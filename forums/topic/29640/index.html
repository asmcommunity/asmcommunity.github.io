<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Physical Addresses - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29640" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29640">Physical Addresses</a></p>
   <div class="post" id="post-209275">
    <div class="subject"><a href="#post-209275">Physical Addresses</a></div>
    <div class="body">.model small<br />.stack 100h<br />.data<br /><br />num1 DW 127<br />num2 DW 55<br />msg DB &#039;The NULL message&#039;, 0<br />sum DW ?<br /><br />.CODE<br />main proc<br /> &nbsp; &nbsp;.STARTUP<br />inst1: push number1 <br />inst2: push number2 <br /> &nbsp; &nbsp; &nbsp; &nbsp; call donothing<br />done:<br />.EXIT<br />main ENDP<br /><br />We assume the following registers have the following values: CS = 0F00, SS = 0C00 and DS = 0E00<br /><br />Now I need to know the physical address (in hex) of number 2. The back of the book says 0E002 which clearly goes with DS. I know how we got 0E002 ((Segment value * 16) + Offset value) but I don&#039;t know why we&#039;re looking at DS for number2, what is the connection?<br /><br />Can somebody please explain this? Thanks.<br /> &nbsp;<br /></div>
    <div class="meta">Posted on 2009-10-23 20:43:56 by dre</div>
   </div>
   <div class="post" id="post-209277">
    <div class="subject"><a href="#post-209277">Re: Physical Addresses</a></div>
    <div class="body"><div class="quote">why we&#039;re looking at DS for number2, what is the connection?</div><br /><br />DS = Data Segment</div>
    <div class="meta">Posted on 2009-10-23 21:25:06 by JimmyClif</div>
   </div>
   <div class="post" id="post-209290">
    <div class="subject"><a href="#post-209290">Re: Physical Addresses</a></div>
    <div class="body">If you could disassemble your code, or look at it in a debugger, you&#039;d see that the &quot;.STARTUP&quot; macro expands to something like:<br /><br />mov ax, data<br />mov ds, ax<br />mov es, ax ;??? dunno if it does this or not<br /><br />That will explain how ds gets to point to your data segment - it isn&#039;t &quot;automatic&quot; (commonly, the OS takes care of this for us, but not in MZ executables). Addresses generally - there are exceptions! - default to &quot;ds:something&quot; or &quot;ds:&quot;...<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2009-10-24 09:31:51 by fbkotler</div>
   </div>
   <div class="post" id="post-209292">
    <div class="subject"><a href="#post-209292">Re: Physical Addresses</a></div>
    <div class="body">So let me get this straight...anything under the data segment is covered under DS? For the same example would the physical address of num1 be 0E000 ? Suppose we were asked the physical address of inst1, what register would we refer to for that and why?<br /><br />Thanks again.</div>
    <div class="meta">Posted on 2009-10-24 13:16:16 by dre</div>
   </div>
   <div class="post" id="post-209313">
    <div class="subject"><a href="#post-209313">Re: Physical Addresses</a></div>
    <div class="body">anyone? lol</div>
    <div class="meta">Posted on 2009-10-25 20:47:59 by dre</div>
   </div>
   <div class="post" id="post-209314">
    <div class="subject"><a href="#post-209314">Re: Physical Addresses</a></div>
    <div class="body">I guess so. The physical address for num1 would be at offset 00 as it&#039;s the first word at the beginning of the data segment. According to the specs you mentioned at the beginning DS = 0E00 it would be 0E00+00=0E00.<br /><br />For the code segment same rules apply. Although different instructions compile into different byte/word/dword patterns. A push is usually a few bytes - the byte code for push and the address to push.<br /><br />Disassemble it and have a peek :)<br /></div>
    <div class="meta">Posted on 2009-10-25 21:23:11 by JimmyClif</div>
   </div>
   <div class="post" id="post-209315">
    <div class="subject"><a href="#post-209315">Re: Physical Addresses</a></div>
    <div class="body">Sorry, I missed that one...<br /><br />The CPU executes instructions at cs:ip (or eip or rip). I mentioned that ds may not point to our data segment unless we (or the OS) make it so. We can assume that cs points to our code segment - or we&#039;d be executing some other code!<br /><br />However, that &quot;.STARTUP&quot; macro generates some code. Best disassemble it as JimmyClif suggests. (or look at a &quot;list&quot; file... How&#039;s Masm do that? &quot;/l myfile.lst&quot;?) Or RTFM and see what that macro expands to. In spite of the fact that &quot;inst1&quot; is the first instruction &quot;showing&quot;, I don&#039;t think it&#039;s the first instruction...<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2009-10-25 21:38:05 by fbkotler</div>
   </div>
   <div class="post" id="post-209319">
    <div class="subject"><a href="#post-209319">Re: Physical Addresses</a></div>
    <div class="body"><div class="quote"><br />So let me get this straight...anything under the data segment is covered under DS? For the same example would the physical address of num1 be 0E000 ? Suppose we were asked the physical address of inst1, what register would we refer to for that and why?</div><br /><br />Segments are two-fold: there are compiler/linker segments and CPU segments (we&#039;re talking about real-address mode, right?). Compiler and linker use segments to arrange pieces of code/data in particular order to build executable image, CPU uses segment registers to access these pieces.<br /><br />Let&#039;s examine your (slightly modified) source MASM listing:<br /><br /><pre><code><br />				.model small<br />				.stack 100h<br /> 0000				.data<br /><br /> 0000 007F			num1 DW 127<br /> 0002 0037			num2 DW 55<br /> 0004 54 68 65 20 4E 55		msg DB &#039;The NULL message&#039;, 0<br /> &nbsp; &nbsp; &nbsp; 4C 4C 20 6D 65 73<br /> &nbsp; &nbsp; &nbsp; 73 61 67 65 00<br /> 0015 0000			sum DW ?<br /><br /> 0000				.CODE<br /> 0000				main proc<br />				 &nbsp; &nbsp;.STARTUP<br /> 0000			 &nbsp; *@Startup:<br /> 0000 &nbsp;BA ---- R	 &nbsp; *	 &nbsp; &nbsp;mov &nbsp; &nbsp;dx, DGROUP<br /> 0003 &nbsp;8E DA		 &nbsp; *	 &nbsp; &nbsp;mov &nbsp; &nbsp;ds, dx<br /> 0005 &nbsp;8C D3		 &nbsp; *	 &nbsp; &nbsp;mov &nbsp; &nbsp;bx, ss<br /> 0007 &nbsp;2B DA		 &nbsp; *	 &nbsp; &nbsp;sub &nbsp; &nbsp;bx, dx<br /> 0009 &nbsp;D1 E3		 &nbsp; *	 &nbsp; &nbsp;shl &nbsp; &nbsp;bx, 001h<br /> 000B &nbsp;D1 E3		 &nbsp; *	 &nbsp; &nbsp;shl &nbsp; &nbsp;bx, 001h<br /> 000D &nbsp;D1 E3		 &nbsp; *	 &nbsp; &nbsp;shl &nbsp; &nbsp;bx, 001h<br /> 000F &nbsp;D1 E3		 &nbsp; *	 &nbsp; &nbsp;shl &nbsp; &nbsp;bx, 001h<br /> 0011 &nbsp;FA		 &nbsp; *	 &nbsp; &nbsp;cli &nbsp; &nbsp;<br /> 0012 &nbsp;8E D2		 &nbsp; *	 &nbsp; &nbsp;mov &nbsp; &nbsp;ss, dx<br /> 0014 &nbsp;03 E3		 &nbsp; *	 &nbsp; &nbsp;add &nbsp; &nbsp;sp, bx<br /> 0016 &nbsp;FB		 &nbsp; *	 &nbsp; &nbsp;sti &nbsp; &nbsp;<br /> 0017 &nbsp;FF 36 0000 R		inst1: push num1;;; was number1<br /> 001B &nbsp;FF 36 0002 R		inst2: push num2;;; was number2<br /> 001F &nbsp;E8 0004			 &nbsp; &nbsp; &nbsp; &nbsp; call donothing<br /> 0022				done:<br />				.EXIT<br /> 0022 &nbsp;B4 4C		 &nbsp; *	 &nbsp; &nbsp;mov &nbsp; &nbsp;ah, 04Ch<br /> 0024 &nbsp;CD 21		 &nbsp; *	 &nbsp; &nbsp;int &nbsp; &nbsp;021h<br /> 0026				main ENDP<br /><br /> 0026				donothing PROC<br /> 0026 &nbsp;C2 0008				ret	8<br /> 0029				donothing ENDP<br /><br />					END<br /></code></pre><br /><br />As you can see, <strong>.STARTUP</strong> directive expands to some code that loads <strong>ds</strong> with the value of <strong>DGROUP</strong> symbol (and fiddles with ss:sp). DGROUP is segment group, <strong>.MODEL SMALL</strong> directive creates it containing _DATA (from .DATA) and STACK (from .STACK) segments (listing won&#039;t tell you that, just believe me ;-).<br /><br /><pre><code><br />Segments and Groups:<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;N a m e &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size &nbsp; &nbsp; Length &nbsp; Align &nbsp; Combine Class<br /><br />DGROUP . . . . . . . . . . . . .	GROUP<br />_DATA &nbsp;. . . . . . . . . . . . .	16 Bit	 0017	 &nbsp;Word	 &nbsp;Public &nbsp;&#039;DATA&#039;	<br />STACK &nbsp;. . . . . . . . . . . . .	16 Bit	 0100	 &nbsp;Para	 &nbsp;Stack	 &nbsp;&#039;STACK&#039;	 <br />_TEXT &nbsp;. . . . . . . . . . . . .	16 Bit	 0029	 &nbsp;Word	 &nbsp;Public &nbsp;&#039;CODE&#039;	<br /></code></pre><br /><br />Now it&#039;s the fun part: linker builds .Exe placing segments in the following order: <strong>_TEXT</strong> segment (it&#039;s your .CODE), <u>word</u>-aligned <strong>_DATA</strong> segment because <strong>num1</strong> and <strong>num2</strong> are referenced from <strong>_TEXT</strong>, STACK segment (this is the catch: _DATA grouped with STACK, stack is unitialized data, the only way to put unitialized data in MZ .Exe is to stuff it behind EOF ;-). _TEXT is 29h bytes in size, so the next word-aligned offset is 2Ah, 2:0Ah in seg:off-speak. Hence <strong>mov ds, DGROUP</strong> will become <strong>mov ds, 2</strong> (and relocation record in .Exe header), and <strong>push num1/push num2</strong> will become <strong>push [000Ah]/push [000Ch]</strong> respectively.<br /><br />Isn&#039;t MASM simplified segment control somewhat oversimplified? Let&#039;s try full-blown segmentation:<br /><br /><pre><code><br /> 0000				_DATA	SEGMENT	PARA PUBLIC USE16 &quot;DATA&quot;<br /> 0000 007F			num1 DW 127<br /> 0002 0037			num2 DW 55<br /> 0004 54 68 65 20 4E 55		msg DB &#039;The NULL message&#039;, 0<br /> &nbsp; &nbsp; &nbsp; 4C 4C 20 6D 65 73<br /> &nbsp; &nbsp; &nbsp; 73 61 67 65 00<br /> 0015 0000			sum DW ?<br /> 0017				_DATA	ENDS<br /><br /> 0000				_TEXT	SEGMENT	PARA PUBLIC USE16 &quot;CODE&quot;<br /> 0000				main proc<br /> 0000 &nbsp;B8 ---- R			mov	ax, _DATA<br /> 0003 &nbsp;8E D8				mov	ds, ax<br />					ASSUME	ds:_DATA<br /> 0005 &nbsp;FF 36 0000 R		inst1: push num1;;; was number1<br /> 0009 &nbsp;FF 36 0002 R		inst2: push num2;;; was number2<br /> 000D &nbsp;E8 0004			 &nbsp; &nbsp; &nbsp; &nbsp; call donothing<br /> 0010				done:<br /> 0010 &nbsp;B4 4C				mov	ah, 4Ch<br /> 0012 &nbsp;CD 21				int	21h<br /> 0014				main ENDP<br /><br /> 0014				donothing PROC<br /> 0014 &nbsp;C2 0008				ret	8<br /> 0017				donothing ENDP<br /><br /> 0017				_TEXT	ENDS<br /><br /> 0000				STACK	SEGMENT	PARA STACK USE16 &quot;STACK&quot;<br /> 0000 &nbsp;0100 [				db	100h dup (?)<br /> &nbsp; &nbsp; &nbsp; &nbsp;00<br /> &nbsp; &nbsp; &nbsp; ]<br /> 0100				STACK	ENDS<br /><br />					END	main<br /></code></pre><br /><br />Looks similar, but links different: _DATA goes to beginning of the image, <strong>mov ax, _DATA</strong> will be <strong>mov ax, 0</strong> (+reloc) and <strong>num1</strong>/<strong>num2</strong> offsets will be 0 and 2.<br /><br />The crucial point is the <strong>ASSUME ds:_DATA</strong> directive: it tells assembler that symbols in _DATA segment can be accessed via <strong>ds</strong>. Look at this:<br /><br /><pre><code><br /> 0000				_DATA	SEGMENT	PARA PUBLIC USE16 &quot;DATA&quot;<br /> 0000 007F			num1 DW 127<br /> 0002 0037			num2 DW 55<br /> 0004 54 68 65 20 4E 55		msg DB &#039;The NULL message&#039;, 0<br /> &nbsp; &nbsp; &nbsp; 4C 4C 20 6D 65 73<br /> &nbsp; &nbsp; &nbsp; 73 61 67 65 00<br /> 0015 0000			sum DW ?<br /> 0017				_DATA	ENDS<br /><br /> 0000				_TEXT	SEGMENT	PARA PUBLIC USE16 &quot;CODE&quot;<br /> 0000				main proc<br /> 0000 &nbsp;B8 ---- R			mov	ax, _DATA<br /> 0003 &nbsp;8E D8				mov	ds, ax<br />					ASSUME	es:_DATA;;; here I&#039;d changed ds to es<br /> 0005 &nbsp;26: FF 36 0000 R		inst1: push num1;;; notice es: segment override prefix? It&#039;s 26:<br />					ASSUME	ds:_DATA;;; now _DATA is addressable thru ds too<br /> 000A &nbsp;FF 36 0002 R		inst2: push num2;;; no prefix, as expected<br /> 000E &nbsp;E8 0004			 &nbsp; &nbsp; &nbsp; &nbsp; call donothing<br /> 0011				done:<br /> 0011 &nbsp;B4 4C				mov	ah, 4Ch<br /> 0013 &nbsp;CD 21				int	21h<br /> 0015				main ENDP<br /><br /> 0015				donothing PROC<br /> 0015 &nbsp;C2 0008				ret	8<br /> 0018				donothing ENDP<br /><br /> 0018				_TEXT	ENDS<br /><br /> 0000				STACK	SEGMENT	PARA STACK USE16 &quot;STACK&quot;<br /> 0000 &nbsp;0100 [				db	100h dup (?)<br /> &nbsp; &nbsp; &nbsp; &nbsp;00<br /> &nbsp; &nbsp; &nbsp; ]<br /> 0100				STACK	ENDS<br /><br />					END	main<br /></code></pre><br /><br />Examine carefully, it&#039;s almost self-explaining. I didn&#039;t even set up <strong>es</strong> before <strong>ASSUME</strong> ;-).<br /><br />In hypothetical situation (as if MASM can assemble absolute code/initialized data and loader can appropriately place them in memory) <strong>mov ax, _DATA</strong> will become <strong>mov ax, 0E00h</strong>.<br /><br />Are you getting the gist of it? I can explain it further, but conclusion is simple: &quot;Set up segment register and tell compiler about that&quot;.</div>
    <div class="meta">Posted on 2009-10-26 05:11:38 by baldr</div>
   </div>
  </div>
 </body>
</html>