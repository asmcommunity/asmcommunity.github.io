<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>File Mapping, how does it work? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=18202" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=18202">File Mapping, how does it work?</a></p>
   <div class="post" id="post-140814">
    <div class="subject"><a href="#post-140814">File Mapping, how does it work?</a></div>
    <div class="body">Hi , in my audio engine when I request a stream to be played off the harddisk, I just quickly read the file in chunks using ReadFile, but it is horribly slow as I can hear crackles and pops meaning that the ReadFile function is not responding as fast as it should to make this work. But I heard that I could map a very large file into memory without loading it explicitly and accessing like a regular buffer in RAM, can I use it for this purpose (streaming audio data of a hard disk or CD) and can you explain how I can make use of it (f0dder please save me, I believe it was you that suggested this before).</div>
    <div class="meta">Posted on 2004-05-03 17:30:41 by x86asm</div>
   </div>
   <div class="post" id="post-140823">
    <div class="subject"><a href="#post-140823">File Mapping, how does it work?</a></div>
    <div class="body">You can probably do this for audio yes... I don't know if it will be fast enough for chop-free audio though (a defragmented file also helps :)).<br />It works quite simple... You create a filemapping object... I believe CreateFile(), CreateFileMapping(), MapViewOfFile().<br />Then you get a pointer to the start of the file in memory.<br />What the OS does is quite simple. At the start, the file is not in memory yet, and all pages in the range of the memorymap are set up to cause an exception on access.<br />When you access such a page, the OS will catch the exception, read in that page from the file, make the page accessible, and continue your program.<br />So you can just randomly access the memory, and it will appear like the file is completely in memory, since the OS will transparently read in the pages on-demand (and it can also unload pages again, when they haven't been accessed in a while).</div>
    <div class="meta">Posted on 2004-05-03 17:54:19 by Scali</div>
   </div>
   <div class="post" id="post-140825">
    <div class="subject"><a href="#post-140825">File Mapping, how does it work?</a></div>
    <div class="body">You can open the file with CreateFile, then the map with CreateFileMapping. When you want to &quot;read&quot; stuff, make a call to MapViewOfFile with the section you want to read. If the whole file fits in RAM, just map it entirely (don't try this for large files under Win9X, the OS is just too dumb and will end up filling the RAM).<br /><br />Readfile should work well though, it's probably easier to adapt yuor existing code to use asynchronous calls rather than file mappings, as I understand mappings won't give you much of a speed gain compared to Readfile (if used well). Particularly since you will be doing a sequential scan.</div>
    <div class="meta">Posted on 2004-05-03 17:57:36 by QvasiModo</div>
   </div>
   <div class="post" id="post-140831">
    <div class="subject"><a href="#post-140831">File Mapping, how does it work?</a></div>
    <div class="body">File mapping will be slower than ReadFile calls, as ReadFile doesn't incur the Page Fault exception overheads. Ok, you don't get a #PF for each 4k page, more like 64kb - but obviously no pagefaults are better than &quot;just a few&quot;. Memory-mapped files can make things easy, but it's slower than regular file access.<br /><br />The trick is to preload your data, or have a background worker thread with a modified priority, and a good signalling system. Ie, don't read from file when the playback buffer is empty, but when it's 2/3rd done or something like that.<br /><br />Async file I/O could probably also be blended in for good results.<br /><br />Also, have a look here:<br /><a target="_blank" href="http://www.flipcode.com/cgi-bin/msg.cgi?showThread=Tip-ReducingGameLoadTimes&amp;forum=totd&amp;id=-1">http://www.flipcode.com/cgi-bin/msg.cgi?showThread=Tip-ReducingGameLoadTimes&amp;forum=totd&amp;id=-1</a></div>
    <div class="meta">Posted on 2004-05-03 18:20:27 by f0dder</div>
   </div>
   <div class="post" id="post-140853">
    <div class="subject"><a href="#post-140853">File Mapping, how does it work?</a></div>
    <div class="body">You can get a litle help from DirectX (DirectSound) seccondary play buffers:<br />they have an option to notify you when a certain play position was reached in the buffer/stream.<br />(btw leave the primary buffer playing at all times for low latency)<br /><br />So, on that notify procedure you can just read another chunk of audio data inside your buffer. <br /><br />Keep this notify position 2-3s ahead of  buffer end and you should be safe most of the time. Of course occasional stalls might still occur, like when a huge App is starting (3Dstudio Max :D) or when YM will pop-up a message window :grin:. Everything can be solved with a bigger buffer ;)<br /><br /><br />There is nothing faster than a well written ReadFile algorithm. And it is logical since a big part of on OS performance is based on fast reading and writtiong files ... this is a basic and important function of an OS.</div>
    <div class="meta">Posted on 2004-05-04 02:29:14 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-140896">
    <div class="subject"><a href="#post-140896">File Mapping, how does it work?</a></div>
    <div class="body"><div class="quote"><em>Originally posted by f0dder </em><br />File mapping will be slower than ReadFile calls, as ReadFile doesn't incur the Page Fault exception overheads. Ok, you don't get a #PF for each 4k page, more like 64kb - but obviously no pagefaults are better than &quot;just a few&quot;. Memory-mapped files can make things easy, but it's slower than regular file access.<br /><br /></div><br /><br />IIRC, you've made this claim before, and it was just as incorrect then as it is now.<br />Try writing two programs that step sequentially through a large file, one that reads the data 4KB at a time and one that walks a pointer through a memory mapped file. You'll find that the performance is virtually identical.<br /><br />As for the page fault issue, what on earth makes you think that copying file data across buffers between kernel and user space is going to be a whole lot better? <br /><br />Memory mapped files, however, can take a big lead when you're working on small chunks of the file (particularly r/w, random access, though this doesn't particularly apply to the OP's problem, I suspect).<br /><br />Bottom line is that you've seen this argument before, you've seen sample programs that demonstrate that what you're claiming is not true. So why do you continue to insist that memory mapped files are so much slower?  Again, you don't have to believe me -- try it yourself.<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2004-05-04 15:17:10 by rhyde</div>
   </div>
   <div class="post" id="post-140900">
    <div class="subject"><a href="#post-140900">File Mapping, how does it work?</a></div>
    <div class="body"><div class="quote"><br />Try writing two programs that step sequentially through a large file, one that reads the data 4KB at a time and one that walks a pointer through a memory mapped file. You'll find that the performance is virtually identical.</div><br />Why 4Kb at a time? Memory mapped files implementation on win32 reads 64kb at a time..<br /><br /><div class="quote"><br />As for the page fault issue, what on earth makes you think that copying file data across buffers between kernel and user space is going to be a whole lot better?</div><br />The file data isn't being copied anyway...<br /><br /><div class="quote"><br />Memory mapped files, however, can take a big lead when you're working on small chunks of the file (particularly r/w, random access, though this doesn't particularly apply to the OP's problem, I suspect).</div><br />No, the advantages for memory mapped files are IPC, large virtual memory allocations and convenience at times.</div>
    <div class="meta">Posted on 2004-05-04 15:32:19 by death</div>
   </div>
   <div class="post" id="post-140902">
    <div class="subject"><a href="#post-140902">File Mapping, how does it work?</a></div>
    <div class="body">I would recommend an async reading strategy anyway, into a cyclic buffer with 2 or perhaps 3 sections.</div>
    <div class="meta">Posted on 2004-05-04 15:52:06 by Scali</div>
   </div>
   <div class="post" id="post-140905">
    <div class="subject"><a href="#post-140905">File Mapping, how does it work?</a></div>
    <div class="body"><div class="quote"><br />one that reads the data 4KB at a time and one that walks a pointer through a memory mapped file.<br /></div><br />Why would I want to do ReadFile with 4kb buffers? The advantage regular ReadFile gives you is, among other things, that you can control the buffer size. By the use of a larger buffer size, you get fewer of the costy ring3&lt;&gt;ring0 transitions. Besides, thankfully, the #PF's aren't done per 4kb page when dealing with MMF's - so the buffer should be at least 64kb. I wouldn't use such a small buffer if dealing with 'massive' files though, but probably rather between 256-1024kb.<br /><br />You can't really do async I/O with MMF either...<br /><br /><div class="quote"><br />Memory mapped files, however, can take a big lead when you're working on small chunks of the file (particularly r/w, random access, though this doesn't particularly apply to the OP's problem, I suspect).<br /></div><br />If your current algorithm is &quot;read byte, modify byte, write byte&quot; - then, yes, the memory mapped approach will be better. If that's your data usage pattern and you can't use a smarter algorithm, then memory mapped files might turn out better.<br /><br />However, the context of this thread is streaming in audio data. This means you need all the bytes, you need them linearly, and you need rather massive amounts (well, if streaming a regular .wav anyway). The only advantage MMF brings here is convenience - and you put yourself at the mercy of the windows caching and read-ahead strategy rather than keeping full control.<br /><br />Btw, when dealing with writable MMF, you fortunately don't get a #PF for every write access. The page is written as dirty, and the &quot;lazy page writer&quot; thread then, according to internal windows strategies, determine when to write the page to disk and mark the page clean. This means that you don't really know when data will be flushed, and that you (with a very scattered access pattern) could be causing a lot of #PF's. Would take &quot;a bunch of logic&quot; to improve on this with regular file access, and the overhead might not be worth it. Then again, the topic in this thread is not random data access but linear streaming of audio data.<br /><br /><div class="quote"><br />As for the page fault issue, what on earth makes you think that copying file data across buffers between kernel and user space is going to be a whole lot better?<br /></div><br />If this buffer copying takes place, rather than reading directly to the user-supplied buffer, I would very much suspect that a simple memory copy routine takes a lot less time than the overhead of a pagefault, the checks needed to figure out why it happened (should we terminate the program, is it a valid pagefault (ie, MMF), et cetera.) Yes, a lot of this overhead will drown in the disk I/O overhead...<br /><br />Anyway, I would recommend async I/O if you don't need 9x support, or a background worker thread with adjusted priority, signalled when the audio buffer is &quot;running low&quot;, doing regular ReadFile I/O.</div>
    <div class="meta">Posted on 2004-05-04 16:03:44 by f0dder</div>
   </div>
  </div>
 </body>
</html>