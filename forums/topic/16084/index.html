<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Motorolla 68000 processor - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16084" />
    <link rel="next" href="../?id=16084&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=16084">Motorolla 68000 processor</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=16084&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=16084&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="16084" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=16084&amp;page=2">&gt;</a><a href="../?id=16084&amp;page=2">&raquo;</a></form>   <div class="post" id="post-124706">
    <div class="subject"><a href="#post-124706">Motorolla 68000 processor</a></div>
    <div class="body">Hi everyone!<br /><br />I was wondering how to switch bits in the 68000. By this I mean that if I have lets say 3FE0 hex, which is 0011 1111 1110 0000 in binary, I need it to become 7FC, which is 0000 0111 1111 0011 binary.<br /><br />I don't know if I should put it on the stack (which I don't really know how that works).  I've tried rotating, but without success.  I've tried many many other things, but I just can't seem to get a grasp on this.<br /><br />Any help would be appreciated.</div>
    <div class="meta">Posted on 2003-11-18 16:15:36 by stimpyzu</div>
   </div>
   <div class="post" id="post-124707">
    <div class="subject"><a href="#post-124707">Motorolla 68000 processor</a></div>
    <div class="body">Isn't the SWAP instruction for that ? I think it's equivalent to BSWAP in the x86 family.</div>
    <div class="meta">Posted on 2003-11-18 16:28:57 by donkey</div>
   </div>
   <div class="post" id="post-124709">
    <div class="subject"><a href="#post-124709">Motorolla 68000 processor</a></div>
    <div class="body">I had thought of that.<br /><br />But the swap instruction swaps register halves.  So if I use that instruction on 3FE0, I end up with E03F.<br /><br />Thanks anyway!</div>
    <div class="meta">Posted on 2003-11-18 16:54:04 by stimpyzu</div>
   </div>
   <div class="post" id="post-124710">
    <div class="subject"><a href="#post-124710">Motorolla 68000 processor</a></div>
    <div class="body">680x0 instructions for bits shifts are: lsl/lsr/asl/asr/rol/ror<br /><br />move.w #$3fe0,d0<br />lsr.w #3,d0<br /><br />d0 will be equal to $7fc<br /><br />All simply.<br /><br /><br />h.</div>
    <div class="meta">Posted on 2003-11-18 17:28:10 by hitchhikr</div>
   </div>
   <div class="post" id="post-124721">
    <div class="subject"><a href="#post-124721">Motorolla 68000 processor</a></div>
    <div class="body">Thanks, that works for that case, but it doesn't &quot;switch&quot; the last bit with the first bit, so it doesn't work in every case.  Maybe I didnt explain myself properly.<br /><br />Basically I have an &quot;image&quot; made out of 1's that needs to be flipped around.<br /><br />If I have 3FE0 hex, which is 0011 1111 1110 0000 in binary, I need to switch bit 0 with bit 15, then bit 1 with bit 14, and so on.  In this case it gives me 7FC hex, which is 0000 0111 1111 0011 binary.  So using LSR does work, but only for this one.<br /><br />What I need to do is a loop that will change 16 successive different lines in this fashion. Some could be changed using LSR, but the number of shifts to make is different in different cases.<br /><br />But when I get to this next line for example, 3878 hex, or 0011 1000 0111 1000 binary, the end result has to be 0001 1110 0001 1100 or 1E1C hex.<br /><br />As you can see, because this is in a loop, I don't see how the lsl/lsr/asl/asr/rol/ror instructions can be used since every case is different.<br /><br />That is just the first part, after that I have to rotate the image 90 degrees and for that, I don't think I'll ever get it done!!!<br /><br />But if anyone can help with the &quot;switching&quot; of the bits, I would truly appreciate it.  I am at my wits end, I've tried so many different things at this point that I'm starting to repeat things that I've done..... I think I'm going mad!!!</div>
    <div class="meta">Posted on 2003-11-18 19:24:25 by stimpyzu</div>
   </div>
   <div class="post" id="post-124728">
    <div class="subject"><a href="#post-124728">Motorolla 68000 processor</a></div>
    <div class="body">Simplest way to reverse bits is with a lookup table.<br /><br />In MASM:<span style="font-size:0><pre><code>ReverseByteTable	BYTE \<br />	00h,80h,40h,0C0h,20h,0A0h,60h,0E0h,10h,90h,50h,0D0h,30h,0B0h,70h,0F0h,<br />	08h,88h,48h,0C8h,28h,0A8h,68h,0E8h,18h,98h,58h,0D8h,38h,0B8h,78h,0F8h,<br />	04h,84h,44h,0C4h,24h,0A4h,64h,0E4h,14h,94h,54h,0D4h,34h,0B4h,74h,0F4h,<br />	0Ch,8Ch,4Ch,0CCh,2Ch,0ACh,6Ch,0ECh,1Ch,9Ch,5Ch,0DCh,3Ch,0BCh,7Ch,0FCh<br />		BYTE \<br />	02h,82h,42h,0C2h,22h,0A2h,62h,0E2h,12h,92h,52h,0D2h,32h,0B2h,72h,0F2h,<br />	0Ah,8Ah,4Ah,0CAh,2Ah,0AAh,6Ah,0EAh,1Ah,9Ah,5Ah,0DAh,3Ah,0BAh,7Ah,0FAh,<br />	06h,86h,46h,0C6h,26h,0A6h,66h,0E6h,16h,96h,56h,0D6h,36h,0B6h,76h,0F6h,<br />	0Eh,8Eh,4Eh,0CEh,2Eh,0AEh,6Eh,0EEh,1Eh,9Eh,5Eh,0DEh,3Eh,0BEh,7Eh,0FEh<br />		BYTE \<br />	01h,81h,41h,0C1h,21h,0A1h,61h,0E1h,11h,91h,51h,0D1h,31h,0B1h,71h,0F1h,<br />	09h,89h,49h,0C9h,29h,0A9h,69h,0E9h,19h,99h,59h,0D9h,39h,0B9h,79h,0F9h,<br />	05h,85h,45h,0C5h,25h,0A5h,65h,0E5h,15h,95h,55h,0D5h,35h,0B5h,75h,0F5h,<br />	0Dh,8Dh,4Dh,0CDh,2Dh,0ADh,6Dh,0EDh,1Dh,9Dh,5Dh,0DDh,3Dh,0BDh,7Dh,0FDh<br />		BYTE \<br />	03h,83h,43h,0C3h,23h,0A3h,63h,0E3h,13h,93h,53h,0D3h,33h,0B3h,73h,0F3h,<br />	0Bh,8Bh,4Bh,0CBh,2Bh,0ABh,6Bh,0EBh,1Bh,9Bh,5Bh,0DBh,3Bh,0BBh,7Bh,0FBh,<br />	07h,87h,47h,0C7h,27h,0A7h,67h,0E7h,17h,97h,57h,0D7h,37h,0B7h,77h,0F7h,<br />	0Fh,8Fh,4Fh,0CFh,2Fh,0AFh,6Fh,0EFh,1Fh,9Fh,5Fh,0DFh,3Fh,0BFh,7Fh,0FFh</code></pre></span>...if you want to do it in code use the bit instructions (btst, bset, bclr, bchg) and some branching.</div>
    <div class="meta">Posted on 2003-11-18 20:11:25 by bitRAKE</div>
   </div>
   <div class="post" id="post-124733">
    <div class="subject"><a href="#post-124733">Motorolla 68000 processor</a></div>
    <div class="body">Thanks but I have no idea what that table means :)  I am relatively new at this.  I'm sure your pointing me in the right direction, but I am still struggling and absolutely not understanding how this can be done.<br /><br />I have been trying and trying to use btst, bset, bclr, bchg.  The first image I had to do was the negative of the original image.  So I used bchg on that without a problem.....<br /><br />Now I understand that BTST tests the bit without changing anything, BCLR puts the bit to 0 and BSET puts it to 1.  But I don't see how that helps me in anyway.<br /><br />For example, I'll shorten the binary numbers here, I have 0001 0111 and have to make it 1110 1000.  Now if I test bit #4 (we start at bit 0 right?) I find that bit is 0.  Then I test bit #3 which is 1.  I need to switch these 2 bits.  I can't say if 0 then set to 1 or if 1 then clear to 0 because I may have to switch two 1's or 2 0's.  That throws my IF THEN idea right out the door!<br /><br />How can I say &quot;put bit 4 into bit 3&quot; and &quot;put bit 3 into bit 4&quot;?  That's the only way I can see how to do this.<br /><br />Or, I'm thinking if I could just store in memory the binary number itself, then I could retrieve it backwards.  But I don't know how to do that.  Everytime I store a number I get a hex number.  I can't figure out how to store a binary number.  I tried to put it in the status register, but that was a flop too...... <br /><br />I've looked all over the net, message boards, my textbook, tutorials, etc.... nothing tells me how I can do this.<br /><br />I am including the image so that anyone reading this may understand what I mean. Obviously, the periods are 0's.<br /><br /><br /><pre><code><br />IMAGE       DC.W    $AAAA      ;................<br />            DC.W    $0000      ;................<br />            DC.W    $3FE0      ;..111111111.....<br />            DC.W    $3FF0      ;..1111111111....<br />            DC.W    $3878      ;..111....1111...<br />            DC.W    $3838      ;..111.....111...<br />            DC.W    $3838      ;..111.....111...<br />            DC.W    $3870      ;..111....111....<br />            DC.W    $3FE0      ;..111111111.....<br />            DC.W    $3FE0      ;..111111111.....<br />            DC.W    $3870      ;..111....111....<br />            DC.W    $3870      ;..111....111....<br />            DC.W    $3838      ;..111.....111...<br />            DC.W    $3838      ;..111.....111...<br />            DC.W    $0000      ;................<br />            DC.W    $0000      ;................<br />            DC.L    $C0C0C0C0  ;Marker at the end of original image<br /><br /></code></pre><br /><br />If anyone has any idea, I'm willing to try anything at this point.  I trully appreciate everybody reading this post.</div>
    <div class="meta">Posted on 2003-11-18 21:05:25 by stimpyzu</div>
   </div>
   <div class="post" id="post-124737">
    <div class="subject"><a href="#post-124737">Motorolla 68000 processor</a></div>
    <div class="body"><div class="quote"><br />Thanks but I have no idea what that table means :)  I am relatively new at this.  I'm sure your pointing me in the right direction, but I am still struggling and absolutely not understanding how this can be done.<br /><br />I have been trying and trying to use btst, bset, bclr, bchg.  The first image I had to do was the negative of the original image.  So I used bchg on that without a problem.....<br /><br />Now I understand that BTST tests the bit without changing anything, BCLR puts the bit to 0 and BSET puts it to 1.  But I don't see how that helps me in anyway.<br /><br />For example, I'll shorten the binary numbers here, I have 0001 0111 and have to make it 1110 1000.  Now if I test bit #4 (we start at bit 0 right?) I find that bit is 0.  Then I test bit #3 which is 1.  I need to switch these 2 bits.  I can't say if 0 then set to 1 or if 1 then clear to 0 because I may have to switch two 1's or 2 0's.  That throws my IF THEN idea right out the door!<br /><br />How can I say &quot;put bit 4 into bit 3&quot; and &quot;put bit 3 into bit 4&quot;?  That's the only way I can see how to do this.<br /><br />Or, I'm thinking if I could just store in memory the binary number itself, then I could retrieve it backwards.  But I don't know how to do that.  Everytime I store a number I get a hex number.  I can't figure out how to store a binary number.  I tried to put it in the status register, but that was a flop too...... <br /><br />I've looked all over the net, message boards, my textbook, tutorials, etc.... nothing tells me how I can do this.<br /><br />I am including the image so that anyone reading this may understand what I mean. Obviously, the periods are 0's.<br /><br /><br /><pre><code><br />IMAGE       DC.W    $AAAA      ;................<br />            DC.W    &#91;QUOTE&#93;&#91;i&#93;Originally posted by stimpyzu &#91;/i&#93;<br />&#91;B&#93;Thanks but I have no idea what that table means &#58;&#41;  I am relatively new at this.  I'm sure your pointing me in the right direction, but I am still struggling and absolutely not understanding how this can be done.<br /><br />I have been trying and trying to use btst, bset, bclr, bchg.  The first image I had to do was the negative of the original image.  So I used bchg on that without a problem.....<br /><br />Now I understand that BTST tests the bit without changing anything, BCLR puts the bit to 0 and BSET puts it to 1.  But I don't see how that helps me in anyway.<br /><br />For example, I'll shorten the binary numbers here, I have 0001 0111 and have to make it 1110 1000.  Now if I test bit #4 &#40;we start at bit 0 right?&#41; I find that bit is 0.  Then I test bit #3 which is 1.  I need to switch these 2 bits.  I can't say if 0 then set to 1 or if 1 then clear to 0 because I may have to switch two 1's or 2 0's.  That throws my IF THEN idea right out the door!<br /><br />How can I say &quot;put bit 4 into bit 3&quot; and &quot;put bit 3 into bit 4&quot;?  That's the only way I can see how to do this.<br /><br />Or, I'm thinking if I could just store in memory the binary number itself, then I could retrieve it backwards.  But I don't know how to do that.  Everytime I store a number I get a hex number.  I can't figure out how to store a binary number.  I tried to put it in the status register, but that was a flop too...... <br /><br />I've looked all over the net, message boards, my textbook, tutorials, etc.... nothing tells me how I can do this.<br /><br />I am including the image so that anyone reading this may understand what I mean. Obviously, the periods are 0's.<br /><br /><br />&#91;code&#93;<br />IMAGE       DC.W    $AAAA      ;................<br />            DC.W    $0000      ;................<br />            DC.W    $3FE0      ;..111111111.....<br />            DC.W    $3FF0      ;..1111111111....<br />            DC.W    $3878      ;..111....1111...<br />            DC.W    $3838      ;..111.....111...<br />            DC.W    $3838      ;..111.....111...<br />            DC.W    $3870      ;..111....111....<br />            DC.W    $3FE0      ;..111111111.....<br />            DC.W    $3FE0      ;..111111111.....<br />            DC.W    $3870      ;..111....111....<br />            DC.W    $3870      ;..111....111....<br />            DC.W    $3838      ;..111.....111...<br />            DC.W    $3838      ;..111.....111...<br />            DC.W    $0000      ;................<br />            DC.W    $0000      ;................<br />            DC.L    $C0C0C0C0  ;Marker at the end of original image<br /><br />&#91;/code&#93;<br /><br />If anyone has any idea, I'm willing to try anything at this point.  I trully appreciate everybody reading this post. &#91;/B&#93;&#91;/QUOTE&#93;00      ;................<br />            DC.W    FE0      ;..111111111.....<br />            DC.W    FF0      ;..1111111111....<br />            DC.W    78      ;..111....1111...<br />            DC.W    38      ;..111.....111...<br />            DC.W    38      ;..111.....111...<br />            DC.W    70      ;..111....111....<br />            DC.W    FE0      ;..111111111.....<br />            DC.W    FE0      ;..111111111.....<br />            DC.W    70      ;..111....111....<br />            DC.W    70      ;..111....111....<br />            DC.W    38      ;..111.....111...<br />            DC.W    38      ;..111.....111...<br />            DC.W    &#91;QUOTE&#93;&#91;i&#93;Originally posted by stimpyzu &#91;/i&#93;<br />&#91;B&#93;Thanks but I have no idea what that table means &#58;&#41;  I am relatively new at this.  I'm sure your pointing me in the right direction, but I am still struggling and absolutely not understanding how this can be done.<br /><br />I have been trying and trying to use btst, bset, bclr, bchg.  The first image I had to do was the negative of the original image.  So I used bchg on that without a problem.....<br /><br />Now I understand that BTST tests the bit without changing anything, BCLR puts the bit to 0 and BSET puts it to 1.  But I don't see how that helps me in anyway.<br /><br />For example, I'll shorten the binary numbers here, I have 0001 0111 and have to make it 1110 1000.  Now if I test bit #4 &#40;we start at bit 0 right?&#41; I find that bit is 0.  Then I test bit #3 which is 1.  I need to switch these 2 bits.  I can't say if 0 then set to 1 or if 1 then clear to 0 because I may have to switch two 1's or 2 0's.  That throws my IF THEN idea right out the door!<br /><br />How can I say &quot;put bit 4 into bit 3&quot; and &quot;put bit 3 into bit 4&quot;?  That's the only way I can see how to do this.<br /><br />Or, I'm thinking if I could just store in memory the binary number itself, then I could retrieve it backwards.  But I don't know how to do that.  Everytime I store a number I get a hex number.  I can't figure out how to store a binary number.  I tried to put it in the status register, but that was a flop too...... <br /><br />I've looked all over the net, message boards, my textbook, tutorials, etc.... nothing tells me how I can do this.<br /><br />I am including the image so that anyone reading this may understand what I mean. Obviously, the periods are 0's.<br /><br /><br />&#91;code&#93;<br />IMAGE       DC.W    $AAAA      ;................<br />            DC.W    $0000      ;................<br />            DC.W    $3FE0      ;..111111111.....<br />            DC.W    $3FF0      ;..1111111111....<br />            DC.W    $3878      ;..111....1111...<br />            DC.W    $3838      ;..111.....111...<br />            DC.W    $3838      ;..111.....111...<br />            DC.W    $3870      ;..111....111....<br />            DC.W    $3FE0      ;..111111111.....<br />            DC.W    $3FE0      ;..111111111.....<br />            DC.W    $3870      ;..111....111....<br />            DC.W    $3870      ;..111....111....<br />            DC.W    $3838      ;..111.....111...<br />            DC.W    $3838      ;..111.....111...<br />            DC.W    $0000      ;................<br />            DC.W    $0000      ;................<br />            DC.L    $C0C0C0C0  ;Marker at the end of original image<br /><br />&#91;/code&#93;<br /><br />If anyone has any idea, I'm willing to try anything at this point.  I trully appreciate everybody reading this post. &#91;/B&#93;&#91;/QUOTE&#93;00      ;................<br />            DC.W    &#91;QUOTE&#93;&#91;i&#93;Originally posted by stimpyzu &#91;/i&#93;<br />&#91;B&#93;Thanks but I have no idea what that table means &#58;&#41;  I am relatively new at this.  I'm sure your pointing me in the right direction, but I am still struggling and absolutely not understanding how this can be done.<br /><br />I have been trying and trying to use btst, bset, bclr, bchg.  The first image I had to do was the negative of the original image.  So I used bchg on that without a problem.....<br /><br />Now I understand that BTST tests the bit without changing anything, BCLR puts the bit to 0 and BSET puts it to 1.  But I don't see how that helps me in anyway.<br /><br />For example, I'll shorten the binary numbers here, I have 0001 0111 and have to make it 1110 1000.  Now if I test bit #4 &#40;we start at bit 0 right?&#41; I find that bit is 0.  Then I test bit #3 which is 1.  I need to switch these 2 bits.  I can't say if 0 then set to 1 or if 1 then clear to 0 because I may have to switch two 1's or 2 0's.  That throws my IF THEN idea right out the door!<br /><br />How can I say &quot;put bit 4 into bit 3&quot; and &quot;put bit 3 into bit 4&quot;?  That's the only way I can see how to do this.<br /><br />Or, I'm thinking if I could just store in memory the binary number itself, then I could retrieve it backwards.  But I don't know how to do that.  Everytime I store a number I get a hex number.  I can't figure out how to store a binary number.  I tried to put it in the status register, but that was a flop too...... <br /><br />I've looked all over the net, message boards, my textbook, tutorials, etc.... nothing tells me how I can do this.<br /><br />I am including the image so that anyone reading this may understand what I mean. Obviously, the periods are 0's.<br /><br /><br />&#91;code&#93;<br />IMAGE       DC.W    $AAAA      ;................<br />            DC.W    $0000      ;................<br />            DC.W    $3FE0      ;..111111111.....<br />            DC.W    $3FF0      ;..1111111111....<br />            DC.W    $3878      ;..111....1111...<br />            DC.W    $3838      ;..111.....111...<br />            DC.W    $3838      ;..111.....111...<br />            DC.W    $3870      ;..111....111....<br />            DC.W    $3FE0      ;..111111111.....<br />            DC.W    $3FE0      ;..111111111.....<br />            DC.W    $3870      ;..111....111....<br />            DC.W    $3870      ;..111....111....<br />            DC.W    $3838      ;..111.....111...<br />            DC.W    $3838      ;..111.....111...<br />            DC.W    $0000      ;................<br />            DC.W    $0000      ;................<br />            DC.L    $C0C0C0C0  ;Marker at the end of original image<br /><br />&#91;/code&#93;<br /><br />If anyone has any idea, I'm willing to try anything at this point.  I trully appreciate everybody reading this post. &#91;/B&#93;&#91;/QUOTE&#93;00      ;................<br />            DC.L    $C0C0C0C0  ;Marker at the end of original image<br /><br /></code></pre><br /><br />If anyone has any idea, I'm willing to try anything at this point.  I trully appreciate everybody reading this post. </div><br /><br />So you want to reverse the bit patterns in the image so that the R is flipped horizontally ? Am I correct?<br /><br />Well this is how I would do it :<br /><br />-Clear a 16-bit register or memory space to zero<br />-Initialize one byte mask (one that is equal to one) -Use this to test low byte (If I remember correctly the 68000 is big endian so you'll have to remember this fact).<br />-Initialize another byte mask to 80h<br /><br />Basically what you do is you test the upper bit mask (one that is equal to 80h) with the high byte of the 16-bit WORD row in your character map. And if the bit is set, set bit 0 then shift the upper bit mask right, etc. <br /><br />I'll have to think about it, LOL! but you can see where I'm going, use a mask, test each individual bit then if the bit is set the opposite bit in the zeroed 16-bit register or memory location. If someone else hasn't helped you or you haven't reached a solution I'll think about it and let you know.</div>
    <div class="meta">Posted on 2003-11-18 21:30:39 by x86asm</div>
   </div>
   <div class="post" id="post-124739">
    <div class="subject"><a href="#post-124739">Motorolla 68000 processor</a></div>
    <div class="body">That's right.  It's gotta end up like this:  (sorry the first line should of been 0000.....AAAA was for testing purpuses)<br /><br />$0000      ;................<br />$0000      ;................<br />$7FC        ;.....111111111..<br />$FFC        ;....1111111111..<br />$1E1C      ;...1111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$E1C        ;....111....111..<br />$7FC        ;.....111111111..<br />$7FC        ;.....111111111..<br />$E1C        ;....111....111..<br />$E1C        ;....111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$0000      ;................<br />$0000      ;................<br /><br /><br />Although it doesn't look it, the &quot;R&quot; is left side right (flipped on the y-axis).<br /><br />After I have to do another one that rotates the &quot;R&quot; 90 degrees to the clockwise.... but that's another storie :)  ... I figure if I can understand this one, maybe I'll figure out the other one.</div>
    <div class="meta">Posted on 2003-11-18 21:43:09 by stimpyzu</div>
   </div>
   <div class="post" id="post-124741">
    <div class="subject"><a href="#post-124741">Motorolla 68000 processor</a></div>
    <div class="body">oops, better with code tags.... my bad...<br /><br /><pre><code><br />$0000 ;................<br />$0000 ;................<br />$7FC  ;.....111111111..<br />$FFC  ;....1111111111..<br />$1E1C ;...1111....111..<br />$1C1C ;...111.....111..<br />$1C1C ;...111.....111..<br />$E1C  ;....111....111..<br />$7FC  ;.....111111111..<br />$7FC  ;.....111111111..<br />$E1C  ;....111....111..<br />$E1C  ;....111....111..<br />$1C1C ;...111.....111..<br />$1C1C ;...111.....111..<br />$0000 ;................<br />$0000 ;................<br /></code></pre></div>
    <div class="meta">Posted on 2003-11-18 21:45:48 by stimpyzu</div>
   </div>
   <div class="post" id="post-124743">
    <div class="subject"><a href="#post-124743">Motorolla 68000 processor</a></div>
    <div class="body"><div class="quote"><br />That's right.  It's gotta end up like this:  (sorry the first line should of been 0000.....AAAA was for testing purpuses)<br /><br /><div class="quote"><em>Originally posted by stimpyzu </em><br /><strong>That's right.  It's gotta end up like this:  (sorry the first line should of been 0000.....AAAA was for testing purpuses)<br /><br />$0000      ;................<br />$0000      ;................<br />$7FC        ;.....111111111..<br />$FFC        ;....1111111111..<br />$1E1C      ;...1111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$E1C        ;....111....111..<br />$7FC        ;.....111111111..<br />$7FC        ;.....111111111..<br />$E1C        ;....111....111..<br />$E1C        ;....111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$0000      ;................<br />$0000      ;................<br /><br /><br />Although it doesn't look it, the &quot;R&quot; is left side right (flipped on the y-axis).<br /><br />After I have to do another one that rotates the &quot;R&quot; 90 degrees to the clockwise.... but that's another storie :)  ... I figure if I can understand this one, maybe I'll figure out the other one. </strong></div>00      ;................<br /><div class="quote"><em>Originally posted by stimpyzu </em><br /><strong>That's right.  It's gotta end up like this:  (sorry the first line should of been 0000.....AAAA was for testing purpuses)<br /><br />$0000      ;................<br />$0000      ;................<br />$7FC        ;.....111111111..<br />$FFC        ;....1111111111..<br />$1E1C      ;...1111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$E1C        ;....111....111..<br />$7FC        ;.....111111111..<br />$7FC        ;.....111111111..<br />$E1C        ;....111....111..<br />$E1C        ;....111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$0000      ;................<br />$0000      ;................<br /><br /><br />Although it doesn't look it, the &quot;R&quot; is left side right (flipped on the y-axis).<br /><br />After I have to do another one that rotates the &quot;R&quot; 90 degrees to the clockwise.... but that's another storie :)  ... I figure if I can understand this one, maybe I'll figure out the other one. </strong></div>00      ;................<br />FC        ;.....111111111..<br />$FFC        ;....1111111111..<br /><div class="quote"><em>Originally posted by stimpyzu </em><br /><strong>That's right.  It's gotta end up like this:  (sorry the first line should of been 0000.....AAAA was for testing purpuses)<br /><br />$0000      ;................<br />$0000      ;................<br />$7FC        ;.....111111111..<br />$FFC        ;....1111111111..<br />$1E1C      ;...1111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$E1C        ;....111....111..<br />$7FC        ;.....111111111..<br />$7FC        ;.....111111111..<br />$E1C        ;....111....111..<br />$E1C        ;....111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$0000      ;................<br />$0000      ;................<br /><br /><br />Although it doesn't look it, the &quot;R&quot; is left side right (flipped on the y-axis).<br /><br />After I have to do another one that rotates the &quot;R&quot; 90 degrees to the clockwise.... but that's another storie :)  ... I figure if I can understand this one, maybe I'll figure out the other one. </strong></div>E1C      ;...1111....111..<br /><div class="quote"><em>Originally posted by stimpyzu </em><br /><strong>That's right.  It's gotta end up like this:  (sorry the first line should of been 0000.....AAAA was for testing purpuses)<br /><br />$0000      ;................<br />$0000      ;................<br />$7FC        ;.....111111111..<br />$FFC        ;....1111111111..<br />$1E1C      ;...1111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$E1C        ;....111....111..<br />$7FC        ;.....111111111..<br />$7FC        ;.....111111111..<br />$E1C        ;....111....111..<br />$E1C        ;....111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$0000      ;................<br />$0000      ;................<br /><br /><br />Although it doesn't look it, the &quot;R&quot; is left side right (flipped on the y-axis).<br /><br />After I have to do another one that rotates the &quot;R&quot; 90 degrees to the clockwise.... but that's another storie :)  ... I figure if I can understand this one, maybe I'll figure out the other one. </strong></div>C1C      ;...111.....111..<br /><div class="quote"><em>Originally posted by stimpyzu </em><br /><strong>That's right.  It's gotta end up like this:  (sorry the first line should of been 0000.....AAAA was for testing purpuses)<br /><br />$0000      ;................<br />$0000      ;................<br />$7FC        ;.....111111111..<br />$FFC        ;....1111111111..<br />$1E1C      ;...1111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$E1C        ;....111....111..<br />$7FC        ;.....111111111..<br />$7FC        ;.....111111111..<br />$E1C        ;....111....111..<br />$E1C        ;....111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$0000      ;................<br />$0000      ;................<br /><br /><br />Although it doesn't look it, the &quot;R&quot; is left side right (flipped on the y-axis).<br /><br />After I have to do another one that rotates the &quot;R&quot; 90 degrees to the clockwise.... but that's another storie :)  ... I figure if I can understand this one, maybe I'll figure out the other one. </strong></div>C1C      ;...111.....111..<br />$E1C        ;....111....111..<br />FC        ;.....111111111..<br />FC        ;.....111111111..<br />$E1C        ;....111....111..<br />$E1C        ;....111....111..<br /><div class="quote"><em>Originally posted by stimpyzu </em><br /><strong>That's right.  It's gotta end up like this:  (sorry the first line should of been 0000.....AAAA was for testing purpuses)<br /><br />$0000      ;................<br />$0000      ;................<br />$7FC        ;.....111111111..<br />$FFC        ;....1111111111..<br />$1E1C      ;...1111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$E1C        ;....111....111..<br />$7FC        ;.....111111111..<br />$7FC        ;.....111111111..<br />$E1C        ;....111....111..<br />$E1C        ;....111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$0000      ;................<br />$0000      ;................<br /><br /><br />Although it doesn't look it, the &quot;R&quot; is left side right (flipped on the y-axis).<br /><br />After I have to do another one that rotates the &quot;R&quot; 90 degrees to the clockwise.... but that's another storie :)  ... I figure if I can understand this one, maybe I'll figure out the other one. </strong></div>C1C      ;...111.....111..<br /><div class="quote"><em>Originally posted by stimpyzu </em><br /><strong>That's right.  It's gotta end up like this:  (sorry the first line should of been 0000.....AAAA was for testing purpuses)<br /><br />$0000      ;................<br />$0000      ;................<br />$7FC        ;.....111111111..<br />$FFC        ;....1111111111..<br />$1E1C      ;...1111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$E1C        ;....111....111..<br />$7FC        ;.....111111111..<br />$7FC        ;.....111111111..<br />$E1C        ;....111....111..<br />$E1C        ;....111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$0000      ;................<br />$0000      ;................<br /><br /><br />Although it doesn't look it, the &quot;R&quot; is left side right (flipped on the y-axis).<br /><br />After I have to do another one that rotates the &quot;R&quot; 90 degrees to the clockwise.... but that's another storie :)  ... I figure if I can understand this one, maybe I'll figure out the other one. </strong></div>C1C      ;...111.....111..<br /><div class="quote"><em>Originally posted by stimpyzu </em><br /><strong>That's right.  It's gotta end up like this:  (sorry the first line should of been 0000.....AAAA was for testing purpuses)<br /><br />$0000      ;................<br />$0000      ;................<br />$7FC        ;.....111111111..<br />$FFC        ;....1111111111..<br />$1E1C      ;...1111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$E1C        ;....111....111..<br />$7FC        ;.....111111111..<br />$7FC        ;.....111111111..<br />$E1C        ;....111....111..<br />$E1C        ;....111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$0000      ;................<br />$0000      ;................<br /><br /><br />Although it doesn't look it, the &quot;R&quot; is left side right (flipped on the y-axis).<br /><br />After I have to do another one that rotates the &quot;R&quot; 90 degrees to the clockwise.... but that's another storie :)  ... I figure if I can understand this one, maybe I'll figure out the other one. </strong></div>00      ;................<br /><div class="quote"><em>Originally posted by stimpyzu </em><br /><strong>That's right.  It's gotta end up like this:  (sorry the first line should of been 0000.....AAAA was for testing purpuses)<br /><br />$0000      ;................<br />$0000      ;................<br />$7FC        ;.....111111111..<br />$FFC        ;....1111111111..<br />$1E1C      ;...1111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$E1C        ;....111....111..<br />$7FC        ;.....111111111..<br />$7FC        ;.....111111111..<br />$E1C        ;....111....111..<br />$E1C        ;....111....111..<br />$1C1C      ;...111.....111..<br />$1C1C      ;...111.....111..<br />$0000      ;................<br />$0000      ;................<br /><br /><br />Although it doesn't look it, the &quot;R&quot; is left side right (flipped on the y-axis).<br /><br />After I have to do another one that rotates the &quot;R&quot; 90 degrees to the clockwise.... but that's another storie :)  ... I figure if I can understand this one, maybe I'll figure out the other one. </strong></div>00      ;................<br /><br /><br />Although it doesn't look it, the &quot;R&quot; is left side right (flipped on the y-axis).<br /><br />After I have to do another one that rotates the &quot;R&quot; 90 degrees to the clockwise.... but that's another storie :)  ... I figure if I can understand this one, maybe I'll figure out the other one. </div><br /><br />I must admit you have a tricky problem on your hand, I wrote x86 assembly code to do something like this except the data wasn't bitmapped but each pixel was represented with byte data<br /><br />Hold on, maybe I got something here try this:<br />(I'm sorry my friend but I'm not too familiar with 68K code so I can't help you code wise)<br /><br />BitSet: 01h (byte)<br /><br />MaskL: 01h (byte)      <br />MaskH: 80h (byte)<br /><br />Out: 0000h (WORD)<br /> <br />Read High byte of row into a register  (D0?)<br />Load MaskH into another register        (D1?)<br /><br />Do a AND (or an instruction equivalent to the x86 TEST instruction) D0 with D1<br />so maybe like<br /><br /><br /><br />AND.B D1,D0  ? (Save registers if you cannot find equivalent to x86 TEST)<br /><br />If ZeroFlag==0 THEN OR OutLow,BitSet<br /><br />Shift D0 to the right one place<br />Shift Bitset to the left by one place<br /><br />Jump if Zero flag is not set to the AND instruction<br /><br />Read low byte into register (D0 ?)<br />Read MaskL into register (D1)<br /><br />AND.B D1,D0  ? (Save registers if you cannot find equivalent to x86 TEST)<br /><br />Reload Bitset with 01h<br /><br />If ZeroFlag==0 THEN OR OutHigh,BitSet<br /><br />Shift D0 to the left one place<br />Shift Bitset to the left by one place<br /><br />Ihavent tested this code but I think it may do the trick<br />simply loop this code for every line.<br /><br />Let me know if you have any problems. I've always wanted to code for the 68K :D</div>
    <div class="meta">Posted on 2003-11-18 21:58:43 by x86asm</div>
   </div>
   <div class="post" id="post-124744">
    <div class="subject"><a href="#post-124744">Motorolla 68000 processor</a></div>
    <div class="body">I'm quite sleepy now, I would have stayed onlinme to see if it worked for you, but I must go to sleep good night!<br /><br />Please let us know how it goes thanks<br /><br />Happy Coding :alright:</div>
    <div class="meta">Posted on 2003-11-18 22:06:54 by x86asm</div>
   </div>
   <div class="post" id="post-124745">
    <div class="subject"><a href="#post-124745">Motorolla 68000 processor</a></div>
    <div class="body">I'll kindda getting where your coming from, I had thought of a mask, but couldn't figure out what to use.  I will look at it later (I've had enough for now)  I'm pretty sleepy too.....<br /><br />I will let you know how it goes..... thanks for all your help!!!!</div>
    <div class="meta">Posted on 2003-11-18 22:10:01 by stimpyzu</div>
   </div>
   <div class="post" id="post-124747">
    <div class="subject"><a href="#post-124747">Motorolla 68000 processor</a></div>
    <div class="body">I would have made it like that, the principle is to swap the bits first 4 by 4 then 2 by 2 and at last 1 by 1 using bits masking. I wrote it for the intel proc so my conversion to the 68k may not be accurate.<br />(and this probably could be optimized).<br /><br />68000 version:<br /><br /><pre><code><br />		; In&#58; word in d0<br />		; Out&#58; swapped word in d0<br />		ror.b	#4,d0			; swap bits 4 by 4<br />		ror.w	#8,d0<br />		ror.b   #4,d0<br />		move.w	d0,d1			; swap bits 2 by 2<br />		and.w	#$3333,d0<br />		and.w	#$cccc,d1<br />		add.w	d0,d0<br />		add.w	d0,d0<br />		lsr.w	#2,d1<br />		or.w	d1,d0<br />		move.w	d0,d1			; swap bits 1 by 1<br />		and.w	#$5555,d0<br />		and.w	#$aaaa,d1<br />		add.w	d0,d0<br />		lsr.w	#1,d1<br />		or.w	d1,d0<br /></code></pre><br /><br />Intel version:<br /><br /><pre><code><br />		; In&#58; word in ax<br />		; Out&#58; swapped word in ax<br />		ror	al,4<br />		ror	ah,4<br />		ror	ax,8<br />		mov	bx,ax<br />		and	ax,03333h<br />		and	bx,0cccch<br />		shl	ax,2<br />		shr	bx,2<br />		or	ax,bx<br />		mov	bx,ax<br />		and	ax,05555h<br />		and	bx,0aaaah<br />		add	ax,ax<br />		shr	bx,1<br />		or	ax,bx<br /></code></pre><br /><br />But i think a byte based lookup table will be *much* faster, especially on a 68000.<br />The table would be composed of 256 bytes written in reverse order, you still have to swap the 2 lo/hi bytes tho and use them as indexes.<br /><br />h.</div>
    <div class="meta">Posted on 2003-11-18 22:38:31 by hitchhikr</div>
   </div>
   <div class="post" id="post-124751">
    <div class="subject"><a href="#post-124751">Motorolla 68000 processor</a></div>
    <div class="body">Are you guys trying to code for speed???<br /><br />The simplest way (without using a lookup table) is to use two registers.<br />Load one register with the value you want to bit reverse. You may want to clear the second register.<br /><br />Shift the first register right once to move the rightmost bit into the C or X flag.<br />Shift (you probably need to use a rotate instruction) the other register left to shift in the C or X flag into the rightmost bit. It will shift the previous bits left.<br />Repeat the two shifts until you are done.<br /><br />The first register won't have the number anymore, and the second register will contain the bit-reversed image.<br /><br />(Design tactic illustrated here: separate the source of your computations from the result.)</div>
    <div class="meta">Posted on 2003-11-19 00:36:26 by tenkey</div>
   </div>
   <div class="post" id="post-124795">
    <div class="subject"><a href="#post-124795">Motorolla 68000 processor</a></div>
    <div class="body"><div class="quote"><br />I would have made it like that, the principle is to swap the bits first 4 by 4 then 2 by 2 and at last 1 by 1 using bits masking. I wrote it for the intel proc so my conversion to the 68k may not be accurate.<br />(and this probably could be optimized).<br /><br />68000 version:<br /><br /><pre><code><br />		; In&#58; word in d0<br />		; Out&#58; swapped word in d0<br />		ror.b	#4,d0			; swap bits 4 by 4<br />		ror.w	#8,d0<br />		ror.b   #4,d0<br />		move.w	d0,d1			; swap bits 2 by 2<br />		and.w	#33,d0<br />		and.w	#$cccc,d1<br />		add.w	d0,d0<br />		add.w	d0,d0<br />		lsr.w	#2,d1<br />		or.w	d1,d0<br />		move.w	d0,d1			; swap bits 1 by 1<br />		and.w	#55,d0<br />		and.w	#$aaaa,d1<br />		add.w	d0,d0<br />		lsr.w	#1,d1<br />		or.w	d1,d0<br /></code></pre><br /><br />Intel version:<br /><br /><pre><code><br />		; In&#58; word in ax<br />		; Out&#58; swapped word in ax<br />		ror	al,4<br />		ror	ah,4<br />		ror	ax,8<br />		mov	bx,ax<br />		and	ax,03333h<br />		and	bx,0cccch<br />		shl	ax,2<br />		shr	bx,2<br />		or	ax,bx<br />		mov	bx,ax<br />		and	ax,05555h<br />		and	bx,0aaaah<br />		add	ax,ax<br />		shr	bx,1<br />		or	ax,bx<br /></code></pre><br /><br />But i think a byte based lookup table will be *much* faster, especially on a 68000.<br />The table would be composed of 256 bytes written in reverse order, you still have to swap the 2 lo/hi bytes tho and use them as indexes.<br /><br />h. </div><br /><br />It would also be a lot easier to do so as well, are you short on RAM stimpyzu?</div>
    <div class="meta">Posted on 2003-11-19 07:38:37 by x86asm</div>
   </div>
   <div class="post" id="post-124826">
    <div class="subject"><a href="#post-124826">Motorolla 68000 processor</a></div>
    <div class="body"><div class="quote"> the principle is to swap the bits first 4 by 4 then 2 by 2 and at last 1 by 1 using bits masking. </div> <br /><br />That's exactly what I needed to know, thanks <strong>hitchhikr</strong>.  You have any ideas how to rotate it 90 degrees clockwise?  I know that I'm going to have to get every bit from the 16 columns and then turn them into a row.  But I need to work on flipping the image first.  I'm going to look at your code and break it down so that I can understand what you did.<br /><br /><br /><strong>x86asm</strong>  The object is to get it to work and to get us to know how the instructions work, so speed is not an issue.  We haven't discussed the byte based lookup table yet.<br /><br /><strong>tenkey</strong>  as I said to x86asm, speed is of no importance.  Thanks for your input, it gave me a new perspective on all of this.<br /><br /><br />Again, if anyone has any ideas on how to rotate the image 90 degrees clockwise, comments and suggestions would truly be appreciated.<br /><br />You guys are the best. :alright:    I've learned more here in a day than I have in 2 weeks of searching like a fool.</div>
    <div class="meta">Posted on 2003-11-19 14:32:13 by stimpyzu</div>
   </div>
   <div class="post" id="post-124835">
    <div class="subject"><a href="#post-124835">Motorolla 68000 processor</a></div>
    <div class="body">The simplest way is still to shift (or rotate) one bit out and rotate it into the byte(s) where you want to store the image. You will need to build the new image in a separate location. I would not be surprised if there are faster ways (after all, this is a pixel-by-pixel method), but this way is simple and easy to validate.<br /><br />(Oops, this is counterclockwise, but you should be able to convert this procedure into a clockwise version.)<br /><br />Remember to use the rotate version that uses the X or C flag to shift in the bit that's being copied.<br /><br />I will illustrate one iteration of the process with a 4x4 matrix:<br /><pre><code>&#91;b&#93;initial data&#91;/b&#93;<br />line 1 = 1234  row 1 = ....<br />line 2 = 5678  row 2 = ....<br />line 3 = abcd  row 3 = ....<br />line 4 = efgh  row 4 = ....<br /><br />rotate line 1 right<br />rotate row 1 left<br />line 1 = .123  row 1 = ...4<br />line 2 = 5678  row 2 = ....<br />line 3 = abcd  row 3 = ....<br />line 4 = efgh  row 4 = ....<br /><br />rotate line 2 right<br />rotate row 1 left<br />line 1 = .123  row 1 = ..48<br />line 2 = .567  row 2 = ....<br />line 3 = abcd  row 3 = ....<br />line 4 = efgh  row 4 = ....<br /><br />rotate line 3 right<br />rotate row 1 left<br />line 1 = .123  row 1 = .48d<br />line 2 = .567  row 2 = ....<br />line 3 = .abc  row 3 = ....<br />line 4 = efgh  row 4 = ....<br /><br />rotate line 4 right<br />rotate row 1 left<br />line 1 = .123  row 1 = 48dh<br />line 2 = .567  row 2 = ....<br />line 3 = .abc  row 3 = ....<br />line 4 = .efg  row 4 = ....<br /></code></pre>Repeat the process with the other rows.<br /><br />The above might be called a &quot;collection&quot; method. Below is the &quot;distribution&quot; method.<br /><pre><code>rotate line 1 right<br />rotate row 1 left<br />line 1 = .123  row 1 = ...4<br />line 2 = 5678  row 2 = ....<br />line 3 = abcd  row 3 = ....<br />line 4 = efgh  row 4 = ....<br /><br />rotate line 1 right<br />rotate row 2 left<br />line 1 = ..12  row 1 = ...4<br />line 2 = 5678  row 2 = ...3<br />line 3 = abcd  row 3 = ....<br />line 4 = efgh  row 4 = ....<br /><br />rotate line 1 right<br />rotate row 3 left<br />line 1 = ...1  row 1 = ...4<br />line 2 = 5678  row 2 = ...3<br />line 3 = abcd  row 3 = ...2<br />line 4 = efgh  row 4 = ....<br /><br />rotate line 1 right<br />rotate row 4 left<br />line 1 = ....  row 1 = ...4<br />line 2 = 5678  row 2 = ...3<br />line 3 = abcd  row 3 = ...2<br />line 4 = efgh  row 4 = ...1<br /></code></pre>Repeat the process with the other lines and you will get this rotated image:<br /><pre><code>48dh<br />37cg<br />26bf<br />15ae<br /></code></pre></div>
    <div class="meta">Posted on 2003-11-19 15:30:42 by tenkey</div>
   </div>
   <div class="post" id="post-124844">
    <div class="subject"><a href="#post-124844">Motorolla 68000 processor</a></div>
    <div class="body">Thanks TENKEY, that part I understand.  What I don't know how to do is to &quot;save&quot; the bits, bit by bit so that I can end up putting them all back together to give me a hex number.  With a 4x4 matrix I can see that the way you did it is possible, but I don't see how it works with a 16x16 matrix.  Unless I'm missing something ?<br /><br />What I have done, and maybe it's not the right way to do it, is to check every line and then to just &quot;keep&quot; the 1st bits of every line to get my first row.... loop, do the same and keep the 2nd bits of every line for the second column .... and so on.....<br /><br />But I don't know how to &quot;keep&quot; or store the individual bits to bring the 16 bits back again to create my rows.....aarrrrgg!!!<br /><br />Maybe I should do it by groups of 4 bits?<br /><br />Once again, any comments would be appreciated and thank you all for your time!!</div>
    <div class="meta">Posted on 2003-11-19 17:16:22 by stimpyzu</div>
   </div>
   <div class="post" id="post-124854">
    <div class="subject"><a href="#post-124854">Motorolla 68000 processor</a></div>
    <div class="body">The only difference between 4x4 and 16x16 is that you need to do 16 times, what I've done only 4 times.<br /><br />=====<br /><br />There are only two kinds of places that you can &quot;keep&quot; data - registers and memory.<br /><br />It sounds like you are &quot;unpacking&quot; the bits - testing the bits and storing copies of them somewhere, each in a different location.<br /><br />If so, then you need to &quot;pack&quot; them to get the images you want - store a copy of each bit in the bit positions you want them at. Clear the destination to all zeroes, and then you can OR a bit mask to set a particular bit position to 1.<br /><br />=====<br /><br />The shift-out, shift-in procedure doesn't do any packing/unpacking. Shift a destination enough times and the bit you insert at one end of the row will end up in the right position. <br /><br />The shift-out, shift-in procedure uses the ROXR and ROXL instructions. The X flag is stored in the CCR, just like the condition codes N, Z, V, and C.</div>
    <div class="meta">Posted on 2003-11-19 19:57:30 by tenkey</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=16084&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=16084&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="16084" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=16084&amp;page=2">&gt;</a><a href="../?id=16084&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>