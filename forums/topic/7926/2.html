<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Sine Functions - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=7926" />
  <link rel="prev" href="../?id=7926&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=7926">Sine Functions</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=7926&amp;page=1" style="">&laquo;</a><a href="../?id=7926&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="7926" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-58320">
    <div class="subject"><a href="#post-58320">Sine Functions</a></div>
    <div class="body">Thanks guys. I'll probably keep a version of each around and experiment on a bunch of different machines once I know exactly what I'll need for the synthesis engine.<br /><br />And, according to the docs, fsin on the Pentium executes in the U pipe. Which means, nothing can be done in parallel. The k7 has always been much faster for floating point math - fsin just further confirms it.<br /><br />Now, I have to go off in search of coefficients for the faster sine algorithms. <br /><br />- Chris</div>
    <div class="meta">Posted on 2002-09-17 09:35:37 by bit</div>
   </div>
   <div class="post" id="post-58394">
    <div class="subject"><a href="#post-58394">Sine Functions</a></div>
    <div class="body">Here's Sine7. Sorry for the delay, I wasn't able to find time to look at the code. I haven't taken into consideration the optimizations such as using mul instead of div, maybe after I finished all, I'll profile and do some optimization. Probably add some prefetch instructions... This is just a straight translation of the original FPU code.<pre><code>movss	xmm0, x<br />movss	xmm1, xmm0<br />mulss	xmm1, xmm0<br />movss	xmm2, xmm1<br />divss	xmm2, const_42<br />movss	xmm3, const_1<br />movss	xmm4, xmm3<br />movss	xmm5, xmm3<br />subss	xmm3, xmm2<br />mulss	xmm3, xmm1<br />divss	xmm3, const_20<br />subss	xmm4, xmm3<br />mulss	xmm4, xmm1<br />divss	xmm4, const_6<br />subss	xmm5, xmm4<br />mulss	xmm0, xmm5<br />movss	x, xmm0</code></pre>BTW, I'm just doing this for fun. I don't claim these are faster but it should.</div>
    <div class="meta">Posted on 2002-09-17 16:07:20 by stryker</div>
   </div>
   <div class="post" id="post-58425">
    <div class="subject"><a href="#post-58425">Sine Functions</a></div>
    <div class="body">sine9<pre><code>movss	xmm0, x<br />movss	xmm1, xmm0<br />mulss	xmm1, xmm0<br />movss	xmm2, xmm1<br />movss	xmm3, xmm1<br />divss	xmm2, const_72<br />movss	xmm4, const_1<br />movss	xmm5, xmm4<br />movss	xmm6, xmm4<br />movss	xmm7, xmm4<br />subss	xmm4, xmm2<br />mulss	xmm4, xmm1<br />divss	xmm4, const_42<br />subss	xmm5, xmm4<br />mulss	xmm5, xmm1<br />divss	xmm5, const_20<br />subss	xmm6, xmm5<br />mulss	xmm6, xmm1<br />divss	xmm6, const_6<br />subss	xmm7, xmm6<br />mulss	xmm0, xmm7<br />movss	x, xmm0</code></pre></div>
    <div class="meta">Posted on 2002-09-17 23:05:18 by stryker</div>
   </div>
   <div class="post" id="post-58431">
    <div class="subject"><a href="#post-58431">Sine Functions</a></div>
    <div class="body">Sine11<pre><code>movss	xmm0, x<br />movss	xmm1, xmm0<br />mulss	xmm1, xmm0<br />movss	xmm2, xmm1<br />movss	xmm3, xmm1<br />divss	xmm2, const_110<br />movss	xmm4, const_1<br />movss	xmm5, xmm4<br />movss	xmm6, xmm4<br />movss	xmm7, xmm4<br />subss	xmm4, xmm2<br />mulss	xmm4, xmm1<br />divss	xmm4, const_72<br />subss	xmm5, xmm4<br />mulss	xmm5, xmm1<br />movss	xmm4, xmm6<br />divss	xmm5, const_42<br />subss	xmm6, xmm5<br />mulss	xmm6, xmm1<br />divss	xmm6, const_20<br />subss	xmm7, xmm6<br />mulss	xmm7, xmm1<br />divss	xmm7, const_6<br />subss	xmm4, xmm7<br />mulss	xmm0, xmm4<br />movss	x, xmm0</code></pre></div>
    <div class="meta">Posted on 2002-09-17 23:32:20 by stryker</div>
   </div>
   <div class="post" id="post-58585">
    <div class="subject"><a href="#post-58585">Sine Functions</a></div>
    <div class="body">Yet another SSE Sine9<br /><br />It takes about 40-42 clocks on my PIII.  And to use SIMD feature, it implements the Taylor expansion literally.  One obvious drawback is that it supports only single precision.<br /><pre><code><br />        .686<br />        .xmm<br />        .model flat<br />        option casemap&#58;none<br /><br />        .const<br />COEFF   dd      0be2aaaabh ; -1/3!<br />        dd      03c088889h ; 1/5!<br />        dd      0b9500d01h ; -1/7!<br />        dd      03638ef1dh ; 1/9!<br /><br />; float Sine9&#40;float x&#41;<br />        .code<br />Sine9   PROC C<br />        movss   XMM0,&#91;esp+4&#93;<br />        shufps  XMM0,XMM0,0<br />        movaps  XMM1,XMM0<br />        mulps   XMM1,XMM0<br />        movaps  XMM2,XMM1<br />        mulss   XMM1,XMM0<br />        mulss   XMM2,XMM2<br />        movlhps XMM2,XMM1<br />        shufps  XMM2,XMM2,25h<br />        movss   XMM2,XMM0<br />        mulps   XMM2,XMM2<br />        mulps   XMM2,XMM0<br />        mulps   XMM2,COEFF<br />        movhlps XMM1,XMM2<br />        addps   XMM1,XMM2<br />        addss   XMM0,XMM1<br />        shufps  XMM1,XMM1,1<br />        addss   XMM0,XMM1<br />        movss   &#91;esp-4&#93;,XMM0<br />        fld     dword ptr &#91;esp-4&#93;<br />        ret<br />Sine9   ENDP<br />        END<br /></code></pre></div>
    <div class="meta">Posted on 2002-09-18 23:28:38 by Starless</div>
   </div>
   <div class="post" id="post-59035">
    <div class="subject"><a href="#post-59035">Sine Functions</a></div>
    <div class="body">Did you heard about Chebyshev polynoms ?<br />They improve the Taylor series consequently, if I remember correctly.<br /><br />JC</div>
    <div class="meta">Posted on 2002-09-21 15:15:27 by MCoder</div>
   </div>
   <div class="post" id="post-59052">
    <div class="subject"><a href="#post-59052">Sine Functions</a></div>
    <div class="body">Not to put a dampner on ye, but this is what your competing against, Intels MKL:<br /><br />vsSin<br />34.9 Standard Processor<br />33.9 PIII<br />19.6 PIV<br />6.2 Itanium<br /> <br />vdSin<br />49.9 Standard<br />49.9 PIII<br />43.5 PIV<br />7.3 ItaniumTM<br /> <br />Of course that is for bulk processing of multiple Sin values :)</div>
    <div class="meta">Posted on 2002-09-21 18:22:02 by Eóin</div>
   </div>
   <div class="post" id="post-59062">
    <div class="subject"><a href="#post-59062">Sine Functions</a></div>
    <div class="body">MCoder,<br /><br />Thanks for the info. I'll check it out<br /><br />Eoin,<br /><br />shoot!!! those MKL ones are pretty fast. I still haven't started optimizing mine. Anyway, thanks for letting us now. It's a challenge. ;)</div>
    <div class="meta">Posted on 2002-09-21 21:57:17 by stryker</div>
   </div>
   <div class="post" id="post-59064">
    <div class="subject"><a href="#post-59064">Sine Functions</a></div>
    <div class="body">MCoder, yeah those are the coefficients that I have been searching for. So far all I can find is information and coefficients for the cosine.<br /><br />E?in, how accurate are those routines of Intel's and what exactly do you mean by bulk (a pointer to 2 or more values to take the sine on)? Also, I take it the &quot;vs&quot; is single precision and &quot;vd&quot; is double precision? I have some numbers from some Athlons for about 4 cycles in my 5th degree aproximation routine. But, for some reason the timing on the p4's is showing hundreds of cycles (not just for mine either; this happens for the std c routine as well). For whatever reason the AMD's totally smoke the Pentiums in the FP department. Very tragic to see. :)<br /><br />It looks like the MMX version Startless posted if converted to using the Chebyshev coefficients would run as fast as Intels lib, if not faster. And, the one I posted once converted to the Chebyshev coefficients would probably run close to as fast as the vdSin routine, perhaps faster who knows. Of course, these are both 9th degree aproximations and I dunno how accurate Intel's are. <br /><br />Oh yeah E?in, do the routines of Intel's do range reduction?<br /><br />- Chris</div>
    <div class="meta">Posted on 2002-09-21 22:07:58 by bit</div>
   </div>
   <div class="post" id="post-59079">
    <div class="subject"><a href="#post-59079">Sine Functions</a></div>
    <div class="body">More about the Intel algo:<br /><a target="_blank" href="http://www.intel.com/technology/itj/q41999/articles/art_5.htm">http://www.intel.com/technology/itj/q41999/articles/art_5.htm</a><br /><br /><a target="_blank" href="http://www.research.scea.com/gdc2002/fastermath.pdf">http://www.research.scea.com/gdc2002/fastermath.pdf</a><br /><br /><pre><code>; 11 MUL<br />;  5 ADD/SUB<br />;  7 LOAD<br />	fld	x<br />	fld	st<br />	fmul	st,st&#40;1&#41;<br />	fld	one_over_110<br />	fmul	st,st&#40;1&#41;<br />	fld1<br />	fsubr<br />	fmul	st,st&#40;1&#41;<br />	fmul	one_over_72<br />	fld1<br />	fsubr<br />	fmul	st,st&#40;1&#41;<br />	fmul	one_over_42<br />	fld1<br />	fsubr<br />	fmul	st,st&#40;1&#41;<br />	fmul	one_over_20<br />	fld1<br />	fsubr<br />	fmulp	st&#40;1&#41;,st<br />	fmul	one_over_6<br />	fmul	st,st&#40;1&#41;<br />	fsub</code></pre>...and some interesting C++ code (don't know it the comments are true).<br />This isn't my code! :)<pre><code>doubledouble sin&#40;const doubledouble&amp; x&#41; &#123;<br />  static const doubledouble tab&#91;9&#93;=&#123; // tab&#91;b&#93; &#58;= sin&#40;b*Pi/16&#41;...<br />    0.0,<br />    &quot;0.1950903220161282678482848684770222409277&quot;,<br />    &quot;0.3826834323650897717284599840303988667613&quot;,<br />    &quot;0.5555702330196022247428308139485328743749&quot;,<br />    &quot;0.7071067811865475244008443621048490392850&quot;,<br />    &quot;0.8314696123025452370787883776179057567386&quot;,<br />    &quot;0.9238795325112867561281831893967882868225&quot;,<br />    &quot;0.9807852804032304491261822361342390369739&quot;,<br />    1.0<br />  &#125;;<br />  static const doubledouble sinsTab&#91;7&#93; = &#123; // Chebyshev coefficients<br />    &quot;0.9999999999999999999999999999993767021096&quot;,<br />    &quot;-0.1666666666666666666666666602899977158461&quot;,<br />    &quot;8333333333333333333322459353395394180616.0e-42&quot;,<br />    &quot;-1984126984126984056685882073709830240680.0e-43&quot;,<br />    &quot;2755731922396443936999523827282063607870.0e-45&quot;,<br />    &quot;-2505210805220830174499424295197047025509.0e-47&quot;,<br />    &quot;1605649194713006247696761143618673476113.0e-49&quot;<br />  &#125;;<br />  if &#40;fabs&#40;x.h&#40;&#41;&#41;&lt;1.0e-7&#41; return x*&#40;1.0-sqr&#40;x&#41;/3&#41;;<br />  int a,b; doubledouble sins, coss, k1, k3, t2, s, s2, sinb, cosb;<br />  // reduce x&#58; -Pi &lt; x &lt;= Pi<br />  k1=x/doubledouble&#58;&#58;TwoPi; k3=k1-rint&#40;k1&#41;;<br />  // determine integers a and b to minimize |s|, where  s=x-a*Pi/2-b*Pi/16<br />  t2=4*k3;<br />  a=int&#40;rint&#40;t2&#41;&#41;;<br />  b=int&#40;rint&#40;&#40;8*&#40;t2-a&#41;&#41;&#41;&#41;;   // must have |a|&lt;=2 and |b|&lt;=7 now<br />  s=doubledouble&#58;&#58;Pi*&#40;k3+k3-&#40;8*a+b&#41;/16.0&#41;; // s is now reduced argument. -Pi/32 &lt; s &lt; Pi/32<br />  s2=sqr&#40;s&#41;; <br />  // Chebyshev series on -Pi/32..Pi/32, max abs error 2^-98=3.16e-30, whereas<br />  // power series has error 6e-28 at Pi/32 with terms up to x^13 included.<br />  sins=s*&#40;sinsTab&#91;0&#93;+&#40;sinsTab&#91;1&#93;+&#40;sinsTab&#91;2&#93;+&#40;sinsTab&#91;3&#93;+&#40;sinsTab&#91;4&#93;+<br />         &#40;sinsTab&#91;5&#93;+sinsTab&#91;6&#93;*s2&#41;*s2&#41;*s2&#41;*s2&#41;*s2&#41;*s2&#41;;<br />  coss=sqrt&#40;1.0-sqr&#40;sins&#41;&#41;;  // ok as -Pi/32 &lt; s &lt; Pi/32<br />  // here sinb=sin&#40;b*Pi/16&#41; etc.<br />  sinb= &#40;b&gt;=0&#41; ? tab&#91;b&#93; &#58; -tab&#91;-b&#93;; cosb=tab&#91;8-abs&#40;b&#41;&#93;;<br />  if &#40;0==a&#41; &#123;<br />    return  sins*cosb+coss*sinb;<br />  &#125; else if &#40;1==a&#41; &#123;<br />    return -sins*sinb+coss*cosb;<br />  &#125; else if &#40;-1==a&#41; &#123;<br />    return  sins*sinb-coss*cosb;<br />  &#125; else  &#123; // |a|=2<br />    return -sins*cosb-coss*sinb;<br />  &#125;<br />  // i.e. return sins*&#40;cosa*cosb-sina*sinb&#41;+coss*&#40;sina*cosb+cosa*sinb&#41;;<br />&#125;</code></pre></div>
    <div class="meta">Posted on 2002-09-22 02:49:05 by bitRAKE</div>
   </div>
   <div class="post" id="post-59094">
    <div class="subject"><a href="#post-59094">Sine Functions</a></div>
    <div class="body">A quick search of Chebychev and sine with Google lead to:<br /><a target="_blank" href="http://hjem.get2net.dk/bnielsen/sinus.html">http://hjem.get2net.dk/bnielsen/sinus.html</a><br />or with Tchebychev:<br /><a target="_blank" href="http://home.att.net/~numericana/answer/functions.htm">http://home.att.net/~numericana/answer/functions.htm</a><br /><br />Taylor:<br />  sin(x) = x - x^3/3! + x^5/5! - x^7/7! + ...<br /><br />3-leds Chebychev:<br />  sin(x) = x - 0.16605 x^3 + 0.00761 x^5<br /><br />5-leds Chebychev:<br />  sin(x) = x - 0.1666666664 x^3 + 0.0083333315 x^5<br />             - 0.0001984090 x^7 + 0.0000027526 x^9<br />             - 0.0000000239 x^11 <br /><br />Try Chebychev, Chebyshev, Tchebychev, Tchebycheff, etc...<br /><br />JC</div>
    <div class="meta">Posted on 2002-09-22 04:26:07 by MCoder</div>
   </div>
   <div class="post" id="post-59116">
    <div class="subject"><a href="#post-59116">Sine Functions</a></div>
    <div class="body">Bulk means they take in an array of dds/qds depending on the function vs/vd and output an array of answers. They only seem to achieve those clock ratings when dealing with arrays of 100+ elements.<br /><br />I know we've heard again and again that FPU on P4 sucks, but that just means intels given up on it. Unfortunatly with SSE we'll never get better than dq precision but I find it hard to believe that in such circumstance where qwords aren't precise enough speed will be an issue :) .<br /><br />Maybe its just me, but speed in bulk processing is the only place I really think you need it :eek: .</div>
    <div class="meta">Posted on 2002-09-22 07:24:23 by Eóin</div>
   </div>
   <div class="post" id="post-59137">
    <div class="subject"><a href="#post-59137">Sine Functions</a></div>
    <div class="body"><pre><code>; Chebyshev coefficients<br />;cSINc1	REAL8  0.9999999999999999999999999999993767021096<br />cSINc2	REAL8 -0.1666666666666666666666666602899977158461<br />cSINc3	REAL8  0.8333333333333333333322459353395394180616e-2<br />cSINc4	REAL8 -0.1984126984126984056685882073709830240680e-3<br />cSINc5	REAL8  0.2755731922396443936999523827282063607870e-5<br />cSINc6	REAL8 -0.2505210805220830174499424295197047025509e-7<br />cSINc7	REAL8  0.1605649194713006247696761143618673476113e-9<br /><br /><br />;  8 MUL<br />;  6 ADD/SUB<br />;  3 LOAD<br />	fld	x<br />	fld	st<br />	fmul	st, st&#40;1&#41;<br />	fld	cSINc7<br />	fmul	st, st&#40;1&#41;<br />	fadd	cSINc6<br />	fmul	st, st&#40;1&#41;<br />	fadd	cSINc5<br />	fmul	st, st&#40;1&#41;<br />	fadd	cSINc4<br />	fmul	st, st&#40;1&#41;<br />	fadd	cSINc3<br />	fmul	st, st&#40;1&#41;<br />	fadd	cSINc2<br />	fmul	; pop x^2<br />	fmul	st, st&#40;1&#41;<br />	fadd	; pop x</code></pre>Sum of error from -pi/2 to pi/2, 1024 sample points:<br />4.2130688617853282550e-<strong>08</strong> Chebyshev<br />4.1491462730860308530e-06 Taylor<br /><br />1024^2 Sample Points:<br />0.0000428065976113201 Chebyshev<br />0.0042198884936352558 Taylor<br /><br />Look like almost two digits more of accuracy.<br />Now lets take a look at the speed on an Athlon...<br /><br />Average of 100 loops:<br />52.15 cycles Chebyshev<br />60.22 cycles Taylor<br />92.48 cycles FPU (AMD says 96-192)<br /><br />These are actually slow - the dependancies are making the processor very inefficient - your seeing the full latency of each instruction in these times.  The Athlon FPU can do one load/store, one mul, and one add operation per cycle.</div>
    <div class="meta">Posted on 2002-09-22 11:40:17 by bitRAKE</div>
   </div>
   <div class="post" id="post-59156">
    <div class="subject"><a href="#post-59156">Sine Functions</a></div>
    <div class="body">To demostrate the huge dependancies of the algorithm I have shuffled together a dual Chebyshev sine function.  This algorithm executes in the same time as the single sine algorithm above (54 cycles = <strong>27 cycles per sine</strong>)!  Compute the sine for the top two floats on the stack:<pre><code>	fld	st&#40;1&#41;		;	x	y	x<br />	fmul	st, st		;	x*x	y	x<br />	fld	st&#40;1&#41;		;	y	x*x	y	x<br />	fmul	st, st		;	y*y	x*x	y	x<br /><br />	fld	st&#40;1&#41;<br />	fld	cSINc7<br />	fmul	st&#40;1&#41;, st	;	c7	c7*x*x	y*y	x*x	y	x<br /><br />	fmul	st, st&#40;2&#41;	;y<br />	fxch	st&#40;1&#41;<br />	fadd	cSINc6<br /><br />	fmul	st, st&#40;3&#41;	;x<br />	fxch	st&#40;1&#41;<br />	fadd	cSINc6<br /><br />	fmul	st, st&#40;2&#41;	;y<br />	fxch	st&#40;1&#41;<br />	fadd	cSINc5<br /><br />	fmul	st, st&#40;3&#41;	;x<br />	fxch	st&#40;1&#41;<br />	fadd	cSINc5<br /><br />	fmul	st, st&#40;2&#41;	;y<br />	fxch	st&#40;1&#41;<br />	fadd	cSINc4<br /><br />	fmul	st, st&#40;3&#41;	;x<br />	fxch	st&#40;1&#41;<br />	fadd	cSINc4<br /><br />	fmul	st, st&#40;2&#41;	;y<br />	fxch	st&#40;1&#41;<br />	fadd	cSINc3<br /><br />	fmul	st, st&#40;3&#41;	;x<br />	fxch	st&#40;1&#41;<br />	fadd	cSINc3<br /><br />	fmul	st, st&#40;2&#41;	;y<br />	fxch	st&#40;1&#41;<br />	fadd	cSINc2<br /><br />	fmulp	st&#40;3&#41;, st	;x<br />	fadd	cSINc2<br /><br /><br />	fmulp	st&#40;1&#41;, st	;y<br /><br /><br /><br />	fmul	st, st&#40;2&#41;	;y<br /><br /><br /><br />	faddp	st&#40;2&#41;, st	;y<br />	fmul	st, st&#40;2&#41;	;x<br /><br /><br />	faddp	st&#40;2&#41;, st	;x</code></pre>The line spacing gives a little insight on the latency of the instructions.  Note: this is not optimal - the algorithm needs to be re-worked backwards from the end to save a cycle or two.</div>
    <div class="meta">Posted on 2002-09-22 16:07:35 by bitRAKE</div>
   </div>
   <div class="post" id="post-59159">
    <div class="subject"><a href="#post-59159">Sine Functions</a></div>
    <div class="body">MCoder, I was able to find some stuff when searching with the alternate spellings. It would be nice if the transliteration was the same on all sites. Unfortunately, it isn't. Ah well.<br /><br />bitRake, it is interesting to see exactly how much dependency there is. The Chebyshev is always going to be a bit faster than the Taylor for the same amount of accuracy since it distributes the error and can thus get by with a lower term (typically one less). So, with that in mind, converting all my functions to use Chebyshev should be a worthwhile thing. <br /><br />I am still working out in my mind how I am going to organize all of these different versions and which will be the fastest on each of the platforms. Who knows, I may get lucky and be able to get by with Goertzel's algo for the oscillator(s).<br /> <br />- Chris</div>
    <div class="meta">Posted on 2002-09-22 16:28:36 by bit</div>
   </div>
   <div class="post" id="post-59160">
    <div class="subject"><a href="#post-59160">Sine Functions</a></div>
    <div class="body"><strong>bit</strong> (Chris), in the tests above I actually used an extra term on Chebyshev.  The difference in speed is mainly due to fewer FMUL instructions. Four sines at once might keep the Athlon busy. ;)</div>
    <div class="meta">Posted on 2002-09-22 16:36:39 by bitRAKE</div>
   </div>
   <div class="post" id="post-59162">
    <div class="subject"><a href="#post-59162">Sine Functions</a></div>
    <div class="body">Cool. That means it should be a lot faster than the Taylor, but with the same accuracy, when that extra term is removed. I can't wait till I get to the actual writing of the synthesis engine! Right now it is hard to envision how everything is going to fit together (mainly because sound synthesis is a new arena for me).<br /><br />- Chris</div>
    <div class="meta">Posted on 2002-09-22 16:44:00 by bit</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=7926&amp;page=1" style="">&laquo;</a><a href="../?id=7926&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="7926" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>