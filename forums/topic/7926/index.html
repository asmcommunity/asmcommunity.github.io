<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Sine Functions - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=7926" />
    <link rel="next" href="../?id=7926&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=7926">Sine Functions</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=7926&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=7926&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="7926" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=7926&amp;page=2">&gt;</a><a href="../?id=7926&amp;page=2">&raquo;</a></form>   <div class="post" id="post-57826">
    <div class="subject"><a href="#post-57826">Sine Functions</a></div>
    <div class="body">Hey guys,<br /><br />I wrote a bunch of sine routines for a trig package I will be needing. This is the first pass through the routines. The approximation equations are described along with the average/max errors, and average profile cycle time. The calcs are performed using doubles/real8's. There are 4 routines of increasing accuracy and decreasing speed available.<br /><br />Thought I'd post for y'all to check out. Any feedback/optimizations are welcome.<br /><br />- Chris</div>
    <div class="meta">Posted on 2002-09-14 17:42:18 by bit</div>
   </div>
   <div class="post" id="post-57867">
    <div class="subject"><a href="#post-57867">Sine Functions</a></div>
    <div class="body">SSE for sin5<pre><code>movss	xmm0, x<br />movss	xmm1, xmm0<br />mulss	xmm1, xmm0<br />movss	xmm2, xmm1<br />divss	xmm1, const_20<br />movss	xmm3, const_1<br />movss	xmm4, xmm3<br />subss	xmm3, xmm1<br />mulss	xmm3, xmm2<br />divss	xmm3, const_6<br />subss	xmm4, xmm3<br />mulss	xmm0, xmm4<br />movss	x, xmm0</code></pre>Float data type size only, tested on MS-VC w/ inline asm, no doubles. Not timed how many clock cycles &lt;--- too lazy to do that. :)<br /><br />Nice compilation... I'm planning to convert every function to SSE.</div>
    <div class="meta">Posted on 2002-09-15 00:26:01 by stryker</div>
   </div>
   <div class="post" id="post-57874">
    <div class="subject"><a href="#post-57874">Sine Functions</a></div>
    <div class="body">Nice work, bit.<br /><br />But, out of curiosity,<br />what is the advantage of your functions compared to using <strong>fsin</strong>?  Did your functions pass the IEEE754 test?<br /><br />Personally, I prefer using <strong>fsin</strong> because the result does not depend on PC setting.  Here is what I use:<br /><pre><code><br />; double sin&#40;double x&#41;<br />sin     proc c<br />        fld     qword ptr &#91;esp+4&#93;<br />        fsin<br />        fnstsw  ax<br />        sahf<br />        jp      @F   ; assuming most vals<br />        ret          ; are within range.<br />; |x| &gt; 2^63, out of range.<br />; need to reduce x.<br />@@&#58;     fldpi<br />        fadd    st&#40;0&#41;,st&#40;0&#41;<br />        fxch<br />@@&#58;     fprem1<br />        fnstsw  ax<br />        sahf<br />        jp      @B<br />        fstp    st&#40;1&#41;<br />; reduction done.  do it again.<br />        fsin<br />        ret<br />sin     endp<br /></code></pre><br /><br />If you believe Agner, you can eliminate the last loop with only one <strong>fprem1</strong>.  But, I prefer to play safe.  :)<br /><br />Like I said before, this function does not depend on your PC setting, so by only chaning <strong>fld qword ptr </strong>, you get a single precision version and long double precision version (as required by C99) without ever doing <strong>fldcw</strong>.<br />But, I do not know the speed of my function.  Can someone compare and post the performance result?<br /><br />BTW, if you have to approximate at any cost, there is a fairly accurate implementation from Sun.  Look in the directory <a target="_blank" href="ftp://ftp.netlib.org/fdlibm/">ftp://ftp.netlib.org/fdlibm/</a>.  At least, the results are mostly within 1ulp range from <strong>fsin</strong> results for all representable double precision numbers.  (Yeah, I did run the test for that crazy exhaustive test.  :))  Its problem is the unbearably slow (well, from x86 point of view) computation.</div>
    <div class="meta">Posted on 2002-09-15 03:25:12 by Starless</div>
   </div>
   <div class="post" id="post-57875">
    <div class="subject"><a href="#post-57875">Sine Functions</a></div>
    <div class="body"><div class="quote"><em>Originally posted by stryker </em><br />I'm planning to convert every function to SSE. </div><br /><br />Most of useful mathematical functions are already implemented using SSE by Intel, and they distribute them free of charge.  Just download MKL from Intel site.  That will save you a lot of time.</div>
    <div class="meta">Posted on 2002-09-15 03:37:09 by Starless</div>
   </div>
   <div class="post" id="post-57911">
    <div class="subject"><a href="#post-57911">Sine Functions</a></div>
    <div class="body">Thanks guys. The functions don't have any advantage over fsin at this point - I had been playing around with it a little bit as well. However, I have been thinking about doing a Fixed Point version that would use the same algorithms as those floating point versions. Hopefully those would be faster, but with the speed of the FPU nowadays, who knows.<br /><br />And, I actually have the code from fdlibm. Didn't run it, but it seemed rather slow just from looking at it. Or, at the very least, quite complex.<br /><br />Starless, I clocked the function at an average of 246 cycles. The C run time version of sin() runs at 254 cycles. However, these tests are presuming the values are in range. I didn't throw anything needing range reduction at it.<br /><br />- Chris</div>
    <div class="meta">Posted on 2002-09-15 08:31:52 by bit</div>
   </div>
   <div class="post" id="post-57979">
    <div class="subject"><a href="#post-57979">Sine Functions</a></div>
    <div class="body">bit,<br /><br />I could not believe that your functions would take that long.  Or, did you mean my version took 246 clocks and another C library of yours took 254 clocks?  If your function took 246 clocks, did you mean your <strong>Sine9</strong> timing?<br />&lt;edit&gt;<br />Duh...  I'm stupid.  You obviously meant mine took 246 clocks.  But, then, I wonder why your functions take so long as you commented in your source code.<br />&lt;/edit&gt;<br /><br />Anyhow, one more look at your source code, I have a suggestion for speed up.<br /><br />The idea is simple.  'Multiplication by a reciprocal rather than division'.  For example, when you have to divide by 20, you want to multiply by 0.05.  But, you might also want to do error analysis again with this modification, because none of your constants are exactly representable.<br />&lt;edit&gt;<br />I mean, the reciprocal of your constants are not exactly representable.<br />&lt;/edit&gt;<br /><br /><br />To enhance the accuracy, you might want to make all constants in EP.  That will cost you load time, but that is much cheaper than <strong>fdiv</strong>.  And, you can hide the load latency while you are doing another <strong>fmul</strong>, so I guess the cost would be virtually invisible.</div>
    <div class="meta">Posted on 2002-09-15 16:06:45 by Starless</div>
   </div>
   <div class="post" id="post-57982">
    <div class="subject"><a href="#post-57982">Sine Functions</a></div>
    <div class="body">Those timings listed in the code were the delta of calls to rdtsc before and after the routine. The normal C run-time took 254 clocks, and your version took 246. The respective timings of each of my functions are listed in the comments at the start of each function. I thought those were clocks cycles, but I could be wrong. At any rate, the relative meaning is still valid. The fastest one of my functions only runs at 221. So, for a difference of only 25 clocks (or 25 whatever it is) I get the real answer w/o the error.<br /><br />I will implement your suggestions and see what happens. I should smack myself for not thinking of the multiply by reciprical. I hadn't given much thought to any optimizations yet. It took me long enough to figure out the math. ;)<br /><br />Anyway, it seems like the fsin instruction might actually be worth using considering the improved accuracy and only small clock cycle penalty. But, we will see. I need this to be as fast as possible since I am going to be using it for a sound synthesis engine. I have no idea how much accuracy I need - thus the multiple routines.<br /><br />- Chris</div>
    <div class="meta">Posted on 2002-09-15 16:18:08 by bit</div>
   </div>
   <div class="post" id="post-58017">
    <div class="subject"><a href="#post-58017">Sine Functions</a></div>
    <div class="body">Okay, the base stats that I am working against:<br /><br />sin: 254 - c run-time version using vc++ 6.0<br />Sine: 246 - fSin version that you posted<br /><br />And ... the newest stats for the approximation functions after the multiply by reciprical optimization ...<br /><br />Sine5: 168 - 5th degree Taylor Series<br />Sine7: 182 - 7th degree Taylor Series<br />Sine9: 199 - 9th degree Taylor Series<br />Sine11: 212 - 11th degree Taylor Series<br /><br />The errors went up in some and down in others, but only by .00000001 at the max. For the most part they were unchanged.<br /><br />I think there might still be some speed to squeeze out of someplace, but I'll have to beat my head against the wall for a few days to figure it out. :)<br /><br />The only remaining issue is the range of acceptable input. The Taylor series has issues the further away the input is from 0 because there is not enough accuracy. Which means I need to scale the input to somewhere between -PI/2 and PI/2 (or, at the very least -PI and PI). Then, use the symetry of sine to calculate the correct value.<br /><br />So, in order for me to have the approximation routines be more effective than the fsin version, I need to be able to perform that calculation and scaling in under 34 cycles (246 - 212). As long as the 5th and 7th degree approximations were faster I would probably be happy, but I would really like for the most accurate one to be faster as well - after all, what is the point of writing them if they are slower and/or not as accurate.<br /><br />I will post back again when I have some more info/ideas/results.<br /><br />- Chris</div>
    <div class="meta">Posted on 2002-09-15 21:55:48 by bit</div>
   </div>
   <div class="post" id="post-58020">
    <div class="subject"><a href="#post-58020">Sine Functions</a></div>
    <div class="body">but MKL is commercially sold by Intel. Anyway, even if it is/was free, it's fun converting... :)<br /><br />Next time, I'll post more converted functions.<br /><br />Thanks for remembering me of MKL. I'll probably buy the library in the future when I need it. :alright:</div>
    <div class="meta">Posted on 2002-09-15 22:11:18 by stryker</div>
   </div>
   <div class="post" id="post-58026">
    <div class="subject"><a href="#post-58026">Sine Functions</a></div>
    <div class="body">Chris,<br /><br />I still don't understand why your <strong>Sine5</strong> takes that long time.  After you replaced <strong>fdiv</strong> by <strong>fmul</strong>, there are only 5 multiplications.  So, even if the current code cannot hide the latency due to the dependency flow, it should not take more than 50 clocks, unless the cache is trashed every time you measure it so that the memory access time outweighs the calculation time.<br /><br />If you are not allowed to use cache at all, then try using <strong>fld1</strong> instead of getting CONST_1 from the memory, and similarly, try reducing memory access at the entry, for example,<br /><pre><code><br />fld x<br />fld x<br />fmul x<br /></code></pre><br />to <br /><pre><code><br />fld x<br />fld st&#40;0&#41;<br />fmul st&#40;0&#41;,st&#40;0&#41;<br /></code></pre><br />and it is shorter, too.</div>
    <div class="meta">Posted on 2002-09-15 23:46:04 by Starless</div>
   </div>
   <div class="post" id="post-58028">
    <div class="subject"><a href="#post-58028">Sine Functions</a></div>
    <div class="body"><div class="quote"><br />but MKL is commercially sold by Intel.</div><br />Eh?  Since when?  Or, am I totally mistaken?  I thought MKL  distribution was free-of-charge for non-commercial use.<br /><br />Hmm, if Intel sells MKL, I should stop promoting it and stop using it right now.  Oh, well, that is a big loss.  :(  Darn, there is no good math library left for free use.</div>
    <div class="meta">Posted on 2002-09-15 23:52:13 by Starless</div>
   </div>
   <div class="post" id="post-58030">
    <div class="subject"><a href="#post-58030">Sine Functions</a></div>
    <div class="body">I think it was the early versions that was free...I can't be sure but check out this link <a target="_blank" href="http://www.intel.com/software/products/mkl/mkl52/index.htm">http://www.intel.com/software/products/mkl/mkl52/index.htm</a> there's an evaluation for 30 days and Buy Now :(<br /><br />Yeah, I remember it was free but didn't bother to download because I thought I don't have any use for it. What a bad decision... Or I could have been dreaming this all along. :grin:</div>
    <div class="meta">Posted on 2002-09-15 23:56:05 by stryker</div>
   </div>
   <div class="post" id="post-58034">
    <div class="subject"><a href="#post-58034">Sine Functions</a></div>
    <div class="body">Maybe I am misunderstanding the rdtsc instruction. I thought it returned clock counts, but now I dunno. I know what you're saying ... it feels like it should be faster, so I don't know where all of the overhead is coming from. The only thing I can think of is that the routine I am using to time it (which is in C w/ inline asm) is taking a gigantic amount of time since it has the inline asm code and uses 64-bit variables. Maybe I'll take a look at the decompilation and see what code the compiler is writing for that 2 line routine. However, that would make all versions faster (not just mine), since I time all the routines with the function. Thus the deltas would still apply and I am back to square 1 which is that the fsin instruction is almost as fast as my approximations and fully accurate. <br /><br />As a side note, I checked out Intel's optimization manual and they claim the trancendental functions can be implemented *no faster* w/o losing accuracy.<br /><br />Thanks for the idea, I have actually been messing with the entry loading a smidge. So far I have shaved a few cycles off of each routine by loading the second copy of X during the multiply and then exchanging registers. I'll try changing it to load the second x from the registers instead, and I'll keep playing around with preloading some of the constants during the multiplies and see what happens. I might be able to save a few more cycles.<br /><br />- Chris</div>
    <div class="meta">Posted on 2002-09-16 00:05:59 by bit</div>
   </div>
   <div class="post" id="post-58145">
    <div class="subject"><a href="#post-58145">Sine Functions</a></div>
    <div class="body">Turns out the overhead of the Timing stuff was 121 cycles! Which gives me the following new values for everything including the optimizations that have already been done.<br /><br />===<br />sin: 133- c run-time version using vc++ 6.0<br />Sine: 123 - fSin version that you posted<br />===<br />Sine5: 45 - 5th degree Taylor Series<br />Sine7: 59 - 7th degree Taylor Series<br />Sine9: 72 - 9th degree Taylor Series<br />Sine11: 86 - 11th degree Taylor Series<br />===<br /><br />So, is it going to be possible to calculate the smaller range X and then adjust the sine accordingly? I have 37 cycles (123 - 86) in which I could do the calculation and have it be worthwhile. Wish me luck. I am going to attack it once I try and eek a few more cycles out of the others.<br /><br />- Chris</div>
    <div class="meta">Posted on 2002-09-16 09:10:20 by bit</div>
   </div>
   <div class="post" id="post-58173">
    <div class="subject"><a href="#post-58173">Sine Functions</a></div>
    <div class="body">Well, it doesn't appear that this will be a worthwhile undertaking. According to my timings, the range reduction function w/o performing any adjusting to get a correct value of sine takes about 40 cycles. Which is 2 cycles over the limit. I was able to slice a cycle off of the 11th degree approximation, but I am still cutting it way too close without even adjusting the value for the sine function. <br /><br />Here is the range reducing function that also selects the proper degree to call (no code for that part yet).<br /><br /><pre><code><br />;########################################################################<br />; SineApprox Procedure<br />;########################################################################<br />SineApprox proc	x&#58; REAL8, degree&#58; DWORD<br /><br />	;==================================================================<br />	; This function calls the appropriate appoximation functions based<br />	; on the degree specified after performing range reduction.<br />	;<br />	; All approximation functions works best when X is close to 0. So,<br />	; we reduce x to between 0 and PI/2 then utilize the following<br />	; properties of the sine function in each 90 degree quadrant.<br />	;<br />	;	quadrant 1 = sin&#40;x&#41;<br />	;	quadrant 2 = sin&#40;PI/2 - &#40;x - PI/2&#41;&#41;<br />	;	quadrant 3 = -sin&#40;PI - x&#41;<br />	;	quadrant 4 = -sin&#40;&#40;2*PI&#41;-x&#41;<br />	;<br />	;	Average Profile Cycles&#58;<br />	;<br />	;==================================================================<br />	LOCAL	num2PI	&#58;DWORD<br /><br />	;===============================<br />	; Range reduce x to &#40;0 - 2 PI&#41;<br />	;===============================<br />		;=======================================<br />		; Calc and store the number of 2 * PI's<br />		; in x, not including the very last<br />		; incomplete one this is sitting in.<br />		;=======================================<br />		fld	x<br />		fmul	CONST_INV_2_PI<br />		fistp	num2PI<br />		<br />		;=================================<br />		; Subtract number of 2PI's from x<br />		;=================================<br />		fld	CONST_2_PI<br />		fimul	num2PI<br />		fld	x<br />		fsubrp	st&#40;1&#41;, st&#40;0&#41;<br /><br />		;=================================<br />		; The range reduced X is now on <br />		; the top of the stack<br />		;=================================<br /><br />	;=========================================<br />	; What degree approximation do they want?<br />	;=========================================<br />	.if degree == 5<br />		;===============================<br />		; They want a 5th degree approx<br />		;===============================<br /><br />	.elseif degree == 7<br />	.elseif degree == 9<br />	.elseif degree == 11<br />	.else<br />		;=================================<br />		; Invalid degree ... do nothing<br />		;=================================<br />	.endif<br /><br />	;===================<br />	; We completed<br />	;===================<br />	ret<br /><br />SineApprox ENDP<br />;########################################################################<br />; END SineApprox<br />;########################################################################<br /></code></pre> <br /><br />So, I am undecided about what the plan should be. Obviously the fsin routine is going to be faster when accuracy is desired. But, that is what the c run-time uses and a whole bunch of posts have been made about the lack of speed for sound wave oscillation purposes. So, is it actually fast enough nowadays and nobody ever timed it (e.g. basing it off the DOS days)? I have timed a couple other approximation routines and they are all extremely close to the fsin timing.<br /><br />Anybody have any thoughts/ideas?<br /><br />- Chris</div>
    <div class="meta">Posted on 2002-09-16 13:04:25 by bit</div>
   </div>
   <div class="post" id="post-58194">
    <div class="subject"><a href="#post-58194">Sine Functions</a></div>
    <div class="body">For sound use a Goertzel resonator (oscillator). ;)<br /><br />A Google search will do it.</div>
    <div class="meta">Posted on 2002-09-16 16:45:14 by Maverick</div>
   </div>
   <div class="post" id="post-58196">
    <div class="subject"><a href="#post-58196">Sine Functions</a></div>
    <div class="body">What about reducing x using <strong>fprem1</strong>?  Like<br /><pre><code><br />fldpi<br />fadd    st&#40;0&#41;,st&#40;0&#41;<br />fld     x<br />fprem1<br />fstp     st&#40;1&#41;<br />; now st&#40;0&#41; is in &#91;-2*pi, 2*pi&#93;<br /></code></pre><br />According to Agner, this is not faster than your code, but, if your code takes 40 clocks (which I cannot believe - your timing report seems too pessimistic), I think it is worth trying.<br /><br />In <a target="_blank" href="http://www.asmcommunity.net/board/showthread.php?threadid=7849">another thread</a> (almost at the end of it), there is a link to a library.  I have not tested it myself, but it seems worth trying out.</div>
    <div class="meta">Posted on 2002-09-16 17:04:30 by Starless</div>
   </div>
   <div class="post" id="post-58214">
    <div class="subject"><a href="#post-58214">Sine Functions</a></div>
    <div class="body">Thanks Maverick. I am familiar with Goertzel and I do have an implementation in C that I have been playing with. My only issue with that algorithm is the cost of frequency changing. Won't know exactly how that will affect what I am doing until I get further along though.<br /><br />Starless, I don't think my timings are off. But, you never know. Perhaps I will switch to another timing method and see what the comparison yields. Doesn't fprem take like 70 cycles or so to execute?<br /><br />At any rate, I have decided that the caller of the sine routines can either control the range of inputs, or just use the fsin version for full accuracy. This way I can optimize if needed for each situation instead of just blindly range reducing all the time when it can't be interleaved with anything.<br /><br />And ... I think I may have found a slightly faster algorithm for the sine calcs. It looks like I can derive some coefficients to eliminate some of the multiples and subtracts. Only problem is I found it with coefficients for cosine and their implementation of sine just shifts x back by PI/2 and then calls cosine - which is OK, just slightly slower than coding the algorithm directly. So, I need to figure out how to derive the needed coefficients and then I can hopefully save about 3-4 multiples and 3-4 subtracts per approximation - which is quite a few cycles.<br /><br />The one thing that strikes me as weird is the entire community is always complaining about the speed of the c run-times version of sin(). But, according to my calcs it is only a few cycles slower then the fsin assembly version, and once you handle range reduction is a little bit faster than a decent approximation. Yet, people are still going out of their way to write custom implementations and use LUTs. Makes me wonder if my timings are somehow way off. But, then they would be off for everything including the run time lib's ... so, I dunno. <br /><br />- Chris</div>
    <div class="meta">Posted on 2002-09-16 21:19:05 by bit</div>
   </div>
   <div class="post" id="post-58252">
    <div class="subject"><a href="#post-58252">Sine Functions</a></div>
    <div class="body">I just checked out the timing list and found that <strong>fprem1</strong> takes 20-70 clocks on P5 and 33 micro-ops to port 1 on P6 (so 33 clocks or close to that number). If your timing is not off much, then, using <strong>fprem1</strong> may be a viable alternative (which can be done with only one memory access) on P6.  (At least, I thought so.)<br /><br />Then again, these are numbers on a paper.  According to the same timing list, <strong>fsin</strong> takes 65-100 clocks on P5 and generates 17-97 micro-ops on P6.  But, as you already found out, <strong>fsin</strong> version takes longer than these numbers even if we consider the loading and testing.  So, who knows how long <strong>fprem1</strong> will take in real life?  :)<br /><br />I guess that the C runtime library is essentially the same as my version with some additional codes (maybe checking the existence of FPU?).<br /><br />I don't know how sound synthesis works, but if you can vectorize your input, then a fully vectorized SSE version may be the way to go.  (waiting for stryker's SSE version...  :grin: )</div>
    <div class="meta">Posted on 2002-09-17 01:16:06 by Starless</div>
   </div>
   <div class="post" id="post-58267">
    <div class="subject"><a href="#post-58267">Sine Functions</a></div>
    <div class="body">Hi <strong>bit</strong>,<br />If you <em>continuosly</em> change frequency and/or phase, then I suggest you to use fsin (or a faster version like BMath that was mentioned some time ago perhaps in another thread, but which anyway you can find at <a target="_blank" href="http://www.bmath.net/old/bmath/howbmath.htm">http://www.bmath.net/old/bmath/howbmath.htm</a>). Also, on my K7 last time I had to face this problem, using fsin was not a problem because it was nicely executed &quot;for free&quot;, due to other stuff done in parallel (including memory accesses). So it depends on the specific algorithm (and CPU, being the K7 excellent at FPU), and the eventual optimizations one can do on it.. but I suggest you to try all the solutions before excluding any.. because you may get very suprised.<br />If you use fsin I just suggest you to keep your current_phase variable always within 0..Pi2 ranges.. both for precision and for fsin overhead.</div>
    <div class="meta">Posted on 2002-09-17 02:46:10 by Maverick</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=7926&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=7926&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="7926" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=7926&amp;page=2">&gt;</a><a href="../?id=7926&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>