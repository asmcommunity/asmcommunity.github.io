<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>signed numbers addiction help... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=14832" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=14832">signed numbers addiction help...</a></p>
   <div class="post" id="post-115124">
    <div class="subject"><a href="#post-115124">signed numbers addiction help...</a></div>
    <div class="body">hi all,<br /><br />was not very good on mathematics at school... :)<br />and i'm not strong in assembler signed operations... :(    <br /><br />need a litle help<br /><br />i have to do the signed sum of two numbers, the first could be negative or positive, the second is positive...<br /><br />is there a better way than compare values and using &quot;cmp&quot;, &quot;neg&quot; intruction, jumps .... ?<br /><br />thanks B7</div>
    <div class="meta">Posted on 2003-08-23 15:50:51 by Bit7</div>
   </div>
   <div class="post" id="post-115125">
    <div class="subject"><a href="#post-115125">Re: signed numbers addiction help...</a></div>
    <div class="body"><div class="quote"><em>Originally posted by Bit7 </em><br />is there a better way than compare values and using &quot;cmp&quot;, &quot;neg&quot; intruction, jumps .... ?</div><br />How about <strong>add</strong>?<br /><br />Thomas</div>
    <div class="meta">Posted on 2003-08-23 15:59:49 by Thomas</div>
   </div>
   <div class="post" id="post-115127">
    <div class="subject"><a href="#post-115127">signed numbers addiction help...</a></div>
    <div class="body">Hi thoma<br /><br />what happens if we have a number like:<br /><br />0111 1111 + 0100 0000 = 1011 1111 &lt;---- negative???<br /><br />peace</div>
    <div class="meta">Posted on 2003-08-23 16:04:55 by mistronr1</div>
   </div>
   <div class="post" id="post-115135">
    <div class="subject"><a href="#post-115135">signed numbers addiction help...</a></div>
    <div class="body"><div class="quote"><br />Hi thoma<br /><br />what happens if we have a number like:<br /><br />0111 1111 + 0100 0000 = 1011 1111 &lt;---- negative???<br /><br />peace </div><br /><br />Since a signed byte range is from -128 to +127, your calculation causes an overflow (127 + 64 &gt; 127). The same thing happens when you add for example 255 and 255 with unsigned arithmetic. In both cases the result is invalid, although the flags will be set so that you can detect this and take the right action.<br /><br />Thomas<br />P.S. signed numbers addi<strong>c</strong>tion and addition are two totally different things :grin:...</div>
    <div class="meta">Posted on 2003-08-23 18:00:22 by Thomas</div>
   </div>
   <div class="post" id="post-115140">
    <div class="subject"><a href="#post-115140">signed numbers addiction help...</a></div>
    <div class="body">Im having a hard time getting just what Bit7 wants, but has it been made clear that you can use the .if/.endif to comare for signed numbers.<br /><br /><pre><code><br />mov eax, PositiveOrNegative<br />mov edx, PositiveOnly<br />.if&#40; SDWORD PTR eax &gt; = 0 &#41;<br />  add eax, edx<br />  jc @PositiveAddOverflowError<br />.else<br />  add eax, edx<br />  jc @NegativeAddOverflowError<br />.endif</code></pre><br /><br />Maybe im way off base here.. i dunno..<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2003-08-23 19:31:09 by NaN</div>
   </div>
   <div class="post" id="post-115151">
    <div class="subject"><a href="#post-115151">signed numbers addiction help...</a></div>
    <div class="body">I would suggest the OR instruction to test if the first number is negative or positive. If negative, the sign flag will be set. Under such condition, adding a negative number with a positive number can never cause an overflow. The sign of the result will depend on which one had the greatest absolute value.<br /><br />If both are positive, you then have to test the result for an overflow which would set the sign flag and indicate an invalid result.<br /><br />The following example uses 8-bit registers but you can modify it for any size register.<br /><pre><code><br />   mov   al,firstnum<br />   or    al,al<br />   jns   @F          ;jump if first number is positive<br />   add   al,secondnum<br />   jmp   finish<br />@@&#58;<br />   add   al,secondnum<br />   js    OVERFLOW    ;go handle the overflow error<br />finish&#58;</code></pre><br /><br />Raymond</div>
    <div class="meta">Posted on 2003-08-23 21:56:50 by Raymond</div>
   </div>
   <div class="post" id="post-115163">
    <div class="subject"><a href="#post-115163">signed numbers addiction help...</a></div>
    <div class="body">thanks all, and sorry for my bad explaination.<br /><br />Yes, my problem was the addition of a positive or negative with a positive number.<br /><br />So seems i have to introduce comparisons and jumps... i would like to avoid this becouse i have a grat routine with about 16 of there operations, and i think that many &quot;cmp/jump&quot; will make my routine run too slow..... <br /><br />What about introducing floating ?</div>
    <div class="meta">Posted on 2003-08-24 00:09:42 by Bit7</div>
   </div>
   <div class="post" id="post-115211">
    <div class="subject"><a href="#post-115211">signed numbers addiction help...</a></div>
    <div class="body">Bit7, maybe you're just getting confused by the fact that the same add and sub instructions are used for both signed and unsigned. In your example<br /><br />0111 1111 + 0100 0000 = 1011 1111 &lt;---- negative???<br /><br />The answer is both negatinve and positive, its depends on what instructions you use with it from then on. If you use eg mul or jb then the number is treated as positive, whereas using idiv or jg would treat the number as negative. Using add and sub it won't matter.<br /><br />In floating point all numbers are signed, you can't get unsigned numbers.</div>
    <div class="meta">Posted on 2003-08-24 06:48:19 by Eóin</div>
   </div>
   <div class="post" id="post-115213">
    <div class="subject"><a href="#post-115213">signed numbers addiction help...</a></div>
    <div class="body">I think Eoin is correct. It does not matter if the number is positive or not, but what that really matter is whether you are adding unsigned numbers to signed numbers or something like that. <br /><br />If both are sign, no problem, just use plain add. If one is unsigned and the other is unsigned, then it makes things hard.</div>
    <div class="meta">Posted on 2003-08-24 07:02:21 by roticv</div>
   </div>
   <div class="post" id="post-115217">
    <div class="subject"><a href="#post-115217">signed numbers addiction help...</a></div>
    <div class="body">Bit7, theres an important bit you don't mention. When you say the second number is positive do you mean positive in the signed range 0-127 or in the unsigned range 0-255. <br /><br />If its in the signed positive range then don't worry about checking signs just add and sub watching out for overflows. If its in the unsigned range then it only makes sense to treat the answer as an unsigned number. Eg -10 + 200 = 190 if you're taking unsigned numbers, or -66 if you're taking signed. <br /><br />The lesson here is don't mixed signed and unsigned numbers too much. Positive and negative are ok to mix, just keep them within their signed ranges.</div>
    <div class="meta">Posted on 2003-08-24 07:37:56 by Eóin</div>
   </div>
   <div class="post" id="post-115221">
    <div class="subject"><a href="#post-115221">signed numbers addiction help...</a></div>
    <div class="body">roticv, eion, thanks again,<br /><br />i think i have understand that add and sub work just with number, don't care about the sign, so i've to check an mange it.<br /><br />Since i've discovered i need just another operation, where both the numbers could be neg or pos... i decide to go for floating to go in an easier way.<br /><br /><br /><pre><code><br /><br />fild	&#91;y&#93;<br />fiadd	&#91;cr&#93;                 can be pos/or negative<br />fidiv	&#91;i256&#93;<br />fiadd	&#91;RTable2&#93;       can be pos/or negative<br />fistp	&#91;offTable&#93;                                  <br />mov	al, &#91;byte ptr offTable&#93;<br />mov	&#91;byte ptr edi+2&#93;, al<br /><br /></code></pre><br /><br /><br />so i let the FPU do the homeworks for me :) but i think that using FPU make my routine slower... is it ?</div>
    <div class="meta">Posted on 2003-08-24 08:49:10 by Bit7</div>
   </div>
   <div class="post" id="post-115222">
    <div class="subject"><a href="#post-115222">signed numbers addiction help...</a></div>
    <div class="body">It will make it very much slower, specially that division instruction.<br /><br />If you are actually dividing by 256, you could then use the very fast SHR instruction instead of the DIV with the CPU.<br /><br />Raymond</div>
    <div class="meta">Posted on 2003-08-24 09:12:04 by Raymond</div>
   </div>
   <div class="post" id="post-115236">
    <div class="subject"><a href="#post-115236">signed numbers addiction help...</a></div>
    <div class="body">All this guess work.  It would be alot more efficient to help you if we know roughtly what your algorithm was to be.. (I can interperent from you floating point listing), but im not sure where the end result is....<br /><br />:NaN:</div>
    <div class="meta">Posted on 2003-08-24 10:22:28 by NaN</div>
   </div>
   <div class="post" id="post-115247">
    <div class="subject"><a href="#post-115247">signed numbers addiction help...</a></div>
    <div class="body">it's jus a rotine i'm converting from C<br />The routine perform a YUV 4:1:1 image format to RGB, 24 bit per pixel.<br /><br /><br />since you're asking, this is the main cycle code<br /><br /><pre><code><br />while &#40;wly--&#41; &#123;<br />	for &#40;i=0; i&lt;lx; i+=4&#41; &#123;			<br />		cr=*crp++;<br />		cr-=128;<br />		cb=*cbp++;<br />		cb-=128;<br />		cg=cr;<br />		cg+=cb;						<br />		cr*=409;<br />		cg*=-617;<br />		cb*=517;<br />		cg+=cr;<br />		cg+=cb;<br />		y=MulTable&#91;*src++&#93;;			<br />		*rp=Table&#91;&#40;y+cr&#41;&gt;&gt;8&#93;;<br />		rp+=rinc;<br />		*gp=Table&#91;&#40;y+cg&#41;&gt;&gt;8&#93;;<br />		gp+=ginc;					<br />		*bp=Table&#91;&#40;y+cb&#41;&gt;&gt;8&#93;;<br />		bp+=binc;	<br />		y=MulTable&#91;*src++&#93;;				<br />		*rp=Table&#91;&#40;y+cr&#41;&gt;&gt;8&#93;;<br />		rp+=rinc;					<br />		*gp=Table&#91;&#40;y+cg&#41;&gt;&gt;8&#93;;<br />		gp+=ginc;					<br />		*bp=Table&#91;&#40;y+cb&#41;&gt;&gt;8&#93;;<br />		bp+=binc;					<br />		y=MulTable&#91;*src++&#93;;			<br />		*rp=Table&#91;&#40;y+cr&#41;&gt;&gt;8&#93;;<br />		rp+=rinc;					<br />		*gp=Table&#91;&#40;y+cg&#41;&gt;&gt;8&#93;;<br />		gp+=ginc;					<br />		*bp=Table&#91;&#40;y+cb&#41;&gt;&gt;8&#93;;<br />		bp+=binc;					<br />		y=MulTable&#91;*src++&#93;;			<br />		*rp=Table&#91;&#40;y+cr&#41;&gt;&gt;8&#93;;<br />		rp+=rinc;					<br />		*gp=Table&#91;&#40;y+cg&#41;&gt;&gt;8&#93;;<br />		gp+=ginc;					<br />		*bp=Table&#91;&#40;y+cb&#41;&gt;&gt;8&#93;;<br />		bp+=binc;					<br />		&#125;<br />	&#125;<br />&#125;<br /><br /></code></pre><br /><br />i've just converted, seems work... but i have to discover if is faster or slower heheheh<br /><br />B7</div>
    <div class="meta">Posted on 2003-08-24 11:00:29 by Bit7</div>
   </div>
   <div class="post" id="post-115252">
    <div class="subject"><a href="#post-115252">signed numbers addiction help...</a></div>
    <div class="body"><div class="quote"><br />If you are actually dividing by 256, you could then use the very fast SHR instruction instead of the DIV with the CPU.</div>Of course, SAR for signed numbers - the FPU only works with signed numbers.</div>
    <div class="meta">Posted on 2003-08-24 11:12:01 by bitRAKE</div>
   </div>
   <div class="post" id="post-115287">
    <div class="subject"><a href="#post-115287">signed numbers addiction help...</a></div>
    <div class="body">A good rule to remember when using the:<br /><br />add<br />sub<br />cmp<br /><br />instructions is to use these jumps when dealing with unsigned numbers only:<br /><br />JB, JBE, JA, JAE              these test the Carry flag<br /><br />and use these jumps when dealing with signed numbers only:<br /><br />JL, JLE, JG, JGE              these test the Sign &amp; Overflow flags<br /><br />farrier</div>
    <div class="meta">Posted on 2003-08-24 14:05:55 by farrier</div>
   </div>
   <div class="post" id="post-115451">
    <div class="subject"><a href="#post-115451">signed numbers addiction help...</a></div>
    <div class="body">The nice thing about two's complement arithmetic is that adding (and subtracting) numbers is exactly the same for signed and unsigned. That's why, unlike multiply and divide, there aren't separate signed/unsigned versions of ADD and SUB. As always, arithmetic overflow will invalid your results (unless you want the &quot;wraparound&quot; feature.)</div>
    <div class="meta">Posted on 2003-08-25 16:29:43 by tenkey</div>
   </div>
   <div class="post" id="post-115606">
    <div class="subject"><a href="#post-115606">signed numbers addiction help...</a></div>
    <div class="body">thanks all again, now i've understand what i was missing :<br /><br />for some stupid reason (i've some great black holes about the knowledge of signed numbers), i tought that<br /><br />11111111  = -128<br />10000001  = -1<br />:stupid: <br /><br />instade, reading the book Advanced Assembly Language .. i've soon discovered that <br /><br />11111111 = -1<br />10000000 = -128<br /><br />so i've also soon discovered why the Intel processors have the imul or idiv and not iadd or isub  :)<br />It worth some moderator please move my &quot;posted&quot; count to 0 or better -1  :)<br /><br />Ok, now i've got it hardly and i hope i'll remember it well.<br />So on Sunday, when guys of my town go to the beach, i tought to change my YUV4:1:1 to RGB routine, avoiding the slow floating instructions. <br />This is the last release :)<br /><br /><pre><code><br />;---------------------------------------------------------------------------<br />proc		ImageToRGB uses ebx edx esi edi, src&#58;dword, dst&#58;dword, dstpitch&#58;dword, lx&#58;dword, ly&#58;dword<br /><br />		;/*      src &#58; image in CM_YUV411P format<br />		;/*      dst &#58; destination buffer					<br />		;/* dstpitch &#58; dest. line pitch, pass zero to get the default	<br />		;/*    lx,ly &#58; image dimensions in pixels					<br />		;/*  wy, wly &#58; sub-image window to process &#40;0,0 for all&#41;	<br /><br />		;B = 1.164&#40;Y - 16&#41; + 2.018&#40;U - 128&#41;<br />		;G = 1.164&#40;Y - 16&#41; - 0.813&#40;V - 128&#41; - 0.391&#40;U - 128&#41;<br />		;R = 1.164&#40;Y - 16&#41; + 1.596&#40;V - 128&#41;<br /><br />		dataseg<br />	<br />		RoundTable	db	300 dup&#40;0&#41;, 256 dup&#40;0&#41;, 300 dup&#40;255&#41;<br />		MulTable	dd	256 dup&#40;0&#41;<br />		Inited		dd	0<br />		<br />		codeseg	<br />		<br />		LOCAL   i, y, RTable2&#58; dword<br />		LOCAL	cr, cg, cb &#58; dword<br />		<br />		cmp	&#91;Inited&#93;,0<br />		jne	@@st03		<br /><br />		; Round-Table initialization<br />		or	&#91;Inited&#93;,1<br />		lea 	edi,&#91;RoundTable&#93;<br />		add	edi,300<br />		xor	ecx,ecx<br />@@st00&#58;		mov	&#91;byte ptr edi&#93;,cl<br />		inc	ecx<br />		inc	edi<br />		cmp	ecx,256<br />		jl	@@st00<br />		<br />		lea 	edi,&#91;MulTable&#93;<br />		xor	ecx,ecx<br />@@st02&#58;		mov	eax,ecx<br />		sub	eax,16<br />		imul	eax,298<br />		add	eax,128<br />		mov	&#91;dword ptr edi&#93;,eax<br />		add	edi,4<br />		inc	ecx<br />		cmp	ecx,256<br />		jl	@@st02<br />					<br />		; preparo i puntatore croma red e croma blu<br /><br />@@st03&#58;		push	offset RoundTable + 300<br />		pop	&#91;RTable2&#93;<br /><br />		mov	esi,&#91;src&#93;		; esi puntatore a luminanza<br />		<br />		mov	eax,&#91;lx&#93;<br />		imul	eax,&#91;ly&#93;<br />		push	eax<br />		mov	ebx,eax<br />		add	ebx,&#91;src&#93;		; ebx croma red pointer<br />		<br />		pop	eax<br />		shr	eax,2 		<br />		mov	edx,ebx<br />		add	edx,eax			; edx croma blu pointer	<br />		<br />		mov	edi,&#91;dst&#93;		; edi RGB blue ptr<br />		<br />		; ciclo di conversione<br />		<br />@@st04&#58;		xor	ecx,ecx<br />		<br />@@st05&#58;		movzx	eax,&#91;byte ptr ebx&#93;  <br />		mov	&#91;cr&#93;,eax<br />		sub	&#91;cr&#93;,128<br />		<br />		movzx	eax,&#91;byte ptr edx&#93;  <br />		mov	&#91;cb&#93;,eax<br />		sub	&#91;cb&#93;,128<br />		<br />		push	&#91;cr&#93;<br />		pop	&#91;cg&#93;<br />		<br />		mov	eax,&#91;cb&#93;<br />		add	&#91;cg&#93;,eax<br />		<br />		mov	eax,&#91;cr&#93;<br />		imul	eax,409<br />		mov	&#91;cr&#93;,eax<br /><br />		mov	eax,&#91;cg&#93;<br />		imul	eax,-617<br />		mov	&#91;cg&#93;,eax<br />		<br />		mov	eax,&#91;cb&#93;<br />		imul	eax,517<br />		mov	&#91;cb&#93;,eax<br />		<br />		mov	eax,&#91;cg&#93;<br />		add   	eax,&#91;cr&#93;<br />		add	eax,&#91;cb&#93;<br />		mov	&#91;cg&#93;,eax<br />		<br />		movzx	eax,&#91;byte ptr esi&#93;<br />		shl	eax,2<br />		push	&#91;dword ptr offset MulTable + eax&#93;<br />		pop	&#91;y&#93;<br />		<br />		mov	eax,&#91;y&#93;<br />		add	eax,&#91;cr&#93;<br />		sar	eax,8<br />		add	eax,&#91;RTable2&#93;<br />		<br />		mov	al,&#91;byte ptr eax&#93;<br />		mov	&#91;byte ptr edi&#93;,al<br />		<br />		mov	eax,&#91;y&#93;<br />		add	eax,&#91;cg&#93;<br />		sar	eax,8<br />		add	eax,&#91;RTable2&#93;<br />		<br />		mov	al,&#91;byte ptr eax&#93;<br />		mov	&#91;byte ptr edi+1&#93;,al<br />		<br />		mov	eax,&#91;y&#93;<br />		add	eax,&#91;cb&#93;<br />		sar	eax,8<br />		add	eax,&#91;RTable2&#93;<br />		<br />		mov	al,&#91;byte ptr eax&#93;<br />		mov	&#91;byte ptr edi+2&#93;,al<br />		<br />		inc	esi			; increment limunance ptr<br />		add	edi,3			; increment RGB ptr<br />		<br />		movzx	eax,&#91;byte ptr esi&#93;<br />		shl	eax,2<br />		push	&#91;dword ptr offset MulTable + eax&#93;<br />		pop	&#91;y&#93;<br />		<br />		mov	eax,&#91;y&#93;<br />		add	eax,&#91;cr&#93;<br />		sar	eax,8<br />		add	eax,&#91;RTable2&#93;<br />		<br />		mov	al,&#91;byte ptr eax&#93;<br />		mov	&#91;byte ptr edi&#93;,al<br />		<br />		mov	eax,&#91;y&#93;<br />		add	eax,&#91;cg&#93;<br />		sar	eax,8<br />		add	eax,&#91;RTable2&#93;<br />		<br />		mov	al,&#91;byte ptr eax&#93;<br />		mov	&#91;byte ptr edi+1&#93;,al<br />		<br />		mov	eax,&#91;y&#93;<br />		add	eax,&#91;cb&#93;<br />		sar	eax,8<br />		add	eax,&#91;RTable2&#93;<br />		<br />		mov	al,&#91;byte ptr eax&#93;<br />		mov	&#91;byte ptr edi+2&#93;,al<br />		<br />		inc	esi			; increment limunance ptr<br />		add	edi,3			; increment RGB ptr<br />		<br />		movzx	eax,&#91;byte ptr esi&#93;<br />		shl	eax,2<br />		push	&#91;dword ptr offset MulTable + eax&#93;<br />		pop	&#91;y&#93;<br />		<br />		mov	eax,&#91;y&#93;<br />		add	eax,&#91;cr&#93;<br />		sar	eax,8<br />		add	eax,&#91;RTable2&#93;<br />		<br />		mov	al,&#91;byte ptr eax&#93;<br />		mov	&#91;byte ptr edi&#93;,al<br />		<br />		mov	eax,&#91;y&#93;<br />		add	eax,&#91;cg&#93;<br />		sar	eax,8<br />		add	eax,&#91;RTable2&#93;<br />		<br />		mov	al,&#91;byte ptr eax&#93;<br />		mov	&#91;byte ptr edi+1&#93;,al<br />		<br />		mov	eax,&#91;y&#93;<br />		add	eax,&#91;cb&#93;<br />		sar	eax,8<br />		add	eax,&#91;RTable2&#93;<br />		<br />		mov	al,&#91;byte ptr eax&#93;<br />		mov	&#91;byte ptr edi+2&#93;,al<br />		<br />		inc	esi			; increment limunance ptr<br />		add	edi,3			; increment RGB ptr<br />		<br />		movzx	eax,&#91;byte ptr esi&#93;<br />		shl	eax,2<br />		push	&#91;dword ptr offset MulTable + eax&#93;<br />		pop	&#91;y&#93;<br />		<br />		mov	eax,&#91;y&#93;<br />		add	eax,&#91;cr&#93;<br />		sar	eax,8<br />		add	eax,&#91;RTable2&#93;<br />		<br />		mov	al,&#91;byte ptr eax&#93;<br />		mov	&#91;byte ptr edi&#93;,al<br />		<br />		mov	eax,&#91;y&#93;<br />		add	eax,&#91;cg&#93;<br />		sar	eax,8<br />		add	eax,&#91;RTable2&#93;<br />		<br />		mov	al,&#91;byte ptr eax&#93;<br />		mov	&#91;byte ptr edi+1&#93;,al<br />		<br />		mov	eax,&#91;y&#93;<br />		add	eax,&#91;cb&#93;<br />		sar	eax,8<br />		add	eax,&#91;RTable2&#93;<br />		<br />		mov	al,&#91;byte ptr eax&#93;<br />		mov	&#91;byte ptr edi+2&#93;,al<br />		<br />		inc	esi			; increment limunance ptr<br />		inc	ebx			; increment of croma red ptr<br />		inc	edx			; increment of croma blu ptr<br />		add	edi,3			; increment RGB ptr<br />		<br />		add	ecx,4<br />		cmp	ecx,&#91;lx&#93;<br />		jl	@@st05<br />		<br />		dec	&#91;ly&#93;<br />		cmp	&#91;ly&#93;,0<br />		jg	@@st04<br />		<br />		ret<br /><br />endp		ImageToRGB<br /><br /></code></pre><br /><br />I will do some measurements, my purpose is to make it faster than the vc++ one, any suggestion/trick is appreciated.<br /><br />Thanks all again, B7</div>
    <div class="meta">Posted on 2003-08-26 16:45:18 by Bit7</div>
   </div>
  </div>
 </body>
</html>