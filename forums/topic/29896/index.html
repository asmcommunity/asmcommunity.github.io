<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>crc collisions - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29896" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=29896">crc collisions</a></p>
   <div class="post" id="post-211161">
    <div class="subject"><a href="#post-211161">crc collisions</a></div>
    <div class="body">just thought i would post some stuff i&#039;m working on.<br /><br />the crcgen and getcrc procs are both size optimized, ill probably end up writing some speed optimized procs later,&nbsp; the crccollision proc is pretty much brute force.<br /><br />i had to multithread it because on my quad core, windows(xp) would only assign a single processor core per thread.<br /><br />the code is pretty rough and needs some improvement however it does work pretty well.<br /><br />anyways, all it does is appends a dword to the modified file, increments the dword then checks the crc against the original crc and loops till a collision happens.<br /><br />edit: looks like im having issues with the multithreading. ill try to work that out tonight.<br />edit: race condition. anyways the code is UGLY ill clean it up later, but the error looks like its completely fixed.<br /><br /><pre><code><br />.586<br />.model flat, stdcall<br />option casemap:none<br /><br />include windows.inc<br />include kernel32.inc<br />include user32.inc<br />includelib kernel32.lib<br />includelib user32.lib<br /><br />.data<br />filenameo	db &quot;orig.crc&quot;,0<br />filenamec	db &quot;coll.crc&quot;,0<br />error		db &quot;generic error message&quot;,0<br />format		db &quot;collision = %08lx&quot;,0<br />thread1		dword 0<br />thread2		dword 1<br />thread3		dword 2<br />thread4		dword 3<br />threads1	dword 000000000H<br />threads2	dword 03FFFFFFFH<br />threads3	dword 07FFFFFFFH<br />threads4	dword 0BFFFFFFFH<br />threads5	dword 0FFFFFFFFH<br /><br />.data?<br />crctable	dword 256 dup(?)<br />crc			dword ?<br />hfileo		dword ?<br />hfilec		dword ?<br />fsizeo		dword ?<br />fsizec		dword ?<br />tempo		dword ?<br />tempc		dword ?<br />bytesread	dword ?<br />collision	dword ?<br />crcorig		dword ?<br />falloc		dword ?<br />threadid1	dword ?<br />threadid2	dword ?<br />threadid3	dword ?<br />threadid4	dword ?<br />tarray		dword 4 dup(?)<br />output		dword 10 dup(?)<br /><br />.code<br /><br />crccollision proc uses ebx ecx edx param:DWORD<br />		mov ecx, <br />		mov ebx, ecx<br />		mov ebx, <br />		mov ecx, <br />		shl ecx, 2<br />		add ecx, offset threads1<br />		mov edx, ecx <br />		mov ecx, <br />		add edx, 4<br />		mov edx, <br />		mov edi, crcorig<br />		mov esi, tempc<br />		mov eax, fsizec<br />		push edx<br />		mul ebx<br />		pop edx<br />		add esi, eax<br />		mov ebx, esi<br />		add esi, <br />		sub esi, 4<br />@@:		cmp , 0<br />		jne @nocol<br />		push fsizec<br />		push ebx<br />		call getcrc<br />		inc ecx<br />		mov , ecx<br />		cmp ecx, edx<br />		je @nocol<br />		cmp eax, edi<br />		jne @B<br />		dec ecx<br />		mov collision, ecx<br />@nocol:	ret	<br />crccollision endp<br /><br />getcrc proc uses ebx ecx edx esi edi buffer:DWORD, buffersize:DWORD<br />		mov ecx, buffersize<br />		mov edx, buffer<br />		xor eax, eax<br />		dec eax<br />@@:		mov ebx, eax<br />		shr eax, 8<br />		mov esi, <br />		xor ebx, esi<br />		movzx ebx, bl<br />		mov ebx, <br />		xor eax, ebx<br />		inc edx<br />		loop @B<br />		not eax<br />		ret<br />getcrc endp<br /><br />crcgen proc uses eax ebx ecx edx <br />		mov ebx, 0EDB88320h<br />		xor ecx, ecx<br />outter:	mov eax, ecx<br />		mov dl, 8<br />inner:	push eax<br />		and al, 1<br />		or al, al&nbsp; &nbsp; <br />		pop eax<br />		jne fail<br />		shr eax, 1<br />	&nbsp; &nbsp; jmp pass<br />fail:	shr eax, 1<br />		xor eax, ebx<br />pass:	dec dl<br />		jne inner<br />		mov dword ptr , eax<br />		inc ecx<br />		cmp ch, 1<br />		jne outter<br />		ret<br />crcgen endp<br /><br /><br /><br />start:<br /><br />call crcgen<br /><br />invoke CreateFile, offset filenameo, GENERIC_READ or GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL<br />or eax, eax<br />je @err1<br /><br />mov hfileo, eax<br /><br />invoke CreateFile, offset filenamec, GENERIC_READ or GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL<br />or eax, eax<br />je @err1<br /><br />mov hfilec, eax<br /><br />invoke GetFileSize, hfileo, NULL<br />or eax, eax<br />je @err2<br /><br />mov fsizeo, eax<br /><br />invoke GetFileSize, hfilec, NULL<br />or eax, eax<br />je @err2<br /><br />mov fsizec, eax<br /><br />invoke VirtualAlloc, NULL, fsizeo, MEM_COMMIT or MEM_RESERVE, PAGE_READWRITE<br />or eax, eax<br />je @err3<br /><br />mov tempo, eax<br /><br />mov eax, fsizec<br />add eax, 4<br />shl eax, 2<br /><br />mov falloc, eax<br /><br />invoke VirtualAlloc, NULL, falloc, MEM_COMMIT or MEM_RESERVE, PAGE_READWRITE<br />or eax, eax<br />je @err3<br /><br />mov tempc, eax<br /><br /><br />invoke ReadFile, hfileo, tempo, fsizeo, offset bytesread, NULL<br />or eax, eax<br />je @err3<br /><br />mov bytesread, 0<br /><br />mov edi, tempc<br />add fsizec, 4<br />mov esi, 4<br />@@:<br />invoke ReadFile, hfilec, edi, fsizec, offset bytesread, NULL<br />or eax, eax<br />je @err3<br />invoke SetFilePointer, hfilec, NULL, NULL, FILE_BEGIN<br />add edi, fsizec<br />dec esi<br />jne @B<br /><br />push fsizeo<br />push <br />call getcrc<br />mov crcorig, eax<br /><br /><br />mov edi, offset thread1<br />mov esi, offset tarray<br />mov ebx, offset threadid1<br />mov ecx, 4<br />@@: <br />push ecx<br />invoke CreateThread, NULL, NULL, addr crccollision, edi, NULL, ebx<br />mov , eax<br />pop ecx<br />add edi, 4<br />add esi, 4<br />add ebx, 4<br />loop @B<br /><br />invoke WaitForMultipleObjects, 4, offset tarray, 1, -1<br /><br />mov ecx, <br />bswap ecx<br />invoke wsprintf, offset output, offset format, ecx<br />invoke MessageBox, 0, offset output, 0, 0<br /><br />invoke VirtualFree, tempo, 0, MEM_DECOMMIT or MEM_RELEASE<br />invoke CloseHandle, hfileo<br />invoke VirtualFree, tempc, 0, MEM_DECOMMIT or MEM_RELEASE<br />invoke CloseHandle, hfilec<br /><br />invoke ExitProcess,0<br /><br /><br />@err3:<br />invoke VirtualFree, tempo, 0, MEM_DECOMMIT or MEM_RELEASE<br />@err2:<br />invoke CloseHandle, hfileo<br />@err1:<br />invoke MessageBox,0, offset error, 0, 0<br />invoke ExitProcess,-1<br />end start<br /></code></pre></div>
    <div class="meta">Posted on 2010-03-29 18:47:42 by paradox</div>
   </div>
   <div class="post" id="post-211164">
    <div class="subject"><a href="#post-211164">Re: crc collisions</a></div>
    <div class="body"><div class="quote">i had to multithread it because on my quad core, windows(xp) would only assign a single processor core per thread.</div>Yes, that&#039;s how multi-core systems work? You can&#039;t magically &quot;run a thread on multiple cores&quot;.<br /><br />crccollision proc:<br />You pushad unconditionally, but popad happens conditionally (only if you have a collision). You don&#039;t need to pushad/popad anyway, the calling convention is EAX/ECX/EDX=scratch, EBX/ESI/EDI=preserve.<br /><br />You run this proc from multiple threads, but write to a single global &quot;collision&quot; variable - bad. Even worse, the thread modifies the memory buffer. <br /><br />What&#039;s with the Sleep() calls after the CreateThread() calls? Pretty senseless - at least once you rewrite your code to be threadsafe ;)</div>
    <div class="meta">Posted on 2010-03-29 23:11:31 by f0dder</div>
   </div>
   <div class="post" id="post-211165">
    <div class="subject"><a href="#post-211165">Re: crc collisions</a></div>
    <div class="body">fodder, yep you nailed the problem<br /><br />its ugly but now its thread safe, it didn&#039;t click that i had 4 threads writing to a single global dword.<br /><br />it wasn&#039;t collision that was causing the problem, it was <br /><br />push fsizec<br />push tempc<br />call getcrc<br /><br />all 4 threads were writing to tempc+fsizec<br /><br />collision should only be written to by a single thread where the collision happens then all the other threads should exit.<br /><br />i was trying the sleeps to see if it was a problem with thread creation.<br /><br />to be honest i have zero experience with threading, this is the first piece of code ive needed to thread.</div>
    <div class="meta">Posted on 2010-03-29 23:52:39 by paradox</div>
   </div>
   <div class="post" id="post-211166">
    <div class="subject"><a href="#post-211166">Re: crc collisions</a></div>
    <div class="body">Each thread is *reading* the tempc and fsizec variables, not writing to them. This isn&#039;t a problem. However, each thread is writing to the memory buffer *pointed to* by tempc - and this is a no-go, you need to duplicate the buffer per-thread since you&#039;re modifying it.<br /><br /><div class="quote">collision should only be written to by a single thread where the collision happens then all the other threads should exit.</div>This requires some amount of additional logic, and won&#039;t be worth it unless each thread is expected to run for a fair amount of time. The basic idea would be running your inner loop for X iterations, check a global &quot;hasCollisionBeenFound&quot; flag, and continue the inner loop if the flag isn&#039;t set. Some people would claim TerminateThread is an alternative, but that really is equivalent to dropping a tactical nuke.</div>
    <div class="meta">Posted on 2010-03-30 02:04:26 by f0dder</div>
   </div>
   <div class="post" id="post-211167">
    <div class="subject"><a href="#post-211167">Re: crc collisions</a></div>
    <div class="body">Each thread is *reading* the tempc and fsizec variables, not writing to them. This isn&#039;t a problem. However, each thread is writing to the memory buffer *pointed to* by tempc - and this is a no-go, you need to duplicate the buffer per-thread since you&#039;re modifying it.<br /><br />------------------------------------------------------------------<br /><br />thats what i meant :), i updated the code before i posted last time so each thread has its own buffer now. <br /><br />---------------------------------------------------------------------<br />This requires some amount of additional logic, and won&#039;t be worth it unless each thread is expected to run for a fair amount of time. The basic idea would be running your inner loop for X iterations, check a global &quot;hasCollisionBeenFound&quot; flag, and continue the inner loop if the flag isn&#039;t set. Some people would claim TerminateThread is an alternative, but that really is equivalent to dropping a tactical nuke.<br /><br />each thread is expected to run for a minimum of 30 seconds ( usually 2 minutes ) and  is checked at the start of the loop and if  != 0 the loop breaks and the thread terminates.  is only written to once a valid collision is found so its pretty much the same thing as you suggested.&nbsp; ill end up re-writing most of it this week so its a lot neater and more stable this was mainly a proof of concept as i haven&#039;t done much with threading or hash collisions.</div>
    <div class="meta">Posted on 2010-03-30 02:25:52 by paradox</div>
   </div>
   <div class="post" id="post-211182">
    <div class="subject"><a href="#post-211182">Re: crc collisions</a></div>
    <div class="body">Is this a multithreading exercise? ...because crc32 is reversible.</div>
    <div class="meta">Posted on 2010-03-31 19:18:23 by drizz</div>
   </div>
   <div class="post" id="post-211184">
    <div class="subject"><a href="#post-211184">Re: crc collisions</a></div>
    <div class="body"><div class="quote">Is this a multithreading exercise? ...because crc32 is reversible.</div>Isn&#039;t that only if the message is &lt;= 4 bytes?<br /><br />Injecting/fixing data to the stream to make the CRC match != reversible :)</div>
    <div class="meta">Posted on 2010-04-01 02:13:18 by f0dder</div>
   </div>
   <div class="post" id="post-211192">
    <div class="subject"><a href="#post-211192">Re: crc collisions</a></div>
    <div class="body"><div class="quote">anyways, all it does is appends a dword to the modified file, increments the dword then checks the crc against the original crc and loops till a collision happens.</div><div class="quote">Injecting/fixing data to the stream to make the CRC match != reversible :)</div><br />Sure, you can also append a dword to make the CRC match.<br /><br />Here&#039;s a tuto<br />http://www.codebreakers-journal.com/downloads/cbj/2004/CBJ_1_1_2004_Anarchriz_CRC_and_how_to_Reverse_it.pdf<br /><br />I&#039;ve attached my source code and an example.</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3102" target="_blank">crc32test.7z</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-04-01 11:03:42 by drizz</div>
   </div>
   <div class="post" id="post-211195">
    <div class="subject"><a href="#post-211195">Re: crc collisions</a></div>
    <div class="body"><div class="quote"><br />Here&#039;s a tuto<br />http://www.codebreakers-journal.com/downloads/cbj/2004/CBJ_1_1_2004_Anarchriz_CRC_and_how_to_Reverse_it.pdf<br /></div><br /><br />Heh, small world.<br />Anarchriz was in my class when he wrote this paper. He was a friend of mine. I think I&#039;m actually one of the guys who proofread it at the time :)</div>
    <div class="meta">Posted on 2010-04-01 15:29:04 by Scali</div>
   </div>
  </div>
 </body>
</html>