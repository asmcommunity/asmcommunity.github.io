<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Intercept a windows API function? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=1470" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=1470">Intercept a windows API function?</a></p>
   <div class="post" id="post-9499">
    <div class="subject"><a href="#post-9499">Intercept a windows API function?</a></div>
    <div class="body">How could I intercept a windows API function?<br />I have seen people who did something like this somewhere, but I don't remember where.<br />I would like to write an app that would intercept the function DeleteFile and display me a message asking if I aprove. If I let the file be deleted, the app would call the actual DeleteFile function.<br />I think this has something to do with changing the kernel dll memory.<br />I hope you can understand what I am trying to ask.<br />Thanks in advance.<br />=)</div>
    <div class="meta">Posted on 2001-10-15 20:39:46 by dilau</div>
   </div>
   <div class="post" id="post-9501">
    <div class="subject"><a href="#post-9501">Intercept a windows API function?</a></div>
    <div class="body">I have been checking into this myself, and believe me, the info can be quite hard to find :)<br /><br />There are two different methods you could try. There is the method used in the app Regmon, you can read about it and download the source from <a target="_blank" href="http://www.sysinternals.com/.">http://www.sysinternals.com/.</a> Check their site out, it has some good stuff on it.<br /><br />Matt Pietrek also has a method for doing it, which is detailed in his book &quot;Windows 95 System Programming Secrets&quot;. The method he uses will work on both W9x and NT machines. This book is out of print, but there is a pdf version of it floating around on the net, get back to me if you can't obtain it (wink). <br /><br />There are also a couple of MSJ articles from circa '94 and '95 dealing with it, however i have been unable to track down the actual text of them, let me know if you manage to get them (MS conveniently have left these article titles in their indexes, but have failed to include the actual article on their site or on the MSDN cds).<br /><br />HTH,<br />sluggy</div>
    <div class="meta">Posted on 2001-10-15 21:26:15 by sluggy</div>
   </div>
   <div class="post" id="post-9504">
    <div class="subject"><a href="#post-9504">Intercept a windows API function?</a></div>
    <div class="body">There are lots of tutorials on this topic (API Hooking) and I am sure you will have no trouble finding tutorials and articles about this rather popular topic. I would rather recommend ApiHooks from ELiCZ, check it out at <a target="_blank" href="http://www.anticracking.sk/EliCZ/.">http://www.anticracking.sk/EliCZ/.</a></div>
    <div class="meta">Posted on 2001-10-15 21:53:53 by comrade</div>
   </div>
   <div class="post" id="post-9506">
    <div class="subject"><a href="#post-9506">Intercept a windows API function?</a></div>
    <div class="body">There is an API spy program available at <a target="_blank" href="http://www.internals.com">http://www.internals.com</a> .  If you download it and test it, you'll find it's an excellent program.  You can send him an email and he'll send you the source code but you have to make an agreement about not using the source for profit.<br /><br /><br />Thanks,<br />_Shawn</div>
    <div class="meta">Posted on 2001-10-15 21:58:37 by _Shawn</div>
   </div>
   <div class="post" id="post-9549">
    <div class="subject"><a href="#post-9549">Intercept a windows API function?</a></div>
    <div class="body">Anything in &quot;&quot;Windows 95 System Programming Secrets&quot; should be<br />taken with a grain of salt, a lot of the information isn't valid anymore :/.<br />EliCZ stuff is good. A pretty funky and well-working (as far as I know)<br />method is the one used in &quot;detours&quot;, which can be found at <a target="_blank" href="http://www.research.microsoft.com/sn/detours/">http://www.research.microsoft.com/sn/detours/</a></div>
    <div class="meta">Posted on 2001-10-16 15:41:33 by f0dder</div>
   </div>
   <div class="post" id="post-9579">
    <div class="subject"><a href="#post-9579">reply</a></div>
    <div class="body">Take a look at  Lucifer48 Site<br />--&gt; <a target="_blank" href="www.multimania.com/lucifer48">www.multimania.com/lucifer48</a><br /><br />--&gt;100% Win32ASM<br />--&gt; Project II - Hookall<br /><br />this project is unfinished and replaces kernel-Api-code with yours via Ring-0 (vxd)<br />but there are other ways to bypass the writeprotection in memory-areas (Kernel for example)<br /><br />hope this helps a bit</div>
    <div class="meta">Posted on 2001-10-17 01:57:57 by CRYO</div>
   </div>
   <div class="post" id="post-9815">
    <div class="subject"><a href="#post-9815">Intercept a windows API function?</a></div>
    <div class="body">Thanks everyone.<br />Those sites really helped me understand how to do what I want.<br />I read some articles about changing the import table of the EXEs that I want to intercept. But since I want to intercept all of them, wouldn't be easier to change the kernel32.dll export table?<br />Is that possible? Does anyone have any information about that?<br />Thanks in advance.</div>
    <div class="meta">Posted on 2001-10-20 10:02:28 by dilau</div>
   </div>
   <div class="post" id="post-9816">
    <div class="subject"><a href="#post-9816">Intercept a windows API function?</a></div>
    <div class="body">You'll definitely have to go ring0 to do that... iirc, virtualprotect and<br />read/writeprocessmemory don't work above &quot;a magic limit&quot;, where<br />the kernel related files live.</div>
    <div class="meta">Posted on 2001-10-20 10:07:32 by f0dder</div>
   </div>
   <div class="post" id="post-9819">
    <div class="subject"><a href="#post-9819">Intercept a windows API function?</a></div>
    <div class="body">The &quot;detours&quot; library only works correctly on Windows 2000, NT, and XP. Alot of the stuff wont work on Windows 9x platforms.<br /><br />I wanted to try some of this info, but I guess I cant.<br /><br />Torch</div>
    <div class="meta">Posted on 2001-10-20 10:57:31 by Torch</div>
   </div>
   <div class="post" id="post-9861">
    <div class="subject"><a href="#post-9861">Intercept a windows API function?</a></div>
    <div class="body">hey fodder,<br />that's not true at all.<br /><br />i' ve found a way to write to kernel without entering Ring-0 in some eZine 'Matrix#2'. Give it a try! It plays around with the pagetable. But be warned! It's a little bit abstract and hard to understand. But it works.<br />But maybe there are some compatiblity prblems on NT or 2K<br /><br />the article follows here:<br /><br />           WRITING INTO KERNEL FROM RING-3: LETS FUCK PAGETABLE<br />            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br />                  xlated from russian for MATRiX #2 E-Zine<br />                              (x) 2000 Z0MBiE<br /><br />  WARNING #1.<br />  Before reading this text, it is strongly recommended to read some<br />  documentation about page table, protected mode, memory organisation, etc.<br /><br />[*] PREFACE<br /><br />  Here will be described a method of writing into any region of memory<br />  from ring3 by means of pagetable modification.<br /><br />  Our task is to write data into some virtual (linear) address X.<br />  And let the write-protected memory page that contains address X<br />  will be called PageX.<br /><br />[*] getting access rights to address X<br /><br />  It is possible to get information about our access rights to address X<br />  in the following ways:<br /><br />  1. call win32 api: IsBadXXXPtr (XXX=Read,Write,Code,etc.)<br />  2. use SEH<br /><br />  1. IsBadXXXPtr<br />                        push    size-in-bytes<br />                        push    address<br />                        call    IsBadReadPtr<br />                        or      eax, eax<br />                        jnz     __can_not_read<br />__can_read:             ...<br /><br />  2. SEH<br />                        call    __seh_init<br />                        mov     esp, <br />                        stc<br />                        jmp     __seh_exit<br />__seh_init:             push    dword ptr fs:[0]<br />                        mov     fs:[0], esp<br /><br />                        mov     al, byte ptr <br />                        clc<br /><br />__seh_exit:             pop     dword ptr fs:[0]<br />                        pop     eax<br /><br />                        jc      __can_not_read<br />__can_read:             ...<br /><br />  Btw, IsBadXXXPtr functions (in win9X at least) uses SEH method too,<br />  so their execution with the same result just takes more time.<br /><br />  So, now we know how to find if PageX is write-protected<br /><br />[*] Page Table format<br /><br />  What is page table?<br />  All physical memory is divided into 4k-pages, which may be:<br />  read/write-protected and mapped into linear 4GB-length address space.<br />  Information about all this shit is stored in the page table.<br /><br />                                Page Table:<br />                                ~~~~~~~~~~~<br /><br /> 1st-level directory page             1024 x                physical memory<br /> aka Page Directory          2nd-level directory pages          pages<br /><br />   single 4k-page,       totally 1024*1024 DWORD-descriptors,<br /> physical addr in CR3    for any 4k page in 4GB address space<br /><br />  ??????????????               ?????????????<br />  ? DWORD #0    ?--------------&gt;? ?????????????           ????????????<br />  ??????????????               ?? DWORD #0   ?----------&gt;? ...       ?<br />  ? DWORD #1    ?----------------&gt;?????????????           ?????????????<br />  ??????????????               ?? DWORD #1   ?----------&gt;????????????<br />  : ...         :               : ?????????????           ? ...       ?<br />  : ...         :               : : ...        :           ?????????????<br />  ??????????????               ? : ...?????????????<br />  ? DWORD #1023 ?---------------------&gt;? DWORD #0   ?-------&gt; ...<br />  ???????????????               ??    ?????????????<br />                                  ????? DWORD #1   ?-------&gt; ...<br />                                       ?????????????<br />                                       : ...        :<br />                                       : ...        :<br />                                       ?????????????<br />                                       ? DWORD #1023?-------&gt; ...<br />                                       ??????????????<br /><br />  Each DWORD has the following format:<br />  (to find more details see documentation)<br /><br /> 31                           12 11                    0<br />---------------------------------------------------------<br />|                               |     |   | | |P|P|U|R| |<br />|     physical address   31..12 |AVAIL|0 0|D|A|C|W|/|/|P|<br />|                               |     |   | | |D|T|S|W| |<br />---------------------------------------------------------<br /><br />P        - present (if P=0, all other data is unused and the corresponding<br />                    page is absent in linear address space)<br /><br />R/W      - read/write                               -- bit 1 (0x02)<br />U/S      - user/supervisor                          -- bit 2 (0x04)<br /><br />[*] finding pagetable: variant 1<br /><br />  High 20 bits of the CR3 register is a physycal address of the page table,<br />  low 12 bits are zero (it just means that pagetable base is 4k-aligned).<br /><br />  But, if you will use 'MOV EAX, CR3' instruction, you will suck.<br />  This is because it is a privileged instruction, which may not be<br />  called from ring-3.<br />  Indeed, win9X will not generate an exception in this situation, but,<br />  it will not modify EAX too.<br /><br />  Now we may think a little, and find out, that copy of the CR3 register<br />  (for the current context!) is stored in the TSS.<br /><br />  Where to find TSS?<br />  TSS selector may be found using STR (Store Task Register) command.<br /><br />  So, we know everything to find CR3 register value.<br /><br />; subroutine: get_cr3<br />; output:     EBX=CR3<br /><br />get_cr3:                push    eax<br /><br />                        sgdt    <br />                        mov     ebx,     ; EBX&lt;--GDT.base<br /><br />                        str     ax              ; EAX&lt;--TSS selector<br />                        and     eax, 0FFF8h     ; optionally<br /><br />                        add     ebx, eax        ; EBX&lt;--TSS descriptor offset<br /><br />                        mov     ah,      ; EAX&lt;--TSS linear address<br />                        mov     al, <br />                        shl     eax, 16<br />                        mov     ax, <br /><br />                        mov     ebx,   ; EBX&lt;--CR3<br />                        and     ebx, 0FFFFF000h ; EBX&lt;--pagetable phys. offs<br /><br />                        pop     eax<br />                        ret<br /><br />  Btw, if you will change 'mov ebx, ' into 'mov ebx, ' in<br />  the code shown above, you will get ESP0, i.e. ESP of the code, that<br />  has called current task.<br /><br />  So, now we have CR3 register value, which is physical address of the<br />  page table.<br /><br />  But how can we use this fucking physical address in the PE file?<br />  Of course, in the ring-0 it may be converted into linear address<br />  using VxDcalls, but in winthin the win32 api there are no such<br />  api functions...<br /><br />[*] finding pagetable: variant 2<br /><br />  Now lets try to find pagetable in memory.<br /><br />  We will search not the first-level directory page,<br />  but that second-level directory page,<br />  that contains DWORD which describes PageX.<br /><br />  What do we know about this second-level page? Seems nothing.<br /><br />  But, life is not so bad. Above-mentioned IsBadReadPtr function can<br />  tell us, is some address readable or not. (a whole bit!)<br />  And each DWORD-element in the second-level directory page has U/S bitflag,<br />  which has the same meaning. ;-)<br />  And there are another bit (R/W) which determines writeability of the<br />  memory page, which may be found using IsBadWritePtr function.<br /><br />                ring-3 function     flags in the page descriptor<br />  read          IsBadReadPtr        U/S  user/supervisor<br />  write         IsBadWritePtr       R/W  read/write<br /><br />  So, calling IsBadRead/WritePtr functions for 1024 different pages we can<br />  generate 1024 DWORDs, and each DWORD will contain the same 2 bits,<br />  as in the 2nd-level directory page.<br /><br />  After that we will scan all the memory (really C0000000..D0000000),<br />  comparing each memory page to our generated page,<br />  but checking only these 2 bits in each DWORD.<br /><br />needtbl                 dd      1024 dup (?)<br /><br />; subroutine: find_kernel_pagetable<br />; return:     EBX=2ndlevel directory page (for addresses BFC00000...C0000000)<br /><br />find_kernel_pagetable:<br /><br />; create page of DWORDs (with 2 meaningful bits in each DWORD)<br /><br />                        lea     edi, needtbl    ; page of DWORDs<br />                        cld<br /><br />                        mov     esi, 0BFC00000h ; ESI--starting page<br /><br />__maketbl:              xor     ebp, ebp<br /><br />                        push    4096<br />                        push    esi<br />                        callW   IsBadReadPtr<br /><br />                        xor     eax, 1          ; 0 &lt;--&gt; 1<br />                        shl     eax, 2          ; 1 --&gt; 4<br />                        or      ebp, eax<br /><br />                        push    4096<br />                        push    esi<br />                        callW   IsBadReadPtr<br /><br />                        xor     eax, 1          ; 0 &lt;--&gt; 1<br />                        shl     eax, 1          ; 1 --&gt; 2<br />                        or      eax, ebp<br /><br />                        stosd<br /><br />                        add     esi, 4096       ; +1 page<br />                        cmp     esi, 0C0000000h ; totally 1024 pages<br />                        jne     __maketbl<br /><br />; find 2nd-level directory page<br /><br />                        mov     ebx, 0C0000000h   ; start address<br />__cycle:<br />                        push    4096              ; is current page readable?<br />                        push    ebx<br />                        callW   IsBadReadPtr<br />                        or      eax, eax<br />                        jnz     __cont<br /><br />                        xor     edi, edi          ; compare pages<br /><br />__scan:                 mov     eax, <br />                        and     eax, 2+4    ; only 2 bits has meaning for us<br />                        xor     eax, needtbl ; compare<br />                        jnz     __cont<br /><br />                        add     edi, 4<br />                        cmp     edi, 4096<br />                        jb      __scan<br /><br />                        clc                       ; found!<br />                        ret<br /><br />__cont:                 add     ebx, 4096         ; +1 page<br />                        cmp     ebx, 0D0000000h   ; end-address<br />                        jb      __cycle<br /><br />                        stc                       ; not found...<br />                        ret<br /><br />  So, we have found 2nd level directory page which describes<br />  1024 pages in  range.<br /><br />  Now, if we wanna change RW bit for address BFF70000 we do the following:<br /><br />                        ; find 2nd level directory page<br />                        call    find_kernel_pagetable<br />                        jc      __damnedsonofabitch<br /><br />                        ; clear protection (make page writeable)<br />                        c1 = (0BFF70000h-0BFC00000h)/1024<br />                        or      dword ptr , 2  ; RW=1<br /><br />                        ; check if all okey, if page really became writeable<br />                        push    4096<br />                        push    0BFF70000h<br />                        call    IsBadReadPtr<br />                        or      eax, eax<br />                        jnz     __exit<br /><br />                        ; fuck the kernel<br />                        not     dword ptr ds:[0BFF70000h]<br /><br />                        ; restore protection<br />                        and     dword ptr , not 2  ; RW=0<br /><br />  Now you may ask me: why did u used BFC00000 and C0000000 constants in<br />  the example above?<br />  This numbers are BFF70000 address, rounded up and down to the 4MB range.<br /><br />[*] damned shit<br /><br />  Maybe you think, we've just patched kernel? No. This really sucks.<br />  As it were found, the fucking 2nd-level directory page is just ABSENT<br />  in the current context, by default.<br />  So you really will find nothing.<br />  But, under fucking Soft-ICE all works. This is because it commits this<br />  2ndlevel page into current context, performing something like this:<br /><br />                        push    0<br />                        push    4096<br />                        push    physical-page-offset<br />                        VMMcall MapPhysToLinear<br />                        add     esp,3*4<br /><br />  And fucking VMM_MapPhysToLinear calls first VMM_PageReserve and then<br />  VMM_LinPageLock, in such way allocating new page in the current context<br />  and mapping physical page there.<br /><br />  So, we may find pagetable only if it is loaded into current context.<br /><br />[*] finding pagetable: back to variant 1<br /><br />  So, we have the following trouble: 2nd-level directory page may not be<br />  found, because it is absent in the current context.<br /><br />  Solution may be the following:<br />  1. try to find this fucking page in the different contexts<br />  2. map this page into current context<br /><br />  2nd variant seems better, so, question:<br />  how to convert physical address into linear without entering ring-0?<br /><br />  And here it is.<br /><br />KERNEL@ORD0             dd      0BFF713D4h      ; surely, it may be found<br /><br />; subroutine: phys2linear<br />; input:      EBX=physical address<br />; output:     EBX=linear address<br /><br />phys2linear:            pusha<br /><br />                        movzx   ecx, bx         ; BX:CX&lt;--EBX=phys addr<br />                        shr     ebx, 16<br /><br />                        mov     eax, 0800h      ; physical address mapping<br /><br />                        xor     esi, esi        ; SI:DI=size (1 byte)<br />                        xor     edi, edi<br />                        inc     edi<br /><br />                        push    ecx<br />                        push    eax<br />                        push    0002A0029h      ; INT 31 (DPMI services)<br />                        call    KERNEL@ORD0<br /><br />                        shl     ebx, 16         ; EBX&lt;--BX:CX=linear address<br />                        or      ebx, ecx<br /><br />                        mov     , ebx  ; popa.ebx<br /><br />                        popa<br />                        ret<br /><br />  So, now we know CR3 value and may xlate it into linear address.<br /><br />; subroutine: get_pagetable_entry<br />; input:      ESI=address<br />; output:     EDI=pagetable entry address<br /><br />get_pagetable_entry:    pusha<br /><br />                        call    get_cr3         ; take CR3<br />                        and     ebx, 0FFFFF000h ; EBX&lt;--pagetable phys. addr<br /><br />                        call    phys2linear     ; EBX&lt;--pagetable linear addr<br /><br />                        mov     eax, esi<br />                        and     eax, 0FFC00000h<br />                        sub     esi, eax<br />                        shr     eax, 20       ; EAX&lt;--1st-level dir page<br />                        shr     esi, 10       ; ESI&lt;--2nd-level dir page<br /><br />                        mov     ebx,   ; EBX&lt;--physical address<br />                        and     ebx, 0FFFFF000h ; of the needed page<br /><br />                        call    phys2linear   ; EBX&lt;--linear address<br /><br />                        add     esi, ebx      ; ESI&lt;--DWORD to patch<br /><br />                        mov     , esi    ; popa.edi<br />                        popa<br />                        ret<br /><br />  And, at last, all this shit may be used as this:<br /><br />                        mov     esi, 0BFF70000H<br />                        call    get_pagetable_entry<br />                        or      dword ptr , 2  ; PAGEFLAG_RW<br />                        ...<br />                        mov     byte ptr , xxxx  ; fuckup kernel<br />                        ...<br />                        and     dword ptr , not 2<br /><br />        Thats all!<br />                                   * * *</div>
    <div class="meta">Posted on 2001-10-21 00:50:21 by CRYO</div>
   </div>
   <div class="post" id="post-9879">
    <div class="subject"><a href="#post-9879">Intercept a windows API function?</a></div>
    <div class="body">yep...ring0 is not necessary under win9x to modify kernel.<br />the easyest way is to use the Int 2eh service, or deprotect the address you want to write to in kernel using the ORD_01 (VxDCall)-look in Vecna's hide proc which u should find on iczelion's site.</div>
    <div class="meta">Posted on 2001-10-21 06:41:06 by DZA</div>
   </div>
   <div class="post" id="post-9899">
    <div class="subject"><a href="#post-9899">Intercept a windows API function?</a></div>
    <div class="body">Interesting article, CRYO :alright:.<br />I guess I should have written &quot;You'll definitely have to go ring0 to do that (in a clean way)&quot;. :)<br /><br />I don't believe that the method set forth in the article will work under<br />nt/2k, btw. I mean, &quot;kernel32 ord0&quot; is VXDCall iirc, and... I find it hard<br />to believe that you have VXDCall under nt/2k ;). So, even if you can<br />find the physical adresses for the kernel tables, you still need to map<br />phys-&gt;linear, and that requires ring0 (or at least a detour to ring0),<br />which nt/2k generally isn't very fond of ;). I'll try playing around with<br />the stuff a bit and see if I can come up with something.</div>
    <div class="meta">Posted on 2001-10-21 08:59:16 by f0dder</div>
   </div>
   <div class="post" id="post-9954">
    <div class="subject"><a href="#post-9954">Intercept a windows API function?</a></div>
    <div class="body">What about this???<br />-You could patch the export table of kernel32 when it is on disk, with the address of a new func, so when a prog loads with and imports the address of the DeleteFile API it will get your value, and call your proc. Then you can call the real DeleteFile.<br /><br />Would that work?<br /><br />I am assuming you would have to update the CRC of kernel32 and this method would cause problems if your proc was relocated.<br /><br />You would also have to have your dll or whatever loaded with the prog to handle the calls with each running program.</div>
    <div class="meta">Posted on 2001-10-22 03:27:31 by huh</div>
   </div>
   <div class="post" id="post-9955">
    <div class="subject"><a href="#post-9955">Intercept a windows API function?</a></div>
    <div class="body">Well, you could &quot;sort of&quot; do this. Either you'd have to make the export<br />point to &quot;something else&quot; in kernel32, or you'd have to add a bunch<br />of code to k32 (either with the use of caves, or by adding a new<br />section). This *is* possible.<br /><br />Updating the crc is not necessary. The only time PE CRCs are used,<br />are for nt/2k/xp drivers, to prevent corrupted drivers from being loaded.<br /><br />However, messing with kernel32 on disk is a bad idea, for a couple<br />of reasons. If you mess up, you're in trouble :). Second, patching the<br />file is not so easy, as the file is always in use. Under 9x you can boot<br />to real dos mode and fix it, but it's a bit harder under nt/2k. Also,<br />under 2k/xp (and WinMe?), you will be battling system file protection.</div>
    <div class="meta">Posted on 2001-10-22 04:04:50 by f0dder</div>
   </div>
   <div class="post" id="post-10358">
    <div class="subject"><a href="#post-10358">Intercept a windows API function?</a></div>
    <div class="body">Thanks again everyone. I think I am on my way to get this done.<br />The HideProc example in the Source Codes section does exactly what I want, but it intercepts the functions Process32First and Process32Next. I want to intercept DeleteFile.<br />The program is written for TASM. I use MASM. I think I was able to translate the .inc files (I wasn't able to compile the program in MASM yet). I didn't understand the main .asm file. There is code inside the .data section. Is that possible? I think MASM didn't accept that.<br />Here is the beginning of the code:<br /><br />;============================<br />.386<br />.model flat<br />locals<br /><br />ofs equ offset<br />by  equ byte ptr<br />wo  equ word ptr<br />dwo equ dword ptr<br /><br />include pe.inc                          ;29A inc files<br />include mz.inc<br />include win32api.inc<br /><br />include process.inc<br /><br />.data<br />titulo db &quot;HIDEPROC - Stealth W9x process&quot;, 0<br />msg1   db &quot;KERNEL32 already patched&quot;, 0<br />msg2   db &quot;KERNEL32 has not available space for our code&quot;, 0<br />msg3   db &quot;KERNEL32 patched&quot;, 0<br /><br />dll    db &quot;kernel32.dll&quot;, 0<br />api001 db &quot;Process32First&quot;, 0<br />api002 db &quot;Process32Next&quot;, 0<br /><br />vxdcall0 dd 0<br /><br />IMPLANT EQU THIS BYTE<br /><br />p32f_entry:<br />       call swap_p32f<br />       push dwo                  ;buffer<br />       push dwo                  ;snapshot<br />       call _p32f<br />       test eax, eax<br />       jz @@error                       ;wasnt sucessful...<br />       call check_name<br />       jnz @@error<br />       call swap_p32f<br />       push dwo                  ;yeahh, stealth it!<br />       push dwo <br />       call p32n_entry<br />       ret 2*4<br />(lots of code here)<br />(Here is the end of the data section:)<br />swap:<br />       pushad<br />       mov eax, <br />       xchg , eax<br />       mov , eax<br />       mov al,                   ;swap 5-byte buffers<br />       xchg , al<br />       mov , al<br />       popad<br />       ret<br /><br />p32n_code db 5 dup (0)<br /><br />p32f_code db 5 dup (0)<br /><br />IMPLANT_SIZE EQU $-ofs IMPLANT<br /><br />.code<br />;=============================<br /><br />Can anyone help me translate this to MASM?<br />Or can someone help me find some kind of TASM manual that explains this?<br />Thanks in advance.</div>
    <div class="meta">Posted on 2001-10-26 17:26:27 by dilau</div>
   </div>
   <div class="post" id="post-109696">
    <div class="subject"><a href="#post-109696">Intercept a windows API function?</a></div>
    <div class="body">Well there are always times you'll want systemwide hooks or hooking multiple things but in all hookingprojects I've done single application spesific hooking is what I've wanted todo because<br />1: I only want to hook stuff and get info/do stuff with that app? doh :P<br />2: Because it's cleaner when you are hooking just what you want....<br /><br />The easiest way you could hook some app you want to hook is to write a loader/GUI that either<br /><br />a: Lets you choose a file on disk, then CreateProcess it suspended and inject a DLL<br />b: Use Toolhelp32 to find all running processes and let the user choose that way and inject the DLL (or as I've done in my prog, let you choose both running and progs on disk).<br /><br />Then in the DllMain on attach just rewrite the import-table of the process you loaded into (GetModuleHandle(0)...) and you'll have patched only that app.... There is only one negative side with doing it this way and that is if the application is packed or simular because then you often can't get the importtable (atleast not without a lot of reversing)....<br /><br />Oh yea and if you are having problems hooking ie GetProcAddress inn kernel32.dll then you can hook LdrGetProcedureAddress inn ntdll.dll instead :P</div>
    <div class="meta">Posted on 2003-07-08 16:56:01 by SFP</div>
   </div>
  </div>
 </body>
</html>