<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>C like strings in MASM - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17217" />
  <link rel="prev" href="../?id=17217&amp;page=4" />  <link rel="next" href="../?id=17217&amp;page=6" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=17217">C like strings in MASM</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=17217&amp;page=1" style="">&laquo;</a><a href="../?id=17217&amp;page=4" style="">&lt;</a><input type="hidden" name="id" value="17217" /><input type="number" name="page" min="1" max="7" step="1" value="5" onchange="this.form.submit();" /><a href="../?id=17217&amp;page=6">&gt;</a><a href="../?id=17217&amp;page=7">&raquo;</a></form>   <div class="post" id="post-133875">
    <div class="subject"><a href="#post-133875">C like strings in MASM</a></div>
    <div class="body">Don't worry about the HeapAlloc thing, it didn't insult me - and I can easily see why you got this idea :). For me it's just about using HeapAlloc for generic allocations (since that's sorta what MSDN recommends), and &quot;whatever scheme&quot; (custom manager, pooled strings, whatever) ontop of HeapAlloc or &quot;pretty custom VirtualAlloc&quot; schemes where necessary. This would also involve discouraging people from using Memory Mapped Files for generic memory allocation purposes, for instance :)<br /><br />As for the scali thing... I generally like the guy, since I know how to deal with him, and why he thinks like he does. He tends to get lost in details, but that's not too stange in the context of assembly, where scali is the type that focuses on getting a small piece of code running *fast*. I think he forgets that a lot of people here writte assembly &quot;just because&quot;, and don't care too much about speed (or are still young and na?ve and think &quot;just because it's asm it's faster&quot;, heh).<br /><br />It's unfortunate that it always seems to end this way and the tone becomes so agressive, but I must admit that I prefer scali's way to hutch'es behaviour. Bullying around, twisting words, spewing non-info. I don't know who's worst, but at least scali doesn't hide behind a mask of niceness. Oh well, it's no secret that I've been pissed at hutch since he called me a virus writer.</div>
    <div class="meta">Posted on 2004-02-17 11:34:29 by f0dder</div>
   </div>
   <div class="post" id="post-133877">
    <div class="subject"><a href="#post-133877">C like strings in MASM</a></div>
    <div class="body"><div class="quote">I think he forgets that a lot of people here writte assembly &quot;just because&quot;, and don't care too much about speed (or are still young and na?ve and think &quot;just because it's asm it's faster&quot;, heh).</div><br /><br />I think the issue is more that these people get annoyed when someone tells them there's a way to improve their code, and even go as far as determining for the entire forum that this is not interesting at all.<br />The only right answers would be: &quot;You're right, thanks for pointing that out, I will use it from now on.&quot;<br />or &quot;You're right, but it's not important to me, I will continue my usual way&quot;.<br />Anything else is just silly.</div>
    <div class="meta">Posted on 2004-02-17 11:38:49 by Henk-Jan</div>
   </div>
   <div class="post" id="post-133881">
    <div class="subject"><a href="#post-133881">C like strings in MASM</a></div>
    <div class="body">It would be easier to get either reaction if you were a bit less agressive, though. But, hey, it *is* easy to become annoyed when people seem ignorant to you.</div>
    <div class="meta">Posted on 2004-02-17 11:49:58 by f0dder</div>
   </div>
   <div class="post" id="post-133883">
    <div class="subject"><a href="#post-133883">C like strings in MASM</a></div>
    <div class="body">It would be easier to get either reaction if people would wait long enough with answering until they actually understood what they just read. Cross-referencing info is not a bad idea either.. Like checking whether it is actually in the Intel manuals, before someone spoonfeeds it to you (why should the one providing the info always supply an exact source? It takes time to go through a manual and find out exactly where it is mentioned. Besides, any decent asm programmer should have read the manual anyway, so why can we not just assume it as wellknown truth?). Then there would be no denying of facts, and there can exist no argument.<br />The same goes for the SGI-case.<br />I think some people are just too confident about their knowledge, and think they don't have to cross-reference. Or that they think that because they don't like someone, that person can never provide any factual information or whatever.<br /><br />I don't think that way. Facts are completely independent of who mentions them.</div>
    <div class="meta">Posted on 2004-02-17 11:57:01 by Henk-Jan</div>
   </div>
   <div class="post" id="post-133929">
    <div class="subject"><a href="#post-133929">C like strings in MASM</a></div>
    <div class="body">OK, since I was gone WTF just happened?<br /><br />Please don't tell me this is another ASM and C war, geeze I make effective use of both....(C++ I'm learning, albeit slowly :) )<br /><br />Please explain what happened? I'm quite busy studying and dont have time to read 6 PAGES?!?!</div>
    <div class="meta">Posted on 2004-02-17 15:33:18 by x86asm</div>
   </div>
   <div class="post" id="post-133932">
    <div class="subject"><a href="#post-133932">C like strings in MASM</a></div>
    <div class="body"><div class="quote">Please explain what happened? I'm quite busy studying and dont have time to read 6 PAGES?!?!</div><br /><br />I pointed out that one of the proposed methods (embedding the string in the code) did not work quite like in C (where strings are in the data section), and had some cache disadvantages (as the Intel manuals also point out)... Then someone started a war about it because he took it as a personal insult or something... Nothing interesting anyway.</div>
    <div class="meta">Posted on 2004-02-17 15:49:07 by Henk-Jan</div>
   </div>
   <div class="post" id="post-133933">
    <div class="subject"><a href="#post-133933">C like strings in MASM</a></div>
    <div class="body">Henk and f0dder I respect both you guys as coders as both of you have offered help when I have asked questions but I mean come on dont you think your being a little childish here? Saying someone is an idiot because they deliberately screw up cache performance I think is a little too far. I mean there is no point to chase performance where it is not needed, this principle which many use in HLL's can be used in ASM as well with MACROS that make ASM easier, sure they may screw up the pipelines or that (?) MOESI stuff (hehe, I researched I wanna become a microprocessor engineer :D) but if it makes ASM code more readable I don't mind taking the hit in performance.</div>
    <div class="meta">Posted on 2004-02-17 15:57:39 by x86asm</div>
   </div>
   <div class="post" id="post-133937">
    <div class="subject"><a href="#post-133937">C like strings in MASM</a></div>
    <div class="body"><div class="quote"> mean there is no point to chase performance where it is not needed</div><br /><br />There is no point to screw up performance where it is not needed either.<br /><br /><div class="quote">if it makes ASM code more readable I don't mind taking the hit in performance.</div><br /><br />That's not the issue here though. There's no difference in ease-of-use, or readability, or anything, for the different methods of storing strings. So it makes no sense to choose an inferior performing macro, since there is no other value to gain whatsoever.</div>
    <div class="meta">Posted on 2004-02-17 16:10:15 by Henk-Jan</div>
   </div>
   <div class="post" id="post-133953">
    <div class="subject"><a href="#post-133953">C like strings in MASM</a></div>
    <div class="body">I accept that f0dder made a genuine mistake in asserting the SADD macro wrote to the code section when in fact it writes to the initialised data section. Just an attention to detail matter.<br /><br />To answer the original question that was asked, C string over many years is a sequence of characters terminated by an ascii zero. Unicode strings are technicaly different. Now MASM handles C string in the normal manner when it uses the notation,<br /><pre><code><br />MyString db &quot;This is a C string&quot;,0<br /></code></pre><br />Now where the debate has been is whether cache considerations actually matter when data is embedded in the code section.<br /><br />Anyone who can write assembler knows data in the code section is normal code and this is where you use an immediate operand.<br /><pre><code><br />mov eax, 1<br /></code></pre><br />The immediate &quot;1&quot; IS data.<br /><br />So is a table written in the code section to avoid the fetch delays of reading data from the data section.<br /><br />String data written in the code section is not as common for historical reason that follow from the segmented architecture of old DOS code but the complaints about using the technique in very small files does not pass the test of relevance.<br /><br />A substantial amount of code never handles processor intensive algorithms so there is no point in trying to structure the data in a way that is suitable for a non-existent high speed algo. Trying to do so is lousy design by a person who simply does not know how and why a program works.<br /><br />With examples like embedding a control class name before a CreateWindowEx function call, the entire function fits into the code cache so code like,<br /><pre><code><br />jmp @F<br />BtnClass db &quot;BUTTON&quot;,0<br />@@&#58;<br /></code></pre><br />in fact does not break the code cache as it is 7 characters long.<br /><br />Then there is the example of writing string data after the start of the code section but before the entry point label.<br /><pre><code><br />.code<br />MyStringData db &quot;I am written in the code section&quot;,0<br />start&#58;<br /></code></pre><br />What is being confused here by our proponent of data section purity is that the data before the start: label is never read into the code cache yet it is clearly data in the code section.<br /><br />Blanket statements made on misunderstandings of processor performance and a lack of understanding or the PE specifications demonstrate ignorance on the part of the speaker which could be excused if he confined his ignorance to his own circle but he has in fact tried to confuse people here with his ignorance.<br /><br />Since I do put my money where my mouth is, the example in the MASM32 example code called &quot;smallwin&quot; in the example9 directory in 1536 bytes and it is a demo of SIZE that was originally aimed at the TASM example WEP that was 8k in SIZE.<br /><br />Now note here that the size for a working window IS 1536 bytes, not the minimum 28k of a current C compiler or needing to perform unusual entry pointv design in C code to avoid all of the bloat in the default file layout.<br /><br />When SIZE matters, assembler programmers have all sorts of wicked little tricks and not adding a data section is simply one of them. It may feel profound when manipulating big bad mannered pigs in C to make noises about cache performance but assembler programmers are not saddled with such piles of crap and can write what they want.<br /><br />Not that any technical consideration actually matters here, our friend think he can win an argument when he is wrong again by weight of his wit and rhetoric.<br /><br />Regards,<br /><br />http://www.asmcommunity.net/board/cryptmail.php?tauntspiders=in.your.face@nomail.for.you&amp;id=2f46ed9f24413347f14439b64bdc03fd</div>
    <div class="meta">Posted on 2004-02-17 18:58:01 by hutch--</div>
   </div>
   <div class="post" id="post-133958">
    <div class="subject"><a href="#post-133958">C like strings in MASM</a></div>
    <div class="body"><div class="quote">The immediate &quot;1&quot; IS data.</div><br /><br />Semantically, yes. Technically it is encoded in the opcode for the instruction, and therefore the CPU considers it as code. And guess what? It ends up in the code cache, not the data cache.<br />So this is not the same as the string.<br />See, the difference is that with a string, you don't actually embed the data in opcodes. Instead, you pass a memory address to the CPU... The CPU will pass this address to the data cache, in order to fetch the data... Guess what? The data is not in the data cache yet! It's in the code cache! (or not cached at level 1 at all, in the case of P4).<br /><br /><div class="quote">in fact does not break the code cache as it is 7 characters long.</div><br /><br />And what exactly is this based on?<br />Where are the start and end-boundaries of your cacheline? This is an entirely hollow statement.<br /><br />Someone needs to read the Intel manuals again....<br /><br /><div class="quote">What is being confused here by our proponent of data section purity is that the data before the start: label is never read into the code cache yet it is clearly data in the code section.</div><br /><br />The entire case mentioned here was never discussed until you brought it up in your last post.<br /><br /><div class="quote">Blanket statements made on misunderstandings of processor performance and a lack of understanding or the PE specifications demonstrate ignorance on the part of the speaker which could be excused if he confined his ignorance to his own circle but he has in fact tried to confuse people here with his ignorance.</div><br /><br />The PE specifications have absolutely nothing to do with how the CPU cache works. Trying to use them as a crutch for your bruised ego-crap is just sad. And guess what... I can put data in the code in MZ files aswell! Which I have only mentioned about 10 times. Let's just keep ignoring that and repeating the same useless crap forever, until people are so numb that they will believe it!<br /><br /><div class="quote">Now note here that the size for a working window IS 1536 bytes, not the minimum 28k of a current C compiler or needing to perform unusual entry pointv design in C code to avoid all of the bloat in the default file layout.</div><br /><br />Nice try, but cynica_l can provide you with a Visual C++ project that will compile to a PE file with a working messagebox in about 700 bytes, without any manual tuning whatsoever. Just load the project, and build it. Don't judge tools if you don't know how to use them.<br /><br /><div class="quote">When SIZE matters, assembler programmers have all sorts of wicked little tricks and not adding a data section is simply one of them. It may feel profound when manipulating big bad mannered pigs in C to make noises about cache performance but assembler programmers are not saddled with such piles of crap and can write what they want.</div><br /><br />Firstly, this issue was never about ASM vs C, but rather about one version of a MASM macro versus another. Ofcourse, if you need to hide behind this kind of nonsense, that says a lot about you, and the lack of quality of your macro.<br />Secondly, would you believe that I can make programs without a data section in C aswell? Don't judge tools if you don't know how to use them. So far all you've managed to prove is that you are absolutely useless when it comes to using C.<br /><br /><div class="quote">Not that any technical consideration actually matters here, our friend think he can win an argument when he is wrong again by weight of his wit and rhetoric.</div><br /><br />Look who's talking. Even putting actual Intel manual quotes in your face doesn't stop you from denying the issue! You are so wrong, there are no words for it.</div>
    <div class="meta">Posted on 2004-02-17 19:43:01 by Henk-Jan</div>
   </div>
   <div class="post" id="post-133969">
    <div class="subject"><a href="#post-133969">C like strings in MASM</a></div>
    <div class="body">I first saw the cTXT macro posted by <strong>huh</strong> and knew it was pure genius.  I will use it with reckless abandon for as long as I use MASM; and FASM has a similar macro, so my recklessness will have no bounds. :)<br /><br />Sometimes I program using mostly code, and then I'll shift to the other extreme of using mostly data.  It is fun to understand the relationship between one and the other.  Data is nothing without code and code requires data - it is a beautiful relationship allowing us to delve deeper into the inner workings of the processor.</div>
    <div class="meta">Posted on 2004-02-17 21:46:07 by bitRAKE</div>
   </div>
   <div class="post" id="post-133971">
    <div class="subject"><a href="#post-133971">C like strings in MASM</a></div>
    <div class="body">Profundities from a person using a C compiler as a crutch don't cut much ice in the assembler programming area.<br /><br />When you support stupidity like blanket statements that data in the code section is BAD, you have failed in technical terms with a multitude of working examples.<br /><pre><code><br />mov eax, &quot;lluB&quot;<br />mov ecx, &quot;t*hs&quot;<br /></code></pre><br />Now for the dummies,<br /><div class="quote"><br />DATA is DATA is DATA is DATA<br /></div><br />Next example,<br /><pre><code><br />mov eax, 1<br /></code></pre><br />Again for the dummies,<br /><div class="quote"><br />DATA is DATA is DATA is DATA<br /></div><br />Another example,<br /><pre><code><br />.code<br />MyString db &quot;DATA is DATA is DATA is DATA&quot;,0<br />start&#58;<br />; your code<br /></code></pre><br />Ain't it a shame that you still don't comprehend the PE specifications or understand how code is read into the code cache.<br /><br />Again for the dummies,<br /><div class="quote"><br />DATA is DATA is DATA is DATA<br /></div><br />Now if you stopped hobbling along with a poor grasp of the C compiler you are using and actually bothered to do some work with the instructions, you would understand the differences.<br /><br />The range of sse2 instructions include non temporal writes and with some instructions that require 16 byte aligned data. You set the data in memory at the correct alignment, use either the hardware prefetch instructions or another technique of software pretouch, the fastest I have seen there is Lingo's code.<br /><br />Do you use these performance related instructions with small zero terminated strings ?<br /><br />Now if you were truly performance oriented, you would allocate memory, align the starting address to a page boundary, write the zero terminated string to it and then try and write some code that would show this AMAZING technical advantage you keep assuming with cache loads.<br /><br />In high level code and that is what API functions are, placing a short string in the same function is fast safe reliable code, even if you don't know it.<br /><br />You may have some need for this neurotic scratching but it does not convince anyone, particularly assembler programmers who already know what cache usage is about and where to use it.<br /><br />Most people who need them have the Intel manuals but the application you are trying to force does not follow from the cache technical data in the manuals, what you are trying to inflict is a private interpretation of technical data in a contaext where you are simply wrong.<br /><br />Now when you succeed in scraping the egg off your face for having made a fool of yourself again, you can try again and get the same result. Why you bother I simply don't know but I guess it must feel good. :tongue: <br /><br />Regards,<br /><br />http://www.asmcommunity.net/board/cryptmail.php?tauntspiders=in.your.face@nomail.for.you&amp;id=2f46ed9f24413347f14439b64bdc03fd</div>
    <div class="meta">Posted on 2004-02-17 22:21:32 by hutch--</div>
   </div>
   <div class="post" id="post-133973">
    <div class="subject"><a href="#post-133973">C like strings in MASM</a></div>
    <div class="body">Yeah, even code is data - data the processor works with to obtain the result - electrons flowing through the hardware at a faster rate in a planned direction.</div>
    <div class="meta">Posted on 2004-02-17 23:30:27 by bitRAKE</div>
   </div>
   <div class="post" id="post-133977">
    <div class="subject"><a href="#post-133977">C like strings in MASM</a></div>
    <div class="body">Hm, there's no reason whatsoever to use the<br /><pre><code><br />jmp @F<br />BtnClass db &quot;BUTTON&quot;,0<br />@@&#58;<br /></code></pre><br />kind of code style. I'd say that cache performance is rather irrelevant in this case (at the same time, though, I see no reason why you wouldn't put the string in .data) - but anyway, if you're going to put your BtnClass string in the code section, why do it like this? It's plain silly, when you can put it before a procedure entry point or after a ret. This is just *waste*, with no excuse whatsoever.<br /><br />I think it's kinda fun that it's *hutch* bringing in C and trying to turn this into some twisted C-vs-asm thing... especially when he obviously has such a poor understanding of C, and how to use the tools around.<br /><br />The crap about immediates in opcodes... like, wtf? You can't call this &quot;data in the code section&quot; since, technically, it's code, and goes in the code cache. Putting non-code data pieces is something different. Do you disagree that this would impair performance a bit? Whether it's relevant for a certain piece of code is another question, but do you disagree it impars performance?<br /><br />Then I wonder why you pull in the PE format specification, it has absolutely nothing to do with any of this. And when coupled with what seems to be a bad understanding of the old segmented memory model, well, it gets even sillier.<br /><br />As for placing code right before the entrypoint - I actually wonder how this will affect things. Parts of MyStringData will obviously be in the same cache line as the code after start - how does this affect the caching? Does this mean the parts of MyStringData in the same cache line as the code will no be put in the data cache? In this example it's <strong>clearly irrelevant performance-wise</strong>, but it would be a good thing to know for other situations.</div>
    <div class="meta">Posted on 2004-02-18 01:01:14 by f0dder</div>
   </div>
   <div class="post" id="post-133981">
    <div class="subject"><a href="#post-133981">C like strings in MASM</a></div>
    <div class="body">Oh, and while I confused SADD with szText, szText *does* do the junky &quot;jmp skipdata&quot; kind of thing, and is used in 70 of the examples in masm32v8 (I only bothered to look at scall.inc and 5 of the asm files, but I think it's a safe assumption it's the same macro used in all).<br /><br />Btw, if you don't mind the extra few bytes of &quot;jmp @f&quot; here and there, and don't think data cache is relevant, you might as well put the following code sequence in the start of your applications as well (apart from it requiring CPL=0, of course).<br /><pre><code><br />mov	eax, cr0<br />or	eax, 060000000h		; CD + NW<br />mov	cr0, eax<br />wbinvd<br /></code></pre></div>
    <div class="meta">Posted on 2004-02-18 01:28:26 by f0dder</div>
   </div>
   <div class="post" id="post-133988">
    <div class="subject"><a href="#post-133988">C like strings in MASM</a></div>
    <div class="body">f0dder,<br /><br />Basically the same answer, string data directly into registers, immediated loaded into registers are all data. This is among the reasons why the blanket statement breaks down as it does not fit either the hardware or the executable file specification.<br /><br />Now I have no doubt you could find places where embedded string data could cause a problem with code caching in terms of cache performance and this is why the technical data is in the Intel manuals but you would really have to go out of your way to write it that way.<br /><br />Write something like an sse2 algo and place a large body of unrelated data directly in the middle of it so that the algo did not fit into cache and you could get disasterous results.<br /><pre><code><br />sse2 algo beginning<br />big block of data far larger than code cache<br />sse2 algo end<br /></code></pre><br />Now if this was an interdependent pair of loops on either side of the big block of data, each cross jump would involved completely reloading the code cache which would deliver a serious reduction in the algorithms performance but then why would you bother to write code this way ?<br /><br />Another instance is blocks of data using the standard DB sequences which can comfortably reside in the code section but never be executed. Even though it IS in the code section, it is in fact data.<br /><br />A table at the front of an algorithm is another perfect example of data in the code section. It is code than cannot be executed that you jump over and it is accessed item by item as data from the code that uses it. Putting the same table in the data section is usually slightly slower because the data is not in the data cache and has to be fetched.<br /><br />Where you are worried about data and code cache fetches is in code that is not even vaguely related to high level code. Very high speed block copy of memory, specialised forms of encryption, the multitude of multimedia style data processing in both video and sound simultaneously and you will undersand the difference.<br /><br />There are two reasons why you use small strings embedded in the code section.<br /><br />1. When you wish to avoid a data section in very small programs.<br /><br />2. When you wish to enclosed a complete working algorithm without committing the exe that may use it to a data section when it is not needed. The perfect example is the string for a control window class.<br /><br />It is code design to put a block of high level code in a seperate procedure so you just need to call it for the functionality and to restrict the size and keep it all in one place, you write the procedure with the control class as embedded data in the code section.<br /><br />There are simply no cache issues that arise here as high level code is powers slower than assembler algorithm code.<br /><br />There is nothing wrong with your preference to always use the data section, even though it may be under 10 bytes but it does commit you to a 512 byte PE section which is often not needed for a read only string.<br /><br />I mentioned the PE specifications for a reason, it does not specify that data cannot be written in the code section because as you should know, both data and code reside in the same flat segment. You have some control by defining the sections as read or write or execute or combinations of the three but if you choose to intermix blocks of code and blocks of data, the PE loader will load and run the file if it gets everything else right.<br /><br />With DOS code, you would remember that a com file specifies that both code and data reside in the same segment as a com file can only be one 64k segment long but with EXE files of different memory models, you actually use different segments like CS for code, DS for data and ES for extra data.<br /><br />It just happens to be that dos MZ and Windows PE files are structured differently yet many seem to forget this difference and try and do things the old way.<br /><br />Regards,<br />http://www.asmcommunity.net/board/cryptmail.php?tauntspiders=in.your.face@nomail.for.you&amp;id=2f46ed9f24413347f14439b64bdc03fd</div>
    <div class="meta">Posted on 2004-02-18 01:56:06 by hutch--</div>
   </div>
   <div class="post" id="post-133992">
    <div class="subject"><a href="#post-133992">C like strings in MASM</a></div>
    <div class="body"><div class="quote"><br />Basically the same answer, string data directly into registers, immediated loaded into registers are all data.<br /></div><br /><br />Now, then tell me, how are you going to pass this &quot;string data directly into registers&quot; to an API function, say, MessageBox?</div>
    <div class="meta">Posted on 2004-02-18 02:59:19 by Morris</div>
   </div>
   <div class="post" id="post-133993">
    <div class="subject"><a href="#post-133993">C like strings in MASM</a></div>
    <div class="body"><div class="quote"><br />Basically the same answer, string data directly into registers, immediated loaded into registers are all data.<br /></div><br />It isn't &quot;string data&quot; though, it's just immediate values. To use it as &quot;a string&quot; (in the sense of passing it to a piece of code that accepts &quot;a string&quot;), you'd have to store it somewhere first. Besides, this is still *code*, and goes entirely in the code cache, without the problems of mixing code/data. <br /><br /><div class="quote"><br />Now I have no doubt you could find places where embedded string data could cause a problem with code caching in terms of cache performance and this is why the technical data is in the Intel manuals but you would really have to go out of your way to write it that way.<br /></div><br />If you mean in the sense of putting a text string in your code section, sure. Quite frankly, I don't see this as much of a performance problem, really... okay, sure, there are the cache issues of doing this, but it won't matter when casually passing a string to some speed-insensitive function. The &quot;jmp @f&quot; way of putting data in code is silly, though - it has no advantages at all, and makes stuff both slower &amp; larger. While the speed and size disadvantages of doing this are very small in non-critical code, there's no reason to write bad code when it brings no advantages - this is quite different from &quot;requiring people to write optimal code&quot;.<br /><br /><div class="quote"><br />Write something like an sse2 algo and place a large body of unrelated data directly in the middle of it so that the algo did not fit into cache and you could get disasterous results.<br /></div><br />As long as you don't execute the data ^_^ and don't reference the data-in-code in the sse2 algo, this should't be too much of a problem. The code and data cache is set-associative, not a linear chunk of memory. Cache lines, etc. Some of the data would end up being placed in code cache because of cache line size though.<br /><br /><div class="quote"><br />Another instance is blocks of data using the standard DB sequences which can comfortably reside in the code section but never be executed. Even though it IS in the code section, it is in fact data.<br /></div><br />Sure, and there isn't too much trouble with this. Just place your data before proc entrypoints or after a ret, and you can put data in code sections without having to jmp around. You can even have data-in-code without performance issues, as long as you don't mix data and code in the same cache line. Of course knowing cache line size beforehand is a bit tricky, so you might have to &quot;align 64&quot; to be safe - might as well put performance-critical stuff in .data (for initialized data, and do align it of course) or on the stack.<br /><br /><div class="quote"><br />A table at the front of an algorithm is another perfect example of data in the code section. It is code than cannot be executed that you jump over and it is accessed item by item as data from the code that uses it. Putting the same table in the data section is usually slightly slower because the data is not in the data cache and has to be fetched.<br /></div><br />Well, if scali is right here - and by the stuff he quoted directly fro m the intel manuals, he just might be - *this* is the kind of thing that you should worry about, not putting your average trivial strings in the code section. From the information scali posted, I got the idea that<br />1) stuff that goes in the code cache doesn't go in the data cache - oops!<br />2) stuff doesn't keep away from the code cache just because you don't execute it, it's about cache lines.<br />Also, remember that code and data caches are split, and that furthermore they're set-associative and not linear. Moder processors do speculative prefetching, and the P4 can even handle multiple &quot;streams&quot; of data... you still get maximum performance by doing your own prefetching, of course.<br /><br /><div class="quote"><br />There is nothing wrong with your preference to always use the data section, even though it may be under 10 bytes but it does commit you to a 512 byte PE section which is often not needed for a read only string.<br /></div><br />512 bytes on disk, 4096 bytes in memory, and some additional PE header space usage; I'm well aware of the implications, and I'm well aware that even for a tiny app, this would all be lost if filesystem cluster size :)<br /><br /><div class="quote"><br />I mentioned the PE specifications for a reason, it does not specify that data cannot be written in the code section because as you should know, both data and code reside in the same flat segment. You have some control by defining the sections as read or write or execute or combinations of the three but if you choose to intermix blocks of code and blocks of data, the PE loader will load and run the file if it gets everything else right.<br /></div><br />Yup, but the PE specifications do have read/write/execute flags, which does indicate the intention of making read-only data read-only (which is a quite sound idea, safety-wise). As for DOS code, nothing stops you from setting CS=DS in a exe file, and using ES to access &quot;farther away segments&quot; - I think at least one memory model did it this way. In small enough programs, you could even have CS!=DS, but the difference between the two segments being small enough that you could access data through  - this has been done more than once to delay crackers.<br /><br />Just to make it perfectly clear, I'm not really opposed to putting data inside your code section, as long as you don't do this for performance-critical stuff. I don't see much use in doing it (as for self-contained pieces of code, you could always have a SEGMENT+ENDS), though. The thing I *really* oppose is using &quot;jmp @f&quot; to do this, as it's silly - considering you can put the data before proc entry points or after a RET.<br /><br />Also, while not very relevant in the context of trivial code, cache *is* very important. Even a multi-ghz x86 would be of very little use if you execute the CR0 flag-changing code I posted in the previous thread. It also does sound like you have a somewhat wrong idea of how the cache works?, but that could just be me.<br /><br />Anyway, you ought to update the 'litereal' macro in masm32 to use SEGMENT+ENDS instead of .data/.code, this way it can be used in other segments, to construct stuff like string tables. It won't change the use of the macro, nor have any side effects - just extend the use of it.</div>
    <div class="meta">Posted on 2004-02-18 03:07:45 by f0dder</div>
   </div>
   <div class="post" id="post-133995">
    <div class="subject"><a href="#post-133995">C like strings in MASM</a></div>
    <div class="body"><div class="quote">Now I have no doubt you could find places where embedded string data could cause a problem with code caching in terms of cache performance and this is why the technical data is in the Intel manuals but you would really have to go out of your way to write it that way.</div><br /><br />From what I remember the only time you can take a performance hit with data in the code segment is after an indirect jump that is <strong>not</strong> cached so there is no problem there and anyone would be hard pressed to find one. In your case Hutch you use a JMP I think so there is no cache hit at all or an insignificant one at best.<br /><br /><div class="quote">Well, if scali is right here - and by the stuff he quoted directly fro m the intel manuals, he just might be - *this* is the kind of thing that you should worry about, not putting your average trivial strings in the code section. From the information scali posted, I got the idea that</div><br /><br />Don't know where he quoted the stuff from, he never says. I am quoting from page 2-47 of the optimization manual, Rule # 27.</div>
    <div class="meta">Posted on 2004-02-18 03:21:18 by donkey</div>
   </div>
   <div class="post" id="post-133997">
    <div class="subject"><a href="#post-133997">C like strings in MASM</a></div>
    <div class="body">The &quot;literal&quot; macro in the macros.inc file is a modification of an original design by &quot;huh&quot; from Blenheim in New Zealand and it is used by the SADD and CTXT macros depending on where they are called from.<br /><pre><code><br />      literal MACRO quoted_text&#58;VARARG<br />        LOCAL local_text<br />        .data<br />          local_text db quoted_text,0<br />        align 4<br />        .code<br />        EXITM &lt;local_text&gt;<br />      ENDM<br /></code></pre><br />It does in fact write directly to the DATA section then aligns the exit so the next item written to the data section is aligned at a 4 byte boundary. Committing flat memory model code to segment assumptions is of little use in 32 bit code where the initialised data section is the right place to write initialised data where you want to both read and write to it.</div>
    <div class="meta">Posted on 2004-02-18 03:36:51 by hutch--</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=17217&amp;page=1" style="">&laquo;</a><a href="../?id=17217&amp;page=4" style="">&lt;</a><input type="hidden" name="id" value="17217" /><input type="number" name="page" min="1" max="7" step="1" value="5" onchange="this.form.submit();" /><a href="../?id=17217&amp;page=6">&gt;</a><a href="../?id=17217&amp;page=7">&raquo;</a></form>  </div>
 </body>
</html>