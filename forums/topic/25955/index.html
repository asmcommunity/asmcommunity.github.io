<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>I didn't use to suck this bad :-P - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25955" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=22">Recruitment</a> &raquo; <a href="../?id=25955">I didn't use to suck this bad :-P</a></p>
   <div class="post" id="post-189176">
    <div class="subject"><a href="#post-189176">I didn't use to suck this bad :-P</a></div>
    <div class="body">So I use to program ASM back a long time ago in the days of DOS and win 3.1 but fell away from that in college when I turned to bio as my major.&nbsp; Now I am way far behind on the new features and macros of ASM.&nbsp; Here is my problem (if anyone can help that would be dandy).&nbsp; I wrote a VB program for fun to implement a One-time pad encryption method.&nbsp; Everything works fine and all but the encryption part is rather slow for large files.&nbsp; I would like to make a .dll in assembler and call the proc from VB to run the actual encryption part but since it has been forever since I wrote assembler I don&#39;t know how to make the .dll so I can call it from VB.&nbsp; Also, time was for reading and writing files you would use Int 21 (ah 3Fh and 40h respectively) to do it but now I see there are macros CreateFile, ReadFile, ect...&nbsp; <br />What I need the Proc to do is basically this<br />1: I call the proc from VB with the following arguements, (Source file path, Key file path, offset of encryption and desired output file name<br />2:open all three (duh) <br />3: I write the value for encryption offset (5 bytes) followed by the 3 letter extension of the source file name to the output file (so I can restore the extension at decryption)<br />4: read the source file from the start and the key file starting at the offset of encryption, XOR the bytes and write them to the output file.<br />Pretty easy, eh?&nbsp; I would think so but my brain has been fried on ASM from years of graduate lvl genetics&nbsp; ;)<br /><br />For decryption it would <br />1: Open source, key and output file<br />2: read source (encrypted) bytes 1-5 for offset of key encryption<br />3: Start reading encrypted bytes at byte 9 (to bypass the extension stored at bytes 6-8 since VB gets that for me prior to decryption anyway)<br />4: Start reading key bytes at offset and XOR again to decrypt.<br /><br />Like I said, I have this working in Vb and it works fine except for the speed issue.&nbsp; Any help would be great.&nbsp; I don&#39;t expect anyone to write the whole thing for me or anything but some guidance would be appreciated.&nbsp; If you want to see what the Finished VB version looks like let me know&nbsp; :D<br /><br /><br /></div>
    <div class="meta">Posted on 2007-05-11 11:51:39 by Command_Prompt</div>
   </div>
   <div class="post" id="post-189183">
    <div class="subject"><a href="#post-189183">Re: I didn't use to suck this bad :-P</a></div>
    <div class="body">OK, so while I was waiting for input I started coding the basic read and XOR section of the code (asm is very slowly coming back to me).&nbsp; I still however have no clue how to pass arguments from vb to the proc, nor how to structure the file to be a dll that accepts arguments from vb in the first place (I never did that when I coded asm years ago.&nbsp; Anyway here is what I have so far.&nbsp; Any input would be great and if anyone knows how to make the dll to pass arguments...ummm...then I would forever be in your debt/send valentine&#39;s e-mails and such:<br /><br />.Data<br /><br />SourceBuffer 	DB 256 Dup (0)<br />KeyBuffer		DB 256 Dup (0)<br />OutBuffer		DB 256 Dup (0)<br />InFileName		DB 512 Dup (0)<br />KeyFileName		DB 512 Dup (0)<br />OutFileName		DB 512 Dup (0)<br /><br />hInFile			DW<br />hKeyFile		DW<br />hOutFile		DW<br />BytesRead		DB<br /><br />CryptFile Proc Public<br />;// Open Source file to be crypted<br />	Mov Ah, 3DH				;Open function<br />	Mov Al, 0				;as Read<br />	Lea Dx, InFileName		;Specify which file to open<br />	Int 21H					;Open<br />	Jc _Error_Occured		;if no error occured then<br />	Mov hInFile, Ax			;store handle<br /><br />;// Open Key file to be used<br />	Mov Ah, 3DH				;Open function<br />	Mov Al, 2				;as Random access (since I need to jump to offset of encryption start)<br />	Lea Dx, InFileName		;Specify which file to open<br />	Int 21H					;Open<br />	Jc _Error_Occured		;if no error occured then<br />	Mov hKeyFile, Ax		;store handle<br /><br />;// Create output file to be written<br />	Mov Ah, 3CH				;Create function<br />	Xor Cx, Cx				;blank out cx (for file attributes)<br />	Lea Dx, InFileName		;Specify which file to open<br />	Int 21H					;Create<br />	Jc _Error_Occured		;if no error occured then<br />	Mov hOutFile, Ax		;store handle<br /><br />;// Move key file&#39;s pointer to the offset required<br />	Mov Ah, 42H				;Seek function<br />	Mov Al, 0				;set as offset is specified from the start of key file<br />	Mov Bx, hKeyFile		;load key file&#39;s handle to bx<br />							;Here Load CX:DX with offset needed in key file<br />	Int 21H<br />	Jc _Error_Occured		;End if error occured (file size vs offset size checked in VB)<br /><br />;// Begin read and encrypt loop<br />_ReadAndXOR:<br />;// Read 512 bytes from Source file<br />	Mov Ah, 3FH				;Read file function<br />	Lea Dx, SourceBuffer	;With 512 byte source buffer as storage location<br />	Mov Cx, 256				;set length to 256<br />	Mov Bx, hInFile			;set input file&#39;s handel to bx<br />	Int 21H					;call int<br />	Jc _Error_Occured		;End if error occured<br />	Cmp Ax, 0				;AX now holds actual bytes read, make sure data was read (in case file was an even multiple of 256)<br />	Je _Finished_Reading_Source_File<br /><br />;// Read from key, same number of btyes<br />;// Read 512 bytes from Source file<br />	Mov Cx, Ax				;move the actual bytes read from AX, to CX<br />	Mov BytesRead, Cx		;Store how many bytes were actually read to memory<br />	Mov Ah, 3FH				;Read file function<br />	Lea Dx, KeyBuffer		;With 512 byte source buffer as storage location<br />	Mov Bx, hKeyFile		;set input file&#39;s handel to bx<br />	Int 21H					;call int<br />	Jc _Error_Occured		;End if error occured<br /><br />;//XOR loop<br />_XORloop:					;CX should still hold actual bytes read from source<br />	Mov Si, 0				;zero out SI<br />	Mov Al, SourceBuffer ;Get first byte from source file to al<br />	Mov Ah, KeyBuffer 	;Get first byte from key file to ah<br />	Xor Ah, Al				;xor and store result in ah<br />	Mov OutBuffer, Ah	;move XOR&#39;d value to output string<br />	Inc Si					;increase SI by 1<br />	Loop _XORloop			;Loop for length of string read<br /><br />;// When all bytes are read<br />	Mov Cx, BytesRead		;Store how many bytes were actually read from memory to CX for writing length to crypted file<br />	Mov Ah, 40H				;Set ah=write function<br />	Mov Bx, hOutFile		;BX = output file&#39;s handle<br />	Lea Dx, OutBuffer		;point dx to location of output string<br />	Int 21H					;and write<br />	Jc _Error_Occured		;<br />	Cmp Ax, 256				;Does # of bytes written=256?<br />	Je _ReadAndXOR			;If not then EOF was reached, so jump to exit.&nbsp; if yes then do another iteration of read and XORing<br /><br /><br />_Finished_Reading_Source_File:<br />_Error_Occured:<br />	Mov Ah, 3EH				;close file function<br />	Mov Bx, hInFile			;BX= source file handle<br />	Int 21H					;close<br /><br />	Mov Ah, 3EH				;close file function<br />	Mov Bx, hKeyFile		;BX= key file handle<br />	Int 21H					;clsoe<br /><br />	Mov Ah, 3EH				;close file function<br />	Mov Bx, hOutFile		;BX= output file handle<br />	Int 21H					;close<br /><br />	Ret<br />CryptFile EndP</div>
    <div class="meta">Posted on 2007-05-11 15:25:21 by Command_Prompt</div>
   </div>
   <div class="post" id="post-189276">
    <div class="subject"><a href="#post-189276">Re: I didn't use to suck this bad :-P</a></div>
    <div class="body"><br />You need to stop thinking in terms of 16 bit code, especially if you want to interface with modern languages like VB.<br /><br />I&#39;m not sure how you go about calling external functions from VB, but I was under the impression that VB only understands COM interfaces, which means you can&#39;t use a &#39;regular&#39; DLL - it has to be a COM Server (your VB program would be the COM Client).<br />There are examples posted for COM stuff, Ernie and Biterider spring to mind.<br /></div>
    <div class="meta">Posted on 2007-05-18 00:46:00 by Homer</div>
   </div>
   <div class="post" id="post-189281">
    <div class="subject"><a href="#post-189281">Re: I didn't use to suck this bad :-P</a></div>
    <div class="body">VB can call STDCALL funcs from any DLL with no sweat, so forget about COM :) . <br />But really, really, learn 32-bit asm, <strong>forget about the &quot;int&quot; instruction</strong>!!! Almost start from scratch. <br /><br /></div>
    <div class="meta">Posted on 2007-05-18 09:58:00 by Ultrano</div>
   </div>
   <div class="post" id="post-189292">
    <div class="subject"><a href="#post-189292">Re: I didn't use to suck this bad :-P</a></div>
    <div class="body">You can use inline assembly in VB6, just a little tricky but works<br /><br />Dim MagicArray() as byte<br />myHex = &quot;AABBCCED0934323424ACEB08&quot; &#39;this is your executable code<br />ReDim MagicArray(0 To Len(myHex)/2)as byte<br />For i=0 To Len(myHex)/2<br />MagicArray(i)=Val(&quot;H&amp;&quot; &amp; Mid(myHex,i*2,2))<br />Next i<br /><br />errval=CallWindowProc(VarPtr(MagicArray(0)),0,0,0,0)<br /><br />P.S: your assembly code must be self-relocateable !!!</div>
    <div class="meta">Posted on 2007-05-19 12:49:09 by Dite</div>
   </div>
   <div class="post" id="post-204464">
    <div class="subject"><a href="#post-204464">Re: I didn't use to suck this bad :-P</a></div>
    <div class="body">Hi guys, and sorry for resurrecting this thread.<br />I just thought the following link would be interesting to anyone interested on the subject...<br /><br /><a target="_blank" href="http://members.optusnet.com.au/~draw3d/assembly.html">Mixing Assembly language with Visual Basic</a></div>
    <div class="meta">Posted on 2008-01-13 04:50:04 by samael</div>
   </div>
   <div class="post" id="post-204474">
    <div class="subject"><a href="#post-204474">Re: I didn't use to suck this bad :-P</a></div>
    <div class="body">Thats an old page, but the information is basically still correct up to VB6.<br /><br />VB6 can leverage any DLL that uses the STDCALL calling convention. <br /><br />The language itself also has a CDECL keyword but it was unofficial and does not work in the debugger at all, and in compiled executables there is still some debate about when and where it actualy does work. It is presumed that it was an intended feature extending more compatability to the older QuickBasic (which did have a working CDECL) but was depreciated before making an official appearance. <br /><br />This isnt much of an issue because STDCALL is generally more efficient than CDECL so there arent many DLL&#039;s still in service which use it. One semi-popular library which is still stuck on the legacy CDECL in its windows implementation is the GMP (GNU Multi-Precision) math library. <br /><br />Some thing to keep in mind which I didnt see referenced on that page and I do not believe is officialy part of the STDCALL convention is that functions which return structures of 64-bits or less are expected to do so in EDX:EAX.<br /><br />VB6 also supports type libraries and it IS recommended that you use a type library with your DLL, beause VB6 defaults to calling GetLastError() after every DLL call unless you use a type library.<br /><br /></div>
    <div class="meta">Posted on 2008-01-13 08:03:30 by Rockoon</div>
   </div>
  </div>
 </body>
</html>