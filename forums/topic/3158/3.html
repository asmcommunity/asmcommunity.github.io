<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Encrytion Method Testing - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=3158" />
  <link rel="prev" href="../?id=3158&amp;page=2" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=3158">Encrytion Method Testing</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=3158&amp;page=1" style="">&laquo;</a><a href="../?id=3158&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="3158" /><input type="number" name="page" min="1" max="3" step="1" value="3" onchange="this.form.submit();" /></form>   <div class="post" id="post-21436">
    <div class="subject"><a href="#post-21436">Encrytion Method Testing</a></div>
    <div class="body"><div class="quote"><br />I don't know what your idea of an &quot;ordinary hacker&quot; of today is, hutch. <br />But the general level has increased quite a bit. True, there's a hell of <br />a lot more clueless wannabes that'll never be able to do anything. But <br />there's a lot more &quot;intermediates&quot;, and there's a lot more free knowledge <br />around these days... CRC check (or even better, hashing) is okay, but <br />unless you do something clever with it, it shouldn't take more than a <br />few minutes to detect &amp; disable.<br /></div><br /><br />So the question is... <br />Now that the &quot;bar&quot; has been raised... what do we do?<br /><br />I think this area is only briefly talked about and often of most use to *any* software programmer (and just because I write only freeware programs -- usually with source included) doesn't mean this information is less valuable to me...<br /><br />The problem is that this thread has more turned into a philosopical arguement of whether &quot;we&quot; as software programmers can use tricks that people with destructive tendicies use?  <br /><br />Much like all good points this thread will fall to the way side and be buried under such thread of &quot;help me convert this C to asm&quot;, &quot;Seriously I need this converted&quot; and &quot;I'm a newbie can you help me convert this C to assembly&quot;... All intresting topics but not useful to the community as a whole...<br /><br />This, I believe, is something that is important... <br /><br />Sliver<br /><br />&quot;Sliver&quot; or &quot;_Sliver_&quot; on mirc<br /><br />ps. If this does go away -- fodder I would appreciate any help you had to offer</div>
    <div class="meta">Posted on 2002-01-27 14:05:48 by Sliver</div>
   </div>
   <div class="post" id="post-21475">
    <div class="subject"><a href="#post-21475">Encrytion Method Testing</a></div>
    <div class="body">f0dder,<br /><br />Most who have written protection systems of one type or another have a pretty good idea of what it takes to break them but it is also well known that the real talent in protection systems have retired so ther majority of what is left over have little chance of breaking a reasonable system.<br /><br />In particular, an EXE file compressed with UPX 0.84 or earlier has no automatic unpacker and just as a matter of fact, the compressor throws away a lot of information needed for the reconstruction back to an unpacked EXE file.<br /><br />A memory dump and a set of fixups will get it to run again but nothing on the planet will recompress it again so it is very easy to write a length checked and CRC checked EXE file based on the compressed length after UPX has compressed it that will notv run if either is incorrect.<br /><br />You appear to have confused the later UPX versions with the old ones that are constructed differently and many of the simpler ones that have automatic unpackers available to access them again.<br /><br />To get a file to run on your own machine is a long way from being able to make a crack for it that will work on the original. You may in fact enjoy the internal structure of an EXE file packed with UPX 0.84, you get the original code to play with but the EXE file still runs from compressed code in another section so there is a lot more to do than just unpack it to reconstruct it back to original.<br /><br />I know of a few guys who could have done the work but they are less than interested in hacking someones programs to get the functionality out of it. I used to follow the old UPX forum and while there were a number of people who postulated the view that if it runs it can be broken but with the format of UPX 0.84 and earlier, no-one ever produced a program that could do it, procdump and all so its a case of when the flag drops, the bullsh*t stops, all I ever heard was bullsh*t. :tongue: <br /><br />The general drift is that something is better than nothing when it comes to protection systems as the general level of talent in the cracking scene is so poor these days that there is little risk of breaking anything stronger than a kiddies version anyway.<br /><br />With an Elmer Fudd accent, &quot;HAY man, I am a quacker, waddavyogottadotocrackthisfile, Quack Quack Quack.&quot;<br /><br />Daffy Duck, &quot;Well dude, you may have to do something like learn to program and how to read assembler.&quot;<br /><br />Elmer, &quot;Assembler, whats that ? I thought all you had to do was set a BPX on SetWindowText, twiddle it a little and you then become a l3et0 h1gH f3llut1n cr4Ck3r. I mean HAY man, I can count in HEX, 1h + 2h + 3h = 6h. R34lLy le3t hUh.&quot;<br /><br />Daffy, &quot;Well dude, it ain't that easy, you have to learn programming, how to read and write assembler, how to trace code in a debugger, understand operating system code, a range of different C runtime libraries, VB pcode construction, how to count on more than 10 fingers and all sorts of other complicated things.&quot;<br /><br />Elmer, &quot;No way, if I had to do all of that I would write the program myself.&quot;<br /><br />Daffy, &quot;Yeah, Right, Muhahahaha.&quot;<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-01-27 18:38:47 by hutch--</div>
   </div>
   <div class="post" id="post-21486">
    <div class="subject"><a href="#post-21486">Encrytion Method Testing</a></div>
    <div class="body"><div class="quote"><br />In particular, an EXE file compressed with UPX 0.84 or earlier has<br />no automatic unpacker and just as a matter of fact, the compressor<br />throws away a lot of information needed for the reconstruction back<br />to an unpacked EXE file. <br /></div><br /><br />Sure, there's no &quot;Upx -d&quot; for 0.84 and earlier. But it's still piece<br />of cake to get a dumped exe that can be both analyzed *and* run.<br />To verify this, I dug out an old backup CD, installed upx 0.84,<br />compressed a test file, and did a manual OEP-trace and dump. The<br />process of tracing and dumping took less than five minutes. I had to<br />set PEHdr.entry manually (big surprise since I did a manual dump),<br />and after that the executable ran just as it was supposed to. Sure,<br />it's not back in original state, and it has some UPX junk left, but<br />thing is, the exe runs fine.<br /><br />And it's not like it's rocket science to unpack a file. Especially<br />not when there's NO tricks whatsoever. And even tricky stuff like<br />asprotect and telock and safedisc/securom gets unpacked...<br /><br /><div class="quote"><br />To get a file to run on your own machine is a long way from being able<br />to make a crack for it that will work on the original.<br />You may in fact enjoy the internal structure of an EXE file packed with<br />UPX 0.84, you get the original code to play with but the EXE file still<br />runs from compressed code in another section so there is a lot more to<br />do than just unpack it to reconstruct it back to original. <br /></div><br />Why would you need to get back the original? As for crack, people just<br />release the dumped/fixed exe. This is being done for asprotect, safedisc,<br />and whatever. No big deal really.<br /><br /><div class="quote"><br />The general drift is that something is better than nothing when it<br />comes to protection systems as the general level of talent in the cracking<br />scene is so poor these days that there is little risk of breaking anything<br />stronger than a kiddies version anyway. <br /></div><br />:rolleyes: . What rock are you sleeping under? :grin: . Yes, there's<br />a lot of talentless n00b's. People with no talent and no desire to learn.<br />A lot of the &quot;old guys&quot; have grown weary and have left the kiddie crackers.<br />Also, people seem to keep the best tools to themselves, because of all<br />the bullshit scene competition stuff. There *are* working generic safedisc2<br />unwrappers around, but the groups keeps them to themselves so they can<br />be the ones to release &lt;whatever new thingamajig&gt; before the rest, and<br />thus get more credits on the 13370 FTPz. Lame? Yes.<br /><br />But I wouldn't say that there's not much talent in the &quot;scene&quot; these days.<br />Dongles are still popped. Wrapping schemes are still unwrapped. DAMN takes<br />care of the strong crypto. Some are in it for the fun, others for the leech<br />site access. Fact is, if you release a shareware app, it *will* get on a<br />groups supply list no matter how lame and pathetic the application is. And<br />almost no matter what you do to the application, it will be cr4xx0red.<br />The only thing you can really do is to make your program worth buying.<br />No &quot;leet old UPX version&quot; will do that for you.</div>
    <div class="meta">Posted on 2002-01-27 20:53:45 by f0dder</div>
   </div>
   <div class="post" id="post-21503">
    <div class="subject"><a href="#post-21503">Every Little Bit Helps</a></div>
    <div class="body"><strong>Kool</strong> <br /><br />Thank for letting us rookies hear how deep this stuff can really be.  You Guys are the best...<br /><br />Can we get a one shot deal here where with-in the next couple of week where the ones who are concern to present only 5 - 7 question each all at one time and wait until you guys find time to reply. Than be done with it...<br /><br />We be happy (<span style="font-size:9px>or sadder</span>) the Board be Happy...I see right now that i am not going to do what you guy did...It would take me 40 years or better...he$5hahA$jj<br /><br />that mean I got to RuN before i get my Mind Blown to quick...Thats deeper than ASM itself...<strong>WHO LET THE DOGS OUT!!!</strong>  (:)<br /><br />See Ya<br /><br />Silver, it's problerly no big dll but i got a lot of gragits that i down loaded a few years back that may be worth the time.  Just junk that could be used for great monkeywhenchs i think along with the heavy stuff that you guys know about....... I'll be here at the Board if instrested...<br /><br /><span style="font-size:9px>PS: It would be nice if the Board had a special secssion one week every other month or so just to keep the members abreast. ....Just a thought</span></div>
    <div class="meta">Posted on 2002-01-28 00:56:47 by cmax</div>
   </div>
   <div class="post" id="post-21524">
    <div class="subject"><a href="#post-21524">Encrytion Method Testing</a></div>
    <div class="body"><div class="quote"><br />BTW Mob, <br />Why can't use use the original offsets since in theory the rest of the code isn't going to be changed... meaning can't you just modify the open process based on the start offset and the end offset of the code you want to encrypt? How hard is it to modify the &quot;inimport&quot; program that you wrote in the masm32 example8 folder? <br /></div><br /><br />hm, you want to have a secure, encrypted, self-extracting<br />method... two ways are in my mind... <br /><br />if you want it to be SFX you'll need something like a host<br />that automaticly generates executables... that means your<br />code + your encrypted data will be relocated<br /><br />1st way: use use the regular pe-frame and just copy the<br />encrypted code into it... you have to use delta-fixed offsets<br />and you can't use api's the normal way, too... you have to get<br />the kernel base and loadup those api's for yourself... (yup<br />this example i gave in hutchs masm pack can be modified very<br />easy i think... i've got nevr and better versions if you want...)<br />even if that sounds pretty hard it's the easier way in my <br />opinion...<br /><br />2nd way: you Have to Use a fixed pe-frame with import table.<br />determine The size of the encrypted data and change the pe<br />header section entries... i'm not sure but if you be carefull with<br />the offsets and api's you have to use, a &quot;standart&quot; way could <br />be possible but That should be very hard to implement...<br /><br /><div class="quote"><br />Anyway, the reason why I'm writing is that from what you wrote it may seem that you know e.g. how to get LoadLibrary's address without importing it in your PE.. is it right? If so, how do you do it? <br /></div><br /><br />you can use api's without importing them, yes... in the normal<br />situation you could use loadlibrary &amp; getprocadr to obtain your<br />goal... for code that will be relocated (v1riis, self-extracting,...)<br />there are other ways to do it...<br /><br />you could scan the current executable's import-sec for the <br />presence of &quot;GetModuleHandle&quot;, this api is imported in almost<br />every executable (maybe 95% i think...), if you have the adr<br />you Can use this api to get the base-adr of every dll you want,<br />say kernel32... now you can scan the export dir of kernel for<br />&quot;GetProcAdress&quot;... if you found This one you can now reach<br />every api you want...<br /><br />but... you could also use this way (the better way i think):<br />EVERY win32 app is loaded by the kernel (CreateProcess)...<br />so if you doubleclick a executable windows will load up this<br />prog with &quot;CreateProcess&quot;... remeber if you CALL something<br />the current InstructionPointer will be pushed to the stack so<br />that the called function can retrurn properly (ret)... our goal<br />is to get the kernel-base... so just grab the first stack-entry<br />and you're inside the windows kernel... now you just scan<br />backwards until you find some of the known pe-marks (MZ,<br />PE/0/0)... there are a couple of checks to do but thats not<br />to hard... now you have the REAL kernel-base... you can <br />scan the pe-structures  (export-dir) to get the api's you want...<br />i wrote a routine for this purpose... you just generate some<br />thing like a structure with the api's you want... later this<br />structure is filled with working pointers so you can use those<br />api's from now on...</div>
    <div class="meta">Posted on 2002-01-28 03:24:18 by mob</div>
   </div>
   <div class="post" id="post-21555">
    <div class="subject"><a href="#post-21555">Encrytion Method Testing</a></div>
    <div class="body">mob, there's no guarantee that kernel32 CALLs your app.<br />It does on all current win32 versions, but nobody can tell<br />if it will remain doing so. As for GetModuleHandle, it will<br />probably only work for DLLs you are importing from (and DLLs<br />your imported DLLs import from.)<br /><br />And remember that if you do manual importing, you must handle<br />NT-style redirected exports (which also means something you<br />think is in kernel32 is really in ntdll.dll, which means you<br />might even end up getting ntdll.dll base instead of kernel32.dll.)<br /><br />The safest approach is probably to make (at least) one import<br />from each DLL you want. Then you can use GetModuleHandle to get<br />the DLL base (it's tempting to base-scan yourself, but if your<br />import has been redirected it will not work). Once you have the<br />base, it *should* be safe doing a manual GetProcAddress.</div>
    <div class="meta">Posted on 2002-01-28 07:15:25 by f0dder</div>
   </div>
   <div class="post" id="post-21559">
    <div class="subject"><a href="#post-21559">Encrytion Method Testing</a></div>
    <div class="body">f0dder, i know that... but till now these techniques ARE win32<br />compatible... thats all i want... if microsoft changes this... bad<br />luck. btw i don't think they will... but even if they do... new<br />methods will developed. GMH?<br /><br />scan for GetModuleHandle in the IMPORT dir of some executable<br />use this api to get the KERNEL32 base<br />scan KERNEL32 for GetProcAdress and maybe LoadLibrary<br />use those API'S to get other Dll's and Function's<br />stupid but it will work, WITHOUT GETTING KERNEL STACK ENTRY<br />result? <strong>FULL w32 compatiblity, even in future win versions...</strong><br />oh and for &quot;<em>it will probably only work for DLLs you are importing<br />from (and DLLs your imported DLLs import from.)</em>&quot; --- LoadLibrary<br /><br />btw to sliver, cmax and all the other people that want to gain<br />knowledge about topics that differ from &quot;standart&quot; win32 coding:<br />yup, many v1riis use similar techniques but that doesn't have to<br />mean that this kind of stuff is evil, it can be widely used for very<br />usefull puposes like protection, security, whatever... there's no<br />doubt about it. i recommend reading tutes about the pe-format<br />at first... it's quite interesting and you'll learn what happens with<br />your code after it has been mapped... then you'll understand why<br />you can not just paste code or have to fix offsets or have to<br />struggle with the kernel to retrieve api-usage... stupidly you'll find<br />the most interesting stuff on v1rus-related sites but that should<br />not prevent you... i started learning this thing coz i was bored...<br />windows coding can be VERY boring sometimes... it's EVERYTIME<br />the same, CommonControl, DialogHandler, ToolHelp, bla bla bla...<br />everytime? ok, as i said, *sometimes* :)</div>
    <div class="meta">Posted on 2002-01-28 07:21:28 by mob</div>
   </div>
   <div class="post" id="post-21602">
    <div class="subject"><a href="#post-21602">Encrytion Method Testing</a></div>
    <div class="body">f0dder,<br /><br />If you are taking 5 minutes to unpack an EXE compressed with UPX 0.84, you are losing it but if you think that this is a reconstruction, you are abusing it. Getting it to run is kiddie level stuff, trying to modify it is another matter, if you bothered to look, it retains both the compressed and unpacked data and it still runs from the uncompressed data.<br /><br />I have a particular program in mind here which I wrote before I had a HDD failure 2 years ago which I got to run in about 2 minutes. (Had to find the toys I wrote on my HDD :) ) Memory dumped it and did the fixups for the difference between disk and memory image offsets and voila, it runs. Problem is it still runs off the compressed data so simply patching it in a HEX editor is not going to help you here.<br /><br />What the file needs is a full reconstruction just to get rid of the extra data and this will not reconstruct it, it will just make the file modifiable. Now I am sure that you are familiar with how simple length checking and CRC checking is in an EXE file, there are of course other ways to test if a file has been modified and this means just 1 byte difference, not a simplistic unpacking of an EXE file that has very large differences from the packed version so detection of change is kiddies stuff to do.<br /><br />Now doing something this simple is enough to break most l3et0 w4nN4b3e cR4cK3rZ and it does not involve anything smart yet. The most common approach is to spread the tests across a complete application over a range of different categories so that the w0uLd b3 l3et0 has to do a lot of hard low level dirty work to even try and find what the checks are and there is no 5 minute effort that will do this.<br /><br />As you would be aware, an EXE file is a big bag of binary with a multitude of critical numbers in it and it is trivial to fiddle any number of its bits to stop it from working. The most successful methods of preventing a file from being easily hacked use multiple techniques that are aimed at increasing the dirty work needed to be done by a massive amount and there is still nothing smart done here yet.<br /><br />When the workload to break a protection system exceeds the time to write it, the protection system is working. I suggest that the days of easy cracks are over and this is enough to beat most attacks.<br /><br />The next trick is to vary the system each release so the few who are smart enough to beat a tidy system have to do it all again. There comes a point where its not worth bothering and this is more or less how modern protection systems work.<br /><br />It is easy to say that any file can be broken but what is not being said is the time frame to do it, having a crack ready for the release of Win3k is probably too late to bother the original program's owner.<br /><br />What my advice to authors is in protection schemes is to start somewhere and this means start doing the simplest things first, compression is one of them that increases the workload on the freeloader while being easy to do. Depending on the requirement, there are many more things that can be done and being original just make the task harder for the attacker.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-01-28 12:33:51 by hutch--</div>
   </div>
   <div class="post" id="post-21608">
    <div class="subject"><a href="#post-21608">Encrytion Method Testing</a></div>
    <div class="body">Mob,<br /><div class="quote"><br />scan for GetModuleHandle in the IMPORT dir of some executable <br />use this api to get the KERNEL32 base <br />scan KERNEL32 for GetProcAdress and maybe LoadLibrary <br />use those API'S to get other Dll's and Function's <br /></div><br />Who says GetModuleHandle will not be forwarded to, say, ntdll.dll<br />in some windows release? If you want to be 100% compatible, you<br />have to at least do LoadLibrary.<br /><br />-----------------<br /><br />Well, I'm sorry hutch, but my 5 minute dump (yes yes, I'm losing it)<br />includes making it run from the uncompressed data and fixing up the<br />imports to proper values instead of machine-dependant values.<br />I don't know if you're familiar with asprotect, it's anti-debugging<br />tricks, fake APIs, chunk encryption (etc). But &quot;even&quot; asprotect is<br />broken routinely... and no, we're not talking about weeks or days<br />of work.<br /><br /><div class="quote"><br />so detection of change is kiddies stuff to do. <br /></div><br />And kiddies stuff to remove. Ok, admitted, if you pepper them ALL<br />over the place, they can turn out to be annoying, especially if you're<br />smart enough to delay the checks, and delay the shutdown of the app<br />as well.<br /><br /><div class="quote"><br />As you would be aware, an EXE file is a big bag of binary with a multitude<br />of critical numbers in it and it is trivial to fiddle any number of its bits<br />to stop it from working.<br /></div><br />And trivial enough to change something so that it suddenly only works<br />on some windows versions. If you go fiddling with PE header values<br />runtime, you'd better know exactly what you're doing. Lots of people<br />who do this don't.<br /><br /><div class="quote"><br />When the workload to break a protection system exceeds the time to write<br />it, the protection system is working. I suggest that the days of easy cracks<br />are over and this is enough to beat most attacks.<br /></div><br />True. But most stuff today (because it relies on ready-made protection)<br />does *not* take very long time to break. IDA is one of the few apps that<br />have not been totally broken yet, and that's because their user group is<br />small enough that the main executable can be compiler per-user. It seems<br />like they got rid of all the watermarking and keychecks though...</div>
    <div class="meta">Posted on 2002-01-28 13:07:07 by f0dder</div>
   </div>
   <div class="post" id="post-21609">
    <div class="subject"><a href="#post-21609">Encrytion Method Testing</a></div>
    <div class="body"><strong>Hutch--</strong>, these things should be built into the tools, IMO.  Programatic convolution of code at non-time critical sections would be a nice feature to program into an assembler.  Whoever tries to modify the program would have to write a special disassembler to handle the convolutions - not your average guy messing with your code.  Even writing macros in IDA would take some talent to counter such methods.</div>
    <div class="meta">Posted on 2002-01-28 13:07:35 by bitRAKE</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=3158&amp;page=1" style="">&laquo;</a><a href="../?id=3158&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="3158" /><input type="number" name="page" min="1" max="3" step="1" value="3" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>