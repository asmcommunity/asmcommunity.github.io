<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>str_compare.asm &amp; str_len.asm of AsmLib - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29811" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29811">str_compare.asm &amp; str_len.asm of AsmLib</a></p>
   <div class="post" id="post-210653">
    <div class="subject"><a href="#post-210653">str_compare.asm &amp; str_len.asm of AsmLib</a></div>
    <div class="body">I have been going through the AsmTools code and I came across a few things that didn&#039;t make sense in these two files.<br /><br />First, is push ecx and pop ecx necessary in str_compare? I&#039;ve tested it, and I don&#039;t see a need for it.<br /><pre><code><br />&nbsp; &nbsp;  global str_compare<br />str_compare:<br />&nbsp; &nbsp;  push ecx<br />sc_lp:<br />&nbsp; &nbsp;  cmp byte , 0<br />&nbsp; &nbsp;  je sc_done1<br />&nbsp; &nbsp;  cmpsb<br />&nbsp; &nbsp;  je sc_lp<br />&nbsp; &nbsp;  jmp short sc_exit<br />sc_done1:<br />&nbsp; &nbsp;  cmp byte , 0<br />sc_exit:<br />&nbsp; &nbsp;  pop ecx<br />&nbsp; &nbsp;  ret<br /></code></pre><br /><br />And str_len with comments of what I had changed it to.<br /><pre><code><br />&nbsp; &nbsp;  global str_len&nbsp; &nbsp;  ;&nbsp; &nbsp;  global _strlen<br />str_len:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp;  strlen:<br />&nbsp; &nbsp;  push eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;&nbsp; &nbsp;  push eax<br />&nbsp; &nbsp;  push esi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;<br />&nbsp; &nbsp;  mov ecx, esi&nbsp; &nbsp; &nbsp;  ;&nbsp; &nbsp;  mov ecx, esi<br />str_lp:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;&nbsp; &nbsp;  strlen_l:<br />&nbsp; &nbsp;  lodsb&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp;  lodsb<br />&nbsp; &nbsp;  or al, al&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp;  or al, al<br />&nbsp; &nbsp;  jnz str_lp&nbsp; &nbsp; &nbsp; &nbsp;  ;&nbsp; &nbsp;  jnz _strlen_l<br />&nbsp; &nbsp;  dec esi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp;  sub esi, 1<br />&nbsp; &nbsp;  sub esi, ecx&nbsp; &nbsp; &nbsp;  ;&nbsp; &nbsp;  sub esi, ecx<br />&nbsp; &nbsp;  pop ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />&nbsp; &nbsp;  xchg esi, ecx&nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp;  xchg esi, ecx<br />&nbsp; &nbsp;  pop eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp;  pop eax<br />&nbsp; &nbsp;  ret&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp;  ret<br /></code></pre><br />I had tested this, too and it seemed to work.<br /><br />Anyway, I&#039;m just curious to know if there is/was some reason for the extra code?</div>
    <div class="meta">Posted on 2010-02-07 01:21:00 by Mol_Bolom</div>
   </div>
   <div class="post" id="post-210664">
    <div class="subject"><a href="#post-210664">Re: str_compare.asm &amp; str_len.asm of AsmLib</a></div>
    <div class="body">Your improvements to Jeff&#039;s code look sound to me (untested!). In the str_cmp, the push/pop of ecx is probably a &quot;leftover&quot; from an earlier version that used &quot;rep cmpsb&quot;(?).<br /><br />Jeff&#039;s str_len is kinda weird, in that it returns the length in ecx and preserves eax. (what was he thinking?). Your improvements there look sound, too. We&#039;ve &quot;preserved&quot; esi in ecx, so no need to push/pop it.<br /><br />In Linux, we often want the length in edx. With a standard &quot;C-style&quot; strlen, we need to mov edx, eax. With Jeff&#039;s str_len, we need to mov edx, ecx... and probably mov ecx, esi, too.<br /><br />S&#039;pose we had an &quot;astrlen&quot;, which would optionally allow a &quot;destination&quot; (must be a register) where the length is returned. If only one parameter is given, the length is in eax.<br /><br />astrlen mystring ; like C&#039;s strlen()<br /><br />mov esi, mystr<br />astrlen ecx, esi ; like Jeff&#039;s str_len<br /><br />mov ecx, mystring<br />astrlen edx, ecx&nbsp; ; length in edx - ready for a sys_write<br /><br />Being a macro, not a subroutine, this pastes the &quot;whole thing&quot; in, every time you use it. But if you look closely, there isn&#039;t a heck of a lot of code involved in the actual &quot;business&quot; of finding the length<br /><br />I&#039;m not much of a macro user, much less a macro writer, but here&#039;s my shot at it.<br /><br /><pre><code><br />%imacro astrlen 0-*<br /><br />; single operand - eax is implied dest<br />&nbsp; &nbsp; %if %0 = 1<br />	%ifidni %1, eax<br />	&nbsp; &nbsp; %error &quot;single operand form - eax is implied destination!!!&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; %endif	&nbsp; &nbsp; <br /><br />	or eax, byte -1<br />	%%getlen:<br />	cmp [%1 + eax + 1], byte 1<br />	inc eax<br />	jnc %%getlen<br /><br />; two operand form<br />&nbsp; &nbsp; %elif %0 = 2<br />	%ifidni %1, %2<br />	&nbsp; &nbsp; %error &quot;src and dest must not be the same!!!&quot;<br />	%endif<br /><br />; fake an &quot;%ifnreg&quot;<br /><br />	%assign %%isreg 0<br /><br />	%ifidni %1, eax<br />	&nbsp; &nbsp; %assign %%isreg 1<br />	%elifidni %1, ebx<br />	&nbsp; &nbsp; %assign %%isreg 1<br />	%elifidni %1, ecx<br />	&nbsp; &nbsp; %assign %%isreg 1<br />	%elifidni %1, edx<br />	&nbsp; &nbsp; %assign %%isreg 1<br />	%elifidni %1, esi<br />	&nbsp; &nbsp; %assign %%isreg 1<br />	%elifidni %1, edi<br />	&nbsp; &nbsp; %assign %%isreg 1<br />	%elifidni %1, ebp<br />	&nbsp; &nbsp; %assign %%isreg 1<br />	%endif<br /><br />	%if %%isreg = 0<br />	&nbsp; &nbsp; %error &quot;destination must be a GP register!!!&quot;<br />	%endif<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; <br />	or %1, byte -1<br />	%%getlen2:<br />	cmp [%1 + %2 + 1], byte 1<br />	inc %1<br />	jnc %%getlen2<br />&nbsp; &nbsp; %else<br />	%error &quot;usage: strlen src (reg/label) or strlen dest (reg) src (reg/label).&quot;<br />&nbsp; &nbsp; %endif<br />%endm<br /><br /></code></pre><br /><br />I&#039;m sure this can be improved, but I don&#039;t think you&#039;ll find any extraneous pushes in it. Of course, zero-terminated strings are a dumb data structure anyway. Generally, we know the length - either it&#039;s static, in which case Nasm can count it for us, or we read it from someplace, in which case we know what we read. If you&#039;re doing strlen a lot, retink your code.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-02-07 16:06:18 by fbkotler</div>
   </div>
   <div class="post" id="post-210685">
    <div class="subject"><a href="#post-210685">Re: str_compare.asm &amp; str_len.asm of AsmLib</a></div>
    <div class="body"><div class="quote"><br />Jeff&#039;s str_len is kinda weird, in that it returns the length in ecx and preserves eax. (what was he thinking?). Your improvements there look sound, too. We&#039;ve &quot;preserved&quot; esi in ecx, so no need to push/pop it.<br /><br />In Linux, we often want the length in edx. With a standard &quot;C-style&quot; strlen, we need to mov edx, eax. With Jeff&#039;s str_len, we need to mov edx, ecx... and probably mov ecx, esi, too.<br /><br />S&#039;pose we had an &quot;astrlen&quot;, which would optionally allow a &quot;destination&quot; (must be a register) where the length is returned. If only one parameter is given, the length is in eax.<br /><br />astrlen mystring ; like C&#039;s strlen()<br /><br />mov esi, mystr<br />astrlen ecx, esi ; like Jeff&#039;s str_len<br /><br />mov ecx, mystring<br />astrlen edx, ecx &nbsp;; length in edx - ready for a sys_write<br /><br /></div><br /><br />That&#039;s one thing I&#039;ve been working on, I&#039;ve yet to standardize which register to use for what. &nbsp;ecx seemed the best bet for any kind of count because of the loopcc instructions, however, now that you&#039;ve mentioned it, would be more prudent to use edx for string lengths.<br /><br />So far I&#039;ve organized the registers this way.<br />EAX: Return value of a call<br />ECX: Loop, count, etc<br />ESI: &nbsp;Main string, or the &#039;source&#039; string.<br />EDI: &nbsp;Secondary, or the &#039;destination&#039; string.<br />Stack: I&#039;ve only started using it more often lately. &nbsp;I try not to use it if I can, though.<br /><br />And I&#039;ll start using EDX for string lengths. &nbsp;That will simplify a few things.<br /><br />Well, I&#039;m still a beginner, so maybe I&#039;ll learn a better way. &nbsp;I&#039;ve been reading through several sites on the internet, Intel manuals, as well as trying to read through the pcasm book again, still got a ways to go.<br /><br /><div class="quote"><br />Being a macro, not a subroutine, this pastes the &quot;whole thing&quot; in, every time you use it. But if you look closely, there isn&#039;t a heck of a lot of code involved in the actual &quot;business&quot; of finding the length<br /><br />I&#039;m not much of a macro user, much less a macro writer, but here&#039;s my shot at it.<br /><br /><pre><code><br />%imacro astrlen 0-*<br /><br />; single operand - eax is implied dest<br />&nbsp; &nbsp; %if %0 = 1<br />	%ifidni %1, eax<br />	&nbsp; &nbsp; %error &quot;single operand form - eax is implied destination!!!&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; %endif	&nbsp; &nbsp; <br /><br />	or eax, byte -1<br />	%%getlen:<br />	cmp [%1 + eax + 1], byte 1<br />	inc eax<br />	jnc %%getlen<br /><br />; two operand form<br />&nbsp; &nbsp; %elif %0 = 2<br />	%ifidni %1, %2<br />	&nbsp; &nbsp; %error &quot;src and dest must not be the same!!!&quot;<br />	%endif<br /><br />; fake an &quot;%ifnreg&quot;<br /><br />	%assign %%isreg 0<br /><br />	%ifidni %1, eax<br />	&nbsp; &nbsp; %assign %%isreg 1<br />	%elifidni %1, ebx<br />	&nbsp; &nbsp; %assign %%isreg 1<br />	%elifidni %1, ecx<br />	&nbsp; &nbsp; %assign %%isreg 1<br />	%elifidni %1, edx<br />	&nbsp; &nbsp; %assign %%isreg 1<br />	%elifidni %1, esi<br />	&nbsp; &nbsp; %assign %%isreg 1<br />	%elifidni %1, edi<br />	&nbsp; &nbsp; %assign %%isreg 1<br />	%elifidni %1, ebp<br />	&nbsp; &nbsp; %assign %%isreg 1<br />	%endif<br /><br />	%if %%isreg = 0<br />	&nbsp; &nbsp; %error &quot;destination must be a GP register!!!&quot;<br />	%endif<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; <br />	or %1, byte -1<br />	%%getlen2:<br />	cmp [%1 + %2 + 1], byte 1<br />	inc %1<br />	jnc %%getlen2<br />&nbsp; &nbsp; %else<br />	%error &quot;usage: strlen src (reg/label) or strlen dest (reg) src (reg/label).&quot;<br />&nbsp; &nbsp; %endif<br />%endm<br /><br /></code></pre><br /><br />I&#039;m sure this can be improved, but I don&#039;t think you&#039;ll find any extraneous pushes in it. Of course, zero-terminated strings are a dumb data structure anyway. Generally, we know the length - either it&#039;s static, in which case Nasm can count it for us, or we read it from someplace, in which case we know what we read. If you&#039;re doing strlen a lot, retink your code.<br /><br />Best,<br />Frank<br /><br /><br /></div><br /><br />Someday soon I&#039;ll have to sit down and read through the Nasm manual and learn how to read and write macros. &nbsp;I&#039;ve done it once before, and just put it off until after I memorize the instructions a little better. &nbsp;One thing that really bugs me about macros, since I&#039;m learning, and if I use a macro, while debugging a program I&#039;ll come across some code and not have a clue why, what, or how it got there &nbsp;:shock:. &nbsp;So I try to stay away from them for the time being. <br /><br /><div class="quote"><br />zero-terminated strings are a <strong>dumb</strong> data structure anyway. Generally, we know the length - either it&#039;s static, in which case Nasm can count it for us, or we read it from someplace, in which case we know what we read. If you&#039;re doing strlen a lot, retink your code.<br /></div><br /><br />While trying different methods to figure strings out, I&#039;ve found that to be too true. Unfortunately I don&#039;t know an easier way to get the string lengths of command line arguments, too bad there isn&#039;t a empty string passed, then I could just use a pop and get all the string lengths from pop&#039;ing the next arguments addr and subtracting it from the preceding arguments addr.<br /><br />Hmm, just happen to think that the computer, OS, or whatever should know at least the length of the command line arguments. &nbsp;It has the program directory and name, plus the arguments in memory, so there should be a way to find those out, and from that I could retrieve the arguments and their lengths easier. Perhaps that&#039;s what you meant by static, I am not sure (The hardest part to learn is the terminology)...<br /><br />Well, thanks for the info. &nbsp;Gives me something to work on.</div>
    <div class="meta">Posted on 2010-02-08 20:06:36 by Mol_Bolom</div>
   </div>
   <div class="post" id="post-210715">
    <div class="subject"><a href="#post-210715">Re: str_compare.asm &amp; str_len.asm of AsmLib</a></div>
    <div class="body">Well I&#039;m not sure &quot;static&quot; is the correct terminology. Maybe I should have said &quot;initialized&quot;. I just meant that we can do:<br /><br />msg db &quot;Hi There!&quot;<br />msg_len equ $ - msg<br /><br />But command line arguments and environment variables come to us as zero-terminated strings - Linux being written in C, and all. I don&#039;t know if you can get the length by subtracting one address from another or not. It would work if the strings are located contiguously in memory... which they may be, but I don&#039;t know if we can count on it.<br /><br />If you can spot those unneccessary instructions in Jeff&#039;s code, I&#039;d say you were off to a good start!<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-02-09 21:02:06 by fbkotler</div>
   </div>
   <div class="post" id="post-210718">
    <div class="subject"><a href="#post-210718">Re: str_compare.asm &amp; str_len.asm of AsmLib</a></div>
    <div class="body">After I had written my last post I had searched static up, and you were right.<br /><br />I&#039;ve found myself using Jeff&#039;s style a little more often...<br />msg: db &#039;Howdy!&#039;<br />end_msg:<br /><br />mov edx, end_msg - msg<br /><br />It&#039;s not perfect, but it does seem useful, say I want to create an array.<br /><br /><pre><code><br />help:&nbsp; db&nbsp; &#039;This is program what not&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#039;, 10<br />help_01:&nbsp; db&nbsp; &#039;&nbsp; &nbsp;  -h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  print help&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &#039;, 10<br />help_last:db&nbsp; &#039;&nbsp; &nbsp;  -v&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  print version&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &#039;, 10<br />end_help:<br /></code></pre><br /><br />That way I wouldn&#039;t have to remember too much.&nbsp; Thus for a write...<br /><pre><code><br />mov ecx, help<br />mov edx, end_help - help<br /><br />; Or for only a single line...<br />mov ecx, help * linenumber<br />mov edx, end_help - help_last<br /></code></pre><br /><br /><div class="quote"><br />I don&#039;t know if you can get the length by subtracting one address from another or not. It would work if the strings are located contiguously in memory... which they may be, but <strong>I don&#039;t know if we can count on it.</strong><br /></div><br />That&#039;s the million dollar question, can it be counted on?<br /><br />So far everything I&#039;ve tested it does work, however if there is a chance that it wont be like that always, then the code will not work.<br /><br />Such that when I wrote this code an hour ago, it would be useless if the arguments weren&#039;t stored contiguously.<br /><br /><pre><code><br />_get_arg:<br />	pop ebp		; Since only testing, don&#039;t need to worry about this.<br />	pop esi		; Get arg...<br />	cmp ecx, 1<br />	jz _get_arglen	; If ecx = 1 then we have to get the arg length by scanning the string.<br /><br />	mov edx, 	; Get next arg...<br />	sub edx, esi	; Get arg length+NULL.<br />	dec edx		; Now string length...<br />	jmp _end_get_arg<br />_get_arglen:<br />	mov edx, esi<br />_get_arglen_l:<br />	lodsb		; Get byte from esi<br />	or al, al<br />	jnz _get_arglen_l<br />	xchg edx, esi<br />	sub edx, esi<br />	dec edx<br />_end_get_arg:<br />	push ebp<br />	ret<br /></code></pre><br /><br />More to think about.<br /><br />Thanks</div>
    <div class="meta">Posted on 2010-02-09 21:53:57 by Mol_Bolom</div>
   </div>
   <div class="post" id="post-210722">
    <div class="subject"><a href="#post-210722">Re: str_compare.asm &amp; str_len.asm of AsmLib</a></div>
    <div class="body">I&#039;m a little confused by your code. Where does the value in ecx come from? Passed in as a parameter? Your use of ebp is... unusual. Why not &quot;mov esi, &quot;, and leave the return address on the stack? Or maybe I don&#039;t understand how this is intended to be used.<br /><br />In any case, keep thinkin&#039; and keep codin&#039; - you can&#039;t go wrong!<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-02-10 01:25:53 by fbkotler</div>
   </div>
   <div class="post" id="post-210726">
    <div class="subject"><a href="#post-210726">Re: str_compare.asm &amp; str_len.asm of AsmLib</a></div>
    <div class="body">Whoops. Well, I don&#039;t get to talk with others about this kind of thing, so I often forget to explain things.<br /><br />Anyway, ecx was used with LOOP and stored the argument count, argc in c. For the most part, ebp &amp;ecx weren&#039;t important in this example, it was the rest of the code that was, just showing that as long as the arguments are contiguous in memory then that&#039;s one way that they could be retrieved, possibly faster than parsing each string.<br /><br /><div class="quote"><br />Your use of ebp is... unusual. Why not &quot;mov esi, &quot;, and <strong>leave the return address on the stack</strong>?<br /></div><br /><br />I thought I had read that it is a good idea to remove everything from the stack, so nothing existed after program execution. So I didn&#039;t think it would be a good idea to leave the arguments on the stack, and so one of my thoughts was to use something such as this to pop each arg off the stack for testing.&nbsp; I guess that leaves me with another question, is it ok for the stack to remain after a program exits?<br /></div>
    <div class="meta">Posted on 2010-02-10 10:27:36 by Mol_Bolom</div>
   </div>
   <div class="post" id="post-210727">
    <div class="subject"><a href="#post-210727">Re: str_compare.asm &amp; str_len.asm of AsmLib</a></div>
    <div class="body"><div class="quote">Mol_Bolom</strong>&quot;]…is it ok for the stack to remain after a program exits?</div><br /><br />Whole program or function? Modern OS releases resources of terminated program (including stack). As for function, it&#039;s the matter of calling conventions.<br /><br />For example, <strong>cdecl</strong> function leaves it&#039;s parameters on stack, <strong>stdcall</strong> function discards them (using <strong>ret #</strong> instruction, usually).</div>
    <div class="meta">Posted on 2010-02-10 11:57:49 by baldr</div>
   </div>
   <div class="post" id="post-210782">
    <div class="subject"><a href="#post-210782">Re: str_compare.asm &amp; str_len.asm of AsmLib</a></div>
    <div class="body">When your program exits, your stack, along with all your other memory, just vanishes - poof! The magic of virtual memory.<br /><br />A program that begins at the &quot;_start:&quot; label has no return address on the stack, so we don&#039;t have to worry about that. We couldn&#039;t &quot;ret&quot; if we wanted to! A &quot;call&quot; instruction puts a return address on the stack, and the &quot;ret&quot; instruction expects to find it there, so the stack is critical in a called function. &quot;main&quot; is called. (and a Windows entrypoint is called, AFAIK) We can exit our program with &quot;ret&quot;, in this case - and the stack has to be correct. If we exit with sys_exit, or with exit(), the stack can be trash.<br /><br />A more &quot;usual&quot; subroutine would look like:<br /><br /><pre><code><br />somefunction:<br /> push ebp ; save caller&#039;s ebp, they&#039;re probably using it<br /> mov ebp, esp<br /> ; body of our function<br /> mov esp, ebp<br /> pop ebp<br /> ret<br /></code></pre><br /><br />Sometimes the &quot;enter&quot; and &quot;leave&quot; instructions are used instead of explicit code like this - look &#039;em up. Now, in the body of our function, we can abuse esp any way we want, and it&#039;ll be restored to a sane state from ebp. Typically, &quot;sub esp, ?&quot; is used to reserve space for local variables, for example. It means we can&#039;t trash ebp, of course!<br /><br />Your code, where I said your usage of ebp was &quot;unusual&quot;, pops the return address into ebp, and pushes it back before the &quot;ret&quot;. You indicate that&#039;s &quot;not important&quot; - but it is! That allows you to pop the next arg from the &quot;original&quot; stack. Works, but it isn&#039;t the &quot;usual&quot; way, and confused me at first.<br /><br />Here&#039;s an example I happened to have on hand, that shows a different approach. This scans through environment variables instead of command line arguments, but it&#039;s the same idea...<br /><br /><pre><code><br />; nasm -f elf myfile.asm<br />; ld -o myfile myfile.o<br /><br />; finds the USER environment variable, and says hi,<br />; using sys_writev - write several buffers at a time.<br /><br />global _start<br /><br />section .text<br />_start:<br />&nbsp; &nbsp; nop<br />commence:<br />&nbsp; &nbsp; mov eax,  ; &quot;argc&quot;<br /><br />; &quot;lea eax, [8 + esp + eax * 4]&quot; is start of environment variables<br />; 4 bytes for each arg in argc, plus argc itself, plus the terminating 0<br />; since we&#039;re going to be adding 4, calculate 4 short of that.<br />&nbsp; &nbsp; lea eax, [4 + esp + eax * 4]<br /><br />; fancy search algorithm :)<br />finduser:<br />&nbsp; &nbsp; add eax, byte 4<br />&nbsp; &nbsp; mov ecx, <br />&nbsp; &nbsp; test ecx, ecx ; this just sets flags so we can...<br />&nbsp; &nbsp; jz end_of_env ; terminating zero at end of env array - not found<br />&nbsp; &nbsp; cmp dword , &#039;USER&#039;<br />&nbsp; &nbsp; jne finduser<br />&nbsp; &nbsp; cmp byte , &#039;=&#039;<br />&nbsp; &nbsp; jne finduser<br /><br />; got it, advance to &quot;value&quot;<br />&nbsp; &nbsp; add ecx, byte 5<br /><br />; find the length<br />&nbsp; &nbsp; or edx, byte -1<br />getlen:<br />&nbsp; &nbsp; inc edx<br />&nbsp; &nbsp; cmp byte , 0<br />&nbsp; &nbsp; jne getlen<br /><br />&nbsp; &nbsp; mov , ecx<br />&nbsp; &nbsp; mov , edx<br />&nbsp; &nbsp; jmp short write_it<br /><br />end_of_env:<br />&nbsp; &nbsp; mov , dword whodat<br />&nbsp; &nbsp; mov , dword whodat_len<br /><br />write_it:<br />&nbsp; &nbsp; mov eax, 146	; __NR_writev<br />&nbsp; &nbsp; mov ebx, 1		; stdout<br />&nbsp; &nbsp; mov ecx, my_vector	; ptr, len, ptr, len...<br />&nbsp; &nbsp; mov edx, 3		; three items to write<br />&nbsp; &nbsp; int 80h<br /><br />exit:<br />&nbsp; &nbsp; mov eax, 1		; __NR_exit<br />&nbsp; &nbsp; int 80h<br /><br />;-----------------------------------<br />section .data<br /><br />&nbsp; &nbsp; greet db &quot;Hello, &quot;<br />&nbsp; &nbsp; greet_len equ $ - greet<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; coda db &quot;! Welcome to Linux Assembly!&quot;, 10<br />&nbsp; &nbsp; coda_len equ $ - coda<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; whodat db &quot;Unknown User&quot;<br />&nbsp; &nbsp; whodat_len equ $ - whodat<br />&nbsp; &nbsp; <br />; sys_writev takes a &quot;vector&quot;, ptr, len, ptr, len... N times.<br />&nbsp; &nbsp; my_vector:<br />	dd greet<br />	dd greet_len<br />username:<br />&nbsp; &nbsp; &nbsp; &nbsp; dd 0		; fill in at runtime<br />name_len:<br />&nbsp; &nbsp; &nbsp; &nbsp; dd 0		; fill in at runtime<br />&nbsp; &nbsp; &nbsp; &nbsp; dd coda<br />&nbsp; &nbsp; &nbsp; &nbsp; dd coda_len<br /><br />;------------------------------<br /></code></pre><br /><br />I guess that doesn&#039;t really address your question about the stack, since I pretty much leave it alone. I&#039;m not really comfortable with popping argc, etc. off the stack. What if I&#039;ve forgotten something, and want to go back and look again? :) If I were to &quot;mov , esp&quot; first thing (which I don&#039;t do in this example), I&#039;d be able to find args and env from anywhere - even in deeply nested subroutines. Dunno, just a different approach...<br /><br />If you were to keep popping, past all the args and environment variables, when you finally got to 0xC0000000, you&#039;d segfault, I think. Try it...<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-02-15 06:18:19 by fbkotler</div>
   </div>
   <div class="post" id="post-210783">
    <div class="subject"><a href="#post-210783">Re: str_compare.asm &amp; str_len.asm of AsmLib</a></div>
    <div class="body"><div class="quote">A program that begins at the &quot;_start:&quot; label has no return address on the stack, so we don&#039;t have to worry about that. We couldn&#039;t &quot;ret&quot; if we wanted to!</div><br /><br />Actually, that depends on the OS.<br />Obviously the &#039;_start:&#039;-label isn&#039;t the beginning of all code. This code is called by the executable loader of the OS. In many cases (eg DOS/Windows), this loader stores a valid return address on the stack, so a ret will indeed exit your program cleanly. But yes, you have to be cautious with such an approach.</div>
    <div class="meta">Posted on 2010-02-15 06:34:34 by Scali</div>
   </div>
   <div class="post" id="post-210785">
    <div class="subject"><a href="#post-210785">Re: str_compare.asm &amp; str_len.asm of AsmLib</a></div>
    <div class="body">Right. I should have said, &quot;a Linux program that starts with the label _start:&quot; (or non-default entrypoint supplied to ld). In this specific case, it&#039;s &quot;jmp&quot;ed to, not &quot;call&quot;ed. Good catch.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-02-15 07:15:09 by fbkotler</div>
   </div>
   <div class="post" id="post-210793">
    <div class="subject"><a href="#post-210793">Re: str_compare.asm &amp; str_len.asm of AsmLib</a></div>
    <div class="body">Thanks a lot fbkotler. &nbsp;Running that little example I was finally able to <strong>finally</strong> understand LEA. &nbsp;I&#039;ve been reading on that for quite some time, but couldn&#039;t grasp it. &nbsp;Though I still need to tinker around with it to figure out how your example compiled and mine didn&#039;t, wasn&#039;t too different, I think, unfortunately I don&#039;t remember where I put that test program...<br /><br />Anyway...<br /><br /><div class="quote"><br />When your program exits, your stack, along with all your other memory, just vanishes - poof! The magic of virtual memory.<br /></div><br />Strange how it took me so long to figure that out...Eh, at least I know now...<br /><br /><div class="quote"><br /><pre><code><br />somefunction:<br /> push ebp ; save caller&#039;s ebp, they&#039;re probably using it<br /> mov ebp, esp<br /> ; body of our function<br /> mov esp, ebp<br /> pop ebp<br /> ret<br /></code></pre><br /><br />Sometimes the &quot;enter&quot; and &quot;leave&quot; instructions are used instead of explicit code like this - look &#039;em up. Now, in the body of our function, we can abuse esp any way we want, and it&#039;ll be restored to a sane state from ebp. Typically, &quot;sub esp, ?&quot; is used to reserve space for local variables, for example. It means we can&#039;t trash ebp, of course!<br /></div><br />Yeah, I learned that early on when I first read about macros. &nbsp;The only macros that I bother using, actually, are contending with local and passed variables and entering and exiting a call.<br /><br /><div class="quote"><br />Your code, where I said your usage of ebp was &quot;unusual&quot;, pops the return address into ebp, and pushes it back before the &quot;ret&quot;. You indicate that&#039;s &quot;not important&quot; - but it is! That allows you to pop the next arg from the &quot;original&quot; stack. Works, but it isn&#039;t the &quot;usual&quot; way, and confused me at first.<br /></div><br />Well, that&#039;s my fault, I should have mentioned that it was merely an example and those two registers didn&#039;t matter in <strong>that</strong> particular example. At least I know what your talking about... ;)<br /><br /><div class="quote"><br />I guess that doesn&#039;t really address your question about the stack, since I pretty much leave it alone. I&#039;m not really comfortable with popping argc, etc. off the stack. What if I&#039;ve forgotten something, and want to go back and look again? :) If I were to &quot;mov , esp&quot; first thing (which I don&#039;t do in this example), I&#039;d be able to find args and env from anywhere - even in deeply nested subroutines. Dunno, just a different approach...<br /><br />If you were to keep popping, past all the args and environment variables, when you finally got to 0xC0000000, you&#039;d segfault, I think. Try it...<br /></div><br /><br />The last paragraph, is exactly what was causing me the confusion. &nbsp;I didn&#039;t have time to try any test programs for finding different ways to traverse the stack without actually pop&#039;ing the stack, been rather busy, but I had thought about it.<br /><br />The part that was the hardest to figure out was argc. So far, with what little time I&#039;ve had to think on it, this is what I have so far come up with.<br /><ul>Pop argc, need to have another register to compare it to.</ul><br /><ul>Leave argc on the stack, and read the arguments backwards. &nbsp;Thus multiplying it by four, and subtracting it by four after every loop then using it to add to the stack to read the arguments. Therefore would not need any registers for the counter, but argc would be lost.</ul><br /><ul>Push a variable onto the stack, one that would be used for the counter. &nbsp;Thus would have something to test with argc. Would only need one more 4.</ul><br /><br />Though, after reading through your example and all, I realized I maybe just plain nuts. &nbsp;:D . Anyway, I should have this Wednesday to examine your code more closely and think about it and how I might go about it more clearly then.<br /><br />Thanks.<br /><br />Charles<br /></div>
    <div class="meta">Posted on 2010-02-16 00:07:06 by Mol_Bolom</div>
   </div>
   <div class="post" id="post-210849">
    <div class="subject"><a href="#post-210849">Re: str_compare.asm &amp; str_len.asm of AsmLib</a></div>
    <div class="body">Ok I finally got it, so it seems. Though now I know I really need to study up on the debuggers I use (Oh what fun was that debugging this code... :shock: )...<br /><br />Anyway, this is what I got so far...<br /><br /><pre><code><br />_getarg:<br />	lea ecx, <br />	mov ecx, <br />	call _strlen<br />	ret<br /><br />_getenv:<br />	or edx, edx<br />	jz _getenv_len<br />	lea ecx, <br />	mov ecx, <br />	call _strlen<br />	jmp _end_getenv	<br /><br />_getenv_len:<br />	inc edx<br />	add ecx, byte 4<br />	mov eax, <br />	test eax, eax <br />	jnz _getenv_len<br />_end_getenv:<br />	ret<br /><br />_strlen:<br />	cmp byte , 0<br />	je _end_strlen<br />	xor edx, edx<br />_strlen_l:<br />	inc edx<br />	cmp byte , 0<br />	jne _strlen_l<br />_end_strlen:<br />	ret<br /></code></pre><br /><br />I still want to work on the _genenv part, but eh, reality bytes sometimes.<br /><br />So far I modified the code so I&#039;d only need to remember two registers, ecx and edx.&nbsp; Which now I try to use edx for array indexing, strings only. Of course this may change, but eh, I remember it and that&#039;s the important thing.<br /><br />So this is the main program code that I&#039;ve tested it with, it&#039;s not pretty, but it was just a spur of the moment kind of thing only needed to test the calls.<br /><br /><pre><code><br />segment .data<br />argc:		dd	0<br />argv:		dd	0<br />env_begin:	dd	0<br />env_count:	dd	0<br />newline:	db	10<br /><br />segment .text<br />	global _start<br />_start:<br />	mov eax, <br />	mov , eax&nbsp; &nbsp; &nbsp; ; Save argc<br />	mov ebx, esp<br />	add ebx, 4<br />	mov , ebx&nbsp; &nbsp; &nbsp; ; Save stack address of arguments.<br /><br />	lea ecx, [4+esp+eax*4]	; Should be the beginning of the environ<br />	mov , ecx&nbsp; &nbsp; &nbsp; &nbsp;  ; Save stack address of environ<br />	xor edx, edx<br />	call _getenv<br />	mov , edx&nbsp; &nbsp; &nbsp;  ; Save # of environ variables.<br />	mov edx, 1<br />	push edx<br />_envloop:<br />	mov ecx, <br />	call _getenv<br />	call _printout<br />	call _printnewline<br />	inc dword <br />	mov edx, <br />	cmp edx, <br />	jnz _envloop	<br />	mov , dword 1<br />	mov edx, 1<br />_argloop:<br />	mov ecx, <br />	call _getarg<br />	call _printout<br />	call _printnewline<br />	inc dword <br />	mov edx, <br />	cmp edx, <br />	jnz _argloop<br />	pop edx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Clear the pop, though I know now I don&#039;t need to do so.<br />_exit:<br />	mov eax, 1<br />	mov ebx, 0<br />	int 80h<br /><br />_printnewline:<br />	mov ecx, newline<br />	mov edx, 1<br />_printout:<br />	mov eax, 4<br />	mov ebx, 1<br />	int 80h<br />	ret<br /></code></pre><br /><br />And lastly, I&#039;ve created two others, but haven&#039;t tested them yet.&nbsp; These two calls were something I created that could be utilized in other programs as well.<br />What these &quot;should&quot; do is, _lcodestr &quot;something=else&quot; should be ecx=&quot;something&quot; and edx = strlen(&quot;something&quot;), and _rcodestr should be ecx = &quot;else&quot; and edx = strlen(&quot;else&quot;).<br /><br /><pre><code><br />_lcodestr:<br />	inc edx<br />	cmp byte , &#039;=&#039;<br />	jnz _lcodestr<br />	ret<br /><br />_rcodestr:<br />	inc ecx<br />	cmp byte , &#039;=&#039;<br />	jnz _rcodestr<br />	inc ecx<br />	call _strlen<br />	ret<br /></code></pre><br /><br />Anyway, it&#039;s not pretty, but for only having a few minutes a day to work on it for the past several days, it&#039;s not too bad, IMO...<br /><br />Again, thanks for everyone&#039;s help.</div>
    <div class="meta">Posted on 2010-02-19 13:04:46 by Mol_Bolom</div>
   </div>
   <div class="post" id="post-210860">
    <div class="subject"><a href="#post-210860">Re: str_compare.asm &amp; str_len.asm of AsmLib</a></div>
    <div class="body"><strong>Mol_Bolom</strong>,<br /><br /><strong>lea ecx, </strong> / <strong>mov ecx, </strong> is somewhat artificial way to write <strong>mov ecx, </strong>.<br /><br /><strong>test edx, edx</strong> is better way to test.<br /><br /><strong>_getenv(0)</strong> assumes that environment is not empty.<br /><br /><strong>_strlen</strong> explicitly checks for zero-length string, yet returns undefined value in <strong>edx</strong>.<br /><br /><strong>_lcodestr</strong> again assumes that <strong>edx</strong> will be zero upon call.<br /><br />Both <strong>_lcodestr</strong> and <strong>_rcodestr</strong> don&#039;t check for terminating <strong>NUL</strong>.</div>
    <div class="meta">Posted on 2010-02-21 12:06:50 by baldr</div>
   </div>
  </div>
 </body>
</html>