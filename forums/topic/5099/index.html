<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>64 bit prime numbers - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=5099" />
    <link rel="next" href="../?id=5099&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=5099">64 bit prime numbers</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=5099&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=5099&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="5099" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=5099&amp;page=2">&gt;</a><a href="../?id=5099&amp;page=2">&raquo;</a></form>   <div class="post" id="post-35858">
    <div class="subject"><a href="#post-35858">64 bit prime numbers</a></div>
    <div class="body">I would like the algo experts to see if this code can be improved.<br />It was just an exercise on 64 bit math, that i have tried to optimize as much as possible.<br />Nothing very usefull, but i think many people don't manage 64 bit integer math, and it could be helpfull.<br /><br />Have fun<br /><br /><pre><code><br /><br />;======================================================================<br />;  File&#58; pr.asm<br />;  Desc&#58; Prints prime numbers starting from input number &#40;64 bit&#41;.<br />;  Auth&#58; Towers<br />;  Date&#58; 04/30/2002<br />;<br />;  Usage&#58; pr 12345678   &#40; any number, greater than 12 &#41;<br />;<br />;-----------------------------------------------------------------------<br />; Notes&#58;<br />;       Win32 Assembly console project. <br />;       To compile and link with masm32, use&#58;<br />;<br />;      c&#58;\masm32\bin\ml /c /coff pr.asm<br />;      c&#58;\masm32\bin\LINK -subsystem&#58;console -entry&#58;_start pr.obj<br />;<br />;=================================================<br /><br />;-----------------------------------------------------------------------<br />; DIRECTIVES<br />;-----------------------------------------------------------------------<br /><br />.586<br />.MODEL flat, stdcall<br />option casemap&#58;none<br /><br />;-----------------------------------------------------------------------<br />; INCLUDES<br />;-----------------------------------------------------------------------<br />.nolist<br />include \masm32\include\Windows.inc<br />include \masm32\include\masm32.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\user32.inc<br /><br />includelib \masm32\lib\user32.lib<br />includelib \masm32\lib\masm32.lib<br />includelib \masm32\lib\kernel32.lib<br />.list<br /><br />.DATA<br /><br />only_num BYTE  &quot;Only digits from 0 to 9&quot;,13,10,0<br />msg_12   BYTE  &quot;Input must be grater than 12&quot;,13,10,0<br />msg      BYTE  &quot;Prime numbers starting at&#58; &quot;<br />cmdline  BYTE  &quot;                        &quot;,13,10,0<br />msg4     BYTE  &quot;.....................&quot;, 13, 10,0 <br />numlo    DWORD 0<br />numhi    DWORD 0<br />numten   DWORD 10<br />root     DWORD 0<br />itera    DWORD 20<br /><br />.CODE<br /><br />_start    PROC<br /><br />          INVOKE GetCommandLineA<br /><br />@@&#58;       mov dl,&#91;eax&#93;           ; eax= pointer to command line<br />          cmp dl,&quot; &quot;         <br />          je espacio             ; search for space to start reading<br />          inc eax                ; the number entered <br />          jmp @B<br /><br />espacio&#58;<br />;------------------------------------          <br />; copy from command line into buffer<br />;------------------------------------          <br />          <br />          lea edi,&#91;cmdline&#93;       ; buffer to place the ASCII number<br />          <br />          inc eax                 ; start reading after space<br />          sub ecx,ecx<br />@@&#58;       mov dl,&#91;eax+ecx&#93;        ; move from  command line ....<br />          cmp dl,0h<br />          je finstr<br />          mov &#91;edi+ecx&#93;,dl        ; ... into buffer, until 0 found<br />          inc ecx                 ; ECX has number of ascii digits <br />          jmp @B                  ; found in the buffer<br /><br />;---------------------------------------------          <br />; get numbers from buffer, checking range 0&#58;9 <br />; and then transform to 64 bit binary<br />; starts with # of digits in ECX<br />;----------------------------------------------          <br />finstr&#58;<br />          lea esi,&#91;cmdline&#93;       <br />          sub ebx,ebx<br />@@&#58;       mov bl,&#91;esi&#93;<br />          cmp bl,39h<br />          ja msg_num<br />          cmp bl,30h<br />          jb msg_num             ; if out of range display msg<br />          and bl,0fh<br /><br />          mov eax,numlo          ; this is a 64 bit multiply<br />          mul numten             ; by ten<br />          mov numlo,eax          ; first multiply lower 32 bits<br />          push edx               ; save upper 32 bits from mul<br />          mov eax,numhi<br />          mul numten             ; multiply hi 32 bits<br />          mov numhi,eax<br />          pop edx<br />          add numhi,edx          ; add the upper bits from 1st mul<br /><br />          add numlo,ebx          ; add in the next digit <br />          adc numhi,0            ; from the buffer<br />          inc esi                ; <br />          loop @B                ; loops until all digits processed<br /><br />;----------------------------------------------------          <br />; check if resulting 64 bit number is greater than 12<br />;----------------------------------------------------          <br />          mov eax,numhi<br />          cmp eax,0<br />          jnz calc_prime      ; numhi must not be zero<br />          mov eax,numlo<br />          cmp eax,13          ; and numlo must be greater than 12<br />          jb msg12            ; print msg saying &quot;must be greater than 12&quot;<br /><br />;----------------------------------------------------          <br />; start calculating if number is prime<br />; if number is even &#40;last bit =0 &#41; decrement<br />; because i want to start with an odd number<br />; &#40;even numbers are never prime!&#41;<br />;----------------------------------------------------          <br /><br />calc_prime&#58; invoke StdOut,addr msg  <br />           finit<br /><br />          mov eax,numlo<br />          and eax,1      ; check last bit to see if number is even<br />          cmp eax,1<br />          je primero     ; if odd start calculating <br /><br />          sub numlo,1    ; if even decrement <br />          sbb numhi,0<br /><br />;------------------------------------<br />; to calculate primes i will divide by different numbers<br />; only upto SQRT&#40;number&#41;<br />; if no factors found upto SQRT, no factors will be found.<br />; to check if ODD number is prime, divide by<br />; 3,5, then  7,11, 13,17, 19,23  pattern +2 +4 +2+ 4+ 2+4....<br />; if no factors found   --&gt; print prime<br />;------------------------------------<br /><br />; Calcula root del numero <br />otrop&#58;<br />          add numlo,2<br />          adc numhi,0<br /><br />primero&#58;  fild  QWORD PTR numlo<br />          fsqrt<br />          fistp root              ; found SQRT&#40;number&#41;<br /><br /><br />          sub edx,edx        ; 64 bit divide by 3<br />          mov ebx,3<br />          mov eax,numhi<br />          div ebx<br />          mov eax,numlo<br />          div ebx<br />          cmp edx,0<br />          je otrop         ; edx = 0 means no remainder, factor found<br />                           ; so not prime, try with next odd number<br />                           ; adding to present number<br /><br />          sub edx,edx       ; 64 bit divide by 5<br />          mov ebx,5<br />          mov eax,numhi<br />          div ebx<br />          mov eax,numlo<br />          div ebx<br />          cmp edx,0<br />          je otrop         ; edx = 0 means no remainder, factor found<br />          <br />          mov ebx,5<br />masdos&#58;<br />          sub edx,edx<br />          add ebx,2         ; start the +2 +4 +2 +4 sequence<br />          mov eax,numhi     ; looking for factors<br />          div ebx<br />          mov eax,numlo<br />          div ebx<br />          cmp edx,0<br />          je otrop         <br /><br />          sub edx,edx<br />          add ebx,4          ; +4<br />          mov eax,numhi<br />          div ebx<br />          mov eax,numlo<br />          div ebx<br />          cmp edx,0<br />          je otrop         <br />          cmp ebx,root       ; keep looking for factors upto ROOT<br />          jb masdos          ; +2  ......<br /><br />;---------------------------------------------------<br />; no factors found  - let's print the PRIME number <br />;---------------------------------------------------<br />          mov ebx,numlo  <br />          mov ecx,numhi<br /><br />          lea edi,&#91;msg4+20&#93;  ; we have to print backwards<br />          mov esi,10         ; decoding the 64 bit binary to ASCII<br />@@&#58;<br />          sub edx,edx<br />          mov eax,ecx<br />          div esi              ; divide numhi by 10<br />          mov ecx,eax<br /><br />          mov eax,ebx<br />          div esi              ; then num lo by 10 using<br />          mov ebx,eax          ; first remainder in edx<br />          add dl,30h           ; new remainder plus 30h is the digit<br />          mov &#91;edi&#93;,dl         ; move into output print buffer<br />          dec edi              ; decrement position in buffer<br />          cmp eax,0<br />          jne @B               ; keep looping until no digits left <br /><br />          INVOKE  StdOut,addr msg4    ; print the prime<br />          dec itera                   ; decrement number of primes<br />          jz fin                      ; until 20 have been found<br /><br />          jmp otrop             ; try to find another<br />      <br />;---------------------------------------------<br /><br />msg_num&#58;<br />          invoke StdOut,addr only_num  <br />          jmp fin<br /><br />msg12&#58;<br />          invoke StdOut,addr msg_12<br />          jmp fin<br /><br />fin&#58;      INVOKE  ExitProcess,<br />          0                        ; Result code for parent process<br /><br />_start    ENDP<br /><br />PUBLIC _start<br /><br />END<br /><br /></code></pre></div>
    <div class="meta">Posted on 2002-04-30 18:10:09 by towers</div>
   </div>
   <div class="post" id="post-35869">
    <div class="subject"><a href="#post-35869">Some optimizations</a></div>
    <div class="body">One optimization can be to change your <em>sub ecx,ecx</em> by <strong>xor ecx,ecx</strong>. The same with your <em>sub ebx,ebx</em><br /><br />I think you can also change cases like <em><br />          mov eax,numhi<br />          cmp eax,0<br />          jnz calc_prime</em>d<br /><br />by      <strong><br /><br />         mov eax,numhi<br />         dec  eax<br />         js     calc_prime</strong><br /><br />I think cases such as this:<br />          cmp eax,1<br />          je primero     <br />can be changed by:<br />         <strong>  <br />         dec  eax<br />         jz     primero<br />....<br />....<br />primero: <br />         inc eax   ;If you really need to keep old EAX value<br />         </strong>            <br /><br />I also saw a:<br />                   sub numlo,1<br />that can be changed by:<br />                  dec word ptr <br /><br />OK. This is what I saw at the moment. Just correct me if I have mistakes.<br /><br />Bueno, mucha suerte con el ejercicio.  :grin:<br /><br />Saludos.</div>
    <div class="meta">Posted on 2002-04-30 19:51:58 by CodeLover</div>
   </div>
   <div class="post" id="post-35875">
    <div class="subject"><a href="#post-35875">64 bit prime numbers</a></div>
    <div class="body"><div class="quote"><br />One optimization can be to change your sub ecx,ecx by xor ecx,ecx. The same with your sub ebx,ebx <br /></div><br />And why this is better ?<br />:)<br /><br /><div class="quote">cmp edx,0</div> <br />use<br /> test edx,edx<br />speed the same but shorter. as option<br /> or edx,edx<br />also set ZF if edx = 0</div>
    <div class="meta">Posted on 2002-04-30 20:23:47 by The Svin</div>
   </div>
   <div class="post" id="post-35877">
    <div class="subject"><a href="#post-35877">64 bit prime numbers</a></div>
    <div class="body">Sorry, xor reg,reg is not better than sub reg,reg<br />:stupid:</div>
    <div class="meta">Posted on 2002-04-30 20:51:55 by CodeLover</div>
   </div>
   <div class="post" id="post-35971">
    <div class="subject"><a href="#post-35971">64 bit prime numbers</a></div>
    <div class="body">I guess there are not many comments.:( <br />I can change a sub for a dec, or a cmp for a test, but that doesn't improve inner loop or the algorithm.<br /><br />I was asking if maybe there is a better way to do the 64 math, such as the divides in the inner loop than are called millions of times for big primes.<br /><br />Any ideas ?</div>
    <div class="meta">Posted on 2002-05-01 15:22:04 by towers</div>
   </div>
   <div class="post" id="post-35973">
    <div class="subject"><a href="#post-35973">64 bit prime numbers</a></div>
    <div class="body">I understand you and promisse to have a close look later.<br />Can you send a copy of sourse as asm file or archive,<br />I faild to copy it from screen.</div>
    <div class="meta">Posted on 2002-05-01 15:38:43 by The Svin</div>
   </div>
   <div class="post" id="post-35998">
    <div class="subject"><a href="#post-35998">64 bit prime numbers</a></div>
    <div class="body">Many, many years ago I was &quot;challenged&quot; to beat some routines that calculated n prime numbers as quickly as possible. At that time I didn't have a girlfriend so I *had* free time ;) thus I accepted.<br /><br />The CPU was a 65xx.<br /><br />I mumbled mumbled a bit and found what to me seemed the fastest solution or, at least, was hundreds times faster than the other proposed ones, at least in the given conditions of the challenge, so I've been happy with this and didn't try to improve it.<br /><br />In short how it worked is: I create/use an array of &quot;flags&quot;, where a flag can mean &quot;prime number&quot; or &quot;not prime number&quot;. Each flag is 1 bit wide. So if bit 2 of this big array of bits is clear, then it means that the number 2 is a prime number. If bit 18 is set, then it means than number 18 is not a prime number. I start with the whole array initialized as &quot;prime number&quot;, as if they all were prime numbers.<br /><br />Then I scan 8 (64 today with MMX) bits at a time, and (to simplify the concept) OR each even bit. That will make &quot;non prime number&quot; every multiple of 2. I then go back and do this every 3 bits.. using a mask like this:<br /><br />00100100 10010010 01001001<br /><br />i.e. every multiple of 3 will be marked as &quot;non prime number&quot;.<br /><br /><strong>&lt;edit&gt;</strong><em>It's implicitly clear (but I better write it explicitly maybe) that then we continue this process with 5, etc..<br />In substance we skipped 4 because we found it (thanks to the previous computations) to be already a &quot;non prime number&quot;, and thus there was no need to check for its multiples.. being them certainly &quot;non prime numbers&quot; as well. That's why the went directly to 5.. and so on</em><strong>&lt;/edit&gt;</strong><br /><br />It's fast.. it's just OR instructions, for the most.<br /><br />Today CPU's have caches, so you better work on a block at a time, where the block isn't bigger than a certain size.<br /><br />Moreover, in my implementation I made things even 2 times as fast, by exploiting the fact that all even numbers aren't prime anyway.. and there are further clever optimizations possible. It was lotsa years ago.. I wish I could find the 65xx source of it somewhere, I've got a box full of papers in the cellar.<br /><br />I hope that helps.</div>
    <div class="meta">Posted on 2002-05-01 18:03:08 by Maverick</div>
   </div>
   <div class="post" id="post-36007">
    <div class="subject"><a href="#post-36007">64 bit prime numbers</a></div>
    <div class="body"><strong>Maverick</strong>, I've done the same algo on 680x0, x86, but not MMX.<br /><strong>Hutch</strong>, has a version on his web page - not by me.</div>
    <div class="meta">Posted on 2002-05-01 19:28:17 by bitRAKE</div>
   </div>
   <div class="post" id="post-36058">
    <div class="subject"><a href="#post-36058">64 bit prime numbers</a></div>
    <div class="body">Well, I didn't know.. to me (at that time) it seemed the more straightforward and &quot;low level&quot;, thus best solution.</div>
    <div class="meta">Posted on 2002-05-02 04:11:30 by Maverick</div>
   </div>
   <div class="post" id="post-36080">
    <div class="subject"><a href="#post-36080">64 bit prime numbers</a></div>
    <div class="body">We learn similarly - that is very cool.</div>
    <div class="meta">Posted on 2002-05-02 07:14:45 by bitRAKE</div>
   </div>
   <div class="post" id="post-36101">
    <div class="subject"><a href="#post-36101">64 bit prime numbers</a></div>
    <div class="body">Thanks The Svin.<br />Glad to hear that you can still communicate with the world.<br /><br />Here is the asm code  as attachment.<br /><br /><br />I know that this is kind of &quot;brute force&quot; calculation of prime, <br />and that there are more elegant ways of doing it.<br />I'll try another method next time.<br /><br />As i said this was more of an experiment to see if all my 64 bit math was working OK, I had a few problems with it, but now it seems to be working perfect.<br /><br />Primes upto 15 digits are very fast, with 20 digits it takes some seconds to find each prime (i'm working with a PIII 750).</div>
    <div class="meta">Posted on 2002-05-02 08:45:31 by towers</div>
   </div>
   <div class="post" id="post-36157">
    <div class="subject"><a href="#post-36157">64 bit prime numbers</a></div>
    <div class="body">Maverick<br /><br />The biggest number i can handle with my algorithm is aprox 9.22E18 (9220000000000000000).<br /><br />First prime found using this number as input is <br />9220000000000000039<br /><br />If i want to create a bit array and start to check off primes how would i start to manage this. I would need 1E18 bytes or 1000000000 gigabytes!!!<br /><br />There must be another (simple) way for checking big primes.</div>
    <div class="meta">Posted on 2002-05-02 13:59:20 by towers</div>
   </div>
   <div class="post" id="post-36204">
    <div class="subject"><a href="#post-36204">64 bit prime numbers</a></div>
    <div class="body"><div class="quote"><br />We learn similarly - that is very cool. </div>It happened more times and, yup, it's someway an indication that things can't be made faster. ;)<br /><br />BTW: I looked at Hutch site but couldn't find the x86 routine. Do you have a direct link please?</div>
    <div class="meta">Posted on 2002-05-02 16:57:58 by Maverick</div>
   </div>
   <div class="post" id="post-36207">
    <div class="subject"><a href="#post-36207">64 bit prime numbers</a></div>
    <div class="body"><div class="quote"><br />BTW: I looked at Hutch site but couldn't find the x86 routine. Do you have a direct link please?</div><a target="_blank" href="http://www.movsd.com/source.htm">http://www.movsd.com/source.htm</a><br />(Third from the bottom, called primes.zip)<br /><br />I did a rewrite some time back, with a great speed increase over this one, but have since lost that HD - it is still sitting here in the hopes of reading it one day. :(<br /><br /><strong>towers</strong>, how serious are you about primes?<br /><a target="_blank" href="http://www.mersenne.org/source.htm">http://www.mersenne.org/source.htm</a><br />...large chunk of the source is ASM - what else could it be. :)<br /><a target="_blank" href="http://www.mersenne.org/math.htm">http://www.mersenne.org/math.htm</a><br />...this page is a good read.</div>
    <div class="meta">Posted on 2002-05-02 17:07:18 by bitRAKE</div>
   </div>
   <div class="post" id="post-36210">
    <div class="subject"><a href="#post-36210">64 bit prime numbers</a></div>
    <div class="body"><div class="quote"><br />Maverick<br /><br />The biggest number i can handle with my algorithm is aprox 9.22E18 (9220000000000000000).<br /><br />First prime found using this number as input is <br />9220000000000000039<br /><br />If i want to create a bit array and start to check off primes how would i start to manage this. I would need 1E18 bytes or 1000000000 gigabytes!!!<br /><br />There must be another (simple) way for checking big primes. </div>Maybe you could check some book on number theory on your local library.. or use those wonderful internet search engines. ;)</div>
    <div class="meta">Posted on 2002-05-02 17:17:53 by Maverick</div>
   </div>
   <div class="post" id="post-36212">
    <div class="subject"><a href="#post-36212">64 bit prime numbers</a></div>
    <div class="body"><div class="quote"><br /><a target="_blank" href="http://www.movsd.com/source.htm">http://www.movsd.com/source.htm</a><br />(Third from the bottom, called primes.zip)</div>Thank you. :)<br /><strong><div class="quote">I did a rewrite some time back, with a great speed increase over this one, but have since lost that HD - it is still sitting here in the hopes of reading it one day. :(</div>Hard disk crashes are one of the worst things that can happen.. I've solved my problem (i.e. &quot;I can't live making backups every day&quot;) by having two PC's, one at my house and one at my gf's house, which are &quot;cloned&quot;.. so I just update this or that depending where I worked that half day, and if one dies I've a full working copy in the other house. :)<br />Now, a earthquake that destroys both computers.. hmm. :tongue:</div>
    <div class="meta">Posted on 2002-05-02 17:23:11 by Maverick</div>
   </div>
   <div class="post" id="post-36214">
    <div class="subject"><a href="#post-36214">64 bit prime numbers</a></div>
    <div class="body">Rare find on P4 testing by ASM programmer:<br /><a target="_blank" href="http://www.mersenne.org/gimps/p4notes.doc">http://www.mersenne.org/gimps/p4notes.doc</a><br />...I found it a good read.</div>
    <div class="meta">Posted on 2002-05-02 17:26:08 by bitRAKE</div>
   </div>
   <div class="post" id="post-36231">
    <div class="subject"><a href="#post-36231">64 bit prime numbers</a></div>
    <div class="body">I gave it a quick look.. interesting.. when I have some time I'll read it well.<br /><br />BTW: you probably++ already know, but Intel nicely sends real (paper) book versions of its CPU books. Just got 248966-04 (Intel Pentium-IV and Intel Xeon Processor Optimization Reference Manual). The 3 books on the IA32 are backordered, and should arrive soon. Paper is much better than PDF, can bring it with me when I'm in holiday (NO! Assuming I'll have any holiday anyway). :)</div>
    <div class="meta">Posted on 2002-05-02 18:05:01 by Maverick</div>
   </div>
   <div class="post" id="post-36232">
    <div class="subject"><a href="#post-36232">64 bit prime numbers</a></div>
    <div class="body">Maverick, don't you have to call Intel by phone to get them to send<br />you the manuals? Or is there some online ordering page?</div>
    <div class="meta">Posted on 2002-05-02 18:12:08 by f0dder</div>
   </div>
   <div class="post" id="post-36236">
    <div class="subject"><a href="#post-36236">64 bit prime numbers</a></div>
    <div class="body">I did it via WEB.. maybe it was available only temporarily, dunno. Worth a check anyway! Sorry, don't have any link.. I was just browsing, found the link, clicked, wrote my address and voilat. ;)<br /><br />PS: What I recall was a button with a text like &quot;Order a hardcopy of this document&quot;.</div>
    <div class="meta">Posted on 2002-05-02 18:16:36 by Maverick</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=5099&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=5099&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="5099" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=5099&amp;page=2">&gt;</a><a href="../?id=5099&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>