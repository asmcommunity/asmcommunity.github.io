<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>OBJ --&gt; BSP Tree - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20751" />
  <link rel="prev" href="../?id=20751&amp;page=2" />  <link rel="next" href="../?id=20751&amp;page=4" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=20751">OBJ --&gt; BSP Tree</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=20751&amp;page=1" style="">&laquo;</a><a href="../?id=20751&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="20751" /><input type="number" name="page" min="1" max="4" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=20751&amp;page=4">&gt;</a><a href="../?id=20751&amp;page=4">&raquo;</a></form>   <div class="post" id="post-159492">
    <div class="subject"><a href="#post-159492">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">Here&#39;s the virtually completed SplitPolygon procedure.<br />All cases are handled for tri and quad polygons being split with a plane.<br />The only thing I&#39;m not doing at the moment is constructing the output geometry from the resulting intersection data.<br /><br />http://homer.ultrano.com/Upload/BSP_SplitPolygon.inc</div>
    <div class="meta">Posted on 2005-05-03 02:36:17 by Homer</div>
   </div>
   <div class="post" id="post-159493">
    <div class="subject"><a href="#post-159493">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">Addendum : Regarding Triangle : I&#39;ve added code for all cases of two edges of a triangle being intersected by a plane. These result in a new Triangle and a new Quad.<br /><br />I&#39;ve realized I forgot totally about the cases where one vertex is on the plane, and the other two are either side of plane. These should result in two Triangles.<br /><br />The code for Quads won&#39;t be difficult as long as I don&#39;t lose the piece of paper I&#39;ve been scratching diagrams on :)<br /><br />How&#39;s the weather?<br /></div>
    <div class="meta">Posted on 2005-05-03 04:06:04 by Homer</div>
   </div>
   <div class="post" id="post-159498">
    <div class="subject"><a href="#post-159498">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">I&#39;ve now handled all the abuttment cases for both polys, and I&#39;ve handled the bisection cases for triangles, and the diagonal bisection cases for quads (results in two triangles).<br /><br />I have also handled the two-edge intersection of a triangle (results in a triangle and a quad), and the two-edge intersection of a quad where the edges share a vertex (are neighbours, results in two triangles and a quad)<br /><br />The only remaining case : two-edge intersection of a quad where the edges share no vertices (are opposing edges, results in two quads)<br /><br />If I can gather the sanity to face this one again tonight, I&#39;ll finish SplitPoly tonight.<br /></div>
    <div class="meta">Posted on 2005-05-03 06:30:43 by Homer</div>
   </div>
   <div class="post" id="post-159507">
    <div class="subject"><a href="#post-159507">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">I completed SplitPoly, all cases handled, output polygons are calculated,etc.<br />Yay me !!<br /><br />Tomorrow I&#39;ll post updated code and tie any loose ends up, then it&#39;s time to work on the BuildBSPNode recursive method which drives ChooseBestFace and SplitPoly.<br />Should have the new BSP generator up and running in a few more days, or less.<br />It should prove faster than the old one, as well as being more efficient in terms of producing less overall faces (due to ability to split arbitrary polygons into both triangle and quad fragments).<br />More to the point, it&#39;s built on top of the HSM code, which is recent and appears solid.<br /><br />It seems like the more views a thread gets, the less people are actually reading it.. <br />I&#39;ve just made a fundamental improvement above the current generation of BSP generators, which will give me a clear advantage when it comes to collision detections (reduced plane count, plus ability to test quad plane instead of 2*tri plane)<br /><br />Does this stuff interest nobody but myself? <br /></div>
    <div class="meta">Posted on 2005-05-03 11:02:34 by Homer</div>
   </div>
   <div class="post" id="post-159509">
    <div class="subject"><a href="#post-159509">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body"><div class="quote">Does this stuff interest nobody but myself? </div><br />I&#39;m trying to follow, but you&#39;re too fast :P I&#39;m writing something like car-racer game (just to test what I&#39;ve learned). Right now I&#39;m implementing car-track collision. I think the stuff you discuss here is too complex for what I want to do now :)</div>
    <div class="meta">Posted on 2005-05-03 12:25:59 by ti_mo_n</div>
   </div>
   <div class="post" id="post-159520">
    <div class="subject"><a href="#post-159520">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">Not really - the track surfaces in your car game are a perfect candidate for BSP subdivisiion.<br />In fact, any time you have a fairly large number of &quot;world surfaces&quot; which you&#39;d like to render AND be able to collide with is ok to use a BSP.<br />BSP is really just an organized way of storing a mess of geometry.<br /><br />My new BSP generator takes HSM files as input - this is a custom format I designed for storing static models - 3d models that don&#39;t need to bend and are not animated.<br />I wasn&#39;t happy with the existing file formats I&#39;d come across as they are decidedly non coder-friendly, I wanted something that kept the geometry sorted by material.<br />The HSM file format is the property of Homerware Studios, inc.<br />You may use it as you wish, provided you supply your own sourcecode with regards to Importing and Exporting these models to and from your own application(s) and/or other file format(s).<br />I will release public documentation on the file format soon... if you want it sooner, ask.<br /><br />I&#39;ve written an OBJ to HSM converter module, meaning you can make your &quot;world&quot; , car track or castle wolfenstein in Maya or other 3D editing software, export to OBJ format, and take it from there.<br /><br />Once the world model has been converted from OBJ to HSM to BSP, we save it again, so we never need to reprocess the BSP unless the model is altered.<br /><br />Using a BSP is actually very easy. Generating one in the first place is more difficult.<br />Once I&#39;ve finished this code module, I&#39;ll be publishing three documents describing its inner working, my findings, and documentation for usage in your own games / game engines / large scale visualisation tools. As always, any code I post in public remains 100% public property, free to use, modify, use as a doorstop, etc. as you see fit.<br /><br />Have a nice day :)</div>
    <div class="meta">Posted on 2005-05-03 19:38:45 by Homer</div>
   </div>
   <div class="post" id="post-159560">
    <div class="subject"><a href="#post-159560">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">I know at least 30 people a day are watching this thread.. who are you? :)<br /><br />I&#39;d like to talk biefly about real application of BSP in games.<br />As any of you who have bothered to do your homework would have surmised, a BSP is a tree data structure.<br />What some of you may not be aware of is that the &quot;leaf nodes&quot; of the BSP tree are special.<br />Each leafnode can be thought of as a &quot;cell&quot; , &quot;room&quot;, or other empty partitioned 3D space.<br />If we trace back up through the tree from any leafnode to the tree root, all the splitting planes we discover actually define a hull surrounding an empty space in our world.<br />We can for example calculate which leafnode the camera is in, and thereby only perform collision checks against the planes which surround the camera at any given moment.<br />We can do this for any moving object.<br />Leafnodes in a BSP are special indeed !!<br />The partitioned spaces defined by leafnodes are not TOTALLY enclosed generally, because they have entrances and exits.<br />We can calculate &quot;portal planes&quot; which totally separate the spaces defined by leafnodes.<br />These are totally invisible surfaces which we can nonetheless perform collision checks against.<br />Portals are planes which connect two leafnodes - on one side is leafnode A, on the other is leafnode B. If objects (or the player-camera) collide with a portal plane, that object is moving from one leafnode to another - meaning we can calculate which leafnode an object is in ONCE, then track it from there.<br />Knowing which leafnode a moving object is in allows us to eliminate most of the world surfaces during our planar collision detection per object.<br />Faster physics means more time for other eyecandy, and/or more moving objects.<br /><br />Honk if you love beer :)<br /></div>
    <div class="meta">Posted on 2005-05-05 05:10:47 by Homer</div>
   </div>
   <div class="post" id="post-159584">
    <div class="subject"><a href="#post-159584">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">Is anyone else starting to see the motivation behind all this partitioning crap?<br />I&#39;m beginning to think that I am speaking over everyone.<br />When I joined this board, Scronty was posting regularly in this forum.<br />Where are you mate?<br /><br />Where are the ambitious young coders of tomorrow? Off playing Neopets?<br />I&#39;d really appreciate a little more feedback, otherwise I may as well not be posting.<br /></div>
    <div class="meta">Posted on 2005-05-05 13:01:11 by Homer</div>
   </div>
   <div class="post" id="post-159656">
    <div class="subject"><a href="#post-159656">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">Hey EvilHomer. I am interested in writing a lightweight (and fast) software renderer as the first step towards a full fledged game engine. I&#39;m primarily interested in visible surface determination and scene graph render/culling, so I find your work on BSP trees interesting. I&#39;m particularly interested in the application of BSP trees to scene rendering as a means of partitioning the drawing surface into drawn and undrawn areas.<br /><br />At the moment I am debating over what language(s) or SDKs to use. Although I find assembly language very intriguing (obviously for its speed) I am a bit inexperienced at it (really more of a C/C++ programmer) and also a bit worried over the lack of support for DirectX. I don&#39;t want to spend all my time maintaining a good set of DirectX include files. At the moment I am considering programming in MVC++ for the framework and using inline asm and MASM compiled subroutine modules for the dirty work, although I am disappointed that there is no good free optimizing compiler for windows (unless you count gcc w/ MinGW ug!) Oh well, I guess that&#39;s why god made #define.<br /><br />Anyway, so I&#39;d love to hear your opinion on the matter.</div>
    <div class="meta">Posted on 2005-05-06 07:59:54 by wildgnu</div>
   </div>
   <div class="post" id="post-159660">
    <div class="subject"><a href="#post-159660">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">The lack of DX support has been partially addressed by several individuals including myself, but nobody has yet bothered to translate the entire set of dx headers at once, which makes sense, since dx is modular in nature, most applications don&#39;t require all of it anyway.<br />To put it bluntly, DX is only a lib based api anyway, so keeping up with version changes isn&#39;t too difficult its just that its COM based and so we have to use COM calling convention (which is as simple as pushing one extra parameter in our dx calls, or using a dx call macro).<br /><br />What kind of software renderer did you have in mind? Realtime or not?<br /><br />BSP ensures theres that occluded surfaces are not rendered.<br />It achieves this at the BSPGenerator stage, by splitting all the world poygons against the planes of other world polygons, so that the occluded portions of surfaces are physically split away from the original polygon into one or more fragment polygons, which are then associated with the &quot;other&quot; side of that splitting plane. If we walk around the corner we can see them, they are &quot;in the next room&quot; in bsp terms we say they &quot;belong to the neighbouring leafnode, not the one we&#39;re standing in&quot;.<br />A BSPGenerator repeatedly splits the world into two using flat, infinite splitting planes which we get from the surface plane of other polygons in the world.<br />A good BSPGen will split as few polygons as possible through careful selection of the splitting plane during this repeated subdivision of the world, while simultaneously attempting to maintain the balance of the BSPTree by selecting a plane which splits the world into most equal halves in terms of the number of polygons which fall on either side of it.<br />If you think about it, these goals are mutually exclusive, but we can prevail, by using two heuristics.<br />My generator differs from the usual suspects in its ability to understand more than triangle polygons. I don&#39;t mean just in terms of being able to split quads with it, I mean that we can use quads when we create fragments during splitting, resulting in fewer polygons and also fewer surface planes, faster bsp generation times, faster render times, fewer collision detection calculations, etc.. leading to more time for more eye candy, more objects, etc.<br />An example is the splitting of an equilateral triangle.<br />If we split it one way, we get two equal half triangles.<br />If we split it the other way, we get a triangle and a quad.<br />Splitting a quad yields more but similarly simple cases.<br /><br />We can build the output polygons in the correct direction by observing the order of appearance of the vertices in the input polygon, so it becomes quite simple to write a polygon splitter, but making a smart and efficient splitter is a little more challenging.<br />It&#39;s the code which drives that splitter which requires closer attention.<br /><br />When you see how easy rendering a BSP is, you will reconsider its application as a VSD mechanism.<br />Of course, nothing can move around, or we have to alter the BSP in realtime, but that&#39;s doable too :D<br /></div>
    <div class="meta">Posted on 2005-05-06 08:36:51 by Homer</div>
   </div>
   <div class="post" id="post-159677">
    <div class="subject"><a href="#post-159677">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">Yes, I would like to design a real time software renderer. I want to focus on the rendering end of the game engine equation. As I said hidden surface removal interests me. BSP trees have a lot of applications in this regard especially if you implement a quake style portal system which it sounds like you are describing. Portals are inefficient though when the number of portals is large. Also, as you said, you have to handle moving walls with care.<br /><br />Besides BSP trees l am also interested in heirarchical oriented bounding boxes (OBB) as a means of culling whole scene graph subtrees before rendering as well as using quatrees and octrees to created a kind of visibility map. Not sure exactly how this would work but I have some ideas...<br /><br />Anyway, it sounds like you know a lot more about the relationship between DirectX and MASM than I do, perhaps you can help me find a good small set of macros to help me get started on my way. I don&#39;t like borrowing other people&#39;s include files, I find it tedious to sift through it all and I hate not understanding the code that I am relying on. I would much rather learn the theory behind it and create my own libraries. Again my only fear is that I would end up spending so much time maintaining the library and not working on the code... Really, I want something that will work on any windows platform, I&#39;m thinking of using DirectDraw and avoiding the whole D3D thing.<br /><br />After working on the renderer I plan to focus on scene graph management issues, collision detection, dynamic objects, &quot;AI&quot;, finite state machines perhaps... Also I am not particularly interested in the modeling side of the equation though obviously I will have to implement something with which to create test models.<br /><br />Thanks.</div>
    <div class="meta">Posted on 2005-05-06 10:18:36 by wildgnu</div>
   </div>
   <div class="post" id="post-159680">
    <div class="subject"><a href="#post-159680">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">What you need is one of the oop object call methods.<br />These are almost universally macro wrappers that push &quot;pThis&quot; and then all other params onto the stack and then perform the call as normal.<br />Several well-known variants include MCALL, DXINVOKE and ICALL.<br /><br />using these macros is simplicity itself. The standard format is:<br />mcall pClassObject, ClassName, MethodName, MethodParams<br /><br />DirectX has standard exported functions you use to create class objects.<br />But after that you have to use the returned objectpointer in your method calls as above.<br />Think of it as &quot;calling a procedure APON an instance of the object&quot;.<br />If we want to call code specifically apon a given &quot;target&quot; object, we obviously have to hand a pointer to the object in with our calls.<br />That&#39;s all the &quot;pThis&quot; parameter is, and what all the COM calling fuss is about.<br /><br />Now, even though using the call macro(s) is easy and even though we don&#39;t actually have to &quot;create&quot; object instances ourselves, we still have to &quot;define the class&quot; for the call macro to work properly.<br /><br />Defining a class in masm depends on which macro you choose, because each macro is from a different oopasm implementation.<br /><br />Therefore, you&#39;ll need to look at an existing example in order to understand how to translate the C headers for the classes to masm. This currently HAS to be done by hand for all the above reasons, but doesn&#39;t take long once you get going. (Who knows, perhaps we&#39;ll convert you to oopasm too :) )<br /><br />Personally I don&#39;t like BSP that much, but I do see untapped potential there.<br />I am quite taken by something you mentioned though, which is &quot;hierarchical object oriented bounding boxes&quot;, otherwise known as OSP2.<br /><br />This system is great for sparse worlds and handles moving objects better than bsp, and has a mechanism for grouping surfaces belonging to an entity.<br />It&#39;s a flop when applied in dense worlds however, and so its best application is really in outdoors engines.<br />Still, it does make me think about something thats been bugging me for a while - collision detection against the planes of hierarchical objects.<br />I concluded a while ago that its much faster to transform the test ray into each &quot;bone space&quot; than it is to transform each &quot;bone face&quot; back to world space.<br />It&#39;s something that I&#39;m yet to actually apply.<br /></div>
    <div class="meta">Posted on 2005-05-06 10:40:20 by Homer</div>
   </div>
   <div class="post" id="post-159684">
    <div class="subject"><a href="#post-159684">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">An example of what my masm based oop code looks like:<br /><br />mov pBSP, new (BSP) ;&lt;-- create instance of class<br />icall pBSP, BSP, LoadFromBinaryFile, CTEXT(&quot;MyWorld1.bsp&quot;) &lt;-- call class method on my object<br /><br />.. do something ...<br /><br /><br />delete pBSP ;&lt;-- delete the object (causes class destructor to be called)<br /><br /><br />New, icall and delete are macros from &quot;ATC&quot;, which is a set of macros written primarily by Ultrano.<br />You can find posts about it on this board, but they understate its potential and perhaps are not as clear as they could be considering how simple ATC macros are to apply.<br />I developed my D3D9 includes for/with ATC/masm.<br /></div>
    <div class="meta">Posted on 2005-05-06 10:55:11 by Homer</div>
   </div>
   <div class="post" id="post-159686">
    <div class="subject"><a href="#post-159686">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">I think a combination of a BSP and OBB could be useful, the BSP part for spatial sorting during the render phase and the OBB part for the culling phase. Anyway, this is all just talk, I&#39;d like to implement something and see just how it really performs...<br /><br />As for DirectX and &quot;oopasm&quot; (what a word!) the part I find confusing is the vtables... So when we get an instance of the object in order to call these functions don&#39;t we have to call via a pointer in a vtable? How do we know what order the functions are in the table and what about virtual functions and baseclass functions etc???</div>
    <div class="meta">Posted on 2005-05-06 11:07:07 by wildgnu</div>
   </div>
   <div class="post" id="post-159687">
    <div class="subject"><a href="#post-159687">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">If we define a class using ATC, we are really defining two things, with the same Name as the Class.<br />ATC creates these definitions internally.<br />So do other oop models, but I understand ATC best so I&#39;ll talk using it as an example.<br /><br />ATC creates,as I was saying, two Named thingies whose name = classname.<br />One is a data structure definition, whose fields are named the same as the data element fields from the class definition, plus one hidden dword used internally by ATC (so if you had three dword vars in your classdef, then the struct is 16 bytes in size).<br />This struct happens to be exactly what gets allocated each time we call new() to create an instance, and is basically also how COM instances are created.<br />New() allocates an object using Heap memory, of the size described.<br /><br />The second thing that ATC defines internally from the classdef is the vtable.<br />This is a hardcoded jumptable which is compiled in the data segment by ATC.<br />We can totally forget it exists in practise, but that&#39;s what it is.<br /><br />So - in response to your question regarding vtables, the whole point of using an oop macro to call class methods on class object instances is that the macro, in combination with the macro(s) used to define the classdef, do all that dirty work for you.<br />In reality, icall() uses the classname you gave in the method call as a guide to which vtable it should be calling a function from, and then it calls the method using a hardcoded index into the jumptable (calculated at build time).<br />So ATC does all the real work at build time, calls are fast (very little overhead), objects are on a growable heap, anything else? :)<br /></div>
    <div class="meta">Posted on 2005-05-06 11:20:28 by Homer</div>
   </div>
   <div class="post" id="post-159688">
    <div class="subject"><a href="#post-159688">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">Note that we can apply this stuff to existing classes like with DX, and/or with our own classes.<br />Writing code using oop and asm at once is extremely liberating and addictive.<br />Your code gains the best from both worlds so to speak.<br />Not only that, but we can use this as a bridge to call code written in VB for example.<br />Or we can write a superfast OCX in sweet oopasm and market it to VB coders.<br />I&#39;m sure you can think of ways you can gain from using this stuff.<br />For me, it began with ATC&#39;s malloc() macro, which it internally uses for heap allocations but which me may also merrily use along with its partner free() macro.<br />I hadn&#39;t even looked at the oop aspect and I was already hooked by the elegance of these macros, and their seemingly limitless application potential.<br /></div>
    <div class="meta">Posted on 2005-05-06 11:28:58 by Homer</div>
   </div>
   <div class="post" id="post-159693">
    <div class="subject"><a href="#post-159693">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">Ok, so how do I sign up? I&#39;d like to digest the inc&#39;s though and really understand what is happening below the surface. No matter how easy it may be to use these macros I still think ignorance is not always bliss when it comes to programming.</div>
    <div class="meta">Posted on 2005-05-06 12:02:39 by wildgnu</div>
   </div>
   <div class="post" id="post-159736">
    <div class="subject"><a href="#post-159736">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">Ultrano hosts ATC at his site, http://www.ultrano.com<br />You can get the very latest version there.<br /><br />He also hosts a little dump for me :) http://homer.ultrano.com<br />You can find some related junk there, which was written for prior versions.<br /><br />ATC is now in version 34, which equates to roughly one version update per year up until this point, however don&#39;t hold your breath waiting for a new version as it&#39;s pretty much finalversion now.<br /><br />There are other oop models to investigate too, I am most familiar with / prefer this one</div>
    <div class="meta">Posted on 2005-05-06 23:17:20 by Homer</div>
   </div>
   <div class="post" id="post-159762">
    <div class="subject"><a href="#post-159762">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">Actually, the link is http://www.ultrano.com/ilix<br />Also, there are some tutorials that cover the basic stuff of ATC (they&#39;re 1 year old) there . Some of the tutorials show you how to make ATC show all the code it generates - which is exactly what you said you want :) . <br />Other tute iirc shows how to make ATC generate automatically the skeleton of all methods (procs) your new classes need. <br /><br /><br /><br />A brief tute to the newest features in ATC can be found here:<br />http://www.asmcommunity.net/board/index.php?topic=17987.0<br /><br />Ah and &quot;equates to one version per year&quot; ... hmm I thought this month I turn out only 21 years old :)<br />Those &quot;versions&quot; are actually the count of features ATC has at some point. When I add some new feature (or a group of features) , I increment that &quot;version&quot;. ATC started off like a simple C++ class wrapper to turn out like a tool to aid me complete much more work faster ;)</div>
    <div class="meta">Posted on 2005-05-07 06:45:50 by Ultrano</div>
   </div>
   <div class="post" id="post-159768">
    <div class="subject"><a href="#post-159768">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">Roughly one version per year since I first got involved with it, it was an educated guess..<br />It&#39;s a feature count? Now I know something else I don&#39;t care about and will never use :)<br /><br />Ultrano - Hope all is well in your world mate.<br />Mine sucks at the moment, you could write a song about it.<br />First my dog went missing, then my girlfriend left me for her ex who happens to be a friend just to complicate things, then my epox based box decided to spontaneously combust...<br />I&#39;m struggling to smile as I install masm on a 333 and look around for my wallet...<br /><br />wildgnu - I did not elaborate on the shortcomings of ATC, which is unjust.<br />It is single-inheritance, like C++ is.<br />Each class can inherit from one, and only one, previously-defined class.<br />I am unaware of a depth limit, but if there is one, it would be masm&#39;s 30-something nesting depth limit.<br />Base classes don&#39;t inherit from IUnknown, they don&#39;t inherit from anything.<br />If you want to use ATC with COM, you need to look at my example D3D9 stuff.<br />You will see that I either define IUnknown class and inherit from it, or I redefine it at the start of each class, depending on which example you are looking at (I left my early examples in their original state so that other authors could follow my trail).<br />As Ultrano stated, ATC was written as a C++ wrapper.<br />He wanted to call C++ stuff from asm.<br />Then he saw he could do the reverse.<br />Then I pointed out that it could be adapted for COM support.<br />Then my code started looking very different..<br /><br />Personally, I am totally in love with ATC.<br />Nonetheless, as I have said previously, there ARE other models to investigate.<br />Some of them are more elaborate than ATC.<br />They inevitably pay a price for it (generally in call overhead), and since I am into speed and lowlevel code, I love ATC. If you are smart you will shop around. I am sticking with what works for me until I have a damn good reason not to.<br /><br /></div>
    <div class="meta">Posted on 2005-05-07 07:42:33 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=20751&amp;page=1" style="">&laquo;</a><a href="../?id=20751&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="20751" /><input type="number" name="page" min="1" max="4" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=20751&amp;page=4">&gt;</a><a href="../?id=20751&amp;page=4">&raquo;</a></form>  </div>
 </body>
</html>