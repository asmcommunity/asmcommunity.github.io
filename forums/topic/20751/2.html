<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>OBJ --&gt; BSP Tree - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20751" />
  <link rel="prev" href="../?id=20751&amp;page=1" />  <link rel="next" href="../?id=20751&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=20751">OBJ --&gt; BSP Tree</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=20751&amp;page=1" style="">&laquo;</a><a href="../?id=20751&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="20751" /><input type="number" name="page" min="1" max="4" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=20751&amp;page=3">&gt;</a><a href="../?id=20751&amp;page=4">&raquo;</a></form>   <div class="post" id="post-158180">
    <div class="subject"><a href="#post-158180">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">awesome *alright* <img src="http://www.ultrano.com/s1.gif" /><br />I&#39;ll study a bit BSP to be of help with the object lists ;)</div>
    <div class="meta">Posted on 2005-03-21 10:10:50 by Ultrano</div>
   </div>
   <div class="post" id="post-158186">
    <div class="subject"><a href="#post-158186">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">but isnt Mirrors easier todo with portal rendering?<br />the mirror is just a portal to a different view of the room, and the portal is set to be not able to enter thru it<br /><br /><br /></div>
    <div class="meta">Posted on 2005-03-21 15:54:57 by daydreamer</div>
   </div>
   <div class="post" id="post-158190">
    <div class="subject"><a href="#post-158190">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">Mirroring is one effect which is easy to accomplish with Portal rendering, true, but it doesn&#39;t come cheap - you are simply rendering more polygons than the geometry stipulates are really there, and then you have to pay for it too, by clipping each and every one against the frustum and against the Portal poly.<br />Environmental texturing, aided by the TL pipeline in hardware, is bound to be faster and still gives visually pleasing results for reflective surfaces.<br />I&#39;m not pro-bsp, nor am I anti-portal.<br />The most recent BSP implementation I&#39;ve seen actually included elements of both rendering systems, ie, it was a BSP which contained portal planes as well as surface planes. <br />These guys had realized that they could actually add some quality control to the BSP generation algorithm such that the generator could automatically create portals during BSP generation, which could be used to reduce splitting of polygons and improve the balance of the tree - ie, improve both BSP goals at once through minor subdivision of the worldspace via invisible planar surfaces.<br />How&#39;s them apples?</div>
    <div class="meta">Posted on 2005-03-21 18:33:11 by Homer</div>
   </div>
   <div class="post" id="post-158193">
    <div class="subject"><a href="#post-158193">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">I&#39;m seriously considering storing the coordinates for each polygon in &quot;plucker space&quot;.<br />This &quot;plucker space&quot; is a 6D space which is useful for quickly determining whether a ray intersects a polygon or not, and where. Note - not just whether it intersects the PLANE of the polygon, but the GEOMETRY of the polygon, which normally requires a number of ray/plane tests followed by a number of edge/point tests.<br />This would be extremely useful in a realtime physics simulation involving large numbers of objects in motion as it offers a potential speedup which cannot be easily dismissed.<br />The cost of this speedup is the precalculation of the PluckerSpace coordinates of each polygon, which in turn describe the polygon&#39;s plane as a Plucker HyperPlane.<br />These would replace the conventional surfacenormal of each polygon.<br /></div>
    <div class="meta">Posted on 2005-03-21 19:29:18 by Homer</div>
   </div>
   <div class="post" id="post-158194">
    <div class="subject"><a href="#post-158194">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">I am now absorbing Nathan Whitaker&#39;s &#39;Extracting connectivity information from a BSP tree&quot; whitepaper.<br />It describes the process of creating Portals between the Leaves of a BSP.<br />These Portals are then used for VSD (culling) .. if a Portal is visibile, then the Leaf beyond it is visible.<br /><br />The Portals are not encoded in the BSP at all.<br />They are generated at runtime from the BSP binary data.<br /><br />I don&#39;t want to implement it yet, but I mean to.<br />Another great use for these BSP leaf portals is to use them to generate a perLeaf PVS. Alan Baylis has written an excellent tutorial on the subject of generating REALTIME PVS from the LeafPortals of a BSP.<br />The industry standard is to precalculate this and store it in the binary file.<br />It&#39;s huge, several meg of data for ten thousand poly worlds.<br />The industry standard is to use RLE and other compressions to get it back down to a reasonable 20 or 30kb, but what a lot of overhead when there&#39;s a cheaper way !!<br />The LeafPortals VSD method places realtime PVS very much within our grasp.<br />With all due respect to Carmack and Abrash, thanks for all the fish.<br /><br /></div>
    <div class="meta">Posted on 2005-03-21 20:03:45 by Homer</div>
   </div>
   <div class="post" id="post-158202">
    <div class="subject"><a href="#post-158202">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">Just a note to say I&#39;ve completed the BSP reloader.<br />I was only reconstructing the Nodes tree before, now I&#39;m reloading the whole lot.<br /><br />The BSP is reloaded into the following container object:<br /><br /><pre><code><br />class BSP, ,C++ compatible<br />? ? void LoadBinaryFile:pFileName<br />? ? long pfilemem<br />? ? long pBSPRoot<br />? ? long pVec3Array<br />? ? long pVec2Array<br />? ? long pTextures<br />? ? long pFaces<br />endclass<br /></code></pre><br /><br />As you can see, this class only has one public method, and the name is a bit of a giveaway as to its purpose.<br /><br />pBSPRoot points to a BSPNode object (first in a linked tree).<br />pVec3Array and pVec2Array are managed arrays of uniqie Vec3 and Vec2 values, respectively, from which the Faces index their primitives.<br />pTextures is an instance of TextureManager class.<br />pFaces points to a PolygonManager object, which contains a list of Triangles which are described by the indices of their primitives.<br />IE - a Triangle has three points - it needs three indices for Position vectors, three indices for UV vectors, and three indices for Normal vectors (pervertex normals), and it also needs a TextureID, which is an indexed Texture.<br /><br />MeshLoader - the class used to import TriangleSoup from OBJ file format.<br />It uses ObjectLists to store stuff.<br />BSPGenerator - the class used to convert a MeshLoader to HSP binary file<br />BSPNode - the node structure for a reloaded HSPTree<br />This time it&#39;s stored as a LinkedList of Objects (via Pointers).<br />BSP - the container class used to reload a HSP binary file (uses BSPNode)<br /><br /><br /></div>
    <div class="meta">Posted on 2005-03-21 21:16:31 by Homer</div>
   </div>
   <div class="post" id="post-158213">
    <div class="subject"><a href="#post-158213">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">I&#39;ve added a second Method to the BSP class.<br />It&#39;s called CalculateSurfaceNormals.<br />BSP_LoadBinaryFile now calls it following reloading of the BSP data.<br />It&#39;s the same code as used in BSPGenerator, and should be put in a separate procedure and called from each Method to reduce the filesize a hundred bytes or so if I really gave a crap.<br /><br />Basically, I&#39;m preparing to try Rendering stuff soon.<br /></div>
    <div class="meta">Posted on 2005-03-22 03:44:42 by Homer</div>
   </div>
   <div class="post" id="post-158222">
    <div class="subject"><a href="#post-158222">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">I&#39;ve added a third Method to the BSP class.<br />It&#39;s name is Render, and it renders the BSPTree recursively.<br /><br />The code is complete but remains unimplemented due to constraints on my time.<br />I&#39;ll see if everything is working nicely soon enough.<br /><br />Rendering the BSPTree is very easy indeed.<br />Each node represents a splittingplane which was obtained from a polygon.<br />At each node, we classify that plane against the position of the camera, using the ClassifyPoint procedure.<br />We want to know which side of the plane the camera resides.<br />If the camera is smack on the plane, we consider it as being on the front side for the sake of convention.<br />Having determined which side the camera is on, we walk the child tree for the OTHER side first and then the child tree for the SAME side second, then having walked both child trees and returned, we draw the splitterplane poly.<br />The result of this is that the leaf polygons are drawn first, and the root poly drawn always last, and with the exact order being dependant on the location of the camera, but always using painters algorithm.</div>
    <div class="meta">Posted on 2005-03-22 08:55:38 by Homer</div>
   </div>
   <div class="post" id="post-158251">
    <div class="subject"><a href="#post-158251">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">This is an example of a NODEY BSP TREE (as opposed to a LEAFY tree).<br />The polygons are distributed throughout the Nodes of the Tree.<br />The other kind, LEAFY, shoves all the polygons down into the LEAF nodes.<br />NODEY is more useful for collision detection, but LEAFY can render slightly faster (in theory).<br />Since I will be wanting to perform collision testing against the world surfaces, NODEY seemed more appropriate.<br /><br />In some BSP tutorials you will see a lot of references to LEAF nodes - for example, what leaf is the Camera within. These tutorials are geared towards LEAFY tree model, and so I want to make a clear distinction.<br />When you see such references to LEAF nodes, we are really referring to an entire BRANCH of the tree, from Root to Leaf.<br />LEAFY bsp tutorials describe the partitioned world as being a bunch of spaces represented by the leaves of the BSPTree, and that the Camera can only be inside one Leaf at a time.<br />For a Nodey BSPTree, the Camera is somewhere between the Root node and one of the Leaves.<br />IE, it&#39;s somewhere on a Branch from Root to some Leaf.<br />So when we say &quot;what Leaf is the Camera in&quot; we are really saying &quot;what Leaf&#39;s Branch is the Camera in&quot;.<br />This was described more clearly in my last post, regarding Rendering the Tree with respect to the Camera position.<br /><br />Basically the number of LeafNodes&nbsp; of the BSPTree indicates how many separate volumes the world has been chopped into - true - but we must assume that, having discovered during the render recursion process which Leaf is terminal for the Camera&#39;s current position, that this Leaf &quot;owns all the Nodes above it, up to and including Root&quot;, because all of those bound the volume which the camera is located in.<br /><br />If we count the Leaf nodes and number them, we can track &quot;which Leaf we are in&quot; just as in a Leafy Tree. <br /><br />When it comes to creating PORTALS BETWEEN LEAFNODES, we can aplply the Portals between the actual LeafNodes, but must take ALL geometry into account when clipping the Portal polygon (whittling it down to size, as these start massive and are trimmed to the world geometry).<br /><br />This process is n times faster than actual BSPGeneration, since we are only clipping a couple of triangles against the world, instead of every triangle against every triangle&#39;s plane (n = #polygons)<br />Therefore it should probably remain a runtime processing step - it seems a waste to store all these extra polygons within the BSP file when they can be regenerated relatively quickly.<br /><br />So why bother creating these &quot;portals between leaves&quot;?<br /><br />The answer is pretty straightforwards, it&#39;s the obvious reason to use Portals every time.<br />We will cull the portals against the view frustum.<br />If a portal is visible, then the leaf beyond it is visible.<br />If a portal is not visible, then neither is the leaf beyond it.<br />This can speed up render times even more, bringing the actual number of polygons being rendered at any moment down to at most a few hundred in most situations.<br /><br />Now we have married the best features of BSP and Portal rendering engines.<br />I&#39;ve been having some discussions with Ultrano concerning adaptation of his smAlloc memory manager into a utility objectlist container. I hope to squeeze some new life into it before it is relegated to the (pardon the pun) Heap.<br /><br />I wonder how many people are still following this thread?<br />Does anyone else have anything to contribute to this thread?<br /><br /></div>
    <div class="meta">Posted on 2005-03-22 22:50:46 by Homer</div>
   </div>
   <div class="post" id="post-158259">
    <div class="subject"><a href="#post-158259">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">I try to follow, but I know too little about BSP to make any worthwile comment<br />but my thought is: are polycount like 0.5m that much on todays hardware and does speed matter that much of reducing polys, doesnt it matter more of organize it to fewest trianglestrip calls and fewest texturechanges and reorder those trianglestrips to be rendered in right order(from meshes)<br /><br />theoretically if you have a bounch of trianglestrips, couldnt you instead extend each trianglestrip if possible with a hidden quad, that connects to the next trianglestrip etc<br />so perfect condition you only have one call to a &quot;sewed together&quot; trianglestrip call<br /></div>
    <div class="meta">Posted on 2005-03-23 02:24:48 by daydreamer</div>
   </div>
   <div class="post" id="post-158272">
    <div class="subject"><a href="#post-158272">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">Texture thrashing is an important issue - at the last moment, faces need to be sorted by texture id.<br />This eliminates the thrashing.<br />We cannot and do not use trianglestrips for the world surfaces encoded in a BSP.<br />We can however use them in OSP.<br /><br />One demo I wrote under D3D a while ago , the terraindemo I&#39;ve mentioned in the past, was an example of heightmapped terrain via a 2D OSP of sorts.<br />The world was a big square, chopped into 16x16 patches.<br />Each patch was a collection of trianglestrips.<br /><br />I could perform culling on a per-patch basis, but I had not generated a Tree containing patch nodes, so I could not employ hierarchical culling methods directly.<br /><br /></div>
    <div class="meta">Posted on 2005-03-23 05:46:49 by Homer</div>
   </div>
   <div class="post" id="post-158304">
    <div class="subject"><a href="#post-158304">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">Hey Homer<br /><br />Like daydreamer I don&#39;t know enough about BSP to comment constructively but I&#39;m following the thread with increasing interest.<br /><br />With regards to clipping to portals, do you actually need to clip the visible polys?<br />If any part of the poly is visible through the portal why not simply draw the entire poly, the resulting overdraw penalty could be less than the overhead of clipping the poly to the portal.<br /></div>
    <div class="meta">Posted on 2005-03-23 16:55:52 by Maelstrom</div>
   </div>
   <div class="post" id="post-158383">
    <div class="subject"><a href="#post-158383">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">The industry defacto standard seems to be to limit overdraw to no more than 10x per pixel.<br />If you&#39;re only looking at a 3D cube in empty space this isn&#39;t a worry.<br />But if you are drawing a 3D world then you really need to reduce overdraw as much as you can.<br />In a portal rendering system, especially where used indoors, we can rely on our limited view through portals to limit rendering to no deeper than the next cell (or leaf) most of the time, but occasionally we&#39;ll be able to see other portals through the current portal, and the overdraw per pixel can rapidlly increase (especially for outdoor scenes).<br /><br />Overdraw is exactly what we are trying to prevent, especially when depth buffering is enabled.<br />Most of the programming madness in 3D stuff has that much in common - they&#39;re almost all methods of attempting to reduce or eliminate overdraw, while correctly handling occlusions.<br /><br />You don&#39;t have to clip polygons to the portal, but depending on the implementation, not doing so can lead to visual artifacts (example is a pure portal engine, where portals can connect arbitrary regions of 3D space, ie arbitrary cells). Regardless, the overdraw is the issue of concern.<br /></div>
    <div class="meta">Posted on 2005-03-24 19:50:52 by Homer</div>
   </div>
   <div class="post" id="post-158387">
    <div class="subject"><a href="#post-158387">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">I&#39;ve been thinking about an OSP implementation where the vertices are relative to the origin of the LeafNode they are within. In turn, the LeafNodes contain the 3D offsets of their origin (to avoid recalculating it all the time) to be used as a translation from world origin during rendering.<br />The idea appeals to me more because I&#39;ve recently implemented manager classes for arrays of unique 2D and 3D values which can be referenced via their indices.<br />It occurred to me when I studied OSP tree generators where I noted that a common first step is to calculate a bounding geometry (cube or sphere) for the entire world, and then generally at this moment, the vertices are all shifted to move the origin of the bounding geometry to conincide with world origin (ie, centralize the world geometry about world zero).<br />I realized that this could be done at each iteration during the recurive building of the tree, with the offset to the node origin being absolute translation from world origin.<br />Assuming that any polygons to be rendered by such a system will at least have lighting applied to them in hardware, then we can say they are going to be processed by the TL pipeline and so there&#39;s no real cost to perform the translation required to render a node&#39;s vertices.<br />The probability of numeric dupications being discovered by my unique vec2 and vec3 managers is high - I&#39;m effectively using it as a form of realtime vertex compression.<br />Faces pretty much will always refer to vertices by index, so all I&#39;m really doing is eliminating unnecessary vertices and reducing the number of indices.<br /><br />I guess this could also apply to a KD-Tree or a BSP-Tree, or N-Tree, it just seems more obvious to me with regards to OSP.<br /><br />Anyway, the beauty of always basing vertices around a shifted origin is that it allows a very fast classification algorithm during tree generation/modification by simply checking the Sign of the vertices.<br />We can say that the eight child nodes are +++, ++-, +-+,+--,-++,-+-, --+,--- :)<br />Another way to do this might be to leave the vertices alone until it comes time to detect collisions, and then transform them into &quot;node space&quot;.<br />This is for when we wish to , for example, create the intersection of a decal crater and the terrain, or when we wish to blow a nice jagged hole in a wall, to handle the intersection across node boundaries where the nodes are at different depth of subdivision.<br /></div>
    <div class="meta">Posted on 2005-03-24 20:27:20 by Homer</div>
   </div>
   <div class="post" id="post-158734">
    <div class="subject"><a href="#post-158734">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">hi.<br />i m interested in this, since, would you believe it, i m involved in a sort of a student project that deals with building of bsp trees from an arbitrary scene, building &quot;visibility graphs&quot; and &quot;adjacency graphs&quot; and displaying the whole mess in an optimized way. tis hard to stay motivated but i should keep going on. theres a teacher that is a researcher that gives up thesis about bsp... congrats for what you do.well were doing c++,but i m interested in the SplitPolygon function...<br /><br />bye<br /></div>
    <div class="meta">Posted on 2005-04-05 08:12:28 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-159100">
    <div class="subject"><a href="#post-159100">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">The SplitPolygon procedure actually only works with Triangles in my example, but can work with arbitrary polygons too.<br /><br />It works by first classifying all Polygon Points against the Plane.<br />Then we examine the number of points on either side and on the plane to reduce the number of possible outcomes to only three.<br /><br />1. The triangle is totally on one side of the plane. One, two or even three points may be on the plane, but we push them along the plane normal and classify them as being on the + side.<br /><br />2. The triangle is split into two triangles. One vertex is on the plane, the other two lay either side of the plane.<br /><br />3. The triangle is split into three triangles. One vertex is on one side of the plane, the other two vertices are on the other side of the plane.<br /><br />From these cases, we extrapolate potential triangles based on intersection points.<br /><br />The SplitPolygon proc I wrote can either actually calculate the split triangles and return them, or it can just perform the classification and return a result implying the split result, used to give a &quot;score&quot; to potential splitplanes when deciding the best plane to split with.<br /><br />Hope that helped :)</div>
    <div class="meta">Posted on 2005-04-17 05:50:38 by Homer</div>
   </div>
   <div class="post" id="post-159439">
    <div class="subject"><a href="#post-159439">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">I&#39;m about to rework my BSP code to support quads as well as triangles, and to better handle coplanar polygons.<br />In the previous post regarding SplitPoly , the third case of a Triangle being split would produce one Triangle and one Quad, rather than three Triangles.<br />Splitting a Quad results in only a few more Cases.<br />I&#39;ve narrowed down the possible Cases for splitting a Quad with a Plane to seven.<br />Can you think of any more?<br />(NB - I can modify my existing SplitPoly to handle both types at once, no drama)<br /><br />1. None of the quad&#39;s vertices are on the Plane.<br />The four vertices are totally on one side of the Plane.<br />This isn&#39;t really an intersecting case.<br /><br />2. None of the quad&#39;s vertices are on the Plane.<br />Two appear on wither side of the Plane.<br />The quad is split into two Quads.<br /><br />3. None of the quad&#39;s vertices are on the Plane.<br />One appears on one side, and three on the other side.<br />The quad is split into a Triangle (side A) and a Triangle and a Quad (side B).<br /><br />4. One of the quad&#39;s vertices lays on the Plane, the other three are on the same side of the Plane.<br />The quad is abutting the Plane.<br />This isn&#39;t really an intersecting case.<br /><br />5. One of the quad&#39;s vertices lays on the plane.<br />One lays on one side, the other two lay on the other side.<br />The quad is split into a Triangle and a Quad.<br /><br />6. Two vertices which form an Edge of the quad lay on the Plane. <br />The other two are on the same side of the Plane.<br />The quad is abutting the Plane.<br />This isn&#39;t really an intersecting case.<br /><br />7.. Two vertices which form diagonal corners of the quad lay on the plane.<br />The other two lay either side of the plane.<br />The quad is split into two triangles.<br /><br />The benefit of also supporting quads in the BSP is that we reduce the number of Planes required to both map the world and to perform collision detection against it.<br />Besides that, I plan on calculating &quot;interleaf portals&quot; soon, which are in fact only invisible quads which &quot;cover the doorways&quot; in the world - they stand between one leaf region and another.<br />If we hit-detect against these, we can track the nodal location of objects and thus only require surface collision detection against the surfaces in that leafnode, ie, those surfaces which bound the region of space represented by this leafnode.<br />It would be really handy if we could handle these natively as quads rather than as pairs of triangles because again we are reducing the workload - especially when it comes to stabbing geometry with rays.<br /><br /><br /></div>
    <div class="meta">Posted on 2005-05-01 11:30:25 by Homer</div>
   </div>
   <div class="post" id="post-159452">
    <div class="subject"><a href="#post-159452">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">I&#39;m coding it up now.<br />The number of cases I gave in the last post was overestimated.<br />Actually, the cases for split classification of a Quad face&#39;s vertices are as follows:<br /><br />1. Front<br />2. Back<br />3. TwoFrontTwoBack<br />4.OneFrontThreeBack<br />5.ThreeFrontOneBack<br /><br />We can merge the cases for Tris and Quads and use a modified SplitPoly procedure to handle them both.<br />SelectBestFace won&#39;t care what kind of faces it is evaluating.<br />It will just call SplitPoly (with intersections disabled) for every combination of face pairs and select the best face based on the absolute difference result, as it already does.<br />What I&#39;m doing at the moment to handle this stuff is building a list of &quot;references to faces&quot; and then evaluating those.<br />Since my HSM system stores Faces in Material groups, I tag each reference object with a pointer back to the face&#39;s owner material.<br />I also tag each reference with an indicator of the polygon type (tri or quad).<br />This allows me to process a simple linear array of the same structure in the poly pair comparator, divide the faces down into sublists, and yet retain the existing material groupings.<br />At the very least, if I was to process the faces directly, I&#39;d have to rebuild the face arrays to keep a material tag and I&#39;d just be moving larger structures around during processing.<br /><br />BSPFaceRef struct<br />? ? TriOrQuad dw ?? ? ? ;&lt;-- identifies whether this refers to a Triangle or Quad face<br />? ? pMaterial? ?dd ?? ? ? ;&lt;-- points to HSMaterial which owns this face<br />? ? pFace? ? ? ? dd ?? ? ? ;&lt;-- points to a HSMFace3 or HSMFace4<br />BSPFaceRef ends<br /><br /></div>
    <div class="meta">Posted on 2005-05-02 03:03:55 by Homer</div>
   </div>
   <div class="post" id="post-159458">
    <div class="subject"><a href="#post-159458">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">Here&#39;s the start of the new SplitPoly code.<br />As you can see, I&#39;m extracting the Planes of faces every time I compare them.<br />This is bad, but read on.<br />You can see the first test being performed here anyway.<br />We are testing whether ALL of the vertices of the subject polygon are resting on the test plane. If they are, we have a special case of coplanar input polygons which we can take advantage of by grouping faces by Plane in the BSP nodes.<br />(The VertexPointers in a Face are 12 bytes apart...)<br />Since no splitting is necessary for a coplanar polygon, we theoretically shove the polygon into a front or back list according to whether their normals face the same way or not.<br /><br />What I&#39;ll probably end up doing is calculating the Planes in the code that drives SplitPoly, and handing the Planes to SplitPoly as more input params (reduces total calculations considerably). <br />Just out of curiosity, who is following these posts?<br /><br /><pre><code><br />;=======================================================<br />;? ?Note that the following code section treats the input polygons (pplanePolygon and ppolygonToSplit)<br />;? ?as both being TRIANGLES, regardless of whether they are actually Tri or Quad polygons.<br />;? ?The simple reasoning behind this is that we can treat the first three vertices of a Quad as a Tri<br />;? ?for the purposes of calculating a surface normal, since a Quad is always flat, we know that if we<br />;? ?perceive a Quad as two triangles, that both triangles are coplanar.<br />;? ?The HSMFace3 and HSMFace4 structures were deliberately designed with this in mind.<br />;=======================================================<br /><br />;? ?Get the SurfaceNormal of the polygon which is being evaluated for splitting<br />;? ?We can disregard the actual number of vertices in each polygon for now.<br />? ? mov ecx,ppolygonToSplit<br />? ? mov eax,.BSPFaceRef.pFace<br />? ? invoke SurfaceNormalFromTrianglePoints, .HSMFace3.pvert0,.HSMFace3.pvert1,.HSMFace3.pvert2,addr polysNormal<br /><br />;? ?Get the SurfaceNormal of the polygon whose plane is being evaluated as the best splitting plane<br />;? ?We can disregard the actual number of vertices in each polygon for now.<br />? ? mov ecx,pplanePolygon<br />? ? mov eax,.BSPFaceRef.pFace<br />? ? invoke SurfaceNormalFromTrianglePoints, .HSMFace3.pvert0,.HSMFace3.pvert1,.HSMFace3.pvert2,addr planeNormal<br /><br />;? ?Get a point on the Plane - the first vertex of the planepoly will do just fine.? ? <br />;? ?Even though the planepoly might be a Face3 or a Face4 - who cares - vert0 is same<br />? ? mov ecx,pplanePolygon<br />? ? mov eax,.BSPFaceRef.pFace<br />? ? m2m ppointOnPlane,.HSMFace3.pvert0<br /><br />? ? ;----------------------------------------------------------------------------------------------------<br />? ? ;Check if ALL THREE (OR FOUR?) of the splittee polygon&#39;s vertices lie on the splitter plane<br />? ? ;ie are the Splitter and Splittee CoPlanar?<br />? ? ;(Hey, won&#39;t this only occur if their SurfaceNormals match? or does planeD differ a lot?)<br />? ? ;----------------------------------------------------------------------------------------------------<br />? ? mov ecx,ppolygonToSplit<br />? ? .if .BSPFaceRef.TriOrQuad==0<br />? ? ? ? mov numVerts,3<br />? ? .else<br />? ? ? ? mov numVerts,4<br />? ? .endi<br />? ? xor ecx,ecx<br />? ? mov numPointsOnPlane,ecx<br /><br />? ? mov ecx,.BSPFaceRef.pFace<br />? ? lea esi, .HSMFace3.pvert0<br />? ? xor ecx,ecx<br />? ? .while ecx&lt;numVerts<br />? ? ? ? push ecx<br />? ? ? ? push esi<br />? ? ? ? invoke ClassifyPoint, dword ptr, ppointOnPlane, addr planeNormal<br />? ? ? ? .if eax!=0<br />? ? ? ? ? ? pop esi<br />? ? ? ? ? ? pop ecx<br />? ? ? ? ? ? jmp @F<br />? ? ? ? .endif<br />? ? ? ? inc numPointsOnPlane<br />? ? ? ? pop esi<br />? ? ? ? add esi,3*4? ? ? ? <br />? ? ? ? pop ecx<br />? ? ? ? inc ecx<br />? ? .endw<br />? ? ;----------------------------------------------------------------------------------------------------<br />? ? ;Handle Special Case - Splitter and Splittee are CoPlanar<br />? ? ;----------------------------------------------------------------------------------------------------<br />;**code goes here<br /><br />@@:<br /><br /></code></pre></div>
    <div class="meta">Posted on 2005-05-02 04:56:00 by Homer</div>
   </div>
   <div class="post" id="post-159491">
    <div class="subject"><a href="#post-159491">Re: OBJ --&gt; BSP Tree</a></div>
    <div class="body">Here&#39;s the current state of my new SplitPoly procedure.<br />The last input param is a pointer to a buffer to receive new polygons formed during splitting.<br />If this parameter is NULL, the procedure merely evaluates a potential polysplit.<br />So far I&#39;ve handled the following cases (for both tri and quad polys):<br />-Coplanar<br />-Abutting<br />I only have the cases resulting in Splits to code up.<br />I&#39;m trying to decide which way to go about it.<br /><br />ClassifyPoint classifies a 3d point against a plane.<br />The result is signed and indicates which side of the plane the point lays.<br />Possible return values are -1, +1 and 0.<br /><br />The following code relies a lot on ClassifyPoint to determine firstly whether the poly and plane are coplanar, and then to determine whether polygon edges intersect the plane.<br />The second part is really easy.<br />If we think of a polygon edge as two points in space, and classify both the points against the plane, we can tell if they are both on the same side of the plane or not.<br />If they are on the same side of the plane, no intersection occurs :)<br />If they are NOT on the same side, THE EDGE MUST INTERSECT THE PLANE AT SOME POINT - and we can calculate the intersection point using some vector math and the plane equation, or by other means.<br /><br />Having determined which edges of the polygon intersect the plane, and calculated the intersection points, we can calculate some UV coordinates for the intersection points (we can extrapolate these from the input polygon&#39;s vertices).<br />Finally, we can generate several output polygons based on which edges intersected the plane, the input vertices from the input polygon, and the new vertices from the intersection points.<br /><br />I must be talking to myself, since I see no replies other than my own :(<br /><br /><pre><code><br />TEMPVERTEX struct<br />X REAL4 ?<br />Y REAL4 ?<br />Z REAL4 ?<br />U REAL4 ?<br />V REAL4 ?<br />TEMPVERTEX ends<br /><br />SplitPolygon proc ppolygonToSplit:ptr BSPFaceRef, pplanePolygon:ptr BSPFaceRef, ppolygons:DWORD<br />local ppointOnPlane:ptr Vec3<br />local planeNormal:Vec3<br />local polysNormal:Vec3<br />local tempVec:Vec3<br /><br />local inpts[4]:TEMPVERTEX<br />local outpts[4]:TEMPVERTEX<br /><br />local numPointsOnPlane&nbsp; &nbsp; &nbsp; ;&lt;-- How many of the polygon&#39;s vertices lay on the plane<br /><br />;These two are counters used to count vertices on each side of plane<br />;while testing a polygon&#39;s Edges (pairs of vertices) against the Plane<br />local in_c&nbsp; &nbsp; &nbsp; <br />local out_c<br /><br />;Two endpoints of an Edge of the polygon to test against the Plane<br />local ptA:TEMPVERTEX<br />local ptB:TEMPVERTEX<br /><br />;These hold the Signed Results after classifying an Edge<br />;against the Plane. They indicate which side of the Plane<br />;each endpoint of the Edge exists on, which&nbsp; in turn implies<br />;whether the Edge and Plane intersect or not.<br />local sideA:SDWORD<br />local sideB:SDWORD<br /><br />;This holds the point on Plane where an Edge intersects it<br />local intersection:TEMPVERTEX<br /><br />local outputFlag<br />;A bunch of variables used while calculating new UV&#39;s for intersection points<br />local x1, x2, y1, y2, z1, z2, u1, u2, v1, v2, ftheScale:REAL4<br /><br />local iPoint&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Index of current Point (during processing of Points of a Triangle)<br /><br />local numVerts&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;#Vertices in polygon<br /><br /><br />&nbsp; &nbsp; ;================================================================================<br />&nbsp; &nbsp; ; INITIALIZE LOCAL VARIABLES<br />&nbsp; &nbsp; ;================================================================================<br />&nbsp; &nbsp; xor eax,eax<br />&nbsp; &nbsp; mov numPointsOnPlane,eax<br />&nbsp; &nbsp; mov out_c,eax<br />&nbsp; &nbsp; mov in_c,eax&nbsp; &nbsp; <br />&nbsp; &nbsp; mov numPointsOnPlane,eax<br />&nbsp; &nbsp; mov sideA,eax<br />&nbsp; &nbsp; mov sideB,eax<br />&nbsp; &nbsp; mov sideC,eax<br />&nbsp; &nbsp; mov sideD,eax<br /><br />&nbsp; &nbsp; mov ecx,ppolygonToSplit<br />&nbsp; &nbsp; .if .BSPFaceRef.TriOrQuad==0<br />&nbsp; &nbsp; &nbsp; &nbsp; mov numVerts,3<br />&nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; mov numVerts,4<br />&nbsp; &nbsp; .endi<br />;================================================================================<br />;&nbsp;  Note that the following code section treats the input polygons (pplanePolygon and ppolygonToSplit)<br />;&nbsp;  as both being TRIANGLES, regardless of whether they are actually Tri or Quad polygons.<br />;&nbsp;  The simple reasoning behind this is that we can treat the first three vertices of a Quad as a Tri<br />;&nbsp;  for the purposes of calculating a surface normal, since a Quad is always flat, we know that if we<br />;&nbsp;  perceive a Quad as two triangles, that both triangles are coplanar.<br />;&nbsp;  The HSMFace3 and HSMFace4 structures were deliberately designed with this in mind.<br />;================================================================================<br /><br />;&nbsp;  Get the SurfaceNormal of the polygon which is being evaluated for splitting<br />;&nbsp;  We can disregard the actual number of vertices in each polygon for now.<br />&nbsp; &nbsp; mov ecx,ppolygonToSplit<br />&nbsp; &nbsp; mov eax,.BSPFaceRef.pFace<br />&nbsp; &nbsp; invoke SurfaceNormalFromTrianglePoints, .HSMFace3.pvert0,.HSMFace3.pvert1,.HSMFace3.pvert2,addr polysNormal<br /><br />;&nbsp;  Get the SurfaceNormal of the polygon whose plane is being evaluated as the best splitting plane<br />;&nbsp;  We can disregard the actual number of vertices in each polygon for now.<br />&nbsp; &nbsp; mov ecx,pplanePolygon<br />&nbsp; &nbsp; mov eax,.BSPFaceRef.pFace<br />&nbsp; &nbsp; invoke SurfaceNormalFromTrianglePoints, .HSMFace3.pvert0,.HSMFace3.pvert1,.HSMFace3.pvert2,addr planeNormal<br /><br />;&nbsp;  Get a point on the Plane - the first vertex of the planepoly will do just fine.&nbsp; &nbsp; <br />;&nbsp;  Even though the planepoly might be a Face3 or a Face4 - who cares - vert0 is same<br />&nbsp; &nbsp; mov ecx,pplanePolygon<br />&nbsp; &nbsp; mov eax,.BSPFaceRef.pFace<br />&nbsp; &nbsp; m2m ppointOnPlane,.HSMFace3.pvert0<br /><br /><br />&nbsp; &nbsp; ;------------------------------------------------------------------------------------------------------------<br />&nbsp; &nbsp; ;CLASSIFY ALL OF THE POLYGON VERTICES AGAINST THE PLANE<br />&nbsp; &nbsp; ;-------------------------------------------------------------------------------------------------------------<br />;&nbsp; &nbsp; ptA = polygonToSplit.Vertex[0];<br />&nbsp; &nbsp; mov eax,polygonToSplit<br />&nbsp; &nbsp; mov eax,.BSPFaceRef.pFace<br />&nbsp; &nbsp; mov eax, .HSMFace3.pvert0<br />&nbsp; &nbsp; fld .Vec3.X<br />&nbsp; &nbsp; fld .Vec3.Y<br />&nbsp; &nbsp; fld .Vec3.Z<br />&nbsp; &nbsp; fstp ptA .Z<br />&nbsp; &nbsp; fstp ptA .Y<br />&nbsp; &nbsp; fstp ptA .X<br /><br />;&nbsp; &nbsp; ptB = polygonToSplit.Vertex[1];<br />&nbsp; &nbsp; mov eax,polygonToSplit<br />&nbsp; &nbsp; mov eax,.BSPFaceRef.pFace<br />&nbsp; &nbsp; mov eax, .HSMFace3.pvert1<br />&nbsp; &nbsp; fld .Vec3.X<br />&nbsp; &nbsp; fld .Vec3.Y<br />&nbsp; &nbsp; fld .Vec3.Z<br />&nbsp; &nbsp; fstp ptB .Z<br />&nbsp; &nbsp; fstp ptB .Y<br />&nbsp; &nbsp; fstp ptB .X<br /><br />;&nbsp; &nbsp; ptC = polygonToSplit.Vertex[2];<br />&nbsp; &nbsp; mov eax,polygonToSplit<br />&nbsp; &nbsp; mov eax,.BSPFaceRef.pFace<br />&nbsp; &nbsp; mov eax, .HSMFace3.pvert2<br />&nbsp; &nbsp; fld .Vec3.X<br />&nbsp; &nbsp; fld .Vec3.Y<br />&nbsp; &nbsp; fld .Vec3.Z<br />&nbsp; &nbsp; fstp ptC .Z<br />&nbsp; &nbsp; fstp ptC.Y<br />&nbsp; &nbsp; fstp ptC .X<br /><br />&nbsp; &nbsp; invoke&nbsp; ClassifyPoint, addr ptA, addr pointOnPlane, pplaneNormal<br />&nbsp; &nbsp; mov sideA,eax<br />&nbsp; &nbsp; invoke ClassifyPoint,addr ptB, ppointOnPlane, addr planeNormal<br />&nbsp; &nbsp; mov sideB,eax<br />&nbsp; &nbsp; invoke ClassifyPoint,addr ptC, ppointOnPlane, addr planeNormal<br />&nbsp; &nbsp; mov sideC,eax<br /><br />&nbsp; &nbsp; .if numVerts==4<br />&nbsp; &nbsp; ;&nbsp; &nbsp; ptD = polygonToSplit.Vertex[3];<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,polygonToSplit<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,.BSPFaceRef.pFace<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax, .HSMFace3.pvert3<br />&nbsp; &nbsp; &nbsp; &nbsp; fld .Vec3.X<br />&nbsp; &nbsp; &nbsp; &nbsp; fld .Vec3.Y<br />&nbsp; &nbsp; &nbsp; &nbsp; fld .Vec3.Z<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp ptD .Z<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp ptD .Y<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp ptD .X<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke ClassifyPoint,addr ptD, ppointOnPlane, addr planeNormal<br />&nbsp; &nbsp; &nbsp; &nbsp; mov sideD,eax<br />&nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; ;----------------------------------------------------------------------------------------------------<br />&nbsp; &nbsp; ;Check if ALL THREE (OR FOUR?) of the splittee polygon&#39;s vertices lie on the splitter plane<br />&nbsp; &nbsp; ;ie are the Splitter and Splittee CoPlanar?<br />&nbsp; &nbsp; ;(Hey, won&#39;t this only occur if their SurfaceNormals match? or does planeD differ a lot?)<br />&nbsp; &nbsp; ;----------------------------------------------------------------------------------------------------<br />&nbsp; &nbsp; .if sideA==0 <br />&nbsp; &nbsp; &nbsp; &nbsp; inc numPointsOnPlane <br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; .if sideB==0<br />&nbsp; &nbsp; &nbsp; &nbsp; inc numPointsOnPlane <br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; .if sideC==0<br />&nbsp; &nbsp; &nbsp; &nbsp; inc numPointsOnPlane <br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; .if numVerts==4<br />&nbsp; &nbsp; &nbsp; &nbsp; .if sideD==0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc numPointsOnPlane<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; mov eax,numPointsOnPlane <br />&nbsp; &nbsp; .if eax==numVerts<br />&nbsp; &nbsp; &nbsp; &nbsp; ;----------------------------------------------------------------------------------------------------<br />&nbsp; &nbsp; &nbsp; &nbsp; ;Handle Special Case - Splitter and Splittee are CoPlanar<br />&nbsp; &nbsp; &nbsp; &nbsp; ;No splitting will be necessary, but we&#39;ll still have to make<br />&nbsp; &nbsp; &nbsp; &nbsp; ;a decision about whether to call this a Front or Back face.<br />&nbsp; &nbsp; &nbsp; &nbsp; ;----------------------------------------------------------------------------------------------------<br />&nbsp; &nbsp; &nbsp; &nbsp; ;Decide whether to toss the splittee into the front or back list<br />&nbsp; &nbsp; &nbsp; &nbsp; ;based on whether the normals face the same way or not.<br />&nbsp; &nbsp; &nbsp; &nbsp; ;Since the normals may differ very slightly due to fpu error and epsilon value,<br />&nbsp; &nbsp; &nbsp; &nbsp; ;simply comparing them is a bad move.<br />&nbsp; &nbsp; &nbsp; &nbsp; ;We could add them and see if the result is near zero, but we&#39;re still pissing around.<br />&nbsp; &nbsp; &nbsp; &nbsp; ;Let&#39;s do it right and use the poly&#39;s normal as a testpoint<br />&nbsp; &nbsp; &nbsp; &nbsp; ;by adding the poly&#39;s normal and first vertex and testing against Plane<br />&nbsp; &nbsp; &nbsp; &nbsp; ;----------------------------------------------------------------------------------------------------<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,pPolygonToSplit<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,.BSPFaceRef.pFace<br />&nbsp; &nbsp; &nbsp; &nbsp; mov esi, .HSMFace3.pvert0<br />&nbsp; &nbsp; &nbsp; &nbsp; fld .Vec3.X<br />&nbsp; &nbsp; &nbsp; &nbsp; fadd polysNormal.X<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp tempVec.X<br />&nbsp; &nbsp; &nbsp; &nbsp; fld .Vec3.Y<br />&nbsp; &nbsp; &nbsp; &nbsp; fadd polysNormal.Y<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp tempVec.Y<br />&nbsp; &nbsp; &nbsp; &nbsp; fld .Vec3.Z<br />&nbsp; &nbsp; &nbsp; &nbsp; fadd polysNormal.Z<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp tempVec.Z<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke ClassifyPoint, addr tempVec, ppointOnPlane, addr planeNormal<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==1&nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Front<br />&nbsp; &nbsp; &nbsp; &nbsp; .elseif eax==-1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Back<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ;----------------------------------------------------------------------------------------------------<br />&nbsp; &nbsp; .elseif eax==1&nbsp; &nbsp; &nbsp; ;ONE VERTEX ON PLANE<br />&nbsp; &nbsp; &nbsp; &nbsp; ;----------------------------------------------------------------------------------------------------<br />&nbsp; &nbsp; &nbsp; &nbsp; ;HANDLE ABUTTING CASES OF A SINGLE VERTEX ON PLANE<br />&nbsp; &nbsp; &nbsp; &nbsp; ;----------------------------------------------------------------------------------------------------<br />&nbsp; &nbsp; &nbsp; &nbsp; .if numVerts==3<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if sideA==0 <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (sideB&gt;0 &amp;&amp; sideC&gt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif&nbsp;  (SideB&lt;0 &amp;&amp; sideC&lt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif sideB==0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (sideA&gt;0 &amp;&amp; sideC&gt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif&nbsp;  (SideB&lt;0 &amp;&amp; sideC&lt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif sideC==0 <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (sideA&gt;0 &amp;&amp; sideB&gt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif&nbsp;  (sideA&lt;0 &amp;&amp; sideB&lt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .elseif numVerts==4<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if sideA==0 <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (sideB&gt;0 &amp;&amp; sideC&gt;0 &amp;&amp; sideD&gt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif&nbsp;  (SideB&lt;0 &amp;&amp; sideC&lt;0&nbsp; &amp;&amp; sideD&lt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif sideB==0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (sideA&gt;0 &amp;&amp; sideC&gt;0 &amp;&amp; sideD&gt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif&nbsp;  (SideA&lt;0 &amp;&amp; sideC&lt;0&nbsp; &amp;&amp; sideD&lt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif sideC==0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (sideA&gt;0 &amp;&amp; sideB&gt;0 &amp;&amp; sideD&gt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif&nbsp;  (SideA&lt;0 &amp;&amp; sideB&lt;0&nbsp; &amp;&amp; sideD&lt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif sideD==0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (sideA&gt;0 &amp;&amp; sideB&gt;0 &amp;&amp; sideC&gt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif&nbsp;  (SideA&lt;0 &amp;&amp; sideB&lt;0&nbsp; &amp;&amp; sideC&lt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; ;----------------------------------------------------------------------------------------------------<br />&nbsp; &nbsp; .elseif eax==2&nbsp; &nbsp; &nbsp; ;ONE VERTEX ON PLANE<br />&nbsp; &nbsp; &nbsp; &nbsp; ;----------------------------------------------------------------------------------------------------<br />&nbsp; &nbsp; &nbsp; &nbsp; ;HANDLE ABUTTING CASES OF AN EDGE ON PLANE<br />&nbsp; &nbsp; &nbsp; &nbsp; ;----------------------------------------------------------------------------------------------------<br />&nbsp; &nbsp; &nbsp; &nbsp; .if numVerts==3<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if (sideA==0 &amp;&amp; sideB==0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if&nbsp; sideC&gt;0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif&nbsp; sideC&lt;0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif (sideA==0 &amp;&amp; sideC==0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if&nbsp; sideB&gt;0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif&nbsp; sideB&lt;0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif (sideB==0 &amp;&amp; sideC==0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if&nbsp; sideA&gt;0 <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif sideA&lt;0 <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .elseif numVerts==4<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if (sideA==0 &amp;&amp; sideB==0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if&nbsp; (sideC&gt;0 &amp;&amp; sideD&gt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif&nbsp; (sideC&lt;0 &amp;&amp; sideD&lt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif (sideB==0 &amp;&amp; sideC==0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if&nbsp; (sideA&gt;0 &amp;&amp; sideD&gt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif&nbsp; (sideA&lt;0 &amp;&amp; sideD&lt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif (sideC==0 &amp;&amp; sideD==0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if&nbsp; (sideA&gt;0 &amp;&amp; sideB&gt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif&nbsp; (sideA&lt;0 &amp;&amp; sideB&lt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif (sideA==0 &amp;&amp; sideD==0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if&nbsp; (sideB&gt;0 &amp;&amp; sideC&gt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif&nbsp; (sideB&lt;0 &amp;&amp; sideC&lt;0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; .endif<br />;==========================================================<br />;We have now handled all the following cases:<br />;-coplanar faces<br />;-faces with a single abutting vertex<br />;-faces with an abutting edge<br />;<br />;If we get this far, then our polygon MUST be cut by the plane.<br />;More importantly, we can say that the plane must cut TWO EDGES<br />;of our polygon, and therefore, and one (or two) edges are &quot;safe&quot;.<br />;eg crap ascii art<br />;<br />;&nbsp; &nbsp; &nbsp;  /\&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;&lt;-- pA is all alone<br />;&nbsp; &nbsp; &nbsp; /&nbsp; \&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;&lt;--- output tri<br />;__/___\____&nbsp;  ;&lt;-- intersection points on edge 0 and 2<br />;&nbsp; /&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \&nbsp; &nbsp; &nbsp; &nbsp;  ;&lt;-- output quad<br />;/_______\&nbsp; &nbsp; &nbsp;  ;&lt;-- &quot;safe&quot; edge = 1<br />;What we do next will depend very much on whether we are merely <br />;evaluating the polygon for potential splitting, or actually splitting it.<br />;The order of vertices in newly-formed output polygons is crucial.<br />;These polygons will be constructed based on which two edges were cut.<br />;==========================================================<br /></code></pre><br /></div>
    <div class="meta">Posted on 2005-05-03 01:29:41 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=20751&amp;page=1" style="">&laquo;</a><a href="../?id=20751&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="20751" /><input type="number" name="page" min="1" max="4" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=20751&amp;page=3">&gt;</a><a href="../?id=20751&amp;page=4">&raquo;</a></form>  </div>
 </body>
</html>