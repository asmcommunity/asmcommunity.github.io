<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>explaining register *mov&quot; easy way - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16991" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=16991">explaining register *mov&quot; easy way</a></p>
   <div class="post" id="post-131848">
    <div class="subject"><a href="#post-131848">explaining register *mov&quot; easy way</a></div>
    <div class="body">explaning  registers movements easy way       ( thanks kulhas )<br /><br />mov eax , 1       means  eax = 1 <br /> <br /> <br /><br />mov eax , '1'     means  eax = 31h    ( 31h is '1' ) <br /> <br /> <br /><br />mov eax , 12      means   eax = 12<br /> <br /> <br /><br />mov eax , '1234'   means   eax = 34333231h     ( 34333231h is  '4321') <br />                            reversse order<br /> <br /> <br /> <br /> <br /><br />capix :) <br /> <br /><br />another example<br /><br />section data<br /><br />zuzu:<br />db 0<br />db 0<br />db 0<br />db 0,0<br /> <br /> <br /> <br /><br />section code<br /> <br /><br />mov eax,zuzu        means that eax = to the adress of zuzu <br />                            eax points  to zuzu label<br /> <br /><br />mov byte ,1      means we place in eax first element  number 1 <br />                               eax = 1000<br /> <br /><br />mob byte ,2     means we place in second element number 2 <br />                                   eax = 1200<br /><br /><br />we can not do<br /><br />cmp eax,1200   <br /><br />becouse eax its only the pointer to the adress of zuzu label .    eax = adress of zuzu in memory<br /> <br /><br /><br /> <br /> <br /> <br /> <br /> <br /><br />we can compare each element !<br /><br />cmp ,1<br />cmp ,2<br />cmp ,0<br />cmp ,0<br /><br />another thing<br /><br />mov eax,&quot;1234&quot;   means eax = &quot;4321&quot; = 34333231h<br /><br />but if we do after this line<br /><br />mov eax,&quot;1&quot;   eax = &quot;1&quot; = 31h<br /> <br /> <br /><br />mov eax, &quot;1234&quot;<br />mov eax,&quot;1&quot;<br /> <br /><br />its the same of doing only<br /><br />mov eax ,&quot;1&quot;<br /> <br /> <br /> <br /> <br /> <br /> <br /> <br />just a litle program to test this<br /><br />%include &quot;\lab\vasm\inc\nagoa.inc&quot;<br /> <br /> <br /><br /><br /><br />..start:<br /> <br /><br />mov eax,&quot;1234&quot;<br />cmp eax,34333231h   ;  eax ?   =  &quot;4321&quot;<br /><br />jne not_equal<br />call MessageBoxA ,NULL,&quot; equal !&quot;,&quot;teste&quot;,MB_OK<br />jmp out_<br />not_equal:<br />call MessageBoxA ,NULL,&quot; not equal !&quot;,&quot;teste&quot;,MB_OK<br /><br />out_: <br />call ExitProcess,0<br /><br /> <br /> <br /> <br />another test<br />%include &quot;\lab\vasm\inc\nagoa.inc&quot;<br /> <br /> <br /><br /><br /><br />..start:<br /> <br /><br />section data <br /><br />  zuzu: <br />  db 0 <br />  db 0 <br />  db 0 <br />  db 0,0 <br />    <br />    <br />    <br /><br />  section code <br />    <br />  xor eax,eax<br /><br />  mov eax,zuzu        ; means that eax = to the adress of zuzu  <br />                             ; eax points  to zuzu label <br />    <br /><br />  mov byte ,1    ; means we place in eax first element  number 1  <br />                             ; eax = 1000 <br />    <br /><br />  mov byte ,2   ; means we place in second element number 2  <br />                               ; eax = 1200 <br /> <br />  cmp dword  ,0   <br />  jne not_equal<br />  call MessageBoxA , NULL,&quot;it is equal&quot;,&quot;info&quot;,MB_OK<br />  jmp out_<br /><br />  not_equal:<br />  call MessageBoxA ,NULL,&quot;not equal..&quot;,&quot;info&quot;,MB_OK<br /><br />  out_:<br />  call ExitProcess,0<br /><br /> <br /> <br /> <br /> <br /><br />well  and after this  just a final one :)<br /> <br /> <br /> <br /><br />%include &quot;\lab\vasm\inc\nagoa.inc&quot;<br /> <br /> <br /><br /><br /><br />..start:<br /> <br /><br />section data <br /><br />  zuzu: <br />  dd 0                             ; size dword<br />  db 0                             ; size byte<br />  db 0                             ; size byte<br />  db 0,0                          ; size byte<br />    <br />    <br />  section code <br />    <br />  mov byte ,1           ; place in first element number 1<br />  mov byte ,2       ; second element of zuzu number 2<br />  mov byte ,3   ; thirth element of zuzu number 3<br /> <br /><br />  cmp byte ,2<br />  jne not_equal<br />  call MessageBoxA , NULL,&quot;it is equal&quot;,&quot;info&quot;,MB_OK<br />  jmp out_<br /><br />  not_equal:<br />  call MessageBoxA ,NULL,&quot;not equal..&quot;,&quot;info&quot;,MB_OK<br /><br />  out_:<br />  call ExitProcess,0 <br /><br /><br />nasm win32 group and examples here <br /><a target="_blank" href="http://groups.yahoo.com/group/win32-nasm-users/">http://groups.yahoo.com/group/win32-nasm-users/</a></div>
    <div class="meta">Posted on 2004-01-27 09:01:35 by Nguga</div>
   </div>
   <div class="post" id="post-131874">
    <div class="subject"><a href="#post-131874">explaining register *mov&quot; easy way</a></div>
    <div class="body"><div class="quote"><br />mov eax,zuzu means that eax = to the adress of zuzu <br />eax points to zuzu label<br /></div><br />Not with stupid masm syntax, where &quot;mov eax, zuzu&quot; equals &quot;mov eax, &quot;</div>
    <div class="meta">Posted on 2004-01-27 10:50:12 by f0dder</div>
   </div>
   <div class="post" id="post-131879">
    <div class="subject"><a href="#post-131879">explaining register *mov&quot; easy way</a></div>
    <div class="body">That's Intel Syntax, MASM simply follows it, as does TASM.<br />I cannot deny Intel being stupid though ;)</div>
    <div class="meta">Posted on 2004-01-27 11:11:10 by Henk-Jan</div>
   </div>
   <div class="post" id="post-131894">
    <div class="subject"><a href="#post-131894">explaining register *mov&quot; easy way</a></div>
    <div class="body">Such syntax can be debated both ways.<br /><br />When you initialize the value of a label (or modify its value later) one could say that label=value, much like we learned to assign values to variables in algebra. On that basis, it can be considered quite logical if the variable y=2 to interpret<br /><br />mov eax,y<br /><br />as meaning move the value 2 of the variable into eax.<br /><br />Some later assemblers were built to interpret the variable's name as its location in memory (some of them probably doing it only to be different from the original MASM) even though specific instructions are available to perform that exact duty and are thus redundant in such assemblers (i.e. <strong>mov eax,offset y</strong> and <strong>lea eax,y</strong>).<br /><br />Raymond</div>
    <div class="meta">Posted on 2004-01-27 12:44:43 by Raymond</div>
   </div>
   <div class="post" id="post-131898">
    <div class="subject"><a href="#post-131898">Oh f0dder likes that huh</a></div>
    <div class="body">Yeah he must be a C programmer. That NASM is a bunch of crap! Reversing the order? What's that about? MASM is pure nuemonic representation of machine code as it should be thank God. Sure one or two surprizes like:<br /><br />unstead of:<br /><br />repnz<br />movsd<br /><br />it's:<br /><br />rep movsd<br /><br />Hey I can work with that, but please leave the bytes in their respective order. That why we understand what's happening in the machine. LIFO memory is reversed when in memory not the registers. My God what confusion. You can have it f0dder, it's about your speed.</div>
    <div class="meta">Posted on 2004-01-27 13:13:28 by mrgone</div>
   </div>
   <div class="post" id="post-131934">
    <div class="subject"><a href="#post-131934">explaining register *mov&quot; easy way</a></div>
    <div class="body">Just what are you talking about, mrgone? masm,fasm,tasm,nasm (etc) use the same operand order: &quot;dest, source&quot;. Quite the same as standard C library routines and assignment rules, btw.<br /><br />What I don't like is the lack of constistency in masm: a variable access is a memory access, dereferencing an offset. When doing this with registers or fullblown SIB, you have to add brackets.<br /><br />*forcing* brackets for variables makes the code cleaner and more consistant, and leaves the assembler with the choice of interpreting a variable without brackets as it's address - which saves me from typing &quot;offset&quot;.<br /><br /><br />As for<br /><div class="quote"><br />MASM is pure nuemonic representation of machine code as it should be thank God. <br /></div><br /> - *cough*. As if fasm/masm/tasm/nasm (heck, even atrocious gnu as) weren't. Besides, masm is probly the least &quot;pure&quot; assembler, with all the <strong>high-level</strong> support it has (as if this was a bad thing).</div>
    <div class="meta">Posted on 2004-01-27 16:37:47 by f0dder</div>
   </div>
   <div class="post" id="post-131939">
    <div class="subject"><a href="#post-131939">explaining register *mov&quot; easy way</a></div>
    <div class="body">There seems to be a bit of folklore occurring here with the syntax of different assembler. NASM for example uses square brackets for addressing as part of its design where MASM being the older and far more widespread industrial standard stil uses a derivation of the much earlier Intel standard syntax.<br /><br />When you have a &quot;LOCAL var :DWORD&quot; in MASM, you use the NAME as the address as MASM has always done it and don't try and copy less successful assemblers that do it a diferent way.<br /><br />Roughly, when in Rome, do as the Romans do so if you write GAS, write it the way it should be written, if you write NASM, do it according to its syntax rules and when you write in MASM, use the syntax correctly and don't try and copy bad habits from other assemblers.<br /><br />There is no intrinsic right or wrong in the notation used by different assembler, just syntax errors by those who assume that one form should be used by others. Fortunately not everyone who wrote assembler a long time ago wrote in the style of TASM virus writers. :tongue: <br /><br />Regards,<br />http://www.asmcommunity.net/board/cryptmail.php?tauntspiders=in.your.face@nomail.for.you&amp;id=2f46ed9f24413347f14439b64bdc03fd</div>
    <div class="meta">Posted on 2004-01-27 18:08:29 by hutch--</div>
   </div>
   <div class="post" id="post-131942">
    <div class="subject"><a href="#post-131942">explaining register *mov&quot; easy way</a></div>
    <div class="body"><div class="quote">*forcing* brackets for variables makes the code cleaner and more consistant</div><br /><br />Any programmer can write code that computers can understand. Good programmers write code that humans can understand.</div>
    <div class="meta">Posted on 2004-01-27 18:52:07 by Henk-Jan</div>
   </div>
   <div class="post" id="post-131944">
    <div class="subject"><a href="#post-131944">explaining register *mov&quot; easy way</a></div>
    <div class="body">I have always spent more time thinking than typing - no matter the language.  Maybe I am just developmentally disabled? :notsure:</div>
    <div class="meta">Posted on 2004-01-27 19:02:42 by bitRAKE</div>
   </div>
   <div class="post" id="post-131948">
    <div class="subject"><a href="#post-131948">I talking about</a></div>
    <div class="body">this NASM garbage:<br /><br />mov eax , '1234' means eax = 34333231h ( 34333231h is '4321') <br />reversse order<br /><br /><br /> You know f0dder you seem to be very well educated in fuctions calls I guess do to you vast C++ experience but I never here anything substitive come out of you when it comes to real low level. Oh you claim you do but everytime something goes over your head you bash it as a &quot;cheap hack&quot;. I have been able to do more than I ever thought possible with MASM and once again I am a hardware engineer so I am more concerned with bits and bytes.</div>
    <div class="meta">Posted on 2004-01-27 20:14:30 by mrgone</div>
   </div>
   <div class="post" id="post-131949">
    <div class="subject"><a href="#post-131949">hi!</a></div>
    <div class="body">just to say :) <br /><br />NASM use 100% intel syntax<br /><br /><br />Anyway you can read the nasm documentation:<br /><br /><a target="_blank" href="http://nasm.sourceforge.net/doc/html/nasmdoc0.html">http://nasm.sourceforge.net/doc/html/nasmdoc0.html</a><br /><br /><br /><br />Intel syntax:<br />mov eax, <br />or<br />lea eax, <br /><br />and<br />call function<br /><br />is different of:<br />call <br /><br />and NASM uses it so. All this is Intel.<br /><br />NASM uses it.</div>
    <div class="meta">Posted on 2004-01-27 20:30:36 by Nguga</div>
   </div>
   <div class="post" id="post-131967">
    <div class="subject"><a href="#post-131967">explaining register *mov&quot; easy way</a></div>
    <div class="body">Nguga, we already covered that in another thread. NASM does NOT use Intel Syntax. Use google please. Stop saying the same wrong stuff after it has been pointed out to be wrong. It makes you look stupid.</div>
    <div class="meta">Posted on 2004-01-28 03:52:02 by Henk-Jan</div>
   </div>
   <div class="post" id="post-131973">
    <div class="subject"><a href="#post-131973">explaining register *mov&quot; easy way</a></div>
    <div class="body"><div class="quote"><br />this NASM garbage:<br /><br />mov eax , '1234' means eax = 34333231h ( 34333231h is '4321') <br />reversse order<br /></div><br />I like that feature of nasm pretty much... When you see people move &quot;text&quot; into registers this way, it's usually to construct or check for a string. It's pretty silly having to &quot;cmp ax, 'ZM'&quot; or &quot;mov , 'LLD.'&quot; (and '23LE' and 'NREK'). Matter of taste anyway.<br /><br /><div class="quote"><br />Oh you claim you do but everytime something goes over your head you bash it as a &quot;cheap hack&quot;. <br /></div><br />No, not when something goes over my head, but when something obviously is a hack. Don't assume I can't do lowlevel code just because I dislike crap code.</div>
    <div class="meta">Posted on 2004-01-28 05:00:57 by f0dder</div>
   </div>
   <div class="post" id="post-131980">
    <div class="subject"><a href="#post-131980">googling...</a></div>
    <div class="body">googling...<br /><br /><br />-----------------------------------------------------------------------------------------<br />at this site:<br /><br /><a target="_blank" href="http://linuxassembly.org/resources.html">http://linuxassembly.org/resources.html</a><br /><br /><br />you can read this :<br /><br /><br />NASM  	x86 assembler with Intel syntax<br /><br /><br /><br /><br />-------------------------------------------------------------------------------------<br /><br /><br />onother link:<br /><br /><br /><a target="_blank" href="http://www.tldp.org/">http://www.tldp.org/</a><br /><br /><br />informs you :<br /><br />NASM is Intel-style syntax<br /><br /><br />-------------------------------------------------------------------------------------------<br /><br /><br />another link:<br /><br /><a target="_blank" href="http://home.ptd.net/~tms2/hello.html">http://home.ptd.net/~tms2/hello.html</a><br /><br />How do I write &quot;Hello, world&quot; in FreeBSD assembler?<br />Thomas M. Sommers<br /><br /><br />NASM	If you prefer Intel syntax in your assembler, try NASM. It is in the FreeBSD ports system.<br /><br />-------------------------------------------------------------------------------------------------<br /><br /><br /><br />another link:<br /><br /><a target="_blank" href="http://www.bumba.net/~hmaon/a2i/">http://www.bumba.net/~hmaon/a2i/</a><br /><br />Att2Intl home page<br />Att2Intl will convert gcc's AT&amp;T syntax assembly output (.s) into Intel syntax (.asm), intended for compilation with NASM or Tasm<br /><br /><br />------------------------------------------------------------------------------------------------------<br /><br /><br />well ....  they are all wrong ??<br /><br /><br /><br />The University of Illinois at Urbana-Champaign<br />Department of Electrical and Computer Engineering<br />Computer Engineering II<br />Spring 2004<br /><br /><br /><br /><a target="_blank" href="http://courses.ece.uiuc.edu/ece291/lecture/index.html">http://courses.ece.uiuc.edu/ece291/lecture/index.html</a><br /><br /><br /><a target="_blank" href="http://courses.ece.uiuc.edu/ece291/">http://courses.ece.uiuc.edu/ece291/</a><br /><br /><br /><a target="_blank" href="http://www.google.com/search?q=nasm+syntax+intel+site%3Auiuc.edu&amp;sourceid=mozilla-search&amp;start=0&amp;start=0&amp;ie=utf-8&amp;oe=utf-8">http://www.google.com/search?q=nasm+syntax+intel+site%3Auiuc.edu&amp;sourceid=mozilla-search&amp;start=0&amp;start=0&amp;ie=utf-8&amp;oe=utf-8</a><br /><br /><br /><br /><a target="_blank" href="http://courses.ece.uiuc.edu/ece291/archive/mp/f99/mp5/dev_env.html">http://courses.ece.uiuc.edu/ece291/archive/mp/f99/mp5/dev_env.html</a><br /><br /><br /><br />NASM is the Netwide Assembler, a free, portable assembler for the Intel 80x86 microprocessor series, which uses the traditional Intel instruction mnemonics and syntax<br /><br />--------------------------------------------------------------------------------------------------<br /><br /><br /><br />:) but any way i?m fucking for syntax i just like logic .</div>
    <div class="meta">Posted on 2004-01-28 08:32:07 by Nguga</div>
   </div>
   <div class="post" id="post-131983">
    <div class="subject"><a href="#post-131983">Re: googling...</a></div>
    <div class="body"><div class="quote"><em>Originally posted by Nguga </em><br /><br />NASM is the Netwide Assembler, a free, portable assembler for the Intel 80x86 microprocessor series, which uses the traditional Intel instruction mnemonics and syntax<br /><br /></div><br /><br />Ah yes, I found it on the internet. It *must* be correct :-).<br /><br />To a lot of people, &quot;Intel Syntax&quot; may only mean that the assembler uses the same mnemonics and operand order as the original Intel ASM86 assembler. To those who've studied formal language design, however, a claim that some assembler follows &quot;Intel Syntax&quot; suggests that the assembler will process (without error) any source file that ASM86 could process (and, technically, no other source files). Today, there are no such assemblers in existence. MASM and TASM come close (though they are greatly extended beyond the original &quot;Intel Syntax&quot;). As Intel no longer provides an assembler or a definition for x86 assembly language, the term &quot;Intel Syntax&quot; no longer has any meaning in a technical sense. So it no longer makes any sense to use this term. As MASM is the defacto standard for x86 assembly language (and it is an actual extension of the original &quot;Intel Syntax&quot;), one could claim that &quot;MASM Syntax&quot; is synonymous with &quot;Intel Syntax&quot; in modern systems.  However, to make claims about products like NASM, FASM, Gas (with the &quot;.intel_syntax&quot; directive), etc., being &quot;Intel Syntax&quot; assemblers is ludicrous. That would suggest that they all accept the same source files and they do not.<br /><br />One might argue that &quot;Intel Syntax&quot; simply means that we use the same mnemonics and operand ordering. But why was the line drawn there? What about data declarations? What about segments? What about macros? What about equates? What about type checking (which was *definitely* a *big* component of the original &quot;Intel Syntax&quot;)? And what about those brackets? If you're going to ignore all these other elements of &quot;Intel Syntax&quot;, what makes the mnemonics and operand ordering so sacrosanct?<br /><br />If you get sloppy with your definition of what the term &quot;syntax&quot; means, you wind up with people like Rene Tournois claiming that &quot;RosAsm&quot; is an &quot;Intel Syntax&quot; assembler! Completely ludicrous!<br /><br />As &quot;Intel Syntax&quot; really no longer has any meaning, I think that the x86 programming community needs to move beyond this point and use terms like &quot;MASM syntax&quot; or &quot;NASM syntax&quot;. Such descriptions would be far more precise. As best I can tell, the insistence on the term &quot;Intel Syntax&quot;, as applied to many assemblers, is just a smoke screen to cover up failings in the design of the assembler under discussion.<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2004-01-28 09:54:09 by rhyde</div>
   </div>
   <div class="post" id="post-131984">
    <div class="subject"><a href="#post-131984">explaining register *mov&quot; easy way</a></div>
    <div class="body">Thank you, randall.hyde. You managed to explain it better than I have so far.<br /><br />I don't fully agree on &quot;Intel Syntax&quot; not having any meaning however. Intel still publishes articles and sourcecode using this syntax, and MASM/TASM can still assemble this code with little or no changes (as do various inline assemblers such as the VC++ one, and I believe also Borland C++ Builder). I used to write code that assembled in both MASM and TASM back in the old days anyway.<br /><br />That was my point anyway, Intel Syntax is a common subset of a group of (inline-) assemblers, and code written in this syntax can be used with little or no changes by these assemblers, and the syntax is well understood by a large group of programmers. So it still has meaning to me. And since assemblers such as NASM have a slightly different syntax, this can be confusing in communication and use, and code will have to be modified in order to work with these assemblers.</div>
    <div class="meta">Posted on 2004-01-28 10:18:14 by Henk-Jan</div>
   </div>
   <div class="post" id="post-132008">
    <div class="subject"><a href="#post-132008">explaining register *mov&quot; easy way</a></div>
    <div class="body">I pretty much agree with Randy's comments here, its been a very long time since anyone used the Intel assembler while MASM has maintained more or less the same syntax for many years.<br /><br />When you refer to NASM syntax, you know what it means as NASM uses square brackets around addresses which is simply different to the standard set by MASM.<br /><br />There is no reason why anyone cannot write an assembler that uses different names for mnemonics, a different operand order and invent its own keywords but if you want code to be understandable to something like about 95% of all assembler programmers in x86, you will continue to use something similar to MASM and TASM with its data size specifiers, the distinction between OFFSET and local variables and the usual set of operators that it as mainained for so many years.<br /><br />I generally agree with Randy's view about &quot;no red tape&quot; style assembler using this idea as a smoke screen for what they cannot do properly. Rather than hide behind nonsense like this, I do see the point of specialised tools selling their virtues, not their vices and if a lower level style of assembler allows the user to do specialised things that cannot be done in others, its an advantage.<br /><br />Regards,<br />http://www.asmcommunity.net/board/cryptmail.php?tauntspiders=in.your.face@nomail.for.you&amp;id=2f46ed9f24413347f14439b64bdc03fd</div>
    <div class="meta">Posted on 2004-01-28 17:10:54 by hutch--</div>
   </div>
   <div class="post" id="post-132009">
    <div class="subject"><a href="#post-132009">explaining register *mov&quot; easy way</a></div>
    <div class="body"><div class="quote">if you want code to be understandable to something like about 95% of all assembler programmers in x86, you will continue to use something similar to MASM and TASM with its data size specifiers</div><br /><br />Speaking of which... oddly enough some Intel docs adopted 'word' for 32 bit entities (as theoretically they should, on a 32 bit CPU, since officially a word is defined to be the largest addressible unit of the CPU, where a byte is the smallest addressible unit of the CPU), while MASM and many other assemblers maintained the old definition of 'word' (16 bit) for backward-compatibility. So sometimes it still gets confusing.</div>
    <div class="meta">Posted on 2004-01-28 17:27:34 by Henk-Jan</div>
   </div>
  </div>
 </body>
</html>