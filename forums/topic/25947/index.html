<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>error..error..and..error... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25947" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25947">error..error..and..error...</a></p>
   <div class="post" id="post-189138">
    <div class="subject"><a href="#post-189138">error..error..and..error...</a></div>
    <div class="body">im compiling a timer program to display the time required to execute a program<br />i tried to execute this file(time7.exe) but it has encountered an illegal instruction..<br />why does it happen?<br />i try to debug it using turbo debugger but to no avail...<br /><br />r there anything wrong with the code?? :shock:<br /><br />the error pop-up window reads:<br />16bit MS-DOS Subsystem<br />c:\WINNT\system32\cmd.exe - time7.exe<br />the NTVDM CPU has encountered an illegal instuction.<br />CS:015c IP:f31d OP:ff ff ff ff ff <br /><br />here i include the source code...<br /><br />LIBSEG&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;segment byte public &quot;LIB&quot;<br />		assume cs:LIBSEG , ds:LIBSEG<br /><br />	include	mac.inc<br />	includelib alib.lib<br />	extrn	word_to_dec_stdout:far<br />	extrn	dword_to_dec_stdout:far<br />	extrn	stdout_string:far<br />	extrn	quad_multiply1:far<br />	extrn	quad_divide:far<br />		<br />timer_low	equ	046ch<br />timer_mode	equ	43h<br />timer0		equ	40h<br /><br />;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -(&nbsp; TIME&nbsp; &nbsp;)<br /><br />start:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call&nbsp; calibrate_timer<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call&nbsp; start_timer<br /><br />	&nbsp; &nbsp;call CHECK_DOS_MEMORY&nbsp; ; program to be evaluated time<br />	&nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call&nbsp; read_timer<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call&nbsp; convert_timer<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;call&nbsp; display_timer<br /><br />public	CHECK_DOS_MEMORY<br />CHECK_DOS_MEMORY	proc	far<br />	push	cx<br />&nbsp; &nbsp; &nbsp; &nbsp; sub&nbsp; &nbsp; &nbsp;bx,bx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;es,bx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;bx,es:[413h]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;get mem. size in 1k blocks<br />&nbsp; &nbsp; &nbsp; &nbsp; mov	cl,6<br />&nbsp; &nbsp; &nbsp; &nbsp; shl	bx,cl<br />;<br />; compute our final program location in paragraphs<br />;&nbsp; ax = our final offset<br />;<br />&nbsp; &nbsp; &nbsp; &nbsp; mov	cx,bx<br />&nbsp; &nbsp; &nbsp; &nbsp; sub	cx,ax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov	ax,cx<br />&nbsp; &nbsp; &nbsp; &nbsp; pop	cx<br />	retf<br />CHECK_DOS_MEMORY	endp<br />	<br />	<br />	public	start_timer<br />start_timer	proc	far<br />	apush	ax,dx,ds<br />	pushf<br />	cli<br />;<br />; initialize the 8253 to count down max count of 65536 by setting zero<br />;<br />	mov	al,00110100b		;select mode<br />	out	timer_mode,al		;request mode<br />	call	delay<br />	sub	ax,ax			;starting count<br />	out	timer0,al<br />	call	delay<br />	out	timer0,al<br />;<br />; wait for timer tick before starting<br />;<br />	sti<br />	call	delay<br />	in	al,timer0<br />	mov	ah,al<br />twait:	call	delay<br />	in	al,timer0<br />	cmp	al,ah<br />	je	twait<br />	call	delay<br />;<br />;wait for interrupt<br />;<br />	sub	dx,dx<br />	mov	ds,dx			;point at seg 0<br />	mov	dx,word ptr ds:<br />ilop:	mov	ax,word ptr ds:<br />	cmp	ax,dx<br />	je	ilop<br />;<br />; restart the timer back at count of zero again.<br />;<br />	mov	al,00110100b		;select mode<br />	out	timer_mode,al		;request mode<br />	call	delay<br />	sub	ax,ax			;starting count<br />	out	timer0,al<br />	call	delay<br />	out	timer0,al<br />;<br />; get the current bios time of day<br />;<br />	mov	ax,word ptr ds:<br />	mov	cs:interrupt_count,ax<br />	popf<br />	apop	ds,dx,ax<br />	retf<br />start_timer	endp<br /><br />delay:	jmp	d1<br />d1:	jmp	d2<br />d2:	jmp	d3<br />d3:	jmp	d4<br />d4:	ret<br /><br /><br />	public	read_timer<br />read_timer	proc	far<br />	apush	ds,es<br />	pushf<br />	cli<br />	mov	ax,cs<br />	mov	ds,ax<br />	xor	ax,ax<br />	mov	es,ax<br />;<br />; stop timer by setting mode to zero<br />;<br />	out	timer_mode,al	;timer interrupts off<br />	call	delay<br />	in	al,timer0<br />	call	delay<br />	mov	ah,al<br />	in	al,timer0<br />	xchg	ah,al<br />	neg	ax<br />	mov	timer_count,ax	;ax now has 16 bit timer count<br />;<br />; read interrupt count from bios<br />;<br />	mov	ax,es:<br />	sub	ax,interrupt_count<br />	mov	interrupt_count,ax<br />;<br />; restart the timer by resetting default value of control word<br />;<br />	mov	al,00110110b	;binary,mode 3,timer 0<br />	out	timer_mode,al<br />	mov	al,0<br />	call	delay<br />	out	timer0,al<br />	call	delay<br />	out	timer0,al<br />;<br />; return values to caller<br />;<br />	mov	ax,timer_count<br />	mov	dx,interrupt_count<br /><br />	sub	ax,calibrate<br />	sbb	dx,0			;calibrate timer value<br />	popf<br />exit:	apop	es,ds<br />	retf<br />read_timer	endp<br /><br />	public	CONVERT_TIMER<br />CONVERT_TIMER	proc	far<br />	apush	si,ds<br />	mov	si,cs<br />	mov	ds,si<br /><br />	mov	cx,word ptr timer_convert+2<br />	mov	bx,word ptr timer_convert<br />	call	quad_multiply1		;result to dx,cx,bx,ax<br />	mov	si,word ptr hundred_thousand+2<br />	mov	di,word ptr hundred_thousand<br />	call	quad_divide		;result dx,ax&nbsp; remainder cx,bx<br /><br />;<br />; dx,ax now contains the total number of micro seconds, cx,bx = remainder<br />;<br />	cmp	cx,1<br />	je	round_up<br />	cmp	bx,0c350h		;(100000/2)<br />	jb	compute_seconds<br />round_up:<br />	add	ax,1<br />	adc	dx,0			;round up 1<br /><br />compute_seconds:<br />	mov	bx,dx<br />	xor	dx,dx<br />	xor	cx,cx<br />	mov	si,word ptr million+2<br />	mov	di,word ptr million<br />	call	quad_divide		;compute seconds &amp; microseconds<br />;<br />; dx,ax = seconds&nbsp; &nbsp;cx,bx = microseconds<br />;<br />	apop	ds,si<br />	retf		<br /><br />CONVERT_TIMER	endp<br /><br />	public	display_timer<br />DISPLAY_TIMER	proc	far<br />	apush	si,ds<br /><br />	mov	si,cs<br />	mov	ds,si<br />	mov	seconds,ax<br />	mov	word ptr microseconds+2,cx<br />	mov	word ptr microseconds,bx<br /><br />	mov	si,offset msg1<br />	call	stdout_string			;display &#39;Elapsed time =&quot;<br />	<br />	mov	ax,seconds<br />	call	word_to_dec_stdout		;seconds<br />	mov	si,offset message_sec<br />	call	stdout_string<br />	<br />	mov	ax,word ptr microseconds<br />	mov	dx,word ptr microseconds+2<br />	call	dword_to_dec_stdout<br />	mov	si,offset message_micro<br />	call	stdout_string<br />	apop	ds,si<br />	retf<br />DISPLAY_TIMER	endp<br />	<br />public	calibrate_timer<br />calibrate_timer	proc	far<br />	apush	ax,bx,cx,dx<br />	mov	cs:calibrate,0<br />	mov	cs:seconds,0<br />	mov	cx,8<br />ct_lp1:	push	cx<br />&nbsp; &nbsp; &nbsp; &nbsp;	call	start_timer<br />	call	read_timer<br />	add	cs:seconds,ax<br />	pop	cx<br />	loop	ct_lp1<br /><br />	mov	ax,cs:seconds<br />	mov	cl,3<br />	shr	ax,cl<br />	mov	cs:calibrate,ax<br />	<br />	mov	cx,5000<br />ct_lp:	call	delay<br />	loop	ct_lp<br />	apop	dx,cx,bx,ax<br />	retf<br />calibrate_timer	endp<br />;--------------------------------------------------------------------------<br /><br />timer_count	dw	0	;read from 8253<br />interrupt_count	dw	0	;read from BIOS<br /><br />microseconds	dd	0	;total microseconds<br />seconds		dw	0	;total seconds<br /><br />calibrate	dw	0	;calibration factor from read_timer<br /><br />timer_convert	dd	83809	;838.096 nsec per tick<br />hundred_thousand dd	100000<br />million		dd	1000000<br /><br />msg1		db	0dh,0ah,0dh,0ah,&#39;Elapsed time = &#39;,0<br />message_sec	db	&#39; (seconds)&nbsp; &nbsp;&#39;,0<br />message_micro	db	&#39; (Micro seconds)&#39;,0dh,0ah,0<br /><br /><br />LIBSEG	ENDS<br />	end start<br /><br /></div>
    <div class="meta">Posted on 2007-05-09 01:30:25 by wogok</div>
   </div>
   <div class="post" id="post-189140">
    <div class="subject"><a href="#post-189140">Re: error..error..and..error...</a></div>
    <div class="body">Doesn&#39;t start: need some kind of exit? At the moment it just carries on into the CHECK_DOS_MEMORY proc, so who<br />knows where it will end up?</div>
    <div class="meta">Posted on 2007-05-09 01:40:36 by sinsi</div>
   </div>
   <div class="post" id="post-189141">
    <div class="subject"><a href="#post-189141">Re: error..error..and..error...</a></div>
    <div class="body">but i did put the end start right at the end of the code...<br /><br />jus below the LIBSEG ENDS...<br /><br />so...<br /><br /></div>
    <div class="meta">Posted on 2007-05-09 01:47:27 by wogok</div>
   </div>
   <div class="post" id="post-189142">
    <div class="subject"><a href="#post-189142">Re: error..error..and..error...</a></div>
    <div class="body">All &quot;end start&quot; does is tell the linker where the entry point is - you still need to exit to DOS<br /><pre><code><br />start:<br />&nbsp; ;blah blah blah<br />&nbsp; mov ah,4ch<br />&nbsp; int 21h<br /></code></pre></div>
    <div class="meta">Posted on 2007-05-09 02:15:17 by sinsi</div>
   </div>
   <div class="post" id="post-189143">
    <div class="subject"><a href="#post-189143">Re: error..error..and..error...</a></div>
    <div class="body">Dear Sinsi,<br /><br />thanks 4 the reply!! :D<br /><br />yaya..i had include it..and it realy works!!<br />now it has the time output display..<br /><br />actually this is the first time im using MASM!!<br />it took me 1week to learn all d basic stuff!! <br /><br />do u think this program can be use to measure RAM(memory) speed accurately?<br /><br /><br /></div>
    <div class="meta">Posted on 2007-05-09 02:34:01 by wogok</div>
   </div>
   <div class="post" id="post-189144">
    <div class="subject"><a href="#post-189144">Re: error..error..and..error...</a></div>
    <div class="body">I think that the clock only goes 1.19MHz whereas memory is in the nanosecond range, so...nope<br />Maybe someone can refute this?</div>
    <div class="meta">Posted on 2007-05-09 05:20:16 by sinsi</div>
   </div>
   <div class="post" id="post-189146">
    <div class="subject"><a href="#post-189146">Re: error..error..and..error...</a></div>
    <div class="body">This would probably work.<br /><br />;&nbsp; INT 15h,&nbsp; 86h (134)&nbsp; &nbsp; &nbsp; Wait&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XT-286, AT<br />;<br />;&nbsp; &nbsp; Waits a specified number of microseconds before returning control to<br />;&nbsp; &nbsp; the caller.<br />;<br />;&nbsp; &nbsp; &nbsp;  On entry:&nbsp; &nbsp; &nbsp; AH&nbsp; &nbsp; &nbsp; &nbsp;  86h<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CX:DX&nbsp; &nbsp; &nbsp; Number of microseconds to elapse<br />;<br />;&nbsp; &nbsp; &nbsp;  Returns:&nbsp; &nbsp; &nbsp;  Carry&nbsp; &nbsp; &nbsp; Set if error or wait in progress, else<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  cleared<br />;<br />;&nbsp; &nbsp; &nbsp;  Notes:&nbsp; &nbsp; &nbsp; &nbsp;  This service is not available for the PC, PCjr, and<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the XT.<br />;<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The real-time clock is used to count the number of<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; microseconds.<br />;<br />;&nbsp; &nbsp; &nbsp; The granularity of the time is 976 microseconds. (1/1000 second)<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1,000,000 microseconds = 1 second<br /></div>
    <div class="meta">Posted on 2007-05-09 20:50:45 by skywalker</div>
   </div>
   <div class="post" id="post-189147">
    <div class="subject"><a href="#post-189147">Re: error..error..and..error...</a></div>
    <div class="body">Dear skywalker,<br /><br />i dont really catch the meaning... :shock:<br />mayb can u xplain a little bit more...<br /><br />anyway, thanks ya!!!&nbsp; :D</div>
    <div class="meta">Posted on 2007-05-09 21:03:00 by wogok</div>
   </div>
  </div>
 </body>
</html>