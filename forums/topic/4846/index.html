<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Newbie Program II - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4846" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=4846">Newbie Program II</a></p>
   <div class="post" id="post-34005">
    <div class="subject"><a href="#post-34005">Newbie Program II</a></div>
    <div class="body">Hi all,<br /><br />I'm about to plunge into my next program, and it's a bit more ambitious, and I have come to realize that I'm not really sure how to go about it.  Here's what I'm thinking, and I'd love it if any of you would point out things I could or should do differently.<br /><br />My next teach-myself-assembly program is a Win32 assembly port of the Unix wc command, which does word counts on a file.  I've written this program already in C, and am hoping to use that familiarity as I write it in assembly.  As I prepare to write, however, I notice that I'm thinking at a very high level, and am trying to code it that way.  I think it would be better if I could learn the &quot;right&quot; way to do it in assembler.  So, comments are welcome.<br /><br />Here's what I need to do:<br /><br />1. Get and parse the command line.  At first blush this seemed easy; GetCommandLine returns the command line.  But then I noticed that it returns the entire command line as a single string.  To break it into separate arguments, I need to split the string up on whitespace and quotes.  Ugh, that's a assembly programming challenge for me right off the bat.  I'm used to getting an array of pointers to the string, already split up.  Is there a proper way to do this in assembler, like make a <em>different</em> call of which I am not aware, or perhaps use some already written code?<br /><br />If I *do* write this from scratch, what's the best way to do it?  My thinking would be to have a dword buffer prepared to hold a list of pointers to each argument.  Next, I would scan through the string looking for dividing points--whitespace between arguments, and/or quotes.  Each bit of whitespace or quote character I would write a zero byte over the whitespace, and record the address of that chunk of string in my pointer buffer.  When I was done, I would write the number of pointers somewhere--possibly to the first dword in the buffer, which I would have reserved in advance.  Is this a sane and assemblylike approach?  One quick thought that worries me is the possibility that the buffer pointed to by GetCommandLine may not be intended to have me writing zeroes into it.  If so, I'll need to copy the string first.<br /><br />2. Once that's all done, I should have the filename.  I'll need to check to see if it exists (PathFileExists in Shlwapi.dll, right?) and then open it and read it.  What's the proper assembler way to do this in Win32?  Should I use CreateFile, or is there a simpler way?  (CreateFile, in C++ at least, is notoriously overcomplex.)<br /><br />3. Those are the two hard parts.  After that, it's just a matter of read a chunk and scan it; update totals and repeat until end of file.  Here my thinking is to simply scan for characters.  If the first character I get is alphanumeric, I count myself as being &quot;in a word&quot;.  If not, I'm outside a word.  I simply scan forward, looking at each byte looking for the other character type than I've already found.  Each time I toggle to &quot;in a word&quot; I increase the word count.  Each time I find \n while outside a word I increase the line count.  Each byte read I increase the byte count.  (Actually, I probably won't do that last one unless it's essentially free as a byproduct of my scanning loops, because functions exist that will get the file size anyway.)<br /><br />I know this is only barely a Win32 program :) but it'll go a long way towards helping me learn to think in assembler.<br /><br />Thoughts/ideas?<br /><br />Thanks!<br /><br />-Chalain</div>
    <div class="meta">Posted on 2002-04-18 23:11:21 by Chalain</div>
   </div>
   <div class="post" id="post-34006">
    <div class="subject"><a href="#post-34006">Newbie Program II</a></div>
    <div class="body">Chalain,<br /><br />To answer your question 1:<br /><br />You could use the routine included with Masm32 <br />Version7 GetCL, supplied in the Masm32\M32LIB<br />where you supply the the argument number and a <br />buffer for the returned argument.  Or the routine <br />I wrote can be run once at the beginning of a <br />program and can check for single quotes ' or <br />double quotes &quot; for literals, including a quoted <br />program name. I fixed this since the last time I <br />posted this routine.  The result is an array of <br />pointers to the command line arguments, cl_args.<br /><br />farrier<br /><br /><pre><code><br />.386                      ; forces 32 bit assembly<br />.model flat, stdcall		; memory model and calling convention<br />option casemap &#58;none	; case sensitive code<br /><br />include	\masm32\include\windows.inc	; always first<br />include	dbmacros.asm<br />include	\masm32\include\user32.inc		; system include<br />include	\masm32\include\kernel32.inc	; file next<br />include	\masm32\include\gdi32.inc<br /><br />includelib \masm32\lib\user32.lib			; matching system<br />includelib \masm32\lib\kernel32.lib		; libraries after that<br />includelib \masm32\lib\gdi32.lib<br /><br />get_cl		PROTO	STDCALL<br />pro_q		PROTO	STDCALL &#58;BYTE<br /><br />.data<br />ALIGN	4<br />err_msg		db	&quot;error in get_cl&quot;, 0<br />head_get_cl	db	&quot;GET_CL PROG&quot;, 0<br /><br />.data?<br />ALIGN	4<br />hInstance		dword	?<br />lpCmdLine	LPSTR		?				;address of command line string<br />end_of_cl		dword	?				;address of end of command line<br />len_cl			dword	?				;length of command line<br />num_args		dword	?				;numbers of cl arguments not counting program<br />cl_args		dword	80 dup	&#40;?&#41;	;addresses of up to 80 arguments<br /><br />.code<br />start&#58;<br />	invoke	GetModuleHandle, NULL<br />	mov		hInstance, eax<br />	call		get_cl<br />	.if &#40;eax != 0&#41;<br />		invoke	MessageBox, hInstance, addr err_msg, addr head_get_cl, MB_OK<br />	.else<br />		mov ebx, 0<br />		.while &#40;ebx &lt; num_args&#41;<br />			invoke MessageBox, hInstance, cl_args&#91;ebx * 4&#93;, addr head_get_cl, MB_OK<br />			inc ebx<br />		.endw<br />	.endif<br />	invoke	ExitProcess, 0<br /><br />get_cl	PROC	uses ebx edi esi<br /><br />;       Requires the following routines<br />;skip_sp         PROTO   STDCALL<br />;pro_q           PROTO   STDCALL &#58;BYTE<br />;       Requires the following data<br />;cl_args     dword   80 dup  &#40;?&#41;     ;addresses of up to 80 arguments<br />;end_of_cl   dword   ?               ;address of end of command line<br />;lpCmdLine	LPSTR   ?               ;address of command line string<br />;len_cl      dword   ?               ;length of command line<br />;num_args    dword   ?               ;numbers of cl arguments not counting program<br /><br />	invoke	GetCommandLine	; get the address of the command line<br />	mov	lpCmdLine, eax          ;store the address<br />	xor		al, al                  ;zero al<br />	mov	ecx, 10000           ;ecx will hold count down from 10000<br />	mov	edi, lpCmdLine          ;destination of scan in DI<br />	cld                         ;advance after each comparison<br />	repne	scasb               ;compare command line bytes to 0<br />	dec	edi<br />	mov	end_of_cl, edi         ;store add. of end of command line<br />	mov	eax, 10000           ;original count in ecx<br />	sub	eax, ecx             ;total length of command line including program<br />	mov	len_cl, eax             ;store total length of command line<br />	mov	ecx, eax<br />	mov	num_args, 0<br />	xor		ebx, ebx             ;pointer to array in cl_args<br />	mov	edi, lpCmdLine<br />skip_bl&#58;                            ;skip leading spaces<br />	cmp	byte ptr &#91;edi&#93;, ' '<br />	jne		check_q<br />	inc		edi<br />	jmp	skip_bl<br />;Check for ' or &quot; enclosing program name<br />check_q&#58;                            ;check for ' or &quot; enclosing program directory<br />	cmp	byte ptr &#91;edi&#93;, '&quot;'<br />	je		check_d<br />	cmp	byte ptr &#91;edi&#93;, &quot;'&quot;<br />	jne		check_a<br />check_s&#58;                            ;first non-blank char is '<br />	inc		edi<br />	cmp	edi, end_of_cl<br />	jne		@f<br />	mov	eax, 2<br />	jmp	iep<br />@@&#58;<br />	cmp	byte ptr &#91;edi&#93;, &quot;'&quot;     ;look for another '<br />	jne		check_s<br />skip_s_ag&#58;<br />	cmp	byte ptr &#91;edi&#93;, ' '<br />	jne		check_a<br />	inc		edi<br />	jmp	skip_s_ag<br />check_d&#58;                             ;first non-blank char is &quot;<br />	inc		edi<br />	cmp	edi, end_of_cl<br />	jne		@f<br />	mov	eax, 2<br />	jmp	iep<br />@@&#58;<br />	cmp	byte ptr &#91;edi&#93;, '&quot;'     ;look for another '<br />	jne		check_d<br />check_a&#58;                            ;check for a space before end of CL<br />	mov	al, ' '                 ;now check for a ' ' space<br />;        mov edi, lpCmdLine<br />	repne	scasb<br />	jecxz	no_args             ;if ECX is 0, no args<br />pro_arg&#58;<br />;	call	skip_sp         ;skip all extra spaces, edi returns pointing<br />                                    ;to first non-space after program<br />	cmp	byte ptr &#91;edi&#93;, ' '<br />	jne		@f<br />	inc		edi<br />	jmp	pro_arg<br />;	mov	edi, ecx<br />@@&#58;<br />	cmp	byte ptr &#91;edi&#93;, 0       ;see if this is end of command line<br />	je		no_mo_args<br />	cmp	byte ptr &#91;edi&#93;, 34      ;is this next character a double quote &quot;<br />	jne		c_sq                    ;if not a dq check for a single quote<br />	push	34<br />	call	pro_q              ;process a double quote<br />	mov	edi, ecx<br />	mov	ebx, edx<br />	.IF &#40;eax == FALSE&#41;<br />		jmp	pro_ra<br />	.ENDIF<br />	jmp	pro_arg                 ;process another argument<br />c_sq&#58;<br />	cmp	byte ptr &#91;edi&#93;, 39      ;is this next character a single quote '<br />	jne		pro_ra                  ;if not a sq process regular argument<br />	push	39<br />	call	pro_q              ;process a single quote<br />	mov	edi, ecx<br />	mov	ebx, edx<br />	.IF &#40; eax == FALSE &#41;<br />		jmp	pro_ra<br />	.ENDIF<br />	jmp	pro_arg                 ;process another argument<br />pro_ra&#58;                             ;edi points to something other than<br />                                    ;0, ' '. '&quot;', &quot;'&quot;<br />	mov	&#91;cl_args + ebx&#93;, edi     ;beginning of first arg in cl_args<br />	inc		num_args<br />	add	ebx, 4               ;use ebx to point to next pointer in cl_args<br />	mov	al, ' '                 ;look for a space in the rest of the cl<br />	mov	ecx, end_of_cl<br />	sub	ecx, edi                ;number of bytes left to process<br />	repne	scasb                 ;scan for dq, 34, still in al<br />	jecxz	no_mo_args            ;jump if a space is not found<br />	mov	byte ptr &#91;edi - 1&#93;, 0<br />	jmp	pro_arg<br />no_mo_args&#58;<br />	mov	eax, 0<br />	cmp	num_args,   0<br />	je		no_args<br />;        call    disp_args<br />	jmp	iep<br />no_args&#58;<br />;        call    disp_no_args<br />	mov	eax, 0<br />iep&#58;<br />	ret<br />get_cl		ENDP<br /><br />pro_q		PROC  uses ebx edi esi, type_q&#58;BYTE<br />                                    ;edi points to an opening type_q quote<br />                                    ;scan to see if there is a matching type_q quote<br />                                    ;if not, consider it part of an arg<br />	push	edi                 ;store edi in case there is no match<br />	mov	ecx, end_of_cl<br />	sub	ecx, edi                ;number of bytes to process<br />	inc		edi                     ;point to next char<br />	mov	al, type_q<br />	repne	scasb                 ;scan for type_q, still in al<br />	jecxz	psq_ra              ;jump if type_q not found in rest of cl<br />	mov	byte ptr &#91;edi - 1&#93;, 0   ;replace second type_q with a 0 for end of string<br />	pop	esi                     ;pop address of first type_q<br />	mov	byte ptr &#91;esi&#93;, 0       ;replace first type_q with a 0<br />	inc		esi                     ;point to first non-type_q char<br />	mov	&#91;cl_args + ebx&#93;, esi    ;beginning of first arg in cl_args<br />	inc		num_args                ;we have another arg<br />	add	ebx, 4               ;use ebx to point to next pointer in cl_args<br />;       set edi to end of this arg!!!<br />	mov	ecx, edi                ;return edi in ecx<br />	mov	edx, ebx<br />	mov	eax, TRUE            ;return TRUE<br />	jmp	get_out<br />psq_ra&#58;<br />	pop	ecx                     ;return edi in ecx<br />	mov	edx, ebx<br />	mov	eax, FALSE           ;second quote not found, process as a regular argument<br />get_out&#58;<br />	ret<br />pro_q		ENDP<br /><br />end	start<br /></code></pre></div>
    <div class="meta">Posted on 2002-04-18 23:51:52 by farrier</div>
   </div>
   <div class="post" id="post-34011">
    <div class="subject"><a href="#post-34011">Newbie Program II</a></div>
    <div class="body">It all sounds good to me... go do it, and come back when stumped :tongue: <br /><br />No seriously, heed to farrier's advice and make use of the masm32.lib.  Use his source if it helps, but my sugestion is to remember that your program is to have a single purpose, and maybe generic functions is overkill?? If params dont fit in the right order, simply output an Error.<br /><br />I also think it would be a good excersise in itself to have you parse the line itself for what you want (definitely alot of oportunity to practice the @@:, @F, and @B jumping (i know cause i wrote a parser for this same purpose once)).<br /><br />Also, before you jump into CreateFile (which is a correct API to use), look at Iczelions File mapping tutorial (Tuts are at the top of the main section).  You may find it would be better to file map instead (seeing some files might be quite large).<br /><br />Also, on a whole, i think this next project is a good one to tackle (seeing you have windows experience under the belt ~ this is why i suggest you write the parser your self, after all, asm algo's is what your really asking to learn)<br /><br />Best of luck..<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-04-19 01:26:57 by NaN</div>
   </div>
   <div class="post" id="post-34033">
    <div class="subject"><a href="#post-34033">Newbie Program II</a></div>
    <div class="body">If you want to go about commandline parsing manually (good excercise,<br />although the m32lib GetCL will save you some time), you probably shouldn't<br />write to the pointer returned by GetCommandLine. The argv-style pointer array<br />is a good approach, don't worry if it's &quot;assembly-like&quot; or not, it's about<br />suiting *your* needs. Note that commandline parsing can be tricky, there's<br />a bunch of different situations with spaces, quotes and stuff. While you're<br />testing your code, you should try running your app in a lot of different<br />ways (from a shell, double-clicking, dragging a file to the .exe, . . .).<br /><br />Don't bother checking if file exists before you open it. Especially not<br />using those ugly shell functions ;). Just CreateFile - if this fails, you<br />can GetLastError to see what the error was (or just abort saying there was<br />a problem opening the file, which should be sufficient). CreateFile isn't<br />overcomplex, it just offers a lot of flexibility. You don't need all this<br />flexibility most of the time though, so it would make sense writing a simple<br />&quot;openFile&quot; wrapper that takes fewer parameters and adds the extra parms.<br /><br />If you want, you could use Memory Mapped Files, that way you simply get a<br />pointer and can treat the file as if it was a memory buffer. There's a few<br />more API calls involved, but it's not hard to use, and you don't have to<br />do a block-based algorithm. Memory mapped files are somewhat slower than<br />&quot;raw&quot; IO (because they're backed via the PageFault mechanism), but the<br />advantage of simplified programming usually makes up for this performance<br />degradation. You might not even be able to notice the performance difference.<br /><br />Also, don't worry if this program isn't very &quot;win32ish&quot;, it's assembly<br />language you're out to learn :). This program will be more &quot;assembly&quot; than<br />iczelions tutorials, since icz' tuts are more focused on teaching the win32<br />api than assembly.<br /><br />Go for it :alright:</div>
    <div class="meta">Posted on 2002-04-19 07:51:32 by f0dder</div>
   </div>
   <div class="post" id="post-34047">
    <div class="subject"><a href="#post-34047">Newbie Program II</a></div>
    <div class="body">GetCL will do fine, but there's a small problem when you pass a lot of files to the program. In my PNG viewer (written in C but without libc so I had to write my own command line parser) I first used GetCL to get the PNG files specified in the command line of the program. However when you feed it a lot of files, the function crashes. That's why I wrote my own.<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-04-19 11:02:19 by Thomas</div>
   </div>
  </div>
 </body>
</html>