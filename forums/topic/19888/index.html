<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Fast 2D rectangle intersection test - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19888" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=19888">Fast 2D rectangle intersection test</a></p>
   <div class="post" id="post-152709">
    <div class="subject"><a href="#post-152709">Fast 2D rectangle intersection test</a></div>
    <div class="body">I showed you mine first - aint I a flirt?<br /><br /><pre><code><br />Coord2D struct<br />    X REAL4 ?<br />    Y REAL4 ?<br />Coord2D ends<br /><br />BB2D struct<br />    TopLeft         Coord2D &lt;?&gt;<br />    BottomRight Coord2D &lt;?&gt;<br />BB2D ends<br />;=============================================<br />;A very fast test for intersection of regular 2d rectangles<br />;=============================================<br />QUICK_DoTheseBB2DsIntersect proc pBB1, pBB2<br />    mov esi,pBB1<br />    mov edi,pBB2<br />    fld &#91;esi&#93;.BB2D.TopLeft.X<br />    fcomp &#91;edi&#93;.BB2D.BottomRight.X<br />    __FJLE @F<br />    return FALSE<br />@@<br />    fld &#91;esi&#93;.BB2D.BottomRight.X<br />    fcomp &#91;edi&#93;.BB2D.TopLeft.X<br />    __FJGE @F<br />    return FALSE<br />@@&#58;<br />    fld &#91;esi&#93;.BB2D.BottomRight.Y<br />    fcomp &#91;edi&#93;.BB2D.TopLeft.Y<br />    __FJLE @F<br />    return FALSE<br />@@&#58;<br />    fld &#91;esi&#93;.BB2D.TopLeft.Y<br />    fcomp &#91;edi&#93;.BB2D.BottomRight.Y<br />    __FJGE @F<br />    return FALSE<br />@@&#58;<br />    return TRUE<br />QUICK_DoTheseBB2DsIntersect endp<br /></code></pre></div>
    <div class="meta">Posted on 2004-11-10 23:20:49 by Homer</div>
   </div>
   <div class="post" id="post-152735">
    <div class="subject"><a href="#post-152735">Fast 2D rectangle intersection test</a></div>
    <div class="body">I don't turn my head at everything with a pair of legs and the jumpy ones scare me, but I'm drinking tonight and who knows...<br /><br />Boolean returns should be in the carry flag, imho.  No jump is required for this algorithm. :)  Subtract and accumulate the negative signs - return the opposite of the sign in the carry flag.<br /><br />Maybe this code will work, or at the very least you can see what I mean:<pre><code>	push edi<br />	push esi<br />	mov edi, &#91;esp&#93;&#91;4*4&#93;<br />	mov esi, &#91;esp&#93;&#91;4*3&#93;<br /><br />	mov ecx, &#91;edi&#93;.BB2D.BottomRight.X<br />	sub ecx, &#91;esi&#93;.BB2D.TopLeft.X<br /><br />	mov eax, &#91;esi&#93;.BB2D.BottomRight.X<br />	sub eax, &#91;edi&#93;.BB2D.TopLeft.X<br /><br />	sub edx, &#91;edi&#93;.BB2D.TopLeft.Y<br />	mov edx, &#91;esi&#93;.BB2D.BottomRight.Y<br /><br />	or eax, ecx<br /><br />	mov ecx, &#91;esi&#93;.BB2D.TopLeft.Y<br />	sub ecx, &#91;edi&#93;.BB2D.BottomRight.Y<br /><br />	or eax, edx<br />	or eax, ecx<br />	shr eax, 31<br />	pop esi<br />	pop edi<br />	retn 4*2</code></pre>I image the SSE2 code would be a couple instructions. :)</div>
    <div class="meta">Posted on 2004-11-11 10:14:29 by bitRAKE</div>
   </div>
   <div class="post" id="post-152736">
    <div class="subject"><a href="#post-152736">Fast 2D rectangle intersection test</a></div>
    <div class="body">bitrake, maybe you can use the sign flag instead. then you won't do the shr at all, if i'm correct. it will save a clocktick :)</div>
    <div class="meta">Posted on 2004-11-11 11:15:10 by lifewire</div>
   </div>
   <div class="post" id="post-152737">
    <div class="subject"><a href="#post-152737">Fast 2D rectangle intersection test</a></div>
    <div class="body">1cycle * 60FPS * 1000 BB2D^2; yeah - good idea to use the sign flag.<br /><br />...* 1000 users * 50 hours; yeah - good idea to use the sign flag.<br /><br />...* 10 years; yeah - good idea to use the sign flag.<br /><br />Sorry, I forgot to reverse the bit to stick with the return type of the original code.</div>
    <div class="meta">Posted on 2004-11-11 11:34:55 by bitRAKE</div>
   </div>
   <div class="post" id="post-152752">
    <div class="subject"><a href="#post-152752">Fast 2D rectangle intersection test</a></div>
    <div class="body">I still think my version is preferable due to the early out at each test.<br />My version will return a boolean response with as few as one floating compare (one test).<br />Also, the structure declares the type as REAL4 - a simple integer subtraction won't yield a correct answer, but assuming the type was dword integer, your code is perfectly valid, just wants some tests of carry jumping to an early out ie jc/jnc tests.<br />I do see your point about using carryflag to hold replyvalue, but then my code wouldn't be C/C++ friendly anymore..</div>
    <div class="meta">Posted on 2004-11-11 21:45:25 by Homer</div>
   </div>
   <div class="post" id="post-152755">
    <div class="subject"><a href="#post-152755">Fast 2D rectangle intersection test</a></div>
    <div class="body">The same technique works with REAL4 (code is just an example).  Yeah, the unpredicted early out takes more time than whole routine. :roll: :lol: (assuming the data within a single cacheline) True, C/C++ friendly is not a goal of mine.</div>
    <div class="meta">Posted on 2004-11-11 22:08:23 by bitRAKE</div>
   </div>
   <div class="post" id="post-152756">
    <div class="subject"><a href="#post-152756">Fast 2D rectangle intersection test</a></div>
    <div class="body">Could you elaborate on &quot;unpredicted early out takes more time than the whole routine&quot; please?<br /><br />You mean by exiting the procedure early, it actually takes more cpu time to execute than performing unnecessary math does?</div>
    <div class="meta">Posted on 2004-11-11 22:36:56 by Homer</div>
   </div>
   <div class="post" id="post-152760">
    <div class="subject"><a href="#post-152760">Fast 2D rectangle intersection test</a></div>
    <div class="body">Sure it's faster to execute unbranching code, because the processor is built like a rocket car.  We flick the switch and it races down the road at <a target="_blank" href="http://www.landspeed.com/">763MPH</a> - kind of late to be thinking about steering!<br /><br />The start of the pipe does the prefeching of the instructions, but the processor will not know until the middle of the pipe (or later for Intel) if a branch is truely taken or not. Forward branches are not predicted as being taken the first time, and after that its predictablity is very hard for the processor to predict because of the nature of the algorithm. An unpredicted branch causes the processor to deploy the parachute. Like positioning rockets the processor has a few tricks to prevent the total clearing of the instruction pipe: prefetch all targets, calculate both paths.<br /><br />Every optimization text I've ever read (including the manuals) advocated the exchange of branches with code if possible. From the AMD manual, &quot;Predicted-taken branches incur only a single-cycle delay to redirect the instruction fetcher to the target instruction. In the event of a mispredict, the minimum penalty is ten cycles.&quot; The maximum is much higher!<br /><br />*I'm speaking of conditional branching throughout the above.<br /><br />Another example is my checkers engine - it is faster for it to evaluate all the moves than to exclude duplicate moves with a hash table (below a few ply).  Which is contrary to everything published on the matter (because they use some conceptual theory based on ply approaching infinity - checkers games are much shorter :)).</div>
    <div class="meta">Posted on 2004-11-11 23:06:38 by bitRAKE</div>
   </div>
   <div class="post" id="post-152917">
    <div class="subject"><a href="#post-152917">Fast 2D rectangle intersection test</a></div>
    <div class="body">Tested both procs, and they proved wrong. (please, prove me wrong) I couldn't believe it, so I made a dozen of tests with different arguments. The last two conditional jumps should be exactly the opposite, and also the first two should not include the &quot;or equal&quot; statement. That's because usually we take this: if a rect at (0;0) with size 10x10 is next to a rect with the same dimensions but at position (10;0), they <strong> do not</strong> overlap. With Homer's code they would be thought to do so. bitRAKE's code didn't pass all tests, so I think it's not a solution. Comparing both negative floats with integer comparisonor subtraction leads to inverse-logic. <br />Anyway, here's my simple solution, that can be made in MMX/SSE/SSE2, I guess. No jumping here to confuse the conveyer :).Also, no calling/ret - for max speed. Preserve esi and edi if your code needs it. <br /><br /><pre><code><br />; First, a float compare macro, that behaves perfectly<br />; with negative values too<br /><br />;------&#91; support macro &#93;---------\<br />ufcomp macro var1,var2<br />	mov eax,var1<br />	mov ebx,var2<br />	mov ecx,eax<br />	and ecx,ebx<br />	sar ecx,31<br />	xor eax,ecx<br />	xor ebx,ecx<br />	cmp eax,ebx<br />endm<br />;--------------------------------/<br /><br />;------------&#91; example usage &#93;--------------------------------\<br />; after using this macro, you can use the Jxx as though you <br />; just compared two integer values <br /><br />;Example&#58;<br />f1 real4 -17.6<br />f2 real4 44.7<br /><br />ufcomp f1,f2<br />jle @F<br />	print &quot;f1 is bigger&quot;<br />@@&#58;<br />jne @F<br />	print &quot;f1 = f2&quot;<br />@@&#58;<br />jge @F<br />	print &quot;f1 is lower&quot;<br />@@&#58;<br /><br />The only problem is that 0.0 &gt; -0.0  ^^&quot;<br />;------------------------------------------------------------/<br /><br /><br />;-----------&#91; Rectangle intersection macro &#93;--------\<br />DoRectsIntersect macro r1,r2<br />	;push esi<br />	;push edi<br />	mov esi,r1<br />	mov edi,r2<br />	ufcomp &#91;esi&#93;.RECT.left,&#91;edi&#93;.RECT.right<br />	setge dl<br />	ufcomp &#91;esi&#93;.RECT.right,&#91;edi&#93;.RECT.left<br />	setle dh<br />	shl edx,16<br />	ufcomp &#91;esi&#93;.RECT.bottom,&#91;edi&#93;.RECT.top<br />	setle dl<br />	ufcomp &#91;esi&#93;.RECT.top,&#91;edi&#93;.RECT.bottom<br />	setge dh<br />	;pop edi<br />	test edx,edx<br />	;pop esi<br />endm<br /><br />;---------------------------------------------------/<br /><br />;----------&#91; example &#93;-----------------------------------------\<br />If EDX was zero, then the two rectangles intersect<br /><br />re1 RECT &lt;9.9,0.0,19.9,10.0&gt;<br />re2 RECT &lt;0.0,0.0,10.0,10.0&gt;<br /><br /> <br />	DoRectsIntersect offset re1,offset re2<br />	.if ZERO?<br />		print &quot;They Intersect!&quot;<br />	.endif<br /><br />; if you change the 9.9 to 10.0 , the rectangles won't intersect,<br />; so it works correctly &#58;&#41;. I tested this code thoroughly before<br />; posting, so you can use it safely ;&#41;<br /><br />;--------------------------------------------------------------/<br /><br /><br /><br /></code></pre><br /><br />Btw, I got interested in this topic in the moment it was posted, but I was delayed to reply partly because I had done one of the tests of my code wrong ^^&quot; Sorry for the delay, have fun :)<br /><br />btw, do you know a good 1:1 replacement of Notepad, with the same shortcut keys - because win2k's Notepad sucks to Win98's one - chops text in lines when copying to clipboard, and sometimes/often doesn't redraw correctly :|</div>
    <div class="meta">Posted on 2004-11-14 14:16:32 by Ultrano</div>
   </div>
   <div class="post" id="post-152920">
    <div class="subject"><a href="#post-152920">Fast 2D rectangle intersection test</a></div>
    <div class="body">Speed test:<br /><pre><code><br />invoke GetTickCount<br />	push eax<br />	<br />	mov ecx,1000000000<br />	@@&#58;<br />	push ecx<br />	DoRectsIntersect offset are1,offset are2<br />	;.if ZERO?<br />	;	print &quot;They Intersect! 7&quot;<br />	;.endif<br />	pop ecx<br />	dec ecx<br />	jnz @B<br />	<br />	invoke GetTickCount<br />	pop edx<br />	sub eax,edx<br />	print eax<br /></code></pre><br />On AthlonXP 2000+ , normal thread priority, this takes 14.4 seconds to execute (70 million intersections/sec)<br />If I change the &quot;dec ecx&quot; to &quot;dec dword ptr&quot; with the accompanying changes, it takes 12 seconds (83.3 mil tests/s)<br />Thus, the DoRectsIntersect code executes in less than 20 cycles, with 2+ instructions/cycle</div>
    <div class="meta">Posted on 2004-11-14 14:41:05 by Ultrano</div>
   </div>
   <div class="post" id="post-152950">
    <div class="subject"><a href="#post-152950">Fast 2D rectangle intersection test</a></div>
    <div class="body">In my current 2D OpenGL code,  it seems OpenGL inverts the Y axis so that 0,0 is in the bottom left screen corner, sorry  :oops:<br /><br />The 2D stuff is viewed as orthographic projection in a 3D environment.<br /><br />It's something I haven't been worried about too much yet (although it feels weird to draw bottom up lol) and I guess maybe there could be something wrong with my projection matrix ?<br /><br />hehehe :)<br /><br />Anyway thanks for showing interest, especially bitRake (you have opened my eyes somewhat, I've a very linear 8bit background)<br /><br />Ultrano, we are covering some common ground at this point in time, any input you have into the 2D aspects of my opengl dll would be appreciated :)</div>
    <div class="meta">Posted on 2004-11-14 22:49:03 by Homer</div>
   </div>
   <div class="post" id="post-152959">
    <div class="subject"><a href="#post-152959">Fast 2D rectangle intersection test</a></div>
    <div class="body">2D - my specialty I guess  :-D  lol . <br />In the ogl then my second macro should look like this:<br /><pre><code><br />DoRectsIntersect macro r1,r2<br />   ;push esi<br />   ;push edi<br />   mov esi,r1<br />   mov edi,r2<br />   ufcomp &#91;esi&#93;.RECT.left,&#91;edi&#93;.RECT.right<br />   setge dl<br />   ufcomp &#91;esi&#93;.RECT.right,&#91;edi&#93;.RECT.left<br />   setle dh<br />   shl edx,16<br />   ufcomp &#91;esi&#93;.RECT.bottom,&#91;edi&#93;.RECT.top<br />   setge dl<br />   ufcomp &#91;esi&#93;.RECT.top,&#91;edi&#93;.RECT.bottom<br />   setle dh<br />   ;pop edi<br />   test edx,edx<br />   ;pop esi<br />endm <br /></code></pre><br />Funny ogl :| . I remember it was a <strong>pain</strong> to draw a DIB of a virtual window that was resizable with scrollbar + it was a child of another virtual window but with top-down draw, and the DIB had many elements that depended on top-down drawing :( . Good now I use DDraw, so no such problems arise :-D<br />Looking at the code I currently develop, there's only a SetBounds function and something that isn't 2D-related but helps a lot in games - message queue. The SetBounds actually makes the Blt functions clip to a specified area - it is really fast, so you might not need any ogl code for that. The message queue is something like this:<br />invoke NewMessage,MSG_REMOVEINVULNERABILITY,150 <br />where 150 is the timeout in <em>animation</em> frames (with having 50 fps) after which this message will be launched and processed. For instance, this code is usually used after the player's shield gets broken, and he's been set to immortal. And this message makes sure this immortality is just temporary :) .</div>
    <div class="meta">Posted on 2004-11-15 03:17:36 by Ultrano</div>
   </div>
   <div class="post" id="post-153010">
    <div class="subject"><a href="#post-153010">Fast 2D rectangle intersection test</a></div>
    <div class="body">The message queue sounds interesting.. my current coding ethic is to create one or more object classes, then an &quot;object manager class&quot; for keeping collections of objects, it would certainly be useful for my objects to post messages to their manager and vice versa :) At the moment I use flags within the object instances to pass messages to/from the object manager instance...</div>
    <div class="meta">Posted on 2004-11-15 14:47:31 by Homer</div>
   </div>
   <div class="post" id="post-153089">
    <div class="subject"><a href="#post-153089">Fast 2D rectangle intersection test</a></div>
    <div class="body"><div class="quote">Speed test:<br /><pre><code><br />invoke GetTickCount<br />	push eax<br />	<br />	mov ecx,1000000000<br />	@@&#58;<br />	push ecx<br />	DoRectsIntersect offset are1,offset are2<br />	;.if ZERO?<br />	;	print &quot;They Intersect! 7&quot;<br />	;.endif<br />	pop ecx<br />	dec ecx<br />	jnz @B<br />	<br />	invoke GetTickCount<br />	pop edx<br />	sub eax,edx<br />	print eax<br /></code></pre><br />On AthlonXP 2000+ , normal thread priority, this takes 14.4 seconds to execute (70 million intersections/sec)<br />If I change the &quot;dec ecx&quot; to &quot;dec dword ptr&quot; with the accompanying changes, it takes 12 seconds (83.3 mil tests/s)<br />Thus, the DoRectsIntersect code executes in less than 20 cycles, with 2+ instructions/cycle</div><br /><br />  You made a slight mistake in your math.  12 seconds = 12*1000*1000*2000 ( 2000+ athlon) = 24000000000 cycles for the whole thing.  Divide that by 1 billion loops to get the average time in cycles for executing the code.<br /><br />24000000000 / 1000000000 = 24 cycles.  <br /><br /> Also I don't know how accurate it is to be using GetTickCount ( since it only has a resolution in the millisecond range) and then using that to see how many cycles it took to execute your code.  You should probably use RDTSC to get more accurate values.</div>
    <div class="meta">Posted on 2004-11-16 15:09:44 by mark_larson</div>
   </div>
   <div class="post" id="post-153093">
    <div class="subject"><a href="#post-153093">Fast 2D rectangle intersection test</a></div>
    <div class="body">The AthlonXP2000+ runs on 1.6GHz, not 2GHz. It's called 2000+ because it effectively runs almost all code as if it was an Intel on 2GHz or more :P . In this case you see the code runs as if it was a 3.7 GHz Celeron or PIII.  Though, I haven't made exactly this benchmark on my PIII and k6-2 or a Celeron, so I can be wrong with +-10%. <br />The millisecond mistake is just 0.08% , since this code takes 12-14 secs to execute :)<br />Btw, tested the proc with manually setting priority in TaskManager to realtime, produces only 300ms speedup ^^&quot;</div>
    <div class="meta">Posted on 2004-11-16 15:24:34 by Ultrano</div>
   </div>
   <div class="post" id="post-153104">
    <div class="subject"><a href="#post-153104">Fast 2D rectangle intersection test</a></div>
    <div class="body">The error in GetTickCount must be worse than that, I used it as the basis for my timing and found that it was &quot;jumpy&quot; even though the framerate was high.. after changing to high performance timer, the timing artifacts disappeared completely. <br />I do admit that I would have exaggerated the timing error within my math, but then so would any application requiring timing based on elapsed times...<br />I probably should write some benchmarking code myself :)</div>
    <div class="meta">Posted on 2004-11-16 19:57:22 by Homer</div>
   </div>
   <div class="post" id="post-153109">
    <div class="subject"><a href="#post-153109">Fast 2D rectangle intersection test</a></div>
    <div class="body"><div class="quote">The error in GetTickCount must be worse than that, I used it as the basis for my timing and found that it was &quot;jumpy&quot; even though the framerate was high.. after changing to high performance timer, the timing artifacts disappeared completely. <br />I do admit that I would have exaggerated the timing error within my math, but then so would any application requiring timing based on elapsed times...<br />I probably should write some benchmarking code myself :)</div><br /><br />  Yes it has more error that what Ultrano listed.  <br /><br />  Ultrano, look at it this way.  You are timing someting that runs in the &quot;cycle&quot; range of time using a timer that times events in the millisecond range of time.  There are 1,600,000 cycles in 1 millisecond, and your routine is supposedly running in 20 cycles.  See the problem?  Even if there was no error in GetTickCount you cannot possibly accurately time something that runs in around 20 cycles.  There just isn't enough accuracy.<br /><br />Ignoring loop overhead, here's a simple method.<br /><br /><pre><code><br />LOOP_CNT equ 10000000<br /><br /><br />xor  eax,eax<br />cpuid<br /><br />rdtsc<br />push edx<br />push eax<br /><br />mov ecx,LOOP_CNT<br />looper&#58;<br />push ecx<br /><br />;... put code to time here<br />call Whatever<br /><br />pop ecx<br />dec ecx<br />jnz looper<br /><br />rdtsc<br />pop ebx<br />sub eax,ebx<br />pop ecx<br />sbb edx,ecx<br /><br />mov ecx,LOOP_CNT<br />div ecx<br /><br />;EAX holds the number of cycles.  You can print that or convert to some other unit of time.<br /><br />;In my actual code I also subtract out the loop overhead to get a more accurate answer.  Adding that is easy.<br /></code></pre></div>
    <div class="meta">Posted on 2004-11-16 21:20:25 by mark_larson</div>
   </div>
  </div>
 </body>
</html>