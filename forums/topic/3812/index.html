<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>ole automation in asm??? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=3812" />
    <link rel="next" href="../?id=3812&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=116">Windows</a> &raquo; <a href="../?id=3812">ole automation in asm???</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=3812&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=3812&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="3812" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=3812&amp;page=2">&gt;</a><a href="../?id=3812&amp;page=2">&raquo;</a></form>   <div class="post" id="post-25753">
    <div class="subject"><a href="#post-25753">ole automation in asm???</a></div>
    <div class="body">Hello everyone,<br />I was given a vb proggie that reads data from a database end uses ole automation to print, through an ole server, some labels.<br />They asked me a complete rewrite of this program and as usual I've done everything in asm.<br />I've almost completed it, but i cannot figure out how to handle the ole routines. This is totally new to me!<br /><br />I've tried to search around (msdn included) but I didn't find any reference to automation api's, but objet programing for vb and c++.<br /><br />Can anyone help me or give me some hints about api based ole automation?<br /><br />The vb code uses functions like these:<br /><br />- Set OLE_Server = CreateObject(&quot;XXXXXXX.Application&quot;) <br />- OLE_Server.ActiveDocument.CopyToClipboard<br />- PrintLab = OLE_Server.ActiveDocument.PrintLabel(Num)<br />etc.<br /><br />Thanx a lot,<br />acab</div>
    <div class="meta">Posted on 2002-02-24 19:58:33 by acab</div>
   </div>
   <div class="post" id="post-25762">
    <div class="subject"><a href="#post-25762">ole automation in asm???</a></div>
    <div class="body">IN asm, it would be:<br /><br /><br /><pre><code><br />.data<br />pOLE_Server     DWORD    0<br />pszAppName     BYTE         &quot;XXXXXXX.Application&quot;, 0<br />pCLSID              DWORD    0<br />pActiveDoc        DWORD    0<br />IID_IOLE_Server         GUID   &lt;need to look this up for the interface you need&gt;<br />IID_IActiveDocument   GUID   &lt;this one too&gt;<br /><br />; you also need to define the vtable structure of the interfaces <br /><br />.code<br /><br />    invoke CLSIDFromProgID, ADDR pszAppName, ADDR pCLSID<br />    invoke CoGetClassObject, ADDR pCLSID, CLSCTX_SERVER, NULL,  \<br />                     ADDR IID_IOLE_Server, ADDR pOLE_Server<br />    mov edx, pOLE_Server<br />    mov edx, &#91;edx&#93;<br />    invoke &#91;edx&#93;.IOLE_Server.ActiveDocument, pOLE_Server, ADDR pActiveDoc<br />    mov edx, pActiveDoc<br />    mov edx, &#91;edx&#93;<br />    invoke &#91;edx&#93;.IActiveDocument.CopyToClipboard, pActiveDoc<br />    mov edx, pActiveDoc<br />    mov edx, &#91;edx&#93;<br />    invoke &#91;edx&#93;.IActiveDocument.Release, pActiveDoc<br /></code></pre> <br /><br />and so on....<br /><br />  It looks completely different because VB has been doing a lot of the messy COM details for you. For example, <br /><br /><pre><code><br />OLE_Server.ActiveDocument.CopyToClipboard <br /></code></pre><br /><br />  Really means &quot;call the ActiveDocument method of the OLE_Server interface, get another interface back, and use th new interface to call its CopyToClipboard method. Then release this new interface.&quot;<br /><br />You'll need to curl up with the best COM reference you can find, for C or C++ (C++ actually being easier to understand for COM), and make sure the reference doesn't use any MFC or ATL.  &quot;Inside COM&quot; is the best book on this I can recommend. &quot;Inside OLE&quot; (available online frrom MSDN) is acceptable, but not as directed as the first book. &quot;Automation Proggamers Reference&quot; is also handy, it used to be online, but I found it in the bookstores. It has some goodies about how VB does its COM stuff.<br /><br />I have some COM stuff on my website (link somewhere over there by my name), but it USES COM, doesn't teach the basics, or teach how to translate VB into COM into asm.<br /><br />You'll also find some macros and other goodies to make this easier on you (like a coinvoke macro to make a COM call all in one line).<br /><br />But it IS possible, even easy once you know the pattern.</div>
    <div class="meta">Posted on 2002-02-24 22:46:47 by Ernie</div>
   </div>
   <div class="post" id="post-25774">
    <div class="subject"><a href="#post-25774">ole automation in asm???</a></div>
    <div class="body">Hi Ernie,<br />thanx a lot for your replay and for your site as well.<br />I've downloaded your tutorials about com objects and I'm starting reading them.<br />About your code, I'm trying to understand it properly to port it to tasm, but firstly I've got to learn many things, including what the hell a vTable is...<br /><br />Phanx again,<br />acab</div>
    <div class="meta">Posted on 2002-02-25 03:41:07 by acab</div>
   </div>
   <div class="post" id="post-25776">
    <div class="subject"><a href="#post-25776">ole automation in asm???</a></div>
    <div class="body">I post you an example with some more basic assembler code.<br />There is only one macro, which is defined at begin. (the names of the VARIANT may differ from yours)<br /><br />The AutoWrap function does all the things to &quot;call&quot; the given OLE automation function for you. Parameters and return values are transfered via VARIANT data structures.<br /><br />(hope this text is not too long ...)<br /><pre><code><br />callother	MACRO	object, method<br />	mov	eax, object<br />	mov	eax, &#91;eax&#93;<br />	push	object<br />	call	method&#91;eax&#93;<br />	ENDM<br /><br />	.data<br /><br />hcomActive&#58;	dd	?<br />hcomDispatch&#58;	dd	?<br /><br />xResult	VARIANT	&lt;?&gt;<br />szActive&#58;	db	&quot;ActiveDocument&quot;, 0<br />szCopy&#58;	db	&quot;CopyToClipboard&quot;, 0<br /><br />clsidAppl	CLSID	&lt;?&gt;		; fill in your apps class id<br />idINull	GUID	&lt;0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0&gt;<br />idIDispatch	GUID	&lt;00020400h, 0, 0, 0C0h, 00, 00, 00, 00, 00, 00, 46h&gt;<br /><br /><br />	.code<br /><br />;----------------- start application<br /><br />	lea	eax, hcomDispatch<br />	lea	ebx, clsidAppl<br /><br />	xor	ecx, ecx<br />	push	eax<br />	push	offset idIDispatch<br />	push	CLSCTX_LOCAL_SERVER<br />	push	ecx<br />	push	ebx<br />	call	CoCreateInstance<br />	cmp	eax, S_OK<br />	jne	ippDone<br /><br /><br />;----------------- get active document object<br /><br />	lea	ecx, xResult<br />	mov	&#91;ecx.var_vt&#93;, VT_EMPTY<br /><br />	xor	eax, eax<br />	lea	ecx, xResult<br /><br />	push	eax<br />	push	eax<br />	push	offset szActive<br />	push	hcomDispatch<br />	push	ecx<br />	push	DISPATCH_PROPERTYGET<br />	call	AutoWrap<br />	test	eax, eax<br />	jne	ippClose<br /><br />	lea	ecx, xResult<br />	mov	eax, &#91;ecx.var_pdispVal&#93;<br />	mov	hcomActive, eax<br /><br /><br />;----------------- copy to clipboard<br /><br />	xor	eax, eax<br />	push	eax<br />	push	eax<br />	push	offset szCopy<br />	push	hcomActive<br />	push	ecx<br />	push	DISPATCH_METHOD<br />	call	AutoWrap<br />	test	eax, eax<br />	jne	ippClsPres<br /><br />	;; success<br /><br /><br />;----------------- free objects<br /><br />	callother	hcomActive, iunk_Release<br />	callother	hcomDispatch, iunk_Release<br /><br />	ret<br /><br /><br />;*********************************************************************<br />; does&#58;	find a named C++ method or attribute	and call it		*<br />; last update&#58;	08-05-2001 - Scholz			*<br />; parameters&#58;	dwError AutoWrap &#40;dwType, lpvResult, hObject, lpszName, dwArgs, lpxArgs&#41;	*<br />; returns&#58;	zero for ok, else errorcode			*<br />;*********************************************************************<br /><br />AutoWrap	PROC	dwType&#58;DWORD, lpvResult&#58;DWORD, hObject&#58;DWORD, lpszName&#58;DWORD, dwArgs&#58;DWORD, lpxArgs&#58;DWORD<br />	LOCAL	lpWide&#58;DWORD, idProp&#58;DWORD, lpxParams&#58;DWORD, dwPut&#58;DWORD<br /><br />	sub	esp, MAX_PATH<br />	mov	lpWide, esp<br />	sub	esp, sizeof DISPPARAMS<br />	mov	lpxParams, esp<br /><br />	mov	eax, hObject<br />	test	eax, eax<br />	je	auwParam<br /><br /><br />;----------------- convert name to unicode<br /><br />	push	MAX_PATH<br />	push	lpWide<br />	push	-1<br />	push	lpszName<br />	push	MB_PRECOMPOSED<br />	push	CP_ACP<br />	call	MultiByteToWideChar<br />	test	eax, eax<br />	je	auwError<br /><br /><br />;----------------- get id for the name<br /><br />	lea	eax, idProp<br />	lea	ecx, lpWide<br /><br />	push	eax<br />	push	LOCALE_USER_DEFAULT<br />	push	1<br />	push	ecx<br />	push	offset idINull<br />	callother	hObject, idisp_GetIDsOfNames<br /><br />	test	eax, eax<br />	jne	auwExit<br /><br /><br />;----------------- fill param struc<br /><br />	xor	edx, edx<br />	mov	ebx, lpxArgs<br />	mov	eax, lpxParams<br />	mov	ecx, dwArgs<br /><br />	mov	&#91;eax.dispp_cArgs&#93;, ecx<br />	mov	&#91;eax.dispp_rgvarg&#93;, ebx<br />	mov	&#91;eax.dispp_cNamedArgs&#93;, edx<br />	mov	&#91;eax.dispp_rgdispidNamedArgs&#93;, edx<br />	<br />	test	dwType, DISPATCH_PROPERTYPUT<br />	je	auwInvoke<br /><br />	lea	ecx, dwPut<br />	mov	dwPut, DISPID_PROPERTYPUT<br />	mov	&#91;eax.dispp_cNamedArgs&#93;, 1<br />	mov	&#91;eax.dispp_rgdispidNamedArgs&#93;, ecx<br /><br /><br />;----------------- invoke object<br /><br />auwInvoke&#58;	xor	eax, eax<br />	push	eax<br />	push	eax<br />	push	lpvResult<br />	push	lpxParams<br />	push	dwType<br />	push	LOCALE_USER_DEFAULT<br />	push	offset idINull<br />	push	idProp<br />	callother	hObject, idisp_Invoke<br /><br />	test	eax, eax<br />	jne	auwExit<br /><br />	xor	eax, eax<br />	jmp	auwExit    <br /><br /><br />;----------------- exit cases<br /><br />auwParam&#58;	mov	eax, E_INVALIDARG<br />	jmp	auwExit<br /><br />auwError&#58;	call	GetLastError<br /><br />auwExit&#58;	add	esp, sizeof DISPPARAMS<br />	add	esp, MAX_PATH<br />	ret<br /><br />AutoWrap	ENDP<br /></code></pre></div>
    <div class="meta">Posted on 2002-02-25 04:08:53 by beaster</div>
   </div>
   <div class="post" id="post-25793">
    <div class="subject"><a href="#post-25793">ole automation in asm???</a></div>
    <div class="body">Phanx a lot beaster,<br />your code is quite clear to me!<br />I'll try some coding tonight.<br />Bye for now,<br />acab</div>
    <div class="meta">Posted on 2002-02-25 09:26:08 by acab</div>
   </div>
   <div class="post" id="post-25975">
    <div class="subject"><a href="#post-25975">ole automation in asm???</a></div>
    <div class="body">A vtable (table of virtual functions) isn't so hard, it's just poorly named, since it xcomes from how C++ makes the members of a class.<br /> <br />Its just a table of function pointers, one pointer to each method of the class. They appear in the order the methods are declares, meaning the first method of the class has its pointer first, the 2nd 2nd, and so on.<br /><br />When you make an object from the class, a small blob of memory is declared to be the object. The class code knows the layout of the object since the class defined the object in its creation method. The user of the object gets the address location where part of it resides.<br /><br />Now, stored in that address location given for the object is another pointer, and that pointer is to the vtable. That is why every COM call shown above has the little two-step dance first:<br /><br /><pre><code><br />mov edx, pObject       ; gets the location of the object<br />mov edx, &#91;edx&#93;           ; gets the location of the vtable<br />call &#91;edx&#93;.InterfaceName.MethodName<br /></code></pre><br /><br />In MSM (I don't know nuthin about TASM), InterfaceName.MethodName would be a structure followed by an element of that structure. InterfaceName is the list of methods of the COM class you are using, MethodName is the name of the method. The compiler will change that to a simple number.<br /><br />Calling the first method would just &quot;call &quot; directly. Let's say for arguments sake you wish to execute the 2nd method of a class (or interface). That would compile down to this:<br /><br /><pre><code><br />mov edx, pObject       ; gets the location of the object<br />mov edx, &#91;edx&#93;           ; gets the location of the vtable<br />call &#91;edx + 4&#93;              ; which is 1 * SIZEOF DWORD<br /></code></pre><br /><br />Hope this helps. Good luck.</div>
    <div class="meta">Posted on 2002-02-26 08:34:45 by Ernie</div>
   </div>
   <div class="post" id="post-26040">
    <div class="subject"><a href="#post-26040">ole automation in asm???</a></div>
    <div class="body">Hello Masters,<br />I've studied the lesson, or at list the basis...<br />What I think I've learned is (please correct if I'm wrong!):<br /><br />- A COM server is registered inside the registry and associated to a univoque CLISID<br />I can get the CLSID of a server through CLSIDFromProgId which uses Unicode style strings.<br /><br />- A COM server exposes Interfaces identified each by its unique GUID<br />A minimal com implementation requires at least IUnknown an IDispatch.<br />BTW which is the GUID of IUnknown???<br /><br />- I can get a ppv to an Interface passing the Server CLSID and the Interface GUID to CoCreateInstance.<br /><br />- If I know nothing about a server I need to use its IDispatch interface.<br />So if I wanted to Set a Property I would nedd to:<br />Get the server CLSID<br />Get the ppv of its IDispatch (GUID={00020400-0000-0000-C000-000000000046})<br />Get the pointer to IDispatch::GetIDsOfName<br />Call GetIDsOfName passing the name of the property to set<br />Get the pointer to IDispatch::Invoke<br />Pass to Invoke the Member as returned from GetIDsOfName, an array of args together with the flag PROPERTY_GET<br /><br />Is everything ok?<br /><br />Thanks a lot<br />acab</div>
    <div class="meta">Posted on 2002-02-26 13:37:50 by acab</div>
   </div>
   <div class="post" id="post-26062">
    <div class="subject"><a href="#post-26062">ole automation in asm???</a></div>
    <div class="body">Correct me if I'm wrong but if I remember correctly IDispatch is not required in a COM object. It is however required in an OLE Automation COM object since they require a dual-interface  (so that VB and scripting languages can use them)<br /><br /><br />As for you problem here: I think it would be faster going through COM directly then using the IDispatch interface (it's just another layer to find the same stuff)<br /><br />I'm sure Ernie will correct any mistakes I've written here.<br /><br />Good luck.</div>
    <div class="meta">Posted on 2002-02-26 15:58:29 by Hiroshimator</div>
   </div>
   <div class="post" id="post-26075">
    <div class="subject"><a href="#post-26075">ole automation in asm???</a></div>
    <div class="body"><strong>To Ernie:</strong><br /><br />Sorry Ernie,<br />but I didn't notice your message at the time of my last post.<br />&quot;The little two-step dance&quot; is now perfectly clear to me (after reading your access.doc - tnx a lot) and the syntax you used is ok even from a tasm point of view (after all asm is always asm).<br />What I still don't understand is how do I reconstruct the vtable if this is not provided me by the author of the ole server.<br />Is there a simpler way other than going through IDispatch?<br />And this other way will still be valid after a version updrade of the server? It seems to me (correct me if i'm wrong) that if now I can &quot;call &quot; meaning &quot;call .ActiveDocument.Print&quot;, this won't be true any more after a version upgrade if the elements in the table are in the same position.<br /><br />Phanx again, you've been very helpful to me!<br /><br /><br /><strong>To Hiroshimator:</strong><br /><br /><div class="quote">I think it would be faster going through COM directly then using the IDispatch interface</div><br /><br />Do you mean using vtable?</div>
    <div class="meta">Posted on 2002-02-26 18:33:33 by acab</div>
   </div>
   <div class="post" id="post-26081">
    <div class="subject"><a href="#post-26081">ole automation in asm???</a></div>
    <div class="body">acab,<br /><br />  Excellent questions, I can see your really getting into this.<br /><br />  First off, understand that COM is first of all a communications standard, it defines how different blobs of code will talk to each other, no matter what language each blob is written in. Thats why VB can work with VC can work with Java can work with Delphi can work with...<br /><br />  Part of what is refered to as the COM 'contract' (meaning the mutual agreement how the communication is done) is once an interface is published, that interface shall not change. Ever!<br /><br />  This explains why you'll sometimes see SomeInterface and also SomeInterface2, where SomeInterface2 has everything SomeInterface has, plus a new method or two. The orgional interface is left alone, and a brand new interface is defined. <br /><br />Thus no code will break, old code uses the orgional interface, new code can take advantage of the newer methods. So you do not have to worry about some new version changing the vtable. The COM contract demands thou shall NOT change the vtable.<br /><br /><br /><br />  So let's look at the vtable for IUnknown, since another part of the COM contract states everything MUST inherite from IUnknown.<br /><br />  IUnknown has three member functions: QueryInterface, AddRef and Release. If I was to define this interface, I would do so as follows:<br /><br /><pre><code><br />IUnknown    STRUCT<br />    QueryInterface  DWORD   ?<br />    AddRef          DWORD   ?    <br />    Release         DWORD   ?<br />IUnknown    ENDS<br /></code></pre><br /><br />This establishes the relationship of the members of the vtable, each member is a DWORD away from the previous one. If any methods are added, they MUST be added to the end of this table (and they frequently are added, that is how an interface inherits from another interface).<br /><br />That will work fine, but is a little limited, we can do better if we want to use the MASM invoke macro to call a COM interface:<br /><br /><pre><code><br />QueryInterfaceProto           typedef proto &#58;DWORD, &#58;DWORD<br />AddRefProto                   typedef proto <br />ReleaseProto                  typedef proto <br /><br />pIUnknown_QueryInterface      typedef ptr  QueryInterfaceProto<br />pIUnknown_AddRef              typedef ptr  AddRefProto<br />pIUnknown_Release             typedef ptr  ReleaseProto<br /><br />IUnknown    STRUCT<br />    IUnknown_QueryInterface   pIUnknown_QueryInterface  ?<br />    IUnknown_AddRef           pIUnknown_AddRef          ?    <br />    IUnknown_Release          pIUnknown_Release         ?<br />IUnknown    ENDS<br /></code></pre><br /><br />wow... that's a lot in one piece. But it tells the compiler to expect a function pointer inside the vtable, and also gives it the count of parameters (which MASMs invoke needs, and will generate errors if you forget a parameter).<br /><br />Also, there is some name Decoration there, each member function has the interface name tacked on. This is what lets polymorphism work. Polymorphism is just a fancy word for two different interfaces with the same member method name. By adding the interface name like that, we're pretty much guarnteed unique method names every time.<br /><br />(The only exception is when two interfaces have the same name, which is actually legal, as COM only regognises the interface GUID, or REFID. You could use the REFID for a decoration, but it will make your code even more unreadable.)<br /><br />(Also, I've heard the way I define interfaces cannot be traced with a debugger. This never bothered me, as I don't use debuggers, if you do use one, you'll have to find out how this is done on your own.)<br /><br />If your Interfaces are defined like this then you can construct a fancy macro to do a lot of the work in calling a method, such as you will see in the coinvoke macro.<br /><br />The REFID for IUnknown is {000000000H, 00000H, 00000H, {0C0H, 000H, 000H, 000H, 000H, 000H, 000H, 046H}}. You'll find lots of those in my include files, hopefully they will translate to TASM without too much trouble.<br /><br />Interfaces are defined for the whole world thru type libraries. They are not eazy to read directly, but MSVC includes a viewer (OLE View). That will give you the layout of any interface on your computer. GUIDs, constants, and other goodies can also be learned from the type lib.<br /><br /><br />Additionally, MSDN documents the methods of an interface in vtable order, so if all else fails...<br /><br /><br />Also: My copy of MSDN states CLSIDFromProgID takes a lpszProgID, which is an ASCII zero terminated string. I would guess NT has a CLSIDFromProgIDW version that uses Unicode.<br /><br /><br /><br /><br /><br /><br />To Hiro:  <br /><br />Yes, the only interface a COM object is required to have is IUnknown. Mind you, thats a pretty useless object, as all it can do is say &quot;No, I don't do that.&quot; <br /><br />IDispatch is also known as the Automation interface, no prior knowedge of an interfaces vtable  is necessary if it inherits from IDispatch, it can be driven at runtime by method names alone.<br /><br />And yes, going directly to the vtable is much much faster then going thru IDispatch. An interface that inherits from IDispatch and has a vtable is known as a dual interface.<br /><br />I don't see anything to correct you on.   ;-)</div>
    <div class="meta">Posted on 2002-02-26 19:24:00 by Ernie</div>
   </div>
   <div class="post" id="post-26128">
    <div class="subject"><a href="#post-26128">ole automation in asm???</a></div>
    <div class="body">Hi Ernie,<br />tnx to this board (and to your dox too) COMinASM seems now quite unharmful.<br />I still need to go a little deep into coding, but my ten line tests seeem to have no problem.<br /><br /><div class="quote">Also: My copy of MSDN states CLSIDFromProgID takes a lpszProgID, which is an ASCII zero terminated string. I would guess NT has a CLSIDFromProgIDW version that uses Unicode. </div><br />This is what I thought as well, but in my tests I've found out that<br /><pre><code>OleServerName db 'Codesoft2.Application',0</code></pre><br />returns error 800401f3 (Invalid class string)<br />while<br /><pre><code>OleServerName db 'C',0,'o',0,'d',0,'e',0,'S',0,'o',0,'f',0,'t',0,'2',0,'.',0,'A',0,'p',0,'p',0,'l',0,'i',0,'c',0,'a',0,'t',0,'i',0,'o',0,'n',0,0,0</code></pre><br />works ok. And dunno why?!?!?!<br /><br />Thanx again for your help: hopefully I won't bother you for a while;)<br /><br />acab</div>
    <div class="meta">Posted on 2002-02-27 03:01:30 by acab</div>
   </div>
   <div class="post" id="post-26133">
    <div class="subject"><a href="#post-26133">ole automation in asm???</a></div>
    <div class="body">in the second example you effectively define it as unicode :)<br /><br />unicode is just that after all: a word/char</div>
    <div class="meta">Posted on 2002-02-27 03:54:58 by Hiroshimator</div>
   </div>
   <div class="post" id="post-26146">
    <div class="subject"><a href="#post-26146">ole automation in asm???</a></div>
    <div class="body">Hi there, sorry for bothering again!!!!!<br />I've still got some problems...<br /><br />I've got an Interface named &quot;IApplication&quot; that exposes a few properties and methods.<br />For testing purposes I'm just interested in two of them: the property &quot;Visible&quot; that wants 1 bool arg and is supposed to show/hide the server and the method &quot;Quit&quot; that shoud shutdown the server and that needs no args.<br /><br />I firstly tried changing the Application.Visible to TRUE (the server hides itself by default) but my code crashes.<br />The property &quot;Visible&quot; is ID#01 so it shoud be the first entry in the vtrable.<br /><br /><pre><code><br />mov edx, dword ptr &#91;ppvIApplication&#93;<br />mov eax, dword ptr &#91;edx&#93;<br />push TRUE<br />push edx<br />call &#91;eax&#93;<br /></code></pre><br /><br />This gives me a prot fault in ole32...<br />I thought this was caused by an incorrect method of setting a property (your samples only explains methods). Are you so kind to expain how to get/set a Property?<br />So I've tried with Application.Quit mehod that have ID#17h<br /><br /><pre><code><br />mov edx, dword ptr &#91;ppvIApplication&#93;<br />mov eax, dword ptr &#91;edx&#93;<br />push TRUE<br />push edx<br />call &#91;eax+&#40;16h*4&#41;&#93;<br /></code></pre><br /><br />This time no crash and the call returns eax=0 but if I hit Ctrl-Atl-Del I can see the program's still running...<br /><br />What am I doing wrong this time?????<br /><br />Thanks again<br />acab</div>
    <div class="meta">Posted on 2002-02-27 07:30:11 by acab</div>
   </div>
   <div class="post" id="post-26148">
    <div class="subject"><a href="#post-26148">ole automation in asm???</a></div>
    <div class="body">did you call Release on the interface?<br /><br />Also about the TRUE: if you observe VB, you'll see that true translates there to -1 (FFFF), I think true here is defined as 1.<br /><br />This might be a problem if it's not expecting it :/</div>
    <div class="meta">Posted on 2002-02-27 07:52:53 by Hiroshimator</div>
   </div>
   <div class="post" id="post-26149">
    <div class="subject"><a href="#post-26149">ole automation in asm???</a></div>
    <div class="body">acab,<br /><br />the dispid of a property has nothing to do with the position in the vtable.<br /><br />If IApplication inherits from IDispatch (which I assume), you can set a property with<br /><br /><pre><code><br />local variant&#58;VARIANT<br />local disp&#58;DISPPARAMS<br /><br />   mov variant.vt,VT_I4       ; I assume property is &quot;integer&quot;<br />   mov eax,y                        ;&lt;- new value of property<br />   mov variant.lVal,eax<br />  <br />  lea eax,variant<br />  mov disp.rgvarg,eax<br />  mov disp.rgdispidNamedArgs,NULL<br />  mov disp.cArgs,1<br />  mov disp.cNamedArgs,0<br /><br />  coinvoke pIapplication,IApplication,Invoke_,\<br />           DISPID_xxx, addr IID_NULL, LOCALE_USER_DEFAULT,\<br />           DISPATCH_PROPERTYSET,addr disp,NULL,NULL,NULL<br /></code></pre><br /><br />But check structure DISPPARAMS first. There exist some with wrong format. It should be<br /><br /><pre><code><br />DISPPARAMS struct<br />rgvarg	LPVARIANT ?<br />rgdispidNamedArgs   LPDISPID ?<br />cArgs	 DWORD ?<br />cNamedArgs	 DWORD ?<br />DISPPARAMS ends<br /></code></pre><br /><br /><br />japheth</div>
    <div class="meta">Posted on 2002-02-27 08:12:51 by japheth</div>
   </div>
   <div class="post" id="post-26168">
    <div class="subject"><a href="#post-26168">ole automation in asm???</a></div>
    <div class="body">Ok, I think I'm missing something!<br /><br />I'll start from the beginning, please correct me<br /><br />1) First I need to get the server's CLSID<br />This can be done through CLSIDFromProgID api.<br />And this is ok.<br /><br />2) Then i need a ppv for IApplication:<br />to do this I can use CoCreateInstance or CoGetClassObject.<br />Still dunno the difference however they both work perfectly.<br />The server is loaded and the ppv is returned.<br /><br />3) If i need to call a method i can do this via vtable:<br />mov edx, dword ptr <br />mov eax, dword ptr <br />push edx<br />call <br /><br />4) If i want to set a property I have to go through IDispatch.<br />Or at least i think this is the meaning of the previous post...<br /><br />5) When I've done with the ole server I need to call the Release method.<br />And that's another issue: browsing the IAppication interface with OleViewer I found out it doesn't expose any Release method.<br />Trying to call the Quit method doesn't work: the server process is still active in background.<br />Is there any other api i need to call to free the server process?!<br /><br />Thanx for your help</div>
    <div class="meta">Posted on 2002-02-27 09:44:28 by acab</div>
   </div>
   <div class="post" id="post-26175">
    <div class="subject"><a href="#post-26175">ole automation in asm???</a></div>
    <div class="body">whenever you create ANY COM interface, it calls AddRef. So whenever you wish to quit using an interface you call Release.<br /><br />EVERY interface has Release, since every interface inherits from IUnknown (which has only 3 methods: QueryInterface, AddRef, Release)<br /><br />When you clone a pointer it's usually best to call AddRef on it (don't forget the corresponding release, whenever you call AddRef, code a Release as well)<br /><br />properties usually have correspondent putPropertyName and getPropertyName methods, so they can be used via a vtable.</div>
    <div class="meta">Posted on 2002-02-27 10:12:46 by Hiroshimator</div>
   </div>
   <div class="post" id="post-26184">
    <div class="subject"><a href="#post-26184">ole automation in asm???</a></div>
    <div class="body">So if any com interface is inherited from IUnknown:<br /><pre><code><br />IUnknown STRUCT <br />IUnknown_QueryInterface DWORD ? <br />IUnknown_AddRef DWORD ? <br />IUnknown_Release DWORD ?<br />IUnknown ENDS<br /></code></pre><br /><br />and my IApplication interface exposes just 3 methods (methodA, methodB, methodC), its table should be:<br /><br /><pre><code><br />IApplication STRUCT<br />IApplication_QueryInterface DWORD ? <br />IApplication_AddRef DWORD ? <br />IApplication_Release DWORD ?<br />IApplication_MethodA DWORD ?<br />IApplication_MethodB DWORD ?<br />IApplication_MethodC DWORD ?<br />IApplication ENDS<br /></code></pre><br /><br />So that to call IApplication.MethodA I would do:<br /><br /><pre><code><br />call CoGetClassObject,....<br />mov edx, dword ptr &#91;ppvIApplication&#93;<br />mov eax, dword ptr &#91;edx&#93;<br />push edx<br />call &#91;eax+0ch&#93;<br /></code></pre><br /><br />Am I right?!<br /><br />BTW: does CoGetClassObject and CoCreateInstance internally call AddRef?<br /><br />Tnx for your patience</div>
    <div class="meta">Posted on 2002-02-27 10:53:47 by acab</div>
   </div>
   <div class="post" id="post-26343">
    <div class="subject"><a href="#post-26343">ole automation in asm???</a></div>
    <div class="body">I see a lot of points to cover here, let me hit some of them quick.<br /><br />Methods and properties are both actually methods. In VB, on may say an object exposes some properties, but it exposes each by two methods, a get method, and a put method. VB does this to keep things as simple as possible for the programmer.<br /><br />CoGetClassObject and CoCreateInstance are very similar, with CoGetClassObject being the more general of the two, as it can reach into other computers on a network to instance objects.<br /><br />Defining the correct vtable and parameters for each method is quite importaint. A mistake in either is a sure fire way to cause a GPF. If you can post (or email me direct) the program with the IApplication I'll peek at it and see what I can find to help define the interface (and then tell you how I found it out). If its a popular program, maybe I already have it.<br /><br />The ID_OF_THE_METHOD has no realation to the vtable order, so if &quot;call &quot; happens to work, it is by pure chance.<br /><br />You're making some really good mistakes now, you'll really learn some good stuff when you work thru them.<br /><br /><br /><br />&quot;If a fool would just persist in his folly, he would become wise.&quot;  <br />--William Blake</div>
    <div class="meta">Posted on 2002-02-27 22:13:21 by Ernie</div>
   </div>
   <div class="post" id="post-26414">
    <div class="subject"><a href="#post-26414">ole automation in asm???</a></div>
    <div class="body">Hi Ernie,<br />it seems I'm keeping on bothering you... :(<br /><br />But I keep on learning as well...<br /><br />1) You say:<br /><div class="quote">Defining the correct vtable and parameters for each method is quite importaint. A mistake in either is a sure fire way to cause a GPF. If you can post (or email me direct) the program with the IApplication I'll peek at it and see what I can find to help define the interface (and then tell you how I found it out). If its a popular program, maybe I already have it.</div><br /><br />I realized this through tens of GPF+Reboot...:(<br />The app is a little too big for my poor dialup (5 megs for the main exe + a dozen of libs - sh*tty VB crap)<br />Instead you colud explain me how to get a really usable vtable from any com app. I would be really glad if you'd do this:)<br />msdn only reports that the first 7 entries are those of IUnknown (3) and IDispatch (4) and my oleviewer just reports props and methos sorted by ID.<br /><br /><br />2) Now my tests are producing some results. Although I lack a right vtable and so I need to use IDispatch, I can now get ppv's of Interfaces, get properties and call Methods without any argument.<br />What I'm still trying (without success) is passing arguments to IDispatch::Invoke.<br />I think I've got the whole serie of 800xxxxx errors ;)<br />What I thing I'm doing wrong is filling in the various structures.<br />Here's a little piece of code, could you please check it?<br /><br /><pre><code><br /><br />; First the structures<br />; Tasm syntax here, sorry, but it's quite similar to masm<br /><br />; This is the DISPPARAMS struct<br />DISPPARAMS struc<br />rgvarg dd	?<br />rgdispidNamedArgs dd	?<br />cArgs dd	?<br />cNamedArgs dd	?<br />DISPPARAMS ends<br /><br />; This is the VARIANTARG struct<br />; Last field is defined as DWORD for my convenience<br />; &#40;tasm doesn't like unions&#41;<br />; I fix the clSize by hand inside the CODE section according to vt type<br />VARIANTARG struc<br />clSize dd	?<br />rpcReserved dd	?<br />vt dw	?<br />wReserved1 dw	?<br />wReserved2 dw	?<br />wReserved3 dw	?<br />vvariant dd	?<br />VARIANTARG ends<br /><br />VT_BOOL equ 11<br />VVT_TRUE	equ 0ffffh<br />DISPID_PROPERTYPUT equ -3 <br /><br />; Now the DATA section<br />; Tasm syntax again&#58; just subst &quot;offset&quot; with &quot;ADDR&quot;<br />vOneArg DISPPARAMS &lt;offset vVariant, offset vDispidPutProp, 1, 1&gt;<br />vDispidPutProp	dd	DISPID_PROPERTYPUT<br />vVariant	VARIANTARG &lt;&gt;<br />iidINull GUID &lt;0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0&gt;<br /><br />; The CODE section at last<br /><br />mov ebx, &#91;ppvIDispatch&#93;<br />mov ebp, &#91;ebx&#93;<br /><br />mov	&#91;vVariant.clSize&#93;, size VARIANTARG-2<br />; the last &quot;-2&quot; is required 'cause VT_BOOL uses a WORD value<br />mov	&#91;vVariant.rpcReserved&#93;, 0<br />mov	&#91;vVariant.vt&#93;, VT_BOOL<br />mov	&#91;vVariant.wReserved1&#93;, 0<br />mov	&#91;vVariant.wReserved2&#93;, 0<br />mov	&#91;vVariant.wReserved3&#93;, 0<br />mov	&#91;vVariant.vvariant&#93;, VVT_TRUE<br /><br />push	0<br />push	0<br />push	0<br />push	offset vOneArg<br />push	DISPATCH_PROPERTYPUT<br />push	LOCALE_USER_DEFAULT<br />push	offset iidINull<br />push	L OLE_VISIBLE ; This is the id of the &quot;Visible&quot; property<br />push	ebx<br />call	&#91;ebp+24&#93; ; = IDispatch&#58;&#58;Invoke<br /></code></pre><br /><br />Thanks a lot again<br />acab<br /><br />Bye for now; i'll keep on experimenting! Hope at last i'll get wise instead of crazy;)</div>
    <div class="meta">Posted on 2002-02-28 09:07:54 by acab</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=3812&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=3812&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="3812" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=3812&amp;page=2">&gt;</a><a href="../?id=3812&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>