<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Binary to Ascii - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=784" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=784">Binary to Ascii</a></p>
   <div class="post" id="post-4837">
    <div class="subject"><a href="#post-4837">Binary to Ascii</a></div>
    <div class="body">I have a small problem with converting my 16 Bit code to 32 bit. The code in question is converting a binary number to ascii, now this works O.K. in my original 16 bit code, but I can't get it to work in 32 bit. The problem seems to be when I divide by 10 i.e.<br /><br />     mov ecx,10<br />     div ecx<br /><br /> where in 32 bit assembler does the remainder finish up?     :confused:</div>
    <div class="meta">Posted on 2001-08-25 08:45:33 by Mel</div>
   </div>
   <div class="post" id="post-4839">
    <div class="subject"><a href="#post-4839">Binary to Ascii</a></div>
    <div class="body">in win 32 you don't need to use a routine inside your app.<br />You can use routines ready for this.<br />Look at wsprintf function on win32 Programmer's Reference.<br /><br />If you want you can always use your own routine but it must be adapted to 32bit registers.</div>
    <div class="meta">Posted on 2001-08-25 10:20:19 by Bit7</div>
   </div>
   <div class="post" id="post-4843">
    <div class="subject"><a href="#post-4843">remainder</a></div>
    <div class="body">the remainder is in edx. you should delete the contents of edx to make a division.<br /><br />NOP-erator</div>
    <div class="meta">Posted on 2001-08-25 11:43:15 by NOP-erator</div>
   </div>
   <div class="post" id="post-4848">
    <div class="subject"><a href="#post-4848">Binary to Ascii</a></div>
    <div class="body">Speaking of binary to ASCII, I've been looking for an excuse to post this. :) It does ths usual conversion and also inserts commas to make the result easier to read.<br /><br /><pre><code><br />; This function converts a binary DWORD to an ASCII string, inserting commas<br />; as needed. and places a sign in the last position. A - is used for negative<br />; numbers, and a space for positive numbers.<br />;<br />; Example code&#58;<br />;    ...<br />;    dtoae proto  &#58;dword, &#58;dword<br />;    ...<br />;          invoke dtoae, inputdw, addr outstring<br />;    ...<br />;<br />; The first parameter is the 32-bit value to be converted. The second<br />; parameter is the address of a string that will contain the result. A<br />; maximum of 15 characters will be returned in the edited, signed, null<br />; terminated string. Never allocate less than 4 bytes for the string,<br />; and use caution if reserving fewer than 15 bytes.<br />;<br />; EAX returns the length of the string, not including the null terminator.<br />; If you don't care about the sign, and/or if you want to eliminate the<br />; ending space character sign in positive numbers, use the following code<br />; after your INVOKE to terminate the string at the last digit&#58;<br />;<br />;    dec   eax<br />;    mov   outstring &#91;eax&#93;, 0<br />;<br />; Example results&#58;<br />;<br />; Source value      Result string<br />; ------------     --------------<br />;  -1234567890     1,234,567,890-<br />;        -1000             1,000-<br />;         -999               999-<br />;            0                 0 <br />;          123               123 <br />;        12345            12,345 <br />;       999999           999,999 <br />;      1000000         1,000,000 <br />;    111111111       111,111,111 <br />;   2000000000     2,000,000,000 <br />;<br />; standard proc startup<br />;<br />      .586                        <br />      .model flat, stdcall<br />      .code<br />dtoae proc   idwd&#58;dword, ostr&#58;dword<br />;<br />; get and check caller parm - save regs - setup buffer and loop 1<br />;<br />      push   edi                        ; save edi<br />      mov    edi, &#91;ostr&#93;                ; get pointer to result string<br />      mov    eax, idwd                  ; get input parm<br />      or     eax, eax                   ; test it<br />      jz     zxit                       ; if 0 quick exit<br />      push   esi                        ; save other caller regs<br />      push   edx                        ; .<br />      push   ecx                        ; .<br />      mov    byte ptr &#91;edi&#93;, ' '        ; clear result sign<br />      jns    @f                         ; if parm negative...<br />      mov    byte ptr &#91;edi&#93;, '-'        ;   minus result sign<br />      neg    eax                        ;   make parm positive<br />@@&#58;   inc    edi                        ; pointer +1<br />      mov    ecx, 3                     ; number of digits before comma<br />;<br />; loop 1 - divide parm by 10 - convert remainder to ascii character and<br />; place in string - place commas in string as needed -<br />; string is in reverse order when done<br />;<br />@@&#58;   xor    edx, edx                   ; clear for div<br />      div    k10                        ; divide parm by 10<br />      or     dl, 30h                    ; make remainder ascii digit<br />      mov    byte ptr &#91;edi&#93;, dl         ; save in string<br />      inc    edi                        ; pointer +1<br />      or     eax, eax                   ; are we done?<br />      jz     @f                         ; yes - exit loop<br />      dec    ecx                        ; digits before comma -1<br />      jnz    @b                         ; if comma needed...<br />      mov    byte ptr &#91;edi&#93;, ','        ;   save , in string<br />      inc    edi                        ;   pointer +1<br />      mov    ecx, 3                     ;   set digits before next comma<br />      jmp    @b                         ; continue loop<br />;<br />; get string length - terminate string - setup loop 2<br />;<br />@@&#58;   mov    ecx, edi                   ; point to end of string<br />      sub    ecx, &#91;ostr&#93;                ; compute string length<br />      push   ecx                        ; save it<br />      sar    ecx, 1                     ; compute loop count<br />      mov    byte ptr &#91;edi&#93;, 0          ; null terminate string<br />      dec    edi                        ; end pointer -1<br />      mov    esi, &#91;ostr&#93;                ; point to start of string<br />;<br />; loop 2 - flip the string - includes sign byte<br />;<br />@@&#58;   mov    al, byte ptr &#91;esi&#93;         ; get character from start of string<br />      mov    dl, byte ptr &#91;edi&#93;         ; get char from end<br />      mov    byte ptr &#91;esi&#93;, dl         ; put it in start<br />      mov    byte ptr &#91;edi&#93;, al         ; and put start character in end<br />      dec    ecx                        ; count -1<br />      jz     @f                         ; exit loop if done<br />      dec    edi                        ; end pointer -1<br />      inc    esi                        ; start pointer +1<br />      jmp    @b                         ; continue loop<br />;<br />; exit with string length &#40;less null&#41; in eax<br />;<br />@@&#58;   pop    eax                        ; get string length<br />      pop    ecx                        ; restore caller regs<br />      pop    edx                        ; .<br />      pop    esi                        ; .<br />      pop    edi                        ; .<br />      ret                               ; return to caller<br />;<br />; quick exit if called with 0<br />;<br />zxit&#58; mov    dword ptr &#91;edi&#93;, 00002030h ; quick move - zero space null null<br />      mov    eax, 2                     ; set string length<br />      pop    edi                        ; restore edi<br />      ret                               ; return to caller<br />;<br />align 4                                 ; align on dword<br />k10   dd     10                         ; constant for div<br />;<br />dtoae endp<br />end<br /></code></pre></div>
    <div class="meta">Posted on 2001-08-25 12:26:09 by S/390</div>
   </div>
   <div class="post" id="post-4873">
    <div class="subject"><a href="#post-4873">Binary to Ascii</a></div>
    <div class="body">Nice :)<br /><br />As well Mel, if your looking for more information in DIV in general, i posted a discussion on my web-site on just this issue (from the old message board, and i thought it was worth saving..)<br /><br />Anywho check it out if you think it could help...<br /><br /><a target="_blank" href="http://www.angelfire.com/scifi/win32asm/Disc_4.html">The Ins and Outs of DIV</a> <br /><br />Hope it helps...<br />:alright: <br />NaN</div>
    <div class="meta">Posted on 2001-08-25 16:12:58 by NaN</div>
   </div>
   <div class="post" id="post-4924">
    <div class="subject"><a href="#post-4924">Binary to ascii</a></div>
    <div class="body">Thanks everyone very helpful, seems like I already new the basics so it must be my code that's incorrect.<br />By the way has anyone used 'dwtoa' proc in the MASM32 library looks like this does the same thing, <br />Mel</div>
    <div class="meta">Posted on 2001-08-26 03:08:42 by Mel</div>
   </div>
  </div>
 </body>
</html>