<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Injecting SEH into program - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29123" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29123">Injecting SEH into program</a></p>
   <div class="post" id="post-205734">
    <div class="subject"><a href="#post-205734">Injecting SEH into program</a></div>
    <div class="body">I&#039;ve been experimenting with assembly SEH for a while, but one thing I do not understand is why my code below doesn&#039;t execute the injected SEH but instead the default in ntdll.<br />I&#039;ve got a simple ASM app name &quot;one.exe&quot; which doesn&#039;t implement any SEH by itself. I want to inject a SEH handler into this app so I can catch all necessary exceptions in a random code cave.<br />I thought this would be as easy as injecting the three-line SEH initializer, but when (purposely - mov ,1) causing an access violation exception, my exception handler isn&#039;t called. What did I do wrong?<br /><br /><strong>Code injected into code-cave and called by &quot;one.exe&quot;</strong><br /><pre><code>00401189 PUSH one.004011B0 ; se initializer<br />0040118E PUSH DWORD PTR FS:[0]<br />00401195 MOV DWORD PTR FS:[0],ESP<br />0040119C MOV EAX,0<br />004011A1 MOV BYTE PTR DS:,1 ; purposely cause exception to test<br />004011A4 RETN</code></pre><br /><br /><strong>Se-handler code also injected into &quot;one.exe&quot;</strong><br /><pre><code>004011B0 PUSH 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; /Style = MB_OK|MB_APPLMODAL;<br />004011B2 PUSH 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; |Title = NULL<br />004011B4 PUSH One.004030BF&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; |Text = &quot;Exception caught!&quot;<br />004011B9 PUSH DWORD PTR DS:[4030E8]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; |hOwner = NULL<br />004011BF CALL user32.MessageBoxA&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; \MessageBoxA<br />004011C4 RETN</code></pre></div>
    <div class="meta">Posted on 2008-08-09 13:02:08 by pn0k</div>
   </div>
   <div class="post" id="post-205738">
    <div class="subject"><a href="#post-205738">Re: Injecting SEH into program</a></div>
    <div class="body">I&#039;d love to help you, as the problem is very obvious, however I&#039;d like to hear your excuse for wanting to capture exceptions in a remote process before I do that, as it sounds to me a lot like you want to hook some SEH-based security / code obfuscation scheme (I&#039;m thinking you wanna crack something).</div>
    <div class="meta">Posted on 2008-08-10 20:05:08 by Homer</div>
   </div>
   <div class="post" id="post-205741">
    <div class="subject"><a href="#post-205741">Re: Injecting SEH into program</a></div>
    <div class="body"><div class="quote"><br />I&#039;d love to help you, as the problem is very obvious, however I&#039;d like to hear your excuse for wanting to capture exceptions in a remote process before I do that, as it sounds to me a lot like you want to hook some SEH-based security / code obfuscation scheme (I&#039;m thinking you wanna crack something).<br /></div><br /><br />I can assure you I am not cracking anything. All I&#039;m trying to do is to learn about SEH as close to the bone as possible. After all there is almost zero documentation on SEH beyond compiler specific variations - that is, no documentation on what happens behind the scenes. I&#039;ve been reading some papers written by people who have reversed their own compiler-specific SEH apps (which is what I am doing as well) to get the info. But as I&#039;m sure you know, nothing is as rewarding as discovering things yourself. &quot;one.exe&quot; is a simple ASM app that does nothing but display a window. I wrote it myself. I&#039;m trying to replicate the code MASM compiler produces when utilizing SEH.<br /><br />I&#039;d really appreciate your help Homer, if you&#039;d be so kind.</div>
    <div class="meta">Posted on 2008-08-11 04:34:23 by pn0k</div>
   </div>
   <div class="post" id="post-205742">
    <div class="subject"><a href="#post-205742">Re: Injecting SEH into program</a></div>
    <div class="body">I don&#039;t think you should be pushing the address of the SEH function into FS:[0]<br /><br />Take a look at Iczelion&#039;s PE Tutorial #2, which contains a simple exception handler...<br /><br />You should be pushing the address of a structure that becomes linked into the SEH handler chain - its a linkedlist of &#039;record&#039; structures. The structure is as follows (you can extend it)..<br /><br /><div class="quote"><br />SEH struct<br />PrevLink dd ?&nbsp; &nbsp; ; the address of the previous seh structure<br />CurrentHandler dd ?&nbsp; &nbsp; ; the address of the exception handler<br />SafeOffset dd ?&nbsp; &nbsp; ; The offset where it&#039;s safe to continue execution<br />PrevEsp dd ?&nbsp; &nbsp; &nbsp; ; the old value in esp<br />PrevEbp dd ?&nbsp; &nbsp; &nbsp;; The old value in ebp<br />SEH ends<br /><br /></div><br /><br />and Iczelion&#039;s example code to install the SEH is as follows:<br /><div class="quote"><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push fs:[0]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop seh.PrevLink<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov seh.CurrentHandler,offset SEHHandler<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov seh.SafeOffset,offset FinalExit<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lea eax,seh<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov fs:[0], eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov seh.PrevEsp,esp<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov seh.PrevEbp,ebp<br /></div><br />Why do all this? We do it so that RtlUnwind can walk the SEH record chain without falling over.<br />As you can see, the old SEH obtained from FS:[0] is stored in there before we point FS:[0] at the structure itself, creating the linkedlist I mentioned.. we also stow ebp and esp so they can be restored if/when the SEH is triggered, since we want those back at the very least.<br /><br />In his example, the main SEH handler is:<br /><div class="quote"><br />SEHHandler proc C uses edx pExcept:DWORD, pFrame:DWORD, pContext:DWORD, pDispatch:DWORD<br />&nbsp; &nbsp; mov edx,pFrame<br />&nbsp; &nbsp; assume edx:ptr SEH<br />&nbsp; &nbsp; mov eax,pContext<br />&nbsp; &nbsp; assume eax:ptr CONTEXT<br />&nbsp; &nbsp; push .SafeOffset<br />&nbsp; &nbsp; pop .regEip<br />&nbsp; &nbsp; push .PrevEsp<br />&nbsp; &nbsp; pop .regEsp<br />&nbsp; &nbsp; push .PrevEbp<br />&nbsp; &nbsp; pop .regEbp<br />&nbsp; &nbsp; mov ValidPE, FALSE<br />&nbsp; &nbsp; mov eax,ExceptionContinueExecution<br />&nbsp; &nbsp; ret<br />SEHHandler endp<br /></div><br />You can see there that when the exception occurs, we are passed a cpu CONTEXT structure, as well as the pointer to the SEH record where we safely stowed some registers earlier... here&#039;s our chance to restore those registers to nice safe values, and then we are returning the constant &#039;ExceptionContinueExecution&#039; (I think its NULL) which will let the cpu continue (using the values we just forced apon it) - notice that EIP now points to a label called &#039;FinalExit&#039;.. lets see that code.<br /><br />FinalExit:<br />(...some junk I cut)...<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push seh.PrevLink<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop fs:[0] <br />(..more junk..)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret<br /><br />We didn&#039;t really need to point EIP here, but in that example we had nothing better to do than leave the program, and before we do that, we better restore the SEH chain to normal.<br />I would suggest that your code would be at the FinalExit label, since you&#039;re not planning on doing much once your messagebox has fired...<br /></div>
    <div class="meta">Posted on 2008-08-11 06:15:06 by Homer</div>
   </div>
   <div class="post" id="post-205745">
    <div class="subject"><a href="#post-205745">Re: Injecting SEH into program</a></div>
    <div class="body"><div class="quote"><br />I don&#039;t think you should be pushing the address of the SEH function into FS:[0]</div><br /><br />Are you sure about that? All the articles I&#039;ve been reading consistently provide examples following the below code (and also the code I used in my example in the original post). <a target="_blank" href="http://www.microsoft.com/msj/0197/exception/exception.aspx">http://www.microsoft.com/msj/0197/exception/exception.aspx</a> describes very well how it all works.<br />According to <a target="_blank" href="http://win32assembly.online.fr/Exceptionhandling.html">http://win32assembly.online.fr/Exceptionhandling.html</a> we need to push an ERR structure (at least: DWORD Pointer-to next-ERR-structure, DWORD Pointer-to-own-exception-handler&quot;). By utilizing the two push and one mov instructions we are creating this struct on the stack and sending it to the thread information block.<br />The ERR struct contains a pointer to the next (previous) ERR struct, and therefore the system is able to walk the handler chain as you describe.<br /><br /><strong>Example taken directly from <a target="_blank" href="http://win32assembly.online.fr/Exceptionhandling.html">http://win32assembly.online.fr/Exceptionhandling.html</a></strong><br /><pre><code>Establishing a &quot;per-thread&quot; exception handler<br />So now we can see how easy it is to establish this type of exception handler:-<br /><br />Example<br />PUSH OFFSET HANDLER<br />PUSH FS:[0] ;address of next ERR structure<br />MOV FS:[0],ESP ;give FS:[0] the ERR address just made <br />...<br />...<br />...<br />POP FS:[0] ;restore next ERR structure to FS:[0] <br />ADD ESP,4h ;throw away rest of ERR structure <br />RET<br />;***********************<br />HANDLER:<br />...<br />... ;exception handler code goes here <br />...<br />MOV EAX,1 ;eax=1 go to next handler <br />RET 	; ;eax=0 reload context &amp; continue execution</code></pre></div>
    <div class="meta">Posted on 2008-08-11 08:41:35 by pn0k</div>
   </div>
   <div class="post" id="post-205746">
    <div class="subject"><a href="#post-205746">Re: Injecting SEH into program</a></div>
    <div class="body">OK, I see that, yes it should be ok.<br />Tell me, which process owns the memory that those strings are stored in?<br />Could it be that your SEH is actually firing - but then MessageBox is attempting to access illegal addresses (the strings) and causing the final exception handler to be invoked (in order to prevent a nested exception) ?<br /><br /></div>
    <div class="meta">Posted on 2008-08-11 09:42:38 by Homer</div>
   </div>
   <div class="post" id="post-205748">
    <div class="subject"><a href="#post-205748">Re: Injecting SEH into program</a></div>
    <div class="body"><div class="quote"><br />Tell me, which process owns the memory that those strings are stored in?<br />Could it be that your SEH is actually firing - but then MessageBox is attempting to access illegal addresses (the strings) and causing the final exception handler to be invoked (in order to prevent a nested exception) ?</div><br /><br />The strings are all stored in the current process &quot;one.exe&quot;.<br />I am certain that not even the push instructions in the SE handler are executed because the SE handler is never called. To verify this I launched Olly, put a breakpoint on the first push instruction, when the program reached the faulty line (mov byte ptr ,1) it rose an exception as it should, I told Olly to pass it to the program, then pressed f9 to run the program where Olly paused it and the breakpoint in the custom SE handler was never reached. Darn I just can&#039;t find the bug here :/<br /><br /></div>
    <div class="meta">Posted on 2008-08-11 10:49:56 by pn0k</div>
   </div>
   <div class="post" id="post-205749">
    <div class="subject"><a href="#post-205749">Re: Injecting SEH into program</a></div>
    <div class="body">Why not start by doing SEHs in <strong>one</strong> process and getting that to work? :)<br /><br />Can&#039;t think of much use of SEH injection in other processes, tbh... well, perhaps for tracing, which <strong>can</strong> have legitimate purposes, but is definitely a bit shady.</div>
    <div class="meta">Posted on 2008-08-11 11:22:51 by f0dder</div>
   </div>
   <div class="post" id="post-205750">
    <div class="subject"><a href="#post-205750">Re: Injecting SEH into program</a></div>
    <div class="body">Well what do you know. It turned out after all that the code above wasn&#039;t the culprit, it was Olly. Somehow Olly wasn&#039;t working right - perhaps wise not to have +200 plugins installed - it didn&#039;t break or modify the code properly so I tried with a fresh copy and my handler was called.<br />So to sum it up the above code works perfectly fine.<br /><br />BTW: I do know how to get SEH to work in a single process;)</div>
    <div class="meta">Posted on 2008-08-12 00:55:33 by pn0k</div>
   </div>
   <div class="post" id="post-205751">
    <div class="subject"><a href="#post-205751">Re: Injecting SEH into program</a></div>
    <div class="body">Olly is NOT a good debugger, and particularly so where SEH are concerned.<br />I suggest you put Olly on the back shelf, its still useful for certain things, however I would suggest switching to IDA (pro, 5+) and/or the debugger from Visual Studio (I don&#039;t code C but I have recently been using that debugger, and it&#039;s not too bad).<br /><br />I am using IDA to poke around in other peoples stuff, and the VS debugger for my development work.<br />Both are quite capable, although their GUIs are a lot different to Olly, and take getting used to.<br /></div>
    <div class="meta">Posted on 2008-08-12 02:36:49 by Homer</div>
   </div>
   <div class="post" id="post-205754">
    <div class="subject"><a href="#post-205754">Re: Injecting SEH into program</a></div>
    <div class="body">IMHO Olly is a good enough debugger for the simpler stuff. It does have it&#039;s issues here and there, but I wouldn&#039;t say it&#039;s a bad debugger. I find IDAs debugger somewhat clunky to work with, but it does have the advantage of being integrated with probably the world&#039;s best x86 disassembler :)<br /><br />I tend to use Olly when I need a quick look at some assembly code (dealing with small asm apps of my own, just-in-time attaching to a crashed program, etc.), IDA when I need to mess with other people&#039;s code (rarely use the debugger though), and Visual Studio for high-level debuggin... VS isn&#039;t all that hot for asm debugging, but it has a <strong>lot</strong> of nice features for HLL debugging.</div>
    <div class="meta">Posted on 2008-08-12 05:12:22 by f0dder</div>
   </div>
   <div class="post" id="post-205757">
    <div class="subject"><a href="#post-205757">Re: Injecting SEH into program</a></div>
    <div class="body">I&#039;ve only been using the VS debugger since Biterider has been implementing some support for it within OA32 - I&#039;m able to see my actual sourcecode and exactly which line caused a problem, just like I was coding in a HLL.</div>
    <div class="meta">Posted on 2008-08-12 06:03:23 by Homer</div>
   </div>
  </div>
 </body>
</html>