<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Mesh loader - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20673" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=20673">Mesh loader</a></p>
   <div class="post" id="post-157528">
    <div class="subject"><a href="#post-157528">Mesh loader</a></div>
    <div class="body">well here it is (kinda), my first attempt in making something using OOP in masm32, combined with the basic OpenGL code from EvilHomer this code can load a mesh from a file into memory and then display it on the screen, so i'd like to see some heavy comments on my code so i can learn from it :D<br /><br />the modelfiles have the following format<br />word NumVertices<br />NumVertices * Sizeof(vertice) --&gt; which is 4 dwords<br />word NumTriangles<br />NumTriangles * Sizeof(Triangle) --&gt; which is 6 bytes, 3 words which point to 3 vertices indexes.<br /><br />the file is located here:<br /><br />http://members.lycos.nl/thascorp/Mesh.inc.txt<br />ill upload a zip containing a working exe later on.<br /><br />edit: here it is http://members.lycos.nl/thascorp/WorkingExample.zip<br /><br />ps. the Color parameters will be removed once it can handle textures<br /><br />Scorpie</div>
    <div class="meta">Posted on 2005-02-27 14:34:28 by Scorpie</div>
   </div>
   <div class="post" id="post-157535">
    <div class="subject"><a href="#post-157535">Mesh loader</a></div>
    <div class="body">Wow . Cool :alright:<br />I never thought it'd be this simple to load and display a mesh in OpenGL :) <br />You can skip &quot;ds:&quot; when accessing data, masm will do this automatically for you :) . And  you can merge the <br /><strong>set Box as Mesh<br />set Pyramid as Mesh<br /></strong><br />into<br /><strong> <br />set Box,Pyramid as Mesh</strong><br />With ATC, you can use &quot;set&quot; even <em>before</em> the variables have been declared ;)<br /><br />Nice usage of ATC, btw :)<br />Is this .hex in a custom mesh format ?</div>
    <div class="meta">Posted on 2005-02-27 18:23:55 by Ultrano</div>
   </div>
   <div class="post" id="post-157557">
    <div class="subject"><a href="#post-157557">Mesh loader</a></div>
    <div class="body">Thanks for the comment<br /><br />If i use Set before the declare do i still have to declare the variables or isnt this needed anymore when you Set them?<br /><br />About the format; first i just listed the vertices and 3 vertices in a row made a triangle but i found out milkshape3D has openSource file format so i studyed it a little and there i found the methode of storing all vertices and then just use a word to specify wich vertices form a triangle which will probably save a lot of space since in a model vertices are used multiple times.<br /><br />i made a little mistake in my explaination i reserved an extra dword after each vertices so i could use shift instead of mul and this dword will be used later on to store boneID and such. (planning on inplementing bone animation)<br /><br />advantage with openGL is you need to load a mesh only once and then you can use the same instance to draw it multiple times on the screen :)<br /><br />Scorpie</div>
    <div class="meta">Posted on 2005-02-28 11:01:24 by Scorpie</div>
   </div>
   <div class="post" id="post-157559">
    <div class="subject"><a href="#post-157559">Mesh loader</a></div>
    <div class="body">The &quot;set&quot; macro doesn't do allocation of the variable automatically. Because this allows some flexibility: the variable can be a global initialized dword, a global uninitialized dword, a local variable, or even a register<br /><pre><code><br />set inited,uninited as Mesh<br />.data<br />	inited dd 0<br />.data?<br />	uninited dd ?<br />.code<br /><br />someProc  proc arg1<br />	local localVar<br /><br />	set arg1,localVar,edx  as Mesh<br />	pcall inited.Draw<br />	pcall uninited.Draw<br />	pcall edx.Draw<br />	ret<br />someProc endp<br /><br /></code></pre><br /><br />Ah the boneID is a good idea :) . Just as I was wondering how to make good-looking animated meshes  :-D . <br />So, openGL is exactly like my software 3D engine for PalmOS :) - my DrawMesh() is identical to your Mesh_Draw :) . I'd love to see this Mesh class become complete :alright:</div>
    <div class="meta">Posted on 2005-02-28 12:41:31 by Ultrano</div>
   </div>
   <div class="post" id="post-157560">
    <div class="subject"><a href="#post-157560">Mesh loader</a></div>
    <div class="body">ah i see, flexibility is good :)<br /><br />im stil working out a good system for the animations and im thinking of implementing textures first but im not sure wether i want the textures inside the model file or not and if i should do them before or after animations (probably animations since i got a nice idea on how to make it possible :wink:  ) <br /><br />btw, a friend of mine didnt see any 3D in my example so i made the following JPG to show that the model is actually 3D but it isnt very clear since i dont use textures nor shading/lightning yet: http://members.lycos.nl/thascorp/see3D.JPG<br /><br />edit: hmm maybe it'll take some time before i've implemented the animation system, im thinking about two different things i can do:<br /><br />One way: i can put extra parameters in the call; AnimotionNumber and FrameNumber.<br />Downside: user needs to keep data of all objects, what framenumber they are and update this theirselves.<br /><br />Other way: combine a Timer with the mesh include so you only need to call UpdateAnims (or something) and the objects get transformed the right way and displayed.<br />downside would be you need to create an instance of the Mesh for every object you want to draw so they can all hold their own CurrentFrame.<br />but im thinking about solving this by making 2 classes, 1 class that just holds data for a certain mesh (ie. Box or Pyramid) and another class which has a datamember to hold a pointer to the mesh its using (for example a pointer to the box class) and other values like CurrentFrame and such.<br />But i still need to be able to have a dynamic number of the second class (depending on how many object are near the user or in its section or something like that)<br /><br />Any thoughts on this? (im gona think more now in front of the tv)</div>
    <div class="meta">Posted on 2005-02-28 13:26:24 by Scorpie</div>
   </div>
   <div class="post" id="post-157573">
    <div class="subject"><a href="#post-157573">Mesh loader</a></div>
    <div class="body">I'm currently working on a more advanced mesh class which currently supports:<br />A) &quot;Plain&quot; quad surfaces (pervertex color)<br />B) &quot;Textured&quot; quad surfaces<br /><br />Textured surfaces support persurface normal for lighting and collision detection. That means you can bounce particles off any surface of your model. Since &quot;plain&quot; surfaces don't currently support Normal, they are not currently useful for lighting/collisions.<br />So far, I've implemented a Sphere/Plane collision and response.<br />It uses the &quot;Planar Sweep&quot; method to determine the precise collision time and position, determines if the collision is in the current timestep, and if so, &quot;goes back in time&quot;, fixes the collision situation (response), then &quot;winds time forward&quot;.<br />The class also provides for BoundingSphere for the entire &quot;cluster of surfaces&quot;, as an aid to frustum culling.<br />Finally, the class supports Loading and Saving of surface data.<br /><br />ToDo: Write a flexible Vertex arraymanager class and then implement Indexed Vertices to eliminate vertex duplication in reference models.<br />Write a Modelmanager class to instance our ReferenceModels.<br />Add support for collisions of Sphere/Sphere, Sphere/Box and Sphere/Cylinder (all pretty easy).<br /><br />The aim of the current work is to implement a robust class to manage surface arrays, handle collisions and responses, etc. <br />I'm only working with Spheres because it's the first geometric primitive which I implemented, and many physics tutorials mention Spheres.<br /><br />This will all come together to form my next 2 or 3 OGL tutorials.<br />Interesting?<br /><br />Scorpie, you are currently running into some of the very same issues that I have of recent days. One of the first things I did about Textures was to write a robust TextureManager class.<br />I humbly offer this class here. It may or may not be bugfree, but I'm already using it quite happily to render my textured quads.<br /><br /><pre><code><br /><br /><br />class TextureManager, ,C++ compatible<br />    void GetNameByID&#58;dwID<br />    void GetIDByName&#58;pName<br />    void AddNewTexture&#58;pName<br />    long pNamesArray    ;&lt;-- ptr to CVector object which contains an array of stringptrs<br />    long pIDsArray          ;&lt;-- ptr to CVector object which contains an array of ID values<br />    static CurrentTextureID dd 0<br />endclass<br /><br /><br />;=============================================================================<br />;The TextureManager class stores two closely-associated arrays of data.<br />;One array contains stringpointers for the filenames from which textures were sourced,<br />;the other contains the associated &quot;ID&quot; of each loaded texture.<br /><br />;The following class methods are provided for your general use&#58;<br />;GetIDByName<br />;GetNameByID<br />;AddNewTexture<br /><br />;GetIDByName attempts to return the ID for a given Name, or -1 for Error &#40;not found&#41;.<br />;GetNameByID attempts to return the stringpointer for a given ID, or -1 for Error &#40;as above&#41;.<br />;AddNewTexture is what we use to load new textures.<br />;Ostensibly, it returns the ID of the loaded texture, and E_FAIL for error &#40;could not load&#41;.<br />;It contains a call to the GetIDByName method which it uses to determine whether<br />;the given filename has already been loaded, in which case it returns the existing ID.<br />;=============================================================================<br /><br />AUX_RGBImageRec struct<br />    dwsizeX GLint ?<br />    dwsizeY GLint ?<br />    data dd ?<br />AUX_RGBImageRec ends<br /><br /><br />;=============================================================================<br />;This &quot;Helper Procedure&quot; creates an OpenGL texture from a source image file &#40;most media types&#41;<br />;It is called from TextureManager class's &quot;AddNewTexture&quot; method.<br />;=============================================================================<br />CreateTexture proc ptexture, pstrFileName<br />local pBitmap&#58;ptr AUX_RGBImageRec<br />	<br />    .if !pstrFileName       ; Return from the function if no file name was passed in<br />        return E_FAIL<br />    .endif<br />    <br />    invoke auxDIBImageLoad,  pstrFileName   ;Load the bitmap and store the data<br />    .if eax == NULL     ; If we can't load the file, quit!<br />        return E_FAIL<br />    .endif<br />    mov pBitmap , eax	<br /><br />    invoke glGenTextures,1, ptexture                              ; Generate a texture with the associated texture variable<br />    invoke glPixelStorei , GL_UNPACK_ALIGNMENT, 1   ; This sets the alignment requirements for the start of each pixel row in memory.<br /><br />    mov eax,ptexture <br />   invoke glBindTexture,GL_TEXTURE_2D, dword ptr&#91;eax&#93;    ; Bind the texture to the texture variable passed in<br />  <br />  ; Build Mipmaps &#40;builds different versions of the picture for distances - looks better&#41;<br />      mov ebx, pBitmap<br />      invoke gluBuild2DMipmaps,GL_TEXTURE_2D, 3, &#91;ebx&#93;.AUX_RGBImageRec.dwsizeX, &#91;ebx&#93;.AUX_RGBImageRec.dwsizeY, GL_RGB, GL_UNSIGNED_BYTE, &#91;ebx&#93;.AUX_RGBImageRec.data<br />  <br />  ; Lastly, we need to tell OpenGL the quality of our texture map.  GL_LINEAR_MIPMAP_LINEAR<br />  ; is the smoothest.  GL_LINEAR_MIPMAP_NEAREST is faster than GL_LINEAR_MIPMAP_LINEAR, <br />  ; but looks blochy and pixilated.  Good for slower computers though.  <br />      invoke glTexParameteri,GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST<br />      invoke glTexParameteri,GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR_MIPMAP_LINEAR<br /><br />; Now we need to free the bitmap data that we loaded since openGL stored it as a texture<br />    mov ebx, pBitmap<br />    free &#91;ebx&#93;.AUX_RGBImageRec.data<br />    free pBitmap<br />    return S_OK<br />CreateTexture endp<br />;=============================================================================<br /><br />TextureManager_TextureManager proc<br />    mov &#91;ecx&#93;.TextureManager.pNamesArray, new &#40;CVector&#41;<br />    mov &#91;ecx&#93;.TextureManager.pIDsArray, new &#40;CVector&#41;<br />    ret<br />TextureManager_TextureManager endp<br /><br />TextureManager_$TextureManager proc<br />local cunt<br />local me<br />    mov me,ecx<br />    ;Since the IDsArray only contains numbers, we can just delete the whole thing..simple.<br />    delete &#91;ecx&#93;.TextureManager.pIDsArray<br />    ;Since the NamesArray contains stringpointers, we need to &quot;sweep&quot; the array<br />    ;ie For each StringPointer in array &#58; free StringPointer <br />    mov cunt,$icall &#40;&#91;ecx&#93;.TextureManager.pNamesArray, CVector, getcount&#41;<br />    xor ebx,ebx<br />    .while ebx&lt;cunt<br />        push ebx<br />        icall &#91;ecx&#93;.TextureManager.pNamesArray, CVector, getbyindex, ebx<br />        free eax<br />        pop ebx<br />        inc ebx<br />    .endw<br />    delete &#91;ecx&#93;.TextureManager.pNamesArray<br />    ret<br />TextureManager_$TextureManager endp<br /><br />;This procedure scans the IDsArray for the given ID.<br />;If found, it returns the associated StringPointer.<br />;Otherwise it returns Error=-1<br />TextureManager_GetNameByID proc dwID<br />local cunt<br />local me<br />    mov me,ecx<br />    mov cunt,$icall &#40;&#91;ecx&#93;.TextureManager.pIDsArray, CVector, getcount&#41;<br />    xor ebx,ebx<br />    .while ebx&lt;cunt<br />        push ebx<br />        icall &#91;ecx&#93;.TextureManager.pIDsArray, CVector, getbyindex, ebx<br />        .if eax==dwID<br />            pop ebx<br />            push ebx<br />            icall &#91;ecx&#93;.TextureManager.pNamesArray, CVector, getbyindex, ebx<br />            ret<br />        .endif<br />        pop ebx<br />        inc ebx<br />    .endw<br />    return -1   ;Not Found<br />TextureManager_GetNameByID endp<br /><br />;This procedure scans the NamesArray for the given Name.<br />;If found, it returns the associated ID.<br />;Otherwise it returns Error=-1<br />TextureManager_GetIDByName proc pName<br />local cunt<br />local me<br />    mov me,ecx<br />    icall &#91;ecx&#93;.TextureManager.pNamesArray, CVector, getcount<br />    .if eax==NULL<br />        return -1<br />    .else<br />        mov cunt,eax<br />    .endif<br />    xor ebx,ebx<br />    .while ebx&lt;cunt<br />        push ebx<br />        icall &#91;ecx&#93;.TextureManager.pNamesArray, CVector, getbyindex, ebx<br />        invoke lstrcmpi, eax, pName<br />        .if eax==0<br />            pop ebx<br />            push ebx<br />            mov ecx,me<br />            icall &#91;ecx&#93;.TextureManager.pIDsArray, CVector, getbyindex, ebx<br />            ret<br />        .endif<br />        pop ebx<br />        inc ebx<br />    .endw<br />    return -1   ;Not Found<br />TextureManager_GetIDByName endp<br /><br />TextureManager_AddNewTexture proc pName<br />local me<br />local dwID<br />    mov me,ecx<br />    ;First, check to see if the Texture has already been loaded<br />    icall me, TextureManager, GetIDByName, pName<br />    .if eax!=-1<br />        ret     ;If the Texture was already Loaded, we return its ID<br />    .endif<br />    ;The Texture has not been Loaded yet, attempt to do so now.<br />    invoke CreateTexture, addr dwID, pName<br />    .if eax==E_FAIL<br />        ret     ;If we fail to load the Texture for WHATEVER reason, return E_FAIL<br />    .endif<br />    ;The Texture was successfully Loaded, so add it to the Array&#40;s&#41;<br />    ;Store the ID in the IDsArray<br />    mov ecx,me<br />    icall &#91;ecx&#93;.TextureManager.pIDsArray, CVector, push_back, dwID<br />    ;Store the Name in the NamesArray<br />    invoke AllocString, pName   ;Allocate string memory and copy string into it    <br />    mov ecx,me<br />    icall &#91;ecx&#93;.TextureManager.pNamesArray, CVector, push_back, eax<br />    return dwID<br />TextureManager_AddNewTexture endp<br /><br /></code></pre><br /><br />Have a nice day :)</div>
    <div class="meta">Posted on 2005-03-01 01:52:34 by Homer</div>
   </div>
   <div class="post" id="post-157574">
    <div class="subject"><a href="#post-157574">Mesh loader</a></div>
    <div class="body">My only complaint about your basic mesh class is that you could have used the malloc() and free() macros to allocate the array memory as Heap memory rather than as virtual process memory via VirtualAlloc.</div>
    <div class="meta">Posted on 2005-03-01 02:02:47 by Homer</div>
   </div>
   <div class="post" id="post-157580">
    <div class="subject"><a href="#post-157580">Mesh loader</a></div>
    <div class="body">i tried reading a bit on various allocation types and i couldnt find much about it but i did find some benchmark results and VirtuallAlloc came out as the fastest way possible and its what i've always used to allocate memory.<br />But im always willing to learn :) what is the advantage of using heapalloc instead if virtualalloc?<br /><br />Scorpie<br /><br />edit: im at school now (in class) ill read your code later on today and ill post some comment on it.</div>
    <div class="meta">Posted on 2005-03-01 04:18:07 by Scorpie</div>
   </div>
   <div class="post" id="post-157582">
    <div class="subject"><a href="#post-157582">Mesh loader</a></div>
    <div class="body">Firstly, understand that every Process has a &quot;Process Heap&quot;.<br />Then understand that we're not using it when we use malloc and free.<br />We can create as many heaps as we require, and ATC creates one such Heap (on demand, when we first use the malloc macro).<br /><br />Theres some handy functions for &quot;walking&quot; the data structures stored in Heap memory, but I've never needed them yet although they offer potential as debugging tools. For example, its possible to enumerate every chunk of memory that was allocated on the heap, how large it is, etc. Since ATC only creates and uses ONE such Heap, those enumeration functions are less valuable. Perhaps CLASS33 will support more powerful malloc and free macros which operate on one of N heaps, but for now, malloc uses one heap.<br /><br />If you dig down into the kernel code for VirtualAlloc and GlobalAlloc, you will find that both eventually call HeapAlloc iirc. This implies that those api functions carry some overhead which we don't need (I assume its related to automatic garbage collection). It also implies that HeapAlloc &quot;should&quot; be faster.<br /><br />VirtualAlloc and GlobalAlloc (and LocalAlloc for that matter) have a default &quot;page granularity&quot; which means they are not very friendly for allocating lots of small memory blocks, and implying that a &quot;memory manager&quot; codebase is required to manage objects allocated in such an environment to prevent them from straddling pages.<br /><br />Heap memory, if allocated correctly in the first place, can GROW ON DEMAND, and will ensure that objects never straddle memory pages.<br /><br />In summary: if you want to allocate one or two largish chunks of memory and only need to do so once or twice, then you're fine with the api Alloc functions. But if you need to allocate memory for numerous small objects (with no idea how many may be required) and/or need to frequently release arbitrary objects, then the Heap is your friend.<br />It took a long time for me to stop using GlobalAlloc and be convinced that Heap memory was actually better for this kind of thing, I think it happened around the same time I started writing particle demos under DirectX 8... <br /><br />If anyone has another point of view on this, or wishes to correct me on any point or points, please feel free.</div>
    <div class="meta">Posted on 2005-03-01 06:21:12 by Homer</div>
   </div>
   <div class="post" id="post-157591">
    <div class="subject"><a href="#post-157591">Mesh loader</a></div>
    <div class="body">Thanks for the explanation.<br /><br />By &quot;GROW ON DEMAND&quot; do you mean the heap gets bigger but the existing data stays as it is since this would be very nice to fix one of my problems (dynamic number of objects).<br /><br />GlobalAlloc is out of the question anyway since it has some limitations, bugs and is slow compared to most other methodes for allocating mem. Ill look up the benchmark results again since VirtuallAlloc did come out faster then other methodes but if it calls HeapAlloc that wouldnt be very logical.<br /><br />But reading this i think using HeapAlloc would be better.<br /><br />ps. ill read your texture code after dinner.<br /><br />Scorpie</div>
    <div class="meta">Posted on 2005-03-01 11:18:53 by Scorpie</div>
   </div>
   <div class="post" id="post-157592">
    <div class="subject"><a href="#post-157592">Mesh loader</a></div>
    <div class="body">Homer, you got things mixed up a bit here - local/globalalloc end up as HeapAlloc calls, which internally uses a VirtualAlloc-like routine. heap+local/globalalloc has &quot;whatever&quot; alignment (4byte, I think), VirtualAlloc has 64kb alignment - so VA is not good for small chunks.<br /><br />Local/GlobalAlloc are deprecated and shouldn't be used, use HeapAlloc instead.<br /><br />VirtualAlloc is good if you need huge chunks of memory, or want to design your own heap manager.</div>
    <div class="meta">Posted on 2005-03-01 11:22:25 by f0dder</div>
   </div>
   <div class="post" id="post-157596">
    <div class="subject"><a href="#post-157596">Mesh loader</a></div>
    <div class="body">The working example download doesn't work.</div>
    <div class="meta">Posted on 2005-03-01 13:21:00 by drhowarddrfine</div>
   </div>
   <div class="post" id="post-157597">
    <div class="subject"><a href="#post-157597">Mesh loader</a></div>
    <div class="body">hmm i had the same problem at school and just ago but now it seems to be working again, if it doenst work try to copy the url to the adresbar or rightclick --&gt; save the file.<br /><br />sorry for the inconveniance</div>
    <div class="meta">Posted on 2005-03-01 14:01:05 by Scorpie</div>
   </div>
   <div class="post" id="post-157603">
    <div class="subject"><a href="#post-157603">Mesh loader</a></div>
    <div class="body">I thought I might have been mixed up - it was late at night when I replied.<br />Generally speaking I wasn't far off the mark - VirtualAlloc for large allocation, HeapAlloc for small allocation.<br /><br />Yes, the Heap can Grow on demand, leaving existing data in place.<br />Better yet, ATC already contains some basic macros to help implement heap memory objects, and in fact, the malloc() macro I mentioned is internally used by ATC to allocate memory for CLASS OBJECTS when you call the new() macro...</div>
    <div class="meta">Posted on 2005-03-01 22:35:27 by Homer</div>
   </div>
   <div class="post" id="post-157840">
    <div class="subject"><a href="#post-157840">Mesh loader</a></div>
    <div class="body">I've managed to get animations working (animations stored in model and to display them), im thinking about making the following system:<br /><br />Mesh class to load and display a model<br /><br />Texture manager for all the textures (i like the idea Homer :))<br /><br />Object class which holds a reference to a Mesh class (so every model only needs to be loaded once) with private values like position in world, rotation in world, current animation, currentframe etc<br /><br />Timer class which works with 3 counters inside, 1 counter to Update the 'Currentframe' of all objects, 1 counter which allows you to run code on a certain fps (so objects move at the same speed on all hardware) and the last counter counts how many times the Timer.Update is called every sec to display the FPS.<br /><br />I dont have much time to program this week but ill let you know when i got some new things working</div>
    <div class="meta">Posted on 2005-03-08 11:00:31 by Scorpie</div>
   </div>
  </div>
 </body>
</html>