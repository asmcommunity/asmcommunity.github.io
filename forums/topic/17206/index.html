<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>How to Unhook ???? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17206" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=17206">How to Unhook ????</a></p>
   <div class="post" id="post-133338">
    <div class="subject"><a href="#post-133338">How to Unhook ????</a></div>
    <div class="body">I have tangled my self in a web and don't know how to get out of it :)mov	<br /><br /><br />By some trial and error<br />i have hooked like this <br /><br />mov	esi, offset32 MyHookProc<br />GetVxDServiceOrdinal eax, _RegOpenKey<br />VMMCall	Hook_Device_Service<br />jc	error<br /><br /><br />How do i unhook ???<br />How do i get the address of the original function before hooking :) ??<br /><br />Am i totally Dumb !!</div>
    <div class="meta">Posted on 2004-02-13 01:08:49 by monty</div>
   </div>
   <div class="post" id="post-133356">
    <div class="subject"><a href="#post-133356">How to Unhook ????</a></div>
    <div class="body">Hi, monty<br /><br />Did you read my answers to your previous questions ???? :confused: <br />Did you accessed the <a target="_blank" href="http://www.sysinternals.com">Russinovich</a>  site ????<br />Did you read the VxDMon source code ????<br /><br />Well, the answer to your question is register ESI. Look:<br /><br /><pre><code><br />        ; hook the mouse input routine<br /><br />        GetVxDServiceOrdinal eax, VMD_Post_Pointer_Message<br />                            ; get the id of the service<br />        mov     esi, offset32 Record_Mouse      ; pass our hook routine address<br />        VMMCall Hook_Device_Service             ; hook it<br />        mov     Mouse_Proc, esi                 ; save service address<br /></code></pre> <br /><br />Good luck :alright:</div>
    <div class="meta">Posted on 2004-02-13 05:30:33 by Opcode</div>
   </div>
   <div class="post" id="post-133376">
    <div class="subject"><a href="#post-133376">How to Unhook ????</a></div>
    <div class="body">Hi<br /><br />You should use Unhook_Device_Service to unhook the service you previously hooked.<br /><pre><code>&#91;size=12&#93;<br />Hook&#58;<br />GetVxDServiceOrdinal eax, VMM_Add_DDB	; Service to hook - CHANGE TO ANY OTHER<br />mov esi, OFFSET32 HookProc		; pointer to our hook procedure<br />VMMCall Hook_Device_Service		; address of service returned in ESI<br />jc hookfailed<br />jmp ExitOK<br /><br />Unhook&#58;<br />GetVxDServiceOrdinal eax, VMM_Add_DDB	; service to unhook<br />mov esi, OFFSET32 HookProc		; pointer to our hook procedure<br />VMMCall Unhook_Device_Service<br />jc unhookfailed<br />jmp ExitOK2<br />&#91;/size&#93;</code></pre><br />Kayaker</div>
    <div class="meta">Posted on 2004-02-13 10:42:34 by Kayaker</div>
   </div>
   <div class="post" id="post-133464">
    <div class="subject"><a href="#post-133464">How to Unhook ????</a></div>
    <div class="body">Yes opcode i did went to sysinternals they are not giving the source code to regmon now ,<br /><br />i do have the code of vcmon but as might have guessed it is quite overwhelming for a newbie like me to swallow it all , so i am taking small steps little bit from here and there<br /><br />but i got it finally .<br /><br />one last nagging doubt i have , if you could just explain this to me <br /><br />this is my hooking code <br />----------------------------------------------------------------------------------<br />mov	esi, offset32 RegOpenKey_Hook<br />GetVxDServiceOrdinal eax, _RegOpenKey<br />VMMCall	Hook_Device_Service<br /><br />----------------------------------------------------------------------------------<br />This is my hook proc<br />----------------------------------------------------------------------------------<br />BeginProc RegOpenKey_Hook, HOOK_PROC, Prev_RegOpenKey, HIGH_FREQ, CCALL<br /><br />	ArgVar	hKey, DWORD<br />	ArgVar	lpszSubKey, DWORD<br />	ArgVar	lphKey, DWORD<br /><br />	EnterProc<br />	<br />	pushfd                              ; save flags on stack<br />	pushad                              ; save registers on stack<br />	mov     esi, lpszSubKey        ; points to string to write<br />	VMMCall Out_Debug_String<br />	popad<br />	popfd<br />	<br />	cCall	, &lt;hKey, lpszSubKey, lphKey&gt;<br /><br />	LeaveProc<br />	return<br />EndProc RegOpenKey_Hook<br /><br />where Prev_RegOpenKey is a vaiable i have declared so<br />Prev_RegOpenKey		DD	?<br /><br /><br />all this is working fine , but i have never put anything in Prev_RegOpenKey then how am i able to call it ???????? without a blue screen showing up</div>
    <div class="meta">Posted on 2004-02-14 00:09:34 by monty</div>
   </div>
   <div class="post" id="post-133474">
    <div class="subject"><a href="#post-133474">How to Unhook ????</a></div>
    <div class="body">Hi<br /><br />A few comments from looking at my old notes.<br /><br />I'm not sure exactly why you use the HIGH_FREQ, CCALL in your BeginProc, but I'll assume that's the way you want to set it up.<br /><br />From the notes I have, the BeginProc macro which is needed for a hook routine has the syntax:<br />; &lt;BeginProc ProcName, HOOK_PROC, hook_var, segment_type&gt;<br /><br />The hook_var parameter is the name of the variable into which the address of the previous hook will be stored, which you have correctly declared.  The segment_type should I believe be LOCKED, since all Hook and Interrupt routines should go in a locked code segment.  The rest of your code can be in a VxD_PAGEABLE_CODE_SEG, but it's only logical you DON'T want your hook routine to be paged out, hence I would strongly suggest you use VxD_LOCKED_CODE_SEG.<br /><br /><br />When your HookProc is called, all the parameters required for the particular service you hooked are sitting on the stack, so what you can do is set up a stack frame at the start, save all the registers and flags, then when you are ready to chain back to the original handler simply pop them off the stack and do a simple jump.  There is no need to do a Call + parameters setup.  In fact you DON'T want to do a Call else it would in theory return to your own code instead of actually chaining.  Your hook is supposed to not exist remember, you do your thing then pass execution on to where it was supposed to go in the first place...<br /><br />A little code from my hook proc might help explain. Note also my use of an Exception Handler, you may want to implement this in various parts of your vxd code for safety.<br /><br /><pre><code>&#91;size=12&#93;<br />VxD_LOCKED_DATA_SEG<br />	OldServiceAddress DWORD ?	; address of original Service routine<br />	EXCEPTION Exception_Handler_Struc &lt;&gt;<br />VxD_LOCKED_DATA_ENDS<br /><br />VxD_LOCKED_CODE_SEG <br /><br />;=========================Begin HookProc=======================<br />BeginProc HookProc, HOOK_PROC, OldServiceAddress, LOCKED<br /><br />;---------------------------------------------------------------------<br />; Important&#58; Note syntax of BeginProc macro needed for a hook routine&#58;<br />; &lt;BeginProc ProcName, HOOK_PROC, hook_var, segment_type&gt;<br />;<br />; If hook uses Hook_Device_Service, Hook_V86_Fault, Hook_PM_Fault,<br />; or Hook_VMM_Fault, then it must be marked with the HOOK_PROC attribute<br />; so that the service can be unhooked.<br />; The hook_var parameter is the name of the variable into which the <br />; address of the previous hook will be stored.<br />;-----------------------------------------------------------------------<br /><br />;----------------------------------------------------------------------<br />; Create a stack frame so we can access stack parameters at time of hook,<br />; parameters will vary with Service hooked.<br />;----------------------------------------------------------------------<br />        push ebp<br />        mov ebp, esp<br /><br />        pushad<br />        pushfd<br />        <br />;----------------------------------------------------------------<br />; Install Exception Handler<br />; Place any code that might generate an error between<br />; EH_Start_EIP and EH_End_EIP<br />;----------------------------------------------------------------<br />mov	EXCEPTION.EH_Reserved,0<br />mov	EXCEPTION.EH_Start_EIP,offset32 PROTECT1<br />mov	EXCEPTION.EH_End_EIP,offset32 ENDPROTECT1<br />mov	EXCEPTION.EH_Handler,offset32 EHandler1<br /><br />mov     esi, offset32 EXCEPTION	; points to an Exception_Handler_Struc<br />VMMCall Install_Exception_Handler	; set up exception handler <br />;=============================================<br /><br />PROTECT1&#58;<br /><br />; Do your stuff here, fill some data structures with info from<br />; the stack variables for later retrieval, whatever.<br /><br />ENDPROTECT1&#58;<br /><br />ExitOK1&#58;	<br />	mov esi, offset32 EXCEPTION	; points to an Exception_Handler_Struc<br />	VMMcall Remove_Exception_Handler	; remove exception handler <br /><br />        popfd<br />        popad<br /><br />        pop ebp<br /><br />        jmp &#91;OldServiceAddress&#93;	; Chain to previous hook<br />        <br />EHandler1&#58;<br />	GetVxDServiceOrdinal eax, VMM_Add_DDB	; service to unhook<br />     mov esi, OFFSET32 HookProc	; pointer to our hook procedure<br />     VMMCall Unhook_Device_Service<br />        <br />ret<br /><br />EndProc HookProc<br />;===================End HookProc==================<br /><br />VxD_LOCKED_CODE_ENDS<br />&#91;/size&#93;</code></pre><br /><br />Hope this helps,<br />Kayaker</div>
    <div class="meta">Posted on 2004-02-14 01:37:55 by Kayaker</div>
   </div>
   <div class="post" id="post-133479">
    <div class="subject"><a href="#post-133479">How to Unhook ????</a></div>
    <div class="body">OH my god what a wonderfull explaination , i love it <br />i will read more in to it and try to implement all that <br /><br />one more thing , i didn't quite understand <br />---------------------<br />push ebp<br />mov ebp, esp<br /><br />pushad<br />pushfd<br />---------------------<br />will this code vary incase of different parameters passed ,<br />could you please explain more <br /><br />Thanks a bunch Kayakar</div>
    <div class="meta">Posted on 2004-02-14 02:31:58 by monty</div>
   </div>
   <div class="post" id="post-133522">
    <div class="subject"><a href="#post-133522">How to Unhook ????</a></div>
    <div class="body">I'm glad it was useful.  I don't believe there should be any difference in how you set up or access the parameters from the stack frame, but you will have to confirm what each stack parameter represents for your particular service.<br /><br />The VMMCall for VMM_Add_DDB for example passes the offset of a Vxd_Desc_Block structure. I don't know at what point the &quot;hook&quot; actually occurs and your own code is called, so you'll have to test the stack to see where the parameters you are *expecting* actually are.<br /><br />For VMM_Add_DDB,  in my hook proc happened to be the Driver Name, not necessarily where I *expected* it from the structure of the Vxd_Desc_Block, so this is why you need to test.<br /><br />        push ebp<br />        mov ebp, esp<br />;  == DDB_Name<br /><br />VMM_Add_DDB is called as part of the VxD loader services and can be used to detect a driver being loaded. It adds a Vxd_Desc_Block structure (DDB or Device Description Block) to the linked device list chain.  This chain can be &quot;walked&quot; to identify and analyze each application or Kernel system driver loaded on your system.<br /><br />Heh, it's good to see some people are still coding vxd's ;-)</div>
    <div class="meta">Posted on 2004-02-14 13:59:46 by Kayaker</div>
   </div>
   <div class="post" id="post-133561">
    <div class="subject"><a href="#post-133561">How to Unhook ????</a></div>
    <div class="body">Thanks Again Kayaker :)<br /><br />just one more thing could you please shed some light  on APC <br />i want to Queue some data to the User mode application as well<br /><br />Heh, it's good to see some people are still coding vxd's ;-)<br /><br />Thats what i was worried about when i started this , will i be able to get help from some ppl who STILL codes VXD's :)</div>
    <div class="meta">Posted on 2004-02-15 01:08:05 by monty</div>
   </div>
   <div class="post" id="post-133565">
    <div class="subject"><a href="#post-133565">How to Unhook ????</a></div>
    <div class="body">Well I don't code 'em anymore but...<br />Can you even do APC's in vxd's? There may be something similar, but if what you're trying to do is pass info back to user mode the easiest way is to create a data structure in your vxd, fill it up in your hook proc with whatever you want, then access the data later from a separate DeviceIOControl call back in user mode.  If your data structure is again in a locked segment you can simply pass back a pointer to it through lpOutBuffer and spit it out again in usermode.<br /><br />I gave a complete example of this a while back in this thread which should explain it.<br /><br /><a target="_blank" href="http://www.asmcommunity.net/board/showthread.php?threadid=7375">http://www.asmcommunity.net/board/showthread.php?threadid=7375</a></div>
    <div class="meta">Posted on 2004-02-15 04:46:19 by Kayaker</div>
   </div>
  </div>
 </body>
</html>