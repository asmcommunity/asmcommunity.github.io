<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>When to use registers vs local variables - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29955" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29955">When to use registers vs local variables</a></p>
   <div class="post" id="post-211510">
    <div class="subject"><a href="#post-211510">When to use registers vs local variables</a></div>
    <div class="body">I have written myself a primitive &quot;itoa&quot; function (NASM) which actually works (or so it seems so far) :shock: But it uses both EAX, EBX, ECX and EDX. I&#039;m not sure if that is a problem or not, but I was wondering what the &quot;conventions&quot; for using registers were. Can you just use any register at any time, or will that be frowned upon? Should I use local variables instead whenever possible (for example instead of ECX as a loop counter in my code below)?<br /><br />Here is the specific code, but my question is general. And please bear with me if the code sucks - I have just started out and don&#039;t know very much yet.. Just hacking along with what I&#039;ve learned so far. Suggestions for improvement are very welcome, I&#039;m eager to learn. ;)<br /><br /><pre><code><br /><br />; Function _itoa (int, char*)<br />; ------------------------------<br />; Converts 32-bit integer to ASCII<br />; Input:&nbsp; &nbsp; - Arg1: An integer (dword) to convert to ascii<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  - Arg2: 32-bit pointer to a 32 bytes (or more) string buffer to store the result in&nbsp; &nbsp; &nbsp;  <br />;<br />; Note 1: Push arguments on stack in reverse order (Arg2 first)<br />; Note 2: The ASCII string will contain the number represented in binary with all leading zeroes<br />_itoa:<br />&nbsp; &nbsp; %define&nbsp; &nbsp;  src_integer dword &nbsp; &nbsp;  ; 1st argument<br />&nbsp; &nbsp; %define&nbsp; &nbsp;  dst_buffer&nbsp; dword &nbsp; &nbsp; ; 2nd argument<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; push ebp<br />&nbsp; &nbsp; mov ebp, esp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Stack frame<br />&nbsp; &nbsp;  <br />&nbsp; &nbsp; push eax<br />&nbsp; &nbsp; push ebx<br />&nbsp; &nbsp; push ecx<br />&nbsp; &nbsp; push edx<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ; Conversion loop&nbsp; &nbsp;  <br />&nbsp; &nbsp; mov edx, dst_buffer&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Pointer to string buffer&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; mov eax, src_integer&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Integer to convert<br />&nbsp; &nbsp; mov ecx, 32&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Repeat once for each bit<br /> conv_loop:&nbsp; &nbsp; <br />&nbsp; &nbsp; mov ebx, eax<br />&nbsp; &nbsp; and ebx, 80000000h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Get leftmost bit in ebx - sets ZF&nbsp; <br />&nbsp; &nbsp; jnz addone&nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; mov , byte 30h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Leftmost bit is 0 - write to buffer <br />&nbsp; &nbsp; jmp next<br />&nbsp; addone:<br />&nbsp; &nbsp; mov , byte 31h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Leftmost bit is 1 - write to buffer<br />&nbsp; next:<br />&nbsp; &nbsp; shl eax, 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Next bit in integer<br />&nbsp; &nbsp; inc edx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Next byte in buffer<br />&nbsp; &nbsp; dec ecx&nbsp; &nbsp; <br />&nbsp; &nbsp; jnz conv_loop<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ; Cleanup <br />&nbsp; &nbsp; pop edx<br />&nbsp; &nbsp; pop ecx<br />&nbsp; &nbsp; pop ebx<br />&nbsp; &nbsp; pop eax<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; pop ebp<br />&nbsp; &nbsp; ret (2 * 4)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; 2 arguments * 4 bytes<br /><br /></code></pre> </div>
    <div class="meta">Posted on 2010-04-29 12:48:03 by !me</div>
   </div>
   <div class="post" id="post-211511">
    <div class="subject"><a href="#post-211511">Re: When to use registers vs local variables</a></div>
    <div class="body"><strong>!me</strong>,<br /><br />Along with fine guides about optimization, <a target="_blank" href="http://www.agner.org/optimize/">Agner Fog&#039;s site</a> contains document about calling conventions used in various compilers/OSes. For example, <strong>stdcall</strong> calling conventions, common for Win32 API, allow to use <strong>eax</strong>, <strong>ecx</strong>, <strong>edx</strong> and FPU/MMX/XMM registers freely while preserving others.<br /><br />You can use registers as you wish if you have preserved those specified in calling conventions you wish to adhere to.<br /><br />As about your code, for a first try it&#039;s not bad (only quite straightforward).<br /><br />Stack frame is not necessary for small functions like this, you may use <strong>dword </strong> to access arguments (it makes those <strong>mov</strong> instructions slightly longer, but at a benefit of absent prolog/epilog code).<br /><br />Your if/then/else construction is not necessary, it can be reduced to something like<br /><pre><code><br />&nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp;  ebx, ebx&nbsp; &nbsp; &nbsp; &nbsp; ; not necessarily right before the following<br />&nbsp; &nbsp; &nbsp; &nbsp; shl&nbsp; &nbsp;  eax, 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; shift leftmost bit into CF<br />&nbsp; &nbsp; &nbsp; &nbsp; adc&nbsp; &nbsp;  ebx, &#039;0&#039;&nbsp; &nbsp; &nbsp; &nbsp; ; bl = &#039;0&#039;+CF<br /></code></pre><br /><br />You may use calculated binary digit right now, or defer store until <strong>ebx</strong> contains four digits (counter in ecx helps to detect when this occurs).<br /><br /><strong>ecx</strong> and <strong>edx</strong> are updated synchronously, this can be used to eliminate one of the updates. For example, you can count from 0 to 31 (easy way to detect 31-&gt;32 transition is to test lower 5 bits of <strong>ecx</strong> for being zero) and use <strong></strong> as the address of memory to store digit.</div>
    <div class="meta">Posted on 2010-04-29 13:38:00 by baldr</div>
   </div>
   <div class="post" id="post-211513">
    <div class="subject"><a href="#post-211513">Re: When to use registers vs local variables</a></div>
    <div class="body">Thank you for taking time replying :) That link was great, I&#039;ll read it all as soon as I get time.<br /><br />As for the _itoa function, I got most of your suggestions to work, but couldn&#039;t make it work without the stack frame.. Never learned how to do that, and it seems like I did something very wrong. <br /><br />Here is what I currently have:<br /><br /><pre><code><br /><br />; Function _itoa (int, char*)<br />; ------------------------------<br />; Converts 32-bit integer to ASCII<br />; Input:&nbsp; &nbsp; - Arg1: An integer (dword) to convert to ascii<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  - Arg2: 32-bit pointer to a 32 bytes (or more) string buffer to store the result in&nbsp; &nbsp; &nbsp;  <br />;<br />; Note 1: Push arguments on stack in reverse order (Arg2 first)<br />; Note 2: The ASCII string will contain the number represented in binary <br />_itoa:<br />&nbsp; &nbsp; %define&nbsp; &nbsp;  src_integer dword &nbsp; &nbsp; ; 1st argument<br />&nbsp; &nbsp; %define&nbsp; &nbsp;  dst_buffer&nbsp; dword &nbsp; &nbsp; ; 2nd argument<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; push&nbsp; &nbsp; eax<br />&nbsp; &nbsp; push&nbsp; &nbsp; ebx<br />&nbsp; &nbsp; push&nbsp; &nbsp; ecx<br />&nbsp; &nbsp; push&nbsp; &nbsp; edx<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ; Conversion loop&nbsp; &nbsp;  <br />&nbsp; &nbsp; mov&nbsp; &nbsp;  edx, dst_buffer&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Pointer to string buffer&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; mov&nbsp; &nbsp;  eax, src_integer&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Integer to convert<br />&nbsp; &nbsp; xor&nbsp; &nbsp;  ecx, ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Clear loop counter<br /> conv_loop: <br />&nbsp; &nbsp; xor&nbsp; &nbsp;  ebx, ebx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Clear EBX <br />&nbsp; &nbsp; shl&nbsp; &nbsp;  eax, 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Shift leftmost bit into CF&nbsp;  <br />&nbsp; &nbsp; adc&nbsp; &nbsp;  ebx, &#039;0&#039;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Add with CF =&gt; BL contains byte to write to buffer&nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; mov&nbsp; &nbsp;  , bl&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Write to buffer <br />&nbsp; &nbsp; inc&nbsp; &nbsp;  ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Next loop iteration<br />&nbsp; &nbsp; cmp&nbsp; &nbsp;  ecx, 32<br />&nbsp; &nbsp; jne&nbsp; &nbsp;  conv_loop<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ; Cleanup <br />&nbsp; &nbsp; pop&nbsp; &nbsp;  edx<br />&nbsp; &nbsp; pop&nbsp; &nbsp;  ecx<br />&nbsp; &nbsp; pop&nbsp; &nbsp;  ebx<br />&nbsp; &nbsp; pop&nbsp; &nbsp;  eax<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ret&nbsp; &nbsp;  (2 * 4)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; 2 arguments * 4 bytes<br /><br /><br /></code></pre></div>
    <div class="meta">Posted on 2010-04-29 14:14:06 by !me</div>
   </div>
   <div class="post" id="post-211514">
    <div class="subject"><a href="#post-211514">Re: When to use registers vs local variables</a></div>
    <div class="body"><strong>!me</strong>,<br /><br />There is a catch in frameless functions: <em>relative (to <strong>esp</strong>) offsets of arguments/local variables change if you use stack</em>. Those <strong>push</strong>es move stack pointer 16 bytes down, now arguments are at <strong>dword </strong>.</div>
    <div class="meta">Posted on 2010-04-29 14:27:59 by baldr</div>
   </div>
   <div class="post" id="post-211515">
    <div class="subject"><a href="#post-211515">Re: When to use registers vs local variables</a></div>
    <div class="body">I thought so, actually.. IMO it gets a bit messy then, I think I&#039;ll just keep my stack frame for now, unless there is a major performance hit or something<br /><br />Thanks much for your help! </div>
    <div class="meta">Posted on 2010-04-29 15:06:57 by !me</div>
   </div>
   <div class="post" id="post-211516">
    <div class="subject"><a href="#post-211516">Re: When to use registers vs local variables</a></div>
    <div class="body"><strong>!me</strong>,<br /><br />There is another technique to manipulate bits: let&#039;s assume that <strong>ebx</strong> contains 0Bh (arbitrary 4-bit pattern, 1011). Multiply it by magic number (it has every 7th bit set):<br /><br /><pre><code><br />&nbsp; &nbsp; &nbsp; &nbsp; imul&nbsp; &nbsp; eax, ebx, 00000000001000000100000010000001b<br />; now eax == 0162C58Bh == 00000001011000101100010110001011b<br />&nbsp; &nbsp; &nbsp; &nbsp; and&nbsp; &nbsp;  eax, 0x01010101<br />; now eax == 01000101h == 00000001000000000000000100000001b<br />&nbsp; &nbsp; &nbsp; &nbsp; or&nbsp; &nbsp; &nbsp; eax, &#039;0000&#039;<br />; now eax == 31303131h<br /></code></pre><br /><br />Though there is a little problem — <strong>al</strong> contains binary digit for <em>the least significant</em> bit in <strong>bl</strong>. If we store <strong>eax</strong> as is, displayed digits will have reverse order. To restore proper order, <strong>bswap</strong> instruction can be used.<br /><br />BTW, that magic number can be easily built using expression (1 SHL ((32/7)*7) - 1)/(1 SHL 7 - 1), where 7 is the period.</div>
    <div class="meta">Posted on 2010-04-29 16:59:26 by baldr</div>
   </div>
   <div class="post" id="post-211517">
    <div class="subject"><a href="#post-211517">Re: When to use registers vs local variables</a></div>
    <div class="body">Now that is cool! I love hacks like that :P<br /><br />Does it have any advantages over the other algorithm (except from the added coolness-factor)?</div>
    <div class="meta">Posted on 2010-04-29 18:07:20 by !me</div>
   </div>
   <div class="post" id="post-211524">
    <div class="subject"><a href="#post-211524">Re: When to use registers vs local variables</a></div>
    <div class="body">Your mileage may vary. That depends on many factors, not the last of them being the CPU make/model.<br /><br />This approach shows possibility of pseudo-SIMD operation on plain i386, four bits are converted in parallel.<br /><br />Google for &quot;bithack&quot;, you may learn much from this. Google is your friend. ;-)</div>
    <div class="meta">Posted on 2010-04-30 09:01:22 by baldr</div>
   </div>
   <div class="post" id="post-211530">
    <div class="subject"><a href="#post-211530">Re: When to use registers vs local variables</a></div>
    <div class="body">I&#039;d say a rule of thumb is that you use registers for the most frequently modified values.<br />Registers are fastest, local variables are effectively cache variables, so they will have a bit more latency.<br />How many registers you use exactly, depends on the specific routine. Since in most cases, only eax, ecx and edx are considered &#039;volatile&#039;, all other registers have to be preserved by the callee (and likewise, if your routine uses eax, ecx and edx, it has to preserve those when it calls another function).<br />So it then depends on the cost of storing and restoring the registers vs the cost of using local variables (which are preserved when you call another function).</div>
    <div class="meta">Posted on 2010-04-30 11:55:18 by Scali</div>
   </div>
  </div>
 </body>
</html>