<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Can i include file jpeg instead bitmap - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16817" />
  <link rel="prev" href="../?id=16817&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=16817">Can i include file jpeg instead bitmap</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=16817&amp;page=1" style="">&laquo;</a><a href="../?id=16817&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="16817" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-135175">
    <div class="subject"><a href="#post-135175">Working code to display a jpeg</a></div>
    <div class="body"><div class="quote"><br />Been toying with your snippets for a while... this is the result.<br />Two issues:<br /><br />1. Since we're using the get_Handle method to get the bitmap (and then copying it), shouldn't we copy the pallete as well?<br /><br />2. Your function will get the RGB values of the transparent GIF, and AFAIK we should use the pallete entry instead. We might have a repeated color in the pallete, one transparent and the other opaque. That would mess up the transparency. Should be easy to fix as long as the IPicture object does not alter the image's original pallete values.<br /><br />BTW, my sample prog isn't even loading the picture... don't know why. :confused: </div><br /><br />This code works. At some point I would like to have the picture inserted into the .exe instead of in a separate<br />file.<br /><br />Thanks.<br /><br /><br />; showpic.asm  File location of jpeg is hardcoded into this<br />;  Includes Image file loading routines for the MASM32 library<br />;<br />;  This source and assosciated binary code is <br />;  Copyright ? 2001 by M Stoller Enterprises<br />;<br />;  Written by Ernest Murphy<br />;<br />; Not for commercial reproduction. No fee whatsoever may be imposed for <br />; transfering this file. Source files may be coppied only for educational use<br />; on a free basis.<br /><br /><br />386<br />.model flat,stdcall<br />option casemap:none<br /><br />WinMain proto :DWORD,:DWORD,:DWORD,:DWORD<br /><br />include \masm32\include\windows.inc<br />include \masm32\include\user32.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\masm32.inc<br />include \masm32\include\gdi32.inc<br />include \masm32\include\comctl32.inc<br />include \masm32\include\ole32.inc<br />include \masm32\include\oleaut32.inc<br />include image.inc<br /><br />includelib \masm32\lib\user32.lib<br />includelib \masm32\lib\masm32.lib<br />includelib \masm32\lib\kernel32.lib<br />includelib \masm32\lib\gdi32.lib<br />includelib \masm32\lib\ole32.lib <br />includelib \masm32\lib\oleaut32.lib <br />includelib \masm32\lib\COMCTL32.LIB<br />includelib image.lib<br /><br />.data<br />ClassName db &quot;SimpleWinClass&quot;,0<br />AppName  db &quot;Show a non-bmp image&quot;,0<br />OurText  db &quot;Win32 Executable - less than 5K too :-)      &quot;,0<br />szFile      BYTE    &quot;C:\masm32\BIN\german1.jpg&quot;,0<br />            <br /><br />.data?<br />hInstance HINSTANCE ?<br />CommandLine LPSTR ?<br />hBmp        DWORD   ?<br />.code<br />start:<br />	invoke GetModuleHandle, NULL<br />	mov    hInstance,eax<br />	invoke GetCommandLine<br />	invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT<br />	invoke ExitProcess,eax<br />WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD<br />	LOCAL wc:WNDCLASSEX<br />	LOCAL msg:MSG<br />	LOCAL hwnd:HWND<br />	mov   wc.cbSize,SIZEOF WNDCLASSEX<br />	mov   wc.style, CS_HREDRAW or CS_VREDRAW<br />	mov   wc.lpfnWndProc, OFFSET WndProc<br />	mov   wc.cbClsExtra,NULL<br />	mov   wc.cbWndExtra,NULL<br />	push  hInst<br />	pop   wc.hInstance<br />	mov   wc.hbrBackground,COLOR_WINDOW+1<br />	mov   wc.lpszMenuName,NULL<br />	mov   wc.lpszClassName,OFFSET ClassName<br />	invoke LoadIcon,NULL,IDI_APPLICATION<br />	mov   wc.hIcon,eax<br />	mov   wc.hIconSm,0<br />	invoke LoadCursor,NULL,IDC_ARROW<br />	mov   wc.hCursor,eax<br />	invoke RegisterClassEx, addr wc<br />	INVOKE CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\<br />           WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\<br />           CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\<br />           hInst,NULL<br />	mov   hwnd,eax<br />	INVOKE ShowWindow, hwnd,SW_SHOWNORMAL<br />	INVOKE UpdateWindow, hwnd<br />	.WHILE TRUE<br />                INVOKE GetMessage, ADDR msg,NULL,0,0<br />                .BREAK .IF (!eax)<br />                INVOKE TranslateMessage, ADDR msg<br />                INVOKE DispatchMessage, ADDR msg<br />	.ENDW<br />	mov     eax,msg.wParam<br />	ret<br />WinMain endp<br />WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM<br />	LOCAL hdc:HDC<br />	LOCAL ps:PAINTSTRUCT<br />	LOCAL rect:RECT<br />      LOCAL  tempDC:DWORD<br />      LOCAL  htbmp<br />	.IF uMsg==WM_DESTROY<br />		invoke PostQuitMessage,NULL<br />	.ELSEIF uMsg==WM_PAINT<br />		invoke BeginPaint,hWnd, ADDR ps<br />		mov    hdc,eax<br />		invoke GetClientRect,hWnd, ADDR rect<br />		invoke DrawText, hdc,ADDR OurText,-1, ADDR rect, DT_SINGLELINE or DT_RIGHT	;or DT_CENTER or DT_VCENTER<br />            invoke CreateCompatibleDC, hdc<br />        mov tempDC, eax<br />        invoke SelectObject, tempDC, hBmp<br />        mov htbmp, eax<br />        invoke BitBlt, hdc, 0,0,rect.right,rect.bottom, tempDC, 0, 0, SRCCOPY<br />        invoke SelectObject, tempDC, htbmp<br />        invoke DeleteDC, tempDC<br />		invoke EndPaint,hWnd, ADDR ps<br />      .ELSEIF uMsg==WM_CREATE<br />            invoke BitmapFromFile, ADDR szFile<br />;            invoke BitmapFromResource, hInstance, 2002<br />;            invoke BitmapFromResource, hInstance, 2001<br />            mov hBmp, eax<br />	.ELSE<br />		invoke DefWindowProc,hWnd,uMsg,wParam,lParam<br />		ret<br />	.ENDIF<br />	xor    eax,eax<br />	ret<br />WndProc endp<br />end start</div>
    <div class="meta">Posted on 2004-03-02 19:08:08 by skywalker</div>
   </div>
   <div class="post" id="post-135177">
    <div class="subject"><a href="#post-135177">Can i include file jpeg instead bitmap</a></div>
    <div class="body"><div class="quote"><br />Been toying with your snippets for a while... this is the result.<br />Two issues:<br /><br />1. Since we're using the get_Handle method to get the bitmap (and then copying it), shouldn't we copy the pallete as well?<br /><br />2. Your function will get the RGB values of the transparent GIF, and AFAIK we should use the pallete entry instead. We might have a repeated color in the pallete, one transparent and the other opaque. That would mess up the transparency. Should be easy to fix as long as the IPicture object does not alter the image's original pallete values.<br /><br />BTW, my sample prog isn't even loading the picture... don't know why. :confused: </div><br /><br />Hi QvasiModo,<br /><br />1. Since the returned handle is a rendering of the original image (it is not a bitmap after all) the IPicture interface does color correction (ICM) so the palette is not necessarily the same when it is loaded. I found that in my tests when using it in TBPaint that there were some horrible results when saving images loaded and saved with IPicture. Remember the early days of TBPaint when the greens etc.. were darker or lighter than the original. However I think that if you use the IPicture::KeepOriginalFormat method you can bypass this, I have never tried.<br /><br />2. My GIF transparency thingy actually finds the color by palette index, not by scanning the color table. You can have the index by preserving it from this :<br /><br />movzx eax,B<br /><br />EAX contains the palette index, the rest just looks up the color in the color table.<br /><br />3. I have found that it seems to make no difference on any Windows version if you pass a pointer returned from GlobalAlloc in place of a handle (including all GlobalXXX functions such as GlobalSize etc..), I geuss to be 100% certain you should pass an HGLOBAL instead but the two seem to be interchangeable.</div>
    <div class="meta">Posted on 2004-03-02 22:41:29 by donkey</div>
   </div>
   <div class="post" id="post-135184">
    <div class="subject"><a href="#post-135184">Can i include file jpeg instead bitmap</a></div>
    <div class="body"><div class="quote"><br />3. I have found that it seems to make no difference on any Windows version if you pass a pointer returned from GlobalAlloc in place of a handle (including all GlobalXXX functions such as GlobalSize etc..), I geuss to be 100% certain you should pass an HGLOBAL instead but the two seem to be interchangeable.<br /></div><br />My experience as well - and it makes sense, since win32 doesn't use the same handle+lock based system as win16, and all the 'normal' memory allocations end up allocating from the heap (including Global/LocalAlloc).<br /><br />However, there <strong>is</strong> a difference between the values returned with and without GMEM_FIXED - somebody with access to the NT source should have a look as to what is going on... :rolleyes: . It might be pedantic of me, but for the sake of safety, I'm doing the extra steps of GlobalLock and such.</div>
    <div class="meta">Posted on 2004-03-03 04:01:09 by f0dder</div>
   </div>
   <div class="post" id="post-135185">
    <div class="subject"><a href="#post-135185">Can i include file jpeg instead bitmap</a></div>
    <div class="body">No need for the source, the memory is allocated differently and there is no need for a handle at all...<br /><br /><div class="quote"><strong><em>From Managing Heap Memory in Win32<br />Randy Kath<br />Microsoft Developer Network Technology Group</em></strong><br /><br />It is surprising that the distinction between FIXED and MOVEABLE memory still exists in these functions. In Windows 3.1, MOVEABLE memory compacted the local and global heaps to reduce fragmentation and make more memory available to all applications. Yet the Windows NT virtual memory system does not rely on these techniques for efficient memory management and has little to gain by applications using them. In any case, they still exist and could actually be used in some circumstances.<br /><br />When allocating FIXED memory in Win32, the GlobalAlloc and LocalAlloc functions return a 32-bit pointer to the memory block rather than a handle as they do for MOVEABLE memory. The pointer can directly access the memory without having to lock it first. This pointer can also be passed to the GlobalFree and LocalFree functions to release the memory without having to first retrieve the handle by calling the GlobalHandle function. With FIXED memory, allocating and freeing memory is similar to using the C run-time functions _malloc and _free.</div></div>
    <div class="meta">Posted on 2004-03-03 04:18:49 by donkey</div>
   </div>
   <div class="post" id="post-135186">
    <div class="subject"><a href="#post-135186">Can i include file jpeg instead bitmap</a></div>
    <div class="body">Hmmm... however, that says nothing about<br /><br />*) What happens if you treat a &quot;handle&quot; (ie, no FIXED flag) return as a pointer?<br /><br />*) What happens when GlobalLock and, more importantly, GlobalUnlock, are called for a FIXED alloc pointer?<br /><br />The allocations done by Local/GlobalAlloc are done on the heap, but with some special/undocumented flags appended. It seems that, opposed to a straight HeapAlloc call, the memory region has some 8-byte structure prepended. If you use GMEM_FIXED you get a memory pointer, if you don't, you get a &quot;handle&quot; - which is this structure that's 8 bytes directly before the memory itself.<br /><br />I haven't looked into what's stored in this structure, but I have the impression that overwriting it &quot;might be bad&quot;. This is <strong>probably</strong> only an issue if you treat a 'handle' as a pointer, and not the other way around - treating a handle as a pointer would overwrite this structure, but functions <strong>might</strong> have some safechecking to see whether they're operating on pointers or 'handles'.</div>
    <div class="meta">Posted on 2004-03-03 04:42:18 by f0dder</div>
   </div>
   <div class="post" id="post-135201">
    <div class="subject"><a href="#post-135201">Can i include file jpeg instead bitmap</a></div>
    <div class="body">Mmm,<br /><br />I thought that the handles were acutally structures stored outside of the heap address space, that is that they are stored in some other location of memory in an table of structures. If you do not create a moveable chunk of memory the handle table is never created and calls to GlobalLock will simply return the same address, making it essentially interchangeable. For example :<br /><br /><pre><code>invoke GlobalAlloc,GMEM_FIXED,1024<br />mov &#91;pGlob&#93;,eax<br />invoke GlobalUnlock,&#91;pGlob&#93;<br />; eax == 1 ; success<br />invoke GlobalLock,&#91;pGlob&#93;<br />; eax == pGlob<br />invoke GlobalFree,&#91;pGlob&#93;</code></pre><br /><br />As you can see they are 100% interchangeable, even if a function assumes that you are passing it a handle, it must first lock the memory in order to write to or read from it and that will simply return the same pointer. GlobalUnlock always returns 1 which is correct in this context as the reference count remains locked at one reference. Ofcourse with a fixed reference count you cannot interchange the block with moveable memory in functions like DDE or the clipboard.</div>
    <div class="meta">Posted on 2004-03-03 14:51:34 by donkey</div>
   </div>
   <div class="post" id="post-135202">
    <div class="subject"><a href="#post-135202">Can i include file jpeg instead bitmap</a></div>
    <div class="body">I recall that some Win16 application code actually used this information, so the feature was retained for porting code. I don't remember which Win16 book detailed this information.</div>
    <div class="meta">Posted on 2004-03-03 14:53:47 by tenkey</div>
   </div>
   <div class="post" id="post-135204">
    <div class="subject"><a href="#post-135204">Can i include file jpeg instead bitmap</a></div>
    <div class="body">Ok, I guess there's no problem with using a GMEM_FIXED pointer in place of a 'handle' then - as long as you don't use a 'handle' as a memory pointer :)</div>
    <div class="meta">Posted on 2004-03-03 14:58:15 by f0dder</div>
   </div>
   <div class="post" id="post-135205">
    <div class="subject"><a href="#post-135205">Can i include file jpeg instead bitmap</a></div>
    <div class="body">Hi Tenkey,<br /><br />Yeah, I think that in order to retain compatibility with Win16 the clipbaord and DDE was required to retain the moveable memory concept and as far as I can tell they are the only things left that rely on the handles as they must unlock the memory so they check that the reference count is 0 before proceding. Besides that I can't find another example that absolutely requires a 0 reference count.<br /><br />PS nice that the board is running smoothly again :)</div>
    <div class="meta">Posted on 2004-03-03 15:00:40 by donkey</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=16817&amp;page=1" style="">&laquo;</a><a href="../?id=16817&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="16817" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>