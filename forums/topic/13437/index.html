<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>image-moving in lfb - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=13437" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=13437">image-moving in lfb</a></p>
   <div class="post" id="post-104077">
    <div class="subject"><a href="#post-104077">image-moving in lfb</a></div>
    <div class="body">hi all!<br /><br />i currently about to write a gui for my &quot;os&quot;. when moving a window i dont want to draw everything new. i want to move the image containing the window-rectangle. it ain't fast anymore on 300*200 px. this is what i have.<br /><br /><pre><code><br />movewindow&#58;<br />;param<br />;  ebx | loword&#58; source x-pos<br />;      | hiword&#58; source y-pos<br />;  ecx | loword&#58; destination x-pos<br />;      | hiword&#58; destination y-pos<br />;  edx | loword&#58; width<br />;      | hiword&#58; height<br />s_x    equ &#91;ebp+8&#93;<br />s_y    equ &#91;ebp+10&#93;<br />d_x    equ &#91;ebp+4&#93;<br />d_y    equ &#91;ebp+6&#93;<br />width  equ &#91;ebp&#93;<br />height equ &#91;ebp+2&#93;<br /><br />  push ebx<br />  push ecx<br />  push edx<br />  push ebp<br />  lea ebp,&#91;esp+4&#93;<br /><br />  xor eax,eax<br />  movewindow.y&#58;<br />    push eax<br />    xor eax,eax<br />    movewindow.x&#58;<br />      push eax<br />      ;x-counter&#58; &#91;esp&#93;<br />      ;y-counter&#58; &#91;esp+4&#93;<br />      mov ax,s_y<br />      cmp ax,d_y<br />      jge movewindow.bottom2top<br />        mov si,word &#91;esp+4&#93;<br />        shl esi,16 ;y-offset to higher word<br />        <br />        mov ax,s_x<br />        cmp ax,d_x<br />        jge movewindow.bottom2top.left2right<br />          mov si,word &#91;esp&#93; ;x-offset to lower word<br />         jmp movewindow.draw<br />        movewindow.top2bottom.left2right&#58;<br />          mov si,width<br />          sub si,word &#91;esp&#93;<br />         jmp movewindow.draw<br />      movewindow.bottom2top&#58;<br />        mov si,word &#91;esp+4&#93;<br />        shl esi,16<br />        <br />        mov ax,s_x<br />        cmp ax,d_x<br />        jge movewindow.bottom2top.left2right<br />          mov si,word &#91;esp&#93;<br />         jmp movewindow.draw<br />        movewindow.bottom2top.left2right&#58;<br />          mov si,width<br />          sub si,word &#91;esp&#93;          <br />     movewindow.draw&#58;<br />      mov ebx,dword s_x<br />      add ebx,esi<br />      call getpixel<br />      mov ecx,eax<br />      mov ebx,dword d_x<br />      add ebx,esi<br />      call putpixel<br />      pop eax<br />      inc eax<br />      cmp ax,width<br />    jl movewindow.x<br />    pop eax<br />    inc eax<br />    cmp ax,height<br />  jl movewindow.y<br />  pop ebp<br />  pop edx<br />  pop ecx<br />  pop ebx<br />  ret<br /></code></pre><br /><br />note that putpixel and getpixel have the coordinate in ebx, y in hiword, x in loword. this function checks for screen-range and calculates the position in the memory to put the pixel. i know, this is the slow part, i'd love to use rep movsd, but i can't due to range-checking.<br />so does anybody have an idea how to directly access the lfb (not by put- and getpixel), but keeping the range-checking? i would be dimensions faster if i could access the next pixel just by adding 4 to a counter.<br />btw, maybe there is any hardware-possibility to do that? i've heard of the pm-interface of vesa, but i actually don't know how to use it.<br /><br />greets, hartyl</div>
    <div class="meta">Posted on 2003-05-20 14:11:53 by hartyl</div>
   </div>
   <div class="post" id="post-104349">
    <div class="subject"><a href="#post-104349">image-moving in lfb</a></div>
    <div class="body">oh man, nobody out there who can help me?<br /><br />i've played around with it today. i noticed that when i move out a window partially the moving works incredibly fast (almost realtime). i thought &quot;ok, put- and getpixel do rangechecking, the functions only calculate the memory-address if i am in range&quot;. so i modified the code that it <strong>always</strong> calculates the memory-address, then comes the range checking and only if it was successful i do the last move to the lfb. and guess what: it went as slow as before, so i figured out that not the calculating is slow, the actual pixel-putting is.<br /><br />2 questions:<br />could it be the problem that i have to do monitor-synchronizing (wait for retrace)? how would i do that?<br />where is really the memory of the lfb? on the gfx-card or in ram? is it slow to write there?</div>
    <div class="meta">Posted on 2003-05-22 14:37:56 by hartyl</div>
   </div>
   <div class="post" id="post-104354">
    <div class="subject"><a href="#post-104354">image-moving in lfb</a></div>
    <div class="body">Man,<br /><br />1)<br />Unfortunately on curent &quot;modern&quot; - hardware accelerated - video boards you are not allowed to READ from video memory. It is possible BUT doing so gives you BIG slowdown.<br /><br />Look at my OS i always rewrite everything but it is a one way operation i a;ways PUT data on video memory NEVER read it from there<br /><br />2) DO not make 2 CALL's inside your INNER loop man... inline getpixe/putpixel there<br /><br />3) The whole thing looks WAY too much complicated and general...such code is more likely a HLL construct. SIMPLYFY!. <br /><br />4) IMHO -- DO not play with Stack THAT way : you do not NEED it (esp when you make 2 CALL's inside inner loop) -- go for standard ebp usage for params instead --  keep code simple until you can see it right<br /><br /><br />The LFB memory is in video card's own RAM.<br />Writting there is SLOWer than system RAM ...  but not THAT slow as READ!!!<br />I will check it out more when i have time but as a general personal impresion the whole thing is too much unoptimized. <br /><br />Keep inner loop as small as possible</div>
    <div class="meta">Posted on 2003-05-22 15:50:09 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-104499">
    <div class="subject"><a href="#post-104499">image-moving in lfb</a></div>
    <div class="body">neither the loop nor the 2 calls inside are that slow, as you told me, the reading is. i just wanted to test my code thats why its unoptimized and simple. hey, its temporary code. the conditions are just to check whether i have to move from left to right or from right to left, with top and bottom its also done. real speed optimizing comes later.<br /><br />ok... the reading from lfb is the problem... but i have to... i had an idea right now:<br />what about keeping a complete copy of lfb in memory, putpixel writes to both buffers, but getpixel reads from the copy. but this alone would need 1024*768*4=3MB and with changing screensize this would change either.<br /><br />any other ideas?</div>
    <div class="meta">Posted on 2003-05-23 11:20:27 by hartyl</div>
   </div>
   <div class="post" id="post-104510">
    <div class="subject"><a href="#post-104510">image-moving in lfb</a></div>
    <div class="body">I can see no other solution but to use hardware accelerated BLIT  to do the move, blitting from video memory to video memory via the hardware blitter is extreemly fast...<br /><br />Unfortunately in order to do this you must have a special driver for every video board out there as there is NO standard/ no documentation, or the VBE AF standard is so secret and its specs cost approx a few thousand US$<br /><br />Personaly i use a memory buffer --for the LFB-- in system RAM and ONLY write from this buffer to video memory<br /><br />I still think your code is very complicated for my taste, but i recognise it might be ok for you, and for sure you underestimate the damage that 2 Call's will do to your iinner loop ... IMHO of course.<br /><br />I must also point it out to you that you will need to redraw the windows UNDER the window you are moving using such code so this makes this kind of move useless in the long run, you still have to have a function to redraw/regenerate each window elemets via a call to code. <br /><br />This remake of the window (usually involving ONLY writes) MIGHT just be fast enough to make READ+WRITE COPY useless (even if for smaller sizes)</div>
    <div class="meta">Posted on 2003-05-23 12:09:32 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-104523">
    <div class="subject"><a href="#post-104523">image-moving in lfb</a></div>
    <div class="body">you're right, i have to redraw everything below the window - but thats not the problem. i wanted to really &quot;move&quot; the window as i thought this would be easy and fast, i dont have to care about redrawing the window itself. furthermore i dont want to drag a frame and then draw a window there if the mouse is released.<br /><br />as i reduced my plans that its not possible to move the window out of the screen it is possible to use the hardware-bitblt and the moved window doesn't have to be redrawn.  i think that the pm-interface of vesa has some standards. i've found informations about it before in Ralf Browns interrupt list, i'll try this when i have time.<br /><br />actually i turned away from my buffer-idea. i don't like wasting 8megs of memory just as a copy of the screen.<br /><br />i'll tell you when i'm finished</div>
    <div class="meta">Posted on 2003-05-23 13:22:34 by hartyl</div>
   </div>
   <div class="post" id="post-104525">
    <div class="subject"><a href="#post-104525">image-moving in lfb</a></div>
    <div class="body">1024x768x32bits will be ~ 3.14Megabytes<br /><br />If the target system is low on ram i guess it can go on 800x600 or 640x480<br /><br />If the target system is embeded system then it is possible that read from the video device is not that slow (or write not that fast -- hehe ).<br /><br />Double buffering is a good ideea  for some other things like: flicker free animations or window move and translucent windows :P<br /><br />But indeed on a very limited RAM system i would also go for direct video device memory access also<br /><br />Clipping the blits is not THAT ard esp IF only rectangles are involved.<br /><br />I suggest the DX method of using 2 rectangles one for source and one for destination, both can be very easy clipped to new rectangles that DO NOT cross the screen borders IMHO<br /><br /><br />So  I decided to wasted a double buffer on SOLAR OS for translucent windows :P, most games do that all the time anyway to avoid flicker.<br /><br />RAM is a resource that modern CPU/OS/PCs should have plenty of .... IMHO<br /><br />Good luck...</div>
    <div class="meta">Posted on 2003-05-23 13:33:59 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-104585">
    <div class="subject"><a href="#post-104585">image-moving in lfb</a></div>
    <div class="body">initially i also wanted to do translucent windows, but with the gui i went about it, i can't do that. redrawing everything for everyframe is a very slow process i wanted to avoid.<br />i've just planned to involve only rectangle-windows (on the long time of windows-programming i've never needed different shapes...)<br />this weekend i'll take the time and do what i mentioned: implement a hardware-bitblt-function.</div>
    <div class="meta">Posted on 2003-05-24 09:11:45 by hartyl</div>
   </div>
   <div class="post" id="post-104600">
    <div class="subject"><a href="#post-104600">image-moving in lfb</a></div>
    <div class="body">If you succed into using hardware BLIT in your own OS please let me know, i am interested, even if it is only for a few well known video boards like nVidia and ATI :D<br /><br />The redraw all windows all times is not THAT slow as you expect, my os can do this decently on P2 400+ CPUs. esp because of the above talked WRITE ONLY aspect of today video memory<br /><br />But i agree most of the time there is no need to do this --aka when nothing changes on screen -- however when many contents changes during each frame  (like in games or animations or very active contents) this method is quite efective...and i must mention : very simple to implement and understand<br /><br />I expect myself to develop some dirty rectangles algorithm and update only THAT active parts each frame --- when i will go to optimizations phase in SOLAR OS... <br /><br />... curentky is just ok as it is == not too fast but very simple and easy to understand --&gt; is good while developing IMHO</div>
    <div class="meta">Posted on 2003-05-24 11:19:11 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-104885">
    <div class="subject"><a href="#post-104885">image-moving in lfb</a></div>
    <div class="body">hardware blitting can't be that difficult, out of ralf browns interrupt list, here is what i already know. and it seems easy to use and understand:<br /><br />- use int 10 with subfunction 0x4f0b to get a &quot;device context buffer&quot;. you get a list of pointers you can call from pm.<br />- the pointer in offset 0x24 is the bitblt-function. usually its call by register, but in that case there are too many params. so a pointer to a parameter block:<br /><br />ES:EDI -&gt; device context buffer<br />DS:ESI -&gt; BitBlt parameter block<br />BL = mix operation<br />    00h replace<br />    01h XOR<br />    02h OR<br />    03h AND<br /><br />with the following format:<br />Offset	Size	Description<br /> 00h	WORD	left coordinate of source rectangle<br /> 02h	WORD	top coordinate of source rectangle<br /> 04h	WORD	right coordinate of source rectangle<br /> 06h	WORD	bottom coordinate of source rectangle<br /> 08h	WORD	left coordinate of destination rectangle<br /> 0Ah	WORD	top coordinate of destination rectangle<br /> 0Ch	BYTE	horizontal direction: 00h = decrement X, 01h = increment X<br /> 0Dh	BYTE	vertical direction: 00h = decrement Y, 01h = increment Y</div>
    <div class="meta">Posted on 2003-05-26 13:47:32 by hartyl</div>
   </div>
   <div class="post" id="post-105008">
    <div class="subject"><a href="#post-105008">damnit, a draft!</a></div>
    <div class="body">i didn't read the small-printed.<br /><pre><code><br />Note&#58;	this interface description is derived from the draft VBE/AF proposal<br />	  &#40;version 1.0P, document revsion 0.12P, dated 13jan95&#41;<br /></code></pre><br />...<br />i tried this function to get a device context buffer, but actually the subfunction 0x4f0b is listed twice. the second one is &quot;get nearest pixel clock&quot;. so, when i call it i get a pixel-clock in ecx, not a device context buffer.<br />so... redraw the window itsself on moving too... and i gotta tell you, i don't like it that way.<br />i'll take some time right now to find a good screen-to-screen bitblt...</div>
    <div class="meta">Posted on 2003-05-27 13:20:34 by hartyl</div>
   </div>
   <div class="post" id="post-105278">
    <div class="subject"><a href="#post-105278">image-moving in lfb</a></div>
    <div class="body">First things first: <strong>NEVER trust the documentations</strong><br /><br />I have had a hard time explaining generation after generation of DX programmers that alphablending is NOT implemented in DirectDraw EVEN IF it is mentioned and promised at each DX release :D. Even today when GDI+ can do Alpha blending using hardware, DirectDraw stii can not do it, well the latest DX7 :P, the fact that you have to use 3D to do that is just plain pathetic, since THEY obviousely use it in GDI and any normal GUI will need it (2D) ...but doh ...<br /><br /><br />I would also like to get a hold of the good VBE-AF documentation....  but i do not have the required money :(<br />info about accelerated 2D and 3D functions at hardware level for NVidia and ATI and other video boards are my greatest dreams...not to mention network boards, AGP etc<br /><br />things are hard for OS developers, information is keept secret etc, we have only ourself and the comunity to help, ah ..... also Linux sourcecode :P</div>
    <div class="meta">Posted on 2003-05-29 09:11:51 by BogdanOntanu</div>
   </div>
  </div>
 </body>
</html>