<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>real randomizer - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=11188" />
    <link rel="next" href="../?id=11188&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=11188">real randomizer</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=11188&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=11188&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="11188" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=11188&amp;page=2">&gt;</a><a href="../?id=11188&amp;page=2">&raquo;</a></form>   <div class="post" id="post-84363">
    <div class="subject"><a href="#post-84363">real randomizer</a></div>
    <div class="body">Hello,<br /><br />Is possible a _real_ randomizer to generate quickly many (millions+) rendom numbers to not repeat the order aswhile the variation range is exploited. I had quick look at C's _rand but it's just a formula. Also mixing results from variety of time funcs are comming to my mind but their problem is very slow change of the result (one sec) thus generation alots of same 'random' numbers in one chunk. I'd be very grateful if there's a real random algo.<br /><br />Perhaps to apply an analogic component unit to my Intel , sigh ;o)</div>
    <div class="meta">Posted on 2003-03-01 17:32:15 by _Servil_</div>
   </div>
   <div class="post" id="post-84376">
    <div class="subject"><a href="#post-84376">real randomizer</a></div>
    <div class="body">You can't get real random algo. <br /><br />I wonder though, if you could get access to the raw binary feed than comes in through the modem and at the same time pick up your phone and blow onto it would that create a random binary string. Hmmmmm, maybe not :(</div>
    <div class="meta">Posted on 2003-03-01 18:35:14 by Eóin</div>
   </div>
   <div class="post" id="post-84383">
    <div class="subject"><a href="#post-84383">real randomizer</a></div>
    <div class="body"><strong>Stephen Wolfram</strong>, the guy that wrote <a target="_blank" href="http://www.wolfram.com">Mathematica</a> and a book I'm reading ( <a target="_blank" href="http://www.wolframscience.com">A New Kind of Science</a> ) uses cellular automata for the random numbers/data.  Basically, put some psuedo random data in a buffer as large as needed - I like to use:<pre><code>	RDTSC<br /><br />_2&#58;	rcr	eax, 1<br />	jnc	_4<br /><br />	RDTSC<br /><br />_4&#58;	adc	eax, edx<br />	mov	&#91;edi + esi*4&#93;, eax<br />	dec	esi<br />	jns	_2</code></pre>...sensitive dependance on initial conditions is the only reason I use this code.  After the buffer is initialized use some automata rule that produces psuedo randomness.  Here is the code I created based on the description in the book:<pre><code>	; load rule lookup register<br />	movzx	eax, BYTE PTR &#91;ebx&#93;.rule.rule<br />	; all four bytes are same!<br />	mov	edx, 01010101h<br />	mul	edx<br />	mov	ebx, eax<br /><br />	mov	ebp, &#91;esi + ecx*4&#93;<br />	bswap	ebp<br />	mov	edx, ebp ; ?<br />	rol	edx, 2<br />;	xor	edx, edx ; ?<br />	inc	ecx<br />_3&#58;<br />; edx = ...| -2 | -1 | 0<br />	shr	edx, 2		; get bit -1<br />	rcl	ebp, 3		; 3 |...| 31 | -1 | 0 | 1<br />	; save bit 2<br />	adc	edx, edx	; ? |...| ? | 2<br /><br />; rule bit 0<br />	bt	ebx, ebp<br />	rcl	eax, 1<br /><br />	; put bit 2 back<br />	rcr	edx, 1		; ? |...| ?<br />	rcr	ebp, 3		; 0 | 1 | 2 | ... | 31<br />	rol	ebp, 3		; 3 |...| 31 | 0 | 1 | 2<br /><br />	REPEAT 32-3<br />	; rule bit 1 thru 29<br />		bt	ebx, ebp<br />		rcl	eax, 1<br />		rol	ebp, 1<br />	ENDM<br />	bt	ebx, ebp<br />	rcl	eax, 1<br /><br /><br />	mov	edx, &#91;esi + ecx*4&#93;<br />	bswap	edx<br /><br />	shld	ebp, edx, 1<br />; rule bit 31<br />	bt	ebx, ebp<br />	rcl	eax, 1<br /><br />	xchg	edx, ebp<br /><br /><br />	bswap	eax<br />	mov	&#91;edi + ecx*4 - 4&#93;, eax<br />	inc	ecx<br />	jne	_3</code></pre>It is optimized a little.  The resulting bit is based on the previous bit and the bit on both sides of that bit.  Attached is a program that produces lots of random data.  Note how local features can be seen, but no long range features are predicatable (Rule 105).  There are a variety of rules to produce different size features - depending on what scale of randomness is needed.</div>
    <div class="meta">Posted on 2003-03-01 20:02:37 by bitRAKE</div>
   </div>
   <div class="post" id="post-84387">
    <div class="subject"><a href="#post-84387">real randomizer</a></div>
    <div class="body"><div class="quote"><br />You can't get real random algo. <br /></div><br /><br />I don't quite understand the random concept..<br />Something may only seem random..?<br />I mean like chaotic system, like of fractals and stuff, they seem produce random result but there is a system behind it<br />So it's not really random, or? It's not random if there was a system behind it?<br /><br />If a 'real random algo' could exist theoretically, how would it work like?<br /><br />:stupid:</div>
    <div class="meta">Posted on 2003-03-01 20:37:33 by david</div>
   </div>
   <div class="post" id="post-84389">
    <div class="subject"><a href="#post-84389">real randomizer</a></div>
    <div class="body">Good question <strong>david</strong>.  Personnally, I say there is no randomness - only complexity.</div>
    <div class="meta">Posted on 2003-03-01 20:40:31 by bitRAKE</div>
   </div>
   <div class="post" id="post-84440">
    <div class="subject"><a href="#post-84440">real randomizer</a></div>
    <div class="body"><strong></strong><br />The imponderable. :)</div>
    <div class="meta">Posted on 2003-03-02 03:57:04 by Maverick</div>
   </div>
   <div class="post" id="post-84474">
    <div class="subject"><a href="#post-84474">real randomizer</a></div>
    <div class="body">By quantum mechanics and uncertainty princilpes there is true randomness....</div>
    <div class="meta">Posted on 2003-03-02 06:55:44 by Eóin</div>
   </div>
   <div class="post" id="post-84475">
    <div class="subject"><a href="#post-84475">real randomizer</a></div>
    <div class="body"><strong></strong><br />But String theory has a more convincing explanation, which is much different than Quantum one. ;)</div>
    <div class="meta">Posted on 2003-03-02 07:21:48 by Maverick</div>
   </div>
   <div class="post" id="post-84490">
    <div class="subject"><a href="#post-84490">real randomizer</a></div>
    <div class="body">and also not to forget the second rule of thermodynamics,the entropy.<br /><br />Regards,<br /><br />Vortex</div>
    <div class="meta">Posted on 2003-03-02 09:22:58 by Vortex</div>
   </div>
   <div class="post" id="post-84511">
    <div class="subject"><a href="#post-84511">real randomizer</a></div>
    <div class="body">When a child comes into the world all things seem random - we are still children in the universe.</div>
    <div class="meta">Posted on 2003-03-02 11:40:49 by bitRAKE</div>
   </div>
   <div class="post" id="post-84804">
    <div class="subject"><a href="#post-84804">real randomizer</a></div>
    <div class="body">RC4 is very good for pseudo-random bit-streams.</div>
    <div class="meta">Posted on 2003-03-03 16:52:42 by comrade</div>
   </div>
   <div class="post" id="post-85087">
    <div class="subject"><a href="#post-85087">real randomizer</a></div>
    <div class="body">What do you mean by random?<br />- hard for an attacker to predict: gather all sorts of entropy, stuff it in a buffer, and (crypto) hash it. See linux drivers/char/random.c<br />- totally non-deterministic: I've read about a hardware RNG in Intels 845 chipset (principle: sample thermal noise). That would be ideal, if everyone had it, and I knew how to get at it ;)<br />- the intuitive definition: just about any PRNG will do (although these are deterministic 'formulas'). Mersenne Twister is one such algorithm that's better (longer period, better distribution of esp. the low bits) than VC's rand(), albeit slower.<br /><br />HTH<br />Jan</div>
    <div class="meta">Posted on 2003-03-04 19:23:07 by Jan Wassenberg</div>
   </div>
   <div class="post" id="post-85231">
    <div class="subject"><a href="#post-85231">real randomizer</a></div>
    <div class="body">Hello,<br /><br />Sure only way of real randomizer is additional hardware.<br /><br />I haven't fully clear what to look for first, now RANROT/Mother algo which is claimed to have extreme live period and quite chaotic behaviour seems to be sufficient, though pseudo.<br /><br />Also I was thinking the seed should be de-synchronized after certain pass count, eg. by time value as background traffic makes the intervals slightly different. I think de-sync frequency is indirectly related to quality of random generating function, and may be useless for this algorithm.<br /><br />Just came into doubt if it won't make yet worse on condition the data I'm trying to decrypt could be generated by std. _rand() func. ;o)<br /><br />Thanks for all infos ...<br />servil</div>
    <div class="meta">Posted on 2003-03-05 12:26:42 by _Servil_</div>
   </div>
   <div class="post" id="post-85690">
    <div class="subject"><a href="#post-85690">real randomizer</a></div>
    <div class="body">Hi All,<br /><br />I read a very interesting paper on the nature of randomness and a comparison of two effective pseudo random number generators (PRNGs), the Park-Miller algorithm which many are probably aware of, but also one known as The Mersenne Twister which appears to have some advantages over the former.<br /><br />The Twisted Road to Randomness<br /><a target="_blank" href="http://www.coyotegulch.com/algorithm/libcoyote/TwistedRoad/TwistedRoad.html">http://www.coyotegulch.com/algorithm/libcoyote/TwistedRoad/TwistedRoad.html</a><br /><br /><br />I've been researching Genetic Algorithm (GA) programming lately, as used as a stochastic model in applications such as AI, neural net, fractal generation, many forms of predictive analysis and so on.  I'm fascinated in how it's implemented as a generational model of natural populations, using the concepts of population size, fitness and reproduction success, crossover and mutation rates, all creating a method of problem solving.  <br /><br />Naturally a good random number generator is of prime (no pun) interest in creating an initial random population of values to begin with. I've been working on a GA model to use as an input application to play with any number of GA ideas, perhaps graphic representation or fractals at some point, perhaps encryption algos, perhaps just creating my own little menagerie of creatures, a zoo of bits and bytes... In any case...<br /><br />The paper I mentioned describes the Park-Miller PRNG (pseudo random number generator) algo and its optimum parameters:<br /><br />-- ------------------<br />Ni+1 = (a ? Ni + c) mod m<br /><br />&quot;Numerical research by S. K. Park and K. W. Miller has identified a theoretical &quot;best&quot; set of parameters. For the linear congruential algorithm to be effective, a and m can take on only a very few values, with m most certainly being prime. <br />Park and Miller identified the parameter values a = 16807, m = 2147483647, c = 0 as producing the most statistically-random values for 32-bit signed integers. For producing 16-bit values, a good set of parameters is a = 171, m = 30269, c = 0. If an application requires 32-bit numbers, Park and Miller suggested a = 42871 or a = 69621.&quot;<br />-------------------<br /><br />I quite Thank! NaN for the Park-Miller algo source I've been using, but I'd mention that the 'magic numbers' used (16807, 127773, 2836 if I'm interpreting it right) are slightly different from the above recommended ones.  I haven't got a way of accurately testing them one way or the other at the moment.  Any PRNG will eventually generate its initial seed again and the values will start repeating themselves.  For a small population this isn't critical, but for some applications it could be.<br /><br /><br />The Mersenne Twister algorithm sounds interesting as an option to the Park-Miller<br /><a target="_blank" href="http://www.math.keio.ac.jp/~matumoto/emt.html">http://www.math.keio.ac.jp/~matumoto/emt.html</a><br /><a target="_blank" href="http://www.math.keio.ac.jp/~nisimura/random/doc/mt.pdf">http://www.math.keio.ac.jp/~nisimura/random/doc/mt.pdf</a><br /><br />-----------------<br />..appealing aspects of the Mersenne Twister is its use of binary operations -- as opposed to time- consuming multiplication -- for generating numbers. <br /><br />.. algorithm's period is ~10^6001, as compared to a period of ~10^8 for the best variants of the linear congruential methods -- in other words, for practical purposes, the Mersenne Twister doesn't repeat itself. <br /><br />..the basic algorithm generates 32-bit integers, which provide a greater granularity than 16-bit linear congruential generators. Granularity allows finer distinctions between individual values and is particularly important when dealing with floating-point numbers. <br /><br />Smaller granularity means a broader range of results, which is required by stochastic algorithms that solve large problems to a fine degree.<br />-----------------<br /><br />Unfortunately there's no sweet MASM implementation of this code... Yet?? !! :D<br /><br />Cheers,<br />Kayaker<br /><br />EDIT: I see Jan already mentioned the Mersenne Twister, maybe we can learn more?</div>
    <div class="meta">Posted on 2003-03-07 21:20:03 by Kayaker</div>
   </div>
   <div class="post" id="post-85778">
    <div class="subject"><a href="#post-85778">real randomizer</a></div>
    <div class="body">I don't think its MASM, but Anger Fog distributes his Mersenne twister source code <a target="_blank" href="http://www.agner.org/random/randoma.htm">here</a> along with others. Most already know of Ranrot.</div>
    <div class="meta">Posted on 2003-03-08 07:00:53 by Eóin</div>
   </div>
   <div class="post" id="post-85813">
    <div class="subject"><a href="#post-85813">real randomizer</a></div>
    <div class="body">My mistake, on closer reading there is a MASM 6 version of the Mersenne Twister written by Sterling Stuart Stein<br /><br /><a target="_blank" href="http://www.math.keio.ac.jp/~matumoto/CODES/S3mt.zip">http://www.math.keio.ac.jp/~matumoto/CODES/S3mt.zip</a><br /><br />Thanks for the Agner link as well, very nice.<br /><br />Kayaker</div>
    <div class="meta">Posted on 2003-03-08 10:31:42 by Kayaker</div>
   </div>
   <div class="post" id="post-85822">
    <div class="subject"><a href="#post-85822">real randomizer</a></div>
    <div class="body">There have been some changes to the array initialization code to improve the randomness:<br /><br /><a target="_blank" href="http://www.math.keio.ac.jp/~matumoto/MT2002/emt19937ar.html">http://www.math.keio.ac.jp/~matumoto/MT2002/emt19937ar.html</a><br /><a target="_blank" href="http://www.math.keio.ac.jp/matumoto/CODES/MT2002/mt19937ar.c">http://www.math.keio.ac.jp/matumoto/CODES/MT2002/mt19937ar.c</a><br /><br />The convertion to ASM is rather straight forward:<pre><code>init_genrand PROC seed&#58;DWORD<br />	; See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier.<br />	; In the previous versions, MSBs of the seed affect<br />	; only MSBs of the array mt&#91;&#93;.<br />	; 2002/01/09 modified by Makoto Matsumoto<br />	mov	eax, seed<br />	mov	ecx, 0<br />; mt&#91;mti&#93; = &#40;1812433253UL * &#40;mt&#91;mti-1&#93; ^ &#40;mt&#91;mti-1&#93; &gt;&gt; 30&#41;&#41; + mti&#41;; <br />@@&#58;	mov	&#91;mt + ecx*4&#93;, eax<br />	inc	ecx<br />	cmp	ecx, N<br />	je	@F<br />	mov	edx, eax<br />	shr	eax, 30<br />	xor	eax, edx<br />	mov	edx, 6C078965h<br />	mul	edx<br />	add	eax, ecx<br />	jmp	@B<br />@@&#58;	mov	&#91;mti&#93;, ecx<br />	ret<br />init_genrand ENDP</code></pre></div>
    <div class="meta">Posted on 2003-03-08 11:17:58 by bitRAKE</div>
   </div>
   <div class="post" id="post-85864">
    <div class="subject"><a href="#post-85864">real randomizer</a></div>
    <div class="body">Here is my conversion:<pre><code>; Period parameters<br />N		EQU 624<br />M		EQU 397<br />MATRIX_A	EQU 09908B0DFh	; constant vector a<br />UPPER_MASK	EQU 080000000h	; most significant w-r bits<br />LOWER_MASK	EQU 07FFFFFFFh	; least significant r bits<br /><br /><br /><br />_BSS SEGMENT<br />	mti	dd ?		; mti==N+1 means mt&#91;N&#93; is not initialized<br />	mt	dd N dup&#40;?&#41;	; the array for the state vector<br />_BSS ENDS<br /><br /><br />	ALIGN 16<br /><br />init_genrand PROC seed&#58;DWORD<br />	; See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier.<br />	; In the previous versions, MSBs of the seed affect<br />	; only MSBs of the array mt&#91;&#93;.<br />	; 2002/01/09 modified by Makoto Matsumoto<br />	mov	eax, seed<br />	xor	ecx, ecx<br />	mov	seed, 6C078965h<br /><br />	ALIGN 16<br /><br />; mt&#91;mti&#93; = &#40;1812433253UL * &#40;mt&#91;mti-1&#93; ^ &#40;mt&#91;mti-1&#93; &gt;&gt; 30&#41;&#41; + mti&#41;; <br />@@&#58;	mov	&#91;mt + ecx*4&#93;, eax<br />	inc	ecx<br />	cmp	ecx, N<br />	je	@F<br />	mov	edx, eax<br />	shr	eax, 30<br />	xor	eax, edx<br />	mul	seed<br />	add	eax, ecx<br />	jmp	@B<br />@@&#58;	mov	&#91;mti&#93;, -N<br />	ret<br />init_genrand ENDP<br /><br /><br />	ALIGN 16<br /><br />; generates a random number on &#91;0,0xffffffff&#93;-interval<br />genrand_int32 PROC<br />	mov	eax, &#91;mti&#93;<br />	inc	&#91;mti&#93;<br />	js	get_rand<br />; leave this to the programmer!<br />;	je	@F			; if init_genrand&#40;&#41; has not been called,<br />;	invoke init_genrand, 5489	; a default initial seed is used<br />;@@&#58;<br /><br />	; generate N words at one time<br />	;-----------------------------<br /><br />;  for &#40;kk=0;kk&lt;N-M;kk++&#41; &#123;<br />;    y = &#40;mt&#91;kk&#93; &amp; UPPER_MASK&#41; | &#40;mt&#91;kk+1&#93; &amp; LOWER_MASK&#41;;<br />;    mt&#91;kk&#93; = mt&#91;kk+M&#93; ^ &#40;y &gt;&gt; 1&#41; ^ mag01&#91;y &amp; 0x1UL&#93;;<br />;  &#125;<br />	mov	ecx, -&#40;N-M&#41;<br />	MT EQU &lt;&#40;mt+&#40;N-M&#41;*4&#41;&gt;			; forward through memory<br /><br />_1&#58;	mov	edx, &#91;MT + ecx*4&#93;<br />	mov	eax, &#91;MT + ecx*4 + 4&#93;<br />	and	edx, UPPER_MASK<br />	and	eax, LOWER_MASK<br />	;<br />	or	eax, edx			; y<br />	;<br />	shr	eax, 1<br />	sbb	edx, edx<br />	xor	eax, &#91;MT + ecx*4 + M*4&#93;<br />	and	edx, MATRIX_A<br />	;<br />	xor	eax, edx<br />	mov	&#91;MT + ecx*4&#93;, eax<br />	inc	ecx<br />	jne	_1<br /><br /><br />;  for &#40;;kk&lt;N-1;kk++&#41; &#123;<br />;    y = &#40;mt&#91;kk&#93;&amp;UPPER_MASK&#41;|&#40;mt&#91;kk+1&#93;&amp;LOWER_MASK&#41;;<br />;    mt&#91;kk&#93; = mt&#91;kk+&#40;M-N&#41;&#93; ^ &#40;y &gt;&gt; 1&#41; ^ mag01&#91;y &amp; 0x1UL&#93;;<br />;  &#125;<br />	mov	ecx, -&#40;M-1&#41;			; last one wraps around<br />	MT EQU &lt;&#40;mt+N*4-4&#41;&gt;			; forward through memory<br /><br />_2&#58;	mov	edx, &#91;MT + ecx*4&#93;<br />	mov	eax, &#91;MT + ecx*4 + 4&#93;<br />	and	edx, UPPER_MASK<br />	and	eax, LOWER_MASK<br />	;<br />	or	eax, edx			; y<br />	;<br />	shr	eax, 1<br />	sbb	edx, edx<br />	xor	eax, &#91;MT + ecx*4 + &#40;M-N&#41;*4&#93;<br />	and	edx, MATRIX_A<br />	;<br />	xor	eax, edx<br />	mov	&#91;MT + ecx*4&#93;, eax<br />	inc	ecx<br />	jne	_2<br /><br /><br />;  y = &#40;mt&#91;N-1&#93;&amp;UPPER_MASK&#41;|&#40;mt&#91;0&#93;&amp;LOWER_MASK&#41;;<br />;  mt&#91;N-1&#93; = mt&#91;M-1&#93; ^ &#40;y &gt;&gt; 1&#41; ^ mag01&#91;y &amp; 0x1UL&#93;;<br />	mov	edx, &#91;mt + N*4 - 4&#93;<br />	mov	eax, &#91;mt&#93;<br />	and	edx, UPPER_MASK<br />	and	eax, LOWER_MASK<br />	;<br />	or	eax, edx			; y<br />	;<br />	shr	eax, 1<br />	sbb	edx, edx<br />	xor	eax, &#91;mt + &#40;M-1&#41;*4&#93;<br />	and	edx, MATRIX_A<br />	;<br />	xor	eax, edx<br />	mov	&#91;mt + N*4 - 4&#93;, eax<br /><br />	mov	eax, -N<br />	mov	&#91;mti&#93;, -&#40;N - 1&#41;<br /><br />get_rand&#58;<br />	; EAX in interval &#91;-N, -1&#93;<br />	MT EQU &lt;&#40;mt+N*4&#41;&gt;			; forward through memory<br />	mov	eax, &#91;MT + eax*4&#93;<br /><br />	mov	edx, eax<br />	shr	eax, 11<br />	xor	eax, edx<br /><br />	mov	edx, eax<br />	shl	eax, 7<br />	and	eax, 09D2C5680h<br />	xor	eax, edx<br /><br />	mov	edx, eax<br />	shl	eax, 15<br />	and	eax, 0EFC60000h<br />	xor	eax, edx<br /><br />	mov	edx, eax<br />	shr	eax, 18<br />	xor	eax, edx<br />	ret<br />genrand_int32 ENDP<br /><br />; generates a random number on &#91;0,0x7fffffff&#93;-interval<br />genrand_int31 MACRO<br />	call	genrand_int32<br />	shr	eax, 1<br />ENDM</code></pre>...I haven't tuned it up, yet.<br /><br />Make sure to initialize the array:<pre><code>	invoke init_genrand, 19730905<br />	invoke genrand_int32</code></pre><br />I'd like to optimise the loops, but I'm not sure that the following code doesn't adversely effect the randomness of the algorithm:<pre><code>_1&#58;	mov	edx, &#91;MT + ecx*4&#93;<br />	mov	eax, &#91;MT + ecx*4 + 4&#93;<br />	add	edx, edx<br />	rcr	eax, 1<br />	sbb	edx, edx<br />	xor	eax, &#91;MT + ecx*4 + M*4&#93;<br />	and	edx, MATRIX_A<br />	xor	eax, edx<br />	mov	&#91;MT + ecx*4&#93;, eax<br />	inc	ecx<br />	jne	_1</code></pre>Anyone know a way to test?  My math skills are lacking in this regaurd.<br /><br />Here are some macros for other types of random number ranges with floats:<pre><code>; generates a random number on &#91;0,0x7fffffff&#93;-interval<br />genrand_int31 MACRO<br />	invoke genrand_int32<br />	shr	eax, 1<br />ENDM<br /><br /><br />; generates a random number on &#91;0,1&#41;-real-interval<br />genrand_real0 MACRO<br />	invoke genrand_int32<br />	push	0<br />	push	eax<br />	fild	QWORD PTR &#91;esp&#93;<br />	; = int31 / 2^32<br />	fmul	fpc&#40;REAL8 2.3283064365386962890625e-10&#41;<br />	add	esp, 8<br />ENDM<br /><br /><br />; generates a random number on &#91;0,1&#93;-real-interval<br />genrand_real1 MACRO<br />	invoke genrand_int32<br />	push	0<br />	push	eax<br />	fild	QWORD PTR &#91;esp&#93;<br />	; = int31 / &#40;2^32 - 1&#41;<br />	fmul	fpc&#40;REAL8 2.3283064370807973754314699618685e-10&#41;<br />	add	esp, 8<br />ENDM<br /><br /><br />; generates a random number on &#91;0,1&#93; with 63-bit resolution<br />genrand_res63 MACRO<br />	invoke genrand_int32<br />	push	eax<br />	invoke genrand_int32<br />	shr	DWORD PTR &#91;esp&#93;, 1<br />	push	eax<br />	fild	QWORD PTR &#91;esp&#93;<br />	; = int63 / 2^63<br />	fmul	fpc&#40;REAL8 1.0842021724855044340074528008699e-19&#41;<br />	add	esp, 8<br />ENDM<br /><br />; generates a random number on &#91;0,1&#41; with 63-bit resolution<br />genrand_res63_b MACRO<br />	sub	esp, 12<br />	invoke genrand_int32<br />	mov	&#91;esp+4&#93;, eax<br />	invoke genrand_int32<br />	mov	DWORD PTR &#91;esp&#93;, eax<br />	or	DWORD PTR &#91;esp+4&#93;, 80000000h ; must set high bit<br />	mov	DWORD PTR &#91;esp+8&#93;, 3FFFh<br />	fld1<br />	fld	TBYTE PTR &#91;esp&#93;<br />	fsubr<br />	add	esp, 12<br />ENDM</code></pre>I did a little testing.  2^26 random numbers takes just over<br />a sec on a 1.3Ghz Athlon processor (~20 cycles each).<br /><br />...and I did an MMX version that is &gt;15% faster (needs some more work).</div>
    <div class="meta">Posted on 2003-03-08 16:51:01 by bitRAKE</div>
   </div>
   <div class="post" id="post-86125">
    <div class="subject"><a href="#post-86125">real randomizer</a></div>
    <div class="body">Thanks for the translation bitRAKE, now I can interpret the algorithm in good old M(othertongue)ASM ;)  <br /><br />I was able to do some testing with it and the results look good.  To start with, it's roughly twice as fast as the Park-Miller algo.  I tested your code of the updated Mersenne Twister MT19937 algo, the Park-Miller (NaN's code), and the older MT19937 version in the Sterling code I mentioned above (but with the improved <em>init_genrand</em> initial seed proc).<br /><br />I measured the execution speed using lpPerformanceCount of a larger proc that used each of these PRNGs to produce a random population of 10,000 dword hex strings, results averaged over 100 generations.  <br /><br />MT19937 genrand_int32 - 10.9 ms<br />older MT19937 Rand - 11.0 ms<br />Park-Miller - <strong>22.4 ms</strong><br /><br />I'm not sure how best to test for &quot;randomness&quot;, but I tried to take some kind of measurement by testing for duplication of a random byte in a single byte position in each of these 10,000 dwords.  The hex strings were limited to 4 byte ascii strings from 20h to 7Ah, so only 90 possible ascii characters were possible.  Averaged over 100 generations, there were roughly 110 out of 10,000 dwords in the array with a single duplicated byte at a particular byte location.  This number seemed to be very slightly higher in the Park-Miller algo over the MT, the difference becoming a bit more noticeable as the size of the array increased.  <br /><br />LOL, That said, I'm not sure if this number means anything in terms of a test for &quot;randomness&quot; though, I was only looking for comparative differences, and it certainly wasn't rigorous.  I think there was a thread on graphically representing randomness recently, perhaps a pattern test might show something? <br /><br />For all intents your code is great unless you find an error, and the Mersenne Twister is certainly much faster than the Park-Miller. Thanks, I'm sure many will find it useful :)<br /><br />Regards,<br />Kayaker</div>
    <div class="meta">Posted on 2003-03-09 19:28:39 by Kayaker</div>
   </div>
   <div class="post" id="post-86145">
    <div class="subject"><a href="#post-86145">real randomizer</a></div>
    <div class="body">bitRAKE,<br /><pre><code>OPTION PROLOGUE&#58;NONE	<br />OPTION EPILOGUE&#58;NONE	<br />Align 16				<br />init_genrand PROC seed&#58;DWORD<br />; See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier.<br />; In the previous versions, MSBs of the seed affect<br />; only MSBs of the array mt&#91;&#93;.<br />; 2002/01/09 modified by Makoto Matsumoto<br />	mov	eax, &#91;esp+4&#93;            ; seed<br />	xor	ecx, ecx		; ecx=0<br />; mt&#91;mti&#93; = &#40;1812433253UL * &#40;mt&#91;mti-1&#93; ^ &#40;mt&#91;mti-1&#93; &gt;&gt; 30&#41;&#41; + mti&#41;;<br /><br />@@&#58;<br />	add	eax, ecx<br />	inc	ecx<br />	mov	edx, eax<br />	shr	eax, 30<br />	mov	&#91;mt+ecx*4-4&#93;, edx<br />        xor     eax, edx<br />	imul	eax, 6C078965h	        ; delay 4<br />	cmp	ecx, N			; 1 + 2 clocks for taken jmp and<br />	jl	@B			; CPU has a job until imul finish with eax<br />	mov	&#91;mti&#93;, ecx<br />	ret     4<br />init_genrand ENDP		        ;		<br />OPTION PROLOGUE&#58;PROLOGUEDEF	        ; turn back on the defaults<br />OPTION EPILOGUE&#58;EPILOGUEDEF	        ; </code></pre><br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-03-09 22:10:38 by lingo12</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=11188&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=11188&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="11188" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=11188&amp;page=2">&gt;</a><a href="../?id=11188&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>