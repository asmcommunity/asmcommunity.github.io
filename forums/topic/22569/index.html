<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Binary Search Tree - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=22569" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=22569">Binary Search Tree</a></p>
   <div class="post" id="post-169302">
    <div class="subject"><a href="#post-169302">Binary Search Tree</a></div>
    <div class="body">Can someone point me to an algorithm for implementing a (balanced) binary search tree in an array rather than a linked list? The only operations needed are search/insert.<br /><br />The linked list is fast - O(log n) search time and O(1) insert time (once the search fails). However, the linked list has greater memory requirement - maintaining separate left and right child pointers (for the braches which are less than or more than the current node). *O(1) insertion time if no attempt is made to keep the search tree balanced.<br /><br />The array would be slower - O(log n) search as well as O(log n) insert, but would require less space.<br />----------------<br />Obviously Binary Search with Insertion Sort into the list would be slower - O(Log n) search and O(n) insertion. Anyone interested in that algorithm?<br /><br />Thanks.</div>
    <div class="meta">Posted on 2006-01-02 09:54:48 by V Coder</div>
   </div>
   <div class="post" id="post-169304">
    <div class="subject"><a href="#post-169304">Re: Binary Search Tree</a></div>
    <div class="body">I am sure</div>
    <div class="meta">Posted on 2006-01-02 10:53:09 by shism2</div>
   </div>
   <div class="post" id="post-169307">
    <div class="subject"><a href="#post-169307">Re: Binary Search Tree</a></div>
    <div class="body">How do you make a search algorithm in O(log n) for a linked list?</div>
    <div class="meta">Posted on 2006-01-02 12:02:02 by QvasiModo</div>
   </div>
   <div class="post" id="post-169310">
    <div class="subject"><a href="#post-169310">Re: Binary Search Tree</a></div>
    <div class="body">Depends, whats the size of your data? 100 bytes for each item?<br />If the data is big the linked list is the best way, the two pointers wont make a big diference, but if your data this wont be a good option.<br />You can group the data in pages and make a linked list of those pages, each page have ahn 32kb, <br />insert always on the last page, if the last page is full insert a new page.</div>
    <div class="meta">Posted on 2006-01-02 14:56:10 by Eduardo Schardong</div>
   </div>
   <div class="post" id="post-169315">
    <div class="subject"><a href="#post-169315">Re: Binary Search Tree</a></div>
    <div class="body">BASIC code. Apologies.<br /><br /><pre><code>// BINARY SEARCH<br />IF n=0 THEN n=1: w(1)=value<br />sab:<br />m = (l + r)\2: wa$=value(m)<br />IF w$ = wa$ THEN saf<br />IF w$ &lt; wa$ THEN r = m - 1 ELSE l = m + 1<br />IF l &lt;= r THEN sab<br />// INSERTION into sorted list<br />incr n: FOR j = n TO l+1 STEP -1: w(j) = w(j-1): NEXT j<br />w(j)=value<br />saf: ... // Deal with data found</code></pre><br /><br />Yes. This is great for very small sets. I need one for a very large set, so insertion will take increasingly longer. That means a binary search tree is necessary.<br /><br />The linked list version is great in that it offers O(1) insertion speed, but this results in an unbalanced list. In a worse case scenario, it produces a one-sided tree with height n instead of log2 (n). With random data it may not be too bad. In addition the linked list takes 50% more space than my data itself, and space is badly at a premium.<br /><br />Now, apparently the array version would mean that the data have to be resorted  after each insertion. I am now beginning to wonder if that will slow down the routine too much. Any tips please?</div>
    <div class="meta">Posted on 2006-01-02 19:36:24 by V Coder</div>
   </div>
   <div class="post" id="post-169373">
    <div class="subject"><a href="#post-169373">Re: Binary Search Tree</a></div>
    <div class="body">Does anyone know of an algorithm for implementing a (balanced) binary search tree in an array rather than a linked list? The only operations needed are search/insert.<br /><br />Thanks.</div>
    <div class="meta">Posted on 2006-01-07 18:17:04 by V Coder</div>
   </div>
   <div class="post" id="post-169377">
    <div class="subject"><a href="#post-169377">Re: Binary Search Tree</a></div>
    <div class="body">Isn&#39;t a binary search tree implemented like an array only a sorted array??<br /><br />You will need only 2 search functions, <br /><br />1) one that return the exact place of the number or fail<br />2) the other that return the position where the number that&nbsp; you enter will be placed, that is 3,5,9,13 and you insert 7.5, it will return position 2, after that you will only move to the left the 9 and 13 and place in the 7.5.<br /><br /><br /><br />Also there is a variant if&nbsp; remember OK, the bin search give &quot;probability of .5 to each side, but if you have 1,2,3,4,5,..., 1000 in the first half and in the second 10000, 20000, 30000,...,10000000 then if you are searching 99999000, it will be best if you start the search more to the right than the half of the array.<br /><br /><br /><br />You can use perhaps a hinting or caching of the last or last 2 numbers inserted/searched... for &quot;cut&quot; at first hand a part of the array...<br /><br />For example p is for position p6 mean position-6 the number dosent matter at all ;)...<br /><br />p0, p1, p2, p3,..., p100<br /><br />you insert now x1 and say that you will insert it on p45 now the last number is in p101.<br />now you insert x2 and is compared to x1 and you take the part of the array that is correct, and so on.<br /><br /><br /><br /><br /><br /><br />Based on the anterior, you can use the following as STEPS insertion...<br /><br />1) Do a buffer array with implementation of a binary search tree, do the insertions in this array, will be very fast because the size... perhaps use linear search for insertion...<br /><br />2) When the array is full, commit it to the major array using the anterior way of hinthing about the last number inserted, and because is already ordered, you will be cuting upward your main array of search.<br /><br />3) you can cut more the major array, if in the minor array, you first insert the 1st number, and then the last number, andd taking that sub-array of the main array like the place to search and insert (tought insertions will affect the major array, especially at the end)<br /><br />Simple example 1:<br /><br />buffer array<br />1,2,4,6,7,8,9,10<br /><br />major array<br /><br />5, 15, 40, 50, 54, 62, 70 76, 88, 89, 90, 93, 96, 99, 103, 105<br /><br />First inserted<br />1*, 5, 15, 40, 50, 54, 62, 70 76, 88, 89, 90, 93, 96, 99, 103, 105<br />Last inserted<br />1*,5, 10*, 5, 15, 40, 50, 54, 62, 70 76, 88, 89, 90, 93, 96, 99, 103, 105<br />now your place to insert you will not need apply the bin search to the whole array, but to 1*, 5, 10* and move 8 places the rest of the array 15, 40, 50, 54, 62, 70 76, 88, 89, 90, 93, 96, 99, 103, 105 ;)...<br /><br />Also you can try inserting the first, the last, the after the first, the before the last, and so on, for help reduce de array to &quot;implode&quot; himself (dont know if the correct term).<br /><br /><br /><br /><br /><br />Dont know if this thing have a name, but I guess it will help a little in performance???<br /><br /><br /><br /><pre><code>By the way<br /> Posts: 666</code></pre><br /></div>
    <div class="meta">Posted on 2006-01-07 22:30:16 by rea</div>
   </div>
   <div class="post" id="post-169381">
    <div class="subject"><a href="#post-169381">Re: Binary Search Tree</a></div>
    <div class="body"><div class="quote"><br />Does anyone know of an algorithm for implementing a (balanced) binary search tree in an array rather than a linked list? The only operations needed are search/insert.<br /><br />Thanks.<br /></div><br />And why not mix them?<br /><br />Having a structure:<br />dunno STRUCT<br />previous dd ?<br />size dd ?<br />next dd ?<br />array (your data type) 4000 dup(?)<br />dunno ENDS<br /><br />To search start with the first structure, if not there search in the structure pointed by next, if next is null there are no more rows, so insert, to insert put a row on the last structure and increase the size, if size equals the size of array add a new structure (globalalloc you know what i mean), point its previous to the last structure, and point the last structure next to this new structure.<br /><br />Working a little more on this idea you can sort this list and put an index to speed up the search.</div>
    <div class="meta">Posted on 2006-01-08 07:15:45 by Eduardo Schardong</div>
   </div>
   <div class="post" id="post-169396">
    <div class="subject"><a href="#post-169396">Re: Binary Search Tree</a></div>
    <div class="body">I did some search about binary search tree and saw the concept mentioned of using a search tree implemented in an array. For node i, the left child is index 2i, and the right child is index 2i+1. Inserting an item and then balancing the tree will take a really long time, but it eliminates the need to use a linked list. A linked list will be very quick but unbalanced (which does not bother me). The main problem for my purposes is that it uses extra memory.<br /><br />I guess nobody knows of an algorithm that I can convert to assembly code?<br /><br />Thanks anyway.<br /><br />Cheers</div>
    <div class="meta">Posted on 2006-01-08 23:07:39 by V Coder</div>
   </div>
   <div class="post" id="post-169398">
    <div class="subject"><a href="#post-169398">Re: Binary Search Tree</a></div>
    <div class="body">Using a linked structure saves you memory because you don&#39;t start with an array of max size (or resizing your array). With the array structure you have to allocate enough memory to hold all the objects you want to add at the beginning, while in a linked structure you allocate memory as you go.<br /><br />The end case memory usage of a linked BSP is not even 3/2 more than an array BSP<br /><br />&gt;&gt;Array BSP with 100 objects in it BALANCED<br />Array 2*100+2 DWORDS long, each dword is a pointer to the data the object holds. The extra dwords are because the last object needs to have space for its children.<br />You&#39;ll need a byte array that holds the balance factor for each array element.<br />202*4+202 <br />= 1010bytes<br /><br />&gt;&gt;Linked BSP with 100 objects BALANCED<br />struct Obj<br />DWORD ptrToData<br />DWORD ptrToLeft<br />DWORD ptrToRight<br />BYTE balanceFactor ;;<br />endstruc<br />3*100*4+100 <br />= 1300bytes<br /><br /><br />Balancing an array BST with rotations is difficult.<br />Why even use a BST, can&#39;t you just use a sorted array?<br />It would be easier to implement a quicksort algo then an AVL tree in an array IMO<br />Insertion = O(1) + Quicksort O(n*logn)<br />Search&nbsp;  =&nbsp; O(logn)<br /><br />If you really want to implement an array bst, I suggest you check out a linked implementation and just realize that when it&#39;s trying to get the left or right child you are doing 2*(index) + 1 or 2.<br /><br />Here&#39;s a good LinkedAVL implementation in Java. The code is straight forward so porting it to asm shouldn&#39;t be impossible, then converting it to an array AVL would be mostly find and replace.<br /><br />http://www.cs.sjsu.edu/~smithj/oldclass/146s02/solutions/a2/AVL.java</div>
    <div class="meta">Posted on 2006-01-09 01:24:51 by r22</div>
   </div>
   <div class="post" id="post-169404">
    <div class="subject"><a href="#post-169404">Re: Binary Search Tree</a></div>
    <div class="body"><div class="quote">I did some search about binary search tree and saw the concept mentioned of using a search tree implemented in an array. For node i, the left child is index 2i, and the right child is index 2i+1.</div><br /><br /><br />If the tree is complete in a n-level and balanced, then at the end will be a sorted array ;).<br /><br /><pre><code><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  6<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  /&nbsp;  \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3&nbsp; &nbsp; &nbsp; &nbsp;  11<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  /&nbsp;  \&nbsp; &nbsp; &nbsp;  /&nbsp; &nbsp; \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  1&nbsp; &nbsp; &nbsp; 5&nbsp; &nbsp; 9&nbsp; &nbsp; &nbsp;  13<br /><br />It will end in something like<br />1,3,4,6, 9, 11,13<br /></code></pre><br /><br /><br />But also a not complete in the n-level will be sorted..<br /><pre><code><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  6<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  /&nbsp;  \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3&nbsp; &nbsp; &nbsp; &nbsp;  11<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  /&nbsp;  \&nbsp; &nbsp; &nbsp;  /&nbsp; &nbsp; \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 9<br /><br />It will end in something like<br />1,3,6, 9, 11<br /></code></pre><br />that is without take care of the position in the array like 2*i+1 or 2*i+2, you can aply a bin-search and it will work.<br /><br /><br />If not, for the two anterior cases, you will have something like<br /><pre><code><br />1)<br />6 for the header and apart<br />3,11, 1,5, 9,13<br /><br />2)<br />6 for the header<br />3,11, 1,_, 9,_<br /></code></pre><br /><br />See that the header not being a left or right child need be outside of the array.</div>
    <div class="meta">Posted on 2006-01-09 10:50:17 by rea</div>
   </div>
   <div class="post" id="post-169406">
    <div class="subject"><a href="#post-169406">Re: Binary Search Tree</a></div>
    <div class="body">rea, the nature of the bst is to be sorted, but BALANCED means the height of all the children is no more than 1 unit apart.<br /><br />&nbsp; A<br />/&nbsp; \<br />&nbsp; &nbsp; B<br />&nbsp; /&nbsp; \<br />&nbsp; &nbsp; &nbsp; C<br />Is an unbalanced tree, it&#39;s still sorted but the elements were added in a was that causes the structure of the tree to be inefficient for searching.</div>
    <div class="meta">Posted on 2006-01-09 14:09:35 by r22</div>
   </div>
   <div class="post" id="post-169407">
    <div class="subject"><a href="#post-169407">Re: Binary Search Tree</a></div>
    <div class="body">You mean it by this???<br /><br /><div class="quote">But also a not complete in the n-level will be sorted..<br /></div><br /><br />I was thinking in reference to the array, how it look (sorted), even that is not complete the bst in the n-th level, also in that way isn&#39;t ofered the &quot;extra spaces&quot; betwen the elements like give them the 2i+1 or 2*i+2, tought you will need move blocks of memory when inserting 1 element. Is based on such order of array I suguest the steps for insertion: buffer them, commit-insertingfirst-last each time.<br /><br /><br /><br /><br /><br />What can I correct is that I fail in the first time in interpretation, the header isn&#39;t apart from the array lol, is only that it can not be acceded with 2*i+1 or 2*i+2, if you take apart the header like I do, then those two functions are 2*i and 2*i+1 respectively.<br /><br /><br /><br /><br />With that last way of implementing the array for a bst, there is no way that the look at first sight is sorted ;), even that the nature of the bst is to be sorted. (Now Im thinking how like is a implementation of a bst in an array, there are now 2 posible way diferent, but still the same?, that is, tought a sorted array have the sorted way of the bst but dosent offer the left-right child-thing, the second way of implementation ofer the left-right-child of the nature of the bst, but dosent ofer at first sight the ordered nature of the bst  ;)).</div>
    <div class="meta">Posted on 2006-01-09 15:06:47 by rea</div>
   </div>
   <div class="post" id="post-169410">
    <div class="subject"><a href="#post-169410">Re: Binary Search Tree</a></div>
    <div class="body"><div class="quote"> although no explicit balance conditions are imposed on the tree, each of these operations can be shown to use time O(lg n) on an n-element tree</div><br /><br />http://www.ibr.cs.tu-bs.de/courses/ss98/audii/applets/BST/SplayTree-Example.html<br /><br /> Not exactly what you asked for but it may do the job you want and the animation looks good!<br /><br />Paul.<br /></div>
    <div class="meta">Posted on 2006-01-09 16:21:53 by pdixon</div>
   </div>
   <div class="post" id="post-169443">
    <div class="subject"><a href="#post-169443">Re: Binary Search Tree</a></div>
    <div class="body"><div class="quote"><br />Using a linked structure saves you memory because you don&#39;t start with an array of max size (or resizing your array). With the array structure you have to allocate enough memory to hold all the objects you want to add at the beginning, while in a linked structure you allocate memory as you go.<br /><br />The end case memory usage of a linked BSP is not even 3/2 more than an array BSP<br /><br />&gt;&gt;Array BSP with 100 objects in it BALANCED<br />Array 2*100+2 DWORDS long, each dword is a pointer to the data the object holds. The extra dwords are because the last object needs to have space for its children.<br />You&#39;ll need a byte array that holds the balance factor for each array element.<br />202*4+202 <br />= 1010bytes<br /><br />&gt;&gt;Linked BSP with 100 objects BALANCED<br />struct Obj<br />DWORD ptrToData<br />DWORD ptrToLeft<br />DWORD ptrToRight<br />BYTE balanceFactor ;;<br />endstruc<br />3*100*4+100 <br />= 1300bytes</div><br />In the linked list form, the program would allocate the estimated amount of memory needed for the list at the start (eg. 2.5GB) on a machine with that RAM - each data element consists of 4bytes left pointer, 4 bytes right pointer, 16 bytes data.<br /><u><strong>Insert:</u></strong> Binary Search for the data. If you reach a node with a zero pointer (left or right, depending on whether the data to be inserted is less than or more than the data at that node), then set that pointer to the end of the list. Insert the new data at the end of the list. Reset the end of list pointer to the next available position.<br /><br />In the array form with binary search and insertion sort, the program would allocate the estimated amount of memory needed at the start (eg. 1.7GB) - each data element consists of 16 bytes data.<br /><u><strong>Insert:</u></strong> Binary Search for the data. If the data is not found, insert the data at the current position, shifting everything else down. <u>That is the routine I included above</u> I guess that is effectively a bubble sort? Or is it an insertion sort. No matter. This is exponentially slower than the linked list version. And having done a binary search I know exactly where the new data needs to go in the sorted list, so I&#39;m guessing that there is no other more effective way of getting it there. Even heap, shell, quick or other sort will not work faster.<br /><br /><strong>What I want is</strong><br />In the array form with binary search and insertion sort, the program would allocate the estimated amount of memory needed at the start (eg. 1.7GB) - each data element consists of 16 bytes data.<br /><u><strong>Insert:</u></strong> Binary Search for the data. If the data is not found. I guess there is no way to keep it balanced without essentially going through the same hassle of comparing with parent and sibling nodes and shifting things around, which works out to slower than insertion/bubble sort, because the implementation above needs no further compares.</div>
    <div class="meta">Posted on 2006-01-10 18:17:28 by V Coder</div>
   </div>
  </div>
 </body>
</html>