<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>IsBadString - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4384" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=4384">IsBadString</a></p>
   <div class="post" id="post-30414">
    <div class="subject"><a href="#post-30414">IsBadString</a></div>
    <div class="body">Since Masm cannot determine if a String is 0 terminated in certain situations can we do something so that a string is not read BEYOND an REAL Characters. EXAMPLE:<br /><br />MyBuffer db 128............<br /><br />When the line below is read it into MyBuffer it will read 128 BYTE and as you see there are only 19 BYTE in the string.....My Masm Buffer don't know that... so it is going to write Blank spaces or walk over to the next string and take part of that in if it is in the RANGE of 128 BYTES and at it to compete as 128 byte lenght string witch finally makes since to me...<br /><br />D:\My Folder\MyFile____________all blanks ________ C:\W<br /><br />This is a problem that many has seen but what kind of SELF OPERATION can we make to get all of the REAL characters out of the string and leave the JUNK (spaces) BEHIND. Than put it in another Buffer or whatever with the proper amount of characters.....<br /><br />D:\My Folder\MyFile<br /><br />The only thing i can think of is to read the string in backwards and force masm to find a legal characters and begin from there.  Or to Read only Real Characters into ecx and cut OFF at any Blank Space...<br /><br />I tried INSTRING from m32.lib but i can get it to work right.  I got self operations for other things but i don't know the best way to approach this problems.  I am not talking Masm Alinement ....<br /><br />PLEASeee Help  <br /><span style="font-size:9px>I have grown very,very tired of this problem</span> <br /><br />Thanks</div>
    <div class="meta">Posted on 2002-03-22 23:14:30 by cmax</div>
   </div>
   <div class="post" id="post-30416">
    <div class="subject"><a href="#post-30416">IsBadString</a></div>
    <div class="body">i don't know if this is what you want, but it searches for a non-space, then starts copying the string from there, appending a null-terminator.  It can be easily changed to search for different patterns.  (i don't have a charmap on me to find &quot;:&quot; or &quot;\&quot; :p)<br /><br /><em><br />.radix	16<br />push	MAXSIZE ;max length of the string<br />lea	ebx,StringIn ;location of StringIn<br /><br />lea	eax,StringOut ;writes the null-terminated string here<br />pop	ecx<br /><br />NextChar:<br />mov 	dl, ;reads a char, from end<br />dec	ecx<br /><br />je	NoString ;kills loop if the beginning of the string is reached<br />;Change here to make a more complex comparison routine<br />cmp	dl,20 ;check for space<br />je	NextChar<br /><br />mov	byte ptr ,0 ;append a zero<br /><br />WriteNextChar:<br />mov	,dl ;start copying the string - read<br />nop<br />;possibly huge whack of cache penalties here<br />mov	dl, ;write<br />dec	ecx<br />jne	WriteNextChar ;loop<br /><br />NoString:<br /></em><br /><br />hope this helps... (haven't tested it, either, but i commented it)</div>
    <div class="meta">Posted on 2002-03-22 23:40:55 by jademtech</div>
   </div>
   <div class="post" id="post-30417">
    <div class="subject"><a href="#post-30417">IsBadString</a></div>
    <div class="body">:)  Its a leaning lesson for sure, i dont get too frustrated, the experience will give you good knowledge for simular probs.<br /><br />(( First i want to say, that the INSTRING version released in the previous MASM32 package (v 6 ??)  had a bug in it..  (do a search if your currious ~ i know its on the board somewhere).  However, the new release (i believe) is corrected, in V7 that Hutch currently offers on his web site ))<br /><br />Next... To hack out your problem, you got to ask yourself what do *you* consider legal / illegal for your parser?  You say spaces are out, ok.  But what else? There is alot of chars to choose from.   So a better approach might be what chars do you want to allow?<br /><br />The ASCII table has A-Z in upper case from 0x41 -&gt; 0x5A.  And lower case a-z being 0x61 -&gt; 0x7a.  As well there is #'s from 0x30 to 0x39. (0-&gt;9 respectively).  These are the basics and can be isolated in a character parsing function quite easily.  But what else?  the is '/' or '\' if your dealing with file/web addresses. As well as the ':'  all of which have a unique code to them in the ASCII table.  <br /><br />If you have *alot* of isolated characters you want to pass thru unlike a-z or 0-9 (that are confined to a range), you could use the <strong>xlat</strong> command and have it filter through a look-up table:<div class="quote"> Usage:  XLAT    translation-table<br />         XLATB   (masm 5.x)<br /> Modifies flags: None<br /><br /><br /> Replaces the byte in AL with byte from a user table addressed by<br /> BX.  The original value of AL is the index into the translate table.<br /><br /></div><br /><br />Like so:<pre><code><br />  lea edx, RawTextBuffer<br />  push ebx      ; Be safe ~ for windows anyways<br />@@&#58;<br />  mov al, &#91;edx&#93;          ; Parse this char for validity<br />  lea ebx, FilterTable<br />  xlat<br />  cmp al, 0<br />  je @F<br />  inc edx         ; char is valid<br />  jmp @B<br />@@&#58;<br />  mov BYTE PTR &#91;edx&#93;, 0      ; Add the NULL at first non-valid char<br />  mov eax, edx<br />  lea edx, RawTextBuffer    ; Get start addr again..<br />  sub eax, edx             ;  Eax = Fin - Start = Lenght of Valid buffer<br />  pop ebx             ; Keep windows working... &#58;&#41;<br /></code></pre><br /><br />WHere the table would be in your &quot; .data &quot; section containing 1's or 0's for valid chars or not.  The table will be 256 bytes long, and when ever you want the char to 'pass' place a 1, if not, place a zero.  <br /><br /><u></u>  Space is 0x40 or the 64'th Ascii char value. Thus Placing a <strong>'0'</strong> in the table's 64'th position will ensure that a space is considered an &quot;illegal&quot; value.  Likewise, placing a <strong>'1'</strong> at 0x5c or the 92'd table entry will allow the &quot; \ &quot; char to be seen as valid. )<br /><br />This method is *slow* but ez to do.  If its not the core of a complicated engine, you wont even notice the 'lag'.  <br /><br />Another way is to pre-filter for the standard ranges (0x41-0x5a, 0x61-&gt;7a,0x30-&gt;0x39) with simple math on the char, and if its not these, then pass the char as a one last check thru the above algo.  (you can ignore placing 1's in the already filtered areas for obvious reasons).  This will at least limit you from relying *soley* on xlat, when math can be a faster solution.  <br /><br /><br />Again, it really matters what *you* want to achieve, specifically.  All this could be overkill, if all you want to do if look for the first space and call it quits (0x40).<br /><br />Hope this is some help to you?<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-03-22 23:54:06 by NaN</div>
   </div>
   <div class="post" id="post-30419">
    <div class="subject"><a href="#post-30419">IsBadString</a></div>
    <div class="body">To determine a string if it is NULL terminated or not, I don't think there is a sole solution, it depends on the data itself, we cannot assume the blank spaces are junk, what if it is actually part of the string. If we talk about string that contains the path and directories in a hardrive, you can try recursing the harddrive and find a string match.<br /><br />My best bet is to build a pattern failure. What I meant is, you have to recurse all directories and files and check for the closest possible match of your string. Don't assume anything's a match, don't stop comparing till the end.<br /><br />E.G.<br /><br />Legend: 0 means a mismatch<br />Valid Paths:<br />c:\cmax\x__files_<br />c:\cmax\x__files__<br />c:\cmax\x__files___x<br /><br />String Data: c:\cmax\x__files__xgf<br /><br /><br />Closest Match 1:<br /><br />c:\cmax\x__files_<br />|||||||||||||||||0<br />c:\cmax\x__files__xgf<br /><br />Mismatch at position 17 (Save for Null termination later...)<br /><br />Closest match 2:<br />c:\cmax\x__files__<br />||||||||||||||||||0<br />c:\cmax\x__files__xgf<br /><br />Our new closest match...<br />Mismatch at position 18 (Save for Null termination later...)<br /><br />c:\cmax\x__files__x<br />|||||||||||||||||||0<br />c:\cmax\x__files__xgf<br /><br />Our new closest match...<br />Mismatch at position 19 (Save for Null termination later...)<br /><br />After finished recursing... append 0 at the last data whose value is pointing at position 19 of our string.<br /><br />Our final string: c:\cmax\x__files__x<br /><br />Then again, we really don't know how to determine if a string is null terminated or not, it depends on you, what you actually want your string data to contain. There are a lot of ways to determine if it's a junk, we can say <strong>blank</strong> spaces are junk, we can say <strong>a</strong> is a junk...</div>
    <div class="meta">Posted on 2002-03-23 00:06:17 by stryker</div>
   </div>
   <div class="post" id="post-30614">
    <div class="subject"><a href="#post-30614">IsBadString</a></div>
    <div class="body">I founded a way to do it by putting a mark (\) at the end than  finding mark and cut from there.  I founded in a recent post about strings.<br /><br />The thing was that when you look a string in a message box it looks perfect and will work if use through-out the program................ BuT when you write it to disk it may someTimes have extra characters at the end of that string depending on how buffers are alined or something.<br /><br />But anyway with this new information about strings in this post it should end my quest to having an good understanding of what can be done with strings.  This is some serious information for me to look into<br /><br />Looks deeper than i thought<br /><br />Thanks Again</div>
    <div class="meta">Posted on 2002-03-24 05:05:56 by cmax</div>
   </div>
   <div class="post" id="post-30622">
    <div class="subject"><a href="#post-30622">IsBadString</a></div>
    <div class="body">For my two cents, your problem is made harder, actually caused, not by the string data, but by your buffer:<br /><br /><pre><code><br />MyBuffer db 128<br /></code></pre><br /><br />It would be much more flexible is you define it like so:<br /><br /><pre><code><br />pMyBuffer DWORD  ?<br /></code></pre><br /><br />Just a pointer location, not a fixed length. This way, *ANY* string you encounter at run time can be acommodated by simply getting the string length, adding one, and allocating that much memory and storing the pointer back into pMyBuffer.</div>
    <div class="meta">Posted on 2002-03-24 08:30:04 by Ernie</div>
   </div>
   <div class="post" id="post-30635">
    <div class="subject"><a href="#post-30635">IsBadString</a></div>
    <div class="body">Ernie,<br /><br />You Hit the Nail Right on the Head.  It is a Buffer Problem.  But up until now it keep me very confussed.  So I keep asking the same question over and over again because of differece situations thinking it's something new... Now i know... and with stronger knowlege about strings to BOOT....<span style="font-size:9px>ABOUT TIME</span> <br /><br />Thanks</div>
    <div class="meta">Posted on 2002-03-24 11:50:52 by cmax</div>
   </div>
  </div>
 </body>
</html>