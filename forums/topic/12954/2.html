<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Accessing the fields of a struct via pointer - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=12954" />
  <link rel="prev" href="../?id=12954&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=12954">Accessing the fields of a struct via pointer</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=12954&amp;page=1" style="">&laquo;</a><a href="../?id=12954&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="12954" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-101054">
    <div class="subject"><a href="#post-101054">Accessing the fields of a struct via pointer</a></div>
    <div class="body">Good discussion! I learned a lot from it. I accept .struct.field too.</div>
    <div class="meta">Posted on 2003-05-04 05:37:08 by taowen2002</div>
   </div>
   <div class="post" id="post-101058">
    <div class="subject"><a href="#post-101058">Accessing the fields of a struct via pointer</a></div>
    <div class="body"><div class="quote"><em>My problem with assume is you have to be carefull with function calls in between your ASSUME:xxxx and ASSUME:NOTHING statements...</em></div>You think so? I have never had this problem. Or i have a bunch of undiscovered bugs in my code because of it. Hmmm, i know which option i prefer to believe in.....<br /><br />What i am saying is that i have never found any indication of the ASSUME being carried across the bounds of functions, API or otherwise.<br /><br />I have used both the ASSUME method, and the &lt;ptr&gt;.&lt;struct&gt;.&lt;field&gt; method, and definately prefer the ASSUME (mainly because it means less typing, i don't believe in short cryptic names for my structs).</div>
    <div class="meta">Posted on 2003-05-04 06:33:48 by sluggy</div>
   </div>
   <div class="post" id="post-101066">
    <div class="subject"><a href="#post-101066">Accessing the fields of a struct via pointer</a></div>
    <div class="body">I think ASSUME is good if you're going to make &quot;alot&quot; of references to a STRUC.<br /><br />Also, I used to use<br /><br />(struc PTR ).item<br /><br />but I've changed my ways and have been using<br /><br />.struc.item<br /><br />for a while now. I think it's easier to read, etc...<br /><br />:)</div>
    <div class="meta">Posted on 2003-05-04 07:21:16 by S/390</div>
   </div>
   <div class="post" id="post-106550">
    <div class="subject"><a href="#post-106550">Accessing the fields of a struct via pointer</a></div>
    <div class="body">I will post it here. But this question is something else. BTW. ASSUME is more cool :tongue: <br /><br /><br />;K this one is my struct<br /><br />HANDLESSTRU struct<br /> 	hCBSh	dd	?<br /> 	hCBLo	dd	?<br /> 	hCBNIP	dd	?<br /> 	hCBKon	dd	?<br /> 	hCBTel	dd	?<br /> 	hLV	dd	?<br /> HANDLESSTRU ends<br /><br /><br />HandlesS		HANDLESSTRU    &lt;?&gt;<br /><br /><br />;after filling  HandlesS with proper data i wonted to read it somewhere in my proc.<br />;i made something like this.<br /><br />invoke MyProc,addr HandlesS<br /><br /><br /><br />MyProc proc pHandlesS:DWORD<br /><br />;I thought that structures are just like arrays so i add 4 to adres to <br />;obtain HandlesS.hCBLo<br /><br />add pHandlesS,4<br /><br />;Unfortunatelly addr HandlesS != HandlesS.hCBSh<br /><br />ret<br />MyProc endp<br /><br /><br />how can i obtain pointers to struct members without knowing name of them ??<br /><br />pleas can you explain to me struct rules ??</div>
    <div class="meta">Posted on 2003-06-09 17:01:11 by AceEmbler</div>
   </div>
   <div class="post" id="post-106555">
    <div class="subject"><a href="#post-106555">Accessing the fields of a struct via pointer</a></div>
    <div class="body">That should have worked AceEmbler. A structure in all languages is an array of contiguous data, addressed by named labels. The first field in the structure is always at offset 0. So :<br /><br />MyStruct STRUCT<br />f1 dd ?<br />f2 dd ?<br />f3 dd ?<br />MyStruct ENDS<br /><br />ms    MyStruct &lt;?&gt;<br /><br />mov edi,OFFSET ms<br /><br /> holds f1<br /> holds f2<br /> holds f3<br /><br />This pattern is unchanging even in HLL's. There must be something else up with the code for it not to have worked. I have used this method extensively and have never had a problem with it.</div>
    <div class="meta">Posted on 2003-06-09 18:55:22 by donkey</div>
   </div>
   <div class="post" id="post-106600">
    <div class="subject"><a href="#post-106600">Accessing the fields of a struct via pointer</a></div>
    <div class="body">youre right I fail:alright:</div>
    <div class="meta">Posted on 2003-06-10 01:47:19 by AceEmbler</div>
   </div>
   <div class="post" id="post-111613">
    <div class="subject"><a href="#post-111613">Accessinf Fields of a structure using ptr</a></div>
    <div class="body">Hi all,<br /><br />	I have been using this format in my programs as I find that its shorted and easier to type.  (sorry for the formatting - I could not figure out how to get it right)<br /><br />sFixedSzArray	 struct<br />hArrMem 		 dd 0<br />nMemSz			 dd 0<br />nElmtSz 		 dd 0							 <br />nArrLen 		 dd 0<br />hIdxMem 		 dd 0<br />nIdxMemSz		 dd 0<br />pIdxMem 		 dd 0<br />pArrMem 		 dd 0<br />sFixedSzArray	 ends<br />pAr 			 TEXTEQU&lt;.sFixedSzArray&gt;<br />pArESI			 TEXTEQU&lt;.sFixedSzArray&gt;<br /><br />;---------------------------------------------------------------------------------<br /><br />ReleaseArray	 proc uses ebx pArr:dword<br />				 mov ebx,pArr<br />				 .if(pAr.pArrMem) <br />					invoke GlobalUnlock,pAr.hArrMem<br />					mov pAr.pArrMem,0<br />				 .endif<br />				 ret<br />ReleaseArray	 endp<br /><br /> I use EBX For a lot of my structures I, so when I have to use more than one in the same section I use the alternat pointer <strong>pArESI</strong> ect to remind myself which Register is being used.</div>
    <div class="meta">Posted on 2003-07-23 14:33:50 by Gr8ful dead</div>
   </div>
   <div class="post" id="post-114234">
    <div class="subject"><a href="#post-114234">here we go!!! :D</a></div>
    <div class="body"><div class="quote"><br />guys,<br />The original question was:<br />&quot;If it possible to accessing a field <strong>without the presence of register</strong>?&quot;<br />The answer is:<pre><code><br />.data<br />            MyRect      RECT  &lt;&gt;<br />.code<br />           mov  MyRect.left, 2<br />           mov  MyRect.top, 1<br />           mov  MyRect.bottom, 7 <br />           inc  MyRect.top<br />           ...		<br />           jmp   ExitProcess	; kill the process</code></pre><br />No registers!<br /><br />Note:<br />I didn't see <strong>assume reg: NOTHING</strong> in the examples above! Why?<br /><br />Regards,<br />Lingo </div><br /><br />you can read a little more, to catch a little more.. or have more questions.. i dunno here.. ;) <br /><a target="_blank" href="http://www.asmcommunity.net/board/showthread.php?s=&amp;postid=112728.msg112728">http://www.asmcommunity.net/board/showthread.php?s=&amp;postid=112728.msg112728</a><br /><br />Also centering on what you are saying i will try explain here too :D<br /><pre><code><br />struct mean<br /> m1 dword 1<br /> m2 dword 1<br />endstruct<br /><br />think in this like res is for reserve<br />struct mean<br /> m1 resd 1<br /> m2 resd 1<br />endstruct<br /><br /></code></pre><br /><br />Then what is the mean of this??, nothing for the compter, but for the assembler you are defining a dta type, maybe or probable that in language at level of assembly time this is (in words for understand at human level :D ):<br /><br />define a type struct called mean<br />define the first member with displacement 0 and is called m1 and size double word<br />define the next member with displacement 4 and is called m2 and size double word<br /><br />ok ok... that was easy... for how to use it??.. and for what to use?? (read the explanation that i write in the other  post), is simply for acces more easy ;).<br /><br />ok now have two cases in general.<br /><br />The first in the code, when you do:<br /><br />.data<br />            MyRect      RECT  &lt;&gt;<br /><br />you are saying to the compiler some like this:<br /><br />hey I want define a label called MyRect<br />I want you reserve for me the space of RECT<br />I will not give you any initializer &lt;&gt;<br /><br />After the assembler know this, then it go for the case, if, jmp or call :D, and &quot;say&quot; hey, i have a dta type called RECT is a struct and have four members, and the displacements of the members are (i dont know the order):<br /><br />left 0<br />top 4<br />bottom 8<br />top 12<br /><br />now that i know that i will make others labels with the first label (the base label), make the suposition that in the data section your label MyRect is in the addres 10<br />then the addresses will be:<br /><br />---------------<br />MyRect 10<br />MyRect.left 10<br />MyRect.top 14<br />MyRect.bottom 18<br />MyRect.right22<br />----------------<br /><br /><br />But the assembler cannot create the addres, first need some content if provided is in &lt;,,,,&gt; and if no is &lt;&gt; and simply declare the sizes without initializers:<br /><br />Then the assembler will do some like (without the need of write in the code, only calling directly the secuences of instructions for do this:<br /><br />MyRect:<br />MyRect.left dd 0<br />MyRect.top dd 0<br />MyRect.bottom dd 0<br />MyRect.right dd 0<br /><br /><br />This is a large explanation, but at the end you will get completely  the idea.<br /><br />And for what no assume when you acces it???, simple, they are labels with a specific address, and name, you dont need assume nothing, the compiler know all that need for acces this part of memory in the way that you abstract it :D.<br /><br /><br />And for what assume with registers???<br /><br />Go to the first steps, where you say to the compiler that you are defining a data type.<br /><br />What things you know????<br /><br />-The name of the data type<br />- The type of the data type<br />- The displacements of the members (based on the size of the previous member )<br />- The sizes of each member (for the fill with initializers)<br />- the size of the data type.<br /><br />First look at this, you can move the direction of a addres to a register, then you can add the displacements, at the end, dosent matter what you use for access, at the end will look like ebx+0 or ebx+4, ok now with this fact.<br /><br />you can think now in this posibility:<br /><br />if you have only rectangle, then you can access<br /><br />ebx.top and will be ebx+x<br />ebx.left etc ebx+x2<br /><br />but see this case:<br /><br />struct TRIANGLE<br /> topx resd 1<br /> topy resd 1<br /> left resd 1<br /> bottomleft resd 1<br /> right resd 1<br /> bottomright resd 1<br />endstruct<br /><br /><br />Now you have two diferent things, if you take ebx.left or ebx.right, here for the rectangle ebx.left will be for example ebx+4 and for the triangle ebx.left will be ebx+8, here the assembler say.. WHAT APPEND!!!!!!!!!!!!, what of this two take???, and here we comes..... the diferent forms of acces.... (when you write the rules, you have to take decisions).<br /><br />--Complete cualified names:<br /><br />ebx.DATATYPE.member<br /><br />(in this form the assembler know that you will take the value of DATATYPE and no DATATYPE2)<br /><br />By this way are the other forsm of  cualified names:<br /><br />DATATYPE register.member.. and others....<br /><br />--Using a indicator of what to take if a bot specifiers taked:<br /><br />This is assume...<br /><br />assume ebx:RECTANGLE<br />then ebx.left will be taked from the data type RECTANGLE... <br /><br /><br />here a break... i dont know if you can do this:<br />assume ebx:RECTANGLE<br />assume ebx:BINFO<br />and if both (the two) data types have diferent members, then you can acces booth (the two)??, if this can be done, then the problem of what to choice comes for second time if some of the members in the two structures have the same name (or give a error). I dont know the mechanism of assume in the way that i dont know if they push when you do that combination, or simple rewrite RECTANGLE with BINFO without the assume nothing for ebx (get the idea?), or more simple, simple give a message error. If a mechanis like a push.. then you can do:<br /><pre><code><br />assume ebx&#58;RECTANGLE<br />  ;use ebx with the members of rectangle<br />assume ebx&#58;TRIANGLE<br />  ;push the anterior assume<br />  ;use ebx with members of triangle<br />assume ebx&#58;nothing<br />  ;pop the assume<br />  ;continue using ebx with the members of RECTANGLE<br />assume ebx&#58;nothing<br /></code></pre><br />if have a implementation like a list (walk all)<br /><pre><code><br />assume ebx&#58;RECTANGLE<br />  ;use ebx with the members of rectangle<br />assume ebx&#58;TRIANGLE<br />  ;link with the anterior assume and check for no duplicate members in the dta types in the list<br />  ;use ebx with members of triangle<br />  ; and with members of rectangle<br />assume ebx&#58;nothing<br />  ;unlink the assume<br />  ;continue using ebx with the members of RECTANGLE<br />assume ebx&#58;nothing<br /><br /></code></pre><br /> <br /><br />or if have a more simple implementation:<br /><pre><code><br />assume ebx&#58;RECTANGLE<br />  ;use ebx with the members of rectangle<br />assume ebx&#58;TRIANGLE<br /> ; give a error you are trying rewrite the anterior assume, use assume ebx&#58;nothing<br /> ;and the next will maybe not work correctly by this error<br /> ; THAT IS NOT FUNNY say the assembler &#58;D<br />assume ebx&#58;nothing<br />  ;right you are in the correct path &#40;but before this you have a fail<br />assume ebx&#58;nothing<br /><br /></code></pre><br /><br /><br />haha, now you can see in a more deep way for what the assume for registers.... anf for what the cualified names :D, and for what no with data in the code :), you see that is a question of choise... make desicions, use one or other sintaxis, if assume work like some of the first two posible choises, then i prefer for readibility a complete cualified name (maybe If I have a goode use of tab can work with this way.), you can be a little ambigous if you use assume (if first read of code) you need search where is the assume you can not know at first look to what Data TYPE is ebx.left (remember RECTANGLE and TRIANGLE) and can type a little fast more, or by a no ambigous (at first read) with complete cualified names ebx.DataType.member, but write a little less fast and more ;D<br /><br /><br /><br /><br />* remember that a union manipulate in diferent way the displacement of his members, and sure the total size of the  data type.<br /><br />Nice day.</div>
    <div class="meta">Posted on 2003-08-18 10:40:02 by rea</div>
   </div>
   <div class="post" id="post-114242">
    <div class="subject"><a href="#post-114242">Accessing the fields of a struct via pointer</a></div>
    <div class="body">Since we are talking about ASSUME with structures now....<br /><br />I uae ASSUME alot now, and many structure definitions.  I've wrapped API call into structures. Now an API call looks like this:<br /><br />	invoke .GetModuleHandle, NULL<br /><br />But what I do is an ASSUME like:<br /><br />	WAPI TEXTEQU &lt;ecx&gt;<br />	ASSUME WAPI:PTR _WAPI<br /><br />So it ends up looking like this:<br /><br />	invoke .GetModuleHandle, NULL<br /><br />This might not be the best example, but the benfit of equating your assumed reg is that if you decide to use a diffrent reg, just change the reg in the equate. Done. No error of forgeting to change a reg in the code after you change the reg in the ASSUME.<br /><br />I am beginning to think ASSUME is good for structured programming, especial if you name the reg with an equate.  Nameing the reg gives it meaning, if you change the meaning, done right, you can emulate scope. You dont  see a reg, but information about what the reg is being used for or contains.  Starting to apply HLL techniques to assem.  Cant really explaine it very well, it really seems to be something that must be tried, to start to understand.</div>
    <div class="meta">Posted on 2003-08-18 12:34:29 by ThoughtCriminal</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=12954&amp;page=1" style="">&laquo;</a><a href="../?id=12954&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="12954" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>