<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>anyncronous send/recv (continues) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=2086" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=8">Networking</a> &raquo; <a href="../?id=2086">anyncronous send/recv (continues)</a></p>
   <div class="post" id="post-13256">
    <div class="subject"><a href="#post-13256">anyncronous send/recv (continues)</a></div>
    <div class="body">Greetings,<br /><br />here is a small problem i have.. the client sends a request to the server for a file. the server receives the request from the client, forms a header which contains info about the file to be trasmitted, sends the header and then sends the actual file. The problem is that the client however does not nessesarily receive the info in the same order ! is this correct or am i doing something wrong? <br />What happens is that i want to receive the header first, get the info about the file (size, name, blah) and then recieve the actual file..<br /><br />is there a way to accomblish this? <br />(thomas, random are you reading ;)  )<br /><br />thanks.</div>
    <div class="meta">Posted on 2001-11-27 15:33:32 by Ray</div>
   </div>
   <div class="post" id="post-13260">
    <div class="subject"><a href="#post-13260">anyncronous send/recv (continues)</a></div>
    <div class="body">You're doing something wrong because whatever you send will be received in the same order... Well not at the hardware &amp; IP level, but the TCP level ensures you get the data in the right order..<br /><br />So there's probably something wrong with sending the data. How are you sending it? <br /><br />Thomas</div>
    <div class="meta">Posted on 2001-11-27 15:48:05 by Thomas</div>
   </div>
   <div class="post" id="post-13263">
    <div class="subject"><a href="#post-13263">anyncronous send/recv (continues)</a></div>
    <div class="body">Thomas,<br />:<pre><code><br />;  Handle socket messages<br />	mov eax, lParam   <br />	.IF ax == FD_ACCEPT<br />           shr eax, 16	<br />	   .if eax == NULL<br />	     invoke accept, sock, NULL,NULL<br />	     .if eax != INVALID_SOCKET<br />  	     	mov sock2, eax<br /> 		invoke	WSAAsyncSelect, sock2, hWin, WM_CLIENTSOCK, FD_WRITE OR FD_READ OR FD_CLOSE<br />  	     .endif	<br />	   .endif  <br /><br /> .ELSEIF ax == FD_READ <br />           shr eax, 16	<br />	   .if eax == NULL<br />	     invoke ioctlsocket, sock2, FIONREAD, ADDR dataAmount<br />	     .if eax==NULL<br />		     invoke recv, sock2, ADDR buffer1, dataAmount, 0<br />     	             invoke ContructHeader, ADDR buffer<br />	             invoke send, sock2, ADDR HeaderBuffer, 250, NULL ; &lt;&lt;---Send Header Here<br />	     <br />	     .endif  	   <br />	   .endif  <br /><br />   <br />.ENDIF   <br /><br />.....<br />    .elseif uMsg == WM_CLIENTSOCK<br />	mov eax, lParam   <br />	.IF ax == FD_WRITE<br />           shr eax, 16	<br />	   .if eax == NULL	 <br />	        ; wParam is client socket handle here<br />		invoke	send, wParam, pMem, FileSize, NULL	; &lt;&lt;-- Send actual file here<br />		.IF	eax==SOCKET_ERROR<br />		  MsgBox 'Error sending to clientsock'	;error occurred!!!<br />		.ELSE<br />			;here, eax is number of bytes actually sent. Note that this<br />			;may be less than 4096!!!!!			<br />		.ENDIF<br /><br /><br /></code></pre><br />:grin:</div>
    <div class="meta">Posted on 2001-11-27 16:12:31 by Ray</div>
   </div>
   <div class="post" id="post-13265">
    <div class="subject"><a href="#post-13265">anyncronous send/recv (continues)</a></div>
    <div class="body">The problem is the design of the synchronisation, the code you posted does exactly this:<br /><pre><code><br /> when data arrives at socket -&gt; read data and send header<br /> when client is ready for writing -&gt; send file<br /></code></pre><br /><br />This looks okay when all the events happen at the right place, but this is rarely the case..<br /><br />First of all, remember you are using non-blocking sockets, which means that send will not necessairily send all the bytes you feed it, and that recv may receive less bytes than you ask. Using  ioctlsocket is good because you will receive the maximum number of bytes available at that moment, but it doesn't mean you've received the full request, as it may be split in multiple parts!. So using single recv's and send's here will cause problems.<br /><br />The received data (from the client) may come in parts, which means you get multipe FD_READ messages, and everytime the header is sent. This isn't correct.<br /><br />The FD_WRITE message simply means 'client is ready for writing'. This message is sent when the client is ready after you called WSAAsyncSelect, and thereafter when send fails with WSAEWOULDBLOCK. So this event is of no use to time the sending of the file.<br /><br />I'll give an example of something that may happen:<br /><pre><code><br />- server accepts connection<br />- wsaasyncselect is called<br />- client socket is ready for writing, FD_WRITE msg sent<br />- &#91;b&#93;server sends file&#91;/b&#93;<br />- client sends first part of request &#40;this can happen&#41;<br />- server receives data and &#91;b&#93;sends header&#91;/b&#93;<br />- client sends second part of request<br />- server receives data and &#91;b&#93;sends header again&#91;/b&#93;<br />- &#40;Imagine sending of the header failed with WSAEWOULDBLOCK, because the client socket wasn't ready for writing&#41;<br />- Winsock waits until client socket is ready for writing<br />- FD_WRITE msg sent<br />- &#91;b&#93;server sends file again&#91;/b&#93;<br /></code></pre><br /><br />This example may be a little exaggerated, but it's perfectly possible that this would happen. In this case, the client would receive this: file,header,header again,file again<br /><br />The solution is to create a bunch of flags and counters, to check what you were sending, how much data is already sent, etc...<br />Then each time before sending, check what you have to send, which part of it, and try to send it. If send fails (because it would block), wait for the FD_WRITE message and proceed sending.<br />Maybe you can add your own custom message (WM_CONTINUESEND or something) that sends the next part of the full response (= header and file)..<br /><br />I'll try to explain a bit more tomorrow, right now I'm a bit tired.<br /><br />Thomas</div>
    <div class="meta">Posted on 2001-11-27 16:41:44 by Thomas</div>
   </div>
   <div class="post" id="post-13317">
    <div class="subject"><a href="#post-13317">anyncronous send/recv (continues)</a></div>
    <div class="body">Good morning,<br />Thomas,<br /><br />so you are suggesting to use a flag of somekind (on the server side) to await for the complete header to send. the header is 250 bytes long, so i guess i can use this correct? So, unless the header is sent i should not send anything else to the client.<br />After succesful sent of the header, i can proceed with the actual file send :)<br /><br />If you can change a bit the above code to accomodate this changes i would appreciate it.<br /><br />thanks.</div>
    <div class="meta">Posted on 2001-11-28 01:22:07 by Ray</div>
   </div>
   <div class="post" id="post-13334">
    <div class="subject"><a href="#post-13334">anyncronous send/recv (continues)</a></div>
    <div class="body"><div class="quote"><br />so you are suggesting to use a flag of somekind (on the server side) to await for the complete header to send. the header is 250 bytes long, so i guess i can use this correct? So, unless the header is sent i should not send anything else to the client. <br />After succesful sent of the header, i can proceed with the actual file send. <br /></div><br />Yes that's right, one thing to add: you also have to wait for the complete request to be received. Never assume one recv will receive all the data you need, although this is true most of the time.<br /><br />Here's an example design for your program:<br />(btw I don't know if your request has a fixed size too, but you'll have to make some code that checks if you've received the full request)<br /><br /><pre><code><br />&#91;b&#93;data&#58;&#91;/b&#93;<br />buffers&#58;<br />- requestBuffer &#58; a buffer for your request<br />- headerBuffer &#58; the buffer that will contain your file header<br />- pMem &amp; FileSize&#58; you already have these ones.<br /><br />flags&#58;<br />- currentAction dd ?<br />  ; this flag tells you what you are currently doing<br />  ; make some flags for this, say&#58;<br />  ;ACTION_RECEIVING_REQUEST equ 1<br />  ;ACTION_SENDING_HEADER equ 2<br />  ;ACTION_SENDING_FILE equ 2<br />  ;ACTION_DONE equ 3<br />  ; this flag has to be initialized to ACTION_RECEIVING_REQUEST before processing<br />  ; a request<br /><br />vars&#58;<br />- requestBytesReceived dd ? ; number of bytes of the request already received<br />- headerBytesSent dd ?      ; number of bytes of the header already sent<br />- fileBytesSent dd ?        ; number of bytes of the file already sent<br /> ; all these vars have to be initialized to zero before processing a request<br /><br />constants&#58;<br />    WM_CONTINUE_SENDING equ WM_USER + 120<br />    <br />--CODE--<br /><br />&#91;b&#93;on FD_READ&#58;&#91;/b&#93;<br />    .IF currentAction==ACTION_RECEIVING_REQUEST<br />        ; --- get maximum buffer size ---<br />        mov     eax, MAX_REQUEST_BUFFER_SIZE ;define this constant somewhere<br />        ; --- get number of bytes aready received ---<br />        mov     ecx, requestBytesReceived<br />        ; --- get number of bytes left in buffer &#40;max - already done&#41; ---<br />        sub     eax, ecx<br />        ; --- create current buffer pointer ---<br />        add     ecx, offset requestBuffer<br />        ; --- *add* data to buffer ---<br />        invoke  recv, sock2, ecx, eax, NULL<br />        .IF     eax==SOCKET_ERROR<br />            invoke  WSAGetLastError<br />            .IF     eax!=WSAEWOULDBLOCK ; if WSAEWOULDBLOCK, do nothing,<br />                                        ; just wait for more data<br />                ; error occurred!!!<br />            .ENDIF<br />        .ELSE<br />            ; update number of bytes received<br />            add     requestBytesReceived, eax<br />        .ENDIF<br />        <br />        invoke  CheckIfFullRequestReceived ;create this proc yourself<br />        .IF     yes, fully received<br />            ; start with sending the header&#58;<br />            mov     currentAction, ACTION_SENDING_HEADER<br />            invoke  SendMessage, hWin, WM_CONTINUE_SENDING, NULL, NULL<br />        .ENDIF<br />    .ELSE<br />        ;client sends data after the request, <br />        ;bad client &#58;&#41;<br />    .ENDIF<br />        <br />&#91;b&#93;on FD_WRITE&#58;&#91;/b&#93;<br />    ; if ready for writing, and currently sending something, continue<br />    ; with sending.<br />    .IF currentAction==ACTION_SENDING_HEADER || \<br />        currentAction==ACTION_SENDING_FILE<br />        invoke  SendMessage, hWin, WM_CONTINUE_SENDING, NULL, NULL<br />    .ENDIF<br />    <br />&#91;b&#93;on WM_CONTINUE_SENDING&#58;&#91;/b&#93;  <br />    .IF currentAction==ACTION_SENDING_HEADER<br />       <br />       @send_next_header_part&#58;<br />        ; get number of bytes already sent&#58;<br />        mov     eax, headerBytesSent<br />        <br />        ; get number of bytes yet to do&#58;<br />        mov     ecx, 250<br />        sub     ecx, eax<br />        <br />        ; get the right buffer pointer<br />        add     eax, offset headerBuffer<br />        <br />        ; send next part of data&#58;<br />        invoke  send, sock2, eax, ecx, NULL<br />        <br />        .IF     eax==SOCKET_ERROR<br />            invoke  WSAGetLastError<br />            .IF     eax!=WSAEWOULDBLOCK<br />                ; error occurred!!<br />            .ENDIF<br />            ;else, just wait for the FD_WRITE message, it will<br />            ;send the WM_CONTINUE_SENDING message again.<br />            <br />            ret     ;!!!!!!!! don't forget this one <br />            <br />        .ELSE<br />            ;update counter&#58;<br />            add     headerBytesSent, eax<br />            .IF     headerBytesSent==250 ; header done?<br />                ;start sending file<br />                mov currentAction, ACTION_SENDING_FILE<br />                jmp @send_next_file_part<br />            .ENDIF<br />        .ENDIF  <br />        ; no WSAEWOULDBLOCK, client is still ready for writing, so send more&#58;<br />        jmp @send_next_header_part<br />        <br />    .ELSEIF currentAction==ACTION_SENDING_FILE<br />        <br />       @send_next_file_part&#58;<br />    <br />        ; get number of bytes already sent&#58;<br />        mov     eax, fileBytesSent<br />        <br />        ; get number of bytes yet to do&#58;<br />        mov     ecx, FileSize<br />        sub     ecx, eax<br />        <br />        ; get the right buffer pointer<br />        add     eax, pMem<br />        <br />        ; send next part of data&#58;<br />        invoke  send, sock2, eax, ecx, NULL<br />        <br />        .IF     eax==SOCKET_ERROR<br />            invoke  WSAGetLastError<br />            .IF     eax!=WSAEWOULDBLOCK<br />                ; error occurred!!<br />            .ENDIF<br />            ;else, just wait for the FD_WRITE message, it will<br />            ;send the WM_CONTINUE_SENDING message again.<br />            <br />            ret     ;!!!!!!!! don't forget this one <br />            <br />        .ELSE<br />            ;update counter&#58;<br />            add     fileBytesSent, eax<br />            mov     eax, FileSize<br />            .IF     fileBytesSent==eax ; file done?<br />                ; DONE!!!!<br />                mov currentAction, ACTION_DONE<br />                <br />                ret ; !!! don't forget this one either<br />                <br />            .ENDIF<br />        .ENDIF  <br />        ; no WSAEWOULDBLOCK, client is still ready for writing, so send more&#58;<br />        jmp @send_next_file_part<br />    .ENDIF<br /></code></pre><br /><br />Thomas<br />P.S. I have written this code without testing but it will probably work.<br />P.S.2. You'd better read it with a syntax highlighting editor, looks so much better :) .</div>
    <div class="meta">Posted on 2001-11-28 04:58:01 by Thomas</div>
   </div>
   <div class="post" id="post-13442">
    <div class="subject"><a href="#post-13442">anyncronous send/recv (continues)</a></div>
    <div class="body">Thanks Thomas,<br /><br />let me spend some time working with this....<br />my first attempt gives me a socket error when trying to send the header. I am sure i messed up somehere :rolleyes: <br /><br />'i'll be back'</div>
    <div class="meta">Posted on 2001-11-29 01:42:54 by Ray</div>
   </div>
  </div>
 </body>
</html>