<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>P/E Extender v2.0-RC2 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=413" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=413">P/E Extender v2.0-RC2</a></p>
   <div class="post" id="post-2330">
    <div class="subject"><a href="#post-2330">P/E Extender v2.0-RC2</a></div>
    <div class="body">I've read somewhere about being macro mad.<br />You'll now discover what it means to be macro PERVERT.<br /><br />Prologue/Epilogue Extender (or P/E Extender for short) is a set of macros which primarily allows to access procedure arguments and local variables through esp rather than ebp, thus freeing ebp for common use (and also preserved register).<br /><br />Well-- primarily it was that. Until today, its list of features grew longer and longer, and it was time to update some of the documentation to make it ready for publication.<br /><br />Note that P/E Extender is currently in RC2 state, and performs quite stable, nevertheless, any bugs go into this thread, or directly to <a href="mailto:s-m-k@gmx.net">s-m-k@gmx.net</a>.<br /><br />--------------------------------------------------------------------------<br /><br /><strong>Prologue/Epilogue Extender for Masm v2.0-RC2</strong><br />a high-level macro compilation for low-level coders<br /><br />Copyright ? 2000, 2001 ?SMK? &lt;<a href="mailto:s-m-k@gmx.net">s-m-k@gmx.net</a>&gt;<br /><br />LEGAL NOTICE - The author accepts no responsibility for losses of any type<br />arising from the use of this macro set. Whereas the author has used his best<br />endeavours to ensure that this compilation of macros is working, you should<br />not rely on this and you should do your own tests.<br /><br />In other words: Make backups.<br />--------------------------------------------------------------------------<br /><br /><br />FEATURES<br /><ul><br />[*] Enables generation of stack pointer (esp) based stack frames, provides all necessary offset calculation for procedure arguments and local variables via text macro equations<br />[*] Support for Masm standard base pointer (ebp) based stack frames:<br />* Enabling the use of _alloca (growable-only memory allocation on the stack, rather than using heaps. Library code included with P/E Extender)<br />* Enabling the possibility to align the stack pointer (ie. local variables that need an alignment other (bigger) than DWORD)<br />[*] Built-in support for structured exception handlers<br />[*] Full support for PASCAL, BASIC and FORTRAN languages<br />[*] Optimized alignment techniques for local variables allocation:<br />* Native data types are automatical <em>naturally</em> aligned<br />* If the size of any local type is bigger than 4 bytes, the stack will be suitably aligned to the biggest type (results in loss of ebp, this functionality can be disabled)<br />* Optional enforced alignment<br />[*] Extensive debug and trace message modes, smart error handling<br /><br /><br />KNOWN ANOMALIES<br /><ul><br />[*] Within one module (ie. file), all symbolic names of any P/E Extender enabled procedure (argument <em>and</em> local names) <strong>have to be unique</strong>!<br />Technical background: Once a symbol is made into an equation, there is no possibility  to re-define the same name to another equation (or purge it). Workaround: Prefix symbolic names with abbrevated procedure name.<br />[*] All macro directives spanning more than one line <strong>must use</strong> line continuation '\'! (Masm macro limitation)<br />[*] Since there is no 'fatal error' macro command, it is not possible to immediately stop the compiler. Therefore I've chosen to issue two error messages per error: One is issued in compiler flow, (sometimes) with additional verbose information appended (like faulty arguments, etc.). The other is a Masm .ERR, which appears always at the end of all compiler messages (not in compiler flow).<br /><br /><br /><img src="http://www.asmcommunity.net/board/images/icons/icon4.gif" /> <u>Included in ZIP:</u><br />peext.mac - Main macro include file<br />peext.txt - Rough documentation of new directives and options<br />\alloca - Library and source of _alloca support</div>
    <div class="meta">Posted on 2001-07-28 18:55:01 by -SMK-</div>
   </div>
   <div class="post" id="post-2364">
    <div class="subject"><a href="#post-2364">P/E Extender v2.0-RC2</a></div>
    <div class="body">SMK,<br /><br />I had a look to your macros and some tests done. And I dare to say that only very few people will use it. Ok, I must admit that it works principially. But:<br /><br />- include a code example! It is really needed. For you I think it looks very simple. But others who are not used to this stuff will resign.<br />- just to get one free register the coder must accept to care for unique names on source code level AND modify source code at many places (_push, _pop). Too much costs.<br />- the stuff is not foolproofed. For example, if you need to do a push without a pop in a loop (.repeat or .while), your macros will not work. <br /><br />May be a &quot;precompiler&quot; solution would be better, if any.<br /><br />japheth</div>
    <div class="meta">Posted on 2001-07-29 09:45:49 by japheth</div>
   </div>
   <div class="post" id="post-2370">
    <div class="subject"><a href="#post-2370">P/E Extender v2.0-RC2</a></div>
    <div class="body"><strong>japheth:</strong><br /><div class="quote"><br />Just to get one free register the code must accept to care for unique names on source code level AND modify source code at many places (_push, _pop).<br /></div><br />I see that point, and especially for the unique names, I must admit it's one of the biggest unsolved problems I have (and no alternative solution, as of yet). On the other hand, I primarily use P/E Extender to write optimized subroutine/library code containing time critical hot spots - most of them from scratch - and do <strong>not</strong> convert whole existing programs. Think of it: What would you gain from? One more common usage register between tons of Win32 API (or in general - subroutine) calls. That isn't what I made it for, and efforts for conversion go far beyond any realistic performance/algorithmic gains.<br /><br />Modification of code isn't a thing <em>I</em> really have to care about. Any editor should be able to search and replace text within a selection (with the procedure of interest currently selected ;)).<br /><div class="quote"><br />The stuff is not foolproofed. For example, if you need to do a push without a pop in a loop (.repeat or .while), your macros will not work.<br /></div><br />I completely agree with you: you found something that isn't possible - and was never meant to be (I think I concerned about the given example in the answer above). Besides that: Can you give me a real-life example that makes it necessary to push/pop a number of values, where the number is known only at run-time (and further, that is not able to be translated into a similar algorithm)? Or, according to what I said before: Hot spots souldn't contain such push/pop 'orgies' - refer to execution times of these instructions.<br /><br />BTW, workaround: Since you know the space required for the looped push operation at least at run-time, you can use the included _alloca command to allocate as much space as you need on the stack, and do a .repeat / mov  (which executes way faster, too). Note that _alloca requires an ebp-based stack frame. Be creative, it's all in there...!<br /><br />Last, not least: examples. I know, I know... It's time to write a basic outline of all supported functions, and the resulting code. Stay tuned...</div>
    <div class="meta">Posted on 2001-07-29 12:17:30 by -SMK-</div>
   </div>
   <div class="post" id="post-2464">
    <div class="subject"><a href="#post-2464">P/E Extender v2.0-RC2</a></div>
    <div class="body">-SMK-<br /><br />quote:<br />--------------------------------------------------------------------------------<br /> <br />Besides that: Can you give me a real-life example that makes it necessary to push/pop a number of values, where the number is known only at run-time (and further, that is not able to be translated into a similar algorithm)?<br />--------------------------------------------------------------------------------<br /><br />Ok, I agree that my example is no real problem. But the following pseudo code:<br /><br />count = 0<br />.repeat <br />  push value<br />  value = parent(value)<br />  inc count<br />.until value = 0<br /><br />.while (count)<br /> pop value<br /> do something useful with it<br /> dec count<br />.endw<br /><br />will hopefully show that pushing values repeatedly in a loop can be a proper solution to handle tree data structures for example. But you are right, you will always be able to code it in another way.<br /><br />japheth</div>
    <div class="meta">Posted on 2001-07-30 09:05:22 by japheth</div>
   </div>
  </div>
 </body>
</html>