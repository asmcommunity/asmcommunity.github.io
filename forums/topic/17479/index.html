<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Anyone know how .NET is implemented internally? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17479" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=17479">Anyone know how .NET is implemented internally?</a></p>
   <div class="post" id="post-135274">
    <div class="subject"><a href="#post-135274">Anyone know how .NET is implemented internally?</a></div>
    <div class="body">Well, obviously the way Microsoft is going seems to be promoting .NET languages and .NET code.  I am thinking they will probably phase out the Win32API before they phase out any of their .NET APIs (purely speculation though).<br /><br />Anyhow, it would be of tremendous advantage to have the internals (and, more importantly <em>why</em> and <em>where</em>) of what makes a program a .NET program, in the PE file, that is.<br /><br />I am thinking (in fact, pretty much certain) that how it is implemented is a small interpreter embedded into each .NET application and that interpreter interprets the MSIL code which then executes it based on the underlying machine architecture (which, for now, is x86 and Win32, but could change in an instant---probably will be IA-64 and Win64 soon)<br /><br />Obviously, I do NOT want to be stuck with having to use higher level languages in order to create .NET applications (if I absolutely HAD to make a .NET application, which I'm also going to try to avoid for a while, but I think it inevitable).  I do NOT want to be forced into using C# and Visual Basic .NET and Managed C++.<br /><br />I personally think this whole .NET thing is exceptionally ugly/etc, but, hey, I don't make the rules here...just play by them:p  As such, I still enjoy and appreciate as much of power and grasp as I possibly can on any situation.  Regardless, I still need to be able to make .NET applications at some point.  I'd rather do it through assembly language than through a higher level language, if that is possible.<br /><br />Any information on this (or speculation) would be appreciated:)<br /><br />Besides, it would be a grave travesty if all of the efforts of the entire Win32 asm community were thwarted in an instant if Microsoft decided to port their OS to various other processors, go .NET all the way, and implement all of the processor-dependent and OS-dependent things within the .NET interpreters, wouldn't it?</div>
    <div class="meta">Posted on 2004-03-06 00:00:45 by ShortCoder</div>
   </div>
   <div class="post" id="post-135284">
    <div class="subject"><a href="#post-135284">Anyone know how .NET is implemented internally?</a></div>
    <div class="body">Heya, I share your opinions and worries too! As a professional programmer, in VB 6, Delphi and all flavours of C++, I'm resisting the Dark Side of programming (.NET) for as long as I can! As far as I know, Microsoft is already planning a replacement of .NET, can't remember what it was called and I'm not sure if it's a complete rebuild, or an &quot;upgrade&quot; or something along the lines of ... &quot;built on .NET architecture&quot;. My personal belief, is that Microsoft can have .NET, and they can keep it, market it, promote it, support it etc. But no matter how much they try, the heart of operating systems, the Kernel, Drivers and any area where speed is critical will still be written in Asm.<br /><br />I also believe Microsoft will never be able to completely remove the API. 1) API calls are faster than .NET calls, this is essential in many situations! 2) They need to maintain backward compatability with older software, that is of course one of Microsoft's strongest selling points. 3) People developing Drivers for example, writing them in Asm will often need to make system calls directly from Asm, and can make these system calls to nothing but API's.<br /><br />After all, computers don't think in terms of objects, and that's what the .NET framework is all about. Everything becomes an object. You want a Thread? Create an object of type System.Thread. Personally, I detest this idea!<br /><br />My opinion, I wouldn't worry about the future of assembler or assembler programming.<br /><br />Regards</div>
    <div class="meta">Posted on 2004-03-06 11:53:30 by SubEvil</div>
   </div>
   <div class="post" id="post-135313">
    <div class="subject"><a href="#post-135313">Anyone know how .NET is implemented internally?</a></div>
    <div class="body"><div class="quote"><br />But no matter how much they try, the heart of operating systems, the Kernel, Drivers and any area where speed is critical will still be written in Asm.<br /></div><br />Not really... C and C++, with a very few routines written in asm, like the ZeroPage function (for speed) and stuff that just can't be written in C (some processor setup, lowlevel mutex stuff, etc).<br /><br />There will be native code for years to come, same with the win32 API. And once it's phased out, there will probably still be emulators available. SO if you're going to program in .NET, you might as well do it &quot;the proper way&quot; - there will hardly be much advantage in writing in MSIL, since the code is JIT'ed to native code anyway.<br /><br />But of course you can do it, afaik Microsoft provides both an assembler and disassembler for MSIL, plus a .NET specification. It's ported to FreeBSD, and there's the opensource MONO project.<br /><br /><div class="quote"><br />You want a Thread? Create an object of type System.Thread. Personally, I detest this idea!<br /></div><br />The WIN32 API is already *heavily* object-oriented, and so is the NT kernel. Only small parts of both are written in an object-oriented language (C++), but that doesn't change it's OOP-ness. OOP is a good idea, even assembly programmers are starting to realize this.</div>
    <div class="meta">Posted on 2004-03-07 15:16:05 by f0dder</div>
   </div>
   <div class="post" id="post-135320">
    <div class="subject"><a href="#post-135320">Re: Anyone know how .NET is implemented internally?</a></div>
    <div class="body"><div class="quote">Anyhow, it would be of tremendous advantage to have the internals (and, more importantly <em>why</em> and <em>where</em>) of what makes a program a .NET program, in the PE file, that is.</div>As fodder suggested, check out the Mono project, it is an open source port of the .Net framework, which means all the source is available.<br /><br /><div class="quote">I am thinking (in fact, pretty much certain) that how it is implemented is a small interpreter embedded into each .NET application and that interpreter interprets the MSIL code which then executes it based on the underlying machine architecture (which, for now, is x86 and Win32, but could change in an instant---probably will be IA-64 and Win64 soon)</div>Incorrect. The files are still have a PE type header, but they are not PE files. And the JITter is part of the .Net framework, it is not embedded in each file.<br /><br /><div class="quote">Obviously, I do NOT want to be stuck with having to use higher level languages in order to create .NET applications (if I absolutely HAD to make a .NET application, which I'm also going to try to avoid for a while, but I think it inevitable).  I do NOT want to be forced into using C# and Visual Basic .NET and Managed C++.</div>Why not? What is wrong with them?<br /><br /><div class="quote">I personally think this whole .NET thing is exceptionally ugly/etc, but, hey, I don't make the rules here...just play by them</div>You could look at it the other way, and say it is also beautiful. MS has sunk a lot of money and development time into .Net, and they stand to make a huge amount of money in return. Also, the .Net framework has been very well architected and well written.<br /><br /><div class="quote">I'd rather do it through assembly language than through a higher level language, if that is possible.</div>You can code in MSIL, although it is not asm as you know it.<br /><br /><br /><br /><div class="quote">Besides, it would be a grave travesty if all of the efforts of the entire Win32 asm community were thwarted in an instant if Microsoft decided to port their OS to various other processors, go .NET all the way, and implement all of the processor-dependent and OS-dependent things within the .NET interpreters, wouldn't it? </div>As an asm programmer, you mean nothing to MS. It is MS's intention that the .Net framework be ported to as many platforms as possible (one reason why they released Rotor), it is also their intention that as many platforms and devices as possible run some form of Windows. This is definately a &quot;world domination&quot; tactic, and has every chance of succeeding where Java failed.</div>
    <div class="meta">Posted on 2004-03-07 16:53:47 by sluggy</div>
   </div>
   <div class="post" id="post-135342">
    <div class="subject"><a href="#post-135342">Re: Re: Anyone know how .NET is implemented internally?</a></div>
    <div class="body"><div class="quote"><br />As fodder suggested, check out the Mono project, it is an open source port of the .Net framework, which means all the source is available.</strong><br /></div><br />Will do:)  <a target="_blank" href="http://www.go-mono.com">http://www.go-mono.com</a> right?<br /><div class="quote"><br />Incorrect. The files are still have a PE type header, but they are not PE files. And the JITter is part of the .Net framework, it is not embedded in each file.<br /></div><br />Interesting!  So, are you basically saying that the Windows loader first checks to see if a program is a .NET program and, if it is, then sends it off to the .NET interpreter to convert it to a legit PE file, and then sends that back again to the Windows loader which finally loads and executes it?  That's more complicated than I thought, but probably has a lot less performance overhead though, as it would be done only at start of program invocation rather than each MSIL instruction having to be interpreted every time it was encountered.<br /><div class="quote"><br />Why not? What is wrong with them?<br /></div><br />Nothing is wrong with them if you like programming in that paradigm.  Personally, I like close to 100% control of what my program is.  I'm the kind of guy that likes to make files based on their binary specifications rather than using external APIs geared towards those types of files <em>if</em> I can help it!  YES I like reinventing the wheel a lot IF it means I then gain a better understanding of internals in the process.  My ultimate goal is to be able to program any sort of program for any OS in pure hexadecimal.  Yes, I realize that might sound crazy, but I'm not planning on making all my programs in pure hex---more of a &quot;Hello World&quot; in as many different executable formats on as many different OSes as I can type thing---mainly a personal proof-of-concept thing for me.  If I manage to accomplish this incredible task, then I will know I have a very intimate knowledge of programs on each of those OSes.  With this knowledge, I then will be nearly unimpeded in any programming endeavours.  Code in C# or Visual Basic .NET or Managed C++ and you wouldn't have this degree of internal control.  I never said I would not program in those languages, just that I did not want to be forced to programming in any one (or a few) programming languages.;)<br /><div class="quote"><br />You could look at it the other way, and say it is also beautiful. MS has sunk a lot of money and development time into .Net, and they stand to make a huge amount of money in return. Also, the .Net framework has been very well architected and well written.<br /></div><br />Perhaps--depends on your personal paradigm, I'd say.:)<br /><div class="quote"><br />You can code in MSIL, although it is not asm as you know it.<br /></div><br />Then add MSIL to the list of things I will try to learn;)  It seems necessary to know MSIL backwards and forwards to even hope to accomplish making a .NET program in hex, so I should then learn it.:)<br /><br /><div class="quote"><br />As an asm programmer, you mean nothing to MS. It is MS's intention that the .Net framework be ported to as many platforms as possible (one reason why they released Rotor), it is also their intention that as many platforms and devices as possible run some form of Windows. This is definately a &quot;world domination&quot; tactic, and has every chance of succeeding where Java failed.</div><br />True.  However, if I succeed with my incredible (though not impossible) task, (yes, I am aware it requires I memorize all opcode hex values, but I see this as doable and a good test of self-discipline) it won't really matter what I mean to MS as I would then be able to (in theory) create my own low-level tools, compilers, and programming languages and port them to all those platforms.  Somehow I trust things that I, myself, made/wrote more than any other software, but that's just me.  If I also wrote my own compilers/etc, then I'd have nearly full trust in my programs.</div>
    <div class="meta">Posted on 2004-03-08 04:38:35 by ShortCoder</div>
   </div>
   <div class="post" id="post-135358">
    <div class="subject"><a href="#post-135358">Anyone know how .NET is implemented internally?</a></div>
    <div class="body"><div class="quote"><br />Incorrect. The files are still have a PE type header, but they are not PE files. And the JITter is part of the .Net framework, it is not embedded in each file.<br /></div><br />Iirc they actually are, but the entrypoint is just a call to some .NET manager code... it's only a very few instructions though, and the JITer + runtime is definitely NOT embedded in each and every executable, that would be plain stupid.<br /><br /><div class="quote"><br />&quot;Hello World&quot; in as many different executable formats on as many different OSes as I can type thing---mainly a personal proof-of-concept thing for me. If I manage to accomplish this incredible task, then I will know I have a very intimate knowledge of programs on each of those OSes.<br /></div><br />Not really. You will know a few simple system calls, a few CPU instructions, and a very limited subset of the executable format :tongue:. It's smarter to learn a few high-level languages and scripting languages really well, which enables you to work on more or less any platform, and focus on becoming good with assembly on a few platforms. Not much use in being half-assed on every platform on the earth...</div>
    <div class="meta">Posted on 2004-03-08 08:32:37 by f0dder</div>
   </div>
  </div>
 </body>
</html>