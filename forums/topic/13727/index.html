<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Very Large File Line Count: - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=13727" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=13727">Very Large File Line Count:</a></p>
   <div class="post" id="post-106307">
    <div class="subject"><a href="#post-106307">Very Large File Line Count:</a></div>
    <div class="body">The algorithm itself doesn't get any faster by using MMX, but the processor can do more while it is waiting on the hard drive.  My computer very consistently processes a 640MB file in 22 seconds -- that is 30MB/sec - the speed of my hard drive!  Furthermore, it does this with the simple byte scanner or the MMX code.<br /><br />Create a thread for <em>ScanFile</em> passing it the file name, and let your program do other stuff...<br /><br /><u>Stuff to do before using code:</u><br />- add error checking<br />- select the memory and threads needed<br /><br /><pre><code>BIGINT UNION<br />	QWORD ?<br />	STRUCT<br />		dwLow	DWORD ?<br />		dwHigh	DWORD ?<br />	ENDS<br />BIGINT ENDS<br /><br /><br /><br />THREAD_BLOCK STRUCT<br />	ol		OVERLAPPED &lt;&gt;	; overlapped structure for reads<br /><br />	mem		DWORD ? 	; address to memory buffer<br /><br />	ThreadId	DWORD ?		; thread id<br />	hThread		DWORD ?		; thread handle<br />THREAD_BLOCK ENDS<br /><br /><br /><br />MAX_SCAN_MEMORY		EQU 1024*256	; memory buffer to use<br />SCAN_MEMORY_BLOCK	EQU 1024*64	; bytes in blocks to read/scan<br />MAX_SCAN_BLOCKS		EQU MAX_SCAN_MEMORY / SCAN_MEMORY_BLOCK<br /><br />SCAN_BYTE		EQU 10			; linefeed<br />SCAN_BYTE_MMX		EQU &lt;0A0A0A0A0A0A0A0Ah&gt;	; linefeed<br /><br /><br /><br />_DATA SEGMENT<br />	iBigFile	BIGINT &lt;0&gt;	; 64 bit file length<br />	BigFile_count	BIGINT &lt;0&gt;	; number of lines<br /><br />	hBigFile	DWORD ?<br />_DATA ENDS<br /><br /><br />	OPTION PROLOGUE&#58;PROLOGUEDEF<br />	OPTION EPILOGUE&#58;EPILOGUEDEF<br /><br />BlockComplete PROC dwErrorCode&#58;DWORD, dwNumberOfBytesTransfered&#58;DWORD, lpOverlapped&#58;DWORD<br />	cmp	dwErrorCode, 0<br />	jne	_X<br />	cmp	dwNumberOfBytesTransfered, SCAN_MEMORY_BLOCK<br />	jne	_Y<br />	mov	edx, lpOverlapped<br />	mov	edx, &#91;edx&#93;.THREAD_BLOCK.mem<br /><br /><br />IF 0	; reference scanner<br />	or	eax, -1<br />	dec	edx<br />	mov	ecx, SCAN_MEMORY_BLOCK<br />_0&#58;	inc	eax<br />	dec	ecx<br />	js	_x<br />_1&#58;	inc	edx<br />	cmp	BYTE PTR &#91;edx&#93;, SCAN_BYTE<br />	je	_0<br />	dec	ecx<br />	jns	_1<br />_x&#58;<br />ELSE	; MMX scanner<br /><br />	movq	mm7, mxc&#40;&lt;0A&gt;&#41;<br />	pxor	mm6, mm6<br /><br />	mov	ecx, SCAN_MEMORY_BLOCK / &#40;8*128&#41;<br />@@&#58;<br />	pxor	mm5, mm5<br />	i = 0<br />	WHILE i LT &#40;8*128&#41;<br />		movq	mm0, &#91;edx + i +  0&#93;<br />		movq	mm1, &#91;edx + i +  8&#93;<br />		movq	mm2, &#91;edx + i + 16&#93;<br />		movq	mm3, &#91;edx + i + 24&#93;<br /><br />		pcmpeqb	mm0, mm7<br />		pcmpeqb	mm1, mm7<br />		pcmpeqb	mm2, mm7<br />		pcmpeqb	mm3, mm7<br /><br />		paddb	mm0, mm1<br />		paddb	mm2, mm3<br /><br />		paddb	mm0, mm2<br /><br />		psubb	mm5, mm0	; total 128*8 max = 1K<br />	i=i+8*4<br />	ENDM<br /><br />	; unpack MM5 to get sum in 1K block<br />	pxor		mm0, mm0<br />	psadbw		mm5, mm0<br />	paddd		mm6, mm5<br /><br />	dec	ecx<br />	lea	edx, &#91;edx + 128*8&#93;<br />	jne	@B<br /><br />	movd	eax, mm6<br />ENDIF<br /><br /><br />_9&#58;	add	BigFile_count.dwLow, eax<br />	adc	BigFile_count.dwHigh, 0<br /><br />	mov	edx, lpOverlapped<br />	; adjust the OVERLAPPED structure to get next file block<br />	add	&#91;edx&#93;.THREAD_BLOCK.ol.loffset, MAX_SCAN_MEMORY<br />	adc	&#91;edx&#93;.THREAD_BLOCK.ol.OffsetHigh, 0<br />	ret<br /><br />_X&#58;	; &#40;just bail&#41;<br />	ret<br /><br />_Y&#58; ; short block scan...<br />	or	eax, -1<br />	dec	edx<br />	mov	ecx, dwNumberOfBytesTransfered<br />_y0&#58;	inc	eax<br />	dec	ecx<br />	js	_yx<br />_y1&#58;	inc	edx<br />	cmp	BYTE PTR &#91;edx&#93;, SCAN_BYTE<br />	je	_y0<br />	dec	ecx<br />	jns	_y1<br />_yx&#58;	jmp	_9<br /><br />BlockComplete ENDP<br /><br /><br />	OPTION PROLOGUE&#58;NONE<br />	OPTION EPILOGUE&#58;NONE<br /><br />ScanFile_Thread PROC lpData&#58;PTR THREAD_BLOCK<br /><br />	mov	ebx, &#91;esp + 4&#93;	; lpData<br />	mov	esi, &#91;ebx&#93;.THREAD_BLOCK.ol.loffset<br />	mov	edi, &#91;ebx&#93;.THREAD_BLOCK.ol.OffsetHigh<br />	add	esi, SCAN_MEMORY_BLOCK<br />	adc	edi, 0<br />	; EBX is pointer to THREAD_BLOCK structure which must begin with<br />	; OVERLAPPED structure.  EDI&#58;ESI equals end of block offset<br />	jmp	_0<br /><br />_w&#58;	; wait for I/O completion<br />	invoke SleepEx, INFINITE, TRUE<br /><br />_0&#58;	mov	eax, SCAN_MEMORY_BLOCK<br />	xor	edx, edx<br /><br />	; check if end of block within file<br />	cmp	edi, iBigFile.dwHigh<br />	jc	_io<br />	jne	@F<br />	cmp	esi, iBigFile.dwLow<br />	jle	_io<br />@@&#58;<br />	; if not adjust block size<br />	add	eax, iBigFile.dwLow<br />	adc	edx, iBigFile.dwHigh<br /><br />	; if block size negitive kill thread<br />	sub	eax, esi<br />	sbb	edx, edi<br />	jne	EOF<br />	dec	eax<br />	je	EOF<br /><br />_io&#58;	add	esi, MAX_SCAN_MEMORY<br />	adc	edi, 0<br /><br />	invoke ReadFileEx, hBigFile, &#91;ebx&#93;.THREAD_BLOCK.mem, eax, ebx, OFFSET BlockComplete<br />	test	eax, eax<br />	jne	_w<br /><br />	invoke ExitThread, -1	; file ERROR<br />	retn	4<br /><br />EOF&#58;	invoke ExitThread, 0<br />	retn	4<br /><br />ScanFile_Thread ENDP<br /><br /><br />	OPTION PROLOGUE&#58;PROLOGUEDEF<br />	OPTION EPILOGUE&#58;EPILOGUEDEF<br /><br />ScanFile PROC USES ebx esi edi, lpFileName&#58;DWORD<br /><br />	invoke VirtualAlloc, NULL,<br />		MAX_SCAN_MEMORY + MAX_SCAN_BLOCKS * &#40;SIZEOF THREAD_BLOCK&#41;,<br />		MEM_COMMIT or MEM_RESERVE,<br />		PAGE_READWRITE<br />	test	eax, eax<br />	je	mem_ERROR<br /><br />	lea	ebx, &#91;eax + MAX_SCAN_MEMORY&#93;<br />	mov	edi, eax<br /><br />;; Open test file<br />	invoke CreateFile, lpFileName, GENERIC_READ, NULL, NULL, OPEN_EXISTING,<br />		FILE_FLAG_OVERLAPPED or FILE_FLAG_NO_BUFFERING or FILE_FLAG_SEQUENTIAL_SCAN, NULL<br />	mov	hBigFile, eax<br /><br />	invoke GetFileSizeEx, eax, OFFSET iBigFile<br /><br />	push	ebp<br />	xor	esi, esi<br />	xor	ebp, ebp<br />_t0&#58;	; fill THREAD_BLOCK<br />	lea	eax, &#91;edi + esi&#93;<br />	mov	&#91;ebx&#93;.THREAD_BLOCK.ol.loffset, esi<br />	mov	&#91;ebx&#93;.THREAD_BLOCK.ol.OffsetHigh, 0<br />	mov	&#91;ebx&#93;.THREAD_BLOCK.ol.hEvent, ebp<br />	mov	&#91;ebx&#93;.THREAD_BLOCK.mem, eax<br /><br />	invoke CreateThread, NULL, 4096, OFFSET ScanFile_Thread, ebx,<br />		NULL, ADDR &#91;ebx&#93;.THREAD_BLOCK.ThreadId<br />	mov	&#91;ebx&#93;.THREAD_BLOCK.hThread, eax<br /><br />	inc	ebp<br />	add	esi, SCAN_MEMORY_BLOCK<br />	add	ebx, SIZEOF THREAD_BLOCK<br />	cmp	ebp, MAX_SCAN_BLOCKS<br />	jne	_t0<br />	pop	ebp<br /><br />	sub	ebx, MAX_SCAN_BLOCKS * &#40;SIZEOF THREAD_BLOCK&#41;<br /><br />	;; Wait for threads to finish&#58;<br /><br />	push	esp<br />	mov	esi, MAX_SCAN_BLOCKS<br />_w&#58;<br />	;--------------------------------<br />	; Could do something useful here<br />	;--------------------------------<br /><br />	invoke GetExitCodeThread, &#91;ebx&#93;.THREAD_BLOCK.hThread, esp<br />	cmp	DWORD PTR &#91;esp&#93;, STILL_ACTIVE<br />	je	_w<br /><br />	cmp	DWORD PTR &#91;esp&#93;, 0<br />	je	@F<br /><br />	; file ERROR!<br />	int 3<br />	; file ERROR!<br /><br />@@&#58;	invoke CloseHandle, &#91;ebx&#93;.THREAD_BLOCK.hThread<br />	add	ebx, SIZEOF THREAD_BLOCK<br />	dec	esi<br />	jne	_w<br />	pop	eax<br /><br /><br />	invoke CloseHandle, hBigFile<br />	invoke VirtualFree, edi, 0, MEM_RELEASE<br /><br />mem_ERROR&#58;<br />	ret<br /><br />ScanFile ENDP</code></pre></div>
    <div class="meta">Posted on 2003-06-07 15:14:49 by bitRAKE</div>
   </div>
   <div class="post" id="post-106317">
    <div class="subject"><a href="#post-106317">Outstanding</a></div>
    <div class="body">I going to port this into SpAsm Syntax.<br />And play with it in SpAsm.<br /><br />multi threading and loading blocks, helps in overcoming natural<br />speed roadblocks in algos. <br /><br />Large file usage and byte parsing always an interesting algo topic.<br /><br />Thanks <strong>bitRake</strong></div>
    <div class="meta">Posted on 2003-06-07 18:10:01 by RobotBob</div>
   </div>
   <div class="post" id="post-106327">
    <div class="subject"><a href="#post-106327">Very Large File Line Count:</a></div>
    <div class="body">There is an error in the above code - should use:<pre><code>invoke WaitForSingleObject, &#91;ebx&#93;.THREAD_BLOCK.hThread, INFINITE</code></pre>...instead of continually checking if the thread is active.  This error cause the application to grap all the processor resources - now it is down to a couple percent. :)  The reference byte scanner takes 11% of processor time, but the MMX code cuts that down to 3%.</div>
    <div class="meta">Posted on 2003-06-07 20:31:01 by bitRAKE</div>
   </div>
   <div class="post" id="post-106442">
    <div class="subject"><a href="#post-106442">Very Large File Line Count:</a></div>
    <div class="body"><strong>bitRAKE</strong><br />Why in function <em>ScanFile_Thread</em> you use <em>ExitThread</em>, instead of<pre><code>	xor	eax, eax	; file ERROR<br />	dec	eax<br />	retn	4<br /><br />EOF&#58;	xor	eax, eax<br />	retn	4</code></pre></div>
    <div class="meta">Posted on 2003-06-08 21:06:54 by P2M</div>
   </div>
   <div class="post" id="post-106455">
    <div class="subject"><a href="#post-106455">Very Large File Line Count:</a></div>
    <div class="body"><strong>P2M</strong>, I did not know this was equivalent - thank you!<div class="quote"><strong>ExitThread</strong> is the preferred method of exiting a thread. When this function is called (either explicitly or by <u>returning from a thread procedure</u>)</div>Another optimization would be to pre-calculate number of loops needed by each thread, and the partial read thread -- which reduces the thread code to:<pre><code>	OPTION PROLOGUE&#58;NONE<br />	OPTION EPILOGUE&#58;NONE<br /><br />ScanFile_Thread PROC lpData&#58;PTR THREAD_BLOCK<br /><br />	mov	ebx, &#91;esp + 4&#93;	; lpData<br /><br />_0&#58;	invoke ReadFileEx, hBigFile, &#91;ebx&#93;.THREAD_BLOCK.mem,<br />		SCAN_MEMORY_BLOCK, ebx, OFFSET BlockComplete<br />	test	eax, eax<br />	je	Error<br /><br />	; wait for I/O completion<br />	invoke SleepEx, INFINITE, TRUE<br /><br />	dec	&#91;ebx&#93;.THREAD_BLOCK.blocks<br />	jne	_0<br /><br />	xor	eax, eax<br />	retn	4<br /><br />Error&#58;	dec	eax<br />	retn	4<br /><br />ScanFile_Thread ENDP</code></pre></div>
    <div class="meta">Posted on 2003-06-09 00:43:28 by bitRAKE</div>
   </div>
   <div class="post" id="post-106565">
    <div class="subject"><a href="#post-106565">Very Large File Line Count:</a></div>
    <div class="body"><strong>bitRAKE</strong> <br /><em>My computer very consistently processes a 640MB file in 22 seconds -- that is 30MB/sec </em><br />What computer configuration (hard, soft)?<br /><br />I try <strong>MMF + memchr</strong> WinAPI, C, no thread, no ReadFile:<pre><code>#define WIN32_LEAN_AND_MEAN<br />#include &lt;windows.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;limits.h&gt;<br /><br />#define INVALID_FILE_SIZE &#40;&#40;DWORD&#41;0xFFFFFFFF&#41;<br /><br />int main&#40;int argc, char *argv&#91;&#93;&#41;<br />&#123;<br />  DWORD   dwStart = GetTickCount&#40;&#41;; // = 0;<br /><br />  HANDLE  hFile   = INVALID_HANDLE_VALUE;<br />  HANDLE  hFMap   = NULL;<br />  LPVOID  pFile   = NULL;<br />  char   *pStart  = NULL;<br />  char   *pFind   = NULL;<br />  DWORD   loSize  = 0;<br />  DWORD   hiSize  = 0;<br />  DWORD   dwCount = 0;<br /><br />  if &#40;1 &gt;= argc&#41;<br />  &#123;<br />    printf&#40;&quot;Usage %s filename\n&quot;, argv&#91;0&#93;&#41;;<br />    goto cleanup;<br />  &#125;<br /><br />  hFile = CreateFile&#40;argv&#91;1&#93;, GENERIC_READ, FILE_SHARE_READ, NULL,<br />                     OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL&#41;;<br />  if &#40;INVALID_HANDLE_VALUE == hFile&#41;<br />  &#123;<br />    printf&#40;&quot;CreateFile&#40;\'%s\'&#41; failed %d\n&quot;, argv&#91;1&#93;, GetLastError&#40;&#41;&#41;;<br />    goto cleanup;<br />  &#125;<br /><br />  loSize = GetFileSize&#40;hFile, &amp;hiSize&#41;;<br />  if &#40;INVALID_FILE_SIZE == loSize&#41;<br />  &#123;<br />    printf&#40;&quot;GetFileSize failed %d\n&quot;, GetLastError&#40;&#41;&#41;;<br />    goto cleanup;<br />  &#125;<br />  if &#40;0 != hiSize&#41;<br />  &#123;<br />    printf&#40;&quot;Size great then %d\n&quot;, UINT_MAX&#41;;<br />    goto cleanup;<br />  &#125;<br />  if &#40;0 == loSize&#41;<br />  &#123;<br />    printf&#40;&quot;File is empty\n&quot;&#41;;<br />    goto cleanup;<br />  &#125;<br /><br />  hFMap = CreateFileMapping&#40;hFile, NULL, PAGE_READONLY, 0, 0, NULL&#41;;<br />  if &#40;NULL == hFMap&#41;<br />  &#123;<br />    printf&#40;&quot;CreateFileMapping failed %d\n&quot;, GetLastError&#40;&#41;&#41;;<br />    goto cleanup;<br />  &#125;<br />  CloseHandle&#40;hFile&#41;; hFile = INVALID_HANDLE_VALUE;<br /><br />  pFile = MapViewOfFile&#40;hFMap, FILE_MAP_READ, 0, 0, 0&#41;;<br />  if &#40;NULL == pFile&#41;<br />  &#123;<br />    printf&#40;&quot;MapViewOfFile failed %d\n&quot;, GetLastError&#40;&#41;&#41;;<br />    goto cleanup;<br />  &#125;<br />  CloseHandle&#40;hFMap&#41;; hFMap = NULL;<br /><br />  pStart = pFind = &#40;char *&#41;pFile;<br />  do<br />  &#123;<br />    pFind = memchr&#40;pStart, '\n', loSize&#41;;<br />    if &#40;NULL != pFind&#41;<br />    &#123;<br />      dwCount++;<br />      loSize -= &#40;pFind - pStart + 1&#41;;<br />      pStart = pFind + 1;<br />    &#125;<br />  &#125; while &#40;0 != pStart &amp;&amp; NULL != pFind&#41;;<br />  if &#40;pFind != pStart&#41; <br />    dwCount++;<br />  printf&#40;&quot;%d ends of the lines are found for %d seconds\n&quot;,<br />    dwCount, &#40;GetTickCount&#40;&#41; - dwStart&#41; / 1000&#41;;<br /><br />cleanup&#58;<br />  if &#40;NULL != pFile&#41; UnmapViewOfFile&#40;pFile&#41;;<br />  if &#40;NULL != hFMap&#41; CloseHandle&#40;hFMap&#41;;<br />  if &#40;INVALID_HANDLE_VALUE != hFile&#41; CloseHandle&#40;hFile&#41;;<br /><br />  return 0;<br />&#125;</code></pre><br /><br />Configuration:<br />Celeron Tualatin 1300 (13*100MHz) up to 1510 (13*115Mhz)<br />RAM 320Mb (115Mhz)<br />HDD 20 Gb UDMA100<br />W2k sp3<br />scan file size 746'583'601 byte<br /><br />Result:<br />23'394'001 ends of the lines are found for 25 seconds<br /><br />PS Instead of <strong>memchr</strong> can be use <strong>scasb</strong> for ANSI string and <strong>scasw</strong> for UNICODE string.</div>
    <div class="meta">Posted on 2003-06-09 20:44:55 by P2M</div>
   </div>
   <div class="post" id="post-106571">
    <div class="subject"><a href="#post-106571">Very Large File Line Count:</a></div>
    <div class="body"><strong>P2M</strong>, my hard drive sucks compared to yours. :)<br />XP 2500 Barton (at 2.0 Ghz)<br />1 GB DDR2700 (166Mhz)<br />EpoX 8RDA+ motherboard<br />Windows XP<br />...the weak link is a WD 205AA DMA66 Hard drive.  There is currently a problem with the NForce2 IDE driver - it's only working at 33MB/s instead of the rated 66MB/s.<br /><br />Results are nice! :)  How can you deal with files above 2^32 bytes. :)<br /><br />How did the code above perform?</div>
    <div class="meta">Posted on 2003-06-09 21:16:16 by bitRAKE</div>
   </div>
   <div class="post" id="post-106695">
    <div class="subject"><a href="#post-106695">Very Large File Line Count:</a></div>
    <div class="body"><strong>bitRAKE</strong> <br /><em>How can you deal with files above 2^32 bytes.</em><br />This is not simply. I use FAT32. Limit file size on FAT32: 2^32 - 1 bytes. (info from <a target="_blank" href="http://msdn.microsoft.com/library/en-us/fileio/base/supported_file_systems.asp?frame=true">Supported File Systems</a>)<br />I converted FAT32 to NTFS and has changed program.<pre><code>/* support file above 2^32 bytes*/<br />#define WIN32_LEAN_AND_MEAN<br />#include &lt;windows.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;limits.h&gt;<br /><br />#define INVALID_FILE_SIZE &#40;&#40;DWORD&#41;0xFFFFFFFF&#41;<br /><br />int main&#40;int argc, char *argv&#91;&#93;&#41;<br />&#123;<br />  DWORD     dwStart    = GetTickCount&#40;&#41;;<br />  HANDLE    hFile      = INVALID_HANDLE_VALUE;<br />  HANDLE    hFMap      = NULL;<br />  LPVOID    pFile      = NULL;<br />  char     *pStart     = NULL;<br />  char     *pFind      = NULL;<br />  LONGLONG  DefMapSize = 7 * &#40;256*1024*1024&#41;;<br /><br />  LARGE_INTEGER FileSize, MapOffset;<br />  ULONG64       EolCount;<br />  SIZE_T        MapSize;<br /><br /><br />  if &#40;1 &gt;= argc&#41;<br />  &#123;<br />    printf&#40;&quot;Usage %s filename\n&quot;, argv&#91;0&#93;&#41;;<br />    goto cleanup;<br />  &#125;<br /><br />  hFile = CreateFile&#40;argv&#91;1&#93;, GENERIC_READ, FILE_SHARE_READ, NULL,<br />                     OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL&#41;;<br />  if &#40;INVALID_HANDLE_VALUE == hFile&#41;<br />  &#123;<br />    printf&#40;&quot;CreateFile&#40;\'%s\'&#41; failed %d\n&quot;, argv&#91;1&#93;, GetLastError&#40;&#41;&#41;;<br />    goto cleanup;<br />  &#125;<br /><br />  FileSize.QuadPart = 0;<br />  FileSize.LowPart  = GetFileSize&#40;hFile, &#40;DWORD *&#41;&amp;FileSize.HighPart&#41;;<br />  if &#40;INVALID_FILE_SIZE == FileSize.LowPart&#41;<br />  &#123;<br />    printf&#40;&quot;GetFileSize failed %d\n&quot;, GetLastError&#40;&#41;&#41;;<br />    goto cleanup;<br />  &#125;<br />  if &#40;0 == FileSize.QuadPart&#41;<br />  &#123;<br />    printf&#40;&quot;File is empty\n&quot;&#41;;<br />    goto cleanup;<br />  &#125;<br />  printf&#40;&quot;FileSize is %I64u\n&quot;, FileSize.QuadPart&#41;;<br /><br />  hFMap = CreateFileMapping&#40;hFile, NULL, PAGE_READONLY, 0, 0, NULL&#41;;<br />  if &#40;NULL == hFMap&#41;<br />  &#123;<br />    printf&#40;&quot;CreateFileMapping failed %d\n&quot;, GetLastError&#40;&#41;&#41;;<br />    goto cleanup;<br />  &#125;<br /><br />  MapOffset.QuadPart = 0;<br />  EolCount = 0;<br />  while &#40;0 != FileSize.QuadPart&#41;<br />  &#123;<br />    MapSize = &#40;SIZE_T&#41; min&#40;DefMapSize, FileSize.QuadPart&#41;;<br /><br />    pFile = MapViewOfFile&#40;hFMap, FILE_MAP_READ,<br />                          MapOffset.HighPart, MapOffset.LowPart, MapSize&#41;;<br />    if &#40;NULL == pFile&#41;<br />    &#123;<br />      printf&#40;&quot;MapViewOfFile failed %d\n&quot;, GetLastError&#40;&#41;&#41;;<br />      goto cleanup;<br />    &#125;<br /><br />    FileSize.QuadPart  -= MapSize;<br />    MapOffset.QuadPart += MapSize;<br /><br />    pStart = pFind = &#40;char *&#41;pFile;<br />    do<br />    &#123;<br />      pFind = memchr&#40;pStart, '\n', MapSize&#41;;<br />      if &#40;NULL != pFind&#41;<br />      &#123;<br />        EolCount++;<br />        MapSize -= &#40;pFind - pStart + 1&#41;;<br />        pStart = pFind + 1;<br />      &#125;<br />    &#125; while &#40;0 != MapSize &amp;&amp; NULL != pFind&#41;;<br /><br />    UnmapViewOfFile&#40;pFile&#41;; pFile = NULL;<br /><br />  &#125;<br />  CloseHandle&#40;hFMap&#41;; hFMap = NULL;<br /><br />  if &#40;pFind != pStart&#41; <br />    EolCount++;<br /><br />  printf&#40;&quot;%I64u ends of the lines are found for %d seconds\n&quot;,<br />         EolCount, &#40;GetTickCount&#40;&#41; - dwStart&#41; / 1000&#41;;<br /><br />cleanup&#58;<br />  if &#40;NULL != pFile&#41; UnmapViewOfFile&#40;pFile&#41;;<br />  if &#40;NULL != hFMap&#41; CloseHandle&#40;hFMap&#41;;<br />  if &#40;INVALID_HANDLE_VALUE != hFile&#41; CloseHandle&#40;hFile&#41;;<br /><br />  return 0;<br />&#125;</code></pre>Result:<br />FileSize is 4'479'501'601<br />140'364'001 ends of the lines are found for 185 seconds</div>
    <div class="meta">Posted on 2003-06-10 19:30:51 by P2M</div>
   </div>
   <div class="post" id="post-111928">
    <div class="subject"><a href="#post-111928">Very Large File Line Count:</a></div>
    <div class="body">Hi bitRAKE, I've just been trying to rewrite/understand this code when I came across a small bug. So small it took me hours to track it down. Basically you used FILE_FLAG_NO_BUFFERING	which states<br /><div class="quote">File access must be for numbers of bytes that are integer multiples of the volume's sector size. For example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, or 2048 bytes, but not of 335, 981, or 7171 bytes. </div><br />I imagine the file you tested with happend to be a whole multiple of the sector size in lenght meaning the final block was still safe. In my test file it wasn't and ReadFileEx threw up an error.<br /><br />Here's my simple fix, You need two additional dwords, SectorSize and SectorMask. Then after <pre><code>	invoke VirtualAlloc, NULL,<br />		MAX_SCAN_MEMORY + MAX_SCAN_BLOCKS * &#40;SIZEOF THREAD_BLOCK&#41;,<br />		MEM_COMMIT or MEM_RESERVE,<br />		PAGE_READWRITE<br />	test	eax, eax<br />	je	mem_ERROR<br /><br />	lea	ebx, &#91;eax + MAX_SCAN_MEMORY&#93;<br />	mov	edi, eax<br /></code></pre><br />add <pre><code>	invoke GetDiskFreeSpace,0,eax,offset SectorSize,eax,eax<br />	dec 	SectorSize<br />	mov 	eax, SectorSize<br />	xor 	eax, 0FFFFFFFFh<br />	mov 	SectorMask, eax</code></pre><br />and replace <pre><code>_io&#58;	add	esi, MAX_SCAN_MEMORY<br />	adc	edi, 0<br /><br />	invoke ReadFileEx, hBigFile, &#91;ebx&#93;.THREAD_BLOCK.mem, eax, ebx, OFFSET BlockComplete<br />	test	eax, eax<br />	jne	_w</code></pre><br />with<pre><code>_io&#58;	add 	eax, SectorSize<br />	add	esi, MAX_SCAN_MEMORY<br />	and 	eax, SectorMask<br />	adc	edi, 0<br /><br />	invoke ReadFileEx, hBigFile, &#91;ebx&#93;.THREAD_BLOCK.mem, eax, ebx, OFFSET BlockComplete<br />	test	eax, eax<br />	jne	_w</code></pre>I think this fixs it.</div>
    <div class="meta">Posted on 2003-07-25 23:07:15 by Eóin</div>
   </div>
   <div class="post" id="post-112035">
    <div class="subject"><a href="#post-112035">Very Large File Line Count:</a></div>
    <div class="body"><div class="quote"><br /><pre><code><br />	and 	eax, SectorMask<br />	adc	edi, 0<br /></code></pre></div><br /><br />Note I don't understand the code all over, but those instructions could be incorrect. You have to exchange them.</div>
    <div class="meta">Posted on 2003-07-27 12:35:12 by MazeGen</div>
   </div>
   <div class="post" id="post-112087">
    <div class="subject"><a href="#post-112087">Very Large File Line Count:</a></div>
    <div class="body">I believe you are correct, I was clearly a bit hasty. Thanks :)</div>
    <div class="meta">Posted on 2003-07-27 18:45:25 by Eóin</div>
   </div>
  </div>
 </body>
</html>