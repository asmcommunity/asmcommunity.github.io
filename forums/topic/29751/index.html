<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>BAFO 1284 pritning cable: writing byte to parallel port - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29751" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=113">Low Level Concepts</a> &raquo; <a href="../?id=29751">BAFO 1284 pritning cable: writing byte to parallel port</a></p>
   <div class="post" id="post-210154">
    <div class="subject"><a href="#post-210154">BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">Hi all,<br />I am new to windows programming. I want to communicate with the PIC programmer&nbsp; which my friend has developed.<br />I am using BAFO 1284 parallel printing cable for this since laptop does not have any LPT port<br />I reffered following links for the same.<br /><br />http://www.asmcommunity.net/board/index.php?action=printpage;topic=21143.0<br />http://blog.peter.skarpetis.com/.<br />I developed the code using the Visual&nbsp; studio 6.0.<br /><br />while debugging the WriteFile() is able to write successfuly, atleast the number of bytes sent is 1.<br />but the data is not seen on the actual port pins.<br />At first the Writefile was hanging up , but i reffered link 1 mentioned above, after i connected pin 10 and 11 to ground using 440 ohms(220+220) the api started working. also when i plug in the BAFO 1284 (in debug mode) i am able to get the guid string, and when i remove the BAFO 1284 printing cable, the code exits as expected.<br />Can any one please help me, and tell me why the data is not seen on port, even though nACK and BUSY pin status is succesfully checked by WritFile().<br />This is my code :&nbsp; :) means the one i have assembled using this&nbsp; forum<br />/***********************************************************************************/<br />/* Code to find the device path for a usbprint.sys controlled <br /> * usb printer and print to it<br /> */<br />#include &lt;windows.h&gt;<br />#include &quot;iostream.h&quot;<br />#include&lt;stdio.h&gt;<br />#include &lt;SETUPAPI.H&gt;<br />#include &lt;MALLOC.H&gt;<br />#include &lt;SETUPAPI.H&gt;<br />#include &lt;MALLOC.H&gt;<br />#include &lt;time.h&gt;<br /> <br /><br />void sleep(unsigned int mseconds)<br />{<br />&nbsp; &nbsp; clock_t goal = mseconds + clock();<br />&nbsp; &nbsp; while (goal &gt; clock());<br />}<br /><br /><br />//const GUID GUID_DEVINTERFACE_USBPRINT = {0x36FC9E60,0xC465,0x11CF,0x8056,0x444553540000};<br /><br />/* This define is required so that the GUID_DEVINTERFACE_USBPRINT variable is<br /> * declared an initialised as a static locally, since windows does not include it in any<br /> * of its libraries<br /> */<br />/*<br />#define SS_DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \<br /><br />static const GUID DECLSPEC_SELECTANY name \<br />= { l, w1, w2, { b1, b2,&nbsp; b3,&nbsp; b4,&nbsp; b5,&nbsp; b6,&nbsp; b7,&nbsp; b8 } }<br /><br />SS_DEFINE_GUID(GUID_DEVINTERFACE_USBPRINT, 0x28d78fad, 0x5a12, 0x11D1, 0xae, 0x5b, 0x00, 0x00, 0xf8, 0x03, 0xa8, 0xc2);<br />*/<br />const GUID GUID_DEVINTERFACE_USBPRINT = {0x28d78fad,0x5a12,0x11D1,0xae,0x5b,0x00,0x00,0xf8,0x03,0xa8,0xc2}; <br />void main()<br />{ DWORD err =0;<br />&nbsp; HDEVINFO devs;<br />&nbsp; HANDLE port;<br />&nbsp; DWORD devcount;<br />&nbsp; DWORD dataType;<br />&nbsp; SP_DEVINFO_DATA devinfo;<br />&nbsp; SP_DEVICE_INTERFACE_DATA devinterface;<br />&nbsp; DWORD size;<br />&nbsp; GUID intfce;<br />&nbsp; PSP_DEVICE_INTERFACE_DETAIL_DATA interface_detail;<br />&nbsp; err = GetLastError(); <br />&nbsp; intfce = GUID_DEVINTERFACE_USBPRINT;<br />&nbsp; devs = SetupDiGetClassDevs(&amp;intfce, 0, 0, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);<br />&nbsp; if (devs == INVALID_HANDLE_VALUE) {<br />&nbsp; &nbsp; return;<br />&nbsp; }<br />&nbsp; devcount = 0;<br />&nbsp; devinterface.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);<br />&nbsp; while (SetupDiEnumDeviceInterfaces(devs, 0, &amp;intfce, devcount, &amp;devinterface)) {<br />&nbsp; &nbsp; //&nbsp; The following buffers would normally be malloced to he correct size<br />&nbsp; &nbsp; // but here we just declare them as large stack variables<br />&nbsp; &nbsp; // to make the code more readable<br />&nbsp; &nbsp; //<br />&nbsp; &nbsp; char driverkey[2048];<br />&nbsp; &nbsp; char interfacename[2048];<br />&nbsp; &nbsp; char location[2048];<br /><br />	err = GetLastError();	&nbsp; &nbsp; <br />&nbsp; &nbsp; //If this is not the device we want, we would normally continue onto the next one<br />&nbsp; &nbsp;  //so something like if (!required_device) continue; would be added here<br />&nbsp; &nbsp;  ///<br />&nbsp; &nbsp; devcount++;<br />&nbsp; &nbsp; size = 0;<br />&nbsp; &nbsp; // See how large a buffer we require for the device interface details //<br />&nbsp; &nbsp; SetupDiGetDeviceInterfaceDetail(devs, &amp;devinterface, 0, 0, &amp;size, 0);<br />&nbsp; &nbsp; devinfo.cbSize = sizeof(SP_DEVINFO_DATA);<br />&nbsp; &nbsp; interface_detail = calloc(1, size);<br />&nbsp; &nbsp; if (interface_detail) {<br />&nbsp; &nbsp; &nbsp; interface_detail-&gt;cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);<br />&nbsp; &nbsp; &nbsp; devinfo.cbSize = sizeof(SP_DEVINFO_DATA);<br />&nbsp; &nbsp; &nbsp; if (!SetupDiGetDeviceInterfaceDetail(devs, &amp;devinterface, interface_detail, size, 0, &amp;devinfo)) {<br />	free(interface_detail);<br />	SetupDiDestroyDeviceInfoList(devs);<br />	return;<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; // Make a copy of the device path for later use //<br />&nbsp; &nbsp; &nbsp; strcpy(interfacename, interface_detail-&gt;DevicePath);<br />&nbsp; &nbsp; &nbsp; free(interface_detail);<br />&nbsp; &nbsp; &nbsp; // And now fetch some useful registry entries //<br />&nbsp; &nbsp; &nbsp; size = sizeof(driverkey);<br />&nbsp; &nbsp; &nbsp; driverkey[0] = 0;<br />&nbsp; &nbsp; &nbsp; if (!SetupDiGetDeviceRegistryProperty(devs, &amp;devinfo, SPDRP_DRIVER, &amp;dataType, (LPBYTE)driverkey, size, 0)) {<br />	SetupDiDestroyDeviceInfoList(devs);<br />	return;<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; size = sizeof(location);<br />&nbsp; &nbsp; &nbsp; location[0] = 0;<br />&nbsp; &nbsp; &nbsp; if (!SetupDiGetDeviceRegistryProperty(devs, &amp;devinfo, SPDRP_LOCATION_INFORMATION, &amp;dataType, (LPBYTE)location, size, 0)) {<br />	SetupDiDestroyDeviceInfoList(devs);<br />	return;<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; port = CreateFile(interfacename, GENERIC_WRITE, FILE_SHARE_READ,NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,NULL);<br />&nbsp; &nbsp; &nbsp; if (port != INVALID_HANDLE_VALUE) {<br />	/* Now perform all the writing to the device ie.*/<br />	OVERLAPPED olWrite = { 0 };<br /><br />	olWrite.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL);<br />err = GetLastError();<br />&nbsp; &nbsp;  <br />	 while (1)<br />	 {&nbsp;  DWORD bytes_written = 0;<br />		 <br />	&nbsp; &nbsp;  static int buf= 0;<br />		 char ret1 = 0;<br />		// size = 1;<br />		DWORD&nbsp;  errors=0;<br />		COMSTAT lpStat;<br />		ClearCommError(port, &amp;errors, &amp;lpStat);<br />		ret1= WriteFile(port, &amp;buf, 2,&amp;bytes_written,&amp;olWrite);<br />		buf++;<br />		if(ret1 ==0)<br />		{<br />			DWORD err =0;<br />		&nbsp; &nbsp; err = GetLastError();<br />			printf(&quot;ERROR&quot;);<br />			//break;<br />		}<br />		else<br />		{&nbsp;  static int i = 0;<br />		&nbsp; &nbsp; i++;<br />			printf(&quot;%d\r\n&quot;,i);<br />			sleep(1000);<br />		}<br />	 }<br /><br />	 <br />	CloseHandle(port);<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br />&nbsp; }<br />&nbsp; SetupDiDestroyDeviceInfoList(devs);<br />}<br />/*******************************************************************************/<br /><br />Best regards<br />Rohit<br /><br /></div>
    <div class="meta">Posted on 2010-01-01 23:20:23 by rohitd</div>
   </div>
   <div class="post" id="post-210155">
    <div class="subject"><a href="#post-210155">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">Your WriteFile call sends two bytes, but you increment the bufferpointer by one byte.<br /></div>
    <div class="meta">Posted on 2010-01-01 23:41:43 by Homer</div>
   </div>
   <div class="post" id="post-210157">
    <div class="subject"><a href="#post-210157">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">opps , sorry, that was one of the change i made to see if the number of bytes sent make any difference. if it is 1 even then the same thing happens</div>
    <div class="meta">Posted on 2010-01-01 23:48:40 by rohitd</div>
   </div>
   <div class="post" id="post-210158">
    <div class="subject"><a href="#post-210158">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">It&#039;s not jumping out at me.<br />Start adding debug lines after each api call, and check all the return values, from the top down.<br />As you go, you can eliminate the debug lines behind you, until you find the offending api.<br />Not the most efficient, but it will work.</div>
    <div class="meta">Posted on 2010-01-01 23:58:31 by Homer</div>
   </div>
   <div class="post" id="post-210160">
    <div class="subject"><a href="#post-210160">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">Hi Homer,<br /><br />Thanks a lot for replying.<br />The WriteFile() api returns 1 and bytes_written is also 1. the problem is some how the data is not replicated on the port pins.<br />the input pins i.e nAck and BUSY are being sensed succesfully.<br />The problem is somethign related to some setting, related to parallel port which i am missing.<br />I think some thing related to registry key ....<br />Also i dont know how to set the port out put mode ECP, EPP and so on<br /><br />Thanks<br />Rohit</div>
    <div class="meta">Posted on 2010-01-02 00:09:38 by rohitd</div>
   </div>
   <div class="post" id="post-210161">
    <div class="subject"><a href="#post-210161">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">You are grounding the ACK and BUSY lines !!<br /><br />Pin10 is ACK<br />Pin11 is BUSY<br /><br />Your device can tell the computer that &quot;the printer is busy&quot; by holding the BUSY line HIGH.<br />It should do this in response to the Stobe line being toggled.<br />Holding it LOW when the computer is allowed to send some data.<br /><br />Since you&#039;re using Printer api, ignore that and lets move on.<br />You can&#039;t just hold the ACK line low.<br />It&#039;s meant to be normally HIGH, and given a low pulse when your Device has accepted the Byte.<br /><br /><div class="quote">Once the printer has accepted data, it will acknowledge the byte by a negative pulse about 5uS on the nAck line.</div><br /></div>
    <div class="meta">Posted on 2010-01-02 00:56:00 by Homer</div>
   </div>
   <div class="post" id="post-210162">
    <div class="subject"><a href="#post-210162">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">Hi Homer,<br /><br />:) It worked.<br />Thanks a lot.<br />what i did was i removed the register connection of pin 10 i.e ACK. The register connecting the pin 11 (BUSY)to ground is still present. Now when i write a byte then the data is seen on the port, but still the write API&nbsp; has not returned, and nothing is printed on the output terminal(i.e. printf is not executed), now when i connect the pin 10 register to ground again the writefile api returns 1, and message is printed on output. if i do not toggele the pin 10 writefile() hangs. so if i have to output next byte i need to connect the pin 10 nACK to ground via 440 ohms register once and disconnect again. also if i exit the code, change the byte to send to some other value ,recompile the code and re-run the code, the new byte wont come on the port unless i ack the previous one. :) So its up and running now :) i will be making a DLL and post it here so that every body can use it. Thanks again Homer for your promt answers. <br /><br />Best regards<br />Rohit</div>
    <div class="meta">Posted on 2010-01-02 01:47:14 by rohitd</div>
   </div>
   <div class="post" id="post-210163">
    <div class="subject"><a href="#post-210163">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">Hi,<br /><br />i have one more query .<br />How can i access other i/o pins, i need to write to strobe and one or two output pins,and i need to read some of the other input pins (not the data port).<br /><br />the programmer (to whihc i want t communicate)is using these pins for some syncronisation and reading the PIC micro controller information.<br /><br />thanks and regards<br />rohit</div>
    <div class="meta">Posted on 2010-01-02 02:09:02 by rohitd</div>
   </div>
   <div class="post" id="post-210164">
    <div class="subject"><a href="#post-210164">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">You don&#039;t need to write to Strobe.<br /><br />The computer will check the BUSY line, and if its ok, it will put its data out, and toggle the Strobe line.<br />Your device needs to somehow detect the Strobe line toggling.<br />It might be done by connecting it to the device&#039;s Clock line, assuming you can use an external clock!<br /><br />So, once your device sees Strobe toggle, it knows theres some data, and accepts it (flashes its Load line, or whatever).<br />Shortly thereafter, it toggles the ACK line, which tells the computer it&#039;s time to check the BUSY line again.<br />So you could think of the ACK line as being the IRQ line.<br /><br />So your problem isn&#039;t in the software at all, its in your interface design. Time to think about what goes where and when, but you&#039;re very close !<br /></div>
    <div class="meta">Posted on 2010-01-02 02:35:30 by Homer</div>
   </div>
   <div class="post" id="post-210167">
    <div class="subject"><a href="#post-210167">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">hi,<br /><br />since i am interfacing the PIC18F programmer to the parallel port, i need to interface all the pins as if i am using a normal LPT port. so i need to read few of the parallel port pins and write to parallel port pins [ none of these pins are from D0-D7 data port pins]. these port pins are needed to do some controlling work during flashing of the microcontroller.Initialy this programmer was designed for LPT port using the inputout32.dll, but if I want to use this programmer on the printer cable i should be able to access all the port pins available on printer port individualy. so i am wondering how to do this usning the windows api.<br /><br />Best regards<br />rohit</div>
    <div class="meta">Posted on 2010-01-02 03:17:48 by rohitd</div>
   </div>
   <div class="post" id="post-210168">
    <div class="subject"><a href="#post-210168">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">If using a NT based OS you will need to use something like WinIO, which is an api that allows you to write to all the pins, and could be a replacement for all your existing code, giving you full control.<br /><br />Here&#039;s the pinouts and the IO Port addresses for the data, control and status pins:<br />http://www.easyfreeware.com/images/screenshots/parallel_port_viewer_internet___networking-7310-screenshot.gif<br /></div>
    <div class="meta">Posted on 2010-01-02 03:47:53 by Homer</div>
   </div>
   <div class="post" id="post-210169">
    <div class="subject"><a href="#post-210169">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">Hi Homer,<br />thanks for the information.<br />I downloaded winio.dll from the net. but&nbsp; i was not able to get any VC source code using this dll. do you have any link from where i can download the cexample code for using the dll. also do i need to download any other supporting files.<br /><br />best regards<br />rohit</div>
    <div class="meta">Posted on 2010-01-02 04:45:42 by rohitd</div>
   </div>
   <div class="post" id="post-210170">
    <div class="subject"><a href="#post-210170">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">Genuine package is here http://www.internals.com/utilities/winio.zip<br />Contains full source + C example also.</div>
    <div class="meta">Posted on 2010-01-02 05:00:15 by Homer</div>
   </div>
   <div class="post" id="post-210171">
    <div class="subject"><a href="#post-210171">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">Hi homer,<br />Thanks a lot for the files.<br />But how do i determine the physical address of my parallel port. since it is detected as a printing device. if i go in to the device manager there is no physical address asigned only some hardware id,matching device ids etc. BTW i am working on windows XP. Can api MapPhysToLin() be used for detecting the physical address.<br /><br /><img src="" /><br /><br />best regards<br />rohit</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3043" target="_blank">usb_parallelCable.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-01-02 06:09:38 by rohitd</div>
   </div>
   <div class="post" id="post-210224">
    <div class="subject"><a href="#post-210224">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">Hi rohitd.<br /><br />Is it too much to ask if you could just attach the complete project files? The code you have posted is in C#?. <br /><br />Im trying to use this code with a similar adapter like yours.<br /><br />Thank you, again.</div>
    <div class="meta">Posted on 2010-01-14 21:58:01 by BrunoF</div>
   </div>
   <div class="post" id="post-210237">
    <div class="subject"><a href="#post-210237">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">Well, i finally re-started all again but in VB6.<br /><br />Its running ok, but really slow. It takes up to 3 seconds in sending 256 bytes to the port. I would like to believe that its because im not changing the ACK pin, so its changing with every timeout...<br /><br />And, actually im with a pulldown&nbsp; resistor on pin 10, and pin 11 floating...<br /><br />I guess i will have to continue trying. I will connect a microcontroller tomorrow to make the ACK signal and see if i can speed it up. <br /><br /></div>
    <div class="meta">Posted on 2010-01-17 21:59:08 by BrunoF</div>
   </div>
   <div class="post" id="post-210238">
    <div class="subject"><a href="#post-210238">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">P.S.<br /><br />Im using a &quot;Manhatan&quot; brand USB to parallel adapter.<br /><br />Cheers.</div>
    <div class="meta">Posted on 2010-01-17 21:59:58 by BrunoF</div>
   </div>
   <div class="post" id="post-210239">
    <div class="subject"><a href="#post-210239">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">Maybe this could help.<br /><br />Im investigating a little more, and seems that WriteFileEx() its similar to WriteFile(), but asynchronously. This may be helpful to, maybe(didnt test it) avoid acknowledge from device.<br /><br />Cant tell the difference really. I have a testboard but tomorow will get final results.<br /><br /></div>
    <div class="meta">Posted on 2010-01-17 22:24:05 by BrunoF</div>
   </div>
   <div class="post" id="post-210240">
    <div class="subject"><a href="#post-210240">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">The only new thing in WriteFileEx is support for specifying a &#039;Completion Callback&#039; function to be called when the IO request actually completes.<br /><br />WriteFile/WriteFileEx BOTH support the use of OVERLAPPED IO, which is an alternative (and preferred) way to obtain notification of Completion of your IO request, via a data structure called Overlapped (which can contain your desired 64bit file offset for each IO request), and noting that you&#039;ll need to use FILE_OVERLAPPED flag in call to CreateFile.<br />Notification is typically received via triggering of an event handle (you placed in the overlapped struct), but it&#039;s also possible to use this kind of file io with IOCP thread pooling... allowing optimal performance on machines with more than one logical cpu through concurrent execution of one worker thread per logical cpu.<br /><br />You have to ask yourself why you&#039;re using asynch file io - the caller will be returned control instantly, but the operation itself may still be pending completion, and any buffer associated with it must not be touched until it does complete... you end up , usually, having to work with lots of little data buffers (heap memory objects etc) which represent your io operations, and dispose of them when you&#039;re notified of their Completion - which, by the way, is your only chance to check for errors with Overlapped io model, since the Read/WriteFile calls will just return ERROR_IO_PENDING, meaning &quot;your io operation will complete sometime later, don&#039;t call us, we&#039;ll call you&quot;.<br />Unless you have a lot of independant data channels, there&#039;s often little reason to use asynch io, and the more you expect from it, the more complicated your implementation can become.<br /><br />For asynchronous io, Completion Callbacks are simple, but don&#039;t perform as well as Overlapped io, and don&#039;t scale as well as Overlapped IO with IO Completion Port event handling via a pool of worker threads.<br /><br />It may be worth looking at the CreateFile flags again, you might want to try turning off the internal buffering etc. since your device doesn&#039;t have trouble keeping up with the port.<br /><br />But WriteFileEx is not a solution by itself.<br />Problems... the hEvent field of the Overlapped struct is ignored by this api function, so we HAVE to use the Completion Routine, or the IOCP method.<br />And it gets worse.<br />The io subsystem will call your completion routine (or post a completion message to your iocp) when the first io operation completes.<br />But it won&#039;t post any subsequent notifications until your completion routine returns (or your iocp message is dequeued by a worker).<br />So even though several pending io operations may have completed, you&#039;ll only be notified about one of them!<br />The subtle difference between callback and iocp notifications is that the iocp workers can concurrently be dequeuing completion messages without blocking, whereas the completion callback notification scheme is actually BLOCKING!!!<br />Not really that asynchronous after all? They&#039;ve just moved the bottleneck LOL!!!<br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2010-01-18 00:26:47 by Homer</div>
   </div>
   <div class="post" id="post-210244">
    <div class="subject"><a href="#post-210244">Re: BAFO 1284 pritning cable: writing byte to parallel port</a></div>
    <div class="body">Hi Homer.<br /><br />First, thanks for all before and actual assistence.<br /><br />So, WriteFileEx isn&#039;t the solution. I started to believe it yesterday, when i start to play with FLAGS and nothing happens. The only difference, as you have perfectly said, is that the function returns before data send completion.<br /><br />So, now the big question is how yo speed up data out, because its REALLY slow(like 80 Bps). I cant believe this could be used in any kind of decent printer...<br /><br />Maybe with device ACK, times between data bytes will decreace.<br /><br />Thx again.</div>
    <div class="meta">Posted on 2010-01-18 07:34:22 by BrunoF</div>
   </div>
  </div>
 </body>
</html>