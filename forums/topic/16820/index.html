<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>CBoundingBox - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16820" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=16820">CBoundingBox</a></p>
   <div class="post" id="post-130497">
    <div class="subject"><a href="#post-130497">CBoundingBox</a></div>
    <div class="body">Heya all.<br />I thought I'd devote a thread to this class, since its so generically useful to 3D gamecoding.<br />CBoundingBox class provides all the necessary code to perform all kinds of intersection tests of points, lines, planes and of course, bounding boxes, against one another. <br />One very good example of why you might wish to perform such tests is culling. We can define the Viewing Frustrum as a boundingbox, and check what's totally inside it, whats partially inside it, and whats not inside it at all, before we go rendering stuff to the screen.<br />Another obvious example is testing for collisions of point and planes, after all, we don't want objects falling through the floor, and we'd like them to stop when they hit walls :)<br /><br />The class I will describe is taken from my bsp demo, which itself is incomplete.<br />I'd love to hear any feedback, particularly in terms of optimisations to the code presented - if we are going to use this class for things like culling and collision detection, we'd like it to be as fast as possible.<br /><br />I'll begin by describing the functions within the class, then we'll define the class object and its data members, and finally, begin presenting the actual code.<br /><br />Function #1 - FindBoundingBoxA<br />This function is used to calculate the tightest fitting boundingbox around an arbitrary number of vertices (points in 3D space).<br /><br />Function #2 - FindBoundingBoxB<br />This variation of the above function calculates a boundingbox from two vertices (which could be considered corners of the BB).<br /><br />Both of these functions can handle situations where an axis of the BB has zero depth in an axis (all lay on an axial plane).<br /><br />Function #3 - SetBoundingBoxA<br />This function sets an object's BoundingBox once its been calculated, and additionally calculates and sets the six PLANES which are the faces of the boundingbox. Objects wishing to have support from CBoundingBox class can either inherit from it (if they are class-based themselves) or create an instance of CBoundingBox for themselves and store a pointer to it in their struct.<br /><br />Function #4 - SetBoundingBoxB<br />This variation of the above function sets the boundingbox and planes for an object same as above, except it assumes the planes are precalculated and takes a pointer to them as a parameter.<br /><br />Function #5 - TransformBoundingBox<br />This function manipulates all of a boundingbox's 8 points and 6 planes according to a given transformation matrix.<br /><br />Function #6 - IsIntersecting<br />This function performs intersection tests between two boundingboxes. The four possible return values are:<br />NOT_INTERSECTING          equ 0<br />PARTIALY_INTERSECTING equ 1<br />COMPLETELY_COVER        equ 2<br />COMPLETELY_INSIDE        equ 3<br /><br />Function #7 - LazyIsIntersecting<br />Same as above, except less computationally intensive (less accurate but lots faster). It's useful to perform a rough test, and if it returns a positive result, we can optionally perform a more accurate test or tests.<br /><br />Function #8 - IsPenetrated<br />This function tests for intersection of a boundingbox and a line (two points).<br />It simply returns TRUE or FALSE.<br /><br />Except for a couple of helper functions which I consider to be external to the Class (no good reason to add class calling overhead to generic functions) that pretty much wraps up the functionality of CBoundingBox class.<br /><br />An idea I had which is yet to be explored is the concept of creating HIERARCHIES of boundingboxes whereby we could reduce the number of tests necessary.<br />For instance, one BoundingBox might contain several others. If we performed a test on the larger, outer BB first and it failed, we could forego performing the same test on anything inside it. This could be useful in situations like culling of objects. If the larger BB does not intersect the viewing frustrum for example, theres no possibility of any of its child BB's from penetrating it.<br />Next time we'll start laying out the class definition for CBoundingBox and examine its data members more closely.<br /><br />Have a nice day :)</div>
    <div class="meta">Posted on 2004-01-13 03:57:35 by Homer</div>
   </div>
   <div class="post" id="post-130500">
    <div class="subject"><a href="#post-130500">CBoundingBox</a></div>
    <div class="body">Well I was bored so I decided to make another post immediately.<br />I want to lay out the class definition for you.<br />For some of you, this may be your first ever look at an oop class in asm.<br />I want you to know that I've adopted the ATC oop support macros which were written by Ultrano, a regular user of this board.<br />There are several other oop implementations around, but I like his one.<br />Enough waffling, on with the show :)<br /><br />We will define a top level class (one that doesnt inherit from another class).<br />Under ATC, we can define Class Methods (functions) two ways:<br />virtual MethodName will define a Method that can be overridden by a Method of the same name in a class that inherits from the current one.<br />void MethodName will define a Method that CANNOT be overridden. 'void' does NOT imply that there is no return value, it only refers to that feature of inheritance. This is NOT C++, it just looks a little similar sometimes :P<br /><br />The class definition looks like this:<br /><br />class CBoundingBox<br />;---Class Methods---<br />void FindBoundingBoxA<br />void FindBoundingBoxB<br />void SetBoundingBoxA<br />void SetBoundingBoxB<br />void TransformBoundingBox<br />void IsIntersecting<br />void LazyIsIntersecting<br />void IsPenetrated<br />;---Class Data---<br />long valid<br />array points,D3DXVECTOR3,8<br />array planes,D3DXPLANE,6<br />endclass<br /><br />Now some notes.<br />We do not need to describe the number or type of params for Methods.<br />There are several keywords (theyre macros) we can use to add various data types to our Class. Here's a few of them:<br /><br />char -   defines a named BYTE<br />short - defines a named WORD<br />long - defines a named DWORD<br />float -  defines a named 32bit FLOAT (real4)<br />real -   defines a named 64bit FLOAT (real8)<br /><br />The 'array' type was only added to ATC by me today and may be subject to change without notice. Previously I had been using a macro called 'AddClassData' which is part of ATC and is used internally to define the various datatypes, and can be used to add unhandled types.<br />For the curious among you who have the latest version of ATC and are wondering where the 'array' macro is, its right here :<br /><br />array macro argName:REQ, argType:REQ, argNum:REQ<br />        AddClassData &lt;argName argType argNum dup (&lt;?&gt;)&gt;<br />endm<br /><br />===========<br />The Class Data<br />===========<br />valid is defined as a DWORD, but probably should be a BYTE since its merely a BOOLEAN flag that is used to determine whether a particular instance of the class object has been initialised or not.<br />points is an array of 8 vec3's that define the xyz values of the 8 corners of a box.<br />Note here that the box does not have to be regular, it can be trapezoidal (squashed), it just has to have eight corners.<br />planes is an array of 6 planes which define the planes formed by the six sides of the box.<br />Nothing has been given any initial values, but ATC will zero everything when an object instance is created.<br /><br />Once we have defined the class above in our source, we can create any number of instances of the class ('objects') using the 'new' directive (another macro).<br />'new' returns a pointer to the object instance which should be stored somewhere, and has been setup like '$invoke' to allow the following syntax:<br />mov pBB, new (CBoundingBox)<br />See, it DOES look like C++ :grin:<br /><br />I modified my own version of 'new' to preserve ecx register, the reasons for this will become obvious when we start looking at the code, and I'll ask Ultrano to make this change standard in the next public release of ATC. <br /><br />Thats it for my posting for today, I know I rambled a lot, I'm sure those unfamiliar with ATC oop programming will appreciate it all the same.<br /><br />Have a nice day :)</div>
    <div class="meta">Posted on 2004-01-13 05:17:14 by Homer</div>
   </div>
   <div class="post" id="post-130502">
    <div class="subject"><a href="#post-130502">CBoundingBox</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br /><div class="quote"> An idea I had which is yet to be explored is the concept of creating HIERARCHIES of boundingboxes whereby we could reduce the number of tests necessary.<br />For instance, one BoundingBox might contain several others. If we performed a test on the larger, outer BB first and it failed, we could forego performing the same test on anything inside it. This could be useful in situations like culling of objects. If the larger BB does not intersect the viewing frustrum for example, theres no possibility of any of its child BB's from penetrating it. </div> <br /><br />This is basically how you use an Octree. It's the modern replacement to BSP.<br />The nice extra feature is that you can actually have deformable objects using Octree culling. Recalculation during realtime is no problem (unlike the preprocessed data for BSP).<br />When I say &quot;Deformable objects&quot;, I mean stuff like allowing the player to blow holes in *any* of the walls/etc. With BSP, you have to already select which walls are &quot;blowable&quot;.<br /><br />Are the bounding boxes actual boxes? If used as the view frustrum it wouldn't be correct. The view frustrum angles out from the viewer like a cone (or like a Trapezoid).<br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2004-01-13 06:20:40 by Scronty</div>
   </div>
   <div class="post" id="post-130503">
    <div class="subject"><a href="#post-130503">CBoundingBox</a></div>
    <div class="body">Scronty,<br /> <br />I did mention that they are deformable in my second posting, quoting myself :<br /><div class="quote">points is an array of 8 vec3's that define the xyz values of the 8 corners of a box.<br />Note here that the box does not have to be regular, it can be trapezoidal (squashed), it just has to have eight corners.</div><br /><br />:)<br /><br />Are there any decent map editors that produce pre-sorted octrees?<br />octree and hextree are as old as bsp, but I had no idea they were being applied in such ways, intruiging :)</div>
    <div class="meta">Posted on 2004-01-13 06:55:28 by Homer</div>
   </div>
   <div class="post" id="post-130559">
    <div class="subject"><a href="#post-130559">CBoundingBox</a></div>
    <div class="body">Scronty,<br />I've just done a little digging around the modern usage of OSP Trees, and I find they have two common forms:<br />1&gt;Hierarchical Bounding Volumes<br />2&gt;Canonical Space Subdivision<br /><br />The descriptions of both types insist that the boundingboxes be pure cubes whose faces are axially aligned to the World Axes, can you think of any good reason for this? Is it to eliminate the need for storing plane information in the nodes, and to allow for using simplistic axial comparison in the math rather than performing plane tests? Or is this just leftover logic from the earliest form of osp (canonical space subdivision)?<br /><br />To put it plainly, this cubic approach is fine as long as the cubes are large enough such that a rotating object never protrudes through its own cube, but then the cubes are relatively inaccurate for intersection testing, and the whole approach seems unsuitable to long, thin objects, it seems geared towards round or cubic objects.<br />This includes world surfaces.<br /><br />Perhaps the tightest-fitting approach might have merit in an osp engine, if planes could be calculated on the fly, or at least not stored in the boundingbox nodes themselves but in a separate mapped database?<br /><br />What are your thoughts?</div>
    <div class="meta">Posted on 2004-01-13 22:15:00 by Homer</div>
   </div>
  </div>
 </body>
</html>