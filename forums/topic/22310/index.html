<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Bitmap shift Question - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=22310" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=22310">Bitmap shift Question</a></p>
   <div class="post" id="post-167602">
    <div class="subject"><a href="#post-167602">Bitmap shift Question</a></div>
    <div class="body">Hi, I need U help:<br />     In memory DC,   create a compatible memory dc and bitmap as background,and create another compatible dc and bitmap ,the moving bitmap should pass throught the background bitmap while the background image keep still,then bitblt to window client area DC to display the result.<br />   How do I? Doest it refer to SRCPAINT raster in Bitblt function?<br />   Many TXS!<br />   Best Regard.<br /></div>
    <div class="meta">Posted on 2005-11-07 03:07:40 by Luckrock</div>
   </div>
   <div class="post" id="post-167617">
    <div class="subject"><a href="#post-167617">Re: Bitmap shift Question</a></div>
    <div class="body">The easiest option is to hold both your background bitmap and the other bitmap in their own separate compatible DCs. You also keep the current coordinates (top left corner) of the other bitmap.<br /><br />Then, whenever you want to display the other bitmap at some other location, bitblt part of the background bitmap (the size of the other bitmap) where the current other bitmap is located to restore your background before you bitblt the other bitmap to the new location. Update the current coordinates of the other bitmap.<br /><br />Raymond<br /></div>
    <div class="meta">Posted on 2005-11-07 10:12:27 by Raymond</div>
   </div>
   <div class="post" id="post-167640">
    <div class="subject"><a href="#post-167640">Re: Bitmap shift Question</a></div>
    <div class="body"> Hi,Raymond,<br />          Many thanks to your reply.<br />      &quot;The easiest option is to hold both your background bitmap and the other bitmap in their own separate compatible DCs. &quot;. as what you said, Yes, I save the two bitmap in different compatible DCs:<br />       <br />In WM_CREATE MESSAGE ,create a still bitmap (painted by 20 green line) as background,as follow code piece:<br /><br /><pre><code>        ;Create the first( Background)  Dc and bitmap <br />        invoke CreateCompatibleDC,hdc<br />        mov    hdc_Grid,eax<br />        invoke CreateCompatibleBitmap,hdc_Grid,maxX,maxY<br />        mov    hBitmap_Grid,eax<br />        invoke  SelectObject,hdc_Grid,hBitmap_Grid                      <br />        mov	  eax,cOScopeLeft                                           ;set This bitmap  coordinates and size<br />	mov	  rcGrid.left,eax<br />	add	  eax,cOScopeWidth	<br />	mov	  rcGrid.right,eax		       <br />        mov	  eax,cOScopeTop<br />        mov	  rcGrid.top,eax<br />        add	  eax,cOScopeHeight<br />        mov	  rcGrid.bottom,eax		; <br />        <br />        invoke  SelectObject,hdc_Grid,hBrush_Black                        ;paint it with black brush<br />        invoke  PatBlt, hdc_Grid,0 , 0, maxX, maxY, PATCOPY<br />        <br />                  invoke SelectObject,hdc_Grid,hPenGreen         ;draw 20 horizonal green lines as background<br />                  mov COUNT,0                         <br />                  m2m pt.x,rcGrid.left                          <br />                  m2m pt.y,rcGrid.top<br />                  .while COUNT!=20                      <br />                         inc  COUNT<br />                         invoke MoveToEx,hdc_Grid,pt.x,pt.y,NULL<br />                         invoke LineTo,  hdc_Grid,cOScopeWidth, pt.y<br />                         add  pt.y,20                         ;Grid Step=20 pixels<br />                         ;PrintDec pt.y<br />                  .endw<br /><br /></code></pre><br />     In WM_CREATE Message ,create the 2nd Dc and bitmap ?Name = Plot)<br />     and in WM_TIMER message ,a square wave generator append this wave to Plot bitmap as a moving   picture,as the following two code pieces:<br /><pre><code><br />      ;WM_CREAT Message<br />      ; Create a compatible  Plot bitmap<br />        invoke  CreateCompatibleDC, hdc                              ;current DC memory<br />        mov     hdc_Plot,eax<br />        invoke  CreateCompatibleBitmap, hdc, maxX, maxY <br />        mov     hBitmap_Plot,eax<br />        invoke  SelectObject, hdc_Plot, hBitmap_Plot              ;select Memory DC<br />    <br />        mov	  eax,cOScopeLeft                                        ;set the rect area of the bitmap<br />	mov	  rcPlot.left,eax<br />	add	  eax,cOScopeWidth	<br />	mov	  rcPlot.right,eax		; set to cOScopeLeft+cOScopeWidht<br />        mov	  eax,cOScopeTop<br />        mov	  rcPlot.top,eax<br />        add	  eax,cOScopeHeight<br />        mov	  rcPlot.bottom,eax		        <br />        invoke  SelectObject, hdc_Plot, hBrush_White                ;paint with white <br />        invoke  PatBlt, hdc_Plot,0 , 0, maxX, maxY, PATCOPY <br /></code></pre><br /><br />        and in the WM_TIMER Message ,a SQUARE WAVE GENERATOR append the square wave point on right edge of Plot Bitmap .On every 50 ms interval,connect the old point to new point ?Produced by SQUARE WAVE GENERATOR),and shift this bitmap to left by nShiftPixels[=4]<br /><pre><code><br />    .elseif uMsg==WM_TIMER<br />        m2m PreviousPoint,CurrentPoint   ;CurrentPoint -&gt;PreviousPoint<br /><br />        .if (NUM&gt;=0)&amp;&amp;(NUM&lt;=30)     ;SQUARE WAVE GENERATOR<br />             mov  CurrentPoint,54<br />             inc  NUM<br />            <br />             .elseif (NUM&gt;=31)&amp;&amp;(NUM&lt;=59)<br />             	mov CurrentPoint,103<br />             	inc NUM<br />             .elseif (NUM==60)<br />             	mov CurrentPoint,103<br />             	mov NUM,0<br />        .endif<br />        <br />        ;grab the right side of the plot (exluding nShiftPixels on the left)<br />        ;move this grabbed bitmap to the left by m_nShiftPixels<br />        mov    ecx,cOScopeWidth<br />        sub    ecx,nShiftPixels<br />        ;mov    ecx,eax              ;cOScopeWidth - nShiftPixels --&gt; ecx<br />        mov    eax,cOScopeLeft<br />        add    eax,nShiftPixels     ;cOScopeLeft + nShiftPixels --&gt;eax<br /><br />        ;Shift the Plot bitmap to left by nShiftPixels<br />        invoke  BitBlt, hdc_Plot, cOScopeLeft, cOScopeTop, ecx, cOScopeHeight,\    <br />                        hdc_Plot, eax, cOScopeTop, SRCCOPY<br />	invoke  InvalidateRect, hWnd, ADDR rcPlot,0<br />	<br />        ; establish a rectangle over the right side of plot<br />        ; which now needs to be cleaned up proir to adding the new point<br />        ; rectCleanUp = m_rectPlot ;<br />        ; rectCleanUp.left  = rectCleanUp.right - m_nShiftPixels ;<br />         m2m rcCleanUp.right       ,rcPlot.right<br />         mov eax                       ,rcCleanUp.right<br />         sub eax                        ,nShiftPixels<br />         mov rcCleanUp.left          ,eax<br />         m2m rcCleanUp.top         ,rcPlot.top<br />         m2m rcCleanUp.bottom      ,rcPlot.bottom<br />	<br />        ;fill the cleanup area with the background<br />          invoke FillRect,hdc_Plot,ADDR rcCleanUp,hBrush_Black<br />         <br />         ;grab the plot pen<br />         invoke SelectObject,hdc_Plot,hPenGreen<br />         <br />         ; move to the previous point           <br />         ;!!!Should be modified for PreviousPoint are actual value of data<br />         mov eax,          rcPlot.right<br />         sub eax,          nShiftPixels<br />         mov prevX,        eax<br />         m2m prevY,        PreviousPoint<br />         invoke MoveToEx,hdc_Plot,prevX,prevY,NULL<br />          <br /><br />         ; draw to the current point<br />         mov eax,         nShiftPixels<br />         shr eax,         1<br />         mov nHalfShiftPixels, eax       ;get half shift pixels value,should draw in center for current Point DATA<br />         mov eax,         rcPlot.right<br />         sub eax,         nHalfShiftPixels<br />         mov currX,       eax <br />         m2m currY,       CurrentPoint<br />         <br />         invoke   LineTo,hdc_Plot,currX,currY<br /></code></pre><br />       <br />      O.K., be patient,Raymond, &quot;bitblt part of the background bitmap (the size of the other bitmap) where the current other bitmap is located to restore your background before you bitblt the other bitmap to the new location&quot;<br />&nbsp; &nbsp; What I have used in this program is different from what U said above.<br />&nbsp; &nbsp; I combine these two bitmap using SRCPAINT ,by&nbsp; Bitblt the moving bitmap to background bitmap ,and update the DC<br />&nbsp; &nbsp; in WM_PAINT.<br /><br /><pre><code><br />       .elseif uMsg==WM_PAINT                               <br />        ;Copy those virtual window (memory DC ) onto screen <br />        invoke BeginPaint,hWnd, ADDR ps    ;get current DC in hdc<br />        mov hdc,eax<br />        <br />        <br />        invoke CreateCompatibleDC,hdc<br />        mov hdc_OScope  ,eax<br />        invoke CreateCompatibleBitmap,hdc_OScope,maxX,maxY<br />        mov  hBitmap_OScope,eax<br />        <br />        invoke BitBlt,hdc_OScope,cOScopeLeft,cOScopeTop,cOScopeWidth,cOScopeHeight,\<br />                      hdc_Grid,rcGrid.left,rcGrid.top,SRCCOPY<br />        <br />        invoke BitBlt,hdc_OScope,cOScopeLeft,cOScopeTop,cOScopeWidth,cOScopeHeight,\<br />                      hdc_Plot,rcPlot.left,rcPlot.top,SRCPAINT<br />        invoke BitBlt,hdc,cOScopeLeft,cOScopeTop,cOScopeWidth,cOScopeHeight,\<br />                      hdc_OScope,cOScopeLeft,cOScopeTop,SRCCOPY<br />        <br />       <br />        <br />        mov	eax,ps.rcPaint.right<br />        sub	eax,ps.rcPaint.left<br />        mov	ecx,ps.rcPaint.bottom<br />        sub	ecx,ps.rcPaint.top<br />        <br />        invoke  BitBlt, hdc,   ps.rcPaint.left, ps.rcPaint.top, eax, ecx, \ <br />			  hdc_Plot, ps.rcPaint.left, ps.rcPaint.top, SRCCOPY<br /><br />        invoke EndPaint,hWnd, ADDR ps  <br /></code></pre><br /><br />        The program sceen shot is here:<br />        <br /><img src="" /><br />        what make me crazy is: only the plot square wave shift to left as what I think,but the background<br />(20 green line grids) has disappeared. <br />       I thought the bugs may be lie in the WM_PAINT message routine,but I DONT know where. :mad:<br />       <br />       Could u help to analyse ?<br />    <br /> Many,many ,many.. thanks.</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1158" target="_blank">plot shifting 1.jpg</a></li>
      <li><a href="../../attachments/?id=1160" target="_blank">plot shifting 2.jpg</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2005-11-07 21:28:59 by Luckrock</div>
   </div>
   <div class="post" id="post-167672">
    <div class="subject"><a href="#post-167672">Re: Bitmap shift Question</a></div>
    <div class="body">One thing I am noticing in the WM_PAINT is that you are combining the hdc_Grid and the hdc_Plot in hdc_OScope, then you bitblt that onto your hdc. But then you follow that by a bitblt of your hdc_Plot onto the same hdc.<br /><br />Raymond<br /></div>
    <div class="meta">Posted on 2005-11-08 22:00:47 by Raymond</div>
   </div>
   <div class="post" id="post-167686">
    <div class="subject"><a href="#post-167686">Re: Bitmap shift Question</a></div>
    <div class="body">Yes,<br />        You are right!<br />        Let me modify it and try again.<br /><br />       <br />        But before that ,I have now deleted the Grid Bitmap from dc memory, and paint it directly to hdc,  after Bitblt from hdc_Plot to hdc.<br />        See Attchement file. It work well.<br />        <br />       Thanks,anyway,you are the kindest people I ever meet in this forum .<br />       Best Regards.<br /><br />:<br /><pre><code><br />&nbsp;  .elseif uMsg==WM_PAINT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke BeginPaint,hWnd, ADDR ps&nbsp; &nbsp; ;get current DC in hdc<br />&nbsp; &nbsp; &nbsp; &nbsp; mov hdc,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ;Draw Grid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke SelectObject,hdc_Plot,hPenGreen&nbsp; &nbsp; ;select into DC<br />&nbsp; &nbsp; &nbsp; &nbsp; ;create Horizon Grid<br />&nbsp; &nbsp; &nbsp; &nbsp; mov COUNT,0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;initial count=0<br />&nbsp; &nbsp; &nbsp; &nbsp; m2m pt.x,rcPlot.left&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;initial Grid Start Point<br />&nbsp; &nbsp; &nbsp; &nbsp; m2m pt.y,rcPlot.top<br />&nbsp; &nbsp; &nbsp; &nbsp; .while COUNT&lt;=20&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;loop 20 times <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  add&nbsp; pt.y,20&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Grid Step=20 pixels<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  inc&nbsp; COUNT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  invoke MoveToEx,hdc_Plot,pt.x,pt.y,NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  invoke LineTo,&nbsp; hdc_Plot,rcPlot.right, pt.y<br />&nbsp; &nbsp; &nbsp; &nbsp; .endw<br />&nbsp; &nbsp; &nbsp; &nbsp; ;Copy those virtual window (memory DC ) onto screen <br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; eax, rcPlot.right<br />&nbsp; &nbsp; &nbsp; &nbsp; sub&nbsp; &nbsp; eax, rcPlot.left<br />&nbsp; &nbsp; &nbsp; &nbsp; ;add&nbsp; &nbsp; eax, 1<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; ecx, rcPlot.bottom<br />&nbsp; &nbsp; &nbsp; &nbsp; sub&nbsp; &nbsp; ecx, rcPlot.top<br />&nbsp; &nbsp; &nbsp; &nbsp; ;add&nbsp; &nbsp; ecx, 1<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke&nbsp; BitBlt, hdc,rcPlot.left, rcPlot.top, eax, ecx, \ <br />			hdc_Plot,rcPlot.left, rcPlot.top, SRCCOPY<br />	<br />&nbsp; &nbsp; &nbsp;  ;Draw Inner frame<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,OScopeBrdWidth&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; RGB 0,200,0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Frame3D,hdc,eax,eax,\&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  rcPlot.left,rcPlot.top,rcPlot.right,rcPlot.bottom, ecx&nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ;-------------------------<br />&nbsp; &nbsp; &nbsp; &nbsp; ;Draw Outter Frame<br />&nbsp; &nbsp; &nbsp; &nbsp; ;-------------------------<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;first,calculat the space between outer frame and inner frame<br />&nbsp; &nbsp; &nbsp; &nbsp; xor eax,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; xor ecx,ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,4<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,tm.tmAveCharWidth<br />&nbsp; &nbsp; &nbsp; &nbsp; mul ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx, eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;save the space (3* average char width) in ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax, rcPlot.left<br />&nbsp; &nbsp; &nbsp; &nbsp; sub eax, ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov rcOuterFrame.left,eax&nbsp;  ; rcOuterFrame.left=rcPlot.left-space<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax, rcPlot.right<br />&nbsp; &nbsp; &nbsp; &nbsp; add eax, ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov rcOuterFrame.right,eax&nbsp;  ;rcOuterFrame.right=rcPlot.right+space<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax, tm.tmHeight<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,2<br />&nbsp; &nbsp; &nbsp; &nbsp; mul ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,rcPlot.top<br />&nbsp; &nbsp; &nbsp; &nbsp; sub eax,ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov rcOuterFrame.top,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,rcPlot.bottom<br />&nbsp; &nbsp; &nbsp; &nbsp; add eax,ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov rcOuterFrame.bottom,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; RGB 240,10,150<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Frame3D,hdc,eax,eax,\&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;draw outer Oscillator Window Frame<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  rcOuterFrame.left,rcOuterFrame.top,rcOuterFrame.right,rcOuterFrame.bottom,3&nbsp;  <br /></code></pre></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1176" target="_blank">screen shot 2.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2005-11-09 09:53:49 by Luckrock</div>
   </div>
   <div class="post" id="post-167691">
    <div class="subject"><a href="#post-167691">Re: Bitmap shift Question</a></div>
    <div class="body">Well, <br />&nbsp; &nbsp; it doest work,<br />&nbsp;  the method&quot; two momery bitmap dc combine into another memory bitmap dc, then bitblt to screen&quot; seem to hopeless for my code.<br />&nbsp;  I give it up. no way out...<br /><br /><pre><code><br /> .elseif uMsg==WM_PAINT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; ;Copy those virtual window (memory DC ) onto screen <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke BeginPaint,hWnd, ADDR ps&nbsp; &nbsp; ;get current DC in hdc<br />&nbsp; &nbsp; &nbsp; &nbsp; mov hdc,eax<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; invoke CreateCompatibleDC,hdc<br />&nbsp; &nbsp; &nbsp; &nbsp; mov hdc_Mem&nbsp; ,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke CreateCompatibleBitmap,hdc_Mem,maxX,maxY<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; hBitmap_Mem,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke BitBlt,hdc_Mem,cOScopeLeft,cOScopeTop,cOScopeWidth,cOScopeHeight,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdc_Grid,rcGrid.left,rcGrid.top,SRCCOPY<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke BitBlt,hdc_Mem,cOScopeLeft,cOScopeTop,cOScopeWidth,cOScopeHeight,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdc_Plot,rcPlot.left,rcPlot.top,SRCPAINT<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke BitBlt,hdc,cOScopeLeft,cOScopeTop,cOScopeWidth,cOScopeHeight,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdc_Mem,cOScopeLeft,cOScopeTop,SRCCOPY&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp;  invoke EndPaint,hWnd, ADDR ps&nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; <br /></code></pre><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; what actually confuse me is&nbsp; &quot;SRCPAINT&quot; raster,what is the hell it meaning? Two night spent debuging this method...<br /><br />&nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp;  </div>
    <div class="meta">Posted on 2005-11-09 10:31:04 by Luckrock</div>
   </div>
   <div class="post" id="post-167692">
    <div class="subject"><a href="#post-167692">Re: Bitmap shift Question</a></div>
    <div class="body">The following function is equal to &quot;TransparentBlt&quot; WinAPI function. I wrote this function when I read that Win9x has some bug associated with it. All those pushes prepare the stack so that 7 functions are being called with 1 &#39;call&#39;. Those 7 Functions are commented-out. You can go ahead and cut those pushes (and the &#39;call&#39; after them) and uncomment those 7 calls ---  it&#39;ll be the same (I&#39;m just a bit paranoid about optimizations :P ). The code is in TASM syntax, but it&#39;s easy to convert to MASM, or something. The funcions&#39; names are in brackets (and start with &quot;_&quot;) because I&#39;m using dynamic linking to GDI32.dll. Just change them to proper names. I hope it&#39;ll help you somehow.<br /><br />labels. To make it simplier to understand the code, here&#39;s how I name the labels:  &quot;rtfrblt&quot; means &quot;return from blit&quot;.  if there is a number (like &quot;rtfrblt2&quot;) then it means there&#39;s something to be done before returning (usually some cleanup).<br /><br />parameters:<br />hdcDest --  destination device context<br />x1, y1, w1, h1 ---  destination rectangle<br />hdcSrc -- source device context<br />x2, y2  --- source rectangle<br />color -- transparent color<br /><br />NOTE: If you cut the pushes and uncomment those 7 calls, then make sure to delete &quot;align 4&quot; directive (the one right after the commented calls)<br /><br /><pre><code>;---------------------------------------------<br />align 4<br />proc  TransparentBlit uses ebx esi edi, hdcDest, x1, y1, w1, h1, hdcSrc, x2, y2, color<br /><br />LOCAL hdcmask1,hdcmask2,hdctemp1,hdctemp2:dword ;device contexts<br />LOCAL bmono1,bmono2,btemp1,btemp2:dword     ;bitmaps<br />LOCAL bit1,bkcol,bit2,bit4:dword        ;previous values<br /><br />            xor     edi, edi<br />            call    [_CreateCompatibleDC], <br />            or      eax, eax<br />            jz      rtfrblt<br />            mov     , eax<br />            call    [_CreateBitmap], , , 1, 1, edi<br />            or      eax, eax<br />            jz      rtfrblt2<br />            mov     , eax<br />            call    [_SelectObject], , eax<br />            or      eax, eax<br />            jz      rtfrblt3<br />            mov     , eax<br />            call    [_SetBkColor], , <br />            mov     , eax<br />            call    [_BitBlt], , edi, edi, , , , , , SRCCOPY<br />            call    [_CreateCompatibleDC], <br />            or      eax, eax<br />            jz      rtfrblt4<br />            mov     , eax<br />            call    [_CreateBitmap], , , 1, 1, edi<br />            or      eax, eax<br />            jz      rtfrblt5<br />            mov     , eax<br />            call    [_SelectObject], , eax<br />            or      eax, eax<br />            jz      rtfrblt6<br />            mov     , eax<br />            call    [_BitBlt], , edi, edi, , , , edi, edi, NOTSRCCOPY<br />            call    [_CreateCompatibleDC], <br />            or      eax, eax<br />            jz      rtfrblt7<br />            mov     , eax<br />            call    [_CreateCompatibleDC], <br />            or      eax, eax<br />            jz      rtfrblt8<br />            mov     , eax<br />            call    [_CreateCompatibleBitmap], , , <br />            or      eax, eax<br />            jz      rtfrblt9<br />            mov     , eax<br />            call    [_CreateCompatibleBitmap], , , <br />            or      eax, eax<br />            jz      rtfrblt10<br />            mov     , eax<br />            call    [_SelectObject], , eax<br />            or      eax, eax<br />            jz      rtfrblt11<br />            mov     , eax<br />            call    [_SelectObject], , <br />            or      eax, eax<br />            jz      rtfrblt12<br />            ;mov    , eax<br /><br />            push    eax     ;7<br />            push      ;7<br />            mov     eax, <br />            mov     ebx, <br />            mov     ecx, <br />            mov     edx, <br />            mov     esi, [_BitBlt]<br />            push    offset rtfrblt13<br />            push    SRCCOPY     ;6<br />            push    edi     ;6<br />            push    edi     ;6<br />            push    eax     ;6<br />            push    edx     ;6<br />            push    ecx     ;6<br />            push            ;6<br />            push            ;6<br />            push       ;6<br />            push    [_SelectObject] ;7<br />            push    SRCPAINT    ;5<br />            push    edi     ;5<br />            push    edi     ;5<br />            push    ebx     ;5<br />            push    edx     ;5<br />            push    ecx     ;5<br />            push    edi     ;5<br />            push    edi     ;5<br />            push    eax     ;5<br />            push    esi     ;6<br />            push    SRCAND      ;4<br />            push    edi     ;4<br />            push    edi     ;4<br />            push      ;4<br />            push    edx     ;4<br />            push    ecx     ;4<br />            push    edi     ;4<br />            push    edi     ;4<br />            push    ebx     ;4<br />            push    esi     ;5<br />            push    SRCCOPY     ;3<br />            push    edi     ;3<br />            push    edi     ;3<br />            push        ;3<br />            push    edx     ;3<br />            push    ecx     ;3<br />            push    edi     ;3<br />            push    edi     ;3<br />            push    ebx     ;3<br />            push    esi     ;4<br />            push    SRCAND      ;2<br />            push    edi     ;2<br />            push    edi     ;2<br />            push      ;2<br />            push    edx     ;2<br />            push    ecx     ;2<br />            push    edi     ;2<br />            push    edi     ;2<br />            push    eax     ;2<br />            push    esi     ;3<br />            push    SRCCOPY     ;1<br />            push    edi     ;1<br />            push    edi     ;1<br />            push       ;1<br />            push    edx     ;1<br />            push    ecx     ;1<br />            push    edi     ;1<br />            push    edi     ;1<br />            push    eax     ;1<br />            push    esi     ;2<br />            jmp     esi     ;1<br /><br /><br />        ;   call    [_BitBlt], , edi, edi, , , , edi, edi, SRCCOPY<br />        ;   call    [_BitBlt], , edi, edi, , , , edi, edi, SRCAND<br />        ;   call    [_BitBlt], , edi, edi, , , , edi, edi, SRCCOPY<br />        ;   call    [_BitBlt], , edi, edi, , , , edi, edi, SRCAND<br />        ;   call    [_BitBlt], , edi, edi, , , , edi, edi, SRCPAINT<br />        ;   call    [_BitBlt], , , , , , , edi, edi, SRCCOPY<br />        ;   call    [_SelectObject], , <br /><br />align 4<br /><br />rtfrblt13:<br />rtfrblt12:      call    [_SelectObject], , <br />rtfrblt11:      call    [_DeleteObject], <br />rtfrblt10:      call    [_DeleteObject], <br />rtfrblt9:       call    [_DeleteDC], <br />rtfrblt8:       call    [_DeleteDC], <br />rtfrblt7:       call    [_SelectObject], , <br />rtfrblt6:       call    [_DeleteObject], <br />rtfrblt5:       call    [_DeleteDC], <br />rtfrblt4:       call    [_SetBkColor], ,  <br />            call    [_SelectObject], , <br />rtfrblt3:       call    [_DeleteObject], <br />rtfrblt2:       call    [_DeleteDC], <br />rtfrblt:        ret<br />endp    TransparentBlit<br />;---------------------------------------------</code></pre></div>
    <div class="meta">Posted on 2005-11-09 10:40:26 by ti_mo_n</div>
   </div>
   <div class="post" id="post-167725">
    <div class="subject"><a href="#post-167725">Re: Bitmap shift Question</a></div>
    <div class="body">HI, ti_mo_n<br />&nbsp; &nbsp; Thanks for your advice.<br />&nbsp; &nbsp; I have google the word &#39;SRCPAINT&#39;. and found the concept &#39;Transparent bitmap&#39; and download several paper to study.<br />&nbsp; &nbsp; But now I have to turn to next step. to draw a knob control&nbsp; to adjust&nbsp; the shift&nbsp; frequency ofbitmap.<br />&nbsp;  I hope i could use the transparent bitmap in some other day.you know,i write program in my spare time.<br />&nbsp;  For this program ,directly draw on hdc ,is enough speed and simple.<br />&nbsp; <br />&nbsp; &nbsp; Anyway thanks for your kindness .<br />&nbsp; &nbsp; With my regards.<br /><br />&nbsp; &nbsp; </div>
    <div class="meta">Posted on 2005-11-10 08:18:30 by Luckrock</div>
   </div>
  </div>
 </body>
</html>