<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Animated SkinMesh under D3D - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=24515" />
  <link rel="prev" href="../?id=24515&amp;page=3" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=24515">Animated SkinMesh under D3D</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=24515&amp;page=1" style="">&laquo;</a><a href="../?id=24515&amp;page=3" style="">&lt;</a><input type="hidden" name="id" value="24515" /><input type="number" name="page" min="1" max="4" step="1" value="4" onchange="this.form.submit();" /></form>   <div class="post" id="post-180043">
    <div class="subject"><a href="#post-180043">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Hi Homer,<br /><br />With all the files I was able to build the project, and it&#39;s running<br />But I still don&#39;t understand how you can use atofp.asm in an unchanged form.<br />Because when I don&#39;t remove the &quot;END&quot; directive from it, the linker produces the complaint &quot;unresolved external symbol _WinMainCRTStartup&quot; I mentioned earlier.<br />Only if I remove it I am able to build the project.<br /><br />What strikes me when I look at the BoneBoxes is the following:<br />They appear to be longer than the mesh they encompass.<br />Look at the upperarm, when Tiny is waving.<br />When the lower arm has an angle of about 90 degrees, the bonebox around the upperarm is much longer than the upperarm itself. It is sticking out.<br />And the same is true for all other boxes.<br />I guess this is what you ment by the following:<br /><br /><div class="quote">Basically I need to create a BoundingBox for each Bone.<br />The orientation of each box is that of the Bone it encompasses.<br />To be more precise, for each Bone, find the set of vertices affected by this Bone, and find the boundingbox of the set of affected vertices. Then expand the box to include its connection points with other Bones if necessary.</div><br /><br />Does this have a special purpose? Why aren&#39;t they exactly the same size as the maximum width, height and depth of the mesh belonging to the bones? Why would we want to expand the boxes?<br /><br />Friendly regards,<br />mdevries.</div>
    <div class="meta">Posted on 2006-04-22 09:48:27 by mdevries</div>
   </div>
   <div class="post" id="post-180046">
    <div class="subject"><a href="#post-180046">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Yeah, I agree, the boxes don&#39;t seem to be as great a fit as they could be.<br />Maybe this is due to numerical error introduced when we transform the box points from bonespace to modelspace?<br />My code does what I described - it finds the min,max coordinates of the boundingbox by examining the affected mesh vertices (and since this model is smooth-skinned, some vertices are affected by more than one bone, and so our boxes overlap, which is fine).<br />Maybe my math for checking the relative positions of child bones is wrong, causing the boxes to be expanded more than necessary, but the code appears ok to me..<br />Anyway, it&#39;s pretty close to what I imagined it would look like, and the box hull doesn&#39;t need to be a perfect fit, especially if we use the box hull as only a preliminary hit-detection test, and perform secondary detection with the subset of faces implied by a subset of affected mesh vertices..<br /><br />We don&#39;t really need to expand the boxes, we&#39;re just&nbsp; making sure that for a given box, the points where it joins its parent and child(s) are all inside the box.<br />The box is represented by a frame, its a frame of reference.<br />Normally, these connector points will already fall inside the box without us intervening.<br />Why do they HAVE to be inside the box, why expand it if we have to do so in order to fulfil the above conditions?<br />I don&#39;t actually know why, it&#39;s probably not at all necessary for our implementation, but the whitepaper I&#39;m basing this stuff on mentioned it, so I did it too.<br />My guess is that the author wanted to ensure that the boxes overlapped at the joints even where a joint is defined outside of the mesh - a perfectly legal strategy - there&#39;s no golden law which states that all bones/joints have to be INSIDE the mesh ;)<br /><br />Here&#39;s another sore point.<br />The whitepaper handles boneboxes by their centers, even though the origin of a given box (eg for rotation) is in fact its connectionpoint with its parent (if any) which is offset some distance from the center of the box.<br />There&#39;s no reason why we have to do this, it just makes the physics code a bit trickier since our boxes are no longer rotating about their own center of mass, and thus we have to make some per-box-point physics calcs that we&#39;d otherwise avoid..we wind up with a physics model that is somewhat less accurate in terms of rotational forces as a result.<br /><br /></div>
    <div class="meta">Posted on 2006-04-22 10:39:50 by Homer</div>
   </div>
   <div class="post" id="post-180050">
    <div class="subject"><a href="#post-180050">Re: Animated SkinMesh under D3D</a></div>
    <div class="body"><div class="quote">When the lower arm has an angle of about 90 degrees, the bonebox around the upperarm is much longer than the upperarm itself. It is sticking out.</div><br /><br />Probably because the vertices which would occupy that empty space at the elbow end of the upper arm have been bent around the corner, since they are partly affected by the lower arm ;)<br />In the BindPose, the model has its arms sticking out horizontally, with no bend in the arm.<br /><br />This model is smooth-skinned, not rigid-skinned..<br />If the model was rigidly skinned, each mesh vertex would be affected by exactly one bone, and the bends would be sharper, and the boxes would overlap less or not at all.<br /><br /></div>
    <div class="meta">Posted on 2006-04-22 11:02:58 by Homer</div>
   </div>
   <div class="post" id="post-180054">
    <div class="subject"><a href="#post-180054">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Hi Homer,<br /><br /><div class="quote">Why do they HAVE to be inside the box, why expand it if we have to do so in order to fulfil the above conditions?<br />I don&#39;t actually know why, it&#39;s probably not at all necessary for our implementation, but the whitepaper I&#39;m basing this stuff on mentioned it, so I did it too.</div><br /><br />The whitepaper you&#39;re basing your code on, is it J.Adam&#39;s book &quot;Advanced Animation with DirectX 9.0&quot; you provided a link for in an earlier post? Or do you mean an other source? And if so, is it availlable on the web?<br /><br />Friendly regards,<br />mdevries.<br /></div>
    <div class="meta">Posted on 2006-04-22 11:43:31 by mdevries</div>
   </div>
   <div class="post" id="post-180060">
    <div class="subject"><a href="#post-180060">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Yes, it&#39;s that document I linked to earlier that I&#39;m basing most of this stuff on.<br />There&#39;s little in the way of actual code contained in that document, so I&#39;m basically winging it and using the document as a reference.<br /><br />I&#39;ve written other physics simulators so I&#39;m pretty confident that even if I deviate a little from the system described in the document that I can get it working to my satisfaction.<br /><br />In fact, I&#39;m already overhauling the ragdoll bone structs as I begin to implement the code for initializing the physics system based on the prev and current animation frames, so expect a few changes..<br /><br />What I have in mind:<br />I&#39;ve spent some effort to get everything into &quot;model space&quot; for a reason..<br />Now I can extract my initial physics values in a common spatial context.<br />I probably should go further, and get everything into &quot;world space&quot;, but I&#39;ll get it working first and come back to that when theres more stuff to collide with ;)<br /><br />Anyway, now I can deduce my physics initial values, which is the hard bit.<br />Well, it doesn&#39;t have to be that hard,theres room to fudge things a little, but doing it wrong will mean the model will jerk harshly when we switch modes.<br /><br />After that we can relax and just call the Integrate method to update the physics over time, which in turn leads to the boneframe.matCombined being updated.<br />This means that the standard rendering code is fine to use in ragdoll mode.<br /></div>
    <div class="meta">Posted on 2006-04-22 12:23:25 by Homer</div>
   </div>
   <div class="post" id="post-180082">
    <div class="subject"><a href="#post-180082">Calculating the Moment of Inertia tensor of an Axially Aligned  Box</a></div>
    <div class="body">Today I wanna talk about building the &quot;inertia tensors&quot;.<br />We&#39;ll need the size of each Box as a Vec3, and the Mass as a float.<br />I&#39;ll talk about how to calculate the Mass in a separate post, its easy.<br /><br />Take the Box&#39;s size in x,y and z and use them to obtain &quot;moment of inerta scalars&quot;:<br /><br />xs = vecSize.x * vecSize.x<br />ys = vecSize.y * vecSize.y<br />zs = vecSize.z * vecSize.z<br /><br />Now take the moi scalars and the Mass and use them to obtain the axial moi values:<br />ixx = Mass * (ys + zs)<br />iyy = Mass * (xs + zs)<br />izz = Mass * (xs + ys)<br /><br />Build your Moment of Inertia Tensor (a 3x3 matrix) as follows:<br />ixx 0 0<br />0 iyy 0<br />0 0 izz<br /><br />Finally, we&#39;ll also need the inverse of that matrix, which is:<br />1/ixx 0 0<br />0 1/iyy 0<br />0 0 1/izz<br /><br />We should build these tensors for each Box during the box generation phase, since its the kind of thing we do once, and since it means we won&#39;t need to keep the box size vector anymore, unnecessarily bloating our struct.<br /><br /></div>
    <div class="meta">Posted on 2006-04-22 23:47:35 by Homer</div>
   </div>
   <div class="post" id="post-180107">
    <div class="subject"><a href="#post-180107">Re: Animated SkinMesh under D3D</a></div>
    <div class="body"><br />I&#39;m trying to decide which is the best way to determine the initial angular velocity.<br />Please correct me/feel free to jump in/if you have something to contribute.<br /><br />The problem is that since we defined the Moment of Inertia about the &#39;regular cartesian axes in bonespace&#39;, we&#39;re now forced to use these standard axes to define the other angular properties - we can&#39;t use an arbitrary rotation axis, we must find (for any arbitrary orientation) the rotations about the standard axes which would achieve it.<br /><br />We have two Orientations of the BoneBox in BoneSpace, kept as Matrices.<br />We need to find the angular DIFFERENCE between the two arbitrary 3D orientations as a set of &#39;euler angles&#39; (think yaw-pitch-roll).<br /><br />I&#39;m pretty sure that performing matrix subtraction (to measure the angular differece) is a no-no, especially since I&#39;m not sure that the orientation matrices are pure rotation matrices, and anyway, it doesn&#39;t help us to obtain the change in angle around x,y and z in bonespace.. <br /><br />We&#39;re left with no alternative but to do the following:<br />-decompose both Matrices to be sure we have pure rotation matrices<br />-extract a set of Euler angles from each rotation matrix<br />-perform a vector subtraction on the two sets of Euler angles to find the angular change around X,Y,Z axes<br /><br />Quite expensive really (even if it does only happen when we enable the physics code), anyone have other ideas?<br /><br /><br /></div>
    <div class="meta">Posted on 2006-04-23 20:29:30 by Homer</div>
   </div>
   <div class="post" id="post-180153">
    <div class="subject"><a href="#post-180153">Re: Animated SkinMesh under D3D</a></div>
    <div class="body"><br />Reading Chris Hecker&#39;s physics articles for the Nth time paid off.<br />I&#39;ve always found his stuff a bit dry, but there&#39;s gold in them thar hills.<br /><br />His fourth article in particular is great because the material is presented in two parts : Kinematics and Dynamics.<br /><br />Dynamics is about how Forces move and rotate our 3D objects, it&#39;s what our RagDoll physics is all about.<br />Kinematics is about calculating the Forces required to reach a particular position/orientation.<br />It should be obvious that our current problem (initializing the physics state to suit the animation state) is a Kinematics problem, not a Dynamics problem - we know how and where things moved, and we need to calculate the implied Forces involved.<br /><br />Chris mentions somewhere that &quot;if we define the Angular Velocity as &#39;the current instantaneous axis of rotation, multiplied by the Rotation Speed&#39;, then we now have all we need to calculate Angular Momentum and Torque with respect to the axis of rotation.<br /><br />Since, according to Chris, it&#39;s not necessary that the vector axes of the Angular Velocity and of the orientation matrix be the same, it&#39;s perfectly ok to calculate the rotation forces with respect to an arbitrary axis - a statement which is in direct conflict with my previous posting.. I recant my posting and bow to a man with a greater understanding than I.<br /><br /></div>
    <div class="meta">Posted on 2006-04-26 06:07:01 by Homer</div>
   </div>
   <div class="post" id="post-180182">
    <div class="subject"><a href="#post-180182">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Well, we&#39;re not a heck of a lot better off than we were several posts ago, we&#39;ve just got a new problem to solve.. our animated orientations are matrices, but we need to convert them to an axis/angle representation in order to calculate the instantaneous angular velocity.<br /><br />The problem for us is that D3D doesn&#39;t supply this functionality - we&#39;ll need to code our own &quot;rotation matrix to angle/axis&quot; conversion function.<br />Note that we&#39;ll only need to use this when we first enable the bone physics.. after that, we&#39;ll use quaternions to represent orientations (as an intermediate during calculations, with the final representation of course being matrix once more).</div>
    <div class="meta">Posted on 2006-04-27 17:55:02 by Homer</div>
   </div>
   <div class="post" id="post-180454">
    <div class="subject"><a href="#post-180454">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">OK, it&#39;s time for me to pick this project up again, and so I&#39;d like to talk about my intentions.<br />In the current demo, we are able to draw our animated boneboxes in modelspace because we:<br />1- defined our box points in bonespace<br />2- already transformed those back into modelspace (&#39;bindpose&#39;).<br />3- are transforming those &#39;bindpose boxes&#39; using the same &#39;final transform matrices&quot; that we used to manipulate the mesh.. note: these are currently NOT stored within bones or boneframes, they need to be in a linear array, although we COULD keep pointers..meh.<br /><br />It&#39;s important to note that these matrices we&#39;re using actually define the position, rotation and scale of each box in modelspace.. which is good news for us !! After all, perhaps the most important thing we need right now is a way to calculate the bone orientations at the critical moment when we switched off Animation and enabled our Physics.. and those matrices are our ticket to ride.<br /><br />The following stuff is done just once, at the &quot;critical moment&#39; described earlier..<br />We can Decompose those matrices to separate the translation, rotation and scale components, and then we have our Orientation matrix , yay :D<br />If we want, we can obtain some modelspace Euler angles now, but I&#39;m not so sure we need to.. We are able to convert Orientation matrices directly into Orientation quaternions, and I&#39;m pretty sure that if we do all of the above for the current and previous FinalMatrices (so we have the state at two moments in Time), we should be able to extract change in rotation, position and time, and thus obtain an instantaneous set of acceleration values, and finally, momentum (both linear and angular) due to Mass.<br />Having done ALL of that, we&#39;ll be ready to &quot;unleash the beast&quot; and let our physics simulation run on its own (will it blow up? I&#39;ll discuss different kinds of Integration soon..)</div>
    <div class="meta">Posted on 2006-05-06 13:18:10 by Homer</div>
   </div>
   <div class="post" id="post-180514">
    <div class="subject"><a href="#post-180514">Re: Animated SkinMesh under D3D</a></div>
    <div class="body"><br />I&#39;m not sure exactly how many different Integration algorithms exist, I am neither a mathematician nor a physicist.. however, in terms of physics simulations, I have encountered just three, meaning I can talk about all of them briefly without losing my mind, or your patience.<br /><br />1A. EULER INTEGRATION : This is the easiest to implement. All others are variants of this.<br />The Swiss mathematician Leonard Euler (pronounced &#39;oiler&#39; - let&#39;s at least SOUND like we know what we&#39;re talking about) lived from 1707 to 1783..<br /><div class="quote">Leonhard Euler was one of top mathematicians of the eighteenth century and the greatest mathematician to come out of Switzerland. He made numerous contributions to almost every mathematics field and was the most prolific mathematics writer of all time. It was said that &quot;Euler calculated without apparent effort, as men breathe....&quot; He was dubbed &quot;Analysis Incarnate&quot; by his peers for his incredible ability.</div><br />Unfortunately, his integration algorithm leaves a lot to be desired.. the larger the &quot;timestep&quot; between calculations, the greater the degree of error, with error being compounded over time.. and conversely, if the &quot;timestep&quot; is infinitely small, the error is infinitely small as well...<br /><br />1B. EULER MIDWAY : This variation on Euler integration works by finding the midpoint between the start and end of the timestep, calculating values for the midpoint and endpoint, and then averaging out the overall error. It effectively halves the amount of error for a given timestep.<br /><br />2. RUNGE-KUTTA INTEGRATION : This integrator is similar to the Midway variant, but instead of merely calculating one extra point in the middle of each timestep, we now calculate THREE points distributed between the start and end of the timestep, so that we have FOUR lots of calculations per timestep (including the endpoint).. thats why it is sometimes called RK4.<br />Bumping things up a notch, the values calculated at each point are fed as inputs into the next, so that &quot;the corrections to the error are propagated along the curve&quot; (noting that in physics, almost everything is a curve of some kind). This is a really nice integrator, but it takes 4 times as much calculation as simple Euler, so its 4 times as slow.. and it basically hates you changing the size of the timestep, so you have to get used to &quot;fixed timesteps&quot;..<br /><br />3. VERLET INTEGRATION : Developed by French mathematician Loup Verlet in 1967 (relatively recently!), this kind of integrator is often used for &quot;molecular dynamics&quot; simulators.. It has some advantages and it has some drawbacks, and is appearing more and more in games because it&#39;s cheaper to implement than RK4, while being almost as accurate (eg it was used for the ragdolls in the recent game &#39;Hitman&#39;).<br />Among its advantages, it&#39;s quite easy to apply Constraints to the &quot;particles&quot; which comprise your objects, and quite easy to &quot;go backwards in time&quot;.<br />Among its disadvantages, you basically need a way to obtain the Position of your object at some small delta into the past or future in order to use it, since Velocity is never calculated in the Current TimeStep.. weird huh.. <br />Like RK4, the Verlet integrator HATES VARIABLE TIMESTEPS.<br /><br />So, the number one reason why people don&#39;t talk about Verlet integration is because this integrator effectively needs you to be able to define the Position of your object in at LEAST TWO moments in time, otherwise the bloody thing is useless..but hey, guess what? Our ragdoll models are suitable !! WE CAN USE THIS !!<br /><br />Verlet is the only kind of integrator that I personally have NEVER written, and I am tempted to: because of that reason, and also because it represents the best tradeoff between speed and accuracy that we can obtain.<br /><br />You may be wondering - so where is all this math? Why are you waffling about stuff I can&#39;t see again, Homer? <br />I didn&#39;t want to burden you with N sets of exceedingly similar equations.. that would be needlessly scary and/or confusing, I figured it was better to describe the algorithms in historical order, so that you might understand why people have been tinkering with Euler&#39;s work ever since the late 1700s :)<br /><br /></div>
    <div class="meta">Posted on 2006-05-08 04:44:50 by Homer</div>
   </div>
   <div class="post" id="post-180516">
    <div class="subject"><a href="#post-180516">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">I&#39;d also prefer Verlet calculation. <br /><br />Euler&#39;s work is constantly a subject at university - Higher Maths 1-3, then Numerical Methods&nbsp; - usually calculating roughly (and very quickly) complex equations, iirc. <br /><br />Actually I guess Homer isn&#39;t presenting the Maths involved, since it will turn you off immediately unless you&#39;ve studied it at university. The math is actually simple (a lot simpler than what I studied at school...). Anyway, a quick reference to Chris Heckler&#39;s articles is at http://www.d6.com/users/checker/dynamics.htm#articles&nbsp; (the 3 pdfs)<br /><br /><br />And, time-corrected Verlet is <br /><pre><code><br />x<em> = x<em> + (x<em> - x<em>) * (dt<em> / dt<em>) + ax * dt<em> * dt<em>;<br /></code></pre><br />&quot;float x[3];&quot; - the x coordinate of the object&#39;s position. In 3 points: previous position, current, next. <br />&quot;float dt[3];&quot; - the time passed between the 3 frames. <br />&quot;float ax&quot; - the acceleration&#39;s x<br /><br />Likewise, we compute the Y and Z coordinates of the object position. <br />Though, I still haven&#39;t seen code on computing the rotation, constraints and collision-response .. I guess they&#39;re just like in Euler-based dynamics engines. </div>
    <div class="meta">Posted on 2006-05-08 05:28:36 by Ultrano</div>
   </div>
   <div class="post" id="post-180519">
    <div class="subject"><a href="#post-180519">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Hmm the only thing I don&#39;t like about usages of Verlet is the proposed Constraints for collision response:<br /><pre><code><br />dx = x2-x1;<br />dy = y2-y1;<br />dz = z2-z1;<br />d1 = sqrt(dx*dx+dy*dy+dz*dz);<br />d2 = 0.5*(d1-r)/d1;<br />dx = dx*d2;<br />dy = dy*d2;<br />dz = dz*d2;<br />x1 += dx;<br />x2 -= dx;<br />y1 += dy;<br />y2 -= dy;<br />z1 += dz;<br />z2 -= dz;<br /></code></pre><br />This 0.5 value... they&#39;re basically assuming that both objects have the same mass ... no ... inert force. <br />We don&#39;t want our game having a tennis ball move a skyscraper that it hit ^^.<br /><br />Instead, we should provide dx (and dy,dz) ourselves - the distance to move, (so that the objects don&#39;t penetrate) and Force1 &amp; Force2. Force1 and Force2 (both are Vec3) are derived from mass and velocity. So far, I&#39;ve done this only with mass involved, on slow-moving objects ^^&quot;. <br /><br />Hmm Homer, maybe it&#39;ll be better (than bounding rotated boxes) to use spheres around points of our meshes&#39; bones? And an array of spheres (belonging to one line) when the bone is long? Then, if some sphere of the arm is penetrating the chest (ragdoll fallen sideways on ground), we move both chest and sphere until they don&#39;t penetrate. And meanwhile we realign the arm&#39;s spheres. <br />Optimizing this case (ragdoll fallen sideways on ground/object) is rather interesting to me (mostly because of CounterStrike:Source, I guess ^^). <br />We probably should also cache the group of objects that are in such a complicated situation, and iterate calculations on it, until the level of error is acceptable. </div>
    <div class="meta">Posted on 2006-05-08 07:02:38 by Ultrano</div>
   </div>
   <div class="post" id="post-180520">
    <div class="subject"><a href="#post-180520">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Yeah, I do mention Chris Hecker&#39;s work in at least one previous post.. it&#39;s almost obligatory that I do, since almost everything ELSE I&#39;ve read quotes his work and credits him :)<br /><br />Please note that the &#39;constraint&#39; you posted is an EXAMPLE constraint, those formula are NOT written in stone, in fact, as gamedevs, we are encouraged to CHEAT wherever we can get away with it - ie , as long as things LOOK believable, we&#39;ve succeeded.<br />I imagine that constraint you posted was developed for a &quot;pool physics&quot; demo, where we have N spheres of equal mass.<br /><br />Actually, it appears again in this article by Thomas Jakobsen from IO Interactive, the guy who developed the physics behind Hitman, and this article is one hell of a good read.. http://www.teknikus.dk/tj/gdc2001.htm<br /><br />He doesn&#39;t mention time correction in this article, but he does cover a lot of ground and there&#39;s an abundance of useful information : it&#39;s probably the best article on the subject I have ever read.<br /><br />I took away a few new ideas from that article, one of which renders your Spheres idea redundant.. he talks about the cheapest way of resolving object interpenetration, and shows how to use point constraints to achieve it... effectively, we are performing sphere tests using the vertices of the bounding hull..<br /><br />I agree that a bunch of boxes generated at runtime is neither an elegant nor an efficient solution.. my own idea of a &quot;desirable scenario&quot; involves making the 3D artist responsible for creating the bounding hull and storing it as a separate (textureless) mesh, but still bound to the skeleton and thus animated along with the mesh it surrounds.. my idea of a &quot;best case scenario&quot; is that bounding hull being nothing more than a subset of the actual mesh vertices, just enough of them to form the most simple animated hull possible, with the tightest fit possible.. note that means zero overhead for deriving the animated vertex positions of the hull at runtime.<br /><br />Nonetheless, I will persevere with the existing framework simply because it&#39;s easy to understand.. I can rework my implementation later, this is a public demo/educational project ;)<br /><br />You were right about angular dynamics under Verlet, it&#39;s the same, that&#39;s why it&#39;s never discussed in any of the material I&#39;ve seen. Verlet is merely an INTEGRATION METHOD, ie, an algorithm for getting from physics state A to physics state B - the standard physics formulae (Euler, Newton et al) are still at work behind the scenes.. they always are, which is why Euler&#39;s stuff is standard fare at most colleges around the world.. <br /><br />Anyhow, there&#39;s just one or two more things I&#39;d like to say regarding my ever-growing fondness for Verlet: I am no longer required to calculate either the initial momentums&nbsp; OR the initial velocities (angular and linear), the only requirement for initializing the physics state is that we can describe the Position (and Orientation!!) of the object at two moments in time : the current animation frame, and the previous one, provide everything we want :)<br />Don&#39;t be fooled into thinking that Verlet only works &quot;if the object was already moving&quot;, its perfectly ok for the physics state to describe &#39;no change in orientation / position&#39; :)<br /><br />I think my mind is made up :)<br /></div>
    <div class="meta">Posted on 2006-05-08 09:26:06 by Homer</div>
   </div>
   <div class="post" id="post-180523">
    <div class="subject"><a href="#post-180523">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Maybe this info could be of some interest to you too:<br />Just out of curiousity, I installed HL2 Source SDK, and took a peek at the models&#39; physics definitions. Turned out they (the physics layer of .mdl) consist entirely of convex solid triangular meshes, usually 15 of them (for human models), each phys object:<br />- has 20-70 triangles.<br />- has a bounding-box (automatically generated at compile-time), [ no AABB] .<br />- X,Y,Z constraints: min:max<br />- mass.&nbsp; 90.0 being the default value<br />- friction: 1.0&nbsp; up to 1000.0 <br />- mass bias 0.0 to 10.0&nbsp; ,&nbsp; 1.0 is default<br />- inertia 0.0 to 10.0,&nbsp; 10.0 default<br />- damping 0.0 to 1.0 , 0.01 default<br />- rotation damping 0.0 to 10.0 , 1.5 default<br />- material: string. Something like &quot;flesh&quot; or &quot;metal&quot;<br /> <br />Meanwhile, the real (drawn) submeshes, attached to the bone, have their own hitboxes, too :/<br />Sry if this could steer you out of your planned code ^^&quot;</div>
    <div class="meta">Posted on 2006-05-08 17:19:01 by Ultrano</div>
   </div>
   <div class="post" id="post-180526">
    <div class="subject"><a href="#post-180526">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">That&#39;s quite interesting :)<br />I guess you could argue endlessly about which kind of theoretical geometric primitives to use for the collision hull, I don&#39;t know if you bothered to read the article I linked to in my previous post, it describes using the simplest 3D geometric primitive, ie tetrahedrons (four pointed pyramids). The reason that tetrahedrons were selected is because in a Verlet rigidbody simulation you must use point constraints between various pairs of points in the body, and ideally between each point and all other points.. tetrahedrons require just FOUR constraints.<br /><br />The more points we add, the more constraints must be enforced, and the more constraints we enforce, the more likely it is that at least one constraint is going to be violated in some collision situation.<br /><br />Still, I don&#39;t feel that tetrahedrons are useful for defining volumes of space (ie collision hulls), and neither did the author of that article, because he also talks about using cylinders as collision hulls (which opens the possibility for using tapered cylinders and elliptical cylinders etc). Perhaps these offer more flexibility than spheres or ellipses.<br /><br />Jakobsen&#39;s verlet physics are applied not to any 3D primitives nor the mesh .. they are applied to a point representation of the model (looks like a stick figure). This stick figure is manipulated under physics, and it is used to control the bones, which in turn control the collision hull and the mesh... under collision response, vice versa : the collision hull controls the bones which controls the stick figure.. with me?<br /><br />I was thinking I might be able to define such a stick figure at runtime by examining the bone endpoints for limbs.. <br /></div>
    <div class="meta">Posted on 2006-05-09 06:53:14 by Homer</div>
   </div>
   <div class="post" id="post-180528">
    <div class="subject"><a href="#post-180528">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Yes, of course I read the article (re-read 3+ times until completely understood ^^&quot;), and many related materials - I am keen on using that approach, too :D<br /></div>
    <div class="meta">Posted on 2006-05-09 07:46:43 by Ultrano</div>
   </div>
   <div class="post" id="post-180564">
    <div class="subject"><a href="#post-180564">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">I still haven&#39;t found any suitable sourcecode demonstrating the verlet technique - how about you? Everything I found so far has been devoted to cloth simulation (think of 3d flag demos).<br />Worse (imho) is that all the literature I&#39;ve read has stated that &quot;orientation is arbitrary and must be extracted from the particle position data&quot;, ie, it seems a lot of people are &#39;cheating&#39; in regards to rotational dynamics, even going so far as to &quot;implement constraints which roughly emulate an angular inertia tensor&quot;.. basically what they are saying is that we should just move all the points about in space, with rotations being implicit rather than explicit (eg, we should build our orientation matrix at runtime by analyzing the positions of our particles in relation to one another and in relation to the body&#39;s local origin).<br /><br />I was initially led to believe (and still do believe) that verlet is MERELY an integration algo and that we can and SHOULD implement an impulse-driven rotation scheme as usual.<br /><br /></div>
    <div class="meta">Posted on 2006-05-10 02:51:23 by Homer</div>
   </div>
   <div class="post" id="post-180570">
    <div class="subject"><a href="#post-180570">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Just a quick reply on a quick idea to solve rotation - make a &quot;heavy&quot; particle, that is in the mass-center of the object. Of course, constrain all/most other particles to it. This &quot;heavy&quot; particle would be the hardest to move on indirect collision (at a nonperpendicular angle), and would be as &quot;light&quot; as the other particles on a direct hit (the mass-center, collission-point and collider&#39;s acceleration vector are aligned). This might work for the first frame after collision, if the collider isn&#39;t rotating (or its friction=0).<br />no, I haven&#39;t found anything about rotation with verlet :(</div>
    <div class="meta">Posted on 2006-05-10 06:46:52 by Ultrano</div>
   </div>
   <div class="post" id="post-180575">
    <div class="subject"><a href="#post-180575">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">How to handle rotations in regards to Verlet:<br /><br />Basically, imagine the rigid body as a &quot;particle cloud&quot;.<br />Each particle wants to continue moving in the general direction it already was moving (conservation).<br />If our &quot;particle cloud&quot; bumps into something, we correct the position of the first offending particle, and we correct the positions of all other particles in the body via our distal constraints, with respect to the offender particle.. which causes rotation to occur without any mention of forces or orientation.<br /><br />It&#39;s really braindead, but the degree of error isn&#39;t really that noticeable (it sure worked well in Hitman and its sequels).<br /><br />I disagree with all the above nonsense.<br />We can treat rotation the same way as we do position under the Verlet scheme.. I think :)<br /><br />That is to say, perhaps we can implement a Verlet-style &#39;velocity-less&#39; algorithm which calculates more accurate force-based (impulse-driven) collision responses? :)<br /></div>
    <div class="meta">Posted on 2006-05-10 08:28:16 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=24515&amp;page=1" style="">&laquo;</a><a href="../?id=24515&amp;page=3" style="">&lt;</a><input type="hidden" name="id" value="24515" /><input type="number" name="page" min="1" max="4" step="1" value="4" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>