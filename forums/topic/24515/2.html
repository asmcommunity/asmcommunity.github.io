<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Animated SkinMesh under D3D - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=24515" />
  <link rel="prev" href="../?id=24515&amp;page=1" />  <link rel="next" href="../?id=24515&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=24515">Animated SkinMesh under D3D</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=24515&amp;page=1" style="">&laquo;</a><a href="../?id=24515&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="24515" /><input type="number" name="page" min="1" max="4" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=24515&amp;page=3">&gt;</a><a href="../?id=24515&amp;page=4">&raquo;</a></form>   <div class="post" id="post-179382">
    <div class="subject"><a href="#post-179382">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">ExtendFrame is really simple - here it is:<br /><pre><code>;Extend a Bone&#39;s FRAME struct for RagDoll Physics<br />;Noe that ID3DXAllocateHierarchy now cleans up this resource<br />Method CRagDoll.ExtendFrame,uses esi,pBoneFrame<br />	mov ebx,pBoneFrame<br />	mov .FRAME.pRagDollBone,$MemAlloc(sizeof RagDollBone,MEM_INIT_ZERO)<br />MethodEnd</code></pre><br /><br />BuildBonePhysics is simple too, if we look at it as a series of steps.<br />First, here&#39;s a helper method that we&#39;ll require.<br /><pre><code>;Search for a Bone whose Name matches that of the given Frame<br />;Returns: index of matching Bone, or -1 for failure<br />Method CRagDoll.BoneIndexFromBoneFrame,uses esi,pBoneFrame<br />LOCAL pSkin<br />LOCAL numBones<br />LOCAL BoneNum<br />	SetObject esi<br />	.if .m_pFirstMesh==0<br />		DbgWarning &quot;NULL m_pFirstMesh&quot;,&quot;CRagDoll.BoneIndexFromBoneFrame&quot;<br />		invoke ExitProcess,0<br />	.endif<br />	mov ebx,.m_pFirstMesh<br />	m2m pSkin, .MESHCONTAINER.Base.pSkinInfo	<br />	; Search for a bone with same name as frame<br />	mov numBones,$ICall (pSkin::ID3DXSkinInfo.GetNumBones)<br />	mov BoneNum , -1<br />	xor ecx,ecx<br />	.while ecx&lt;numBones<br />		push ecx<br />		ICall pSkin::ID3DXSkinInfo.GetBoneName,ecx<br />		mov ebx,pBoneFrame		<br />		invoke lstrcmp,eax, .D3DXFRAME.pName<br />		pop ecx<br />		.if eax==0<br />			mov BoneNum ,ecx<br />			.break<br />		.endif<br />		inc ecx<br />	.endw<br />	mov eax,BoneNum<br />MethodEnd</code></pre><br /><br />Now for the motherlode: note that this Method is not quite complete.<br /><pre><code>;Calculate a BoundingBox for a BoneFrame<br />;which encloses all vertices affected by<br />;the Bone, as well as the ConnectionPoints<br />;between the Bone and any other Bones.<br />;The resulting Box info is stored in <br />;the Frame&#39;s RagDollBone extension struct.<br />Method CRagDoll.GetBoneBoundingBoxSize,uses esi,pBoneFrame<br />LOCAL pSkin:ptr ID3DXSkinInfo<br />LOCAL pMesh:ptr MESHCONTAINER<br />LOCAL pFrameChild<br />LOCAL numBones		;#Bones in Model<br />LOCAL BoneNum		;Index of our Bone<br />LOCAL NumVertices	;#Vertices attached to our Bone<br />LOCAL Stride		;#Bytes per Vertex in original Mesh<br />LOCAL Vertices		;ptr to array of dword-sized Vertex Indices<br />LOCAL Weights		;ptr to array of real4 sized Skin Weights<br />LOCAL pVertices 	;ptr to original mesh VB<br />LOCAL pvecPtr		;<br />LOCAL vecPos:Vec3<br />LOCAL matInvFrame:D3DXMATRIX<br />LOCAL pmatInvBone	;ptr to Bone&#39;s Inverse Offset Matrix<br />LOCAL vecMin:Vec3<br />LOCAL vecMax:Vec3<br /><br /><br />; Set default min and max coordinates<br />and vecMin.x,0<br />and vecMin.y,0<br />and vecMin.z,0<br />and vecMax.x,0<br />and vecMax.y,0<br />and vecMax.z,0 <br /><br />;The first order of business in GetBoundingBoxSize is<br />;to find the bone that matches the frame&#39;s name.<br />;This bone, or rather the skinned mesh bone interface object <br />;(ID3DXSkinInfo), queries which vertices are connected to the bone.<br /><br />; Only process bone vertices if there is a bone to work with..<br />; Interesting Fact : BoneFrames are Named, other frames are not.<br />mov ebx,pBoneFrame<br />.if .D3DXFRAME.pName!=0<br />	; Get a pointer to ID3DXSkinInfo interface for easier handling.<br />	SetObject esi	<br />	.if .m_pFirstMesh==0<br />		DbgWarning &quot;NULL m_pFirstMesh&quot;,&quot;CRagDoll.GetBoneBoundingBoxSize&quot;<br />		invoke ExitProcess,0<br />	.endif	<br />	mov ebx,.m_pFirstMesh<br />	mov pMesh,ebx<br />	m2m pSkin, .MESHCONTAINER.Base.pSkinInfo<br />	<br />	;Search for a Bone whose name matches the name of the Frame<br />	mov BoneNum,$OCall (BoneIndexFromBoneFrame,pBoneFrame)<br /><br />	; Only continue if we found our target bone by name<br />	.if BoneNum != -1<br />		;After you&#39;ve found an ID3DXSkinInfo for the bone in question, <br />		;you query it for the number of vertices attached and allocate <br />		;arrays of DWORD and REAL4 values to hold the vertex indices <br />		;and weights.<br />		<br />		; Get the number of vertices attached to the bone<br />		mov NumVertices,$ICall(pSkin::ID3DXSkinInfo.GetNumBoneInfluences,BoneNum)<br />		.if eax!=0<br />			; Get stride of vertex data<br />			mov ebx,pMesh<br />			ICall .MESHCONTAINER.Base.MeshData.pMesh::ID3DXMesh.GetFVF<br />			mov Stride ,$invoke (D3DXGetFVFVertexSize,eax)<br /><br />			; Get bone&#39;s offset inversed transformation matrix<br />			mov pmatInvBone,$ICall (pSkin::ID3DXSkinInfo.GetBoneOffsetMatrix,BoneNum)<br />			<br />			;Allocate temp memory for arrays <br />			;of vertex indices and skin weights<br />			shl eax,2	;*4 for dword sized<br />			push eax<br />			mov Vertices ,$MemAlloc(eax)<br />			pop eax<br />			mov Weights&nbsp; ,$MemAlloc(eax)<br />			; Get the bone influences (vertices and skinweights)<br />			ICall pSkin::ID3DXSkinInfo.GetBoneInfluence,BoneNum, Vertices, Weights<br /><br />			;Now that the vertex indices are stored in the Vertices buffer <br />			;(which you accomplished by calling GetBoneInfluence), you can <br />			;begin iterating through each vertex, transforming the vertices <br />			;by the bone&#39;s inverse transformation and using the transformed <br />			;vertices to calculate the size of the bounding box.<br />						<br />			; Lock vertex buffer and go through all of<br />			; the vertices that are connected to our bone<br />			mov ebx,pMesh<br />			ICall .MESHCONTAINER.Base.MeshData.pMesh::ID3DXMesh.LockVertexBuffer,D3DLOCK_READONLY, addr pVertices<br /><br />			xor ecx,ecx<br />			.while ecx&lt;NumVertices<br />				push ecx<br />				; Get pointer to vertex coordinates<br />				;pvecPtr = pVertices+Vertices<em>*Stride<br />				shl ecx,2<br />				add ecx,Vertices<br />				mov eax,dword ptr	;eax=Vertices<em><br />				mul Stride				;eax=Vertices<em>*Stride<br />				add eax,pVertices		;eax=pVertices+Vertices<em>*Stride<br />				mov pvecPtr,eax<br />				; Transform vertex by bone offset transformation<br />				;(ie from Modelspace to Bonespace)<br />				;This makes the vertices relative to the Bone instead of <br />				;to the Origin of the Model.<br />				invoke D3DXVec3TransformCoord,addr vecPos, pvecPtr, pmatInvBone<br /><br />				;Get min/max values<br />				fMin vecMin.x,vecPos.x<br />				fstp vecMin.x<br />				fMin vecMin.y,vecPos.y<br />				fstp vecMin.y<br />				fMin vecMin.z,vecPos.z<br />				fstp vecMin.z<br />				;<br />				fMax vecMax.x,vecPos.x<br />				fstp vecMax.x<br />				fMax vecMax.y,vecPos.y<br />				fstp vecMax.y<br />				fMax vecMax.z,vecPos.z<br />				fstp vecMax.z<br />				<br />				pop ecx<br />				inc ecx<br />			.endw<br /><br />			;Unlock VB<br />			mov ebx,pMesh<br />			ICall .MESHCONTAINER.Base.MeshData.pMesh::ID3DXMesh.UnlockVertexBuffer<br /><br />			; Free temp resources<br />			MemFree Vertices<br />			MemFree Weights<br />		.endif<br /><br />		;At the end of this bit of code, you&#39;ll have the extents of <br />		;the bounding box stored in the two vectors (vecMin and vecMax) <br />		;you instanced at the beginning of the function. <br />		;The array of vertex indices is freed (as well as the vertex weights), <br />		;and processing continues by accounting for the point where <br />		;the bone connects to its parent and child bones.<br /><br />		;To factor in the connection points, you basically grab <br />		;the world-space coordinates of the connected bones and<br />		;transform them by the bone&#39;s inverse transformation. <br />		;These coordinates are then compared to the coordinates<br />		;stored in the vecMin and vecMax vectors.<br />	<br />		; Factor in child bone connection points to size<br />		mov ebx,pBoneFrame<br />		.if .D3DXFRAME.pFrameFirstChild!=0<br />			; Get the bone&#39;s inverse transformation to<br />			; position child connections.<br />			mov ebx,pBoneFrame<br />			invoke D3DXMatrixInverse,addr matInvFrame,NULL,addr .FRAME.matCombined<br /><br />			; Go through all child frames connected to this frame<br />			mov ebx,pBoneFrame<br />			m2m pFrameChild,.D3DXFRAME.pFrameFirstChild<br />			.while pFrameChild!=0<br />				; Get the frame&#39;s vertex coordinates and transform it<br />				mov ebx,pFrameChild<br />				fld .FRAME.matCombined.m30<br />				fld .FRAME.matCombined.m31<br />				fld .FRAME.matCombined.m32<br />				fstp vecPos.z<br />				fstp vecPos.y<br />				fstp vecPos.x<br />				invoke D3DXVec3TransformCoord,addr vecPos, addr vecPos, addr matInvFrame<br /><br />				;Get min/max values<br />				fMin vecMin.x,vecPos.x<br />				fstp vecMin.x<br />				fMin vecMin.y,vecPos.y<br />				fstp vecMin.y<br />				fMin vecMin.z,vecPos.z<br />				fstp vecMin.z<br />				;<br />				fMax vecMax.x,vecPos.x<br />				fstp vecMax.x<br />				fMax vecMax.y,vecPos.y<br />				fstp vecMax.y<br />				fMax vecMax.z,vecPos.z<br />				fstp vecMax.z<br />				<br />				; Go to next child bone<br />				mov ebx,pFrameChild<br />				m2m pFrameChild , .D3DXFRAME.pFrameSibling<br />			.endw<br />		.endif<br />		<br />		;You can now finish the function by storing the size of the box. <br />		;If the box is too small, set the size to a minimum amount <br />		;(MINIMUM_BONE_SIZE is set to 1.0f).<br />	<br />		; Calc the bounding box size<br />		mov eax,pBoneFrame		<br />		mov eax,.FRAME.pRagDollBone<br />		fld&nbsp; vecMax.x<br />		fsub vecMin.x<br />		fabs<br />		fstp .RagDollBone.m_vecBBSize.x<br />		;<br />		fld&nbsp; vecMax.y<br />		fsub vecMin.y<br />		fabs<br />		fstp .RagDollBone.m_vecBBSize.y<br />		;<br />		fld&nbsp; vecMax.z<br />		fsub vecMin.z<br />		fabs<br />		fstp .RagDollBone.m_vecBBSize.z<br />		<br />		; Make sure each bone has a minimal size<br />		mov eax,pBoneFrame<br />		mov eax,.FRAME.pRagDollBone<br />		fMin .RagDollBone.m_vecBBSize.x,MINIMUM_BONE_SIZE<br />		fstpReg ebx<br />		.if ebx == .RagDollBone.m_vecBBSize.x<br />			mov eax,pBoneFrame<br />			fld MINIMUM_BONE_SIZE<br />			fst .RagDollBone.m_vecBBSize.x<br />			fmul fHalf<br />			fstp vecMax.x<br />		.endif<br /><br />		mov eax,pBoneFrame<br />		mov eax,.FRAME.pRagDollBone<br />		fMin .RagDollBone.m_vecBBSize.y,MINIMUM_BONE_SIZE<br />		fstpReg ebx<br />		.if ebx == .RagDollBone.m_vecBBSize.y<br />			mov eax,pBoneFrame<br />			fld MINIMUM_BONE_SIZE<br />			fst .RagDollBone.m_vecBBSize.y<br />			fmul fHalf<br />			fstp vecMax.y<br />		.endif<br />		<br />		mov eax,pBoneFrame<br />		mov eax,.FRAME.pRagDollBone<br />		fMin .RagDollBone.m_vecBBSize.z,MINIMUM_BONE_SIZE<br />		fstpReg ebx<br />		.if ebx == .RagDollBone.m_vecBBSize.z<br />			fld MINIMUM_BONE_SIZE<br />			fst .RagDollBone.m_vecBBSize.z<br />			fmul fHalf<br />			fstp vecMax.z<br />		.endif<br />	<br />		; Set the bone&#39;s offset to center based on half the size<br />		; of the bounding box and the max position<br />		mov eax,pBoneFrame<br />		mov eax,.FRAME.pRagDollBone<br />		lea ebx,.RagDollBone.m_vecJointOffset<br />		lea eax,.RagDollBone.m_vecBBSize<br />		fld .Vec3.x<br />		fmul fHalf<br />		fsub vecMax.x<br />		fstp .Vec3.x<br />		;<br />		fld .Vec3.y<br />		fmul fHalf<br />		fsub vecMax.y<br />		fstp .Vec3.y<br />		;<br />		fld .Vec3.z<br />		fmul fHalf<br />		fsub vecMax.z<br />		fstp .Vec3.z	<br />	.endif<br />.endif<br />MethodEnd</code></pre><br /><br />It&#39;s important to note that &quot;the boneboxes are defined in bonespace and must be transformed back into modelspace before self-collision tests, and then into worldspace before testing against anything else&quot;.<br />The reason they are defined in bonespace is so that they are &quot;bone-aligned&quot;, so that we can strongly associate the orientation of a bone and its box.. in fact, they share the same&nbsp; transformation matrix.<br /><br />This means when the physics orients our boxes, and thus updates the orientation matrix, the bone orientation changes to suit - it can&#39;t help it - it&#39;s using the same matrix :)<br /><br />Now you can see why I chose to extend the FRAME struct the way I did - we&#39;re strongly associating a &quot;box physics object&quot; with each &quot;bone frame object&quot;.<br /><br />In the next day or two I&#39;ll post an update of the entire project source + binary :)<br />Questions?</div>
    <div class="meta">Posted on 2006-04-10 11:41:42 by Homer</div>
   </div>
   <div class="post" id="post-179401">
    <div class="subject"><a href="#post-179401">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">We should be in a position now to be able to call our entrypoint method (CRagDoll::LoadXFile) and have the BoneBoxes automatically generated to suit our Bones.<br />We&#39;re actually only describing the Boxes in terms of a pair of min/max corner values, which won&#39;t quite cut the mustard - we really ought to describe the Box as a set of eight Points (we already defined an array to hold them).<br /><br />Note once more that the Boxes are NOT axially-aligned ... they are Bone-aligned.<br />In terms of collision detection, I&#39;m only going to perform point-based collision tests.<br />We will test the eight box points against various spheres and planes.<br /><br />Since the Boxes overlap each other slightly in ModelSpace, we will not perform collision testing between the boxes of any Bones that are directly connected.<br />IE, there will be NO testing for collision between LeftUpperArm and LeftLowerArm, but there WILL be testing for collision between LeftUpperArm and LeftHand.<br />This means that we&#39;re allowing the skinmesh to self-intersect at the &quot;creases&quot; formed by the joints between bones.<br /><br />I intend to implement rendering of the BoneBoxes during Animated mode as my next step, to make it obvious what the heck all this BoneBox business is about.<br />Next is to implement the switch to RagDoll mode, and enough collision-detection to test for (if not resolve) hits between &quot;boneboxes that are not sharing a joint&quot;.<br /><br />The physics code is practically complete now, but I choose to leave it unimplemented until the bonebox stuff is proven .. For now, I&#39;m just gonna pretend those methods don&#39;t exist ;)<br /><br />I know, I know, I&#39;m waffling on about stuff you can&#39;t actually SEE, and not sharing updates of the binary as often as I could.. I&#39;ll repost when I think the framework has reached its next milestone, and until then, you&#39;ll have to be satisfied with the snippets of code I&#39;m posting along the way.<br /><br />I&#39;m inclined to separate the physics code from the CRagDoll class, so I&#39;ll try to write it in a way that lends itself toward encapsulation, and then when its working, if I still feel justified in doing so, I&#39;ll create one or more physics-specific object classes.<br /><br />Has anyone been playing with the earlier project framework since I posted it?<br />I&#39;m just curious who I&#39;m actually talking to, aside from writing a reference for myself..<br /></div>
    <div class="meta">Posted on 2006-04-11 01:51:54 by Homer</div>
   </div>
   <div class="post" id="post-179409">
    <div class="subject"><a href="#post-179409">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Hi Homer<br />I haven&#39;t played nor compiled your code, but I&#39;m interested in how you create the &quot;BoneBoxes&quot; since I need something similar for my parts/assemblies of my CAD project.<br /><br />Biterider</div>
    <div class="meta">Posted on 2006-04-11 03:40:42 by Biterider</div>
   </div>
   <div class="post" id="post-179410">
    <div class="subject"><a href="#post-179410">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Let&#39;s review how to construct the BoneBoxes :)<br /><br />For any Bone, we are able to obtain several different things. For the problem of determining the bounds of a Bone&#39;s influence, we want:<br />1 - a transformation matrix which moves us from the origin of the Bone to the origin of the Model - it&#39;s known as an &quot;inverse bone offset matrix&quot;, and it&#39;s simple to obtain.<br />2 - the subset of vertices which are affected by the Bone (given as a set of indices).<br /><br />Once we have these two things, we can look up each affected vertex and then transform it from modelspace into bonespace using the inverse bone offset matrix. We can do this for all the vertices in the affected subset, and track the min and max values as we go, discarding the vertices as we go, since we&#39;re only obtaining the bounds.<br />The end result of this is a pair of min/max values describing the untransformed boundingbox.<br /><br />You might care to imagine this as &quot;transforming the affected bodypart to the origin so that our boundingbox is relative to the bone origin, rather than the model origin&quot;.<br />It also means that the boundingbox now shares the Bone&#39;s transformation matrix ;)<br /><br />We&#39;ve now constructed one or more Bone-oriented boundingboxes, all that remains is to transform them back from bonespace to modelspace (using the inverse of the previously used matrix) but we don&#39;t do that until after we&#39;re done manipulating it (be it via animation or physics), because as long as the box is in bonespace, its easier to orient, and since the Bone and its Box share a common matCombined matrix, their orientations are in fact locked together.. this is why its so useful to bone-align the boxes :)<br /><br /></div>
    <div class="meta">Posted on 2006-04-11 04:24:38 by Homer</div>
   </div>
   <div class="post" id="post-179426">
    <div class="subject"><a href="#post-179426">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Hi Homer,<br /><br /><div class="quote">Has anyone been playing with the earlier project framework since I posted it?<br />I&#39;m just curious who I&#39;m actually talking to, aside from writing a reference for myself..</div><br /><br /><div class="quote">In the next day or two I&#39;ll post an update of the entire project source + binary</div><br /><br />I can assure you this is the most important thread I&#39;m interested in at the moment.<br />As I told you I compiled the project. And I will do so again.<br />So you are talking at least to me.<br /><br />Keep on going. It&#39;s most interesting.<br />It&#39;s not only a reference for yourself, but also for the ones who are looking over your shoulder at the moment, and the ones who will will be reading this thread in the future.<br /><br /><div class="quote">Am I going too fast? Have I dumbed it down too much? Is this stuff too weird? etc..</div><br /><br />Regarding this I can say: Keeping things simple is not so bad. It&#39;s better to overexplain something than telling to little. In the end it will attract more people, even after this thread has been closed for a long time. <br /><br />Friendly regards,<br />mdevries<br /></div>
    <div class="meta">Posted on 2006-04-11 13:08:38 by mdevries</div>
   </div>
   <div class="post" id="post-179430">
    <div class="subject"><a href="#post-179430">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">keep going Homer<br />busy atm with artwork and lightmap renderer<br /></div>
    <div class="meta">Posted on 2006-04-11 13:37:56 by daydreamer</div>
   </div>
   <div class="post" id="post-179460">
    <div class="subject"><a href="#post-179460">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">OK, let&#39;s keep going :)<br /><br />One of the most interesting things I gained from studying Microsoft&#39;s MultiAnim demo was learning how to set up an animation event callback for the purpose of timing a sound effect.<br />That demo used an xfile called something like &quot;Tiny4Anim.x&quot;, it had 4 animationsets for the character (loiter, walk, jog, and &#39;look at wristwatch&#39;). The walk and jog animations had special callbacks set up to play a &quot;footfall&quot; sound effect at hardcoded positions in the respective animationsets. I&#39;m DEFINITELY going to implement something like this - not just for footfalls but particularly for weapon attacks. I&#39;ll implement this as a side-note just after I implement the animation blending controls, allowing you to define your own timed animation soundeffects via a common callback, at runtime, via the gui :)<br /><br />Weapons are a problem - they tend to require their own animations, and they fall into at least two categories : one and two handed.<br /><br />My current thinking is to import all weapons that a character can wield into the same Scene as the character, and create extra joints in the hands which are later used as weapon attachment points/orientation controls, then one by one, attach each weapon to the model, create the attack animations, and detach weapon from model - it&#39;s the hand joints that will orient our weapon during attacks, the weapon itself isn&#39;t necessarily animated (this is cool to mention though - our weapon mesh can be another animated skinmesh if we really want, with its OWN AnimationSets...)<br /><br />There&#39;s another of these so-called &quot;attachment points&quot; placed near the rectum of the character, which is used to attach the model to a saddle or chair, and at least two more on the character&#39;s feet, used to sense the groundplane, eg climb stairs (basically we need to fudge the animation with respect to the terrain).<br /><br />Can you guys think of any more useful &quot;attachment points&quot;, or situations where the ones I described are unsufficient?<br />Who&#39;s good with Maya or other high end modeller and knows how to export user data in XFile format, and/or can supply a demo model with N animations for use in this free educational project?<br /><br /></div>
    <div class="meta">Posted on 2006-04-12 03:51:32 by Homer</div>
   </div>
   <div class="post" id="post-179568">
    <div class="subject"><a href="#post-179568">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">I spent yesterday making a series of minor changes to the framework, and am happy to report that I can now load Tiny4Anim.x, and that the ListView now correctly displays the state of the AnimationController.. also, I modified my SetTrackTransitionKey method to set up a timed animation blending event which fades out one existing AnimationTrack and simultaneously fades another one in.. what remains is to process doubleclicks on the ListView control for selecting a new Animation, and using the transition code to smoothly fade to the new animation .. and to implement the blender editing controls, below the ListView.<br /><br />BoneBoxes are being calculated, but I have no way to prove they are correct yet.<br /><br />Anyway, here&#39;s an update of the Binary so you can see what&#39;s been going on :)<br />I think that next&nbsp; I&#39;ll add some code to display the boneboxes while the animation plays..<br /><br />PS : Since I moved the code for Loading a skinmesh to be driven by the GUI&#39;s menu controls, I&#39;ve noticed an intermittent GPF that occurs SOMETIMES, but usually not.<br />It occurs inside the D3DXLoadMeshHierarchyFromX api, and appears NOT to occur within our ID3DXAllocateHieraerchy callbacks, or be due to register preservation during the callbacks... can anyone else verify/reproduce this problem?<br /><br />Have a nice day :)</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1553" target="_blank">DXSkinMesh.rar</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-04-13 23:41:58 by Homer</div>
   </div>
   <div class="post" id="post-179575">
    <div class="subject"><a href="#post-179575">Re: Animated SkinMesh under D3D</a></div>
    <div class="body"><br />Another small bug in D3DX9Anim.inc<br />Interface is ID3DXAnimationController<br />Correction is:<pre><code>&nbsp; STDMETHOD SetTrackPosition,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dword, real8</code></pre><br /><br />Happy nailing of the godhead, everyone.<br /></div>
    <div class="meta">Posted on 2006-04-14 02:38:51 by Homer</div>
   </div>
   <div class="post" id="post-179576">
    <div class="subject"><a href="#post-179576">Re: Animated SkinMesh under D3D</a></div>
    <div class="body"><div class="quote"><br />OK, let&#39;s keep going :)<br /><br />One of the most interesting things I gained from studying Microsoft&#39;s MultiAnim demo was learning how to set up an animation event callback for the purpose of timing a sound effect.<br />That demo used an xfile called something like &quot;Tiny4Anim.x&quot;, it had 4 animationsets for the character (loiter, walk, jog, and &#39;look at wristwatch&#39;). The walk and jog animations had special callbacks set up to play a &quot;footfall&quot; sound effect at hardcoded positions in the respective animationsets. I&#39;m DEFINITELY going to implement something like this - not just for footfalls but particularly for weapon attacks. I&#39;ll implement this as a side-note just after I implement the animation blending controls, allowing you to define your own timed animation soundeffects via a common callback, at runtime, via the gui :)<br /><br />Weapons are a problem - they tend to require their own animations, and they fall into at least two categories : one and two handed.<br /><br />My current thinking is to import all weapons that a character can wield into the same Scene as the character, and create extra joints in the hands which are later used as weapon attachment points/orientation controls, then one by one, attach each weapon to the model, create the attack animations, and detach weapon from model - it&#39;s the hand joints that will orient our weapon during attacks, the weapon itself isn&#39;t necessarily animated (this is cool to mention though - our weapon mesh can be another animated skinmesh if we really want, with its OWN AnimationSets...)<br /><br />There&#39;s another of these so-called &quot;attachment points&quot; placed near the rectum of the character, which is used to attach the model to a saddle or chair, and at least two more on the character&#39;s feet, used to sense the groundplane, eg climb stairs (basically we need to fudge the animation with respect to the terrain).<br /><br />Can you guys think of any more useful &quot;attachment points&quot;, or situations where the ones I described are unsufficient?<br />Who&#39;s good with Maya or other high end modeller and knows how to export user data in XFile format, and/or can supply a demo model with N animations for use in this free educational project?<br /><br /><br /></div><br />I am not yet learned modelling so much I can make a character, I am still texturing and cheats modelling with transmap existing meshes<br />I have some animations, but no clue howto export the whole animation to Xfile format<br />I really like the callback function, think a swordswinging animation also can check for if swords angles meet certain conditions, a lighteffect appear<br />but here a callback function can connect to collisiondetection vs another character/breakable object and act according to what happens<br /></div>
    <div class="meta">Posted on 2006-04-14 03:15:34 by daydreamer</div>
   </div>
   <div class="post" id="post-179585">
    <div class="subject"><a href="#post-179585">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Hi Homer,<br /><br /><div class="quote">Can you guys think of any more useful &quot;attachment points&quot;, or situations where the ones I described are unsufficient?</div><br /><br />What if the character lies down on a surface that is not horizontal? Perhaps it is a slope?<br />Or it is sitting on a chair, and the the back of the chair is not 100% vertical.<br />Would an extra attachment point between the shoulders be usefull?<br />In that case you would have 4 attachment points to work with:<br />2 at the feet, 1 near the rectum, and 1 between the shoulders<br /><br /><br /><div class="quote">Anyway, here&#39;s an update of the Binary so you can see what&#39;s been going on <br />I think that next?&nbsp; I&#39;ll add some code to display the boneboxes while the animation plays..<br /><br />PS : Since I moved the code for Loading a skinmesh to be driven by the GUI&#39;s menu controls, I&#39;ve noticed an intermittent GPF that occurs SOMETIMES, but usually not.<br />It occurs inside the D3DXLoadMeshHierarchyFromX api, and appears NOT to occur within our ID3DXAllocateHieraerchy callbacks, or be due to register preservation during the callbacks... can anyone else verify/reproduce this problem?<br /></div><br /><br />At first I thougt I didn&#39;t have tiny4anix.x<br />But it had a slightly different name on my machine: tiny_4anim.x<br />When I tried to load it, it resulted in a GPF.<br />I&#39;m using DX 9 (SDK December 2005) on an XP SP2 machine.<br /><br />I also tried to load tiny.x with the attached executable.<br />When I open the x.file the grey area just flickers once.<br />The model is not loaded into that area. But there was no GPF.<br /><br />Friendly regards,<br />mdevries.</div>
    <div class="meta">Posted on 2006-04-14 06:21:40 by mdevries</div>
   </div>
   <div class="post" id="post-179588">
    <div class="subject"><a href="#post-179588">Re: Animated SkinMesh under D3D</a></div>
    <div class="body"><br />There is a problem I&#39;m aware of regarding the render window : occasionally , for several possible reasons, we &quot;lose our render device&quot;..<br />The demo framework makes no attempt to detect or remedy this situation.<br />Until I add code to handle this situation, I suggest that you make the debug window smaller, this seems to help.<br /><br />With regards to Tiny_4Anim.x, the demo will certainly crash if the texture filepath does not exist, so you&#39;ll need to make a folder called Tiny in the same folder as the demo, and then copy the DDS skin file into it.<br /><br />Even having done this, there is still a small chance of GPF during loading, which I&#39;ve mentioned already.<br /><br />Anyway, please try the stuff I suggested and let me know how you went.</div>
    <div class="meta">Posted on 2006-04-14 07:22:22 by Homer</div>
   </div>
   <div class="post" id="post-179591">
    <div class="subject"><a href="#post-179591">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Hi Homer,<br /><br />I created the Tiny-directory under the directory the DXSkinMesh.exe file was in.<br />In that subdirectory I placed tiny_skin.dds. This is the right file I guess? Or are more files required?<br /><br />I also placed Tiny.x and Tiny_skin.bmp in the subdirectory.<br />When I load Tiny.x the listview mentions only Track 0: Wieight = 1.0, and Length = 1.0<br />The rest of the values are 0. The model itself doesn&#39;t show up.<br /><br />When I load Tiny_4anim.x, the Listview is filled with information for the Tracks 0 to 3.<br />In track 0: Weight = 1.0 and Length = 1.0. All other values are 0.<br />The model doesn&#39;t show up in this case either.<br /><br />So, in both situations the grey area still remains just grey.<br />Both models still won&#39;t show up.<br />And indead: sometimes a GPF follows, but not always.<br />But adding the Tiny-directory, and putting the Tiny_skin.dds file in it, is certainly a step forward.<br /><br /><div class="quote">Until I add code to handle this situation, I suggest that you make the debug window smaller, this seems to help.</div><br /><br />Regarding this suggestion: There was no difference, as far as I could see. <br /><br />Friendly regards,<br />mdevries.</div>
    <div class="meta">Posted on 2006-04-14 10:13:55 by mdevries</div>
   </div>
   <div class="post" id="post-179605">
    <div class="subject"><a href="#post-179605">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Yeah, that&#39;s the only file you need.. its just because in Tiny4Anim.x, the texture has been given a pathname rather than just a filename, and I haven&#39;t written any code to strip paths from texture files and/or go hunting in other folders for them.<br />The path given in this xfile is &quot;tiny\tiny_skin.dds&quot;<br />The dds file is an image file containing the texture, you don&#39;t need the bmp for this xfile.<br /><br />Check this out, I haven&#39;t looked into it yet, but theres TWO MESHES in Tiny4Anim.x, the first mesh only has 8 faces, the second mesh is the main mesh.<br />The old CModel.Draw method might have failed on this xfile, because it only draws the first meshcontainer encountered (plus submeshes).<br />I changed CModel.Draw to draw a given MeshContainer, and changed CModel.DrawFrame to call CModel.Draw for each encountered MeshContainer, and I call CModel.DrawFrame, pRootFrame in my Render thread.<br />What ya think the 8-faced mesh is? (It doesnt get rendered, maybe it has no material?)<br />I&#39;m guessing: its a BoundingBox that deforms with the animated mesh,improving its accuracy.<br /><br />Here&#39;s an update of the binary.<br />It greatly reduces the frequency of the unknown gpf, as well as addressing some problems in the ListView display.. best of all, this version has all the controls implemented.<br /><br />I still really don&#39;t have a clue what&#39;s causing this intermittant gpf, but strangely, it seems to be related to rendering, which is disabled during the loading, so thats quirky.<br /><br />You can use left mousebutton to select an AnimationTrack (click the track identifier) and then use the lower controls to alter the track settings and hit Update to use the new values.<br />You can doubleclick any AnimationTrack to switch from the current animation to the one you clicked - and the switching of animations will not be &quot;sharp&quot;, a &quot;transition blend&quot; is performed.. <br /><br />Yes, the&nbsp; tracks other than 0 are initialized with Zero values - that&#39;s just the way things are insde Tiny4Anim.x, and it gets worse - it turns out that there&#39;s four AnimationSets, but only two AnimationTracks to play them on.. the update fixes that by using the Cloning trick I described in another post to expand the capacity of the AnimationController, so we can have enough AnimationTracks to play all AnimationSets at once if we wanna.<br /><br />Set a secondary track&#39;s Weight and Speed and Disable/ReEnable it to mix it with the current Animation - you can mix in all four Animations at once.<br /><br />The Update button only refers to the Weight,Speed and Position fields.<br />The Enable/Disable toggle is implemented independantly.<br />The Priority toggle is not yet implemented, and isn&#39;t really important.<br /><br />You might notice that once you Update you start getting garbage values appearing in the ListView, and that when you force a Switch Transition that you don&#39;t see the values in the listview &quot;crossfading&quot; as they actually do.<br /><br />Oh well, it&#39;s getting there - I said I&#39;d implement the Blender controls along the way, and it sure looks better to me now you can play all the animations and screw around with them :)<br /><br />I have no problem rendering with this version, provided that I don&#39;t cover the rendering window during the loading (or any other time, as this causes loss of render device after some seconds)<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1556" target="_blank">DXSkinMesh.rar</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-04-15 00:41:51 by Homer</div>
   </div>
   <div class="post" id="post-179606">
    <div class="subject"><a href="#post-179606">Re: Animated SkinMesh under D3D</a></div>
    <div class="body"><br />I think it&#39;s a good thing to build up the framework sourcecode in stages, posting it along the way, rather than post a robust framework that deals with all situations, because mountains of casecode that rarely get executed are not conducive to learning ;)<br /><br />I&#39;ll repost the entire source shortly, and at this stage, I&#39;ll want to discuss the existing framework again in order to &#39;set the stage&#39; for showing how to handle &quot;losing the render device&quot; (where and how to handle this tragedy).<br /><br />Maybe - just maybe - this relates to the unknown gpf ;)<br /></div>
    <div class="meta">Posted on 2006-04-15 01:00:34 by Homer</div>
   </div>
   <div class="post" id="post-179617">
    <div class="subject"><a href="#post-179617">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Hi Homer,<br /><br /><div class="quote">Check this out, I haven&#39;t looked into it yet, but theres TWO MESHES in Tiny4Anim.x, the first mesh only has 8 faces, the second mesh is the main mesh.</div><br /><br />DubbelClicking on Tiny_skin.dds shows 2 identical versions of the skin (as far as I can see). Maybe it has something to do with it.<br /><br /><br />I tested the new version of DXSkinMesh.exe. The character shows up now.<br />And I can alter the settings in the listview.<br />More than that: I can select a different animation from it, being reflected in the render-window.<br /><br />I haven&#39;t seen intermittent GPF&#39;s under the new circumstances sofar.<br /><br /><br />Friendly regards,<br />mdevries.</div>
    <div class="meta">Posted on 2006-04-15 09:15:23 by mdevries</div>
   </div>
   <div class="post" id="post-179618">
    <div class="subject"><a href="#post-179618">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">I&#39;ll probably begin writing two new object classes this evening, for the purpose of implementing Instancing of our animated models..not so useful for Player models, but exceedingly handy for Enemies :)<br /><br />Basically each Instance of our model will have its own position, orientation etc, and most importantly, each will have its own AnimationController.. this is important because when we start instancing our animated model, we can&#39;t mess with the original AC that we got from Loading..&nbsp; we have to Clone a copy of it into each new Instance, and use that instead.<br /><br />So, I feel it&#39;s convenient to write a CCharacter class which represents an Instance of a referenced CRagDoll, and a Manager class to serve as the primary interface for user calls would be nice too.<br /><br />I don&#39;t like chocolate.<br /></div>
    <div class="meta">Posted on 2006-04-15 09:16:36 by Homer</div>
   </div>
   <div class="post" id="post-179622">
    <div class="subject"><a href="#post-179622">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Here&#39;s some code which demonstrates how to correctly Instance our RagDoll as described in the previous posting.<br />It shows how to take advantage of an existing class as a &#39;reference object&#39; (CRagDoll), and uses a lot of existing code ;)<br />The CRagDollInstance object takes advantage of our proven working code and provides the ability to create, animate and render N unique instances of any loaded ragdoll.<br /><br />Instances would likely be stored in a standard OA32 Collection.<br /><br />The idea is that we load a RagDoll using our existing code, and then attach it to one or more of these new-fangled &quot;CRagDollInstance&quot; objects (so each instance knows which ragdoll it represents). <br /><br />Note that this code is Beta and unimplemented, but should basically be right.<br />We should be able to load a RagDoll, then create some Instances of it and start animating and rendering the Instances individually, like in Microsoft&#39;s MultiAnim demo.<br />(But unlike that demo, there&#39;s still no code to drive the animations/behaviours of the instances, this is what I call a &quot;character class&quot;. Microsoft&#39;s character class was called CTiny. I&#39;ll get to character classes soon, that&#39;s where we describe a &quot;character&quot;, which is a set of behaviours that drive the animations of our model.. if we wanna write a game, we&#39;ll have to define several character classes to describe our various kinds of enemies and such. Tiny is an example of a character class, but not a great one :)<br /><br /><pre><code>;This object represents an INSTANCE of a loaded RagDoll.<br />CRagDollInstanceID equ 83484<br />Object CRagDollInstance,CRagDollInstanceID,Primer<br /><br />	RedefineMethod Init,Pointer	;pRagDoll<br />	RedefineMethod Done<br />	StaticMethod Update,REAL8	;rElapsedTime<br />	StaticMethod Draw	<br /><br />	;Position of the instance in WorldSpace<br />	DefineVariable m_vWorldPos,Vec3,{&lt;&gt;} <br />	;Matrix to Position the instance in WorldSpace<br />	DefineVariable matWorldTrans,D3DXMATRIX,{&lt;&gt;}<br />	;Matrix to Orient the model instance in WorldSpace<br />	DefineVariable matWorldRot,D3DXMATRIX,{&lt;&gt;}<br />	;Pointer to our Cloned AnimationController<br />	DefineVariable m_pAC,Pointer,NULL<br />	;Pointer to Loaded Model (which this Instance is referencing)<br />	DefineVariable pRagDoll,Pointer,NULL<br />ObjectEnd<br /><br />;Cleanup:<br />;Release the Cloned AC (see Init)<br />Method CRagDollInstance.Done,uses esi<br />	SetObject esi<br />	SafeRelease .m_pAC<br />MethodEnd<br /><br />;Initialize:<br />;Clone a copy of the RagDoll&#39;s AnimationController.<br />;Then initialize the Cloned AC.<br />Method CRagDollInstance.Init,uses esi, pRagDoll<br />LOCAL dwTracks,pAC,numEvents,numOutputs<br />	.if pRagDoll==NULL<br />		DbgWarning &quot;Error : NULL CRagDoll&quot;,&quot;CRagDollInstance.Init&quot;<br />		invoke ExitProcess,0<br />	.endif<br />	mov ebx,pRagDoll	<br />	.if .CRagDoll.m_pAnimController==NULL<br />		DbgWarning &quot;Error : NULL AnimationController&quot;,&quot;CRagDollInstance.Init&quot;<br />		mov eax,E_FAIL<br />		ExitMethod<br />	.endif<br />	;Grab a copy of the Original AC from the RagDoll<br />	m2m pAC,.CRagDoll.m_pAnimController<br /><br />&nbsp; &nbsp; ;Clone the AnimationController<br />&nbsp; &nbsp; mov numEvents,$ICall (pAC::ID3DXAnimationController.GetMaxNumEvents)<br />&nbsp; &nbsp; mov numOutputs,$ICall (pAC::ID3DXAnimationController.GetMaxNumAnimationOutputs)<br />&nbsp; &nbsp; SetObject esi<br />&nbsp; &nbsp; ICall pAC::ID3DXAnimationController.CloneAnimationController,numOutputs,.CRagDoll.m_dwAnimationSetCount,.CRagDoll.m_dwAnimationSetCount,numEvents,addr .m_pAC<br />	.if eax!=S_OK<br />		DbgWarning &quot;Error : Failed Cloning AnimationController&quot;,&quot;CRagDollInstance.Init&quot;<br />		mov eax,E_FAIL<br />		ExitMethod<br />	.endif<br /><br />&nbsp; &nbsp; ; Start with all tracks disabled<br />&nbsp; &nbsp; mov dwTracks, $ICall (.m_pAC::ID3DXAnimationController.GetMaxNumTracks)<br />&nbsp; &nbsp; xor ecx,ecx<br />&nbsp; &nbsp; .while ecx &lt; dwTracks<br />		push ecx<br />		ICall .m_pAC::ID3DXAnimationController.SetTrackEnable,ecx, FALSE<br />		pop ecx<br />		inc ecx<br />	.endw<br />&nbsp; &nbsp; mov eax, S_OK<br />MethodEnd<br /><br />;Basically adds an instance-specific transformation<br />;to position and orient the instance when we render it :)<br />;Aside from that, it uses code in CRagDoll to do its work.<br />Method CRagDollInstance.Draw,uses esi<br />	SetObject esi<br />	;Update the instance&#39;s Translation and Orientation matrices<br />	invoke D3DXMatrixTranslation,addr .matWorldTrans,addr .m_vWorldPos<br />	invoke D3DXMatrixRotationYawPitchRoll,addr .matWorldRot,addr .m_fYaw,addr .m_fPitch,addr .m_fRoll<br />	;Combine them<br />	invoke D3DXMatrixMultiply,addr .matWorldCombined,addr .matWorldRot,addr .matWorldTrans<br />	;Apply them<br />	ICall pD3DDevice::IDirect3DDevice9.SetTransform, D3DTS_WORLD,addr .matWorldTrans<br />	;Draw the skinmesh<br />	mov eax,.pRagDoll<br />	OCall .pRagDoll::CRagDoll.DrawFrame,.CRagDoll.m_pRootFrame<br />MethodEnd<br /><br />;This replacement version of CModel.Update uses the <br />;instance-specific AnimationController we Cloned<br />;to update the SkinMesh (so it&#39; ready for rendering)<br />;rather than the original AC (owned by the RagDoll)<br />Method CRagDollInstance.Update,uses esi, dElapsedTime:REAL8<br />local pMesh,Bones,SrcPtr,DestPtr<br />	;Update the time for animation<br />	SetObject esi<br />	.if .m_pAC!=0 ;&amp;&amp; .m_dwCurrentAnimation != -1<br />		ICall .m_pAC::ID3DXAnimationController.AdvanceTime,dElapsedTime,NULL<br />	.endif<br />	<br />	mov ebx,.pRagDoll<br />	.if .CRagDoll.m_pFrameRoot!=0<br />		;Update the matCombined matrices of the Frames<br />		;by performing a recursive matrix multiplication		<br />		OCall .pRagDoll::CRagDoll.UpdateFrameMatrices,.CRagDoll.m_pFrameRoot, NULL<br />		<br />		;UPDATE THE MATRIX PALETTE AND THE SKINMESH<br />		mov ebx,.pRagDoll<br />		m2m pMesh ,.CRagDoll.m_pFirstMesh<br />		.if pMesh!=0<br />			mov ebx,pMesh	<br />			.if .MESHCONTAINER.Base.pSkinInfo!=0<br /><br />				;Get number of Bones (from SkinInfo)<br />				ICall .MESHCONTAINER.Base.pSkinInfo::ID3DXSkinInfo.GetNumBones<br />				mov Bones,eax<br />					<br />				;Calculate each Matrix in the m_pBoneMatrices array<br />				;(Combine each Bone&#39;s matCombined and BoneOffset matrices)<br />				xor ecx,ecx<br />				.while ecx&lt;Bones	<br />					push ecx<br /><br />					mov eax,sizeof D3DXMATRIX<br />					mul ecx<br />					mov ebx,.pRagDoll<br />					add eax,.CRagDoll.m_pBoneMatrices<br />					push eax	;eax=ptr to nth target BoneMatrix<br />					;		<br />					mov eax,ecx<br />					shl eax,2<br />					mov edx,eax<br />					mov ebx,pMesh<br />					add eax,.MESHCONTAINER.ppFrameMatrices<br />					add edx,.MESHCONTAINER.ppBoneOffsetMatrices<br />					mov ebx,dword ptr	;source ebx=ptr to FRAME.matCombined<br />					mov edx,dword ptr	;source edx=ptr to BoneOffset matrix<br />					;<br />					pop eax<br />					<br />					invoke D3DXMatrixMultiply,eax,edx,ebx<br />					pop ecx<br />					inc ecx<br />				.endw<br /><br />				;We&#39;re ready to transform the mesh vertices :)<br />				<br />				; Lock the source and target vertex buffers				<br />				mov ebx,pMesh<br />				ICall .MESHCONTAINER.Base.MeshData.pMesh::ID3DXMesh.LockVertexBuffer,D3DLOCK_READONLY, addr SrcPtr<br /><br />				mov ebx,pMesh<br />				.if .MESHCONTAINER.pSkinMesh!=0<br />					mov ebx,pMesh<br />					ICall .MESHCONTAINER.pSkinMesh::ID3DXMesh.LockVertexBuffer,0, addr DestPtr<br />				.else<br />					DbgWarning &quot;NULL pSkinMesh&quot;<br />					invoke ExitProcess,0<br />				.endif<br />				<br />				; Update the skinned mesh using provided transformations<br />				mov ebx,pMesh<br />				ICall .MESHCONTAINER.Base.pSkinInfo::ID3DXSkinInfo.UpdateSkinnedMesh,.m_pBoneMatrices, NULL, SrcPtr, DestPtr<br /><br />				; We&#39;re done with this meshcontainer..<br />				; Unlock the vertex buffers<br />				mov ebx,pMesh<br />				ICall .MESHCONTAINER.pSkinMesh::ID3DXMesh.UnlockVertexBuffer<br />				mov ebx,pMesh<br />				ICall .MESHCONTAINER.Base.MeshData.pMesh::ID3DXMesh.UnlockVertexBuffer<br />			.endif<br />		.endif<br />	.endif<br />MethodEnd<br /><br /></code></pre><br /><br /></div>
    <div class="meta">Posted on 2006-04-15 11:26:50 by Homer</div>
   </div>
   <div class="post" id="post-179630">
    <div class="subject"><a href="#post-179630">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Hi Homer,<br /><br /><div class="quote">Tiny is an example of a character class, but not a great one </div><br /><br />In what way do you consider Tiny not to be a great class?<br /><br />Friendly regards,<br />mdevries.</div>
    <div class="meta">Posted on 2006-04-15 17:22:37 by mdevries</div>
   </div>
   <div class="post" id="post-179631">
    <div class="subject"><a href="#post-179631">Re: Animated SkinMesh under D3D</a></div>
    <div class="body">Tiny is a simple demo character class.<br />There&#39;s only four animations, so the number of possible activities that Tiny can engage in is quite small. For example, Tiny can&#39;t Jump.<br /><br />For now, I&#39;d like to steer the conversation back to the BoneBoxes.<br /><br />We&#39;ve managed to define our BoneBoxes as sets of Min/Max values, and determined the offset from the center of the box to the point where the box connects to its parent.<br />Note that the Boxes are defined in BoneSpace (are Bone-Aligned).<br />This was achieved by applying a per-bone matrix that was obtained during loading, whose purpose is to move from modelspace to bonespace (bindpose).<br />In order to get our boxes back into modelspace, we need to apply a different matrix.<br />If we applied the inverse of the matrix we used to make the boxes, we&#39;d have our boxes oriented around the model in bindpose.. but not animated.<br />We need to also consider the animation matrix ie, obtain our &quot;final matrix&quot; from the Palette which is used to transform the skinmesh vertices, and use THAT to transform our BoundingBox vertices from BoneSpace back to ModelSpace.<br />Since this final matrix is dynamic, we need to re-transform our BoneBoxes each time the matrix is modified, ie, within the Update code. This way, our BoneBoxes are automatically oriented to follow the animated Bones, which is what we want at first so we can render the boxes during animation and prove that stuff is working the way we planned..<br /><br /><br /></div>
    <div class="meta">Posted on 2006-04-15 18:30:40 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=24515&amp;page=1" style="">&laquo;</a><a href="../?id=24515&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="24515" /><input type="number" name="page" min="1" max="4" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=24515&amp;page=3">&gt;</a><a href="../?id=24515&amp;page=4">&raquo;</a></form>  </div>
 </body>
</html>