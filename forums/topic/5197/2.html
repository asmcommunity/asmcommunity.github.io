<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>64 bit conversion to ascii - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=5197" />
  <link rel="prev" href="../?id=5197&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=5197">64 bit conversion to ascii</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=5197&amp;page=1" style="">&laquo;</a><a href="../?id=5197&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="5197" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-38325">
    <div class="subject"><a href="#post-38325">64 bit conversion to ascii</a></div>
    <div class="body">Here is Svin's routine sligthly modified to use the '-' sign.<br />Also, I think I optimized the loop routine.<br /><br />I'd be glad to hear about other optimizations.<br /><br />JCM<br /><br />.code<br />uqw2a   proc uses ebx ecx esi edi lBuffer,lQword<br />	public	_uqw2a<br />_uqw2a:<br />LOCAL	num18:QWORD<br />	mov esi,offset lQword<br />	mov edi,offset lBuffer<br />	mov edx,<br />	mov eax,<br /><br />	or eax, eax<br />	jns positive<br />	mov byte ptr , '-'<br />	inc edi<br />	neg eax<br />	neg edx<br />	sbb eax, 0<br />positive:<br />	mov	esi, edi<br /><br />N19H equ 0DE0B6B3h<br />N19L equ 0A7640000h<br />N20H equ 8AC72304h<br />N20L equ 89E80000h<br />	cmp eax,N19H<br />	jne C20<br />	cmp edx,N19L<br />C20:<br />	jc  C18 <br />	cmp eax,N20H<br />	jne DO20<br />	cmp edx,N20L<br />DO20:<br />	jc  DO19<br />	mov byte ptr ,'1'<br />	sub edx,N20L<br />	lea edi,<br />	sbb eax,N20H<br />DO19:<br />	mov ebx, '0'-1<br />@@:	inc ebx<br />	sub edx,N19L<br />	sbb eax,N19H<br />	jnc @B<br />	add edx,N19L<br />	mov byte ptr ,bl<br />	adc eax,N19H<br />	inc edi<br />C18:<br />	mov dword ptr num18,edx<br />	mov dword ptr num18+4,eax<br /><br />	sub esp,10<br />	fild num18<br />	fbstp <br />	mov ecx,2<br />@@:<br />	pop eax<br />	mov ebx, eax<br />	and eax, 00F0F0F0Fh<br />	and ebx, 0F0F0F0F0h<br />	shr ebx, 4<br />	add eax, 30303030h<br />	add ebx, 30303030h<br /><br />	mov byte ptr , bh<br />	mov byte ptr , ah<br />	mov byte ptr , bl<br />	mov byte ptr , al<br />	shr ebx, 16<br />	shr eax, 16<br />	mov byte ptr , bh<br />	mov byte ptr , ah<br />	mov byte ptr , bl<br />	mov byte ptr , al<br />	dec ecx<br />	lea edi,<br />	jne @B<br /><br />	mov ah,byte ptr <br />	add esp,2                       ; pop ax better ?<br />	mov al,ah<br />	shr  al,4<br />	and eax,0f0fh<br />	or eax,3030h<br />	mov word ptr ,ax<br />	mov byte ptr ,0<br /><br />	lea ebx, <br />@@:	inc ebx<br />	cmp byte ptr ,30h<br />	je @B<br />	jae	finalfill<br />	dec ebx<br />finalfill:<br />	mov al, byte ptr <br />	inc ebx<br />	mov byte ptr , al<br />	inc esi<br />	or al,al<br />	jne finalfill<br />	ret<br />uqw2a endp<br /><br />JCM</div>
    <div class="meta">Posted on 2002-05-15 07:41:06 by MCoder</div>
   </div>
   <div class="post" id="post-38429">
    <div class="subject"><a href="#post-38429">64 bit conversion to ascii</a></div>
    <div class="body">Thanks MCoder<br /><br />I didn't see the small bug that happens if low part was 0 before hi part was 0. I added in your fixes, and also added a check to avoid dividing the hi part if it already reached zero.<br />Now uses the stack to store partial digits during calculation.<br /><br />final code <br /><br /><pre><code><br /><br />.486<br />.model flat,stdcall<br />option casemap&#58;none<br /><br />include \masm32\include\Windows.inc<br />include \masm32\include\masm32.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\user32.inc<br /><br />includelib \masm32\lib\user32.lib<br />includelib \masm32\lib\masm32.lib<br />includelib \masm32\lib\kernel32.lib<br /><br />i64toa proto &#58;DWORD,&#58;DWORD<br /><br />.data<br />testint1     dq 7FFFFFFFFFFFFFFFh<br />testint2     dq -1234567890123456789<br />caption1    db &quot;POSITIVE 64 bit integer&quot;,0<br />caption2    db &quot;NEGATIVE 64 bit integer&quot;,0<br />testbuff    db 64 dup&#40;32&#41; ,0<br /><br />.code<br /><br />start&#58;<br />invoke i64toa,ADDR testint1,ADDR testbuff<br />invoke MessageBox,0,ADDR testbuff,ADDR caption1,0<br />invoke i64toa,ADDR testint2,ADDR testbuff<br />invoke MessageBox,0,ADDR testbuff,ADDR caption2,0<br />invoke ExitProcess,0<br /><br />i64toa proc uses ebx ecx edx edi esi lpLarge&#58;DWORD,lpBuffer&#58;DWORD<br /> <br />   mov edi,lpLarge<br />   mov ebx,&#91;edi&#93;            ; low 32 bits<br />   mov ecx,&#91;edi+4&#93;          ; high 32 bits<br />   <br />   mov edi,lpBuffer <br />   or ecx, ecx <br />   jns positive <br />   mov byte ptr &#91;edi&#93;,'-' ; integer is negative <br />   inc edi <br />   not ebx <br />   not ecx <br />   add ebx,1 <br />   adc ecx,0 <br /><br />positive&#58;<br />;--------------------------------<br />	 xor eax, eax          ; push the 0 to end string<br />	 push eax <br />	 mov esi,10 ; decoding the 64 bit binary to ASCII <br />	  <br />@@&#58;     sub edx,edx<br />	  test ecx,ecx         ; avoid dividing numhi<br />	  jz not64             ; if it's already 0<br />	  <br />	  mov eax,ecx<br />	  div esi              ; divide numhi by 10...<br />	  mov ecx,eax<br /><br />not64&#58;  mov eax,ebx<br />	  div esi              ; .... then numlo by 10, using<br />	  mov ebx,eax          ; first remainder in edx<br />	  add dl,30h           ; new remainder plus 30h is the digit<br />	  push edx             ; store it in the stack for printing<br />	  or eax,ecx<br />	  jnz @B               ; keep looping until no digits left <br />;---------------------------------------------------------------<br />;  conversion  finished<br />;  copy from stack to testbuff  <br />;  +123456..................  pop to testbuff after sign<br />;---------------------------------------------------------------<br /><br />move&#58; <br />	 pop eax<br />	 mov &#91;edi&#93;,al        ; move......<br />	 inc edi<br />	 or eax,eax<br />	 jnz move<br />	 ret<br />i64toa   endp<br /><br />end start<br /><br /></code></pre></div>
    <div class="meta">Posted on 2002-05-15 16:50:15 by towers</div>
   </div>
   <div class="post" id="post-38434">
    <div class="subject"><a href="#post-38434">64 bit conversion to ascii</a></div>
    <div class="body">Good trick to avoid half of the divisions !<br /><br />BTW, you can optimize this:<br />   not ebx <br />   not ecx <br />   add ebx,1 <br />   adc ecx,0 <br /><br />as:<br /><br />neg ecx<br />neg ebx <br />sbb ecx, 0 <br /><br />JCM</div>
    <div class="meta">Posted on 2002-05-15 17:43:00 by MCoder</div>
   </div>
   <div class="post" id="post-41222">
    <div class="subject"><a href="#post-41222">64 bit conversion to ascii</a></div>
    <div class="body">More optimized code for good processors ;)<br /><pre><code><br />const<br />dig1	='0'<br />dig2	='0'<br />dig3	='0'<br />len	=1<br />label tblX2DecAsc dword<br />REPT 1000<br />dd len shl 24 + dig1 shl 16 + dig2 shl 8 + dig3<br />  dig1=dig1+1<br />  if dig1 gt '9'<br />    if len eq 1<br />      len=2<br />    endif<br />    dig1='0'<br />    dig2=dig2+1<br />    if dig2 gt '9'<br />      if len eq 2<br />        len=3<br />      endif<br />      dig2='0'<br />      dig3=dig3+1<br />    endif<br />  endif<br />ENDM<br /><br />macro Div1000<br />	mov edx,10624DD3h<br />	mov ecx,eax<br />	mul edx<br />	shr edx,6<br />	imul eax,edx,1000<br />	sub ecx,eax<br />endm<br /><br />macro FullTriplet<br />	pop eax<br />	Div1000<br />	mov eax,edx<br />	mov esi,&#91;tblX2DecAsc+4*ecx&#93;<br />	Div1000<br />	mov eax,&#91;tblX2DecAsc+4*edx&#93;<br />	mov &#91;d,edi+0&#93;,eax<br />	mov eax,&#91;tblX2DecAsc+4*ecx&#93;<br />	mov &#91;d,edi+3&#93;,eax<br />	mov &#91;d,edi+6&#93;,esi<br />	add edi,9<br />endm<br /><br />codeseg<br />proc Qword2DecAsc<br />	test edx,edx<br />	je Dword2DecAsc<br />	mov ebx,eax<br />	mov eax,edx<br />	mov esi,1000000000<br />	xor edx,edx<br />	div esi<br />	mov ecx,eax<br />	mov eax,ebx<br />	div esi<br />	mov ebx,ecx<br />	or ecx,eax<br />	je @@t3<br />	push edx<br />	mov edx,ebx<br />	div esi<br />	test eax,eax<br />	je @@t2<br />	push edx<br />	cmp eax,10<br />	jl @@ten<br />	mov ebx,0CCCCCCCDh<br />	mov ecx,eax<br />	mul ebx<br />	shr edx,3<br />	imul esi,edx,10<br />	add edx,'0'<br />	mov &#91;edi&#93;,dl<br />	inc edi<br />	sub ecx,esi<br />	mov eax,ecx<br />@@ten&#58;	add al,'0'<br />	mov &#91;edi&#93;,al<br />	inc edi<br />	FullTriplet<br />@@t1&#58;	FullTriplet<br />	mov &#91;b,edi&#93;,0<br />	ret<br />@@t2&#58;	mov eax,edx<br />	call Dword2DecAsc<br />	jmp @@t1<br />@@t3&#58;	mov eax,edx<br /><br />proc Dword2DecAsc<br />	mov ebx,esp<br />@@lpG&#58;	Div1000<br />	mov eax,edx<br />	push &#91;tblX2DecAsc+4*ecx&#93;<br />	test eax,eax<br />	jne @@lpG<br />	sub ebx,esp<br />	pop eax<br />	mov edx,eax<br />	shr edx,24<br />	mov ecx,edx<br />	xor ecx,3<br />	shl ecx,3<br />	shr eax,cl<br />	mov &#91;edi&#93;,eax<br />	add edi,edx<br />	jmp &#91;tbl-4+ebx&#93;<br />const<br />tbl	dd q@@0,q@@1,q@@2,q@@3<br />codeseg<br />q@@3&#58;	pop &#91;d,edi&#93;<br />	add edi,3<br />q@@2&#58;	pop &#91;d,edi&#93;<br />	add edi,3<br />q@@1&#58;	pop &#91;d,edi&#93;<br />	add edi,3<br />q@@0&#58;	mov &#91;b,edi&#93;,0<br />	ret<br />endp<br />endp<br /></code></pre><br />Compare Stepan's MMX and div+table versions<br /><br /><pre><code><br />MMX div+tbl number<br />249 32      0<br />276 32      1<br />276 32      10<br />276 32      100<br />276 43      1000<br />282 43      10000<br />282 43      100000<br />282 55      1000000<br />280 57      10000000<br />284 57      100000000<br />284 69      1000000000<br />284 185     10000000000<br />283 185     100000000000<br />295 196     1000000000000<br />294 195     10000000000000<br />294 195     100000000000000<br />293 208     1000000000000000<br />289 209     10000000000000000<br />289 209     100000000000000000<br />294 185     1000000000000000000<br />292 191     10000000000000000000<br />316 191     18446744073709551615<br />313 191     17777777777777777777<br />298 191     12345678901234567890<br />clocks<br /></code></pre></div>
    <div class="meta">Posted on 2002-06-03 09:39:19 by Nexo</div>
   </div>
   <div class="post" id="post-41238">
    <div class="subject"><a href="#post-41238">64 bit conversion to ascii</a></div>
    <div class="body"><strong>Nexo</strong>, how many conversions do you think would have to be made before this algo really becomes faster than a non-table version on these 'good processors'?</div>
    <div class="meta">Posted on 2002-06-03 10:37:07 by bitRAKE</div>
   </div>
   <div class="post" id="post-41276">
    <div class="subject"><a href="#post-41276">64 bit conversion to ascii</a></div>
    <div class="body">Probably you have in view of cache a problem. The table - 4000 bytes. For memory DDR333 cache will be loaded for ~3000ns. If frequency of the processor of 1400 MHz, it 4285clk. An average of clock ticks MMX 286 clk, DIV-TBL 126 clk. As the result, for arbitrary number it will be 27 conversions. It so is a lot of for you? I can somewhere was mistaken? But in any case I see acceleration of machining in real applications.</div>
    <div class="meta">Posted on 2002-06-03 14:31:56 by Nexo</div>
   </div>
   <div class="post" id="post-41284">
    <div class="subject"><a href="#post-41284">64 bit conversion to ascii</a></div>
    <div class="body">I am just curious about the environment for which this algo was designed and to stress that there is a need for more than one algo for a task.  I would not use this algo in a general way - it is for applications that do several conversions almost consecutively, or rather don't thrash the data cache between conversions.  Thanks for sharing it with us. :)</div>
    <div class="meta">Posted on 2002-06-03 15:12:49 by bitRAKE</div>
   </div>
   <div class="post" id="post-41587">
    <div class="subject"><a href="#post-41587">64 bit conversion to ascii</a></div>
    <div class="body">What is &quot;general way&quot;? :) I saw variation of productivity at generation of reports, mathematical tables and statistics, orders, listings of compilation. Even at insignificant quantity of numbers on the form (2-4). Three numbers, on the average ~10 digits - 10 triplets. The table - 63 lines cache (AMD). At worst 10 triplets - 1/6 necessary lines. But it is really even less. Plus a good FSB 266Mhz (533 Mhz). How many there should be a period between conversions for trash 384 Kb (or 512 Kb) cache memories? For one thread quantum will be generated more forms.</div>
    <div class="meta">Posted on 2002-06-05 12:23:50 by Nexo</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=5197&amp;page=1" style="">&laquo;</a><a href="../?id=5197&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="5197" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>