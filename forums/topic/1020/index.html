<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>code + helllppp: to ADDR or not to ADDR - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=1020" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=1020">code + helllppp: to ADDR or not to ADDR</a></p>
   <div class="post" id="post-6634">
    <div class="subject"><a href="#post-6634">code + helllppp: to ADDR or not to ADDR</a></div>
    <div class="body">the code below is what I have, with the help of others on this board, up to so far...  when I hardcode the indexes in as commented out in the code at the bottom of the listing, it works great.  When I increment a local variable pntr inside a .repeat/.until loop, and do an ADD pntr,28... then invoke pushbutton, it blows up with a 'cannot read' error. see below for details.  <br /><br />NOTES: I hardcoded the '28', which is the size of the structure, for now for debugging and hair-pulling purposes.  I've tried it with and without ADDRing the PcPt and I get the same results. When I uncomment out the code at the bottom and take out the looping invoke, it works prefectly.  Thank you for your continuing support.<br /><br /><br />.486<br />.model flat,stdcall<br />option casemap:none <br /><br />include &lt;\masm32\rlibinc\gio.inc&gt;<br />; contains all the includes/prototypes/etc..,.<br /><br />PANEL_CONTROL struct DWORD<br />  PcPb DWORD ?     ;Command<br />  PcPq DWORD ?     ;Response ie 400=open,402=close,404=exit,etc<br />  PcPt DWORD ?     ;Text on button<br />  PcX1 DWORD ?     ;x,y,wid,hgt of button<br />  PcY1 DWORD ?<br />  PcX2 DWORD ?<br />  PcY2 DWORD ?<br />PANEL_CONTROL ends<br /><br />; DB = db and C=command<br />PC_PB           equ 0015<br />QuitDBC         equ 500<br />LaunchDBC       equ 600<br />TestDBC         equ 650<br />OpenDBC         equ 651<br /><br />.data   <br /><br />FontText2       db &quot;with this script type of font...&quot;,0<br />FontName        db &quot;Roman&quot;,0<br />F_Comic         db &quot;Comic Sans MS&quot;,0<br />MouseClik       db 0            ;0=no click yet<br />BUFA1           db &quot;                                     &quot;,0<br />QuitDB          db &quot;EXIT&quot;,0<br />LaunchDB        db &quot;Launch&quot;,0<br />TestDB          db &quot;TEST&quot;,0<br />OpenDB          db &quot;OPEN&quot;,0<br /><br /><br />;Pc PANEL_CONTROL 16h dup (&lt;&gt;)<br />Pc PANEL_CONTROL &lt;PC_PB,   TestDBC,   offset   TestDB,     25,   400,   64,   64&gt;, <br />                 &lt;PC_PB,   OpenDBC,   offset   OpenDB,     25,   466,   64,   64&gt;,<br />                 &lt;PC_PB, LaunchDBC,   offset LaunchDB,     25,   530,   64,   64&gt;,<br />                 &lt;PC_PB,   TestDBC,   offset   TestDB,     25,   594,   64,   64&gt;<br /><br />sizeOfPanelControls dd ( $ - Pc ) / sizeof PANEL_CONTROL<br /><br />.data?<br />hInstance HINSTANCE ?<br />CommandLine LPSTR ?<br /><br />.const<br /><br />.code<br /><br />start:<br />    invoke GetModuleHandle,NULL<br />    mov hInstance,eax<br />    invoke GetCommandLine<br />    mov CommandLine, eax<br />    <br />   ; FillPC 0, PC_PB, TestDBC, offset TestDB, 25,400,64,64<br />   ; FillPC 1, PC_PB, OpenDBC, offset OpenDB, 25,466,64,64<br /><br />  xor eax,eax<br />  mov eax,sizeOfPanelControls<br />;  invoke wsprintf, addr BUFA1, SADD(&quot;Size of Buffer: %d&quot;), eax<br /> ; invoke MessageBox, NULL, addr BUFA1, SADD(&quot;size of panel ctlrs&quot;), MB_OK<br />  <br />  ;invoke MessageBox, NULL, addr MsgBoxText, addr MsgBoxCaption, MB_OK<br />    invoke WinMain, hInstance, NULL, CommandLine, SW_SHOWDEFAULT<br />    <br />;    invoke MessageBox, NULL, addr MsgBoxText, addr MsgBoxCaption, MB_OK<br />    invoke ExitProcess,eax<br /><br /><br />WinMain proc <br />&lt;blah blah blah&gt;<br />WinMain endp<br /><br />WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM<br />  LOCAL ps:PAINTSTRUCT<br />  LOCAL rect:RECT<br />  LOCAL lcolor:DWORD<br /> <br />  <br />  .IF uMsg==WM_DESTROY<br />    StopRun<br /><br />  .ELSEIF uMsg == WM_COMMAND<br />   pushad<br />   .if wParam == QuitDBC<br />        StopRun<br />   .endif<br />    .if wParam == LaunchDBC<br />        invoke MessageBox, hWnd, Pc[56].PcPt, SADD(&quot;Please Wait&quot;), MB_OK<br />    .endif<br />    .if wParam == TestDBC<br />        invoke MessageBox, hWnd, Pc[0].PcPt, SADD(&quot;TESTDBC&quot;), MB_OK<br />    .endif<br />    .if wParam == OpenDBC<br />        invoke MessageBox, hWnd, Pc[28].PcPt, SADD(&quot;OpenDBC&quot;), MB_OK<br />    .endif<br />     <br />    popad<br /><br />  .ELSEIF uMsg == WM_CREATE<br />    invoke Draw_Panel_Command, hWnd<br />          <br />  .ELSEIF uMsg==WM_CHAR<br />    push wParam<br />    pop char<br />    invoke InvalidateRect, hWnd,NULL,TRUE<br /><br />  .ELSEIF uMsg==WM_PAINT<br />    invoke BeginPaint, hWnd, ADDR ps<br />    mov hdc,eax<br />    <br />    RGB 192,192,192<br />    mov lcolor,eax<br />    invoke DrawGDI,hdc,0,0,1024,768,GDI_RECT,BS_SOLID,lcolor<br />   <br />    invoke EndPaint, hWnd, ADDR ps<br /><br />  .Else<br />    invoke DefWindowProc, hWnd, uMsg, wParam, lParam<br />    ret<br />  .ENDIF<br />  xor eax,eax<br />  ret<br />WndProc endp<br /><br />Draw_Panel_Command PROC  hWnd:HWND<br />    LOCAL  pntr:DWORD<br />    mov pntr, 0<br />  <br />.Repeat<br />  invoke wsprintf, addr BUFA1, SADD(&quot;Size of pntr: %d&quot;),pntr<br />  invoke MessageBox, NULL, addr BUFA1, SADD(&quot;size of pointer ctlrs&quot;), MB_OK  <br /><br />    invoke PushButton, Pc.PcPt, hWnd, Pc.PcX1, Pc.PcY1, Pc.PcX2,\<br />         Pc.PcY2, Pc.PcPq<br />    add pntr, 28<br /><br />.Until pntr &gt;= 112<br />    <br />;        invoke PushButton, Pc[0].PcPt,hWnd, Pc[0].PcX1, Pc[0].PcY1, Pc[0].PcX2, Pc[0].PcY2, Pc[0].PcPq<br />;        invoke PushButton, Pc[56].PcPt,hWnd, Pc[56].PcX1, Pc[56].PcY1, Pc[56].PcX2, Pc[56].PcY2, Pc[56].PcPq<br />;        invoke PushButton, Pc[28].PcPt,hWnd, Pc[28].PcX1, Pc[28].PcY1, Pc[28].PcX2, Pc[28].PcY2, Pc[28].PcPq<br />;        invoke PushButton, Pc[84].PcPt,hWnd, Pc[84].PcX1, Pc[84].PcY1, Pc[84].PcX2, Pc[84].PcY2, Pc[84].PcPq<br />  ret<br />Draw_Panel_Command endp<br /><br />end start</div>
    <div class="meta">Posted on 2001-09-08 20:15:22 by drarem</div>
   </div>
   <div class="post" id="post-6701">
    <div class="subject"><a href="#post-6701">code + helllppp: to ADDR or not to ADDR</a></div>
    <div class="body">Here's some modification of the frankenstein code per help from here, but still comes up with a read error.. doesn't like the indexing of the structure or so it appears..<br /><br /><br />Draw_Panel_Command PROC  hWnd:HWND<br />    LOCAL  pntr:DWORD<br /><br />    xor eax,eax<br />    xor ecx,ecx<br />     mov pntr, 0<br />  <br />.Repeat<br />   mov eax, <br />    mul ecx<br />    inc ecx<br />    lea edi, <br />    pushad<br />    invoke PushButton, (PANEL_CONTROL PTR ).PcPt, hWnd, (PANEL_CONTROL PTR ).PcX1, (PANEL_CONTROL PTR ).PcY1,\<br />          (PANEL_CONTROL PTR ).PcX2, (PANEL_CONTROL PTR ).PcY2, (PANEL_CONTROL PTR ).PcPq<br />    popad<br /><br />.Until pntr &gt;= 112</div>
    <div class="meta">Posted on 2001-09-09 20:38:51 by drarem</div>
   </div>
   <div class="post" id="post-6780">
    <div class="subject"><a href="#post-6780">code + helllppp: to ADDR or not to ADDR</a></div>
    <div class="body">Looks like you've dropped the increment code for pntr, so it loops forever.</div>
    <div class="meta">Posted on 2001-09-10 17:27:33 by tank</div>
   </div>
   <div class="post" id="post-6790">
    <div class="subject"><a href="#post-6790">code + helllppp: to ADDR or not to ADDR</a></div>
    <div class="body">actually, I cleaned up all my commented code out so it is more readable and wiped out the     add pntr,28   <br /><br />however it is there, trust me :)  I still have no dice with this, I have tried it multiple ways to fix it.<br /><br />if I hardcode the indexes as so:<br /><br />; invoke PushButton, Pc[0].PcPt,hWnd, Pc[0].PcX1, Pc[0].PcY1, Pc[0].PcX2, Pc[0].PcY2, Pc[0].PcPq <br />; invoke PushButton, Pc[56].PcPt,hWnd, Pc[56].PcX1, Pc[56].PcY1, Pc[56].PcX2, Pc[56].PcY2, Pc[56].PcPq <br /><br /><br />it works fine.  If I do all these invokes in a loop like in my reply above, it comes back with a memory read error. I have tried using ADDR,  the loading the pointer to EDI and using  PANEL_CONTROL PTR, and it still says memory read error with the PUSHAD and POPAD removed...<br /><br />if they are left in (PUSHAD and POPAD), program goes into a vicious loop and I have to remove it with the task manager.</div>
    <div class="meta">Posted on 2001-09-10 18:56:49 by drarem</div>
   </div>
   <div class="post" id="post-6799">
    <div class="subject"><a href="#post-6799">code + helllppp: to ADDR or not to ADDR</a></div>
    <div class="body">I don't see how the code you posted could exit? Where does <strong>pntr</strong> get incremented?  Also, this kind of code is begging for the <em>assume</em> directive!  Also, look at the use of <strong>Pc_Size</strong>.  Just offering another view...<pre><code>PANEL_CONTROL struct DWORD<br />	PcPb dd ?<br />	PcPq dd ?<br />	PcPt dd ?<br />	PcX1 dd ?<br />	PcY1 dd ?<br />	PcX2 dd ?<br />	PcY2 dd ?<br />PANEL_CONTROL ends<br /><br />Pc PANEL_CONTROL &lt;&gt;,&lt;&gt;,&lt;&gt;,&lt;&gt;<br />Pc_Size = sizeof Pc / type Pc<br /><br />.code<br /><br />Draw_Panel_Command PROC hWnd&#58;HWND <br />	LOCAL pntr&#58;DWORD <br /><br />	xor eax,eax <br />	mov pntr, 0 <br /><br />	assume edx&#58;PTR PANEL_CONTROL<br />	.Repeat <br />		mov eax, &#91;sizeof PANEL_CONTROL&#93; <br />		mul pntr<br />		lea edx, &#91;Pc + eax&#93;<br />		invoke PushButton, &#91;edx&#93;.PcPt, hWnd, &#91;edx&#93;.PcX1, &#91;edx&#93;.PcY1, \<br />			&#91;edx&#93;.PcX2, &#91;edx&#93;.PcY2, &#91;edx&#93;.PcPq<br />		inc pntr<br />	.Until pntr &gt;= Pc_Size<br />	assume edx&#58;NOTHING<br />	ret<br />Draw_Panel_Command ENDP</code></pre></div>
    <div class="meta">Posted on 2001-09-10 20:06:38 by bitRAKE</div>
   </div>
   <div class="post" id="post-6809">
    <div class="subject"><a href="#post-6809">code + helllppp: to ADDR or not to ADDR</a></div>
    <div class="body">well welll, don't know why it worked but it worked  :)<br /><br />I did have the ADD PNTR, 28 coded, just I removed it accidentally when I posted it to this board when I was cleaning up comments to make it more readable... <br /><br />guess I can't do a:   lea edx,  <br />while incrementing pntr every 28 bytes (size of Pc)  ?<br />I don't see why I can't, if the indexes can be hardcoded then why can't I add 28 to pntr every loop it makes and do that lea?<br /><br /><br />I'll put reads on everything and look at the edx, eax, etc to see where i went wrong<br /><br /><br />thanks again bitRake!!!</div>
    <div class="meta">Posted on 2001-09-10 21:20:05 by drarem</div>
   </div>
   <div class="post" id="post-6813">
    <div class="subject"><a href="#post-6813">code + helllppp: to ADDR or not to ADDR</a></div>
    <div class="body">could do:<pre><code>Draw_Panel_Command PROC hWnd&#58;HWND <br />	LOCAL pntr&#58;DWORD, count&#58;DWORD<br /><br />	mov pntr, offset Pc<br />	mov count, 0<br /><br />	assume edx&#58;PTR PANEL_CONTROL<br />	.Repeat<br />		mov edx, pntr<br />		invoke PushButton, &#91;edx&#93;.PcPt, hWnd, &#91;edx&#93;.PcX1, &#91;edx&#93;.PcY1, \<br />			&#91;edx&#93;.PcX2, &#91;edx&#93;.PcY2, &#91;edx&#93;.PcPq<br />		add pntr, &#91;sizeof PANEL_CONTROL&#93;<br />		inc count<br />	.Until count &gt;= Pc_Size<br />	assume edx&#58;NOTHING<br />	ret<br />Draw_Panel_Command ENDP</code></pre></div>
    <div class="meta">Posted on 2001-09-10 21:32:00 by bitRAKE</div>
   </div>
  </div>
 </body>
</html>