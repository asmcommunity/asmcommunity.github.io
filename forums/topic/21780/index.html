<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Generic Programming in Assembly - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=21780" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=21780">Generic Programming in Assembly</a></p>
   <div class="post" id="post-164366">
    <div class="subject"><a href="#post-164366">Generic Programming in Assembly</a></div>
    <div class="body">Hello all,<br /><br />I&#39;m not sure how well received this sort of thing would be in assembly but I&#39;ve been putting together some generic data structures and algos using FASMs very powerful macro systems.<br /><br />That way it works is that you write code for say a linked list and instead of trying to make it reusable by having node contain pointer to the data they hole, instead the data is stored directly in with the node and the templates generate different functions specific for each type of data.<br /><br />The real advantage of this is in algorithms where instead of relying on callbacks functions to deal with different data types the macros generate a specific version of the algorithm for each type of data. This avoids the overhead of callbacks which can be particularly bad because they require indirect calls (well I think they do).<br /><br />The problem is though that I’ve had to make too many design decisions, and quite frankly I’m just not experienced enough to be making them. So while I’m not abandoning this little project, I’m just not sure how much further I can take myself.<br /><br />I encourage people to check out the quick <a target="_blank" href="http://student.dcu.ie/~ocallae3/index.html">webpages</a> I’ve put together, in particular read the <a target="_blank" href="http://student.dcu.ie/~ocallae3/design.html">design decisions</a> page which describes some of the problems I’ve come across.<br /><br />Also look at the source and ask questions about what is going on internally because I haven’t documented that yet.<br /></div>
    <div class="meta">Posted on 2005-09-08 12:59:13 by Eóin</div>
   </div>
   <div class="post" id="post-164374">
    <div class="subject"><a href="#post-164374">Re: Generic Programming in Assembly</a></div>
    <div class="body">I am just wondering, are you going to put in place ADT like queues, priority queues, etc etc. By the way, your code do look very c++ish.&nbsp; ;)</div>
    <div class="meta">Posted on 2005-09-08 21:59:57 by roticv</div>
   </div>
   <div class="post" id="post-164386">
    <div class="subject"><a href="#post-164386">Re: Generic Programming in Assembly</a></div>
    <div class="body">Hello roticv,<br /><br />Yes I’m sure everything does look like C++, but I’m not trying to hide the fact that I was motivated by C++’s STL and adopted its names for alot of things.. <br /><br />I think most people will agree that assembly needs some sort of standard library with prewritten data structures and algorithms. While nothing will be best in all situations, there is a best for a lot of situations. If that is already implemented and tested then new programmers will and indeed most programmer will find their lives a bit easier.<br /><br />The problem with writing a one data structure fits all is as I&#39;ve explained is that it tends to overly rely on pointers and callbacks which needlessly bloat and slow things down. This generic technique with macros tries to avoid that, but it does have its own problems as I’ve mentioned above.<br /><br />So to answer your question, will I be implementing more advanced types? I would like to but amn&#39;t sure if I will. Thing is that I don’t consider myself qualified or experienced enough to be making the though decisions I&#39;ve described above. And if the wrong choices are made there the rest of the work could but made redundant. <br /><br />That is why I posted this so early in this development, I need some help or advice on it.<br /></div>
    <div class="meta">Posted on 2005-09-09 07:10:37 by Eóin</div>
   </div>
   <div class="post" id="post-164538">
    <div class="subject"><a href="#post-164538">Re: Generic Programming in Assembly</a></div>
    <div class="body">Its safe to bet that not many people are interested in this. Perhaps I’m not surprised, it does seem very HLL.<br /><br />I wonder though is there a better way of writing a reusable library of data structures and algos? Almost every program needs some sort of dynamic array or a means of connecting keys to some sort of data through an associative map of some type. Well at least all of my programs seem to need those things.<br /><br />I can’t think of a good way to implement such things which will be reusable.</div>
    <div class="meta">Posted on 2005-09-14 12:54:15 by Eóin</div>
   </div>
   <div class="post" id="post-164540">
    <div class="subject"><a href="#post-164540">Re: Generic Programming in Assembly</a></div>
    <div class="body">My approach is to keep my own source code lib and do &quot;copy+paste&quot; but that&#39;s too betov and probably not acceptable by most. The problem with code reusing is that you are trading it off for speed and size which is essentially what coding in assembly is about.<br /><br />Maybe we can get a library of graph algorithms and so on. Haha. </div>
    <div class="meta">Posted on 2005-09-14 13:05:45 by roticv</div>
   </div>
   <div class="post" id="post-164541">
    <div class="subject"><a href="#post-164541">Re: Generic Programming in Assembly</a></div>
    <div class="body">It is of course true that a trade off can&#39;t really be helped. But as assembly is becoming more popular there is surely a need for well written and tested code libraries (not that I&#39;m suggesting what I wrote above is either of the two :) ). <br /><br />Even a source library would be difficult to make easily reusable for a varity of type unless you enforce some limitations on yourself which will probably sacrifice size and speed too. The macro method is kinda a source library isn&#39;t? Just one whos insides don&#39;t have to be understood if you don&#39;t want to.</div>
    <div class="meta">Posted on 2005-09-14 13:25:47 by Eóin</div>
   </div>
   <div class="post" id="post-164548">
    <div class="subject"><a href="#post-164548">Re: Generic Programming in Assembly</a></div>
    <div class="body">Yes, you are correct. Personally I support your project (seems like I am the only one interested), but I do not exactly know how to answer your question on whether your decision is right or wrong.</div>
    <div class="meta">Posted on 2005-09-14 23:19:31 by roticv</div>
   </div>
   <div class="post" id="post-164553">
    <div class="subject"><a href="#post-164553">Re: Generic Programming in Assembly</a></div>
    <div class="body">It&#39;s an interesting project - I have a set of MASM macros that do the vector stuff, and they prove very handy. <br />Though, I have 3 types of &quot;predefined&quot; vectors (realized as OOP objects) : <br />ObjVector (most often used) -&nbsp; holds dword values, most often pointers or handles<br />has a &quot;foreach&quot; macro - thread-safe, and foreach-like macros (both thread-safe and not)<br /><br />HookVector - extremely useful for callbacks. Here objects register themselves for events, instead of the event procedure sending the event to all objects created. <br />has a &quot;CallHooks:Param1,Param2&quot; method for event processing<br /><br />VarVector - holds objects of arbitrary size (each object can have a different size), has a &quot;foreach2&quot; macro. Created it on request of my OOP-model users.<br /><br /><br />The first two vectors prove very efficient in making (large) software quickly and safe. <br />The TDword-template probably will be the most often used, I think. Maybe adding qsort/heapsort proc with a custom callback function (for custom compare) could be good - especially when using pointers </div>
    <div class="meta">Posted on 2005-09-15 04:22:49 by Ultrano</div>
   </div>
   <div class="post" id="post-164560">
    <div class="subject"><a href="#post-164560">Re: Generic Programming in Assembly</a></div>
    <div class="body"><div class="quote">I think. Maybe adding qsort/heapsort proc with a custom callback function (for custom compare) could be good - especially when using pointers</div><br /><br />That exact thing is what prompted me to try this generic approach. I have written two QuickSort/Insertion Sort hybrids. One which operates directly on DWORDs in an array. The second uses a callback function for comparing two elements. When run on the same array of dwords the callback method runs close to 2.5 times slower. <br /><br />So I decided that since callbacks are too slow, and that rewriting a quicksort for each and every data type would be too awkard that maybe an approach with macros generating code for different data types would be a nice comprimise. Its very trick to do though.</div>
    <div class="meta">Posted on 2005-09-15 07:56:37 by Eóin</div>
   </div>
  </div>
 </body>
</html>