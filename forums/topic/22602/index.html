<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>BSP from XFILE - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=22602" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=22602">BSP from XFILE</a></p>
   <div class="post" id="post-169541">
    <div class="subject"><a href="#post-169541">BSP from XFILE</a></div>
    <div class="body">I&#39;ve started recoding my BSP generator.<br />This version imports directly from XFile.<br /><br />The attached demo is an XFile-to-BSP converter tool.<br />You can&#39;t save the output yet, so don&#39;t bother trying.<br /><br />So far it imports geometry from an XFile (collapsing the scene hierarchy if any), checks that all referenced textures are available (in the same folder as the xfile), calculates an array of unique Planes from the Face data, and marks each imported Face with the index of its Plane.<br />Then it will examine the set of imported faces to determine if the set is concave, convex, or neither.<br />A Concave set of triangles &quot;all face toward each others plane&quot;, while a Convex set of triangles &quot;all face away from each others plane&quot;.<br />In both of these cases, no plane exists which divides the set of faces, and therefore no (further) BSP sorting is possible.<br />During generation of the nodes of a BSP Tree, this test for 100% concavity/convexity is the first test we apply, and so it is the first test which I have coded.<br />The demo does not generate a BSP Tree, it simply performs the first test apon the entire set of imported faces.<br /><br />If you are interested and want to see the source, ask and you shall receive.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1381" target="_blank">BSPGenerator.rar</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-01-14 21:53:56 by Homer</div>
   </div>
   <div class="post" id="post-169542">
    <div class="subject"><a href="#post-169542">Choosing the Best Splitter Plane</a></div>
    <div class="body">Moving right along, here&#39;s an updated version of the BSP tool.<br /><br />This time, I have added the most important function of all.<br />Its name is ChooseBestDividingPlane.<br />Given a set of faces, the function performs an exhaustive (and thus slow) search for the Face whose Plane best matches the following two (mutually exclusive) criteria:<br />- the Face&#39;s Plane must cut (split) the fewest other Faces.<br />- the Face&#39;s Plane must divide the other Faces most equally on either of its sides.<br /><br />The first thing that ChooseBestDividingPlane does is perform the concavity/convexity test outlined in the previous posting. If the set of faces is found to be concave or convex, it returns EAX=NULL.<br />Otherwise, every Face is compared to every other Face, while some heuristics are maintained in order to find the Face which is &quot;best&quot; according to the criteria outlined above, and it returns EAX=pointer to Best Face and EBX=index of Best Face.<br /><br />In order to generate a BSP Tree, we select the best dividing face as outlined above, and then divide the remaining faces into two sublists, adding extra faces due to Splitting where necessary.<br />This process is then repeated for each sublist, until division becomes impossible.<br /><br />Therefore, this ChooseBestDividingPlane function is really at the heart of the BSPGenerator, and is vital in order to generate a well-balanced tree with the fewest possible splits (&quot;the best tree&quot;).<br /><br />The attached version of the tool chooses the best splitter from the entire set of faces, that&#39;s all folks.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1382" target="_blank">BSPGenerator_B.rar</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-01-15 00:46:29 by Homer</div>
   </div>
   <div class="post" id="post-169543">
    <div class="subject"><a href="#post-169543">Re: BSP from XFILE</a></div>
    <div class="body">Hi Homer,<br /><br /><div class="quote">If you are interested and want to see the source, ask and you shall receive.</div><br /><br />Sure I am intersested to see the source. Could you attach it?<br /><br />But I have a problem running the given executables.<br />Both of them produce the complaint that d3dx9_28.dll is not installed, and that I should install it first.<br /><br />On my computer DirectX 9.0 SDK (Oktober 2005) is installed.<br />Isn&#39;t this enough?<br /><br />Friendly regards,<br />mdevries.<br /><br /></div>
    <div class="meta">Posted on 2006-01-15 02:29:26 by mdevries</div>
   </div>
   <div class="post" id="post-169546">
    <div class="subject"><a href="#post-169546">Re: BSP from XFILE</a></div>
    <div class="body">I built this using the DECEMBER 2005 updated libs.<br />I suggest you update your DX9 runtimes, we don&#39;t want to live in the past, do we?<br /><br />Attached are the main .asm file, the main .inc, and the ChooseBestDividingPlane code.<br />This is not ALL of the code required to build the project.<br /><br />The missing files include the Vec4Collection class and my &quot;PointsPlanesEtc&quot; include which contains most of the math and primitive classification functions.<br />The Vec4Collection class implements an array of unique Vec4&#39;s used to store Planes.<br />It is guaranteed to ONLY store unique Planes.<br /><br />Probably most interesting to you will be the main .asm file, which shows how to get D3D9 fired up for Windowed mode (it just uses the desktop&#39;s pixelformat and the appwindow&#39;s resolution).<br />No code for rendering is provided, we don&#39;t want to render anything here, just wanna use DX functionality to help us rip the XFile data. I only bothered firing up D3D at ALL because the XFile loading function requires it.<br /><br />If you want ALL the files, ask again, noting that this is a work in progress and that these files are subject to change without notification ;)<br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1383" target="_blank">BSPGenerator.rar</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-01-15 03:47:41 by Homer</div>
   </div>
   <div class="post" id="post-169547">
    <div class="subject"><a href="#post-169547">Re: BSP from XFILE</a></div>
    <div class="body">Hi Homer,<br /><br /><div class="quote">I built this using the DECEMBER 2005 updated libs.<br />I suggest you update your DX9 runtimes, we don&#39;t want to live in the past, do we?</div><br /><br />I will update the DX9 runtimes.<br /><br /><div class="quote">If you want ALL the files, ask again, noting that this is a work in progress and that these files are subject to change without notification </div> <br /><br />I understand that the files are subject to change.<br />But at the moment, they represent the actual state of the project, and they help building the project, which is very useful.<br />So, I am interested in ALL the files.<br /><br />Friendly regards,<br />mdevries.<br /></div>
    <div class="meta">Posted on 2006-01-15 07:50:41 by mdevries</div>
   </div>
   <div class="post" id="post-169550">
    <div class="subject"><a href="#post-169550">Re: BSP from XFILE</a></div>
    <div class="body">I&#39;ve added code to divide the faces into face subsets as directed by the AttributeTable.<br />ChooseBestDividingPlane was modified into ChooseBestDividingPlaneFromSubSet, and a new ChooseBestDividingPlaneFromSet was added.<br />A new class, SubSetManager was added.<br />Its job is to manage a Collection of Face SubSets, and ChooseBestDividingPlaneFromSet expects to be handed a SubSetManager instance.<br /><br />Sorting the faces into subsets at load time is a good idea, even if it does make the processing of faces in the BSPTree generation slightly more difficult. If we keep the faces in separate subsets, texture thrashing will be reduced during the bsptree rendering process... not only can we draw all faces within a bsp leaf, we can draw them as subsets - and this gives us a mechanism to selectively disable entire subsets if we want to. By maintaining N subsets at the Node level, we have avoided being forced to mark each Face with a subset identifier, and we have eliminated any code which accesses that field, and we have eliminated sorting of faces&nbsp; by subset at the end of the tree generation (to cope with new faces that were created from splitting of faces during tree generation).<br /><br /><br />ChooseBestDividingPlaneFromSet finds the best divider from N subsets, and stores the results in a temporary collection. If there&#39;s more than one result, ChooseBestDividingPlaneFromSet then finds the best divider from the results.<br />In other words, candidates are selected from each subset and then the candidates are whittled down to one winner.<br /><br />Attached is the updated binary + full source.<br />If I missed any files, yell at me :)<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1384" target="_blank">BSPGenerator.rar</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-01-15 10:52:07 by Homer</div>
   </div>
   <div class="post" id="post-169604">
    <div class="subject"><a href="#post-169604">Re: BSP from XFILE</a></div>
    <div class="body">In my constant search for perfection, sometimes I overlook the obvious.<br />I believe I have been approaching this the wrong way.<br />Supporting face subsets during the bsptree sorting phase is undesirable... saving a few bytes of memory at the expense of higher complexity and slower execution is not desirable during the most computationally expensive phase.<br />Therefore, I have reverted to the original version of the source, with a few changes backported from the more recent source.<br />Faces are now marked with pPlane, rather than iPlane.<br />AttributeRanges are tracked during the extraction of Faces, and so Faces are marked with pMaterial as dictated by the AttributeID of the AttributeRange each Face belongs to.<br />Finally, Faces are now Stored in a DwordCollection rather than a DataCollection.<br />The reason is that this vastly simplifies the process of actually segregating the input list of faces into two sublists, although it means that we must provide our own code to clean up the collection where required.<br /><br />A DwordCollection and a DataCollection are similar, but quite different.<br />DataCollection stores an array of Pointers to allocated structs (&quot;memory objects&quot;).<br />It automatically releases the memory of objects removed from the collection.<br />DwordCollection stores an array of arbitrary dwords (which in our case happen to be Pointers).<br />It is totally naive as to the nature of the dwords it contains, and does not clean anything up when dwords are removed from the collection.<br />Since we want to be able to remove stuff from one collection and shove it into another one WITHOUT releasing anything, DwordCollection becomes the logical choice, noting that we must now take FULL responsibility for our data.<br /><br />We can still sort the Faces in each BSPLeaf by Material at the end of the tree generation.<br />I&#39;ll live with that if it means that the processing speed is improved.<br />GENERATING A BSPTREE IS SLOW, and we should do everything within our power to speed it up.<br />I thought about creating a large lookup table of the results of comparing each face to the plane of each other face, but decided that is unrealistic for large meshes as the memory required is quite great.. and storing the LUT to disk for dynamic access is not an option, since disk access times are greater than the time required to perform a single comparison.<br />I&#39;ll be keeping my eye open for other potential optimisations.<br /><br /></div>
    <div class="meta">Posted on 2006-01-17 01:42:54 by Homer</div>
   </div>
   <div class="post" id="post-169661">
    <div class="subject"><a href="#post-169661">Re: BSP from XFILE</a></div>
    <div class="body">Attached is an update of the BSP tool.<br />This version actually generates a BSPTree, and has a crappy gui so you can watch it working without having DebugCenter installed (detailed information is spewed to debug output).<br />It handles both convex and concave meshes, and has been tested so far with 600 and 6000 triangle meshes.<br />What it currently does NOT do is split triangles which are cut by the dividing plane.<br />Also, I have yet to implement code to save the BSPTree to disk, I&#39;ll do that LAST.<br />I must solve the triangle splitting problem before even thinking about disk format, because right now faces which are to be split are simply disregarded, and thus are filtered from the tree, which is a Bad Thing.<br /><br />Here is some pseudocode I threw together for performing the splitting of triangles.<br />It takes one input face and returns two or three output faces.<br />It does NOT calculate UV coordinates in regards to the new vertices created at the intersections of edges and the plane. So far, the entire project has been written to be &quot;fvf-naive&quot; - that is to say, it has no understanding of the vertex format, except for knowing how large vertices are in terms of #bytes per vertex.<br /><br />If anyone wants to have a go at optimizing the pseudocode in any way, please post your work!!<br /><br /><pre><code><br />;Name 	 - SplitFace<br />;Purpose - Split a triangular Face into two or three triangular Faces<br />;pFace = pointer to Face to be split<br />;pPlane = pointer to splitting plane<br />;pFrontCollection = Collection to receive Front output faces<br />;pBackCollection = Collection to receive Back output faces<br />;dwSplitType = how to split the triangle<br />;(we determined SplitType in DivideFaces function)<br />SplitFace proc pFace, pplane, pFrontCollection, pBackCollection,dwSplitType<br />LOCAL RawTriangle:Triangle<br />LOCAL p1Classified<br />LOCAL p2Classified<br />LOCAL p3Classified<br />LOCAL fDist1<br />LOCAL fDist2<br />LOCAL fDist3<br /><br />;First thing to do : obtain raw vertices (Points) of triangle face<br />invoke ConvertIndexedTriangleToRaw,addr RawTriangle,pFace,pVertices,dwNumBytesPerVertex<br />;Now classify each of the Points against the Plane (again)<br />;This time we are interested in exactly where each Point lays<br />;with respect to both the plane AND each other...<br />mov numOnPlane,0<br />invoke ClassifyPointPlane,addr RawTriangle.Point1,pPlane<br />fstp fDist1<br />mov p1Classified,eax<br />;<br />invoke ClassifyPointPlane,addr RawTriangle.Point2,pPlane<br />fstp fDist2<br />mov p2Classified,eax<br />;<br />invoke ClassifyPointPlane,addr RawTriangle.Point3,pPlane<br />fstp fDist3<br />mov p3Classified,eax	<br />	<br />;——————————————————————————————————————————————————————————————————————————————————————————————————	<br />.if dwSplitType==ONEFRONTTWOBACK<br />	;Cases of OneFrontTwoBack<br />	;One point is on the Front side of the Plane,<br />	;and the other two points are on the Back side.<br />	;So.. which point is on the Front side?<br />	;<br />	;p1 front, p2p3 back<br />	.if 	p1Classified==INFRONT &amp;&amp; p2Classified==BEHIND&nbsp; &amp;&amp; p3Classified==BEHIND<br />		;p1=Point1, p2=Point2, p3=Point3		<br />		;i1=intersection(p1p2)<br />		;i2=intersection(p3p1)<br />		;front+=tri(p1i1i2)<br />		;Back+=tri(i1p2p3)<br />		;Back+=tri(i1p3i2)<br />		<br />	;p2 front, p1p3 back<br />	.elseif p1Classified==BEHIND&nbsp; &amp;&amp; p2Classified==INFRONT &amp;&amp; p3Classified==BEHIND<br />		;p1=Point2,p2=Point3, p3=Point1<br />		;i1=intersection(p1p2)<br />		;i2=intersection(p2p3)		<br />	<br />	;p3 front, p1p2 back<br />	.elseif p1Classified==BEHIND&nbsp; &amp;&amp;&nbsp; p2Classified==BEHIND &amp;&amp; p3Classified==INFRONT<br />		;p1=Point3,p2=Point1,p3=Point2<br />		;i1=intersection(p2p3)<br />		;i2=intersection(p3p1)<br />		<br />	.else<br />		jmp UnhandledCase<br />	.endif<br />	<br />;——————————————————————————————————————————————————————————————————————————————————————————————————<br />.elseif dwSplitType==TWOFRONTONEBACK<br />	;Cases of TwoFrontOneBack<br />	;One point is on the Back side of the Plane,<br />	;and the other two points are on the Front side.<br />	;So.. which point is on the Back side?<br />	;	<br />	;p1p2 front, p3 back<br />	.elseif	p1Classified==INFRONT &amp;&amp; p2Classified==INFRONT &amp;&amp; p3Classified==BEHIND		<br />		;p1=Point1, p2=Point2, p3=Point3<br />		;i1=intersection(p2p3)<br />		;i2=intersection(p3p1)<br />		;front+=tri(p1p2i1)<br />		;Back+=tri(i1p3i2)<br />		;Front+=tri(i2p1i1)<br />		<br />	;p1p3 front, p2 back<br />	.elseif p1Classified==INFRONT &amp;&amp; p2Classified==BEHIND&nbsp; &amp;&amp; p3Classified==INFRONT<br />		;p1=Point3, p2=Point1, p3=Point2<br />		;i1=intersection(p1p2)<br />		;i2=intersection(p2p3)		<br />		;Same algo as above<br />	<br />	;p2p3 front, p1 back<br />	.elseif p1Classified==BEHIND&nbsp; &amp;&amp; p2Classified==INFRONT &amp;&amp; p3Classified==INFRONT<br />		;p1=Point2, p2=Point3, p3=Point1<br />		;i1=intersection(p3p1)<br />		;i2=intersection(p1p2)		<br />		;Same algo as above<br />	<br />	.else<br />		jmp UnhandledCase<br />	.endif<br /><br />;——————————————————————————————————————————————————————————————————————————————————————————————————	<br />;——————————————————————————————————————————————————————————————————————————————————————————————————	<br />.elseif dwSplitType==ONEEACHSIDE<br />EachSideCases:<br />	;Cases of OneEachSide<br />	;We have one point laying smack dab on the plane,<br />	;and the other two points lay either side of the plane.<br />	;<br />	;p1 on plane, p2p3 on different sides<br />	.if 	p1Classified==COINCIDING<br />		;i1=intersection(p2p3)<br />		;tri1=tri(p1p2i1)<br />		;tri2=tri(i1p3p1)	<br />		.if (p2Classified==FRONT &amp;&amp; p3Classified==BEHIND)<br />		;Front+=tri1<br />		;Back+=tri2<br />		.elseif (p2Classified==BEHIND &amp;&amp; p3Classified==FRONT)<br />		;Front+=tri2<br />		;Back+=tri1<br />		.endif<br />	;p2 on plane, p1p3 on different sides<br />	.elseif	p2Classified==COINCIDING <br />		;i1=intersection(p3p1)<br />		;tri1=tri(p1p2i1)<br />		;tri2=tri(i1p2p3)<br />		<br />		.if (p1Classified==FRONT &amp;&amp; p3Classified==BEHIND)<br />		;Front+=tri1<br />		;Back+=tri2<br />		.elseif (p1Classified==BEHIND &amp;&amp; p3Classified==FRONT)<br />		;Front+=tri2<br />		;Back+=tri1<br />		.endif<br />	;p3 on plane, p1p2 on different sides<br />	.elseif p3Classified==COINCIDING <br />		;i1=intersection(p1p2)<br />		;tri1=tri(p1i1p3)<br />		;tri2=tri(i1p2p3)<br />		.if (p1Classified==FRONT &amp;&amp; p2Classified==BEHIND)<br />		;Front+=tri1<br />		;Back+=tri2<br />		.elseif (p1Classified==BEHIND &amp;&amp; p2Classified==FRONT)<br />		;Front+=tri2<br />		;Back+=tri1<br />	.elseif<br />	return TRUE<br /><br />.endif<br />UnhandledCase:<br />		DbgWarning &quot;SplitFace : Unhandled Case&quot;<br />		DbgDec dwSplitType		<br />		DbgDec p1Classified<br />		DbgDec p2Classified<br />		DbgDec p3Classified<br />		return FALSE<br />SplitFace endp<br /></code></pre><br /><br />As usual, full updated source is available apon request.<br />I&#39;m not going to post it if nobody gives a crap.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1401" target="_blank">BSPGenerator.rar</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-01-18 09:27:59 by Homer</div>
   </div>
   <div class="post" id="post-170101">
    <div class="subject"><a href="#post-170101">Re: BSP from XFILE</a></div>
    <div class="body">I&#39;ve revised my BSPGenerator code yet again.<br />This time, I&#39;ve incorporated the &quot;convexity test&quot; within the &quot;FindBestSplitter&quot; function, which speeds up the generator immensely. I&#39;ve also found two other major speedups which involve tagging any Faces that are coplanar with the splitting plane to prevent them from being considered as candidate Splitters in future iterations. Also, I&#39;m now throwing splitter faces down the Tree in order to generate a &quot;Leafy Tree&quot; as used in Quake etc. I&#39;ve improved the heuristics used to select splitter planes. I&#39;ve streamlined the memory accesses to handle massive worlds, eliminating &quot;illegal pointers&quot; caused by memory reallocation.<br /><br />The algorithms involved have been and will continue to be refined until I am absolutely satisifed that they are as fast as they possibly can be without sacrificing stability.<br /><br />I am considering extending the existing functionality to include &quot;CSG&quot; , ie, realtime construction of geometry via boolean operations applied to convex primitives.<br /><br />I would have attached a binary executable to show you, but the Board is still a little wiggy..&quot;An Error Has Occurred! <br />Cannot access attachments upload path!&quot;<br /><br />If you are interested in the source, are interested in becoming involved in betatesting, or think you might be able to contribute in some other way, please let me know.<br /></div>
    <div class="meta">Posted on 2006-02-28 23:29:43 by Homer</div>
   </div>
   <div class="post" id="post-170103">
    <div class="subject"><a href="#post-170103">Re: BSP from XFILE</a></div>
    <div class="body">Hi Homer<br />I’ll be glad to take a look into the source code. <br />My interest focus lays in first place on the code construction and in second place the logic you have used.<br /><br />Regards,<br /><br />Biterider<br /></div>
    <div class="meta">Posted on 2006-03-01 00:42:07 by Biterider</div>
   </div>
   <div class="post" id="post-170108">
    <div class="subject"><a href="#post-170108">Re: BSP from XFILE</a></div>
    <div class="body">Cool, I&#39;ll send you source directly when I see you online next.. I found another three optimizations at the algorithmic level today :D<br /><br />A guy called Nathan Whitaker wrote a tutorial on BSPTree construction for Leafy Trees in which he said something along the lines of &quot;so now that we&#39;re no longer storing Faces at the Nodes of the tree, what do we do with the Faces we used to form Splitting Planes? We throw them down the Tree like any other face, marking them so we don&#39;t use them again&quot;..<br /><br />It got me thinking : yeah, ok, but what about any OTHER faces that happen to be coplanar with the splitting plane? Is this not true of those faces also?<br /><br />Now I&#39;ve made the whole thing smarter, because I&#39;ve realized that &quot;all coplanar faces, including the splitterface, can be distributed any way we like&quot; - that means in many cases the balance of faces can be improved or even perfected, and that a set of faces that is &quot;totally coplanar&quot; is in fact &quot;convex&quot;, and can be treated as such.<br /><br />You&#39;ll have to excuse the fact that I&#39;ve disabled and/or removed code relating to the handling of &quot;split faces&quot; due to my preoccupation with improving the two main algorithms (choosing a splitting plane, and distributing the faces either side of it).<br /><br /></div>
    <div class="meta">Posted on 2006-03-01 08:00:55 by Homer</div>
   </div>
   <div class="post" id="post-170182">
    <div class="subject"><a href="#post-170182">Re: BSP from XFILE</a></div>
    <div class="body">back to terrainengines:<br />if you instead construct terrain more object oriented, outta hill1,hill2 ,valley1,valley2, etc, instead of heightmaps<br />and do that in combination of using BSP tree&#39;s if you can see Hill1, but Hill2 is hidden and so is valley2 etc<br /><br />for example a small terrainarea is composed outta Hill1-4 and valley1-2 and leveled plain 1-4 and stonebridge&nbsp; 5<br />instead of load heightmap, you instead load the objects not yet in memory before entering this area<br />now why not use BSP tree twice? one time for visible surfaces to render, and one time for determine readahead objects on disk.<br />must be less diskload when you use Hill1 instanced several times and no diskload if it already been used in previous terrain<br />now maybe we even can use BSP a third time, to determine the stonebridge you left far behind you is time to release that object to free up space for other objects that need to be readahead<br /><br />what I understood, you are climbing around in that BSP tree and current node is where you are, neighbouring nodes are what needs to be read, farthest away nodes is what need to be released<br />???<br /></div>
    <div class="meta">Posted on 2006-03-04 05:10:28 by daydreamer</div>
   </div>
   <div class="post" id="post-170209">
    <div class="subject"><a href="#post-170209">Re: BSP from XFILE</a></div>
    <div class="body">I wrote a huge reply to this posting yesterday, but my videocard is crashing my machine intermittently (thermal fault), and I&#39;m too lazy to type all of it again, so here&#39;s the short version.<br /><br />BSPTrees split the world into ever-smaller pieces, where each piece is approximately half of the input.<br />The root node of a BSPTree cuts the world into halves, stored as two child nodes, and this process is repeated until a node contains a single face, a convex set of faces, or some other preset limit we imposed.<br /><br />There&#39;s basically two kinds of BSPTree, they are called Nodey and Leafy.<br /><br />Nodey trees have some geometry stored at the Nodes of the tree, whereas Leafy trees store ALL the geometry in the LEAFNODES of the tree.<br /><br />I&#39;m predominantly interested in Leafy Trees because of certain properties of the LeafNodes.. for example, each LeafNode represents a convex subspace defined by the planes of the Faces it contains and the planes of its Parent nodes.<br />Convex sets can be rendered in any order without causing error (no occlusions), which is cool, and LeafNodes represent &quot;places we can go&quot;.<br />The major error of your assumption is that we can travel from one leafnode to another by following the BSPTree.<br />The BSPTree has nothing to do with linking leafnodes together.<br />We need to create links between leafnodes ourselves, which are known as PORTALS.<br />Portals are &quot;the places where walls are not&quot;, ie &quot;holes&quot;.<br />We can discover them automatically.<br />One of the clues we are handed is the knowledge that &quot;portals can only exist on the planes of non-leaf bsp nodes&quot;.<br />Non-leaf nodes MAY contain Portals, but they may NOT.<br /><br />If you want more information regarding BSPTrees, and how they relate to passive culling and collision detection acceleration, let me know.<br /><br />The only other thing I really wanna say regarding your posting is that yeah, we can store an entire BSPTree on disk, and so long as we &quot;write the nodes in the same order as we normally walk them&quot;, we can walk the tree directly from disk at runtime, its not necessary to have the entire bsptree in memory at once.<br /></div>
    <div class="meta">Posted on 2006-03-05 23:06:50 by Homer</div>
   </div>
  </div>
 </body>
</html>