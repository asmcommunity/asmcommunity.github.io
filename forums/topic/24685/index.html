<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Help Optimizing a Function in MSVC++ 2005 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=24685" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=24685">Help Optimizing a Function in MSVC++ 2005</a></p>
   <div class="post" id="post-180371">
    <div class="subject"><a href="#post-180371">Help Optimizing a Function in MSVC++ 2005</a></div>
    <div class="body">I&#39;d like to ask several questions regarding assembly.&nbsp; I am a C++ student using MSVC++ 2005&#39;s inline __asm {} to learn the basics of assembly.<br />The code I&#39;m trying to optimize:<br /><pre><code>template&lt;class T&gt;<br />int CBinaryHeap&lt;T&gt;::moveUp(int index, int newKey)<br />{<br />&nbsp; register int current2 = index&gt;&gt;1;<br />&nbsp; while (index &gt; 1) {//while there is a parent to compare<br />&nbsp;  if (BinaryHeap.key &gt; newKey) {<br />&nbsp; &nbsp; BinaryHeap = BinaryHeap;//move parent down<br />&nbsp; &nbsp; index = current2;//on the next iteration, compare the parent<br />&nbsp; &nbsp; current2 &gt;&gt;= 1;//divided by 2, points to the parent of the parent<br />&nbsp;  }<br />&nbsp;  else {<br />&nbsp; &nbsp;  break;//we can stop comparing, we&#39;ve found the index to insert at<br />&nbsp;  }<br />&nbsp; }<br />&nbsp; return (index);<br />}//end moveUp</code></pre><br /><br />A Binary Heap is a sorted structure, basically a tree inside an array, and its indexs serve as pointers to tree members.&nbsp; To insert an element onto the heap, it is placed at the end of the array.&nbsp; The newly placed element is then iteratively compared with its parent node and filters up, the parent moving down each time.&nbsp; To avoid temporary objects and extra assignments, the insertion and moving up have been seperated into two functions.&nbsp; The new element is not actually placed on the binary heap until its index has been determined, and all its parents have moved down.&nbsp; I have implemented the binary heap to have one extra element.&nbsp; The root of the tree is at Heap[1], its two children are at 2 and 3, etc; this saves a bit of pointer calculation.&nbsp; The datatype of data&nbsp; and key is an int.<br /><br />In the moveUp function, index is the heapSize, the index of the last element - or where it would be placed if following the standard algorithm.&nbsp; Current2 is the parent, or index / 2.<br /><br />Now, the moveDown function, which is used when removing an element from the heap, is more complex.&nbsp; It needs to compare both children, and move down.&nbsp; Because the children are at index*2 and index*2+1 I wanted to optimize this.&nbsp; I found that I couldn&#39;t in C++, anything I did made it slower.&nbsp; So I tried rewriting moveDown in assembly, but again things were slower, this time much worse!&nbsp; So I tried rewriting moveUp in assembly because it was simpler.&nbsp; This too is slower than if I compiled with MSVC++.<br /><br />So I looked at how MSVC++ compiled the above, and I got this:<br /><pre><code><br />mov&nbsp; eax, dword ptr<br />sar&nbsp; eax, 1<br />mov&nbsp; dword ptr, eax<br /><br />while_current#1:<br />cmp&nbsp; dword ptr, 1<br />jle&nbsp; end#1;<br /><br />mov&nbsp; ecx, dword ptr;<br />mov&nbsp; edx, dword ptr;<br />mov&nbsp; eax, dword ptr;<br />mov&nbsp; ecx, dword ptr;<br />cmp&nbsp; ecx, dword ptr;<br />jle&nbsp; end#2;<br /><br />mov&nbsp; edx, dword ptr;<br />mov&nbsp; eax, dword ptr;<br />mov&nbsp; ecx, dword ptr;<br />mov&nbsp; edx, dword ptr;<br />mov&nbsp; eax, dword ptr;<br />mov&nbsp; ecx, dword ptr;<br />mov&nbsp; ecx, dword ptr;<br />mov&nbsp; esi, dword ptr;<br />mov&nbsp; dword ptr, edx;<br />mov&nbsp; dword ptr, eax;<br /><br />mov&nbsp; edx, dword ptr;<br />mov&nbsp; dword ptr, edx;<br />mov&nbsp; eax, dword ptr;<br />sar&nbsp; eax, 1;<br />mov&nbsp; dword ptr, eax;<br />jmp&nbsp; while_current#2;<br /><br />end#2:<br />jmp&nbsp; end#1;<br /><br />while_current#2:<br />jmp while_current#1;<br /><br />end#1:<br />mov&nbsp; eax, dword ptr</code></pre><br />I have a few questions as to how / why MSVC++ compiled it this way, but first my rewritten assembly, copy and pasting some of this code:<br /><pre><code><br />__asm {<br />mov&nbsp; ebx, index;<br />shr&nbsp; ebx, 1;<br /><br />while_current:<br />cmp&nbsp; index, 1;<br />jle&nbsp; end;<br /><br />mov&nbsp; ecx, dword ptr ;<br />mov&nbsp; edx, dword ptr ;<br />mov&nbsp; eax, ebx;<br />mov&nbsp; ecx, dword ptr ;<br />cmp&nbsp; ecx, dword ptr ;<br />jle&nbsp; end;<br /><br />mov&nbsp; edx, dword ptr ;<br />mov&nbsp; eax, dword ptr ;<br />mov&nbsp; ecx, ebx;<br />mov&nbsp; edx, dword ptr ;<br />mov&nbsp; eax, dword ptr ;<br />mov&nbsp; ecx, dword ptr ;<br />mov&nbsp; ecx, dword ptr ;<br />mov&nbsp; esi, dword ptr ;<br />mov&nbsp; , edx;<br />mov&nbsp; , eax;<br /><br />mov&nbsp; index, ebx;<br />shr&nbsp; ebx, 1;<br />jmp&nbsp; while_current;<br /><br />end:<br />}<br />return index;</code></pre><br />So a few things were changed that in my mind should yield extra performance<br />1 I removed the double jumps<br />2 I replaced current2 with ebx<br />3 I&#39;ve cut down some moves when assigning index = current; and current &gt;&gt;= 1;<br />4 Other changes, but this is the current state of my code and only includes things that really seem like they would work.<br /><br />However, after compiling my optimized code, it is slower by about 25 - 33%.<br />Now that you have all the information, here are my questions:<br /><br />1: Are there any multiplications or additions in statements like this: mov edx, ? I see many moves, with pointer arrithmetic, but I&#39;m not sure how much that move costs in ops. Or to put it another way, aren&#39;t there really 2 moves and an add in this: mov ecx, dword ptr ; mov edx, dword ptr ;?<br />2: Would it be any faster to store eax+ecx*8 in a free register, so that it can be reused on the next move?<br />3: Why the double jumps? It looks like it&#39;s to handle the break, but surely it could / should have been eliminated.<br />4: Could it possibly be that the code is slower because it doesn&#39;t know how to handle the assembly in templates?<br />5: Could it possibly be that the code is slower because with assembly there aren&#39;t any global optimizations being done? (this is where a profiler would help, but my trial edition doesn&#39;t seem to have this, I&#39;m just going by time)<br />6: Do you see any way you can improve on the MSVC++ assembly here, and/or are any of my optimizations improving or hurting?<br />7: I thought &#91;] means to load from the memory using the address stored inside the &#91;], so why is it doing things like mov edx, dword ptr ?<br />8: Where online can I find resources for AMD and Intel that show cost in cycles for ops, for up to date processors?<br />9: Would compiling in something like MASM32 be better than inlining?<br />10: How can I measure execution time in clocks rather than time?<br /><br />Thanks for your help!</div>
    <div class="meta">Posted on 2006-05-04 00:05:26 by aalaardb</div>
   </div>
   <div class="post" id="post-180373">
    <div class="subject"><a href="#post-180373">Re: Help Optimizing a Function in MSVC++ 2005</a></div>
    <div class="body"><br />Hello,<br /><br />I don&#39;t know the answer to all your questions but hopefully I can help.<br /><br />In answer to question 7, in masm doing mov reg,  is the same as mov reg, label<br /><br />You can get developer manuals as PDFs for free <a target="_blank" href="http://www.intel.com/design/pentium4/manuals/index_new.htm">here</a>. They can also be obtained as printed versions for free (though not at the moment, but soon) from <a target="_blank" href="http://developer.intel.com/design/pentium4/manuals/index2.htm">here</a>.<br /><br />Also, if you&#39;re a student, check out <a target="_blank" href="http://thespoke.net">thespoke.net</a> where you can register for a small fee (about £20 / €30) then you can download many Microsoft products for free, like Windows Server 2003, SQL Server, Visual Studio 2005 Professional (which has a profiler).<br /><br />And some general comments: this function seems too basic to be worth optimising tbh. Also, using inline asm can stop the compiler from doing other optimisations like inlining. And using the &quot;register&quot; keyword is not much use (and even discouraged i think) these days.<br /><br />hth</div>
    <div class="meta">Posted on 2006-05-04 05:28:45 by stormix</div>
   </div>
   <div class="post" id="post-180374">
    <div class="subject"><a href="#post-180374">Re: Help Optimizing a Function in MSVC++ 2005</a></div>
    <div class="body">I agree with Stormix, the function looks like it&#39;s too smal to be worth optimizing - you should probably focus your efforts elsewhere. And when you need the Assembly, it&#39;s often better to write an external .asm module instead of inline assembly (you need &quot;large&quot; blocks before it&#39;s worthwhile, and as Stormix pointed out, inline assembly can confuse some compilers).<br /></div>
    <div class="meta">Posted on 2006-05-04 05:34:00 by f0dder</div>
   </div>
   <div class="post" id="post-180381">
    <div class="subject"><a href="#post-180381">Re: Help Optimizing a Function in MSVC++ 2005</a></div>
    <div class="body">The goal of optimizing this is not a matter of effort/reward, but one of learning.&nbsp; Also, the available optimizations are better on the moveDOwn function, but I&#39;ve posted moveUp here for simplicity.</div>
    <div class="meta">Posted on 2006-05-04 16:00:24 by aalaardb</div>
   </div>
  </div>
 </body>
</html>