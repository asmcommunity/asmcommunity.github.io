<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>About the checking for the landing dialog - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25897" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25897">About the checking for the landing dialog</a></p>
   <div class="post" id="post-188826">
    <div class="subject"><a href="#post-188826">About the checking for the landing dialog</a></div>
    <div class="body">invoke&nbsp; &nbsp; GetWindowText,hEdit2,addr password,sizeof password<br />invoke&nbsp; &nbsp; lstrlen,addr password<br />.if&nbsp; &nbsp; eax<br />invoke&nbsp; &nbsp; lstrcmp,addr password,addr password1;compare your inputs with passwd1<br />.if&nbsp; &nbsp; eax != 0<br />invoke&nbsp; &nbsp; MessageBox,hDlg,CTXT(&quot;your inut is wrong&quot;),CTXT(&quot;please reinput&quot;),MB_ICONINFORMATION or MB_OK<br />invoke&nbsp; &nbsp; SetFocus,hEdit1;this is a edit control &#39;s handle<br />inc&nbsp; &nbsp; &nbsp; &nbsp; LandingNum&nbsp; &nbsp; ;use as count&nbsp; &nbsp; LandingNum???0 <br />mov&nbsp; &nbsp; &nbsp; &nbsp; eax,LandingNum<br />.if&nbsp; &nbsp; &nbsp; &nbsp; eax &lt;=3<br />mov&nbsp; &nbsp; &nbsp; &nbsp; flag,0<br />invoke&nbsp; &nbsp; SetWindowText,hEdit2,NULL<br />ret<br />.else<br />mov&nbsp; &nbsp; &nbsp; &nbsp; flag,0<br />invoke&nbsp; &nbsp; MessageBox,hDlg,CTXT(&quot;you have landed wrong of&nbsp; three times!&quot;),CTXT(&quot;thank for your landing!&quot;),MB_OK or MB_ICONINFORMATION<br />invoke&nbsp; &nbsp; _FreeRes,hDlg,hdback1,hbitback,hdc1,hbrBrush1<br />ret<br />.endif<br /></div>
    <div class="meta">Posted on 2007-04-13 20:50:10 by hero liu</div>
   </div>
   <div class="post" id="post-188827">
    <div class="subject"><a href="#post-188827">Re: About the checking for the landing dialog</a></div>
    <div class="body">My question are:<br />1,I can land two times in a wrong password ,But when i use the wrong password for the third landing ,the programe made a anomaly.<br />windows info:041f1a48h can&#39;t be writted,why?</div>
    <div class="meta">Posted on 2007-04-13 20:54:54 by hero liu</div>
   </div>
   <div class="post" id="post-188828">
    <div class="subject"><a href="#post-188828">Re: About the checking for the landing dialog</a></div>
    <div class="body"><div class="quote"><br />My question are:<br />1,I can land two times in a wrong password ,But when i use the wrong password for the third landing ,the programe made a anomaly.<br />windows info:041f1a48h can&#39;t be writted,why?<br /></div><br /><br />Start inserting breakpoints (such as RET) at various points in your code. Start by where the code *should* work, and move up or down from there. This is about the easiest form of troubleshooting/debugging that you can do.</div>
    <div class="meta">Posted on 2007-04-13 21:48:56 by SpooK</div>
   </div>
   <div class="post" id="post-188829">
    <div class="subject"><a href="#post-188829">Re: About the checking for the landing dialog</a></div>
    <div class="body">Can you attach your program?</div>
    <div class="meta">Posted on 2007-04-14 00:51:21 by roticv</div>
   </div>
   <div class="post" id="post-188840">
    <div class="subject"><a href="#post-188840">Re: About the checking for the landing dialog</a></div>
    <div class="body"><div class="quote"><br />invoke&nbsp; &nbsp; SetWindowText,hEdit2,NULL<br /></div><br /><br />BOOL SetWindowText(<br /><br />&nbsp; &nbsp; HWND hWnd,	// handle of window or control<br />&nbsp; &nbsp; LPCTSTR lpString 	// address of string<br />&nbsp;  );	<br /> <br />Parameters<br /><br />hWnd<br />Identifies the window or control whose text is to be changed. <br /><br />lpString<br />Points to a null-terminated string to be used as the new title or control text. <br /><br />----------------<br /><br />dont think &#39;NULL&#39; is allowed / accepted by send message<br /><br /><br />just a guess, without seeing the whole source its a bit tricky to find the problem </div>
    <div class="meta">Posted on 2007-04-14 13:26:43 by evlncrn8</div>
   </div>
   <div class="post" id="post-188879">
    <div class="subject"><a href="#post-188879">Re: About the checking for the landing dialog</a></div>
    <div class="body">setwindowtext (hwnd,lpsz)<br />it is&nbsp; current to set lpsz with &quot;null&quot;<br /><br /></div>
    <div class="meta">Posted on 2007-04-16 12:09:34 by hero liu</div>
   </div>
   <div class="post" id="post-188883">
    <div class="subject"><a href="#post-188883">Re: About the checking for the landing dialog</a></div>
    <div class="body">The whole source :<br />		.data<br />ClassName	db	&quot;login&quot;,0<br />WindowName	db	&quot;????&quot;,0<br />query			db	&quot;select password from login where name = ?&quot;,0<br />SQLAppStmt	db	&quot;insert into login (name,password) values (?,?)&quot;,0<br />strconnect	db	&quot;DRIVER={Microsoft Access Driver (*.mdb)};DBQ=&quot;,0<br />dbname		db	&quot;text.mdb&quot;,0	<br />zlc			db	&quot;?????????&quot;,0<br />connfail		db	&quot;Connection attempt failed&quot;,0<br />appname		db	&quot;ODBC Test&quot;,0<br />allocconnfail		db	&quot;Connection handle allocation failed&quot;,0<br />setattrfail			db	&quot;Cannot set desired ODBC version&quot;,0<br />allocenvfail		db	&quot;Environment handle allocation failed&quot;,0<br />ToolTipsClassName	db &nbsp;&quot;Tooltips_class32&quot;,0<br />szPath				db 	MAX_PATH dup(?)<br />szPath1				db 	MAX_PATH dup(?)<br />		.data?<br />hInstance	dd	?<br />hWinMain		dd	?<br />hwndTool		dd	?<br />hconn			dd	?<br />hsmt			dd	?<br />hEdit1		dd 	?<br />hEdit2		dd	?<br />henv			dd	?<br />strlen		dd	?<br />LandingNum	dd	?<br />connectstring	db	1024 dup(?)<br />progpath		db	256 dup(?)<br />conn			db	256 dup(?)<br />name1			db 6 	dup(?)<br />password1	db 6	dup(?)<br />hcmain		dd	?<br />hcmov			dd	?<br />buffer2lh	dd	?<br />namel			dd	?<br />passwordl	dd	?<br />flag			dd	?<br />hDlg1			dd	?<br />hdc1			dd	?<br />hdback1		dd	?<br />hbrBrush1	dd	?<br />hbrBrush2	dd	?<br />hbrBrush3	dd	?<br />hDlg2			dd	?<br />hdc2			dd	?<br />hdback2		dd	?<br />hWinToolbar	dd	?<br /><br />		MOVmw &nbsp; &nbsp;MACRO Var1, Var2<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lea &nbsp; &nbsp; esi, Var2<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lea &nbsp; &nbsp; edx, Var1<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;REPEAT &nbsp; &nbsp; 2<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; al, <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; , al<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; esi<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc &nbsp; &nbsp; edx<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ENDM<br /> &nbsp; &nbsp; &nbsp; &nbsp; ENDM<br />		RGB MACRO Blue,Green,Red<br />			xor eax,eax<br />			mov al,Blue<br />			shl eax,8<br />			mov al,Green<br />			shl eax,8<br />			mov al,Red<br />		ENDM<br />;**********************************************************************<br />;???????<br />		.code<br />WinMain	proc	<br />	local @stwc:WNDCLASSEX<br />	local	@stmsg:MSG<br />	local	@stRect:RECT<br />	local	Wtx:DWORD <br />	local	Wty:DWORD <br />	<br />	<br />	invoke	RtlZeroMemory,addr @stwc,sizeof @stwc<br />	mov &nbsp; 	@stwc.cbSize,SIZEOF WNDCLASSEX<br />	mov &nbsp; 	@stwc.style, CS_HREDRAW or CS_VREDRAW or CS_BYTEALIGNWINDOW<br />	mov &nbsp; 	@stwc.lpfnWndProc, OFFSET _WndProc<br />;	mov	 &nbsp;@stwc.hbrBackground,COLOR_BTNFACE+1<br />	push &nbsp;	hInstance<br />	pop &nbsp; 	@stwc.hInstance<br />	invoke 	LoadIcon,hInstance,IDI_APPLICATION<br />	mov &nbsp; 	@stwc.hIcon,eax<br />	mov &nbsp; 	@stwc.hIconSm,eax<br />	mov &nbsp; 	@stwc.lpszClassName,offset ClassName<br /><br />	invoke RegisterClassEx, addr @stwc<br />	mov Wwd,700<br />	mov Wht,700<br />	invoke GetSystemMetrics,SM_CXSCREEN <br />	shr Wwd,1<br />	shr eax,1<br />	sub eax,Wwd<br />	mov Wtx,eax<br />	invoke GetSystemMetrics,SM_CYSCREEN <br />	shr Wht,1<br />	shr eax,1<br />	sub eax,Wht<br />	mov Wty,eax<br />	invoke 	CreateWindowEx,NULL,addr ClassName,addr WindowName,WS_CAPTION or WS_SYSMENU or WS_BORDER or WS_MINIMIZEBOX ,<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 	Wtx,Wty,570,590,NULL,NULL,hInstance,NULL<br />	mov &nbsp; 	hWinMain,eax<br />	<br />	invoke	AnimateWindow,hWinMain,1000,AW_BLEND<br />	invoke	SetForegroundWindow,hWinMain<br />	invoke	LoadMenu,hInstance,101<br />	mov		hmenu,eax<br />	invoke	SetMenu,hWinMain,eax<br />	invoke	LoadAccelerators,hInstance,101<br />	mov		haccel,eax<br /><br />	invoke	GetSubMenu,hmenu,1<br />	mov		hsubmenu,eax<br />	invoke	ShowWindow,hWinMain	,SW_SHOWNORMAL<br />	invoke	UpdateWindow,hWinMain<br />	<br />	.while TRUE<br />		invoke	GetMessage,addr @stmsg,NULL,NULL,NULL<br />		.break .if(!eax)<br />		invoke	TranslateAccelerator,hWinMain,haccel,addr @stmsg<br />		.if	eax==0<br />			invoke	TranslateMessage,addr @stmsg<br />			invoke	DispatchMessage,addr @stmsg<br />		.endif	<br />	.endw<br />	mov	eax,@stmsg.wParam<br />	ret<br />WinMain	endp<br /><br />;**********************************************************************<br />;<strong>get the main process path name </strong><br /> _GetProgramPath	proc<br />	invoke	GetModuleFileName,NULL,addr progpath,sizeof progpath<br />	std<br />	mov	edi,offset progpath<br />	add	edi,sizeof progpath-1<br />	mov	al,&quot;\&quot;<br />	mov	ecx,sizeof progpath<br />	repne	scasb<br />	cld<br />	mov	BYTE &nbsp;ptr ,0<br />	ret<br />_GetProgramPath	endp<br /><br />;***********************************************************************<br />;?????<br />_odbcconnect	proc &nbsp;hWnd:DWORD<br />	invoke	SQLAllocHandle,SQL_HANDLE_ENV,SQL_NULL_HANDLE,addr henv<br />	.if	ax==SQL_SUCCESS || ax==SQL_SUCCESS_WITH_INFO<br />		invoke	SQLSetEnvAttr,henv,SQL_ATTR_ODBC_VERSION,SQL_OV_ODBC3,0<br />		.if	ax==SQL_SUCCESS || ax==SQL_SUCCESS_WITH_INFO<br />			invoke	SQLAllocHandle,SQL_HANDLE_DBC,henv,addr hconn<br />			.if	ax==SQL_SUCCESS || ax==SQL_SUCCESS_WITH_INFO<br />				invoke &nbsp;SQLSetConnectAttr,hconn,SQL_ATTR_ODBC_CURSORS,SQL_CUR_USE_ODBC,0<br />				invoke	lstrcpy,addr connectstring,addr strconnect<br />				invoke	lstrcat,addr connectstring,addr progpath<br />				invoke	lstrcat,addr connectstring,addr dbname<br />				invoke	SQLDriverConnect,hconn,hWnd,addr connectstring,sizeof connectstring,\<br />					addr conn,sizeof conn,addr strlen,SQL_DRIVER_COMPLETE<br />				.if	ax==SQL_SUCCESS || ax==SQL_SUCCESS_WITH_INFO<br />					invoke	SQLAllocHandle,SQL_HANDLE_STMT,hconn,addr hsmt<br />					.if	!(ax==SQL_SUCCESS || ax==SQL_SUCCESS_WITH_INFO)<br />						invoke	MessageBox,hWnd,addr zlc,addr zlc,MB_OK OR MB_ICONERROR<br />					.endif<br />				.else<br />					invoke	SQLFreeHandle,SQL_HANDLE_DBC,hconn<br />					invoke	SQLFreeHandle,SQL_HANDLE_ENV,henv<br />					invoke	MessageBox,hWnd,addr connfail,addr appname,MB_OK OR MB_ICONERROR<br />				.endif<br />			.else<br />	 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />				invoke	SQLFreeHandle,SQL_HANDLE_ENV,henv<br />				invoke	MessageBox,hWnd,addr allocconnfail,addr appname,MB_OK OR MB_ICONERROR<br />			.endif<br />		.else<br />			invoke	SQLFreeHandle,SQL_HANDLE_ENV,henv<br />			invoke	MessageBox,hWnd,addr setattrfail,addr appname,MB_OK OR MB_ICONERROR<br />		.endif<br />	.else<br />		invoke	MessageBox,hWnd,addr allocenvfail,addr appname,MB_OK OR MB_ICONERROR<br />	.endif<br />	ret<br />_odbcconnect	endp<br />;*****************************************************************<br />;<strong>disconnect the odbc</strong><br />_OdbcDisconnect	proc 	hDlg<br />		invoke	SQLDisconnect,hconn<br />		invoke	SQLFreeHandle,SQL_HANDLE_DBC,hconn<br />		invoke	SQLFreeHandle,SQL_HANDLE_ENV,henv<br />		ret<br />_OdbcDisconnect	endp<br /><br />;*************************************************************************<br />;********************************************************************<br />;<strong>the button classlong callback function of Dialog1</strong><br />_BtnProc1	proc	hCtl,uMsg,wParam,lParam<br />		local	ID<br />		<br />		invoke	GetDlgCtrlID,hCtl<br />		mov		ID,eax<br />		.if	uMsg==WM_LBUTTONDOWN<br />			invoke	SetCapture,hCtl<br />			.if	ID==1<br />				invoke	SendMessage,hCtl,STM_SETIMAGE,IMAGE_BITMAP,hsure2<br />			.elseif	ID==2<br />				invoke	SendMessage,hCtl,STM_SETIMAGE,IMAGE_BITMAP,happly2<br />			.elseif	ID==3<br />				invoke	SendMessage,hCtl,STM_SETIMAGE,IMAGE_BITMAP,hexit2<br />			.endif<br />		.elseif	uMsg==WM_LBUTTONUP<br />			.if	ID==1<br />				invoke	SendMessage,hCtl,STM_SETIMAGE,IMAGE_BITMAP,hsure1<br />				invoke	SendMessage,hDlg1,WM_COMMAND,10,hCtl<br />			.elseif ID==2<br />				invoke	SendMessage,hCtl,STM_SETIMAGE,IMAGE_BITMAP,happly1<br />				invoke	SendMessage,hDlg1,WM_COMMAND,11,hCtl<br />			.elseif	ID==3<br />				invoke	SendMessage,hCtl,STM_SETIMAGE,IMAGE_BITMAP,hexit1<br />				invoke	SendMessage,hDlg1,WM_COMMAND,12,hCtl<br />			.endif<br />			invoke	ReleaseCapture<br />		.endif<br />		invoke GetWindowLong,hCtl,GWL_USERDATA<br />		invoke CallWindowProc,eax,hCtl,uMsg,wParam,lParam<br />		ret<br />_BtnProc1	endp	<br /><br />;*********************************************************<br />;<strong>release the resource</strong><br />_FreeRes	proc	_hDlg,_hdback,_hbitback,_hdc,_hbrBrush<br />		invoke	_OdbcDisconnect,_hDlg<br />		invoke	DeleteDC,_hdback<br />		invoke	DeleteObject,_hbitback<br />		invoke	DeleteObject,_hbrBrush<br />		invoke	ReleaseDC,_hDlg,_hdc<br />		invoke	EndDialog,_hDlg,NULL<br />		ret<br />_FreeRes	endp		<br /><br />;********************************************************************<br />;<strong>The landing dialog</strong>&nbsp; <strong>why can&#39;t give user three chances to landing</strong><br />_DlgProc1 proc	hDlg:DWORD,uMsg:DWORD,wParam:DWORD,lParam:DWORD <br />		local	@stPaint:PAINTSTRUCT<br />		local	password[9]:BYTE <br />		local	ti:TOOLINFO<br />		local dwTemp:DWORD<br />		local	hDlgbitmap:DWORD <br />		local	hbitback,TempNum<br />		<br /><br />		mov		eax,uMsg<br />		.if	eax == WM_COMMAND<br />			mov	eax,wParam<br />			shr	eax,16<br />			.if	ax == 0<br />				mov	eax,wParam<br />				and	eax,0FFFFh<br />				.if(eax == 10)<br />					invoke	SQLBindParameter,hsmt,1,SQL_PARAM_INPUT,SQL_C_CHAR,\<br />			 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SQL_CHAR,10,0,addr name1,sizeof name1,addr dwTemp<br />					mov		LandingNum,1<br />					invoke	GetWindowText,hEdit1,addr name1,sizeof name1 <br />					invoke	lstrlen,addr name1<br />					mov	dwTemp,eax<br />					.if	!dwTemp<br />						invoke	MessageBox,hDlg,CTXT(&quot;??????&quot;),CTXT(&quot;??&quot;),MB_OK or MB_ICONINFORMATION<br />						invoke	SetFocus,hEdit1<br />						ret<br />					.endif<br />					<br />					invoke	SQLExecute,hsmt<br />	<br />					invoke	SQLBindCol,hsmt,1,SQL_C_CHAR,addr password1,10,addr dwTemp<br />					invoke	SQLFetch,hsmt<br />						<br />					invoke	SQLCloseCursor,hsmt<br />					invoke	SQLFreeHandle, SQL_HANDLE_STMT, hsmt<br />	<br />					invoke	GetWindowText,hEdit2,addr password,sizeof password<br />					invoke	lstrlen,addr password<br />					.if	eax<br />						invoke	lstrcmp,addr password,addr password1 &nbsp;;compare the input password with the right password 						.if	eax != 0<br />							invoke	MessageBox,hDlg,CTXT(&quot;you input a wrong password&quot;),CTXT(&quot;please reinput&quot;),MB_ICONINFORMATION or MB_OK<br />							invoke	SetFocus,hEdit1<br />							<br />							mov		eax,LandingNum<br />							.if		eax ==4<br />								mov		flag,0<br />								invoke	MessageBox,hDlg,CTXT(&quot;you have landing three times ,thank you!&quot;),CTXT(&quot;thank Landing!&quot;),MB_OK or MB_ICONINFORMATION<br />								invoke	_FreeRes,hDlg,hdback1,hbitback,hdc1,hbrBrush1<br />								ret<br />								<br />							.else<br />								mov		flag,0<br />								inc		LandingNum	;use as a count<br />								invoke	SetWindowText,hEdit2,NULL<br />								ret<br />							.endif<br />						.else	<br />							mov		flag,1 <br />							invoke	_FreeRes,hDlg,hdback1,hbitback,hdc1,hbrBrush1<br />							ret<br />						.endif<br />					.else<br />						mov	eax,TRUE<br />						ret<br />					.endif<br />					<br />				.elseif(eax == 11)	;					invoke	ShowWindow,hDlg1,SW_HIDE<br />					invoke	DialogBoxParam,hInstance,100,hDlg,offset _DialogProc2,NULL<br />				.elseif(eax == 12)<br />					invoke	_FreeRes,hDlg,hdback1,hbitback,hdc1,hbrBrush1<br />				.endif<br />			.endif<br />		.elseif	eax == WM_PAINT<br />			invoke	BeginPaint,hDlg,addr @stPaint<br />			mov		hdc1,eax<br />			invoke	BitBlt,hdc1,0,0,600,400,hdback1,0,0,SRCCOPY<br />			invoke	EndPaint,hDlg,addr @stPaint<br />		.elseif	eax == WM_INITDIALOG<br />			invoke	CreateRoundRectRgn,30,10,420,250,80,80<br />			push		eax<br />			invoke	SetWindowRgn,hDlg,eax,TRUE<br />			pop		eax<br />			invoke	DeleteObject,eax<br />			invoke	SetWindowPos,hDlg,HWND_TOPMOST,250,250,0,0,SWP_NOSIZE<br />			push		hDlg<br />			pop		hDlg1<br />			invoke	CreateWindowEx,WS_EX_TOPMOST,ADDR ToolTipsClassName,NULL,\<br />	 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TTS_NOPREFIX or TTS_ALWAYSTIP or TTS_BALLOON,\<br />		 &nbsp; &nbsp;CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,\<br />		 &nbsp; &nbsp;NULL,NULL, hInstance,NULL<br />		 &nbsp; mov		hwndTool,eax<br />		 &nbsp; mov		ti.cbSize,sizeof TOOLINFO<br />		 &nbsp; mov		ti.uFlags,TTF_SUBCLASS<br />		 &nbsp; push		hDlg<br />		 &nbsp; pop		ti.hWnd<br />		 &nbsp; invoke 	EnumChildWindows,hDlg,addr EnumChild,addr ti<br />			mov 		TempNum,1<br />		@@:<br />			invoke GetDlgItem,hDlg,TempNum<br />			push eax<br />			invoke SetWindowLong,eax,GWL_WNDPROC,offset _BtnProc1<br />			pop ecx<br />			invoke SetWindowLong,ecx,GWL_USERDATA,eax<br />			inc TempNum<br />			cmp TempNum,3<br />			jbe @B<br />			invoke	LoadCursor,hInstance,102<br />			mov		hcmov,eax<br />			invoke	LoadBitmap,hInstance,107<br />			mov		hDlgbitmap,eax<br />			invoke	GetDC,hDlg<br />			mov		hdc1,eax<br />			invoke	CreateCompatibleDC,hdc1<br />			mov		hdback1,eax<br />			invoke	CreateCompatibleBitmap,hdc1,600,400<br />			mov		hbitback,eax<br />			invoke	SelectObject,hdback1,hbitback<br />			<br />			invoke	CreatePatternBrush,hDlgbitmap<br />			mov		hbrBrush1,eax<br />			invoke	SelectObject,hdback1,eax<br />			invoke	DeleteObject,eax<br />			invoke	PatBlt,hdback1,0,0,600,400,PATCOPY 	;paint the Landing face	<br />;			invoke	BitBlt,hdc1,0,0,600,400,hdback1,0,0,SRCCOPY<br />			<br />			invoke	GetDlgItem,hDlg,6<br />			mov		hEdit1,eax<br />			invoke	SendMessage,hEdit1,EM_LIMITTEXT,6,0<br />			invoke	GetDlgItem,hDlg,7<br />			mov		hEdit2,eax<br />			invoke	SendMessage,hEdit2,EM_LIMITTEXT,6,0<br />			invoke	_odbcconnect,hDlg<br />			invoke	SetFocus,hEdit1<br />			invoke	SQLAllocHandle,SQL_HANDLE_STMT,hconn,addr hsmt<br />			.if	ax == SQL_SUCCESS || ax == SQL_SUCCESS_WITH_INFO<br />				invoke	SQLPrepare,hsmt,addr query,sizeof query<br />				ret<br />			.else<br />				invoke	MessageBox,hDlg,CTXT(&quot;????????&quot;),(&quot;??&quot;),MB_OK<br />				ret<br />			.endif	<br />		.elseif	eax == WM_CLOSE<br />			@@:<br />			mov		num,101<br />			invoke	DeleteObject,addr num<br />			inc		num<br />			cmp		num,112<br />			jbe		@B &nbsp; <br />			invoke	_FreeRes,hDlg,hdback1,hbitback,hdc1,hbrBrush1<br />		.elseif eax == WM_LBUTTONDOWN	;??????????????<br />			invoke	SetCursor,hcmov<br />			invoke	UpdateWindow,hDlg<br />			invoke	ReleaseCapture<br />			invoke	SendMessage,hDlg,WM_NCLBUTTONDOWN,HTCAPTION,0<br />			invoke	SetCursor,hcmain<br />		.else	<br />			mov	eax,FALSE<br />			ret<br />		.endif<br />		mov	eax,TRUE<br />		xor	eax,eax<br />		ret<br />_DlgProc1	endp<br /><br /><br />;*; found the file that user want &nbsp;<strong>but when i found the file ,the found process can&#39;t run out </strong> ******************************************************************<br />;_FindFile	proc	uses edi	ebx _lpszPath<br />		local	@stFindFile:WIN32_FIND_DATA<br />		local	@hFindFile<br />		local	@szPath:BYTE 		;used as loadint &quot;the path\&quot;<br />		local	@szSearch:BYTE 	;used as loading?the path\*.*?<br />		local	@szFindFile:BYTE 	;used as loading?the path\the file?<br />		local	@szbuffer:BYTE <br />		<br />		invoke	GetDlgItemText,hDlg4,1000,addr @szbuffer,sizeof @szbuffer<br />		invoke	lstrcpy,addr @szPath,_lpszPath<br />;********************************************************************<br /> ;add this \*.* behind the path<br />;********************************************************************<br />		@@:<br />		invoke	lstrlen,addr @szPath<br />		lea	esi,@szPath<br />		add	esi,eax<br />		xor	eax,eax<br />		mov	al,&#39;\&#39;<br />		.if	BYTE &nbsp;ptr  != al<br />			mov	WORD &nbsp;ptr ,ax<br />		.endif<br />		invoke	lstrcpy,addr @szSearch,addr @szPath<br />		invoke	lstrcat,addr @szSearch,addr szAll &nbsp; ;szAll defined as &#39;\*.*&quot;<br />;********************************************************************; found the file that user want &nbsp;<strong>but when i found the file ,the found process can&#39;t run out </strong> <br /> ;********************************************************************<br />		invoke	FindFirstFile,addr @szSearch,addr @stFindFile<br />		.if	eax !=	INVALID_HANDLE_VALUE<br />			mov	@hFindFile,eax<br />			.while	eax !=0<br />				invoke	lstrcpy,addr @szFindFile,addr @szPath<br />				invoke	lstrcat,addr @szFindFile,addr @stFindFile.cFileName<br />				.if	@stFindFile.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY<br />					.if	@stFindFile.cFileName != &#39;.&#39;<br />						invoke	_FindFile,addr @szFindFile<br />					.endif<br />				.else<br />					invoke	SetDlgItemText,hDlg4,110,addr @szFindFile<br />					invoke	lstrcmp,addr @szbuffer,addr @stFindFile.cFileName ;@szbuffer &nbsp;is the file name that user want to found			.if		eax == 0<br />						invoke	FindClose,@hFindFile<br />						ret<br />					.endif	<br />				.endif<br />				invoke	FindNextFile,@hFindFile,addr @stFindFile<br />			.endw <br />			.if	@hFindFile<br />				invoke	FindClose,@hFindFile<br />				ret<br />			.endif	<br />		.endif<br />		ret<br />_FindFile	endp<br /><br />;**************************************************************************<br />;Get the full path file name _GetFileName proc	<br />		local	lvi:LV_ITEM<br />		local	@szbuffer:BYTE <br />		<br />		invoke	lstrcpy,addr szPath1,addr szPath<br />		invoke	SendMessage,hList,LVM_GETNEXTITEM,-1,LVNI_FOCUSED<br />		mov		lvi.iItem,eax<br />		mov		lvi.iSubItem,0<br />		mov		lvi.imask,LVIF_TEXT<br />		lea		eax,@szbuffer<br />		mov		lvi.pszText,eax<br />		mov		lvi.cchTextMax,256<br />		invoke	SendMessage,hList,LVM_GETITEM,0,addr lvi <br />		push		lvi.iItem<br />		pop		iItem<br />		invoke	lstrlen,addr szPath1<br />		sub		eax,1<br />		.if		BYTE ptr szPath !=&#39;\&#39;<br />			invoke	lstrcat,addr szPath1,CTXT(&quot;\&quot;)<br />			invoke	lstrcat,addr szPath1,addr @szbuffer<br />		.else<br />			invoke	lstrcat,addr szPath1,addr @szbuffer<br />		.endif	<br />		ret<br />_GetFileName	endp<br /><br />;The Main process entry<br />start:<br />		invoke	GetModuleHandle,NULL<br />		mov		hInstance,eax<br />		call		_GetProgramPath<br />		invoke	LoadBitmap,hInstance,110		<br />		mov		hsure2,eax						<br />		invoke	LoadBitmap,hInstance,104<br />		mov		hsure1,eax<br />		invoke	LoadBitmap,hInstance,105<br />		mov		happly1,eax<br />		invoke	LoadBitmap,hInstance,112<br />		mov		happly2,eax<br />		invoke	LoadBitmap,hInstance,106<br />		mov		hexit1,eax<br />		invoke	LoadBitmap,hInstance,117<br />		mov		hexit2,eax<br />		invoke	DialogBoxParam,hInstance,65h,NULL,offset _DlgProc1,NULL<br />		mov		hDlg1,eax<br />		.if		flag<br />			invoke	WinMain<br />			invoke	ExitProcess,NULL<br />		.else<br />			invoke	ExitProcess,NULL<br />		.endif	<br /><br />end start<br /></div>
    <div class="meta">Posted on 2007-04-16 13:06:51 by hero liu</div>
   </div>
   <div class="post" id="post-188922">
    <div class="subject"><a href="#post-188922">Re: About the checking for the landing dialog</a></div>
    <div class="body">I know why the program can&#39;t run in the third time of wrong password landing<br />Because the sql_handle_stmt &#39;s handle was release in the first time landing,but did&#39;t create in the second time ,of course in the third time ..</div>
    <div class="meta">Posted on 2007-04-18 05:13:40 by hero liu</div>
   </div>
  </div>
 </body>
</html>