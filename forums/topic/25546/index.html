<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>C++ Program to ASM Program - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25546" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25546">C++ Program to ASM Program</a></p>
   <div class="post" id="post-186609">
    <div class="subject"><a href="#post-186609">C++ Program to ASM Program</a></div>
    <div class="body">Hi&nbsp; :P It&#39;s possible to say to me how to convert the code below (c++) to ASM? There are some things like parameter passage between functions that i don&#39;t understand. Where could i find good documentation about this? <br />Joanne :oops:<pre><code>#include &lt;iostream.h&gt;<br /><br />void calc_sum(int n, int *sump);<br /><br />int main(){<br />	int sump[20];<br /><br />	calc_sum(20,sump);<br /><br />	for(int i = 0; i &lt; 20; i++)<br />		cout&lt;&lt;sump<em>&lt;&lt;endl;<br /><br />	return 0;<br /><br />}<br /><br />void calc_sum(int n, int *sump){<br /><br />	int i, sum=0;<br /><br />	for(i=0; i &lt; n; i++){<br /><br />		sum+=i;<br /><br />		sump<em>=sum;<br /><br />}<br /><br />}</code></pre></div>
    <div class="meta">Posted on 2006-11-18 10:18:57 by Joanne</div>
   </div>
   <div class="post" id="post-186610">
    <div class="subject"><a href="#post-186610">Re: C++ Program to ASM Program</a></div>
    <div class="body">&quot;cl /FAs file.cpp&quot; :-)<br /><br />Sorry that I don&#39;t have time for giving some real help, I&#39;m on my way out.</div>
    <div class="meta">Posted on 2006-11-18 10:57:01 by f0dder</div>
   </div>
   <div class="post" id="post-186614">
    <div class="subject"><a href="#post-186614">Re: C++ Program to ASM Program</a></div>
    <div class="body">Which assembler are you using? That would help us alot.</div>
    <div class="meta">Posted on 2006-11-18 20:16:23 by roticv</div>
   </div>
   <div class="post" id="post-186616">
    <div class="subject"><a href="#post-186616">Re: C++ Program to ASM Program</a></div>
    <div class="body">Joanne,<br /><br /><div class="quote">Hi&nbsp; &nbsp;It&#39;s possible to say to me how to convert the code below (c++) to ASM?</div><br /><br />&nbsp; &nbsp; &nbsp;Yes.<br /><br /><div class="quote">There are some things like parameter passage between functions that i don&#39;t understand.</div><br /><br />&nbsp; &nbsp; &nbsp;See the example below in the attached ZIP file.<br /><br /><div class="quote">Where could i find good documentation about this?</div><br /><br />&nbsp; &nbsp; &nbsp;Other than Iczelion&#39;s tutorials, and whatever you can find on the forums, I don&#39;t know.&nbsp; <br /><br />&nbsp; &nbsp; &nbsp;Here is a MASM example which approximates what you are trying to do.&nbsp; It passes to a subroutine the address of the array and its length.&nbsp; The subroutine adds the numbers in the array and returns the sum in EAX.&nbsp; Look carefully at the build file.&nbsp; Notice that since this a console application, the link processor has the /SUBSYSTEM:CONSOLE option instead of /SUBSYSTEM:WINDOWS.&nbsp; The parameters are passed by pushing them onto the stack.&nbsp; You can follow what is happening by stepping through the program with a good debugger like OllyDbg.&nbsp; Ask if you have any questions.&nbsp; Ratch</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2168" target="_blank">JOANNE.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-11-18 20:57:09 by Ratch</div>
   </div>
   <div class="post" id="post-186620">
    <div class="subject"><a href="#post-186620">Re: C++ Program to ASM Program</a></div>
    <div class="body">Hello to all!&nbsp; :)<br />The assembler i&#39;m using is the nasm (vs. 0.98.39) one. Thanks Ratch, i&#39;m going to study your sample. <br />Kiss&nbsp; ;)</div>
    <div class="meta">Posted on 2006-11-19 06:08:09 by Joanne</div>
   </div>
   <div class="post" id="post-186623">
    <div class="subject"><a href="#post-186623">Re: C++ Program to ASM Program</a></div>
    <div class="body">Hi again!<br />Ratch, i&#39;ve been looking to your code to make the sum but... i don&#39;t understand lot&#39;s of instructions&nbsp; :sad: Maybe because i&#39;m learning the basis of assembly language and the assembler version i&#39;m using is a little bit old&nbsp; :) Could you translate your code to my assembler version? (nasm vs 0.98.39) I&#39;ll wait for your response&nbsp;  :D</div>
    <div class="meta">Posted on 2006-11-19 15:59:43 by Joanne</div>
   </div>
   <div class="post" id="post-186624">
    <div class="subject"><a href="#post-186624">Re: C++ Program to ASM Program</a></div>
    <div class="body">Joanne,<br /><br /><div class="quote">...Could you translate your code to my assembler version?...</div><br /><br />&nbsp; &nbsp;  Sorry, but I only know and do MASM. If you could point out the areas where you are having probs, maybe I or someone else can help.&nbsp; Ratch</div>
    <div class="meta">Posted on 2006-11-19 16:13:42 by Ratch</div>
   </div>
   <div class="post" id="post-186625">
    <div class="subject"><a href="#post-186625">Re: C++ Program to ASM Program</a></div>
    <div class="body"><div class="quote"><br />Could you translate your code to my assembler version? (nasm vs 0.98.39) I&#39;ll wait for your response&nbsp; :D<br /></div><br /><br />If you want to start converting that particular piece of MASM(32) code, then take a look at <a target="_blank" href="http://www.asmcommunity.net/projects/nasm32/"><u><strong>NASM32</strong></u></a> ;)</div>
    <div class="meta">Posted on 2006-11-19 16:22:15 by SpooK</div>
   </div>
   <div class="post" id="post-186626">
    <div class="subject"><a href="#post-186626">Re: C++ Program to ASM Program</a></div>
    <div class="body">Hello!<br />I&#39;ll try myself to translate your code to my assembler version. The great diference i&#39;m paying atention&nbsp; is on the way you pass the array and lenght to the stack. The instructions used in your assembler version are of a recent version of assembler :) . Best regards and thank you for your fast response. OK Spook, i&#39;ll look that link :)</div>
    <div class="meta">Posted on 2006-11-19 16:27:02 by Joanne</div>
   </div>
   <div class="post" id="post-186628">
    <div class="subject"><a href="#post-186628">Re: C++ Program to ASM Program</a></div>
    <div class="body">Hi again! I hope i&#39;m not being boring with this &quot;simple&quot; (not for me&nbsp; :roll: ) question... I&#39;ve tryed to make the program by myself, but the problem arises when i want to manipulate the array with the stack. The code i&#39;ve done is presented next:<pre><code>%include &quot;asm_io.inc&quot;<br /><br />segment .data<br /><br />segment .bss<br /><br />array resd 20<br /> <br />segment .text<br />&nbsp; &nbsp; &nbsp; &nbsp; global&nbsp; _asm_main <br />&nbsp; &nbsp; &nbsp; &nbsp; global sum <br />&nbsp; &nbsp; &nbsp; &nbsp; <br />_asm_main:&nbsp; <br /><br />&nbsp; &nbsp; &nbsp; &nbsp; enter&nbsp;  0,0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; setup routine<br />&nbsp; &nbsp; &nbsp; &nbsp; pusha<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx, 0<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />fill_array:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; cmp ecx, 19<br />&nbsp; &nbsp; &nbsp; &nbsp; ja end<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; mov , ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; inc ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; jmp fill_array<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />end:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax, 20<br />&nbsp; &nbsp; &nbsp; &nbsp; push eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; MY PROBLEM STARTS HERE!!! <br />&nbsp; &nbsp; &nbsp; &nbsp; lea eax, <br />&nbsp; &nbsp; &nbsp; &nbsp; push eax<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; call sum<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ; ???? - after calling sum function, i need to deallocate memory on the stack?&nbsp; &nbsp; &nbsp; &nbsp; <br /> <br />&nbsp; &nbsp; &nbsp; &nbsp; popa<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  eax, 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return back to C<br />&nbsp; &nbsp; &nbsp; &nbsp; leave&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br /><br />sum:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; push ebp<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ebp, esp<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ; ???? - here, i need to allocate memory to all the array?<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ; How could i access the elements of the array in a correct way?<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; mov esp, ebp<br />&nbsp; &nbsp; &nbsp; &nbsp; pop ebp<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ret</code></pre></div>
    <div class="meta">Posted on 2006-11-20 04:53:25 by Joanne</div>
   </div>
   <div class="post" id="post-186630">
    <div class="subject"><a href="#post-186630">Re: C++ Program to ASM Program</a></div>
    <div class="body">I see a procedural stack frame.. surely &quot;Sum&quot; is meant to be defined as a procedure.. then you&#39;re doing it &#39;the hard way&#39; by declaring the stack frame yourself..<br /><br />Before you call &#39;Sum&#39;, you&#39;re pushing the address of the array.. it might look something like this:<br /><br /><pre><code><br />sum proc pArray:ptr DWORD<br />(some code here)<br />ret<br />sum endp<br /></code></pre><br /><br />Your assembler will write the stack frame FOR you, pushing ebp etc..<br />but if you insist on doing things the hard way, you&#39;ll find that the first and only parameter to your pseudo-procedure is at ebp+8 (after you enter the stackframe via push ebp..mov ebp,esp)<br /><br />Also, I note that you are writing dwords to the array, but only incrementing the counter (ecx) by one.. this is not correct.<br />Either write bytes to the array, or increment the counter by 4 (size of dword) depending on what you intended ..<br /><br />Hope this was helpful :)<br /></div>
    <div class="meta">Posted on 2006-11-20 06:08:46 by Homer</div>
   </div>
   <div class="post" id="post-186631">
    <div class="subject"><a href="#post-186631">Re: C++ Program to ASM Program</a></div>
    <div class="body">Hi Homer!<br />The objective of my code is to make the program i post here at first (in c++). I&#39;ve made the changes to the code that you&#39;ve sugested, but it continues to give me an error. For example, i was trying to access the value of the array that was at the memory position  on the stack like:<sub>mov al, </sub> and then, print it out to the screen, but the following error appear:<br /><pre><code>58368<br />Exiting due to signal SIGFPE<br />Division by Zero at eip=0000182d, x87 status=0000<br />eax=0000009b ebx=10000000 ecx=00000298 edx=00091768 esi=00000014 edi=0000e410<br />ebp=00000000 esp=000117cb program=D:\SUMPROG.EXE<br />cs: sel=01a7&nbsp; base=02980000&nbsp; limit=0009ffff<br />ds: sel=01af&nbsp; base=02980000&nbsp; limit=0009ffff<br />es: sel=0000<br />fs: sel=017f&nbsp; base=0000fb00&nbsp; limit=0000ffff<br />gs: sel=01bf&nbsp; base=00000000&nbsp; limit=0010ffff<br />ss: sel=01af&nbsp; base=02980000&nbsp; limit=0009ffff<br />App stack: [000917c0..</code></pre></div>
    <div class="meta">Posted on 2006-11-20 08:46:15 by Joanne</div>
   </div>
   <div class="post" id="post-186634">
    <div class="subject"><a href="#post-186634">Re: C++ Program to ASM Program</a></div>
    <div class="body">Foregoing any efficiency, thorough error-checking... and attempting to keep a semi-equivalent output of what a generic C compiler would do...<br /><br />read and learn...<br /><br /><pre><code><br />;Straight NASM code (no includes or macros)<br /><br />global _main<br /><br /><br />sump resd 20<br /><br /><br /><br />;##### Program Entrypoint (global procedure) #####<br />_main:<br />;Stack Frame + Registers<br />push ebp<br />mov ebp,esp<br />pusha<br /><br />;Calculation<br />push DWORD sump ;*sump<br />push DWORD 20 ;int n<br />call calc_sum ;calc_sum()<br />add esp,8	 ;adjust stack after STDCALL + parameters<br /><br />;Print<br />;* fill in your printing routine here - scale ECX for DWORD *<br /><br />;Restore Registers + Stack Frame (STDCALL) and Return with Code 0 (in EAX, as per standard x86 ABI)<br />popa<br />mov esp,ebp<br />pop ebp<br />xor eax,eax<br />ret<br /><br />;##### calc_sum (local procedure, not global) #####<br />calc_sum:<br />;Stack Frame + Registers<br />push ebp<br />mov ebp,esp<br />pusha<br /><br />;Calculate<br />xor eax,eax ;int sum = 0<br />xor ecx,ecx ;int i = 0<br />mov ebx,DWORD ;*sump<br />.calculate:<br />add eax,ecx ;sum += i<br />mov DWORD,eax ;sump<em> = sum<br />inc ecx ;i++<br />cmp ecx,DWORD ;i &lt; 20<br />jl .calculate<br /><br />;Restore Registers + Stack Frame (STDCALL) and Return<br />popa<br />mov esp,ebp<br />pop ebp<br />ret<br /></code></pre><br /><br />Everyone/anyone, please feel free to correct anything you see explicitly wrong :)<br /><br /><span style="font-size:8pt><em>Edit: Fixed &quot;tab&quot; problems with above code, replaced with single space... sloppier looking... but it works.</em></span></div>
    <div class="meta">Posted on 2006-11-20 11:07:09 by SpooK</div>
   </div>
   <div class="post" id="post-186635">
    <div class="subject"><a href="#post-186635">Re: C++ Program to ASM Program</a></div>
    <div class="body">Thank you Spook! Now, i can see what i was doing wrong. There are some procedures that i need to learn better... But your code seems exactly what i need. Sorry if i took some time from you, but i&#39;m not a professional&nbsp; :D I&#39;m learning assembly language slowly, but with some patience, i would reach my objectives.<br /><br />Thanks again&nbsp; ;)</div>
    <div class="meta">Posted on 2006-11-20 11:52:47 by Joanne</div>
   </div>
   <div class="post" id="post-186636">
    <div class="subject"><a href="#post-186636">Re: C++ Program to ASM Program</a></div>
    <div class="body">Joanne,<br /><br />&nbsp; &nbsp;  If you already know this, then forgive me.&nbsp; The following facts will cause you no end of grief if you are not aware of them.<br /><br />&nbsp; &nbsp;  First, the stack pointer does not increase with a PUSH and decrease with a POP.&nbsp; Just the opposite happens.&nbsp; The stack grows toward zero and shrinks toward its highest address.&nbsp; For instance if the stack allotment is 4K bytes and you PUSH 1000 items (4K/DWORD), the stack pointer (ESP) will point to the lowest relative stack address.&nbsp; Similarly, a fresh stack will have its highest pointer relative value of 4K.<br /><br />&nbsp; &nbsp;  Second, the INTEL CPUs use the little endian format for memory storage.&nbsp; That means that if each 8 bit byte in a 32 bit register is valued 1,2,3,4 , then it will be stored from the register into memory as 4,3,2,1 .&nbsp; If that memory location is read into another register, the bytes will flip again to 1,2,3,4 .&nbsp; So&nbsp; if you specify something like DB 1,2,3,4 and read that location with EAX, then you will get 4,3,2,1 in EAX.&nbsp; If you specify DD 01020304H, then the assembler will generate each byte backwards into the dword, and a subsequent read into EAX will be 1,2,3,4 .<br /><br />&nbsp; &nbsp;  Since you are a beginner, you might want to take Homer&quot;s advice and use the PROC method for writing subroutines instead of STRUCs as I do.&nbsp; PROCs have advantages and disadvantages, but they are simpler.&nbsp; Sorry I cannot help you with NASM, but you do have a functional executable that you can use with a debugger to see what happens with the transfer of parameters to the stack for the subroutine.&nbsp; I strongly advise you to do that.&nbsp; Ratch<br /><br />Homer,<br /><br />&nbsp; &nbsp;  As mentioned above, my method does have some advantages.&nbsp; It does not use EBP in a register starved CPU.&nbsp; And parameters can be PUSHed ahead of time when they are available instead of storing them somewhere and retrieving them later when the subroutine is called.&nbsp; The disadvantage is, of course, the stack frame is &quot;floating&quot;, and any references to parameters on the stack have to be compensated with respect to any stack changes.&nbsp; It becomes second nature after awhile to do that, but it is probably too advanced for beginners.&nbsp; Ratch<br />&nbsp; &nbsp;  <br /><br /></div>
    <div class="meta">Posted on 2006-11-20 11:54:03 by Ratch</div>
   </div>
   <div class="post" id="post-186638">
    <div class="subject"><a href="#post-186638">Re: C++ Program to ASM Program</a></div>
    <div class="body"><div class="quote"><br />&nbsp; &nbsp; &nbsp;Since you are a beginner, you might want to take Homer&quot;s advice and use the PROC method for writing subroutines instead of STRUCs as I do.&nbsp; PROCs have advantages and disadvantages, but they are simpler.&nbsp; Sorry I cannot help you with NASM, but you do have a functional executable that you can use with a debugger to see what happens with the transfer of parameters to the stack for the subroutine.&nbsp; I strongly advise you to do that.&nbsp; Ratch<br /></div><br /><br /><a target="_blank" href="http://www.asmcommunity.net/projects/nasm32/"><u><strong>NASM32</strong></u></a> has a set of includes and macros (nasm32.inc) that helps creating/calling procedures.<br /><br />The following code is the equivalent program of the one I posted above except using nasm32.inc...<br /><br /><pre><code><br />;Straight NASM code (no includes or macros)<br /><br />global _main<br /><br /><br />sump resd 20<br /><br /><br /><br />;##### Program Entrypoint (global procedure) #####<br />proc _main<br />;Stack Frame taken care of by &quot;proc&quot; macro<br /><br />;Calculation<br />invoke calc_sum, DWORD 20, DWORD sump ;calc_sum(int n, int *sump)<br /><br />;Print<br />;* fill in your printing routine here - scale ECX for DWORD *<br /><br />;Restore Stack Frame (STDCALL) and Return with Code 0 (in EAX, as per standard x86 ABI)<br />xor eax,eax<br />ret ;using NASM32.INC, &quot;ret&quot; is actually an overloaded macro instruction, resulting in proper stack clean-up depending on the call<br />endproc<br /><br />;##### calc_sum (local procedure, not global) #####<br />proc calc_sum<br />;Stack Frame taken care of by &quot;proc&quot; macro<br /><br />;Calculate<br />xor eax,eax ;int sum = 0<br />xor ecx,ecx ;int i = 0<br />mov ebx,DWORD ;*sump<br />.calculate:<br />add eax,ecx ;sum += i<br />mov DWORD,eax ;sump<em> = sum<br />inc ecx ;i++<br />cmp ecx,DWORD ;i &lt; 20<br />jl .calculate<br /><br />;Restore Stack Frame (STDCALL) and Return<br />ret ;using NASM32.INC, &quot;ret&quot; is actually an overloaded macro instruction, resulting in proper stack<br />endproc<br /></code></pre><br /><br />As you can see, stack frame setup and restoration are always consistent in such a generic manner. NASM&#39;s macro capabilities help take care of this by cleaning things up with the use of simpler &quot;instructions&quot;, and eliminating human error by making sure the right instructions are in the right place.<br /><br />NASM32.INC also includes macros for using higher-level constructs such as &quot;IF/ELSE/FOR/WHILE&quot; to help ease your transition to lower-level programming.<br /><br />Learning ASM like this is a common thing. People tend to start off with HLL&#39;s such as C/C++ and work their way down to the bare instruction set. Along the way, people make use of macros and pseudo-instructions. When people become more comfortable with their knowledge level, they start to use some of those macros again, to save typing time (a BIG one is the proc/endproc/invoke example).<br /><br />I haven&#39;t used NASM32 in awhile, so there may be some inconsistancies (mostly things missing) from the code above to make it fully assemble properly.</div>
    <div class="meta">Posted on 2006-11-20 14:18:19 by SpooK</div>
   </div>
   <div class="post" id="post-186639">
    <div class="subject"><a href="#post-186639">Re: C++ Program to ASM Program</a></div>
    <div class="body">Hello again!<br />I&#39;ve already tested your code Spook. I&#39;ve changed some things and it&#39;s now 100% functional. Resources like this are blessed :D<br />Thanks.<br /><pre><code>%include &quot;asm_io.inc&quot;<br />segment .data<br />;<br />; initialized data is put in the data segment here<br />;<br /><br />segment .bss<br />;<br />; uninitialized data is put in the bss segment<br />;<br />sump resd 20<br /><br /> <br /><br />segment .text<br />&nbsp; &nbsp; &nbsp; &nbsp; global&nbsp; _asm_main<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />_asm_main:<br />&nbsp; &nbsp; &nbsp; &nbsp; enter&nbsp;  0,0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; setup routine<br />&nbsp; &nbsp; &nbsp; &nbsp; pusha<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx, 0&nbsp; &nbsp; <br /><br />fill_array:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; cmp ecx, 19<br />&nbsp; &nbsp; &nbsp; &nbsp; ja continue<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; mov DWORD, ecx&nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; inc ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; jmp fill_array&nbsp; &nbsp; &nbsp;  <br /><br />continue:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ;Calculation<br />&nbsp; &nbsp; &nbsp; &nbsp; push DWORD sump ;*sump&nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; push DWORD 20 ;int n<br />&nbsp; &nbsp; &nbsp; &nbsp; call calc_sum ;calc_sum()<br />&nbsp; &nbsp; &nbsp; &nbsp; add esp,8	 ;adjust stack after STDCALL + parameters<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx, 0<br />&nbsp; &nbsp; &nbsp; &nbsp;  <br />present_on_screen:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; cmp ecx, 19<br />&nbsp; &nbsp; &nbsp; &nbsp; ja end<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax, DWORD<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; call print_int<br />&nbsp; &nbsp; &nbsp; &nbsp; call print_nl<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; inc ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; jmp present_on_screen<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />end:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; popa<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  eax, 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return back to C<br />&nbsp; &nbsp; &nbsp; &nbsp; leave&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br /><br />;##### calc_sum (local procedure, not global) #####<br />calc_sum:<br />;Stack Frame + Registers<br />push ebp<br />mov ebp,esp <br />sub esp, 8<br /><br /><br />;Calculate<br />xor eax,eax ;int sum = 0<br />xor ecx,ecx ;int i = 0<br />mov ebx,DWORD ;*sump&nbsp; <br /><br />.calculate:<br />add eax,ecx ;sum += i<br />mov DWORD,eax ;sump<em> = sum<br />inc ecx ;i++<br />cmp ecx,DWORD ;i &lt; 20<br />jl .calculate<br /><br />;Restore Registers + Stack Frame (STDCALL) and Return<br /><br />mov esp,ebp<br />pop ebp<br />ret</code></pre><br /></div>
    <div class="meta">Posted on 2006-11-20 15:29:33 by Joanne</div>
   </div>
   <div class="post" id="post-186642">
    <div class="subject"><a href="#post-186642">Re: C++ Program to ASM Program</a></div>
    <div class="body">Hi:<br />Check this for details:<br />http://maven.smith.edu/~thiebaut/ArtOfAssembly/CH11/CH11-1.html<br /><br />It&#39;s very detailed in the mechanism of Procedures and Functions in Assembly, though using 16-bits address mode,&nbsp; the concept is the same.<br /><br />How I wish&nbsp; <strong>x86 ASM Wiki book </strong> could cover this.<br />I&#39;ve waited for 6 months, but the content of chapter &quot;Sub Programs: Code reuse and procedures&quot; is still empty.</div>
    <div class="meta">Posted on 2006-11-20 18:16:11 by guidry</div>
   </div>
  </div>
 </body>
</html>