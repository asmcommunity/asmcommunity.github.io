<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>How to compress codes using Huffman tree by Assembly. - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4983" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=4983">How to compress codes using Huffman tree by Assembly.</a></p>
   <div class="post" id="post-35034">
    <div class="subject"><a href="#post-35034">How to compress codes using Huffman tree by Assembly.</a></div>
    <div class="body">Hi,everyone:<br />             <br />           I am trying to make a huffman tree compression using assembly,now I have built the sorted frequence table of  bytes,but  couldn't building it to a huffman tree and  do compress .:confused: <br />So who can tell  me some tricks or some place that I could get help about such arithmetic written by assembly.:stupid: <br /><br />                      Thanks any!<br /><br />                                                                       Smallwaves.</div>
    <div class="meta">Posted on 2002-04-25 10:08:22 by smallwaves</div>
   </div>
   <div class="post" id="post-35037">
    <div class="subject"><a href="#post-35037">How to compress codes using Huffman tree by Assembly.</a></div>
    <div class="body">I haven't worked with huffman *encoding* but here are my thoughts on decoding, maybe you can get some ideas from it:<br /><br /><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=4183">http://www.asmcommunity.net/board/index.php?topic=4183</a><br /><br />Thomas<br /><br />P.S. my PNGlib contains the full implementation of a zlib decoder (which uses huffman as well)</div>
    <div class="meta">Posted on 2002-04-25 10:17:26 by Thomas</div>
   </div>
   <div class="post" id="post-35038">
    <div class="subject"><a href="#post-35038">How to compress codes using Huffman tree by Assembly.</a></div>
    <div class="body"><a target="_blank" href="http://www.hugi.de/compo/compoold.htm#compo7">http://www.hugi.de/compo/compoold.htm#compo7</a><br />Download the source pack - many compressors in ASM :)<br />Arithmic, DMC, Huffman, RLE, etc...</div>
    <div class="meta">Posted on 2002-04-25 10:19:31 by bitRAKE</div>
   </div>
   <div class="post" id="post-35062">
    <div class="subject"><a href="#post-35062">How to compress codes using Huffman tree by Assembly.</a></div>
    <div class="body">I'm almost temped to do this in a new thread (but since it relates to the point of compression and BitRake's link to hugi.com) -- here it goes:<br /><br />In one of the examples (given in the competions examples -- Sniper?) the author creates a new file (entry.com) and stores the entire contents of &quot;Unpacker.com&quot; and &quot;hugi.raw&quot; (compressed)<br /><br />Now I'm guessing that entry.com now unpacks the data contained in itself and loads the image...<br /><br />Using 32 bit assembly can this method be accomplished using exe files?<br /><br />Or can this only be done within the context of the 16 bit realm (in otherwords will I never be able to compete in this form of competetion because my data can't be stored in itself in the same manner?<br /><br />I hope I'm being clear about this...<br /><br />If anyone has an idea or (source?) as to how this can be done... I'd be very intrested in it...<br /><br />I'm including the source for both the pack.c and unpacker.asm (obviously you need to have the hugi.raw to actually run the program at the above link)<br /><br />unpacker.asm<br /><pre><code><br />; Unpack.com<br />; Forever Young Software<br />; Benjamin David Lunt  &#40;SNIPER&#41;<br />; &#91;url&#93;http&#58;//www.zekes.com/~blunt/index.html&#91;/url&#93;<br />;<br />; This is my part entry for the seventh adok^hugi contest<br />;   I am in the process of moving and had a little time<br />;   to work on an entry.  It is a wopping 19,999 bytes,<br />;   however, a few points is better than no points.<br />; Maybe I can get back to it and do some real compression<br />;   when I am done moving.<br />;<br />;  - Sniper  &#40;Ben&#41;<br />;     02 May 1999<br />;<br />;  Well needless to say, I didn't get back to it at all.<br />;   I was working on a fractal compression that compressed<br />;   hugi.raw to 4k.  However, I think it was a little<br />;   too &quot;lossy&quot;.<br />;  As I stated above, a few points is better than none and<br />;   at least I can say that I entered #7.<br />;   For about 2 hours work, I say I did pretty good. &#58;-&#125;<br />;  When I suggested this compo, I had in mind a small graphic<br />;   so that the compo would be more about the viewer, rather<br />;   than the actual compression of a file.  Oh well, It looks<br />;   as if you all had fun anyway, and that is the idea of<br />;   the whole thing.<br />;  Looking forward to #8, and good luck to all.<br />;    -Ben<br />;   &#40;31 May 1999&#41;<br />;<br />;<br />OurSize  equ  2000<br /><br />.model small, c<br />CodeSeg    segment<br />           assume cs&#58;CodeSeg, ds&#58;CodeSeg, es&#58;CodeSeg<br />.186<br />           org  100h<br />start&#58;<br />           mov  al,13h<br />           int  10h<br /><br />           mov  cx,256                  ; &#40;cx = 255 on start up&#41; &#40;inc  cx&#41;<br />           ;xor  bx,bx                  ; bx = 00 on start up<br />           mov  dx,offset BufferIn<br />           mov  ax,1012h<br />           int  10h<br /><br />           mov  si,offset BufferIn<br />           add  si,768<br />           mov  ax,0A000h<br />           mov  es,ax                   ; es&#58;di = 0A000&#58;0000h<br />           xor  di,di                   ;<br />           mov  cx,32<br />MainLoop&#58;  push cx<br />           lodsw<br />           mov  cx,ax<br />           and  cx,3FFFh<br />           shr  ax,14<br />           cmp  al,00h<br />           jne  short NotNull<br />           mov  cx,OurSize<br />           xor  al,al<br />           rep  stosb<br />           jmp  short LoopIt<br />NotNull&#58;   cmp  al,01h<br />           jne  short NotRLE<br />           call rleit<br />           jmp  short LoopIt<br />NotRLE&#58;    ;cmp  al,02h<br />           ;jne  short LoopIt<br />           ;  do another compression algo here<br />LoopIt&#58;    pop  cx<br />           loop MainLoop<br /><br />           xor  ah,ah<br />           int  16h<br /><br />           mov  ax,0003h<br />           int  10h<br /><br />           ret                          ; return to DOS<br /><br />rleit      proc near<br />           mov  bx,cx<br />rleitL&#58;    lodsb<br />           dec  bx<br />           mov  cx,1<br />           test al,10000000b<br />           jz   short NotRep<br />           and  al,01111111b<br />           mov  cl,al<br />           dec  cx<br />           lodsb<br />           dec  bx<br />           rep  stosb<br />NotRep&#58;    stosb<br />           or   bx,bx<br />           jnz  short rleitL<br />           ret<br />rleit      endp<br /><br />BufferIn&#58;<br /><br />CodeSeg    ends<br />           end  start<br /></code></pre><br /><br />packer.c<br /><pre><code><br />/*  This is the packer for my wopping 19,999 byte entry.<br />		It is in C so that I could do it fairly fast, since<br />		I haven't much time tonight to do anything.<br /><br />		I hope to get to it after I am done moving.<br /><br />    &#40;Anyway, a few points is better than none&#41;<br /><br />		Compiled with MS Quick C 2.5 in SMALL model<br />*/<br /><br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br />#include &lt;ctype.h&gt;<br /><br />#define UNSIZE  104<br /><br />unsigned int  i, j, k, l, rle, repcnt;<br />unsigned char buffer&#91;2000&#93;;<br />unsigned char rlebuff&#91;2000&#93;;<br />unsigned int  tempw;<br /><br />FILE *input;<br />FILE *output;<br /><br />void rleit&#40;&#41;;<br /><br />void main&#40;void&#41; &#123;<br /><br />	input = fopen&#40;&quot;unpack.com&quot;,&quot;rb&quot;&#41;;<br />	output = fopen&#40;&quot;entry.com&quot;,&quot;w+b&quot;&#41;;<br /><br />	// copy .com file code from 'unpack.com' to entry.com<br />	fread&#40;&amp;buffer,UNSIZE,1,input&#41;;<br />	fwrite&#40;&amp;buffer,UNSIZE,1,output&#41;;<br />	fclose&#40;input&#41;;<br /><br />	input = fopen&#40;&quot;hugi.raw&quot;,&quot;rb&quot;&#41;;<br />	fread&#40;&amp;buffer,768,1,input&#41;;     // write uncompressed palette<br />	fwrite&#40;&amp;buffer,768,1,output&#41;;<br />	for&#40;j=0; j &lt; 32; j++&#41; &#123;<br />		fread&#40;&amp;buffer,sizeof&#40;buffer&#41;,1,input&#41;;<br />		rleit&#40;&#41;;<br />//  do other compress algos here<br /><br />		l = 0;<br />		for &#40;k=0; k &lt; sizeof&#40;buffer&#41;; k++&#41;<br />			l |= buffer&#91;k&#93;;<br />		if &#40;l == 0&#41;<br />			fwrite&#40;&amp;l,2,1,output&#41;;<br />		else &#123;<br />			// check for sizes here when get another compress algo<br />			tempw = &#40;rle | 0x4000&#41;;<br />			fwrite&#40;&amp;tempw,2,1,output&#41;;<br />			fwrite&#40;&amp;rlebuff,rle,1,output&#41;;<br />		&#125;<br />	&#125;<br /><br />	fclose&#40;input&#41;;<br />	fclose&#40;output&#41;;<br />&#125;<br /><br />void rleit&#40;&#41; &#123;<br />	i = rle = 0;<br />	do &#123;<br />		repcnt = 0;<br />		while&#40;&#40;&#40;i+&#40;repcnt++&#41;&#41; &lt; &#40;sizeof&#40;buffer&#41;-1&#41;&#41; &amp;&amp;<br />										&#40;buffer&#91;i+repcnt&#93; == buffer&#91;i&#93;&#41; &amp;&amp; &#40;repcnt &lt; 0x7F&#41;&#41;;<br />		if &#40;repcnt &gt; 1&#41;<br />			rlebuff&#91;rle++&#93;=&#40;repcnt | 0x80&#41;;<br />		else<br />			if &#40;buffer&#91;i&#93; &gt; 0x7F&#41;<br />				rlebuff&#91;rle++&#93;=0x81;<br />		rlebuff&#91;rle++&#93;=buffer&#91;i&#93;;<br />		i += repcnt;<br />	&#125; while&#40;i &lt; sizeof&#40;buffer&#41;&#41;;<br />&#125;<br /><br /></code></pre></div>
    <div class="meta">Posted on 2002-04-25 14:04:01 by Sliver</div>
   </div>
   <div class="post" id="post-35063">
    <div class="subject"><a href="#post-35063">How to compress codes using Huffman tree by Assembly.</a></div>
    <div class="body">You can create an EXE (what do you think the compiler does?), but COM files are nice(=easy) because they are flat files - you don't have to worry about headers and sections.  You could not do this with the Hugi Compo because it's small DOS programs.  <strong>f0dder</strong>, has hinted about needing to do this in windows.</div>
    <div class="meta">Posted on 2002-04-25 14:13:10 by bitRAKE</div>
   </div>
   <div class="post" id="post-35104">
    <div class="subject"><a href="#post-35104">How to compress codes using Huffman tree by Assembly.</a></div>
    <div class="body">There is a piece of 0The huffman source in the VX magazine by 29A,but I forget whether it's in Issue 4 or Issue 5...<br />Who have some standard asm LZ compression source code?</div>
    <div class="meta">Posted on 2002-04-25 21:43:40 by Hume</div>
   </div>
  </div>
 </body>
</html>