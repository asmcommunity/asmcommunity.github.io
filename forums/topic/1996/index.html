<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>IDispatch interface - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=1996" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=116">Windows</a> &raquo; <a href="../?id=1996">IDispatch interface</a></p>
   <div class="post" id="post-12820">
    <div class="subject"><a href="#post-12820">IDispatch interface</a></div>
    <div class="body">can anyone help me with the IDispatch interface? My code runs fine except it doesn't return S_OK from IDispatch::Invoke, possibly because I haven't initialised the variant structures (should I have)? The invoke doesn't have any effect on the host program either. More specifically I want to write a COM add-in for Word 2000. The code is below.<br /><br />;Com Add-in for Word 2000 (DLL file)<br />.386<br />.model flat, stdcall<br />option casemap:none ; case sensitive<br />.NOLIST  ; keep the list file small, don't add the std libs to it.<br />;--------------------------------------------------------------------------<br /><br />; please make sure your paths are the same has mine.<br /><br />include     \masm32\include\windows.inc<br />include     \masm32\include\user32.inc<br />include     \masm32\include\kernel32.inc<br />include     \masm32\include\advapi32.inc<br />include     \masm32\include\oleaut32.inc<br />include     \masm32\include\ole32.inc<br /><br />include     \masm32\COM\include\oaidl.inc<br />include     \masm32\COM\include\L.inc<br /><br /><br />includelib  \masm32\lib\user32.lib<br />includelib  \masm32\lib\kernel32.lib<br />includelib  \masm32\lib\advapi32.lib<br />includelib  \masm32\lib\oleaut32.lib<br />includelib  \masm32\lib\ole32.lib<br /><br />;--------------------------------------------------------------------------<br />.LISTALL ; NOW let's list everything<br /><br />; build with these settings: \masm32\bin\ml /c /Fl /Sn /coff %1.asm<br />;  /Fl /Sn will create a small listing without all the include files<br />;  (note placement of .NOLIST and .LISTALL bracketing the include area)<br /><br />; IMyCom Interface<br />;------------------------------------------------------------------------------------<br />; public IUnknown<br /><br />sIID_IMyCom       TEXTEQU   &lt;{0B65AD801h, 0ABAFh, 11D0h,      \<br />                             {0BBh, 8Bh, 0h, 0A0h, 0C9h, 0Fh, 27h, 44h}}&gt;<br />sLIBID_MyComLib   TEXTEQU   &lt;{0A21A8C43H, 01266H, 011D4H,     \ <br />                             {0A3H, 024H, 000H, 040H, 0F6H, 0D4H, 087H, 0D9H}}&gt;<br />sCLSID_MyCom      TEXTEQU   &lt;{0A21A8C42H, 01266H, 011D4H,     \ <br />                             {0A3H, 024H, 000H, 040H, 0F6H, 0D4H, 087H, 0D9H}}&gt;<br /><br />_vtIMyCom MACRO CastName:REQ<br />    ; IMyCom methods<br />    _vtIDispatch CaseName<br />    &amp;CastName&amp;_OnConnection     comethod5   ?<br />    &amp;CastName&amp;_OnDisconnection  comethod3   ?<br />    &amp;CastName&amp;_AddInsUpdate     comethod2   ?<br />    &amp;CastName&amp;_StartupComplete  comethod2   ?<br />    &amp;CastName&amp;_BeginShutdown    comethod2   ?<br />    &amp;CastName&amp;_GetProperty      comethod4   ?<br />    &amp;CastName&amp;_PutProperty      comethod4   ?<br />    &amp;CastName&amp;_CallMethod       comethod6   ?<br />ENDM<br /><br />IMyCom                   STRUCT<br />    _vtIMyCom IMyCom<br />IMyCom                   ENDS<br /><br />;--------------------------------------------------------------------------<br />; .dll exports<br />DllRegisterServer       PROTO <br />DllCanUnloadNow         PROTO<br />DllGetClassObject       PROTO :DWORD, :DWORD, :DWORD<br />DllUnregisterServer     PROTO <br /><br />; our interface implimentations<br />QueryInterface_CF       PROTO :DWORD, :DWORD, :DWORD<br />AddRef_CF               PROTO :DWORD<br />Release_CF              PROTO :DWORD<br />QueryInterface_MC       PROTO :DWORD, :DWORD, :DWORD<br />AddRef_MC               PROTO :DWORD<br />Release_MC              PROTO :DWORD<br /><br />CreateInstance          PROTO :DWORD, :DWORD, :DWORD, :DWORD<br />OnConnection            PROTO :DWORD, :DWORD, :DWORD, :DWORD, :DWORD<br />OnDisconnection         PROTO :DWORD, :DWORD, :DWORD<br />OnAddInsUpdate          PROTO :DWORD, :DWORD<br />OnStartupComplete       PROTO :DWORD, :DWORD<br />OnBeginShutdown         PROTO :DWORD, :DWORD<br />GetProperty             PROTO :DWORD, :DWORD, :DWORD, :DWORD<br />PutProperty             PROTO :DWORD, :DWORD, :DWORD, :DWORD<br />CallMethod              PROTO :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD<br />;internal helper functions<br />CreateMyComObject       PROTO <br />GuardedDeleteKey        PROTO :DWORD, :DWORD<br /><br />;------------------------------------------------------------------------<br />; declare the ClassFactory object structure<br />ClassFactoryObject  STRUCT   ; this_<br />    ; interface object<br />    lpVtbl          DWORD       0<br />    ; object data<br />    nRefCount       DWORD       1  <br />ClassFactoryObject  ENDS<br /><br />; declare the MyCom object structure<br />MyComObject         STRUCT   ; this_<br />    ; interface object<br />    lpVtbl          DWORD       0<br />    ; object data<br />    nRefCount       DWORD       1  <br />    nValue          DWORD       0  <br />MyComObject         ENDS<br /><br />;-----------------------------------------------------------------------------<br />.data<br /><br />; here are the actual vtables for the interfaces we need to support.<br />vtIClassFactory   IClassFactory     &lt;   QueryInterface_CF,      \<br />                                        AddRef_CF,              \<br />                                        Release_CF,             \<br />                                        CreateInstance,         \<br />                                        LockServer       &gt;<br /><br />vtIMyCom IMyCom     &lt;   QueryInterface_MC,\<br />AddRef_MC,\<br />Release_MC,\<br />GetTypeInfoCount,\<br />GetTypeInfo,\<br />GetIDsOfNames,\<br />Invoker,\<br />OnConnection,\<br />OnDisconnection,\<br />OnAddInsUpdate,\<br />OnStartupComplete,\<br />OnBeginShutdown,\<br />GetProperty,\<br />PutProperty,\<br />CallMethod &gt;<br /><br />; we only need a single class factory object, so let's just allow<br />;  for it in our .data area and not bother instancing it every time.<br /><br />MyCFObject        ClassFactoryObject&lt;   OFFSET vtIClassFactory, \<br />                                        0                &gt;<br /><br /><br />; define the interface's IID<br /><br />IID_IMyCom          GUID    sIID_IMyCom<br />CLSID_MyCom         GUID    sCLSID_MyCom<br />TYPELIB_MyCom       GUID    sLIBID_MyComLib<br />IID_IUnknown        GUID    sIID_IUnknown<br />IID_IClassFactory   GUID    sIID_IClassFactory<br />IID_NULL            GUID    sIID_NULL<br />IID_IDispatch       GUID    sIID_IDispatch<br /><br />g_hDllMain          DWORD   0       ; hInstance for the dll (process)<br /><br />; strings needed to register the component<br /><br />hIDispatch          DWORD   0<br />dwDispID            DWORD   0<br />appinf              DWORD   0<br />dispparams          DISPPARAMS &lt;&gt;<br />dispparamsb         DISPPARAMS &lt;&gt;<br />vtCmdBars           VARIANT &lt;0,0,0,0&gt;<br />vtCmdBar            VARIANT &lt;0,0,0,0&gt;<br />vtParam             VARIANT &lt;0,0,0,0&gt;<br />vtParam2            VARIANT &lt;0,0,0,0&gt;<br /><br />error1              BYTE    &quot;error in GetIDsOfNames&quot;,0<br />error2              BYTE    &quot;error in Invoke&quot;,0<br />error3              BYTE    &quot;IDispatch Interface error&quot;,0<br />toolbars            wchar   L(&lt;CommandBars\0&gt;)<br />adds                wchar   L(&lt;Item\0&gt;)<br />mybarr              wchar   L(&lt;Standard\0&gt;)<br />pmybarr             EQU     OFFSET mybarr<br />szSampleDesc1       DWORD   0h<br />szSampleDesc2       BYTE    &quot;Japanese Dictionary for Word 2000/2002&quot;, 0<br />szSampleDesc3       BYTE    &quot;Japanese.Dictionary&quot;, 0<br />szSampleDesc4       DWORD   3h<br />szSampleDesc5       BYTE    &quot;OnConnection&quot;, 0<br />szSampleDesc6       BYTE    &quot;OnDisconnection&quot;, 0<br />szSampleDesc7       BYTE    &quot;OnAddInsUpdate&quot;, 0<br />szSampleDesc8       BYTE    &quot;OnStartupComplete&quot;, 0<br />szSampleDesc9       BYTE    &quot;OnBeginShutdown&quot;, 0<br /><br />szInprocServer32    BYTE    &quot;InprocServer32&quot;, 0<br />szSampleProgID      BYTE    &quot;Software\Microsoft\Office\Word\Addins\Japan.dict&quot;, 0<br />szSampleProgID2     BYTE    &quot;Japan.dict&quot;, 0<br />szProgID            BYTE    &quot;Japan.dict&quot;, 0<br />szCommandLineSafe   BYTE    &quot;CommandLineSafe&quot;, 0<br />szDescription       BYTE    &quot;Description&quot;, 0<br />szFriendlyName      BYTE    &quot;FriendlyName&quot;, 0<br />szLoadBehaviour     BYTE    &quot;LoadBehavior&quot;, 0<br />szThreadModel       BYTE    &quot;ThreadingModel&quot;, 0<br />szThreadType        BYTE    &quot;Both&quot;,0<br />szCLSID             BYTE    &quot;CLSID&quot;              ,0<br /><br />;--------------------------------------------------------------------------<br />.code<br /><br />;--------------------------------------------------------------------------<br />DllMain PROC hModule:HANDLE, dwReason:DWORD, lpReserved:DWORD<br />    .IF dwReason == DLL_PROCESS_ATTACH<br />        mov eax, hModule<br />        mov g_hDllMain, eax<br />        mov eax, TRUE<br />    .ELSEIF<br />        mov eax, FALSE<br />    .ENDIF<br />    ret<br />DllMain Endp<br /><br />;--------------------------------------------------------------------------<br />DllCanUnloadNow PROC<br />    .IF (MyCFObject.nRefCount == 0)<br />        mov eax, TRUE<br />    .ELSEIF<br />        mov eax, FALSE<br />    .ENDIF<br />    ret<br />DllCanUnloadNow Endp<br /><br />;--------------------------------------------------------------------------<br />DllGetClassObject PROC pCLSID:DWORD, pIID:DWORD, ppv:DWORD<br />    LOCAL   hr        :DWORD<br />    LOCAL   pFactory  :DWORD<br />    ; compare the clsid given us to the one we can build<br />    ; we can ONLY build a Class Factory object to build a IID_IMyCom object<br />    ; all others get rejected<br />    invoke  IsEqualGUID, pCLSID, addr CLSID_MyCom<br />    .IF (eax == TRUE)<br />        ; get a pointer to our static object<br />        ; (static = no constructor or alloc methods needed)<br />        ; (member values are set at compile time)<br />        mov eax, OFFSET MyCFObject<br />        ; use it to get the requested pointer<br />        invoke QueryInterface_CF, eax, pIID, ppv<br />        ; use the QI hresult to determine the sucess of this procedure<br />        mov hr, eax<br />        ; and release our helper pointer<br />        invoke Release_CF, OFFSET MyCFObject<br />    .ELSE<br />        mov hr, CLASS_E_CLASSNOTAVAILABLE<br />    .ENDIF  <br />    mov eax, hr         ; pass back the hresult<br />    ret<br />DllGetClassObject Endp<br /><br />;--------------------------------------------------------------------------<br />DllRegisterServer PROC<br />    LOCAL   hKey    :DWORD<br />    LOCAL   hKey2   :DWORD<br />    LOCAL   hKey3   :DWORD<br />    LOCAL   hKey4   :DWORD<br />    LOCAL   sBuf    :BYTE<br />    LOCAL   wsBuf   :WORD<br />    LOCAL   psBuf   :DWORD<br />    LOCAL   pwsBuf  :DWORD<br />    LOCAL   pti     :DWORD<br />    <br />    ; Register Com Add-in<br />    invoke RegCreateKey, HKEY_CURRENT_USER, ADDR szSampleProgID, ADDR hKey4<br />    .IF (eax != ERROR_SUCCESS) <br />        jmp return<br />    .ENDIF<br /><br />    invoke RegSetValueEx, hKey4, ADDR szCommandLineSafe, NULL, REG_DWORD, ADDR szSampleDesc1, 4<br />    .IF (eax != ERROR_SUCCESS) <br />        jmp return<br />    .ENDIF<br /><br />    invoke lstrlen, ADDR szSampleDesc2    <br />    invoke RegSetValueEx, hKey4, ADDR szDescription, NULL, REG_SZ, ADDR szSampleDesc2, eax<br />    .IF (eax != ERROR_SUCCESS) <br />        jmp return<br />    .ENDIF<br /><br />    invoke lstrlen, ADDR szSampleDesc3    <br />    invoke RegSetValueEx, hKey4, ADDR szFriendlyName, NULL, REG_SZ, ADDR szSampleDesc3, eax<br />    .IF (eax != ERROR_SUCCESS) <br />        jmp return<br />    .ENDIF<br /><br />    invoke RegSetValueEx, hKey4, ADDR szLoadBehaviour, NULL, REG_DWORD, ADDR szSampleDesc4, 4<br />    .IF (eax != ERROR_SUCCESS) <br />        jmp return<br />    .ENDIF<br /><br />; assign the pointers to the local text buffers<br />    lea eax, sBuf<br />    mov psBuf, eax<br />    lea eax, wsBuf<br />    mov pwsBuf, eax<br />    ; Create HKEY_CLASSES_ROOT\progid\CLSID<br />    invoke RegCreateKey, HKEY_CLASSES_ROOT, ADDR szSampleProgID2, ADDR hKey<br />    .IF (eax != ERROR_SUCCESS) <br />        jmp return<br />    .ENDIF<br />    invoke lstrlen, ADDR szSampleDesc2    <br />    invoke RegSetValue,hKey, NULL, REG_SZ, ADDR szSampleDesc2, eax<br />    .IF (eax != ERROR_SUCCESS) <br />        jmp return<br />    .ENDIF<br />    ; Create HKEY_CLASSES_ROOT\%szProgID%\CLSID <br />    invoke RegCreateKey, hKey, ADDR szCLSID, ADDR hKey2<br />    .IF (eax != ERROR_SUCCESS) <br />        jmp return<br />    .ENDIF<br />    ; convert the CLSID_MyCom number to a string    <br />    invoke StringFromGUID2, ADDR CLSID_MyCom, pwsBuf, MAX_PATH<br />    invoke WideCharToMultiByte, CP_ACP, 0, pwsBuf, -1, <br />                                psBuf, MAX_PATH, NULL, NULL<br />    invoke lstrlen, psBuf<br />    invoke RegSetValue, hKey2, NULL, REG_SZ, psBuf, eax<br />    .IF (eax != ERROR_SUCCESS)<br />        jmp return<br />    .ENDIF<br /><br />    invoke RegCloseKey, hKey<br />    invoke RegCloseKey, hKey2<br />    ; Create HKEY_CLASSES_ROOT\CLSID<br />    invoke RegCreateKey, HKEY_CLASSES_ROOT, ADDR szCLSID, ADDR hKey<br />    .IF (eax != ERROR_SUCCESS) <br />        jmp return<br />    .ENDIF<br />    ; Create HKEY_CLASSES_ROOT\CLSID\%GUID%<br />    invoke RegCreateKey, hKey, psBuf, ADDR hKey2<br />    .IF (eax != ERROR_SUCCESS) <br />        jmp return<br />    .ENDIF<br />    ; put in sample description value into CLSID\GUID key<br />    invoke lstrlen, ADDR szSampleDesc2    <br />    invoke RegSetValue, hKey2, NULL, REG_SZ, ADDR szSampleDesc2, eax<br />    .IF (eax != ERROR_SUCCESS) <br />        jmp return<br />    .ENDIF<br />    ; get our path ..<br />    invoke GetModuleFileName,g_hDllMain, psBuf, MAX_PATH<br />    .IF (eax == 0) <br />        mov eax, 1<br />        jmp return<br />    .ENDIF<br />    ; Create HKEY_CLASSES_ROOT\CLSID\%GUID%\InprocServer32<br />    invoke RegCreateKey, hKey2, ADDR szInprocServer32, ADDR hKey3<br />    .IF (eax != ERROR_SUCCESS) <br />        jmp return<br />    .ENDIF<br />    ; set key value to the path obtained above<br />    invoke RegSetValue, hKey3, NULL, REG_SZ, psBuf, MAX_PATH<br />    .IF (eax != ERROR_SUCCESS) <br />        jmp return<br />    .ENDIF<br />    ; set the threading type value<br />    invoke lstrlen, ADDR szThreadType<br />    invoke RegSetValueEx, hKey3, ADDR szThreadModel, 0, REG_SZ, ADDR szThreadType, eax<br />    .IF (eax != ERROR_SUCCESS) <br />        jmp return<br />    .ENDIF<br />    invoke RegCloseKey, hKey3<br />    ; Create HKEY_CLASSES_ROOT\CLSID\%GUID%\%szProgID% <br />    invoke RegCreateKey, hKey2, ADDR szProgID, ADDR hKey3<br />    .IF (eax != ERROR_SUCCESS) <br />        jmp return<br />    .ENDIF<br />    invoke lstrlen, ADDR szSampleProgID<br />    invoke RegSetValue, hKey3, NULL, REG_SZ, ADDR szSampleProgID, eax<br />    .IF (eax != ERROR_SUCCESS) <br />        jmp return<br />    .ENDIF<br />    invoke RegCloseKey, hKey3<br />    .IF (hKey != 0)<br />        invoke RegCloseKey, hKey<br />    .ENDIF    <br />    .IF (hKey2 != 0)<br />        invoke RegCloseKey, hKey2<br />    .ENDIF    <br />    .IF (hKey3 != 0)<br />        invoke RegCloseKey, hKey3<br />    .ENDIF    <br />    .IF (hKey4 != 0)<br />        invoke RegCloseKey, hKey4<br />    .ENDIF    <br /><br />    ; sBuf still has our dll pathname, lets use it to<br />    ; get the class type library<br />    Invoke MultiByteToWideChar, CP_ACP, 0, psBuf, -1, pwsBuf, MAX_PATH<br />    .IF !eax<br />        mov eax, S_FALSE<br />        jmp return<br />    .ENDIF<br />    lea eax, pti<br />    Invoke LoadTypeLib, pwsBuf, eax<br />    .IF (eax != ERROR_SUCCESS)<br />        mov eax, S_FALSE<br />        jmp return<br />    .ENDIF<br />    ; and register the type lib<br />    Invoke RegisterTypeLib, pti, pwsBuf, NULL<br />    .IF (eax != ERROR_SUCCESS)<br />        mov eax, S_FALSE<br />        jmp return<br />    .ELSE<br />        ; release the type info pointer we got<br />        ; NOTE: the 3 following lines could be substuited with<br />        ;       the coinvoke macro like so:<br />        ;  coinvoke pti, IUnknown, Release<br />        mov eax, pti<br />        mov eax, <br />        invoke (IUnknown PTR ).IUnknown_Release, pti<br />    .ENDIF<br />    xor eax, eax    ;    mov eax, S_OK<br />return:<br />    ret<br />DllRegisterServer ENDP<br /><br />; -------------------------------------------------------------------------<br />DllUnregisterServer PROC<br />    LOCAL   hSubkey:DWORD<br />    LOCAL   hSubkey2:DWORD<br />    LOCAL   sBuf    :BYTE<br />    LOCAL   psBuf   :DWORD<br />    LOCAL   wsBuf   :WORD<br />    LOCAL   pwsBuf  :DWORD<br /><br />    lea eax, sBuf<br />    mov psBuf, eax<br />    lea eax, wsBuf<br />    mov pwsBuf, eax<br />    invoke StringFromGUID2, ADDR CLSID_MyCom, pwsBuf, MAX_PATH<br />    invoke WideCharToMultiByte, CP_ACP, 0, pwsBuf, -1, <br />                                psBuf, MAX_PATH, NULL, NULL<br /><br />    invoke GuardedDeleteKey, HKEY_CURRENT_USER, ADDR szSampleProgID<br />    .IF (eax != ERROR_SUCCESS)        <br />        jmp return<br />    .ENDIF<br /><br />    invoke GuardedDeleteKey, HKEY_CLASSES_ROOT, ADDR szSampleProgID2<br />    .IF (eax != ERROR_SUCCESS)        <br />        jmp return<br />    .ENDIF<br /><br />    invoke RegOpenKey, HKEY_CLASSES_ROOT, ADDR szCLSID, ADDR hSubkey<br />    invoke GuardedDeleteKey, hSubkey, psBuf<br />    .IF (eax != ERROR_SUCCESS)        <br />        jmp return<br />    .ENDIF<br />    invoke RegCloseKey, hSubkey<br />    xor eax, eax    ; mov eax, S_OK<br />return:    <br />    ret<br />DllUnregisterServer ENDP<br /><br />;--------------------------------------------------------------------------<br />GuardedDeleteKey PROC hKey:DWORD, lpszSubKey:DWORD<br />    LOCAL   szSubKeyName    :TCHAR<br />    LOCAL   hSubkey         :DWORD  <br /><br />    ; check to see if the key to be deleted still has subkey, <br />    ; if not delete it, otherwise delete the subkey<br />    invoke RegOpenKey, hKey, lpszSubKey, ADDR hSubkey<br />    .IF (eax != ERROR_SUCCESS) <br />        mov eax, REGDB_E_INVALIDVALUE<br />        jmp return<br />    .ENDIF<br />KillNextSubkey:    <br />    ; check for a subkey<br />    invoke RegEnumKey, hSubkey, 0, ADDR szSubKeyName, MAX_PATH+1<br />    .IF (eax != ERROR_NO_MORE_ITEMS) ; IF SubKeys exist...<br />        ; delete the subkey thru recusion<br />        invoke GuardedDeleteKey, hSubkey, ADDR szSubKeyName<br />        jmp KillNextSubkey<br />    .ELSE<br />    .ENDIF<br />    ; no more Subkeys, delete the specfied hey.<br />    invoke RegCloseKey, hSubkey<br />    invoke RegDeleteKey, hKey,  lpszSubKey<br />    .IF (eax == ERROR_SUCCESS) <br />        xor eax, eax  ; mov eax, S_OK<br />    .ENDIF<br />return:<br />    ret<br />GuardedDeleteKey ENDP<br /><br />;--------------------------------------------------------------------------<br />QueryInterface_CF PROC this_:DWORD, pRIID:DWORD,  ppv:DWORD<br />; QueryInterface for the ClassFactory Interface<br />    LOCAL Match:DWORD<br />    ; check against the two interfaces we support<br />    invoke  IsEqualGUID, pRIID, addr IID_IUnknown<br />    mov Match, eax<br />    invoke  IsEqualGUID, pRIID, addr IID_IClassFactory<br />    or eax, Match    <br />    .IF (eax == TRUE)           ; then asking for either IUnknown or IClassFactory<br />                                ; both of which we are &amp; support<br />        mov eax, this_          <br />        mov edx, ppv<br />        mov , eax          ; so we point to ourselves<br />        invoke AddRef_CF, eax   ; inc the ref count for the new pointer *we* created     <br />        xor eax, eax            ; and signal all is well (same as 'ret S_OK')<br />        jmp return<br />    .ENDIF      <br />NoInterface:<br />    mov , NULL             ; good practice, always NULL bad pointers <br />                                ; in case client doesn't check the SCODE in hResult<br />    mov eax, E_NOINTERFACE      ; and signal interface is not supported here<br />return: <br />    ret<br />QueryInterface_CF endp<br /><br />;-----------------------------------------------------------------------------<br />AddRef_CF proc this_:DWORD<br />    inc MyCFObject.nRefCount<br />    mov eax, MyCFObject.nRefCount<br />    ret         ; note we return the object count<br />AddRef_CF endp<br /><br />;-----------------------------------------------------------------------------<br />Release_CF proc this_:DWORD<br />    ; Remember, we don't have a 'real' constuctor for this<br />    ; object. Neither do we have a real destructor.<br />    dec MyCFObject.nRefCount  <br />    mov eax, MyCFObject.nRefCount<br />    ret         ; note we return the object count<br />Release_CF endp<br /><br />;-----------------------------------------------------------------------------<br />CreateInstance PROC this_:DWORD, pUnknownOuter:DWORD, iid:DWORD, ppv:DWORD<br />    LOCAL   pMyObject:DWORD<br />    LOCAL   hr:DWORD<br />    .IF pUnknownOuter != NULL<br />        ; we don't support aggregation (it's too aggravating)<br />        mov eax, CLASS_E_NOAGGREGATION<br />    .ELSE<br />        invoke CreateMyComObject<br />        mov pMyObject, eax<br />        .IF eax == NULL                <br />            ; Create failed<br />            mov eax, E_OUTOFMEMORY<br />        .ELSE<br />            ; we have a valid pointer &amp; new object<br />            ; record we sucessfully made a new object<br />            inc MyCFObject.nRefCount<br />            ; see if we can get the requested interface<br />            invoke QueryInterface_MC, pMyObject, iid, ppv<br />            mov hr, eax<br />            invoke Release_MC,  pMyObject<br />        .ENDIF<br />    .ENDIF<br />    mov eax, hr<br />    ret<br />CreateInstance ENDP<br /><br />;-----------------------------------------------------------------------------<br />LockServer PROC pif:DWORD, bLockServer:DWORD<br />    ; minor cheat here, we reuse the object count to also<br />    ; count locks, because BOTH must be zero to unload the dll<br />    ; (the only way to delete our static ClassFactory object)<br />    .IF bLockServer == TRUE<br />        inc MyCFObject.nRefCount<br />    .ELSE<br />        dec MyCFObject.nRefCount<br />    .ENDIF<br />    mov eax, S_OK<br />    ret    <br />LockServer ENDP<br /><br />;-----------------------------------------------------------------------------<br />CreateMyComObject PROC<br />    LOCAL   pNewObject:DWORD<br />    ; make a new MyCom object<br />    invoke  CoTaskMemAlloc, sizeof MyComObject<br />    mov pNewObject, eax<br />    .IF (eax != NULL)<br />        ; we got our memory<br />        ; initialize the new object<br />        mov edx, pNewObject<br />        mov (MyComObject PTR ).lpVtbl, OFFSET vtIMyCom<br />        mov (MyComObject PTR ).nRefCount, 1<br />        mov (MyComObject PTR ).nValue, 0<br />    .ENDIF<br />    mov eax, pNewObject         ; restore our memory pointer<br />    ret<br />CreateMyComObject endp<br /><br />;-----------------------------------------------------------------------------<br />QueryInterface_MC PROC this_:DWORD, pRIID:DWORD,  ppv:DWORD<br />; QueryInterface for the IMyCom Interface<br />    LOCAL Match     :DWORD<br />    LOCAL ppvt      :DWORD<br />    ; check against the two interfaces we support<br />    invoke  IsEqualGUID, pRIID, addr IID_IUnknown<br />    mov Match, eax<br />    invoke  IsEqualGUID, pRIID, addr IID_IMyCom<br />    or eax, Match<br />    .IF (eax == TRUE)           ; then asking for either IUnknown or IMyCom<br />                                ; both of which we are &amp; support<br />        mov eax, this_          <br />        mov edx, ppv<br />        mov , eax          ; so we point to ourselves<br />        mov ppvt, eax<br />        invoke AddRef_MC, ppvt  ; inc the ref count for the new pointer *we* created     <br />        mov eax, S_OK           ; and signal all is well<br />        jmp return<br />    .ENDIF    <br />    ; no other interfaces supported<br />NoInterface:<br />    xor eax, eax                ; eax = NULL<br />    mov edx, ppv                ; good practice, always NULL bad pointers <br />    mov , eax              ; in case client doesn't check the SCODE in hResult<br />    mov eax, E_NOINTERFACE      ; and signal interface is not supported here<br />return: <br />    ret<br />QueryInterface_MC endp<br />;-----------------------------------------------------------------------------<br />AddRef_MC proc this_:DWORD<br />    push ebx<br />    push esi<br />    push edi<br />    mov eax, this_<br />    inc (MyComObject ptr ).nRefCount<br />    mov eax, (MyComObject ptr ).nRefCount<br />    pop edi<br />    pop esi<br />    pop ebx<br />    ret         ; note we return the object count<br />AddRef_MC endp<br />;-----------------------------------------------------------------------------<br />Release_MC proc this_:DWORD<br />    push ebx<br />    push esi<br />    push edi<br />    mov eax, this_<br />    dec (MyComObject ptr ).nRefCount<br />    mov eax, (MyComObject ptr ).nRefCount<br />    .IF (eax == 0)<br />        ; the reference count has dropped to zero<br />        ; no one holds reference to the object<br />        ; so let's delete it<br />        invoke  CoTaskMemFree, this_<br />        dec MyCFObject.nRefCount<br />        xor eax, eax    ; clear eax (count = 0)<br />    .ENDIF<br />    pop edi<br />    pop esi<br />    pop ebx<br />    ret         ; note we return the object count<br />Release_MC endp<br />;-----------------------------------------------------------------------------<br />OnConnection proc this_:DWORD, application:DWORD, connectmode:DWORD, addininst:DWORD, custom:DWORD<br />    push ebx<br />    push esi<br />    push edi<br />    mov eax, this_<br />    invoke MessageBox, 0, ADDR szSampleDesc5, 0, MB_OK or MB_ICONWARNING<br />    mov eax, application<br />    mov appinf, eax<br />    mov eax, S_OK<br />    pop edi<br />    pop esi<br />    pop ebx<br />    ret<br />OnConnection endp<br />;-----------------------------------------------------------------------------<br />OnDisconnection proc this_:DWORD, removemode:DWORD, custom:DWORD<br />    push ebx<br />    push esi<br />    push edi<br />    mov eax, this_<br />    invoke MessageBox, 0, ADDR szSampleDesc6, 0, MB_OK or MB_ICONWARNING<br />    mov eax, S_OK<br />    pop edi<br />    pop esi<br />    pop ebx<br />    ret<br />OnDisconnection endp<br />;-----------------------------------------------------------------------------<br />OnAddInsUpdate proc this_:DWORD, custom:DWORD<br />    push ebx<br />    push esi<br />    push edi<br />    mov eax, this_<br />    invoke MessageBox, 0, ADDR szSampleDesc7, 0, MB_OK or MB_ICONWARNING<br />    mov eax, S_OK<br />    pop edi<br />    pop esi<br />    pop ebx<br />    ret<br />OnAddInsUpdate endp<br />;-----------------------------------------------------------------------------<br />OnStartupComplete proc this_:DWORD,custom:DWORD<br />    push ebx<br />    push esi<br />    push edi<br />    mov eax, this_<br />    invoke MessageBox, 0, ADDR szSampleDesc8, 0, MB_OK or MB_ICONWARNING<br /><br />    invoke GetProperty, this_, appinf, addr toolbars, addr vtCmdBars<br />    <br />    mov vtParam2.vt, VT_BSTR<br />    invoke SysAllocString, addr mybarr<br />    mov vtParam2.bstrVal, eax<br /><br />    invoke CallMethod, this_, vtCmdBars.pdispVal, ADDR adds, ADDR vtCmdBar, 1, ADDR vtParam2<br />    <br />    mov eax, S_OK<br />    pop edi<br />    pop esi<br />    pop ebx<br />    ret<br />OnStartupComplete endp<br />;-----------------------------------------------------------------------------<br />OnBeginShutdown proc this_:DWORD, custom:DWORD<br />    push ebx<br />    push esi<br />    push edi<br />    mov eax, this_<br />    invoke MessageBox, 0, ADDR szSampleDesc9, 0, MB_OK or MB_ICONWARNING<br />    mov eax, S_OK<br />    pop edi<br />    pop esi<br />    pop ebx<br />    ret<br />OnBeginShutdown endp<br />;-----------------------------------------------------------------------------<br />;-----------------------------------------------------------------------------<br />GetTypeInfoCount proc this_:DWORD, removemode:DWORD, custom:DWORD<br />    push ebx<br />    push esi<br />    push edi<br />    mov eax, this_<br />    ;invoke MessageBox, 0, ADDR szSampleDesc2, 0, MB_OK or MB_ICONWARNING<br />    mov eax, S_OK<br />    pop edi<br />    pop esi<br />    pop ebx<br />    ret<br />GetTypeInfoCount endp<br />;-----------------------------------------------------------------------------<br />GetTypeInfo proc this_:DWORD<br />    push ebx<br />    push esi<br />    push edi<br />    mov eax, this_<br />    <br />    mov eax, S_OK<br />    pop edi<br />    pop esi<br />    pop ebx<br />    ret<br />GetTypeInfo endp<br />;-----------------------------------------------------------------------------<br />GetIDsOfNames proc this_:DWORD<br />    push ebx<br />    push esi<br />    push edi<br />    mov eax, this_<br />    ;invoke MessageBox, 0, ADDR szSampleDesc2, 0, MB_OK or MB_ICONWARNING<br />    mov eax, S_OK<br />    pop edi<br />    pop esi<br />    pop ebx<br />    ret<br />GetIDsOfNames endp<br />;-----------------------------------------------------------------------------<br />Invoker proc this_:DWORD<br />    push ebx<br />    push esi<br />    push edi<br />    mov eax, this_<br />    ;invoke MessageBox, 0, ADDR szSampleDesc2, 0, MB_OK or MB_ICONWARNING<br />    mov eax, S_OK<br />    pop edi<br />    pop esi<br />    pop ebx<br />    ret<br />Invoker endp<br />;-----------------------------------------------------------------------------<br />GetProperty proc this_:DWORD, pDisp:DWORD, pszName:DWORD, pvResult:DWORD<br />    push ebx<br />    push esi<br />    push edi<br />    mov eax, this_<br /><br />    coinvoke pDisp, IUnknown, QueryInterface, addr IID_IDispatch, addr hIDispatch<br />    test eax, 80000000h<br />    jz noerror3<br />    invoke MessageBox, 0, addr error3, 0, MB_OK or MB_ICONWARNING<br />    noerror3:<br /><br />    coinvoke hIDispatch, IDispatch, GetIDsOfNames, addr IID_NULL, addr pszName, 1, LOCALE_USER_DEFAULT, ADDR dwDispID<br />    test eax, 80000000h<br />    jz noerror<br />    invoke MessageBox, 0, addr error1, 0, MB_OK or MB_ICONWARNING<br />    noerror:<br /><br />    coinvoke hIDispatch, IDispatch, Invoker, dwDispID, addr IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD or DISPATCH_PROPERTYGET, addr dispparams, pvResult, NULL, NULL<br />    test eax, 80000000h<br />    jz noerror2<br />    invoke MessageBox, 0, addr error2, 0, MB_OK or MB_ICONWARNING<br />    noerror2:<br /><br />    mov eax, S_OK<br />    pop edi<br />    pop esi<br />    pop ebx<br />    ret<br />GetProperty endp<br />;-----------------------------------------------------------------------------<br />PutProperty proc this_:DWORD, pDisp:DWORD, pszName:DWORD, pvValue:DWORD<br />    push ebx<br />    push esi<br />    push edi<br />    mov eax, this_<br />    ;invoke MessageBox, 0, ADDR szSampleDesc2, 0, MB_OK or MB_ICONWARNING<br />    mov eax, S_OK<br />    pop edi<br />    pop esi<br />    pop ebx<br />    ret<br />PutProperty endp<br />;-----------------------------------------------------------------------------<br />CallMethod proc this_:DWORD, pDisp:DWORD, pszName:DWORD, pvResult:DWORD, cArgs:DWORD, rgVarParams:DWORD<br />    push ebx<br />    push esi<br />    push edi<br />    mov eax, this_<br /><br />    <br />    mov dispparamsb.rgdispidNamedArgs, 0<br />    mov dispparamsb.cNamedArgs, 0<br />    <br />    mov eax, rgVarParams<br />    mov dispparamsb.rgvarg, eax<br />    mov eax, cArgs<br />    mov dispparamsb.cArgs, ax<br /><br />    coinvoke pDisp, IDispatch, GetIDsOfNames, addr IID_NULL, addr pszName, 1, LOCALE_USER_DEFAULT, ADDR dwDispID<br />    test eax, 80000000h<br />    jz noerror4<br />    invoke MessageBox, 0, addr error1, 0, MB_OK or MB_ICONWARNING<br />    noerror4:<br /><br />    coinvoke pDisp, IDispatch, Invoker, dwDispID, addr IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD or DISPATCH_PROPERTYGET, addr dispparamsb, pvResult, NULL, NULL<br />    test eax, 80000000h<br />    jz noerror5<br />    invoke MessageBox, 0, addr error2, 0, MB_OK or MB_ICONWARNING<br />    noerror5:<br /><br />    mov eax, S_OK<br />    pop edi<br />    pop esi<br />    pop ebx<br />    ret<br />CallMethod endp<br />;-----------------------------------------------------------------------------<br /><br />End DllMain</div>
    <div class="meta">Posted on 2001-11-22 23:29:25 by Spider</div>
   </div>
   <div class="post" id="post-12824">
    <div class="subject"><a href="#post-12824">IDispatch interface</a></div>
    <div class="body">Giving your code the 30 sec review, it looks OK so far, So...<br /><br />You shouldn't have to do anything with the params TO the invoke here, as you're clearly not using any.<br /><br />How are you calling this code? Are you trying to go right from Word? I suggest something simpler, like C or asm to debug it. You never know just how word is going about it.<br /><br />Other things that can cause trouble is the typelib either not compiling or not linking into the resources correctly. But it seems you're not up to that yet, just trying to get the code block to execute.<br /><br />I'll be back around Sat, lemmy know how it's going.</div>
    <div class="meta">Posted on 2001-11-23 00:17:39 by Ernie</div>
   </div>
   <div class="post" id="post-12836">
    <div class="subject"><a href="#post-12836">IDispatch interface</a></div>
    <div class="body">Spider,<br /><br />check your DISPPARAMS structure definition. It should look like:<br /><br /><pre><code><br />DISPPARAMS  STRUCT DWORD<br />    rgvarg          LPVARIANT   ?<br />    rgdispidNamedArgs LPDISPID  ?<br />    cArgs           DWORD       ?	<br />    cNamedArgs      DWORD       ?<br />DISPPARAMS ENDS<br /></code></pre><br /><br />Ernies CoLib had a bug here.<br /><br />japheth</div>
    <div class="meta">Posted on 2001-11-23 05:01:15 by japheth</div>
   </div>
  </div>
 </body>
</html>