<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Fast window procedure - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=1026" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=1026">Fast window procedure</a></p>
   <div class="post" id="post-6678">
    <div class="subject"><a href="#post-6678">Fast window procedure</a></div>
    <div class="body">What are the most efficient way to implement the window functions handling the messages being sent to the windows.<br />I'm most concerned about speed.<br /><br />Thanks<br />--<br />RolfT</div>
    <div class="meta">Posted on 2001-09-09 13:32:19 by rolft</div>
   </div>
   <div class="post" id="post-6713">
    <div class="subject"><a href="#post-6713">Fast window procedure</a></div>
    <div class="body">hmm... well as far as i think the best way would be to code in C using switch-case to check for which msg is being sent. Somehing like this.<br /><pre><code><br />LRESULT CALLBACK WndProc&#40;HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam&#41;<br />&#123;<br />switch &#40;message&#41; <br />&#123;<br />case WM_CREATE&#58;<br />&#123;<br />     your code <br />&#125;<br />break;<br />case WM_whatevermsg&#58;<br />&#123;<br />your code<br />&#125;<br />break;<br /><br />default&#58;	return DefWindowProc&#40;hWnd, message, wParam, lParam&#41;;                               <br />&#125;<br />   return 0;<br />&#125;<br /></code></pre><br /><br />But if you want to code in asm only then i would suggest using bitrake's switch-case macro. Search for it on this forum and you shall find it.</div>
    <div class="meta">Posted on 2001-09-10 03:29:41 by MovingFulcrum</div>
   </div>
   <div class="post" id="post-6765">
    <div class="subject"><a href="#post-6765">Fast window procedure</a></div>
    <div class="body">Due to the fact that even on mouse-moving your app get a message mostly your message-loop roll over without doing anything special. Secondary a jump which will not proceed uses just about one cycle opposite to three cycles (without cache-missings !) if proceeded.<br /><br />So my conclusion to do a fast message-loop is that: (It isn't a regular proto - but who needs this real ?)<br /><br /><pre><code><br />WndProc&#58;	; *** in most cases the incoming messages are passed through ***<br />	        ; *** so no jump will be executed                            ***<br /><br />		mov	eax, 8 &#91;esp&#93;                    ; = uMsg !<br /><br /> 		cmp	eax, WM_PAINT<br /> 		je	WP_Paint<br /><br /> 		cmp	eax, WM_CLOSE<br /> 		je	WP_Close<br /><br /> 		cmp	eax, WM_DESTROY<br /> 		je	WP_Destroy<br /><br />		cmp	eax, WM_CREATE<br /> 		je	WP_Create<br /><br />		; *** call default WindowProc ***<br />                ;<br />                ; In fact, no Invoke is needed here because stack-contents will be copied only !<br />                ; There's no reason to return from DefWindowProc, so a jmp is done !<br /><br />@@&#58;		jmp	DefWindowProc<br /><br />WP_Create&#58;	...<br />WP_Close&#58;	...<br />WP_Destroy&#58;	...<br /><br /></code></pre> <br /><br />Greetings, CALEB</div>
    <div class="meta">Posted on 2001-09-10 14:21:00 by Caleb</div>
   </div>
   <div class="post" id="post-6776">
    <div class="subject"><a href="#post-6776">Fast window procedure</a></div>
    <div class="body">Agree'd...  I receintly built myself a very basic template *.asm that is simular to this design: (This creates an Empty, White Window, for custom controls etc.).<br /><pre><code>.386<br />.model flat,stdcall<br />option casemap&#58; none<br /><br />include \masm32\include\gdi32.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\user32.inc<br />include \masm32\include\windows.inc<br />include \masm32\include\_Macros_.inc<br /><br />includelib \masm32\lib\gdi32.lib<br />includelib \masm32\lib\kernel32.lib<br />includelib \masm32\lib\user32.lib<br /><br />; --==============================================<br /><br />WinMain PROTO &#58;DWORD,&#58;DWORD,&#58;DWORD,&#58;DWORD<br />WndProc PROTO &#58;DWORD,&#58;DWORD,&#58;DWORD,&#58;DWORD<br />Paint_Proc   PROTO &#58;DWORD,&#58;DWORD<br /><br />   ; This is supporting equates for the CreateBlankWindow Macro..<br />   ;500 ICON MOVEABLE PURE LOADONCALL DISCARDABLE &quot;MAINICON.ICO&quot;<br />   IDI_MAINICON equ 500<br />   THIS_WIDTH   equ 300<br />   THIS_HEIGHT  equ 200<br />   <br />; --==============================================<br />.data<br /><br />.data?<br />   hInstance        dd   ?<br />   hIcon            dd   ?<br />   CommandLine      dd   ?<br />   <br />.code<br />; --==============================================<br />start&#58;<br />      invoke GetModuleHandle, NULL<br />      mov hInstance, eax<br /><br />      invoke GetCommandLine<br />      mov CommandLine, eax<br /><br />      invoke WinMain,hInstance,NULL,CommandLine,SW_SHOWDEFAULT<br />      invoke ExitProcess,eax<br /><br /><br />; --==============================================<br />WinMain proc hInst     &#58;DWORD, hPrevInst &#58;DWORD,<br />             CmdLine   &#58;DWORD, CmdShow   &#58;DWORD<br />             <br />      LOCAL wc      &#58;WNDCLASSEX      <br />      LOCAL hWnd    &#58;DWORD<br />      LOCAL msg     &#58;MSG<br /><br />      mov hWnd, CreateBlankWindow&#40; &quot;AClass&quot;, &quot;CTRL-DEL NAME&quot;, WndProc &#41;<br />      <br />      invoke ShowWindow,hWnd,SW_SHOWNORMAL<br />      invoke UpdateWindow,hWnd<br /><br />      ;===================================<br />      ; Loop until PostQuitMessage is sent<br />      ;===================================<br /><br />    StartLoop&#58;<br />      invoke GetMessage,ADDR msg,NULL,0,0<br />      cmp eax, 0<br />      je ExitLoop<br />      invoke TranslateMessage, ADDR msg<br />      invoke DispatchMessage,  ADDR msg<br />      jmp StartLoop<br />    ExitLoop&#58;<br />      <br />      mov eax, msg.wParam<br />      ret<br />WinMain endp      <br /><br /><br />; --==============================================<br />WndProc proc hWnd&#58;DWORD, uMsg&#58;DWORD, wParam&#58;DWORD, lParam&#58;DWORD<br /><br />     IF_MSG    WM_DESTROY,         Do_destroy<br />     IF_MSG    WM_CREATE,          Do_create<br />     IF_MSG    WM_PAINT,           Do_paint<br />     IF_MSG    WM_COMMAND,         Do_command<br />     IF_MSG    WM_LBUTTONDOWN,     Do_LButtonDown<br /><br /> @return&#58;  ; ###################################################<br />     invoke    DefWindowProc,hWnd,uMsg,wParam,lParam<br />     ret<br />     <br /> @end&#58;     <br />     xor eax, eax<br />     jmp @return<br /><br /> Do_destroy&#58;  ; ################################################<br />     <br />     invoke PostQuitMessage, NULL<br />     jmp @end<br />     <br /> Do_create&#58;  ; #################################################<br /> <br />     jmp @end<br /><br /> Do_paint&#58;  ; ##################################################<br /> <br />     jmp @end<br /> <br /> Do_command&#58;  ; ################################################<br /> <br />     jmp @end<br />     <br /> Do_LButtonDown&#58;  ; ############################################<br />     <br />     mov eax, lParam<br />     mov edx, eax        ; x point<br />     and edx, 0ffffh<br />     shr eax, 16         ; y point<br />     <br />     invoke SendMessage, hWnd, WM_CLOSE, NULL, NULL<br /> <br />     jmp @end     <br />     <br />WndProc endp<br />; --==============================================<br />end start</code></pre><br /><br />I built this to work with two MACRO's, one for creating the Window, and the other for the message loop:<pre><code><br />CreateBlankWindow MACRO CName&#58;REQ, CDisp&#58;REQ, Prc&#58;REQ<br />      .data<br />      szThisClassName db CName,0<br />      szThisDisplayName db CDisp,0<br />      .code<br />      <br />      mov wc.cbSize,SIZEOF WNDCLASSEX<br />      mov wc.style,CS_HREDRAW or CS_VREDRAW<br />      mov wc.lpfnWndProc, Prc<br />      mov wc.cbClsExtra,0<br />      mov wc.cbWndExtra,0<br />      mov wc.hbrBackground,COLOR_WINDOW+1<br />      mov wc.lpszMenuName,0<br />      mov wc.lpszClassName,offset szThisClassName<br /><br />      invoke   LoadIcon,hInst, IDI_MAINICON<br />      mov hIcon,eax<br />      mov wc.hIcon,eax<br />      mov wc.hIconSm,eax<br /><br />      invoke   LoadCursor,0,IDC_ARROW<br />      mov wc.hCursor,eax<br /><br />      push     hInstance<br />      pop wc.hInstance<br /><br />      invoke   RegisterClassEx,addr wc<br />      invoke   GetSystemMetrics,SM_CXSCREEN<br /><br />      sub eax, THIS_WIDTH<br />      shr eax,1<br />      mov ebx,eax<br /><br />      invoke   GetSystemMetrics,SM_CYSCREEN<br />      sub eax, THIS_HEIGHT<br />      shr eax,1<br /><br />      invoke   CreateWindowEx,WS_EX_TOPMOST,addr szThisClassName,addr szThisDisplayName,WS_POPUP or\<br />                              WS_SYSMENU,ebx,eax,THIS_WIDTH,THIS_HEIGHT,0,0,hInst,0<br />      EXITM &lt;eax&gt;<br />ENDM      <br /><br />IF_MSG MACRO WMsg&#58;REQ, DoJmp&#58;REQ<br />      cmp uMsg, WMsg<br />      jz  DoJmp<br />ENDM</code></pre><br /><br />You dont *need* the &quot;CreateBlankWindow&quot; macro, but i hate seeing all that crap.  But the IF_MSG macro is more to the point of what Caleb was getting at.<br /><br />As well, the @end, and @return are placed for proper exiting, @end == msg handled, @return == message not handled.<br /><br /><br />If you can use it, enjoy...<br /><br />NaN</div>
    <div class="meta">Posted on 2001-09-10 17:14:19 by NaN</div>
   </div>
   <div class="post" id="post-6842">
    <div class="subject"><a href="#post-6842">Fast window procedure</a></div>
    <div class="body">Correct me if i am worng but by the use of switch-case the binary tree which will be created will allow lesser jumps. NaN and Caleb in your methods one would have to pass through all the WM_msgs until it reaches the last one. So obviously more jumps would be executed.</div>
    <div class="meta">Posted on 2001-09-11 03:47:45 by MovingFulcrum</div>
   </div>
   <div class="post" id="post-6843">
    <div class="subject"><a href="#post-6843">Fast window procedure</a></div>
    <div class="body">rolft,<br /><br />From programming windows code for over 10 years, Microsoft designed the WndProc callback in a C Switch format. Many of the guys who wrote assembler some time back used what ws called despatchers but they are not as efficient as a Switch block style of processing.<br /><br />If you use the MASM .IF block syntax you get a efficient technique that is much faster than the messages that are being sent to the window and that can be nested as deep as you need with nightmare collections of jumps.<br /><br />What you will find with a Window's callback WndProc is that clarity and understanding what it does properly is more important than trying to find speed where it does not exist. The current genius in OOP programming is to avoid C style switch blocks because they are supposed to be too complicated to use but this is nonsense, there is a simple method for handling this type of tree structure that is error free if you understand it properly.<br /><br />In C you make an opening bracket followed by a closing bracket and write the switches inbetween them, in Basic you use Select Case followed by End Select, in MASM you use .IF followed by .ENDIF.<br /><br />.IF uMsg == WM_COMMAND<br /><br />.ELSEIF uMsg == WM_CREATE<br /><br />.ENDIF<br /><br />This syntax is clear, much faster than windows messaging and is easily extendable in both length and nesting. Despatchers produce nightmares in comparison.<br /><br />Regards,<br /><br /><a href="mailto:hutch@pbq.com.au">hutch@pbq.com.au</a></div>
    <div class="meta">Posted on 2001-09-11 04:09:40 by hutch--</div>
   </div>
   <div class="post" id="post-6846">
    <div class="subject"><a href="#post-6846">Fast window procedure</a></div>
    <div class="body">A point to notice, you are never going to get a FAST windows message PROC, sure you could go out of your way to not make a slow one. <br /><br />Any gains you get from extra effot in jumps and switching will maybe increase speed your proc up by 0.1%. Window's own overhead processing on messages is so much greater than anything you can optimize at that level.</div>
    <div class="meta">Posted on 2001-09-11 04:34:44 by huh</div>
   </div>
   <div class="post" id="post-6850">
    <div class="subject"><a href="#post-6850">Fast window procedure</a></div>
    <div class="body">Hutch,<br /><br />Been a long while since I heard reference to <strong>dispatchers</strong> in a language. Oh them good old days!;)</div>
    <div class="meta">Posted on 2001-09-11 06:02:12 by bcraven</div>
   </div>
   <div class="post" id="post-6852">
    <div class="subject"><a href="#post-6852">Fast window procedure</a></div>
    <div class="body"><strong>To HUH:</strong><br /><br />Yes that's true - the Windows-Overhang makes all tries to optimize the message-loop senseless. But it's a good exercise in optimization ;) !<br /><br /><strong>To MovingFulcrum:</strong><br /><br />A switchcase will not produce fewer jumps...<br /><br />But what I write was more compact and so due to caching it's faster because all jumps are in a small block. If you do a Switch-Case the block expands and more cache-prefetching is needed, so the processor needs more time to process the message-loop !<br /><br />Also with proceeded jumps some other cpu-optimizations will fail, too !<br /><br />Greetings, CALEB</div>
    <div class="meta">Posted on 2001-09-11 06:33:40 by Caleb</div>
   </div>
   <div class="post" id="post-7767">
    <div class="subject"><a href="#post-7767">Fast window procedure</a></div>
    <div class="body">Talking of speed Caleb's logic is fastest in the case and<br />.ID uMsg ==<br />.ELSEIF uMsg ==<br />style produce the worst possible code.<br />If anybody care I can explain it in detail.<br />As to clearity, please, have a look - to me it's much clear and shorter than .IF .ELSEIF:<br /><pre><code><br />.586<br />.model flat,stdcall<br />option casemap&#58;none<br />include C&#58;\masm32\include\windows.inc<br />include C&#58;\masm32\include\user32.inc<br />include C&#58;\masm32\include\kernel32.inc<br />includelib kernel32.lib<br />includelib user32.lib<br />WM_CASE macro reg,msgs<br />  irp msg,&lt;msgs&gt;<br />    cmp reg,WM_&amp;msg<br />    je  @@&amp;msg<br />  endm<br />endm<br />.code<br />start&#58;<br />	<br />WndProc proc hWnd,uMsg,wParam,lParam<br /><br />WM_CASE eax,&lt;CREATE,COMMAND,SIZE,PAINT,CLOSE&gt;<br />invoke DefWindowProc,hWnd,eax,wParam,lParam<br />@@CREATE&#58;<br />	xor eax,eax<br />	ret<br />@@COMMAND&#58;<br />	ret<br />@@SIZE&#58;<br />	xor eax,eax<br />	ret<br />@@PAINT&#58;<br />	ret<br />@@CLOSE&#58;<br />	ret<br />WndProc endp<br />	end start<br /></code></pre></div>
    <div class="meta">Posted on 2001-09-22 12:15:25 by The Svin</div>
   </div>
   <div class="post" id="post-7768">
    <div class="subject"><a href="#post-7768">Fast window procedure</a></div>
    <div class="body"><strong>Svin</strong>, my switch case macro does better for many branches. (<a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=179">here</a>)</div>
    <div class="meta">Posted on 2001-09-22 12:20:56 by bitRAKE</div>
   </div>
   <div class="post" id="post-7769">
    <div class="subject"><a href="#post-7769">Fast window procedure</a></div>
    <div class="body">I have a simple question:<br />Did you time a WINDOW CALLBACK proc with ~10 to 20 cases<br />using your macro. And compared with this simple pass though <br />logic?<br />If you did I want to see results and testing proc.<br />I doubt.<br />You can recommend your macro in many cases as very usefull but<br />not in wndproc.<br />For simple reason - first jcc taken will flash all pipes.<br />How may clock it will take if we have in uMsg someting wich is not<br />one of &quot;our&quot; case and we need just passing it to DefWndProc?<br />Using:<br />cmp <br />je<br />cmp<br />je<br />We need just NumberOfOurCases clocks.<br />Cause 99% possibitily that none of jmps will be predicted as taken. And in the case both commands pair in one clock. Jmps will be predicted as not taken.<br />Prove me wrong - write test and we'll see.<br />We need to remember what is WndProc, it's called by system.</div>
    <div class="meta">Posted on 2001-09-22 12:41:32 by The Svin</div>
   </div>
   <div class="post" id="post-7785">
    <div class="subject"><a href="#post-7785">Fast window procedure</a></div>
    <div class="body">I'm going to take a somewhat different view here. I think the fact that DefWindowProc IS executed so often makes it a good candidate for optimization. Most applications don't process the majority of messages sent to them. Doesn't it help overall system performance if we can give control back to the &quot;system&quot; as quickly as possible?<br /><br />Caleb brings up a good point with keeping all the cmp/je code close together, since spreading them out can increase cache and BPB confilcts. But I don't think branch prediction is that much of a factor, since we've still got to run the entire loop each time anyway. Using je vs. jne doesn't make a difference since they would both be predicted equally.<br /><br />Beyond saving a clock here and there, I don't think there is any way of finding great performance improvements, since we still need to pick out the messages we want to process, one way or another. And yes, considering the general windows overhead, it is like spiting into the ocean. But considering how often we spit DefWindowProc, we'll have a few gallons in a short time. So again, doesn't it help system performance if we can give a few clocks back to the OS and/or another application? Doesn't it possibly make OUR next message available that much sooner?<br /><br />My vote goes to Caleb for the quickest way in and out, and it is pretty clear. IF/ELSE still has a place, one level down, as in WM_COMMAND processing. :)</div>
    <div class="meta">Posted on 2001-09-22 19:09:00 by S/390</div>
   </div>
   <div class="post" id="post-7787">
    <div class="subject"><a href="#post-7787">Fast window procedure</a></div>
    <div class="body">During this discussion I remember my days coding on AMIGA. Well, my friends and me fought for every cycle subroutines spend on. And if the system takes too much, well, we shut it off :grin:  and the complete machine belongs to our code. Nice days ...<br /><br />Today on PC this is impossible due to the fact that there are less than none informations about how to code the devices, even the graphics-cards (today, noone will code VGA or VESA !)<br /><br />Greetings, CALEB</div>
    <div class="meta">Posted on 2001-09-22 19:42:22 by Caleb</div>
   </div>
   <div class="post" id="post-7793">
    <div class="subject"><a href="#post-7793">Fast window procedure</a></div>
    <div class="body"><div class="quote">. I think the fact that DefWindowProc IS executed so often makes it a good candidate for optimization. </div> <br />What did you mean? To write your own user32.dll? :)<br /><div class="quote">Doesn't it help overall system performance if we can give control back to the &quot;system&quot; as quickly as possible? </div> <br />Yes it does.<br />And though out sequence cmp je cmp je serves both to purposes<br />to give control back to system if it's not our message and find right jump if it's ours.<br /><div class="quote">But I don't think branch prediction is that much of a factor, since we've still got to run the entire loop each time anyway. Using je vs. jne doesn't make a difference since they would both be predicted equally. </div> <br />You're deadly wrong here. Do simple step by step analyze of different scenarios and clock testing.<br /><div class="quote">Beyond saving a clock here and there, I don't think there is any way of finding great performance improvements, since we still need to pick out the messages we want to process, one way or another. </div> <br />Words, words, words...<br />I did get what you meant.<br /><div class="quote">IF/ELSE still has a place, one level down, as in WM_COMMAND processing. </div> <br />In WM_COMMAND we don't need it at all. We can calculate right jmp with two opecodes even if we have 1000 items in menu.<br />================<br /><br />OK, it is my last post in the thread. <br />If anybody wants to know thruth - the anybody can do some practical work to figure it out - logical analyze going though bare disassebled code and writing test apps.<br />Here is last hints on the topic look:<br />Compile, watch, test, think<br /><pre><code><br />.586<br />.model flat,stdcall<br />option casemap&#58;none<br />include C&#58;\masm32\include\windows.inc<br />include C&#58;\masm32\include\user32.inc<br />include C&#58;\masm32\include\kernel32.inc<br />includelib kernel32.lib<br />includelib user32.lib<br />WM_CASE macro reg,msgs<br />  irp msg,&lt;msgs&gt;<br />    cmp reg,WM_&amp;msg<br />    je  @@&amp;msg<br />  endm<br />endm<br />.data<br />.data?<br />.code<br />start&#58;<br /><br />.IF eax == WM_CREATE<br />	add ecx,ecx<br />	ret<br />.ELSEIF eax == WM_DESTROY<br />	add edx,edx<br />        ret<br />.ELSEIF eax == WM_PAINT<br />	xor ecx,ecx<br />	ret<br />.ELSEIF eax ==WM_COMMAND<br />	ret<br />.ENDIF<br /><br />WM_CASE &lt;CREATE,DESTROY,PAINT,COMMAND&gt;<br /><br />@@CREATE&#58;  ADD ECX,ECX<br />	   RET<br />@@PAINT&#58;   ADD EDX,EDX<br />	   RET<br />@@DESTROY&#58; XOR ECX,ECX<br /><br />@@COMMAND&#58; RET<br /><br /><br /><br />	call ExitProcess<br />	end start.<br /></code></pre><br />There are 2 piece of code wich do the same thing.<br />Second is<br />1. More Clear<br />2. Less size<br />3. In callback proc it'll run at least twice faster.<br /><br />To understand it you need:<br />1. Learn about what is callback.<br />2. Learn about brunching prediction especially part of first time not in the BPB block handling jmps.<br />3. Analyse it only in disassembled mode.<br />Good luck.</div>
    <div class="meta">Posted on 2001-09-22 20:39:40 by The Svin</div>
   </div>
   <div class="post" id="post-7798">
    <div class="subject"><a href="#post-7798">Fast window procedure</a></div>
    <div class="body">I understand what your saying <strong>Svin</strong>, and I'm fairly sure your right.  What do you think about the <strong>scasd</strong> method?<pre><code>;;<br />;;          MAIN WINDOW MESSAGES<br />;;<br />            .CONST<br />MainMsg DWORD WM_NOTIFY, WM_COMMAND, WM_MENUSELECT,<br />              WM_SIZING, WM_ENTERSIZEMOVE, WM_WINDOWPOSCHANGED,<br />              WM_MOUSEMOVE, WM_LBUTTONDOWN, WM_LBUTTONUP, WM_RBUTTONDOWN,<br />              WM_KEYDOWN, WM_CANCELMODE,<br />              WM_ERASEBKGND, WM_ACTIVATE,<br />              WM_CREATE, WM_CLOSE, WM_DESTROY,<br />              WM_SYSCOLORCHANGE, WM_SETTINGCHANGE<br />        DWORD MainWM_NOTIFY, MainWM_COMMAND, MainWM_MENUSELECT,<br />              MainWM_SIZING, MainWM_ENTERSIZEMOVE, MainWM_WINDOWPOSCHANGED,<br />              MainWM_MOUSEMOVE, MainWM_LBUTTONDOWN, MainWM_LBUTTONUP, MainWM_RBUTTONDOWN,<br />              MainWM_KEYDOWN, MainWM_CANCELMODE,<br />              MainWM_ERASEBKGND, MainWM_ACTIVATE,<br />              MainWM_CREATE, MainWM_CLOSE, MainWM_DESTROY,<br />              MainWM_SYSCOLORCHANGE, MainWM_SETTINGCHANGE<br /><br />;Equates used to simplify references to window procedure parameters<br />lParam TEXTEQU &lt;esp+4+4&gt;<br />wParam TEXTEQU &lt;esp+4+8&gt;<br />uMsg   TEXTEQU &lt;esp+4+12&gt;<br />hWnd   TEXTEQU &lt;esp+4+16&gt;<br /><br />            .CODE<br />MainWND PROC<br />    push edi<br />    mov eax,&#91;uMsg&#93;<br />    mov ecx,LENGTHOF MainMsg<br />    mov edi,OFFSET MainMsg<br />    repne scasd<br />    je Process<br />Default&#58;<br />    pop edi<br />    jmp &#91;DefWindowProc&#93;<br /><br />; ELSE process this message possibly setting carry flag for default processing<br />    ALIGN 4<br /><br />Process&#58;<br />    call DWORD PTR &#91;edi+&#40;SIZEOF MainMsg-4&#41;&#93;<br />    jc Default<br />Return&#58;<br />    pop edi<br />    ret 10h<br />MainWND ENDP</code></pre>Maybe, we could prefetch the data to speed it up. :)</div>
    <div class="meta">Posted on 2001-09-22 22:18:54 by bitRAKE</div>
   </div>
   <div class="post" id="post-7802">
    <div class="subject"><a href="#post-7802">Fast window procedure</a></div>
    <div class="body">Of course the one more logic is create arrays of WM_s and jmps<br />to handlers and scan through the array.<br />But what we should remember:<br />1. It wouldn't do code faster, we may use the technigue just to decrease size.<br />2. Using scasd in the case is worst possible way to scan.<br />The fastest way for the scaning would be creating a loop.<br />And the fastest way of looping here would be one design with<br />&quot;fiction point&quot; logic. <br />With this logic you:<br />1. Don't need counter at all, wich make the loop faster<br />2. You can unroll the loop as much as you want. Wich give you aditional speed.<br />Let you have an array of structures of WM_s and handlers<br />.data<br />...<br />jmptbl dd WM_CREATE,wm_create<br />           dd WM_COMMAND,wm_command<br />and so on<br />and in the code:<br />.code<br />...<br />wm_create:<br />...<br />wm_command:<br />and so on<br />Now put at the and of jmptbl<br />....<br />wm_def   dd 0,default<br />and in the code<br />default:<br />          invoke DefWindowProc,hWnd,eax,wParam,lParam<br />Whatever message you have we insert it into wm_def dword<br />So now you don't need counter. <br />WndProc proc hWnd,uMsg,wParam,lParam<br />      mov eax,uMsg<br />      mov ecx,offset jmptbl<br />      mov wm_def,eax<br />@@:  cmp ,eax<br />          lea ecx,<br />          jne @B<br />          jmp d <br />do I need show how you can unroll it? :)</div>
    <div class="meta">Posted on 2001-09-22 23:27:45 by The Svin</div>
   </div>
   <div class="post" id="post-7806">
    <div class="subject"><a href="#post-7806">Fast window procedure</a></div>
    <div class="body"><div class="quote"><em>Originally posted by The Svin </em><strong>do I need show how you can unroll it? :) </div>Please, do :)</div>
    <div class="meta">Posted on 2001-09-23 00:11:37 by bitRAKE</div>
   </div>
   <div class="post" id="post-7807">
    <div class="subject"><a href="#post-7807">Fast window procedure</a></div>
    <div class="body">Hi Svin,<br /><br />I think we're arguing the same point. :)<br /><br />But I will take a minute to reply to a couple of your comments.<br /><br />&quot;What did you mean? To write your own user32.dll?&quot;<br /><br />No, what I'm saying is that when we do run DefWindowProc, let's get there as quickly as possible.<br /><br />&quot;In WM_COMMAND we don't need it at all. We can calculate right jmp with two opecodes even if we have 1000 items in menu.&quot;<br /><br />This is a good point, and true if you structure your resources properly. All I'm saying is that there are cases where IF/ELSE programming can be useful, just like any other programming technique.<br /><br />As far branch prediction, I think it's a moot point in this case. Windows is a mulit-tasking OS, so if it task switches between sending us messages, chances are our entries in the BPB well be clobbered. The PII/III have a maximum of 512 BPB entries. Just normal win overhead without a task switch may be enough to step on the BPB. I guess we could test to see how true this is.<br /><br />If it is true that we suffer the &quot;first time penalty&quot; nearly every time, then cmp/je/cmp/je is by far the best choice, since it is predicted to fall thru the first time (actually first 2 times) on the PII/III if it is a forward reference, which it is in our example. According to Agner Fog, a misprediction costs between 10 and 20 clocks on a PII/III.<br /><br />In any case, we are in complete agreement that cmp/je/cmp/je is the better of the two. :)</div>
    <div class="meta">Posted on 2001-09-23 00:42:04 by S/390</div>
   </div>
   <div class="post" id="post-7814">
    <div class="subject"><a href="#post-7814">Another way</a></div>
    <div class="body">Hi CoderZ!<br /><br />  I'm a newbie about win32 stuff, I'm a bit rusted in ASM and I have the worst english possible, so excuse me if my post is inapropiate for this thread or wathever .:) <br /><br /> I think there is other efficient ways for checking those WM_msgs, and I try to show you my aproachs.<br /> The WM_msgs are, in fact, numbers, and looking in the windows.inc I think that a way to perform these checks is in &quot;partitions&quot;: (sorry for the code but Im writing this from the top of my head)<br /><br />  mov eax, ; take the uMsg <br />  test ah,ah<br />  jz Part00<br />  cmp ah,01h ; check the High Byte<br />  jz Part01<br />  cmp ah,02h <br />  jz Part02<br />  cmp ah,03h <br />  jz Part03<br />  <br />  Part00:<br />         ....check here the messages between 0000h and 00FFh - ie: WM_NULL,WM_CREATE.....WM_NCMBUTTONDBLCLK <br /> Part01:<br />         ....check here the messages between 0100h and 01FFh - ie: WM_KEYFIRST...WM_CTLCOLORSTATIC<br />etc.<br /> <br /> You can test the nibbles for more precision (in Part00: test al,0F0h, jnz ....etc.<br />I think this works like a binary tree ;)<br /> This method has sense when you need to check a lot of messages and are &quot;separated&quot; between the values.<br /> <br /> The other way (the best, I think) is using a lookup table:<br /><br /> .data<br /><br />JumpTable  dd offset EOCheckTable ;WM_NULL<br />                   dd offset InitialDial ;WM_CREATE<br />                   dd offset EOCheckTable ;WM_DESTROY<br />                   dd offset EOCheckTable ;WM_MOVE<br />                   dd offset EOCheckTable         <br />                   dd offset EOCheckTable ;WM_SIZE<br />                   dd offset EOCheckTable ;WM_ACTIVATE<br />                   dd offset EOCheckTable ;WM_SETFOCUS<br />                   dd offset EOCheckTable ;WM_KILLFOCUS<br />                   dd offset EOCheckTable<br />                   dd offset EOCheckTable ;WM_ENABLE<br />           ............<br />           ............<br />           ...........<br />                   dd offset EOCheckTable ;WM_USER<br />........<br /><br />.code<br /><br /> ...........<br />    ;put this for check<br /><br />            mov  eax, ;get uMsg<br />            cmp  eax,400h ;check the upper boundary <br />            ja   UserCommand ;process the message above 400h<br />            Call ProcMsg<br />            test eax,eax<br />            jne  MessageNotProcesed<br /><br /> .............<br /><br /><br /><br /><br />ProcMsg:  add eax,eax<br />                add eax,eax ; uMsg * 4<br />                add eax,offset JumpTable ; add the base of the table<br />                jmp dword ptr  ; jump to the correct message routine<br /><br /><br />EOCheckTable:   mov eax,1 ;return true if the message is not processed<br />                           ret<br /><br />;Process the WM_CREATE msg<br />InitialDial:    MsgBox NULL,&quot;Initializing&quot;,&quot;NSSys&quot;,MB_OK ;a msgbox  sample<br />                ..........<br />                .........<br />                xor eax,eax<br />                ret<br /><br />EOCheckTable is the &quot;default-not-process-message&quot; routine. Obviously, you must write the complete table putting the right offsets when you want to process some message, and you can make things like this if you dont want to write all the table:<br /><br />JumpTable  dd 110h dup (offset EOCheckTable)<br />           dd offset InitialDial ;WM_INITDIALOG<br />           dd 4096 dup (offset EOCheckTable) <br /><br />or doing at runtime whith a simple prog that fill the correct address of the routines you want.<br /><br />The only counterpart for this method is you must waste 4096 bytes for the table (But nowadays I think that is not a serious problem ;) <br /><br />You can combine the two methods too; checking the &quot;partitions&quot; and doing jumptables.<br /><br />Well, I hope that you find this useful.<br /><br />ByeZ<br /><br />PS: I dont remember if there is some penalties in pairing or caching using &quot;Jmp dword ptr &quot; but its 4:12 AM and Im tired and I dont want to read the agner help now...:grin:</div>
    <div class="meta">Posted on 2001-09-23 02:15:10 by NightShade</div>
   </div>
  </div>
 </body>
</html>