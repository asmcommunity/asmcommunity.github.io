<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Hoping for some pointers on this one... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=2523" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=2523">Hoping for some pointers on this one...</a></p>
   <div class="post" id="post-15897">
    <div class="subject"><a href="#post-15897">Hoping for some pointers on this one...</a></div>
    <div class="body">I'm sick of not being able to drag &amp; drop my windows on the taskbar. I have to open my progs in order to get what I want. That sucks! I figure I'll write an app that'll let me do that....but how? I don't know where to start or what method to use or even how to ask the question. This normally means its out of my league but I don't care this time. Its killing me. <br /><br />Just to rehash the question in case it isn't clear here goes:<br /><br />Problem : open windows are grouped on the taskbar in the order we open them. these cannot me moved to one side or another,<br /><br />What I want : to be able to drag said windows to the left/right of other windows<br /><br />Solution : ?<br /><br />Thanks (and sorry bout the lenghty post &amp; ranting),<br />lackluster</div>
    <div class="meta">Posted on 2001-12-23 12:01:09 by lackluster</div>
   </div>
   <div class="post" id="post-15898">
    <div class="subject"><a href="#post-15898">Hoping for some pointers on this one...</a></div>
    <div class="body">oh yeah, preferably on an NT/2000/XP platform.</div>
    <div class="meta">Posted on 2001-12-23 12:02:17 by lackluster</div>
   </div>
   <div class="post" id="post-15904">
    <div class="subject"><a href="#post-15904">Hoping for some pointers on this one...</a></div>
    <div class="body">The taskbar is a tab control so I think you should search for a method to move the tabs on a tab control around. To make them draggable you probably need some hook..<br /><br />Thomas</div>
    <div class="meta">Posted on 2001-12-23 12:28:44 by Thomas</div>
   </div>
   <div class="post" id="post-15940">
    <div class="subject"><a href="#post-15940">Hoping for some pointers on this one...</a></div>
    <div class="body">Implementing D&amp;D on the explorer taskbar may be nontrivial, I' m afraid. <br />But possibly an app can rearrange the &quot;window buttons&quot; by hiding and restoring the related main windows (To hide and restore a window moves the &quot;window button&quot; to the right).</div>
    <div class="meta">Posted on 2001-12-24 00:11:28 by japheth</div>
   </div>
   <div class="post" id="post-15953">
    <div class="subject"><a href="#post-15953">Hoping for some pointers on this one...</a></div>
    <div class="body">There's a freeware program on Hotfiles, called Taskbar Organizer, that seems to do what you want. I haven't looked at it, so I don't know if it uses DD or not.<br /><br /><a target="_blank" href="http://www.zdnet.com/downloads/stories/info/0,10615,77624,00.html">http://www.zdnet.com/downloads/stories/info/0,10615,77624,00.html</a><br /><br />:)</div>
    <div class="meta">Posted on 2001-12-24 06:06:53 by S/390</div>
   </div>
   <div class="post" id="post-16038">
    <div class="subject"><a href="#post-16038">Hoping for some pointers on this one...</a></div>
    <div class="body">That prog is pretty good. I wish I knew how they did it. No DnD though ;(...... still looking into it in case anybody came across a cool tut on how to do it or something similar.<br /><br />thanks</div>
    <div class="meta">Posted on 2001-12-24 23:27:30 by lackluster</div>
   </div>
   <div class="post" id="post-16039">
    <div class="subject"><a href="#post-16039">Hoping for some pointers on this one...</a></div>
    <div class="body">Oh well, I thought it may come with source. Just a wild guess, since I didn't play with it. They do that sometimes with freeware... :grin:</div>
    <div class="meta">Posted on 2001-12-24 23:33:38 by S/390</div>
   </div>
   <div class="post" id="post-16040">
    <div class="subject"><a href="#post-16040">Hoping for some pointers on this one...</a></div>
    <div class="body">nah no source, but wrote a nice email asking the author ( a complete stranger) if he wanted to give a nice christmas gift ;). hopefully he'll help out</div>
    <div class="meta">Posted on 2001-12-24 23:36:37 by lackluster</div>
   </div>
   <div class="post" id="post-16073">
    <div class="subject"><a href="#post-16073">Hoping for some pointers on this one...</a></div>
    <div class="body">Before i start, let me say i have consumed a vast quantitiy of beer :)<br /><br />I don't wnat this to delve too far into the realms of cracking, but try this:<br /><br />- go to either <a target="_blank" href="http://sysinternals.com"><em>www,sysinternals.com</em></a> or  <a target="_blank" href="http://winternals.com/"><em>www.winternals.com</em></a>, and pick up RegSpy, and run it against this app, you may pick up a few valuable clues reagarding how it works.</div>
    <div class="meta">Posted on 2001-12-25 06:23:12 by sluggy</div>
   </div>
   <div class="post" id="post-16074">
    <div class="subject"><a href="#post-16074">Christmas present</a></div>
    <div class="body">I played a bit with tab control messages and I succeeded in reversing the order of the items (but any order is possible)!<br /><br />The code is quite simple, apart from the memory stuff. <br />First I read all item data (TC_ITEM stucts) into a big buffer. Secondly I delete all items. Finally, I put the items back in the reversed order.<br /><br />That wasn't the hardest part. The problem was that I allocated memory for the buffer, but because the message was sent to a window from explorer.exe, the memory pointers were not valid in the memory space of explorer.<br />I used VirtualAlloc<strong>Ex</strong> to allocate a buffer in explorer's memory space, and this did work. It also meant the initialization of the TC_ITEM structs in that buffer had to be done with WriteProcessMemory, because now the memory pointers where not valid in my own program. <br />VirtualAllocEx is only available in NT/2000 but that shouldn't be a problem for you. I think you can use some kind of shared dll in win9x if you really need it.<br /><br />Finding the tab control is a bit messy, I don't know if this method is working on all systems. I just used a spy tool (download it from <br /><a target="_blank" href="http://nan32asm.cjb.net">NaN's site</a>) to get the tab window and see what it's parents are. <br /><br />Thomas<br /><br /><pre><code><br />.data<br />tShTrayWnd      db  &quot;Shell_TrayWnd&quot;,0<br />tRebarCtrl      db  &quot;ReBarWindow32&quot;,0<br />tTaskSwClass    db  &quot;MSTaskSwWClass&quot;,0<br />tSysTabCtrl     db  &quot;SysTabControl32&quot;,0<br /><br />.code<br /><br />MAX_TEXT_BUFFERSIZE     equ     500<br /><br />MoveTaskBarItems    proc uses ebx edi esi<br />LOCAL   tbiCount&#58;DWORD<br />LOCAL   hTaskBar&#58;DWORD<br />LOCAL   explorerPID&#58;DWORD<br />LOCAL   hExplorer&#58;DWORD<br />LOCAL   tempItem&#58;TC_ITEM<br />LOCAL   BytesWritten&#58;DWORD<br /><br />    invoke  FindWindowEx, 0, 0, addr tShTrayWnd, NULL<br />    .IF     !eax<br />        int 3 <br />    .ENDIF<br />    <br />    invoke  FindWindowEx, eax, NULL, addr tRebarCtrl, NULL<br />    .IF     !eax<br />        int 3 ;no taskbar tab control found?<br />    .ENDIF<br />    <br />    invoke  FindWindowEx, eax, NULL, addr tTaskSwClass, NULL<br />    .IF     !eax<br />        int 3 ;no taskbar tab control found?<br />    .ENDIF<br />    <br />    invoke  FindWindowEx, eax, NULL, addr tSysTabCtrl, NULL<br />    .IF     !eax<br />        int 3 ;no taskbar tab control found?<br />    .ENDIF<br />    <br />    mov     hTaskBar, eax<br />    lea     ecx, explorerPID<br />    invoke  GetWindowThreadProcessId, eax, ecx<br />    <br />    <br />    <br /><br />    ; --- Open explorer process ---<br />    invoke  OpenProcess, PROCESS_VM_OPERATION OR PROCESS_VM_WRITE, FALSE, explorerPID<br />    .IF     !eax<br />        int 3<br />    .ENDIF<br />    mov     hExplorer, eax<br />    <br />    ; --- get number of items on taskbar ---<br />    invoke  SendMessage, hTaskBar, TCM_GETITEMCOUNT, 0, 0<br />    or      eax, eax<br />    jz      @no_items<br />    <br />    mov     tbiCount, eax<br /><br />    ; --- items * &#40;sizeof TC_ITEM&#41; + size of text buffer ---<br />    mov     ecx, &#40;SIZEOF TC_ITEM&#41;+ MAX_TEXT_BUFFERSIZE<br />    mul     ecx<br /><br />    ; --- allocate memory in memory space of explorer ---<br />    invoke  VirtualAllocEx, hExplorer, NULL, eax, MEM_COMMIT, PAGE_READWRITE    <br /><br />    ; Note&#58; the allocated memory is an array of &#40;TC_ITEM + TextBuffer&#41;s. <br />    ; The textbuffer is necessary to store the texts on the items<br />    <br />    mov     edi, eax<br />    mov     esi, eax<br />    <br />    ; tempitem is copied into each item before retrieving info<br />    mov     tempItem.imask, TCIF_TEXT OR TCIF_IMAGE OR TCIF_PARAM    <br />    <br />    xor     ebx, ebx<br />    .WHILE  ebx&lt;tbiCount<br /><br />        ; --- let eax point to the text buffer ---<br />        mov     eax, esi<br />        add     eax, SIZEOF TC_ITEM<br />        <br />        ; --- store pointer to textbuffer &amp; size in tempItem ---<br />        mov     tempItem.pszText, eax<br />        mov     tempItem.cchTextMax, MAX_TEXT_BUFFERSIZE<br />        <br />        ; --- Write this into memory space of explorer ---<br />        invoke  WriteProcessMemory, hExplorer, esi, addr tempItem, SIZEOF TC_ITEM, \<br />                    addr BytesWritten<br />        <br />        ; --- Get item info ---<br />        invoke  SendMessage, hTaskBar, TCM_GETITEM, ebx, esi<br />    <br />        ; --- move to next item in array ---<br />        add esi, &#40;SIZEOF TC_ITEM&#41;+ MAX_TEXT_BUFFERSIZE<br />        inc ebx<br />    .ENDW<br />    <br />    ; --- delete everything ---<br />    invoke  SendMessage, hTaskBar, TCM_DELETEALLITEMS, 0, 0<br /><br />    mov     esi, edi<br />    <br />    xor     ebx, ebx<br />    .WHILE  ebx&lt;tbiCount<br />        ; --- get itemcount-currentcounter-1 = new index ---<br />        mov     eax, tbiCount<br />        dec     eax<br />        sub     eax, ebx<br />        xor     eax, eax<br />        <br />        ; --- place item back ---<br />        invoke  SendMessage, hTaskBar, TCM_INSERTITEM, eax, esi<br />        <br />        ; --- move to next item in array ---<br />        add esi, &#40;SIZEOF TC_ITEM&#41; + MAX_TEXT_BUFFERSIZE<br />        inc ebx<br />    .ENDW<br />    <br />    <br />    ; --- free memory ---<br />    invoke  VirtualFreeEx, hExplorer, edi, 0, MEM_RELEASE   <br />    <br />   @no_items&#58;<br />    invoke  CloseHandle, hExplorer<br />ret<br />MoveTaskBarItems endp</code></pre></div>
    <div class="meta">Posted on 2001-12-25 06:23:39 by Thomas</div>
   </div>
   <div class="post" id="post-16087">
    <div class="subject"><a href="#post-16087">Hoping for some pointers on this one...</a></div>
    <div class="body">Cool. If I were female, I'd give you a big sloppy uh.....kiss ;). Maybe if you PM me we can work something out also. Just kidding, but thanks alot :).<br /><br />PS - Can you explain the int 3? Its the only thing that's confusing me:confused: .</div>
    <div class="meta">Posted on 2001-12-25 10:33:43 by lackluster</div>
   </div>
   <div class="post" id="post-16093">
    <div class="subject"><a href="#post-16093">Hoping for some pointers on this one...</a></div>
    <div class="body">The int 3 is nothing special, it's the breakpoint interrupt that most debuggers catch, just place some error handling code there.<br /><br />Thomas</div>
    <div class="meta">Posted on 2001-12-25 11:24:59 by Thomas</div>
   </div>
   <div class="post" id="post-16095">
    <div class="subject"><a href="#post-16095">Hi Thomas what parts are top of the code</a></div>
    <div class="body">I added this to the top, by just guesing<br /><br />.386<br />.model flat,stdcall<br />option casemap:none<br /><br />include \masm32\include\windows.inc<br />include \masm32\include\user32.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\comdlg32.inc<br />includelib \masm32\lib\user32.lib<br />includelib \masm32\lib\kernel32.lib<br />includelib \masm32\lib\comdlg32.lib<br /><br /><br />And I got this error<br /><br />LINK : error LNK2001: unresolved external symbol _WinMainCRTStartup<br />dragdrop.exe : fatal error LNK1120: 1 unresolved externals<br />_<br />Link error<br />Press any key to continue . . .<br /><br />What should be on top?<br /><br />Have a Merry Christmas too Thomas!<br /><br />Andy</div>
    <div class="meta">Posted on 2001-12-25 11:42:14 by andy981</div>
   </div>
   <div class="post" id="post-16108">
    <div class="subject"><a href="#post-16108">Hoping for some pointers on this one...</a></div>
    <div class="body">andy,<br /><br /><pre><code><br />.486<br />.model flat, stdcall<br />option casemap&#58;none<br /><br />include \masm32\include\windows.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\user32.inc<br />includelib \masm32\lib\kernel32.lib<br />includelib \masm32\lib\user32.lib<br /><br />WinMain proto &#58;DWORD, &#58;DWORD, &#58;DWORD, &#58;DWORD<br />MainProc proto &#58;DWORD, &#58;DWORD, &#58;DWORD, &#58;DWORD <br />MoveTaskBarItems proto<br /><br />.data<br />tShTrayWnd      db  &quot;Shell_TrayWnd&quot;,0<br />tRebarCtrl      db  &quot;ReBarWindow32&quot;,0<br />tTaskSwClass    db  &quot;MSTaskSwWClass&quot;,0<br />tSysTabCtrl     db  &quot;SysTabControl32&quot;,0<br />ClsName         db  &quot;MovClass&quot;, 0<br />AppName         db  &quot;Move The Whales&quot;, 0<br /><br />.data?<br />hInstance       dd  ?<br /><br />.code<br /><br />MAX_TEXT_BUFFERSIZE     equ     500<br /><br />Start&#58;<br /><br />invoke GetModuleHandle, NULL<br />mov    hInstance, eax<br />invoke WinMain, hInstance, NULL, NULL, SW_HIDE<br />invoke ExitProcess, eax<br /><br />WinMain proc USES esi edi ebx ebp, hInst&#58;HINSTANCE, hPrevInstance&#58;HINSTANCE, Cmd&#58;LPSTR, nShow&#58;DWORD<br />	LOCAL   wc&#58;WNDCLASSEX<br />    LOCAL  msg&#58;MSG <br />    LOCAL  hwnd&#58;DWORD<br /><br />    mov    wc.cbSize,SIZEOF WNDCLASSEX<br />    mov    wc.style, CS_HREDRAW or CS_VREDRAW <br />    mov    wc.lpfnWndProc, OFFSET MainProc <br />    mov    wc.cbClsExtra,NULL <br />    mov    wc.cbWndExtra,NULL <br />    push   hInstance <br />    pop    wc.hInstance <br />    mov    wc.hbrBackground,COLOR_WINDOW+1 <br />    mov    wc.lpszMenuName,NULL <br />    mov    wc.lpszClassName,OFFSET ClsName <br />    invoke LoadIcon,NULL,IDI_APPLICATION <br />    mov    wc.hIcon,eax <br />    mov    wc.hIconSm,eax <br />    invoke LoadCursor,NULL,IDC_ARROW <br />    mov    wc.hCursor,eax <br />    invoke RegisterClassEx, addr wc<br />    invoke CreateWindowEx, NULL, addr ClsName, addr AppName, WS_VISIBLE or WS_OVERLAPPEDWINDOW, \<br />    		CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInst, NULL<br />	mov    hwnd, eax<br />	.WHILE TRUE<br />		invoke GetMessage, addr msg, NULL, 0, 0<br />		.BREAK .IF eax == 0<br />		invoke TranslateMessage, addr msg<br />		invoke DispatchMessage, addr msg<br />	.endw<br />	mov  eax, msg.wParam<br />	ret<br />WinMain endp<br /><br />MainProc proc USES edi esi ebx ebp, hWnd&#58;HWND, uMsg&#58;UINT, wParam&#58;WPARAM, lParam&#58;LPARAM<br />	.IF uMsg == WM_CLOSE<br />		invoke PostQuitMessage, NULL<br />	.ELSEIF uMsg == WM_LBUTTONDOWN<br />		invoke MoveTaskBarItems<br />	.ELSE <br />		invoke DefWindowProc, hWnd, uMsg, wParam, lParam<br />		ret<br />	.ENDIF<br />	mov  eax, FALSE<br />	ret<br />MainProc endp<br /><br /><br />MoveTaskBarItems    proc uses ebx edi esi<br />LOCAL   tbiCount&#58;DWORD<br />LOCAL   hTaskBar&#58;DWORD<br />LOCAL   explorerPID&#58;DWORD<br />LOCAL   hExplorer&#58;DWORD<br />LOCAL   tempItem&#58;TC_ITEM<br />LOCAL   BytesWritten&#58;DWORD<br /><br />    invoke  FindWindowEx, 0, 0, addr tShTrayWnd, NULL<br />    .IF     !eax<br />        int 3 <br />    .ENDIF<br />    <br />    invoke  FindWindowEx, eax, NULL, addr tRebarCtrl, NULL<br />    .IF     !eax<br />        int 3 ;no taskbar tab control found?<br />    .ENDIF<br />    <br />    invoke  FindWindowEx, eax, NULL, addr tTaskSwClass, NULL<br />    .IF     !eax<br />        int 3 ;no taskbar tab control found?<br />    .ENDIF<br />    <br />    invoke  FindWindowEx, eax, NULL, addr tSysTabCtrl, NULL<br />    .IF     !eax<br />        int 3 ;no taskbar tab control found?<br />    .ENDIF<br />    <br />    mov     hTaskBar, eax<br />    lea     ecx, explorerPID<br />    invoke  GetWindowThreadProcessId, eax, ecx<br />    <br />    <br />    <br /><br />    ; --- Open explorer process ---<br />    invoke  OpenProcess, PROCESS_VM_OPERATION OR PROCESS_VM_WRITE, FALSE, explorerPID<br />    .IF     !eax<br />        int 3<br />    .ENDIF<br />    mov     hExplorer, eax<br />    <br />    ; --- get number of items on taskbar ---<br />    invoke  SendMessage, hTaskBar, TCM_GETITEMCOUNT, 0, 0<br />    or      eax, eax<br />    jz      @no_items<br />    <br />    mov     tbiCount, eax<br /><br />    ; --- items * &#40;sizeof TC_ITEM&#41; + size of text buffer ---<br />    mov     ecx, &#40;SIZEOF TC_ITEM&#41;+ MAX_TEXT_BUFFERSIZE<br />    mul     ecx<br /><br />    ; --- allocate memory in memory space of explorer ---<br />    invoke  VirtualAllocEx, hExplorer, NULL, eax, MEM_COMMIT, PAGE_READWRITE    <br /><br />    ; Note&#58; the allocated memory is an array of &#40;TC_ITEM + TextBuffer&#41;s. <br />    ; The textbuffer is necessary to store the texts on the items<br />    <br />    mov     edi, eax<br />    mov     esi, eax<br />    <br />    ; tempitem is copied into each item before retrieving info<br />    mov     tempItem.imask, TCIF_TEXT OR TCIF_IMAGE OR TCIF_PARAM    <br />    <br />    xor     ebx, ebx<br />    .WHILE  ebx&lt;tbiCount<br /><br />        ; --- let eax point to the text buffer ---<br />        mov     eax, esi<br />        add     eax, SIZEOF TC_ITEM<br />        <br />        ; --- store pointer to textbuffer &amp; size in tempItem ---<br />        mov     tempItem.pszText, eax<br />        mov     tempItem.cchTextMax, MAX_TEXT_BUFFERSIZE<br />        <br />        ; --- Write this into memory space of explorer ---<br />        invoke  WriteProcessMemory, hExplorer, esi, addr tempItem, SIZEOF TC_ITEM, \<br />                    addr BytesWritten<br />        <br />        ; --- Get item info ---<br />        invoke  SendMessage, hTaskBar, TCM_GETITEM, ebx, esi<br />    <br />        ; --- move to next item in array ---<br />        add esi, &#40;SIZEOF TC_ITEM&#41;+ MAX_TEXT_BUFFERSIZE<br />        inc ebx<br />    .ENDW<br />    <br />    ; --- delete everything ---<br />    invoke  SendMessage, hTaskBar, TCM_DELETEALLITEMS, 0, 0<br /><br />    mov     esi, edi<br />    <br />    xor     ebx, ebx<br />    .WHILE  ebx&lt;tbiCount<br />        ; --- get itemcount-currentcounter-1 = new index ---<br />        mov     eax, tbiCount<br />        dec     eax<br />        sub     eax, ebx<br />        xor     eax, eax<br />        <br />        ; --- place item back ---<br />        invoke  SendMessage, hTaskBar, TCM_INSERTITEM, eax, esi<br />        <br />        ; --- move to next item in array ---<br />        add esi, &#40;SIZEOF TC_ITEM&#41; + MAX_TEXT_BUFFERSIZE<br />        inc ebx<br />    .ENDW<br />    <br />    <br />    ; --- free memory ---<br />    invoke  VirtualFreeEx, hExplorer, edi, 0, MEM_RELEASE   <br />    <br />   @no_items&#58;<br />    invoke  CloseHandle, hExplorer<br />ret<br />MoveTaskBarItems endp<br /><br />end Start<br /></code></pre><br /><br />cut-paste-complie</div>
    <div class="meta">Posted on 2001-12-25 12:34:07 by lackluster</div>
   </div>
   <div class="post" id="post-16109">
    <div class="subject"><a href="#post-16109">Thanks Lackluster</a></div>
    <div class="body">Thanks Lackluster<br /><br />I got it running<br /><br />And <br /><br />Merry Christmas<br /><br />Andy!</div>
    <div class="meta">Posted on 2001-12-25 12:49:55 by andy981</div>
   </div>
   <div class="post" id="post-16617">
    <div class="subject"><a href="#post-16617">Hoping for some pointers on this one...</a></div>
    <div class="body">In a recent / latest issue of PCMagazine is a<br />utility called &quot;Button Boogie&quot; which does this.<br />Source code is available at <br /><br /><a target="_blank" href="www.pcmag.com/utilities">www.pcmag.com/utilities</a><br /><br />farrier</div>
    <div class="meta">Posted on 2001-12-29 11:31:23 by farrier</div>
   </div>
  </div>
 </body>
</html>