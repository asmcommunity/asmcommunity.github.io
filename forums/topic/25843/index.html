<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Retrieve the remainder of a number divided by 160 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25843" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25843">Retrieve the remainder of a number divided by 160</a></p>
   <div class="post" id="post-188467">
    <div class="subject"><a href="#post-188467">Retrieve the remainder of a number divided by 160</a></div>
    <div class="body">Somewhere in my OS I need to divide a number by 160 and retrieve the remainder. This might happen a lot so I thought of an alternative to the DIV instruction and wrote the below code in which the EAX holds the numerator and after the computations, it will contain the remainder. I was wondering if any of you could please suggest a better and perhaps faster way. (The code takes 12 clock cycles to execute on my PIII 800 MHZ).<br /><br /><pre><code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Input -&gt; EAX = Numerator<br />&nbsp; MOV&nbsp; &nbsp;  EBX , EAX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Save the Numerator temporarily in EBX<br />&nbsp; MOV&nbsp; &nbsp;  ECX , 0xCCCCCCCD&nbsp; &nbsp; &nbsp; &nbsp; ; Constant Reciprocal Multiplier of 160<br />&nbsp; MUL&nbsp; &nbsp;  ECX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; EDX = EAX DIV 160<br />&nbsp; MOV&nbsp; &nbsp;  EAX , EBX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; EAX is the Numerator again<br />&nbsp; SHR&nbsp; &nbsp;  EDX , 0x00000002&nbsp; &nbsp; &nbsp; &nbsp; ; SHR EDX 0x07 &amp; SHL EDX 0x05, Step 1<br />&nbsp; AND&nbsp; &nbsp;  EDX , 0xFFFFFFE0&nbsp; &nbsp; &nbsp; &nbsp; ; SHR EDX 0x07 &amp; SHL EDX 0x05, Step 1<br />&nbsp; LEA&nbsp; &nbsp;  EDX , &nbsp; ; Multiply EDX by 160, Step 2<br />&nbsp; SUB&nbsp; &nbsp;  EAX , EDX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; EAX = Remainder of (EAX DIV 160)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Output &lt;- EAX = Remainder</code></pre></div>
    <div class="meta">Posted on 2007-03-18 03:54:55 by XCHG</div>
   </div>
   <div class="post" id="post-188469">
    <div class="subject"><a href="#post-188469">Re: Retrieve the remainder of a number divided by 160</a></div>
    <div class="body"><div class="quote"><br />Somewhere in my OS I need to divide a number by 160 and retrieve the remainder. This might happen a lot so I thought of an alternative to the DIV instruction and wrote the below code in which the EAX holds the numerator and after the computations, it will contain the remainder. I was wondering if any of you could please suggest a better and perhaps faster way. (The code takes 12 clock cycles to execute on my PIII 800 MHZ).<br /><br /><pre><code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Input -&gt; EAX = Numerator<br />&nbsp; MOV&nbsp; &nbsp;  EBX , EAX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Save the Numerator temporarily in EBX<br />&nbsp; MOV&nbsp; &nbsp;  ECX , 0xCCCCCCCD&nbsp; &nbsp; &nbsp; &nbsp; ; Constant Reciprocal Multiplier of 160<br />&nbsp; MUL&nbsp; &nbsp;  ECX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; EDX = EAX DIV 160<br />&nbsp; MOV&nbsp; &nbsp;  EAX , EBX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; EAX is the Numerator again<br />&nbsp; SHR&nbsp; &nbsp;  EDX , 0x00000002&nbsp; &nbsp; &nbsp; &nbsp; ; SHR EDX 0x07 &amp; SHL EDX 0x05, Step 1<br />&nbsp; AND&nbsp; &nbsp;  EDX , 0xFFFFFFE0&nbsp; &nbsp; &nbsp; &nbsp; ; SHR EDX 0x07 &amp; SHL EDX 0x05, Step 1<br />&nbsp; LEA&nbsp; &nbsp;  EDX , &nbsp; ; Multiply EDX by 160, Step 2<br />&nbsp; SUB&nbsp; &nbsp;  EAX , EDX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; EAX = Remainder of (EAX DIV 160)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Output &lt;- EAX = Remainder</code></pre><br /></div><br /><br />What is this instance that requires to divide by 160?</div>
    <div class="meta">Posted on 2007-03-18 04:30:28 by SpooK</div>
   </div>
   <div class="post" id="post-188471">
    <div class="subject"><a href="#post-188471">Re: Retrieve the remainder of a number divided by 160</a></div>
    <div class="body">One of the procedures that uses this computation is my __CarriageReturn procedure in my Video Driver. I have defined a global variable called VideoCursor which holds the number of bytes that should be added to the start of the Video Segment in order to retrieve the current Video Cursor so that I will know if I should write a character to the screen, where it should go. Now if the user presses Enter, I should divide this value by 160 (160 bytes per row in 80*25) and then get the remainder. The remainder will be subtracted from this value to get the position of the character at the beginning of the current line.<br /><br />The code that I have written for this procedure is:<br /><br /><pre><code>&nbsp; __CarriageReturn:<br />&nbsp; &nbsp; ; void __CarriageReturn (void)<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; EAX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Push the accumulator onto the stack<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; EBX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Push the base index onto the stack<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; ECX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Push the count register onto the stack<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; EDX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Push the data register onto the stack<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  EAX , DWORD PTR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Move the value of the  global variable into EAX<br />&nbsp; &nbsp; TEST&nbsp; &nbsp; EAX , EAX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; See if we are at the first row, first column?<br />&nbsp; &nbsp; JE&nbsp; &nbsp; &nbsp; .EP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; If yes, there is no need to move to the beginning of the line<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  EBX , EAX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Put the value of  in the base index temporarily<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  ECX , 0xCCCCCCCD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; The reciprocal multiplier for EAX<br />&nbsp; &nbsp; NOP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Prevent dependence chain<br />&nbsp; &nbsp; MUL&nbsp; &nbsp;  ECX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Multiply EAX by ECX (EDX = EAX/ECX)<br />&nbsp; &nbsp; SHR&nbsp; &nbsp;  EDX , 0x00000002&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; SHR EDX 0x07 And SHL EDX 0x07 = SHR EDX 0x02<br />&nbsp; &nbsp; AND&nbsp; &nbsp;  EDX , 0xFFFFFFE0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Remove bits 0 through 4 (inclusive) in the result (Multiply by 160)<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  EAX , EBX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; EAX holds the original number now<br />&nbsp; &nbsp; LEA&nbsp; &nbsp;  EDX , &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; EDX = EDX * 160 (Step 2)<br />&nbsp; &nbsp; SUB&nbsp; &nbsp;  EAX , EDX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; EAX = EAX Mod 160<br />&nbsp; &nbsp; SUB&nbsp; &nbsp;  DWORD PTR  , EAX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Subtract the remainder from the video cursor, beginning of the line<br />&nbsp; &nbsp; .EP:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; End of the procedure<br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp;  EDX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Restore the data register<br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp;  ECX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Restore the count register<br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp;  EBX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Push the base index onto the stack<br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp;  EAX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Restore the accumulator<br />&nbsp; &nbsp; RET&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Return to the calling procedure, no parameters to remove</code></pre></div>
    <div class="meta">Posted on 2007-03-18 04:59:32 by XCHG</div>
   </div>
   <div class="post" id="post-188472">
    <div class="subject"><a href="#post-188472">Re: Retrieve the remainder of a number divided by 160</a></div>
    <div class="body">Sounds like you would be better off keeping track of X/Y instead of an absolute calculation. You can always multiply X*Y when needed.<br /><br /><pre><code><br />;ebx = x<br />;ecx = y<br />xor ebx,ebx<br />inc ecx<br /></code></pre><br /><br />This comes in even more handy when you have to deal with &quot;scrolling&quot; the screen and whatnot ;)</div>
    <div class="meta">Posted on 2007-03-18 05:38:35 by SpooK</div>
   </div>
   <div class="post" id="post-188477">
    <div class="subject"><a href="#post-188477">Re: Retrieve the remainder of a number divided by 160</a></div>
    <div class="body">Position calculation for your textmode buffer is <strong>not</strong> going to be a speed-critical piece of code, you&#39;re wasting your time on doing micro-optimizations when that time could be spent better elsewhere.<br /></div>
    <div class="meta">Posted on 2007-03-18 10:59:57 by f0dder</div>
   </div>
   <div class="post" id="post-188490">
    <div class="subject"><a href="#post-188490">Re: Retrieve the remainder of a number divided by 160</a></div>
    <div class="body"><div class="quote"><br />Sounds like you would be better off keeping track of X/Y instead of an absolute calculation. You can always multiply X*Y when needed.</div><br />I would agree with that - with a CR, you would just make x=0, and a LF y+1.<br /><br />You could also use a lookup table filled with line start addresses. (26*4=only 104 bytes for the table)</div>
    <div class="meta">Posted on 2007-03-19 03:12:59 by sinsi</div>
   </div>
   <div class="post" id="post-188491">
    <div class="subject"><a href="#post-188491">Re: Retrieve the remainder of a number divided by 160</a></div>
    <div class="body">I don&#39;t know but you see, when using a relative cursor position like what I am doing, you will only access a global variable once, and for example printing a character to the screen, add 0x00000002 to it for having moved forward 1 character (+1 attribute) but when you want to have X and Y separately, you will have to read both of them, do the calculation on both of them and store them both to their memory locations. This is also a problem when applying back spaces to the screen because you are going to have to calculate more than relative addresses. I tried implementing this method today and saw all these problems and just thought maybe I shouldn&#39;t do it.<br /><br />Below is my yet-uncommented Write Character procedure.<br /><br /><pre><code>&nbsp; __WriteChar:<br />&nbsp; &nbsp; ; void __WriteChar (DWORD TheChar) ; StdCall;<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; EAX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; <br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; EBX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; <br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; EBP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; <br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  EBP , ESP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; <br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  EAX , DWORD PTR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; <br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  AH , 0x0F&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; <br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  EBX , VIDEOSEGMENT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; <br />&nbsp; &nbsp; ADD&nbsp; &nbsp;  EBX , DWORD PTR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; <br />&nbsp; &nbsp; CMP&nbsp; &nbsp;  EBX , VIDEOSEGMENT + VIDEOBYTECOUNT&nbsp; &nbsp; &nbsp; &nbsp;  ; <br />&nbsp; &nbsp; JB&nbsp; &nbsp; &nbsp; .NoScrolls&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; <br />&nbsp; &nbsp; INVOKE&nbsp; __ScrollUp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; <br />&nbsp; &nbsp; SUB&nbsp; &nbsp;  EBX , 160&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; <br />&nbsp; &nbsp; .NoScrolls:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; <br />&nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp;  WORD PTR  , AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; <br />&nbsp; &nbsp; &nbsp; ADD&nbsp; &nbsp;  DWORD PTR  , 02h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; <br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp;  EBP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; <br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp;  EBX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; <br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp;  EAX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; <br />&nbsp; &nbsp; RET&nbsp; &nbsp;  0x04&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; </code></pre><br /><br />But if I had separate variables for X and Y, I had to multiply the Y by 80, multiply the X by 2, add the segment to the result and all that stuff. I really like to hear some opinions about this. I would implement the X and Y approach if I knew the advantages. My Scroll procedure is also implemented easily using this approach. Thank you guys in advance.<br /><br /></div>
    <div class="meta">Posted on 2007-03-19 04:13:12 by XCHG</div>
   </div>
   <div class="post" id="post-188492">
    <div class="subject"><a href="#post-188492">Re: Retrieve the remainder of a number divided by 160</a></div>
    <div class="body"><div class="quote"><br />But if I had separate variables for X and Y, I had to multiply the Y by 80, multiply the X by 2, add the segment to the result and all that stuff.</div><br />Use a lookup table - there&#39;s your Y. Then shl X, add Y and there&#39;s your address. This can work for any text resolution - even 132x50 VESA modes.</div>
    <div class="meta">Posted on 2007-03-19 04:41:28 by sinsi</div>
   </div>
  </div>
 </body>
</html>