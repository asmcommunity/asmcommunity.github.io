<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Compressing To Jpg - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19005" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=19005">Compressing To Jpg</a></p>
   <div class="post" id="post-147033">
    <div class="subject"><a href="#post-147033">Compressing To Jpg</a></div>
    <div class="body">Hi.<br /><br />I don't speak English very well, so please sorry my English...<br /><br />OK, i'am looking to a Source Code (In MASM of course) to Compress Images to JPEG  format,<br />or Create Images  directly to this format...<br /><br />I want that the size of the images be less to 200kb to be able to send it to a server.<br /><br />Please help me.<br />:confused: :confused: :confused:<br />Thanks.</div>
    <div class="meta">Posted on 2004-07-28 14:26:16 by </div>
   </div>
   <div class="post" id="post-147047">
    <div class="subject"><a href="#post-147047">Compressing To Jpg</a></div>
    <div class="body"><a target="_blank" href="http://www.comrade64.com/sources/imgview.zip">http://www.comrade64.com/sources/imgview.zip</a></div>
    <div class="meta">Posted on 2004-07-28 19:06:06 by comrade</div>
   </div>
   <div class="post" id="post-147049">
    <div class="subject"><a href="#post-147049">Compressing To Jpg</a></div>
    <div class="body">There are a few steps to compressing raw image data into the JPEG format:<br /><br />1) Afine transformation - convert Red, Green, Blue (RGB) signals into luminance and chromimance (YCbCr).  This is a simple matrix multiply:<br /><br /><pre><code><br />RGB -&gt; YCbCr<br />  | Y  |     |  0.299       0.587       0.114 |   | R |     | 0 |<br />  | Cb |  =  |- 0.1687    - 0.3313      0.5   | * | G |   + |128|<br />  | Cr |     |  0.5       - 0.4187    - 0.0813|   | B |     |128|<br /></code></pre><br /><br />It's the same taking YCbCr back to RGB, but with the differant matrix of course.  Here is some sample code (written in C for which I appologize) that does both.<br /><br /><pre><code><br />void RGBtoYCbCr&#40; unsigned char r, unsigned char g, unsigned char b, unsigned char *Y, unsigned char *Cb, unsigned char *Cr &#41;<br />&#123;<br />  // Y  = 0.299 * R + 0.587 * G + 0.114 * B<br />  &#40;*Y&#41;  = &#40;unsigned char&#41;&#40; &#40;5016388 * r + 9848226 * g + 1912603 * b&#41; &gt;&gt; 24 &#41;;<br />  // Cb = -0.1687 * R - 0.3313 * G + 0.5 * B + 128<br />  &#40;*Cb&#41; = &#40;unsigned char&#41;&#40; &#40;&#40;8388608 * b - 2830316 * r - 5558292 * g&#41; &gt;&gt; 24&#41; + 128 &#41;;<br />  // Cr = 0.5 * R - 0.4187 * G - 0.0813 * B + 128<br />  &#40;*Cr&#41; = &#40;unsigned char&#41;&#40; &#40;&#40;8388608 * r - 7024620 * g - 1363988 * b&#41; &gt;&gt; 24&#41; + 128 &#41;;<br />&#125;<br /></code></pre><br /><br />and <br /><br /><pre><code><br />void YCbCrtoRGB&#40; unsigned char Y, unsigned char Cb, unsigned char Cr, unsigned char *r, unsigned char *g, unsigned char *b &#41;<br />&#123;<br />  // R = Y + 1.402 * &#40;Cr-128&#41;<br />  &#40;*r&#41; = &#40;unsigned char&#41;&#40; Y + &#40;&#40;23521657 * &#40;Cr-128&#41;&#41; &gt;&gt; 24&#41; &#41;;<br />  // G = Y - 0.34414 * &#40;Cb-128&#41; - 0.71414 * &#40;Cr-128&#41;<br />  &#40;*g&#41; = &#40;unsigned char&#41;&#40; Y - &#40;&#40;-5773711 * &#40;Cb-128&#41; - 11981281 * &#40;Cr-128&#41;&#41; &gt;&gt; 24&#41; &#41;;<br />  // B = Y + 1.772 * &#40;Cb-128&#41;<br />  &#40;*b&#41; = &#40;unsigned char&#41;&#40; Y + &#40;&#40;29729227 * &#40;Cb-128&#41;&#41; &gt;&gt; 24&#41; &#41;;<br />&#125;<br /></code></pre><br /><br />So, that's the first step.<br /><br />2) Sampling - The JPEG standard creators realized that the human eye was more sensitive to changes in brightness rather than changes in color, the raw image data should be sampled in such a way that there is twice as much luminance (one sample per pixel) than chrominance (one sample for ever two pixels).<br /><br />3) Level shift - All 8-bit YCbCr values are level shifted by converting them to a 8-bit signed representation (subtract 128).<br /><br />4) Discrete Cosine Transform (DCT) - Now it starts to get really fun.  The DCT converts the spacial data of the raw image into the frequency domain.  This is a rather complicated process (that's a bit of an understatement), but garners amazing results.  The mathematical definition of the DCT is as follows:<br /><br /><pre><code><br />	   c&#40;u,v&#41;     7   7                 2*x+1                2*y+1<br />F&#40;u,v&#41; = --------- * sum sum f&#40;x,y&#41; * cos &#40;------- *u*PI&#41;* cos &#40;------ *v*PI&#41;<br />	     4       x=0 y=0                 16                   16<br /><br /> u,v = 0,1,...,7<br /><br />	  &#123; 1/2 when u=v=0<br /> c&#40;u,v&#41; = &#123; 1/sqrt&#40;2&#41; when  u=0, v!=0<br />          &#123; 1/sqrt&#40;2&#41; when u!=0, v=0<br />	  &#123;  1 otherwise<br /></code></pre><br /><br />And the inverse DCT is:<br /><br /><pre><code><br />	   1     7   7                      2*x+1                2*y+1<br />f&#40;x,y&#41; =  --- * sum sum c&#40;u,v&#41;*F&#40;u,v&#41;*cos &#40;------- *u*PI&#41;* cos &#40;------ *v*PI&#41;<br />	   4    u=0 v=0                      16                   16<br /><br /> x,y=0,1...7<br /></code></pre><br /><br />Here is some sample source code (again written in C):<br /><br /><pre><code><br />void dct8x8&#40; int data&#91;8&#93;&#91;8&#93; &#41;<br />&#123;<br />  static const int c1   = 1004;   // cos&#40; PI / 16 &#41; * 2^10<br />  static const int s1   = 200;    // sin&#40; PI / 16 &#41; * 2^10<br />  static const int c3   = 851;    // cos&#40; 3 * PI / 16 &#41; * 2^10<br />  static const int s3   = 569;    // sin&#40; 3 * PI / 16 &#41; * 2^10<br />  static const int r2c6 = 554;    // sqrt&#40; 2 &#41; * cos&#40; 6 * PI / 16 &#41; * 2^10<br />  static const int r2s6 = 1337;   // sqrt&#40; 2 &#41; * sin&#40; 6 * PI / 16 &#41; * 2^10<br />  static const int r2   = 362;    // sqrt&#40; 2 &#41; * 2^8<br /><br />  int i, temp&#91;8&#93;&#91;8&#93;;<br />  int x0, x1, x2, x3, x4, x5, x6, x7, x8;<br /><br />  // Do the rows...<br />  for&#40; i = 0 ; i &lt; 8 ; i++ &#41;<br />  &#123;<br />    x0 = data&#91;i&#93;&#91;0&#93;; x1 = data&#91;i&#93;&#91;1&#93;; x2 = data&#91;i&#93;&#91;2&#93;; x3 = data&#91;i&#93;&#91;3&#93;;<br />    x4 = data&#91;i&#93;&#91;4&#93;; x5 = data&#91;i&#93;&#91;5&#93;; x6 = data&#91;i&#93;&#91;6&#93;; x7 = data&#91;i&#93;&#91;7&#93;;<br /><br />    // Stage 1<br />    x8 = x7 + x0; x0 -= x7; x7 = x1 + x6; x1 -= x6;<br />    x6 = x2 + x5; x2 -= x5; x5 = x3 + x4; x3 -= x4;<br /><br />    // Stage 2<br />    x4 = x8 + x5;                     x8 -= x5;<br />    x5 = x7 + x6;                     x7 -= x6;<br />    x6 = c1 * &#40;x1 + x2&#41;;              x2 = &#40;-s1 - c1&#41; * x2 + x6;<br />    x1 = &#40;s1 - c1&#41; * x1 + x6;         x6 = c3 * &#40;x0 + x3&#41;;<br />    x3 = &#40;-s3 - c3&#41; * x3 + x6;        x0 = &#40;s3 - c3&#41; * x0 + x6;<br /><br />    // Stage 3<br />    x6 = x4 + x5;                     x4 -= x5;<br />    x5 = r2c6 * &#40;x7 + x8&#41;;            x7 = &#40;-r2s6 - r2c6&#41; * x7 + x5;<br />    x8 = &#40;r2s6 - r2c6&#41; * x8 + x5;     x5 = x0 + x2; x0 -= x2;<br />    x2 = x3 + x1; x3 -= x1;<br /><br />    // Stage 4, rounding and output<br />    temp&#91;i&#93;&#91;0&#93; = x6;                 temp&#91;i&#93;&#91;4&#93; = x4;<br />    temp&#91;i&#93;&#91;2&#93; = &#40;x8+512&#41;&gt;&gt;10;       temp&#91;i&#93;&#91;6&#93; = &#40;x7+512&#41;&gt;&gt;10;<br />    temp&#91;i&#93;&#91;7&#93; = &#40;x2-x5+512&#41;&gt;&gt;10;    temp&#91;i&#93;&#91;1&#93; = &#40;x2+x5+512&#41;&gt;&gt;10;<br />    temp&#91;i&#93;&#91;3&#93; = &#40;x3*r2+65536&#41;&gt;&gt;18;  temp&#91;i&#93;&#91;5&#93; = &#40;x0*r2+65536&#41;&gt;&gt;18;<br />  &#125;<br /><br />  // Do the columns...<br />  for&#40; i = 0 ; i &lt; 8 ; i++ &#41;<br />  &#123;<br />    x0 = temp&#91;0&#93;&#91;i&#93;; x1 = temp&#91;1&#93;&#91;i&#93;; x2 = temp&#91;2&#93;&#91;i&#93;; x3 = temp&#91;3&#93;&#91;i&#93;;<br />    x4 = temp&#91;4&#93;&#91;i&#93;; x5 = temp&#91;5&#93;&#91;i&#93;; x6 = temp&#91;6&#93;&#91;i&#93;; x7 = temp&#91;7&#93;&#91;i&#93;;<br /><br />    // Stage 1<br />    x8 = x7 + x0; x0 -= x7; x7 = x1 + x6; x1 -= x6;<br />    x6 = x2 + x5; x2 -= x5; x5 = x3 + x4; x3 -= x4;<br /><br />    // Stage 2<br />    x4 = x8 + x5;                     x8 -= x5;<br />    x5 = x7 + x6;                     x7 -= x6;<br />    x6 = c1 * &#40;x1 + x2&#41;;              x2 = &#40;-s1 - c1&#41; * x2 + x6;<br />    x1 = &#40;s1 - c1&#41; * x1 + x6;         x6 = c3 * &#40;x0 + x3&#41;;<br />    x3 = &#40;-s3 - c3&#41; * x3 + x6;        x0 = &#40;s3 - c3&#41; * x0 + x6;<br /><br />    // Stage 3<br />    x6 = x4 + x5;                     x4 -= x5;<br />    x5 = r2c6 * &#40;x7 + x8&#41;;            x7 = &#40;-r2s6 - r2c6&#41; * x7 + x5;<br />    x8 = &#40;r2s6 - r2c6&#41; * x8 + x5;     x5 = x0 + x2; x0 -= x2;<br />    x2 = x3 + x1; x3 -= x1;<br /><br />    // Stage 4, rounding and output<br />    data&#91;0&#93;&#91;i&#93; = x6;                 data&#91;4&#93;&#91;i&#93; = x4;<br />    data&#91;2&#93;&#91;i&#93; = &#40;x8+512&#41;&gt;&gt;10;       data&#91;6&#93;&#91;i&#93; = &#40;x7+512&#41;&gt;&gt;10;<br />    data&#91;7&#93;&#91;i&#93; = &#40;x2-x5+512&#41;&gt;&gt;10;    data&#91;1&#93;&#91;i&#93; = &#40;x2+x5+512&#41;&gt;&gt;10;<br />    data&#91;3&#93;&#91;i&#93; = &#40;x3*r2+65536&#41;&gt;&gt;18;  data&#91;5&#93;&#91;i&#93; = &#40;x0*r2+65536&#41;&gt;&gt;18;<br />  &#125;<br />&#125;<br /></code></pre><br /><br />and the Inverse DCT:<br /><br /><pre><code><br />void idct8x8&#40; int data&#91;8&#93;&#91;8&#93; &#41;<br />&#123;<br />  static const int c1   = 1004;   // cos&#40; PI / 16 &#41; * 2^10<br />  static const int s1   = 200;    // sin&#40; PI / 16 &#41; * 2^10<br />  static const int c3   = 851;    // cos&#40; 3 * PI / 16 &#41; * 2^10<br />  static const int s3   = 569;    // sin&#40; 3 * PI / 16 &#41; * 2^10<br />  static const int r2c6 = 554;    // sqrt&#40; 2 &#41; * cos&#40; 6 * PI / 16 &#41; * 2^10<br />  static const int r2s6 = 1337;   // sqrt&#40; 2 &#41; * sin&#40; 6 * PI / 16 &#41; * 2^10<br />  static const int r2   = 362;    // sqrt&#40; 2 &#41; * 2^8<br /><br />  int i, temp&#91;8&#93;&#91;8&#93;;<br />  int x0, x1, x2, x3, x4, x5, x6, x7, x8;<br /><br />  // Do the rows...<br />  for&#40; i = 0 ; i &lt; 8 ; i++ &#41;<br />  &#123;<br />    // Stage 4<br />    x0 = data&#91;i&#93;&#91;0&#93; &lt;&lt; 10; x1 = data&#91;i&#93;&#91;1&#93; &lt;&lt; 8;  x2 = data&#91;i&#93;&#91;2&#93;;<br />    x3 = data&#91;i&#93;&#91;3&#93; *  r2; x4 = data&#91;i&#93;&#91;4&#93; &lt;&lt; 10; x5 = data&#91;i&#93;&#91;5&#93; * r2;<br />    x6 = data&#91;i&#93;&#91;6&#93;;       x7 = data&#91;i&#93;&#91;7&#93; &lt;&lt; 8;  x8 = x7 + x1;<br />    x1 -= x7;<br /><br />    // Stage 3<br />    x7 = x0 + x4;                 x0 -= x4;<br />    x4 = x1 + x5;                 x1 -= x5;<br />    x5 = x3 + x8;                 x8 -= x3;<br />    x3 = r2c6 * &#40;x2 + x6&#41;;        x6 = x3 + &#40;-r2c6 - r2s6&#41; * x6;<br />    x2 = x3 + &#40;-r2c6 + r2s6&#41; * x2;<br /><br />    // Stage 2<br />    x3 = x7 + x2;                 x7 -= x2;<br />    x2 = x0 + x6;                 x0 -= x6;<br />    x6 = c3 * &#40;x4 + x5&#41;;          x5 = &#40;x6 + &#40;-c3 - s3&#41; * x5&#41; &gt;&gt; 8;<br />    x4 = &#40;x6 + &#40;-c3 + s3&#41; * x4&#41; &gt;&gt; 8;<br />    x6 = c1 * &#40;x1 + x8&#41;;          x1 = &#40;x6 + &#40;-c1 - s1&#41; * x1&#41; &gt;&gt; 8;<br />    x8 = &#40;x6 + &#40;-c1 + s1&#41; * x8&#41; &gt;&gt; 8;<br /><br />    // Stage 1, rounding and output<br />    x7 += 4096; x2 += 4096; x0 += 4096; x3 += 4096;<br />    temp&#91;i&#93;&#91;0&#93;=&#40;x3 + x4&#41; &gt;&gt; 13;    temp&#91;i&#93;&#91;1&#93; = &#40;x2 + x8&#41; &gt;&gt; 13;<br />    temp&#91;i&#93;&#91;2&#93;=&#40;x0 + x1&#41; &gt;&gt; 13;    temp&#91;i&#93;&#91;3&#93; = &#40;x7 + x5&#41; &gt;&gt; 13;<br />    temp&#91;i&#93;&#91;4&#93;=&#40;x7 - x5&#41; &gt;&gt; 13;    temp&#91;i&#93;&#91;5&#93; = &#40;x0 - x1&#41; &gt;&gt; 13;<br />    temp&#91;i&#93;&#91;6&#93;=&#40;x2 - x8&#41; &gt;&gt; 13;    temp&#91;i&#93;&#91;7&#93; = &#40;x3 - x4&#41; &gt;&gt; 13;<br />  &#125;<br /><br />  // Do the columns...<br />  for&#40; i = 0 ; i &lt; 8 ; i++ &#41;<br />  &#123;<br />    // Stage 4<br />    x0 = temp&#91;0&#93;&#91;i&#93; &lt;&lt; 10; x1 = temp&#91;1&#93;&#91;i&#93; &lt;&lt; 8;  x2 = temp&#91;2&#93;&#91;i&#93;;<br />    x3 = temp&#91;3&#93;&#91;i&#93; *  r2; x4 = temp&#91;4&#93;&#91;i&#93; &lt;&lt; 10; x5 = temp&#91;5&#93;&#91;i&#93; * r2;<br />    x6 = temp&#91;6&#93;&#91;i&#93;;       x7 = temp&#91;7&#93;&#91;i&#93; &lt;&lt; 8;  x8 = x7 + x1;<br />    x1 -= x7;<br /><br />    // Stage 3<br />    x7 = x0 + x4;                 x0 -= x4;<br />    x4 = x1 + x5;                 x1 -= x5;<br />    x5 = x3 + x8;                 x8 -= x3;<br />    x3 = r2c6 * &#40;x2 + x6&#41;;        x6 = x3 + &#40;-r2c6 - r2s6&#41; * x6;<br />    x2 = x3 + &#40;-r2c6 + r2s6&#41; * x2;<br /><br />    // Stage 2<br />    x3 = x7 + x2;                 x7 -= x2;<br />    x2 = x0 + x6;                 x0 -= x6;<br />    x6 = c3 * &#40;x4 + x5&#41;;          x5 = &#40;x6 + &#40;-c3 - s3&#41; * x5&#41; &gt;&gt; 8;<br />    x4 = &#40;x6 + &#40;-c3 + s3&#41; * x4&#41; &gt;&gt; 8;<br />    x6 = c1 * &#40;x1 + x8&#41;;          x1 = &#40;x6 + &#40;-c1 - s1&#41; * x1&#41; &gt;&gt; 8;<br />    x8 = &#40;x6 + &#40;-c1 + s1&#41; * x8&#41; &gt;&gt; 8;<br /><br />    // Stage 1, rounding and output<br />    x7 += 4096; x2 += 4096; x0 += 4096; x3 += 4096;<br />    data&#91;0&#93;&#91;i&#93;=&#40;x3 + x4&#41; &gt;&gt; 13;    data&#91;1&#93;&#91;i&#93; = &#40;x2 + x8&#41; &gt;&gt; 13;<br />    data&#91;2&#93;&#91;i&#93;=&#40;x0 + x1&#41; &gt;&gt; 13;    data&#91;3&#93;&#91;i&#93; = &#40;x7 + x5&#41; &gt;&gt; 13;<br />    data&#91;4&#93;&#91;i&#93;=&#40;x7 - x5&#41; &gt;&gt; 13;    data&#91;5&#93;&#91;i&#93; = &#40;x0 - x1&#41; &gt;&gt; 13;<br />    data&#91;6&#93;&#91;i&#93;=&#40;x2 - x8&#41; &gt;&gt; 13;    data&#91;7&#93;&#91;i&#93; = &#40;x3 - x4&#41; &gt;&gt; 13;<br />  &#125;<br />&#125;<br /></code></pre><br /><br />As you can see (maybe), these functions perform a 2D DCT on an 8x8 block of image data.  This can be accomplised by performing a 1D DCT on the rows, then a 1D DCT on the columns (the order doesn't matter, columns could go first).<br /><br />5) Zig-zag reordering - The 64 DCT coefficients are then reordered in a zig-zag order:<br /><br /><pre><code><br /> 0, 1, 5, 6,14,15,27,28,<br /> 2, 4, 7,13,16,26,29,42,<br /> 3, 8,12,17,25,30,41,43,<br /> 9,11,18,24,31,40,44,53,<br />10,19,23,32,39,45,52,54,<br />20,22,33,38,46,51,55,60,<br />21,34,37,47,50,56,59,61,<br />35,36,48,49,57,58,62,63<br /></code></pre><br /><br />to make a 1D array of length 64.<br /><br />6) Quantization - Another matrix multiplication.  This time, the matrix being multiplied will determing the quality of the resulting image.  A typical luminance quantization matrix could be as follows:<br /><br /><pre><code><br /> 16 11 10 16 24  40  51  61<br /> 12 12 14 19 26  58  60  55<br /> 14 13 16 24 40  57  69  56<br /> 14 17 22 29 51  87  80  62<br /> 18 22 37 56 68  109 103 77<br /> 24 35 55 64 81  104 113 92<br /> 49 64 78 87 103 121 120 101<br /> 72 92 95 98 112 100 103 99<br /></code></pre><br /><br />7) Run Length Coding - If you've ever written a library of Bitmap or Targa images, you're no doubt familiar with RLE.  This is very simple so I'll leave it at that.<br /><br />8) Huffman encoding - Finaly, the last step is to use a Huffman encoder to minimize the space required for common data.  There are many good resource on this subject so I'll leave it to you to figure out.<br /><br />-----------<br /><br />So, my word of advice.  Unless you want to spend many many hourse learning how to encode a JPEG image correctly, I suggest you find a free library and use it instead.<br /><br />NOTE:  The DCT has recently been replaced by the Descrete Wavelet Transform (DWT) which is quite a bit more complicated that the DCT, but has better results.<br /><br />Spara</div>
    <div class="meta">Posted on 2004-07-28 19:26:13 by SowWn</div>
   </div>
   <div class="post" id="post-147119">
    <div class="subject"><a href="#post-147119">Compressing To Jpg</a></div>
    <div class="body">Wavelet compression requires some license fees, doesn't it? Or is it just that the current libraries are commercial?</div>
    <div class="meta">Posted on 2004-07-30 06:16:59 by f0dder</div>
   </div>
   <div class="post" id="post-147144">
    <div class="subject"><a href="#post-147144">Compressing To Jpg</a></div>
    <div class="body">A specific algorithm that performs DWT compression might require a licence, but the DWT theory itself doesn't.  People have been using wavelet transforms since the turn of the 20th century.<br /><br />Spara</div>
    <div class="meta">Posted on 2004-07-30 13:52:24 by SowWn</div>
   </div>
   <div class="post" id="post-161062">
    <div class="subject"><a href="#post-161062">Re: Compressing To Jpg</a></div>
    <div class="body">Hello, Im trying to the same thing, and I got question to ask. I found this topic with search.<br />I have tryed do compression manually, so what I got:<br /><pre><code>Test image(RGB hex):<br />0FFFFFFh, 0FFFFFFh, 0FFFFFFh, 0FFFFFFh, 0FFFFFFh, 0FFFFFFh, 0FFFFFFh, 0FFFFFFh<br />0FFFFFFh, 0000000h, 0000000h, 0000000h, 0000000h, 0000000h, 0000000h, 0FFFFFFh<br />0FFFFFFh, 0000000h, 0FFFFFFh, 0FFFFFFh, 0FFFFFFh, 0FFFFFFh, 0000000h, 0FFFFFFh<br />0FFFFFFh, 0000000h, 0FFFFFFh, 0808080h, 0808080h, 0808080h, 0000000h, 0FFFFFFh<br />0FFFFFFh, 0000000h, 0FFFFFFh, 0808080h, 0808080h, 0808080h, 0FFFFFFh, 0FFFFFFh<br />0FFFFFFh, 0000000h, 0FFFFFFh, 0FFFFFFh, 0FFFFFFh, 0FFFFFFh, 0FFFFFFh, 0FFFFFFh<br />0FFFFFFh, 0000000h, 0000000h, 0000000h, 0000000h, 0000000h, 0000000h, 0FFFFFFh<br />0FFFFFFh, 0FFFFFFh, 0FFFFFFh, 0FFFFFFh, 0FFFFFFh, 0FFFFFFh, 0FFFFFFh, 0FFFFFFh<br /></code></pre><br />Now I convert RGB to YCbCr<br /><pre><code>-----<br />Y&nbsp; = 0.299 * R + 0.587 * G + 0.114 * B<br />Cb = -0.1687 * R - 0.3313 * G + 0.5 * B + 128<br />Cr = 0.5 * R - 0.4187 * G - 0.0813 * B + 128<br />-----<br />White (0FFFFFFh):<br />Y = 0.299 * 255 + 0.587 * 255 + 0.114 * 255 = 255<br />Cb = -0.1687 * 255 - 0.3313 * 255 + 0.5 * 255 + 128 = 128<br />Cr = 0.5 * 255 - 0.4187 * 255 - 0.0813 * 255 + 128 = 128<br />Gray (0808080h):<br />Y = 0.299 * 128 + 0.587 * 128 + 0.114 * 128 = 128<br />Cb = -0.1687 * 128 - 0.3313 * 128 + 0.5 * 128 + 128 = 128<br />Cr = 0.5 * 128 - 0.4187 * 128 - 0.0813 * 128 + 128 = 128<br />Black (0000000h):<br />Y = 0.299 * 0 + 0.587 * 0 + 0.114 * 0 = 0<br />Cb = -0.1687 * 0 - 0.3313 * 0 + 0.5 * 0 + 128 = 128<br />Cr = 0.5 * 0 - 0.4187 * 128 - 0.0813 * 0 + 128 = 128<br /><br />Test image(YCbCr dec):<br />255 128 128, 255 128 128, 255 128 128, 255 128 128, 255 128 128, 255 128 128, 255 128 128, 255 128 128<br />255 128 128, 000 128 128, 000 128 128, 000 128 128, 000 128 128, 000 128 128, 000 128 128, 255 128 128<br />255 128 128, 000 128 128, 255 128 128, 255 128 128, 255 128 128, 255 128 128, 000 128 128, 255 128 128<br />255 128 128, 000 128 128, 255 128 128, 128 128 128, 128 128 128, 128 128 128, 000 128 128, 255 128 128<br />255 128 128, 000 128 128, 255 128 128, 128 128 128, 128 128 128, 128 128 128, 255 128 128, 255 128 128<br />255 128 128, 000 128 128, 255 128 128, 255 128 128, 255 128 128, 255 128 128, 255 128 128, 255 128 128<br />255 128 128, 000 128 128, 000 128 128, 000 128 128, 000 128 128, 000 128 128, 000 128 128, 255 128 128<br />255 128 128, 255 128 128, 255 128 128, 255 128 128, 255 128 128, 255 128 128, 255 128 128, 255 128 128<br /><br />Test image(YCbCr hex):<br />0FF8080h, 0FF8080h, 0FF8080h, 0FF8080h, 0FF8080h, 0FF8080h, 0FF8080h, 0FF8080h<br />0FF8080h, 0008080h, 0008080h, 0008080h, 0008080h, 0008080h, 0008080h, 0FF8080h<br />0FF8080h, 0008080h, 0FF8080h, 0FF8080h, 0FF8080h, 0FF8080h, 0008080h, 0FF8080h<br />0FF8080h, 0008080h, 0FF8080h, 0808080h, 0808080h, 0808080h, 0008080h, 0FF8080h<br />0FF8080h, 0008080h, 0FF8080h, 0808080h, 0808080h, 0808080h, 0FF8080h, 0FF8080h<br />0FF8080h, 0008080h, 0FF8080h, 0FF8080h, 0FF8080h, 0FF8080h, 0FF8080h, 0FF8080h<br />0FF8080h, 0FF8080h, 0FF8080h, 0FF8080h, 0FF8080h, 0FF8080h, 0FF8080h, 0FF8080h</code></pre><br />So, what next? Sampling. I didnt understand actually how to, I should remove Cb from each second?<br /></div>
    <div class="meta">Posted on 2005-06-12 13:57:56 by valka</div>
   </div>
   <div class="post" id="post-161101">
    <div class="subject"><a href="#post-161101">Re: Compressing To Jpg</a></div>
    <div class="body">about the DCT and IDCT : I&#39;ve heard that the fastest algo for (I)DCT is &quot;AA&amp;N algorithm&quot;. is the above faster than this &#39;aa&amp;n&#39; ? </div>
    <div class="meta">Posted on 2005-06-13 10:04:52 by ti_mo_n</div>
   </div>
   <div class="post" id="post-161106">
    <div class="subject"><a href="#post-161106">Re: Compressing To Jpg</a></div>
    <div class="body">To tell you the truth, it&#39;s been almost a year since I&#39;ve looked at this code.&nbsp; At the time I chose the fastest algorithm I could find which might be the one you&#39;re talking about.&nbsp; I do know that it ran at a decent speed and that it worked.&nbsp; That&#39;s pretty much all I was interested in at the time.<br /><br />Spara<br /><br />PS: Why is some other dude&#39;s name on my posts?</div>
    <div class="meta">Posted on 2005-06-13 10:49:04 by Sparafusile</div>
   </div>
   <div class="post" id="post-161107">
    <div class="subject"><a href="#post-161107">Re: Compressing To Jpg</a></div>
    <div class="body">wtf? I dont care speed, how to do compression? First I do it myself to understand how it works</div>
    <div class="meta">Posted on 2005-06-13 11:00:06 by valka</div>
   </div>
   <div class="post" id="post-161111">
    <div class="subject"><a href="#post-161111">Re: Compressing To Jpg</a></div>
    <div class="body"><div class="quote"><br />wtf? I dont care speed, how to do compression? First I do it myself to understand how it works<br /></div><br />Since you asked in such a nice way, I feel compelled to answer.<br /><br />The next step is sampling.&nbsp; You already have your luminance values, but you need to cut the amount of Cb and Cr data in half (because it&#39;s not as important).&nbsp; You do this by taking the average to two adjacent pixels and then using that value for both.&nbsp; This way you cut the amount of data you&#39;re saving to disk by a third, but only reducing the quality by a small amount.<br /><br />Spara</div>
    <div class="meta">Posted on 2005-06-13 14:45:13 by Sparafusile</div>
   </div>
   <div class="post" id="post-161140">
    <div class="subject"><a href="#post-161140">Re: Compressing To Jpg</a></div>
    <div class="body">Ok then doing the Sampling:<br /><br /><pre><code>Test image(YCbCr dec):<br />255 128 128, 255, 255 128 128, 255, 255 128 128, 255, 255 128 128, 255<br />255 128 128, 000, 000 128 128, 000, 000 128 128, 000, 000 128 128, 255<br />255 128 128, 000, 255 128 128, 255, 255 128 128, 255, 000 128 128, 255<br />255 128 128, 000, 255 128 128, 128, 128 128 128, 128, 000 128 128, 255<br />255 128 128, 000, 255 128 128, 128, 128 128 128, 128, 255 128 128, 255<br />255 128 128, 000, 255 128 128, 255, 255 128 128, 255, 255 128 128, 255<br />255 128 128, 000, 000 128 128, 000, 000 128 128, 000, 000 128 128, 255<br />255 128 128, 255, 255 128 128, 255, 255 128 128, 255, 255 128 128, 255<br /><br />Test image(YCbCr hex):<br />0FF8080h, 0FFh, 0FF8080h, 0FFh, 0FF8080h, 0FFh, 0FF8080h, 0FFh<br />0FF8080h, 000h, 0008080h, 000h, 0008080h, 000h, 0008080h, 0FFh<br />0FF8080h, 000h, 0FF8080h, 0FFh, 0FF8080h, 0FFh, 0008080h, 0FFh<br />0FF8080h, 000h, 0FF8080h, 080h, 0808080h, 080h, 0008080h, 0FFh<br />0FF8080h, 000h, 0FF8080h, 080h, 0808080h, 080h, 0FF8080h, 0FFh<br />0FF8080h, 000h, 0FF8080h, 0FFh, 0FF8080h, 0FFh, 0FF8080h, 0FFh<br />0FF8080h, 0FFh, 0FF8080h, 0FFh, 0FF8080h, 0FFh, 0FF8080h, 0FFh</code></pre><br />Did regrouping:<br /><pre><code>Test image(YCbCr dec):<br />255 128, 128 255, 255 128, 128 255, 255 128, 128 255, 255 128, 128 255<br />255 128, 128 000, 000 128, 128 000, 000 128, 128 000, 000 128, 128 255<br />255 128, 128 000, 255 128, 128 255, 255 128, 128 255, 000 128, 128 255<br />255 128, 128 000, 255 128, 128 128, 128 128, 128 128, 000 128, 128 255<br />255 128, 128 000, 255 128, 128 128, 128 128, 128 128, 255 128, 128 255<br />255 128, 128 000, 255 128, 128 255, 255 128, 128 255, 255 128, 128 255<br />255 128, 128 000, 000 128, 128 000, 000 128, 128 000, 000 128, 128 255<br />255 128, 128 255, 255 128, 128 255, 255 128, 128 255, 255 128, 128 255<br /><br />Test image(YCbCr hex):<br />0FF80h, 080FFh, 0FF80h, 080FFh, 0FF80h, 080FFh, 0FF80h, 080FFh<br />0FF80h, 08000h, 00080h, 08000h, 00080h, 08000h, 00080h, 080FFh<br />0FF80h, 08000h, 0FF80h, 080FFh, 0FF80h, 080FFh, 00080h, 080FFh<br />0FF80h, 08000h, 0FF80h, 08080h, 08080h, 08080h, 00080h, 080FFh<br />0FF80h, 08000h, 0FF80h, 08080h, 08080h, 08080h, 0FF80h, 080FFh<br />0FF80h, 08000h, 0FF80h, 080FFh, 0FF80h, 080FFh, 0FF80h, 080FFh<br />0FF80h, 080FFh, 0FF80h, 080FFh, 0FF80h, 080FFh, 0FF80h, 080FFh</code></pre><br /><br />Subtracting 128:<br /><pre><code>Test image(YCbCr dec):<br />127 000, 000 127, 127 000, 000 127, 127 000, 000 127, 127 000, 000 127<br />127 000, 000 128, 128 000, 000 128, 128 000, 000 128, 128 000, 000 127<br />127 000, 000 128, 127 000, 000 127, 127 000, 000 127, 128 000, 000 127<br />127 000, 000 128, 127 000, 000 000, 000 000, 000 000, 128 000, 000 127<br />127 000, 000 128, 127 000, 000 000, 000 000, 000 000, 127 000, 000 127<br />127 000, 000 128, 127 000, 000 127, 127 000, 000 127, 127 000, 000 127<br />127 000, 000 128, 128 000, 000 128, 128 000, 000 128, 128 000, 000 127<br />127 000, 000 127, 127 000, 000 127, 127 000, 000 127, 127 000, 000 127<br /><br />Test image(YCbCr hex):<br />07F00h, 0007Fh, 07F00h, 0007Fh, 07F00h, 0007Fh, 07F00h, 0007Fh<br />07F00h, 00080h, 08000h, 00080h, 08000h, 00080h, 08000h, 0007Fh<br />07F00h, 00080h, 07F00h, 0007Fh, 07F00h, 0007Fh, 08000h, 0007Fh<br />07F00h, 00080h, 07F00h, 00000h, 00000h, 00000h, 08000h, 0007Fh<br />07F00h, 00080h, 07F00h, 00000h, 00000h, 00000h, 07F00h, 0007Fh<br />07F00h, 00080h, 07F00h, 0007Fh, 07F00h, 0007Fh, 07F00h, 0007Fh<br />07F00h, 0007Fh, 07F00h, 0007Fh, 07F00h, 0007Fh, 07F00h, 0007Fh</code></pre><br />Is everything correct?</div>
    <div class="meta">Posted on 2005-06-14 04:25:35 by valka</div>
   </div>
  </div>
 </body>
</html>