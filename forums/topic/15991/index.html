<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Optimzed calls to ExitProcess. Or other APIs.... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=15991" />
    <link rel="next" href="../?id=15991&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=15991">Optimzed calls to ExitProcess. Or other APIs....</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=15991&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=15991&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="15991" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=15991&amp;page=2">&gt;</a><a href="../?id=15991&amp;page=2">&raquo;</a></form>   <div class="post" id="post-123945">
    <div class="subject"><a href="#post-123945">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body">fodder once wrote that to many people are trying to optimize ExitProcess. In other words, useless optimization.  But hey, I optimized a call to ExitProcess.<br /><br />I started using jump tables again after calling everything through function pointers and I've learned some stuff regarding call and jmp.  Please correct me if Im wrong on any of this.<br /><br />Using MASM if I turn off incremental linking, calls to function defined in my own program do not get a jump table, just E8(realtive offset).  But Windows APIs, must use a jump  table or funtion pointer because the address of the API is not know at assemble time.  The PE loader loads the address at runtime.<br /><br />Now a few time here there has been dicussion about speed etc jump table vs function pointer.  Both require a memory reference:<br /><br />call ExitProcess<br />.<br />.<br />jmp [_imp_ExitProcess@4]  ;An indirect jmp requiring access to memory<br /><br />call    ;Calls to an address containing the address of the function<br /><br />But there is a relative version of jmp:<br /><br />E9(realtive offset)<br /><br />So I got the crazy idea of copying to addresses in the import table and make my own jump table that will use relative call to a relative jmp.  No memory reference needed:<br /><pre><code><br />_DATA SEGMENT<br />	__imp__ExitProcess@4&#58;<br />	db 0e9h<br />	dd 0<br />_DATA ENDS<br /><br />	mov eax,_imp__ExitProcess@4		;Get import table address<br />	mov eax,dword ptr&#91;eax&#93;			;Get API entry point<br />	mov ecx,__imp__ExitProcess@4+1	;Get addres of jmp+1<br />	mov edi,ecx<br />	add edi,3						;Not sure why I need to add 4<br />	sub edi,eax					<br />	not edi							<br />	mov &#91;ecx&#93;,edi					;Store Relative offset at jmp+1<br /><br />	invoke p_imp__ExitProcess@4,0      ;It exits without error&#91;I&#93;!!!&#91;/I&#93; <br /><br /><br />00401327 E8 F4 1C 00 00   call        __imp__ExitProcess@4 &#40;403020h&#41;<br />00403020 E9 F7 37 A7 77   jmp         77E7681C <br /></code></pre><br />TaDa, a faster call to exitprocess.  If you call an API or DLL in an inner loop this might be a good optimization.</div>
    <div class="meta">Posted on 2003-11-10 11:22:02 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-123952">
    <div class="subject"><a href="#post-123952">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body"><pre><code><br />mov ecx, ExitProcess+2<br />call ecx<br /></code></pre><br />I think it should work... At least it looks shorter than your code. :grin: PS: This code requires a jump table. :/</div>
    <div class="meta">Posted on 2003-11-10 12:01:35 by roticv</div>
   </div>
   <div class="post" id="post-123957">
    <div class="subject"><a href="#post-123957">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body">First, am I correct in saying that you are trying to <strong>statically</strong> call the memory address where you <strong>expect</strong> ExitProcess to be?<br /><br />I'd like to ask a few questions about this kind of <strong>speed</strong> optimization.<br /><br />1) Is the location of API calls <strong>always</strong> the same? If they are, are you sure they are the same for all Windows Operating systems. What I mean is, will the above mentioned speed optimization work the same on Windows 95 and XP?<br /><br />2) Does Windows link for example, the Kernel32.dll into the same address space everytime? What I mean is, is the memory location of Kernel32.dll the same for all applications?<br /><br />3) What will happen to your above mentioned speed optimization when a new version of Windows comes out? Could you not run into a problem if they change the address of ExitProcess in a new version of Kernel32?<br /><br /><div class="quote">_DATA SEGMENT<br />	__imp__ExitProcess@4:<br />	db 0e9h<br />	dd 0<br />_DATA ENDS<br /></div><br /><br />4) What is the <strong>dd 0</strong> used for?<br /><br />5) How <strong>safe</strong> is this optimization or this kind of programming based on <strong>assumptions</strong>?<br /><br />Thanx</div>
    <div class="meta">Posted on 2003-11-10 13:06:21 by SubEvil</div>
   </div>
   <div class="post" id="post-123960">
    <div class="subject"><a href="#post-123960">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body"><div class="quote"><br />First, am I correct in saying that you are trying to <strong>statically</strong> call the memory address where you <strong>expect</strong> ExitProcess to be?<br /><br />I'd like to ask a few questions about this kind of <strong>speed</strong> optimization.<br /><br />1) Is the location of API calls <strong>always</strong> the same? If they are, are you sure they are the same for all Windows Operating systems. What I mean is, will the above mentioned speed optimization work the same on Windows 95 and XP?<br /><br />2) Does Windows link for example, the Kernel32.dll into the same address space everytime? What I mean is, is the memory location of Kernel32.dll the same for all applications?<br /><br />3) What will happen to your above mentioned speed optimization when a new version of Windows comes out? Could you not run into a problem if they change the address of ExitProcess in a new version of Kernel32?<br /><br /><br /><br />4) What is the <strong>dd 0</strong> used for?<br /><br />5) How <strong>safe</strong> is this optimization or this kind of programming based on <strong>assumptions</strong>?<br /><br />Thanx </div><br /><br />heh, I think you are missing a few things in the code. What thoughtcriminal is doing is taking the mem-pointer from the import table and patching it into his own jump table. Thus, the answers to your questions are.<br />1) The location of the import table is always the same. So ofcourse it will work cross-windows, as windows itself fills in the import table.<br />2) No, it doesn't have to, but basically it does. Kernel32 is the first dll to be loaded in win9x (if memory serves me right) and subsequent dll's will be relocated. In win2k and xp, it will most likely also be placed the same.<br />3) Nothing whatsoever.<br />4) heh, it's an integral part. The 0e9h that preceeds it is a jump mnemonic. So the dd 0h is basically just an empty variable<br />5) it's hardly based on assumptions - it's as safe as the linking of exe-files goes, it's the same idea basically.<br /><br />Fake</div>
    <div class="meta">Posted on 2003-11-10 14:07:14 by Fake51</div>
   </div>
   <div class="post" id="post-123962">
    <div class="subject"><a href="#post-123962">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body">Nope, that's not it. You got it all wrong. He is just making a new jump table at runtime, with relative jumps.<br /><br /><em></em><br /><br />Anyway, you don't really need an import library. Many assemblers allow you to put imports inside the source. I don't remember if MASM can do that, though...<br /><br />You could optimize things further by trying something like this:<br /><br /><pre><code><br />; Begin with ecx=number of imports<br />push esi<br />push edi<br />cmp ecx,65<br />mov edi,Table<br />mov al,235<br />mov ah,cl<br />jb not_65_imports<br />mov ah,64<br />not_65_imports&#58;<br />add ah,ah<br />call afterpatchfunction<br />beforepatchfunction&#58;<br />pop eax<br />mov ecx,&#91;eax-4&#93;<br />add ecx,eax<br />sub ecx,Table<br />mov edx,&#91;WhateverFirstImport+ecx*2&#93;<br />sub edx,eax<br />mov &#91;eax-4&#93;,edx<br />sub eax,5<br />jmp eax<br />afterpatchfunction&#58;<br />pop esi<br />table_loop&#58;<br />dec ecx<br />sub ah,2<br />stosw<br />jae table_loop<br />push ecx<br />push afterpatchfunction-beforepatchfunction<br />pop ecx<br />rep movsb<br />mov ah,beforepatchfunction-afterpatchfunction-2<br />pop ecx<br />jz nomoreimports<br />table_loop2&#58;<br />sub ah,2<br />stosw<br />loop table_loop2<br />nomoreimports&#58;<br />pop edi<br />pop esi<br /></code></pre><br /><br />Then you could just call all the APIs with call Table+FunctionNumber*2. (or Table+FunctionNumber*2+afterpatchfunction-beforepatchfunction for imports from 64 and up) And it would automatically correct the address.</div>
    <div class="meta">Posted on 2003-11-10 14:18:48 by Sephiroth3</div>
   </div>
   <div class="post" id="post-123986">
    <div class="subject"><a href="#post-123986">re:</a></div>
    <div class="body">regards!</div>
    <div class="meta">Posted on 2003-11-10 21:08:54 by jefeng</div>
   </div>
   <div class="post" id="post-123987">
    <div class="subject"><a href="#post-123987">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body">Maybe I'm missing something, but if you want to dump the jump table, why not just use hutch's L2EXTIA utility. Then when you say:<br /><br />invoke ExitProcess,eax<br /><br />you get:<br /><br />push eax<br />call _imp__ExitProcess@4<br /><br />:grin:</div>
    <div class="meta">Posted on 2003-11-10 21:56:27 by S/390</div>
   </div>
   <div class="post" id="post-123992">
    <div class="subject"><a href="#post-123992">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body">S/390:<br /><br />Check the opcode for a call using his utility.  I'll bet the first byte is FF, an indirect call needing an access to memory to get the address.  What I'm doing does not need a memory access.<br /><br />.<br />.<br />.<br /><br />Regarding the import table.  I'll need to look at a windows program and not a console one, since a window needs user32.dll.  What I do know about kernel32.dll is the imports are loaded alphabetically.  I only used one API so ,_imp__ExitProcess@4 would be at the top of the import table.  I'll need to look and see what happens when you link with more than one lib.  You should just be able to grab the first entry and go down the table(up in memory) and stop when you get to 0(the import section should be zeroed out by the PE loader.<br /><br />Sephiroth3:<br /><br />A few to many magic numbers(to me) for me to understand your code.</div>
    <div class="meta">Posted on 2003-11-11 00:14:55 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-124048">
    <div class="subject"><a href="#post-124048">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body">Hehe, well, what I'm doing is making a table of jumps that all go to the same address, which is a function that reads the called address from the instruction that called the function, and replaces it with the offset to an imported function, taken from the IAT. Hmm. I just saw an error. The code is broken for entries 64 and up. But that's easy to repair. Anyway, you get the idea :P The code will now jump directly to the imported function, instead of going to an intermediate address.</div>
    <div class="meta">Posted on 2003-11-11 11:31:05 by Sephiroth3</div>
   </div>
   <div class="post" id="post-124051">
    <div class="subject"><a href="#post-124051">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body">The order that you list imports in your executable, whether it be console, GUI, or dll is irrelevent. It just may happen that your assembler and/or linker will create the tables in alphabetic order.<br /><br />On the other hand, the exports of an executable MUST be in alphabetical order.<br /><br />I know this as I have written import entries by hand - I don't anymore because the macros take care of the creation of the import section.<br /><pre><code><br />section '.idata' import data readable writeable<br /><br />  dd 0,0,0,rva kernel_name,rva kernel_table<br />  dd 0,0,0,rva user_name,rva user_table<br />  dd 0,0,0,0,0<br /><br />  kernel_table&#58;<br />    GetCommandLine   dd rva _GetCommandLine<br />    ExitProcess      dd rva _ExitProcess<br />    dd 0<br />  user_table&#58;<br />    MessageBox dd rva _MessageBoxA<br />    dd 0<br /><br />  kernel_name db 'KERNEL32.DLL',0<br />  user_name db 'USER32.DLL',0<br /><br />  _GetCommandLine    dw 0<br />      db 'GetCommandLineA', 0<br />  _ExitProcess       dw 0<br />      db 'ExitProcess', 0<br />  _MessageBoxA       dw 0<br />      db 'MessageBoxA', 0<br /></code></pre><br /><br />With in import macros you get<br /><pre><code><br />section '.idata' import data readable writeable<br /><br />library     kernel,             'KERNEL32.DLL',\<br />            user,               'USER32.DLL'<br /><br />kernel&#58;<br />  import    GetCommandLine,   'GetCommandLineA',\<br />            ExitProcess,      'ExitProcess'<br /><br />user&#58;<br />  import    MessageBox,         'MessageBoxA'<br /></code></pre><br /><br />Now i use the .code, .data, and .end macros which create the code, data, and import sections.<br /><br />Here is the minipad example that comes with fasm. It has an unordered import table.</div>
    <div class="meta">Posted on 2003-11-11 12:05:09 by eet_1024</div>
   </div>
   <div class="post" id="post-124097">
    <div class="subject"><a href="#post-124097">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body">Sephiroth3:<br /><br />Is the first byte of any call with this method FF?  I looked at Hutch's utility and it makes function pointers(indirect calls) to the import table.  I figured this out independantly, but our syntaxs where very similar.<br /><br />My little code for copying and adjusting the rvas would be a run once thing done at program start, not for every call to a function.<br />(I sure you understand this, but I want to clarify for those who may not.)<br /><br />eet_1024:<br /><div class="quote">On the other hand, the exports of an executable MUST be in alphabetical order.</div> <br />Thanks for letting me know.  I was wonder if they came in alphabetical order becuase the libs(ie Kernel32.lib) are in alphabetical order.  In the case of MASM, I'd guess LINK would enforce the order. But your using FASM, so maybe the PE loader enforces this??</div>
    <div class="meta">Posted on 2003-11-11 21:51:30 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-124245">
    <div class="subject"><a href="#post-124245">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body">Ok, first post so hi to the forum and please bear with me here.<br /><br />Isn't this actually quite stupid? you are for speed reasons building a new jump table only this time with relative<br />jumps it really feels like a cludge. If you would ever be in a situation that you need to speed up that jump<br />wouldn't something like:<br /><br />;before loop<br />mov unused_reg, [_imp__Function@X]<br /><br />;in loop<br />call unused_reg<br /><br />ok, sure one could argue that this isn't an option in most cases but it's quite a deal less work than building the<br />jump table, another way would be runtime patching just create a function that on startup patches itself using the relative addresses instead. That way you would at least get rid of the jump table figouring out  a good scheme to encode patching places would also get around hardwiring all places to patch...<br /><br />But somehow this all feels like throwing the baby out with the bathwater...</div>
    <div class="meta">Posted on 2003-11-13 04:14:48 by DrunkenCoder</div>
   </div>
   <div class="post" id="post-124321">
    <div class="subject"><a href="#post-124321">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body"><div class="quote"><br />Isn't this actually quite stupid? you are for speed reasons building a new jump table only this time with relative<br />jumps it really feels like a cludge. If you would ever be in a situation that you need to speed up that jump<br />wouldn't something like:<br /><br />;before loop<br />mov unused_reg, [_imp__Function@X]<br /><br />;in loop<br />call unused_reg<br /></div> <br />It all depends on what your optimization needs are.  If you have regs to spare, you code is fine.  If you don't and it will negatively impact you algorithm to free one, a relative call might be better than changing your algorithm.  But if that relative call is to address that cannot be know at assemble time(imports,DLL vtable method entry points,etc), MASM can only code it as a jump table:<br /><br />call someAPI ;E8(offset to jump table entry)<br />jmp  ;FF(address of point to function entry point).<br /><br />Or a function pointer:<br /><br />call .someAPI;FF(address of point to function entry point). A call to a reg is a call to a pointer.<br /><br /><br /><br />Both methods need to touch memory.  What if you really need speed and touching memory is an unaceptqable penalty?<br />There are two thing I know you could do.  One is to patch all inner loop callsto a direct relative call.  It is also extream opimization.  Depending on how you build your program and for safety you my need to call VirtualProtect to make the area writable, and again to make it non-writable.  And where you patch, you might effect surrounding code.  Can be a lot of work and error prone.  What I demonstrated is a basic way to call functions, where the entrypoint cannot be known at assembly time, without touching memory. The optimization gurus here have not posted anything about a fatal flaw in what I'm doing.  I take that as a good sign.  They are quite good a educating someone who says something that is  right.  Optimizing around calls to Windows APIs is generally silly.  The time the API takes usually cancels out any gain.  I used ExitProcess as a simple example.  So who needs an optimization like this?  I can only guess.  Optimization freaks, demo coders, DirectX,video decoders?  Maybe some of the OOP implementaions could us this for inheritance vtable optimization.  VC2003 uses a relative call then relative jmp for some operator overloads(in some stuff I looked at).  I've never seem this type of optimization discuss, so I'm just trying to provide some food to the forum.  I hope some have read this a gained a deeper understanding how this all works, and run with it and share what they have learned.<br /><br />Oh, BTW, welcome to the forum :)</div>
    <div class="meta">Posted on 2003-11-14 04:31:58 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-124358">
    <div class="subject"><a href="#post-124358">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body">No, my idea involves direct calls. When the call is first made, the address of the function will be loaded from the import table and the offset will be updated, and subsequent calls will then be very fast.</div>
    <div class="meta">Posted on 2003-11-14 11:39:48 by Sephiroth3</div>
   </div>
   <div class="post" id="post-124378">
    <div class="subject"><a href="#post-124378">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body">I guess we kinda misunderstood each other.  When you posted your code I figured that you were using a method where rather than copying then patching the imports like me, you getting the address from the imports to patch the actual call.  My simple method uses a jump table and you more complicated method has no  jump table, just a direct call to the correct offset(entry point).</div>
    <div class="meta">Posted on 2003-11-14 14:10:22 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-129824">
    <div class="subject"><a href="#post-129824">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body">The reason PE exports must be alphabetical is because a binary search is used when the PE loader tries to locate an import.<br /><br />This is a silly optimization anyway - as mentioned in another thread. first of all you end up dirtying your code pages, which as we all know is a bad idea (not being able to do discard+reload but having to do pagefilewrite+pagefileload, and of course not being able to use code sharing when running multiple instances of the same app).<br /><br />If you &quot;need&quot; this kind of optimization, you're designing your application wrong. Who would do *calls* in their innerloops? This is akin to spending a lot of time optimizing putpixel for use in a spriteblit, whereas you should really spend your time designing the spriteblit properly.<br /><br />It's a cute trick (even if your implementation lacks a lot), but I hope people won't go &quot;gee wizz, I'm gonna use this in my apps!&quot; without considering the tradeoffs.</div>
    <div class="meta">Posted on 2004-01-05 10:00:51 by f0dder</div>
   </div>
   <div class="post" id="post-129829">
    <div class="subject"><a href="#post-129829">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body">To be honest, I have no idea what I'd use this for.  I have no interest in making high-performance 3D demos or anything like that.  However, if I ever need something like this, I will have some ideas on how to proceed.<br /><br />I hadn't touched programming for over a month and just needed a project.<br /><br /><div class="quote"><br />The reason PE exports must be alphabetical is because a binary search is used when the PE loader tries to locate an import.<br /></div> <br />Thank you, thats good to know.</div>
    <div class="meta">Posted on 2004-01-05 11:27:47 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-129832">
    <div class="subject"><a href="#post-129832">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body">(continuing from <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=16694">http://www.asmcommunity.net/board/index.php?topic=16694</a> )<br /><br />Hmm, don't think DX would patch it's vtable on-the-fly, so it's probably &quot;safe&quot; to 'optimize' the vtable calls to direct calls. However, for &lt;256byte indices into the vtable, the call can be coded as a three-byte &quot;call &quot;... I like guaranteed safe+small better than slight_risk_of_something_unforseen+not_reall_that_much_faster :)<br /><br />And would it really matter for DX anyway? The big deal is 3D, and there you (as far as I have understood) tend to send a vertex buffer or similar - so, doing a whole batch of operations per call. Still seems like a silly optimization.<br /><br />I don't know if there's any source floating around for my stub idea, and I can't really rip out parts of a &quot;pretty private&quot; project I'm working on :). But it's not really too bad to get working, as long as you fix the PE header properly when adding the stub.<br /><br />EXE that optimizes itself and dumps to disk... nah. If the calls are optimized on the fly, you'll have to dump at an arbitrary point - some calls might not be optimized yet. Then there's all the tedious things about dumping, like having to reconstruct IT, fixing up PE header etc. Besides, static global variables might have been changed, which could cause unpredictable program execution. Besides, you will have an exe that will only work on YOUR computer, with the exact same windows version, service packs, hotfixes etc. 'Re-optimization' probably wouldn't be feasible.<br /><br />The best runtime optimization that doesn't cause dirty code pages would probably be running through the import thunks and fixing the FF25 to E9 + whatever padding byte. These thunks should be grouped together, and iirc (could be wrong) will usually be located close to the IAT, which will (should) be dirty anyway, since it needs to be fixed by the PE loader. This still has both CALL+JMP but at least both are direct calls. Of course it doesn't handle the case where the app directly does indirect call through the IAT instead of direct call to the thunk.<br /><br /><div class="quote"><br />To be honest, I have no idea what I'd use this for.<br /></div><br />Heh, okay - I was afraid you thought this was a thing that would make much of a difference ;). It's a fun project anyway, and there's a whole bunch of things to be learnt from it which might be put to use for more productive things.<br /><br /><div class="quote"><br />I hadn't touched programming for over a month and just needed a project.<br /></div><br />Play around with PE encryption and advance to compression afterwards - those are fun and interesting (and lots of hairpulling when SOME version of windows refuses to load the output PE while all the rest work, hehe)..</div>
    <div class="meta">Posted on 2004-01-05 12:00:30 by f0dder</div>
   </div>
   <div class="post" id="post-129866">
    <div class="subject"><a href="#post-129866">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body"><div class="quote"><br />Hmm, don't think DX would patch it's vtable on-the-fly, so it's probably &quot;safe&quot; to 'optimize' the vtable calls to direct calls. However, for &lt;256byte indices into the vtable, the call can be coded as a three-byte &quot;call &quot;... I like guaranteed safe+small better than slight_risk_of_something_unforseen+not_reall_that_<br />much_faster <br /></div> <br />It does not patch it on the fly.<br /><div class="quote"><br />And would it really matter for DX anyway? The big deal is 3D, and there you (as far as I have understood) tend to send a vertex buffer or similar - so, doing a whole batch of operations per call. Still seems like a silly optimization.<br /></div><br />From what I know about Direct 3D, there is a rander loop.  The best optmization is to remove function calls, maybe this could be 2nd best.<br /><div class="quote"><br />EXE that optimizes itself and dumps to disk... nah. If the calls are optimized on the fly, you'll have to dump at an arbitrary point - some calls might not be optimized yet. Then there's all the tedious things about dumping, like having to reconstruct IT, fixing up PE header etc. Besides, static global variables might have been changed, which could cause unpredictable program execution. Besides, you will have an exe that will only work on YOUR computer, with the exact same windows version, service packs, hotfixes etc. 'Re-optimization' probably wouldn't be feasible.<br /></div> <br />I would not optmize on the fly at all.  Optimized once at program startup before any of the real program code is used.  &quot;Kinda&quot; like the C# JIT compilation process.  It runs the jitter the first time the program is started and tunes it for... your computer :grin: With my current code reoptimization would be easy.  It can only patch static addresses know at link time, so the addresses never move and the code does not change size.<br /><div class="quote"><br />The best runtime optimization that doesn't cause dirty code pages would probably be running through the import thunks and fixing the FF25 to E9 + whatever padding byte. These thunks should be grouped together, and iirc (could be wrong) will usually be located close to the IAT, which will (should) be dirty anyway, since it needs to be fixed by the PE loader. This still has both CALL+JMP but at least both are direct calls. Of course it doesn't handle the case where the app directly does indirect call through the IAT instead of direct call to the thunk.<br /></div> <br />My first post in this thread has code to do E8 to E9.  A lot simpler than E8 to entrypoint as you can see. FF25 is an indirect call.  Please explain dirty code page.   I could build the E9 right after the IAT in a data section.<br /><div class="quote"><br />Play around with PE encryption and advance to compression afterwards - those are fun and interesting (and lots of hairpulling when SOME version of windows refuses to load the output PE while all the rest work, hehe)..<br /></div> <br />Perhaps I will.....<br /><br />Thanks for all your input.</div>
    <div class="meta">Posted on 2004-01-05 21:03:46 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-129877">
    <div class="subject"><a href="#post-129877">Optimzed calls to ExitProcess. Or other APIs....</a></div>
    <div class="body"><div class="quote"><br />Please explain dirty code page.<br /></div><br />Dirty pages are one of the reasons thinks like exe compression is generally bad... <a target="_blank" href="http://f0dder.has.it">http://f0dder.has.it</a> , articles, &quot;packing, data handling, stuff&quot;.</div>
    <div class="meta">Posted on 2004-01-06 00:44:58 by f0dder</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=15991&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=15991&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="15991" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=15991&amp;page=2">&gt;</a><a href="../?id=15991&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>