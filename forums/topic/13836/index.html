<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Reading word/text under mouse pointer - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=13836" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=13836">Reading word/text under mouse pointer</a></p>
   <div class="post" id="post-107014">
    <div class="subject"><a href="#post-107014">Reading word/text under mouse pointer</a></div>
    <div class="body">Hi,<br /><br />what ist the best way to read words under the mouse pointer (not only in edits/richedits...).<br />Can somebody help ?<br /><br />Greetings,<br />Nordwind64</div>
    <div class="meta">Posted on 2003-06-13 15:54:26 by Nordwind64</div>
   </div>
   <div class="post" id="post-107019">
    <div class="subject"><a href="#post-107019">Reading word/text under mouse pointer</a></div>
    <div class="body">Hi,<br /><br />    In fact i have tried to implementing word sensitive F1 help add-in for AsmEdit for a while. But not very successful. Because AsmEdit was not ready to accept this. Btw, i did my best also. In fact inspired from AsmEdit sources(Thanks Ewayne). This is my implementation, only needs to selecting the keyword and F1. However you may wait the fat woman :) <br /><br /><pre><code>;*******************************************<br /><br />; Place the LIBRARY &amp; EXPORTS in your Projects xxxx.def file.<br /><br />;------------------<br />;LIBRARY &#40;your Project name&#41;<br />;EXPORTS DllProc<br />;------------------<br />         title   AddinT<br /><br />         .586<br />         .model flat, stdcall<br />         option casemap&#58;none   ; Case sensitive<br /><br />            include  C&#58;\Masm32V1\include\Windows.inc<br />            include  C&#58;\Masm32\include\user32.inc<br />            include  C&#58;\Masm32\include\kernel32.inc<br />            include  C&#58;\Masm32\include\advapi32.inc<br />            include  C&#58;\Masm32V1\include\DSPMACRO.asm<br />include	masm32.inc<br /><br />         includelib  C&#58;\Masm32\lib\user32.lib<br />         includelib  C&#58;\Masm32\lib\kernel32.lib<br />         includelib  C&#58;\Masm32\lib\advapi32.lib<br />includelib	masm32.lib<br /><br />;===================================================<br />; PROTO, MACRO, and Data section<br />;===================================================<br />Initilize    PROTO   &#58;DWORD<br />NewProject   PROTO   &#58;DWORD<br />GetRegPaths  PROTO   &#58;DWORD<br /><br />FindTopic PROTO &#58;DWORD,&#58;DWORD<br />SearchKeyword proto &#58;DWORD<br />GetKeyword proto<br /><br />.const<br />; Messages sent to AsmEdit<br />IDM_GETDWORDS           equ WM_USER+50<br />IDM_GETPROC             equ WM_USER+51<br />IDM_GETDATA             equ WM_USER+52<br /><br />IDM_NEW                 equ 6001<br />IDM_OPEN                equ 6002<br />IDM_CLOSE               equ 6004<br />IDM_SAVEAS              equ 6006<br />IDM_PRINT               equ 6010<br /><br />IDM_HELPF1		equ 492			; wParam value<br /><br />ADDINPROCS struct<br />	lpGetWordFromPos	dd 0	;Handle of richedit, returns pointer to word<br />	lpGetWord			dd 0	;lpWord, returns pointer to word<br />ADDINPROCS ends<br /><br />; IDM_GETDWORDS returns a poiner to the following Handle &amp; dword structure.<br />ASMDWORDS struct<br />      hWnd              dd 0   ; Handle of AsmEdit.<br />      hMenu             dd 0   ; Handle of AsmEdit Menu.<br />      hToolBar          dd 0   ; Handle of AsmEdit ToolBar.<br />      hStatus           dd 0   ; Handle of AsmEdit StatusBar.<br />      hREdit            dd 0   ; Handle of RichEdit window.<br />      MenuID            dd 0   ; Addin/Project menu item ID.<br />      ProjType          dd 0   ; Project type from create &#40;.dll or .exe&#41;<br />ASMDWORDS ends<br /><br />; IDM_GETPROC returns a poiner to the following Procedure structure.<br />ASMEPROC struct<br />      lpBaseAscii       dd 0   ; Pointer to BaseAscii Proc.<br />      lpAsciiBase       dd 0   ; Pointer to AsciiBase Proc.<br />      lpEnaDisMenu      dd 0   ; Pointer to EnableDisableEditMenu Proc.<br />ASMEPROC ends<br /><br />; IDM_GETDATA returns a poiner to the following Data structure.<br />ASMEDATA struct<br />      lpRootDir         dd 0   ; Pointer to root dir, ends with \.<br />      lpPathName        dd 0   ; Pointer to current full path.<br />      lpFileName        dd 0   ; Pointer to FileName.<br />      lpProjectName     dd 0   ; Pointer to Project Name.<br />      lpProjectPath     dd 0   ; Pointer to Project Path.<br />      lpRegKey          dd 0   ; AsmEdit registry key.<br />ASMEDATA ends<br /><br />.data<br /><br />AppName                 db 'ContextF1',0<br />szHelp			db &quot;C&#58;\\Program Files\\Common Files\\Borland Shared\\MSHelp\\WIN32SDK.HLP&quot;,0<br /><br />.data?<br />hInst                   dd ?   ; AsmEdit's instance<br />hREdit                   dd ?   ; Handle of RichEdit<br />dwHStruct               dd ?   ; Pointer to handles struct<br />dwPStruct               dd ?   ; Pointer to proc struct<br />dwDStruct               dd ?   ; Pointer to data struct<br /><br />	szKw			db 51 dup &#40;?&#41;<br />	lnKw			dd ?<br />	szFn			db 256 dup &#40;?&#41;<br />	buffer						db 256 dup &#40;?&#41;<br />	dOptions					dd ?<br />	lpHStruct					dd ?	;Pointer to handles struct<br />	lpPStruct					dd ?	;Pointer to proc struct<br />	lpDStruct					dd ?	;Pointer to data struct<br />	pDbPath						dd ?<br />	hHHwin						dd ?<br /><br />topicBuffer						db 256 dup &#40;?&#41;<br /><br />.code<br /><br />;===============================================================<br />; DLL Entry<br />;===============================================================<br />DllEntry PROC hInstance&#58;DWORD, reason, reserved1<br /><br />      .if reason == DLL_PROCESS_ATTACH  ; When the dll is loaded<br />           push     hInstance<br />            pop     hInst<br />            mov     eax, TRUE<br />      .endif<br />         ret<br /><br />DllEntry ENDP<br /><br />;===============================================================<br />; Initilize Proc loads pointers for various handles, and<br />; data areas. Is called from the DllProc<br />;===============================================================<br />Initilize PROC  hWnd&#58;DWORD<br /><br />      INVOKE     SendMessage, hWnd, IDM_GETDWORDS, 0, 0<br />         mov     dwHStruct, eax<br />      INVOKE     SendMessage, hWnd, IDM_GETPROC, 0, 0<br />         mov     dwPStruct, eax<br />      INVOKE     SendMessage, hWnd, IDM_GETDATA, 0, 0<br />         mov     dwDStruct, eax<br />         ret<br /><br />Initilize ENDP<br /><br />;===============================================================<br />; DllProc Receives WM_COMMAND messages from AsmEdit<br />;===============================================================<br />DllProc PROC  uses edi hWnd&#58;DWORD, wMsg, wParam, lParam<br /><br />      .if wMsg == WM_COMMAND<br /><br />         .if !dwHStruct                  ; Check if Initilize has been run<br />            INVOKE     Initilize, hWnd<br />         .endif<br />            mov     eax, wParam<br />           cwde<br />            mov     wParam, eax<br /><br />; NOTE! The wParam &amp; lParam value will be whatever you specified in the menu command.<br /><br />;---------- &#91;New Tab&#93; ----------<br />         .if ax == IDM_HELPF1<br />		invoke GetKeyword ; Get the current word<br />		.if eax<br />		   invoke WinHelp,hREdit,addr szHelp,HELP_KEY, eax<br />		.endif<br />               jmp     Ret1<br />         .endif<br /><br />;---------- &#91;AsmEdit closing down&#93; ----------<br />      .elseif wMsg == WM_CLOSE<br />; Do cleanup work<br />            jmp     Ret0<br />      .endif<br /><br />Ret0&#58;<br />         xor     eax, eax<br />         ret<br /><br />Ret1&#58;<br />         mov     eax, TRUE<br />         ret<br /><br />DllProc ENDP<br /><br />;----------------------------------------------------------------------------------<br />GetKeyword proc<br /><br />LOCAL trg&#58;TEXTRANGE<br />LOCAL chr&#58;byte<br />LOCAL hEdt&#58;dword<br />LOCAL pKeyword&#58;dword<br /><br /><br />	;Clear buffer<br />	mov		buffer,0<br />	mov		pKeyword, offset buffer<br /><br />	mov		eax, dwHStruct<br />	mov		eax,&#40;ASMDWORDS ptr &#91;eax&#93;&#41;.hREdit<br /><br />	.if eax<br />	    mov     hREdit, eax<br />	    mov	    hEdt,eax<br />	.endif<br /><br />		;Get selection<br />		invoke SendMessage, hEdt, EM_EXGETSEL, 0, addr trg.chrg<br />		;Get size<br />		mov		eax, trg.chrg.cpMax<br />		sub		eax, trg.chrg.cpMin<br />		.if eax<br />			;There is a selection in the edit window<br />			;If more than 255 chars in selection, dont bother<br />			.if eax&lt;256<br />				invoke SendMessage,hEdt,EM_GETSELTEXT,0,addr buffer<br />			.endif<br />		.else<br />			;No selection, let RadASM get word under caret<br />;			push	hEdt<br />;			mov		eax,&#91;lpPStruct&#93;<br />;			mov		eax,&#40;ADDINPROCS ptr &#91;eax&#93;&#41;.lpGetWordFromPos<br />;			call	eax<br />;			mov pKeyword,eax<br />			;On return eax contains pointer to word<br />			;The word will be a null string if caret is on white space<br />			;Check character before keyword<br />				; Get start of word<br />				inc trg.chrg.cpMin ; Hack to fix when the caret is just after the &quot;.&quot;<br />				invoke SendMessage,hEdt,EM_FINDWORDBREAK,WB_MOVEWORDLEFT,trg.chrg.cpMin<br />				; Set up the textrange<br />				mov trg.chrg.cpMax,eax<br />				dec eax<br />				mov trg.chrg.cpMin,eax<br />				lea edx,chr<br />				mov trg.lpstrText,edx<br />				; Get the character<br />				invoke SendMessage,hEdt,EM_GETTEXTRANGE,0,addr trg<br />				.if chr==&quot;.&quot;<br />					mov esi,pKeyword<br />					mov edi,offset buffer+1<br />					mov byte ptr &#91;edi-1&#93;,&quot;.&quot;				<br />				@@&#58;<br />					lodsb<br />					stosb<br />					or al,al<br />					jnz @B<br />					mov pKeyword,offset buffer<br />				.endif<br />		.endif<br /><br />	mov pKeyword, offset buffer<br />	invoke ltrim,pKeyword,pKeyword<br />	mov eax,pKeyword<br />	.if byte ptr &#91;eax&#93;==0<br />		xor eax,eax<br />	.endif<br />	ret<br /><br />GetKeyword endp<br />;----------------------------------------------------------------------------------<br /><br />End DllEntry<br /></code></pre></div>
    <div class="meta">Posted on 2003-06-13 16:52:46 by cakmak</div>
   </div>
   <div class="post" id="post-107020">
    <div class="subject"><a href="#post-107020">Reading word/text under mouse pointer</a></div>
    <div class="body">I usually move the mouse pointer off the text to see it, and then read it from left to right.  :grin:<br /><br />Try the EM_CHARFROMPOS message.  :alright:</div>
    <div class="meta">Posted on 2003-06-13 16:52:46 by iblis</div>
   </div>
   <div class="post" id="post-107162">
    <div class="subject"><a href="#post-107162">Reading word/text under mouse pointer</a></div>
    <div class="body">Hi,<br /><br />thanks a lot !!!<br /><br />Greetings,<br />Nordwind64</div>
    <div class="meta">Posted on 2003-06-15 06:58:55 by Nordwind64</div>
   </div>
  </div>
 </body>
</html>