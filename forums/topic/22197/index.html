<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Serial port sniffer - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=22197" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=22197">Serial port sniffer</a></p>
   <div class="post" id="post-166951">
    <div class="subject"><a href="#post-166951">Serial port sniffer</a></div>
    <div class="body">Hi,<br /><br />I need to make a serial port sniffer for Windows XP. What do I need to get started? I don&#39;t want to use any 3rd party drivers or libraries - I have to start from scratch. Any suggestions appreciated.</div>
    <div class="meta">Posted on 2005-10-16 11:35:31 by marcinbu</div>
   </div>
   <div class="post" id="post-166963">
    <div class="subject"><a href="#post-166963">Re: Serial port sniffer</a></div>
    <div class="body">What exactly are you trying to sniff?<br /><br />At work, we needed to reverse engineer a protocol that used RS232 as its channel. The idea was to pass the signal through a computer with two serial ports, and bounce the data while recording it. I have tried a few commercial programs and none worked for that purpose. Most of them only monitored serial traffic that originated from software. I have programmed a simple program for that purpose, and here it is:<br /><pre><code>//###########################################################################<br />#include &lt;windows.h&gt;<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />//###########################################################################<br />//###########################################################################<br />HANDLE com[2];<br />//###########################################################################<br />//###########################################################################<br />void swap(DWORD* a, DWORD* b) {<br />	*a = *a ^ *b;<br />	*b = *a ^ *b;<br />	*a = *a ^ *b;<br />}<br />//###########################################################################<br />HANDLE openCommPort(const char* szCOMPort) {<br />	HANDLE hComm; COMMTIMEOUTS ctos; DCB dcb;<br />	<br />	hComm = CreateFile(szCOMPort, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);<br />	GetCommState(hComm, &amp;dcb);<br />	dcb.BaudRate = 9600;<br />	dcb.ByteSize = 8;<br />	dcb.StopBits = ONESTOPBIT;<br />	dcb.Parity = NOPARITY;<br />	dcb.fOutxCtsFlow = FALSE;<br />	dcb.fOutxDsrFlow = FALSE;<br />	dcb.fDsrSensitivity = FALSE;<br />	dcb.fNull = FALSE;<br />	dcb.fDtrControl = DTR_CONTROL_ENABLE;<br />	dcb.fRtsControl = RTS_CONTROL_ENABLE;<br />	dcb.XonChar = 0x02;<br />	dcb.XoffChar = 0x03;<br />	dcb.fOutX = FALSE;<br />	SetCommState(hComm, &amp;dcb);<br /><br />	memset(&amp;ctos, 0, sizeof(ctos));<br />	ctos.ReadIntervalTimeout = 10;<br />	ctos.ReadTotalTimeoutMultiplier = 10;<br />	ctos.ReadTotalTimeoutConstant = 10;<br />	ctos.WriteTotalTimeoutMultiplier = 10;<br />	ctos.WriteTotalTimeoutConstant = 10;<br />	SetCommTimeouts(hComm, &amp;ctos);<br /><br />	SetCommMask(hComm, EV_BREAK | EV_CTS | EV_DSR | EV_ERR | EV_RING | EV_RLSD | EV_RXCHAR | EV_RXFLAG | EV_TXEMPTY);<br /><br />	return hComm;<br />}<br />//###########################################################################<br />DWORD WINAPI CommThread(LPVOID lParam) {<br />	HANDLE* context = (HANDLE*)lParam;<br />	DWORD events, bytesRead, bytesWritten;<br />	char value[0x10]; WORD colour;<br />	HANDLE hEventRead, hEventWrite;<br />	OVERLAPPED ovlp;<br />	HANDLE hFileLog, hFileCombinedLog;<br /><br />	hFileLog = CreateFile((context[0] == com[0] ? &quot;com1recv.raw&quot; : &quot;com2recv.raw&quot;), GENERIC_WRITE, FILE_SHARE_READ, 0, OPEN_ALWAYS, 0, 0);<br />	hFileCombinedLog = CreateFile(&quot;combined.raw&quot;, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_ALWAYS, 0, 0);<br />	SetFilePointer(hFileLog, 0, 0, FILE_END);<br />	hEventRead = CreateEvent(0, 0, 0, 0);<br />	hEventWrite = CreateEvent(0, 0, 0, 0);<br />	colour = FOREGROUND_INTENSITY;<br />	colour |= (context[0] == com[0] ? (FOREGROUND_RED | FOREGROUND_GREEN) : (FOREGROUND_RED | FOREGROUND_BLUE));<br />	while(WaitCommEvent(context[0], &amp;events, 0)) {<br />		memset(&amp;ovlp, 0, sizeof(ovlp));<br />		ovlp.hEvent = hEventRead;<br />		ReadFile(context[0], value, sizeof(value), &amp;bytesRead, &amp;ovlp);<br />		if (WaitForSingleObject(hEventRead, INFINITE) == WAIT_OBJECT_0) {<br />			GetOverlappedResult(context[0], &amp;ovlp, &amp;bytesRead, 0);<br />			if (bytesRead &gt; 0) {<br />				SetFilePointer(hFileCombinedLog, 0, 0, FILE_END);<br />				WriteFile(hFileCombinedLog, value, bytesRead, &amp;bytesWritten, 0);<br />	<br />				WriteFile(hFileLog, value, bytesRead, &amp;bytesWritten, 0);<br /><br />				memset(&amp;ovlp, 0, sizeof(ovlp));<br />				ovlp.hEvent = hEventWrite;<br />				WriteFile(context[1], value, bytesRead, &amp;bytesWritten, &amp;ovlp);<br /><br />				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), colour);<br />				WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), value, bytesRead, &amp;bytesWritten, 0);<br />			}<br />		}<br />	}<br />	CloseHandle(hEventWrite);<br />	CloseHandle(hEventRead);<br />	return 0;<br />}<br />//###########################################################################<br />int main(int argc, char* argv&#91;]) {<br />	HANDLE thread[2]; DWORD tid;<br />	HANDLE context[2][2] = { { 0, 0 }, { 0, 0 } };<br /><br />	com[0] = openCommPort(&quot;COM1&quot;);<br />	com[1] = openCommPort(&quot;COM2&quot;);<br />	context[0][0] = com[0];<br />	context[0][1] = com[1];<br />	context[1][0] = com[1];<br />	context[1][1] = com[0];<br /><br />	thread[0] = CreateThread(0, 0, &amp;CommThread, context[0], 0, &amp;tid);<br />	thread[1] = CreateThread(0, 0, &amp;CommThread, context[1], 0, &amp;tid);<br />	WaitForSingleObject(thread[0], INFINITE);<br />	WaitForSingleObject(thread[1], INFINITE);<br />	CloseHandle(thread[1]);<br />	CloseHandle(thread[0]);<br /><br />	CloseHandle(com[1]);<br />	CloseHandle(com[0]);<br /><br />	return 0;<br />}<br />//###########################################################################<br />//###########################################################################</code></pre></div>
    <div class="meta">Posted on 2005-10-16 15:13:48 by comrade</div>
   </div>
  </div>
 </body>
</html>