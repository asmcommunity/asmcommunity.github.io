<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>masm32.lib-&gt;Alloc ... error on large allocation - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17348" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=17348">masm32.lib-&gt;Alloc ... error on large allocation</a></p>
   <div class="post" id="post-134380">
    <div class="subject"><a href="#post-134380">masm32.lib-&gt;Alloc ... error on large allocation</a></div>
    <div class="body">Hello,<br /><br />can it be, that Alloc only can handle allocations up to ca. 2 MB?<br /><br />If i allocate a larger block and write some data at the end of it, there is an error and the programm terminates.<br /><br />For example:<br /><br />Allocate 4 MB and use ZeroMemory.<br /><br />Is it a known bug, because VirtualAlloc works well.<br /><br /><br /><br />MfG Manuel.</div>
    <div class="meta">Posted on 2004-02-21 13:50:46 by other</div>
   </div>
   <div class="post" id="post-134382">
    <div class="subject"><a href="#post-134382">masm32.lib-&gt;Alloc ... error on large allocation</a></div>
    <div class="body">Alloc uses the IMalloc interface (and is sloppy code, heh) - anyway, the PlatformSDK description of IMalloc::Alloc doesn't mention any allocation size limits like this. Have you tried HeapAlloc instead?<br /><br />If you're doing large allocations like this and don't need to resize the block, you're probably better off using VirtualAlloc anyway.</div>
    <div class="meta">Posted on 2004-02-21 14:03:01 by f0dder</div>
   </div>
   <div class="post" id="post-134383">
    <div class="subject"><a href="#post-134383">masm32.lib-&gt;Alloc ... error on large allocation</a></div>
    <div class="body">Do you check that the memory was actually allocated?<br />Besides, the Alloc function in M32Lib is pretty, well, silly. Instead of using CoGetMalloc(), it would be better to use CoTaskMemAlloc(). Also, notice that it doesn't Release() the interface it got.</div>
    <div class="meta">Posted on 2004-02-21 14:09:59 by death</div>
   </div>
   <div class="post" id="post-134384">
    <div class="subject"><a href="#post-134384">masm32.lib-&gt;Alloc ... error on large allocation</a></div>
    <div class="body"><div class="quote"><br />Alloc uses the IMalloc interface (and is sloppy code, heh) - anyway, the PlatformSDK description of IMalloc::Alloc doesn't mention any allocation size limits like this. Have you tried HeapAlloc instead?<br /><br />If you're doing large allocations like this and don't need to resize the block, you're probably better off using VirtualAlloc anyway. </div><br /><br />I use VirtualAlloc and there are no problems. But is use VA for a memory-lib, which will be used for a dynamic string-lib (it set his length dynamically).<br />Is it better to use HeapAlloc instead. Can i use the ProcessHead or is it better to Create a new Heap?<br /><br /><br />MfG Manuel.</div>
    <div class="meta">Posted on 2004-02-21 14:28:22 by other</div>
   </div>
   <div class="post" id="post-134386">
    <div class="subject"><a href="#post-134386">masm32.lib-&gt;Alloc ... error on large allocation</a></div>
    <div class="body">Dynamic string lib... I guess I would use HeapAlloc for that, probably with a secondary heap - this way fragmentation can be reduced. I'd implement some additional bookkeeping ontop of HeapAlloc though: a bunch of 'slots' for the most common string sizes, so that allocation/deallocation of those could be very fast (ie, mark them unused in the slot table instead of HeapFree+HeapAlloc) - this approach is similar to the one used in SysAllocString... I'd rather design my own than using SysAllocString, though, as this gives more control. Also, I'd have the resizes grow in 'chunks' - keep track of &quot;stringsize&quot; and &quot;blocksize&quot;... this way you have less calls to Heap(Re)Alloc, and less fragmentation.<br /><br />You could get even better performance by using VirtualAlloc as the memory allocation 'primitive' instead of HeapAlloc, but this requires a whole lot of additional code... managing chunks of memory, etc. And if not done right, you could end up with worse performance. I'd say give HeapAlloc with an additional heap a go first, see if it meets your performance requirements. If not, a heavy-duty VirtualAlloc version could be implemented.</div>
    <div class="meta">Posted on 2004-02-21 14:51:47 by f0dder</div>
   </div>
   <div class="post" id="post-134392">
    <div class="subject"><a href="#post-134392">masm32.lib-&gt;Alloc ... error on large allocation</a></div>
    <div class="body"><div class="quote"><br />Dynamic string lib... I guess I would use HeapAlloc for that, probably with a secondary heap - this way fragmentation can be reduced. I'd implement some additional bookkeeping ontop of HeapAlloc though: a bunch of 'slots' for the most common string sizes, so that allocation/deallocation of those could be very fast (ie, mark them unused in the slot table instead of HeapFree+HeapAlloc) - this approach is similar to the one used in SysAllocString... I'd rather design my own than using SysAllocString, though, as this gives more control. Also, I'd have the resizes grow in 'chunks' - keep track of &quot;stringsize&quot; and &quot;blocksize&quot;... this way you have less calls to Heap(Re)Alloc, and less fragmentation.</strong><br /></div><br /><br />In a similar way i have done this:<br /><br /><pre><code><br />  POINTER typedef DWORD<br />  PPOINTER typedef DWORD <br /><br />  ; Memory <br />  ; -12&#58; Blocksize<br />  ; -8&#58; can be used from caller ; Status, Len etc.<br /><br />.const<br />  BLOCKSIZE		equ		1024<br />  BLOCKMASK		equ		0FFFFFFFFh - &#40;BLOCKSIZE - 1&#41;<br />  STATUSSIZE	equ		3 * SIZEOF DWORD<br /><br />AllocMem proc nSize&#58; DWORD<br /><br />  ; align<br />	MOV ECX, nSize<br />	ADD ECX, BLOCKSIZE + STATUSSIZE - 1<br />	AND ECX, BLOCKMASK<br />	PUSH ECX<br />	<br />  ; alloc<br />;	invoke Alloc, ECX<br />	invoke VirtualAlloc, NULL, ECX, MEM_COMMIT or MEM_RESERVE, PAGE_READWRITE  ; better will be a memory manager, which distribute memory blocks<br />	<br />  ; set size<br />	POP ECX<br />	<br />	MOV &#91;EAX&#93;, ECX<br />	LEA EAX, &#91;EAX+STATUSSIZE&#93;<br /><br />	Ret<br />AllocMem EndP<br /></code></pre><br /><br />And then, when i ReAllocate Memory, i use the following code:<br /><br /><pre><code><br />ReAllocMem proc p&#58; PPOINTER, nSize&#58; DWORD<br />	<br />	MOV EDX, p<br />	.if DWORD PTR &#91;EDX&#93; == NULL<br />		invoke AllocMem, nSize<br />		MOV EDX, p<br />		MOV &#91;EDX&#93;, EAX<br />	.else<br />		MOV EDX, &#91;EDX&#93;<br />		MOV ECX, &#91;EDX-STATUSSIZE&#93;<br />		.if ECX &lt; nSize<br />			&#123; allocate new, copy old buffer to new, deallocate mem-block &#125;<br /><br />...<br /></code></pre><br /><br /><br />Thats a small part of the string library:<br /><br /><pre><code><br />StrNew proc nSize&#58; DWORD<br />	MOV ECX, nSize<br />	LEA ECX, &#91;ECX+4&#93;     ; 1 = #0; 3 = align<br />	AND ECX, 0FFFFFFFCh  ; align to 4 byte<br />    invoke AllocMem, ECX<br />    MOV ECX, nSize<br />    MOV &#91;EAX-4&#93;, ECX<br />	Ret<br />StrNew EndP<br /><br /><br />StrReAlloc proc pasmstr&#58; PASMSTRING, nSize&#58; DWORD<br />	MOV ECX, nSize<br />	LEA ECX, &#91;ECX+4&#93;     ; 1 = #0; 3 = align<br />	AND ECX, 0FFFFFFFCh  ; align to 4 byte<br />    invoke ReAllocMem, pasmstr, ECX<br />    MOV ECX, nSize<br />    MOV &#91;EAX-4&#93;, ECX<br />	Ret<br />StrReAlloc EndP<br /><br />SetLength proc pasmstr&#58; PASMSTRING, nSize&#58; DWORD<br />	MOV EDX, pasmstr<br /><br />	; asmstr empty?<br />	.if DWORD PTR &#91;EDX&#93; == NULL<br />	   invoke StrNew, nSize<br />	   MOV EDX, pasmstr<br />       MOV &#91;EDX&#93;, EAX<br />    .else  <br />       MOV EDX, &#91;EDX&#93;    <br />       MOV ECX, &#91;EDX-4&#93;<br />       .if ECX &lt; nSize ; buffer to small<br />          invoke StrReAlloc, pasmstr, nSize<br />       .else <br />          MOV ECX, nSize<br />          MOV &#91;EDX-4&#93;, ECX<br />          MOV EAX, EDX<br />       .endif           <br />    .endif<br />	Ret<br />SetLength EndP<br /><br />StrAdd proc asDest&#58; PASMSTRING, asSrc&#58; ASMSTRING<br />	invoke StrLength, asSrc<br />	.if EAX &gt; 0<br />	   MOV ECX, EAX<br />	   PUSH ECX<br />	   MOV EDX, asDest<br />	   invoke StrLength, DWORD PTR &#91;EDX&#93;<br />	   PUSH EAX<br />	   ADD ECX, EAX<br />	   Invoke SetLength, asDest, ECX<br />	   POP EAX  ; asDest<br />	   POP ECX  ; asSrc<br />	   MOV EDX, asDest<br />	   MOV EDX, &#91;EDX&#93;<br />	   LEA EDX, &#91;EDX+EAX&#93;<br />	   PUSH EDX<br />	   PUSH ECX<br />	   invoke CopyMem, EDX, asSrc, ECX<br />	   POP ECX<br />	   POP EDX<br />	   MOV BYTE PTR &#91;EDX+ECX&#93;, BYTE PTR 0<br />	.endif	<br />		<br />	Ret<br />StrAdd EndP<br /></code></pre><br /><br /><br /><div class="quote"><br />You could get even better performance by using VirtualAlloc as the memory allocation 'primitive' instead of HeapAlloc, but this requires a whole lot of additional code... managing chunks of memory, etc. And if not done right, you could end up with worse performance. I'd say give HeapAlloc with an additional heap a go first, see if it meets your performance requirements. If not, a heavy-duty VirtualAlloc version could be implemented. </div><br /><br />I consider to implement a memory manager which will be distribute the memory blocks.<br /><br /><br />Regards, Manuel.</div>
    <div class="meta">Posted on 2004-02-21 16:15:32 by other</div>
   </div>
  </div>
 </body>
</html>