<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Optimization Tips for Assembly - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19976" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=19976">Optimization Tips for Assembly</a></p>
   <div class="post" id="post-153258">
    <div class="subject"><a href="#post-153258">Optimization Tips for Assembly</a></div>
    <div class="body">There is an excellent optimization tutorial by Mark Larson at<br /><br />                               www.visionx.com/markl/optimization_tips.htm<br /><br />Apology to all of you who already know about this.</div>
    <div class="meta">Posted on 2004-11-20 09:56:38 by penang</div>
   </div>
   <div class="post" id="post-153374">
    <div class="subject"><a href="#post-153374">Optimization Tips for Assembly</a></div>
    <div class="body">Thanks for posting the link.  I actually posted it when I first wrote the page.  However, I should probably post it from time to time.  <br /><br />I have a copy up on masmforum as well, because Hutch-- was kind enough to give me webspace.<br />http://masmforum.com/website/mark/index.htm<br /><br /><br />I've also written some assembler optimization tutorials in case anyone is interested.  All on masmforum.<br /><br /><strong>Using SSE2 to do Quaternions</strong> ( used in game programming):<br />http://www.masmforum.com/viewtopic.php?t=3469&amp;highlight=quaternions<br /><br /><strong>Mersenne Twister Random Number Generator optimization tutorial</strong>.  The author of the mersenne twister's C code runs in 258 cycles.  Agner Fog's P4 SSE2 code for the mersenne twister runs in 44 cycles.  My ALU code runs in 25 cycles ( 10 times faster than the author's code, and almost twice as fast as Agner's SSE2 code).  Yes, you read that right, my ALU code is running faster than Agner's SSE2 code.  It's because I optimized it specifically for the P4, and you can execute up to 4 ALU instructions in parallel if you do it right.  I then wrote an SSE2 version that runs in 14 cycles ( 18.5 times faster than the author's code, and 3.1 times faster than Agner's SSE2 code).<br />http://www.masmforum.com/viewtopic.php?t=3565&amp;highlight=mersenne+twister<br /><br /><br /><strong>How to optimize C code into fast assembler code</strong>.  This was the first one I did.  It is 6 pages due to all the replies I was getting from people.  Jibz was kind enough to offer some better optimized C code to compare against.  I took the original code from a book on optimizing C.  I wanted to show how to speed up already highly optimized C code using assembler.<br />http://www.masmforum.com/viewtopic.php?t=3329&amp;highlight=optimization+tutorial<br /><br /><br />My account got messed up on masmforum.  I had to get a new account.  Some of my old posts now say hutch-- and some say marklarson.  I participated in the MD5CRK project ( http://www.md5crk.com).  You can see where Jean-luc gave me credit here: http://www.md5crk.com/?sec=aboutmd5client ( search for &quot;larson&quot;).  My code runs 10 times faster than the standard C code.  I also posted the code on masmforum but it says hutch-- ( because of that I previously mentioned problem).  <br />http://www.masmforum.com/viewtopic.php?t=2921&amp;highlight=md5</div>
    <div class="meta">Posted on 2004-11-22 16:06:36 by mark_larson</div>
   </div>
   <div class="post" id="post-153391">
    <div class="subject"><a href="#post-153391">Optimization Tips for Assembly</a></div>
    <div class="body">Excellent work <strong>Mark</strong>!  :alright:  I will be using the Twister code extensively.</div>
    <div class="meta">Posted on 2004-11-22 23:18:39 by bitRAKE</div>
   </div>
   <div class="post" id="post-153553">
    <div class="subject"><a href="#post-153553">Optimization Tips for Assembly</a></div>
    <div class="body">I forgot this.  I wrote some macros for Masm 6.14 ( the version that comes with MASM32) to use SSE3.  They are useful if you have a Prescott processor.<br /><br />I tried uploading the file but the board is not giving me that option.  So I am cutting and pasting instead.<br /><br /><pre><code><br />;SSE3 macros Written By&#58; Mark Larson, Mark_Larson@dell.com<br />;These macros support all 13 of the new SSE3 instructions.  <br />;List of Supported SSE3 instructions<br />;01&#41;  ADDSUBPD<br />;02&#41;  ADDSUBPS<br />;03&#41;  HADDPD<br />;04&#41;  HADDPS<br />;05&#41;  HSUBPD<br />;06&#41;  HSUBPS<br />;07&#41;  MOVDDUP<br />;08&#41;  MOVSLDUP<br />;09&#41;  MOVSHDUP<br />;10&#41;  LDDQU<br />;11&#41;  MONITOR<br />;12&#41;  MWAIT<br />;13&#41;  FISTTP<br /><br />ADDSUBPD	macro reg1&#58;req, reg2&#58;req<br />	local	do_override<br />	local	start_modify<br />	local	end_modify<br />	local	reg_sub<br /><br />	do_override = 0						;Initialize that we have seen an override to not seen.<br />	reg_sub textequ @SubStr&#40;reg2,1,3&#41;	;Get the first 3 characters of the second passed in parameter<br />										;We want to try and see if their is a segment override<br />IFIDNI reg_sub, &lt;cs&#58;&gt;					;CS override?<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ds&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;es&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;fs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;gs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ss&#58;&gt;<br />	do_override = 1<br />ENDIF<br /><br /><br />;overrides get added in IN front of Mod R/M in the opcode.  So the byte we modify to convert the<br />; ADDPD to a ADDSUBPD may change by 1 byte, if a segment override has been used in a memory access.<br /><br />	db	066h			;This forces the following ADDPS to reallly be an ADDPD.<br />start_modify equ $<br />	addps	reg1,reg2	;I am using ADDPS since it is supported with MASM 6.14, which comes with MASM32<br />end_modify equ $<br />	org &#40;start_modify+1+do_override&#41;;Go back to the &quot;58&quot; and change it to a &quot;D0&quot;<br />	db	0D0h			;Change the ADDPD from a &quot;66 0f 58 /r&quot; to a &quot;66 0f D0 /r&quot; which is a ADDSUBPD<br />	org	&#40;end_modify&#41;	;Go to the last byte in the opcode.<br />endm<br /><br />ADDSUBPS	macro reg1&#58;req, reg2&#58;req<br />	local	do_override<br />	local	start_modify<br />	local	end_modify<br />	local	reg_sub<br /><br />	do_override = 0						;Initialize that we have seen an override to not seen.<br />	reg_sub textequ @SubStr&#40;reg2,1,3&#41;	;Get the first 3 characters of the second passed in parameter<br />										;We want to try and see if their is a segment override<br />IFIDNI reg_sub, &lt;cs&#58;&gt;					;CS override?<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ds&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;es&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;fs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;gs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ss&#58;&gt;<br />	do_override = 1<br />ENDIF<br /><br /><br />;overrides get added in IN front of Mod R/M in the opcode.  So the byte we modify to convert the<br />; ADDPS to a ADDSUBPS may change by 1 byte, if a segment override has been used in a memory access.<br /><br />	db	0F2h			;We add an F2h in front since the opcode for ADDSUBPS is &quot;F2,0F,D0,/r&quot;<br />start_modify equ $<br />	addps	reg1,reg2	;I am using ADDPS since it is supported with MASM 6.14, which comes with MASM32<br />end_modify equ $<br />	org &#40;start_modify+1+do_override&#41;;Go back to the &quot;58&quot; and change it to a &quot;D0&quot;<br />	db	0D0h			;Change the ADDPS from a &quot;0f 58 /r&quot; to a &quot;0f D0 /r&quot; which is a ADDSUBPS<br />	org	&#40;end_modify&#41;	;Go to the last byte in the opcode.<br />endm<br /><br />HADDPD	macro reg1&#58;req, reg2&#58;req<br />	local	do_override<br />	local	start_modify<br />	local	end_modify<br />	local	reg_sub<br /><br />	do_override = 0						;Initialize that we have seen an override to not seen.<br />	reg_sub textequ @SubStr&#40;reg2,1,3&#41;	;Get the first 3 characters of the second passed in parameter<br />										;We want to try and see if their is a segment override<br />IFIDNI reg_sub, &lt;cs&#58;&gt;					;CS override?<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ds&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;es&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;fs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;gs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ss&#58;&gt;<br />	do_override = 1<br />ENDIF<br /><br /><br />;overrides get added in IN front of Mod R/M in the opcode.  So the byte we modify to convert the<br />; ADDPD to a HADDPD may change by 1 byte, if a segment override has been used in a memory access.<br /><br />	db	066h			;This forces the following ADDPS to reallly be an ADDPD.<br />start_modify equ $<br />	addps	reg1,reg2	;I am using ADDPS since it is supported with MASM 6.14, which comes with MASM32<br />end_modify equ $<br />	org &#40;start_modify+1+do_override&#41;;Go back to the &quot;58&quot; and change it to a &quot;7C&quot;<br />	db	07Ch			;Change the ADDPD from a &quot;66 0f 58 /r&quot; to a &quot;66,0F,7C,/r&quot; which is a HADDPD<br />	org	&#40;end_modify&#41;	;Go to the last byte in the opcode.<br />endm<br /><br />HADDPS	macro reg1&#58;req, reg2&#58;req<br />	local	do_override<br />	local	start_modify<br />	local	end_modify<br />	local	reg_sub<br /><br />	do_override = 0						;Initialize that we have seen an override to not seen.<br />	reg_sub textequ @SubStr&#40;reg2,1,3&#41;	;Get the first 3 characters of the second passed in parameter<br />										;We want to try and see if their is a segment override<br />IFIDNI reg_sub, &lt;cs&#58;&gt;					;CS override?<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ds&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;es&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;fs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;gs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ss&#58;&gt;<br />	do_override = 1<br />ENDIF<br /><br /><br />;overrides get added in IN front of Mod R/M in the opcode.  So the byte we modify to convert the<br />; ADDPS to a HADDPS may change by 1 byte, if a segment override has been used in a memory access.<br /><br />	db	0F2h			;We add an F2h in front since the opcode for HADDPS is &quot;F2,0F,7C,/r&quot;<br />start_modify equ $<br />	addps	reg1,reg2	;I am using ADDPS since it is supported with MASM 6.14, which comes with MASM32<br />end_modify equ $<br />	org &#40;start_modify+1+do_override&#41;;Go back to the &quot;58&quot; and change it to a &quot;7C&quot;<br />	db	07Ch			;Change the ADDPS from a &quot;0f 58 /r&quot; to a &quot;F2,0F,7C,/r&quot; which is a HADDPS<br />	org	&#40;end_modify&#41;	;Go to the last byte in the opcode.<br />endm<br /><br />HSUBPD	macro reg1&#58;req, reg2&#58;req<br />	local	do_override<br />	local	start_modify<br />	local	end_modify<br />	local	reg_sub<br /><br />	do_override = 0						;Initialize that we have seen an override to not seen.<br />	reg_sub textequ @SubStr&#40;reg2,1,3&#41;	;Get the first 3 characters of the second passed in parameter<br />										;We want to try and see if their is a segment override<br />IFIDNI reg_sub, &lt;cs&#58;&gt;					;CS override?<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ds&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;es&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;fs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;gs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ss&#58;&gt;<br />	do_override = 1<br />ENDIF<br /><br /><br />;overrides get added in IN front of Mod R/M in the opcode.  So the byte we modify to convert the<br />; ADDPD to a HSUBPD may change by 1 byte, if a segment override has been used in a memory access.<br /><br />	db	066h			;This forces the following ADDPS to reallly be an ADDPD.<br />start_modify equ $<br />	addps	reg1,reg2	;I am using ADDPS since it is supported with MASM 6.14, which comes with MASM32<br />end_modify equ $<br />	org &#40;start_modify+1+do_override&#41;;Go back to the &quot;58&quot; and change it to a &quot;7D&quot;<br />	db	07Dh			;Change the ADDPD from a &quot;66 0f 58 /r&quot; to a &quot;66,0F,7D,/r&quot; which is a HSUBPD<br />	org	&#40;end_modify&#41;	;Go to the last byte in the opcode.<br />endm<br /><br />HSUBPS	macro reg1&#58;req, reg2&#58;req<br />	local	do_override<br />	local	start_modify<br />	local	end_modify<br />	local	reg_sub<br /><br />	do_override = 0						;Initialize that we have seen an override to not seen.<br />	reg_sub textequ @SubStr&#40;reg2,1,3&#41;	;Get the first 3 characters of the second passed in parameter<br />										;We want to try and see if their is a segment override<br />IFIDNI reg_sub, &lt;cs&#58;&gt;					;CS override?<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ds&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;es&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;fs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;gs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ss&#58;&gt;<br />	do_override = 1<br />ENDIF<br /><br /><br />;overrides get added in IN front of Mod R/M in the opcode.  So the byte we modify to convert the<br />; ADDPS to a HSUBPS may change by 1 byte, if a segment override has been used in a memory access.<br /><br />	db	0F2h			;We add an F2h in front since the opcode for HSUBPS is &quot;F2,0F,7D,/r&quot;<br />start_modify equ $<br />	addps	reg1,reg2	;I am using ADDPS since it is supported with MASM 6.14, which comes with MASM32<br />end_modify equ $<br />	org &#40;start_modify+1+do_override&#41;;Go back to the &quot;58&quot; and change it to a &quot;7D&quot;<br />	db	07Dh			;Change the ADDPS from a &quot;0f 58 /r&quot; to a &quot;F2,0F,7D,/r&quot; which is a HSUBPS<br />	org	&#40;end_modify&#41;	;Go to the last byte in the opcode.<br />endm<br /><br />MOVDDUP	macro reg1&#58;req, reg2&#58;req<br />	local	do_override<br />	local	start_modify<br />	local	end_modify<br />	local	reg_sub<br /><br />	do_override = 0						;Initialize that we have seen an override to not seen.<br />	reg_sub textequ @SubStr&#40;reg2,1,3&#41;	;Get the first 3 characters of the second passed in parameter<br />										;We want to try and see if their is a segment override<br />IFIDNI reg_sub, &lt;cs&#58;&gt;					;CS override?<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ds&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;es&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;fs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;gs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ss&#58;&gt;<br />	do_override = 1<br />ENDIF<br /><br /><br />;overrides get added in IN front of Mod R/M in the opcode.  So the byte we modify to convert the<br />; ADDPS to a MOVDDUP may change by 1 byte, if a segment override has been used in a memory access.<br /><br />	db	0F2h			;We add an F2h in front since the opcode for MOVDDUP is &quot;F2,0F,12,/r&quot;<br />start_modify equ $<br />	addps	reg1,reg2	;I am using ADDPS since it is supported with MASM 6.14, which comes with MASM32<br />end_modify equ $<br />	org &#40;start_modify+1+do_override&#41;;Go back to the &quot;58&quot; and change it to a &quot;12&quot;<br />	db	012h			;Change the ADDPS from a &quot;0f 58 /r&quot; to a &quot;F2,0F,12,/r&quot; which is a MOVDDUP<br />	org	&#40;end_modify&#41;	;Go to the last byte in the opcode.<br />endm<br /><br />MOVSLDUP	macro reg1&#58;req, reg2&#58;req<br />	local	do_override<br />	local	start_modify<br />	local	end_modify<br />	local	reg_sub<br /><br />	do_override = 0						;Initialize that we have seen an override to not seen.<br />	reg_sub textequ @SubStr&#40;reg2,1,3&#41;	;Get the first 3 characters of the second passed in parameter<br />										;We want to try and see if their is a segment override<br />IFIDNI reg_sub, &lt;cs&#58;&gt;					;CS override?<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ds&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;es&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;fs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;gs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ss&#58;&gt;<br />	do_override = 1<br />ENDIF<br /><br /><br />;overrides get added in IN front of Mod R/M in the opcode.  So the byte we modify to convert the<br />; ADDPS to a MOVSLDUP may change by 1 byte, if a segment override has been used in a memory access.<br /><br />	db	0F3h			;We add an F3h in front since the opcode for MOVSLDUP is &quot;F3,0F,12,/r&quot;<br />start_modify equ $<br />	addps	reg1,reg2	;I am using ADDPS since it is supported with MASM 6.14, which comes with MASM32<br />end_modify equ $<br />	org &#40;start_modify+1+do_override&#41;;Go back to the &quot;58&quot; and change it to a &quot;12&quot;<br />	db	012h			;Change the ADDPS from a &quot;0f 58 /r&quot; to a &quot;F3,0F,12,/r&quot; which is a MOVSLDUP<br />	org	&#40;end_modify&#41;	;Go to the last byte in the opcode.<br />endm<br /><br />MOVSHDUP	macro reg1&#58;req, reg2&#58;req<br />	local	do_override<br />	local	start_modify<br />	local	end_modify<br />	local	reg_sub<br /><br />	do_override = 0						;Initialize that we have seen an override to not seen.<br />	reg_sub textequ @SubStr&#40;reg2,1,3&#41;	;Get the first 3 characters of the second passed in parameter<br />										;We want to try and see if their is a segment override<br />IFIDNI reg_sub, &lt;cs&#58;&gt;					;CS override?<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ds&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;es&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;fs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;gs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ss&#58;&gt;<br />	do_override = 1<br />ENDIF<br /><br /><br />;overrides get added in IN front of Mod R/M in the opcode.  So the byte we modify to convert the<br />; ADDPS to a MOVSHDUP may change by 1 byte, if a segment override has been used in a memory access.<br /><br />	db	0F3h			;We add an F2h in front since the opcode for MOVSHDUP is &quot;F3,0F,16,/r&quot;<br />start_modify equ $<br />	addps	reg1,reg2	;I am using ADDPS since it is supported with MASM 6.14, which comes with MASM32<br />end_modify equ $<br />	org &#40;start_modify+1+do_override&#41;;Go back to the &quot;58&quot; and change it to a &quot;16&quot;<br />	db	016h			;Change the ADDPS from a &quot;0f 58 /r&quot; to a &quot;F3,0F,16,/r&quot; which is a MOVSHDUP<br />	org	&#40;end_modify&#41;	;Go to the last byte in the opcode.<br />endm<br /><br />;The MONITOR instruction requires certain registers to be set up PRIOR to calling the instruction.<br />MONITOR	macro<br />	db	0Fh,01h,0C8h	;Opcodes for MONITOR<br />endm<br /><br />;The MWAIT instruction requires certain registers to be set up PRIOR to calling the instruction.<br />MWAIT	macro<br />	db	0Fh,01h,0C9h	;Opcodes for MWAIT<br />endm<br /><br />;The LDDQU instruction does not support using an XMM register.  So if you try and pass in an XMM register<br />; the macro prints an error message and does an .ERR<br />LDDQU	macro reg1&#58;req, reg2&#58;req<br />	local	do_override<br />	local	start_modify<br />	local	end_modify<br />	local	reg_sub<br /><br />;we do not allow the second parameter to be a register.  It has to be a memory location<br />IFIDNI &lt;reg2&gt;, &lt;xmm0&gt;					;CS override?<br />	echo ERROR&#58; The second parameter &#40; source&#41; has to be a memory location<br />	.err<br />ELSEIFIDNI &lt;reg2&gt;, &lt;xmm1&gt;					;CS override?<br />	echo ERROR&#58; The second parameter &#40; source&#41; has to be a memory location<br />	.err<br />ELSEIFIDNI &lt;reg2&gt;, &lt;xmm2&gt;					;CS override?<br />	echo ERROR&#58; The second parameter &#40; source&#41; has to be a memory location<br />	.err<br />ELSEIFIDNI &lt;reg2&gt;, &lt;xmm3&gt;					;CS override?<br />	echo ERROR&#58; The second parameter &#40; source&#41; has to be a memory location<br />	.err<br />ELSEIFIDNI &lt;reg2&gt;, &lt;xmm4&gt;					;CS override?<br />	echo ERROR&#58; The second parameter &#40; source&#41; has to be a memory location<br />	.err<br />ELSEIFIDNI &lt;reg2&gt;, &lt;xmm5&gt;					;CS override?<br />	echo ERROR&#58; The second parameter &#40; source&#41; has to be a memory location<br />	.err<br />ELSEIFIDNI &lt;reg2&gt;, &lt;xmm6&gt;					;CS override?<br />	echo ERROR&#58; The second parameter &#40; source&#41; has to be a memory location<br />	.err<br />ELSEIFIDNI &lt;reg2&gt;, &lt;xmm7&gt;					;CS override?<br />	echo ERROR&#58; The second parameter &#40; source&#41; has to be a memory location<br />	.err<br />ENDIF<br /><br />	do_override = 0						;Initialize that we have seen an override to not seen.<br />	reg_sub textequ @SubStr&#40;reg2,1,3&#41;	;Get the first 3 characters of the second passed in parameter<br />										;We want to try and see if their is a segment override<br />IFIDNI reg_sub, &lt;cs&#58;&gt;					;CS override?<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ds&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;es&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;fs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;gs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ss&#58;&gt;<br />	do_override = 1<br />ENDIF<br /><br /><br />;overrides get added in IN front of Mod R/M in the opcode.  So the byte we modify to convert the<br />; ADDPS to a LDDQU may change by 1 byte, if a segment override has been used in a memory access.<br /><br />	db	0F2h			;We add an F2h in front since the opcode for LDDQU is &quot;F2,0F,F0,/r&quot;<br />start_modify equ $<br />	addps	reg1,reg2	;I am using ADDPS since it is supported with MASM 6.14, which comes with MASM32<br />end_modify equ $<br />	org &#40;start_modify+1+do_override&#41;;Go back to the &quot;58&quot; and change it to a &quot;F0&quot;<br />	db	0F0h			;Change the ADDPS from a &quot;0f 58 /r&quot; to a &quot;F2,0F,F0,/r&quot; which is a LDDQU<br />	org	&#40;end_modify&#41;	;Go to the last byte in the opcode.<br />endm<br /><br />;FISTTP works on 3 different memory types.  Word, Dword, and Qword.  Don't forget to specify the appropriate pointer when<br />; using it with memory.  If you don't specify a pointer or one too big it forces an .ERR and prints an error message.<br />FISTTP	macro reg1&#58;req<br />	local	do_override<br />	local	start_modify<br />	local	end_modify<br />	local	reg_sub<br />	local	fisttp_size<br />	local	fisttp_type<br />	local	cur_offset<br />	local	last_offset<br /><br />	do_override = 0						;Initialize that we have seen an override to not seen.<br /><br />	last_offset = @SizeStr&#40;reg1&#41;		;Get size of passed in argument.<br />	last_offset = last_offset - 3		;We look at 3 bytes in the argument at a time.<br />	cur_offset = 1						;Start at the first byte of the argument.<br /><br />;I could not get InStr to work properly so I had to do it this way by scanning through the passed in value a byte at a time<br />; looking for an override.<br />WHILE cur_offset LE last_offset<br />	reg_sub textequ @SubStr&#40;reg1,cur_offset,3&#41;	;Get the first 3 characters of the second passed in parameter<br /><br />IFIDNI reg_sub, &lt;cs&#58;&gt;					;CS override?<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ds&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;es&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;fs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;gs&#58;&gt;<br />	do_override = 1<br />ELSEIFIDNI reg_sub, &lt;ss&#58;&gt;<br />	do_override = 1<br />ENDIF<br /><br />	cur_offset = cur_offset + 1<br />endm<br /><br /><br />;the TYPE operator returns the following when used in REG1 which is passed to the macro<br />;1 if no pointer used &#40; it assumes byte&#41;<br />;1 if byte pointer used<br />;2 if word pointer used<br />;4 if dword pointer used<br />;8 if qword pointer used<br />	fisttp_size equ TYPE reg1	;1 if byte pointer, 2 if word pointer, 4 if dword pointer, and 8 if qword pointer<br />if fisttp_size EQ 1<br />	echo ERROR&#58; you have to pass in &quot;word ptr&quot;, &quot;dword ptr&quot; or &quot;qword ptr&quot;.<br />	.err<br />elseif fisttp_size EQ 2<br />	fisttp_type equ 0DFh		;opcode for using WORD sized fisttp<br />elseif fisttp_size EQ 4<br />	fisttp_type equ 0DBh		;opcode for using DWORD sized fisttp<br />elseif fisttp_size EQ 8<br />	fisttp_type equ 0DDh		;opcode for using QWORD sized fisttp<br />else<br />	echo ERROR&#58; you have to pass in &quot;word ptr&quot;, &quot;dword ptr&quot; or &quot;qword ptr&quot;.<br />	.err<br />endif<br /><br />;overrides get added in IN front of Mod R/M in the opcode.  So the byte we modify to convert the<br />; FISTP to a FISTTP may change by 1 byte, if a segment override has been used in a memory access.<br /><br />start_modify equ $<br />	fimul word ptr reg1			;adds on the segment override prefix if one is present.<br />								;Also forces the user to pass in a valid memory address<br />end_modify equ $<br />	org &#40;start_modify+do_override&#41;;Go back to the byte in the FIMUL<br />	db	fisttp_type				;Change the FIMUL byte to a FISTTP byte<br />	org	&#40;end_modify&#41;			;Go to the last byte in the opcode.<br />endm<br /><br /></code></pre></div>
    <div class="meta">Posted on 2004-12-01 15:11:59 by mark_larson</div>
   </div>
  </div>
 </body>
</html>