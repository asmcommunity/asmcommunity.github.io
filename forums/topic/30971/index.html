<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>how use the reverse CRC32 ? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30971" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=30971">how use the reverse CRC32 ?</a></p>
   <div class="post" id="post-216561">
    <div class="subject"><a href="#post-216561">how use the reverse CRC32 ?</a></div>
    <div class="body"><span style="font-size:10pt>1. while the chars &gt; 4 bytes, the z0mbie_Rcrc32 can&#039;t works well.<br />2. how do you use the z0mbie_Xcrc32 ?</span><br /><pre><code>.686p<br />.model flat, stdcall&nbsp; ;32 bit memory model<br />option casemap :none&nbsp; ;case sensitive<br /><br />include \masm32\include\windows.inc<br />include \masm32\include\masm32.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\user32.inc<br />include \masm32\include\Comdlg32.inc<br />include \masm32\include\debug.inc<br /><br />includelib \masm32\lib\kernel32.lib<br />includelib \masm32\lib\user32.lib<br />includelib \masm32\lib\Comdlg32.lib<br />includelib \masm32\lib\masm32.lib<br />includelib \masm32\lib\debug.lib<br /><br />include \masm32\macros\macros.asm<br /><br />.const<br />	IDD_DLGNATIVECRY	equ 101<br />	IDC_EDTINPUT		equ 1002<br />	IDC_EDTOUTPUT		equ 1005<br />	IDC_EDTCRC32		equ 1006<br />	IDC_BTNCLEAR		equ 1007<br />	IDC_BTNRCRC		equ 1008<br />	IDC_BTNEXIT		equ 1009<br /><br />.data?<br />	ByteNum		dd	?<br />	hwnd		dd	?<br />	Temp_Buf	dd	?<br />	Crc32Value	dd	?<br />	Crc32len	dd	?<br />	hInstance	dd	?<br />	szCRC32		db	16 dup (?)<br />	szInput		db	8192 dup (?)<br />	szOutput	db	8192 dup (?)<br /><br />.code<br /><br />z0mbie_Crc32 proc uses ebx pData:dword,dwSize:dword<br />	; retValue=eax<br /><br />	mov	edx,pData<br />	mov	ecx,dwSize<br />	mov	eax,0<br /><br />	jecxz&nbsp;  @@4<br />&nbsp; &nbsp; &nbsp; &nbsp; not&nbsp; &nbsp;  eax<br />@@1:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />	xor&nbsp; &nbsp;  al, <br />&nbsp; &nbsp; &nbsp; &nbsp; inc&nbsp; &nbsp;  edx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  bl, 8<br />@@2:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />	shr&nbsp; &nbsp;  eax, 1<br />&nbsp; &nbsp; &nbsp; &nbsp; jnc&nbsp; &nbsp;  @@3<br />&nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp;  eax, 0EDB88320h<br />@@3:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />	dec&nbsp; &nbsp;  bl<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz&nbsp; &nbsp;  @@2<br />&nbsp; &nbsp; &nbsp; &nbsp; loop&nbsp; &nbsp; @@1<br />&nbsp; &nbsp; &nbsp; &nbsp; not&nbsp; &nbsp;  eax<br />@@4:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />	ret<br /><br />z0mbie_Crc32 endp<br /><br />z0mbie_Rcrc32 proc uses ebx pData:dword,dwSize:dword,dwCRC32:dword<br />; input:&nbsp; EDX=data, ECX=size, EAX=crc<br />; output: EAX=crc, EDX+=ECX, ECX=BL=0<br />;int 3	<br />	mov	edx,pData<br />	mov	ecx,dwSize<br />	mov	eax,dwCRC32<br />	<br />	jecxz&nbsp;  @@4<br />&nbsp; &nbsp; &nbsp; &nbsp; not&nbsp; &nbsp;  eax<br />@@1:&nbsp; &nbsp; <br />	mov&nbsp; &nbsp;  bl, <br />&nbsp; &nbsp; &nbsp; &nbsp; shl&nbsp; &nbsp;  ebx, 24<br />&nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp;  eax, ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  bl, 8<br />@@2:&nbsp; &nbsp; <br />	shl&nbsp; &nbsp;  eax, 1<br />&nbsp; &nbsp; &nbsp; &nbsp; jnc&nbsp; &nbsp;  @@3<br />&nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp;  eax, 0DB710641h<br />@@3:&nbsp; &nbsp; <br />	dec&nbsp; &nbsp;  bl<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz&nbsp; &nbsp;  @@2<br />&nbsp; &nbsp; &nbsp; &nbsp; loop&nbsp; &nbsp; @@1<br />&nbsp; &nbsp; &nbsp; &nbsp; not&nbsp; &nbsp;  eax<br />@@4:&nbsp; &nbsp; <br />	ret<br /><br />z0mbie_Rcrc32 endp<br /><br />z0mbie_Xcrc32 proc uses ebx pData:dword,dwSize:dword,dwCRC32:dword<br />; input:&nbsp; EDX=data, ECX=size, EAX=crc<br />; output: EAX=crc, EDX+=ECX, ECX=BL=0<br />;int 3	<br />	mov	edx,pData<br />	mov	ecx,dwSize<br />	mov	eax,dwCRC32<br />	<br />	jecxz&nbsp;  @@4<br />&nbsp; &nbsp; &nbsp; &nbsp; not&nbsp; &nbsp;  eax<br />@@1:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />	xor&nbsp; &nbsp;  al, <br />&nbsp; &nbsp; &nbsp; &nbsp; inc&nbsp; &nbsp;  edx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  bl, 8<br />@@2:<br />	shr&nbsp; &nbsp;  eax, 1<br />&nbsp; &nbsp; &nbsp; &nbsp; jnc&nbsp; &nbsp;  @@3<br />&nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp;  eax, 0EDB88320h<br />@@3:<br />	dec&nbsp; &nbsp;  bl<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz&nbsp; &nbsp;  @@2<br />&nbsp; &nbsp; &nbsp; &nbsp; loop&nbsp; &nbsp; @@1<br />&nbsp; &nbsp; &nbsp; &nbsp; not&nbsp; &nbsp;  eax<br />@@4:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />	ret<br /><br />z0mbie_Xcrc32 endp<br /><br />DlgProc proc uses edi hWin:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM<br />	<br />	.if uMsg==WM_COMMAND<br />		mov	eax,wParam<br />		mov	edx,wParam<br />		shr	edx,16<br />		.if	edx==BN_CLICKED<br />			.if	ax==IDC_BTNCLEAR<br />				invoke SendDlgItemMessage,hWin,IDC_EDTINPUT,WM_SETTEXT,0,NULL<br />				invoke SendDlgItemMessage,hWin,IDC_EDTCRC32,WM_SETTEXT,0,NULL<br />				invoke SendDlgItemMessage,hWin,IDC_EDTOUTPUT,WM_SETTEXT,0,NULL<br />			.elseif ax==IDC_BTNEXIT<br />				invoke SendMessage,hWin,WM_CLOSE,NULL,NULL<br />			.elseif ax==IDC_BTNRCRC<br />				invoke RtlZeroMemory,addr szOutput,sizeof szOutput<br />				mov	eax,Crc32Value<br />				;invoke z0mbie_Xcrc32,addr szOutput,Crc32len,eax<br />				invoke z0mbie_Rcrc32,addr szOutput,Crc32len,eax<br />				lea	edi,szOutput<br />				stosd<br />				invoke SendDlgItemMessage,hWin,IDC_EDTOUTPUT,WM_SETTEXT,0,addr szOutput<br />			.endif<br />		.elseif edx==EN_CHANGE<br />			.if	ax==IDC_EDTINPUT<br />				invoke RtlZeroMemory,addr szInput,sizeof szInput<br />				invoke RtlZeroMemory,addr szCRC32,sizeof szCRC32<br /><br />				invoke GetDlgItemText,hWin,IDC_EDTINPUT,addr szInput,8192<br />				invoke lstrlen,addr szInput<br />				mov	Crc32len,eax<br />				invoke z0mbie_Crc32,addr szInput,eax<br />				mov	Crc32Value,eax<br />				invoke wsprintf, ADDR szCRC32, CTXT(&#039;%X&#039;), eax<br />				invoke SendDlgItemMessage,hWin,IDC_EDTCRC32,WM_SETTEXT,0,ADDR szCRC32<br />			.endif<br />		.endif<br />	.elseif uMsg==WM_CLOSE<br />		invoke EndDialog,hWin,0<br />	.else&nbsp; <br />		mov eax,FALSE<br />		ret<br />	.endif <br /><br />	mov eax,TRUE<br />	ret<br />DlgProc endp<br /><br />start:<br />	invoke	GetModuleHandle,NULL<br />	mov	hInstance,EAX<br />	invoke	DialogBoxParam,hInstance,IDD_DLGNATIVECRY,NULL,ADDR DlgProc,NULL<br />	invoke	ExitProcess,0<br /><br />end start<br /></code></pre><br /><pre><code>#include &lt;\masm32\include\RESOURCE.H&gt;<br />#define IDD_DLGNATIVECRY 101<br />IDD_DLGNATIVECRY DIALOGEX 0,0,200,180<br />STYLE WS_CAPTION | WS_MINIMIZEBOX | WS_SYSMENU | WS_VISIBLE | DS_CENTER<br />CAPTION &quot;ReverseCRC32 tests &quot;<br />FONT 9,&quot;Tahoma&quot;<br />BEGIN<br />	LTEXT		&quot;Input:&quot;,1001,4,3,36,8,0<br />	EDITTEXT	1002,4,14,192,61,ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL | ES_AUTOHSCROLL | WS_CHILD | WS_VISIBLE | WS_BORDER | WS_HSCROLL | WS_VSCROLL<br />	LTEXT		&quot;Input CRC32:&quot;,1003,58,83,60,8,0<br />	EDITTEXT	1006,103,81,40,12,ES_AUTOHSCROLL | ES_READONLY<br />	LTEXT		&quot;Output:&quot;,1004,4,88,36,8,0<br />	EDITTEXT	1005,4,99,192,61,ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL | ES_AUTOHSCROLL | ES_READONLY | WS_CHILD | WS_VISIBLE | WS_BORDER | WS_HSCROLL | WS_VSCROLL<br />	PUSHBUTTON	&quot;&amp;Clear&quot;,1007,2,165,42,14,0<br />	PUSHBUTTON	&quot;&amp;Rcrc32&quot;,1008,45,165,42,14,0<br />	PUSHBUTTON	&quot;E&amp;xit&quot;,1009,155,165,42,14,0<br />END<br /></code></pre></div>
    <div class="meta">Posted on 2013-06-01 05:50:04 by dcskm4200</div>
   </div>
  </div>
 </body>
</html>