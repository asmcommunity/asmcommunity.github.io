<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Please BetaTest - VOIP Thingy - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=24667" />
  <link rel="prev" href="../?id=24667&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=24667">Please BetaTest - VOIP Thingy</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=24667&amp;page=1" style="">&laquo;</a><a href="../?id=24667&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="24667" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-180335">
    <div class="subject"><a href="#post-180335">Re: Please BetaTest - VOIP Thingy</a></div>
    <div class="body">Hi. Audio data is usually smaller after compression-&gt;deompression. The loss is unnoticable in most cases. The buffers should have their own notification positions.<br /><br />1) on playbuffer notify: receive, decompress and refill the buffer (actually some part of it)<br />2) on capturebuffer notify: compress the buffer (actually some part of it) and send<br /><br />playing should be stopped when there is no data<br />capturing should be stopped in case of silence (directsound has a &#39;microphone settings&#39; dialog for that).</div>
    <div class="meta">Posted on 2006-05-02 14:13:16 by ti_mo_n</div>
   </div>
   <div class="post" id="post-180354">
    <div class="subject"><a href="#post-180354">Re: Please BetaTest - VOIP Thingy</a></div>
    <div class="body">We&#39;ll see what happens.. I remain unconvinced of the benefits of setting up playbuffer notifications, especially since there is no correlation between the Time a packet is received and the Time it should play, and particularly so if there is more than one source of data.. think about it, two users begin sending you data, if we blindly assume that packets should slot into the playbuffer in the order received AND at the time received...<br /><br />If I&#39;m not satisfied with the output&nbsp; of the decompressor, I have a &#39;fix&#39; in mind.<br />Right now I am marking the sent udp packets with their recording offset and their compressed size.. if I also mark them with the uncompressed size, then it becomes possible to &#39;stretch&#39; the decompressed wave data to its original size by inserting a few values interpolated from the existing values.. since the decompressed data never exceeds a couple of kilobytes, it should be possible to make this correction without causing any further artifacts.. hopefully, like you say, that won&#39;t be necessary, we&#39;ll see.<br /><br /><br /></div>
    <div class="meta">Posted on 2006-05-03 02:17:29 by Homer</div>
   </div>
   <div class="post" id="post-180359">
    <div class="subject"><a href="#post-180359">Re: Please BetaTest - VOIP Thingy</a></div>
    <div class="body">Use DSBCAPS_GETCURRENTPOSITION2, have your soundbuffers in software, lock them only once ever (and keep the pointer in a global var). <br /><br />Preferrably, use only GSM compression 160 samples-&gt;33 bytes. Every Win32 PC has it by default. Set only the samplerate, for quality/size adjustment. <br /><br /><br /><br />Maybe you should take a look at my EasySound implementation (though it&#39;s for output only, for now)</div>
    <div class="meta">Posted on 2006-05-03 09:03:52 by Ultrano</div>
   </div>
   <div class="post" id="post-180362">
    <div class="subject"><a href="#post-180362">Re: Please BetaTest - VOIP Thingy</a></div>
    <div class="body">Ultrano, I&#39;m just screwing around with stuff I haven&#39;t yet had the chance to, and trying to put it to some reasonable purpose, for no good reason except that I can.<br /><br />Why do you suggest I use GSM over other codecs?<br />Is there a technical reason for your proposed sample size?<br /><br />Like I said, I&#39;m just screwing around, I really have no idea what I&#39;m trying to achieve here.<br />I&#39;m interested right now in mixing multiple incoming streams, which is why I lean towards sending the &#39;raw recording offset&#39; of each sent chunk of compressed audio.. it lends itself towards software mixing, but I have no idea about hardware mixing atm except that &#39;I can have as many secondary buffers as I like&quot; - which seems weird.<br /><br /></div>
    <div class="meta">Posted on 2006-05-03 11:16:15 by Homer</div>
   </div>
   <div class="post" id="post-180363">
    <div class="subject"><a href="#post-180363">Re: Please BetaTest - VOIP Thingy</a></div>
    <div class="body">A GSM frame is always 160 samples (320 bytes) in PCM, and 33 bytes compressed. Thus, mixing out-of-order decompressed data is straightforward. The GSM codec doesn&#39;t take samplerate in account internally, when compressing and decompressing. <br /><br /><br />afaik, in the sndcard market, there are only 3 affordable models of audiocards that support at least one DirectSound secondary buffer in hardware (and thus have hardware mixing): Yamaha YMF724 , Creative Live (not sure much) and Creative Audigy1/2. Thus secondary buffers are usually done in software, in the form of:<br /><pre><code><br />SecBuffer struct ; (simplified version)<br />	IsPlaying	db ?<br />	BytesRemaining	db ?<br />	BytesTotal	db ?<br />	format	WAVEFORMATEX &lt;&gt;<br />	<br />	; and the wavedata<br />	WaveData	db BytesTotal dup (?)<br />SecBuffer ends<br /></code></pre><br /><br />I&#39;ve never got into DSound as deep as driver-level, so from my experience and knowledge I can just share my assumptions, for now ^^&#39; :<br /><br />Let&#39;s assume our cheapo card has a 100ms buffer in 44100Hz stereo 16-bit. (17640 bytes). Every 50ms the soundcard will be interrupting the cpu, if it&#39;s playing (otherwise they&#39;re just idling, and some cards are damn noisy while doing that). So, on this interrupt, DirectSound will render all of its active SecBuffers (pointers to them are placed in a vector-array) . Rendering of a SecBuffer can include decompression, pitching, panning/volume, resampling (to match the primary buffer samplerate), and adding effects (DSound8). <br />Current PC games don&#39;t do any mixing themselves for sfx - they decode+dump their sfx once at level-load into SecBuffer/3D,&nbsp;  and occassionally play some of them (DSound/3D adds them to the vector-array of currently-playing-sounds when the game executes lpDSBsoundYikes-&gt;Play() ). During/after rendering, buffers that have finished playing completely, get kicked out of the vector-array of currently-playing-sounds ^^ .<br />Then, finally, DSound sends this rendered buffer to the soundcard. If it&#39;s a bit late, we hear rave-music ^^. <br /><br /><br />Win2k &amp; XP add an extra 20ms buffer, handled by the WDM drivers, to enable simultaneous work of apps, that use DSound with apps that use WinMM. Win98/ME and previous Win OS could not do that with cheapo cards - there if you had some longer system sound (a&#39;la recycle-bin-emptying), you could not start any DSound app at the same time and vice-versa. But you get worse latency ^^&#39;<br /><br /><br />Sound capture, on the other hand, is always with exclusive access, iirc. <br /><br /><br />The &#39;raw recording offset&#39; will always have to be adjusted (add eax,inputadjust) when received, and then clipped (and eax,OutputBufSize-1). Then mix + clip (by sample volume) on the output buffer, then &quot;inc eax&quot;, &quot;and eax,OutputBufSize-1&quot;, &lt;- repeated for the number of PCM samples received (and decoded). <br />This way, you can mix-in as many sources you want (each of them having their own &quot;inputadjust dd ?&quot; ). As long as just after sending some samples to the soundcard, you clear their values (&quot;invoke memcpy,pSndcardBuf,myMixBuf,numBytes&quot; + &quot;invoke memset,myMixBuf,0,numBytes&quot;) <br /><br /></div>
    <div class="meta">Posted on 2006-05-03 12:45:19 by Ultrano</div>
   </div>
   <div class="post" id="post-180365">
    <div class="subject"><a href="#post-180365">Re: Please BetaTest - VOIP Thingy</a></div>
    <div class="body">Attached is a clean example of how to capture sound with no da*n notifications and obfuscations. Though, still in cpp. Will convert it later to pure asm, with the audio polling moved to another thread in the process (as it should be). <br /><br />Those notifications&#39; examples... the MSDN team tend to make horror+gore stories, instead of reusable examples... hmm maybe they&#39;re being nice, since the &quot;reusable&quot; word could make some people shudder, thinking about licenses ^^. Oh well, anyway, an EasySoundCapture library is coming up next, usable in cooperation with EasySound(output),&nbsp; so stay tuned :). </div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1606" target="_blank">DSoundCapture.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-05-03 14:16:53 by Ultrano</div>
   </div>
   <div class="post" id="post-180366">
    <div class="subject"><a href="#post-180366">Re: Please BetaTest - VOIP Thingy</a></div>
    <div class="body"><br />Yeah, the notifications are only waking a thread that services the capture-send/receive-play code.. your demo version is nice and simple indeed :P<br />I guess I could drive my code in a loop like that and get rid of the notifications too, but I&#39;d still want to have it running in a separate thread.<br />I have a thread with a loop that is calling WaitForMultipleObjects on 16 event handles, with the capturebuffer&#39;s hardware cursor triggering my event handles.. I know it&#39;s overkill.<br /><br />Well anyway, I&#39;ve got everything working in loopback mode using TrueSpeech now, but I have one final problem (that I kinda expected and mentioned previously) that I am getting &quot;sandwich packets&quot; and not dealing with them correctly.<br />I guess if I was using GSM codec this problem would be easier to deal with because the payload size would always be known, but the problem would certainly still exist.<br />I can &quot;walk&quot; the received subpackets in a &quot;sandwich packet&quot; because I added a 6-byte header containing the payload size (among other things)..<br /><br />Tomorrow I&#39;ll implement code to handle &quot;sandwich packets&quot; and then I&#39;ll post the source as it stands, and then I&#39;ll add support for GSM as a bonus, so you can choose your own poison :)<br /><br /></div>
    <div class="meta">Posted on 2006-05-03 15:11:49 by Homer</div>
   </div>
   <div class="post" id="post-180369">
    <div class="subject"><a href="#post-180369">Re: Please BetaTest - VOIP Thingy</a></div>
    <div class="body">Here&#39;re the EasySound + EasySoundCapture libs + src + examples. Running in separate threads, of course :)<br /><br />Though, you&#39;ll need to add an extra proc in EasySound to write out-of-order data in the output buffer ^^&quot; . Right now I can&#39;t remember exactly how to do it ^^&#39; . <br /><br />The ESCapture needs no modification for your app, I think. I added floating-point support, since you&#39;d best put an audio compressor (emulation of an analog circuit) - to auto-adjust microphone gain. Well, and since I need the audio data in FP for my stuff ^^<br /><br />I haven&#39;t tested ES + ESCap in co-op yet, neither have I fully tested ESCap on its own, sandman&#39;s calling ...</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1607" target="_blank">EasySound.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-05-03 17:29:39 by Ultrano</div>
   </div>
   <div class="post" id="post-180391">
    <div class="subject"><a href="#post-180391">Re: Please BetaTest - VOIP Thingy</a></div>
    <div class="body">OK, updated the zip one last time.<br />This version represents what SHOULD be the complete, working &#39;debug build&#39; of the demo.<br />I &quot;should&quot; be able to set the host to localhost and hear myself speaking.<br />However, I just jumped on my other machine that happens to have a microphone headset and tried it, and I hear machinegun junk :(<br /><br />How it works: sent packets of compressed audio are marked with their payload size (ie the size of the compressed data), the original uncompressed size, and the offset at which they were recorded in the one second capture buffer... received packets are decompressed and written to the playback buffer at the offset they were originally recorded at, so all things being equal, we should hear a small delay in the playback when we perform the loopback test, which is the difference between the current hardware playbuffer cursor position and the offset that the data was recorded at/written to.<br /><br />I know I don&#39;t have to send the original uncompressed size in my packets, I do so only because it is interesting to compare it with the decompressed size, once we&#39;ve received and decompressed the data..<br /><br />The capturebuffer is currently not &quot;started and stopped&quot;, but the playback buffer is.. when packets start arriving we start playing, and when we run out of data we stop playing.. really we should make sure the harware playbuffer cursor has moved beyond the end of the last data we wrote to the playbuffer before we stop, but anyway, that has nothing to do with the fact that my application sucks.<br /><br /><br /></div>
    <div class="meta">Posted on 2006-05-04 20:49:00 by Homer</div>
   </div>
   <div class="post" id="post-180397">
    <div class="subject"><a href="#post-180397">Re: Please BetaTest - VOIP Thingy</a></div>
    <div class="body">You just forgot to adjust the offset of writing to the output, I think. I&#39;d first try to make it with compression disabled</div>
    <div class="meta">Posted on 2006-05-04 23:03:09 by Ultrano</div>
   </div>
   <div class="post" id="post-180412">
    <div class="subject"><a href="#post-180412">Re: Please BetaTest - VOIP Thingy</a></div>
    <div class="body"><br />Yeah I don&#39;t adjust the playback offset.. should I be? I guess I didn&#39;t think that hard about what happens on the playback side.<br />Let&#39;s see.. recording begins at some arbitrary offset X .. I don&#39;t start playback until packets are received, so I have a chance to set the play cursor, which I don&#39;t do... packets received are fed into playbuffer beginning at offset X.... ah !! What if I just set the play cursor to offset X after I have written my first data and before I start playing? Does this have the same effect as adjusting the playback offset to suit the cursor? On the other hand, why should it matter what offset? Like, if I write to the playbuffer at an offset that is &quot;one half of the buffer away from the play cursor at the time of writing&quot;, and the playbuffer is one second long, shouldn&#39;t it play a half second of junk, then start playing my audio?<br /><br /></div>
    <div class="meta">Posted on 2006-05-05 06:02:56 by Homer</div>
   </div>
   <div class="post" id="post-180413">
    <div class="subject"><a href="#post-180413">Re: Please BetaTest - VOIP Thingy</a></div>
    <div class="body">To determine the InputOffset:<br /><br />Run our input and output soundbuffers never with pause here. <br />Let&#39;s be having just 1:1 conversation: between John and Sally. We&#39;ll only look at Sally sending audio to John. <br />And let&#39;s assume our (John&#39;s) output buffer is 262144 samples long (2^18). <br /><br /><br />We&#39;re now looking at John&#39;s side only. <br /><br /><br />We receive the first <strong>audio</strong> packet from Sally, with the following data:<br />SallysOffset = 1245255 ; total number of samples captured from Sally&#39;s sndcard since the proggie started capturing (never stops capturing)<br />VoiceSize = 700 ; length of current chunk, in number of samples (in PCM form, decompressed)<br />VoiceCompressedSize = 90 ; in bytes; doesn&#39;t matter to us now.<br />compressedData&#91;]<br /><br /><br />we decompress the audio chunk, to get a<br /><br />pcmDecompressedData&#91;]<br /><br /><br />So, now, and only now, John&#39;s receiving proggie computes a variable, called:<br />ReceivedAudioOffsetAdjuster dd 0 ; <br /><br />We get John&#39;s the output buffer&#39;s position. Let&#39;s say it&#39;s 55542. This is the position, up to which we can safely put some audio data (in the output buffer). <br /><pre><code><br />;-------[ this is computed only once, on receiving the first packet ]-- -------[<br />mov eax,OutBufPosition ; this has the 55542 value<br />add eax,22050 ; Let&#39;s set 0.5 second of latency (if we&#39;re @ 44100Hz samplerate)<br />sub eax,SallysOffset<br />mov ReceivedAudioOffsetAdjuster,eax<br />;------------------------------------------------------------------------------------------/<br /></code></pre><br /><br /><br />Right after that, <strong>and</strong> on each new received audio packet, we do this:<br /><pre><code><br />mov eax,SallysOffset<br />add eax,ReceivedAudioOffsetAdjuster<br />and eax,(1 SHL 18) - 1<br />; now EAX has the index of the SndOutBuffer, from which we must start<br />; writing samples to the soundcard.<br />; Don&#39;t forget to wrap-around on each new written sample<br /><br />;-------[ write to output buffer ]--------[<br />mov esi,pcmDecompressedData<br />mov edi,SndOutBuffer<br />xor ecx,ecx<br />.while ecx&lt;VoiceSize<br />&nbsp; &nbsp; mov dx,<br />&nbsp; &nbsp; mov ,dx<br /><br />&nbsp; &nbsp; and eax,(1 SHL 18) - 1 ; wrap-around<br />&nbsp; &nbsp; inc ecx<br />.endw<br /><br />; all done !<br />;----------------------------------------------/<br /></code></pre><br /></div>
    <div class="meta">Posted on 2006-05-05 07:10:34 by Ultrano</div>
   </div>
   <div class="post" id="post-180414">
    <div class="subject"><a href="#post-180414">Re: Please BetaTest - VOIP Thingy</a></div>
    <div class="body"><div class="quote"><br /> On the other hand, why should it matter what offset? Like, if I write to the playbuffer at an offset that is &quot;one half of the buffer away from the play cursor at the time of writing&quot;, and the playbuffer is one second long, shouldn&#39;t it play a half second of junk, then start playing my audio?<br /></div><br />If you remove the &quot;ReceivedAudioOffsetAdjuster&quot; and the packet&#39;s &quot;SallysOffset&quot;, and always write half a second forward, things will work right only if you receive (+ process) packets absolutely at the perfect time (+/-10microsecs), and always in perfect order with UDP. Which is impossible outside of lab conditions. </div>
    <div class="meta">Posted on 2006-05-05 07:35:37 by Ultrano</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=24667&amp;page=1" style="">&laquo;</a><a href="../?id=24667&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="24667" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>