<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>MOV question... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=12979" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=12979">MOV question...</a></p>
   <div class="post" id="post-100869">
    <div class="subject"><a href="#post-100869">MOV question...</a></div>
    <div class="body">I'm trying to assign the results of a simple calculation (r*r+d) (which results in a number) into the integer &quot;s&quot; like so:<br /><br />mov(r*r+d,s);<br /><br />But it results in the following compiler error:<br /><br />Error in file &quot;west.hla&quot; at line 1077 :<br />Expected ',', encountered '*'.<br />Near: &lt;&lt; * &gt;&gt;<br /><br /><br />D:\MASM&gt;<br /><br />What do I need to use for the syntax to be correct?<br /><br />P.S. Found a solution to the multi-dimensional problem. r*r+d results in a unique number each time from  (that is, I'm multiplying row*row+column to synthesize a multi-dimensional array. This creates a larger single-dimension array, but it works).<br /><br />Example:<br /><br />m[15,2] becomes [15*15+2] which is 227. m[227] is then set to 19, corresponding to the room #19.<br /><br />Regards,<br /><br />Paul Panks<br /><a href="mailto:dunric@yahoo.com">dunric@yahoo.com</a></div>
    <div class="meta">Posted on 2003-05-02 23:40:32 by Paul Panks</div>
   </div>
   <div class="post" id="post-100931">
    <div class="subject"><a href="#post-100931">Re: MOV question...</a></div>
    <div class="body"><div class="quote"><br />I'm trying to assign the results of a simple calculation (r*r+d) (which results in a number) into the integer &quot;s&quot; like so:<br /><br />mov(r*r+d,s);<br /><br />But it results in the following compiler error:<br /><br />Error in file &quot;west.hla&quot; at line 1077 :<br />Expected ',', encountered '*'.<br />Near: &lt;&lt; * &gt;&gt;<br /><br /><br />D:\MASM&gt;<br /><br />What do I need to use for the syntax to be correct?<br /><br />P.S. Found a solution to the multi-dimensional problem. r*r+d results in a unique number each time from  (that is, I'm multiplying row*row+column to synthesize a multi-dimensional array. This creates a larger single-dimension array, but it works).<br /><br />Example:<br /><br />m[15,2] becomes [15*15+2] which is 227. m[227] is then set to 19, corresponding to the room #19.<br /><br />Regards,<br /><br />Paul Panks<br /><a href="mailto:dunric@yahoo.com">dunric@yahoo.com</a> </div><br /><br />re:<br />mov(r*r+d,s);<br /><br />You're confusing *compile-time* calculations with *run-time* calculations<br />(a common mistake among people learning assembly language, btw).<br /><br />The computations like you've listed in the MOV instruction above<br />may only involve constants (or VAL objects) whose value is known at<br />the point of this instruction, e.g.,<br /><br />const<br />    r :int32 := 15;<br />    d:int32 := 4;<br />       .<br />       .<br />       .<br />mov( r*r+d, s );<br /><br />Note that this MOV instruction is completely equivalent to<br /><br />mov( 229, s );<br /><br />HOWEVER, if r and (/or) d are memory variables, this statement<br />is not legal (for a couple of reasons).  First of all, memory to memory<br />moves are illegal (I'm assuming s is a variable).  Second, calculations<br />like this are not permissible as operands.  What you need to do is<br />calculate the expression into a register and then store that register<br />into S, e.g.,<br /><br />mov( r, eax );<br />intmul( r, eax );<br />add( d, eax );<br />mov( eax, s );<br /><br />Yep, that's a pain.  Welcome to assembly language!<br /><br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-05-03 09:28:47 by rhyde</div>
   </div>
   <div class="post" id="post-101025">
    <div class="subject"><a href="#post-101025">MOV question...</a></div>
    <div class="body">Using your calculation r*r+c, both row 1 column 4, and row 2 column 1 give 5.<br /><br />row 2, column 6 and row 3 column 1 both give 10.<br /><br />I believe you should use r*n+c, where n is the total number of rows.</div>
    <div class="meta">Posted on 2003-05-04 00:46:18 by V Coder</div>
   </div>
   <div class="post" id="post-101720">
    <div class="subject"><a href="#post-101720">test.hla</a></div>
    <div class="body">Well, I looked at the source code.<br />Here are a couple of comments.<br /><br />Problem #1, as I suspected, is the fact that you're indexing into a dword array<br />using a byte indexing scheme.  You must multiply your index by the array element<br />size (in bytes, four in this case) before accessing the element.  Otherwise you<br />get total garbage.  There are probably some other problems in there as well,<br />but this is the #1 problem.  The size of your m array needs to be better than<br />1681 (41*41) if you're really going to index it using the room number squared.<br /><br />At the beginning of your code, you do this to initialize m:<br /><br />// Start up...<br /><br />// room 1<br />mov(5,m[3]);<br />mov(2,m[6]);<br /><br />// room 2<br />mov(4,m[7]);<br />mov(1,m[10]);<br /><br />// room 3<br />mov(5,m[13]);<br />   .<br />   .<br />   .<br /><br />If you were to use a true two-dimensional array (rather than<br />a sparse array as you are using), you could initialize this<br />static array at load time rather than at run time by assigning<br />an array constant to m, e.g.,<br /><br />static<br />    m:int32 := [ 1, 5, 2, 4, ...];<br /><br />This would shave a ton of instructions off the front of your code.<br /><br />Rather than using straight-line code to print the room descriptions,<br />I'd use a data structure like this:<br /><br /><pre><code> <br />type<br />    RoomText&#58;record<br />        RoomName&#58;string;<br />        RoomDesc&#58;string;<br />        RoomExits&#58;string;<br />    endrecord;<br /><br /><br />static<br />    RoomInfo&#58; RoomText&#91;42&#93; &#58;=<br />    &#91;<br />         RoomText&#58;&#91; &quot;&quot;,&quot;&quot;,&quot;&quot;&#93;, //No room 0?<br />         RoomText&#58;<br />               &#91; <br />                     &quot;Village tavern&quot;,<br /><br />                     &quot;You are standing in a tavern with creaky wooden floors. Laughter and&quot; nl<br />                     &quot;commotion surround you as the bartender tends to his customers. A few&quot; nl<br />                     &quot;tables and chairs are visible here. A staircase heads upstairs to the&quot; nl<br />                     &quot;second floor of the tavern.&quot; nl,<br /><br />                     &quot;&lt;south, up&gt;&quot;<br />                &#93;,<br />        &lt;&lt;40 more RoomText declarations&gt;&gt;<br />    &#93;;<br /><br /></code></pre> <br /><br />Now your code to emit the room description becomes just the following:<br /><br />intmul( @size( RoomText ), r, esi );<br />console.setOutputAttr( win.fgnd_LightCyan | win.bgnd_Black );<br />stdout.put( (type string RoomInfo.RoomName), nl );<br />console.setOutputAttr( win.fgnd_LightGray | win.bgnd_Black );<br />stdout.put( (type string RoomInfo.RoomDesc), nl );<br />console.setOutputAttr( win.fgnd_White | win.bgnd_Black );<br />stdout.put( &quot;Exits: &quot; );<br />console.setOutputAttr( win.fgnd_Yellow | win.bgnd_Black );<br />stdout.put( (type string RoomInfo.RoomExits), nl );<br /><br />This short sequence replaces those 42 if statements (if(r=1) then.... if(r=2) then..., etc)<br />in your existing code.  Note that the intmul instruction multiplies the index (r) by<br />the size of an array element (@size(RoomText)).  This is the trick that you were<br />missing in your earlier code.<br /><br />As for the parse routine, if your adventure game follows the traditional<br />&lt;verb&gt;&lt;noun&gt; command structure, I'd recommend converting the first<br />word to a number in the range 0..#verbs and the second word on the line<br />to a number in the range 0..#nouns (with zero representing an unknown<br />noun or verb) and then use these two values as an index into a two dimensional<br />array of procedure pointers and call the procedure responsible for that combination.<br /><br />E.g., assume we have:<br /><br />verbs: go, get, put<br /><br />nouns: north, east, shield<br /><br />You would create a 4x4 array of procedure pointers as follows:<br /><br /><pre><code> <br />type<br />   procPtr&#58; procedure;<br /><br />static<br />    procPtrs&#58; procPtr&#91;4,8&#93; &#58;=<br />           &#91;<br />               &amp;invalid, &amp;invalid, &amp;invalid, &amp;invalid,  // index zero is always an invalid command<br />               <br />               //           go north   go east    go shield<br /><br />               &amp;invalid, &amp;gonorth, &amp;goeast, &amp;invalid,<br /><br />               //           get north get east get shield<br /><br />               &amp;invalid, &amp;invalid, &amp;invalid, &amp;getshield,<br /><br />              //             put north put east put shield<br />               &amp;invalid, &amp;invalid, &amp;invalid, &amp;putsheild<br />           &#93;;<br /></code></pre> <br /><br /><br />Assuming you can turn the nouns and verbs into the values 0..3 and 0..2 respectively,<br />(and leave the values in noun and verb), you can call the procedure than handles<br />the command thusly:<br /><br /><br /><pre><code> <br />      intmul&#40; 8, verb, edx &#41;; // could also shl verb by three and use that value.<br />      add&#40; noun, edx &#41;;<br />      call&#40; procPtrs&#91; edx*4&#93; &#41;; // Calls one of the functions invalid, gonorth, goeast,<br />                                            // getshield, or putshield depending upon the values<br />                                            // of noun and verb.<br /></code></pre> <br /><br />Then you'd just have to supply one procedure for each legal command.<br /><br />I think you'll agree that this scheme will produce far less code than the string<br />of if statements you're currently using.<br /><br />This project, btw, *begs* to be written in an object-oriented fashion using<br />classes in HLA.  However, I'm assuming you've probably not done much object-oriented<br />programming in the past, so you'll probably find the schemes I've suggested thus far<br />to be a bit more convenient.<br /><br />BTW, another good approach is to use the HLA pattern matching library to parse<br />the user commands, e.g.,<br /><br /><br /><pre><code> <br />str.lower&#40; input_line_from_user &#41;;<br />pat.match&#40; input_line_from_user &#41;;<br /><br />    pat.zeroOrMoreWS&#40;&#41;;<br />    pat.matchStr&#40; &quot;go&quot; &#41;;<br />    pat.zeroOrMoreWS&#40;&#41;;<br />    pat.matchStr&#40; &quot;north&quot; &#41;;<br /><br />    GoNorth&#40;&#41;;<br /><br />  pat.alternate;<br /><br />    pat.zeroOrMoreWS&#40;&#41;;<br />    pat.matchStr&#40; &quot;go&quot; &#41;;<br />    pat.zeroOrMoreWS&#40;&#41;;<br />    pat.matchStr&#40; &quot;east&quot; &#41;;<br /><br />    GoEast&#40;&#41;;<br /><br />  pat.alternate;<br /><br />    pat.zeroOrMoreWS&#40;&#41;;<br />    pat.matchStr&#40; &quot;get&quot; &#41;;<br />    pat.zeroOrMoreWS&#40;&#41;;<br />    pat.matchStr&#40; &quot;shield&quot; &#41;;<br /><br />    GetShield&#40;&#41;;<br /><br />  pat.alternate;<br /><br />    pat.zeroOrMoreWS&#40;&#41;;<br />    pat.matchStr&#40; &quot;put&quot; &#41;;<br />    pat.zeroOrMoreWS&#40;&#41;;<br />    pat.matchStr&#40; &quot;shield&quot; &#41;;<br /><br />    PutShield&#40;&#41;;<br /><br />  pat.if_failure;<br /><br />    stdout.put&#40; &quot;Illegal command&quot; nl &#41;;<br /><br />pat.endmatch;<br /></code></pre> <br /><br />The pattern matching code is really easy to understand and modify<br />(unlike the array stuff I've suggested, which is a bit more painful to<br />create and modify) at the expense of longer code.<br /><br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-05-06 23:26:55 by rhyde</div>
   </div>
  </div>
 </body>
</html>