<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Diagonal of Pascal triangle table - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=18791" />
  <link rel="prev" href="../?id=18791&amp;page=1" />  <link rel="next" href="../?id=18791&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=18791">Diagonal of Pascal triangle table</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=18791&amp;page=1" style="">&laquo;</a><a href="../?id=18791&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="18791" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=18791&amp;page=3">&gt;</a><a href="../?id=18791&amp;page=3">&raquo;</a></form>   <div class="post" id="post-145539">
    <div class="subject"><a href="#post-145539">Diagonal of Pascal triangle table</a></div>
    <div class="body">Ehh, it's wellknown fact that P4 doesn't like inc,dec <br />But in this case I don't care.<br />You see the algo itself is already fast enough, so I'd like to see speed optimizing in the case only if it doesn't make opcode longer.<br />You can, for instence, just put ALIGN 16 at loops start and it itself would make the code faster.<br />If you'll make it 50% slower (not of cause 200 times slower :)) yet 50% shorter - this would be better.<br />As I said before - it's compromize between size and speed.<br />BlackMirror version ~ 10-15% slower than mine, yet it's almost twice shorter. I took it as a great improvemet.<br />It uses the same general algo, but better desinged and with shorter instruction.<br />You see it's one of kinda &quot;tables filling procs&quot; that used in apps that havilly used &quot;table lookups&quot; approches.<br />In some those apps the tables just included directly in binaries, in others for size sake they are replaced by &quot;table filling procs&quot;. Those procs works just at start of apps (there might be a hundred of such procs) and if they themself are big ones, thogh fast - it make no sence to use them at all - since the fastest way to fill table - just include it in bin file :)<br />Of cause they shouldn't be too slow, but without changing the algo itself - it's just impossible to make the proc slow, 2000 ticks of 3000 ticks - it doesn't matter here, just don't make it 2000000 ticks :)<br />For example your changing rep stosd for 3 movs OUTSIDE loop!! - absolute nonsence, <br />what did you it for - paying a byte for 1 clock?<br /><br />Again - speed improvements are wellcome, but only if they don't increase size.</div>
    <div class="meta">Posted on 2004-07-07 03:04:52 by The Svin</div>
   </div>
   <div class="post" id="post-145553">
    <div class="subject"><a href="#post-145553">Diagonal of Pascal triangle table</a></div>
    <div class="body"><div class="quote"><br />Ehh, it's wellknown fact that P4 doesn't like inc,dec <br />But in this case I don't care.<br />You see the algo itself is already fast enough, so I'd like to see speed optimizing in the case only if it doesn't make opcode longer.<br />You can, for instence, just put ALIGN 16 at loops start and it itself would make the code faster.<br />If you'll make it 50% slower (not of cause 200 times slower :)) yet 50% shorter - this would be better.<br />As I said before - it's compromize between size and speed.<br />BlackMirror version ~ 10-15% slower than mine, yet it's almost twice shorter. I took it as a great improvemet.<br />It uses the same general algo, but better desinged and with shorter instruction.<br />You see it's one of kinda &quot;tables filling procs&quot; that used in apps that havilly used &quot;table lookups&quot; approches.<br />In some those apps the tables just included directly in binaries, in others for size sake they are replaced by &quot;table filling procs&quot;. Those procs works just at start of apps (there might be a hundred of such procs) and if they themself are big ones, thogh fast - it make no sence to use them at all - since the fastest way to fill table - just include it in bin file :)<br />Of cause they shouldn't be too slow, but without changing the algo itself - it's just impossible to make the proc slow, 2000 ticks of 3000 ticks - it doesn't matter here, just don't make it 2000000 ticks :)<br />For example your changing rep stosd for 3 movs OUTSIDE loop!! - absolute nonsence, <br />what did you it for - paying a byte for 1 clock?<br /><br />Again - speed improvements are wellcome, but only if they don't increase size. </div><br /><br />  I completely disagree.  To me optimization is all about the speed.  If you have run your C code on a profiler, and you found such and such routine runs slow, then I want to make it run as fast as possible to make the overall app run faster.  Now you might avoid using lookup tables in your optimization if your app churns through a lot of data  Trading a rep stosd for 3 MOVes is a much better solution.  Adding a few bytes doesn't really effect the over all app that much and it does make it run faster.  I have developed large apps competely in assembler for my job ( I write BIOS), and I write asembler code daily for BIOS.</div>
    <div class="meta">Posted on 2004-07-07 07:48:25 by mark_larson</div>
   </div>
   <div class="post" id="post-145555">
    <div class="subject"><a href="#post-145555">Diagonal of Pascal triangle table</a></div>
    <div class="body"><div class="quote"><br />bitRake, have you posted something here or it's just something wrong with my email borad notification? </div>I reply XADD. ;)<br /><br />I totally agree with the middle way - fast but small.  It is not an easy way to code, but it would be no fun if it was.  The idea that resources are not limited is absurd.  All resources are limited and in general we should code accordingly.<br /><br />IMHO, of course.</div>
    <div class="meta">Posted on 2004-07-07 08:16:47 by bitRAKE</div>
   </div>
   <div class="post" id="post-145560">
    <div class="subject"><a href="#post-145560">Diagonal of Pascal triangle table</a></div>
    <div class="body"><div class="quote"><br />I reply XADD. ;)<br /><br />I totally agree with the middle way - fast but small.  It is not an easy way to code, but it would be no fun if it was.  The idea that resources are not limited is absurd.  All resources are limited and in general we should code accordingly.<br /><br />IMHO, of course. </div><br /><br />  I didn't say resources were unlimited ( look at the comment about not using look up tables if you churn through a lot of memory), however saving 4 or 5 bytes in the code by using rep stosd when it is slower to me isn't a good reason.  Now saving a 64MB lookup table because the user doesn't have that much memory, or you go through a lot of data is different.<br /><br />EDIT:  Let me clarify that some more<br /><br />1)  to me adding a 4 or 5 bytes to a routine to make it faster is definitely ok and worth it.  <br />2)  I don't think you should program like you have unlimited resources.  Definitely not.  I actually talked about this on masmforum.  I wrote a tutorial on optimizing a ascii to radix40 routine.  In the end I had it running at 300 cycles on a P4.  However I showed an alternate version as a joke, that used a 64MB lookup table that ran in 16 cycles.  I joked that who in their right mind would use a 64MB lookup table to convert ascii to radix40?  It's a balancing act.  You have to look at how much resources you have, and program for that.  A few bytes isn't going to make a difference.  I actually keep 2 copies of all my routines that have lookup tables.  A have a second copy that does the same thing but without a lookup table.  Lookup tables usually end up running faster but have a few problems.  One of which is resources and the other is if you go through a lot of data in your app you are going to get a lot of cache misses if you have a lot of lookup tables.  As a side note I also keep multiple copies of routines that use SSE2.  I usually try and have an SSE or MMX version as well.  For instance I have a random number routine that uses SSE2 that generates a random number every 12 cycles on a P4.  It actually does it in 4, but the other 8 cycles are used to scale it to a base.  If you only need a 32-bit number then it runs in 4 cycles.  You can't run it on systems without SSE2 support, so I have a similar MMX one that runs in 24 cycles.</div>
    <div class="meta">Posted on 2004-07-07 09:40:37 by mark_larson</div>
   </div>
   <div class="post" id="post-145578">
    <div class="subject"><a href="#post-145578">Diagonal of Pascal triangle table</a></div>
    <div class="body"><strong>mark_larson</strong><br />Nothing personal, but those talks a la &quot;how proffecional asm programmer should code&quot; would lead to nothing, but flames here.<br />To me as a former proffecional low-level coder, most of your statements look very strange as said from another &quot;professional&quot; in the field, but I kept the notions for myself and kept quiet since it nothing to do with the topic.<br />As to something related to topic, let's say some facts to make picture clear. Your statements about 64 mb look up tables don't feat here:<br />1. Max table size possible to fill with the proc is 33 diag.<br />So it's 1+2+3..+33=33*34/2=561 bytes<br />So it's not so big look up table, and making very big proc to fill it could eliminate sence of such a proc comparing with alternatives to the table as binary data.<br />2. In other hand the having the table itself as alternative to calculating very havily used in many fields formulea<br />n!/((n-x)!x!) for x element in n raw makes a lot of sence in particular if code are going to call the calculation frequently.<br />It's nothing to do with your unfortunate example about radix 40 convertion, it's times exponantionally harder to calculate. Nevertheless I gave another proc that calulate it (x element in n raw) without table and your are wellcome to optimize or offer even another algorithm to calc it.<br /><br />To All: I firstly thought that it would be interesting for those of us who &quot;math inclined&quot; :)<br />I new there are lot of math smarty ones who could improve my x in n proc (wich actually calcs x!/((x-n)!n!), and we all could have a fun :))</div>
    <div class="meta">Posted on 2004-07-07 14:14:31 by The Svin</div>
   </div>
   <div class="post" id="post-145587">
    <div class="subject"><a href="#post-145587">Diagonal of Pascal triangle table</a></div>
    <div class="body"><div class="quote"><br /><strong>mark_larson</strong><br />Nothing personal, but those talks a la &quot;how proffecional asm programmer should code&quot; would lead to nothing, but flames here.<br />To me as a former proffecional low-level coder, most of your statements look very strange as said from another &quot;professional&quot; in the field, but I kept the notions for myself and kept quiet since it nothing to do with the topic.<br />As to something related to topic, let's say some facts to make picture clear. Your statements about 64 mb look up tables don't feat here:<br />1. Max table size possible to fill with the proc is 33 diag.<br />So it's 1+2+3..+33=33*34/2=561 bytes<br />So it's not so big look up table, and making very big proc to fill it could eliminate sence of such a proc comparing with alternatives to the table as binary data.<br /></div><br /><br />  You misuderstood.  I have no problems with your table size.  It is not too big.  I was using the 64MB as an example of a lookup table that is too big.<br /><br /><br /><div class="quote"><em>Originally posted by The Svin </em>In other hand the having the table itself as alternative to calculating very havily used in many fields formulea<br />n!/((n-x)!x!) for x element in n raw makes a lot of sence in particular if code are going to call the calculation frequently.<br />It's nothing to do with your unfortunate example about radix 40 convertion, it's times exponantionally harder to calculate. Nevertheless I gave another proc that calulate it (x element in n raw) without table and your are wellcome to optimize or offer even another algorithm to calc it.<br /><br />To All: I firstly thought that it would be interesting for those of us who &quot;math inclined&quot; :)<br />I new there are lot of math smarty ones who could improve my x in n proc (wich actually calcs x!/((x-n)!n!), and we all could have a fun :)) </div><br /><br />That's what I was saying about doing 2 versions.  Having one that does a table lookup and one that doesn't.  That way if you have a program that goes through a lot of data, you can use the non-lookup table one to help reduce cache misses.</div>
    <div class="meta">Posted on 2004-07-07 16:02:04 by mark_larson</div>
   </div>
   <div class="post" id="post-145599">
    <div class="subject"><a href="#post-145599">Diagonal of Pascal triangle table</a></div>
    <div class="body">If you mean this particular task, non look up table proc though can be used to avoid cache misses any way will be much slower. Just compare time to calc <br />n!/(n-x)!x! with penalty for cache miss.<br />Enough to say that bigest n! for 32 bit var would be 12!.<br />So you'd also need in the case special time consuming procs to work with very long integers<br />(for example 32! =~2,6313083693369353016721801216e+35&quot;</div>
    <div class="meta">Posted on 2004-07-07 18:22:29 by The Svin</div>
   </div>
   <div class="post" id="post-145604">
    <div class="subject"><a href="#post-145604">Diagonal of Pascal triangle table</a></div>
    <div class="body"><div class="quote"><br />If you mean this particular task, non look up table proc though can be used to avoid cache misses any way will be much slower. Just compare time to calc <br />n!/(n-x)!x! with penalty for cache miss.<br />Enough to say that bigest n! for 32 bit var would be 12!.<br />So you'd also need in the case special time consuming procs to work with very long integers<br />(for example 32! =~2,6313083693369353016721801216e+35&quot; </div><br /><br />I sped up the Blackmirror code.  Here is the original code.  It runs in 9252 cycles on my P4.  On my P3 I think it around in the 3000 cycle range.  I will have to re-run it at work tomorrow to get an exact baseline.<br /><br /><pre><code><br />;PascalD2&#58;;&#40;lpMemory, dCount&#41; <br />   pusha <br />   mov esi,&#91;32+esp+4&#93;;lpMemory <br />   mov edi,esi <br />   jmp _l2 <br /> _l0&#58;   lodsd <br />    xadd eax, edx <br />   stosd <br />   cmp esi,ebp <br />   jb _l0 <br /> _l2&#58;   xor eax,eax <br />   xor edx,edx <br />   inc eax <br />   stosd <br />   dec dword ptr &#91;32+esp+8&#93;;dCount <br />   mov ebp,edi <br />   jnz _l0 <br />   popa <br />   retn<br /></code></pre><br /><br />  To speed it up I changed a number of things around.<br /><br />1) I got rid of the &quot;complex&quot; instructions.  Complex instructions are instructions that do more than one thing in an instruction.  That's the stosd, lodsd, and XADD.  That's where I got most of the speed up from.  When the Pentium came out they recommended not using them anymore ( except in the case of using REP with the string instructions), because you were supposed to do more RISC like programming.  <br /><br />2) Moved dCount to a register to get rid of a memory access every loop when they decrement the loop counter.<br /><br />3) Got rid of one of these instructions &quot;xor eax,eax&quot;, &quot;xor edx,edx&quot;, &quot;inc eax&quot;, and made it just 2 instructions &quot;mov eax,1&quot;, &quot;xor edx,edx&quot;.<br /><br />4) I was going to try unrolling the inner loop, but I haven't had a chance yet.<br /><br />  This new code runs in 2360 cycles.  If I remember right this version I am posting now is also faster on a P3, but you don't get as much of a speed improvement as I did in this case.  The original unoptimized Blackmirror code ran in 9252 cycles.  That is 9252 / 2360 = 3.92 times faster.  The reason it runs in more clock cycles on a P4 than on a P3 ( just looking at the cycle count, the higher processor speed of the P4 will help it run faster), has to do with how slow they made some ALU instructions on the P4.  So I avoided them ( the ones listed above).  I didn't comment the code, instead I explained the differences above.  Those are the only changes I made.<br /><br /><pre><code><br />;PascalD2&#58;;&#40;lpMemory, dCount&#41; <br />pusha <br />mov esi,&#91;32+esp+4&#93;;lpMemory <br />mov ecx,&#91;32+esp+8&#93;<br />mov edi,esi <br />jmp _l2 <br />_l0&#58; <br />mov eax,&#91;esi&#93; <br />add esi,4<br />mov ebx,eax<br />add eax,edx <br />mov edx,ebx<br />mov &#91;edi&#93;,eax <br />add edi,4<br /><br />cmp esi,ebp <br />jb _l0 <br />_l2&#58; <br />mov eax,1 <br />xor edx,edx <br />mov &#91;edi&#93;,eax <br />add edi,4<br /><br />dec ecx<br />mov ebp,edi <br />jnz _l0 <br />popa <br />retn <br /><br /></code></pre></div>
    <div class="meta">Posted on 2004-07-07 20:01:42 by mark_larson</div>
   </div>
   <div class="post" id="post-145630">
    <div class="subject"><a href="#post-145630">Diagonal of Pascal triangle table</a></div>
    <div class="body">There is an additional optimization which you can do which I have not done yet.  My life is starting to get busy, so I probably won't be able to finish it.  But it should give a great speed up ( close to 2x).  This is an &quot;algorithmic&quot; change.  I finally look at how a Pascal triangle is generated from this web page.  If you look at the webpage you will notice something interesting.  Every row is symmetric!!!  You can use that to only generate HALF the entries for a row and just fill in the rest.<br /><br /><a target="_blank" href="http://mathworld.wolfram.com/PascalsTriangle.html">http://mathworld.wolfram.com/PascalsTriangle.html</a><br /><br />  I wrote some code that has some bugs to do this.  Basically I freed up another register, and when I do a &quot;mov ,eax&quot; to fill in one entry in a row, I also do a &quot;mov ,eax&quot; to fill out the opposite end of the same row.  I freed up ESP by moving it to an MMX register.  Just make sure you aren't accessing anything on the stack or doing any push/pops after you save it.  I had already moved dCount to a register, and that was the only stack access in the loop.<br /><br /><pre><code><br />movd mm0,esp<br /><br />... code<br /><br />movd esp,mmo<br /></code></pre></div>
    <div class="meta">Posted on 2004-07-08 10:36:35 by mark_larson</div>
   </div>
   <div class="post" id="post-145634">
    <div class="subject"><a href="#post-145634">Diagonal of Pascal triangle table</a></div>
    <div class="body"><em> If you look at the webpage you will notice something interesting. Every row is symmetric!!! </em><br />You might have noticed it looking at test app :)<br />The thing why the fact hasn't been used to speed up proc - again, not to make the proc bigger.</div>
    <div class="meta">Posted on 2004-07-08 12:09:50 by The Svin</div>
   </div>
   <div class="post" id="post-145723">
    <div class="subject"><a href="#post-145723">Diagonal of Pascal triangle table</a></div>
    <div class="body"><pre><code>; dCount = &#91;0,34&#93;<br />; 35 bytes<br />PascalD PROC lpMemory, dCount<br />	xor eax, eax<br />	mov edi, lpMemory<br />	inc eax<br />	mov esi, edi<br />	jmp _3<br /><br />_1&#58;	cdq<br />_2&#58;	lodsd<br />	xadd eax, edx<br />	cmp esi, ebp<br />	stosd<br />	jne _2<br />	mov eax, edx<br />_3&#58;	stosd<br />	dec dCount<br />	mov ebp, edi<br />	jns _1<br />	retn 8<br />PascalD ENDP</code></pre>This PROC was developed from the inside out (start at inner loop and build around), and it is almost the same as <strong>BlackMirror</strong>'s. I was not able to make use of half table.  I wish it was 32 bytes or less (which is not a problem if inlined).</div>
    <div class="meta">Posted on 2004-07-09 07:24:25 by bitRAKE</div>
   </div>
   <div class="post" id="post-145728">
    <div class="subject"><a href="#post-145728">Diagonal of Pascal triangle table</a></div>
    <div class="body"><div class="quote"><em>Originally posted by bitRAKE </em><pre><code> ;code snipped</code></pre>This PROC was developed from the inside out (start at inner loop and build around), and it is almost the same as <strong>BlackMirror</strong>'s. I was not able to make use of half table.  I wish it was 32 bytes or less (which is not a problem if inlined). </div><br /><br /><br />  I think you guys are being a bit too sensitive on code size for saving a few bytes.  When you get into saving in the KB range or MB range then that matters.  Heck at these small byte values, my EXE comes out the same size in both cases.  Let me show you what I mean.  It has to do with how the linker makes the program into an EXE.  Here is my optimized blackmirror code ( not the half a row version)<br /><br /><pre><code><br />;PascalD2&#58;;&#40;lpMemory, dCount&#41; <br />;smallest dCount you can use is 3.  For 3 rows<br />	pusha <br />	cmp dCount,3<br />	jl exit<br />	mov esi,&#91;32+esp+4&#93;;lpMemory <br />	mov ecx,&#91;32+esp+8&#93;<br />	mov edi,esi <br />	mov eax,1<br />	dec	ecx			;we do 2 rows to begin with, so we want to start one lower.<br />	mov &#91;edi&#93;,eax <br />	mov &#91;edi+4&#93;,eax <br />	add edi,8<br />	add	esi,4<br />	jmp _l2 <br />_l0&#58; <br />	mov eax,&#91;esi&#93; <br />	add esi,4<br />	mov ebx,eax<br />	add eax,edx <br />	mov edx,ebx<br />	mov &#91;edi&#93;,eax <br />	add edi,4<br />	cmp esi,ebp <br />	jb _l0 <br />_l2&#58; <br />	mov eax,1 <br />	xor edx,edx <br />	mov &#91;edi&#93;,eax <br />	add edi,4<br />	dec ecx<br />	mov ebp,edi <br />	jnz _l0 <br />exit&#58;<br />	popa <br />   retn <br /></code></pre><br /><br />  The OBJ is 58,400.  The EXE is 54,272.  Just to let you know I have more code in their than just these 2 routines.  I use this program for optimizing all my code.  So it has a lot of other code in it.  But we only care about how much bigger the EXE is from using the 2 different algorithms.<br /><br />  Here is the original blackmirror code.<br /><pre><code><br />;PascalD2&#58;;&#40;lpMemory, dCount&#41; <br />   pusha <br />   mov esi,&#91;32+esp+4&#93;;lpMemory <br />   mov edi,esi <br />   jmp _l2 <br /> _l0&#58;<br />   lodsd <br />   xadd eax, edx <br />   stosd <br />   cmp esi,ebp <br />   jb _l0 <br /> _l2&#58;<br />   xor eax,eax <br />   xor edx,edx <br />   inc eax <br />   stosd <br />   dec dword ptr &#91;32+esp+8&#93;;dCount <br />   mov ebp,edi <br />   jnz _l0 <br />   popa <br />   retn<br /></code></pre><br /><br />  It's OBJ is 58,324 ( mine was 58,400, that means the code I added added 76 bytes).  The EXE size is 54,272.  Wait, wasn't MY algorithm that was a WHOLE 72 bytes longer ALSO 54,272?  I am stunnnnnnned.  How could that happen?  hehhe</div>
    <div class="meta">Posted on 2004-07-09 09:29:45 by mark_larson</div>
   </div>
   <div class="post" id="post-145729">
    <div class="subject"><a href="#post-145729">Diagonal of Pascal triangle table</a></div>
    <div class="body"><strong>mark_larson</strong>, don't assume ignorance just because the coding style doesn't fit your desires.  Please, try to entertain the aspect of the thread.  It has already been stated that the algortihm is not even required, and that speed is not the primary goal.<br /><br /><br />I think we might be able to remove a branch if each line of the table is allowed to end with a zero.  Or how about accessing the table with X(X-1)/2 and allowing the ones to overlap:<br /><br />1,1,2,1,3,3,1,4,6,4,1,5,...<br /><br />This seems to reduce the algorithm/table nicely. :)</div>
    <div class="meta">Posted on 2004-07-09 09:41:56 by bitRAKE</div>
   </div>
   <div class="post" id="post-145743">
    <div class="subject"><a href="#post-145743">Diagonal of Pascal triangle table</a></div>
    <div class="body">Overlapping ones seems a good idea.<br />Icluding situation when there is no table filling proc, and table is included in binary data section.</div>
    <div class="meta">Posted on 2004-07-09 13:56:25 by The Svin</div>
   </div>
   <div class="post" id="post-145745">
    <div class="subject"><a href="#post-145745">Diagonal of Pascal triangle table</a></div>
    <div class="body"><div class="quote"><br /><strong>mark_larson</strong>, don't assume ignorance just because the coding style doesn't fit your desires.  Please, try to entertain the aspect of the thread.  It has already been stated that the algortihm is not even required, and that speed is not the primary goal.<br /><br /><br />I think we might be able to remove a branch if each line of the table is allowed to end with a zero.  Or how about accessing the table with X(X-1)/2 and allowing the ones to overlap:<br /><br />1,1,2,1,3,3,1,4,6,4,1,5,...<br /><br />This seems to reduce the algorithm/table nicely. :) </div><br /><br />  I wasn't assuming ignorance.  When I put the &quot;heehee&quot;, I was doing it in a &quot;teasing&quot; fashion, not in a &quot;you are ignorant&quot; fashion.  I was merely pointing out that worrying over 72 bytes doesn't net you anything since the EXE size ends up being the same anyways.  And I thought the purpose of the thread was to optimize the code and make it run fast.  If you want to reduce the size, you can save an additional byte by using the LOOP command.  It's one byte smaller than DEC/JNZ</div>
    <div class="meta">Posted on 2004-07-09 14:22:22 by mark_larson</div>
   </div>
   <div class="post" id="post-145747">
    <div class="subject"><a href="#post-145747">Diagonal of Pascal triangle table</a></div>
    <div class="body">In case of X = 0, X(X-1)/2 gives wrong offset.<br />I think one more 1 at the start could solve it.</div>
    <div class="meta">Posted on 2004-07-09 14:34:32 by The Svin</div>
   </div>
   <div class="post" id="post-145750">
    <div class="subject"><a href="#post-145750">Diagonal of Pascal triangle table</a></div>
    <div class="body">is the proc recursive?<br />do you care about the size of the proc for the sport of it or because it will be called multiple times and instanciate some stack/heap mem each time?<br /><br />if its the case you could also make a nonrec version of it with an associated data struct to keep track of the different calls... i ve tried to explain what i meant here:<br /><br /><a target="_blank" href="http://www.asmcommunity.net/board/showthread.php?threadid=18705">http://www.asmcommunity.net/board/showthread.php?threadid=18705</a><br /><br />but it seems it wasnt very clear since noone really answered. :)<br /><br />bye</div>
    <div class="meta">Posted on 2004-07-09 14:55:28 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-145752">
    <div class="subject"><a href="#post-145752">Diagonal of Pascal triangle table</a></div>
    <div class="body"><div class="quote"><br />In case of X = 0, X(X-1)/2 gives wrong offset.<br />I think one more 1 at the start could solve it. </div>How so?<br /><br />f(x) = x(x-1)/2<br /><br />f(0) = 0<br /><br />lpMemory[0] = 1<br /><br />?</div>
    <div class="meta">Posted on 2004-07-09 15:10:59 by bitRAKE</div>
   </div>
   <div class="post" id="post-145753">
    <div class="subject"><a href="#post-145753">Diagonal of Pascal triangle table</a></div>
    <div class="body"><div class="quote"><br />I wasn't assuming ignorance.  When I put the &quot;heehee&quot;, I was doing it in a &quot;teasing&quot; fashion, not in a &quot;you are ignorant&quot; fashion.  I was merely pointing out that worrying over 72 bytes doesn't net you anything since the EXE size ends up being the same anyways.  And I thought the purpose of the thread was to optimize the code and make it run fast.  If you want to reduce the size, you can save an additional byte by using the LOOP command.  It's one byte smaller than DEC/JNZ </div>I am saying if someone wants to save some bytes then saving them does net something.  And the challenge can teach things that you might not learn otherwise. Coding can be done for many reasons.  Show me how LOOP makes the code smaller?</div>
    <div class="meta">Posted on 2004-07-09 15:29:28 by bitRAKE</div>
   </div>
   <div class="post" id="post-145754">
    <div class="subject"><a href="#post-145754">Diagonal of Pascal triangle table</a></div>
    <div class="body"><div class="quote"><br />How so?<br /><br />f(x) = x(x-1)/2<br /><br />f(0) = 0<br /><br />lpMemory[0] = 1<br /><br />? </div><br /><br />Stupid me :)<br />I was Just naivly buffled that X=1 and X=0 would gives the same offs, wich in the case overlapping format is correct.</div>
    <div class="meta">Posted on 2004-07-09 15:36:13 by The Svin</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=18791&amp;page=1" style="">&laquo;</a><a href="../?id=18791&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="18791" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=18791&amp;page=3">&gt;</a><a href="../?id=18791&amp;page=3">&raquo;</a></form>  </div>
 </body>
</html>