<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Floating point expression evaluator - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20302" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=20302">Floating point expression evaluator</a></p>
   <div class="post" id="post-155396">
    <div class="subject"><a href="#post-155396">Floating point expression evaluator</a></div>
    <div class="body">I have written the following code to evaluate arithmetic expressions:<br /><br /><pre><code><br />.CONST<br />  OPP_BINARY            EQU 0       ; binary and &#40;&amp;&#41;, or &#40;|&#41;, xor &#40;^&#41;, not &#40;~&#41;<br />  OPP_SHIFT             EQU 1       ; left shift &#40;&lt;&lt;&#41; and right shift &#40;&gt;&gt;&#41;<br />  OPP_LINEAR            EQU 2       ; binary plus &#40;+&#41;, minus &#40;-&#41;<br />  OPP_GEOMETRIC         EQU 3       ; multiply &#40;*&#41;, divide &#40;/&#41;, modulus &#40;%&#41;<br />  OPP_POLYNOMIAL        EQU 4       ; power symbol &#40;^&#41;, log, root<br />  OPP_UNARY_MINUS       EQU 5       ; -&#91;number&#93;<br />  OPP_xCREMENT          EQU 6       ; increment &#40;++&#41; and decrement &#40;--&#41;<br />  OPP_PARENTHESIS       EQU 7       ; &#40; and &#41;<br /><br />.CODE<br />InfixToPostfix proc uses esi edi ebx ecx edx pInfix&#58;DWORD, pPostfix&#58;DWORD<br />  LOCAL stackPos&#58;DWORD<br />  <br />  mov           stackPos, 0<br />  invoke        lstrlen, pInfix<br />  add           eax, pInfix<br />  mov           ecx, eax  <br />  mov           esi, pInfix<br />  mov           edi, pPostfix<br />  .WHILE esi &lt; ecx<br />    movzx       ebx, BYTE PTR &#91;esi&#93;<br /><br />    ; If the next character is part of a number<br />    .IF ebx &gt;= '0' &amp;&amp; ebx &lt;= '9'<br />      mov       BYTE PTR &#91;edi&#93;, bl<br />      add       edi, 1<br />      ; If the next character is not a digit &#40;or decimal&#41;, output a space<br />      .IF BYTE PTR &#91;esi+1&#93; != '.' &amp;&amp; &#40; BYTE PTR &#91;esi+1&#93; &lt; '0' || BYTE PTR &#91;esi+1&#93; &gt; '9' &#41;<br />        mov     BYTE PTR &#91;edi&#93;, ' '<br />        add     edi, 1<br />      .ENDIF<br /><br />    ; If the next character is a decimal point<br />    .ELSEIF ebx == '.'<br />      ; If the character after the decimal is a digit<br />      .IF BYTE PTR &#91;esi+1&#93; &gt;= '0' || BYTE PTR &#91;esi+1&#93; &lt;= '9'<br />        mov     BYTE PTR &#91;edi&#93;, '.'<br />        add     edi, 1<br />      .ELSE<br />        invoke  lstrcpy, pPostfix, CTEXT&#40;&quot;Unexpected decimal point&quot;&#41;<br />        .WHILE stackPos &gt; 0<br />          pop   edx<br />          pop   edx<br />          sub   stackPos, 1<br />        .ENDW<br />        xor     eax, eax<br />        ret<br />      .ENDIF<br /><br />    ; Ignore white space<br />    .ELSEIF ebx == ' ' || ebx == 09h<br />      ; Do nothing<br /><br />    ; Right parenthesis is a special case operator<br />    .ELSEIF ebx == '&#41;'<br />      ; Pop the stack until the left parenthesis is found<br />      .WHILE DWORD PTR &#91;esp+4&#93; != '&#40;' &amp;&amp; stackPos &gt; 0<br />        pop     edx<br />        pop     edx<br />        mov     BYTE PTR &#91;edi&#93;, dl<br />        add     edi, 1<br />        mov     BYTE PTR &#91;edi&#93;, ' '<br />        add     edi, 1<br />        sub     stackPos, 1<br />      .ENDW<br />      <br />      .IF stackPos &gt; 0<br />        ; Discard the parenthesis, do not output<br />        pop     edx<br />        pop     edx<br />        sub     stackPos, 1<br />      .ELSE<br />        invoke  lstrcpy, pPostfix, CTEXT&#40;&quot;Unmatched right parenthesis&quot;&#41;<br />        ; The stack is already clear<br />        xor     eax, eax<br />        ret<br />      .ENDIF<br /><br />    ; The next character is assumed to be an operator<br />    .ELSE<br />      .switch&#40; ebx &#41;        ; Get the operator priority<br />        .case '&amp;', '|'<br />          mov eax, OPP_BINARY<br />          .break<br />        .case '+', '-'<br />          mov eax, OPP_LINEAR<br />          .break          <br />        .case '*', '/', '%'<br />          mov eax, OPP_GEOMETRIC<br />          .break          <br />        .case '^'<br />          mov eax, OPP_POLYNOMIAL<br />          .break        <br />        .case 28h, 29h      ; '&#40;', '&#41;'<br />          mov eax, OPP_PARENTHESIS<br />          .break<br />        .default<br />          ; Unknown operator, print error, clear the stack, and return<br />          invoke    wsprintf, pPostfix, CTEXT&#40;&quot;Error encountered around '%c' - Unknown operator&quot;&#41;, ebx<br />          .WHILE stackPos &gt; 0<br />            pop     edx<br />            pop     edx<br />            sub     stackPos, 1<br />          .ENDW<br />          xor       eax, eax<br />          ret<br />      .endswitch<br /><br />      ; Pop all operators of higher priority than the current one to output<br />      ; with the exception of the left parenthesis, which is a special case<br />      .WHILE DWORD PTR &#91;esp&#93; &gt;= eax &amp;&amp; DWORD PTR &#91;esp+4&#93; != '&#40;' &amp;&amp; stackPos &gt; 0<br />        pop     edx<br />        pop     edx<br />        mov     BYTE PTR &#91;edi&#93;, dl<br />        add     edi, 1<br />        mov     BYTE PTR &#91;edi&#93;, ' '<br />        add     edi, 1<br />        sub     stackPos, 1<br />      .ENDW<br /><br />      push      ebx         ; Actual opperator character<br />      push      eax         ; Opperator priority<br />      add       stackPos, 1<br />    .ENDIF<br /><br />    add         esi, 1<br />  .ENDW<br /><br />  ; Pop the remaining operators from<br />  ; the stack and output them<br />  .WHILE stackPos &gt; 0 <br />    pop         edx<br />    pop         edx<br />    .IF edx != '&#40;'<br />      mov       BYTE PTR &#91;edi&#93;, dl<br />      add       edi, 1<br />      mov       BYTE PTR &#91;edi&#93;, ' '<br />      add       edi, 1<br />    .ENDIF<br />    sub         stackPos, 1<br />  .ENDW<br />  <br />  ; NULL terminate the postfix string<br />  mov           BYTE PTR &#91;edi-1&#93;, 0<br /><br />  mov           eax, edi<br />  sub           eax, pPostfix<br />  sub           eax, 1<br /><br />  ret<br />InfixToPostfix endp<br /><br />EvalExp proc uses esi edi ebx ecx edx pPrefix&#58;DWORD<br />  LOCAL postfix&#91;MAX_PATH&#93;&#58;BYTE<br />  LOCAL expEnd&#58;DWORD<br /><br />  invoke        InfixToPostfix, pPrefix, ADDR postfix<br /><br />  lea           esi, &#91;postfix&#93;<br />  lea           ebx, &#91;esi+eax&#93;<br />  mov           expEnd, ebx<br />  .WHILE esi &lt; expEnd<br />    movzx       ebx, BYTE PTR &#91;esi&#93;<br /><br />    ; If next character is the beginning of an operand<br />    .IF ebx &gt;= '0' &amp;&amp; ebx &lt;= '9'<br />      ; Get the value of the operand<br />      xor       eax, eax<br />      @@&#58;<br />        imul    eax, 10<br />        sub     ebx, '0'<br />        add     eax, ebx<br />        add     esi, 1<br />        movzx   ebx, BYTE PTR &#91;esi&#93;<br />        cmp     ebx, ' '<br />        jnz     @B<br /><br />      ; Operands are pushed directly to the stack<br />      push      eax<br />      <br />    .ELSEIF ebx == ' '<br />      ; Do nothing, a space is just a divider<br />      <br />    .ELSE<br />      ; An operator has been found<br />      pop       ecx     ; Source operand<br />      pop       eax     ; Destination operand<br /><br />      ; Perform the operation<br />      .switch&#40; ebx &#41;<br />        .case '+'<br />          add   eax, ecx<br />          .break<br />        .case '-'<br />          sub   eax, ecx<br />          .break<br />        .case '*'<br />          mul   ecx<br />          .break<br />        .case '/'<br />          xor   edx, edx<br />          div   ecx<br />          .break<br />        .case '%'<br />          xor   edx, edx<br />          div   ecx<br />          mov   eax, edx<br />          .break<br />        .case '&amp;'<br />          and   eax, ecx<br />          .break<br />        .case '|'<br />          or    eax, ecx<br />          .break<br />        .case '^'  ; X^Y  &#40;thanks to bitRAKE&#41;<br />          mov   ebx, ecx    ; Y<br />          mov   ecx, eax    ; X<br />          mov   eax, 1 <br />          xor   edx, edx <br />          jmp   pow_a<br />          pow_1&#58;    imul    ecx <br />          pow_2&#58;    imul    ecx, ecx<br />          pow_a&#58;    shr     ebx, 1<br />                    jnbe    pow_2<br />                    jc      pow_1        <br />          .break<br />      .endswitch<br /><br />      ; Push the result of the operation back onto the stack<br />      push      eax        <br />    .ENDIF<br /><br />    ; Advance to the next character<br />    add         esi, 1<br />  .ENDW<br /><br />  ; The top of the stack contains the result<br />  pop           eax<br />  ret<br />EvalExp endp<br /></code></pre><br /><br />and now I'm wondering if anybody has some advice for me on how to improve on it.  I didn't have but one lousy referance so I'm pretty sure my code isn't the best.  In particular, I'd appreciate any advice on how to add support for floating point numers durring the actual evaluation (in the EvalExp procedure).  Any ideas, thoughts, criticisms, and advice would be a great help.<br /><br />Spara</div>
    <div class="meta">Posted on 2005-01-08 02:13:41 by Sparafusile</div>
   </div>
   <div class="post" id="post-155404">
    <div class="subject"><a href="#post-155404">Floating point expression evaluator</a></div>
    <div class="body">neat. i wrote something similar, recently, but i did it in c# :)<br /><br />I was wondering: do you handle postfix expressions like (-a+b) and -(c/d) and such? I had a minor problem with the - in such cases.</div>
    <div class="meta">Posted on 2005-01-08 08:55:06 by lifewire</div>
   </div>
   <div class="post" id="post-155413">
    <div class="subject"><a href="#post-155413">Floating point expression evaluator</a></div>
    <div class="body">Yeah, the unary operators (-,+,++,--,not) are not implemented yet.  That's one of the things I'm having trouble figuring out.  How did you do it?<br /><br />Spara</div>
    <div class="meta">Posted on 2005-01-08 13:19:55 by Sparafusile</div>
   </div>
   <div class="post" id="post-155459">
    <div class="subject"><a href="#post-155459">Floating point expression evaluator</a></div>
    <div class="body">well, my expression evaluator translated postfix expressions into infix (RPN) expressions which got on their turn translated into commands for a virtual stackmachine, so it differs a little from yours, but iirc, i checked whether the left hand of the '-' operator (i only had that operator as operator that differed from the others) was an operator itself, parenthesis or start of the expression. but note that i'm not 100% sure about that ;)</div>
    <div class="meta">Posted on 2005-01-10 03:46:26 by lifewire</div>
   </div>
   <div class="post" id="post-155512">
    <div class="subject"><a href="#post-155512">Floating point expression evaluator</a></div>
    <div class="body">Yeah, the only thing I could think of was to check the lexeme to the left of the minus to see if it was another operator.  This causes problems if I allow increment and decrement operations though.  On a side not, I rewrote the functions above so that instead of keeping the expression in ascii form, the InfixToPostfix procedure converts it to a binary representation.  This makes the whole process much easier and I think a little faster.<br /><br /><strong>Edit:</strong> I just checked the Dragon Book and it said that, in the case of of a unary operator that is also a binary operator (minus sign in this case), the operator is &quot;unary if the previous token was an operator, a left parenthesis, a comma, or an assignment symbol&quot; (using the Fortran language for an example).  Just thought you'd like to know.<br /><br />Spara</div>
    <div class="meta">Posted on 2005-01-10 13:07:13 by Sparafusile</div>
   </div>
   <div class="post" id="post-155664">
    <div class="subject"><a href="#post-155664">Floating point expression evaluator</a></div>
    <div class="body">i haven't really looked at the code, but i personally think recursion with parentheses are a lot easier than RPN, and keeping seperate stacks/define precedence and stuff. how mine worked was that i split he parsing thing into 3 layers, the first layer would check for addition/subtraction, the second layer would take care of multiplication/division, and the third layer would do stuff like parentheses and unary operators. the first layer would first call the second, and second third, etc. and take that result and do the operation. if a parenthese &quot;(&quot; is detected by layer 3, it calls layer 1, and sorta recurses like that. and when a unary operator is reached, layer 3 will just negate the next term (which may be a nested parenthese, which would then recurse back to layer 1 until a value was returned, etc.)<br /><br />just my 2 cents. i'm still struggling to think of how to make a system like this versatile enough for a interpreter engine, or something like that. darn.</div>
    <div class="meta">Posted on 2005-01-12 17:19:01 by Drocon</div>
   </div>
   <div class="post" id="post-155669">
    <div class="subject"><a href="#post-155669">Floating point expression evaluator</a></div>
    <div class="body">If I was to use your approach, Drocon, I'd have 11 differant functions for all the differant &quot;layers&quot; of operator precedence.  That might be a little hard to maintain so I'll stick with the RPN way for now.  I'm looking into using tripples or quadrupals, but it seems like more work than is needed right now.  In case you're curious, you can download a working version of my expression evaluator <a target="_blank" href="www.cs.iupui.edu/~phatcher/ExpEval.exe">here</a>.  Supported operators include:<br /><br />+,-,*,/,%,^(power),&amp;,|,xor,~,&lt;&lt;,&gt;&gt;,++,--,&amp;&amp;,||,!,&lt;,&gt;,&lt;=,&gt;=,==,!=,(bool),(,)<br /><br />Only interger operands for now.<br /><br />Spara</div>
    <div class="meta">Posted on 2005-01-12 19:32:54 by Sparafusile</div>
   </div>
   <div class="post" id="post-155718">
    <div class="subject"><a href="#post-155718">Floating point expression evaluator</a></div>
    <div class="body">never heard of the dragon book, but at least i'm happy that my solution wasn't very brainless :)<br /><br />about RPN/postfix: i think it makes sense to translate infix to postfix if the evaluation will get evaluated many times and speed matters. translating infix to postfix is almost identical to evaluating infix, i think.</div>
    <div class="meta">Posted on 2005-01-13 05:34:15 by lifewire</div>
   </div>
   <div class="post" id="post-155786">
    <div class="subject"><a href="#post-155786">Floating point expression evaluator</a></div>
    <div class="body">Adding floating point support should be trivial, what part of it are you having problems with, and what kind of problems?<br /><br />Leading unary operators can be handled near the check for the parenthesis. If found, treat it like a normal operator. When it's time to evaluate it, the item to be acted on should be on the top of the operand stack.<br />Following operators are processed by writing down all operators on the stack until you get to one with lower precedence, and then writing down the new operator instead of laying it on the stack.<br /><br />You could compare the code with this snippet from my ARM7 assembler (written in NASM), but it doesn't have floating point or preposterous operators either, because they slipped my mind :P<br /><pre><code><br />; &#40;c&#41; me. For educational purposes.<br />GetExpr&#58;<br />mov edi,&#91;nextexpr&#93;<br />add edi,byte 18<br />push byte -1<br />lodsb<br />cmp al,'#'<br />jz expr0<br />dec esi<br />expr0&#58;<br />call fchspaces ; Skip blanks<br />test al,al<br />jz near synerror<br />cmp al,'&#40;'<br />jnz ikkeparentes<br />push byte -2<br />jmp short expr0<br />ikkeparentes&#58;<br />call GetNumber<br />jae exp_nbr<br />mov al,129<br />stosb<br />call checklabel<br />xchg ecx,eax<br />stosw<br />jmp short nesteop<br />exp_nbr&#58;<br />mov &#91;edi&#93;,byte 128<br />inc edi<br />stosd<br />nesteop&#58;<br />call fchspaces<br />lodsb<br />test al,al<br />jz near expslutt<br />push byte 11<br />pop ecx<br />xor edx,edx<br />oploop&#58;<br />mov ah,&#91;ecx+operators-1&#93;<br />add ah,ah<br />adc edx,byte 0<br />shr ah,1<br />cmp al,ah<br />loopnz oploop<br />jnz operror<br />cmp cl,4<br />jb ikkeskiftop<br />cmp cl,6<br />jae ikkeskiftop<br />cmp al,&#91;esi&#93; ; Check &lt;&lt; and &gt;&gt;<br />jnz operror<br />inc esi<br />ikkeskiftop&#58;<br />pop eax<br />cmp eax,edx ; Check precedence<br />ja dyttnyop<br />pop eax ; Write down previous operator.<br />stosb<br />jmp short ikkeskiftop<br />dyttnyop&#58;<br />jecxz sluttpar<br />push eax<br />push ecx ; Put on stack<br />push edx<br />jmp short expr0<br />sluttpar&#58;<br />cmp al,255<br />jnz nesteop<br />push eax<br />mov al,'&#41;'<br />operror&#58;<br />push eax<br />push dword operrmsg<br />call LogError<br />fjernneste2&#58;<br />pop eax<br />fjernneste&#58;<br />pop eax<br />cmp al,255<br />jz expferdig<br />cmp al,254<br />jnz fjernneste2<br />jmp short fjernneste<br />exp_ok&#58;<br />stosb<br />push edi<br />mov edi,&#91;nextexpr&#93; ; Store field info<br />push edi<br />mov eax,&#91;esp+12&#93;<br />stosw<br />mov eax,&#91;asmofs&#93;<br />stosd<br />mov eax,&#91;linenbr&#93;<br />stosd<br />mov eax,&#91;curpc&#93;<br />movzx ecx,byte &#91;thumbflag&#93;<br />shl ecx,3<br />sub ecx,8<br />sub eax,ecx<br />stosd<br />pop edi<br />call calcexp2<br />pop eax<br />jae expferdig<br />mov &#91;nextexpr&#93;,eax ; Put calculation on hold if unsuccessful<br />mov &#91;edi+14&#93;,eax<br />expferdig&#58;<br />dec esi<br />mov ecx,edi<br />mov edi,esi<br />ret 4<br />synerror&#58;<br />push dword synerrmsg<br />call LogError<br />jmp short fjernneste<br />expslutt&#58;<br />pop eax<br />cmp al,255<br />jz exp_ok<br />cmp al,254<br />jz synerror<br />pop eax<br />stosb<br />jmp short expslutt<br /><br />calcexp&#58;<br />mov edx,&#91;edi+6&#93;<br />mov &#91;linenbr&#93;,edx<br />calcexp2&#58;<br />push ebx<br />push esi<br />mov ebx,esp<br />lea esi,&#91;edi+18&#93;<br />calcloop&#58;<br />xor eax,eax<br />lodsb<br />test al,al<br />jns calcop<br />cmp al,255 ; End of calculation<br />jz calcok<br />cmp al,128 ; Check label or number<br />jnz notcalcimm<br />lodsd<br />push eax<br />jmp short calcloop<br />notcalcimm&#58;<br />xor eax,eax<br />lodsw<br />shl eax,4<br />add eax,labeltbl<br />test byte &#91;eax+5&#93;,1<br />jz calcfail ; Forward reference<br />push dword &#91;eax+8&#93;<br />jmp short calcloop<br />calcop&#58;<br />xchg edx,eax<br />pop ecx<br />pop eax<br />call &#91;opfunc+edx*4-4&#93;<br />push eax<br />jmp short calcloop<br />calcok&#58;<br />pop eax<br />push eax<br />xor edx,edx<br />movzx ecx,byte &#91;edi&#93;<br />inc edx<br />cmp cl,4<br />jb simplefield<br />call &#91;fieldfunc-16+ecx*4&#93; ; Format field<br />jb fielderr<br />jmp short fieldok2<br />simplefield&#58;<br />jecxz fieldok<br />mov cl,&#91;fieldtbl-1+ecx&#93;<br />shl edx,cl<br />cmp eax,edx<br />jb fieldok<br />fielderr&#58;<br />push dword bounderrstr<br />call LogError<br />pop eax<br />fieldok&#58;<br />mov cl,ch<br />shl eax,cl<br />fieldok2&#58;<br />or ebp,eax<br />pop eax<br />clc<br />jmp short calcsuccess<br />calcfail&#58;<br />stc<br />calcsuccess&#58;<br />mov esp,ebx<br />pop esi<br />pop ebx<br />ret<br />bounderrstr db &quot;Inappropriate number - 0x%X&quot;,0<br />opfunc dd opor,opxor,opand,oplsl,oplsr,opadd,opsub,opmul,opdiv,oprem<br />opor&#58;<br />or eax,ecx<br />ret<br />opxor&#58;<br />xor eax,ecx<br />ret<br />opand&#58;<br />and eax,ecx<br />ret<br />oplsl&#58;<br />shl eax,cl<br />ret<br />oplsr&#58;<br />shr eax,cl<br />ret<br />opadd&#58;<br />add eax,ecx<br />ret<br />opsub&#58;<br />sub eax,ecx<br />ret<br />opmul&#58;<br />imul ecx<br />ret<br />opdiv&#58;<br />jecxz diverror<br />cdq<br />idiv ecx<br />ret<br />oprem&#58;<br />jecxz diverror<br />cdq<br />idiv ecx<br />xchg edx,eax<br />ret<br />diverror&#58;<br />push dword diverrstr<br />call LogError<br />xor eax,eax<br />ret<br />diverrstr db &quot;Didn't you learn not to do that in elementary school?&quot;,0<br />; Formatting functions and number input not reproduced.<br />operrmsg db &quot;Syntax error - %c&quot;,0<br />synerrmsg db &quot;Operand error&quot;,0<br />shifterror db &quot;Shift error&quot;,0<br />operators db &quot;??^?&lt;?+?*/%&quot;<br /></code></pre></div>
    <div class="meta">Posted on 2005-01-14 13:09:47 by Sephiroth3</div>
   </div>
   <div class="post" id="post-155789">
    <div class="subject"><a href="#post-155789">Floating point expression evaluator</a></div>
    <div class="body"><div class="quote">never heard of the dragon book...</div><br /><br /><a target="_blank" href="http://www.amazon.com/exec/obidos/ASIN/0201100886/qid=1105734230/sr=2-2/ref=pd_ka_b_2_2/103-0347622-6031879">Dragon Book</a> - it's the definitive book on compiler design and very worth the price if you're into that sort of thing.<br /><br /><div class="quote">Adding floating point support should be trivial, what part of it are you having problems with, and what kind of problems?</div><br /><br />I'm having trouble converting from ascii to binary.  Idealy I would write my own procedure, but after looking at some examples it look like that's more work than I want to put into it.  I guess I'm going to have to use FpuAtoFL which is distributed with MASM, but that procedure (and it's counterpart FpuFLtoA) is confusing to me because I haven't found any good documentation for them.<br /><br /><div class="quote">Leading unary operators can be handled near the check for the parenthesis. If found, treat it like a normal operator. When it's time to evaluate it, the item to be acted on should be on the top of the operand stack.</div><br /><br />Thanks, but I already solved the unary operator problem (as stated in my previous post).  I belive you may be wrong in that statement anyway.  Durring a infix to postfix conversion, the operands are not on the stack, but rather the operators are.  The operands are output as soon as they're seen.  Perhaps you ment that statement to refer to the evaluation process durring which the operands are pushed to the stack and the operators are handled immediately.<br /><br />Spara</div>
    <div class="meta">Posted on 2005-01-14 14:30:41 by Sparafusile</div>
   </div>
   <div class="post" id="post-155805">
    <div class="subject"><a href="#post-155805">Floating point expression evaluator</a></div>
    <div class="body"><div class="quote"> I just checked the Dragon Book and it said that, in the case of of a unary operator that is also a binary operator (minus sign in this case), the operator is &quot;unary if the previous token was an operator, a left parenthesis, a comma, or an assignment symbol&quot; (using the Fortran language for an example). <br /></div><br />A simpler rule is that an operator is binary if the symbol to the left is an operand (number or variable or right bracketing symbol). Fewer comparisons. This rule and the one cited above don't work if there are postfix operators.</div>
    <div class="meta">Posted on 2005-01-14 21:56:37 by tenkey</div>
   </div>
   <div class="post" id="post-155836">
    <div class="subject"><a href="#post-155836">Floating point expression evaluator</a></div>
    <div class="body">here's a very simple infix to postfix program in pascal, in a nutshell<br />the lowest function calls the next-higher precedence function and so on.<br /><br /><pre><code><br />program postfix&#40;input,output&#41;;<br /><br />const n=255;<br />      num_of_fns=18;<br />      <br />type str=string&#91;n&#93;;<br /><br />var expr,token,fns&#58;str;<br />    i,count&#58;integer;<br />    fns1&#58;array&#91;1..num_of_fns&#93; of string&#91;5&#93;;<br />    <br />procedure initfns;<br /><br />begin<br />  fns1&#91;1&#93;&#58;='ASINH';fns1&#91;2&#93;&#58;='ACOSH';fns1&#91;3&#93;&#58;='ATANH';<br />  fns1&#91;4&#93;&#58;='SINH';fns1&#91;5&#93;&#58;='COSH';fns1&#91;6&#93;&#58;='TANH';<br />  fns1&#91;7&#93;&#58;='ASIN';fns1&#91;8&#93;&#58;='ACOS';fns1&#91;9&#93;&#58;='ATAN';<br />  fns1&#91;10&#93;&#58;='ALOG';fns1&#91;11&#93;&#58;='SQRT';fns1&#91;12&#93;&#58;='SIN';<br />  fns1&#91;13&#93;&#58;='COS';fns1&#91;14&#93;&#58;='TAN';fns1&#91;15&#93;&#58;='LOG';<br />  fns1&#91;16&#93;&#58;='EXP';fns1&#91;17&#93;&#58;='SQR';fns1&#91;18&#93;&#58;='LN';<br />end;<br /><br />function upper&#40;ch&#58;char&#41;&#58;char;<br />begin<br />  if &#40;ch&gt;='a'&#41; and &#40;ch&lt;='z'&#41; then<br />     upper&#58;=chr&#40;ord&#40;ch&#41;+&#40;ord&#40;'A'&#41;-ord&#40;'a'&#41;&#41;&#41;<br />  else upper&#58;=ch;<br />end; &#123; upper &#125;<br /><br />procedure ucase&#40;var x&#58;str&#41;;<br />var i&#58;integer;<br />begin<br />  for i&#58;=1 to length&#40;x&#41; do x&#91;i&#93;&#58;=upper&#40;x&#91;i&#93;&#41;;<br />end;<br /><br />procedure modcheck&#40;var expr&#58;str&#41;;<br />var i&#58;integer;<br />    s&#58;str;<br />begin<br />  i&#58;=1;<br />  while &#40;i&lt;length&#40;expr&#41;&#41; do begin<br />    s&#58;=copy&#40;expr,i,5&#41;;<br />    ucase&#40;s&#41;;;<br />    if &#40;s=' MOD '&#41; then begin<br />      delete&#40;expr,i,5&#41;;<br />      insert&#40;'%',expr,i&#41;;<br />    end;<br />    i&#58;=i+1;<br />  end;<br />end;<br /><br />procedure fncheck&#40;var expr&#58;str&#41;;<br />var i,p,l&#58;integer;<br />    f&#58;str;<br />    <br />begin<br />  ucase&#40;expr&#41;;<br />  for i&#58;=1 to num_of_fns do begin<br />    f&#58;=fns1&#91;i&#93;;<br />    l&#58;=length&#40;f&#41;;<br />    f&#58;=concat&#40;f,'&#40;'&#41;;<br />    p&#58;=pos&#40;f,expr&#41;;<br />    while p&lt;&gt;0 do begin<br />      delete&#40;expr,p,l&#41;;<br />      insert&#40;chr&#40;i&#41;,expr,p&#41;;<br />      p&#58;=pos&#40;f,expr&#41;;<br />    end;<br />  end;<br />end;<br /><br />procedure removeblanks&#40;var expr&#58;str&#41;;<br /><br />var ch&#58;char;<br />    i&#58;integer;<br />    <br />begin<br />  i&#58;=1;<br />  while i&lt;=length&#40;expr&#41; do begin<br />    ch&#58;=expr&#91;i&#93;;<br />    if ch=' ' then delete&#40;expr,i,1&#41;;<br />    if ch&lt;&gt;' ' then i&#58;=i+1;<br />  end;<br />end;<br /><br />procedure scan;<br /><br />begin<br />  if count&lt;=length&#40;expr&#41; then begin<br />    token&#58;=expr&#91;count&#93;;<br />    count&#58;=count+1;<br />  end<br />  else token&#58;=' ';<br />end;<br /><br />procedure error;<br />begin<br />  expr&#58;=' ';<br />  token&#58;=' ';<br />end;<br /><br />function indentifier&#40;var token&#58;str&#41;&#58;boolean;<br />var i,t&#58;boolean;<br />begin<br />  i&#58;=&#40;token&#91;1&#93; in &#91;'A'..'Z','a'..'z'&#93;&#41;;<br />  t&#58;=i;<br />  while t do begin<br />    if &#40;expr&#91;count&#93; in &#91;'_','A'..'Z','a'..'z','0'..'9'&#93;&#41; then begin<br />      token&#58;=token+expr&#91;count&#93;;<br />      count&#58;=count+1;<br />    end<br />    else t&#58;=not t;<br />  end;<br />  indentifier&#58;=i;<br />end;<br /><br />function constant&#40;var token&#58;str&#41;&#58;boolean;<br />var c,t&#58;boolean;<br />begin<br />  t&#58;=&#40;token&#91;1&#93; in &#91;'0'..'9'&#93;&#41;;<br />  c&#58;=t;<br />  while c do begin<br />    c&#58;=&#40;expr&#91;count&#93; in &#91;'0'..'9'&#93;&#41;;<br />    if c then begin<br />      token&#58;=token+expr&#91;count&#93;;<br />      count&#58;=count+1;<br />    end;<br />  end;<br />  constant&#58;=t;<br />end;<br /><br />procedure variable;<br />begin<br />  if indentifier&#40;token&#41; then begin<br />    write&#40;token,' '&#41;;<br />    scan;<br />  end<br />  else write&#40;'ERROR&#58; missing VARIABLE '&#41;;<br />end;<br /><br />procedure expression;<br />var t&#58;char;<br /><br />  procedure unary;<br />  var t&#58;char;<br />  <br />    procedure term;<br />    var t&#58;char;<br />  <br />      procedure expon;<br />    <br />        procedure gamma;<br />        var t&#58;char;<br />        <br />          procedure factor;<br />          var t&#58;integer;<br />        <br />          begin<br />            if constant&#40;token&#41; then begin<br />              write&#40;token,' '&#41;;<br />              scan;<br />            end<br />            else if &#40;token&#91;1&#93; in &#91;'+','-'&#93;&#41; then unary<br />            else if token='&#40;' then begin<br />              scan;<br />              expression;<br />              if token='&#41;' then scan<br />                else write&#40;'ERROR&#58; missing ',chr&#40;39&#41;,'&#41;',chr&#40;39&#41;,' '&#41;;<br />            end<br />            else if &#40;token&#91;1&#93; in &#91;chr&#40;1&#41;..chr&#40;num_of_fns&#41;&#93;&#41; then begin<br />              fns&#58;=fns+token&#91;1&#93;;<br />              scan;<br />              if token&#91;1&#93;='&#40;' then begin<br />                scan;<br />                expression;<br />              end<br />              else begin<br />                writeln;writeln&#40;chr&#40;39&#41;,'&#40;',chr&#40;39&#41;,' expected'&#41;;<br />              end;<br />              if token&#91;1&#93;='&#41;' then scan<br />              else begin<br />                writeln;writeln&#40;chr&#40;39&#41;,'&#41;',chr&#40;39&#41;,' expected'&#41;;<br />              end;<br />              t&#58;=ord&#40;fns&#91;length&#40;fns&#41;&#93;&#41;;<br />              delete&#40;fns,length&#40;fns&#41;,1&#41;;<br />              write&#40;fns1&#91;t&#93;,' '&#41;;<br />            end<br />            else variable;<br />          end; &#123; factor &#125;<br />        <br />      begin &#123; gamma &#125;<br />        factor;<br />        while token&#91;1&#93;='!' do begin<br />          write&#40;'! '&#41;;<br />          scan;<br />        end;<br />      end; &#123; gamma &#125;<br />      <br />    begin &#123; expon &#125;<br />      gamma;<br />      while token&#91;1&#93;='^' do begin<br />        scan;<br />        if token&#91;1&#93;&lt;&gt;'^' then begin<br />          gamma;<br />          write&#40;'^ '&#41;;<br />        end<br />        else begin<br />          writeln&#40;'syntax error'&#41;;<br />          error;<br />        end;<br />      end;<br />    end; &#123; expon &#125;<br />    <br />    begin &#123; term &#125;<br />      expon;<br />      while &#40;token&#91;1&#93; in &#91;'*','/','%'&#93;&#41; do begin<br />        t&#58;=token&#91;1&#93;;<br />        scan;<br />        expon;<br />        case t of<br />          '*'&#58;write&#40;'* '&#41;;<br />          '/'&#58;write&#40;'/ '&#41;;<br />          '%'&#58;write&#40;'mod '&#41;;<br />        end; &#123; case &#125;<br />      end;<br />    end; &#123; term &#125;<br />    <br />    begin &#123; unary &#125;<br />      if token&#91;1&#93; in &#91;'-','+'&#93; then begin<br />        t&#58;=token&#91;1&#93;;<br />        scan;<br />        term;<br />        if t='-' then write&#40;'NEG '&#41;;<br />      end<br />      else term;<br />    end; &#123; unary &#125;<br /> <br />    <br />  begin &#123; expression &#125;<br />    unary;<br />    while &#40;token&#91;1&#93;='-'&#41; or &#40;token&#91;1&#93;='+'&#41; do begin<br />      t&#58;=token&#91;1&#93;;<br />      scan;<br />      unary;<br />      case t of<br />        '+'&#58;write&#40;'+ '&#41;;<br />        '-'&#58;write&#40;'- '&#41;;<br />      end; &#123; case &#125;<br />    end;<br />  end; &#123; exxpression &#125;<br />  <br />  procedure assignment;<br />  begin<br />    variable;<br />    if token&#91;1&#93;='=' then scan else write&#40;'ERROR&#58; no ASSIGNMENT '&#41;;<br />    expression;<br />    writeln&#40;'STORE'&#41;;<br />  end;<br />  <br />  begin &#123; postfix &#125;<br />  initfns;<br />  expr&#58;=' ';<br />  while length&#40;expr&#41;&gt;0 do begin<br />    count&#58;=1;for i&#58;=1 to n do expr&#91;i&#93;&#58;=' ';<br />    fns&#58;='';<br />    write&#40;'Enter an expression&#58; '&#41;;<br />    readln&#40;expr&#41;;<br />    modcheck&#40;expr&#41;;<br />    fncheck&#40;expr&#41;;<br />    removeblanks&#40;expr&#41;;<br />    if length&#40;expr&#41;&gt;0 then begin<br />      scan;<br />      if indentifier&#40;token&#41; and &#40;expr&#91;count&#93;='='&#41; then assignment<br />      else begin<br />        expression;<br />        writeln;<br />      end;<br />    end;<br />    writeln;<br />  end;<br />end.<br /></code></pre></div>
    <div class="meta">Posted on 2005-01-15 19:49:34 by jack</div>
   </div>
   <div class="post" id="post-155867">
    <div class="subject"><a href="#post-155867">Floating point expression evaluator</a></div>
    <div class="body">Yes, and the parsing strategy coded in Pascal is called recursive descent.<br /><br />In ASM, the nested procedures are unnecessary. The nesting gets around Pascal's declare-before-use rule, without using the common FORWARD extension.</div>
    <div class="meta">Posted on 2005-01-16 18:15:33 by tenkey</div>
   </div>
   <div class="post" id="post-155925">
    <div class="subject"><a href="#post-155925">Floating point expression evaluator</a></div>
    <div class="body">Sorry, but none of this is new to me.  I've been writing recursive decent analyzers for years.  What I do need some help on is converting the ASCII representation of a floating point number into the binary representation.  Any hints would be appreciated.<br /><br />Spara</div>
    <div class="meta">Posted on 2005-01-17 18:19:46 by Sparafusile</div>
   </div>
   <div class="post" id="post-155938">
    <div class="subject"><a href="#post-155938">Floating point expression evaluator</a></div>
    <div class="body">You should first know how to translate 2.2 to binary if Im not wrong is 10.00110 and then a infinite repetition  of 0110 then you should apply Cientific notation some like for example (if Im not wrong ;)) 1000110*10^(-101) there is a special way and is the called normalization denormalization is somewhat the notation cientific with some considerations. That is all that I can say about that :D, by the way, because you can not have infinite representations like the anterior one, the information is &quot;packed&quot; in acordance to a standar.<br /><br />http://www.asmcommunity.net/board/viewtopic.php?t=16687&amp;highlight=ieee+float<br /><br />By the way, the assemblers should have some algorithms implemented at this side.<br /><br />You can look at nasm, yasm or fasm...<br /><br /><br /><br />By the way, I remember that the yasm transformations are from other source, where interesting and I where unable to undertand some things :).</div>
    <div class="meta">Posted on 2005-01-17 22:42:04 by rea</div>
   </div>
  </div>
 </body>
</html>