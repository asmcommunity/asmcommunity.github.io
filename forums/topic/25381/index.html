<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Negative Offsets? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25381" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25381">Negative Offsets?</a></p>
   <div class="post" id="post-185599">
    <div class="subject"><a href="#post-185599">Negative Offsets?</a></div>
    <div class="body">Hi<br /><br />I&#39;ve just come across a strange (to me) error when assembling a piece of code using masm.&nbsp; I&#39;m trying to point to a character in a string (esi) by using a register (ecx) as an offset.&nbsp; The use of an offset works when adding them, but when I attempt to subtract them, it fails to assemble.&nbsp; Here is an example:<br /><br /><pre><code><br />mov dl, byte ptr 		;This works fine<br /><br />mov dl, byte ptr 		;&lt;--The assembler fails on this instruction<br /></code></pre><br /><br />Upon viewing a disassembly listing of the working code, I noticed that the first statement is rewritten as<br /><br /><pre><code><br />mov dl, byte ptr <br /></code></pre><br /><br />with the registers in the instructions swapped.&nbsp; I imagine the problem in the second line lies somewhere with this conversion, seeing that the order of the registers would not make a difference to an addition, but it would affect a subtraction.<br /><br />Is the second line considered illegal syntax for masm or for assembly in general?<br /><br />Is there a way to reference a location relative to esi by subtracting a value as in the second instruction?</div>
    <div class="meta">Posted on 2006-09-29 07:05:33 by Timbo</div>
   </div>
   <div class="post" id="post-185600">
    <div class="subject"><a href="#post-185600">Re: Negative Offsets?</a></div>
    <div class="body">it is impossible by opcode specification.<br />you have to use neg ecx, then addition</div>
    <div class="meta">Posted on 2006-09-29 07:11:59 by Shoo</div>
   </div>
   <div class="post" id="post-185601">
    <div class="subject"><a href="#post-185601">Re: Negative Offsets?</a></div>
    <div class="body">Thanks Shoo.&nbsp; Due to the way ollydbg displayed rewrote the instruction, I thought it might not be allowed but thanks for confirming it.&nbsp; It also never occurred to do the negation then the addition so thanks for that little gem too.&nbsp; The code was part of a string reversing routine and I was just looking for a shorter way of doing it.&nbsp; It only ended up 1 byte longer (using dec ecx actually), but at least I learnt something :)</div>
    <div class="meta">Posted on 2006-09-29 07:21:29 by Timbo</div>
   </div>
   <div class="post" id="post-185602">
    <div class="subject"><a href="#post-185602">Re: Negative Offsets?</a></div>
    <div class="body">Just to add a subtle point to Shoo&#39;s post, there is no way you could use a negative sign between either way of addressing mode. You could form the effective address with the below formula<br /><br />Segment address + Base address + Index multiplied by the scale  + Displacement <br /><br />Therefore, you are not allowed to compute the effective address of a memory location using the negative sign. Just like Shoo implied. Oh before i forget, if you are trying to navigate backwards through the elements of some kind of an array or something or generally in memory, you could decrement the base address or the index factor of the above formula N times where N is the number of bytes you need to navigate back through in each iteration.</div>
    <div class="meta">Posted on 2006-09-29 08:52:50 by XCHG</div>
   </div>
   <div class="post" id="post-185604">
    <div class="subject"><a href="#post-185604">Re: Negative Offsets?</a></div>
    <div class="body"><div class="quote"><br />if you are trying to navigate backwards through the elements of some kind of an array or something or generally in memory, you could decrement the base address or the index factor of the above formula N times where N is the number of bytes you need to navigate back through in each iteration.<br /></div><br /><br />Thanks for the formula!&nbsp; In my implementation, I ended up decrementing the index.&nbsp; I had esi pointing to the start of the string and edi pointing to the end of it.&nbsp; By incrementing ecx as a displacement index, I could reference the characters at the start of the string by using <strong>ecx + esi</strong>, but unfortunately not for the characters at the end (by using the flawed edi - ecx).&nbsp; I settled for a simple <strong>dec edi</strong> on every iteration.&nbsp; I was basically trying to cheat and see if I could get away without using an extra instruction.</div>
    <div class="meta">Posted on 2006-09-29 09:24:41 by Timbo</div>
   </div>
   <div class="post" id="post-185614">
    <div class="subject"><a href="#post-185614">Re: Negative Offsets?</a></div>
    <div class="body">Here is a little procedure I wrote despite not having enough time to code it the way I like, however, it works, to show you how you could navigate back through characters and stuff using LEA. This procedure reverses a string without allocating space in the stack or using a local variable. It uses the string itself to reverse its content and it works like this.<br /><br />Imagine you have the string &quot;Assembly&quot; which is 8 bytes long. First you have to find the end of the string and let one of the base register hold the address of the beginning of the string. Now for example, EBX points at the last byte in the string and ESI is at the beginning of the string. By subtracting the memory address of the ESI register from the EBX you will find the length of the string which is eight. Put this length in another register preferably the count register. Now what we do is that we move the first byte to the last and the last to the first, then we decrement the pointer to the last byte of the string by one and increment the pointer to the beginning of the string by one too.<br /><br />Therefore, we first move A to Y and Y to A, and we&#39;ll have &quot;YssemblA&quot;.<br />Then we have to continue doing this but for ECX/2 times because if we do this for ECX times we will get the original value back. Thus, you need to divide the value of the counter by 2 using the SHR instruction.<br /><br />One important thing to notice is that not every string has an even length, for example, &quot;Borland&quot;. The length of the string is 7 which if devided by 2 would result in three. But it is no big deal due to the fact that the character placed at the center does not need to get replaced or replace anything in a string with an odd length.<br /><br />Below is a procedure I coded which does this for you.<br /><br /><pre><span style="font-size:2><br />StrReverse PROC TheStr:DWORD<br />&nbsp; PUSH&nbsp; &nbsp; EBX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Preserve the base index<br />&nbsp; PUSH&nbsp; &nbsp; ESI&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Preserve the source index<br />&nbsp; MOV&nbsp; &nbsp;  EBX , TheStr&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; EBX now points to the string<br />&nbsp; TEST&nbsp; &nbsp; DWORD PTR  , 000000FFh&nbsp;  ; See if the string is null<br />&nbsp; JE&nbsp; &nbsp; &nbsp; @@__EP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Jump to ... if yes<br />&nbsp; TEST&nbsp; &nbsp; DWORD PTR  , 0000FF00h&nbsp;  ; See if the string has one character<br />&nbsp; JE&nbsp; &nbsp; &nbsp; @@__EP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Jump to ... if yes<br />&nbsp; MOV&nbsp; &nbsp;  ESI , EBX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; ESI is a copy of the string<br />&nbsp; @@__FindEndStr:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Find the end of the string now<br />&nbsp; &nbsp; INC&nbsp; &nbsp;  EBX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Navigate one byte forward<br />&nbsp; &nbsp; TEST&nbsp; &nbsp; DWORD PTR  , 000000FFh ; See if the current byte is zero<br />&nbsp; &nbsp; JNE&nbsp; &nbsp;  @@__FindEndStr&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Keep doing this if not<br />&nbsp; DEC&nbsp; &nbsp;  EBX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Move back before the null-terminator<br />&nbsp; MOV&nbsp; &nbsp;  ECX , EBX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; ECX is now where the end of the string is<br />&nbsp; SUB&nbsp; &nbsp;  ECX , ESI&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Subtract the start from the end (Length)<br />&nbsp; INC&nbsp; &nbsp;  ECX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Minus one byte<br />&nbsp; SHR&nbsp; &nbsp;  ECX , 01h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Length divided by two<br />&nbsp; @@__Reverse:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Reverse the string now<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  AL , BYTE PTR &nbsp; &nbsp; &nbsp; &nbsp;  ; Read one byte from the end<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  AH , BYTE PTR &nbsp; &nbsp; &nbsp; &nbsp;  ; Read one byte from the beginning<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  BYTE PTR  , AH&nbsp; &nbsp; &nbsp; &nbsp;  ; Left byte to the right byte<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  BYTE PTR  , AL&nbsp; &nbsp; &nbsp; &nbsp;  ; Right byte to the left byte<br />&nbsp; &nbsp; LEA&nbsp; &nbsp;  ESI , &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Move one byte forward in ESI<br />&nbsp; &nbsp; LEA&nbsp; &nbsp;  EBX , &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Move one byte back in EBX<br />&nbsp; &nbsp; DEC&nbsp; &nbsp;  ECX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Decrement the counter<br />&nbsp; &nbsp; JNE&nbsp; &nbsp;  @@__Reverse&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Keep doing this until CX!=0<br />&nbsp; @@__EP:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; End of the procedure routine<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  ESI&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Restore the source index<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  EBX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Restore the base index<br />&nbsp; RET&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Return to the calling procedure<br />StrReverse ENDP</span></pre><br /><br />Hope i could help, good luck.</div>
    <div class="meta">Posted on 2006-09-29 13:50:00 by XCHG</div>
   </div>
   <div class="post" id="post-185665">
    <div class="subject"><a href="#post-185665">Re: Negative Offsets?</a></div>
    <div class="body">Thanks XCHG.&nbsp; That&#39;s pretty much the same code as I had for my own procedure, although I forgot to include any minimum length checking, so I&#39;m glad I read your post!&nbsp; Using the <strong>lea</strong> instruction is a good idea too, i&#39;ll use that one!</div>
    <div class="meta">Posted on 2006-10-02 23:15:03 by Timbo</div>
   </div>
  </div>
 </body>
</html>