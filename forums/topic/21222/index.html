<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Self-Modifying Code As Alternative to compile-time decisions? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=21222" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=21222">Self-Modifying Code As Alternative to compile-time decisions?</a></p>
   <div class="post" id="post-160621">
    <div class="subject"><a href="#post-160621">Self-Modifying Code As Alternative to compile-time decisions?</a></div>
    <div class="body">Hi everybody :)<br /><br />It&#39;s been so long since I&#39;ve been here (I visit this forum? regularily, though passively!).<br /><br />If some of you would remember, 14 months ago, I announced? that I designed a <strong>Digital Signal Processing library? (FFT, Filtering, &amp; IFFT)</strong> mainly (but not necessarily)? for audio.<br /><br />Since then, I kept enhancing it (for example:? <strong>supporting mono/stereo, supporting more data types, &amp;? simplifying usage in the same time</strong>). And I started? updating the documentation. <br /><br />The problem I faced is the <strong>large number of? functions</strong> that I had to design to support many? datatypes (16-bit &amp; 32-bit PCM, 32-bit &amp; 64-bit float).<br />(I made these changes , but still didn&#39;t upload the new? version on my humble web page <a target="_blank" href="http://geocities.com/johnkirollos">http://geocities.com/johnkirollos</a>.)<br /><br />Recently, I started thinking of using self-modifying code? to reduce nb of functions, by adding 1 arg specifying the? data types ==&gt; at start of function, instructions affected? by type are modified. (example: choosing between <strong>FLD? &lt;double_var&gt;</strong> &amp; <strong>FLD &lt;float_var&gt;</strong>.<br /><br />Here is the current list of functions:<br /><pre><code><br /><strong>1- 256-pts functions:</strong><br /><br />FFTSignal_256_fi_f32<br />FFTSignal_256_fi_f64<br />FFTSignal_256_i16<br />FFTSignal_256_i32<br /><br />FFT2Signals_256_fi_f32<br />FFT2Signals_256_fi_f64<br />FFT2Signals_256_i16<br />FFT2Signals_256_i32<br /><br />FilterSignal_256_fi_f32<br />FilterSignal_256_fi_f64<br />FilterSignal_256_fio_f32<br />FilterSignal_256_fio_f64<br />FilterSignal_256_fo_i16<br />FilterSignal_256_fo_i32<br />FilterSignal_256_i16<br />FilterSignal_256_i32<br /><br />Filter2Signals_256_fi_f32<br />Filter2Signals_256_fi_f64<br />Filter2Signals_256_fio_f32<br />Filter2Signals_256_fio_f64<br />Filter2Signals_256_fo_i16<br />Filter2Signals_256_fo_i32<br />Filter2Signals_256_i16<br />Filter2Signals_256_i32<br /><br />IFFT_256_fo_f32<br />IFFT_256_fo_f64<br />IFFT_256_i16<br />IFFT_256_i32<br /><br />FIR_OverlapSave_256_i16<br />FIR_OverlapSave_256_i32<br /><br /><strong>2- 1024-pts functions:</strong><br /><br />FFTSignal_1024_fi_f32<br />FFTSignal_1024_fi_f64<br />FFTSignal_1024_i16<br />FFTSignal_1024_i32<br /><br />FFT2Signals_1024_fi_f32<br />FFT2Signals_1024_fi_f64<br />FFT2Signals_1024_i16<br />FFT2Signals_1024_i32<br /><br />FilterSignal_1024_fi_f32<br />FilterSignal_1024_fi_f64<br />FilterSignal_1024_fio_f32<br />FilterSignal_1024_fio_f64<br />FilterSignal_1024_fo_i16<br />FilterSignal_1024_fo_i32<br />FilterSignal_1024_i16<br />FilterSignal_1024_i32<br /><br />Filter2Signals_1024_fi_f32<br />Filter2Signals_1024_fi_f64<br />Filter2Signals_1024_fio_f32<br />Filter2Signals_1024_fio_f64<br />Filter2Signals_1024_fo_i16<br />Filter2Signals_1024_fo_i32<br />Filter2Signals_1024_i16<br />Filter2Signals_1024_i32<br /><br />IFFT_1024_fo_f32<br />IFFT_1024_fo_f64<br />IFFT_1024_i16<br />IFFT_1024_i32<br /><br />FIR_OverlapSave_1024_i16<br />FIR_OverlapSave_1024_i32<br /></code></pre><br /><br />As you see, the list is BIG! I gess using SMC would reduce? nb of functions (&amp; hence code size by more than 75%)<br /><br /><strong>So, is SMC generally used for such purpose? I never? used SMC, so should I go for it or not?</strong> </div>
    <div class="meta">Posted on 2005-05-30 17:52:12 by John Kiro</div>
   </div>
   <div class="post" id="post-160622">
    <div class="subject"><a href="#post-160622">Re: Self-Modifying Code As Alternative to compile-time decisions?</a></div>
    <div class="body">I think &quot;runtime code generation&quot; is a better term for this than SMC (which is more like patching a few locations). SMC also tends to do modifications multiple times, while RCG tends to construct procedures at the beginning of the program.<br /><br />It&#39;s a good method when you have a lot of similar routines... You might want to have a look at http://softwire.sourceforge.net/</div>
    <div class="meta">Posted on 2005-05-30 18:19:29 by f0dder</div>
   </div>
   <div class="post" id="post-160648">
    <div class="subject"><a href="#post-160648">Re: Self-Modifying Code As Alternative to compile-time decisions?</a></div>
    <div class="body">Thanks fOdder for clarifying the concept :)<br /><br />So.. what I&#39;m thinking of is not a bad thing to do.. I can&#39;t wait to see the outcome of going RCG :D<br /><br />I downloaded SoftWire to see if it can help!&nbsp; </div>
    <div class="meta">Posted on 2005-05-31 18:53:15 by John Kiro</div>
   </div>
   <div class="post" id="post-160649">
    <div class="subject"><a href="#post-160649">Re: Self-Modifying Code As Alternative to compile-time decisions?</a></div>
    <div class="body"><div class="quote"><br />So.. what I&#39;m thinking of is not a bad thing to do..<br /></div><br />Indeed not - the thing to avoid is constantly moldifying + calling code, that is pretty foo.<br /><br />Also, be sure to allocate buffers with VirtualAlloc and the PAGE_EXECUTE_READWRITE protection type (possibly setting to PAGE_EXECUTE_READ or PAGE_EXECUTE when the code is constructed); if you don&#39;t do this, you will get protection errors on AMD64 or P4-64 computers.<br /></div>
    <div class="meta">Posted on 2005-05-31 19:01:15 by f0dder</div>
   </div>
   <div class="post" id="post-160650">
    <div class="subject"><a href="#post-160650">Re: Self-Modifying Code As Alternative to compile-time decisions?</a></div>
    <div class="body"><strong>fOdder Wrote:</strong><br /><div class="quote"><br />Also, be sure to allocate buffers with VirtualAlloc and the PAGE_EXECUTE_READWRITE protection type (possibly setting to PAGE_EXECUTE_READ or PAGE_EXECUTE when the code is constructed); if you don&#39;t do this, you will get protection errors on AMD64 or P4-64 computers.</div><br /><br />What I&#39;m intending to do is just modifying an <strong>fld</strong> with <strong>fild</strong> for example. That is, I&#39;m not gonna add new functions at runtime, just modifying a couple of bytes in an already existing function (most probably the current one). A typical DSP function takes thousands of clocks to execute, so I gess adding a few cycles to make these modifications won&#39;t heart, specially if modified parts are far from the modification point.. <br />Or I am missing something?</div>
    <div class="meta">Posted on 2005-05-31 19:22:01 by John Kiro</div>
   </div>
   <div class="post" id="post-160651">
    <div class="subject"><a href="#post-160651">Re: Self-Modifying Code As Alternative to compile-time decisions?</a></div>
    <div class="body">If you only need to patch some bytes (ie, no opcode length change), softwire is probably overkill; I would then suggest having a &quot;template&quot; routine, which you copy to VirtualAlloc&#39;ed memory and patch modifications.<br /><br />You could construct all the needed routines at program startup, or create them on-the-fly as necessary. If there are many routines and you won&#39;t always need all of them, I would probably create them on-the-fly but keep each routine after it&#39;s constructed.<br /><br />You could call the DSP routines via pointer indirection; initially, the pointers would be to stub functions that create the necessary routine, then change the pointer to point to the newly created routine... that ought to work fairly well.<br /><br /><br /><div class="quote"><br />so I gess adding a few cycles to make these modifications won&#39;t heart, specially if modified parts are far from the modification point..<br /></div><br />Testing will show :) - but mixing data/code and pipeline flushes are typically pretty expensive.<br /></div>
    <div class="meta">Posted on 2005-05-31 19:28:25 by f0dder</div>
   </div>
   <div class="post" id="post-160654">
    <div class="subject"><a href="#post-160654">Re: Self-Modifying Code As Alternative to compile-time decisions?</a></div>
    <div class="body">Thanks again fOdder,<br /><br />I&#39;ll start by making some experiments &amp; speed testing. Then other questions may arise. </div>
    <div class="meta">Posted on 2005-05-31 20:49:24 by John Kiro</div>
   </div>
   <div class="post" id="post-160704">
    <div class="subject"><a href="#post-160704">Re: Self-Modifying Code As Alternative to compile-time decisions?</a></div>
    <div class="body">Hi again,<br /><br />After some searches on this board (which is a treasure BTW:)), I made a test lib to investigate the effect of SMC, concerning my idea.<br /><br />The library contains 2 functions: <strong>SinTable_real4() &amp; SinTable_real8()</strong>. The 1st replaces a table of real4 by their sin (Array=sin(Array) ), the 2nd is the same but with real8.<br /><br />Here are C-style functions declaration:<br /><pre><code><br />SinTable_real4(dword pTable, dword iCount);<br />SinTable_real8(dword pTable, dword iCount);<br /></code></pre><br /><br />My idea was to combine the 2 functions into 1 for the following benefits:<br /><strong>1- Reducing code size.<br />2- Having only 1 function whose name is simply SinTable() (I named it SinTable_SMC() in my test lib).<br /></strong><br /><br />To achieve this, an extra argument is passed to function:<br /><pre><code><br />SinTable_SMC(dword pTable, dword iCount,dword iType);<br /></code></pre><br /><strong>iType</strong>=1 (choosing real4), or 2 (choosing real8).<br /><br />This function has a piece of code at its start, that writes the instructions affected by data type. In this example function, they are:<br /><strong>fld mem</strong>, <strong>fstp mem</strong>, &amp; <strong>add eax,&lt;size&gt;</strong> (incrementing pointer to next element).<br /><br />So, I tested speed of both normal, &amp; SMC functions, for several iCount (array length) <strong>on a P4 CPU</strong>.<br /><br />My conclusion is:<br />---------------<br /><strong>Modifying the code adds an overhead of about 1000 clocks.</strong> <br />For example: array length=200:<br />SinTable_real4()? ----&gt; average=26,344 clocks<br /><br />SinTable_SMC() with iType=1 ----&gt; average=27,486 clocks<br /><br />For array length of 1000, the difference is still around 1000 clocks. <br /><br /><strong>So, may we say that SMC costs about 1000 clocks on P4? And would this value depend on distance between patching &amp; patched code? &amp; is better or worse on previous processors?</strong><br /><br />Then, to minimize the number of times the function would have to modify the code, I used a global variable called <strong>iLastType</strong>, that holds 1 if currently the function is for real4, &amp; 2 if real8. <br />So, if for example I call SinTable_SMC() with iType=1,<br />iType is compared to iLastType, if they&#39;re equal, no need for code modification. =&gt; for example, when calling it 100 consecutive times with same data type, only the 1st time execution suffers a 1000 clocks overhead.<br /><br />So, <strong>in what cases could this approach be most beneficial?</strong><br /><br />I think the answer could be the following conditions:<br /><strong><br />- Number of functions needed is large otherwise :</strong><br />Consider supporting <strong>word, dword, real4, real8</strong>, i.e. 4 functions. (in my DSP lib, each function deals with more than 1 type =&gt;large set of functions - see list at start of this topic)<br /><br /><strong><br />- Needed code modification is minor compared to the function itself so that patching code is small compared to whole function:</strong><br />For example: <strong>fld --&gt; Lengthy processing on FPU stack (independent of type) --&gt; fst</strong>.<br />=&gt; only fld &amp; fst need modification.<br /><br /><strong><br />- Function clocks is &gt;&gt;1000 clocks (for P4).</strong><br /><br /><strong><br />- Type needs not be changed frequently:</strong><br />For example, FFT algorithm is usually performed in a loop to process a long audio signal, =&gt;modification occurs only? in the 1st loop iteration.<br /><br />About the possible disadvantages:<br /><br />1- Code is writable, =&gt; Virtual memory system treats it as data (<strong>swapped to disk rather than discarded</strong>). But I think this won&#39;t have a pronounced effect.<br /><br />2- <strong>Some bad pointer bugs can&#39;t be easily discovered</strong> (no exception received on writing to code by mistake) since code is writable. But I see we can minimize this by not? making the whole code writable, just the SMC functions.<br /><br />3- Such <strong>function can&#39;t be called from 2 different threads simultaneously (unless both threads are using same data types, i.e same code)</strong>.<br />(I think this is not a big problem, since you usually won&#39;t use same code in both GUI &amp; worker threads).<br /><br /><strong><br />Finally, those are my conclusions after a very short research, experience, &amp; testing (2 days). So what do you think about it? If someone has experience in this issue, if something is wrong/not precise in my idea, assumptions &amp; conclusions, it&#39;d be helpful to comment.</strong><br /><br />Note: I attached the lib (a RadASM project) - I didn&#39;t include the speed tests coz they&#39;re in Sphinx C--.<br /><br />Sorry for this long thread! I hope it could be useful to others :)<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=656" target="_blank">SMCTestLib.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2005-06-02 06:02:18 by John Kiro</div>
   </div>
   <div class="post" id="post-160706">
    <div class="subject"><a href="#post-160706">Re: Self-Modifying Code As Alternative to compile-time decisions?</a></div>
    <div class="body">Nice research, and your conclusions seem okay :)<br /><br />Disadvantages 2 and 3 can be avoided with a just-in-time/caching scheme; #2 would be avoided by VirtualAlloc/write-and-patch/VirtualProtect, and #3 would be avoided by some smart CriticalSection protection of the *first* time a routine is called (ie, when the thunk generates the real code).<br /></div>
    <div class="meta">Posted on 2005-06-02 06:17:43 by f0dder</div>
   </div>
   <div class="post" id="post-160728">
    <div class="subject"><a href="#post-160728">Re: Self-Modifying Code As Alternative to compile-time decisions?</a></div>
    <div class="body"><strong>fOdder Said:</strong><br /><div class="quote">#3 would be avoided by some smart CriticalSection protection of the <strong>*first*</strong> time a routine is called</strong> , when the thunk generates the real code).</div><br /><br />Thanks fOdder again :),<br /><br />But the bold part in the quote needs just be changed to &quot;*first* time a routine is called with code change request (different data type(s)&quot;<br /><br />So, I think I&#39;m going to try the approach on some &quot;real&quot; function..<br /><br /></div>
    <div class="meta">Posted on 2005-06-03 06:21:23 by John Kiro</div>
   </div>
   <div class="post" id="post-160733">
    <div class="subject"><a href="#post-160733">Re: Self-Modifying Code As Alternative to compile-time decisions?</a></div>
    <div class="body"> Not to burst your bubble with all the research you have done.&nbsp; But have you considered using Macros to do this instead??? MASM has a very powerful set of Macros that can let you do stuff like specifying a variable type and then doing conditional or non-conditional assembly on it.&nbsp; Plus it&#39;s a lot easier than this approach.</div>
    <div class="meta">Posted on 2005-06-03 09:40:56 by mark_larson</div>
   </div>
   <div class="post" id="post-160734">
    <div class="subject"><a href="#post-160734">Re: Self-Modifying Code As Alternative to compile-time decisions?</a></div>
    <div class="body">Just an idea. What if you use two procedures?. One is the main procedure, and the other is used to setup the main procedure.<br /><br />Example:&nbsp; SinTable_set(type) and&nbsp; SinTable_SMC(ptable,iCount)<br /><br />In SinTable_set(type) you modify the SinTable_SMC code. You can set the section writable or not after procedure modification. This can be useful in case where the type is not going to be modified for a while. <br /><br />Example: changing type because of user preferences, PC resources (processor characteristics, available memory), etc.<br /><br />This idea can be used in cases like this:<br /><br /><pre><code>SinTable_set(1)<br />SinTable_SMC(...)<br />SinTable_SMC(...)<br />SinTable_SMC(...)<br />SinTable_set(2)<br />SinTable_SMC(pTable_1, iCount_1)<br />SinTable_SMC(pTable_2, iCount_2)<br />...<br />...<br />SinTable_SMC(pTable_n, iCount_n)<br />SinTable_set(x)<br />...</code></pre><br /><br />Like example shows, this idea can not be aplied in all cases (but it can be useful in others).<br />This was just an idea (that can be considered or not). It is similar to yours, but you don&#39;t have to pass data type to main procedure in every call (and you don&#39;t have to make data type checking in it). But brings programming problems like: What was the last data type used? Programer using the lib can call the procedure with invalid data type if he is distracted (I hope that this idea not distract and confuse more the thing).<br /><br />Regards.<br /><br />Kecol.-<br /><br />Mark, I think he need all the functions in the lib, and that is the &quot;why&quot; he is not considering use of macros</div>
    <div class="meta">Posted on 2005-06-03 10:33:44 by Kecol</div>
   </div>
   <div class="post" id="post-160737">
    <div class="subject"><a href="#post-160737">Re: Self-Modifying Code As Alternative to compile-time decisions?</a></div>
    <div class="body"><div class="quote"><br />Mark, I think he need all the functions in the lib, and that is the &quot;why&quot; he is not considering use of macros<br /></div><br /><br />&nbsp; The macros would be in the library as well.</div>
    <div class="meta">Posted on 2005-06-03 11:50:19 by mark_larson</div>
   </div>
   <div class="post" id="post-160766">
    <div class="subject"><a href="#post-160766">Re: Self-Modifying Code As Alternative to compile-time decisions?</a></div>
    <div class="body"><strong>Mark Larson Said:</strong><br /><br /><div class="quote"><br />But have you considered using Macros to do this instead??? MASM has a very powerful set of Macros that can let you do stuff like specifying a variable type and then doing conditional or non-conditional assembly on it.? Plus it&#39;s a lot easier than this approach.<br /></div><br /><br />I&#39;m already using Macros in current design &amp; this has 4 disadvantages (concerning my case):<br /><br />1- Library code size is large. Many functions are almost identical except for some few instructions or constant values.<br /><br />2- Many Functions with names hard to remember.<br /><br />3- <strong>FFT length</strong> parameter is currently a compile-time constant. I had to do this due to the limited number of registers. So, I had to make a function for each FFT length (64, 256, 1024, ...) ==&gt; Nb of functions becomes huge, &amp; so becomes the library size!<br /><br />To demonstrate the lack of registers, consider (If you have time:)) this macro invokation taken from a loop body:<br /><br /><pre><code><br />Butterfly_LastLevel_RealOut	,,\<br />	,,\<br />	,,,<br /></code></pre><br /><br />It uses 5 registers out of the 7 available. EAX &amp; ECX are also used in other purposes in the loop. <br />(In this macro, I could have not used EBX, &amp; add its value to EBP instead, but EBX is also used for loop termination (when EBX==0), ==&gt; a CMP instruction is saved. <br /><br />4- <strong>Number of channels</strong> (Mono, Stereo, ...) is a parameter that user passes to function. This adds complexity &amp; consequently registers/mem vars are required in loops, =&gt;again, speed loss! So, if number of channels is determined at compile-time, we can free some registers for other use. <strong>==&gt; we can gain some speed-up that may outweight speed loss by SMC, specially if we don&#39;t modify code all the time.</strong><br /><br /><br />Concerning how easy is this approach compared to using macros, I made a list of all parts that would be affected by using SMC, they are all just a single instruction, or a single constant. And there are few of them.<br /><br /><strong>But I still don&#39;t want to jump to conclusions so fast, specially since I never used SMC before!</strong><br /><br /><div class="quote"><br />Just an idea. What if you use two procedures?. One is the main procedure, and the other is used to setup the main procedure.<br /><br />Example:? SinTable_set(type) and? SinTable_SMC(ptable,iCount)<br /><br />In SinTable_set(type) you modify the SinTable_SMC code. You can set the section writable or not after procedure modification. This can be useful in case where the type is not going to be modified for a while.<br /></div><br /><br />I see your idea is good Kecol. But as you said it has a down side in that it leaves the duty of checking wether modification is needed now or not to the function user. So, he&#39;d either call the 2 functions as a pair all the time, or checks 1st:<br /><br /><pre><code><br />IF(type changed)<br />	SinTable_Set(x)<br />ENDIF<br /><br />SinTable_SMC(...)<br /></code></pre><br /><br />I&#39;ll keep it in mind anyway :)<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2005-06-04 07:40:53 by John Kiro</div>
   </div>
   <div class="post" id="post-162874">
    <div class="subject"><a href="#post-162874">Re: Self-Modifying Code As Alternative to compile-time decisions?</a></div>
    <div class="body">Hi. If you would sacrifice the code size maybe you can use pointers to functions, i.e. you have a table of all available functions and a table of functions used for only one data type, and you init that table at the startup or when needed.<br /><br />Ex:<br /><br />allfuncs:<br />SinTable4<br />SinTable8<br />CosTable4<br />CosTable8<br />...<br /><br /><br />singlyfuncs: ; used in code<br />SinTable dd SinTable4<br />CosTable dd CosTable8<br />...<br /><br />Code always uses functions from singlyfuncs:<br />invoke SinTable, ...<br /><br />And by user input you can change the contents of the functions.</div>
    <div class="meta">Posted on 2005-08-06 05:00:28 by inFinie</div>
   </div>
  </div>
 </body>
</html>