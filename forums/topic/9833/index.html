<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Frustration takes a new kinda low... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=9833" />
    <link rel="next" href="../?id=9833&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=116">Windows</a> &raquo; <a href="../?id=9833">Frustration takes a new kinda low...</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=9833&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=9833&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="9833" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=9833&amp;page=2">&gt;</a><a href="../?id=9833&amp;page=2">&raquo;</a></form>   <div class="post" id="post-73205">
    <div class="subject"><a href="#post-73205">Frustration takes a new kinda low...</a></div>
    <div class="body">Ok..  In short, does anyone have any experience in working with PASCAL calling convenetions with COM interfaces?<br /><br />I've been having bitter luck with M$ Excel's automation interfaces.  I have sample code, i have the typelib converted (thanx to Japheth), I have the IDL.. it should be a walk in the coding-park.  But its not. <br /><br />I managed to get the Excell server running, and added a new workbook.  But that is it.  Trying to 'GET' any cell data is not working at all, and i have no clue what the M$ HLL Apps do behinde the sceens (will explain in a bit).<pre><code>void CExcelCtrlDlg&#58;&#58;OnButton1&#40;&#41; <br />&#123;<br />	int i,j;<br />	CString ssbuf;<br />	COleVariant x;<br />	COleVariant y;<br />	COleVariant data;<br />	COleVariant ItemId;<br />	_Application pApp;  <br />	_Application pXlsApp;<br />	Workbooks pXlsBooks;<br />	Range pXlsRange;<br /><br />	pXlsApp.CreateDispatch&#40;&quot;Excel.Application&quot;&#41;;		<br />	pXlsApp.SetVisible&#40;TRUE&#41;;<br />	<br />	LPDISPATCH pWkBooks = pXlsApp.GetWorkbooks&#40;&#41;;	   <br />	pXlsBooks.Add&#40;&#41;;					<br />	<br />	LPDISPATCH pCells = pXlsApp.GetCells&#40;&#41;;				<br />	pXlsRange.AttachDispatch&#40;pCells,TRUE&#41;;<br /><br />&#91;b&#93;	y = &#40;short&#41;1;<br />	x = &#40;short&#41;1;<br />	ItemId = pXlsRange.GetItem&#40;y,x&#41;;						<br />	pApp.AttachDispatch&#40;ItemId.pdispVal,TRUE&#41;;<br />	ssbuf = pApp.GetValue&#40;&#41;;p&#91;/b&#93;   <br />   ...<br />&#125;</code></pre><br /><br />Here is my ASM version. Note that _Application, Workbooks, and Range above are wrapper classes to the interfaces (of the same name) im accessing direclty below:<br /><pre><code>       mov vb, TRUE       <br />       ;HRESULT Visible&#40;&#91;in, lcid&#93; long lcid, &#91;in&#93; VARIANT_BOOL RHS&#41;;<br />       invoke vf&#40;pIExcelApp, _Application ,put_Visible&#41;, NULL, vb<br />       <br />       ;HRESULT Workbooks&#40;&#91;out, retval&#93; Workbooks** RHS&#41;;<br />       invoke vf&#40;pIExcelApp, _Application ,get_Workbooks&#41;, addr WBKS<br />       <br />       ;HRESULT Add&#40; &#91;in, optional&#93; VARIANT Template, &#91;in, lcid&#93; long lcid, &#91;out, retval&#93; Workbook** RHS&#41;;<br />       mov VTEMP, $NEW&#40; VRNT &#41;<br />       invoke vf&#40;WBKS, Workbooks ,Add_&#41;, VARIANT PTR &#91;eax&#93;.VRNT.Var, NULL, addr WBK<br />       DESTROY VTEMP<br />       <br />       ;LPDISPATCH pCells = pXlsApp.GetCells&#40;&#41;;	<br />       invoke vf&#40;pIExcelApp, _Application ,get_Cells&#41;, addr RNG</code></pre><br />This is what DOES work, beyond it fails:<br /><pre><code>       ;ItemId = pXlsRange.GetItem&#40;&#40;short&#41; y,&#40;short&#41; x&#41;;	<br />       .data<br />         VVA VARIANT &lt;2,0,0,0,&lt;2&gt;&gt;<br />         VVB VARIANT &lt;2,0,0,0,&lt;4&gt;&gt;<br />         VVC VARIANT &lt;0,0,0,0,&lt;0&gt;&gt;<br />         ddata db 0ch,20h,0ch,20h,0<br />       .code<br />       <br />       mov ebx, esp<br />       PrintHex esp<br />&#91;b&#93;       invoke vf&#40;RNG, IRange, get_Item&#41;, addr lpVar, VVA, VVB, addr VVC&#91;/b&#93;  ;; PROBLEM HERE<br />       PrintHex eax<br />       PrintHex esp<br />       mov esp, ebx</code></pre><br /><br />There problem, as im tracking it, is that there is 'optional' VARIANT arguments, thus the STDCALL doesnt work if you dont provide all arguments, so im assuming its taking on a PASCAL calling convention. Here is my reasons:<br />1)  The C++ Wrapper interface defines such:<pre><code>VARIANT Range&#58;&#58;GetItem&#40;const VARIANT&amp; RowIndex, const VARIANT&amp; ColumnIndex&#41;<br />&#123;<br />	VARIANT result;<br />	static BYTE parms&#91;&#93; =<br />		VTS_VARIANT VTS_VARIANT;<br />	InvokeHelper&#40;0xaa, DISPATCH_PROPERTYGET, VT_VARIANT, &#40;void*&#41;&amp;result, parms,<br />		&amp;RowIndex, &amp;ColumnIndex&#41;;<br />	return result;<br />&#125;</code></pre>Where <strong>InvokeHelper</strong> is in the CoreSDK as:<pre><code>	void AFX_CDECL InvokeHelper&#40;DISPID dwDispID, WORD wFlags,<br />		VARTYPE vtRet, void* pvRet, const BYTE* pbParamInfo, ...&#41;;</code></pre>2) The stack is NOT being cleane up even after a suscessful call (no crashes, hresult == 0).  This is why im looking at the ESP and manually fixing it.<br /><br />The other problem is this Byte Array busines &quot;params&quot;, which like wsprintf, indicates how many params are to follow.  The reason its a problem is the transcribed typelib has no such indications of any of this:<br /><pre><code>;HRESULT _stdcall Item&#40; &#91;in&#93; VARIANT RowIndex, &#91;in, optional&#93; VARIANT ColumnIndex, <br />;                       &#91;in, lcid&#93; long lcid,  &#91;out, retval&#93; VARIANT* RHS&#41;;<br />STDMETHOD	get_Item	, &#58;VARIANT, &#58;VARIANT, &#58;SDWORD, &#58;ptr VARIANT</code></pre><br />I know its a problem, cause follwing the transcribed type lib to It crashes internally, cause the first Variant (RowIndex) pushes its variant type first (2), followed by 12 other bytes for it.  OllyDbg'n this i traced it thru and found out its trying to used this first push as a <strong>pInterface</strong> and when accessing address '00000002' its crashes.  So the typelib it wrong (not your fault Japheth!).  I checked VC++'s typelib tool and it gave the EXACTLY SAME MISLEADING INFORMATION!.  So i manually buggered around with the params and tryied to follow (as best as i can) to the wrapper definition and discovered that its more like:<pre><code>STDMETHOD	get_Item	, &#58;ptr ReturnVar, lpByteArgList&#58;DWORD, &#58;VARIANT , &#58;VARIANT </code></pre><br /><strong>When i try this, it doesnt crash, and returns a VARIANT NULL by the ReturnVal pointer param!!!</strong><br />HRESULT is = 00000000h! So things are better, but not great cause im still getting a null back!  I should be getting a Variant=Dispatch with a pInterface in its argument!<br /><br />So im stumped at this point.  Im trying to 'find the caramel secret' that MS had done.<br /><br />It makes sence to me that the parm ordering for PASCAL type com calls would be:<br />0)  lpTHIS intefvace  &lt;&lt; Always true<br />1)  Return Value   &lt;&lt;&lt; This is confirmed (outputs Variant NULL)<br />2)  AgrumentByteList  <br />3)  Optional Arguments <br /><br />Please Please Please Please Please Give any advice you can.  This is driving me nuts, as im sure you for trying to read all this and take it in.  I would be glad to clarify anything that is not clear to you above.<br />In the mean time, I dont expect many to respond, so im going to consult my texts on COM, but i doubt they will discuss the details im looking for (since they are all geared to MS VC++ and alike :rolleyes: )<br /><br />THanx for reading and putting up with me,<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-12-29 11:50:12 by NaN</div>
   </div>
   <div class="post" id="post-73208">
    <div class="subject"><a href="#post-73208">Frustration takes a new kinda low...</a></div>
    <div class="body">NaN,<br /><br />Im not so good at english so it may cost me a week or so to translate your novel. But 2 things I have understood so far:<br /><br />- be careful if an argument is of VARIANT type. If it is a true VARIANT (not a &quot;ptr VARIANT&quot;), you may need to push 4 DWORD on the stack, the arguments size is 16 bytes!<br /><br />- optional parameters are valid for IDispatch::Invoke only. If you call the function directly throu vtable, you must supply all parameters. The optional ones, it they are VARIANTS, should have a special type/content if they arent supplied (think its VT_EMPTY or VT_ERROR, cant remember exacly).</div>
    <div class="meta">Posted on 2002-12-29 12:41:40 by japheth</div>
   </div>
   <div class="post" id="post-73209">
    <div class="subject"><a href="#post-73209">Frustration takes a new kinda low...</a></div>
    <div class="body">How many &quot;optional&quot; arguments?  Can you pass a NULL for each optional arg you don't want to use?  The callee should check the optional arg list to see which ones are used, no?  So, if you want to pass arg 2 out of three, shouldn't you pass NULL, Something, NULL and the callee will sort that out?<br /><br />Me thinks NaN is going to pull the rest of the hair outta the head tring to work with this. :grin:</div>
    <div class="meta">Posted on 2002-12-29 12:45:51 by Gunner</div>
   </div>
   <div class="post" id="post-73210">
    <div class="subject"><a href="#post-73210">Frustration takes a new kinda low...</a></div>
    <div class="body"><div class="quote"><br />- optional parameters are valid for IDispatch::Invoke only. If you call the function directly throu vtable, you must supply all parameters. The optional ones, it they are VARIANTS, should have a special type/content if they arent supplied (think its VT_EMPTY or VT_ERROR, cant remember exacly). </div><br /><br />Ok.. this fits with what I've learnt (and expected, up to now).  So there is two questions then.  Does anyone know what goes on inside the InvokeHelper API??  Is there a Link between this mysterious LCID:SDWORD param and the bytestring 'PARAMS' used to indicate the # of arguments used.<br /><br />Secondly, why is the vtable interface then not cleaning up the stack? And why is it writing over the first (RolIndex = VT_I2) to the first VARAINT instead of reading it.<br /><br />If you like, i can zip up my information, and sample code.<br />Thanks for your initial thoughts... i look forward to when you 'transcribe my novel ;) ', and have more to say...<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-12-29 12:52:06 by NaN</div>
   </div>
   <div class="post" id="post-73211">
    <div class="subject"><a href="#post-73211">Frustration takes a new kinda low...</a></div>
    <div class="body"><div class="quote"><br />How many &quot;optional&quot; arguments?  Can you pass a NULL for each optional arg you don't want to use?  The callee should check the optional arg list to see which ones are used, no?  So, if you want to pass arg 2 out of three, shouldn't you pass NULL, Something, NULL and the callee will sort that out?<br /><br />Me thinks NaN is going to pull the rest of the hair outta the head tring to work with this. :grin: </div><br /><br />I have..  this has been the most challenging project i've even worked on.  Dam M$ and their screwball ways ;)<br /><br />The Autocad interfaces were a walk in the park compared to this.  It just doens make sence, and nothing is painting the complete 'correct' picture.  Im getting the feeling to use excel interfaces you have to use the DISPACTH Inovke methods explicitly as the above wrapper class method does.<br /><br />:nan:</div>
    <div class="meta">Posted on 2002-12-29 12:55:53 by NaN</div>
   </div>
   <div class="post" id="post-73212">
    <div class="subject"><a href="#post-73212">Frustration takes a new kinda low...</a></div>
    <div class="body">Here is the example C++ im working with.  Its commented in Russian, but C++ language speaks for itself anyways...  You can see the wrapper classses and how its being used</div>
    <div class="meta">Posted on 2002-12-29 12:58:04 by NaN</div>
   </div>
   <div class="post" id="post-73218">
    <div class="subject"><a href="#post-73218">Re: Frustration takes a new kinda low...</a></div>
    <div class="body"><div class="quote"><em>Originally posted by NaN </em><br />[...]<br />Where <strong>InvokeHelper</strong> is in the CoreSDK as:<pre><code>	void AFX_CDECL InvokeHelper&#40;DISPID dwDispID, WORD wFlags,<br />		VARTYPE vtRet, void* pvRet, const BYTE* pbParamInfo, ...&#41;;</code></pre><br /></div><br />Are you sure it's in the coreSDK? I couldn't find it and when I traced the code you were talking about in the C++ example it traced through COleDispatchDriver::InvokeHelper in the MFC source code. So I don't think it's an API, just an MFC helper method. Also, AFX_CDECL gives the suspicion that the function is just a normal C function (using C calling convention), with ... to indicate a variable number of parameters. The usage of va_list/va_start/va_end inside that function confirms this.<br /><br />Hope this helps &amp; good luck ;)<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-12-29 13:25:38 by Thomas</div>
   </div>
   <div class="post" id="post-73223">
    <div class="subject"><a href="#post-73223">Frustration takes a new kinda low...</a></div>
    <div class="body">You are correct.. I did a 'FindFile' search in the CoreSDK directory... but i didnt pay attention to which dir it pulled it out of.. i simply opened it in UltraEdit and Searched for the 'InvokeHelper' in the file.  This leads directly to what your mentioned. (my bad).<br /><br />Ok. So its MFC that this example is using.  So i should ignore it and try and find a pure C++ example then?  With out MFC, to see how to properly use these interfaces?  Cause im still puzzled why the interface writes 'out' to an 'in' param (RowIndex:VARIANT).<br /><br />Thank you for correcting me here.. im going to abandon all trust in this source..<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-12-29 13:53:29 by NaN</div>
   </div>
   <div class="post" id="post-73229">
    <div class="subject"><a href="#post-73229">Frustration takes a new kinda low...</a></div>
    <div class="body">Here is some knowledge base infor i just dug up..<br /><div class="quote">How do I pass optional parameters?<br /><br />Some methods have &quot;optional&quot; parameters. In Visual Basic, you can casually omit them when calling the method. However, when calling with Visual C++ you have to pass a special VARIANT whose .vt field is VT_ERROR, and .scode field is DISP_E_PARAMNOTFOUND. That is: <br />      // VARIANT used in place of optional-parameters.<br />      VARIANT varOpt;<br />      varOpt.vt = VT_ERROR;<br />      varOpt.scode = DISP_E_PARAMNOTFOUND;<br />						<br />This is really what Visual Basic is doing behind-the-scenes. </div><br /><br />And...<br /><pre><code>      LRESULT CClientDlg&#58;&#58;OnOK&#40;WORD wNotifyCode, WORD wID,<br />         HWND hWndCtl, BOOL&amp; bHandled&#41;<br />      &#123;<br />         IDispatch*  pDisp;   // Main IDispatch pointer.<br />         CLSID       clsid;   // Holds CLSID of server<br />         DISPID      dispID;  // Temporary variable to hold DISPIDs.<br />         HRESULT     hr;      // General error/result holder.<br /><br />         hr = CLSIDFromProgID&#40;L&quot;Excel.Application&quot;, &amp;clsid&#41;;<br />         if&#40;FAILED&#40;hr&#41;&#41;&#123;<br />            MessageBox&#40;&quot;Excel is not installed.&quot;&#41;;<br />            return 0;&#125;<br /><br />         hr = CoCreateInstance&#40;clsid, NULL, CLSCTX_LOCAL_SERVER,<br />            IID_IDispatch, &#40;void **&#41;&amp;pDisp&#41;;<br />         if&#40;FAILED&#40;hr&#41;&#41;&#123;<br /><br />            MessageBox&#40;&quot;Couldn't start Excel.&quot;&#41;;<br />            return 0;&#125;<br /><br />         OLECHAR    *szVisible = L&quot;Visible&quot;;<br />         DISPPARAMS dispParams = &#123; NULL, NULL, 0, 0 &#125;;<br />         DISPID dispidNamed = DISPID_PROPERTYPUT;<br />         CComVariant vrTrue = VARIANT_TRUE;<br /><br />         pDisp-&gt;GetIDsOfNames&#40;IID_NULL, &amp;szVisible, 1,<br />            LOCALE_USER_DEFAULT, &amp;dispID&#41;;<br /><br />         dispParams.cArgs = 1;<br />         dispParams.rgvarg = &amp;vrTrue;<br />         dispParams.cNamedArgs = 1;<br />         dispParams.rgdispidNamedArgs = &amp;dispidNamed;<br /><br />         // Set 'Visible' property to true.<br />         pDisp-&gt;Invoke&#40;dispID, IID_NULL, LOCALE_SYSTEM_DEFAULT,<br />            DISPATCH_PROPERTYPUT | DISPATCH_METHOD, &amp;dispParams,<br />            NULL, NULL, NULL&#41;;<br /><br />         MessageBox&#40;&quot;We're done.&quot;, &quot;Finish&quot;, MB_SETFOREGROUND&#41;;<br /><br />         // Release the IDispatch pointer before exit<br />         pDisp-&gt;Release&#40;&#41;;<br />         return 0;</code></pre><br /><br />Im getting the feeling that the only way around this mess is using the pDisp-&gt;Invoke method :rolleyes: .  It will be a lot of extra work, but i guess if i wrap it up in a MASM oop class for reuse it will pay off...<br /><br />Feeling defeated..<br />:nAn:</div>
    <div class="meta">Posted on 2002-12-29 14:52:04 by NaN</div>
   </div>
   <div class="post" id="post-73230">
    <div class="subject"><a href="#post-73230">Frustration takes a new kinda low...</a></div>
    <div class="body">I think the problem is interface &quot;Range&quot; or &quot;IRange&quot;, which you are using. Both are marked as &quot;dispatchable&quot;, but not as &quot;dual&quot;. So you cant be sure that there is a valid vtable at all. And if not, you have to call it throu IDispatch:Invoke (which I suggest is exactlly what Invokehelper does). To ensure that I would stop just before the call and look at the vtable of IRange. The first 7 entries are the IDispatch interface, no doubt. But what does follow?<br /><br />So you will have to code an Invokehelper vor IRange as well. Heres an example (1 parameter only):<br /><br /><pre><code><br />local dispparams&#58;DISPPARAMS<br />local rgvarg&#91;1&#93;&#58;VARIANT<br />local varResult&#58;VARIANT<br />;--------------------------------- set method/property ID &#40;here &quot;Visible&quot;&#41;<br />	mov dwIDs, 22Eh<br />;--------------------------------- init result variant<br />	invoke VariantInit, addr varResult<br />;--------------------------------- set dispparams<br /><br />	lea eax, rgvarg<br />	mov dispparams.rgvarg, eax <br />	mov dispparams.cArgs, 1<br /><br />	mov dwPropPutId, DISPID_PROPERTYPUT       ;alway needed for put property<br />	lea eax, dwPropPutId<br />	mov dispparams.rgdispidNamedArgs, eax<br />	mov dispparams.cNamedArgs, 1<br />	 <br />;--------------------------------- set property via invoke<br /><br />	invoke vf&#40;pDispatch, IDispatch, Invoke_&#41;, dwIDs, addr IID_NULL, LOCALE_SYSTEM_DEFAULT,\<br />		DISPATCH_PROPERTYPUT, addr dispparams, addr varResult, NULL, NULL<br />	.if &#40;eax != S_OK&#41;<br /></code></pre></div>
    <div class="meta">Posted on 2002-12-29 14:53:56 by japheth</div>
   </div>
   <div class="post" id="post-73247">
    <div class="subject"><a href="#post-73247">Frustration takes a new kinda low...</a></div>
    <div class="body">I tried using IDispatch::Invoke and it worked.<br />Putting number 555 in first cell of a new worksheet.<br />Quite sure now that vtable calls doesnt work for interface Range.<br /><br /><pre><code><br />	invoke vf&#40;pApp, _Application, get_Workbooks&#41;, addr pWorkbooks<br />	.if &#40;eax == S_OK&#41;<br />		mov var1.vt, VT_ERROR<br />		mov var1.scode, DISP_E_PARAMNOTFOUND <br />		invoke vf&#40;pWorkbooks, Workbooks, Add_&#41;, var1, 0, addr pWorkbook<br />		.if &#40;eax == S_OK&#41;<br />			invoke vf&#40;pApp, _Application, get_Cells&#41;, addr pCells<br />			.if &#40;eax == S_OK&#41;<br />				mov var1.vt, VT_I4<br />				mov var1.lVal, 555<br />				invoke put_Item@Range, pCells, 1, 1, var1<br />				invoke vf&#40;pCells, IUnknown, Release&#41; <br />			.endif<br />			invoke vf&#40;pWorkbook, IUnknown, Release&#41;<br />		.endif<br />		invoke vf&#40;pWorkbooks, IUnknown, Release&#41;<br />	.endif<br /></code></pre><br /><br />and thats the &quot;invoke wrapper&quot;:<br /><pre><code><br />put_Item@Range	proc pDispatch&#58; LPDISPATCH, dwRow&#58;DWORD, dwCol&#58;DWORD, varProp&#58;VARIANT<br /><br />local dwPropPutId&#58;DWORD<br />local dispparams&#58;DISPPARAMS<br />local rgvarg&#91;3&#93;&#58;VARIANT<br /><br />	lea eax, rgvarg<br />	mov dispparams.rgvarg, eax <br />	mov dispparams.cArgs, 3<br />	mov dispparams.cNamedArgs, 1<br />		<br />	mov dwPropPutId, DISPID_PROPERTYPUT<br />	lea eax, dwPropPutId<br />	mov dispparams.rgdispidNamedArgs, eax<br /><br />	mov ax, varProp.vt<br />	mov rgvarg&#91;0*sizeof VARIANT&#93;.vt, ax<br />	mov eax, varProp.lVal<br />	mov rgvarg&#91;0*sizeof VARIANT&#93;.lVal, eax<br /><br />	mov rgvarg&#91;1*sizeof VARIANT&#93;.vt, VT_I4<br />	mov eax, dwCol<br />	mov rgvarg&#91;1*sizeof VARIANT&#93;.lVal, eax<br /><br />	mov rgvarg&#91;2*sizeof VARIANT&#93;.vt, VT_I4<br />	mov eax, dwRow<br />	mov rgvarg&#91;2*sizeof VARIANT&#93;.lVal, eax<br />	invoke vf&#40;pDispatch, IDispatch, Invoke_&#41;, DISPID_ITEM, addr IID_NULL, LOCALE_SYSTEM_DEFAULT,\<br />			DISPATCH_PROPERTYPUT, addr dispparams, NULL, NULL, NULL<br />	ret<br />put_Item@Range	endp<br /></code></pre><br /><br />the parameters for invoke must be in REVERSE order!!!<br />And PROPERTYPUT needs one named argument!!!<br /><br />generating such wrapper code for dispatchonly interfaces would be a nice feature for comview.<br />But Im afraid then COM would be too easy, just for lamers  :) <br /><br />Japheth.</div>
    <div class="meta">Posted on 2002-12-29 16:17:57 by japheth</div>
   </div>
   <div class="post" id="post-73264">
    <div class="subject"><a href="#post-73264">Frustration takes a new kinda low...</a></div>
    <div class="body">Well i feel like a lamer ;)<br /><br />Thanks (once again) for your help..<br /><br />At least i know *someone* got it to work.. so it must be possible.<br />Funny you spoke of the addon for COMView, cause i was thinking of writing a class with the OOP to do all this, much like the MFC class generated by its wizard.<br /><br />Anywho, thanx again... <br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-12-29 17:36:05 by NaN</div>
   </div>
   <div class="post" id="post-73305">
    <div class="subject"><a href="#post-73305">Frustration takes a new kinda low...</a></div>
    <div class="body">Thanx again! Im back on the ball with this Invoke_ business.  I managed to do some basic stuff now!  <br /><br />So now to make my Excel wrapper class to make the automation simpler...<br /><br />If you are interested in this when im done, you are welcome to it for you help!<br /><br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-12-29 21:17:47 by NaN</div>
   </div>
   <div class="post" id="post-73324">
    <div class="subject"><a href="#post-73324">Frustration takes a new kinda low...</a></div>
    <div class="body">its quite funny: looking for IRange in generated excel.inc doesnt find any reference as &quot;retval&quot; parameter. Im quite sure that there exists a way of avoiding this Invoke_ stuff by somehow transforming a dispatchonly &quot;Range&quot; object to an vtable &quot;IRange&quot; object, since if not these &quot;Ixxxx&quot; interfaces would make no sense.</div>
    <div class="meta">Posted on 2002-12-29 23:14:28 by japheth</div>
   </div>
   <div class="post" id="post-73379">
    <div class="subject"><a href="#post-73379">Frustration takes a new kinda low...</a></div>
    <div class="body"><strong>I dont mind the extra work, if it means it *will work* ;)<br /><br />And to that end here is some code, hopefully as repayment for you help.<br /><br />I made my own &quot;InvokeHelper&quot;.</strong><br /><pre><code>MakeInvokeString PROTO C cNum&#58;DWORD, args&#58;VARARG<br />;--------------------------------------------------------------+<br />; Note&#58;  VT_BSTR_BLOB      are not supported types!!<br />;        VT_VECTOR  <br />;        VT_ARRAY<br />;        VT_BYREF<br />;        VT_RESERVED <br />;        VT_ILLEGAL  <br />;        VT_ILLEGALMASKED <br />;        VT_TYPEMASK      <br />;--------------------------------------------------------------+<br />MakeInvokeString PROC C USES esi edi ebx cNum&#58;DWORD, args&#58;VARARG<br /><br />   invoke GetProcessHeap                     ;; Get the process heap pointer in EAX<br />   mov edx, cNum                             ;; Get EDX = number of byte params<br />   add edx, 9                                ;; Align to next power of 4, with 4 byte header <br />   and edx, 0FFFFFFFCh                       ;; Trim off any exess<br />   invoke HeapAlloc, eax, NULL, edx          ;; Use it to allocate<br />   mov edx, cNum                             ;; Get the total count<br />   mov edi, eax                              ;; Save hMem in edi<br />   mov ebx, edi                              ;; Save hMem in ebx as well<br />   mov &#91;edi&#93;, edx                            ;; Store the count in the header<br />   add edi, 4                                ;; Set edi to start of string of bytes<br />   lea esi, args                             ;; Get the arguments pointer<br />   xor ecx, ecx                              ;; Set counter to zero<br />   @@&#58;<br />   cmp ecx, edx                              ;; Is ecx == Count<br />   je @F                                     ;; Yes, end and tag on null<br />   mov eax, &#91;esi&#93;                            ;; EAX == VTS type<br />   mov &#91;edi&#93;, al                             ;; copy byte into string<br />   inc edi                                   ;; EDI points to next byte location<br />   add esi, 4                                ;; ESI points to next argument<br />   inc ecx                                   ;; Counter is increased<br />   jmp @B                                    ;; <br />   @@&#58;<br />   xor eax, eax                              ;; eax = 0<br />   mov &#91;edi&#93;, al                             ;; tack on null at the end<br />   mov eax, ebx                              ;; Return the starting pointer to the memory<br />   ret<br />MakeInvokeString ENDP</code></pre><pre><code>InvokeHelp PROTO C pDispatch&#58; LPDISPATCH, w_Did&#58;DWORD, dw_dFlag&#58;DWORD, w_oVT_TYPE&#58;WORD, lpResult&#58;DWORD, lpParam&#58;DWORD, &#58;VARARG<br /><br />; All Qword types must be passed as a pointer<br />InvokeHelp PROC C uses edi esi ebx pDispatch&#58; LPDISPATCH, w_Did&#58;DWORD, dw_dFlag&#58;DWORD, w_oVT_TYPE&#58;WORD, lpResult&#58;DWORD, lpParam&#58;DWORD, args&#58;VARARG<br />;	InvokeHelper&#40;0xc5, DISPATCH_PROPERTYGET, VT_DISPATCH, &#40;void*&#41;&amp;result, parms,<br /><br />local dwPropPutId &#58;DWORD<br />local dispparams  &#58;DISPPARAMS<br />local paramcount  &#58;DWORD<br />local lpVars      &#58;DWORD<br />local varReturn   &#58;VARIANT<br /><br /> <br />   ; Get the length of the argument param list<br />   ;------------------------------------------+<br />   mov esi, lpParam                          ;; Get the byte string address<br />   mov ecx, &#91;esi&#93;                            ;; Get the number of arguments in ECX<br />   mov paramcount, ecx                       ;; Save it for later<br />   add esi, 4                                ;; Move to the argument byte string &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#91;esi&#93;<br />   <br />   ; Allocate Heap Memory for an array of Variants<br />   ;----------------------------------------------+<br />   xor eax, eax                              ;; EAX = 0<br />   mov lpVars, eax                           ;; Ensure lpVars == Null for later<br />   mov dispparams.cArgs, eax                 ;; Indicate 0 arguments &#40;for now&#41;<br />   invoke GetProcessHeap                     ;; Get the process heap pointer in EAX   <br />   mov edx, paramcount                       ;; EDX == Param count<br />   .if&#40;edx != NULL&#41;                          ;; if EDX != NULL<br />      mov dispparams.cArgs, edx              ;; Indicate 'n' arguments<br />      shl edx, 4                             ;; ECX = ECX * 16 &#40;Size of Variant&#41;<br />      invoke HeapAlloc, eax, NULL, edx       ;; Use it to allocate Variant memory  <br />      mov edi, eax                           ;; EDI == Variants on the heap &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#91;edi&#93;<br />      mov lpVars, edi                        ;; Save it for l8r &#40;active value&#41;<br /><br />   <br />   ; Populate the Variants with the required data<br />   ;---------------------------------------------+<br />      @@&#58;<br />      invoke VariantInit, edi                ;; Initialize the Variant at EDI<br />      mov ebx, paramcount                    ;; EBX = paramsleft<br />      xor eax, eax                           ;; EAX = 0<br />      cmp ebx, eax                           ;; if EBX = 0 <br />      je @F                                  ;; Then done, jump out<br />      dec ebx                                ;; EBX--<br />      mov paramcount, ebx                    ;; Paramsleft--<br />      mov edx, ebx                           ;; EDX = EBX<br />      shl ebx, 2                             ;; EBX = Count * sizeof DWORD<br />      lea ecx, args                          ;; ECX = args address<br />      add ebx, ecx                           ;; EBX == param offset for Variant data &lt;&lt;&lt;&lt;&lt;&lt;&lt;&#91;ebx&#93;<br />      <br />      add edx, esi                           ;; EDX == lpByteString + ByteCountOffset &lt;&lt;&lt;&lt;&lt;&lt;&#91;edx&#93;<br />      mov al, &#91;edx&#93;                          ;; AL == corresponding VT_ TYPE byte<br />      <br />      mov &#91;edi&#93;.VARIANT.vt, ax               ;; Set the Variant Type<br />      .if    &#40; eax == VT_NULL&#41;<br />         nop<br />      .elseif&#40; eax == VT_BOOL&#41;<br />         mov eax, &#91;ebx&#93;                      ;; Get Param Data<br />         and eax, 1                          ;; Trim out any fat<br />         mov &#91;edi&#93;.VARIANT.boolVal, ax       ;; Set Bool<br />      .elseif&#40;&#40; eax == VT_I1  &#41; || &#40; eax == VT_UI1&#41;&#41;<br />         mov eax, &#91;ebx&#93;                      ;; Get the param data<br />         and eax, 0FFh                       ;; Trim out any fat<br />         mov &#91;edi&#93;.VARIANT.bVal, al          ;; Set Byte<br />      .elseif&#40;&#40; eax == VT_I2  &#41; || &#40; eax == VT_UI2&#41;&#41;<br />         mov eax, &#91;ebx&#93;                      ;; Get the param data<br />         and eax, 0FFFFh                     ;; Trim out any fat<br />         mov &#91;edi&#93;.VARIANT.uiVal, ax         ;; Set the word<br />      .elseif&#40;&#40; eax == VT_R8  &#41; || &#40; eax == VT_CY &#41; || &#40;eax == VT_DATE&#41;&#41;<br />         mov eax, &#91;ebx&#93;                      ;; the pointer<br />         mov ebx, eax                        ;; Reset ebx to pointer pointed to<br />         mov eax, &#91;ebx&#93;                      ;; Get the low 4<br />         mov &#91;edi&#93;.VARIANT.ulVal, eax        ;; Set the low 4<br />         add ebx, 4<br />         add edi, 4<br />         mov eax, &#91;ebx&#93;                      ;; Get the high 4<br />         mov &#91;edi&#93;.VARIANT.ulVal, eax        ;; Set the high 4<br />         sub ebx, 4<br />         sub edi, 4<br />      .else<br />         mov eax, &#91;ebx&#93;                      ;; Get data32 in General<br />         mov &#91;edi&#93;.VARIANT.ulVal, eax        ;; Set data32 in General<br />      .endif<br />      add edi, 16                            ;; EDI = EDI + Sizeof Variant<br />      jmp @B                                 ;; Next Param to process<br />      @@&#58;<br />   <br />   .endif                                    ;; End of IF Param COunt<br />   <br />   ; Make the disparams header<br />   ;--------------------------+<br />	mov eax, lpVars                           ;; Get Variant List addres;<br />	mov dispparams.rgvarg, eax                ;; set dispatch params pointer;<br />	mov eax, dw_dFlag<br />	.if&#40;&#40; eax == DISPATCH_PROPERTYPUT &#41; || &#40; eax == DISPATCH_PROPERTYPUTREF&#41; &#41;<br />		mov dispparams.cNamedArgs, 1              ;; Indicate 1 named argument<br />   	mov dwPropPutId, DISPID_PROPERTYPUT       ;; Indicate 'get' property call<br />   	lea eax, dwPropPutId                      ;; get the address to this indication<br />   	mov dispparams.rgdispidNamedArgs, eax     ;; Set the named agrument pointer<br />   .else<br />   	mov dispparams.cNamedArgs, 0              ;; Indicate 0 named argument<br />      mov dispparams.rgdispidNamedArgs, NULL    ;; Set the named agrument pointer<br />   .endif<br />   <br />   ; Make the Invoke Call<br />   ;---------------------+<br />	.data<br />   	xlsIID_NULL sIID_NULL<br />	.code<br />	<br />	.if !&#40; lpResult &#41;<br />	invoke vf&#40;pDispatch, IDispatch, Invoke_&#41;, w_Did, addr xlsIID_NULL, LOCALE_SYSTEM_DEFAULT,\<br />			dw_dFlag, addr dispparams, NULL, NULL, NULL<br />	.else<br />	invoke VariantInit, addr varReturn<br />	xor eax, eax<br />	mov ax, w_oVT_TYPE<br />	mov varReturn.vt, ax<br />	invoke vf&#40;pDispatch, IDispatch, Invoke_&#41;, w_Did, addr xlsIID_NULL, LOCALE_SYSTEM_DEFAULT,\<br />			dw_dFlag, addr dispparams, addr varReturn, NULL, NULL<br />      <br />      mov edx, lpResult<br />      lea ecx, varReturn<br />      add ecx, 8<br />      mov eax, &#91;ecx&#93;<br />      mov &#91;edx&#93;,eax<br />      <br />      .if &#40;&#40; w_oVT_TYPE == VT_R8 &#41; || &#40;w_oVT_TYPE  == VT_CY &#41; || &#40;w_oVT_TYPE == VT_DATE&#41;&#41;<br />         mov eax, &#91;ecx+4&#93;<br />         mov &#91;edx+4&#93;, eax<br />      .endif<br />   <br />	.endif<br />	<br />	; Clean up the Heaps<br />	;-------------------+<br /><br /> 	invoke GetProcessHeap<br />  	invoke HeapFree, eax, NULL, lpVars<br /> 	invoke GetProcessHeap<br />  	invoke HeapFree, eax, NULL, lpParam<br /><br />   ret<br />InvokeHelp ENDP</code></pre><strong><br /><br />It has not been fully tested yet (since im burnt and going to bed). However, It does work with the following code example (places an integer 202 at (1,4) ):<br /></strong><pre><code><br />       invoke MakeInvokeString, 3, VT_I4, VT_I4, VT_I4<br />       invoke InvokeHelp, RNG, 0AAh, DISPATCH_PROPERTYPUT, NULL, NULL, eax, 1, 4, 202</code></pre><strong><br /><br />It should be robust enough.  It has limitations tho (ie, no array types), but can be fixed if i make it the 'MakeInvokeString' produce words.  As well, im not sure if the proper way to handle 'property get' methods is by setting the NamedArgs to Zero (likewize the DISP_METHOD type).<br /><br />The Function &quot;MakeInvokeString&quot; returns a heap pointer with the byte array in it.  The &quot;InvokeHelp&quot; will use this to build Variants, set them and call the invoke.  When done it will destroy it automatically.  <br /><br />Both are 'C' type functions (what i was earlier calling 'pascal' calling convention), so you can go nutz with the number of params tacked on.<br /><br />Anywho, look it over, use it if you like, and give feedback if you can ;)<br />Thanks again Japheth,<br />:alright:<br />NaN</strong></div>
    <div class="meta">Posted on 2002-12-30 04:46:24 by NaN</div>
   </div>
   <div class="post" id="post-73477">
    <div class="subject"><a href="#post-73477">Frustration takes a new kinda low...</a></div>
    <div class="body">With this it should be rather ez to make an addon for your tool, to generate template functions for properties/methods.  It keep EXE sizes under control, i think that each Method/Property should be selected from the Interface list by checkbox.  So a person can ask for code for only the interfaces they will use. This is alot of extra bagage in these COM classes ;)<br /><br />Anywho, just some thoughts.  I've tested it further with no hitch, however, im about to test it with &quot;get&quot; type methods (not done yet).<br /><br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-12-30 11:48:58 by NaN</div>
   </div>
   <div class="post" id="post-73500">
    <div class="subject"><a href="#post-73500">Frustration takes a new kinda low...</a></div>
    <div class="body">Hi NaN,<br /><br />thanks for the code. I would prefer not to use HeapAlloc for such helper functions, simple stack allocation (like &quot;sub esp, dwbytes&quot;, you know? ;) ) would be more appropriate here. Ok , you may say &quot;it works fine this way&quot;, but HeapAlloc can be a really costly operation.</div>
    <div class="meta">Posted on 2002-12-30 14:11:15 by japheth</div>
   </div>
   <div class="post" id="post-73510">
    <div class="subject"><a href="#post-73510">Frustration takes a new kinda low...</a></div>
    <div class="body">This code is slightly different with some (minor) fixes:<br /><pre><code>MakeInvokeString PROTO C cNum&#58;DWORD, args&#58;VARARG<br /><br />;--------------------------------------------------------------+<br />; MakeInvokeString      Rev 1.1                      Dec 30,2002<br />;<br />; Use this to build A string representing the vararg parms<br />;    passed into the InvokeHelp fucntion.<br />;    The first argument MUST be total of all following arguments<br />;    Following arguments must be valid VT_TYPES &#40;WORD SIZED&#41;<br />;    but pushed as DOUBLES<br />;<br />;    The return is a heap memory pointer with the array built<br />;    for used in the InvokeHelp function.<br />;<br />; By NaN &#40;c&#41; 2002.<br />; Help and Support by Japheth and Thomas.<br />;--------------------------------------------------------------+<br />MakeInvokeString PROC C USES esi edi ebx cNum&#58;DWORD, args&#58;VARARG<br /><br />   invoke GetProcessHeap                     ;; Get the process heap pointer in EAX<br />   mov edx, cNum                             ;; Get EDX = number of byte params<br />   inc edx                                   ;; Add one for NULL<br />   shl edx, 1                                ;; count = count * sizeof WORD<br />   add edx, 8                                ;; Align to next power of 4, with 4 byte header <br />   and edx, 0FFFFFFFCh                       ;; Trim off any exess<br />   invoke HeapAlloc, eax, NULL, edx          ;; Use it to allocate<br />   mov edx, cNum                             ;; Get the total count<br />   mov edi, eax                              ;; Save hMem in edi<br />   mov ebx, edi                              ;; Save hMem in ebx as well<br />   mov &#91;edi&#93;, edx                            ;; Store the count in the header<br />   add edi, 4                                ;; Set edi to start of string of bytes<br />   lea esi, args                             ;; Get the arguments pointer<br />   xor ecx, ecx                              ;; Set counter to zero<br />   @@&#58;<br />   cmp ecx, edx                              ;; Is ecx == Count<br />   je @F                                     ;; Yes, end and tag on null<br />   mov eax, &#91;esi&#93;                            ;; EAX == VTS type<br />   mov &#91;edi&#93;, ax                             ;; copy WORD into string<br />   inc edi                                   ;; EDI points to next byte location<br />   inc edi                                   ;; <br />   add esi, 4                                ;; ESI points to next argument<br />   inc ecx                                   ;; Counter is increased<br />   jmp @B                                    ;; <br />   @@&#58;<br />   xor eax, eax                              ;; eax = 0<br />   mov &#91;edi&#93;, ax                             ;; tack on null at the end<br />   mov eax, ebx                              ;; Return the starting pointer to the memory<br />   ret<br />MakeInvokeString ENDP<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />InvokeHelp PROTO C pDispatch&#58; LPDISPATCH, w_Did&#58;DWORD, dw_dFlag&#58;DWORD, w_oVT_TYPE&#58;WORD, \<br />                    lpResult&#58;DWORD, lpParam&#58;DWORD, &#58;VARARG<br />;-----------------------------------------------------------------+<br />; InvokeHelp               Rev 1.1                      Dec 30,2002<br />;<br />; Use this to call DISPATCHABLE interfaces by means of LATE Binding<br />;<br />;    The params are&#58;<br />;        pDispatch   &#58;LPDISPATCH  --   Disp Interface pointer<br />;        w_Did       &#58;DWORD       --   Disp. Unique ID of prop/meth<br />;        dw_dFlag    &#58;DWORD       --   Either&#58;<br />;                                         DISPATCH_PROPERTYPUT<br />;                                         DISPATCH_PROPERTYGET<br />;                                         DISPATCH_PROPERTYPUTREF<br />;                                         DISPATCH_METHOD<br />;        woVT_TYPE   &#58;WORD        --   Return VT_TYPE to expect<br />;                                      &#40;Set NULL if not used&#41;<br />;        lpResult    &#58;DWORD       --   Address to store return<br />;                                      &#40;Set NULL if not used&#41;<br />;        lpParam     &#58;DWORD       --   Pointer to argument WORD<br />;                                      array string, created by<br />;                                      MakeInvokeString. This<br />;                                      fuction will destory alloc<br />;                                      heap memory created by <br />;                                      MakeInvokeString.<br />;        args        &#58;VARARGS     --   Argument Data as indicated<br />;                                      By the lpParam WORD string<br />;                                      For QWORD SIZED arguments<br />;                                      you must pass a pointer<br />;                                      to where the data is found.<br />;<br />; By NaN &#40;c&#41; 2002.<br />; Help and Support by Japheth.<br />;--------------------------------------------------------------+<br />InvokeHelp PROC C uses edi esi ebx pDispatch&#58; LPDISPATCH, w_Did&#58;DWORD, dw_dFlag&#58;DWORD, \<br />                                  w_oVT_TYPE&#58;WORD, lpResult&#58;DWORD, lpParam&#58;DWORD, args&#58;VARARG<br /><br />local dwPropPutId &#58;DWORD<br />local dispparams  &#58;DISPPARAMS<br />local paramcount  &#58;DWORD<br />local lpVars      &#58;DWORD<br />local varReturn   &#58;VARIANT<br />LOCAL iErr        &#58;DWORD<br /> <br />   ; Get the length of the argument param list<br />   ;------------------------------------------+<br />   mov esi, lpParam                          ;; Get the byte string address<br />   mov ecx, &#91;esi&#93;                            ;; Get the number of arguments in ECX<br />   mov paramcount, ecx                       ;; Save it for later<br />   add esi, 4                                ;; Move to the argument byte string &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#91;esi&#93;<br />   <br />   ; Allocate Heap Memory for an array of Variants<br />   ;----------------------------------------------+<br />   xor eax, eax                              ;; EAX = 0<br />   mov lpVars, eax                           ;; Ensure lpVars == Null for later<br />   mov dispparams.cArgs, eax                 ;; Indicate 0 arguments &#40;for now&#41;<br />   invoke GetProcessHeap                     ;; Get the process heap pointer in EAX   <br />   mov edx, paramcount                       ;; EDX == Param count<br />   .if&#40;edx != NULL&#41;                          ;; if EDX != NULL<br />      mov dispparams.cArgs, edx              ;; Indicate 'n' arguments<br />      shl edx, 4                             ;; ECX = ECX * 16 &#40;Size of Variant&#41;<br />      invoke HeapAlloc, eax, NULL, edx       ;; Use it to allocate Variant memory  <br />      mov edi, eax                           ;; EDI == Variants on the heap &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#91;edi&#93;<br />      mov lpVars, edi                        ;; Save it for l8r &#40;active value&#41;<br /><br />   <br />   ; Populate the Variants with the required data<br />   ;---------------------------------------------+<br />      @@&#58;<br />      mov ebx, paramcount                    ;; EBX = paramsleft<br />      xor eax, eax                           ;; EAX = 0<br />      cmp ebx, eax                           ;; if EBX = 0 <br />      je @F                                  ;; Then done, jump out<br />      invoke VariantInit, edi                ;; Initialize the Variant at EDI<br />      xor eax, eax                           ;; EAX = 0 &#40;after call&#41;<br />      dec ebx                                ;; EBX--<br />      mov paramcount, ebx                    ;; Paramsleft--<br />      mov edx, ebx                           ;; EDX = EBX<br />      shl ebx, 2                             ;; EBX = Count * sizeof DWORD<br />      lea ecx, args                          ;; ECX = args address<br />      add ebx, ecx                           ;; EBX == param offset for Variant data &lt;&lt;&lt;&lt;&lt;&lt;&lt;&#91;ebx&#93;<br />      <br />      shl edx, 1                             ;; EDX == Count * sizeof WORD<br />      add edx, esi                           ;; EDX == lpByteString + WORDCountOffset &lt;&lt;&lt;&lt;&lt;&lt;&#91;edx&#93;<br />      mov ax, &#91;edx&#93;                          ;; AX == corresponding VT_ TYPE byte<br />      <br />      mov &#91;edi&#93;.VARIANT.vt, ax               ;; Set the Variant Type<br />      .if    &#40; eax == VT_NULL&#41;<br />         nop<br />      .elseif&#40; eax == VT_BOOL&#41;<br />         mov eax, &#91;ebx&#93;                      ;; Get Param Data<br />         and eax, 1                          ;; Trim out any fat<br />         mov &#91;edi&#93;.VARIANT.boolVal, ax       ;; Set Bool<br />      .elseif&#40;&#40; eax == VT_I1  &#41; || &#40; eax == VT_UI1&#41;&#41;<br />         mov eax, &#91;ebx&#93;                      ;; Get the param data<br />         and eax, 0FFh                       ;; Trim out any fat<br />         mov &#91;edi&#93;.VARIANT.bVal, al          ;; Set Byte<br />      .elseif&#40;&#40; eax == VT_I2  &#41; || &#40; eax == VT_UI2&#41;&#41;<br />         mov eax, &#91;ebx&#93;                      ;; Get the param data<br />         and eax, 0FFFFh                     ;; Trim out any fat<br />         mov &#91;edi&#93;.VARIANT.uiVal, ax         ;; Set the word<br />      .elseif&#40;&#40; eax == VT_R8  &#41; || &#40; eax == VT_CY &#41; || &#40;eax == VT_DATE&#41;&#41;<br />         mov eax, &#91;ebx&#93;                      ;; the pointer<br />         mov ebx, eax                        ;; Reset ebx to pointer pointed to<br />         mov eax, &#91;ebx&#93;                      ;; Get the low 4<br />         mov &#91;edi&#93;.VARIANT.ulVal, eax        ;; Set the low 4<br />         add ebx, 4<br />         add edi, 4<br />         mov eax, &#91;ebx&#93;                      ;; Get the high 4<br />         mov &#91;edi&#93;.VARIANT.ulVal, eax        ;; Set the high 4<br />         sub ebx, 4<br />         sub edi, 4<br />      .else<br />         mov eax, &#91;ebx&#93;                      ;; Get data32 in General<br />         mov &#91;edi&#93;.VARIANT.ulVal, eax        ;; Set data32 in General<br />      .endif<br />      add edi, 16                            ;; EDI = EDI + Sizeof Variant<br />      jmp @B                                 ;; Next Param to process<br />      @@&#58;<br />   <br />   .endif                                    ;; End of IF Param COunt<br />   <br />   ; Make the disparams header<br />   ;--------------------------+<br />   mov eax, lpVars                           ;; Get Variant List addres;<br />   mov dispparams.rgvarg, eax                ;; set dispatch params pointer;<br />   mov eax, dw_dFlag<br />   .if&#40;&#40; eax == DISPATCH_PROPERTYPUT &#41; || &#40; eax == DISPATCH_PROPERTYPUTREF&#41; &#41;<br />      mov dispparams.cNamedArgs, 1              ;; Indicate 1 named argument<br />      mov dwPropPutId, DISPID_PROPERTYPUT       ;; Indicate 'get' property call<br />      lea eax, dwPropPutId                      ;; get the address to this indication<br />      mov dispparams.rgdispidNamedArgs, eax     ;; Set the named agrument pointer<br />   .else<br />      mov dispparams.cNamedArgs, 0              ;; Indicate 0 named argument<br />      mov dispparams.rgdispidNamedArgs, NULL    ;; Set the named agrument pointer<br />   .endif<br />   <br />   ; Make the Invoke Call<br />   ;---------------------+<br />   .data<br />      xlsIID_NULL sIID_NULL<br />   .code<br /><br />   xor eax, eax<br />   mov iErr, eax<br />   <br />   .if !&#40; lpResult &#41;<br />   invoke vf&#40;pDispatch, IDispatch, Invoke_&#41;, w_Did, addr xlsIID_NULL, LOCALE_SYSTEM_DEFAULT,\<br />         dw_dFlag, addr dispparams, NULL, NULL, addr iErr<br />   <br />   xor eax, eax<br />   mov edx, iErr<br />   <br />   .else<br />   invoke VariantInit, addr varReturn<br />   xor eax, eax<br />   mov ax, w_oVT_TYPE<br />   mov varReturn.vt, ax<br /><br />   invoke vf&#40;pDispatch, IDispatch, Invoke_&#41;, w_Did, addr xlsIID_NULL, LOCALE_SYSTEM_DEFAULT,\<br />         dw_dFlag, addr dispparams, addr varReturn, NULL, addr iErr<br /><br />   xor eax, eax<br />   mov ax, w_oVT_TYPE<br />   invoke VariantChangeType, addr varReturn, addr varReturn, NULL, eax<br />      mov edx, lpResult<br />      lea ecx, varReturn<br />      add ecx, 8<br />      mov eax, &#91;ecx&#93;<br />      mov &#91;edx&#93;,eax<br />      <br />      .if &#40;&#40; w_oVT_TYPE == VT_R8 &#41; || &#40;w_oVT_TYPE  == VT_CY &#41; || &#40;w_oVT_TYPE == VT_DATE&#41;&#41;<br />         mov eax, &#91;ecx+4&#93;<br />         mov &#91;edx+4&#93;, eax<br />      .endif<br />      <br />      xor eax, eax<br />      lea ecx, varReturn<br />      mov ax, &#91;ecx&#93;<br />      <br />      mov edx, iErr<br />   <br />   .endif<br /><br />   push eax   <br />   push edx<br />   <br />   ; Clean up the Heaps<br />   ;-------------------+<br /><br />   .if &#40;lpVars&#41;<br />   invoke GetProcessHeap<br />   invoke HeapFree, eax, NULL, lpVars<br />   .endif<br />   <br />   invoke GetProcessHeap<br />   invoke HeapFree, eax, NULL, lpParam<br /><br />   pop edx<br />   pop eax<br />   <br />   ret<br />InvokeHelp ENDP</code></pre><br /><br />It now works with all variant types, and returns what is asked for by converting the output variant on all 'get' calls.<br /><br />I origionally though about doing the same (sub esp, xx) , but to be honest, its not something i practice and didnt feel conformatble taking on too much at once.  Not sure how to get around call / ret's and still preserve the stack data??<br /><br />If you wish to modify this code to do such please do!  I agree the stack would be best, cause im allocating only small amounts of heap for the Variant WORD string, and the Variants themselves...<br /><br />Anywho, with the above routines, i managed to do both put, get, and re-put data with excel.<pre><code>       invoke MakeInvokeString, 3, VT_I4, VT_I4, VT_R8<br />       invoke InvokeHelp, RNG, 0AAh, DISPATCH_PROPERTYPUT, NULL, NULL, eax, 1, 4, addr ar5<br /><br /><br />       invoke MakeInvokeString, 2, VT_I4, VT_I4<br />       invoke InvokeHelp, RNG, 0AAh, DISPATCH_PROPERTYGET, VT_DISPATCH, addr aout, eax, 2, 3<br />       <br />     <br />       invoke MakeInvokeString, 0<br />       invoke InvokeHelp, aout, 006h, DISPATCH_PROPERTYGET, VT_I4, addr lpStr, eax<br /><br />       invoke MakeInvokeString, 3, VT_I4, VT_I4, VT_I4<br />       invoke InvokeHelp, RNG, 0AAh, DISPATCH_PROPERTYPUT, NULL, NULL, eax, 1, 1, lpStr</code></pre><br /><br />Thanx again!<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-12-30 14:27:13 by NaN</div>
   </div>
   <div class="post" id="post-73616">
    <div class="subject"><a href="#post-73616">Frustration takes a new kinda low...</a></div>
    <div class="body"><div class="quote"><br />Hi NaN,<br />thanks for the code. I would prefer not to use HeapAlloc for such helper functions, simple stack allocation (like &quot;sub esp, dwbytes&quot;, you know? ;) ) would be more appropriate here. Ok , you may say &quot;it works fine this way&quot;, but HeapAlloc can be a really costly operation. </div><br /><br />I was thinking about this, i can see how to do such within the 'InvokeHelp' function, since its already scoped (ie. Variant Allocations).  But how would i do it for the 'MakeInvokeString' function?? Upon the return the stack will be adjusted..<br /><br />Unless i jump say 1000h bytes down the stack and assume i wont have enough calls to get here.  Modify this area, and keep the stack pointer the same (unmodified), and pass the -1000 pointer into the 'InvokeHelp' function.  <br /><br />As well i guess it would not need to be destoryed.. simply forget about it..<br /><br />I dunno, need to play around i guess..<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-12-30 22:37:07 by NaN</div>
   </div>
   <div class="post" id="post-73623">
    <div class="subject"><a href="#post-73623">Frustration takes a new kinda low...</a></div>
    <div class="body">I played around and discovered it was easier than i first expected.  Im simply moving back 1000h in the stack to pass out of scope data between functions.  So there is now no heap calls ;)<br /><br />The 'MakeInvokeString' function jumps back 1000h on the stack and builds a string while preserving esp.  Then it returns a pointer to this -1000h stack address.<br /><pre><code>MakeInvokeString PROTO C cNum&#58;DWORD, args&#58;VARARG<br /><br />;--------------------------------------------------------------+<br />; MakeInvokeString      Rev 1.2                      Dec 31,2002<br />;<br />; Use this to build A string representing the vararg parms<br />;    passed into the InvokeHelp fucntion.<br />;    The first argument MUST be total of all following arguments<br />;    Following arguments must be valid VT_TYPES &#40;WORD SIZED&#41;<br />;    but pushed as DOUBLES<br />;<br />;    The return is a stack memory pointer with the array built<br />;    for used in the InvokeHelp function.<br />;<br />; By NaN &#40;c&#41; 2002.<br />; Help and Support by Japheth and Thomas.<br />;--------------------------------------------------------------+<br />MakeInvokeString PROC C USES esi edi ebx cNum&#58;DWORD, args&#58;VARARG<br /><br />   mov eax, esp                              ;; EAX == Stack data pointer<br />   sub eax, 1000h                            ;; Back up 1000h hex in the stack for hMem data<br />      <br />   mov edx, cNum                             ;; Get EDX = number of byte params<br />   inc edx                                   ;; Add one for NULL<br />   shl edx, 1                                ;; count = count * sizeof WORD<br />   add edx, 12                               ;; Align to next power of 4, with 4 byte header, 4 byte size<br />   and edx, 0FFFFFFFCh                       ;; Trim off any exess<br /><br />   mov edi, eax                              ;; Save hMem in edi<br />   mov ebx, edi                              ;; Save hMem in ebx as well<br /><br />   mov &#91;edi&#93;, edx                            ;; Pre-Header How much memory is allocated<br />   add edi, 4                                ;; Increment to Param count Header<br /><br />   mov edx, cNum                             ;; Get the total count   <br />   mov &#91;edi&#93;, edx                            ;; Store the count in the header<br />   add edi, 4                                ;; Set edi to start of string of bytes<br />   lea esi, args                             ;; Get the arguments pointer<br />   xor ecx, ecx                              ;; Set counter to zero<br />   @@&#58;<br />   cmp ecx, edx                              ;; Is ecx == Count<br />   je @F                                     ;; Yes, end and tag on null<br />   mov eax, &#91;esi&#93;                            ;; EAX == VTS type<br />   mov &#91;edi&#93;, ax                             ;; copy WORD into string<br />   inc edi                                   ;; EDI points to next byte location<br />   inc edi                                   ;; <br />   add esi, 4                                ;; ESI points to next argument<br />   inc ecx                                   ;; Counter is increased<br />   jmp @B                                    ;; <br />   @@&#58;<br />   xor eax, eax                              ;; eax = 0<br />   mov &#91;edi&#93;, ax                             ;; tack on null at the end<br />   mov eax, ebx                              ;; Return the starting pointer to the memory<br />   ret<br />MakeInvokeString ENDP</code></pre><br />The 'InvokeHelp' function take a lpParam pointer to this string data.  It keep things all good for in-scope push's and pop's, I allocate more stack memory, copy it up, and readjust the lpParam pointer to point to the in-scope memory.  This is so i can forget about it being outside the scope, and have the potential of functions / methods writing over this stack memory (unlikely, i realize, but its safe and can now be copied an pasted if need be).  From here i also replaced inscope HeapAllocs with sub esp, xx as suggested.  ;)<br /><pre><code>InvokeHelp PROTO C pDispatch&#58; LPDISPATCH, w_Did&#58;DWORD, dw_dFlag&#58;DWORD, w_oVT_TYPE&#58;WORD, \<br />                    lpResult&#58;DWORD, lpParam&#58;DWORD, &#58;VARARG<br />;--------------------------------------------------------------------------------------------+<br />; InvokeHelp                      Rev 1.2                                          Dec 31,2002<br />;<br />; Use this to call DISPATCHABLE interfaces by means of LATE Binding<br />;<br />;    The params are&#58;<br />;        pDispatch   &#58;LPDISPATCH  --   Disp Interface pointer<br />;        w_Did       &#58;DWORD       --   Disp. Unique ID of prop/meth<br />;        dw_dFlag    &#58;DWORD       --   Either&#58;<br />;                                         DISPATCH_PROPERTYPUT<br />;                                         DISPATCH_PROPERTYGET<br />;                                         DISPATCH_PROPERTYPUTREF<br />;                                         DISPATCH_METHOD<br />;        woVT_TYPE   &#58;WORD        --   Return VT_TYPE to expect &#40;Set NULL if not used&#41;<br />;        lpResult    &#58;DWORD       --   Address to store return  &#40;Set NULL if not used&#41;<br />;        lpParam     &#58;DWORD       --   Pointer to argument WORD array string, created by<br />;                                      MakeInvokeString.<br />;        args        &#58;VARARGS     --   Argument Data as indicated by the lpParam WORD string<br />;                                      For QWORD SIZED arguments you must pass a pointer<br />;                                      to where the data is found.<br />;<br />; By NaN &#40;c&#41; 2002.<br />; Help and Support by Japheth.<br />;--------------------------------------------------------------------------------------------+<br />InvokeHelp PROC C uses edi esi ebx pDispatch&#58; LPDISPATCH, w_Did&#58;DWORD, dw_dFlag&#58;DWORD, \<br />                                  w_oVT_TYPE&#58;WORD, lpResult&#58;DWORD, lpParam&#58;DWORD, args&#58;VARARG<br /><br />local dwPropPutId &#58;DWORD<br />local dispparams  &#58;DISPPARAMS<br />local paramcount  &#58;DWORD<br />local lpVars      &#58;DWORD<br />local varReturn   &#58;VARIANT<br />LOCAL iErr        &#58;DWORD<br />LOCAL stkVarSize  &#58;DWORD<br />LOCAL stkParamSz  &#58;DWORD<br /><br />;----------------------------------------------------------+<br />; Copy Stack Memory into scope<br />;----------------------------------------------------------+<br />mov esi, lpParam     ; Get pointer<br />mov ecx, &#91;esi&#93;       ; Get copy size<br />mov eax, 4<br />sub ecx, eax         ; Ignore the copy size DWORD<br />add esi, eax         ; ESI = Start of data &#40;header&#41;<br />sub esp, ecx         ; Allocate memory<br />mov stkParamSz, ecx  ; Save this for cleanup<br />mov lpParam, esp     ; Modify the lpParam pointer<br />mov edi, esp         ; EDI = lpParam data<br />@@&#58;<br />cmp ecx, NULL        ; Will land on NULL cause ecx=aligned 4<br />je @F<br />mov eax, &#91;esi&#93;       ; Copy Source outa scope<br />mov &#91;edi&#93;, eax       ; into dest, in scope<br />mov eax, 4           ; EAX = 4<br />add esi, eax         ; ESI + 4<br />add edi, eax         ; EDI + 4<br />sub ecx, eax         ; ECX - 4<br />jmp @B               ; Go again.<br />@@&#58;<br />;----------------------------------------------------------+<br />; Now lpParam points to in scope data <br />;----------------------------------------------------------+<br /><br /><br /> <br />   ; Get the length of the argument param list<br />   ;------------------------------------------+<br />   mov esi, lpParam                          ;; Get the byte string address<br />   mov ecx, &#91;esi&#93;                            ;; Get the number of arguments in ECX<br />   mov paramcount, ecx                       ;; Save it for later<br />   add esi, 4                                ;; Move to the argument byte string &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#91;esi&#93;<br />   <br />   ; Allocate Heap Memory for an array of Variants<br />   ;----------------------------------------------+<br />   xor eax, eax                              ;; EAX = 0<br />   mov stkVarSize, eax                       ;; Pre-init the stack size to NULL<br />   mov lpVars, eax                           ;; Ensure lpVars == Null for later<br />   mov dispparams.cArgs, eax                 ;; Indicate 0 arguments &#40;for now&#41;<br />   mov edx, paramcount                       ;; EDX == Param count<br />   .if&#40;edx != NULL&#41;                          ;; if EDX != NULL<br />      mov dispparams.cArgs, edx              ;; Indicate 'n' arguments<br />      shl edx, 4                             ;; ECX = ECX * 16 &#40;Size of Variant&#41;<br />      mov stkVarSize, edx                    ;; Save Stack Variant size<br />      sub esp, edx                           ;; Allocate memory from stack<br />      mov edi, esp                           ;; EDI == Variants on the heap &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#91;edi&#93;<br />      mov lpVars, edi                        ;; Save it for l8r &#40;active value&#41;<br /><br />   <br />   ; Populate the Variants with the required data<br />   ;---------------------------------------------+<br />      @@&#58;<br />      mov ebx, paramcount                    ;; EBX = paramsleft<br />      xor eax, eax                           ;; EAX = 0<br />      cmp ebx, eax                           ;; if EBX = 0 <br />      je @F                                  ;; Then done, jump out<br />      invoke VariantInit, edi                ;; Initialize the Variant at EDI<br />      xor eax, eax                           ;; EAX = 0 &#40;after call&#41;<br />      dec ebx                                ;; EBX--<br />      mov paramcount, ebx                    ;; Paramsleft--<br />      mov edx, ebx                           ;; EDX = EBX<br />      shl ebx, 2                             ;; EBX = Count * sizeof DWORD<br />      lea ecx, args                          ;; ECX = args address<br />      add ebx, ecx                           ;; EBX == param offset for Variant data &lt;&lt;&lt;&lt;&lt;&lt;&lt;&#91;ebx&#93;<br />      <br />      shl edx, 1                             ;; EDX == Count * sizeof WORD<br />      add edx, esi                           ;; EDX == lpByteString + WORDCountOffset &lt;&lt;&lt;&lt;&lt;&lt;&#91;edx&#93;<br />      mov ax, &#91;edx&#93;                          ;; AX == corresponding VT_ TYPE byte<br />      <br />      mov &#91;edi&#93;.VARIANT.vt, ax               ;; Set the Variant Type<br />      .if    &#40; eax == VT_NULL&#41;<br />         nop<br />      .elseif&#40; eax == VT_BOOL&#41;<br />         mov eax, &#91;ebx&#93;                      ;; Get Param Data<br />         and eax, 1                          ;; Trim out any fat<br />         mov &#91;edi&#93;.VARIANT.boolVal, ax       ;; Set Bool<br />      .elseif&#40;&#40; eax == VT_I1  &#41; || &#40; eax == VT_UI1&#41;&#41;<br />         mov eax, &#91;ebx&#93;                      ;; Get the param data<br />         and eax, 0FFh                       ;; Trim out any fat<br />         mov &#91;edi&#93;.VARIANT.bVal, al          ;; Set Byte<br />      .elseif&#40;&#40; eax == VT_I2  &#41; || &#40; eax == VT_UI2&#41;&#41;<br />         mov eax, &#91;ebx&#93;                      ;; Get the param data<br />         and eax, 0FFFFh                     ;; Trim out any fat<br />         mov &#91;edi&#93;.VARIANT.uiVal, ax         ;; Set the word<br />      .elseif&#40;&#40; eax == VT_R8  &#41; || &#40; eax == VT_CY &#41; || &#40;eax == VT_DATE&#41;&#41;<br />         mov eax, &#91;ebx&#93;                      ;; the pointer<br />         mov ebx, eax                        ;; Reset ebx to pointer pointed to<br />         mov eax, &#91;ebx&#93;                      ;; Get the low 4<br />         mov &#91;edi&#93;.VARIANT.ulVal, eax        ;; Set the low 4<br />         add ebx, 4<br />         add edi, 4<br />         mov eax, &#91;ebx&#93;                      ;; Get the high 4<br />         mov &#91;edi&#93;.VARIANT.ulVal, eax        ;; Set the high 4<br />         sub ebx, 4<br />         sub edi, 4<br />      .else<br />         mov eax, &#91;ebx&#93;                      ;; Get data32 in General<br />         mov &#91;edi&#93;.VARIANT.ulVal, eax        ;; Set data32 in General<br />      .endif<br />      add edi, 16                            ;; EDI = EDI + Sizeof Variant<br />      jmp @B                                 ;; Next Param to process<br />      @@&#58;<br />   <br />   .endif                                    ;; End of IF Param COunt<br />   <br />   ; Make the disparams header<br />   ;--------------------------+<br />   mov eax, lpVars                           ;; Get Variant List addres;<br />   mov dispparams.rgvarg, eax                ;; set dispatch params pointer;<br />   mov eax, dw_dFlag<br />   .if&#40;&#40; eax == DISPATCH_PROPERTYPUT &#41; || &#40; eax == DISPATCH_PROPERTYPUTREF&#41; &#41;<br />      mov dispparams.cNamedArgs, 1              ;; Indicate 1 named argument<br />      mov dwPropPutId, DISPID_PROPERTYPUT       ;; Indicate 'get' property call<br />      lea eax, dwPropPutId                      ;; get the address to this indication<br />      mov dispparams.rgdispidNamedArgs, eax     ;; Set the named agrument pointer<br />   .else<br />      mov dispparams.cNamedArgs, 0              ;; Indicate 0 named argument<br />      mov dispparams.rgdispidNamedArgs, NULL    ;; Set the named agrument pointer<br />   .endif<br />   <br />   ; Make the Invoke Call<br />   ;---------------------+<br />   .data<br />      xlsIID_NULL sIID_NULL<br />   .code<br />   xor eax, eax<br />   mov iErr, eax<br />   <br />   .if !&#40; lpResult &#41;    ;-------------------------------------------------------------------+ &#91;IF START&#93;<br />   <br />   ; Do the DISP&#58;Invoke for SET types<br />   ;---------------------------------+<br />   invoke vf&#40;pDispatch, IDispatch, Invoke_&#41;, w_Did, addr xlsIID_NULL, LOCALE_SYSTEM_DEFAULT,\<br />         dw_dFlag, addr dispparams, NULL, NULL, addr iErr<br />   xor eax, eax                                 ;; Eax == 0 &#40;no return info&#41;<br />   mov edx, iErr                                ;; Edx == Any found param error<br /><br />   .else ;----------------------------------------------------------------------------------+ &#91;ELSE&#93;<br /><br />   invoke VariantInit, addr varReturn           ;; Init the return Variant<br />   xor eax, eax                                 ;; Eax == 0<br />   mov ax, w_oVT_TYPE                           ;; Get out type<br />   mov varReturn.vt, ax                         ;; Set it<br />   <br />   ; Do the DISP&#58;Invoke for GET types<br />   ;---------------------------------+<br />   invoke vf&#40;pDispatch, IDispatch, Invoke_&#41;, w_Did, addr xlsIID_NULL, LOCALE_SYSTEM_DEFAULT,\<br />         dw_dFlag, addr dispparams, addr varReturn, NULL, addr iErr<br />   xor eax, eax                                 ;; EAX == 0<br />   mov ax, w_oVT_TYPE                           ;; Get the desired return typ<br />   <br />   ; Modify the Return to what we asked for<br />   ;---------------------------------------+<br />   invoke VariantChangeType, addr varReturn, addr varReturn, NULL, eax<br />   mov edx, lpResult                            ;; Get destination address<br />   lea ecx, varReturn                           ;; Get return variant address<br />   add ecx, 8                                   ;; got to variant data area<br />   mov eax, &#91;ecx&#93;                               ;; Copy out the low DWORD<br />   mov &#91;edx&#93;,eax                                ;; Save low DWORD in dest<br /><br />   ; If QWORD types, then copy High DWORDS as well<br />   ;----------------------------------------------+      <br />   .if &#40;&#40; w_oVT_TYPE == VT_R8 &#41; || &#40;w_oVT_TYPE  == VT_CY &#41; || &#40;w_oVT_TYPE == VT_DATE&#41;&#41;<br />      mov eax, &#91;ecx+4&#93;                          ;; Get High DWORD<br />      mov &#91;edx+4&#93;, eax                          ;; Set High DWORD<br />   .endif<br />      <br />   xor eax, eax                                 ;; EAX = 0<br />   lea ecx, varReturn                           ;; Get return variant address<br />   mov ax, &#91;ecx&#93;                                ;; Copy EAX == Return VT_TYPE<br />   mov edx, iErr                                ;; Set EDX to any error returned<br />   <br />   .endif   ;-------------------------------------------------------------------------------+ &#91;END IF&#93;<br /><br />   <br />   ; Clean up the Stacks<br />   ;-------------------------------------------------+<br />   .if &#40;lpVars&#41;<br />      add esp, stkVarSize                       ;; Fix stack Variants &#40;if any&#41; &#91;Allocated Last&#93;<br />   .endif<br />   add esp, stkParamSz                          ;; Fix lpData stack &#40;lpData is now invalid&#41;<br />   ;-------------------------------------------------+<br />   ret<br />InvokeHelp ENDP</code></pre><br /><br />Anywho, let me know what you think ;)<br />It works great so far, I havent yet tested it on 'METHOD' types, but PUT/GET PROPERTY types work great!<br /><br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-12-31 00:59:05 by NaN</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=9833&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=9833&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="9833" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=9833&amp;page=2">&gt;</a><a href="../?id=9833&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>