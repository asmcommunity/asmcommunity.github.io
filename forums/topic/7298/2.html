<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>PROFILE: Is there a way to get stable results? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=7298" />
  <link rel="prev" href="../?id=7298&amp;page=1" />  <link rel="next" href="../?id=7298&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=7298">PROFILE: Is there a way to get stable results?</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=7298&amp;page=1" style="">&laquo;</a><a href="../?id=7298&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="7298" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=7298&amp;page=3">&gt;</a><a href="../?id=7298&amp;page=3">&raquo;</a></form>   <div class="post" id="post-53297">
    <div class="subject"><a href="#post-53297">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body">Hi <strong>KetilO</strong>, you wrote: <br /><em>Finally some mature response.<br />[..]<br />To all:<br />I started this thread hoping for a mature discussion leading to a result, but as often happends on this board someone has to show off and use 'war types' to heat up the discusssion and thereby destroying the possibility of a result. It's a pity. I am here to learn and share my ideas.<br /></em><br /><br />Please don't take the &quot;it was personal&quot;, victimistic road now.<br /><br />The reason why I got a bit pissed because of your behaviour was that I several times wrote you about some issues that you in the following posts completely ignored. I'm sure you would have been annoyed by this behaviour too, if somebody asked about some RadAsm problem, you replied in detail, and in his next post he looked deaf. It is annoying, considering the very little free time I can dedicate to the board and to help (something I gladly do, anyway).<br /><br />That's the whole point, I've very little free time and I'd like to help, and thus to get listened. Anyway I'm working on a &quot;dramatic&quot; solution for PROFILE (more about this later).<br /><br />About &quot;mature discussion&quot;, thanks for finally sharing what CPU was the one that gave you problems. The next release of PROFILE (which will be released as machine code, thus compatible with all assemblers, MASM included) will be extremely careful also to cache trace and other possible problems related with Windows and what not. I'm writing the next release of PROFILE in a &quot;be paranoid&quot; way, so to cover all the unprobable and inimaginable causes of problems, and to ensure MASM compatibility as well.<br /><br />I will document the advances when I post the new routine, hoping the documentation will be read this time. ;)<br /><br />Then please write a MASM sample application and report any inconvenience on the CPU's you have access to, eventually reporting the brand/model, etc..<br /><br />And please don't take this as personal.. I got heated only since the 4th time I repeated the same things on. Try to see it from the other point of view as well, I have nothing against you, never had, and don't want to have. I want to help but I don't want to waste my time.. simple as that.<br /><br /><br /><strong>ALL</strong>: Do you know of a single CPU where if CPUID reports the presence of CMOV one can <strong>NOT</strong> assume anyway the presence of SFENCE? The next release of PROFILE will do sfence (to improve consistency on some memory intensive routines), and I need a reliable way to detect its presence (should be on all CPU's that execute out of order, which should all also support CMOV. <em>Do you know of any exception?</em>).</div>
    <div class="meta">Posted on 2002-08-14 08:07:52 by Maverick</div>
   </div>
   <div class="post" id="post-53301">
    <div class="subject"><a href="#post-53301">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body">Hi Maverick<br /><br />Althoug not clearly stated the request was targeted to masm users that might had a solution. I don't know why you selected to assume that I had not read your instructions or not fully understood the importance of alignment (after reading it).<br /><br />KetilO</div>
    <div class="meta">Posted on 2002-08-14 08:35:12 by KetilO</div>
   </div>
   <div class="post" id="post-53304">
    <div class="subject"><a href="#post-53304">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body">Hi <strong>KetilO</strong>,<br /><br />The problem is wider than that.<br /><br />For example, on the K7 a stall will happen if:<br /><br /><pre><code><br />        OR      EAX,12<br />        CMP     EAX,128<br /><br />&lt;edit&#58; the above alone will not produce the stall, so I better show a full test as well&#58;&gt;<br /><br />        CMP             ECX,'g'-'0'<br />        JAE             .exit<br />        MOV             EAX,$12345678<br />        CMP             ECX,128                ; try 32 instead.. and the stall arises &#40;10 cycles of stall!&#41;<br />        CMOVC           EAX,EBX<br />        BT              EAX,ECX<br />        JNC             .exit<br /><br /></code></pre><br />Simply because the former instruction immediate operand can be codified as byte size, while the latter not. Weird, ain't it. This kind of unknown_by_the_most stall instead won't happen on Intel CPU's, AFAIK.<br /><br />Many assemblers won't let you have control over the (short vs long) form of the instruction that will be produced, while others will, and e.g. FAsm will by default find/use the shortest possible form, but will let you specify what you prefer, in case.<br /><br />PROFILE is extremely tricky in this regard.. if an instruction is assembled a bit different than I thought, the results may be much different. These things aren't obvious, by any means. That's why I insisted on the importance of not assuming anything (about alignment or anything else), although any small difference may seem to not change anything (while indeed it may do).<br /><br />That's why I decided, for the next release, to make a machine code version.. so to provide assembler independent code, and be sure all works as expected. Also, I'm glad if MASM users can use it, although I don't like that assembler.<br /><br />I will finish and release it when I have my next free time slice.</div>
    <div class="meta">Posted on 2002-08-14 08:45:19 by Maverick</div>
   </div>
   <div class="post" id="post-53308">
    <div class="subject"><a href="#post-53308">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body">Hi Maverick<br /><br />Thanks, :alright: <br /><br />It is a gereat tool, still a bit tricky to use under masm tho.<br /><br />KetilO</div>
    <div class="meta">Posted on 2002-08-14 08:50:54 by KetilO</div>
   </div>
   <div class="post" id="post-53311">
    <div class="subject"><a href="#post-53311">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body">You're wellcome.. but, believe me, MASM has its limitations, it's not that I'm not supporting it. MASM is good as a HLL tool, but when you want to do stuff really low level, it has many limitations.<br /><br />I'm trying to circumvent all of them anyway, and the next release of PROFILE should not be too difficult to use with any assembler, although being the tricky tool that it is, you're right, it's not too trivial to use, unfortunately. Nothing can be made to improve this, though, I'm afraid. It's a tricky thing to count the exact number of cycles an arbitrary routine takes on a modern CPU.</div>
    <div class="meta">Posted on 2002-08-14 09:10:34 by Maverick</div>
   </div>
   <div class="post" id="post-53332">
    <div class="subject"><a href="#post-53332">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body"><div class="quote"><br /><strong>ALL</strong>: Do you know of a single CPU where if CPUID reports the presence of CMOV one can <strong>NOT</strong> assume anyway the presence of SFENCE? The next release of PROFILE will do sfence (to improve consistency on some memory intensive routines), and I need a reliable way to detect its presence (should be on all CPU's that execute out of order, which should all also support CMOV. <em>Do you know of any exception?</em>). </div><br />The SSE instruction set include SFENCE. You need check &quot;SSE Extensions&quot; flag of CPUID.<br /><br />About you stall example. All stall situation described in CPU documentation (AMD/Intel). I dont have K7 doucumentation. But you example look strange. May be such stall specific only for K7? Very intresting where you become known about this.</div>
    <div class="meta">Posted on 2002-08-14 11:34:06 by Nexo</div>
   </div>
   <div class="post" id="post-53345">
    <div class="subject"><a href="#post-53345">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body">I don't have my docs here.. but doesn't the Pentium II support SFENCE?<br />Are you 100% sure that it is a SSE extension? What about Athlons then.. no SSE (but probably XMMX, i.e. MMX SSE extensions), but SFENCE support. A 100% sure, final word on this would be appreciated.<br /><br />About the weird stall, I came to it by experience, but I've explicitly read about this somewhere too (K6/K7).<br /><br />Play with my example.. you'll see it's a short vs long form stall. The 1st and 2nd CMP produce the stall in a &quot;xor&quot; fashion.. both short = no stall, both long = no stall, otherwise stall.</div>
    <div class="meta">Posted on 2002-08-14 12:59:09 by Maverick</div>
   </div>
   <div class="post" id="post-53355">
    <div class="subject"><a href="#post-53355">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body">For Athlon SFENCE included in MMX Extension (22007.pdf, page 293). Detect by test 22bits of feature flags (20734.pdf, page 13).<br />I play with example. Every stall must have a causality. But realy cause this stall in long/short args?<br />I start from this code:<br /><pre><code><br />...<br />PROFILE Test1<br />...<br />align<br />Test1&#58;<br />	mov ecx,1<br />        CMP             ECX,124<br />        JAE             exit<br />        MOV             EAX,123<br />        CMP             ECX,124333<br />        CMOVC           EAX,EBX<br />        BT              EAX,ECX<br />        JNC             exit<br />exit&#58; ret<br /></code></pre><br />Clocks=3<br />Then made add one NOP after Test1:<br />Clocks=32<br />Add also one NOP<br />Clocks=5<br />..31,5,32,6,33,6...<br />Hmm.. What you can say? It only with my CPU (AthlonXP)? Anyone check this, please.</div>
    <div class="meta">Posted on 2002-08-14 15:33:32 by Nexo</div>
   </div>
   <div class="post" id="post-53367">
    <div class="subject"><a href="#post-53367">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body"><div class="quote"><br />I don't have my docs here.. but doesn't the Pentium II support SFENCE? </div><br /><br />Pentium III is the first Intel processor that has <strong>sfence</strong>.  Before Pentium III, Intel did not need <strong>sfence</strong> at all, because Intel's weakly ordered memory write became available (at least, to asm programmers) only with Pentium III.</div>
    <div class="meta">Posted on 2002-08-14 17:54:50 by Starless</div>
   </div>
   <div class="post" id="post-53388">
    <div class="subject"><a href="#post-53388">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body"><div class="quote"><br />What you can say? It only with my CPU (AthlonXP)? Anyone check this, please.</div>Oh, yes we are not alone. :)  Maybe, now you can understand some of my comments in previous test cases and discussions with <strong>Svin</strong>.  These are very funny processors and we merely probe their inner workings with such code, imho.  Here are my results:<pre><code>	;Total time &#40;Athlon TB&#41;&#58;<br />	; 2 or 3	&#40;no nop's&#41;<br />nop	; 3 or 31	&#40;one nop&#41;<br />nop	; 4		&#40;...etc.&#41;<br />nop	; 4<br />nop	; 6<br />nop	; 6 or 34<br />nop	; 4<br />nop	; 4 or 33<br />nop	; 6 or 10<br />nop	; 5 or 34<br />nop	; 6 or 8<br />nop	; 7 or 35<br />	mov ecx,1<br />	CMP             ECX,124<br />	JAE             exit<br />	MOV             EAX,123<br />	CMP             ECX,124333<br />	CMOVC           EAX,EBX<br />	BT              EAX,ECX<br />	JNC             exit<br />exit&#58;	ret</code></pre>These are very funny results, but highly reproducable! :grin:<br /><br /> Further tests would need to be made to exclude PROFILE being the source of error, but I do not have the time right now.</div>
    <div class="meta">Posted on 2002-08-14 21:52:45 by bitRAKE</div>
   </div>
   <div class="post" id="post-53476">
    <div class="subject"><a href="#post-53476">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body"><strong>bitRAKE</strong>, I known cause this stall :) Remember following rule and you save several clocks ;)<br /><pre><code><br />        &#91;B&#93;jnc&#91;/B&#93; exit<br />        nop ; K7 branch predict doesn't like RET after Jcc<br />exit&#58;<br />        &#91;B&#93;ret&#91;/B&#93;<br /></code></pre><br />But for me still strange <strong>Maverick's</strong> description stalls. May be it some other. Last example unfit for research this. Maverick, can you make other example?</div>
    <div class="meta">Posted on 2002-08-15 10:48:21 by Nexo</div>
   </div>
   <div class="post" id="post-53546">
    <div class="subject"><a href="#post-53546">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body"><strong>Nexo</strong>, does not change much.  New results:<pre><code>nop	; 7 or 11<br />nop	; 8 or 21<br />nop	; 5<br />nop	; 6 or 20<br />nop	; 6<br />nop	; 5 or 18<br />nop	; 6<br />nop	; 6 or 20<br />nop	; 3 or 4<br />nop	; 4<br />nop	; 3<br />	; 3 or 15<br />	mov ecx,1<br />	CMP             ECX,124<br />	JAE             exit<br />	MOV             EAX,123<br />	CMP             ECX,124333<br />	CMOVC           EAX,EBX<br />	BT              EAX,ECX<br />	JNC             exit<br />	nop ; K7 branch predict doesn't like RET after Jcc<br />exit&#58;	ret</code></pre></div>
    <div class="meta">Posted on 2002-08-15 22:40:35 by bitRAKE</div>
   </div>
   <div class="post" id="post-53569">
    <div class="subject"><a href="#post-53569">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body">Hi <strong>Nexo</strong>: the stalls changing with NOPs to me look like even/odd alignment issues that cause problems to the instruction decoders.<br /><br />About the short vs long stall instead, the following is from an older AMD optimization document (21924):<br /><br /><div class="quote"><em><br /><strong>Avoid superset dependencies</strong> ? Using the larger form of<br />a register immediate after an instruction uses the smaller form<br />creates a superset dependency and prevents parallel execution.<br />For example, avoid the following type of code:<br />OR AH,07h<br />ADD EAX,1555555h<br />One method for avoiding superset dependencies is to schedule<br />the instruction with the superset dependency (for example, the<br />ADD instruction) 4?6 instructions later than would normally be<br />preferable. Another method, useful in some cases, is to use the<br />MOVZX instruction to efficiently convert a byte-size value to a<br />doubleword-size value, which can then be combined with other<br />values in 32-bit operations.<br /></em></div><br /><br />Although this should probably apply to the K6 only, I found that it (maybe in minor part, but still) applies to the K7 as well.<br /><br />I also found some interesting branch cache misbehaviours with particular alignments, which in the very little time I had to investigate the problem, to me looked like some sort of undocumented intruction cache bank conficts.<br /><br />Anyway, I'm <em>extremely</em> busy with job right now.. I will have to delay these experiments and the release of the new PROFILEr of some days, but it's rock solid.. just as example, here's an early excerpt from the new docs:<br /><br />&lt;&lt;<br /><br />This is the new, official, improved version of my PROFILE tool. It is now assembler-independent, FPU aware, and has several small other improvements. For example, under a preemptive multitasking OS such as Windows, our process may be switched off in the middle of the profiling job. This means that the profiler will return a wrong value, because of the OS interference.<br />Although rare to happen, we have to take into account this possibility, to offer as maximum reliability as possible, even without an human/intelligent interpretation of the results. The new PROFILEr detects and fixes automatically abnormal results/situations, so you can always be sure that what you get is what the CPU really spends on your test routine.<br /><br />For example, this shows the consistency and precision of the new PROFILEr:<br /><pre><code><br />Test Code,           CPU&#58;  Pentium     Athlon  <br />just a RET&#58;                      0          0       cycles<br /> 1 NOP + RET&#58;                    1          1       cycles<br /> 2 NOP + RET&#58;                    1          1       cycles<br /> 3 NOP + RET&#58;                    2          1       cycles<br /> 4 NOP + RET&#58;                    2          2       cycles<br /> 5 NOP + RET&#58;                    3          2       cycles<br /> 6 NOP + RET&#58;                    3          2       cycles<br /> 7 NOP + RET&#58;                    4          3       cycles<br /> 8 NOP + RET&#58;                    4          3       cycles<br /> 9 NOP + RET&#58;                    5          3       cycles<br />10 NOP + RET&#58;                    5          4       cycles<br />11 NOP + RET&#58;                    6          4       cycles<br />12 NOP + RET&#58;                    6          4       cycles<br /></code></pre><br /><br />NOTE: for reasons I don't have the time to dig, new alignment rules is a page (4 KB), and <strong>must</strong> be followed.<br /><br />&gt;&gt;<br /><br />PS: so, which CPU's support SFENCE?<br /><br />Intel: PIII and PIV, some Celerons (best detection: SSE bit?)<br />AMD: K7 and Duron only? If not, best detection method = ?)</div>
    <div class="meta">Posted on 2002-08-16 03:52:02 by Maverick</div>
   </div>
   <div class="post" id="post-53636">
    <div class="subject"><a href="#post-53636">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body">Hi <strong>bitRAKE</strong>. I always receive with same clocks for each nop: 3,4,4,3,6,6,5,6,6,5,9,7... Here not jumping clocks. <br />I find source of Jcc/NOP/RETt stalls: AMD Library Reference [<a target="_blank" href="ftp://ftp.amd.com/pub/devconn/sdk/library.zip">ftp://ftp.amd.com/pub/devconn/sdk/library.zip</a>] - useful thing ;)<br />How you calculate clocks, PROFILE or other. I use different tools and appear similar results.</div>
    <div class="meta">Posted on 2002-08-16 12:24:17 by Nexo</div>
   </div>
   <div class="post" id="post-53637">
    <div class="subject"><a href="#post-53637">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body"><div class="quote"><br />Hi <strong>Nexo</strong>: the stalls changing with NOPs to me look like even/odd alignment issues that cause problems to the instruction decoders.<br /></div><strong>Maverick</strong>, i simplify last example:<pre><code><br />	clc<br />	jnc exit<br />;nop<br />exit&#58;	ret<br /></code></pre>and receive same result. All instruction decoding in DirectPath decoder three per cycle. Fetcher reads 16 bytes and can decode 24 bytes at all (no aligment problem here). The last code have less 16 bytes and can be easy decoded.<br /><div class="quote"><strong>About the short vs long stall instead, the following is from an older AMD optimization document (21924):<br />...<br />Although this should probably apply to the K6 only, I found that it (maybe in minor part, but still) applies to the K7 as well.<br /></div>Yes. It is also problem of Pentium Pro ... Pentium III processors (except Pentium4). It is described in docs Intel (24896602.pdf - Pentium 4) &amp; AMD (22007.pdf - Athlon).<br /><div class="quote"><strong>PS: so, which CPU's support SFENCE?<br /><br />Intel: PIII and PIV, some Celerons (best detection: SSE bit?)<br />AMD: K7 and Duron only? If not, best detection method = ?) </div><br />if (Intel) SFENCE=CPUID(1).edx[25]<br />if (AMD) SFENCE=CPUID(80000001h).edx[22]</div>
    <div class="meta">Posted on 2002-08-16 12:24:18 by Nexo</div>
   </div>
   <div class="post" id="post-53836">
    <div class="subject"><a href="#post-53836">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body"><div class="quote"><br />How you calculate clocks, PROFILE or other. I use different tools and appear similar results.</div>I use PROFILE above so we have comparable results, but I have my own profiling macros, too.</div>
    <div class="meta">Posted on 2002-08-17 23:20:08 by bitRAKE</div>
   </div>
   <div class="post" id="post-53973">
    <div class="subject"><a href="#post-53973">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body">Maveric,<br />I wander if it's possible to make design of your PROFILE as<br />startPROFILE<br />endPROFILE<br />To measure code between to libaratly choosen points.<br />I still need such testing (if not say &quot;mostly need&quot;).<br />And here is many ocasions when I coudn't test it as a piece of code with ret at the end.<br />Now, until the time, I use profile for testing snippents and procs, and use TimeTest_ON(OFF) for<br />described cases. I'd prefer PROFILE do it. What'd you say?</div>
    <div class="meta">Posted on 2002-08-18 13:33:17 by The Svin</div>
   </div>
   <div class="post" id="post-54070">
    <div class="subject"><a href="#post-54070">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body">Hi <strong>The Svin</strong>,<br />I'll work on it.. although I can't guarantee anything because some months ago I investigated this interesting possibility, but the results weren't satisfactory. Modern (exp. K7 &amp; P4) CPU's are extremely tricky, expecially if one has to do it in ring 3 (in ring 0 we'd have additional advantages like reading the TSC with a serializing instruction like RDMSR, while RDTSC is not serializing). I'll try again with more attention now. I have to take some more days, also because of a lot of job work to do, and of some kins at home for holiday.</div>
    <div class="meta">Posted on 2002-08-19 04:15:22 by Maverick</div>
   </div>
   <div class="post" id="post-54139">
    <div class="subject"><a href="#post-54139">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body">Hi Maverick!<br /><br />Your new version of the PROFILER is just great!<br />I was thinking about that same think, make an executable out of the FASM MACRO, and my idea was to use CreateProcess with the REALTIME_PRIORITY_CLASS flag on.<br />THat would probably work, because it starts a new whole page for the process, and then quickly returns control.<br />What do you think?<br /><br /><pre><code><br />;<br />; Maverick's PROFILER executable<br />;<br /><br />format PE GUI 4.0<br />entry start<br /><br />include 'include\kernel.inc'<br />include 'include\user.inc'<br />include 'include\comdlg.inc'<br /><br />include 'include\macro\stdcall.inc'<br />include 'include\macro\import.inc'<br /><br /><br />macro align value &#123; rb &#40;value-1&#41; - &#40;$ + value-1&#41; mod value &#125;<br /><br /><br />section '.data' data readable writeable<br /><br />  ofn	     OPENFILENAME<br /><br />  filter     db 'Executable files',0,'*.EXE',0<br />	     db 'All files',0,'*.*',0<br />	     db 0<br /><br />  file_title rb 100h<br /><br />  _message   db 'Cycles&#58; '<br />    .number  db '0000000000',0<br />  _caption   db 'Maverick?s PROFILER',0<br /><br />section '.code' code readable executable<br /><br />  start&#58;<br /><br />	invoke	GetModuleHandle,0<br />	mov	&#91;ofn.hInstance&#93;,eax<br />	mov	&#91;ofn.lStructSize&#93;,ofn.size<br />	mov	eax,NULL<br />	mov	&#91;ofn.hwndOwner&#93;,eax<br />	mov	&#91;ofn.lpstrFilter&#93;,filter<br />	mov	&#91;ofn.lpstrCustomFilter&#93;,NULL<br />	mov	&#91;ofn.nFilterIndex&#93;,1<br />	mov	&#91;ofn.lpstrFileTitle&#93;,file_title<br />	mov	&#91;ofn.nMaxFileTitle&#93;,100h<br />	mov	&#91;ofn.lpstrInitialDir&#93;,NULL<br /><br /><br />	invoke	VirtualAlloc,0,1000h,MEM_COMMIT,PAGE_READWRITE<br />	mov	esi,eax<br />	mov	&#91;ofn.lpstrFile&#93;,esi<br />	mov	&#91;ofn.nMaxFile&#93;,1000h<br />	mov	byte &#91;esi&#93;,0<br />	mov &#91;ofn.Flags&#93;,OFN_EXPLORER+OFN_FILEMUSTEXIST+OFN_HIDEREADONLY<br />	invoke	GetOpenFileName,ofn<br />	or	eax,eax<br />	jz	finish<br /><br />	mov	dword &#91;_PROFILE.ROUTINE&#93;,Address<br />	call	_PROFILE<br /><br />;------------------------------------------------------------------------------<br />	 align 64<br /><br />PROFILE.CYCLES&#58; 		DD		0<br />				DD		0<br />_PROFILE.EMPTY&#58; 		DD		0				; how many cycles it takes for a simple RET to be executed on the host CPU<br />				DD		0<br />_PROFILE.ROUTINE&#58;		DD		0<br />_PROFILE.RETURN&#58;		DD		0<br />_PROFILE.IN.EAX&#58;		DD		0<br />_PROFILE.IN.EBX&#58;		DD		0<br />_PROFILE.IN.ECX&#58;		DD		0<br />_PROFILE.IN.EDX&#58;		DD		0<br />_PROFILE.IN.ESI&#58;		DD		0<br />_PROFILE.IN.EDI&#58;		DD		0<br />_PROFILE.IN.EBP&#58;		DD		0<br />_PROFILE.IN.EFL&#58;		DD		0<br />_PROFILE.OUT.EAX&#58;		DD		0<br />_PROFILE.OUT.EBX&#58;		DD		0<br />_PROFILE.OUT.ECX&#58;		DD		0<br />_PROFILE.OUT.EDX&#58;		DD		0<br />_PROFILE.OUT.EFL&#58;		DD		0<br />_PROFILE.RETADDR&#58;		DD		0<br /><br />  startupinfo STARTUPINFO<br />  processinfo PROCESSINFO<br /><br />; the following is to make sure that data and code are on a different page.<br />				 align		 4096				 ; note&#58; *YOU* have to provide alignment<br />;------------------------------------------------------------------------------<br /><br />				align		64				; align to a cache entry on all CPU's<br />_PROFILE&#58;<br />				MOV		DWORD &#91;_PROFILE.IN.EAX&#93;,EAX	; saves INPUT EAX &#40;will be trashed by CPUID&#41;<br />				MOV		DWORD &#91;_PROFILE.IN.EBX&#93;,EBX	; saves INPUT EBX &#40;will be trashed by CPUID&#41;<br />				MOV		DWORD &#91;_PROFILE.IN.ECX&#93;,ECX	; saves INPUT ECX &#40;will be trashed by CPUID&#41;<br />				MOV		DWORD &#91;_PROFILE.IN.EDX&#93;,EDX	; saves INPUT EDX &#40;will be trashed by CPUID&#41;<br />				MOV		DWORD &#91;_PROFILE.IN.ESI&#93;,ESI	; saves INPUT EAX &#40;will be trashed by the routine to be tested, which will be called multiple times&#41;<br />				MOV		DWORD &#91;_PROFILE.IN.EDI&#93;,EDI	; saves INPUT EBX &#40;will be trashed by the routine to be tested, which will be called multiple times&#41;<br />				MOV		DWORD &#91;_PROFILE.IN.EBP&#93;,EBP	; saves INPUT ECX &#40;will be trashed by the routine to be tested, which will be called multiple times&#41;<br />				PUSHFD<br />				POP		DWORD &#91;_PROFILE.IN.EFL&#93; 	; saves INPUT CPU EFLAGS<br />				POP		DWORD &#91;_PROFILE.RETURN&#93; 	; saves return address<br />				PUSH		DWORD &#91;_PROFILE.ROUTINE&#93;	; saves requested _PROFILE.ROUTINE<br />				MOV		DWORD &#91;_PROFILE.ROUTINE&#93;,.empty ; first we'll profile a simple RET<br />				MOV		DWORD &#91;_PROFILE.RETADDR&#93;,.ret1<br />				JMP DWORD	.profile			; make sure it gets cached<br />.ret1&#58;				MOV		DWORD &#91;_PROFILE.RETADDR&#93;,.ret2<br />				JMP DWORD	.profile			; profile for real &#40;well, let it set up&#41;<br />.ret2&#58;				MOV		DWORD &#91;_PROFILE.RETADDR&#93;,.ret3<br />				JMP DWORD	.profile			; profile for real &#40;well, let it set up again&#41;<br />.ret3&#58;				MOV		DWORD &#91;_PROFILE.RETADDR&#93;,.ret4<br />				JMP DWORD	.profile			; profile for real &#40;well, let it set up one final time&#41;<br />.ret4&#58;				MOV		DWORD &#91;_PROFILE.RETADDR&#93;,.ret5<br />				JMP DWORD	.profile			; profile for real<br />.ret5&#58;				MOV		EAX,DWORD &#91;PROFILE.CYCLES+0&#93;<br />				MOV		EDX,DWORD &#91;PROFILE.CYCLES+4&#93;<br />				MOV		DWORD &#91;_PROFILE.EMPTY+0&#93;,EAX	; saves RET cycles count<br />				MOV		DWORD &#91;_PROFILE.EMPTY+4&#93;,EDX<br />				;<br />				POP		DWORD &#91;_PROFILE.ROUTINE&#93;	; restores requested _PROFILE.ROUTINE<br />				MOV		DWORD &#91;_PROFILE.RETADDR&#93;,.ret6<br />				JMP BYTE	.profile			; make sure it gets cached<br />.ret6&#58;				MOV		DWORD &#91;_PROFILE.RETADDR&#93;,.ret7<br />				JMP BYTE	.profile			; profile for real<br />.ret7&#58;				MOV		DWORD &#91;_PROFILE.RETADDR&#93;,.ret8<br />				JMP BYTE	.profile			; make sure it gets cached<br />.ret8&#58;				MOV		DWORD &#91;_PROFILE.RETADDR&#93;,.ret9<br />				JMP BYTE	.profile			; profile for real<br />.ret9&#58;				MOV		DWORD &#91;_PROFILE.RETADDR&#93;,.ret10<br />				JMP BYTE	.profile			; make sure it gets cached<br />.ret10&#58; 			MOV		EAX,DWORD &#91;_PROFILE.EMPTY+0&#93;	; subtracts simple RET overhead<br />				MOV		EDX,DWORD &#91;_PROFILE.EMPTY+4&#93;<br />				SUB		DWORD &#91;PROFILE.CYCLES+0&#93;,EAX	; saves cycles, low 32bit<br />				SBB		DWORD &#91;PROFILE.CYCLES+4&#93;,EDX	; saves cycles, high 32bit<br />				MOV		EAX,DWORD &#91;_PROFILE.OUT.EAX&#93;	; gives OUTPUT EAX<br />				MOV		EBX,DWORD &#91;_PROFILE.OUT.EBX&#93;	; gives OUTPUT EBX<br />				MOV		ECX,DWORD &#91;_PROFILE.OUT.ECX&#93;	; gives OUTPUT ECX<br />				MOV		EDX,DWORD &#91;_PROFILE.OUT.EDX&#93;	; gives OUTPUT EDX<br />				PUSH		DWORD &#91;_PROFILE.OUT.EFL&#93;<br />				POPFD						; gives CPU EFLAGS<br />				JMP		DWORD &#91;_PROFILE.RETURN&#93; 	; returns to caller<br />.profile&#58;<br />				MOV		EAX,DWORD &#91;PROFILE.CYCLES+0&#93;	; touches caches<br />				MOV		EDX,DWORD &#91;PROFILE.CYCLES+4&#93;<br />				MOV		EAX,DWORD &#91;_PROFILE.IN.EAX&#93;<br />				MOV		EBX,DWORD &#91;_PROFILE.IN.EBX&#93;<br />				MOV		ECX,DWORD &#91;_PROFILE.IN.ECX&#93;<br />				MOV		EDX,DWORD &#91;_PROFILE.IN.EDX&#93;<br />				MOV		ESI,DWORD &#91;_PROFILE.IN.ESI&#93;<br />				MOV		EDI,DWORD &#91;_PROFILE.IN.EDI&#93;<br />				MOV		EBP,DWORD &#91;_PROFILE.IN.EBP&#93;<br />				MOV		EAX,DWORD &#91;_PROFILE.IN.EFL&#93;<br />				MOV		EAX,DWORD &#91;_PROFILE.OUT.EAX&#93;<br />				MOV		EBX,DWORD &#91;_PROFILE.OUT.EBX&#93;<br />				MOV		ECX,DWORD &#91;_PROFILE.OUT.ECX&#93;<br />				MOV		EDX,DWORD &#91;_PROFILE.OUT.EDX&#93;<br />				MOV		EAX,DWORD &#91;_PROFILE.OUT.EFL&#93;<br />				MOV		EAX,DWORD &#91;_PROFILE.ROUTINE&#93;<br />				MOV		ECX,32<br />.stack&#58; 			PUSH		EAX				; touches stack<br />				LOOP		.stack<br />				ADD		esp,128<br />				XOR		EAX,EAX<br />				CPUID						; flush pipelines<br />				RDTSC<br />				MOV		DWORD &#91;PROFILE.CYCLES+0&#93;,EAX	; saves TSC, low 32bit<br />				MOV		DWORD &#91;PROFILE.CYCLES+4&#93;,EDX	; saves TSC, high 32bit<br />				XOR		EAX,EAX<br />				CPUID						; flush pipelines<br />				MOV		EAX,DWORD &#91;_PROFILE.IN.EAX&#93;	; restores INPUT EAX<br />				MOV		EBX,DWORD &#91;_PROFILE.IN.EBX&#93;	; restores INPUT EBX<br />				MOV		ECX,DWORD &#91;_PROFILE.IN.ECX&#93;	; restores INPUT ECX<br />				MOV		EDX,DWORD &#91;_PROFILE.IN.EDX&#93;	; restores INPUT EDX<br />				MOV		ESI,DWORD &#91;_PROFILE.IN.ESI&#93;<br />				MOV		EDI,DWORD &#91;_PROFILE.IN.EDI&#93;<br />				MOV		EBP,DWORD &#91;_PROFILE.IN.EBP&#93;<br />				PUSH		DWORD &#91;_PROFILE.IN.EFL&#93;<br />				POPFD						; restores CPU EFLAGS<br />				CALL		DWORD &#91;_PROFILE.ROUTINE&#93;	; calls the routine to be tested<br />				MOV		DWORD &#91;_PROFILE.OUT.EAX&#93;,EAX	; saves OUTPUT EAX<br />				MOV		DWORD &#91;_PROFILE.OUT.EBX&#93;,EBX	; saves OUTPUT EBX<br />				MOV		DWORD &#91;_PROFILE.OUT.ECX&#93;,ECX	; saves OUTPUT ECX<br />				MOV		DWORD &#91;_PROFILE.OUT.EDX&#93;,EDX	; saves OUTPUT EDX<br />				PUSHFD<br />				POP		DWORD &#91;_PROFILE.OUT.EFL&#93;	; saves OUTPUT CPU EFLAGS<br />				XOR		EAX,EAX<br />				CPUID						; flush pipelines<br />				RDTSC<br />				XCHG		DWORD &#91;PROFILE.CYCLES+0&#93;,EAX<br />				XCHG		DWORD &#91;PROFILE.CYCLES+4&#93;,EDX<br />				SUB		DWORD &#91;PROFILE.CYCLES+0&#93;,EAX	; saves TSC, low 32bit<br />				SBB		DWORD &#91;PROFILE.CYCLES+4&#93;,EDX	; saves TSC, high 32bit<br />				JMP		DWORD &#91;_PROFILE.RETADDR&#93;<br /><br />				align		64				; align to a cache entry on all CPU's<br />.empty&#58; 			RET<br /><br />; ---------------------------------------------------------------------------<br /><br />Address&#58;<br />	mov	eax,&#91;startupinfo.size&#93;<br />	mov	&#91;startupinfo.cb&#93;,eax<br />	invoke CreateProcess,file_title,0,0,0,0,REALTIME_PRIORITY_CLASS,0,0,startupinfo,processinfo<br />	;To be very accurate we should also substract CreateProcess' prologue and those two movs.<br />	;I'll implement that later ;&#41;<br />	invoke TerminateProcess,processinfo.hProcess,0<br /><br />	xor eax,eax<br />	mov eax,&#91;PROFILE.CYCLES&#93;<br />	mov edi,_message.number<br />	mov ecx,10<br />	add edi,ecx<br />convert&#58;<br />	xor edx,edx<br />	div ecx<br />	add dl,30h<br />	mov &#91;edi&#93;,dl<br />	dec edi<br />	cmp eax,0<br />	jne convert<br /><br />	invoke MessageBox,0,_message,_caption,MB_OK<br /><br />finish&#58;<br />	invoke ExitProcess,0<br /><br />section '.idata' import data readable writeable<br /><br />  library kernel,'KERNEL32.DLL',\<br />	  user,'USER32.DLL',\<br />	  com,'COMDLG32.DLL'<br /><br />  kernel&#58;<br />  import GetModuleHandle,'GetModuleHandleA',\<br />	 VirtualAlloc,'VirtualAlloc',\<br />	 CreateProcess,'CreateProcessA',\<br />	 ExitProcess,'ExitProcess'<br /><br />  user&#58;<br />  import MessageBox,'MessageBoxA'<br /><br />  com&#58;<br />  import GetOpenFileName,'GetOpenFileNameA'<br /><br /></code></pre><br /><br />Right now, it doesn't really work, but I'm still working on it.<br />I'm using your profiler unchanged, because I don't know exactly how it works, I get lost in <pre><code>CPUID<br />RTCSC</code></pre> Can you explain it a little?<br /><br /><br />ANd if anybody sees what's wrong with the code, please feel free...</div>
    <div class="meta">Posted on 2002-08-19 11:34:24 by slop</div>
   </div>
   <div class="post" id="post-54151">
    <div class="subject"><a href="#post-54151">PROFILE: Is there a way to get stable results?</a></div>
    <div class="body">Hi <strong>sloppy</strong>, you wrote: <em>Your new version of the PROFILER is just great!</em><br /><br />Hardly; I haven't released it yet. ;P<br /><br />The FASM code I released some days ago is the old NASM one simply rewritten to fit FASM syntax.<br /><br />The new PROFILE (unreleased yet) is a major rewrite.<br /><br /><em>I was thinking about that same think, make an executable out of the FASM MACRO, and my idea was to use CreateProcess with the REALTIME_PRIORITY_CLASS flag on.<br />THat would probably work, because it starts a new whole page for the process, and then quickly returns control.<br />What do you think?</em><br /><br />REALTIME_PRIORITY_CLASS would help, but it's not necessary on ~small routines. In the case that the task is switched away, the (next) PROFILE won't go in error, though, because it selects the most accurate result from 16.. which anyway are almost always the same.. so you may wonder why 16 and not 2 or 3.. well.. reason: let's be paranoid :grin: . Seriously, it has to do with branch prediction misbehaviours, FPU, etc.. 8 would suffice, but I've chosen 16 with future CPU's in mind (or those I have no access to, like the Pentium IV).<br /><br />Sorry, I'm not even at home anymore (neither at my gf's home).. I apologize but there's still some days to wait for the new PROFILE. You've all surely much more interesting things to do in the while, though.<br /><br />PS: about CPUID and RDTSC:<br /><br />CPUID is used here not because it tells you which CPU it's running on, but because it's a <em>serializing instruction</em> (check the Intel manuals for the details), and in substance helps giving accurate results (together with other solutions).<br /><br />RDTSC accesses to an internal clock-frequency 64 bit counter, which is used to say how many cycles a subroutine takes (but alone wouldn't be precise, because RDTSC is not a serializing instruction, unfortunately (wish we were in ring 0, and we'd use RDMSR, which is)).<br /><br />Anyway.. it's pretty basic stuff, but the implementation is careful (expecially the next PROFILE).</div>
    <div class="meta">Posted on 2002-08-19 13:52:49 by Maverick</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=7298&amp;page=1" style="">&laquo;</a><a href="../?id=7298&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="7298" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=7298&amp;page=3">&gt;</a><a href="../?id=7298&amp;page=3">&raquo;</a></form>  </div>
 </body>
</html>