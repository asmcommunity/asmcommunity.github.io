<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Trying to prove a (rather high-level) theory... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=21105" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=35">Toolchain Development</a> &raquo; <a href="../?id=21105">Trying to prove a (rather high-level) theory...</a></p>
   <div class="post" id="post-159868">
    <div class="subject"><a href="#post-159868">Trying to prove a (rather high-level) theory...</a></div>
    <div class="body"><br />I&#39;m developing a LISP-based language/LISP dialect to test the following thesis:<br />&quot;By making bytecode/machinecode instructions imbeddable in LISP S-expressions/lists, the entire LISP language&#39;s primitives may be implemented as macrofunctions that return such an S-Expression/list of bytecode/machinecode.&nbsp; Further, compilation optimizations may be performed by manipulating an S-expression/list composed of bytecode/machinecode.&quot;<br /><br />Currently I&#39;m trying to struggle with garbage collection, and I think the algo I&#39;ve thought up sucks (wanting to support multiple threads without being able to view their registers is rather bad, since this means I can&#39;t safely throw away anything the current thread didn&#39;t create).&nbsp; I can probably live easier if I didn&#39;t need to support multiple threads, but I really really really want to try and go for multiple threads.&nbsp; It&#39;s partly generational, bit of a mark-and-sweep.&nbsp; I&#39;m wondering about mark-and-compact but it would probably be difficult without using handles, or using some kind of rather slowish scheme to figure out where a memory address now is.<br /><br />As to the &quot;bytecode&quot;, I&#39;m currently developing a bastardized version of intel assembly language, one nearer to the way it&#39;s actually encoded rather than to the intel-specified syntax.&nbsp; Guess what?&nbsp; Most instructions have what I call a &quot;modreg&quot;; it&#39;s what specifies an eax,edx or a [4],eax (intel labels them as &quot;mod | reg | r/m&quot; according to the fields within the byte; hence I call them modreg).&nbsp; A few instructions have what I call a &quot;modmem&quot;, which only involves a memory address expression, such as label or label[4]; instructions such as mov foo,4 use modmems.&nbsp; Some of the operand&#39;s bits, too (3, to be specific) actually overflow into the modmem (some of intel&#39;s instructions consistently drop the reg field of modregs, so I now have a new class of bytecode, modmem, that I&#39;m handling separately from modreg).<br /><br />I&#39;m developing my own &quot;bytecode&quot; because I&#39;m too lazy to go all the way to writing a &quot;real&quot; assembler.&nbsp; Besides, it strikes me as being ridiculously difficult to figure out how to encode label as a LISP S-expression.<br /><br />So what do I want?&nbsp; Nothing much, just a couple comments and a bit of a place to talk about this idea. woot woot.<br /><br />This is of course solely in my nonexistent spare time, between courting a girl who lives a couple hundred miles from where I happen to live (on a different island, at that), keeping my boss off my neck (my performance is dropping because of some.... personal emotional problems, mostly related to a previous girl who wasn&#39;t my girlfriend), writing bits of that novel I&#39;m writing (about the Golden Lily operation, pre-Hispanic Philippines, and modern microelectronics), and trying to get enough sleep, food, and exercise to keep myself out of the hospital (it&#39;s 1251AM where I am now, I forgot to eat lunch yesterday because I was working, and my body still aches from our basketball round yesterday afternoon).&nbsp; Gosh, I can&#39;t even update myself on what&#39;s happening to Bogdan&#39;s HE.&nbsp; Sorry Bogdan, what&#39;s up with HE?<br /><br />Anyway, any comments, suggestions, criticism, flames, etc. are welcome.&nbsp; Anything but silence.<br /><br /></div>
    <div class="meta">Posted on 2005-05-08 12:06:06 by AmkG</div>
   </div>
   <div class="post" id="post-159905">
    <div class="subject"><a href="#post-159905">Re: Trying to prove a (rather high-level) theory...</a></div>
    <div class="body"> :shock:<br /><br />&quot;on a different island&quot; <br /><br />!!!<br /><br />goodluck</div>
    <div class="meta">Posted on 2005-05-09 10:30:17 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-159918">
    <div class="subject"><a href="#post-159918">Re: Trying to prove a (rather high-level) theory...</a></div>
    <div class="body"><div class="quote"><br />Currently I&#39;m trying to struggle with garbage collection, and I think the algo I&#39;ve thought up sucks (wanting to support multiple threads without being able to view their registers is rather bad, since this means I can&#39;t safely throw away anything the current thread didn&#39;t create).? I can probably live easier if I didn&#39;t need to support multiple threads, but I really really really want to try and go for multiple threads.? It&#39;s partly generational, bit of a mark-and-sweep.? I&#39;m wondering about mark-and-compact but it would probably be difficult without using handles, or using some kind of rather slowish scheme to figure out where a memory address now is.<br /></div><br /><br />Normally, the GC is called by an allocator when it can&#39;t immediately get the memory it needs. It can also be invoked on demand by the programmer. If those are the only times, then all you need to do is lock the heap (well, actually the GC itself) so that a second attempt to GC must wait for the other thread to finish. It is defiinitely hard if you want to run the GC concurrently in its own thread. For the last case, I would suggest researching what others have done.<br /><br /><div class="quote"><br />I&#39;m developing my own &quot;bytecode&quot; because I&#39;m too lazy to go all the way to writing a &quot;real&quot; assembler.? Besides, it strikes me as being ridiculously difficult to figure out how to encode label as a LISP S-expression.<br /></div><br /><br />So (opcode register displacement index1 index2 scale immediate) and using NIL for missing components is not an answer?</div>
    <div class="meta">Posted on 2005-05-10 00:08:09 by tenkey</div>
   </div>
   <div class="post" id="post-159976">
    <div class="subject"><a href="#post-159976">Re: Trying to prove a (rather high-level) theory...</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br />Currently I&#39;m trying to struggle with garbage collection, and I think the algo I&#39;ve thought up sucks (wanting to support multiple threads without being able to view their registers is rather bad, since this means I can&#39;t safely throw away anything the current thread didn&#39;t create).? I can probably live easier if I didn&#39;t need to support multiple threads, but I really really really want to try and go for multiple threads.? It&#39;s partly generational, bit of a mark-and-sweep.? I&#39;m wondering about mark-and-compact but it would probably be difficult without using handles, or using some kind of rather slowish scheme to figure out where a memory address now is.<br /></div><br /><br />Normally, the GC is called by an allocator when it can&#39;t immediately get the memory it needs. It can also be invoked on demand by the programmer. If those are the only times, then all you need to do is lock the heap (well, actually the GC itself) so that a second attempt to GC must wait for the other thread to finish. It is defiinitely hard if you want to run the GC concurrently in its own thread. For the last case, I would suggest researching what others have done.<br /></div><br /><br />Actually I do plan on locking the heap (or rather, my heaps).? My problem is that I don&#39;t know how to access the stack/registers of another thread.? Since in theory I could share data with another thread (say, via a global), I want to make sure I don&#39;t trash anything that might be used by another thread.? The scheme I&#39;ve worked out initially trashes the most recent data allocated in the current thread (the one which called the GC), then recovers anything referenced from the root set.? The root set is:<br />1. the virtual V register (intel EBP)<br />2. the stack<br />3. all memory areas currently allocated<br /><br />Since we free only from the current thread, anything allocated on another thread would be part of the root set (as per #3) and would recover any memory passed to it.<br /><br />Unfortunately it strikes me that #3 would take a long time, which is why I&#39;m not very hot on this....<br /><br /><div class="quote"><br /><div class="quote"><br />I&#39;m developing my own &quot;bytecode&quot; because I&#39;m too lazy to go all the way to writing a &quot;real&quot; assembler.? Besides, it strikes me as being ridiculously difficult to figure out how to encode label as a LISP S-expression.<br /></div><br /><br />So (opcode register displacement index1 index2 scale immediate) and using NIL for missing components is not an answer?<br /></div><br /><br />I realized an even better option.? As it happens, the &quot;mutator&quot; (my bytecode-level optimizer) would have an easier time if I were able to give a more &quot;normal&quot; (intel-based) syntax.? I decided on the following:<br />1. Registers are symbols A B C D (corresponding to eax ebx ecx edx), V (ebp), X Y (esi edi), S (esp).<br />2. Memory references will be enclosed in a list.? For instance, DWORD PTR  would be (A).? All objects in such a memory reference list would be &quot;added&quot; together, in the same sense that the assembler &quot;adds&quot; foo[4].<br />3. An &quot;embed&quot; character, #, will imply that the succeeding object&#39;s numeric value (the pointer) will be included.? Since small numbers encodable in 16 bits would be an object too, we could encode:<br />mov DWORD PTR [4],5<br />as:<br />(MOV (A #4) #5)<br />and:<br />mov DWORD PTR z[8],eax<br />as:<br />(MOV (#z #8) A)<br />this allows us to use A, B, C, D etc. as both a symbol and a register name.<br />4. scaled indices would themselves be in lists:<br />mov DWORD PTR foo,3<br />=&gt;<br />(MOV (#foo (A 4)) 3)<br /><br /><br /><br />OMG tenkey we think alike!!!<br /><div class="quote"><br />I have worked out a GC (Garbage Collection) scheme for objects. Each object has an embedded size field because it&#39;s simpler and faster to GC than if the size is stored in a class or &quot;type&quot; table. Because I&#39;m allocating in DWORDs, the size has two redundant bits (they are always 0). If I use MOVSD, I can eliminate the two bits by storing the DWORD count instead of the object size. And because the objects can only be allocated in user memory (the lower 2G), there is another redundant bit. I can use one bit to indicate that an object has been collected, and another bit to indicate whether the object contains pointers only or no pointers. The all-or-none pointer property of objects is also a way to simplify GC. The GC will probably be the only code that actually uses this size-and-attributes field.<br /></div><br />The rather creepy part is that my defines are done this way:<br /><pre><code><br />GC_USEDBIT EQU 80000000h<br />GC_DUMBBIT EQU 40000000h<br />GC_GENBIT EQU 20000000h<br />GC_LENGTH EQU 1fffffffh<br /></code></pre><br />My reasoning was the same as yours: two bits free because of DWORD boundaries, and another bit because it&#39;s not likely to reach addresses in the 80000000h range.<br /><br />My &quot;USEDBIT&quot; corresponds to &quot;an object has been collected&quot;, my &quot;DUMBBIT&quot; corresponds to &quot;contains pointers only or no pointers.&quot;&nbsp; The &quot;GENBIT&quot; was free and allocated for generational GC.&nbsp; I do have an additional field, for a pointer to the previous allocated memory area, since I need to keep track of which areas were allocated in the current thread.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2005-05-12 01:13:14 by AmkG</div>
   </div>
   <div class="post" id="post-159984">
    <div class="subject"><a href="#post-159984">Re: Trying to prove a (rather high-level) theory...</a></div>
    <div class="body"><div class="quote"><br /> :shock:<br /><br />&quot;on a different island&quot; <br /><br />!!!<br /><br />goodluck<br /></div><br />The country where I live, the Philippines, is an archipelago composed of several islands.&nbsp; And actually, she&#39;s my girlfriend.&nbsp; Sort of.&nbsp; Err.&nbsp; Gosh, I guess I know more about hashing functions than about that sort of thing.&nbsp;  :P :P :lol:<br />Thanks for the luck anyway.<br /></div>
    <div class="meta">Posted on 2005-05-12 05:29:54 by AmkG</div>
   </div>
   <div class="post" id="post-160108">
    <div class="subject"><a href="#post-160108">Re: Trying to prove a (rather high-level) theory...</a></div>
    <div class="body"><div class="quote"><br />Actually I do plan on locking the heap (or rather, my heaps).? My problem is that I don&#39;t know how to access the stack/registers of another thread.? Since in theory I could share data with another thread (say, via a global), I want to make sure I don&#39;t trash anything that might be used by another thread.? The scheme I&#39;ve worked out initially trashes the most recent data allocated in the current thread (the one which called the GC), then recovers anything referenced from the root set.? The root set is:<br />1. the virtual V register (intel EBP)<br />2. the stack<br />3. all memory areas currently allocated<br /><br />Since we free only from the current thread, anything allocated on another thread would be part of the root set (as per #3) and would recover any memory passed to it.<br /><br />Unfortunately it strikes me that #3 would take a long time, which is why I&#39;m not very hot on this....<br /></div><br /><br />I forgot about the registers. The compiler needs to ensure all heap pointers loaded into registers are rooted in memory. Heavy optimization may mean that a compacting or copy collector is not a good idea. <br /><br />One issue I had with putting heap pointers on the ESP stack was the nonheap data that exists in a callback (window proc). I wanted a heap that worked in a GUI app. I was looking at two options: creating a second EBP chain that chained together application stack frames, and implementing the stack in the heap.</div>
    <div class="meta">Posted on 2005-05-15 18:52:11 by tenkey</div>
   </div>
   <div class="post" id="post-160111">
    <div class="subject"><a href="#post-160111">Re: Trying to prove a (rather high-level) theory...</a></div>
    <div class="body">As to the registers, I followed STDCALL&#39;s rule that the called procedure/function can trash all registers except ebp (V), ebx (B), esi (X) and edi (Y).&nbsp; I modified the rule so that only V is saved by a macro call, and Y can never be used because it keeps track of the memory areas allocated in the current thread.&nbsp; Hence, the macros must assume that all registers are trashed if they embed a function call; they must save any registers on the stack, at least.&nbsp; In case the function call is actually a macro that expands to bytecode that <em>isn&#39;t</em> a function call, removing the saving of registers would be the task of my &quot;mutator&quot; or bytecode-level optimizer.<br /><br />Since I want my LISP to also be able to communicate well with windows (using the IA32 native code rather limits me to that OS, after all), my GC will have to check my stack&#39;s contents if they are indeed pointers to memory areas.&nbsp; A second problem is with function calls.&nbsp; Function return addresses point to the middle of a code area, so I will have to figure out some way to get the start of a code area from a function return address.&nbsp; In theory, after all, I could release a function from all memory areas while that function is calling me.&nbsp; Still, the function isn&#39;t free because it&#39;s still running.<br /><br />Because I want to have lexical binding and persistent environments in my LISP, my local variables will have to be on the heap too, which is just too bad.&nbsp; I guess I can rewrite my &#39;fn macro (equivalent to &#39;lambda on other LISPs) so that it will attempt to guess if the function&#39;s environment could possibly persist, and if definitely not, will keep locals on the stack.<br /><br />Thanks for the interest!<br /><br /></div>
    <div class="meta">Posted on 2005-05-15 21:37:59 by AmkG</div>
   </div>
  </div>
 </body>
</html>