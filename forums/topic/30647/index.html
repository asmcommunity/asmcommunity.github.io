<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>A lots of questions about Windows API - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30647" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=116">Windows</a> &raquo; <a href="../?id=30647">A lots of questions about Windows API</a></p>
   <div class="post" id="post-214912">
    <div class="subject"><a href="#post-214912">A lots of questions about Windows API</a></div>
    <div class="body">Well, i can sadly say that i have almost no experience with Windows API. It seems to be so confusing to me. I hope you guys can explain me what is going on.<br /><br />I have the following code written in C:<br /><pre><code>#include &lt;windows.h&gt;<br /><br />HINSTANCE gInstance;<br /><br />LRESULT CALLBACK WndProc(<br />	HWND HandleWindow,<br />	UINT message,<br />	WPARAM wParam,<br />	LPARAM lParam)<br />{<br />	PAINTSTRUCT PaintStruct;<br />	HDC HandleDeviceContext;<br />	HDC HDCBuffer;<br />	HANDLE Image;<br /><br />	switch(message)<br />	{<br />		case WM_PAINT:<br />			HandleDeviceContext = BeginPaint(HandleWindow, &amp;PaintStruct);<br /><br />			Image = LoadImage(<br />				NULL,<br />				&quot;exercising.bmp&quot;,<br />				IMAGE_BITMAP,<br />				384,<br />				256,<br />				LR_LOADFROMFILE<br />			);<br />			HDCBuffer = CreateCompatibleDC(HandleDeviceContext);<br />			SelectObject(HDCBuffer, Image);<br />			BitBlt(<br />				HandleDeviceContext,<br />				100,<br />				100,<br />				384,<br />				246,<br />				HDCBuffer,<br />				0,<br />				0,<br />				SRCCOPY<br />			);<br />			DeleteDC(HDCBuffer);<br />			DeleteObject(Image);<br /><br />			EndPaint(HandleWindow, &amp;PaintStruct);<br />			break;<br />		case WM_DESTROY:<br />			PostQuitMessage(0);<br />			break;<br />		default:<br />			return DefWindowProc(<br />				HandleWindow,<br />				message,<br />				wParam,<br />				lParam);<br />	}<br />	return 0;<br />}<br /> <br />int WINAPI wWinMain(<br />	HINSTANCE hInstance,<br />	HINSTANCE prevInstance,<br />	LPWSTR cmdLine,<br />	int cmdShow)<br />{<br />	gInstance = hInstance;<br /><br />	WNDCLASSEX WindowClass = {<br />		sizeof(WNDCLASSEX),<br />		CS_HREDRAW | CS_VREDRAW,<br />		WndProc,<br />		NULL, //cbClsExtra<br />		NULL, //cbWndExtra<br />		hInstance,<br />		NULL, //hIcon<br />		LoadCursor(NULL, IDC_ARROW), //hCursor<br />		(HBRUSH)(COLOR_WINDOW+1), //hbrBackground<br />		NULL, //lpszMenuName<br />		&quot;MainClass&quot;, //lpszClassName<br />		NULL //hIconSm<br />	};<br />	RegisterClassEx(&amp;WindowClass);<br /><br />	HWND HandleWindow = CreateWindowA(<br />		&quot;MainClass&quot;,<br />		&quot;WindowTitle&quot;,<br />		WS_OVERLAPPEDWINDOW,<br />		CW_USEDEFAULT,<br />		CW_USEDEFAULT,<br />		CW_USEDEFAULT,<br />		CW_USEDEFAULT,<br />		NULL, //hWndParent<br />		NULL, //hMenu<br />		hInstance,<br />		NULL //lpPraram<br />	);<br /><br />	ShowWindow(HandleWindow, cmdShow);<br />	<br />	MSG Message = {0};<br />	while (Message.message != WM_QUIT)<br />	{<br />		if (PeekMessage(<br />			&amp;Message,<br />			NULL, //HWND<br />			NULL, //wMsgFilterMin<br />			NULL, //wMsgFilterMax<br />			PM_REMOVE))<br />		{<br />			TranslateMessage(&amp;Message);<br />			DispatchMessage(&amp;Message);<br />		}<br />	}<br /><br />	UnregisterClass(&quot;MainClass&quot;, hInstance);<br /><br />	return static_cast&lt;int&gt;(Message.wParam);<br />}</code></pre><br /><br />What it pretty much does is to:<br />-Create a simple window<br />-Loads a bitmap with filename &quot;exercising.bmp&quot; to the created Window<br /><br />So now, let&#039;s get over the code. First in wWinMain() function, the first thing it does is to fill up WNDCLASSEX{} structure and &quot;register it as a class&quot; using the function RegisterClassEx(). Then it uses the registered class&#039; handle to create a window using CreateWindowA() function.<br /><br />a) What exactly is the exact use of this RegisterClassEx()?<br />a.1 -As far i can tell is that it prepares the Window&#039;s structure information and registers it (to where does it register?) to be ready to create a Window. And i am not sure what exactly is this &quot;class&quot; they are referring to register.<br />a.2 -The big question is that why does it have to be a two step function in order to create a Window. Couldn&#039;t it be done in just CreateWindowA() where one of the parameters is the WNDCLASSEX{} structure? It just doesn&#039;t make sense to me to register (to wherever it goes) a structure. If i wanted re-usability, i can just re-use the original structure. If i wanted to have multiple window settings i could just have multiple structures. I mean, to have a structure i already need memory allocation. And to register the structure into a class, i need to use additional memory. Can&#039;t WindowClassEx() create a Window and register the structure in one go? What is the reason to have two separate functions?<br /><br />So, after creating the window, it makes the created window visible using ShowWindow() function. Then it enters a while loop which checks for inputs associated with the window we just created. Before entering the while loop we cleared the MSG{} structure. So the first check for the while loop the &quot;.message&quot; item is not WM_QUIT and continues down. It peeks for messages in the queue, if there is any message translate it TranslateMessage() and dispatch it DispatchMessage(). But because we cleared the structure there should be nothing on the queue.<br /><br />b) What does TranslateMessage() translate exactly? Maybe because my program is very simple, that it can work without this function. Can anyone offer me any simple example?<br /><br />c) Since i don&#039;t see my WndProc() callback function called by me inside the wMainWin(), i believe DispatchMessage() is the one responsible to call WndProc().<br />c.1 -If i have multiple callback functions, how does DispatchMessage() determines which message corresponds to which callback function?<br />c.2 -Is it one message queue for the entire application even when i have multiple windows and callback functions?<br />c.3 -Within wWinMain(), I never invoked WndProc() manually nor invoked the message WM_PAINT. Yet a message requesting WM_PAINT to be dispatched to WndPro() was issued otherwise it would not show the bitmap on the window. And before any input is inserted, the MSG structure was initially emptied.<br />c.4 -Is there a multi-threaded background code working along with my application to read the window inputs or how does inputs get into the message queue i have in my application?</div>
    <div class="meta">Posted on 2011-08-24 07:17:45 by banzemanga</div>
   </div>
   <div class="post" id="post-214916">
    <div class="subject"><a href="#post-214916">Re: A lots of questions about Windows API</a></div>
    <div class="body">RegisterClass/RegisterClassEx registers a window&#039;s class. Every process has its own pool of registered window classes ready to be used. Every signle window is *of some class*. There are, for example, &#039;buttons&#039;, &#039;edits&#039;, etc. You create a button class, where you describe its behavior. And then you can create multiple windows of that class. It&#039;s true, of course, that you usually create only 1 &quot;main window&quot;, so it may be strange to register a class just to create one window.<br />Another &#039;big&#039; example of a window class are explorer&#039;s (not internet explorer&#039;s) windows. You can have multiple explorer windows - they are of the same class and they belong to one process (explorer.exe)*.<br /><br />*it&#039;s possible to make them spawn in separate processes<br /><br />TranslateMessage - there are some &#039;combinations&#039; of messages that make their own specific sense. Most common example is WM_KEYDOWN/WM_KEYUP pair: When you quickly press and depress a key, you can translate it into a signle WM_KEYPRESS. Additionally, if that key corresponds to an ASCII character, you get WM_CHAR. <a target="_blank" href="http://msdn.microsoft.com/en-us/library/ms644955%28v=vs.85%29.aspx">Please read the remarks</a>.<br /><br />Every event generated in Windows OS relevant to your application&#039;s window is aded to that window&#039;s MESSAGE QUEUE. GetMessage waits for a message in that queue (enters &#039;efficient wait state&#039;). As soon as there is a meesage, it *pops* that message and returns it. At this point you usually try to translate it, and the post it to your window. DispatchMessage is a convenient function which asks for the window&#039;s handle and then automagically gets that window procedure&#039;s address and calls it. It&#039;s because you more often that not DON&#039;T know a window&#039;s procedure address. There are way to get wndproc&#039;s address, but it&#039;s easier to just call Dispatch Message. It does that or you.<br /><br />A callback function is attached to a window&#039;s class. You specify it when you register it. And then that becomes the function called by &#039;Dispatch Message&#039; with that class&#039; window handle.<br /><br />Please read these articles about <a target="_blank" href="http://msdn.microsoft.com/en-us/library/ms632590%28v=vs.85%29.aspx">messages and queues</a>. It&#039;s really &#039;a must&#039; in Windows OS. Seriously, make yourself a tea and read it.<br /><br />Ad c4: It&#039;s not really &#039;multithreaded&#039;, but it&#039;s something -more or less- like that. Yes, there is &#039;something&#039; that reads all events in the OS and adds the relevant ones to your window&#039;s message queue. It is the very definition of the Event-Driven OS: Every time there is something relevant to a window of your application, it gets posted to that window&#039;s message queue. Note that you may have multiple windows (even of the same class) and there might be an event which will be posted to one of your windows and not any other, for example (keypress in one window is an example - it&#039;s relevant to a window in which it took place).<br /><br /><br /><br />It&#039;s late, so -like- 99% of it may be bullsh*t. Good night ^^</div>
    <div class="meta">Posted on 2011-08-24 17:50:51 by ti_mo_n</div>
   </div>
   <div class="post" id="post-214917">
    <div class="subject"><a href="#post-214917">Re: A lots of questions about Windows API</a></div>
    <div class="body">You can create a window in one step, if you are happy to use one of the native window classes (includes those known as Common Controls) eg EDIT is a box for entering some text.<br /><br />You can also create a window in one step if you have prepared a &quot;dialog resource&quot; (see Dialog Windows). This is basically some data embedded in your executable which describes the window and its subwindows (child controls). A lot like a &quot;form&quot;, really.<br /><br />Registering a window class is only necessary if your application contains no resource information and you wish to create a window whose function and form differ greatly from the ones you can choose from.<br /><br />The final options are called &#039;subclassing&#039; and &#039;superclassing&#039;, and basically involve modifying/extending the behavior of a defined window class.<br /><br /></div>
    <div class="meta">Posted on 2011-08-25 04:09:03 by Homer</div>
   </div>
   <div class="post" id="post-214920">
    <div class="subject"><a href="#post-214920">Re: A lots of questions about Windows API</a></div>
    <div class="body">To get more into c4...<br />Basically each thread has a message queue. Windows messages are a way to communicate between threads/processes (see for example <a target="_blank" href="http://msdn.microsoft.com/en-us/library/ms644946(v=VS.85).aspx">PostThreadMessage</a>).<br /><br />Window messages are placed into the queue of the thread that created the window.<br />It works in a few steps. Namely, when you press a key or do something with the mouse, the event will first come in via the device driver, which places it onto the system message queue. After all, the keyboard or mouse doesn&#039;t know anything about applications or windows. It&#039;s just very basic information of &quot;key X is pressed&quot; or &quot;mouse moved by X units horizontally and Y units vertically&quot;.<br />The system will then figure out what application/window is active/was clicked in/etc, and places the message in the proper thread&#039;s queue.<br /><br />So in that sense it is multithreaded: each application has at least one thread, and then there is the lowlevel system event handling code, which can also be seen as a separate thread.</div>
    <div class="meta">Posted on 2011-08-25 08:39:41 by Scali</div>
   </div>
  </div>
 </body>
</html>