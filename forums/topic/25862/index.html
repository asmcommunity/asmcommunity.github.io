<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>SceneGraphs and 3D Games - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25862" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25862">SceneGraphs and 3D Games</a></p>
   <div class="post" id="post-188593">
    <div class="subject"><a href="#post-188593">SceneGraphs and 3D Games</a></div>
    <div class="body"><br />SceneGraphs are a relatively new concept in the GameDev world, and seem to have been adopted from those high-end 3D modelling tools which are based apon them.<br />In simple terms, a SceneGraph is just some kind of tree or hierarchy which contains all the objects that can be rendered in a Scene.<br />The implementations are as many and as varied as the people who write them, but in all cases are geared toward those characteristics deemed most important by their Author for a given application.<br />For example, a SceneGraph could be as simple as a list of stuff to draw... but when applied as the basis of a 3D Game Rendering Engine, we&#39;re mostly interested in Culling of stuff that is not currently visible, so we&#39;d want some kind of space partitioning scheme (bsptree, octree, or something else), and we&#39;d want to store our renderable objects in the nodes of that &#39;space tree&#39;.<br /><br />So far we haven&#39;t introduced anything &#39;new&#39; in terms of data storage mechanisms - for games or otherwise. Let&#39;s fix that.<br /><br />SceneGraphs are MORE than just a frame hierarchy representing a scene, because in a SceneGraph, we can have many &#39;SPECIAL NODES&#39; which rather than (or in addition to) just &#39;storing stuff&#39;, can also &#39;DO stuff&#39; (to any/all descendant nodes further down that branch of the tree).<br />Furthermore, Special Nodes can be used to associate arbitrary attributes of arbitrary Nodes, possibly via Script / Braced Formula.<br />This can be used to create any number of physical constraints which are automatically maintained by the Engine - this allows the game developer to describe complex interactive behaviours between the world&#39;s entities, and to otherwise fine-tune any in-game behaviours in a way that is external to the hard code of the engine - the developer can softwire the game without rebuilding the engine.<br /></div>
    <div class="meta">Posted on 2007-03-25 19:43:23 by Homer</div>
   </div>
   <div class="post" id="post-188594">
    <div class="subject"><a href="#post-188594">Re: SceneGraphs and 3D Games</a></div>
    <div class="body"><br />I&#39;ve begun to roll together several of the projects I&#39;ve posted here previously : animated skinmeshes, octrees, frustum culling etc.<br />My goal is to produce a more useful demo from the components I&#39;ve developed, and to develop them further but in a more global context.<br />It&#39;ll give me a chance to see them work together, and to address any issues that arise.</div>
    <div class="meta">Posted on 2007-03-26 02:52:21 by Homer</div>
   </div>
   <div class="post" id="post-188609">
    <div class="subject"><a href="#post-188609">Re: SceneGraphs and 3D Games</a></div>
    <div class="body"><br />My OctTree refuses to render.<br />I have just been investigating this. The problem turned out to be invalid INDICES.<br /><br />When I generate an OctTree from a (potentially huge) X File, the geometry is distributed among N OctNodes.<br /><br />Each OctNode is a container for 0 to N Faces.<br />Each Face is comprised of three Indices, which are 32bit during the Generation phase, but are renumbered to 16bits....<br /><br />I collect the unique Vertices referenced by all the Faces in a given Node, and store them in that Node.<br />I&#39;m MEANT to renumber the Indices to suit my new node-local VertexBuffer, replacing the &#39;global 32bit index&#39; with a &#39;local 16bit index&#39; but apparently I stuffed up there.<br />At first glance, the Index values which I loaded from my custom OctTree file seem incorrect.<br /><br />I&#39;ll confirm this problem in the Octree Generator code later today, and probably fix it on the spot.<br /><br /></div>
    <div class="meta">Posted on 2007-03-26 23:35:40 by Homer</div>
   </div>
   <div class="post" id="post-188610">
    <div class="subject"><a href="#post-188610">Re: SceneGraphs and 3D Games</a></div>
    <div class="body">The Octree Generator was writing junk index values to the output file, due to a trashed register.<br />I added a push and pop to protect that register, and I also added some code to detect illegal output indices (&gt;65535)..<br /> <br />That problem solved, still my faces did not get rendered.<br />I checked the values of some Vertices, they seemed sane.<br />I stared at the render states.<br />I tried generating an octree from tiger.x instead of my own xfile, so that it for sure has a texture etc, and I changed the Generator settings to make a very shallow tree (forcing many original triangles to appear in the output).<br />Still no luck.<br />I created some simple democode for an indexed textured Cube, and that worked just fine.<br />I checked that I was setting material, texture, fvf, vertexstream, indexbuffer, etc, and I see nothing different.<br />What the heck is happening?<br />Next I will try to walk thru the faces in my own IB&#39;s, manually look up the three vertices for each face, and draw it using DrawPrimitive.<br />If that doesn&#39;t work, I&#39;ll try the demo fvf... I should see &#39;something&#39;, even if it&#39;s not correct :|<br /><br /></div>
    <div class="meta">Posted on 2007-03-27 00:34:01 by Homer</div>
   </div>
   <div class="post" id="post-188611">
    <div class="subject"><a href="#post-188611">Re: SceneGraphs and 3D Games</a></div>
    <div class="body">Fortunately, the Tiger.x uses the exact same FVF as my demo cube, so I was able to fairly quickly get stuff rendering.<br /><br />I&#39;m now able to render all the faces distributed in the (mostly leaf) nodes of my OctTree, although I&#39;m not currently applying Culling, and I haven&#39;t tested it on UNTEXTURED materials since I just got it working.<br /><br />I&#39;ll now confirm that untextured materials are working by reverting to my homemade xfile, and once that&#39;s done, I&#39;ll import my Frustum code for culling the OctTree nodes in realtime via the View Matrix (current camera view), and implement it within the OctTree rendering code.<br /><br />It&#39;s worth mentioning that my OctTreeGenerator currently does not calculate Vertex Normals for any &#39;new&#39; Vertices generated during the partitioning process. I&#39;ll worry about that when I have Lighting.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2007-03-27 02:18:05 by Homer</div>
   </div>
   <div class="post" id="post-188612">
    <div class="subject"><a href="#post-188612">Re: SceneGraphs and 3D Games</a></div>
    <div class="body">You&#39;re going to have to play around with the LEAF_OCTANT_FACE_LIMIT constant when generating your octrees.<br />Example results from Tiger.x :<br /><br />Limit=300, outputfile = 20kb<br />Limit=150, outputfile = 970kb<br /><br />Dramatic difference?<br /></div>
    <div class="meta">Posted on 2007-03-27 03:45:40 by Homer</div>
   </div>
   <div class="post" id="post-188613">
    <div class="subject"><a href="#post-188613">Re: SceneGraphs and 3D Games</a></div>
    <div class="body">How is that difference possible :| ?</div>
    <div class="meta">Posted on 2007-03-27 06:57:52 by Ultrano</div>
   </div>
   <div class="post" id="post-188614">
    <div class="subject"><a href="#post-188614">Re: SceneGraphs and 3D Games</a></div>
    <div class="body">The answer lies in the way the subdivision of faces is performed.<br />My octree generator finds the centroid of the imported xfile, and uses three virtual planes passing through that centroid to cut the model into 8 subsets. It then repeats this process for each subset, until some threshhold is reached, thus building the spacetree.<br />Whenever a plane passes through a triangular face, that triangle is cut into either 2 or 3 pieces, and those pieces are then fed back into the equation and tested against other planes,thus several planes may cut the same triangle, generating even more output triangles from the single input triangle.<br />My generator suppresses any splitting operations which would create unreasonable output &#39;fragments&#39;, which helps a little, but the triangle count can still be quite high.<br /><br />Two factors affect the output facecount in my generator, one we can control, and one we cannot control.<br />The factor we can control is the &#39;maximum faces per leafnode&#39; threshold which is used to terminate the recursion during tree-building when the working facecount is sufficiently low.<br />The factor we cannot control is the geometry of the model, which directly affects the number of triangles that are cut by a virtual plane or planes.<br />The reason that the &#39;maximum faces per leafnode&#39; threshold affects the output facecount is not immediately obvious... think of it this way: the octants get smaller as the tree gets deeper, and smaller octants means less distance between the axial position of the cuttingplanes, thus as we go down the tree, more triangles are going to get cut, and produce more output faces... so conversely, a more shallow tree means less potential for cuts (but larger facecounts at the leaves)<br /><br />The output facecount is going to depend a lot on the geometry, and we&#39;d have to go to an &#39;adaptive tree&#39; to try to reduce the split count further, which would make the Generator so slow as to preclude the possibility of using it at runtime for blowing holes in things..and without the promise of actually reducing the #splits, since there is no guarantee that an optimal centroid position actually exists for an arbitrary set of input faces.<br /><br />The best we can hope for without a heuristical best-case search is to find through trial and error the lowest value for the &#39;maximum faces per leafnode&#39; constant which still produces an acceptable outcome... </div>
    <div class="meta">Posted on 2007-03-27 08:12:13 by Homer</div>
   </div>
   <div class="post" id="post-188615">
    <div class="subject"><a href="#post-188615">Re: SceneGraphs and 3D Games</a></div>
    <div class="body">But isn&#39;t subdivision something to avoid in octrees??<br />AFAIK, octrees are fast and small when:<br />a) a polygon/object that is entirely inside the current cube-node, is kept there <br />b) a polygon that <strong>isn&#39;t entirely inside</strong> the cube, is moved to the parent node. <br />This way, you don&#39;t bring even more burden to the cpu and VGA card when drawing, and cpu when performing collision-detection. </div>
    <div class="meta">Posted on 2007-03-27 08:57:14 by Ultrano</div>
   </div>
   <div class="post" id="post-188616">
    <div class="subject"><a href="#post-188616">Re: SceneGraphs and 3D Games</a></div>
    <div class="body">Generator App:<br />Here what I&#39;m doing is taking an input xfile which would presumably contain the static World geometry for a Game Level, importing its data, stripping it of duplications, and generating an &#39;MX Octree&#39; from it, then saving that data to a custom file.<br />The potentially massive input file is subdivided into octants and suboctants according to our heuristic, and for each node that contains faces after processing is completed, the REFERENCED subset of vertices are stripped of duplicates, and suitable 16-bit indices are generated, leaving a neat little package of vertices and indices at the appropriate nodes, each suitable for shoving directly into D3D buffers.<br />The distribution/renumbering scheme allows us to have more than 64k vertices, which is reasonable for a modern game.<br />Basically, we can make bigger levels, without being forced to use 32bit indices, or using relative vertices (ugly), so our file and runtime memory requirements are reduced for a larger model.<br /><br />Demo App:<br />Here I&#39;m reloading the custom file, rebuilding the Octree, and presumably applying frustum culling to the octree in order to cull the World surfaces and presumably also to cull any object instances that have been attached to any Octree nodes.<br />The goal is to create a SceneGraph that contains space partitioning data as well as the objects which inhabit the subspaces, and is thus geared toward view-dependant culling.<br />Each octree node may contain a list of faces, a list of entities, both, or neither.. the entity list might end up being a subtree or list of subtrees (of Frames) for the purpose of object relativity (eg relative position/rotation of subobjects).<br /><br />I don&#39;t attempt to subdivide objects in general, just the World itself.<br />The example I gave for Tiger.x was a bad example, giving the wrong impression.<br /><br />Attaching of objects to the Octree nodes is outside the scope of my thread (so far).<br /></div>
    <div class="meta">Posted on 2007-03-27 09:13:04 by Homer</div>
   </div>
   <div class="post" id="post-188617">
    <div class="subject"><a href="#post-188617">Re: SceneGraphs and 3D Games</a></div>
    <div class="body">My Octree is actually already a hybrid MX Octree / SphereTree.<br />Each Node has a &#39;HyperBox&#39; (ie the infinite inverse BoundingBox implied by a Centroid which intersects three Axial Planes), but the nodes that contain geometry ALSO have a BoundingSphere.<br /><br />The HyperBox cuts space into 8 equal subspaces.<br />The BoundingSphere&nbsp; encloses a node&#39;s Faces.<br />Both of them offer extremely fast point-based testing.<br />The Spheres are ONLY to be used for Visibility Testing.<br />When we want to Render, we walk the Octree looking for Nodes which contain Faces, and thus a BoundingSphere... when we find one, we test the Sphere against the Frustum, and if we fail, we return from recursion.. elseif we succeed, we draw that node&#39;s faces, AND if the node is non-leaf, we continue recursing until we reach a Leaf.<br />Thus, we&#39;re only visibility-testing on a subset of the octree nodes, rather than all of them, and using a geometry which is potentially a better fit around the PVS than the hyper or regular cube is, and using&nbsp; tests which are quite a bit faster than any box test.<br /><br />The Spheres in the SphereTree may overlap one another etc, they&#39;re not meant to be accurate, they&#39;re meant to be fast (they are &#39;hungry&#39;, and never return a false negative but can return false positive) - I believe in using Sphere tests to check the &#39;proximity&#39; of two test entities, and then using a more accurate secondary test if the result of the first test is positive - in this case, I&#39;m merely extending that logical premise and applying it to the World itself in order to improve apon the performance offered by conventional frustum/octree schemes.<br /><br />The octree&#39;s node-box hierarchy accurately subdivides space, but does not care much about the distribution of geometry within it.<br />Once we have such a Tree, we can easily generate a SphereTree WITHIN the Octree, which better describes the NON-EMPTY SUBSPACES within the Octree that contain POTENTIALLY VISIBLE GEOMETRY of the static world surface variety :)<br /><br /></div>
    <div class="meta">Posted on 2007-03-27 09:38:30 by Homer</div>
   </div>
   <div class="post" id="post-188624">
    <div class="subject"><a href="#post-188624">Re: SceneGraphs and 3D Games</a></div>
    <div class="body">The first implementation of the hybrid octree/spheretree with frustum culling is complete and tested.<br /><br />I decided to create a boundingsphere for each and every Node during the tree generation.<br />Whenever we create a new OctNode and shove its input subset of Faces into it, we calculate the boundingsphere (origin and size) of that subset of faces.<br />The sphere may not completely enclose the BoundingBox of the Octant, but it does not have to.<br />It completely encloses the INPUT subset of faces, which includes all the faces that belong to that Octant AND any child octants that are at that stage yet to be created.<br /><br />So - each Octant has a Sphere that bounds &#39;any faces in that octant, plus those in any child octants&#39;.<br /><br />I now perform a sphere/frustum intersection test at each OctNode.<br /><br />Here is the code for my Sphere/Frustum test,<br /><pre><code><br />;Tests a Sphere against a set of Frustum Planes, return values are:<br />;-1 = totally outside the frustum<br />; 0 = intersecting one or more frustum planes<br />;+1 = totally inside the frustum<br />SphereInFrustum proc uses esi ecx pvSphereOrigin,fSphereRadius,pFrustumPlanes<br />LOCAL fDistance:real4<br />LOCAL fRad:real4<br />	; calculate our distances to each of the planes<br />	xor ecx,ecx<br />	mov esi,pFrustumPlanes<br />	.while ecx&lt;6<br />		<br />		;Calculate : fDistance = (PlaneNormal . vSphere) + PlaneD<br />		mov eax,pvSphereOrigin<br />		fld&nbsp; .Vec4.x<br />		fmul .Vec3.x<br />		fld&nbsp; .Vec4.y<br />		fmul .Vec3.y<br />		fld&nbsp; .Vec4.z<br />		fmul .Vec3.z<br />		fadd<br />		fadd<br />		fadd .Vec4.w<br />		fstp fDistance<br />		<br />		; if this distance is &lt; -sphere.radius, we are outside<br />		;if(fDistance &lt; -refSphere.Radius())<br />		;	return(OUT);<br />		fld fSphereRadius<br />		fchs<br />		fstp fRad<br />		fMin fDistance, fRad<br />		fstpReg eax<br />		.if eax==fDistance<br />			return -1<br />		.endif<br /><br />		; else if the distance is between +- radius, then we intersect<br />		fAbsMin fDistance, fRad<br />		;if((float)fabs(fDistance) &lt; refSphere.Radius())<br />		;	return(INTERSECT);<br />		.if eax==fDistance<br />			return 0<br />		.endif<br />		add esi,sizeof Plane<br />		inc ecx<br />	.endw<br /><br />	; otherwise we are fully in view<br />	return 1<br />SphereInFrustum endp<br /><br /></code></pre><br /><br />and my culled octant drawing code:<br /><pre><code><br />;Draw the entire OctTree with Frustum Culling<br />Method OctTree.DrawCulled,uses esi,pnode, pFrustumPlanes<br />	.if pnode!=0<br />		SetObject esi<br />		ICall pD3DDevice::IDirect3DDevice9.SetFVF,.dFVF<br />		mov edi,pnode<br />		invoke SphereInFrustum,addr .OctNode.vSphereCenter,.OctNode.fSphereRadius,pFrustumPlanes<br />		.if eax!=-1<br />			OCall pnode::OctNode.Draw<br />			mov edi,pnode<br />			lea edi,.OctNode.pPPP<br />			xor ecx,ecx<br />			.while ecx&lt;8<br />				.if dword ptr!=0<br />					push ecx<br />					push edi<br />					OCall DrawCulled,&nbsp; dword ptr,pFrustumPlanes<br />					pop edi<br />					pop ecx<br />				.endif<br />				inc ecx<br />			.endw<br />		.endif<br />	.endif<br />MethodEnd<br /></code></pre><br /><br />Note that the SphereFrustum test returns &#39;visible&#39; if the sphere is totally inside the frustum, OR if the frustum is totally inside the sphere.. that&#39;s quite handy!<br /><br />Note that the culled render function will draw both partially and fully visible nodes.<br /><br /></div>
    <div class="meta">Posted on 2007-03-28 02:55:43 by Homer</div>
   </div>
   <div class="post" id="post-188626">
    <div class="subject"><a href="#post-188626">Re: SceneGraphs and 3D Games</a></div>
    <div class="body">I&#39;ve extended my Frustum code.<br />It can now return one or more of the following:<br />-Frustum Planes (x6)<br />-Frustum Vertices (x8)<br />-Frustum BoundingSphere (vOrigin and fRadius)<br /><br />I then wrote a proc that tests for the intersection of two Spheres.<br />If the distance between their Origins is greater than the sum of their radii, then they do not intersect.<br /><br />Finally, I modified the &#39;render-with-culling&#39; method in my Octree code to use the new Sphere/Sphere test as the primary test.<br />In my previous post, I wrongly asserted that the Sphere/Frustum test would detect the case of &#39;frustum inside sphere&#39;.<br />It doesn&#39;t, but this new test handles the the case of &#39;frustumsphere inside octantsphere&#39; perfectly.<br /><br />Still, I did say PRIMARY test, we must think of the sphere/sphere test as a &#39;proximity&#39; test.. it can give false positives, but not false negatives.<br /><br />Extracting the Frustum BoundingSphere every time the View changes isn&#39;t cheap, but I think it will be worth the cost considering the savings we can obtain from using sphere/sphere as the primary test.<br /><br />Let&#39;s assume we tested sphere/sphere and detected intersection.<br />How do we know it&#39;s not a false result?<br />For the special case of the frustumsphere, first we&#39;ll make sure that the testsphere could fit inside the frustumsphere (has smaller radius).<br />A&gt;If it won&#39;t fit inside the frustum, then the frustum is &#39;inside it&#39;, and so we ASSUME its partially visible, since part of it is inside our frustum!!<br />B&gt;If it WILL fit inside the frustum, we&#39;ll perform our crapworthy frustum/sphere secondary test, which will now return reliable results, ie whether there is a full or partial visibility involved with respect to the frustum planes.<br /><br />Just because the testsphere T intersects the Frustumsphere F, we cannot conclude that testsphere T ALSO intersects the Frustum PlaneSpace.. we need to perform that second check, which MAY FAIL, indicating that the testsphere is PROXIMATE to the Frustum, but is NOT VISIBLE.<br /><br />I think that is sufficiently accurate for visibility culling purposes.<br />Anyone have comments or ideas?</div>
    <div class="meta">Posted on 2007-03-28 06:18:59 by Homer</div>
   </div>
   <div class="post" id="post-188631">
    <div class="subject"><a href="#post-188631">Re: SceneGraphs and 3D Games</a></div>
    <div class="body">Hi<br />I know that some frustum culling implementations remember the plane that gives the last positive result to check for that plane first, when the next frame is rendered. <br /><br />Regards,<br /><br />Biterider</div>
    <div class="meta">Posted on 2007-03-28 09:07:39 by Biterider</div>
   </div>
   <div class="post" id="post-188655">
    <div class="subject"><a href="#post-188655">Re: SceneGraphs and 3D Games</a></div>
    <div class="body">That&#39;s a great idea for accelerated walking of trees in general, and one I&#39;ve used in another component of this project already (SkinMesh).<br />I&#39;ll bear it in mind as I go.<br /><br />Last night I slapped myself a few times, and then changed the way I calculate octnode boundingspheres.<br />Now I simply calculate and store the sphere which bounds the NODEBOX, so the Sphere and Box share the same Origin.<br />Our spheres are now large enough to contain ALL the space owned by an octnode, and therefore, anything WITHIN an octnode, which is consistant with typical spacepartitioning schemes.<br /><br />We still need to perform secondary testing to check for false positives, what we&#39;ve achieved is to ensure that any entities which are later attached to octnodes fall completely within the bounds of the proximity hull, guaranteeing that we don&#39;t accidentally cull them.<br /><br />Here&#39;s my current visibility-culling nodewalk function.<br />I&#39;m not currently drawing entities that are attached to Octnodes, because this project currently doesn&#39;t support that.. that&#39;ll be addressed in due course.<br />Note that the Child octnodes of the current node are only recursed if the current node is not culled (is partly or fully visible) - of course, if a node isn&#39;t visible, then none of its children are either.<br /><br /><pre><code><br />;Draw the entire OctTree with Frustum Culling<br />Method OctTree.DrawCulled,uses esi,pnode, pFrustumPlanes<br />	.if pnode!=0<br />		SetObject esi<br />		mov edi,pnode		<br />		invoke Sphere_x_Sphere,addr .OctNode.vBBCenter,.OctNode.fSphereRadius,addr myFrustSpherePos,myFrustSphereRad<br />		.if eax!=-1<br />			;The primary &#39;proximity test&#39; returned a Positive result..<br />			;Check if nodesphere could fit inside frustumsphere<br />			mov edi,pnode<br />			fAbsMax .OctNode.fSphereRadius, myFrustSphereRad<br />			fstReg eax<br />			.if eax==myFrustSphereRad<br />				;The nodesphere is smaller than the frustumsphere,<br />				;so we will perform a secondary and more accurate test<br />				;using the nodesphere and the 6 frustum Planes<br />				mov edi,pnode<br />				invoke SphereInFrustum,addr .OctNode.vBBCenter,.OctNode.fSphereRadius,pFrustumPlanes<br />				.if eax==-1<br />					;failed secondary test - no intersection, but is &#39;proximate&#39;, if that matters to us..					<br />					ret<br />				.endif<br />			.endif<br />			;We&#39;ve decided the Node is partially or fully visible<br />			ICall pD3DDevice::IDirect3DDevice9.SetFVF,.dFVF<br />			OCall pnode::OctNode.Draw<br />			mov edi,pnode<br />			lea edi,.OctNode.pPPP<br />			xor ecx,ecx<br />			.while ecx&lt;8<br />				.if dword ptr!=0<br />					push ecx<br />					push edi<br />					OCall DrawCulled,&nbsp; dword ptr, pFrustumPlanes<br />					pop edi<br />					pop ecx<br />				.endif<br />				inc ecx<br />			.endw			<br />		.endif<br />	.endif<br />MethodEnd<br /><br /></code></pre><br /><br />ps : I just added a couple of params so that the function no longer relies on static variables eg myFrustumSpherexxx</div>
    <div class="meta">Posted on 2007-03-29 01:39:48 by Homer</div>
   </div>
   <div class="post" id="post-188661">
    <div class="subject"><a href="#post-188661">Re: SceneGraphs and 3D Games</a></div>
    <div class="body">I&#39;ve added a pEntities field to my OctNode.<br />It&#39;s a &#39;DataCollection&#39; object which contains a list of &#39;Entity&#39; structs.<br /><br />Here&#39;s the Entity struct.<br /><pre><code><br />;This container is used to represent one Node in a SceneGraph of arbitrary entities.<br />;Each OctNode contains a list of N Entity structs, representing individual entities.<br />;Each Entity struct is the rootnode of a Frame Hierarchy, which means that<br />;we are supporting &#39;compound entities&#39; ie CSG, and also support &#39;relativity&#39;.<br />;Please NOTE this is a Derived Frame Struct, which D3D likes to work with,<br />;and that we&#39;re able to implement our specific entities as Object Classes<br />;since this struct acts as a container for arbitrary objects.<br />;We use the Frame.pMeshContainer field to point to the actual object.<br />Entity struct<br />	Base D3DXFRAME &lt;&gt;<br />	matCombined D3DXMATRIX &lt;&gt;	;not sure if I really want this here<br />	EntityType	db ?<br />	EntityState db ?<br />Entity ends<br /></code></pre><br /><br />I think the comments cover everything important regarding the Entity struct.<br /><br />The OctNodes in our OctTree are our main SceneGraph nodes.<br />They represent &#39;non-empty subspaces&#39; in our World.<br />Any NULL OctNode Pointers refer to &#39;empty subspaces&#39;.<br />Think of the Game World without any movable objects or creatures.<br />Just the immutable World itself.<br />Normally, we&#39;ll be attaching uor entities to nodes that already contain some world surfaces.<br />Will we ever wish to attach entities to &#39;empty nodes&#39;?<br />YES.<br />We might wish to place a bird in the sky.<br />The sky is a region that contains no World faces, so we didn&#39;t bother to create an OctNode to represent it.<br />Instead, there&#39;s a NULL pointer somewhere that WOULD lead to this sky node, if it existed..<br /><br />I am going to alter the Loader function to create dummy nodes to represent the empty subspaces. This means that we will never find any NULLs in any OctNode&#39;s 8 childpointers, unless they are ALL NULL, which would indicate either a Dummy Node (which contains no faces), or a Terminal Node (which contains Faces).<br />Altering the Loader means that Dummy nodes are not stored in my custom file.<br /><br />Having done that, we can make the following statements:<br />Non-Leaf Nodes contain 8 VALID ChildPointers, while LeafNodes contains 8 NULL ChildPointers.<br />Dummy Nodes are LeafNodes which contain No Faces.<br /><br />Oh, just one more thing to say.<br />It&#39;s about the entity lists.<br /><br />I won&#39;t attempt to store entities in multiple nodes, thats just messy and painful, what I&#39;ll do is store them in the first node that completely bounds them... if object X won&#39;t fit totally in a given node, I&#39;ll just try its parents until I find one it fits into.<br />The octree&#39;s rootnode bounds the entire World, so we&#39;re sure to find a happy home for any entity unless it&#39;s large enough to swallow the World :P<br /></div>
    <div class="meta">Posted on 2007-03-29 08:47:19 by Homer</div>
   </div>
   <div class="post" id="post-188664">
    <div class="subject"><a href="#post-188664">Re: SceneGraphs and 3D Games</a></div>
    <div class="body">I haven&#39;t modified the Loader for DUMMY octnodes yet, I got carried away with three new Methods:<br /><br />OctNode.ClassifyPoint<br />Compares given Point to octnode&#39;s centroid, and returns the index of the child octant (0-7) which that Point would exist in. This is quite a fast operation.<br /><br />OctTree.PointInWhichNode<br />Uses the previous method to explore the octree looking for the deepest node which bounds the given point.<br /><br />OctTree.SphereInWhichNode<br />Same as the previous method, but for Spheres, via a Sphere/NodeSphere test.<br /><br />Now, assuming that I&#39;ve created the Dummy Nodes as mentioned earlier, I can now find the deepest octnode into which arbitrary entity X&#39;s boundingsphere will fit... useful eh?<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2007-03-29 11:51:55 by Homer</div>
   </div>
   <div class="post" id="post-188732">
    <div class="subject"><a href="#post-188732">Re: SceneGraphs and 3D Games</a></div>
    <div class="body">Because I&#39;ve opted to go for a FrustumSphere-based primary cull, the frustum-related code has become more critical in terms of performance.<br />I&#39;m just spending some time working over the existing code before extending it further.<br />I&#39;ll be designing a master class representing an instance of some renderable object, from which I&#39;ll derive classes for all the kinds of stuff we&#39;d like to attach to the world(&#39;s octree nodes).<br />This master class will define some abstract methods for performing common tasks such as rendering, positioning and orienting.<br /><br /></div>
    <div class="meta">Posted on 2007-04-04 06:13:06 by Homer</div>
   </div>
   <div class="post" id="post-188964">
    <div class="subject"><a href="#post-188964">Re: SceneGraphs and 3D Games</a></div>
    <div class="body"><div class="quote"><br />Because I&#39;ve opted to go for a FrustumSphere-based primary cull, the frustum-related code has become more critical in terms of performance.<br /></div><br />isnt that a perfect case to speedup with help of SSE?, because squareroots are pretty fast, because they are highly parallelizable, could cull several coordinates at once, radius and center of sphere and each coordinate x,y,z relative center of sphere <br />busy modelling, just made an outfit, interesting in make use of a lowpoly model and RTRT it in a hall of mirrors<br /><br /></div>
    <div class="meta">Posted on 2007-04-23 03:26:45 by daydreamer</div>
   </div>
   <div class="post" id="post-189773">
    <div class="subject"><a href="#post-189773">I HATE GAMES THAT USES CAPS LOCKS!!!</a></div>
    <div class="body">anything new?<br /></div>
    <div class="meta">Posted on 2007-07-07 13:43:23 by daydreamer</div>
   </div>
  </div>
 </body>
</html>