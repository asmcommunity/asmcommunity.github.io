<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>opcode help - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29485" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29485">opcode help</a></p>
   <div class="post" id="post-208232">
    <div class="subject"><a href="#post-208232">opcode help</a></div>
    <div class="body">Hi Guys<br /><br />One more time, am trying to understand the opcode and operands here and how the conversion is done....<br /><br />For example consider this,<br /><br />CALL 004010D6<br /><br />The equivalent opcode for the above is &quot;E8 67000000&quot;.<br /><br />Please tell me how did 004010D6 was converted to 67000000? I understand the opcode for the CALL instruction is E8. But unsure how the address was converted&nbsp; ;)<br /><br />Any help is much appreciated!</div>
    <div class="meta">Posted on 2009-07-21 09:04:46 by karthikeyanck</div>
   </div>
   <div class="post" id="post-208234">
    <div class="subject"><a href="#post-208234">Re: opcode help</a></div>
    <div class="body">Relative address?</div>
    <div class="meta">Posted on 2009-07-21 10:35:50 by ti_mo_n</div>
   </div>
   <div class="post" id="post-208235">
    <div class="subject"><a href="#post-208235">Re: opcode help</a></div>
    <div class="body"><div class="quote"><br />Relative address?<br /></div><br /><br />Yep. CALL can be (and usually is) 32-bit relative (+/- 2GB).</div>
    <div class="meta">Posted on 2009-07-21 10:38:48 by SpooK</div>
   </div>
   <div class="post" id="post-208236">
    <div class="subject"><a href="#post-208236">Re: opcode help</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br />Relative address?<br /></div><br /><br />Yep. CALL can be (and usually is) 32-bit relative (+/- 2GB).<br /></div><br /><br />Oh yeah, those are from Olly.... any idea on how to achieve this?</div>
    <div class="meta">Posted on 2009-07-21 10:50:29 by karthikeyanck</div>
   </div>
   <div class="post" id="post-208237">
    <div class="subject"><a href="#post-208237">Re: opcode help</a></div>
    <div class="body">Add manually? <br /><br />The opcode means the following (Olly helped you do the addition):<br /><br /><pre><code><br />curr: call curr+67h<br /></code></pre></div>
    <div class="meta">Posted on 2009-07-21 11:41:09 by roticv</div>
   </div>
   <div class="post" id="post-208240">
    <div class="subject"><a href="#post-208240">Re: opcode help</a></div>
    <div class="body">Say if I&#039;m calling the function MessageBoxA; will the address of the function remain the same always?<br /><br />I don&#039;t think that is the case, I get the address of the function using LoadLibrary and GetProcAddress....<br /><br />The goal here is to display a messagebox, I&#039;ve managed to push the opcode...<br /><br /><pre><code>mov DWORD PTR,0E8h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;opcode for call</code></pre><br /><br />Am fine till I push the opcode for CALL, but then I&#039;ve the address of the MessageBox function in the edx (004010DA).... how would I pass this on as opcode? <br /><br />Sorry but I didn&#039;t understand this - I believe you are saying to add 67 to the address shown in Olly?<br /><br /><div class="quote">Add manually?<br /><br />The opcode means the following (Olly helped you do the addition):<br /><br />Code:<br /><br />curr: call curr+67h</div><br /><br />Thanks,<br /><br />C K</div>
    <div class="meta">Posted on 2009-07-22 02:40:02 by karthikeyanck</div>
   </div>
   <div class="post" id="post-208244">
    <div class="subject"><a href="#post-208244">Re: opcode help</a></div>
    <div class="body">I think you do not understand the opcode encoding and what the rest meant by call by relative address. E8h is call by relative address, ie suppose the call is done at 100h&nbsp; and you call +10h, it means you are calling the address 110h.<br /><br />The address will differ from machines to machine, but I do not think it will change that much for the same system. <br /><br />Suppose you have the address you want to call is in eax, then you can do call .<br /><br />PS: The svin has some good tutorials on opcode encoding on this forum - search for opcode.</div>
    <div class="meta">Posted on 2009-07-22 10:16:48 by roticv</div>
   </div>
   <div class="post" id="post-208286">
    <div class="subject"><a href="#post-208286">Re: opcode help</a></div>
    <div class="body">I can&#039;t seem to get a solution even after reading the SVIN tuts....<br />I could only manage to push the Address of the MessageBox function.. meaning the address is hard coded..<br /><br /><pre><code>mov DWORD PTR, 07e04f4d6h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;pushing the address for the messagebox function</code></pre><br /><br />Am sure this isn&#039;t the right way to do this, but neverthelesss this works!... but I fear this will break if the function is loaded to a different location in the memory? &nbsp;:sad: <br /><br />Any suggestions?</div>
    <div class="meta">Posted on 2009-07-28 10:24:59 by karthikeyanck</div>
   </div>
   <div class="post" id="post-208287">
    <div class="subject"><a href="#post-208287">Re: opcode help</a></div>
    <div class="body">Change the import table so that you have an addition entry for MessageBoxA. call that address like how like jump table in masm generated code works.</div>
    <div class="meta">Posted on 2009-07-28 10:36:08 by roticv</div>
   </div>
   <div class="post" id="post-208289">
    <div class="subject"><a href="#post-208289">Re: opcode help</a></div>
    <div class="body"><span style="font-family:Monospace">destination_address = getprocaddress(mbox)<br /><br />start_address:<br />	db 0E8h<br />	dd destination_address-return_adress<br />return_adress:<br /></div>
    <div class="meta">Posted on 2009-07-28 15:39:28 by drizz</div>
   </div>
   <div class="post" id="post-208297">
    <div class="subject"><a href="#post-208297">Re: opcode help</a></div>
    <div class="body">Drizz, Wonderful, thanks for that, works perfectly&nbsp;  :D</div>
    <div class="meta">Posted on 2009-07-29 09:55:26 by karthikeyanck</div>
   </div>
   <div class="post" id="post-208383">
    <div class="subject"><a href="#post-208383">Re: opcode help</a></div>
    <div class="body">This may be helpful to you...<br /><br />Intel® 64 and IA-32 Architectures Software Developer&#039;s Manual<br />Volume 1: Basic Architecture:<br /><div class="quote">6.3.1 Near CALL and RET Operation<br />When executing a near call, the processor does the following (see Figure 6-2):<br />1. Pushes the current value of the EIP register on the stack.<br />2. Loads the offset of the called procedure in the EIP register.<br />3. Begins execution of the called procedure.<br />When executing a near return, the processor performs these actions:<br />1. Pops the top-of-stack value (the return instruction pointer) into the EIP register.<br />2. If the RET instruction has an optional n argument, increments the stack pointer<br />by the number of bytes specified with the n operand to release parameters from<br />the stack.<br />3. Resumes execution of the calling procedure.</div><br /><div class="quote">6.3.2 Far CALL and RET Operation<br />When executing a far call, the processor performs these actions (see Figure 6-2):<br />1. Pushes the current value of the CS register on the stack.<br />2. Pushes the current value of the EIP register on the stack.<br />3. Loads the segment selector of the segment that contains the called procedure in<br />the CS register.<br />4. Loads the offset of the called procedure in the EIP register.<br />5. Begins execution of the called procedure.<br />When executing a far return, the processor does the following:<br />1. Pops the top-of-stack value (the return instruction pointer) into the EIP register.<br />2. Pops the top-of-stack value (the segment selector for the code segment being<br />returned to) into the CS register.<br />3. If the RET instruction has an optional n argument, increments the stack pointer<br />by the number of bytes specified with the n operand to release parameters from<br />the stack.<br />4. Resumes execution of the calling procedure.</div><br /><br />Intel® 64 and IA-32 Architectures Software Developer&#039;s Manual<br />Volume 2A: Instruction Set Reference, A-M:<br /><div class="quote">Near Call. When executing a near call, the processor pushes the value of the EIP<br />register (which contains the offset of the instruction following the CALL instruction)<br />on the stack (for use later as a return-instruction pointer). The processor then<br />branches to the address in the current code segment specified by the target operand.<br />The target operand specifies either an absolute offset in the code segment (an offset<br />from the base of the code segment) or a relative offset (a signed displacement relative<br />to the current value of the instruction pointer in the EIP register; this value<br />points to the instruction following the CALL instruction). The CS register is not<br />changed on near calls.<br />For a near call absolute, an absolute offset is specified indirectly in a general-purpose<br />register or a memory location (r/m16, r/m32, or r/m64). The operand-size attribute<br />determines the size of the target operand (16, 32 or 64 bits). When in 64-bit mode,<br />the operand size for near call (and all near branches) is forced to 64-bits. Absolute<br />offsets are loaded directly into the EIP(RIP) register. If the operand size attribute is<br />16, the upper two bytes of the EIP register are cleared, resulting in a maximum<br />instruction pointer size of 16 bits. When accessing an absolute offset indirectly using<br />the stack pointer  as the base register, the base value used is the value of the<br />ESP before the instruction executes.<br />A relative offset (rel16 or rel32) is generally specified as a label in assembly code. But<br />at the machine code level, it is encoded as a signed, 16- or 32-bit immediate value.<br />This value is added to the value in the EIP(RIP) register. In 64-bit mode the relative<br />offset is always a 32-bit immediate value which is sign extended to 64-bits before it<br />is added to the value in the RIP register for the target calculation. As with absolute<br />offsets, the operand-size attribute determines the size of the target operand (16, 32,or 64 bits). In 64-bit mode the target operand will always be 64-bits because the<br />operand size is forced to 64-bits for near branches.</div><br /><div class="quote">Far Calls in Protected Mode. When the processor is operating in protected mode, the<br />CALL instruction can be used to perform the following types of far calls:<br />• Far call to the same privilege level<br />• Far call to a different privilege level (inter-privilege level call)<br />• Task switch (far call to another task)<br />In protected mode, the processor always uses the segment selector part of the far<br />address to access the corresponding descriptor in the GDT or LDT. The descriptor<br />type (code segment, call gate, task gate, or TSS) and access rights determine the<br />type of call operation to be performed.<br />If the selected descriptor is for a code segment, a far call to a code segment at the<br />same privilege level is performed. (If the selected code segment is at a different privilege<br />level and the code segment is non-conforming, a general-protection exception<br />is generated.) A far call to the same privilege level in protected mode is very similar<br />to one carried out in real-address or virtual-8086 mode. The target operand specifies<br />an absolute far address either directly with a pointer (ptr16:16 or ptr16:32) or indirectly<br />with a memory location (m16:16 or m16:32). The operand- size attribute<br />determines the size of the offset (16 or 32 bits) in the far address. The new code<br />segment selector and its descriptor are loaded into CS register; the offset from the<br />instruction is loaded into the EIP register.<br />A call gate (described in the next paragraph) can also be used to perform a far call to<br />a code segment at the same privilege level. Using this mechanism provides an extra<br />level of indirection and is the preferred method of making calls between 16-bit and<br />32-bit code segments.<br />When executing an inter-privilege-level far call, the code segment for the procedure<br />being called must be accessed through a call gate. The segment selector specified by<br />the target operand identifies the call gate. The target operand can specify the call<br />gate segment selector either directly with a pointer (ptr16:16 or ptr16:32) or indirectly<br />with a memory location (m16:16 or m16:32). The processor obtains thesegment selector for the new code segment and the new instruction pointer (offset)<br />from the call gate descriptor. (The offset from the target operand is ignored when a<br />call gate is used.)<br />On inter-privilege-level calls, the processor switches to the stack for the privilege<br />level of the called procedure. The segment selector for the new stack segment is<br />specified in the TSS for the currently running task. The branch to the new code<br />segment occurs after the stack switch. (Note that when using a call gate to perform<br />a far call to a segment at the same privilege level, no stack switch occurs.) On the<br />new stack, the processor pushes the segment selector and stack pointer for the<br />calling procedure’s stack, an optional set of parameters from the calling procedures<br />stack, and the segment selector and instruction pointer for the calling procedure’s<br />code segment. (A value in the call gate descriptor determines how many parameters<br />to copy to the new stack.) Finally, the processor branches to the address of the<br />procedure being called within the new code segment.<br />Executing a task switch with the CALL instruction is similar to executing a call<br />through a call gate. The target operand specifies the segment selector of the task<br />gate for the new task activated by the switch (the offset in the target operand is<br />ignored). The task gate in turn points to the TSS for the new task, which contains the<br />segment selectors for the task’s code and stack segments. Note that the TSS also<br />contains the EIP value for the next instruction that was to be executed before the<br />calling task was suspended. This instruction pointer value is loaded into the EIP<br />register to re-start the calling task.<br />The CALL instruction can also specify the segment selector of the TSS directly, which<br />eliminates the indirection of the task gate. See Chapter 7, “Task Management,” in the<br />Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for<br />information on the mechanics of a task switch.<br />When you execute at task switch with a CALL instruction, the nested task flag (NT) is<br />set in the EFLAGS register and the new TSS’s previous task link field is loaded with<br />the old task’s TSS selector. Code is expected to suspend this nested task by executing<br />an IRET instruction which, because the NT flag is set, automatically uses the previous<br />task link to return to the calling task. (See “Task Linking” in Chapter 7 of the Intel®<br />64 and IA-32 Architectures Software Developer’s Manual, Volume 3A, for information<br />on nested tasks.) Switching tasks with the CALL instruction differs in this regard from<br />JMP instruction. JMP does not set the NT flag and therefore does not expect an IRET<br />instruction to suspend the task.</div><br /><div class="quote">IF far call and (PE = 1 and VM = 0) (* Protected mode or IA-32e Mode, not virtual-8086 mode*)<br />THEN<br />IF segment selector in target operand NULL<br />THEN #GP(0); FI;<br />IF segment selector index not within descriptor table limits<br />THEN #GP(new code segment selector); FI;<br />Read type and access rights of selected segment descriptor;<br />IF IA32_EFER.LMA = 0<br />THEN<br />IF segment type is not a conforming or nonconforming code segment, call<br />gate, task gate, or TSS<br />THEN #GP(segment selector); FI;<br />ELSE<br />IF segment type is not a conforming or nonconforming code segment or<br />64-bit call gate,<br />THEN #GP(segment selector); FI;<br />FI;<br />Depending on type and access rights:<br />GO TO CONFORMING-CODE-SEGMENT;<br />GO TO NONCONFORMING-CODE-SEGMENT;<br />GO TO CALL-GATE;<br />GO TO TASK-GATE;<br />GO TO TASK-STATE-SEGMENT;<br />FI;<br />CONFORMING-CODE-SEGMENT:<br />IF L-Bit = 1 and D-BIT = 1 and IA32_EFER.LMA = 1<br />THEN GP(new code segment selector); FI;<br />IF DPL &gt; CPL<br />THEN #GP(new code segment selector); FI;<br />IF segment not present<br />THEN #NP(new code segment selector); FI;<br />IF stack not large enough for return address<br />THEN #SS(0); FI;<br />tempEIP ? DEST(Offset);<br />IF OperandSize = 16<br />THEN tempEIP ? tempEIP AND 0000FFFFH; FI; (* Clear upper 16 bits *)<br />IF (EFER.LMA = 0 or target mode = Compatibility mode) and (tempEIP outside new code<br />segment limit)<br />THEN #GP(0); FI;<br />IF tempEIP is non-canonical<br />THEN #GP(0); FI;<br />IF OperandSize = 32<br />THEN<br />Push(CS); (* Padded with 16 high-order bits *)<br />Push(EIP);<br />CS ? DEST(CodeSegmentSelector);<br />(* Segment descriptor information also loaded *)<br />CS(RPL) ? CPL;<br />EIP ? tempEIP;<br />ELSE<br />IF OperandSize = 16<br />THEN<br />Push(CS);<br />Push(IP);<br />CS ? DEST(CodeSegmentSelector);<br />(* Segment descriptor information also loaded *)<br />CS(RPL) ? CPL;<br />EIP ? tempEIP;<br />ELSE (* OperandSize = 64 *)<br />Push(CS); (* Padded with 48 high-order bits *)<br />Push(RIP);<br />CS ? DEST(CodeSegmentSelector);<br />(* Segment descriptor information also loaded *)<br />CS(RPL) ? CPL;<br />RIP ? tempEIP;<br />FI;<br />FI;<br />END;</div></div>
    <div class="meta">Posted on 2009-08-07 11:31:45 by asmdna</div>
   </div>
   <div class="post" id="post-208384">
    <div class="subject"><a href="#post-208384">Re: opcode help</a></div>
    <div class="body">you can also read the source code of OllyDBG&#039;s engine....<br /><a target="_blank" href="http://www.pediy.com/sourcecode/disassemblers/disasm/disasm.zip">http://www.pediy.com/sourcecode/disassemblers/disasm/disasm.zip</a><br />assembl.c<br />asmserv.c</div>
    <div class="meta">Posted on 2009-08-07 11:43:06 by asmdna</div>
   </div>
  </div>
 </body>
</html>