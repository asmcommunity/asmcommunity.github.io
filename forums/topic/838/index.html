<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Go to protected mode - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=838" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=838">Go to protected mode</a></p>
   <div class="post" id="post-5289">
    <div class="subject"><a href="#post-5289">Go to protected mode</a></div>
    <div class="body">Hy to all, I need a help about mode switching. Excuse me if I use a lot of words but I want to expose my problem in all its details. Those are my skills :<br />In real mode I use NASM, i know how to chain interrupts like system timer, how to use BIOS, how to write in video memory by Int 10h (320X200 256 colors and 640X480 16 colors), how to create a bootstrap loader, how to write to I/O ports and so on. I have made a lot of small .com files that demonstrate ( to me ) what can be done; I have never built a large .exe program or accessed databases or used VGA Mode X.<br />In protected mode, under Win98, I use MASM32 to write GUI applications ( simple screensavers, simple forms ) or DLL containing functions that I can call from VB. I have to learn how to write VxDs, applications that use ODBC, DirectX, OpenGL and a lot more.<br />What is my goal ? To write in NASM a program that enable protected mode. I have found a lot of examples, but they are often incomplete, use TASM sintax, are too complex to verify. I have all Intel's documentation but the main difficulty is, in my opinion, to find a simple example where structures like IDT are well defined.<br />I hate protection !!! I want to implement a flat system where you have a single segment of 4 Gb readable and writable, a sort of super 8086 without paging. In this environment I would load from disk all my data and keep them in memory once and forever.<br />I think that interrupt handling would be the main problem but one could return back to real mode with interrupt number to process it and then switch again to p. mode like DOS extenders do.<br />Are you interested in ?<br />I would like to know your opinion about difficulty, or your ideas.<br />Thanks to all !!<br /><br />fooCoder</div>
    <div class="meta">Posted on 2001-08-29 08:17:04 by fooCoder</div>
   </div>
   <div class="post" id="post-5313">
    <div class="subject"><a href="#post-5313">Main::Go to protected mode</a></div>
    <div class="body">fooCoder,<br /><br />I'm precisely working on that. I've downloaded lots of tutorials and<br />source codes about protected mode and relatives.<br /><br />About NASM I found:<br /><br /><a target="_blank" href="http://www.venezuelacultural.com.ve/files/PM-NASM.ZIP">http://www.venezuelacultural.com.ve/files/PM-NASM.ZIP</a> (82KB)<br /><br />I don't know if this is what you search, but it seems me<br />a well work.<br /><br />Do you hate pm? I believe that you want try with Flat Real Mode. I've<br />worked with a example for NASM, but did not run:<br /><br /><a target="_blank" href="http://www.venezuelacultural.com.ve/files/FLAT100.ZIP">http://www.venezuelacultural.com.ve/files/FLAT100.ZIP</a> (43KB)<br /><br />I got best results with these tasm source codes:<br /><br /><a target="_blank" href="http://www.venezuelacultural.com.ve/files/FLAU.ZIP">http://www.venezuelacultural.com.ve/files/FLAU.ZIP</a> (12KB)<br /><br />I was very surprised with this posibility, but is not so easy.<br />A found useful info about this in:<br /><br /><a target="_blank" href="http://www.venezuelacultural.com.ve/files/GEM0022.ZIP">http://www.venezuelacultural.com.ve/files/GEM0022.ZIP</a> (6KB)<br /><br />The author says that flat real mode was a dream with the i486 and<br />windows 3.x, but with the new DOS extenders and the PENTIUN<br />processors, this mode became less attractive since it is still <br />16-bit.<br /><br />The author recomends use it only in 486 plataforms. The flat real<br />mode implementation of  of this author is based on the use of <br />HIMEM.SYS. But is not stable. Posibly, the best is study the <br />HIMEM.SYS. Here is a disasembly:<br /><br /><a target="_blank" href="http://www.venezuelacultural.com.ve/files/HIMEM.ZIP">http://www.venezuelacultural.com.ve/files/HIMEM.ZIP</a> (11KB)<br /><br />(great work of Renegade!)<br /><br />You will need a mechanism to know the used memory and the<br />address of the used chunks. <br /><br />My opinion is that could be a way and posibly, with the new <br />hardware posibilities, this could be --the way. Seems me that<br />by this way you don't have to use paging or swap files. So, this<br />could be a very fast plataform. But we need a minimal protection<br />mechanism if we work on a multiprogramming system with <br />multiple users.<br /><br />Anyway, I'm not better than you about these themes, I continue<br />studing and working... Seems me a extensive subject.<br /><br />nmt</div>
    <div class="meta">Posted on 2001-08-29 14:12:15 by n u M I T_o r</div>
   </div>
   <div class="post" id="post-5347">
    <div class="subject"><a href="#post-5347">Here it is the code</a></div>
    <div class="body">here it is my one of my first OS tests ...<br /><br />Its NASM specific because NASM was able to make a raw output bin file, this was placed in the first sectors of a floppy with Linux rawwrite.exe tool<br /><br />it goes tp PM flat mode but without INTS, there is a bug in the INT routines so the LGIDT routine is comented<br /><br />I guess i posted this before on the old messageboard <br /><br /><pre><code><br />;	bootsector system loader<br />;	version 0.0.3<br />; <br />;	build with&#58;<br />;	===============<br />;	nasm -f bin os4.asm -o os4.bin -l os4.lst<br />;<br />;	Credits go to&#58;<br />;	=========================<br />;	Linus Torvalds and Linux <br />;	GazOS<br />;	and may other anonymous heroes<br />;<br /><br />	BITS 16<br /><br />	ORG 0x0000<br /><br />boot01&#58;<br />	jmp	boot02<br />	nop<br /><br />; data zone , variables we may need<br />;========================================<br />boot_drv	db	0	; drive number we where loaded from <br />cs_segment	dw	0<br />Track		db	0<br />Sector		db	0<br />Head		db	0<br />Length		dw	1<br />x1		dd	boot01<br />x2		dd	boot02<br /><br />; back to code<br />; ===============================================<br />; BIOS loads this first  512bytes sector at linear 0000&#58;7C00h<br />; so we set DS to 0x07C0<br />; in order to correctly access data references<br />; ===============================================<br />align 16<br /><br />boot02&#58;<br />	cli			; please no interupts<br />	mov	ax,0x07C0<br />	mov	ds,ax<br />	mov	es,ax		; es same as ds<br /><br />	mov	&#91;boot_drv&#93;,dl	; save drive #<br /><br />; here we make our own stack<br />; at 0x9000&#58;0xFFF0 linear 0x0009&#58;FFF0<br /><br />	mov	ax,0x9000	; segment for stack<br />	mov	ss,ax<br />	mov	sp,0xFFF0	; offset for stack<br /><br />	sti			; enable ints again<br /><br />; clear direction flag<br />; repetitive string operations <br />; will increment SI/DI from now on<br /><br />	cld			<br /><br />; print a short wellcome message<br /><br />	mov	si,msg_001<br />	call	Print_Msg <br /><br />; test  our hex printing routine<br /><br />	mov	dx,0xface	; arbitrary hex constant to print<br />	call	Print_Hex16<br />	call	Print_CRLF<br /><br /><br />	mov	ax,0x07C0	; base memory for loading<br />	mov	es,ax<br />; ========================================================<br />; Load the Setup Code Sectors at linear 0x0000&#58;7e00<br />; Note that ES is already set up above at ES=0x07C0<br />; buffer is at es&#58;bx ie 0x7c00&#58;0200 and 0x7C00+0x0200=0x7E00<br />; =========================================================<br /><br />load_setup&#58;<br />	xor	cx,cx<br />	xor	ah,ah		; func.no.0 = reset FDC <br />	xor	dl,dl		; drive.no=0 ie disk a&#58;<br />	int 	0x13		; use bios call <br /><br />	xor	dx,dx		; drive 0, head 0<br />	mov	cl,2		; sector 2, track 0<br />	mov	bx,0x0200	; offset of loading<br />				; address ES&#58;BX = 07C00&#58;0200, linear 0x0000&#58;7E00<br />	mov	ah,2		; func.no.2=read sectors<br />	mov	al,16		; 8 sectors 8*512=4096=4k=0x1000h <br />				; setup is loaded at 0x7E00-0x8E00<br />	int	0x13		; read it via bios call<br />	jnc	ok_load_setup	; if ok - continue<br /><br />; Ouch...here we have an error.... &#58;&#40;<br /><br />	push	ax		; save error code<br />	call	Print_CRLF	; newline<br />	pop	ax		; retrive error code<br />	mov	dx,ax<br />	call	Print_Hex16	; print error code<br /><br />; if error ... lets try it again ....<br />	<br />	jmp	load_setup<br /><br />ok_load_setup&#58;<br />	mov	si,msg_002	; print happy message...<br />	call	Print_Msg 			 <br /><br /><br />; nothig more to do here ...eh..<br />; bye-bye First Sector .... for now<br /><br /><br />;	jmp	far dword Sector_002<br /><br />; QUICK HACK FOR A -FAR- JMP INSTRUCTION<br />	DB 0xEA			; jump to sector 02<br />	DW 0x7E00		; offset <br />	DW 0x0000		; segment <br /><br /><br />; ************************************<br />; utility routines for the bootsector<br />; ************************************<br />;<br />; First a message printing routine<br />; using bios call to output ASCII letters to Screen<br />; until the last char=0 when it stops and returns<br />; ===================================================<br />Print_Msg&#58;<br />		lodsb		; al=&#91;ds&#58;si&#93;, si=si+1<br />		or	al,al<br />		jz	ok_msg1<br /><br />; BIOS int 0x10 function 0x0E = write char to console<br />		mov	ah,0x0E	; ah=0x0e al=ascii code of char to output<br />		int	10h<br />		jmp	Print_Msg<br />ok_msg1&#58;<br />		ret<br />;<br />; Print newline to Screen<br />; CR and LF are actually a newline<br />; ===================================================<br />Print_CRLF&#58;	<br />		mov	ax,0x0E0D	; al=CR=0x0D, ah=0x0E=print char fn<br />		int	10h<br />		mov	ax,0x0E0A	; al=LF=0x0A<br />		int	10h<br />		ret<br />;<br />; print 16 bit value from DX in hexa format on Screen<br />; DX register has the value to print<br />; ======================================================<br />Print_Hex16&#58;<br />		mov   cx, 4      	; 4 hex digits	<br />				<br />PrintDigit&#58;<br />		rol   dx, 4      	; rotate so that lowest 4 bits are used<br />		mov   ax, 0E0Fh		; ah = request, al = mask for nybble<br />		and   al, dl<br /><br />		add   al, 90h		; convert al to ascii hex &#40;four instructions&#41;<br />		daa			; somebody  spent 1 hour <br />		adc   al, 40h		; to understand how this code works..<br />		daa			; WOW!<br /><br />		int   10h		; call BIOS to print char<br />		loop  PrintDigit<br />		ret<br /><br />; ========================================================<br />; some messages i use in boot sector<br />; ========================================================<br />msg_001&#58;	db	&quot;&gt;Loading SOL OS Ver. 0.0.3&quot;,10,13,0<br />msg_002&#58;	db	&quot;&gt;Setup Code Loaded Ok! &#58;&#41; &quot;,10,13,0<br /><br />; ===============================================================<br />; NASM knows&#58;<br />; $ =begining of curent line at assembly time<br />; $$=begining of current section at assembly time<br />; so expression $-$$ equals curent position in curent section<br />; or offset from the begining of current section<br />; ================================================================<br /><br />	times 510-&#40;$-$$&#41; db 0	; go to end of sector, ie 512-2=510<br /><br />; ========================================<br />; boot disk signature is required <br />; at end of sector 1 Track 0<br />; or else BIOS will not execute this<br />; as a valid boot sector<br />; ========================================<br />BootSignature&#58;<br />	db	0x55,0xAA 	<br />				<br /><br />; ==================================<br />; HERE sector 01  Physically ends<br />; ==================================<br /><br />; ==============================================================<br />; HERE sector 02 Physically starts<br />; ==============================================================<br />; this sector will be loaded by previous code<br />; at addr linear 0x0000&#58;7d00 ie segment&#58;offset= 0x7c00&#58;0200<br />;<br /><br />Sector_002&#58;<br /><br />	mov	si,msg_003	; message to show we are in the second<br />	call	Print_Msg	; sector now<br />;<br />	jmp	Setup_Start<br />;<br />; Some more messages we use in second sector<br />;<br />msg_003&#58;	db	&quot;Setup Code Started &quot;,10,13,0,0<br />msg_A20_line&#58;	db	&quot;Enableing A20 line &quot;,10,13,0<br />msg_005&#58;	db	&quot;Going to PM Mode...bye bye... &quot;,10,13,0<br />msg_8259	db	&quot;Seting up 8259 Interupt Controller...&quot;,10,13,0<br /><br />; ============================================<br />; this routine enables the infamouse A20 Line<br />; ============================================<br />Enable_A20&#58;<br />	call	empty_8042<br />	mov	al,0xD1		; command write<br />	out	0x64,al<br />	call	empty_8042<br />	mov	al,0xDF		; A20 line is going to be on from now on<br />	out	0x60,al<br />	call	empty_8042<br />	ret<br /><br />; =============================================================<br />; This routine checks that the keyboard command queue is empty<br />; &#40;after emptying the output buffers&#41; <br />; for A20 Line enableing commands<br />; it deals with the 8042 chip whitch is used <br />; as a keyboard controller in PCs<br />; =============================================================<br />empty_8042&#58;<br />	call	Delay<br />	in	al,0x64		; 8042 status port<br />	test	al,1		; output buffer?<br />	jz	no_output<br />;<br />	call	Delay<br />	in	al,0x60		; yes, then read it<br />	jmp	empty_8042	; and of course we ignore it<br /><br />no_output&#58;<br />	test	al,2		; is input buffer full?<br />	jnz	empty_8042	; yes - loop<br />	ret<br /><br />; here is a short delay for input/output operations<br />;==================================================<br />Delay&#58;<br />	jmp	delay_01<br />delay_01&#58;<br />	jmp	delay_02<br />delay_02&#58;<br />	ret<br /><br />; =====================================<br />;   8259 PIC initialization	<br />; =====================================<br />Init_8259&#58;					<br />	cli<br /><br />	mov	si,msg_8259		; tell the user<br />	call	Print_Msg		; what we do next<br /><br />	mov	al, 11h 		; ICW1 to both controllers<br />	out	20h, al			; bit 0=1&#58; ICW4 provided<br />	call	Delay			; bit 1=0&#58; cascaded PICs<br />	out	0A0h, al		; bit 2=0&#58; call address interval 8 <br />	call	Delay			; bit 4=1&#58; at 1 &#40;?&#41;<br />		<br />	mov	al, 20h 		; ICW2 PIC1 - offset of vectors<br />	out	21h, al<br />	call	Delay<br />		<br />	mov	al, 28h 		; ICW2 PIC2 - offset of vectors<br />	out	0A1h, al<br />	call	Delay<br />		<br />	mov	al, 4h			; ICW3 PIC1 &#40;master&#41;<br />	out	21h, al			; bit 2=1&#58; irq2 is the slave<br />	call	Delay<br />		<br />	mov	al, 2h			; ICW3 PIC2<br />	out	0A1h, al		; bit 1=1&#58; slave id is 2<br />	call	Delay<br />		<br />	mov	al, 1h			; ICW4 to both controllers<br />	out	21h, al			; bit 0=1&#58; 8086 mode<br />	call	Delay<br />	out	0A1h, al<br />	call	Delay<br />		<br />	mov	al, 0h			; OCW1 interrupt mask to both<br />	out	20h, al			; no irq masked<br />	call	Delay<br />	out	0A0h, al  <br />	call	Delay<br /><br />	ret<br /><br />; ==========================================================================<br />; Hope this will stop the FDC motor...<br />; this motor is also stopped by <br />; int 0x08=realtime clock but after 2 seconds<br />; and only if interupts are enabled....<br />; ==========================================================================<br />Kill_motor&#58;<br />	push	dx<br />	mov	dx,0x3f2<br />	xor	al, al<br />	out	dx,al<br />	pop 	dx<br />	ret<br /><br />; ==========================================<br />; This is our actual Setup 16bits Code<br />; hopefully it will&#58;<br />; 	1.setup as necesarry<br />; 	2.go to protected mode <br />;	3.load the kernel<br />;	4.and fire up the kernel!<br />; ==========================================<br /><br />Setup_Start&#58;<br /><br />;	call	Init_8259<br /><br />;==================================<br />;	Going to Protected Mode <br />;	in 4 little steps&#58;<br />;===================================<br />; STEP.0. <br />; ========<br />;	Enable A20 line<br />;	strange hadrware in PCs<br />;	forces us to do this &#58;&#41;<br />;<br />	mov	si,msg_A20_line		; tell the user what we are <br />	call	Print_Msg		; going to do<br />;<br />	call	Enable_A20<br /><br />;<br /><br />;<br />; STEP.1. <br />; =========<br />;	We disable Ints...lol.... once again?<br />;	but it looks like some BIOS-es enable ints<br />; 	on int_13 and then forget to disable them again<br />;	on exit<br /><br />	CLI<br />;<br />; STEP.2.<br />; ==========<br />;	Set the GDT  System Table<br />;<br />;	db	0x66<br />;	lidt	&#91;idt_48&#93;	; load idt with 16&#58;32 pointer to IDT<br /><br />	db	0x66		; 32 bit instruction override<br />	lgdt	&#91;gdt_48&#93;	; load gdt with 16&#58;32 pointer to GDT<br /><br /><br />; our last message from REAL MODE...<br />; strange but we cant print messages if ints are disabled?<br /><br />;	mov	si,msg_005<br />;	call	Print_Msg<br /><br /><br />;<br />; STEP.3.<br />;	Go To PROTECTED MODE!<br /><br />;<br />	MOV EAX, CR0<br />	OR AL, 1<br />	MOV CR0, EAX		<br /><br />; MicroP is now in &quot;Protected &#40;safe sex?&#41; mode&quot; &#58;&#41;<br /><br />; pmode1&#58;		jmp	pmode1<br />;<br />; jump far to selector1&#58;pmode_next to clear pipeline ,etc<br />; and to load CS segment with the correct selector<br />; we also have to add 0x7C00 to any absolute address <br />; as we use no linker ;&#41;<br />;<br />	jmp	dword 0x0008&#58;0x7c00+pmode_next<br />;<br /><br />;<br /><br />	<br />pmode_next&#58;<br />;===============================================================<br />; from now on we are in 32 bit protected mode<br />; and we hope never have to leave again &#58;&#41;<br />; but also never forget that here we have no help from bios &#58;&#40;<br />; so we have to know our way with ALL hardware i/o ports and stuff<br />;===============================================================<br />&#91;BITS 32&#93;<br /><br />		nop	; just padding<br />		nop	; also<br /><br />;================================================<br />; kill the floppy disk motor<br />; eh...allready having hardware problems &#58;&#41;<br />;	<br />;	at early testing stages<br />; 	this also told me...for the first time<br />;	that I am in protected mode...at last<br />;	without looseing control..&#58;&#41;<br />;=================================================<br /><br />	mov	edx,0x03f2	<br />	xor	eax,eax<br />	out	dx,al<br /><br />;=================================================<br />; prepare segment registers<br />; all of them now hold segment descriptors<br />; SS is still a problem<br />; because i dont yet have a valid stack descriptor<br />; we now have&#58;<br />; #1.selector 008h		-code 32bits nonconforming	base=0 size=4Giga<br />; #2.selector 010h		-data 32bits read/write		base=0 size=4Giga<br />; #3.selector 018h		-data 32bits read/write		base=0 size=4Giga<br />;=================================================================================<br />	mov	ax,0x0010	; #2 segment descriptor=data r/w 4G<br />	nop<br />	nop<br />	nop<br />;<br />	mov	ds,ax<br />	mov	es,ax<br />	mov	fs,ax<br />	mov	gs,ax<br />;======================================================<br />; treat the StackSegment separately <br />; ... gently with that axe &#58;&#41;<br />; we will use the general data descriptor for now<br />; and setup a new stack starting at 2M boundry<br />; and expanding down of course<br />; this makes 2megabytes our minimum memory req<br />; and i hope our kernel will fit in just 1M<br />; also hope stack will never go too much down<br />; because we are not safe &#58;&#40;<br />;=======================================================<br />	mov	ss,ax<br />	mov	esp,&#40;2*1024*1024&#41;	; 2megabytes for stack &#58;&#41;<br />;<br />	mov	eax,0	;for safety<br />	push	eax<br />	push	eax<br /><br />	mov	ecx,80*5<br />	mov	edx,0xB8000<br />;<br />mic_loop&#58;<br />	mov	al,&quot;A&quot;<br />	mov	bl,0x07<br />	mov	byte &#91;edx&#93;,al<br />	inc	edx<br />	mov	byte &#91;edx&#93;,bl<br />	inc	edx<br />;<br />	dec	ecx<br />	or	ecx,ecx<br />	jnz	mic_loop<br />;<br /><br /><br /><br />test_loop&#58;<br />	in	al,0x64<br />	and	al,0x01<br />	jz	test_loop	; no key then loop back<br /><br />; we have a key<br /><br />	in	al,0x60		;get scan_code<br />	and	al,0x7f		;only one scan_code for both key_up and key_down<br />;<br />	xor	ecx,ecx<br />	mov	cl,al<br />	shl	ecx,2		; *4<br />;<br />	add	ecx,kb_ascii_table+0x7C00	; no linker so i have to do it &#58;&#41;<br />	mov	eax,&#91;ecx&#93;<br /><br />	mov	edx,0xB8000+80*4*2+40*2		;hmmm lots of absolute address here<br />	mov	byte &#91;edx&#93;,al<br />;<br />	cmp	al,13		; Enter Key<br />	jz	setup_ints<br /><br />	jmp	test_loop<br /><br /><br />setup_ints&#58;<br />;===============================<br /><br />; first prepare the 8259 PIC<br /><br />;	call	Init_8259_32<br /><br /><br /><br />	call	Delay32<br /><br /><br />; now the infamouse LIDT instruction<br />;=================================================<br />;	db	0x66		; 32 bit instruction overide<br />	lidt	&#91;idt_48&#93;	; load idt with 16&#58;32 pointer to IDT<br /><br /><br />	int	5<br /><br />;<br />;	sti			; enable ints<br />	jmp	test_loop<br />	<br />big_loop&#58;	<br />	nop<br />	nop<br />	cli<br />	hlt<br /><br />	jmp	big_loop<br /><br /><br /><br />; here is a short delay for input/output operations<br />;==================================================<br />Delay32&#58;<br />	jmp	delay_01_32<br />delay_01_32&#58;<br />	jmp	delay_02_32<br />delay_02_32&#58;<br />	ret<br /><br />; =====================================<br />;   8259 PIC initialization	<br />; =====================================<br />Init_8259_32&#58;					<br />	cli<br /><br />;	mov	si,msg_8259		; tell the user<br />;	call	Print_Msg		; what we do next<br /><br />	mov	al, 11h 		; ICW1 to both controllers<br />	out	20h, al			; bit 0=1&#58; ICW4 provided<br />	call	Delay			; bit 1=0&#58; cascaded PICs<br />	out	0A0h, al		; bit 2=0&#58; call address interval 8 <br />	call	Delay32			; bit 4=1&#58; at 1 &#40;?&#41;<br />		<br />	mov	al, 20h 		; ICW2 PIC1 - offset of vectors<br />	out	21h, al			; irq00 mapped to int020h<br />	call	Delay32<br />		<br />	mov	al, 28h 		; ICW2 PIC2 - offset of vectors<br />	out	0A1h, al		; irq08 mapped to int028h<br />	call	Delay32<br />		<br />	mov	al, 4h			; ICW3 PIC1 &#40;master&#41;<br />	out	21h, al			; bit 2=1&#58; irq2 is the slave<br />	call	Delay32<br />		<br />	mov	al, 2h			; ICW3 PIC2<br />	out	0A1h, al		; bit 1=1&#58; slave id is 2<br />	call	Delay32<br />		<br />	mov	al, 1h			; ICW4 to both controllers<br />	out	21h, al			; bit 0=1&#58; 8086 mode<br />	call	Delay<br />	out	0A1h, al<br />	call	Delay32<br />		<br />	mov	al, 0h			; OCW1 interrupt mask to both<br />	out	20h, al			; no irq masked<br />	call	Delay			; all irq's will trigger int's<br />	out	0A0h, al  <br />	call	Delay32<br /><br />	ret<br /><br /><br /><br /><br />; ======================<br />; interupt handlers<br />; ======================<br />		align 32<br />;<br />int00_hand&#58;	<br />		mov	al,&quot;0&quot;<br />		mov	edx,0xB8000+2*0<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;		<br />		align	32<br />int01_hand&#58;<br />		mov	al,&quot;1&quot;<br />		mov	edx,0xB8000+2*1<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align	32<br />int02_hand&#58;<br />		mov	al,&quot;2&quot;<br />		mov	edx,0xB8000+2*2<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int03_hand&#58;<br />		mov	al,&quot;3&quot;<br />		mov	edx,0xB8000+2*3<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int04_hand&#58;<br />		mov	al,&quot;4&quot;<br />		mov	edx,0xB8000+2*4<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int05_hand&#58;<br />		mov	al,&quot;5&quot;<br />		mov	edx,0xB8000+2*5<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int06_hand&#58;<br />		mov	al,&quot;6&quot;<br />		mov	edx,0xB8000+2*6<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int07_hand&#58;<br />		mov	al,&quot;7&quot;<br />		mov	edx,0xB8000+2*7<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int08_hand&#58;<br />		mov	al,&quot;8&quot;<br />		mov	edx,0xB8000+2*8<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int09_hand&#58;<br />		mov	al,&quot;9&quot;<br />		mov	edx,0xB8000+2*9<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int0A_hand&#58;<br />		mov	al,&quot;A&quot;<br />		mov	edx,0xB8000+2*0x0A<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int0B_hand&#58;<br />		mov	al,&quot;B&quot;<br />		mov	edx,0xB8000+2*0x0B<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int0C_hand&#58;<br />		mov	al,&quot;C&quot;<br />		mov	edx,0xB8000+2*0x0C<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int0D_hand&#58;<br />		mov	al,&quot;D&quot;<br />		mov	edx,0xB8000+2*0x0D<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int0E_hand&#58;<br />		mov	al,&quot;E&quot;<br />		mov	edx,0xB8000+2*0x0E<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int0F_hand&#58;<br />		mov	al,&quot;F&quot;<br />		mov	edx,0xB8000+2*0x0F<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int10_hand&#58;<br />		mov	al,&quot;0&quot;<br />		mov	edx,0xB8000+2*0x10<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int11_hand&#58;<br />		mov	al,&quot;1&quot;<br />		mov	edx,0xB8000+2*0x11<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int12_hand&#58;<br />		mov	al,&quot;2&quot;<br />		mov	edx,0xB8000+2*0x12<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int13_hand&#58;<br />		mov	al,&quot;3&quot;<br />		mov	edx,0xB8000+2*0x13<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int14_hand&#58;<br />		mov	al,&quot;4&quot;<br />		mov	edx,0xB8000+2*0x14<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int15_hand&#58;<br />		mov	al,&quot;5&quot;<br />		mov	edx,0xB8000+2*0x15<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int16_hand&#58;<br />		mov	al,&quot;6&quot;<br />		mov	edx,0xB8000+2*0x16<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int17_hand&#58;<br />		mov	al,&quot;7&quot;<br />		mov	edx,0xB8000+2*0x17<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int18_hand&#58;<br />		mov	al,&quot;8&quot;<br />		mov	edx,0xB8000+2*0x18<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int19_hand&#58;<br />		mov	al,&quot;9&quot;<br />		mov	edx,0xB8000+2*0x09<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int1A_hand&#58;<br />		mov	al,&quot;A&quot;<br />		mov	edx,0xB8000+2*0x1A<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int1B_hand&#58;<br />		mov	al,&quot;B&quot;<br />		mov	edx,0xB8000+2*0x1B<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int1C_hand&#58;<br />		mov	al,&quot;C&quot;<br />		mov	edx,0xB8000+2*0x1C<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int1D_hand&#58;<br />		mov	al,&quot;D&quot;<br />		mov	edx,0xB8000+2*0x1D<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int1E_hand&#58;<br />		mov	al,&quot;E&quot;<br />		mov	edx,0xB8000+2*0x1E<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 32<br />int1F_hand&#58;<br />		mov	al,&quot;F&quot;<br />		mov	edx,0xB8000+2*0x1F<br />		mov	byte &#91;edx&#93;,al<br />		jmp	$<br />;<br />		align 4<br />int20_hand&#58;<br />		mov	eax,0020h<br />		jmp	0x0008&#58;main_int_hand+0x7c00<br />;<br />		align 4<br />int21_hand&#58;<br />		mov	eax,0021h<br />		jmp	0x0008&#58;main_int_hand+0x7c00<br />;<br />		align 4<br />int22_hand&#58;<br />		mov	eax,0022h<br />		jmp	0x0008&#58;main_int_hand+0x7c00<br />;<br />		align 4<br />int23_hand&#58;<br />		mov	eax,0023h<br />		jmp	0x0008&#58;main_int_hand+0x7c00<br />;<br />		align 4<br />int24_hand&#58;<br />		mov	eax,0024h<br />		jmp	0x0008&#58;main_int_hand+0x7c00<br />;<br />		align 4<br />int25_hand&#58;<br />		mov	eax,0025h<br />		jmp	0x0008&#58;main_int_hand+0x7c00<br />;<br />		align 4<br />int26_hand&#58;<br />		mov	eax,0026h<br />		jmp	0x0008&#58;main_int_hand+0x7c00<br />;<br />		align 4<br />int27_hand&#58;<br />		mov	eax,0027h<br />		jmp	0x0008&#58;main_int_hand+0x7c00<br />;<br />		align 4<br />int28_hand&#58;<br />		mov	eax,0028h<br />		jmp	0x0008&#58;main_int_hand+0x7c00;<br />;<br />		align 4<br />int29_hand&#58;<br />		mov	eax,0029h<br />		jmp	0x0008&#58;main_int_hand+0x7c00;<br />;<br />		align 4<br />int2A_hand&#58;<br />		mov	eax,002Ah<br />		jmp	0x0008&#58;main_int_hand+0x7c00;<br />;<br />		align 4<br />int2B_hand&#58;<br />		mov	eax,002Bh<br />		jmp	0x0008&#58;main_int_hand+0x7c00;<br />;<br />		align 4<br />int2C_hand&#58;<br />		mov	eax,002Ch<br />		jmp	0x0008&#58;main_int_hand+0x7c00;<br />;<br />		align 4<br />int2D_hand&#58;<br />		mov	eax,002Dh<br />		jmp	0x0008&#58;main_int_hand+0x7c00;<br />;<br />		align 4<br />int2E_hand&#58;<br />		mov	eax,002Eh<br />		jmp	0x0008&#58;main_int_hand+0x7c00;<br />;<br />		align 4<br />int2F_hand&#58;<br />		mov	eax,002Fh<br />		jmp	0x0008&#58;main_int_hand+0x7c00;<br />;<br />		align 4<br />int30_hand&#58;<br />		mov	eax,0030h<br />		jmp	0x0008&#58;main_int_hand+0x7c00;<br />;<br />		align 4<br /><br /><br /><br /><br /><br />; ========================================<br />; Main interupt handler routine<br />; ========================================<br />		align	32<br />main_int_hand&#58;	<br />		iretd<br /><br /><br /><br /><br />; *********************************************<br />; ************* Descriptor tables *************<br />; *********************************************<br /><br /><br />; =============================================<br />; First the GLOBAL DESCRIPTOR TABLE<br />; witch can have a maximum of &#40;8192 x 8bytes&#41; entrys<br />; each 8 byte entry is an segment descriptor<br />; made of 3 fields&#58;<br />;	1=BASE ADRESS of the SEGMENT<br />;	2=LIMIT of the SEGMENT<br />;	3=ACCESS RIGHTS/TYPE of the SEGMENT<br />;<br />; those 3 fields are &#40;stupidely?&#41; bit mixed and merged<br />; or encoded in a strange way....<br />;<br />;<br /><br />align 32<br /><br />BIG_GDT&#58;<br />;===========================<br />; #0 segment descriptor<br />; dummy <br />; Intel&#40;c&#41;&#40;r&#41; specifications<br />;============================<br />	db	0,0,0,0		; the first selector is dummy<br />	db	0,0,0,0		; and unused even by the microP<br />;<br />; so loading a segment register with a &quot;zero&quot; selector <br />; will show that you dont use that segment<br />; it is ok with the exception of the CS and SS segment registers<br />; witch will generate a protection fault if loaded with zero selector<br />;<br /><br /><br />; ===========================<br />; #1 segment descriptor <br />; index=0x08<br />; code<br />; read is ok<br />; nonconforming<br />; ring 0<br />; base=0 <br />; limit=4Giga<br />; ===========================<br />;<br />; THIS IS/WAS my first &quot;real&quot; segment descriptor<br />; I am so proud of it....cause i thought i will never make it<br />; by hand...<br />; ========================================================================<br />	dw	0xFFFF		; limit00 to limit15=0xFFFF=4GigaByte<br />	dw	0x0000		; base00 to base15=0x0000<br />;<br />	db	0x00		; base16 to base23=0x00<br />	db	0x9A		; 0x9=1001=P/DPL/S<br />				; 0xA=1010=Type=code/nonconforming/read<br />;<br />; P=1=Present<br />; DPL=00=Maximum privilege level ...requ? or applied?<br />; S=1=Code or Data Segment &#40;ie not a system segment&#41;<br />;<br />; Type=1010=b11&#58;b10&#58;b09&#58;b08<br />; b11=1=Code<br />; b10=0=nonconforming<br />; b09=1=Read from code segment is acceptable<br />; 	please note that writeing to a code segment in never<br />; 	acceptable from Intel's point of view...<br />; b08=0=Accessed is zero...until actually loaded?<br /><br /><br />	db	0xCF		; limit16 to limit19=0xF<br />				; 0xC=1100=G&#58;D/B&#58;0&#58;AVL<br />;<br />; G=1=Granularity=4Kbyte increments to the limit<br />; D/B=1=32 bits segment<br />; AVL=0=this bit is available for use by system software..<br />; they are generouse 1bit for free...wow! &#58;&#41;<br />;<br /><br />	db	0x00		; base24 to base31=0x00<br />;==========================================================================<br /><br />; ===========================<br />; #2 segment descriptor <br />; index=0x10<br />; data<br />; read / write<br />; ring 0<br />; base=0 <br />; limit=4Giga<br />; ===========================<br />	dw	0xFFFF		; 4Gb - &#40;0x100000*0x1000 = 4Gb&#41;<br />	dw	0x0000		; base address=0<br />	dw	0x9200		; data read/write<br />	dw	0x00CF		; granularity=4096, 386 &#40;+5th nibble of limit&#41;<br /><br />; ===========================<br />; #3 segment descriptor <br />; index=0x18<br />; read / write <br />; base=0 <br />; limit=4Giga<br />; ===========================<br />	dw	0xFFFF		; 4Gb - &#40;0x100000*0x1000 = 4Gb&#41;<br />	dw	0x0000		; base address=0<br />	dw	0x9200		; data read/write<br />	dw	0x00CF		; granularity=4096, 386 &#40;+5th nibble of limit&#41;<br /><br /><br /><br />align	32<br /><br />BIG_IDT&#58;<br />; ======================================================================<br />; interupt gate 00<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int00_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 01<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int01_hand+0x7c00	; offset 0...15	<br /><br />; interupt gate 02<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int02_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 03<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int03_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 04<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int04_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 05<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int05_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 06<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int06_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 07<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int07_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 08<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int08_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 09<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int09_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 0A<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int0A_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 0B<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int0B_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 0C<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int0C_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 0D<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int0D_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 0E<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int0E_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 0F<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int0F_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 10<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int10_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 11<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int11_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 12<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int12_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 13<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int13_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 14<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int14_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 15<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int15_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 16<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int16_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 17<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int17_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 18<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int18_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 19<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int19_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 1A<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int1A_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 1B<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int1B_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 1C<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int1C_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 1D<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int1D_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 1E<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int1E_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 1F<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int1F_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 20<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int20_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 21<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int21_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 22<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int22_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 23<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int23_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 24<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int24_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 25<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int25_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 26<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int26_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 27<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int27_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 28<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int28_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 29<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int29_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 2A<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int2A_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 2B<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int2B_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 2C<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int2C_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 2D<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int2D_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 2E<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int2E_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 2F<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int2F_hand+0x7c00	; offset 0...15<br /><br />; interupt gate 30<br />	dw	0x0000			; offset 31...16<br />	db	10001110b		; P=1,dpl=00,0,d=1=32bit,xxx<br />	db	00000000b		; rezerved<br />	dw	0x0008			; our only code segment selector<br />	dw	int30_hand+0x7c00	; offset 0...15<br /><br /><br />;<br />	times	8*255	db 0<br /><br />; data structures req. for LGIT and LGDT instructions<br />; ===================================================<br />idt_48&#58;<br />	dw	0x017f		; idt limit=30h*8-1=180-1=17f entries<br />	dd	BIG_IDT+0x7c00	; idt base<br /><br />gdt_48&#58;<br />	dw	0x0004*0x08		; gdt limit=4 max GDT entries<br />	dd	BIG_GDT+0x7c00	; gdt base<br /><br /><br /><br /><br /><br /><br />kb_ascii_table&#58;<br />	dd	0,   27,  '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 8,   9<br />	dd	'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '&#91;', '&#93;', 13,  0,   'a', 's'<br />	dd	'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', 39,  '`', 0,   92,  'z', 'x', 'c', 'v'<br />	dd	'b', 'n', 'm', ',', '.', '/', 0,   '*', 0,   ' ', 0,   3,   3,   3,   3,   8<br />	dd	3,   3,   3,   3,   3,   0,   0,   0,   0,   0,   '-', 0,   0,   0,   '+', 0<br />	dd	0,   0,   0,   127, 0,   0,   92,  3,   3,   0,   0,   0,   0,   0,   0,   0<br />	dd	13,  0,   '/', 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   127<br />	dd	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   '/', 0,   0,   0,   0,   0<br /><br />kb_capslock_table&#58;<br />	dd	0,   27,  '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 8,   9<br />	dd	'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '&#91;', '&#93;', 13,  0,   'A', 'S'<br />	dd	'D', 'F', 'G', 'H', 'J', 'K', 'L', ';', 39,  '`', 0,   92,  'Z', 'X', 'C', 'V'<br />	dd	'B', 'N', 'M', ',', '.', '/', 0,   '*', 0,   ' ', 0,   3,   3,   3,   3,   8<br />	dd	3,   3,   3,   3,   3,   0,   0,   0,   0,   0,   '-', 0,   0,   0,   '+', 0<br />	dd	0,   0,   0,   127, 0,   0,   92,  3,   3,   0,   0,   0,   0,   0,   0,   0<br />	dd	13,  0,   '/', 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   127<br />	dd	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   '/', 0,   0,   0,   0,   0<br /><br />kb_shift_table&#58;<br />	dd	0,   27,  '!', '@', '#', '$', '%', '^', '&amp;', '*', '&#40;', '&#41;', '_', '+', 126, 126<br />	dd	'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '&#123;', '&#125;', 126, 0,   'A', 'S'<br />	dd	'D', 'F', 'G', 'H', 'J', 'K', 'L', '&#58;', 34,  '~', 0,   '|', 'Z', 'X', 'C', 'V'<br />	dd	'B', 'N', 'M', '&lt;', '&gt;', '?', 0,   '*', 0,   1,   0,   1,   1,   1,   1,   1<br />	dd	1,   1,   1,   1,   1,   0,   0,   0,   0,   0,   '-', 0,   0,   0,   '+', 0<br />	dd	0,   0,   1,   127, 0,   0,   0,   1,   1,   0,   0,   0,   0,   0,   0,   0<br />	dd	13,  0,   '/', 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   127<br />	dd	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   '/', 0,   0,   0,   0,   0<br /><br />kb_control_table&#58;<br />	dd	0,   0,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   0,   0,   127, 127<br />	dd	17,  23,  5,   18,  20,  25,  21,  9,   15,  16,  2,   2,   10,  0,   1,   19<br />	dd	4,   6,   7,   8,   10,  11,  12,  0,   0,   0,   0,   0,   26,  24,  3,   22<br />	dd	2,   14,  13,  0,   0,   0,   0,   0,   0,   0,   0,   2,   2,   2,   2,   2<br />	dd	2,   2,   2,   2,   2,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0<br />	dd	0,   0,   2,   0,   0,   0,   0,   2,   2,   0,   0,   0,   0,   0,   0,   0<br />	dd	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0<br />	dd	0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0<br /><br /><br /></code></pre></div>
    <div class="meta">Posted on 2001-08-29 21:26:37 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-5363">
    <div class="subject"><a href="#post-5363">THANK YOU</a></div>
    <div class="body">Thank you boys !!!!!! <br />n u M I T_o r  your links are good, I think we should exchange our experiences and progresses in system programming.<br />BogdanOntanu, your source code is great, I will carefully study it<br />because it seems to me a good base to developing a protected mode system.<br />Anyway, I think I have been successful in Flat Real Mode !!!<br />I have modified, in NASM syntax, the source code of gem0022.txt,<br />making little modifications; I don't fully understand the bitfields of<br />Global Descriptor Table yet , but it is a matter of concentration and time.So I left unaltered those values and the operation made by the code here and switched to pmode. If you load segment register with 0 the system crash, so I left the original value of 24.<br />Then we are back in real mode, but our segment should be 4Gb.<br />My part of program performs stupid and non optimized operation such as printing a message by using DOS ( I saved the ds early in the code at an arbitrary location ), displaying  the Vga ROM BIOS using a flat addressing mode, and finally, writing and reading a character at a location in extended memory. I use different registers, so, if you see this char in the lower right corner of your screen, this means that this should came from extended memory.<br /><br />The file is a simple .com called a.asm<br />The command line :<br /><br />nasmw a.asm -o a.com<br />I restart win98 in DOS mode and launch the program; I haven't noticed any problem to restart windows yet ( but they could happen).<br />So, thanks a lot.<br /><br />;============================================<br /><br /><br /><br /><br /><br /><br /><br />Mem32_GDT       dw 0,0,0,0<br /><br />        dw      0ffffh,0ffh,9a00h,0<br />        dw      0ffffh,0ffh,9200h,0<br />        dw      0ffffh,0ffh,9200h,8fh<br /><br />GDTptr  dw      GDTptr-1-Mem32_GDT<br />        dd      Mem32_GDT ; Absolute adress GDTtable<br />        dw      0<br /><br />mes db 'Hello World$'<br /><br /><br /><br /><br />START:<br /><br />       ;Save ds at an arbitrary location to<br />       ;display message with DOS later<br /><br />       mov di, 0x0000<br />       mov ax, 0x5000<br />       mov es, ax;<br />       mov ax, ds<br />       mov ,ax;<br /><br />       ;=[0x5000:0x0000]<br /><br /><br />        mov     ax,cs           ; set up GDT for this code segment<br />        mov     ds,ax<br />        movzx   eax,ax<br />        shl     eax,4<br />        add     ,eax<br />        lgdt    <br /><br />        mov     ax,cs<br />        and     eax,65535<br />        shl     eax,4<br />        mov     ,ax;<br />        mov     ,ax<br />        ror     eax,16<br />        mov     ,al<br />        mov     ,al<br />        mov     ,ah<br />        mov     ,ah<br /><br />        cli       ; no interrupts<br /><br />        mov   eax,cr0; set protected mode<br />        or      al,1<br />        mov   cr0,eax<br /><br />pmode:<br />        <br />        mov     ax,24; now we are in protected mode;<br />        mov     ds,ax; set all selector limits to 4 GB<br />        mov     es,ax;<br />        mov     fs,ax ;<br />        mov     gs,ax;<br /><br />        mov     eax,cr0; restore real mode<br />        and     al,0feh<br />        mov     cr0,eax<br /><br />        ;db      0eah; far jump to rmode label (unnecessary with Pentium)<br />        ;dw      rmode<br />        ;dw      .text ; (.text is not correct)<br /><br />rmode:<br /><br />        clc                     ; now we are back in real mode, zero carry<br />        sti                     ; to indicate ok and enable interrupts<br /><br />        ;Restore old cs for DOS print string message<br /><br />        mov di, 0<br />        mov ax, 0x5000<br />        mov es, ax;=[0x5000:0x0000]<br />        mov ax, ; get old ds<br />        mov ds, ax<br />       <br />       ;Print string<br /><br />        mov dx, mes;<br />        mov ah, 9;<br />        int 21h;<br /><br />;OK, I want to read VGA BIOS at ADDRESS 0xC000:0x0000<br />;In a flat model it should be byte number 786432<br />;I will use register ds = 0 (16 bit) and esi (32 bit offset)<br /><br />         mov ax, 0<br />         mov ds, ax<br />         mov esi, 786432;<br /><br />;Now a non optimized, primitive routine to access Video Page<br />;starting at address 0xB800:0x0000<br />;I will use es di, both are 16 bit registers<br /><br />         mov ax, 0xB800<br />         mov es, ax<br />         mov di, 0<br /><br />         ;=[0xB800:0x0000]<br /><br />         mov cx, 1200<br /><br />ShowChar<br /><br />         ;read char in bh<br />         mov bh, <br /><br />         ;write char in video memory<br />         mov ,bh<br />	<br />         ;point to next char<br />         inc esi;<br />	<br />          ;2 increments to skip char attributes<br />          inc di;<br />          inc di;<br /><br />          loop ShowChar<br /><br />;OK, now I want to write my own char at an <br />;arbitrary address &gt;16 Mb in RAM<br />;After writing, I want to read it<br />;If all is ok, I should be displayed in<br />;the down right corner of the screen<br /><br />           ;put a face at 24? Mb<br /><br />           mov esi, 25165824; 24? Mb<br />           mov bh, 0x01;<br />           mov , bh;<br /><br />;read face from location 25165824 using another register<br /><br />           mov al, <br /><br />           ;point to corner<br />           mov di, 3998;<br />           ;Display my char<br />           mov ,al<br /><br />End<br />           mov ah, 0x4c;<br />           int 21h</div>
    <div class="meta">Posted on 2001-08-30 03:58:13 by fooCoder</div>
   </div>
   <div class="post" id="post-5401">
    <div class="subject"><a href="#post-5401">Main::Go to protected mode</a></div>
    <div class="body">&gt; n u M I T_o r your links are good, I think we should <br />&gt; exchange our experiences and progresses in system programming. <br /><br />Of course. Here is my email:<br /><br />	<a href="mailto:numit_or@iname.com">numit_or@iname.com</a><br /><br />Please, write me, I've finded more info in the Intel Manual.<br /><br />&gt; I don't fully understand the bitfields of <br />&gt; Global Descriptor Table yet<br /><br />The GDT structure is an array of 8 byte (64 bits).<br />But there are some types of Segment Descriptor we<br />can define. Intel explains the general descriptor<br />format for all types of segment descriptors:<br /><br />bits 0-15: Segment Limit (15:00) - Size of the segment<br />bits 15-31: Segment base (15:00) - location of byte 0 of the segment.<br />bits 32-39: Segment base (23:16)<br />bits 40-43: Type. Indicates the segment or gate type and specifies the <br />possible kinds of access.<br />bit 44: Descriptor type (0=system, 1=code or data)<br />bits 45-46: P - Segment present.<br />bits 48-51: Segment Limit (19:16)<br />bit 52: AVL - Available for use by system software (programmer use)<br />bit 53: 0<br />bit 54: D/B: Default operation size (0=16-bit segment, 1=32-bit seg)<br />bit 55: granularity<br />bit 56: base (31:24)<br /><br />About the base: the processor puts together the to segment limit fields<br />to form a 20-bit value. Ther granularyty field says to the processor<br />how interpret the segment limit.<br /><br />fooCoder, I will test your code...<br /><br /><br />BogdanOntanu:<br />Great source code! It will be very useful for me. Like fooCoder,<br />I will carefully study it. Thanks!<br /><br />nmt</div>
    <div class="meta">Posted on 2001-08-30 13:25:07 by n u M I T_o r</div>
   </div>
   <div class="post" id="post-5545">
    <div class="subject"><a href="#post-5545">BRUTAL DUMPER</a></div>
    <div class="body">Thank you n u M I T_o r, I will write you soon (my email address is <a href="mailto:blueeyestwo@hotmail.com">blueeyestwo@hotmail.com</a>).<br />Following the waves of enthusiasm, I have quickly written <br />a ram dumper that allow you to navigate the memory.<br />It is brutal but it works.<br />You start viewing 4000 bytes from address 1048576 ( the first byte is in the upper left corner of the screen, the last in the lower right corner ).<br />Press '4' to advance 1 byte, press '3' to go back.<br />Press any key ( es. SPACEBAR ) to advance to the next 4000 bytes or press 'b' to go back 4000 bytes.<br />Press '2' to advance 1 Megabyte or '1' to do the opposite.<br />Press 'q' to quit.<br />You should carefully consider how much RAM you have because, if you attempt to read a non existing address, the system hangs.<br />So adjust the correct value in CheckLimit.<br />If you go above the limit or below 0, you return to address 0 ( an interesting address, you can see the Keyboard Buffer and Timer Ticks Counter to modify their values, just keep up pressing '1' ).<br /><br />If you use Win98 restart the PC in DOS mode and launch the program ( and browse . . . .).<br />If you start from DOS, the Extended Memory should be free ( who knows ?)<br /><br />I repeat, it is only a prototype but I have seen interesting things with it!<br /><br />Bye,<br /><br />fooCoder<br /><br />;; <br />;; a1.asm brutal ram dumper ( ALL YOUR RAM !!)<br />;; nasmw a1.asm -o a1.com<br /><br /><br /><br /><br /><br /><br /><br />Mem32_GDT       dw 0,0,0,0<br /><br />        dw      0ffffh,0ffh,9a00h,0<br />        dw      0ffffh,0ffh,9200h,0<br />        dw      0ffffh,0ffh,9200h,8fh<br /><br />GDTptr  dw      GDTptr-1-Mem32_GDT<br />        dd      Mem32_GDT ; Absolute adress GDTtable<br />        dw      0<br /><br /><br /><br />START:<br /><br />        mov     ax,cs           ; set up GDT for this code segment<br />        mov     ds,ax<br />        movzx   eax,ax<br />        shl     eax,4<br />        add     ,eax<br />        lgdt    <br /><br />        mov     ax,cs<br />        and     eax,65535<br />        shl     eax,4<br />        mov     ,ax;<br />        mov     ,ax<br />        ror     eax,16<br />        mov     ,al<br />        mov     ,al<br />        mov     ,ah<br />        mov     ,ah<br /><br />        cli                     ; no interrupts<br /><br />        mov     eax,cr0         ; set protected mode<br />        or      al,1<br />        mov     cr0,eax<br /><br />pmode:<br />        mov     ax,24		; now we are in protected mode;<br />        mov     ds,ax                    ; set all selector limits to 4 GB<br />        mov     es,ax		;<br />        mov     fs,ax		;<br />        mov     gs,ax		;<br /><br />        mov     eax,cr0         ; restore real mode<br />        and     al,0feh<br />        mov     cr0,eax<br /><br />rmode:<br />        clc                     ; now we are back in real mode, zero carry<br />        sti                     ; to indicate ok and enable interrupts<br /><br />	mov ax, 0<br />	mov ds, ax<br />	mov ax, 0xB800;<br />	mov es, ax;<br /><br />;;;;;;;;Start at 1 Mb<br /><br />	mov esi, 1048576;<br /><br />MEMEDIT<br /><br />	;es = 0xB800<br />	;ds = 0<br />	;esi = 1048576<br />	;di = 0;<br /><br />	mov cx, 4000<br />	mov di, 0x0000;<br /><br />Leggi<br />	;read char in bh<br />	mov bh, <br /><br />	;write char in video memory<br />	mov ,bh<br />	<br />	;point to next char<br />	inc esi;<br />	<br />	;2 increments to skip char attributes<br />	inc di;<br />	inc di;<br />	loop Leggi<br /><br />	mov ah, 0x00<br />	int 0x16;<br />quit<br />	cmp al, 'q'<br />	je End<br />MegaAdd<br />	cmp al, '2'<br />	jnz MegaTog<br />	add esi, 1048576<br />	call CheckLimit<br />MegaTog<br />	cmp al, '1'<br />	jnz back<br />	sub esi, 1048576+8000<br />	call CheckLimit<br />back<br />	cmp al, 'b'<br />	jnz forw1<br />	sub esi, 8000<br />	call CheckLimit<br /><br />forw1<br />	cmp al, '4'<br />	jnz back1<br />	sub esi, 3999<br />	call CheckLimit<br />back1<br />	cmp al, '3'<br />	jnz NextPage<br />	sub esi, 4001<br />	call CheckLimit<br />NextPage<br />	jmp MEMEDIT<br /><br />End<br />	mov ah, 0x4c;<br />	int 21h<br /><br />CheckLimit<br /><br />	;Excursion 0-128 Mb is  0 to 0x8000000 - 8000 byte<br />	;On this PC 0 - 64 Mb is 0 to 0x4000000 - 8000 byte<br />	;Put here the value of your RAM<br /><br />	cmp esi,0<br />	ja Maggiore; if &gt; 0<br />	mov esi, 0<br />Maggiore<br />	cmp esi, 0x4000000 - 8000<br />	jna Torna; if not above Torna<br />	mov esi, 0<br />Torna<br />	ret</div>
    <div class="meta">Posted on 2001-08-31 08:38:25 by fooCoder</div>
   </div>
   <div class="post" id="post-5560">
    <div class="subject"><a href="#post-5560">Main::Go to protected mode</a></div>
    <div class="body">flat real mode is baaad carma. First of all, it's not compatible with<br />any &quot;real&quot; operating system, and it can't use emm386 either.<br />Next, your code is still stuck in 16bit. You get no 32bit instructions,<br />unless you use those dreaded 66h and 67h prefixes. Memory management<br />is only really possible with XMS, and you also constantly have to<br />check whether A20 is enabled or not (think there's an XMS function<br />call to handle this). flat realmode / voodo / unreal mode tends to<br />be pretty buggy as well. So I'd advise you to only study it as a<br />curiosity, never ever use it for anything.<br /><br />As for os-development in general, there's a lot of good resources<br />around. Sabre's OS stuff (can't remember URL, but it should be easy<br />to find) is a good starting point with links and stuff.<br /><br />Btw, if you should bump into the V2OS project, don't take the stuff<br />they say too seriously. They simply don't know what they're talking about.<br /><br />Protection is a good thing. It might be a bit difficult to program, but<br />it gives so many wonderful benefits. And doesn't really affect your<br />program speed. Anybody thinking user apps should run ring0 oughta<br />be bitchslapped. Paging and ring0&lt;&gt;ring3 splitting are your friends.<br />Don't bother about segmented &quot;protection&quot;, it's no use really. Stay<br />with 32bit flat protected mode, like windows, linux, bsd, and anything<br />else that's worth more than a penny. If you ever come anywhere,<br />be sure to use paging to separate processes in memory. Paging<br />is REALLY your friend, you can do lots of neat stuff with it.</div>
    <div class="meta">Posted on 2001-08-31 10:51:57 by f0dder</div>
   </div>
  </div>
 </body>
</html>