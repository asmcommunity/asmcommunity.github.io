<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Multiple subprograms - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29903" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29903">Multiple subprograms</a></p>
   <div class="post" id="post-211215">
    <div class="subject"><a href="#post-211215">Multiple subprograms</a></div>
    <div class="body">If i have a linear search subprogram that needs to get called by a get_UnionArray subprogram... From main i pushed 3 arrays and 3 size variables. within get_UnionArray i pushed registers ebp, eax, ebx, ecx, edx... i have to call linear search next. I have to use one of the arrays and its size in linear search. My question is, do i have to push these two parameters on the stack again, or can i access them from linear search after i push ebp and mov ebp,esp within linear search?</div>
    <div class="meta">Posted on 2010-04-03 15:04:48 by ZosoLzrd</div>
   </div>
   <div class="post" id="post-211219">
    <div class="subject"><a href="#post-211219">Re: Multiple subprograms</a></div>
    <div class="body">Short answer: push &#039;em again. There may be optimizations available by using values that happen to already be on the stack. Taking advantage of these is liable to make your program &quot;brittle&quot; - if you change some little thing, the program will crash, unless you change a whole bunch of other stuff to compensate. I doubt if you&#039;ll find the added complication &quot;worthwhile&quot;.<br /><br />You do something a little &quot;unusual&quot; in your program so far...<br /><br /><pre><code><br />...<br />push&nbsp;  array2						; push array2 onto stack for get_array<br />push&nbsp;  size2						; push size2 onto stack to count entries for array2<br /><br />call&nbsp;  get_array					; call subprogram get_array to fill second array<br /><br />pop&nbsp; &nbsp; dword <span style="font-size:2>				; pop counter from stack into size2<br />pop&nbsp; &nbsp; edx						; pop to discard start of array<br />...<br /></code></pre><br /><br />And down in &quot;get_array&quot;, you put the &quot;count&quot; into its position on the stack, so you can get it back the way you do...<br /><br /><pre><code><br />mov&nbsp; &nbsp; , ecx				; copy counter into stack where size is.<br /><br />popa<br />ret<br /></code></pre><br /><br />That works (obviously, it is working), but the more &quot;usual&quot; way to do it would be to return the &quot;result&quot; - which is the count, in this case - in eax. You do need to &quot;clean up the stack&quot; after returning from the call (in this calling convention), but usually the parameters are &quot;thrown away&quot; after they&#039;re used - either popped into a &quot;scratch&quot; register (Dr. Carter likes &quot;pop ecx&quot;, as I recall) or...<br /><br /><pre><code><br />push param3<br />push param2<br />push param1<br />call somefunc<br />add esp, 4 * 3&nbsp; ; 3 parameters @ 4 bytes each<br /></code></pre><br /><br />Another way would be:<br /><br /><pre><code><br />lea esp, <br /></code></pre><br /><br />...which has the advantage that it leaves the flags alone - we can set carry-flag to indicate an error, for example. Your method has the advantage that we can return multiple values (we can return multiple values in registers, too). Usually, we don&#039;t, so that the HLLs can keep up. :)<br /><br />It may be that, as homework, you&#039;re &quot;supposed&quot; to do it the &quot;usual&quot; way.<br /><br />But to get back to (re)pushing parameters... In get_UnionArray, you may have the parameters you need for linear_search in convenient registers that you can just push. If not, you can &quot;push dword &quot;, or whatever. This is a memory-to-memory move - which is generally not allowed, but it works...<br /><br />At first, I thought you wouldn&#039;t want to call linear_search from get_UnionArray, but after it returns... but if get_UnionArray is supposed to eliminate duplicates (?), you&#039;d want to, yeah...<br /><br />If you want to clean up your &quot;program so far&quot;, you&#039;ve got &quot;liner_search&quot; in the comment...<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-04-03 17:29:30 by fbkotler</div>
   </div>
   <div class="post" id="post-211220">
    <div class="subject"><a href="#post-211220">Re: Multiple subprograms</a></div>
    <div class="body"><div class="quote"><br /><br />That works (obviously, it is working), but the more &quot;usual&quot; way to do it would be to return the &quot;result&quot; - which is the count, in this case - in eax.</div><br /><br />How would i do that?<br />Would i write:<br /><pre><code>ret&nbsp; &nbsp; </code></pre><br /><br />Also, when pushing registers, do i need to use &quot;push &quot; or just &quot;push eax&quot;</div>
    <div class="meta">Posted on 2010-04-03 19:16:07 by ZosoLzrd</div>
   </div>
   <div class="post" id="post-211225">
    <div class="subject"><a href="#post-211225">Re: Multiple subprograms</a></div>
    <div class="body">Just &quot;push eax&quot; to save a register. If eax contained a valid address, &quot;push dword &quot; (Nasm would make us specify the size... although it seems obvious) would put the &quot;&quot; of that address on the stack. We might want to do that sometimes, but it doesn&#039;t preserve the value in eax.<br /><br />There&#039;s a variety of &quot;ret&quot; that takes a parameter, but &quot;ret &quot; won&#039;t work. In the &quot;stdcall&quot; calling convention, a subroutine ends in &quot;ret 4&quot; or &quot;ret 8&quot; or &quot;ret 12&quot; - however many bytes of parameters the function took. This removes the parameters from the stack, freeing the calling code from having to do so. Neat! But we&#039;re using the &quot;cdecl&quot; calling convention (no idea how you pronounce that!), where &quot;caller cleans up&quot;, so just &quot;ret&quot;. If the value you want to return is in ecx, &quot;mov eax, ecx&quot; first. But you do &quot;popa&quot;, which will overwrite eax... :(<br /><br />Your &quot;get_array&quot; will make a good example.<br /><br /><pre><code><br />;=== Subprogram get_array===<br />get_array:<br /><br />segment .data<br /><br />moreinputs db&nbsp; &nbsp; &quot;Are the more inputs to be entered(Y=1 or N=0)? &quot;, 0<br />enterprompt db&nbsp; &nbsp; &quot;Enter next number: &quot;, 0<br /><br />segment .bss<br /><br />segment .text<br />pusha<br />mov&nbsp; &nbsp; ebp, esp					; copy esp into ebp to hold place on stack<br /><br />mov&nbsp; &nbsp; edx, 				; move array into edx from stack<br />mov&nbsp; &nbsp; ecx, 0						; move size counter for array into ecx from stack<br /><br />mov&nbsp; &nbsp; eax, moreinputs				; move inputs prompt for printing<br />call&nbsp;  print_string					; print inputs prompt<br />call&nbsp;  read_int<br /><br />if:<br />	cmp&nbsp; &nbsp; eax, 1<br />	jne&nbsp; &nbsp; endif<br /><br />	beginloop:					; statement to start while loop<br />	mov&nbsp; &nbsp; eax, enterprompt			; move enterprompt into eax for printing<br />	call&nbsp;  print_string				; print enterprompt<br />	call&nbsp;  read_int				; read integer from keyboard<br />	mov&nbsp; &nbsp; , eax			; place integer incoming integer into array<br />	add&nbsp; &nbsp; ecx, 1					; increment counter for array size<br />	;<br />	mov&nbsp; &nbsp; eax, moreinputs			; move inputs prompt for printing<br />	call&nbsp;  print_string				; print inputs prompt<br />	call&nbsp;  read_int				;<br />	cmp&nbsp; &nbsp; eax, 1					; 8-bit comparison, if equal then zf = 1, otherwise zf =0<br />	je&nbsp; &nbsp;  beginloop				; jump to start of loop if zf = 1<br />	;<br />endif:<br /><br />mov&nbsp; &nbsp; , ecx				; copy counter into stack where size is.<br /><br />popa<br />ret<br />;==== End of Subprogram get_array ====<br /></code></pre><br /><br />I&#039;m not &quot;comfortable&quot; with that label &quot;isolated&quot; from the code it refers to. If the preceeding source code happened to end in &quot;section .data&quot;, the label would be moved elsewhere with the &quot;.data&quot;... it would make a subtle, hard-to-find bug. So I moved it. This has nothing to do with returning the value.<br /><br />Then I changed to a more &quot;canonical&quot; prolog, &quot;push ebp&quot;/&quot;mov ebp, esp&quot;. You could use &quot;enter 0, 0&quot; here - does the same thing. &quot;enter 4, 0&quot; would do &quot;sub esp, 4&quot; - like I&#039;ve got commented out - as well. We don&#039;t need any local variables, so forget it (and don&#039;t ask what the second parameter to &quot;enter&quot; does!).<br /><br />I ditched the &quot;pusha&quot;/&quot;popa&quot; and just saved the two registers we alter. We&#039;re &quot;allowed&quot; to trash these registers, according to the convention, but it can be &quot;convenient&quot; to save &#039;em. Dr. Carters subroutines in &quot;asm_io&quot; preserve all registers (except returning the result in eax, where there is one), so I did the same.<br /><br />This results in the parameter being in a different position &quot;up the stack&quot;, of course. The &quot;last pushed&quot; parameter, which we may be calling &quot;first&quot;, is at ebp + 8 (skipping 4 for &quot;caller&#039;s ebp&quot; and 4 for return address). The address of our array is currently at  (&quot;second&quot; parameter). I&#039;ve left it that way, but you might want to change it...<br /><br /><pre><code><br />;=== Subprogram get_array===<br /><br />segment .data<br /><br />moreinputs db&nbsp; &nbsp; &quot;Are there more inputs to be entered(Y=1 or N=0)? &quot;, 0<br />enterprompt db&nbsp; &nbsp; &quot;Enter next number: &quot;, 0<br /><br />segment .bss<br /><br />segment .text<br /><br />get_array:<br />push ebp ; save caller&#039;s ebp<br />mov&nbsp; &nbsp; ebp, esp					; copy esp into ebp to hold place on stack<br /><br />; sub esp, ??? ; if you want local variables<br /><br />push ecx&nbsp; ; save caller&#039;s regs that we alter<br />push edx&nbsp; ; these ones are optional - ebx, esi, edi are mandatory (but we don&#039;t alter &#039;em)<br /><br />mov&nbsp; &nbsp; edx, &nbsp;  			; move array into edx from stack<br />mov&nbsp; &nbsp; ecx, 0						; move size counter for array into ecx from stack<br /><br />mov&nbsp; &nbsp; eax, moreinputs				; move inputs prompt for printing<br />call&nbsp;  print_string					; print inputs prompt<br />call&nbsp;  read_int<br /><br />if:<br />	cmp&nbsp; &nbsp; eax, 1<br />	jne&nbsp; &nbsp; endif<br /><br />	beginloop:					; statement to start while loop<br />	mov&nbsp; &nbsp; eax, enterprompt			; move enterprompt into eax for printing<br />	call&nbsp;  print_string				; print enterprompt<br />	call&nbsp;  read_int				; read integer from keyboard<br />	mov&nbsp; &nbsp; , eax			; place integer incoming integer into array<br />	add&nbsp; &nbsp; ecx, 1					; increment counter for array size<br />	;<br />; guard against buffer overflow!<br />; cmp ecx, <br />; ja buffer_full<br /><br />	mov&nbsp; &nbsp; eax, moreinputs			; move inputs prompt for printing<br />	call&nbsp;  print_string				; print inputs prompt<br />	call&nbsp;  read_int				;<br />	cmp&nbsp; &nbsp; eax, 1					; 8-bit comparison, if equal then zf = 1, otherwise zf =0<br />	je&nbsp; &nbsp;  beginloop				; jump to start of loop if zf = 1<br />	;<br />endif:<br /><br />mov&nbsp; &nbsp; eax, ecx				; copy counter to eax for return<br /><br />pop edx&nbsp; ; restore caller&#039;s regs<br />pop ecx<br /><br />mov esp, ebp ; restore esp - we don&#039;t have to do this, since we didn&#039;t alter it<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; if we&#039;d done that &quot;sub esp, ???&quot; to make a local variable,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; this would &quot;free&quot; that memory<br />pop ebp&nbsp; ; restore caller&#039;s ebp<br /><br />; or &quot;leave&quot; does these two things at once<br /><br />ret<br />;==== End of Subprogram get_array ====<br /></code></pre><br /><br />Your calling code looks like:<br /><br /><pre><code><br />...<br />push&nbsp;  array1						; push array1 onto stack for get_array<br />push&nbsp;  size1						; push size1 onto stack to count entries for array1<br /><br />call&nbsp;  get_array					; call subprogram get_array to fill first array<br /><br />pop&nbsp; &nbsp; dword <span style="font-size:1>				; pop counter from stack into size1<br />pop&nbsp; &nbsp; edx						; pop to discard start of array<br />...<br /></code></pre><br /><br />You push the address of the array, which is what we want, and then the address of the size variable... which isn&#039;t really useful, except that it makes a &quot;place&quot; for the return. You&#039;r get_array doesn&#039;t really &quot;use&quot; it - just overwrites it. All get_array really needs for a parameter is the array address. But wait! This will allow the dread buffer overrun! Not good! We really ought to pass a &quot;MAX_COUNT&quot; parameter that we don&#039;t let &#039;em exceed. I put some commented-out code to check for this, assuming that it&#039;d be called like:<br /><br /><pre><code><br />push array1<br />push 50<br />call get_array<br />add esp, 8<br />mov <span style="font-size:1>, eax<br /><pre><code><br /><br />I don&#039;t know if you&#039;d want to make those changes or not - the way you&#039;re doing it works alright. You do have that potential buffer overrun... the user will probably get bored before they enter 50 numbers, but it really isn&#039;t &quot;secure&quot;...<br /><br />Making the user enter &#039;1&#039; or &#039;0&#039; for &#039;y&#039; and &#039;n&#039; is kinda strange... Could you use &quot;read_char&quot; here instead of &quot;read_int&quot;?<br /><br />Save a copy of the &quot;working&quot; version before you start making &quot;improvements&quot;... just in case... :)<br /><br />Best,<br />Frank<br /><br /></code></pre></code></pre></div>
    <div class="meta">Posted on 2010-04-04 10:39:36 by fbkotler</div>
   </div>
   <div class="post" id="post-211226">
    <div class="subject"><a href="#post-211226">Re: Multiple subprograms</a></div>
    <div class="body">THANKS! That&#039;s really helpful.<br /><br />I&#039;ve tried using Y or N, but for some reason it doesn&#039;t read the char.<br />My professor said i would have to write:<br /><br /><pre><code>mov&nbsp; &nbsp; eax, askformoreinputs<br />call&nbsp;  print_string<br />call&nbsp;  read_char<br />call&nbsp;  read_char</code></pre><br /><br />calling read_char twice... i guess it works like cin.ignore() in c++<br /><br />I just used 1 or 0 to make it simpler to write, since i&#039;m the only one that is going to use it.<br />However, i am planning to try to use Y or N once i have everything working.</div>
    <div class="meta">Posted on 2010-04-04 10:49:23 by ZosoLzrd</div>
   </div>
  </div>
 </body>
</html>