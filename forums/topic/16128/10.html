<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>How many are still going to program ASM on 64-bit Windows OS - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16128" />
  <link rel="prev" href="../?id=16128&amp;page=9" />  <link rel="next" href="../?id=16128&amp;page=11" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=16128">How many are still going to program ASM on 64-bit Windows OS</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=16128&amp;page=1" style="">&laquo;</a><a href="../?id=16128&amp;page=9" style="">&lt;</a><input type="hidden" name="id" value="16128" /><input type="number" name="page" min="1" max="15" step="1" value="10" onchange="this.form.submit();" /><a href="../?id=16128&amp;page=11">&gt;</a><a href="../?id=16128&amp;page=15">&raquo;</a></form>   <div class="post" id="post-126394">
    <div class="subject"><a href="#post-126394">loop? see loop.</a></div>
    <div class="body">Bruce, some men you just can't reach.<br /><br />I wonder if hutch hasn't read the previous posts, or if he just doesn't grasp the content.<br /><br />I fail to see where hutch has posted any 'technical data' - unless he considers hacking at things without any quantitive backing, 'technical data'.<br /><br />Perhaps hutch should stick to the things he knows about: PowerBASIC, writing superfast HAND OPTIMIZED ASSEMBLY string scanning algorithms that can beat ANY HIGHLEVEL algorithms WHATSOEVER, and dabbling with philosiphy and political ramblings. And preferably on his own ego-rubbing board, and let us have peaceful and techical discussions here.<br />:rolleyes:</div>
    <div class="meta">Posted on 2003-12-03 09:26:28 by f0dder</div>
   </div>
   <div class="post" id="post-126396">
    <div class="subject"><a href="#post-126396">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body">Same response as before, read my previous postings for the technical data but the argument you started is over. If you have not spoken truthfully about your own knowledge, finally thats your problem, not mine. :tongue: <br /><br />Same old stuff, direct(whatever) was developed to get around limitations of Microsoft OS design.<br /><br />&quot;Then why can you not name a single one of these limitations,&quot;<br /><br />HAL :tongue: <br /><br />Am i taking you seriously ? Arrrrgh ! No. This argument is over.<br /><br />Now how many x86s do you need to strap together to make a supercomputer ?<br /><br />Weep as you calculate the number in the face of OpenGL running on the real high end boxes while direct(whatever) paddles away on Windows boxes and if you are right, a MAC.<br /><br />Lockheed Martin Selects SGI Graphics Supercomputers for two Flight Simulator Projects<br /><br /><a target="_blank" href="http://www.sgi.com/newsroom/press_releases/2003/december/lockheed.html">http://www.sgi.com/newsroom/press_releases/2003/december/lockheed.html</a><br /><br />I wonder why they did not construct their next flight simulator out of a million cheap x86 chips ? Is it they cannot run the SGI OpenGL on x86 or is it just the superior overall technology ? :grin: <br /><br />I wonder why Lockheed Martin, the JPL and other miss you so obvious facts that they could build cheaper faster supercomputers in the graphics area with x86, directX and a cheapie graphics card. These guys must be a bunch of real dorks if what you say is true.<br /><br />Muhahahaha<br />http://www.asmcommunity.net/board/cryptmail.php?tauntspiders=in.your.face@nomail.for.you&amp;id=2f46ed9f24413347f14439b64bdc03fd</div>
    <div class="meta">Posted on 2003-12-03 09:37:41 by hutch--</div>
   </div>
   <div class="post" id="post-126397">
    <div class="subject"><a href="#post-126397">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body"><div class="quote">HAL</div><br /><br />That's a good one... Then you still have to explain why other OSes use similar HALs (including OpenGL yes), and how these HALs differ from the Windows-ones. See? This is yet another loose statement with no technical value whatsoever.<br /><br /><div class="quote">Am i taking you seriously ? Arrrrgh ! No. This argument is over.</div><br /><br />Then why are you still replying?<br /><br /><div class="quote">I wonder why they did not construct their next flight simulator out of a million cheap x86 chips ? Is it they cannot run the SGI OpenGL on x86 or is it just the superior overall technology ?</div><br /><br />That is exactly what I would like to know... You say you know the technical reasons why. Name them.<br /><br /><div class="quote">I wonder why Lockheed Martin, the JPL and other miss you so obvious facts that they could build cheaper faster supercomputers in the graphics area with x86, directX and a cheapie graphics card. These guys must be a bunch of real dorks if what you say is true</div><br /><br />I just say what Microsoft's supercomputer page is saying, as you have seen. And I am just saying what Pixar and google are doing.<br />Besides, I don't think I've specifically used the combination &quot;x86, directx and a cheapie graphics card&quot;.<br />You seem very confused...<br />YOU said 3 things, 3 UNRELATED things.<br />Namely:<br />1) x86 is impossible to use for supercomputers.<br />2) DirectX cannot be implemented on anything else, and cannot compete with OpenGL for technical reasons (which ones are those again?)<br />3) 70s military flightsims and 90s arcade machines were tons faster than even the best PC graphics card today, or in the future, when we have PV 10 GHz PCs.<br /><br />I simply asked you to clarify, and gave you some factual info on how x86 is actually used for supercomputers, DirectX actually is implemented on other systems, and how the 90s Japanese arcade systems that I could find information on, were nothing like what you described. The entire thread is still available, perhaps you should read it again, then it may become more clear what I said and what I didn't say... And ofcourse also what you claimed, and what I found hard to believe, and where I asked you to supply some supporting facts...<br /><br />Read the thread again, then answer the questions, because as you see, they relate directly to your statements and your credibility, unlike most of the rubbish you have been posting lately.<br /><br />Should I take you seriously? Probably not... Everytime you are asked to clarify anything you say, you sidetrack and get arrogant and insulting. Clear signs of someone who cannot back up what he is saying, and tries to use dirty tactics to try and 'win' the argument.<br />I repeat once again, it's not about what I said, it's about what YOU said.<br />So far I (and apparently other readers/participants in this thread) can only conclude that you don't know what you are talking about, and are a sore loser.</div>
    <div class="meta">Posted on 2003-12-03 09:51:49 by Bruce-li</div>
   </div>
   <div class="post" id="post-126398">
    <div class="subject"><a href="#post-126398">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body">Here are some numbers for you,<br /><br />Lets see yours for Windows x86 PCs. :tongue: Feel free to mention a G5, Itanium or x86 Windows box.<br /><br />Onyx4 UltimateVision Extreme<br /><div class="quote"><br />Visualization Specifications*<br />Fill G pixels/sec no FSAA           Up to 76.8G pixels/sec<br />Fill G pixels/sec with FSAA         Up to 51.2G pixels/sec<br />Polygons/sec                        Up to 4800 M poly/sec<br />Display resolution                  Up to 99.2M pixels<br />Display channels                    Up to 64<br />Graphics memory                     Up to 8GB<br /></div><br /><br />Having PHUN are we ?<br /><br /><div class="quote"><br />Then why are you still replying?<br /></div><br />I have been writing test code all day and I am brain dead. this is a good way to put me to sleep after. :alright: <br /><br />Regards,<br />http://www.asmcommunity.net/board/cryptmail.php?tauntspiders=in.your.face@nomail.for.you&amp;id=2f46ed9f24413347f14439b64bdc03fd</div>
    <div class="meta">Posted on 2003-12-03 09:58:43 by hutch--</div>
   </div>
   <div class="post" id="post-126399">
    <div class="subject"><a href="#post-126399">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body">Its just me or this got so boring?<br /><br />Hutch, may you should answer those questions and finally end this ...<br /><br />Just a comment.</div>
    <div class="meta">Posted on 2003-12-03 09:59:35 by Eternal Idol Birmingham</div>
   </div>
   <div class="post" id="post-126403">
    <div class="subject"><a href="#post-126403">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body">1) the Onyx4 is not in the same league as a G5, Itanium or x86 Windows box in any way. So comparisons are useless. It is also not relevant to your statements. And if you divide the Onyx specs by the number of visual processors it has, you end up with something remarkably similar to the ATi R3x0 specs. Besides, there is no reason why Onyx could not run DirectX, is there? In fact... How expensive is that Onyx4 anyway, and how big an Itanium2 cluster could you build for that amount of money? (Not that you'd use an itanium2 cluster for the same kind of job, probably - with that fillrate, the Onyx4 does seem like a good tool for the job - if the same can't be achieved cheaper).<br /><br />2) Do you really think OpenGL is used for the real heavy-duty stuff? Do you think it could render &quot;Finding Nemo&quot; for example? (Hint: where's OpenGL support for NURBS, procedural texures/objects, raytracing, radiosity, photonmapping, non-linear projection, proper softshadows, correct handling of translucent objects, with shadows, correct handling of reflections, refractions (OpenGL can do render-to-texture, but as we all know, this has problems with accuracy and quality, and it is not efficient for recursive reflections/refractions)...). It's also worth to note that GL, like DX, does triangle rasterization - so while the Onyx4 box has a quite nice hardware accelerated rendering subsystem, which is fine for engineering apps, it would still be limited by main CPU muscle if it came to movie rendering - and then some other cluster might be more cost efficient?<br /><br />3) Nobody said DX is available for the most powerful rendering hardware - we claimed that there's no reason why it couldn't be. You showed some, admittedly, impressive systems - but nothing to back up your statements that DX would be unsuitable for these.<br /><br />4) If we are at &quot;Look who's using what&quot; anyway, why was the &quot;Rendering with Natural Light&quot; animation by Paul Debevec (posted earlier by f0dder) rendered on an Itanium2 cluster, and not on an SGI box?<br /><br />5) The right tool for the right job. Nobody said x86 was the best supercomputer - but you said one couldn't build a x86 supercomputer, which is clearly wrong. They just happen to be aimed at other tasks - scientific number crunching (sdu.dk, google.com), non-realtime rendering of video data (pixar).</div>
    <div class="meta">Posted on 2003-12-03 10:42:54 by Bruce-li</div>
   </div>
   <div class="post" id="post-126406">
    <div class="subject"><a href="#post-126406">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body">at the beginning I laughrd my ass off.<br />now...<br /><br />from now on you could just reply to each other by posting things like:<br /><br />&quot;To answer lines 12 to 17 of your post number 25, I repeat the things I said in my post 22, lines 35 to 41&quot;, <br /><br />or , more stylish, <br /><br />you25(12-17)?haha!-&gt;me22(35-41)!<br />you25(22-23)?ridiculous!-&gt;me22(35-41)take that!<br /><br />just beware of recursive loops    :grin:</div>
    <div class="meta">Posted on 2003-12-03 10:56:46 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-126409">
    <div class="subject"><a href="#post-126409">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body">Yes, it's rather sad that we get the same old arguments back at us, that don't relate to the questions we asked, regarding the early statements...<br />It would help if hutch-- could actually answer any of these questions... Then again, I think we all know by know that he cannot, and I think we all see right through the smoke-screen of insults, patronizing, arrogance and non-info that he tries to pull up, trying to cover this.</div>
    <div class="meta">Posted on 2003-12-03 11:04:04 by Bruce-li</div>
   </div>
   <div class="post" id="post-126410">
    <div class="subject"><a href="#post-126410">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body">quote:<br />// &quot;This Onyx4 system will be capable of powering over 120 megapixels of screen area and has a fill rate of over 40 <br />//gigapixels per second, which is enough pixels per second to put a new image on the average screen of every <br />//computer in the world nearly 5000 times a day.&quot;<br /><br />//Lets face it, does a kid playing a directX game on his PC need to have a pixel production rate capable of updating <br />//every computer screen on the planet in real time.<br /><br />I wouldnt consider 5000 fpd* as &quot;realtime&quot; :grin:<br /><br />*note : fpd , abreviation (c) 2003,HeLLoWorld : &quot;frames per day&quot; :grin:<br /><br /><br />(okay, okay, 40Gpix/sec is still nice though)</div>
    <div class="meta">Posted on 2003-12-03 11:05:07 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-126411">
    <div class="subject"><a href="#post-126411">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body">5000 fpd ==approx. 1frame every 17 sec! :grin:</div>
    <div class="meta">Posted on 2003-12-03 11:07:59 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-126414">
    <div class="subject"><a href="#post-126414">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body">i ve read ONCE that dx was bought by microsoft from a small company (an english one i think) and was continued by microsoft, and that it was VERY VERY bad back in these times. but whatever origin DX may have , it s not the same thing anymore, its evolving and maturing (example:dunno bout execute buffer, but i ve been told they was a crappy legacy from the old times, and that now doing without is best) like any software or product that has thousands of dollars to push it forward.<br /><br />Whats wrong? even if it had been designed with 32bx86 in mind , (I absolutely dont know, but ppl say no) , what does it change to its state now? versions after versions, interfaces evolve, and they are just interfaces, not implementations... so the implementation is another matter... <br /><br />besides, maybe dx was designed to do what win couldnt(because win wasnt meant to do it, and not because win was crappy imho) , but it was also designed to allow to do it the same way on different hardware... so saying that &quot;when you ve no win you dont need dx to access hardw, just /*  X=&quot;ly&quot;  */access hardware DIRECT(X)  (okay its so lame maybe nobody will understand theres a lame joke :grin:  )  &quot;  is not a good way of putting down direct i think... coz without dx you then have to support all these accel funcs for all these cards yourself...<br /><br />But thats what hal and drivers and apis are all about, btw in previous posts i wondered if one couldnt vastly simplify apis and programming and OSes (maybe even suppress drivers or apis) by making wider and stricter and better hardware standards... i thought that wasnt done for compatibility s sake and protection and all... but bogdanOntanu said it wasnt done because of hardw manufacturers hiding their specs... that seemed strange, i never thought bout it , but maybe its true...<br /><br />Anyway before I hardly saw once that dx &gt;gl... now thanks to hutch, and bruce and the others I have tech reasons why this should be...</div>
    <div class="meta">Posted on 2003-12-03 11:34:04 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-126415">
    <div class="subject"><a href="#post-126415">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body">quote:<br />//Also, while nobody has said 3D accelerated hardware should be used for final product rendering (see reasons <br />//given above), it can be used for previews, and some pretty impressive stuff. You might want to have a look at the <br />//following two URLs to see some examples:<br />//http://www.daionet.gr.jp/~masa/rthdribl/<br />//http://www.debevec.org/RNL/<br />//The second shows that a standard middle-end Radeon 9700 card can be used for a real-time (and decent frames <br />//per second) approximation of something that took &quot;a while&quot; to render on a high-performance cluster.<br /><br />thnx for these links!<br /><br />....wow.....this.....is....amazing.....! <br /><br />my eyes hurt!<br />since a few months I ve come to think rtrt was the future... but those dear old triangles are still gonna rule the world for a long time producing so fucking beautiful graphics!</div>
    <div class="meta">Posted on 2003-12-03 11:40:40 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-126417">
    <div class="subject"><a href="#post-126417">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body"><div class="quote">i ve read ONCE that dx was bought by microsoft from a small company (an english one i think) and was continued by microsoft, and that it was VERY VERY bad back in these times. but whatever origin DX may have , it s not the same thing anymore, its evolving and maturing (example:dunno bout execute buffer, but i ve been told they was a crappy legacy from the old times, and that now doing without is best) like any software or product that has thousands of dollars to push it forward.</div><br /><br />I doubt that it was bought from another company, since DirectX required modifications to the kernel and driver model. Only MS could do that... Perhaps some other company proposed the idea, but I doubt they could actually build a working DirectX without MS.<br />As for execute-buffers... that's pretty much how early hardware worked... MS asked some leading game developers (including John Carmack) for advice on how to design the API... Carmack wanted a low-level API, as long as it was fast... He said something like &quot;If I could code on the bare metal of the cards, I would, as long as it's fast&quot; (you can find the actual quotes somewhere on the net, I'm sure).<br />The sad part is, when MS actually came up with such an API, Carmack turned out not to be the tough guy he pretended to be, and went for the highlevel OpenGL instead, which is the opposite of what he asked MS for.<br />Most other developers have used Direct3D from the beginning, and performance and quality have always been reasonable, so it wasn't all that bad really.<br />Execute buffers only existed in the first few versions of Direct3D anyway, I believe they were abandoned in DirectX5, and the DrawPrimitive() was introduced... That's the difference between OpenGL and Direct3D. If the hardware changes, Direct3D changes with it. OpenGL remains static, and therefore somewhat unoptimal, hence hacks (aka extensions) need to be provided.<br /><br /><div class="quote">Whats wrong? even if it had been designed with 32bx86 in mind , (I absolutely dont know, but ppl say no) , what does it change to its state now? versions after versions, interfaces evolve, and they are just interfaces, not implementations... so the implementation is another matter... </div><br /><br />You know that, I know that, f0dder knows that... But hutch-- doesn't know that, apparently.<br /><br /><div class="quote">But thats what hal and drivers and apis are all about, btw in previous posts i wondered if one couldnt vastly simplify apis and programming and OSes (maybe even suppress drivers or apis) by making wider and stricter and better hardware standards... i thought that wasnt done for compatibility s sake and protection and all... but bogdanOntanu said it wasnt done because of hardw manufacturers hiding their specs... that seemed strange, i never thought bout it , but maybe its true...</div><br /><br />This is an interesting dilemma... If you make wider hardware standards, this basically limits the freedom of the hardware developers. They are going to make mostly the same hardware then, and it will be hard to compete on a technical level, since you can't easily add or improve features, and make them available to the OS.<br />Hardware manufacturers need to hide at least some of their specs anyway, because they don't want their competitors to copy what they invented (they may have implemented the same function in a cheaper, faster or more clever way).<br />The hardware abstraction layers should make it both easy to program different hardware, and should make it possible to use specific hardware-features... These two things sometimes collide, especially when it comes to graphics. That's one reason why Direct3D is nice... You can check if a feature is present (the device caps), and use it if it is, or use an alternative if it isn't. OpenGL instead forces the manufacturers to put software emulation in for all unsupported features.<br />This means that it's easier to program in a way, because you know it will work... But you don't know HOW it will work... So if you want it to work RIGHT, Direct3D is the easier (or perhaps even the only) way.</div>
    <div class="meta">Posted on 2003-12-03 11:51:44 by Bruce-li</div>
   </div>
   <div class="post" id="post-126426">
    <div class="subject"><a href="#post-126426">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body">YES! I have found it again!<br />the second link is a page where it is said tha DX originally wasnt a microsoft product.<br /><br /><a target="_blank" href="http://www.scorpioncity.com/djdirectxtut.html">http://www.scorpioncity.com/djdirectxtut.html</a><br /><a target="_blank" href="http://www.scorpioncity.com/dj1.html">http://www.scorpioncity.com/dj1.html</a><br /><br />quote:<br />// It was originally purchased from a London company called RenderMorphics, and quietly released more or less as<br />// is as DirectX 2. DirectX 3 was probably the first &quot;serious&quot; release by Microsoft<br /><br />There are also opinions that go somewhat in your way bruce, somewhat not...<br /><br />thnx big time for the history of execute buffers.<br /><br /><br />//This is an interesting dilemma... If you make wider hardware standards, this basically limits the freedom of <br />//the hardware developers. They are going to make mostly the same hardware then, and it will be hard to <br />//compete on a technical level, since you can't easily add or improve features, and make them available to the OS.<br />//Hardware manufacturers need to hide at least some of their specs anyway, because they don't want <br />//their competitors to copy what they invented (they may have implemented the same function in a cheaper, <br />//faster or more clever way).<br /><br /><br />interesting also... I dont see why this should be different with api. in my perfect world there would be hardware with integrated software, like bios, except it would implement the api, that is, it would contain the drivers that are usually provided with devices now. But thats doesnt make it to the api level I think; a DX call isnt just a translation to a windows driver call ? enlighten me please. If not, what is there between?<br /><br />excuse me but i m _really_ interested in knowing if it would be a valid system to have hardw standards making it to the app programming level... whether it will happen or not because of commercial reasons is another matter... but could it be efficient , while still providing compatibility at a given time, backw compatibility, and be flexible enough to allow evolution? <br /><br />You said &quot;so, no new features&quot;. but thats the same with api! just that the api gets extensions as hardw gets capabilities. why couldnt we have  would have firmwares that all implement a specification, and from times to times the specification is changed and ratified ? this even allows periods of transition where hardware manufacturers publish the top level api of their new functions and say &quot;if someone wants to specific-code apps with this then go on&quot; . maybe it is that this embedded soft would be too big... come on , i dont think so (maybe i m wrong).<br /><br />ofcourse its a bit hard to deal with unimplemented features... but the device can report it doesnt handle it and then , only then , we need software package of emulation... <br /><br />well...<br /><br /><br />//You can check if a feature is present (the device caps), and use it if it is, or use an alternative if it isn't.<br /><br />this seems a bit crappy to me, coz youve got to handle all cases in each app you write, but i dont know the subject... yes it sounds more work, but more flexible...<br /><br />//OpenGL instead forces the manufacturers to put software emulation in for all unsupported features.<br /><br />do you mean soft emu in their driver code, and using the cpu? so its even not ogl that handles it when its not there?<br /><br /><br />bye<br />(oh , and i didnt want to hurt someone by making a poll , in fact it has been removed which was a good thing cause i wouldnt have  wanted  to post a war-style poll. i was just laughing at how the arguments were never ending, and thought it would be very funny. apologies if needed. )</div>
    <div class="meta">Posted on 2003-12-03 14:49:20 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-126427">
    <div class="subject"><a href="#post-126427">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body">I once though about &quot;drivers in hardware&quot; too, but... with PCI, AGP and PCI-X busses, there's this little catch: the hardware is not limited to x86. So it would be hard to put a BIOS on the hardware to provide an API, and I don't know if the PCI/whatever standards have any way to &quot;execute commands&quot; on the hardware. Furthermore, it's not guaranteed the hardware BIOS would suit the OS it's running under (running VESA under a 32bit pmode OS requires some virtualization that's not all that funny). Imo, it's better to do as now, and have software drivers - it's also easire to update a software driver than flash firmware, especially for end-users.<br /><br />DirectX comes in multiple levels... there's the ring3 API parts, especially the helper d3dex (or what it's called) code is ring3. Iirc, the model is made so there's a lot of common code in the DirectX you download from microsoft, but no hardware-specific code as such - the video drivers have to support certain features to have DX acceleration, just like they need certain features for GDI acceleration. Iirc, there's a lot of documentation about the specifics in the NTDDK. It's been some years since I glanced at it, but it seemed like a nice way to handle things.<br /><br />So, DirectX is quite a lot more than just calls to driver code.<br /><br />I like the way new features are added to DirectX better than the way it happens with OpenGL... the OpenGL commitee is very slow, so to use any extensions, you lock yourself to the vendor specific extensions you choose to support. With DX, the featureset is determined by microsoft and a bunch of hardware designers, added as a part of the DX specification, and hardware vendors then have to support this in their drivers - so to use DirectX 9 features, you 'just' need a DirectX 9 capable card - you don't have to code specific codepaths for eg nvidia, ATi, &lt;whatever&gt;. There's a couple of new cards hitting the market soon, so this is rather relevant (2 codepaths might be managable, but four including debugging and performance testing == annoying).<br /><br />The capability querying of DX is nice. Either you can use it just to check if necessary features are available, and say &quot;upgrade your graphics card&quot; if they're not - this works a lot better than just checking for certain vendor extension strings, as OpenGL lets you. If you're making a somewhat bigger engine, you can use the caps-querying to enable &quot;eye candy&quot; features if they're available, but let the game run if not. Querying for texture memory available etc lets you optimize the texture set to use, to have less (expensive) texture loads, etc.<br /><br /><div class="quote"><br />do you mean soft emu in their driver code, and using the cpu? so its even not ogl that handles it when its not there?<br /></div><br />Try using a feature in OpenGL that's not fully hardware accelerated, and you'll hit around 1fps. The problem here is that you aren't really able to tell if a certain feature is supported in GL - this isn't as bad as it used to be, but back in the days of GL miniports for not-so-powerful hardware... oh boy :)<br /><br />Btw, the board supports quote and /quote, inside square brackets ([ and ]), instead of manually backslashing lines - oh, and there's a private message feature on the board :)</div>
    <div class="meta">Posted on 2003-12-03 15:16:32 by f0dder</div>
   </div>
   <div class="post" id="post-126428">
    <div class="subject"><a href="#post-126428">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body"><div class="quote">in my perfect world there would be hardware with integrated software, like bios, except it would implement the api, that is, it would contain the drivers that are usually provided with devices now.</div><br /><br />I guess that would make the hardware much more expensive and complex... Perhaps also harder to update drivers.<br />I suppose you mean that a ROM on the hardware stores the driver, and the OS downloads it from the hardware and installs it?<br />If the hardware will actually have to run some of the API code itself, it would require a processor.<br />The legacy BIOS already does this... there are interrupt handlers that are installed by the different hardware by mapping their BIOS into the CPU's addressing space.<br />These interrupt handlers are the API for the 'driver' in a way.<br />But this is very limited, ancient, and hard-to-use technology...<br />If want to bring it to OS-level you would have the problem that it becomes OS-specific... On PCs this doesn't work, because people want to choose the OS themselves (and also be able to upgrade).<br />On proprietary systems like Macintosh and Amiga, this is a more viable approach.<br /><br /><div class="quote">But thats doesnt make it to the api level I think; a DX call isnt just a translation to a windows driver call ? enlighten me please. If not, what is there between?</div><br /><br />Well, that depends a bit on what call it is. Some calls map directly to driver functions, other calls may have some 'neutral' code that is not handled by the driver, but by DX itself.<br />But yes, the view of DX being an interface for the underlying driver is correct in general.<br />You can think of DX as a docking-station... Any hardware-driver can 'dock' to it, and then the functions can be used through DX, which functions as a bridge between OS and driver.<br /><br /><div class="quote">excuse me but i m _really_ interested in knowing if it would be a valid system to have hardw standards making it to the app programming level... whether it will happen or not because of commercial reasons is another matter... but could it be efficient , while still providing compatibility at a given time, backw compatibility, and be flexible enough to allow evolution?</div><br /><br />Hardware usually acts at a much lower level than function calls... Memory-mapped registers, buffers, and I/O ports. There's no other way of using hardware without massively redesigning the whole system, I guess. So the idea of an API that is 'static', and a driver underneath that translates function calls to the proper toggling of bits in hardware registers, mapping hardware buffers to the CPU etc, is probably the best one. This way the programmer doesn't have to know anything about the underlying hardware. And neither does the OS, so any hardware with a working driver can be used.<br /><br />PS2 might be a nice example of a different approach... It has a few separate processors, with their own dedicated memory... The main processor will just upload programs for these processors, and they will execute them without CPU/driver/OS intervention. But I don't think it makes programming any easier, just much harder...<br />And it only works because all PS2s have the exact same hardware.<br /><br /><div class="quote">You said &quot;so, no new features&quot;. but thats the same with api! just that the api gets extensions as hardw gets capabilities.</div><br /><br />Well, that depends... In the case of Direct3D 9 for example, there are some API features that are not supported by any hardware yet. Or what about GDI in the old days? When stuff like linedrawing was not accelerated yet.<br />So when you would let all programs hammer on the hardware directly, they would all implement their own software linedrawing routine... When a manufacturer then comes out with a hardware-linedrawing card, none of the programs use it... All programs have to be rewritten.<br />If all programs nicely use an API-function, then the implementation of the linedrawing can transparently be replaced by a hardware-accelerated one, and all programs will automatically use it, without a problem.<br />So there certainly is something to be said for abstraction of functions.<br /><br /><div class="quote">ofcourse its a bit hard to deal with unimplemented features... but the device can report it doesnt handle it and then , only then , we need software package of emulation...</div><br /><br />Yes, and generally we want this handled by the OS/driver, and not by the program itself... realtime 3d is a big exception there, I'll get to that in just a moment.<br /><br /><div class="quote">this seems a bit crappy to me, coz youve got to handle all cases in each app you write, but i dont know the subject... yes it sounds more work, but more flexible...</div><br /><br />The thing is, if you are trying to write a high-performance 3d application, software emulation is the last thing you want. And in that case there's no other way than letting the programmer decide the best fallback method.<br />Hardware is so incredibly much faster than software in this case, that software-emulation is plain useless...<br />For example, if you simply select the wrong texture format in OpenGL, your application may drop from 500 to 0.5 fps. This is unacceptable. It's a much better solution to let the programmer query the device for the formats it supports, and then choose the best one for the task. Then you can guarantee that the application will always be fast. In most cases it's relatively easy to implement some kind of fallback anyway.<br /><br /><div class="quote">do you mean soft emu in their driver code, and using the cpu? so its even not ogl that handles it when its not there?</div><br /><br />Well, OpenGL is rather odd... Unlike DirectX, it is not directly part of the OS. OpenGL itself is implemented by the driver (that's why it's much harder to make a proper OpenGL driver, and why performance and quality between diiferent vendors could differ greatly... Currently it's mostly ATi and NVIDIA though, and they both seem to have their drivers under control). So yes, the software emulation is in the driver code, using the CPU.<br />It still has to give the 'reference' quality of hardware though, so it's not just a speed-optimized software renderer. It's a very accurate and slow renderer. Not useful at all for realtime purposes.</div>
    <div class="meta">Posted on 2003-12-03 15:28:28 by Bruce-li</div>
   </div>
   <div class="post" id="post-126430">
    <div class="subject"><a href="#post-126430">It's hat eating time :)</a></div>
    <div class="body"><div class="quote"><br />PS: you might wants to ask discreet (3d studio max) and/or Alias|wavefront (maya) what they use to do their final rendering - betcha it's not going to be neither DX or GL. Hell, I'll eat my hat and take pictures of it if proven wrong. (DX/GL is obviously used for accelerating the working environment, though).<br /></div><br /><br /><a target="_blank" href="http://www.alias.com/eng/products-services/maya/technical_features/rendering.shtml">maya renderers</a><br /><br /><div class="quote"><br />Full support for hardware off-screen, background, batch rendering is available from both the Maya user interface and the command line.<br /></div><br /><br />This is programed via a DX interface.<br /><br />Mirno</div>
    <div class="meta">Posted on 2003-12-03 16:16:03 by Mirno</div>
   </div>
   <div class="post" id="post-126432">
    <div class="subject"><a href="#post-126432">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body"><div class="quote">Quickly generate images for pre-visualization and broadcast quality final output. This rendering option generates near software-quality images significantly faster using the power of next-generation graphics cards.</div><br /><br />I don't think f0dder needs to eat his hat just yet... it's still 'near software-quality', so for true production quality, you still need the software. Also, if it is like Mental Ray, it can use the hardware only for part of the rendering process (first pass), and still render a part with software... but it's not entirely clear from the text how the hardware is used.</div>
    <div class="meta">Posted on 2003-12-03 16:22:20 by Bruce-li</div>
   </div>
   <div class="post" id="post-126433">
    <div class="subject"><a href="#post-126433">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body">mmh, and<br /><div class="quote"><br />Quickly generate images for pre-visualization and broadcast quality final output. This rendering option generates near software-quality images significantly faster using the power of next-generation graphics cards.<br /></div><br />Would be interesting to compare this hardware rendered stuff to software rendered - 3d cards *are* getting good. Sounds like the perfect thing for a fast but still decent quality preview.</div>
    <div class="meta">Posted on 2003-12-03 16:22:35 by f0dder</div>
   </div>
   <div class="post" id="post-126435">
    <div class="subject"><a href="#post-126435">How many are still going to program ASM on 64-bit Windows OS</a></div>
    <div class="body">I left that bit out on purpose :tongue:<br />I wouldn't be surprised if the cards were programmed natively, they could manage even higher quality.<br />AFAIK all the drivers use compilers to convert from the &quot;asm&quot; in DX to their native format. I'm guessing they have longer instruction limits than the DX spec enforces, and possibly more optimal code paths.<br /><br />DX10 / OGL2 speced cards will really show some impressive effects.<br /><br />P.S. GL hasn't stopped being updated, it just moves so slowly it just looks that way.<br /><br />Mirno</div>
    <div class="meta">Posted on 2003-12-03 16:34:01 by Mirno</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=16128&amp;page=1" style="">&laquo;</a><a href="../?id=16128&amp;page=9" style="">&lt;</a><input type="hidden" name="id" value="16128" /><input type="number" name="page" min="1" max="15" step="1" value="10" onchange="this.form.submit();" /><a href="../?id=16128&amp;page=11">&gt;</a><a href="../?id=16128&amp;page=15">&raquo;</a></form>  </div>
 </body>
</html>