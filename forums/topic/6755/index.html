<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Is val&gt;lowval and val&lt;highval optomization? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=6755" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=6755">Is val&gt;lowval and val&lt;highval optomization?</a></p>
   <div class="post" id="post-48835">
    <div class="subject"><a href="#post-48835">Is val&gt;lowval and val&lt;highval optomization?</a></div>
    <div class="body">I needed a project to do...and since I like writing containers... I've started work on a safe-access container.  That allocates and will eventually allow r/w and copying with bounds checking.  The current code is meant to work with DWORD data.<br /><pre><code><br />rws&#58;				  ;write<br />	mov ecx,&#91;SSobject&#93;		;Address of object<br />	mov eax,&#91;SSval&#93;		;Write value<br />	mov ebx,&#91;SSindex&#93;		;Write index<br />		<br />	and ebx, 0fffffffch		;index divisable by 4/free sign check!<br />	js  @F			;Less than start? Negative index.<br /><br />	mov edx, ebx<br /><br />	mov edx, &#91;ecx+12&#93;		;More than last? Address of last element <br />	mov esi, edx                            ;* <br />	sub esi, ebx                             ;*ebx=index<br />	cmp esi, edx                             ;*<br />	ja  @F	<br />	<br />	mov ecx, &#91;ecx+8&#93;		;get current pointer to buffer and write<br />	mov &#91;ecx&#93;&#91;ebx&#93;,eax	<br /><br />	ret<br />@@&#58;<br />	mov eax, -1<br />	ret<br /></code></pre><br />Because it is a safe-container and checks access pointers, there is a little more overhead.  I would like to make it as little as needed.  The three memory values at the start, are like a useage '?snapshot?'.  If you keep using the same object, you will not need to update SSobject for every call to the methods stored in the object.  I've got the 'is the index&lt;the start' down to 2 instructions, and , js @F.  If the index is less than 0, it is obviously out of range.   CAn anyone do better with is the 'index greater than total range***' part?</div>
    <div class="meta">Posted on 2002-07-19 11:04:07 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-48841">
    <div class="subject"><a href="#post-48841">Algorithms::Is val&gt;lowval and val&lt;highval optomization</a></div>
    <div class="body">The general equation for quick bounds<br />(with being non-destructive to test value):<pre><code>; EAX is the value to test&#58;<br />	lea edx,&#91;eax-HighValue-1&#93;<br />	IF LowValue NE 0<br />		sub eax,LowValue<br />	ENDIF<br />	xor edx,eax<br />	jns @BadValue</code></pre>This checks for  inclusive.<br />LowValue is zero in your case, so the SUB is not needed.<pre><code><br />Object STRUCT<br />	d1	DWORD	?	; ?<br />	d2	DWORD	?	; ?<br />	Buff	DWORD	?	; ptr<br />	Size	DWORD	?	; bytes in buffer<br />Object ENDS<br /><br />; can only write to &#91;0, &#40;size-granularity&#41;&#93;<br />rws&#58;				;write<br />	mov ecx,&#91;SSobject&#93;		;Address of object<br />	mov eax,&#91;SSindex&#93;		;Write index<br />	mov edx,eax<br />	sub eax, &#91;ecx&#93;.Object.Size	;More than last? Address of last element<br />	sub eax, 4-1 ; ensure whole dword lies in buffer &#40;granularity of buffer -1&#41;<br />	xor eax,edx<br />	jns  @F			;Less than start? Negative index.<br />	mov eax,&#91;SSval&#93;		;Write value<br />	add edx, &#91;ecx&#93;.Object.Buff	;get current pointer to buffer and write<br />	mov &#91;edx&#93;,eax<br />	ret<br />@@&#58;	or eax, -1<br />	ret</code></pre>This is how I would do it.</div>
    <div class="meta">Posted on 2002-07-19 12:03:34 by bitRAKE</div>
   </div>
   <div class="post" id="post-48851">
    <div class="subject"><a href="#post-48851">Algorithms::Is val&gt;lowval and val&lt;highval optomization</a></div>
    <div class="body">:grin:<br /><br /><pre><code><br />	mov eax,&#91;SSval&#93; ; value<br />	mov ebx,&#91;SSindex&#93; ; index<br />	mov ecx,&#91;SObject&#93; ; object<br />	bound ebx,&#91;ecx+Object.Limits&#93; ; check index bounds<br />	add ebx,&#91;ecx+Object.Buffer&#93; ; add buffer pointer<br />	mov &#91;ebx&#93;,eax<br /></code></pre></div>
    <div class="meta">Posted on 2002-07-19 13:18:46 by Nexo</div>
   </div>
   <div class="post" id="post-48854">
    <div class="subject"><a href="#post-48854">Algorithms::Is val&gt;lowval and val&lt;highval optomization</a></div>
    <div class="body"><strong>Nexo</strong>, don't forget the exception handler. :grin:</div>
    <div class="meta">Posted on 2002-07-19 13:23:06 by bitRAKE</div>
   </div>
   <div class="post" id="post-48855">
    <div class="subject"><a href="#post-48855">Algorithms::Is val&gt;lowval and val&lt;highval optomization</a></div>
    <div class="body">Don't entirely understand this part:<br /><pre><code><br />	sub eax, &#91;ecx&#93;.Object.Size	;More than last? Address of last element<br /></code></pre><br />index=index-size<br /><pre><code><br />	sub eax, 4-1 ; ensure whole dword lies in buffer &#40;granularity of buffer -1&#41;<br /></code></pre><br />???4-1??? You mean 3 right??<br /><pre><code><br />	xor eax,edx<br /></code></pre><br />Uhhh.....<br />At least....<br /><pre><code><br />	sub eax, &#91;ecx&#93;.Object.Size<br /></code></pre><br />I learned a better way to express a register offset</div>
    <div class="meta">Posted on 2002-07-19 13:23:44 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-48859">
    <div class="subject"><a href="#post-48859">Algorithms::Is val&gt;lowval and val&lt;highval optomization</a></div>
    <div class="body"><strong>ThoughtCriminal</strong>, there are three possiblities: low, good, high.<pre><code>; sign bits				; low	good	high<br />	lea edx,&#91;eax-HighValue-1&#93;	;  1	 1	 0<br />	sub eax,LowValue		;  1	 0	 0<br />	xor edx,eax			;  0	 1	 0<br />	jns @BadValue			;</code></pre>If we were moving just bytes then the valid range would be [0,(size-1)].  But with dwords the valid range is [0,(size-4)].  Put those values in the algorithm above (LowValue = 0, HighValue = (size-4)) and you will see how the code came to be.</div>
    <div class="meta">Posted on 2002-07-19 13:40:21 by bitRAKE</div>
   </div>
   <div class="post" id="post-48866">
    <div class="subject"><a href="#post-48866">Algorithms::Is val&gt;lowval and val&lt;highval optomization</a></div>
    <div class="body"><div class="quote"><br /><strong>Nexo</strong>, don't forget the exception handler. :grin: </div><br />Yes, of course. As it will be not so <em>fast</em> to work. But sometimes it looks nice :)<br /><br /><span style="font-size:9px><br />I have noted, that you started to use [] more often. We get used to the order? ;)<br /></span></div>
    <div class="meta">Posted on 2002-07-19 15:38:57 by Nexo</div>
   </div>
   <div class="post" id="post-48867">
    <div class="subject"><a href="#post-48867">Algorithms::Is val&gt;lowval and val&lt;highval optomization</a></div>
    <div class="body"><strong>Nexo</strong>, sorry, but I do not understand your question?<br />Or, maybe I have not noticed of what you speak?</div>
    <div class="meta">Posted on 2002-07-19 15:42:52 by bitRAKE</div>
   </div>
   <div class="post" id="post-48870">
    <div class="subject"><a href="#post-48870">Algorithms::Is val&gt;lowval and val&lt;highval optomization</a></div>
    <div class="body">I am speak about squared bracket.<br />You never saw Paradigm or Turbo assembler?</div>
    <div class="meta">Posted on 2002-07-19 16:15:26 by Nexo</div>
   </div>
   <div class="post" id="post-48887">
    <div class="subject"><a href="#post-48887">Algorithms::Is val&gt;lowval and val&lt;highval optomization</a></div>
    <div class="body">No, never seen Paradigm.  I used TASM very briefly (couple months), read Tom Swan's book then some others, but I used square brankets with NASM and now FASM.  They are easy to type as other letters. ;)</div>
    <div class="meta">Posted on 2002-07-19 18:44:52 by bitRAKE</div>
   </div>
   <div class="post" id="post-48929">
    <div class="subject"><a href="#post-48929">Re: Is val&gt;lowval and val&lt;highval optomization?</a></div>
    <div class="body"><div class="quote"><br />I needed a project to do...and since I like writing containers... I've started work on a safe-access container.  That allocates and will eventually allow r/w and copying with bounds checking.  The current code is meant to work with DWORD data.<br /><br />[..]<br /><br />Because it is a safe-container and checks access pointers, there is a little more overhead.  I would like to make it as little as needed.  The three memory values at the start, are like a useage '?snapshot?'.  If you keep using the same object, you will not need to update SSobject for every call to the methods stored in the object.  I've got the 'is the index&lt;the start' down to 2 instructions, and , js @F.  If the index is less than 0, it is obviously out of range.   CAn anyone do better with is the 'index greater than total range***' part? </div><br /><br />These should be optimal on a wide range of CPU's:<br /><br /><pre><code><br />        CMP     REG,Upper               ; REG is the register we want to test<br />        JAE     out_of_bounds           ; or you can use JB inside_bounds &#40;inverted condition&#41;<br /></code></pre><br />and:<br /><pre><code><br />        LEA     REG2,&#91;REG-Lower&#93;        ; REG is the register we want to test<br />        CMP     REG2,Upper-Lower        ; REG2 is a temporary, scratch register<br />        JAE     out_of_bounds           ; or you can use JB inside_bounds &#40;inverted condition&#41;<br /></code></pre><br /><br />NOTE: in the above Lower..Upper ranges by &quot;convention&quot; (of a lot of programming languages) I consider Lower <em>included</em> and Upper <em>excluded</em>.<br /><br />NOTE2: since we're talking about ~optimizations here, we should give to branch prediction the importance that it deserves.<br />Remember that uncached (i.e. &quot;new&quot;) branches are considered by default &quot;taken&quot; if unconditional or if backward-targeted, and are considered &quot;untaken&quot; if indirect or forward-targeted.<br /><br />This means that the above code is ok if <strong>statistically</strong> you believe that most of the times the code will go through with no branch happening, AND the eventual branch target label is forward.<br /><br />If you believe that a branch is likely to happen often instead, then (for best optimization) you should place your target label backward, <em>x</em>or invert the branch condition (thus inverting again the branch statistics).<br /><br /><br /><br /><br /><strong>I already wrote with much detail about this subject, which I report here because I don't know how to put links of posts:</strong> <br /><br /><br /><br /><br />Extending the concept, here are other possible schemes:<br /><br /><pre><code><br />ebx,ecx,edx,esi = up to 4 &#40;5 if we use EBP, 6 if we use ESP&#41; indexes we want to check<br />eax             = temporary register<br />edi             = scratch register &#40;must be set to zero initially&#41;<br /></code></pre><br /><br />1) if ALL of the indexes are INSIDE of bounds, jump label<br /><br />PseudoCode: IF (ebx&gt;=LOWER1 &amp;&amp; ebx&lt;UPPER1) &amp;&amp; (ecx&gt;=LOWER2 &amp;&amp; ecx&lt;UPPER2) &amp;&amp; (edx&gt;=LOWER3 &amp;&amp; edx&lt;UPPER3) &amp;&amp; (esi&gt;=LOWER4 &amp;&amp; esi&lt;UPPER4) THEN GOTO label<br /><br /><pre><code><br />                                xor             edi,edi<br />                                ;<br />                                lea             eax,&#91;ebx-UPPER1&#93;<br />                                cmp             eax,LOWER1-UPPER1<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;ecx-UPPER2&#93;<br />                                cmp             eax,LOWER2-UPPER2<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;edx-UPPER3&#93;<br />                                cmp             eax,LOWER3-UPPER3<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;esi-UPPER4&#93;<br />                                cmp             eax,LOWER4-UPPER4<br />                                adc             edi,edi<br />                                ;<br />                                jz              label<br /></code></pre><br /><br />---<br /><br />2) if ALL of the indexes are OUTSIDE of bounds, jump label<br /><br />PseudoCode: IF (ebx&lt;LOWER1 &amp;&amp; ebx&gt;=UPPER1) &amp;&amp; (ecx&lt;LOWER2 &amp;&amp; ecx&gt;=UPPER2) &amp;&amp; (edx&lt;LOWER3 &amp;&amp; edx&gt;=UPPER3) THEN GOTO label<br /><br /><pre><code><br />                                xor             edi,edi<br />                                ;<br />                                lea             eax,&#91;ebx-LOWER1&#93;<br />                                cmp             eax,UPPER1-LOWER1<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;ecx-LOWER2&#93;<br />                                cmp             eax,UPPER2-LOWER2<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;edx-LOWER3&#93;<br />                                cmp             eax,UPPER3-LOWER3<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;esi-LOWER4&#93;<br />                                cmp             eax,UPPER4-LOWER4<br />                                adc             edi,edi<br />                                ;<br />                                jz              label<br /></code></pre><br /><br />---<br /><br />3) if ANY of the indexes are INSIDE of bounds, jump label<br /><br />PseudoCode: IF (ebx&gt;=LOWER1 &amp;&amp; ebx&lt;UPPER1) || (ecx&gt;=LOWER2 &amp;&amp; ecx&lt;UPPER2) || (edx&gt;=LOWER3 &amp;&amp; edx&lt;UPPER3) || (esi&gt;=LOWER4 &amp;&amp; esi&lt;UPPER4) THEN GOTO label<br /><br /><pre><code><br />                                xor             edi,edi<br />                                ;<br />                                lea             eax,&#91;ebx-LOWER1&#93;<br />                                cmp             eax,UPPER1-LOWER1<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;ecx-LOWER2&#93;<br />                                cmp             eax,UPPER2-LOWER2<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;edx-LOWER3&#93;<br />                                cmp             eax,UPPER3-LOWER3<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;esi-LOWER4&#93;<br />                                cmp             eax,UPPER4-LOWER4<br />                                adc             edi,edi<br />                                ;<br />                                jnz             label<br /></code></pre><br /><br /><br />---<br /><br />4) if ANY of the indexes are OUTSIDE of bounds, jump label<br /><br />PseudoCode: IF (ebx&lt;LOWER1 &amp;&amp; ebx&gt;=UPPER1) || (ecx&lt;LOWER2 &amp;&amp; ecx&gt;=UPPER2) || (edx&lt;LOWER3 &amp;&amp; edx&gt;=UPPER3) || (esi&lt;LOWER4 &amp;&amp; esi&gt;=UPPER4) THEN GOTO label<br /><br /><pre><code><br />                                xor             edi,edi<br />                                ;<br />                                lea             eax,&#91;ebx-UPPER1&#93;<br />                                cmp             eax,LOWER1-UPPER1<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;ecx-UPPER2&#93;<br />                                cmp             eax,LOWER2-UPPER2<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;edx-UPPER3&#93;<br />                                cmp             eax,LOWER3-UPPER3<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;esi-UPPER4&#93;<br />                                cmp             eax,LOWER4-UPPER4<br />                                adc             edi,edi<br />                                ;<br />                                jnz              label<br /></code></pre><br /><br />---<br /><br />As you easily noted, if you invert ANY with ALL (or viceversa) and you also invert INSIDE with OUTSIDE (or viceversa) and the final branch instruction, then the code is perfectly the same.<br />That's why 3) and 4) are the same, and 1) and 4 are the same as well (of course with inverted branch).<br />This is exactly like to say that:<br />a OR b OR c<br />is perfectly equivalent to:<br />NOT ( (NOT a) AND (NOT b) AND (NOT c) )<br /><br />---<br /><br />Some remarks and general rules to help understanding, so this moves from &quot;black magic&quot; to something very intuitive, and expecially simple and easy to use:<br /><br />a) the LEA,CMP trick simply sets the carry flag if we're inside the bounds, and clears it if we're outside the bounds.<br /><br />b) said that, then we can use ADC reg,0 to accumulate in reg that single carry value, but we can also perform other operations, like RCL (more on this below). Note that instead of the 0 constant we can use a register, which makes the code smaller and thus faster (at least for cache considerations).<br /><br />c) now think again about the a) point. We can not invert the behaviour of CMP (i.e. the result it gives), but we could exploit the CMC instruction where it matters to complement the carry flag. For example:<br /><br />    LEA     EAX,<br />    CMP     EAX,UPPER1-LOWER1<br />    CMC                        ; this inverts the carry flag, and thus the result<br />    ADC     EDI,0              ; where 0 will be in a register, preferably<br /><br />But CMC may not be the fastest solution.<br />Having multiple indexes to check, we can use RCL:<br /><br />    LEA     EAX,<br />    CMP     EAX,UPPER1-LOWER1<br />    RCL     EDI,1<br />many times, and then apply a XOR mask to our final EDI register result, so that after the XOR we get a zero result if the bit mask is the one we wanted, in order to satisfy all the conditions we want in order to perform the final branch.<br /><br />But we don't even need that.. yes, we CAN invert the behaviour of CMP. How? Simply inverting the range:<br />    LEA     EAX,<br />    CMP     EAX,UPPER1-LOWER1<br />becomes:<br />    LEA     EAX,<br />    CMP     EAX,LOWER1-UPPER1<br /><br />So, to sum it all:<br /><br />---<br /><br />we can produce a carry flag depending on if an index is in range or not (i.e. carry=1 if inside bounds):<br /><br />    LEA     EAX,<br />    CMP     EAX,UPPER1-LOWER1<br /><br />or, if the lower range is 0, then we can use just:<br /><br />    CMP     EBX,UPPER1<br /><br />we can get inverted CMP behaviour (i.e. carry=1 if outside bounds) by simply doing:<br /><br />    LEA     EAX,<br />    CMP     EAX,LOWER1-UPPER1<br /><br />or, if the lower range is 0, then we can use:<br /><br />    CMP     EBX,UPPER1<br />    CMC     ;beware as CMC may get slow if abused, in some CPU's<br /><br />---<br /><br />Now that we've the power to produce a carry, inverted or not, depending on a lower..upper (or 0..upper) range, we can &quot;accumulate&quot; these carry flag results, one for each condition/index we want to check, using one of the following methods:<br /><br />    ADC     reg,0    ; instead of 0 we can use a register which is known to be zero)<br />the above ADC will increment reg every time a carry flag was found set. A typical use is in the &quot;OR&quot; constructs.. i.e. if the final result of reg is not 0, then at least one ADC had a carry to add, and thus at least one condition was true (or false, depending if we produced the carry flag inverted or not).<br /><br />we could set up reg e.g. to 4, and then SBB (subtract if the carry flag is found set) at each index/condition check: if our initial reg (which was set to the value 4) then reachs 0, we're sure that all 4 conditions were true. But we don't need this extra overhead: we can invert the conditions and use ADC.. thus use less instructions (remember the OR -&gt; AND tranform of above?).<br /><br />also, we could collect all carry flags via RCL reg,1 .. then XOR the final result with a mask, so that after the XOR we get a zero result if the bit mask is the one we wanted, in order to satisfy all the conditions we want to perform the final branch. But, again, we can instead always use ADC and simply invert the CMP result each specific time that we want so. This way we save the extra XOR.<br /><br />Finally, we can accumulate a result by doing ADC reg,reg caring only that the reg was 0 *initially*. This because by being able to exploit the &quot;inverted CMP&quot; trick I exposed, we only care that the final result of all those ADC's will be 0 or not (to then either JZ label or JNZ label).<br /><br />Note that ADC reg,reg doesn't take advantage of reg being eax (ADC reg,0 instead does). Neither LEA or XOR do take advantage of reg being eax. However, CMP does.. so I'm using EAX as temporary register in my lower..upper checks.<br /><br />---<br /><br />With the above explanation I tryed to move the discussion from black magic to something easy and intuitive to control.<br />Now there's something important to add.<br /><br />After years of experience, I designed my programming language's compiler in a way that privileges the optimizer to the compiler.. i.e. the compiler doesn't try to be _excessively_ smart, while the optimizer does.<br /><br />So a sequence like:<br /><br />PseudoCode: IF (ebx&gt;=LOWER1 &amp;&amp; ebx&lt;UPPER1) || (ecx&gt;=LOWER2 &amp;&amp; ecx&lt;UPPER2) || (edx&gt;=LOWER3 &amp;&amp; edx&lt;UPPER3) || (esi&gt;=LOWER4 &amp;&amp; esi&lt;UPPER4) THEN GOTO label<br /><br />gets initially compiled to:<br /><pre><code><br />                                lea             eax,&#91;ebx-LOWER1&#93;<br />                                cmp             eax,UPPER1-LOWER1<br />                                jc              label<br />                                lea             eax,&#91;ebx-LOWER2&#93;<br />                                cmp             eax,UPPER2-LOWER2<br />                                jc              label<br />                                lea             eax,&#91;ecx-LOWER3&#93;<br />                                cmp             eax,UPPER3-LOWER3<br />                                jc              label<br />                                lea             eax,&#91;esi-LOWER4&#93;<br />                                cmp             eax,UPPER4-LOWER4<br />                                jc              label<br /></code></pre><br /><br />and then the optimizer (for how it is designed) could recognize this typical scheme (also aided by some side info), seek for another free register (it chooses, if present, one that incidentally is already known to be zeroed), and change the above code sequence in part or completely to:<br /><br /><pre><code><br />                               ;xor             edi,edi              &#40;only if necessary&#41;<br />                                lea             eax,&#91;ebx-LOWER1&#93;<br />                                cmp             eax,UPPER1-LOWER1<br />                                adc             edi,edi<br />                                lea             eax,&#91;ecx-LOWER2&#93;<br />                                cmp             eax,UPPER2-LOWER2<br />                                adc             edi,edi<br />                                lea             eax,&#91;edx-LOWER3&#93;<br />                                cmp             eax,UPPER3-LOWER3<br />                                adc             edi,edi<br />                                lea             eax,&#91;esi-LOWER4&#93;<br />                                cmp             eax,UPPER4-LOWER4<br />                                adc             edi,edi<br />                                jne             label<br /></code></pre><br /><br />But I didn't even bother to implement this.<br /><br />Why? Because if we really want to exploit the power of assembly, then we should always use our brain, not just use others' code or a technique blindly. Note that in case all of our conditions are related by &quot;OR&quot;, all of the above is absolutely stupid, since it will check all of 4 conditions when maybe even just the first was sufficient to exit this big &quot;IF&quot; construct.<br /><br />In my programming language, I can set for each high level instruction (in this case &quot;IF&quot;) an optimizer setting which then the editor normally hides. This optimizer setting, in this case, would be &quot;optimize or not&quot;, and to which extent.<br /><br />Extensive use of nearly totally AUTOMATIC profiling then fine-tunes these specific instruction optimizer's settings.<br /><br />I try to keep things as much automatic as possible, although of course I'm here to advocate the use of hand written assembly. Yet being myself such a great fan of assembly has made me write a very efficient optimizer for my LLL/MLL/HLL language's compiler.<br /><br />You should also be aware that if e.g. you have 4 conditions and &quot;if any of them is valid you will jump&quot;, then you better put the most probable one as the first one to test (and so on), so that _statistically_ your routine will perform better. In my language I've a set of tools that help me also on these issues.. of course the goal is to produce extremely efficient code in less time than if I had to write it directly in hand optimized assembly. Honestly I'm very, very happy with the results.. and that's why I've always adviced you all to spend no less than half of your development time on your very own development tools.. that's the most intelligent and productive thing you could do.. at the end it pays with the interests, more than you may imagine. And it will feel &quot;yours&quot; more than anything else.<br /><br /><br />---<br /><br /><br />I'd like to extend what I wrote some posts above about advanced uses of the<br />carry flag. When you check for a bound, e.g. from 0 (included) to 32 (excluded),<br />you can do, as we saw in that post, a simple:<br /><pre><code><br />                CMP     ECX,32<br /></code></pre><br />now the carry flag will be set if ECX is within 0 (included) to 32 (excluded).<br />(note that the &quot;from included to excluded&quot; is what is typically used in bound<br />checkings, for example for arrays).<br /><br />We can now exploit another trick:<br /><pre><code><br />                SBB     EAX,EAX<br /></code></pre><br />regardless of what was in EAX before, now EAX will be all zeros if the carry<br />flag was set by CMP (which is like to say &quot;if we were inside the bounds&quot;, but<br />EAX will be all ones (i.e. FFFFFFFF hex) if the carry was clear (i.e. if we<br />were out of bounds).<br /><br />Now we can use the EAX mask we obtained to do many interesting tricks, using<br />for example the AND, OR and XOR instructions.<br /><br />To remain in topic with this thread, we may want to select one of two 32 bit<br />values depending on if ECX is within the bounds or not.<br /><br /><br />On P6 and higher:<br /><pre><code><br />                MOV     EBX,MASK1<br />                MOV     EAX,MASK2<br />                CMP     ECX,32<br />                CMOVC   EAX,EBX<br /></code></pre><br />Now EAX will contain MASK1 or MASK2, depending if ECX is within bounds or not.<br /><br /><br />For CPU's &lt;= P5 we can do instead:<br /><pre><code><br />                MOV     EAX,MASK2<br />                CMP     ECX,32<br />                SBB     EBX,EBX<br />                AND     EBX,MASK1^MASK2          ; MASK1 xor MASK2<br />                XOR     EAX,EBX<br /></code></pre><br />How does it work? It's simple.. and maybe it's about time to remove the magic<br />also from the tricks that use another very useful instruction: XOR.<br /><br />So, we already know that, after SBB, EBX will be either all 0's or all 1's,<br />depending if ECX is within the bounds we've specified or not.<br />Now, for example, do you recall the formula to implement linear interpolation?<br /><br />It's just a:<br /><br />result = (A*(1-alpha))+(B*alpha)     ; where alpha is from 0.0 to 1.0<br /><br />but the above can be rewritten this way, which is perfectly equivalent (but simply more optimized):<br /><br />result = A+(alpha*(B-A))<br /><br />i.e. we start from A and then account only for the difference between B and A,<br />&quot;to fill the gap&quot;.<br /><br />We can use the same technique to set a value, and eventually fix it later as<br />much as needed to transform it into another value. We could have written it<br />also this way:<br /><pre><code><br />                MOV     EAX,MASK2<br />                CMP     ECX,32<br />                SBB     EBX,EBX<br />                AND     EBX,MASK1-MASK2         ; difference between MASKs<br />                ADD     EAX,EBX<br /></code></pre><br />It's just that I prefer to use logical instructions instead of arithmetic<br />ones, when possible (there are good reasons to do so, but I do not want to<br />make this post too long).<br /><br />---<br /><br />So now we've a P6 (using CMOV) or P5 method to select the right mask.. and<br />we can finally test it:<br /><pre><code><br />                BT      EAX,ECX<br />                JNC     .notvalid<br /></code></pre><br />But BT may be a slow instruction in some CPU's .. so here's an alternative<br />method:<br /><pre><code><br />                SHR     EAX,CL<br />                JC      .notvalid<br /></code></pre><br />Just remember two things if you use the above:<br />1) ECX must not be higher than 31 .. because otherwise unfortunately Intel does<br />not *guarantee* a correct carry flag :( So place a AND ECX,31 before the SHR.<br />2) You must increment of 1 unit CL to obtain the same result obtained with BT.<br />You may account for this in the LEA instruction, or rotate the masks, etc..<br /><br />---<br /><br />To sum it all this is my code for &quot;bitmap register lookup&quot;. I've to admit<br />that my own programming language's compiler/optimizer gave me some hints,<br />because I was too lazy to think about some of the above things myself. ;)<br /><pre><code><br />                MOV     EBX,MASK1<br />                MOV     EAX,MASK2<br />                CMP     ECX,32            ; ECX is a 0..63 index<br />                CMOVC   EAX,EBX<br />                BT      EAX,ECX<br />                JNC     .notvalid<br /></code></pre><br />Maybe it can be improved furtherly.. but I've no time right now. I will try<br />later perhaps, since I'd like to send this stuff to Thomas' snippets section;<br />together with the profile code (BTW, <strong>grv575</strong>, since I'd like to give you proper<br />credits for your MASM translation, please could you give me your full name,<br />or anyway the name you prefer to be credited with?); and maybe also send the<br />stuff about CMP and the carry flag. Later I may add other contributions,<br />since I'm trying to be less ****ole and maybe share the little I know. Also,<br />I proven myself my ignorance on the x86 by the ROL wrong assumptions.. I've<br />really to clean my mind a bit about the 68000 and start doing some serious<br />x86 assembly instead.. like learning flags after all opcodes, etc.. lazyness<br />sucks. :)<br /><br /><br />ISHEX? (lowercase and uppercase supported)<br />;input: AL = character to test<br /><pre><code><br />                LEA     ECX,&#91;EAX-'0'&#93;<br />                MOV     EBX,007E03FFh                   ; MASK1<br />                MOV     EAX,007E0000h                   ; MASK2<br />                CMP     CL,32<br />                CMOVC   EAX,EBX<br />                BT      EAX,ECX<br />                JNC     .not_a_hex_number<br /></code></pre><br /><br />Finally, to know if a character is numeric, we can use the other technique<br />I exposed:<br /><br />ISNUMERIC?<br />;input: CL = character to test<br /><pre><code><br />                LEA     EAX,&#91;ECX-'0'&#93;<br />                CMP     AL,10<br />                JNC     .not_a_number<br /></code></pre><br /><br />Really gotta go now.. have a nice day.<br /><br />---<br /><br />PS: the above ISHEX? routine was just an applicative example.. if you specifically look for a ISHEX? routine there are better solutions:<br /><pre><code><br />;ISHEX? &#40;both uppercase and lowercase are supported&#41;<br />                                CMP             AL,'g'                  ; AL = char<br />                                JNC             .not_a_hex_digit<br />                                CMP             AL,'0'<br />                                JC              .not_a_hex_digit<br />                                LEA             EAX,&#91;EAX-'G'&#93;<br />                                CMP             AL,'a'-'G'<br />                                JC              .not_a_hex_digit<br />                                LEA             EAX,&#91;EAX-&#40;'9'+1-'G'&#41;&#93;<br />                                CMP             AL,'A'-'9'-1<br />                                JC              .not_a_hex_digit<br /></code></pre><br />and:<br /><pre><code><br />;ISALPHANUMERIC? &#40;both uppercase and lowercase are supported&#41;<br />                                CMP             AL,'z'+1                ; AL = char<br />                                JNC             .not_alphanumeric<br />                                CMP             AL,'0'<br />                                JC              .not_alphanumeric<br />                                LEA             EAX,&#91;EAX-'Z'-1&#93;<br />                                CMP             AL,'a'-'Z'-1<br />                                JC              .not_alphanumeric<br />                                LEA             EAX,&#91;EAX-'9'+'Z'&#93;<br />                                CMP             AL,'A'-'9'-1<br />                                JC              .not_alphanumeric<br /></code></pre><br />others:<br /><pre><code><br />;TOUPPER &#40; &gt;= P6&#41;<br />LEA             EBX,&#91;EAX-'a'&#93;<br />LEA             ECX,&#91;EAX-32&#93;<br />CMP             EBX,BYTE 'z'+1-'a'<br />CMOVC           EAX,ECX<br /><br />;TOUPPER &#40; &lt;= P5&#41;<br />LEA             EAX,&#91;EAX-'a'&#93;<br />CMP             EAX,BYTE 'z'+1-'a'<br />SBB             EBX,EBX<br />AND             EBX,BYTE -32<br />LEA             EAX,&#91;EAX+EBX+'a'&#93;<br /></code></pre></div>
    <div class="meta">Posted on 2002-07-20 05:09:18 by Maverick</div>
   </div>
   <div class="post" id="post-48972">
    <div class="subject"><a href="#post-48972">Algorithms::Is val&gt;lowval and val&lt;highval optomization</a></div>
    <div class="body"><div class="quote">a) the LEA,CMP trick simply sets the carry flag if we're inside the bounds, and clears it if we're outside the bounds.<br /></div><br /><br />Shoot, I looked at using lea, but the opcode halp in MASM32 sadi lea didn't affect flags.  Now I'll have to try this.<br /><br />Maverick, thanks for the very in-depth post.  It reeks of FAQ  :grin:</div>
    <div class="meta">Posted on 2002-07-20 08:36:33 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-49019">
    <div class="subject"><a href="#post-49019">Algorithms::Is val&gt;lowval and val&lt;highval optomization</a></div>
    <div class="body">In fact LEA doesn't affect flags, but the CMP that follows it, does. ;)<br /><br />You're wellcome about the other thing. :)</div>
    <div class="meta">Posted on 2002-07-20 13:10:57 by Maverick</div>
   </div>
  </div>
 </body>
</html>