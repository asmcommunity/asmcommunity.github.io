<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Better static table searches... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=14107" />
    <link rel="next" href="../?id=14107&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=14107">Better static table searches...</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=14107&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=14107&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="14107" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=14107&amp;page=2">&gt;</a><a href="../?id=14107&amp;page=2">&raquo;</a></form>   <div class="post" id="post-109033">
    <div class="subject"><a href="#post-109033">Better static table searches...</a></div>
    <div class="body">Often a value needs to be tested against a set of values and our high level brain takes a direct approach:<br /><pre><code>	cmp	al, 1<br />	je	Found<br />	cmp	al, 2<br />	je	Found<br />	cmp	al, 3<br />	je	Found<br />...<br />	cmp	al, N<br />	je	Found<br /></code></pre>There are many good things about this method: data cache is not effected, value not in set take a short execution path.  No so good: lot of typing (use a macro), the penalty for values being a part of the set increases linearly with the size of the set.<br /><br />Another method that is less code and quite direct:<br /><pre><code>	mov	ecx, SIZE OF TABLE - 1<br />_0&#58;	cmp	al, &#91;TABLE + ecx&#93;<br />	je	Found<br />	dec	ecx<br />	jns	_0<br /><br />Not_Found&#58;<br /><br />	; number is NOT part of set<br />	ret<br /><br />Found&#58;<br /><br />	; number is a member of set<br />	ret<br /></code></pre>Is this method better?  Only in requard to taking less typing, and not impacting the instruction cache (no need to worry about this even - not a problem).  There are many additionally bad things about this method:  even a longer execution path for all values, data cache is impacted.<br /><br /><br />And now we come to another method:<pre><code><br />	mov	ecx, 1<br />	mov	edx, TABLE_DEPTH<br /><br />_0&#58;	cmp	&#91;TABLE + ecx&#93;, al<br />	je	Found<br />	adc	ecx, ecx<br />	dec	edx<br />	jne	_0<br /><br />Not_Found&#58;<br /><br />	; number is NOT part of set<br />	ret<br /><br />Found&#58;<br /><br />	; number is a member of set<br />	ret<br /><br /><br />; The table has to be sorted into a balanced tree and<br />; first entry is not used, but makes the table a power<br />; of two in size.<br /><br />TABLE_DEPTH EQU 5<br /><br />TABLE	BYTE                     0<br />	BYTE                    16<br />	BYTE         8,                      24<br />	BYTE    4,        12,          20,         28<br />	BYTE  2,  6,   10,   14,    18,   22,    26,  32<br />	BYTE 1,3,5,7, 9,11,13,15, 17,19,21,23, 25,27,31,33<br /></code></pre>What could be better about this method?  Well, it does look more complex and it is - take some time to understand how it works in your favorite debugger.  Note how both execution paths are optimized - both values in the set and not in the set take less instruction to determine than in the first method above.  Also, all but the final branch is correctly predicted.<br /><br />It seems like a natual question to ask: Why not do the binary tree search in code only?  This has been explored here before, but it basically boils down to branch mis-prediction being a huge penalty on newer processors.</div>
    <div class="meta">Posted on 2003-07-02 11:00:34 by bitRAKE</div>
   </div>
   <div class="post" id="post-109048">
    <div class="subject"><a href="#post-109048">Better static table searches...</a></div>
    <div class="body">- needs a sorted array<br />- not built for signed numbers but feel free to change some jcc flags<br />- &quot;divide and conquer&quot; style<br />- I tested this before and it seems to have no problems. But as usual, I write buggy code, so there... :grin:<br />- it simply starts at the center of the starting point and ending point, in which these 2 points will vary as the code executes<pre><code>&#91;size=9&#93;.686<br />.MMX<br />.XMM<br />.MODEL FLAT, STDCALL<br />OPTION SCOPED<br />OPTION CASEMAP&#58;NONE<br /><br />INCLUDE C&#58;\masm32\include\windows.inc<br />INCLUDE C&#58;\masm32\include\kernel32.inc<br />INCLUDELIB C&#58;\masm32\lib\kernel32.lib<br />INCLUDE C&#58;\masm32\include\user32.inc<br />INCLUDELIB C&#58;\masm32\lib\user32.lib<br /><br />.DATA<br /><br />                ;  0  1  2  3  4  5  6   7   8  9<br /><br />    myarray     DD 1, 2, 4, 5, 6, 7, 9, 11, 15, 18<br /><br />.CODE<br /><br />start&#58;<br /><br />    ;let EAX be the register to hold the value we are looking for<br /><br />    mov     eax, 3<br />    xor     ebx, ebx<br />    mov     ecx, LENGTHOF myarray - 1<br />    mov     esi, OFFSET myarray<br /><br />    cmp     &#91;esi+ecx*4&#93;, eax<br />    je      __found<br /><br />    __lp&#58;<br /><br />        mov     edx, ecx<br />        shr     ecx, 1<br />        cmp     &#91;esi+ecx*4&#93;, eax<br />        ja      __elp<br />        je      __found<br />        jmp     __oilp<br /><br />    __elp&#58;<br /><br />        test    ecx, ecx<br />        jnz     __lp<br />        jz      __not_found<br /><br />    __oilp&#58;<br /><br />        push    edx<br />        inc     ebx<br /><br />    __ilp&#58;<br /><br />        sub     edx, ecx<br />        shr     edx, 1<br />        test    edx, edx<br />        jz      __not_found<br />        add     edx, ecx<br />        cmp     &#91;esi+edx*4&#93;, eax<br />        ja      __ilp<br />        je      __found<br /><br />            mov     ecx, edx<br />            pop     edx<br />            dec     ebx<br />            jmp     __oilp<br /><br />    __found&#58;<br /><br />        invoke  MessageBox, 0, 0, 0, 0<br />        jmp     __exit<br /><br />    __not_found&#58;<br /><br />                 ;  0  1  2  3  4  5  6   7   8  9<br /><br />    ;myarray     DD 1, 2, 4, 5, 6, 7, 9, 11, 15, 18<br /><br />    __exit&#58;<br /><br />    shl     ebx, 2<br />    add     esp, ebx<br /><br />    invoke  ExitProcess, 0<br />    ret<br /><br />END start&#91;/size&#93;</code></pre>I don't know how this will fair on larger arrays(~1 million) compared to other methods... I'm pretty sure this is slow on smaller arrays. :)<br /><br />It seems fast theoritically, but I don't know the actual performance on real world tests.</div>
    <div class="meta">Posted on 2003-07-02 13:24:57 by arkane</div>
   </div>
   <div class="post" id="post-109050">
    <div class="subject"><a href="#post-109050">Better static table searches...</a></div>
    <div class="body"><strong>arkane</strong>, seems like overkill - I'm doing the same thing with only a couple instructions and those bad branches will kill the speed. :)</div>
    <div class="meta">Posted on 2003-07-02 13:44:44 by bitRAKE</div>
   </div>
   <div class="post" id="post-109051">
    <div class="subject"><a href="#post-109051">Better static table searches...</a></div>
    <div class="body">yep, that's what I was thinking about... :grin: :grin:</div>
    <div class="meta">Posted on 2003-07-02 13:47:46 by arkane</div>
   </div>
   <div class="post" id="post-109054">
    <div class="subject"><a href="#post-109054">Better static table searches...</a></div>
    <div class="body">I'll create an example once I'm back online.</div>
    <div class="meta">Posted on 2003-07-02 13:59:06 by bitRAKE</div>
   </div>
   <div class="post" id="post-109062">
    <div class="subject"><a href="#post-109062">Better static table searches...</a></div>
    <div class="body">your favorite style: recursion :grin: :grin:<pre><code>&#91;size=9&#93;ssrch&#58;<br />    pop     eax<br />    pop     ecx<br />    pop     edx<br />    push    eax<br />__srch&#58;<br />    mov     eax, &#91;esp+4&#93;<br />    cmp     eax, &#91;esp+8&#93;<br />    ja      __ret0<br />    add     eax, &#91;esp+8&#93;<br />    shr     eax, 1<br />    cmp     edx, &#91;ecx+eax*4&#93;<br />    je      __ret1<br />    ja      __greater<br />        dec     eax<br />        js      __ret0<br />        push    eax<br />        push    &#91;esp+8&#93;<br />        call    __srch<br />        jmp     __ret<br />    __greater&#58;<br />        inc     eax<br />        push    &#91;esp+8&#93;<br />        push    eax<br />        call    __srch<br />        jmp     __ret<br />    __ret0&#58;<br />    xor     eax, eax<br />    retn    8<br />    __ret1&#58;<br />    xor     eax, eax<br />    inc     eax<br />    __ret&#58;<br />    retn    8&#91;/size&#93;</code></pre>Usage:<pre><code>&#91;size=9&#93;    push    LENGTHOF array - 1  ;# of items in the array - 1<br />    push    0                   ;always 0<br />    push    10                  ;number to find<br />    push    OFFSET array        ;pointer to the array<br />    call    ssrch<br /><br />    .IF&#40;eax != 0&#41;<br />        invoke  MessageBox, 0, 0, 0, 0<br />    .ENDIF&#91;/size&#93;</code></pre></div>
    <div class="meta">Posted on 2003-07-02 14:39:45 by arkane</div>
   </div>
   <div class="post" id="post-109065">
    <div class="subject"><a href="#post-109065">Better static table searches...</a></div>
    <div class="body"><strong>bitRAKE,</strong><br />adc is nice idea but <strong>inc ecx</strong> is an error<br />You can substitude TABLE_DEPTH<br />with one last row with zeroes too...<br />and test for zero to end...just an idea<pre><code> <br />_0&#58;<br />	mov	eax, edx<br />	sub	eax, &#91;TABLE + ecx*4&#93;<br />	adc	ecx, ecx     <br />	xor	eax, edx ; exit if  eax=0 or eax=edx<br />	cmp	eax, edx<br />	jne	_0<br />...<br />...<br />dd 1,3,5,7, 9,11,13,15, 17,19,21,23, 25,27,31,33<br />dd  4*4*2 Dup&#40;0&#41;</code></pre><br /><br />and  rewrite the tree too!!! <br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-07-02 15:23:23 by lingo12</div>
   </div>
   <div class="post" id="post-109072">
    <div class="subject"><a href="#post-109072">Better static table searches...</a></div>
    <div class="body"><strong>lingo12</strong>, can you explain how that loop stops when EDX is not a value in the table?  I think that two conditional jumps in the loop is the minimum.  Yeah, I forgot to remove the INC - I was using another version in my code. :)<br /><br />Mainly, I wanted to show the technique:<pre><code>TABLE	BYTE                         0<br /><br />	BYTE                         1<br /><br />	BYTE            2,                        3<br /><br /><br />	BYTE      4,           5,           6,          7<br /><br /><br />	BYTE   8,    9,    10,   11,    12,   13,    14,   15<br /><br />	BYTE 16,17,18,19, 20,21,22,23, 24,25,26,27, 28,29,30,31</code></pre></div>
    <div class="meta">Posted on 2003-07-02 16:08:53 by bitRAKE</div>
   </div>
   <div class="post" id="post-109081">
    <div class="subject"><a href="#post-109081">Better static table searches...</a></div>
    <div class="body"><strong>&quot;lingo12, can you explain how that loop stops when EDX is not a value in the table?&quot;</strong><br /><br />Yes<br /><br /><strong>&quot;I think that two conditional jumps in the loop is the minimum.&quot;</strong><br /><br />No</div>
    <div class="meta">Posted on 2003-07-02 17:15:34 by lingo12</div>
   </div>
   <div class="post" id="post-109085">
    <div class="subject"><a href="#post-109085">Better static table searches...</a></div>
    <div class="body"><strong>lingo12</strong>, :grin: there is no questioning your talent.  My loop is still better, imho.<br /><br />Another option would be:<pre><code>_0&#58;	cmp	al, &#91;TABLE + ecx&#93;<br />	je	Found<br />	adc	ecx, ecx<br />	test	ecx, SIZE OF TABLE<br />	je	_0</code></pre></div>
    <div class="meta">Posted on 2003-07-02 17:29:34 by bitRAKE</div>
   </div>
   <div class="post" id="post-109088">
    <div class="subject"><a href="#post-109088">Better static table searches...</a></div>
    <div class="body"><strong>&quot;lingo12, there is no questioning your talent.&quot;</strong><br /><br />Thanks<br /><br />&quot;My loop is still better,<strong>imho.</strong>&quot;<br /><br />Yes, because it is your<br /><br /><strong>&quot;Another option would be:...&quot;</strong><br /><br />Two conditional jumps again</div>
    <div class="meta">Posted on 2003-07-02 17:45:02 by lingo12</div>
   </div>
   <div class="post" id="post-109089">
    <div class="subject"><a href="#post-109089">Better static table searches...</a></div>
    <div class="body"><div class="quote"><br />Two conditional jumps again </div>The jump in the middle is only taken once and is basically ignored (CPU continues to execute instructions) by modern processors (ie always predicted in the case of number not in set, and taken only once for number in set).  Do you find this to be a problem in your tests?</div>
    <div class="meta">Posted on 2003-07-02 17:56:34 by bitRAKE</div>
   </div>
   <div class="post" id="post-109117">
    <div class="subject"><a href="#post-109117">Better static table searches...</a></div>
    <div class="body"><pre><code>&#91;size=9&#93;srch&#58;<br /><br />    mov         ecx, &#91;esp+4&#93;<br />    mov         eax, &#91;esp+8&#93;<br />    mov         edx, &#91;esp+12&#93;<br /><br />    movd        MM0, edx<br />    punpcklbw   MM0, MM0<br />    punpcklbw   MM0, MM0<br />    punpcklbw   MM0, MM0<br /><br />    ;start a loop here<br /><br />    movq        MM1, &#91;ecx&#93;<br />    pcmpeqb     MM1, MM0<br />    packsswb    MM1, MM1<br />    movd        eax, MM1<br />    test        eax, eax<br />    jnz         __found<br /><br />    ;loop around here<br /><br />    ;...<br />    ;...<br />    ;...<br />    <br />    __not_found&#58;<br />    <br />        xor     eax, eax<br />        <br />    __found&#58;<br /><br />        retn        12<br /><br />...<br />...<br />...<br /><br />    push    2                   ;byte size vaue to search<br />    push    LENGTHOF array - 1  ;...<br />    push    OFFSET array        ;...<br />    call    srch<br /><br />    .IF&#40;eax != 0&#41;<br />        invoke  MessageBox, 0, 0, 0, 0<br />    .ENDIF&#91;/size&#93;</code></pre>compares 8 byte values. :)</div>
    <div class="meta">Posted on 2003-07-02 23:05:52 by arkane</div>
   </div>
   <div class="post" id="post-109119">
    <div class="subject"><a href="#post-109119">Better static table searches...</a></div>
    <div class="body"><strong>&quot;The jump in the middle is only taken once....&quot;</strong><br /><br />Two is more than one<br />Will be better to follow <strong>bitRAKE</strong>'s advice:<br /><br />&quot;Conditional moves are not much better than conditional jump instructions -<strong> better to do without them all together.</strong>&quot; by bitRAKE<br /><br /><a target="_blank" href="http://www.asmcommunity.net/board/showthread.php?threadid=9989&amp;highlight=not+conditional">http://www.asmcommunity.net/board/showthread.php?threadid=9989&amp;highlight=not+conditional</a><br /><br />Just kidding...I like your ideas<br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-07-03 00:16:27 by lingo12</div>
   </div>
   <div class="post" id="post-109122">
    <div class="subject"><a href="#post-109122">Better static table searches...</a></div>
    <div class="body">I think something like this is solely dependant on the situation.<br /><br />You need to take into account the likelihood that certain values will be tested against the table.  Take for example a window procedure.  Odds are that many, if not most, of the usual window messages you receive aren't going to be of any use to you.  It seems silly then to have to scan a whole table every time you get a message you're not going to handle.  I would suggest in that case, your priority is to first identify (at least some of) the values that are not in the table, so execution can quickly pass through.<br /><br />Also, as is the case with the example table here, notice that all numbers are in the range 1-31.  For numerically consecutive values it would seem both faster and easier to do a simple range test.  Of course the tables aren't always going to look like that, but it might be worth considering how many adjacent values are in your table, as opposed to scattered values.  Or really any sort of pattern you can find will work to your advantage.<br /><br />But as a general purpose algorithm this would seem a lot faster than the usual way.  I like the use of the tree.  Good job.  :alright:</div>
    <div class="meta">Posted on 2003-07-03 00:47:33 by iblis</div>
   </div>
   <div class="post" id="post-109144">
    <div class="subject"><a href="#post-109144">Better static table searches...</a></div>
    <div class="body">There are two versions of the TABLE posted above.  The first is numbered in accending order of table item value - think of the number in terms of being the index into a sorted array of the table values.  The second is numbers by TABLE index value - the byte number is used to better understand what the algorithm is doing.</div>
    <div class="meta">Posted on 2003-07-03 08:33:52 by bitRAKE</div>
   </div>
   <div class="post" id="post-109172">
    <div class="subject"><a href="#post-109172">Better static table searches...</a></div>
    <div class="body">oh and before I forgot, that MMX versions doesn't need a sorted array. :)</div>
    <div class="meta">Posted on 2003-07-03 13:13:58 by arkane</div>
   </div>
   <div class="post" id="post-109657">
    <div class="subject"><a href="#post-109657">Better static table searches...</a></div>
    <div class="body"><div class="quote"><br />&quot;The jump in the middle is only taken once....&quot;</strong><br /><br />Two is more than one<br />Will be better to follow <strong>bitRAKE</strong>'s advice:<br /><br />&quot;Conditional moves are not much better than conditional jump instructions -<strong> better to do without them all together.</strong>&quot; by bitRAKE<br /><br /><a target="_blank" href="http://www.asmcommunity.net/board/showthread.php?threadid=9989&amp;highlight=not+conditional">http://www.asmcommunity.net/board/showthread.php?threadid=9989&amp;highlight=not+conditional</a><br /><br />Just kidding...I like your ideas<br /><br />Regards,<br />Lingo</div>I guess you missed the sweet unroll potential:<br /><pre><code>	cmp	&#91;TABLE + 1&#93;, al	; ECX always one.<br />	rcl	ecx, 1	; doesn't effect Z flag<br />	je	Found<br />	cmp	&#91;TABLE + ecx&#93;, al<br />	rcl	ecx, 1<br />	je	Found<br />	cmp	&#91;TABLE + ecx&#93;, al<br />	rcl	ecx, 1<br />	je	Found<br />	cmp	&#91;TABLE + ecx&#93;, al<br />	rcl	ecx, 1<br />	je	Found<br />	cmp	&#91;TABLE + ecx&#93;, al<br />	je	Found<br /></code></pre>Like I said, it is better to do without. :grin:<br /><br />Can someone post something that is faster on random data?  I'm not concidering this for WndProc handling - it is for the general case.  It works for WORDs or DWORDs just by changing the multiplier on memory indexing.<br /><br />MMX isn't effective except on small sets of values [ O(n/{8,4,2}) verses O(log2 n) ].</div>
    <div class="meta">Posted on 2003-07-08 08:43:53 by bitRAKE</div>
   </div>
   <div class="post" id="post-109689">
    <div class="subject"><a href="#post-109689">Better static table searches...</a></div>
    <div class="body">bitRake, <br />I've read first post in the thread and<br />would like to extent one of methods you placed<br />your code contra.<br />I mean this method you described:<br />-------------------------------------------------<br />Another method that is less code and quite direct:<br /><br /><pre><code><br /><br />movecx, SIZE OF TABLE - 1<br />_0&#58; cmp al, &#91;TABLE + ecx&#93;<br />  jeFound<br />  dec ecx<br />  jns _0<br />Not_Found&#58;<br />; number is NOT part of set<br />  ret<br />Found&#58;<br />  ; number is a member of set<br />ret<br /></code></pre><br /><br />Is this method better? <br /><br />-------- end of your desciption -----------<br /><br />A year or more ago I posted algo logic called<br />&quot;False point algo&quot;<br /><br />Scaning is used usually for to things,<br />1. to find a place of scanned value<br />2. to find if gotten value belongs to some subset. (as in your post)<br />Or for both.<br /><br />Yet we know - if we knew for sure that<br />value is in table of subset values<br /> - we could make a scaning loop faster.<br />'Cause we don't need to check if current address<br />is out of table addresses space.<br /><br />For example many different asciiz zero point scanners<br />assumed that string has zero for sure - end this<br />allows to scan for it much faster then if assume<br />otherwize (meaning - considering possibility that there<br />is no zero).<br /><br />Actually it can be done even if we don't for sure<br />if there is that value.<br />All we need - to include after end of the table<br />a place for data that serve as &quot;false pont&quot;<br />Then we change the algo this way<br />1. Before start of scaning loop we place<br />   recieved value into the &quot;false point&quot; var at<br />   the end of the table.<br />2. Then we arrange scaning loop, but now without<br />   code that checks if there end of table, 'cause<br />   we know now for sure - if there is no value in the<br />   table - our scanner yet will find it - 'cause we<br />   placed it ourself in memory next to table.<br />3. So the question &quot;belongs or not recieved value to<br />   the subset&quot; for us is now &quot;is address of found value<br />   belongs to false point&quot;.<br />If it is - then recieved value does not belong to<br />the subset in table. Otherwise (address is less then<br />address of false point) it belongs to it.<br />Scanner loop and data type might be different.<br />I just to illustrate my point changing your code:<br /><br /><pre><code><br />.data<br />TABLE db .,.,.,., some values subset<br />false point db ?<br />.code<br />mov ecx, offset of TABLE<br />mov false point,al<br />;very short loop&#58;<br />_0&#58; cmp al, &#91;ecx&#93;<br />    lea ecx,&#91;ecx&#93;&#91;1&#93;<br />    jne _0<br />;alternative ecx,offs table-1 ;inc ecx;cmp al,&#91;ecx&#93;;jne _0<br />    cmp ecx,offset falsepoint+1<br />    jne notfound<br />;found&#58;<br />.......<br />;not found <br /></code></pre><br /><br />It can be used for any type and scanner loop can be changed.<br />But it now don't need check for the end of table in loop itself<br />anyway.<br /><br />It's not about your &quot;contra&quot; algo.<br />Just addition to you revision of possible algos.</div>
    <div class="meta">Posted on 2003-07-08 16:04:59 by The Svin</div>
   </div>
   <div class="post" id="post-109701">
    <div class="subject"><a href="#post-109701">Better static table searches...</a></div>
    <div class="body"><strong>Svin</strong>, that method is nice for small or dynamic tables, but is still O(n).  Try it with a table of primes less than 256 verses the method I post above.<br /><pre><code><br />    2     3     5     7    11    13    17    19    23    29<br />   31    37    41    43    47    53    59    61    67    71<br />   73    79    83    89    97   101   103   107   109   113<br />  127   131   137   139   149   151   157   163   167   173<br />  179   181   191   193   197   199   211   223   227   229<br />  233   239   241   251</code></pre>...54 prime numbers.  My method takes less than &lt;18 instuctions to determine if a byte is prime, and only one mis-predicted branch.  It is hard to say that about any other method.</div>
    <div class="meta">Posted on 2003-07-08 18:03:05 by bitRAKE</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=14107&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=14107&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="14107" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=14107&amp;page=2">&gt;</a><a href="../?id=14107&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>