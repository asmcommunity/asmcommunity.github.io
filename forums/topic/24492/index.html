<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>fill large file efficiently and change file name... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=24492" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=24492">fill large file efficiently and change file name...</a></p>
   <div class="post" id="post-178815">
    <div class="subject"><a href="#post-178815">fill large file efficiently and change file name...</a></div>
    <div class="body">I write a test program which function is search all the files in the chosen directory and sub-directory and to fill the files with zero, it works well but it&#39;s inefficient when fill the large files(100M or large), I suppose the search snippet(see below) is OK,so...how can I set the NumberOfBytesToWrite in WriteFile to make it efficiently or how can I call different WriteFile(use different parameters) according to the file size?<br /><pre><code>szSize&nbsp; &nbsp; equ&nbsp; 1048576&nbsp; &nbsp;  ; It compiles error but 1024 is OK<br />szZero&nbsp; &nbsp; BYTE&nbsp; &nbsp; szSize&nbsp; dup&nbsp; (?)<br />invoke&nbsp; WriteFile,hFile,addr szZero,szSize,addr BytesWritten,0</code></pre><br /><br /><pre><code>invoke	FindFirstFile,addr @szSearch,addr @stFindFile<br />.if	eax !=	INVALID_HANDLE_VALUE<br />mov	@hFindFile,eax<br />.repeat<br />.if	@stFindFile.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY<br />.if	@stFindFile.cFileName != &#39;.&#39;<br />invoke	_FindFile,addr @szFindFile<br />.endif<br />.else<br />invoke	_ProcessFile,addr @szFindFile<br />.endif<br />invoke	FindNextFile,@hFindFile,addr @stFindFile<br />.until	(eax ==	FALSE) || (dwOption &amp; F_STOP)<br />invoke	FindClose,@hFindFile<br />.endif</code></pre><br /><br />And some other questions, how can I change the file name and delete it at last after I fill the file with zero?<br /><br />THX.</div>
    <div class="meta">Posted on 2006-03-31 02:54:45 by Eric4ever</div>
   </div>
   <div class="post" id="post-178824">
    <div class="subject"><a href="#post-178824">Re: fill large file efficiently and change file name...</a></div>
    <div class="body">You should do your writing in &quot;chunks&quot; - you&#39;ll have to experiment to find the optimal size, personally I&#39;d probably use a 64kb block allocated with VirtualAlloc; seems a decent trade-off between not using too much memory and not making too many WriteFile calls. Do experiment with values of your own, though. You&#39;ll need a chunk/block writing loop instead of just a single WriteFile call.<br /><br />Further enhancements would be to open the file in UNBUFFERED mode so you don&#39;t go through the cache subsystem (a bit faster + doesn&#39;t waste memory for cache) (you might want to use somewhat larger blocks in that case). Also, for file wiping, filling with 0 is a bad idea because some filesystems can optimize all-zero writes away, and thus won&#39;t actually overwrite your data on disk.<br /></div>
    <div class="meta">Posted on 2006-03-31 06:48:10 by f0dder</div>
   </div>
   <div class="post" id="post-178840">
    <div class="subject"><a href="#post-178840">Re: fill large file efficiently and change file name...</a></div>
    <div class="body">You might also consider using CreateFileMapping() and MapViewOfFile()</div>
    <div class="meta">Posted on 2006-03-31 12:49:53 by XCHG</div>
   </div>
   <div class="post" id="post-178841">
    <div class="subject"><a href="#post-178841">Re: fill large file efficiently and change file name...</a></div>
    <div class="body"><div class="quote"><br />You might also consider using CreateFileMapping() and MapViewOfFile()<br /></div><br /><br />It&#39;s a thing to consider and test for performance - but you still need to process in &quot;chunks&quot; if you want to support large files, since even on NT there&#39;s a limit to how large files you can map... unless you only want to support 64bit editions of windows :)<br /><br />Also, while filemapping gets the job done in the same time as WriteFile (because you&#39;re I/O bound), filemapping puts a higher strain on your CPU because you effectively get a pagefault for each 4kb of your write. This can be noticable even on relatively decent hardware. Furthermore, filemapping doesn&#39;t respect flags like NO_BUFFERING, which means you *will* use filesystem cache, which isn&#39;t really what you want for a write-through operation like this.<br /></div>
    <div class="meta">Posted on 2006-03-31 12:54:33 by f0dder</div>
   </div>
   <div class="post" id="post-178984">
    <div class="subject"><a href="#post-178984">Re: fill large file efficiently and change file name...</a></div>
    <div class="body">I use the process like this:<br /><br /><pre><code>Fill Proc<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  edi,Fillnum<br />label0:<br />&nbsp; &nbsp; &nbsp; &nbsp; CreateFile<br />&nbsp; &nbsp; &nbsp; &nbsp; GetFileSize&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax &gt;= 400H		; largefile<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  esi,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; shr&nbsp; &nbsp;  eax,SB		;SB == 20<br />label1:<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax != 0<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; eax<br />&nbsp; &nbsp; &nbsp; &nbsp; WriteFile&nbsp; &nbsp; &nbsp;  ; 1024*1024<br />&nbsp; &nbsp; &nbsp; &nbsp; pop&nbsp; &nbsp;  eax<br />&nbsp; &nbsp; &nbsp; &nbsp; dec&nbsp; &nbsp;  eax<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz&nbsp; &nbsp;  label1<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; and&nbsp; &nbsp;  esi,OB		; OB == 1024*1024-1<br />&nbsp; &nbsp; &nbsp; &nbsp; WriteFile&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; CloseHandle&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br /><br />&nbsp; &nbsp; &nbsp; &nbsp; dec&nbsp; &nbsp;  edi<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz&nbsp; &nbsp;  label0<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .else			; Smallfile<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  esi,eax							<br />&nbsp; &nbsp; &nbsp; &nbsp; shr&nbsp; &nbsp;  eax,SS		; SS == 10											<br />label2:<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax != 0<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; eax<br />&nbsp; &nbsp; &nbsp; &nbsp; WriteFile&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;&nbsp; 1024 <br />&nbsp; &nbsp; &nbsp; &nbsp; pop&nbsp; &nbsp;  eax<br />&nbsp; &nbsp; &nbsp; &nbsp; dec&nbsp; &nbsp;  eax<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz&nbsp; &nbsp;  label2<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; and&nbsp; &nbsp;  esi,OS			; OS == 1023<br />&nbsp; &nbsp; &nbsp; &nbsp; WriteFile<br />&nbsp; &nbsp; &nbsp; &nbsp; CloseHandle<br />&nbsp; &nbsp; &nbsp; &nbsp; dec&nbsp; &nbsp;  edi<br />&nbsp; &nbsp; &nbsp; &nbsp; jnz&nbsp; &nbsp;  label0<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif		<br />&nbsp; &nbsp; &nbsp; &nbsp; pop&nbsp; &nbsp;  esi<br />&nbsp; &nbsp; &nbsp; &nbsp; pop&nbsp; &nbsp;  edi<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br /><br />Fill ENDP</code></pre><br /><br />The WriteFile size == 1024 is OK, but for the large file the WriteFile size ==1024*1024 error?</div>
    <div class="meta">Posted on 2006-04-02 21:07:42 by Eric4ever</div>
   </div>
   <div class="post" id="post-179027">
    <div class="subject"><a href="#post-179027">Re: fill large file efficiently and change file name...</a></div>
    <div class="body">Try this on for size...<br /><pre><code><br />PUBLIC WipeFile<br />WipeFile PROC STDCALL uses ebx, fn:DWORD<br />	LOCAL _fsize$:DWORD, _bwrite$:DWORD, _buf$:DWORD, _file$:DWORD<br />	WIPESIZE = (1024*256)<br /><br />	mov		[_file$], 0<br />	mov		[_buf$], 0<br />	xor		ebx, ebx						; ebx is used for success/failure<br />	<br />	; allocate buffer memory<br />	invoke	VirtualAlloc, 0, WIPESIZE, MEM_COMMIT, PAGE_READWRITE<br />	test	eax, eax<br />	jz		@@cleanup<br />	mov		DWORD PTR [_buf$], eax<br /><br />	; open file<br />	invoke	CreateFile, , GENERIC_WRITE, 0, 0, OPEN_EXISTING,\<br />		FILE_FLAG_WRITE_THROUGH or FILE_FLAG_NO_BUFFERING, 0<br />	cmp		eax, INVALID_HANDLE_VALUE<br />	je		@@cleanup<br />	mov		DWORD PTR [_file$], eax<br /><br />	; get filesize and round to WIPESIZE boundary<br />	invoke	GetFileSize, [_file$], 0<br />	add		eax, WIPESIZE-1<br />	and		eax, NOT (WIPESIZE-1)<br />	mov		[_fsize$], eax<br /><br />	; fill buffer with junk. Don&#39;t zero because certain filesystems might do<br />	; zero-optimizations. The best would probably be to fill with Really Random Data (TM).<br />	invoke	RtlFillMemory, [_buf$], eax, &#39;@&#39;<br /><br />	; do the actual file wiping<br />@@FillLoop:<br />	invoke	WriteFile, [_file$], [_buf$], WIPESIZE, addr [_bwrite$], 0<br /><br />	test	eax, eax<br />	jz		@@cleanup<br />	cmp		[_bwrite$], WIPESIZE<br />	jne		@@cleanup<br />	<br />	sub		DWORD PTR [_fsize$], WIPESIZE<br />	jnz		@@FillLoop<br /><br />	; flush filebuffers. Don&#39;t have much afaik, but included for completeness<br />	invoke	FlushFileBuffers, [_file$]<br />	inc		ebx								; indicate success<br /><br />@@cleanup:<br />	; free buffer memory, unless the pointer is 0<br />	mov		eax, [_buf$]<br />	test	eax, eax<br />	jz		@@skipfree<br />	invoke	VirtualFree, eax, 0, MEM_RELEASE<br />@@skipfree:<br /><br />	; close file, unless the handle is 0<br />	mov		eax, [_file$]<br />	test	eax, eax<br />	jz		@@skipclose<br />	invoke	CloseHandle, [_file$]<br />@@skipclose:<br /><br />	mov		eax, ebx						; returnvalue = success/failure indicator<br /><br />	ret<br />WipeFile ENDP<br /></code></pre><br /></div>
    <div class="meta">Posted on 2006-04-03 09:26:50 by f0dder</div>
   </div>
   <div class="post" id="post-179896">
    <div class="subject"><a href="#post-179896">Re: fill large file efficiently and change file name...</a></div>
    <div class="body">I found a way to &quot;fill large files with zero&quot; when I was working on the OpenSlather p2p project some time back. Search this forum.<br />From memory, I would do the following:<br />-DeleteFile<br />-CreateFile with OPEN_ALWAYS<br />-SetFilePointer to the desired filesize, minus one byte (yes, even though this is beyond the end of the file<br />-(SetEndOfFile at the current FilePointer position ?? cant remember if I did..)<br />-Write one zero byte, the filesize will NOT be changed unless we do this<br />-Close file handle<br /><br />This method can create huge files eg 10 gigs , and do it in about a half a second.<br />If we don&#39;t delete/recreate the file first, the extended file data is &quot;undefined&quot; and could contain random junk - but since we remade the file, in my experience, its always totally full of NULL, with the exception of the final byte, that in our case is ALSO NULL.<br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2006-04-20 01:37:57 by Homer</div>
   </div>
   <div class="post" id="post-179906">
    <div class="subject"><a href="#post-179906">Re: fill large file efficiently and change file name...</a></div>
    <div class="body">Won&#39;t zero out the on-disk data though - that&#39;s why it&#39;s fast. And it only works on NTFS, not FAT (or rather, on FAT it&#39;s slow and *does* zero-fill the on-disk data). There&#39;s also no guarantee that the original on-disk data will be overwritten, windows *could* choose to write to some other location (although in practice, it shouldn&#39;t).<br /><br /></div>
    <div class="meta">Posted on 2006-04-20 04:32:07 by f0dder</div>
   </div>
  </div>
 </body>
</html>