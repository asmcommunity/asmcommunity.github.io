<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>First 40 bytes are blanks in array ..???? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20127" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=20127">First 40 bytes are blanks in array ..????</a></p>
   <div class="post" id="post-154186">
    <div class="subject"><a href="#post-154186">First 40 bytes are blanks in array ..????</a></div>
    <div class="body">Hello sorry to bother you again, but i'm experimenting with arrays, and this program behaves strangly, i have a 100 bye array and when i try to print out the data the first 40 bytes are blanks from array[0] to array[39]<br />Don't know what's wrong with the program, maybe you guys and gals could se what's wrong with this little program, here's the code.<br /><br /><pre><code><br />// E TUTORMYSELF program from Zellennium<br />// This program is a way for me to learn how to acces arrays<br />// And do a strange counting on the stack wich i think nobody ever does<br />// but it's a way to learn i think maybe tha bad way but i learn.<br /><br /><br />program arraytest;<br /><br />#include&#40; &quot;stdlib.hhf&quot; &#41;<br />const<br />	dword_index&#58;=10;<br />	byte_index&#58;=100;<br />static<br />// myArr		&#58; dword&#91;index&#93;&#58;=&#91;10,20,30,40,50,60,70,80,90,100&#93;;<br />myArr 		&#58; dword&#91;dword_index&#93;&#58;= 10 dup&#91;0&#93;;<br />// to do<br />myArrBytes	&#58; char&#91;byte_index&#93;&#58;= 100 dup &#91;'W'&#93;;<br />			<br /><br />begin arraytest;<br /><br />	stdout.put&#40; &quot;Hello, Lets do some DWORD ARRAYS counting and accessing&quot;, nl, nl &#41;;<br />	stdout.put&#40; &quot;Press enter to continue&#58; &quot; ,nl,nl &#41;;<br />	mov &#40;@size&#40;myArr&#41;,ecx&#41;;				// get ARRAY size in bytes<br />										// If all goes well @size wil give a total of 40 bytes<br />										// so<br />	shr	&#40;2,ecx&#41;;						// ecx = ecx /4 &#40;40/4&#41; = 10<br />	<br />	<br />	xor	&#40;eax,eax&#41;;						// zero out eax use it as as counter<br />	push	&#40;eax&#41;;						// push it on the stack &#91;esp+4&#93;<br />	push	&#40;esi&#41;;						// save esi we are changing it &#91;esp+8&#93;<br />	<br />	stdout.put&#40;&quot;Data in ecx is &quot;,&#40;type int32 ecx&#41;,nl&#41;;<br />	for &#40; mov &#40; 0,ebx &#41;; ebx &lt; dword_index; inc &#40;ebx&#41;&#41;<br />		do<br />			mov	&#40;myArr&#91;ebx*4&#93;,edx&#41;;<br />			stdout.put&#40;&quot;data in Array &#91; &quot;, &#40;type int32 ebx&#41;,&quot; &#93; =   &quot;, &#40; type int32 edx &#41;,nl&#41;;<br />	// maybe not the best counter ever but just experimenting with the stack<br />			<br />			mov	&#40;&#91;esp+4&#93;,esi&#41;;			// setup eax on stack for counting<br />			inc &#40;esi&#41;;					// increment &#40; eax stack&#41; esi<br />			mov	&#40;esi,&#91;esp+4&#93;&#41;;			// put it back into stack location<br />		endfor;<br />			<br />	pop	&#40;esi&#41;;						// get back saved register<br />	pop	&#40;eax&#41;;						// must contain counted data<br />	<br />	<br />	<br />	stdout.put &#40;&quot;I have repeated myself &quot;, &#40;type uns32 eax &#41;,nl&#41;;<br />	stdout.put &#40;&quot;Press any key to continue with BYES  &quot;,nl,nl&#41;;<br />	stdin.readLn&#40;&#41;;<br />	<br />	//==================================================================<br />	stdout.put&#40; &quot;Hello, Lets do this again but with bytes&quot;, nl, nl &#41;;<br />	stdout.put&#40; &quot;Press enter to continue&#58; &quot; ,nl,nl &#41;;<br />	<br />	mov &#40;@size&#40;myArrBytes&#41;,ecx&#41;;		// get ARRAY size in bytes<br />										// If all goes well @size wil give a total of 40 bytes<br />										// so ecx wil be 100 bytes<br />										// so we don't need shr instruction here<br /><br />	<br />	xor	&#40;eax,eax&#41;;						// zero out eax use it as as counter<br />	push	&#40;eax&#41;;						// push it on the stack &#91;esp+4&#93;<br />	push	&#40;esi&#41;;						// save esi we are changing it &#91;esp+8&#93;<br />	<br />	stdout.put&#40;&quot;Data in ecx is &quot;,&#40;type int32 ecx&#41;,nl&#41;;<br />	for &#40; mov &#40; 0,ebx &#41;; ebx &lt; byte_index; inc &#40;ebx&#41;&#41;<br />		do<br />			mov	&#40;myArr&#91;ebx&#93;, edx&#41;;		// things changes here no&#91;ebx*4&#93; because <br />										// we have bytes now i bye remember<br />										<br />			stdout.put&#40;&quot;data in Array &#91; &quot;, &#40;type int32 ebx&#41;,&quot; &#93; =   &quot;, &#40; type char dl &#41;,nl&#41;;<br />	// maybe not the best counter ever but just experimenting with the stack<br />			<br />			mov	&#40;&#91;esp+4&#93;,esi&#41;;			// setup eax on stack for counting<br />			inc &#40;esi&#41;;					// increment &#40; eax stack&#41; esi<br />			mov	&#40;esi,&#91;esp+4&#93;&#41;;			// put it back into stack location<br />		endfor;<br />			<br />	pop	&#40;esi&#41;;						// get back saved register<br />	pop	&#40;eax&#41;;						// must contain counted data<br />	<br />	<br />	<br />	stdout.put &#40;&quot;I have repeated myself &quot;, &#40;type uns32 eax &#41;,nl&#41;;<br />	stdout.put &#40;&quot;Press any key to exit this program  &quot;,nl,nl&#41;;<br />	stdin.readLn&#40;&#41;;<br />	<br /><br />end arraytest;<br /><br /></code></pre><br /><br />Later.</div>
    <div class="meta">Posted on 2004-12-15 05:27:33 by zellennium</div>
   </div>
   <div class="post" id="post-154218">
    <div class="subject"><a href="#post-154218">First 40 bytes are blanks in array ..????</a></div>
    <div class="body">Hi zellennium,<br />I notice a few things which I'll point out, there may be more problems with the code.<br /><br /><pre><code>   stdout.put&#40; &quot;Hello, Lets do some DWORD ARRAYS counting and accessing&quot;, nl, nl &#41;;<br />   stdout.put&#40; &quot;Press enter to continue&#58; &quot; ,nl,nl &#41;; </code></pre><br /><br />Does this really work?  You need an stdin command somewhere.<br /><br /><br /><pre><code>  mov &#40;@size&#40;myArr&#41;,ecx&#41;;            // get ARRAY size in bytes<br />                              // If all goes well @size wil give a total of 40 bytes<br />                              // so<br />   shr   &#40;2,ecx&#41;;                  // ecx = ecx /4 &#40;40/4&#41; = 10 </code></pre><br /><br />Why do you do this?  You don't even use ecx later.<br /><br /><br /><pre><code>xor   &#40;eax,eax&#41;;                  // zero out eax use it as as counter<br />   push   &#40;eax&#41;;                  // push it on the stack &#91;esp+4&#93;<br />   push   &#40;esi&#41;;                  // save esi we are changing it &#91;esp+8&#93; </code></pre><br /><br />Whenever you push a value onto the stack, the system first decrements the esp register by the size of the pushed operand, then copies the value to the new memory location pointed to by esp.<br /><br />As an example, if you push a dword (eax)<br /><br />push (eax);<br /><br />esp is subtracted by 4 and the value of eax is copied to .<br /><br />Keep in mind that at any one time, the address  contains the very last item you pushed.<br /><br />push (eax);      //  eax = <br />push (esi );      //  eax = ,  esi <br />push (ebx);      // eax  = ,  esi = ,  ebx = <br /><br />and so on.  Keep in mind that eax, esi and ebx in the comments are the original values that were pushed and not the registers themselves.<br /><br />When you pop, the reverse happens:<br /><br />pop (ebx);      // eax = ,  esi = <br /><br />Again, the comments indicate the original values that were in the registers.<br /><br /><br /><pre><code>  for &#40; mov &#40; 0,ebx &#41;; ebx &lt; byte_index; inc &#40;ebx&#41;&#41;<br />      do<br />         mov   &#40;myArr&#91;ebx&#93;, edx&#41;;      // things changes here no&#91;ebx*4&#93; because<br />                              // we have bytes now i bye remember<br />                              <br />         stdout.put&#40;&quot;data in Array &#91; &quot;, &#40;type int32 ebx&#41;,&quot; &#93; =   &quot;, &#40; type char dl &#41;,nl&#41;;<br />   // maybe not the best counter ever but just experimenting with the stack<br />         <br />         mov   &#40;&#91;esp+4&#93;,esi&#41;;         // setup eax on stack for counting<br />         inc &#40;esi&#41;;               // increment &#40; eax stack&#41; esi<br />         mov   &#40;esi,&#91;esp+4&#93;&#41;;         // put it back into stack location<br />      endfor;<br />         <br />   pop   &#40;esi&#41;;                  // get back saved register<br />   pop   &#40;eax&#41;;                  // must contain counted data </code></pre><br /><br />You are displaying the values of myArr which is initialized as 40 bytes of zeros.  I think you want the information in myArrBytes.</div>
    <div class="meta">Posted on 2004-12-15 21:59:13 by Kain</div>
   </div>
   <div class="post" id="post-154223">
    <div class="subject"><a href="#post-154223">First 40 bytes are blanks in array ..????</a></div>
    <div class="body"><div class="quote">Hi zellennium,<br />I notice a few things which I'll point out, there may be more problems with the code.<br /><br /><pre><code>   stdout.put&#40; &quot;Hello, Lets do some DWORD ARRAYS counting and accessing&quot;, nl, nl &#41;;<br />   stdout.put&#40; &quot;Press enter to continue&#58; &quot; ,nl,nl &#41;; </code></pre><br /><br />Does this really work?  You need an stdin command somewhere.<br /><br /></div><br />NO it doesn't<br />Hihi what was i thinking .??? FIXED IT thanks.<br /><br /><br /><div class="quote"><br /><pre><code>  mov &#40;@size&#40;myArr&#41;,ecx&#41;;            // get ARRAY size in bytes<br />                              // If all goes well @size wil give a total of 40 bytes<br />                              // so<br />   shr   &#40;2,ecx&#41;;                  // ecx = ecx /4 &#40;40/4&#41; = 10 </code></pre><br /><br />Why do you do this?  You don't even use ecx later.<br /><br /></div><br /><br />Really i don't know why i wasted bytes like this, sorry i really don't know<br />the only place where i used it was to print out the total bytes i got from @size devided true 4. :? <br /><br /><pre><code><br />	stdout.put&#40; &quot;Hello, Lets do some DWORD ARRAYS counting and accessing&quot;, nl, nl &#41;;<br />	stdout.put&#40; &quot;Press enter to continue&#58; &quot; ,nl,nl &#41;;<br />//FIX&#58;<br />	stdin.readLn&#40;&#41;;						// FIX&#58; This is needed here for above to work DUH<br />	mov &#40;@size&#40;myArr&#41;,ecx&#41;;			<br />										// get ARRAY size in bytes<br />										// If all goes well @size wil give a total of 40 bytes<br />										// so<br />	shr	&#40;2,ecx&#41;;						// ecx = ecx /4 &#40;40/4&#41; = 10<br />	<br />	<br />	xor	&#40;eax,eax&#41;;						// zero out eax use it as as counter<br />	push	&#40;eax&#41;;						// push it on the stack &#91;esp+4&#93;<br />	push	&#40;esi&#41;;						// save esi we are changing it &#91;esp+8&#93;<br />	<br />// USED IT HERE	stdout.put&#40;&quot;Data in ecx is &quot;,&#40;type int32 ecx&#41;,nl&#41;;<br /></code></pre><br /><br /><div class="quote"><br /><br /><pre><code>xor   &#40;eax,eax&#41;;                  // zero out eax use it as as counter<br />   push   &#40;eax&#41;;                  // push it on the stack &#91;esp+4&#93;<br />   push   &#40;esi&#41;;                  // save esi we are changing it &#91;esp+8&#93; </code></pre><br /><br />Whenever you push a value onto the stack, the system first decrements the esp register by the size of the pushed operand, then copies the value to the new memory location pointed to by esp.<br /><br />As an example, if you push a dword (eax)<br /><br />push (eax);<br /><br />esp is subtracted by 4 and the value of eax is copied to .<br /><br />Keep in mind that at any one time, the address  contains the very last item you pushed.<br /><br />push (eax);      //  eax = <br />push (esi );      //  eax = ,  esi <br />push (ebx);      // eax  = ,  esi = ,  ebx = <br /><br />and so on.  Keep in mind that eax, esi and ebx in the comments are the original values that were pushed and not the registers themselves.<br /><br />When you pop, the reverse happens:<br /><br />pop (ebx);      // eax = ,  esi = <br /><br />Again, the comments indicate the original values that were in the registers.<br /></div><br /><br />Hmmm got to hit the books again going to fast maybe.<br /><br /><br /><br /><div class="quote"><br /><br /><pre><code>  for &#40; mov &#40; 0,ebx &#41;; ebx &lt; byte_index; inc &#40;ebx&#41;&#41;<br />      do<br />         mov   &#40;myArr&#91;ebx&#93;, edx&#41;;      // things changes here no&#91;ebx*4&#93; because<br />                              // we have bytes now i bye remember<br />                              <br />         stdout.put&#40;&quot;data in Array &#91; &quot;, &#40;type int32 ebx&#41;,&quot; &#93; =   &quot;, &#40; type char dl &#41;,nl&#41;;<br />   // maybe not the best counter ever but just experimenting with the stack<br />         <br />         mov   &#40;&#91;esp+4&#93;,esi&#41;;         // setup eax on stack for counting<br />         inc &#40;esi&#41;;               // increment &#40; eax stack&#41; esi<br />         mov   &#40;esi,&#91;esp+4&#93;&#41;;         // put it back into stack location<br />      endfor;<br />         <br />   pop   &#40;esi&#41;;                  // get back saved register<br />   pop   &#40;eax&#41;;                  // must contain counted data </code></pre><br /><br />You are displaying the values of myArr which is initialized as 40 bytes of zeros.  I think you want the information in myArrBytes.</div><br /><br />Yep fixed it :lol:</div>
    <div class="meta">Posted on 2004-12-15 23:13:44 by zellennium</div>
   </div>
   <div class="post" id="post-154224">
    <div class="subject"><a href="#post-154224">First 40 bytes are blanks in array ..????</a></div>
    <div class="body"><div class="quote"><br /><pre><code>   push   &#40;eax&#41;;                  // push it on the stack &#91;esp+4&#93;<br />   push   &#40;esi&#41;;                  // save esi we are changing it &#91;esp+8&#93; </code></pre><br /><br />Hmmm got to hit the books again going to fast maybe. <br /></div><br /><br />One more comment I should add to this.  It seems that you are using the push opcode to build automatic variables on the stack.  You shouldn't do it this way as it will create confusion.  Here is a better way:<br /><br />sub (8, esp) ;      // reserve 8 bytes of space on the stack.<br /><br />// now you have 2 dwords accessed as <br /><br />mov ( &lt;somedwordvalue&gt;, );          // this is your 1st 4-byte var object<br />mov ( &lt;anotherdwordvalue&gt;, );   // this is your 2nd 4-byte var object<br /><br />But you must be careful not to push or pop other data on the stack or you will lose your pointer.  If you wish to preserve your pointer, the ebp register is perfect for this (this is described in the section on low-level  procedures).</div>
    <div class="meta">Posted on 2004-12-15 23:29:53 by Kain</div>
   </div>
  </div>
 </body>
</html>