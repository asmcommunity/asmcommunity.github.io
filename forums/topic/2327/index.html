<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>using dlls (cygwin1.dll specifically) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=2327" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=2327">using dlls (cygwin1.dll specifically)</a></p>
   <div class="post" id="post-14737">
    <div class="subject"><a href="#post-14737">using dlls (cygwin1.dll specifically)</a></div>
    <div class="body">Hello,<br /><br />I'm used to using the unix standard library so I thought I could call a few of cygwin's functions and be all set. However it's not working and it could be because I'm doing something foolish (probably) or assuming that it should work when it will not in fact work at all, etc.<br /><br />I tried to follow Iczelion's tutorial #17 exactly.<br /><br />Could someone please take a look at this code? Thank you, if so.</div>
    <div class="meta">Posted on 2001-12-12 14:09:33 by cmonahan</div>
   </div>
   <div class="post" id="post-14738">
    <div class="subject"><a href="#post-14738">sorry, here's the code</a></div>
    <div class="body">Sorry, I was failing to figure out how to get it in monospaced.<br /><br />Here is the code although poorly spaced.<br /><br />;<br />; trys to use the cygwin1.dll posix layer.<br />;<br />; Based on the UseDLL.asm sample from Iczelion's Win32 asm<br />; tutorial, number 17.<br />;<br /><br />.386<br />.model flat,stdcall<br />option casemap:none<br /><br />include \masm32\include\windows.inc<br />include \masm32\include\user32.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\masm32.inc<br /><br />includelib \masm32\lib\kernel32.lib<br />includelib \masm32\lib\user32.lib<br />includelib \masm32\lib\masm32.lib<br /><br />.data<br />LibName db &quot;cygwin1.dll&quot;,0<br />FunctionName db &quot;printf&quot;,0<br />MallocName db &quot;malloc&quot;,0   ; try function taking 1 arg<br />RandName db &quot;rand&quot;,0       ; try function taking no args<br />DllNotFound db &quot;Cannot load library&quot;,0<br />FunctionNotFound db &quot; function not found&quot;,0<br />errStr db &quot;error code: %d&quot;,0<br />buffer db 1000h dup (?)<br />crlf db 10,13,0<br />formStr db &quot;I am a printf format string, %d\n&quot;,0<br />diagnost1 db &quot;about to call malloc&quot;,10,13,0<br />diagnost2 db &quot;done with call to malloc&quot;,10,13,0<br /><br />.data?<br />hLib dd ?   ; the handle of the DLL<br />printf dd ? ; the address of the external function<br />malloc dd ? ; ditto<br />rand   dd ? <br />i       DWORD ?<br /><br />.code<br />start:<br />    ; ////////////////////////////////////////////////////<br />    ; // get the cygwin1.dll posix library<br />    ; ////////////////////////////////////////////////////<br />    invoke LoadLibrary,addr LibName<br />    .IF eax==NULL<br />        invoke StdOut,ADDR DllNotFound<br />        invoke StdOut,ADDR crlf<br />        invoke ExitProcess,1<br />    .ENDIF<br />    mov hLib,eax<br /><br />    ; ////////////////////////////////////////////////////<br />    ; // test by using printf<br />    ; ////////////////////////////////////////////////////<br />    invoke GetProcAddress,hLib,ADDR FunctionName<br />    .IF eax==NULL<br />        invoke GetLastError<br />        invoke wsprintf,addr buffer,addr errStr,eax<br />        invoke StdOut,addr buffer<br />        invoke StdOut,ADDR crlf<br />        invoke StdOut,ADDR FunctionName<br />        invoke StdOut,ADDR FunctionNotFound<br />        invoke StdOut,ADDR crlf<br />        invoke ExitProcess,1<br />    .ENDIF<br />    mov printf,eax<br />    push i              ; push 3 args in reverse (r to l) order<br />    push offset formStr<br />    push offset buffer<br />    ;call       ; Executing this crashes the program<br /><br />    ; ////////////////////////////////////////////////////<br />    ; // try malloc (uses only 1 argument)<br />    ; ////////////////////////////////////////////////////<br />    invoke GetProcAddress,hLib,ADDR MallocName<br />    .IF eax==NULL<br />        invoke GetLastError<br />        invoke wsprintf,addr buffer,addr errStr,eax<br />        invoke StdOut,addr buffer<br />        invoke StdOut,ADDR crlf<br />        invoke StdOut,ADDR MallocName<br />        invoke StdOut,ADDR FunctionNotFound<br />        invoke StdOut,ADDR crlf<br />        invoke ExitProcess,1<br />    .ENDIF<br />    mov malloc,eax<br />    invoke StdOut,addr diagnost1 ; this gets output<br />    xor eax,eax ; these four lines are trying in paranoid fashion<br />    mov eax,5   ; to make sure to push 4 bytes...<br />    push eax    ;<br />    xor eax,eax ;<br />    ;call  ; Executing this crashes the program<br />    mov i,eax<br />    invoke StdOut,addr diagnost2 ; this is not output, if the malloc<br />                                 ; call is attempted.<br /><br />    ; ////////////////////////////////////////////////////<br />    ; // try rand (no args)<br />    ; ////////////////////////////////////////////////////<br />    invoke GetProcAddress,hLib,ADDR RandName<br />    .IF eax==NULL<br />        invoke GetLastError<br />        invoke wsprintf,addr buffer,addr errStr,eax<br />        invoke StdOut,addr buffer <br />        invoke StdOut,addr crlf<br />        invoke StdOut,addr RandName<br />        invoke StdOut,addr FunctionNotFound<br />        invoke StdOut,addr crlf<br />        invoke ExitProcess,1<br />    .ENDIF<br />    mov rand,eax<br />    call   ; this one works.<br />    <br />    invoke FreeLibrary,hLib<br />    invoke ExitProcess,0<br />end start</div>
    <div class="meta">Posted on 2001-12-12 14:10:50 by cmonahan</div>
   </div>
   <div class="post" id="post-14753">
    <div class="subject"><a href="#post-14753">now in spiffy courier!</a></div>
    <div class="body">If I only had a brain, I could have done this in just one post.<br /><br /><br />;<br />; trys to use the cygwin1.dll posix layer.<br />;<br />; Based on the UseDLL.asm sample from Iczelion's Win32 asm<br />; tutorial, number 17.<br />;<br /><br />.386<br />.model flat,stdcall<br />option casemap:none<br /><br />include \masm32\include\windows.inc<br />include \masm32\include\user32.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\masm32.inc<br /><br />includelib \masm32\lib\kernel32.lib<br />includelib \masm32\lib\user32.lib<br />includelib \masm32\lib\masm32.lib<br /><br />.data<br />LibName db &quot;cygwin1.dll&quot;,0<br />FunctionName db &quot;printf&quot;,0<br />MallocName db &quot;malloc&quot;,0   ; try function taking 1 arg<br />RandName db &quot;rand&quot;,0       ; try function taking no args<br />DllNotFound db &quot;Cannot load library&quot;,0<br />FunctionNotFound db &quot; function not found&quot;,0<br />errStr db &quot;error code: %d&quot;,0<br />buffer db 1000h dup (?)<br />crlf db 10,13,0<br />formStr db &quot;I am a printf format string, %d\n&quot;,0<br />diagnost1 db &quot;about to call malloc&quot;,10,13,0<br />diagnost2 db &quot;done with call to malloc&quot;,10,13,0<br /><br />.data?<br />hLib dd ?   ; the handle of the DLL<br />printf dd ? ; the address of the external function<br />malloc dd ? ; ditto<br />rand   dd ? <br />i       DWORD ?<br /><br />.code<br />start:<br />    ; ////////////////////////////////////////////////////<br />    ; // get the cygwin1.dll posix library<br />    ; ////////////////////////////////////////////////////<br />    invoke LoadLibrary,addr LibName<br />    .IF eax==NULL<br />        invoke StdOut,ADDR DllNotFound<br />        invoke StdOut,ADDR crlf<br />        invoke ExitProcess,1<br />    .ENDIF<br />    mov hLib,eax<br /><br />    ; ////////////////////////////////////////////////////<br />    ; // test by using printf<br />    ; ////////////////////////////////////////////////////<br />    invoke GetProcAddress,hLib,ADDR FunctionName<br />    .IF eax==NULL<br />        invoke GetLastError<br />        invoke wsprintf,addr buffer,addr errStr,eax<br />        invoke StdOut,addr buffer<br />        invoke StdOut,ADDR crlf<br />        invoke StdOut,ADDR FunctionName<br />        invoke StdOut,ADDR FunctionNotFound<br />        invoke StdOut,ADDR crlf<br />        invoke ExitProcess,1<br />    .ENDIF<br />    mov printf,eax<br />    push i              ; push 3 args in reverse (r to l) order<br />    push offset formStr<br />    push offset buffer<br />    ;call       ; Executing this crashes the program<br /><br />    ; ////////////////////////////////////////////////////<br />    ; // try malloc (uses only 1 argument)<br />    ; ////////////////////////////////////////////////////<br />    invoke GetProcAddress,hLib,ADDR MallocName<br />    .IF eax==NULL<br />        invoke GetLastError<br />        invoke wsprintf,addr buffer,addr errStr,eax<br />        invoke StdOut,addr buffer<br />        invoke StdOut,ADDR crlf<br />        invoke StdOut,ADDR MallocName<br />        invoke StdOut,ADDR FunctionNotFound<br />        invoke StdOut,ADDR crlf<br />        invoke ExitProcess,1<br />    .ENDIF<br />    mov malloc,eax<br />    invoke StdOut,addr diagnost1 ; this gets output<br />    xor eax,eax ; these four lines are trying in paranoid fashion<br />    mov eax,5   ; to make sure to push 4 bytes...<br />    push eax    ;<br />    xor eax,eax ;<br />    ;call  ; Executing this crashes the program<br />    mov i,eax<br />    invoke StdOut,addr diagnost2 ; this is not output, if the malloc<br />                                 ; call is attempted.<br /><br />    ; ////////////////////////////////////////////////////<br />    ; // try rand (no args)<br />    ; ////////////////////////////////////////////////////<br />    invoke GetProcAddress,hLib,ADDR RandName<br />    .IF eax==NULL<br />        invoke GetLastError<br />        invoke wsprintf,addr buffer,addr errStr,eax<br />        invoke StdOut,addr buffer <br />        invoke StdOut,addr crlf<br />        invoke StdOut,addr RandName<br />        invoke StdOut,addr FunctionNotFound<br />        invoke StdOut,addr crlf<br />        invoke ExitProcess,1<br />    .ENDIF<br />    mov rand,eax<br />    call   ; this one works.<br />    <br />    invoke FreeLibrary,hLib<br />    invoke ExitProcess,0<br />end start</div>
    <div class="meta">Posted on 2001-12-12 16:09:18 by cmonahan</div>
   </div>
  </div>
 </body>
</html>