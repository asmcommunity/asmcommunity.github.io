<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>PE, NE, LE formats struct info - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=8096" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=8096">PE, NE, LE formats struct info</a></p>
   <div class="post" id="post-59285">
    <div class="subject"><a href="#post-59285">PE, NE, LE formats struct info</a></div>
    <div class="body">For all those interested in knowing the PE, NE, LE formats, here is the header defined in winnt.h from visual c++<br /><br /><div class="quote"><br />//<br />// Image Format<br />//<br /><br /><br />#define IMAGE_DOS_SIGNATURE                 0x4D5A      // MZ<br />#define IMAGE_OS2_SIGNATURE                 0x4E45      // NE<br />#define IMAGE_OS2_SIGNATURE_LE              0x4C45      // LE<br />#define IMAGE_NT_SIGNATURE                  0x50450000  // PE00<br /><br />typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header<br />    WORD   e_magic;                     // Magic number<br />    WORD   e_cblp;                      // Bytes on last page of file<br />    WORD   e_cp;                        // Pages in file<br />    WORD   e_crlc;                      // Relocations<br />    WORD   e_cparhdr;                   // Size of header in paragraphs<br />    WORD   e_minalloc;                  // Minimum extra paragraphs needed<br />    WORD   e_maxalloc;                  // Maximum extra paragraphs needed<br />    WORD   e_ss;                        // Initial (relative) SS value<br />    WORD   e_sp;                        // Initial SP value<br />    WORD   e_csum;                      // Checksum<br />    WORD   e_ip;                        // Initial IP value<br />    WORD   e_cs;                        // Initial (relative) CS value<br />    WORD   e_lfarlc;                    // File address of relocation table<br />    WORD   e_ovno;                      // Overlay number<br />    WORD   e_res[4];                    // Reserved words<br />    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)<br />    WORD   e_oeminfo;                   // OEM information; e_oemid specific<br />    WORD   e_res2[10];                  // Reserved words<br />    LONG   e_lfanew;                    // File address of new exe header<br />  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;<br /><br />typedef struct _IMAGE_OS2_HEADER {      // OS/2 .EXE header<br />    WORD   ne_magic;                    // Magic number<br />    CHAR   ne_ver;                      // Version number<br />    CHAR   ne_rev;                      // Revision number<br />    WORD   ne_enttab;                   // Offset of Entry Table<br />    WORD   ne_cbenttab;                 // Number of bytes in Entry Table<br />    LONG   ne_crc;                      // Checksum of whole file<br />    WORD   ne_flags;                    // Flag word<br />    WORD   ne_autodata;                 // Automatic data segment number<br />    WORD   ne_heap;                     // Initial heap allocation<br />    WORD   ne_stack;                    // Initial stack allocation<br />    LONG   ne_csip;                     // Initial CS:IP setting<br />    LONG   ne_sssp;                     // Initial SS:SP setting<br />    WORD   ne_cseg;                     // Count of file segments<br />    WORD   ne_cmod;                     // Entries in Module Reference Table<br />    WORD   ne_cbnrestab;                // Size of non-resident name table<br />    WORD   ne_segtab;                   // Offset of Segment Table<br />    WORD   ne_rsrctab;                  // Offset of Resource Table<br />    WORD   ne_restab;                   // Offset of resident name table<br />    WORD   ne_modtab;                   // Offset of Module Reference Table<br />    WORD   ne_imptab;                   // Offset of Imported Names Table<br />    LONG   ne_nrestab;                  // Offset of Non-resident Names Table<br />    WORD   ne_cmovent;                  // Count of movable entries<br />    WORD   ne_align;                    // Segment alignment shift count<br />    WORD   ne_cres;                     // Count of resource segments<br />    BYTE   ne_exetyp;                   // Target Operating system<br />    BYTE   ne_flagsothers;              // Other .EXE flags<br />    WORD   ne_pretthunks;               // offset to return thunks<br />    WORD   ne_psegrefbytes;             // offset to segment ref. bytes<br />    WORD   ne_swaparea;                 // Minimum code swap area size<br />    WORD   ne_expver;                   // Expected Windows version number<br />  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;<br /><br />typedef struct _IMAGE_VXD_HEADER {      // Windows VXD header<br />    WORD   e32_magic;                   // Magic number<br />    BYTE   e32_border;                  // The byte ordering for the VXD<br />    BYTE   e32_worder;                  // The word ordering for the VXD<br />    DWORD  e32_level;                   // The EXE format level for now = 0<br />    WORD   e32_cpu;                     // The CPU type<br />    WORD   e32_os;                      // The OS type<br />    DWORD  e32_ver;                     // Module version<br />    DWORD  e32_mflags;                  // Module flags<br />    DWORD  e32_mpages;                  // Module # pages<br />    DWORD  e32_startobj;                // Object # for instruction pointer<br />    DWORD  e32_eip;                     // Extended instruction pointer<br />    DWORD  e32_stackobj;                // Object # for stack pointer<br />    DWORD  e32_esp;                     // Extended stack pointer<br />    DWORD  e32_pagesize;                // VXD page size<br />    DWORD  e32_lastpagesize;            // Last page size in VXD<br />    DWORD  e32_fixupsize;               // Fixup section size<br />    DWORD  e32_fixupsum;                // Fixup section checksum<br />    DWORD  e32_ldrsize;                 // Loader section size<br />    DWORD  e32_ldrsum;                  // Loader section checksum<br />    DWORD  e32_objtab;                  // Object table offset<br />    DWORD  e32_objcnt;                  // Number of objects in module<br />    DWORD  e32_objmap;                  // Object page map offset<br />    DWORD  e32_itermap;                 // Object iterated data map offset<br />    DWORD  e32_rsrctab;                 // Offset of Resource Table<br />    DWORD  e32_rsrccnt;                 // Number of resource entries<br />    DWORD  e32_restab;                  // Offset of resident name table<br />    DWORD  e32_enttab;                  // Offset of Entry Table<br />    DWORD  e32_dirtab;                  // Offset of Module Directive Table<br />    DWORD  e32_dircnt;                  // Number of module directives<br />    DWORD  e32_fpagetab;                // Offset of Fixup Page Table<br />    DWORD  e32_frectab;                 // Offset of Fixup Record Table<br />    DWORD  e32_impmod;                  // Offset of Import Module Name Table<br />    DWORD  e32_impmodcnt;               // Number of entries in Import Module Name Table<br />    DWORD  e32_impproc;                 // Offset of Import Procedure Name Table<br />    DWORD  e32_pagesum;                 // Offset of Per-Page Checksum Table<br />    DWORD  e32_datapage;                // Offset of Enumerated Data Pages<br />    DWORD  e32_preload;                 // Number of preload pages<br />    DWORD  e32_nrestab;                 // Offset of Non-resident Names Table<br />    DWORD  e32_cbnrestab;               // Size of Non-resident Name Table<br />    DWORD  e32_nressum;                 // Non-resident Name Table Checksum<br />    DWORD  e32_autodata;                // Object # for automatic data object<br />    DWORD  e32_debuginfo;               // Offset of the debugging information<br />    DWORD  e32_debuglen;                // The length of the debugging info. in bytes<br />    DWORD  e32_instpreload;             // Number of instance pages in preload section of VXD file<br />    DWORD  e32_instdemand;              // Number of instance pages in demand load section of VXD file<br />    DWORD  e32_heapsize;                // Size of heap - for 16-bit apps<br />    BYTE   e32_res3[12];                // Reserved words<br />    DWORD  e32_winresoff;<br />    DWORD  e32_winreslen;<br />    WORD   e32_devid;                   // Device ID for VxD<br />    WORD   e32_ddkver;                  // DDK version for VxD<br />  } IMAGE_VXD_HEADER, *PIMAGE_VXD_HEADER;<br /><br /><br />//<br />// File header format.<br />//<br /><br />typedef struct _IMAGE_FILE_HEADER {<br />    WORD    Machine;<br />    WORD    NumberOfSections;<br />    DWORD   TimeDateStamp;<br />    DWORD   PointerToSymbolTable;<br />    DWORD   NumberOfSymbols;<br />    WORD    SizeOfOptionalHeader;<br />    WORD    Characteristics;<br />} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;<br /><br /><br />#define IMAGE_SIZEOF_FILE_HEADER             20<br /><br /><br />#define IMAGE_FILE_RELOCS_STRIPPED           0x0001  // Relocation info stripped from file.<br />#define IMAGE_FILE_EXECUTABLE_IMAGE          0x0002  // File is executable  (i.e. no unresolved externel references).<br />#define IMAGE_FILE_LINE_NUMS_STRIPPED        0x0004  // Line nunbers stripped from file.<br />#define IMAGE_FILE_LOCAL_SYMS_STRIPPED       0x0008  // Local symbols stripped from file.<br />#define IMAGE_FILE_AGGRESIVE_WS_TRIM         0x0010  // Agressively trim working set<br />#define IMAGE_FILE_LARGE_ADDRESS_AWARE       0x0020  // App can handle &gt;2gb addresses<br />#define IMAGE_FILE_BYTES_REVERSED_LO         0x0080  // Bytes of machine word are reversed.<br />#define IMAGE_FILE_32BIT_MACHINE             0x0100  // 32 bit word machine.<br />#define IMAGE_FILE_DEBUG_STRIPPED            0x0200  // Debugging info stripped from file in .DBG file<br />#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   0x0400  // If Image is on removable media, copy and run from the swap file.<br />#define IMAGE_FILE_NET_RUN_FROM_SWAP         0x0800  // If Image is on Net, copy and run from the swap file.<br />#define IMAGE_FILE_SYSTEM                    0x1000  // System File.<br />#define IMAGE_FILE_DLL                       0x2000  // File is a DLL.<br />#define IMAGE_FILE_UP_SYSTEM_ONLY            0x4000  // File should only be run on a UP machine<br />#define IMAGE_FILE_BYTES_REVERSED_HI         0x8000  // Bytes of machine word are reversed.<br /><br />#define IMAGE_FILE_MACHINE_UNKNOWN           0<br />#define IMAGE_FILE_MACHINE_I386              0x014c  // Intel 386.<br />#define IMAGE_FILE_MACHINE_R3000             0x0162  // MIPS little-endian, 0x160 big-endian<br />#define IMAGE_FILE_MACHINE_R4000             0x0166  // MIPS little-endian<br />#define IMAGE_FILE_MACHINE_R10000            0x0168  // MIPS little-endian<br />#define IMAGE_FILE_MACHINE_WCEMIPSV2         0x0169  // MIPS little-endian WCE v2<br />#define IMAGE_FILE_MACHINE_ALPHA             0x0184  // Alpha_AXP<br />#define IMAGE_FILE_MACHINE_POWERPC           0x01F0  // IBM PowerPC Little-Endian<br />#define IMAGE_FILE_MACHINE_SH3               0x01a2  // SH3 little-endian<br />#define IMAGE_FILE_MACHINE_SH3E              0x01a4  // SH3E little-endian<br />#define IMAGE_FILE_MACHINE_SH4               0x01a6  // SH4 little-endian<br />#define IMAGE_FILE_MACHINE_ARM               0x01c0  // ARM Little-Endian<br />#define IMAGE_FILE_MACHINE_THUMB             0x01c2<br />#define IMAGE_FILE_MACHINE_IA64              0x0200  // Intel 64<br />#define IMAGE_FILE_MACHINE_MIPS16            0x0266  // MIPS<br />#define IMAGE_FILE_MACHINE_MIPSFPU           0x0366  // MIPS<br />#define IMAGE_FILE_MACHINE_MIPSFPU16         0x0466  // MIPS<br />#define IMAGE_FILE_MACHINE_ALPHA64           0x0284  // ALPHA64<br />#define IMAGE_FILE_MACHINE_AXP64             IMAGE_FILE_MACHINE_ALPHA64<br />//<br />// Directory format.<br />//<br /><br />typedef struct _IMAGE_DATA_DIRECTORY {<br />    DWORD   VirtualAddress;<br />    DWORD   Size;<br />} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;<br /><br />#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16<br /><br />//<br />// Optional header format.<br />//<br /><br />typedef struct _IMAGE_OPTIONAL_HEADER {<br />    //<br />    // Standard fields.<br />    //<br /><br />    WORD    Magic;<br />    BYTE    MajorLinkerVersion;<br />    BYTE    MinorLinkerVersion;<br />    DWORD   SizeOfCode;<br />    DWORD   SizeOfInitializedData;<br />    DWORD   SizeOfUninitializedData;<br />    DWORD   AddressOfEntryPoint;<br />    DWORD   BaseOfCode;<br />    DWORD   BaseOfData;<br /><br />    //<br />    // NT additional fields.<br />    //<br /><br />    DWORD   ImageBase;<br />    DWORD   SectionAlignment;<br />    DWORD   FileAlignment;<br />    WORD    MajorOperatingSystemVersion;<br />    WORD    MinorOperatingSystemVersion;<br />    WORD    MajorImageVersion;<br />    WORD    MinorImageVersion;<br />    WORD    MajorSubsystemVersion;<br />    WORD    MinorSubsystemVersion;<br />    DWORD   Win32VersionValue;<br />    DWORD   SizeOfImage;<br />    DWORD   SizeOfHeaders;<br />    DWORD   CheckSum;<br />    WORD    Subsystem;<br />    WORD    DllCharacteristics;<br />    DWORD   SizeOfStackReserve;<br />    DWORD   SizeOfStackCommit;<br />    DWORD   SizeOfHeapReserve;<br />    DWORD   SizeOfHeapCommit;<br />    DWORD   LoaderFlags;<br />    DWORD   NumberOfRvaAndSizes;<br />    IMAGE_DATA_DIRECTORY DataDirectory;<br />} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;<br /><br />typedef struct _IMAGE_ROM_OPTIONAL_HEADER {<br />    WORD   Magic;<br />    BYTE   MajorLinkerVersion;<br />    BYTE   MinorLinkerVersion;<br />    DWORD  SizeOfCode;<br />    DWORD  SizeOfInitializedData;<br />    DWORD  SizeOfUninitializedData;<br />    DWORD  AddressOfEntryPoint;<br />    DWORD  BaseOfCode;<br />    DWORD  BaseOfData;<br />    DWORD  BaseOfBss;<br />    DWORD  GprMask;<br />    DWORD  CprMask[4];<br />    DWORD  GpValue;<br />} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;<br /><br />typedef struct _IMAGE_OPTIONAL_HEADER64 {<br />    WORD        Magic;<br />    BYTE        MajorLinkerVersion;<br />    BYTE        MinorLinkerVersion;<br />    DWORD       SizeOfCode;<br />    DWORD       SizeOfInitializedData;<br />    DWORD       SizeOfUninitializedData;<br />    DWORD       AddressOfEntryPoint;<br />    DWORD       BaseOfCode;<br />    ULONGLONG   ImageBase;<br />    DWORD       SectionAlignment;<br />    DWORD       FileAlignment;<br />    WORD        MajorOperatingSystemVersion;<br />    WORD        MinorOperatingSystemVersion;<br />    WORD        MajorImageVersion;<br />    WORD        MinorImageVersion;<br />    WORD        MajorSubsystemVersion;<br />    WORD        MinorSubsystemVersion;<br />    DWORD       Win32VersionValue;<br />    DWORD       SizeOfImage;<br />    DWORD       SizeOfHeaders;<br />    DWORD       CheckSum;<br />    WORD        Subsystem;<br />    WORD        DllCharacteristics;<br />    ULONGLONG   SizeOfStackReserve;<br />    ULONGLONG   SizeOfStackCommit;<br />    ULONGLONG   SizeOfHeapReserve;<br />    ULONGLONG   SizeOfHeapCommit;<br />    DWORD       LoaderFlags;<br />    DWORD       NumberOfRvaAndSizes;<br />    IMAGE_DATA_DIRECTORY DataDirectory;<br />} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;<br /><br />#define IMAGE_SIZEOF_ROM_OPTIONAL_HEADER      56<br />#define IMAGE_SIZEOF_STD_OPTIONAL_HEADER      28<br />#define IMAGE_SIZEOF_NT_OPTIONAL32_HEADER    224<br />#define IMAGE_SIZEOF_NT_OPTIONAL64_HEADER    240<br /><br />#define IMAGE_NT_OPTIONAL_HDR32_MAGIC      0x10b<br />#define IMAGE_NT_OPTIONAL_HDR64_MAGIC      0x20b<br />#define IMAGE_ROM_OPTIONAL_HDR_MAGIC       0x107<br /><br />typedef IMAGE_OPTIONAL_HEADER32             IMAGE_OPTIONAL_HEADER;<br />typedef PIMAGE_OPTIONAL_HEADER32            PIMAGE_OPTIONAL_HEADER;<br />#define IMAGE_SIZEOF_NT_OPTIONAL_HEADER     IMAGE_SIZEOF_NT_OPTIONAL32_HEADER<br />#define IMAGE_NT_OPTIONAL_HDR_MAGIC         IMAGE_NT_OPTIONAL_HDR32_MAGIC<br /><br />typedef struct _IMAGE_NT_HEADERS {<br />    DWORD Signature;<br />    IMAGE_FILE_HEADER FileHeader;<br />    IMAGE_OPTIONAL_HEADER32 OptionalHeader;<br />} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;<br /><br />typedef struct _IMAGE_ROM_HEADERS {<br />    IMAGE_FILE_HEADER FileHeader;<br />    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;<br />} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;<br /><br /><br />#define IMAGE_FIRST_SECTION32( ntheader ) ((PIMAGE_SECTION_HEADER)        \<br />    ((UINT_PTR)ntheader +                                                  \<br />     FIELD_OFFSET( IMAGE_NT_HEADERS32, OptionalHeader ) +                 \<br />     ((PIMAGE_NT_HEADERS32)(ntheader))-&gt;FileHeader.SizeOfOptionalHeader   \<br />    ))<br /><br />typedef IMAGE_NT_HEADERS32                  IMAGE_NT_HEADERS;<br />typedef PIMAGE_NT_HEADERS32                 PIMAGE_NT_HEADERS;<br />#define IMAGE_FIRST_SECTION(ntheader)       IMAGE_FIRST_SECTION32(ntheader)<br /><br />// Subsystem Values<br /><br />#define IMAGE_SUBSYSTEM_UNKNOWN              0   // Unknown subsystem.<br />#define IMAGE_SUBSYSTEM_NATIVE               1   // Image doesn't require a subsystem.<br />#define IMAGE_SUBSYSTEM_WINDOWS_GUI          2   // Image runs in the Windows GUI subsystem.<br />#define IMAGE_SUBSYSTEM_WINDOWS_CUI          3   // Image runs in the Windows character subsystem.<br />#define IMAGE_SUBSYSTEM_OS2_CUI              5   // image runs in the OS/2 character subsystem.<br />#define IMAGE_SUBSYSTEM_POSIX_CUI            7   // image runs in the Posix character subsystem.<br />#define IMAGE_SUBSYSTEM_NATIVE_WINDOWS       8   // image is a native Win9x driver.<br />#define IMAGE_SUBSYSTEM_WINDOWS_CE_GUI       9   // Image runs in the Windows CE subsystem.<br /><br />// DllCharacteristics Entries<br /><br />//      IMAGE_LIBRARY_PROCESS_INIT           0x0001     // Reserved.<br />//      IMAGE_LIBRARY_PROCESS_TERM           0x0002     // Reserved.<br />//      IMAGE_LIBRARY_THREAD_INIT            0x0004     // Reserved.<br />//      IMAGE_LIBRARY_THREAD_TERM            0x0008     // Reserved.<br />#define IMAGE_DLLCHARACTERISTICS_WDM_DRIVER  0x2000     // Driver uses WDM model<br /><br />// Directory Entries<br /><br />#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory<br />#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory<br />#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory<br />#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory<br />#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory<br />#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table<br />#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory<br />//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)<br />#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data<br />#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP<br />#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory<br />#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory<br />#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers<br />#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table<br />#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors<br />#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor<br /><br />//<br />// Section header format.<br />//<br /><br />#define IMAGE_SIZEOF_SHORT_NAME              8<br /><br />typedef struct _IMAGE_SECTION_HEADER {<br />    BYTE    Name;<br />    union {<br />            DWORD   PhysicalAddress;<br />            DWORD   VirtualSize;<br />    } Misc;<br />    DWORD   VirtualAddress;<br />    DWORD   SizeOfRawData;<br />    DWORD   PointerToRawData;<br />    DWORD   PointerToRelocations;<br />    DWORD   PointerToLinenumbers;<br />    WORD    NumberOfRelocations;<br />    WORD    NumberOfLinenumbers;<br />    DWORD   Characteristics;<br />} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;<br /><br />#define IMAGE_SIZEOF_SECTION_HEADER          40<br /><br />//<br />// Section characteristics.<br />//<br />//      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.<br />//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.<br />//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.<br />//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.<br />#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.<br />//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.<br /><br />#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.<br />#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.<br />#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.<br /><br />#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.<br />#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.<br />//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.<br />#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.<br />#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.<br />//                                           0x00002000  // Reserved.<br />//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000<br />#define IMAGE_SCN_NO_DEFER_SPEC_EXC          0x00004000  // Reset speculative exceptions handling bits in the TLB entries for this section.<br />#define IMAGE_SCN_GPREL                      0x00008000  // Section content can be accessed relative to GP<br />#define IMAGE_SCN_MEM_FARDATA                0x00008000<br />//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000<br />#define IMAGE_SCN_MEM_PURGEABLE              0x00020000<br />#define IMAGE_SCN_MEM_16BIT                  0x00020000<br />#define IMAGE_SCN_MEM_LOCKED                 0x00040000<br />#define IMAGE_SCN_MEM_PRELOAD                0x00080000<br /><br />#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //<br />#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //<br />#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //<br />#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //<br />#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.<br />#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //<br />#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //<br />#define IMAGE_SCN_ALIGN_128BYTES             0x00800000  //<br />#define IMAGE_SCN_ALIGN_256BYTES             0x00900000  //<br />#define IMAGE_SCN_ALIGN_512BYTES             0x00A00000  //<br />#define IMAGE_SCN_ALIGN_1024BYTES            0x00B00000  //<br />#define IMAGE_SCN_ALIGN_2048BYTES            0x00C00000  //<br />#define IMAGE_SCN_ALIGN_4096BYTES            0x00D00000  //<br />#define IMAGE_SCN_ALIGN_8192BYTES            0x00E00000  //<br />// Unused                                    0x00F00000<br /><br />#define IMAGE_SCN_LNK_NRELOC_OVFL            0x01000000  // Section contains extended relocations.<br />#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.<br />#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.<br />#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.<br />#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.<br />#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.<br />#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.<br />#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.<br /><br />//<br />// TLS Characteristic Flags<br />//<br />#define IMAGE_SCN_SCALE_INDEX                0x00000001  // Tls index is scaled<br /><br />//<br />// Symbol format.<br />//<br /><br />typedef struct _IMAGE_SYMBOL {<br />    union {<br />        BYTE    ShortName[8];<br />        struct {<br />            DWORD   Short;     // if 0, use LongName<br />            DWORD   Long;      // offset into string table<br />        } Name;<br />        PBYTE   LongName[2];<br />    } N;<br />    DWORD   Value;<br />    SHORT   SectionNumber;<br />    WORD    Type;<br />    BYTE    StorageClass;<br />    BYTE    NumberOfAuxSymbols;<br />} IMAGE_SYMBOL;<br />typedef IMAGE_SYMBOL UNALIGNED *PIMAGE_SYMBOL;<br /><br /><br />#define IMAGE_SIZEOF_SYMBOL                  18<br /><br />//<br />// Section values.<br />//<br />// Symbols have a section number of the section in which they are<br />// defined. Otherwise, section numbers have the following meanings:<br />//<br /><br />#define IMAGE_SYM_UNDEFINED           (SHORT)0          // Symbol is undefined or is common.<br />#define IMAGE_SYM_ABSOLUTE            (SHORT)-1         // Symbol is an absolute value.<br />#define IMAGE_SYM_DEBUG               (SHORT)-2         // Symbol is a special debug item.<br /><br />//<br />// Type (fundamental) values.<br />//<br /><br />#define IMAGE_SYM_TYPE_NULL                 0x0000  // no type.<br />#define IMAGE_SYM_TYPE_VOID                 0x0001  //<br />#define IMAGE_SYM_TYPE_CHAR                 0x0002  // type character.<br />#define IMAGE_SYM_TYPE_SHORT                0x0003  // type short integer.<br />#define IMAGE_SYM_TYPE_INT                  0x0004  //<br />#define IMAGE_SYM_TYPE_LONG                 0x0005  //<br />#define IMAGE_SYM_TYPE_FLOAT                0x0006  //<br />#define IMAGE_SYM_TYPE_DOUBLE               0x0007  //<br />#define IMAGE_SYM_TYPE_STRUCT               0x0008  //<br />#define IMAGE_SYM_TYPE_UNION                0x0009  //<br />#define IMAGE_SYM_TYPE_ENUM                 0x000A  // enumeration.<br />#define IMAGE_SYM_TYPE_MOE                  0x000B  // member of enumeration.<br />#define IMAGE_SYM_TYPE_BYTE                 0x000C  //<br />#define IMAGE_SYM_TYPE_WORD                 0x000D  //<br />#define IMAGE_SYM_TYPE_UINT                 0x000E  //<br />#define IMAGE_SYM_TYPE_DWORD                0x000F  //<br />#define IMAGE_SYM_TYPE_PCODE                0x8000  //<br />//<br />// Type (derived) values.<br />//<br /><br />#define IMAGE_SYM_DTYPE_NULL                0       // no derived type.<br />#define IMAGE_SYM_DTYPE_POINTER             1       // pointer.<br />#define IMAGE_SYM_DTYPE_FUNCTION            2       // function.<br />#define IMAGE_SYM_DTYPE_ARRAY               3       // array.<br /><br />//<br />// Storage classes.<br />//<br />#define IMAGE_SYM_CLASS_END_OF_FUNCTION     (BYTE )-1<br />#define IMAGE_SYM_CLASS_NULL                0x0000<br />#define IMAGE_SYM_CLASS_AUTOMATIC           0x0001<br />#define IMAGE_SYM_CLASS_EXTERNAL            0x0002<br />#define IMAGE_SYM_CLASS_STATIC              0x0003<br />#define IMAGE_SYM_CLASS_REGISTER            0x0004<br />#define IMAGE_SYM_CLASS_EXTERNAL_DEF        0x0005<br />#define IMAGE_SYM_CLASS_LABEL               0x0006<br />#define IMAGE_SYM_CLASS_UNDEFINED_LABEL     0x0007<br />#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT    0x0008<br />#define IMAGE_SYM_CLASS_ARGUMENT            0x0009<br />#define IMAGE_SYM_CLASS_STRUCT_TAG          0x000A<br />#define IMAGE_SYM_CLASS_MEMBER_OF_UNION     0x000B<br />#define IMAGE_SYM_CLASS_UNION_TAG           0x000C<br />#define IMAGE_SYM_CLASS_TYPE_DEFINITION     0x000D<br />#define IMAGE_SYM_CLASS_UNDEFINED_STATIC    0x000E<br />#define IMAGE_SYM_CLASS_ENUM_TAG            0x000F<br />#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM      0x0010<br />#define IMAGE_SYM_CLASS_REGISTER_PARAM      0x0011<br />#define IMAGE_SYM_CLASS_BIT_FIELD           0x0012<br /><br />#define IMAGE_SYM_CLASS_FAR_EXTERNAL        0x0044  //<br /><br />#define IMAGE_SYM_CLASS_BLOCK               0x0064<br />#define IMAGE_SYM_CLASS_FUNCTION            0x0065<br />#define IMAGE_SYM_CLASS_END_OF_STRUCT       0x0066<br />#define IMAGE_SYM_CLASS_FILE                0x0067<br />// new<br />#define IMAGE_SYM_CLASS_SECTION             0x0068<br />#define IMAGE_SYM_CLASS_WEAK_EXTERNAL       0x0069<br /><br />// type packing constants<br /><br />#define N_BTMASK                            0x000F<br />#define N_TMASK                             0x0030<br />#define N_TMASK1                            0x00C0<br />#define N_TMASK2                            0x00F0<br />#define N_BTSHFT                            4<br />#define N_TSHIFT                            2<br />// MACROS<br /><br />// Basic Type of  x<br />#define BTYPE(x) ((x) &amp; N_BTMASK)<br /><br />// Is x a pointer?<br />#ifndef ISPTR<br />#define ISPTR(x) (((x) &amp; N_TMASK) == (IMAGE_SYM_DTYPE_POINTER &lt;&lt; N_BTSHFT))<br />#endif<br /><br />// Is x a function?<br />#ifndef ISFCN<br />#define ISFCN(x) (((x) &amp; N_TMASK) == (IMAGE_SYM_DTYPE_FUNCTION &lt;&lt; N_BTSHFT))<br />#endif<br /><br />// Is x an array?<br /><br />#ifndef ISARY<br />#define ISARY(x) (((x) &amp; N_TMASK) == (IMAGE_SYM_DTYPE_ARRAY &lt;&lt; N_BTSHFT))<br />#endif<br /><br />// Is x a structure, union, or enumeration TAG?<br />#ifndef ISTAG<br />#define ISTAG(x) ((x)==IMAGE_SYM_CLASS_STRUCT_TAG || (x)==IMAGE_SYM_CLASS_UNION_TAG || (x)==IMAGE_SYM_CLASS_ENUM_TAG)<br />#endif<br /><br />#ifndef INCREF<br />#define INCREF(x) ((((x)&amp;~N_BTMASK)&lt;&lt;N_TSHIFT)|(IMAGE_SYM_DTYPE_POINTER&lt;&lt;N_BTSHFT)|((x)&amp;N_BTMASK))<br />#endif<br />#ifndef DECREF<br />#define DECREF(x) ((((x)&gt;&gt;N_TSHIFT)&amp;~N_BTMASK)|((x)&amp;N_BTMASK))<br />#endif<br /><br />//<br />// Auxiliary entry format.<br />//<br /><br />typedef union _IMAGE_AUX_SYMBOL {<br />    struct {<br />        DWORD    TagIndex;                      // struct, union, or enum tag index<br />        union {<br />            struct {<br />                WORD    Linenumber;             // declaration line number<br />                WORD    Size;                   // size of struct, union, or enum<br />            } LnSz;<br />           DWORD    TotalSize;<br />        } Misc;<br />        union {<br />            struct {                            // if ISFCN, tag, or .bb<br />                DWORD    PointerToLinenumber;<br />                DWORD    PointerToNextFunction;<br />            } Function;<br />            struct {                            // if ISARY, up to 4 dimen.<br />                WORD     Dimension[4];<br />            } Array;<br />        } FcnAry;<br />        WORD    TvIndex;                        // tv index<br />    } Sym;<br />    struct {<br />        BYTE    Name;<br />    } File;<br />    struct {<br />        DWORD   Length;                         // section length<br />        WORD    NumberOfRelocations;            // number of relocation entries<br />        WORD    NumberOfLinenumbers;            // number of line numbers<br />        DWORD   CheckSum;                       // checksum for communal<br />        SHORT   Number;                         // section number to associate with<br />        BYTE    Selection;                      // communal selection type<br />    } Section;<br />} IMAGE_AUX_SYMBOL;<br />typedef IMAGE_AUX_SYMBOL UNALIGNED *PIMAGE_AUX_SYMBOL;<br /><br />#define IMAGE_SIZEOF_AUX_SYMBOL             18<br /><br />//<br />// Communal selection types.<br />//<br /><br />#define IMAGE_COMDAT_SELECT_NODUPLICATES    1<br />#define IMAGE_COMDAT_SELECT_ANY             2<br />#define IMAGE_COMDAT_SELECT_SAME_SIZE       3<br />#define IMAGE_COMDAT_SELECT_EXACT_MATCH     4<br />#define IMAGE_COMDAT_SELECT_ASSOCIATIVE     5<br />#define IMAGE_COMDAT_SELECT_LARGEST         6<br />#define IMAGE_COMDAT_SELECT_NEWEST          7<br /><br />#define IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY  1<br />#define IMAGE_WEAK_EXTERN_SEARCH_LIBRARY    2<br />#define IMAGE_WEAK_EXTERN_SEARCH_ALIAS      3<br /><br />//<br />// Relocation format.<br />//<br /><br />typedef struct _IMAGE_RELOCATION {<br />    union {<br />        DWORD   VirtualAddress;<br />        DWORD   RelocCount;             // Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set<br />    };<br />    DWORD   SymbolTableIndex;<br />    WORD    Type;<br />} IMAGE_RELOCATION;<br />typedef IMAGE_RELOCATION UNALIGNED *PIMAGE_RELOCATION;<br /><br />#define IMAGE_SIZEOF_RELOCATION         10<br /><br />//<br />// I386 relocation types.<br />//<br />#define IMAGE_REL_I386_ABSOLUTE         0x0000  // Reference is absolute, no relocation is necessary<br />#define IMAGE_REL_I386_DIR16            0x0001  // Direct 16-bit reference to the symbols virtual address<br />#define IMAGE_REL_I386_REL16            0x0002  // PC-relative 16-bit reference to the symbols virtual address<br />#define IMAGE_REL_I386_DIR32            0x0006  // Direct 32-bit reference to the symbols virtual address<br />#define IMAGE_REL_I386_DIR32NB          0x0007  // Direct 32-bit reference to the symbols virtual address, base not included<br />#define IMAGE_REL_I386_SEG12            0x0009  // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address<br />#define IMAGE_REL_I386_SECTION          0x000A<br />#define IMAGE_REL_I386_SECREL           0x000B<br />#define IMAGE_REL_I386_REL32            0x0014  // PC-relative 32-bit reference to the symbols virtual address<br /><br />//<br />// Line number format.<br />//<br /><br />typedef struct _IMAGE_LINENUMBER {<br />    union {<br />        DWORD   SymbolTableIndex;               // Symbol table index of function name if Linenumber is 0.<br />        DWORD   VirtualAddress;                 // Virtual address of line number.<br />    } Type;<br />    WORD    Linenumber;                         // Line number.<br />} IMAGE_LINENUMBER;<br />typedef IMAGE_LINENUMBER UNALIGNED *PIMAGE_LINENUMBER;<br /><br />#define IMAGE_SIZEOF_LINENUMBER              6<br /><br />//<br />// Based relocation format.<br />//<br /><br />typedef struct _IMAGE_BASE_RELOCATION {<br />    DWORD   VirtualAddress;<br />    DWORD   SizeOfBlock;<br />//  WORD    TypeOffset[1];<br />} IMAGE_BASE_RELOCATION;<br />typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;<br /><br />#define IMAGE_SIZEOF_BASE_RELOCATION         8<br /><br />//<br />// Based relocation types.<br />//<br /><br />#define IMAGE_REL_BASED_ABSOLUTE              0<br />#define IMAGE_REL_BASED_HIGH                  1<br />#define IMAGE_REL_BASED_LOW                   2<br />#define IMAGE_REL_BASED_HIGHLOW               3<br />#define IMAGE_REL_BASED_HIGHADJ               4<br />#define IMAGE_REL_BASED_MIPS_JMPADDR          5<br />#define IMAGE_REL_BASED_SECTION               6<br />#define IMAGE_REL_BASED_REL32                 7<br /><br />#define IMAGE_REL_BASED_MIPS_JMPADDR16        9<br />#define IMAGE_REL_BASED_IA64_IMM64            9<br />#define IMAGE_REL_BASED_DIR64                 10<br />#define IMAGE_REL_BASED_HIGH3ADJ              11<br /><br /><br />//<br />// Archive format.<br />//<br /><br />#define IMAGE_ARCHIVE_START_SIZE             8<br />#define IMAGE_ARCHIVE_START                  &quot;!&lt;arch&gt;\n&quot;<br />#define IMAGE_ARCHIVE_END                    &quot;`\n&quot;<br />#define IMAGE_ARCHIVE_PAD                    &quot;\n&quot;<br />#define IMAGE_ARCHIVE_LINKER_MEMBER          &quot;/               &quot;<br />#define IMAGE_ARCHIVE_LONGNAMES_MEMBER       &quot;//              &quot;<br /><br />typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {<br />    BYTE     Name[16];                          // File member name - `/' terminated.<br />    BYTE     Date[12];                          // File member date - decimal.<br />    BYTE     UserID[6];                         // File member user id - decimal.<br />    BYTE     GroupID[6];                        // File member group id - decimal.<br />    BYTE     Mode[8];                           // File member mode - octal.<br />    BYTE     Size[10];                          // File member size - decimal.<br />    BYTE     EndHeader[2];                      // String to end header.<br />} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;<br /><br />#define IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR      60<br /><br />//<br />// DLL support.<br />//<br /><br />//<br />// Export Format<br />//<br /><br />typedef struct _IMAGE_EXPORT_DIRECTORY {<br />    DWORD   Characteristics;<br />    DWORD   TimeDateStamp;<br />    WORD    MajorVersion;<br />    WORD    MinorVersion;<br />    DWORD   Name;<br />    DWORD   Base;<br />    DWORD   NumberOfFunctions;<br />    DWORD   NumberOfNames;<br />    DWORD   AddressOfFunctions;     // RVA from base of image<br />    DWORD   AddressOfNames;         // RVA from base of image<br />    DWORD   AddressOfNameOrdinals;  // RVA from base of image<br />} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;<br /><br />//<br />// Import Format<br />//<br /><br />typedef struct _IMAGE_IMPORT_BY_NAME {<br />    WORD    Hint;<br />    BYTE    Name[1];<br />} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;<br /><br />typedef struct _IMAGE_THUNK_DATA32 {<br />    union {<br />        PBYTE  ForwarderString;<br />        PDWORD Function;<br />        DWORD Ordinal;<br />        PIMAGE_IMPORT_BY_NAME  AddressOfData;<br />    } u1;<br />} IMAGE_THUNK_DATA32;<br />typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;<br /><br />#define IMAGE_ORDINAL_FLAG64 0x8000000000000000<br />#define IMAGE_ORDINAL_FLAG32 0x80000000<br />#define IMAGE_ORDINAL64(Ordinal) (Ordinal &amp; 0xffff)<br />#define IMAGE_ORDINAL32(Ordinal) (Ordinal &amp; 0xffff)<br />#define IMAGE_SNAP_BY_ORDINAL64(Ordinal) ((Ordinal &amp; IMAGE_ORDINAL_FLAG64) != 0)<br />#define IMAGE_SNAP_BY_ORDINAL32(Ordinal) ((Ordinal &amp; IMAGE_ORDINAL_FLAG32) != 0)<br /><br />//<br />// Thread Local Storage<br />//<br /><br />typedef VOID<br />(NTAPI *PIMAGE_TLS_CALLBACK) (<br />    PVOID DllHandle,<br />    DWORD Reason,<br />    PVOID Reserved<br />    );<br /><br />typedef struct _IMAGE_TLS_DIRECTORY64 {<br />    ULONGLONG   StartAddressOfRawData;<br />    ULONGLONG   EndAddressOfRawData;<br />    PDWORD  AddressOfIndex;<br />    PIMAGE_TLS_CALLBACK *AddressOfCallBacks;<br />    DWORD   SizeOfZeroFill;<br />    DWORD   Characteristics;<br />} IMAGE_TLS_DIRECTORY64;<br />typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;<br /><br />typedef struct _IMAGE_TLS_DIRECTORY32 {<br />    DWORD   StartAddressOfRawData;<br />    DWORD   EndAddressOfRawData;<br />    PDWORD  AddressOfIndex;<br />    PIMAGE_TLS_CALLBACK *AddressOfCallBacks;<br />    DWORD   SizeOfZeroFill;<br />    DWORD   Characteristics;<br />} IMAGE_TLS_DIRECTORY32;<br />typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;<br /><br />#define IMAGE_ORDINAL_FLAG              IMAGE_ORDINAL_FLAG32<br />#define IMAGE_ORDINAL(Ordinal)          IMAGE_ORDINAL32(Ordinal)<br />typedef IMAGE_THUNK_DATA32              IMAGE_THUNK_DATA;<br />typedef PIMAGE_THUNK_DATA32             PIMAGE_THUNK_DATA;<br />#define IMAGE_SNAP_BY_ORDINAL(Ordinal)  IMAGE_SNAP_BY_ORDINAL32(Ordinal)<br />typedef IMAGE_TLS_DIRECTORY32           IMAGE_TLS_DIRECTORY;<br />typedef PIMAGE_TLS_DIRECTORY32          PIMAGE_TLS_DIRECTORY;<br /><br />typedef struct _IMAGE_IMPORT_DESCRIPTOR {<br />    union {<br />        DWORD   Characteristics;            // 0 for terminating null import descriptor<br />        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)<br />    };<br />    DWORD   TimeDateStamp;                  // 0 if not bound,<br />                                            // -1 if bound, and real date\time stamp<br />                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)<br />                                            // O.W. date/time stamp of DLL bound to (Old BIND)<br /><br />    DWORD   ForwarderChain;                 // -1 if no forwarders<br />    DWORD   Name;<br />    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)<br />} IMAGE_IMPORT_DESCRIPTOR;<br />typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;<br /><br />//<br />// New format import descriptors pointed to by DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ]<br />//<br /><br />typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {<br />    DWORD   TimeDateStamp;<br />    WORD    OffsetModuleName;<br />    WORD    NumberOfModuleForwarderRefs;<br />// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows<br />} IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;<br /><br />typedef struct _IMAGE_BOUND_FORWARDER_REF {<br />    DWORD   TimeDateStamp;<br />    WORD    OffsetModuleName;<br />    WORD    Reserved;<br />} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;<br /><br /><br />//<br />// Resource Format.<br />//<br /><br />//<br />// Resource directory consists of two counts, following by a variable length<br />// array of directory entries.  The first count is the number of entries at<br />// beginning of the array that have actual names associated with each entry.<br />// The entries are in ascending order, case insensitive strings.  The second<br />// count is the number of entries that immediately follow the named entries.<br />// This second count identifies the number of entries that have 16-bit integer<br />// Ids as their name.  These entries are also sorted in ascending order.<br />//<br />// This structure allows fast lookup by either name or number, but for any<br />// given resource entry only one form of lookup is supported, not both.<br />// This is consistant with the syntax of the .RC file and the .RES file.<br />//<br /><br />typedef struct _IMAGE_RESOURCE_DIRECTORY {<br />    DWORD   Characteristics;<br />    DWORD   TimeDateStamp;<br />    WORD    MajorVersion;<br />    WORD    MinorVersion;<br />    WORD    NumberOfNamedEntries;<br />    WORD    NumberOfIdEntries;<br />//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];<br />} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;<br /><br />#define IMAGE_RESOURCE_NAME_IS_STRING        0x80000000<br />#define IMAGE_RESOURCE_DATA_IS_DIRECTORY     0x80000000<br />//<br />// Each directory contains the 32-bit Name of the entry and an offset,<br />// relative to the beginning of the resource directory of the data associated<br />// with this directory entry.  If the name of the entry is an actual text<br />// string instead of an integer Id, then the high order bit of the name field<br />// is set to one and the low order 31-bits are an offset, relative to the<br />// beginning of the resource directory of the string, which is of type<br />// IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the<br />// low-order 16-bits are the integer Id that identify this resource directory<br />// entry. If the directory entry is yet another resource directory (i.e. a<br />// subdirectory), then the high order bit of the offset field will be<br />// set to indicate this.  Otherwise the high bit is clear and the offset<br />// field points to a resource data entry.<br />//<br /><br />typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {<br />    union {<br />        struct {<br />            DWORD NameOffset:31;<br />            DWORD NameIsString:1;<br />        };<br />        DWORD   Name;<br />        WORD    Id;<br />    };<br />    union {<br />        DWORD   OffsetToData;<br />        struct {<br />            DWORD   OffsetToDirectory:31;<br />            DWORD   DataIsDirectory:1;<br />        };<br />    };<br />} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;<br /><br />//<br />// For resource directory entries that have actual string names, the Name<br />// field of the directory entry points to an object of the following type.<br />// All of these string objects are stored together after the last resource<br />// directory entry and before the first resource data object.  This minimizes<br />// the impact of these variable length objects on the alignment of the fixed<br />// size directory entry objects.<br />//<br /><br />typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {<br />    WORD    Length;<br />    CHAR    NameString[ 1 ];<br />} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;<br /><br /><br />typedef struct _IMAGE_RESOURCE_DIR_STRING_U {<br />    WORD    Length;<br />    WCHAR   NameString[ 1 ];<br />} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;<br /><br /><br />//<br />// Each resource data entry describes a leaf node in the resource directory<br />// tree.  It contains an offset, relative to the beginning of the resource<br />// directory of the data for the resource, a size field that gives the number<br />// of bytes of data at that offset, a CodePage that should be used when<br />// decoding code point values within the resource data.  Typically for new<br />// applications the code page would be the unicode code page.<br />//<br /><br />typedef struct _IMAGE_RESOURCE_DATA_ENTRY {<br />    DWORD   OffsetToData;<br />    DWORD   Size;<br />    DWORD   CodePage;<br />    DWORD   Reserved;<br />} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;<br /><br />//<br />// Load Configuration Directory Entry<br />//<br /><br />typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY {<br />    DWORD   Characteristics;<br />    DWORD   TimeDateStamp;<br />    WORD    MajorVersion;<br />    WORD    MinorVersion;<br />    DWORD   GlobalFlagsClear;<br />    DWORD   GlobalFlagsSet;<br />    DWORD   CriticalSectionDefaultTimeout;<br />    DWORD   DeCommitFreeBlockThreshold;<br />    DWORD   DeCommitTotalFreeThreshold;<br />    PVOID   LockPrefixTable;<br />    DWORD   MaximumAllocationSize;<br />    DWORD   VirtualMemoryThreshold;<br />    DWORD   ProcessHeapFlags;<br />    DWORD   ProcessAffinityMask;<br />    WORD    CSDVersion;<br />    WORD    Reserved1;<br />    PVOID   EditList;<br />    DWORD   Reserved[ 1 ];<br />} IMAGE_LOAD_CONFIG_DIRECTORY, *PIMAGE_LOAD_CONFIG_DIRECTORY;<br /><br /><br />//<br />// WIN CE Exception table format<br />//<br /><br />typedef struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {<br />    DWORD FuncStart;<br />    DWORD PrologLen : 8;<br />    DWORD FuncLen : 22;<br />    DWORD ThirtyTwoBit : 1;<br />    DWORD ExceptionFlag : 1;<br />} IMAGE_CE_RUNTIME_FUNCTION_ENTRY, * PIMAGE_CE_RUNTIME_FUNCTION_ENTRY;<br /><br />//<br />// Debug Format<br />//<br /><br />typedef struct _IMAGE_DEBUG_DIRECTORY {<br />    DWORD   Characteristics;<br />    DWORD   TimeDateStamp;<br />    WORD    MajorVersion;<br />    WORD    MinorVersion;<br />    DWORD   Type;<br />    DWORD   SizeOfData;<br />    DWORD   AddressOfRawData;<br />    DWORD   PointerToRawData;<br />} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;<br /><br />#define IMAGE_DEBUG_TYPE_UNKNOWN          0<br />#define IMAGE_DEBUG_TYPE_COFF             1<br />#define IMAGE_DEBUG_TYPE_CODEVIEW         2<br />#define IMAGE_DEBUG_TYPE_FPO              3<br />#define IMAGE_DEBUG_TYPE_MISC             4<br />#define IMAGE_DEBUG_TYPE_EXCEPTION        5<br />#define IMAGE_DEBUG_TYPE_FIXUP            6<br />#define IMAGE_DEBUG_TYPE_OMAP_TO_SRC      7<br />#define IMAGE_DEBUG_TYPE_OMAP_FROM_SRC    8<br />#define IMAGE_DEBUG_TYPE_BORLAND          9<br />#define IMAGE_DEBUG_TYPE_RESERVED10       10<br /><br /><br />typedef struct _IMAGE_COFF_SYMBOLS_HEADER {<br />    DWORD   NumberOfSymbols;<br />    DWORD   LvaToFirstSymbol;<br />    DWORD   NumberOfLinenumbers;<br />    DWORD   LvaToFirstLinenumber;<br />    DWORD   RvaToFirstByteOfCode;<br />    DWORD   RvaToLastByteOfCode;<br />    DWORD   RvaToFirstByteOfData;<br />    DWORD   RvaToLastByteOfData;<br />} IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;<br /><br />#define FRAME_FPO       0<br />#define FRAME_TRAP      1<br />#define FRAME_TSS       2<br />#define FRAME_NONFPO    3<br /><br />typedef struct _FPO_DATA {<br />    DWORD       ulOffStart;             // offset 1st byte of function code<br />    DWORD       cbProcSize;             // # bytes in function<br />    DWORD       cdwLocals;              // # bytes in locals/4<br />    WORD        cdwParams;              // # bytes in params/4<br />    WORD        cbProlog : 8;           // # bytes in prolog<br />    WORD        cbRegs   : 3;           // # regs saved<br />    WORD        fHasSEH  : 1;           // TRUE if SEH in func<br />    WORD        fUseBP   : 1;           // TRUE if EBP has been allocated<br />    WORD        reserved : 1;           // reserved for future use<br />    WORD        cbFrame  : 2;           // frame type<br />} FPO_DATA, *PFPO_DATA;<br />#define SIZEOF_RFPO_DATA 16<br /><br /><br />#define IMAGE_DEBUG_MISC_EXENAME    1<br /><br />typedef struct _IMAGE_DEBUG_MISC {<br />    DWORD       DataType;               // type of misc data, see defines<br />    DWORD       Length;                 // total length of record, rounded to four<br />                                        // byte multiple.<br />    BOOLEAN     Unicode;                // TRUE if data is unicode string<br />    BYTE        Reserved[ 3 ];<br />    BYTE        Data[ 1 ];              // Actual data<br />} IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC;<br /><br />//<br />// Debugging information can be stripped from an image file and placed<br />// in a separate .DBG file, whose file name part is the same as the<br />// image file name part (e.g. symbols for CMD.EXE could be stripped<br />// and placed in CMD.DBG).  This is indicated by the IMAGE_FILE_DEBUG_STRIPPED<br />// flag in the Characteristics field of the file header.  The beginning of<br />// the .DBG file contains the following structure which captures certain<br />// information from the image file.  This allows a debug to proceed even if<br />// the original image file is not accessable.  This header is followed by<br />// zero of more IMAGE_SECTION_HEADER structures, followed by zero or more<br />// IMAGE_DEBUG_DIRECTORY structures.  The latter structures and those in<br />// the image file contain file offsets relative to the beginning of the<br />// .DBG file.<br />//<br />// If symbols have been stripped from an image, the IMAGE_DEBUG_MISC structure<br />// is left in the image file, but not mapped.  This allows a debugger to<br />// compute the name of the .DBG file, from the name of the image in the<br />// IMAGE_DEBUG_MISC structure.<br />//<br /><br />typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {<br />    WORD        Signature;<br />    WORD        Flags;<br />    WORD        Machine;<br />    WORD        Characteristics;<br />    DWORD       TimeDateStamp;<br />    DWORD       CheckSum;<br />    DWORD       ImageBase;<br />    DWORD       SizeOfImage;<br />    DWORD       NumberOfSections;<br />    DWORD       ExportedNamesSize;<br />    DWORD       DebugDirectorySize;<br />    DWORD       SectionAlignment;<br />    DWORD       Reserved[2];<br />} IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;<br /><br />#define IMAGE_SEPARATE_DEBUG_SIGNATURE 0x4449<br />#define IMAGE_SEPARATE_DEBUG_FLAGS_MASK 0x8000<br />#define IMAGE_SEPARATE_DEBUG_MISMATCH   0x8000  // when DBG was updated, the<br />                                                // old checksum didn't match.<br /><br />//<br />//  The .arch section is made up of headers, each describing an amask position/value<br />//  pointing to an array of IMAGE_ARCHITECTURE_ENTRY's.  Each &quot;array&quot; (both the header<br />//  and entry arrays) are terminiated by a quadword of 0xffffffffL.<br />//<br />//  NOTE: There may be quadwords of 0 sprinkled around and must be skipped.<br />//<br /><br />typedef struct _ImageArchitectureHeader {<br />    unsigned int AmaskValue: 1;                 // 1 -&gt; code section depends on mask bit<br />                                                // 0 -&gt; new instruction depends on mask bit<br />    int :7;                                     // MBZ<br />    unsigned int AmaskShift: 8;                 // Amask bit in question for this fixup<br />    int :16;                                    // MBZ<br />    DWORD FirstEntryRVA;                        // RVA into .arch section to array of ARCHITECTURE_ENTRY's<br />} IMAGE_ARCHITECTURE_HEADER, *PIMAGE_ARCHITECTURE_HEADER;<br /><br />typedef struct _ImageArchitectureEntry {<br />    DWORD FixupInstRVA;                         // RVA of instruction to fixup<br />    DWORD NewInst;                              // fixup instruction (see alphaops.h)<br />} IMAGE_ARCHITECTURE_ENTRY, *PIMAGE_ARCHITECTURE_ENTRY;<br /><br />#include &quot;poppack.h&quot;                // Back to the initial value<br /><br />// The following structure defines the new import object.  Note the values of the first two fields,<br />// which must be set as stated in order to differentiate old and new import members.<br />// Following this structure, the linker emits two null-terminated strings used to recreate the<br />// import at the time of use.  The first string is the import's name, the second is the dll's name.<br /><br />#define IMPORT_OBJECT_HDR_SIG2  0xffff<br /><br />typedef struct IMPORT_OBJECT_HEADER {<br />    WORD    Sig1;                       // Must be IMAGE_FILE_MACHINE_UNKNOWN<br />    WORD    Sig2;                       // Must be IMPORT_OBJECT_HDR_SIG2.<br />    WORD    Version;<br />    WORD    Machine;<br />    DWORD   TimeDateStamp;              // Time/date stamp<br />    DWORD   SizeOfData;                 // particularly useful for incremental links<br /><br />    union {<br />        WORD    Ordinal;                // if grf &amp; IMPORT_OBJECT_ORDINAL<br />        WORD    Hint;<br />    };<br /><br />    WORD    Type : 2;                   // IMPORT_TYPE<br />    WORD    NameType : 3;               // IMPORT_NAME_TYPE<br />    WORD    Reserved : 11;              // Reserved. Must be zero.<br />} IMPORT_OBJECT_HEADER;<br /><br />typedef enum IMPORT_OBJECT_TYPE<br />{<br />    IMPORT_OBJECT_CODE = 0,<br />    IMPORT_OBJECT_DATA = 1,<br />    IMPORT_OBJECT_CONST = 2,<br />} IMPORT_OBJECT_TYPE;<br /><br />typedef enum IMPORT_OBJECT_NAME_TYPE<br />{<br />    IMPORT_OBJECT_ORDINAL = 0,          // Import by ordinal<br />    IMPORT_OBJECT_NAME = 1,             // Import name == public symbol name.<br />    IMPORT_OBJECT_NAME_NO_PREFIX = 2,   // Import name == public symbol name skipping leading ?, @, or optionally _.<br />    IMPORT_OBJECT_NAME_UNDECORATE = 3,  // Import name == public symbol name skipping leading ?, @, or optionally _<br />                                        // and truncating at first @<br />} IMPORT_OBJECT_NAME_TYPE;<br /><br />//<br />// End Image Format<br />//<br /></div></div>
    <div class="meta">Posted on 2002-09-23 12:29:28 by slop</div>
   </div>
  </div>
 </body>
</html>