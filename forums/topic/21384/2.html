<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>NASM and related arguments - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=21384" />
  <link rel="prev" href="../?id=21384&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=21384">NASM and related arguments</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=21384&amp;page=1" style="">&laquo;</a><a href="../?id=21384&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="21384" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-162602">
    <div class="subject"><a href="#post-162602">Re: NASM and related arguments</a></div>
    <div class="body"><div class="quote"><br />I really don&#39;t see any syntax as &quot;official&quot;... everyone has their own flavor... and that shouldn&#39;t be pushed onto others.<br /></div><br /><br />Well, as Intel developed the instruction set, they certainly have the right to define the &quot;official&quot; syntax. Of course, people do *not* have to adhere or use the official syntax. Indeed, there are good reasons for using a radically different syntax (else why would I have given HLA such a radically different syntax?). But you can&#39;t have it both ways -- change the syntax for whatever reason and then try to claim that you&#39;re following the official (or Intel) syntax.<br />Cheers,<br />Randy Hyde<br /></div>
    <div class="meta">Posted on 2005-07-29 10:40:53 by rhyde</div>
   </div>
   <div class="post" id="post-162603">
    <div class="subject"><a href="#post-162603">Re: NASM and related arguments</a></div>
    <div class="body"><div class="quote"><br />I think I saw a sentence along the lines of &quot;modelled after the intel {standard,syntax,whatever}&quot; somewhere, sometime, in the NASM documentation. Which would indicate that it&#39;s not the `official intel syntax`, but a derivate :)<br /><br /></div><br /><br />Largely, what most people think when they use the term &quot;Intel syntax&quot; is (1) the same instruction mnemonics, and (2) the &quot;dest, src&quot; operand ordering. Almost every &quot;Intel Syntax Compatible&quot; assembler (with the exception of MASM) deviates completely in every other sense.<br /><br />If an assembler follows the &quot;Intel syntax&quot;, this says that you can take *any* Intel syntax assembly source file and compile it using that assembler. This just isn&#39;t the case with all the so-called &quot;Intel syntax&quot; assemblers out there (technically, it&#39;s not even the case with MASM, but MASM comes the closest).<br /><br />One of the most fundamental features of the &quot;Intel syntax&quot; was typed identifiers. If an assembler cannot figure out that &quot;ThisIdentifier&quot; is a memory variable, constant, or something else, on the basis of information kept in the symbol table, then it&#39;s *not* an Intel syntax assembler. That is, if your assembler requires brackets to denote memory addressing, it is *not* an Intel syntax assembler. Similarly, if your assembler doesn&#39;t require &quot;offset&quot; to tell the assembler to use a variable&#39;s address as a constant in an expression, it is *not* an Intel Syntax assembler. Likewise, if your assembler doesn&#39;t use phrases like &quot;byte ptr&quot; or &quot;word ptr&quot; to coerce the size of a memory operand, it is *not* an Intel Syntax assembler. If your assembler doesn&#39;t use all the original Intel directives (e.g., &quot;db&quot;, &quot;dw&quot;, etc., IIRC), it is *not* an Intel Syntax assembler.<br /><br />Again, there have been no true &quot;Intel Syntax&quot; assemblers since Intel removed ASM386 from the market, but MASM does come pretty close. TASM comes in second (if you ignore &quot;ideal mode&quot;). Everyone else follows way off in the distance.<br />Cheers,<br />Randy Hyde<br /></div>
    <div class="meta">Posted on 2005-07-29 10:47:33 by rhyde</div>
   </div>
   <div class="post" id="post-162604">
    <div class="subject"><a href="#post-162604">Re: NASM and related arguments</a></div>
    <div class="body">You dont like the term mnemonic sintaxis uh? ;), not intel, not amd sintaxis, but mnemonic.</div>
    <div class="meta">Posted on 2005-07-29 10:48:33 by rea</div>
   </div>
   <div class="post" id="post-162605">
    <div class="subject"><a href="#post-162605">Re: NASM and related arguments</a></div>
    <div class="body"><div class="quote"><br />You dont like the term mnemonic sintaxis uh? ;), not intel, not amd sintaxis, but mnemonic.<br /></div><br /><br />Well, in computer science the phrase &quot;syntax&quot; has a very specific meaning. It means we have a grammar (of some sort) that describes which strings are legal in a language and which are not (a &quot;string&quot;, in computer theory, corresponds to a whole program source file in this particular case).<br /><br />We can certainly define a &quot;grammar&quot; via a set of regular expressions that specify the mnemonics to use. And most so-called &quot;intel-compatible&quot; assemblers would accept that grammar. <br /><br />However, when one speaks of an &quot;Intel-compatible&quot; syntax, the only reason for the importance of such a term is because someone is asking &quot;if I write my source code in an &#39;Intel-compatible syntax&#39; mode, how much work is involved in getting the code to compile with a less compliant assembler?&quot;&nbsp; Sure, not having to change all the mnemonics helps. Likewise, not having to change the order of the instructions helps. But with an assembler like NASM or FASM, you wind up changing a signficant number of lines of source code in order to get it into an Intel compatible format (or convert an Intel compatible format to NASM/FASM). <br /><br />Source code compatibility is *the* reason we&#39;d like to see Intel Syntax in an assembler. This gives a product (like MASM) a marketing advantage when there is a huge body of Intel Syntax source code laying around. It&#39;s also helpful if an assembler uses Intel syntax when reading through the Intel manuals and trying to use that information in your programs.<br /><br />Alas, like monitor sizes, disk drive sizes, &quot;Intel Inside&quot;, and so on, once the &quot;marketing people&quot; get their hands on a term like &quot;Intel Syntax&quot; it gets perverted all to Hell. &lt;&lt;People want &quot;Intel Syntax&quot;, so we&#39;ll use that term to describe our product even if we&#39;re not strictly Intel Syntax compatible&gt;&gt;&nbsp; You get the idea.<br /><br />The sad part, as many people know, is that Intel Syntax is not without its blemishes. There are good reasons for producing an assembler that is *not* Intel syntax compatible. Too bad various assembler authors try to hide behind a false claim of &quot;Intel Syntax&quot; rather than celebrating their differences from Intel syntax.&nbsp; Ultimately, this causes confusion for beginners and achieves very little else.<br />Cheers,<br />Randy Hyde<br /></div>
    <div class="meta">Posted on 2005-07-29 11:04:28 by rhyde</div>
   </div>
   <div class="post" id="post-162653">
    <div class="subject"><a href="#post-162653">Re: NASM and related arguments</a></div>
    <div class="body">I must admit, I have never seen the differences as anything else than parser dictated considerations based on the authors preferences and how powerful their parser was.<br /><br />GAS uses AT&amp;T which is a major shift from most x86 assemblers in operand order but the rest have varying degrees of similarity to Intel syntax as defined by the old Intel assemblers. That MASM is the closest to the old Intel syntax probably has something to do with it having been around since 1981 and this produces a massive body of code that is written in this format.<br /><br />NASM is a portable assembler and it has no reason to be Intel syntax as it can be used on non x86 platforms so I tend to refer to it as NASM syntax. FASM is similar with it bracketing requirements and both follow the TASM ideal mode requirement of bracketing named memory operands.<br /><br />Randy is certainly correct here in that the actual notation dictates what is the closest to historical Intel syntax and apart from the advertising value, none of the others properly do this as they have their own notation and should claim it that way, not make claims that are not correct.<br /><br />Regards,<br /><br />hutch at movsd dot com</div>
    <div class="meta">Posted on 2005-07-30 12:50:39 by hutch--</div>
   </div>
   <div class="post" id="post-162692">
    <div class="subject"><a href="#post-162692">Re: NASM and related arguments</a></div>
    <div class="body"><div class="quote"><br />NASM is a portable assembler and it has no reason to be Intel syntax as it can be used on non x86 platforms so I tend to refer to it as NASM syntax.<br /></div><br />While the assembler is portable to basically any platform with a C compiler, it still only assembles x86 code, though.</div>
    <div class="meta">Posted on 2005-08-01 08:52:42 by f0dder</div>
   </div>
   <div class="post" id="post-163267">
    <div class="subject"><a href="#post-163267">Re: NASM and related arguments</a></div>
    <div class="body">I guess if I remember correctly, there was a version not ready?? at all for ARM?? I dont remember exactly wich member of the board point it... Ultrano???? tought I guess he switch to other one... peraphs.</div>
    <div class="meta">Posted on 2005-08-15 01:31:54 by rea</div>
   </div>
   <div class="post" id="post-163282">
    <div class="subject"><a href="#post-163282">Re: NASM and related arguments</a></div>
    <div class="body">Yes, there&#39;s a NASM port, called &quot;NARM&quot;, assembling ARM code. Most funcs of NASM were enabled, but macros were not available. And it did produce wrong code from time to time. <br />Since my other option was to lose my sanity with GAS, I made a third option - an average-power preprocessor. <br />Making a custom preprocessor is easy, and has <strong>lot and lots</strong> of pros. You modify and add to the HLL syntax in the way it&#39;s best for you, keep your sanity by staying off the GAS syntax, and if you want some powerful macro - you implement it in the preprocessor&#39;s code, not as a script. <br />The only cons is that if you get an error on some line, its number won&#39;t match. The real assembler will say the error is on line 3176, while the error will be at line 1704 on your custom.asm . This is the reason I haven&#39;t made a powerful MASM-overlay. </div>
    <div class="meta">Posted on 2005-08-15 06:14:27 by Ultrano</div>
   </div>
   <div class="post" id="post-163294">
    <div class="subject"><a href="#post-163294">Re: NASM and related arguments</a></div>
    <div class="body">I remember modificating the preprocesor of nasm for suport directly structs/unions (in some way... lol), can lead to more fast assembling (half time) when you include for example nagoa.inc. I have passed much time figuring what I will do in the future, but best to choose one of the options tha I have now :D...</div>
    <div class="meta">Posted on 2005-08-15 10:39:29 by rea</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=21384&amp;page=1" style="">&laquo;</a><a href="../?id=21384&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="21384" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>