<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Complex Rigid MultiBody Dynamics (yay) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=21629" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=21629">Complex Rigid MultiBody Dynamics (yay)</a></p>
   <div class="post" id="post-163271">
    <div class="subject"><a href="#post-163271">Complex Rigid MultiBody Dynamics (yay)</a></div>
    <div class="body">Just a teaser - I&#39;m messing with it..<br /><br /><pre><code><br />ifndef RigidBodyID<br />RigidBodyID equ 00d0d0h<br /><br />;=========================================================================<br />;Title			&nbsp; : RigidBody<br />;Description	&nbsp; : Class for a 3D rigid body with 4th order Runge-Kutta integrator.<br />;Original Author&nbsp; : Richard Chaney<br />;Original Version : 4.0 - June 2000<br />;Current&nbsp; Author&nbsp; : Evil Homer<br />;Current&nbsp; Version : 1.0 - July 2005<br />;=========================================================================<br /><br />;=========================================================================<br />;Notes:<br />;	To set up a rigid body do as follows :<br />;	1.&nbsp; Call &#39;setGravity&#39; to set RigidBody_g (gravity is always along the y axis)<br />;	2.&nbsp; Create a rigid primitive with &#39;setBox&#39;, &#39;setCylinder&#39; or &#39;setSphere&#39;.<br />;	3.&nbsp; Join primitives together if needed with &#39;combine&#39;.<br />;	4.&nbsp; Call &#39;diagonalise&#39; to make moment of inertia matrix diagonal. It also initialise various bits.<br />;	5.&nbsp; Don&#39;t forget to transform your graphical object and collision detection object by the transform :<br />;		newCoord = diagRotPos * oldCoord + diagLinPos<br />;	6.&nbsp; Call &#39;initialise&#39; with initial parameters<br />;<br />;&nbsp;  Bodies can be integrated with Euler or 4th order Runge-Kutta. <br />;	Runge-Kutta is recommended as it is much more accurate for a given step size, <br />;	however the step takes 4 times as long to calculate.<br />;<br />;	The following Steps must Always be performed, regardless<br />;	of which Integration method we choose to use...<br />;<br />;	1.&nbsp; Call &#39;setStepSize&#39; to set size of step (applies to all rigid bodies)<br />;	2.&nbsp; Call &#39;RKInit&#39;<br />;	3.&nbsp; Use linPos, linVel, rotPos and rotVel to determine forces on body.<br />;		Add forces and torques with provided functions, or add them to linForce and rotForce directly.<br />;	4.&nbsp; Calculate constraint forces if necessary and add to linForce and rotForce<br />;<br />;	To update it with Euler method do :<br />;	5.&nbsp; Call &#39;eulerStep&#39;<br />;	6.&nbsp; Draw body at linPos, linVel, rotPos and rotVel.<br />;<br />;	To update it with Runge-Kutta method do :<br />;	5.&nbsp; Call &#39;RKStep1&#39;<br />;	6.&nbsp; Repeat step 2 and 3.<br />;	7.&nbsp; Call &#39;RKStep2&#39;<br />;	8.&nbsp; Repeat step 2 and 3.<br />;	9.&nbsp; Call &#39;RKStep3&#39;<br />;	10. Repeat step 2 and 3.<br />;	11. Call &#39;RKStep4&#39;<br />;	12. Draw body at linPos, linVel, rotPos and rotVel.<br />;<br />;	To go back to the previous position after a step is made call &#39;undo&#39;. <br />;	This is useful when a collision is detected.<br />;=========================================================================<br /><br />;include Matrix.inc<br /><br /><br />.data<br />Vec3 struct<br />	X REAL4 ?<br />	Y REAL4 ?<br />	Z REAL4 ?<br />Vec3 ends<br />Vec3_mac macro pOut, pA, pB, fS<br />;Out = A + B * scalar<br />	fld pB.X<br />	fmul fS<br />	fadd pA.X<br />	fstp pOut.X<br />	fld pB.Y<br />	fmul fS<br />	fadd pA.Y<br />	fstp pOut.Y<br />	fld pB.Z<br />	fmul fS<br />	fadd pA.Z<br />	fstp pOut.Z	<br />endm<br /><br /><br />__LoadFloat3 macro blah<br />	fld .X<br />	fld .Y<br />	fld .Z<br />endm<br /><br />Quaternion struct<br />	X REAL4 ?<br />	Y REAL4 ?<br />	Z REAL4 ?<br />	W REAL4 ?<br />Quaternion ends<br /><br />Mat33 struct<br />M0 REAL4 ?<br />M1 REAL4 ?<br />M2 REAL4 ?<br />M3 REAL4 ?<br />M4 REAL4 ?<br />M5 REAL4 ?<br />M6 REAL4 ?<br />M7 REAL4 ?<br />M8 REAL4 ?<br />Mat33 ends<br /><br />Mat33_mac macro pTarget,pSource1,pSource2,fS<br />;target = A + B * scalar<br />	push eax<br />	push ebx<br />	push ecx<br />	push esi<br /><br />	lea eax,pTarget<br />	mov ebx,pSource1<br />	mov esi,pSource2<br />	xor ecx,ecx<br />	.while ecx&lt;9<br />		push ecx<br />		shl ecx,2<br />		fld&nbsp; REAL4 ptr<br />		fmul fs<br />		fadd REAL4 ptr<br />		fstp REAL4 ptr<br />		pop ecx<br />		inc ecx<br />	.endw<br />	<br /><br />	pop esi<br />	pop ecx<br />	pop ebx<br />	pop eax<br />endm<br />; ??????????????????????????????????????????????????????????????????????????????????????????????????<br />;DEFINE SOME GLOBALS (&quot;CLASS STATICS&quot;)<br />; ??????????????????????????????????????????????????????????????????????????????????????????????????<br />r4_0_0f	 REAL4 0.0f<br />r4_half	 REAL4 0.50f<br />r4_3_0f&nbsp; REAL4 3.0f<br />r4_5_0f	 REAL4 5.0f<br />r4_12_0f REAL4 12.0f<br />; gravity, y accel = -g<br />RigidBody_g		REAL4 0.0f<br /><br />;precalculated Step sizes (for speedup)<br />RigidBody_RKh	REAL4 0.0f<br />RigidBody_RKh2	REAL4 0.0f<br />RigidBody_RKh4	REAL4 0.0f<br />RigidBody_RKh6	REAL4 0.0f<br /><br />.code<br />; ??????????????????????????????????????????????????????????????????????????????????????????????????<br />; DEFINE THE RIGIDBODY CLASS OBJECT<br />; ??????????????????????????????????????????????????????????????????????????????????????????????????<br />Object RigidBody,RigidBodyID,Primer<br /><br />; Runge-Kutta integration stuff<br />&nbsp; &nbsp; DefineVariable linPos0,Vec3,{}<br />&nbsp; &nbsp; DefineVariable linVel0,Vec3,{}<br />&nbsp; &nbsp; DefineVariable rotVel0,Vec3,{}<br />&nbsp; &nbsp; DefineVariable qRotPos0,Quaternion,{}<br />&nbsp; &nbsp; DefineVariable rotPos0,Mat33,{}<br />&nbsp; &nbsp; DefineVariable linVel1,Vec3,{}<br />&nbsp; &nbsp; DefineVariable rotVel1,Vec3,{}<br />&nbsp; &nbsp; DefineVariable linAcc1,Vec3,{}<br />&nbsp; &nbsp; DefineVariable rotAcc1,Vec3,{}<br />&nbsp; &nbsp; DefineVariable linVel2,Vec3,{}<br />&nbsp; &nbsp; DefineVariable rotVel2,Vec3,{}<br />&nbsp; &nbsp; DefineVariable linAcc2,Vec3,{}<br />&nbsp; &nbsp; DefineVariable rotAcc2,Vec3,{}<br />&nbsp; &nbsp; DefineVariable linVel3,Vec3,{}<br />&nbsp; &nbsp; DefineVariable rotVel3,Vec3,{}<br />&nbsp; &nbsp; DefineVariable linAcc3,Vec3,{}<br />&nbsp; &nbsp; DefineVariable rotAcc3,Vec3,{}<br /><br />; properties of body<br />&nbsp; &nbsp; DefineVariable mass,REAL4<br />&nbsp; &nbsp; DefineVariable oneOverMass,REAL4<br />	;-mass * g<br />&nbsp; &nbsp; DefineVariable minusMG,REAL4<br />	;centre of mass (in old body coords)<br />&nbsp; &nbsp; DefineVariable cOfM,Vec3,{}<br /><br />	; Ix = sum of mx<br />&nbsp; &nbsp; DefineVariable Ix,REAL4<br />&nbsp; &nbsp; DefineVariable Iy,REAL4<br />&nbsp; &nbsp; DefineVariable Iz,REAL4<br />	;Ixx = sum of m(y^2 + z^2)<br />&nbsp; &nbsp; DefineVariable Ixx,REAL4<br />&nbsp; &nbsp; DefineVariable Iyy,REAL4<br />&nbsp; &nbsp; DefineVariable Izz,REAL4<br />	; Ixy = sum of mxy<br />&nbsp; &nbsp; DefineVariable Ixy,REAL4<br />&nbsp; &nbsp; DefineVariable Iyz,REAL4<br />&nbsp; &nbsp; DefineVariable Izx,REAL4<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;these are in old body coords<br /><br />	; transform from old body coords to diagonalised body coords.<br />&nbsp; &nbsp; DefineVariable diagRotPos,Mat33,{}<br />&nbsp; &nbsp; DefineVariable diagLinPos,Vec3,{};&nbsp;  Rd = diagRotPos * Rb + diagLinPos<br />&nbsp; &nbsp; DefineVariable diagIxx,REAL4<br />&nbsp; &nbsp; DefineVariable oneOverDiagIxx,REAL4;transformed moment of inertia (diagonalised body coords)<br />&nbsp; &nbsp; DefineVariable diagIyy,REAL4<br />&nbsp; &nbsp; DefineVariable oneOverDiagIyy,REAL4;also 1 / Ixx * h for Euler integrater<br />&nbsp; &nbsp; DefineVariable diagIzz,REAL4<br />&nbsp; &nbsp; DefineVariable oneOverDiagIzz,REAL4;<br />&nbsp; &nbsp; DefineVariable diagIyyMinusIzzOverIxx,REAL4;<br />&nbsp; &nbsp; DefineVariable diagIzzMinusIxxOverIyy,REAL4;<br />&nbsp; &nbsp; DefineVariable diagIxxMinusIyyOverIzz,REAL4;<br /><br />	; (Iyy - Izz) / Ixx * h, etc..&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; DefineVariable diagIzzMinusIyy,REAL4;<br />&nbsp; &nbsp; DefineVariable diagIxxMinusIzz,REAL4;<br />&nbsp; &nbsp; DefineVariable diagIyyMinusIxx,REAL4;<br />	; linear damping (-ve and multiplied by mass)<br />&nbsp; &nbsp; DefineVariable linKD,REAL4<br />	;Angular damping (-ve and multiplied by Ixx, etc..)<br />&nbsp; &nbsp; DefineVariable rotKDx, REAL4<br />&nbsp; &nbsp; DefineVariable rotKDy, REAL4&nbsp; &nbsp; <br />&nbsp; &nbsp; DefineVariable rotKDz,REAL4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br /><br /><br />; current state of body<br />	;linear position and velocity of centre of mass (Rd = 0). (world coords)<br />	DefineVariable linPos,Vec3,{}<br />	DefineVariable linVel,Vec3,{}<br />	<br />	;rotational position.. transform from diagonalised body coord to world coords is <br />	;Rw = rotPos * Rd + linPos<br />	DefineVariable rotPos,Mat33,{}<br />	;quaternion of above matrix (matrix and quaternion are kept the same)									&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; DefineVariable qRotPos,Quaternion,{}; <br />	;rotational velocity (diagonalised body coords)&nbsp; &nbsp; <br />	DefineVariable rotVel,Vec3,{}<br /><br />; current forces on body<br />	DefineVariable linForce,Vec3,{}<br />	DefineVariable rotForce,Vec3,{}<br /><br />; functions to set up rigid body mass distribution<br />	StaticMethod setBox,REAL4,REAL4,REAL4,REAL4;(float xRadius, float yRadius, float zRadius, float mass);<br />&nbsp; &nbsp; StaticMethod setCylinder,REAL4,REAL4,REAL4;(float radius, float height, float mass);<br />&nbsp; &nbsp; StaticMethod setSphere,REAL4,REAL4 ;(float radius, float mass);<br />&nbsp; &nbsp; StaticMethod clear<br />;&nbsp; &nbsp; StaticMethod combine,Pointer,Pointer,Pointer;pother:ptr RigidBody, protPos:ptr Mat33, plinPos:ptr Vec3<br /><br />; functions for initialising rigid body<br />&nbsp; &nbsp; StaticMethod diagonalise<br />&nbsp; &nbsp; RedefineMethod Init,Pointer,Pointer,Pointer,REAL4,REAL4; poLinPos, poLinVel, poQRotPos, poRotVel,flinKD, frotKD<br />	StaticMethod setGravity,REAL4<br />	StaticMethod setStepSize,REAL4<br /><br />; functions to update from one frame to another<br />&nbsp; &nbsp; StaticMethod RKInit<br />&nbsp; &nbsp; StaticMethod eulerStep<br />&nbsp; &nbsp; StaticMethod RKStep1<br />&nbsp; &nbsp; StaticMethod RKStep2<br />&nbsp; &nbsp; StaticMethod RKStep3<br />&nbsp; &nbsp; StaticMethod RKStep4<br />&nbsp; &nbsp; StaticMethod undo<br /><br />; functions to add force and torque<br />	StaticMethod addBodyTorque,Pointer<br />	StaticMethod addWorldTorque,Pointer<br />	StaticMethod addWorldWorldForce,Pointer,Pointer	;pforce,ppos<br />	StaticMethod addWorldBodyForce,Pointer,Pointer	;pforce,ppos<br />	StaticMethod addBodyBodyForce,Pointer,Pointer	;pforce,ppos<br /><br />; functions to get current position and velocity of points<br />	StaticMethod findWorldPos,Pointer,Pointer;pbodyPos, pworldPos<br />	StaticMethod findBodyPos,Pointer,Pointer;pWorldPos, pbodyPos<br />	StaticMethod findBodyWorldVel,Pointer,Pointer;pbodyPos, pworldVel<br />	StaticMethod findWorldWorldVel,Pointer,Pointer;pworldPos, pworldVel<br />&nbsp; &nbsp; StaticMethod findWorldPosVel,Pointer,Pointer,Pointer;pbodyPos, pworldPos, pworldVel<br /><br />; functions for energy and momentum (for testing)<br />&nbsp; &nbsp; StaticMethod energy<br />&nbsp; &nbsp; StaticMethod momentum,Pointer,Pointer	;plin, prot<br />ObjectEnd<br />; ??????????????????????????????????????????????????????????????????????????????????????????????????<br />; ??????????????????????????????????????????????????????????????????????????????????????????????????<br />;DEFINE THE RIGIDBODY CLASS METHODS<br />; ??????????????????????????????????????????????????????????????????????????????????????????????????<br /><br />Method RigidBody.setBox,uses esi, fxRadius:REAL4, fyRadius:REAL4, fzRadius:REAL4, fmass:REAL4<br />;=====================================================================<br />;Set the body as a rectangular box centred on the origin.<br />;xRadius, yRadius, zRadius = half the size of the box<br />;fmass = total mass<br />;=====================================================================<br />	SetObject esi	<br />	m2m .mass , fmass<br />	mov .cOfM.X,0<br />	mov .cOfM.Y,0<br />	mov .cOfM.Z,0<br />	mov .Ix,0<br />	mov .Iy,0<br />	mov .Iz,0<br />	mov .Ixy,0<br />	mov .Iyz,0<br />	mov .Izx,0	<br />	<br />;	Ixx = mass / 3.0 * (yRadius * yRadius + zRadius * zRadius);	<br />	fld fmass<br />	fld fyRadius<br />	fmul st(0),st(0)<br />	fld fzRadius<br />	fmul st(0),st(0)<br />	fadd<br />	fmul r4_3_0f<br />	fdiv<br />	fstp .Ixx<br />	<br />;	Iyy = mass / 3.0 * (zRadius * zRadius + xRadius * xRadius);<br />	fld fmass<br />	fld fzRadius<br />	fmul st(0),st(0)<br />	fld fxRadius<br />	fmul st(0),st(0)<br />	fadd<br />	fmul r4_3_0f<br />	fdiv<br />	fstp .Iyy<br /><br />;	Izz = mass / 3.0 * (xRadius * xRadius + yRadius * yRadius);<br />	fld fmass<br />	fld fxRadius<br />	fmul st(0),st(0)<br />	fld fyRadius<br />	fmul st(0),st(0)<br />	fadd<br />	fmul r4_3_0f<br />	fdiv<br />	fstp .Izz<br />MethodEnd<br /><br />; ??????????????????????????????????????????????????????????????????????????????????????????????????<br /><br />Method RigidBody.setCylinder,uses esi,fradius:REAL4, fheight:REAL4, fmass:REAL4<br />;================================================================<br />;Set the body as a cylinder centred on the origin. <br />;Cylinder goes along X axis from -height/2 to +height/2.<br />;fradius, fheight = size of cylinder<br />;fmass = total mass<br />;================================================================<br />	SetObject esi<br />	m2m .mass,fmass<br />	mov .cOfM.X,0<br />	mov .cOfM.Y,0<br />	mov .cOfM.Z,0	<br />&nbsp; &nbsp; mov .Ix,0<br />&nbsp; &nbsp; mov .Iy,0<br />&nbsp; &nbsp; mov .Iz,0&nbsp;  <br />&nbsp; &nbsp; <br />;	Ixx = mass * radius * radius / 2.0;<br />	fld fradius<br />	fmul st(0),st(0)<br />	fmul fmass<br />	fmul r4_half<br />	fstp .Ixx<br />	<br />;	Iyy = Izz = mass / 12.0 * (3 * radius * radius + height * height);<br />	fld fmass<br />	fld fradius<br />	fmul st(0),st(0)<br />	fmul r4_3_0f<br />	fld fheight<br />	fmul st(0),st(0)<br />	fadd<br />	fmul r4_12_0f<br />	fdiv<br />	fst .Iyy<br />	fstp .Izz<br />		<br />;&nbsp; &nbsp; Ixy = Iyz = Izx = 0.0;<br />	mov .Ixy,0<br />	mov .Iyz,0<br />	mov .Izx,0<br />MethodEnd<br /><br />; ??????????????????????????????????????????????????????????????????????????????????????????????????<br /><br />Method RigidBody.setSphere,uses esi,fradius:REAL4, fmass:REAL4<br />;================================================================<br />;Set the body as a sphere centred on the origin.<br />;fradius = size of sphere<br />;fmass = total mass<br />;================================================================<br />	SetObject esi<br />	m2m .mass,fmass<br />	mov .cOfM.X,0<br />	mov .cOfM.Y,0<br />	mov .cOfM.Z,0	<br />&nbsp; &nbsp; mov .Ix,0<br />&nbsp; &nbsp; mov .Iy,0<br />&nbsp; &nbsp; mov .Iz,0&nbsp;  <br /><br />;	Ixx = Iyy = Izz = mass * radius * radius * 2.0 / 5.0;<br />&nbsp; &nbsp; fld fradius<br />&nbsp; &nbsp; fmul st(0),st(0)<br />&nbsp; &nbsp; fmul fmass<br />&nbsp; &nbsp; fadd st(0),st(0)<br />&nbsp; &nbsp; fdiv r4_5_0f<br />&nbsp; &nbsp; fst .Ixx<br />&nbsp; &nbsp; fst .Iyy<br />&nbsp; &nbsp; fstp .Izz<br /><br />;&nbsp; &nbsp; Ixy = Iyz = Izx = 0.0;<br />	mov .Ixy,0<br />	mov .Iyz,0<br />	mov .Izx,0<br />MethodEnd<br /><br />; ??????????????????????????????????????????????????????????????????????????????????????????????????<br /><br />Method RigidBody.clear,uses esi<br />;==============================================<br />;Set the body as zero mass. <br />;May be useful if &#39;combine&#39; is being used.<br />;==============================================<br />	SetObject esi<br />	fld r4_0_0f	<br />	fst .mass<br />	fst .cOfM.X<br />	fst .cOfM.Y<br />	fst .cOfM.Z<br />	fst .Ix<br />	fst .Iy<br />	fst .Iz	<br />	fst .Ixx<br />	fst .Iyy<br />	fst .Izz<br />	fst .Ixy<br />	fst .Iyz<br />	fstp .Izx<br />MethodEnd<br /><br />; ??????????????????????????????????????????????????????????????????????????????????????????????????<br /><br /><br />Vec3Transform proc pDest,pr, protPos, plinPos<br />;Transform a point to a new coords system.<br />;		pDest:pVec3					 - output vec3<br />;&nbsp; &nbsp; &nbsp;  pr:pVec3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  -&nbsp;  point in coord system 1<br />;&nbsp; &nbsp; &nbsp;  protPos:pMat33&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;  rotation from system 1 to 2<br />;&nbsp; &nbsp; &nbsp;  plinPos:pVec3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;  translation from system 1 to 2<br />;<br /><br />	mov eax,pr<br />	mov ebx,protPos<br />	mov ecx,plinPos<br />	mov edi,pDest<br /><br />;	x = r.x * rotPos.m[0] + r.y * rotPos.m[1] + r.z * rotPos.m[2] + linPos.x;<br />	fld .Vec3.X<br />	fmul .Mat33.M0<br />	fld .Vec3.Y<br />	fmul .Mat33.M1<br />	fadd<br />	fld .Vec3.Z<br />	fmul .Mat33.M2<br />	fadd<br />	fadd .Vec3.X<br />	fstp .Vec3.X<br /><br />;	y = r.x * rotPos.m[3] + r.y * rotPos.m[4] + r.z * rotPos.m[5] + linPos.y;<br />	fld .Vec3.X<br />	fmul .Mat33.M3<br />	fld .Vec3.Y<br />	fmul .Mat33.M4<br />	fadd<br />	fld .Vec3.Z<br />	fmul .Mat33.M5<br />	fadd<br />	fadd .Vec3.Y<br />	fstp .Vec3.Y<br /><br />;	z = r.x * rotPos.m[6] + r.y * rotPos.m[7] + r.z * rotPos.m[8] + linPos.z;<br />	fld .Vec3.X<br />	fmul .Mat33.M6<br />	fld .Vec3.Y<br />	fmul .Mat33.M7<br />	fadd<br />	fld .Vec3.Z<br />	fmul .Mat33.M8<br />	fadd<br />	fadd .Vec3.Z<br />	fstp .Vec3.Z<br />	ret<br />Vec3Transform endp<br /><br />; ??????????????????????????????????????????????????????????????????????????????????????????????????<br /><br /><br /><br /><br /><br />endif<br /><br /><br /></code></pre></div>
    <div class="meta">Posted on 2005-08-15 03:43:08 by Homer</div>
   </div>
   <div class="post" id="post-163357">
    <div class="subject"><a href="#post-163357">Re: Complex Rigid MultiBody Dynamics (yay)</a></div>
    <div class="body">Decided to implement Math functions in a separate testbed (see MathTools thread), I&#39;ll come back to this.<br /></div>
    <div class="meta">Posted on 2005-08-16 16:10:11 by Homer</div>
   </div>
   <div class="post" id="post-163490">
    <div class="subject"><a href="#post-163490">Re: Complex Rigid MultiBody Dynamics (yay)</a></div>
    <div class="body">More code was implemented, see attachment if interested..<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=852" target="_blank">RigidBody.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2005-08-19 11:56:06 by Homer</div>
   </div>
   <div class="post" id="post-163493">
    <div class="subject"><a href="#post-163493">Re: Complex Rigid MultiBody Dynamics (yay)</a></div>
    <div class="body">That&#39;s pretty much all the &quot;hard stuff&quot; out of the way, except for the integrator methods, which are so very similar that I will likely try to come up with a universal method for these.. (I dislike redundancy in my code..)<br /><br />After I complete this code module, I&#39;ll be looking for people to help me write code to apply &quot;constraints&quot; to the physics objects, such as various kinds of Joints and other goodies expected of a physics engine, because the aim is to get to &quot;ragdoll&quot; stage as quickly as possible, and I have no experience with this stuff or the math behind it.<br /><br />Have a nice day :)<br /></div>
    <div class="meta">Posted on 2005-08-19 12:34:17 by Homer</div>
   </div>
   <div class="post" id="post-163623">
    <div class="subject"><a href="#post-163623">Re: Complex Rigid MultiBody Dynamics (yay)</a></div>
    <div class="body">Good stuff.<br /><br />One question though, why are ya living in the 1990&#39;s with all the FPU math ? :D <br />Go SSE on those rx^2 + rz^2 things, you&#39;ll just end up having to rewrite it anyways when your testing and the slow FPU is bottlenecking everything.</div>
    <div class="meta">Posted on 2005-08-22 20:19:32 by r22</div>
   </div>
   <div class="post" id="post-163902">
    <div class="subject"><a href="#post-163902">Re: Complex Rigid MultiBody Dynamics (yay)</a></div>
    <div class="body">Hi, I wanted to ask what the Quaternions xyzw represents when converted from a 3x3 matrix and how and why to convert?</div>
    <div class="meta">Posted on 2005-08-28 16:49:50 by inFinie</div>
   </div>
   <div class="post" id="post-163925">
    <div class="subject"><a href="#post-163925">Re: Complex Rigid MultiBody Dynamics (yay)</a></div>
    <div class="body">The quaternions represent an orientation, ie, a 3D rotation about an arbitrary axis.<br />3x3 Matrices are used to represent rotational inertia (&quot;angular velocity&quot;), from which we can derive a 3D orientation at any moment in time.. that is to say, we are also using 3x3 matrices to represent rotation in 3-space.<br />So why bother with quaternions?<br /><br />Matrices are subject to compound error from numerical drift, and quaternions are less prone to compounded error.. also, it&#39;s easier to interpolate between two quaternions than it is to interpolate between two matrices (think about that).<br /><br />We can extract a quaternion from a 3x3 rotation matrix by observing the plane equation, thus our quaternion is &quot;unit length&quot;.<br /><br />I have deliberately omitted speaking about diagonalising the moment of inertia matrix via Eigen Vectors, but I think I covered everything else :)<br /><br /></div>
    <div class="meta">Posted on 2005-08-29 00:27:55 by Homer</div>
   </div>
  </div>
 </body>
</html>