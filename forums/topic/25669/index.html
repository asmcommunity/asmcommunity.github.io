<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Need Help Optimizing Terminator-Based String Cut Proc - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25669" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25669">Need Help Optimizing Terminator-Based String Cut Proc</a></p>
   <div class="post" id="post-187318">
    <div class="subject"><a href="#post-187318">Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body">I have been working on a string &quot;cut&quot; function that goes byte by byte through a source string and copies these bytes to a destination string until it hits the specified terminator byte or a NULL byte. I personally think that my code is horrific and can be optimized but I cannot think myself through to any better. I am slightly new to programming in the assembly language, so please don&#39;t shun me as if I were a drunken guru.<br /><br />Here is the code that created using MASM syntax/procedures:<br /><br /><pre><code><br />&nbsp; &nbsp; .486<br />&nbsp; &nbsp; .model flat, stdcall&nbsp; ; 32 bit memory model<br />&nbsp; &nbsp; option casemap :none&nbsp; ; case sensitive<br /><br />&nbsp; &nbsp; .code<br /><br /><br />align 4<br /><br />tString proc src:DWORD,dst:DWORD,ter:BYTE<br /><br />&nbsp; &nbsp; push edi	;preserve edi<br /><br />&nbsp; &nbsp; xor ecx,ecx	;reset counter<br />&nbsp; &nbsp; mov edx, src	;source address<br />&nbsp; &nbsp; mov edi, dst	;destination address<br />&nbsp; &nbsp; xor eax,eax	; no stall<br />	<br />&nbsp; @@:<br />&nbsp; &nbsp; mov al, 	;move byte in edx at offset ecx to low single byte register (of ax of eax)<br />&nbsp; &nbsp; cmp al, ter	;check if terminator<br />&nbsp; &nbsp; je @B	;if it is terminator then finish up (go to last/previous label)<br />&nbsp; &nbsp; cmp al, NULL	;check if null (last chance, no string overflow)<br />&nbsp; &nbsp; je @B	;if it is null then finish up (go to last/previous label)<br />&nbsp; @@:<br />&nbsp; &nbsp; mov , al	;move byte into destination buffer at correct offset<br />&nbsp; &nbsp; inc ecx	;increase offset by one<br />&nbsp; &nbsp; jmp @B	;repeat back to previous label<br />&nbsp; @@:<br />&nbsp; &nbsp; mov BYTE PTR , 0&nbsp;  ; write terminator<br /><br />&nbsp; &nbsp; pop edi	;restore edi<br />&nbsp; &nbsp; inc ecx	;after terminator<br />&nbsp; &nbsp; mov eax, src	;move src pointer to eax<br />&nbsp; &nbsp; add eax, ecx	;add offset (after terminator) in ecx to eax<br /><br />&nbsp; &nbsp; ret	;return :P<br /><br />tString endp<br /><br />end<br /><br /></code></pre></div>
    <div class="meta">Posted on 2007-01-03 22:01:24 by NegativeNull</div>
   </div>
   <div class="post" id="post-187336">
    <div class="subject"><a href="#post-187336">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body">Before optimizing, you should add an output-buffer-size parameter and make sure you don&#39;t write more bytes than that to output.<br /></div>
    <div class="meta">Posted on 2007-01-04 04:30:19 by f0dder</div>
   </div>
   <div class="post" id="post-187338">
    <div class="subject"><a href="#post-187338">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body">Welcome NegativeNull&nbsp; :)<br />It looks like you inverted @B and @F in the loop. The two je @B should be je @F.<br />The code is not horrific at all. I was thinking about using jecxz to remove a comparison in the loop:<br /><br /><pre><code><br />tString proc src:PTR BYTE,dst:PTR BYTE,ter:BYTE<br /><br />&nbsp; &nbsp; push edi	;preserve edi<br /><br />&nbsp; &nbsp; xor ecx,ecx	;reset counter<br />&nbsp; &nbsp; mov edx, src	;source address<br />&nbsp; &nbsp; mov edi, dst	;destination address<br />&nbsp; &nbsp; xor eax, eax ; no stall<br />	<br />@@:<br />&nbsp; &nbsp; mov cl, 	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;move byte in edx at offset ecx to low single byte register (of ax of eax)<br />&nbsp; &nbsp; cmp cl, ter	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;check if terminator<br />&nbsp; &nbsp; je @F	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;if it is terminator then finish up (go to last/previous label)<br />&nbsp; &nbsp; jecxz @F<br />&nbsp; &nbsp; mov , cl	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;move byte into destination buffer at correct offset<br />&nbsp; &nbsp; inc eax	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;increase offset by one<br />&nbsp; &nbsp; jmp @B	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;repeat back to previous label<br />@@:<br />&nbsp; &nbsp; mov BYTE PTR , 0&nbsp;  ; write terminator<br /><br />&nbsp; &nbsp; pop edi	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;restore edi<br />&nbsp; &nbsp; inc eax	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;after terminator<br />&nbsp; &nbsp; mov eax, src	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;move src pointer to eax<br />&nbsp; &nbsp; add eax, eax	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;add offset (after terminator) in ecx to eax<br /><br />&nbsp; &nbsp; ret	;return :P<br />tString endp<br /></code></pre><br /><br />But it is just a micro optimization and it looks like it&#39;s actually slowing down the code. The next step would be to read four bytes at a time and process them in parallel (like in Intel&#39;s optimized strlen algo.)</div>
    <div class="meta">Posted on 2007-01-04 05:27:24 by Dr. Manhattan</div>
   </div>
   <div class="post" id="post-187355">
    <div class="subject"><a href="#post-187355">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body"><div class="quote"><br />Before optimizing, you should add an output-buffer-size parameter and make sure you don&#39;t write more bytes than that to output.<br /></div><br /><br />That would defeat my purpose however since all strings it uses are 0-terminator based and the destination buffer is expected to match at least the size of the source buffer automatically. If I added this recommended code this would in fact slow it down and add to the size.<br /><br /><div class="quote"><br />Welcome NegativeNull&nbsp; :)<br />It looks like you inverted @B and @F in the loop. The two je @B should be je @F.<br />The code is not horrific at all. I was thinking about using jecxz to remove a comparison in the loop:<br /><br /><pre><code><br />tString proc src:PTR BYTE,dst:PTR BYTE,ter:BYTE<br /><br />&nbsp; &nbsp; push edi	;preserve edi<br /><br />&nbsp; &nbsp; xor ecx,ecx	;reset counter<br />&nbsp; &nbsp; mov edx, src	;source address<br />&nbsp; &nbsp; mov edi, dst	;destination address<br />&nbsp; &nbsp; xor eax, eax ; no stall<br />	<br />@@:<br />&nbsp; &nbsp; mov cl, 	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;move byte in edx at offset ecx to low single byte register (of ax of eax)<br />&nbsp; &nbsp; cmp cl, ter	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;check if terminator<br />&nbsp; &nbsp; je @F	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;if it is terminator then finish up (go to last/previous label)<br />&nbsp; &nbsp; jecxz @F<br />&nbsp; &nbsp; mov , cl	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;move byte into destination buffer at correct offset<br />&nbsp; &nbsp; inc eax	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;increase offset by one<br />&nbsp; &nbsp; jmp @B	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;repeat back to previous label<br />@@:<br />&nbsp; &nbsp; mov BYTE PTR , 0&nbsp;  ; write terminator<br /><br />&nbsp; &nbsp; pop edi	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;restore edi<br />&nbsp; &nbsp; inc eax	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;after terminator<br />&nbsp; &nbsp; mov eax, src	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;move src pointer to eax<br />&nbsp; &nbsp; add eax, eax	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;add offset (after terminator) in ecx to eax<br /><br />&nbsp; &nbsp; ret	;return :P<br />tString endp<br /></code></pre><br /><br />But it is just a micro optimization and it looks like it&#39;s actually slowing down the code. The next step would be to read four bytes at a time and process them in parallel (like in Intel&#39;s optimized strlen algo.)<br /></div><br />I don&#39;t believe I did invert them... @B is Previous/Before and @F is Next/Forward, are they not?<br />If you look at my code the first two jumps are not meant to jump to the &quot;next&quot; label after it, it is meant to jump to the label before it in order, which would be the finalizing/end code. The next jump in the second label returns to the label before which is just a repeat.<br />The only down side to using JECXZ is that for the jump and comparison the recorded clock speed is far slower than other conditional jumps.<br /><br />Also in your code there is a slight error...<br /><pre><code>&nbsp; &nbsp; inc eax	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;after terminator<br />&nbsp; &nbsp; mov eax, src	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;move src pointer to eax<br />&nbsp; &nbsp; add eax, eax	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;add offset (after terminator) in ecx to eax</code></pre><br />If you move src into eax, it replaces the current eax value. Adding eax to eax would merely multiply eax by two.</div>
    <div class="meta">Posted on 2007-01-04 14:11:39 by NegativeNull</div>
   </div>
   <div class="post" id="post-187360">
    <div class="subject"><a href="#post-187360">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body"><div class="quote"><br />That would defeat my purpose however since all strings it uses are 0-terminator based and the destination buffer is expected to match at least the size of the source buffer automatically. If I added this recommended code this would in fact slow it down and add to the size.<br /></div><br />It would add very little to the size - slowdown might be noticable... but what&#39;s best, buffer overflows or slightly slower code? :)<br /><br />But okay, if you&#39;re NEVER going to run this on user intput, NEVER going to run it on network data, and NEVER going to run it on data read from files, then it&#39;s safe enough.<br /><br />Even if you use an output buffer that&#39;s larger than the input buffer, what happens if the input buffer actually isn&#39;t zero-terminated? *boom*<br /><br />Just some things to keep in mind!<br /></div>
    <div class="meta">Posted on 2007-01-04 15:20:05 by f0dder</div>
   </div>
   <div class="post" id="post-187362">
    <div class="subject"><a href="#post-187362">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br />That would defeat my purpose however since all strings it uses are 0-terminator based and the destination buffer is expected to match at least the size of the source buffer automatically. If I added this recommended code this would in fact slow it down and add to the size.<br /></div><br />It would add very little to the size - slowdown might be noticable... but what&#39;s best, buffer overflows or slightly slower code? :)<br /><br />But okay, if you&#39;re NEVER going to run this on user intput, NEVER going to run it on network data, and NEVER going to run it on data read from files, then it&#39;s safe enough.<br /><br />Even if you use an output buffer that&#39;s larger than the input buffer, what happens if the input buffer actually isn&#39;t zero-terminated? *boom*<br /><br />Just some things to keep in mind!<br /><br /></div><br />Buffer overflows is best, well in this case at least, seeing as there will be none. This procedure will be used in a case where there will always definitely be a zero-terminator or specified terminator.<br />The reason is that I already have an optimized function that stores a configuration file in memory and processes each line as a seperate zero-terminated string, this function is just part of the processing. It is a very important function however due to the fact it will be used to cut sections of the string to a buffer using a delimiter and return the position after that &quot;delimiter&quot; in the register EAX for later use.<br />I understood all the problems of buffer overflows before making this function and they are the least of my worries. I need optimized code that can do this seemingly small but largely important task in minimal time in order to allow my dynamic load library to be better than it&#39;s Visual C++ sibling.</div>
    <div class="meta">Posted on 2007-01-04 15:49:31 by NegativeNull</div>
   </div>
   <div class="post" id="post-187363">
    <div class="subject"><a href="#post-187363">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body">Good, then it&#39;s obvious to everybody that this function shouldn&#39;t be a generic-use function, and we can move on to the optimization part :)<br /></div>
    <div class="meta">Posted on 2007-01-04 16:34:35 by f0dder</div>
   </div>
   <div class="post" id="post-187364">
    <div class="subject"><a href="#post-187364">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body">Just a quick note that if anyone dislikes programming in MASM and is only avoiding optimization due to this you can feel free to work with FASM or NASM. I would prefer MASM or FASM, but NASM is okay too.<br />I might be porting my project to FASM if the benchmarks and filesize footprints are near or better than MASM.</div>
    <div class="meta">Posted on 2007-01-04 17:58:31 by NegativeNull</div>
   </div>
   <div class="post" id="post-187366">
    <div class="subject"><a href="#post-187366">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body">heres a modified strcpy routine&nbsp; 8)<br /><pre><code>.686<br />.MMX<br />.MODEL FLAT,STDCALL<br />OPTION CASEMAP:NONE<br />OPTION PROLOGUE:NONE<br />OPTION EPILOGUE:NONE<br />.CODE<br />;------------------------------------<br />; if (no Term found) Returns (NULL)<br />; else Returns (Pointer after Term)<br />;------------------------------------<br />;; char *p<br />;; p = NNStrCpy(&amp;Dest,&amp;Source,&#39;,&#39;);<br />;; if (p) {<br />;; }<br />; extern &quot;C&quot; char * __stdcall NNStrCpy(char *pszDest,char *pszSource,char chTerm);<br />NNStrCpy proc pszDest:PTR BYTE,pszSource:PTR BYTE,chTerm:BYTE<br />	$pszDest EQU &lt;&gt;<br />	$pszSource EQU &lt;&gt;<br />	$chTerm EQU &lt;byte ptr &gt;<br />	movzx ecx,$chTerm<br />	mov eax,$pszSource<br />	mov edx,$pszDest<br />	pxor mm2,mm2<br />	movd mm3,ecx<br />	punpcklbw mm3,mm3<br />	punpcklwd mm3,mm3<br />	punpckldq mm3,mm3<br />@@TestAlignment:<br />	test eax,7<br />	jnz @@UnAlignedOrDoByte<br />@@AlignedAt8:<br />	movq mm0,<br />	movq mm1,mm0<br />	pcmpeqb mm0,mm3<br />	packsswb mm0,mm0<br />	movd ecx,mm0<br />	movq mm0,mm1<br />	test ecx,ecx; Found Term byte?<br />	jnz @@UnAlignedOrDoByte<br />	pcmpeqb mm0,mm2<br />	packsswb mm0,mm0<br />	movd ecx,mm0<br />	test ecx,ecx; Found NULL byte?<br />	jnz @@UnAlignedOrDoByte<br />	movq ,mm1<br />	add eax,8<br />	add edx,8<br />	jmp @@AlignedAt8<br />@@UnAlignedOrDoByte:	<br />	mov cl,<br />	inc eax<br />	cmp cl,$chTerm<br />	je @@Done <br />	mov ,cl<br />	inc edx<br />	test cl,cl<br />	jnz @@TestAlignment<br />	dec edx<br />	xor eax,eax <br />@@Done:<br />	mov byte ptr ,0<br />	ret 3*4<br />NNStrCpy endp<br /><br />END<br /></code></pre><br /><br />if youre strings arent too big maybe an inline proc might be better<br /><pre><code>__inline char * NNStrCpy(char *pszDest,char *pszSource,char chTerm)<br />{<br />__asm<br />	{<br />	mov edx,pszDest<br />	mov eax,pszSource<br />	dec edx<br />_1:	mov cl,<br />	inc eax<br />	cmp cl,chTerm<br />	sete ch<br />	dec ch<br />	inc edx<br />	and cl,ch<br />	mov ,cl<br />	jnz _1<br />	}<br />}</code></pre></div>
    <div class="meta">Posted on 2007-01-04 21:16:55 by drizz</div>
   </div>
   <div class="post" id="post-187367">
    <div class="subject"><a href="#post-187367">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body">Thank you, drizz! That is some fast code, but sadly it uses MMX. Yes, you may be asking why that is bad since most modern processors support MMX... well with my product I am not exactly sure all of my users will have a modern processor. Of course it is expected that they will, but I am scared to take a chance.<br />If someone feels it necessary to correct me on my worries and give me strength to use only the MMX version, please do.</div>
    <div class="meta">Posted on 2007-01-04 21:51:19 by NegativeNull</div>
   </div>
   <div class="post" id="post-187368">
    <div class="subject"><a href="#post-187368">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body">just to say that it uses plain MMX code not SSEMMX that would require P3 or better,<br />this code requires PMMX (year 1995 i think) :)</div>
    <div class="meta">Posted on 2007-01-04 21:59:25 by drizz</div>
   </div>
   <div class="post" id="post-187369">
    <div class="subject"><a href="#post-187369">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body">Thank you drizz, I do believe you have broken my fears. Wikipedia helped a bit as well.<br />I am guessing your code will be fast than mine, but it is worth a good benchmark.</div>
    <div class="meta">Posted on 2007-01-04 22:07:11 by NegativeNull</div>
   </div>
   <div class="post" id="post-187371">
    <div class="subject"><a href="#post-187371">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body">I doubt that anyone today has a CPU without MMX O_O It&#39;s really hard to buy a Celeron (the &#39;old one&#39;, not the one with P4&#39;s technology), you know, and even this Celeron supports MMX. I once saw an auction on Allegro where one guy was adding Celerons for free if you bought P4/AthlonXP. It&#39;s XXI century ^^ If someone has a CPU without MMX, then they have it because of their own, conscious will ^^</div>
    <div class="meta">Posted on 2007-01-05 02:43:32 by ti_mo_n</div>
   </div>
   <div class="post" id="post-187387">
    <div class="subject"><a href="#post-187387">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body">I just can&#39;t seem to get the MMX-based code to assemble!<br />I have MASM 6.14.8444 and I have included the .MMX flag at the beginning of the code but I still get these errors:<br /><pre><code>speedtest.asm(56) : error A2006: undefined symbol : mm2<br />speedtest.asm(57) : error A2006: undefined symbol : mm3<br />speedtest.asm(58) : error A2006: undefined symbol : mm3<br />speedtest.asm(59) : error A2006: undefined symbol : mm3<br />speedtest.asm(60) : error A2006: undefined symbol : mm3<br />speedtest.asm(65) : error A2006: undefined symbol : mm0<br />speedtest.asm(66) : error A2006: undefined symbol : mm1<br />speedtest.asm(67) : error A2006: undefined symbol : mm0<br />speedtest.asm(68) : error A2006: undefined symbol : mm0<br />speedtest.asm(69) : error A2006: undefined symbol : mm0<br />speedtest.asm(70) : error A2006: undefined symbol : mm0<br />speedtest.asm(73) : error A2006: undefined symbol : mm0<br />speedtest.asm(74) : error A2006: undefined symbol : mm0<br />speedtest.asm(75) : error A2006: undefined symbol : mm0<br />speedtest.asm(78) : error A2006: undefined symbol : mm1</code></pre><br />Why is this happening?</div>
    <div class="meta">Posted on 2007-01-05 23:13:23 by NegativeNull</div>
   </div>
   <div class="post" id="post-187389">
    <div class="subject"><a href="#post-187389">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body">Use upper-cases for the MMx registers...<br /></div>
    <div class="meta">Posted on 2007-01-06 01:46:38 by f0dder</div>
   </div>
   <div class="post" id="post-187390">
    <div class="subject"><a href="#post-187390">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body">Thank you, f0dder.<br />My only problem now is that my test code is crashing. I debugged it and it crashes always on the movq instruction that takes the result and puts it back into the buffer. It says that there is some sort of memory access violation, but I cannot figure out why.<br />The basic structure of my code after all the includes is as follows:<br /><pre><code>.data<br />str1 db &quot;abc-abcd-abcde-abcdef-abcdefg-abcdefgh-abcdefghi,abc-labcd-abcde-abcdef-abcdefg-abcdefgh-abcdefghi,abc-abcd-abcde-abcdef-abcdefg-abcdefgh-abcdefghi&quot;,9,&quot;//Comment&quot;,0<br />str2 db 256 dup (0)<br /><br />.code<br />invoke NNStrCpy,addr str1,addr str2,&quot;,&quot;<br />fn MessageBox,0,str$(str2),&quot;Drizz NNStrCpy&quot;,MB_OK&nbsp; <br /> <br />invoke ExitProcess,0</code></pre><br />Now why would there be an access violation of some sort?</div>
    <div class="meta">Posted on 2007-01-06 02:42:59 by NegativeNull</div>
   </div>
   <div class="post" id="post-187391">
    <div class="subject"><a href="#post-187391">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body">On my system it doesn&#39;t crash, but the MessageBox shows up empty...<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2216" target="_blank">test.asm</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-01-06 02:59:50 by f0dder</div>
   </div>
   <div class="post" id="post-187396">
    <div class="subject"><a href="#post-187396">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body"><div class="quote"><br /><pre><code><br />invoke NNStrCpy,addr str1,addr str2,&quot;,&quot;<br /></code></pre><br />Now why would there be an access violation of some sort?<br /></div><br />NNStrCpy proc <strong>pszDest</strong>:PTR BYTE,<strong>pszSource</strong> :) :PTR BYTE,chTerm:BYTE<br />so the logical output is the empty msgbox.<br /><br />the source was meant to be compiled and linked as .obj, (with ml 6.15 or above :twisted:)<br />if youre going to include that source as/in a sourcefile you must put at end:<br />OPTION PROLOGUE:PROLOGUEDEF<br />OPTION EPILOGUE:EPILOGUEDEF<br />so other procedures can have prologue-epilogue code.<br />also note that my function omits prologue-epilogue code with:<br />OPTION PROLOGUE:NONE<br />OPTION EPILOGUE:NONE<br /><u>see f0dder&#39;s file</u><br /><br /></div>
    <div class="meta">Posted on 2007-01-06 10:13:52 by drizz</div>
   </div>
   <div class="post" id="post-187397">
    <div class="subject"><a href="#post-187397">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body">note 2:<br />performance would be better if both buffers are aligned at 8, (&quot;align N&quot; - command).<br />if you use <u>any</u> of the memory allocation functions for buffers then you dont have to worry about that, because all of them align at 8 at least.<br />assuming that the source string is not static.</div>
    <div class="meta">Posted on 2007-01-06 10:27:22 by drizz</div>
   </div>
   <div class="post" id="post-187401">
    <div class="subject"><a href="#post-187401">Re: Need Help Optimizing Terminator-Based String Cut Proc</a></div>
    <div class="body"><div class="quote"><br />NNStrCpy proc <strong>pszDest</strong>:PTR BYTE,<strong>pszSource</strong> :) :PTR BYTE,chTerm:BYTE<br />so the logical output is the empty msgbox.</div><br /><br />That was so incredibly bright of myself to not notice the order in which you made the arguments, ha. Well my code is 400 ticks slower than your code over 1M iterations, so my code is definitely out. Thank you so much drizz, I will be sure to give you some credit for your help.<br /><br />Oh, and I knew about the prologue-epilogue &quot;issue.&quot; That was one of the more obvious things. As for the align, I never knew that. Thank you again for your help, the code I was using was merely a test, in the actual I use the heap allocation methods.</div>
    <div class="meta">Posted on 2007-01-06 14:22:02 by NegativeNull</div>
   </div>
  </div>
 </body>
</html>