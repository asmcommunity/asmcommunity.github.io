<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>NASM OOP - Work In Progress - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30083" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=38">Object Oriented Programming</a> &raquo; <a href="../?id=30083">NASM OOP - Work In Progress</a></p>
   <div class="post" id="post-212264">
    <div class="subject"><a href="#post-212264">NASM OOP - Work In Progress</a></div>
    <div class="body">Below is some sample code to demonstrate what it can do so far, nothing overly special. &#039;virtual&#039; methods can be overloaded whereas &#039;static&#039; methods cannot. That might change as I&#039;m thinking of making a change to the syntax now that the core is working fairly well.<br /><br />Even though I mention it in the source, I want to go ahead and thank Ultrano and Homer for their help with this as I wouldn&#039;t have ever gotten this far without their help.<br /><br /><pre><code>BITS 32<br /><br />%define SINGLE_FILE_BUILD<br />%include &quot;objects.inc&quot;<br /><br />EXTERN puts<br />EXTERN printf<br /><br />CLASS CTest<br />	virtual method, Say<br />	static method, CTest<br />	static method, Hello<br />	static method, GoodBye<br />	static dword, m_who<br />ENDCLASS<br /><br />CLASS CHaha, CTest<br />ENDCLASS<br /><br />CLASS CBlah, CHaha<br />	virtual method, Say<br />	static method, CBlah<br />	static method, Hi<br />ENDCLASS<br /><br />CLASS MYA<br />	static method, Say<br />ENDCLASS<br /><br />SECTION .text<br /><br />MYA_Say:<br />%push<br />%stacksize flat<br />%arg	this:DWORD, msg:DWORD<br /><br />	push ebp<br />	mov ebp, esp<br />	push dword <br />	call puts<br />	add esp, 4<br />	leave<br />	ret<br /><br />%pop<br /><br />CBlah_CBlah:<br />%push<br />%stacksize flat<br />%arg	this:DWORD<br /><br />	push ebp<br />	mov ebp, esp<br />	mov ecx, <br />	mov edx, strAuthor<br />	mov , edx<br />	leave<br />	ret<br /><br />%pop<br /><br />CBlah_Hi:<br />%push<br />%stacksize flat<br />%arg	this:DWORD<br /><br />	push ebp<br />	mov ebp, esp<br />	mov ecx, <br />	push dword <br />	push dword strHello<br />	call printf<br />	add esp, 8<br />	leave<br />	ret<br /><br />%pop<br /><br />CBlah_Say:<br />%push<br />%stacksize flat<br />%arg	this:DWORD, msg:DWORD<br /><br />	push ebp<br />	mov ebp, esp<br />	mov ecx, <br />	push dword <br />	push dword strCBS<br />	call printf<br />	add esp, 8<br />	leave<br />	ret<br /><br />%pop<br /><br /><br />CTest_CTest:<br />%push<br />%stacksize flat<br />%arg	this:DWORD, msg:DWORD<br /><br />	push ebp<br />	mov ebp, esp<br />	mov ecx, <br />	mov edx, <br />	mov , edx<br />	leave<br />	ret<br /><br />%pop<br /><br />CTest_Say:<br />%push<br />%stacksize flat<br />%arg	this:DWORD, msg:DWORD<br /><br />	push ebp<br />	mov ebp, esp<br />	mov ecx, <br />	push dword <br />	call puts<br />	add esp, 4<br />	leave<br />	ret<br /><br />%pop<br /><br />CTest_Hello:<br />%push<br />%stacksize flat<br />%arg	this:DWORD<br /><br />	push ebp<br />	mov ebp, esp<br />	mov ecx, <br />	push dword <br />	push dword strHello<br />	call printf<br />	add esp, 8<br />	leave<br />	ret<br /><br />%pop<br /><br />CTest_GoodBye:<br />%push<br />%stacksize flat<br />%arg	this:DWORD<br /><br />	push ebp<br />	mov ebp, esp<br />	mov ecx, <br />	push dword <br />	push dword strGoodBye<br />	call printf<br />	add esp, 8<br />	leave<br />	ret<br /><br />%pop<br /><br />GLOBAL main<br />main:<br />	push ebp<br />	mov ebp, esp<br /><br />	new CTest, dword strAuthor<br />	mov , eax<br /><br />	vcall , CTest,Say, strTitle<br />	mcall , CTest,Hello<br />	mcall , CTest,GoodBye<br /><br />	delete <br /><br />	new CBlah<br />	mov , eax<br /><br />	mcall , CBlah,Hi<br />	vcall , CBlah,Say, strTitle<br /><br />	delete <br /><br />	new MYA<br />	mov , eax<br />	mcall , MYA,Say, strTitle<br />	delete <br /><br />	xor eax, eax<br />	leave<br />	ret<br /><br />SECTION .data<br />pObject		DD 0	;; Our Object Pointer<br /><br />strHello	DB &quot;Hello, %s&quot;, 10, 0<br />strGoodBye	DB &quot;GoodBye, %s&quot;, 10, 0<br />strTitle	DB &quot;NASM OOP Demo&quot;, 0<br />strAuthor	DB &quot;Bryant Keller&quot;, 0<br />strCBS		DB &quot;CBS: %s&quot;, 10, 0</code></pre></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3220" target="_blank">objects.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-07-12 00:10:38 by Synfire</div>
   </div>
   <div class="post" id="post-212268">
    <div class="subject"><a href="#post-212268">Re: NASM OOP - Work In Progress</a></div>
    <div class="body">Update:<br /><br /><strong>Change 1 - BugFix(001)</strong><br />Okay, so I&#039;m not perfect. lol It&#039;s not a really major bug (no security problem or anything) it&#039;s just something that creeped up because of my personal coding style. When I do OOP development, I put classes in a file by themselves and link the resulting .OBJ files together. Because of this tendency, when I tested my objects.inc I didn&#039;t check to see if two classes with methods/members of the same name might cause a conflict, they did. That has been fixed in my first official bugfix. :)<br /><br /><strong>Change 2 - Ctor/Dtor Generator</strong><br />Having the user be forced to write a Ctor/Dtor for every single class just seems a bit excessive.. So I&#039;ve come up with a much simpler solution which mimics the way that C++ does. Unless the user declares a Ctor/Dtor, then you don&#039;t have to worry about defining one. This will reduce the overall executable size dramatically from the first version of objects.inc and I&#039;m really happy about how this feature has turned out.<br /></div>
    <div class="meta">Posted on 2010-07-12 17:55:23 by Synfire</div>
   </div>
   <div class="post" id="post-212276">
    <div class="subject"><a href="#post-212276">Re: NASM OOP - Work In Progress</a></div>
    <div class="body">Update:<br /><br /><strong>Change 3 - Optimizations!!!</strong><br />A Lot! of optimizations have taken place within the objects.inc file. I haven&#039;t really kept this thread as up-to-date on the conversation as I have the Nasm-Forum thread, but too keep a long story short -- almost everything is compile-time now except the new/delete and the internal constructor (and your code of course). So much of the code has been turned into just identifier manipulations and state change monitoring that there is very little actual code being generated now. :)<br /><br /><strong>Change 4 - USE macro</strong><br />Since OOP design is oriented around multi-file builds, I&#039;ve included a neat little macro (and modified the core a little) to allow you to declare your class in a single include file to be used throughout your project and define your methods in a single assembler source file (.asm) which gets built into an object file for linkage. This style of coding is familiar if you&#039;ve done any large scale projects in C++. The use macro comes into play in the source (.asm) file. Place the use macro at the top of your source to import your declared class (.inc). When you do this, the internal constructor, virtual method table, and virtual data table will be brought into the source (and saved into your .obj file where it belongs).<br /><br />All this is grand and cool, but since the USE macro introduced a toggling mechanism within the class generator, people who prefer to define and declare their class in the same file (like the above example does) will need to set a switch (SINGLE_FILE_BUILD) to disable all the toggling that USE relies on. I know this seems like a bad idea, but trust me -- it&#039;s for the best. :)<br /><br /><strong>EDIT:</strong> Oh yea! I forgot to mention this. There is a multi-file build test at http://assembly.ath.cx/code/mft.tar.gz which shows the USE macro in action, as well as how larger scale projects are laid out. When I get some time I might do a three-tier example, I think objects.inc is probably mature enough for it.</div>
    <div class="meta">Posted on 2010-07-14 13:36:07 by Synfire</div>
   </div>
   <div class="post" id="post-212390">
    <div class="subject"><a href="#post-212390">Re: NASM OOP - Work In Progress</a></div>
    <div class="body"><div class="quote"><br /><strong>Change 2 - Ctor/Dtor Generator</strong><br />Having the user be forced to write a Ctor/Dtor for every single class just seems a bit excessive.. So I&#039;ve come up with a much simpler solution which mimics the way that C++ does. Unless the user declares a Ctor/Dtor, then you don&#039;t have to worry about defining one. This will reduce the overall executable size dramatically from the first version of objects.inc and I&#039;m really happy about how this feature has turned out.<br /></div><br /><br />What currently happens when a class without a c&#039;tor inherits from a parent class with a c&#039;tor that must be invoked during object creation?</div>
    <div class="meta">Posted on 2010-07-24 15:45:26 by p1ranha</div>
   </div>
   <div class="post" id="post-212393">
    <div class="subject"><a href="#post-212393">Re: NASM OOP - Work In Progress</a></div>
    <div class="body">Good point. Actually I hadn&#039;t tested for that. I suppose it could be fixed with a modification to new along the lines of:<br /><br /><pre><code>%macro argcnt 1-*<br />%assign %$argCount %0<br />%endm<br /><br />%imacro new 1-2+<br />	nasm_alloc %{1}_size<br />	push eax<br /><br />	push eax<br />	call %{1}___%{1}<br />%push<br />	%define %$parent %{1}<br />	%if %[%{$parent}]_has_parent = 1<br /><br />		%define %$parent %[%{$parent}]_parent<br /><br />		%if %[%{$parent}]_has_ctor = 1<br />			rpush %{2}<br />			push eax<br />			call %[%{$parent}]_%[%{$parent}]<br />		%endif<br />		pop eax<br />		argcnt %{2}<br />		%if %$argCount &gt; 0<br />			sub esp, (%{$argCount} * 4)<br />		%endif<br />	%endif<br />%pop<br />	%if %{1}_has_ctor = 1<br />		rpush %{2}<br />		push eax<br />		call %{1}_%{1}<br />	%endif<br />	pop eax<br />	argcnt %{2}<br />	%if %$argCount &gt; 0<br />		sub esp, (%{$argCount} * 4)<br />	%endif<br />%endm</code></pre><br /><br />And making the Ctor always use CDECL calling convention rather than the STDCALL convention I was using. This will repeatedly call the user Ctor if it exists for each parent class. I might upload a patch with this fix, I&#039;m hesitant because what I really want to do is a completely rewrite of the underlying subsystem to work on a Primer class based system rather than my current system of creating an initialization for every definition (which I think is suboptimal). This is why I&#039;ve not done any major revisions to this lately, I&#039;m still working out all the theory behind the rewrite, I really don&#039;t want to start such an overhaul of the code only to find out that it can&#039;t be done because of some quirk in NASM which is why I tread softly in this field. When it comes to OOP, better men have come before me to get NASM to handle it, and better men have failed. I&#039;m just taking my time and working slowly as to avoid any serious design flaws (not too dissimilar from this one :oops:) from rearing their ugly heads.<br /><br />Thanks for the heads up though.</div>
    <div class="meta">Posted on 2010-07-24 17:41:02 by Synfire</div>
   </div>
   <div class="post" id="post-212394">
    <div class="subject"><a href="#post-212394">Re: NASM OOP - Work In Progress</a></div>
    <div class="body">It would be unexpected for a parent class&#039;s c&#039;tor not to be invoked. The best way to handle this is to provide a default c&#039;tor for any class that does not define one to simply call <strong>it&#039;s</strong> parent object c&#039;tor, and so on and so on. As a matter of fact, you are going to need code which does this regardless, unless part of your syntax is to force a call to super() (Java terminology there) as the first line in a class&#039;s c&#039;tor prior to any other code executing. By providing a default c&#039;tor in your CLASS macro you can have any other object c&#039;tor call it to make the parent call. Another option is to make the c&#039;tor declaration mandatory in the class definition even if the user will not define a method to do anything other than call it&#039;s parent c&#039;tor. Whichever way you choose, you must provide support for this feature. Otherwise &quot;Bad Things&quot; :shock: will happen...<br /><br />Along the same line of thinking regarding OO inheritance, you most definately want a root, or primer, class. There is a lot of ground to cover using OOP principles. It is especially important for the low-level &quot;glue&quot; that will be used for future object identification, comparison, etc.. You need to start these types of processes somewhere and having a root parent will make your life much easier!&nbsp; :)<br /></div>
    <div class="meta">Posted on 2010-07-24 18:22:03 by p1ranha</div>
   </div>
   <div class="post" id="post-212408">
    <div class="subject"><a href="#post-212408">Re: NASM OOP - Work In Progress</a></div>
    <div class="body">I would opt for a root class simply named... <strong>Object</strong> :)</div>
    <div class="meta">Posted on 2010-07-25 11:54:10 by SpooK</div>
   </div>
   <div class="post" id="post-212409">
    <div class="subject"><a href="#post-212409">Re: NASM OOP - Work In Progress</a></div>
    <div class="body">Ours is called &quot;Primer&quot;.<br />It has almost no functionality, but one vital function is error reporting, and its inherited by Everything except for &quot;pure interfaces&quot;.<br />As an example of a &quot;pure interface&quot;, see &quot;ID3DXAllocateHierarchy&quot;</div>
    <div class="meta">Posted on 2010-07-25 11:59:49 by Homer</div>
   </div>
   <div class="post" id="post-212411">
    <div class="subject"><a href="#post-212411">Re: NASM OOP - Work In Progress</a></div>
    <div class="body"><div class="quote"><br />I would opt for a root class simply named... <strong>Object</strong> :)<br /></div><br /><br />Ack! kind of like the definition of recursion: see recursion?&nbsp; :lol:<br /><br /><div class="quote"><br />Ours is called &quot;Primer&quot;.<br />It has almost no functionality, but one vital function is error reporting, and its inherited by Everything except for &quot;pure interfaces&quot;.<br />As an example of a &quot;pure interface&quot;, see &quot;ID3DXAllocateHierarchy&quot;<br /></div><br /><br />Homer,<br />When comparing instance identities of two different classes whose initial parents are different but whose grandparents are identical - is this functionality implemented in OA32 as interating (or recursing) from child to grandparent or from Primer to grandparent?<br /><br />eg:<br /><pre><code><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Primer<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  |<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ClassX<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /&nbsp; &nbsp; &nbsp; \<br />&nbsp; &nbsp; &nbsp; ClassY&nbsp; &nbsp; &nbsp; &nbsp; ClassZ<br />&nbsp; &nbsp;  /	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br />ClassA&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ClassB<br /></code></pre><br />Such that ClassA and ClassB are both instances of ClassX.<br /></div>
    <div class="meta">Posted on 2010-07-25 14:00:38 by p1ranha</div>
   </div>
   <div class="post" id="post-212418">
    <div class="subject"><a href="#post-212418">Re: NASM OOP - Work In Progress</a></div>
    <div class="body">Each object instance has access to every single class in its own family tree which was declared before it was, ie ,&quot;ancestor aware&quot;.<br />Obviously, a grandparent or even a parent class cannot be aware of its child classes, since their definitions did not exist at the moment the ancestor was declared.<br /><br /></div>
    <div class="meta">Posted on 2010-07-25 21:37:09 by Homer</div>
   </div>
   <div class="post" id="post-212419">
    <div class="subject"><a href="#post-212419">Re: NASM OOP - Work In Progress</a></div>
    <div class="body"> Perhaps I wasn&#039;t clear. From a declaration point of view, sure. But from the RTTI point of view?<br />I&#039;m thinking specifically of an isInstanceOf() method.</div>
    <div class="meta">Posted on 2010-07-25 23:18:30 by p1ranha</div>
   </div>
   <div class="post" id="post-212437">
    <div class="subject"><a href="#post-212437">Re: NASM OOP - Work In Progress</a></div>
    <div class="body"><pre><code><br />.if dword ptr  == MyClass1_Somefunc ; isInstanceOf<br /></code></pre><br /><br />But seriously, do such things as the Object base need to be pre-packed and enforced? What if you don&#039;t need IUnknown::Release? Or a vtable when you don&#039;t need one, but Object already specified it?&nbsp; Sure, it&#039;s just 4 bytes and one instruction extra, but you might need it slim some time :) . </div>
    <div class="meta">Posted on 2010-07-26 13:26:19 by Ultrano</div>
   </div>
   <div class="post" id="post-212439">
    <div class="subject"><a href="#post-212439">Re: NASM OOP - Work In Progress</a></div>
    <div class="body"><div class="quote"><br /><pre><code><br />.if dword ptr  == MyClass1_Somefunc ; isInstanceOf<br /></code></pre><br /></div><br /><br />For shallow classes maybe, but for deep classes?<br /><br />(C++ pseudocode):<br /><pre><code><br />&nbsp;  ClassZ::Primer {}<br />&nbsp;  ClassY::ClassZ {}<br />&nbsp;  ClassX::ClassY {}<br />&nbsp;  ClassA::ClassX {}<br /><br />&nbsp;  ClassY Y;<br />&nbsp;  ClassA A;<br /><br />&nbsp;  bool ClassY::isInstanceOf(ClassY* argObj) { ... }<br /><br />&nbsp;  // is A an instance of Y<br />&nbsp;  if (Y.isInstanceOf(&amp;ClassA) ) { ... }<br /></code></pre><br /><br />I just wanted to know how OA32 handled this.<br /><br /><div class="quote"><br />But seriously, do such things as the Object base need to be pre-packed and enforced?<br /></div><br /><br />Welcome to the beginning of the great OOP debate :)<br /><br /><div class="quote"><br /> What if you don&#039;t need IUnknown::Release?<br /></div><br /><br />You should if you use IUnknown::QueryInterface or IUnknown::AddRef<br /><br /><div class="quote"><br /> Or a vtable when you don&#039;t need one, but Object already specified it?&nbsp; Sure, it&#039;s just 4 bytes and one instruction extra, but you might need it slim some time :) . <br /></div><br /><br />The static keyword should handle that. The _this pointer is not available to static methods, thus no vtable info available to reach into instantiated object member vars.<br /><br /></div>
    <div class="meta">Posted on 2010-07-26 15:27:21 by p1ranha</div>
   </div>
   <div class="post" id="post-212440">
    <div class="subject"><a href="#post-212440">Re: NASM OOP - Work In Progress</a></div>
    <div class="body">By IUnknown::Release I meant the whole IUnknown parent. &quot; NumReferences dd ?&quot; being the key useful feature. <br /><br />By vtable, I meant this:<br /><br /><pre><code><br />CBase struct<br />	;vTable dd ? ; poof, redundancy purged<br />	<br />	.. <br />CBase ends<br /></code></pre><br /><br /><br />The kind of deep instanceof support seems completely useless. Functionality can be easily designed and implemented with simple virtuals in the rare cases it happens to make sense, imho. In OA32 it may be supported, but Homer has to chime-in for that :)</div>
    <div class="meta">Posted on 2010-07-26 15:49:04 by Ultrano</div>
   </div>
   <div class="post" id="post-212441">
    <div class="subject"><a href="#post-212441">Re: NASM OOP - Work In Progress</a></div>
    <div class="body">A simple way to implement the deep instanceof is:<br /><pre><code><br />CChildXYZ_instanceList:&nbsp; dd&nbsp; CChildXYZ_Destructor, CChild1_Destructor, CBase_Destructor,0 ; the instanceof func/macro loops this<br /><br />CChildXYZ_vTable: dd CChildXYZ_instanceList, CChildXYZ_Destructor, CBase_virtual1,CChildXYZ_virtual2<br /><br /><br /></code></pre></div>
    <div class="meta">Posted on 2010-07-26 15:59:51 by Ultrano</div>
   </div>
   <div class="post" id="post-212442">
    <div class="subject"><a href="#post-212442">Re: NASM OOP - Work In Progress</a></div>
    <div class="body"><div class="quote"><br />By IUnknown::Release I meant the whole IUnknown parent. &quot; NumReferences dd ?&quot; being the key useful feature. <br /><br />By vtable, I meant this:<br /><br /><pre><code><br />CBase struct<br />	;vTable dd ? ; poof, redundancy purged<br />	<br />	.. <br />CBase ends<br /></code></pre><br /></div><br /><br />Sure, you absolutely can design a static class like that. You&#039;re basically creating a simple struct containing data and function pointers. But at the same time you will not benefit from the features that OOP provides.<br /><br /><div class="quote"><br />The kind of deep instanceof support seems completely useless. Functionality can be easily designed and implemented with simple virtuals in the rare cases it happens to make sense, imho.<br /></div><br /><br />That is one way. Another way is to implicitly provide the capability from within the system thus making it available to all objects created using that system. If all objects have this built-in ability then you don&#039;t have to worry about previously coded objects blowing up when a reference to the latest and greatest objects are given as a parameter. Also, when designing that new object, you eliminate the need to look into the parent class code to see if it&#039;s there or not - reducing time and eliminating duplicate or redundant coding (smaller footprint).<br /><br />I think you see which side of the fence I&#039;m on :)<br /></div>
    <div class="meta">Posted on 2010-07-26 16:14:19 by p1ranha</div>
   </div>
   <div class="post" id="post-215987">
    <div class="subject"><a href="#post-215987">Re: NASM OOP - Work In Progress</a></div>
    <div class="body">i like this tombstone, bump</div>
    <div class="meta">Posted on 2012-05-13 06:59:16 by Homer</div>
   </div>
   <div class="post" id="post-215988">
    <div class="subject"><a href="#post-215988">Re: NASM OOP - Work In Progress</a></div>
    <div class="body">Tombstone is accurate. I&#039;ve not even been coding for PC&#039;s lately so a lot of these old projects are being neglected. About the only thing I do on computers anymore is VHDL/FPGA simulations. As for this project, I don&#039;t even really remember what I was working on when I stopped it. :P</div>
    <div class="meta">Posted on 2012-05-13 11:20:10 by Synfire</div>
   </div>
  </div>
 </body>
</html>