<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Combonation function (Calculating factorials) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4978" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=4978">Combonation function (Calculating factorials)</a></p>
   <div class="post" id="post-34979">
    <div class="subject"><a href="#post-34979">Combonation function (Calculating factorials)</a></div>
    <div class="body">I need to code a combonation function (n<strong>C</strong>r) but I very quickly ran into some problems that Im not sure how to work around. <br /><br />First of all, the combonation function:<br />n<strong>C</strong>r = n! / r!(n - r)!<br /><br /><br />The 'n exclamation mark', '<strong>n!</strong>' means 'n factorial', where n is an integer greater than or equal to zero.<br /><br />it itself is a function:<br />n! = 1 * 2 * 3 *.... * (n - 2)(n - 1)n<br /><br />for example:<br />8! = 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 = 40320<br />5! =5 * 4 * 3 * 2 * 1 = 120<br />(A special case is where 0! = 1)<br /><br /><br />This leaves me with a long series of multiplcations, and a divide.<br /><br />There is half a way around this:<br />if<br />6! / 3! = 6 * 5 * 4 * 3 * 2 * 1 / 3 * 2 * 1 <br />then<br />6! / 3!  = 6 * 5 * 4 <br />because the rest cancels itself out, which simplifys things a bit.<br /><br /><br />If anyone can see or knows an easier way to code this than a fully blown out unoptimized it would be much appreciated.<br /><br />-Thanks</div>
    <div class="meta">Posted on 2002-04-25 05:04:26 by huh</div>
   </div>
   <div class="post" id="post-35056">
    <div class="subject"><a href="#post-35056">Combonation function (Calculating factorials)</a></div>
    <div class="body"><pre><code>; esi = n<br />; edi = r<br />mov edx, esi<br />sub edx, edi<br /><br />mov eax, &#91;FacList + edi*8&#93;<br />; r!&#40;n-r&#41;!  &#123;must fit into 32-bits&#125;<br />mul &#91;FacList + edx*8&#93;<br />mov ecx,eax<br /><br />mov eax,&#91;FacList + esi*8&#93;<br />mov edx,&#91;FacList + esi*8 + 4&#93;<br /><br />div ecx<br />; eax = nCr</code></pre>FacList are the QWORD factorials.<br />This is very limited. :(<br /><br />There should be a way to cancel many terms of the factorials.<pre><code>n=7; r=3;<br /><br /> 7   6   5   4   3   2   1<br />*** *** *** ***              &#40;n!/r!&#41;<br />            *** *** *** ***  &#40;n-r&#41;!</code></pre>See here how the 4 overlaps, and can be factored out.  Have to think a little more on how to do that easily.</div>
    <div class="meta">Posted on 2002-04-25 12:42:15 by bitRAKE</div>
   </div>
   <div class="post" id="post-35106">
    <div class="subject"><a href="#post-35106">Combonation function (Calculating factorials)</a></div>
    <div class="body">This is very flexible - I believe it will work for any n! up to 16! and many others.  The minimum of (r,(n-r)) has to be [0-16].  Also, n!/MAX(r,(n-r)) has to fit in 64 bits.  It can be slow.  Let me know if your wondering how it works.<pre><code>; EDX&#58;EAX * 32 bit constant ; select register/memory to trash<br />; assume result fits into 64 bits<br />MUL64 MACRO val&#58;REQ, regmem&#58;REQ<br />	mov regmem,eax<br />	mov eax,edx<br />	mul val<br />	xchg eax,regmem<br />	mul val<br />	add edx,regmem<br />ENDM<br /><br /><br />; Combintorial&#58; nCr = n! / r!&#40;n-r&#41;!  ; n &gt;= r<br />;<br />; esi = n<br />; edi = r<br />;<br />	mov ecx,esi<br />	sub ecx,edi<br /><br />; edi = MAX&#40;r, &#40;n-r&#41;&#41;<br />	cmp edi,ecx<br />	jnc @F<br />	mov edi,ecx<br />@@&#58;<br />	mov eax,1<br />	xor edx,edx<br />	mov ebx,esi<br />	jmp _5<br />_4&#58;<br />	MUL64 ebx, ecx<br />	dec ebx<br />_5&#58;	cmp edi,ebx<br />	jc _4<br />	sub esi,edi ; esi = MIN&#40;r, &#40;n-r&#41;&#41; = &#91;0,16&#93;<br />	mov ecx,&#91;FacListDD2 + esi*8 + 4&#93;<br />	shrd eax,edx,cl<br />	shr edx,cl<br />	div &#91;FacListDD2 + esi*8&#93;<br />; eax = nCr<br />	ret<br /><br />const SEGMENT<br />FacListDD2&#58;<br />;          base          power  ; n! = base * 2^&#40;power&#41;<br />	dd 1,					0	; 0!<br />	dd 1,					0	;<br />	dd 1,					1	;<br />	dd 3,					1	;<br />	dd 3,					3	;<br />	dd 3*5,					3	; 5!<br />	dd 9*5,					4	;<br />	dd 9*5*7,				4	;<br />	dd 9*5*7,				7	;<br />	dd 81*5*7,				7	;<br />	dd 81*25*7,				8	; 10!<br />	dd 81*25*7*11,				8	;<br />	dd 243*25*7*11,				10	;<br />	dd 243*25*7*11*13,			10	;<br />	dd 243*25*49*11*13,			11	;<br />	dd 729*125*49*11*13,			11	; 15!<br />	dd 729*125*49*11*13,			15	;<br />;	dd 729*125*49*11*13*17,			15	;<br />;	dd 6561*125*49*11*13*17,		16	;&#40;18!&#41;<br />const ENDS</code></pre><strong>Edit</strong>: There are a couple bugs. :(<br />Idea is good, though. :)<br /><strong>Edit</strong>: Think I might have fixed it for r=0.</div>
    <div class="meta">Posted on 2002-04-25 22:10:28 by bitRAKE</div>
   </div>
   <div class="post" id="post-35140">
    <div class="subject"><a href="#post-35140">Combonation function (Calculating factorials)</a></div>
    <div class="body">Very nice, I am impressed. As far as I can tell will calculate any combonation up to 29<strong>C</strong>r. After that the results start to get a bit random as the numbers start to get bigger.<br /><br /><br />I have attached a basic output which I have quickly scratched together.<br /><br />Cheers for the hand. I still have a long way to go :)</div>
    <div class="meta">Posted on 2002-04-26 05:56:50 by huh</div>
   </div>
   <div class="post" id="post-35148">
    <div class="subject"><a href="#post-35148">Combonation function (Calculating factorials)</a></div>
    <div class="body">That is great to hear.  I didn't have time to test it.  Think I'll write an FPU version and confirm the results.</div>
    <div class="meta">Posted on 2002-04-26 07:30:37 by bitRAKE</div>
   </div>
   <div class="post" id="post-35196">
    <div class="subject"><a href="#post-35196">Combonation function (Calculating factorials)</a></div>
    <div class="body">An example of nCr, also written C(n,r):<br /><br /><pre><code>         6 * 5 * 4 * 3 * 2 * 1   6 * 5 * 4 * 3<br />C&#40;6,4&#41; = --------------------- = -------------<br />         4 * 3 * 2 * 1 * 2 * 1   1 * 2 * 3 * 4</code></pre>To get larger results without resorting to floating point, you can alternate between multiplication and division. Note that if you multiply three <strong>consecutive</strong> integers together, one of them will be a multiple of 3. Similarly, for any consecutive sequence of integers.<br /><br />nCr = nC(n-r)<br /><br />As you can figure out, C(6,2) yields the same number and would use less division with the alternating multiply/divide algorithm.<br /><br />You may also want to try a recursive algorithm based on Pascal's triangle.<br /><br />nC(0) = 1<br />nCn = 1<br />nCr = (n-1)C(r-1) + (n-1)Cr<br /><br />Or simply calculate each row of Pascal's triangle until you get to row n, and pick out the r'th entry.<br /><br />(I wonder how long it would take to calculate something like (54321543)C(27123543).)</div>
    <div class="meta">Posted on 2002-04-26 16:51:03 by tenkey</div>
   </div>
   <div class="post" id="post-35206">
    <div class="subject"><a href="#post-35206">Combonation function (Calculating factorials)</a></div>
    <div class="body"><strong>tenkey</strong>, all those solutions sound <u>really</u> slow. :)  Your C(6,4) example reduces to C(6,2) - you just didn't get rid of the 3 and 4.  The symetry is why the algo above finds the MAX(r,(n-r)) to reduce the iterations of the MUL64 loop.  The FPU should be able to do something like ~60Cr.  I wonder when we would need (54321543)C(27123543)? It would be fun to try and solve it though. :grin: <strong>Roy</strong> has a BigInt lib that would work.</div>
    <div class="meta">Posted on 2002-04-26 17:30:40 by bitRAKE</div>
   </div>
   <div class="post" id="post-35220">
    <div class="subject"><a href="#post-35220">Combonation function (Calculating factorials)</a></div>
    <div class="body">bitRAKE, I think you underestimate the FP, I found a little program, (written in Visual Basic of all langauges) that can calculate 268<strong>C</strong>134 (or 268<strong>C</strong>r). I would guess a better written asm prog could go even higher.<br /><br />My goal for the result of the combonation is to use it to calculate binomal distributions/probability's (which are always between 0 and 1) so this could be intergrated into the function, giving a even greater range.</div>
    <div class="meta">Posted on 2002-04-26 18:56:39 by huh</div>
   </div>
   <div class="post" id="post-116533">
    <div class="subject"><a href="#post-116533">Combonation function (Calculating factorials)</a></div>
    <div class="body"><strong>huh</strong>, sorry I should have said, &quot;using the same algo above.&quot;<br />Yes, there are slower algos that have greater flexiblity.<br /><br />I have over estimated the difficulty of this problem.  For very large numbers all that needs to be done is prime factorization and cancel terms to get the resulting integer.  This reduces to some very simple code working up to (2^32)<strong>C</strong>.  The result does not always fit into 32 bits, of course.<br /><br />(2^32 - 1)<strong>C</strong>(2^31 - 1) = ;) I don't think Mathematica would finish today! (note: number was too large for Mathematica.)<br /><br />Try this out with my prime <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=13322&amp;highlight=prime">sieve</a>! :grin:<pre><code>CHOOSE MACRO __n__,__r__<br />; nCr =		n!<br />;          ----------	; n &gt;= r<br />;	    r!&#40;n-r&#41;!<br />;<br />; nCr =	    n*&#40;n-1&#41;*...*MAX&#40;&#40;n-r&#41;,r&#41;<br />;          --------------------------<br />;	     1*2*3*...*MIN&#40;&#40;n-r&#41;,r&#41;<br />;<br />;<br />;<br />;<br />;<br />; Note&#58; should add/subtract in the following order&#58;<br />;	C&#40;24,5&#41; = &#40;+24-1&#41;+&#40;23-2&#41;+&#40;22-3&#41;+&#40;21-4&#41;+&#40;20-5&#41;<br />;	...to ensure all products are reduced with minimal stack size<br />;<br />	push ebp<br />	mov ebp,esp<br /><br />	mov ebx,PrimeBits ; prime sieve!<br />	mov edi,1<br />	mov esi,__n__<br />	push edi ;&#41;<br /><br />_3&#58;	; over range &#91;F&#40;MAX&#40;r,&#40;n-r&#41;&#41;&#41;, F&#40;n&#41;&#93;<br />	; store prime factors of ESI on the stack<br />	mov eax, esi<br /><br />	; divide by all primes less than N until = 1<br />	mov ecx, 2<br />	jmp _3a<br /><br />_31&#58;	; not a product of ECX<br />	; restore EAX to test again<br />	pop eax<br /><br />	; get next prime from ECX<br />	dec ecx ; needed for 2<br />	shr ecx,1<br />_32&#58;	; test for primeness<br />	bt &#91;ebx&#93;,ecx<br />	inc ecx<br />	jnc _32<br />	lea ecx,&#91;ecx*2 + 1&#93; ; prime #<br /><br />_3a&#58;	; catch final prime or 1<br />	push eax<br />	cmp eax, ecx<br />	jng _3x<br /><br />	xor edx,edx<br />	div ecx<br /><br />	test edx,edx<br />	jne _31<br /><br />	mov &#91;esp&#93;,ecx ; save factor<br />	jmp _3a<br />_3x&#58;<br /><br />	;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<br /><br />_4&#58;	; over range &#91;F&#40;2&#41;, F&#40;MIN&#40;r,n-r&#41;&#41;&#93;<br />	; subtract prime factors of EDI at &#91;ESP,EBP&#93;<br />	mov eax, edi<br /><br />	; divide by all primes less than N until = 1<br />	mov ecx, 2<br />	jmp _4a<br /><br />_41&#58;	; not a product of ECX<br />	; restore EAX to test again<br />	pop eax<br /><br />	; get next prime from ECX<br />	dec ecx ; needed for 2<br />	shr ecx,1<br />_42&#58;	; test for primeness<br />	bt &#91;ebx&#93;,ecx<br />	inc ecx<br />	jnc _42<br />	lea ecx,&#91;ecx*2 + 1&#93; ; prime #<br /><br />_4a&#58;	; catch final prime or 1 or 0<br />	cmp eax, ecx<br />	jng _4x<br /><br />	xor edx,edx<br />	push eax<br />	div ecx<br /><br />	test edx,edx<br />	jne _41<br /><br />	; find factor on stack and erase<br />	lea edx,&#91;esp+4&#93;<br />	add esp,4<br />@@&#58;	cmp &#91;edx&#93;, ecx<br />	lea edx, &#91;edx+4&#93;<br />	jne @B<br />	pop &#91;edx-4&#93;<br />	jmp _4a<br /><br />_4x&#58;	; delete final prime or 1<br />	mov edx,esp<br />@@&#58;	cmp &#91;edx&#93;, eax<br />	lea edx, &#91;edx+4&#93;<br />	jne @B<br />	pop &#91;edx-4&#93;<br /><br /><br />	dec esi<br />	inc edi<br /><br />	cmp edi,__r__<br />	jle _3<br /><br />	; build number from factorization<br />	; on stack &#91;ESP,EBP&#41;<br /><br />	xor edx,edx<br />	mov eax,1<br /><br />@@&#58;	mov ecx,&#91;esp&#93;<br />	xchg eax,ecx<br />	mul edx<br />	; EDX is zero<br />	xchg eax,ecx<br />	mul DWORD PTR &#91;esp&#93;<br />	add edx,ecx<br />	pop ecx<br />	cmp ebp,esp<br />	jne @B<br />	pop ebp<br />	; EAX&#58;EDX is U64 result<br />ENDM</code></pre>C(n,r) ; r should be MIN(r,(n-r)) to use above algo.<br /><br />It's not the fastest for very large numbers, but gets the job done and I can understand how it works.  Major slow down is the brute force approach to factoring - easy to plug into other routines.  Stack memory is used for convienence.<br /><br />Often playing the card game Spades, we only have three players (we play partners and one guy has to leave).  So, we just throw two jokers in and everyone gets 17 cards.  Well, with all those cards 47,153,358,767,970 hands are possible! (54<strong>C</strong>17 and the algorithm hardly used the stack!)</div>
    <div class="meta">Posted on 2003-09-01 21:25:03 by bitRAKE</div>
   </div>
   <div class="post" id="post-116567">
    <div class="subject"><a href="#post-116567">Combonation function (Calculating factorials)</a></div>
    <div class="body">Hi Bitrake,<br /><br />the Prime&quot;factorization&quot; Method leads to the fastest possible Method to compute the factorial of large numbers. In fact 1.000.000! can be computed in this way in  3.5 seconds on a P4 1.5Ghz. The results have 5.565.709 decimal digits. Now, the &quot;primefactorization&quot; method can be easily expanded to strike out all duplicate primepower exponents if we want the binomial.<br /><br />As Example <br />10! = ((3)^2 * 5)^2 * 7 * 2^8  -&gt; shortest computational path for 10!<br />  5! = ((3)^1 * 5)^1 *    * 2^3<br /><br />now for C(10,5) we strike out the exponents by subtractions<br />C(10,5) = 10!/5!/5!<br /><br />   10! = 3^4 * 5^2 * 7^1 * 2^8<br />-   5! = 3^1 * 5^1 * 7^0 * 2^3<br />..... = 3^3 * 5^1 * 7^1 * 2^5<br />-  5!  = 3^1 * 5^1 * 7^0 * 2^3<br />..... = 3^2 * 7 * 2^2 = 252<br /><br />thus C(10,5) = 252<br /><br />Above we get the primepower expansion and strike out by subtraction each exponent.<br />After this we can reorder each exponent such as above shown<br />252 = 3^2* 7 * 2^2 =  (3*2)^2 * 7 <br /><br />Here we get one Multiplication + one Squaring + one Multiplication. Thats the computational shortest possible path to compute this value. One Squaring is about 1.5 times faster as the multiplication (of course with very large numbers).<br /><br /><br />Hagen<br /><br />PS: Arnold Sch?nhage has proposed this way.</div>
    <div class="meta">Posted on 2003-09-02 05:13:43 by Hagen</div>
   </div>
   <div class="post" id="post-116578">
    <div class="subject"><a href="#post-116578">Combonation function (Calculating factorials)</a></div>
    <div class="body"><strong>Hagen</strong>, in the algorithm above I use the method you have explained.  I put the prime factors on the stack and it is quite fast in practice.  For example, C(10,5):<pre><code><br />. = push 1<br />10 = push 5,2<br />    1 = pop 1<br />9 = push 3,3<br />    2 = pop 2<br />8 = push 2,2,2<br />    3 = pop 3<br />7 = push 7<br />    4 = pop 2,2<br />6 = push 3,2<br />    5 = pop 5</code></pre>Which leaves 3,2,7,2,3 on the stack = 252 :)<br /><br />I don't fully calculate 10! or even accumulate the factors for the lower part (let Arnold Sch?nhage know of my improvement). The algorithm was designed with specific dependancies on x86 ASM and is very fast except the prime decomposition.<br /><br />Do you know of a faster prime decomposition?</div>
    <div class="meta">Posted on 2003-09-02 07:59:49 by bitRAKE</div>
   </div>
   <div class="post" id="post-116602">
    <div class="subject"><a href="#post-116602">Combonation function (Calculating factorials)</a></div>
    <div class="body">Yes I have seen that you do it in this way, but it's harder to understand a mathematicaly problem only based on asm source :)<br /><br />I wanted to show why we can use primepower extraction and how to use it for factorials, binomials, product and other combinatoric functions.<br /><br />&gt; Do you know of a faster prime decomposition?<br /><br />Your way is for small computations even optimal. For larger numbers with use of floatingpoints we don't need any real computation, there exists faily very exact approxiamtions. Such apporximations are very very fast.<br /><br />For exact computation with very large numbers is the essential trick to find the shortest path with common powers. Eg. we need a way to multiplicate all products very fast. In this context we have to prefer Squaring over Multiplication because Squaring is 1.5 times faster as Multiplications.<br />After this we have to multiply some Primorials (eg. Lists of many small primes) very fast. The fastest way are called Binary Splitting for this Operations.<br /><br />As example 50! = <br />((((3)^2 * <br />5*7)^2 * <br />3*5*11)^2 * <br />3*13*17*19*23)^2 * <br />13*29*31*37*41*43*47 * 2^47<br /><br />As we seen we have some Product liek 3*13*17*19*23 to build. Here we use binary splitting by ((3*13) * 17) * (19 * 23). Eg. a weighted multiplications.<br /><br />If we consider all this need we see that a Power Table, a array of Prime + Exponent are a very good idea.<br />So we have to build such a table based on N of N!.<br /><br /><br />here some small pseudo code:<br /><br />procedure Powers(Table, N: Integer);<br />{<br />  I = 0<br />  while true do<br />   {<br />      P = Primes<em><br />      if P &gt; N then break<br />      I = I +1<br />      E  = 0<br />      K = N<br />      while K &gt; P do {K = K div P, E = E + K }<br />      if E &gt; 0 then { Table.Base = P, Table.Exponent = E }<br />   }<br />    <br />}<br /><br />Above we extract the prime power exponents only for N, but we could extract it in one step as example to N/K/L where we have (N! / K! / L!). In this case we have for each prime to compute the exponents to N,K,L in one loop and the subtract these exponents. The final power table could be that one we need to compute the binomial.<br /><br />By the way, the power to prime 2 can be computed easier.<br /><br />C(10,3) = 10! / 7! / 3! thus N = 10, K = 7, L = 3 and<br /><br />(N - L - K) - (BitWeight(N) - BitWeight(L) - BitWeight(K)) = Count of trailing 0 LSBits in the Binomial of C(10, 3).<br /><br />Thus N - BitWeight(N) = count of trailing 0 bits in N!.<br /><br />BitWeight(N) is the Count of 1 Bits in N, hamming weight.<br /><br />After we get this table we have to examine how are the shortest path with a maximum of Squarings.<br />The trick is fairly easy:<br /><br />we have now our Powertable such as follow<br /><br />3^56 * 5^34 * 7^15 * 11^7 * 13^3 * 17^2 * 19^1 * 23^1 * 29^1<br /><br />an we want<br /><br />such as (((3*5)^2 * 7)^2 * 11 * 13)^2 .... (only example not math. correct:)<br /><br />To get this we write down to each prime its power as binary value<br /><br />3^001111000<br />5^000110011<br />7^000011010<br />...<br /><br />and so on<br /><br />now each Bitcolumn from left to right are computed where the column contains 1.<br /><br />From above we get.<br /><br />3<br />3*5<br />3*5*7<br />3*7<br />5<br /><br />-&gt;&gt;<br /><br />((((3)^2 * (3*5))^2 * (3*5*7))^2 * (3*7))^2 * 5<br /><br />Thats the shortest path. In fact, when you know how works Exponentations Algorithms = Binary Powering then You can see the direct dependencies to above way. It's nothing others as a binary Powering Algorithms to multiple Bases and Exponents, like  A = B^C * D^E * F^G.<br /><br />For any interesst I attached a small executable with the Pascal/Delphi Source to compute Factorials/Binomials/Permutations/Products/Primorials to arbitrary numbers.<br />In the source you can find some quit different Factorial Computations Algorithms.<br /><br /><br />Regards, Hagen<br /><br />PS: i hope my bad english is'nt to bad :)</div>
    <div class="meta">Posted on 2003-09-02 12:55:28 by Hagen</div>
   </div>
   <div class="post" id="post-116614">
    <div class="subject"><a href="#post-116614">Combonation function (Calculating factorials)</a></div>
    <div class="body">I think this is same as Hagen's function, in C:<br /><pre><code>long contdiv&#40;long x ,long i&#41;&#123;<br />long tot;<br />do&#123;<br />x=floor&#40;x / i&#41;;<br />tot+=x;<br />&#125;while &#40;x&gt;=1&#41;;<br />return tot;<br />&#125;</code></pre><br /><br /><strong>x</strong> is number under check of factor numbers of prime <strong>i</strong><br />That is called contdiv (maybe an other term but translated word by word it is 'continuous division')<br /><br /><pre><code><br />main&#40;&#41;&#123;<br />long i,chknum; char *k;<br />do&#123;<br />k=strcat&#40;k, &quot; * &quot;&#41;;<br />k=strcat&#40;k, prs&#91;i&#93;&#41;;<br />k=strcat&#40;k, &quot;^&quot;&#41;;<br />k=strcat&#40;k, contdiv&#40;chknum,prs&#91;i&#93;&#41;&#41;;<br />&#125;while prs&#91;i&#93;&lt;chknum<br />printf &#40;k&#41;;<br />&#125;<br /></code></pre><br />prs is prime list.<br />The function does not calculates factorial but prints as above<br />10! : 2^8 * 3^4 * 5^2 * 7<br />100! : 2^97 * 3^48 * 5^24 * 7^16 * 11^9 * 13^7 * 17^5 * 19^5 * 23^4 * 29^3 * 31^3 * 37^2 * 41^2 * 43^2 * 47^2 * 53 * 53 * 59 * 61 * 67 * 71 * 73 * 79 * 83 * 89 * 97<br />.<br />.<br />I have written this code when we learned how to find how many digits does a factorial has without calculating itself and with out logarithms at school. Algorithm does not seems fast but does the job;)</div>
    <div class="meta">Posted on 2003-09-02 14:54:47 by inFinie</div>
   </div>
   <div class="post" id="post-116644">
    <div class="subject"><a href="#post-116644">Combonation function (Calculating factorials)</a></div>
    <div class="body">Yes thats the right code translation if my C knownledge is correct :)<br /><br />&gt; Algorithm does not seems fast but does the job<br /><br />Thats dependend on the viewpoint. As i currently can say it is the fastest to compute the factorial/binomial etc. to arbitrary size. There exists currently no other known method with same low complexity. The small 32bit Divisions and the needed memory for the prime power table can be ignored, in comparsion to the needed squarings and multiplications. <br /><br />Some people proposed and stated that there exists a FFT based factorial function with far lower complexity. But I never found it :(<br /><br />My attached executable is as i know that fastest PC program to compute such factorials :)<br /><br />Regards Hagen</div>
    <div class="meta">Posted on 2003-09-02 17:40:40 by Hagen</div>
   </div>
   <div class="post" id="post-116656">
    <div class="subject"><a href="#post-116656">Combonation function (Calculating factorials)</a></div>
    <div class="body">Thank you <strong>Hagen</strong> and <strong>inFinie</strong>.  I am sorry my math skills are lacking - my asm is better.  I'll review the code (I can read C/Pascal equally well) and convert it to asm if appropriate - for comparison.  Hopefully, I can learn more about math through my coding. :)</div>
    <div class="meta">Posted on 2003-09-02 19:34:00 by bitRAKE</div>
   </div>
   <div class="post" id="post-116720">
    <div class="subject"><a href="#post-116720">Combonation function (Calculating factorials)</a></div>
    <div class="body"><a target="_blank" href="http://mathworld.wolfram.com/Factorial.html">http://mathworld.wolfram.com/Factorial.html</a><br />n!=gamma(n+1)<br /><br />Here is a source to approximate gamma function in TASM<br /><a target="_blank" href="http://www.crbond.com/download/misc/gamma32.asm">http://www.crbond.com/download/misc/gamma32.asm</a></div>
    <div class="meta">Posted on 2003-09-03 04:18:26 by inFinie</div>
   </div>
  </div>
 </body>
</html>