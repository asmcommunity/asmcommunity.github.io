<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Hybrid Knuth-Pratt-Morris Algorithm - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=3837" />
  <link rel="prev" href="../?id=3837&amp;page=1" />  <link rel="next" href="../?id=3837&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=3837">Hybrid Knuth-Pratt-Morris Algorithm</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=3837&amp;page=1" style="">&laquo;</a><a href="../?id=3837&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="3837" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=3837&amp;page=3">&gt;</a><a href="../?id=3837&amp;page=3">&raquo;</a></form>   <div class="post" id="post-26348">
    <div class="subject"><a href="#post-26348">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">I found a flaw again, this is a fix :) I'm learning, I'm learning :)<br /><br /><pre><code><br /><br />&#91;size=9&#93;<br /><br />Test Case&#58; String Source&#58; hello cruel world<br />           String To Search&#58; lo<br /><br />Cause&#58; Bad Shift<br /><br />Problem&#58;<br /><br />First Attempt&#58;<br />hello cruel world<br />l<br /><br />Second Attempt&#58;<br />hello cruel world<br /> l<br /><br />Third Attempt&#58;<br />hello cruel world<br />  l<br />  <br />Fourth Attempt&#58;<br />hello cruel world<br />  lo<br />  <br />Fifth Attempt&#58;<br /><br />hello cruel world<br />    l<br />...<br /><br />As you can see between the 4th and 5th attempt it had a bad shift so,<br />we must return to the byte we started comparing. To fix that, here it is...<br /><br />UKPM PROC USES ebx esi edi srcStr&#58;DWORD, fndStr&#58;DWORD<br /><br />    xor     eax, eax<br />    xor     ebx, ebx<br />    xor     ecx, ecx<br />    xor     edx, edx<br />    mov     esi, srcStr<br />    mov     edi, fndStr<br />    <br />    @@KPMSCAN&#58;<br />    <br />        inc     ecx<br />        mov     dl, BYTE PTR &#91;edi&#93;<br />        or      edx, edx<br />        jz      @@KPMSTOPSCAN<br />        mov     al, BYTE PTR &#91;esi+ecx-1&#93;<br />        or      eax, eax<br />        jz      @@KPMSTOPSCAN<br />        cmp     al, dl<br />        jne     @@KPMRESETSCAN<br />        inc     edi<br />        or      ebx, ebx<br />        jnz     @@KPMSCAN<br />        mov     ebx, ecx<br />        jmp     @@KPMSCAN<br />        <br />    @@KPMRESETSCAN&#58;<br />&#91;color=blue&#93;    <br />        or      ebx, ebx<br />        jz      @@KPMSEARCHCONTIN<br />        mov     ecx, ebx<br />        xor     ebx, ebx<br /><br />    @@KPMSEARCHCONTIN&#58;<br />&#91;/color&#93;<br />        mov     edi, fndStr<br />        jmp     @@KPMSCAN<br />    <br />    @@KPMSTOPSCAN&#58;<br />        <br />        or      edx, edx<br />        jnz     @@KPMEXIT<br />        or      eax, eax<br />        jz      @@KPMEXIT<br />        mov     eax, ebx<br />        ret<br />        <br />    @@KPMEXIT&#58;<br />    <br />        xor     eax, eax<br />        ret<br />    <br />UKPM ENDP<br /><br />&#91;color=blue&#93;<br />I'll just add this lame strlen for everybody to use &#58;&#41;<br />and this one has no bugs I'm pretty sure &#58;&#41;<br /><br />Return value in ECX<br />&#91;/color&#93;<br /><br />strlen PROC srcStr&#58;DWORD<br /><br />    xor     ecx, ecx<br />    mov     esi, srcStr<br />    <br />    @@&#58;<br />    <br />        mov     al, BYTE PTR &#91;esi+ecx&#93;<br />        inc     ecx<br />        or      al, al<br />        jnz     @b<br />    <br />    dec     ecx<br /><br />    ret<br /><br />strlen ENDP<br /><br />&#91;/size&#93;<br /><br /></code></pre><br /><br />Sorry for the mistake :)<br /><br /><br />I moved up the xor ebx, ebx that was after the label @@KPMSEARCHCONTIN: to save a few cycles when executing a non matching byte.</div>
    <div class="meta">Posted on 2002-02-27 22:58:28 by stryker</div>
   </div>
   <div class="post" id="post-26356">
    <div class="subject"><a href="#post-26356">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">I would like to thank all the people who have responded to this thread and the sites I mentioned. To wrap all things up here is a program that will do a search using this algorithm. I hope you'll find this useful. The controls of this program are pretty basic, just be careful <strong>find</strong> and <strong>find next</strong> have 2 different jobs. If you click on <strong>find</strong> it will always start at the first byte of the string, if you click on <strong>find next</strong> it will continue what has been started by the <strong>find</strong> button. Try entering a lot of string combo on the big edit box and your search terms on the small one to test its limits. I've tested this algorithm rigorously using a lot of string combinations and found :) no bugs :) If there are bugs, that you'll find, please let me know. Thank You All!!! :alright:<br /><br /><br />Happy ASMing!!!</div>
    <div class="meta">Posted on 2002-02-28 00:57:10 by stryker</div>
   </div>
   <div class="post" id="post-26362">
    <div class="subject"><a href="#post-26362">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">If i'm not wrong : just a little change that makes you disappear a &quot;mov edi, fndStr&quot; and remove a jumping overhead.<br />(It is untested and I'm very tired these days then please take care to test it).<br /><br />Your original version in blue, my additions/changes in green<br /><br /><div class="quote">UKPM PROC USES ebx esi edi srcStr:DWORD, fndStr:DWORD<br /><br />    xor     eax, eax<br />    xor     ebx, ebx<br />    xor     ecx, ecx<br />    xor     edx, edx<br />    mov     esi, srcStr<br />    @@KPMRESCAN:<br />    mov     edi, fndStr<br />    <br />    @@KPMSCAN:<br />    <br />        inc     ecx<br />        mov     dl, BYTE PTR <br />        or      edx, edx<br />        jz      @@KPMSTOPSCAN<br />        mov     al, BYTE PTR <br />        or      eax, eax<br />        jz      @@KPMSTOPSCAN<br />        cmp     al, dl<br />        jne     @@KPMRESETSCAN<br />        inc     edi<br />        or      ebx, ebx<br />        jnz     @@KPMSCAN<br />        mov     ebx, ecx<br />        jmp     @@KPMSCAN<br />        <br />    @@KPMRESETSCAN:<br />    <br />        or      ebx, ebx<br />        ;jz @@KPMSEARCHCONTIN<br />         jz @@KPMRESCAN<br />        mov     ecx, ebx<br />        xor     ebx, ebx<br /><br />    ;@@KPMSEARCHCONTIN:<br /><br />        ;mov edi, fndStr<br />        ;jmp     @@KPMSCAN<br />        <br />        jmp @@KPMRESCAN<br />   <br /><br />    <br />    @@KPMSTOPSCAN:<br />        <br />        or      edx, edx<br />        jnz     @@KPMEXIT<br />        or      eax, eax<br />        jz      @@KPMEXIT<br />        mov     eax, ebx<br />        ret<br />        <br />    @@KPMEXIT:<br />    <br />        xor     eax, eax<br />        ret<br />    <br />UKPM ENDP<br /></div></div>
    <div class="meta">Posted on 2002-02-28 01:53:30 by JCP</div>
   </div>
   <div class="post" id="post-26364">
    <div class="subject"><a href="#post-26364">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">and if you reorganize a bit your initialization code you can suppress a xor ebx, ebx somewhere... but I'm not sure if it would not result in a bit slower initialization code (pairing).<br />I can't benchmark nor test here : annoying. :mad:</div>
    <div class="meta">Posted on 2002-02-28 02:10:31 by JCP</div>
   </div>
   <div class="post" id="post-26368">
    <div class="subject"><a href="#post-26368">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">Readiosys, that's great, I tested it and it worked!!! :alright: great job. And I must say, I've learned a lot :) But as for xor ebx, ebx you really need to have it as part of the initialization. Because the problem always lies if the match is found at the first byte. Anyway, I'll do some benchmarking tomorrow, it's getting late here.<br /><br />BTW, yours is 1 instruction less than mine. :) Also, I tried to hide the xor ebx, ebx before a label to save a cycle during a first byte mismatch.<br /><br />:)</div>
    <div class="meta">Posted on 2002-02-28 02:38:41 by stryker</div>
   </div>
   <div class="post" id="post-26371">
    <div class="subject"><a href="#post-26371">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">First, I'm happy it worked and it is smaller and faster. ;)<br />It is possible we can do even more things like that... I only had a quick look to it...<br /><br />About ebx, I know you need it but I was thinking to do something like :<br /><br /><pre><code><br />xor eax, eax <br />xor ebx, ebx <br />xor ecx, ecx <br />xor edx, edx <br />mov esi, srcStr <br />@@KPMRESCAN&#58; <br />mov edi, fndStr <br /></code></pre><br /><br />becomes<br /><br /><pre><code><br />xor eax, eax <br />xor ecx, ecx <br />xor edx, edx <br />mov esi, srcStr<br />&#91;color=green&#93;@@KPMRESCANebx&#58;<br />xor ebx, ebx&#91;/color&#93;  <br />@@KPMRESCAN&#58; <br />mov edi, fndStr<br /></code></pre><br /><br />---<br /><br /><pre><code><br />or ebx, ebx <br />jz @@KPMRESCAN <br />mov ecx, ebx <br />xor ebx, ebx <br />jmp @@KPMRESCAN <br /></code></pre><br /><br />becomes<br /><br /><pre><code><br />or ebx, ebx <br />jz @@KPMRESCAN<br />mov ecx, ebx <br />&#91;color=blue&#93;;xor ebx, ebx ;We do not need it to be there anymore&#91;/color&#93;<br />&#91;color=green&#93;jmp @@KPMRESCANebx&#91;/color&#93;<br /></code></pre><br /><br />The xor ebx, ebx dissapeared but is still executed... it is only a size optimization, I don't really think it will be faster...<br />The inconvenient is the changes in the initialization routine perhaps breaks some pairing rules... it is something to test... and if it works well, please find a better name for the label  @@KPMRESCANebx : the name I gave to is not explicit at all in an algo implementation routine... ;)</div>
    <div class="meta">Posted on 2002-02-28 02:56:04 by JCP</div>
   </div>
   <div class="post" id="post-26372">
    <div class="subject"><a href="#post-26372">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">I'll check this out tomorrow :) I need sleep :) yawn :) to really test that it works just replace my proc on kmp.asm and try these strings for testing.<br /><br />In case you want to know. This is how I test my procedures<br /><pre><code><br />Source String&#58; Hello Cruel World<br />Search Terms&#58; 1&#58; He<br />              2&#58; llo<br />              3&#58; l0<br />              4&#58; ld<br />              5&#58; d<br />              6&#58; orld<br />              7&#58; ue<br />              8&#58; lo<br /><br />Source String&#58; elelelelelelelelelelelelelaaaaaleleleleeelllel<br />Search Terms&#58; 1&#58; el<br />              2&#58; le<br />              3&#58; al<br />              4&#58; la<br />              5&#58; lx<br />And lastly do anything random<br /></code></pre><br /><br />I'll try to code up your idea tomorrow. Thanks!!!</div>
    <div class="meta">Posted on 2002-02-28 03:03:50 by stryker</div>
   </div>
   <div class="post" id="post-26373">
    <div class="subject"><a href="#post-26373">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">Ok, good night ;)<br /><br />Maybe this is better for pairing : please test them both since I don't know which is the best... this second solution seems more logical than the first one though... (the four xor are rassembled into the same code block while the first one breaks this harmony by inserting the mov esi, srcStr between the xor instructions).<br /><br /><pre><code><br />&#91;color=green&#93;mov esi, srcStr&#91;/color&#93;<br />xor eax, eax <br />xor ecx, ecx <br />xor edx, edx <br />@@KPMRESCANebx&#58;<br />xor ebx, ebx  <br />@@KPMRESCAN&#58; <br />mov edi, fndStr<br /></code></pre></div>
    <div class="meta">Posted on 2002-02-28 03:20:02 by JCP</div>
   </div>
   <div class="post" id="post-26424">
    <div class="subject"><a href="#post-26424">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">Readiosys, Here it is and it still does the same thing:<br /><br /><pre><code><br /><br />&#91;size=9&#93;<br />UKPM PROC USES ebx esi edi srcStr&#58;DWORD, fndStr&#58;DWORD<br /><br />    mov     esi, srcStr<br />    xor     eax, eax<br />    xor     ecx, ecx<br />    xor     edx, edx<br />    <br />    @@KPMRESETEBX&#58;<br />    <br />        xor     ebx, ebx<br />    <br />    @@KPMRESCAN&#58;<br /><br />        mov     edi, fndStr<br /><br />    @@KPMSCAN&#58;<br /><br />        inc     ecx<br />        mov     dl, BYTE PTR &#91;edi&#93;<br />        or      edx, edx<br />        jz      @@KPMSTOPSCAN<br />        mov     al, BYTE PTR &#91;esi+ecx-1&#93;<br />        or      eax, eax<br />        jz      @@KPMSTOPSCAN<br />        cmp     al, dl<br />        jne     @@KPMRESETSCAN<br />        inc     edi<br />        or      ebx, ebx<br />        jnz     @@KPMSCAN<br />        mov     ebx, ecx<br />        jmp     @@KPMSCAN<br /><br />    @@KPMRESETSCAN&#58;<br /><br />        or      ebx, ebx<br />        jz      @@KPMRESCAN<br />        mov     ecx, ebx<br />        jmp     @@KPMRESETEBX<br />        <br />    @@KPMSTOPSCAN&#58;<br /><br />        or      edx, edx<br />        jnz     @@KPMEXIT<br />        or      eax, eax<br />        jz      @@KPMEXIT<br />        mov     eax, ebx<br />        ret<br /><br />    @@KPMEXIT&#58;<br /><br />        xor     eax, eax<br />        ret<br /><br />UKPM ENDP<br />&#91;/size&#93;<br /><br /></code></pre><br /><br />BTW, this is now 2 instructions less than the original one :)<br /><br /><br />Happy ASMing!!!</div>
    <div class="meta">Posted on 2002-02-28 10:53:38 by stryker</div>
   </div>
   <div class="post" id="post-26432">
    <div class="subject"><a href="#post-26432">congratz</a></div>
    <div class="body">Hi<br /><br />I like this thread and your small &quot;Hybrid-KPM&quot;, umberg. <br /><br />Just a small question:<br /><br />What is the faster method:<br /><br />using Repne Scasb or the way, umberg does it (with manually increase ecx and edi, mov     al, BYTE PTR  and so on) ?<br />I was of the opinion that string instructions are faster Wrong or right?<br /><br />Thx and HAND!<br />:cool:</div>
    <div class="meta">Posted on 2002-02-28 11:21:54 by Rennsemmel</div>
   </div>
   <div class="post" id="post-26433">
    <div class="subject"><a href="#post-26433">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">scasb is slower</div>
    <div class="meta">Posted on 2002-02-28 11:24:47 by The Svin</div>
   </div>
   <div class="post" id="post-26438">
    <div class="subject"><a href="#post-26438">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">Thanks, rensemmel. Svin's right scasb is slower, it'll take you more cycles for this instruction. I'll dig up more on MMX and change the routines to MMX ones, I should be able to remove most of the jump instruction, maybe :)</div>
    <div class="meta">Posted on 2002-02-28 12:15:24 by stryker</div>
   </div>
   <div class="post" id="post-26483">
    <div class="subject"><a href="#post-26483">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">We russian programmers have a joke that there are only<br />three men in the whole world who understand what is<br />KMP algorithm and how it works.<br />Their names are Knuth, Morris and ... you know who else :)<br /><br />I see the joke can be applied not only to our programmers but<br />also to this whole board :)<br />I'm the only who say that it is not KMP algo.<br />I gave you already the algo with both sceme of the algo and one<br />possible realization.<br />Why do you not have a look and think how it works?<br /><br />When you reset search you always start comparing from begining<br />of pattern string.<br />It is against KMP logic.<br />What you did is simple forward search.<br />You may call it UM algo but stop call it KMP algo.<br /><br />Steve, you too had better learn what KMP is before confusing<br />umberg6007 with you remarks.</div>
    <div class="meta">Posted on 2002-02-28 17:50:47 by The Svin</div>
   </div>
   <div class="post" id="post-26496">
    <div class="subject"><a href="#post-26496">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">Alex,<br /><br />Its sheer ignorance on my part, when I needed a table based search system, I poked through the technical data and went in the direction of BM, not KPM so I have not done the work there.<br /><br />I think umberg6007 is developing a hybrid algo that may end up being a UMB search algo and I think thats great. I will leave the label for it up to him as he is the one developing it.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-02-28 19:23:55 by hutch--</div>
   </div>
   <div class="post" id="post-26509">
    <div class="subject"><a href="#post-26509">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">Just converted this KPM algo - I haven't tested this, yet.<pre><code>;  Knuth-Morris-Pratt Algorithm<br />; ==============================<br />; - performs the comparisons from left to right<br />; - preprocessing phase in O&#40;m&#41; space and time complexity<br />; - searching phase in O&#40;n+m&#41; time complexity &#40;independent from the alphabet size&#41;<br />; - delay bounded by log&#40;m&#41; where the base of the log is the golden ratio<br />;<br />;void KMP&#40;char *x, int m, char *y, int n&#41; &#123;<br />;    int i, j, kmpNext&#91;XSIZE&#93;;<br />;<br />;    /* Preprocessing */<br />;    i = 0;<br />;    j = kmpNext&#91;0&#93; = -1;<br />;    while &#40;i &lt; m&#41; &#123;<br />;       while &#40;j &gt; -1 &amp;&amp; x&#91;i&#93; != x&#91;j&#93;&#41; j = kmpNext&#91;j&#93;;<br />;       i++; j++;<br />;       if &#40;x&#91;i&#93; == x&#91;j&#93;&#41;<br />;          kmpNext&#91;i&#93; = kmpNext&#91;j&#93;;<br />;       else<br />;          kmpNext&#91;i&#93; = j;<br />;    &#125;<br />;<br />;    /* Searching */<br />;    i = j = 0;<br />;    while &#40;j &lt; n&#41; &#123;<br />;       while &#40;i &gt; -1 &amp;&amp; x&#91;i&#93; != y&#91;j&#93;&#41; i = kmpNext&#91;i&#93;;<br />;       i++; j++;<br />;       if &#40;i &gt;= m&#41; &#123;<br />;          OUTPUT&#40;j - i&#41;;<br />;          i = kmpNext&#91;i&#93;;<br />;       &#125;<br />;    &#125;<br />; &#125;<br /><br />KMP PROC uses ebx esi edi, x&#58;DWORD, m&#58;DWORD, y&#58;DWORD, n&#58;DWORD<br />	LOCAL kmpNext&#91;256&#93;&#58;DWORD<br /><br />_i TEXTEQU &lt;ecx&gt;<br />_i TEXTEQU &lt;edx&gt;<br />_x TEXTEQU &lt;esi&gt;<br />_y TEXTEQU &lt;edi&gt;<br /><br />	mov _x,x<br />	mov _y,y<br /><br />	; Preprocessing<br /><br />	xor _i, _i<br />	mov _j, -1<br />	mov &#91;kmpNext&#93;, _j<br />	jmp @F<br />preLoop&#58;<br />	mov _j, &#91;kmpNext + _j*4&#93;<br />	mov al,&#91;_x + _i&#93;<br />	cmp al,&#91;_x + _j&#93;<br />	jne preLoop<br />@@&#58;	inc _j<br />	inc _i<br />	push &#91;kmpNext + _j*4&#93; ; assume kmpNext&#91;j&#93;<br />	mov al,&#91;_x + _i&#93;<br />	cmp al,&#91;_x + _j&#93;<br />	je @F<br />	mov &#91;esp&#93;, _j<br />@@&#58;	pop &#91;kmpNext + _i*4&#93;<br />	cmp _i, m<br />	jne preLoop<br /><br /><br />	; Searching<br /><br />	xor _i, _i<br />	xor _j, _j<br />sLoop&#58;<br />	test _i, _i<br />	js @F<br />	mov al, &#91;_y + _j&#93;<br />	cmp al, &#91;_x + _i&#93;<br />	je @F<br />	mov _i, &#91;kmpNext + _i*4&#93;<br />	jmp sLoop<br />@@&#58;	inc _i<br />	inc _j<br />	cmp _i, m<br />	jge Output<br />@@&#58;	cmp _j, n<br />	jl sLoop<br /><br />	mov eax,-1<br />	ret<br />Output&#58;<br />	mov eax, _j<br />	sub eax, _i<br />;	mov _i, &#91;kmpNext + _i*4&#93;<br />;	jmp @B ; get next...<br />	ret<br />KMP ENDP</code></pre>Fairly straight forward conversion - I haven't optimized, yet. :)<br /><br /><strong>Edit</strong>: Already found a <u>bug<strong>s</strong></u> in the conversion...will fix...<br /><br />Once I have increase my understanding, then I'll code it from an assembly perspective.  This is the first part of my process.  Looking at the flow of the data at the machine level.<br /><br />Here is some good text on the algo:<br /><a target="_blank" href="http://www1.ics.uci.edu/~eppstein/161/960227.html">http://www1.ics.uci.edu/~eppstein/161/960227.html</a><br />PHP: <a target="_blank" href="http://www.iezzi.ch/algodat/kmp.php">http://www.iezzi.ch/algodat/kmp.php</a><br />CAML: <a target="_blank" href="http://pauillac.inria.fr/coq/contribs/kmp.html">http://pauillac.inria.fr/coq/contribs/kmp.html</a><br />C: <a target="_blank" href="http://www-igm.univ-mlv.fr/~lecroq/string/node8.html">http://www-igm.univ-mlv.fr/~lecroq/string/node8.html</a></div>
    <div class="meta">Posted on 2002-02-28 20:37:54 by bitRAKE</div>
   </div>
   <div class="post" id="post-26510">
    <div class="subject"><a href="#post-26510">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">About this very algo I can say - it IS KMP :)<br />I just don't understand one this - why you keep calling it<br />KPM - even at start of you source written:<br />Knuth-Morris-Pratt<br />so it is K M P</div>
    <div class="meta">Posted on 2002-02-28 20:57:00 by The Svin</div>
   </div>
   <div class="post" id="post-26516">
    <div class="subject"><a href="#post-26516">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">Ok, I'll take  a look at the source code but you also have to consider the link, bitrake gave. I just want to explain how my algo works and I say it's kmp/kpm.<br /><br /><pre><code><br /><br /><br />     0  1  2  3  4  5  6  7  8  9 10 11<br />      T&#58; b  a  n  a  n  a  n  o  b  a  n  o<br /><br />    i=0&#58; X<br />    i=1&#58;    X<br />    i=2&#58;       n  a  n  X<br />    i=3&#58;          X<br />    i=4&#58;             n  a  n  o<br />    i=5&#58;                X<br />    i=6&#58;                   n  X<br />    i=7&#58;                         X<br />    i=8&#58;                            X<br />    i=9&#58;                               n  X<br />    i=10&#58;                                 X<br /><br /><br /></code></pre><br /><br />You might not agree to it since I said on my earlier posts that there are variations to it, and I say mine belongs to the first one(<a target="_blank" href="http://www1.ics.uci.edu/~eppstein/161/960227.html">http://www1.ics.uci.edu/~eppstein/161/960227.html</a> ).<br /><br />This site gives you an example and that's how my algo works!</div>
    <div class="meta">Posted on 2002-02-28 21:23:31 by stryker</div>
   </div>
   <div class="post" id="post-26519">
    <div class="subject"><a href="#post-26519">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">umberg6007:<br />I don't need any sites to learn anything about KMP.<br />Since I have all that Mr. D.Knuth wrote on my bookshelf.<br />Let me say it straight? May I?<br />I tried as I may in my previous post.<br />You'd better read the same site twice. And more carefull.<br />You analyzed just first picture-sceme and missunderstood the whole idea. One shift forward is just in WORST case. In better case shift more than one.<br />I'm done it's my last post on the topic.</div>
    <div class="meta">Posted on 2002-02-28 21:45:02 by The Svin</div>
   </div>
   <div class="post" id="post-26520">
    <div class="subject"><a href="#post-26520">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">You can have may variations to KMP, but saying mine is not KMP is wrong, and I have prove my algorithm that it does what first version of what the site says. I have noticed that what bitrake and you have done is the second one. I'm sure you are an open minded person but please for discussion sakes, take a look at that site and prove me wrong that I didn't do the KMP algo.</div>
    <div class="meta">Posted on 2002-02-28 21:49:48 by stryker</div>
   </div>
   <div class="post" id="post-26522">
    <div class="subject"><a href="#post-26522">Hybrid Knuth-Pratt-Morris Algorithm</a></div>
    <div class="body">Give me Donald Knuth work were he discribe this algo as KMP.<br />In the site is first step explonation is not KMP but material wich preparing learners to KMP idea.<br />In original it starts even earlier Knuth starts explonation from broot-force search - but it does not make broot-force search KMP algo.</div>
    <div class="meta">Posted on 2002-02-28 21:59:39 by The Svin</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=3837&amp;page=1" style="">&laquo;</a><a href="../?id=3837&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="3837" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=3837&amp;page=3">&gt;</a><a href="../?id=3837&amp;page=3">&raquo;</a></form>  </div>
 </body>
</html>