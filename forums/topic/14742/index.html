<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>a byte - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=14742" />
    <link rel="next" href="../?id=14742&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=14742">a byte</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=14742&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=14742&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="14742" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=14742&amp;page=2">&gt;</a><a href="../?id=14742&amp;page=2">&raquo;</a></form>   <div class="post" id="post-114214">
    <div class="subject"><a href="#post-114214">a byte</a></div>
    <div class="body">it is true that a byte is 8bits; and a kilobyte is 1024 bytes. why not 1000 bytes instead? and a text which is one byte in size have 256 diff. characters bec. it is ranging from 00000000B - 11111111B(which is 255), therefore 256 all in all. i have read a book that explains this as 2^8(2x2x2x2x2x2x2x2) why?</div>
    <div class="meta">Posted on 2003-08-18 04:32:23 by 010101</div>
   </div>
   <div class="post" id="post-114215">
    <div class="subject"><a href="#post-114215">a byte</a></div>
    <div class="body">Is this a joke ?<br /><br />The processor operates in binary, everything *must* be a power of 2</div>
    <div class="meta">Posted on 2003-08-18 04:44:26 by donkey</div>
   </div>
   <div class="post" id="post-114217">
    <div class="subject"><a href="#post-114217">a byte</a></div>
    <div class="body">Lol, that one was good. But it's the kind of thread I would expect on &quot;Visual Basic for beginners&quot; board, not here.</div>
    <div class="meta">Posted on 2003-08-18 05:13:33 by iwabee</div>
   </div>
   <div class="post" id="post-114218">
    <div class="subject"><a href="#post-114218">Re: a byte</a></div>
    <div class="body"><div class="quote">it is true that a byte is 8bits; </div><br />really? why some computers have DIMMs with n*9 chips? :grin: <br />ansver: because of ECC<br /><br />computers have memory. memory is a plenty of bits (0 or 1)<br />if we want use 010101010101010101010101010110100 numbers we don't need 104 keys on keyboard:grin:<br />so alternatives:<br />0,1,2,3,10,12,13  (2bit per digit)<br />0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17,20 (3 bit)<br />0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,10,11,... (4 bit)<br />or another alfabet thal latin<br /><br />more compact are HEX digits (4bit). HEX+HEX=BYTE <br />so byte is 8 bits: 00h...FFh<br /><br />if we will use decimal sistem, we'll waste 6 values of every halfbyte, because of this VB programs are probably 60% larger than asm ones :grin:<br /><br />so I count 0,1,2,3,4,5,6,7,8,9,a,b,c,d,...<br />NOT 1,2,3,4,5,6,7,8,9,10<br />:stupid:</div>
    <div class="meta">Posted on 2003-08-18 05:45:37 by S.T.A.S.</div>
   </div>
   <div class="post" id="post-114219">
    <div class="subject"><a href="#post-114219">a byte</a></div>
    <div class="body">thanks to you all but... what i mean is that why 2^8(is 8 has something to do with 8 bits)i mean *mathematical* explanation for this; the thought is something like this in every 8 bits there is 256 different combinations. the base which is 2 is bec. of two bits 0 and 1?</div>
    <div class="meta">Posted on 2003-08-18 06:02:55 by 010101</div>
   </div>
   <div class="post" id="post-114220">
    <div class="subject"><a href="#post-114220">a byte</a></div>
    <div class="body">:rolleyes:<br />in base 2:<br />1 bit - 2 values: 0, 1 = 2^1<br />2 bits - 4 values: 00, 01, 10, 11 = 2^2<br />3 bits - 8 values: 000, 001, 010, 011, 100, 101, 110, 111 = 2^3<br />4 bits - 16 values: 0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111 = 2^4<br />etc.<br />in base 10:<br />1 digit - 10 values: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 = 10^1<br />2 digits - 100 values: ...... = 10^2<br /><br />Take whatever base you want (b) and number of digits you want to use (n). Make calculation b^n, and you will know how many different values there can be.<br /><br />You really have to change that nick of yours, you know.</div>
    <div class="meta">Posted on 2003-08-18 06:53:39 by iwabee</div>
   </div>
   <div class="post" id="post-114221">
    <div class="subject"><a href="#post-114221">a byte</a></div>
    <div class="body"><div class="quote">it is true that a byte is 8bits; and a kilobyte is 1024 bytes. why not 1000 bytes instead? </div> <br />:grin: The closest number to 1000 made with base 2 number is 1024 or 2^10. <br /><br />You ask why a byte is 2^8. My question is what other unit do you propose?</div>
    <div class="meta">Posted on 2003-08-18 07:28:56 by roticv</div>
   </div>
   <div class="post" id="post-114222">
    <div class="subject"><a href="#post-114222">a byte</a></div>
    <div class="body">2^8(2x2x2x2x2x2x2x2) i think is incorrect, if you do tht, then you have some like ((2^8)^(2x2x2x2x2x2x2x2)), that become (2^8)^(256) that become (2^(8*256)) that become 2^(2048).... or the other posibility is<br /><br />2^8(2x2x2x2x2x2x2x2) if you take 2^8 like a factor and (2x2x2x2x2x2x2x2) like other factor, you have 256*256... that is a incorrect expresion in this context<br /><br /><br /><br /><br /><br />I think the correct expresion for 2^8(2x2x2x2x2x2x2x2) is:<br /><br />2^8 = (2x2x2x2x2x2x2x2) = 256 in decimal.<br /><br /><br /><div class="quote"><br />The processor operates in binary, everything *must* be a power of 2<br /></div><br /><br />Not necesarily true, the computer work with electric circuits, this now are digital, this means some like a &quot;onda&quot;<br /><br /><pre><code><br />-------<br />         |          |<br />         |          |<br />-&gt;here the zerito &#58;D -------------  0 zero<br />         |          |<br />         |          |<br />         ----------<br /></code></pre><br /><br />Here you have a complete cycle Ghz cycles per second... (clock frequenky) how many instructions can do the procesor in a sec.., but you see that have two posible ------, we can call it like you want patatoes, zanaorias, gitomates, guacamole, but we choice to call this for simplicity 0 and 1<br /><br /><br />The computer work with group of bits ;) yea, not with a single bit, you can call the groups of bits like this (if i am not wrong):<br /><br /><pre><code><br /># of bits            name<br /><br />4                        nible<br />8                        byte<br />16                      word<br />32                      doubleword<br />64<br />128<br />256<br />.... like you see i not remember all ;&#41; you can call a page &#40;if i am not wrong&#41; to 1024 bits &#40;or bytes ???? lol &#58;D&#41;, i think is 1024 bits.<br /></code></pre><br />The computer... (here try visualize)... think in a avenue (a computer that work with bytes, the old ones) have 8 'streets', the 16 have 16 streets, 32 have 32, 64 have 64, 128 have 128. like you see a computer can not only work with one single bit, work with groups, the timer (reloj in spanish) is useful for diferentiate if are one 1 or 5 1 in a simgle street. See this 'graph'<br /><br /><pre><code><br />--------           -----<br />          |          |    |<br />          |          |    |<br />          |          |    |<br />          |          |    |<br />          ----------<br /></code></pre><br /><br />like you see the first a secuence like this ---------, you know that this is the higher value, but you dont know how many '1s' have this, this is the work of the timer, if you timer take 5 - this is -----  this secuence will be procesed (or the computer take the behaviour) like 11001, but if the clock...... ahhhh is clock not timer ;) lolol, ok, but if the clock take only 1 - then this secuence become 1111111111000000000011111 haha, now you see the diference for this, is that the clock frequency, see the diference between 11001 (a 5 1s) and 1111111111000000000011111  (1 by 1), now remember that the cpu work with groups, then think this in paralel 8 streets, or 16 or 32 or 64 or 1024 (some day)<br /><br /><br />Now you can compare two aproach more streets... or more fast clock frequency.... more fast (not much) maybe intel, but amd can too, more streets, some say me that sun i think in g4 64 or work with more complex cpu.<br /><br />In that view poit, more streets require a more 'sophisticated' cpu or more complex in the design. And the fast cause that the cpu is not cool... burn... up the temperature.... this is for the faraday law. Then the mix of both &quot;techniques&quot; more fast and more streets is not easy, you need combine burn up with more complexity, this not mean that a procesor of 32 bits is not hard of write ;), but a 64 have a little more internal complexity.<br /><br /><pre><code><br />-                     -<br />    -            -<br />        -      -<br />           -<br /></code></pre><br /><br />This is a like analogic signal, all the signals difering of the  medium that they move have distortion or 'ruido', then this signal can be touched like this by the interference.<br /><br /><pre><code><br />                      -<br />-    -            -<br />        -      <br />           -   - <br /></code></pre><br /><br />This is for what analogic copy never have the same fidelity that the original.. say  that some music where you go to grab a song ... the copys that they produce have too this dificulty, but they have filters for try give a signal a cleanup for the interference... and the copys of home.. simply dont have this type of equip for clean a little the signal...., then what append with a digital signal???, the same, can have interference, but for what a raw digital copy can have the same quality than theoriginal???, simply by this:<br /><br />the original:<br /><br /><pre><code><br />------------------<br />                      |<br />                      |<br />                      |<br />                      |<br />                      --------------------<br /></code></pre><br />with distortion or interference:<br /><br /><pre><code><br />--  -     ---------<br />   -  ---            |<br />                      |<br />                      |<br />                      |      --     --<br />                      ------  ----  -----<br /></code></pre><br />but  you know that the diferences, all that is near to top or hig is 1 and all that is near to bottom is 0, then no more problems &quot;assuming&quot; this, and without filters you have the same output assuming higest are 1 and lowet are 0<br /><pre><code><br />------------------<br />                      |<br />                      |<br />                      |<br />                      |<br />                      --------------------<br /></code></pre><br /><br /><br />Also a last note... a teacher say me that the called byte is not always 8, in other computers are 16... and i think.. then maybe can be 4, 3 or 64, but like a standar a byte is 8 bits ;)<br /><br />The comversions come like :<br /><br /><div class="quote"><br />if we want use 010101010101010101010101010110100 numbers we don't need 104 keys on keyboard<br /></div><br /><br />ascii is a conversion of this, your keyboard simply do his job converting the specific keystroke to the specific bytes.. or if you prefer bits ro more true electric signal.<br /><br /><br /><br /><br /><br /><br />More that what you want?? :D<br /><br />Have nice day.</div>
    <div class="meta">Posted on 2003-08-18 08:22:41 by rea</div>
   </div>
   <div class="post" id="post-114259">
    <div class="subject"><a href="#post-114259">a byte</a></div>
    <div class="body"><strong>hgb</strong> a byte is always 8 bits. A word is machine dependant, the 386 -&gt; Pentium4 are all 32 bit word machines (i.e. they have an internal data bus of 32 bits in width). For historical reasons we still refer to the WORD and DWORD (double word), but this is because of the origins of the x86 architecture.<br /><br />Mirno</div>
    <div class="meta">Posted on 2003-08-18 15:11:18 by Mirno</div>
   </div>
   <div class="post" id="post-114268">
    <div class="subject"><a href="#post-114268">a byte</a></div>
    <div class="body">hi hgb, sorry for that, what i mean there is 2 raise to the power of 8. hence 2^8; or (2x2x2x2x2x2x2x2). and you're right.<br /><br /><div class="quote">can call it like you want patatoes, zanaorias, gitomates, guacamole, but we choice to call this for simplicity 0 and 1</div> <br />^yes. that is right^<br /><br />i have read the post of iwabee, right? how come that in base 2:<br /><div class="quote">1 byte - 2 options: 0, 1 = 2^1</div> <br />the mere fact that 1 byte is *8 bits* and for this, we have 00000000,00000001,00000010.... upto 11111111. or am i getting myself wrong?</div>
    <div class="meta">Posted on 2003-08-18 16:37:15 by 010101</div>
   </div>
   <div class="post" id="post-114269">
    <div class="subject"><a href="#post-114269">a byte</a></div>
    <div class="body">actually a byte is 9 bits, not 8...associated with each byte is a parity bit, and when the computer starts up a parity check is performed so that the number of 1 bits in each byte is either odd or even (i forget if it has to be even or odd) and the parity bit gets set accordingly...this parity check is performed by the hardware so we dont have to worry abt it at all and it happens super fast</div>
    <div class="meta">Posted on 2003-08-18 16:41:36 by AnotherWay83</div>
   </div>
   <div class="post" id="post-114272">
    <div class="subject"><a href="#post-114272">a byte</a></div>
    <div class="body">iwabee had a typo, he meant that a <strong>bit</strong> has two values, a <strong>byte</strong> has 256 possible values and a <strong>word</strong> has 65536 possible values. The formula 2^nBits holds true in all cases. I think that you should google for some info on the binary number systems, the people who will answer your questions here are not the right ones to ask. For the most part we can all do binary and hex conversions in our heads and in some cases our explanations will take too much knowledge on your part for granted. Google for a binary arithmetic primer or just something that explains how different radix (bases) work.<br /><br />A byte is 8 bits *not* 9 the parity bit is used to verify the byte and is not part of the data. It is simply a checksum, do not confuse the parity with part of the byte or anything that can be considered useable data.<br /><br />Anyway this guy is yanking our chain, nobody who has done any programming at all can be so unfamiliar with the concept of binary.</div>
    <div class="meta">Posted on 2003-08-18 16:48:16 by donkey</div>
   </div>
   <div class="post" id="post-114273">
    <div class="subject"><a href="#post-114273">a byte</a></div>
    <div class="body">you're wrong, coz you've just answered my question. thanks.</div>
    <div class="meta">Posted on 2003-08-18 17:04:21 by 010101</div>
   </div>
   <div class="post" id="post-114274">
    <div class="subject"><a href="#post-114274">a byte</a></div>
    <div class="body"><div class="quote"><em>Originally posted by donkey </em><br /><br />A byte is 8 bits *not* 9 the parity bit is used to verify the byte and is not part of the data. It is simply a checksum, do not confuse the parity with part of the byte or anything that can be considered useable data.<br /><br /></div><br /><br />yes, of course u're rite, u cannot use the parity bit urself in any meaningful way, but since there is a parity bit for each byte, i dont think its wrong to think of it that way, and thats how its even described in Peter Abel's IBM PC Assembly Language and Programming :grin:</div>
    <div class="meta">Posted on 2003-08-18 17:08:03 by AnotherWay83</div>
   </div>
   <div class="post" id="post-114275">
    <div class="subject"><a href="#post-114275">a byte</a></div>
    <div class="body">Then Abel was wrong if he explained it that way. For the most part on the machine level there is not even a parity bit. It is just generated by circuitry as the byte is read and not even stored in memory. The early IBM PC's used parity RAM but that is exceedingly rare, it is now nothing more than a bit generated by the MMU when fetching a byte. I think you should email Abel and correct him, it is not part of the byte and is no longer resident even in memory.</div>
    <div class="meta">Posted on 2003-08-18 17:15:36 by donkey</div>
   </div>
   <div class="post" id="post-114280">
    <div class="subject"><a href="#post-114280">a byte</a></div>
    <div class="body"><div class="quote"><strong>A byte is 8 bits *not* 9</div><br />It's easy to see: open your comp case and count chips that are on DIMM ;)<br />you'll see: 4, 8,  or 16 (not 9 or 18)<br /><br />really just about 5% chipsets use ECC, since RAM is far more stable than 20 years ago<br /><br />so BYTE=8 BITs - that's basis of the matter</div>
    <div class="meta">Posted on 2003-08-18 17:54:24 by S.T.A.S.</div>
   </div>
   <div class="post" id="post-114285">
    <div class="subject"><a href="#post-114285">a byte</a></div>
    <div class="body">Wierd thread...<br /><br />Anywho, ya, just to add:<br /><br />1 Bit = one or a zero (2^1)<br />1 Nibble = 4 Bits (2^2)<br />1 Byte = 2 Nibbles = 8 bits (2^3)<br />1 Word = 2 Bytes = 4 Nibbles = 16 Bits (2^4)<br />1 DWord = 4 Bytes = 8 Nibbles = 32 Bits (2^5)<br />1 QWord = 8 Bytes = 16 Nibbles = 64 Bits (2^6)<br />???????? = 16 Bytes = 32 Nibbles = 128 Bits (2^7)<br />???????? = 32 Bytes = 64 Nibbles = 256 Bits (2^8)<br />???????? = 64 Bytes = 128 Nibbles = 512 Bits (2^9)<br />1k (in computer lingo) = 1,024 = (2^10)<br />1Meg (in computer lingo ) = 1,048,576 = (2^20)<br />1Gig ( in computer lingo ) = 1,073,741,824 = (2^30)<br /><br />???????? == No defined name that im aware of.<br /><br /><br /><br />With this knowlege, any size should be easy to figure out in your head different number from the amount of bits.<br /><br />Say i had 17 bits, then the number of unique states is 2^7 * 2^10 = 128 * 'k' = 128k bit states (or 128k different numbers)<br /><br />A well known one is 16bit = 2^6 * 2^10 = 64k <br /><br />32bits = 2^2 Gig = 4Gig.. (the magic number in the windows os ;) )<br /><br />:NaN:</div>
    <div class="meta">Posted on 2003-08-18 19:20:02 by NaN</div>
   </div>
   <div class="post" id="post-114288">
    <div class="subject"><a href="#post-114288">a byte</a></div>
    <div class="body">128 bits = Double Quad Word DQWORD according to the AMD 64 bit manual</div>
    <div class="meta">Posted on 2003-08-18 19:48:49 by donkey</div>
   </div>
   <div class="post" id="post-114404">
    <div class="subject"><a href="#post-114404">not just a byte</a></div>
    <div class="body">---------------------------------------------------------------------------<br />The hardware calculates the effective address in such a way that the result is always a 20-bit number. Thus, the effective address can range from 000000h to FFFFFFh. This gives you 100000h possible addresses.<br />---------------------------------------------------------------------------<br />it's clear that it is said above that 100000h different possibilities, different possibilities.<br />continued...<br />----------------------------------------------------------------------------<br />In other words, by using a combination of segment addresses and offsets, the processor can address up to 100000h bytes of memory. This is equal to 1024K bytes of 1 megabyte, a vast improvement over 64k.<br />----------------------------------------------------------------------------<br />here it is said that the processor can address up 100000h bytes of memory; how come that it can access that *bytes* though it is said before that *different* possible address; i think... it can access that MANY diff. address but only 16-bit???<br />like 0-9; ten different possible nos. but only one digit right???not 2 digit like 10?</div>
    <div class="meta">Posted on 2003-08-19 09:08:25 by 010101</div>
   </div>
   <div class="post" id="post-114409">
    <div class="subject"><a href="#post-114409">a byte</a></div>
    <div class="body">Win32 uses a flat 32 bit memory model, that means that there are no segment registers to play with, the offset can address the full range of memory without segments. So the addressable range in Win32 is 2^32 or 4 Gig. The article you are quoting deals with DOS addressing technique, as for the issue of how the addressable range is calculated that has been beaten to death in this thread.</div>
    <div class="meta">Posted on 2003-08-19 09:38:31 by donkey</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=14742&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=14742&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="14742" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=14742&amp;page=2">&gt;</a><a href="../?id=14742&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>