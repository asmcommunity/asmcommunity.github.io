<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Loading GIF, JPG, BMP, WMF files and viewing them - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4015" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=4015">Loading GIF, JPG, BMP, WMF files and viewing them</a></p>
   <div class="post" id="post-27406">
    <div class="subject"><a href="#post-27406">Loading GIF, JPG, BMP, WMF files and viewing them</a></div>
    <div class="body">Found this and like to archive it :)<br />------------------8&lt;----------------------<br />When I was developing the early beta versions of my new Windows application, EVE (see <a target="_blank" href="http://myeve.org">http://myeve.org</a>), a vector graphics drawing program, it needed to be able to load and insert bitmap graphics images. That is, I wanted to load a graphic file and display it in my application's window.<br /><br />Now, there are libraries available to do this, some of them free. They don't have source code, except for one, called GIFLIB, with MASM source code -- see a link to it from Hutch's MASM site. GIFLIB only loads GIF files.<br />I used it for the first release of my EVE product, however it is bit buggy and crashes on some GIFs -- the LZW decompressor is the part that crashes.<br /><br />After much hunting around, I found a technical article on Microsoft's web site, describing a program called LOADPIC -- you should be able to locate it from &quot;LOADPIC&quot; as a keyword. This is a C++ program that uses the OleLoadPicture() function. This function is very high-level and will convert GIF, JPG, BMP and WMF files into a format that can be displayed, including the decompressing.<br /><br />This function is not described in Microsoft's SDKs prior to 1998, though the docs state that it works on Win95 -- I haven't tested my program on a wide range of Win95 systems -- the function is in OLEPRO32.DLL and it may not be in older Win95 systems, though I suspect that most will have it, as it is likely that a later application will have loaded it when it got installed.<br /><br />The problem is, I knew nothing about OLE (Object Linking and Embedding) and COM (Common Object Model). For MASM programmers, there's a whole lot of stuff on this topic at Hutch's asm site (or was that Iczelion's site? -- whatever), submitted by Ernie Murphy. Also, this COM stuff is at Ernie's own site: <a target="_blank" href="http://here.is/COMinASM.">http://here.is/COMinASM.</a><br /><br />Ok, to tackle this, I took the LOADPIC.CCP application and compiled it using the free Borland C++ compiler -- it gave lots of compile errors, because the code was designed for Microsoft's Visual C++. But, I had set a switch on the compiler to generate an asm file, and at least the compiler got as far as that.<br />Armed with the asm file, I was able to figure out the code required for my program, however, the key function, OleLoadPicture(), returned an error code. So, I emailed my code to Ernie for his perusal. This greatly intrigued Ernie, as he had no idea that there was such a function to load graphics images (as is the case for just about every other Win32 programmer). Ernie has converted LOADPIC.CCP to LOADPIC.ASM and it is now available at his site.<br /><br />Ernie's approach is very professional, and you have to include lots of macros, include files and link in various library files. I successfully assembled his example program, but I decided to have another look at my original &quot;grassroots&quot; solution. I discovered the bug that was preventing OleLoadPicture() to work, so I have placed my code below. The only extra libraries that you have to link to are OLEPRO32.LIB and OLE32.LIB -- you can find these from various places.<br /><br />You'll need these two prototypes:<br /><pre><code><br />CreateStreamOnHGlobal PROTO WINAPI, &#58;DWORD, &#58;DWORD, &#58;DWORD<br />OleLoadPicture PROTO WINAPI, &#58;DWORD, &#58;DWORD, &#58;DWORD, &#58;DWORD, &#58;DWORD<br /></code></pre><br /><br />I'm talking MASM code here, but you should be able to translate to C or whatever.<br /><br />I'll leave it up to you to write the code to open a file and load it into a memory block. Note that Ernie's example has the code for that. Let's say we have loaded the file and have variable &quot;pmem&quot; pointing to the memory block...<br /><br />Here is my grassroots code for converting the file into a form that can be displayed:<br /><pre><code><br />.DATA<br />IID_IPicture DWORD 07bf80980h ;unsigned long.<br />             WORD 0bf32h      ;unsigned short.<br />             WORD 0101ah      ;unsigned short<br />             BYTE 08bh,0bbh,0,0aah,0,030h,0ch,0abh ;unsigned char Data4&#91;8&#93;;<br />;0x7bf80980,0xbf32,0x101a,0x8b,0xbb,0,0xaa,0,0x30,0xc,0xab<br /><br />gpPicture DWORD 0<br />E_POINTER EQU 080000005h<br />E_NOINTERFACE EQU 080000004h<br />E_OUTOFMEMORY EQU 080000002h<br /><br />.CODE<br />creategifhdc PROC STDCALL USES ebx ecx edx esi edi, \<br />  pobj&#58;DWORD,pmem&#58;DWORD,p1stdataelement&#58;DWORD<br />  LOCAL hglobal&#58;DWORD,pstm&#58;DWORD,hr&#58;DWORD<br />  LOCAL widthpixels&#58;DWORD,heightpixels&#58;DWORD<br />  LOCAL hmwidth&#58;DWORD,hmheight&#58;DWORD<br />;ret eax=0 ok, else error#.<br />;we enter func with pmem-&gt;bitmap-file-in-memory.<br />  mov gpPicture,0<br /></code></pre><br /><br />For the OLE/COM functions to use it, the memory block has to be converted into something called a &quot;stream&quot; -- don't ask me what the difference is ...<br /><br /><pre><code><br />;now need to convert the mem-block into a &quot;stream&quot;...<br />  invoke GlobalHandle,pmem<br />  mov hglobal,eax<br />  invoke CreateStreamOnHGlobal,hglobal,TRUE,ADDR pstm<br />  ;...returns pstm =ptr to stream &#40;i.e. copy of the mem block&#41;.<br />  ;returns eax=0 if ok<br />  .IF eax != 0<br />    mov eax,220<br />    jmp er0<br />  .ENDIF<br /></code></pre><br /><br />When I created the memory block, I saved its size, which I'm retrieving here, and calling the magical function OleLoadPicture(). IID_IPicture is a structure that defines what type of information is to be loaded, in this case a graphic image. This function will place a pointer into variable gpPicture, that points to an &quot;interface&quot; -- this is basically a structure, with addresses of &quot;methods&quot; (functions) that can manipulate the data...<br /><br /><pre><code><br /> mov eax,mygifinfo.dwGIFDataSize ;size of mem block.<br />  invoke OleLoadPicture,pstm,eax,0,ADDR IID_IPicture,ADDR gpPicture<br />  ;...&quot;IID_IPicture&quot; is the type of interface pointer to return.<br />  ;...The requested interface pointer is returned in &quot;gpPicture&quot;.<br />  ;returns eax=0 if ok<br />  .IF eax != 0 ;S_OK=0<br />    .IF eax==E_POINTER<br />      mov eax,222<br />    .ELSEIF eax==E_NOINTERFACE<br />      mov eax,223<br />    .ELSEIF eax==E_OUTOFMEMORY<br />      mov eax,224<br />    .ELSE<br />      .IF SDWORD PTR eax&lt;0<br />        mov eax,221 ;E_UNEXPECTED<br />      .ELSE<br />        jmp ok9<br />      .ENDIF<br />    .ENDIF<br />    jmp er0<br />  .ENDIF<br />ok9&#58;<br /></code></pre><br /><br />I don't need the &quot;stream&quot; anymore. Also, it wasn't in the original LOADPIC code, but I presumed that I also needed to free the original memory block (does releasing the stream also delete the original memory block? -- I have no idea). Release() is a method, and has to be accessed in this manner (see Ernie's code for a more formal way of doing this)...<br /><br /><pre><code><br /> mov eax,pstm            ;pstm-&gt;Release&#40;&#41;;<br />  push eax                ;/<br />  mov edx,dword ptr &#91;eax&#93; ;/<br />  call dword ptr &#91;edx+8&#93;  ;/<br />  ;umm, presume can release original mem block?...<br />  invoke GlobalFree,hglobal<br /></code></pre><br /><br />I need to call some more methods to get the width and height of the graphic, but they are returned in &quot;himetric&quot; units. I have converted these to pixels. Earlier in my program, in the handling of the WM_CREATE message, I had calculated the variables xscreenpixels and yscreenpixels, using this code:<br /><pre><code><br />          ;find out the resolution of the display...<br />          invoke GetDC, g_hwnd ;--&gt;eax=display context client area.<br />          mov hdc1,eax<br />          invoke GetDeviceCaps, hdc1,LOGPIXELSX ;query pixels/inch.<br />          mov xscreenpixels,eax<br />          invoke GetDeviceCaps, hdc1,LOGPIXELSY ;query pixels/inch.<br />          mov yscreenpixels,eax<br />          invoke ReleaseDC, g_hwnd,hdc1<br /></code></pre><br />So, I can convert the himetric units to pixels... <br /><br />;the picture is now ready to be painted... gpPicture points (indirectly) to it...<br /><pre><code><br />  lea eax,hmwidth             ;gpPicture-&gt;get_Width&#40;&amp;hmWidth&#41;<br />  push eax                    ;/<br />  mov edx,dword ptr gpPicture ;/<br />  push edx                    ;/<br />  mov ecx,dword ptr &#91;edx&#93;     ;/ &#40;hmwidth is in himetric units&#41;<br />  call dword ptr &#91;ecx+24&#93;     ;/<br />  lea eax,hmheight            ;gpPicture-&gt;get_Height&#40;&amp;hmHeight&#41;<br />  push eax                    ;/<br />  mov edx,dword ptr gpPicture ;/<br />  push edx                    ;/<br />  mov ecx,dword ptr &#91;edx&#93;     ;/<br />  call dword ptr &#91;ecx+28&#93;     ;/ &#40;hmheight is in himetric units&#41;<br />  ;the wwidth and height are in HIMETRIC units. for output to screen, need<br />  ;the width/height in pixels...<br />  mov eax,hmwidth<br />  mul xscreenpixels <br />  mov ecx,2540<br />  div ecx<br />  mov widthpixels,eax<br />  mov eax,hmheight<br />  mul yscreenpixels <br />  mov ecx,2540<br />  div ecx<br />  mov heightpixels,eax<br /></code></pre><br /><br />This section of code below is just for my own EVE program. I have an element that is to display on the screen and it has to hold gpPicture, the coordinates of the element on the diagram, and width/height in both pixels and himetric units. When EVE processes the WM_PAINT message, this info is retrieved from the element...<br /><br />;the picture is going to be painted in common_paint_bitmap(), and need to<br />;setup the icon now and pass stuff...<br /><pre><code><br />  mov eax,gpPicture<br />  mov ebx,p1stdataelement<br />  mov &#40;OBJECT PTR &#91;ebx&#93;&#41;.ximage,eax<br />  ;also, save width/height of bitmap into icon...<br />  ;and update xmid/ymid...<br />  mov edi,pobj<br />  mov eax,widthpixels<br />  mov &#40;OBJECT PTR &#91;edi&#93;&#41;.wwidth,eax<br />  shr eax,1<br />  add eax,&#40;OBJECT PTR &#91;edi&#93;&#41;.xtopleft<br />  mov &#40;OBJECT PTR &#91;edi&#93;&#41;.xmid,eax<br />  mov eax,heightpixels<br />  mov &#40;OBJECT PTR &#91;edi&#93;&#41;.height,eax<br />  shr eax,1<br />  add eax,&#40;OBJECT PTR &#91;edi&#93;&#41;.ytopleft<br />  mov &#40;OBJECT PTR &#91;edi&#93;&#41;.ymid,eax<br />  ;also need to save wwidth/height of image in 1st data-element...<br />  mov eax,&#40;OBJECT PTR &#91;edi&#93;&#41;.wwidth<br />  mov WORD PTR &#40;OBJECT PTR &#91;ebx&#93;&#41;.nshape,ax ;&#40;alias for rplock2&#41;.<br />  mov eax,&#40;OBJECT PTR &#91;edi&#93;&#41;.height<br />  mov WORD PTR &#40;OBJECT PTR &#91;ebx&#93;&#41;.nshape+2,ax<br />  ;save the width/height in himetric units in the icon...<br />  mov eax,hmwidth<br />  mov &#40;OBJECT PTR &#91;edi&#93;&#41;.widthhimetric,eax<br />  mov eax,hmheight<br />  mov &#40;OBJECT PTR &#91;edi&#93;&#41;.heighthimetric,eax<br /><br />ok1&#58;<br />  xor eax,eax ;ok.<br />  ret<br />er1&#58; mov eax,219 ;error.<br />er0&#58; ret<br />creategifhdc ENDP<br /></code></pre><br /><br />Ok, so we've got this gpPicture pointer and the width/height of the image, in both himetric units and pixels. When the application processes the WM_PAINT message, you can have this code:<br /><br /><pre><code><br />;width/height in pixels...<br />  mov esi,&#40;OBJECT PTR &#91;edi&#93;&#41;.wwidth<br />  mov widthpixels,esi<br />  mov ebx,&#40;OBJECT PTR &#91;edi&#93;&#41;.height<br />  mov heightpixels,ebx<br />;width/height in himetric units...<br />  mov esi,&#40;OBJECT PTR &#91;edi&#93;&#41;.widthhimetric<br />  mov widthhimetric,esi<br />  mov ebx,&#40;OBJECT PTR &#91;edi&#93;&#41;.heighthimetric<br />  mov heighthimetric,ebx<br />  mov ebx,p1stdataelement<br />  mov eax,&#40;OBJECT PTR &#91;ebx&#93;&#41;.ximage ;gpPicture ;hDCBitmap<br />  mov ecx,&#40;OBJECT PTR &#91;edi&#93;&#41;.xtopleft<br />  mov edx,&#40;OBJECT PTR &#91;edi&#93;&#41;.ytopleft<br /><br />; // display picture using IPicture&#58;&#58;Render<br />; gpPicture-&gt;Render&#40;hdc, 0, 0, nWidth, nHeight, 0, hmHeight, hmWidth, -hmHeight, &amp;rc&#41;;<br />  ; lea ebx,clientrect<br />  ; push ebx ;0 ;really need addr of client rect here. ? &#40;for wmf file&#41;<br />  push 0<br />  mov ebx,heighthimetric  ;needs to be -ve, otherwise picture<br />  neg ebx                 ;displays upside down. see also below topcorner.<br />  push ebx                ;heighthimetric ;y height to copy from source picture. himetric<br />  push widthhimetric      ;x width to copy from source picture. units.<br />  push heighthimetric     ;upper-left corner of source, NOTE, not 0.<br />  push 0                  ; / himetric units.<br />  push heightpixels       ;height diagram coords.<br />  push widthpixels        ;wwidth /<br />  push edx             ;0 ;y upper-left corner,<br />  push ecx             ;0 ;x diagram coords.<br />  push hdc                ;hdc.<br />  ; mov eax,dword ptr gpPicture<br />  push eax<br />  mov edx,dword ptr &#91;eax&#93;<br />  call dword ptr &#91;edx+32&#93;<br /></code></pre><br /><br /><br />Ok, so as my program draws each element to the screen, it gets the gpPicture variable and the width/height parameters out. Then we call a method of the IPicture interface, called Render(). <br /><br />The basic structure of the code described above allows more than one picture to be simultaneously loaded and displayed. However, gpPicture points to an &quot;interface&quot; that points to methods (functions) as well as the actual bitmap data. So, when finished it is necessary to release the interface. My EVE program flushes these gpPicture's whenever a diagram is saved, as well as when the EVE program is exited. Here is the code to release a gpPicture interface:<br /><br /><pre><code><br />mov eax,&#40;OBJECT PTR &#91;esi&#93;&#41;.ximage<br />.IF eax != 0<br />  mov edx,eax       ;gpPicture ;gpPicture-&gt;Release&#40;&#41;;<br />  push edx                     ;/ &quot;this&quot; has to be passed, which is a ptr<br />  mov ecx,dword ptr &#91;edx&#93;      ;/ to the interface.<br />  call dword ptr &#91;ecx+8&#93;       ;/<br />  mov &#40;OBJECT PTR &#91;esi&#93;&#41;.ximage,0<br />.ENDIF<br /></code></pre><br /><br />What EVE does is look through the elements in the database, and the .ximage parameter has gpPicture if the entry is non-zero. I then call the Release() method. Simple.<br /><br />There you are, it works real nice. Have a look at my EVE site: <a target="_blank" href="http://myeve.org/">http://myeve.org/</a> or <a target="_blank" href="http://www4.tpg.com.au/users/void/eve_web/">http://www4.tpg.com.au/users/void/eve_web/</a><br /><br />Regards,<br />Barry Kauler<br /><a target="_blank" href="http://www4.tpg.com.au/users/void/bkauler">http://www4.tpg.com.au/users/void/bkauler</a></div>
    <div class="meta">Posted on 2002-03-05 18:55:26 by syntax_error</div>
   </div>
   <div class="post" id="post-28916">
    <div class="subject"><a href="#post-28916">Loading GIF, JPG, BMP, WMF files and viewing them</a></div>
    <div class="body">I added code tags to the post (and lost my edit button in the process)</div>
    <div class="meta">Posted on 2002-03-14 01:09:54 by Ernie</div>
   </div>
  </div>
 </body>
</html>