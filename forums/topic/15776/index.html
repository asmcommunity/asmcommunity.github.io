<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Using XOR - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=15776" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=15776">Using XOR</a></p>
   <div class="post" id="post-122241">
    <div class="subject"><a href="#post-122241">Using XOR</a></div>
    <div class="body">I know how to use AND &amp; OR but I don't know how and when to use XOR. I know that 1 XOR 1=0, 0 XOR 1=1 and so forth, but that doesn't help me much, I can't &quot;see&quot; the bits in front of me the same way I do when using OR and AND. Could someone give me a good XOR example so I can gain deeper knowledge of the XOR operation?</div>
    <div class="meta">Posted on 2003-10-23 14:00:58 by Delight</div>
   </div>
   <div class="post" id="post-122243">
    <div class="subject"><a href="#post-122243">Using XOR</a></div>
    <div class="body">Erm... you use it when you want some bits that are 1 to become 0, and bits that are 0 to become 1. It's useful when you want to negate part of a number, or toggle some flags in a flag variable.</div>
    <div class="meta">Posted on 2003-10-23 14:14:18 by Sephiroth3</div>
   </div>
   <div class="post" id="post-122246">
    <div class="subject"><a href="#post-122246">Re: Using XOR</a></div>
    <div class="body">Or, for instance, if you need to know, which bits are different:<br /><br /><div class="quote"><br />XOR AL,BL:<br />10101010=AL before<br />10101001=BL before<br />-------------<br />00000011=AL after<br /></div><br /><br />&quot;NOT operand&quot; performs the same operation as &quot;XOR operand,-1&quot;.</div>
    <div class="meta">Posted on 2003-10-23 14:54:18 by MazeGen</div>
   </div>
   <div class="post" id="post-122247">
    <div class="subject"><a href="#post-122247">Using XOR</a></div>
    <div class="body">I use it mainly to flip flags around ;)<br /><br />xor , TRUE<br /><br />Makes False become True and True become False.</div>
    <div class="meta">Posted on 2003-10-23 15:09:54 by JimmyClif</div>
   </div>
   <div class="post" id="post-122249">
    <div class="subject"><a href="#post-122249">Using XOR</a></div>
    <div class="body"><pre><code><br />XOR Table<br />  ----------------------------- <br /> Start | XORed with | Result <br /> ----------------------------- <br /> 0     | 1          | 1 <br /> 0     | 0          | 0 <br /> 1     | 0          | 1 <br /> 1     | 1          | 0<br /><br />OR<br /><br />  ----------------------------- <br /> Start | ORed with  | Result <br /> ----------------------------- <br /> 0     | 1          | 1 <br /> 0     | 0          | 0 <br /> 1     | 0          | 1<br /> 1     | 1          | 1 <br /></code></pre></div>
    <div class="meta">Posted on 2003-10-23 15:30:59 by devilsclaw</div>
   </div>
   <div class="post" id="post-122251">
    <div class="subject"><a href="#post-122251">Using XOR</a></div>
    <div class="body">ANDing bits with 0 clears them (to 0)<br />ORing bits with 1 sets them (to 1)<br />NOT 10010000 toggles all the bits to 01101111 (1's complement)<br />NOT is not the same as NEG (which is used to change signs)<br /><br />XORing bits with 1 toggles them<br /><br />Say, if i want to toggle the states of bits 4, 5, and 7, i would use the following<br /><br />10101000<br />10110000  XOR<br />============<br />00011000  =<br /><br />which simply indicates XORing using 1 toggles the state of bits.<br /><br />XOR has another purpose, to clear a register to 0<br />for example,<br /><br />XOR eax, eax<br /><br />is equivalent to<br /><br />MOV eax, 0<br /><br />since 1 XOR 1 = 0 <br />and <br />0 XOR 0 = 0</div>
    <div class="meta">Posted on 2003-10-23 15:37:38 by art_sands</div>
   </div>
   <div class="post" id="post-122252">
    <div class="subject"><a href="#post-122252">Using XOR</a></div>
    <div class="body">For the most part, the result is the unmatch bit positions = 1, matched bit positions = 0.  It a great operator to find what is different in operands.  Good for testing state of flags or software conditions.<br /><br />Beside zeroing a register like, XOR EAX,EAX.<br /><br />Regards,  P1 :cool:</div>
    <div class="meta">Posted on 2003-10-23 15:41:20 by Pone</div>
   </div>
   <div class="post" id="post-122257">
    <div class="subject"><a href="#post-122257">Using XOR</a></div>
    <div class="body">A couple other ways of viewing XOR.<br /><br />1) As logic statement<br /><br />The normal Boolean OR is the inclusive OR:  either A is true or B is true <strong>or both</strong>.<br /><br />With two operands, the exclusive OR rejects the previous last case: either A is true or B is true <strong>but not both</strong>.<br /><br />2) As Boolean addition<br /><br />XOR is the same as binary addition except <strong>the carry is ignored</strong>.<br /><br />0 + 0 = 0, 0 XOR 0 = 0<br />0 + 1 = 1, 0 XOR 1 = 1<br />1 + 0 = 1, 1 XOR 0 = 1<br />1 + 1 = (1)0, 1 XOR 1 = 0<br /><br />For bit masking:<br /><br />AND to <strong>extract</strong> bits with a bit mask<br />AND to <strong>clear</strong> bits with a complemented bit mask<br />OR to <strong>set</strong> bits with a bit mask<br />XOR to <strong>complement</strong> bits with a bit mask<br /><br />Some algorithms, like CRC calculation, use XOR simply as a function without any reference to its other meanings.</div>
    <div class="meta">Posted on 2003-10-23 17:52:19 by tenkey</div>
   </div>
   <div class="post" id="post-122262">
    <div class="subject"><a href="#post-122262">From calculator</a></div>
    <div class="body">Logic operators are operand who decide if the door whil open or not<br /><br />In the case of XOR <br />Think about two corridors who bring to one door.<br />each corridor have a detector to know if we have someone inside<br />the rule is dont open the door if 2 guy there<br /><br />MOV EAX, <br />XOR EAX, <br /><br />EAX = 1 If only one guy there....<br /><br />I hope that is helping you a bit .....<br /><br />0100000100101011</div>
    <div class="meta">Posted on 2003-10-23 20:17:33 by BinBin</div>
   </div>
   <div class="post" id="post-122271">
    <div class="subject"><a href="#post-122271">Using XOR</a></div>
    <div class="body">Another way of seeing XOR:<br /><br />XOR reverses the bits in the destination that are set in the source.<pre><code>FOR i = 0 TO 31<br />  IF bit&#40;source, i&#41;<br />    bit&#40;destination, i&#41; = NOT bit&#40;destination, i&#41;<br />  ENDIF<br />NEXT i</code></pre>...viewing it this way really helps optimization of some algorithms.</div>
    <div class="meta">Posted on 2003-10-23 21:46:54 by bitRAKE</div>
   </div>
   <div class="post" id="post-122274">
    <div class="subject"><a href="#post-122274">Using XOR</a></div>
    <div class="body">I like thinking of it by just what its name means, Exclusive.<br /><br />The &quot;Exclusive&quot; OR operation is best used to identify differences between two sources that are Exclusive between themselfs.  This means &quot;report back a value of 1 if either register is different, while evaluating it on a bit level&quot;. <br /><br />When applied to things like &quot;XOR EAX, EAX&quot; you end up with EAX = 0 because there is nothing EXCLUSIVELY DIFFERENT between a direct copy of the the source.<br /><br />As pointed out earlier, this nature has good use is bit flipping.  For example, if you wanted to Toggle the value of the 3rd bit in a register EDX, you would use a mask pattern of:<br /><br />&quot;00000000-00000000-00000000-00000100b&quot;<br /><br />At a binary level, the only thing that is EXCLUSIVELY DIFFERENT from '0' is '1'.  If two bits are exclusively different, the definition says to produce a '1' indicating this. So in essence where a 0 bit is used in the mask, to get a result of '1' the only mutially exclusive value from the mask is '1'.  If it was not exclusively different (equal) its definition says to produce a '0', which as well mirrors the only possible value of '0' when the mask is zero, '0' !<br /><br />Where ever a mask bit of '1' ocours, the end result will simply negate instead of mirror the bit in evaluation. Since '1' is now in the mask, to get a result of '1' the only MUTUALLY DIFFERENT bit to produce this result would then be '0' (Which is opposite from each other).  Likewise, to get a result of '0' the only value that ISNT mutually different is then a '1'. (Again opposite from each other).<br /><br /><br />Another case is the &quot;switch&quot; routine:<br /><br />If EAX = 0F0Fh and EBX = 1234h Then the following code:<br /><br />xor EAX, EBX<br />xor EBX, EAX<br />xor EAX, EBX<br /><br />Will result in EAX = 1234h and EBX = 0F0Fh!  Dont believe me?  Well i will show you why: ( ^ = XOR )<br /><br />[1] EAX* = EAX ^ EBX<br />[2] EBX* = EBX ^ EAX* = EBX ^ (EAX ^ EBX) = EBX ^ (EBX ^ EAX) = (EBX ^ EBX) ^ EAX = (0) ^ EAX = EAX<br />[3] EAX** = EAX* ^ EBX* = (EAX ^ EBX) ^ EAX = (EBX ^ EAX) ^ EAX = EBX ^ (EAX ^ EAX) = EBX ^ (0) = EBX<br /><br />In the end, EBX* = EAX and EAX** = EBX.  <br /><br />(1) This is because EAX* is the result of EAX with additional bits set that is MUTUALLY EXCLUSIVE TO EBX only!  EAX* is now mutated with the essence of EBX packed in to iself as well!!.<br /><br />(2) EBX* does the same, but with the 'mutated' source of EAX*.  Seeing this time around EAX* is already packed with all things unique to EBX, the XOR operation finds NOTHING mutually exclusive to EBX in EAX* and as a result negates the mutation.  Thus EBX* = EAX.<br /><br />(3) The previous two operations essentially moved EAX -&gt; EBX. But we still have EAX* which is the mutated version of EAX and EBX we started with.  To correct for this a similar process as (2) above is done to produce EAX**.  EAX** = EAX* ^ EBX*.  Since EBX* is now the origional EAX.  The only thing mutually eclusive from the mutated combination of EAX / EBX  and EAX itself would be EBX!.<br /><br />I hope this helps answer your question, and not confuse you...<br />I thought this would be an easy post, however, writing out how i think has been surprisingly challenging in this area.  ( :P ) <br /><br />Regards,<br />:alright:<br />:NaN:</div>
    <div class="meta">Posted on 2003-10-23 23:32:15 by NaN</div>
   </div>
   <div class="post" id="post-122278">
    <div class="subject"><a href="#post-122278">Using XOR</a></div>
    <div class="body">XOR can be used to create &quot;parity&quot;-disks data (RAID 3 and/or/xor (;)) 5, iirc).<br /><br />Because:<br />A XOR B = C ; 10101010 XOR 11110000 = 01011010<br />A = B XOR C ; 10101010 = 11110000 XOR 01011010<br />B = A XOR C ; 11110000 = 10101010 XOR 01011010<br /><br />So if A, B or  C is &quot;lost&quot;, you can 'caluclate' the lost part by xoring the know values togeter.<br /><br /><pre><code>just had little extra time, so I too write the truth table for xor&#58;<br />Q = A XOR B  &#40; Q = A &#40;+&#41; B, &#40;+&#41; = a plus sign in a circle&#41;<br />A|B|Q<br />-+-+-<br />0|0|1<br />0|1|0<br />1|0|0<br />1|1|0</code></pre></div>
    <div class="meta">Posted on 2003-10-23 23:44:42 by scientica</div>
   </div>
   <div class="post" id="post-122315">
    <div class="subject"><a href="#post-122315">Using XOR</a></div>
    <div class="body">Thanks guys! You have all done a great job explaining how it works and I understand now :alright:</div>
    <div class="meta">Posted on 2003-10-24 07:18:15 by Delight</div>
   </div>
   <div class="post" id="post-122318">
    <div class="subject"><a href="#post-122318">Using XOR</a></div>
    <div class="body">All folks,<br /><br />    The information that all of you provided here was by far excellent on the topic. Would you mind contributing in such small amounts to a book on assembly language and it's use in win32 and linux? I've been trying to structure such a book. The answer to one's question in a forum such as this just keeps getting better and better. So, Hiroshimator figured out that we could use wiki (a collaboration kind of forum where you can edit the content online) to create the book.<br /><br />    The big problem has been, as Randy pointed out, people want stuff from us, but they themselves don't want to share. That's a little unfair, isn't it? After all, the book is for them and, as another matter of fact, free for online reading. So, I encourage you to think about it. Just imagine the quality of the book an entire community could produce. Get in touch with me at the &quot;Let's make a book out of this kb&quot; thread. I sincerely hope all of you generous people out there will do something about it.<br /><br />Regards,<br />Art</div>
    <div class="meta">Posted on 2003-10-24 07:46:04 by art_sands</div>
   </div>
  </div>
 </body>
</html>