<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>ResizeEdit control - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=18292" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=18292">ResizeEdit control</a></p>
   <div class="post" id="post-141546">
    <div class="subject"><a href="#post-141546">ResizeEdit control</a></div>
    <div class="body">In the MSDN, there is a C++ example of how to Resize an edit control, taking into account the font height and standard edit control's 3D border. Basically it just resizes the height. The original C++ code looks like this: <pre><code>void ResizeEdit&#40;HWND hwndEdit, HFONT hNewFont&#41;<br />   &#123;<br />      HFONT       hSysFont,<br />                  hOldFont;<br />      HDC         hdc;<br />      TEXTMETRIC  tmNew,<br />                  tmSys;<br />      RECT        rc;<br />      int         nTemp;      // Get the DC for the edit control.<br />      hdc = GetDC&#40;hwndEdit&#41;;      // Get the metrics for the system font.<br />      hSysFont = GetStockObject&#40;SYSTEM_FONT&#41;;<br />      hOldFont = SelectObject&#40;hdc, hSysFont&#41;;<br />      GetTextMetrics&#40;hdc, &amp;tmSys&#41;;      // Get the metrics for the new font.<br />      SelectObject&#40;hdc, hNewFont&#41;;<br />      GetTextMetrics&#40;hdc, &amp;tmNew&#41;;      // Select the original font back into the DC and release the DC.<br />      SelectObject&#40;hdc, hOldFont&#41;;<br />      DeleteObject&#40;hSysFont&#41;;<br />      ReleaseDC&#40;hwndEdit, hdc&#41;;      // Calculate the new height for the edit control.<br />      nTemp = tmNew.tmHeight + &#40;min&#40;tmNew.tmHeight, tmSys.tmHeight&#41;/2&#41; +<br />      &#40;GetSystemMetrics&#40;SM_CYEDGE&#41; * 2&#41;;      // Re-size the edit control.<br />      GetWindowRect&#40;hwndEdit, &amp;rc&#41;;<br />      MapWindowPoints&#40;HWND_DESKTOP, GetParent&#40;hwndEdit&#41;, &#40;LPPOINT&#41;&amp;rc, 2&#41;;<br />      MoveWindow&#40; hwndEdit,<br />                  rc.left,<br />                  rc.top,<br />                  rc.right - rc.left,<br />                  nTemp,<br />                  TRUE&#41;;<br />   &#125;</code></pre><br />I converted and tested this code to MASM syntax, not for speed purposes, simply for implementation purposes, trying to stick as closely to the original algorithm as possible (without disassembling the C code). My code, for the benefit of others trying to do the same thing: <pre><code>ResizeEdit PROC hwndEdit &#58;DWORD, hNewFont &#58;DWORD<br />  ;; MSDN conversion by SubEvil<br />  LOCAL hSysFont  &#58;DWORD<br />  LOCAL hOldFont  &#58;DWORD<br />  LOCAL hdc       &#58;DWORD<br />  LOCAL tmNew     &#58;TEXTMETRIC<br />  LOCAL tmSys     &#58;TEXTMETRIC<br />  LOCAL rc        &#58;RECT<br />  LOCAL nTemp     &#58;DWORD<br /><br />  INVOKE GetDC, hwndEdit<br />  mov hdc, eax<br />  INVOKE GetStockObject, SYSTEM_FONT<br />  mov hSysFont, eax<br />  INVOKE SelectObject, hdc, hSysFont<br />  mov hOldFont, eax<br />  INVOKE GetTextMetrics, hdc, addr tmSys<br />  INVOKE SelectObject, hdc, hNewFont<br />  INVOKE GetTextMetrics, hdc, addr tmNew<br />  INVOKE SelectObject, hdc, hOldFont<br />  INVOKE DeleteObject, hSysFont<br />  INVOKE ReleaseDC, hwndEdit, hdc<br />  <br />  INVOKE GetSystemMetrics, SM_CYEDGE<br />  add eax, eax ;; Multiply system metrics by 2<br />  mov ecx, tmNew.tmHeight<br />  mov edx, tmSys.tmHeight<br />  add eax, ecx<br />  .IF ecx &gt; edx ;; edx == min<br />    shr edx, 1<br />    add eax, edx<br />  .ELSE ;; ecx &#40;tmNew.tmHeight&#41; == min<br />    shr ecx, 1<br />    add eax, ecx<br />  .ENDIF<br />  mov nTemp, eax<br /><br />  INVOKE GetWindowRect, hwndEdit, addr rc<br />  INVOKE GetParent, hwndEdit<br />  mov ecx, eax ;; Backup incase MASM uses eax for addr rc?<br />  INVOKE MapWindowPoints, HWND_DESKTOP, ecx, addr rc, 2<br />  mov ecx, rc.right<br />  sub ecx, rc.left<br />  INVOKE MoveWindow, hwndEdit, rc.left, rc.top, ecx, nTemp, TRUE<br />  ret<br />ResizeEdit ENDP</code></pre><br />Well, looking at the above code, I felt that:<br />1) The edit control may already have a font in it, why not just resize the control to that (already inside) font. Whether it be the System default font, or another?<br />2) Since we create a new font, 'extract' the original font, then put it back in, seems a little stupid!<br />3) What if the control doesn't have a 3D border? What if it only has a standard border (WS_BORDER) style, like some static controls do.<br />So I enhanced the above algorithm to ResizeHeight, it only needs the hWnd of the control and will resize according to the currently selected font for that control, then check for a 3D or 2D border and add the relevent, per system defined sizes to the height. My new algorithm is both faster, and more accurate and can be used on any (single line) Edit/Static control:<pre><code>ResizeHeight PROC hWnd &#58;DWORD<br />  ;; Written by SubEvil<br />  LOCAL hdc       &#58;DWORD<br />  LOCAL tm        &#58;TEXTMETRIC<br />  LOCAL rc        &#58;RECT<br /><br />  INVOKE GetDC, hWnd<br />  mov hdc, eax<br />  INVOKE GetTextMetrics, hdc, addr tm<br />  INVOKE ReleaseDC, hWnd, hdc<br /><br />  INVOKE GetWindowLong, hWnd, GWL_EXSTYLE<br />  and eax, WS_EX_OVERLAPPEDWINDOW<br />  .IF !Zero? ;; IF !Zero then hWnd = 3D<br />    INVOKE GetSystemMetrics, SM_CYEDGE ;; Get 3D border size!<br />    shl eax, 1 ;; Multiply by 2, for top+bottom / right+left<br />    add tm.tmHeight, eax<br />  .ENDIF<br /><br />  INVOKE GetWindowLong, hWnd, GWL_STYLE<br />  and eax, WS_BORDER<br />  .IF !Zero? ;; IF !Zero then hWnd = 3D<br />    INVOKE GetSystemMetrics, SM_CYBORDER ;; Get 2D border size!<br />    shl eax, 1 ;; Multiply by 2, for top+bottom / right+left<br />    add tm.tmHeight, eax<br />  .ENDIF<br /><br />  INVOKE GetWindowRect, hWnd, addr rc<br />  INVOKE GetParent, hWnd<br />  mov ecx, eax<br />  INVOKE MapWindowPoints, HWND_DESKTOP, ecx, addr rc, 2<br />  mov ecx, rc.right<br />  sub ecx, rc.left<br />  INVOKE MoveWindow, hWnd, rc.left, rc.top, ecx, tm.tmHeight, TRUE<br />  ret<br />ResizeHeight ENDP</code></pre><br />Also, I decided to enhance the algorithm, to provide a method to &quot;Autosize&quot; a control, based on currently selected Font, with minX, minY, maxX, maxY values. If minX or minY are -1, the function will do a true 'autosize', this function uses many personal macros, if there is interest in it, I can convert it, but too much effort if there isn't interest!</div>
    <div class="meta">Posted on 2004-05-20 08:01:56 by SubEvil</div>
   </div>
  </div>
 </body>
</html>