<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Could anyone provide explained code for a calculator, or something similar? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29858" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29858">Could anyone provide explained code for a calculator, or something similar?</a></p>
   <div class="post" id="post-210942">
    <div class="subject"><a href="#post-210942">Could anyone provide explained code for a calculator, or something similar?</a></div>
    <div class="body">Hello, peoples. I&#039;m noobish here... and once again, I must join a forum by asking a question, then finding out I placed it in the wrong area and worded it poorly, thus getting no acceptable answers... But this time might be an exception!&nbsp; :O<br /><br />So I&#039;m noobish to Assembly, and I&#039;ve found a lacking of information elsewhere on the Internet, and got redirected to here by a person. I&#039;m using the NASM assembler, and... it appears as though it isn&#039;t popularly used... but it seems I can&#039;t find any downloads for any other assemblers, and I&#039;ve grown too attached to NASM by now, anyways... <br /><br />I&#039;ve found just about 0 tutorials going anywhere beyond absolute basics. It seems I can find nothing about variables, and nothing about arrays. But.. that&#039;s only partially what I mainly wanted to ask. I figured a calculator could prove to be a good example, though, because it&#039;d require everything I&#039;m wanting to know.. I think...<br /><br />SO, basically, how would user input be stored in a character array? Like, if I type &#039;a&#039;, will that, then, be added to the end of the array, then continue down the process? Are there other, simpler ways of doing this? And how would I declare the existence of this array? <br />And.. how would I take this string and add something to it? If I would type in &#039;5&#039;, then try adding the next user inputted character, &#039;2&#039;, the result would be &#039;g&#039;. <br />Similarly, if I take &#039;5&#039; and &#039;2&#039;, convert them both to plain integers, then add them together, how do I turn them back into a string? I made a thing which gets the current year, and it threw &#039;?&#039; at me as the answer. Surely that&#039;s not this year :/&nbsp; (But then again, my computer&#039;s clock doesn&#039;t like staying set quite right, so I&#039;m usually a little ahead of everyone else ^.^&nbsp; Sometimes days ahead, sometimes years ahead...)<br /><br />And then the easy part is manageable from there... but I&#039;m clueless, and have been searching the Internet for over a week... Help is greatly appreciated. <br />Thank-you in advance to any answers. (if you can figure out where this question should have been placed, and what my incoherent sentences were meant to say)<br /><br />(and note that I&#039;m generally tired and with a severe lacking of sleep, so... actual code for this would be helpful, and preferably with some explanation that&#039;s relatively straightforward... I&#039;m braindead... like, all the time &gt;.&lt;)</div>
    <div class="meta">Posted on 2010-03-10 01:53:10 by Nikumu</div>
   </div>
   <div class="post" id="post-210943">
    <div class="subject"><a href="#post-210943">Re: Could anyone provide explained code for a calculator, or something similar?</a></div>
    <div class="body">^ I notice a lack of an &#039;edit&#039; button... so sorry for double posting...<br /><br />Sorry if there&#039;s already a topic regarding this subject - I found none in my search, thus quickly resigned in my weakness and inability to continue. </div>
    <div class="meta">Posted on 2010-03-10 01:58:41 by Nikumu</div>
   </div>
   <div class="post" id="post-210946">
    <div class="subject"><a href="#post-210946">Re: Could anyone provide explained code for a calculator, or something similar?</a></div>
    <div class="body">First of all: Which assembler? what hardware? which OS?</div>
    <div class="meta">Posted on 2010-03-10 12:02:10 by ti_mo_n</div>
   </div>
   <div class="post" id="post-210948">
    <div class="subject"><a href="#post-210948">Re: Could anyone provide explained code for a calculator, or something similar?</a></div>
    <div class="body"><div class="quote"><br />First of all: Which assembler? what hardware? which OS?<br /></div><br /><br />Haha... I dunno how readable that is at all, as a later statement I tried writing... turned out... horribly.. And I remembered that I probably should have stated these shortly after posting this.<br /><br />NASM Assmbler, Windows XP, and 8086. </div>
    <div class="meta">Posted on 2010-03-10 13:38:28 by Nikumu</div>
   </div>
   <div class="post" id="post-210951">
    <div class="subject"><a href="#post-210951">Re: Could anyone provide explained code for a calculator, or something similar?</a></div>
    <div class="body"><div class="quote"><br />Hello, peoples. I&#039;m noobish here... and once again, I must join a forum by asking a question, then finding out I placed it in the wrong area and worded it poorly, thus getting no acceptable answers... But this time might be an exception!&nbsp; :O<br /></div><br /><br />Eric Raymond has some thoughts about how to ask questions so that the experts will want to help you...<br /><br />http://catb.org/~esr/faqs/smart-questions.html<br /><br /><div class="quote"><br />So I&#039;m noobish to Assembly, and I&#039;ve found a lacking of information elsewhere on the Internet, and got redirected to here by a person. I&#039;m using the NASM assembler, and... it appears as though it isn&#039;t popularly used...<br /></div><br /><br />We&#039;re in the Top 40. With a bullet! :)<br /><br /><div class="quote"><br />but it seems I can&#039;t find any downloads for any other assemblers, and I&#039;ve grown too attached to NASM by now, anyways... <br /></div><br /><br />It&#039;s too late to stop now! :)<br /><br />There are plenty of other assemblers. We can hook you up with a download site,&nbsp; I&#039;m sure, if that&#039;s what you want, but I don&#039;t think it&#039;ll help (they all do the same thing, essentially).<br /><br />FWIW, Nasm 2.08 has just been released - http://www.nasm.us - but the bad news is that a minor glitch has been found in it already - 2.08.01 will be along soon.<br /><br /><div class="quote"><br />I&#039;ve found just about 0 tutorials going anywhere beyond absolute basics. It seems I can find nothing about variables, and nothing about arrays.<br /></div><br /><br />http://www.drpaulcarter.com/pcasm - quite an extensive chapter on arrays...<br /><br /><div class="quote"><br />But.. that&#039;s only partially what I mainly wanted to ask. I figured a calculator could prove to be a good example, though, because it&#039;d require everything I&#039;m wanting to know.. I think...<br /><br />SO, basically, how would user input be stored in a character array?<br /></div><br /><br /><pre><code><br />mov , al<br />inc edi<br /></code></pre><br /><br />...or so, probably. Getting the input depends on your OS.<br /><br /><div class="quote"><br />Like, if I type &#039;a&#039;, will that, then, be added to the end of the array, then continue down the process? Are there other, simpler ways of doing this?<br /></div><br /><br />Any OS will have an input function. &quot;sys_read&quot; for Linux. You mention XP - &quot;ReadFile&quot;, but you&#039;ll have to do &quot;GetStdHandle&quot; first. But you mention 8086 too. That makes me think maybe you&#039;re doing dos - int 21h/0Ah.<br /><br /><div class="quote"><br />And how would I declare the existence of this array? <br /></div><br /><br /><pre><code><br />section .bss<br />input_buffer resb MAX_INPUT + 1<br /></code></pre><br /><br />...maybe?<br /><br /><div class="quote"><br />And.. how would I take this string and add something to it? If I would type in &#039;5&#039;, then try adding the next user inputted character, &#039;2&#039;, the result would be &#039;g&#039;.<br /></div><br /><br />Yeah... adding characters doesn&#039;t work well.<br /><br /><div class="quote"><br />Similarly, if I take &#039;5&#039; and &#039;2&#039;, convert them both to plain integers, then add them together, how do I turn them back into a string?<br /></div><br /><br />Ah! So you do know that you need to do this! Many tutorials relegate this to a macro, or provide a library call (Dr. Carter&nbsp; resorts to &quot;just call printf&quot;... and the horrid scanf, for these chores). Personally, I think it&#039;s an educational exercise to attempt. You&#039;re putting together a series of simple-minded instructions to do something &quot;useful&quot; - with a visible result, and it isn&#039;t likely to do damage if you get it wrong. So I urge you to give it a shot, and see what you come up with.<br /><br />If you need some hints, search for something like &quot;convert string to number&quot;, &quot;convert number to string&quot;, &quot;how do I print a number&quot;, &quot;get number from keyboard&quot;, etc. If you don&#039;t find anything here (I&#039;m sure you will - it is a very frequently asked question!), hop over to the new Nasm forum - http://forum.nasm.us - (supplants the Nasm forum at SourceForge, which has been &quot;improved&quot; so much that it&#039;s totally unusable. IMHO...). I know for a fact that there has been discussion of the subject in recent threads. :)<br /><br />Google groups - alt.lang.asm and comp.lang.asm.x86 would find info on the subject, as well.<br /><br /><div class="quote"><br />I made a thing which gets the current year, and it threw &#039;?&#039; at me as the answer. Surely that&#039;s not this year :/<br /></div><br /><br />I wouldn&#039;t count on that. I&#039;m 65, and every year so far has been &#039;?&#039;. :)<br /><br />You don&#039;t say how you were getting the year. Linux gives us seconds since &quot;the dawn of time&quot; - 01/01/1970. The bios interrupt (if you&#039;re doing dos) returns the values in BCD, as I recall (Binary Coded Decimal). If that&#039;s the case, try printing it as if it were hex.<br /><br />Show it to us! We can probably help you fix it.<br /><br /><div class="quote"><br /> (But then again, my computer&#039;s clock doesn&#039;t like staying set quite right, so I&#039;m usually a little ahead of everyone else ^.^&nbsp; Sometimes days ahead, sometimes years ahead...)<br /></div><br /><br />So how come you&#039;re not showing us how to do it? :)<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-03-11 03:07:53 by fbkotler</div>
   </div>
   <div class="post" id="post-210977">
    <div class="subject"><a href="#post-210977">Re: Could anyone provide explained code for a calculator, or something similar?</a></div>
    <div class="body">Thank-you for the reply :)<br />Hmmm.... my question was worded rather poorly, and thus I apologize. :)&nbsp; <br /><br /><br /><br />So, thus far I seem to have come up with this:<br /><br /><pre><code><br />org 100h<br /><br />section .bss<br />x resb 10h<br />y resb 10h<br /><br />section .text<br /><br />start:<br />mov dx,msg1<br />mov ah,09h<br />int 21h<br /><br />mov ah,01h&nbsp;  ; Input x<br />int 21h<br />sub al,30h<br />mov ,al<br /><br />mov dx,newl&nbsp;  ; New line<br />mov ah,09h<br />int 21h<br /><br />mov dx,msg2&nbsp;  ; Print msg2<br />mov ah,09h<br />int 21h<br /><br />mov ah,01h&nbsp;  ; Input y<br />int 21h<br />sub al,30h<br />add al,&nbsp;  ; Add x+y<br />mov ,al<br /><br />mov dx,newl&nbsp;  ; New line<br />mov ah,09h<br />int 21h<br /><br />mov dx,msg3&nbsp;  ; Print msg3<br />mov ah,09h<br />int 21h<br /><br />mov bx,&nbsp;  ; Print the result<br />add bx,30h<br />mov dx,bx<br />mov ah,06h<br />int 21h<br /><br />mov ah,07h&nbsp;  ; Pause<br />int 21h<br />mov ah,4Ch<br />int 21h<br /><br />msg1 db &#039;Enter a number&#039;,0Ah,0Dh,&#039; --&gt;&nbsp; $&#039;<br />msg2 db &#039;Enter another number&#039;,0Ah,0Dh,&#039; --&gt;&nbsp; $&#039;<br />msg3 db &#039;The answer is: &#039;,0Dh,0Ah,&#039; --&gt;&nbsp; $&#039;<br />newl db 0Ah,0Dh,24h<br /></code></pre><br /><br />Although this has multiple faults: <br />Neither x or y can hold more then one character (easily fixable)<br />The result can be no greater than 9, lest various characters be thrown out<br /><br />I&#039;m thinking that I know how to convert a string to a number now.. so that&#039;s of minimal priority. Find the string length, subtract 48 from each character, and then multiply accordingly; if I entered &#039;145&#039;, take away 48 from each character, then multiply the 1 by 100, 4 by 10, and 5 by 1, and add them all together into one number. <br /><br />But... then I&#039;m still rather clueless as to how to do the same thing in reverse..... I read on.. somewhere (I seem to have exited the tab)&nbsp; that it can be done by doing the same thing in reverse: repeatedly dividing by ten, then adding the remainder to the end of the end of an array. But... the &#039;div&#039; is confusing me... thus far I&#039;ve failed to get it to work. (it&#039;s all of NASM&#039;s fault - it&#039;s just not cooperating; I have naught to do with this)&nbsp; How does div work? <br /><br /><pre><code><br />mov dx,8<br />mov ax,2<br />div ax<br /></code></pre><br />is the best I&#039;ve come up with, and it keeps returning 1 (or, rather, a mocking smiley face O.o). Clearly I&#039;m not using it correctly... But, what is the proper usage? I&#039;m left clueless and dumbfounded once more... and my mad Googling skillz are failing me... (pretty epic... the searches that seem to meet the best results are the ones questioning the purpose of features of cats; &quot;why do cats purr&quot;, &quot;why do cats have tails&quot;, etc.)<br /><br />Or am I mistaken in saying that dividing in the above named manner would work? <br /><br /><br />&quot;You don&#039;t say how you were getting the year. Linux gives us seconds since &quot;the dawn of time&quot; - 01/01/1970. The bios interrupt (if you&#039;re doing dos) returns the values in BCD, as I recall (Binary Coded Decimal). If that&#039;s the case, try printing it as if it were hex.<br /><br />Show it to us! We can probably help you fix it.&quot;<br /><br />(I don&#039;t have immediate access to how the quotes work here, so... I&#039;ll just be inconvenient and leave it in normal quotation marks)<br /><br /><pre><code><br />mov ah,2Ah<br />int 21h<br />mov dx,al<br />mov ah,09h<br />int 21h<br /></code></pre><br />(apparently a normal and thus expected number of characters show up here; 0x07DA, or, 2010 doesn&#039;t O.o )<br />That would be (basically) how it was done; <br /><br />Yeah - all that would need to be done is converting this to a sort of string. (I think....)&nbsp; &quot;Printing it as if it were hex&quot;? How&#039;s this done? Or perhaps a better question... What is this? (wouldn&#039;t have been the first time I crashed my computer because I asked &quot;how&quot; before &quot;why&quot; :P )<br /><br /><br />&quot;So how come you&#039;re not showing us how to do it? :)&quot;<br />I tend to forget a lot upon the shock of realizing that I&#039;ve been sitting at the computer for the past 16 years, 10 days, and an hour... time flies with glitchy clocks... my proof: I&#039;ve been typing this for the past 14 days according to this clock<br /><br /><br />Thank, again, for answering! (I&#039;ve been trying to determine the general answer to this  for over two weeks)</div>
    <div class="meta">Posted on 2010-03-11 21:51:57 by Nikumu</div>
   </div>
   <div class="post" id="post-210981">
    <div class="subject"><a href="#post-210981">Re: Could anyone provide explained code for a calculator, or something similar?</a></div>
    <div class="body">You&#039;ve really got two different questions here. The &quot;year&quot; one is probably easier... maybe...<br /><br />(&quot;quote&quot;, incidentally is done like &quot;code&quot; - &quot;quote&quot; and &quot;/quote&quot; in &quot;&#91;]&quot;s - so it seems - lemme try it)<br /><br /><div class="quote"><br /><pre><code><br />mov ah,2Ah<br />int 21h<br />mov dx,al<br />mov ah,09h<br />int 21h<br /></code></pre><br /></div><br /><br />You&#039;re fibbin&#039; to me, Nikumu! Nasm won&#039;t assemble that! &quot;mov dx, al&quot;? No way! &quot;movzx&quot; maybe. But it isn&#039;t what you want, in any case. Ralf Brown...<br /><br />http://www.ctyme.com/intr/rb-2686.htm<br /><br />(if you don&#039;t know Ralf, he&#039;s your new best friend!) says int 21h/2Ah returns the year in cx. So we either write a function that converts cx to text, or...<br /><br /><pre><code><br />mov ah, 2Ah<br />int 21h<br />mov ax, cx ; year<br />call showax<br />ret<br /></code></pre><br /><br />The &quot;showax&quot; function gets us right back into the other question, &quot;how do I print a number?&quot; which rapidly decomposes into &quot;div???&quot;. You tried:<br /><br /><div class="quote"><br /><pre><code><br />mov dx,8<br />mov ax,2<br />div ax<br /></code></pre><br /></div><br /><br />Just about the worst thing you could have done, as it turns out. :) &quot;div&quot;, in the size we&#039;re talking about, uses ax and dx as implicit operands - we don&#039;t have any choice about &#039;em. dx:ax (that is, dx times 65536 plus ax) is divided by... a register or memory that we provide. I&#039;m surprised that what you tried didn&#039;t crash your machine (doesn&#039;t hurt it - good exercise!), &#039;cause if the result doesn&#039;t fit in ax, it raises an exception. 8 times 64k plus 2, divided by 2, shouldn&#039;t.<br /><br />See what the old Nasm manual had to say about &quot;div&quot;:<br /><br />http://home.myfairpoint.net/fbkotler/nasmdocc.html#section-A.4.59<br /><br />In our case, we want dx to be explicitly zero, since we &quot;don&#039;t care&quot; about it, and the CPU does. We could put 10 in a register, or in memory - &quot;div 10&quot; won&#039;t work. :(<br /><br />After the &quot;div&quot;, the quotient is in ax (we probably want to keep it to use again), and the remainder is in dx (so we&#039;re going to have to zero it again for the next &quot;div&quot;!). This is one of the digits we&#039;re looking for. Since we&#039;ve divided by ten, it&#039;ll be between 0 and 9, so it&#039;ll fit in dl. We can just &quot;add dl, &#039;0&#039;&quot;, to &quot;convert&quot; to a character, which we can store in a buffer. If we put a &#039;$&#039; as the very last thing in the buffer, and worked forward from there, we could display it with int 21h/9...<br /><br />There are different ways to do it - &quot;div&quot; is quite slow. A repeated subtraction version can actually be faster(!). The fastest version involves multiplying by the reciprocal of 10... I think... makes my head hurt to try to figure it out. &quot;div&quot; is &quot;fast enough&quot;, I guess. :)<br /><br />The attached code displays ax as decimal, hex, and binary (let&#039;s see &quot;just call printf&quot; do that!). It is horribly slow - calls the OS for each character - much faster to accumulate the characters and just call the OS once! It is fairly well &quot;explained&quot;, I think - far better than any &quot;calculator&quot; code I&#039;d have around! You can do better, but maybe it&#039;ll give you an idea how to get started...<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3075" target="_blank">showax.asm</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-03-12 03:45:05 by fbkotler</div>
   </div>
   <div class="post" id="post-210993">
    <div class="subject"><a href="#post-210993">Re: Could anyone provide explained code for a calculator, or something similar?</a></div>
    <div class="body"><div class="quote"><br />You&#039;re fibbin&#039; to me, Nikumu! Nasm won&#039;t assemble that! &quot;mov dx, al&quot;? No way! &quot;movzx&quot; maybe. But it isn&#039;t what you want, in any case. <br /></div><br /><br />Oh... I meant &#039;mov dx,cx&#039;. I guess I typed &#039;al&#039; forgetting what I was doing at the moment. (after all, I am unable to make mistakes unless I have my memory to blame) <br /><br /><div class="quote"><br />Just about the worst thing you could have done, as it turns out. :)<br /></div><br /><br />I try my hardest - after all, if I only did something minutely wrong, I could never find where my mistake was. ;)<br /><br /><br />So... I have pretty much everything for this calculator made... <br /><br /><pre><code><br />contonum:<br />&nbsp;  <br />.beg:<br />&nbsp;  call topower ; Yes, Civilization: Call to Power<br />&nbsp;  <br />&nbsp;  mov dx,<br />&nbsp;  sub dx,30h<br />&nbsp;  mul dx<br />&nbsp;  add bx,ax<br />&nbsp;  <br />&nbsp;  cmp cx,00h<br />&nbsp;  je .end<br />&nbsp;  <br />&nbsp;  dec cx<br />&nbsp;  jmp .beg&nbsp;  ; I think this is all how it was before I did some editing to it..<br />&nbsp;  <br />.end:<br />&nbsp;  mov ax,bx<br />&nbsp;  ret<br /><br /><br /><br />topower:<br />&nbsp;  push bx<br />&nbsp;  push cx<br />&nbsp;  mov ax,1<br />&nbsp;  mov bx,10<br />&nbsp;  <br />&nbsp;  cmp cx,0<br />&nbsp;  je .if1<br />&nbsp;  jne .beg<br />&nbsp;  <br />.if1:<br />&nbsp;  mov ax,1<br />&nbsp;  jmp .end<br /><br />.beg:<br />&nbsp;  mul bx<br />&nbsp;  dec cx<br />&nbsp;  cmp cx,0<br />&nbsp;  je .end<br />&nbsp;  jne .beg<br /><br />.end:<br />&nbsp;  pop cx<br />&nbsp;  pop bx<br />&nbsp;  <br />&nbsp;  ret<br /></code></pre><br />Is what I have so far of the conversion of characters to numbers.... although this is harder than I had anticipated. <br /><br />Somewhere in &#039;contonum&#039; (convert to number), there is a mistake. Where it is, I&#039;ve not yet pinpointed. <br /><br />Although I&#039;m pretty sure it&#039;s still doable. I&#039;ll separate it later (I&#039;m brain-dead now; I&#039;ve basically been writing two small parts of this calculator at a very sluggish rate, all day...)&nbsp; and try to get it... <br />But... if I would make input be done through 0Ah/21h, could I still go through that and grab specific characters? Like, is it possible to do something like &#039;mov ,otherregister&#039;? <br /><br /><br />In what I&#039;m using at the moment:<br /><br /><pre><code><br />gets:<br />&nbsp;  push ax<br />&nbsp;  push cx<br />&nbsp;  <br />&nbsp;  xor bx,bx<br /><br />.beg:<br />&nbsp;  mov ah,07h<br />&nbsp;  int 21h<br />&nbsp;  cmp al,0Dh<br />&nbsp;  je .end<br />&nbsp;  <br />&nbsp;  mov ,al<br />&nbsp;  inc bx<br />&nbsp;  jmp .beg<br /><br />.end:<br />&nbsp;  pop cx<br />&nbsp;  pop ax<br />&nbsp;  <br />&nbsp;  ret<br /></code></pre><br /><br />is it possible to make it possible to move the contents of &#039;al&#039; into &#039;dx&#039;, so that they can be left undestroyed upon being taken back out of x? (that was a poorly crafted sentence... but I know not how to make it better, and I know not how to rephrase it...)<br />I think what I tried doing there is the same thing as I had tried doing with the clock, isn&#039;t it?...<br /><br />I think I&#039;m gonna conclude writing (typing)&nbsp; this quickly, hoping I don&#039;t neglect to say anything... I suddenly realized that I need to disappear from here. <br /><br />So the &#039;contonum&#039; mistake, I&#039;m pretty sure, was made when I started being careless and just throwing what I thought might fix it in. If help is attempted to be provided for that, I&#039;ll cover my ears and start screaming. (hopefully in your annoyance at me for doing this, you won&#039;t notice that my eyes are still open and I&#039;m reading the help)<br /><br />But... I think my only still-standing question is how to movement of things from specific areas in &#039;dx&#039; is done, and/or how I might move things from al to dx... <br /><br />Thus far I&#039;ve learned infinitely more than I had prior known... but I still remember it being easier in C... <br /><br />(note that I&#039;m unsure that all the code I used there is exactly how I wanted it... I might have changed some of it around to try seperating various other mistakes, out of the millions of ones that were initially there, and not noticed when copying/pasting it here)</div>
    <div class="meta">Posted on 2010-03-13 18:55:24 by Nikumu</div>
   </div>
   <div class="post" id="post-211005">
    <div class="subject"><a href="#post-211005">Re: Could anyone provide explained code for a calculator, or something similar?</a></div>
    <div class="body">Of course it&#039;s easier in C. Someone else has already written the code for you! Try it without any library calls. Quite possible, and if you still find it easy, you might work out the algorithm in C, and &quot;translate&quot; to asm. (or just let the compiler do it, and forget asm...)<br /><br /><pre><code><br />contonum:<br />&nbsp;  <br />.beg:<br />&nbsp;  call topower ; Yes, Civilization: Call to Power<br />&nbsp;  <br />&nbsp;  mov dx,<br />&nbsp;  sub dx,30h<br />&nbsp;  mul dx<br />&nbsp;  add bx,ax<br /></code></pre><br /><br />Okay... it might be nice to comment this code to divulge that the string length is in cx. (right?). So &quot;topower&quot; returns with ax at 10000, 1000, 100, 10, or 1, depending on the length of the string. (right?) Looks like it would work.<br /><br />I take it that &quot;x&quot; is the input buffer where the user has put some characters representing decimal digits. (or some other garbage - pesky users!) I&#039;m not sure what&#039;s in bx - zero, initially? In any case, you&#039;re getting two characters (or two bytes, at least) into dx. This is not what you want. Probably just use dl, here. But you are going to want to multiply by dx! What to do? &quot;mov dh, 0&quot; would fix it. &quot;movzx dx, byte &quot; would do it. &quot;xor dx, dx&quot; (before &quot;mov dl, &quot;!). Pick your favorite.<br /><br />You multiply by whatever &quot;topower&quot; gave us, and add the result to... whatever was in bx. Okay if bx was &quot;result so far&quot;, but you loop back to &quot;.beg:&quot;... What in heck does &quot;&quot; point to now? I think you need to introduce another register here - one to serve as &quot;result so far&quot; (should probably be explicitly zeroed before we start), and another to index into the buffer at &quot;x&quot;.<br /><br />That should work, but I would do it a slightly different way, which doesn&#039;t need to know the string length, or &quot;whatpower&quot;...<br /><br />; zero a register for &quot;result so far&quot;<br />.top:<br />; get a character, one way or another<br />; verify it&#039;s a valid digit (if not, quit, or ignore and continue? - if CR, quit)<br />; multiply &quot;result so far&quot; by ten<br />; add in the new digit, converted from character to number<br />; go back to .top<br /><br />Here&#039;s a cute way to do it:<br /><br /><pre><code><br />atoi:<br />&nbsp; &nbsp; mov edx, &nbsp; ; pointer to string<br />&nbsp; &nbsp; xor eax, eax&nbsp; &nbsp; &nbsp; &nbsp; ; clear &quot;result&quot;<br />.top:<br />&nbsp; &nbsp; movzx ecx, byte <br />&nbsp; &nbsp; inc edx<br />&nbsp; &nbsp; cmp ecx, byte &#039;0&#039;<br />&nbsp; &nbsp; jb .done<br />&nbsp; &nbsp; cmp ecx, byte &#039;9&#039;<br />&nbsp; &nbsp; ja .done<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ; we have a valid character - multiply<br />&nbsp; &nbsp; ; result-so-far by 10, subtract &#039;0&#039;<br />&nbsp; &nbsp; ; from the character to convert it to<br />&nbsp; &nbsp; ; a number, and add it to result.<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; lea eax, <br />&nbsp; &nbsp; lea eax, <br /><br />&nbsp; &nbsp; jmp short .top<br />.done<br />&nbsp; &nbsp; ret<br /></code></pre><br /><br />Using the two &quot;lea&quot;s to do the whole multiply-by-ten-etc was generated by a compiler(!). It is essentially &quot;C code&quot;, which must preserve ebx, esi, edi, etc... so it doesn&#039;t use any of them. C is allowed to &quot;trash&quot; ecx and edx, so it does. But these registers aren&#039;t really &quot;trash&quot; - edx is &quot;next position in string&quot;, and cl is the invalid character that ended input. If we&#039;re calling this from asm instead of C, we can utilize this information. Note that while I called it &quot;atoi&quot;, it deals with unsigned integers - should really be called &quot;atou&quot;. Since &quot;lea&quot; doesn&#039;t set flags, we have no way of detecting overflow.<br /><br />You ask, &quot;is it possible to do something like &#039;mov ,otherregister&#039;?&quot;<br /><br />No, not exactly. 16-bit addressing modes are picky, picky, picky! You can do &quot;mov , al&quot; or &quot;mov , al&quot; but not &quot;mov , al&quot;. You can do &quot;mov , al&quot;, even in 16-bit code, but the upper bits of edx must be clear. Usually, this is true, but there are exceptions - such as after running a DJGPP build of Nasm(!). (ask me how long it took me to figure that bug out!) If you&#039;re planning to use 32-bit registers in 16-bit code, I would &quot;xor edx, edx&quot; for each register you&#039;re going to use, right at the beginning of the program, &quot;just to be sure&quot;. (this means that &quot;atoi&quot; above would &quot;probably&quot; work in 16-bit code... have to &quot;push dword buffer&quot; and &quot;add sp, 4&quot; after... never tried it...)<br /><br />To do it in 16-bit instructions, you may have to juggle registers around a bit. Lemme see...<br /><br /><pre><code><br />org 100h<br /><br />%define MAX_INPUT 5<br />section .bss<br />input_buffer resb MAX_INPUT + 3<br /><br />section .text<br />; prep the buffer for int 21h/0Ah<br />mov word , MAX_INPUT + 1<br /><br />; prompt?<br />; get the number<br />mov dx, input_buffer<br />mov ah, 0Ah<br />int 21h<br /><br />mov cl, <br />mov ch, 0<br />; now cx is string length, if you want it<br /><br />; convert the text to number<br />mov si, input_buffer + 2<br />xor bx, bx<br />.top:<br />lodsb&nbsp; ; &quot;mov al, &quot;/&quot;inc si&quot; - all in one byte!<br />cmp al, 10 ; or 13 for dos???<br />jz .done<br />sub al, &#039;0&#039;<br />jc .invalid<br />cmp al, 9<br />ja .invalid<br />imul bx, bx, 10<br />; jc .overflow<br />mov ah, 0 ; just to be sure<br />add bx, ax<br />; jc .overflow<br />jmp short .top<br />. done:<br />.invalid:&nbsp; ; do something special here, if you want<br />mov ax, bx<br />;ret ; oops, we weren&#039;t called<br />; ...<br /></code></pre><br /><br />(caution: untested code!)<br /><br />There ya go, now just press the square root key, and...<br /><br />Your &quot;gets&quot; looks good (does it &quot;echo&quot; what you type?), but it looks like &quot;gets&quot; - allows buffer overrun - extremely bad!!! Throw it out, or rework it to &quot;ngets&quot; (limit input to the length of your buffer). Sorry to be a nut-case about &quot;gets&quot;, but... every time a new version of  comes out, it&#039;s full of buffer overruns that vile individuals exploit, causing trouble for all of us. This is not a new problem, but the &quot;professionals&quot; can&#039;t seem to figure it out. Us hobbyists have gotta do better. Please don&#039;t use &quot;gets&quot;!<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-03-14 09:29:34 by fbkotler</div>
   </div>
   <div class="post" id="post-211031">
    <div class="subject"><a href="#post-211031">Re: Could anyone provide explained code for a calculator, or something similar?</a></div>
    <div class="body"><div class="quote"><br />Okay... it might be nice to comment this code to divulge that the string length is in cx. (right?). So &quot;topower&quot; returns with ax at 10000, 1000, 100, 10, or 1, depending on the length of the string. (right?) Looks like it would work.<br /></div><br /><br />Yeah, x is input buffer; I suppose I should have left comments... I&#039;m not used to having to do that, but I&#039;m thinking it&#039;ll be more necessary in Assembly... right. And yes; cx = string length.<br /><br /><br />I think I had some sort of pop/push thing before and after the increment of bx, as I couldn&#039;t think of enough registers that would work at the time. bx served as both the current position to read, and and result so far... of course that doesn&#039;t appear to have been working so very perfectly... <br /><br /><br />That idea does seem a bit easier... <br /><br />I tried doing this:<br /><pre><code><br />contonum:<br />&nbsp;  xor ecx,ecx&nbsp; &nbsp; &nbsp; &nbsp; ; Current Position in x<br />&nbsp;  mov ax,10<br />&nbsp;  xor bx,bx<br />&nbsp;  <br />.beg:<br />&nbsp;  movzx dx,&nbsp; ; Get the cx position in the input buffer<br />&nbsp;  <br />&nbsp;  cmp dx,&#039;9&#039;<br />&nbsp;  ja .end<br />&nbsp;  cmp dx,&#039;0&#039;<br />&nbsp;  jb .end<br />&nbsp;  <br />&nbsp;  mul bx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Multiply bx by 10, then add the next number to it...<br />&nbsp;  sub dx,30h<br />&nbsp;  add bx,dx&nbsp; &nbsp; &nbsp; &nbsp; ; This is where the problem is?<br />&nbsp;  <br />&nbsp;  inc ecx<br />&nbsp;  <br />&nbsp;  jmp .beg<br />&nbsp;  <br />.end:<br />&nbsp;  ret<br /></code></pre><br /><br />And that throws out a number that... obviously does not equal the 32 I&#039;m wanting it to... <br /><br /><pre><code><br />call contonum<br />&nbsp;  mov ax,bx<br />&nbsp;  call contochar<br /></code></pre><br /><br />Is where it got called. <br /><br /><br />I tried using the above provided code, but quickly encountered the problem of moving eax into ax. &#039;movzx&#039; does that the other way around, but... is it also doable as eax&gt;ax in any way?<br /><br /><pre><code><br />; I appear to have closed the Notepad where is was being kept... or something..... so this is untested, and rewritten...<br /><br />atoi:<br />&nbsp; &nbsp; mov edx, &nbsp; ; pointer to string<br />&nbsp; &nbsp; xor eax, eax&nbsp; &nbsp; &nbsp; &nbsp; ; clear &quot;result&quot;<br />&nbsp; &nbsp; xor ebx,10<br />.top:<br />&nbsp; &nbsp; movzx ecx, byte <br />&nbsp; &nbsp; inc edx<br />&nbsp; &nbsp; cmp ecx, byte &#039;0&#039;<br />&nbsp; &nbsp; jb .done<br />&nbsp; &nbsp; cmp ecx, byte &#039;9&#039;<br />&nbsp; &nbsp; ja .done<br /><br />&nbsp; &nbsp; mul ebx<br />&nbsp; &nbsp; sub ecx,30h<br />&nbsp; &nbsp; add ebx,ecx<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; lea eax, <br />&nbsp; &nbsp; lea eax, <br /></code></pre><br />Is what would finish that? But then, what exactly does &#039;movzx ecx, byte &#039; do? Is edx where the last byte read is? <br />&#039;mov edx, &#039; also leaves me..... umm... (I&#039;ll think of a word...)... without knowing what&#039;s going on..... (I know a fancy word for that, but what is it? &gt;.&lt;) <br /><br />I don&#039;t think that was as concise as &#039;twas planned, was it? But that is still well..... But I think (and have said before) that eax&gt;ax may be the answer to all my problems, as is it to the rest of the world&#039;s problems. But... then, we&#039;ll find out what problem I next encounter.... there are infinite, just waiting......... Is that all I meant to say..... I dunno...... but I&#039;m being rushed again today, and think it should be, regardless of whether or not it really is :/&nbsp; </div>
    <div class="meta">Posted on 2010-03-16 16:00:37 by Nikumu</div>
   </div>
   <div class="post" id="post-211033">
    <div class="subject"><a href="#post-211033">Re: Could anyone provide explained code for a calculator, or something similar?</a></div>
    <div class="body">If there are set bits in the upper word of eax, &quot;eax&gt;ax&quot; isn&#039;t going to &quot;fit&quot;. We&#039;ll have to assume that the upper word of eax is clear - or meaningless to us - in which case we just use ax. If that solves all the world&#039;s problems, we&#039;re in good shape! :)<br /><br /><div class="quote"><br />&#039;mov edx, &#039; also leaves me..... umm... <br /></div><br /><br />I shouldn&#039;t have shown you that. The &quot;string&quot; is passed to the subroutine by pushing it on the stack, before &quot;call&quot;ing the function. In 32-bit code, &quot;call&quot; stores a 32-bit (4 byte) return address on the stack, so our parameter is at . In 16-bit code, &quot;call&quot; would only use 16 bits, so that wouldn&#039;t be right. Shouldn&#039;t have showed it to you - forget 32-bit...<br /><br />You&#039;ve got a &quot;problem&quot; in a couple of your code examples, in that &quot;mul&quot; uses dx as one of its destination registers, trashing whatever you had there - pointer-to-string in one case (replacing the &quot;two lea trick&quot; with a regular &quot;mul&quot; totally breaks that code!) , and &quot;the byte&quot; in the other.<br /><br /><div class="quote"><br />I tried doing this:<br /><br /><pre><code><br />contonum:<br />&nbsp;  xor ecx,ecx&nbsp; &nbsp; &nbsp; &nbsp; ; Current Position in x<br />&nbsp;  mov ax,10<br />&nbsp;  xor bx,bx<br />&nbsp;  <br />.beg:<br />&nbsp;  movzx dx,&nbsp; ; Get the cx position in the input buffer<br />&nbsp;  <br />&nbsp;  cmp dx,&#039;9&#039;<br />&nbsp;  ja .end<br />&nbsp;  cmp dx,&#039;0&#039;<br />&nbsp;  jb .end<br />&nbsp;  <br />push dx ; save &quot;the byte&quot; - &quot;mul&quot; is going to trash it!<br /><br />&nbsp;  mul bx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Multiply bx by 10, then add the next number to it...<br /><br />pop dx ; get our character back<br />mov bx, ax&nbsp; ; &quot;mul&quot; left the answer in ax, not bx!<br />mov ax, 10&nbsp; ; get ax back where we want it<br /><br /><br />&nbsp;  sub dx,30h<br />&nbsp;  add bx,dx&nbsp; &nbsp; &nbsp; &nbsp; ; This is where the problem is?<br />&nbsp;  <br />&nbsp;  inc ecx<br />&nbsp;  <br />&nbsp;  jmp .beg<br />&nbsp;  <br />.end:<br />&nbsp;  ret<br /></code></pre><br /></div><br /><br />Untested, but I think those changes will fix it. Obviously(?), the rigamarole to clean up the mess made by &quot;mul&quot; could be reduced by different choice of registers.<br /><br />Using 16-bit registers &quot;&quot; won&#039;t work, but bx, si, or di would. &quot;mul&quot; uses ax and dx as destination registers (dx * 65536 + ax). If dx is non-zero, you&#039;ve overflowed 16 bits with your number. You may want to check for this. You should have enough registers to do this, if you choose &#039;em wisely.<br /><br />&quot;imul&quot; is a funny instruction. It&#039;s actually two very different instructions... made to look like three.<br /><br /><pre><code><br />imul bx<br /></code></pre><br /><br />works like &quot;mul&quot; - a 16-bit by 16-bit multiply into a 32-bit result (bx * ax -&gt; dx:ax). The difference is that &quot;imul&quot; works for signed integers, and &quot;mul&quot; works for unsigned.<br /><br /><pre><code><br />imul cx, bx, 10<br /></code></pre><br /><br />is different. It does a 16-bit by 16-bit multiply, into a 16-bit result (bx * 10 -&gt; cx). Any overflow out of 16 bits is lost. It also accepts an &quot;immediate&quot; operand, as well as the reg or  the other forms require. Handy!<br /><br /><pre><code><br />imul bx, 10<br /></code></pre><br /><br />is the same instruction as &quot;imul bx, bx, 10&quot;, with source and destination the same register. So the two-operand form is just a special case of the three-operand form.<br /><br />If you find that confusing, go back to &quot;mul&quot;, but being able to write &quot;10&quot; instead of having it in a register (&quot;ten dw 10&quot;...&quot;mul word &quot; will work, too) might free up a register...<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-03-16 23:37:37 by fbkotler</div>
   </div>
   <div class="post" id="post-211051">
    <div class="subject"><a href="#post-211051">Re: Could anyone provide explained code for a calculator, or something similar?</a></div>
    <div class="body"><div class="quote">fbkotler</strong>&quot;]It also accepts an &quot;immediate&quot; operand, as well as the reg or  the other forms require. Handy!</div><br /><br />I beg to differ. For three-operand <strong>imul</strong>, destination is always register, and one of the multiplicands (third operand) is always immediate.</div>
    <div class="meta">Posted on 2010-03-17 12:00:39 by baldr</div>
   </div>
   <div class="post" id="post-211054">
    <div class="subject"><a href="#post-211054">Re: Could anyone provide explained code for a calculator, or something similar?</a></div>
    <div class="body">Right you are. Only the two-operand form gives us a choice. I guess it really *is* three different instructions. Thanks for the correction!<br /><br />Best,<br />Frank<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2010-03-17 12:46:30 by fbkotler</div>
   </div>
  </div>
 </body>
</html>