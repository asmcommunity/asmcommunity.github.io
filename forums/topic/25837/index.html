<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>SceneGraphs and SkinMesh Attachments - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25837" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25837">SceneGraphs and SkinMesh Attachments</a></p>
   <div class="post" id="post-188432">
    <div class="subject"><a href="#post-188432">SceneGraphs and SkinMesh Attachments</a></div>
    <div class="body"><br />The aim of this post is to develop an efficient mechanism for attaching meshes to other meshes, such as weapons to animated models.<br /><br />When we load a model (static or animated), we must remember to always treat that loaded object as a REFERENCE OBJECT, because we intend to have N INSTANCES of that Ref object, sharing ONE resource.<br /><br />Therefore it seems a bad idea to manipulate the frame hierarchy of our Ref object when it comes to attaching one hierarchy to another, unless we wish ALL INSTANCES to have this new attachment.<br /><br />Let&#39;s assume we want individual instances to have different attachments.<br />The problem now is that since we&#39;re memory-conscious asm coders, our &#39;instance struct&#39; doesn&#39;t have its own copy of the model&#39;s frame hierarchy - we&#39;re relying on the one shared copy of that.<br />So how can our instance know where the attachment should go?<br />If we merely keep framepointers in our instance structs, then we&#39;ll be required to enumerate all instances from within the Model&#39;s Frame Update function, which is recursive, so that&#39;s a REALLY BAD IDEA.<br /><br />Maybe altering the Ref object isn&#39;t such a bad idea after all, IF we do it conscientiously.<br /><br />Let&#39;s extend our already derived Frame struct a little further, so that we can tag Frames as being of various Types.<br /><br />Now we can mark all Frames (during loading) as being of &#39;Original Type&#39;, and if we go adding any other Frames to the hierarchy later, we can mark those as being of &#39;OTHER Types&#39;.<br /><br />Our Model is responsible for deallocating only the Frames marked as ORIGINAL Type, but it will happily calculate the Combined Matrix for ALL FRAMES in the Hierarchy. Note that this behaviour can be switched selectively for a given Type at runtime.<br /><br />Now we can attach Ref objects to other Ref objects, and have a way to tell within a hierarchy which Frames are &#39;glue-ons&#39; and which are &#39;original&#39;.<br /><br />During Rendering, we walk all the Original frames, and we SELECTIVELY walk the OTHER Frames.<br /><br />But what&#39;s all this got to do with Scene Graphs?<br /><br />Well, our SceneGraph is a frame hierarchy too, but ALL its frames (nodes) are of &#39;Other Type&#39;.<br />Each node in our SceneGraph represents an INSTANCE of a Ref object in our World.<br />The structure of our SceneGraph is almost identical to that of our Ref object frame hierarchies, in fact its simpler, it contains ONLY a tree of instances.<br /><br />It makes sense to use the SAME derived frame struct and take advantage of the new Type field for this purpose also !!<br /><br />The render logic is as follows:<br />We walk the SceneGraph (which may also contain space partitioning data), and for each Potentially Visible (unculled) instance, we update and render, following any &#39;Switch&#39; frames that are specified by that Instance, and disregarding any which are not.<br /><br />Yes, we have to walk the Ref object N times.<br />This can ONLY be avoided if the Combined Ref Object CONTAINS NO ANIMATIONS.<br /><br />In this special case ALONE, we can precalculate the COMBINED MATRICES just ONCE, storing it within the Instance, and then combining it at the last moment with one dynamic matrix for last-moment position,rotation and scale of the combined object.<br /><br />We never have to Walk such an object&#39;s hierarchy :)<br /></div>
    <div class="meta">Posted on 2007-03-15 21:54:10 by Homer</div>
   </div>
  </div>
 </body>
</html>