<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>API hooking problem. - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17619" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=17619">API hooking problem.</a></p>
   <div class="post" id="post-136249">
    <div class="subject"><a href="#post-136249">API hooking problem.</a></div>
    <div class="body">Hi!<br /><br />I'm having a problem with API hooking, but! This problem appears only when I'm loading taskmgr.exe myseft... If the taskmgr.exe already loaded - everything goes as I need.<br /><br />Here are the functions.<br /><br />First, <strong>dll injection code</strong>:<br /><pre><code><br />InjectLib        Proc dwProcessId&#58;DWORD, lpszLibFile&#58;DWORD<br />  LOCAL dwMemSize,<br />        dwWritten,<br />        dwKernel,<br />        dwProcAddr,<br />        dwThread,<br />        Result,<br />        pszRemote &#58;DWORD<br /><br />  LOCAL hProcess  &#58;HANDLE<br /> <br />  invoke OpenProcess, PROCESS_CREATE_THREAD or PROCESS_VM_OPERATION or PROCESS_VM_WRITE, TRUE, dwProcessId<br />  .if eax<br />    mov    Result, FALSE<br /><br />    mov    hProcess, eax<br /><br />    mov    eax, @Result&#40;lstrlen, lpszLibFile&#41;<br />    inc    eax<br />    mov    dwMemSize, eax<br />    invoke VirtualAllocEx, hProcess, NULL, eax, MEM_COMMIT, PAGE_READWRITE;<br />    .if eax<br />      mov    pszRemote, eax<br />      invoke WriteProcessMemory, hProcess, pszRemote, lpszLibFile, dwMemSize, ADDR dwWritten<br />      .if  eax<br />        mov       dwKernel, @Result&#40;GetModuleHandle, @Text&#40;'KERNEL32'&#41;&#41;<br />        mov       dwProcAddr, @Result&#40;GetProcAddress, dwKernel, @Text&#40;'LoadLibraryA'&#41;&#41;;<br />        invoke CreateRemoteThread, hProcess, NULL, 0, dwProcAddr, pszRemote, 0, NULL<br />        .if eax<br />          mov       dwThread, eax<br />          mov       Result, TRUE<br />          invoke WaitForSingleObject, dwThread, INFINITE<br />          invoke CloseHandle, dwThread<br />        .endif<br />      .endif<br />      invoke VirtualFreeEx, hProcess, pszRemote, 0, MEM_RELEASE<br />    .endif<br />  .endif	<br />  mov    eax, Result<br />  Ret<br />InjectLib        Endp<br /></code></pre><br /><br />Second, <strong>creating the process and injecting my library</strong>:<br /><pre><code><br />CreateProcessEx  Proc Param1&#58;DWORD, Param2&#58;DWORD, Param3&#58;DWORD, Param4&#58;DWORD, Param5&#58;DWORD, Param6&#58;DWORD, \<br />                      Param7&#58;DWORD, Param8&#58;DWORD, Param9&#58;DWORD, Param10&#58;DWORD, lpszLibFile &#58;DWORD<br /><br />  mov    eax, Param6<br />  or     eax, CREATE_SUSPENDED<br />  invoke CreateProcess, Param1, Param2, Param3, Param4, Param5, eax, Param7, Param8, Param9, Param10<br /><br />  push   eax<br />  push   ebx<br />  mov    ebx, Param10<br /><br />  invoke InjectLib, &#91;ebx+8&#93;, lpszLibFile<br />  invoke ResumeThread, &#91;ebx+4&#93;<br /><br />  pop    ebx<br />  pop    eax<br />  Ret<br />CreateProcessEx Endp<br /></code></pre><br /><br />Third, <strong>IAT entries patching...</strong> From my DLL.<br /><pre><code><br />ReplaceIATEntryInOneMod  Proc USES Ebx lpszCaleeName&#58;DWORD, lpfnCurrent&#58;DWORD, lpfnNew&#58;DWORD, hmodCaller&#58;DWORD<br /><br />                        LOCAL hHandle&#58;DWORD<br />                        LOCAL Dummy  &#58;DWORD<br />                        LOCAL ppfn   &#58;DWORD<br />                        LOCAL wrbt   &#58;DWORD<br /> <br />  invoke ImageDirectoryEntryToData, hmodCaller, TRUE, \<br />         IMAGE_DIRECTORY_ENTRY_IMPORT, ADDR hHandle<br /><br />  .if eax == NULL<br />    jmp   _exit<br />  .endif<br />  <br />  xchg   Ebx, Eax<br />  @AssumePtr IMAGE_IMPORT_DESCRIPTOR<br />  .while &#91;ebx&#93;.Name1<br />     mov    Eax, &#40;IMAGE_IMPORT_DESCRIPTOR Ptr &#91;Ebx&#93;&#41;.Name1<br />     add    Eax, hmodCaller<br />     invoke lstrcmpi, Eax, lpszCaleeName<br />     .if eax == 0<br />       jmp   _found<br />     .else<br />       add    Ebx, SIZEOF IMAGE_IMPORT_DESCRIPTOR<br />     .endif<br />  .endw<br />  jmp _exit<br />    <br />_found&#58;<br />  mov   Ebx, &#91;ebx&#93;.FirstThunk<br />  add   Ebx, hmodCaller<br />	<br />  @AssumePtr IMAGE_THUNK_DATA<br />  .while &#91;ebx&#93;.u1.Function<br />    mov    eax, &#91;Ebx&#93;.u1.Function<br />    .if lpfnCurrent == eax<br />      lea    ebx, &#91;ebx&#93;.u1.Function<br />      mov    ppfn, ebx<br />      invoke VirtualProtect, ppfn, SIZEOF DWORD, PAGE_EXECUTE_READWRITE, ADDR Dummy<br />      mov    hHandle, @Result&#40;GetCurrentProcess&#41;<br />      invoke WriteProcessMemory, hHandle, ppfn, ADDR lpfnNew, SIZEOF DWORD, ADDR wrbt<br />      jmp   _exit<br /><br />      invoke VirtualProtect, ppfn, SIZEOF DWORD, Dummy, ADDR Dummy<br />    .endif<br />    <br />    add    Ebx, SIZEOF IMAGE_THUNK_DATA<br />  .endw<br />  jmp _exit<br />      <br />_exit&#58;      <br />  Assume Ebx&#58;Nothing<br />  ret<br />ReplaceIATEntryInOneMod  Endp<br /><br />ReplaceIATEntryInAllMod  Proc Restore&#58;BYTE<br /><br />  LOCAL  hSnap      &#58;DWORD<br />  LOCAL  hProcSnap  &#58;MODULEENTRY32<br /><br />  mov    hProcSnap.dwSize, SIZEOF MODULEENTRY32<br />  invoke GetCurrentProcessId<br />  invoke CreateToolhelp32Snapshot, TH32CS_SNAPMODULE, eax<br />  mov    hSnap, eax<br />  invoke Module32First, hSnap, ADDR hProcSnap<br />  .if eax<br />    .repeat<br />      mov eax, hProcSnap.hModule<br />      .if eax<br />        .if !Restore<br />          invoke ReplaceIATEntryInOneMod, ADDR szKernel, oldOpenProc, ADDR NewOpen, hProcSnap.hModule    ; OpenProcess<br />          invoke ReplaceIATEntryInOneMod, ADDR szKernel, oldKillProc, ADDR NewKill, hProcSnap.hModule    ; TerminateProcess<br />          invoke ReplaceIATEntryInOneMod, ADDR szKernel, oldGetProc, ADDR NewProc, hProcSnap.hModule     ; GetProcAddress<br />        .else<br />          invoke ReplaceIATEntryInOneMod, ADDR szKernel, ADDR NewProc, oldGetProc, hProcSnap.hModule     ; GetProcAddress<br />          invoke ReplaceIATEntryInOneMod, ADDR szKernel, ADDR NewKill, oldKillProc, hProcSnap.hModule    ; TerminateProcess<br />          invoke ReplaceIATEntryInOneMod, ADDR szKernel, ADDR NewOpen, oldOpenProc, hProcSnap.hModule    ; TerminateProcess<br />        .endif<br />      .endif<br />      invoke Module32Next, hSnap, ADDR hProcSnap<br />    .until !eax<br />  .endif<br />  invoke CloseHandle, hSnap<br />  ret<br />ReplaceIATEntryInAllMod  Endp<br /><br />DllEntry    Proc hInstDll&#58;HINSTANCE, reason&#58;DWORD, reserved1&#58;DWORD<br /><br />  .if reason == DLL_PROCESS_ATTACH<br />    mov  dwKernel, @Result&#40;GetModuleHandle, ADDR szKernel&#41;<br />    mov  oldGetProc, @Result&#40;GetProcAddress, dwKernel, @Text&#40;'GetProcAddress'&#41;&#41;<br />    mov  oldKillProc, @Result&#40;GetProcAddress, dwKernel, @Text&#40;'TerminateProcess'&#41;&#41;<br />    mov  oldOpenProc, @Result&#40;GetProcAddress, dwKernel, @Text&#40;'OpenProcess'&#41;&#41;<br /><br />    invoke ReplaceIATEntryInAllMod, FALSE<br />  &#91; ... &#93;<br /><br />  .elseif reason == DLL_PROCESS_DETACH<br />    invoke ReplaceIATEntryInAllMod, TRUE<br /><br />  &#91; ... &#93;<br /></code></pre><br /><br />And the last, <strong>replaced functions</strong><br /><pre><code><br />; New TerminateProcess<br />NewKill             Proc Param1&#58;DWORD, Param2&#58;DWORD<br /><br />  push   Param2<br />  push   Param1<br />  call   oldKillProc<br />  Ret<br />NewKill     EndP<br /><br />; New OpenProcess<br />NewOpen     Proc Param1&#58;DWORD, Param2&#58;DWORD, Param3&#58;DWORD<br /><br />  push    Param3<br />  push    Param2<br />  push    Param1<br />  call    oldOpenProc<br />  Ret<br />NewOpen EndP<br /><br />; New GetProcAddress<br />NewProc     Proc  hModule&#58;DWORD, lpProc&#58;DWORD<br />  <br />  push   lpProc<br />  push   hModule<br />  call   oldGetProc<br />  <br />  .if eax == oldGetProc<br />    mov   eax, OFFSET NewProc<br /><br />  .elseif eax == oldKillProc<br />    mov   eax, OFFSET NewKill<br />    <br />  .elseif eax == oldOpenProc<br />    mov   eax, OFFSET NewOpen<br />  .endif<br />	Ret<br />NewProc EndP<br /></code></pre><br /><br />Maybe some one would look through the code and say me where am I wrong... <br /><br />Thanx...</div>
    <div class="meta">Posted on 2004-03-17 20:19:17 by The CHEMI$T</div>
   </div>
   <div class="post" id="post-136275">
    <div class="subject"><a href="#post-136275">API hooking problem.</a></div>
    <div class="body">afaik no IAT when u just create it<br />i'd do hard hook on those API instead of IAT redirect</div>
    <div class="meta">Posted on 2004-03-18 05:38:23 by comrade</div>
   </div>
  </div>
 </body>
</html>