<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>WankerLIB alpha 1.0 + long code post of example - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=21352" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=22">Recruitment</a> &raquo; <a href="../?id=21352">WankerLIB alpha 1.0 + long code post of example</a></p>
   <div class="post" id="post-161455">
    <div class="subject"><a href="#post-161455">WankerLIB alpha 1.0 + long code post of example</a></div>
    <div class="body">I&#39;m releasing an alpha version of what I&#39;m playing with (GDI library), if anyone wants to offer suggestions or help and I follow up with it, I&#39;ll put your name or screen name into the credits.? I ran my example with Memproof and found no memory leaks.<br /><br />An executable example and bitmap are zipped here:<br />http://www.drarem.ms11.net/code/WLmemTest.zip<br /><br />It runs some basic tests with the memory it allocates/copies to, displaying text boxes.<br />It also opens the bitmap and blits it to the main screen - since double-buffering is employed, if there were moving entities on the screen,<br />there would be no flickering.<br /><br /><br />The library is located here:<br />http://www.drarem.ms11.net/code/WankerGDI_A10.zip<br /><br />To use it in your own program, all you need to do is this:<br />? ?include ..<br />? ?include ..\WLmem\WLmem.Inc<br />? ?<br />? ?includelib ..<br />? ?includelib ..\WLmem\WLmem.lib<br /><br /><br />Here is the initial documentation:<br />http://www.drarem.ms11.net/code/wankerlib.html<br /><br /><br />Please give me your thoughts or concerns. Thank you.<br /><br />The source for the above example is posted below:<br /><pre><code><br />.586<br />.model flat,stdcall<br />option casemap:none<br /><br />? ?include windows.inc<br />? ?include user32.inc<br />? ?include kernel32.inc<br />? ?include ..\WLmem\WLmem.Inc<br />? ?<br />? ?includelib user32.lib<br />? ?includelib kernel32.lib<br />? ?includelib ..\WLmem\WLmem.lib<br /><br />WinMain proto :DWORD,:DWORD,:DWORD,:DWORD<br /><br />.const<br />BCKGND equ 1<br /><br />.data<br />? ?ClassName db &quot;MainWinClass&quot;,0<br />? ?AppName? db &quot;Main Window&quot;,0<br />	testtext db &quot;This is a test of the hardcoded junk ....? &quot;<br />			 db &quot;and so is this and so is this and so is thi&quot;<br />			 db &quot;s.. Inspired by the beauty of HDTV, XBRITE.&quot;,0<br />	lpOut? db &quot;? ? ? ? ? ? ? ? ? ?&quot;,0<br />	lpFmt? db &quot;%c&quot;<br /><br />.data?<br />? ?hInstance HINSTANCE ?<br />? ?CommandLine LPSTR ?<br />	ohwnd dd ?<br />? ?stringtest dd ?<br />.code<br /><br /><br />; ---------------------------------------------------------------------------<br /><br /><br />start:<br />	invoke GetModuleHandle, NULL<br />	mov? ? hInstance,eax<br />	<br />	invoke GetCommandLine<br />	mov? ? CommandLine,eax<br />	<br />	invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT<br />	invoke ExitProcess,eax<br /><br />WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD<br />	LOCAL wc:WNDCLASSEX<br />	LOCAL msg:MSG<br />	LOCAL hwnd:HWND<br />	LOCAL arx:DWORD<br />	<br />	mov? ?wc.cbSize,SIZEOF WNDCLASSEX<br />	mov? ?wc.style, CS_HREDRAW or CS_VREDRAW<br />	mov? ?wc.lpfnWndProc, OFFSET WndProc<br />	mov? ?wc.cbClsExtra,NULL<br />	mov? ?wc.cbWndExtra,NULL<br />	push? hInstance<br />	pop? ?wc.hInstance<br />	mov? ?wc.hbrBackground,COLOR_BTNFACE+1<br />	mov? ?wc.lpszMenuName,NULL<br />	mov? ?wc.lpszClassName,OFFSET ClassName<br />	<br />	invoke LoadIcon,NULL,IDI_APPLICATION<br />	mov? ?wc.hIcon,eax<br />	mov? ?wc.hIconSm,eax<br /><br />	invoke LoadCursor,NULL,IDC_ARROW<br />	mov? ?wc.hCursor,eax<br /><br />	invoke RegisterClassEx, addr wc<br />	INVOKE CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\<br />? ? ? ? ? ?WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\<br />? ? ? ? ? ?CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\<br />? ? ? ? ? ?hInst,NULL<br />	mov? ?hwnd,eax<br />	mov? ohwnd,eax<br />	invoke ShowWindow, hwnd,SW_SHOWNORMAL<br />	invoke UpdateWindow, hwnd<br />	mov arx,0<br /><br />	NEW stringtest, 128000<br />	invoke lstrcpy, stringtest, addr testtext<br />	invoke MessageBox,NULL, stringtest, NULL, MB_OK<br /><br />;TESTING AS FOLLOWS:<br />;? stringtest is a dword pointer<br />;? testtext is a byte array (string of text)<br />;? after each READ, the dword pointer is incremented - preserve eax as needed<br />;? after each WRITE, the dword pointer is incremented<br /><br />	RESTORE stringtest<br />	READ arx,byte<br />	READ arx,byte<br /><br />	RESTORE stringtest<br />	xor ecx,ecx<br />	mov ecx,65<br />loopa:<br />	mov arx,ebx<br />	WRITE cl,byte<br />	add ecx,1<br />	cmp ecx,91<br />	jb loopa<br />	<br />	READ arx,byte<br />? ? READ arx,byte <br />? ? READ arx,byte <br />? ? READ arx,byte <br />? ? READ arx,byte <br />? ? READ arx,byte <br />? ? READ arx,byte<br />? ? <br />? ? WRITE 66,byte<br />	RESTORE stringtest<br />	READ arx,byte<br />? ? READ arx,byte <br />? ? READ arx,byte <br />? ? READ arx,byte <br />? ? READ arx,byte <br />	READ arx,byte<br />	READ arx,byte<br />	READ arx,byte<br />	<br />	invoke wsprintf,addr lpOut, addr lpFmt, arx<br />	invoke MessageBox,NULL,addr lpOut, NULL, MB_OK<br /><br />	invoke MessageBox,NULL, stringtest, NULL, MB_OK<br /><br />	.WHILE TRUE<br />		invoke GetMessage, ADDR msg,NULL,0,0<br />		.BREAK .IF (!eax)<br />		invoke TranslateMessage, ADDR msg<br />		invoke DispatchMessage, ADDR msg<br />	.ENDW<br /><br />	invoke cleanup<br />	FREE stringtest<br /><br />	mov? ? ?eax,msg.wParam<br />	ret<br />WinMain endp<br /><br />WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM<br />LOCAL hdc:DWORD<br />LOCAL ps:PAINTSTRUCT<br /><br />	.IF uMsg==WM_DESTROY<br />		invoke PostQuitMessage,NULL<br />		invoke DestroyWindow,ohwnd<br />	.ELSEIF uMsg==WM_CREATE<br /><br />		invoke BackBuffer,hWnd,800,600,1,1<br />		invoke LoadBANK,CTEXT(&quot;test.bmp&quot;),BCKGND,800,600,0<br />		<br />	.elseif uMsg==WM_PAINT<br />		invoke BeginPaint,hWnd, ADDR ps<br />		mov? ? hdc,eax<br />		invoke blit,BCKGND,0,0,800,600,0,0,800,600<br />		invoke flip<br />		invoke EndPaint,hWnd, ADDR ps<br />	.ELSE<br />		invoke DefWindowProc,hWnd,uMsg,wParam,lParam		<br />		ret<br />	.ENDIF<br /><br />	xor eax,eax<br />	ret<br />WndProc endp<br /><br /><br />end start<br /></code></pre><br /></div>
    <div class="meta">Posted on 2005-06-24 16:30:42 by drarem</div>
   </div>
   <div class="post" id="post-161457">
    <div class="subject"><a href="#post-161457">Re: WankerLIB alpha 1.0 + long code post of example</a></div>
    <div class="body">Why the childish name, wouldn&#39;t a more descriptive one have been better .</div>
    <div class="meta">Posted on 2005-06-24 17:22:12 by EÃ³in</div>
   </div>
   <div class="post" id="post-161458">
    <div class="subject"><a href="#post-161458">Re: WankerLIB alpha 1.0 + long code post of example</a></div>
    <div class="body">I have the brain of a child. Really it is for lack of a better one, I&#39;ll change the name unless you want to name it. Should have thought it out.</div>
    <div class="meta">Posted on 2005-06-24 17:44:44 by drarem</div>
   </div>
   <div class="post" id="post-161834">
    <div class="subject"><a href="#post-161834">Re: WankerLIB alpha 1.0 + long code post of example</a></div>
    <div class="body">Right now there&#39;s nothing unique or even close to useful in WL :| . With the banking feature it gets close to useful - but trust me, banking is less than 2% of any GUI code we GUI coders write. In x86, I use primarily 1024x300 bitmaps, with dozens to hundreds of sprites. These sprites can never be completely algorithmically positioned, otherwise we lose lots of memory for empty (useless) pixels.<br />I always do<br />invoke Blt,destX,destY,Wid,Hei,srcX,srcY,SourceBitmap ; DestBitmap is pre-set<br />or I can pre-set SourceBitmap, too. <br /><br />Well, I could give some (or lots of) advice on making a graphics library (I have 2 years of commercial experience in it), but all my apps that need a graphics engine have literally thousands of &quot;child elements&quot;: buttons, knobs, triggers, special-drawn... So, only a few might find my advice useful/interesting ^^&quot; . <br /><br />I&#39;ve concentrated on DirectDraw (in the x86 field that is) - since GDI proves extremely slow even on good PCs (but with bad nVidia drivers) - and my apps need 30fps full-update ^^. <br /><br />Ah, and btw the FREE/.. macros ... slow, taking too much i-memory, garbling registers (actually, not preserving them) - put separate procs for malloc/free that don&#39;t call GetProcessHeap everytime. Preserving the registers saves coders from typing and later debugging a lot! <br />The RESTORE macro is utterly useless - it takes less time to type&nbsp; &quot;mov eax,var1&quot;, and the code is much more readable. <br /><br />As for bitmaps - a compression is best to use (jpg/gif/png). But, the buttons and smaller images should never be jpeg - or the GUI will look awful. I downsample my images to 565 (16-bit), and then compress them. LZSS by Haruhiko Okumura (patent-free) is very good. But for simple GDI stuff, gif/png is better (though loading time of apps increases). <br /><br />I can be useful if you tell what your target software is (where WL can/should be used). </div>
    <div class="meta">Posted on 2005-07-08 18:13:19 by Ultrano</div>
   </div>
   <div class="post" id="post-162111">
    <div class="subject"><a href="#post-162111">Re: WankerLIB alpha 1.0 + long code post of example</a></div>
    <div class="body">Thank you for your honest and useful feedback.<br /><br />Yes the next release would include the sprites - I am stalled trying to write a decent skinner.<br /><br />One point I tend to disagree with is the garbling of registers - I&#39;ve learned long ago not to trust the win32api&#39;s as they garble the registers also. Why add to the confusion and/or difficulty of coding as to preserve them?&nbsp; I always save my registers before any function call which isn&#39;t mine. When I come to code it again later like in five months, what documentation do I have to say it&#39;s safe to spit in the wind?<br /><br />The target is myself and other newcomers who wish to run before they walk.&nbsp; It will primarily be for myself to code simple games or remakes.&nbsp; When I go code something else, it will be reusable and I won&#39;t have to start from ground zero. If someone else finds it useful then great.<br /><br />I do need help with the memory. I found I had to do a call to GetProcessHeap everytime to allocate each block of memory and again to release it, but if I am wrong please let me know.<br /><br /></div>
    <div class="meta">Posted on 2005-07-15 09:57:08 by drarem</div>
   </div>
   <div class="post" id="post-162112">
    <div class="subject"><a href="#post-162112">Re: WankerLIB alpha 1.0 + long code post of example</a></div>
    <div class="body">hahahahhahaha WankerLib its golden</div>
    <div class="meta">Posted on 2005-07-15 10:52:50 by comrade</div>
   </div>
  </div>
 </body>
</html>