<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>3D IsPointInTriangle test (uses facos) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=21010" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=21010">3D IsPointInTriangle test (uses facos)</a></p>
   <div class="post" id="post-159283">
    <div class="subject"><a href="#post-159283">3D IsPointInTriangle test (uses facos)</a></div>
    <div class="body">Heya :)<br />This snippet may or may not interest you&nbsp; :P<br />The following (working, tested !!) code returns TRUE or FALSE for whether a given 3D Point is within the Bounds of (and on the Plane of) the given 3D Triangle.<br />It ONLY works if the test point is on the triangle plane, but if that point was the result of an initial &quot;plane intersection&quot; test, then we can be sure this secondary &quot;geometry bounds&quot; test will work correctly.<br /><br /><br /><pre><code><br />;Test for whether intersection point (on Plane) is within actual triangle boundary<br />;This is achieved by using acos to measure the angles formed between pairs of<br />;triangle edges and the testpoint, and totalling the resulting angles.<br />;Points inside the triangle result in an angle very close to 2pi radians (360 degrees).<br />;It should be exactly so, but floating point error must be considered.<br />;We allow a small epsilon (fudging margin).<br />;If it&#39;s &quot;very close to 2pi&quot; we return TRUE, otherwise we return FALSE.<br />;Sadly, this method ONLY works for points on the Plane of the subject Triangle :(<br />;Happily, our Plane Intersection Point is always guaranteed to be on the Plane :)<br /><br />IsPointInTriangle proc uses esi edi pPoint, pV0, pV1, pV2<br />local vec0:Vec3<br />local vec1:Vec3<br />local vec2:Vec3<br />local ftemp:REAL4<br />local ftemp0:REAL4<br />local ftemp1:REAL4<br />local ftemp2:REAL4<br /><br />;&nbsp; &nbsp; vec0 = Normalize( vtxPoint - vtx0 );<br />mov esi, pPoint<br />mov edi, pV0<br />fld .Vec3.X<br />fsub .Vec3.X<br />fstp vec0.X<br />fld .Vec3.Y<br />fsub .Vec3.Y<br />fstp vec0.Y<br />fld .Vec3.Z<br />fsub .Vec3.Z<br />fstp vec0.Z<br />invoke Vec3Normalize, addr vec0<br /><br />;&nbsp; &nbsp; vec1 = Normalize( vtxPoint - vtx1 );<br />mov edi, pV1<br />fld .Vec3.X<br />fsub .Vec3.X<br />fstp vec1.X<br />fld .Vec3.Y<br />fsub .Vec3.Y<br />fstp vec1.Y<br />fld .Vec3.Z<br />fsub .Vec3.Z<br />fstp vec1.Z<br />invoke Vec3Normalize, addr vec1<br /><br />;&nbsp; &nbsp; vec2 = Normalize( vtxPoint - vtx2 );<br />mov edi, pV2<br />fld .Vec3.X<br />fsub .Vec3.X<br />fstp vec2.X<br />fld .Vec3.Y<br />fsub .Vec3.Y<br />fstp vec2.Y<br />fld .Vec3.Z<br />fsub .Vec3.Z<br />fstp vec2.Z<br />invoke Vec3Normalize, addr vec2<br /><br />invoke Vec3Dot, addr vec0, addr vec1<br />fst ftemp&nbsp; &nbsp; &nbsp;  ;This fpu stall is because we need the DotProduct result<br />fld ftemp&nbsp; &nbsp; &nbsp;  ;to be in st(0) and also in st(1) in order for facos() to work correctly<br />facos<br />fstp ftemp0<br /><br />invoke Vec3Dot, addr vec1, addr vec2<br />fst ftemp<br />fld ftemp<br />facos<br />fstp ftemp1<br /><br />invoke Vec3Dot, addr vec2, addr vec0<br />fst ftemp<br />fld ftemp<br />facos<br />fstp ftemp2<br /><br />fld ftemp0<br />fadd ftemp1<br />fadd ftemp2<br />fldpi<br />fmul fp2<br />fsub<br />fabs<br />fcomp fpepsilon ;small floating point value like 0.001f<br />__FJGE @F<br />return TRUE<br />@@:<br />return FALSE<br />IsPointInTriangle endp<br /></code></pre><br /><br />Have a nice day :)<br /></div>
    <div class="meta">Posted on 2005-04-25 11:17:43 by Homer</div>
   </div>
   <div class="post" id="post-159816">
    <div class="subject"><a href="#post-159816">Re: 3D IsPointInTriangle test (uses facos)</a></div>
    <div class="body">Perhaps this will run a bit faster:<br /><pre><code><br />IsPointInTriangle proc uses ecx pPoint, pV0, pV1, pV2<br />	local vec0:Vec3<br />	local vec1:Vec3<br />	local vec2:Vec3<br />	local ftemp:REAL4<br />	<br />	assume eax:ptr Vec3<br />	assume ecx:ptr Vec3<br />	<br />	;----[ cache vtxPoint ]----------\<br />	mov ecx,pPoint<br />	fld .Z<br />	fld .Y<br />	fld .X<br />	;--------------------------------/<br />	<br />	; Y Z pX pY pZ<br />	<br />	;----[&nbsp; vec0 = Normalize( vtxPoint - vtx0 ); ]------------\<br />	mov eax,pV0<br />	fld .Z<br />	fsub ST,ST(3)<br />	fld .Y<br />	fsub ST,ST(3)<br />	fld .X<br />	fsub ST,ST(3)<br />	fstp vec0.X<br />	fstp vec0.Y<br />	fstp vec0.Z<br />	invoke Vec3Normalize,addr vec0<br />	;---------------------------------------------------------/<br />	<br />	;----[&nbsp; vec1 = Normalize( vtxPoint - vtx1 ); ]------------\<br />	mov eax,pV1<br />	fld .Z<br />	fsub ST,ST(3)<br />	fld .Y<br />	fsub ST,ST(3)<br />	fld .X<br />	fsub ST,ST(3)<br />	fstp vec1.X<br />	fstp vec1.Y<br />	fstp vec1.Z<br />	invoke Vec3Normalize,addr vec1<br />	;---------------------------------------------------------/<br />	<br />	;----[&nbsp; vec2 = Normalize( vtxPoint - vtx2 ); ]------------\<br />	mov eax,pV2<br />	fld .Z<br />	fsub ST,ST(3)<br />	fld .Y<br />	fsub ST,ST(3)<br />	fld .X<br />	fsub ST,ST(3)<br />	fstp vec2.X<br />	fstp vec2.Y<br />	fstp vec2.Z<br />	invoke Vec3Normalize,addr vec2<br />	;---------------------------------------------------------/<br />	<br />	;-----[ free the vtxPoint cache ]---\<br />	assume eax:nothing<br />	assume ecx:nothing<br />	<br />	fdecstp ; pop vtxPoint.X to nothing<br />	fdecstp ; pop vtxPoint.Y to nothing<br />	fdecstp ; pop vtxPoint.Z to nothing<br />	;-----------------------------------/<br />	<br />	;-----------[ Do dot-products ]----------------\<br />	invoke Vec3Dot,addr vec0,addr vec1<br />	fld ST<br />	facos ; a macro that needs ST(0) = ST(1) <br />	; note: ST(0) now contains the angle1 value<br />	<br />	invoke Vec3Dot,addr vec0,addr vec1<br />	fld ST<br />	facos&nbsp; ; ST(0) contains the angle2 value<br />	fadd&nbsp; ; angle1+= angle2, discard angle2<br />	<br />	invoke Vec3Dot,addr vec0,addr vec1<br />	fld ST<br />	facos&nbsp; ; ST(0) contains the angle3 value<br />	fadd&nbsp; ; angle1+= angle3, discard angle3<br />	;----------------------------------------------/<br />	<br />	;-------[ introduce fp2 and finalize ]--------------\<br />	fldpi<br />	fmul fp2&nbsp; ; &lt;------ what is this ?!<br />	fsub ;&nbsp; angle1 = angle1 - (fp2 * 3.1415)<br />	fabs<br />	fstp ftemp<br />	xor eax,eax<br />	cmp ftemp,3A83126Fh ; 0.001f<br />	setl al<br />	;---------------------------------------------------/<br />	ret<br />IsPointInTriangle endp<br /></code></pre><br /><br />But I need to know the definitions of facos, and what fp2 is. <br />We can also optimize this further, by replacing the calls to Vec3Normalize and Vec3Dot with macros - though, we may run out of FPU registers ^^&quot; - but still. at least 6 extra cycles will be saved this way :)</div>
    <div class="meta">Posted on 2005-05-07 14:01:04 by Ultrano</div>
   </div>
   <div class="post" id="post-159852">
    <div class="subject"><a href="#post-159852">Re: 3D IsPointInTriangle test (uses facos)</a></div>
    <div class="body">facos is a macro I describe elsewhere on this board.<br />It&#39;s &quot;acos&quot;, also known as &quot;arc cosine&quot;.<br />The source is here, and on my old hdd which is still covered in melted plastic (hope its ok!)<br /><br />fp2 is simply 2.0f<br />I needed the value 2*pi (this is 360 degrees, in Radians)<br />and I was too lazy to define it since I already had fp2 defined, and since fldpi is a valid opcode.<br /><br />The above test requires that the point being tested is on the plane of the test triangle.<br />The above test is really measuring the three angles formed between a theoretical edge (based on the testpoint and the surfacenormal of the triangle) and another theoretical edge (based on the testpoint and each triangle vertex).<br />If the point is inside the triangle, these should total to 360 degrees, aka 2pi radians.<br />Due to fpu error the actual result may vary slightly and so we employ an Epsilon (fudge value).<br /><br />You can visualize this test by drawing a 2D triangle on paper, and placing deliberately a point inside it.<br />Now draw lines from the point to each triangle vertex.<br />The angles inbetween the lines you drew total 360 degrees.<br /><br />That&#39;s how the test works.<br />It saves us from performing three separate 3D point / edge tests and then checking the three results, it produces accurate results but only if we can ensure the test point is already on the plane of the triangle.<br />That&#39;s why I stress that the test point should be the result of a ray/plane test, ie, an intersection point on the plane of the triangle.<br /><br /></div>
    <div class="meta">Posted on 2005-05-08 03:47:07 by Homer</div>
   </div>
   <div class="post" id="post-160039">
    <div class="subject"><a href="#post-160039">Re: 3D IsPointInTriangle test (uses facos)</a></div>
    <div class="body">I sourced most of my Vec3 math code from a set of fpu macros released by Caleb with his masm DX8 includes. I chose to wrap a couple that I use heavily as procs to keep my binary size down.<br />No worries about overflowing the fpu either way mate :)<br /><br /></div>
    <div class="meta">Posted on 2005-05-12 22:07:09 by Homer</div>
   </div>
  </div>
 </body>
</html>