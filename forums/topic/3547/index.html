<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Byte shuffling challenge. - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=3547" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=3547">Byte shuffling challenge.</a></p>
   <div class="post" id="post-23559">
    <div class="subject"><a href="#post-23559">Byte shuffling challenge.</a></div>
    <div class="body">Nice stuff Thomas.. I like the idea of putting challenges on the board, keeps the brains fresh. ;)<br /><br />I'd like to propose one not-too-trivial practical problem I came across some time ago.. let's see:<br /><br />Input: You have a 32bit CPU register containing four bytes, let's call them ABCD.<br /><br />Output: You have to output 3 registers (one of which will be the original register), containing the original ABCD components, but reordered this way:<br /><br />orig.reg = DBCD <br />2nd.reg  = CDBC<br />3rd.reg  = BCDB<br /><br />The challenge for the most optimized asm code is open ;-)<br />I didn't spend much time on my code but it seems very efficient. I'll post it after you all.. and if you wrote a better one, I'll jump into the challenge myself to try to do even better. :)<br /><br />Greets,<br />Maverick</div>
    <div class="meta">Posted on 2002-02-09 13:03:29 by Maverick</div>
   </div>
   <div class="post" id="post-23563">
    <div class="subject"><a href="#post-23563">Byte shuffling challenge.</a></div>
    <div class="body"><div class="quote">Nice stuff Thomas.. I like the idea of putting challenges on the board, keeps the brains fresh. </div><br />Well it was The Svin's idea, I just posted the challenge..<br /><br />For your challenge, here's one solution... to be the first :), it can probably be done much better.<br /><br /><pre><code><br />    mov     ecx, eax<br />    shl     eax, 8<br />    mov     al, cl<br />    ror     eax, 8<br />    mov     ecx, eax<br />    shl     ecx, 16<br />    ror     eax, 8<br />    mov     edx, eax<br />    mov     cx, ax<br />    rol     eax, 8<br />    ror     edx, 16<br />    mov     dl, ch<br /></code></pre><br /><strong>edit:<br />eax = src &amp; first output<br />ecx = second output<br />edx = third output<br /></strong><br />Thomas</div>
    <div class="meta">Posted on 2002-02-09 13:44:02 by Thomas</div>
   </div>
   <div class="post" id="post-23565">
    <div class="subject"><a href="#post-23565">Byte shuffling challenge.</a></div>
    <div class="body">A shorter and faster version:<br /><pre><code><br />    mov     ecx, eax<br />    shl     eax, 8<br />    mov     edx, eax<br />    mov     al, ah<br />    ror     ecx, 16<br />    mov     dl, cl<br />    ror     eax, 16<br />    mov     cx, ax<br />    rol     eax, 8<br /></code></pre><br /><br />About 4 clockcycles on an athlon thunderbird.<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-02-09 13:56:03 by Thomas</div>
   </div>
   <div class="post" id="post-23584">
    <div class="subject"><a href="#post-23584">Byte shuffling challenge.</a></div>
    <div class="body">This only uses rol's and mov's:<pre><code><br />rol	eax, 8<br />mov	edx, eax<br />rol	eax, 8<br />mov	ecx, eax<br />mov	ah, dh<br />mov	dl, al<br />rol	eax, 16<br />mov	ch, ah<br /><br />; eax = DBCD <br />; ecx = CDBC <br />; edx = BCDB</code></pre></div>
    <div class="meta">Posted on 2002-02-09 17:39:02 by eet_1024</div>
   </div>
   <div class="post" id="post-23587">
    <div class="subject"><a href="#post-23587">Byte shuffling challenge.</a></div>
    <div class="body">Hi eet_1024,<br /><br />I can talk only at the end, but I must warn you that your routine produces a wrong result in ECX:<br /><br />It produces CDCB instead of CDBC.<br /><br />Just wanted to inform you about that.<br /><br />When the posts stop I will start a deeper discussion on all the implications, and why did I say &quot;not-too-trivial practical problem&quot;.. and the seriously understimated importance that development tools have in my opinion. :)<br /><br />Greets,<br />Maverick</div>
    <div class="meta">Posted on 2002-02-09 17:55:33 by Maverick</div>
   </div>
   <div class="post" id="post-23598">
    <div class="subject"><a href="#post-23598">Byte shuffling challenge.</a></div>
    <div class="body">Fixed:<pre><code><br />shl	eax, 8<br />mov	ecx, eax<br />mov	edx, eax<br />shr	ecx, 16<br />or	dl, ch<br />shl	eax, 8<br />or	ecx, eax<br />or	ax, dx<br />rol	eax, 16</code></pre><br /><br />After finishing this, I noticed that it looks very similar to Thomas's.</div>
    <div class="meta">Posted on 2002-02-09 20:56:36 by eet_1024</div>
   </div>
   <div class="post" id="post-23611">
    <div class="subject"><a href="#post-23611">Byte shuffling challenge.</a></div>
    <div class="body">This is a little different:<pre><code>	mov edx,eax ; ABCD<br />	shl eax,8   ; BCD0<br />	xchg dl,dh  ; ABDC<br />	mov ecx,eax ; BCD0<br />	bswap edx   ; CDBA<br />	mov al,ah   ; BCDD<br />	mov cl,dh   ; BCDB *<br />	ror eax,8   ; DBCD *<br />;-<br />	mov dl,ah   ; CDBC *</code></pre>Should be fast, too?  I am very interested in the explaination for needing this algo, and await your comments, <strong>Maverick</strong>.<pre><code>	mov edx,eax ; ABCD<br />	shl eax,8   ; BCD0<br />	xchg dl,dh  ; ABDC<br />	mov ecx,eax ; BCD0<br />	mov al,ah   ; BCDD<br />	bswap edx   ; CDBA<br />	ror eax,8   ; DBCD *<br />	mov cl,dh   ; BCDB *<br />	mov dl,ah   ; CDBC *</code></pre></div>
    <div class="meta">Posted on 2002-02-09 22:46:12 by bitRAKE</div>
   </div>
   <div class="post" id="post-23630">
    <div class="subject"><a href="#post-23630">Byte shuffling challenge.</a></div>
    <div class="body">Another solution :<br /><br /><pre><code><br />mov	eax, 0AABBCCDDh	;// eax = ABCD<br />mov	edx, eax		;// edx = ABCD<br />mov	ecx, eax		;// ecx = ABCD<br />shl	edx, 8		;// edx = BCD0<br />shld	ecx, edx, 8	;// ecx = BCDB<br />shld	eax, ecx, 24	;// eax = DBCD<br />shrd	edx, eax, 16	;// edx = CDBC<br /></code></pre></div>
    <div class="meta">Posted on 2002-02-10 03:31:35 by Dr. Manhattan</div>
   </div>
   <div class="post" id="post-23661">
    <div class="subject"><a href="#post-23661">Byte shuffling challenge.</a></div>
    <div class="body">This is even slower than <strong>Dr. Manhattan</strong>'s. ;)<br />20 bytes (one byte larger than <strong>Dr. Manhattan</strong>'s).<pre><code>push eax<br />rol eax,8<br />push eax ; Stack = ADCBDCBA<br />mov eax,&#91;esp + 1&#93; ; DBCD<br />mov edx,&#91;esp + 2&#93; ; CDBC<br />mov ecx,&#91;esp + 3&#93; ; BCDB<br />add esp,8</code></pre>This is the fastest on my machine:<pre><code>	mov edx,eax ; ABCD<br />	rol eax,8   ; BCD0<br />	rol edx,16  ; CDAB<br />	mov ecx,eax ; BCD0<br />	mov al,ah   ; BCDD<br />	rol dx,8    ; CDBA<br />	ror eax,8   ; DBCD *<br />	mov cl,dh   ; BCDB *<br />	mov dl,ah   ; CDBC *</code></pre>...under 4 ticks on Athlon. ;)</div>
    <div class="meta">Posted on 2002-02-10 10:25:57 by bitRAKE</div>
   </div>
   <div class="post" id="post-23672">
    <div class="subject"><a href="#post-23672">Byte shuffling challenge.</a></div>
    <div class="body">shld and shlr are sloooow :)<br /><br />By the way, how do you measure the number of ticks ?<br /><br />I use the following code<br /><br />.data<br />TICK_A DWORD 0<br /><br />.CODE<br /><br />rdtsc <br />mov TICK_A, eax<br /><br />; code...<br /><br />rdtsc<br />sub eax, TICK_A<br /><br />But the timings are not constant, even when there is no code to test !</div>
    <div class="meta">Posted on 2002-02-10 12:33:06 by Dr. Manhattan</div>
   </div>
   <div class="post" id="post-23673">
    <div class="subject"><a href="#post-23673">Byte shuffling challenge.</a></div>
    <div class="body">There is a very long winded explaination as to why, but I use the lowest count of several loops with overlaping copies.  Here is the code:</div>
    <div class="meta">Posted on 2002-02-10 12:40:57 by bitRAKE</div>
   </div>
   <div class="post" id="post-23676">
    <div class="subject"><a href="#post-23676">Byte shuffling challenge.</a></div>
    <div class="body"><div class="quote"><em>Originally written by Maverick</em><strong><br /><br />Nice stuff Thomas.. I like the idea of putting challenges on the board, keeps the brains fresh. <br /><br />I'd like to propose one not-too-trivial practical problem I came across some time ago.. let's see:<br /><br />Input: You have a 32bit CPU register containing four bytes, let's call them ABCD.<br /><br />Output: You have to output 3 registers (one of which will be the original register), containing the original ABCD components, but reordered this way:<br /><br />orig.reg = DBCD <br />2nd.reg  = CDBC <br />3rd.reg  = BCDB <br /><br />The challenge for the most optimized asm code is open ;-)<br /></div><br />Several replies came. I think that the proposed solutions span all possible implementations, so I think I could close the &quot;competition&quot;.<br /><br />Well, in my original post I called it a &quot;not-too-trivial practical problem&quot; for a reason: this is a good example of an algorithm for which probably there is not a good solution that spans all the CPU's. It is also a good example of how much a human skilled coder is better than compilers, and/or of how good a certain compiler is. Also, when doing your evaluations, keep in mind that all the modern CPU's are designed with the goal to execute as fast as possible the code generated by high level (mostly C/C++) compilers.. rather than human asm coders.<br /><br />But it's also a good example of how much primitive are still today the standard tools that ~everybody uses and thinks that are &quot;THE ONLY WAY THAT EXISTS&quot;.<br />I've always believed that tools are an extremely important part of the work, and I've always felt kinda lonely in this belief. I created my own programming language, compiler and source-level debugger on the Amiga, as well on the PC (work in progress), where, among many other things, I introduced a layered loader.. which, again among other things, can load different code depending on the CPU running in the system. So you can have automatically loaded the best routine for the PC your program is running on, and leave the others on disk. If you think that 3x times of difference in clock cycles count for an innerloop is a difference, then you will agree that the development time to spend on own development tools pays back (BTW: it took me less time to write my HLA language on Amiga plus my game Virtual Karting than if I wrote Virtual Karting 100% in assembly! And then the language was there to be reused, as well as most of my first HLA-made game's code. Note that my language has the same name of Randall Hyde's HLA, but Randall's one came many years after and has really nothing in common with my language (I was also a bit unhappy about the shared name, urgh, not his fault though; he even proved that IBM used HLA even before me)). Anyway, let's look at the results of our optimizations:<br /><br />First of all, the routines:<br /><br /><pre><code><br /><br />Maverick - Athlon XP optimized n.1 &#40;original routine&#41;&#58;<br />                                       ; EAX = ABCD &#40;entry&#41;<br />        shl     eax,8                  ; EAX = BCD0<br />        mov     ebx,eax                ; EBX = BCD0<br />        mov     al,ah                  ; EAX = BCDD<br />        mov     ecx,ebx                ; ECX = BCD0<br />        rol     ebx,8                  ; EBX = CD0B<br />        ror     eax,8                  ; EAX = DBCD &#40;out 1&#41;<br />        mov     cl,bl                  ; ECX = BCDB &#40;out 3&#41;<br />        mov     bh,bl                  ; EBX = CDBB<br />        mov     bl,ah                  ; EBX = CDBC &#40;out 2&#41;<br /><br />		<br />Maverick - Athlon XP optimized n.2 &#40;based on BitRake 2nd, and improved&#41;&#58;<br />                                       ; EAX = ABCD &#40;entry&#41;<br />        mov     ecx,eax                ; ECX = ABCD<br />        rol     eax,8                  ; EAX = BCD0<br />        rol     cx,8                   ; ECX = ABDC<br />        mov     ebx,eax                ; EBX = BCD0<br />        mov     al,ah                  ; EAX = BCDD<br />        bswap   ecx                    ; ECX = CDBA<br />        ror     eax,8                  ; EAX = DBCD &#40;out 1&#41;<br />        mov     bl,ch                  ; EBX = BCDB &#40;out 3&#41;<br />        mov     cl,ah                  ; ECX = CDBC &#40;out 2&#41;<br /><br /><br />Maverick - Pentium-II optimized &#40;original routine, extremely similar to Dr.Manhattan's!!&#41;&#58;<br />                                       ; EAX = ABCD &#40;entry&#41;<br />        mov     ecx,eax                ; ECX = ABCD<br />        mov     ebx,eax                ; EBX = ABCD<br />        rol     ecx,8                  ; ECX = BCDA<br />        shld    ebx,ecx,8              ; EBX = BCDB &#40;out 3&#41;<br />        shld    eax,ebx,24             ; EAX = DBCD &#40;out 1&#41;<br />        shrd    ecx,eax,16             ; ECX = CDBC &#40;out 2&#41;<br /><br /><br />Thomas 1st attempt&#58;<br />        mov     ecx, eax<br />        shl     eax, 8<br />        mov     al, cl<br />        ror     eax, 8<br />        mov     ecx, eax<br />        shl     ecx, 16<br />        ror     eax, 8<br />        mov     edx, eax<br />        mov     cx, ax<br />        rol     eax, 8<br />        ror     edx, 16<br />        mov     dl, ch<br /><br /><br />Thomas 2nd attempt&#58;<br />        mov     ecx, eax<br />        shl     eax, 8<br />        mov     edx, eax<br />        mov     al, ah<br />        ror     ecx, 16<br />        mov     dl, cl<br />        ror     eax, 16<br />        mov     cx, ax<br />        rol     eax, 8<br /><br /><br />eet_1024&#58;<br />        shl     eax, 8<br />        mov     ecx, eax<br />        mov     edx, eax<br />        shr     ecx, 16<br />        or      dl, ch<br />        shl     eax, 8<br />        or      ecx, eax<br />        or      ax, dx<br />        rol     eax, 16<br /><br /><br />BitRake 1st attempt&#58;<br />        mov     edx,eax ; ABCD<br />        shl     eax,8   ; BCD0<br />        xchg    dl,dh   ; ABDC<br />        mov     ecx,eax ; BCD0<br />        bswap   edx     ; CDBA<br />        mov     al,ah   ; BCDD<br />        mov     cl,dh   ; BCDB *<br />        ror     eax,8   ; DBCD *<br />        mov     dl,ah   ; CDBC *<br /><br /><br />BitRake 2nd attempt&#58;<br />        mov     edx,eax ; ABCD<br />        shl     eax,8   ; BCD0<br />        xchg    dl,dh   ; ABDC<br />        mov     ecx,eax ; BCD0<br />        mov     al,ah   ; BCDD<br />        bswap   edx     ; CDBA<br />        ror     eax,8   ; DBCD *<br />        mov     cl,dh   ; BCDB *<br />        mov     dl,ah   ; CDBC *<br /><br /><br />Dr.Manhattan&#58;<br />                                ;// eax = ABCD<br />        mov     edx, eax        ;// edx = ABCD<br />        mov     ecx, eax        ;// ecx = ABCD<br />        shl     edx, 8          ;// edx = BCD0<br />        shld    ecx, edx, 8     ;// ecx = BCDB<br />        shld    eax, ecx, 24    ;// eax = DBCD<br />        shrd    edx, eax, 16    ;// edx = CDBC<br /><br /><br />WatcomC/C++ 11.0 optimized code &#40;one of the best optimizing compilers around&#41;&#58;<br />        shl     ecx,0x00000008               ; ECX = entry<br />        mov     eax,ecx<br />        mov     edx,ecx<br />        and     eax,0x0000ff00<br />        xor     cl,cl<br />        shr     eax,0x00000008<br />        or      ecx,eax<br />        mov     eax,edx<br />        mov     esi,edx<br />        shl     eax,0x00000008<br />        shr     edx,0x00000018<br />        or      edx,eax<br />        mov     eax,ecx<br />        shr     eax,0x00000008<br />        shl     ecx,0x00000018<br />        or      ecx,eax<br />        mov     eax,edx<br />        and     si,0x0ff00<br />        and     eax,0x000000ff<br />        xor     dh,dh<br />        or      esi,eax<br />        shl     eax,0x00000008<br />        or      edx,eax<br />        mov     eax,ecx<br />        and     eax,0x0000ff00<br />        xor     dl,dl                        ; ECX = 1st<br />        shr     eax,0x00000008               ; EDX = 2nd<br />        or      edx,eax                      ; ESI = 3rd<br /><br /></code></pre><br /><br /><br />I'm impressed about four things in particular:<br /><br />1) The great disparity of optimal code depending on the CPU (and that's why I called it a not-so-trivial *practical* problem). I will say more about this soon.<br /><br />2) One of my solutions was almost identical to Dr.Manhattan's one.. (too bad that although it looks like the most elegant and short of all, it's actually by far the slowest on my Athlon XP! SHLD/SHRD are such a good resource that I wish it was more optimized in these CPU's.. I kept it only because I later found it to be still optimal on PentiumII, half cycle better than a previous routine I wrote which used only 32bit registers to avoid partial register stalls on those CPU's). Also, I wrote a stack-based routine which looked extremely elegant too, but didn't perform well on most modern CPU's.<br /><br />3) Many solutions were extremely similar to each other.. showing that we're bare to the metal already (if it was necessary to show this).<br /><br />4) Me (Maverick), BitRake and Dr.Manhattan all used the same style in commenting.. shows maybe a similar structured mind. ;)<br /><br />---<br /><br />Now it's time for some benchmarking. Available machines are:<br /><br />Athlon-XP<br />Pentium-II<br />K6-2<br />Pentium-S<br /><br />Benchmark is done by counting the number of CPU cycles that it takes to compute each routine unrolled 10 times and looped 1,000,000 of times. The total clock cycles count is then divided by 10,000,000. The benchmark is performed under Dos (i.e. no virtual memory nor multitasking interferences).<br /><br />---<br /><br />on the Athlon-XP:<br /> 4.20 cycles = Maverick - Athlon XP opt.1<br /> 3.70 cycles = Maverick - Athlon XP opt.2<br />10.20 cycles = Maverick - Pentium-II opt<br /> 6.10 cycles = Thomas 1st attempt<br /> 4.40 cycles = Thomas 2nd attempt<br /> 4.30 cycles = eet_1024<br /> 5.00 cycles = BitRake 1st attempt<br /> 5.00 cycles = BitRake 2nd attempt<br />10.20 cycles = Dr.Manhattan<br />11.90 cycles = WatcomC/C++ 11.0 opt<br /><br /><br />on the Pentium-II:<br /> 9.20 cycles = Maverick - Athlon XP opt.1<br />11.10 cycles = Maverick - Athlon XP opt.2<br /> 7.00 cycles = Maverick - Pentium-II opt<br />12.20 cycles = Thomas 1st attempt<br /> 9.30 cycles = Thomas 2nd attempt<br />10.10 cycles = eet_1024<br />17.50 cycles = BitRake 1st attempt<br />11.70 cycles = BitRake 2nd attempt<br /> 7.00 cycles = Dr.Manhattan<br />32.00 cycles = WatcomC/C++ 11.0 opt<br /><br /><br />on the K6-2:<br />10.00 cycles = Maverick - Athlon XP opt.1<br />12.30 cycles = Maverick - Athlon XP opt.2<br /> 9.30 cycles = Maverick - Pentium-II opt<br />16.60 cycles = Thomas 1st attempt<br />11.00 cycles = Thomas 2nd attempt<br />11.40 cycles = eet_1024<br />13.20 cycles = BitRake 1st attempt<br />11.10 cycles = BitRake 2nd attempt<br /> 9.00 cycles = Dr.Manhattan<br />24.00 cycles = WatcomC/C++ 11.0 opt<br /><br /><br />on the Pentium-S:<br /> 7.00 cycles = Maverick - Athlon XP opt.1<br /> 9.00 cycles = Maverick - Athlon XP opt.2<br />15.00 cycles = Maverick - Pentium-II opt<br />12.00 cycles = Thomas 1st attempt<br /> 9.00 cycles = Thomas 2nd attempt<br /> 7.00 cycles = eet_1024<br />10.00 cycles = BitRake 1st attempt<br /> 9.00 cycles = BitRake 2nd attempt<br />15.00 cycles = Dr.Manhattan<br />20.00 cycles = WatcomC/C++ 11.0 opt<br /><br /><br />---<br /><br />My development machine is an Athlon-XP, but I can have (rare) testing access on those other listed machines as well.<br /><br />It is my habit now to produce (for my key routines, where speed matters) different versions for each CPU. My own executable format's loader will then load the right routine for the host PC. This includes also MMX2,3DNow,etc..<br /><br />If you do not think that this is useful, then.. for example, if I had to choose my Pentium-II optimized routine for all, then it would be nearly 3 times suboptimal on Athlon-XP's!!! Is 3x an significant difference? It is the same difference (well, ratio ;) ) between 1700 MHz and 5100 MHz.. it is not much, right? &quot;Why bother.. use a C compiler, it's unbeatable&quot;, and the virtual 5100 MHz drop to 1115 (Pentium-II case). Buy a faster CPU, eh!! ;-)<br /><br />Run-time checks are tedious, and you also waste RAM keeping all the versions together; it's much better to have a loader that chooses the right routine for you. A loader can do much more for you, it can resolve inter-module referiments (dynamic linking) and e.g. avoid many virtual function pointers, for increased performance not possible with the standard .EXE OS loader, and give other benefits as well (also for protection purposes).<br /><br />---<br /><br />PS: BitRake,<br />The use of this routine is simply to pack xRGB values into RGBRGBRGBRGB, so to e.g. quickly draw horizontal lines or bars on a 24bit screen, and not have to go to 32bit which steals precious bandwidth, or anyway in the cases where one has to work with 24bit screens. When I faced this problem I thought it was a very good testbench for my compiler's optimizer, and for any human coder.. and a good example of how key routines (as e.g. gfx routines) should come in many versions.. one of each possible host CPU, and automatically loaded. Also, you gave me the possibility to improve further my Athlon-XP version. ;)<br /><br />I'm forwarding this post now to comp.lang.asm.x86, I think it may interest some people there.<br /><br />Greets,<br />Maverick</div>
    <div class="meta">Posted on 2002-02-10 13:01:45 by Maverick</div>
   </div>
   <div class="post" id="post-23689">
    <div class="subject"><a href="#post-23689">Byte shuffling challenge.</a></div>
    <div class="body"><strong>Maverick</strong>, I get 3.9000023 cycles for your best on my Athlon?  Mine is 3.8000021, very strange?  I tried to use the same test conditions you outlined.  Could you post the test proggie, or use mine above?  Can you try the second version from my second post:<pre><code>	mov edx,eax ; ABCD<br />	rol eax,8   ; BCD0<br />	rol edx,16  ; CDAB<br />	mov ecx,eax ; BCD0<br />	mov al,ah   ; BCDD<br />	rol dx,8    ; CDBA ; faster than mov dh,dl?<br />	ror eax,8   ; DBCD *<br />	mov cl,dh   ; BCDB *<br />	mov dl,ah   ; CDBC *</code></pre>The XCHG instruction is too costly.<br /><br />I find that the added bandwidth of 32 bits is offset by the speed of MMX and the use of an alpha channel.<br /><br />I like the sound of your loader being able to use different version of code! :alright:</div>
    <div class="meta">Posted on 2002-02-10 14:57:51 by bitRAKE</div>
   </div>
   <div class="post" id="post-23716">
    <div class="subject"><a href="#post-23716">Byte shuffling challenge.</a></div>
    <div class="body">Howdy bitRAKE :)<br /><br /><div class="quote"><strong>Maverick, I get 3.9000023 cycles for your best on my Athlon? Mine is 3.8000021, very strange? I tried to use the same test conditions you outlined. Could you post the test proggie, or use mine above? Can you try the second version from my second post:</div><br />Done.. here's the benchmark results with your added routines, on a Athlon-XP (not Athlon.. but I will have access to an Athlon machine in 3 days and test it also there):<br /><br />Maverick Athlon-XP opt.1:    cycles=4.20<br />Maverick Athlon-XP opt.2:    cycles=3.70<br />Maverick Pentium-II:         cycles=10.20<br />Thomas 1st attempt:          cycles=6.10<br />Thomas 2nd attempt:          cycles=4.40<br />eet_1024 fxd attempt:        cycles=4.30<br />BitRake 1st attempt:         cycles=5.00<br />BitRake 2nd attempt:         cycles=5.00<br />BitRake 3rd attempt:         cycles=18.00<br />BitRake 4th attempt:         cycles=3.80<br />Dr.Manhattan attempt:        cycles=10.20<br />C much opt. routine:         cycles=11.90<br /><br />I'm attaching the sourcecode of my test program.. I wrote it in 5 minutes, it doesn't subtract some setup cycles etc.. today I've been with my girlfriend and didn't really have much time for coding.. the results are reliable, though. I guess the difference is because of your Athlon vs my Athlon-XP.<br />Also, I'm sure you're not running it in Windows though.. since that would false the results a bit, and make them not constant (I guess this is the problem that Dr.Manhattan was referring to).<br /><br />---<br /><br /><div class="quote"><strong>I find that the added bandwidth of 32 bits is offset by the speed of MMX and the use of an alpha channel.</div> <br />Indeed.. I'm not a fan of 24bit at all. I just *had* to use it for someone that commissioned me a library ;)<br />There was a GUI specific case in which I've chosen to use it, though.. but it's rare.<br /><br />If you're curious about what I often like and use.. and maybe even why.. normally I use 3 byteplanes (4 or more sometimes, for added effects), and for some gfx things the &quot;classical CPU&quot; is still much better than MMX. ;)<br />We can discuss more about it.. but there are some things that I will keep for myself.<br /><br />Byteplanes are 256 colors 2D arrays of only one color component.<br />I use them because they're much more cache-friendly.. it's clear that doing 8bit gfx three times what fits in the cache is better than doing one time 32bit what doesn't fit in the cache. ;)<br />Moreover, it simplifyes some tricky algorithms. I can also use wordplanes, and custom color formats in certain cases. I've always been kinda maniacal in this aspect, I even designed a hardware device on the Amiga (called AgaEXTENDER, you can search the Internet for it) that if Viscorp and Escom didn't go bankruptcy (after Commodore) would have given coders new impressive possibilities to do nice things.<br /><br />Now about the CPU vs MMX part: my font routine, but not only that, (sprites and more..) loads gfx but then precompiles it into machinecode. This means that e.g. an &quot;A&quot; becomes a bunch of MOV instructions, and some LEA or ADD. Even better a &quot;I&quot;. I could print 8 millions of characters (12x16) on real world tests very easily on a Athlon-800 @ 100MHz fsb and SDR memory this way. The same is for sprites with e.g. many holes in them.. and even more for other advanced stuff about which I can't talk, sorry.<br />Of course MMX is still very ok for other cases, as well as hardware 3D acceleration is. There's no rule of thumb.. only specific cases and specific solutions.<br /><br />Greets,<br />Maverick</div>
    <div class="meta">Posted on 2002-02-10 16:29:00 by Maverick</div>
   </div>
   <div class="post" id="post-23736">
    <div class="subject"><a href="#post-23736">Byte shuffling challenge.</a></div>
    <div class="body">Thanks for posting the bench code.  Very strange that there is a diffence between XP and standard Athlon?  Guess there really was some changes in the CPU.<br /><br />I totally agree about breaking the data up when it benefits the algo, and MMX certainly has it's limitations.</div>
    <div class="meta">Posted on 2002-02-10 18:41:13 by bitRAKE</div>
   </div>
   <div class="post" id="post-23907">
    <div class="subject"><a href="#post-23907">Byte shuffling challenge.</a></div>
    <div class="body"><div class="quote"><br />Thanks for posting the bench code.</div>You're wellcome :)<br /><br /><div class="quote"><strong>Very strange that there is a diffence between XP and standard Athlon?  Guess there really was some changes in the CPU.</div>According to AMD there is.. my personal experience at the begin was that there wasn't any difference instead, so I suspected that the claimed better performances of the XP were rather because of the support of SSE/SSE2. But given our thread's results, I now believe that also the core was slightly improved. In any case, I'll know better in a couple of days (getting my hands on my old Athlon machine).<br /><br />Greets,<br />Mav</div>
    <div class="meta">Posted on 2002-02-11 16:51:06 by Maverick</div>
   </div>
  </div>
 </body>
</html>