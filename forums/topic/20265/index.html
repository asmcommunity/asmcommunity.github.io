<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Another optimization problem - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20265" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=20265">Another optimization problem</a></p>
   <div class="post" id="post-155140">
    <div class="subject"><a href="#post-155140">Another optimization problem</a></div>
    <div class="body">I hope that I give you good challenges in optimizing problems. This time I translated the Delphi code to assembly and it?s only 15ms faster. Delphi code runs in 140ms and asm code in 125ms in a Pentium 4 3.2 GHz with 1GB RAM. The problem is to find the edge to a monochromatic image. In the tests the image was 3507x4960 pixels.<br /><br />Can anyone suggest a better code or algorithm? The use of a table to avoid the comparitions could work better ?!?<br /><br />Delphi Code:<br /><br /><pre><code>t1 &#58;= GetTickCount;<br />  for i &#58;= 1 to 1 do<br />  begin<br />    p &#58;= src;<br />    q &#58;= dst;<br />    r &#58;= w*&#40;h-1&#41;;<br />    for x &#58;= 0 to w-1 do<br />    begin<br />      if p&#91;x&#93; = BLACK then<br />        q&#91;x&#93; &#58;= BLACK;<br />      if p&#91;r+x&#93; = BLACK then<br />        q&#91;r+x&#93; &#58;= BLACK;<br />    end;<br />    for y &#58;= 0 to h-1 do<br />    begin<br />      r &#58;= w*y;<br />      if p&#91;r&#93; = BLACK then<br />        q&#91;r&#93; &#58;= BLACK;<br />      r &#58;= r+w-1;<br />      if p&#91;r&#93; = BLACK then<br />        q&#91;r&#93; &#58;= BLACK;<br />    end;<br />    for y &#58;= 1 to h-2 do<br />      begin<br />        p &#58;= bmp.ScanLine&#91;y&#93;;<br />        q &#58;= result.ScanLine&#91;y&#93;;<br />        for x &#58;= 1 to w-2 do<br />        begin<br />          if &#40;p&#91;x&#93; = BLACK&#41; and not &#40;&#40;p&#91;x-1&#93; = BLACK&#41; and &#40;p&#91;x+1&#93; = BLACK&#41;<br />           and &#40;p&#91;x-w&#93; = BLACK&#41; and &#40;p&#91;x+w&#93; = BLACK&#41;&#41; then<br />            q&#91;x&#93; &#58;= BLACK;<br />        end;<br />      end;<br />  end;<br />  t2 &#58;= GetTickCount;<br />  ShowMessage&#40;IntToStr&#40;t2-t1&#41;&#41;;</code></pre><br /><br />Asm Code:<br /><br /><pre><code>t1 &#58;= GetTickCount;<br />  for i &#58;= 1 to 1 do<br />  asm<br />    &#123; Save the registers ? Delphi pre-requisit &#125;<br />    push edi<br />    push esi<br />    push ebx<br /><br />    mov  esi, src<br />    mov  edi, dst<br /><br />    &#123; First line &#125;<br />    mov  eax, w<br />  @first_line&#58;<br />    cmp  &#91;esi&#93;, BLACK<br />    jne  @first_line_isnt_black<br />    mov  &#91;edi&#93;, RED<br />  @first_line_isnt_black&#58;<br />    add  esi, 4<br />    add  edi, 4<br />    dec  eax<br />    jnz  @first_line<br /><br />    &#123; All image &#125;<br />    mov  eax, h<br />    sub  eax, 2<br />    mov  ecx, bytesPerLine<br />    mov  edx, bytesPerLineNeg<br /><br />  @outterloop&#58;<br />    mov  ebx, w<br />    sub  ebx, 2<br /><br />    &#123; First pixel of each line &#125;<br />    cmp  &#91;esi&#93;, BLACK<br />    jne  @1<br />    mov  &#91;edi&#93;, RED<br />  @1&#58;<br />    add  esi, 4<br />    add  edi, 4<br /><br />  @innerloop&#58;<br />    &#123;*<br />     *  if &#40;p&#91;x&#93; = BLACK&#41; and not &#40;&#40;p&#91;x-1&#93; = BLACK&#41; and &#40;p&#91;x+1&#93; = BLACK&#41;<br />     *    and &#40;p&#91;x-w&#93; = BLACK&#41; and &#40;p&#91;x+w&#93; = BLACK&#41;&#41; then<br />     *      q&#91;x&#93; &#58;= BLACK;<br />     *&#125;<br />    cmp  &#91;esi&#93;, BLACK<br />    jne  @nao_e_limite<br />    cmp  &#91;esi-4&#93;, WHITE<br />    je   @is_edge<br />    cmp  &#91;esi+4&#93;, WHITE<br />    je   @is_edge<br />    cmp  &#91;esi+ecx&#93;,WHITE<br />    je   @is_edge<br />    cmp  &#91;esi+edx&#93;,WHITE<br />    je   @is_edge<br />    jmp  @isnt_edge<br /><br />  @is_edge&#58;<br />    mov  &#91;edi&#93;, RED<br /><br />  @isnt_edge&#58;<br />    add  esi, 4<br />    add  edi, 4<br />    dec  ebx<br />    jnz  @innerloop<br /><br />    &#123; Last pixel of each line &#125;<br />    cmp  &#91;esi&#93;, BLACK<br />    jne  @2<br />    mov  &#91;edi&#93;, RED<br />  @2&#58;<br />    add  esi, 4<br />    add  edi, 4<br /><br />    dec  eax<br />    jnz  @outterloop<br /><br />    &#123; Last line &#125;<br />    mov  eax, w<br />  @last_line&#58;<br />    cmp  &#91;esi&#93;, BLACK<br />    jne  @ last_line_isnt_black<br />    mov  &#91;edi&#93;, RED<br />  @last_line_isnt_black&#58;<br />    add  esi, 4<br />    add  edi, 4<br />    dec  eax<br />    jnz  @last_line<br /><br />    &#123; Restore the registers &#125;<br />    pop  ebx<br />    pop  esi<br />    pop  edi<br />  end;<br />  t2 &#58;= GetTickCount;<br />  ShowMessage&#40;IntToStr&#40;t2-t1&#41;&#41;;</code></pre></div>
    <div class="meta">Posted on 2005-01-02 13:18:52 by brunoavila</div>
   </div>
   <div class="post" id="post-155848">
    <div class="subject"><a href="#post-155848">Another optimization problem</a></div>
    <div class="body">1. You shouldn't profile with GetTickCount, but with a high resolution counter.<br /><br />2. You can optimize to have less cache-misses, as your image is quite big. (just a guess, don't no better, but nobody else appears to reply)</div>
    <div class="meta">Posted on 2005-01-16 06:33:20 by lifewire</div>
   </div>
  </div>
 </body>
</html>