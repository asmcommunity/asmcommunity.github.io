<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>All possible ways to implement Fibonacci algo? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=14206" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=14206">All possible ways to implement Fibonacci algo?</a></p>
   <div class="post" id="post-109862">
    <div class="subject"><a href="#post-109862">All possible ways to implement Fibonacci algo?</a></div>
    <div class="body">Maybe this is a stupid question (I'm a novice) but how many <em>ways</em> are there to solve this?  I hear that there are more efficient methods than the two I use below, can this be solved in just three lines?<br /><br />Also what is the fastest method?<br /><br /><pre><code><br />; =====================<br />; ===== FIBONACCI =====<br />; =====================<br />mov al,1  ; Set initial values<br />mov bl,0<br />mov cl,0<br />here&#58;<br />add cl,al  ; CL contains the result<br />push   bl ; Copy BL into AL<br />pop al<br />push   cl ; Copy CL into BL<br />pop bl<br />jmp here ; Next step in the series<br />end <br /></code></pre><br /><pre><code><br />; =====================<br />;Solution using a RAM location.<br />; =====================<br />; ===== FIBONACCI =====<br />; =====================<br />mov al,1  ; Set initial values<br />mov bl,0<br />mov &#91;40&#93;,bl<br />here&#58;<br />add bl,al ; BL contains the result<br />mov al,&#91;40&#93;<br />mov &#91;40&#93;,bl<br />jmp here  ; Next step in the series<br />end<br />; =====================<br /></code></pre></div>
    <div class="meta">Posted on 2003-07-09 17:34:56 by Alone</div>
   </div>
   <div class="post" id="post-109867">
    <div class="subject"><a href="#post-109867">All possible ways to implement Fibonacci algo?</a></div>
    <div class="body">There is a formula to solve it.</div>
    <div class="meta">Posted on 2003-07-09 18:00:50 by comrade</div>
   </div>
   <div class="post" id="post-109869">
    <div class="subject"><a href="#post-109869">All possible ways to implement Fibonacci algo?</a></div>
    <div class="body">I know there is a formula but that's not what I asked and there <strong>are</strong> many ways to implement it so I have been told (methods involving recursion as well).  Or do you suggest I use the formula without any translation to asm?<br /><br />Btw I am learning asm on my own and I expected more help than that, so basically can someone answer <strong>all</strong> of my questions please without none of the bullshit (no offence to anyone but I would appreciate straight answers no matter how lame you think I am).<br /><br />And before anyone tells me to go &quot;Google it&quot; I have looked and haven't found any good examples. :)</div>
    <div class="meta">Posted on 2003-07-09 18:42:28 by Alone</div>
   </div>
   <div class="post" id="post-109872">
    <div class="subject"><a href="#post-109872">All possible ways to implement Fibonacci algo?</a></div>
    <div class="body"><div class="quote"><br />And before anyone tells me to go &quot;Google it&quot; I have looked and haven't found any good examples. :) </div><a target="_blank" href="http://www.mcs.surrey.ac.uk/Personal/R.Knott/Fibonacci/fibFormula.html">http://www.mcs.surrey.ac.uk/Personal/R.Knott/Fibonacci/fibFormula.html</a><br /><br />First result on Google. :grin:</div>
    <div class="meta">Posted on 2003-07-09 19:00:50 by bitRAKE</div>
   </div>
   <div class="post" id="post-109875">
    <div class="subject"><a href="#post-109875">All possible ways to implement Fibonacci algo?</a></div>
    <div class="body"><div class="quote"><br /><a target="_blank" href="http://www.mcs.surrey.ac.uk/Personal/R.Knott/Fibonacci/fibFormula.html">http://www.mcs.surrey.ac.uk/Personal/R.Knott/Fibonacci/fibFormula.html</a><br /><br />First result on Google. :grin: </div><br /><br />Thanks for the help but again not what I asked, I want <em>practical examples</em> of all/some of the different ways in assembly language <strong>not</strong> a page with a primer on the formula.<br /><br />I want to know if there are infinite ways to implement this formula in asm and what is the most efficient way of doing so.</div>
    <div class="meta">Posted on 2003-07-09 19:12:30 by Alone</div>
   </div>
   <div class="post" id="post-109876">
    <div class="subject"><a href="#post-109876">All possible ways to implement Fibonacci algo?</a></div>
    <div class="body"><pre><code>&#91;size=9&#93;0               - 0000000000000000000000000000000<br />1               - 0000000000000000000000000000001<br /><br />1               - 0000000000000000000000000000001<br />2               - 0000000000000000000000000000010<br />3               - 0000000000000000000000000000011<br />5               - 0000000000000000000000000000101<br />8               - 0000000000000000000000000001000<br />13              - 0000000000000000000000000001101<br />21              - 0000000000000000000000000010101<br />34              - 0000000000000000000000000100010<br />55              - 0000000000000000000000000110111<br />89              - 0000000000000000000000001011001<br />144             - 0000000000000000000000010010000<br />233             - 0000000000000000000000011101001<br />377             - 0000000000000000000000101111001<br />610             - 0000000000000000000001001100010<br />987             - 0000000000000000000001111011011<br />1597            - 0000000000000000000011000111101<br />2584            - 0000000000000000000101000011000<br />4181            - 0000000000000000001000001010101<br />6765            - 0000000000000000001101001101101<br />10946           - 0000000000000000010101011000010<br />17711           - 0000000000000000100010100101111<br />28657           - 0000000000000000110111111110001<br />46368           - 0000000000000001011010100100000<br />75025           - 0000000000000010010010100010001<br />121393          - 0000000000000011101101000110001<br />196418          - 0000000000000101111111101000010<br />317811          - 0000000000001001101100101110011<br />514229          - 0000000000001111101100010110101<br />832040          - 0000000000011001011001000101000<br />1346269         - 0000000000101001000101011011101<br />2178309         - 0000000001000010011110100000101<br />3524578         - 0000000001101011100011111100010<br />5702887         - 0000000010101110000010011100111<br />9227465         - 0000000100011001100110011001001<br />14930352        - 0000000111000111101000110110000<br />24157817        - 0000001011100001001111001111001<br />39088169        - 0000010010101000111000000101001<br />63245986        - 0000011110001010000111010100010<br />102334155       - 0000110000110010111111011001011<br />165580141       - 0001001110111101000110101101101<br />267914296       - 0001111111110000000110000111000<br />433494437       - 0011001110101101001100110100101<br />701408733       - 0101001110011101010010111011101<br />1134903170      - 1000011101001010011111110000010<br />1836311903      - 1101101011100111110010101011111&#91;/size&#93;</code></pre>oh I don't know, probably a pattern on each columns? :grin:<br /><br />try pasting this on an editor that has a column mode which you can highlight a column and use a monospace font...</div>
    <div class="meta">Posted on 2003-07-09 19:18:33 by arkane</div>
   </div>
   <div class="post" id="post-109878">
    <div class="subject"><a href="#post-109878">All possible ways to implement Fibonacci algo?</a></div>
    <div class="body"><strong>Firstly,</strong><br />It seems that no matter what question you ask, for someone to answer, they have to take quite some time to perform the search for you, since noone has all the code for everything stored in their minds: so they have to visit google just as you. But the good thing about assembly programming is that the answers for many questions, and algorithms for the same are on the net in abundance if you know how to look for them.<br /><br />I just searched google for ... fibonacci assembly (No quotes, etc...)<br /><br />I was not going to search the net, actually, since I downloaded Randall Hyde's &quot;Art of Assembly Language&quot; late last year, and he provides several different implementations, as I recall, each successive version is (much) faster than the previous:<br /><br />straight search,<br />recursion<br />iterators<br />thunks<br /><br />He has full source code for each routine (written in HLA - High Level Assembly) see another part of this Win32 site for information on it. But I did have to search my room for my printed copy to remind myself of how he programmed it.<br /><br />Anyway, on my google search, the 8th item was a link to a pdf from his site. If you follow it up you can find four routines. He should have downloads of the code available (you may have to download the HLA compiler to try it out, indeed you may have to download the entire example code zip file). I have not tried to explain each type of routine since I am learning HLA myself right now, but it is fully explained in 3 or four chapters in Randy's very large (&gt;1500 pages) FREE book (which can also be downloaded from his site).<br /><br /><strong>Secondly,</strong><br />It is always recommeded to search the Win32 site first (see the search button at the top right hand) for help on any topic before posting:<br /><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=6752">&quot;I am new here&quot;</a> &quot;If you have a question, please first try to solve it with our search function. It's very fast and may point you to a thread where the same question was already asked.&quot;<br /><br />When you search you will find test code by The Svin for fibonacci posted (to test another algorithm)...<br /><br /><strong>Thirdly,</strong><br />Your algorithm should fail pretty quickly since it only copes with 8-bit numbers in al, bl, etc. 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, <strong>144,  233, <u>377</u></strong><br />144 and 233 are valid unsigned numbers but not signed. They cause a signed overflow. 377 causes an unsigned overflow.<br /><br /><strong>Fourthly,</strong><br />Since this is Win32 programming, you will need to get away from the 8-bit and 16-bit programming paradigm very quickly. We scarcely use 8-bit registers. Only when absolutely necessary. 32-bit numbers have a higher unsigned limit &gt;4 billion, and signed limit from less than -2 billion to more than 2 billion.<br />That can handle many more iterations of the fibonacci sequence...<br /><br /><strong>Fifthly,</strong><br />Patience, patience! To respond to any post means that someone must divert his attention at least 5 minutes from what he was doing before. Some people do not have the time or interest in the algorithm or knowledge of where to get specific answers to help. I have a little time (I have spent &gt;30 minutes here), some knowledge of the algorithm, and knowledge of where to get some answers (Randall Hyde's book), but NO interest in fibonacci!!! I executed Randy's fibonacci program some time ago, while learning about the features in the program. Now I am using HLA for one particular project, and learning only what is essential for my project.<br /><br /><strong>Sixthly,</strong><br />If you want to interest people in a programming problem, it is better to follow the counsel given in the Frequently Asked Questions...<br /><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=6749">&quot;Help me with my Homework&quot;</a> &quot;Do it yourself then post your questions.&quot;<br />If you post a complete program, many people are likely to test it and tell you how to improve it.<br /><br /><strong>Finally,</strong><br />Since this topic is about algorithms, it may better have been posted on the algorithm page - no problem. You can ask the moderator to move it (or they will eventually anyway).</div>
    <div class="meta">Posted on 2003-07-09 19:33:37 by V Coder</div>
   </div>
   <div class="post" id="post-109882">
    <div class="subject"><a href="#post-109882">All possible ways to implement Fibonacci algo?</a></div>
    <div class="body"><div class="quote"><em>Originally posted by arkane </em><br />oh I don't know, probably a pattern on each columns? :grin:</div><br /><br />Arkane, you are a genius!!! (Or maybe not)... :cool: <br /><br />Might this be a way to determine an arbitrary value in the sequence? That's something to look into. However, the pattern of the most significant bit might not be known beforehand...</div>
    <div class="meta">Posted on 2003-07-09 19:42:02 by V Coder</div>
   </div>
   <div class="post" id="post-109885">
    <div class="subject"><a href="#post-109885">All possible ways to implement Fibonacci algo?</a></div>
    <div class="body">I wrote the app sometime ago to check <br />some libs, it just show the sequence.<br />May be you can find a use of it.</div>
    <div class="meta">Posted on 2003-07-09 19:51:09 by The Svin</div>
   </div>
   <div class="post" id="post-109887">
    <div class="subject"><a href="#post-109887">All possible ways to implement Fibonacci algo?</a></div>
    <div class="body">Here are 4 algorithms from Randy's book. The first program is a straight search. The second compares Recursion, Iteration and Thunks...<br /><br /><pre><code>// This program generates the fibonocci<br />// sequence for n=1..40.<br />//<br />// The fibonocci sequence is defined recursively<br />// for positive integers as follows&#58;<br />//<br />//  fib&#40;1&#41; = 1;<br />//  fib&#40;2&#41; = 1;<br />//  fib&#40; n &#41; = fib&#40; n-1 &#41; + fib&#40; n-2 &#41;.<br />//<br />//  This program provides an iterative solution.<br /><br /><br />program fib;<br />#include&#40; &quot;stdlib.hhf&quot; &#41;;<br /><br />static<br /><br />    FibCntr&#58;    int32;<br />    CurFib&#58;     int32;<br />    LastFib&#58;    int32;<br />    TwoFibsAgo&#58; int32;<br /><br />begin fib;<br /><br />    // Some simple initialization&#58;<br /><br />    mov&#40; 1, LastFib &#41;;<br />    mov&#40; 1, TwoFibsAgo &#41;;<br /><br />    // Print fib&#40;1&#41; and fib&#40;2&#41; as a special case&#58;<br /><br />    stdout.put<br />    &#40;<br />        &quot;fib&#40; 1&#41; =         1&quot;, nl<br />        &quot;fib&#40; 2&#41; =         1&quot;, nl<br />    &#41;;<br /><br />    // Use a loop to compute the remaining fib values&#58;<br /><br />    mov&#40; 3, FibCntr &#41;;<br />    while&#40; FibCntr &lt;= 40 &#41; do<br /><br />        // Get the last two computed fibonocci values<br />        // and add them together&#58;<br />        <br />        mov&#40; LastFib, ebx &#41;;<br />        mov&#40; TwoFibsAgo, eax &#41;;<br />        add&#40; ebx, eax &#41;;<br />        <br />        // Save the result and print it&#58;<br />        <br />        mov&#40; eax, CurFib &#41;;<br />        stdout.put&#40; &quot;fib&#40;&quot;,FibCntr&#58;2, &quot;&#41; =&quot;, CurFib&#58;10, nl &#41;;<br />        <br />        // Recycle current LastFib &#40;in ebx&#41; as TwoFibsAgo,<br />        // and recycle CurFib as LastFib.<br /><br />        mov&#40; eax, LastFib &#41;;<br />        mov&#40; ebx, TwoFibsAgo &#41;; <br /><br />        // Bump up our loop counter&#58;<br /><br />        add&#40; 1, FibCntr &#41;;<br /><br />    endwhile;<br /><br />end fib;</code></pre><br /><br /><pre><code>program fibIter;<br />#include&#40; &quot;stdlib.hhf&quot; &#41;<br /><br />// Fibonocci function using a thunk to calculate fib&#40;n-2&#41;<br />// without making a recursive call.<br /><br />procedure fib&#40; n&#58;uns32; nm2&#58;thunk &#41;; @nodisplay; returns&#40; &quot;eax&quot; &#41;;<br />var<br />    n2&#58; uns32;      // A recursive call to fib stores fib&#40;n-2&#41; here.<br />    t&#58;  thunk;      // This thunk actually stores fib&#40;n-2&#41; in n2.<br /><br />begin fib;<br /><br />    // Special case for n = 1, 2.  Just return 1 as the<br />    // function result and store 1 into the fib&#40;n-2&#41; result.<br /><br />    if&#40; n &lt;= 2 &#41; then<br /><br />        mov&#40; 1, eax &#41;;  // Return as n-1 value.<br />        nm2&#40;&#41;;          // Store into caller as n-2 value.<br /><br />    else<br /><br />        // Create a thunk that will store the fib&#40;n-2&#41; value<br />        // into our local n2 variable.<br /><br />        thunk   t &#58;=<br />                #&#123;<br />                    mov&#40; eax, n2 &#41;;<br />                &#125;#;<br /><br />        mov&#40; n, eax &#41;;<br />        dec&#40; eax &#41;;<br />        fib&#40; eax, t &#41;;  // Compute fib&#40;n-1&#41;.<br /><br />        // Pass back fib&#40;n-1&#41; as the fib&#40;n-2&#41; value to a previous caller.<br />         <br />        nm2&#40;&#41;;<br /><br /><br />        // Compute fib&#40;n&#41; = fib&#40;n-1&#41; &#91;in eax&#93; + fib&#40;n-2&#41; &#91;in n2&#93;&#58;<br /><br />        add&#40; n2, eax &#41;;<br /><br />    endif;<br /><br />end fib;<br /><br /><br />// Standard fibonocci function using the slow recursive implementation.<br /><br />procedure slowfib&#40; n&#58;uns32 &#41;; @nodisplay; returns&#40; &quot;eax&quot; &#41;;<br />begin slowfib;<br /><br />    // For n= 1,2 just return 1.<br /><br />    if&#40; n &lt;= 2 &#41; then<br /><br />        mov&#40; 1, eax &#41;;<br /><br />    else<br /><br />        // Return slowfib&#40;n-1&#41; + slowfib&#40;n-2&#41; as the function result&#58;<br /><br />        dec&#40; n &#41;;<br />        slowfib&#40; n &#41;;   // compute fib&#40;n-1&#41;<br />        push&#40; eax &#41;;    // Save fib&#40;n-1&#41;;<br /><br />        dec&#40; n &#41;;       // compute fib&#40;n-2&#41;;<br />        slowfib&#40; n &#41;;<br /><br />        add&#40; &#91;esp&#93;, eax &#41;;  // Compute fib&#40;n-1&#41; &#91;on stack&#93; + fib&#40;n-2&#41; &#91;in eax&#93;.<br />        add&#40; 4, esp &#41;;      // Remove old value from stack.<br /><br />    endif;<br /><br />end slowfib;<br /><br /><br />// FibNum-<br />//<br />//  Iterator that generates all the fibonacci numbers between 1 and n.<br /><br />iterator FibNum&#40; n&#58;uns32 &#41;; @nodisplay;<br />var<br />    Fibn_1&#58; uns32;      // Holds Fib&#40;n-1&#41; for a given n.<br />    Fibn_2&#58; uns32;      // Holds Fib&#40;n-2&#41; for a given n.<br />    CurFib&#58; uns32;      // Current index into fib sequence.<br />    <br />begin FibNum;<br /><br />    mov&#40; 1, Fibn_1 &#41;;   // Initialize these guys upon initial entry.<br />    mov&#40; 1, Fibn_2 &#41;;<br />    mov&#40; 1, eax &#41;;      // Fib&#40;0&#41; = 1<br />    yield&#40;&#41;;<br />    mov&#40; 1, eax &#41;;      // Fib&#40;1&#41; = 1;<br />    yield&#40;&#41;;<br />    mov&#40; 2, CurFib &#41;;<br />    forever<br />    <br />        mov&#40; CurFib, eax &#41;;     // Compute sequence up to the nth #.<br />        breakif&#40; eax &gt; n &#41;;<br />        mov&#40; Fibn_2, eax &#41;;     // Compute this result.<br />        add&#40; Fibn_1, eax &#41;;<br /><br />        // Recompute the Fibn_1 and Fibn_2 values&#58;<br />        <br />        mov&#40; Fibn_1, Fibn_2 &#41;;<br />        mov&#40; eax, Fibn_1 &#41;;<br />        <br />        // Return current value&#58;<br />        <br />        yield&#40;&#41;;<br />        <br />        // Next value in sequence&#58;<br />        <br />        inc&#40; CurFib &#41;;<br />        <br />    endfor;<br />    <br />end FibNum;<br />    <br /><br /><br />var<br />    prevTime&#58;dword&#91;2&#93;;      // Used to hold 64-bit result from RDTSC instr.<br />    qw&#58; qword;              // Used to compute difference in timing.<br />    dummy&#58;thunk;            // Used in original calls to fib.<br /><br />begin fibIter;<br /><br />    // &quot;Do nothing&quot; thunk used by the initial call to fib.<br />    // This thunk simply returns to its caller without doing<br />    // anything.<br /><br />    thunk dummy &#58;= #&#123; &#125;#;<br /><br /><br />    // Call the fibonocci routines to &quot;prime&quot; the cache&#58;<br /><br />    fib&#40; 1, dummy &#41;;<br />    slowfib&#40; 1 &#41;;<br />    foreach FibNum&#40; 1 &#41; do<br />    endfor;<br /><br /><br /><br />    // Okay, compute the running times for the three fibonocci routines to<br />    // generate a sequence of n fibonacci numbers where n ranges from<br />    // 1 to 32&#58;<br /><br />    for&#40; mov&#40; 1, ebx &#41;; ebx &lt; 32; inc&#40; ebx &#41;&#41; do<br /><br />        // Emit the index&#58;<br />        <br />        stdout.put&#40; &#40;type uns32 ebx&#41;&#58;2, stdio.tab &#41;;<br />        <br />        // Compute the # of cycles needed to compute the Fib via iterator&#58;<br /><br />        rdtsc&#40;&#41;;<br />        mov&#40; eax, prevTime &#41;;<br />        mov&#40; edx, prevTime&#91;4&#93; &#41;;<br /><br />        foreach FibNum&#40; ebx &#41; do<br />        <br />        endfor;<br />        <br />        rdtsc&#40;&#41;;<br />        sub&#40; prevTime, eax &#41;;<br />        sbb&#40; prevTime&#91;4&#93;, edx &#41;;<br />        mov&#40; eax, &#40;type dword qw&#41;&#41;;<br />        mov&#40; edx, &#40;type dword qw&#91;4&#93;&#41;&#41;;<br /><br />        stdout.putu64Size&#40; qw, 4, ' ' &#41;;<br />        stdout.putc&#40; stdio.tab &#41;;<br /><br /><br /><br /><br />        // Read the time stamp counter before calling fib&#58;<br />        <br />        rdtsc&#40;&#41;;<br />        mov&#40; eax, prevTime &#41;;<br />        mov&#40; edx, prevTime&#91;4&#93; &#41;;<br /><br />        for&#40; mov&#40; 1, ecx &#41;; ecx &lt;= ebx; inc&#40; ecx &#41;&#41; do<br />        <br />            fib&#40; ecx, dummy &#41;;<br /><br />        endfor;<br /><br />        // Read the timestamp counter and compute the approximate running<br />        // time of the current call to fib&#58;<br /><br />        rdtsc&#40;&#41;;<br />        sub&#40; prevTime, eax &#41;;<br />        sbb&#40; prevTime&#91;4&#93;, edx &#41;;<br />        mov&#40; eax, &#40;type dword qw&#41;&#41;;<br />        mov&#40; edx, &#40;type dword qw&#91;4&#93;&#41;&#41;;<br /><br />        // Display the results and timing from the call to fib&#58;<br /><br />        stdout.putu64Size&#40; qw, 10, ' ' &#41;;<br />        stdout.putc&#40; stdio.tab &#41;;<br /><br /><br />        // Okay, repeat the above for the slowfib implementation&#58;<br /><br />        rdtsc&#40;&#41;;<br />        mov&#40; eax, prevTime &#41;;<br />        mov&#40; edx, prevTime&#91;4&#93; &#41;;<br /><br />        for&#40; mov&#40; 1, ecx &#41;; ecx &lt;= ebx; inc&#40; ecx &#41;&#41; do<br />        <br />            slowfib&#40; ebx &#41;;<br /><br />        endfor;<br />        <br />        rdtsc&#40;&#41;;<br />        sub&#40; prevTime, eax &#41;;<br />        sbb&#40; prevTime&#91;4&#93;, edx &#41;;<br />        mov&#40; eax, &#40;type dword qw&#41;&#41;;<br />        mov&#40; edx, &#40;type dword qw&#91;4&#93;&#41;&#41;;<br /><br />        stdout.putu64Size&#40; qw, 10, ' ' &#41;;<br />        stdout.newln&#40;&#41;;<br />        <br />        <br /><br />    endfor;<br /><br />end fibIter;<br /></code></pre></div>
    <div class="meta">Posted on 2003-07-09 20:01:37 by V Coder</div>
   </div>
   <div class="post" id="post-109889">
    <div class="subject"><a href="#post-109889">All possible ways to implement Fibonacci algo?</a></div>
    <div class="body">Here are the run-time cycles  for the Iterator function, the Thunk function, and Recursion, respectively, for each fib nunmber. The second program above was compiled and run (console mode) on my Pentium III 1066...(with my browser open and internet connected so some RDTSC times (eg. 20, 22, 24, 28, 30 for Iterator) are obviously wrong - however much processor time going to different threads. The value for 31 is also too far from 30 to be correct. No problem: 1000 cycles is still less than a microsecond!!! In comparison to 2 seconds for the last recursion!!!<br /><br /><pre><code> 1       136           131              92<br /> 2       166           160             106<br /> 3       192           272             287<br /> 4       207           402             494<br /> 5       236           577             984<br /> 6       245           797            1734<br /> 7       262          1009            3836<br /> 8       281          1236            6883<br /> 9       301          1523           12239<br />10       323          1848           22359<br />11       340          2188           39788<br />12       359          2569          255628<br />13       380          3318          122914<br />14       400          3421          215023<br />15       423          3891          372133<br />16       439          4397          982422<br />17       457          4961         1104284<br />18       475          5539         2252104<br />19       504          6158         4020264<br />20       703          7087         6590072<br />21       540          7731        47901252<br />22       793          8759        17851868<br />23       571          9584        32153729<br />24       741         10219        51990931<br />25       621         11337        83777375<br />26       627         12141       144056904<br />27       658         13226       242948164<br />28      1180         14662       454582274<br />29       689         15358       678341147<br />30       709         16427      1141638934<br />31       986         17789      1868647883</code></pre><br /><br />Another run had these figures...<br /><br /><pre><code>29       695         15517       671562486<br />30       715         16598      1136735726<br />31       729         18195      1887330540</code></pre><br /><br />So the actual time is at most 689, 709, 729 respectively.</div>
    <div class="meta">Posted on 2003-07-09 20:14:27 by V Coder</div>
   </div>
   <div class="post" id="post-109902">
    <div class="subject"><a href="#post-109902">All possible ways to implement Fibonacci algo?</a></div>
    <div class="body">Thanks everyone for your help and I appreciate all the time and effort you guys spent!<br /><br />Yeah about the 8bit examples I posted, I want to get a grasp on the basic concepts first before I progress to using more registers.  (bad idea?)<br /><br />Ok fair enough I will try and help myself before asking but obviously if I could then I wouldn't be asking, I am not usually one to ask for help and I didn't know anywhere else to go (I searched the entire board and the web beforehand) but just so you know it is <strong>not</strong> homework, as I mentioned previously I'm learning on my own.<br /><br />About HLA, I know what it is and I have heard of the book AoA but I did not know those examples were in there since I'm not learning HLA.<br /><br />Most of you guys have way more experience than me so I kinda expected some help even if you think I should be able to <em>figure it out</em> on my own, should I feel guilty that I asked for help? Have you guys forgotten where you started or am I just that stupid? <br /><br />But anyways I'm really grateful for all the help and I hope this post will be useful to people like me or not. :)</div>
    <div class="meta">Posted on 2003-07-09 21:49:08 by Alone</div>
   </div>
   <div class="post" id="post-109906">
    <div class="subject"><a href="#post-109906">All possible ways to implement Fibonacci algo?</a></div>
    <div class="body"><div class="quote"><br /><br /><br />Arkane, you are a genius!!! (Or maybe not)... :cool: <br /><br />Might this be a way to determine an arbitrary value in the sequence? That's something to look into. However, the pattern of the most significant bit might not be known beforehand... </div>first, please don't call me a genius, 'cause I hate it :grin: :grin: :grin: just call it a good idea... :grin:<br /><br />second, well probably you are right but I haven't really studied the pattern very well just a glance from the few columns starting on the right... which I can see a pattern on columns 0, 1 and 2.<br /><br />what I had in mind was if someone will find an algorithm to this pattern or any other pattern in binary, we can generate easily the number sequence without using complex addition.<br /><br />example: we can generate numbers with 1 to X digits on a table easily without addition, of course memory management comes into mind here...<br /><br />theoritically, it should be *faster* but I can't guarantee in real world tests.<br /><br /><br />just a thought. :grin: I could be wrong... :grin:</div>
    <div class="meta">Posted on 2003-07-09 22:21:58 by arkane</div>
   </div>
   <div class="post" id="post-109907">
    <div class="subject"><a href="#post-109907">All possible ways to implement Fibonacci algo?</a></div>
    <div class="body"><div class="quote"><em>Originally posted by Alone </em><br />Yeah about the 8bit examples I posted, I want to get a grasp on the basic concepts first before I progress to using more registers.  (bad idea?)</div><br />Yes, jump in at 32 bit Windows code, unless you intend to program for DOS. Anyway, try using the best tools for the job, in this case 32 bit...<br />What Assembler are you using?<br /><div class="quote"><em>Originally posted by Alone </em>Ok fair enough I will try and help myself before asking but obviously if I could then I wouldn't be asking, I am not usually one to ask for help and I didn't know anywhere else to go (I searched the entire board and the web beforehand) but just so you know it is <strong>not</strong> homework, as I mentioned previously I'm learning on my own.</div><br />I did not think it was homework, but the principle still applies.<br /><div class="quote"><em>Originally posted by Alone </em>About HLA, I know what it is and I have heard of the book AoA but I did not know those examples were in there since I'm not learning HLA.</div><br />Your loss, since it is a really good way to learn many aspects of Assembly programming.<br /><div class="quote"><em>Originally posted by Alone </em>Most of you guys have way more experience than me so I kinda expected some help even if you think I should be able to <em>figure it out</em> on my own, should I feel guilty that I asked for help? Have you guys forgotten where you started or am I just that stupid?</div><br />I'm not sure anyone thinks you're stupid. But I was irritated at your second post. There was no need to get so hot-headed, especially since you got an answer pretty quickly...It really takes time for people to search for answers to help you, even if they are experienced. (I'm just a beginner myself). Sometimes the people with the answers may not log on during the day, or at the time you expect answers.<br /><div class="quote"><em>Originally posted by Alone </em>But anyways I'm really grateful for all the help and I hope this post will be useful to people like me or not. :) </div><br />The whole point of this (community) forum is to benefit all the forum users. You can probably try to convert the first program above to MASM32 and post it here for others to benefit. Not so sure about the second one. It involves advanced HLA and Assembly concepts. In fact, I'm not sure if the iterator feature or thunks are available in other Assemblers (someone else would probably know).</div>
    <div class="meta">Posted on 2003-07-09 22:54:11 by V Coder</div>
   </div>
   <div class="post" id="post-110054">
    <div class="subject"><a href="#post-110054">All possible ways to implement Fibonacci algo?</a></div>
    <div class="body">There are infinite ways to do this in ASM.  This is my favorite sequence in all the world.  Here is another method (also used in <strong>Svin</strong>'s example):<pre><code>fib PROC n&#58;DWORD<br />	; n only valid on &#91;1,47&#93;<br />	mov	edx, 1<br />	mov	eax, 0<br />	mov	ecx, n<br />@@&#58;	xadd	eax, edx<br />	dec	ecx<br />	jne	@B<br />	ret<br />fib ENDP</code></pre>Many coders forget XADD. :)<br /><br />*Use ADC and another XADD for 64-bit.<pre><code><br />fib64 PROC USES esi edi, n&#58;DWORD<br />	; n only valid on &#91;1,93&#93;<br />	mov	eax, 0<br />	mov	edi, 1<br />	mov	edx, 0<br />	mov	esi, 0<br />	mov	ecx, n<br />@@&#58;	xadd	eax, edi<br />	adc	esi, 0<br />	xadd	edx, esi<br />	dec	ecx<br />	jne	@B<br />	ret<br />fib64 ENDP</code></pre><br /><br />(How fast is this <strong>V Coder</strong>?  Should be faster than an uncached table lookup on most newer machines. :))</div>
    <div class="meta">Posted on 2003-07-11 00:12:27 by bitRAKE</div>
   </div>
  </div>
 </body>
</html>