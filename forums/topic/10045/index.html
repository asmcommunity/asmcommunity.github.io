<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Macro creation assistance for WDM tut - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=10045" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=10045">Macro creation assistance for WDM tut</a></p>
   <div class="post" id="post-75142">
    <div class="subject"><a href="#post-75142">Macro creation assistance for WDM tut</a></div>
    <div class="body">All:<br /><br />I must admit that I am just plain terrible at the creation of macros (I hardly ever use them) so I was wondering if some of you who are rather skilled at it could save me some time by reviewing the vary basic macros that I have created for use in my WDM tut and then suggest the proper way to make them.<br /><br />Thanks in advance as this greatly assist in the efforts.<br /><br /><pre><code><br /><br />;++<br />;<br />; PIO_STACK_LOCATION<br />; IoGetCurrentIrpStackLocation&#40;<br />;     IN PIRP Irp<br />;     &#41;<br />;<br />; Routine Description&#58;<br />;<br />;     This routine is invoked to return a pointer to the current stack location<br />;     in an I/O Request Packet &#40;IRP&#41;.<br />;<br />; Arguments&#58;<br />;<br />;     Irp - Pointer to the I/O Request Packet.<br />;<br />; Return Value&#58;<br />;<br />;     The function value is a pointer to the current stack location in the<br />;     packet.<br />;<br />;--<br />;#define IoMarkIrpPending&#40; Irp &#41; &#40; \<br />;    IoGetCurrentIrpStackLocation&#40; &#40;Irp&#41; &#41;-&gt;Control |= SL_PENDING_RETURNED &#41;<br />;<br />IoGetCurrentIrpStackLocation MACRO pIrp&#58;REQ<br />    mov edi, pIrp<br />    mov esi, &#40;_IRP PTR &#91;edi&#93;&#41;.CurrentStackLocation<br />ENDM<br /><br />;++<br />;<br />; VOID<br />; IoSkipCurrentIrpStackLocation &#40;<br />;     IN PIRP Irp<br />;     &#41;<br />;<br />; Routine Description&#58;<br />;<br />;     This routine is invoked to increment the current stack location of<br />;     a given IRP.<br />;<br />;     If the caller wishes to call the next driver in a stack, and does not<br />;     wish to change the arguments, nor does he wish to set a completion<br />;     routine, then the caller first calls IoSkipCurrentIrpStackLocation<br />;     and the calls IoCallDriver.<br />;<br />; Arguments&#58;<br />;<br />;     Irp - Pointer to the I/O Request Packet.<br />;<br />; Return Value&#58;<br />;<br />;     None<br />;<br />;--<br />;#define IoSkipCurrentIrpStackLocation&#40; Irp &#41; \<br />;    &#40;Irp&#41;-&gt;CurrentLocation++; \<br />;    &#40;Irp&#41;-&gt;Tail.Overlay.CurrentStackLocation++;<br />;<br />IoSkipCurrentIrpStackLocation MACRO pIrp&#58;REQ<br />    mov eax, pIrp<br />    inc &#40;_IRP PTR &#91;eax&#93;&#41;.CurrentLocation<br />    inc &#40;_IRP PTR &#91;eax&#93;&#41;.CurrentStackLocation<br />ENDM<br /><br />;++<br />;<br />; PIO_STACK_LOCATION<br />; IoGetNextIrpStackLocation&#40;<br />;     IN PIRP Irp<br />;     &#41;<br />;<br />; Routine Description&#58;<br />;<br />;     This routine is invoked to return a pointer to the next stack location<br />;     in an I/O Request Packet &#40;IRP&#41;.<br />;<br />; Arguments&#58;<br />;<br />;     Irp - Pointer to the I/O Request Packet.<br />;<br />; Return Value&#58;<br />;<br />;     The function value is a pointer to the next stack location in the packet.<br />;<br />;--<br />;#define IoGetNextIrpStackLocation&#40; Irp &#41; &#40;\<br />;   &#40;Irp&#41;-&gt;Tail.Overlay.CurrentStackLocation - 1 &#41;<br />;<br />IoGetNextIrpStackLocation MACRO pIrp&#58;REQ<br />    mov edi, pIrp<br />    mov esi, &#40;_IRP PTR &#91;edi&#93;&#41;.CurrentStackLocation - 1<br />ENDM<br /><br />;++<br />;<br />; VOID<br />; IoCopyCurrentIrpStackLocationToNext&#40;<br />;     IN PIRP Irp<br />;     &#41;<br />;<br />; Routine Description&#58;<br />;<br />;     This routine is invoked to copy the IRP stack arguments and file<br />;     pointer from the current IrpStackLocation to the next<br />;     in an I/O Request Packet &#40;IRP&#41;.<br />;<br />;     If the caller wants to call IoCallDriver with a completion routine<br />;     but does not wish to change the arguments otherwise,<br />;     the caller first calls IoCopyCurrentIrpStackLocationToNext,<br />;     then IoSetCompletionRoutine, then IoCallDriver.<br />;<br />; Arguments&#58;<br />;<br />;     Irp - Pointer to the I/O Request Packet.<br />;<br />; Return Value&#58;<br />;<br />;     None.<br />;<br />;--<br />;<br />;#define IoCopyCurrentIrpStackLocationToNext&#40; Irp &#41; &#123; \<br />;    PIO_STACK_LOCATION irpSp; \<br />;    PIO_STACK_LOCATION nextIrpSp; \<br />;    irpSp = IoGetCurrentIrpStackLocation&#40; &#40;Irp&#41; &#41;; \<br />;    nextIrpSp = IoGetNextIrpStackLocation&#40; &#40;Irp&#41; &#41;; \<br />;    RtlCopyMemory&#40; nextIrpSp, irpSp, FIELD_OFFSET&#40;IO_STACK_LOCATION, CompletionRoutine&#41;&#41;; \<br />;    nextIrpSp-&gt;Control = 0; &#125;<br />;<br />IoCopyCurrentIrpStackLocationToNext MACRO pIrp&#58;REQ<br />    LOCAL irpSp<br />    LOCAL nextIrpSp<br /><br />    irpSp     DWORD ?<br />    nextIrpSp DWORD ?<br /><br />    IoGetCurrentIrpStackLocation pIrp<br />    mov irpSp, esi<br /><br />    IoGetNextIrpStackLocation pIrp<br />    mov nextIrpSp, esi<br /><br /><br />    ;<br />    ; Get the needed Field offset and place it into eax<br />    ;<br />    FIELD_OFFSET IO_STACK_LOCATION, \<br />                 CompletionRoutine<br /><br />    invoke RtlCopyMemory, nextIrpSp, \<br />                          irpSp, \<br />                          eax<br /><br />    mov &#40;IO_STACK_LOCATION PTR &#91;nextIrpSp&#93;&#41;.Control, 0<br />ENDM<br /><br />;++<br />;<br />; VOID<br />; IoSetCompletionRoutine&#40;<br />;     IN PIRP Irp,<br />;     IN PIO_COMPLETION_ROUTINE CompletionRoutine,<br />;     IN PVOID Context,<br />;     IN BOOLEAN InvokeOnSuccess,<br />;     IN BOOLEAN InvokeOnError,<br />;     IN BOOLEAN InvokeOnCancel<br />;     &#41;<br />;<br />; Routine Description&#58;<br />;<br />;     This routine is invoked to set the address of a completion routine which<br />;     is to be invoked when an I/O packet has been completed by a lower-level<br />;     driver.<br />;<br />; Arguments&#58;<br />;<br />;     Irp - Pointer to the I/O Request Packet itself.<br />;<br />;     CompletionRoutine - Address of the completion routine that is to be<br />;         invoked once the next level driver completes the packet.<br />;<br />;     Context - Specifies a context parameter to be passed to the completion<br />;         routine.<br />;<br />;     InvokeOnSuccess - Specifies that the completion routine is invoked when the<br />;         operation is successfully completed.<br />;<br />;     InvokeOnError - Specifies that the completion routine is invoked when the<br />;         operation completes with an error status.<br />;<br />;     InvokeOnCancel - Specifies that the completion routine is invoked when the<br />;         operation is being canceled.<br />;<br />; Return Value&#58;<br />;<br />;     None.<br />;<br />;--<br />;<br />;#define IoSetCompletionRoutine&#40; Irp, Routine, CompletionContext, Success, Error, Cancel &#41; &#123; \<br />;    PIO_STACK_LOCATION irpSp;                                               \<br />;    ASSERT&#40; &#40;Success&#41; | &#40;Error&#41; | &#40;Cancel&#41; ? &#40;Routine&#41; != NULL &#58; TRUE &#41;;    \<br />;    irpSp = IoGetNextIrpStackLocation&#40; &#40;Irp&#41; &#41;;                             \<br />;    irpSp-&gt;CompletionRoutine = &#40;Routine&#41;;                                   \<br />;    irpSp-&gt;Context = &#40;CompletionContext&#41;;                                   \<br />;    irpSp-&gt;Control = 0;                                                     \<br />;    if &#40;&#40;Success&#41;&#41; &#123; irpSp-&gt;Control = SL_INVOKE_ON_SUCCESS; &#125;               \<br />;    if &#40;&#40;Error&#41;&#41; &#123; irpSp-&gt;Control |= SL_INVOKE_ON_ERROR; &#125;                  \<br />;    if &#40;&#40;Cancel&#41;&#41; &#123; irpSp-&gt;Control |= SL_INVOKE_ON_CANCEL; &#125; &#125;<br /><br />IoSetCompletionRoutine MACRO pIrp&#58;REQ, Routine&#58;REQ,  \<br />                             CompletionContext&#58;REQ,  \<br />                             Success&#58;REQ, Error&#58;REQ, \<br />                             Cancel&#58;REQ<br /><br />    LOCAL irpSp<br /><br />    irpSp   DWORD ?<br /><br />    IoGetNextIrpStackLocation pIrp<br /><br />    mov irpSp, esi<br />    mov &#40;IO_STACK_LOCATION PTR &#91;irpSp&#93;&#41;.CompletionRoutine, Routine<br /><br />    mov eax, DWORD PTR CompletionContext<br /><br />    mov &#40;IO_STACK_LOCATION PTR &#91;irpSp&#93;&#41;.Context, eax<br />    mov &#40;IO_STACK_LOCATION PTR &#91;irpSp&#93;&#41;.Control, 0<br /><br />    .IF Success<br />        mov &#40;IO_STACK_LOCATION PTR &#91;irpSp&#93;&#41;.Control, SL_INVOKE_ON_SUCCESS<br />    .ENDIF<br /><br />    .IF Error<br />        or &#40;IO_STACK_LOCATION PTR &#91;irpSp&#93;&#41;.Control, SL_INVOKE_ON_ERROR<br />    .ENDIF<br /><br />    .IF Cancel<br />        or &#40;IO_STACK_LOCATION PTR &#91;irpSp&#93;&#41;.Control, SL_INVOKE_ON_CANCEL<br />    .ENDIF<br /><br />ENDM<br /><br />;<br />; Calculate the byte offset of a field in a structure of type type.<br />;<br />;#define FIELD_OFFSET&#40;type, field&#41;    &#40;&#40;LONG&#41;&#40;LONG_PTR&#41;&amp;&#40;&#40;&#40;type *&#41;0&#41;-&gt;field&#41;&#41;<br />FIELD_OFFSET MACRO type&#58;REQ, field&#58;REQ<br />    mov eax, type<br />    mov eax, &#40;type PTR &#91;edx&#93;&#41;.field<br />ENDM<br /><br /></code></pre></div>
    <div class="meta">Posted on 2003-01-08 17:21:20 by madprgmr</div>
   </div>
   <div class="post" id="post-75172">
    <div class="subject"><a href="#post-75172">Macro creation assistance for WDM tut</a></div>
    <div class="body"><pre><code>;<br />; Calculate the byte offset of a field in a structure of type type.<br />;<br />;#define FIELD_OFFSET&#40;type, field&#41;    &#40;&#40;LONG&#41;&#40;LONG_PTR&#41;&amp;&#40;&#40;&#40;type *&#41;0&#41;-&gt;field&#41;&#41;<br />FIELD_OFFSET MACRO _type&#58;REQ, field&#58;REQ<br />	EXITM %&#40;_type&amp;.&amp;field&#41;<br />ENDM<br /><br />; Example&#58;<br />mov eax, FIELD_OFFSET&#40;D3DXCOLOR, r&#41;</code></pre>TYPE is a reserved word.  This macro reduces to a constant. :)<br />I'll take a further look at the rest as I have time...</div>
    <div class="meta">Posted on 2003-01-08 21:24:55 by bitRAKE</div>
   </div>
   <div class="post" id="post-75181">
    <div class="subject"><a href="#post-75181">Macro creation assistance for WDM tut</a></div>
    <div class="body">I noticed this and other stuff with the macros, so i abondonded your code (in some cases) and simply translated it for you from the #defines in the comments.<br /><br />I have one major concern.  The C++ macro:<br /><strong>;#define IoGetNextIrpStackLocation( Irp ) ( (Irp)-&gt;Tail.Overlay.CurrentStackLocation - 1 )<br /></strong><br /><br />Looks odd.  Get the current address pointer, then subtract one from the address? One BYTE? If the stack is aligned on DWORDS then the alignment will be thrown off!  However, im translating it literally!  It may be 1 (DWORD) in which case you need to change it to 'sub eax, 4' instead...<br /><br />The problem is, i dont know what these macro's do, or what the structures look like that they operater on.<br /><br /><br />Another think is i dont know why you need three parameters for status in the <strong>IoSetCompletionRoutine</strong>.  But since C++ is doing this im assuming its an interfacing issue from other macros per se.<br /><br />Lastly i use <strong>EBX</strong> soley for structure accessing. This is to keep a consistancy up so you can rely on edi, and esi if need be.  This is also why i push/pop esi, edi in the copy routine.  From a users point of view, they should only have to memorize &quot;dont use EBX cause it will be corrupted, and be ready for returns in EAX&quot;...<br /><br /><pre><code>;++<br />;<br />; PIO_STACK_LOCATION<br />; IoGetCurrentIrpStackLocation&#40;<br />;     IN PIRP Irp<br />;     &#41;<br />;<br />; Routine Description&#58;<br />;<br />;     This routine is invoked to return a pointer to the current stack location<br />;     in an I/O Request Packet &#40;IRP&#41;.<br />;<br />; Arguments&#58;<br />;<br />;     Irp - Pointer to the I/O Request Packet.<br />;<br />; Return Value&#58;<br />;<br />;     The function value is a pointer to the current stack location in the<br />;     packet.<br />;<br />;--<br />;#define IoMarkIrpPending&#40; Irp &#41; &#40; IoGetCurrentIrpStackLocation&#40; &#40;Irp&#41; &#41;-&gt;Control |= SL_PENDING_RETURNED &#41;<br />;<br />IoMarkIrpPending  MACRO pIrp&#58;REQ<br />   mov ebx, pIrp<br />   mov eax, &#40;_IRP PTR &#91;ebx&#93;&#41;.CurrentStackLocation<br />   or  &#40;IO_STACK_LOCATION PTR &#91;eax&#93;&#41;.Control, SL_PENDING_RETURNED<br />ENDM   <br />   <br />IoGetCurrentIrpStackLocation MACRO pIrp&#58;REQ<br />    mov ebx, pIrp<br />    mov eax, &#40;_IRP PTR &#91;ebx&#93;&#41;.CurrentStackLocation<br />    EXITM &lt;eax&gt;<br />ENDM<br /><br />;++<br />;<br />; VOID<br />; IoSkipCurrentIrpStackLocation &#40;<br />;     IN PIRP Irp<br />;     &#41;<br />;<br />; Routine Description&#58;<br />;<br />;     This routine is invoked to increment the current stack location of<br />;     a given IRP.<br />;<br />;     If the caller wishes to call the next driver in a stack, and does not<br />;     wish to change the arguments, nor does he wish to set a completion<br />;     routine, then the caller first calls IoSkipCurrentIrpStackLocation<br />;     and the calls IoCallDriver.<br />;<br />; Arguments&#58;<br />;<br />;     Irp - Pointer to the I/O Request Packet.<br />;<br />; Return Value&#58;<br />;<br />;     None<br />;<br />;--<br />;#define IoSkipCurrentIrpStackLocation&#40; Irp &#41; \<br />;    &#40;Irp&#41;-&gt;CurrentLocation++; \<br />;    &#40;Irp&#41;-&gt;Tail.Overlay.CurrentStackLocation++;<br />;<br />IoSkipCurrentIrpStackLocation MACRO pIrp&#58;REQ<br />    mov ebx, pIrp<br />    inc &#40;_IRP PTR &#91;ebx&#93;&#41;.CurrentLocation          <br />    inc &#40;_IRP PTR &#91;ebx&#93;&#41;.Tail.Overlay.CurrentStackLocation  <br />ENDM<br /><br />;++<br />;<br />; PIO_STACK_LOCATION<br />; IoGetNextIrpStackLocation&#40;<br />;     IN PIRP Irp<br />;     &#41;<br />;<br />; Routine Description&#58;<br />;<br />;     This routine is invoked to return a pointer to the next stack location<br />;     in an I/O Request Packet &#40;IRP&#41;.<br />;<br />; Arguments&#58;<br />;<br />;     Irp - Pointer to the I/O Request Packet.<br />;<br />; Return Value&#58;<br />;<br />;     The function value is a pointer to the next stack location in the packet.<br />;<br />;--<br />;#define IoGetNextIrpStackLocation&#40; Irp &#41; &#40; &#40;Irp&#41;-&gt;Tail.Overlay.CurrentStackLocation - 1 &#41;<br />;<br />IoGetNextIrpStackLocation MACRO pIrp&#58;REQ<br />   mov ebx, pIrp<br />   mov eax, &#40;_IRP PTR &#91;ebx&#93;&#41;.Tail.Overlay.CurrentStackLocation<br />   dec eax<br />   EXITM &lt;eax&gt;<br />ENDM<br /><br /><br />;++<br />;<br />; VOID<br />; IoCopyCurrentIrpStackLocationToNext&#40;<br />;     IN PIRP Irp<br />;     &#41;<br />;<br />; Routine Description&#58;<br />;<br />;     This routine is invoked to copy the IRP stack arguments and file<br />;     pointer from the current IrpStackLocation to the next<br />;     in an I/O Request Packet &#40;IRP&#41;.<br />;<br />;     If the caller wants to call IoCallDriver with a completion routine<br />;     but does not wish to change the arguments otherwise,<br />;     the caller first calls IoCopyCurrentIrpStackLocationToNext,<br />;     then IoSetCompletionRoutine, then IoCallDriver.<br />;<br />; Arguments&#58;<br />;<br />;     Irp - Pointer to the I/O Request Packet.<br />;<br />; Return Value&#58;<br />;<br />;     None.<br />;<br />;--<br />;<br />;#define IoCopyCurrentIrpStackLocationToNext&#40; Irp &#41; &#123; \<br />;    PIO_STACK_LOCATION irpSp; \<br />;    PIO_STACK_LOCATION nextIrpSp; \<br />;    irpSp = IoGetCurrentIrpStackLocation&#40; &#40;Irp&#41; &#41;; \<br />;    nextIrpSp = IoGetNextIrpStackLocation&#40; &#40;Irp&#41; &#41;; \<br />;    RtlCopyMemory&#40; nextIrpSp, irpSp, FIELD_OFFSET&#40;IO_STACK_LOCATION, CompletionRoutine&#41;&#41;; \<br />;    nextIrpSp-&gt;Control = 0; &#125;<br />;<br />IoCopyCurrentIrpStackLocationToNext MACRO pIrp&#58;REQ<br />    push esi<br />    push edi<br />    mov ebx, pIrp<br />    ;;  irpSp = IoGetCurrentIrpStackLocation&#40; &#40;Irp&#41; &#41;;<br />    mov esi, &#40;_IRP PTR &#91;ebx&#93;&#41;.CurrentStackLocation<br />    ;;  nextIrpSp = IoGetNextIrpStackLocation&#40; &#40;Irp&#41; &#41;; <br />    mov edi, &#40;_IRP PTR &#91;ebx&#93;&#41;.Tail.Overlay.CurrentStackLocation<br />    dec edi<br />    invoke RtlCopyMemory, edi, esi, FIELD_OFFSET&#40;IO_STACK_LOCATION, CompletionRoutine&#41;<br />    xor eax, eax<br />    mov &#40;IO_STACK_LOCATION PTR &#91;edi&#93;&#41;.Control, eax    ;; xor is less byts than &quot;mov xxx, 0&quot;<br />    pop edi<br />    pop esi   <br />ENDM<br /><br />;++<br />;<br />; VOID<br />; IoSetCompletionRoutine&#40;<br />;     IN PIRP Irp,<br />;     IN PIO_COMPLETION_ROUTINE CompletionRoutine,<br />;     IN PVOID Context,<br />;     IN BOOLEAN InvokeOnSuccess,<br />;     IN BOOLEAN InvokeOnError,<br />;     IN BOOLEAN InvokeOnCancel<br />;     &#41;<br />;<br />; Routine Description&#58;<br />;<br />;     This routine is invoked to set the address of a completion routine which<br />;     is to be invoked when an I/O packet has been completed by a lower-level<br />;     driver.<br />;<br />; Arguments&#58;<br />;<br />;     Irp - Pointer to the I/O Request Packet itself.<br />;<br />;     CompletionRoutine - Address of the completion routine that is to be<br />;         invoked once the next level driver completes the packet.<br />;<br />;     Context - Specifies a context parameter to be passed to the completion<br />;         routine.<br />;<br />;     InvokeOnSuccess - Specifies that the completion routine is invoked when the<br />;         operation is successfully completed.<br />;<br />;     InvokeOnError - Specifies that the completion routine is invoked when the<br />;         operation completes with an error status.<br />;<br />;     InvokeOnCancel - Specifies that the completion routine is invoked when the<br />;         operation is being canceled.<br />;<br />; Return Value&#58;<br />;<br />;     None.<br />;<br />;--<br />;<br />;#define IoSetCompletionRoutine&#40; Irp, Routine, CompletionContext, Success, Error, Cancel &#41; &#123; \<br />;    PIO_STACK_LOCATION irpSp;                                               \<br />;    ASSERT&#40; &#40;Success&#41; | &#40;Error&#41; | &#40;Cancel&#41; ? &#40;Routine&#41; != NULL &#58; TRUE &#41;;    \<br />;    irpSp = IoGetNextIrpStackLocation&#40; &#40;Irp&#41; &#41;;                             \<br />;    irpSp-&gt;CompletionRoutine = &#40;Routine&#41;;                                   \<br />;    irpSp-&gt;Context = &#40;CompletionContext&#41;;                                   \<br />;    irpSp-&gt;Control = 0;                                                     \<br />;    if &#40;&#40;Success&#41;&#41; &#123; irpSp-&gt;Control = SL_INVOKE_ON_SUCCESS; &#125;               \<br />;    if &#40;&#40;Error&#41;&#41; &#123; irpSp-&gt;Control |= SL_INVOKE_ON_ERROR; &#125;                  \<br />;    if &#40;&#40;Cancel&#41;&#41; &#123; irpSp-&gt;Control |= SL_INVOKE_ON_CANCEL; &#125; &#125;<br /><br />IoSetCompletionRoutine MACRO pIrp&#58;REQ, Routine&#58;REQ,  \<br />                             CompletionContext&#58;REQ,  \<br />                             Success&#58;REQ, Error&#58;REQ, \<br />                             Cancel&#58;REQ<br /><br />    mov ebx, IoGetNextIrpStackLocation&#40; pIrp &#41;<br />    mov eax, DWORD PTR Routine                                     ;; Incase a memory address is given as 'routine'<br />    mov &#40;IO_STACK_LOCATION PTR &#91;ebx&#93;&#41;.CompletionRoutine, eax       ;; Now &quot;mov mem, reg&quot; &#40;always successful&#41;<br />    mov eax, DWORD PTR CompletionContext<br />    mov &#40;IO_STACK_LOCATION PTR &#91;ebx&#93;&#41;.Context, eax<br />    xor eax, eax                                                   ;; better than &quot;mov mem, 00000000h&quot;<br />    mov &#40;IO_STACK_LOCATION PTR &#91;ebx&#93;&#41;.Control, eax<br /><br />    .IF Success<br />        mov &#40;IO_STACK_LOCATION PTR &#91;ebx&#93;&#41;.Control, SL_INVOKE_ON_SUCCESS<br />    .ENDIF<br /><br />    .IF Error<br />        or &#40;IO_STACK_LOCATION PTR &#91;ebx&#93;&#41;.Control, SL_INVOKE_ON_ERROR<br />    .ENDIF<br /><br />    .IF Cancel<br />        or &#40;IO_STACK_LOCATION PTR &#91;ebx&#93;&#41;.Control, SL_INVOKE_ON_CANCEL<br />    .ENDIF<br /><br />ENDM<br /><br />;<br />; Calculate the byte offset of a field in a structure of type 'type'.<br />;<br />;#define FIELD_OFFSET&#40;type, field&#41;    &#40;&#40;LONG&#41;&#40;LONG_PTR&#41;&amp;&#40;&#40;&#40;type *&#41;0&#41;-&gt;field&#41;&#41;<br /><br />FIELD_OFFSET MACRO struc_name&#58;REQ, member_field&#58;REQ<br />    EXITM %&#40;struc_name&amp;.&amp;member_field&amp;&#41;<br />ENDM<br /><br />-------------------------------------------------------------------------------</code></pre><br />Anywho, hope this is some help ;)<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2003-01-08 21:54:17 by NaN</div>
   </div>
   <div class="post" id="post-75232">
    <div class="subject"><a href="#post-75232">Macro creation assistance for WDM tut</a></div>
    <div class="body"><strong>1.</strong> The DDK stands that IoGetCurrentIrpStackLocation is &quot;routine&quot;.<br />We know it's not true, but...<br />When driver writer read this he might expect esi, edi, ebx are preserved.<br />It's very very bad, IMHO, to use these regs in macro.<br />You will get BSOD in very short order.<br /><br />I use this macro in my ntddk.inc<br /><pre><code>IoGetCurrentIrpStackLocation MACRO pIrp&#58;REQ<br />    IFDIFI &lt;pIrp&gt;, &lt;eax&gt;	;; don't move eax onto itself<br />        mov eax, pIrp<br />    ENDIF<br />    mov eax, &#40;_IRP PTR &#91;eax&#93;&#41;.Tail.Overlay.CurrentStackLocation<br />ENDM</code></pre>I have not defined other *IrpStackLocation macros because i don't need them.<br />If you will do, please hardly try to use only eax register.<br />And never esi, edi, ebx<br /><br /><strong>2.</strong><br /><pre><code>mov esi, &#40;_IRP PTR &#91;edi&#93;&#41;.CurrentStackLocation</code></pre><br />CurrentStackLocation ia a field of nested structure Overlay but not the field of _IPR itself.<br />It tells me you use incorrectly defined _IRP structure.<br /><br />Mine is below:<br /><pre><code>;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;<br />; I/O Request Packet &#40;IRP&#41; definition<br />;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;<br /><br />_IRP STRUCT			; sizeof = 70h<br />	fwType			WORD	?<br />	cbSize			WORD	?	; 02h<br /><br />	; Define the common fields used to control the IRP.<br /><br />	; Define a pointer to the Memory Descriptor List &#40;MDL&#41; for this I/O<br />	; request.  This field is only used if the I/O is &quot;direct I/O&quot;.<br /><br />	MdlAddress		PVOID	?		; 04h PMDL<br /><br />	; Flags word - used to remember various flags.<br /><br />	Flags			DWORD	?		; 08h<br /><br />	; The following union is used for one of three purposes&#58;<br />	;<br />	; 1. This IRP is an associated IRP.  The field is a pointer to a master IRP.<br />	;<br />	; 2. This is the master IRP.  The field is the count of the number of<br />	; IRPs which must complete &#40;associated IRPs&#41; before the master can<br />	; complete.<br />	;<br />	; 3. This operation is being buffered and the field is the address of<br />	; the system space buffer.<br /><br />	UNION AssociatedIrp<br />		MasterIrp		PVOID	?	; 0Ch PIRP<br />		IrpCount		DWORD	?	; 0Ch <br />		SystemBuffer	PVOID	?	; 0Ch <br />	ENDS	; AssociatedIrp<br /><br />	; Thread list entry - allows queueing the IRP to the thread pending I/O<br />	; request packet list.<br /><br />	ThreadListEntry	LIST_ENTRY	&lt;&gt;	; 10h<br /><br />	; I/O status - final status of operation.<br /><br />	IoStatus		IO_STATUS_BLOCK	&lt;&gt;	; 18h<br /><br />	; Requestor mode - mode of the original requestor of this operation.<br /><br />	RequestorMode	BYTE	?	; 20h KPROCESSOR_MODE<br /><br />	; Pending returned - TRUE if pending was initially returned as the<br />	; status for this packet.<br /><br />	PendingReturned	BYTE	?	; 21h<br /><br />	; Stack state information.<br /><br />	StackCount		BYTE	?	; 22h<br />	CurrentLocation	BYTE	?	; 23h<br /><br />	; Cancel - packet has been canceled.<br /><br />	Cancel			BYTE	?	; 24h<br /><br />	; Cancel Irql - Irql at which the cancel spinlock was acquired.<br /><br />	CancelIrql		BYTE	?	; 25h<br /><br />	; ApcEnvironment - Used to save the APC environment at the time that the<br />	; packet was initialized.<br /><br />	ApcEnvironment	BYTE	?	; 26h<br /><br />	; Allocation control flags.<br /><br />	AllocationFlags	BYTE	?	27h<br /><br />	; User parameters.<br /><br />	UserIosb		PIO_STATUS_BLOCK	?	; 28h<br />	UserEvent		PKEVENT				?	; 2Ch<br />	UNION Overlay							; 30h<br />		STRUCT AsynchronousParameters		; 30h<br />			UserApcRoutine	PVOID	?	; 30h PIO_APC_ROUTINE<br />			UserApcContext	PVOID	?	; 34h<br />		ENDS	; AsynchronousParameters<br />		AllocationSize		LARGE_INTEGER	&lt;&gt;	; 30h<br />	ENDS	; Overlay<br /><br />	; CancelRoutine - Used to contain the address of a cancel routine supplied<br />	; by a device driver when the IRP is in a cancelable state.<br /><br />	CancelRoutine	PVOID		?		; 38h PDRIVER_CANCEL<br /><br />	; Note that the UserBuffer parameter is outside of the stack so that I/O<br />	; completion can copy data back into the user's address space without<br />	; having to know exactly which service was being invoked.  The length<br />	; of the copy is stored in the second half of the I/O status block. If<br />	; the UserBuffer field is NULL, then no copy is performed.<br /><br />	UserBuffer		PVOID		?	; 3Ch<br /><br />	; Kernel structures<br />	;<br />	; The following section contains kernel structures which the IRP needs<br />	; in order to place various work information in kernel controller system<br />	; queues.  Because the size and alignment cannot be controlled, they are<br />	; placed here at the end so they just hang off and do not affect the<br />	; alignment of other fields in the IRP.<br /><br />	UNION Tail<br />		STRUCT Overlay<br />			UNION<br />				; DeviceQueueEntry - The device queue entry field is used to<br />				; queue the IRP to the device driver device queue.<br /><br />				DeviceQueueEntry	KDEVICE_QUEUE_ENTRY	&lt;&gt;<br /><br />				STRUCT<br />					; The following are available to the driver to use in<br />					; whatever manner is desired, while the driver owns the<br />					; packet.<br />					DriverContext	PVOID	4 dup&#40;?&#41;<br />				ENDS<br /><br />			ENDS<br /><br />			; Thread - pointer to caller's Thread Control Block.<br /><br />			Thread				PVOID	?			; PETHREAD<br /><br />			; Auxiliary buffer - pointer to any auxiliary buffer that is<br />			; required to pass information to a driver that is not contained<br />			; in a normal buffer.<br /><br />			AuxiliaryBuffer		PCHAR	?<br /><br />			; The following unnamed structure must be exactly identical<br />			; to the unnamed structure used in the minipacket header used<br />			; for completion queue entries.<br /><br />			STRUCT<br /><br />				; List entry - used to queue the packet to completion queue, among<br />				; others.<br /><br />				ListEntry		LIST_ENTRY	&lt;&gt;<br /><br />				UNION<br /><br />					; Current stack location - contains a pointer to the current<br />					; IO_STACK_LOCATION structure in the IRP stack.  This field<br />					; should never be directly accessed by drivers.  They should<br />					; use the standard functions.<br />					CurrentStackLocation	PVOID	?	; PTR IO_STACK_LOCATION<br /><br />					; Minipacket type.<br /><br />					PacketType				DWORD	?<br />				ENDS<br />			ENDS<br /><br />			; Original file object - pointer to the original file object<br />			; that was used to open the file.  This field is owned by the<br />			; I/O system and should not be used by any other drivers.<br /><br />			OriginalFileObject	PFILE_OBJECT	?<br /><br />		ENDS	; Overlay<br /><br />		; APC - This APC control block is used for the special kernel APC as<br />		; well as for the caller's APC, if one was specified in the original<br />		; argument list.  If so, then the APC is reused for the normal APC for<br />		; whatever mode the caller was in and the &quot;special&quot; routine that is<br />		; invoked before the APC gets control simply deallocates the IRP.<br /><br />		Apc		KAPC	&lt;&gt;<br /><br />		; CompletionKey - This is the key that is used to distinguish<br />		; individual I/O operations initiated on a single file handle.<br /><br />		CompletionKey	PVOID	?<br /><br />	ENDS	;Tail<br /><br />_IRP ENDS<br />PIRP typedef PTR _IRP</code></pre></div>
    <div class="meta">Posted on 2003-01-09 05:22:51 by Four-F</div>
   </div>
   <div class="post" id="post-75272">
    <div class="subject"><a href="#post-75272">Macro creation assistance for WDM tut</a></div>
    <div class="body"><div class="quote"><em>Originally posteb by bitRake</em><br /><strong>TYPE is a reserved word. This macro reduces to a constant<br /></div><br /><br />Thanks for point this out to me.  I feel like such a newbie when it comes to this macro stuff :)<br /><br /><div class="quote"><em>Originally posteb by NaN</em><br /><strong>I have one major concern. The C++ macro:<br />;#define IoGetNextIrpStackLocation( Irp ) ( (Irp)-&gt;Tail.Overlay.CurrentStackLocation - 1 )<br /></div><br /><br />This is how it is defined inside the wdm.h file.<br /><br /><div class="quote"><em>Originally posteb by </em><br /><strong>Lastly i use EBX soley for structure accessing. This is to keep a consistancy up so you can rely on edi, and esi if need be. This is also why i push/pop esi, edi in the copy routine. From a users point of view, they should only have to memorize &quot;dont use EBX cause it will be corrupted, and be ready for returns in EAX&quot;...<br /></div><br /><br />Thanks for the excellent tip!  I am learning so much from all of the response.  Heck in no time I will be a macro programming master :) -- NOT.  I can see, though, I do have alot of work ahead of me to figuring out the proper use and definitions of macros.  Its just that I have spent so much time not using macros that grasping the use seems to be difficult (maybe it's that I am just going crazy :) )<br /><br /><br /><div class="quote"><br />It's very very bad, IMHO, to use these regs in macro.<br />You will get BSOD in very short order.<br /></div><br /><br />Thanks for the tip! as it is well noted as I truly do not<br />build and use macros that much (I am a baddddd little boy :) )<br /><br /><br /><div class="quote"><br />I have not defined other *IrpStackLocation macros because i don't need them.<br />If you will do, please hardly try to use only eax register.<br />And never esi, edi, ebx<br /></div><br /><br />I never really use them either!  What I was trying to do was to make the Win32ASM code<br />read like the C code and then within the text document I was going to explain that you<br />really did not need to use them as this is all that they were   I was just thinking that<br />the more the source codes look and feel alike the the easier it would be for people<br />to concentrate on the meat of the text document rather than spending their time in<br />figuring out the differences in the way the code is layed out.<br /><br /><br /><div class="quote"><br />CurrentStackLocation ia a field of nested structure Overlay but not the field of _IPR itself.<br />It tells me you use incorrectly defined _IRP structure.<br /></div><br /><br />Your right, stupid me I failed to notice what I had done wrong :eek:   As you can see from the below code snippet (my version of _IRP) I had the UNION's and Structs as no names (I failed to remove the ; before the name of the UNION) :rolleyes: and if you do not mind I would like to use your corrected version in my future projects.<br /><br />Thanks for pointing that out!<br /><br /><pre><code><br />_IRP Struct<br />    irpType         WORD                ?   ;+000h<br />    irpSize         WORD                ?   ;+002h<br />    MdlAddress      pMDL                ?   ;+004h<br />    Flags           DWORD               ?   ;+008h<br />    UNION ;AssociatedIrp<br />      MasterIrp     pIRP        ?   ;+00Ch<br />      IrpCount      DWORD       ?   ;+00Ch<br />      SystemBuffer  pVOID       ?   ;+00Ch<br />    ENDS ; AssociatedIrp<br />    ThreadListEntry LIST__ENTRY         &lt;&gt;  ;+010h<br />    IoStatus        IO_STATUS_BLOCK     &lt;&gt;  ;+018h<br />    RequestorMode   BYTE                ?   ;+020h<br />    PendingReturned BYTE                ?   ;+021h<br />    StackCount      BYTE                ?   ;+022h<br />    CurrentLocation BYTE                ?   ;+023h<br />    Cancel          BYTE                ?   ;+024h<br />    CancelIrql      BYTE                ?   ;+025h<br />    ApcEnvironment  BYTE                ?   ;+026h<br />    AllocationFlags BYTE                ?   ;+027h<br />    UserIosb        pIO_STATUS_BLOCK    ?   ;+028h<br />    UserEvent       pKEVENT             ?   ;+02Ch<br />    UNION  ;Overlay<br />      STRUCT ;AsynchronousParameters<br />        UserApcRoutine  pFunction   ?   ;+030h<br />        UserApcContext  pVOID       ?   ;+034h<br />      ENDS ;AsynchronousParameters<br />      AllocationSize    LARGE_INT   &lt;&gt;  ;+030h<br />    ENDS<br />    CancelRoutine   pFunction           ?   ;+038h<br />    UserBuffer      pVOID               ?   ;+03Ch<br />    UNION    ;Tail<br />      STRUCT   ;Overlay<br />        DeviceQueueEntry    KDEVICE_QUEUE_ENTRY &lt;&gt;  ;+040h<br />      ENDS ;Overlay<br />      STRUCT<br />        DriverContext           pVOID 4 DUP         &#40;?&#41;     ;+040h<br />        Thread                  pETHREAD            ?       ;+050h<br />        AuxiliaryBuffer         DWORD               ?       ;+054h<br />        ListEntry               LIST__ENTRY         &lt;&gt;      ;+058h<br />        UNION<br />            CurrentStackLocation    pIO_STACK_LOCATION  ?   ;+060h<br />            PacketType              DWORD               ?   ;+060h<br />        ENDS<br />        OriginalFileObject      pFILE_OBJECT        ?       ;+064h<br />      ENDS<br />      UNION<br />        Apc           KAPC      &lt;&gt;                          ;+040h<br />        CompletionKey pVOID     ?                           ;+040h<br />      ENDS<br />    ENDS ;Tail<br />_IRP ENDS<br /></code></pre><br /><br />;-------------------------<br /><br />Now for one last Macro question, does anyone already have a macro for ASSERT?<br /><br />Again, I can not begin to tell each of you how much I appreciate your help.  Not only has it helped me to get a better understanding of one of my weak points (macros) but it has also helped out greatly in the development process of my WDM tutorial (I would have spent a long time trying to figure out what was wrong with the macro code).<br /><br />Have a good day (or night - depending on where you are at).:alright:</div>
    <div class="meta">Posted on 2003-01-09 10:16:32 by madprgmr</div>
   </div>
   <div class="post" id="post-75315">
    <div class="subject"><a href="#post-75315">Macro creation assistance for WDM tut</a></div>
    <div class="body"><div class="quote"><em>Originally posted by NaN </em><br />I noticed this and other stuff with the macros, so i abondonded your code (in some cases) and simply translated it for you from the #defines in the comments.<br /><br />I have one major concern.  The C++ macro:<br /><strong>;#define IoGetNextIrpStackLocation( Irp ) ( (Irp)-&gt;Tail.Overlay.CurrentStackLocation - 1 )<br /></strong><br /><br />Looks odd.  Get the current address pointer, then subtract one from the address? One BYTE? If the stack is aligned on DWORDS then the alignment will be thrown off!  However, im translating it literally!  It may be 1 (DWORD) in which case you need to change it to 'sub eax, 4' instead...<br /><br />The problem is, i dont know what these macro's do, or what the structures look like that they operater on.<br /><br />;--<br />;#define IoSkipCurrentIrpStackLocation( Irp ) \<br />;    (Irp)-&gt;CurrentLocation++; \<br />;    (Irp)-&gt;Tail.Overlay.CurrentStackLocation++;<br />;<br />IoSkipCurrentIrpStackLocation MACRO pIrp:REQ<br />    mov ebx, pIrp<br />    inc (_IRP PTR ).CurrentLocation          <br />    inc (_IRP PTR ).Tail.Overlay.CurrentStackLocation  <br />ENDM<br /></div>I checked Oney (instead of wading through C++ code).<br />There is an array of <strong>IO_STACK_LOCATION</strong> structures, and <strong>CurrentLocation</strong> is an index into the structure, while <strong>CurrentStackLocation</strong> is a pointer to the same entry. Consequently, the last <strong>inc</strong> must be changed to an <strong>add</strong>:<br /><br /><strong>add (_IRP PTR ).Tail.Overlay.CurrentStackLocation, SIZEOF IO_STACK_LOCATION</strong><br /><br />Similarly, the code for<br /><br />;#define IoGetNextIrpStackLocation( Irp ) ( (Irp)-&gt;Tail.Overlay.CurrentStackLocation - 1 )<br /><br />will be<br /><br /><strong>mov eax, (_IRP PTR ).Tail.Overlay.CurrentStackLocation<br />sub eax, SIZEOF IO_STACK_LOCATION</strong></div>
    <div class="meta">Posted on 2003-01-09 16:35:47 by tenkey</div>
   </div>
   <div class="post" id="post-77895">
    <div class="subject"><a href="#post-77895">Macro creation assistance for WDM tut</a></div>
    <div class="body">madprgmr,<br /><br />Soo err, with the new KMD kit floating around I thought i would ask the question:<br /><br />Hows the WDM tutorial going?? :grin:<br /><br />:NaN:</div>
    <div class="meta">Posted on 2003-01-22 21:44:49 by NaN</div>
   </div>
   <div class="post" id="post-77952">
    <div class="subject"><a href="#post-77952">Macro creation assistance for WDM tut</a></div>
    <div class="body"><div class="quote"><br />madprgmr,<br /><br />Soo err, with the new KMD kit floating around I thought i would ask the question:<br /><br />Hows the WDM tutorial going?? :grin:<br /><br />:NaN: </div><br /><br />I am sorry to say that it is comming rather slowly as I have been sick with the Flu on-top-of a large amount of extra work at work and dealing with the adoption process. :( <br /><br />I will try to work on it some more this weekend.</div>
    <div class="meta">Posted on 2003-01-23 09:22:26 by madprgmr</div>
   </div>
   <div class="post" id="post-78012">
    <div class="subject"><a href="#post-78012">Macro creation assistance for WDM tut</a></div>
    <div class="body">Take your time... im just happy there *is* work being done.  Those who know it dont seem to write tutorials for it (i assume cause its kinda complicated to explain properly ).<br /><br />Anywho, dont feel rushed; i was just currious..<br />:alright:<br />:NaN:</div>
    <div class="meta">Posted on 2003-01-23 16:33:26 by NaN</div>
   </div>
   <div class="post" id="post-80943">
    <div class="subject"><a href="#post-80943">Progress Update</a></div>
    <div class="body">All:<br /><br />Just thought that I would give you a little update as to the Wdm Tut progress:<br /><br />  At this time I am currently almost done with the debugging of the Win32ASM version of the driver (taking a little more time than I wanted but its getting done).  As for the text portion of this tut, this has been started but is still in it's infancy.<br /><br />I realize that this is taking a long time and all that I can offer you in terms of support is that it will be worth the wait.<br /><br />:alright:</div>
    <div class="meta">Posted on 2003-02-10 18:34:04 by madprgmr</div>
   </div>
  </div>
 </body>
</html>