<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>C Arrays to Assembly Help  - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=24725" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=24725">C Arrays to Assembly Help </a></p>
   <div class="post" id="post-180595">
    <div class="subject"><a href="#post-180595">C Arrays to Assembly Help </a></div>
    <div class="body">Hi Guys<br /><br />I´m trying to convert the following routine to asm:<br /><br /><pre><code><br />	int mcount=0;<br />	int mindex=0;<br /><br />	&nbsp; for(int i=0;i&lt;sizeof(face_indicies)/sizeof(face_indicies[0]);i++)<br />		{<br />&nbsp; &nbsp; &nbsp; if(!mcount)<br />&nbsp; &nbsp; &nbsp;  {<br />&nbsp; &nbsp; &nbsp; &nbsp; SelectMaterial(material_ref[0]);<br />&nbsp; &nbsp; &nbsp; &nbsp; mcount=material_ref[1];<br />&nbsp; &nbsp; &nbsp; &nbsp; mindex++;<br />&nbsp; &nbsp; &nbsp;  }<br />&nbsp; &nbsp; &nbsp;  mcount--;<br />		for(int j=0;j&lt;3;j++)<br />		 {<br />		 int vi=face_indicies<em>;<br />		 int ni=face_indicies<em>;<br />		 int ti=face_indicies<em>;<br />		 glNormal3f (normals[0],normals[1],normals[2]);<br />		 glTexCoord2f(textures[0],textures[1]);<br />		 glVertex3f (vertices[0],vertices[1],vertices[2]);<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp;  }<br /><br />Ehere the variables are:<br />static short face_indicies[15680][9] = {<br />// H0_C_0<br />	{2,1,0 ,0,1,2 ,0,1,2 }, {4,3,1 ,3,4,1 ,3,4,1 }, <br />.....................<br /><br />static int material_ref [1][2] = {<br />{0,15680}<br />};<br /><br />.........<br />static GLfloat normals [744][3] = {<br />{0.353102f,0.924082f,0.14626f},{0.382195f,0.924082f,0.0f},<br />..........................<br />static GLfloat textures [185][2] = {<br />{0.0625f,0.875f},{0.0f,0.875f},{0.03125f,1.0f},<br />..................................<br /><br />static GLfloat vertices [5165][3] = {<br />{-0.00680804f,0.00424107f,0.361161f},{0.0113438f,0.000630464f,0.361161f},<br /><br />Note: I know that sizeof(face_indicies)/sizeof(face_indicies[0]) = 15680<br /><br /></code></pre><br /><br />My problem is with the array indexes...What a hell is:<br /><br /><br /><div class="quote">		 int vi=face_indicies<em>;<br />		 int ni=face_indicies<em>;<br />		 int ti=face_indicies<em>;</div><br /><br />or<br /><br /><div class="quote">		 glNormal3f (normals[0],normals[1],normals[2]);</div><br /><br />or<br /><br /><div class="quote">&nbsp; &nbsp; &nbsp; &nbsp; SelectMaterial(material_ref[0]);<br />&nbsp; &nbsp; &nbsp; &nbsp; mcount=material_ref[1];</div><br /><br />??????????<br /><br />I have no idea how those arrays can be translated to assembly, and used inside a while routine. (The &quot;For&#39; routine is, in fact a While in assembly....ok..but how translate the arrays ?)<br /><br /><br /><br />Someone can help me translating this arrays ?<br /><br /><br />Best Regards,<br /><br />Guga</div>
    <div class="meta">Posted on 2006-05-10 22:27:09 by Beyond2000!</div>
   </div>
   <div class="post" id="post-180596">
    <div class="subject"><a href="#post-180596">Re: C Arrays to Assembly Help </a></div>
    <div class="body">A quick glance reveals that the code determines the index count of the array, and proceeds to processes each array in a sequential manner, starting from &quot;0&quot; (but using <em>i</em> and <em>j</em> from the for loops as counters).<br /><br />All-in-all, it is just looks more complex than it really is. It is a system of variables and arrays based on other variables and arrays. Considering the names of variables and arrays used *cough* <strong>gl</strong> *cough*, I would say that this has to do with game programming in some direct or indirect way, so it makes pretty good sense.<br /><br />Considering that, I would say that the &quot;<em>j+3</em>&quot; type stuff is a point/vertex system (relative position in the array creates an absolute reference.)<br /><br />That code is probably a little beyond my attention span or general understanding right now, but I bet Homer could help you more easily, correctly, and simply than I could hope to :)<br /><br />He shows up often, so just some patience and your question should be answered to your satisfaction.</div>
    <div class="meta">Posted on 2006-05-11 00:10:56 by SpooK</div>
   </div>
   <div class="post" id="post-180597">
    <div class="subject"><a href="#post-180597">Re: C Arrays to Assembly Help </a></div>
    <div class="body">Hi Spook<br /><br />tks...It is not exactly a game programming. It is a molecular model viewer i´m making. I suceed to make the model show up. But this array stuff is really killing.<br /><br />Best Regards,<br /><br />Guga</div>
    <div class="meta">Posted on 2006-05-11 00:22:14 by Beyond2000!</div>
   </div>
   <div class="post" id="post-180599">
    <div class="subject"><a href="#post-180599">Re: C Arrays to Assembly Help </a></div>
    <div class="body">I see.<br /><br />Right now, the array parser looks 2-fold. It is parsing all sub-arrays of each array (hence the <em>j</em> of <em>i</em>).<br /><br />I said that this can be explained better, but I offer to explain it in a way that I &quot;explain&quot; things to myself when breaking stuff down to assembly language.<br /><br /><em>i</em> starts off as zero. Then <em>j</em> is used to go through each set of points in the index. In short...<br /><br /><ul><br /><li>vi = the first point when <em>j</em> = 0, fourth point when <em>j</em> = 1, and seventh point when <em>j</em> = 2</li><br /><li>ni = the second point when <em>j</em> = 0, fifth point when <em>j</em> = 1, and eighth point when <em>j</em> = 2</li><br /><li>ti = the third point when <em>j</em> = 0, sixth point when <em>j</em> = 1, and ninth point when <em>j</em> = 2</li><br /></ul><br /><br />So in a quick way, your assembly language equivalent (please note that I am a NASM buff) could look like so...<br /><pre><code><br />;Assmue sizeof was used from Windows API call and value is now stored in EAX, divide EAX by 9 (quick and dirty way of doing it)<br /><br />;for i<br />parse_array:<br />mov ebx,eax<br />shl ebx,1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Extrapolate array position<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Assume WORD (16-bit) sized array index<br />mov ecx,ebx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;ECX = EBX <br />add ecx,18&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Set ECX to the index &quot;j&quot; limit we wish to use ((3*3) * 2)<br />cmp BYTE<em>,al&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Compare AL to i<br />jl .parse_subarray&nbsp; &nbsp; &nbsp; &nbsp; ;Process array if we are within the array size limit<br />jmp .end&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Otherwise, end processing<br /><br />;for j<br />.parse_subarray:<br />add ebx,face_indicies&nbsp; &nbsp; ;Add base address of the master array to EBX (array offset)<br />mov dx,WORD&nbsp; &nbsp; &nbsp;  ;Load first indexed point<br />mov WORD,dx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Store value of first indexed point into VI<br />mov dx,WORD&nbsp;  ;Load second indexed point (+3, but WORD size makes it +6)<br />mov WORD,dx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Store value of second indexed point into NI<br />mov dx,WORD ;Load third indexed point (+6, but WORD size makes it +12)<br />mov WORD,dx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Store value of third indexed point into TI<br /><br />;blah blah blah... more stuff...<br /><br />add ebx,2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Increase array offset by one (but acknowledge WORD size)<br />cmp ebx,ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Have we processed all sub_arrays???<br />jl .parse_subarray&nbsp; &nbsp; &nbsp; &nbsp; ;If not, keep processing!!!<br /><br />inc BYTE<em>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Increment i<br />jmp parse_array&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Keep processing array...<br /><br />.end:<br />;umm... are we finished???<br /></code></pre><br /><br />I kind of slapped that together quick and dirty like, might be a few logic/grammatical errors as well... but you should get a general idea of how you can access the values of these arrays (other methods can be used as well).</div>
    <div class="meta">Posted on 2006-05-11 01:30:10 by SpooK</div>
   </div>
   <div class="post" id="post-180601">
    <div class="subject"><a href="#post-180601">Re: C Arrays to Assembly Help </a></div>
    <div class="body">It&#39;s using OpenGL (obviously), but it doesn&#39;t use vertex buffers, which is a <strong>*SERIOUS*</strong> preformance penalty.<br /><br /><pre><code>¦nbsp; ¦nbsp; ¦nbsp; ¦nbsp;int vi=face_indicies;<br />¦nbsp; ¦nbsp; ¦nbsp; ¦nbsp;int ni=face_indicies;<br />¦nbsp; ¦nbsp; ¦nbsp; ¦nbsp;int ti=face_indicies;</code></pre><br />vi = vertex index<br />ni - normal index ( normals follow vertices)<br />ti - texture index ( texture coordinates follow normals)<br /><br />1 vertex here is X;Y;Z;Xn;Yn;Zn;Tu;Tv; , so it takes 8 elements (usually 32-bit floating pointvalues) to describe a vertex. 3 vertices are requiredd to form a &#39;face&#39; (a triangle in such case).<br /><br /><a target="_blank" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/opengl/glfunc03_5ru4.asp">glNormal</a> (&#39;3f&#39; in this case) sets current normal vecotr. OpengGL is a state machine - it works according to many &#39;states&#39;. glNormal3f sets the &#39;actual normal&#39; state. Vertex/Index buffers are used to drastically speed up the rendering process (which is not being done here). <a target="_blank" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/opengl/glfunc03_7cq4.asp">glMaterial</a> is used to set &#39;actual material&#39; state.</div>
    <div class="meta">Posted on 2006-05-11 03:23:12 by ti_mo_n</div>
   </div>
   <div class="post" id="post-180603">
    <div class="subject"><a href="#post-180603">Re: C Arrays to Assembly Help </a></div>
    <div class="body">Hi ti_mo_n <br /><br />Tks<br /><br />So i need here 8 Buffers, right&nbsp; ?<br /><br />Ok..but concernign the arrat..i´m still not following the translation to asm of it.<br /><br /><br />Do you need me to post teh entire C function to you take a look ?<br /><br /><br />Best REgards<br /><br />Guga</div>
    <div class="meta">Posted on 2006-05-11 04:03:15 by Beyond2000!</div>
   </div>
  </div>
 </body>
</html>