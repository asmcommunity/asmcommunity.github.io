<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Help - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=3044" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=3044">Help</a></p>
   <div class="post" id="post-19934">
    <div class="subject"><a href="#post-19934">Help</a></div>
    <div class="body">Hello it's about a source code that i've not understood :<br />well it's about the water effect demo og tom kenny i think :<br />i'd like to know where in his code is the code for makink the ripples simulating drops ( well if possible the formula he uses , comments on it , .. ) <br />Well before pasting code thanks for all help !!! :<br /><br /><br />;                            The Great &quot;Water Effect&quot; Demo!!!<br />;                            By Tom Kenny<br />;<br />;<br />;  My first full assembler program, this little demo creates a rain-storm (or more <br />;  accurately a light-drizzle :) on the user's desktop for a while.  It demonstrates <br />;  the Windows GDI and Multi-threading. There is no program window. <br />;<br />;  The droplet effect is done by creating a TILE_SIZE x TILE_SIZE bitmap at a random<br />;  location on the user's desktop. The wave is simulated by using two arrays of bytes<br />;  representing water depth (height maps).  The main program loop, creates several of <br />;  these tiles at once thus simulating a rainstorm on the desktop.<br />;<br />;  The separate tiles are handled using an array of structures (WaterTileStruct) which<br />;  define the X and Y coordinates of each tile as well as maintaining pointers to their <br />;  bitmaps and height maps.  Each tile runs on its' own thread of execution for <br />;  NUM_FRAMES then dies on its own (no fuss, no muss).<br />;<br />;  This program was written on the MASM32 package (Version 6). <br />;<br /><br />.386 <br />.model flat,stdcall <br />option casemap:none <br />include \masm32\include\windows.inc <br />include \masm32\include\user32.inc <br />include \masm32\include\kernel32.inc <br />include \masm32\include\gdi32.inc <br />includelib \masm32\lib\user32.lib <br />includelib \masm32\lib\kernel32.lib <br />includelib \masm32\lib\gdi32.lib <br /><br /><br />LPCOLORREF TYPEDEF PTR COLORREF;             Create some TypeDefs........<br />LPBYTE TYPEDEF PTR BYTE;<br />PBITMAPINFO  TYPEDEF   PTR   BITMAPINFO  <br /><br />; Define the structure which keeps our WaterTiles...<br />WaterTileStruct STRUCT<br /><br />  IsInUse DWORD 0                     ; Is this structure currently in use?<br />  DropDepth DWORD 0                   ; How deep is the droplet?<br />  OffSetX DWORD 0                     ; Offset from the left of the screen<br />  OffSetY DWORD 0                     ; Offset from the top of the screen<br />  CaptureBitmap HBITMAP 0             ; Holds the &quot;background&quot; on which the effect is drawn<br />  WaterBitmap HBITMAP 0               ; The finished frame of animation.<br />  CaptureBitmapBits LPCOLORREF 0      ; Points to the bits of CaptureBitmap<br />  WaterBitmapBits LPCOLORREF 0        ; Points to the bits of WaterBitmap<br />  HeightMapOne LPBYTE 0               ; Points to a frame of water height data<br />  HeightMapTwo LPBYTE 0               ; Points to the last frame of water height data<br />   <br />WaterTileStruct ends <br /><br />LPWaterTileStruct TYPEDEF PTR WaterTileStruct   ; typedef a pointer to a WaterTileStruct<br /><br />WinMain proto :DWORD,:DWORD,:DWORD,:DWORD <br />;      <br />; Our &quot;main&quot; function most of the parameters aren't used, but I kept them for consistency with <br />; standards.<br />;<br /><br />CreateStorm proto WTStruct:LPWaterTileStruct, StormSize:DWORD, Elements:DWORD<br />;<br />; This is where the magic happens!  This function defines a loop which is responsible<br />; for creating our water tiles. First it searches the array of WaterTiles to find a free <br />; structure that we can use to make a new tile.  If it finds one, it generates random<br />; x and y coordinates, and a random droplet depth.  Then it searches the existing tiles<br />; to make sure that the new tile's coordinates don't interfere with any already running <br />; tiles.  provided there is no interference, the new tile's structure is filled out and<br />; its own thread of execution is created.  A short Sleep after each tile's creation makes<br />; for a steady stream of droplets.  Up to MAX_DROPS_AT_ONCE drops can be created at any time.<br />;<br /><br />ThreadProc proto WTStruct:LPWaterTileStruct<br />;<br />; This is the callback we use when we call CreateThread to create a thread of execution for <br />; a tile. All it does is call CreateWaterTile.  It takes a pointer to the tile's watertile <br />; structure. <br />; <br /><br />CreateWaterTile proto WTStruct:LPWaterTileStruct<br />;<br />; This function acts as a sort of parent for each tile.  It captures a TILE_SIZE x<br />; TILE_SIZE portion of the desktop at OffSetX, OffSetY, and then calls the function<br />; CreateWaterMaps to allocate memory for the two required &quot;height maps&quot;.  Then it calls<br />; the CreateADrop function to place the raindrop in one of the &quot;height maps&quot;.  Then<br />; it calls AnimationLoop to handle the animation of the tile. When the animation is <br />; complete, DestroyObjects is called to de-allocate the memory used by the tile's bitmaps<br />; and height maps.  All of the functions from now on take a pointer to an individual Tile's<br />; structure (i.e. one of the tiles from the global array of tile structures)..<br />;<br /><br />CreateWaterMaps proto WTStruct:LPWaterTileStruct<br />;<br />; This just allocates two arrays to handle our &quot;height maps&quot; Since we need one byte for<br />; each pixel, we need TILE_SIZE x TILE_SIZE bytes for each map.<br />;<br /><br />CreateADrop proto WTStruct:LPWaterTileStruct<br />;<br />; In order to start the ripples, we need a nice big drop placed square in the middle of the<br />; tile.  Using the .DropDepth member of the Tile structure, we calculate the drop's depth<br />; and put the information into the first &quot;Height Map&quot;.<br />;<br /><br />AnimationLoop proto WTStruct:LPWaterTileStruct<br />;<br />; Here is where the actual animation of the tile happens.  This function consists of a loop<br />; (run once every SLEEP_TIME milliseconds) that calls ProcessWater to produce a new<br />; water &quot;height map&quot; for the current Tile, then it calls the MakeFrame function to create<br />; the display bitmap based on the height map.  Finally, PaintWaterTile blits the tile<br />; to the screen.<br />;<br /><br />ProcessWater proto WTStruct:LPWaterTileStruct<br />;<br />; This function processes our two &quot;height map&quot; arrays to produce a height map for our<br />; current animation frame.<br />;<br />; The animation of a tile is achieved by maintaining two separate arrays of information<br />; on the height of the water at each pixel in the tile.  The first array holds the <br />; information for the current frame of animation, the second holds the information from<br />; the last frame.  Between the two frames, we have enough information to create a new<br />; frame of animation (in the second array).  Then we switch the pointers to the arrays<br />; around and do it again for the next frame ect.....  <br /><br />MakeFrame proto WTStruct:LPWaterTileStruct<br />;<br />; This function goes through the new height map and depending on the value of each byte<br />; the corresponding pixel in the destination bitmap is set.  If the value of a given byte<br />; was zero for instance, then the resulting pixel on the desintation bitmap would be the<br />; same as the pixel in the source (or background) bitmap.  Non-zero bytes correspond to<br />; another pixel from the source bitmap (i.e. due to the water's refraction).<br />;<br /><br />PaintWaterTile proto WTStruct:LPWaterTileStruct<br />;<br />; Nothing too exciting here!  Just creates a DC, and blits the finished bitmap onto the<br />; screen.<br />;<br /><br />DestroyObjects  proto WTStruct:LPWaterTileStruct<br />;<br />; Here we de-allocate the memory that was used to store the &quot;height maps&quot; and the source and <br />; destination bitmaps.  Also the IsInUse member is set back to false here so that the tile can<br />; be reused.<br />;<br /><br />FillWTStruct proto WTStruct:LPWaterTileStruct, OffSetX:DWORD, OffSetY:DWORD, DropDepth:DWORD<br />;<br />; This helper function fills out a Tile Structure for us.  It takes the XOffset, the YOffset<br />; and the Drop Depth.  It also sets the IsInUse member to true to indicate the structure is <br />; in use.<br />;<br /><br />SetupBitmapInfoStruct proto BIH:PBITMAPINFO, PicWidth:DWORD, PicHeight:DWORD<br />;<br />; Many bitmaps (dibsections actually) are created in this program. Since they are all the same <br />; size (TILE_SIZE x TILE_SIZE) we just fill out one BITMAPINFO structure and use it every time we<br />; need to create a bitmap. It takes a pointer to a BITMAPINFO structure, and the width and height<br />; of the bitmap.<br />;<br />;<br /><br />TRand proto :DWORD<br />;<br />; This is the random number generating function.  The code is based on something I took<br />; from VC++'s C library.  This function takes one parameter specifying the upper limit<br />; of the number to be generated.<br />;<br /><br /><br />.DATA                                         ; initialized data <br />BitmapInfo BITMAPINFO &lt;&gt;                      ; Our BitmapInfo Structure <br />WTileStruct  WaterTileStruct {},{},{},{},{}   ; an array of 5 Tile structures...<br />seed DWORD 1                                  ; for our Random numbers...<br /><br />.DATA?                                        ; Uninitialized data <br />CommandLine LPSTR ?                           ; Can't have too many of these<br /><br /><br />.CONST<br />TILE_SIZE DWORD 100         ; Our Tile's (length and width) <br />                            ; Unfortunately, I could not use this constant for lea address <br />                            ; calculations for some reason.  So I still have &quot;100&quot; in some<br />                            ; program areas.....<br /><br /><br />TILE_SMIN DWORD 99          ; TILE_SIZE -1 Its usefull in a loop.<br />TRAND_MAX DWORD 32767       ; The maximum possible random number<br /><br />RAND_DROPDEPTH DWORD 100    ; These two constants help us determine a good   <br />MIN_DROPDEPTH DWORD 27      ; drop depth<br /><br />MAX_DROPS_AT_ONCE DWORD 5   ; How many drops can we have at once?<br />STORMLENGTH DWORD 100       ; How many drops should we display in total?<br />SLEEP_TIME DWORD 120;       ; How much time should we wait between creating Tiles?<br />NUM_FRAMES DWORD 55         ; How many frames should a tile run for?<br />SLEEP_TICKS DWORD 10        ; How long should we wait between frames of animation?<br />INVERSE REAL4 0.166666      ; Helps us to divide by 6 quickly!<br />NOT_AVAILABLE DWORD -99     ; When all WaterTile structures  in the array are in use<br /><br />.CODE                                  ; Here comes the CODE segment <br />WaterTiles: <br /><br />invoke GetCommandLine                  ; get the command line.May be useful later.<br />mov CommandLine,eax                    <br /><br />invoke WinMain, NULL,NULL,CommandLine, NULL       ; call the main function <br />invoke ExitProcess, eax                           ; quit our program. The exit code is returned <br />                                                  ; in eax from WinMain. <br /><br />WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD <br /> <br />    ; First lets fill out our WaterTileStructure....<br />    <br />    invoke CreateStorm, ADDR WTileStruct, STORMLENGTH, MAX_DROPS_AT_ONCE;<br />    invoke InvalidateRect, NULL, NULL, 1;<br />                 <br />    xor eax,eax;                                   All's well..... return 0<br />    ret <br />    <br />WinMain endp <br /><br />;##########################################################################################<br /><br />CreateStorm proc WTStruct:LPWaterTileStruct, StormSize:DWORD, Elements:DWORD<br /><br />   LOCAL ScreenX:DWORD<br />   LOCAL ScreenY:DWORD<br />   LOCAL ScreenDC:HDC<br />   LOCAL x:DWORD<br />   LOCAL y:DWORD<br />   LOCAL i:DWORD<br />   LOCAL j:DWORD<br />   LOCAL FreeElement:DWORD<br />   LOCAL DropDepth:DWORD<br />   LOCAL SleepAfter:DWORD<br />   LOCAL ThreadID:DWORD<br /><br />   ; Since all tiles are the same size, we only need to set up one bitmap<br />   ; info structure<br />   <br />   invoke SetupBitmapInfoStruct, ADDR BitmapInfo, TILE_SIZE, TILE_SIZE<br /><br />   xor eax,eax;<br />   mov i, eax;<br />   mov ThreadID, eax;   <br /><br />   StormLoop:<br />       ; the first thing we need to do is see if there are any available structures...<br />              <br />       mov eax, NOT_AVAILABLE;<br />       mov FreeElement, eax;<br /><br />       xor eax,eax;<br />       mov j, eax;<br /><br />       FreeLoop:<br /><br />          mov eax, j;<br />          imul eax, SIZEOF WaterTileStruct;<br />          mov edx, WTStruct;<br />          add edx, eax;<br />          <br />          mov eax, ;<br />          cmp eax, TRUE;<br />          je NotFree<br />          mov eax, j;<br />          mov FreeElement, eax;         The index of a free structure<br />             <br />          NotFree:<br />          inc j;<br />          mov eax, j;<br />          cmp eax, Elements;<br />          <br />       jl FreeLoop;<br />       <br />       mov eax, FreeElement;<br />       cmp eax, NOT_AVAILABLE;<br />       je NoneFree;<br /> <br />       inc i;<br /><br />       invoke GetDC, NULL;<br />       mov ScreenDC, eax;<br /><br />       invoke GetDeviceCaps, ScreenDC, HORZRES;<br />       sub eax, TILE_SIZE;<br />       mov ScreenX, eax;<br /><br />       invoke GetDeviceCaps, ScreenDC, VERTRES;<br />       sub eax, TILE_SIZE;<br />       mov ScreenY, eax;<br /><br />       invoke ReleaseDC, NULL, ScreenDC;<br /><br />       PickCoords:<br />       <br />       invoke TRand, ScreenX;<br />       mov x, eax;<br /><br />       invoke TRand, ScreenY;<br />       mov y, eax;<br /><br />       ; Now for the &quot;ugly&quot; part.  we need to make sure that the x and y coords weve picked<br />       ; dont interfere with any already running animation tiles.  Basically we need to know whether<br />       ; our x and y values are both within +/-TILE_SIZE of already running Tiles. So we go through all <br />       ; the tiles and if they are in use, we look for interferences.  <br />       ;<br />       ; If at any point we see that no interference is possible, we jump past all the other tests.  <br />       ; If we get past all tests we have an interference, and so we jump back up to pick new coordinates...<br /><br />;-----------------------------------------------------<br /><br />       xor eax, eax;<br />       mov j, eax;<br />       <br />       InterferenceLoop:<br /><br />          mov eax, j;<br />          imul eax, SIZEOF WaterTileStruct;<br />          mov edx, WTStruct;<br />          add edx, eax;<br />          add edx, 8;<br />          <br />          mov esi, ;       // esi holds the XOffSet for structure j<br />          add edx, 4;<br />          mov edi, ;       // edi holds the YOffSet for structure j<br /><br />          sub esi, TILE_SIZE;<br />          sub edi, TILE_SIZE;<br /><br />          cmp x, esi;<br />          jl Passed<br />          add esi, TILE_SIZE;<br />          add esi, TILE_SIZE;<br />          cmp x, esi;<br />          jg Passed<br /><br />          cmp y, edi;<br />          jl Passed;<br />          add edi, TILE_SIZE;<br />          add edi, TILE_SIZE;<br />          cmp y, edi;<br />          jg Passed;<br /><br />          jmp PickCoords            ; We have an inteference so go back and pick new coords<br />                   <br />          Passed:                   ; No interference. Increment j and do the next one...<br />          inc j;<br />          mov eax, j;<br />          cmp eax, Elements;<br />          <br />       jl InterferenceLoop;<br />       <br />;-----------------------------------------------<br /><br /> <br />       invoke TRand, RAND_DROPDEPTH                   ; Now get a drop-depth for our droplet<br />       add eax, MIN_DROPDEPTH;<br />       mov DropDepth, eax;<br />  <br />       mov eax, FreeElement;<br />       imul eax, SIZEOF WaterTileStruct;<br />       mov edx, WTStruct;<br />       add edx, eax;<br />     <br />       invoke FillWTStruct, edx, x, y ,DropDepth      ; Fill out our structure<br /><br />       mov eax, FreeElement;<br />       imul eax, SIZEOF WaterTileStruct;<br />       mov edx, WTStruct;<br />       add edx, eax;<br /><br /><br />       xor ebx, ebx                                   ; Create a new thread<br /><br />       invoke CreateThread, ebx, ebx, OFFSET ThreadProc, edx, ebx, ADDR ThreadID <br />       invoke CloseHandle, eax                        ; We dont need the Handle anymore so lets close it now...<br /><br />       NoneFree:                                      ; If we jumped here, there are no free structures<br />       invoke Sleep, SLEEP_TIME;                      ; try sleeping for a while....<br />       <br />       mov eax, i;<br />       cmp eax, StormSize;<br />       <br />   jl StormLoop;<br />   ret<br /><br />CreateStorm  endp <br /><br />;################################################################################################<br /><br />ThreadProc proc WTStruct:LPWaterTileStruct<br /><br />   invoke CreateWaterTile, WTStruct                    ; Create a tile, and off we go.....<br />   ret<br />   <br />ThreadProc endp<br /><br />;################################################################################################<br /><br />CreateWaterTile proc WTStruct:LPWaterTileStruct<br /><br />    LOCAL ScreenDC:HDC<br />    LOCAL BitmapDC:HDC<br />    LOCAL CaptureBitmap:HBITMAP<br />    LOCAL pOldBitmap:HGDIOBJ<br />    LOCAL BitmapBits:LPVOID <br /><br /><br />    invoke CreateCompatibleDC, NULL;                Create a Memory DC<br />    mov BitmapDC, eax;<br />  <br />    invoke GetDC, NULL;                             Get a Hardware DC for our screen...<br />    mov ScreenDC, eax;<br />       <br />    ; create the bitmap<br />      <br />    invoke CreateDIBSection, BitmapDC, ADDR BitmapInfo, DIB_RGB_COLORS, ADDR BitmapBits, NULL, NULL<br />    mov edx, WTStruct;<br />    mov , eax;<br />    mov ebx, ;<br />    mov , ebx;<br /><br />    invoke CreateDIBSection, BitmapDC, ADDR BitmapInfo, DIB_RGB_COLORS, ADDR BitmapBits, NULL, NULL<br />    mov edx, WTStruct;<br />    mov , eax;<br />    mov ebx, ;<br />    mov , ebx;<br /><br />   <br />    ; Select the bitmap into our memory DC<br />      <br />    invoke SelectObject, BitmapDC, eax;  Select the capture bitmap into the memory DC<br />    mov pOldBitmap, eax;<br />  <br />    ;Capture some screen area into the memory DC...<br /><br />    mov edx, WTStruct;<br />    mov eax, ;<br />    mov ebx, ;<br /><br />    invoke BitBlt, BitmapDC ,0 ,0 ,TILE_SIZE ,TILE_SIZE ,ScreenDC ,eax ,ebx ,SRCCOPY;<br />  <br />    ; Now clean up our GDI stuff....<br />  <br />    invoke SelectObject, BitmapDC, pOldBitmap;   Select the bitmap out of the DC and delete it<br />      <br />  <br />    invoke DeleteDC, BitmapDC;                   Delete the DCs....<br />    invoke ReleaseDC, NULL, ScreenDC;<br /><br />    invoke CreateWaterMaps, WTStruct;            Create the water masks for this tile..<br />    invoke CreateADrop, WTStruct;                Place a &quot;drop&quot; on one of the masks<br /><br />    invoke AnimationLoop, WTStruct;              Now Animate!    <br />     <br />    invoke DestroyObjects, WTStruct;             Destroy the watermaps and bitmaps      <br />    ret<br /><br />CreateWaterTile endp <br /><br />;################################################################################################<br /><br />CreateWaterMaps proc WTStruct:LPWaterTileStruct<br /><br />   ; Here is where we allocate the memory for our water masks.....<br /><br />   mov eax, TILE_SIZE;<br />   imul eax, eax;<br />   <br />   invoke GlobalAlloc, GMEM_FIXED or GMEM_ZEROINIT, eax;<br />   mov edx, WTStruct;<br />   mov , eax;<br /><br />   mov eax, TILE_SIZE;<br />   imul eax, eax;<br />   <br />   invoke GlobalAlloc, GMEM_FIXED or GMEM_ZEROINIT, eax;<br />   mov edx, WTStruct;<br />   mov , eax;<br /><br /><br />   ret<br />CreateWaterMaps endp <br /><br />;################################################################################################<br /><br />CreateADrop proc WTStruct:LPWaterTileStruct<br /><br />    LOCAL i:DWORD<br />    LOCAL j:DWORD<br />    LOCAL DripRadius:DWORD<br />    LOCAL Distance:DWORD<br />    LOCAL DropDepth:DWORD<br />    LOCAL FinalDepth:DWORD<br /><br /><br />    mov edx, WTStruct;<br />    mov edx, ;<br /><br />    mov DropDepth, edx;<br />    shr edx, 3;<br />    mov DripRadius, edx;<br /><br />    mov esi, TILE_SIZE;  <br />    shr esi, 1;   <br />		<br />    mov ebx, esi;         // ebx is both X and Y in the original calculation.<br />		<br />    mov edi, esi;         <br />    add edi, edx;         // edi contains the upper limit of our loops<br />    sub esi, edx;         // esi contains the lower limit of our loops<br /><br />    mov j, esi;<br />    JLoop:<br /><br />       mov ecx, esi;<br />	 ILoop:<br />          mov eax, ecx;<br />	    sub eax, ebx;<br />	    imul eax, eax;<br />	    mov Distance, eax;<br /><br />	    mov eax, j;<br />	    sub eax, ebx;<br />	    imul eax, eax;<br />	    add Distance, eax;<br /><br />	    mov eax, DripRadius;<br />	    imul eax, eax;<br /><br />	    cmp Distance, eax;<br />	    jge short NoDrip<br /><br />	    fild DripRadius;        <br />	    fld st(0);<br />	    fild Distance;<br />	    fsqrt;<br />	    fsubp st(1), st(0);<br />	    fxch;<br />	    fdivp st(1), st(0);<br />	    fild DropDepth;<br />	    fmulp st(1), st(0);<br /><br />	    fistp FinalDepth;<br />          mov eax, j;<br />	    imul eax, TILE_SIZE;<br />	    add eax, ecx;<br /><br />	    mov edx, WTStruct;<br />	    mov edx, ;<br />	    add edx, eax;<br />	    mov eax, FinalDepth;<br />	    mov , al;<br /><br />	    NoDrip:<br />	    inc ecx;<br />	    cmp ecx, edi;<br /><br />	 jl short ILoop;<br /><br />	 inc j;<br />	 cmp j, edi;<br /><br />   jl short JLoop;<br />   invoke Sleep, NULL;<br />	<br />   ret<br />CreateADrop endp <br /><br />;################################################################################################<br /><br />AnimationLoop proc WTStruct:LPWaterTileStruct<br /><br />  LOCAL Counter:DWORD<br /><br />  xor eax, eax;<br />  mov Counter, eax;<br />  AniLoop:<br /><br />     inc Counter;<br />     invoke ProcessWater, WTStruct;<br />     invoke MakeFrame, WTStruct;<br />     invoke PaintWaterTile, WTStruct;<br />     invoke Sleep, SLEEP_TICKS;<br />     mov ecx, Counter;<br />     cmp ecx, NUM_FRAMES<br />     <br /> jl AniLoop<br /><br />  ret<br /><br />AnimationLoop endp<br /><br />;################################################################################################<br /><br />ProcessWater proc WTStruct:LPWaterTileStruct<br /><br />    LOCAL i:DWORD<br />    LOCAL j:DWORD<br />    LOCAL YCounter:DWORD<br />    LOCAL LoopLim:DWORD<br />    LOCAL StPt:DWORD<br />    LOCAL TempInt:DWORD<br /><br />    mov eax, 2;<br />    mov StPt, eax;<br /><br />    mov eax, TILE_SIZE;<br />    sub eax, 2;<br />    mov LoopLim, eax;<br /><br />	fld INVERSE;           // For later when we divide by 6...<br />	mov esi, WTStruct;<br />	mov edi, WTStruct;<br />	mov esi, ;   // Now esi and edi point to <br />	mov edi, ;<br /><br />      mov eax, TILE_SIZE;<br />      shl eax, 1;<br />      lea edi, ;<br />		<br />	mov ecx, StPt;<br />	mov YCounter, ecx;<br />	<br />	YLoop:<br />		mov ecx, 2;<br />		XLoop:<br /><br />	      lea edx, ;<br />		movsx eax, byte ptr ;         // i,j-2<br /><br />		lea edx, ;<br />		movsx ebx, byte ptr ;    // i-1,j-1<br />		add eax, ebx;<br />		movsx ebx, byte ptr ;         // i,j-1<br />		add eax, ebx;<br />		movsx ebx, byte ptr ;     // i + 1,j-1<br />		add eax, ebx;<br /><br />		lea edx, ;<br />		movsx ebx, byte ptr ;     // i-2,j<br />		add eax, ebx;<br />		movsx ebx, byte ptr ;     // i-1,j<br />		add eax, ebx;<br />		movsx ebx, byte ptr ;     // i+1,j<br />		add eax, ebx;<br />		movsx ebx, byte ptr ;     // i+2,j<br />		add eax, ebx;<br /><br />		lea edx, ;<br />		movsx ebx, byte ptr ;     // i-1,j+1<br />		add eax, ebx;<br />		movsx ebx, byte ptr ;         // i,j + 1<br />		add eax, ebx;<br />		movsx ebx, byte ptr ;     // i + 1,j + 1<br />		add eax, ebx;<br /><br />		lea edx, ;<br />		movsx ebx, byte ptr ;         // i,j + 2<br />		add eax, ebx;<br /><br />		mov TempInt, eax;			     We need to integer divide by 6, but its quicker to <br />		fild TempInt;                      do a floating point multiplication by 1/6....<br /><br />		fmul st(0), st(1);<br />		fistp TempInt;<br /><br />		mov eax, TempInt;<br /><br />		movsx ebx, byte ptr ;<br />		sub eax, ebx;<br />	<br />		mov ebx, eax;<br />		shr eax, 4;<br />		sub ebx, eax;<br /><br />		cmp ebx, 2;<br />		jge MakeZero;<br />		xor ebx, ebx;<br /><br />		MakeZero:<br />		mov byte ptr , bl;   // Nasty partial-register stall?<br /><br />		inc ecx;<br />		cmp ecx, LoopLim ;<br />	jb XLoop;<br /><br />	add edi, TILE_SIZE;<br />	add esi, TILE_SIZE;<br /><br />	mov ecx, YCounter;<br />	inc ecx;<br />	mov YCounter, ecx;<br />	cmp ecx, LoopLim;<br /><br />   jb YLoop;<br /><br />   fstp TempInt;          get our float off the stack<br />   invoke Sleep, NULL;    Surrender control to a sibling thread<br />   ret<br />   <br />ProcessWater endp<br /><br />;################################################################################################<br /><br />MakeFrame proc WTStruct:LPWaterTileStruct<br /><br />   LOCAL CapBits:DWORD      <br />   LOCAL WatBits:DWORD   <br />   LOCAL YCounter:DWORD <br />   LOCAL Count:DWORD <br />       <br /><br />   xor eax, eax;<br />   mov YCounter, eax;<br />   mov Count, eax;<br />            <br />   mov ebx, WTStruct;<br /><br />   mov eax, ;<br />   mov CapBits, eax;<br />   mov eax, ;<br />   mov WatBits, eax;<br /><br />   mov eax, WTStruct;<br />   mov esi, ;   Make edi and esi point to<br />   mov edi, ;   the two watermasks<br /><br />   mov , edi;   Now switch them around to<br />   mov , esi;   make the animation happen<br /><br />   mov eax, edi;          switch them again to make it <br />   mov edi, esi;          consistant with ProcessWater<br />   mov esi, eax;          <br /><br />   mov YCounter, 0;<br />   YLoop:<br />   <br />     xor ecx, ecx;<br />     XLoop:<br />        mov eax, ecx;<br />	  mov edx, Count;<br />	  test ecx, ecx;<br />				<br />	  jz  short NoX;<br />        cmp ecx, TILE_SMIN;<br />	  jnb short NoX;<br /><br />	  movsx edi, byte ptr ;<br />	  movsx ebx, byte ptr ;<br />					<br />	  sub ebx, edi;<br />	  add eax, ebx;<br /><br />    	  NoX:<br />		mov ebx, YCounter;<br />		test ebx, ebx;<br />       	jz  short NoY;<br />	         cmp ebx, TILE_SMIN;<br />		jnb short NoY;<br />  		movsx edx, byte ptr ;<br />		movsx edi, byte ptr ;<br />									<br />		sub edi, edx;<br />		add ebx, edx;<br /><br />		NoY:<br /><br />  		test eax, eax;           unless xoff and edi are greater than 0, put 0 in them<br />		jns short NoChangeX;<br />		xor eax, eax;<br /><br />		NoChangeX:<br />				<br />		test ebx, ebx;<br />		jns short NoChangeY<br />		xor ebx, ebx;<br />		NoChangeY:<br /><br />		mov edx, TILE_SMIN;      if xoff and ebx are &gt; than TILE_SIZE, put TILE_SMIN in them<br /><br />		cmp eax, edx;<br />		jng short NoLimX;<br />		mov eax, edx;<br />		NoLimX:<br /><br /><br />		cmp ebx, edx;<br />		jng short NoLimY;<br />		mov ebx, edx;<br />		NoLimY:<br />		<br />		inc edx;                 get some RGB values, ebx is in ebx, TILE_SIZE in edx....<br />		shl ebx, 2;<br />		imul edx, ebx;<br />		lea eax, ;<br />		mov edx, Count;<br />		add eax, CapBits;<br /><br />		movsx edx, byte ptr ;<br /><br />		movzx ebx, byte ptr ;<br />		add ebx, edx;<br />		cmp ebx, 255;<br />		jnge short NoRLim;<br />		mov ebx, 255;<br />		NoRLim:			<br />		mov edi, ebx;<br /><br />		movzx ebx, byte ptr ;<br />		add ebx, edx;<br />		cmp ebx, 255;<br />		jnge short NoGLim;<br />		mov ebx, 255;<br /><br />		NoGLim:			<br />		shl ebx, 8;<br />		or edi, ebx;<br />		movzx ebx, byte ptr ;<br />		add ebx, edx;<br />		cmp ebx, 255;<br />		jnge short NoBLim;<br />		mov ebx, 255;<br /><br />		NoBLim:			<br />		shl ebx, 16;<br />		or edi, ebx;<br />		mov eax, Count;<br />		mov edx, WatBits;<br />		mov , edi;<br /><br />		inc Count;<br />		inc ecx;<br />		cmp ecx, TILE_SIZE ;<br /><br />	jb XLoop;<br />			<br />	mov ecx, YCounter;<br />	inc ecx;<br />	mov YCounter, ecx;<br />	cmp ecx, TILE_SIZE;<br /><br />   jb YLoop;<br /><br />   invoke Sleep, NULL;<br />   ret<br />   <br />MakeFrame endp<br /><br />;################################################################################################<br /><br />PaintWaterTile proc WTStruct:LPWaterTileStruct<br />    LOCAL ScreenDC:HDC<br />    LOCAL BitmapDC:HDC<br />    LOCAL pOldBitmap:HGDIOBJ<br />    LOCAL BitmapBits:LPVOID <br />    LOCAL Counter:DWORD<br /><br />      <br />    invoke CreateCompatibleDC, NULL;                Create a Memory DC<br />    mov BitmapDC, eax;<br />  <br />    invoke GetDC, NULL;                             Get a Hardware DC for our screen...<br />    mov ScreenDC, eax;<br />  <br />        <br />    ; Select the bitmap into our memory DC<br />    mov edx, WTStruct<br />    mov edx, ;<br />      <br />    invoke SelectObject, BitmapDC, edx;             Select the capture bitmap into the memory DC<br />    mov pOldBitmap, eax;<br /><br /><br />    mov edx, WTStruct<br />    mov eax, ;<br />    mov ebx, ;<br /><br />    ;Blit our watered bitmap onto the screenDC...<br /><br />    invoke BitBlt, ScreenDC ,eax ,ebx ,TILE_SIZE ,TILE_SIZE ,BitmapDC ,0 ,0 ,SRCCOPY;<br />       <br />    ; Now clean up our GDI stuff....<br />  <br />    invoke SelectObject, BitmapDC, pOldBitmap;     Select the bitmap out of its DC<br />      <br />    invoke DeleteDC, BitmapDC;                     Delete the DCs....<br />    invoke ReleaseDC, NULL, ScreenDC;<br />    <br />    invoke Sleep, NULL;                            Surrender control to a sibling thread<br />    ret<br />    <br />PaintWaterTile endp<br /><br />;################################################################################################<br /><br />DestroyObjects proc WTStruct:LPWaterTileStruct<br /><br />   mov edx, WTStruct;<br />   mov edx, ;<br />   invoke DeleteObject, edx; <br />   <br />   mov edx, WTStruct;<br />   mov edx, ;<br />   invoke DeleteObject, edx; <br /><br />   mov edx, WTStruct;<br />   mov edx, ;<br />   invoke GlobalFree, edx;<br /><br />   mov edx, WTStruct;<br />   mov edx, ;<br />   invoke GlobalFree, edx;<br /><br />   mov edx, WTStruct;          Set the IsInUse member to FALSE<br />   xor eax, eax;<br />   mov , eax;<br />  <br />   ret<br />DestroyObjects endp<br /><br />;################################################################################################<br /><br />FillWTStruct proc WTStruct:LPWaterTileStruct, OffSetX:DWORD, OffSetY:DWORD, DropDepth:DWORD<br /><br />    mov edx, WTStruct;<br />    mov eax, 1;<br />    mov , eax;            Set the IsInUse member to TRUE<br /><br />    mov eax, DropDepth;        Set the Drop Depth<br />    mov ,  eax;<br /><br />    mov eax, OffSetX;          Set the X OffSet<br />    mov ,  eax;<br /><br />    mov eax, OffSetY;          Set the Y Offset<br />    mov , eax;<br />    <br />    ret<br /><br />FillWTStruct endp <br /><br />;################################################################################################<br /><br />SetupBitmapInfoStruct proc BIH:PBITMAPINFO, PicWidth:DWORD, PicHeight:DWORD<br /><br />    mov edx, BIH;<br /><br />    mov ebx, SIZEOF BITMAPINFOHEADER;<br />    mov , ebx; <br /><br />    mov ebx, PicWidth; <br />    mov , ebx; <br />    mov ebx, PicHeight; <br />    mov , ebx; <br />     <br />    mov bx, 1; <br />    mov , bx; <br /><br />    mov bx, 32;<br />    mov , bx;<br /> <br />    ret<br /><br />SetupBitmapInfoStruct endp <br /><br />;################################################################################################<br /><br />TRand proc Range:DWORD     ; I got the integer part of this from the C++ libs.  This function <br />                           ; returns an integer between 0 and Range instead of 0 and RAND_MAX<br />    LOCAL TempInt:DWORD<br />    LOCAL RMax:DWORD<br /><br />    mov eax, TRAND_MAX;<br />    mov RMax, eax;<br />      <br />    mov  eax, seed;<br />    imul eax, eax,343FDh;<br />    add  eax, 269EC3h;<br />    mov  seed,eax;<br />    sar  eax,10h;<br />    and  eax,7FFFh;<br /><br />    mov TempInt, eax;<br /><br />    fild TempInt;<br />    fild RMax;<br />    fdivp st(1), st(0);<br />    fild Range;<br />    fmulp st(1), st(0);<br />    fistp TempInt; <br /> <br />    mov eax, TempInt;<br />    ret<br />    <br />TRand endp<br /><br />;################################################################################################<br /><br />end WaterTiles</div>
    <div class="meta">Posted on 2002-01-19 03:07:00 by ViaX</div>
   </div>
  </div>
 </body>
</html>