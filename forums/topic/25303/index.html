<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>how to create dynamic array of strings - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25303" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25303">how to create dynamic array of strings</a></p>
   <div class="post" id="post-185076">
    <div class="subject"><a href="#post-185076">how to create dynamic array of strings</a></div>
    <div class="body">after great efforts i tried to write this code,but i want to convert the proc of getfiledir in a way that it stores the result in array of strings and return that string array<br />i don&#39;t know how to declare that array equiv char **arr or char *arr in win32 asm<br />i just only know declaration of array string only(LOCAL arr:BYTE).<br />as i post my vb code in http://www.asmcommunity.net/board/index.php?topic=25297.0 section that was<br />locked as due to lack of efforts by me shown.but i try hard for 2-3 days and create this code.<br /><br />plz help me for making a proc that stores result in array of strings.<br />i thing then i have 2 return that array address(right????)<br />as in this code i thing i have to use dynamic array but i don&#39;t know to declare and make.<br />plz guide me...<br />plz don&#39;t lock this topic this time,plz suggest views in dynamoc array of strings usage and declaration<br /><br />.386<br />.model flat,stdcall<br />option casemap:none<br /><br />GetFileDir Proto lpszPath:DWORD<br /><br />include windows.inc<br />include user32.inc<br />includelib user32.lib<br />include kernel32.inc<br />includelib kernel32.lib<br /><br />.data<br />&nbsp;  szMsgText db &quot;invalid file handle&quot;,0<br />&nbsp;  szMsgCap&nbsp; db &quot;Message&quot;,0 <br />&nbsp;  szPath db &quot;C:\\*.*&quot;,0<br />.code<br /><br />start:<br />&nbsp; &nbsp; &nbsp; invoke GetFileDir,addr szPath<br />&nbsp; &nbsp; &nbsp; invoke ExitProcess,NULL<br /><br />GetFileDir Proc lpszPath:DWORD<br />&nbsp; &nbsp; LOCAL hFile:HANDLE <br />&nbsp; &nbsp; LOCAL wfd:WIN32_FIND_DATA<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; invoke FindFirstFile,lpszPath,addr wfd<br />&nbsp; &nbsp; mov hFile,eax<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; .if(hFile==INVALID_HANDLE_VALUE)<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke MessageBox,NULL,addr szMsgText,addr szMsgCap,MB_OK<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; .while eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  invoke FindNextFile,hFile,addr wfd<br />&nbsp; &nbsp; &nbsp; &nbsp; .if (wfd.dwFileAttributes==FILE_ATTRIBUTE_DIRECTORY)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  invoke MessageBox,NULL,addr wfd.cFileName,addr szMsgCap,MB_OK<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif&nbsp;  <br />&nbsp; &nbsp; .endw<br />&nbsp; &nbsp;  <br />&nbsp; &nbsp;  invoke CloseHandle,hFile <br />	Ret<br />GetFileDir EndP<br /><br /><br />end start</div>
    <div class="meta">Posted on 2006-09-04 12:39:03 by sihotaamarpal</div>
   </div>
   <div class="post" id="post-185108">
    <div class="subject"><a href="#post-185108">Re: how to create dynamic array of strings</a></div>
    <div class="body">Using compilers and high level languages exclusively, such as VB, leaves you without the actual knowledge of how to program.<br /><br />Think of VB as a baker. You (the customer) stop by this baker&#39;s shop (VB) and tell him what you want made, this requires very little to no &quot;real&quot; knowledge on your behalf. It is the baker&#39;s job to understand the ingredients and baking instructions, and give you the end-result.<br /><br />Think of ASM as baking it yourself. You have to posses intimate knowledge of the ingredients (instructions) and how they achieve the end-result (the program)... otherwise, with the lack of quality, you&#39;d be out of business quickly (unless you bully every other baker out of the city and everyone is forced to come to you).<br /><br />To relate, VB knows what an array is and how to utilize memory to &quot;make&quot; the array. VB keeps track of the array size and how it is accessed in order to do error/bounds checking. VB does EVERYTHING for you short of expressing your own desires.<br /><br />On the other hand, ASM requires you to allocate a section of memory and you apply whatever concept is needed to that section of memory. In this case, you wish to apply the concept of an &quot;array&quot; to a fixed chunk of memory. This requires you to create the logic that accesses this portion of memory in the manner you desire (your &quot;array&quot;). You are also required to exercise size/error/bounds checking yourself.<br /><br />You have to read some more and start digging deeper, because after two years you are *still* thinking like &quot;the customer&quot; and not &quot;the baker&quot;.<br /><br />To help you on your way, I will give you some advice on how to make an array from fixed chunk of memory. First, you need to decide what length your array is going to be (more complex concepts involve resizing, but let&#39;s stick to the basics), and allocate that amount of memory. Second, you need to decide how your array is going to be segmented. If we are talking a fixed amount of data, say an array of 4 byte values... then you have very little to worry about. For such an array, you just need to increment the memory pointer on a scale of 4 bytes.<br /><br /><pre><code><br />;Basic concept of &quot;long MyArray[16]&quot; - NASM Style Syntax<br />mov ebx,DWORD MyArray ;Address of &quot;MyArray&quot; in memory, ebx becomes the pointer<br />mov eax,DWORD ;Access the first 4-byte value (long MyArray[0])<br />add ebx,4 ;Move the array pointer to the next 4-byte value<br />mov eax,DWORD ;Access the second 4-byte value (long MyArray[1])<br />mov eax,DWORD; Access the third 4-byte value (long MyArray[2])<br /></code></pre><br /><br />As you can see from the above code, there is more than one way to access memory using pointers. You could also &quot;scale&quot; in order to directly access a single value. Things like that, and variable-sized arrays (which would require a &quot;linked-list&quot;), are pushing into more intermediate assembly language topics. I can tell you that your &quot;array of strings&quot; concept is much more complex than VB allows you to realize, and it will require a linked-list of arrays if you plan on doing anything equivalent in Assembly Language.<br /><br />So, even something this simple in VB might be too complex for someone still learning basic Assembly Language concepts. For someone in your position, sihotaamarpal, I might suggest that you start thoroughly learning C programming concepts before trying to drop straight into ASM... it would help you greatly coming from a VB background.<br /><br />People only tend to help you here, if you help yourself... so please start doing so.</div>
    <div class="meta">Posted on 2006-09-04 22:57:32 by SpooK</div>
   </div>
   <div class="post" id="post-185109">
    <div class="subject"><a href="#post-185109">Re: how to create dynamic array of strings</a></div>
    <div class="body">thks spook,now i tried myself of translation of link -list of c in asm</div>
    <div class="meta">Posted on 2006-09-05 00:38:50 by sihotaamarpal</div>
   </div>
   <div class="post" id="post-185112">
    <div class="subject"><a href="#post-185112">Re: how to create dynamic array of strings</a></div>
    <div class="body">You don&#39;t actually <strong>need</strong> a linked list unless you wish for the array to be resizable. If you know you won&#39;t have any more than, for example 256 strings in your array, then you could allocate a (256*4) section of memory. Then for each string, allocate enough room for a string then store the address to that section of memory into your 256*4 chunk. This is an &quot;Array of Arrays&quot; and is actually fiarly easy to do. Check out the sample code below. I&#39;ve not done any actual work for you, this just kinda shows what you might want to try and do (point you in the right direction) because I too think you should possibly try a little harder.<br /><br /><pre><code>MALLOC	MACRO	Size:REQ<br />	INVOKE	HeapAlloc, process_heap, HEAP_ZERO_MEMORY, Size<br />ENDM<br /><br />FREE	MACRO	pMem:REQ<br />	INVOKE	HeapFree, process_heap, 0, pMem<br />ENDM<br /><br />.data<br />process_heap	DWORD 0<br /><br />.code<br />InitArray PROC<br />	INVOKE	GetProcessHeap<br />	mov	process_heap, EAX<br />	MALLOC	( 256 * 4 )	; 256 string pointers<br />	ret<br />InitArray ENDP<br /><br />ClearArray PROC	pArray:DWORD<br />	FREE	pArray<br />	ret<br />ClearArray ENDP<br /><br />....<br /><br />; Pointer to our strings<br />LOCAL	pStrings:DWORD<br />LOCAL	dIndex:DWORD<br />....<br />	INVOKE	InitArray<br />	mov	pStrings, EAX<br /><br />...<br />	; storing a string into the array<br />	INVOKE	lstrlen, ADDR wfd.cFileName<br />	inc	EAX<br />	MALLOC	EAX<br />	mov	EDI, pStrings<br />	mov	ECX, dIndex<br />	mov	, EAX<br />	INVOKE	lstrcpy, EAX, ADDR wfd.cFileName<br />	inc	dIndex<br />...<br />	; somewhere down the line you need to cleanup all your strings<br />	; then you can clean up the array which contains the addresses<br />	; of the strings<br />	INVOKE	ClearArray, pStrings<br />...</code></pre><br /><br />You will also need to preform bounds checking, (ie make sure you haven&#39;t inserted too many pointers into the array). That&#39;s the plus side to using Linked Lists instead of the above method, because you allocate room for each entry as you insert them. That way you can add as many entries as memory allows.<br /><br />In the future, please try to put forth more effort like SpooK said. You have grown a bit of a habbit over the last two years of trying to get spoon fed source code (ie &quot;I have this, translate it for me&quot;) and it really doesn&#39;t seem like you are trying much yourself. This issue, I don&#39;t mind so much because I hear novices complain about arrays all the time, but it would probably have done some good to search the board. IIRC there is even a macro set somewhere on the board (I think it was designed by Biterider) to make it easier, because it was such an issue.<br /><br />Regards,<br />Bryant Keller<br /></div>
    <div class="meta">Posted on 2006-09-05 01:01:50 by Synfire</div>
   </div>
   <div class="post" id="post-185114">
    <div class="subject"><a href="#post-185114">Re: how to create dynamic array of strings</a></div>
    <div class="body">Thanks for clearing that up Synfire. I was trying to give sihotaamarpal the most basic of arrays... one that really doesn&#39;t even qualify as an array in these high-level terms (technically my example would just be a fixed-length/size structure). Too much OS development gets to my head :P<br /><br />He does indeed need to know that arrays are (typically) linear lists of pointers to other objects in memory. So, ultimately, sihotaamarpal... I think you should study how Structures are held in memory (i.e. my example from above). Once you understand the basics of how to create/manipulate a Structure, you can move into studying Arrays. You will soon realize that the actual Array itself is just a structure of memory pointers that reference other objects in memory. In the end, you will learn that Structures and Arrays are just ways to efficiently organize and sort large amounts of data in a uniform manner.<br /><br />Good luck ;)</div>
    <div class="meta">Posted on 2006-09-05 01:46:09 by SpooK</div>
   </div>
   <div class="post" id="post-185156">
    <div class="subject"><a href="#post-185156">Re: how to create dynamic array of strings</a></div>
    <div class="body">thks Synfire&nbsp; :) and Spook&nbsp; 8) too also</div>
    <div class="meta">Posted on 2006-09-06 05:39:28 by sihotaamarpal</div>
   </div>
  </div>
 </body>
</html>