<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>ADC and ASCII Operation AAA ... help please - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=12760" />
    <link rel="next" href="../?id=12760&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=12760">ADC and ASCII Operation AAA ... help please</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=12760&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=12760&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="12760" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=12760&amp;page=2">&gt;</a><a href="../?id=12760&amp;page=2">&raquo;</a></form>   <div class="post" id="post-98763">
    <div class="subject"><a href="#post-98763">ADC and ASCII Operation AAA ... help please</a></div>
    <div class="body">Ok... next question. :grin: <br /><br />Now I've split 2 floating point numbers (strings) into two parts, whole and decimal.<br /><br />So if the user enters: '123.999' and '1.111'<br /><br /><br />FPVal_W1 is '123' and FPVal_D1 is '999'<br />FPVal_W2 is '1__' and FPVal_D2 is '111'<br /><br /><br />So I add like this:<br /><br />123.999<br />001.1<br /><br /><br />Now, I'm having some trouble adding the carry from the addition of ( FPVal_D1 + FPVal_D2 ) to FPVal_W1 like in a normal arithmitec problem...<br /><br />Here is what I got so far:<br /><br /><div class="quote"><br />.data<br /><br />FPSum_W1 BYTE 60 dup ('#'),0<br />FPSum_D1 BYTE 60 dup ('#'),0<br /><br />.<br />.<br />.<br />.<br /><br />.code<br />.<br />.<br />.<br />Addition1:<br />        	<br />       		setPointer   esi,FPVal_D1                   ;points esi to last digit in FPVal_D1<br />       		setPointer   edi,FPVal_D2                   ;points edi to last digit in FPVal_D2<br />		setPointer   ebx,FPSum_D1                ;points ebx to last space in FPSum_D1<br />		<br />		dec ebx<br />		<br />		mov   ecx, lengthof FPVal_D1<br />		clc     <br /><br />		L1:<br />			mov al, <br />			adc al, <br /><br />			aaa<br /><br />			pushf<br /><br />			add al, 30h<br />			mov , al<br /><br />			dec esi<br />			dec edi<br />			dec ebx<br /><br />			popf<br /><br />		loop L1<br />	<br />		setPointer   esi,FPVal_W1<br />				<br />		jnc Addition2<br /><br />		carry_over:<br />			mov al, '1'<br />			add al, <br />			<br />			aaa<br />			<br />			pushf<br />			<br />			add al, 30h<br />			mov , al<br />			<br />			popf<br />			<br />	Addition2:<br />	<br />		<br />		setPointer   esi,FPVal_W1<br />		setPointer   edi,FPVal_W2<br />		setPointer   ebx,FPSum_W1<br />		<br />		dec ebx<br />		<br />		mov   ecx, lengthof FPVal_W1<br />		clc     <br /><br />		L2:<br />			mov al, <br />			adc al, <br /><br />			aaa<br /><br />			pushf<br /><br />			add al, 30h<br />			mov , al<br /><br />			dec esi<br />			dec edi<br />			dec ebx<br /><br />			popf<br /><br />		loop L2<br />		<br />		<br />		jnc Print<br /><br />		mov byte ptr , '1'<br /></div><br /><br />I wanna say in advance thanks to anyone who takes their time to look at my code and help me out, :)<br /><br />:) :) :) :) :)</div>
    <div class="meta">Posted on 2003-04-23 00:52:00 by locke</div>
   </div>
   <div class="post" id="post-98779">
    <div class="subject"><a href="#post-98779">ASCII Operation AAA</a></div>
    <div class="body">I know you are probably wanting to do this the hard way, but.... did you know that there is a StrToFloat function in masm32.lib? You could convert both your strings to floats, then put them on the fpu and let it do the addition for you.</div>
    <div class="meta">Posted on 2003-04-23 03:03:22 by sluggy</div>
   </div>
   <div class="post" id="post-98782">
    <div class="subject"><a href="#post-98782">ASCII Operation AAA</a></div>
    <div class="body">His project requires him to use the Ascii commands ;-)<br /><br /><br />IIRC AAA will convert the byte in AL into two decimal digits in AH and AL... can't be sure though.</div>
    <div class="meta">Posted on 2003-04-23 03:36:10 by AmkG</div>
   </div>
   <div class="post" id="post-98789">
    <div class="subject"><a href="#post-98789">ASCII Operation AAA</a></div>
    <div class="body">I think you need to use FPU for the code. Not too sure anyway since I do not use much of FPU.</div>
    <div class="meta">Posted on 2003-04-23 04:01:12 by roticv</div>
   </div>
   <div class="post" id="post-98912">
    <div class="subject"><a href="#post-98912">ASCII Operation AAA</a></div>
    <div class="body">locke<br /><br />There are several ways to learn something new. One of them is to read on the subject. Sometimes, the information is not sufficient nor too clear. By trial and error, you may be able to figure out what the text was trying to explain. Whatever you can learn that way will be remembered for a long time, and possibly apply to other situations, thus making your learning curve much steeper if you have the capabilities to absorb it.<br /><br />I would strongly suggest that you get a debugger and see for yourself what happens to the registers (including the flag register) under various scenarios of input with the instructions that are not familiar to you.<br /><br />Another way of learning is to expect to be &quot;spoon-fed&quot;. You won't really learn much that way unless responders go to extremes to explain all the details of their reasonning. And, even then, each programmer has his/her own style which may not suit yours.<br /><br />For your current assignment, forget the FPU because you have to learn the usage of operations with packed/unpacked decimals. It may come handy to you some day. <br /><br />The very first part of your assignment will be to learn what those operations require as input. Only then can you proceed further.<br /><br />Raymond</div>
    <div class="meta">Posted on 2003-04-23 15:34:46 by Raymond</div>
   </div>
   <div class="post" id="post-98951">
    <div class="subject"><a href="#post-98951">ASCII Operation AAA</a></div>
    <div class="body">I've already read about Unpacked BCD, Packed BCD, and ASCII numbers.  My debugger (VC++) isn't working for whatever reason... and I don't wanna deal w/ uninstalling and reinstalling it.... just wanted to see if anyone could see a real obvious mistake I might have made w/ my code or not. And no I don't want to deal w/ the FPU, cause thats not what I'm doing right now. THis whole project is to learn about ASCII OPERATIONS AAA, AAS ... and yes I know what they do.  I've just had some problem w/ formating the strings (padding), now that I got that right (thanks Raymond :) ), I'm just trying to finish this proj up. <br /><br />Jumping from C++ to Asm, I've learned a lot about major concepts of coding, which hopefully I can translate to whatever language. <br /><br />Thanks again everyone for the help.</div>
    <div class="meta">Posted on 2003-04-23 21:38:41 by locke</div>
   </div>
   <div class="post" id="post-98954">
    <div class="subject"><a href="#post-98954">ASCII Operation AAA</a></div>
    <div class="body">I don't know what you have read about BCDs (and I won't assume anything), but it appears that you have not learned that they are <strong>not</strong> ASCII. The AAA, AAD, etc. do  <strong>not</strong> operate on ASCII characters but on <strong>binary numbers</strong>.<br /><br />Therefore, you have to convert your ASCII characters to binary numbers before you do any of the maths, and then convert the binary answer back to ASCII for display.<br /><br />Have fun<br /><br />Raymond</div>
    <div class="meta">Posted on 2003-04-23 21:59:23 by Raymond</div>
   </div>
   <div class="post" id="post-98961">
    <div class="subject"><a href="#post-98961">ASCII Operation AAA</a></div>
    <div class="body">Forgot to mention one trick for your assignment.<br /><br />After you make both numbers the same length (integers and decimals), join the integer digits and decimal digits together for each of the numbers (simulating a multiplication by a factor of 10 to eliminate the decimals. Then do the addition and reposition your decimal point in the answer for display (simulating a division by the same factor of 10).<br /><br />Have more fun<br /><br />Raymond</div>
    <div class="meta">Posted on 2003-04-23 22:18:15 by Raymond</div>
   </div>
   <div class="post" id="post-99097">
    <div class="subject"><a href="#post-99097">ASCII Operation AAA</a></div>
    <div class="body">This is straight outta my book (Assembly Language For Intel Based Computers):<br /><br />&quot;The CPU calculates in binary, but it is also possible to perform arithmetic on ASCII decimal strings.&quot;<br /><br />&quot;Suppose that we would like to input two numbers from the user and add them together. The following is a sample of the program's output, in which the user has input 3402 and 1256:<br /><br />Enter first number:              3402<br />Enter second number:         1256<br />The sum is:                          4658          &quot;<br /><br />&quot;We have two options when calculating and displaying the sum:<br /><br />1. Convert both operands to binary (what you said Raymond), add the binary values, and convert the sum from binary to ASCII strings.<br /><br />2. Add the digits strings directly by successively adding each pair of ASCII digits (2+6, 0+5, 4+2, 3+1). The sum is an ASCII digit, so it can be directly displayed on the screen   &quot;<br /><br />&quot;The second option requires specialized instructions that adjust the sum after adding each pair of ASCII digits. The instruction set has four instructions that deal with ASCII addition, subtraction, multiplication, and division: AAA, AAS, AAM and AAD.&quot;<br /><br />&quot;When executing ASCII addition and subtraction, operand s can be in either ASCII format or in unpacked decimal format. Only unpacked decimal numbers can be used for multiplication and division.&quot;<br /><br />&quot;AAA (ASCII adjust after addition) and AAS adjust the binary result of and ADD or ADC instruction. IT makes the result in AL consisten with ASCII digit representation.&quot;<br /><br />Here is the example they give:<br /><br />mov ah, 0     <br />mov al, '8'         ; AX = 0038h<br />add al, '2'         ; AX = 006Ah<br />aaa                  ; AX = 0100h<br />or ax, 3030h    ; AX = 3130h = '10'<br /><br />and basically thats what I'm doing...</div>
    <div class="meta">Posted on 2003-04-24 13:39:52 by locke</div>
   </div>
   <div class="post" id="post-99198">
    <div class="subject"><a href="#post-99198">ASCII Operation AAA</a></div>
    <div class="body"><div class="quote">or ax, 3030h ; AX = 3130h = '10'</div> One minor observation. If you store that AX value as a word and try to display it as a string, it would come out as '01'!<br /><br />More food for thought since you are showing a very sincere interest in learning.<br /><br />This may not be a specified part of your current assignment, but it's never too early to review the subject. A good program <strong>never</strong> assumes that the user will always provide valid input. For a program to return valid results, code must be added to verify the validity of the input and provide some additional code to handle invalid and/or problematic input.<br /><br />The following are some examples of input which could be entered by the user:<br /><br /><strong>123.45</strong> ;the obvious valid input which you currently expect<br /><strong> 123.5</strong> ;mathematically valid with one or more leading (or trailing) spaces but could insert needless 0's in your output.<br /><strong>+12.4567</strong> ;mathematically valid but the + sign would be treated as a value of 11 if not removed.<br /><strong>-5.789</strong> ;also mathematically valid but you would have to transfer control to a subtraction procedure unless both numbers were negative. In the latter case, you would need to remove the - signs before adding and later reinsert it in the output.<br /><strong>765</strong> ;mathematically valid but without any decimal point or digits.<br /><strong>84.K/L</strong> ;obviously invalid.<br /><strong>12.56.98</strong> ;also obviously invalid with more than 1 decimal point.<br /><br />You could also imagine a few more unusual kinds of input. Not to mention the  absence of input.<br /><br />Sounds like more fun<br /><br />And, as the saying goes, there are more than one way to skin a cat. As algorithms go, there are innumerable ways to achieve the desired result in assembler. After you have verified the input and lined it up, you could also look at the following:<br /><br />EDI pointing to the terminating 0 of the1st string<br />ESI pointing to the terminating 0 of the 2nd string<br />EBX pointing to the end of the buffer where you store the result<br />ECX containing the sum of integer and decimal digits to be added<br /><pre><code>  mov byte ptr &#91;ebx&#93;,0 ;store the terminating 0<br />  clc<br />  lahf        ;keep the flags in AH, starting with NO carry<br />toploop&#58;<br />  dec edi<br />  dec esi<br />  dec ebx<br />  mov al,&#91;edi&#93;<br />  cmp al,&quot;.&quot;<br />  jz @F       ;store the decimal point in result<br />  sahf        ;recover the flags &#40;primarily the carry flag&#41;<br />  adc al,&#91;esi&#93; ;adds the two digits + any carryover<br />  aaa<br />  lahf        ;keep the latest carry flag in AH<br />  add al,30h<br />@@&#58;<br />  mov &#91;ebx&#93;,al<br />  dec ecx<br />  jnz toploop<br /><br />  sahf<br />  jnc @F     ;jump if last addition had no carry<br />  dec ebx<br />  mov byte ptr &#91;ebx&#93;,&quot;1&quot;<br />@@&#58;<br /><br />;if you have to insert a &quot;-&quot; sign, you would now need the following 2 lines<br /><br />  dec ebx<br />  mov byte ptr &#91;ebx&#93;,&quot;-&quot;<br /><br />;EBX now points to the first character of the null-terminated result string.</code></pre>You can be sure that every programmer would come up with something different to arrive at the same result.<br /><br />Raymond</div>
    <div class="meta">Posted on 2003-04-24 20:05:50 by Raymond</div>
   </div>
   <div class="post" id="post-99250">
    <div class="subject"><a href="#post-99250">ASCII Operation AAA</a></div>
    <div class="body">Raymond... my program as it is, already seperates a floating point number into two parts, than padds it if neccessary.  If a user enters '123.999' and '1.111' it seperates and padds like this:<br /><br />FPVal_W1 holds -&gt; '123'<br />FPVal_W2 holds -&gt; '001'<br /><br />FPVal_D1 holds -&gt; '999'<br />FPVal_D2 holds -&gt; '111'<br /><br />But my problem is...  I can't get it to add the carry from adding '999' and '111' to '123'.<br /><br /><br />After I get this case done, I'm going to add later code to check for signs (+/-) and other invalid input. But right now, I have to do this first.<br /><br />Here is my entire code so far (kinda long):<br /><br /><div class="quote"><br /><br />;===============================================<br /><br />INCLUDE Irvine32.inc<br /><br />includelib KERNEL32.lib<br />includelib USER32.lib<br /><br /><br /><br />wsprintfA PROTO C :DWORD,:DWORD,:VARARG<br />wsprintf equ &lt;wsprintfA&gt;<br /><br />.data<br /><br />	str1 BYTE &quot;Assignment4: Addition of two Floating Point Numbers &quot;,0Ah, 0Dh,0 	<br />	str2 BYTE &quot;Enter your name: &quot;,0<br />	str3 BYTE &quot;Please enter two Floating Point Numbers, &quot;,0<br />	str4 BYTE &quot;Enter first Floating Point Number: &quot;,0<br />	str5 BYTE &quot;Enter second Floating Point Number: &quot;,0<br />	str6 BYTE &quot;.&quot;,0<br />	str7 BYTE &quot;The sum is: &quot;,0<br />		<br />	buffer BYTE 50 dup (0), 0<br />	<br />	FPVal1 BYTE 50 dup ('0'),0<br />	FPVal2 BYTE 50 dup ('0'),0<br />	<br />	FPVal_W1 BYTE 50 dup ('0'),0<br />	FPVal_D1 BYTE 50 dup ('0'),0<br />	<br />	FPVal_W2 BYTE 50 dup ('0'),0<br />	FPVal_D2 BYTE 50 dup ('0'),0<br />		<br />	FPSum_W1 BYTE 51 dup ('0'),0<br />	FPSum_D1 BYTE 51 dup ('0'),0<br />	<br />	setPointer MACRO reg, var		; Macro to set pointer<br />		lea reg, var			; Load Effective Address of register 	<br />		add reg, lengthof var		; Move pointer to end of string<br />		dec reg				; Move back one	<br />	ENDM					; End of Macro definition<br />	<br />	EnterString MACRO FP_Buffer		; Readstring Macro<br />		lea edx, FP_Buffer		; Load Effective Address of FP_Buffer<br />		mov ecx, (SIZEOF FP_Buffer) - 1	; Maximum number of characters <br />		call Readstring			; Call Readstring function<br />	ENDM<br />		<br />	<br />.code<br />	<br />main PROC<br /><br />	mov eax, lightGreen + (black * 16)	;light green text on black background<br />	call SetTextColor<br />	call Clrscr<br />	<br />	lea edx, str1			; load effective address str1<br />	call WriteString		; &quot;Assignment4: Addition of two Floating Point Numbers&quot;<br />	call Crlf			; end line<br /><br />	call WaitMsg			; &quot;Press...&quot;<br />		<br />	lea edx, str2			; load effective offset str2<br />	call WriteString		; &quot;Enter your name: &quot;<br />	<br />	lea edx, buffer			; load effective address buffer<br />	mov ecx, (SIZEOF buffer) - 1	; maximum # of characters<br />        call ReadString			; read string input from user<br />        <br />	lea edx, str3			; load effective address str3<br />	call WriteString		; &quot;Please enter two Floating Point Numbers, &quot;<br />	<br />	lea edx, buffer			; load effective offset buffer<br />	call WriteString		; display user name<br />	call Crlf			; end line<br />	<br />	Again:<br />		call Crlf			; end line<br />				<br />		lea edx, str4			; load effective address str4<br />		call WriteString		; &quot;Enter first Floating Point Number: &quot;<br />		Enterstring FPVal1		; read floating point value from user<br />		call Crlf			; end line<br />	<br />		lea edx, str5			; load effective offset str5<br />		call WriteString		; &quot;Enter second Floating Point Number: &quot;<br />		Enterstring FPVal2		; read floating point value from user	<br />		call Crlf			; end line<br />	<br />	Mov_Num1:		<br />		mov     ecx, LENGTHOF FPVal1	; get length of string<br />     		lea     edi, FPVal_W1		; load effective address of FPVal_W1<br />        	lea     esi, FPVal1		; load effective address of FPVal1<br />        	cld				; clear direction flag<br />        	<br />	check_loop1:<br />        	<br />        	lodsb				; load byte from memory at ESI into AL<br />        	cmp     al, '.'			; compare to see if it is decimal point<br />        	jne     no_change_dest1		; jump if not equal to no_change_dest1<br />        	mov     byte ptr , 0	; set null terminator<br />        	lea     edi, FPVal_D1		; load effective address FPVal_D1<br />        	jmp     loop_next1		; jump to loop_next1<br />        	<br />	no_change_dest1:			<br />        	<br />        	stosb				; store content of al into memory at EDI<br />	<br />	loop_next1:<br />        	<br />        	dec     ecx			; decrement counter<br />        	jnz     check_loop1		; jump if not zero to check_loop1<br />        	xor     al, al			; clear al register<br />        	stosb				; store content of al into memory at EDI<br />                <br />        Mov_Num2:               	<br />        	mov     ecx, LENGTHOF FPVal2<br />     		lea     edi, FPVal_W2<br />        	lea     esi, FPVal2<br />        	cld<br />        	<br />	check_loop2:<br />        	<br />        	lodsb<br />        	cmp     al, '.'<br />        	jne     no_change_dest2<br />        	mov     byte ptr , 0<br />        	lea     edi, FPVal_D2<br />        	jmp     loop_next2<br />        	<br />	no_change_dest2:<br />        	<br />        	stosb<br />	<br />	loop_next2:<br />        	<br />        	dec     ecx<br />        	jnz     check_loop2<br />        	xor     al, al<br />        	stosb<br />        	<br />   <br />        	<br />              	<br />       Prepare:<br />       		<br />       		INVOKE Str_length, ADDR FPVal_W2<br />		push  eax    				; preserve that value on the stack<br />		INVOKE Str_length, ADDR FPVal_W1<br />		pop   ecx    				; retrieve W2 length<br />			<br />		std         				; do everything backwards<br />			<br />		.if ( eax &gt; ecx )    			; if (W1 &gt; W2)<br />    			lea   edi,	; <br />    			lea   esi,	; points to the terminating 0<br />    			push  ecx<br />    			inc ecx<br />    			rep   movsb      		; moves the terminating 0 and the digits<br />    				<br />    			mov   ecx,eax    		; longer string length<br />    			pop   eax        		; shorter string length<br />    			sub   ecx,eax    		; difference between the two<br />    			mov   al,'0'<br />    			rep   stosb      <br />		.elseif ( ecx &gt; eax )			; if (W2 &gt; W1)<br />			lea edi, <br />			lea esi, 		;points to the terminating 0<br />			<br />			push ecx<br />			mov ecx, eax<br />			inc ecx<br />			rep movsb			; moves the terminating 0 and the digits<br />			<br />											<br />			pop ecx				; restore original value of ecx<br />			sub ecx, eax			; difference between the two<br />			mov al,'0'<br />			rep stosb<br />		.endif       				; if both are equal, you don't change anything<br />		cld          				; clean-up the direction flag<br />		<br />		 		<br />    		        	                             	<br />        Add_Decimal_Part:<br />        	<br />       		setPointer   esi,FPVal_D1<br />       		setPointer   edi,FPVal_D2<br />		setPointer   ebx,FPSum_D1<br />		<br />		dec ebx<br />										<br />		mov   ecx, lengthof FPVal_D1<br />		clc     <br /><br />		L1:<br />			mov al, <br />			adc al, <br /><br />			aaa<br /><br />			pushf<br /><br />			add al, 30h<br />			mov , al<br /><br />			dec esi<br />			dec edi<br />			dec ebx<br /><br />			popf<br /><br />		loop L1<br />	<br />		setPointer   esi,FPVal_W1<br />		setPointer   edi,FPVal_W2<br />		setPointer   ebx,FPSum_W1<br />		<br />		dec ebx<br />				<br />		jnc Add_Whole_Part<br />			<br />		Carry_Over:<br />		<br />			mov al, <br />			adc al, '1'<br />			aaa<br />			pushf<br />			add al, 30h<br />			mov , al<br />			<br />			<br />			<br />	Add_Whole_Part:<br />	<br />		<br />		setPointer   esi,FPVal_W1<br />		setPointer   edi,FPVal_W2<br />		setPointer   ebx,FPSum_W1<br />		<br />		dec ebx<br />											<br />		mov   ecx, lengthof FPVal_W1<br />		clc     <br /><br />		L2:<br />			mov al, <br />			adc al, <br /><br />			aaa<br /><br />			pushf<br /><br />			add al, 30h<br />			mov , al<br /><br />			dec esi<br />			dec edi<br />			dec ebx<br /><br />			popf<br /><br />		loop L2<br />		<br />		<br />		jnc Remove_Extra<br /><br />		mov byte ptr , '1'<br />		<br />		<br />		<br />	comment %<br />	<br />	Subtraction:<br />	<br />		setPointer   esi,num1<br />		setPointer   edi,num2<br />		setPointer   ebx,dif<br />		<br />		dec   ebx<br /><br />		mov   ecx, lengthof num1<br />		clc     <br /><br />		L3:<br />			mov   al, <br />			sbb    al, <br />			<br />			aas<br /><br />			pushf<br /><br />			add   al, 30h<br />			mov   , al<br /><br />			dec   esi<br />			dec   edi<br />			dec   ebx<br /><br />			popf	<br />		loop L3<br />	<br />	%	<br />	<br />	Remove_Extra:<br />	<br />		;INVOKE Str_trim, ADDR FPSum_W1, '0'<br />		;INVOKE Str_trim, ADDR FPSUm_D1, '0'<br />	<br />	<br />	Print:<br />       		call Crlf<br />       		lea edx, FPVal_W1<br />		call Writestring<br />		call Crlf<br />		lea edx, FPVal_W2<br />		call Writestring<br />		call Crlf<br />		<br />		call Crlf<br />       		lea edx, FPVal_D1<br />		call Writestring<br />		call Crlf<br />		lea edx, FPVal_D2<br />		call Writestring<br />		call Crlf<br />		<br />		call Crlf<br />       		lea edx, str7<br />       		call Writestring<br />       			<br />       		lea edx, FPSum_W1<br />		call Writestring<br />		lea edx, str6<br />		call Writestring<br />		lea edx, FPSum_D1<br />		call Writestring<br />		call Crlf<br />	       	       			<br />		INVOKE ExitProcess,0			; exit program<br /><br />main ENDP<br />END main<br /><br /></div><br /><br /><br />Also when I print out the sum... I get excess zeros '0' ... like if the sum should be 259.112 its prints like: '25900000000000000000000000.1120000000000000000000000'<br /><br />I tried adding the code: mov byte ptr , 0 <br />(  pointing to the buffer where I save the sum ) right before adding... but that didn't help.</div>
    <div class="meta">Posted on 2003-04-24 23:50:24 by locke</div>
   </div>
   <div class="post" id="post-99257">
    <div class="subject"><a href="#post-99257">ASCII Operation AAA</a></div>
    <div class="body">I would recommend that you convert the numbers to a fixed point format and add fixed point numbers. I saw from your previous thread that you were having problems with it. Position the decimal place for example after the 64th digit in both 128 digit numbers (for example). This way you just need to add two numbers BCD numbers...<br /><br />so, position esi to last digit of FPVal1<br />edi to last position of FPVal2<br />ebx to target<br /><br />clc<br />L1:<br />mov al, <br />adc al, <br /><br />aaa<br /><br />pushf<br /><br />add al, 30h<br />mov , al<br /><br />dec esi<br />dec edi<br />dec ebx<br /><br />popf<br /><br />loop L1<br /><br />The carry will cross the decimal point just as it crosses everywhere else..<br /><br />If you insist on adding the whole part and decimal separately, however, forget testing for a carry from the decimal part!!!!!!<br />Just add it into the first digit of the whole part!!!!<br /><br />;(*****leave out this part because now you are altering your ;source number... Actually, what are you altering here? esi was ;defined to point to the decimal part, but now that the decimal ;addition is gone, and esi has not yet been set to point to the ;whole part, esi should be undefined!!!! So, leave out all of this<br /><br />;jnc Addition2<br /><br />;carry_over:<br />;mov al, '1'<br />;***** Next problem, you should add 1, not $31 ASCII 49('1')<br />;***** ie use mov al, 1<br />;add al, <br />;***** Plus in your latest program I see you use<br />;***** mov al, <br />;***** adc al, '1'<br />;***** this also adds $31 ASCII 49 ('1')<br />;***** but since the carry flag is set, adc adds an extra 1<br />;***** none of this matters since I have already said to omit<br />;***** this entire section that checks for the carry flag<br />;***** straingt from the {***** to *****)<br /><br /><br />;aaa<br /><br />;pushf<br /><br />;add al, 30h<br />;mov , al<br /><br />;popf<br />;*******)<br /><br />;(***** Edit this section as follows<br />;pushf ***** - should not be necessary because none of the ;following instructions affect the carry<br />Addition2:<br /><br />setPointer esi,FPVal_W1<br />setPointer edi,FPVal_W2<br />setPointer ebx,FPSum_W1<br /><br />;***** dec ebx - leave out this I think<br /><br />mov ecx, lengthof FPVal_W1<br />;***** clc - leave out the clc because you are simply using the ;carry flag from the last addition<br />;popf ***** - should not be necessary because none of the ;preceding instructions affect the carry<br />L2:<br />mov al, <br />adc al, <br /><br />aaa<br /><br />pushf<br /><br />add al, 30h<br />mov , al<br /><br />dec esi<br />dec edi<br />dec ebx<br /><br />popf<br />;*****)<br /><br /><br />Hope this helps..... I put in the brackets and stars to delineate the program... for commenting purposes...<br /><br />What this does is simply move from adding the decimals to adding the whole part. The carry flag is added in normally with adc.</div>
    <div class="meta">Posted on 2003-04-25 00:40:05 by V Coder</div>
   </div>
   <div class="post" id="post-99346">
    <div class="subject"><a href="#post-99346">ASCII Operation AAA</a></div>
    <div class="body">As V Coder explained, go directly from adding the decimals to adding the integers.<br /><br />HOWEVER, as you exit Loop1, you must save the flags because the carry flag will be affected by your setPointer macro instructions. You then retrieve the flags just before entering the L2 loop.<br /><br />Raymond</div>
    <div class="meta">Posted on 2003-04-25 08:57:29 by Raymond</div>
   </div>
   <div class="post" id="post-99410">
    <div class="subject"><a href="#post-99410">ASCII Operation AAA</a></div>
    <div class="body">Did as you said V_Coder and Raymond, but didn't work... hmmmm<br /><br />Actually it kinda works, but the other problem comes up(excess zeros '0') which I don't know where it comes form.<br /><br />When I added: '123.999' and '1.111'<br /><br />123<br />001<br /><br />999<br />111<br /><br /><br />I got the sum as: '124000000000000000000000000000000000000001' . '1100000000000000000000000000000000000000'<br /><br />so instead of adding the carry from '999' and '111' to the '124', it added it to the excess zeros... <br /><br />Any ideas? :confused:<br /><br /><br /><br />here is the code:<br /><br /><div class="quote"><br /><br />Addition1:<br />        	<br />       		setPointer   esi,FPVal_D1<br />       		setPointer   edi,FPVal_D2<br />		setPointer   ebx,FPSum_D1<br />		<br />		dec ebx<br />										<br />		mov   ecx, lengthof FPVal_D1<br />		clc     <br /><br />		L1:<br />			mov al, <br />			adc al, <br /><br />			aaa<br /><br />			pushf<br /><br />			add al, 30h<br />			mov , al<br /><br />			dec esi<br />			dec edi<br />			dec ebx<br /><br />			popf<br /><br />		loop L1<br />		<br />		pushf<br />			<br />	Addition2:<br />			<br />		setPointer   esi,FPVal_W1<br />		setPointer   edi,FPVal_W2<br />		setPointer   ebx,FPSum_W1<br />		<br />		;dec ebx<br />											<br />		mov   ecx, lengthof FPVal_W1<br />		<br />		popf<br />		<br />		L2:<br />			mov al, <br />			adc al, <br /><br />			aaa<br /><br />			pushf<br /><br />			add al, 30h<br />			mov , al<br /><br />			dec esi<br />			dec edi<br />			dec ebx<br /><br />			popf<br /><br />		loop L2<br />		<br />		<br />		jnc Remove_Extra<br /><br />		mov byte ptr , '1'<br /><br /></div></div>
    <div class="meta">Posted on 2003-04-25 15:58:56 by locke</div>
   </div>
   <div class="post" id="post-99415">
    <div class="subject"><a href="#post-99415">ASCII Operation AAA</a></div>
    <div class="body">For your add routine to work, you need to &quot;right justify&quot; your whole number part. Don't change the fraction part.<br /><br />Store it as<br /><br />00000000000xxx<br /><br />rather than as<br /><br />xxx00000000000<br /><br />This way you also get zeros in the correct places. Then for printing, you just need to skip over zeros on the correct ends of the two strings.</div>
    <div class="meta">Posted on 2003-04-25 16:45:11 by tenkey</div>
   </div>
   <div class="post" id="post-99419">
    <div class="subject"><a href="#post-99419">ASCII Operation AAA</a></div>
    <div class="body">The whole number part is already right justified...<br /><br />If the two numbers '123.999' and '1.111' are entered it adds in '0's to the shorter string of the whole number part, so it becomes:<br /><br />'123' is saved in FPVal_W1<br />'001' is saved in FPVal_W2<br /><br />than their sum is suppose to be saved in FPSum_W1...<br /><br /><br />its just that... after adding it and saving the sum... for some reason it adds or there are already extra zeros... :(</div>
    <div class="meta">Posted on 2003-04-25 17:34:42 by locke</div>
   </div>
   <div class="post" id="post-99437">
    <div class="subject"><a href="#post-99437">ASCII Operation AAA</a></div>
    <div class="body">No, it's not right justified.<br /><br />In your macros, you use LENGTHOF which starts your pointer not at the end of the number, but at the end of the string buffer. You have '0' chars at the end of the buffer. The (binary) zero byte that ends the string is at the very end of the buffer, so your print routines display everything to that point. You're adding the carry to the digit at the end of the buffer, not the end of the number.<br /><br />What your strings look like are:<br /><br />123000...000<br />001000...000<br /><br />not as I suggest:<br /><br />000...000123<br />000...000001</div>
    <div class="meta">Posted on 2003-04-25 20:34:12 by tenkey</div>
   </div>
   <div class="post" id="post-99455">
    <div class="subject"><a href="#post-99455">ASCII Operation AAA</a></div>
    <div class="body">Let's go back to basics. Your setPointer macro uses the &quot;lengthof&quot; pseudo code. This returns the number of bytes you reserved for the variable used with it. If you would have reserved 256 bytes for that variable, it returns a value of 256 regardless of the number of bytes you would have effectively used at the start of that buffer, AND it doesn't care about terminating 0's.<br /><br />If you want to know the number of characters at the beginning of a buffer before a terminating 0, the masm32.lib has a function to do just that: <strong>lnstr</strong>.<br /><br />Secondly. Getting the end address of the buffer where you want to store the result can easily be obtained by getting the address of the following variable and decrementing it by 1.<br /><br />answer db 100 dup(0)<br />nexone db xx dup(xx)<br /><br />mov ebx,offset nexone-1 ;-&gt;address of last byte of answer buffer<br /><br />Store your terminating 0 immediately at that point and &quot;dec ebx&quot;<br /><br />Thirdly. After you add the decimals, store immediately your decimal point and <strong>don't</strong> try to store the integers into another buffer. Then, when you're finished with the integers, EBX will point to the start of your full answer.<br /><br />You're getting there. Don't despair.<br /><br />Raymond</div>
    <div class="meta">Posted on 2003-04-25 22:10:52 by Raymond</div>
   </div>
   <div class="post" id="post-99475">
    <div class="subject"><a href="#post-99475">ASCII Operation AAA</a></div>
    <div class="body">I'm not familiar w/ <strong>lnstr</strong> is it the same as <strong>Str_length</strong> function I've been using?<br /><br /><br />Is this correct?<br /><br />.data<br /><br />FPSum_D1 BYTE 60 dup ('0'),0<br />FPSum_W1 BYTE 60 dup ('0'),0<br /><br />.code<br /><br />mov ebx, offset FPSum_W1-1;<br />mov byte ptr ,0<br />		<br />dec ebx</div>
    <div class="meta">Posted on 2003-04-25 23:01:53 by locke</div>
   </div>
   <div class="post" id="post-99480">
    <div class="subject"><a href="#post-99480">ASCII Operation AAA</a></div>
    <div class="body">this is how I updated my code, still isn't working quite right... : /<br /><br /><br />It actually adds it correctly w/ the the carry ... but now I have extra '0's on the left of the number<br /><br /><div class="quote"><br /><br />setPointer MACRO reg, var		                                ; Macro to set pointer<br />		lea reg, var			; Load Effective Address of register<br />		INVOKE Str_length, ADDR var	                ; Receive length of string in eax<br />		add reg, eax			; Move pointer to end of string<br />		dec reg				; Move back one	<br />	ENDM					; End of Macro definition<br /><br /><br />.<br />.<br />.<br />.<br /><br /><br />        Addition1:<br />        	        	   	<br />       		setPointer esi, FPVal_D1<br />       		setPointer edi, FPVal_D2<br />		<br />		mov ebx, offset FPSum_W1-1;<br />		mov byte ptr ,0<br />				<br />		dec ebx<br />										<br />		INVOKE Str_length, ADDR FPVal_D1<br />		mov ecx, eax<br /><br />                                ;mov   ecx, lengthof FPVal_D1<br />		clc     <br /><br />		L1:<br />			mov al, <br />			adc al, <br /><br />			aaa<br /><br />			pushf<br /><br />			add al, 30h<br />			mov , al<br /><br />			dec esi<br />			dec edi<br />			dec ebx<br /><br />			popf<br /><br />		loop L1<br />		<br />		pushf<br />		<br />		mov byte ptr , '.'	<br />		dec ebx<br />		<br />	Addition2:<br />		<br />		setPointer esi, FPVal_W1<br />		setPointer edi, FPVal_W2<br />						<br />		INVOKE Str_length, ADDR FPVal_W1<br />		mov ecx, eax<br />                                ;mov   ecx, lengthof FPVal_W1<br />		<br />		popf<br />		<br />		L2:<br />			mov al, <br />			adc al, <br /><br />			aaa<br /><br />			pushf<br /><br />			add al, 30h<br />			mov , al<br /><br />			dec esi<br />			dec edi<br />			dec ebx<br /><br />			popf<br /><br />		loop L2<br />		<br />		<br />		jnc Remove_Extra<br /><br />		mov byte ptr , '1'<br /><br /></div><br /><br /><br />So if I add '900.999' and '100.111' I get: '0000000000000000001001.110'<br /><br />well I guess thats not such a big gripe... maybe I should start working on a case for negative signs<br /><br />hmmm... actually I get an error of memory could not be written if I enter a whole number alone, like: '2' and '5'</div>
    <div class="meta">Posted on 2003-04-25 23:17:41 by locke</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=12760&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=12760&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="12760" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=12760&amp;page=2">&gt;</a><a href="../?id=12760&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>