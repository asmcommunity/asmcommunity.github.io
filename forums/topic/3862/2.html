<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Creating a &quot;networked&quot; text based game - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=3862" />
  <link rel="prev" href="../?id=3862&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=8">Networking</a> &raquo; <a href="../?id=3862">Creating a &quot;networked&quot; text based game</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=3862&amp;page=1" style="">&laquo;</a><a href="../?id=3862&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="3862" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-33702">
    <div class="subject"><a href="#post-33702">Creating a &quot;networked&quot; text based game</a></div>
    <div class="body">Thomas - That routine was copied directly from my own code, so if there are any bugs I guess I'm to blame :)<br />It works just fine for me though, have you tried turning on Local echo (in case you use the Win9x telnet client)? On winXP this setting is enabled by default.<br />I must say I agree I didn't code this routine very nicely, and I plan on rewriting it soon. I'll be sure to notify you, Sliver :)</div>
    <div class="meta">Posted on 2002-04-16 11:38:06 by Qweerdy</div>
   </div>
   <div class="post" id="post-33707">
    <div class="subject"><a href="#post-33707">Creating a &quot;networked&quot; text based game</a></div>
    <div class="body">I guess it depends on the OS, I'm running win2k SP2 which has local echo off by default, but that shouldn't matter. The problem is that the peek will never give me more than 1 char.. This might not happen on other OSes (and therefore work) but it is valid behaviour, you can't rely on the internal buffers to be filled with a whole string, winsock can choose any buffer size. I think it also has to do with the relatively slow transfer rate from telnet as you're typing the characters..<br /><br />I'll see if I can find some sample code from my webserver if I have time.<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-04-16 12:21:42 by Thomas</div>
   </div>
   <div class="post" id="post-33709">
    <div class="subject"><a href="#post-33709">Creating a &quot;networked&quot; text based game</a></div>
    <div class="body">Here's part of my HTTP server code that handles the received data buffer. It's a bit lengthy but a lot of stuff is specificly for my own code so you can leave that out.  The code isn't optimized yet either.<br /><br />The ReadDataToBuffer method (it's a class) receives data and adds it to it's internal buffer (.InputBuffer). GetNextBufferLine checks if a full line is found, if it is, it's copied to an output buffer. After you processed that line, it can be deleted from the buffer with RemoveFirstBufferLine.<br />The pseudo code:<br /><pre><code><br />while&#40;connected&#41;<br />&#123;<br /> wait for incomming data<br /> ReadDataToBuffer<br />    while &#40;GetNextBufferLine finds a line&#41;<br />    &#123;<br />        process line<br />        RemoveFirstBufferLine<br />    &#125;<br />&#125;<br /></code></pre><br /><br /><pre><code><br />; returns 1 on success &#40;which doesn't have to mean that data has been added to <br />; the buffer&#40;!&#41;.<br />; returns 0 on failure &#40;dwLastError is set&#41;<br />CST_ReadDataToBuffer proc uses edi lpTHIS&#58;DWORD<br />    SetObject edi, CServerThread<br /><br />    ; Calculate unused buffer part pointer &amp; size<br />    mov     eax, ST_INPUT_BUFFER_SIZE<br />    lea     ecx, &#91;edi&#93;.InputBuffer<br />    sub     eax, &#91;edi&#93;.InBufferUsed         ;nr of unused bytes<br />    add     ecx, &#91;edi&#93;.InBufferUsed         ;pointer to first unused byte<br />    <br />    ; Check if all bytes are already in use&#58;<br />    .IF     eax==0 ;no bytes left?<br />        ; If no buffer space is available, disable further notification of<br />        ; arriving data. No data is received now. The notification should<br />        ; be re-enabled when buffer space has been freed.<br />        and     &#91;edi&#93;.CurNetEventMask, NOT FD_READ<br />        invoke  WSAEventSelect, &#91;edi&#93;.hClientSocket, &#91;edi&#93;.hNetworkEvent,<br />                     &#91;edi&#93;.CurNetEventMask<br />        int 3<br />        ; Check if errors occurred and quit<br />        .IF     eax==SOCKET_ERROR<br />            mov     &#91;edi&#93;.dwLastError, ST_ERR_INTERNALFUNCTIONFAILED<br />            xor     eax, eax<br />        .ELSE<br />            xor     eax, eax<br />            inc     eax<br />        .ENDIF<br />        ret<br />    .ENDIF<br /><br />    ; Receive data and append to buffer&#58;<br />    invoke  recv, &#91;edi&#93;.hClientSocket, ecx, eax, NULL<br />    <br />    ; Process return value and quit&#58;<br />    xor     ecx, ecx<br />    .IF     eax==0<br />        mov     &#91;edi&#93;.dwLastError, ST_ERR_CONNECTION_CLOSED<br />    .ELSEIF eax==SOCKET_ERROR<br />        invoke  WSAGetLastError<br />        .IF     eax!=WSAEWOULDBLOCK<br />            mov     &#91;edi&#93;.dwLastError, ST_ERR_INTERNALFUNCTIONFAILED<br />        .ELSE<br />            inc     ecx<br />        .ENDIF<br />    .ELSE<br />        ; add number of bytes received &#40;eax&#41; to buffer use counter&#58;<br />        add     &#91;edi&#93;.InBufferUsed, eax<br />        inc     ecx<br />    .ENDIF<br />    <br />    mov     eax, ecx<br />    ReleaseObject edi<br />ret <br />CST_ReadDataToBuffer endp<br /><br />;------------------------------------------------------------------------------------------<br /><br />; returns -1 when no lines currently available<br />; returns -2 on error<br />; otherwise, the return value is the number of characters copied to the output buffer<br />; Note that this value may be zero, indicating an empty line<br />; The output buffer has to have at least the size of the data buffer!!!<br />; lpLnSrc points to a dword that will hold the size of the line in the original buffer..<br />; This value may be different from the returnvalue, as LWS are replaced by single spaces<br />; in the output buffer. Use this value for RemoveFirstBufferLine<br />CST_GetNextBufferLine proc uses edi esi ebx lpTHIS&#58;DWORD, lpOutBuffer&#58;DWORD, lpLnSrc&#58;DWORD<br />LOCAL   prevChar&#58;BYTE<br />    SetObject edi, CServerThread<br /><br />    ; Calculate unused buffer part pointer &amp; size<br />    lea     ecx, &#91;edi&#93;.InputBuffer<br />    mov     edx, ecx<br />    add     edx, &#91;edi&#93;.InBufferUsed<br /><br />    ; Check for empty buffer&#58;<br />    .IF     ecx==edx<br />        or      eax, -1<br />        ret<br />    .ENDIF<br />    <br />    ; Check if empty line &#40;CR, LF or CRLF&#41;<br />    mov     al, &#91;ecx&#93;<br />    <br />    ;!!!!!!!!! yet to do&#58; check for other invalid chars<br />    .IF     al==0<br />        int 3 <br />        ;INVALID REQUEST&#58; INVALID REQUEST!!<br />        or      eax, -1<br />        dec     eax<br />        ret<br />    .ENDIF<br /><br />    .IF     al==0Dh ;CR?<br />        .IF     &#91;edi&#93;.usedEOL==EOL_CR<br />            mov     eax, lpOutBuffer<br />            mov     byte ptr &#91;eax&#93;,0<br />            xor     eax, eax<br />            ret<br />        .ELSEIF &#91;edi&#93;.usedEOL==EOL_CRLF<br />            inc     ecx<br />            .IF     ecx==edx ;LF not yet arrived so wait for it &#40;=no lines yet&#41;<br />                or      eax, -1<br />                dec     eax ;-2<br />                ret<br />            .ELSE<br />                .IF     byte ptr &#91;ecx&#93;==0Ah ;LF in CRLF?<br />                    mov     eax, lpOutBuffer<br />                    mov     byte ptr &#91;eax&#93;,0<br />                    xor     eax, eax<br />                    ret<br />                .ELSE<br />                    int 3<br />                    ;INVALID REQUEST.. CRLF expected but LF is something else!!!<br />                .ENDIF<br />            .ENDIF<br />        .ELSEIF &#91;edi&#93;.usedEOL==EOL_LF<br />            int 3<br />            ;INVALID REQUEST.. CR used where LF expected!<br />        .ENDIF<br />    .ELSEIF al==0Ah ;LF?<br />            mov     eax, lpOutBuffer<br />            mov     byte ptr &#91;eax&#93;,0<br />            xor     eax, eax<br />            ret<br />    .ENDIF<br />    <br />    <br />    lea     ecx, &#91;edi&#93;.InputBuffer<br />    and     prevChar, 0<br /><br />    ;Find line&#58;<br />    .WHILE  ecx &lt; edx<br />        mov     al, &#91;ecx&#93;<br />        cmp     al, &quot; &quot;<br />        je      @gnbl001<br />        cmp     al, 09h ;tab<br />        je      @gnbl001<br />        <br />        ;if no whitespace&#58;<br />        .IF     prevChar==0Dh   ;CR?<br />            cmp al, 0Ah ;part of CRLF?<br />            je  @gnbl001<br />                        <br />            mov     &#91;edi&#93;.usedEOL, EOL_CR<br />            jmp     @foundline<br />        .ELSEIF prevChar==0Ah   ;LF?<br />            .IF     &#91;edi&#93;.usedEOL==EOL_CRLF<br />                ; note&#58; &#91;ecx-2&#93; is always a valid pointer, as<br />                ; &#91;ecx-1&#93; &#40;=prevChar&#41; is LF, and LF can never be<br />                ; the first character &#40;this is handled in the empty<br />                ; line check at the start of this proc&#41;. So there<br />                ; HAS to be another character before the LF, at<br />                ; &#91;ecx-2&#93;.<br />                .IF byte ptr &#91;ecx-2&#93;!=0Dh ; CR in CRLF?<br />                        mov &#91;edi&#93;.usedEOL, EOL_LF<br />                .ENDIF<br />                jmp     @foundline<br />            .ELSEIF &#91;edi&#93;.usedEOL==EOL_LF<br />                jmp     @foundline<br />            .ELSEIF &#91;edi&#93;.usedEOL==EOL_CR<br />                int 3<br />                ; INVALID REQUEST.. LF used where CR expected!!!<br />            .ENDIF<br />        .ENDIF<br />       @gnbl001&#58;<br />        mov     prevChar, al<br />        inc     ecx<br />    .ENDW<br />    <br />    ;No lines found, check if full buffer used&#58;<br />    or      eax, -1<br />    .IF     &#91;edi&#93;.InBufferUsed==ST_INPUT_BUFFER_SIZE<br />        ;BUFFER OVERFLOW &#40;LINE TOO LONG&#41;!!!!!!!!!!!!!<br />        int 3<br />        dec     eax<br />    .ENDIF  <br />    ret<br />    <br />  @foundline&#58;<br />    ;here&#58; ecx points to first character after the last character in the <br />    ;      found line. <br />    ;store source length first&#58;<br />    mov     edx, lpLnSrc<br />    lea     eax, &#91;edi&#93;.InputBuffer<br />    neg     eax<br />    add     eax, ecx    <br />    mov     &#91;edx&#93;, eax<br />    <br />    lea     edx, &#91;edi&#93;.InputBuffer<br />    mov     ebx, lpOutBuffer<br />    <br />    and     prevChar, 0<br />    .WHILE  edx&lt;ecx<br />        mov     al, &#91;edx&#93;<br />        .IF     al==&quot; &quot; || al==09h ;space or tab?<br />            .IF     prevChar==0Dh || prevChar==0Ah<br />                mov     byte ptr &#91;ebx&#93;, &quot; &quot;<br />                inc     ebx<br />                ;skip all other whitespace at start of line&#58;<br />                .WHILE  al==&quot; &quot; || al==09h<br />                    ; Note&#58; this loop does not need to check if <br />                    ; edx goes beyond ecx, as the last character of that string<br />                    ; can never be a space or a tab &#40;only a CR or LF&#41;.<br />                    inc     edx<br />                    mov     prevChar, al<br />                    mov     al, &#91;edx&#93;<br />                .ENDW<br />                dec     edx<br />            .ELSE<br />                mov byte ptr &#91;ebx&#93;, al<br />                inc ebx<br />            .ENDIF<br />        .ELSEIF al!=0Ah &amp;&amp; al!=0Dh<br />            mov     byte ptr &#91;ebx&#93;, al<br />            inc     ebx<br />        .ENDIF<br />        <br />        inc     edx<br />        mov     prevChar, al<br />    .ENDW<br />    mov     byte ptr &#91;ebx&#93;, 0   ;final null terminator<br />    sub     ebx, lpOutBuffer<br />    mov     eax, ebx<br />    ReleaseObject edi<br />ret<br />CST_GetNextBufferLine   endp<br /><br />; returns 0 on failure &#40;dwLastError is set&#41;<br />; returns 1 on success<br />CST_RemoveFirstBufferLine proc uses edi esi ebx lpTHIS&#58;DWORD, lnSrc&#58;DWORD<br />LOCAL   prevChar&#58;BYTE<br />    SetObject edi, CServerThread<br /><br />    ; Calculate unused buffer part pointer &amp; size<br />    lea     ecx, &#91;edi&#93;.InputBuffer<br />    mov     edx, ecx<br />    add     edx, &#91;edi&#93;.InBufferUsed<br />    <br />    mov     ebx, ecx<br />    add     ebx, lnSrc<br />    <br /><br />    .WHILE  ebx&lt;edx<br />        mov     al, &#91;ebx&#93;<br />        mov     &#91;ecx&#93;, al<br />    <br />        inc     ecx<br />        inc     ebx<br />    .ENDW<br />    <br />    mov     eax, lnSrc<br />    sub     &#91;edi&#93;.InBufferUsed, eax<br />    <br />    xor eax,eax<br />    inc eax<br />    <br />    ReleaseObject edi<br />ret<br />CST_RemoveFirstBufferLine   endp<br /></code></pre><br /><br />Thomas</div>
    <div class="meta">Posted on 2002-04-16 12:31:03 by Thomas</div>
   </div>
   <div class="post" id="post-33711">
    <div class="subject"><a href="#post-33711">Creating a &quot;networked&quot; text based game</a></div>
    <div class="body">Thomas, what I don't get is this: since I use MSG_PEEK, I get all the data in Winsock's buffer that is available at that moment, right? And that data does not get removed.<br />In that case, if the data didn't contain a CrLf, I can call recv again, and it should give me the entire buffer again, including the old data I already parsed and the new data that just arrived. At least it works this way on XP, and I always understood it would work this way from MSDN.<br /><br />I guess your code is more or less what I was aiming at, the code in my example program (telnet server) is just a quick hack to get the network interface working. Can I download the full source somewhere (for this &quot;class&quot;, OOP I presume :) )?</div>
    <div class="meta">Posted on 2002-04-16 13:06:38 by Qweerdy</div>
   </div>
   <div class="post" id="post-33712">
    <div class="subject"><a href="#post-33712">Creating a &quot;networked&quot; text based game</a></div>
    <div class="body"><div class="quote">Thomas, what I don't get is this: since I use MSG_PEEK, I get all the data in Winsock's buffer that is available at that moment, right?<br /></div><br />Yes<br /><div class="quote">And that data does not get removed. <br />In that case, if the data didn't contain a CrLf, I can call recv again, and it should give me the entire buffer again, including the old data I already parsed and the new data that just arrived.</div><br />Yes, but what if winsock decides the buffer is full and waits until your program actually received it before adding more data  to it's internal buffers? I think this is what happens.. <br />When I trace the code, and 6 chars are in the buffer, it ends up in an endless loop with the peek, and each time the peek only receives one char. When I manually break the loop, and the second recv is called, it receives all characters!<br /><br /><div class="quote"><br />At least it works this way on XP, and I always understood it would work this way from MSDN. </div><br />As I said, it probably depends on the OS.<br /><br /><div class="quote"><br />I guess your code is more or less what I was aiming at, the code in my example program (telnet server) is just a quick hack to get the network interface working. Can I download the full source somewhere (for this &quot;class&quot;, OOP I presume  )?<br /></div><br /><br />Sorry, it's for one of my own projects and it relies on many other classes. But you can take out the parts you need, everything is there. <br /><br />Thomas</div>
    <div class="meta">Posted on 2002-04-16 13:28:29 by Thomas</div>
   </div>
   <div class="post" id="post-33787">
    <div class="subject"><a href="#post-33787">Creating a &quot;networked&quot; text based game</a></div>
    <div class="body">Okay, thanks anyway. But in that case I think I'll continue working on my own solution, since it's starting to look better and better. I'd say it was sort-of OOP, since it creates a separate struct for each connection (socket) opened, and requires you to pass a ptr to this struct to all the other procs.<br /><br />PS: Now that I actually studied your code more closely, I've noticed that you're doing the reading-into-buffer part almost the same way I am (in the new version), only I'm storing the amount of data that's in the buffer, instead of what's left. It may make more sense for me to do it your way though... <br />I also noticed you're using WSAEventSelect... really nice functions, I agree. But not available on winsock 1.1, and I was trying to make my app compatible with that too. Besides, with a telnet client, performance may not be such a big issue as with your project.</div>
    <div class="meta">Posted on 2002-04-17 00:40:58 by Qweerdy</div>
   </div>
   <div class="post" id="post-33796">
    <div class="subject"><a href="#post-33796">Creating a &quot;networked&quot; text based game</a></div>
    <div class="body"><div class="quote"><em>Originally posted by Qweerdy </em><br />Okay, thanks anyway. But in that case I think I'll continue working on my own solution, since it's starting to look better and better. I'd say it was sort-of OOP, since it creates a separate struct for each connection (socket) opened, and requires you to pass a ptr to this struct to all the other procs.<br /></div><br /><br />My code uses several objects (Request, Response, ServerThread) for each connection, but of course that differs for the type of server.<br /><br /><div class="quote"><br />PS: Now that I actually studied your code more closely, I've noticed that you're doing the reading-into-buffer part almost the same way I am (in the new version), only I'm storing the amount of data that's in the buffer, instead of what's left. It may make more sense for me to do it your way though... <br /></div><br /><br />I'm doing the same, look at the <strong>lnBufferUsed</strong> member of the class. I only calculate what's left because you need this to add the new data. You don't want the buffer to overflow because too much data is added.<br /><br /><div class="quote"><br />I also noticed you're using WSAEventSelect... really nice functions, I agree. But not available on winsock 1.1, and I was trying to make my app compatible with that too. Besides, with a telnet client, performance may not be such a big issue as with your project. </div><br /><br />Well I consider it safe to use winsock 2. The only OS that doesn't support it is win95, but there's even a patch for that. I don't know about NT, NT 4 probably has it, 2k+ for sure.<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-04-17 01:46:44 by Thomas</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=3862&amp;page=1" style="">&laquo;</a><a href="../?id=3862&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="3862" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>