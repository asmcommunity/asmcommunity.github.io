<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Don't need last window - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25965" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25965">Don't need last window</a></p>
   <div class="post" id="post-189233">
    <div class="subject"><a href="#post-189233">Don't need last window</a></div>
    <div class="body">This works but I don&#39;t know how to eliminate that last window that<br />pops open without getting that endless loop that I had previously.<br />This version no longer stays in memory. :-)<br /><br />Thanks.<br /><br /><pre><code><br />; killit1.asm<br />;<br />; Kills notepad.exe<br />;<br />.586<br />.model flat,stdcall<br />option casemap:none<br /><br />include&nbsp; \masm32\include\windows.inc<br />include&nbsp; \masm32\include\user32.inc<br />include&nbsp; \masm32\include\kernel32.inc<br />include&nbsp; \masm32\include\shlwapi.inc<br />include&nbsp; \masm32\macros\macros.asm<br />include&nbsp; \masm32\include\advapi32.inc<br /><br />includelib&nbsp; \masm32\lib\advapi32.lib<br />includelib&nbsp; \masm32\lib\user32.lib<br />includelib&nbsp; \masm32\lib\kernel32.lib<br />includelib&nbsp; \masm32\lib\shlwapi.lib<br /><br />STOP&nbsp; &nbsp; equ NOP&nbsp; ; marker<br /><br />; Local Prototypes<br /><br />&nbsp; &nbsp; IsWinNT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PROTO<br />&nbsp; &nbsp; ReqNTPrivilege&nbsp; PROTO :DWORD<br /><br />.const<br /><br />&nbsp; &nbsp; dwMaskNT&nbsp; &nbsp; &nbsp; &nbsp; DWORD&nbsp; &nbsp;2<br /><br />WinMain proto :DWORD,:DWORD,:DWORD,:DWORD<br /><br />.data<br /><br />&nbsp; &nbsp; BoofText&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db &quot;Something wrong !!&quot;,0<br />&nbsp; &nbsp; MsgCaption&nbsp; &nbsp; &nbsp; &nbsp; db &quot;OOPS&quot;,0<br /><br />&nbsp; &nbsp; msg_NotNT&nbsp; &nbsp;BYTE&nbsp; &nbsp; &quot;This is NOT an NT system.&quot;,0<br />&nbsp; &nbsp; msg_NotPL&nbsp; &nbsp;BYTE&nbsp; &nbsp; &quot;Privilege requested NOT granted.&quot;,0<br />&nbsp; &nbsp; BoxName&nbsp; &nbsp; &nbsp;BYTE&nbsp; &nbsp; &quot;ASM Win NT Shutdown&quot;,0<br />&nbsp; &nbsp; Watermark&nbsp; &nbsp;db&nbsp; &nbsp; &nbsp; &quot;Andrew Kennedy 5/10/07&quot;,0<br /><br />&nbsp; &nbsp;ClassName&nbsp; &nbsp; db &quot;MainWinClass&quot;,0<br />&nbsp; &nbsp;AppName&nbsp; &nbsp; &nbsp; db &quot;Main Window&quot;,0<br />&nbsp; &nbsp;ProcessName&nbsp; db &quot;notepad.exe&quot;,0<br />&nbsp; &nbsp;started&nbsp; &nbsp; &nbsp; db &quot;KillIt&quot;,0<br />&nbsp; &nbsp;startedtext&nbsp; db &quot;KillIt has started!&quot;,0<br />&nbsp; &nbsp;quittext&nbsp; &nbsp; &nbsp;db &quot;KillIt is suceeding!&quot;,0<br />&nbsp; &nbsp;successtext&nbsp; db &quot;KillIt has succeeded in killing notepad.exe!&quot;,0<br />&nbsp; &nbsp;failedtext&nbsp; &nbsp;db &quot;KillIt has failed!&quot;,0<br /><br />.data?<br /><br />&nbsp; &nbsp;hInstance&nbsp; &nbsp;HINSTANCE ?<br />&nbsp; &nbsp;CommandLine LPSTR&nbsp; &nbsp; &nbsp;?<br /><br />.code<br /><br />start:<br /><br />&nbsp; &nbsp; invoke GetModuleHandle, NULL<br />&nbsp; &nbsp; mov&nbsp; &nbsp; hInstance,eax<br /><br />&nbsp; &nbsp; invoke GetCommandLine<br />&nbsp; &nbsp; mov&nbsp; &nbsp; CommandLine,eax<br /><br />&nbsp; &nbsp; invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT<br /><br />&nbsp; &nbsp; ; with ReqNTPrivilege call, we ask for the &#39;SeShutdownPrivilege&#39;<br />&nbsp; &nbsp; ; note string names of possible privilege are in windows.inc<br /><br />&nbsp; &nbsp; invoke&nbsp; ReqNTPrivilege, SADD(&quot;SeShutdownPrivilege&quot;)<br />&nbsp; &nbsp; .if eax == FALSE<br />&nbsp; &nbsp; &nbsp; invoke&nbsp; MessageBox,NULL,addr msg_NotPL,addr BoxName,MB_OK<br />&nbsp; &nbsp; &nbsp; invoke&nbsp; ExitProcess,NULL<br />&nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; invoke ExitProcess,eax<br /><br />KillProcess proc lpszExecutable:LPSTR<br />&nbsp; &nbsp; LOCAL bLoop:BOOL<br />&nbsp; &nbsp; LOCAL bResult:BOOL<br />&nbsp; &nbsp; LOCAL pe32:PROCESSENTRY32<br />&nbsp; &nbsp; LOCAL hProcess:HANDLE<br />&nbsp; &nbsp; LOCAL hProcesses:HANDLE<br /><br />&nbsp; &nbsp; mov bLoop,TRUE<br />&nbsp; &nbsp; mov bResult,FALSE<br /><br />&nbsp; &nbsp; ; Returns an open handle to the specified snapshot if successful<br />or - 1 otherwise.<br />&nbsp; &nbsp; invoke CreateToolhelp32Snapshot,TH32CS_SNAPPROCESS,0<br />&nbsp; &nbsp; mov hProcesses,eax&nbsp; &nbsp; ;&nbsp; Did not need 2 copies of your snap shot<br /><br />&nbsp; &nbsp; mov pe32.dwSize,SIZEOF PROCESSENTRY32<br /><br />&nbsp; &nbsp; invoke Process32First,hProcesses,ADDR pe32<br />&nbsp; &nbsp; .IF eax<br />&nbsp; &nbsp; &nbsp; &nbsp; .WHILE bLoop<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke CompareString, LOCALE_USER_DEFAULT,<br />NORM_IGNORECASE, addr pe32.szExeFile, -1, lpszExecutable, -1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .IF eax==2 ; check if strings are equal in lexical value<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; With having addr pe32.th32ProcessID you were<br />getting an invalid PID<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke OpenProcess, PROCESS_TERMINATE, FALSE,<br />pe32.th32ProcessID ; returns handle<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.IF eax!=NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov hProcess, eax&nbsp; &nbsp; &nbsp; &nbsp; ; Need to save the<br />process handle to terminate<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke TerminateProcess, hProcess, 0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke CloseHandle, hProcess ; fails if eax is<br />zero<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; STOP ; 1st ; confirmed tht process IS sucessfully<br />terminated<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov bResult,TRUE;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; STOP ; 2nd<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; why go on to next process ?<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invoke Process32Next, hProcesses, ADDR pe32<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Retrieves information about the next process recorded in<br />a system snapshot.<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov bLoop,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; .endw<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke CloseHandle,hProcesses<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; mov eax,bResult<br />&nbsp; &nbsp; ret<br /><br />KillProcess endp<br /><br />WinMain proc<br />hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD<br />&nbsp; &nbsp; LOCAL wc:WNDCLASSEX<br />&nbsp; &nbsp; LOCAL msg:MSG<br />&nbsp; &nbsp; LOCAL hwnd:HWND<br /><br />&nbsp; &nbsp; mov&nbsp; &nbsp;wc.cbSize,SIZEOF WNDCLASSEX<br />&nbsp; &nbsp; mov&nbsp; &nbsp;wc.style, CS_HREDRAW or CS_VREDRAW<br />&nbsp; &nbsp; mov&nbsp; &nbsp;wc.lpfnWndProc, OFFSET WndProc<br />&nbsp; &nbsp; mov&nbsp; &nbsp;wc.cbClsExtra,NULL<br />&nbsp; &nbsp; mov&nbsp; &nbsp;wc.cbWndExtra,NULL<br />&nbsp; &nbsp; push&nbsp; hInstance<br />&nbsp; &nbsp; pop&nbsp; &nbsp;wc.hInstance<br />&nbsp; &nbsp; mov&nbsp; &nbsp;wc.hbrBackground,COLOR_BTNFACE+1<br />&nbsp; &nbsp; mov&nbsp; &nbsp;wc.lpszMenuName,NULL<br />&nbsp; &nbsp; mov&nbsp; &nbsp;wc.lpszClassName,OFFSET ClassName<br /><br />&nbsp; &nbsp; invoke LoadIcon,NULL,IDI_APPLICATION<br />&nbsp; &nbsp; mov&nbsp; &nbsp;wc.hIcon,eax<br />&nbsp; &nbsp; mov&nbsp; &nbsp;wc.hIconSm,eax<br /><br />&nbsp; &nbsp; invoke LoadCursor,NULL,IDC_ARROW<br />&nbsp; &nbsp; mov&nbsp; &nbsp;wc.hCursor,eax<br /><br />&nbsp; &nbsp; invoke RegisterClassEx, addr wc<br /><br />&nbsp; &nbsp; INVOKE CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hInst,NULL<br />&nbsp; &nbsp; mov&nbsp; &nbsp;hwnd,eax<br /><br />&nbsp; &nbsp; invoke ShowWindow, hwnd,SW_SHOWNORMAL<br />&nbsp; &nbsp; invoke UpdateWindow, hwnd<br /><br />&nbsp; &nbsp; .WHILE TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke GetMessage, ADDR msg,NULL,0,0<br />&nbsp; &nbsp; &nbsp; &nbsp; .BREAK .IF (!eax)<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke TranslateMessage, ADDR msg<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke DispatchMessage, ADDR msg<br />&nbsp; &nbsp; .ENDW<br /><br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;eax,msg.wParam<br />&nbsp; &nbsp; ret<br /><br />WinMain endp<br /><br />WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM<br /><br />&nbsp; &nbsp; LOCAL bResult:BOOL<br />&nbsp; &nbsp; LOCAL bLoop:BOOL<br /><br />&nbsp; &nbsp; .IF uMsg==WM_DESTROY<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PostQuitMessage,NULL<br /><br />&nbsp; &nbsp; .ELSEIF uMsg==WM_CREATE<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax, -1&nbsp; &nbsp; &nbsp; &nbsp; ;FALSE<br />&nbsp; &nbsp; &nbsp; &nbsp; STOP<br />&nbsp; &nbsp; &nbsp; &nbsp; mov bResult,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke MessageBox,0,OFFSET startedtext,OFFSET started,MB_OK<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke KillProcess,OFFSET ProcessName<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; mov bResult,eax ; don&#39;t see why we need two of these<br />&nbsp; &nbsp; &nbsp; &nbsp; STOP<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .IF bResult==FALSE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke MessageBox,0,OFFSET failedtext,OFFSET started,MB_OK<br />&nbsp; &nbsp; &nbsp; &nbsp; .ELSE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke MessageBox,0,OFFSET successtext,OFFSET<br />started,MB_OK<br />&nbsp; &nbsp; &nbsp; &nbsp; .ENDIF<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov bLoop,FALSE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; .WHILE !bLoop<br /> ;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invoke GetAsyncKeyState,VK_ESCAPE ; determines whether<br />key is up or down<br /> ;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; .IF&nbsp; eax &lt; 0<br /> ;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; .IF SDWORD PTR eax &lt; 0 ; this doesn&#39;t work<br /> ;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test eax,8000000h&nbsp; &nbsp; &nbsp; &nbsp;; or this<br /> ;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .IF !ZERO?&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; &quot;<br /> ;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invoke MessageBox,0,OFFSET quittext,OFFSET<br />started,MB_OK<br /> ;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invoke SendMessage,hWnd,WM_DESTROY,0,0<br /> ;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov bLoop,TRUE<br /> ;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.ENDIF<br />&nbsp; &nbsp; &nbsp; &nbsp; ; .WHILE !bLoop ; WHY is this checking for a key press ?<br />&nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp; &nbsp;invoke GetAsyncKeyState,VK_ESCAPE<br />&nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp; &nbsp; .IF ax != 0<br />&nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp; &nbsp; &nbsp; invoke MessageBox,0,OFFSET quittext,OFFSET<br />started,MB_OK<br />&nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp; &nbsp; &nbsp; invoke SendMessage,hWnd,WM_SYSCOMMAND,SC_CLOSE,NULL ;<br />closes window ?<br />&nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp; &nbsp; &nbsp; mov bLoop,TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp; .ENDIF<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ;.ENDW<br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br /><br />&nbsp; &nbsp; .ELSE<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke DefWindowProc,hWnd,uMsg,wParam,lParam<br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; .ENDIF<br /><br />&nbsp; &nbsp; xor eax,eax<br />&nbsp; &nbsp; ret<br />WndProc endp<br /><br />ReqNTPrivilege proc lpPrivilegeName:DWORD<br /><br />; return TRUE (not zero) in eax if privilege is granted<br />; lpPrivilegeName parameter points to a string with request privilege<br />name<br /><br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;hProcess:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;hToken:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;phToken:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;RetLen:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;pRetLen:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;tkp:TOKEN_PRIVILEGES<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;tkp_old:TOKEN_PRIVILEGES<br />;<br />&nbsp; &nbsp; invoke&nbsp; GetCurrentProcess<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;hProcess, eax<br />&nbsp; &nbsp; lea&nbsp; &nbsp; &nbsp;eax, hToken<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;phToken, eax<br />&nbsp; &nbsp; invoke&nbsp; OpenProcessToken, hProcess, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TOKEN_ADJUST_PRIVILEGES Or TOKEN_QUERY, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phToken<br />&nbsp; &nbsp; .if eax != FALSE<br />&nbsp; &nbsp; &nbsp; lea&nbsp; &nbsp; &nbsp;eax, tkp.Privileges[0].Luid<br />&nbsp; &nbsp; &nbsp; invoke&nbsp; LookupPrivilegeValue, NULL, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpPrivilegeName, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eax<br />&nbsp; &nbsp; &nbsp; lea&nbsp; &nbsp; &nbsp;eax, RetLen<br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;pRetLen, eax<br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;tkp.PrivilegeCount, 1<br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;tkp.Privileges[0].Attributes, SE_PRIVILEGE_ENABLED<br />&nbsp; &nbsp; &nbsp; invoke&nbsp; AdjustTokenPrivileges, hToken, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NULL, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr tkp, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof tkp_old, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr tkp_old, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pRetLen<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; ret<br /><br />ReqNTPrivilege endp<br /><br />end start <br /></code></pre><br /><br /><span style="font-size:6pt>Edit by JimmyClif: added Code Tags</span></div>
    <div class="meta">Posted on 2007-05-14 04:59:51 by skywalker</div>
   </div>
  </div>
 </body>
</html>