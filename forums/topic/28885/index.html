<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Help in displaying Multiplication Answer - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=28885" />
    <link rel="next" href="../?id=28885&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=28885">Help in displaying Multiplication Answer</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=28885&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=28885&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="28885" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=28885&amp;page=2">&gt;</a><a href="../?id=28885&amp;page=2">&raquo;</a></form>   <div class="post" id="post-204207">
    <div class="subject"><a href="#post-204207">Help in displaying Multiplication Answer</a></div>
    <div class="body">Hi guys.. i need some help here..<br /><br />I&#039;ve practically completed the coding..but no matter which ever way i try..i can&#039;t get it to print out the values of the multiplication..Can someone review my coding and point out my mistakes ?? thanks a lot..<br /><br /><div class="quote"><br /><span style="font-size:6pt>.MODEL MEDIUM<br />.STACK <br />.DATA <br /><br />;==================================<br />ONE DW 04DEH ; First signed number A = (-79H) = FF87H (2&#039;Compliment form)<br />TWO DW 096CH ; Second signed number B = (-7CH) = FF84H (2&#039;Compliment form)<br />THREE DW ? ; Variable C to store result<br />FOUR DW ?<br /><br />MSGTWO db &quot;enter first number:$&quot;<br />MSGTRI db &quot;enter second number:$&quot;<br />;MSGFOUR db &quot;Answer&nbsp; : $&quot;<br />;MSGFIVE db&nbsp; &quot;thank you for using the calculator! press any ;key...$&quot;<br />;ERROR db&nbsp; &quot;wrong operator!$&quot;<br />;==================================<br />PARALIST LABEL BYTE<br />MAX	 DB 	6<br />ACT 	 DB	?<br />PARADATA DB 	6 DUP (&#039; &#039;)<br /><br />PARALIST2 LABEL BYTE<br />MAX2	 DB 	6<br />ACT2 	 DB	?<br />PARADATA2 DB 	6 DUP (&#039; &#039;)<br /><br />;===================================<br /><br /><br />.CODE<br /><br /><br />MAIN PROC<br /><br />MOV AX,@DATA<br />MOV DS,AX<br />MOV SI,0000H ; Initialize SI to 0000H<br /><br />;Prompt For Input<br /><br />LEA DX,MSGTWO<br />MOV AH,09H<br />INT 21H<br /><br />MOV AH,0AH<br />LEA DX,PARALIST<br />INT 21H<br /><br />;New Line<br /><br />MOV AH,02H<br />MOV DL,0DH<br />INT 21H<br />MOV DL,0AH<br />INT 21H<br /><br />;Prompt For Input2<br />LEA DX,MSGTRI<br />MOV AH,09H<br />INT 21H<br /><br />MOV AH,0AH<br />LEA DX,PARALIST2<br />INT 21H<br /><br />;New Line<br /><br />MOV AH,02H<br />MOV DL,0DH<br />INT 21H<br />MOV DL,0AH<br />INT 21H<br /><br />;mov $ sign<br />MOV BL,ACT<br />MOV BH,00<br />MOV PARADATA,&#039;$&#039;<br /><br />;mov $ sign<br />MOV BL,ACT2<br />MOV BH,00<br />MOV PARADATA2,&#039;$&#039;<br /></span><br /><br /><br />; Perform Multiplication<br /><br />LEA AX,PARADATA ;Take first number A in AX register<br />LEA CX,PARADATA2 ;Take second number B in CX register<br />MUL CX ; Performs unsigned Multiplication DX:AX = AX × CX<br /><br />MOV SI,DX<br /><br />MOV FOUR,SI ; Store higher 16-bit result<br /><br />MOV AH,09H<br />MOV DX,FOUR<br />INT 21H<br /><br />MOV AH,02H<br />MOV DL,0DH<br />INT 21H<br />MOV DL,0AH<br />INT 21H<br /><br />MOV SI,AX<br /><br />MOV THREE,SI ; Store lower 16-bit result<br /><br />MOV AH,09H<br />MOV DX,THREE<br />INT 21H<br /><br />MOV AX,4c00H<br />INT 21H<br /><br />MAIN ENDP<br />END MAIN<br /></div><br /><br />The part in red is the code where i initialize it to print out..been trying to solve it for days..</div>
    <div class="meta">Posted on 2007-12-30 06:50:05 by zeropulse</div>
   </div>
   <div class="post" id="post-204223">
    <div class="subject"><a href="#post-204223">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body">Just some quick notes.<br /><br /><div class="quote"><br />LEA AX,PARADATA ;Take first number A in AX register<br />LEA CX,PARADATA2 ;Take second number B in CX register<br /></div><br /><br />LEA = Load Effective Address. It is a confusing instruction, but think of it as a mix of MOV/ADD/MUL in order to quickly calculate semi-complex addresses.<br /><br />So, essentially, you are multiplying the addresses (pointers) of the two variables instead of the values themselves.<br /><br /><div class="quote"><br />Performs unsigned Multiplication DX:AX = AX × CX<br /></div><br /><br />Yet, DX is not cleared before use.</div>
    <div class="meta">Posted on 2007-12-30 11:12:26 by SpooK</div>
   </div>
   <div class="post" id="post-204233">
    <div class="subject"><a href="#post-204233">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body">Yeah, you always have to do that first:<br /><br />xor edx,edx<br /><br />It clears the remainder</div>
    <div class="meta">Posted on 2007-12-30 12:54:01 by mrgone</div>
   </div>
   <div class="post" id="post-204258">
    <div class="subject"><a href="#post-204258">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body"><div class="quote">Quote<br />Performs unsigned Multiplication DX:AX = AX × CX<br /><br />Yet, DX is not cleared before use.</div><br /><br /><div class="quote">Yeah, you always have to do that first:<br /><br />xor edx,edx<br /><br />It clears the remainder</div><br /><br />There is absolutely no need to clear the DX register <u>before a multiplication</u>. Code such as follows can work just fine:<br /><br />mov ax,1234<br />mov dx,5678<br />mul dx<br /><br />with the correct answer returned in the DX:AX register pair.<br /></div>
    <div class="meta">Posted on 2007-12-30 20:19:51 by Raymond</div>
   </div>
   <div class="post" id="post-204259">
    <div class="subject"><a href="#post-204259">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body">Raymond is correct, clearing DX/EDX would only apply for division. Seeing DX:AX threw me off greatly for some reason :|</div>
    <div class="meta">Posted on 2007-12-30 20:27:10 by SpooK</div>
   </div>
   <div class="post" id="post-204262">
    <div class="subject"><a href="#post-204262">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body"><div class="quote">clearing DX/EDX would only apply for division</div><br /><br />My apology for seeming so picky. But (for newbies) even that statement must not be applied blindly.<br /><br />- For signed divisions, the DX/EDX register must be sign extended instead of being zeroed.<br /><br />- Immediately following a multiplication with the result possibly extending into the DX/EDX register (as in the example posted previously), that register must NOT be zeroed if the product must be divided by some other value.<br /></div>
    <div class="meta">Posted on 2007-12-30 22:24:17 by Raymond</div>
   </div>
   <div class="post" id="post-204270">
    <div class="subject"><a href="#post-204270">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body">No EBX is the Multiplyer. EDX is the remainder. Always clear EDX<br /><br />if EDX has value to multiply then:<br /><br />&nbsp; &nbsp; &nbsp; mov ebx,05h&nbsp;  ; multiplyer<br />&nbsp; &nbsp; &nbsp; mov eax,edx&nbsp;  ; move value to multiply to EAX<br />&nbsp; &nbsp; &nbsp; xor edx,edx&nbsp; &nbsp;  ; clear EDX or will be applied toward operation<br />&nbsp; &nbsp; &nbsp; mul ebx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Answer is EAX:EDX&nbsp; where EDX is remainder<br /><br /></div>
    <div class="meta">Posted on 2007-12-31 07:24:16 by mrgone</div>
   </div>
   <div class="post" id="post-204274">
    <div class="subject"><a href="#post-204274">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body">What is the definition of reminder of multiplication?</div>
    <div class="meta">Posted on 2007-12-31 12:00:01 by LocoDelAssembly</div>
   </div>
   <div class="post" id="post-204277">
    <div class="subject"><a href="#post-204277">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body"><div class="quote"><br />No EBX is the Multiplyer. EDX is the remainder. Always clear EDX<br /><br />if EDX has value to multiply then:<br /><br />&nbsp; &nbsp; &nbsp; mov ebx,05h&nbsp;  ; multiplyer<br />&nbsp; &nbsp; &nbsp; mov eax,edx&nbsp;  ; move value to multiply to EAX<br />&nbsp; &nbsp; &nbsp; xor edx,edx&nbsp; &nbsp;  ; clear EDX or will be applied toward operation<br />&nbsp; &nbsp; &nbsp; mul ebx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Answer is EAX:EDX&nbsp; where EDX is remainder<br /><br /><br /></div><br /><br />Actually, EAX x r/m32 = EDX:EAX, with EDX acting as the high 32-bits and EAX acting as the low 32-bits of a 64-bit number.<br /><br />Moreover, EBX <strong><em>can</em></strong> be a multiplier, but doesn&#039;t <strong><em>have</em></strong> to be. The multiplier just needs to be a valid r/m32 operand.<br /><br />Raymond is correct, on both accounts, so please yield to his advice ;)<br /><br />One reason you may want to clear/set EDX, is if you do 16-bit multiplication (result in DX:AX) and you want to use all of EDX after for whatever reason (same concept as MOVZX/MOVSX.)</div>
    <div class="meta">Posted on 2007-12-31 13:04:35 by SpooK</div>
   </div>
   <div class="post" id="post-204282">
    <div class="subject"><a href="#post-204282">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body">Ok Ok go ahead get into trouble by not clearing EDX. Go ahead. It&#039;s gonna happen.<br /><br />And yeah &quot;remainder&quot; is division and that will be that part of the result, but EDX will be applied toward your next division or multiplication.<br /><br />As a general rule of thumb:<br /><br />Always clear EDX first.</div>
    <div class="meta">Posted on 2007-12-31 15:07:17 by mrgone</div>
   </div>
   <div class="post" id="post-204283">
    <div class="subject"><a href="#post-204283">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body"><pre><code>3.2.3&nbsp; Multiplication Instructions<br /><br />The 80386 has separate multiply instructions for unsigned and signed<br />operands. MUL operates on unsigned numbers, while IMUL operates on signed<br />integers as well as unsigned.<br /><br />MUL (Unsigned Integer Multiply) performs an unsigned multiplication of the<br />source operand and the accumulator. If the source is a byte, the processor<br />multiplies it by the contents of AL and returns the double-length result to<br />AH and AL. If the source operand is a word, the processor multiplies it by<br />the contents of AX and returns the double-length result to DX and AX. If the<br />source operand is a doubleword, the processor multiplies it by the contents<br />of EAX and returns the 64-bit result in EDX and EAX. MUL sets CF and OF<br />when the upper half of the result is nonzero; otherwise, they are cleared.<br /><br />IMUL (Signed Integer Multiply) performs a signed multiplication operation.<br />IMUL has three variations:<br /><br />&nbsp; 1.&nbsp; A one-operand form. The operand may be a byte, word, or doubleword<br />&nbsp; &nbsp; &nbsp; located in memory or in a general register. This instruction uses EAX<br />&nbsp; &nbsp; &nbsp; and EDX as implicit operands in the same way as the MUL instruction.<br /><br />&nbsp; 2.&nbsp; A two-operand form. One of the source operands may be in any general<br />&nbsp; &nbsp; &nbsp; register while the other may be either in memory or in a general<br />&nbsp; &nbsp; &nbsp; register. The product replaces the general-register operand.<br /><br />&nbsp; 3.&nbsp; A three-operand form; two are source and one is the destination<br />&nbsp; &nbsp; &nbsp; operand. One of the source operands is an immediate value stored in<br />&nbsp; &nbsp; &nbsp; the instruction; the second may be in memory or in any general<br />&nbsp; &nbsp; &nbsp; register. The product may be stored in any general register. The<br />&nbsp; &nbsp; &nbsp; immediate operand is treated as signed. If the immediate operand is a<br />&nbsp; &nbsp; &nbsp; byte, the processor automatically sign-extends it to the size of the<br />&nbsp; &nbsp; &nbsp; second operand before performing the multiplication.<br /><br />The three forms are similar in most respects:<br /><br />&nbsp; þ&nbsp; The length of the product is calculated to twice the length of the<br />&nbsp; &nbsp;  operands.<br /><br />&nbsp; þ&nbsp; The CF and OF flags are set when significant bits are carried into the<br />&nbsp; &nbsp;  high-order half of the result. CF and OF are cleared when the<br />&nbsp; &nbsp;  high-order half of the result is the sign-extension of the low-order<br />&nbsp; &nbsp;  half.<br /><br />However, forms 2 and 3 differ in that the product is truncated to the<br />length of the operands before it is stored in the destination register.<br />Because of this truncation, OF should be tested to ensure that no<br />significant bits are lost. (For ways to test OF, refer to the INTO and PUSHF<br />instructions.)<br /><br />Forms 2 and 3 of IMUL may also be used with unsigned operands because,<br />whether the operands are signed or unsigned, the low-order half of the<br />product is the same.<br /><br /><br />3.2.4&nbsp; Division Instructions<br /><br />The 80386 has separate division instructions for unsigned and signed<br />operands. DIV operates on unsigned numbers, while IDIV operates on signed<br />integers as well as unsigned. In either case, an exception (interrupt zero)<br />occurs if the divisor is zero or if the quotient is too large for AL, AX, or<br />EAX.<br /><br />DIV (Unsigned Integer Divide) performs an unsigned division of the<br />accumulator by the source operand. The dividend (the accumulator) is twice<br />the size of the divisor (the source operand); the quotient and remainder<br />have the same size as the divisor, as the following table shows.<br /><br />Size of Source Operand<br />&nbsp; &nbsp; &nbsp; (divisor)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Dividend&nbsp; &nbsp; &nbsp;  Quotient&nbsp; &nbsp; &nbsp; Remainder<br /><br />Byte&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  AL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AH<br />Word&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DX:AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DX<br />Doubleword&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EDX:EAX&nbsp; &nbsp; &nbsp; &nbsp; EAX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  EDX<br /><br />Non-integral quotients are truncated to integers toward 0. The remainder is<br />always less than the divisor. For unsigned byte division, the largest<br />quotient is 255. For unsigned word division, the largest quotient is 65,535.<br />For unsigned doubleword division the largest quotient is 2^(32) -1.<br /><br />IDIV (Signed Integer Divide) performs a signed division of the accumulator<br />by the source operand. IDIV uses the same registers as the DIV instruction.<br /><br />For signed byte division, the maximum positive quotient is +127, and the<br />minimum negative quotient is -128. For signed word division, the maximum<br />positive quotient is +32,767, and the minimum negative quotient is -32,768.<br />For signed doubleword division the maximum positive quotient is 2^(31) -1,<br />the minimum negative quotient is -2^(31). Non-integral results are truncated<br />towards 0. The remainder always has the same sign as the dividend and is<br />less than the divisor in magnitude.<br /></code></pre><br /><br />That comes from the 80386 manual. What trouble do you see by not clearing EDX before multiplying? MUL/IMUL store something to EDX at most, but never use it to calculate the product (unless it is explicitly specified as operand).<br /><br />I agree about division, if EDX is not intended to be the high part of the dividend then it must be cleared (or cdq&#039;ed for IDIV) and that if the divisor is too small to produce a quotient that can fit in EAX it will throw an exception. You must also touch EDX if you intend to have modulo 2^32 arithmetic.<br /><br />PS: Yes, I more or less repeated what Raymond and later SpooK said.</div>
    <div class="meta">Posted on 2007-12-31 15:37:37 by LocoDelAssembly</div>
   </div>
   <div class="post" id="post-204284">
    <div class="subject"><a href="#post-204284">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body">How about this part?<br /><br />&quot;and returns the 64-bit result in EDX and EAX&quot;<br /><br />or you could take my word for it. Trial &amp; error is the best teacher I admit&nbsp; :P<br /><br />Although your research is lacking. You did not find the part that tells you EDX will be applied to next calculation.</div>
    <div class="meta">Posted on 2007-12-31 16:57:14 by mrgone</div>
   </div>
   <div class="post" id="post-204285">
    <div class="subject"><a href="#post-204285">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body"><div class="quote">Although your research is lacking. You did not find the part that tells you EDX will be applied to next calculation.</div><br /><br />What? :|<br /><br />Remember, I&#039;m trying to convince that EDX takes no part for computing MUL/IMUL despite on DIV/IDIV does ;)<br /><br />If you meant I&#039;m hiding part of the manual beleave me, I don&#039;t, clearing EDX or not makes no difference (except for EFLAGS if you use XOR or SUB to clear) on multiplication (unless EDX is one of the operands but if you clear it then skip the mul/imul and store 0 on dest instead ;))</div>
    <div class="meta">Posted on 2007-12-31 17:25:45 by LocoDelAssembly</div>
   </div>
   <div class="post" id="post-204286">
    <div class="subject"><a href="#post-204286">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body">I&#039;m not sure if I understood correctly, but multiplication RETURNS THE RESULT in edx:eax pair. And the result is equal to eax*reg32. There&#039;s no edx in the source arguments.<br />So:<br />1) Initialize eax to first operand<br />2) Initialize _ANY_ other GP register (maybe except esp? I don&#039;t remember) with second operand<br />3) perform <strong>mul</strong> with _the_second_register<br />4) The result is in edx:eax pair (or, if it didn&#039;t overflow, it&#039;s in eax and edx is equal to 0)<br /><br />Why would you have to initialize edx? You have to initialize edx before <u>division</u>, because <strong>div</strong> divides the contents of edx:eax pair by some other 32-bit register (so woth div, edx hold a part of the source argument - hence, it must be initialized).</div>
    <div class="meta">Posted on 2007-12-31 17:26:40 by ti_mo_n</div>
   </div>
   <div class="post" id="post-204287">
    <div class="subject"><a href="#post-204287">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body">mrgone <br /><br />The architecture of the CPU is such that when it encounters a mul instruction, it send the content of EAX and the content of the other operand to its multiplying unit. That in turn returns the result to the EDX::EAX pair and overwrites whatever was in those two registers.<br /><br />I have to assume you have used a debugger in the past. Write a short app with only the following instructions and watch what happens with those two registers as you step through the instructions.<br />mov eax,5<br />mov edx,7<br />mul edx<br /><br />If that small exercise doesn&#039;t convince you, I guess nothing will.<br /></div>
    <div class="meta">Posted on 2007-12-31 20:13:55 by Raymond</div>
   </div>
   <div class="post" id="post-204288">
    <div class="subject"><a href="#post-204288">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body">&nbsp; I wouldn&#039;t do that without first including this instruction:<br /><br />Xor EDX,EDX<br /><br /><br />Happy New Year&nbsp; :P</div>
    <div class="meta">Posted on 2007-12-31 20:38:55 by mrgone</div>
   </div>
   <div class="post" id="post-204289">
    <div class="subject"><a href="#post-204289">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body">a 2-byte NOP&nbsp; :roll:</div>
    <div class="meta">Posted on 2007-12-31 20:42:36 by sinsi</div>
   </div>
   <div class="post" id="post-204292">
    <div class="subject"><a href="#post-204292">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body"><div class="quote">Happy New Year&nbsp;  :P</div><br /><br />I sincerely wish you the same.<br />AND also to everyone else.<br /></div>
    <div class="meta">Posted on 2007-12-31 22:34:43 by Raymond</div>
   </div>
   <div class="post" id="post-204293">
    <div class="subject"><a href="#post-204293">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body"><div class="quote"><br /><div class="quote">Happy New Year&nbsp; &nbsp;:P</div><br /><br />I sincerely wish you the same.<br />AND also to everyone else.<br /><br /></div><br /><br />Pardon my boorishness...<br />Happy New Year to all. It&#039;s a hot 38.3C here and the beer is flowing...<br /><br /><br />I can only think of XOR EDX,EDX before MUL as being as useful as CLC before a CMP - a waste of time (tits...bull... :lol:)</div>
    <div class="meta">Posted on 2007-12-31 22:55:43 by sinsi</div>
   </div>
   <div class="post" id="post-204298">
    <div class="subject"><a href="#post-204298">Re: Help in displaying Multiplication Answer</a></div>
    <div class="body">I found this:<br /><br /><div class="quote">These two instructions perform multiplication and division.<br /><br />Example: <br /><br /><br />MOV	EAX, 10<br />MOV	ECX, 30<br />MUL	ECX<br />XOR	EDX, EDX<br />MOV	ECX, 10<br />DIV	ECX<br /><br /><br />The examples above first load EAX with 10 and ECX with 30. EAX is always the default multiplicand, and you get to select the other multiplier. When performing a multiplication the answer is in EAX:EDX. It only goes into EDX if the value is larger than the EAX register. When performing a divide you must first clear the EDX register that is what the XOR instruction does by performing an Exclusive OR on itself. After the divide, the answer is in EAX, with the remainder in EDX, if any exists.<br /><br /></div><br /><br />here: http://www.gamedev.net/reference/articles/article789.asp<br /><br />and this: <div class="quote">Integer multiplication and division are a little more awkward, for the reason<br />that multiplying two moderately large 32-bit numbers often will produce a result<br />which does not t in a 32-bit register. Thus, the integer multiply and divide<br />instructions implicitly work with the pair of registers (EDX:EAX), forming a<br />64-bit value by storing the most signicant bits in EDX, and the least signicant<br />in EAX. The imul (integer multiply) and idiv (integer divide) instructions then<br />take a single operand which they multiply or divide this 64-bit value by. As we<br />are only interested in 32-bit precision for our VSL programs, we can happily<br />use this mechanism to multiply and divide values in EAX without any extra<br />measures, apart from making sure that the EDX is 0 before doing so.</div><br /><br />from PDF doc: vsl-IA-32.pdf<br /><br />A good reason to always clear EDX first&nbsp; ;)</div>
    <div class="meta">Posted on 2008-01-01 10:11:56 by mrgone</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=28885&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=28885&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="28885" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=28885&amp;page=2">&gt;</a><a href="../?id=28885&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>