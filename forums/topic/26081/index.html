<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>MACRO to replace IMUL with LEA, SHL, ADD - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=26081" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=26081">MACRO to replace IMUL with LEA, SHL, ADD</a></p>
   <div class="post" id="post-189948">
    <div class="subject"><a href="#post-189948">MACRO to replace IMUL with LEA, SHL, ADD</a></div>
    <div class="body">I&#39;ve created a &quot;mult&quot; macro that replaces (in some cases)<br />the slower &quot;imul&quot; instruction. (max 5 times faster than imul)<br /><br />Currently, it supports all numbers between 0 and 50, and some others.<br /><br />You can get it from www.beotel.net/~astancic (click on &quot;Multiply.inc&quot;)<br /></div>
    <div class="meta">Posted on 2007-07-28 06:17:15 by aleksaZR</div>
   </div>
   <div class="post" id="post-189960">
    <div class="subject"><a href="#post-189960">Re: MACRO to replace IMUL with LEA, SHL, ADD</a></div>
    <div class="body">IMHO, writing a separate algorithm for every multiplication factor is inane. We discussed the <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=25495.0">Multiplication Algorithm</a> subject a while ago. Maybe that will help you create a better macro. Good luck.</div>
    <div class="meta">Posted on 2007-07-28 11:53:41 by XCHG</div>
   </div>
   <div class="post" id="post-189976">
    <div class="subject"><a href="#post-189976">Re: MACRO to replace IMUL with LEA, SHL, ADD</a></div>
    <div class="body"><div class="quote"><br />IMHO, writing a separate algorithm for every multiplication factor is inane. We discussed the <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=25495.0">Multiplication Algorithm</a> subject a while ago. Maybe that will help you create a better macro. Good luck.<br /></div><br />I disagree.<br /><br />Writing a &#39;separate&#39; macro for every number needed is, AFAIK,<br />simply the fastest method to MUL reg with a number.<br /><br />I&#39;ve created a list with all the numbers between 0-50, just<br />to see how it works, that doesn&#39;t mean that I need all of them.<br /><br />In the future, I&#39;ll just add the numbers that I need.<br /><br />For example, now I need to mul with 4000:<br />	lea	reg,<br />	lea	reg,<br />	lea	reg,<br />	shl	reg,5			;(5*5*5*32)<br />can you make it faster than that? (its 44% faster than IMUL)<br /></div>
    <div class="meta">Posted on 2007-07-29 05:34:48 by aleksaZR</div>
   </div>
   <div class="post" id="post-189979">
    <div class="subject"><a href="#post-189979">Re: MACRO to replace IMUL with LEA, SHL, ADD</a></div>
    <div class="body">Note that on newer processor &quot;IMUL reg, imm&quot; takes 3 cycles only. Since your code seems to always use the same reg then nothing can be executed in parallel and hence it takes no less than 4 cycles. Additionally, the Athlon64 manuals says that LEA don&#39;t take one cycle but two when scalling is used, so perhaps we could be talking about a code that takes 7 cycles.<br /><br /><div class="quote">4. LEA instructions have a latency of 1 when there are two source operands (as in the case of the base + index<br />form LEA EAX, ). Forms with a scale or more than two source operands will have a latency of 2 (LEA<br />EAX, ).</div><br /><br />Of course your efforts are still good if your target is processors prior to Pentium Pro.</div>
    <div class="meta">Posted on 2007-07-29 09:19:36 by LocoDelAssembly</div>
   </div>
   <div class="post" id="post-189982">
    <div class="subject"><a href="#post-189982">Re: MACRO to replace IMUL with LEA, SHL, ADD</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br />IMHO, writing a separate algorithm for every multiplication factor is inane. We discussed the <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=25495.0">Multiplication Algorithm</a> subject a while ago. Maybe that will help you create a better macro. Good luck.<br /></div><br />I disagree.<br /><br />Writing a &#39;separate&#39; macro for every number needed is, AFAIK,<br />simply the fastest method to MUL reg with a number.<br /><br />I&#39;ve created a list with all the numbers between 0-50, just<br />to see how it works, that doesn&#39;t mean that I need all of them.<br /><br />In the future, I&#39;ll just add the numbers that I need.<br /><br />For example, now I need to mul with 4000:<br />	lea	reg,<br />	lea	reg,<br />	lea	reg,<br />	shl	reg,5			;(5*5*5*32)<br />can you make it faster than that? (its 44% faster than IMUL)<br /><br /></div><br /><br /><br />I have always been interested in the fractions and the percentages that people give. 44%? Where did you get the numerator and the denominator that have made that percentage?<br /><br />Now about the actual code, the code that you gave:<br /><br /><pre><code>&nbsp; LEA&nbsp; &nbsp;  EAX , <br />&nbsp; LEA&nbsp; &nbsp;  EAX , <br />&nbsp; LEA&nbsp; &nbsp;  EAX , <br />&nbsp; SHL&nbsp; &nbsp;  EAX , 5</code></pre><br /><br />Takes 3 clock cycles to execute on my PIII 800MHZ with the code segment aligned on a DWORD boundary. The equivalent of this code using IMUL:<br /><br /><pre><code>&nbsp;  IMUL&nbsp; &nbsp;  EAX , EAX , 4000</code></pre><br /><br />Takes 1 clock cycle on the same machine to execute. Now if the value that has to be multiplied is in a variable, your code will take 13 clock cycles to execute:<br /><br /><pre><code>&nbsp; MOV&nbsp; &nbsp;  EAX , DWORD PTR <br />&nbsp; LEA&nbsp; &nbsp;  EAX , <br />&nbsp; LEA&nbsp; &nbsp;  EAX , <br />&nbsp; LEA&nbsp; &nbsp;  EAX , <br />&nbsp; SHL&nbsp; &nbsp;  EAX , 5<br />&nbsp; MOV&nbsp; &nbsp;  DWORD PTR  , EAX</code></pre><br /><br />this is while the equivalent of this code using IMUL will take 12 clock cycles on the same machine with the same conditions:<br /><br /><pre><code>&nbsp; IMUL&nbsp; &nbsp; EAX , DWORD PTR  , 4000<br />&nbsp; MOV&nbsp; &nbsp;  DWORD PTR  , EAX<br /></code></pre><br /></div>
    <div class="meta">Posted on 2007-07-29 12:19:51 by XCHG</div>
   </div>
   <div class="post" id="post-189983">
    <div class="subject"><a href="#post-189983">Re: MACRO to replace IMUL with LEA, SHL, ADD</a></div>
    <div class="body">XCHG, how do you measured the time? Did you remember to serialize before getting the TSC?</div>
    <div class="meta">Posted on 2007-07-29 12:26:28 by LocoDelAssembly</div>
   </div>
   <div class="post" id="post-189989">
    <div class="subject"><a href="#post-189989">Re: MACRO to replace IMUL with LEA, SHL, ADD</a></div>
    <div class="body">I just don&#39;t believe, yet, that any CPU can MUL in just one clock with a number such as 4000.<br />DECODE in one clock is OK, but the actual MUL...<br /><br />Parallel execution (probably, I&#39;m not sure with the IMUL instruction)<br />lets you do other stuff while IMUL is executing, but in my current app there&#39;s simply no other stuff to do.<br /><br />Actually, I&#39;ve made a mistake, it is 30%.<br />The numerator and denominator were given by the test prog below (MASM),<br />namely 150mS for the IMUL and 105mS for the macro.<br /><br />;___________________________________________________________________________________________________________________________<br />number equ 4000<br /><br />Start proc public<br />local text[128]:char<br />local count:UINT, count1:UINT, count2:UINT<br />local rez1:dword, rez2:dword<br /><br />;---------------------------------------------------------------------------------------------------------------------------<br />		status	, GetTickCount	;invoke GetTickCount: mov , eax<br /><br />		mov	eax,3<br />		mov	ecx,2500000<br />@@:		imul	eax,number<br />		djnz	ecx, @B			;DEC, JNZ<br /><br />		mov	, eax<br /><br />		invoke	GetTickCount<br />		sub	eax,<br />		mov	,eax<br /><br />;---------------------------------------------------------------------------------------------------------------------------<br />		status	, GetTickCount<br /><br />		mov	eax,3<br />		mov	ecx,2500000<br />@@:		mult	eax,number<br />		djnz	ecx, @B<br /><br />		mov	, eax<br /><br />		invoke	GetTickCount<br />		sub	eax,<br />		mov	,eax<br /><br />;---------------------------------------------------------------------------------------------------------------------------<br />%		invoke	wsprintf, a text, qt2(&lt;&#39;number=%u&#39;, cr,lf,cr,lf, &#39;imul = %u, mult = %u&#39;, cr,lf,cr,lf, &#39;rez1=%u&#39;, cr,lf, &#39;rez2=%u&#39;&gt;), number, , , , <br />		invoke	MessageBox, null, a text, qt2(&#39;Test&#39;), null<br />		ret<br />Start endp<br />;___________________________________________________________________________________________________________________________<br />end Start<br /></div>
    <div class="meta">Posted on 2007-07-29 14:59:57 by aleksaZR</div>
   </div>
   <div class="post" id="post-189991">
    <div class="subject"><a href="#post-189991">Re: MACRO to replace IMUL with LEA, SHL, ADD</a></div>
    <div class="body">I like to put beliefs aside, and actually test algorithms side-by-side. Below are the results in milliseconds for each code <br /><br />250,000,000 iterations (100 times more than what aleksaZR had put)<br />Sempron 3000+ , 1GB DDR@400 (timing 3, 4/8/4) . Thread-switching timer: 16,7ms. <br /><br /><pre><code><br />1:	454 vs 312<br />2:	468 vs 313<br />3:	468 vs 297<br />4:	469 vs 313<br />5:	469 vs 312<br />6:	469 vs 468<br />7:	453 vs 1016<br />8:	469 vs 313<br />9:	453 vs 313<br />10:	468 vs 469<br />11:	453 vs 953<br />12:	453 vs 469<br />13:	469 vs 1031<br />14:	469 vs 1125<br />15:	469 vs 625<br />16:	469 vs 313<br />17:	453 vs 1016<br />18:	453 vs 469<br />19:	469 vs 937<br />20:	468 vs 453<br />21:	468 vs 1032<br />22:	469 vs 1140<br />23:	453 vs 1094<br />24:	454 vs 468<br />25:	453 vs 625<br />26:	469 vs 1031<br />27:	453 vs 625<br />28:	469 vs 1031<br />29:	468 vs 985<br />30:	453 vs 781<br />31:	468 vs 1032<br />32:	468 vs 313<br />33:	454 vs 1015<br />34:	454 vs 1109<br />35:	454 vs 1046<br />36:	468 vs 469<br />37:	469 vs 1031<br />38:	454 vs 1250<br />39:	469 vs 1031<br />40:	469 vs 469<br />41:	469 vs 1031<br />42:	469 vs 1235<br />43:	469 vs 1250<br />44:	469 vs 1031<br />45:	453 vs 625<br />46:	468 vs 1032<br />47:	453 vs 1031<br />48:	468 vs 469<br />49:	469 vs 1031<br />50:	469 vs 781<br />51:	468 vs 985<br />52:	468 vs 1235<br />53:	453 vs 1000<br />54:	468 vs 766<br />55:	453 vs 1000<br />56:	454 vs 1093<br />57:	468 vs 1282<br />58:	469 vs 453<br />59:	468 vs 1125<br />60:	468 vs 922<br />61:	468 vs 1125<br />62:	453 vs 1187<br />63:	453 vs 1016<br />64:	469 vs 313<br />65:	453 vs 1016<br />72:	469 vs 453<br />80:	469 vs 469<br />81:	469 vs 625<br />90:	453 vs 781<br />96:	469 vs 469<br />100:	468 vs 766<br />1000:	468 vs 1079<br />4000:	468 vs 625<br /></code></pre><br /><br />aleksaZR, thanks for the macro. Just note that currently no end-user is on a 166MHz cpu, everyone&#39;s on a Sempron/AthlonXP/64 or a P4/C2D. Optimization for these beasts is usually a whole another matter. <br /><br />P.S. the code to measure timing was:<br /><pre><code><br />Start2 proc<br />	local count, count1,count2<br />	local rez1:dword, rez2:dword<br />	invoke Sleep,0<br /><br />;---------------------------------------------------------------------------------------------------------------------------<br />	mov count,$invoke(GetTickCount)<br /><br />&nbsp; &nbsp; &nbsp; mov&nbsp;  eax,3<br />&nbsp; &nbsp; &nbsp; mov&nbsp;  ecx,250000000<br />align 16<br />@@:&nbsp; &nbsp; &nbsp; imul&nbsp;  eax,number<br />	dec ecx<br />	jnz&nbsp; @B<br /><br />&nbsp; &nbsp; &nbsp; mov&nbsp;  , eax<br /><br />&nbsp; &nbsp; &nbsp; invoke&nbsp;  GetTickCount<br />&nbsp; &nbsp; &nbsp; sub&nbsp;  eax,<br />&nbsp; &nbsp; &nbsp; mov&nbsp;  ,eax<br /><br />;---------------------------------------------------------------------------------------------------------------------------<br />&nbsp; &nbsp; &nbsp; mov count,$invoke(GetTickCount)<br /><br />&nbsp; &nbsp; &nbsp; mov&nbsp;  eax,3<br />&nbsp; &nbsp; &nbsp; mov&nbsp;  ecx,250000000<br />	align 16<br />@@:&nbsp; &nbsp; &nbsp; mult&nbsp;  eax,number<br />	dec ecx<br />	jnz @B<br /><br />&nbsp; &nbsp; &nbsp; mov&nbsp;  , eax<br /><br />&nbsp; &nbsp; &nbsp; invoke&nbsp;  GetTickCount<br />&nbsp; &nbsp; &nbsp; sub&nbsp;  eax,<br />&nbsp; &nbsp; &nbsp; mov&nbsp;  ,eax<br />	trace &quot;%d:	%d vs %d&quot;,number,count1,count2<br />	ret<br />Start2 endp<br /></code></pre><br /><br /><br />P.P.S. :&nbsp; XCHG, percentages like that are (OldAlgoCycles/NewAlgoCycles - 1)*100 . <br />So, if OldAlgo took 36 cycles, and the new algo took 25 cycles, (36/25-1)*100 = 44% improvement. A 100% improvement is obviously a double-increase in speed. </div>
    <div class="meta">Posted on 2007-07-29 16:36:13 by Ultrano</div>
   </div>
   <div class="post" id="post-189992">
    <div class="subject"><a href="#post-189992">Re: MACRO to replace IMUL with LEA, SHL, ADD</a></div>
    <div class="body">You forgot to set Realtime priority first and the number of iterations are very few to get a conclution. Besides, the loops are not aligned so perhaps one of them is enjoying a better alignment than the other.<br /><br />The flat assembler program below gives me this <br /><div class="quote"><br />---------------------------<br />Test<br />---------------------------<br />number=4000<br />imul = 406, mult = 938<br />rez1=0<br />rez2=0</div><br /><br />The flat assembler program below gives me this <pre><code>include &#39;win32axp.inc&#39;<br /><br />number equ 4000<br /><br />proc Start<br />local text[128]:BYTE,\<br />&nbsp; &nbsp; &nbsp; count:DWORD, count1:DWORD, count2:DWORD,\<br />&nbsp; &nbsp; &nbsp; rez1:DWORD, rez2:DWORD,\<br />&nbsp; &nbsp; &nbsp; ProcessAffinityMask:DWORD, SystemAffinityMask:DWORD<br /><br />&nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; &nbsp;ebx esi<br /><br />&nbsp; &nbsp; &nbsp; invoke&nbsp; &nbsp;GetCurrentProcess<br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp; ebx, eax<br />&nbsp; &nbsp; &nbsp; invoke&nbsp; &nbsp;SetPriorityClass, eax, REALTIME_PRIORITY_CLASS<br />&nbsp; &nbsp; &nbsp; invoke&nbsp; &nbsp;GetCurrentThread<br />&nbsp; &nbsp; &nbsp; invoke&nbsp; &nbsp;SetThreadPriority, eax, THREAD_PRIORITY_TIME_CRITICAL<br /><br />;;;; On multi-{core|CPU} systems is required to set affinity as well but I don&#39;t have one :D<br />;;;; f0dder insisted in adding it anyway so here it is :P<br /><br />&nbsp; &nbsp; &nbsp; invoke&nbsp; &nbsp;GetProcessAffinityMask, ebx, addr ProcessAffinityMask, addr SystemAffinityMask<br />&nbsp; &nbsp; &nbsp; test&nbsp; &nbsp; &nbsp;eax, eax<br />&nbsp; &nbsp; &nbsp; jz&nbsp; &nbsp; &nbsp; &nbsp;.letThePartyBegin<br /><br />; Lets choose only one of the processors allowed for this process<br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp; esi, 1<br />&nbsp; &nbsp; &nbsp; bsf&nbsp; &nbsp; &nbsp; ecx, <br />&nbsp; &nbsp; &nbsp; shl&nbsp; &nbsp; &nbsp; esi, cl<br /><br />; Now, since Win9x/Me is smart enough to have GetProcessAffinityMask but not its counterpart we must check its existence first<br /><br />&nbsp; &nbsp; &nbsp; invoke&nbsp; &nbsp;LoadLibrary, &#39;KERNEL32.DLL&#39;<br />&nbsp; &nbsp; &nbsp; test&nbsp; &nbsp; &nbsp;eax, eax<br />&nbsp; &nbsp; &nbsp; jz&nbsp; &nbsp; &nbsp; &nbsp;.letThePartyBegin<br /><br />&nbsp; &nbsp; &nbsp; invoke&nbsp; &nbsp;GetProcAddress, eax, &#39;SetProcessAffinityMask&#39;<br />&nbsp; &nbsp; &nbsp; test&nbsp; &nbsp; &nbsp;eax, eax<br />&nbsp; &nbsp; &nbsp; jz&nbsp; &nbsp; &nbsp; &nbsp;.letThePartyBegin<br /><br />&nbsp; &nbsp; &nbsp; stdcall&nbsp; eax, ebx, esi<br /><br />.letThePartyBegin:<br />&nbsp; &nbsp; &nbsp; invoke Sleep, 20 ; Lets get a fresh slice<br />;---------------------------------------------------------------------------------------------------------------------------<br />&nbsp; &nbsp; &nbsp; invoke GetTickCount<br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; , eax<br /><br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;eax,3<br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;ecx, $10000000<br /><br />align 16<br />@@:<br />&nbsp; &nbsp; &nbsp; imul&nbsp; &nbsp;eax,number<br />&nbsp; &nbsp; &nbsp; dec&nbsp; &nbsp; ecx<br />&nbsp; &nbsp; &nbsp; jnz&nbsp; &nbsp; @B<br /><br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;, eax<br /><br />&nbsp; &nbsp; &nbsp; invoke&nbsp; &nbsp;GetTickCount<br />&nbsp; &nbsp; &nbsp; sub&nbsp; &nbsp; &nbsp; eax,<br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp; ,eax<br /><br />&nbsp; &nbsp; &nbsp; invoke Sleep, 20 ; Lets get a fresh slice<br />;---------------------------------------------------------------------------------------------------------------------------<br />&nbsp; &nbsp; &nbsp; invoke GetTickCount<br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; , eax<br /><br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;eax,3<br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;ecx, $10000000<br /><br />@@:<br />reg equ eax<br />&nbsp; &nbsp; &nbsp; lea&nbsp; &nbsp;reg,<br />&nbsp; &nbsp; &nbsp; lea&nbsp; &nbsp;reg,<br />&nbsp; &nbsp; &nbsp; lea&nbsp; &nbsp;reg,<br />&nbsp; &nbsp; &nbsp; shl&nbsp; &nbsp;reg,5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;(5*5*5*32)<br />restore reg<br /><br />&nbsp; &nbsp; &nbsp; dec&nbsp; &nbsp; ecx<br />&nbsp; &nbsp; &nbsp; jnz&nbsp; &nbsp; @B<br /><br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;, eax<br /><br />&nbsp; &nbsp; &nbsp; invoke&nbsp; &nbsp;GetTickCount<br />&nbsp; &nbsp; &nbsp; sub&nbsp; &nbsp;eax,<br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;,eax<br /><br />;---------------------------------------------------------------------------------------------------------------------------<br />&nbsp; &nbsp; &nbsp; invoke&nbsp; &nbsp;wsprintf, addr text, fmt, number, , , , <br />&nbsp; &nbsp; &nbsp; invoke&nbsp; &nbsp;MessageBox, NULL, addr text, &#39;Test&#39;, NULL<br /><br />&nbsp; &nbsp; &nbsp; pop&nbsp; &nbsp; &nbsp; esi ebx<br />&nbsp; &nbsp; &nbsp; ret<br />endp<br /><br />fmt db &#39;number=%u&#39;, 13, 10, 13, 10, &#39;imul = %u, mult = %u&#39;, 13, 10, 13, 10, &#39;rez1=%u&#39;, 13, 10, &#39;rez2=%u&#39;,0<br />;___________________________________________________________________________________________________________________________<br />.end Start</code></pre><br /> I got the red warning before posting telling me that Ultrano already posted something but I couldn&#39;t resist myself to post my version :P<br /><br />Since f0dder disliked my laziness now it also takes care about affinity ;)<br /><br />Fixed a big mess I did (apparently I did :?) with tags</div>
    <div class="meta">Posted on 2007-07-29 16:52:50 by LocoDelAssembly</div>
   </div>
   <div class="post" id="post-189993">
    <div class="subject"><a href="#post-189993">Re: MACRO to replace IMUL with LEA, SHL, ADD</a></div>
    <div class="body"><strong>LocoDelAssembly:</strong> it&#39;s a good idea to set the affinity even though you don&#39;t have a multicore machine... it doesn&#39;t really <em>cost</em> you anything, and means us people with multicore machines don&#39;t have to add it ourselves :P<br /></div>
    <div class="meta">Posted on 2007-07-29 17:13:26 by f0dder</div>
   </div>
   <div class="post" id="post-189994">
    <div class="subject"><a href="#post-189994">Re: MACRO to replace IMUL with LEA, SHL, ADD</a></div>
    <div class="body">Yes, I remember your advice from the other forum but seems that my disclaimer was not enough to avoid the suggestion ;)<br /><br />I added it, but I can&#39;t assure if it is right because I don&#39;t remember how you did it.</div>
    <div class="meta">Posted on 2007-07-29 17:51:18 by LocoDelAssembly</div>
   </div>
   <div class="post" id="post-189996">
    <div class="subject"><a href="#post-189996">Re: MACRO to replace IMUL with LEA, SHL, ADD</a></div>
    <div class="body">I think everybody should be more supportive. Not about the actual code but about people&#39; ideas. We are told everyday about the magic new hardware can do, etc. We do not need to be the optmization freaks all the time also. ASM is also about reinventing the wheel, since most of you, or at least me myself, write some code in another language (even on paper) before trying to do the same on asm.<br /><br />XCHG: Maybe just the title of the topic was misunderstood. Maybe &quot;alternative&quot; instead of &quot;replace&quot; would be better but anyway I believe you guys are sometimes too cold hearted on simple ideas. I learn a lot from each line of code everybody puts up and it is good to know people still put some effort on trying to discover new ways of doing things (of all sorts), specially when programming is not my living it is good to see it. Sometimes I see people asming for 16bit also. I think there are even many information about it around somewhere. Well I hope you understand my point. I also love Symphony X but a community should be made of chances for everybody to show off work. Or so I think. Not sure if you guys agree with me or not.</div>
    <div class="meta">Posted on 2007-07-29 20:51:44 by codename</div>
   </div>
   <div class="post" id="post-189998">
    <div class="subject"><a href="#post-189998">Re: MACRO to replace IMUL with LEA, SHL, ADD</a></div>
    <div class="body">I agree with codename. Imho aleksaZR&#39;s macro just needs polishing: <br />1) we should see the speed results of all supported numbers in mult, compared to imul. Like the ones I posted. Though, in my case I simply spent several minutes recompiling and running the app for each number ^^. The needed data to obtain this way is - with which numbers mult is faster than imul on all/most cpus. <br />2) change the mult macro to support only the faster-than-imul versions<br />3) also make a mult2 macro, which accepts 3 parameters (dest,temp,imm) - where &quot;temp&quot; will remove the need for stack-usage. This optimization won&#39;t be noticed as an improvement in the synthetic benchmarks, but can give an extra cycle or two (we save the write-back to memory, after all). </div>
    <div class="meta">Posted on 2007-07-29 22:28:07 by Ultrano</div>
   </div>
   <div class="post" id="post-189999">
    <div class="subject"><a href="#post-189999">Re: MACRO to replace IMUL with LEA, SHL, ADD</a></div>
    <div class="body">I&#39;ve changed the mult macro to support only the faster-than-imul versions, as Ultrano suggested.<br />Same-as-imul versions are also included, for the sake of some older CPUs.<br /><br />You can now get a new mult, an alternative to imul;) and use it if you like it.<br /><br />Thanks, everyone<br /><br />P.S.<br />Ultrano also suggested mult2 which would use a register instead of a stack.<br />That, at least on my CPU, didn&#39;t give much more speed,<br />60 mS instead of 75 mS (mult with 7).<br /><br />Also, using the stack allows to multiply by, say 77, 7*11.<br />Both 7 and 11 would use the stack, esp-4 and esp-8, which would probably<br />be harder with the regs.<br /><br />Anyway, since the newer CPUs do IMUL just fine, I&#39;ve deleted all stack usage.<br /></div>
    <div class="meta">Posted on 2007-07-30 02:37:59 by aleksaZR</div>
   </div>
   <div class="post" id="post-190065">
    <div class="subject"><a href="#post-190065">Re: MACRO to replace IMUL with LEA, SHL, ADD</a></div>
    <div class="body">hello Aleksandre,<br />i also wrote a mul replacement recursive macro.<br />might be useful.<br />http://www.asmcommunity.net/board/index.php?topic=20441.0</div>
    <div class="meta">Posted on 2007-08-07 17:33:01 by drizz</div>
   </div>
  </div>
 </body>
</html>