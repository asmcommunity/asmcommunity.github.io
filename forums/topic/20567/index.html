<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Quaternion Multiply - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20567" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=20567">Quaternion Multiply</a></p>
   <div class="post" id="post-157076">
    <div class="subject"><a href="#post-157076">Quaternion Multiply</a></div>
    <div class="body">I've recently written two quite different implementations of firstperson camera that use Quaternions to perform rotations.<br />Neither worked, they appeared to suffer a common bug (the results onscreen were identical). The only thing they had in common was a code module providing quaternion math functions that I'd written earlier.<br /><br />For starters, here is the formula for QuatMultiply (gleaned from the net) apon which I based my code - is it correct?<br /><br /><pre><code><br />Assuming two input quaternions &#40;A and B&#41;, find C = A . B<br /><br />C.x = | A.w*B.x + A.x*B.w + A.y*B.z - A.z*B.y |<br />C.y = | A.w*B.y - A.x*B.z + A.y*B.w + A.z*B.x |<br />C.z = | A.w*B.z + A.x*B.y - A.y*B.x + A.z*B.w |<br />C.w = | A.w*B.w - A.x*B.x - A.y*B.y - A.z*B.z |<br /></code></pre><br /><br />Now, here is my implementation of the above formula. Is it correct?<br /><pre><code><br />QuaternionMultiply proc uses esi edi ecx pA, pB, pC<br />mov esi,pA<br />mov edi,pB<br />mov ecx,pC<br />assume esi&#58;ptr CQuaternion<br />assume edi&#58;ptr CQuaternion<br />assume ecx&#58;ptr CQuaternion<br /><br />;C.x = | A.w*B.x + A.x*B.w + A.y*B.z - A.z*B.y |<br />fld &#91;esi&#93;.fW<br />fmul &#91;edi&#93;.fX<br />fld &#91;esi&#93;.fX<br />fmul &#91;edi&#93;.fW<br />fadd<br />fld &#91;esi&#93;.fY<br />fmul &#91;edi&#93;.fZ<br />fadd<br />fld &#91;esi&#93;.fZ<br />fmul &#91;edi&#93;.fY<br />fsub<br />fstp &#91;ecx&#93;.fX<br /><br />;C.y = | A.w*B.y - A.x*B.z + A.y*B.w + A.z*B.x |<br />fld &#91;esi&#93;.fW<br />fmul &#91;edi&#93;.fY<br />fld &#91;esi&#93;.fX<br />fmul &#91;edi&#93;.fZ<br />fsub<br />fld &#91;esi&#93;.fY<br />fmul &#91;edi&#93;.fW<br />fadd<br />fld &#91;esi&#93;.fZ<br />fmul &#91;edi&#93;.fX<br />fadd<br />fstp &#91;ecx&#93;.fY<br /><br />;C.z = | A.w*B.z + A.x*B.y - A.y*B.x + A.z*B.w |<br />fld &#91;esi&#93;.fW<br />fmul &#91;edi&#93;.fZ<br />fld &#91;esi&#93;.fX<br />fmul &#91;edi&#93;.fY<br />fadd<br />fld &#91;esi&#93;.fY<br />fmul &#91;edi&#93;.fX<br />fsub<br />fld &#91;esi&#93;.fZ<br />fmul &#91;edi&#93;.fW<br />fadd<br />fstp &#91;ecx&#93;.fZ<br /><br />;C.w = | A.w*B.w - A.x*B.x - A.y*B.y - A.z*B.z |<br />fld &#91;esi&#93;.fW<br />fmul &#91;edi&#93;.fW<br />fld &#91;esi&#93;.fX<br />fmul &#91;edi&#93;.fX<br />fsub<br />fld &#91;esi&#93;.fY<br />fmul &#91;edi&#93;.fY<br />fsub<br />fld &#91;esi&#93;.fZ<br />fmul &#91;edi&#93;.fZ<br />fsub<br />fstp  &#91;ecx&#93;.fW<br /><br />assume esi&#58;nothing<br />assume edi&#58;nothing<br />assume ecx&#58;nothing<br />ret<br />QuaternionMultiply endp<br /></code></pre><br /><br />Does everything here look right?<br />TIA, Homer.</div>
    <div class="meta">Posted on 2005-02-16 02:50:39 by Homer</div>
   </div>
   <div class="post" id="post-157077">
    <div class="subject"><a href="#post-157077">Quaternion Multiply</a></div>
    <div class="body">Two other formulas for QuaternionMultiply:<br /><br />;this one is correct<br /><pre><code><br />Cx = Ax*Bw + Ay*Bz - Az*By + Aw*Bx <br />Cy = - Ax*Bz + Ay*Bw + Az*Bx + Aw*By <br />Cz = Ax*By - Ay*Bx + Az*Bw + Aw*Bz <br />Cw = - Ax*Bx - Ay*By - Az*Bz + Aw*Bw <br /></code></pre><br />;this one must work also, not tested though...<br /><pre><code><br />Cx = Ax*Bw + Aw*Bx + Az*By + Ay*Bz <br />Cy = Ay*Bw + Aw*By + Ax*Bz + Az*Bx <br />Cz = Az*Bw + Aw*Bz + Ay*Bx + Ax*By <br />Cw = Aw*Bw + Ax*Bx + Ay*By + Az*Bz<br /></code></pre></div>
    <div class="meta">Posted on 2005-02-16 05:36:37 by Siekmanski</div>
   </div>
   <div class="post" id="post-157079">
    <div class="subject"><a href="#post-157079">Quaternion Multiply</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br />Code seems fine.<br /><br />Are you sure the sourcecode example you found on Gamedev.net actually works as intended? Reading through the comments on the article shows at least one person had to &quot;fix&quot; the code to make it work correctly.<br /><br />I've seen Quaternion code for rotating cameras which <em>don't</em> supply GimbalLock, even though Quaternions are supposed to do that easily.<br /><br />Are you still keen on using a Quaternion method, or would this one be easier?<br /><a target="_blank" href="http://www.asmcommunity.net/board/viewtopic.php?t=16454">http://www.asmcommunity.net/board/viewtopic.php?t=16454</a><br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2005-02-16 05:54:11 by Scronty</div>
   </div>
   <div class="post" id="post-157080">
    <div class="subject"><a href="#post-157080">Quaternion Multiply</a></div>
    <div class="body">Thanks for the replies.<br />The first source I tried was the GameDev one, which uses glLookAt to apply the camera perspective. It's a bit long-winded imho.<br />The second one I tried was from NeHe and applies perspective by concatenating the combined rotation matrix (from Quat) to the model matrix using glMatrixMultf. The code is much shorter, and the camera requires less data, ie we don't need stuff like &quot;vStrafe&quot; anymore.<br /><br />I too had to &quot;fix&quot; the code to make it work.<br />Most of the errors were obvious, some were less so.<br />I made some small optimizations to the procs (when I translate C/C++ to asm literally, some optimizations are glaringly obvious, and I can't stand redundancy in clearcode blocks).<br />The main errors which were wigging me were both in the Quaternion math as I suspected. The functions to convert quat--&gt;matrix and to multiply quats were both in error - the formulae were bad. Damn the disinformation out there, my code was fine  :roll: <br /><br />I found yet another alternative formula for the Multiply:<br /><br />NeHe (WORKS)<br />Cx = Aw*Bx + Ax*Bw + Ay*Bz - Az*By;<br />Cy = Aw*By + Ay*Bw + Az*Bx - Ax*Bz;<br />Cz = Aw*Bz + Az*Bw + Ax*By - Ay*Bx;<br />Cw = Aw*Bw - Ax*Bx - Ay*By - Az*Bz;<br /><br />Compared to these:<br /><br />Siekmanski #1 (WORKS)<br />Cx = Ax*Bw + Ay*Bz - Az*By + Aw*Bx <br />Cy = - Ax*Bz + Ay*Bw + Az*Bx + Aw*By <br />Cz = Ax*By - Ay*Bx + Az*Bw + Aw*Bz <br />Cw = - Ax*Bx - Ay*By - Az*Bz + Aw*Bw <br /><br />Siekmanski#2 (UNTESTED)<br />Cx = Ax*Bw + Aw*Bx + Az*By + Ay*Bz <br />Cy = Ay*Bw + Aw*By + Ax*Bz + Az*Bx <br />Cz = Az*Bw + Aw*Bz + Ay*Bx + Ax*By <br />Cw = Aw*Bw + Ax*Bx + Ay*By + Az*Bz<br /><br />I also found an error in the formula for &quot;CreateMatrix&quot; (convert quat to matrix) , the alternative formula for this (NeHe) works.<br /><br />My quat camera is working, I'll post the source in the gamecoding forum for suggestions to improve it. At the moment, time has no bearing on camera movement, which needs to be remedied (camera physics 101)<br /><br />Scronty - I've discovered that quaternions, like matrices, are a tool.<br />Like matrices, are non commutative.<br />Like matrices, can perform various transformations.<br />Like matrices, offer shortcuts to those familiar with the structure.<br />Like matrices, can cause loads of headaches when applied incorrectly.<br /><br />I can see how you could gimbal lock with quatrot.<br />You would however be applying quatrot incorrectly to achieve this.<br />Nonetheless, it took me three tries to get it right, even with source (in C) on offer.<br />Third time is a charm :)<br /><br />Yes Scronty, there's a REALLY good reason why I wanted to get quatrot working, and it's only partly to do with camera.<br />In a nutshell, I want to implement QuatSlerp, and I intend to test my slerp code by slerping the camera between first and thirdperson views over a second or two of time.<br />It's possible to slerp between any two complex matrices if you convert them to quats, and the possibilities are interesting to say the least.</div>
    <div class="meta">Posted on 2005-02-16 06:09:56 by Homer</div>
   </div>
  </div>
 </body>
</html>