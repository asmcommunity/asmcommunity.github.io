<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Thoughts on huffman decoding - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4183" />
    <link rel="next" href="../?id=4183&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=4183">Thoughts on huffman decoding</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=4183&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=4183&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="4183" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=4183&amp;page=2">&gt;</a><a href="../?id=4183&amp;page=2">&raquo;</a></form>   <div class="post" id="post-28787">
    <div class="subject"><a href="#post-28787">Thoughts on huffman decoding</a></div>
    <div class="body"><strong>warning: large post ;)</strong><br /><br />I've been reading some PNG specifications lately to see how hard it would be to write a library for it (just like my giflib), particulary the huffman decoding.<br />PNG uses a combination of LZ77 (an algorithm that uses pointers to already outputted strings to reduce redundant data) and huffman encoding.<br /><br />Huffman codes are bit sequences of any size, each one representing a symbol in from the alphabet (abc, bytes 0-255, anything you want). These bit codes are chosen in a way that when a sequence of bit codes is made, the decoder can still seperate the codes without the need of a seperator.<br />A small example is:<br />A: 00<br />B:   1<br />C: 011<br />D: 010<br />BCBBDA would be: 10111101000<br />When the code table above is known, you can split this bit sequence into the symbols it represents, although there aren't any separators between the symbols.<br /><br />RFC1951, a document which describes the 'deflate' compression format, shows a method to generate huffman codes based on a frequency list for the bitlengths.<br />For example, the example above can be described in bit lengths as {2,1,3,3}: 2 bits for A (00), 1 bit for B (1), 3 bits for C (011) and 3 bits for D (010). <br />Put these frequency of each bit length in an array (bl_count) like this:<br /><br /><pre><code><br />bl_count = &#123;0,1,1,2&#125;;</code></pre><br />This means:<br />0-bit length: occurs zero times (not used)<br />1-bit length: occurs once (namely for B)<br />2-bit length: occurs once (namely for A)<br />3-bit length: occurs twice (for C and D)<br /><br />Then put the bit lengths themselves in an array as well:<br />(note: the code I show here is slightly different from the one in the RFC)<br /><pre><code><br />bit_lengths&#91;&#93; = &#123;2,1,3,3&#125;; // 2 for A, 1 for B, 3 for C, 3 for D<br /></code></pre><br /><br />Now you can generate the codes (bit_codes[]) for each symbol with this code:<br /><pre><code><br />MAX_BITS = 3; // longest is 3 bits<br />MAX_CODE = 4; // 4 symbols in alphabet<br />next_code&#91;MAX_BITS&#93;;<br />code = 0;<br />for &#40;bits=1;bits &lt;= MAX_BITS;bits++&#41;<br />&#123;<br />    code = &#40;code + bl_count&#91;bits-1&#93;&#41; &lt;&lt; 1;<br />    next_code&#91;bits&#93; = code;<br />&#125;<br /><br />for &#40;n=0;n&lt;MAX_CODE;n++&#41;<br />&#123;<br />    len = bit_lengths&#91;n&#93;;<br />    if &#40;len!=0&#41;<br />    &#123;<br />        bit_codes&#91;n&#93; = next_code&#91;len&#93;;<br />        next_code&#91;len&#93;++;<br />    &#125;<br />&#125;<br /></code></pre><br /><br />The first for loop creates the code bases for each code length. The rest of the codes for each code length are generated by just increasing the base by one for every code (the second loop).<br />In this case:<br />next_code table after first for:<br /><pre><code><br />next_code&#91;2&#93; =   00b<br />next_code&#91;3&#93; =  010b<br />next_code&#91;4&#93; = 1110b<br /><br />&#40;the other next_code values are filled in but not valid nor used&#41;<br /></code></pre><br /><br />The actual code can be generated by taking the base (next_code) for a length, an increasing it for each new code:<br /><pre><code><br />2 bit codes&#58;<br />00<br />3 bit codes&#58;<br />010<br />011<br />100<br />101<br />110<br />4 bit codes&#58;<br />1110<br />1111<br /></code></pre><br /><br />That's the basic idea behind it, for more details read the RFC (1950+1951).<br /><br />Now, the code stream is a sequence of these codes. I was thinking of how I could implement this in the fastest way possible. Just storing all codes in several arrays would require a lot of look-ups and memory access, which is slow. I searched for a method to determine which bit length the next code has, before doing a look-up for the corresponding value. So I examined the code generation algorithm described above closer, and found something interesting:<br /><br />code = (code = bl_count) &lt;&lt; 1;<br /><br />Each code base (next_code) for a given bit length is based on the previously generated code base and the frequency of the previously generated bit length (the number of times that bit length is used).<br /><br />&quot;code base + frequency&quot; gives one more than the maximum code for that bit length. In the example above, the bit length 3 was used 5 times. The code base was 010b. 010b + 5 = 111b.<br />111b is one more than the highest code generated with length 3 (110, see above).<br />This value is then shifted left once, a zero bit is appended:<br />111b SHL 1  = 1110b. <br /><br />Because this are huffman codes, you should be able to distinguish a 3-bit code from a 4-bit code. <br />If you would treat the sequence 1110b as a 3 bit code: 111b, you will see that it does not fall into the range used by 3 bit codes (as 110 is the highest value). Each code is based on maximum previous code + 1 (and thus out of range), shifted left by one. So when you don't read enough bits (say 3 instead of 4), a simple range check will show that the code can never be a 3 bit code.<br /><br />A decoder algorithm for the example codes above could be this:<br /><pre><code><br />xor     eax, eax<br /><br />shift 2 bits into eax &#40;2 bits from input stream, shift in from the LSB&#41;<br /><br />cmp     eax, 01b    ;max 2-bit code + 1<br />jb      @its_a_2_bit_code<br /><br />shift 1 bit more into eax<br /><br />cmp     eax, 111b   ;max 3-bit code + 1<br />jb      @its_a_3_bit_code<br /><br />shift 1 bit more into eax<br /><br />@its_a_4_bit_code&#58;<br />lookup value of eax into 4-bit code table<br /><br />@its_a_3_bit_code&#58;<br />lookup value of eax into 3-bit code table<br /><br />@its_a_2_bit_code&#58;<br />lookup value of eax into 2-bit code table<br /></code></pre><br /><br />There are several problems here:<br /><br />Huffman codes are packed like this:<br /><pre><code><br />huffman codes&#58; ABCD, EF, GHIJKL &#91;msb to lsb&#93;<br />byte sequence&#58;<br />1st byte&#58; HGFEDCBA   &#91;msb to lsb&#93;<br />2nd byte&#58; ??LKJIHG   &#91;msb to lsb&#93;<br /></code></pre><br /><br />So, 'shifting in a bit into eax on the right', means that you first have to get a bit from the input sequence and then shift it into eax (reversed order). Assuming ecx contains the next 32 bits from the input stream:<br />shr ecx, 1<br />rlc eax, 1<br /><br />This shifts in one bit, using the carry as temporary buffer. This is okay for 1 bit, but for 5 bits you need to do this 5 times... Say for example that only 2 and 10 bit codes are used. After you've checked that it isn't a 2 bit code, you need to shift in 8 bits, in reversed order compared to the input stream.<br /><br />Second problem: in the code above I used hardcoded values but of course these depend on the code tables. I was thinking about a piece of self modifying code to 'compile' the bit-detection into executable code. If I won't do this, I would still require to look up the bit frequencies. <br /><br />I'd like to hear your opinions (if you made it through here ;) ) on this algorithm, especially alternatives for the bit shifting (reversing order, but for any length), and the implementation of the range checks (SMC? smart lookup tables?)<br /><br />Thomas<br /><br />P.S. I think this is my longest post ever :grin:</div>
    <div class="meta">Posted on 2002-03-13 10:26:14 by Thomas</div>
   </div>
   <div class="post" id="post-28791">
    <div class="subject"><a href="#post-28791">Thoughts on huffman decoding</a></div>
    <div class="body">Here's another example. ecx holds the next 32 input bits, when done, edx will hold the value represented by the first huffman code in the stream, using the code table below:<br /><br /><pre><code><br />3-bit codes&#58;<br />000<br />001<br />010<br />011<br /><br />5-bit codes&#58;<br />10000     <br />10001     <br />10010     <br /><br />8-bit codes&#58;<br />10011000  <br />10011001  <br />10011010  <br />10011011  <br />10011100<br /><br />10-bit codes&#58;<br />1001110100<br />1001110101<br /><br /><br />; Assumes ecx contains the next 32 bits of input data<br /><br />xor eax, eax<br /><br />;shift 3 bits into eax<br />shr ecx, 1<br />rcl eax, 1<br />shr ecx, 1<br />rcl eax, 1<br />shr ecx, 1<br />rcl eax, 1<br /><br />cmp eax, 011b + 1 <br />jb  @its_a_3_bit_code<br /><br />;shift 2 bits into eax<br />shr ecx, 1<br />rcl eax, 1<br />shr ecx, 1<br />rcl eax, 1<br /><br />cmp eax, 10010b + 1 <br />jb  @its_a_5_bit_code<br /><br />;shift 3 bits into eax<br />shr ecx, 1<br />rcl eax, 1<br />shr ecx, 1<br />rcl eax, 1<br />shr ecx, 1<br />rcl eax, 1<br /><br /><br />cmp eax, 10011100b + 1 <br />jb  @its_an_8_bit_code<br /><br />@its_a_3_bit_code&#58;<br />mov  edx, lookUp3bit&#91;eax*4 - 4*0&#93;      ; 0 is 3-bit code base<br />jmp @done<br /><br />@its_a_5_bit_code&#58;<br /><br />mov  edx, lookUp5bit&#91;eax*4 - 4*10000b&#93; ;10000b is 5-bit code base<br />jmp @done<br /><br />@its_an_8_bit_code&#58;<br /><br />mov  edx, lookUp8bit&#91;eax*4 - 4*10011000b&#93; ; 10011000b is 8-bit code base<br />jmp @done<br /><br />@its_a_10_bit_code&#58;<br /><br />mov  edx, lookUp10bit&#91;eax*4 - 4*1001110100b&#93; ; 1001110100 is 10-bit code base<br />;jmp @done<br />@done&#58;<br /></code></pre></div>
    <div class="meta">Posted on 2002-03-13 10:43:00 by Thomas</div>
   </div>
   <div class="post" id="post-28798">
    <div class="subject"><a href="#post-28798">Thoughts on huffman decoding</a></div>
    <div class="body"><strong>Thomas</strong>, that was a good read.  PNG is asm would be a great work.  I'm wondering if there is some multiply trick to reverse bits? (quite sure there is but can't do the math right now : I think 2 MUL + 2 AND)  I think a look-up table has been used in the past for bit reversals.  Can't wait to see more of what you got cooking!</div>
    <div class="meta">Posted on 2002-03-13 11:40:44 by bitRAKE</div>
   </div>
   <div class="post" id="post-28802">
    <div class="subject"><a href="#post-28802">Thoughts on huffman decoding</a></div>
    <div class="body"><div class="quote"><br />Thomas, that was a good read. PNG is asm would be a great work. I'm wondering if there is some multiply trick to reverse bits? (quite sure there is but can't do the math right now : I think 2 MUL + 2 AND) I think a look-up table has been used in the past for bit reversals. Can't wait to see more of what you got cooking! </div><br /><br />I have seen some trick for 8-bit numbers (forgot where though :) ), but the problem is that the number of bits to swap is variable. <br /><br />I think a piece of self modifying code would be very fast. All known values can be hardcoded, so there won't be any memory access, even optimization is possible.<br />As I know how many bits I want to shift, the proper  algo for that number could be inserted..<br /><br />For small bit sequences (say 3 bits), maybe it's possible to do a look up inside a register (without memory access):<br /><pre><code><br />	bits	reversed<br />0	000	000<br />1	001	100<br />2	010	010<br />3	011	110<br />4	100	001<br />5	101	101<br />6	110	011<br />7	111	111<br /><br />Reversed bits left padded with a zero bit&#58;<br />0000<br />0100<br />0010<br />0110<br />0001<br />0101<br />0011<br />0111<br /><br />all bits concatenated, right to left&#58;<br /><br />01110011010100010110001001000000b<br /><br />; 3 bits to invert are in LS bits of ECX &#40;all other bits are zeroed&#41;&#58;<br /><br />mov  esi, 01110011010100010110001001000000b<br />shl ecx, 2<br />shr  esi, ecx<br />and esi, 111b<br /><br />; esi holds inverted bits<br /><br /></code></pre><br /><br />however I don't know if that will be any faster than 3 SHR/RCLs, and the input stream needs to be shifted anyway.<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-13 12:00:43 by Thomas</div>
   </div>
   <div class="post" id="post-28805">
    <div class="subject"><a href="#post-28805">Thoughts on huffman decoding</a></div>
    <div class="body">I found this one somewhere for 8-bits:<br /><pre><code><br />  mov ah,al        ;76543210 76543210<br />  add al,al        ;76543210 65432100<br />  shr ah,1         ;07654321 65432100<br />  and ax,55AAh     ;07050301 60402000<br />  or  al,ah        ;07050301 67452301<br />  mov ah,al        ;67452301 67452301<br />  ror al,2         ;67452301 01674523<br />  rol ah,2         ;45230167 01674523<br />  and ax,33CCh     ;00230067 01004500<br />  or  al,ah        ;00230067 01234567<br /></code></pre></div>
    <div class="meta">Posted on 2002-03-13 12:13:34 by Thomas</div>
   </div>
   <div class="post" id="post-28816">
    <div class="subject"><a href="#post-28816">Thoughts on huffman decoding</a></div>
    <div class="body">I've been trying to figure out a short and tricky way to reverse a byte...  to no avail.<br /><br />At this point I would create a 256 byte table with each value's reverse value and use the byte itself as the index.<br /><br /><br />something like<br /><br /><pre><code><br />.data<br />	_lookuptable db 00h, 80h, 40h, C0h, ......<br /><br /><br /><br />.code<br />reverseDword proc _dword&#58;DWORD<br /><br />	mov eax, _dword<br />	mov edx, offset _lookuptable<br /><br />	movzx ecx, al<br />	mov al, byte ptr &#91;edx + ecx&#93;<br />	movzx ecx, ah<br />	mov ah, byte ptr &#91;edx + ecx&#93;<br /><br />	bswap eax<br /><br />	movzx ecx, al<br />	mov al, byte ptr &#91;edx + ecx&#93;<br />	movzx ecx, ah<br />	mov ah, byte ptr &#91;edx + ecx&#93;<br /><br />	ret<br /><br />reverseDword endp<br /></code></pre><br /><br /><br />256 bytes might be too much for some people though, but the tradeoff is it would be faster than doing 32 shifts and rotates.</div>
    <div class="meta">Posted on 2002-03-13 13:32:59 by iblis</div>
   </div>
   <div class="post" id="post-28818">
    <div class="subject"><a href="#post-28818">Thoughts on huffman decoding</a></div>
    <div class="body">Thanks for your code .. I think the maximum number of bits I need to swap is 16.. The code I posted for switching 8 bits takes 5 cycles on my athlon, and doesn't use memory..<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-13 13:45:27 by Thomas</div>
   </div>
   <div class="post" id="post-28828">
    <div class="subject"><a href="#post-28828">Thoughts on huffman decoding</a></div>
    <div class="body">I should look at the docs for PNG to see how huffman (this is my mothers family name Huffman :)) is used, but I thought I'd ask anyway:<br /><br />For the SMC method, does this have to be generated for each picture only once, or is the table allowed to be reset - so that anytime in the stream you might have to re-generate the SMC code.  I assume the latter, else it wouldn't be any good. :)  This aasumption leads me to think SMC isn't a good idea.</div>
    <div class="meta">Posted on 2002-03-13 14:30:00 by bitRAKE</div>
   </div>
   <div class="post" id="post-28829">
    <div class="subject"><a href="#post-28829">Thoughts on huffman decoding</a></div>
    <div class="body">Just in case anyone's still interested in a dword bitswap,  I found this:<br /><br /><pre><code><br />;in  - eax<br />;out - eax<br /><br />	bswap eax<br />	mov edx,eax<br /><br />	and eax,00F0F0F0Fh<br />	xor edx,eax<br />	rol eax,8<br />	or eax,edx<br />	mov edx,eax<br /><br />	and eax,033333333h<br />	xor edx,eax<br />	rol eax,4<br />	or eax,edx<br />	mov edx,eax<br /><br />	and eax,055555555h<br />	xor edx,eax<br />	rol eax,2<br />	or eax,edx<br />	ror eax,7<br /><br /></code></pre><br /><br />I don't know how fast it is, but I see a lot of opportunities for optimisation.</div>
    <div class="meta">Posted on 2002-03-13 14:32:56 by iblis</div>
   </div>
   <div class="post" id="post-28843">
    <div class="subject"><a href="#post-28843">Thoughts on huffman decoding</a></div>
    <div class="body"><div class="quote">For the SMC method, does this have to be generated for each picture only once, or is the table allowed to be reset - so that anytime in the stream you might have to re-generate the SMC code. I assume the latter, else it wouldn't be any good.  This aasumption leads me to think SMC isn't a good idea.</div><br /><br />Well the compressed stream consists of blocks, each block has it's own huffman table, and blocks can be of any size. So it's up to the encoder... <br /><br />I've considered this as well, it's hard to get an idea of the overhead for SMC. You need to calculate the huffman codes anyway, and decoding the stream requires looking up these codes. When the decoding code is hardcoded, executing it would be quite fast.. So I think it depends on the overhead for setting up the code.<br />The code is relatively easy to build, just a bunch of cmp, jump and mov opcodes, apart from some nasty problems like short/long variations of opcodes (mov eax,4 is smaller than mov eax, 100h).<br />Iirc, there are also some problems with executing memory which just has been written to.<br /><br />Do you have any ideas about a good alternative which doesn't require much memory look-ups (or efficient ones)?<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-13 15:50:46 by Thomas</div>
   </div>
   <div class="post" id="post-28848">
    <div class="subject"><a href="#post-28848">Thoughts on huffman decoding</a></div>
    <div class="body">No I don't have any bright ideas, but I haven't beat my head against the wall either. :)  How big are the blocks?  SMC could be the way to go if the generated code is fast enough to overcome the generation overhead.  (You know this, I'm just stating the obvious :))  mov eax,4 is the same size as mov eax, 100h :)<br /><br />How about you create the SMC code, and I'll do the non-SMC code?</div>
    <div class="meta">Posted on 2002-03-13 16:04:02 by bitRAKE</div>
   </div>
   <div class="post" id="post-28855">
    <div class="subject"><a href="#post-28855">Thoughts on huffman decoding</a></div>
    <div class="body"><div class="quote"><br />No I don't have any bright ideas, but I haven't beat my head against the wall either.  How big are the blocks? </div><br /><br />That's the problem, they can be any size. There's no restriction on them (except for non-compressed blocks, they have a limit of 32kb iirc). It's up to the encoder, it probably chooses a block size that contains similair pixels.<br /><br /><div class="quote">SMC could be the way to go if the generated code is fast enough to overcome the generation overhead. (You know this, I'm just stating the obvious )</div><br /><br />Generating it isn't to hard, the only problem is the variable sizes some opcodes have, it makes calculating relative jump offset harder. Of course I could choose to only use the larger version of each opcode but short ones are better as more can be read at the same time by the processor.<br /><br /><div class="quote">mov eax,4 is the same size as mov eax, 100h</div><br /><br />Sorry, I meant cmp eax, 4 is different from cmp eax, 100h.. :rolleyes:<br /><br /><div class="quote">How about you create the SMC code, and I'll do the non-SMC code?</div><br /><br />Sounds great, I'm still struggling with the decoded data.. I created some test PNG (with sizes like 10x1 or 5x1) and tried to decode them manually. The results didn't make sense to me though and some things from the PNG specs are not quite clear to me. If I would succeed in decoding a simple PNG image manually, I would be sure I understand it.<br /><br />I have had a quick look at the rest of the PNG format, most of it doesn't seem hard to code, although I think I'm not going to support interlaced PNGs (maybe later), as their ouput pattern makes coding it (especially optimizing it) much harder.<br /><br />I think I'm going to code some functions for huffman code generation etc., so I can play around with it. I'll mail you the code if I have created something useful.<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-13 16:29:16 by Thomas</div>
   </div>
   <div class="post" id="post-28857">
    <div class="subject"><a href="#post-28857">Thoughts on huffman decoding</a></div>
    <div class="body">Maybe this .pdf could help. It's very straight forward, even though it might not be the best solution there is at least you could get some ideas. I was suppose to include this example on my btrees but maybe you could make some fast huffman decoder codes out of it. :)</div>
    <div class="meta">Posted on 2002-03-13 16:35:43 by stryker</div>
   </div>
   <div class="post" id="post-28859">
    <div class="subject"><a href="#post-28859">Thoughts on huffman decoding</a></div>
    <div class="body">stryker: Thanks for the document, I'll have a look at it.. First some sleep :)<br /><br />I managed to decode an image myself, I made a mistake with the bits per pixel (it was 4 instead of 8 :rolleyes: ).<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-13 16:51:00 by Thomas</div>
   </div>
   <div class="post" id="post-28921">
    <div class="subject"><a href="#post-28921">Thoughts on huffman decoding</a></div>
    <div class="body">I did a quick test (with bitRAKEs code for testing small code pieces) of SMC. I commited a new page (execute, read&amp;write access), write C3909090h to it (nop,nop,nop,retn) and call it.<br /><br />When I write that dword *before* the loop, the code takes 1~2 cycles on my athlon. With the memory write *inside* the loop, it takes 785 cycles!<br /><br />So there seems to be a penalty for executing memory you just wrote to. Of course in my case I only need to write it once and then loop the execution, however 785 cycles is quite some overhead.<br /><br />I think SMC might not be the fastest way, unless you have really large blocks but you don't know the block size beforehand as the length is determined by the 'end of block' code which is encoded itself as well. <br /><br />Also, the huffman table (in case of custom codes) is huffman encoded as well :rolleyes:, so you need to do huffman decoding even for decoding another huffman table, and these are quite small in general.<br /><br />I have some thoughts on using several memory look-ups, and how to use them efficiently. I'll post some ideas later this day.<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-14 01:51:29 by Thomas</div>
   </div>
   <div class="post" id="post-28981">
    <div class="subject"><a href="#post-28981">Thoughts on huffman decoding</a></div>
    <div class="body"><strong>Thomas</strong>, you might try writing a larger block of memory (greater than the cacheline size, 64 bytes) to see how the great the penalty is then.  Execution will start at the begining of the SMC code I presume, and the cache latency might have cleared up by then.  Hopefully, that is the only reason for the penalty - dual dirty cacheline round trip.<br /><br />Another good link for Huffman and compression articles is <a target="_blank" href="http://www.arturocampos.com/cp.html">Arturo Campos</a>'s pages.  He is very knowledgable on compression and programming - nice guy too.  :)  I find his explainations very easy to follow.<br /><br />What about programming a FSM for byte values?  The programming seems complex, but it would really fly thought the data - faster than SMC, imo.  I'll see if I can work out some more details. It's similar to a table look-up, but with more data in the table.  Guess that would be really slow? :tongue:<br /><br /><strong>Links</strong>:<br /><a target="_blank" href="http://www.google.com/search?hl=en&amp;ie=ISO-8859-1&amp;oe=ISO-8859-1&amp;q=Sub-Linear+Decoding+of+Huffman+Codes+Almost+In-Place&amp;btnG=Google+Search">http://www.google.com/search?hl=en&amp;ie=ISO-8859-1&amp;oe=ISO-8859-1&amp;q=Sub-Linear+Decoding+of+Huffman+Codes+Almost+In-Place&amp;btnG=Google+Search</a></div>
    <div class="meta">Posted on 2002-03-14 09:57:12 by bitRAKE</div>
   </div>
   <div class="post" id="post-28987">
    <div class="subject"><a href="#post-28987">Thoughts on huffman decoding</a></div>
    <div class="body">I think I'll first try a non-SMC version. I have got an algorithm for the whole decoding in my head, and now I'm trying it out. I tried to minimize use of tables and memory, but due to shortage of registers I'll have to use a few counter variables. Not much though, probably one or two. <br />I have designed a smart lookup table. It consists of dwords, where the higher word of each dword is the (maximum code + 1) for a given bitsize (index in table). The lower word is a forward reference to the table right behind it, holding the values represented by the codes of that bitsize.<br />I'll try to work it out, I make zips of the code when each part is done so I can easily look back to see how I implemented everything.<br /><br />Thanks for the links, I'll have a look there as well.<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-14 10:49:30 by Thomas</div>
   </div>
   <div class="post" id="post-28998">
    <div class="subject"><a href="#post-28998">Thoughts on huffman decoding</a></div>
    <div class="body">Here's the table I worked out. It is used for both determining the length of the next huffman code (using the method described in my first post here), as for looking up the value the code represents.<br /><br /><pre><code><br />step 4.<br /><br />lookup tables LUcodeA and LUcodeB&#58;<br /><br />&#40;LUcodeA is sometimes referenced to as table A,<br /> LUcodeB as table B&#41;<br /> <br />LUcodeB table should be immediately after table LUcodeA.<br /><br />LUcodeA table&#58;<br /><br />Array of DWORDS. The index of the DWORD in this table represents<br />a bit length&#58; index 0 = bitlength 1, index 1 = bitlength 2 and so on.<br />Each DWORD is split into a high word &#40;Q&#41; and a low word &#40;P&#41;.<br /><br />The low word P equals &quot;max_code + 1&quot;, where max_code stands for the<br />highest code in the huffman table for that bit length.<br />This value can be used to check if a huffman code of a given length<br />is valid for the huffman table used. If the code is equal or higher<br />to the value of P, it is not a code of the bit length used at that<br />moment. <br /><br />The high word Q is a forward reference to address R, which resides<br />in LUcodeB. To calculate R, use this formula&#58;<br /><br />R = cur_addr +  2 * &#40;Q  + P - code&#41;<br /><br />where cur_addr stands for the address of the DWORD containing Q and P<br />in table A. Remember that table B comes right after table A. <br />code holds the huffman code to be decoded, the LSB of the huffman code<br />is in the LSB of this value.<br /><br />There is one special case for the value of P&#58; when P is 0, there are<br />no codes of the current bitlength<br /> <br /><br />LUcodeB table&#58;<br /><br />Array of WORDs, each word represents an output code. All possible output<br />values &#40;one for each huffman code&#41; are in this table. The codes are in<br />order of increasing bit size. Codes with the same bit size are ordered<br />descending by value.<br /><br />----------------------------------------------------------------------<br />Example&#58;<br /><br />2 bit codes&#58;<br />00                  represents          B<br />3 bit codes&#58;<br />010                 represents          C<br />011                 represents          D<br />100                 represents          A<br />101                 represents          E                   <br />110                 represents          G<br />4 bit codes&#58;<br />1110                represents          H<br />1111                represents          F<br /><br /><br />-----Table A------<br />offset      value<br />0           P&#58; 0        Q&#58;0     &#40;bitsize 1, not used&#41;<br />4           P&#58; 01b      Q&#58;5     &#40;bitsize 2&#41;<br />8           P&#58; 111b     Q&#58;4     &#40;bitsize 3&#41;<br />12          P&#58; 10000b   Q&#58;7     &#40;bitsize 4&#41;<br />-----Table B------<br />offset      value<br />16          B       &#91;meaning of code 00&#93;<br />18          G       &#91;meaning of code 110&#93;<br />20          E       &#91;meaning of code 101&#93;<br />22          A       &#91;meaning of code 100&#93;<br />24          D       &#91;meaning of code 011&#93;<br />26          C       &#91;meaning of code 010&#93;<br />28          F       &#91;meaning of code 1111&#93;<br />30          H       &#91;meaning of code 1110&#93;<br /><br /><br />Say for example that you know you have a 3 bit code, and the<br />code is 100b &#40; = 4 dec&#41;. The info in table A for a 3 bit<br />code is at index &#40;bitlength-1&#41; = 3 - 1 = 2.<br />Index 2 is at offset 8 &#40;cur_addr = 8&#41;.<br />This gives&#58;<br />    P = 111b &#40;7 dec&#41;<br />    Q = 5 dec<br /><br />Using the formula below&#58;<br /><br />R = cur_addr +  2 * &#40;Q  + P - code&#41;<br />R =     8    +  2 * &#40;4  + 7 - 4&#41;<br />R = 22<br /><br />At offset 24 &#40;in table B&#41; you will find the symbol A. This is the<br />value that the huffman code 100b represents.<br /><br />----------------------------------------------------------------------<br /><br />An asm implementation could be&#58;<br /><br />; assumes ebx points to the right index in table A.<br />; assumes eax holds the current huffman code to be looked up<br />; edx will, on return, hold the value represented by the<br />; huffman code.<br /><br />    mov     edx, &#91;ebx&#93;<br />    neg     eax<br />    add     eax, edx<br />    and     eax, 0ffffh<br />    shr     edx, 16<br />    add     eax, edx<br />    mov     edx, &#91;ebx + 2 * eax&#93;<br />    <br />Or using 16-bit regs&#58;<br /><br />    mov     edx, &#91;ebx&#93;<br />    neg     ax<br />    add     ax, dx<br />    shr     edx, 16<br />    add     eax, edx<br />    mov     edx, &#91;ebx + 2 * eax&#93;<br /></code></pre><br /><br />Thomas</div>
    <div class="meta">Posted on 2002-03-14 12:51:34 by Thomas</div>
   </div>
   <div class="post" id="post-29039">
    <div class="subject"><a href="#post-29039">Thoughts on huffman decoding</a></div>
    <div class="body"><pre><code>    neg     ax<br />    add     ax, &#91;ebx&#93;<br />    add     ax, &#91;ebx + 2&#93;<br />    mov     edx, &#91;ebx + 2 * eax&#93;</code></pre></div>
    <div class="meta">Posted on 2002-03-14 17:09:47 by bitRAKE</div>
   </div>
   <div class="post" id="post-29043">
    <div class="subject"><a href="#post-29043">Thoughts on huffman decoding</a></div>
    <div class="body">&lt;head explodes&gt;</div>
    <div class="meta">Posted on 2002-03-14 17:31:39 by iblis</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=4183&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=4183&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="4183" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=4183&amp;page=2">&gt;</a><a href="../?id=4183&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>