<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Terrain Texture Generation - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25319" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25319">Terrain Texture Generation</a></p>
   <div class="post" id="post-185188">
    <div class="subject"><a href="#post-185188">Terrain Texture Generation</a></div>
    <div class="body">Recently I&#39;ve been using a free texture generator called &#39;T2&#39;.<br />It&#39;s quite good, but has one MAJOR DRAWBACK.<br />It does not attempt to solve staircasing issues arising from the UPSCALING of a HeightMap.<br />The result can be seen in the attached image.<br />As you can see, this is totally unacceptable.<br />I&#39;ve already changed my &#39;height data extraction&#39; code to use bilinear filtered results, but it makes little difference that my GEOMETRY is smooth when the TEXTURE for that geometry is not.<br />Therefore I see little alternative but to revise my own Texture Generator program, implementing the best features of T2 while addressing its fatal flaw.<br /><br />Is anyone interested in being involved in this mini-project?<br />If so, I recommend you download and install T2 and play around with it to see exactly what it is we&#39;re trying to achieve, then post your ideas and pseudocode in this thread for further discussion :)</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2069" target="_blank">killmejagged.jpg</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-09-08 23:13:54 by Homer</div>
   </div>
   <div class="post" id="post-185190">
    <div class="subject"><a href="#post-185190">Re: Terrain Texture Generation</a></div>
    <div class="body">The basic idea is as follows:<br /><br />We have N input heightmap images (as few as ONE).<br />Each heightmap has N input texture images associated with it (as few as TWO).<br />Each texture has a set of BLENDING ATTRIBUTES.<br />The attributes of each texture, along with the height data, determine the INFLUENCE of each input texel with respect to the output texel.<br /><br />Let&#39;s rattle off a quick list of appropriate blending attributes...<br /><br />PRIMARY ATTRIBUTES:<br />-ELEVATION: determines the absolute minimum and maximum Heights where this Texture can exist, for example we might decide that SNOW exists from height 200 to height 255.<br />-SLOPE: limits this texture to appear only within the given SLOPE range, for example Grass won&#39;t grow where it&#39;s too steep.<br /><br />SECONDARY ATTRIBUTES: These influence the Primary Attributes..<br />-ATTACK/DECAY: determines how quickly any given Primary Attribute&#39;s influence fades in and out when outside the given Range.<br /><br />Finally, we need some way to determine the weighting between the input HeightMaps..<br />HEIGHTMAP INFLUENCE: Determines the contribution to the final output image of the per-heightmap texels we calculated.<br /><br />How does that lot sound to you?<br /><br /></div>
    <div class="meta">Posted on 2006-09-08 23:36:36 by Homer</div>
   </div>
   <div class="post" id="post-185195">
    <div class="subject"><a href="#post-185195">Re: Terrain Texture Generation</a></div>
    <div class="body">blending=texture1*blendfactor+texture2*(1-blendfactor)<br />if you blend snow/rock between 195-205 its only 10 steps that gets converted to 0.1 steps, which is causing staircasing, maybe you should convert heightmap to internally work with floats having a smooth range instead of steps and final output anyway is vertices that use floats<br />if you read in pixel at 200 and neighbouring pixel at 205 and you expand it to be bigger the pixel inbetween gonna be 202, not 202.5 if you keep working with bytes<br />should we also assign a minimum of 32*32 pixels are gonna participate in blend between two terrains and test with different minimums until it look good, because if its happen to be only 4 pixels between fullsnow and fullrock its dont gonna look good if we dont expand it to more pixels in either direction to smoother blend<br /></div>
    <div class="meta">Posted on 2006-09-09 00:54:11 by daydreamer</div>
   </div>
   <div class="post" id="post-185196">
    <div class="subject"><a href="#post-185196">Re: Terrain Texture Generation</a></div>
    <div class="body">All of the issues you just mentioned have been addressed, with the exception of DownScaling.<br />The most important issue you mentioned is what I call &#39;hard switching&#39; between different textures, and that&#39;s handled by the implementation of &#39;Attack&#39; and &#39;Decay&#39; influence modifiers.<br /><br />Yes, my own code *DOES* use floating coordinates, *DOES* perform weighting between the closest integer neighbours, etc.<br />The real problem I mentioned with the T2 generator application is that application *DOESN&#39;T* use floating coords when it samples the HeightMap. If it did, I wouldn&#39;t be considering writing a terrain texture generator.<br /><br />The algorithm you proposed is VERY SIMPLISTIC.<br />That&#39;s the algorithm for weghted blending of two pixels from two textures.<br />What if we have N input textures, and what if the weights are nonlinear?<br />Sure, at the end of the day we still use the algo you mentioned, but BEFORE that, we have a much more complex algo for calculating the Weights, taking into account much more than simply the Height.<br /><br />We&#39;re doing a lot more than JUST blending N textures assigned to N Height ranges, we must shift our thinking so that we consider the &#39;INFLUENCE&#39; of each input texel, ie its contribution to the final image based on various attributes of each input texture and indeed the influence of the Heightmap itself, should we use more than one Heightmap (so that we can have Roads and other stuff that &#39;overrides&#39; the standard blending result).<br /></div>
    <div class="meta">Posted on 2006-09-09 01:25:39 by Homer</div>
   </div>
   <div class="post" id="post-185202">
    <div class="subject"><a href="#post-185202">Re: Terrain Texture Generation</a></div>
    <div class="body">homer wrote:The algorithm you proposed is VERY SIMPLISTIC.<br />have to start from basic working things before go advance <br />That&#39;s the algorithm for weghted blending of two pixels from two textures.<br />What if we have N input textures, and what if the weights are nonlinear?<br />you mean x^2 wieghts, what if we all add up N input textures and divide final result with N<br />letting it add together (1/N x texture11 x blendfactor1)+ (1/N xtexture2 xblendfactor2)+ (1/N x texture3 x blendfactor3)<br />when blending highlights <br /><br />so should we implement some catmullsplines between heightmap pixels&nbsp; and normal be used to be one of the weights?<br />weigh terrain against normals look good, mountans with grassy plains is possible with this and can blend one with vertical normals vs horizontal normals make great result with simplified n^2<br />there is a document on this in ATI SDK, doesnt matter its for pixelshaders the math/principle is the same<br /><br /></div>
    <div class="meta">Posted on 2006-09-09 05:49:35 by daydreamer</div>
   </div>
   <div class="post" id="post-185255">
    <div class="subject"><a href="#post-185255">Re: Terrain Texture Generation</a></div>
    <div class="body">This thread is about generating textures for the terrain in software as a preprocessing step, not blending textures in hardware at runtime. This means that rendering the terrain requires no fancy tricks, no alphablending, no special hardware capabilities, just one texture stage, and is as fast as it can possibly be.. this means we can draw more vegetation, more explosions, etc.<br /><br />Adding up the pixel channel components and then dividing by N results in what I&#39;d call &#39;RGB Average&#39;.<br />What we really want to do is multiply each channel component OF EACH PIXEL by a Weighting factor and then add the results.<br />If all the Weights add up to 1.0, then no division is necessary, resulting in a true Weighted Sum.<br /><br />Now, where do we get these Weighting values from?<br />It depends on what we want to achieve.<br />Sure, obviously, we can use the Height data to calculate the Weights, but why stop there? We can introduce more terms into the equation, taking into account Slope and other attributes.<br />We can set up further Weights to give one Texture a greater influence in the output than other(s).<br />Finally, we can have multiple HeightMaps, each with its own set of input Textures, and each HeightMap having a &#39;final weight&#39; controlling the influence of one HeightMap&#39;s SET of Textures relative to the other(s).<br /><br />What I&#39;m really pointing out here is that we can avoid blending pixels and then re-blending them with secondary Weights in order to take into account more than just Height... we can write a UNIFIED EQUATION and derive from it an algorithm which allows us to produce this complex blending while only sampling each pixel ONCE.<br /></div>
    <div class="meta">Posted on 2006-09-11 23:21:04 by Homer</div>
   </div>
   <div class="post" id="post-185277">
    <div class="subject"><a href="#post-185277">Re: Terrain Texture Generation</a></div>
    <div class="body">Update of my Terrain TextureGenerator project..<br />I&#39;ve ripped off a number of concepts from the T2 TextureGenerator.<br />Credit where it&#39;s due :)<br /><br />Note that I&#39;ve hooked up all the GUI controls, but this is NOT a working beta, its a &#39;gamma release&#39;..<br /><br />I&#39;ll attempt to explain the GUI controls and what&#39;s going on behind them..<br /><br />We have a list of HeightMaps.<br />Each HeightMap has a list of input Textures (grass, snow etc).<br /><br />Basically we start by adding one or more HeightMaps and then we can add TO EACH HEIGHTMAP one or more Textures..<br />Selecting a HeightMap or a Texture allows you to view and edit the ATTRIBUTES of the selected entity.<br /><br />For each HeightMap, we can choose an INFLUENCE value.<br />This value is the &#39;master influence per HeighMap&#39;, and is the last weighting to be applied before any pixel is written to the output file(s).<br />The numbers you use are totally unimportant.. your values are summed to produce a &#39;total influence&#39;, the ACTUAL influence applied is &#39;your value divided by the total&#39;.<br />Example: if we have two heightmaps with influence values of 1.0 and 2.0, the total is 3.0, and the ACTUAL applied influences are 1.0/3.0 and 2.0/3.0 respectively.<br />Other influence values are treated similarly.<br /><br />As I mentioned, each HeightMap owns a number of Textures.<br />These textures will be blended together (with respect to the owner HeightMap) to produce output pixels.<br />Each of these Textures has some variables we can use to fine-tune the output pixels:<br />Elevation Range (Min/Max): combined with Height values (sampled from the owner HeightMap), this determines which textures will play a part in the output.. it&#39;s how we can make snow appear on the top of mountains.<br />Elevation Influence: This is used to weight the overall influence of Elevation, ie give greater or lesser priority to our blending textures in regards to Elevation only.<br /><br />Slope Range (Min/Max): combined with Slope values (again obtained from the Heightmap), this can be used to control where our textures will appear, and where they won&#39;t, irrespective of the Elevation.. for example grass won&#39;t grow in places where it is too steep, even if the Elevation is suitable for grass.<br />Slope Influence: This is used to weight the overall influence of Slope, ie give greater or lesser priority to our blending textures in regards to Slope only.<br /><br />The pseudocode for the loops looks something like this:<br /><br />(Drive the outermost loops)<br />For PatchesZ = 0 to NumPatchesZ<br />--For PatchesX = 0 to NumPatchesX<br />----Generate texture for current Patch<br />--EndFor<br />EndFor<br /><br />(Drive the inner loops)<br />For OutputPixelY = 0 to Height-1<br />--For OutputPixelX = 0 to Width-1<br />----For each HeightMap<br />------Sample Height<br />------For each Texture of current HeightMap<br />--------Sample Pixel<br />--------Split Pixel into components<br />--------Apply&nbsp; weights<br />--------Sum components<br />------EndFor<br />------Apply master influence<br />------Recombine components to calculate output pixel<br />------Write pixel to output file<br />----EndFor<br />--EndFor<br />EndFor<br /><br />I would very much appreciate hearing your ideas, criticisms, etc.<br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2072" target="_blank">TerrainTexGen060913.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-09-13 04:45:34 by Homer</div>
   </div>
   <div class="post" id="post-185295">
    <div class="subject"><a href="#post-185295">Re: Terrain Texture Generation</a></div>
    <div class="body">I&#39;ve got the application generating textures now, but there&#39;s a few bugs, which is to be expected..<br />I&#39;ve attached four images from my earliest testing.<br />This isn&#39;t a great-looking example, I&#39;ve chosen textures to help highlight problems in the blending implementation, not to make it look pretty..<br />#1 is the HeightMap I used, its a topology of the planet Mars.<br />#2 is Texture A (Green)<br />#3 is Texture B (Red)<br />#4 is the generated output<br />Note the bright green artefacts which are false &#39;high spots&#39;.. where&#39;d they come from?<br />I haven&#39;t incorporated Slope yet either.<br /><br />Texture A was assigned to elevations from 150 to 255 (&#39;high areas are green&#39;)<br />Texture B was assigned to elevations from 0 to 128 (&#39;low areas are red), and was assigned an Elevation Influence of 1.5 (&#39;more red&#39;)<br />Note that there&#39;s a gap where NO textures are being applied ;)<br />The unassigned height range remains black.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2073" target="_blank">Mars.JPG</a></li>
      <li><a href="../../attachments/?id=2075" target="_blank">green.JPG</a></li>
      <li><a href="../../attachments/?id=2077" target="_blank">red.JPG</a></li>
      <li><a href="../../attachments/?id=2079" target="_blank">test_tex_1_1.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-09-13 21:38:16 by Homer</div>
   </div>
   <div class="post" id="post-185299">
    <div class="subject"><a href="#post-185299">Re: Terrain Texture Generation</a></div>
    <div class="body">I fixed that artefact :)<br />Remember when you look at this texture that the input textures would normally be grass, rock, etc.<br />The attached image (just red, green and heightmap) shows graphically the Blending Weights that would be applied to the input textures.<br /><br />The implementation still isn&#39;t perfect, but it&#39;s getting better.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2081" target="_blank">test_tex_1_1.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-09-14 02:03:57 by Homer</div>
   </div>
   <div class="post" id="post-185320">
    <div class="subject"><a href="#post-185320">Re: Terrain Texture Generation</a></div>
    <div class="body">I&#39;d like to point out one significant difference between my generator and T2 (aside from mine using bilinear filtering at all times), which is that mine generates output textures on a per-output-texture basis, rather than generating a single HUGE texture and then chopping it up as an afterthought.<br />That is to say, all the input textures are sampled with respect to the current output texture, eliminating duplication of pixel fetches.<br /><br />Updated the project some more.<br />A critical bug was detected and fixed in Biterider&#39;s Pixelmap.GetVirtualPixel method !!!<br />The &#39;Save Project&#39; button now works, but I haven&#39;t written the corresponding &#39;Load Project&#39; code.<br /><br />The GUI has some new per-texture blending controls, namely a ComboBox for selecting a &#39;falloff function&#39;, and an editbox for selecting the &#39;falloff range&#39;.. these values are used to determine terrain influence when outside the &#39;Active Elevation Range&#39;.<br /><br />The algorithm used to calculate the influence outside AER was modified, I dumped my algo in favour of Yurdan Gyurchev&#39;s version.<br />Mine faded the Influence over the entire height spectrum, whereas his allows the user to specify the acceptable Range (outside the AER) so that its possible for the user to control how &#39;sharp&#39; the transition is.. I may further modify this algo by allowing the user to specify separate &#39;attack&#39; and &#39;decay&#39; rates, which determine the Influence below and above the AER respectively.<br /><br />I still haven&#39;t implemented Slope weighting, but you&#39;d have to admit that this project is looking more and more like a useful tool :)<br />I&#39;ll worry about the butt-ugly GUI cosmetics when everything is working to my satisfaction.<br /><br />Any feature requests or bugreports would be appreciated :)<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2084" target="_blank">TerrainTexGen060915.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-09-15 01:06:08 by Homer</div>
   </div>
   <div class="post" id="post-185330">
    <div class="subject"><a href="#post-185330">Re: Terrain Texture Generation</a></div>
    <div class="body">This update contains a few bugfixes and improvements.<br /><br />LoadProject and SaveProject are working :)<br />Linear, Sine and Cosine Falloff are working, but I&#39;m not sure I did it right.</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2086" target="_blank">test_1_1.JPG</a></li>
      <li><a href="../../attachments/?id=2094" target="_blank">TerrainTexGen060917.zip</a></li>
      <li><a href="../../attachments/?id=2088" target="_blank">cos.JPG</a></li>
      <li><a href="../../attachments/?id=2090" target="_blank">sin.JPG</a></li>
      <li><a href="../../attachments/?id=2092" target="_blank">linear.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-09-16 11:10:27 by Homer</div>
   </div>
   <div class="post" id="post-185347">
    <div class="subject"><a href="#post-185347">Re: Terrain Texture Generation</a></div>
    <div class="body">Another update.. more bugfuxes.. Resource images and most recently generated output image are drawn on the app window.<br />LoadProject now works perfectly.<br /><br />TexGen is very cpu-intensive, so I might shoe-horn that code into a Thread , just so the GUI doesn&#39;t freeze up under load.<br />The pro is that I&#39;d be able to show progress on the GUI, the con is that the time it takes to generate would be longer.</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2096" target="_blank">screenshot.JPG</a></li>
      <li><a href="../../attachments/?id=2098" target="_blank">TerrainTexGen060917.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-09-17 01:58:52 by Homer</div>
   </div>
   <div class="post" id="post-185350">
    <div class="subject"><a href="#post-185350">Re: Terrain Texture Generation</a></div>
    <div class="body">The zip in the previous post was replaced with a further update, I&#39;ve added some &#39;mouseover&#39; controls which allow you to inspect the current HeightMap by simply moving the mouse over it.<br />Pixels will be sampled under the mouse cursor and GUI controls updated accordingly.. it&#39;s really just to give you a better idea of the range of Heights so you can set your per-texture Elevation attributes sanely.<br />As an afterthought, some gui controls were tweaked for position.<br /><br />Some of the ObjAsm32 core files were updated, let me know if you have problems building this project and I&#39;ll supply the updated files.</div>
    <div class="meta">Posted on 2006-09-17 04:04:49 by Homer</div>
   </div>
   <div class="post" id="post-185374">
    <div class="subject"><a href="#post-185374">Re: Terrain Texture Generation</a></div>
    <div class="body">Even though I still haven&#39;t deeply tested the current project and KNOW it has some minor problems, I&#39;m going to start looking at implementing the SLOPE attributes.<br />There&#39;s a bit of a problem with SLOPE though, which I&#39;ll now discuss.<br /><br />We have two ways that we can calculate the Slope at any given point on the HeightMap.<br />#1 is to do it &#39;correctly&#39;, and #2 is to do it &#39;quickly&#39;.<br /><br />Method A) Extract the geometry for the terrainpatch in question (ie evolve triangles from the height data), calculate the SURFACE normal of each Triangle, and then for each Vertex, calculate the AVERAGE of the Normals of the Surfaces it shares. Ouch!<br /><br />Method B) For a given point on the Heightmap, obtain the Height there, and also the Height of the Neighbour points in +X and +Z, and from those values and the world scaling value, we can calculate a &#39;fairly accurate&#39; vertex normal by &#39;scaling the Y differential to the X and Z axial stepping distances&#39;.<br /><br />Method A is QUITE slow as it is based on many crossproducts.<br />Mehtod B can be ALMOST as slow due to the high degree of &#39;pixel oversampling&#39;.<br /><br />It seems that either method can be optimized somewhat by prefetching all the Height data for the current terrainpatch, which implies that I need to port my code for doing exactly that from my Terrain visualizer demo back into this project.<br />As such, it seems logical that this project should be capable of producing not just the Textures, but also the TER(rain) geometry files, which I&#39;ve implied in the text that sits on the demo&#39;s titlebar.<br />Furthermore, it seems logical to import the whole TerrainPatch object, bearing in mind that TexGen produces textures on a per TerrainPatch basis ;)<br /><br />Adding TerrainPatch support to the project implies the adding of D3D9 support, which in turn implies the eventual importation of further chunks of the Terrain visualizer project so that we can see the textures and terrainmeshes we are generating without leaving the TexGen app (which is a feature of the T2 texgen apon which this project is strongly based).<br /><br />I&#39;m feeling a little starved for feedback guys, anyone care to share?<br />All opinions, related links, bugreports etc are welcome!<br /><br /></div>
    <div class="meta">Posted on 2006-09-18 01:05:20 by Homer</div>
   </div>
   <div class="post" id="post-185457">
    <div class="subject"><a href="#post-185457">Re: Terrain Texture Generation</a></div>
    <div class="body"><div class="quote"><br /><br />There&#39;s a bit of a problem with SLOPE though, which I&#39;ll now discuss.<br /><br />Method A) Extract the geometry for the terrainpatch in question (ie evolve triangles from the height data), calculate the SURFACE normal of each Triangle, and then for each Vertex, calculate the AVERAGE of the Normals of the Surfaces it shares. Ouch!<br /><br />Method A is QUITE slow as it is based on many crossproducts.<br /></div><br />its invain to feedback if you make BIG difference between prerender and render with based on same math/algo on whatever hardware doesnt matter even if its slow SNES its prerendered for<br />now when you have come to exactly the same problem which the pdf for shaders show simplified math for blending based on normals to speed it up and still produce good enough visible results<br />ok also I been busy with my own project<br /><br /><br />I say between A and B, leaning to A but not overdo it with computations that are unnesserary because they dont produce any visible improvements<br />on the other hand you gonna make a serious prerendering blender you can as well go for A and leave it at overnight for highest qualitytextures<br /></div>
    <div class="meta">Posted on 2006-09-23 06:40:02 by daydreamer</div>
   </div>
   <div class="post" id="post-185559">
    <div class="subject"><a href="#post-185559">Re: Terrain Texture Generation</a></div>
    <div class="body">daydreamer : Thanks for the feedback, I appreciate it.<br />You talk about using Normals in the blending process, I talk about Slope, its the same damn thing - Slope is a derivative of the &#39;change in height over distance&#39;, which is directly related to the Y component of Normals, just expressed differently (and in my case, obtained from a rise over run calculation because normals are not user friendly, most people tend to think in terms of angles, not normals)<br /><br />Major update to this project.<br />Changes include:<br />-many bugfixes<br />-implemented code for Slope, with MouseOver realtime slope also<br />-now supporting launching of app via &#39;filetype association&#39; - so you can associate PRJ files with the app and use them to launch the app.<br />-fixed a &#39;rounding bug&#39; which only presented itself with certain combinations of input values<br />-implemented &#39;progress status&#39; control<br />-moved TexGen into its own Thread so the GUI does not hang - this slows things down somewhat but its much more &#39;professional&#39;.<br />-calculation of surface planes, surface normals and vertex normals<br />-changed TER file format to contain Geometry rather than Heightmap<br /><br />VertexNormal calculation is VERY slow, because I implemented it using a bruteforce &#39;exhaustive search&#39; method to find vertices which are shared across terrainpatch boundaries, ie belong to more than one &#39;mesh&#39;.. the alternative is to generate one single massive world geometry and one massive texture and then chop everything up at the last moment, as in the T2 generator, I wanted to do things on a per-patch basis, which is more resource-friendly, and besides, I&#39;m not interested in how long it takes, this is all preprocessing stuff.. what matters is that the world can be HUGE and detailed, thats really the most important to me, T2 can&#39;t create huge worlds without huge system resources, and I can.. the whole point of the exercise was to address shortcomings in T2, and I believe I&#39;m succeeding, slowly but surely..<br /><br />There&#39;s been so many changes I can&#39;t remember them all, but I did note most of the changes in the source comments, if you care..<br /><br />I&#39;m still not totally happy with the blending algo as it stands, and only Linear falloff is really working at the moment, but hey, its looking much better.. also, Biterider has made my new &#39;DrawDIBonDC&#39; method redundant, so that&#39;ll be changed next update.<br /><br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2106" target="_blank">TerrainTexGen060927.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-09-27 03:20:13 by Homer</div>
   </div>
   <div class="post" id="post-185564">
    <div class="subject"><a href="#post-185564">Re: Terrain Texture Generation</a></div>
    <div class="body">Time for me to talk a little more about my implementation..<br />I&#39;m going to describe how the generation loop works, how the Blending algo operates, and then propose an idea.. I&#39;d sure love to hear YOUR ideas&nbsp; anyway, for the purposes of clarity, I&#39;m only going to talk about a single Heightmap which owns N textures, so please imagine that&#39;s what we&#39;ve selected via the application gui..<br /><br />First a little technical stuff to get you in the mood:<br />We&#39;ll step across the output image (output width and height).<br />For each output pixel, we&#39;ll loop through the input textures, grabbing the pixel at the corresponding coordinate.. that&#39;s done by transforming the output XY pixel coordinate (with respect to the output dimensions)&nbsp; into a &#39;UV coordinate&#39; (with respect to ONE), and then, for each input texture, we&#39;re transforming that UV coordinate back into XY (with respect to input image dimensions).<br />Note that the XY coords are floating point, we use a special version of GetPixel which returns the blended result of the nearest four pixels (thats called Bilinear Filtering), this means we&#39;re grabbing virtual pixels inbetween the actual pixels, which means that the input images can be all different dimensions and its not problematic for us.<br /><br />Anyhow, we&#39;re grabbing all the input pixels at the same relative coordinate as each output pixel, and we&#39;re blending them, so that brings us to the Blending algo..<br />As soon as we grab an input pixel, we &#39;decompose&#39; (break) it into RGB component values (from 0 to 255), we apply some Weights to make that value smaller, and we sum the results in separate RGB &#39;accumulators&#39; by simply adding together the &#39;partial rgb results&#39; obtained from our input pixels.<br />After we&#39;ve done this for all input textures, the RGB accumulators contain our current output pixel, so we&#39;re weight-blending, there&#39;s no need to average the RGB accumulators, in fact we don&#39;t want average anything, we want weighted results, and we have them.<br />The magic is simple math - as long as the total of the input weights equals ONE, the results will be sane. The trick then is to calculate our input Weights carefully so that they add to 1.0, ahuh?<br /><br />Let&#39;s talk about Weights..<br />We use another word for Weights, we can also call them &#39;Influences&#39;, so &#39;the sum of the influences&#39; means the same thing as &#39;the sum of the weights&#39;.<br />In terms of math and programming, there&#39;s a third name we can use to describe them.. we can call them Fractions.<br />Imagine that we had 6 input textures, each with an Elevation Influence of 1.0 (ie a total elevation influence of 6.0).<br />For sane blending, and noting that we haven&#39;t discussed all the factors yet, it&#39;s pretty obvious that we need to apply a Weight of 1/6 (=0.1666 recurring) to our input RGB values so that the sum of the Weights is 1, ahuh ahuh.<br />Now we grab a Height value by sampling the heightmap at the current relative pixel coordinate, and (for each texture) we use it and the remaining Elevation attributes to obtain a value between 0.0 and 1.0, and we apply that to our 1/6, so like before, we&#39;re down-scaling.<br />If the Height value is within the acceptable range, our downscaling factor will be 1.0 , ie no downscaling .. but if its not within that range (and assuming we want to use Falloff), the value will be smaller than one, and possibly zero.. so most of the time, our 1/6 will be made even smaller, the RGB contribution to the output pixel will be made smaller, so that we &#39;fade&#39; the contribution of each input texture based on its own unique attributes.<br />Slope pretty much works the same way as Elevation, just using different input values to give us more control over the contribution of each input texture to the output.<br />I treat Slope as just another influence on the output, and I combine Slope influence at the same time as Elevation .. a &#39;unified equation&#39;.<br />If the Slope influence is zero, the RGB contribution will be zero (for that texture) REGARDLESS of the Elevation, and vice versa.<br />This means that we&#39;re not &#39;playing the influences against each other&#39;, and still able to obtain sane results.<br /><br />I&#39;m thinking about adding checkboxes to allow the user to disable Slope and Elevation attributes, since we can&#39;t just set Slope influence to zero when we only care about Elevation etc (the unified result would be zero, which is not what we wanted).<br /><br />The intention of my approach is that nothing we are doing can make pixels any brighter (than dictated by their weighted inputs).<br />Everything we are doing can only make them the same or LESS bright : in my mind, any anomoly should appear as very bright or very dark and be fairly easy to spot, given various test inputs.<br />That&#39;s certainly proven to be the case so far :P<br /><br />I&#39;ll see if I can&#39;t get the remaining Falloff functions fixed tonight, so the next update is likely to be the &#39;official Beta release&#39;, and I&#39;ll be looking for a few brave volunteers to beta-test the app :)<br /><br /></div>
    <div class="meta">Posted on 2006-09-27 07:35:34 by Homer</div>
   </div>
  </div>
 </body>
</html>