<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Reverse and Add - The Palindrome 196 problem: - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=12949" />
    <link rel="next" href="../?id=12949&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=12949">Reverse and Add - The Palindrome 196 problem:</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=12949&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=12949&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="12949" /><input type="number" name="page" min="1" max="6" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=12949&amp;page=2">&gt;</a><a href="../?id=12949&amp;page=6">&raquo;</a></form>   <div class="post" id="post-100643">
    <div class="subject"><a href="#post-100643">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body">In a separate thread I use ADC and AAA in adding BCD digits of a number. <br /><br /><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=12934">http://www.asmcommunity.net/board/index.php?topic=12934</a><br /><br />The main loop is as follows:<br /><br /><pre><code><br />// add byte pairs with aaa<br />#asm<br /><br />add1&#58;     mov al,&#91;esi&#93;<br />          adc al,&#91;ebx&#93;<br />          aaa<br />          mov &#91;edi&#93;,al<br />          dec esi<br />          inc ebx<br />          dec edi<br />          dec ecx<br />          jnz add1<br />#endasm<br /></code></pre><br /><br />(Yes ESI is decremented while EBX is incremented - that's because it is a reverse addition - as in the palindrome quest...)<br /><br />I believe this is the most optimal single digit addition routine, excluding SIMD routines with MMX, etc (except if I align it on a 16 byte boundary, I suppose). Is it?</div>
    <div class="meta">Posted on 2003-05-01 21:22:01 by V Coder</div>
   </div>
   <div class="post" id="post-100657">
    <div class="subject"><a href="#post-100657">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body"><pre><code>add1&#58;     mov al,&#91;esi&#93;<br />          dec esi<br /><br />          adc al,&#91;ebx&#93;<br />          inc ebx<br /><br />          aaa<br /><br />          mov &#91;edi&#93;,al<br />          dec edi<br /><br />          dec ecx<br />          jnz addl</code></pre>Look at the latency of the AAA instruction and how long 8 bytes takes to execute - MMX could do better.  On the Athlon this loop takes 10 cycles.  Your test says 14 cycles for loop?</div>
    <div class="meta">Posted on 2003-05-01 22:58:31 by bitRAKE</div>
   </div>
   <div class="post" id="post-100663">
    <div class="subject"><a href="#post-100663">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body">Actually, bitRake, I originally wrote it something like that, (months ago) but thought the further away inc esi is from accessing, better to allow pairing... I can't remember what kind of stall it is now.<br /><br />However, from the pairing rules, I think both ways pair identically, and when I tested various variations, the program speed was not affected (not with RDTSC).<br /><br />On my Pentium MMX, 16 cycles is the best I get for any mod of this routine...<br /><br />But I have one more change I'll try (dec esi, inc ebx just after aaa)... Nope. Same 16 cycles.</div>
    <div class="meta">Posted on 2003-05-01 23:30:10 by V Coder</div>
   </div>
   <div class="post" id="post-100669">
    <div class="subject"><a href="#post-100669">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body"><br /><strong>V Coder</strong>, I met a woman on chat from where you are.  She seems really nice.  Maybe I can introduce you to each other?  She says she is 20 and has her own business.  Who knows?<br /><br /><br />Try this one?:<pre><code>	sub	esi, ecx<br />	sub	edi, ecx<br /><br />addl&#58;	mov	al, &#91;esi+ecx&#93;<br /><br />	adc	al, &#91;ebx&#93;<br />	inc	ebx<br /><br />	aaa<br /><br />	mov	&#91;edi+ecx&#93;, al<br />	dec	ecx<br /><br />	jnz	addl</code></pre>Convert <strong>Norbert Juffa</strong>'s algorithm to MMX - you'd have a real winner!<br />Propagating the carry across MMX registers is the really hard part.<br /><br />What do you need the algorithm for?  Why not convert to binary and back?  In some cases keeping the numbers BCD is faster, but that is very rare case, IMHO.<br /><br />My explaintion for your timing is that memory is slow and your operating on data that will not fit in cache, so part of your timing is the memory access time.  Try the test on (cache size / 4) byte numbers and see if it is faster?</div>
    <div class="meta">Posted on 2003-05-01 23:57:03 by bitRAKE</div>
   </div>
   <div class="post" id="post-100674">
    <div class="subject"><a href="#post-100674">Re: Most optimal BCD single digit addition?</a></div>
    <div class="body">Thanks. I'll try that routine.<br /><br /><div class="quote"><br />(Yes ESI is decremented while EBX is incremented - that's because it is a reverse addition - as in the palindrome quest...)<br /></div><br /><br />I'm working on palindrome 196. Reverse and add a number to itself. Repeat if the result is not a palindrome {121, 235747532, etc}. 196 has been reversed and added to itself (196+691=887+788=1675....) probably 220 million times to yield over 90 million digits over about 3 1/2 years and has not yet yielded a palindrome. It is not expected to. Of course the machines performing the checks now are lots faster than those used earlier, and the software is highly optimized (MMX, SSE2), etc. I am just trying to optimize a program to perform the reverse and add, to see if I can get one of comparable speed as others...<br /><br />Juffa's algorithm is found here, along with an algorithm for unpacked BCD addition. I'll try this routine too, and let you know if it is any faster.<br /><a target="_blank" href="http://www.cs.uiowa.edu/~jones/bcd/bcd.html">http://www.cs.uiowa.edu/~jones/bcd/bcd.html</a></div>
    <div class="meta">Posted on 2003-05-02 00:51:25 by V Coder</div>
   </div>
   <div class="post" id="post-100837">
    <div class="subject"><a href="#post-100837">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body">Perhaps you should use tables to perform the addition.<br />Instead of adding BCD numbers, you just have to add 2 binary digits (0-063h).<br />Or perhaps use one digit per byte, since we have now computers with 1Gb RAM.<br /><br />JC</div>
    <div class="meta">Posted on 2003-05-02 18:28:42 by MCoder</div>
   </div>
   <div class="post" id="post-101022">
    <div class="subject"><a href="#post-101022">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body"><div class="quote"><br />Perhaps you should use tables to perform the addition.<br />Instead of adding BCD numbers, you just have to add 2 binary digits (0-063h).<br /></div><br /><br />Not sure I understand...<br /><br /><div class="quote"><br />Or perhaps use one digit per byte, since we have now computers with 1Gb RAM.<br /></div><br /><br />Yup, I am using 1 digit per byte - unpacked BCD numbers.<br /><br />The version based on Jones algorithm (to add two 32-bit 4 digit numbers instead of two 8-bit single digit numbers) takes 12 cycles instead of 16. I suppose an MMX version to add two 8 digit numbers would increase the speed slightly more. <em>edit - after editing as below, it takes 10 cycles</em><br /><br />I have reached the stage I believe I need to learn how to increase thread priority in HLA.<br /><br />Please visit Jones' website to learn more about adding BCD numbers, and the rationale for the strange algorithm.<br /><br />Hey, MMX, 3dNow, SSE and SSE2 coders, any optimizations???<br /><br /><pre><code>          sub edi,3<br />          sub esi,3<br />          sub esi, ecx<br />          sub edi, ecx<br /><br /><br />          clc<br />          pushf<br />add1&#58;     popf<br />          mov eax,&#91;esi+ecx&#93;<br />          bswap eax<br />          adc eax,&#91;ebx&#93;<br />          <br />          add eax, 0f6f6f6f6h<br />          pushf<br />          mov edx, eax<br />          and edx, 30303030h<br />          shr edx, 3<br />          sub eax, edx<br />          and eax, 0f0f0f0fh<br /><br />          bswap eax<br />          mov &#91;edi+ecx&#93;,edx<br />          add ebx, 4<br />;**          sub edi, 4  ;removed<br />;**          sub esi, 4  ;removed<br />          sub ecx, 4<br />          jnz add1<br /><br />          popf<br /></code></pre><br /><br />Edit - 2 subtractionss and attachment removed. Fixed below.</div>
    <div class="meta">Posted on 2003-05-03 23:52:29 by V Coder</div>
   </div>
   <div class="post" id="post-101028">
    <div class="subject"><a href="#post-101028">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body"><strong>V Coder</strong>, memory violation on add_test_jo.</div>
    <div class="meta">Posted on 2003-05-04 01:02:48 by bitRAKE</div>
   </div>
   <div class="post" id="post-101033">
    <div class="subject"><a href="#post-101033">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body">Rake, I get the error in Windows 2000 (Pentium 4), but not on Windows 95 (Pentium MMX).<br /><br />Sorry, I see my error... I decrement edi and esi twice effectively (by subtracting 4 from edi, esi, and then subtracting 4 from ecx, when the index used is edi/esi +ecx)<br /><br />After fixing it, the version takes 10 cycles.<br /><br />add_test_jo<pre><code>adding&#58;<br />// add dword pairs with aaa<br />#asm<br />          sub edi,3<br />          sub esi,3<br />          sub esi, ecx<br />          sub edi, ecx<br /><br /><br />          clc<br />          pushf<br />add1&#58;     popf<br />          mov eax,&#91;esi+ecx&#93;<br />          bswap eax<br />          adc eax,&#91;ebx&#93;<br />          <br />          add eax, 0f6f6f6f6h<br />          pushf<br />          mov edx, eax<br />          and eax, 30303030h<br />          shr eax, 3<br />          sub edx, eax<br />          and edx, 0f0f0f0fh<br /><br />          bswap edx<br />          mov &#91;edi+ecx&#93;,edx<br />          add ebx, 4<br />          sub ecx, 4<br />          jnz add1<br /><br />          popf<br />#endasm</code></pre></div>
    <div class="meta">Posted on 2003-05-04 01:40:41 by V Coder</div>
   </div>
   <div class="post" id="post-101056">
    <div class="subject"><a href="#post-101056">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body"><div class="quote"><strong>Perhaps you should use tables to perform the addition.<br />Instead of adding BCD numbers, you just have to add 2 binary digits (0-063h).<br />Or perhaps use one digit per byte, since we have now computers with 1Gb RAM.<br /></div><br /><br />V-Coder, I realized that you were adding one digit at a time.<br />Instead of working one digit at a time, wouldn't it be faster to work on 2 digits ?<br />Ok, here is some unoptimized code to show my idea:<br /><br /><pre><code><br />inverttable db 100 dup &#40;?&#41; ;this table will contain the reversed numbers&#58; 10 -&gt; 01, and 01-&gt;10<br />xor eax, eax<br />xor ebx, ebx<br />xor ecx, ecx<br /><br />mov al,&#91;esi&#93;<br />mov bl,&#91;edi&#93;<br />add bl,cl<br />xor ecx,ecx<br />add bl,&#91;inverttable+eax&#93;<br />cmp bl,100<br />jb skip<br />sub bl,100<br />inc ecx<br />skip&#58;<br />mov &#91;edx&#93;, bl<br /><br /></code></pre><br /><br />Perhaps this addition could be done efficiently in MMX ?<br /><br />JC</div>
    <div class="meta">Posted on 2003-05-04 05:56:26 by MCoder</div>
   </div>
   <div class="post" id="post-101103">
    <div class="subject"><a href="#post-101103">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body">MCoder you missed when I changed to 4 digits in 32-bits using Jones algorithm...<br /><br />Actually, there's also no need for tables, since I am reversing not the bits in each digit, but the digits in the number 12345 becomes 54321 (Hexademinal: 0102030405 becomes 0504030201)... But thanks much.</div>
    <div class="meta">Posted on 2003-05-04 12:24:49 by V Coder</div>
   </div>
   <div class="post" id="post-101131">
    <div class="subject"><a href="#post-101131">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body">This works beautifully: :)<pre><code>.data<br /><br />	ALIGN 16<br /><br />		db 16 dup&#40;0&#41; ; this buffer is needed for algorithm overflow<br />	Number1	db 16*8 dup&#40;0&#41;<br /><br />		db 16 dup&#40;0&#41; ; this buffer is needed for algorithm overflow<br />	Number2	db 16*8 dup&#40;0&#41;<br /><br />	mmx_0A QWORD 0A0A0A0A0A0A0A0Ah<br /><br />.code<br /><br />Palendrome_Test PROC<br />	lea	edi, Number1<br /><br />	mov	DWORD PTR &#91;edi&#93;, 010906h ; 196<br />	lea	esi, &#91;edi + 3&#93;<br /><br />	lea	ebp, Number2<br />	lea	ebx, &#91;ebp + 3&#93;<br /><br />_0&#58;	call	Palindrome_Sum<br /><br />	; carry flag set if block overflows<br />	; adjust esi/ebx as number grows<br />	adc	BYTE PTR &#91;ebx&#93;, 0<br />	je	_2<br />	inc	esi<br />	inc	ebx<br />_2&#58;	xchg	ebp, edi<br />	xchg	ebx, esi<br /><br />	call	Palindrome_Find<br />	; loop until we find a palidrone<br />	jne	_0<br /><br />	ret<br />Palendrome_Test ENDP<br /><br /><br /><br /><br />Palindrome_Sum PROC<br />	push	esi	; start address of first number<br />	push	edi	; end address of buffer<br />	push	ebx	;<br />	push	ebp	; end address of destination buffer<br /><br />	lea	eax, &#91;esi + 15&#93;<br />	sub	eax, edi<br />	shr	eax, 4<br />	push	eax	; 16 byte blocks to process<br /><br />	pcmpeqd	mm6, mm6 ; mmx_FF<br />	movq	mm7, mmx_0A<br /><br />	clc<br />_0&#58;	; unaligned high order digits &#40;higher addresses&#41;<br />	mov	eax, &#91;esi - 1*4&#93;<br />	mov	ebx, &#91;esi - 2*4&#93;<br />	mov	ecx, &#91;esi - 3*4&#93;<br />	mov	edx, &#91;esi - 4*4&#93;<br /><br />	bswap	eax	; Athlon note&#58; faster than MMX<br />	bswap	ebx<br />	bswap	ecx<br />	bswap	edx<br /><br />	; fix to ensure overflow into next byte<br />	lea	eax, &#91;eax + 0F6F6F6F6h&#93;<br />	lea	ebx, &#91;ebx + 0F6F6F6F6h&#93;<br />	lea	ecx, &#91;ecx + 0F6F6F6F6h&#93;<br />	lea	edx, &#91;edx + 0F6F6F6F6h&#93;<br /><br />; 00 01 02 03 04 05 06 07 08 09<br />; F6 F7 F8 F9 FA FB FC FD FE FF<br /><br />; Adding carry flags across MMX registers is slow, too<br /><br />	; aligned low order digits<br />	adc	eax, &#91;edi + 0*4&#93;<br />	adc	ebx, &#91;edi + 1*4&#93;<br />	adc	ecx, &#91;edi + 2*4&#93;<br />	adc	edx, &#91;edi + 3*4&#93;<br /><br />	lea	esi, &#91;esi - 4*4&#93;<br />	lea	edi, &#91;edi + 4*4&#93;<br /><br />	; aligned low order digits<br />	mov	&#91;ebp + 0*4&#93;, eax<br />	mov	&#91;ebp + 1*4&#93;, ebx<br />	mov	&#91;ebp + 2*4&#93;, ecx<br />	mov	&#91;ebp + 3*4&#93;, edx<br /><br />	movq	mm0, &#91;ebp&#93;<br />	movq	mm1, &#91;ebp+8&#93;<br />	pcmpgtb	mm0, mm6<br />	pcmpgtb	mm1, mm6<br />	pandn	mm0, mm7<br />	pandn	mm1, mm7<br />	paddb	mm0, &#91;ebp&#93;<br />	paddb	mm1, &#91;ebp+8&#93;<br />	movq	&#91;ebp&#93;, mm0<br />	movq	&#91;ebp+8&#93;, mm1<br /><br />	lea	ebp, &#91;ebp + 4*4&#93;<br /><br />	dec	DWORD PTR &#91;esp&#93;<br />	jne	_0<br /><br />	pop	eax	; 16 byte blocks to process<br />	pop	ebp	; end address of destination buffer<br />	pop	ebx	;<br />	pop	edi	; end address of buffer<br />	pop	esi	; start address of first number<br />	ret<br />Palindrome_Sum ENDP<br /><br /><br />Palindrome_Find PROC<br />	or	eax, -1<br />	ret<br />Palindrome_Find ENDP</code></pre>The numbers in the data section are just to show the format in memory - I'm sure you will allocate some larger blocks.  All but four memory accesses are aligned (they are aligned sometimes, too)!  If this isn't faster then it's only memory speed holding it back.  Note: numbers are stored with least significant digit first.  I will test some more before reporting an official timing on the algorithm.<br /><br />call Palendrome_Test ; to get it started...</div>
    <div class="meta">Posted on 2003-05-04 16:46:30 by bitRAKE</div>
   </div>
   <div class="post" id="post-101142">
    <div class="subject"><a href="#post-101142">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body">Here is a test program.  1000 Mhz Athlon clocks in at &lt;7 secs for 2^16 digits.<br />This actually calculates the digits for the number 196.<br /><br /> 2^20 digits takes 3 hours, 33 minutes, 23.52 seconds!<br /><br />Sure beats <a target="_blank" href="http://www.jasondoucette.com/worldrecords.html">( this )</a> guy's 1 day and 18 hours!<br /><pre><code><br />; 2^11 &#40;   2k&#41;&#58;          0 ms<br />; 2^12 &#40;   4k&#41;&#58;         20 ms<br />; 2^13 &#40;   8k&#41;&#58;        100 ms<br />; 2^14 &#40;  16k&#41;&#58;        400 ms<br />; 2^15 &#40;  32k&#41;&#58;      1 552 ms<br />; 2^16 &#40;  64k&#41;&#58;      6 839 ms<br />; 2^17 &#40; 128k&#41;&#58;     28 270 ms<br />; 2^18 &#40; 256k&#41;&#58;    482 003 ms &#40;no longer in the cache!&#41;<br />; 2^19 &#40; 512k&#41;&#58;<br />; 2^20 &#40;1024k&#41;&#58; 12 803 520 ms<br /></code></pre></div>
    <div class="meta">Posted on 2003-05-04 17:49:32 by bitRAKE</div>
   </div>
   <div class="post" id="post-101220">
    <div class="subject"><a href="#post-101220">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body">Hey, wait a minute, you weren't supposed to post an entire palindrome program... I'm working on it...:rolleyes: <br /><br />Anyway, check out the full list of times at <a target="_blank" href="http://home.cfl.rr.com/p196/milestones.html">http://home.cfl.rr.com/p196/milestones.html</a><br /><br />and the software comparisons page at <a target="_blank" href="http://home.cfl.rr.com/p196/compare.html">http://home.cfl.rr.com/p196/compare.html</a><br /><br />You should probably be able to submit your code to be officially timed. And if he likes your code enough, he would use it until a faster one is developed.<br /><br />My intention was to write a routine that was faster on my Pentium MMX 166 than the 1 day 18 hours on a Pentium II 266. <br /><a target="_blank" href="http://www.jasondoucette.com/worldrecords.html">http://www.jasondoucette.com/worldrecords.html</a><br /><br />My fastest routine (8 digit MMX) running in unreal mode for DOS finishes 1 million in 14.7 hours on a K6-2 550, 33% faster on a Pentium II 350, and 50% longer on a Pentium MMX 166 - so I have accomplished my objective...<br /><br />Beyond this I wanted to submit for testing to the Software comparisons page.<br /><br />Unfortunately, the tester prefers a Windows version. I estimate that with all the penalties I accrue from segment prefix, 32 bit prefix, my code should be at least four times as fast in Win32. My initial simple single digit add was half the speed on Pentium MMX. Worse yet, Pentium 4's hate 16 bit code with segment prefixes, etc. The unreal mode code runs barely faster on a 1.8GHz Pentium 4 than on a 166 MHz Pentium MMX.<br /><br />Here's my problem now. I am coding in HLA, and there's some problem preventing the program from working in Win32. I port the routine over and it works for the first adds, then breaks. Plus HLA does not support all the MMX instructions, so I have to use a #asm, #endasm hack. (It must be so annoying to you MASM guys to see HLA code... my bad)<br /><br />My interest here was to develop the best add routine...<br /><br />I had discovered Jones' website months ago, but could not understand his algorithm until I read it carefully a few nights ago, and I was able to post code. I was debugging my MMX routine... Here it is, on my Pentium MMX, it takes 11 cycles, compared to Jones routine, 7-9 cycles... (I do not adjust thread priority yet).<br /><br />It is slower than Jones' but I wrote it myself!!!:grin:</div>
    <div class="meta">Posted on 2003-05-04 23:32:39 by V Coder</div>
   </div>
   <div class="post" id="post-101222">
    <div class="subject"><a href="#post-101222">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body">My MMX algorithm is as follows - only 4 digit is included, I also have it extended to 8 digits ...<br /><br /><pre><code><br />#asm<br />          sub edi,3<br />          sub esi,3<br />          sub esi, ecx<br />          sub edi, ecx<br /><br />          clc<br />          pushf<br />add1&#58;     popf<br />          mov eax,&#91;esi+ecx&#93;<br />          bswap eax<br />          adc eax,&#91;ebx&#93;<br />          add eax, 0f6f6f6f6h<br />          pushf                        ; carry from addition<br /><br />          movd mm0,eax                 ; MMX<br />          movd mm1,eax<br />#endasm<br />          pcmpgtb &#40;allff, mm1&#41;;        // $ffffffffffffffff<br />          pxor &#40;allff, mm1&#41;;           // reverse bits<br />          pand &#40;allf6, mm1&#41;;<br />#asm<br />          psubb mm0, mm1<br />          movd eax,mm1<br /><br />          bswap eax<br />          mov &#91;edi+ecx&#93;,eax<br />          add ebx, 4<br />          sub ecx, 4<br />          jnz add1<br /><br />          popf<br />#endasm<br /></code></pre><br /><br />Let me explain how it works...<br /><br />After adding the two numbers together with carry from previous add, I add $f6f6f6f6 to eax to force the carry out of each digit. Now, any byte from f6-ff has not had the carry out, and any byte from 0-9 has had a carry. Store carry on stack<br /><br />If it is from 0-9, all well and good. If from f6-ff, then f6 needs to be subtracted.<br /><br />MMX signed byte compare with ffffffff. Any byte which is positive will now become ff, any byte which is ff or less will become 00. xor to switch from 00 to ff and vice versa. And with f6. Thus everywhere 0-9 is found the byte value is 00. Everywhere f6-ff is found the byte value is f6.<br />Subtract, pass back to eax, bswap and store...<br /><br />Okay my algorithm has a problem.<br /><br />I am storing all numbers in big endian format (or is that little?) The least significant number is in higher numbered bytes, as opposed to IA-32 architecture. This is why I have to bswap before store. Easy to change. I just have not done it yet, since I cannot get HLA to work with my routine... and I cannot code MASM to save anyone's life.</div>
    <div class="meta">Posted on 2003-05-04 23:47:42 by V Coder</div>
   </div>
   <div class="post" id="post-101224">
    <div class="subject"><a href="#post-101224">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body"><div class="quote"><br />Hey, wait a minute, you weren't supposed to post an entire palindrome program... I'm working on it...:rolleyes:</div>Sorry, didn't mean to help too much - just got carried away.<br /><br /><strong>V Coder</strong>, your doing well.  Look at the algo above - it fixes all the problems you state your's has:<br /><br />1) little endian numbers: only one set of non-aligned loads, only one bswap<br /><br />2) pxor mm0, &lt;FF&gt; ; pand mm0, &lt;F6&gt; should be changed to pandn mm0, &lt;F6&gt; !!<br /><br />3) you don't want to use MOVD it is really slow, use only MOVQ<br /><br />4) almost no forward dependancies<br /><br /><br />On cached data each digit takes 2.66 clock cycles!<br />The faster your memory the faster the algorithm!<br />I still think it is twice as slow as it should be!<br /><br />Do you know where I can get the files of numbers already computed?  I'd like to start at 90 million digits if I can.  I'm going to attempt a packed BCD version because memory is a bottleneck here and we have plenty of time to do more calculations.</div>
    <div class="meta">Posted on 2003-05-05 00:21:33 by bitRAKE</div>
   </div>
   <div class="post" id="post-101226">
    <div class="subject"><a href="#post-101226">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body">Ah, I like your routine... <br /><br />(Apart from the fact that you add $0a, and I subtract $f6 - as we say in Trinidad, six of one, half a dozen of the other).<br /><br />Cute way of setting up allff - $ffffffffffffffff. You can see that I have not yet put allf6 and allff in mmx registers... So I have room for optimization.<br /><br />I suppose moving the data back to memory is faster than movd and shift... which is what I do in my 8 byte version.<br /><br />However, I believe you are wrong...After the pcmpgtd you need to xor $ffffffff. Wait, okay. That's a pandn. That's cute.<br /><br />I suppose it is supported by a C launcher or something?<br /><br />I only now realize that I do not need to push the flags here in this test program, since I do not affect the flags with the MMX comparisons...<br /><br />Well, in my full program, I use an integer CMP to see if the number is a palindrome. Obviously CMP affects the flags, so I need to preserve it... Where do you check for the palindrome?<br /><br />Actually, in theory, you do not need to specifically check for palindrome. If there is any carry in any addition, then the number being formed will not be a palindrome. That's the theory at least. It fails for small numbers, eg 29+92=121. And there are a couple of others. However, it is hard to imagine that any addition of a 90 million digit number will not produce a carry somewhere, so no one actually believes there will be a palindrome, so you do not really need to check right?<br /><br />You need to keep score of how many digits in the new number, and how many additions have passed so far. Also, in my DOS unreal program I use BP, but in my windows port, I leave EBP severely alone.<br /><br />I understand the LEAs. I did not think of them, but then again, I am a relative newbie. I started writing my routine 5 years 4 months ago (before the current &quot;pioneers&quot; started). I got my initial program working in Unreal mode, but thought it was too slow and did not want to stress my mind in learning Win32 API. So I let it go until Jan 1, 2003. I reworked the routines until I reached an MMX version, started teaching myself HLA. But I got stuck January 15th when I could not get the routines that work perfectly under NASM to work under HLA. I have yet to submit my program there for debugging. But I'm sure it is not my routines themselves, but the HLA packaging (yeah for sure!!!)... so, I'm here to try to learn MASM32, and/or fix up the HLA code... Meanwhile I wanted to develop my routines further.<br /><br />Will I get flamed if I post my Unreal Mode routine here?<br /><br />Here goes.<br /><br />I compiles as is with NASMW. I have no idea what to do to make it work with the others.</div>
    <div class="meta">Posted on 2003-05-05 00:35:17 by V Coder</div>
   </div>
   <div class="post" id="post-101229">
    <div class="subject"><a href="#post-101229">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body"><strong>Will I get flamed if I post my Unreal Mode routine here?</strong><br />It fits in well with the discussion, IMHO.<br /><br />I don't test for a palindrome because I'm not to 90 million digits yet - no need.  The algorithm posted above moves ESI/EBX as the number grows - they point to the byte after the number.  With some minor changes (prefetch) I am at 7.5 clock cycles for uncached data. :)<pre><code>; 2^18 &#40; 256k&#41;&#58;    482 003 ms uncached data<br />; 2^18 &#40; 256k&#41;&#58;    343 944 ms  &quot; &quot;  w/ PREFETCHNTA</code></pre>...a  28.6% improvement.</div>
    <div class="meta">Posted on 2003-05-05 00:54:05 by bitRAKE</div>
   </div>
   <div class="post" id="post-101230">
    <div class="subject"><a href="#post-101230">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body">I took too long typing my answer. I started before you...<br /><br />Jones' code uses 5 instructions as opposed to your 6, however.<br /><br />You have to contact the guy at <a target="_blank" href="www.p196.org">www.p196.org</a> to get the 90 million byte file.<br /><br />Have a look at my HLA please.<br /><br />I am trying to debug it. With your deep understanding of ASM, it will probably only bring furrows to your forehead... (Why does V Coder accept reversed operands, mandatory brackets and semicolon?)<br /><br />Thanks<br /><br />You are slightly behind the fastest on the software comparisons page. But then again, you're on a slower clocked machine... Try Jones' routine too.</div>
    <div class="meta">Posted on 2003-05-05 00:57:41 by V Coder</div>
   </div>
   <div class="post" id="post-101232">
    <div class="subject"><a href="#post-101232">Reverse and Add - The Palindrome 196 problem:</a></div>
    <div class="body">I have a record of the correct number of additions to reach each 10,000 digits. <br /><br />10000 digits, 24094 additions;<br />20000 - 48150<br />50000 - 120428 etc.<br /><br />Just for you to verify that your program is accurate (which goes without saying, V Coder :grin: ) I used it to verify each new routine I wrote, and the unreal mode code beeps at each 10,000, so I can time it manually.</div>
    <div class="meta">Posted on 2003-05-05 01:21:50 by V Coder</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=12949&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=12949&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="12949" /><input type="number" name="page" min="1" max="6" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=12949&amp;page=2">&gt;</a><a href="../?id=12949&amp;page=6">&raquo;</a></form>  </div>
 </body>
</html>