<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Ideas about complex macro system - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19734" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=19734">Ideas about complex macro system</a></p>
   <div class="post" id="post-151773">
    <div class="subject"><a href="#post-151773">Ideas about complex macro system</a></div>
    <div class="body">Hi,<br />I'm designing some complex macro system in MASM. The basics looks as follows:<br /><pre><code><br />AddToListmacro const1, const2, ...		; add new constants to list, no code<br />	somemacro1 bbc				; expand some code<br />	somemacro2 cbc<br />	endingmacro dbc<br />AddToListmacro const3, const4, ...		; add new constants to list, no code<br />	somemacro3 fbc				; expand some other code<br />	somemacro4 gbc<br />	somemacro5 hbc<br />	endingmacro ibc<br />...<br /></code></pre><br />i.e. there is always block of somemacros (somemacroX), which is always inducted by AddToListmacro.<br /><br />The problem lies in fact that all somemacros depend the whole list (being created by AddToList), not only on the partial list created at time of expanding the somemacros.<br />I have only one idea: declare blocks between AddToListmacros as macros (wrap the block with macro) and expand them at the end, when whole list is already created, using some macro, say &quot;ExpandAllmacro&quot;. It causes prohibition of expanding of somemacros at their original locations.<br />I got an idea that the AddToListmacro could define header of the wrapping macro &quot;wrappingmacroX MACRO&quot; and the endingmacro footer, actually only &quot;ENDM&quot;.<br /><br />It could look like that:<br /><pre><code><br />AddToListmacro	MACRO<br />; ...original macro code...<br /><br />temp1 TEXTEQU %WRAPPING_CNT	; ordinal number of current wrapping macro<br />WRAPPING_CNT = WRAPPING_CNT + 1<br /><br />temp2 CATSTR &lt;wrappingmacro&gt;, %temp1, &lt;MACRO&gt;<br />temp2				; defines header of wrappingmacro after expanding this macro<br />ENDM<br /></code></pre><br /><pre><code><br />endingmacro	MACRO<br />temp TEXTEQU &lt;ENDM&gt;<br />temp				; defines footer of currently opened wrappingmacro<br /><br />; ...oiginal macro code...<br />ENDM<br /></code></pre><br /><pre><code><br />ExpandAllmacro	MACRO<br />; concatenate names of all defined wrapping macros<br />ENDM<br /></code></pre><br />I did some testing and it seems to be working.<br />Nevertheless, I'm asking here because I'm not absolutely sure (I'm no so experienced) and other members could see any other solution to this macro problem.</div>
    <div class="meta">Posted on 2004-10-24 11:30:15 by MazeGen</div>
   </div>
   <div class="post" id="post-151788">
    <div class="subject"><a href="#post-151788">Ideas about complex macro system</a></div>
    <div class="body">IIRC, a macro within a macro has access to local and passed params of parent macro.  It is difficult to discern what you are trying to achieve.  Hopefully you found a new technique.</div>
    <div class="meta">Posted on 2004-10-24 18:22:25 by bitRAKE</div>
   </div>
   <div class="post" id="post-151817">
    <div class="subject"><a href="#post-151817">Ideas about complex macro system</a></div>
    <div class="body">:) Hi guru,<br /><div class="quote"><br />It is difficult to discern what you are trying to achieve.<br /></div><br />I'll show it with a sample:<br /><pre><code><br />.686<br />.MODEL FLAT, STDCALL<br /><br />.LISTMACROALL<br /><br />AddToListmacro	MACRO	arg1, arg2<br /> ; ...original code here...<br /><br /> ; in this example, this macro creates no list, only creates CONST1-4;<br /> ; CONST3 and 4 would be forward-referenced by somemacro1 and somemacro2<br /><br /> CONST&amp;arg1 EQU arg1<br /> CONST&amp;arg2 EQU arg2<br /><br /> ; concatenate header of wrappingmacro<br /><br /> temp2 CATSTR &lt;wrappingmacro&gt;, %WRAPPING_CNT, &lt; MACRO&gt;<br /> temp2		; defines header of wrappingmacro after expanding this macro<br /><br /> WRAPPING_CNT = WRAPPING_CNT + 1<br />ENDM<br /><br />endingmacro	MACRO<br /> temp TEXTEQU &lt;ENDM&gt;<br /> temp		; defines footer of currently opened wrappingmacro<br /> ; ...original code here...<br />ENDM<br /><br />ExpandAllmacro	MACRO<br /> ; concatenate names of all defined wrapping macros&#58;<br /><br /> count = 0<br /> WHILE count NE WRAPPING_CNT<br />  @CatStr&#40; &lt;wrappingmacro&gt;, %count &#41;	; call all wrappingmacros at the end<br />  count = count + 1<br /> ENDM<br />ENDM<br /><br />somemacro1	MACRO	arg<br /> mov	eax,arg<br />ENDM<br /><br />somemacro2	MACRO	arg<br /> mov	ebx,arg<br />ENDM<br /><br />somemacro3	MACRO	arg<br /> mov	ecx,arg<br />ENDM<br /><br />somemacro4	MACRO	arg<br /> mov	edx,arg<br />ENDM<br /><br />.CODE<br />Start&#58;<br /><br /> WRAPPING_CNT = 0			; init<br /><br /> AddToListmacro 1, 2<br />	somemacro1 CONST3		; forward-referenced constants&#58;<br />	somemacro2 CONST4		;  they will be defined after calling<br />	endingmacro			;  &quot;AddToListmacro 3, 4&quot;<br /> AddToListmacro 3, 4<br />	somemacro3 CONST1<br />	somemacro4 CONST2<br />	endingmacro<br /><br /> ExpandAllmacro				; call all somemacros via wrappingmacros<br /><br />END Start<br /></code></pre><br />Unfortunately, such system is not working. It successfully defines header of first wrappingmacro (&quot;wrappingmacro0 MACRO&quot;) and the compiler accept it:<br /><pre><code><br /> 00000000	.CODE<br />		Start&#58;<br />			<br /> = 00000000	 WRAPPING_CNT = 0			; init<br />		<br />		 AddToListmacro 1, 2<br />	     1	 ; ...original code here...<br />	     1	<br />	     1	 ; in this example, this macro creates no list, only creates CONST1-4;<br />	     1	 ; CONST3 and 4 would be forward-referenced by somemacro1 and somemacro2<br />	     1	<br />	     1	 CONST1 EQU 1<br />	     1	 CONST2 EQU 2<br />	     1	<br />	     1	 ; concatenate header of wrappingmacro<br />	     1	<br />	     1	 temp2 CATSTR &lt;wrappingmacro&gt;, %WRAPPING_CNT, &lt; MACRO&gt;<br />	     1	 wrappingmacro0 MACRO		; defines header of wrappingmacro after expanding this macro<br />	     1		somemacro1 CONST3		; forward-referenced constants&#58;<br />	     1		somemacro2 CONST4		;  they will be defined after calling<br />	     1		endingmacro			;  &quot;AddToListmacro 3, 4&quot;<br />	     1	 AddToListmacro 3, 4<br />	     1		somemacro3 CONST1<br />	     1		somemacro4 CONST2<br />	     1		endingmacro<br />	     1	<br />	     1	 ExpandAllmacro				; call all somemacros via wrappingmacros<br />	     1	<br />	     1	END Start<br /></code></pre><br />BUT, as you can see, the endingmacro will not expand to &quot;ENDM&quot; :( Even though I tried different combinations of expansion operators, even &quot;endignmacro TEXTEQU &lt;ENDM&gt;&quot; does not work...<br /><br />It does work as needed only when I replace &quot;endingmacro&quot; with &quot;ENDM&quot;:<br /><pre><code><br /> AddToListmacro 1, 2<br />	somemacro1 CONST3		; forward-referenced constants&#58;<br />	somemacro2 CONST4		;  they will be defined after calling<br />;	endingmacro			;  &quot;AddToListmacro 3, 4&quot;<br />ENDM<br /> AddToListmacro 3, 4<br />	somemacro3 CONST1<br />	somemacro4 CONST2<br />;	endingmacro<br />ENDM<br /><br /> ExpandAllmacro				; call all somemacros via wrappingmacros<br /><br /><br /> 00000000	.CODE<br />		Start&#58;<br />				<br /> = 00000000	 WRAPPING_CNT = 0			; init<br />		<br />		 AddToListmacro 1, 2<br />	     1	 ; ...original code here...<br />	     1	<br />	     1	 ; in this example, this macro creates no list, only creates CONST1-4;<br />	     1	 ; CONST3 and 4 would be forward-referenced by somemacro1 and somemacro2<br />	     1	<br />	     1	 CONST1 EQU 1<br />	     1	 CONST2 EQU 2<br />	     1	<br />	     1	 ; concatenate header of wrappingmacro<br />	     1	<br />	     1	 temp2 CATSTR &lt;wrappingmacro&gt;, %WRAPPING_CNT, &lt; MACRO&gt;<br />	     1	 wrappingmacro0 MACRO		; defines header of wrappingmacro after expanding this macro<br />	     1		somemacro1 CONST3		; forward-referenced constants&#58;<br />	     1		somemacro2 CONST4		;  they will be defined after calling<br />	     1	;	endingmacro			;  &quot;AddToListmacro 3, 4&quot;<br />	     1	ENDM<br />	     1	<br /> = 00000001  1	 WRAPPING_CNT = WRAPPING_CNT + 1<br />		 AddToListmacro 3, 4<br />	     1	 ; ...original code here...<br />	     1	<br />	     1	 ; in this example, this macro creates no list, only creates CONST1-4;<br />	     1	 ; CONST3 and 4 would be forward-referenced by somemacro1 and somemacro2<br />	     1	<br />	     1	 CONST3 EQU 3<br />	     1	 CONST4 EQU 4<br />	     1	<br />	     1	 ; concatenate header of wrappingmacro<br />	     1	<br />	     1	 temp2 CATSTR &lt;wrappingmacro&gt;, %WRAPPING_CNT, &lt; MACRO&gt;<br />	     1	 wrappingmacro1 MACRO		; defines header of wrappingmacro after expanding this macro<br />	     1		somemacro3 CONST1<br />	     1		somemacro4 CONST2<br />	     1	;	endingmacro<br />	     1	ENDM<br /><br /><br /></code></pre><br />But the goal is not to use any additional macro directives, like this &quot;ENDM&quot;.<br /><br />Are you aware of any way how to force the endingmacro to expand to &quot;ENDM&quot;? Or is it mission: impossible?</div>
    <div class="meta">Posted on 2004-10-25 07:51:25 by MazeGen</div>
   </div>
   <div class="post" id="post-151821">
    <div class="subject"><a href="#post-151821">Ideas about complex macro system</a></div>
    <div class="body">I doubt that the compiler can be forced to expand any macros inside a macro definition :S, because it seems to be stone-dead, there's no room to swing a cat.</div>
    <div class="meta">Posted on 2004-10-25 11:21:34 by MazeGen</div>
   </div>
   <div class="post" id="post-153684">
    <div class="subject"><a href="#post-153684">Ideas about complex macro system</a></div>
    <div class="body">Crazy MACRO<br />EXITM @CatStr(&quot;ENDM&quot;)<br />ENDM<br /><br />...oh this is just asking for trouble - like flirting with a redhead. :lol:</div>
    <div class="meta">Posted on 2004-12-04 02:14:12 by bitRAKE</div>
   </div>
   <div class="post" id="post-153808">
    <div class="subject"><a href="#post-153808">Ideas about complex macro system</a></div>
    <div class="body">Thanks for your stable interest :), but how did you mean it exactly?<br />As I see it, the problem lies in macro definition, which is totally static - if you put your Crazy macro in a definition of another macro, it will not be expanded to &quot;ENDM&quot;, so the definition will be not closed. :(</div>
    <div class="meta">Posted on 2004-12-06 14:17:18 by MazeGen</div>
   </div>
   <div class="post" id="post-153824">
    <div class="subject"><a href="#post-153824">Ideas about complex macro system</a></div>
    <div class="body">Symbols are not resolved in search of ENDM.<br /><br />Something as simple as &quot;testend EQU &lt;ENDM&gt;&quot; will not resolve.<br /><br />teststart MACRO<br />testend<br /><br />But you already knew that. :oops:</div>
    <div class="meta">Posted on 2004-12-06 23:47:52 by bitRAKE</div>
   </div>
   <div class="post" id="post-153842">
    <div class="subject"><a href="#post-153842">Ideas about complex macro system</a></div>
    <div class="body">Yea, that's it.<br /><br />It would be very nice and useful make it working, because we would use MASM as custom multi-pass assembler then!<br /><br /> :evil:</div>
    <div class="meta">Posted on 2004-12-07 07:58:22 by MazeGen</div>
   </div>
  </div>
 </body>
</html>