<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Opcode#6 prefixes - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=9741" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=9741">Opcode#6 prefixes</a></p>
   <div class="post" id="post-72365">
    <div class="subject"><a href="#post-72365">Opcode#6 prefixes</a></div>
    <div class="body">Now we are about to finish with prefixes.<br />The last two classes of prefixes are<br />&quot;Segment override&quot; and &quot;LOCK&quot; prefixes.<br />Term &quot;segment override&quot; might be somehow confusing to<br />begginers, but really perfectly fit to &quot;default&quot; approach in Intel opcode<br />system.<br />Time to open our testopcode app in OllyDbg.<br />Type MNEMONIC.<br />    mov eax,<br />you can see<br />8B03           MOV EAX,<br />Type next MNEMONIC<br />   mov eax,GS:<br />Now you can see:<br /> 8B03           MOV EAX,<br /> 65:8B03        MOV EAX,<br />65 is segment override prefix to change DEFAULT segment for<br />data from DS to GS. But only for this one operation.<br />Actually to use any data in opcode processor need to know both<br />segment and offset to address to the data.<br />But to specify directly those segments we would need additional<br />field in opcode. And it would lead to immenstly growing size compareing<br />to present opcode system.<br />Most common operations are operations with some data in memory.<br />So instead of direct specification in every opcode segment of data used,<br />a different approach was taken:<br />Operations were separated in groups by some definitions<br />and for each group was choosen DEFAULT register for data<br />those operations used:<br />CS: for EIP pointer (code)<br />ES: for chain operations that use 2 mem operands(movs,cmpsb etc.) for dest<br />    and DS: for source<br />SS: for stack operation(push pop etc.)<br />DS: for the rest data operations (data handling other than in chain ops)<br />And logic for processor to understand what segment to use for particular<br />operationis is simple simple and direct:<br />if there is &quot;segment override&quot; prefix - use segment specifyed by the<br />prefix<br />else - use segment that is DEFAULT for that kind of operation.<br /><br />TYPE OPCODES:<br />	 AC<br />      3E AC<br />As you can see in debugger for both AC and 3E AC here is the same mnemonic:<br /><br />AC             LODS <br />3E:AC          LODS <br /><br />3E is prefix that directly specify segment DS,<br />but actually processor in this case would use DS even if it were not<br />specified, because it is DEFAULT segment for LODS operand address.<br /><br />For you as programmer that means each time you use segment that is not<br />default for this kind of operation it costs you 1 byte for each instruction<br />and 1 additional clock for the instruction to execute (actually to &quot;decode&quot;,<br />not &quot;execute&quot;).<br />The same about all other prefixes that change DEFAULT something in operations<br />66 - default operand size (when you use 16 bit registers or 16 bit memory <br />operands in Win32 apps will cost you additional byte and additional clock<br />for each opcode that use them)<br />67 - default address mode (when you use 16 bit addressing)<br /><br />Writing Win32Asm user mode apps you have nor much chance neither need<br />to work with segment registers, nevertheless low level programming is about<br />to make &quot;black boxes&quot; lit ones.<br />Let's have a slite info about specifics of segment register in Win32asm<br />user mode apps.<br />CS:<br />CS is the same for all user mode apps.<br />It is 1Bh in NT family OSs and 227h in 9x.<br />If someone of you remember discussing macro for absolute address jump,<br />I could give now the answer for very simple absolute jump format<br />but it would be different for NT and 9x.<br />OK let's have a look at long direct jump opcode.<br />EA - byte &quot;code&quot; telling processor that it is long direct jump opcode<br />when processor encounter that &quot;code&quot; it assumes that after that is<br />48 bit address, low 32 bits of address is offset and high 16 bits specify<br />segment register.<br />Since we know that for NT(2000,XP) segment selector for code is 1Bh<br />to make absolute direct to address 12345678h we could write:<br />  db EA ;long jump<br />  dd 12345678h;offset where to jump<br />  dw 1Bh ;segment selector for code in NT<br />for 9x the same jump should look the same exept for code selector word.<br />  db EA ;long jump<br />  dd 12345678h;offset where to jump<br />  dw 227h ;segment selector for code in 9x<br /><br />So it would be fine if you are going to use the app only in NT or only in 9x<br />(actually there are lots of such apps - for example by M.Russinovich -<br />that are meant to be used only in one of Windows OS family)<br />We then write such macro<br />;NT=1<br />absjmp macro addr<br />ifdef NT<br />	db 0EAh<br />	dd addr<br />	dw 01Bh<br />else<br />	db 0EAh<br />	dd addr<br />	dw 227h<br />endif<br />endm<br />use:<br />   absjump 401000h<br /><br />And comment\uncomment line NT=1 depending on what system we are<br />going to use this long absolute jump.<br />bitRake can figure out some better way to handle conditions may be.<br /><br />Try to write raw opcode to jump to some &quot;nop&quot; aimed in your debugger.<br />for example you want to jump to string<br />00401013  |. 90             NOP                                      <br />in your debugger<br />type opcode (ctrl-e)<br />EA 13 10 40 00 and the rest two bytes will be B1 00 on NT or 27 02 on 9x<br /> to be continued...</div>
    <div class="meta">Posted on 2002-12-23 16:21:46 by The Svin</div>
   </div>
   <div class="post" id="post-72662">
    <div class="subject"><a href="#post-72662">Opcode#6 prefixes</a></div>
    <div class="body">Important thing to remember is that DS SS CS segment are alias<br />segments in Win32 user mode app. That means that you can address them<br />using any of those segment registers.<br />If you tried &quot;String to Dwords&quot; util you know that one of variant to<br />place constant string where you need is using stack operation, when stack<br />pointer point directly to .data section and use push operations to<br />place constant string there.<br />The same use .code section for data<br />in such code as <br />.code<br />msg db 'Some text',0<br />start:<br /> invoke MessageBox,0,offset sometext,....<br /><br />or such code would do the same thing<br />.data<br />somedw dd 12343<br />......<br />.code<br />....<br /> mov eax,somedw<br /> mov eax,dword ptr offset somedw<br /> mov eax,dword ptr DS:offset somedw<br /> mov eax,dword ptr CS:offset somedw<br /> mov eax,dword ptr SS:offset somedw<br />.......<br /><br />you must remember that data on some section may be protected,<br />(it's done on page protection level to change access rights<br />use ERW keys with /section: option while linking)<br />nevertheless if you can address data as ptr somedata<br />and secced means that you can address it definining any of DS,CS,SS<br />register as selector.<br />We will discuss it in details when come to system aspects of programming.<br /><br />Now what about the rest of the registers?<br />One that first will come to our attention is ES register,<br />that used in chain operations that still matters when you need compact code.<br />In DOS programm you would need make sure that ES=DS if you work in the same <br />segment for both destination and source data.<br />In Win32 user mode programming you don't need it, but it doesn't mean<br />that ES isn't used with chain operations anymore.<br />Before we check it out let's make some simple notes about chain operations.<br />ES is used in those chain operations where are two memory operands: source<br />and destination:<br /> for example<br /> movsd = move dword ptr DS:ESI to ES:EDI<br />As we can see there are two memory operands, so if we use &quot;segment override&quot;<br />prefix what segment selector would be changed? Selector for source or <br />destination?<br />Type OPCODE<br />    A5 65 A5<br />A5             MOVS ,<br />65:A5          MOVS ,<br /><br />So as you can see &quot;segment override&quot; prefix affect source.<br />Changing destionation selector is not allowed.<br />If you want to change selector for destination - change value of ES,<br />not register for selector.<br />The same is about all &quot;two memory operands&quot; chain instructions.<br />BTW if you started use or look at opcode you for sure noticed that all<br />chain operations are short 1 byte if you don't use words (two bytes with<br />words because of 66 prefix) use them when speed doesn't matter - it leads<br />to very compact opcode.<br /><br />As was said before, ES is still used though you don't need especially <br />initialize it with DS value - system do it for you when loads your app.<br />Nevertheless you can easily spoiled it and bad result then comes immideatly.<br />Let's now check out how selector value would effect chain operation.<br />We can do it without writing app - we are low level coders are we not ;)<br />Remeber how we use local vars?<br />We sub esp for size of them. They say: &quot;Stack is growing down&quot; - that<br />means that we can use in stack address space from less then current esp<br />without risk to spoiled some data (return address, arguments etc.)<br />For example if you see in OllyDbg top of stack as<br /><br />0012FFC4   77F1B9EA  RETURN to KERNEL32.77F1B9EA<br />0012FFC8   0012E2D4<br />0012FFCC   77F92CD4  ntdll.77F92CD4<br />0012FFD0   7FFDF000<br />Then you can use addresses from 0012FFC0 and lower for yor local data<br />(remeber that size of given memory for stack (phisical memory mapped to<br />stack space) is 1 mb you can change it using stack key while linking<br />and don't use first kb ever - it's for errors catching).<br />If you feel uneasy yet about it - just type and execute some push\pop<br />operation looking at top of stack to get feeling how and where it grows.<br />Stack window is your right bottom corner in OllyDbg.<br /><br />So let's use some of the space for our local data to check how movs works<br />with different selectors. <br />What are we going to do?<br />1. Fill stack space with short string<br />2. Copy the string to different near stack region step by step (one byte<br />each step) and in each step we define different segment register <br /> - to get impression that selectors in DS,SS,CS pointing to alias segment<br /> - to check if ES is still matter by spoiling it in last step<br /><br />Type MNEMONIC<br />	lea edi,<br />This will point edi to space for local data so we wouldn't spoil anything<br />that was placed in the stack as return address, arg etc.<br />We are going to use space addresses that are &lt;=esp-4<br />Type next MNEMONIC<br />	std    <br />we set direction flag to 1 so that all chain operations use direction to less<br />addresses. (When you change DF to 1 in your window callback procedure - <br />remember to set it to 0 before your proc returns - your proc returns to system<br />code and the code assumes that DF=0)<br />Type next MNEMONICs<br />      mov al,5<br />      stos<br />      dec al<br />Type OPCODE<br />      75 FB<br />This code is analog of what would look in asm source like<br />      	lea edi,<br />	std<br />	mov al,5<br />@@:	<br />	stos<br />	dec al<br />	jne @B<br />As you can see there are no problems to type code right in debugger<br />to check some code, try ideas and find answer for simple questions<br />(for example how some opcode works).<br />The only problem for beginner might be short jump backword (75 FB in our case)<br />Format of the opcode(short relative conditinal jump) in bynary:<br />0111tttn:imm8<br />First 4 bits 0111 identifies that it is relative short conditinal jump.<br />In debugger it shown as 7 as first hex digit of the opcode.<br />Next 4 bits (lower 4 bits of the first byte) is bit field that specifies <br />condition it is called &quot;tttn&quot; and has the same format in all instructions <br />that check flags for condition (all jcc, cmovcc, setcc etc.)<br />second byte is signed value that is added to EIP after jcc instruction is<br />decoded and EIP points to the next to the jcc opcode.<br />Let's &quot;decode&quot; our 75 FB opcode.<br />7 - sign of short relative conditional jump<br />5 - tttn 0101 in banary 0100 - e or zf 0101 ne or not zf, as you can see<br />    changing last bit we changing it to NOT(condition) that's why it is<br />    called &quot;tttn&quot; .<br />FB - it's -5. -5 'cause we need to set EIP back 5 bytes:<br />1 byte   AA             STOS <br />2 bytes  FEC8           DEC AL<br />2 bytes  75 FB          JNZ SHORT <br />----------<br />5 bytes<br /><br />If you want to know more about tttn - have a look at tttn.exe, and<br />not only at the app itself but mostly inside source.<br />Source is written to illustrate inner links iside tttn fields.<br /><br />OK, back to our &quot;register override&quot; topic.<br />Switch to data window.<br />Go to esp-4 address (press ctrl-G and just type &quot;esp-4&quot; and press Enter)<br />Scroll one line up so you could see lower address 'cause we are going to<br />fill string in reverse direction.<br />Execute code step by step (use F8) and see how and were 01 02 03 04 05 bytes<br />are placed.<br />Now we have a string in memory and ready to check how it can be transffered<br />with different selector specified by &quot;segment override&quot; prefixes.<br />First we check if DS CS SS are alias semgent selectors.<br /><br />Type MNEMONIC<br />	lea esi,<br />This will tune esi(source register) to the place where edi was when<br />we started filling the string(remember we fill and move string in reverse<br />direction so put backword to start we add not substruct).<br />edi is already in the end of string-1 position so we can start copying.<br />Opcode for movsb = A4.<br />A4 =   COPY FROM  TO <br />Using &quot;segment override&quot; prefix before A4 we can change selector (segment) for<br />source (we can not do it for destination segment - it always pointed by<br />value in ES)<br />Prefixes to specify CS-2E,SS-36,ES-26<br />fist check DEFAULT<br />Type opcode:<br />	A4<br />Run using F8, look at data window if it has been copied alright.<br />Now check if CS would pass for SOURCE segement selector.<br />Type opcode:<br />	2E A4<br />Run by F8. Check result in data window.<br />Do the same with prefixes 36 and 26.<br />If you did everything correctly you can see that first 4 bytes of our<br />5 bytes string are successfuly copied. That shows that all SS DS CS ES<br />pointed to the same alias segment through different selectors.<br />Try any other segment override prefix - and you will get an error.<br />That last byte of our string we use to check if ES is still matter for<br />32 bit code.<br />Let's change ES.<br />Type OPCODE<br />  66 6A 00<br />it's push WORD 0<br />Type MNEMONIC<br />  pop ES<br />Type opcode (A4) for lodsb or mnemonic itself (for our exersizes the<br />more you type raw opcodes the better)<br />Now run all this 3 instruction using F8.<br />When it comes to lodsb you can not execute the opcode and status bar of<br />OllyDbg says that there are problem.<br />As we now can see ES is actually still used for 2 mem chain instruction,<br />though we don't need to set correct value in it - system do it for us.<br />Let's fix the problem that we created with ES by setting it equal to DS<br />Type in place of last movsb that failed to execute:<br /> push DS<br /> pop ES<br />Execute this two instructions.<br />type again A4.<br />Now everything should work OK.<br />In user mode maybe the only segment register that you would use<br />for something other than education perpose could be FS.<br />It is used for SEH. And now you remember that every time you<br />use FS to specify segment for operation with data it costs you 1 additinal byte <br />and 1 clock.<br />Nevertheless in system programming use of segement registers might have<br />some sence depending on what perpose of your driver is.<br /><br />As to refference of values of segement override prefixes - you know you always<br />can lookup them in your debugger ;)<br />to be continued...</div>
    <div class="meta">Posted on 2002-12-25 13:09:18 by The Svin</div>
   </div>
   <div class="post" id="post-84235">
    <div class="subject"><a href="#post-84235">Opcode#6 prefixes</a></div>
    <div class="body">Next prefix LOCK.<br />There was a nasty story connected with the prefix with<br />Pentium and Pentium MMX :)<br />Known as F00F bug, when using it could freeze pocessor.<br />(for example F00FC7C8)<br />Those who is good in protec mode system understanding could read the detail explanation of nature of the bug in<br />Dr.Dobbs journal.<br />Here is not much special from me to say about using LOCK prefix. It's good explained in Intel refference. I would just<br />quote description to finish with &quot;classic&quot; prefixes.<br />Before it at the end of prefixes topic I want to say about<br />&quot;inproper&quot; use of some prefixes wich was discussed in the<br />&quot;prefixes&quot; part of the tuts, though in models upto PIII including inproper use of prefixes leads just to that processor ignores it, Intel claims that in new models it can have new special meaning and inproper use of them could lead to unpredicted behavior.<br />About new generation of prefixes it worth to mention<br />about 3E &quot;hint&quot; prefix that is used with JCC to help branch predition.<br /><br />Now Intel about LOCK:<br /><br />Causes the processor?s LOCK# signal to be asserted during execution of the accompanying<br />instruction (turns the instruction into an atomic instruction). In a multiprocessor environment,<br />the LOCK# signal insures that the processor has exclusive use of any shared memory while the<br />signal is asserted.<br />Note that in later IA-32 processors (including the Pentium 4, Intel Xeon, and P6 family proces-sors),<br />locking may occur without the LOCK# signal being asserted. See IA-32 Architecture<br />Compatibility below.<br />The LOCK prefix can be prepended only to the following instructions and only to those forms<br />of the instructions where the destination operand is a memory operand: ADD, ADC, AND,<br />BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR,<br />XADD, and XCHG. If the LOCK prefix is used with one of these instructions and the source<br />operand is a memory operand, an undefined opcode exception (#UD) may be generated. An<br />undefined opcode exception will also be generated if the LOCK prefix is used with any instruc-tion<br />not in the above list. The XCHG instruction always asserts the LOCK# signal regardless of<br />the presence or absence of the LOCK prefix.<br />The LOCK prefix is typically used with the BTS instruction to perform a read-modify-write<br />operation on a memory location in shared memory environment.<br />The integrity of the LOCK prefix is not affected by the alignment of the memory field. Memory<br />locking is observed for arbitrarily misaligned fields.<br />IA-32 Architecture Compatibility<br />Beginning with the P6 family processors, when the LOCK prefix is prefixed to an instruction<br />and the memory area being accessed is cached internally in the processor, the LOCK# signal is<br />generally not asserted. Instead, only the processor?s cache is locked. Here, the processor?s cache<br />coherency mechanism insures that the operation is carried out atomically with regards to<br />memory. See ?Effects of a Locked Operation on Internal Processor Caches? in Chapter 7 of IA-32<br />Intel Architecture Software Developer?s Manual, Volume 3, the for more information on<br />locking of caches.</div>
    <div class="meta">Posted on 2003-02-28 18:00:30 by The Svin</div>
   </div>
   <div class="post" id="post-87071">
    <div class="subject"><a href="#post-87071">Opcode#6 prefixes</a></div>
    <div class="body">Svin, I do not understand why lock is needed. Could you help by explaining it to me?</div>
    <div class="meta">Posted on 2003-03-14 08:20:38 by roticv</div>
   </div>
   <div class="post" id="post-87080">
    <div class="subject"><a href="#post-87080">Opcode#6 prefixes</a></div>
    <div class="body">It Used to avoid two processors from updating the same data location.</div>
    <div class="meta">Posted on 2003-03-14 10:15:33 by wizzra</div>
   </div>
   <div class="post" id="post-87347">
    <div class="subject"><a href="#post-87347">Opcode#6 prefixes</a></div>
    <div class="body"><div class="quote"><br />Svin, I do not understand why lock is needed. Could you help by explaining it to me? </div><br />Do you mean in other words then Intel did? :)<br />It's needed only in multiprocessor systems.<br />And only when memory operand during one opcode<br />execution is: <br />- read from memory<br />- changed during ALU operation<br />- written back to memory<br />And only for particular commands.<br />You see here is gap between 1st and 3rd stages. In wich other<br />processor can take data that is being processed and will be overwritten at the end.<br />LOCK makes signal(#LOCK) wich trough BUSs arbitr blocking access to any other processor(s)<br />to shared memory  untill the result of command is written back.<br />Needs mostly for synhronize system work, shared resources etc.<br />Do you need more detailed explonations?</div>
    <div class="meta">Posted on 2003-03-16 05:27:56 by The Svin</div>
   </div>
   <div class="post" id="post-87354">
    <div class="subject"><a href="#post-87354">Opcode#6 prefixes</a></div>
    <div class="body">This should do I suppose. Thanks anyway.</div>
    <div class="meta">Posted on 2003-03-16 06:56:16 by roticv</div>
   </div>
  </div>
 </body>
</html>