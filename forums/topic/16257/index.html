<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>typed assembly - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16257" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=38">Object Oriented Programming</a> &raquo; <a href="../?id=16257">typed assembly</a></p>
   <div class="post" id="post-126229">
    <div class="subject"><a href="#post-126229">typed assembly</a></div>
    <div class="body">I am back:tongue: <br /><br />these days, I have learned O'Caml, Eiffel, and Python and thus got more ideas about type and asm.<br />A few months ago, I have worked out a MACRO implemented OOP model for asm, but now I am interested in a more general topic - type system.<br /><br />two keyword:<br />static typing<br />and type inference<br /><br />We all focused on how to do OOP programming in asm, and using MACRO to invent some new keywords or to say syntax. Yes, we have done that. But now, how about something more? In one model, one maybe use some TEXTEQU to represent a compile time variable, and using these compile-time variables to recode the type infomation related to class(what it inherited from, what fields it have ...).<br /><br />I see a trend: MACRO was over used, I even thought about wrap every line in a MACRO, it may be looks like this:<br /><br />FUNCTION myfunc, arg1:type1, arg2:type2<br />    .MOV eax, 1<br />    .RET<br />FUNCTION END<br /><br />notice the .MOV is a macro to replace mov(a instruction).<br /><br />I want to say using a stand-alone preprocessor just as someone have shown us will be better.and we may implement the following features:<br /><br />single inherit<br />interface (like java)<br />template (like c++)<br />meta programming (to access the info about type when compiling, it will eliminate the need of template specialization or things alike)<br /><br />typed assembly code -&gt; preprocessor -&gt; normal assembly code<br /><br />static typing, type inference(by template) and meta programming will enable asm to do more things, and let the code more safe. studying the ways used in other language(imperative or functional, dynamic or static, typed or untyped) will widen our view.</div>
    <div class="meta">Posted on 2003-12-02 00:28:31 by taowen2002</div>
   </div>
   <div class="post" id="post-126230">
    <div class="subject"><a href="#post-126230">typed assembly</a></div>
    <div class="body">I totally agree!<br /><br />There should be a new kind of assembler - an OOP assembler (some would argue compiler).<br /><br />First, devised a syntax which does not veer greatly from MASM/NASM syntax.<br /><br />Second, choose a method to implement code generation of OOP transformations.<br /><br />Third, ?<br /><br />...I am on the third part. :cool:</div>
    <div class="meta">Posted on 2003-12-02 00:41:55 by bitRAKE</div>
   </div>
   <div class="post" id="post-126234">
    <div class="subject"><a href="#post-126234">typed assembly</a></div>
    <div class="body">I am really very happy you support my idea:grin: <br /><br />let's talk about the implemention detail:<br /><br />I thought generating the native code is very expensive and hard to do, so I want the target enviroment be masm or nams or fnasm(although masm was prefered). <br />the key concept is static typing, it is a revolution just as brought structured programming in asm. and staic typing more than OOP, oop means object-oriented programming, but static typing always resulted in multi-paradigm(generic programming, and meta programming).<br />type will make what the code is doing more precisely and static typing won't consuming a lot resource comparing to dynamic typing.<br /><br />I suggested some syntax here:<br /><br />for class definition:<br /><pre><code><br />class myclass&#58;public baseclass, interface1, interface2<br />    var field1&#58;type1<br />    var normalfiled2&#58;dword<br />    method method1&#40;arg1&#58;type1&#41;<br />class end<br /></code></pre><br /><br />for template procedure:<br /><pre><code><br />template T&#58;typename, i&#58;dword<br />myproc2 proc type1&#58;T<br />    mov eax, i<br />    ret<br />myproc2 endp<br /></code></pre><br /><br />for template class:<br /><pre><code><br />template T1&#58;typename, T2&#58;typename<br />class myclass2<br />    var field1&#58;T1<br />    var field2&#58;T2<br />class end<br /></code></pre><br /><br />and more... I have a lot ideas about syntax and features, I just need a experiment to test which one is better to use.</div>
    <div class="meta">Posted on 2003-12-02 01:29:04 by taowen2002</div>
   </div>
   <div class="post" id="post-126278">
    <div class="subject"><a href="#post-126278">typed assembly</a></div>
    <div class="body">Have you seen <a target="_blank" href="http://www.cs.cornell.edu/talc/">TALC</a>?<br />Sounds like what you want to create.</div>
    <div class="meta">Posted on 2003-12-02 08:50:44 by bitRAKE</div>
   </div>
   <div class="post" id="post-126446">
    <div class="subject"><a href="#post-126446">typed assembly</a></div>
    <div class="body">How should the transition from a complex type to a machine dependant type be made?<br /><br />In all languages that I know complex types are built from basic types and other complex types (circular definitions are bad).  Most languages handle pointers differently -- assembly seems to be the exception.  Of course, most languages offer a mechanism to override the type (casting).<br /><br />MASM attempts to handle pointers a little differently by introducing the PTR/OFFSET/ADDR keywords and the SEG:OFFSET syntax.  IMHO, pointers need to be handled differently due to the introduction of different addressing modes in the x86 processors (and we have 64 bit pointers to include now with x86-64).  Most assembly language programmers don't want anything hidden in the code and MASM goes against this in a bad way, but to offer this abstraction without hiding something is impossible.<br /><br />As most people are aware assembly language is most affective where speed is concerned and this is an economically valued skill - more so than any other.  So, I would like to reduce the language down to the optimization of algorithms and then add a scripting language on top of it.  In many ways this abstracts the instruction set from the control structures of the language, enabling greater ease of scaling and global optimizations.  Some may think this hypocrisy, but this is the direction I want to take assembly language and believe follows in the spirit of what MASM wanted to be as high-level assembler.<br /><br />Combined with a type resolution system which manages the dependancies of: files, objects, functions, macros, symbols, control flow, and instructions; produces quite an assembler if I do say so myself. :)<br /><br />{I'm going to have to continue this...}</div>
    <div class="meta">Posted on 2003-12-03 18:48:35 by bitRAKE</div>
   </div>
   <div class="post" id="post-126462">
    <div class="subject"><a href="#post-126462">typed assembly</a></div>
    <div class="body">yeah, high-level assembler!:alright: <br /><br />to tell the truth, I didn't quite catch on what you have said due to my poor english. But I think we all try to make something different. A new kind of assembler, but no HLA. Or more precisely, a new kind of assembly lanuage. Can you make a more detailed description on what kind of things you want to add?<br /><br /><div class="quote">Most assembly language programmers don't want anything hidden in the code and MASM goes against this in a bad way, but to offer this abstraction without hiding something is impossible.</div> <br /><br />I am quite agree with you on this point. abstraction needs hiding, just as invoke XXXX, you cannot see push/call anymore, but I think most of us prefered invoke to call. And, I see, you try to generalize the structure of asm, maybe you can made the new asm be platform/cpu independant. And I want to add static typing/oop/generic programming/meta programming to asm. They all can make the life of asm coder much easier, and make the asm much more powerful.<br /><br />asm:<br />from plain instruction sequence<br />to .if/.while<br />to structured with proc<br /><br />you want to make expressing how the instructions are organized more easily and I want to make structure the block of code more easily. It may be two different direction, but all goes to one goal, more structured asm.<br /><br />May be I have mistakened what you have said, and you can give a more plain english description about it.<br /><br />some further note about what I want to do:<br /><br />I want to mark symbol with type, the symbol maybe the name of global variable, name of local variable, name of procedure<br />the type itself is just a compile-time symbol. <br />then there will be two benefits, using the typed variable(objects) can be easier, and pass a variable(objects, register value) must be typed correctly.<br />assuming pstruct is a pointer to a struct variable<br /><br />load eax, pstruct<br />mov eax.field1, 0<br /><br />load itself maybe expressed as:<br /><br />mov eax, pstruct<br />cast eax, ptr some_struct<br /><br />the second benefits may be demonstrated as:<br /><br />mov eax,pstruct<br />invoke use_some_struct, eax<br /><br />no, you have to mark the type of eax<br /><br />mov eax,pstruct<br />cast eax, ptr some_struct<br />invoke use_some_struct, eax<br /><br />or:<br />load eax,pstruct<br />invoke use_some_struct,eax<br /><br />because pstruct is a local variable which has been marked with type ptr struct, you can use load directly.</div>
    <div class="meta">Posted on 2003-12-03 21:18:06 by taowen2002</div>
   </div>
   <div class="post" id="post-126465">
    <div class="subject"><a href="#post-126465">typed assembly</a></div>
    <div class="body">IMHO, adding types to assembly language is a higher level abstraction and their items should not be loaded into registers directly unless the programmer is prepared to do all the work.  Your example would reduce to:<pre><code>mov &#91;pstruct&#93;.field1, 0</code></pre>The brackets mean the structure pointer is indirect - we don't want the offset from pstruct's address, but from the offset of the address stored at pstruct.  The assembler does the rest.  pstruct's type would have to be define prior or cast in the statement:<pre><code>mov &#91;pstruct PTR MyStruct&#93;.field1, 0</code></pre>...this would rarely need to be used.  Quite simply, when a programmer states a register they know what they are doing - they want to work at that level.  For example, EAX is used for return values from windows functions - why ever call it EAX? ...it is the return value.  We only call it EAX when we want to do something with EAX.  If we just want to store the return value to a function, then we should say that:<pre><code>invoke MyFunction, MyStruct.item2<br />mov MyStruct.item3, MyFunction.return</code></pre>Seems silly at first, but this is a simple example.  The assembler could inline the function if it wants and integrate it into the rest of the code - all the information to do that is here.  The optimizer could remove the whole thing in rare cases! The interfaces between pieces of code need to be managed by the assembler to provide this functionality.</div>
    <div class="meta">Posted on 2003-12-03 22:02:36 by bitRAKE</div>
   </div>
   <div class="post" id="post-126484">
    <div class="subject"><a href="#post-126484">typed assembly</a></div>
    <div class="body">How about have a talk about *all* the things you want to do...<br /><br />One thing I am sure is, what I am going to do is to write a preprocessor which will produce the nasm/masm/fasm code. No more macro, but a stand-alone preprocessor. It can do global analysis, but macro can not.<br /><br />a bunch of source code(*.xxx) -&gt; all put to the preprocessor -&gt; another bunch of source code(*.inc, *.asm) -&gt; be assembled by nasm/masm/fasm -&gt; native executable file<br /><br />And what?<br />forgive my ignorant</div>
    <div class="meta">Posted on 2003-12-04 01:49:35 by taowen2002</div>
   </div>
   <div class="post" id="post-126496">
    <div class="subject"><a href="#post-126496">typed assembly</a></div>
    <div class="body">Hi taowen2002,<br /><br />the &quot;preprocessor&quot; approach for a OOP implementation is surely much better/powerful than using macros.<br /><br />But, if you know C++, try to consider:<br /><br />- C++ with templates is very powerful. May your approach achieve this level?<br />- for many features you will just have to &quot;reinvent the wheel&quot; regarding C++<br />- C++ has (limited) inline ASM capabilities<br /><br />So currently IMNSHO such a preprocessor would be nice to have, but it is much work and unless it offers more than C++ with templates its possibly a waste of time.<br /><br />Japheth</div>
    <div class="meta">Posted on 2003-12-04 04:17:14 by japheth</div>
   </div>
   <div class="post" id="post-126526">
    <div class="subject"><a href="#post-126526">typed assembly</a></div>
    <div class="body">The compile time programming is the knife of the asm.<br />I have just given up my plan, but I am interested in BitRake's idea. A new assembler is always the goal.</div>
    <div class="meta">Posted on 2003-12-04 08:28:30 by taowen2002</div>
   </div>
   <div class="post" id="post-126532">
    <div class="subject"><a href="#post-126532">typed assembly</a></div>
    <div class="body">Better make it for 64 bit :) If so, count me in - I'll help any way I can.</div>
    <div class="meta">Posted on 2003-12-04 09:07:46 by Homer</div>
   </div>
   <div class="post" id="post-126533">
    <div class="subject"><a href="#post-126533">typed assembly</a></div>
    <div class="body"><div class="quote"><br />So currently IMNSHO such a preprocessor would be nice to have, but it is much work and unless it offers more than C++ with templates its possibly a waste of time.</div>This has been my thinking as well.  So, the goal becomes to eliminate limitations of ASM compared to C++ (other languages as well) while retaining or amplifying the benifits of ASM.  Anything towards that goal is beneficial.<br /><br /><br /><strong>taowen2002</strong>, if you take a look at <strong>KetilO</strong>'s code you will see that he uses very little the registers, and he takes full advantage of the high-level features of MASM.  This is very productive because the work is more symbolic and limitations are few - he quickly goes from idea to code and his understanding of the interfaces is clearly communicated.<br /><br />Now let us go to the other extreme: ...<br /><br />{...to be continued...}</div>
    <div class="meta">Posted on 2003-12-04 09:07:55 by bitRAKE</div>
   </div>
   <div class="post" id="post-126605">
    <div class="subject"><a href="#post-126605">typed assembly</a></div>
    <div class="body"><div class="quote"><br />... So, the goal becomes to eliminate limitations of ASM compared to C++ (other languages as well) while retaining or amplifying the benifits of ASM. ...</div><br />The question is whether that goal gives you the most benefits. As you said, assembly is great for speed but the cases where it matters are rare. One of C++'s big benefits is that it's a HLL but still at such a level that it can compile to pretty efficient code. When it comes to speed, you use assembly and you use it in the lowest level. For example, when you want to get the most out of it you don't use masm's parameter handling, but build your own stackframe. And I think a hand optimized binary search through some list will be more efficient than one using asm templates. My point is: if you're going for absolute speed, you'll avoid as much HLL as possible (until the point where it just gets silly, like hex programming ;))<br /><br />So IMHO, the best approach to use the best of both worlds is not trying to turn assembly into a semi-HLL, but to make it easier to interface the two and use them together. For example, an assembler that compiles on several platforms, automatically writes C(++) headers for the functions it exports etc. At least for me that would be more useful than being able to use templates in asm. <br /><br />Thomas</div>
    <div class="meta">Posted on 2003-12-04 17:24:07 by Thomas</div>
   </div>
   <div class="post" id="post-126609">
    <div class="subject"><a href="#post-126609">typed assembly</a></div>
    <div class="body">Good point <strong>Thomas</strong>, but I don't like programming in C++ and don't need my code to run on non-x86 processors.  I don't really want to create HLA or templates in ASM.  I would like to create more vertical solutions in ASM.  I am confident in the long term viability of x86.<br /><br />Additionally, I don't want to exclude integration with C(++) -- I am just saying that is not what I am going to do.</div>
    <div class="meta">Posted on 2003-12-04 18:04:54 by bitRAKE</div>
   </div>
   <div class="post" id="post-126789">
    <div class="subject"><a href="#post-126789">typed assembly</a></div>
    <div class="body"><div class="quote"><br />Good point <strong>Thomas</strong>, but I don't like programming in C++ and don't need my code to run on non-x86 processors.  I don't really want to create HLA or templates in ASM.  I would like to create more vertical solutions in ASM.  I am confident in the long term viability of x86.</div><br />I should have said OS instead of platform, because that's what I meant. A general assembly for multiple platforms wouldn't be very useful since it could never be optimized for both at the same time. But since C++ is often compiled on several OSes, an assembler that is written in portable C++ that can produce several outputs (COFF, ELF) would probably be a useful thing. I know fasm is already available on linux but if one would write a new assembler I would surely think about support for multiple OSes.<br />It's okay if they all use x86 (though I would design it so that new 64-bit languages etc. can easily be added later), since that's going to be around at least for quite some time.<br /><br />Thomas</div>
    <div class="meta">Posted on 2003-12-06 08:18:13 by Thomas</div>
   </div>
   <div class="post" id="post-126791">
    <div class="subject"><a href="#post-126791">typed assembly</a></div>
    <div class="body"><div class="quote"><br />A general assembly for multiple platforms wouldn't be very useful since it could never be optimized for both at the same time.</div>This is an invalid assumption - there are the same limitations that any language has in that regard.  Please, explain how this statement is true.</div>
    <div class="meta">Posted on 2003-12-06 08:26:33 by bitRAKE</div>
   </div>
   <div class="post" id="post-126806">
    <div class="subject"><a href="#post-126806">typed assembly</a></div>
    <div class="body"><div class="quote"><br />This is an invalid assumption - there are the same limitations that any language has in that regard.  Please, explain how this statement is true. </div><br />The difference with other languages is that assembly isn't compiled. C++ for example can be optimized for two completely different processors because the source is platform independent. <br /><br />Assembly isn't platform independent but written for one specific processor, and thus optimized for that processor. Even if you could assemble the same code for a different processor, which is usually impossible in the first place because of the different opcodes available, it isn't optimized anymore because every processor has its specific optimization techniques.<br /><br />I've seen gcc or some other compiler have a cross platform assembly syntax, where the compiler figures out the register usage etc. So it isn't impossible but choosing registers is not really advanced. Say you have two processors. On one, there's a really fast division opcode that is best suited for all divisions. But on the other, division is slow but there are some other neat opcodes that you can combine in a clever way to perform fast division. How would you express this in assembly? In a HLL, both will just be a / b or something and the compiler will choose the best implementation. Assembly is on a much lower level where you can't express this with such abstraction. You could use a general division opcode 'div' that translates to the division opcode on platform 1 and the trick on platform 2 but still, what if the trick has some side effects that can't be ignored, like extra registers that are invalidated, or flags that change. Also, if the programmer doesn't know what opcodes the pseudo opcode 'div' will produce, how can he optimize around it? <br /><br />The problem in the example above lies in the strange mix of high level and low level coding. On the one hand, you want to work on the lowest level to get the most out of the processor, on the other hand you want to make programmer easier by letting the assembler/compiler make choices for you. <br /><br />Optimizing is all about knowing exactly what's going on in the lowest level. Abstraction only reduces this knowledge and thus is bad for optimizing (at code level that is, not at design level of course). That's why I'm a bit hesitant with HLL extensions to assembly language (even though I worked out an object model with NaN :)).<br /><br />In my opinion, it's best either to use low level programming or high level programming, depending on what suits the task. Mixing low level programming and high level programming at function level is no problem at all either. But creating a language somewhere in between has no real benefits in my view and only weakens the strengths of assembly. Everyone may have his own opinion on this, this is just how I think about it.<br /><br />Thomas</div>
    <div class="meta">Posted on 2003-12-06 10:03:17 by Thomas</div>
   </div>
   <div class="post" id="post-126810">
    <div class="subject"><a href="#post-126810">typed assembly</a></div>
    <div class="body"><strong>Thomas</strong>, great outline of the problems - I thought about this for years and have analyzed all the problems you have stated.  Let us see if I can address them all here:<br /><br />Following the <a target="_blank" href="http://www.cs.virginia.edu/zephyr/">Zephyr Project</a> I learned that they were using machine descriptions to translate code from one to another.  Using a description of each instruction and it's effect on machine state, several layers of code generation can be exposed to the programmer if they desire.  For example, a general routine could be developed at a semi-high-level and as needed the programmer could drop down into more refined views of the code -- some changes would propagate back to the general view while others would be tied to processor specific view.  (Note this isn't limited to processor limitations - each layer can have features that only translate to higher abstractions in a very general way and others will require no translation.)<br /><br />The same algorithms are used to control the interaction between instruction dependancies and procedure/object/file/etc dependancies. :)</div>
    <div class="meta">Posted on 2003-12-06 11:03:34 by bitRAKE</div>
   </div>
   <div class="post" id="post-127414">
    <div class="subject"><a href="#post-127414">typed assembly</a></div>
    <div class="body">The idea of being able to choose a specific abstraction level for each part of the code is nice on itself.. So actually you are creating a whole range of pseudo languages ranging from assembly (if you consider that the lowest level) to some form of HLL? However I think having such a range of languages might be a bit overkill. I mean, C is pretty low level and assembly is even lower but I'm fine with this choice. Is it really advantageous to have another language in between? I guess it's all a matter of where you set the boundaries but I think the change from LLL to HLL is a good boundary and that having extra boundaries leading to a-bit-less-LLs and almost-HLLs doesn't add much advantages (from a practical point of view). I see more in broader boundaries: like low level - high level - functions/methods - classes - modules - applications or something. <br /><br />Thomas</div>
    <div class="meta">Posted on 2003-12-11 13:11:16 by Thomas</div>
   </div>
   <div class="post" id="post-128072">
    <div class="subject"><a href="#post-128072">typed assembly</a></div>
    <div class="body">I would like the langauge to mimic reality - boundaries are perceptual.  The only real boundaries are at external interfaces supported.  I know it seems really messy and it is not what I learned 20 years ago about programming, but I want to give it a try.</div>
    <div class="meta">Posted on 2003-12-16 20:13:15 by bitRAKE</div>
   </div>
  </div>
 </body>
</html>