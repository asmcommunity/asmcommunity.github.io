<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>HLA v2.0 Source Preview - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16659" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=16659">HLA v2.0 Source Preview</a></p>
   <div class="post" id="post-129440">
    <div class="subject"><a href="#post-129440">HLA v2.0 Source Preview</a></div>
    <div class="body">Hi All,<br /><br />I've started putting the HLA v2.0 source code on Webster.<br />Don't get your hopes up, HLA v2.0 is still a *long* ways away at this point. But by putting the source code up on Webster I hope to achieve four things:<br /><br />1. People can watch the progress of HLA v2.0 (or lack thereof), thus encouraging me to keep working on it :-)<br /><br />2. Those interested in working on the HLA v2.0 open source project in the future can start studying the source code today (I intend to open development to others once I get the compile-time language and declarations parsing finished).<br /><br />3. Some people are working on other assemblers and have asked for bits and pieces of the HLA v2.0 source code (because it is very high performance).<br /><br />4. Some people are interested in creating their own HLLs and the HLA declaration parsing code provides a great head start for such languages.<br /><br />In any case, you can check out HLA v2.0's progress at the following web page:<br /><a target="_blank" href="http://webster.cs.ucr.edu/Page_hla/hla2/0_hla2.html">http://webster.cs.ucr.edu/Page_hla/hla2/0_hla2.html</a><br /><br />Enjoy!<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-12-31 13:17:08 by rhyde</div>
   </div>
   <div class="post" id="post-129443">
    <div class="subject"><a href="#post-129443">HLA v2.0 Source Preview</a></div>
    <div class="body">Wow, great!<br /><br />One question though, you mentioned that the standard library needs to be ported over to hla 2.0 (and other OSs I understand) as a long term goal?<br /><br />Will the library not be backward compatible (except for a few minor changes) or does the 'long term goal' apply to other OSs?<br /><br />Thanks for the update.  I'll be following the developemnt closely.</div>
    <div class="meta">Posted on 2003-12-31 13:45:01 by Kain</div>
   </div>
   <div class="post" id="post-129572">
    <div class="subject"><a href="#post-129572">HLA v2.0 Source Preview</a></div>
    <div class="body"><div class="quote"><br />Wow, great!<br /><br />One question though, you mentioned that the standard library needs to be ported over to hla 2.0 (and other OSs I understand) as a long term goal?<br /><br />Will the library not be backward compatible (except for a few minor changes) or does the 'long term goal' apply to other OSs?<br /><br />Thanks for the update.  I'll be following the developemnt closely. </div><br /><br />&quot;Porting&quot; will involve three things:<br /><br />1. There will be (as promised in the HLA manual) some minor syntactical differences between HLA v1.x and HLA v2.0. Therefore, some minor adjustments will need to be made to some of the library source files to get them to compile under 2.0. (Note, btw, that the number of changes are going to be smaller than I originally anticipated because I've made a lot of the &quot;breaking&quot; types of changes to various version of HLA v1.x, as Rene Tournois loves to point out every chance he gets :-)).<br /><br />2. I want to have HLA v2.0 ported to additional OSes. Free BSD, QNX, Solaris, and BeOS 5.0 for starters (in addition to Windows and Linux). To that end, I'm considering doing a special version of the stdlib that makes calls to various C library functions (specifically, the Posix APIs found in the various Unices) in order to ease the porting process (e.g., we don't even want to *begin* to try and write the QNX library routines using only the assembly interface -- it's too crude and depends heavily on the C libraries).<br /><br />3. I want to start optimizing the routines in the stdlib.  Most of them are okay, but many of them can be sped up quite a bit. One of supposed benefits of using library routines is that someone has spent a fair amount of time optimizing those routines. It would be nice to finish this task on the HLA stdlib so that it lives up to expectations.<br /><br />On top of these three things, I'd like to document them better and clean up the semantics a bit (so that the routines do *exactly* the same thing across OSes). Also, it would be nice to add a whole bunch of new routines to the system.  Finally, some reorganization would be nice too (e.g., many of the &quot;fileio&quot; routines really belong in the &quot;os.&quot; namespace).<br /><br />Finally, HLA v2.0's new macro facilities will provide the ability to create a new interface to many of the library routines. As I develop the macro facilities for 2.0, it will be interesting to see if it would be better to change the way you call various routines (e.g., the pattern matching library routines might work better using HLA v2.0's templates rather than context-free macros).<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2004-01-01 22:50:30 by rhyde</div>
   </div>
   <div class="post" id="post-129581">
    <div class="subject"><a href="#post-129581">HLA v2.0 Source Preview</a></div>
    <div class="body">What manner of COFF will you support? COFF? MS-COFF?<br /><br />Will you put debugging infomation into the objs?<br /><br />Kinda curious because if I ever made an assembler I would want one that made obj with debugging info so I could use it with the VC debugger :) <br /><br />How about COFF format info?  Maybe I'll will be able to learn from your code.</div>
    <div class="meta">Posted on 2004-01-02 02:43:11 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-129647">
    <div class="subject"><a href="#post-129647">HLA v2.0 Source Preview</a></div>
    <div class="body">Randall Hyde wrote:<br /><div class="quote">I want to have HLA v2.0 ported to additional OSes. Free BSD, QNX, Solaris, and BeOS 5.0 for starters (in addition to Windows and Linux).</div> <br /><br />ahh great! Beos especially, I haven't programmed for it in ages, but I remember the API/system architecture  was simply a dream, being able to program for it using HLA would be a hoot, and if there ever was a operating system deserving better software support it's Beos. if there's any work in this area that can be done by 'outsiders' please let me know, I'd love to help out!<br /><br />also, any progress report on the 'templates'? from what little you've posted about them they seem extremely powerful, I read some about the Dylan macros and the ability to set up multiple rules really rocks, giving you the ability to create argument overloaded macros, I SURE hope they make it into hla 2.0!<br /><br />now i'm off to skim those pdf's regarding the lexical analyzer and the symbol table, <br /><br />keep up the great work Randall <br />:alright:</div>
    <div class="meta">Posted on 2004-01-03 04:50:25 by BinarySoup</div>
   </div>
   <div class="post" id="post-129790">
    <div class="subject"><a href="#post-129790">HLA v2.0 Source Preview</a></div>
    <div class="body"><div class="quote"><em>Originally posted by BinarySoup </em><br /><br />also, any progress report on the 'templates'? from what little you've posted about them they seem extremely powerful, I read some about the Dylan macros and the ability to set up multiple rules really rocks, giving you the ability to create argument overloaded macros, I SURE hope they make it into hla 2.0!<br /><br /></div><br /><br />To be honest, I haven't thought much about templates recently as I've been busy getting the declarations in HLA to work properly. But rest assured, the whole purpose of templates is to set up multiple rules (i.e., &quot;overloading&quot; to C++ programmers). Haven't figured out the syntax for doing this yet, but this is the whole purpose behind templates.  Indeed, that's where the name comes from - the assembler matches some source code against a particular &quot;template&quot; and then generates code according to the rules associated with the particular match.<br /><br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2004-01-04 21:53:43 by rhyde</div>
   </div>
  </div>
 </body>
</html>