<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>This code is bigger than it should be - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19862" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=19862">This code is bigger than it should be</a></p>
   <div class="post" id="post-152568">
    <div class="subject"><a href="#post-152568">This code is bigger than it should be</a></div>
    <div class="body">I know this code is bigger than it needs to be.<br /> I don't know quite how to exit it if Netscape is running.<br /> <br /> Could someone help reduce it's size as well.<br /> <br /> Thanks.<br /><br /><pre><code><br /><br />; merge.asm  Run another program&#40;batch file for now&#41;<br />             but only if Netscape isn't running.<br />;            Add code later to show message box<br /><br /><br /> .486                       <br />    .model flat, stdcall       ; 32 bit memory model<br />    option casemap &#58;none       ; case sensitive<br /><br /><br />    include \masm32\include\windows.inc<br />    include \masm32\include\masm32.inc<br />    include \masm32\include\gdi32.inc<br />    include \masm32\include\user32.inc<br />    include \masm32\include\kernel32.inc<br />    include \masm32\include\Comctl32.inc<br />    include \masm32\include\comdlg32.inc<br />    include \masm32\include\shell32.inc<br />    include \masm32\include\oleaut32.inc<br />    include \masm32\macros\macros.asm<br /><br />    includelib \masm32\lib\masm32.lib<br />    includelib \masm32\lib\gdi32.lib<br />    includelib \masm32\lib\user32.lib<br />    includelib \masm32\lib\kernel32.lib<br />    includelib \masm32\lib\Comctl32.lib<br />    includelib \masm32\lib\comdlg32.lib<br />    includelib \masm32\lib\shell32.lib<br />    includelib \masm32\lib\oleaut32.lib<br /><br />.data <br /><br />      ProcessNameToSearchFor    BYTE &quot;C&#58;\PROGRAM FILES\NETSCAPE\NETSCAPE\NETSCP.EXE&quot;, 0         <br />      ProcessNameLength         DWORD 45       ; length not including null-termination<br /><br />.code<br /><br />start&#58;<br /><br />main proc<br /><br />    LOCAL buffer&#91;260&#93;&#58;BYTE<br /><br />    call  TestAppRunning     ; see if Netscape is running, if so exit<br />                             <br />    invoke GetCL,1,ADDR buffer<br /><br />    fn ShellExecute,0,&quot;open&quot;,ADDR buffer,NULL,NULL,SW_SHOWNORMAL<br /><br />    invoke ExitProcess,0<br /><br />main endp<br /><br />align 4<br /><br />TestAppRunning    proc    syscall<br />    LOCAL Process&#58;PROCESSENTRY32, SnapShot&#58;DWORD<br /><br />comment    * -----------------------------------------------------------------------------<br />            Test if application is already running. App name wanted and its length are<br />            coded in the .data section.<br /><br />            On exit&#58;<br />                EAX = 0 if not running or unsuccessful, else nonzero<br />            EBX/EBP/EDI/ESI are preserved.<br />            ----------------------------------------------------------------------------- *<br /><br />        push    ebx<br />        push    edi<br />        push    esi<br /><br />        invoke  CreateToolhelp32Snapshot, TH32CS_SNAPPROCESS, 0<br />        test    eax, eax<br />        jz      AppNotRunning                           ; unable to create SnapShot<br /><br />        mov     SnapShot, eax<br />        mov     Process.dwSize, &#40;SIZEOF PROCESSENTRY32&#41;<br />        invoke  Process32First, SnapShot, ADDR Process  ; return first process handle<br /><br />TestValidHandle&#58;<br />        test    eax, eax<br />        jz      CloseSnapHandle<br /><br />TestProcessName&#58;<br />        xor     eax, eax                                ; counter for name length<br />        lea     esi, Process.szExeFile<br />        lea     edi, ProcessNameToSearchFor<br />@@&#58;<br />        add     eax, 1<br />        cmp     BYTE PTR &#91;esi+eax-1&#93;, 0<br />        je      @F<br />        cmp     BYTE PTR &#91;esi+eax-1&#93;, &quot;a&quot;<br />        jb      @B<br />        cmp     BYTE PTR &#91;esi+eax-1&#93;, &quot;z&quot;<br />        ja      @B<br />        sub     BYTE PTR &#91;esi+eax-1&#93;, 32<br />        jmp     @B<br />@@&#58;<br />        sub     eax, ProcessNameLength<br />        jbe     GetNextProcess                          ; exit if process name not long enough<br /><br />        mov     cl, &#91;edi&#93;                               ; get 1st char in pattern<br />        add     esi, eax                                ; add source length<br />        neg     eax                                     ; invert sign<br /><br />ScanProcess&#58;<br />        cmp     cl, &#91;esi+eax&#93;                           ; scan for 1st byte of pattern<br />        je      PreMatchProcess                         ; test if it matches<br /><br />NextScanPosition&#58;<br />        add     eax, 1<br />        js      ScanProcess                             ; exit on sign inversion<br /><br />GetNextProcess&#58;<br />        invoke  Process32Next, SnapShot, ADDR Process   ; return next process handle<br />        jmp     TestValidHandle<br /><br />PreMatchProcess&#58;<br />        mov     edx, ProcessNameLength                  ; put pattern length into EDX<br />        lea     ebx, &#91;esi+eax&#93;                          ; put current scan address in EBX<br /><br />TestMatchProcess&#58;<br />        mov     ch, &#91;edi+edx-1&#93;                         ; load last byte of pattern length<br />        cmp     ch, &#91;ebx+edx-1&#93;                         ; compare it with last byte in main string<br />        jne     NextScanPosition                        ; jump back on mismatch<br /><br />        sub     edx, 1<br />        jnz     TestMatchProcess                        ; 0 = match, fall through on match<br /><br />        invoke  CloseHandle, SnapShot                   ; returns non-zero if process exists<br />        jmp     AppIsRunning<br /><br />CloseSnapHandle&#58;<br />        invoke  CloseHandle, SnapShot<br /><br />AppNotRunning&#58;<br />        xor     eax, eax                                ; returns zero if unsuccessful<br />                                                        ; or process does not exist<br />          <br />AppIsRunning&#58;<br />        pop     esi<br /><br />        cmp     eax,0                         ; if eax isn't zero, don't proceed<br />        ;jnz     dont_runbat                ; execute portion of program <br />                                                    ; that runs the batch file<br />        pop     edi<br />        pop     ebx<br />        ret<br /><br />TestAppRunning    endp <br /><br /><br />end start <br /></code></pre></code></pre></div>
    <div class="meta">Posted on 2004-11-08 18:57:30 by skywalker</div>
   </div>
   <div class="post" id="post-152586">
    <div class="subject"><a href="#post-152586">This code is bigger than it should be</a></div>
    <div class="body">SkyWalker,<br /><br />Here is a very simple way to do what you are after IF Netscape is the only browser to use the Mozilla engine.<br /><pre><code><br />; ?????????????????????????????????????????????????????????????????????????<br /><br />main proc<br /><br />    LOCAL hNetscape &#58;DWORD<br />    LOCAL buffer&#91;128&#93;&#58;BYTE<br /><br />    invoke GetCL,1,ADDR buffer<br /><br />    mov hNetscape, FUNC&#40;FindWindow,chr$&#40;&quot;MozillaWindowClass&quot;&#41;,NULL&#41;<br /><br />    .if eax == 0                            ; if windows cannot be found<br />      invoke WinExec,ADDR buffer, 1         ; start it<br />    .else                                   ; otherwise<br />      invoke SetForegroundWindow,hNetscape  ; set it to the forground<br />    .endif<br /><br />    ret<br /><br />main endp<br /><br />; ?????????????????????????????????????????????????????????????????????????<br /><br /></code></pre><br />Tested and works fine but if you also have Firefox or K-Melion that use the Mozilla engine, it can work on them as well without distinguishing which is which.<br /><br />A slightly more complicated version is to enumerate all of the running windows in the system and test if the word &quot;Netscape&quot; is in the window title.</div>
    <div class="meta">Posted on 2004-11-09 03:25:06 by hutch--</div>
   </div>
   <div class="post" id="post-152591">
    <div class="subject"><a href="#post-152591">Some feedback from others on my code</a></div>
    <div class="body"><div class="quote">SkyWalker,<br /><br />Here is a very simple way to do what you are after IF Netscape is the only browser to use the Mozilla engine.<br /><pre><code><br />; ?????????????????????????????????????????????????????????????????????????<br /><br />main proc<br /><br />    LOCAL hNetscape :DWORD<br />    LOCAL buffer[128]:BYTE<br /><br />    invoke GetCL,1,ADDR buffer<br /><br />    mov hNetscape, FUNC(FindWindow,chr$(&quot;MozillaWindowClass&quot;),NULL)<br /><br />    .if eax == 0                            ; if windows cannot be found<br />      invoke WinExec,ADDR buffer, 1         ; start it<br />    .else                                   ; otherwise<br />      invoke SetForegroundWindow,hNetscape  ; set it to the forground<br />    .endif<br /><br />    ret<br /><br />main endp<br /><br />What exactiy is the SetForegroundWindow statement doing.<br /><br />I have gotten this feedback from someone else about my code.<br />Is it a lot more code to have it work on XP. <br /><br />That's a nice attempt there. You could keep it as is but bear in mind 2 things. First,the Toolhelp32 API does not run on all windows distributions.Second,there's not really a need to search for all processes to find a a particular one,just call FindWindow to get it's window handle back.</div>
    <div class="meta">Posted on 2004-11-09 06:38:13 by skywalker</div>
   </div>
   <div class="post" id="post-152598">
    <div class="subject"><a href="#post-152598">This code is bigger than it should be</a></div>
    <div class="body">SetForgroundWindow does exactly what it says, it sets the window that you set as the handle parameter as the forground window which means if it was covered up, it comes up to the top. The API changes what is called the Z order which is the x, y, Z axis.<br /><br />The logic of the small test piece is display the browser if its already running otherwise start it.</div>
    <div class="meta">Posted on 2004-11-09 08:02:03 by hutch--</div>
   </div>
   <div class="post" id="post-152619">
    <div class="subject"><a href="#post-152619">I don't want browser started</a></div>
    <div class="body"><div class="quote">SetForgroundWindow does exactly what it says, it sets the window that you set as the handle parameter as the forground window which means if it was covered up, it comes up to the top. The API changes what is called the Z order which is the x, y, Z axis.<br /><br />The logic of the small test piece is display the browser if its already running otherwise start it.</div><br /><br />I don't want the browser started. My batch file zips up and deletes files the browser uses, thus I want to exit out if it's running. Later as I get more familiar I can maybe show an error message.</div>
    <div class="meta">Posted on 2004-11-09 16:15:05 by skywalker</div>
   </div>
   <div class="post" id="post-152772">
    <div class="subject"><a href="#post-152772">This code is bigger than it should be</a></div>
    <div class="body">Hi skywalker.<br /><br />You can start by declaring ProcessNameLength as a constant. an immediate value.<br />that way you dont waste space on data. and your mov and sub dont refer to a memory address, but an immediate value. making it twice as fast.<br /><pre><code><br />ProcessNameToSearchFor    BYTE &quot;C&#58;\PROGRAM FILES\NETSCAPE\NETSCAPE\NETSCP.EXE&quot;, 0<br /><br />ProcessNameLength  equ $ - ProcessNameToSearchFor    ; length including null-termination!<br />ProcessNameLength2 equ $ - ProcessNameToSearchFor-1  ; length not including null-termination!<br /></code></pre><br />..<br /><pre><code><br />mov     SnapShot, eax<br />mov     Process.dwSize, &#40;SIZEOF PROCESSENTRY32&#41;<br />invoke  Process32First, SnapShot, ADDR Process  ; return first process handle <br /></code></pre><br />right there! you can push eax instead of SnapShot! 1 cycle compared to pushing  4 cycles. and a couple bytes shorter.<br /><br />and what the hell is all of this! you add and then you subtract and then i dont know wtf you are doing:<br /><br /><pre><code><br />@@&#58;<br />        add     eax, 1<br />        cmp     BYTE PTR &#91;esi+eax-1&#93;, 0<br />        je      @F<br />        cmp     BYTE PTR &#91;esi+eax-1&#93;, &quot;a&quot;<br />        jb      @B<br />        cmp     BYTE PTR &#91;esi+eax-1&#93;, &quot;z&quot;<br />        ja      @B<br />        sub     BYTE PTR &#91;esi+eax-1&#93;, 32<br />        jmp     @B<br />@@&#58; <br /></code></pre><br /><br />ok here we go.<br /><pre><code><br />        add  eax, 1    ; 3 bytes<br />        inc  eax       ; 1 byte. unsigned add 1.<br /><br />; also dont do this stupid crap&#58;<br /><br />        add     eax, 1<br />        cmp     BYTE PTR &#91;esi+eax-1&#93;, whatever..<br /><br />; better solution&#58;<br /><br />        xor     eax, eax<br />        dec     eax                              ; before hand.<br />        ..<br />        inc     eax<br />        cmp     BYTE PTR &#91;esi+eax&#93;, 0<br />        ..<br />        sub     eax, ProcessNameLength-1     ; because you lost 1 byte size on the dec eax.<br />                                             ; this wont effect code size\speed because ProcessNameLength is a constant<br /><br /><br />; best solution&#58;<br />        lea     esi, Process.szExeFile - 1   ; same size and cycles. no extra commands.<br />        ..<br />        inc     eax<br />        cmp     BYTE PTR &#91;esi+eax&#93;, 0<br />        je      @F<br /><br /></code></pre><br />and then i really didnt understand how you are comparing the 2 string and i have to go since its 5am. but there is always more things to optimize. have fun.</div>
    <div class="meta">Posted on 2004-11-12 06:22:22 by pwn</div>
   </div>
   <div class="post" id="post-152802">
    <div class="subject"><a href="#post-152802">Thanks and someone else did a lot of the &quot;crappy coding</a></div>
    <div class="body"><div class="quote">Hi skywalker.<br /><br />You can start by declaring ProcessNameLength as a constant. an immediate value.<br />that way you dont waste space on data. and your mov and sub dont refer to a memory address, but an immediate value. making it twice as fast.<br /><pre><code><br />ProcessNameToSearchFor    BYTE &quot;C&#58;\PROGRAM FILES\NETSCAPE\NETSCAPE\NETSCP.EXE&quot;, 0<br /><br />ProcessNameLength  equ $ - ProcessNameToSearchFor    ; length including null-termination!<br />ProcessNameLength2 equ $ - ProcessNameToSearchFor-1  ; length not including null-termination!<br /></code></pre><br />..<br /><pre><code><br />mov     SnapShot, eax<br />mov     Process.dwSize, &#40;SIZEOF PROCESSENTRY32&#41;<br />invoke  Process32First, SnapShot, ADDR Process  ; return first process handle <br /></code></pre><br />right there! you can push eax instead of SnapShot! 1 cycle compared to pushing  4 cycles. and a couple bytes shorter.<br /><br />and what the hell is all of this! you add and then you subtract and then i dont know wtf you are doing:<br /><br />Most of the code was written by someone else and I am trying to learn<br />what is going on.<br /><br /><br /><pre><code><br />@@&#58;<br />        add     eax, 1<br />        cmp     BYTE PTR &#91;esi+eax-1&#93;, 0<br />        je      @F<br />        cmp     BYTE PTR &#91;esi+eax-1&#93;, &quot;a&quot;<br />        jb      @B<br />        cmp     BYTE PTR &#91;esi+eax-1&#93;, &quot;z&quot;<br />        ja      @B<br />        sub     BYTE PTR &#91;esi+eax-1&#93;, 32<br />        jmp     @B<br />@@&#58; <br /></code></pre><br /><br />ok here we go.<br /><pre><code><br />        add  eax, 1    ; 3 bytes<br />        inc  eax       ; 1 byte. unsigned add 1.<br /><br />; also dont do this stupid crap&#58;<br /><br />        add     eax, 1<br />        cmp     BYTE PTR &#91;esi+eax-1&#93;, whatever..<br /><br />; better solution&#58;<br /><br />        xor     eax, eax<br />        dec     eax                              ; before hand.<br />        ..<br />        inc     eax<br />        cmp     BYTE PTR &#91;esi+eax&#93;, 0<br />        ..<br />        sub     eax, ProcessNameLength-1     ; because you lost 1 byte size on the dec eax.<br />                                             ; this wont effect code size\speed because ProcessNameLength is a constant<br /><br /><br />; best solution&#58;<br />        lea     esi, Process.szExeFile - 1   ; same size and cycles. no extra commands.<br />        ..<br />        inc     eax<br />        cmp     BYTE PTR &#91;esi+eax&#93;, 0<br />        je      @F<br /><br /></code></pre><br />and then i really didnt understand how you are comparing the 2 string and i have to go since its 5am. but there is always more things to optimize. have fun.</div><br /><br />Thanks for your help, I will look over it so I can understand a little <br />better what's going on.<br /><br />One of the things that is harder to get used to in Win32 code I have seen<br />is the lack of commentation compared to what is in most 16 bit code.<br /><br />Coders could at least put a few sentences at the top giving a general<br />description of what the program, dll, or whatever is doing otherwise a lot<br />of people might get scared off. :-)</div>
    <div class="meta">Posted on 2004-11-12 17:20:50 by skywalker</div>
   </div>
  </div>
 </body>
</html>