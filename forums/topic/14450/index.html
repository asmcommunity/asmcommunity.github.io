<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Macro to replace the invoke statement - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=14450" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=14450">Macro to replace the invoke statement</a></p>
   <div class="post" id="post-111694">
    <div class="subject"><a href="#post-111694">Macro to replace the invoke statement</a></div>
    <div class="body">Has anyone a macro to replace the invoke statement? <br />I need to introduce a special code sequence between the argument push and the call instruction for a new OOP approach.</div>
    <div class="meta">Posted on 2003-07-24 07:10:44 by Biterider</div>
   </div>
   <div class="post" id="post-111708">
    <div class="subject"><a href="#post-111708">Macro to replace the invoke statement</a></div>
    <div class="body">What's ur calling convention like for your OOP approach?</div>
    <div class="meta">Posted on 2003-07-24 08:12:41 by roticv</div>
   </div>
   <div class="post" id="post-111716">
    <div class="subject"><a href="#post-111716">Macro to replace the invoke statement</a></div>
    <div class="body">I can use any calling convention, since invoke is flexible. So I'm looking for a macro with the same functionality!</div>
    <div class="meta">Posted on 2003-07-24 09:20:15 by Biterider</div>
   </div>
   <div class="post" id="post-111731">
    <div class="subject"><a href="#post-111731">Macro to replace the invoke statement</a></div>
    <div class="body">Look in the FASM package: <a target="_blank" href="http://www.flatassembler.net">http://www.flatassembler.net</a><br />There have one. Maybe you can adapt it for MASM. (Or better pass on to FASM :grin: )</div>
    <div class="meta">Posted on 2003-07-24 12:09:01 by JohnFound</div>
   </div>
   <div class="post" id="post-111793">
    <div class="subject"><a href="#post-111793">Macro to replace the invoke statement</a></div>
    <div class="body">Here are mine:<br /><pre><code>pushx MACRO parameters&#58;VARARG<br />	LOCAL param, reversed, c<br />	param TEXTEQU &lt;&gt;<br />	reversed TEXTEQU &lt;&gt;<br />	forc c, &lt;&amp;parameters&gt;<br />		IFIDN &lt;c&gt;, &lt; &gt;<br />			reversed CATSTR param, &lt; &gt;, reversed<br />			param TEXTEQU &lt;&gt;<br />		ELSE<br />			param CATSTR param, &lt;c&gt;<br />		ENDIF<br />	endm<br />	reversed CATSTR param, &lt; &gt;, reversed<br />	param TEXTEQU &lt;&gt;<br />%	forc c, &lt;&amp;reversed&gt;<br />		IFIDN &lt;c&gt;, &lt; &gt;<br />			push	param<br />			param TEXTEQU &lt;&gt;<br />		ENDIF<br />		param CATSTR param, &lt;c&gt;<br />	endm<br />ENDM<br />popx MACRO parameters&#58;VARARG<br />	LOCAL param, c<br />	param TEXTEQU &lt;&gt;<br />	forc c, &lt;&amp;parameters&gt;<br />		IFIDN &lt;c&gt;, &lt; &gt;<br />			pop	param<br />			param TEXTEQU &lt;&gt;<br />		ENDIF<br />		param CATSTR param, &lt;c&gt;<br />	endm<br />	pop	param<br />ENDM<br />_call MACRO procedure, parameters&#58;VARARG<br />	LOCAL param, reversed<br />	reversed TEXTEQU &lt;&gt;<br />%	for	param, &lt;parameters&gt;<br />		reversed CATSTR &lt;param&gt;, &lt;!,&gt;, reversed<br />	endm<br />%	for	param, &lt;reversed&gt;<br />		push	param<br />	endm<br />	call	dword ptr procedure<br />ENDM</code></pre><br /><br />The last one is what you need. The first two others are extended versions of push/pop that accept multiple operands.</div>
    <div class="meta">Posted on 2003-07-24 20:30:22 by comrade</div>
   </div>
   <div class="post" id="post-111797">
    <div class="subject"><a href="#post-111797">Macro to replace the invoke statement</a></div>
    <div class="body">Here is my macro.  Ratch<br /><br /><pre><code><br />; ******************************************************************************<br />RPUSHIT MACRO args&#58;VARARG<br />%PUSHIT @ArgRev&#40;args&#41;<br />ENDM<br />; ******************************************************************************<br />;-------------------------------------------------------------------------------<br />INVOKIT MACRO P1&#58;REQ,P2&#58;VARARG<br /> IFNB &lt;P2&gt;<br />  RPUSHIT P2<br /> ENDIF<br /> CALL P1<br />ENDM<br />;-------------------------------------------------------------------------------<br /></code></pre></div>
    <div class="meta">Posted on 2003-07-24 20:48:01 by Ratch</div>
   </div>
   <div class="post" id="post-111821">
    <div class="subject"><a href="#post-111821">Macro to replace the invoke statement</a></div>
    <div class="body">Does somebody know if there is a way that a macro knows what calling convention is been used?</div>
    <div class="meta">Posted on 2003-07-25 01:24:23 by Biterider</div>
   </div>
   <div class="post" id="post-111899">
    <div class="subject"><a href="#post-111899">Macro to replace the invoke statement</a></div>
    <div class="body">Set a flag or some... then let the macro check the  flag for see what is the callong convention that  you are using.. or some like that.. also i have a macro for nasm that let you use locals var with esp and the default ebp without touching your code ;)<br /><br />Nice day.</div>
    <div class="meta">Posted on 2003-07-25 17:12:01 by rea</div>
   </div>
   <div class="post" id="post-111962">
    <div class="subject"><a href="#post-111962">Macro to replace the invoke statement</a></div>
    <div class="body"><div class="quote">Has anyone a macro to replace the invoke statement?</div><br /><pre><code>&#91;size=9&#93;<br />;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;<br /><br />@ArgCount MACRO arglist&#58;VARARG<br />    LOCAL count, arg<br />    count = 0<br />    FOR arg, &lt;arglist&gt;<br />        count = count + 1<br />    ENDM  <br />    EXITM %count<br />ENDM<br /><br />;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;<br /><br />@ArgRev MACRO arglist<br />    LOCAL txt, arg<br />    txt TEXTEQU &lt;&gt;<br />%   FOR arg, &lt;arglist&gt;<br />        txt CATSTR &lt;arg&gt;, &lt;!,&gt;, txt<br />    ENDM<br />    txt SUBSTR  txt, 1, @SizeStr&#40;%txt&#41; - 1<br />    txt CATSTR  &lt;!&lt;&gt;, txt, &lt;!&gt;&gt;<br />    EXITM txt<br />ENDM<br /><br />;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;<br /><br />_call MACRO arglist&#58;VARARG<br /><br />local n, a, sz, q, arg, line, reax<br />    reax = 0<br /><br />    n TEXTEQU @ArgCount&#40; &lt;arglist&gt; &#41;<br />    % FOR arg, @ArgRev&#40; &lt;arglist&gt; &#41;<br />        n TEXTEQU %&#40;n - 1&#41;<br />        IF n EQ 0<br />            IF reax                            ;; if eax was used report error<br />                IFIDNI &lt;arg&gt;, &lt;eax&gt;<br />                    line TEXTEQU %@Line<br />                    % ECHO @FileCur&#40;line&#41; &#58; ERROR! Register value overwritten by _call macro.<br />                    .ERR<br />                ENDIF        <br />            ENDIF<br />            call arg<br />            IF &#40;OPATTR &#40; arg &#41;&#41; AND 10000000y<br />                ;; References an external label<br />                IF &#40;&#40;OPATTR &#40; arg &#41;&#41; AND 11100000000y&#41; EQ 00100000000y<br />                    ;; Uses C calling convention &#40;_cdecl&#41;<br />                    n TEXTEQU @ArgCount&#40; &lt;arglist&gt; &#41;<br />                    add esp, &#40;n - 1&#41; * sizeof DWORD<br />                ENDIF<br />            ENDIF<br />        ELSE<br />            ;;IF @InStr&#40;1, &lt;arg&gt;, &lt;addr &gt;&#41; OR @InStr&#40;1, &lt;arg&gt;, &lt;ADDR &gt;&#41;<br />            IF $IsAddr&#40;arg&#41;<br />                a SUBSTR &lt;arg&gt;, 6<br />                IF $IsStack&#40;a&#41;                ;; Is relative to SS<br />                    lea eax, a<br />                    push eax<br />                    reax = 1                  ;; no more eax<br />                ELSE<br />                    push offset a<br />                ENDIF<br />            ELSEIF @InStr&#40;1, @SubStr&#40;&lt;arg&gt;, 1 , 1&#41;, &lt;!&quot;&gt;&#41;<br />                push $T0&#40;,&lt;arg&gt;,&#41;<br />                ;push $TEXT&#40;,&lt;arg&gt;,&#41;<br />            ELSEIF @InStr&#40;1, @SubStr&#40;&lt;arg&gt;, 1 , 1&#41;, &lt;&amp;&gt;&#41;<br />                a SUBSTR &lt;arg&gt;, 2<br />                IF $IsStack&#40;a&#41;                ;; Is relative to SS<br />                    lea eax, a<br />                    push eax<br />                    reax = 1                  ;; no more eax<br />                ELSE<br />                    push offset a<br />                ENDIF<br />            ELSE<br />                IF $IsImm&#40;arg&#41;<br />                    IF arg EQ 0        <br />                        IF @SizeStr&#40;%_ZERO_REG_&#41; NE 0<br />                            push _ZERO_REG_<br />                        ELSE<br />                            push 0<br />                        ENDIF<br />                    ELSE<br />                        push arg<br />                    ENDIF<br />                ELSE<br />                    push arg<br />                ENDIF<br />            ENDIF<br />        ENDIF<br />    ENDM<br />ENDM<br /><br />$call MACRO arglist&#58;VARARG<br />    ;;EXITM $RMR&#40;_call arglist&#41;<br />    _call arglist<br />    EXITM &lt;eax&gt;<br />ENDM<br />&#91;/size&#93;</code></pre><br /><br /><br /><div class="quote">Does somebody know if there is a way that a macro knows what calling convention is been used?</div><br />It's easy with <strong>OPATTR</strong> operator.<br />See Chapter 9 &quot;Using Macros&quot; of masm reference. The _call/$call macros recognize _cdecl cc using OPATTR.</div>
    <div class="meta">Posted on 2003-07-26 10:12:14 by Four-F</div>
   </div>
   <div class="post" id="post-112008">
    <div class="subject"><a href="#post-112008">Macro to replace the invoke statement</a></div>
    <div class="body">Thanks Four-F!<br />I try to use your _call macro but I miss the following macros and declarations<br /><br />$IsAddr<br />$IsImm<br />$IsStack<br />$RMR<br />$T0<br />$TEXT<br />_ZERO_REG_<br /><br />Can you send them to me?</div>
    <div class="meta">Posted on 2003-07-27 03:07:29 by Biterider</div>
   </div>
   <div class="post" id="post-112014">
    <div class="subject"><a href="#post-112014">Macro to replace the invoke statement</a></div>
    <div class="body">I have a bunch of useful $IsXXX macros:<br /><br /><pre><code>&#91;size=9&#93;<br />$IsCodeLabel MACRO Operand&#58;REQ<br />    IF &#40;OPATTR &#40;Operand&#41;&#41; AND 00000001y<br />        ;; References a code label<br />        EXITM &lt;-1&gt;<br />    ELSE<br />        EXITM &lt;0&gt;<br />    ENDIF<br />ENDM<br /><br />$IsMem MACRO Operand&#58;REQ<br />    IF &#40;OPATTR &#40;Operand&#41;&#41; AND 00000010y<br />        ;; Is a memory variable or has a relocatable data label<br />        EXITM &lt;-1&gt;              ;; True<br />    ELSE<br />        EXITM &lt;0&gt;               ;; False<br />    ENDIF<br />ENDM<br /><br />$IsImm MACRO Operand&#58;REQ<br />    IF &#40;OPATTR &#40;Operand&#41;&#41; AND 00000100y<br />        ;; Is an immediate value<br />        EXITM &lt;-1&gt;<br />    ELSE<br />        EXITM &lt;0&gt;<br />    ENDIF<br />ENDM<br /><br />$IsDirMemAddr MACRO Operand&#58;REQ<br />    IF &#40;OPATTR &#40;Operand&#41;&#41; AND 00001000y<br />        ;; Uses direct memory addressing<br />        EXITM &lt;-1&gt;<br />    ELSE<br />        EXITM &lt;0&gt;<br />    ENDIF<br />ENDM<br /><br />$IsReg MACRO Operand&#58;REQ<br />    IF &#40;OPATTR &#40;Operand&#41;&#41; AND 00010000y<br />        ;; Is a register value<br />        EXITM &lt;-1&gt;<br />    ELSE<br />        EXITM &lt;0&gt;<br />    ENDIF<br />ENDM<br /><br />$IsNoError MACRO Operand&#58;REQ<br />    IF &#40;OPATTR &#40;Operand&#41;&#41; AND 00100000y<br />        ;; References no undefined symbols and is without error<br />        EXITM &lt;-1&gt;<br />    ELSE<br />        EXITM &lt;0&gt;<br />    ENDIF<br />ENDM<br /><br />$IsStack MACRO Operand&#58;REQ<br />    IF &#40;OPATTR &#40;Operand&#41;&#41; AND 01000000y<br />        ;; relative to SS<br />        EXITM &lt;-1&gt;<br />    ELSE<br />        EXITM &lt;0&gt;<br />    ENDIF<br />ENDM<br /><br />$IsExtLabel MACRO Operand&#58;REQ<br />    IF &#40;OPATTR &#40;Operand&#41;&#41; AND 10000000y<br />        ;; References an external label<br />        EXITM &lt;-1&gt;<br />    ELSE<br />        EXITM &lt;0&gt;<br />    ENDIF<br />ENDM<br /><br />$IsAddr MACRO Operand&#58;REQ<br />local a<br />    a = 0<br /><br />    IF @SizeStr&#40;&lt;Operand&gt;&#41; GT 5        <br />        IFIDNI &lt;addr &gt;, @SubStr&#40;&lt;Operand&gt;, 1 , 5&#41;<br />            a = 1<br />        ENDIF<br />    ENDIF<br /><br />    IF a<br />        EXITM &lt;-1&gt;<br />    ELSE<br />        EXITM &lt;0&gt;<br />    ENDIF<br />ENDM<br /><br />$IsByte MACRO Operand&#58;REQ<br />local r, f<br />    f = 0<br />    IF &#40;TYPE Operand&#41; EQ 1<br />        EXITM &lt;-1&gt;<br />    ELSE            ; dunno why, but &#40;TYPE al, bl..&#41; doesn't work<br />        FOR r, &lt;al,ah,bl,bh,cl,ch,dl,dh,&gt;<br />            IFIDNI &lt;Operand&gt;, &lt;r&gt;<br />                f = 1<br />                EXITM<br />            ENDIF<br />        ENDM<br />        IF f<br />            EXITM &lt;-1&gt;<br />        ELSE<br />            EXITM &lt;0&gt;<br />        ENDIF<br />    ENDIF<br />ENDM<br /><br />$IsWord MACRO Operand&#58;REQ<br />    IF &#40;TYPE Operand&#41; EQ 2<br />        EXITM &lt;-1&gt;<br />    ELSE<br />        EXITM &lt;0&gt;<br />    ENDIF<br />ENDM<br /><br />$IsDword MACRO Operand&#58;REQ<br />    IF &#40;TYPE Operand&#41; EQ 4<br />        EXITM &lt;-1&gt;<br />    ELSE<br />        EXITM &lt;0&gt;<br />    ENDIF<br />ENDM<br />&#91;/size&#93;</code></pre><br /><br /><br />$RMR and $TEXT are commented out, so forget about it.<br /><br />$T0 is my old macro to define text. Now there are collection of such macros in Strings.mac (see attach).<br />At the beginning of Strings.mac there are description and examples how to use it. It also the part of my KmdKit.<br /><br /><br /><pre><code>ELSEIF @InStr&#40;1, @SubStr&#40;&lt;arg&gt;, 1 , 1&#41;, &lt;!&quot;&gt;&#41;<br />    push $T0&#40;,&lt;arg&gt;,&#41;</code></pre><br /><br />The above lines in _call macro let you define text directly like this:<br /><br /><pre><code>_call MessageBox, NULL, &quot;Message&quot;, &quot;Caption&quot;, MB_OK</code></pre><br /><br /><br />I wrote _call macro ~1,5 years ago and used it some time, but later i refused to use it.<br />You can replace push $T0(,&lt;arg&gt;,) with push $CTA0(&lt;arg&gt;), but I can't guarantee it will work properly.<br /><br />Now i use my text macros (from Strings.mac) like this:<br /><pre><code>invoke MessageBox, NULL, $CTA0&#40;&quot;Message&quot;&#41;, $CTA0&#40;&quot;Caption&quot;&#41;, MB_OK</code></pre><br /><br />Or simple $invoke macro:<br /><br /><pre><code>$invoke MACRO vars&#58;VARARG<br />     invoke vars<br />     EXITM &lt;eax&gt;<br />ENDM</code></pre><br /><pre><code>mov Result, $invoke&#40;MessageBox, NULL, $CTA0&#40;&quot;Message&quot;&#41;, $CTA0&#40;&quot;Caption&quot;&#41;, MB_OK&#41;</code></pre><br /><br /><br />I played some time with optimization. _ZERO_REG_ is an attempt to optimize code by size.<br />I used ZREG macro to define zero-register (containing null). And if _call macro meet immediate value 0, it replaces it with zero-register. For ex, push 0 will be push ebx. It's much smaller.<br /><br />I don't provide you with my zero macros because of they are in inconsistent state. I stop to develop it and I didn't finished them.<br /><br /><br />I've thrown away not needed lines from _call macro and now it looks like this:<br /><br /><pre><code>&#91;size=9&#93;<br />_call MACRO arglist&#58;VARARG<br /><br />local n, a, sz, q, arg, line, reax<br />    reax = 0<br /><br />    n TEXTEQU @ArgCount&#40; &lt;arglist&gt; &#41;<br />    % FOR arg, @ArgRev&#40; &lt;arglist&gt; &#41;<br />        n TEXTEQU %&#40;n - 1&#41;<br />        IF n EQ 0<br />            IF reax                            ;; if eax was used report error<br />                IFIDNI &lt;arg&gt;, &lt;eax&gt;<br />                    line TEXTEQU %@Line<br />                    % ECHO @FileCur&#40;line&#41; &#58; ERROR! Register value overwritten by _call macro.<br />                    .ERR<br />                ENDIF        <br />            ENDIF<br />            call arg<br />            IF &#40;OPATTR &#40; arg &#41;&#41; AND 10000000y<br />                ;; References an external label<br />                IF &#40;&#40;OPATTR &#40; arg &#41;&#41; AND 11100000000y&#41; EQ 00100000000y<br />                    ;; Uses C calling convention &#40;_cdecl&#41;<br />                    n TEXTEQU @ArgCount&#40; &lt;arglist&gt; &#41;<br />                    add esp, &#40;n - 1&#41; * sizeof DWORD<br />                ENDIF<br />            ENDIF<br />        ELSE<br />            IF $IsAddr&#40;arg&#41;<br />                a SUBSTR &lt;arg&gt;, 6<br />                IF $IsStack&#40;a&#41;                ;; Is relative to SS<br />                    lea eax, a<br />                    push eax<br />                    reax = 1                  ;; no more eax<br />                ELSE<br />                    push offset a<br />                ENDIF<br />            ELSEIF @InStr&#40;1, @SubStr&#40;&lt;arg&gt;, 1 , 1&#41;, &lt;!&quot;&gt;&#41;<br />                push $T0&#40;,&lt;arg&gt;,&#41;<br />            ELSEIF @InStr&#40;1, @SubStr&#40;&lt;arg&gt;, 1 , 1&#41;, &lt;&amp;&gt;&#41;<br />                a SUBSTR &lt;arg&gt;, 2<br />                IF $IsStack&#40;a&#41;                ;; Is relative to SS<br />                    lea eax, a<br />                    push eax<br />                    reax = 1                  ;; no more eax<br />                ELSE<br />                    push offset a<br />                ENDIF<br />            ELSE<br />                push arg<br />            ENDIF<br />        ENDIF<br />    ENDM<br />ENDM<br />&#91;/size&#93;</code></pre></div>
    <div class="meta">Posted on 2003-07-27 05:59:58 by Four-F</div>
   </div>
   <div class="post" id="post-112015">
    <div class="subject"><a href="#post-112015">Macro to replace the invoke statement</a></div>
    <div class="body">Opss.. Forgot to attach.</div>
    <div class="meta">Posted on 2003-07-27 06:03:35 by Four-F</div>
   </div>
  </div>
 </body>
</html>