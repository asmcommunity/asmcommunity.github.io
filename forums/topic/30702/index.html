<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>asmintro.chm, incorrectly dereference a variable in a register + read or write - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30702" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=30702">asmintro.chm, incorrectly dereference a variable in a register + read or write</a></p>
   <div class="post" id="post-215195">
    <div class="subject"><a href="#post-215195">asmintro.chm, incorrectly dereference a variable in a register + read or write</a></div>
    <div class="body">Could you explain this statement (in Protected Mode Memory section) from asmintro.chm of masm32 to me and give some code examples&nbsp; :D :&quot;You can also get into trouble if you incorrectly dereference a variable in a register and try and read or write to that address as it will be out of the address range that your program has access to.&quot; ?<br />I don&#039;t know what &quot;a variable in a register&quot; is either, could you explain this phrase to me?<br /><br />Here&#039;s an online copy for your quick view of this document:<br /><pre><code>Masm32:Flat memory Model<br />http://www.feiesoft.com/masm32/asmintro/flatmemorymodel.html</code></pre></div>
    <div class="meta">Posted on 2011-10-11 12:13:36 by bolzano_1989</div>
   </div>
   <div class="post" id="post-215199">
    <div class="subject"><a href="#post-215199">Re: asmintro.chm, incorrectly dereference a variable in a register + read or write</a></div>
    <div class="body">Programs in userland use Virtual memory addresses, not the real Absolute ones that protected mode uses, you will need to figure out how to convert between them.<br />To make this more clear, most applications appear to execute at the same memory address (40000h or whatever), and most DLLs similarly appear to be mapped to a base address of 100000h or something like that - obviously, this can&#039;t really be the case, as one application would overwrite another one - these addresses are not real, they are a fiction of the operating system. When a file is &#039;mapped&#039; into memory, it is allocated a virtual address space, relative to the process who opened it - and similarly, when a Process is created, it is allocated some virtual &#039;mapped&#039; memory by the system. This implies that the system&#039;s memory page manager contains a big fat list of these associations, a map of real to virtual address associations, heh.<br /><br />Oh - and a variable in a register? just means you used a register to read some variable (say a pointer) and then tried to access that pointed-at memory via the register you loaded.<br />eg <br />mov eax,0040000h<br />mov edx, &lt;- ouch in pmode<br /><br /></div>
    <div class="meta">Posted on 2011-10-12 04:21:01 by Homer</div>
   </div>
   <div class="post" id="post-215200">
    <div class="subject"><a href="#post-215200">Re: asmintro.chm, incorrectly dereference a variable in a register + read or write</a></div>
    <div class="body">Thank you Homer, now I know that  in mov edx, is called &quot;a variable in a register&quot; and such usage is called &quot;dereference a variable in a register&quot; :D.</div>
    <div class="meta">Posted on 2011-10-12 12:45:57 by bolzano_1989</div>
   </div>
   <div class="post" id="post-215201">
    <div class="subject"><a href="#post-215201">Re: asmintro.chm, incorrectly dereference a variable in a register + read or wri</a></div>
    <div class="body">Disclaimer: I don&#039;t &quot;do Windows&quot; and am a &quot;devout Nasmist&quot;, so I&#039;m not familiar with Masm32!<br /><br />Quoting Homer:<br /><div class="quote"><br />mov eax,0040000h<br />mov edx, &lt;- ouch in pmode<br /></div><br />Really? What&#039;s wrong with that? I would expect it to return &quot;MZ&quot; and a couple other bytes. No? In Linux, I&#039;d have to use a different address - 8048000h - but I&#039;d get back 7Fh, &#039;E&#039;, &#039;L&#039;, &#039;F&#039; in edx (little-endian, of course)...<br /><br />The page Balzano_1989 references says all segment registers are &quot;set to the same value&quot;. I don&#039;t think this is strictly speaking correct. Is cs = ds in Windows? It isn&#039;t in Linux - cs=23h, ds=2Bh (according to my debugger). It is true that the &quot;base&quot; of the segment descriptor pointed to by both selectors is zero, so it amounts to the same thing, but &quot;strictly speaking&quot;(!), they are not &quot;the same value&quot;. Also, I think fs is &quot;thread local storage&quot;, but that&#039;s a different issue...<br /><br />To illustrate what I understand by &quot;dereference a variable&quot;, I offer a stupid mistake I made trying to help &quot;anders11&quot; in a nearby topic. I had a &quot;count&quot; variable...<br /><pre><code><br />count: .long 0<br /></code></pre><br />in (G)as syntax. Nasm would be:<br /><pre><code><br />count dd 0<br /></code></pre><br />(I think Masm would be the same... or maybe &quot;dword&quot; rather than &quot;dd). I had filled this variable with, say, 5. Now I call a suboutine, something like:<br /><pre><code><br />pushl $count<br />call mything<br /></code></pre><br />In Nasm syntax:<br /><pre><code><br />push count<br />call mything<br /></code></pre><br />In Masm(?):<br /><pre><code><br />push offset count<br />call mything<br /></code></pre><br />In my subroutine, I did something like:<br /><pre><code><br />; prolog<br />movl 8(%ebp), %ecx<br /></code></pre><br />or Nasm:<br /><pre><code><br />; prolog<br />mov ecx, <br /></code></pre><br />Masm(?)<br /><pre><code><br />; prolog<br />mov ecx, 8<br /></code></pre><br />(I think the Nasm syntax would also work in Masm?)<br />Then I tried to use ecx as a loop counter. RONG! I had the address of &quot;count&quot; in ecx, not the &quot;&quot;. Loops a few too many times! What I had to do, was &quot;dereference the variable&quot;:<br />Gas:<br /><pre><code><br />movl (%ecx), %ecx<br /></code></pre><br />Nasm/Masm:<br /><pre><code><br />mov ecx, <br /></code></pre><br />(yes, it&#039;s okay to use the same register)<br /><br />Of course, it would have been smarter to pass the contents, rather than the address in the first place!<br />Gas:<br /><pre><code><br />pushl count<br /></code></pre><br />Nasm:<br /><pre><code><br />push dword <br /></code></pre><br />Masm<br /><pre><code><br />push dword ptr count<br /></code></pre><br />?<br /><br />This is, as I understand it, the difference between &quot;passing by reference&quot; and &quot;passing by value&quot;. I&#039;m not certain I&#039;ve got the terminology right, but I&#039;m pretty sure I&#039;ve got the concept right. The distinction between &quot;address&quot; (offset) and &quot;contents&quot; of that address is an important one for beginners to &quot;get&quot; (and anyone to remember :) ). Unfortunately, this is an area where different assemblers differ greatly in syntax!<br /><br />Please correct my Masm syntax, and the &quot;concept&quot;, too, if you think I&#039;ve got it wrong!<br /><br />Best,<br />Frank<br /><br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2011-10-12 19:25:57 by fbkotler</div>
   </div>
   <div class="post" id="post-215202">
    <div class="subject"><a href="#post-215202">Re: asmintro.chm, incorrectly dereference a variable in a register + read or write</a></div>
    <div class="body">Just need to see &#039;physical to virtual addressing&#039; to see what I meant ... protected mode uses segment selectors to map &#039;linear addresses&#039; to &#039;physical addresses&#039; - but this is only the beginning of the story, its just how kernel drivers view the world (under windows os), since userland applications live behind a mystical curtain called ring 3, and use another layer of memory address virtualization where physical addresses are mapped to virtual (process space) addresses. The examples I gave were virtual addresses, so it&#039;s anyone&#039;s guess what you would find at physical address 00400000h, let alone at the same address in linear memory! </div>
    <div class="meta">Posted on 2011-10-13 02:43:56 by Homer</div>
   </div>
   <div class="post" id="post-215203">
    <div class="subject"><a href="#post-215203">Re: asmintro.chm, incorrectly dereference a variable in a register + read or wri</a></div>
    <div class="body">Ah, you meant 40000h physical. No, we couldn&#039;t see that from &quot;userland&quot;. I&#039;m used to (resigned to) thinking of virtual addresses as &quot;all there is&quot;. Who knows what physical address that might be? Different for each process, as you point out. Might even be swapped out to disk, and not be in RAM at all! Fortunately(?), the OS takes care of it for us, and we don&#039;t need to know/care... unless we&#039;re writing an OS, in which case we would need to know all the ugly(?) details.<br /><br />To further complicate the issue, some memory is &quot;readonly&quot;. In Linux:<br /><pre><code><br />mov eax, 8048000h<br />mov edx, &nbsp; ; gets 7F &#039;E&#039; &#039;L&#039; &#039;F&#039;<br />mov , edx&nbsp; ; BZZZZT! - readonly!<br /></code></pre><br /><br />8048000h is the &quot;beginning of the world&quot; - an attempt to read/write at a lower address than that would fail. Our &quot;data segment&quot; starts at 8049xxxh (or higher, depending on the size of the code segment) - there we can write. Above that, there&#039;s the &quot;break&quot; - we can&#039;t read/write above that... although we can alter it to allocate more memory. The stack is higher than that - 0C0000000h, and working down. The numbers would be different in Windows, but I think the idea&#039;s the same. If we use &quot;named variables&quot;, we don&#039;t need to know what the numbers are, so it probably isn&#039;t useful to discuss. Sorry.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2011-10-13 11:10:10 by fbkotler</div>
   </div>
  </div>
 </body>
</html>