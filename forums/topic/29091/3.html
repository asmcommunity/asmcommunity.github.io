<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>ObjAsm32 - new stuff - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29091" />
  <link rel="prev" href="../?id=29091&amp;page=2" />  <link rel="next" href="../?id=29091&amp;page=4" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29091">ObjAsm32 - new stuff</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29091&amp;page=1" style="">&laquo;</a><a href="../?id=29091&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="29091" /><input type="number" name="page" min="1" max="5" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=29091&amp;page=4">&gt;</a><a href="../?id=29091&amp;page=5">&raquo;</a></form>   <div class="post" id="post-205699">
    <div class="subject"><a href="#post-205699">SkinMeshes : Smooth, Rigid, and Microsoft's typically unhelpful approach.</a></div>
    <div class="body">More experimenting revealed that Microsoft&#039;s skinmesh api is less than satisfactory - it does not support rigid binding - you can load a rigid-bound , animated skinmesh, sure... but all kinds of api will fail if you hand them this frametree, such as D3DXFrameCalculateBoundingSphere - even if the skinmesh is still in the Bind pose. <br />I would have thought that rigid skinmeshes would have been supported since they are much simpler, could have been implemented using the same framework, and would act as a good introduction to the more complex smooth-bound skinmesh - or simply to illustrate how matrix transformations work in the context of a frame hierarchy.<br />Its so bad that if you actually want rigidly-bound skinmeshes (say, for a tank simulation), you&#039;re better off implementing your own skinmesh class (AGAIN, from scratch) specifically for this purpose.<br />Adding support for this to OA32&#039;s D3D_SkinMesh class is quite possible, however I reiterate my utter disappointment in Microsoft for throwing new users to the wolves in this way.<br />Don&#039;t they like people to use their stuff?<br /></div>
    <div class="meta">Posted on 2008-07-27 08:08:39 by Homer</div>
   </div>
   <div class="post" id="post-205702">
    <div class="subject"><a href="#post-205702">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">So what are the stumbling blocks in implementing rigid animated &#039;skinmesh&#039; ?<br />Well, for a start, we don&#039;t get any skinning information for our MeshContainer(s).. and I&#039;ve mentioned that we must be careful not to use certain api such as D3DXFrameCalculateBoundingSphere - we&#039;ll have to use per-mesh Bounds and maybe implement our own animated boundingsphere unioning method (made me think of onion rings for some reason).<br /><br />So what are we missing out on?<br />Skinning information has two things in it:<br />-list of Bones which affect the (contained) Mesh.<br />-UpdateSkinnedMesh method which transforms the BindPose vertices according to the PROVIDED transform matrices.<br /><br />Indirectly, this means that the AnimationController does NOT affect vertices - its only animating the BONES... and for a Rigid animation, that ALL WE WANT.<br />And the list of Bones affecting each (contained) Mesh? We don&#039;t need it - in a rigid binding, each mesh that is being animated is associated with exactly one Bone.<br /><br />So - what DO we need to do?<br />Thankfully, not much... its not a matter of what we must do, its a matter of what we must NOT do :)<br />The AnimationController is directly messing with the array of bone matrices, and so after our typical &#039;concatenation&#039; recursion, we already have our set of Bone-To-World matrices, all nicely animated, and ready to use.<br />All we need to do is update the animationcontroller, update the frame matrices (matCombined), and then Render the MeshContainers.<br /><br />Well, I&#039;m pretty sure that&#039;s right.<br />Interestingly it seems that either noone else has tackled this problem, or its so plainly obvious that it defies description (literally) as I could not find a single reference to rigidly-bound animated mesh hierarchies using .x files :)<br /></div>
    <div class="meta">Posted on 2008-07-28 06:32:53 by Homer</div>
   </div>
   <div class="post" id="post-205703">
    <div class="subject"><a href="#post-205703">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">More weirdness?<br /><br />Smooth Binding : During the loading of a MeshContainer, we Clone its Mesh object.<br />Then at runtime, we use the original Mesh as a vertex Source, and the Cloned one as a Target, and via our Skinning Information object, produce our warped and bent mesh for Drawing.. so we draw the Cloned one.<br /><br />Rigid Binding : We never got any Skinning info .. we never Cloned the original Mesh. At runtime, if we try to Draw the original Mesh, we&#039;ll crash - the DrawSubSet function pointer is illegal... its the same legal object we would have otherwised used as a Vertex and Cloning source!! <br /><br />Whats going on here then? <br /><br />Did Microsoft write a COM object that doesn&#039;t comply with the COM standard? <br /><br />Have you seen another example of Microsoft (or another company) breaching a standard which they inflicted apon the rest of us?<br /><br />After all, I am not doing anything I shouldn&#039;t be doing, yet the so-called standard-compliant object is not behaving as expected.<br /></div>
    <div class="meta">Posted on 2008-07-28 07:25:40 by Homer</div>
   </div>
   <div class="post" id="post-205704">
    <div class="subject"><a href="#post-205704">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">Yes, Steinberg&#039;s ASIO&nbsp; COM object breaches all COM standards. Using that object in the standard COM way would lead to blue-screen of death (on Win2k/XP !!). The example code to use the object is in C++, so C++ absolutely allows you to breach all COM standards. <br />Solved that problem by disassembling working C++ samples and locating the oddities in calling conventions. 3 or 4 different calling conventions were being used in the same object. </div>
    <div class="meta">Posted on 2008-07-28 07:33:19 by Ultrano</div>
   </div>
   <div class="post" id="post-205706">
    <div class="subject"><a href="#post-205706">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">I have more bad news.<br /><br />Much earlier in the frameword, in the ID3DXAllocateHierarchy.CreateMeshContainer method to be precise, I am Cloning my original Mesh from the transient XFileLoader data... this call is ALSO failing, its says D3DERR_INVALIDCALL but that is simply rubbish because theres nothing wrong with the call itself, its merely that we&#039;re now attemping to load a Rigid-bound mesh instead of a Smooth-bound one.<br /><br />So - the problems begin way back in the XFile Loader api function that I am using (and probably in its variants).<br />I&#039;m able to load all the animation data, all the frame hierarchy, everything EXCEPT that I am being fed illegal Mesh objects right from the very start... I&#039;m being handed object pointers for these Meshes, but they&#039;re simply not valid... they do NOT point to instances of the expected interface.<br /><br />I think I can get around this too, if I cheat a little..<br />What I&#039;ll do is export all the pieces of Mesh as static meshes.<br />Then when they fail to load, I&#039;ll try to load them AS static meshes, and INSERT them into my meshcontainers by hand... Now if THAT doesn&#039;t work, I&#039;ll get cranky :)<br /><br />This isnt as bad as it sounds, because the goal was to create Breakable skinmeshes, and for that, we really need separate static meshes for the &#039;broken&#039; pieces.<br />It just means we have a situation of &#039;all Rigidly bound mesh hierarchies are potentially Breakable&#039; which sounds kinda fun and useful for games.<br /><br />And I don&#039;t see why I can&#039;t still also apply the Breakability stuff to Smooth bound meshes as originally intended... they just don&#039;t have the Loading problems I&#039;m seeing.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-07-28 08:14:40 by Homer</div>
   </div>
   <div class="post" id="post-205707">
    <div class="subject"><a href="#post-205707">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">Ah, finally getting somewhere.. the problem was that the problem Meshes don&#039;t export an FVF - we have to use the slightly more complex &#039;Decl&#039; (vertex declaration) way of describing our vertex format... and there&#039;s a Decl-based version of CloneMesh.<br /><br />Having added code to ID3DXAllocateHierarchy.CreateMeshContainer to detect the NULL FVF and switch to using Decl-based cloning of the transient mesh interface, and checking the return value, I see success - this worked.<br />Now the D3D_SkinMesh class should be seeing valid Meshes, but its not aware of the fact that we might be using the Decl method, so we completely and (assumed) successfully load the skinmesh, then we return to D3D_SkinMesh , only to crash and burn, which is just fine by me.<br /><br />So all of these problems I&#039;ve been having with Rigid-bound skinmeshes are based on the fact that the modeller used the newer Decl way of describing FVF :|<br />This is stuff I covered already in D3D_Mesh&nbsp; :cry:<br />But it gave me somewhere to go for working code to implant and fix the problem :P<br /><br />Happy Day, although still in a state of flux, the D3D_SkinMesh class just received a poignant makeover, which should be a big help with models that were actually created during this decade :P<br /><br /> </div>
    <div class="meta">Posted on 2008-07-28 09:11:39 by Homer</div>
   </div>
   <div class="post" id="post-205708">
    <div class="subject"><a href="#post-205708">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">After I got the troublesome rigidbound skinmesh model to load successfully, I found it wouldn&#039;t render anything onscreen, so I went right to the source and asked the horse.<br />The material didn&#039;t have any Ambience - fixed.<br />To prove that it was renderable, I exported the static mesh, and tried to load and render it as a static mesh... again it would not render... worse, D3D_Mesh was crashing!<br />So I made some small improvements to D3D_Mesh.<br />It can now draw Materials that don&#039;t have any Texture.<br />At last I can see the model, at least in static form.<br />Since it just has color and no texture, and since theres no Lighting in my environment, it looks quite plain and the details are hard to make out ... I should probably think about adding a default light that is glued to the Camera, and maybe later some cool and simple shaders like Phong which make textureless meshes much more visually appealing and can give a false impression of smoothness especially when the polygon count is actually low.<br /><br />Now back to the D3D_SkinMesh class :)<br /></div>
    <div class="meta">Posted on 2008-07-28 23:34:59 by Homer</div>
   </div>
   <div class="post" id="post-205710">
    <div class="subject"><a href="#post-205710">Re: Not all Models are created equal...</a></div>
    <div class="body">I found a further problem with importing of this problematic skinmesh.<br />Not all of its component meshes have a Material!!!<br /><br />ID3DXAllocateHierarchy.CreateMeshContainer wasn&#039;t expecting THAT!<br />I&#039;ve added code to issue a Warning when the mesh has no Material.<br />But really I should be assigning a Default Material in this situation.<br /><br />The more I work on this, the more weird and wonderful models I can load and render.<br />And in the real world, it is more often the case than not, that a given Model has been created without thought to the minimal requirements of a rendering engine.<br />So its up to us, we cannot assume anything about a model, we should check it conforms to our requirements, and if it doesnt, we should manipulate it at loadtime so that it does.<br /><br />Bit quiet around here lately :P<br /></div>
    <div class="meta">Posted on 2008-07-30 00:11:21 by Homer</div>
   </div>
   <div class="post" id="post-205711">
    <div class="subject"><a href="#post-205711">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">I found an interesting bug in Microsoft&#039;s D3DXLoadHierarchyFromX api function.<br />OK, its not so much of a bug as a &#039;feature&#039; ...<br /><br />If you have a MeshContainer associated with the Root Frame, it wont be released... you&#039;ll crash and burn.<br /><br />Say we had 20 meshes in our model, and we named them nicely mesh_1 thru mesh_20.<br />We see them being loaded in numerical order.<br />But when we destroy our frametree, the first meshcontainer to be destroyed will be 2 (it should be 1) ... then theyll get destroyed in order, then in the 20th call to DestroyMeshContainer we shall be handed bad parameters.<br /><br />Then baby go boom fall down.<br /><br /><br /></div>
    <div class="meta">Posted on 2008-07-30 22:14:39 by Homer</div>
   </div>
   <div class="post" id="post-205712">
    <div class="subject"><a href="#post-205712">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">I&#039;ve just removed all mention of FVF from the D3D_Mesh class.<br />Now it only uses the newer &#039;Decl&#039; method of describing a flexible vertex format.<br />It uses more memory, and its potentially a lot slower than the old system.<br />So why did I do it? Why not use the old FVF when it is available?<br />Because we need to use the Decl method when working with SHADERS.<br /><br />I&#039;m expecting to be writing some simple pixelshaders in the next few days, and I&#039;ll want to apply them to my meshes.<br /></div>
    <div class="meta">Posted on 2008-07-31 02:43:19 by Homer</div>
   </div>
   <div class="post" id="post-205713">
    <div class="subject"><a href="#post-205713">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">A new object called D3D_Shader has been written to implement both Vertex and Pixel shaders.<br />Demo was created to test the new object, and to test recent changes to D3D_Mesh in regards to supporting shaders. <br />Everything works :)<br /><br />I&#039;m pretty sure this file will make the next version release of OA32.<br /><br />Ah - maybe I spoke too soon.<br /><br />In regards to setting the values of input Constants, in this case VertexShader:<br />The ID3DXConstantTable.SetMatrix method is leaving the stack unbalanced (by one dword), yet the interface definition looks to be correct.<br />I think I&#039;ll confer with Biterider in regards to this anomoly, maybe I&#039;m just not seeing the error in the def.<br /><br />Nevermind, I found it - there&#039;s been one new Method added to that interface.<br />I&#039;ve corrected the D3DXShader.inc <br /><br />Now everything works 100% - the brave new world of shaders and gpu programming is at the fingertips of the OA32 user.<br /><br /></div>
    <div class="meta">Posted on 2008-07-31 22:20:33 by Homer</div>
   </div>
   <div class="post" id="post-205714">
    <div class="subject"><a href="#post-205714">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">I need a surface for my characters to walk on, and for playing with physics some more.<br />I have not found anything more cool or useful than the Terrain class I wrote two years ago.<br />It does the vertex manipulation (heightmapping) on the cpu so the physics code has access to the terrain geometry, and it can do the texture blending on the gpu via a pixelshader.<br />Its based on a quadtree which encodes LOD detail, terminating early in &#039;flat&#039; regions, and switches the LOD based on an error metric that takes view distance into account.<br />The only thing it doesn&#039;t currently do is geomorphing, and it would be nice if I could blend more than 4 textures.<br /><br />So my next job will be to revise my Terrain code, implant it in my GameClient framework, and write enough networking support to allow clients to connect to a server, cruise around in 3D and paint the terrain blendmap and heightmap, see each other and show the changes being made by all clients.<br /><br />That will effectively be my first development tool, and a genuine milestone in more ways than one, as I am not aware of any other 3D game editor that allows multiple clients to edit the same virtual space in this fashion, it is therefore a bleeding edge tool, and no doubt someone out there who works in the industry will steal this idea and claim it as their own.<br />So be it, just mention me somewhere as a courtesy and I&#039;ll be content.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-08-02 02:03:45 by Homer</div>
   </div>
   <div class="post" id="post-205715">
    <div class="subject"><a href="#post-205715">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">Do you guys remember my &#039;splat&#039; realtime 3D terrain painting demo?<br />I&#039;ve just reworked the code to reflect changes in OA32&#039;s D3D framework (I could probably keep going too), and I&#039;ve implanted the new objects in my GameClient demo project.<br />The idea is, as mentioned previously, to implement&nbsp; a networked terrain editor tool, and the beginnings of a game network protocol.<br />I&#039;ve deprecated the &#039;FF&#039; render code in favor of pixelshader code, implemented as an embedded D3D_Shader object.<br />I&#039;m also keen to expand the number of &#039;blender source&#039; textures from 4 to 8.<br /><br />The lack of recent posts is appalling.<br />What are you people up to?<br />I see that my pinned Physics post gets daily views now.<br />And nobody has a word to say :D<br /><br />Biterider - I added a method to D3D_Camera called &#039;DistanceToPoint&#039;.<br />Its function is obvious, and its location was considered.<br />Consider it a poor mans version of frustum culling, when we just wanna know how far the Camera is away from some point.<br />I guess it really should be &#039;IsPointVisible&quot; :)<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-08-03 05:19:08 by Homer</div>
   </div>
   <div class="post" id="post-205718">
    <div class="subject"><a href="#post-205718">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">Spent today rewriting my old Terrain class in order to implement a better Tesselator.<br />My old terrain was based on a TriangleFan which was recursively cut into four (ie, a quadtree).<br />The new one is based on two &#039;binary Triangle Trees&#039; forming a Quad at the root level, and is using an algorithm similar to ROAM in order to recursively refine those two root triangles.<br />This gives us a slightly improved tesselation, and slightly fewer triangles need to be drawn.<br />Slightly faster rendering, and slightly better geometry, it seemed worthy.<br /><br />Biterider is having problems building the D3D_Shader demo, so I&#039;ll probably spend the rest of today&#039;s free time just nailing that issue... it&#039;s perhaps the second time we&#039;ve had to do this, I&#039;m just concerned what we&#039;ll find because he&#039;s having problems with NEWER libs, and I&#039;m NOT having problems with older ones.... so theres likely more changes in the Headers to account for.<br /><br /></div>
    <div class="meta">Posted on 2008-08-04 06:58:55 by Homer</div>
   </div>
   <div class="post" id="post-205719">
    <div class="subject"><a href="#post-205719">Re: Microsoft Microsoft Microsoft</a></div>
    <div class="body">We were able to quickly narrow the problem down to the D3DX9.lib file , which is version-dependant and links to files with names such as D3DX9_30.dll (2004) and D3DX9_35.dll (August 2007) and D3DX9_36.dll (November 2007).<br /><br />We find that the very old 2004 file works just fine.<br />But when we call certain functions using the newer lib, linking to the newer dlls, they fail.<br />We get NOT IMPLEMENTED errors.<br />BOOOO, Microsoft.<br />Shame on you, both debug and retail builds are missing functionality where they should fall back on the older versions.<br />I&#039;m currently installing the June 2008 SDK, to see if they ever got around to fixing it.<br /><br /></div>
    <div class="meta">Posted on 2008-08-04 07:41:44 by Homer</div>
   </div>
   <div class="post" id="post-205720">
    <div class="subject"><a href="#post-205720">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">While I was waiting on the 2008 SDK to download, I decided to doublecheck the August 2007 version of D3DXShader9 against our OA32 header file.<br />There was heaps of stuff missing, among them was a particular flag:D3DXSHADER_ENABLE_BACKWARDS_COMPATIBILITY<br /><br />This flag, when selected, forces ps_1_x HLSL files to get compiled as ps_2_0 :D<br /><br />For those who are as impatient as I am, I have attached a couple of files.<br /><br />With these changes, I can build against the d3dx9_35.dll :)<br /><br />Tomorrow, I promise to update this file again, against the JUNE 2008 header.<br />After tomorrow, we should all switch to the June 2008 Libs and DLLs.<br />I believe that is version 38.<br /><br />Have a nice day :)</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2615" target="_blank">D3D_Shader.inc</a></li>
      <li><a href="../../attachments/?id=2617" target="_blank">D3DX9Shader.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2008-08-04 09:47:17 by Homer</div>
   </div>
   <div class="post" id="post-205728">
    <div class="subject"><a href="#post-205728">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">Yesterday I got my Terrain code to draw something again (using a pixelshader to perform pixel-perfect alpha-splatting of textures).<br />But I still wasn&#039;t happy with the tesselator. Apparently neither is the spellchecker.<br />So I trashed my integer based code in favor of a float-driven scheme.<br />Now I&#039;m using bilinear multisampling of the heightmap pixels, and generating vertices as I go rather than generating them as a flat array in advance of tesselation.... man, we&#039;re likely to generate less vertices than we have pixels, thats the whole point of the exercise - less triangles where they are not needed.<br />Tomorrow should bring me back on track, but the bottom line is that I spent my few small hours of coding time today reinventing code I wrote a long time ago.<br />Back then, each project was unique, its components were not easily transplanted.<br />I&#039;ve grown up a lot in terms of design.<br />Instead of building slip-stone walls, I&#039;ve learned to build them from regular bricks.<br /><br />Biterider is going to release a new version of OA32 very soon, which will contain some of the objects I&#039;ve been talking about... I hope he includes the new SkinmeshInstance object (which supports attachment of static mesh instances to the animated skinmesh instance), because it&#039;s gamedev gold, and it wouldn&#039;t take a lot of work to make an impressive demo or small game just based on that class.<br /></div>
    <div class="meta">Posted on 2008-08-06 10:23:08 by Homer</div>
   </div>
   <div class="post" id="post-205732">
    <div class="subject"><a href="#post-205732">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">The terrain engine is working, but with no Batching of primitives and with no visibility culling and no view dependent LOD culling, the framerate is terrible.<br />I&#039;m just going through the same stuff that I did two years ago :|<br /><br />I guess the next step will be to introduce simple camera based culling, then reimplement the &#039;variance&#039; stuff for LOD culling.<br />Sigh.<br /><br />On the bright side, I&#039;ve improved D3D_VertexBuffer.Resize and will make similar changes to D3D_IndexBuffer.<br /></div>
    <div class="meta">Posted on 2008-08-08 00:51:09 by Homer</div>
   </div>
   <div class="post" id="post-205739">
    <div class="subject"><a href="#post-205739">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">Having implemented batching of primitives with 32bit indexing (I really dont need 32, 16 would have been adequate) , I scored an immediate speed increase of something over 200 times.. yes, 20,000 percent faster, thats the stuff.<br />And I still haven&#039;t implemented the heuristic for view based dynamic LOD (or any other kind of culling) :)<br /><br />Think I&#039;ll give myself :thumbsup: two thumbs up :thumbsup:<br /><br /><br /></div>
    <div class="meta">Posted on 2008-08-10 20:12:52 by Homer</div>
   </div>
   <div class="post" id="post-205744">
    <div class="subject"><a href="#post-205744">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">Today I&#039;ll briefly describe the algorithm used to tesselate the terrain, and perhaps in a few days I&#039;ll talk about the visibility based realtime dynamic Level Of Density rendering scheme.<br /><br />Before reading on, please forget what you know (or think you know) about heightmaps.<br />This system isn&#039;t strictly based on a uniform grid, and can be easily adapted to work on massive heightmaps of any dimension.<br /><br />Take a pen and some paper, and draw the four points of a square.<br />Now draw one triangle between three of them. Later we can make another triangle here, forming a Quad, but let&#039;s just concentrate on one triangle for now.<br /><br />See that the triangle is a right angled triangle, look at the edge which forms the Hypotenuse of the triangle.<br />Mark a new point half way along the Hypotenuse edge.<br />Now draw a line from the new &#039;hypotenuse midpoint&#039; to the point that opposes the hypotenuse (its the only one that isnt on an existing edge) such that we have split our original triangle into two triangles.<br /><br />See that each child triangle is ALSO a right angled triangle, with a Hypotenuse.<br />Repeat the process until you get bored - you could keep going forever, in theory.<br /><br />I keep going until I reach the &#039;sub-pixel&#039; level of my heightmap resolution...<br />I am tesselating the terrain by sampling the four corners of the heightmap, using floating-point coordinates instead of integers. I then perform the above steps in order to create a binary tree of ever-diminishing triangles, and then do it all again to create two triangle-trees whose root triangles form a Quad.<br /><br />I am using the Pixelmap.GetVirtualPixel function to perform bilinear-filtered pixel lookups with floating-point pixel coordinates, this is slower than integer but allows us to sample &#039;between pixels&#039; and so allow the engine to create a more finely grained tesselation than would otherwise be possible - and also allows us to use heightmaps of arbitrary dimension.<br /><br />Since the building of this tree is a preprocess, the extra time it takes is not important (or noticeable, really).<br /><br />If you can&#039;t understand a word I just said, you&#039;re probably in the wrong place :P<br /><br /></div>
    <div class="meta">Posted on 2008-08-11 06:38:48 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29091&amp;page=1" style="">&laquo;</a><a href="../?id=29091&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="29091" /><input type="number" name="page" min="1" max="5" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=29091&amp;page=4">&gt;</a><a href="../?id=29091&amp;page=5">&raquo;</a></form>  </div>
 </body>
</html>