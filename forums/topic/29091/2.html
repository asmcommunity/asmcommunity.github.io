<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>ObjAsm32 - new stuff - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29091" />
  <link rel="prev" href="../?id=29091&amp;page=1" />  <link rel="next" href="../?id=29091&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29091">ObjAsm32 - new stuff</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29091&amp;page=1" style="">&laquo;</a><a href="../?id=29091&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29091" /><input type="number" name="page" min="1" max="5" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=29091&amp;page=3">&gt;</a><a href="../?id=29091&amp;page=5">&raquo;</a></form>   <div class="post" id="post-205619">
    <div class="subject"><a href="#post-205619">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">OK, this gets a little bit more complex because of the nature of the beast.<br /><br />Microsoft&#039;s sourcecode always assumes that there is just one MESH in the frametree of a SkinMesh... there is at least one MESHCONTAINER attached to one of the frames in the frametree - M$ assumes there is ONLY one... that is not certain, you can have more strewn throughout the frametree.<br />In fact, microsoft&#039;s code will load and animate N meshcontainers, but only draws one.<br /><br />A meshcontainer holds, among other junk, a chunk of Mesh and a list of which Bones it affects.<br />The bones are presumed to belong to that MeshContainer and to be found in the frametree at some point BELOW the node that holds the meshcontainer.<br /><br />So when we wanna attach something to a Bone, we should be dealing with that Bone&#039;s owner - which is a MeshContainer at a higher node... and so the MeshContainer is the logical place to be recording which Bones have attachments.<br />But we can&#039;t go screwing with the content of MeshContainers for the same reason that we can&#039;t screw with the Frames - these are REFERENCE RESOURCES, shared by ALL instances.<br /><br />So it would be nice if Instances had some kind of per-MeshContainer list of attachments that are loosely associated with the Reference resources.<br /><br />In fact, I see no reason that the MeshContainers need to remain inside the FrameTree at all.<br />They could be stored as any kind of list, array, linkedlist, whatever... but that list needs to be constructed AFTER loading, perhaps within &#039;SetupBoneMatrices&#039;.<br /><br />What we really need to know for each Instance is:<br />-how many MeshContainers<br />-how many, and which, Bones are referenced by EACH MeshContainer<br />I&#039;m thinking about using some kind of bitkey to represent some of this.<br /><br />And it would be nice to link the MeshContainers into a linear list, to speed up the rendering - we wouldn&#039;t need to search for them anymore (ok we have a quick pointer to the first one, but what about the rest?)<br /><br /><br /></div>
    <div class="meta">Posted on 2008-07-12 21:58:01 by Homer</div>
   </div>
   <div class="post" id="post-205625">
    <div class="subject"><a href="#post-205625">Re: ObjAsm32 - new stuff</a></div>
    <div class="body"><br />I&#039;ve finally figured out how I want to go about attaching armour and weapons etc.<br /><br />The first thing I did was describe a new class called D3D_SkinMeshInstance, whose immediate ancestor is D3D_SkinMesh. The new class overrides the Init and Done methods... the new Init method requires a pointer to an existing (reference) D3D_SkinMesh object, from which it clones a new instance, stealing a copy of essential data and cloning required interfaces.<br /><br />The next thing I did was extend the FRAME structure, adding a WORD to describe the index of a Bone (if the frame is not a boneframe, its set to -1)<br /><br />The next thing I did was make some key changes to the ancestor D3D_SkinMesh class, I added a Dynamic method that gets called just after a boneframe&#039;s matrix has been updated, just before we return from recursion, at the end of the UpdateFrameMatrices method.<br />Then I added a dummy callback method that I expect to override in the D3D_SkinMeshInstance class (and any subsequent derived classes).<br /><br />Now we have our callback method being called on a per-instance basis (through the magic of dynamic overrides), we can determine what response is appropriate as each Bone is updated, and BEFORE the skinmesh itself has been rendered.<br /><br />If we want the model&#039;s hand to obscure the handle of the Sword he or she is holding, then we need to draw the sword just before we draw the skinmesh.The callback scheme makes that incredibly easy, the alternatives would have cost a lot in terms of memory and/or cpu cycles and would have defeated the purpose of trying to share the reference frametree across all instances... we&#039;d have lost all our savings and possibly more.<br /><br />Any items that need to be drawn &#039;on top of&#039; the model can be drawn after our call to Render the skinmesh itself.<br /><br />What are your thoughts?<br /><br /></div>
    <div class="meta">Posted on 2008-07-14 00:27:01 by Homer</div>
   </div>
   <div class="post" id="post-205627">
    <div class="subject"><a href="#post-205627">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">The D3D_SkinMeshInstance object now has its &#039;onBoneUpdated&#039; callback method implemented... I&#039;ve added a BITKEY to the class object, where each Bit represents a Bone.<br />If a bit is Set, then this Bone has something attached to it.<br />I&#039;ve also added an array of &#039;Pointers to attached objects&#039; which corresponds to the set of Bones, and to the Bits in the BitKey... <br /><br />When a Bone is updated, the callback grabs the Bone&#039;s index from the Frame and checks whether the corresponding Bit in the BitKey is Set or Clear.<br />If its Set, the callback grabs the Pointer from the attachments array at the same Index, and then assumes the attached object is a D3D_MeshManaged object, and proceeds to overwrite its Transform matrix with that of the Bone (ie, from the updated Frame matrix).<br /><br />Rendering of the attached object is currently left to the MeshManager.<br /><br /><pre><code><br />D3D_SkinMeshInstanceID equ 234234<br />Object D3D_SkinMeshInstance,D3D_SkinMeshInstanceID,D3D_SkinMesh<br />	RedefineMethod	Init,					Pointer<br />	RedefineMethod	Done<br />	RedefineMethod	onBoneUpdated,			Pointer				;ptr to FRAME which represents a Named Bone<br />	StaticMethod	Attach_To_Bone,			Pointer,dword		;ptr to D3D_MESHMANAGED , index of Bone we wanna attach mesh to<br />	StaticMethod	Detach_From_Bone,		dword				;index of Bone we wanna detach mesh from<br />	DefineVariable	pBitKey_Attachments,	Pointer,NULL		;binary key denoting which Bones have attachments<br />	DefineVariable	pAttachedObjects,		Pointer,NULL		;array of ptrs to attached objects<br />ObjectEnd<br /><br />Method D3D_SkinMeshInstance.Done,uses esi<br />	SetObject esi<br />	MemFree&nbsp; .pBitKey_Attachments<br />	MemFree&nbsp; .pAttachedObjects<br />MethodEnd<br /><br />; ——————————————————————————————————————————————————————————————————————————————————————————————————<br />; Method:&nbsp; &nbsp; D3D_SkinMeshInstance.Init<br />; Purpose:&nbsp; &nbsp;Create a CLONE of the given (REFERENCE) SkinMesh with the bInstanced flag set to TRUE (see D3D_SkinMesh.Done)<br />; Arguments: None.<br />; Return:&nbsp; &nbsp; None.<br />; Notes:	 Be sure the input param is a REFERENCE SKINMESH, ie, do NOT clone from D3D_SkinMeshInstance<br />Method D3D_SkinMeshInstance.Init,uses esi edi,pRefSkinMesh<br />LOCAL dEvents:dword, dOutputs:dword<br />	SetObject esi	<br />	mov edi,pRefSkinMesh<br />	mov dEvents, $ICall(.D3D_SkinMesh.pAnimController::ID3DXAnimationController.GetMaxNumEvents)<br />	mov dOutputs, $ICall(.D3D_SkinMesh.pAnimController::ID3DXAnimationController.GetMaxNumAnimationOutputs)<br />	<br />	;Clone all the local data from the RefSkinMesh into this new SkinMeshInstance<br />	;making sure we don&#039;t overwrite the (first) 20 bytes of data that are internally used by OA32<br />	;Here you can see I am referencing &#039;the first data variable&#039; in each Class<br />	invoke RtlMoveMemory,addr .pDirect3D,addr .D3D_SkinMesh.pDirect3D,sizeof D3D_SkinMesh-20<br /><br />	mov eax,.dMaxBones<br />	shr eax,3		;divide by 8 ... we need one BIT per Bone<br />	mov .pBitKey_Attachments,$MemAlloc(eax,MEM_INIT_ZERO)<br />	<br />	mov eax,.dMaxBones<br />	shl eax,2		;multiply by 4 ... we need one DWORD per Bone<br />	mov .pAttachedObjects,$MemAlloc(eax,MEM_INIT_ZERO)<br /><br />	;We CANNOT prevent a call to the ancestor&#039;s DONE method - even if we override Done in this class :|<br />	;So we&#039;ll use a BOOLEAN to alert the ancestor&#039;s Done method NOT to release Shared resources	<br />	mov .bIsReferencedResource, FALSE	;&lt;-- I am an INSTANCE, not a REF OBJECT<br />	<br />	;Now we need to clone the refmesh&#039;s AnimationController...<br />	;Overwrite the COPY of the refskinmesh&#039;s animcontroller with a freshly-cloned interface<br />	ICall .pAnimController::ID3DXAnimationController.CloneAnimationController,dOutputs,\<br />		 .dAnimationSetCount, .dAnimationSetCount, dEvents, addr .pAnimController<br />MethodEnd<br /><br />Method D3D_SkinMeshInstance.Attach_To_Bone,uses esi,pMeshInstance,dBoneIndex<br />	SetObject esi<br />	mov edx,.pBitKey_Attachments<br />	mov eax,dBoneIndex<br />	bt word ptr, ax<br />	jc @F<br />	bts word ptr, ax<br />	shl eax,2<br />	mov edx,.pAttachedObjects<br />	push pMeshInstance<br />	pop dword ptr<br />	mov eax,TRUE<br />	ExitMethod<br />@@:	mov eax,FALSE<br />MethodEnd<br /><br />Method D3D_SkinMeshInstance.Detach_From_Bone,uses esi,dBoneIndex<br />	SetObject esi<br />	mov edx,.pBitKey_Attachments<br />	mov eax,dBoneIndex<br />	bt word ptr, ax<br />	jnc @F<br />	btc word ptr, ax<br />	shl eax,2<br />	mov edx,.pAttachedObjects<br />	mov dword ptr,0<br />	mov eax,TRUE<br />	ExitMethod<br />@@:	mov eax,FALSE<br />MethodEnd<br /><br />Method D3D_SkinMeshInstance.onBoneUpdated,uses esi,pBoneFrame<br />	SetObject esi<br />	mov eax,pBoneFrame<br />	mov edx,.pBitKey_Attachments<br />	movzx eax,.FRAME.BoneIndex<br />	bt word ptr, ax<br />	jnc @F<br />	;The bit was SET - this bone has something attached to it<br />	shl eax,2<br />	mov edx,.pAttachedObjects<br />	mov edi, dword ptr<br />	;For now we&#039;ll assume that the attachment is a D3D_MeshManaged object (we can attach skinmeshes at a later date)<br />	;Let&#039;s overwrite the MANAGED MESH&#039;s transform matrix with the BONE&#039;s transform matrix<br />	mov edx,pBoneFrame<br />	invoke RtlMoveMemory,addr .D3D_MeshManaged.mBodyToWorld, addr .FRAME.matCombined,sizeof D3DXMATRIX<br />@@: ;The bit was CLEAR - theres nothing attached to this Bone<br />MethodEnd<br /><br /><br /></code></pre><br /><br /><br />Your thoughts?<br /></div>
    <div class="meta">Posted on 2008-07-14 03:20:37 by Homer</div>
   </div>
   <div class="post" id="post-205629">
    <div class="subject"><a href="#post-205629">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">While I&#039;m &#039;boning up&#039;, I thought it would be cool to extend the MeshManager class (used to manage instances of static meshes) so that it also manages the reference meshes.<br /><br />By properly managing both Reference and Instance objects, the user is free to concentrate on the stuff that matters to them, free to forget about managing these resources.<br /><br />Now the MeshManager keeps two lists - one is a list of ManagedMesh instances - these refer to D3D_Mesh instances... the other is a list of loaded D3D_Mesh instances :)<br />Although we can load several Reference Meshes, each will be loaded only once.. and ALL instances of these ref meshes are kept in a single group, no matter which mesh they represent.<br /><br />Note that these changes only affect STATIC meshes - not Skinned ones.<br />I do not think THESE changes will break any existing applications, however the changes to Skinmesh are another matter. I&#039;ll be providing Biterider with any / all files I have messed with, and I&#039;m pretty sure that he&#039;ll make them immediately available for download via OA32&#039;s Updater application.<br /><br /><br /></div>
    <div class="meta">Posted on 2008-07-14 10:16:11 by Homer</div>
   </div>
   <div class="post" id="post-205634">
    <div class="subject"><a href="#post-205634">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">The code to attach instanced static meshes to instanced animated skinmeshes is working, based on the &#039;onBoneUpdated&#039; dynamic callback I mentioned previously.<br />I&#039;m still not completely convinced that it can&#039;t be done more efficiently, but its still a lot more efficient than the typical solution of loading multiple copies of the entire resource.<br />This is gonna be fun, my lead 3D artist has been grinding his teeth, now the shoe is going on the other foot :P<br /></div>
    <div class="meta">Posted on 2008-07-14 21:08:50 by Homer</div>
   </div>
   <div class="post" id="post-205637">
    <div class="subject"><a href="#post-205637">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">D3D_MeshManager was afforded the Scaling support from D3D_Mesh, and now I&#039;ve got a demo of a walking model (instanced) with a Sword attached to its hand (instanced), wherever the hand goes, whichever way the hand aims, the sword follows it, bound by its transform matrix.<br /><br />The important part here is that everything is Instanced - if we had seventeen bloodthirsty pirates on our screen, and one dropped his sword, the rest will hang onto theirs, even though they all share the same skinmesh. We can give them different accessories to make them appear more different, and we can switch their Skin texture as well, which makes a huge difference to the APPEARANCE of a model, given the same underlying geometry.<br /></div>
    <div class="meta">Posted on 2008-07-15 06:53:41 by Homer</div>
   </div>
   <div class="post" id="post-205645">
    <div class="subject"><a href="#post-205645">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">Current work:<br />I&#039;ve found a much better place to implement the code which &#039;dynamically welds&#039; attachments to my skinmesh instances.. it means one callback per skinmesh update, instead of one callback per boneframe update.. vastly more efficient.<br /><br />Next work:<br />I&#039;m going to leverage the skinmesh-attachments stuff in order to implement BREAKABLE skinmeshes. You&#039;ll be able to tear your enemies limb from limb :)<br /><br />This will be done as follows:<br />Firstly, we&#039;ll make our model, complete with joint hierarchy (at minimum).<br />Then we cut the model up into bodyparts, splitting the mesh into N meshes, one per Joint.<br />We&#039;ll apply a different Material to each bodypart - this is important.<br />Now for each Bodypart, we hide all the others, cap the open surfaces (stumps) of the bodypart, and save it out to a separate file.<br />(We MAY need to move the bodypart to the Origin - it depends on the implementation, I&#039;m yet to decide..)<br />Now we have our complete model, and a bunch of bodyparts.<br />We never attach the bodyparts to the skinmesh - when we wish to break the skinmesh, we instance some bodyparts, stop the skinmesh animations, and initialize the bodypart instances&nbsp; in WorldSpace based on the attachment joint&#039;s transform - as IF we were attaching them.<br /><br />Now when rendering the skinmesh, if its not &#039;completely broken&#039;, we draw the materials of the joints that have NOT been broken.. this is how we can retain our animated skinmesh minus, say, an arm and a leg :P<br /><br />I could not find any information online about how to do this, I&#039;m winging it.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-07-16 08:02:20 by Homer</div>
   </div>
   <div class="post" id="post-205648">
    <div class="subject"><a href="#post-205648">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">I&#039;m not sure I made myself clear in the previous post.<br />There&#039;s no need really to attach the breakable limbs to the skinmesh - what we really want to do is determine their position/orientation at the moment breakage occurs - so it would make sense to use existing code to attach, and then immediately detach, the bodyparts that just got chopped off by that axe-wielding barbarian... now those severed limbs can be treated as simply static meshes under the influence of the physics simulator... in fact the original bodyparts are still being animated by the skinmesh (cant see any easy way to prevent this), they&#039;re just being hidden either through tagging of Material or by storing each in a separate MeshContainer (bonegroup) within the frametree... I think the Material-tagging method will be cheaper than having to process multiple MeshContainers... but then again, multiple MeshContainers indeed opens the possibility of eliminating the animation of &#039;invisible&#039; limbs :)<br /><br /></div>
    <div class="meta">Posted on 2008-07-17 01:21:07 by Homer</div>
   </div>
   <div class="post" id="post-205652">
    <div class="subject"><a href="#post-205652">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">I&#039;ve just installed an experimental new version of OA32.<br />The teething problems are relatively minor, but require that I edit any objects that I wrote (Biterider has modified all the ones you get with OA32, its only &#039;personal&#039; objects that need the changes).<br /><br />If I was a new OA32 user, it would not affect me at all, but existing OA32 users are going to need to learn how the changes affect them, should this version of OA32 be released.<br /><br />And for future reference (in case I forget, which I am liable to), the following three statements sum up the major syntactical changes:<br /><br /><div class="quote"><br />StaticMethod becomes VirtualMethod<br />BoundMethod becomes StaticMethod<br />@ClassName becomes TPL_ClassName<br /></div><br /></div>
    <div class="meta">Posted on 2008-07-18 02:41:04 by Homer</div>
   </div>
   <div class="post" id="post-205655">
    <div class="subject"><a href="#post-205655">Re: ObjAsm32 - new stuff</a></div>
    <div class="body"><div class="quote"><br />Just curious - what are you guys working on lately?<br /></div><br />Homer, not much programming these days since its summer here.<br />Mainly &quot;Honey DO&quot; lists... :lol: Grass cutting, gardens, and whatever else she can come up with for me to do...<br />Rags</div>
    <div class="meta">Posted on 2008-07-18 21:06:34 by rags</div>
   </div>
   <div class="post" id="post-205665">
    <div class="subject"><a href="#post-205665">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">Heh, make hay while the sun shines :P<br /><br />I&#039;ve just re-implemented support for outbound connections in my iocp-based networking support object, so it can talk to itself:P<br /><br />Further, each network session can now use its own protocol-handling object... note where I say &#039;Client&#039; I refer to a network session, regardless of who initiated it.<br />The framework marshalls protocol-dependent calls to each Client&#039;s protocol handler...<br />basically the framework just makes calls to Client methods in a dumb fashion, and from there execution is passed to the Client&#039;s protocol handler.<br /><br />By default, the server knows a Protocol, supplied as a derivation of a common &#039;abstract interface&#039;. All the &#039;Inbound&#039; client sessions will inherit this handler, so conversations between our local server and remote clients will only use the default protocol, or the server will spit the dummy and kick the client off (for breaching the protocol).<br /><br />But each &#039;Outbound&#039; client session can have its own Protocol handler, so conversations between local clients and a remote server can use ANY PROTOCOL, they are not tied down to using the default protocol of our server.<br /><br />It&#039;s all very nicely asynchronous, using overlapped socket io.<br />I guess I&#039;ll keep going to weed out some of the unnecessary calls across objects :)<br /><br /><br /></div>
    <div class="meta">Posted on 2008-07-20 23:31:48 by Homer</div>
   </div>
   <div class="post" id="post-205673">
    <div class="subject"><a href="#post-205673">Re: ObjAsm32 - new stuff</a></div>
    <div class="body"><br />I&#039;ve implemented support for grouping of clients on the Server via a new object called ClientGroup. This object implements a hierarchy or tree of nodes where each node contains a list of clients. The idea was borrowed from DirectPlay - it made a lot of sense to me that te ability to track groups of clients is going to be valuable for a wide range of server implementations - for example, &#039;Lobby&#039; servers, chatroom servers, games that support clans / tribes / teams etc.<br />The code has been tested in a demo &#039;LobbyServer&#039;, with a cheesy GUI to let the local administrator visualize and modify the client groups at runtime.<br /><br />Next I&#039;ll be implementing some kind of abstract support for Account Registration and Authentication, and also abstract support for application event notifications - probably by embedding an instance of my relatively new EventManager object, rather than forcing the User to have to think about application-side event sinking interfaces. And when thats in place, I can begin to redirect the Game application event handling through the Server so that when you eg press a key, instead of being handled locally, the event is sent to the server, a reply is returned, and then the Game reacts to the Reply from the Server. I know its blindingly obvious but the temptation to hook up local handlers for everything is acute and its just not what you want for a network-ready gaming framework.<br /><br /><br /></div>
    <div class="meta">Posted on 2008-07-22 01:14:28 by Homer</div>
   </div>
   <div class="post" id="post-205675">
    <div class="subject"><a href="#post-205675">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">Decided to attack those topics in the opposite order.<br />I noticed that my Server object was still being derived from the Primer ancestor object, which is the root object in OA32 kinda like IUnknown is for COM interfaces.<br />Now I have Server being derived from my EventManager.<br />This gives me a way for Server apps to register their interest in various (assumedly asynchronous) events that occur within (are triggered by) the Server framework, perhaps to force the GUI to refresh its content in regards to a state change (if the server has a gui, or a window at all, neither are requirements).<br />It gives me a way for the Server to call USERCODE in response to internal events, which might be handy, don&#039;t you think? <br /><br /></div>
    <div class="meta">Posted on 2008-07-22 02:23:41 by Homer</div>
   </div>
   <div class="post" id="post-205676">
    <div class="subject"><a href="#post-205676">Networking Engine Component is almost completed</a></div>
    <div class="body"><br />Nah, I stripped away all the Event stuff I&#039;d just added.<br />Then I spent some hours chasing some resource leaks, getting rid of a few blatantly unnecessary methods, renaming some stuff, and generally cleaning it up.<br />Then I implemented support for multiple Listeners, using my existing Client object.<br />I needed an object to wrap a socket handle, and hey, I already had one.<br />Listeners are just Clients whose socket is a listening server.<br />Like all Clients, they are tagged with a Protocol handler.<br />Clients issued by a Listener for ACCEPT are tagged with their Listener, and his Protocol.<br /><br />So now we can serve on multiple ports, use multiple protocols, and do it all through a shared pool of resources.<br /><br />Having done that, I created a new Listen method to allocate new Listeners, so the Server no longer begins to Listen when Initialized, which means that the framework can be used as a pure Server (inbound connects), or as a pure Client (outbound connects), or it can do both.<br /> I have renamed the Server object to &quot;NetEngine&quot; to recognize this fact.<br /><br /></div>
    <div class="meta">Posted on 2008-07-22 07:38:46 by Homer</div>
   </div>
   <div class="post" id="post-205677">
    <div class="subject"><a href="#post-205677">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">Sounds good, homer! :)</div>
    <div class="meta">Posted on 2008-07-22 07:41:44 by f0dder</div>
   </div>
   <div class="post" id="post-205680">
    <div class="subject"><a href="#post-205680">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">I&#039;m now having a look at implementing automatic NAT traversal via upnp.<br />I know, not all routers / NAT devices supports it, and it can be disabled by those who are concerned about the malware already on their system abusing upnp (lol, if you have malware then you&#039;re already screwed, it can enable upnp too).<br />However I&#039;d like my applications to at least TRY to use it, before whining at the User to manually configure port-forwarding.<br /></div>
    <div class="meta">Posted on 2008-07-23 04:19:39 by Homer</div>
   </div>
   <div class="post" id="post-205682">
    <div class="subject"><a href="#post-205682">Re: ObjAsm32 - new stuff</a></div>
    <div class="body"><div class="quote">(lol, if you have malware then you&#039;re already screwed, it can enable upnp too).</div>Spot on the sugar, baby!<br /><br />If upnp isn&#039;t available you could also try using <a target="_blank" href="http://en.wikipedia.org/wiki/STUN">STUN</a> :)</div>
    <div class="meta">Posted on 2008-07-23 09:33:03 by f0dder</div>
   </div>
   <div class="post" id="post-205687">
    <div class="subject"><a href="#post-205687">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">STUN is no good for me, the NetEngine currently does not have a TCP emulation layer, in fact it has zero UDP support. Perhaps I&#039;ll add that at some stage but for now I&#039;m happy to use TCP and wear the overhead - gamers tend not to use dialup connections these days :)<br />There is always STUNT to consider in the meantime :)<br /></div>
    <div class="meta">Posted on 2008-07-24 02:36:07 by Homer</div>
   </div>
   <div class="post" id="post-205688">
    <div class="subject"><a href="#post-205688">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">I generally prefer TCP connections myself, lots of people using UDP end up writing basically a (less reliable) TCP clone - which is a waste of effort. But for protocols that can survive a few dropped packets here and there, UDP can be fine - and STUN <strong>is</strong> a cute trick :)</div>
    <div class="meta">Posted on 2008-07-24 09:23:08 by f0dder</div>
   </div>
   <div class="post" id="post-205695">
    <div class="subject"><a href="#post-205695">Re: ObjAsm32 - new stuff</a></div>
    <div class="body">Today was a quiet day so I decided to try a little experiment that I&#039;ve had on my mind for some time now - I was wondering how to create an animated skinmesh that contains multiple meshcontainers, so that I can &#039;break&#039; the skinmesh at runtime by terminating the rendering at a given meshcontainer in the hierarchy... <br />I was under the impression that I&#039;d have to bind each Bone to its associated mesh, but its much easier than that... all you need to do is have multiple meshes, then select Everything, and Bind once... the fact that you have more than one Mesh is all you need to create more than one MeshContainer. I&#039;ve been merging my meshes because I was led to believe that a skinmesh REQUIRES a single mesh, but that is absolutely untrue... unless you&#039;re a cut and paste cowboy who&#039;s relying on the code from those DX SDK samples in its given form :P<br />Now I need to speak to my 3D artist and tell him the good news - then he can explain to the 2D guys how we want &#039;stump textures&#039; on the (normally) hidden faces on the endcaps of each bodypart :) <br /><br /></div>
    <div class="meta">Posted on 2008-07-27 00:56:17 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29091&amp;page=1" style="">&laquo;</a><a href="../?id=29091&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29091" /><input type="number" name="page" min="1" max="5" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=29091&amp;page=3">&gt;</a><a href="../?id=29091&amp;page=5">&raquo;</a></form>  </div>
 </body>
</html>