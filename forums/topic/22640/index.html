<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>More than 16 IRQs? (and also IRQ sharing) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=22640" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=34">OS Development</a> &raquo; <a href="../?id=22640">More than 16 IRQs? (and also IRQ sharing)</a></p>
   <div class="post" id="post-169814">
    <div class="subject"><a href="#post-169814">More than 16 IRQs? (and also IRQ sharing)</a></div>
    <div class="body">How do I handle IRQs &gt; 0xF ? Many PCI devices are being assigned to such IRQs (my 2 ethernet cards are IRQ 20 and 21, respectively). I can see that Windows (XP) is normally handling IRQs above 0xF. How is that done? I can also see, that 2 or more PCI devices can be attached to same IRQ (IRQ sharing) - it&#39;s described in PCI 2.1 spec. Is there any &quot;standard&quot; mechanism to see which device has actually sent the IRQ we handle, or it&#39;s device-specific?</div>
    <div class="meta">Posted on 2006-02-07 07:20:55 by ti_mo_n</div>
   </div>
   <div class="post" id="post-169815">
    <div class="subject"><a href="#post-169815">Re: More than 16 IRQs? (and also IRQ sharing)</a></div>
    <div class="body">The method is called IRQ Steering, read this article, <a target="_blank" href="http://support.microsoft.com/default.aspx?scid=kb;EN-US;q182604">http://support.microsoft.com/default.aspx?scid=kb;EN-US;q182604</a><br /><br />hth,<br />Paul<br /></div>
    <div class="meta">Posted on 2006-02-07 08:31:35 by PBrennick</div>
   </div>
   <div class="post" id="post-169816">
    <div class="subject"><a href="#post-169816">Re: More than 16 IRQs? (and also IRQ sharing)</a></div>
    <div class="body">Hi pbrennick,<br /><br />It just says that the Windows OS &quot;steers&quot; a device to a particular IRQ (within 0x00 - 0x0F range) in case of a conflict. It doesn&#39;t say how am I suposed to service an IRQ higher than 0x0F. I/O PIC supports 16 IRQs (actually: 15, due to cascading), so how do I assing a CPU&#39;s &#39;int&#39; to an IRQ -for example- 20?<br /><br />I wouldn&#39;t be a problem if PCI devices just collided --&nbsp; I would just use &#39;some way&#39; to find out which one is the one sending an IRQ. But what do I do if a device says that it&#39;ll send IRQ19? And -in case of a shared IRQ (doesn&#39;t matter which one)- how am I supposed to know which device is sending IRQ? Is there any standard way, or do I have to develop some &quot;smart ways&quot; to find this out?</div>
    <div class="meta">Posted on 2006-02-07 08:56:19 by ti_mo_n</div>
   </div>
   <div class="post" id="post-169817">
    <div class="subject"><a href="#post-169817">Re: More than 16 IRQs? (and also IRQ sharing)</a></div>
    <div class="body"><br />&gt; so how do I assing a CPU&#39;s &#39;int&#39; to an IRQ -for example- 20?<br /><br />If I understand it correctly there is still a 15 hardware IRQ lines limit for win2k and XP. But since PCI devices can share hardware IRQs one has introduced a &quot;virtual IRQ&quot; concept, which of course is implemented as &quot;software&quot;.<br /></div>
    <div class="meta">Posted on 2006-02-07 09:14:52 by japheth</div>
   </div>
   <div class="post" id="post-169818">
    <div class="subject"><a href="#post-169818">Re: More than 16 IRQs? (and also IRQ sharing)</a></div>
    <div class="body">It is handled in a software chain.<br /><br />When you hook an interrupt, save the previous pointer.<br />If it is not your device that generated the interrupt then do a call to that previous pointer.<br /><br />KetilO<br /></div>
    <div class="meta">Posted on 2006-02-07 09:20:57 by KetilO</div>
   </div>
   <div class="post" id="post-169819">
    <div class="subject"><a href="#post-169819">Re: More than 16 IRQs? (and also IRQ sharing)</a></div>
    <div class="body">Hi japheth and KetilO,<br /><br />So the IRQs above 0xF are virtual? But in such case: Why the actual devices report that they&#39;ll send IRQ higher than 15? They should just send -for example- 12, and leave the rest to the OS, shouldn&#39;t they?<br /><br />Here: <a target="_blank" href="http://img222.imageshack.us/img222/4479/image18qn.png">Ethernet controller config</a><br />We can read its communication config:<br />first I/O port: 0xB400<br />Address Base: 0xD3800000<br />IRQ: 0x15<br />This Ethernet controller reports that it&#39;ll send IRQ21 (0x15). How&#39;s that possible? The I/O PIC translates only IRQs in range 00-0xF into software <strong>INT</strong>s. How it&#39;s going to handle IRQ 0x15?<br /><br /><div class="quote">There are 256 interrupts, numbered from 0 to 255, but only 16 are used by devices. These are called IRQs (Interrupt ReQuest) or hardware interrupts. The 16 IRQs are numbered from 0 to 15.</div><br />This quote is from <a target="_blank" href="http://www.mega-tokyo.com/osfaq2/index.php/InterruptsForDummies">Mega-Tokyo OS DEV FAQ</a>.<br /><br />It wouldn&#39;t be surprising if all PCI devices just said that they&#39;ll use IRQ12. But it IS surprising when they say, that they&#39;ll use IRQ21&nbsp; &nbsp;:confused:</div>
    <div class="meta">Posted on 2006-02-07 09:24:32 by ti_mo_n</div>
   </div>
   <div class="post" id="post-169823">
    <div class="subject"><a href="#post-169823">Re: More than 16 IRQs? (and also IRQ sharing)</a></div>
    <div class="body">I am no expert with Windows, but I am guess the DDK/Docs probably state that anything above IRQ 0xF will be redirected to a valid IRQ and handled via software interrupt handlers, or just allow developers to do it without that knowledge since it doesn&#39;t make a difference as long as &quot;it works&quot;. This might also be the reason why Windows is able to determine things so easily with virtual IRQs (what a hardware driver assigns and what Windows maps the hardware as are two different things).<br /><br />As for the quote, it is more or less correct. I haven&#39;t dealt with IRQ &quot;trickery&quot; much, but I would follow KetilO&#39;s lead since it sounds valid for the kind of Interrupt Handling you will need.</div>
    <div class="meta">Posted on 2006-02-07 16:02:30 by SpooK</div>
   </div>
   <div class="post" id="post-169828">
    <div class="subject"><a href="#post-169828">Re: More than 16 IRQs? (and also IRQ sharing)</a></div>
    <div class="body">This is how it is done in SolarOS also ;)<br /><br />For each hardware IRQ line there is a generic handler that will check a list of registered software handlers .<br />Each valid software handler will get called.<br /><br />This is of course slow and bad but doh this is the &quot;standard&quot; because each PCI board can share IRQs.<br /><br />The answer from the PCI bus scanning puzzles me also.<br />I have also noticed this IRQ line &gt; 0x0Fh on newer computers.<br /><br />Maybe humans evolved and at last (after 10 years) some PC&#39;s have more that 15 IRQ&#39;s? <br />Who knows...we will have to investigate this in more details...<br /><br /></div>
    <div class="meta">Posted on 2006-02-08 01:28:57 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-169836">
    <div class="subject"><a href="#post-169836">Re: More than 16 IRQs? (and also IRQ sharing)</a></div>
    <div class="body">Hi SpooK and BogdanOntanu,<br /><br />That quote from Mega-Tokyo is probably -at least partially- wrong. I&#39;ve downloaded the <a target="_blank" href="http://www.intel.com/design/chipsets/datashts/290566.htm">Intel 82093AA I/O Advanced Programmable Interrupt Controller (I/O APIC) Datasheet</a> and gave it a quick glance. It Supports 24 IRQs (one of them is SMI#, which puts the CPU into SMM mode, so it&#39;s probably not usable). I&#39;ll proceed to play with it and learn how to identify it and program it correctly when I find some time. First thing worth the note is that there is no &#39;cascading&#39; here, so IRQs 9 and 2 are separate (probably).<br /><br />As for the IRQ sharing: So there is no &#39;standard&#39; way to &#39;ask&#39; a device if it has any data? When an interrupt occurs, I have to &#39;normally&#39; check each device (assigned to this IRQ) to find out which one is the signalling one?<br /><br />/edit<br /><br />Quote from <a target="_blank" href="http://www.intel.com/design/chipsets/specupdt/290710.htm">Intel 82093AA I/O Advanced Programmable Interrupt Controller (I/O APIC) Specification Update</a>:<br /><br />The 82093AA I/O Advanced Programmable Interrupt Controller (I/O APIC) may be identified by the following register contents:<br /><table><tr><td><strong> Register </strong></td><td> | </td><td><strong> APIC Offset </strong></td><td> | </td><td><strong> Value </strong></td></tr><tr><td> IOAPICVER </td><td> | </td><td> 01h </td><td> | </td><td> 00170011h </td></tr></table></div>
    <div class="meta">Posted on 2006-02-08 10:53:29 by ti_mo_n</div>
   </div>
   <div class="post" id="post-169843">
    <div class="subject"><a href="#post-169843">Re: More than 16 IRQs? (and also IRQ sharing)</a></div>
    <div class="body">That is good news: more than 16IRQs, but they will never learn:D why not 32 or 64? <br />This would have fixed it for a longer time frame.<br /><br />Doh, it also means that we must deal with both types of IRQ controlers in our OSes<br />Anyway overall this is definitively some good news.<br /><br />About IRQ sharing: if you have enough IRQ lines this concept becomes a bad ideea even more!<br />Nevertheles it is widely used in Win2K/XP/Linux/etc since it resolves service and support problems by slowing down the&nbsp; PC.<br /><br />And yes, unfortunately you are right there is no standard way to detect what device did trigger the IRQ.<br /><br />You will have to ask each device that shares an IRQ in sequence and act acordingly. Also consider that each manufacturer has its own style and idioms and preferences. Basically you should know what IRQ&#39;a are in a pending state and colaborate this with the information that can be extracted from the controllers; most of the time hardware controlers have a way to say: &quot;hey, I did this!&quot; but this way is device specific.<br /><br />Take care because sometimes simply reading the controler&#39;s status ports cand trigger a state change in the device... <br />And maybe this device did NOT generate the IRQ but it will generate one IRQ in the future after finishing operations already launched but not finished when this &quot;other&quot; device triggered the IRQ :D<br /><br /></div>
    <div class="meta">Posted on 2006-02-08 17:27:12 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-169845">
    <div class="subject"><a href="#post-169845">Re: More than 16 IRQs? (and also IRQ sharing)</a></div>
    <div class="body">Well, the acronym &quot;APIC&quot; should be self-explanatory. We were simply talking about the PIC, which has had a set standard for decades already. Working with the APIC is another battle altogether, mostly an extension of the standards used in the original PIC.<br /><br />The real question you have to ask yourself is, how do you make your OS work they way you want whether it is the standard PIC or the APIC???</div>
    <div class="meta">Posted on 2006-02-08 18:38:03 by SpooK</div>
   </div>
   <div class="post" id="post-169846">
    <div class="subject"><a href="#post-169846">Re: More than 16 IRQs? (and also IRQ sharing)</a></div>
    <div class="body"><div class="quote">That is good news: more than 16IRQs, but they will never learn:D why not 32 or 64? </div><br />I think that they just wanted to get a few really free IRQs for the PCI. Low-numbered IRQs are stuffed already with system devices and ISA devices (although no one is using them today). PCI devices can happily share IRQs, so I doubt they&#39;ll continue to increase this number (or at least: increase by some significant amount).<br /><br /><div class="quote">Doh, it also means that we must deal with both types of IRQ controlers in our OSes</div><br />That&#39;s what I thought too :P<br /><br /><div class="quote">About IRQ sharing: if you have enough IRQ lines this concept becomes a bad ideea even more!</div><br />Yeah, but it seems we&#39;re &#39;forced&#39; to apply to it, since the number of devices in a regular PC i drastically growing.<br /><br /><div class="quote">And yes, unfortunately you are right there is no standard way to detect what device did trigger the IRQ.<br />You will have to ask each device that shares an IRQ in sequence and act acordingly. Also consider that each manufacturer has its own style and idioms and preferences. Basically you should know what IRQ&#39;a are in a pending state and colaborate this with the information that can be extracted from the controllers; most of the time hardware controlers have a way to say: &quot;hey, I did this!&quot; but this way is device specific.</div><br />There&#39;s no problem with Intel&#39;s stuff, since they document everything very, very well. ...But not everyone has Intel&#39;s chipsets. At times like this I vote for Intel&#39;s monopolization! :P<br /><br /><div class="quote">Take care because sometimes simply reading the controler&#39;s status ports cand trigger a state change in the device... <br />And maybe this device did NOT generate the IRQ but it will generate one IRQ in the future after finishing operations already launched but not finished when this &quot;other&quot; device triggered the IRQ :D</div><br />Yeah, seems like writing the Interrupt routines and programming APICs themselves is going to be very funny :P<br /><br /><div class="quote">The real question you have to ask yourself is, how do you make your OS work they way you want whether it is the standard PIC or the APIC???</div><br />Well if you ask me, then I say that I&#39;ll just support modern PCs. I&#39;m not in mood of writing compatibility code just for 0.01% of potential users :) The OS I&#39;m about to write already requires a Pentium-II class CPU. This will go up if I decide to use SSE throughout the kernel.</div>
    <div class="meta">Posted on 2006-02-08 18:55:44 by ti_mo_n</div>
   </div>
   <div class="post" id="post-169855">
    <div class="subject"><a href="#post-169855">Re: More than 16 IRQs? (and also IRQ sharing)</a></div>
    <div class="body"><div class="quote"><br />I think that they just wanted to get a few really free IRQs for the PCI. Low-numbered IRQs are stuffed already with system devices and ISA devices (although no one is using them today). PCI devices can happily share IRQs, so I doubt they&#39;ll continue to increase this number (or at least: increase by some significant amount).<br /></div><br />The so called legacy ISA devices are in fact included in the chipset soutbridge and they are well proven, tested and pretty useful.<br />Even more everybody knows how to program them ;) They are not so much &quot;not used&quot; as they are &quot;widely wrong judged&quot;.<br /><br />This is the standard &quot;human born yesterday sindrome&quot;--&gt; all that is older is bad and all there is in future is going to be good ... wake up.<br /><br />A very good example is the PS/2 mouse that was there for a reason and replacing a mouse with an USB one is the most foulish ideea for multiple very clear logical reasons. Nevertheess &quot;progress&quot; and people did it because of miss judgement. <br /><br />Even when low number IRQs are eliberated by such devices &quot;modern&quot; OSes like Win2k or WinXp or Linux will not &quot;re-populate&quot; those IRQ&#39;s but instead they will stick to sharing the same IRQ 10 or 11 :D . However Win98 was able to do this. So much for &quot;progress&quot;<br /><br />&quot;Happy to share IRQs&quot; is the worst and slowest possible scenario :D The whole ideea is to try an have a single device on a single IRQ line. They will get multiplexed anyway since the CPU only has a single INTERUPT input line... now this CPU design is not the best...&nbsp; BUT sharing them even before the CPU is &quot;stupidity at its best peaks&quot;<br /><br /><div class="quote"><br />Yeah, but it seems we&#39;re &#39;forced&#39; to apply to it, since the number of devices in a regular PC i drastically growing.<br /></div><br /><br />I do no see how the devices in my PC that are actually using IRQ lines could grow beyond 64. Besides instrumentation for a space shuttle or cold fusion experiment. Now really in this kind of situations you would need more PC&#39;s or CPUs anyway. I would not want to delay real time data aquisitions just because I have to play &quot;sharing IRQ line&quot; guess games...<br /><br /><div class="quote"><br />There&#39;s no problem with Intel&#39;s stuff, since they document everything very, very well. ...But not everyone has Intel&#39;s chipsets. At times like this I vote for Intel&#39;s monopolization! Tongue<br /></div><br /><br />Hihihi, YES for now Intel does that--&gt; good for them. However do not consider Intel as playing a fair game. They just choose to do this and they could turn it OFF at any time in the future in this competition based world. Think again about NVidia and ATI that are in the same monopolistic position and refuse to offer any kind of information :D What do you do then?<br /><br />Imagine a world with 99% of PC&#39;s based on INTEL chips (not hard since Apple is switching already) AND INtel witholding any new information and releasing it under mutual agreements with big player or for huge ammounts of money ...WHAT would you do then?<br /><br />For example the VESA VEB /AF (acceleration) new standards are available for a &quot;decent ammount of cash&quot;...<br />Now have you seen them free on the internet lately? I also bet someone does have the NVIDIA specifications under a tight agreement.<br />They are not on P2P either... money and law rules!<br /><br />Intel did removed the AGP 2.0 specifications from their site just to promote the NEW PCI-Express specifications for example.<br />Do you guess how many PC in today world stll have AGP or even PCI video cards... guess what they are exactly your test users!<br />I will not test a new home made OS on my new laptop (besides SolOS that is :P). I would test it on some antique slow P1 or P2 or P3 at maximum and they have very old hardware. If your OS is not runing on them :P THEN i will not give it a try anymore.<br /><br /><div class="quote"><br />Yeah, seems like writing the Interrupt routines and programming APICs themselves is going to be very funny<br /></div><br /><br />Writting drivers and working with real hardware devices at low level is ALWAYS FUN ... you just need a special kind of hummor!<br /><br />I have just found out that my CD-ROM reading routins that worked so nice in Virtual PC ar not working ok on slightly older CD-ROMS :P<br />That VESA 3.0 does NOT mean LFB is available on Intel815 integrated video board and that some devices do generate an IRQ at software reset but some others do NOT, the USB designers at INTEL did not have a CLUE what an IRQ means and what it is used for ... and the list is growing<br /><br /><div class="quote"><br />Well if you ask me, then I say that I&#39;ll just support modern PCs. I&#39;m not in mood of writing compatibility code just for 0.01% of potential users Smile The OS I&#39;m about to write already requires a Pentium-II class CPU. This will go up if I decide to use SSE throughout the kernel.<br /></div><br /><br />Well you will be amazed to find out that more that 70% of today PCs DO NOT HAVE AN APIC (not the local one in&nbsp; the CPU)<br />So you are highly optimistic about 0.01% maybe you are refering to an 5 inch floppy drive :P<br /><br />As for Pentium 2 CPU&#39;s: they clearley have no APIC as neither do most P3 chipsets.</div>
    <div class="meta">Posted on 2006-02-09 11:25:38 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-169856">
    <div class="subject"><a href="#post-169856">Re: More than 16 IRQs? (and also IRQ sharing)</a></div>
    <div class="body">Common confusion is created between APIC (rarely used) and ACPI (used a good deal).</div>
    <div class="meta">Posted on 2006-02-09 12:14:34 by SpooK</div>
   </div>
   <div class="post" id="post-169878">
    <div class="subject"><a href="#post-169878">Re: More than 16 IRQs? (and also IRQ sharing)</a></div>
    <div class="body"><div class="quote"><br />A very good example is the PS/2 mouse that was there for a reason and replacing a mouse with an USB one is the most foulish ideea for multiple very clear logical reasons. Nevertheess &quot;progress&quot; and people did it because of miss judgement.<br /></div><br />What&#39;s wrong with USB mice? PS/2 has a limited speed / packet rate, USB allows for higher mouse resolution. It&#39;s also pretty nice to have some of the old legacy ports removed from motherboards, since they (for many people) just take up space.<br /><br />But sure, USB is &quot;somewhat more difficult&quot; to program than PS/2 :)<br /></div>
    <div class="meta">Posted on 2006-02-11 10:49:47 by f0dder</div>
   </div>
   <div class="post" id="post-169881">
    <div class="subject"><a href="#post-169881">Re: More than 16 IRQs? (and also IRQ sharing)</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br />A very good example is the PS/2 mouse that was there for a reason and replacing a mouse with an USB one is the most foulish ideea for multiple very clear logical reasons. Nevertheess &quot;progress&quot; and people did it because of miss judgement.<br /></div><br />What&#39;s wrong with USB mice? PS/2 has a limited speed / packet rate, USB allows for higher mouse resolution. It&#39;s also pretty nice to have some of the old legacy ports removed from motherboards, since they (for many people) just take up space.<br /><br />But sure, USB is &quot;somewhat more difficult&quot; to program than PS/2 :)<br /><br /></div><br /><br />Many things are wrong with the USB some of them are:<br />-very bad internal design: pooling 1024 descriptors per seccond and no real IRQ support but stil use up IRQ<br />-very complicated: descriptors in descriptors in descriptors but not flexible enough to have Video and mouse and stick on the same port without incredible loss of bandwidth. And evem more: please use up as much CPU power as possible for even the most simple operation.<br /><br />Yes PS/2 has limits, but guess what? they are just OK for the mouse device!<br /><br />I am not against using USB devices (theer are good things about it) but I consider it shuld NOT be used for the mouse.<br /><br />First of all the mouse generates IRQs whan data is ready... the&nbsp; USB requires pooling and constant PCI bus transfers because who designed it had no clue about what an IRQ is...funny becaus the same company makes IRQ controllers (Intel)<br /><br />Even more the USB mouse is a &quot;slow&quot; device on the USB bus and with its slow packets/mode it is slowing down other devices as well.<br />I think USB should be used for faster devices like sticks, HDD or video cameras.<br /><br />Nope USB it is not that much more complicated to programm... it is just plain stupid... <br /></div>
    <div class="meta">Posted on 2006-02-11 18:56:55 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-186917">
    <div class="subject"><a href="#post-186917">Re: More than 16 IRQs? (and also IRQ sharing)</a></div>
    <div class="body">has anyone worked on the MSI (Message Signaled Interrupt) on PCI? sounds like a fun stuff to me (at least on the name)</div>
    <div class="meta">Posted on 2006-12-10 23:44:36 by Pinczakko</div>
   </div>
  </div>
 </body>
</html>