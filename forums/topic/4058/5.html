<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>New strlen algorithm by Jens Duttke - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4058" />
  <link rel="prev" href="../?id=4058&amp;page=4" />  <link rel="next" href="../?id=4058&amp;page=6" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=4058">New strlen algorithm by Jens Duttke</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=4058&amp;page=1" style="">&laquo;</a><a href="../?id=4058&amp;page=4" style="">&lt;</a><input type="hidden" name="id" value="4058" /><input type="number" name="page" min="1" max="9" step="1" value="5" onchange="this.form.submit();" /><a href="../?id=4058&amp;page=6">&gt;</a><a href="../?id=4058&amp;page=9">&raquo;</a></form>   <div class="post" id="post-28611">
    <div class="subject"><a href="#post-28611">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">hi!<br /><br />This is my &quot;new routine&quot; with the code to align the string (i am sure it's more optimizable) ... but still ... it works :<br /><br /><pre><code><br />strlen proc lpString&#58;DWORD<br />	mov	eax, 1				; request CPU feature flags<br />	cpuid					; CPUID instruction<br /><br />	;- Pre-Scan to align the string-start ----<br />	mov	ecx, lpString<br />	mov	eax, ecx<br />	cmp	byte ptr &#91;eax&#93;, 0<br />	je	done<br />	and	ecx, 0FFFFFFF8h<br />	add	ecx, 8<br />	sub	ecx, eax<br />	cmp	ecx, 8<br />	je	aligned<br />	@@&#58;<br />		inc	eax<br />		cmp	byte ptr &#91;eax&#93;, 0<br />		je	done<br />	dec	ecx<br />	jnz	@B<br />	aligned&#58;<br />	mov	ecx, eax<br />	;-----------------------------------------<br /><br />	test	edx, 800000h			; test bit 23 to see if MMX available<br />	jz	no_mmx				; jump if no MMX is available<br />		pxor	mm0, mm0<br /><br />		@@&#58;<br />			movq	mm1, qword ptr &#91;ecx&#93;<br />			movq	mm2, qword ptr &#91;ecx + 8&#93;<br />			movq	mm3, qword ptr &#91;ecx + 16&#93;<br />			movq	mm4, qword ptr &#91;ecx + 24&#93;<br />			movq	mm5, qword ptr &#91;ecx + 32&#93;<br />			movq	mm6, qword ptr &#91;ecx + 40&#93;<br /><br />			pcmpeqb mm1, mm0<br />			pcmpeqb mm2, mm0<br />			pcmpeqb mm3, mm0<br />			pcmpeqb mm4, mm0<br />			pcmpeqb mm5, mm0<br />			pcmpeqb mm6, mm0<br /><br />			por	mm1, mm2<br />			por	mm3, mm4<br />			por	mm5, mm6<br />			por	mm1, mm3<br />			por	mm1, mm5<br /><br />			add	ecx, 48<br /><br />			packsswb mm1, mm1<br />		movd	eax, mm1<br />		test	eax, eax<br />		jz	@B<br /><br />		sub	ecx, 48<br /><br />		emms					; Empty MMX state<br />	no_mmx&#58;<br /><br />	@@&#58;<br />		mov	eax, dword ptr &#91;ecx&#93;<br />		add	ecx, 4<br /><br />		lea	edx, &#91;eax - 01010101h&#93;<br />		xor	eax, edx<br />		and	eax, 80808080h<br />		and	eax, edx<br />	jz	@B<br /><br />	bsf	edx, eax<br /><br />	sub	edx, 4<br />	shr	edx, 3<br /><br />	lea	eax, &#91;ecx + edx - 4&#93;<br /><br />	done&#58;<br /><br />	sub	eax, lpString<br /><br />	ret<br />strlen endp<br /></code></pre><br /><br />I've attached an chart which show the different between the &quot;unaligned&quot; and &quot;aligned&quot; &quot;code&quot;.<br /><br />Cu, Jens Duttke</div>
    <div class="meta">Posted on 2002-03-12 13:13:15 by Jens Duttke</div>
   </div>
   <div class="post" id="post-28612">
    <div class="subject"><a href="#post-28612">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Hmm, your routine tests for mmx on each call... imo it would be better<br />to do this check only once (at program startup): make the &quot;strlen&quot;<br />symbol point to a nop-filled area large enough to hold the largest<br />strlen algo. At startup time, VirtualProtect this area to enable write,<br />copy the optimal (based on processor) strlen algo there, and finish<br />off by VirtualProtect()ing the area back to previous protection flags.</div>
    <div class="meta">Posted on 2002-03-12 13:19:10 by f0dder</div>
   </div>
   <div class="post" id="post-28616">
    <div class="subject"><a href="#post-28616">New strlen algorithm by Jens Duttke</a></div>
    <div class="body"><strong>Jens</strong>, all those sharp spikes in your graphs are do to windows multi-tasking.  I choose the lowest of several runs to minimize this effect.  You can see the execution pattern of the code - which is nice, IMHO.  Timing short strings is just as effective when you clear the cache - there is no need to wait two minutes to time an algorithm, IMHO.</div>
    <div class="meta">Posted on 2002-03-12 13:36:29 by bitRAKE</div>
   </div>
   <div class="post" id="post-28620">
    <div class="subject"><a href="#post-28620">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">hi!<br /><br />fodder : I tried it, and your idea seem to improve the speed noticable, thx.<br /><br />bitRAKE : hmm, that's also a nice idea, i will do that, thx too. :) <br />btw. i still don't know how to clear the cache ... do you know any way to do that ? (I think I saw some instructions in SSE to do that, but the P2 does not support SSE).<br /><br />Cu, Jens Duttke</div>
    <div class="meta">Posted on 2002-03-12 13:52:00 by Jens Duttke</div>
   </div>
   <div class="post" id="post-28623">
    <div class="subject"><a href="#post-28623">New strlen algorithm by Jens Duttke</a></div>
    <div class="body"><div class="quote"><br />btw. i still don't know how to clear the cache ... do you know any way to do that?</div>I choose a section of data (the size of the cache) that doesn't have anything to do with what I'm timing, and I load it into cache - this will work on all processors. :)</div>
    <div class="meta">Posted on 2002-03-12 13:59:20 by bitRAKE</div>
   </div>
   <div class="post" id="post-28624">
    <div class="subject"><a href="#post-28624">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Does that data have to be the same size as your cache? Wouldn't<br />any data set &gt;= the size of your cache work?</div>
    <div class="meta">Posted on 2002-03-12 14:07:01 by f0dder</div>
   </div>
   <div class="post" id="post-28629">
    <div class="subject"><a href="#post-28629">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">I wrote a little test program for non-MMX strlens.  I don't know what Agnor's routine is, so it's not in there.  If I left anybody out, post your source, or link to it.<br /><br />This series of tests was done on an AMD Athlon 750.   I'll post my program if anybody wants it.<br /><br /><br /><pre><code>&#91;size=9&#93;Non MMX strlen tests<br />Note&#58; Each test is actually performed 16 times per algo and averaged.<br /><br />--------------------------------------------------------------<br />&#91;b&#93;Test 1 - Endurance&#91;/b&#93;<br />String is 16,777,216 bytes long.<br />--------------------------------------------------------------<br />1.    lstrlen&#40;&#41;	-	      368229.35<br />2. JensDuttke&#40;&#41;	-	      276212.29<br />3.      iblis&#40;&#41;	-	      300473.56<br />4.BScanUnroll&#40;&#41;	-	      309765.33<br />5.  buliaNaza&#40;&#41;	-	      289484.76<br />--------------------------------------------------------------<br />Best fn&#58;<br />&#91;b&#93; JensDuttke&#40;&#41;&#91;/b&#93; by a difference of 13271.47<br />--------------------------------------------------------------<br /><br /><br />--------------------------------------------------------------<br />&#91;b&#93;Test 2 - Practicality&#91;/b&#93;<br />String is 65536 bytes long.<br />--------------------------------------------------------------<br />1.    lstrlen&#40;&#41;	-	         657.06<br />2. JensDuttke&#40;&#41;	-	         371.23<br />3.      iblis&#40;&#41;	-	         413.82<br />4.BScanUnroll&#40;&#41;	-	         786.18<br />5.  buliaNaza&#40;&#41;	-	         412.78<br />--------------------------------------------------------------<br />Best fn&#58;<br />&#91;b&#93; JensDuttke&#40;&#41;&#91;/b&#93; by a difference of 40.55<br />--------------------------------------------------------------<br /><br /><br />--------------------------------------------------------------<br />&#91;b&#93;Test 3 - Readiness&#91;/b&#93;<br />String is 256 bytes long.<br />--------------------------------------------------------------<br />1.    lstrlen&#40;&#41;	-	           6.40<br />2. JensDuttke&#40;&#41;	-	           5.31<br />3.      iblis&#40;&#41;	-	           5.31<br />4.BScanUnroll&#40;&#41;	-	           5.33<br />5.  buliaNaza&#40;&#41;	-	           5.32<br />--------------------------------------------------------------<br />Best fn&#58; &#91;b&#93;Tie - see results&#91;/b&#93;<br />--------------------------------------------------------------<br /><br /><br />--------------------------------------------------------------<br />&#91;b&#93;Test 4 - Overhead&#91;/b&#93;<br />String is 0 bytes long.<br />--------------------------------------------------------------<br />1.    lstrlen&#40;&#41;	-	           3.22<br />2. JensDuttke&#40;&#41;	-	           4.25<br />3.      iblis&#40;&#41;	-	           3.23<br />4.BScanUnroll&#40;&#41;	-	           3.21<br />5.  buliaNaza&#40;&#41;	-	           4.25<br />--------------------------------------------------------------<br />Best fn&#58;<br />&#91;b&#93;BScanUnroll&#40;&#41;&#91;/b&#93; by a difference of 0.00<br />--------------------------------------------------------------<br /><br /><br />--------------------------------------------------------------<br />&#91;b&#93;Test 5 - Search Stress&#91;/b&#93;<br />String is 65536 bytes long, functions called 100 times.<br />--------------------------------------------------------------<br />1.    lstrlen&#40;&#41;	-	       67959.49<br />2. JensDuttke&#40;&#41;	-	       35184.05<br />3.      iblis&#40;&#41;	-	       41784.55<br />4.BScanUnroll&#40;&#41;	-	       50482.14<br />5.  buliaNaza&#40;&#41;	-	       41887.96<br />--------------------------------------------------------------<br />Best fn&#58;<br />&#91;b&#93; JensDuttke&#40;&#41;&#91;/b&#93; by a difference of 6600.50<br />--------------------------------------------------------------<br /><br /><br />--------------------------------------------------------------<br />&#91;b&#93;Test 6 - Hash Strain&#91;/b&#93;<br />String is 256 bytes long, functions called 1000 times.<br />--------------------------------------------------------------<br />1.    lstrlen&#40;&#41;	-	        3113.59<br />2. JensDuttke&#40;&#41;	-	        1516.76<br />3.      iblis&#40;&#41;	-	        1710.88<br />4.BScanUnroll&#40;&#41;	-	        2183.48<br />5.  buliaNaza&#40;&#41;	-	        1873.11<br />--------------------------------------------------------------<br />Best fn&#58;<br />&#91;b&#93; JensDuttke&#40;&#41;&#91;/b&#93; by a difference of 193.11<br />--------------------------------------------------------------<br /><br /><br />--------------------------------------------------------------<br />&#91;b&#93;Test 7 - Iterative Persistence&#91;/b&#93;<br />String is 16 bytes long, functions called 1,000,000 times.<br />--------------------------------------------------------------<br />1.    lstrlen&#40;&#41;	-	      439857.09<br />2. JensDuttke&#40;&#41;	-	      197054.92<br />3.      iblis&#40;&#41;	-	      156195.21<br />4.BScanUnroll&#40;&#41;	-	      177383.43<br />5.  buliaNaza&#40;&#41;	-	      187797.31<br />--------------------------------------------------------------<br />Best fn&#58;<br />&#91;b&#93;      iblis&#40;&#41;&#91;/b&#93; by a difference of 21187.22<br />--------------------------------------------------------------<br /><br /><br />--------------------------------------------------------------<br />&#91;b&#93;Test 8 - Super Test&#91;/b&#93;<br />String is 1,048,576 bytes long, functions called 100 times.<br />--------------------------------------------------------------<br />1.    lstrlen&#40;&#41;	-	     2177994.67<br />2. JensDuttke&#40;&#41;	-	     1677631.94<br />3.      iblis&#40;&#41;	-	     1812873.57<br />4.BScanUnroll&#40;&#41;	-	     1928963.20<br />5.  buliaNaza&#40;&#41;	-	     1809566.89<br />--------------------------------------------------------------<br />Best fn&#58;<br />&#91;b&#93; JensDuttke&#40;&#41;&#91;/b&#93; by a difference of 131935.95<br />--------------------------------------------------------------<br /><br /><br /><br />&#91;color=red&#93;Running the same tests for non-aligned data....<br /><br />--------------------------------------------------------------<br />&#91;b&#93;Test 1 - Endurance&#91;/b&#93;<br />String is 16,777,216 bytes long.<br />--------------------------------------------------------------<br />1.    lstrlen&#40;&#41;	-	      349326.91<br />2. JensDuttke&#40;&#41;	-	      289607.49<br />3.      iblis&#40;&#41;	-	      269065.58<br />4.BScanUnroll&#40;&#41;	-	      308322.13<br />5.  buliaNaza&#40;&#41;	-	      288883.21<br />--------------------------------------------------------------<br />Best fn&#58;<br />&#91;b&#93;      iblis&#40;&#41;&#91;/b&#93; by a difference of 19818.62<br />--------------------------------------------------------------<br />--------------------------------------------------------------<br />&#91;b&#93;Test 2 - Practicality&#91;/b&#93;<br />String is 65536 bytes long.<br />--------------------------------------------------------------<br />1.    lstrlen&#40;&#41;	-	         655.97<br />2. JensDuttke&#40;&#41;	-	         352.01<br />3.      iblis&#40;&#41;	-	         352.05<br />4.BScanUnroll&#40;&#41;	-	         499.19<br />5.  buliaNaza&#40;&#41;	-	         410.64<br />--------------------------------------------------------------<br />Best fn&#58;<br />&#91;b&#93; JensDuttke&#40;&#41;&#91;/b&#93; by a difference of 0.03<br />--------------------------------------------------------------<br />--------------------------------------------------------------<br />&#91;b&#93;Test 3 - Readiness&#91;/b&#93;<br />String is 256 bytes long.<br />--------------------------------------------------------------<br />1.    lstrlen&#40;&#41;	-	           6.41<br />2. JensDuttke&#40;&#41;	-	           4.30<br />3.      iblis&#40;&#41;	-	           5.31<br />4.BScanUnroll&#40;&#41;	-	           5.33<br />5.  buliaNaza&#40;&#41;	-	           5.32<br />--------------------------------------------------------------<br />Best fn&#58;<br />&#91;b&#93; JensDuttke&#40;&#41;&#91;/b&#93; by a difference of 0.01<br />--------------------------------------------------------------<br />--------------------------------------------------------------<br />&#91;b&#93;Test 4 - Overhead&#91;/b&#93;<br />String is 0 bytes long.<br />--------------------------------------------------------------<br />1.    lstrlen&#40;&#41;	-	           3.23<br />2. JensDuttke&#40;&#41;	-	           3.19<br />3.      iblis&#40;&#41;	-	           3.21<br />4.BScanUnroll&#40;&#41;	-	           3.20<br />5.  buliaNaza&#40;&#41;	-	           3.21<br />--------------------------------------------------------------<br />Best fn&#58;<br />&#91;b&#93; JensDuttke&#40;&#41;&#91;/b&#93; by a difference of 0.01<br />--------------------------------------------------------------<br />--------------------------------------------------------------<br />&#91;b&#93;Test 5 - Search Stress&#91;/b&#93;<br />String is 65536 bytes long, functions called 100 times.<br />--------------------------------------------------------------<br />1.    lstrlen&#40;&#41;	-	       67293.83<br />2. JensDuttke&#40;&#41;	-	       33682.14<br />3.      iblis&#40;&#41;	-	       33301.32<br />4.BScanUnroll&#40;&#41;	-	       51075.24<br />5.  buliaNaza&#40;&#41;	-	       41414.42<br />--------------------------------------------------------------<br />Best fn&#58;<br />&#91;b&#93;      iblis&#40;&#41;&#91;/b&#93; by a difference of 381.81<br />--------------------------------------------------------------<br />--------------------------------------------------------------<br />&#91;b&#93;Test 6 - Hash Strain&#91;/b&#93;<br />String is 256 bytes long, functions called 1000 times.<br />--------------------------------------------------------------<br />1.    lstrlen&#40;&#41;	-	        3267.24<br />2. JensDuttke&#40;&#41;	-	        1509.32<br />3.      iblis&#40;&#41;	-	        1498.67<br />4.BScanUnroll&#40;&#41;	-	        2047.98<br />5.  buliaNaza&#40;&#41;	-	        1732.25<br />--------------------------------------------------------------<br />Best fn&#58;<br />&#91;b&#93;      iblis&#40;&#41;&#91;/b&#93; by a difference of 10.64<br />--------------------------------------------------------------<br />--------------------------------------------------------------<br />&#91;b&#93;Test 7 - Iterative Persistence&#91;/b&#93;<br />String is 16 bytes long, functions called 1,000,000 times.<br />--------------------------------------------------------------<br />1.    lstrlen&#40;&#41;	-	      439543.46<br />2. JensDuttke&#40;&#41;	-	      192216.50<br />3.      iblis&#40;&#41;	-	      151165.83<br />4.BScanUnroll&#40;&#41;	-	      176716.78<br />5.  buliaNaza&#40;&#41;	-	      183479.47<br />--------------------------------------------------------------<br />Best fn&#58;<br />&#91;b&#93;      iblis&#40;&#41;&#91;/b&#93; by a difference of 25551.95<br />--------------------------------------------------------------<br />--------------------------------------------------------------<br />&#91;b&#93;Test 8 - Super Test&#91;/b&#93;<br />String is 1,048,576 bytes long, functions called 100 times.<br />--------------------------------------------------------------<br />1.    lstrlen&#40;&#41;	-	     2181548.78<br />2. JensDuttke&#40;&#41;	-	     1808117.34<br />3.      iblis&#40;&#41;	-	     1682792.51<br />4.BScanUnroll&#40;&#41;	-	     1928479.98<br />5.  buliaNaza&#40;&#41;	-	     1800880.01<br />--------------------------------------------------------------<br />Best fn&#58;<br />&#91;b&#93;      iblis&#40;&#41;&#91;/b&#93; by a difference of 118087.49<br />--------------------------------------------------------------<br />&#91;/color&#93;&#91;/size&#93;</code></pre></div>
    <div class="meta">Posted on 2002-03-12 14:26:15 by iblis</div>
   </div>
   <div class="post" id="post-28630">
    <div class="subject"><a href="#post-28630">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Here's the program.  It's a console app.  The .bat simply just runs it, but redirects stdout to a file.</div>
    <div class="meta">Posted on 2002-03-12 14:30:41 by iblis</div>
   </div>
   <div class="post" id="post-28631">
    <div class="subject"><a href="#post-28631">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">hi!<br /><br />now i know : never say a code isn't more optimizable. :)<br />I just found a way to optimize my first code (posted by hutch) even more ... it's just one more jz, to split the last AND from the main loop. Compared to Agner Fogs and my &quot;original&quot; routine, this double the speed.<br /><br /><pre><code><br />strlen proc lpString&#58;DWORD<br />	mov	ecx, lpString<br /><br />	@@&#58;<br />		mov	eax, dword ptr &#91;ecx&#93;<br />		add	ecx, 4<br /><br />		lea	edx, &#91;eax - 01010101h&#93;<br />		xor	eax, edx<br />		and	eax, 80808080h<br />	jz	@B<br />		and	eax, edx<br />	jz	@B<br /><br />	bsf	edx, eax<br /><br />	sub	edx, 4<br />	shr	edx, 3<br /><br />	lea	eax, &#91;ecx + edx - 4&#93;<br />	sub	eax, lpString<br /><br />	ret<br />strlen endp<br /></code></pre><br /><br />It would be nice if someone, for whom my first routine worked slower or in the same speed as Agners, could test it again.<br /><br />Cu, Jens Duttke</div>
    <div class="meta">Posted on 2002-03-12 14:33:04 by Jens Duttke</div>
   </div>
   <div class="post" id="post-28632">
    <div class="subject"><a href="#post-28632">New strlen algorithm by Jens Duttke</a></div>
    <div class="body"><div class="quote"><br />Does that data have to be the same size as your cache? Wouldn't any data set &gt;= the size of your cache work? </div>Of course!  You only have to touch a byte to load the whole cacheline, too.  I would hope that people would do some research themselves to know the why and how. :)</div>
    <div class="meta">Posted on 2002-03-12 14:35:13 by bitRAKE</div>
   </div>
   <div class="post" id="post-28633">
    <div class="subject"><a href="#post-28633">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Good :). I was afraid there were some dark and secret reason to<br />use a dataset the exact size of your cache =). As for cache line size,<br />do any recent processors have size less than 32bytes? Otherwise<br />I'll just touch in 32byte increments and wont bother CPUIDing for<br />cache line size :).</div>
    <div class="meta">Posted on 2002-03-12 14:40:26 by f0dder</div>
   </div>
   <div class="post" id="post-28634">
    <div class="subject"><a href="#post-28634">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">One added note:   I had to modify the algos so that they matched the same calling convention as WinAPI lstrlen()...  meaning any algos that passed args through registers had to be changed to stack args.  This way I could keep a table of procs and just loop through them.<br /><br />Also because of __stdcall every ret became a ret 4.  So stack cleanup may very well have slanted the results.  (No,  I didn't add a stack enter/leave frame.  lpString was referenced in each proc as )</div>
    <div class="meta">Posted on 2002-03-12 14:44:13 by iblis</div>
   </div>
   <div class="post" id="post-28635">
    <div class="subject"><a href="#post-28635">New strlen algorithm by Jens Duttke</a></div>
    <div class="body"><div class="quote"><br />I was afraid there were some dark and secret reason to<br />use a dataset the exact size of your cache =).</div>There are no secrets - just unread paragraphs of the manual. :grin:</div>
    <div class="meta">Posted on 2002-03-12 14:50:34 by bitRAKE</div>
   </div>
   <div class="post" id="post-28637">
    <div class="subject"><a href="#post-28637">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Here's the program again with Jens optimisation.<br /><br /><br />Edit:  Added time-critical restraining per Jens' suggestion.   Also added Agner Fog's algorithm.<br /><br /><br />Again, this program is to test the algos under different conditions.   That way you can see which works best for large strings, small strings, long iterations, 1 iteration... etc...    This should help to do what BitRake suggested and figure out which works best for which situation.<br /><br />Output is formatted for vBcodes.</div>
    <div class="meta">Posted on 2002-03-12 14:55:50 by iblis</div>
   </div>
   <div class="post" id="post-28681">
    <div class="subject"><a href="#post-28681">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">I wonder what will rip a meg or so of sequential zero seperated strings to pieces in a hurry,<br /><pre><code><br />MyString db &quot;short string&quot;,0<br />         db &quot;longer string length&quot;,0<br />         db &quot;more unaligned zero terminated strings&quot;,0<br />; many more uneven length unaligned strings<br />         db 0,0    ; terminator<br /></code></pre><br />Assuming 4 8 16 32 byte alignment is convenient for testing optimum conditions but a bad assumption on messy data that occurs in a form like this.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-03-12 20:40:45 by hutch--</div>
   </div>
   <div class="post" id="post-28682">
    <div class="subject"><a href="#post-28682">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Assuming 4byte alignment is fine :). You should always get (at least)<br />that with dynamically allocated memory, and as for your own stuff...<br />just align the data properly :).</div>
    <div class="meta">Posted on 2002-03-12 20:45:10 by f0dder</div>
   </div>
   <div class="post" id="post-28685">
    <div class="subject"><a href="#post-28685">New strlen algorithm by Jens Duttke</a></div>
    <div class="body"><div class="quote">You can trust me, I tried nearly every possible way </div> <br /><br />No I can not. I don't trust anybody (including myself), but tests.<br />I've heard those &quot;trust&quot; words from bitRAKE, had I let him go with it he would have not written his intereting code ever.<br /><br />You obviously didn't check the second idea, it's clear from your post. Shall I do it for you?</div>
    <div class="meta">Posted on 2002-03-12 21:14:17 by The Svin</div>
   </div>
   <div class="post" id="post-28690">
    <div class="subject"><a href="#post-28690">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">f0dder,<br /><br />==============<br />Assuming 4byte alignment is fine . You should always get (at least) that with dynamically allocated memory, and as for your own stuff... just align the data properly .<br />==============<br /><br />This is fine with simple data where you can align the beginning but the example is one of the ways of storing lists of strings with just a zero as a seperator and a double zero terminator and the contents are of uneven lengths and misaligned.<br /><br />Now making a DWORD array of pointers is no big deal to do if you can scan the location of each zero and put it in the array but the scan will be unaligned in many of the results.<br /><br />This is why I always included 2 different algos in the MASM32 library, one to handle aligned data in single long reads and a byte scanner that could handle the messy stuff without endless stalls and a massive performance penalty.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-03-12 21:33:41 by hutch--</div>
   </div>
   <div class="post" id="post-28692">
    <div class="subject"><a href="#post-28692">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Jens Duttke:<br />Check it out (your last version with my idea #2)<br />BTW: for new stounes it may be worthy to align boundry of loop:<br /><pre><code><br />strlen proc lpString&#58;DWORD<br />	mov	eax, 1<br />; request CPU feature flags<br />	cpuid<br />; CPUID instruction	<br />;- Pre-Scan to align the string-start ----<br />	mov	ecx, lpString<br />	mov	eax, ecx	cmp<br />	byte ptr &#91;eax&#93;, 0<br />	je	done<br />	and	ecx, 0FFFFFFF8h<br />	add	ecx, 8<br />	sub	ecx, eax<br />	cmp	ecx, 8<br />	je	aligned<br />@@&#58;<br />	inc	eax<br />	cmp	byte ptr &#91;eax&#93;, 0<br />	je	done<br />	dec	ecx<br />	jnz	@B<br />aligned&#58;	mov	ecx, eax<br />	;-----------------------------------------<br />	test	edx, 800000h			; test bit 23 to see if MMX available<br />	jz	no_mmx				; jump if no MMX is available<br />		pxor	mm0, mm0<br />		@@&#58;<br />			movq	mm1, qword ptr &#91;ecx&#93;<br />			movq	mm2, qword ptr &#91;ecx + 8&#93;<br />			movq	mm3, qword ptr &#91;ecx + 16&#93;<br />			movq	mm4, qword ptr &#91;ecx + 24&#93;<br />			movq	mm5, qword ptr &#91;ecx + 32&#93;<br />			movq	mm6, qword ptr &#91;ecx + 40&#93;<br />			movq	mm7, qword ptr &#91;ecx + 48&#93; ;!<br />			pcmpeqb mm1, mm0<br />			pcmpeqb mm2, mm0<br />			pcmpeqb mm3, mm0<br />			pcmpeqb mm4, mm0<br />			pcmpeqb mm5, mm0<br />			pcmpeqb mm7, mm0 ;!<br />			pcmpeqb mm6, mm0<br />			pcmpeqb mm0,&#91;ecx+56&#93; ;!<br />			por	mm1, mm2<br />			por	mm3, mm4<br />			por	mm5, mm6<br />			por	mm7,mm0 ;!<br />			<br />			por	mm1,mm3<br />			por	mm5,mm7 ;!<br /><br />			por	mm1, mm5<br /><br />			add	ecx, 64<br />			packsswb mm1, mm1<br />		movd	eax, mm1<br />		test	eax, eax<br />		jz	@B<br />		sub	ecx, 64<br />		emms					; Empty MMX state<br />	no_mmx&#58;	@@&#58;<br />		mov	eax, dword ptr &#91;ecx&#93;<br />		add	ecx, 4<br />		lea	edx, &#91;eax - 01010101h&#93;<br />		xor	eax, edx<br />		and	eax, 80808080h<br />		and	eax, edx<br />		jz	@B<br />		bsf	edx, eax<br />		sub	edx, 4<br />		shr	edx, 3<br />		lea	eax, &#91;ecx + edx - 4&#93;<br />	done&#58;	sub	eax, lpString<br />	ret<br />strlen endp<br /></code></pre></div>
    <div class="meta">Posted on 2002-03-12 21:48:38 by The Svin</div>
   </div>
   <div class="post" id="post-28696">
    <div class="subject"><a href="#post-28696">New strlen algorithm by Jens Duttke</a></div>
    <div class="body"><div class="quote"><br />No I can not. I don't trust anybody (including myself), but tests.<br />I've heard those &quot;trust&quot; words from bitRAKE, had I let him go with it he would have not written his intereting code ever.</div>I also didn't think an unrolled byte scanner would be so good on uncached data - I wrote it, I tested it, wow!  I'm using it.  Or, rather a general version that scans for the byte in AL.</div>
    <div class="meta">Posted on 2002-03-12 22:03:36 by bitRAKE</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=4058&amp;page=1" style="">&laquo;</a><a href="../?id=4058&amp;page=4" style="">&lt;</a><input type="hidden" name="id" value="4058" /><input type="number" name="page" min="1" max="9" step="1" value="5" onchange="this.form.submit();" /><a href="../?id=4058&amp;page=6">&gt;</a><a href="../?id=4058&amp;page=9">&raquo;</a></form>  </div>
 </body>
</html>