<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>New strlen algorithm by Jens Duttke - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4058" />
  <link rel="prev" href="../?id=4058&amp;page=2" />  <link rel="next" href="../?id=4058&amp;page=4" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=4058">New strlen algorithm by Jens Duttke</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=4058&amp;page=1" style="">&laquo;</a><a href="../?id=4058&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="4058" /><input type="number" name="page" min="1" max="9" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=4058&amp;page=4">&gt;</a><a href="../?id=4058&amp;page=9">&raquo;</a></form>   <div class="post" id="post-28140">
    <div class="subject"><a href="#post-28140">re:</a></div>
    <div class="body">This is my first post here, so a quick introduction: Hi.<br /><br />Okay,<br />I know very little about optimisation, and I haven't coded pure intel assembly since the days of real mode and 286s, so pardon my ignorance here...<br /><br />I'm just curious how a strlen() implimentation using REPNZ SCASB would fare in a benchmark.  I'm guessing not very well.<br /><br /><br />-ib</div>
    <div class="meta">Posted on 2002-03-10 06:50:09 by iblis</div>
   </div>
   <div class="post" id="post-28143">
    <div class="subject"><a href="#post-28143">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">hi!<br /><br />I've just improved my algorithm a bit (it uses MMX now).<br />It's 2 times as fast as my first algorithm on long strings (at least on my P2). It will use the &quot;old&quot; algorithm if the processor does not support MMX ... so it will ever go the fastest way. :-)<br /><br /><pre><code><br />strlen proc lpString&#58;DWORD<br /><br />	;-------------------------------------------------------------------<br />	; Count the characters of a null terminated string.<br />	;-------------------------------------------------------------------<br />	; This procedure was written by Jens Duttke<br />	;----------------------------------------------------------------<br />	; The algorithm use the MMX technology. That means you need to use<br />	; .MMX and ML /Cp to compile the routine.<br />	; If the processor does not support MMX, the routine will use a<br />	; very fast algorithm to scan for the null terminator, and if MMX<br />	; is supported the routine will run more than 100 percent faster,<br />	; on large strings, using this technology.<br />	; NOTE &#58; If you use the FPU, MMX, SSE or SSE2 in your program, you<br />	; should save the state &#40;FXSAVE&#41; of them before you call this<br />	; routine and restore the state &#40;FXRSTOR&#41; after the routine.<br />	;-------------------------------------------------------------------<br /><br />	mov	eax, 1				; request CPU feature flags<br />	cpuid						; CPUID instruction<br /><br />	mov	ecx, lpString<br /><br />	test	edx, 800000h			; test bit 23 to see if MMX available<br />	jz	no_mmx				; jump if no MMX is available<br />		pxor	mm0, mm0<br /><br />		@@&#58;<br />			movq	mm1, qword ptr &#91;ecx&#93;<br />			movq	mm2, qword ptr &#91;ecx + 8&#93;<br />			movq	mm3, qword ptr &#91;ecx + 16&#93;<br />			movq	mm4, qword ptr &#91;ecx + 24&#93;<br />			movq	mm5, qword ptr &#91;ecx + 32&#93;<br />			movq	mm6, qword ptr &#91;ecx + 40&#93;<br /><br />			pcmpeqb mm1, mm0<br />			pcmpeqb mm2, mm0<br />			pcmpeqb mm3, mm0<br />			pcmpeqb mm4, mm0<br />			pcmpeqb mm5, mm0<br />			pcmpeqb mm6, mm0<br /><br />			por	mm1, mm2<br />			por	mm3, mm4<br />			por	mm5, mm6<br />			por	mm1, mm3<br />			por	mm1, mm5<br /><br />			add	ecx, 48<br /><br />			packsswb mm1, mm1<br />		movd	eax, mm1<br />		test	eax, eax<br />		jz	@B<br /><br />		sub	ecx, 48<br /><br />		emms					; Empty MMX state<br />	no_mmx&#58;<br /><br />	@@&#58;<br />		mov	eax, dword ptr &#91;ecx&#93;<br />		add	ecx, 4<br /><br />		lea	edx, &#91;eax - 01010101h&#93;<br />		xor	eax, edx<br />		and	eax, 80808080h<br />		and	eax, edx<br />	jz	@B<br /><br />	bsf	edx, eax<br /><br />	sub	edx, 4<br />	shr	edx, 3<br /><br />	lea	eax, &#91;ecx + edx - 4&#93;<br />	sub	eax, lpString<br /><br />	ret<br />strlen endp<br /></code></pre><br /><br />PS. Since the algorithm read 48 Bytes &quot;at once&quot;, it would be worthless to test it with strings shorter than that. It's done for large strings (above 1KB, or better above 1MB).<br /><br />Cu, Jens Duttke<br />----<br /><a target="_blank" href="http://www.emucheater.com">http://www.emucheater.com</a><br /><a target="_blank" href="http://cyberpad.psxemu.com">http://cyberpad.psxemu.com</a></div>
    <div class="meta">Posted on 2002-03-10 07:19:16 by Jens Duttke</div>
   </div>
   <div class="post" id="post-28185">
    <div class="subject"><a href="#post-28185">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">hi!<br /><br />I've just done some tests, to compare the speed of different algorithms. Agner Fog's, the Byte Scan algorithms, the one from buliaNaza and mine. The tests runs on my Pentium 2 333 MHz.<br />I tested a string length from 1000 till 100000.<br />I noticed that bitRAKE tested also an algorithm from The Svin and himself. I wonder where i can get these algorithms (Are these the algorithms from the &quot;LongStringLen&quot; thread ? i tried some of them, but they aren't faster than the byte scanner on my PC, or are they optimized for AMD's Athlon ?)<br /><br />Cu, Jens Duttke<br />----<br /><a target="_blank" href="http://www.emucheater.com">http://www.emucheater.com</a><br /><a target="_blank" href="http://cyberpad.psxemu.com">http://cyberpad.psxemu.com</a></div>
    <div class="meta">Posted on 2002-03-10 14:05:11 by Jens Duttke</div>
   </div>
   <div class="post" id="post-28188">
    <div class="subject"><a href="#post-28188">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Hi <strong>Jens</strong>,<br />Yes, the MMX algos came from the LongStringLength thread.  I've been optimizing for the Athlon and it's very likely other CPUs will perform differently.  As long as your unrolling the MMX for speed, why go half way?  Try this:<pre><code>pxor mm0,mm0<br />pxor mm1,mm1<br />pxor mm2,mm2<br />pxor mm3,mm3<br />pxor mm4,mm4<br />pxor mm5,mm5<br />pxor mm6,mm6<br />pxor mm7,mm7<br /><br />@@&#58;	pcmpeqb mm0, qword ptr &#91;ecx&#93;<br />	pcmpeqb mm1, qword ptr &#91;ecx + 8&#93;<br />	pcmpeqb mm2, qword ptr &#91;ecx + 16&#93;<br />	pcmpeqb mm3, qword ptr &#91;ecx + 24&#93;<br />	pcmpeqb mm4, qword ptr &#91;ecx + 32&#93;<br />	pcmpeqb mm5, qword ptr &#91;ecx + 40&#93;<br />	pcmpeqb mm6, qword ptr &#91;ecx + 48&#93;<br />	pcmpeqb mm7, qword ptr &#91;ecx + 56&#93;<br /><br />	por	mm0, mm1<br />	por	mm2, mm3<br />	por	mm4, mm5<br />	por	mm6, mm7<br />	por	mm0, mm2<br />	por	mm4, mm6<br />	por	mm0, mm4<br /><br />	add	ecx, 64<br />	packsswb mm0, mm0<br />	movd	eax, mm0<br />	test	eax, eax<br />	jz	@B<br /><br />	sub	ecx, 64<br />	emms	; Empty MMX state</code></pre>This will tackle a whole cache line at once on the Athlon.</div>
    <div class="meta">Posted on 2002-03-10 14:29:39 by bitRAKE</div>
   </div>
   <div class="post" id="post-28195">
    <div class="subject"><a href="#post-28195">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">hi!<br /><br />I don't know why, but if I use pcmpeqb with the memory directly the code is 14% slower on my computer ... with movq it's faster ...<br /><br />Cu, Jens Duttke<br />----<br /><a target="_blank" href="http://www.emucheater.com">http://www.emucheater.com</a><br /><a target="_blank" href="http://cyberpad.psxemu.com">http://cyberpad.psxemu.com</a></div>
    <div class="meta">Posted on 2002-03-10 15:16:06 by Jens Duttke</div>
   </div>
   <div class="post" id="post-28196">
    <div class="subject"><a href="#post-28196">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">iblis,<br /><br />Hi and welcome to the forum. REPNZ SCASB will vary a considerable amount from machine to machine. On later Intel hardware it is a long way off the pace and it seems to be because Intel have not bothered to update the older string instructions. Usually incrementing pointers through an index is faster with normal integer instructions.<br /><br />The MMX examples take advantage of being able to handle larger blocks of data at a time and it shows with the benchmarks if the machine is compatible with MMX.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-03-10 15:17:43 by hutch--</div>
   </div>
   <div class="post" id="post-28243">
    <div class="subject"><a href="#post-28243">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Thanks!   I think it's interesting how one has use little tweaks and convoluted coding methods in order to get a CPU to do what you want.<br /><br />Typically I'm a C person, but will use inline asm when I'm bored.  ( MS's __declspec( naked ) is a great directive ;) )   My only gripe about assembler is that it's not very portable.<br /><br />Because I don't know any better, if I had to write my own asm version of strlen it'd probably look something like:<br /><br />--------------------------------<br />strlen proc strPtr:DWORD<br /><br />mov edi, strPtr<br />mov ecx, 0FFFFFFFFh<br />xor eax, eax<br />repnz scasb<br />mov eax, ecx<br />not eax<br />dec eax<br />ret<br /><br />strlen endp<br />--------------------------------<br /><br />It might be slow, but it's relatively small.  (I prefer size to speed)<br />Er.. well.. I *think* that would work, for strings smaller than 4gb anyway.  For Windows you would probably have to push edi then pop it before ret.  I think I remember reading somewhere that Windows might become unstable if you modify edi, esi, and ebx.  I don't know if that's true.<br /><br />Great forum you have here!  From what I've seen it's fairly civil.  Most programming forums and chatrooms I've come across are filled to the brim with &quot;31337 h4x0rz&quot; who are constantly fighting over why Visual Basic is the best language, or how to &quot;m4ke a k3wl ICMP bomb0r pr0ggy&quot; or something stupid like that.<br /><br />-ib</div>
    <div class="meta">Posted on 2002-03-10 23:57:55 by iblis</div>
   </div>
   <div class="post" id="post-28268">
    <div class="subject"><a href="#post-28268">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">iblis,<br /><br />This is why we have a &quot;crusades&quot; forum so that anyone can put forward any crackpot theory they like with more or less impunity. It keeps the invective out of the main forum and specialised areas most of the time and keeps everyone happy as well.<br /><br />Glad you like the place, we are lucky we have a secret formula for membership, only HUMAN BEINGS are allowed to join so it works well most of the time.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-03-11 03:20:52 by hutch--</div>
   </div>
   <div class="post" id="post-28269">
    <div class="subject"><a href="#post-28269">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">hi!<br /><br />I've tried the different algorithms at work now, on a P3 800 MHz, and it still seems that my algo's are faster compared to Agners. (The MMX algo is even the fastest.) I don't know why bitRAKE, get such a &quot;bad result&quot; with them ... maybe it's because the code works slower on the Athlon ?!?<br /><br /><img src="http://www.emucheater.com/compare.gif" /> <br /><br />Cu, Jens Duttke<br />----<br /><a target="_blank" href="http://www.emucheater.com">http://www.emucheater.com</a><br /><a target="_blank" href="http://cyberpad.psxemu.com">http://cyberpad.psxemu.com</a></div>
    <div class="meta">Posted on 2002-03-11 03:21:49 by Jens Duttke</div>
   </div>
   <div class="post" id="post-28272">
    <div class="subject"><a href="#post-28272">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Jens,<br /><br />It usually has to do with processor variations. BiTRAKE mainly writes for his AMD box which has different characteristics to later Intel hardware.<br /><br />I have found this myself when I try to get algorithms to work across different processors. You can get something to work fine on one but it performs badly on some others and what you have to do to get code to work OK on all of them is to keep testing variations and select the best averages.<br /><br />ts one of the things that drives you NUTZ.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-03-11 03:40:07 by hutch--</div>
   </div>
   <div class="post" id="post-28275">
    <div class="subject"><a href="#post-28275">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">hii<br /><br /> about buliaNaza's code <br /><br /><pre><code><br />mov	eax, &#91;edx&#93;		;u get  a dword &#40;buffer is aligned&#41;<br />        add     edx, 4                  ;v ready for next <br /> 	mov	ecx, eax		;u save it in ecx<br /> 	sub	eax, 1010101h		;v sub 1 from each byte in eax<br /> 	and	eax, 80808080h		;u test  sign  <br />        jz      SLloop      <br /></code></pre><br /> <br /><br />to <br /> <pre><code><br />   mov ecx,&#91;edx&#93;<br />   add edx,4<br />   lea eax,&#91;ecx-1010101h&#93;<br />   and eax, 80808080h<br />jz SLloop<br /><br /></code></pre></div>
    <div class="meta">Posted on 2002-03-11 03:44:48 by eko</div>
   </div>
   <div class="post" id="post-28292">
    <div class="subject"><a href="#post-28292">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Wow looks like my algo really is the slowest.  :x   I thought it would at least be a tad faster than lstrlen.<br /><br />Well that's good to know should I ever come across a situation where I need to repetitively find the length of a 90mb string.<br /><br />Interesting stuff.</div>
    <div class="meta">Posted on 2002-03-11 06:23:55 by iblis</div>
   </div>
   <div class="post" id="post-28295">
    <div class="subject"><a href="#post-28295">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Hmm... I think I use buliaNaza's Algo for my SHA code. <br />It's not the fastest, but I want to understand the code I use. <br />And I don't know any MMX stuff :( <br /><br />regards,<br />bAZiK<br /><br /><br />P.S: buliaNaza, I'll credit you in the SHA source and my mail client where I use this code. Thanks again for sharing!</div>
    <div class="meta">Posted on 2002-03-11 06:32:02 by bazik</div>
   </div>
   <div class="post" id="post-28300">
    <div class="subject"><a href="#post-28300">New strlen algorithm by Jens Duttke</a></div>
    <div class="body"><div class="quote">Hmm... I think I use buliaNaza's Algo for my SHA code. <br />It's not the fastest, but I want to understand the code I use. <br /></div> <br /><br />amm... on my pc buliaNaza's run as fast as anger , and jens codes<br />but with afew fixes<br /><br /><pre><code><br />;use mov esi,offset string <br />;call strlen<br /><br />strlen proc<br />xor edx,edx<br />@@&#58;<br />   mov ecx,&#91;edx+esi&#93;<br />   add edx,4<br />   lea eax,&#91;ecx-1010101h&#93;<br />   and	eax, 80808080h		;u test  sign  <br />   jz @B<br />                ;v <br />   test       al, 80H                ;u is zero?<br />   jnz	C_minus4		;v<br />   test       ah, 80H                 ;u is zero?<br />   jnz	C_minus3		;v<br />   and	eax, 0800000h		;u is zero?<br />   jnz	C_minus2		;v<br />   lea	eax, &#91;edx-1&#93;<br />   ret                             ;<br />C_minus2&#58;				;<br />        lea     eax, &#91;edx-2&#93;        ;u eax= length of string<br />        ret                             ;<br />C_minus3&#58;				;<br />        lea     eax, &#91;edx-3&#93;        ;u eax= length of string<br />        ret                             ;<br />C_minus4&#58;				;<br />        lea     eax, &#91;edx-4&#93;        ;u eax= length of string<br />        ret<br />strlen endp<br /></code></pre><br /><br />EDIT: MORE CHANGES to the algo</div>
    <div class="meta">Posted on 2002-03-11 07:01:32 by eko</div>
   </div>
   <div class="post" id="post-28301">
    <div class="subject"><a href="#post-28301">New strlen algorithm by Jens Duttke</a></div>
    <div class="body"><div class="quote"><br /> <br /><br />amm... on my pc buliaNaza's run as fast as anger , and jens codes<br />but with afew fixes<br /></div><br /><br /><br />Hmm... ok... looks nice :) <br />I can't test it here at work, but I'll do at home. <br />Seems like I need to credit you both, guys! :alright:</div>
    <div class="meta">Posted on 2002-03-11 07:09:14 by bazik</div>
   </div>
   <div class="post" id="post-28332">
    <div class="subject"><a href="#post-28332">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">hi!<br /><br />eko, compared to the other non-MMX-algorithms yours (and buliaNAZA's), seems to be the fastest on long strings, at least on my P2 (the picture).<br /><br />------<br /><br />I've improved my speed-test-routine and get a much more exact result now.<br /><br />All in all the result of the test ony my P2 333 MHz (128 MB RAM) with an 6000 Char-String is :<br /><br />1. Jens (MMX)<br />2. bitRAKE (MMX)<br />3. The Svin (MMX)<br />4. buliaNaza &amp; eko<br />5. Jens<br />6. Agner Fog<br />7. BScan 2<br />8. BScan<br />9. lstrlen<br />10.  iblis<br /><br />the result of a 160 char-string (i think that's the average for &quot;normal&quot; use) :<br /><br />1. Jens<br />2. bitRAKE (MMX) / Jens (MMX)<br />3. buliaNaza &amp; eko<br />4. Agner Fog<br />5. The Svin (MMX)<br />6. BScan / BScan 2<br />7. lstrlen<br />8. iblis<br /><br />btw. the horizontal bar is the string length (i tested from 5 to 6004 bytes), the vertical bar are the required time.<br /><br />Cu, Jens Duttke<br />----<br /><a target="_blank" href="http://www.emucheater.com">http://www.emucheater.com</a><br /><a target="_blank" href="http://cyberpad.psxemu.com">http://cyberpad.psxemu.com</a></div>
    <div class="meta">Posted on 2002-03-11 08:42:18 by Jens Duttke</div>
   </div>
   <div class="post" id="post-28336">
    <div class="subject"><a href="#post-28336">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">hi!<br /><br />I've done a new algorithm (based on my first one, without MMX), which use an really unusual system. The speed of the algorithm depends on the content of the string. For example if the complete string contains only numbers, the speed of the routine is faster than my MMX code (atleast on my P2). But if the string contains mostly different bytes the algorithm will be damn slow.<br />Maybe if someone just need to check a 1000 byte string, which contains only numbers or uppercase letters, this routine could be useful. ;) <br />For all others it's most likely damn useless.<br />(Maybe anyone has an idea to improve it.)<br /><br /><pre><code><br />strlen proc lpString&#58;DWORD<br /><br />	;-------------------------------------------------------------------<br />	; Count the characters of a null terminated string.<br />	;-------------------------------------------------------------------<br />	; This procedure was written by Jens Duttke<br />	;-------------------------------------------------------------------<br />	; This routine uses an unusual algorithm which read 16 bytes<br />	; &quot;per cycle&quot; from the memory and check it for the null-<br />	; terminator. The speed depends on the size and on the content of<br />	; the string. On large strings &#40;&gt; 1000 KB&#41; with &quot;mostly the same&quot;<br />	; content &#40;letters, numbers ...&#41; it's faster than my MMX algorithm,<br />	; but slightly slower on very short strings with different content.<br />	;-------------------------------------------------------------------<br /><br />	mov	ecx, lpString<br /><br />	@@&#58;<br />		mov	eax, dword ptr &#91;ecx&#93;<br />		and	eax, dword ptr &#91;ecx + 4&#93;<br />		and	eax, dword ptr &#91;ecx + 8&#93;<br />		and	eax, dword ptr &#91;ecx + 12&#93;<br />		add	ecx, 16<br /><br />		lea	edx, &#91;eax - 01010101h&#93;<br />		xor	eax, edx<br />		and	eax, 80808080h<br />		and	eax, edx<br />	jz	@B<br /><br />	sub	ecx, 16<br /><br />	;--------<br />		mov	eax, dword ptr &#91;ecx&#93;<br />		add	ecx, 4<br /><br />		lea	edx, &#91;eax - 01010101h&#93;<br />		xor	eax, edx<br />		and	eax, 80808080h<br />		and	eax, edx<br />		jnz	@F<br />	;--------<br />		mov	eax, dword ptr &#91;ecx&#93;<br />		add	ecx, 4<br /><br />		lea	edx, &#91;eax - 01010101h&#93;<br />		xor	eax, edx<br />		and	eax, 80808080h<br />		and	eax, edx<br />		jnz	@F<br />	;--------<br />		mov	eax, dword ptr &#91;ecx&#93;<br />		add	ecx, 4<br /><br />		lea	edx, &#91;eax - 01010101h&#93;<br />		xor	eax, edx<br />		and	eax, 80808080h<br />		and	eax, edx<br />		jnz	@F<br />	;--------<br />		mov	eax, dword ptr &#91;ecx&#93;<br />		add	ecx, 4<br /><br />		lea	edx, &#91;eax - 01010101h&#93;<br />		xor	eax, edx<br />		and	eax, 80808080h<br />		and	eax, edx<br />		jz	@B<br />	;--------<br />	@@&#58;<br /><br />	bsf	edx, eax<br /><br />	sub	edx, 4<br />	shr	edx, 3<br /><br />	lea	eax, &#91;ecx + edx - 4&#93;<br />	sub	eax, lpString<br /><br />	ret<br />strlen endp<br /></code></pre><br /><br />Cu, Jens Duttke<br />----<br /><a target="_blank" href="http://www.emucheater.com">http://www.emucheater.com</a><br /><a target="_blank" href="http://cyberpad.psxemu.com">http://cyberpad.psxemu.com</a></div>
    <div class="meta">Posted on 2002-03-11 09:04:32 by Jens Duttke</div>
   </div>
   <div class="post" id="post-28350">
    <div class="subject"><a href="#post-28350">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">here is another version . i must go . so i dnot have time to check it <br /><br /><br /><pre><code><br />StrLen proc lpString&#58;DWORD<br />xor edx,edx<br />@@&#58;<br />;   add edx,4<br />   add edx,4<br />   mov ecx,&#91;edx+esi-4&#93;<br />   mov ebx,&#91;edx+esi&#93; ; i need to to this ever time expect the last ,   so at least i dont have a stall i think <br />   lea eax,&#91;ecx-1010101h&#93;<br />   and eax, 80808080h<br />   jnz @F<br />   lea eax,&#91;ebx-1010101h&#93;<br />   and eax, 80808080h<br />   jz @B<br /><br />   add edx,4<br />@@&#58;<br />                             ;v <br />   test    al, 80h                ;u is zero?<br />   jnz	C_minus4		;v<br />   test    ah, 80h                 ;u is zero?<br />   jnz	C_minus3		;v<br />   and	eax, 00800000h		;u is zero?<br />   jnz	C_minus2		;v<br />   lea	eax, &#91;edx-1&#93;<br />   ret                             ;<br />C_minus2&#58;				;<br />        lea     eax, &#91;edx-2&#93;        ;u eax= length of string<br />        ret                             ;<br />C_minus3&#58;				;<br />        lea     eax, &#91;edx-3&#93;        ;u eax= length of string<br />        ret                             ;<br />C_minus4&#58;				;<br />        lea     eax, &#91;edx-4&#93;        ;u eax= length of string<br />        ret<br /><br />StrLen endp<br /><br /></code></pre></div>
    <div class="meta">Posted on 2002-03-11 11:46:32 by eko</div>
   </div>
   <div class="post" id="post-28413">
    <div class="subject"><a href="#post-28413">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Hi, eko<br />I agree with you because I have the same variants but:<br /><br />THIS IS A NON WORKING VARIANT FOR THE STRING WITH ASCII CHARACTERS  = OR &gt; 80h!!!<br /><br />So, it is easy to cut the code to improve the speed but you lose the universality...</div>
    <div class="meta">Posted on 2002-03-11 15:50:02 by buliaNaza</div>
   </div>
   <div class="post" id="post-28418">
    <div class="subject"><a href="#post-28418">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Yeah I'd be interested to see a super fast  .486p strlen that tests exclusively for the null terminator.<br /><br />I'll give it a shot.  It should only take me about 4 years to finish.  :x</div>
    <div class="meta">Posted on 2002-03-11 15:58:26 by iblis</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=4058&amp;page=1" style="">&laquo;</a><a href="../?id=4058&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="4058" /><input type="number" name="page" min="1" max="9" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=4058&amp;page=4">&gt;</a><a href="../?id=4058&amp;page=9">&raquo;</a></form>  </div>
 </body>
</html>