<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>New strlen algorithm by Jens Duttke - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4058" />
  <link rel="prev" href="../?id=4058&amp;page=3" />  <link rel="next" href="../?id=4058&amp;page=5" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=4058">New strlen algorithm by Jens Duttke</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=4058&amp;page=1" style="">&laquo;</a><a href="../?id=4058&amp;page=3" style="">&lt;</a><input type="hidden" name="id" value="4058" /><input type="number" name="page" min="1" max="9" step="1" value="4" onchange="this.form.submit();" /><a href="../?id=4058&amp;page=5">&gt;</a><a href="../?id=4058&amp;page=9">&raquo;</a></form>   <div class="post" id="post-28491">
    <div class="subject"><a href="#post-28491">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Do this mean that the original Jens Duttke StrLen ( the First one that Hutch like ) is the fastest or darn close on a plain 386 - P200..... if i was only using strings between the size of 128 - 1000 bytes.  Thats all i will EVER need...<br /><br />Also where do you get a string speed tester from...</div>
    <div class="meta">Posted on 2002-03-11 21:59:37 by cmax</div>
   </div>
   <div class="post" id="post-28492">
    <div class="subject"><a href="#post-28492">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Somebody write the fastest for 0-127 characters without the use<br />of MMX or any &gt;plain586(or 486 ;)) opcodes that doesn't have to<br />read past the end of the actual string... :)</div>
    <div class="meta">Posted on 2002-03-11 22:05:07 by f0dder</div>
   </div>
   <div class="post" id="post-28506">
    <div class="subject"><a href="#post-28506">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Ok We need to make a chart for future notice :-)<br /><br />Fastest Code for Strings 0 - 80 bytes<br />Fastest Code for Strings 80 - 160 bytes<br />Fastest Code for Strings 160 - 1000 bytes <br />Fastest Code for Strings 1000 - 9000 bytes<br />Fastest Code for Strings 9000 - 100k+ bytes<br /><br />I guess this may be a stupid questions but can you do somethng like this?<br /><br />use one string scan technique up to 80 bytes then another one up to 160 bytes then switch to another one if it's over 1000 bytes and so on?<br /><br />sorta like<br /><br />cmp ecx, 160<br />ja SwitchStringScanTechnique<br /><br />Sliver</div>
    <div class="meta">Posted on 2002-03-12 00:38:16 by Sliver</div>
   </div>
   <div class="post" id="post-28519">
    <div class="subject"><a href="#post-28519">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">hi!<br /><br />For sure, that would be possible ... but i don't want to flood the server with thousands of chars. :grin: <br /><br />I got an better idea ... I simply attach my test program, so everybody can use the same test on his computer.<br />The program will generate a file called table.txt in the program directory.<br />This file can be easily imported in MS Excel, and used to make charts from it, or compare the data directly.<br />It will take some seconds/minutes (depends on your computers speed). You should not run any other time-intensive processes in background and you should not move the mouse while it runs.<br />After the program is done it will show a messagebox &quot;Done !&quot; ... while running it does not show anything.<br />The program will test a stringlength from 5 to 6004 bytes. I don't think that the result will be another with more than 6000 bytes.<br /><br />Your computer need to support a high-resolution timer.<br /><br />Cu, Jens Duttke<br />----<br /><a target="_blank" href="http://www.emucheater.com">http://www.emucheater.com</a><br /><a target="_blank" href="http://cyberpad.psxemu.com">http://cyberpad.psxemu.com</a></div>
    <div class="meta">Posted on 2002-03-12 02:02:14 by Jens Duttke</div>
   </div>
   <div class="post" id="post-28524">
    <div class="subject"><a href="#post-28524">New strlen algorithm by Jens Duttke</a></div>
    <div class="body"><div class="quote"><br />Somebody write the fastest for 0-127 characters without the use<br />of MMX or any &gt;plain586(or 486 ;)) opcodes that doesn't have to<br />read past the end of the actual string... :) </div><br /><br /><br />Yeah, wouldn't it be possible to generate some kind of memory fault if you try to read 1-3 more bytes than you've alloc'ed?</div>
    <div class="meta">Posted on 2002-03-12 03:18:29 by iblis</div>
   </div>
   <div class="post" id="post-28538">
    <div class="subject"><a href="#post-28538">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">hi!<br /><br />A friend tested the algorithms on his Athlon 1.4 GHz, 256 MB DDR-RAM.<br /><br />And the result is this :<br /><br />160 Byte String :<br /><br />1. Jens (MMX)<br />2. bitRAKE (MMX)<br />3. Agner Fog<br />4. buliaNaza &amp; eko / The Svin (MMX) / Jens<br />5. BScan 2<br />6. BScan<br />7. lstrlen<br />8. iblis<br /><br />6000 Byte String :<br /><br />1. Jens (MMX)<br />2. The Svin (MMX)<br />3. bitRAKE (MMX)<br />4. Agner Fog<br />5. Jens<br />6. buliaNaza &amp; eko<br />7. BScan 2<br />8. BScan <br />9. lstrlen<br />10. iblis<br /><br />Seems like fast code on the P2/P3 is also fast on the Athlon ... there aren't much differences in the result.<br /><br />Cu, Jens Duttke<br />----<br /><a target="_blank" href="http://www.emucheater.com">http://www.emucheater.com</a><br /><a target="_blank" href="http://cyberpad.psxemu.com">http://cyberpad.psxemu.com</a></div>
    <div class="meta">Posted on 2002-03-12 05:25:06 by Jens Duttke</div>
   </div>
   <div class="post" id="post-28546">
    <div class="subject"><a href="#post-28546">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Okay I gave it a shot.  So far my tests show this one to be pretty fast.  On my AMD Athlon 750 I got these arbitrary values:<br /><pre><code>myNewStrlen&#40;&#41;		...5167740<br /><br />JensNonMMX&#40;&#41;		...4985968<br />ByteScan&#40;&#41;		..12023752<br />REPNZ_SCASB&#40;&#41;		..12029381<br />WinAPIstrlen&#40;&#41;		..15450739</code></pre><br /><br />To get those values I used QueryPerformanceCounter calls before and after calling each function 1 million times on a 1000 byte string.  Something like this:<br /><pre><code>&#91;size=9&#93;***begin pseudo-code***<br /><br />char* string = &quot;1000 bytes long.....-&gt;&quot;<br /><br />for&#40; each algorithm &#41;<br />&#123;<br />  QueryPerformanceCounter&#40;&#41;;<br />  for&#40; 0 - 1,000,000 &#41;<br />  &#123;<br />       strlen&#91; algo &#93;&#40; string &#41;;<br />  &#125;<br />  QueryPerformanceCounter&#40;&#41;;<br /><br />  printf&#40; &quot;Name of Algo&#58;%&quot;, &#40;perfcounter2 - perfcounter1&#41; &#41;;<br /><br />&#125;<br /><br />***end pseudo-code***&#91;/size&#93;</code></pre><br /><br /><br />So I didn't calculate ticks/sec or anything.  Still my strlen seemed fast.<br /><br /><br />Here's my new strlen:<br /><pre><code>&#91;color=blue&#93;&#91;b&#93;strlen proc lpString&#58;DWORD<br />		mov ecx, lpString<br />_slLoopBegin&#58;<br />		mov eax, dword ptr &#91;ecx&#93;<br />		add ecx, 4<br /><br />		test eax, 000000FFh<br />		  jz _slJmp3<br />		test eax, 0000FF00h<br />		  jz _slJmp2<br />		test eax, 00FF0000h<br />		  jz _slJmp1<br />		test eax, 0FF000000h<br />		  jnz _slLoopBegin<br /><br />		inc ecx<br />_slJmp1&#58;<br />		inc ecx<br />_slJmp2&#58;<br />		inc ecx<br />_slJmp3&#58;<br />		lea eax, &#91;ecx - 4&#93;<br />		sub eax, lpString<br />		ret<br />strlen endp&#91;/b&#93;&#91;/color&#93;</code></pre><br /><br />I don't know very much about optimisation, but I figured test/jmp would probably be a uv pair, since it's such a common thing.  Any ideas of how to optimise it?<br /><br />-ib</div>
    <div class="meta">Posted on 2002-03-12 07:02:18 by iblis</div>
   </div>
   <div class="post" id="post-28556">
    <div class="subject"><a href="#post-28556">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">hi!<br /><br />Nice routine ... faster than your first one. :grin: <br />But are you sure it needs only 34257 ? That would be unbelievable fast, compared to the other routines.<br />I've tested it on my P3 800 MHz, and the speed is between the Byte Scanner and Agners algorithm.<br /><br />btw. while testing you should also set the process priority to realtime, so that windows does not affect the testing.<br /><br />Cu, Jens Duttke<br />----<br /><a target="_blank" href="http://www.emucheater.com">http://www.emucheater.com</a><br /><a target="_blank" href="http://cyberpad.psxemu.com">http://cyberpad.psxemu.com</a></div>
    <div class="meta">Posted on 2002-03-12 07:51:26 by Jens Duttke</div>
   </div>
   <div class="post" id="post-28557">
    <div class="subject"><a href="#post-28557">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Yeah, Jens.   Sorry I got some numbers messed up. <br /><br /><br />I've edited the post to reflect the new values.</div>
    <div class="meta">Posted on 2002-03-12 07:59:52 by iblis</div>
   </div>
   <div class="post" id="post-28571">
    <div class="subject"><a href="#post-28571">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">iblis,<br /><br />Compliments, this is a lot better algorithm and its speed seems to be a lot better.<br /><br />Jens, Iblis is testing on an AMD machine that will give different timings to an Intel machine, especially the later ones.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-03-12 08:56:24 by hutch--</div>
   </div>
   <div class="post" id="post-28587">
    <div class="subject"><a href="#post-28587">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Now that we have several great algorithms, I think it is imporant to move the discussion on to finding the best general solution.  I do not mean to imply that it is a single one of these algorithms, but  I would like to reach an understanding of what properties would be favorable for a general solution.  Special situations could integrate a more custom string length function into their algorithm, so please try to ignore them for now.  In general: What is the average string length that one would call this function with?  What part of an algorithm would need a string length function?  What are some situations where one would need to know the length of a string?</div>
    <div class="meta">Posted on 2002-03-12 10:07:32 by bitRAKE</div>
   </div>
   <div class="post" id="post-28589">
    <div class="subject"><a href="#post-28589">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">A question about license. <br /><br />Since the strlen is a function that is used frequently a fast one could really help me to get some cycles back. <br /><br />However im on a comercial project, thus I wish to know if the authors can give permission to use the functions. I cannot give or promise monetary gain, but I can promise credit in the the credits screens.</div>
    <div class="meta">Posted on 2002-03-12 10:22:24 by dxantos</div>
   </div>
   <div class="post" id="post-28591">
    <div class="subject"><a href="#post-28591">New strlen algorithm by Jens Duttke</a></div>
    <div class="body"><strong>dxantos</strong>, <u>any</u> code I post here may be used comercially, or otherwise.  Credit in the project isn't so important to me right now, but if you could send me a letter on company letterhead that states you've used my code that would be awesome. :grin:</div>
    <div class="meta">Posted on 2002-03-12 11:17:59 by bitRAKE</div>
   </div>
   <div class="post" id="post-28593">
    <div class="subject"><a href="#post-28593">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Jens Duttke:<br />I had a look on your unrolled MMX algo.<br />There are two ways to improve it.<br />1. you can get rid of 6 pmovq instruction<br />   - Before loop pxor all mmx regs<br />   - In loop compare it to 8 memory locations<br />advantages: <br />   - 8x8=64 bytes check per iteration<br />   - no need for pmovq inside the loop<br />collecting the checking do the same way por+packsswb<br />2. minor change:<br />you can use mm7 and for parity check mm0 to memory<br />then por mm0 and mm7 with the rest before packsswb.<br /><br />I'm sure you can code and test the ideas without my help<br />Good luck.</div>
    <div class="meta">Posted on 2002-03-12 11:40:17 by The Svin</div>
   </div>
   <div class="post" id="post-28594">
    <div class="subject"><a href="#post-28594">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Generic strlen... well, most strings I juggle around &quot;generically&quot;<br />will not even be 256 bytes long. And most strings are pretty short,<br />probably 32 bytes or less. If you look at any windows app, the situation<br />will probably be very similar - a lot of rather small strings.<br /><br />So, for a generic strlen, I don't think it makes sense to optimize for<br />long string lengths, especially not if makes it slower for short strings<br />(and of course it makes sense to use another strlen when you know<br />you will be dealing with large strings). I think read up to 3-4 bytes<br />too much *can* be acceptable, considering alignment and typical program<br />layout. For a generic strlen, I don't think MMX should be used - there's<br />still a few people out there with pplain, and for short strings, would<br />MMX even be beneficial?<br /><br />Just my thoughts :)</div>
    <div class="meta">Posted on 2002-03-12 11:44:35 by f0dder</div>
   </div>
   <div class="post" id="post-28596">
    <div class="subject"><a href="#post-28596">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">hi!<br /><br />dxantos : I'd spend many hours in my code, I would be happy if someone would use it in his project, that show me that my work wasn't useless. :grin: <br /><br /><div class="quote"><br />Now that we have several great algorithms, I think it is imporant to move the discussion on to finding the best general solution.  I do not mean to imply that it is a single one of these algorithms, but  I would like to reach an understanding of what properties would be favorable for a general solution.  Special situations could integrate a more custom string length function into their algorithm, so please try to ignore them for now.  In general: What is the average string length that one would call this function with?  What part of an algorithm would need a string length function?  What are some situations where one would need to know the length of a string? </div><br /><br />That's true ... and i found a way to improve the speed of the most algorithms (especially the MMX ones.)<br />Since some people said, it will extremly improve the speed to align the string, i've done some tests with the different algorithms, and alignments from 4 to 12 ...<br /><br />The result is ... some algorithms like Agners or the lstrlen algorithm doesn't seems to be affected at all.<br /><br />Some other algorithms seems be slow downed, if the string address is not dividable through 4, like iblis or my non-MMX algorithm.<br /><br />And this is &quot;cool&quot; : the MMX algorithms, are much faster if the string is aligned to 8.<br />bitRAKEs works 37% faster, my MMX code 40%,  and The Svins 45%.<br /><br />Now i wonder, can i except, if the string is aligned to 8, that the code works on all systems faster. Or does that depends on the RAM-type/-speed, processor-type ?<br /><br />bitRAKE :<br />I think strlen is required everywhere, where people need to handle strings/user input. Since user input isn't normally longer than 256 bytes, directory names are also not longer than 256 bytes and i can't think of anything else, which could be longer, i would assume, the standard for string lengths is 40 for short strings, 160 for medium strings and 240 for long strings, so a algorithm should be fast in this range. I also think the test of 60 or 100 MB strings is a bit &quot;useless&quot;, since i really don't know a usage for strings like this (i think a book-writer will need years to write a text-string which is longer than 10 MB ;) )<br /><br />Cu, Jens Duttke</div>
    <div class="meta">Posted on 2002-03-12 11:52:43 by Jens Duttke</div>
   </div>
   <div class="post" id="post-28597">
    <div class="subject"><a href="#post-28597">New strlen algorithm by Jens Duttke</a></div>
    <div class="body"><div class="quote"><br />Generic strlen... well, most strings I juggle around &quot;generically&quot; will not even be 256 bytes long. And most strings are pretty short, probably 32 bytes or less. If you look at any windows app, the situation will probably be very similar - a lot of rather small strings.</div>From an algorithmic perspective, are these strings in the cache, or is string length the first operation performed on the string? (generally)</div>
    <div class="meta">Posted on 2002-03-12 11:55:22 by bitRAKE</div>
   </div>
   <div class="post" id="post-28600">
    <div class="subject"><a href="#post-28600">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">hi!<br /><br />bitRAKE :<br /><br />I don't know how much my processor can cache (i never thought about this.) but the code do this :<br /><br />start:<br />writing the string to the memory<br />test routine 1<br />test routine 2<br />test routine 3<br />...<br />increase the length and jump to start<br /><br />I am not sure if the string is cached ... but it seems like (or what ya think ?)<br />On the other side, if the processor really cache the string, this will also happen in a &quot;real&quot; program, because if i need the strlen routine, i've most like processed the string with another routine first.<br />But ... do you know a way to force the processor to &quot;uncache&quot; the string ? I am interested if this will affect the result.<br /><br /><div class="quote"><em>Originally posted by The Svin </em><br />Jens Duttke:<br />I had a look on your unrolled MMX algo.<br />There are two ways to improve it.<br /></div><br /><br />nope, there aren't. :grin: <br /><br /><div class="quote"><br />1. you can get rid of 6 pmovq instruction<br />   - Before loop pxor all mmx regs<br />   - In loop compare it to 8 memory locations<br />advantages: <br />   - 8x8=64 bytes check per iteration<br />   - no need for pmovq inside the loop<br />collecting the checking do the same way por+packsswb<br /></div><br /><br />I tried to use the pcmpeqb directly with the memory, and this is about 14% slower than my current way. (Don't ask why ... i don't understand that too, but it is ... (atleast on my P2))<br /><br />I also thought about it to read 64 bytes at once ... but there are 3 things :<br /><br />1. If the user use very short strings, this will slow down the execution much more, that it speedup the routine on fast strings ... because it need to read 16 bytes more ...<br />2. I already tried it, and it isn't really faster ... it's nearly the same speed<br />3. I am not sure, if it is really that good, to read such a high number of bytes past the string-end. Some people don't seems to like the idea to read past the end of the string. (Partial I think these guys are maybe right ... but currently i never had any problems with this.)<br /><br />You can trust me, I tried nearly every possible way (&quot;wasted&quot; some hours on it) to get the code as fast as possible. And as far as i see there isn't any way to do faster (for me on my P2) (only the stuff which i've written in my last post will improve the speed extremly ... so i will impliment that as soon as i clicked the &quot;Submit&quot; button :) )<br /><br />Cu, Jens Duttke</div>
    <div class="meta">Posted on 2002-03-12 12:08:55 by Jens Duttke</div>
   </div>
   <div class="post" id="post-28601">
    <div class="subject"><a href="#post-28601">New strlen algorithm by Jens Duttke</a></div>
    <div class="body">Most likely wont be in the cache. Alignment will probably be no better<br />than 4 bytes - but most strings ought to be 4byte aligned (C compilers<br />will do it automatically, asm programmers ought to align strings to<br />4byte boundary).<br /><br />So, I guess the goal is: fastest strlen for 4byte aligned zero-terminated<br />strings, string length from 1-256 chars (average around 20-40), reading<br />maximally 4 bytes past end of string, strings not in cache, compatible<br />with pplain (though speed optimizations should favour ppro+/athlon).<br /><br />:)</div>
    <div class="meta">Posted on 2002-03-12 12:11:44 by f0dder</div>
   </div>
   <div class="post" id="post-28605">
    <div class="subject"><a href="#post-28605">New strlen algorithm by Jens Duttke</a></div>
    <div class="body"><div class="quote"><br />So, I guess the goal is: fastest strlen for 4byte aligned zero-terminated strings, string length from 1-256 chars (average around 20-40), reading maximally 4 bytes past end of string, strings not in cache, compatible with pplain (though speed optimizations should favour ppro+/athlon).</div>On the Athlon this critria results in the unrolled bscan8 I posted above, but I don't know how this performs on pplain, P2, P3, P4?  Unrolling less/further will move the bumps in the graph around.  The P4 has larger penalties for branch miss, so I'm assuming the bumps will be bigger on P4.  Alignment will improve preformance based on cacheline size (ie 64 bytes on athlon).</div>
    <div class="meta">Posted on 2002-03-12 12:22:03 by bitRAKE</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=4058&amp;page=1" style="">&laquo;</a><a href="../?id=4058&amp;page=3" style="">&lt;</a><input type="hidden" name="id" value="4058" /><input type="number" name="page" min="1" max="9" step="1" value="4" onchange="this.form.submit();" /><a href="../?id=4058&amp;page=5">&gt;</a><a href="../?id=4058&amp;page=9">&raquo;</a></form>  </div>
 </body>
</html>