<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>An Alternative to Nasty EXE Servers - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=6521" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=116">Windows</a> &raquo; <a href="../?id=6521">An Alternative to Nasty EXE Servers</a></p>
   <div class="post" id="post-47084">
    <div class="subject"><a href="#post-47084">An Alternative to Nasty EXE Servers</a></div>
    <div class="body">Here's an interesting way to build a COM-ish program without having to make one of those nasty proxy/stub DLL thingies. Instead of placing your code into an EXE and turning it into an out-proc server, make a minimally sized EXE and statically link it with a DLL which contains <em>everything</em>. <br /><br />That way, if you're making an Automation program (for example), you can put all your real application code in a DLL which can be loaded as an in-proc server. Tell me what you think about it.<br /><br />By the way, I am working on a framework for easily designing COM interfaces, objects, and servers. I've looked &quot;CoLib&quot; that comes with the MASM32 package, but I've noticed that it uses too much run-time information for my taste, and defining interfaces doesn't look as clean and pretty as it could be. My COM framework will rely on compile-time (or is it assembler-time?) information using elaborate macros. MASM has a ridiculously powerful preprocessor system, and my system strives to exploit it to the furthest extent :grin: (haven't you noticed that you can define preprocessor constants in macros using parameters?). It will also help with implementing servers, (un)registering components, and (of course) interface calls. The good thing about my system is that everything doesn't rely on the presence of everything else (if you use VC++, then you know MFC). For example, you can link the implementation of the 'standard' class factory with your specially designed object, or you can write a custom class factory with my macros to easily define objects, and use the registration lib functions by not the un-registration functions.<br /><br />(By the way, one of the poll options should be &quot;pain in the assembler.&quot;)</div>
    <div class="meta">Posted on 2002-07-10 23:50:22 by Paulicles the Philosopher</div>
   </div>
   <div class="post" id="post-47186">
    <div class="subject"><a href="#post-47186">An Alternative to Nasty EXE Servers</a></div>
    <div class="body">COM is a natural for in-process servers (ie, a dll), since the process memory space is all the same, and interface pointers are really pointers to the interface.<br /><br />They do not. will not ever require proxy/stub code.<br /><br />Proxy/stub code (P/S) only becomes necessary when you go out of process, so 'just pretend' interfaces may be created in each process.  The P/S puts some code in each process to allow communications between process (via the magic of the operating system itself).<br /><br />Incidentally, you need not write P/S code if you restrict yourself to automation (ie, VB) types, as the universal proxy stub marshaller will handle all of these types.<br /><br />An update to CoLib is way overdue, good luck in your work.</div>
    <div class="meta">Posted on 2002-07-11 21:46:49 by Ernie</div>
   </div>
   <div class="post" id="post-47282">
    <div class="subject"><a href="#post-47282">An Alternative to Nasty EXE Servers</a></div>
    <div class="body">I know that a Local (or even worse, a <strong>Remote</strong>) server includes a lot of shadowy tricks with fake interface pointers and RPC calls, but the fact that professionals actually make those things despite the obvious drawbacks confuses me, even if their program supports Automation with &quot;automatic&quot; default marshalling.<br /><br />Just putting all your code in a DLL and linking it to a tiny EXE just makes more sense. I wonder if anyone else has ever thought of it.<br /><br />And thanks for the encouragement for my project. I'm working really fast (since I have way too much free time), and the debugging is a lot less worse than I had imagined. The hard part will probably be documenting everything in my library so that it is easy to understand and use (which just reminds me of how much I hate writing HTML).</div>
    <div class="meta">Posted on 2002-07-12 14:11:12 by Paulicles the Philosopher</div>
   </div>
   <div class="post" id="post-47409">
    <div class="subject"><a href="#post-47409">An Alternative to Nasty EXE Servers</a></div>
    <div class="body"><div class="quote">Just putting all your code in a DLL and linking it to a tiny EXE just makes more sense. I wonder if anyone else has ever thought of it.</div> <br /><br />I'm confused by what you mean. Lots of COM servers are built inside DLLs. All the .OCX ones are, .OCX is just an alternative spelling of DLL, they are the same thing.<br /><br />Yes, going out of process is a heavy price, but sometimes even professionals want one process to bump inside another. I did it myself in the dark days of VB5 to get multiple threads.</div>
    <div class="meta">Posted on 2002-07-13 16:32:45 by Ernie</div>
   </div>
   <div class="post" id="post-47498">
    <div class="subject"><a href="#post-47498">An Alternative to Nasty EXE Servers</a></div>
    <div class="body">The attached pic will explain what I mean. I know that there are plenty of DLL servers out there (including OCX servers for controls), and there are EXE servers too. I'm only saying that making an EXE which links statically with a DLL server with all the real application code is better than using RegisterActiveObject() and local and remote marshalling. (I know marshalling is sometimes necessary for some types of threading models, but COM multithreading is something I just need to read more about to fully understand.)</div>
    <div class="meta">Posted on 2002-07-14 09:53:58 by Paulicles the Philosopher</div>
   </div>
   <div class="post" id="post-47503">
    <div class="subject"><a href="#post-47503">An Alternative to Nasty EXE Servers</a></div>
    <div class="body">To change the subject, I have two small questions for you. In my COM library, I am adding support for objects that either 1) support aggregation 2) don't support aggregation and return CLASS_E_NOAGGREGATION if the pUnkOuter parameter (in functions like CoCreateInstance()) is not NULL 3) <strong>requires</strong> aggregation and return an error if pUnkOuter <strong>is</strong> NULL. This is similar to one of the features in VC++ ATL library. An object is similar to an abstract base class in C++ and Java (not that I am some sort of Java fan). Small question #1 is that I don't know if COM allows such a thing as an abstract base class.<br /><br />Small question #2 is that I don't know what error value to return if an object that <strong>requires</strong> aggregation is not created correctly (that is, if pUnkOuter is NULL). All I can think about is E_FAIL, but do you think that there is a better HRESULT, in case other clients that aren't aware of my COM library and are totally confused by E_FAIL. I checked Inside OLE, InsideCOM, and the rest of MSDN butI found nothing.</div>
    <div class="meta">Posted on 2002-07-14 10:39:01 by Paulicles the Philosopher</div>
   </div>
   <div class="post" id="post-47536">
    <div class="subject"><a href="#post-47536">An Alternative to Nasty EXE Servers</a></div>
    <div class="body">PTP,<br />to your 2. question: accordung to code sample below CLASS_E_NOAGGREGATION would be best error code.<br /><br /><pre><code><br />CreateInstance PROC pThis&#58;ptr CClassFactory, pUnkOuter&#58;LPUNKNOWN,<br />riid&#58;ptr IID,ppObject&#58;ptr LPUNKNOWN<br /><br />local	pAsmCtrl&#58;ptr CAsmCtrl<br /><br />	DebugOut &quot;IClassFactory&#58;&#58;CreateInstance&quot;<br /><br />	mov	eax, ppObject<br />	mov	DWORD PTR &#91;eax&#93;, 0<br /><br />if ?AGGREGABLE<br />	.if &#40;pUnkOuter != NULL&#41;<br />		invoke IsEqualGUID, riid, addr IID_IUnknown<br />		.if &#40;eax == FALSE&#41;<br />			DebugOut &quot;IClassFactory&#58;&#58;CreateInstance failed &#40;riid != IID_IUnknown&#41;&quot;<br />			return CLASS_E_NOAGGREGATION<br />		.endif<br />	.endif<br />else<br />	.if &#40;pUnkOuter != NULL&#41;<br />		DebugOut &quot;IClassFactory&#58;&#58;CreateInstance failed &#40;pUnkOuter != Null&#41;&quot;<br />		return CLASS_E_NOAGGREGATION<br />	.endif<br />endif<br /></code></pre><br /><br />To your 1. question: What is the difference between an interface and an abtract base class? dont see any.</div>
    <div class="meta">Posted on 2002-07-14 15:01:53 by japheth</div>
   </div>
   <div class="post" id="post-47597">
    <div class="subject"><a href="#post-47597">An Alternative to Nasty EXE Servers</a></div>
    <div class="body"><div class="quote">3) requires aggregation and return an error if pUnkOuter is NULL.</div> <br /><br />I can't see how this is usefull. I don't think it violates the COM contract, so you could do it, but why?<br /><br />An object may be usefull only when contained within another object (such as a visual control), but by demanding it be aggregated, you cut short how it may be reused, leaving the hapless programmer no option to contain it.<br /><br />And after all, COM is about reusing programmable objects.</div>
    <div class="meta">Posted on 2002-07-14 22:03:58 by Ernie</div>
   </div>
   <div class="post" id="post-47626">
    <div class="subject"><a href="#post-47626">An Alternative to Nasty EXE Servers</a></div>
    <div class="body">To Ernie:<br />Just use your imagination! There must be lots of ways to use abstract base classes for COM if you think 'bout it. You could use such a component to display info about the outer component (which may not make sense if the component was not aggregated).<br /><br />Besides, why <em>not</em> support it? The code took me <strong>4 minutes</strong> to write and no time to debug since all it requires is a simple preprocessor statement to generate the code. Besides, I already added support 'support' and 'no support' already. :grin:<br /><br />To japheth:<br />I wouldn't return because CLASS_E_NOAGGREGATION is traditionally used when aggregation is not supported. Returning that code might make Ole32.dll go into a state of denial and crash. The problem is that if an object is created using IClassFactory (in my humble, macro-macho system) a custom code can be returned, but if CoCreateInstance is used, the return value will not equal the value of IClassFactory::CreateInstance (as far as I know). <br /><br />E_INVALIDARG or E_UNEXPECTED are close enough. Or I could make a custom HRESULT (like CLASS_E_MUSTAGGREGATE). If you are using a component that must be aggregated, you probably would know about it anyway.</div>
    <div class="meta">Posted on 2002-07-15 00:15:09 by Paulicles the Philosopher</div>
   </div>
   <div class="post" id="post-48001">
    <div class="subject"><a href="#post-48001">An Alternative to Nasty EXE Servers</a></div>
    <div class="body"><div class="quote"><br />You could use such a component to display info about the outer component (which may not make sense if the component was not aggregated).</div><br /><br /><br />Yikes! And violate containment?    &lt;g&gt;<br /><br />&quot;Gentle degredation&quot; would dictate a non-aggregated 'aggregator sniffer' would, of course, return a reasonable error result if asked to query it's (nonexistant) aggregator.<br /><br />I'm not agruing with you, I'm just asking what is the usefullness you seek.<br /><br />BTW, &quot;abstract base class&quot; is too C++ for me (I don't do C++).  Can you put it in other terms so I get what you mean?<br /><br />Also, as you correctly stated, a multithreaded enviroment also needs interface marshalling, even for in-process DLLs. I tend to forget this case cause I avoid multithreading (having only personally used it once).</div>
    <div class="meta">Posted on 2002-07-16 19:46:52 by Ernie</div>
   </div>
   <div class="post" id="post-48022">
    <div class="subject"><a href="#post-48022">Forgive my dry wit and C++...</a></div>
    <div class="body">An &quot;abstract base class&quot; is a class (or object, or type, or whatever) that has one or more &quot;pure virtual functions&quot; - which are the equivilent of COM vtables with members that point to NULL. <br /><br />For example, interfaces in C++ are declared as abstract base classes inheriting from IUnknown and having only &quot;pure virtual functions.&quot; A class object in C++ &quot;inherits&quot; from these interfaces and fills up the vtables by implementing all functions. This is NOT what a COM abstract base could be used for.<br /><br />(By the way, sorry for spilling C++ stuff in the conversation.)<br /><br />Let me just make a really messy and simple example. You could use an aggregation-only class to automate IDispatch (no put intended.) Let's call it's only interface IAutoDispatch, with two methods: LoadDispatch, which takes a pointer to the outer components ITypeInfo interface, and UnloadDispatch, which takes no parameters. The outer component calls InitDispatch when it initializes and if doesn't return S_OK, it returns E_UNEXPECTED to the class factory*. The outer component can return pointers to IAutoDispatch and...... no, wait..... :confused:  that doesn't make sense. Forget what I just said! My example doesn't make sense anymore since the client wound't want IAutoDispatch, even if IAutoDispatch is useful if it is used by a component. I guess Ernie is right: containment is better (to hide IAutoDispatch). I can't come up with a good example because it could take some thought. I still think an aggregation-only object is somehow useful and there would be no harm in including it into my library. But I am a humble programmer and Ernie wins this round. :alright: Now let's all play &quot;Spear Toss!&quot; ::Everyone runs to The Heap::<br /><br />* I know that the MSDN COM reference states that IClassFactory's CreateInstance method should only return interfaces to <em>uninitialized</em> components, but who follows that rule anyway? I don't think someone is fond of that idea. Why did they make it so? Why?!?</div>
    <div class="meta">Posted on 2002-07-16 23:15:59 by Paulicles the Philosopher</div>
   </div>
  </div>
 </body>
</html>