<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>GDI Question again.. - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4907" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=4907">GDI Question again..</a></p>
   <div class="post" id="post-34412">
    <div class="subject"><a href="#post-34412">GDI Question again..</a></div>
    <div class="body">This one is simpler in nature...<br /><br />I want to add bitmap suport for the control im making, however all i *know* with gdi is how to bitblt dc's.<br /><br />The problem is that i cant mask the backgrounds of bitmaps that would be used.  So if someone's desktop is neon green and i have a standard grey background, its going to show up.<br /><br />How would i go about taking a bitmap, and then building a mask for it such that only the &quot;graphical&quot; info is bitblt'd to another DC. Is there api's for this (briefly looked but didnt see anything).  Code fragments would rock, but a basic pseudo outline is all i really need.<br /><br />Thanx again for any advice.<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-04-22 06:38:07 by NaN</div>
   </div>
   <div class="post" id="post-34418">
    <div class="subject"><a href="#post-34418">GDI Question again..</a></div>
    <div class="body">NaN,<br /><br />The methods I use with bitmaps that have to have the correct background colour is to set them to a single background colour when I make them and flood fill the background colour at runtime. Only problem is you cannot have enclosed areas with the background as the flood fill will not work there.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-04-22 07:37:41 by hutch--</div>
   </div>
   <div class="post" id="post-34419">
    <div class="subject"><a href="#post-34419">GDI Question again..</a></div>
    <div class="body">First, let me explain I've never done this, just that I looked up a few things along the way.<br /><br />msimg32.dll contains an interesting API named TransparentBlt. This BLT function contains the interesting parameter crTransparent, &quot;The RGB color in the source bitmap to treat as transparent.&quot;<br /><br />The &quot;user beware&quot; catch is this API is only good for W98 and NT5 or later. And Microsoft themselves recomends you don't use it in 98 cause it has a memory leak bug.<br /><br />So... on to manual methods. Rather then deescribe how I remember it done, just check out <a target="_blank" href="http://support.microsoft.com/default.aspx?scid=kb;EN-US;q79212">HOWTO: Drawing Transparent Bitmaps (Q79212)</a><br /><br />Hrmmm.... I've seen this question come up about every 3-4 months. Maybe it's time someone write up a routine for the MASM32 library.<br /><br />Any takers?   :-)</div>
    <div class="meta">Posted on 2002-04-22 07:46:41 by Ernie</div>
   </div>
   <div class="post" id="post-34424">
    <div class="subject"><a href="#post-34424">GDI Question again..</a></div>
    <div class="body">Aww heck, I've got time for another cup of coffee today. Here's a direct &quot;C to ASM&quot; translation of that articles code.<br /><br />All I claim is it compiles, I have not tested it. <br /><br /><pre><code><br />DrawTransparentBitmap PROC hdc&#58;DWORD, hBitmap&#58;DWORD, xStart&#58;DWORD, yStart&#58;DWORD,<br />                           cTransparentColor&#58;DWORD<br />    LOCAL bm&#58;DWORD, cColor&#58;DWORD, <br />    LOCAL bmAndBack&#58;DWORD, bmAndObject&#58;DWORD, bmAndMem&#58;DWORD, bmSave&#58;DWORD<br />    LOCAL bmBackOld&#58;DWORD, bmObjectOld&#58;DWORD, bmMemOld&#58;DWORD, bmSaveOld&#58;DWORD<br />    LOCAL hdcMem&#58;DWORD, hdcBack&#58;DWORD, hdcObject&#58;DWORD, hdcTemp&#58;DWORD, hdcSave&#58;DWORD;<br />    LOCAL ptSize&#58;POINT;<br /><br />    invoke CreateCompatibleDC, hdc<br />    mov hdcTemp, eax<br />    invoke SelectObject, hdcTemp, hBitmap   ; Select the bitmap<br /><br />    invoke GetObject, hBitmap, sizeof&#40;BITMAP&#41;, ADDR bm<br />    mov eax, bm.bmWidth                     ; Get width of bitmap<br />    mov ptSize.x, eax <br />    mov eax, bm.bmHeight                    ; Get height of bitmap<br />    mov ptSize.y, eax<br />    invoke DPtoLP, hdcTemp, ADDR ptSize, 1  ; Convert from device<br />                                            ; to logical points<br /><br />    ; Create some DCs to hold temporary data.<br />    invoke CreateCompatibleDC, hdc<br />    mov hdcBack, eax<br />    invoke CreateCompatibleDC, hdc<br />    mov hdcObject, eax<br />    invoke CreateCompatibleDC, hdc<br />    mov hdcMem, eax<br />    invoke CreateCompatibleDC, hdc<br />    mov hdcSave, eax<br /><br />   ; Create a bitmap for each DC. DCs are required for a number of<br />   ; GDI functions.<br /><br />   ; Monochrome DC<br />    invoke CreateBitmap, ptSize.x, ptSize.y, 1, 1, NULL<br />    mov bmAndBack, eax<br />    <br />   ; Monochrome DC<br />    invoke CreateBitmap, ptSize.x, ptSize.y, 1, 1, NULL<br />    mov bmAndObject, eax<br /><br />    invoke CreateCompatibleBitmap, hdc, ptSize.x, ptSize.y<br />    mov bmAndMem, eax<br />    invoke CreateCompatibleBitmap, hdc, ptSize.x, ptSize.y<br />    mov bmSave, eax<br /><br />   ; Each DC must select a bitmap object to store pixel data.<br />    invoke SelectObject, hdcBack, bmAndBack<br />    mov bmBackOld, eax<br />    invoke SelectObject, hdcObject, bmAndObject<br />    mov bmObjectOld, eax<br />    invoke SelectObject, hdcMem, bmAndMem<br />    mov bmMemOld, eax<br />    invoke SelectObject, hdcSave, bmSave<br />    mov bmSaveOld, eax<br /><br />   ; Set proper mapping mode.<br />    invoke GetMapMode, hdc<br />    invoke SetMapMode, hdcTemp, eax<br /><br />   ; Save the bitmap sent here, because it will be overwritten.<br />    invoke BitBlt, hdcSave, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCCOPY<br /><br />   ; Set the background color of the source DC to the color.<br />   ; contained in the parts of the bitmap that should be transparent<br />    invoke SetBkColor, hdcTemp, cTransparentColor<br />    mov cColor, eax<br /><br />   ; Create the object mask for the bitmap by performing a BitBlt<br />   ; from the source bitmap to a monochrome bitmap.<br />    invoke BitBlt, hdcObject, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCCOPY<br /><br />   ; Set the background color of the source DC back to the original<br />   ; color.<br />    invoke SetBkColor, hdcTemp, cColor<br /><br />   ; Create the inverse of the object mask.<br />    invoke BitBlt, hdcBack, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, NOTSRCCOPY<br /><br />   ; Copy the background of the main DC to the destination.<br />    invoke BitBlt, hdcMem, 0, 0, ptSize.x, ptSize.y, hdc, xStart, yStart, SRCCOPY<br /><br />   ; Mask out the places where the bitmap will be placed.<br />    invoke BitBlt, hdcMem, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, SRCAND<br /><br />   ; Mask out the transparent colored pixels on the bitmap.<br />    invoke BitBlt, hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcBack, 0, 0, SRCAND<br /><br />   ; XOR the bitmap with the background on the destination DC.<br />    invoke BitBlt, hdcMem, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCPAINT<br /><br />   ; Copy the destination to the screen.<br />    invoke BitBlt, hdc, xStart, yStart, ptSize.x, ptSize.y, hdcMem, 0, 0, SRCCOPY<br /><br />   ; Place the original bitmap back into the bitmap sent here.<br />    invoke BitBlt, hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcSave, 0, 0, SRCCOPY<br /><br />   ; Delete the memory bitmaps.<br />    invoke DeleteObject, SelectObject, hdcBack, bmBackOld<br />    invoke DeleteObject, SelectObject, hdcObject, bmObjectOld<br />    invoke DeleteObject, SelectObject, hdcMem, bmMemOld<br />    invoke DeleteObject, SelectObject, hdcSave, bmSaveOld<br /><br />   ; Delete the memory DCs.<br />    invoke DeleteDC, hdcMem<br />    invoke DeleteDC, hdcBack<br />    invoke DeleteDC, hdcObject<br />    invoke DeleteDC, hdcSave<br />    invoke DeleteDC, hdcTemp<br /><br />    ret<br />    <br />DrawTransparentBitmap ENDP<br /></code></pre></div>
    <div class="meta">Posted on 2002-04-22 08:23:53 by Ernie</div>
   </div>
   <div class="post" id="post-34426">
    <div class="subject"><a href="#post-34426">GDI Question again..</a></div>
    <div class="body">this is only a guess...<br /><br />oh, the _MakeRegion proc will look up the<br />pixel-color in x:0/y:0 and mark it as &quot;transparent&quot;<br />then it will create a region for you. this was written<br />for window-skinning so i think you have to correct<br />some parts...<br /><br /><pre><code><br />.DATA<br />f_dc dd 0<br />... alot of handle vars<br /><br />.CODE<br />--WM_CREATE&#58;<br />invoke LoadBitmap,hInst, BM_ID<br />mov bm_handle,eax<br /><br />invoke CreatePatternBrush, bm_handle<br />mov bm_brush,eax<br /><br />invoke _MakeRegion, bm_handle<br />mov bm_region, eax<br /><br />invoke OffsetRgn,bm_region,X,Y   ;&lt;-???<br /><br />--WM_PAINT&#58;<br />invoke BeginPaint,hwnd,addr paint_struc<br />mov hdc,eax<br /><br />invoke SelectObject,hdc,bm_brush<br /><br />invoke PaintRgn,hdc,bm_region<br /><br />invoke EndPaint,hwnd,addr paint_struc<br /><br />--WM_CLOSE&#58;<br />close all handles &#40;api-ref&#41;<br /><br /><br /><br /><br /><br />_MakeRegion     PROC USES ESI EDI EBX bhnd&#58;DWORD<br />                LOCAL flag&#58; DWORD<br />                LOCAL frun&#58; DWORD<br />                LOCAL d_dc&#58; DWORD<br />                LOCAL oldx&#58; DWORD<br />                LOCAL tcol&#58; DWORD<br />                LOCAL _hdc&#58; DWORD<br /><br />        invoke  CreateCompatibleDC,NULL<br />        mov     _hdc,eax<br />        invoke  SelectObject,_hdc,bhnd<br />        mov     flag,FALSE<br />        mov     frun,TRUE<br />        mov     oldx,0<br />        xor     edi,edi<br />        xor     esi,esi<br />        invoke  GetPixel,_hdc,0,0<br />        mov     tcol,eax<br />_xloop&#58; invoke  GetPixel,_hdc,edi,esi<br />        cmp     eax,tcol<br />        jz      _letsgo<br />        cmp     edi,PictureW<br />        jnz     _fndone<br />_letsgo&#58;cmp     flag,TRUE<br />        jnz     _nxtone<br />        mov     flag,FALSE<br />        mov     eax,esi<br />        inc     eax<br />        invoke  CreateRectRgn,ebx,esi,edi,eax<br />        mov     d_dc,eax<br />        cmp     frun,TRUE<br />        jnz     _nofrun<br />        mov     frun,FALSE<br />        push    d_dc<br />        pop     f_dc<br />        jmp     _nxtone<br />_nofrun&#58;invoke  CombineRgn,f_dc,f_dc,d_dc,RGN_OR<br />        invoke  DeleteObject,d_dc<br />        jmp     _nxtone<br />_fndone&#58;cmp     flag,FALSE<br />        jnz     _nxtone<br />        mov     flag,TRUE<br />        mov     ebx,edi<br />_nxtone&#58;inc     edi<br />        cmp     edi,PictureW<br />        jbe     _xloop<br />        xor     edi,edi<br />        inc     esi<br />        cmp     esi,PictureH<br />        jb      _xloop<br />_exit&#58;  invoke  DeleteDC,_hdc<br />        mov     eax,f_dc<br />        ret<br /></code></pre></div>
    <div class="meta">Posted on 2002-04-22 08:33:44 by mob</div>
   </div>
   <div class="post" id="post-34437">
    <div class="subject"><a href="#post-34437">GDI Question again..</a></div>
    <div class="body">This should also be done easily if you load the image up in an Image list i believe. You can use a Bitmap that contains the Mask when you add it to an Image List <br /><br /><br /><br /><a target="_blank" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/CommCtls/ImageList/Functions/ImageList_Add.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/CommCtls/ImageList/Functions/ImageList_Add.asp</a><br /><br /><a target="_blank" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/commctls/imagelist/reflist.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/commctls/imagelist/reflist.asp</a></div>
    <div class="meta">Posted on 2002-04-22 09:59:42 by Volcano_88101</div>
   </div>
   <div class="post" id="post-34511">
    <div class="subject"><a href="#post-34511">GDI Question again..</a></div>
    <div class="body">Thanx alot everyone! This is oooodles of stuff for me to hack thru.  <br /><br />Ernie, I plan on writting my first formal tutorial outa this, so it will eventually get discussed ~ however, thanx for the source!<br /><br />PS: How did you ever get this to compile ( :grin: )<pre><code> ; Delete the memory bitmaps.<br />    invoke DeleteObject, SelectObject, hdcBack, bmBackOld<br />    invoke DeleteObject, SelectObject, hdcObject, bmObjectOld<br />    invoke DeleteObject, SelectObject, hdcMem, bmMemOld<br />    invoke DeleteObject, SelectObject, hdcSave, bmSaveOld</code></pre><br /><br />Hutch, i looked over your Bitmap Button example but it confused me what you were trying to do, however with you above explaination i think i now know what your were up to.  I will have to look it over again as well :)<br /><br />Volcano_88101, Thanx for the info.  I knew about this, but from past experiences i didnt *enjoy* using them.  However, if it fits the bill i might have to ;) .  Thanx!<br /><br />Mob, Thanx as well for your source on regions.  I will admit this is one GDI area i've never set foot into so perhaps it holds some uses for this purpose... thanx again!<br /><br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-04-22 16:36:40 by NaN</div>
   </div>
   <div class="post" id="post-34548">
    <div class="subject"><a href="#post-34548">GDI Question again..</a></div>
    <div class="body">Whoops... thats what I get for covering my desktop with multiple source images. <br /><br />This will compile a little better.  ;-)<br /><br /><pre><code><br />;-------------------------------------------------------------------------------<br />;<br />; DrawTransparentBitmap&#58; bitmap blit function that respects the background color<br />;                           and does not copy over it<br />;<br />; Code is directly written from &quot;HOWTO&#58; Drawing Transparent Bitmaps &#40;Q79212&#41;&quot;<br />; &#40;no copyright noted on orgional code, none claimed here either&#41;<br />;<br />;-------------------------------------------------------------------------------<br /><br />DrawTransparentBitmap PROC hdc&#58;DWORD, hBitmap&#58;DWORD, xStart&#58;DWORD, yStart&#58;DWORD, \<br />                           cTransparentColor&#58;DWORD<br />    LOCAL bm&#58;BITMAP, cColor&#58;DWORD<br />    LOCAL bmAndBack&#58;DWORD, bmAndObject&#58;DWORD, bmAndMem&#58;DWORD, bmSave&#58;DWORD<br />    LOCAL bmBackOld&#58;DWORD, bmObjectOld&#58;DWORD, bmMemOld&#58;DWORD, bmSaveOld&#58;DWORD<br />    LOCAL hdcMem&#58;DWORD, hdcBack&#58;DWORD, hdcObject&#58;DWORD, hdcTemp&#58;DWORD, hdcSave&#58;DWORD<br />    LOCAL ptSize&#58;POINT<br /><br />    invoke CreateCompatibleDC, hdc<br />    mov hdcTemp, eax<br />    invoke SelectObject, hdcTemp, hBitmap   ; Select the bitmap<br /><br />    invoke GetObject, hBitmap, sizeof&#40;BITMAP&#41;, ADDR bm<br />    mov eax, bm.bmWidth                     ; Get width of bitmap<br />    mov ptSize.x, eax <br />    mov eax, bm.bmHeight                    ; Get height of bitmap<br />    mov ptSize.y, eax<br />    invoke DPtoLP, hdcTemp, ADDR ptSize, 1  ; Convert from device<br />                                            ; to logical points<br /><br />    ; Create some DCs to hold temporary data.<br />    invoke CreateCompatibleDC, hdc<br />    mov hdcBack, eax<br />    invoke CreateCompatibleDC, hdc<br />    mov hdcObject, eax<br />    invoke CreateCompatibleDC, hdc<br />    mov hdcMem, eax<br />    invoke CreateCompatibleDC, hdc<br />    mov hdcSave, eax<br /><br />   ; Create a bitmap for each DC. DCs are required for a number of GDI functions.<br /><br />   ; Monochrome DC<br />    invoke CreateBitmap, ptSize.x, ptSize.y, 1, 1, NULL<br />    mov bmAndBack, eax<br />    <br />   ; Monochrome DC<br />    invoke CreateBitmap, ptSize.x, ptSize.y, 1, 1, NULL<br />    mov bmAndObject, eax<br /><br />    invoke CreateCompatibleBitmap, hdc, ptSize.x, ptSize.y<br />    mov bmAndMem, eax<br />    invoke CreateCompatibleBitmap, hdc, ptSize.x, ptSize.y<br />    mov bmSave, eax<br /><br />   ; Each DC must select a bitmap object to store pixel data.<br />    invoke SelectObject, hdcBack, bmAndBack<br />    mov bmBackOld, eax<br />    invoke SelectObject, hdcObject, bmAndObject<br />    mov bmObjectOld, eax<br />    invoke SelectObject, hdcMem, bmAndMem<br />    mov bmMemOld, eax<br />    invoke SelectObject, hdcSave, bmSave<br />    mov bmSaveOld, eax<br /><br />   ; Set proper mapping mode.<br />    invoke GetMapMode, hdc<br />    invoke SetMapMode, hdcTemp, eax<br /><br />   ; Save the bitmap sent here, because it will be overwritten.<br />    invoke BitBlt, hdcSave, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCCOPY<br /><br />   ; Set the background color of the source DC to the color.<br />   ; contained in the parts of the bitmap that should be transparent<br />    invoke SetBkColor, hdcTemp, cTransparentColor<br />    mov cColor, eax<br /><br />   ; Create the object mask for the bitmap by performing a BitBlt<br />   ; from the source bitmap to a monochrome bitmap.<br />    invoke BitBlt, hdcObject, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCCOPY<br /><br />   ; Set the background color of the source DC back to the original color.<br />    invoke SetBkColor, hdcTemp, cColor<br /><br />   ; Create the inverse of the object mask.<br />    invoke BitBlt, hdcBack, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, NOTSRCCOPY<br /><br />   ; Copy the background of the main DC to the destination.<br />    invoke BitBlt, hdcMem, 0, 0, ptSize.x, ptSize.y, hdc, xStart, yStart, SRCCOPY<br /><br />   ; Mask out the places where the bitmap will be placed.<br />    invoke BitBlt, hdcMem, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, SRCAND<br /><br />   ; Mask out the transparent colored pixels on the bitmap.<br />    invoke BitBlt, hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcBack, 0, 0, SRCAND<br /><br />   ; XOR the bitmap with the background on the destination DC.<br />    invoke BitBlt, hdcMem, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCPAINT<br /><br />   ; Copy the destination to the screen.<br />    invoke BitBlt, hdc, xStart, yStart, ptSize.x, ptSize.y, hdcMem, 0, 0, SRCCOPY<br /><br />   ; Place the original bitmap back into the bitmap sent here.<br />    invoke BitBlt, hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcSave, 0, 0, SRCCOPY<br /><br />   ; Delete the memory bitmaps.<br />    invoke SelectObject, hdcBack, bmBackOld<br />    invoke DeleteObject, eax<br />    invoke SelectObject, hdcObject, bmObjectOld<br />    invoke DeleteObject, eax <br />    invoke SelectObject, hdcMem, bmMemOld<br />    invoke DeleteObject, eax <br />    invoke SelectObject, hdcSave, bmSaveOld<br />    invoke DeleteObject, eax <br /><br />   ; Delete the memory DCs.<br />    invoke DeleteDC, hdcMem<br />    invoke DeleteDC, hdcBack<br />    invoke DeleteDC, hdcObject<br />    invoke DeleteDC, hdcSave<br />    invoke DeleteDC, hdcTemp<br /><br />    ret<br />    <br />DrawTransparentBitmap ENDP<br /></code></pre></div>
    <div class="meta">Posted on 2002-04-22 19:08:57 by Ernie</div>
   </div>
   <div class="post" id="post-34557">
    <div class="subject"><a href="#post-34557">GDI Question again..</a></div>
    <div class="body">My only question about this is how fast would this actually be?</div>
    <div class="meta">Posted on 2002-04-22 20:46:14 by Volcano_88101</div>
   </div>
   <div class="post" id="post-34565">
    <div class="subject"><a href="#post-34565">GDI Question again..</a></div>
    <div class="body">Hmmm.. still uncertain.  I manually transcribed it myself as well, but it doesn't work.  Im still tracking thu it and seeing where it fails.<br /><br />However, there is an odd API in there:<pre><code>invoke DPtoLP, hdcTemp, ADDR ptSize, 1                                 ; Convert from device<br />                                                                           ; to logical points<br />    ; WARNING&#58; This function fails if the device coordinates exceed 27 bits, or if the converted logical<br />    ;          coordinates exceed 32 bits. In the case of such an overflow, the results for all the points<br />    ;          are undefined. </code></pre><br /><br />What im testing with is a 23*23 bitmap.  ANd would like to be able to suport 32x32 etc.  However, im not positive this is the problem anyways..<br /><br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-04-22 21:11:26 by NaN</div>
   </div>
   <div class="post" id="post-34584">
    <div class="subject"><a href="#post-34584">GDI Question again..</a></div>
    <div class="body">Thanx Everyone who got into this converstaion!<br /><br />Im now satisfied with what i have and seems to work good.  As well the warning on the API doesnt seem to be in 'pixels' as it works fine with 60x60 images.<br /><br />So im happy with what Ernie pointed me to.  And in light of what Ernie suggested, i made a formal MASM32.lib file so that it can be easily added to you libraries.  There is nothing to optomize really (well maybe cut out one less DC, but ah, it works smoothly as far as i can tell anyways).<br /><br />I did however make one param.  Its to suport stuff like what hutch does and samples the first bit for transparency.<br /><br />The file is attached below.  In the header i tell you what to do with the file to add it to the lib, so i wont go over this. What i will talk about is its usage:<br /><br /><pre><code>invoke DrawTransparentBitmap, hDC_Destination,<br />                              hBitmap to draw,<br />                              DC starting x point,<br />                              DC starting y point,<br />                              Transparent color</code></pre><br /><br />In usage the x,y point is where the upper right corner of the bitmap will be on the DC.  The Transparency color can either be:<br /><ul>[*] Any RGB color you choose, but as a DWORD, it must not have the 32nd bit set ( 80000000h ).<br />[*] TBM_FIRSTPIXEL :: This will use the first pixel (0,0) in the bitmap as the transparency color used. This equate is the 8000000h value.<br /><br /><br />There you go!.. Works very well on Win98SE.  If you have problems with it let me know!  As well Hutch, please feel free to add this to you next revision.  I think Ernie's sugestion was a good one. (already added on my home masm32.lib).<br /><br />Enjoy! And thanx again for all the other source everyone.<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-04-23 00:01:39 by NaN</div>
   </div>
  </div>
 </body>
</html>