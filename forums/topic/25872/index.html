<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Quickly fill a contiguous block of memory - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25872" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25872">Quickly fill a contiguous block of memory</a></p>
   <div class="post" id="post-188688">
    <div class="subject"><a href="#post-188688">Quickly fill a contiguous block of memory</a></div>
    <div class="body">If you were to fill a 4MBs contiguous block of memory using only 32-bits GPRs, what would you do? What will your solution be?</div>
    <div class="meta">Posted on 2007-03-31 08:45:14 by XCHG</div>
   </div>
   <div class="post" id="post-188689">
    <div class="subject"><a href="#post-188689">Re: Quickly fill a contiguous block of memory</a></div>
    <div class="body">rep stosd</div>
    <div class="meta">Posted on 2007-03-31 10:22:13 by JimG</div>
   </div>
   <div class="post" id="post-188690">
    <div class="subject"><a href="#post-188690">Re: Quickly fill a contiguous block of memory</a></div>
    <div class="body"><div class="quote"><br />rep stosd<br /></div><br /><br />Agreed. It does fairly well with large memory sizes and static data. Imagine something like &quot;repz stosq&quot; :P</div>
    <div class="meta">Posted on 2007-03-31 10:46:56 by SpooK</div>
   </div>
   <div class="post" id="post-188691">
    <div class="subject"><a href="#post-188691">Re: Quickly fill a contiguous block of memory</a></div>
    <div class="body">Additionally, Intel manulals state that &quot;rep stods&quot; is the fastet method to fill large chunks of memory. On P4 and above, there is also &quot;fast string mode&quot;, where instructions like &quot;rep stosd&quot; execute even faster if they meet the required criteria.</div>
    <div class="meta">Posted on 2007-03-31 14:50:08 by ti_mo_n</div>
   </div>
   <div class="post" id="post-188698">
    <div class="subject"><a href="#post-188698">Re: Quickly fill a contiguous block of memory</a></div>
    <div class="body">Alrighty. Thank you guys.</div>
    <div class="meta">Posted on 2007-04-01 09:28:41 by XCHG</div>
   </div>
   <div class="post" id="post-188720">
    <div class="subject"><a href="#post-188720">Re: Quickly fill a contiguous block of memory</a></div>
    <div class="body">Alternately, you might want to do a MMX store routine, or a SSE routine that uses write-through store so you don&#39;t pollute the CPU cache.<br /></div>
    <div class="meta">Posted on 2007-04-03 10:05:29 by f0dder</div>
   </div>
   <div class="post" id="post-188725">
    <div class="subject"><a href="#post-188725">Re: Quickly fill a contiguous block of memory</a></div>
    <div class="body">Thank you f0dder but there are two problems here. I don&#39;t want to assume that the computer that runs this program has an FPU and also I am not really good at FPU instructions and anything related to it as I&#39;ve said before. For example, this is the best I can do for a MXM ZeroMemory procedure:<br /><br /><pre><code>&nbsp; __MMXZeroMemory:<br />&nbsp; &nbsp; ; void __MMXZeroMemory (void* Destination, DWORD Length)<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; EAX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Push the accumulator onto the stack<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; ECX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Push the count register onto the stack<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; EDX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Push the data register onto the stack<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; EDI&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Push the destination index onto the stack<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; EBP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Push the base pointer onto the stack<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  EBP , ESP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Move the stack pointer to the base pointer<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  ECX , DWORD PTR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; *ECX = The  parameter<br />&nbsp; &nbsp; TEST&nbsp; &nbsp; ECX , ECX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; See if the requested length is zero<br />&nbsp; &nbsp; JZ&nbsp; &nbsp; &nbsp; .EP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Jump to the end of the procedure if yes<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  EDI , DWORD PTR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; *EDI = The  parameter<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  EAX , ECX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; *EAX = The  parameter<br />&nbsp; &nbsp; XOR&nbsp; &nbsp;  EDX , EDX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Clear the buffer for Byte-moves<br />&nbsp; &nbsp; SHR&nbsp; &nbsp;  ECX , 0x00000003&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; *ECX = Number of QWORDs that we have to move to the Destination<br />&nbsp; &nbsp; AND&nbsp; &nbsp;  EAX , 0x00000007&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; *EAX = Number of parity bytes that we have to move<br />&nbsp; &nbsp; TEST&nbsp; &nbsp; ECX , ECX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; See if the number of QWORDs to move is zero<br />&nbsp; &nbsp; JZ&nbsp; &nbsp; &nbsp; .MoveBytes&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Start moving bytes (Up to 7 bytes) if yes<br />&nbsp; &nbsp; EMMS&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Empty MMX Technology State<br />&nbsp; &nbsp; PXOR&nbsp; &nbsp; MM0 , MM0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; The 8-Byte MMX byte is zero<br />&nbsp; &nbsp; .MoveQWORDs:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Start zeroing memory 8 bytes at a time<br />&nbsp; &nbsp; &nbsp; MOVQ&nbsp; &nbsp; QWORD PTR  , MM0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Zero the current QWORD<br />&nbsp; &nbsp; &nbsp; ADD&nbsp; &nbsp;  EDI , 0x00000008&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Move to the next QWORD in the destination<br />&nbsp; &nbsp; &nbsp; DEC&nbsp; &nbsp;  ECX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Decrement the number of QWORDs to move<br />&nbsp; &nbsp; &nbsp; JNZ&nbsp; &nbsp;  .MoveQWORDs&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Keep moving QWORDs to the destination<br />&nbsp; &nbsp; TEST&nbsp; &nbsp; EAX , EAX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; See if the number of parity bytes to move is zero<br />&nbsp; &nbsp; JZ&nbsp; &nbsp; &nbsp; .EP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Jump to the end of the procedure if yes<br />&nbsp; &nbsp; .MoveBytes:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; We are left to move up to 7 bytes now<br />&nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp;  BYTE PTR  , DL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Write one byte to the current destination&#39;s location <br />&nbsp; &nbsp; &nbsp; INC&nbsp; &nbsp;  EDI&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Move to the next byte of the destination<br />&nbsp; &nbsp; &nbsp; DEC&nbsp; &nbsp;  EAX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Decrement the number of bytes to move<br />&nbsp; &nbsp; &nbsp; JNZ&nbsp; &nbsp;  .MoveBytes&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Keep moving parity bytes while EAX&gt;0<br />&nbsp; &nbsp; .EP:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; End of the procedure routine<br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp;  EBP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Restore the base pointer<br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp;  EDI&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Restore the destination index<br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp;  EDX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Restore the data register<br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp;  ECX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Restore the count register<br />&nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp;  EAX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Restore the accumulator<br />&nbsp; &nbsp; RET&nbsp; &nbsp;  0x08&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Return to the calling procedure<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; And sweep 2 parameters off the stack<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; And sweep 1 parameter off the stack</code></pre></div>
    <div class="meta">Posted on 2007-04-04 01:37:20 by XCHG</div>
   </div>
   <div class="post" id="post-188736">
    <div class="subject"><a href="#post-188736">Re: Quickly fill a contiguous block of memory</a></div>
    <div class="body">FPU != MMX, even if original MMX was overlayed on the FPU hardware. If you don&#39;t want to assume FPU, you probably shouldn&#39;t be writing 32bit code anyway :) (unless you want to support _really_ old hardware). Same goes for MMX, you&#39;ll be hard pressed to find a computer today without MMX support.<br /><br />SSE code should still be optional, though, IMHO. Win2k has SSE code for it&#39;s ZeroPage() function, btw.<br /></div>
    <div class="meta">Posted on 2007-04-04 08:11:29 by f0dder</div>
   </div>
   <div class="post" id="post-188738">
    <div class="subject"><a href="#post-188738">Re: Quickly fill a contiguous block of memory</a></div>
    <div class="body">Why Win2k has SSE code, while XP doesn&#39;t?<br /><br />RtlZeroMemory from &quot;XP SP2&quot;&#39;s ntdll.dll:<br /><pre><code>7C90311B &gt;/$ 57&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push&nbsp; &nbsp; edi<br />7C90311C&nbsp; |. 8B7C24 08&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;edi, <br />7C903120&nbsp; |. 8B4C24 0C&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;ecx, <br />7C903124&nbsp; |. 33C0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor&nbsp; &nbsp; &nbsp;eax, eax<br />7C903126&nbsp; |. FC&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cld<br />7C903127&nbsp; |. 8BD1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov&nbsp; &nbsp; &nbsp;edx, ecx<br />7C903129&nbsp; |. 83E2 03&nbsp; &nbsp; &nbsp; &nbsp; and&nbsp; &nbsp; &nbsp;edx, 3<br />7C90312C&nbsp; |. C1E9 02&nbsp; &nbsp; &nbsp; &nbsp; shr&nbsp; &nbsp; &nbsp;ecx, 2<br />7C90312F&nbsp; |. F3:AB&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rep&nbsp; &nbsp; &nbsp;stos <br />7C903131&nbsp; |. 0BCA&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or&nbsp; &nbsp; &nbsp; ecx, edx<br />7C903133&nbsp; |. 75 04&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jnz&nbsp; &nbsp; &nbsp;short ntdll.7C903139<br />7C903135&nbsp; |. 5F&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop&nbsp; &nbsp; &nbsp;edi<br />7C903136&nbsp; |. C2 0800&nbsp; &nbsp; &nbsp; &nbsp; retn&nbsp; &nbsp; 8<br />7C903139&nbsp; |&gt; F3:AA&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rep&nbsp; &nbsp; &nbsp;stos <br />7C90313B&nbsp; |. 5F&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop&nbsp; &nbsp; &nbsp;edi<br />7C90313C&nbsp; \. C2 0800&nbsp; &nbsp; &nbsp; &nbsp; retn&nbsp; &nbsp; 8</code></pre><br /><br />And here are the requirements to be met for the &quot;Fast String Operation&quot; (the fastest way to fill/move chunks of memory, at least according to &quot;The Manuals&quot;):<br /><div class="quote">Initial conditions for ?fast string? operations:<br />? EDI and ESI must be 8-byte aligned for the Pentium III processor. EDI must be 8-byte<br />&nbsp; aligned for the Pentium 4 processor.<br />? String operation must be performed in ascending address order (Direction flag cleared).<br />? The initial operation counter (ECX) must be equal to or greater than 64.<br />? Source and destination must not overlap by less than a cache line (64 bytes, Pentium 4 and<br />&nbsp; Intel Xeon processors; 32 bytes P6 family and Pentium processors).<br />? The memory type for both source and destination addresses must be either WB or WC.</div><br /><br />It requires the size of the block to be at least 1 cache line, so it seems to me like it&#39;s using burst transactions. If it does, nothing can be really faster (but I believe SSE are using burst transactions as well..?). The down side is that it fills the cache and that might be a pollution if you don&#39;t use the memory immediately after zeroing it.</div>
    <div class="meta">Posted on 2007-04-04 20:28:02 by ti_mo_n</div>
   </div>
   <div class="post" id="post-188743">
    <div class="subject"><a href="#post-188743">Re: Quickly fill a contiguous block of memory</a></div>
    <div class="body"><strong>ZeroPage()</strong> is an internal kernel function, not to be confused with RtlZeroMemory.<br /><br />Also, afaik the 64-bit version of XP <strong>does</strong> use SSE in the usermode parts of the system (ie., RtlZeroMemory). Dunno why they do it this way, but perhaps because XP-32 can (at least theoretically :)) run on non-SSE capable hardware, whereas all x64 processors are SSE capable.<br /><br />Or perhaps because XP64 is based on the Win2003 codebase? *shrug*<br /></div>
    <div class="meta">Posted on 2007-04-05 03:12:10 by f0dder</div>
   </div>
  </div>
 </body>
</html>