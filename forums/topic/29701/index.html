<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>uninitialized block - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29701" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29701">uninitialized block</a></p>
   <div class="post" id="post-209684">
    <div class="subject"><a href="#post-209684">uninitialized block</a></div>
    <div class="body">Hi,<br /><br />I have allocated 4 bytes of memory as uninitialized in .bss section and assigned data which is more than 4 bytes. My question is, what is maximum number bytes of that can be assigned. I saw the elf dump, and from what is I see, first 52 bytes is for header, then some bytes are occupied by the text section, then data section and finally the .bss section with some null bytes. That means the last address that is shown in the dump is the end of the size of bss section??? <br /><pre><code><br />.intel_syntax noprefix<br />.section .bss<br />&nbsp; &nbsp; .lcomm&nbsp; buffer, 4<br /><br />.section .data<br />&nbsp; &nbsp; output:<br />&nbsp; &nbsp; &nbsp; &nbsp; .ascii &quot;This is the output&quot;<br /><br />.section .text<br />&nbsp; &nbsp; .globl _start<br />&nbsp; &nbsp; _start:<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  edi, offset buffer<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  esi, offset output<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  ecx, 18<br />&nbsp; &nbsp; &nbsp; &nbsp; rep&nbsp; &nbsp;  movsb<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; print:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  eax, 4<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  ebx, 1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  ecx, offset buffer<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  edx, 18<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int&nbsp; &nbsp;  0x80<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; exit:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  eax, 1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  ebx, 0<br /></code></pre></div>
    <div class="meta">Posted on 2009-11-22 22:14:42 by uglyhunK</div>
   </div>
   <div class="post" id="post-209696">
    <div class="subject"><a href="#post-209696">Re: uninitialized block</a></div>
    <div class="body">You&#039;re probably good to the end of the page. Very Bad Practice to count on it, though (IMO). What do you lose by allocating the memory you need?<br /><br />Use sys_brk (with ebx=0) to find top of valid memory. My experience has been that it&#039;ll return the &quot;exact&quot; value in some kernels, and &quot;rounded up&quot; to the top of the page in others, but that you can, in fact, read/write up to the top of page in either case. I see no advantage in using &quot;shakey&quot; memory, though.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2009-11-23 12:11:28 by fbkotler</div>
   </div>
   <div class="post" id="post-209706">
    <div class="subject"><a href="#post-209706">Re: uninitialized block</a></div>
    <div class="body">Thanks for the info. I did some reading about dynamic memory allocation using sys calls. One of the articles says, using malloc() (C function) is faster than using brk for memory allocation. I find it little surprising. What would you suggest ??</div>
    <div class="meta">Posted on 2009-11-23 23:19:09 by uglyhunK</div>
   </div>
   <div class="post" id="post-209713">
    <div class="subject"><a href="#post-209713">Re: uninitialized block</a></div>
    <div class="body"><div class="quote"><br />Thanks for the info. I did some reading about dynamic memory allocation using sys calls. One of the articles says, using malloc() (C function) is faster than using brk for memory allocation. I find it little surprising. What would you suggest ??<br /></div>Why is that surprising? brk() involves a system call, and thus ring3-&gt;ring0-&gt;ring3 transition - and likely dealing with pagetables and other &quot;costly things&quot;. malloc(), on the other hand, allocates chunks of memory (sbrk or mmap, depending on implementation) and can then stay in ring3 code for several allocations.</div>
    <div class="meta">Posted on 2009-11-24 04:17:04 by f0dder</div>
   </div>
   <div class="post" id="post-209715">
    <div class="subject"><a href="#post-209715">Re: uninitialized block</a></div>
    <div class="body">This is what the man page says about &quot;brk&quot; system call<br /><em><br />&quot;Avoid&nbsp; using&nbsp; brk() and sbrk(): the malloc(3) memory allocation package is the portable and comfortable way of allocating memory.<br />...........<br />...........<br />On Linux, sbrk() is implemented as a library&nbsp; function&nbsp; that&nbsp; uses&nbsp; the brk()&nbsp; system&nbsp; call,&nbsp; and does some internal bookkeeping so that it can<br />return the old break value. &quot;</em><br /><br />- Other than saying malloc is portable and comfortable there is nothing else.<br />- Secondly, even sbrk uses brk system call and even mmap is a system call. So, there is ring3-&gt;ring0-&gt;ring3 transition in both the instances. <br /><br />Now this confuses me even more. It would be helpful if you could throw some more light on this. <br /><br />Thanks<br /><br /><br /></div>
    <div class="meta">Posted on 2009-11-24 09:21:33 by uglyhunK</div>
   </div>
   <div class="post" id="post-209717">
    <div class="subject"><a href="#post-209717">Re: uninitialized block</a></div>
    <div class="body">In the case of (s)brk and mmap you&#039;ll have ring transition for each call, possibly page table manipulations, and probably a very coarse allocation granularity (dunno about brk, but mmap will give you at least 4kb granularity). <br /><br />malloc, on the other hand, is implemented as ring3 code in libc, and does it&#039;s own bookkeeping to avoid all those ring transitions and coarse allocations granularities... along with supporting discarding memory blocks with free() :)<br /><br />Unless you have very specific speed/size requirements and are going to write your own heap allocator on top of mmap, I&#039;d suggest just going for libc&#039;s malloc... can&#039;t imagine seeing a *u*x system that doesn&#039;t have libc installed.</div>
    <div class="meta">Posted on 2009-11-24 11:51:40 by f0dder</div>
   </div>
   <div class="post" id="post-209729">
    <div class="subject"><a href="#post-209729">Re: uninitialized block</a></div>
    <div class="body">Hmmm... well... if you want &quot;portable and comfortable&quot;, libc is the way to go, no doubt. If you do it &quot;the way the book says&quot;, you&#039;ll use libc exclusively - no int 80h. At this point, might as well call it from C, too, and forget about assembly language. If the goal is &quot;to write a program for Linux&quot;, there isn&#039;t much point in asm. Unless, of course, you &quot;like&quot; assembly language and &quot;wanna&quot; do it that way - which is where I stand. :)<br /><br />Seems to me that an initial call to malloc must do a ring transition, and fiddle with the page tables, too - that&#039;s &quot;why we&#039;re here&quot;. Subsequent calls can just manipulate a &quot;big block&quot;, and should be faster... until malloc needs another &quot;big block&quot;, at which point it needs to do the ring transitions and meddle with page tables again. So I would guess the speed depends on both &quot;how many&quot; and &quot;how big&quot;.<br /><br />The granularity would be 4k for sys_brk as well as sys_mmap2. Or possibly worse? X86 allows 1M pages, as I recall - dunno if it&#039;s ever used... Malloc will let us ask for just one byte, but returns memory aligned to 16 bytes, so the &quot;practical&quot; granularity would be 16 bytes, I guess. It &quot;uses&quot; a lot more memory than that, of course.<br /><br />A &quot;trick&quot; I use to see &quot;how libc does it&quot; is to assemble a minimal program using the library, and run it with &quot;strace myprog&quot;. A single call to malloc results in 3 &quot;sys_brk&quot;s (we could have done it in two!). I wondered how much more I could malloc without incurring another system call...<br /><br /><pre><code><br />; nasm -f elf myprog.asm -Ox<br />; ld -o myprog myprog.o -I/lib/ld-linux.so.2 -lc<br /><br />global _start<br />extern malloc<br /><br />section .text<br />_start:<br />&nbsp; &nbsp; nop<br /><br />;&nbsp; &nbsp; push&nbsp; 21D34h ; 3 sys_brk<br />;&nbsp; &nbsp; push 21D35h ; 4 sys_brk<br />;&nbsp; &nbsp; push 21D44h ; &quot;<br />&nbsp; &nbsp; push 21D45h ; 3 sys_brk + sys_mmap2 (!!!)<br />&nbsp; &nbsp; call malloc<br />&nbsp; &nbsp; add esp, 4<br />bp1:<br />&nbsp; &nbsp; push 1<br />&nbsp; &nbsp; call malloc<br />&nbsp; &nbsp; add esp, 4<br />bp2:&nbsp; &nbsp; <br />&nbsp; &nbsp; mov eax, 1<br />&nbsp; &nbsp; int 80h<br /></code></pre><br /><br />The numbers were determined by experimentation (and will probably differ on another system). I have no idea what it means!<br /><br />In the particular situation uglyhunK mentions - a buffer at the end of .bss that we wish to enlarge - there might be an advantage to doing sys_brk ourselves, in that we can get contiguous memory following our buffer. Malloc will return memory &quot;wherever it feels like&quot;, sys_mmap2 is more flexible - might be able to get contiguous memory if we ask for it (haven&#039;t tried it) - but it defaults to giving us memory from 0x40000000 and up.<br /><br />My &quot;man 3 malloc&quot; includes the text &quot;This is a really bad bug.&quot; I don&#039;t think you&#039;re going to evade the bug in question by doing sys_brk or sys_mmap2. So you&#039;ve got a number of imperfect options. Which way would you &quot;like&quot; to do it? :)<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2009-11-25 05:03:59 by fbkotler</div>
   </div>
   <div class="post" id="post-209733">
    <div class="subject"><a href="#post-209733">Re: uninitialized block</a></div>
    <div class="body"><div class="quote"><br />In the case of (s)brk and mmap you&#039;ll have ring transition for each call, possibly page table manipulations, and probably a very coarse allocation granularity (dunno about brk, but mmap will give you at least 4kb granularity). <br /></div><br /><br />sys_brk extends the bss section within a 1-byte granularity, however the system itself is going to extend in page sized chunks and set your space within this allocated area, whereas sys_mmap preforms a full page allocation. With sys_brk, if you haven&#039;t reached the end of a page then the system doesn&#039;t allocate anything for you, it just gives you r/w permission to the memory. Also, 4kb is just the default, page size can be set by the user and will vary from system to system.<br /><br /><div class="quote"><br />malloc, on the other hand, is implemented as ring3 code in libc, and does it&#039;s own bookkeeping to avoid all those ring transitions and coarse allocations granularities... along with supporting discarding memory blocks with free() :)<br /></div><br /><br />That&#039;s not really the biggest reason to use libc&#039;s malloc. Allocations with sys_brk occur within the current process&#039;s allocated space. Using sys_brk, 256 is affectively the same as using:<br /><br /><pre><code>SECTION .bss<br />myMem: RESB 256</code></pre><br /><br />The difference is it happens dynamically. sys_mmap however actually extends the process memory, unfortunately on some linux systems (not sure if it&#039;s all of them as I only use the SELinux kernel) sys_mmap requires root privileges to preform this extended allocation. So, like you said, unless you are planning on writing your own allocator you probably won&#039;t have any use for sys_mmap in user-mode.<br /><br /><div class="quote"><br />Unless you have very specific speed/size requirements and are going to write your own heap allocator on top of mmap, I&#039;d suggest just going for libc&#039;s malloc... can&#039;t imagine seeing a *u*x system that doesn&#039;t have libc installed.<br /></div><br /><br />Very true.<br /><br />With sys_brk, you are either going to simulate what sys_mmap does by allocating against page boundaries or you are going to waste ring-transfer calls by repeatedly requesting memory in smaller chunks only to have the system move a pointer and possibly change some attributes. Another down side to sys_brk is that, since it &quot;allocates&quot; within page blocks there is no guarantee that the memory will appear on a page boundary, meaning that if you later pass that memory to a routine like sys_mprotect, all hell will break loose.<br /><br />One of my recent projects was a port of ATC to JWASM/Linux (ended poorly as JWASM doesn&#039;t like ATC&#039;s symbol scoping and, although works with simple classes, it loses the symbols needed for inheritance) in which I wrote a sys_brk based memory allocator. In the end I realized the best approach would be simply to use malloc() as it avoids the problems I was running into dealing with modifying page protections.</div>
    <div class="meta">Posted on 2009-11-25 10:55:23 by Synfire</div>
   </div>
   <div class="post" id="post-209734">
    <div class="subject"><a href="#post-209734">Re: uninitialized block</a></div>
    <div class="body"><strong>Frank</strong>: I&#039;m not saying you should always stick to malloc(), just that sbrk()/mmap() isn&#039;t a good choice for arbitrary-sized dynamic allocations, and should only be used for big chunks of memory. Hence<br /><div class="quote">Unless you have very specific speed/size requirements and are going to write your own heap allocator on top of mmap, I&#039;d suggest just going for libc&#039;s malloc...</div> :)<br /><br />If you have a &quot;normal&quot; application with a whole bunch of alloc/free calls, chances are your libc routines will have better code than what you write yourself, unless you spend a fair amount of time on a heap system. Of course there&#039;s also a fair chance that memory allocation isn&#039;t going to be a problem for you at all, neither in cpu cycles spent or wasted bytes because of granularity :)<br /><br />As for granularity, x86 pages can be 4kb or 4mb, or 2mb in PAE mode, and iirc AMD also introduced 1GB pages? But granularity in mmap() could be coarser than that - not sure what linux does, but Windows VirtualAlloc (and mmap) allocates at 64kb granular addresses (well, not guaranteed to be 64kb, you should call GetSystemInfo() and check dwAllocationGranularity, but it&#039;s been 64kb everywhere I&#039;ve looked).</div>
    <div class="meta">Posted on 2009-11-25 11:04:20 by f0dder</div>
   </div>
   <div class="post" id="post-209735">
    <div class="subject"><a href="#post-209735">Re: uninitialized block</a></div>
    <div class="body"><div class="quote">The difference is it happens dynamically. sys_mmap however actually extends the process memory, unfortunately on some linux systems (not sure if it&#039;s all of them as I only use the SELinux kernel) sys_mmap requires root privileges to preform this extended allocation. So, like you said, unless you are planning on writing your own allocator you probably won&#039;t have any use for sys_mmap in user-mode.</div>Wtf? mmap() requiring root privileges to allocate memory? O_o - that can&#039;t be true, unless it&#039;s some specific form that requires root (like, requesting specific addresses).</div>
    <div class="meta">Posted on 2009-11-25 11:07:06 by f0dder</div>
   </div>
   <div class="post" id="post-209736">
    <div class="subject"><a href="#post-209736">Re: uninitialized block</a></div>
    <div class="body">f0dder,<br />That&#039;s SELinux for ya. From what I was told, when getting aggravated about it during the ATC port, it&#039;s because sys_mmap requests to extend the memory for a process which is &quot;un-safe&quot; and should only be done through super-user. The response I got was to write my allocator as a shared object (kinda like a DLL) which can be loaded from non super-user apps to handle their allocations. I just reverted to malloc().</div>
    <div class="meta">Posted on 2009-11-25 12:24:44 by Synfire</div>
   </div>
   <div class="post" id="post-209754">
    <div class="subject"><a href="#post-209754">Re: uninitialized block</a></div>
    <div class="body">This sounds really silly - mmap() requests to extend the memory for a process, but sbrk() <strong>doesn&#039;t?</strong> O_o - sounds like a wanky decision. Expanding program memory being a dangerous operation? Bullshit!<br /><br />Trying to allocate a really huge chunk of memory when process quoates are in effect is another thing entirely, though, and would be a valid reason...</div>
    <div class="meta">Posted on 2009-11-26 09:59:42 by f0dder</div>
   </div>
  </div>
 </body>
</html>