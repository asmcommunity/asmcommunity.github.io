<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>struct pointer PART DEUX - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16785" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=16785">struct pointer PART DEUX</a></p>
   <div class="post" id="post-130316">
    <div class="subject"><a href="#post-130316">struct pointer PART DEUX</a></div>
    <div class="body"><pre><code><br />.data?<br />.......................<br />FVX struct<br />	x0 REAL4 ?<br />	y0 REAL4 ?<br />	z0 REAL4 ?<br />	x1 REAL4 ?<br />	y1 REAL4 ?<br />	z1 REAL4 ?<br />	x2 REAL4 ?<br />	y2 REAL4 ?<br />	z2 REAL4 ?<br />FVX ends<br /><br />vObj DWORD ?<br /></code></pre><br /><br />R0 REAL4 0.0<br />R1 REAL4 1.0<br />SIZEOFFVX equ SIZEOF FVX<br /><br /><pre><code><br />heapallocate proc<br /> invoke GetProcessHeap<br /> invoke  HeapAlloc,eax,HEAP_ZERO_MEMORY,4096*sizeof&#40;FVX&#41; <br />         ;up to 4096 of vertices<br /> mov vObj,eax<br /><br />	mov ecx, OFFSET vObj<br />	imul ecx, SIZEOFFVX<br />	fld R0<br />	fstp &#91;FVX.x0+ecx&#93;<br />	fld R1<br />	fstp &#91;FVX.y0+ecx&#93;<br />	fld R0<br />	fstp &#91;FVX.z0+ecx&#93;<br />	fld R1<br />	fstp &#91;FVX.x1+ecx&#93;<br />	fld R0<br />	fstp &#91;FVX.y1+ecx&#93;<br />	fld R0<br />	fstp &#91;FVX.z1+ecx&#93;<br />	fld R0<br />	fstp &#91;FVX.x2+ecx&#93;<br />	fld R0<br />	fstp &#91;FVX.y2+ecx&#93;<br />	fld R0<br />	fstp &#91;FVX.z2+ecx&#93;<br />	<br />	ret<br />heapallocate endp<br /></code></pre><br /><br />I am very close, I can feel it - when I do the below, I get a read error..<br /><br />	mov ecx,OFFSET vObj<br />	imul ecx, SIZEOFFVX<br />	invoke glVertex3f, ,,<br /><br />Last time on this question, thanx.. and thanks Ratch for your help although I didn't follow your suggestion precisely, maybe I am hard headed.<br /><br />how am I not accessing this memory correctly, or mal-defining it?</div>
    <div class="meta">Posted on 2004-01-10 21:13:22 by drarem</div>
   </div>
   <div class="post" id="post-130320">
    <div class="subject"><a href="#post-130320">struct pointer PART DEUX</a></div>
    <div class="body">Shouldn't it be <br /><pre><code><br />mov ecx, vObj<br /></code></pre><br />?<br /><br />Also what are you trying to achieve by<br /><pre><code><br />	mov ecx, OFFSET vObj<br />	imul ecx, SIZEOFFVX<br /></code></pre><br />It looks wrong to me.</div>
    <div class="meta">Posted on 2004-01-10 23:26:29 by roticv</div>
   </div>
   <div class="post" id="post-130323">
    <div class="subject"><a href="#post-130323">struct pointer PART DEUX</a></div>
    <div class="body">drarem,<br />If you have to multiply, which you don't in this case, why use the signed IMUL instead of the unsigned MUL?  You don't say where you are receiving the read error.   Anyway, this is the way I would code the initialization.  Ratch<br /><br /><br /><pre><code><br /> 00000024			FVX struct<br /> 00000000  00000000			x0 REAL4 ?<br /> 00000004  00000000			y0 REAL4 ?<br /> 00000008  00000000			z0 REAL4 ?<br /> 0000000C  00000000			x1 REAL4 ?<br /> 00000010  00000000			y1 REAL4 ?<br /> 00000014  00000000			z1 REAL4 ?<br /> 00000018  00000000			x2 REAL4 ?<br /> 0000001C  00000000			y2 REAL4 ?<br /> 00000020  00000000			z2 REAL4 ?<br />				FVX ends<br /><br /> 00000000			.DATA?<br /><br /> 00000000 00000000		vObj DWORD ?<br /><br /> 00000000			.CODE<br /> 00000000			MAIN&#58;<br /> 00000000			heapallocate&#58;<br />		                    INVOKE GetProcessHeap<br />			INVOKE  HeapAlloc,eax,HEAP_ZERO_MEMORY,4096*FVX <br />				         ;up to 4096 of vertices<br /> 00000012  A3 00000000 R	MOV &#91;vObj&#93;,EAX          ;save pointer to allocated memory<br /> 00000017  B9 00001000	MOV ECX,4096            ;loop count<br />			.REPEAT<br /> 0000001C  33 D2		  XOR EDX,EDX           ;EDX=0.0 in REAL4 format<br /> 0000001E  89 10		  MOV &#91;EAX.FVX.x0&#93;,EDX<br /> 00000020  89 50 08		  MOV &#91;EAX.FVX.z0&#93;,EDX<br /> 00000023  89 50 10		  MOV &#91;EAX.FVX.y1&#93;,EDX<br /> 00000026  89 50 14		  MOV &#91;EAX.FVX.z1&#93;,EDX<br /> 00000029  89 50 18		  MOV &#91;EAX.FVX.x2&#93;,EDX<br /> 0000002C  89 50 1C		  MOV &#91;EAX.FVX.y2&#93;,EDX<br /> 0000002F  89 50 20		  MOV &#91;EAX.FVX.z2&#93;,EDX<br /> 00000032  BA 3F800000	  MOV EDX,03F800000H    ;EDX=1.0 in REAL4 format<br /> 00000037  89 50 04		  MOV &#91;EAX.FVX.y0&#93;,EDX<br /> 0000003A  89 50 0C		  MOV &#91;EAX.FVX.x1&#93;,EDX<br /> 0000003D  83 C0 24		 ADD EAX,FVX            ;move pointer to next vertice set<br /> 00000040  49		DEC ECX                   ;decrement counter<br />			.UNTIL ZERO?           ;check for end of loop<br /><br /> 00000043  C3			 RET<br /><br /> 00000044  8B 0D 00000000 R           MOV ECX,&#91;vObj&#93;<br />			INVOKE glVertex3f,&#91;ECX.FVX.x0&#93;,&#91;ECX.FVX.y0&#93;,&#91;ECX.FVX.z0&#93;<br /></code></pre></div>
    <div class="meta">Posted on 2004-01-11 00:00:55 by Ratch</div>
   </div>
   <div class="post" id="post-130368">
    <div class="subject"><a href="#post-130368">struct pointer PART DEUX</a></div>
    <div class="body">err I should have titled this subject, Project Doh..<br /><br />It would help if I actually called heapallocate() function.. and if I knew what I was doing. I was also under<br />impression I couldn't mix REAL4/8 values with the registers for some weird unGodly reason. I thought those were only for FPU usage since adding/subtraction didn't handle the decimal?<br /><br />Thanks Ratch, I now know another way to reference the data..  vObj.STRUCT.member_variable<br /><br /><br />I am still using FLD/FSTP for working with the vars, trying to get familiar with the FPU.<br /><br />So EDX can store a REAL4 value, meaning it will keep track of the decimal also? What is REAL4 anyway a struc?  I will test that next..<br /><br />R05  REAL4  0.5<br />mov edx,R05<br />mul edx,R05<br />value of R05 = 0.25?<br /><br />with the multiplication, I didn't know IMUL was signed and MUL was unsigned. Or I was probably told that before and forgot it.<br /><br />And to go thru an array, I figure I can do this (untested yet):<br /><br /><pre><code><br />                mov ecx, ARRAY_INDEX_NUMBER<br /><br />                mul ecx, SIZEOFFVX    ;multiply by sizeof FVX structure<br /><br />	invoke glVertex3f, &#91;vObj.FVX.x0+ecx&#93;,&#91;vObj.FVX.y0+ecx&#93;,&#91;vObj.FVX.z0+ecx&#93;<br /></code></pre><br /><br />and it would be faster to move vObj address to a register, as Ratch used:<br /><br /><br />mov edx, vObj<br />....</div>
    <div class="meta">Posted on 2004-01-11 13:44:56 by drarem</div>
   </div>
   <div class="post" id="post-130378">
    <div class="subject"><a href="#post-130378">struct pointer PART DEUX</a></div>
    <div class="body">After some testing, I have concluded the following which may or may not be correct:<br /><br />1) add'ing/sub'ing to edx don't work, you need the FPU when adding to it if you want to preserve the decimals.<br /><br />2) see below for indexed array of vertices, I had to preserve the edx register, yes the glVertex3F calls modify the eax, ecx, and edx registers.. which means pushing and popping them to be able to use  might be as fast as using  reference.   I might as well use a temporary variable which to copy vObj to and use math on the temporary variable.<br /><br />If I didn't preserve the register used to index the array with, edx or whatever would be trashed and the array would end up waayyy out of bounds pointing to whatever the opengl calls did to them.<br /><br /><br /><br /><br /><pre><code><br />invoke glColor3f,R0,R0,R1<br />	invoke glVertex3f, &#91;vObj.FVX.x0&#93;,&#91;vObj.FVX.y0&#93;,&#91;vObj.FVX.z0&#93;<br />invoke glColor3f,R0,R1,R1	<br />	invoke glVertex3f, &#91;vObj.FVX.x1&#93;,&#91;vObj.FVX.y1&#93;,&#91;vObj.FVX.z1&#93;<br />invoke glColor3f,R1,R1,R0	<br />	invoke glVertex3f, &#91;vObj.FVX.x2&#93;,&#91;vObj.FVX.y2&#93;,&#91;vObj.FVX.z2&#93;	<br /><br />mov edx, 1                    ;point to next array of verticeses<br />imul edx,SIZEOFFVX      ;multiply by size of fvx, since MUL does not take TWO operands that I know of.<br /><br />push edx<br />invoke glColor3f,R0,R0,R1<br />pop edx<br />push edx<br />	invoke glVertex3f, &#91;vObj.FVX.x0+edx&#93;,&#91;vObj.FVX.y0+edx&#93;,&#91;vObj.FVX.z0+edx&#93;<br />pop edx<br />push edx<br />invoke glColor3f,R0,R1,R1<br />pop edx<br />push edx<br />	invoke glVertex3f, &#91;vObj.FVX.x1+edx&#93;,&#91;vObj.FVX.y1+edx&#93;,&#91;vObj.FVX.z1+edx&#93;<br />pop edx<br />push edx<br />invoke glColor3f,R1,R1,R0<br />pop edx<br />push edx<br />	invoke glVertex3f, &#91;vObj.FVX.x2+edx&#93;,&#91;vObj.FVX.y2+edx&#93;,&#91;vObj.FVX.z2+edx&#93;<br />pop edx<br /></code></pre></div>
    <div class="meta">Posted on 2004-01-11 15:24:35 by drarem</div>
   </div>
   <div class="post" id="post-130381">
    <div class="subject"><a href="#post-130381">struct pointer PART DEUX</a></div>
    <div class="body">drarem,<div class="quote">err I should have titled this subject, Project Doh..</div>Hmm, maybe you should look at <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=14673&amp;highlight=fpu+tutorial">http://www.asmcommunity.net/board/index.php?topic=14673&amp;highlight=fpu+tutorial</a> or download the zipped version of the tutorial.<div class="quote">It would help if I actually called heapallocate() function.. and if I knew what I was doing. </div> HeapAlloc is well documented.  It returns a pointer to where it allocated the amount of memory you asked for.  Make sure you call HeapFree when you are done using the memory it allocated to your program. <div class="quote">I was also under impression I couldn't mix REAL4/8 values with the registers for some weird unGodly reason. I thought those were only for FPU usage since adding/subtraction didn't handle the decimal?</div> REAL4 is the 4 byte floating format and REAL8 is the 8 byte floating format.  There is also a 10 byte floating format.  All those formats will store in the 80 bit FPU stack registers where arithmetical operations can be performed.  They are converted and stored in the format specified by the floating load or floating store instruction operands.  Read the tutorial.  Don't try to do integer type instructions (ADD, SUB,INC,etc) with numbers in floating point format.  It won't work.  Use the FADD, FSUB, etc instead.<div class="quote">I am still using FLD/FSTP for working with the vars, trying to get familiar with the FPU.<br /><br />So EDX can store a REAL4 value, meaning it will keep track of the decimal also? What is REAL4 anyway a struc? I will test that next..<br /></div>Any 32 bit register or 32 bit memory location can store a REAL4 number.  After all, it is 4 bytes, right?  The decimal point is implied by a specified format within the 32 bits, which the tutorial will explain.  REAL4 is a memory type designator, not a structure, just like BYTE, WORD, DWORD, etc. <br /><pre><code><br />R05 REAL4 0.5<br />mov edx,R05<br />mul edx,R05<br />value of R05 = 0.25?<br /></code></pre> Above, you are doing an integer operation on a floating point number.  That won't work.  See below. Ratch<br /><pre><code><br />FLD &#91;RO5&#93;<br />FMUL &#91;RO5&#93;<br />FSTP &#91;SOMEWHERE&#93;<br /></code></pre></div>
    <div class="meta">Posted on 2004-01-11 15:32:12 by Ratch</div>
   </div>
   <div class="post" id="post-130382">
    <div class="subject"><a href="#post-130382">struct pointer PART DEUX</a></div>
    <div class="body">drarem,<br /><pre><code><br />invoke glColor3f,R0,R0,R1<br />	invoke glVertex3f, &#91;vObj.FVX.x0&#93;,&#91;vObj.FVX.y0&#93;,&#91;vObj.FVX.z0&#93;<br />invoke glColor3f,R0,R1,R1	<br />	invoke glVertex3f, &#91;vObj.FVX.x1&#93;,&#91;vObj.FVX.y1&#93;,&#91;vObj.FVX.z1&#93;<br />invoke glColor3f,R1,R1,R0	<br />	invoke glVertex3f, &#91;vObj.FVX.x2&#93;,&#91;vObj.FVX.y2&#93;,&#91;vObj.FVX.z2&#93;	<br /><br />mov edx, 1                    ;point to next array of verticeses<br />imul edx,SIZEOFFVX      ;multiply by size of fvx, since MUL does not take TWO operands that I know of.<br /><br />push edx<br />invoke glColor3f,R0,R0,R1<br />pop edx<br />push edx<br />	invoke glVertex3f, &#91;vObj.FVX.x0+edx&#93;,&#91;vObj.FVX.y0+edx&#93;,&#91;vObj.FVX.z0+edx&#93;<br />pop edx<br />push edx<br />invoke glColor3f,R0,R1,R1<br />pop edx<br />push edx<br />	invoke glVertex3f, &#91;vObj.FVX.x1+edx&#93;,&#91;vObj.FVX.y1+edx&#93;,&#91;vObj.FVX.z1+edx&#93;<br />pop edx<br />push edx<br />invoke glColor3f,R1,R1,R0<br />pop edx<br />push edx<br />	invoke glVertex3f, &#91;vObj.FVX.x2+edx&#93;,&#91;vObj.FVX.y2+edx&#93;,&#91;vObj.FVX.z2+edx&#93;<br />pop edx<br /></code></pre><br /><pre><code><br />invoke glColor3f,R0,R0,R1<br />	invoke glVertex3f, &#91;vObj.FVX.x0&#93;,&#91;vObj.FVX.y0&#93;,&#91;vObj.FVX.z0&#93;<br />invoke glColor3f,R0,R1,R1	<br />	invoke glVertex3f, &#91;vObj.FVX.x1&#93;,&#91;vObj.FVX.y1&#93;,&#91;vObj.FVX.z1&#93;<br />invoke glColor3f,R1,R1,R0	<br />	invoke glVertex3f, &#91;vObj.FVX.x2&#93;,&#91;vObj.FVX.y2&#93;,&#91;vObj.FVX.z2&#93;	<br /><br />invoke glColor3f,R0,R0,R1<br /><br />	invoke glVertex3f, &#91;vObj.FVX.x0+FVX&#93;,&#91;vObj.FVX.y0+FVX&#93;,&#91;vObj.FVX.z0+FVX&#93;<br /><br />invoke glColor3f,R0,R1,R1<br /><br />	invoke glVertex3f, &#91;vObj.FVX.x1+FVX&#93;,&#91;vObj.FVX.y1+FVX&#93;,&#91;vObj.FVX.z1+FVX&#93;<br /><br />invoke glColor3f,R1,R1,R0<br /><br />	invoke glVertex3f, &#91;vObj.FVX.x2+FVX&#93;,&#91;vObj.FVX.y2+FVX&#93;,&#91;vObj.FVX.z2+FVX&#93;<br /></code></pre><br />Why do you need EDX just to add FVX to the address? Unless you plan to put this into a loop. MUL always puts the result into EAX/AX/AL.  The destination register does not have to be coded.  Ratch</div>
    <div class="meta">Posted on 2004-01-11 16:08:22 by Ratch</div>
   </div>
   <div class="post" id="post-130405">
    <div class="subject"><a href="#post-130405">struct pointer PART DEUX</a></div>
    <div class="body">yep, I was aware I could use MUL  or  to EAX, I changed it anyway..  below is my posted source + 8k exe so far, it draws two triangles and you can use the arrow keys to rotate via X/Z coords..<br /><br />feel free to expand but please share, including the crits. I will continue expanding this as well.<br /><br />Here is my loop. I changed to mul and changed sizeoffvx from const. to dword so mul would compile. I put color3f and vertex3f in macros which save the eax - the eax along with the others appear to get trashed.<br />Instead of<br /><br />push eax<br />invoke glColor3f,r,g,b<br />pop eax<br /><br />it is<br /><br />GLCOLOR3f R,G,B<br /><br />much cleaner. Note: Size changing, FULLSCREEN, and MATRIX modes are not implemented. Rotating to the right will result in clipping of one of the triangles.<br /><br /><pre><code><br />		invoke glPushMatrix<br />		invoke glBegin,GL_TRIANGLES<br /><br />		xor eax,eax   ;kind of pointless in saving speed, loop isn't here..<br />		<br />		.while eax &lt;= 2  ;two faces so far.<br />			mul SIZEOFFVX       ;must multiply first<br />			GLCOLOR3F R0,R0,R1<br />			GLVERTEX3F  &#91;vObj.FVX.x0+eax&#93;,&#91;vObj.FVX.y0+eax&#93;,&#91;vObj.FVX.z0+eax&#93;<br />			GLCOLOR3F R0,R1,R1<br />			GLVERTEX3F &#91;vObj.FVX.x1+eax&#93;,&#91;vObj.FVX.y1+eax&#93;,&#91;vObj.FVX.z1+eax&#93;<br />			GLCOLOR3F R1,R1,R0<br />			GLVERTEX3F &#91;vObj.FVX.x2+eax&#93;,&#91;vObj.FVX.y2+eax&#93;,&#91;vObj.FVX.z2+eax&#93;<br />			add eax,1<br />		.endw<br /><br />		invoke glEnd<br />		invoke glPopMatrix<br /><br /></code></pre></div>
    <div class="meta">Posted on 2004-01-11 22:22:22 by drarem</div>
   </div>
   <div class="post" id="post-130407">
    <div class="subject"><a href="#post-130407">struct pointer PART DEUX</a></div>
    <div class="body">I've reloaded a fix for the loop (see previous post), using eax to simplify the mul has complicated the code a little.. below is the loop fix:<br /><br /><pre><code><br />		invoke glColor3f,R1,R1,R1<br />		mov eax,3            ;NUMBER OF FACES<br />		mul SIZEOFFVX<br />		mov fx,eax<br />		xor eax,eax   ;kind of pointless in saving speed, loop isn't here..<br /><br />		.while eax &lt;= fx<br /><br />		push eax<br />		invoke glPushMatrix<br />		invoke glBegin,GL_TRIANGLES<br />		pop eax<br />			GLCOLOR3F R0,R0,R1<br />			GLVERTEX3F  &#91;vObj.FVX.x0+eax&#93;,&#91;vObj.FVX.y0+eax&#93;,&#91;vObj.FVX.z0+eax&#93;<br />			GLCOLOR3F R0,R1,R1<br />			GLVERTEX3F &#91;vObj.FVX.x1+eax&#93;,&#91;vObj.FVX.y1+eax&#93;,&#91;vObj.FVX.z1+eax&#93;<br />			GLCOLOR3F R1,R1,R0<br />			GLVERTEX3F &#91;vObj.FVX.x2+eax&#93;,&#91;vObj.FVX.y2+eax&#93;,&#91;vObj.FVX.z2+eax&#93;<br />		push eax<br />		invoke glEnd<br />		pop eax<br />		add eax,SIZEOFFVX<br />		push eax<br />		invoke glPopMatrix<br />		pop eax<br />		.endw<br /><br />		invoke SwapBuffers,hDC<br /></code></pre></div>
    <div class="meta">Posted on 2004-01-11 23:07:05 by drarem</div>
   </div>
  </div>
 </body>
</html>