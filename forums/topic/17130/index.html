<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>GetProcAddress using binary search - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17130" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=17130">GetProcAddress using binary search</a></p>
   <div class="post" id="post-132842">
    <div class="subject"><a href="#post-132842">GetProcAddress using binary search</a></div>
    <div class="body">Hope you like it :)<br /><br />&gt;&gt;&gt; EDIT: see end for better version!<br /><br /><pre><code><br /><br />; GetProcAddress using binary search algorithm<br />; by storm1x in 2003<br /><br />OPTION PROLOGUE&#58;NONE<br />OPTION EPILOGUE&#58;NONE<br /><br />GetProcAddr proc lpBase&#58;DWORD, szFn&#58;LPSTR<br /><br />	push ebp<br />	push ebx<br />	push edi<br />	push esi<br /><br />	; check for a valid PE<br />	mov eax,&#91;esp+10h+4&#93;<br />	cmp word ptr &#91;eax&#93;,IMAGE_DOS_SIGNATURE<br />	jnz @fail<br />	mov edx,&#91;eax+3Ch&#93;<br />	mov esi,&#91;esp+10h+8&#93;<br />	add edx,eax<br />	cmp dword ptr &#91;edx&#93;,IMAGE_NT_SIGNATURE<br />	jnz @fail<br />	mov edx,&#91;edx+78h&#93;<br />	test edx,edx<br />	jz @fail			; fail if no export table<br />	add edx,eax			; edx &lt;- IMAGE_EXPORT_TABLE &#40;edt&#41;<br /><br />	; check if getting by ordinal<br />	cmp esi,0000ffffh<br />	ja @F<br />	mov ebx,eax<br />	mov ecx,&#91;edx+1Ch&#93;	; ecx &lt;- address table<br />	add ecx,eax<br />	mov eax,&#91;edx+14h&#93;	; eax &lt;- no. of eat entries<br />	; check if valid ordinal<br />	cmp esi,eax<br />	jae @fail<br />	mov eax,esi<br />	mov esi,&#91;edx+10h&#93;	; esi &lt;- ordinal base<br />	; ordinal base must be subtracted from given ordinals<br />	; before indexing the export address table, but not<br />	; from values in the ordinal table, which runs parallel<br />	; to the name rva table<br />	sub eax,esi			; subtract ordinal base<br />	; index eat by ordinal<br />	mov eax,&#91;ecx+4*eax&#93;<br />	add eax,ebx<br />	jmp @ok<br /><br />@@&#58;	mov ebp,&#91;edx+18h&#93;	; ebp &lt;- no. of names<br />	mov ebx,&#91;edx+20h&#93;<br />	push edx<br />	add ebx,eax			; ebx &lt;- name rva table<br />	mov ecx,eax			; ecx &lt;- image base<br />	push ebx<br />	; binary search loop<br />	; ebp = num, esi = key, edi = name va, ebx = base, edx = mid<br />@bs_loop&#58;<br />	test ebp,ebp<br />	jz @bs_notfound<br />	; get middle and halve no. left<br />	shr ebp,1<br />	lea edx,&#91;ebx+4*ebp&#93;<br />	; get name va from rva array<br />	mov edi,&#91;edx&#93;<br />	add edi,ecx<br />	; compare &#91;esi&#93; and &#91;edi&#93;<br />	push esi<br />	mov al,&#91;esi&#93;<br />@@&#58;	cmp al,&#91;edi&#93;<br />	jnz @F<br />	inc esi<br />	inc edi<br />	test al,al<br />	mov al,&#91;esi&#93;<br />	jnz @B<br />@@&#58;	pop esi<br />	; now flags set according to str difference<br />	lea eax,&#91;edx+4&#93;<br />	cmova ebx,eax<br />	jnz @bs_loop<br />	<br />	; result in edx<br />@bs_done&#58;<br />	; get corresponding ordinal<br />	; first work out where we are in the name rva array<br />	pop ebx				; ebx &lt;- name rva base<br />	sub edx,ebx			; edx &lt;- name rva offset &#40;in bytes&#41;<br />	shr edx,1			; now in _words_<br />	pop esi				; esi &lt;- export table<br />	mov ebx,&#91;esp+10h+4&#93;<br />	mov ecx,&#91;esi+1Ch&#93;	; ecx &lt;- address table<br />	add ecx,ebx<br />	mov eax,&#91;esi+24h&#93;	; eax &lt;- ordinal table<br />	add eax,ebx<br />	; index ordinal table<br />	movzx eax,word ptr &#91;eax+edx&#93;<br />	; index eat by ordinal &#40;ordinal in eax, eat in ecx&#41;<br />	; ordinal table entries already have ordinal base subtracted<br />	mov eax,&#91;ecx+4*eax&#93;<br />	add eax,ebx<br />	jmp @ok<br />@bs_notfound&#58;<br />	add esp,8	; we had saved the export and name table pointers<br />@fail&#58;<br />	xor eax,eax<br />@ok&#58;<br />	pop esi<br />	pop edi<br />	pop ebx<br />	pop ebp<br />	ret 8<br /><br />GetProcAddr endp<br /><br />OPTION PROLOGUE&#58;PROLOGUEDEF<br />OPTION EPILOGUE&#58;EPILOGUEDEF<br /></code></pre></div>
    <div class="meta">Posted on 2004-02-07 15:09:11 by stormix</div>
   </div>
   <div class="post" id="post-132852">
    <div class="subject"><a href="#post-132852">GetProcAddress using binary search</a></div>
    <div class="body">Doesn't normal GetProcAddress already use binary search? Also, just where do you handle redirected exports?</div>
    <div class="meta">Posted on 2004-02-07 18:23:52 by f0dder</div>
   </div>
   <div class="post" id="post-132858">
    <div class="subject"><a href="#post-132858">GetProcAddress using binary search</a></div>
    <div class="body">What are redirected exports?</div>
    <div class="meta">Posted on 2004-02-07 20:52:31 by comrade</div>
   </div>
   <div class="post" id="post-132860">
    <div class="subject"><a href="#post-132860">GetProcAddress using binary search</a></div>
    <div class="body">for example: kernel32!HeapAlloc -&gt; NTDLL!RtlAllocateHeap</div>
    <div class="meta">Posted on 2004-02-07 21:04:36 by f0dder</div>
   </div>
   <div class="post" id="post-132861">
    <div class="subject"><a href="#post-132861">GetProcAddress using binary search</a></div>
    <div class="body">So?</div>
    <div class="meta">Posted on 2004-02-07 21:20:05 by comrade</div>
   </div>
   <div class="post" id="post-132868">
    <div class="subject"><a href="#post-132868">GetProcAddress using binary search</a></div>
    <div class="body">So, using GetProcAddress on kernel32!HeapAlloc, you would be calling code like &quot;dec esi / push esp / inc esp&quot; (etc) - that is, the text string NTDLL.RtlAllocateHeap - because the code doesn't handle those redirected (or 'forwarded' or whatever) exports.</div>
    <div class="meta">Posted on 2004-02-07 21:59:18 by f0dder</div>
   </div>
   <div class="post" id="post-132869">
    <div class="subject"><a href="#post-132869">GetProcAddress using binary search</a></div>
    <div class="body">I don't understand, ET only provide pointers to function. Where does it support redirection?</div>
    <div class="meta">Posted on 2004-02-07 22:46:57 by comrade</div>
   </div>
   <div class="post" id="post-132878">
    <div class="subject"><a href="#post-132878">GetProcAddress using binary search</a></div>
    <div class="body">Export forwarding is described in most texts on the PE format. If the exported address points inside the area marked in the data directory as the export table, then the RVA points to a forwarder string instead of the actual function. Such a forwarder string is in the format f0dder mentions, e.g. NTDLL.RtlAllocateHeap.<br /><br />If you have a kernel32.dll from NT/2K/XP you can see that a number of exports are forwarded to ntdll.dll.</div>
    <div class="meta">Posted on 2004-02-08 02:06:21 by Jibz</div>
   </div>
   <div class="post" id="post-132890">
    <div class="subject"><a href="#post-132890">GetProcAddress using binary search</a></div>
    <div class="body">An easy way to determine forwarded functions:<br /><pre><code><br />dumpbin /exports \windows\system32\kernel32.dll<br /></code></pre><br /><br />The attachment has a list of all the kernel32 APIs.<br />(Tested on Win XP Home)</div>
    <div class="meta">Posted on 2004-02-08 04:16:31 by Vortex</div>
   </div>
   <div class="post" id="post-132906">
    <div class="subject"><a href="#post-132906">GetProcAddress using binary search</a></div>
    <div class="body">ordinal check should also be against 080000000h</div>
    <div class="meta">Posted on 2004-02-08 07:40:24 by evlncrn8</div>
   </div>
   <div class="post" id="post-132945">
    <div class="subject"><a href="#post-132945">GetProcAddress using binary search</a></div>
    <div class="body">Thank you, I didn't know about forwarded exports. I will add support for them.<br /><br />re the 80000000h thing, according to msdn <a target="_blank" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/getprocaddress.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/getprocaddress.asp</a> &quot;If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero.&quot;</div>
    <div class="meta">Posted on 2004-02-08 17:19:59 by stormix</div>
   </div>
   <div class="post" id="post-133000">
    <div class="subject"><a href="#post-133000">GetProcAddress using binary search</a></div>
    <div class="body">Ok here is the new version :)<br /><br />I don't know if normal GetProcAddress uses binary search; anyone know? It calls alot of other functions so i guess this is faster..<br /><br /><pre><code><br />; fast GetProcAddress using binary search algorithm<br />; by storm1x in 2004<br /><br />OPTION PROLOGUE&#58;NONE<br />OPTION EPILOGUE&#58;NONE<br /><br />GetProcAddr proc lpBase&#58;DWORD, szFn&#58;LPSTR<br /><br />	push ebp<br />	push ebx<br />	push edi<br />	push esi<br /><br />	; check for a valid PE<br />	mov eax,&#91;esp+10h+4&#93;<br />	cmp word ptr &#91;eax&#93;,IMAGE_DOS_SIGNATURE<br />	jnz @fail<br />	mov edx,&#91;eax+3Ch&#93;<br />	mov esi,&#91;esp+10h+8&#93;<br />	add edx,eax<br />	cmp dword ptr &#91;edx&#93;,IMAGE_NT_SIGNATURE<br />	jnz @fail<br />	mov ecx,&#91;edx+7Ch&#93;	; export table length<br />	mov edx,&#91;edx+78h&#93;<br />	test edx,edx<br />	jz @fail		; fail if no export table<br />	add edx,eax		; edx &lt;- IMAGE_EXPORT_TABLE &#40;edt&#41;<br />	mov &#91;esp-32&#93;,ecx	; save export table length<br />	mov &#91;esp-28&#93;,edx	; save export table va<br /><br />	; check if getting by ordinal<br />	cmp esi,0000ffffh<br />	ja @F<br />	mov ebx,eax<br />	mov ecx,&#91;edx+1Ch&#93;	; ecx &lt;- address table<br />	add ecx,eax<br />	mov eax,&#91;edx+14h&#93;	; eax &lt;- no. of eat entries<br />	; check if valid ordinal<br />	cmp esi,eax<br />	jae @fail<br />	mov eax,esi<br />	mov esi,&#91;edx+10h&#93;	; esi &lt;- ordinal base<br />	; ordinal base must be subtracted from given ordinals<br />	; before indexing the export address table, but not<br />	; from values in the ordinal table, which runs parallel<br />	; to the name rva table<br />	sub eax,esi		; subtract ordinal base<br />	; index eat by ordinal<br />	mov eax,&#91;ecx+4*eax&#93;<br />	add eax,ebx<br />	jmp @ok<br /><br />@@&#58;	mov ebp,&#91;edx+18h&#93;	; ebp &lt;- no. of names<br />	mov ebx,&#91;edx+20h&#93;<br />	push edx<br />	add ebx,eax		; ebx &lt;- name rva table<br />	mov ecx,eax		; ecx &lt;- image base<br />	push ebx<br />	; binary search loop<br />	; ebp = num, esi = key, edi = name va, ebx = base, edx = mid<br />@bs_loop&#58;<br />	test ebp,ebp<br />	jz @bs_notfound<br />	; get middle and halve no. left<br />	shr ebp,1<br />	lea edx,&#91;ebx+4*ebp&#93;<br />	; get name va from rva array<br />	mov edi,&#91;edx&#93;<br />	add edi,ecx<br />	; compare &#91;esi&#93; and &#91;edi&#93;<br />	push esi<br />	mov al,&#91;esi&#93;<br />@@&#58;	cmp al,&#91;edi&#93;<br />	jnz @F<br />	inc esi<br />	inc edi<br />	test al,al<br />	mov al,&#91;esi&#93;<br />	jnz @B<br />@@&#58;	pop esi<br />	; now flags set according to str difference<br />	lea eax,&#91;edx+4&#93;<br />	cmova ebx,eax<br />	jnz @bs_loop<br />	<br />	; result in edx<br />@bs_done&#58;<br />	; get corresponding ordinal<br />	; first work out where we are in the name rva array<br />	pop ebx			; ebx &lt;- name rva base<br />	sub edx,ebx		; edx &lt;- name rva offset &#40;in bytes&#41;<br />	shr edx,1		; now in _words_<br />	pop esi			; esi &lt;- export table<br />	mov ebx,&#91;esp+10h+4&#93;<br />	mov ecx,&#91;esi+1Ch&#93;	; ecx &lt;- address table<br />	add ecx,ebx<br />	mov eax,&#91;esi+24h&#93;	; eax &lt;- ordinal table<br />	add eax,ebx<br />	; index ordinal table<br />	movzx eax,word ptr &#91;eax+edx&#93;<br />	; index eat by ordinal &#40;ordinal in eax, eat in ecx&#41;<br />	; ordinal table entries already have ordinal base subtracted<br />	mov eax,&#91;ecx+4*eax&#93;<br />	add eax,ebx<br />	; check if forwarder rva &#40;e.g. &quot;MYDLL.expfunc&quot; or &quot;MYDLL.#27&quot;&#41;<br />	mov ecx,&#91;esp-32&#93;	; ecx &lt;- export table len<br />	mov edx,&#91;esp-28&#93;	; edx &lt;- export table va<br />	add ecx,edx		; ecx &lt;- export table end va<br /><br />	; If the address specified is not within the export section<br />	; &#40;as defined by the address and length indicated in the<br />	; Optional Header&#41;, the field is an export RVA else a forwarder<br /><br />	cmp eax,edx<br />	jb @ok<br />	cmp eax,ecx<br />	ja @ok<br /><br />	; so we have a forwarder..<br />	mov esi,eax<br />@@&#58;	mov dl,&#91;esi&#93;<br />	inc esi<br />	cmp dl,'.'<br />	jnz @B<br /><br />	neg esi<br />	lea ecx,&#91;esi+eax&#93;	; ecx &lt;- -&#40;name len&#41;<br />	add ecx,1		; account for '.'<br />	neg esi<br /><br />	mov ebp,esp		; save stack<br />	lea esp,&#91;esp+ecx-5&#93;	; allocate len+5 on stack<br /><br />	mov edi,esp<br /><br />	; is it forwarded to an ordinal?<br />	cmp byte ptr &#91;esi&#93;,'#'<br />	jnz @notord<br />	push esi		; save this as it marks end of dll name<br />	inc esi<br />	; accumulating in edx<br />	xor ecx,ecx<br />	xor edx,edx<br />@@&#58;	mov cl,&#91;esi&#93;<br />	inc esi<br />	test cl,cl<br />	jz @toi_ok<br />	; mul edx by 10<br />	mov ebx,edx<br />	shl ebx,1<br />	shl edx,3<br />	add edx,ebx<br />	sub cl,'0'<br />	add edx,ecx<br />	jmp @B<br />@toi_ok&#58;<br />	pop esi<br />	; push ordinal<br />	push edx<br />	jmp @ffn_done<br />@notord&#58;<br />	; push fun name<br />	push esi<br />@ffn_done&#58;<br /><br />	; copy dll name<br />	push edi<br />@@&#58;	mov dl,&#91;eax&#93;<br />	mov &#91;edi&#93;,dl<br />	inc eax<br />	inc edi<br />	cmp eax,esi<br />	jb @B<br />	mov dword ptr &#91;edi&#93;,'LLD'<br /><br />	call GetModuleHandle<br /><br />	push eax<br />	call GetProcAddr	; call self<br /><br />	mov esp,ebp		; restore stack<br /><br />	jmp @ok<br />@bs_notfound&#58;<br />	add esp,8	; we had saved the export and name table pointers<br />@fail&#58;<br />	xor eax,eax<br />@ok&#58;<br />	pop esi<br />	pop edi<br />	pop ebx<br />	pop ebp<br />	ret 8<br /><br />GetProcAddr endp<br /><br />OPTION PROLOGUE&#58;PROLOGUEDEF<br />OPTION EPILOGUE&#58;EPILOGUEDEF<br /></code></pre></div>
    <div class="meta">Posted on 2004-02-09 08:03:11 by stormix</div>
   </div>
   <div class="post" id="post-133003">
    <div class="subject"><a href="#post-133003">GetProcAddress using binary search</a></div>
    <div class="body"><div class="quote"><br />I don't know if normal GetProcAddress uses binary search; anyone know?<br /></div><br />It should - technical articles mention this, besides afaik DLL exports are required to be sorted by name, for this very reason.<br /><br />Btw, how much does the speed of imports fixing really matter? When executables seem to load slowly under win32, it has almost always been because of a lot of runtime code before showing main windows (some delphi and bcb stuff), or because of delphi/bcb or other huge exes where the author has been stupid enough to use an EXE packer.<br /><br />But I'm wondering whether import resolving speed might matter after all, because on linux, GUI applications seem to load terribly slow, and I can't believe that IDE performance or memory strategies would be THAT bad with a 2.6 kernel - but they might have a really retarded symbol searching strategy? Still seems pretty silly though =)</div>
    <div class="meta">Posted on 2004-02-09 09:36:03 by f0dder</div>
   </div>
   <div class="post" id="post-133034">
    <div class="subject"><a href="#post-133034">GetProcAddress using binary search</a></div>
    <div class="body"><strong>Stormix,</strong><br />it is just an idea (not tested):<pre><code><br /><br />@@&#58;mov ebp,&#91;edx+18h&#93;; ebp &lt;- no. of names<br />&#91;B&#93;inc ebp&#91;/B&#93;<br />	;<br />	;<br />	;	<br />; binary search loop<br />; ebp = num, esi = key, edi = name va, ebx = base, edx = mid<br /><br />@Next&#58;<br />	cmova	ebx,edx	 ;eax<br />	shr	ebp,1<br />	jz	@bs_notfound<br />	mov	esi, &#91;esp+24&#93;       	; esi-&gt;&#91;esp+24&#93;-&gt;szFn&#58;LPSTR ???<br />	mov	edi, ecx		; rather then push esi / pop esi<br />	lea	edx, &#91;ebx+4*ebp&#91;B&#93;-4&#91;/B&#93;&#93;<br />	mov	al, &#91;esi&#93;<br />	add	edi, &#91;edx&#93;<br />@Compare&#58;<br />	cmp	al, &#91;edi&#93;<br />	jnz	@Next<br />	add	esi, 1<br />	add	edi, 1<br />	test	al, al<br />	mov	al, &#91;esi&#93;<br />	jnz	@Compare<br />; result in edx<br />@bs_done&#58;<br />; get corresponding ordinal<br />;<br />;</code></pre><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2004-02-09 18:28:56 by lingo12</div>
   </div>
   <div class="post" id="post-133137">
    <div class="subject"><a href="#post-133137">GetProcAddress using binary search</a></div>
    <div class="body"><strong>Lingo</strong>, thank you for your ideas :) I used them and it is faster now :D The only one that wasn't was not having the test ebp,ebp but having a jz after the shr (that was what you meant right?), this was slower for some reason.<br /><br />Also the last one doesn't handle forwards if you searched by ordinal- oops! This does.<br /><br />Anyways heres the new one:<br /><br /><pre><code><br />; fast GetProcAddress using binary search algorithm<br />; by storm1x in 2004<br />; thanks to lingo12<br /><br />OPTION PROLOGUE&#58;NONE<br />OPTION EPILOGUE&#58;NONE<br /><br />GetProcAddr proc lpBase&#58;DWORD, szFn&#58;LPSTR<br /><br />	push ebp<br />	push ebx<br />	push edi<br />	push esi<br /><br />	; check for a valid PE<br />	mov eax,&#91;esp+10h+4&#93;<br />	cmp word ptr &#91;eax&#93;,IMAGE_DOS_SIGNATURE<br />	jnz @fail<br />	mov edx,&#91;eax+3Ch&#93;<br />	mov esi,&#91;esp+10h+8&#93;<br />	add edx,eax<br />	cmp dword ptr &#91;edx&#93;,IMAGE_NT_SIGNATURE<br />	jnz @fail<br />	mov ecx,&#91;edx+7Ch&#93;	; export table length<br />	mov edx,&#91;edx+78h&#93;<br />	test edx,edx<br />	jz @fail			; fail if no export table<br />	add edx,eax			; edx &lt;- IMAGE_EXPORT_TABLE &#40;edt&#41;<br />	mov &#91;esp-32&#93;,ecx	; save export table length<br />	mov &#91;esp-28&#93;,edx	; save export table va<br /><br />	; check if getting by ordinal<br />	cmp esi,0000ffffh<br />	ja @F<br />	mov ebx,eax<br />	mov ecx,&#91;edx+1Ch&#93;	; ecx &lt;- address table<br />	add ecx,eax<br />	mov eax,&#91;edx+14h&#93;	; eax &lt;- no. of eat entries<br />	; check if valid ordinal<br />	cmp esi,eax<br />	jae @fail<br />	mov eax,esi<br />	mov esi,&#91;edx+10h&#93;	; esi &lt;- ordinal base<br />	; ordinal base must be subtracted from given ordinals<br />	; before indexing the export address table, but not<br />	; from values in the ordinal table, which runs parallel<br />	; to the name rva table<br />	sub eax,esi			; subtract ordinal base<br />	; index eat by ordinal<br />	mov eax,&#91;ecx+4*eax&#93;<br />	add eax,ebx<br />	jmp @check_forwarder<br /><br />@@&#58;	mov ebp,&#91;edx+18h&#93;	; ebp &lt;- no. of names<br />	mov ebx,&#91;edx+20h&#93;<br />	push edx<br />	add ebx,eax			; ebx &lt;- name rva table<br />	mov ecx,eax			; ecx &lt;- image base<br />	push ebx<br />	; binary search loop<br />	; ebp = num, esi = key, edi = name va, ebx = base, edx = mid<br />	stc	; make sure cmov isn't executed first time<br />@bs_loop&#58;<br />	; move to second half if it's after the mid<br />	cmova ebx,edx<br />	test ebp,ebp<br />	jz @bs_notfound<br />	; get middle and halve no. left<br />	shr ebp,1<br />	mov esi,&#91;esp+10h+8+8&#93;	; esi &lt;- szFn&#58;LPSTR<br />	mov edi,ecx<br />	lea edx,&#91;ebx+4*ebp&#93;<br />	; get name va from rva array<br />	add edi,&#91;edx&#93;<br />	; compare &#91;esi&#93; and &#91;edi&#93;<br />	; sets flags according to str difference<br />	mov al,&#91;esi&#93;<br />@@&#58;	cmp al,&#91;edi&#93;<br />	jnz @bs_loop<br />	add esi,1<br />	add edi,1<br />	test al,al<br />	mov al,&#91;esi&#93;<br />	jnz @B<br /><br />	; binary search done, resulting name va in edx<br /><br />	; get corresponding ordinal<br />	; first work out where we are in the name rva array<br />	pop ebx				; ebx &lt;- name rva base<br />	sub edx,ebx			; edx &lt;- name rva offset &#40;in bytes&#41;<br />	shr edx,1			; now in _words_<br />	pop esi				; esi &lt;- export table<br />	mov ebx,&#91;esp+10h+4&#93;<br />	mov ecx,&#91;esi+1Ch&#93;	; ecx &lt;- address table<br />	add ecx,ebx<br />	mov eax,&#91;esi+24h&#93;	; eax &lt;- ordinal table<br />	add eax,ebx<br />	; index ordinal table<br />	movzx eax,word ptr &#91;eax+edx&#93;<br />	; index eat by ordinal &#40;ordinal in eax, eat in ecx&#41;<br />	; ordinal table entries already have ordinal base subtracted<br />	mov eax,&#91;ecx+4*eax&#93;<br />	add eax,ebx<br /><br />@check_forwarder&#58;<br />	; check if forwarder rva &#40;e.g. &quot;MYDLL.expfunc&quot; or &quot;MYDLL.#27&quot;&#41;<br />	mov ecx,&#91;esp-32&#93;	; ecx &lt;- export table len<br />	mov edx,&#91;esp-28&#93;	; edx &lt;- export table va<br />	add ecx,edx			; ecx &lt;- export table end va<br /><br />	; If the address specified is not within the export section<br />	; &#40;as defined by the address and length indicated in the<br />	; Optional Header&#41;, the field is an export RVA else a forwarder<br /><br />	cmp eax,edx<br />	jb @ok<br />	cmp eax,ecx<br />	ja @ok<br /><br />	; so we have a forwarder..<br />	mov esi,eax<br />@@&#58;	mov dl,&#91;esi&#93;<br />	add esi,1<br />	cmp dl,'.'<br />	jnz @B<br /><br />	neg esi<br />	lea ecx,&#91;esi+eax&#93;	; ecx &lt;- -&#40;name len&#41;<br />	inc ecx				; account for '.'<br />	neg esi<br /><br />	mov ebp,esp			; save stack<br />	lea esp,&#91;esp+ecx-5&#93;	; allocate len+5 on stack<br /><br />	mov edi,esp<br /><br />	; is it forwarded to an ordinal?<br />	cmp byte ptr &#91;esi&#93;,'#'<br />	jnz @notord<br />	push esi			; save this as it marks end of dll name<br />	inc esi<br />	; accumulating in edx<br />	xor ecx,ecx<br />	xor edx,edx<br />@@&#58;	mov cl,&#91;esi&#93;<br />	add esi,1<br />	test cl,cl<br />	jz @toi_ok<br />	; mul edx by 10<br />	lea ebx,&#91;edx*2&#93;<br />	lea edx,&#91;ebx+edx*8&#93;<br />	sub cl,'0'<br />	add edx,ecx<br />	jmp @B<br />@toi_ok&#58;<br />	pop esi<br />	; push ordinal<br />	push edx<br />	jmp @ffn_done<br />@notord&#58;<br />	; push fun name<br />	push esi<br />@ffn_done&#58;<br /><br />	; copy dll name and '.'<br />	push edi<br />@@&#58;	mov dl,&#91;eax&#93;<br />	mov &#91;edi&#93;,dl<br />	add eax,1<br />	add edi,1<br />	cmp eax,esi<br />	jb @B<br />	mov dword ptr &#91;edi&#93;,'LLD'<br /><br />	call GetModuleHandle<br /><br />	push eax<br />	call GetProcAddr	; call self<br /><br />	mov esp,ebp			; restore stack<br /><br />	jmp @ok<br />@bs_notfound&#58;<br />	add esp,8	; we had saved the export and name table pointers<br />@fail&#58;<br />	xor eax,eax<br />@ok&#58;<br />	pop esi<br />	pop edi<br />	pop ebx<br />	pop ebp<br />	ret 8<br /><br />GetProcAddr endp<br /><br />OPTION PROLOGUE&#58;PROLOGUEDEF<br />OPTION EPILOGUE&#58;EPILOGUEDEF<br /></code></pre></div>
    <div class="meta">Posted on 2004-02-10 17:36:49 by stormix</div>
   </div>
  </div>
 </body>
</html>