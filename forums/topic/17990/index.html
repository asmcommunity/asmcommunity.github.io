<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>The WIZ - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17990" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=32">Electronics</a> &raquo; <a href="../?id=17990">The WIZ</a></p>
   <div class="post" id="post-138874">
    <div class="subject"><a href="#post-138874">The WIZ</a></div>
    <div class="body">Mr. Steve Bush hasn't posted the stuff here, so I'll do it for him.  This is the website for the WIZ processor.  A simple and interesting piece of equipment.<br /><a target="_blank" href="http://www.steve.bush.org/WizdomR&amp;D/index.html">The WIZ</a> <br />The is the thread in the MASM Forum about the WIZ.<br /><a target="_blank" href="http://www.masmforum.com/viewtopic.php?t=2513">MASM Forum -&gt; Soap Box -&gt; The WIZ</a> <br />I'll let Steve know I did this.</div>
    <div class="meta">Posted on 2004-04-13 20:00:22 by NoDot</div>
   </div>
   <div class="post" id="post-139020">
    <div class="subject"><a href="#post-139020">The WIZ</a></div>
    <div class="body">OK, hello to all! I don't know much about this forum, what kind of people are here, etc. I'll look around...<br /><br />In the meantime, let me introduce my invention, the WIZ processor. It's at:<br /><a target="_blank" href="http://www.steve.bush.org/WizdomR&amp;D/index.html">http://www.steve.bush.org/WizdomR&amp;D/index.html</a><br /><br />It is a technical specification for a processor chip of a very different design. It isn't compatable with any x86 type processors. It isn't even similar!<br /><br />If you're interested in such things, please check it out! I'm looking for some intelligent conversation about it. Comments, thoughts, ideas. Not too many flames I hope, but critical ideas are always welcome...<br /><br />Please beware: my documentation is terse and difficult to read out of order. The WIZ processor is very different from anything you're probably used to, and a single page read out of context will be confusing.<br /><br />The best introduction is NOT the &quot;Introduction&quot; section, but under &quot;The WIZ Processor&quot; in the three pages of the &quot;Overview&quot; there!<br /><br />Thanks for listening...<br /><br />Steve Bush.</div>
    <div class="meta">Posted on 2004-04-15 02:08:54 by Steve Bush</div>
   </div>
   <div class="post" id="post-139034">
    <div class="subject"><a href="#post-139034">The WIZ</a></div>
    <div class="body">Steve, I had a look at the stuff and must say I'm a bit sceptical. I'm not much into the eletronics side of things, so I can't comment on that - but it seems to me that while you're saying &quot;KISS&quot;, you are in reality just moving the complexity to separate components. It might (or might not) be easier to test each component individually, but to have actual work done you still need some &quot;total complexity&quot;.<br /><br />Also, your idea of running 'asynchronously', ho humm. You still have to wait for a 'register' to signal 'ready' before you can move on, right? What good is it that the main core can run at 10ghz if it has to wait for 'register ready' all the time - surely things like adders and memory access will run at lower rates. I guess you could alleviate this somewhat to only wait on dependant registers, but that increases complexity of the core, and you will still be stalling very often, as I see it.<br /><br />Furthermore, it seems like programming the WIZ won't be all to joyful - at least without some form of abstraction (like a macro assembler). The design (over?)simplification puts a lot of burden on the shoulders of the programmer.<br /><br />Of course, all this has to be seen in context of what you want to achieve - cheap and efficient microcontrollers, not an x86 replacement. I'm not familiar with microcontrollers, but I do realize they have a lot of requirements on size, power consumption, and program size...</div>
    <div class="meta">Posted on 2004-04-15 03:32:55 by f0dder</div>
   </div>
   <div class="post" id="post-139590">
    <div class="subject"><a href="#post-139590">That's why there is machine code</a></div>
    <div class="body">f0dder</div>
    <div class="meta">Posted on 2004-04-20 14:12:28 by mrgone</div>
   </div>
   <div class="post" id="post-139593">
    <div class="subject"><a href="#post-139593">Well I'm confused on a few issues</a></div>
    <div class="body">First of all I would think waiting for a reply would take longer than the assumption that goes with clock synchronicity.<br />   Second, if the is no external interrupt triggering mechanism than how does this keyboard work if only internal registers can trigger software interrupts? Is it a polling method?<br />   Is this all theory or do you have some working proto-types where some of this has been proven?<br />   Also in the stack, can you point past the bottom or is it just push/pop?</div>
    <div class="meta">Posted on 2004-04-20 14:31:55 by mrgone</div>
   </div>
   <div class="post" id="post-139617">
    <div class="subject"><a href="#post-139617">The WIZ</a></div>
    <div class="body">mrgone, thanks for your questions.<br /><br />As to waiting, two points. First, the most common case is where both registers are &quot;ready&quot; even before the instruction begins. In this case, the ready bits are high even as we begin driving the bus, so in reality there is no wait for anything, the bus just &quot;goes&quot;.<br /><br />Secondly, a device like an adder or multiplier &quot;knows&quot; when it is done and can generate a ready signal. Waiting for this signal isn't like waiting for some far off buffered device transmitting a signal down a cable -- we are talking about a single transistor driving a short line from one spot to another within a chip. When the adder goes ready, it pulls that line high, and a single AND gate says both ready's are high and the frontend moves to the next instruction. This is literally picoseconds, the time of a single gate delay and a short transmission delay.<br /><br />You said &quot;waiting for a reply would take longer than the assumption that goes with clock synchronicity.&quot; The assumption that goes with clock synchronicity is that the clock has to be calibrated to the worst case add. An adder speced to say 5 ns can probably vary anywhere from 2 to 5 ns, with 5, the spec, being its worst case (adding a zero is a lot faster than adding all ones). But it would have to be clocked with a 5 ns clock always. The time spent &quot;waiting&quot; for a reply is picoseconds. Surely worth the extra few picosends to save nanoseconds.<br /><br />Now, to your question: &quot; if there is no external interrupt triggering mechanism than how does this keyboard work if only internal registers can trigger software interrupts?&quot;.<br /><br />Well, the keyboard is connected to an internal register, which in turn causes the interrupt. There would probably be a keyboard-status register, a keyboard-lastKeyPressed register, and maybe a keyboard-interruptAddress register. If the status register said we are enabled, and a key was pressed, we'd latch it into the lastKeyPressed register and flag an interrupt.<br /><br />I am still working on the &quot;Interrupts&quot; page, so I should be more clear on it (hey, the page does say &quot;This page very much under construction&quot;). Of course there can be external interrupt lines. I'm just saying they don't connect directly to the frontend interrupt mechanism, they go through some logic. On most all processors this is also true, but the logic is thought of as being part of the machine rather than seperated into a frontend and a backend in registers. Minimally, you want to AND the interrupt with an &quot;enable&quot; status bit, so you can control it. Most processors have some soft of &quot;interrupt controller&quot; which minimally checks enable status, and also handles some simple priority schemes, etc. On the WIZ, this is the backend logic of the &quot;Interrupt-status&quot; register, if you want one. That's all I meant by the comment that a register causes an interrupt, not an external line. There IS an external line, it just goes &quot;through&quot; a register on its way to the front-end trigger.<br /><br />On a truely minimal WIZ implimentation, you could have a single interrupt line which goes straight to the frontend interrupt latch, it would be a non-maskable interrupt, and you'd also have no interrupt-address register, so you'd have to default to something like location 0 for the handler. That would all be ok, and actually, since I do intend the WIZ for a niche of minimal applications (WIZ in a shoe to count steps), it might even be common. I will change my &quot;Interrupt&quot; section to note this -- thanks for the question...<br /><br />Now, on to &quot;in the stack, can you point past the bottom or is it just push/pop?&quot;. No, it is just push/pop. You don't point to it at all. There is no stack pointer, the &quot;stack&quot; is a single register. You write to it to push, read from it to pop. It handles the rest independantly.<br /><br />Now this is a hardware supplied stack, the advantage of which is that it can be blazingly fast (it runs at internal flip-flop speed instead of memory speed). The STACK is another register which would typically be &quot;ready&quot; even before the instruction to load it started, and so would run at full WIZ speed. (Although, to be fair, a deep set of pushes which overflowed the hardware buffer size will slow it down to memory speed again, but we hope that won't happen much.)<br /><br />You can ALSO create a &quot;regular&quot; stack if you want: you use a register as a pointer, point to a section of memory, you increment/decrement the pointer, etc. That works too. I just wanted to ALSO provide a hardware stack because straight push/pop operations are common and could benifit greatly from a speedup.<br /><br />And finally, it would be possible to implement a STACK hardware register that worked more like &quot;tranditional&quot; ones, which we be a bit faster and easier than doing it all yourself, but still basically limited to memory speeds.<br /><br />Accessing the n'th item down the stack, in a direct manner, is often used to retreive arguments in many argument passing conventions. While you could still do that, I would put forth that because the hardware stack is so much faster than a memory based stack, if you adopted a slightly different protocal in subroutines you would still benifit greatly. That would be, push stuff on the stack as always, but in the subroutine header, instead of accessing the stack directly and then decrementing the stack pointer by N before returning, you could just do &quot;T1 &lt;= STACK; T2 &lt;= STACK; T3 &lt;= STACK; etc; TN &lt;= STACK;&quot; where TN = N'th temp register and N = number of arguments. If N isn't too large, this is still going to be way faster than memory accesses, I think.<br /><br />Finally, yes, I have no bananas. This is all theory. Well, I have written an assembler and emulator, and successfully executed code, but that emulator is at register level not at gate level and embodies no circuitry or timing. All I have used it for is to test basic programming concepts, like can you write a sort algorithm with this register set, etc.). I'm looking for funding to build a prototype. If you know anywone with a spare couple of hundred thousand dollars, please let me know!!!!<br /><br />Steve.</div>
    <div class="meta">Posted on 2004-04-20 20:10:28 by Steve Bush</div>
   </div>
   <div class="post" id="post-139688">
    <div class="subject"><a href="#post-139688">Yeah I hear ya...</a></div>
    <div class="body">Well it sure sounds like you got your ducks in a row. This may be a rediculous question but you do have these concepts patented? If all works out in theory than I would think your on to something. I may have some contacts for you. I wish I were envolved in this actually. It sounds so interesting. I've always wanted to get my hands on the Xsistor schematics of say Intel's 4004. There are some circuits I'm not sure of like the Z80's micro-program controller and it's rival counterparts, you know, other processors. I beleive it's just an internal ROM but what does the program do? We want source code...lol.<br /><br />P.S.<br />I like that name &quot;temp register&quot;, it's sounds better than the accumulator or ich..the W register.</div>
    <div class="meta">Posted on 2004-04-21 14:35:09 by mrgone</div>
   </div>
   <div class="post" id="post-139703">
    <div class="subject"><a href="#post-139703">The WIZ</a></div>
    <div class="body">As  I have posted lots of details of the WIZ on the www for several years, it cannot be patented. It is freely available for anyone to steal! I'm not too worried; (1) its hard enough to get anybody to be as interested in it as I am, and (2) its not cheap to manufacture a processor, only a bigco (intel, ibm, arm) has the capital to really do it right, and they are so locked in to their own hell, er I mean, way of doing things, that they wouldn't be interested. So I just post it all!<br /><br />I have found a business partner and market niche (a small, radio-linked, self powered wiz processor embedded in primitive devices like switches, sensors, motors, etc, which would then be OEM'd to refridgerator manufactures and the like), and we are looking for funding to do it ourselves. Actually, I think I could get it manufactured in slow and minimal form on a FPGA or some such thing, for something like $20 thousand. But I also need a salary for myself for a year! And then we have to market it, that means another person's salary. Probably $250,000 is minimum to &quot;startup&quot;, for first year, and then you don't even get a product until second year, etc, etc.<br /><br />So right now, it remains a spare time &quot;hobby&quot;. If you are interested, I'd be happy to talk more. But as Tom Cruise put it, &quot;Show me the money!&quot; is the bottom line!<br /><br />Another option is for me to walk into a bigco, especially ARM, and say, &quot;hire me and let me develop this product for you&quot;. I'm not looking to make millions, I just want a good job and a steady salary. And maybe a piece of the profits in the deal... That is kinda my backup plan.<br /><br />PS: Our very rough draft &quot;business proposal&quot; is here:<br /><a target="_blank" href="http://www.steve.bush.org/WizdomR&amp;D/WIZObjectProp04012004.doc">http://www.steve.bush.org/WizdomR&amp;D/WIZObjectProp04012004.doc</a></div>
    <div class="meta">Posted on 2004-04-21 17:04:39 by Steve Bush</div>
   </div>
   <div class="post" id="post-139768">
    <div class="subject"><a href="#post-139768">Once again I hear ya</a></div>
    <div class="body">Yeah, unfortunately the people I know won't budge without a patent. I'm persuing another patent right now. Also if you need help with anything let me know. I'm an old hand with RF. One of my patents is an RF product. I don't see why you culdn't begin a patent because you know AMD copies everything Intel makes. Do a seach on new concepts of processor and if not submitted than start it. Your investors will be wanting something unique with some protection to go along with it.</div>
    <div class="meta">Posted on 2004-04-22 11:03:05 by mrgone</div>
   </div>
   <div class="post" id="post-139801">
    <div class="subject"><a href="#post-139801">The WIZ</a></div>
    <div class="body">I've talked to some patent lawyers about this. The thing is, I have fully disclosed everything on the internet for several years. This makes it un-patentable, as I have legally shown my intent to &quot;give it all away&quot;. Besides, with a wierd sort of notion of honor, I dont want a patent. I think science should be freely shared. Note the &quot;copyleft&quot; symbol at the bottom of all my pages. You can click on it to read the definition of what that means; but it basically means &quot;Please copy - copy all you want! (just don't take it out of context and always continue to give me credit)&quot;.<br /><br />Anyway, thanks for your support. Check out my website from time to time and I'll keep you posted on the latest developments!<br /><br />Steve.</div>
    <div class="meta">Posted on 2004-04-22 15:07:24 by Steve Bush</div>
   </div>
   <div class="post" id="post-139815">
    <div class="subject"><a href="#post-139815">The WIZ</a></div>
    <div class="body">The MASM Forum thread may be done, but at least this one isn't.</div>
    <div class="meta">Posted on 2004-04-22 19:07:44 by NoDot</div>
   </div>
   <div class="post" id="post-139823">
    <div class="subject"><a href="#post-139823">The WIZ</a></div>
    <div class="body">I have an idea to start a new thread... But I'm at my day job now, it'll have to wait until tonight...<br /><br />New thread coming! News at 11...</div>
    <div class="meta">Posted on 2004-04-22 20:08:46 by Steve Bush</div>
   </div>
   <div class="post" id="post-139856">
    <div class="subject"><a href="#post-139856">The WIZ</a></div>
    <div class="body">Sorry, no time... Answered the thread in the MASM forum instead.<br /><br />I was thinking of starting a new thread more like:<br /><div class="quote">Dear friends: I have this processor, I call it the WIZ, its not x86 compatible, and it has this funny assembler language. I want to test the language and see if it is hard or easy to express various snippets of code. I want to see if I left anything out, like if there's something that can't be done or is hard to do.<br /><br />So what I'm looking for you to do to help me is to submit to me some little snippet of asm code, and I'll try to re-code it in WIZ assembler language. Just to see if I can, if it takes too many instructions, if it is hard, etc. And please give me a higher level description (like C equivalent) too, so I know what it's *supposed* to do! I'm not an x86 asm programmer, but I can follow it ok. But this isn't a contest to see if I can figure out your ingenious code - please make it some *simple* stuff!<br /><br />I'll start by posting this bubble sort algorithm from the Art of Assembly Language. Here is my version:<br /><br />... cut/paste here ...<br /><br />and here is the asm version:<br /><br />... cut/paste here ...<br /><br />OK, now its your turn. Anybody got a (preferrably very small and simple) snippet of code for me to try?</div><br />What do you think, would that make a good post? What section of the forum should I post it in?<br /><br />Steve.</div>
    <div class="meta">Posted on 2004-04-23 04:23:07 by Steve Bush</div>
   </div>
   <div class="post" id="post-139858">
    <div class="subject"><a href="#post-139858">The WIZ</a></div>
    <div class="body">Hi<br /><br />This is my code :<br />movaps ,xmm0<br /><br />What it does is a (aligned) 16-byte copy to memory, from an XMM register (128 bits).<br />I do not remember the number of bits you intend to implement. 256 would be great, for ASCII chars for example, and for a full 1-byte handling.<br /><br />Another one :<br />pmovmskb eax,mm0. IIRC, AMD64 made the same with xmm0. Here mm0 is 8 bytes.<br />What it does :<br />it takes the highest bit of each byte of mm0 (8 bytes).<br />It puts these to al (8-bit lower part of 32-bit eax) and zeroes the 24 other bits.<br /><br />Another one :<br />pminub mm0,mm1<br />It does 8 (unsigned byte) min() operations on each byte of mmX registers.<br /><br /><br />I fear that for MMX/XMM emulations, your asm takes dozens of instructions :( <br /><br />Regards</div>
    <div class="meta">Posted on 2004-04-23 05:36:03 by valy</div>
   </div>
   <div class="post" id="post-139891">
    <div class="subject"><a href="#post-139891">Put it in the heap</a></div>
    <div class="body">The heap is group discussions on nothing specific or your own subject. Everyone checks it from time to time. Give it a whirl.</div>
    <div class="meta">Posted on 2004-04-23 09:39:48 by mrgone</div>
   </div>
   <div class="post" id="post-151048">
    <div class="subject"><a href="#post-151048">The WIZ</a></div>
    <div class="body">What if I want to connect a synchronous device to yours?<br /><br />Hmm okay maybe put some kind of sync that the async logic treats as a flag.<br /><br />Pure async design is rarely found in digital design, because it's very difficult.<br /><br />By the way I think I designed a theoretical ALU with a few similarities to your ISC, except that I have no registers at all (I control data paths through the ALU, selecting where each portion of the ALU connects to which subcomponent).  It wouldn't be a full processor.<br /><br />However how about this suggestion, that we separate the backend and frontend, and put all the backend into such a reconfigurable ALU?  We have a set of registers, then we have a reconfigurable ALU? Each portion of the reconfigurable ALU has an &quot;ENABLE IN&quot; input which goes through a bunch of inverters for delay, with at least one delay further than the expected delay from that circuit?  This &quot;ENABLE OUT&quot; output connects to the &quot;ENABLE IN&quot; of the next portion of the ALU (since the ALU is reconfigurable) which would then signal to the next stage to begin.  When the ENABLE OUT signal finally reaches the last ALU portion, we know the ALU has completed and we can then load the destination register.  Then the instruction simply defines the configuration of the ALU, and perhaps which of the registers the destination goes to.<br /><br />The major problem would be the registers racing, which is the main problem with async design.  The design becomes more and more like analog design (with registers becoming amplifiers with feedback) when you use async design, because the voltages cannot settle quite as decently as when we have well-defined starts and stops.</div>
    <div class="meta">Posted on 2004-10-07 04:17:15 by AmkG</div>
   </div>
   <div class="post" id="post-154171">
    <div class="subject"><a href="#post-154171">The WIZ</a></div>
    <div class="body"><strong>steve</strong>,<br />Just out of curiosity but how is your processor thing going?<br />Are u a millionare already? :)</div>
    <div class="meta">Posted on 2004-12-14 17:59:37 by clippy</div>
   </div>
  </div>
 </body>
</html>