<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Improving my TerrainEngine - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=22578" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=22578">Improving my TerrainEngine</a></p>
   <div class="post" id="post-169355">
    <div class="subject"><a href="#post-169355">Improving my TerrainEngine</a></div>
    <div class="body">——————————————————————————————————————————————————————————————————————————————————————————————————<br />Title - Terrain Engine 2.0 - a new beginning.<br />Dated - Jan. 6, 2006<br />Author- EvilHomer<br /><br />This document describes a proposed system for storing<br />terrain tile data suitable for dynamic loading with respect<br />to the 2D implementation of SuperFrustum Algorithm.<br /><br />Refer to the following URL:<br />http://www.gamedev.net/reference/articles/article2012.asp<br /><br />——————————————————————————————————————————————————————————————————————————————————————————————————<br />DESCRIPTION OF RESOURCES<br />——————————————————————————————————————————————————————————————————————————————————————————————————<br />The bitmap data for our terrains is originally sourced from<br />several 512x512x8 images. Each of these can be imagined<br />as a grid of 16x16 Tiles, each Tile being 32x32 Pixels.<br /><br />A PAGE OF TERRAIN TILES IS SOURCED FROM A BITMAP.<br /><br />As a preprocessing step, we parcel these bitmaps on a per-Tile<br />basis, creating 256 small bitmaps, which are saved to disk<br />in raw format (without bitmap headers).<br />The filenames given to a Tile&#39;s bitmap indicates which Page<br />it belongs to, and its array coordinates on that Page.<br /><br />TERRAIN TILES ARE STORED ON DISK WITH MEANINGFUL NAMES.<br /><br />The reason we do this is to enable us to load ONLY the<br />bitmap data required for a particular Tile, rather than being<br />forced to load and unload entire Pages unnecessarily.<br />Furthermore, this enables us to INSTANCE terrain tiles.<br /><br />There exists a MASTER TILEMAP which describes the entire<br />terrain. It is a large 2D array of TILE REFERENCES,<br />which include Tile Identifiers and Material/Texture info.<br />This array of data is stored permanently on disk.<br />The extents of the Master TileMap are predetermined<br />for a given &quot;game level&quot;, and are Wrapped in order to<br />create an illusion of continuity within the game.<br /><br />There also exists a RUNTIME TILELIST which stores a list<br />of data objects from the Master map in memory at runtime.<br />This list includes ONLY those Tiles which are either<br />partially or totally within the Camera View Frustum.<br />This list is dynamically updated during runtime.<br /><br />——————————————————————————————————————————————————————————————————————————————————————————————————<br />DESCRIPTION OF REQUIREMENTS<br />——————————————————————————————————————————————————————————————————————————————————————————————————<br />Everything hinges on the ability to determine the View Frustum.<br />We simply MUST be able to extract a Frustum from the Camera&#39;s<br />current View Matrix.<br />Note that the SuperFrustum is created by first finding<br />the absolute extents of the Frustum on the XZ plane <br />(view from above) and then extending them slightly.<br />This should always yield a large 2D Triangle (please<br />refer to the bottom image at the URL previously given).<br /><br />We generate from the Frustum a list of Tile Identifiers for<br />those Tiles which are within the Frustum.<br />This list is then applied as an inclusive filter to<br />the RunTime TileList in order to identify:<br />-which Tiles need to be dynamically Loaded<br />-which Tiles need to be dynamically UnLoaded<br /><br />We now dynamically update the RunTime TileList.<br />Are we now ready to Render the list?<br />That depends on one more design consideration:<br />Do we tesselate the terrain tiles dynamically when loaded,<br />or do we store geometry data within each Tile datafile? <br /><br />This is really a tradeoff between size and speed.<br />The former requires more cpu time, while the latter<br />requires more disk storage.<br /><br />We must note that if we intend to store geometry within<br />each Tile datafile, that geometry does not use Absolute<br />(World-Relative) coordinates, they are relative to<br />the Origin of that Tile, so that Tiles retain the ability<br />to be Instanced at various locations.<br /><br />This way, a vast grassy plain can be created by simply<br />instancing ONE tile in SEVERAL locations.<br /><br />At runtime, each Tile is transformed into position<br />via a translation matrix, and then rendered in situ.<br /><br />The cost of doing this is that collision detections<br />must be performed relative to each Tile being rendered.<br />That is to say, each IntersectionTest Ray must be<br />tranformed into &quot;tile model space&quot; prior to testing.<br /><br />——————————————————————————————————————————————————————————————————————————————————————————————————<br />I am keen to hear feedback regarding this proposal.<br />Do you foresee problems?<br />Can you suggest improvements?<br /><br /><br /></div>
    <div class="meta">Posted on 2006-01-06 00:54:12 by Homer</div>
   </div>
   <div class="post" id="post-169357">
    <div class="subject"><a href="#post-169357">SPLINE TESSELATION OF TERRAIN TILES</a></div>
    <div class="body">SPLINE TESSELATION OF TERRAIN TILES<br /><br />I have an extension of this proposal to describe.<br />It is possible to implement runtime (but not quite realtime) tesselation of the terrain tiles which support Dynamic Level of Density (DLOD) and based on catmull-rom splines.<br />Catmull-Rom splines create smoother curves than any other algo I know of, and require far fewer control-points than for example a cubic bezier spline.<br /><br />Before I go into detail, let&#39;s step back outside of the terrain for a moment.<br />We effectively have a large 2D array of heightmap values which correspond directly to pixels sourced from a large bitmap (or a number of smaller bitmaps, stitched together).<br />Furthermore, each heightmap value corresponds to a terrain vertex.<br />Finally, each four terrain vertices correspond to a terrain tile.<br /><br />Terrain tiles are NOT simply geometric quads.<br />They are larger, each terrain tile describes four control points between which we would normally interpolate to create a mesh of quads whose level of densite (LOD) is 1/N<br /><br />EG for LOD=1, no interpolation takes place, the Tile describes a geometric quad.<br />But for LOD=2, we interpolate such that the Tile describes FOUR geometric quads.<br />And for LOD=3, we interpolate such that the Tile describes NINE geometric quads.<br /><br />Simply interpolating quadmeshes ourselves is fine, but we can create a much smoother terrain if we use Catmull-Rom splines to interpolate the mesh.<br /><br />CatmullRom splines each require AT LEAST four control points.<br />This means that we can&#39;t create geometry using the outermost pixels on the heightmap (unless we wrap the heightmap, which I already stated that we will).<br />We can consider that each Edge of a Tile represents two controlpoints of a Spline, with the other ControlPoints belonging to the neighbouring Tiles.<br />With that in mind, we can imagine a 3D surface which is defined by interpolating between these Edge Splines.<br /><br />The following crap ascii art describes how eight heighmap values are required to create four edge splines. The Tile we are interested in is the middle one.<br /><br />#=Vertex defining the corners of our Tile<br />@=Vertex belonging to a Neighbour Tile<br />O=Vertex we don&#39;t care about<br /><br />O-------@-------@-------O<br />|&nbsp; &nbsp; &nbsp; &nbsp;  |&nbsp; &nbsp; &nbsp; &nbsp;  |&nbsp; &nbsp; &nbsp; &nbsp; |<br />|&nbsp; &nbsp; &nbsp; &nbsp;  |&nbsp; &nbsp; &nbsp; &nbsp;  |&nbsp; &nbsp; &nbsp; &nbsp; |<br />@-------#--------#-------@<br />|&nbsp; &nbsp; &nbsp; &nbsp;  |&nbsp; &nbsp; &nbsp; &nbsp;  |&nbsp; &nbsp; &nbsp; &nbsp; |<br />|&nbsp; &nbsp; &nbsp; &nbsp;  |&nbsp; &nbsp; &nbsp; &nbsp;  |&nbsp; &nbsp; &nbsp; &nbsp; |<br />@-------#--------#-------@<br />|&nbsp; &nbsp; &nbsp; &nbsp;  |&nbsp; &nbsp; &nbsp; &nbsp;  |&nbsp; &nbsp; &nbsp; &nbsp; |<br />|&nbsp; &nbsp; &nbsp; &nbsp;  |&nbsp; &nbsp; &nbsp; &nbsp;  |&nbsp; &nbsp; &nbsp; &nbsp; |<br />O-------@-------@-------O<br /><br />In order to reduce cpu overhead, we only tesselate Tiles if their LOD changes (and logically, this will occur when they are created/loaded).<br />As the player&#39;s camera moves about the world, we can increase and decrease the LOD of each Tile based on the distance from the Camera&#39;s origin.<br /><br />Having determined that we can quite easily describe the Edge Splines of each Tile, it should also be obvious that we can generate a mesh of any LOD we choose by interpolating along the Edge Splines. Typically, the LOD will be 1, and we can totally ignore everything relating to splines and tesselating, and just describe the geometry for a Tile as two triangles. But when we are closer to a particular Tile, we can increase the LOD dynamically and at relatively low cost.<br />There will be no splitting and joining of triangles as found in the ROAM and some other DLOD algorithms.. and there is little if no incentive in supporting adjacency information.<br />We generate a mesh for each Tile when it is loaded/created, and regenerate it (from its own and the nearest neighbouring controlpoints) ONLY if its LOD is changed.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2006-01-06 06:53:23 by Homer</div>
   </div>
   <div class="post" id="post-169370">
    <div class="subject"><a href="#post-169370">Re: Improving my TerrainEngine</a></div>
    <div class="body">Lets discuss what happens when the user moves or rotates the Camera (changes the view).<br />This should be called &quot;How to dynamically resample a HeightMap based on the Camera View&quot;.<br /><br />When we detect that the view has changed, we rebuild the Frustum (code provided in another thread on this forum). As far as the Terrain is concerned, we are particularly interested in the Vertices which form the corners of the Frustum, rather than its Planes.<br /><br />Having determined the eight 3D vertices of the Frustum, our first mission is to find an imaginary 2D rectangle which encompasses the Frustum on the XZ plane (the top view).<br /><br />This is actually very easy - we find the lowest and highest values in X and Z from all the eight vertices. The resulting 2D vectors are the &quot;topleft&quot; and &quot;bottomright&quot; corners of the imaginary 2D rectangle.<br /><br />Now we have found the region of Terrain we are interested in - right? Wrong.<br />We have eliminated a lot of the world, but we can eliminate more, since we only really care about whats inside the 2D SuperFrustum...<br />Let&#39;s just disregard that fact for now.<br /><br />We are really trying to determine which Terrain ControlPoints are inside our SuperFrustum.<br />In order to do that, we need to know what Scaling factor is being applied to the Terrain.<br />Remember that the ControlPoints are sourced from a bitmap, and multiplied by some scaling factor in order to make the terrain larger in X and Z.<br />We must now do the opposite - if we take our 2D rectangle and divide its 2D coordinates by the scaling factor, we have in fact mapped the viewable Terrain back onto the source bitmap - ie, our rectangle then has a one to one scale against the bitmap, and represents XY pixel coordinates - right? Almost. Assuming that the Terrain was originally centralized so that the World origin is in the middle of the Terrain (by centering the origin of the 2D bitmap), we must again do the opposite - that is, make the 2D coordinates relative to the topleft corner of the bitmap.<br />We&#39;ve done it - our rectangle now encompasses all the pixels on the source bitmap which represent all the ControlPoints in the viewable terrain.<br />We need to make a list of them.<br />Except for the first time we do it, we will have an existing list of them too (here&#39;s one I prepared earlier).<br />We need to compare these lists - we want to identify which controlpoints are no longer viewable, and which are new.<br />For new ones, we must tesselate between them as described in the previous posting, in order to generate renderable geometry.<br />For old ones, we can either toss them out immediately, or via a counter, cache them for a while, until they are well and truly redundant (we also tag them as being offscreen).<br />While we are doing this list filtering, we might also like to compare the distances of each controlpoint to the camera origin. We might decide to modify the level of density of some geometry by re-tesselating it when it becomes close or distant from the camera.<br /><br />Well guys, what do you think?<br /><br /></div>
    <div class="meta">Posted on 2006-01-07 09:25:23 by Homer</div>
   </div>
   <div class="post" id="post-169380">
    <div class="subject"><a href="#post-169380">Re: Improving my TerrainEngine</a></div>
    <div class="body">sounds good<br /><br />use precomputed cos scaled to fit between x-x2 and y-y2 ?<br /><br />question is, shouldnt that look better with lower-resolution map, with more LOD smoothing?<br />and less data to readfromdisk, better performance?<br /></div>
    <div class="meta">Posted on 2006-01-08 05:48:45 by daydreamer</div>
   </div>
   <div class="post" id="post-169382">
    <div class="subject"><a href="#post-169382">Re: Improving my TerrainEngine</a></div>
    <div class="body">No cos is too simplistic, splines are much more hyperbolic - they are curves, not arcs.<br />You have realized that much of the geometry can be generated via the splines - far more than we can describe if we only used the original heightmap (bitmap) data.<br />The size of the entire world is dependant apon the amount of bitmap information we have, and the aim is to handle massive worlds without needing to worry about how much we can store in memory.<br />Rather than stitch together smaller bitmaps and load and unload them dynamically, we can support one extremely large bitmap, and sample it directly from disk on demand - we don&#39;t need to keep it in memory, so we don&#39;t need to split it up, and the load times are more constant - there is no &quot;pause&quot; while we move from one section of world to another, as there is no need to load and unload resources (I am speaking purely about the terrain here).<br /><br /></div>
    <div class="meta">Posted on 2006-01-08 07:41:47 by Homer</div>
   </div>
   <div class="post" id="post-169384">
    <div class="subject"><a href="#post-169384">Re: Improving my TerrainEngine</a></div>
    <div class="body"><div class="quote"><br />No cos is too simplistic, splines are much more hyperbolic - they are curves, not arcs.<br />You have realized that much of the geometry can be generated via the splines - far more than we can describe if we only used the original heightmap (bitmap) data.<br />The size of the entire world is dependant apon the amount of bitmap information we have, and the aim is to handle massive worlds without needing to worry about how much we can store in memory.<br />Rather than stitch together smaller bitmaps and load and unload them dynamically, we can support one extremely large bitmap, and sample it directly from disk on demand - we don&#39;t need to keep it in memory, so we don&#39;t need to split it up, and the load times are more constant - there is no &quot;pause&quot; while we move from one section of world to another, as there is no need to load and unload resources (I am speaking purely about the terrain here).<br /><br /><br /></div><br />I just had my sea-animation almost finished and now I must redo it setting my goal higher, offcourse get rid of cos and create a nice surfwave look<br /><br /><br /></div>
    <div class="meta">Posted on 2006-01-08 11:31:24 by daydreamer</div>
   </div>
   <div class="post" id="post-169390">
    <div class="subject"><a href="#post-169390">Re: Improving my TerrainEngine</a></div>
    <div class="body">I&#39;ve recently been working with dx9, helping with a vc++ 3d engine, it&#39;s been a challenge since I have zero prior knowledge about game/3d/directx developement.<br /><br />I have some questions,<br /><br />What kind of vertex format and texturing for your terrain engine are you thinking about? How will rendering work, index buffered or not?<br /><br />Resampling a heightmap every view change wouldn&#39;t you also have to recalc any detailing texture coordinates as well? I&#39;d think this would be too cpu intensive. Unless you used a large terrain texture (in which case the texture coordinates would be static) and then some sort of vertex shadar for detail?<br /><br />While your culling using the frustum, would the camera orientation affect the efficiency of the implementation? For instance the camera moving along the ground&#39;s rectangle would be different vertices then if the camera was on top of a hill looking downward. This type of situation would force you to interpolate using all the vertices.<br /><br />Would you be able to implement collision detection or physics (simple gravity even) with this (load as you go) type of terrain engine. For instance if geometry was moving from out of the view into view since out of view vertices may not be loaded yet.<br /><br />I ask only because these questions will most likely come up with I&#39;m asked to &#39;hack&#39; together a terrain engine for the project I&#39;m working on.</div>
    <div class="meta">Posted on 2006-01-08 18:31:10 by r22</div>
   </div>
   <div class="post" id="post-169391">
    <div class="subject"><a href="#post-169391">Re: Improving my TerrainEngine</a></div>
    <div class="body"><div class="quote">What kind of vertex format and texturing for your terrain engine are you thinking about? How will rendering work, index buffered or not?</div><br /><br />I intend to use an fvf which incorporates pervertex normals for better lighting, and several sets of uv values for texture layering. The geometry is stored as trianglestrips but as for indexing, it will likely be unnecessary since we don&#39;t have copious amounts of vertex data to contend with (unless we are moving very fast).<br /><br /><div class="quote">Resampling a heightmap every view change wouldn&#39;t you also have to recalc any detailing texture coordinates as well? I&#39;d think this would be too cpu intensive. Unless you used a large terrain texture (in which case the texture coordinates would be static) and then some sort of vertex shadar for detail?</div><br /><br />The uv values for terrain detail textures are to be precalculated and stored in a separate file, and streamed similarly to the heightfield data. They are static, and only the uv values at the controlpoints need to be recalled, all other uv values are calculated at runtime, but only when the LOD of a given terrain tile changes (if DLOD is enabled). &quot;Splat&quot; textures are another story.<br /><br /><div class="quote">While your culling using the frustum, would the camera orientation affect the efficiency of the implementation? For instance the camera moving along the ground&#39;s rectangle would be different vertices then if the camera was on top of a hill looking downward. This type of situation would force you to interpolate using all the vertices.</div><br /><br />We are not culling using the frustum, we are using the frustum as a boundary for dynamic resampling. We only need to sample the controlpoints which are new to the current frame, and we are only interpolating geometry associated with new controlpoints. Frustum culling implies that we have loads of geometry in memory at any given time, this is what we are trying to avoid!!!<br />Changing the camera orientation quickly would pose a problem for this method if there was no caching of controlpoints (and geometry) which has recently become old, ie, moved offscreen.<br /><br /><div class="quote">Would you be able to implement collision detection or physics (simple gravity even) with this (load as you go) type of terrain engine. For instance if geometry was moving from out of the view into view since out of view vertices may not be loaded yet.</div><br /><br />Setting the threshold for caching of geometry relative to the maximum angular and linear velocities of the camera solves this problem. If we allow the camera to move about too quickly, we are forced to cache more, and could soon find ourselves running out of memory. On the other hand, if we slow the player down too much, the game will not &quot;feel right&quot;. Tweaking the caching threshold thus becomes a matter of high importance. <br /><br />I&#39;m pretty braindead at the moment, I hope I answered at least some of your questions.<br />The most important message I&#39;m trying to convey is that we only tesselate terrain which has just become visible (or has changed lod), and we cache geometry which has just gone offscreen.. we don&#39;t want game enemies disappearing when we turn our back on them because the terrain they were &quot;standing on&quot; has disappeared!! We&#39;re not streaming actual geometric data, just controlpoints. We&#39;re not tesselating anything that is already or was recently visible and that has not changed its lod.<br /><br />When I say we are streaming controlpoints, specifically we are streaming height values and uv values.<br />The X and Z values of controlpoints are implicit.<br /><br />This schema has not been applied before to my knowledge, except in regards to medical imaging, where huge amounts of data must be visualized in realtime. I&#39;m yet to code much of it, so all of this is theory, open to interpretation and suggestion.We are simply trying to get away from the chessboard mentality of quadtrees and the static nature of bsp and do something new.<br /> <br /><br /></div>
    <div class="meta">Posted on 2006-01-08 19:54:01 by Homer</div>
   </div>
   <div class="post" id="post-169521">
    <div class="subject"><a href="#post-169521">Re: Improving my TerrainEngine</a></div>
    <div class="body">collision detection: scan a ray in the vector you move<br />heightmap data reworked from ymap to ydeltamap could result in smaller data?<br />anyway you stand on one tile, while surrounding tiles are already coded in relative height to that<br />ybuffer for culling terrain behind hills<br />textureorganizing:<br />settexture uses pointer as input for each texture<br />an array 0-255 of these<br />and terrains texturedata=byte that is offset in this array<br />which also works with alternative textureorganizing of different material in same texture, just using different UV coordinates<br />how does it look if outdoor lightmaps are using paletteanimation and fades between daylight, sunset colors, nighttime moonlight?<br /><br /><br /></div>
    <div class="meta">Posted on 2006-01-14 04:23:47 by daydreamer</div>
   </div>
   <div class="post" id="post-169538">
    <div class="subject"><a href="#post-169538">Re: Improving my TerrainEngine</a></div>
    <div class="body">In order to implement &quot;daylight&quot;, just modify the AMBIENT lighting.<br />Ambient light affects the appearance of everything, and therefore this will affect the appearance of your lightmap texturing.<br />For example, at night, make the ambient lighting a more BLUE colour, and at sunset and sunrise, make it a warmer orange/red colour.<br />Now write a simple procedure to interpolate the &quot;daytime&quot; colour according to the time of day, and just call it once every few &quot;hours in gametime&quot; to update the ambient lighting.<br /><br />If the virtual lightsource associated with a lightmap is switched off, don&#39;t render the lightmap.<br /></div>
    <div class="meta">Posted on 2006-01-14 21:36:58 by Homer</div>
   </div>
   <div class="post" id="post-179578">
    <div class="subject"><a href="#post-179578">Re: Improving my TerrainEngine</a></div>
    <div class="body"><div class="quote"><br />In order to implement &quot;daylight&quot;, just modify the AMBIENT lighting.<br />Ambient light affects the appearance of everything, and therefore this will affect the appearance of your lightmap texturing.<br />For example, at night, make the ambient lighting a more BLUE colour, and at sunset and sunrise, make it a warmer orange/red colour.<br />Now write a simple procedure to interpolate the &quot;daytime&quot; colour according to the time of day, and just call it once every few &quot;hours in gametime&quot; to update the ambient lighting.<br /><br />If the virtual lightsource associated with a lightmap is switched off, don&#39;t render the lightmap.<br /><br /></div><br />I have experimented earlier in C++ with those dx light examples, general ambient lighting look so dull, I wanted to experiment to turn greyscale on lightmaps to some yellow/orange/red spectrum<br /><br />played oblivion, wonder if you have tons of animated grass in some part of the terrain, cant you turn down LOD below that if you dont see much of it anyway and a plain grass area dont need so many polys<br /></div>
    <div class="meta">Posted on 2006-04-14 03:30:08 by daydreamer</div>
   </div>
  </div>
 </body>
</html>