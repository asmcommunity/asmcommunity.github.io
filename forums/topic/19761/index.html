<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>bitstreams - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19761" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=19761">bitstreams</a></p>
   <div class="post" id="post-151963">
    <div class="subject"><a href="#post-151963">bitstreams</a></div>
    <div class="body">Hi,<br />I posted this on fasm forum, but (as roticv suggested) I posted it here too. Hope you will help me... :wink:<br /><br />Bitstream is a small library for reading/writing on single bit. I wrote it for my LZSS compressor (it's easiest to achieve bigger compression ratio when you operate on single bits). Bitstreaming isn's a critical part of whe whole algo, but optimizing it could make whole compressor faster. Here I attach two functions: one that stores bits in a bit stream, and the other that reads them.<br />Could you help me in making some speed improvements to these functions? Maybe there is some other way that would be faster?<br /><br />Here's a short description of the algorithm I used:<br />- BitStream is a structure that contains all data needed to do streaming:<br /><pre><code>struct BitStream<br />  .buf dd ?<br />  .ptr dd ?<br />  .bit_ptr dd ?<br />ends</code></pre><br /><strong>.buf</strong> is a pointer to the first byte of the stream<br /><strong>.ptr</strong> points on a current DWORD<br /><strong>.bit_ptr</strong> is an bit offset relative to the .ptr<br /><br />function <strong>BitsPut</strong> stores given number of given bits into the stream, and then fixes [.ptr] and  members. It can write at most 32 bits into the stream.<br /><strong>BitsGet</strong> reads given number of bits, and moves the pointer too.<br />Both functions firstly generate bit mask that is used to store bits, then they actually write them. The complexity comes because bits to be stored can &quot;cross&quot; two DWORDs.<br /><br />So, could you make any improvements? I would be really grateful... <br />If you want to see how the bitstreams work in a real program, then just download <a target="_blank" href="http://decard.net/download/lzss.zip">lzss library and test code</a>. <br /><br />thanks,<br />decard<br /><br /><pre><code>; puts given number of bits into stream<br />proc BitsPut, .stream,.bits,.bit_count<br />        begin<br />        push    eax ebx ecx edx esi edi<br />        ; generate mask in edi&#58;esi<br />        xor     eax,eax<br />        dec     eax<br />        mov     esi,eax<br />        mov     edi,eax<br />        mov     ebx,&#91;.stream&#93;<br />        mov     ecx,&#91;.bit_count&#93;<br />        shl     esi,cl<br />        mov     ecx,&#91;ebx+BitStream.bit_ptr&#93;<br />        shld    edi,esi,cl<br />        shld    esi,eax,cl<br />        ; load new bits into edx&#58;ecx; at this point ecx==&#91;ebx+BitStream.bit_ptr&#93;<br />        xor     edx,edx<br />        mov     eax,&#91;.bits&#93;<br />        shld    edx,eax,cl<br />        shl     eax,cl<br />        mov     ecx,eax<br />        ; finally, store new bits using<br />        mov     ebx,&#91;ebx+BitStream.ptr&#93;<br />        and     &#91;ebx&#93;,esi<br />        or      &#91;ebx&#93;,ecx<br />        add     ebx,4<br />        and     &#91;ebx&#93;,edi<br />        or      &#91;ebx&#93;,edx<br />        ; and fix the pointers<br />        mov     ebx,&#91;.stream&#93;<br />        mov     eax,&#91;.bit_count&#93;<br />        add     &#91;ebx+BitStream.bit_ptr&#93;,eax<br />        cmp     &#91;ebx+BitStream.bit_ptr&#93;,32<br />        jb      .finish<br />        sub     &#91;ebx+BitStream.bit_ptr&#93;,32<br />        add     &#91;ebx+BitStream.ptr&#93;,4<br />      .finish&#58;<br />        pop     edi esi edx ecx ebx eax<br />        return<br />endp<br /><br />; reads given number of bits form the stream<br />proc BitsGet, .stream,.bit_count<br />        begin<br />        push    ebx ecx edx esi<br />        ; generate mask &#40;in esi&#41;<br />        xor     esi,esi<br />        dec     esi<br />        mov     ecx,&#91;.bit_count&#93;<br />        shl     esi,cl<br />        not     esi<br />        mov     ebx,&#91;.stream&#93;<br />        mov     eax,&#91;ebx+BitStream.ptr&#93;<br />        mov     edx,&#91;eax+4&#93;<br />        mov     eax,&#91;eax&#93;<br />        mov     ecx,&#91;ebx+BitStream.bit_ptr&#93;<br />        shrd    eax,edx,cl<br />        and     eax,esi<br />        ; fix the pointers<br />        mov     ebx,&#91;.stream&#93;<br />        mov     edx,&#91;.bit_count&#93;<br />        add     &#91;ebx+BitStream.bit_ptr&#93;,edx<br />        cmp     &#91;ebx+BitStream.bit_ptr&#93;,32<br />        jb      .finish<br />        sub     &#91;ebx+BitStream.bit_ptr&#93;,32<br />        add     &#91;ebx+BitStream.ptr&#93;,4<br />     .finish&#58;<br />        pop     esi edx ecx ebx<br />        return<br />endp</code></pre></div>
    <div class="meta">Posted on 2004-10-28 11:03:05 by decard</div>
   </div>
   <div class="post" id="post-151969">
    <div class="subject"><a href="#post-151969">bitstreams</a></div>
    <div class="body">For the reading part, Intel has published an application note that shows how to use MMX to read bits from a bitstream. I use a modified version of this method in my jpeg decoder (see the post JPEG decoder beta) I don't even know if it's faster  :)</div>
    <div class="meta">Posted on 2004-10-28 11:57:25 by Dr. Manhattan</div>
   </div>
   <div class="post" id="post-151970">
    <div class="subject"><a href="#post-151970">bitstreams</a></div>
    <div class="body">Bit streams are a native type on x86!<br /><br />BT<br />BTC<br />BTS<br />BTR<br /><br />...nothing else is needed (for a small number of consecutive bits). :)</div>
    <div class="meta">Posted on 2004-10-28 12:21:52 by bitRAKE</div>
   </div>
   <div class="post" id="post-151978">
    <div class="subject"><a href="#post-151978">bitstreams</a></div>
    <div class="body">This should be fast enough, I think:<br /><br />SetBits:<br />push esi<br />mov edx,<br />push ebx<br />mov esi,<br />mov cl,<br />mov eax,edx<br />rol edx,cl<br />shl eax,cl<br />mov ebx,<br />add cl,<br />xor edx,eax<br />or ,eax<br />test cl,32<br />mov ,edx<br />jz nonewdword<br />add ebx,4<br />and cl,31<br />nonewdword:<br />mov ,ebx<br />pop ebx<br />mov ,cl<br />pop esi<br />ret 12<br /><br />GetBits:<br />push esi<br />mov esi,<br />push ebx<br />mov ebx,<br />mov cl,<br />mov eax,<br />mov edx,<br />mov ch,<br />shrd eax,edx,cl<br />xadd ch,cl<br />xor edx,edx<br />inc edx<br />test ch,32<br />jz nonewdword2<br />add ebx,4<br />and ch,31<br />nonewdword2:<br />shl edx,cl<br />mov ,ebx<br />pop ebx<br />dec edx<br />mov ,ch<br />pop esi<br />and eax,edx<br />ret 8<br /><br /></div>
    <div class="meta">Posted on 2004-10-28 14:13:02 by Sephiroth3</div>
   </div>
   <div class="post" id="post-151982">
    <div class="subject"><a href="#post-151982">bitstreams</a></div>
    <div class="body">Hi Sephiroth3,<br />Your code doesn't work :( Something with reading arguments from stack? I will try to fix it, but proably you could find a mistake in your code faster :)<br /><br />bitRAKE:<br />The procedures work on bigger number of bits, so BT instructions aren't optimal in this case, as they can work on single bits only...</div>
    <div class="meta">Posted on 2004-10-28 15:39:23 by decard</div>
   </div>
   <div class="post" id="post-152023">
    <div class="subject"><a href="#post-152023">bitstreams</a></div>
    <div class="body">Ok, now it has to work.</div>
    <div class="meta">Posted on 2004-10-29 11:24:53 by Sephiroth3</div>
   </div>
   <div class="post" id="post-152592">
    <div class="subject"><a href="#post-152592">bitstreams</a></div>
    <div class="body">i have posted this to flat asm board too,<br />i poost it here in case someone interested ( any bugs found are welcome cause i don't see any :)<br /><br /><pre><code><br />; Matrix bitstream functions <br />; here you are, i knew xchg was slow, it could be a size optimization <br />; use rol cx,8 if its faster for your processor <br /><br />write_bitstream&#58;; eax = input bitstream from lsb, edi - ptr to buffer, better if aligned <br />xor ebx,ebx     ; cl  = bit offset 0-31 <br />or ch,ch        ; ch  = number of bits to read\write 0-32 <br />jz .done <br />mov edx,$FFFFFFFF ; 11111111111111111111 <br />rol cx,8   ;xchg cl,ch ; put bit count in cl <br />shl edx,cl ; bit count in cl 11111111111111000000 <br />not edx    ; complement      00000000000000111111 <br />rol cx,8   ;xchg cl,ch ; bit offset in cl <br />shl edx,cl ; offset          00000001111111000000 <br />not edx    ; complement      11111110000000111111 <br />shld ebx,eax,cl ; ebx = upper part <br />shl eax,cl      ; offset eax <br />and &#91;edi&#93;,edx   ; mask out first dword <br />or  &#91;edi&#93;,eax   ; set bits in first dword <br />add cl,ch       ; get second dword number of bits <br />cmp cl,32       ; compare second dword count with 0, <br />jbe .done       ; if second dword not modified then skip <br />sub cl,32       ; get number of bits in second dword <br />mov edx,$FFFFFFFF ; 11111111111111111111 <br />rol cx,8   ;xchg cl,ch        ; put bit count in cl <br />shl edx,cl        ; bit count in cl 11111111111111000000 <br />and &#91;edi+4&#93;,edx   ; mask out first dword <br />or  &#91;edi+4&#93;,ebx   ; set bits in first dword <br />.done&#58;ret <br /><br />read_bitstream&#58;; eax = output bitstream from lsb, edi - ptr to buffer, better if aligned <br />or ch,ch       ; cl  = bit offset 0-31 <br />jz .done       ; ch  = number of bits to read\write 0-32 <br />mov eax,&#91;edi&#93;  ; get first dword <br />mov ebx,&#91;edi+4&#93;; get second dword <br />shrd eax,ebx,cl; adjust by offset <br />mov edx,$FFFFFFFF ; 11111111111111111111 <br />rol cx,8       ;xchg cl,ch     ; put bit count in cl <br />shl edx,cl     ; bit count in cl 11111111111111000000 <br />not edx        ; complement      00000000000000111111 <br />and eax,edx    ; mask out eax <br />.done&#58;ret <br /></code></pre><br /><br />here it is without shld shrd:<br /><pre><code><br />; Matrix bitstream functions <br />; here you are, i knew xchg was slow, it could be a size optimization <br />; use rol cx,8 if its faster for your processor <br />; of course note that call does a push and a pop too <br />; in this version i have avoided the use of shld, shrd <br /><br />write_bitstream&#58;; eax = input bitstream from lsb, edi - ptr to buffer, better if aligned <br />or ch,ch        ; cl  = bit offset 0-31 <br />jz .done        ; ch  = number of bits to read\write 0-32 <br />mov edx,$FFFFFFFF ; 11111111111111111111 <br />rol eax,cl ; hehe <br />mov ebx,eax <br />; --- this part is for zeroing out unneeded bits &#40; if any &#41; in the upper part <br />rol cx,8   ;xchg cl,ch ; put bit count in cl <br />add cl,ch <br />cmp cl,32 <br />jbe .notzeroe <br />sub cl,32 <br />shl edx,cl ; bit count in cl 11111111111111111000 <br />and &#91;edi+4&#93;,edx   ; mask out first dword <br />not edx    ; complement      00000000000000000111 <br />and ebx,edx <br />or  &#91;edi+4&#93;,ebx   ; set bits in first dword <br />add cl,32 <br />.notzeroe&#58; <br />sub cl,ch <br />rol cx,8   ;xchg cl,ch ; put offset in cl <br />; --- this part is for zeroing out unneeded bits &#40; if any &#41; in the upper part <br />mov edx,$FFFFFFFF ; 11111111111111111111 <br />shl edx,cl ; offset in cl 11111111111111000000 <br />; if you are zeroing out use this instead <br />and eax,edx <br /><br />rol cx,8   ;xchg cl,ch ; put bit count in cl <br />mov edx,$FFFFFFFF ; 11111111111111111111 <br />shl edx,cl ; bit count in cl 11111111111111000000 <br />rol cx,8   ;xchg cl,ch ; put offset in cl <br />shl edx,cl ; offset          00000001111111000000 <br />not edx    ; complement      11111110000000111111 <br />rol cx,8   ;xchg cl,ch ; put bit count in cl <br />and &#91;edi&#93;,edx   ; mask out first dword <br />or  &#91;edi&#93;,eax   ; set bits in first dword <br />ret <br /><br />read_bitstream&#58;; eax = output bitstream from lsb, edi - ptr to buffer, better if aligned <br />or ch,ch       ; cl  = bit offset 0-31 <br />jz .done       ; ch  = number of bits to read\write 0-32 <br />mov eax,&#91;edi&#93;  ; get first dword <br />mov ebx,&#91;edi+4&#93;; get second dword <br />mov edx,$FFFFFFFF ; 11111111111111111111 <br />shr eax,cl <br />shr edx,cl ; offset in cl 00000011111111111111 <br />ror ebx,cl <br />not edx    ; offset in cl 11111100000000000000 <br />and ebx,edx <br />or eax,ebx <br />mov edx,$FFFFFFFF ; 11111111111111111111 <br />rol cx,8       ;xchg cl,ch     ; put bit count in cl <br />shl edx,cl     ; bit count in cl 11111111111111000000 <br />not edx        ; complement      00000000000000111111 <br />and eax,edx    ; mask out eax <br />.done&#58;ret <br /></code></pre></div>
    <div class="meta">Posted on 2004-11-09 06:41:27 by &gt;Matrix&lt;</div>
   </div>
  </div>
 </body>
</html>