<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Anyone care to toss me a 4x4 matrix multiply ? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20108" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=20108">Anyone care to toss me a 4x4 matrix multiply ?</a></p>
   <div class="post" id="post-154050">
    <div class="subject"><a href="#post-154050">Anyone care to toss me a 4x4 matrix multiply ?</a></div>
    <div class="body">I know I'm being lazy, but my workload is just crazy right now, I'd appreciate not wasting my time rewriting the wheel.<br />I want it for my bone animation demo, I'm ready to render dancing joint hierarchies sans skin.<br /><br />TIA, Homer.<br /><br />footnote: here's my NON WORKING version (anyone see a problem? I checked the output by multiplying an arbitrary matrix with an Identity matrix, result SHOULD be original arb matrix, and it aint)<br /><br /><pre><code><br />Matrix4By4Product proc uses esi edi ebx pOut, pMat1, pMat2<br />local lLoop1, lLoop2<br />   mov esi, pMat1<br />   mov ebx, pOut<br />   mov ecx, 4<br /><br />QLoop1&#58;<br />   mov edx, 3<br />   mov edi, pMat2           ;&lt;-- reset Source2 pointer<br />   fld dword ptr &#91;esi&#93;        ;&lt;-- load the next Source1 Row<br />   fld dword ptr &#91;esi+4&#93;<br />   fld dword ptr &#91;esi+8&#93;<br />   fld dword ptr &#91;esi+12&#93;<br /><br />QLoop2&#58;<br />   fld dword ptr &#91;edi&#93;<br />   fmul st, st&#40;4&#41;<br />   fld dword ptr &#91;edi+16&#93;<br />   fmul st, st&#40;4&#41;<br />   faddp st&#40;1&#41;, st<br />   fld dword ptr &#91;edi+32&#93;<br />   fmul st, st&#40;3&#41;<br />   faddp st&#40;1&#41;, st<br />   fld dword ptr &#91;edi+48&#93;<br />   fmul st, st&#40;2&#41;<br />   faddp st&#40;1&#41;, st<br />   fstp dword ptr &#91;ebx&#93;<br />   add edi, 4                    ;&lt;-- increment Source2 pointer<br />   add ebx, 4                   ;&lt;-- increment Target pointer<br />   dec edx<br />   jne QLoop2<br /><br />   fld dword ptr &#91;edi&#93;<br />   fmulp st&#40;4&#41;, st<br />   fld dword ptr &#91;edi+16&#93;<br />   fmulp st&#40;3&#41;, st<br />   fld dword ptr &#91;edi+32&#93;<br />   fmulp st&#40;2&#41;, st<br />   fld dword ptr &#91;edi+48&#93;<br />   fmulp st&#40;1&#41;, st<br />   faddp st&#40;2&#41;, st<br />   faddp st&#40;2&#41;, st<br />   faddp st&#40;1&#41;, st  <br />   fstp dword ptr &#91;ebx&#93;     ;&lt;-- Store partial result<br />   add esi, 16                  ;&lt;-- increment Source1 Row<br />   dec ecx<br />   jne QLoop1<br />   ret<br />Matrix4By4Product endp<br /></code></pre></div>
    <div class="meta">Posted on 2004-12-12 21:55:38 by Homer</div>
   </div>
   <div class="post" id="post-154090">
    <div class="subject"><a href="#post-154090">Anyone care to toss me a 4x4 matrix multiply ?</a></div>
    <div class="body"><pre><code>;Kessel 3D math routines<br />;Created by Bas Fagginger Auer, 2001<br />;<br /><br />TempMat DD      16      DUP&#40;0.0&#41;<br /><br />;Matrix vector multiplication<br />;<br />;b = a * matrix<br />;<br />;User passes&#58;<br />;<br />;       ESI     =       Address of the source vector &#40;3x1&#41;<br />;       EAX     =       Address of the matrix &#40;4x4&#41;<br />;       EDI     =       Address of the target vector &#40;3x1&#41;<br />;<br />;User receives&#58;<br />;<br />;       &#91;EDI&#93;   =       the multiplied vector<br />;<br />MVMul   PROC<br /><br />;dummy.x = a.d&#40;0, 0&#41; * v.x + a.d&#40;1, 0&#41; * v.y + a.d&#40;2, 0&#41; * v.z<br />;dummy.y = a.d&#40;0, 1&#41; * v.x + a.d&#40;1, 1&#41; * v.y + a.d&#40;2, 1&#41; * v.z<br />;dummy.z = a.d&#40;0, 2&#41; * v.x + a.d&#40;1, 2&#41; * v.y + a.d&#40;2, 2&#41; * v.z<br /><br />fld dword ptr &#91;esi&#93;     ;ST0 = a.x<br />fmul dword ptr &#91;eax&#93;    ;ST0 = a.x * m&#40;0,0&#41;<br /><br />fld dword ptr &#91;esi+4&#93;   ;ST0 = a.y<br />fmul dword ptr &#91;eax+16&#93; ;ST0 = a.y * m&#40;1,0&#41;<br /><br />fld dword ptr &#91;esi+8&#93;   ;ST0 = a.z<br />fmul dword ptr &#91;eax+32&#93; ;ST0 = a.z * m&#40;2,0&#41;<br /><br />fadd                    ;ST0 = a.z * m&#40;2,0&#41; + a.y * m&#40;1,0&#41;<br />fadd                    ;ST0 = a.z * m&#40;2,0&#41; + a.y * m&#40;1,0&#41; + a.x * m&#40;0,0&#41;<br />fadd dword ptr &#91;eax+48&#93; ;ST0 = a.z * m&#40;2,0&#41; + a.y * m&#40;1,0&#41; + a.x * m&#40;0,0&#41; + m&#40;3,0&#41;<br /><br />fstp dword ptr &#91;edi&#93;    ;b.x = a.z * m&#40;2,0&#41; + a.y * m&#40;1,0&#41; + a.x * m&#40;0,0&#41; + m&#40;3,0&#41;<br /><br /><br />fld dword ptr &#91;esi&#93;     ;ST0 = a.x<br />fmul dword ptr &#91;eax+4&#93;  ;ST0 = a.x * m&#40;0,1&#41;<br /><br />fld dword ptr &#91;esi+4&#93;   ;ST0 = a.y<br />fmul dword ptr &#91;eax+20&#93; ;ST0 = a.y * m&#40;1,1&#41;<br /><br />fld dword ptr &#91;esi+8&#93;   ;ST0 = a.z<br />fmul dword ptr &#91;eax+36&#93; ;ST0 = a.z * m&#40;2,1&#41;<br /><br />fadd                    ;ST0 = a.z * m&#40;2,1&#41; + a.y * m&#40;1,1&#41;<br />fadd                    ;ST0 = a.z * m&#40;2,1&#41; + a.y * m&#40;1,1&#41; + a.x * m&#40;0,1&#41;<br />fadd dword ptr &#91;eax+52&#93; ;ST0 = a.z * m&#40;2,1&#41; + a.y * m&#40;1,1&#41; + a.x * m&#40;0,1&#41; + m&#40;3,1&#41;<br /><br />fstp dword ptr &#91;edi+4&#93;  ;b.y = a.z * m&#40;2,1&#41; + a.y * m&#40;1,1&#41; + a.x * m&#40;0,1&#41; + m&#40;3,1&#41;<br /><br /><br />fld dword ptr &#91;esi&#93;     ;ST0 = a.x<br />fmul dword ptr &#91;eax+8&#93;  ;ST0 = a.x * m&#40;0,2&#41;<br /><br />fld dword ptr &#91;esi+4&#93;   ;ST0 = a.y<br />fmul dword ptr &#91;eax+24&#93; ;ST0 = a.y * m&#40;1,2&#41;<br /><br />fld dword ptr &#91;esi+8&#93;   ;ST0 = a.z<br />fmul dword ptr &#91;eax+40&#93; ;ST0 = a.z * m&#40;2,2&#41;<br /><br />fadd                    ;ST0 = a.z * m&#40;2,2&#41; + a.y * m&#40;1,2&#41;<br />fadd                    ;ST0 = a.z * m&#40;2,2&#41; + a.y * m&#40;1,2&#41; + a.x * m&#40;0,2&#41;<br />fadd dword ptr &#91;eax+56&#93; ;ST0 = a.z * m&#40;2,2&#41; + a.y * m&#40;1,2&#41; + a.x * m&#40;0,2&#41; + m&#40;3,2&#41;<br /><br />fstp dword ptr &#91;edi+8&#93;  ;b.z = a.z * m&#40;2,2&#41; + a.y * m&#40;1,2&#41; + a.x * m&#40;0,2&#41; + m&#40;3,2&#41;<br /><br />ret<br />MVMul   ENDP<br /><br /><br />;Create unit matrix<br />;<br />;matrix = &#91;1,0,0,0&#93;,&#91;0,1,0,0&#93;,&#91;0,0,1,0&#93;,&#91;0,0,0,1&#93;<br />;<br />;User passes&#58;<br />;<br />;       EDI     =       Address of the target matrix<br />;<br />;User receives&#58;<br />;<br />;       &#91;EDI&#93;   =       A unit matrix<br />;<br />MUnit   PROC<br />mov ecx, 16<br />fldz<br />fstp dword ptr &#91;TempI&#93;<br />mov eax, &#91;TempI&#93;<br />rep stosd<br /><br />;mov ECX, 16<br />;LoopjeStoreZeroes&#58;<br />;        fst dword ptr &#91;EDI&#93;<br />;        add EDI, 4<br />;        dec ECX<br />;jnz LoopjeStoreZeroes<br /><br /><br />sub edi, 64<br />fld1<br />fst dword ptr &#91;edi&#93;<br />fst dword ptr &#91;edi+20&#93;<br />fst dword ptr &#91;edi+40&#93;<br />fstp dword ptr &#91;edi+60&#93;<br />ret<br />MUnit   ENDP<br /><br /><br />;Matrix matrix multiplication<br />;<br />;a = a * b<br />;<br />;User passes&#58;<br />;<br />;       &#91;ESI&#93;           =       Matrix B<br />;       &#91;EDI&#93;           =       Matrix A<br />;<br />;User receives&#58;<br />;<br />;       &#91;EDI&#93;           =       Result matrix A<br />;<br />MMul    PROC<br />;FOR i = 0 TO 2<br />;        FOR j = 0 TO 2<br />;                tm.d&#40;i, j&#41; = a.d&#40;i, 0&#41; * b.d&#40;0, j&#41; + a.d&#40;i, 1&#41; * b.d&#40;1, j&#41; + a.d&#40;i, 2&#41; * b.d&#40;2, j&#41;<br />;        NEXT j<br />;NEXT i<br />lea eax, &#91;TempMat&#93;<br />xor ecx, ecx<br />ILoop&#58;<br />        xor cl, cl<br />        JLoop&#58;<br />                xor edx, edx<br />                xor ebx, ebx<br />                mov dl, ch              ;DL = i<br />                mov bl, cl              ;BL = j<br />                lea edx, &#91;edx*8&#93;<br />                lea ebx, &#91;ebx*4&#93;<br />                lea edx, &#91;edx*2&#93;<br /><br />                fld dword ptr &#91;edi+edx&#93; ;ST0 = a&#40;i,0&#41;<br />                fmul dword ptr &#91;esi+ebx&#93; ;ST0 = a&#40;i,0&#41; * b&#40;0,j&#41;<br /><br />                fld dword ptr &#91;edi+edx+4&#93; ;ST0 = a&#40;i,1&#41;<br />                fmul dword ptr &#91;esi+ebx+16&#93; ;ST0 = a&#40;i,1&#41; * b&#40;1,j&#41;<br /><br />                fld dword ptr &#91;edi+edx+8&#93; ;ST0 = a&#40;i,2&#41;<br />                fmul dword ptr &#91;esi+ebx+32&#93; ;ST0 = a&#40;i,2&#41; * b&#40;2,j&#41;<br /><br />                fld dword ptr &#91;edi+edx+12&#93; ;ST0 = a&#40;i,3&#41;<br />                fmul dword ptr &#91;esi+ebx+48&#93; ;ST0 = a&#40;i,3&#41; * b&#40;3,j&#41;<br /><br />                add ebx, edx<br /><br />                fadd                    ;ST0 = a&#40;i,3&#41; * b&#40;3,j&#41; + a&#40;i,2&#41; * b&#40;2,j&#41;<br />                fadd                    ;ST0 = a&#40;i,3&#41; * b&#40;3,j&#41; + a&#40;i,2&#41; * b&#40;2,j&#41; + a&#40;i,1&#41; * b&#40;1,j&#41;<br />                fadd                    ;ST0 = a&#40;i,3&#41; * b&#40;3,j&#41; + a&#40;i,2&#41; * b&#40;2,j&#41; + a&#40;i,1&#41; * b&#40;1,j&#41; + a&#40;i,0&#41; * b&#40;0,j&#41;<br /><br />                fstp dword ptr &#91;eax+ebx&#93;    ;t&#40;i,j&#41; = a&#40;i,3&#41; * b&#40;3,j&#41; + a&#40;i,2&#41; * b&#40;2,j&#41; + a&#40;i,1&#41; * b&#40;1,j&#41; + a&#40;i,0&#41; * b&#40;0,j&#41;<br />                inc cl<br />                cmp cl, 4<br />        jne JLoop<br />        inc ch<br />        cmp ch, 4<br />jne ILoop<br />mov ecx, 16<br />mov esi, eax<br />rep movsd<br />ret<br />MMul    ENDP<br /><br />;-----------&gt; MRot procedure<br />;<br />;Created by Bas Fagginger Auer<br />;<br />;Created a 4x4 rotation matrix based on the given rX, rY and rZ angles.<br />;<br />;<br />;Caller must pass&#58;<br />;<br />;       ESI = Offset of rotation vector &#40;vector.x = rotation around the X angle, etc.&#41;<br />;       EDI = Offset of matrix A<br />;<br />;Caller receives&#58;<br />;<br />;       -<br />;<br />;Register&#40;s&#41; that are modified&#58;<br />;<br />;       -<br />;<br /><br /><br />MRot    PROC<br />        fldz<br />        fstp &#91;TempD&#93;<br />        mov eax, &#91;TempD&#93;<br /><br />        mov cx, 16      ;We want to store 4*4 matrix elements<br />        rep stosd       ;Store 64 zeros<br /><br />        sub EDI, 64<br /><br />        fld1<br />        fstp dword ptr &#91;EDI+60&#93;<br /><br />        <br />        ;Matrix now looks like this&#58;<br />        ;<br />        ;0 0 0 0<br />        ;0 0 0 0 <br />        ;0 0 0 0 <br />        ;0 0 0 1<br /><br /><br />        ;Now insert the 'rotation elements'<br /><br />        fld DWORD PTR &#91;ESI&#93;       ;ST0 = rX<br />        fsincos                   ;ST0 = Cos&#40;rX&#41;<br />                                  ;ST1 = Sin&#40;rX&#41;<br /><br />        fld DWORD PTR &#91;ESI+4&#93;     ;ST0 = rY<br />        fsincos                   ;ST0 = Cos&#40;rY&#41;<br />                                  ;ST1 = Sin&#40;rY&#41;<br /><br />        fld DWORD PTR &#91;ESI+8&#93;     ;ST0 = rZ<br />        fsincos                   ;ST0 = Cos&#40;rZ&#41;<br />                                  ;ST1 = Sin&#40;rZ&#41;<br /><br /><br />        fstp DWORD PTR &#91;cZ&#93;       ;cZ = Cos&#40;rZ&#41;<br />        fstp DWORD PTR &#91;sZ&#93;       ;sZ = Sin&#40;rZ&#41;<br /><br />        fstp DWORD PTR &#91;cY&#93;       ;cY = Cos&#40;rY&#41;<br />        fstp DWORD PTR &#91;sY&#93;       ;sY = Sin&#40;rY&#41;<br /><br />        fstp DWORD PTR &#91;acX&#93;       ;acX = Cos&#40;rX&#41;<br />        fstp DWORD PTR &#91;sX&#93;       ;sX = Sin&#40;rX&#41;<br /><br /><br />        fld DWORD PTR &#91;cY&#93;<br />        fmul DWORD PTR &#91;cZ&#93;       ;ST0 = cY * cZ<br />        fstp DWORD PTR &#91;EDI&#93;      ;A&#40;0,0&#41; = cY * cZ<br /><br /><br /><br /><br />        fld DWORD PTR &#91;cY&#93;<br />        fmul DWORD PTR &#91;sZ&#93;       ;ST0 = cY * sZ<br />        fstp DWORD PTR &#91;EDI+4&#93;    ;A&#40;0,1&#41; = cY * sZ<br /><br />        fld DWORD PTR &#91;sY&#93;<br />        fchs                      ;ST0 = -sY<br />        fstp DWORD PTR &#91;EDI+8&#93;    ;A&#40;0,2&#41; = -sY<br />        <br /><br />        fld DWORD PTR &#91;acX&#93;<br />        fmul DWORD PTR &#91;sZ&#93;     ;ST0 = acX * sZ<br /><br />        fld DWORD PTR &#91;sX&#93;<br />        fmul DWORD PTR &#91;sY&#93;<br />        fmul DWORD PTR &#91;cZ&#93;     ;ST0 = sX * sY * cZ<br /><br />        fsub ST&#40;0&#41;, ST&#40;1&#41;       ;ST0 = sX * sY * cZ - acX * sZ<br /><br />        fstp DWORD PTR &#91;EDI+16&#93; ;A&#40;1,0&#41; = sX * sY * cZ - acX * sZ<br /><br /><br />        fld DWORD PTR &#91;acX&#93;<br />        fmul DWORD PTR &#91;cZ&#93;     ;ST0 = acX * cZ<br /><br />        fld DWORD PTR &#91;sX&#93;<br />        fmul DWORD PTR &#91;sY&#93;<br />        fmul DWORD PTR &#91;sZ&#93;     ;ST0 = sX * sY * sZ<br /><br />        fadd                    ;ST0 = sX * sY * sZ + acX * cZ<br /><br />        fstp DWORD PTR &#91;EDI+20&#93; ;A&#40;1,1&#41; = sX * sY * sZ + acX * cZ<br /><br />        fld DWORD PTR &#91;sX&#93;<br />        fmul DWORD PTR &#91;cY&#93;       ;ST0 = sX * cY<br />        fstp DWORD PTR &#91;EDI+24&#93;   ;A&#40;1,2&#41; = sX * cY<br />        <br /><br />        fld DWORD PTR &#91;sX&#93;<br />        fmul DWORD PTR &#91;sZ&#93;     ;ST0 = sX * sZ<br /><br />        fld DWORD PTR &#91;acX&#93;<br />        fmul DWORD PTR &#91;sY&#93;<br />        fmul DWORD PTR &#91;cZ&#93;     ;ST0 = acX * sY * cZ<br /><br />        fadd                    ;ST0 = acX * sY * cZ + sX * sZ<br /><br />        fstp DWORD PTR &#91;EDI+32&#93; ;A&#40;2,0&#41; = acX * sY * cZ + sX * sZ<br /><br />        fld DWORD PTR &#91;sX&#93;<br />        fmul DWORD PTR &#91;cZ&#93;     ;ST0 = sX * cZ<br /><br />        fld DWORD PTR &#91;acX&#93;<br />        fmul DWORD PTR &#91;sY&#93;<br />        fmul DWORD PTR &#91;sZ&#93;     ;ST0 = acX * sY * sZ<br /><br />        fsub ST&#40;0&#41;, ST&#40;1&#41;       ;ST0 = acX * sY * sZ - sX * cZ<br /><br />        fstp DWORD PTR &#91;EDI+36&#93; ;A&#40;2,1&#41; = acX * sY * sZ - sX * cZ<br /><br />        fld DWORD PTR &#91;acX&#93;<br />        fmul DWORD PTR &#91;cY&#93;       ;ST0 = acX * cY<br />        fstp DWORD PTR &#91;EDI+40&#93;   ;A&#40;2,2&#41; = acX * cY<br /><br />        ret<br />MRot    ENDP</code></pre>http://www.phys.uu.nl/~0307467/</div>
    <div class="meta">Posted on 2004-12-13 15:13:58 by bitRAKE</div>
   </div>
   <div class="post" id="post-154094">
    <div class="subject"><a href="#post-154094">Anyone care to toss me a 4x4 matrix multiply ?</a></div>
    <div class="body">much obliged, I'll give it a whirl when I get home from work :)</div>
    <div class="meta">Posted on 2004-12-13 16:51:32 by Homer</div>
   </div>
   <div class="post" id="post-154115">
    <div class="subject"><a href="#post-154115">Anyone care to toss me a 4x4 matrix multiply ?</a></div>
    <div class="body">Sweet, thanks a bunch - it passed my simplistic multiply-by-Identity test.<br />I should be able to get my joint hierarchy to render correctly now.</div>
    <div class="meta">Posted on 2004-12-13 22:37:17 by Homer</div>
   </div>
   <div class="post" id="post-154125">
    <div class="subject"><a href="#post-154125">Anyone care to toss me a 4x4 matrix multiply ?</a></div>
    <div class="body">Your code is good, but you forgot to advance EBX when you store the last value in a row.<pre><code>Matrix4By4Product proc uses esi edi ebx pOut, pMat1, pMat2 <br />local lLoop1, lLoop2 <br />   mov esi, pMat1 <br />   mov ebx, pOut <br />   mov ecx, 4 <br /><br />QLoop1&#58; <br />   mov edx, 3 <br />   mov edi, pMat2           ;&lt;-- reset Source2 pointer <br />   fld dword ptr &#91;esi&#93;        ;&lt;-- load the next Source1 Row <br />   fld dword ptr &#91;esi+4&#93; <br />   fld dword ptr &#91;esi+8&#93; <br />   fld dword ptr &#91;esi+12&#93; <br /><br />QLoop2&#58; <br />   fld dword ptr &#91;edi&#93; <br />   fmul st, st&#40;4&#41; <br />   fld dword ptr &#91;edi+16&#93; <br />   fmul st, st&#40;4&#41; <br />   faddp st&#40;1&#41;, st <br />   fld dword ptr &#91;edi+32&#93; <br />   fmul st, st&#40;3&#41; <br />   faddp st&#40;1&#41;, st <br />   fld dword ptr &#91;edi+48&#93; <br />   fmul st, st&#40;2&#41; <br />   faddp st&#40;1&#41;, st <br />   fstp dword ptr &#91;ebx&#93; <br />   add edi, 4                    ;&lt;-- increment Source2 pointer <br />   add ebx, 4                   ;&lt;-- increment Target pointer <br />   dec edx <br />   jne QLoop2 <br /><br />   fld dword ptr &#91;edi&#93; <br />   fmulp st&#40;4&#41;, st <br />   fld dword ptr &#91;edi+16&#93; <br />   fmulp st&#40;3&#41;, st <br />   fld dword ptr &#91;edi+32&#93; <br />   fmulp st&#40;2&#41;, st <br />   fld dword ptr &#91;edi+48&#93; <br />   fmulp st&#40;1&#41;, st <br />   faddp st&#40;2&#41;, st <br />   faddp st&#40;2&#41;, st <br />   faddp st&#40;1&#41;, st  <br />   fstp dword ptr &#91;ebx&#93;     ;&lt;-- Store partial result <br /><br />; MISSING INSTRUCTION<br />add ebx, 4                   ;&lt;-- increment Target pointer <br /><br />   add esi, 16                  ;&lt;-- increment Source1 Row <br />   dec ecx <br />   jne QLoop1 <br />   ret <br />Matrix4By4Product endp</code></pre>Can't wait to see what you got cookin'. :)</div>
    <div class="meta">Posted on 2004-12-14 01:55:02 by bitRAKE</div>
   </div>
   <div class="post" id="post-154135">
    <div class="subject"><a href="#post-154135">Anyone care to toss me a 4x4 matrix multiply ?</a></div>
    <div class="body">Hello Homer,<br /><br />Maybe you missed my msg, but here's something for you<br /><br />http://www.asmcommunity.net/board/viewtopic.php?t=19782<br /><br />I did try coding a SSE version but it was only half done. I could post it here if there are any interested parties to complete it.</div>
    <div class="meta">Posted on 2004-12-14 06:03:16 by roticv</div>
   </div>
   <div class="post" id="post-154145">
    <div class="subject"><a href="#post-154145">Anyone care to toss me a 4x4 matrix multiply ?</a></div>
    <div class="body">bitrake - d'oh ! My bad :) ty<br />victor - Yeah I got no msg, I'll take a look at that SSE stuff if you care to share :)</div>
    <div class="meta">Posted on 2004-12-14 09:34:44 by Homer</div>
   </div>
   <div class="post" id="post-154149">
    <div class="subject"><a href="#post-154149">Anyone care to toss me a 4x4 matrix multiply ?</a></div>
    <div class="body"><pre><code><br />;Transpose matrix2<br />;Store transposed matrix in xmm4...xmm7<br />movdqa xmm5, &#91;matrix2&#93;<br />movdqa xmm1, &#91;matrix2+128&#93;<br />movdqa xmm2, &#91;matrix2+128+128&#93;<br />movdqa xmm3, &#91;matrix2+128+128+128&#93;<br /><br />;For later use<br />movdqa xmm7, xmm5<br />movdqa xmm0, xmm1<br /><br />unpcklps xmm5, xmm2<br />unpcklps xmm1, xmm3<br />movdqa xmm4, xmm5<br />unpcklps xmm4, xmm1<br /><br />;First column transposed<br /><br />unpckhps xmm5, xmm1<br /><br />;Second column transposed<br /><br />unpckhps xmm7, xmm2<br />unpckhps xmm0, xmm3<br />movqda xmm6, xmm7<br />unpcklps xmm6, xmm1<br /><br />;Third column transposed<br /><br />unpckhps xmm7, xmm1<br /><br />;Fourth column transposed<br /><br />;Multiply now<br />;Only 16 multiplies needed<br /><br />movqda xmm0, &#91;matrix1&#93;<br />movqda xmm1, xmm0<br />mulps xmm1, xmm4<br />movqda xmm2, xmm1<br />add<br /><br />;movqda xmm2, xmm0<br />;movqda xmm3, xmm1<br />mulps xmm0, xmm4<br />mulps xmm1, xmm5<br />mulps xmm2, xmm6<br />mulps xmm3, xmm7<br /><br />;Add the 4 real in xmm0..xmm3<br />;You get the the first row of the matrix<br /><br />...<br /></code></pre></div>
    <div class="meta">Posted on 2004-12-14 10:39:30 by roticv</div>
   </div>
   <div class="post" id="post-154176">
    <div class="subject"><a href="#post-154176">Anyone care to toss me a 4x4 matrix multiply ?</a></div>
    <div class="body">The existing 3d engine supports managed instances of two basic 3d primitive objects (textured spheres and cubes). I've had a couple of tries under DX to get bone-animated models implemented with little success.<br />This time under OGL, I decided to implement it myself from the ground up.<br />I have written an oop class which implements a Joint node hierarchy, and a container class to hold the root node, skin geometry and other required stuff. I have implemented my own text-based file format for describing just the joint hierarchy (loosely based on X file format), as well as a loader which creates a joint hierarchy based on the text file data.<br />I've written code which should display all the joints in the hierarchy using a single instance of my Sphere class. Once I get the joints to render, I'll write a new geometric primitive class for Pyramids and use that to render the Bones inbetween the Joints. When I have done that I will introduce another custom file format containing animation data (keyframed matrices to be applied at the joints, similar to the static joint hierarchy).<br />After I have implemented dancing skeletons, I will figure out how to go about deforming the skin vertices using bone weights, probably using a vertexshader. Later on I will attempt to blend animations, then it will be time to add code to export the loaded model to a custom BINARY file format, and code to load it back in again from the binfile(s).<br />Wish me luck :)</div>
    <div class="meta">Posted on 2004-12-14 22:54:31 by Homer</div>
   </div>
  </div>
 </body>
</html>