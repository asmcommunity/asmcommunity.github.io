<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>WndProc Returns with Error after Handling WM_PAINT (Solved by Sinsi!) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=28705" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=116">Windows</a> &raquo; <a href="../?id=28705">WndProc Returns with Error after Handling WM_PAINT (Solved by Sinsi!)</a></p>
   <div class="post" id="post-202796">
    <div class="subject"><a href="#post-202796">WndProc Returns with Error after Handling WM_PAINT (Solved by Sinsi!)</a></div>
    <div class="body">Okay, before I even begin, I will offer a warning: You might regard the code you are about to read crazy. In it, I use ESP to reference params and locals, I SUBtract from ESP and MOVe params, rather than PUSHing and POPping, and you won&#039;t find a PROC...ENDP, STRUCT, or WM_* anywhere.<br /><br />It is this way because I was trying to learn what all those luxuries do for me, and then binrapt on #win32asm said I might as well use ESP for speed or write it in C. Naturally, being a n00b not to be outdone, I did just that. And, for the most part, it works. I even figured out how to shortcircuit DefWindowProc to return to WndProc&#039;s caller. However, I have goofed something where I handle the WM_PAINT message, and after WM_PAINT is handled, WndProc RETurns and then crashes. But, only on that message do thing go wrong...<br /><br />It is commented, however, it is probably painful to look at. I have also attached the file, which retains my indentation, making it slightly easier to read than what is below.<br /><br /><pre><code><br />; Assemble with &quot;GoAsm &lt;file.asm&gt;&quot;<br /><br />; Link with &quot;GoLink &lt;file.asm&gt; kernel32.dll user32.dll&quot;<br />; Append &quot;-debug coff&quot; to GoLine command to link with symbols<br /><br />data section<br /><br />	szClsNm		db &quot;FastererWin&quot;, 0x0<br />	szAppNm		db &quot;Attempt at a &quot;, 0x22, &quot;Fasterer&quot;, 0x22, &quot; Window Implementation&quot;, 0x0<br />	szText		db &quot;This is my attempt at a &quot;, 0x22, &quot;fasterer&quot;, 0x22, &quot; window &quot;, \<br />			&nbsp; &nbsp;&quot;implementation. Rather than managing a &quot;, \<br />			&nbsp; &nbsp;&quot;static stack frame manually through EBP, &quot;, \<br />			&nbsp; &nbsp;&quot;I manage a dynamic stack frame through ESP.&quot;, \<br />			&nbsp; &nbsp;0xA, 0xA, \<br />			&nbsp; &nbsp;&quot;To alleviate the headache that ensues from &quot;, \<br />			&nbsp; &nbsp;&quot;trying to keep track of params and locals &quot;, \<br />			&nbsp; &nbsp;&quot;on the stack, especially between intervening &quot;, \<br />			&nbsp; &nbsp;&quot;PUSHes and POPs, I did away with them all &quot;, \<br />			&nbsp; &nbsp;&quot;together. Instead, I SUBtract from ESP the &quot;, \<br />			&nbsp; &nbsp;&quot;number of bytes I need for passing params. &quot;, \<br />			&nbsp; &nbsp;&quot;This allows me to deal with a fixed number &quot;, \<br />			&nbsp; &nbsp;&quot;of intervening bytes throughout the entire &quot;, \<br />			&nbsp; &nbsp;&quot;process of putting params on the stack, as &quot;, \<br />			&nbsp; &nbsp;&quot;opposed to the number changing with each &quot;, \<br />			&nbsp; &nbsp;&quot;PUSH. An ideal side effect of using this &quot;, \<br />			&nbsp; &nbsp;&quot;method is that now I can place params on the &quot;, \<br />			&nbsp; &nbsp;&quot;stack in left-to-right order, at increasing &quot;, \<br />			&nbsp; &nbsp;&quot;offsets from ESP, instead of right-to-left, &quot;, \<br />			&nbsp; &nbsp;&quot;at decreasing offsets from EBP.&quot;, \<br />			&nbsp; &nbsp;0xA, 0xA, \<br />			&nbsp; &nbsp;&quot;Well, any speed advantage will surely not be &quot;, \<br />			&nbsp; &nbsp;&quot;human-perceptible, but at least I have the &quot;, \<br />			&nbsp; &nbsp;&quot;satisfaction of know that this implementation &quot;, \<br />			&nbsp; &nbsp;&quot;is &quot;, 0x22, &quot;fasterer&quot;, 0x22, &quot; than my last one. Also, I have &quot;, \<br />			&nbsp; &nbsp;&quot;discovered an opportunity for additional speed &quot;, \<br />			&nbsp; &nbsp;&quot;gain. About 99.999% of windows messages, at &quot;, \<br />			&nbsp; &nbsp;&quot;least in this program, are sent to DefWindowProc. &quot;, \<br />			&nbsp; &nbsp;&quot;Instead of WndProc coping its params on the stack &quot;, \<br />			&nbsp; &nbsp;&quot;before calling DefWindowProc, it just discards &quot;, \<br />			&nbsp; &nbsp;&quot;its local storage and JuMPs to it instead. &quot;, \<br />			&nbsp; &nbsp;&quot;This eliminates two copies of the same data &quot;, \<br />			&nbsp; &nbsp;&quot;on the stack and one whole procedure RETurn.&quot;<br />			&nbsp; &nbsp;0x0<br /><br />	hInst		dd 0x0<br /><br />code section<br /><br />Start:<br /><br />	; Get hInst<br /><br />	sub esp, 0x4			; Prep 1 Arg<br />	mov d, 0x0			; Calling App hInst<br />	call GetModuleHandleA		; Get hInst<br />	mov , eax		; Save hInst<br /><br />	; Call FastererWin<br /><br />	sub esp, 0x10			; Prep 4 Args<br />	mov , eax			; hInst<br />	mov d, 0x0		; No Prev Inst<br />	mov d, 0x0		; No Cmd Ln<br />	mov d, 0xA		; Show Def<br />	call WinMain			; FastererWin<br /><br />	; Exit to Win<br /><br />	ret 				; Ret Val in EAX<br /><br />WinMain:<br /><br />	; Reserve Auto Store<br /><br />	sub esp, 0x4C			; 0x30+0x18+0x4<br /><br />	; No Crit Regs on Stack<br /><br />	; Auto Store on Stack<br /><br />	; WndClsEx:	esp		; 0x0<br />	; cbSize	+0x0<br />	; style		+0x4<br />	; lpfnWndProc	+0x8<br />	; cbClsEx	+0xC<br />	; cbWndEx	+0x10<br />	; hInst		+0x14<br />	; hIcon		+0x18<br />	; hCurs		+0x1C<br />	; hbrBckGrnd	+0x20<br />	; lpszMnuNm	+0x24<br />	; lpszClsNm	+0x28<br />	; hIconSm	+0x2C<br /><br />	; Msg:		esp+0x30	; 0x0+0x30<br />&nbsp; &nbsp; &nbsp; &nbsp; ; hWnd		+0x0<br />	; msg		+0x4<br />	; wParam	+0x8<br />	; lParam	+0xC<br />	; time		+0x10<br />	; pt		+0x14<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ; hWnd:		esp+0x48	; 0x30+0x18<br /><br />	; Ret Addr on Stack<br /><br />	; Ret EIP:	esp+0x4C	; 0x48+0x4<br /><br />	; Params on Stack<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ; hInst		esp+0x50	; 0x4C+0x4<br />&nbsp; &nbsp; &nbsp; &nbsp; ; hPrevInst	esp+0x54	; 0x50+0x4<br />	; lpCmdLn	esp+0x58	; 0x54+0x4<br />	; nCmdShow	esp+0x5C	; 0x58+0x4<br /><br />	; Do Not Preserve Crit Regs<br /><br />	; Fill WinClsEx<br /><br />	mov d, 0x30		; WinClsEx Size<br />	mov d, 0x1|0x2		; Horiz and Vert Redraw<br />	mov d, addr WndProc	; FastererWin Wndproc<br />	mov d, 0x0		; No Extra Cls Bytes<br />	mov d, 0x0		; No Extra Wnd Bytes<br />	mov , eax		; EAX Still hInst<br />	mov d, 0x5		; Window Color<br />	mov d, 0x0		; No Menu<br />	mov d, addr szClsNm	; FastererWin Cls Nm<br /><br />	; Get WinClsEx hIcon and hIconSm<br /><br />	sub esp, 0x8			; Prep 2 Args<br />	mov d, 0x0			; Sys hIcon<br />	mov d, 0x7F00		; Std App hIcon<br />	call LoadIconA			; Get hIcon<br />	mov , eax		; Save WinClsEx hIcon<br />	mov , eax		; Save WinClsEx hIconSm<br /><br />	; Get WinClsEx hCurs<br /><br />	sub esp, 0x8			; Prep 2 Args<br />	; WOW! ---&gt;			; Correct Args Still on Stack<br />	call LoadCursorA		; Get hCurs<br />	mov , eax		; Save WinClsEx hCurs<br /><br />	; Register FastererWin WinCls<br /><br />	lea eax, 			; Load WinClsEx Addr<br />	sub esp, 0x4			; Prep 1 Arg<br />	mov , eax			; WinClsEx Addr<br />	call RegisterClassExA		; Register FastererWin WinCls<br /><br />	; Create FastererWin Win<br /><br />	sub esp, 0x30			; Prep 12 Args<br />	mov d, 0x0			; No Ex Style<br />	mov , addr szClsNm	; FastererWin<br />	mov , addr szAppNm<br />	mov d, 0x0|0x40000|0x80000|0xC00000<br />					; Overlapped|ThickFrame|SysMnu|Caption<br />	mov d, 0x80000000	; Def X Coord<br />	mov d, 0x80000000	; Def Y Coord<br />	mov d, 0x80000000	; Def Width<br />	mov d, 0x80000000	; Def Height<br />	mov d, 0x0		; DeskTop Parent Win<br />	mov d, 0x0		; No Mnu<br />	mov eax, 	; Get hInst Param<br />	mov , eax		; hInst Param<br />	mov d, 0x0		; No Ex Info<br />	call CreateWindowExA		; Create FastererWin Win<br />	mov , eax		; Save FastererWin hWnd<br /><br />	; Show FastererWin Win<br /><br />	sub esp, 0x8			; Prep 2 Args<br />	mov , eax			; FastererWin hWnd<br />	mov eax, 		; Get nCmdShow<br />	mov , eax		; nCmdShow<br />	call ShowWindow			; Show FastererWin Win<br /><br />	; Update FastererWin Win<br /><br />	sub esp, 0x4			; Prep 1 Arg<br />	mov eax, 		; Get FastererWin hWnd<br />	mov , eax			; FastererWin hWnd<br />	call UpdateWindow		; Update FastererWin Win<br /><br />	MsgLp:<br /><br />		; Get Msg<br /><br />		lea eax, 		; Get Msg Addr<br />		sub esp, 0x10			; Prep 4 Args<br />		mov , eax			; Msg Addr<br />		mov d, 0x0		; No hWnd for All Msgs<br />		mov d, 0x0		; No Min Msg Filter<br />		mov d, 0x0		; No Max Msg Filter<br />		call GetMessageA		; Get Msg<br /><br />		; Exit Msg Lp on Null Msg<br /><br />		or eax, eax			; Check Null Msg<br />		jz &gt;EndMsgLp			; Exit Msg Lp on Null Msg<br /><br />		; Do Not Trans Msg<br /><br />		; Dispatch Msg<br /><br />		lea eax, 		; Get Msg Addr<br />		sub esp, 0x4			; Prep 1 Arg<br />		mov , eax			; Msg Addr<br />		call DispatchMessageA		; Dispatch Msg<br /><br />	jmp &lt;MsgLp			; Keep Pumping Msgs<br /><br />	EndMsgLp:<br /><br />	mov eax, 		; Ret Msg wParam<br /><br />	; Do Not Restore Crit Regs<br /><br />	; Discard Auto Store<br /><br />	add esp, 0x4C			; 0x30+0x18+0x4<br /><br />	; Exit to Start<br /><br />	ret 0x10			; Discard 4 Params<br /><br />WndProc:<br /><br />	; Reserve Auto Store<br /><br />	sub esp, 0x48			; 0x34+0x10+0x4<br /><br />	; No Crit Regs on Stack<br /><br />	; Auto Store on Stack<br /><br />	; PaintStruct:	esp		; 0x0<br />	; hdc		+0x0<br />	; fErase	+0x4<br />	; rcPaint	+0x8<br />	; fRestore	+0xC<br />	; fIncUpdate	+0x10<br />	; rgbReserved	+0x14<br /><br />	; Rect:		esp+0x34	; 0x0+0x34<br />	; left		+0x0<br />	; top		+0x4<br />	; right		+0x8<br />	; bottom	+0xC<br /><br />	; hdc:		esp+0x44	; 0x34+0x10<br /><br />	; Ret Addr on Stack<br /><br />	; Ret EIP:	esp+0x48	; 0x44+0x4<br /><br />	; Params on Stack<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ; hWnd		esp+0x4C	; 0x48+0x4<br />&nbsp; &nbsp; &nbsp; &nbsp; ; uMsg		esp+0x50	; 0x4C+0x4<br />	; wParam	esp+0x54	; 0x50+0x4<br />	; lParam	esp+0x58	; 0x54+0x4<br /><br />	; Do Not Preserve Crit Regs<br /><br />	ProcMsgs:<br /><br />		; Check for Msgs of Interest<br /><br />		mov eax, 		; Get Msg Num<br /><br />		; Something buggy with OnPaint...<br /><br />		;cmp eax, 0xF			; Paint Msg?<br />		;jz &gt;OnPaint			; Paint FastererWin Win<br /><br />		cmp eax, 0x2			; Destroy Msg?<br />		jz &gt;OnDestroy			; Destroy FastererWin Win<br />	<br />		; Discard Auto Store...<br /><br />		add esp, 0x48			; 0x34+0x10+0x4<br /><br />		; Fwd Msg to Windows<br /><br />		jmp DefWindowProcA		; DefWindowProcA Will<br />						; Ret to WndProc&#039;s Caller<br /><br />	OnPaint:<br /><br />		; Paint FastererWin Win<br /><br />		lea eax, 			; Get PaintStruct Addr<br />		sub esp, 0x8			; Prep 2 Args<br />		mov , eax		; PaintStruct Addr<br />		mov eax, 		; Get hWnd<br />		mov , eax			; hWnd<br />		call BeginPaint			; Begin Painting<br />		mov , eax		; Save hdc<br /><br />		; Get FastererWin Win Rect<br /><br />		lea eax, 		; Get Rect Addr<br />		sub esp, 0x8			; Prep 2 Args<br />		mov , eax		; Rect Addr<br />		mov eax, 		; Get hWnd<br />		mov , eax			; hWnd<br />		call GetClientRect		; Get FastererWin Win Rect<br /><br />		; Draw Text to FastererWin Win<br /><br />		mov eax, 		; Get hdc<br />		sub esp, 0x14			; Prep 5 Args<br />		mov , eax			; hdc<br />		mov , addr szText	; szText Addr<br />		mov d, -1		; Assume szText Zero Terminated<br />		lea eax, 	; Get Rect Addr<br />		mov , eax		; Rect Addr<br />		mov d, 0x10|0x40000	; Word Break and Ellipsis<br />		call DrawTextA			; Draw Text<br /><br />		; End Paint FastererWin Win<br /><br />		lea eax, 			; Get PaintStruct Addr<br />		sub esp, 0x8			; Prep 2 Args<br />		mov , eax		; PaintStruct Addr<br />		mov eax, 		; Get hWnd<br />		mov , eax			; hWnd<br />		call EndPaint			; End Painting<br /><br />		; Set Ret Val<br /><br />		xor eax, eax			; ???<br />		<br />		; Exit ProcMsgs<br /><br />		jmp &gt;EndProcMsgs<br /><br />	OnDestroy:<br /><br />		; Destroy FastererWin Win<br /><br />		sub esp, 0x4			; Prep 1 Arg<br />		mov d, 0x0<br />		call PostQuitMessage		; Destroy FastererWin Win<br /><br />		; Set Ret Val<br /><br />		xor eax, eax			; ???<br /><br />	EndProcMsgs:<br /><br />	; Do Not Restore Crit Regs<br /><br />	; Discard Auto Store<br /><br />	add esp, 0x48			; 0x34+0x10+0x4<br /><br />	; Exit to Dispatch/SendMessage<br /><br />	ret 0x10			; Discard 4 Params<br /></code></pre><br /><br />If you uncomment this section, listed below for convenience, it crashes after WM_PAINT.<br /><br /><pre><code><br />		; Something buggy with OnPaint...<br /><br />		;cmp eax, 0xF			; Paint Msg?<br />		;jz &gt;OnPaint			; Paint FastererWin Win<br /></code></pre><br /><br />Any masochists out there that can tell me where I goofed, other than the obvious &quot;Why the hell are you coding like that?&quot;?<br /><br />Thanks to anyone interested in helping.</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2413" target="_blank">FastWin.asm</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-08-31 18:50:56 by TheAbysmal</div>
   </div>
   <div class="post" id="post-202801">
    <div class="subject"><a href="#post-202801">Re: WndProc Returns with Error after Handling WM_PAINT (Coding Horror)</a></div>
    <div class="body"><div class="quote"><br />typedef struct tagPAINTSTRUCT { <br />&nbsp; HDC&nbsp; hdc; <br />&nbsp; BOOL fErase; <br />&nbsp; RECT rcPaint; <br />&nbsp; BOOL fRestore; <br />&nbsp; BOOL fIncUpdate; <br />&nbsp; BYTE rgbReserved[32]; <br />} PAINTSTRUCT, *PPAINTSTRUCT; <br /></div><br />Notice that rcPaint is a RECT and not a DWORD?<br /><div class="quote"><br />	; PaintStruct:	esp		; 0x0<br />	; hdc		+0x0<br />	; fErase	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  +0x4<br />	; rcPaint	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  +0x8<br />	; fRestore	+0xC&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;everything from here on is out by 12 bytes &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br />	; fIncUpdate	+0x10<br />	; rgbReserved	+0x14<br /><br />	; Rect:		esp+0x34	; 0x0+0x34<br /></div></div>
    <div class="meta">Posted on 2007-08-31 19:59:58 by sinsi</div>
   </div>
   <div class="post" id="post-202802">
    <div class="subject"><a href="#post-202802">Re: WndProc Returns with Error after Handling WM_PAINT (Coding Horror)</a></div>
    <div class="body">Sinsi,<br /><br />Thanks a million!&nbsp; You sure made quick work of that.</div>
    <div class="meta">Posted on 2007-08-31 20:20:13 by TheAbysmal</div>
   </div>
   <div class="post" id="post-202806">
    <div class="subject"><a href="#post-202806">Re: WndProc Returns with Error after Handling WM_PAINT (Solved by Sinsi!)</a></div>
    <div class="body">TheAbysmal,<br /><br /><div class="quote">Okay, before I even begin, I will offer a warning: You might regard the code you are about to read crazy. In it, I use ESP to reference params and locals, I SUBtract from ESP and MOVe params, rather than PUSHing and POPping, and you won&#039;t find a PROC...ENDP, STRUCT, or WM_* anywhere.</div><br /><br />&nbsp; &nbsp;  I have been doing PROCless programming for years now.&nbsp; I suggest you read reply #12 of http://www.asmcommunity.net/board/index.php?topic=28695.0 and reply #1 of http://www.asmcommunity.net/board/index.php?topic=24957.0 .&nbsp; Be careful of not calling DefWindowProc when you should, because that cleans up a lot of things that could come back and bite you unexpectedly.&nbsp; Ask if you have any questions.&nbsp; Be warned that MASM is the only assembler I work with.&nbsp; Ratch</div>
    <div class="meta">Posted on 2007-09-01 00:43:10 by Ratch</div>
   </div>
   <div class="post" id="post-202814">
    <div class="subject"><a href="#post-202814">Re: WndProc Returns with Error after Handling WM_PAINT (Solved by Sinsi!)</a></div>
    <div class="body">There&#039;s one mouse trap with the WM_PAINT message which you must be aware of. That message is sent during the creation of the window. If your procedure is such that it uses data (specially memory addresses) which will be defined only AFTER the creation of the window, it&#039;s bound to try accessing illegal memory areas and crash your program right from the start.<br /><br />To circumvent such a problem, have some kind of a flag in your global data which you have initialized to 0 (or -1 or whatever) and you check it BEFORE running the paint code; you then skip that paint code as long as that flag remains set to its initial value. You modify that flag when you define the required data which would then allow the paint code to be executed as intended.<br /><br />Raymond<br /></div>
    <div class="meta">Posted on 2007-09-01 19:17:57 by Raymond</div>
   </div>
  </div>
 </body>
</html>