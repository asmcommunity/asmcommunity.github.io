<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>array problem - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25452" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25452">array problem</a></p>
   <div class="post" id="post-186054">
    <div class="subject"><a href="#post-186054">array problem</a></div>
    <div class="body"> Hello, im trying to create a program with MASM where the program asks me to enter a few numbers. So lets say i enter the numbers &#39;12345&#39;, then it should calculate the sum of those numbers which would result in &#39;15&#39; as a answer.<br />The only problem is that i dont know how to sepperate the whole decimal striing 12345 into sepperate numbers. I still haven&#39;t figured it out.<br /><br />I have this code right now, with a few comments in it. Im hoping that someone can help me out with this.<br /><br /><pre><code><br />.386<br />.model flat,stdcall<br />option casemap:none<br /><br />include \masm32\include\windows.inc<br />include \masm32\include\user32.inc<br />include \masm32\include\masm32.inc<br />include \masm32\include\kernel32.inc<br /><br />includelib \masm32\lib\user32.lib<br />includelib \masm32\lib\masm32.lib<br />includelib \masm32\lib\kernel32.lib<br /><br />.data<br />&nbsp; &nbsp; ;nummers&nbsp; &nbsp;  dd 1,2,3,4,5&nbsp; ;**** Normally i would&#39;ve used this one<br />&nbsp; &nbsp; ;nummers&nbsp; &nbsp;  dd 0&nbsp; &nbsp; ;But now im creating the &#39;array&#39; without hardcoding their values in it.<br />&nbsp; &nbsp; message&nbsp; &nbsp;  db &quot;Totaal is %d&quot;,0<br />&nbsp;  <br />.data?<br />&nbsp; &nbsp; buffer&nbsp; &nbsp; &nbsp; db 100 dup(?)<br />&nbsp; &nbsp; nummers&nbsp; &nbsp;  db 250 dup(?)&nbsp;  ;Tried this as dd and db<br /><br />.code<br /><br />start:<br />&nbsp; &nbsp; xor&nbsp; &nbsp;  eax, eax<br />&nbsp; &nbsp; mov&nbsp; &nbsp;  ecx, 5<br />&nbsp;  <br />&nbsp; &nbsp; invoke&nbsp; StdIn, ADDR nummers, 250&nbsp; &nbsp; ;i enter: 12345 in console<br />&nbsp; &nbsp; sub&nbsp; &nbsp;  eax, 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; mov&nbsp; &nbsp;  BYTE PTR ,0&nbsp; &nbsp; ;strip off ,10,13 &#39;CR+LF&#39;<br />&nbsp; &nbsp; invoke&nbsp; atodw, nummers&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;convert to dword<br /><br />&nbsp; &nbsp; mov&nbsp; &nbsp;  edx, OFFSET nummers<br /><br />Count:<br />&nbsp; &nbsp; adc&nbsp; &nbsp;  eax, DWORD PTR <br />&nbsp;  <br />&nbsp; &nbsp; add&nbsp; &nbsp;  edx, 4<br />&nbsp; &nbsp; dec&nbsp; &nbsp;  ecx<br />&nbsp; &nbsp; jnz&nbsp; &nbsp;  Count<br /><br />&nbsp; &nbsp; invoke&nbsp; wsprintf,ADDR buffer, ADDR message, eax<br />&nbsp; &nbsp; invoke&nbsp; StdOut, ADDR buffer<br />&nbsp; &nbsp; invoke&nbsp; ExitProcess, 0<br /><br />END start<br /></code></pre><br /></div>
    <div class="meta">Posted on 2006-10-19 05:14:30 by w00</div>
   </div>
   <div class="post" id="post-186058">
    <div class="subject"><a href="#post-186058">Re: array problem</a></div>
    <div class="body">The only problem is that i dont know how to sepperate the whole decimal striing 12345 into sepperate numbers<br /><br />means 1,2,3,4,5 is it then method is simple<br /><br />12345 mod 10 =5 <br /> push 5<br /> divide 12345/10=1234<br /><br />1234 mod 10=4 <br />&nbsp; push 4 <br /> divide 1234/10=123<br /><br />123 mod 10=3<br /> push 3 <br /> divide 123/10=12<br /><br />12 mod 10=2&nbsp; <br />&nbsp; push 2<br /> divide 12/10=1<br /><br />1 mod 10 =1 <br />&nbsp;  push 1 <br /><br />pop 1<br />pop 2<br />pop 3<br />pop 4<br />pop 5<br /><br /></div>
    <div class="meta">Posted on 2006-10-19 11:04:04 by AssemblyBeginner</div>
   </div>
   <div class="post" id="post-186061">
    <div class="subject"><a href="#post-186061">Re: array problem</a></div>
    <div class="body">Thanks, but i dont think thats gonna work.<br />I used 12345 as an example, but what if a user enters 2535 as a number.<br />I could wrong about your example, its just that i dont see how i can make this work with any other value.</div>
    <div class="meta">Posted on 2006-10-19 12:22:14 by w00</div>
   </div>
   <div class="post" id="post-186062">
    <div class="subject"><a href="#post-186062">Re: array problem</a></div>
    <div class="body">2535<br /><br />2535 mod 10 =5 push 5 and 2535/10=253<br />253 mod 10=3 push 3 and 253/10 =25<br />25 mod 10 =5 push 5 and 25/10=2<br />2 mod 10=2 push 2<br /><br />pop 2<br />pop 5<br />pop 3<br />pop 5<br /><br />any value,have u try<br /></div>
    <div class="meta">Posted on 2006-10-19 12:26:33 by AssemblyBeginner</div>
   </div>
   <div class="post" id="post-186064">
    <div class="subject"><a href="#post-186064">Re: array problem</a></div>
    <div class="body">Let&#39;s say the EAX register holds the value of 0x00000010 which is equal to 16 in decimal. Now if you divide this value by 10 one time, the EAX will be set to 0x00000001 as the quotient and the EDX register will carry 0x00000006 as the remainder. Now we must keep the remainders until the number in the EAX register is zero. Therefore:<br /><br />EAX = 0x00000010 / 0x0000000A =&gt; Remainder(EDX) = 0x00000006, Quotient(EAX) = 0x00000001<br />EAX != 0x00000000 so keep on dividing<br />EAX = 0x00000001 / 0x0000000A =&gt; Remainder(EDX) = 0x00000001, Quotient(EAX) = 0x00000000<br /><br />Now that EAX is zero, you can reverse the order of the values in the EDX from down to up to get 0x00000001 and 0x00000006 which if put after each other would be 1 and 6 or 16.</div>
    <div class="meta">Posted on 2006-10-19 12:41:43 by XCHG</div>
   </div>
   <div class="post" id="post-186065">
    <div class="subject"><a href="#post-186065">Re: array problem</a></div>
    <div class="body">Thanks for the explanation, its a bit more clear now, so im gonna try some things out.</div>
    <div class="meta">Posted on 2006-10-19 13:42:37 by w00</div>
   </div>
   <div class="post" id="post-186066">
    <div class="subject"><a href="#post-186066">Re: array problem</a></div>
    <div class="body"><pre><span style="font-size:2>&nbsp; ; We are using 386 Instructions<br />&nbsp; .386<br />&nbsp; ; The Flat model with STDCALL calling convention<br />&nbsp; .MODEL FLAT, STDCALL<br />&nbsp; ; Set the mapping of characters<br />&nbsp; OPTION CASEMAP:NONE<br />; -------------------------------<br />&nbsp; ; I have installed MASM on drive D:\<br />&nbsp; INCLUDE D:\MASM32\INCLUDE\windows.inc<br />&nbsp; INCLUDE D:\MASM32\INCLUDE\MASM32.inc<br />&nbsp; INCLUDE D:\MASM32\INCLUDE\kernel32.inc<br />&nbsp; INCLUDE D:\MASM32\INCLUDE\User32.inc<br />; -------------------------------<br />&nbsp; ; Use the library files too<br />&nbsp; INCLUDELIB D:\MASM32\lib\MASM32.lib<br />&nbsp; INCLUDELIB D:\MASM32\lib\kernel32.lib<br />&nbsp; INCLUDELIB D:\MASM32\lib\User32.lib<br />; -------------------------------<br />&nbsp; ; The prototype for the dwtoa function (DWORD to ASCII)<br />&nbsp; ; We code code our own version of this which works faster<br />&nbsp; dwotoa PROTO :DWORD, :DWORD<br />; -------------------------------<br />&nbsp; ; Our data-section begins here<br />&nbsp; .DATA?<br />&nbsp; &nbsp; ; The 32-bit variable which will later hold the handle<br />&nbsp; &nbsp; ; to the console window with the Write access<br />&nbsp; &nbsp; StdWrite&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ?<br />&nbsp; &nbsp; ; The Read access variable, holding the console&#39;s handle<br />&nbsp; &nbsp; StdRead&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  DD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ?<br />&nbsp; &nbsp; ; A dummy variable which is going to be used with ReadFile<br />&nbsp; &nbsp; ; And WriteFile Win32 APIs<br />&nbsp; &nbsp; BytesWritten&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ?<br />&nbsp; &nbsp; ; Align our buffer on a DWORD boundary because it is going to<br />&nbsp; &nbsp; ; be constantly accessed, we don&#39;t want misalignment penalties<br />&nbsp; &nbsp; ALIGN&nbsp;  04h<br />&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DB&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 00FFh DUP(?)<br />&nbsp; .DATA<br />&nbsp; &nbsp; ; The introduction message which asks for the input string<br />&nbsp; &nbsp; IntroMsg&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DB&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;Please enter an integral value : &#39;, 0<br />&nbsp; &nbsp; ; The message which will show the sum of the bytes in the string<br />&nbsp; &nbsp; SumMsg&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DB&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;The sum is : &#39;, 0<br />&nbsp; &nbsp; ; Message which lets the user know that the string he or she has<br />&nbsp; &nbsp; ; entered is invalid<br />&nbsp; &nbsp; InvalidStr&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DB&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#39;I only accept numerical values!&#39;, 0<br />&nbsp; &nbsp; ; Begin the code section here<br />&nbsp; .CODE<br />; -------------------------------<br />; Align our function on a DWORD boundary<br />; Not a good practice on the code segment but better<br />; than misaligned code, we could use the EVEN keyword as well<br />; to make sure our function starts at least on an even address<br />ALIGN&nbsp;  04h<br />; The function which gets the sum of bytes<br />; inside a null-terminated string.<br />GetStrIntSum PROC __TheStr:DWORD<br />&nbsp; ; Push the base index onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; EBX<br />&nbsp; ; Push the data register onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; EDX<br />&nbsp; ; Move the __TheStr parameter to the base index<br />&nbsp; MOV&nbsp; &nbsp;  EBX , DWORD PTR <br />&nbsp; ; Zero out the data register which is later going<br />&nbsp; ; to be reading from the source string<br />&nbsp; XOR&nbsp; &nbsp;  EDX , EDX<br />&nbsp; ; Clear out the result of this function<br />&nbsp; XOR&nbsp; &nbsp;  EAX , EAX<br />&nbsp; ; The following label might be accessed N-2 times before we be<br />&nbsp; ; able to calculate the result where N is the length of the buffer<br />&nbsp; ; so we are going to have to align it on an even address<br />&nbsp; EVEN<br />&nbsp; ; The main loop of the function<br />&nbsp; @@__GetStrIntSumLoop:<br />&nbsp; &nbsp; ; Read one byte from the buffer. If we need to get<br />&nbsp; &nbsp; ; a better result speed-wise, we had to read 4 bytes<br />&nbsp; &nbsp; ; at a time to avoid partial register stall but<br />&nbsp; &nbsp; ; this keeps the process of understanding the code simpler<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  DL , BYTE PTR <br />&nbsp; &nbsp; ; See if we have found the null-terminator<br />&nbsp; &nbsp; TEST&nbsp; &nbsp; DL , DL<br />&nbsp; &nbsp; ; Jump to the end of the procedure if yes<br />&nbsp; &nbsp; JE&nbsp; &nbsp; &nbsp; @@__GetStrIntSumEP<br />&nbsp; &nbsp; ; Change the byte to a numerical value<br />&nbsp; &nbsp; AND&nbsp; &nbsp;  DL , 0CFh<br />&nbsp; &nbsp; ; Add the temporary result to the main result<br />&nbsp; &nbsp; ; of the function<br />&nbsp; &nbsp; ADD&nbsp; &nbsp;  EAX , EDX<br />&nbsp; &nbsp; ; Move to the next byte in the buffer. Note that partial<br />&nbsp; &nbsp; ; modification of the CPU flags done by the INC and the DEC<br />&nbsp; &nbsp; ; instructions can sometimes make the process slower but not<br />&nbsp; &nbsp; ; necessarily always<br />&nbsp; &nbsp; INC&nbsp; &nbsp;  EBX<br />&nbsp; &nbsp; ; Keep reading from the buffer<br />&nbsp; &nbsp; JMP&nbsp; &nbsp;  @@__GetStrIntSumLoop<br />&nbsp; ; End of the procedure routine. This label doesn&#39;t have to<br />&nbsp; ; be aligned on an even address because it is not accessed<br />&nbsp; ; as often as the previous label<br />&nbsp; @@__GetStrIntSumEP:<br />&nbsp; &nbsp; ; Restore the data register<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  EDX<br />&nbsp; &nbsp; ; Restore the base index<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  EBX<br />&nbsp; ; Return to the calling procedure<br />&nbsp; RET<br />GetStrIntSum ENDP<br />; -------------------------------<br />; Align this procedure on DWORD boundaries in the code segment<br />ALIGN&nbsp;  04h<br />; The function returns 0x00000001 in the accumulator (EAX) if<br />; the __TheStr parameter contains only numeric values and 0x00000000<br />; if it contains alphanumerical<br />IsIntegralStr PROC __TheStr:DWORD<br />&nbsp; ; Push the base index onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; EBX<br />&nbsp; ; Push the data register onto the stack and break<br />&nbsp; ; the dependence chain between the previous and the next<br />&nbsp; ; lines of the code<br />&nbsp; PUSH&nbsp; &nbsp; EDX<br />&nbsp; ; the base index now points to the __TheStr null-terminated string<br />&nbsp; MOV&nbsp; &nbsp;  EBX , DWORD PTR <br />&nbsp; ; Set the result to zero, temporarily, as in False<br />&nbsp; XOR&nbsp; &nbsp;  EAX , EAX<br />&nbsp; ; Align the following label on an even address in the code segment<br />&nbsp; EVEN<br />&nbsp; ; The main loop of the function<br />&nbsp; @@__IsIntegralStrLoop:<br />&nbsp; &nbsp; ; Read one byte from the string. We shouldn&#39;t read only one byte<br />&nbsp; &nbsp; ; as explained earlier as we are going to waste a lot of clock-cycles<br />&nbsp; &nbsp; ; for partial register access stall<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  DL , BYTE PTR <br />&nbsp; &nbsp; ; See if we have reached the end of the string<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  DH , DL<br />&nbsp; &nbsp; ; Convert the character to its equivalent numeric value<br />&nbsp; &nbsp; AND&nbsp; &nbsp;  DL , 0CFh<br />&nbsp; &nbsp; ; See if the value is in the range 0..9<br />&nbsp; &nbsp; CMP&nbsp; &nbsp;  DL , 09h<br />&nbsp; &nbsp; ; Jump to the end of the procedure if not<br />&nbsp; &nbsp; JG&nbsp; &nbsp; &nbsp; @@__IsIntegralStrEP<br />&nbsp; &nbsp; ; Move to the next byte of the string. We could put this instruction<br />&nbsp; &nbsp; ; priot to the &quot;CMP&quot; instruction in the previous line to break the<br />&nbsp; &nbsp; ; dependence chain<br />&nbsp; &nbsp; INC&nbsp; &nbsp;  EBX<br />&nbsp; &nbsp; ; See if the original byte is zero<br />&nbsp; &nbsp; TEST&nbsp; &nbsp; DH , DH<br />&nbsp; &nbsp; ; Keep summing up the result if not<br />&nbsp; &nbsp; JNE&nbsp; &nbsp;  @@__IsIntegralStrLoop<br />&nbsp; ; Set the EAX to EAX+1 which would result in 0x00000001<br />&nbsp; INC&nbsp; &nbsp;  EAX<br />&nbsp; ; End of the procedure routine<br />&nbsp; @@__IsIntegralStrEP:<br />&nbsp; &nbsp; ; Restore the data register<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  EDX<br />&nbsp; &nbsp; ; Restore the base index<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  EBX<br />&nbsp; ; Return to the calling procedure<br />&nbsp; RET<br />IsIntegralStr ENDP<br />; -------------------------------<br />; Start our code on an even address<br />EVEN<br />START:<br />&nbsp; ; Allocate a console window for our program<br />&nbsp; INVOKE&nbsp; AllocConsole<br />&nbsp; ; See if the result is zero (Success)<br />&nbsp; TEST&nbsp; &nbsp; EAX , EAX<br />&nbsp; ; Jump to the end of the program if not (Failure)<br />&nbsp; JNE&nbsp; &nbsp;  @@__EP<br />&nbsp; ; Get the OUTPUT handle of the console window<br />&nbsp; INVOKE&nbsp; GetStdHandle, STD_OUTPUT_HANDLE<br />&nbsp; ; Put the handle in the StdWrite variable<br />&nbsp; MOV&nbsp; &nbsp;  StdWrite , EAX<br />&nbsp; ; Get the INPUT handle of the console window<br />&nbsp; INVOKE&nbsp; GetStdHandle, STD_INPUT_HANDLE<br />&nbsp; ; Put it in the StdRead variable<br />&nbsp; MOV&nbsp; &nbsp;  StdRead , EAX<br />&nbsp; ; Get the length of the intro message because for every attempt<br />&nbsp; ; to read from and write to the console window with ReadFile and<br />&nbsp; ; WriteFile respectively, we have to mention the length of the message<br />&nbsp; ; excluding the null-terminator<br />&nbsp; INVOKE&nbsp; lstrlen, OFFSET IntroMsg<br />&nbsp; ; Write the intro message to the screen with its length<br />&nbsp; ; inside the accumulator (EAX)<br />&nbsp; INVOKE&nbsp; WriteFile, StdWrite, OFFSET IntroMsg, EAX, OFFSET BytesWritten, 0b<br />&nbsp; ; Wait for the user&#39;s response and put the response in the Buffer<br />&nbsp; INVOKE&nbsp; ReadFile, StdRead, OFFSET Buffer, 00FFh, OFFSET BytesWritten, 0b<br />&nbsp; ; Get the length of the Buffer<br />&nbsp; INVOKE&nbsp; lstrlen, OFFSET Buffer<br />&nbsp; ; The base index now points to the buffer<br />&nbsp; MOV&nbsp; &nbsp;  EBX , OFFSET Buffer<br />&nbsp; ; Remove the trailing CR and the LF from the buffer<br />&nbsp; ; using scaled and indexed addressing modes<br />&nbsp; MOV&nbsp; &nbsp;  WORD PTR  , 0000h<br />&nbsp; ; See if the string contains only numerals<br />&nbsp; INVOKE&nbsp; IsIntegralStr, OFFSET Buffer<br />&nbsp; ; See if the result is zero (Failure)<br />&nbsp; TEST&nbsp; &nbsp; EAX , EAX<br />&nbsp; ; Jump to ... if not (Success)<br />&nbsp; JNE&nbsp; &nbsp;  @@__IsIntegral<br />&nbsp; ; Get the length of the ending message<br />&nbsp; INVOKE&nbsp; lstrlen, OFFSET InvalidStr<br />&nbsp; ; Say goodbye to the user<br />&nbsp; INVOKE&nbsp; WriteFile, StdWrite, OFFSET InvalidStr, EAX, OFFSET BytesWritten, 0b<br />&nbsp; ; Jump to the end of the program<br />&nbsp; JMP&nbsp; &nbsp;  @@__EP<br />&nbsp; @@__IsIntegral:<br />&nbsp; &nbsp; ; Get the sum of the numerical values inside the buffer<br />&nbsp; &nbsp; INVOKE&nbsp; GetStrIntSum, OFFSET Buffer<br />&nbsp; &nbsp; ; Convert this value to a string inside the Buffer itself<br />&nbsp; &nbsp; INVOKE&nbsp; dwtoa, EAX, OFFSET Buffer<br />&nbsp; &nbsp; ; Get the length of the message that we need to print<br />&nbsp; &nbsp; INVOKE&nbsp; lstrlen, OFFSET SumMsg<br />&nbsp; &nbsp; ; Write the message to the screen. Note that we haven&#39;t yet put the<br />&nbsp; &nbsp; ; sum to the console window.<br />&nbsp; &nbsp; INVOKE&nbsp; WriteFile, StdWrite, OFFSET SumMsg, EAX, OFFSET BytesWritten, 0b<br />&nbsp; &nbsp; ; Get the length of the sum of the numerical values converted to<br />&nbsp; &nbsp; ; a null-terminated string<br />&nbsp; &nbsp; INVOKE&nbsp; lstrlen, OFFSET Buffer<br />&nbsp; &nbsp; ; Write the sum to the output window<br />&nbsp; &nbsp; INVOKE&nbsp; WriteFile, StdWrite, OFFSET Buffer, EAX, OFFSET BytesWritten, 0b<br />&nbsp; &nbsp; ; Close the Write handle<br />&nbsp; &nbsp; INVOKE&nbsp; CloseHandle, StdWrite<br />&nbsp; &nbsp; ; Close the Read handle<br />&nbsp; &nbsp; INVOKE&nbsp; CloseHandle, StdRead<br />&nbsp; ; End of the program routine<br />&nbsp; @@__EP:<br />&nbsp; &nbsp; ; Exit the current process<br />&nbsp; &nbsp; INVOKE&nbsp; ExitProcess, 0b<br />; End of the main procedure<br />END START</span></pre>Good luck.</div>
    <div class="meta">Posted on 2006-10-19 15:51:52 by XCHG</div>
   </div>
   <div class="post" id="post-186423">
    <div class="subject"><a href="#post-186423">Re: array problem</a></div>
    <div class="body">Sorry i forgot all about this but, thanks alot!<br />I wanted to read the old posts so i could give it a try again, but then i noticed your post. It works excellent!<br />I was just hoping if you have the time, that you could explain the code. It feels better if i know what im assembling instead of guessing what i could be.<br /><br />Anyway, thanks again!</div>
    <div class="meta">Posted on 2006-11-07 12:51:27 by w00</div>
   </div>
   <div class="post" id="post-186496">
    <div class="subject"><a href="#post-186496">Re: array problem</a></div>
    <div class="body">This is what we have to do. We have to allocate a console window for our program first because we are going to create a console application. Then we have to get the handle to the console window with the read and the write access so we can read from and write to it.<br /><br />After having passed the above steps, it is time to tell the user what we are intending to do and wait for his or her answer. When the user hits the Enter Key, we should start our main task by first removing the Carriage Return and the Line Feed from the end of the entered string. If you don?t do that, the answer that you will get will be inaccurate because you will be calculating the integral value of the CR and the LF too.<br /><br />Now we have to pass this string to a function which tells us if the string contains only numeral values or not. You can do this by masking out the fourth and the fifth bits of individual bytes inside the string. The byte will then be numeral if it contains the value 9 or below, down to zero. For example, if the user has entered ?A90?, you will ?AND? the ASCII value of the character ?A? with 0xCF to mask-out the fourth and the fifth bits. The ASCII value of the character ?A? is 0x41 which when applied the ?AND? instruction with 0xCF will result in 0x41. This is not a value between the range 0..9 so it is not an integral value, thus, we have to return ?False?.<br /><br />After confirming that the string contains integral values, solely, we have to read each and every byte of the string and convert them to their corresponding integral values using the ?AND 0xCF? again and sum up all these values. <strong>I have modified the code for you in my previous post so that it contains comment on each line.</strong></div>
    <div class="meta">Posted on 2006-11-11 09:17:29 by XCHG</div>
   </div>
   <div class="post" id="post-186531">
    <div class="subject"><a href="#post-186531">Re: array problem</a></div>
    <div class="body">Thanks a lot! Its a good explanation, i kinda understand it all now :)</div>
    <div class="meta">Posted on 2006-11-14 06:59:41 by w00</div>
   </div>
  </div>
 </body>
</html>