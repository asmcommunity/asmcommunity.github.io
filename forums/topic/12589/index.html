<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Saving Private Bumps - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=12589" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=12589">Saving Private Bumps</a></p>
   <div class="post" id="post-97405">
    <div class="subject"><a href="#post-97405">Saving Private Bumps</a></div>
    <div class="body">Heya.<br />I have just tried implementing a screengrabber based on code found over at MSDN ... what's wrong with GetDIBits ? Is it wrong to grab the desktop this way?<br /><br /><br /><br />;The following code was translated from cpp source located at <a target="_blank" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/gdi/bitmaps_87eb.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/gdi/bitmaps_87eb.asp</a><br /><br />;-----------------------------------------------------------------------------------------------------------------------------------------------<br />;This procedure creates a named BMP file given pbi, bmphandle and dchandle of source image.<br />;-----------------------------------------------------------------------------------------------------------------------------------------------<br />CreateBMPFile PROC pszFile:DWORD, pbi:PTR BITMAPINFO,  hBMP:HBITMAP , hDC:HDC <br /> LOCAL   hf:HANDLE                                   ;    // file handle <br /> LOCAL   hdr:BITMAPFILEHEADER           ;    // bitmap file-header <br /> LOCAL    pbih:PTR BITMAPINFOHEADER ;     // bitmap info-header <br />LOCAL hdc:HANDLE<br />LOCAL hBMp:HANDLE<br /> LOCAL    lpBits:PTR BYTE                    ;      // memory pointer <br /> LOCAL    dwTotal:DWORD                   ;       // total count of bytes <br /> LOCAL    cb:DWORD                              ;     // incremental count of bytes <br /> LOCAL     hp:PTR BYTE                        ;      // byte pointer <br /> LOCAL     dwTmp:DWORD<br />;-----------------------------------------------------------------------------------------------------------------------------------------------<br />    mov eax, pbi  <br />    mov pbih,eax<br />    mov eax,hDC<br />    mov hdc,eax<br />    mov eax,hBMP<br />    mov hBMp,eax<br />    mov esi,pbih<br />    push esi<br />    mov lpBits ,$invoke (GlobalAlloc,GMEM_FIXED, .BITMAPINFOHEADER .biSizeImage)<br />    pop esi<br />    .if !eax<br />         invoke MessageBox,0,CTXT(&quot;Failed GlobalAlloc&quot;),CTXT(&quot;ERROR&quot;),MB_OK+MB_ICONERROR<br />         jmp Byee<br />    .endif<br />;    // Retrieve the color table (RGBQUAD array) and the bits (array of palette indices) from the DIB. <br />    push esi<br />     invoke GetDIBits,hdc, hBMp, 0, .BITMAPINFOHEADER.biHeight, lpBits, esi, DIB_RGB_COLORS<br />    pop esi<br />    .if !eax<br />         invoke MessageBox,0,CTXT(&quot;Failed GetDIBits&quot;),CTXT(&quot;ERROR&quot;),MB_OK+MB_ICONERROR<br />         jmp @F<br />    .endif<br /><br />;    // Create the .BMP file. <br />    push esi<br />    mov hf , $invoke (CreateFile,pszFile,GENERIC_READ or GENERIC_WRITE, 0,0, CREATE_ALWAYS,  FILE_ATTRIBUTE_NORMAL, 0) <br />    pop esi<br />    .if eax == INVALID_HANDLE_VALUE <br />         invoke MessageBox,0,CTXT(&quot;Failed CreateFile&quot;),CTXT(&quot;ERROR&quot;),MB_OK+MB_ICONERROR<br />         jmp @F<br />    .endif<br />    mov hdr.bfType , 4d42h              ;        // 0x42 = &quot;B&quot; 0x4d = &quot;M&quot; <br /><br />;    // Compute the size of the entire file. <br />    mov eax,.BITMAPINFOHEADER.biClrUsed <br />    mov ebx,sizeof(RGBQUAD)<br />    mul ebx    <br />    add eax,sizeof (BITMAPFILEHEADER)<br />    add eax,.BITMAPINFOHEADER.biSize<br />    add eax,.BITMAPINFOHEADER.biSizeImage<br />    mov hdr.bfSize ,   eax<br /><br />    mov hdr.bfReserved1 , 0 <br />    mov hdr.bfReserved2 , 0 <br /><br />;    // Compute the offset to the array of color indices. <br />    mov eax,.BITMAPINFOHEADER.biClrUsed<br />    mov ebx,sizeof (RGBQUAD)<br />    mul ebx<br />    add eax,sizeof(BITMAPFILEHEADER)<br />    add eax,.BITMAPINFOHEADER.biSize<br />    mov hdr.bfOffBits ,eax<br /><br />;    // Copy the BITMAPFILEHEADER into the .BMP file. <br />    push esi<br />    invoke WriteFile,hf, addr hdr, sizeof(BITMAPFILEHEADER), addr dwTmp,  0<br />    pop esi<br />    .if !eax<br />         invoke MessageBox,0,CTXT(&quot;Failed WriteFile (FileHeader)&quot;),CTXT(&quot;ERROR&quot;),MB_OK+MB_ICONERROR<br />         jmp @F<br />    .endif<br /><br />;    // Copy the BITMAPINFOHEADER and RGBQUAD array into the file. <br />    mov eax,.BITMAPINFOHEADER.biClrUsed<br />    mov ebx,sizeof (RGBQUAD)<br />    mul ebx<br />    add eax,sizeof(BITMAPINFOHEADER)<br />    mov ebx,eax<br />    push esi<br />    invoke WriteFile,hf, esi, ebx, addr dwTmp, 0<br />    pop esi<br />    .if !eax<br />         invoke MessageBox,0,CTXT(&quot;Failed WriteFile (InfoHeader)&quot;),CTXT(&quot;ERROR&quot;),MB_OK+MB_ICONERROR<br />         jmp @F<br />    .endif<br /><br />;    // Copy the array of color indices into the .BMP file. <br />    mov eax,.BITMAPINFOHEADER.biSizeImage<br />    mov cb,eax<br />    mov dwTotal ,eax<br />    m2m hp , lpBits <br />    push esi<br />    invoke WriteFile,hf, hp, cb, addr dwTmp,0<br />    pop esi<br />    .if !eax<br />         invoke MessageBox,0,CTXT(&quot;Failed WriteFile (ColorData)&quot;),CTXT(&quot;ERROR&quot;),MB_OK+MB_ICONERROR<br />         jmp @F<br />    .endif<br />     invoke CloseHandle,hf                                      ;     Close the .BMP file. <br />@@:<br />    invoke GlobalFree,lpBits                                    ;     Free memory. <br />Byee:<br />    ret<br />CreateBMPFile ENDP<br />;-----------------------------------------------------------------------------------------------------------------------------------------------<br /><br />;-----------------------------------------------------------------------------------------------------------------------------------------------<br />;This procedure creates a BitMapInfo struct and returns a handle to it<br />;-----------------------------------------------------------------------------------------------------------------------------------------------<br />CreateBitmapInfoStruct PROC hBmp:HBITMAP  <br />    LOCAL bmp:BITMAP<br />    LOCAL pbmi:PTR BITMAPINFO  <br />    LOCAL cClrBits:WORD    <br /> ;-----------------------------------------------------------------------------------------------------------------------------------------------<br />    push esi<br />;    /* Retrieve the bitmap's color format, width, and height. */ <br />   invoke GetObject,hBmp, sizeof bmp, addr bmp<br />    .if !eax<br />         invoke MessageBox,0,CTXT(&quot;Failed GetObject&quot;),CTXT(&quot;ERROR&quot;),MB_OK+MB_ICONERROR<br />         jmp @F<br />    .endif<br /> <br />;    /* Convert the color format to a count of bits. */ <br />    xor eax,eax<br />    xor ebx,ebx<br />    mov ax,bmp.bmPlanes<br />    mul bmp.bmBitsPixel<br />    mov cClrBits ,ax<br /> <br />    .if cClrBits == 1 <br />        nop        <br />    .elseif cClrBits &lt;= 4 <br />        mov cClrBits , 4 <br />    .elseif cClrBits &lt;= 8<br />        mov cClrBits , 8; <br />    .elseif cClrBits &lt;= 16 <br />        mov cClrBits , 16; <br />    .elseif cClrBits &lt;= 24 <br />        mov cClrBits , 24; <br />    .else <br />        mov cClrBits , 32; <br />    .endif<br />   <br />;      Allocate memory for the BITMAPINFO structure. (This structure contains <br />;      a BITMAPINFOHEADER structure and an array of RGBQUAD data structures.) <br />;pbmi = (PBITMAPINFO) LocalAlloc(LPTR,  sizeof(BITMAPINFOHEADER) + <br />;                    sizeof(RGBQUAD) * (1&lt;&lt; cClrBits)); <br />      <br />    push esi<br />    .if cClrBits != 24 <br />         xor ecx,ecx<br />         mov eax,sizeof(RGBQUAD)     <br />         mov cx,cClrBits<br />         shl ecx,1<br />         mul ecx<br />         add eax,sizeof(BITMAPINFOHEADER)<br />         mov pbmi ,$invoke (LocalAlloc,LPTR, eax) <br />     .else              ;     * There is no RGBQUAD array for the 24-bit-per-pixel format. <br />         mov pbmi , $invoke (LocalAlloc,LPTR,sizeof(BITMAPINFOHEADER))<br />    .endif<br />    pop esi <br /> <br />;    /* Initialize the fields in the BITMAPINFO structure. */ <br /> <br />    mov .BITMAPINFOHEADER.biSize , sizeof(BITMAPINFOHEADER); <br />    m2m .BITMAPINFOHEADER.biWidth , bmp.bmWidth; <br />    m2m .BITMAPINFOHEADER.biHeight , bmp.bmHeight; <br />    m2m .BITMAPINFOHEADER.biPlanes , bmp.bmPlanes; <br />    m2m .BITMAPINFOHEADER.biBitCount , bmp.bmBitsPixel<br /><br />    .if cClrBits &lt; 24                           ; pbmi-&gt;bmiHeader.biClrUsed = (1&lt;&lt;cClrBits);<br />        xor eax,eax<br />        mov ax,cClrBits<br />        shl eax,1<br />        mov .BITMAPINFOHEADER.biClrUsed ,eax <br />    .endif<br /> <br />;    /* If the bitmap is not compressed, set the BI_RGB flag. */ <br />    mov .BITMAPINFOHEADER.biCompression , BI_RGB<br /> <br />;     * Compute the number of bytes in the array of color <br />;     * indices and store the result in biSizeImage. <br />;   pbmi-&gt;bmiHeader.biSizeImage = ((pbmi-&gt;bmiHeader.biWidth * cClrBits +31) &amp; ~31) /8 * pbmi-&gt;bmiHeader.biHeight;<br />    mov eax,.BITMAPINFOHEADER.biWidth<br />    xor ebx,ebx<br />    mov bx,cClrBits<br />    mul ebx<br />    mov ebx,31<br />    add eax,ebx                                                      ;+31<br />    not ebx <br />    and eax,ebx                                                      ;&amp;~31<br />    shr eax,3                                                           ;/8<br />    mov ebx,.BITMAPINFOHEADER.biHeight<br />    mul ebx    <br />    mov .BITMAPINFOHEADER.biSizeImage ,eax<br /> <br />;     * Set biClrImportant to 0, indicating that all of the device colors are important. <br />    mov .BITMAPINFOHEADER.biClrImportant , 0<br /><br />@@:<br />    pop esi<br />    mov eax, pbmi<br />    ret<br />CreateBitmapInfoStruct ENDP<br />;-----------------------------------------------------------------------------------------------------------------------------------------------<br /><br />;-----------------------------------------------------------------------------------------------------------------------------------------------<br />;This code takes a screenshot of the desktop window, saving it to a named bmpfile<br />;-----------------------------------------------------------------------------------------------------------------------------------------------<br />ScreenShot PROC pFile:DWORD, XX:DWORD,YY:DWORD<br />LOCAL hBmp:HANDLE<br />LOCAL hDC:HANDLE<br />LOCAL hMyDC:HANDLE<br />LOCAL pbmi:PTR BITMAPINFOHEADER<br /><br />mov hDC,    $invoke (GetDC,HWND_DESKTOP)<br />invoke CreateCompatibleDC,eax<br />mov hMyDC,eax<br />mov hBmp, $invoke (CreateCompatibleBitmap,eax,XX,YY)<br />.if eax==0<br />    invoke MessageBox,0,CTXT(&quot;Failed CreateCompatibleBitmap&quot;),CTXT(&quot;ERROR&quot;),MB_OK+MB_ICONERROR<br />    jmp @F<br />.endif<br />mov pbmi, $invoke (CreateBitmapInfoStruct,hBmp)          ;returns pbmi<br />invoke CreateBMPFile,pFile, pbmi,  hBmp , hMyDC <br />invoke LocalFree,pbmi<br />invoke DeleteObject,hBmp<br />invoke DeleteDC,hMyDC<br />invoke DeleteDC,hDC<br />@@:     ret<br />ScreenShot ENDP<br />;-----------------------------------------------------------------------------------------------------------------------------------------------</div>
    <div class="meta">Posted on 2003-04-16 23:33:39 by Homer</div>
   </div>
  </div>
 </body>
</html>