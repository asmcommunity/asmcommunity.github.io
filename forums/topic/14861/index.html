<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>One more OOP crazyness - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=14861" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=38">Object Oriented Programming</a> &raquo; <a href="../?id=14861">One more OOP crazyness</a></p>
   <div class="post" id="post-115330">
    <div class="subject"><a href="#post-115330">One more OOP crazyness</a></div>
    <div class="body">Hello, all!<br /><br />I'm not good with objects and with english :)<br /><br />But here is one more crazyness I found about objects.<br /><br />For some time I was using (well, trying to implement) my own object model.<br />(there alot &quot;to do&quot; in it, of coz)<br /><br />Just one thing I've noticed:<br />When we use VTable, it usually contains some data (for example pointers to some metods, variables, etc)<br />Each data field is usually DWORD (we are on WIntel platform)<br /><br /><strong>Now the main idea:</strong><br />If field  contains a pointer (to some address), then address is always &lt; 8000 0000h for user mode.<br />So we surelly know, that the 31st bit must be alwais zero.<br />Let's say, we need not to save this bit in to memory ;) But anyway we will use DWORD.<br />So I use this bit for other purposes (in my case this flag shows has my object custom destructor or uses standart one)<br />It allow me to have smalest object size = DWORD (if it uses only one metod)<br />And one more, this object can be &quot;suspended&quot; (objects I'm using are automatically executed during main loop)<br />For this purpose I use the 30th bit as a flag.<br /><br />Of cource, this &quot;economy&quot; will not give us much space saving if we're using objects that are ~100DWORD size, but if we have 1000000 small objects...<br /><br />Since I've never seen this technic before, what do you think about it?<br /><br />P.S. may be  :stupid: ?</div>
    <div class="meta">Posted on 2003-08-24 22:15:12 by S.T.A.S.</div>
   </div>
   <div class="post" id="post-115332">
    <div class="subject"><a href="#post-115332">One more OOP crazyness</a></div>
    <div class="body">For many small objects nothing beat an array. ;)<br /><span style="font-size:9px>(You already have proved this in another thread.)</span><br /><br />I think objects should be a larger thing - throw in another DWORD for 32 flags. :grin:</div>
    <div class="meta">Posted on 2003-08-24 22:34:07 by bitRAKE</div>
   </div>
   <div class="post" id="post-115341">
    <div class="subject"><a href="#post-115341">One more OOP crazyness</a></div>
    <div class="body"><div class="quote"><br />For many small objects nothing beat an array. ;)</div><br />Yes, I have &quot;array&quot; of very small &quot;objects&quot; ;)<br /><br /><div class="quote"><em><strong>throw in another DWORD for 32 flags.</div><br />Be sure, I'll do so one day...<br />I mean flags not for &quot;objects&quot; but for &quot;objects manager&quot;.<br />Really I use &quot;big&quot; and &quot;smal&quot; objects at the one time. I just want an universal format, that will work good with  both of them (well, &quot;in most cases&quot;)<br /><br />My idea is really very strange, if we will think high level, but hard facts are: my CPU is able to execute up to ~4G instructions per second, but just able to read  (theoretically) 2,1Mb/sec (really ~1700). I think It's better to calculate something, than to read/write/move from mem.<br /><br />If RAM has &quot;no limit&quot; in size, so we shouldn't save it. But cache is not so big, what if i wanna all my objects to be in cache?</div>
    <div class="meta">Posted on 2003-08-24 23:48:44 by S.T.A.S.</div>
   </div>
   <div class="post" id="post-115345">
    <div class="subject"><a href="#post-115345">One more OOP crazyness</a></div>
    <div class="body"><div class="quote"><br />My idea is really very strange, if we will think high level, but hard facts are: my CPU is able to execute up to ~4G instructions per second, but just able to read  (theoretically) 2,1Mb/sec (really ~1700). I think It's better to calculate something, than to read/write/move from mem. </div>Ah, you have more wisdom than you let on!  My CPU can execute ~18G instructions per second and similarly disproportional memory speed -- there is no shortage of CPU cycles per memory access.  The fact that people are able to test the difference in processors at these speeds is a product of poor compiler technology.  Really makes us seem crazy for wanting to do it in ASM.  ...then along comes hyperthreading to redeem the clock cycle care of the ASM programmer. ;)</div>
    <div class="meta">Posted on 2003-08-25 00:09:11 by bitRAKE</div>
   </div>
   <div class="post" id="post-115358">
    <div class="subject"><a href="#post-115358">One more OOP crazyness</a></div>
    <div class="body">Hi, <strong>bitRAKE</strong>!<br />What a nice CPU do you have?<br /><br /><div class="quote"><br />..then along comes hyperthreading to redeem the clock cycle care of the ASM programmer. ;) </div><br />I know a bit about HT. It seems to me, that Intel has take a look at an old hack of its i8080 (made by Zilog)<br />Z80 has two sets of registers, and instructions to change beetwin them. It was quite usefull thing...<br />Hardware swithing, IMHO, will help only C programmers (with Intel compiler, only).  Why I need 2 logical &quot;CPU&quot; , if one isn't able to get all the data that it can use? Then the second will just trashe cashe...<br />I read somewhere ot this board, that multithreading is even worse :o <br /><br />I made this thread not to say &quot;I know how to do the best object model&quot;, I'm just interesting in all possibilites &quot;haw to do someting better&quot;. Discussion, IMHO, is one of best ways...<br /><br />P.S. Just one real thing I've seen on CPU with HT : Zyxel UNO driver completly freezes win XP, when HT is on :grin:</div>
    <div class="meta">Posted on 2003-08-25 01:31:09 by S.T.A.S.</div>
   </div>
   <div class="post" id="post-115359">
    <div class="subject"><a href="#post-115359">One more OOP crazyness</a></div>
    <div class="body">I have a +2Ghz Athlon XP - it can execute 9 NOP's per cycle. :)<br /><span style="font-size:9px>(It is also the only processor that can execute 3 MMX instructions per cycle!  Although it is not very useful with only 8 MMX registers, but I know the Opteron must do similar or better.)</span><br /><br />I believe HT will require multiple memory buses in the near future - similar to AMD's approach with the Opteron.  Otherwise Intel will take a back seat to AMD's performance.  If Windows used the CPU's task switching for threads then Intel could have just plugged in the HT there, and would have been more efficient, imho.  I think it took Intel too long to get over OS designers not liking all the R&amp;D they put into Task Switching - it's just too damn confusing.  AMD didn't design all that - they just had to implement it.  This left room for AMD's R&amp;D to look elsewhere for improvements.<br /><br />This does seem like a good idea and you have supported your view well.  The idea about fitting all your objects in cache convinced me. ;)</div>
    <div class="meta">Posted on 2003-08-25 01:49:55 by bitRAKE</div>
   </div>
   <div class="post" id="post-115370">
    <div class="subject"><a href="#post-115370">One more OOP crazyness</a></div>
    <div class="body"><div class="quote"><br />I have a +2Ghz Athlon XP - it can execute 9 NOP's per cycle. :)</div><br />That's what I just get! <br />But my code runs on it with the same speed as it does on my previous Athlon1000 :mad: <br />Thought CPU has at least 60% faster core.<br />That is why I'm thinking about such &quot;odd&quot; things like this &quot;One more OOP crazyness&quot; :rolleyes:</div>
    <div class="meta">Posted on 2003-08-25 02:40:08 by S.T.A.S.</div>
   </div>
   <div class="post" id="post-115373">
    <div class="subject"><a href="#post-115373">One more OOP crazyness</a></div>
    <div class="body">Okay, here's another, crazier idea:<br />parallel tables.<br /><br />Let's view objects of the same class as a spreadsheet.<br /><br />Let each row be one object, and each column be an attribute.<br /><pre><code><br />           XPos YPos ZPos Color<br />Particle1   ..   ..   ..   ..<br />Particle2   ..   ..   ..   ..<br />Patricle3   ..   ..   ..   ..<br /></code></pre><br /><br />Now, most object languages arrange the data row-by-row; that is, in memory, they do:<br />Particle1.XPos<br />Particle1.YPos<br />Particle1.ZPos<br />Particle1.Color<br />Particle2.XPos<br />Particle2.YPos<br />Particle2.ZPos<br />Particle2.Color<br />Particle3.XPos<br />Particle3.YPos<br />Particle3.ZPos<br />Particle3.Color<br /><br />However, AFAIK nothing prevents us from doing:<br />Particle1.XPos<br />Particle2.XPos<br />Particle3.XPos<br />Particle1.YPos<br />Particle2.YPos<br />Particle3.YPos<br />Particle1.ZPos<br />Particle2.ZPos<br />Particle3.ZPos<br />Particle1.Color<br />Particle2.Color<br />Particle3.Color<br /><br /><br />Considering the fact that SOME methods will need to work with several different objects, but only a few of the attributes.  For instance, a particle system's PullAllParticlesDown method will prolly work with only the Y positions of all the particles.  By lumping the YPos attributes together, we can make it more likely that, for the method's run, most of the data is in the cache.  If a method makes use of 2 or three attributes from several objects, we, as ASM programmers, have the power to arrange the parallel tables so that they sit right next to each other.<br /><br />While this means that adding new objects is kinda difficult, it also means that adding new ATTRIBUTES is also relatively easier.  And there is no real need to reassemble existing methods - adding a new attribute that existing methods don't care about will not rearrange the existing tables.  In the standard way of arranging data, at the very least we need to change the length of each record/object, so our method (which handles an array of objects) must be reassembled to, at the very least, change the length of the object.<br /><br />NOTE however that such a layout is more powerful if, and only if, we are using methods that work with lots of objects but only a few attributes at a time.  Most things I can think of fall in here.<br /><br />Like for instance, when, say, rendering game objects, I care about the position and color, but I do not need to display certain status things that I don't want the player to see.  At rendering time, all I care about are the position and color.  However, at another time, I will be considering the effects of those status, then I will look at them, but I won't be interested in the position or color.  Out of sight, out of mind.</div>
    <div class="meta">Posted on 2003-08-25 03:02:06 by AmkG</div>
   </div>
   <div class="post" id="post-115490">
    <div class="subject"><a href="#post-115490">One more OOP crazyness</a></div>
    <div class="body">Hi, <strong>AmkG</strong>!<br />Very simple and powerful! Like all genious ;) <br /><br /><div class="quote">While this means that adding new objects is kinda difficult</div> <br />Why not to greate all objects, and mark some of them &quot;suspended&quot;?<br /><br /><div class="quote">And there is no real need to reassemble existing methods - adding a new attribute that existing methods don't care about will not rearrange the existing tables. In the standard way of arranging data, at the very least we need to change the length of each record/object, so our method (which handles an array of objects) must be reassembled to, at the very least, change the length of the object.</div><br />This should be posted to &quot;The Crusades&quot;, IMHO :alright:<br /><br /><br /><strong>bitRAKE</strong>, as I think, AtlonXP2+, is able to execute 9*12,5*133 =15G NOP/sec<br /><span style="font-size:9px>Though can read just 1,7GNOPs , so we have to use JMP that will take some execution time, too</span></div>
    <div class="meta">Posted on 2003-08-25 23:49:48 by S.T.A.S.</div>
   </div>
   <div class="post" id="post-115491">
    <div class="subject"><a href="#post-115491">One more OOP crazyness</a></div>
    <div class="body"><div class="quote"><br />bitRAKE</strong>, as I think, AtlonXP2+, is able to execute 9*12,5*133 =15G NOP/sec<br /><span style="font-size:9px>Though can read just 1,7GNOPs , so we have to use JMP that will take some execution time, too</span></div>How might we test the speed of:<br /><pre><code><br />_0&#58; nop<br />    nop<br />    nop<br />    nop<br />    nop<br />    nop<br />    jmp _0</code></pre>Eight bytes, but how many cycles?<br /><br />My processor is running at 12*166 ~ 2Ghz (it will do 12.5*166 and higher, but that fan is just so loud).  It is an overclocked XP Barton 2500 that runs 10+ degrees cooler than my 1.333Ghz Thunderbird; and over twice as fast with that 512K cache and SSE (did I mention it was cheaper, too?!). ;)</div>
    <div class="meta">Posted on 2003-08-26 00:16:59 by bitRAKE</div>
   </div>
   <div class="post" id="post-115496">
    <div class="subject"><a href="#post-115496">One more OOP crazyness</a></div>
    <div class="body"><div class="quote"><br />My processor is running at 12*166 ~ 2Ghz</div><br />Now I see... I was thinking you're talking about AthlonXP 2,0+ Palomino/Thoroughbred (really 1667Mhz) <br />Sorry for SPAM...<br /><br /><div class="quote">Eight bytes, but how many cycles?</div> <br />I'm not able to calculate it &quot;in mind&quot; now :( <br />I'll take a look at  AMD docs &amp; CodeAnalyst at home later... :rolleyes:</div>
    <div class="meta">Posted on 2003-08-26 00:44:31 by S.T.A.S.</div>
   </div>
   <div class="post" id="post-115515">
    <div class="subject"><a href="#post-115515">One more OOP crazyness</a></div>
    <div class="body"><div class="quote"><br />Hi, <strong>AmkG</strong>!<br />Very simple and powerful! Like all genious ;) <br /><br /> <br />Why not to greate all objects, and mark some of them &quot;suspended&quot;?<br /></div><br /><br />What I had in mind exactly ;)<br /><br />And since you just showed your shortcut for marking unused objects....<br /><br />Gonna integrate that in that game I'm making which prolly won't see the light of day anyway :rolleyes:<br /><br /><div class="quote"><strong><br /><br />This should be posted to &quot;The Crusades&quot;, IMHO :alright:<br /><br /></div><br /><br />Why? :eek:<br />I got in there once and........ I do wanna go in there again!</div>
    <div class="meta">Posted on 2003-08-26 04:11:16 by AmkG</div>
   </div>
   <div class="post" id="post-120252">
    <div class="subject"><a href="#post-120252">Re: One more OOP crazyness</a></div>
    <div class="body"><div class="quote"><br />Now the main idea:</strong><br />If field  contains a pointer (to some address), then address is always &lt; 8000 0000h for user mode.<br />So we surelly know, that the 31st bit must be alwais zero.<br />Let's say, we need not to save this bit in to memory ;) But anyway we will use DWORD.<br />So I use this bit for other purposes (in my case this flag shows has my object custom destructor or uses standart one)<br />It allow me to have smalest object size = DWORD (if it uses only one metod)<br />And one more, this object can be &quot;suspended&quot; (objects I'm using are automatically executed during main loop)<br />For this purpose I use the 30th bit as a flag.<br /><br />Of cource, this &quot;economy&quot; will not give us much space saving if we're using objects that are ~100DWORD size, but if we have 1000000 small objects...<br /><br />Since I've never seen this technic before, what do you think about it?</div>It's not a crazy idea. Also, packing data into redundant areas is not new. The Pentium (and IEEE) floating point format is a prime example.  In a nonzero number, the most significant bit is always 1, so the <strong>normalized</strong> format deletes the MSB, allowing an 8-bit exponent in 32-bit format with 24 significant bits + sign bit (33-bits altogether!) This packing style goes back, at the very least, to the venerable PDP-11 minicomputer.<br /><br />I have worked out a GC (Garbage Collection) scheme for objects. Each object has an embedded size field because it's simpler and faster to GC than if the size is stored in a class or &quot;type&quot; table. Because I'm allocating in DWORDs, the size has two redundant bits (they are always 0). If I use MOVSD, I can eliminate the two bits by storing the DWORD count instead of the object size. And because the objects can only be allocated in user memory (the lower 2G), there is another redundant bit. I can use one bit to indicate that an object has been collected, and another bit to indicate whether the object contains pointers only or no pointers. The all-or-none pointer property of objects is also a way to simplify GC. The GC will probably be the only code that actually uses this size-and-attributes field.</div>
    <div class="meta">Posted on 2003-10-01 17:30:59 by tenkey</div>
   </div>
   <div class="post" id="post-120254">
    <div class="subject"><a href="#post-120254">One more OOP crazyness</a></div>
    <div class="body"><div class="quote"><br />Okay, here's another, crazier idea:<br />parallel tables.</div>Also not a crazy idea. Compilers have been written in HLLs using parallel arrays for symbol tables. The HLLs were languages that didn't have records/structures. These tables were fixed in size because dynamic memory management was not a common feature of HLLs (in those old days). A counter told you how many entries were valid. If you filled up the table and needed to fit in one more entry, you had to give up - lose information or abort the program, take your pick.</div>
    <div class="meta">Posted on 2003-10-01 18:01:51 by tenkey</div>
   </div>
   <div class="post" id="post-120316">
    <div class="subject"><a href="#post-120316">Re: Re: One more OOP crazyness</a></div>
    <div class="body"><div class="quote"><em>Originally posted by tenkey </em><br />packing data into redundant areas is not new</div><br />It's new for me :rolleyes: <br /><br /><div class="quote">If I use MOVSD, I can eliminate the two bits by storing the DWORD count instead of the object size. And because the objects can only be allocated in user memory (the lower 2G), there is another redundant bit</div><br />supposing that your objects should not be 2G in size, I think there are more than 3 bits free in your DWORDs :)<br /><br />Thanks for sharing your ideas, <strong>tenkey</strong> :alright:</div>
    <div class="meta">Posted on 2003-10-02 19:07:47 by S.T.A.S.</div>
   </div>
  </div>
 </body>
</html>