<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Reverse stack scanning - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=18071" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=18071">Reverse stack scanning</a></p>
   <div class="post" id="post-139521">
    <div class="subject"><a href="#post-139521">Reverse stack scanning</a></div>
    <div class="body">Hi,<br />I would like to discuss here an optimal heuristic algo that enables finding of all instructions, which directly fill a specific item in the stack, using reverse stack scanning. I would like to speak about general issues, not about concrete assembly implementation.<br />I started writing this algo as I needed to find all labels of RETN instruction initially - I believe this is the best approach instead of watching the stack after each CALL or PUSH OFFSET or similar instructions. I generalized the algo later on.<br />I wrote the algo with general code in mind and that's why it tests, for instance, far jumps too.<br /><br /><em><strong>Note: This topic is quite sensible here, but is authorised by the moderators. It may be deleted when it turns in the wrong direction, so please sticky to the topic.</strong></em><br /><br />Well... I hope the algo works, even though I didn't code it and test it.<br />I think the algo has only one drawback - it probably will be very slow, because it tests if is stack-handling instruction inside a loop, because the loop multiplies the effect on the stack. The algo tests for the loop until it gets last instruction of the code or some important instruction (see GetStackLoop proc). I think of limitation of maximal count of scanned instructins or so...<br /><br />Notes:<br /> Do not depend on given examples. These are just for illustration.<br /> The algo is intended for scanning protected-mode code with 32bit stack segment.<br /><br />1st example: get the label(s) of the RET instruction:<br /><pre><code><br />	push	eax		stdcall argument<br />	call	proc		ESP=ESP-4<br />	...<br />proc&#58;	...			ESP without changes<br />	&#91;B&#93;retn 4&#91;/B&#93;			find_nest&#58; +4 &#40;== 0 + 4&#41;<br /></code></pre><br />2nd example: get the instruction, which fills the item at ESP+8<br /><pre><code><br />	push	eax		ESP=ESP-4<br />	push	ebx		ESP=ESP-4<br />	push	ecx		ESP=ESP-4<br />	&#91;B&#93;mov	edx,&#91;esp+8&#93;&#91;/B&#93;	find_nest&#58; +12 &#40;== 8 + 4&#41;<br /></code></pre><br /><br /><strong>Base theses:</strong><br /><ul><br />[*]In general, the scanner watches the changes of ESP (e.g. PUSH means ESP=ESP-4). This change is added to the find_nest number until the result is zero - then it gets the filling instruction. Computing the find_nest: at the start of scanning, we know how nested is seeking item (e.g. the nest is zero in case of 1st example, or +8 in case of 2nd example) relative to starting ESP. To this nest has to be added +4 and we get find_nest, because we add each relative change of ESP to this find_nest (see examples above).<br />[*]The main difficulty lies in correct recognition of stack-handling in loop, e.g.:<br /><pre><code><br />&#91;B&#93;@@&#58;	push	eax&#91;/B&#93;<br />	inc	eax<br />	cmp	eax,ebx<br />	&#91;B&#93;jne	@B&#91;/B&#93;		; conditional loop<br />	retn			; start scanning - origin address &#91;I&#93;OA&#91;/I&#93;<br /></code></pre><br />The <strong>GetStackLoop</strong> function tests it.<br /> <br /><br /><strong>Assumptions and simplifications:</strong><br /><ul><br />[*]The code is fully disassembled into list of entries (i.e. we know the lenght of any instruction, so reverse scanning is possible)<br />[*]Data between code and other junks were correctly recognized.<br />[*]No other instruction indirectly rewrites the stack (e.g. MOV EAX,ESP - MOV ,xyz)<br />[*]The manipulations with stack are always DWORD-aligned<br />[*]To prevent multiple scanning of the same code, scanned addresses are remembered along with appropriate find_nest values and these informations are tested while scanning. This saving/testing is not included in the algo below.<br /> <br /><br />Algo:<br /><pre><code><br />&#91;B&#93;Procedure StackScan&#91;/B&#93;&#40;Arg1&#58; Origin Address OA, Arg2&#58; nest&#41;<br />// returns record of addresses of instructions, which fills the item<br />01  Compute and remember find_nest&#58; find_nest = nest + 4;<br />02  &#91;I&#93;&#91;B&#93;Scan reverse through the code, watch for&#58;&#91;/B&#93;&#91;/I&#93;<br />03   &#91;B&#93;Unconditional jump&#91;/B&#93;&#58;<br />04    Stop going this way;<br />      // there has to be label at the next instruction - jumps using this label are remembered already &#40;see next line&#41;<br /><br />05   &#91;B&#93;Label&#91;/B&#93;&#58;<br />06    Remember all jump instructions using this label, with actual find_nest;<br />      // label means independent branch that has to be scanned later extra<br /><br />07   &#91;B&#93;Instruction modifies ESP&#91;/B&#93;&#58;<br />      &#91;QUOTE&#93;<br />08 		mov	esp,405008<br />09	 	push	ebx			; ESP=405004<br />10 		push	ecx			; ESP=405000<br />11	 	&#91;B&#93;mov	esp,405004&#91;/B&#93;<br />12 		pop	eax			; &#91;i&#93;OA&#91;/i&#93;	EAX=EBX &#40;here is nest = 0, find_nest = +4&#41;<br />      &#91;/QUOTE&#93;<br />13    If is ESP filled with absolute value &#40;e.g. MOV&#41; then<br />14     If is value of ESP at the address of the previous instruction &#40;line 10&#41; known then<br />15      If is new value of ESP known &#40;line 11&#41; then<br />16       Compute new find_nest&#58; find_nest = find_nest + subtraction;	// in example 4+4=+8<br />17       Goto check_nest &#40;line 56&#41;;<br />18      Else return from proc with error &quot;unknown value of top of stack&quot;;<br />19     Else return from proc with error &quot;unknown stack contains&quot;;	// can't compute the subtraction<br />20    EndIf;<br /><br />      // ESP is filled relative way&#58; need for recognition if is this instruction inside a loop<br />      // this recognition is not needed, if is founded stack-pair instructions, e.g. PUSH-POP and if one of them<br />      // is not in loop relative to the companion - see example&#58;<br />      &#91;QUOTE&#93;<br />21   	@@&#58;	&#91;B&#93;push	&#91;ebx&#93;&#91;/B&#93;			; ESP=ESP-4 &#91;B&#93;companion&#91;/B&#93;<br />22   		xor	&#91;esp&#93;,eax			; code data<br />23   		jnz	@lbl<br />24   			push	eax		; ESP=ESP-4<br />25   			mov	eax,&#91;ecx&#93;		; if key==0 and data==0, fill with &#91;ecx&#93;<br />26   			xor	&#91;esp+4&#93;,eax<br />27   			pop	eax		; ESP=ESP+4<br />28   	@lbl&#58;	&#91;B&#93;pop	&#91;ebx&#93;&#91;/B&#93;			; ESP=ESP+4 &#91;B&#93;first&#91;/B&#93;<br />29  		add	ebx,4<br />30   		loop	@B			; loop may be overpassed - contains only stack-pair instructions<br />31   		retn				; &#91;i&#93;OA&#91;/i&#93; find_nest=+4<br />      &#91;/QUOTE&#93;<br />32    Remember this ESP change &#40;line 28, +4&#41;;<br />33    Save actual find_nest &#40;line 28, +4&#41;;<br />34    &#91;I&#93;&#91;B&#93;Scan reverse through the code, watch for&#58;&#91;/B&#93;&#91;/I&#93;<br />35     &#91;B&#93;Instruction modifies ESP&#91;/B&#93;&#58;<br />36      Add this ESP change to find_nest;<br />37      If result == 0 then break this local scanning;	// perhaps stack-pair instructions &#40;see example&#41;, check it<br />38     &#91;B&#93;Near jump&#91;/B&#93;&#58;<br />39      If is its label over the original instruction &#40;over line 28&#41; then goto call_get_loop &#40;line 52&#41;;<br />        // this jump breaks the loop &#40;if any&#41;, so break this local scanning and check, if there is a loop<br />40     &#91;B&#93;Far jump&#91;/B&#93;&#58;<br />41      Goto call_get_loop &#40;line 52&#41;;<br />        // this jump breaks the loop &#40;if any&#41;, so break this local scanning and check, if there is a loop<br />42     &#91;B&#93;Label&#91;/B&#93;&#58;<br />43      Remember all jump instructions using this label;	// why see line 47<br />       &#91;B&#93;First instruction of the code&#91;/B&#93;&#58;<br />44      Break scanning this way;	// the founded item is not stored within the code<br />45    &#91;I&#93;&#91;B&#93;Else run scanning on;&#91;/B&#93;&#91;/I&#93;<br /><br />      // find_nest is here 0 - actual address is line 21<br />46    Return saved find_nest;<br />47    If non of remembered jump instructions has labels outside original address &#40;line 28&#41;<br />      and actual address &#40;line 21&#41; then<br />      // means non of them breaks the potential loop<br />48     If ESP change between each of jump instruction and actual address &#40;line 21&#41;<br />       is equal to ESP change between its label and original address &#40;line 28&#41; then<br />       // these two conditions mean that such jump doesn't change the sense of stack handling;<br />       // in example ESP change between lines 23 and 21 is equal to ESP change between lines 28 and 28<br />49      Resume the main scanning loop from instruction previous to actual address;<br />        // Overpass instructions between original and actual addresses, because ESP is returned<br />50     EndIf;<br />51    EndIf;<br />52    &#91;I&#93;Label call_get_loop&#58;&#91;/I&#93;<br />53    Call GetStackLoop&#40;OA, actual address&#41;;	// actual address means instruction at line 28<br />54    If unknown loop count, return from proc with error &quot;can't get the right instruction&quot;; <br />55    Multiply remembered ESP change in actual instruction by loop count;<br />56    &#91;I&#93;Label check_nest&#58;&#91;/I&#93;<br />57    Add the result to find_nest;<br />58    If find_nest &lt;= 0 then<br />59     Remember actual address;	&#91;B&#93;// it got the instruction&#91;/B&#93;<br />60     Break scanning this way;	// i.e. run scanning on from remembered jump from line 5, if any<br />61    EndIf;<br /><br />62   &#91;B&#93;First instruction of the code&#91;/B&#93;&#58;	// check this at the end of main scanning loop<br />63     Break scanning this way;	// the founded item is not stored within the code<br /><br />64  &#91;I&#93;&#91;B&#93;Else run main scanning on;&#91;/B&#93;&#91;/I&#93;<br /><br />&#91;B&#93;StackScan ENDP&#91;/B&#93;;<br /><br />&#91;B&#93;Procedure GetStackLoop&#91;/B&#93;&#40;Arg1&#58; Origin Address OA, Arg2&#58; Actual Address AA&#41;<br />// returns loop_count, one if not in loop, or error when the loop count was not deducted<br />// Checks if instruction at AA is in loop relative to the OA<br /><br />65  &#91;I&#93;&#91;B&#93;Scan through the code from AA, watch for&#58;&#91;/B&#93;&#91;/I&#93;<br />66   &#91;B&#93;OA&#91;/B&#93;&#58;<br />      &#91;QUOTE&#93;<br />67  		push	eax		; AA<br />68  		retn			; OA<br />      &#91;/QUOTE&#93;<br />69    Return from proc with loop_count = 1;	// there is no loop<br /><br />70   &#91;B&#93;AA&#91;/B&#93;&#58;<br />      &#91;QUOTE&#93;<br />71 	&#91;B&#93;@@&#58;	push	eax&#91;/B&#93;		; AA<br />72 		inc	eax<br />73 		cmp	eax,ebx<br />74 		&#91;B&#93;jne	@B&#91;/B&#93;		; see line 90<br />75 		retn			; OA<br />      &#91;/QUOTE&#93;<br />76    If is loop condition unknown then return from proc with the error<br />77    Else return from proc with loop_count = number of loop iterations;<br /><br />78   &#91;B&#93;Last remembered linking label&#91;/B&#93;&#58;	// remembered from line 96<br />      &#91;QUOTE&#93;<br />79  		push	eax		; AA<br />80  	@lbl&#58;	cmp	eax,ebx<br />81  		&#91;B&#93;jne	@F&#91;/B&#93;		; this jump doesn't loop around AA<br />82 		retn			; OA<br />83  	@@&#58;	add	eax,ecx<br />84  		jmp	@lbl<br />      &#91;/QUOTE&#93;<br />85    Run scanning on at the next instruction;	// no loop, run next code on<br /><br />86   &#91;B&#93;Far jump&#91;/B&#93;&#58;<br />87    Return from proc with loop_count = 1;	// there is no loop<br /><br />88   &#91;B&#93;Unconditional jump&#91;/B&#93;&#58;<br />89    Run scanning on at its label;<br /><br />90   &#91;B&#93;Conditional jump&#91;/B&#93;&#58;<br />      &#91;QUOTE&#93;<br />91  		push	eax		; AA<br />92  		inc	eax<br />93  		cmp	eax,ebx<br />94  		&#91;B&#93;jne	@B/F&#91;/B&#93;<br />95  		retn			; OA<br />      &#91;/QUOTE&#93;		<br />96    Remember address of this jump instruction;	// scanning will run later on at the next instruction<br />97    Run scanning on at label of this jump;<br />      // this remembered address is tested at line 78<br />      // this system enables dispatching of nested loops &#40;lines 99 to 101&#41;&#58;<br />      &#91;QUOTE&#93;<br />98  	@BB&#58;	add	eax,ebx<br />99  	nest&#58;	or	eax,esi<br />100  		add	eax,edx<br />101 		&#91;B&#93;ja	nest&#91;/B&#93;<br />102 	@@&#58;	cmp	eax,ecx<br />103 		&#91;B&#93;jne	@BB&#91;/B&#93;<br />104 		push	eax			; AA<br />105 		inc	eax<br />106 		cmp	eax,ebx<br />107 		&#91;B&#93;jne	@B&#91;/B&#93;<br />108 		retn				; OA<br />      &#91;/QUOTE&#93;<br />109  &#91;B&#93;Last instruction of the code&#91;/B&#93;&#58;<br />110   Return from proc with loop_count = 1;	// there is no loop  <br /><br />111 &#91;I&#93;&#91;B&#93;Else run main scanning on;&#91;/B&#93;&#91;/I&#93;<br /><br />&#91;B&#93;GetStackLoop ENDP&#91;/B&#93;;<br /></code></pre><br /><br /><em>edited line 33: +8 corrected to +4</em></div>
    <div class="meta">Posted on 2004-04-19 23:13:17 by MazeGen</div>
   </div>
  </div>
 </body>
</html>