<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Super Basic 80x86 Assembly Homework Help - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=28775" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=28775">Super Basic 80x86 Assembly Homework Help</a></p>
   <div class="post" id="post-203269">
    <div class="subject"><a href="#post-203269">Super Basic 80x86 Assembly Homework Help</a></div>
    <div class="body"><br />So I&#039;m supposed to do this homework assignment where I take a 4 digit number from the user and determine whether or not it is prime.<br />Secondly, I need to find the prime numbers on either side of the prime number.<br /><br />I&#039;ve written this code and since I&#039;m not really sure how to use WinDbg to figure out what line is causing the trouble, I figured I&#039;d ask here.<br />Apparently I&#039;ve written an &quot;Integer Overflow Error&quot; somewhere in here.<br />Anyway I&#039;m aware this is basically the equivalent of assembly garbage code, but I&#039;m just trying to get through this assignment.<br /><br />Thanks for your help, as it&#039;s due Tuesday afternoon (short time schedule I know but I&#039;ve been beating my head in on this one).<br /><br />Oh one more thing...I think one of the div instructions could be the cause, but I&#039;m not sure how.<br /><br />.386<br />.MODEL FLAT<br /><br />ExitProcess PROTO NEAR32 stdcall, dwExitCode:DWORD<br />INCLUDE io.h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;header file for input/output<br /><br />cr&nbsp; &nbsp; EQU&nbsp;  0dh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;carriage return character<br />Lf&nbsp;  EQU&nbsp;  0ah&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;line feed<br /><br />.STACK 4096&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;reserve 4096-byte stack<br /><br />.DATA&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;reserve storage for data<br /><br />prompt1&nbsp;  BYTE&nbsp;  &quot;Please enter a four digit integer:&nbsp; &quot;, 0<br />prompt2&nbsp;  BYTE&nbsp;  cr, Lf, &quot; is not a prime number.&quot;, 0<br />prompt3 BYTE&nbsp;  cr, Lf, &quot; is a prime number.&quot;, 0<br />prompt4 BYTE&nbsp;  cr, Lf, &quot;Largest prime number smaller than &quot;, 0<br />prompt5 BYTE&nbsp;  cr, Lf, &quot;Smallest prime number larger than &quot;, 0<br />string&nbsp;  BYTE&nbsp;  11 DUP (?)<br />orig&nbsp;  WORD&nbsp;  ?<br />lower&nbsp;  WORD&nbsp;  ?<br />higher&nbsp; WORD&nbsp;  ?<br /><br /><br />.CODE<br />_start:<br /><br />mov bx, 2<br />output prompt1<br />input string, 6<br />atoi string&nbsp; &nbsp; &nbsp; ; put input in ax<br />mov orig, ax&nbsp;  ; copy ax to orig<br /><br />origtest:<br /><br />cmp bx, ax&nbsp; &nbsp; &nbsp; ; subtract input from bx<br />je origprime&nbsp;  ; if input and bx are = then jump<br />cwd&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; convert to word<br />div bx&nbsp; &nbsp; &nbsp; &nbsp;  ; divide ax by bx<br />cmp dx, 0&nbsp; &nbsp; &nbsp; ; sub ax minus 0<br />je orignotprime&nbsp;  ; if 0 and dx are = then jump<br />inc bx&nbsp; &nbsp; &nbsp; &nbsp;  ; increment bx register<br />jmp origtest&nbsp;  ; restart loop<br /><br />lowerloop:<br /><br />sub ax, 1<br />jmp lowerprimetest<br /><br />lowerprimetest:<br /><br />cmp bx, ax<br />je lowerprime<br />cwd<br />div bx<br />cmp dx, 0<br />je lowerloop<br />inc bx<br />jmp lowerprimetest<br /><br />lowerprime:<br /><br />mov lower, ax<br />jmp highestloop<br /><br />highestloop:<br /><br />add ax, 1<br />jmp higherprimetest<br /><br />higherprimetest:<br /><br />cmp bx, ax<br />je higherprime<br />cwd<br />div bx<br />cmp dx, 0<br />je highestloop<br />inc bx<br />jmp higherprimetest<br /><br />higherprime:<br /><br />mov higher, ax<br />jmp finalout<br /><br />origprime:<br /><br />mov bx, 2<br />mov ax, orig<br />itoa string, ax ; Convert ax to Ascii<br />output string&nbsp;  ; Output: ax<br />output prompt2&nbsp;  ; is a prime number<br />jmp lowerloop<br /><br />orignotprime:<br /><br />mov bx, 2<br />mov ax, orig<br />itoa string, ax<br />output string<br />output prompt3&nbsp;  ; is not a prime number<br />jmp lowerloop<br /><br />finalout:<br /><br />output prompt4&nbsp;  ; Largest number smaller than<br />mov ax, lower<br />itoa string, ax<br />output string<br />output prompt5&nbsp;  ; Smallest number greather than<br />mov ax, higher<br />itoa string, ax<br />output string<br /><br /><br />INVOKE ExitProcess, 0<br /><br />PUBLIC _start<br /><br />END</div>
    <div class="meta">Posted on 2007-10-22 21:14:57 by Kuroi Kaze</div>
   </div>
   <div class="post" id="post-203271">
    <div class="subject"><a href="#post-203271">Re: Super Basic 80x86 Assembly Homework Help</a></div>
    <div class="body">You must set edx to zero before you perform a divide.<br /><br />The div opcode works like this:<br />ax = (dx : ax) / (reg/mem)&nbsp;  &lt;-- div<br />dx = (dx : ax) % (reg/mem)&nbsp; &lt;-- mod !!!<br /> <br />That means even when working with 16 bit registers, the numerator is 32 bits, dx:ax !!!<br />Just perform a xor dx,dx or equivalent to prevent getting weird div results.</div>
    <div class="meta">Posted on 2007-10-23 00:16:22 by Homer</div>
   </div>
   <div class="post" id="post-203272">
    <div class="subject"><a href="#post-203272">Re: Super Basic 80x86 Assembly Homework Help</a></div>
    <div class="body">Just download OllyDbg and step through the code.<br /><br />http://www.ollydbg.de/<br /><br />(Or, push F9 and it&#039;ll stop at the problem.)<br /><br />*Basically, DIV opperate on DX:AX, but you ignore DX prior to DIV. You should set it to zero.</div>
    <div class="meta">Posted on 2007-10-23 00:17:00 by bitRAKE</div>
   </div>
   <div class="post" id="post-203285">
    <div class="subject"><a href="#post-203285">Re: Super Basic 80x86 Assembly Homework Help</a></div>
    <div class="body">Yeah I grabbed OllyDbg...it&#039;s a bit complicated for a beginner like me, but I generally see that div operations are causing the exceptions.<br /><br />Also my logic is flawed in places where I&#039;m relying on EAX because div changes the values there and it&#039;s no longer original input.&nbsp; I need to use ECX in some places to fix that.<br /><br />I&#039;ll be working hard on this all day and if I have more questions I&#039;ll be back.</div>
    <div class="meta">Posted on 2007-10-23 09:28:45 by Kuroi Kaze</div>
   </div>
   <div class="post" id="post-203287">
    <div class="subject"><a href="#post-203287">Re: Super Basic 80x86 Assembly Homework Help</a></div>
    <div class="body">Okay here&#039;s the re-written overflow-free error code.<br /><br />Unfortunately it doesn&#039;t work right.<br /><br />1059 is my &quot;control&quot; test and the answers that should come out are not what come out of my program.<br /><br />When I put in 1059 I should get 1051 and 1061 are the two primes.<br />Instead I get 1053 and 1060?!?&nbsp; <br /><br />.386<br />.MODEL FLAT<br /><br />ExitProcess PROTO NEAR32 stdcall, dwExitCode:DWORD<br />INCLUDE io.h					;header file for input/output<br /><br />cr 	EQU	0dh						;carriage return character<br />Lf	EQU	0ah						;line feed<br /><br />.STACK 4096						;reserve 4096-byte stack<br /><br />.DATA							;reserve storage for data<br /><br />prompt1	BYTE	&quot;Please enter a four digit integer:&nbsp; &quot;, 0<br />prompt2	BYTE	cr, Lf, &quot; is not a prime number.&quot;, 0<br />prompt3 BYTE	cr, Lf, &quot; is a prime number.&quot;, 0<br />prompt4 BYTE	cr, Lf, &quot;Largest prime number smaller than &quot;, 0<br />prompt5 BYTE	cr, Lf, &quot;Smallest prime number larger than &quot;, 0<br />string	BYTE	11 DUP (?)<br />orig	DWORD	?<br />lower&nbsp;  DWORD	?<br />higher&nbsp; DWORD	?<br /><br /><br />.CODE <br />_start:<br /><br />mov ebx, 2<br />output prompt1<br />input string, 6<br />atod string		; put input in eax<br />mov orig, eax	; copy eax to orig<br />mov ecx, eax<br /><br />origtest:<br /><br />cmp ebx, eax	; subtract input from ebx<br />je origprime	; if input and ebx are = then jump<br />XOR edx,edx		; zero out edx<br />div ebx			; divide eax by ebx<br />cmp edx, 0		; sub eax minus 0<br />je orignotprime	; if 0 and edx are = then jump<br />inc ebx			; increment ebx register<br />mov eax, ecx	; put the original test back in eax<br />jmp origtest	; restart loop<br /><br />lowerloop:<br /><br />sub ecx, 1<br />jmp lowerprimetest<br /><br />lowerprimetest:<br /><br />mov eax, ecx<br />cmp ebx, eax<br />je lowerprime<br />XOR edx,edx<br />div ebx<br />cmp edx, 0<br />je lowerloop<br />inc ebx<br />jmp lowerprimetest<br /><br />lowerprime:<br /><br />mov lower, ecx<br />mov ecx, orig<br />jmp highestloop<br /><br />highestloop:<br /><br />add ecx, 1<br />jmp higherprimetest<br /><br />higherprimetest:<br /><br />mov eax, ecx<br />cmp ebx, eax<br />je higherprime<br />XOR edx,edx<br />div ebx<br />cmp edx, 0<br />je highestloop<br />inc ebx<br />jmp higherprimetest<br /><br />higherprime:<br /><br />mov higher, ecx<br />jmp finalout<br /><br />origprime:<br /><br />mov ebx, 2<br />dtoa string, ecx ; Convert ecx to Ascii<br />output string	; Output: ecx<br />output prompt2	; is a prime number<br />jmp lowerloop<br /><br />orignotprime:<br /><br />mov ebx, 2<br />dtoa string, ecx<br />output string<br />output prompt3	; is not a prime number<br />jmp lowerloop<br /><br />finalout:<br /><br />output prompt4	; Largest number smaller than<br />mov eax, lower<br />dtoa string, eax<br />output string<br />output prompt5	; Smallest number greather than<br />mov eax, higher<br />dtoa string, eax<br />output string<br /><br /><br />INVOKE ExitProcess, 0<br /><br />PUBLIC _start<br /><br />END<br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2007-10-23 12:25:47 by Kuroi Kaze</div>
   </div>
  </div>
 </body>
</html>