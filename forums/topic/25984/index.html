<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Determine when a program has been terminated - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25984" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25984">Determine when a program has been terminated</a></p>
   <div class="post" id="post-189366">
    <div class="subject"><a href="#post-189366">Determine when a program has been terminated</a></div>
    <div class="body">I would like some help adding some code to determine when bartshell.exe has been terminated and then run this.<br /><br />Thanks.<br /> <br />; PPC_gone.asm&nbsp;  This version doesn&#39;t displays messages.&nbsp; &nbsp;  <br />;<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Run this AFTER bartshell.exe has been terminated !!!&nbsp; <br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />; Help from Tedd,sinsi,Nordwind64,AsmGuru62,Jongware, <br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />;<br />; Terminates PeoplePC.exe!! <br />; This program leaves ports open even after modem has been disconnected !!<br />;<br />; (A badly behaved program that likes to HANG around :-))<br />;<br />; Run this AFTER bartshell.exe has been terminated !!!&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />;<br />.586<br />.model flat,stdcall<br />option casemap:none<br /><br />include&nbsp; \masm32\include\windows.inc<br />include&nbsp; \masm32\include\user32.inc<br />include&nbsp; \masm32\include\kernel32.inc<br />include&nbsp; \masm32\include\shlwapi.inc<br />include&nbsp; \masm32\macros\macros.asm<br />include&nbsp; \masm32\include\advapi32.inc<br /><br />includelib&nbsp; \masm32\lib\advapi32.lib<br />includelib&nbsp; \masm32\lib\user32.lib<br />includelib&nbsp; \masm32\lib\kernel32.lib<br />includelib&nbsp; \masm32\lib\shlwapi.lib<br /><br />; Local Prototypes<br /><br />&nbsp; &nbsp; IsWinNT&nbsp; &nbsp; &nbsp; &nbsp;  PROTO<br />&nbsp; &nbsp; ReqNTPrivilege&nbsp; PROTO :DWORD<br />&nbsp; &nbsp; <br />.const<br /><br />&nbsp; &nbsp; dwMaskNT&nbsp; &nbsp; &nbsp; &nbsp; DWORD&nbsp;  2<br /><br />WinMain proto :DWORD,:DWORD,:DWORD,:DWORD<br /><br />.data<br /><br />&nbsp; &nbsp; msg_NotNT&nbsp;  BYTE&nbsp; &nbsp; &quot;This is NOT an NT system.&quot;,0<br />&nbsp; &nbsp; msg_NotPL&nbsp;  BYTE&nbsp; &nbsp; &quot;Privilege requested NOT granted.&quot;,0<br />&nbsp; &nbsp; BoxName&nbsp; &nbsp;  BYTE&nbsp; &nbsp; &quot;ASM Win NT Shutdown&quot;,0<br />&nbsp; &nbsp; Watermark&nbsp;  BYTE&nbsp; &nbsp; &quot;Andrew Kennedy 5/10/07&quot;,0 <br /><br />&nbsp;  ClassName&nbsp; &nbsp; BYTE&nbsp; &nbsp; &quot;MainWinClass&quot;,0<br />&nbsp;  AppName&nbsp; &nbsp; &nbsp; BYTE&nbsp; &nbsp; &quot;CLOSE THIS WINDOW!&quot;,0<br />&nbsp;  ProcessName&nbsp; BYTE&nbsp; &nbsp; &quot;PeoplePC.exe&quot;,0<br />&nbsp;  started&nbsp; &nbsp; &nbsp; BYTE&nbsp; &nbsp; &quot;KillIt&quot;,0<br />&nbsp;  successtext&nbsp; BYTE&nbsp; &nbsp; &quot;PeoplePC.exe has been terminated!&quot;,0<br />&nbsp;  failedtext&nbsp;  BYTE&nbsp; &nbsp; &quot;Program is not currently running!&quot;,0<br /><br />.data?<br /><br />&nbsp;  hInstance&nbsp;  HINSTANCE ?<br />&nbsp;  CommandLine LPSTR&nbsp; &nbsp;  ?<br /><br />.code<br /><br />start:<br /><br />&nbsp; &nbsp; invoke LoadIcon,hInstance,200&nbsp; &nbsp; ; icon ID<br /><br /><br />&nbsp; &nbsp; invoke GetModuleHandle, NULL<br />&nbsp; &nbsp; mov&nbsp; &nbsp; hInstance,eax<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; invoke GetCommandLine<br />&nbsp; &nbsp; mov&nbsp; &nbsp; CommandLine,eax<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT<br /><br />&nbsp; &nbsp; ; with ReqNTPrivilege call, we ask for the &#39;SeShutdownPrivilege&#39;<br />&nbsp; &nbsp; ; note string names of possible privilege are in windows.inc<br /><br />&nbsp; &nbsp; invoke&nbsp; ReqNTPrivilege, SADD(&quot;SeShutdownPrivilege&quot;)<br />&nbsp; &nbsp; .if eax == FALSE<br />&nbsp; &nbsp; &nbsp; invoke&nbsp; MessageBox,NULL,addr msg_NotPL,addr BoxName,MB_OK<br />&nbsp; &nbsp; &nbsp; invoke&nbsp; ExitProcess,NULL<br />&nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; invoke ExitProcess,eax<br />&nbsp; &nbsp; <br />KillProcess proc lpszExecutable:LPSTR<br />&nbsp; &nbsp; LOCAL bLoop:BOOL<br />&nbsp; &nbsp; LOCAL bResult:BOOL<br />&nbsp; &nbsp; LOCAL pe32:PROCESSENTRY32<br />&nbsp; &nbsp; LOCAL hProcess:HANDLE<br />&nbsp; &nbsp; LOCAL hProcesses:HANDLE<br /><br />&nbsp; &nbsp; mov bLoop,TRUE<br />&nbsp; &nbsp; mov bResult,FALSE<br /><br />&nbsp; &nbsp; ; Returns an open handle to the specified snapshot if successful or - 1 otherwise.<br />&nbsp; &nbsp; invoke CreateToolhelp32Snapshot,TH32CS_SNAPPROCESS,0<br />&nbsp; &nbsp; mov hProcesses,eax&nbsp; &nbsp; ;&nbsp; Did not need 2 copies of your snap shot<br /><br />&nbsp; &nbsp; mov pe32.dwSize,SIZEOF PROCESSENTRY32<br /><br />&nbsp; &nbsp; invoke Process32First,hProcesses,ADDR pe32<br />&nbsp; &nbsp; .IF eax<br />&nbsp; &nbsp; &nbsp; &nbsp; .WHILE bLoop<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke CompareString, LOCALE_USER_DEFAULT, NORM_IGNORECASE, addr pe32.szExeFile, -1, lpszExecutable, -1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .IF eax==2 ; check if strings are equal in lexical value <br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; With having addr pe32.th32ProcessID you were getting an invalid PID<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke OpenProcess, PROCESS_TERMINATE, FALSE, pe32.th32ProcessID ; returns handle&nbsp; <br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  .IF eax!=NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov hProcess, eax&nbsp; &nbsp; &nbsp; &nbsp; ; Need to save the process handle to terminate<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke TerminateProcess, hProcess, 0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke CloseHandle, hProcess ; fails if eax is zero<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov bResult,TRUE;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; why go on to next process ?<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  invoke Process32Next, hProcesses, ADDR pe32 <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Retrieves information about the next process recorded in a system snapshot. <br /> <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov bLoop,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; .endw<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke CloseHandle,hProcesses<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; mov eax,bResult<br />&nbsp; &nbsp; ret<br /><br />KillProcess endp<br /><br />WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD<br />&nbsp; &nbsp; LOCAL wc:WNDCLASSEX<br />&nbsp; &nbsp; LOCAL msg:MSG<br />&nbsp; &nbsp; LOCAL hwnd:HWND<br />&nbsp; &nbsp; LOCAL tc&nbsp;  :DWORD ; added 4:08:27 AM Wednesday, May 23, 2007<br /><br />&nbsp; &nbsp; mov&nbsp;  wc.cbSize,SIZEOF WNDCLASSEX<br />&nbsp; &nbsp; mov&nbsp;  wc.style, CS_HREDRAW or CS_VREDRAW<br />&nbsp; &nbsp; mov&nbsp;  wc.lpfnWndProc, OFFSET WndProc<br />&nbsp; &nbsp; mov&nbsp;  wc.cbClsExtra,NULL<br />&nbsp; &nbsp; mov&nbsp;  wc.cbWndExtra,NULL<br />&nbsp; &nbsp; push&nbsp; hInstance<br />&nbsp; &nbsp; pop&nbsp;  wc.hInstance<br />&nbsp; &nbsp; mov&nbsp;  wc.hbrBackground,COLOR_BTNFACE+1<br />&nbsp; &nbsp; mov&nbsp;  wc.lpszMenuName,NULL<br />&nbsp; &nbsp; mov&nbsp;  wc.lpszClassName,OFFSET ClassName<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; invoke LoadIcon,NULL,IDI_APPLICATION<br />&nbsp; &nbsp; mov&nbsp;  wc.hIcon,eax<br />&nbsp; &nbsp; mov&nbsp;  wc.hIconSm,eax<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; invoke LoadCursor,NULL,IDC_ARROW<br />&nbsp; &nbsp; mov&nbsp;  wc.hCursor,eax<br />&nbsp; &nbsp; <br />&nbsp;  <br />&nbsp; &nbsp; invoke RegisterClassEx, addr wc<br /><br />&nbsp; &nbsp; ; If I want a window off screen, do I change the CW_USEDEFAULT statements to some x and<br />&nbsp; &nbsp; ; y co-ordinates off screen, and if so what would be some good values ?<br />&nbsp; &nbsp; ; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; getting rid of CW_USEDEFAULT with NULL creates a &quot;hidden&quot; window<br /><br />&nbsp; &nbsp; INVOKE CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\ <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  WS_OVERLAPPEDWINDOW,NULL,\ ; creates a &quot;hidden&quot; window<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  hInst,NULL<br />&nbsp; &nbsp; mov&nbsp;  hwnd,eax<br /> <br />&nbsp; &nbsp; invoke ShowWindow, hwnd,SW_MINIMIZE&nbsp; &nbsp; ;Minimal window<br />&nbsp; &nbsp; invoke UpdateWindow, hwnd<br /><br />&nbsp; &nbsp;  add tc,1&nbsp; &nbsp; ; get rid of window quickly&nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;2000 =&nbsp; 2 seconds <br /><br />&nbsp; &nbsp; ; ------------------------------------------------<br />&nbsp; &nbsp; ; loop until Tick count catches up with added time<br />&nbsp; &nbsp; ; ------------------------------------------------<br />&nbsp; &nbsp; @@:<br />&nbsp; &nbsp; &nbsp; invoke GetTickCount<br />&nbsp; &nbsp; &nbsp; &nbsp; .if tc &gt; eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jmp @B<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; ; -------------------<br />&nbsp; &nbsp; ; Close screen<br />&nbsp; &nbsp; ; -------------------<br />&nbsp; &nbsp; &nbsp; invoke SendMessage,hwnd,WM_SYSCOMMAND,SC_CLOSE,NULL<br /><br />&nbsp; &nbsp; ;-----------------------------------<br />&nbsp; &nbsp; ; Loop until PostQuitMessage is sent<br />&nbsp; &nbsp; ;-----------------------------------<br />&nbsp; &nbsp; StartLoop:<br />&nbsp; &nbsp; &nbsp; invoke GetMessage,ADDR msg,NULL,0,0<br />&nbsp; &nbsp; &nbsp; cmp eax, 0<br />&nbsp; &nbsp; &nbsp; je ExitLoop<br />&nbsp; &nbsp; &nbsp; invoke TranslateMessage, ADDR msg<br />&nbsp; &nbsp; &nbsp; invoke DispatchMessage,&nbsp; ADDR msg<br />&nbsp; &nbsp; &nbsp; jmp StartLoop<br />&nbsp; &nbsp; ExitLoop:<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; mov&nbsp; &nbsp;  eax,msg.wParam<br />&nbsp; &nbsp; ret<br /><br />WinMain endp<br /><br />WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; LOCAL bResult:BOOL<br />&nbsp; &nbsp; LOCAL bLoop:BOOL<br /><br />&nbsp; &nbsp; .IF uMsg==WM_DESTROY<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PostQuitMessage,NULL<br /><br />&nbsp; &nbsp; .ELSEIF uMsg==WM_CREATE<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax, -1&nbsp; &nbsp; &nbsp; &nbsp; ;FALSE<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; mov bResult,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; ;invoke MessageBox,0,OFFSET startedtext,OFFSET started,MB_OK<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke KillProcess,OFFSET ProcessName<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ;mov bResult,eax ; <br />&nbsp; &nbsp; &nbsp; &nbsp; <br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ;.IF bResult==FALSE<br />&nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp; invoke MessageBox,0,OFFSET failedtext,OFFSET started,MB_OK<br />&nbsp; &nbsp; &nbsp; &nbsp; ;.ELSE<br />&nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp; invoke MessageBox,0,OFFSET successtext,OFFSET started,MB_OK<br />&nbsp; &nbsp; &nbsp; &nbsp; ;.ENDIF<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ; mov bLoop,FALSE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; .ELSE<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke DefWindowProc,hWnd,uMsg,wParam,lParam&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; .ENDIF<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; xor eax,eax<br />&nbsp; &nbsp; ret<br />WndProc endp<br /><br />ReqNTPrivilege proc lpPrivilegeName:DWORD<br /><br />; return TRUE (not zero) in eax if privilege is granted<br />; lpPrivilegeName parameter points to a string with request privilege name<br /><br />&nbsp; &nbsp; LOCAL&nbsp;  hProcess:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp;  hToken:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp;  phToken:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp;  RetLen:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp;  pRetLen:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp;  tkp:TOKEN_PRIVILEGES<br />&nbsp; &nbsp; LOCAL&nbsp;  tkp_old:TOKEN_PRIVILEGES<br />;<br />&nbsp; &nbsp; invoke&nbsp; GetCurrentProcess<br />&nbsp; &nbsp; mov&nbsp; &nbsp;  hProcess, eax<br />&nbsp; &nbsp; lea&nbsp; &nbsp;  eax, hToken<br />&nbsp; &nbsp; mov&nbsp; &nbsp;  phToken, eax<br />&nbsp; &nbsp; invoke&nbsp; OpenProcessToken, hProcess, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TOKEN_ADJUST_PRIVILEGES Or TOKEN_QUERY, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phToken&nbsp; <br />&nbsp; &nbsp; .if eax != FALSE<br />&nbsp; &nbsp; &nbsp; lea&nbsp; &nbsp;  eax, tkp.Privileges[0].Luid<br />&nbsp; &nbsp; &nbsp; invoke&nbsp; LookupPrivilegeValue, NULL, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpPrivilegeName, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eax<br />&nbsp; &nbsp; &nbsp; lea&nbsp; &nbsp;  eax, RetLen<br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  pRetLen, eax<br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  tkp.PrivilegeCount, 1<br />&nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  tkp.Privileges[0].Attributes, SE_PRIVILEGE_ENABLED<br />&nbsp; &nbsp; &nbsp; invoke&nbsp; AdjustTokenPrivileges, hToken, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NULL, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr tkp, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sizeof tkp_old, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr tkp_old, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pRetLen<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; ret<br />&nbsp; &nbsp; <br />ReqNTPrivilege endp<br /><br />end start<br /><br /></div>
    <div class="meta">Posted on 2007-05-25 21:45:55 by skywalker</div>
   </div>
   <div class="post" id="post-189368">
    <div class="subject"><a href="#post-189368">Re: Determine when a program has been terminated</a></div>
    <div class="body"><br />I am not at all happy about your previous post.<br />Not because I believe that this is a serious attempt to disguise malicious intent, but because the answer you seek is right before your very eyes, and yet you are too blind to see it.<br />You posted this sourcecode, but you obviously did not write it, and you obviously did not even read it, and so your request for assistance is, at the very least, premature.</div>
    <div class="meta">Posted on 2007-05-26 00:32:32 by Homer</div>
   </div>
   <div class="post" id="post-189380">
    <div class="subject"><a href="#post-189380">Re: Determine when a program has been terminated</a></div>
    <div class="body"><div class="quote"><br /><br />I am not at all happy about your previous post.<br /><br />Not because I believe that this is a serious attempt to disguise malicious intent, but because the answer you seek is right before your very eyes, and yet you are too blind to see it.<br /><br />Blind...&nbsp; Maybe you don&#39;t understand what I am looking for ?<br /><br />You posted this sourcecode, but you obviously did not write it, and you obviously did not even read it, and so your request for assistance is, at the very least, premature.<br /><br />I wrote quite a bit of it.<br /><br /></div></div>
    <div class="meta">Posted on 2007-05-26 15:23:59 by skywalker</div>
   </div>
   <div class="post" id="post-189382">
    <div class="subject"><a href="#post-189382">Re: Determine when a program has been terminated</a></div>
    <div class="body">I interpreted your post (prior to your recent editing) as a request for a method of enumerating all running processes in order to determine the state of a particular process (which you would like to terminate, if it is indeed active).<br />One of the functions you provided (KillProcess) actually performs this task, although it&#39;s not set up to determine whether a given process is &#39;alive&#39;, its not much work to gut it and rewrite it as two new procs (IsProcessAlive and KillActiveProcess).<br />That&#39;s why I jumped up and down on your thread ;)<br /></div>
    <div class="meta">Posted on 2007-05-27 00:48:04 by Homer</div>
   </div>
   <div class="post" id="post-189388">
    <div class="subject"><a href="#post-189388">Re: Determine when a program has been terminated</a></div>
    <div class="body">.	The termination status of the process changes from STILL_ACTIVE to the exit value of the process. <br /><br />Looking at this, then if STILL_ACTIVE isn&#39;t returned, then it&#39;s OK to send Robo Killer<br />after the last victim?<br /><br />Andy</div>
    <div class="meta">Posted on 2007-05-27 10:00:42 by skywalker</div>
   </div>
   <div class="post" id="post-189392">
    <div class="subject"><a href="#post-189392">Re: Determine when a program has been terminated</a></div>
    <div class="body"><br />KillProcess is returning a BOOLEAN (TRUE/FALSE) result in eax.<br />TRUE if the Process was Terminated, and FALSE if it was not found.<br />If only one instance of this process is expected, I recommend that you insert a line containing only &#39;.break&#39; after the one that sets the result to TRUE, which will break your WHILE loop.. if multiple instance expected, leave it alone.<br /><br />KillProcess is being called from WndProc, and so the result is being returned to WndProc.. everything would be peachy, except for 2 things:<br />1) you&#39;ve commented out the line in WndProc which stores the result, and<br />2) you&#39;re storing the result in a Local Variable of a Procedure (WndProc), which is only valid storage within the context of a single execution of WndProc, ie, this is a &#39;transient&#39; variable, only good for storing data of a very temporary and immediately-used nature.. once WndProc returns, that data is gone forever, and certainly is not accessible from outside of WndProc.<br /><br /><br /></div>
    <div class="meta">Posted on 2007-05-28 02:54:11 by Homer</div>
   </div>
   <div class="post" id="post-189411">
    <div class="subject"><a href="#post-189411">Re: Determine when a program has been terminated</a></div>
    <div class="body">Alright. Let me look at how to declare it globally and get back with you.<br /><br />Can resource files be named with a different extension and still work instead of everything in it&#39;s own directory ? whoops, forgot about the QE macros.&nbsp; <br /><br />Andy</div>
    <div class="meta">Posted on 2007-05-29 05:21:49 by skywalker</div>
   </div>
   <div class="post" id="post-189414">
    <div class="subject"><a href="#post-189414">Re: Determine when a program has been terminated</a></div>
    <div class="body">I recommend you take a look at RadAsm, and especially any example of a RadAsm Project (.RAP file) to see a really nice editor in action.<br />You can edit multiple files simultaneously, it has nice colored syntax hilighting, and other nice features, its extremely configurable, supports plugins for bonus functionality, a joy to work with.<br /></div>
    <div class="meta">Posted on 2007-05-29 10:01:04 by Homer</div>
   </div>
  </div>
 </body>
</html>