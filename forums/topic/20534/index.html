<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Registry SubKey Enumeration - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20534" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=20534">Registry SubKey Enumeration</a></p>
   <div class="post" id="post-156840">
    <div class="subject"><a href="#post-156840">Registry SubKey Enumeration</a></div>
    <div class="body">I'm trying to enumerate subkeys of a specific registry key.<br />Please check the following code.<br /><br /><br />This procedure is the entrypoint, it opens a known registry key and then hands the key's pathname and handle to another proc:<br /><pre><code><br />Registry_EnumerateShares proc pInputPath<br />local hkey&#58;DWORD<br />local cunter<br />mov cunter,0<br />invoke RegOpenKeyEx, HKEY_CURRENT_USER, pInputPath, NULL, KEY_READ,addr hkey<br />.if eax==ERROR_SUCCESS<br />    invoke Registry_RecurseSubKeys, hkey, pInputPath<br />    mov cunter,eax<br />    invoke RegCloseKey,hkey<br />.endif<br />return cunter<br />Registry_EnumerateShares endp</code></pre><br /><br /><br />This is the workhorse procedure, called once by the entrylevel code and then iterative:<br /><br /><pre><code><br />Registry_RecurseSubKeys proc hkey, pInputPath<br />local currentKey&#58;DWORD<br />local currentValue&#58;DWORD<br />local buf&#91;256&#93;&#58;BYTE<br />local szSubKeyPath&#91;256&#93;&#58;BYTE<br />local bufsize<br />local cunter<br />local hsubkey<br /><br />    mov currentKey,0<br />    mov cunter,0<br />    $Message &quot;Registry_RecurseSubKey Entering SubKey %s&quot;,pInputPath<br /><br />;--------------------------<br />@@&#58;<br />    mov bufsize,255<br />    invoke RegEnumKey, hkey, currentKey, addr buf, bufsize<br />    .if eax==ERROR_SUCCESS<br />        ;The current key has one or more SubKeys...<br />        ;We must recurse each SubKey...<br /><br />        invoke lstrcpy, addr szSubKeyPath, pInputPath   ;Construct a Path to the new SubKey<br />        invoke lstrcat, addr szSubKeyPath, CTEXT&#40;&quot;\&quot;&#41;<br />        invoke lstrcat, addr szSubKeyPath, addr buf<br />        invoke RegOpenKeyEx, HKEY_CURRENT_USER, addr szSubKeyPath, NULL, KEY_READ,addr hsubkey<br />        .if eax==ERROR_SUCCESS  <br />            invoke Registry_RecurseSubKeys, hsubkey, addr szSubKeyPath<br />            add cunter,eax<br />            inc currentKey<br />            jmp @B<br />        .else<br />            $Message &quot;Error in RegOpenKeyEx %lu&quot;,eax<br />        .endif<br />;--------------------------<br /><br />    .elseif eax==ERROR_NO_MORE_ITEMS <br />          ;This is a leaf key - it may contain values we seek<br /><br />    .else<br />        $Message &quot;Error in RegEnumKey&#58; %lu&quot;,eax<br />    .endif<br />return cunter<br />Registry_RecurseSubKeys endp<br /></code></pre><br /><br /><br />The problem is stack corruption which I only noticed because of masm silly optimisations.<br />I have pseudocode which looks something like this:<br /><pre><code><br />invoke Registry_EnumerateShares, CTEXT&#40;&quot;OpenSlather\Shares&quot;&#41;<br />invoke wsprintf, addr blah, CTEXT&#40;&quot;%lu keys discovered&quot;&#41;,eax<br /></code></pre><br /><br />I am seeing the &quot;keys discovered&quot; text during final iteration of subkeys.<br />This means that masm is shoving the formatting string on the stack prior to calling the enumerator proc, regardless of my sourcecode's logical order of operations. Anyone have something to say about this?<br />It's frustrating !!</div>
    <div class="meta">Posted on 2005-02-08 22:55:56 by Homer</div>
   </div>
   <div class="post" id="post-156876">
    <div class="subject"><a href="#post-156876">Registry SubKey Enumeration</a></div>
    <div class="body">post the CTEXT Macro so we can see whats going on.<br />But basically yeh.. i wouldnt use it.. or recode it so it works.. what else can you do?</div>
    <div class="meta">Posted on 2005-02-09 13:51:29 by pwn</div>
   </div>
   <div class="post" id="post-156877">
    <div class="subject"><a href="#post-156877">Registry SubKey Enumeration</a></div>
    <div class="body">I think it's not a problem in CTEXT. Please give the code of Registry_EnumerateShares, too . Btw, why do you use HKEY_CURRENT_USER, when you already have the &quot;hkey&quot; variable (that I think you have to use now) ? I think if you use the hkey, the lstrcpy/cat will drop out :) . You won't have more than 10 handles open at once, so you needn't care about it. But don't forget to close those keys when you've finished enumeration  :-D</div>
    <div class="meta">Posted on 2005-02-09 14:18:19 by Ultrano</div>
   </div>
   <div class="post" id="post-156902">
    <div class="subject"><a href="#post-156902">Registry SubKey Enumeration</a></div>
    <div class="body">Here's my current code, modified a little.. I see what you mean about HKEY in the iterator - but since I don't open subkeys based on the current key, it isn't an issue - the way I was closing handle for error condition was a bigger issue.. hey, if you feel inclined to write a cleaner version of this, I'll be happy to replace this crap.. it's got a job to do. As long as it does what its meant to, I'm happy as a pig in the proverbial.<br /><br /><pre><code><br />;====================<br />;This procedure walks the Shares registry &quot;tree&quot;, looking for &quot;leaves&quot;.<br />;We only store file-specific data in the &quot;leaves&quot; of the tree.<br />;It enumerates subkeys of the currently open key.<br />;For each subkey discovered, the procedure iterates &#40;calls itself&#41;.<br />;====================<br />Registry_RecurseSubKeys proc hkey, pInputPath<br />;local dwtype&#58;DWORD<br />local currentKey&#58;DWORD<br />local currentValue&#58;DWORD<br />local buf&#91;256&#93;&#58;BYTE<br />local szSubKeyPath&#91;256&#93;&#58;BYTE<br />local bufsize<br />local cunter<br />local hsubkey<br />local valsize, valtype, valbuffsize<br />local valname&#91;256&#93;&#58;BYTE<br />local valbuffer&#91;256&#93;&#58;BYTE<br />local dwHigh<br />local dwLow<br />local masterhash&#58;MD5HASH<br />local pmap<br />local numbytes<br />local validity<br />local numpieces<br /><br />    mov currentKey,0<br />    mov cunter,0<br />;    $Message &quot;Registry_RecurseSubKey Entering SubKey %s&quot;,pInputPath<br /><br />;--------------------------<br />@@&#58;<br />    mov bufsize,255<br />    invoke RegEnumKey, hkey, currentKey, addr buf, bufsize<br />    .if eax==ERROR_SUCCESS<br />        ;The current key has one or more SubKeys...<br />        ;We must recurse each SubKey...<br /><br />        invoke lstrcpy, addr szSubKeyPath, pInputPath   ;Construct a Path to the new SubKey<br />        invoke lstrcat, addr szSubKeyPath, CTEXT&#40;&quot;\&quot;&#41;<br />        invoke lstrcat, addr szSubKeyPath, addr buf<br />        invoke RegOpenKeyEx, HKEY_CURRENT_USER, addr szSubKeyPath, NULL, KEY_READ,addr hsubkey<br />        .if eax==ERROR_SUCCESS      ;Key will be closed when ERROR_NO_MORE_ITEMS is encountered<br />            invoke Registry_RecurseSubKeys, hsubkey, addr szSubKeyPath<br />            invoke RegCloseKey, hsubkey<br />            add cunter,eax<br />            inc currentKey<br />            jmp @B<br />        .else<br />            $Message &quot;Error in RegOpenKeyEx %lu&quot;,eax<br />        .endif<br />;--------------------------<br /><br />    .elseif eax==ERROR_NO_MORE_ITEMS    ;end of the line, baby - no more CHILDREN<br />     ;   add pInputPath, 28      ;Skip the RegistryKey part of the pathname<br />     ;   $Message &quot;Leaf %s&quot;, pInputPath<br />        mov currentValue,0<br /><br />morevals&#58;<br />            mov bufsize,255<br />            mov valbuffsize,255<br />            mov valsize,255<br />            mov valtype,REG_DWORD	<br />            invoke RegEnumValue, hkey, currentValue, addr valname, addr valsize,NULL,addr valtype,addr valbuffer,addr valbuffsize<br /><br />          mov valbuffsize,255<br />          invoke RegQueryValueEx, hkey, CTEXT&#40;&quot;IsValid&quot;&#41;,NULL,addr valtype, addr validity, addr valbuffsize<br />            .if eax==ERROR_SUCCESS  <br />                .if validity==1<br />                    Message &quot;Valid Registry Entry&quot;<br />                    mov valbuffsize,255<br />                    invoke RegQueryValueEx, hkey, CTEXT&#40;&quot;SizeHigh&quot;&#41;,NULL,addr valtype,addr dwHigh, addr valbuffsize<br />                    .if eax==ERROR_SUCCESS  <br />             ;       $Message &quot;SizeHigh %lu&quot;, dwHigh<br />                      mov valbuffsize,255<br />                      invoke RegQueryValueEx, hkey, CTEXT&#40;&quot;SizeLow&quot;&#41;,NULL,addr valtype,addr dwLow, addr valbuffsize<br />                      .if eax==ERROR_SUCCESS  <br />              ;          $Message &quot;SizeLow %lu&quot;, dwLow<br />                        mov valbuffsize,255<br />                        invoke RegQueryValueEx, hkey, CTEXT&#40;&quot;MasterHash&quot;&#41;,NULL,addr valtype,addr masterhash, addr valbuffsize<br />                        .if eax==ERROR_SUCCESS  <br />                            mov valbuffsize,255<br />                            invoke RegQueryValueEx, hkey, CTEXT&#40;&quot;NumBytes&quot;&#41;,NULL,addr valtype,addr numbytes, addr valbuffsize<br />                            .if eax==ERROR_SUCCESS  <br />                                $Message &quot;NumBytes %lu&quot;, numbytes<br />                                mov pmap, malloc &#40;numbytes&#41;<br />                                mov valbuffsize,255<br />                                invoke RegQueryValueEx, hkey, CTEXT&#40;&quot;PieceMap&quot;&#41;,NULL,addr valtype,pmap, addr valbuffsize<br />                                .if eax==ERROR_SUCCESS  <br />                                    Message &quot;Got PieceMap&quot;<br />                                    mov valbuffsize,255<br />                                    invoke RegQueryValueEx, hkey, CTEXT&#40;&quot;NumPieces&quot;&#41;,NULL,addr valtype,addr numpieces, addr valbuffsize<br />                                    .if eax==ERROR_SUCCESS  <br />                          ;              $Message &quot;NumPieces %lu&quot;, numpieces<br />                                        mov eax,numpieces<br />                                        mov pmap, malloc &#40;sizeof MD5HASH&#41;<br />                                        Message &quot;Fetching PieceHashes&quot;<br /><br />                                        xor ecx,ecx<br />                                        mov edi,pmap<br />                                        .while ecx&lt;numpieces<br />                                            push ecx<br />                                            push edi<br />                                            invoke wsprintf,addr buf, CTEXT&#40;&quot;%lu&quot;&#41;,ecx                                            <br />                                            pop edi<br />                                            push edi<br />                                            mov valbuffsize,255<br />                                            invoke RegQueryValueEx, hkey, addr buf,NULL,addr valtype,edi, addr valbuffsize<br />                                            pop edi<br />                                            add edi,sizeof MD5HASH<br />                                            pop ecx<br />                                            inc ecx<br />                                        .endw<br />                                        Message &quot;should be calling Shares_AddNewFilePath&quot;<br />               ;                         invoke Shares_AddNewFilePath,pInputPath,addr masterhash,pmap<br />                                        inc cunter<br />                                   .endif<br />                                .endif<br />                                free pmap<br />                            .endif<br />                        .endif<br />                      .endif<br />                   .endif<br />                <br />                .else<br />                    Message &quot;Invalid Registry Entry&quot;<br />                .endif<br /><br />            .elseif eax==ERROR_NO_MORE_ITEMS <br /><br />        ;    .else<br />        ;        $Message &quot;RegQueryValue Error %lu&quot;,eax<br />            .endif<br /><br /><br />    .else<br />        $Message &quot;Error in RegEnumKey&#58; %lu&quot;,eax<br />        invoke RegCloseKey, hsubkey<br />    .endif<br />invoke RegCloseKey, hkey<br />return cunter<br />Registry_RecurseSubKeys endp<br /><br />;===================<br />;ENTRYPOINT FOR REGISTRYKEY ENUMERATION<br />;This procedure should be called once during startup to load existing Shares from the registry.<br />;This procedure Opens a Registry Key from a given KeyPath string,<br />;then it hands the open key and the pathstring to Registry_RecurseKeys.<br />;====================<br />Registry_EnumerateShares proc pInputPath<br />local hkey&#58;DWORD<br />local cunter<br />mov cunter,0<br />invoke RegOpenKeyEx, HKEY_CURRENT_USER, pInputPath, NULL, KEY_READ,addr hkey<br />.if eax==ERROR_SUCCESS<br />    invoke Registry_RecurseSubKeys, hkey, pInputPath<br />    mov cunter,eax<br />.endif<br />return cunter<br />Registry_EnumerateShares endp<br /><br />;==========================</code></pre></div>
    <div class="meta">Posted on 2005-02-10 06:39:29 by Homer</div>
   </div>
   <div class="post" id="post-156911">
    <div class="subject"><a href="#post-156911">Registry SubKey Enumeration</a></div>
    <div class="body">i see what you mean about that code being a piece of crap evilhomer...<br />yeh someone should definetely give it a fixup..<br />oh well best of luck. -nt-</div>
    <div class="meta">Posted on 2005-02-10 09:20:31 by pwn</div>
   </div>
   <div class="post" id="post-156931">
    <div class="subject"><a href="#post-156931">Registry SubKey Enumeration</a></div>
    <div class="body">The iterator procedure now opens subkeys via the currently open key's handle ..<br /><br /><pre><code><br />;--------------------------<br />@@&#58;<br />    mov bufsize,255<br />    invoke RegEnumKey, hkey, currentKey, addr buf, bufsize<br />    .if eax==ERROR_SUCCESS<br />        ;The current key has one or more SubKeys...<br />        ;We must recurse each SubKey...<br />        invoke RegOpenKeyEx, hkey, addr buf, NULL, KEY_READ,addr hsubkey<br />        .if eax==ERROR_SUCCESS      ;Key will be closed when ERROR_NO_MORE_ITEMS is encountered<br />            invoke Registry_RecurseSubKeys, hsubkey, addr szSubKeyPath<br />            invoke RegCloseKey, hsubkey<br />            add cunter,eax<br />            inc currentKey<br />            jmp @B<br />        .else<br />            $Message &quot;Error in RegOpenKeyEx %lu&quot;,eax<br />        .endif<br />;--------------------------<br /></code></pre><br /><br />Does that look better to you? :)</div>
    <div class="meta">Posted on 2005-02-10 22:06:01 by Homer</div>
   </div>
   <div class="post" id="post-156934">
    <div class="subject"><a href="#post-156934">Registry SubKey Enumeration</a></div>
    <div class="body">Bug in regkey enumerator finally resolved.<br />It was hard to spot due to the multithreaded nature of the application, which made it appear that the bug was elsewhere..<br />Has anyone ever noticed that RegQueryValueEx operates from within a thread created by ntdll? I had read the documentation regarding cached WRITES to the registry and the keyflush thingy, but I had no idea that READS operated the same way ...<br />Here's the final version of the procedure :)<br />Damn, that little bug took me three days to find because I was looking in the WRONG PLACE  :oops: <br /><br /><br /><pre><code><br />;========================================================<br />;This procedure walks the Shares registry &quot;tree&quot;, looking for &quot;leaves&quot;.<br />;We only store file-specific data in the &quot;leaves&quot; of the tree.<br />;It enumerates subkeys of the currently open key.<br />;For each subkey discovered, the procedure iterates &#40;calls itself&#41;.<br />;========================================================<br />Registry_RecurseSubKeys proc hkey, pInputPath<br />;local dwtype&#58;DWORD<br />local currentKey&#58;DWORD<br />local currentValue&#58;DWORD<br />local buf&#91;256&#93;&#58;BYTE<br />local szSubKeyPath&#91;256&#93;&#58;BYTE<br />local bufsize<br />local cunter<br />local hsubkey<br />local valsize, valtype, valbuffsize<br />local valname&#91;256&#93;&#58;BYTE<br />local valbuffer&#91;256&#93;&#58;BYTE<br />local dwHigh<br />local dwLow<br />local masterhash&#58;MD5HASH<br />local pmap              ;&lt;-- pointer to buffer for binary piecemap<br />local phasharray    ;&lt;-- pointer to buffer for N piecehashes<br />local numbytes<br />local validity<br />local numpieces<br /><br />    mov currentKey,0<br />    mov cunter,0<br />;    $Message &quot;Registry_RecurseSubKey Entering SubKey %s&quot;,pInputPath<br /><br />;--------------------------<br />@@&#58;<br />    mov bufsize,255<br />    invoke RegEnumKey, hkey, currentKey, addr buf, bufsize<br />    .if eax==ERROR_SUCCESS<br />        ;The current key has one or more SubKeys...<br />        ;We must recurse each SubKey...<br />        invoke RegOpenKeyEx, hkey, addr buf, NULL, KEY_READ,addr hsubkey<br />        .if eax==ERROR_SUCCESS      ;Key will be closed when ERROR_NO_MORE_ITEMS is encountered<br />            invoke Registry_RecurseSubKeys, hsubkey, addr szSubKeyPath<br />            invoke RegCloseKey, hsubkey<br />            inc currentKey<br />            jmp @B<br />        .else<br />            $Message &quot;Error in RegOpenKeyEx %lu&quot;,eax<br />        .endif<br />;--------------------------<br /><br />    .elseif eax==ERROR_NO_MORE_ITEMS    ;end of the line, baby - no more CHILDREN<br />     ;   add pInputPath, 28      ;Skip the RegistryKey part of the pathname<br />     ;   $Message &quot;Leaf %s&quot;, pInputPath<br />        mov currentValue,0<br /><br />morevals&#58;<br />            mov bufsize,255<br />            mov valbuffsize,255<br />            mov valsize,255<br />            mov valtype,REG_DWORD	<br />            invoke RegEnumValue, hkey, currentValue, addr valname, addr valsize,NULL,addr valtype,addr valbuffer,addr valbuffsize<br /><br />          mov valbuffsize,255<br />          invoke RegQueryValueEx, hkey, CTEXT&#40;&quot;IsValid&quot;&#41;,NULL,addr valtype, addr validity, addr valbuffsize<br />            .if eax==ERROR_SUCCESS  <br />                .if validity==1<br />                    mov valbuffsize,255<br />                    invoke RegQueryValueEx, hkey, CTEXT&#40;&quot;SizeHigh&quot;&#41;,NULL,addr valtype,addr dwHigh, addr valbuffsize<br />                    .if eax==ERROR_SUCCESS  <br />                      mov valbuffsize,255<br />                      invoke RegQueryValueEx, hkey, CTEXT&#40;&quot;SizeLow&quot;&#41;,NULL,addr valtype,addr dwLow, addr valbuffsize<br />                      .if eax==ERROR_SUCCESS  <br />                        mov valbuffsize,255<br />                        invoke RegQueryValueEx, hkey, CTEXT&#40;&quot;MasterHash&quot;&#41;,NULL,addr valtype,addr masterhash, addr valbuffsize<br />                        .if eax==ERROR_SUCCESS  <br />                            mov valbuffsize,255<br />                            invoke RegQueryValueEx, hkey, CTEXT&#40;&quot;NumBytes&quot;&#41;,NULL,addr valtype,addr numbytes, addr valbuffsize<br />                            .if eax==ERROR_SUCCESS  <br />                                mov pmap, malloc &#40;numbytes&#41;<br />                                mov valbuffsize,255<br />                                invoke RegQueryValueEx, hkey, CTEXT&#40;&quot;PieceMap&quot;&#41;,NULL,addr valtype, pmap, addr valbuffsize<br />                                .if eax==ERROR_SUCCESS  <br />                                    Message &quot;Got PieceMap&quot;<br />                                    mov valbuffsize,255<br />                                    invoke RegQueryValueEx, hkey, CTEXT&#40;&quot;NumPieces&quot;&#41;,NULL,addr valtype,addr numpieces, addr valbuffsize<br />                                    .if eax==ERROR_SUCCESS  <br />                                        mov eax,sizeof MD5HASH <br />                                        mul numpieces<br />                                        mov phasharray, malloc &#40;eax&#41;<br />                                        xor ecx,ecx<br />                                        mov edi,phasharray<br />                                        .while ecx&lt;numpieces<br />                                            push ecx<br />                                            push edi<br />                                            mov buf&#91;0&#93;,0<br />                                            invoke wsprintf,addr buf, CTEXT&#40;&quot;%lu&quot;&#41;,ecx  ;&lt;--Pieces are numerically named &#40;0,1,2,etc&#41;                          <br />                                            pop edi<br />                                            push edi<br />                                            mov valbuffsize,255<br />                                            invoke RegQueryValueEx, hkey, addr buf,NULL,addr valtype,edi, addr valbuffsize<br />                                            pop edi<br />                                            add edi,sizeof MD5HASH<br />                                            pop ecx<br />                                            inc ecx<br />                                        .endw<br />                                        Message &quot;Call to Shares_AddNewFilePath is currently DISABLED&quot;<br />               ;                         invoke Shares_AddNewFilePath,pInputPath,addr masterhash,pmap<br />                                        inc cunter<br />                                   .endif<br />                                .endif<br />                                free pmap<br />                            .endif<br />                        .endif<br />                      .endif<br />                   .endif<br />                <br />                .else<br />                    Message &quot;Invalid Registry Entry&quot;<br />                .endif<br /><br />            .elseif eax==ERROR_NO_MORE_ITEMS <br /><br />        ;    .else<br />        ;        $Message &quot;RegQueryValue Error %lu&quot;,eax<br />            .endif<br /><br /><br />    .else<br />        $Message &quot;Error in RegEnumKey&#58; %lu&quot;,eax<br />        invoke RegCloseKey, hsubkey<br />    .endif<br />invoke RegCloseKey, hkey<br />return cunter<br />Registry_RecurseSubKeys endp<br /><br />;============================================================================<br />;ENTRYPOINT FOR REGISTRYKEY ENUMERATION<br />;This procedure should be called once during startup to load existing Shares from the registry.<br />;This procedure Opens a Registry Key from a given KeyPath string,<br />;then it hands the open key and the pathstring to Registry_RecurseKeys.<br />;============================================================================<br />Registry_EnumerateShares proc pInputPath<br />local hkey&#58;DWORD<br />local cunter<br />mov cunter,0<br />invoke RegOpenKeyEx, HKEY_CURRENT_USER, pInputPath, NULL, KEY_READ,addr hkey<br />.if eax==ERROR_SUCCESS<br />    invoke Registry_RecurseSubKeys, hkey, pInputPath<br />    mov cunter,eax<br />.endif<br />return cunter<br />Registry_EnumerateShares endp<br /><br />;============================================================================<br /></code></pre></div>
    <div class="meta">Posted on 2005-02-10 22:29:48 by Homer</div>
   </div>
  </div>
 </body>
</html>