<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Permutative Optimizer - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=22550" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=22550">Permutative Optimizer</a></p>
   <div class="post" id="post-169151">
    <div class="subject"><a href="#post-169151">Permutative Optimizer</a></div>
    <div class="body">Is there such an application that will allow you to highlight certain lines in an Assembly program for optimizing? eg. in a 20 line code segment, identify which instructions must be after which ones. It would then create all 200 etc permutations of the lines which give the exact same result but run at different speeds. Then you can assemble all 200 asm files and test for speed.<br /><br />This would effetively serve to hand optimize routines without hand optimizing them per se by checking instruction latency, ports, etc.<br /><br />Thanks.</div>
    <div class="meta">Posted on 2005-12-25 12:44:39 by V Coder</div>
   </div>
   <div class="post" id="post-169158">
    <div class="subject"><a href="#post-169158">Re: Permutative Optimizer</a></div>
    <div class="body">VTUNE?</div>
    <div class="meta">Posted on 2005-12-25 16:22:13 by The Svin</div>
   </div>
   <div class="post" id="post-169175">
    <div class="subject"><a href="#post-169175">Re: Permutative Optimizer</a></div>
    <div class="body">Yeah - Vtune is cool. It can tell you how to write the code so the app will perform best on all intels. Alternatively you can dig Agner Fogg&#39;s tutorials on optimization and do the job yourself (more fun IMHO).</div>
    <div class="meta">Posted on 2005-12-26 20:37:18 by ti_mo_n</div>
   </div>
   <div class="post" id="post-169191">
    <div class="subject"><a href="#post-169191">Re: Permutative Optimizer</a></div>
    <div class="body">Thanks.<br /><br />I tried vtune briefly. Short trial period iirc - and I was studying early in the trial period and had little time to experiment with it. Aldo, I don&#39;t yet want to spend that kind of money on a non income-generating project. I&#39;ll look at it again.<br /><br />I&#39;ve used the Agner Fog optimization guidelines and the Intel/AMD optimization manuals. I&#39;m actually optimizing code for multiple platforms. I&#39;m just wondering if I can squeeze another 1 or 2 or 5 or 10% out of the routines.<br /><br />Yet I was thinking more of a brute force optimizer. No software hints, no Agner Fog: Load the asm program into a this app, and it produces 200+ asm variants of the code you have entered. Same instructions in different order. You run ml etc on all 200 and you test the speed yourself.<br /><br />Is there an assembly program to do that?<br /><br /></div>
    <div class="meta">Posted on 2005-12-27 20:20:37 by V Coder</div>
   </div>
   <div class="post" id="post-169192">
    <div class="subject"><a href="#post-169192">Re: Permutative Optimizer</a></div>
    <div class="body">It looks like writing something between a logic analyzer and an assembler. The assembler part shouldn&#39;t be very difficult, but the first part, where you must analyze the logic of a proc and then generate n routines that maintain that logic, is quite a challenge. Try reading any C(++) optimiizng compiler sources (like MS visual c++) to get the idea how it works. Unfortunately I don&#39;t know any open-source C(++) optimizing compiler (I just use MS&#39;s VC++).</div>
    <div class="meta">Posted on 2005-12-27 22:13:17 by ti_mo_n</div>
   </div>
   <div class="post" id="post-169193">
    <div class="subject"><a href="#post-169193">Re: Permutative Optimizer</a></div>
    <div class="body">Well actually, I was thinking just an programmable text editor.<br /><br />Lets say I have a program:<br /><pre><code>A<br />B<br />C**<br />D**<br />E**<br />F**<br />G**<br />H</code></pre><br />Instruction E must follow C, F must follow D, and G must follow E, and I want to optimize that 5 instruction sequence, leaving A, B, H in place.<br /><br />I can have {D, F, C, E, G}; {C, D, F, E, G}; {C, E, D, F, G}; {C, E, G, D, F}, plus several other arrangements. I want the program to produce the how ever many options in separate asm files. Then we&#39;ll need a batch file to run the assembler.<br /><br />The program I&#39;m describing need not understand anything about assembly. It must just obey instructions.</div>
    <div class="meta">Posted on 2005-12-27 22:55:40 by V Coder</div>
   </div>
   <div class="post" id="post-169210">
    <div class="subject"><a href="#post-169210">Re: Permutative Optimizer</a></div>
    <div class="body">This way you&#39;ll gain no more than 1%. Simply rearranging the instructions gives (almost) no gain because nowadays CPUs execute the instructions out of order.</div>
    <div class="meta">Posted on 2005-12-28 07:12:19 by ti_mo_n</div>
   </div>
   <div class="post" id="post-169234">
    <div class="subject"><a href="#post-169234">Re: Permutative Optimizer</a></div>
    <div class="body"><br />&nbsp; I have found in my experience my P4 can give quite a decent speed boost by re-arranging the instructions ( much more than 1%).&nbsp; The P4 by no means does a fantastic job of instruction re-ordering, otherwise I wouldn&#39;t have seen decent speedups from swapping instructions around.&nbsp; I had planned on writing a program exactly like you are proposing, but I ran out of time.&nbsp; I wrote something similar that finds the optimal prefetch distance for the &quot;prefetch&quot; instruction.&nbsp; It would try all combinations of the location of the instruction in a loop, plus all different offsets into the buffer you are trying to prefetch.&nbsp; I wrote a program that would automatically compile all those different combinations, and run them, saving the output of the speed of the routine in cycles into one big huge text file.&nbsp; I sorted the text file to find the fastest one.</div>
    <div class="meta">Posted on 2005-12-29 10:27:55 by mark_larson</div>
   </div>
   <div class="post" id="post-169374">
    <div class="subject"><a href="#post-169374">Re: Permutative Optimizer</a></div>
    <div class="body">I was hoping to get that 1% out of an Athlon routine, plus that x% from the Pentium III and Pentium 4 routines. I&#39;ve recently optimzed stuff for a Pentium III, Athlon and P4. My program chooses the appropriate processor at run-time.<br /><br />The Athlon appears to reorder aggressively, since running the base algorithm took 144 seconds but manual optimization eventually got it down to 140 seconds. I was wondering if I could get that down further. I tried loop unrolling, but I would need to optimize the unrolled loop manually. The Pentium III and Pentium 4 do not appear to reorder as well, and manual optimization got good results. I have no doubt that my manual optimization is not yet optimal, and thus I was looking for an easier way to do this.<br /><br />Mark, do you expect to write such a program? And how soon? Thanks.<br /><br />I would be interested in that prefetch optimization routine as well. Thanks.</div>
    <div class="meta">Posted on 2006-01-07 18:31:18 by V Coder</div>
   </div>
   <div class="post" id="post-169378">
    <div class="subject"><a href="#post-169378">Re: Permutative Optimizer</a></div>
    <div class="body">New AMD chips are better than new Intel chips, that&#39;s just how it is for now.<br /><br />r22&#39;s QUICK REFERENCE OPTIMIZATION POST<br /><br />Rroutines,<br />-If the routine can be made parallel use SIMD instructions<br />-Use CMOV&#39;s and other branch avoiding techniques especially inside loops<br />-If you&#39;re moving a lot of data (ie &gt; 4096 bytes) prefetchnta<br />-Post your routine for other people with experience to check out, if a decent optimization is there usually someone will tell you about it.<br /><br />Memory<br />-Take/Give as much data as possible on reads and writes<br />-Unaligned data movs use 32byte chunks<br />-Aligned data movs use SIMD chunks as big as you can ~64bytes<br />-Aligned and Unaligned, align the READ and keep the WRITE unaligned<br />-Prefetching big READs/WRITEs, use a loop with 2 prefetch instructions inside,<br />prefetch ~4096bytes with the loop then use another loop for your READs<br /><br />mov ecx,32<br />Prefnontemp:<br />prefetchnta byte<br />prefetchnta byte<br />add edi,128<br />dec ecx<br />jnz Prefnontemp<br />sub edi,128*32<br /><br />Math<br />-Use LEA instead of Mul and Add combos<br />-Integer: Div or Mul by power of 2 use a shift<br />-Integer: Div x/y if y is known use magic number multiply<br />-Integer: Div x/y if y is NOT known USE FPU for 32 or 64bit ints<br /> <br />div latency 39/71 for 32bit and 64bit <br />idiv latency 42/74 for 32bit and 64bit<br />fild 2x latency 12 (6+6)<br />fdiv latency 20/24 for 32bit and 64bit reals<br />fistp latency 4<br />FPU int divide 36/40 for 32bit and 64bit integers<br />-SIMD: Don&#39;t use DIV, use RCP and MUL combo<br />-SIMD: Use LUT approximations or taylor expansion approximations for trig functions <br /><br />Unrolling<br />-Unroll after you&#39;ve optimized yoru code<br />-Unroll 2x first and reoptimize the structure of the code<br />-Try to seperate consecutive WRITEs to the same register or memory location<br /><br />BAD<br />inc ecx<br />mov ebx,eax<br />add ebx,10<br />BETTER<br />mov ebx,eax<br />inc ecx<br />add ebx,10<br />-Try to keep 32bit and 16bit instructions apart from eachother<br />-Unrolling too much can sometimes make the code run slower, so benchmark<br /><br />That&#39;s a good start</div>
    <div class="meta">Posted on 2006-01-07 23:10:26 by r22</div>
   </div>
   <div class="post" id="post-169444">
    <div class="subject"><a href="#post-169444">Re: Permutative Optimizer</a></div>
    <div class="body"><em>New AMD chips are better than new Intel chips, that&#39;s just how it is for now.</em><br /><br />Not necessarily. Depends on algorithm and its implementation. In regard to GPR integer and MMX speed, my own tests and optimization of <strong><u>compute-bound</u></strong> code has found that <u>at the same clock speed</u> the Pentium 4 is outclassed by the AMD Athlon 64, AMD Athlon, Pentium M, Pentium III, AMD k6-2 and Pentium MMX. However, the Pentium 4 has an advantage, or is that a saving grace, it does NOT run at the same clock speed as these processors - it runs faster. The Pentium 4 also processes 64 bit numbers with paddq whereas the Athllon, Pentium III (and lower processors) would need to use paddd and propagate carries from dword to dword. This reduces the length of the code from 63 instructions (Athlon) or 56 instructions (Pentiium III) to 46 instructions. The Athlon code does not use paddd to and MMX to propagate the carry. It uses integer operations and therefore has more instructions than the Pentium III code.<br /><br />The Pentium III/M execute MMX instructions with 1 cycle latency, but cannot often execute more than one at a time. The Pentium 4 executes one MMX at a time, with a latency of 2 cycles. The Athlon can execute up to two MMX instructions at a time, with a latency of 2 cycles. Athlon XP/64 and Pentium III/M each have 3 integer execution units. However the Athlons more likely execute 3 integer instructions per cycle than the Pentium III/M, and the Athlons also apparently reorder instructions agressively. Furthermore the Athlons execute 32bit adc in 1 cycle whereas the Pentium III/M take 2 cycles. This is why the Athlon is stronger with my Athlon (integer laden) code than my Pentium III (MMX heavy) code, and the Athlon 64 stronger with the longer Athlon code than the shorter Pentium 4 (MMX &amp; SSE2) code. <br /><br />Interestingly, the Athlon XP runs the Pentium III (MMX heavy) code slower than the Pentium III, and about 20% slower than it does the Athlon code, and the Pentium III runs the Athlon (integer) code slower than the Athlon, and about 20% slower than it does the Pentium III code. All in all, the Athlon executes its own 63 instructions in 10% less time than the Pentium III executes its 56 instructions.<br /><br />The Pentium M is almost identical to the Pentium III, except that it can also run Pentium 4 code (SSE2 instructions). My Pentium 4 code uses 46 instructions including paddq. At the same clock speed, the Pentium M executes the 46 instructions in 83% of the time the Pentium III takes to execute its 56 instructions (almost linear ratio - it does not execute more instructions simultaneously). This is 94% of the time the Athlon takes to execute 63 instructions, ie, the Athlon strictly also executes instructions faster than the Pentium M. However, since the Pentium M uses the shorter instruction sequence whereas the Athlon uses a longer instruction sequence, the Pentium M is slightly faster than the Athlon at the same clock speed.<br /><br />The Athlon 64 inherits the Athlon&#39;s weakness in MMX code and iirc runs the shorter &#39;SSE2&#39; code slower than it runs the Athlon code. Indeed, if the Athlon 64 were to halve its MMX instruction latency from 2 cycles to 1, it would probably be the processor that cannot be beat at anything.<br /><br />Time to complete a benchmark: <br />Pentium 4 HT 2400MHz - 261 seconds <br />Pentium III 1066MHz - 312 seconds. A 2000MHz Pentium 4 competes with this. <br />Athlon XP 1666MHz - 179 seconds. You would need a 3500MHz Pentium 4 Desktop to compete with this desktop. <br />Pentium M 1600MHz - 169 seconds. You would need a 3700MHz Pentium 4 Desktop to compete with this notebook. <br /><br />The Pentium 4 beat my Pentium III notebook but nothing else. It would beat a 1GHz but not a 1.1GHz Pentium M notebook.<br /><br />Dealing with ultimate processors: <br />2200MHz Pentium M  matches 5100MHz Pentium 4. <br />2200MHz Athlon XP  matches 4600MHz Pentium 4 <br />2800MHz Athlon 64  (running Athlon XP code not Pentium 4 SSE2 code) matches 5900MHz Pentium 4. <br /><br />That is, all things being equal.<br /><br />IIRC Prescott eliminated some of the advantages of the double pumped ALU of the Pentium 4, negatively affecting some integer but not so much MMX code. The latency, not the throughput was increased from 0.5 cycles to 1 cycle, that is the result of those instructions would be available 0.5 cycle later. This would not matter so much in an optimized MMX routine which uses sub or add at the end of the loop to advance the pointers. This may negatively affect code which uses tightly arranged integer instructions. Again, the Athlon handles tightly arranged integer instructions very well.<br /><br /><strong>What about Core Duo/Solo?</strong><br />The SSE/SSE2 units of the Pentium M are apparently optimized. I&#39;m not sure if it now would run more MMX instructions in parallel, in which case it would strengthen its position against the Athlon XP/64. I&#39;m eagerly awaiting a look at the new instruction latencies.<br /><br />As it stands I plan to get an Athlon X2 probably next quarter. I&#39;m guess I should wait for the M2 since the 939 is at the end of its line. Or I might get a 939 X2 when the prices come down as 939 is phased out.<br /></div>
    <div class="meta">Posted on 2006-01-10 19:36:29 by V Coder</div>
   </div>
   <div class="post" id="post-169448">
    <div class="subject"><a href="#post-169448">Re: Permutative Optimizer</a></div>
    <div class="body">One question:<br /><br /><div class="quote">Pentium 4 HT 2400MHz - 261 seconds</div><br /><br />Have you split the job for 2 threads of execution? Or is this only 1 unit&#39;s time?</div>
    <div class="meta">Posted on 2006-01-11 00:02:32 by ti_mo_n</div>
   </div>
   <div class="post" id="post-169454">
    <div class="subject"><a href="#post-169454">Re: Permutative Optimizer</a></div>
    <div class="body">With HT and multi-core/smp it&#39;s also worth knowing whether a single-thread operation is affinity-limited to one processor, or allowed to jump around... jumping around has some negative consequences (check the &quot;dualcore musings&quot; at http://f0dder.reteam.org/ )</div>
    <div class="meta">Posted on 2006-01-11 05:49:19 by f0dder</div>
   </div>
   <div class="post" id="post-169464">
    <div class="subject"><a href="#post-169464">Re: Permutative Optimizer</a></div>
    <div class="body">Yeah. In intel&#39;s manuals it&#39;s stated clearly that it&#39;s much wiser to bind a thread to a specific execution unit.<br /><br />So to finish my previous post: you should split the job between all available execution units and then present the slowest time. for example: if a CPU has 2 units, then you<br />a) split the job in half,<br />b) ,<br />c) start the jobs.<br /><br />If the jobs execute in 210ms and 230ms respectively, then you can say that the whole work took 230ms, NOT 440ms.<br /><br />V Coder, please clarify how you did the test on HT CPUs.</div>
    <div class="meta">Posted on 2006-01-11 12:07:00 by ti_mo_n</div>
   </div>
   <div class="post" id="post-169474">
    <div class="subject"><a href="#post-169474">Re: Permutative Optimizer</a></div>
    <div class="body">All machines ran a single-threaded program performing the same calculations, etc. No threading magic done.</div>
    <div class="meta">Posted on 2006-01-11 22:45:52 by V Coder</div>
   </div>
   <div class="post" id="post-169475">
    <div class="subject"><a href="#post-169475">Re: Permutative Optimizer</a></div>
    <div class="body">So the HT CPUs&#39; overall performance is about twice the mentioned :)</div>
    <div class="meta">Posted on 2006-01-11 23:09:05 by ti_mo_n</div>
   </div>
   <div class="post" id="post-169511">
    <div class="subject"><a href="#post-169511">Re: Permutative Optimizer</a></div>
    <div class="body"><div class="quote"><br />So the HT CPUs&#39; overall performance is about twice the mentioned :)<br /></div>Nope. AFAIK HT never doubles performance. Gains are usually about 10-20%<br /><br />In this case HT gave 40% performance increase when two copies of that program ran simultaneously on the HT, they both operated iirc at about (a bit less than) 70% of the speed of a single copy running. Just goes to show how much of the potential bandwidth of the Pentium 4 is normally wasted.</div>
    <div class="meta">Posted on 2006-01-13 15:08:04 by V Coder</div>
   </div>
  </div>
 </body>
</html>