<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Duntemann, Linux, and The C Calling Convention - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29506" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=117">Unix</a> &raquo; <a href="../?id=29506">Duntemann, Linux, and The C Calling Convention</a></p>
   <div class="post" id="post-208407">
    <div class="subject"><a href="#post-208407">Duntemann, Linux, and The C Calling Convention</a></div>
    <div class="body">In &quot;Assembly Language Step-by-Step&quot;, Jeff Duntemann makes a big fuss about the C calling convention and how when programing for Linux, a program cannot modify the EBX, ESP, EBP, ESI and EDI registers. I&#039;m interested in Linux but also BSD and OS X. Looking around the web for information, I cannot find any information that specifically and definitely confirms what Duntemann writes. It seems to me an operating system that depends on application programmers following a convention would be an operating system that crashes frequently. ;-)<br /><br />Duntemann&#039;s discussion results in the following boilerplate code for NASM<br /><pre><code><br />main:<br />&nbsp; push ebp<br />&nbsp; mov ebp, esp<br />&nbsp; push ebx<br />&nbsp; push esi<br />&nbsp; push edi<br /><br />&nbsp; ; guts of program here<br /><br />&nbsp; pop edi<br />&nbsp; pop esi<br />&nbsp; pop ebx<br />&nbsp; mov esp,ebp<br />&nbsp; pop ebp<br />&nbsp; ret<br /></code></pre><br /><br />Does anyone have a definitive reference regarding these registers being preserved for Linux, OS X, and/or FreeBSD. I can&#039;t find anything and there is nothing mentioned in the FreeBSD Developer&#039;s Handbook which has a large-ish Assembly section.<br /><br />Also it seems &quot;ret&quot; is not sufficient to exit a program from OS X. It is necessary to have<br /><br /><pre><code><br />&nbsp; push 1<br />&nbsp; sub esp, 4<br />&nbsp; int 0x80<br /></code></pre><br /><br />Thanks,<br />Peter<br /></div>
    <div class="meta">Posted on 2009-08-08 19:46:31 by petermichaux</div>
   </div>
   <div class="post" id="post-208408">
    <div class="subject"><a href="#post-208408">Re: Duntemann, Linux, and The C Calling Convention</a></div>
    <div class="body">This will help you:<br />http://www.agner.org/optimize/#manuals<br />direct link <u>w ww.agner.org/optimize/calling_conventions.pdf</u></div>
    <div class="meta">Posted on 2009-08-08 21:10:38 by drizz</div>
   </div>
   <div class="post" id="post-208409">
    <div class="subject"><a href="#post-208409">Re: Duntemann, Linux, and The C Calling Convention</a></div>
    <div class="body">If you want to be completely sure Peter, you can install both of these systems and test it yourself with a debugger (like gdb).<br />Call a few APIs consecutively and watch the registers in the debugger. <br /><br />And by the way, the C convention is very good for 32 bit systems. IMO it&#039;s better than stdcall since you can regroup stack cleanup with add esp, 4*x</div>
    <div class="meta">Posted on 2009-08-08 21:29:11 by ChaperonNoir</div>
   </div>
   <div class="post" id="post-208410">
    <div class="subject"><a href="#post-208410">Re: Duntemann, Linux, and The C Calling Convention</a></div>
    <div class="body"><div class="quote"><br />In &quot;Assembly Language Step-by-Step&quot;, Jeff Duntemann makes a big fuss about the C calling convention and how when programing for Linux, a program cannot modify the EBX, ESP, EBP, ESI and EDI registers. I&#039;m interested in Linux but also BSD and OS X. Looking around the web for information, I cannot find any information that specifically and definitely confirms what Duntemann writes. It seems to me an operating system that depends on application programmers following a convention would be an operating system that crashes frequently. ;-)</div><br /><br />You can modify these registers without worry if you are just writing a simple program. It&#039;s considered good practice that when you write a procedure you should save/restore these registers so that the calling procedures don&#039;t need to worry about you trashing registers that it might depend on. When programming in assembly you are generally making calls to the syscall interrupt which uses most of those as arguments.<br /><br />The C Calling convention does not clean up the stack for you but it does specify that those registers will not be trashed when a procedure is called. Ecx and Eax however are almost guaranteed to be trashed and you should not expect them to be the same after a C function call. So when writing procedures which interface with C programs you should always save those registers otherwise your C program might break.<br /><br /><div class="quote"><br />Duntemann&#039;s discussion results in the following boilerplate code for NASM<br /><pre><code><br />main:<br />&nbsp; push ebp<br />&nbsp; mov ebp, esp<br />&nbsp; push ebx<br />&nbsp; push esi<br />&nbsp; push edi<br /><br />&nbsp; ; guts of program here<br /><br />&nbsp; pop edi<br />&nbsp; pop esi<br />&nbsp; pop ebx<br />&nbsp; mov esp,ebp<br />&nbsp; pop ebp<br />&nbsp; ret<br /></code></pre><br /></div><br /><br />Keep in mind the idea of optimization. Instead of arsing with boiler plate routines just keep in mind that if you use a variable in your procedure, save it before and restore it after. So if you aren&#039;t using Edi, Esi, Ebx or whatever then don&#039;t worry about saving it. He&#039;s just trying to instill the standards on you from the git-go. It&#039;s actually a good thing to do since, when you get to doing things like C/ASM mixed projects, if you end up calling a procedure written in assembly from a C program, the compiler might be using Edi to reference a certain value; When your C code calls your Asm routine, if it uses the Edi register then your C program&#039;s Edi reference is no longer valid.<br /><br />Another thing is, this is pretty much true with whatever calling convention you are using. StdCall and the rest also expect you to save/restore your registers. The overall idea is to minimize the size of your programs by centralizing the saving/restoring of used registers to the procedure instead of having the programmer who uses those procedures to know which registers the procedure is using and push&#039;ing them each time the procedure is called and pop&#039;ing them off after the procedures execution or taking the slightly cheaper approach and using pushad/popad before and after each routine.<br /><br /><div class="quote"><br />Does anyone have a definitive reference regarding these registers being preserved for Linux, OS X, and/or FreeBSD. I can&#039;t find anything and there is nothing mentioned in the FreeBSD Developer&#039;s Handbook which has a large-ish Assembly section.</div><br /><br />The FreeBSD handbook&#039;s assembly section doesn&#039;t really cover much and most of the calls it makes are to the system&#039;s IDT in which case variables will get trashed all the time. Check out the Agner docs which where posted by drizz, it is a much better resource for learning calling conventions.<br /><br /><div class="quote"><br />Also it seems &quot;ret&quot; is not sufficient to exit a program from OS X. It is necessary to have<br /><br /><pre><code><br />&nbsp; push 1<br />&nbsp; sub esp, 4<br />&nbsp; int 0x80<br /></code></pre><br /><br />Thanks,<br />Peter<br /></div><br /><br />That&#039;s right. FreeBSD and OSX both require a 4-byte padding between the call and the arguments to IDT calls. A common method on FreeBSD is to call a procedure containing nothing but the int 0x80 call which pushes EIP onto the stack to act as a padding and uses it afterwords to return to the original call.<br /><br /><pre><code>msg	db &quot;Hello World!&quot;<br />msg_len	dd $-msg<br /><br />bsd_kernel:<br />	int 0x80<br />	ret<br /><br />hello_world:<br />	push 	; length of message<br />	push msg	; address of message<br />	push 1		; write to standard output<br />	push 4		; kernel function `write&#039;<br />	call bsd_kernel	; send the interrupt<br /><br />	push 0		; error code for application<br />	push 1		; kernel function `exit&#039;<br />	call bsd_kernel	; send the interrupt</code></pre><br /><br />On a lot of systems you can simply call `ret&#039; but that&#039;s because your program&#039;s procedure is being called from a startup routine which the C compiler you link it with has put in place. When doing assembly and linking without the C compiler (or using the -nostartfiles option) your procedure must make the call to the system `exit&#039; routine itself instead of using ret to return to the startup routine provided by your compiler.<br /><br /><div class="quote"><br />If you want to be completely sure Peter, you can install both of these systems and test it yourself with a debugger (like gdb).<br />Call a few APIs consecutively and watch the registers in the debugger.</div><br /><br />I do agree that if you are building applications for a system you should do so on that system. But setting up multi-boot or anything like that is not needed. Most Linux and FreeBSD distributions can be installed into .bin files and ran through QEmu with very little overhead. I have a Linux distro installed into a flat binary file on a USB disk with QEmu setup to auto-run when the drive is detected. All I have to do is plug the drive in a USB port and it&#039;ll open the OS up in full screen (and I use Ctrl+Alt to switch between my Windows OS and the Linux OS). It&#039;s actually pretty convenient when paired with &quot;persistent mode&quot; distributions.<br /><br />Side Note: I do now have a separate netbook with Linux installed on it, but I still use the USB version for doing cross platform development so that I don&#039;t have to switch computers.<br /><br />I also don&#039;t believe in the idea of using debuggers and disassemblers to learn assembly. I have admitted in the past that was how I learned, but honestly have you seen my code? It teaches horrible coding practices which I myself have trouble avoiding and is the reason many people call my source files `unreadable&#039; and `obfuscated&#039;. Learn programming from manuals, books, and tutorials. They have a lot more to offer than debugging and disassembling.<br /><br /><div class="quote"><br />And by the way, the C convention is very good for 32 bit systems. IMO it&#039;s better than stdcall since you can regroup stack cleanup with add esp, 4*x<br /></div><br /><br />Personally I like stdcall. I don&#039;t like having to clean up the stack after every procedure. It&#039;s okay for things like printf where variable length arguments are required but since those routines are far and few between stdcall just seems more practical.</div>
    <div class="meta">Posted on 2009-08-09 00:02:39 by Synfire</div>
   </div>
   <div class="post" id="post-208412">
    <div class="subject"><a href="#post-208412">Re: Duntemann, Linux, and The C Calling Convention</a></div>
    <div class="body"><div class="quote"><br />The C Calling convention does not clean up the stack for you but it does specify that  registers will not be trashed when a procedure is called. Ecx and Eax however are almost guaranteed to be trashed and you should not expect them to be the same after a C function call. So when writing procedures which interface with C programs you should always save those registers otherwise your C program might break.<br /></div><br /><br />That is the general gist that I understood. The uncomfortable part is this C Calling Convention seems to be mostly floating around in the ether. Sometimes I see ESP as one of the &quot;sacred&quot; registers. Sometimes it is not listed.<br /><br /><br /><div class="quote"><br />Check out the Agner docs which where posted by drizz, it is a much better resource for learning calling conventions.<br /></div><br /><br />Even those docs don&#039;t make me feel like I&#039;m reading something official. It is still all a little folklore-ish.<br /><br /><br /><div class="quote"><br />On a lot of systems you can simply call `ret&#039; but that&#039;s because your program&#039;s procedure is being called from a startup routine which the C compiler you link it with has put in place. When doing assembly and linking without the C compiler (or using the -nostartfiles option) your procedure must make the call to the system `exit&#039; routine itself instead of using ret to return to the startup routine provided by your compiler.<br /></div><br /><br />Thanks. I think connects some information I read in Advanced Programming in the UNIX Environment with this exit business. I think the startup routine you are describing lives in libc, correct?<br /><br />Peter<br /></div>
    <div class="meta">Posted on 2009-08-09 00:34:47 by petermichaux</div>
   </div>
   <div class="post" id="post-208415">
    <div class="subject"><a href="#post-208415">Re: Duntemann, Linux, and The C Calling Convention</a></div>
    <div class="body">Oh Peter, you can be sure Agner Fog knows what he&#039;s talking about.<br />Did you also see this page :<br />http://en.wikipedia.org/wiki/X86_calling_conventions<br /><br />Synfire : Of course when I meant installing, I really meant to use Virtual Machines haha. I never want to have to touch anything GRUB-related again&nbsp; :P<br />I&#039;ve heard a lot of good things about QEMU / KVM. Here I just use VMWARE but that might change very soon !<br />A friend gave me the following commands when using qemu kvm.<br /><br /><pre><code>qemu-kvm -m 512 -cdrom atrolinux.iso<br />qemu-kvm -m 512 -no-acpi&nbsp; -cdrom winxp.iso -hda winxp.img -boot d<br />dd if=/dev/sr0 of=winxp.iso<br />qemu-img create -f qcow winxp.img 6G<br />qemu-kvm -m 512&nbsp;  -hda winxp.img -cdrom /dev/sr0 -localtime</code></pre></div>
    <div class="meta">Posted on 2009-08-09 16:27:04 by ChaperonNoir</div>
   </div>
   <div class="post" id="post-208416">
    <div class="subject"><a href="#post-208416">Re: Duntemann, Linux, and The C Calling Convention</a></div>
    <div class="body"><div class="quote">It seems to me an operating system that depends on application programmers following a convention would be an operating system that crashes frequently. ;-)</div><br />If an app messes the stack, that app is terminated. This is true for almost every OS I&#039;ve seen. I don&#039;t know why the OS should be the one to crash? ^^ Maybe in DOS/win9x times you could BSOD an OS with a shitty code but those times are long since gone.</div>
    <div class="meta">Posted on 2009-08-09 17:08:41 by ti_mo_n</div>
   </div>
   <div class="post" id="post-208432">
    <div class="subject"><a href="#post-208432">Re: Duntemann, Linux, and The C Calling Convention</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br />Check out the Agner docs which where posted by drizz, it is a much better resource for learning calling conventions.<br /></div><br />Even those docs don&#039;t make me feel like I&#039;m reading something official. It is still all a little folklore-ish.<br /></div><br />You probably won&#039;t find much official documentation for something that isn&#039;t officially supported/recommended :). Remember that the systems are written by and for C programmers, and are portable across a relatively wide range of systems; writing official assembly documentation for each systems, and keeping it up to date, probably seems like a bit too much work when it&#039;s expected that almost everybody will be using the official C interfaces.<br /><br />That said, I do believe the ABI should be officially documented for each supported platform.</div>
    <div class="meta">Posted on 2009-08-13 09:18:34 by f0dder</div>
   </div>
   <div class="post" id="post-209462">
    <div class="subject"><a href="#post-209462">Re: Duntemann, Linux, and The C Calling Convention</a></div>
    <div class="body">Google &quot;Intel ABI&quot; - that&#039;s the &quot;official name&quot;, AFAIK. I consider it somewhat misleading, since the hardware doesn&#039;t care, but if you want to interface with any other language (not just C), you need to do it.<br /><br />Why would Duntemann lie? I even happen to know how he learned it. When upgrading from the first edition to the second (Third Edition is recently published), he found an old Linux example that no longer worked. He posted it to a.l.a. (or c.l.a.x. perhaps). Someone - I think it was H. Peter Anvin (maintainer of the x86 port of Linux... plus Nasm) who spotted that he hadn&#039;t preserved ebx. Apparently his old kernel &quot;didn&#039;t care&quot;, but the new one did. So if you want your programs to keep running, do it - even if some kernel/library version &quot;doesn&#039;t care&quot;.<br /><br />If it&#039;s &quot;all your own code&quot;, you can do whatever you like - but don&#039;t try to &quot;ret&quot; without esp being correct. That one, the hardware does care about!<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2009-11-02 16:25:32 by fbkotler</div>
   </div>
  </div>
 </body>
</html>