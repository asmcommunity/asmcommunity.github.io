<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Case Study: Projection Transformation - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30911" />
  <link rel="prev" href="../?id=30911&amp;page=1" />  <link rel="next" href="../?id=30911&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=30911">Case Study: Projection Transformation</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=30911&amp;page=1" style="">&laquo;</a><a href="../?id=30911&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="30911" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=30911&amp;page=3">&gt;</a><a href="../?id=30911&amp;page=3">&raquo;</a></form>   <div class="post" id="post-216151">
    <div class="subject"><a href="#post-216151">Re: Case Study: Projection Transformation</a></div>
    <div class="body"><div class="quote"><br />You cannot show more than one object with &#039;four instructions&#039;. So it wont work for anything other than a very simple demo drawing one model space.</div><br /><br />We are discussing vertex shaders here.<br />Obviously the matrices (like many other variables) need to be updated for different objects between draw calls.<br />That doesn&#039;t mean that you need more than four instructions *inside* the vertex shader. This has nothing to do with the number of objects being drawn.<br />We are talking per-vertex operations vs per-object operations here. Since the frequency of per-vertex operations is a lot higher than that of per-object operations, it is clear that the per-vertex case is where most of the savings should be done.<br /><br /><div class="quote"><br />Don&#039;t try to talk s***. You need a unique modelspace transform for every instance of a geometry. You know that you can&#039;t just send one WorldViewProj for everything. Let alone we talk about things like lighting and shadowing, which you obviously think are all best done in viewspace. Seriously man, you can&#039;t just send one matrix and call it a day. Jeez.<br />And thats using ONE shader! If we have more than one shader, there&#039;s no guarantee that uniforms will be stateful, we need to re-transmit them when shaders switch!<br /></div><br /><br />Wow, getting touchy, are we?<br />Anyway, all this hollow rhetoric aside: you still need to provide an example that shows that you are actually saving processing power.<br />Also, don&#039;t accuse me of things I never said. I never said you can use one matrix for everything (merely that you only need one matrix at a time in the simplest case, like that of your perspective example... Besides, one can argue that you still don&#039;t need to perform matrix*matrix operations inside the vertex shader in many cases even if you do need multiple matrices. As long as the source matrices are static for the entire draw call, then so are the results of the multiplications, and as such they can be precalced and sent as extra shader constants... Or, failing that, you may be able to do mat*(mat*vec) rather than (mat*mat)*vec, still saving you from doing a full matrix multiply).<br />I also never said that things are best done in viewspace. I have absolutely no idea where viewspace came from here.<br /><br />Also, with D3D10+ we do have the guarantee that such data is stateful. I believe there are some recent OpenGL extensions for uniform buffers that do the same.</div>
    <div class="meta">Posted on 2012-08-08 08:27:26 by Scali</div>
   </div>
   <div class="post" id="post-216152">
    <div class="subject"><a href="#post-216152">Re: Case Study: Projection Transformation</a></div>
    <div class="body">I apologise for my bad mood yesterday, you didn&#039;t deserve that. I&#039;m human and under a lot of pressure (work related), I have no good excuse so please disregard. I am not proud of my outburst.<br /><br />GL extensions tend not to be well supported across the board, as by their nature, they are not, at least yet, &#039;core&#039; functionality, it tends to differ from vendor to vendor.<br /><br />All truth passes through three stages. First, it is ridiculed. Second, it is violently opposed. Third, it is accepted as being self-evident.<br /><br />Shader multiplication, whether on the cpu or gpu, requires a crapload of mul operations, 16 from memory.<br />But that&#039;s not actually the problem I was alluding to.<br /><br />The problem, in my mind, is not the speed of muls in the gpu, its the gpu bus, we need to send data that is changing, and by reducing that to a fraction of its former self, we stand to win, and that would still be the case even if the gpu had to work harder, this is an acknowledgement of their complimentary parallel nature, nothing more.<br /><br />If we can reduce the bus traffic AND the number of operations (on either side of the fence), so much the better, this is not a formal proof granted, but you should be able to smell the win on the bus issue alone.<br /><br />With regards to statefulness of opengl shader uniforms, this is a thorny issue, the specs state somewhere that they are stateful, and somewhere else mention that this state exists until the shader changes. Some implementations do keep uniform state per shader, some do not, and there is no concensus, so we should assume they won&#039;t survive a shader switch, and have to send them per shader, per frame, all of them.</div>
    <div class="meta">Posted on 2012-08-09 03:21:52 by Homer</div>
   </div>
   <div class="post" id="post-216153">
    <div class="subject"><a href="#post-216153">Re: Case Study: Projection Transformation</a></div>
    <div class="body"><div class="quote"><br />GL extensions tend not to be well supported across the board, as by their nature, they are not, at least yet, &#039;core&#039; functionality, it tends to differ from vendor to vendor.</div><br /><br />If I&#039;m not mistaken, it is this extension: http://www.opengl.org/wiki/Uniform_Buffer_Object<br />It is core functionality in OpenGL 4.3, which afaik both nVidia and AMD already have drivers for (and they supported it as an extension in earlier drivers already).<br /><br /><div class="quote">All truth passes through three stages. First, it is ridiculed. Second, it is violently opposed. Third, it is accepted as being self-evident.</div><br /><br />Ah, more hollow rhetoric.<br /><br /><div class="quote"><br />Shader multiplication, whether on the cpu or gpu, requires a crapload of mul operations, 16 from memory.</div><br /><br />As I say, mat4x4*vec4 is 4 operations (either through dot4 instructions or multiply-add, depending on the orientation).<br />mat3x4*vec can be done with only 3.<br /><br />So even if you need 2 matrices, that would only be 6 to 8 instructions if you do mat*(mat*vec) as I said before.<br /><br /><div class="quote">The problem, in my mind, is not the speed of muls in the gpu, its the gpu bus, we need to send data that is changing, and by reducing that to a fraction of its former self, we stand to win, and that would still be the case even if the gpu had to work harder, this is an acknowledgement of their complimentary parallel nature, nothing more.<br /><br />If we can reduce the bus traffic AND the number of operations (on either side of the fence), so much the better, this is not a formal proof granted, but you should be able to smell the win on the bus issue alone.<br /></div><br /><br />And you&#039;d be painfully wrong.<br />4x4 Matrices are only 64 bytes. You&#039;d need a LOT of matrices before you&#039;d ever get into bandwidth problems, many more than you could store in the constant registers on the GPU in the first place.<br />The PCI/AGP/PCI-e buses work with burst transfers. The real overhead is in setting up a transfer, which means that you get the first few hundreds of bytes &#039;for free&#039;. Much like how rendering 1 triangle is not faster than rendering 1000 triangles on a T&amp;L-capable GPU. It&#039;s purely the overhead at that point, not the actual transfer/processing speed.<br /><br />So saving a few bytes on some matrices is not going to earn you much, if anything at all. You may save a handful of bytes that you may have gotten &#039;for free&#039; anyway. In return, you need to put in extra GPU time on EVERY vertex that you process. That is something you WILL notice.<br /><br />You want an example of bus speed? Well I can give you one.<br />With our current work, we are streaming HD-video directly to a texture. At 720p50 that is 1280x720 32-bit pixels, 50 times a second. So 1280*720*4*50 == 175 MB/s streaming through the bus.<br />Or at 1080p30 that is 1920*1080*4*30 == 237 MB/s.<br />I can easily do this in realtime, while the renderer maintains a framerate of well over 1000 fps, even on a mainstream videocard like a Radeon HD5770 or GeForce GTX460.<br /><br />Now, 237 MB/s, that is 3.7 million(!) 64-byte matrices per second. And you&#039;re telling me that this is where savings should be done? Nope.<br /><br />More sensible places for saving bandwidth would be the vertex data, or texture compression. Those require considerably more bandwidth because they are processed per-vertex or even per-pixel. So savings make more sense there. The data is also much larger than your matrix data, so you may even be able to save a considerable amount of videomemory, allowing you to use more geometry/texture data before having to spill out into system memory.</div>
    <div class="meta">Posted on 2012-08-09 03:40:50 by Scali</div>
   </div>
   <div class="post" id="post-216154">
    <div class="subject"><a href="#post-216154">Re: Case Study: Projection Transformation</a></div>
    <div class="body">My current game has 36 shaders, and each one of them takes three separate matrices (I could reduce to two, but at the cost of some cpu muls which become a new bottleneck), amounting to a crapload of uploading, per shader, per frame. I can cut that down to about 25 percent, with some caveats, like, eliminating scale from world transform. Then on the gpu, the number of operations required for the same linear operational series is similarly reduced, and the framerate in my early tests is definitely showing that.<br /><br />I would certainly go along with your comments about thin vertex data, but there&#039;s not a whole lot we can do there, this is a place where we can make &#039;some&#039; impact, which reflects positively on our framerate, and gives us a competitive advantage, for really, not much effort. It might not seem much to you.<br /><br />The less shaders you have, the less you stand to gain. If you have one shader, this will all be nonsense to you.<br /></div>
    <div class="meta">Posted on 2012-08-09 04:56:43 by Homer</div>
   </div>
   <div class="post" id="post-216155">
    <div class="subject"><a href="#post-216155">Re: Case Study: Projection Transformation</a></div>
    <div class="body"><div class="quote"><br />My current game has 36 shaders, and each one of them takes three separate matrices (I could reduce to two, but at the cost of some cpu muls which become a new bottleneck), amounting to a crapload of uploading, per shader, per frame. I can cut that down to about 25 percent, with some caveats, like, eliminating scale from world transform. Then on the gpu, the number of operations required for the same linear operational series is similarly reduced, and the framerate in my early tests is definitely showing that.</div><br /><br />Well, my skinning code used a matrix palette of 14 matrices to render the claw animation (alongside 2 other matrices and other lighting/material information). And that code can easily render at 8000+ fps on a modern system. In other words: at a framerate of 60 fps, you could render about 133 objects with 16 matrices (probably more, because my 8000 fps include the overhead of starting/ending each renderpass, presenting and clearing the backbuffer etc).<br />So I really don&#039;t see how 3 matrices would be troublesome.<br /><br /><div class="quote"><br />The less shaders you have, the less you stand to gain. If you have one shader, this will all be nonsense to you.<br /></div><br /><br />I beg to differ. It is not about the number of shaders, but about how often you update the constants. Even if you use the same shader for all objects, you might still need to update matrices and material/light information in the shader for each object.<br />The only thing you&#039;d save would be the changing of the shader itself (but that does not apply to this discussion of matrices vs other types of shader constants).<br />And you&#039;d only need 2 shaders to lose that advantage. Whether you ping-pong between 2 shaders all the time, or switch between 36 shaders, or however many, doesn&#039;t really matter.</div>
    <div class="meta">Posted on 2012-08-09 06:12:07 by Scali</div>
   </div>
   <div class="post" id="post-216156">
    <div class="subject"><a href="#post-216156">Re: Case Study: Projection Transformation</a></div>
    <div class="body">Yep, 2 or 200, if theres more than one, then we need to deal with state.<br />Sometimes, on some drivers, we don&#039;t. Per shader.<br />But we have to cater to the typical, usual, case where uniforms are statefule ONLY for the &#039;lifetime&#039; of a shader.<br />That sucks, but its the way it is, I do my best to contend with this kind of state flapping.<br />OpenGL is not really good at statefulness, the more useless state changes you avoid in cpu land, the less redundant opengl calls you make, and that too, adds up, and if you say it shouldnt matter, I will agree!</div>
    <div class="meta">Posted on 2012-08-09 07:54:42 by Homer</div>
   </div>
   <div class="post" id="post-216157">
    <div class="subject"><a href="#post-216157">Re: Case Study: Projection Transformation</a></div>
    <div class="body"><div class="quote"><br />But we have to cater to the typical, usual, case where uniforms are statefule ONLY for the &#039;lifetime&#039; of a shader.<br />That sucks, but its the way it is, I do my best to contend with this kind of state flapping.<br />OpenGL is not really good at statefulness, the more useless state changes you avoid in cpu land, the less redundant opengl calls you make, and that too, adds up, and if you say it shouldnt matter, I will agree!<br /></div><br /><br />Well, I got the 8000+ fps without using any kind of stateful shader constant trickery. Just vanilla DX9 and OpenGL 2.0 code.<br />The code had 3 different objects, using 2 different kinds of vertex shaders, and each having their own object space. So there were basically 3 shader changes + full state updates per frame, where one of the shaders had 16 matrices. And all that still at 8000+ fps, on a mainstream Core2 Duo 3 GHz and GeForce GTX460. Not a fancy modern CPU and high-end GPU.<br /><br />So I say: not a problem with shader state changes.<br /><br />Anyway, the OpenGL renderer is fully opensource... so.</div>
    <div class="meta">Posted on 2012-08-09 08:42:33 by Scali</div>
   </div>
   <div class="post" id="post-216158">
    <div class="subject"><a href="#post-216158">Re: Case Study: Projection Transformation</a></div>
    <div class="body">Lately, I&#039;m not working on my high end machines, I am coding for phones, so we are JUST above the baseline and BARELY have a shader engine, and the cpu is WAY slower than the gpu is, in this circumstance, all the things I have said will ring true, perhaps not AS relevant for modern gear, but still a measurable improvement, I checked after you posted, I did get a benefit on my GL3.3 engine, I didn&#039;t try on 4+<br />My goals at the moment, involve porting high end shaders to old shadertongue, and make them run at an acceptable rate, so I&#039;m pretty stoked about all these developments. <br /></div>
    <div class="meta">Posted on 2012-08-09 09:00:01 by Homer</div>
   </div>
   <div class="post" id="post-216159">
    <div class="subject"><a href="#post-216159">Re: Case Study: Projection Transformation</a></div>
    <div class="body">Well, I ported my OpenGL code to iPhone and Android as well, and it could easily reach 60 fps. Sadly there doesn&#039;t seem to be a way to disable vsync, so there&#039;s no easy way to find out how fast it can REALLY render.<br />Mind you, even my Athlon XP1800+ with Radeon 9600 could still reach about 700 fps on that code, and that&#039;s a box that is more than 10 years old, probably actually slower than a modern phone.<br /><br />But well, feel free to post some actual code, so that we can compare and perhaps even optimize some stuff.<br /><br />Edit: Oh in fact, it gets worse!<br />I just remembered that I ran it on the PII-350 with Radeon 8500 a while ago:<br />http://www.asmcommunity.net/board/index.php?topic=29617.210<br /><br />That one still gets 375 fps. Now I *know* that thing is slower than a modern phone.</div>
    <div class="meta">Posted on 2012-08-09 09:27:47 by Scali</div>
   </div>
   <div class="post" id="post-216161">
    <div class="subject"><a href="#post-216161">Re: Case Study: Projection Transformation</a></div>
    <div class="body">As mentioned, I&#039;m not actually developing on a GLES-compliant platform - I&#039;m using that PowerVR wrapper to emulate GLES2 for alpha development, so I can indeed disable vsync and get some kind of idea of performance (although not a true indication, at least I can determine where bottlenecks are since the underlying infrastructure is either the same or close enough).<br />I can at least get a feeling for whether some implementation is a bad idea or a good idea by comparison.<br /><br />I&#039;m now looking at compressing tangent space information per vertex with a single quaternion representing the three orthonormal vectors, if I can solve one issue relating to the handedness of the basis transforms.<br />Since this transform changes per vertex, there&#039;s no value in using matrices.<br /><br />The issue at hand is that modelling apps don&#039;t seem to do a good job of ensuring that the handedness of the tangentspace basis for each vertex of a given face is the same - this gives us a headache when we try to interpolate them and then use the interpolated tangentspace vectors in the fragmentshader... not a problem for simple texturing, but a problem for lighting of bumpmapped geometry (especially when skinned as well).<br /></div>
    <div class="meta">Posted on 2012-08-11 00:08:10 by Homer</div>
   </div>
   <div class="post" id="post-216162">
    <div class="subject"><a href="#post-216162">Re: Case Study: Projection Transformation</a></div>
    <div class="body">Well, I suppose one way to measure it is to just skip the glSwapBuffers() call. So you render everything, but just don&#039;t display it on screen.<br />I&#039;ll have to try that and see.<br /><br />At any rate, the Pentium II I mentioned only has an AGP 2x bus, so it has considerably less bandwidth than a modern system. It has a theoretical limit of 533 MB/s.<br />A modern PCI-e 2.0 16x bus has a theoretical limit of more than 8 GB/s.<br />I&#039;m not sure what the bus speed is between the CPU and GPU of a modern smartphone/tablet SoC, but I bet it&#039;s more than AGP 2x.<br /><br />As for modeling... at the time I wrote my BHM exporter for 3dsmax, I don&#039;t think there was a way to get tangentspace information from the modeler at all. So I calculated tangentspace myself, in the exporter. As a result, I never had any issues with that in the first place.<br />I&#039;ve also done an experiment with calculating the tangentspace in the geometry shader.</div>
    <div class="meta">Posted on 2012-08-11 06:02:31 by Scali</div>
   </div>
   <div class="post" id="post-216163">
    <div class="subject"><a href="#post-216163">Re: Case Study: Projection Transformation</a></div>
    <div class="body">If you call glFlush instead of glSwapBuffers, I guess it&#039;s a fair appraisal?<br />That way the gpu needs to actually complete processing, artificially stalling the cpu until its done?</div>
    <div class="meta">Posted on 2012-08-11 06:51:46 by Homer</div>
   </div>
   <div class="post" id="post-216164">
    <div class="subject"><a href="#post-216164">Re: Case Study: Projection Transformation</a></div>
    <div class="body">Hum, it was not quite as simple as that on Android, since you don&#039;t call glSwapBuffers() yourself.<br />Instead, you implement a &#039;Renderer&#039; object, which has an OnDrawFrame() callback, where the rest is done by the Android framework itself, in which you register your Renderer.<br /><br />Well, I did a quick hack where I just implement my own loop inside the OnDrawFrame(), so it never leaves the callback to get to the glSwapBuffers() call (or whatever equivalent they may use).<br />And the result is that instead of 60 fps, I now get well over 100 fps.<br />The actual framerate seems to be incredibly jumpy, probably because this is not how the framework should be working, and it probably will be doing stuff in the background... But it seems to average at around 160 fps, with peaks of 233 fps.<br />So at the very least it&#039;s a rough indication of the actual performance.</div>
    <div class="meta">Posted on 2012-08-11 06:56:57 by Scali</div>
   </div>
   <div class="post" id="post-216165">
    <div class="subject"><a href="#post-216165">Re: Case Study: Projection Transformation</a></div>
    <div class="body">I guess thats the best we can hope for in this new fangled stuff, it&#039;s not made for our kind of programmer and I&#039;m not sure who they are aiming for anymore, I just deal with the fallout.</div>
    <div class="meta">Posted on 2012-08-13 04:41:14 by Homer</div>
   </div>
   <div class="post" id="post-216166">
    <div class="subject"><a href="#post-216166">Re: Case Study: Projection Transformation</a></div>
    <div class="body"><div class="quote"><br />I guess thats the best we can hope for in this new fangled stuff, it&#039;s not made for our kind of programmer and I&#039;m not sure who they are aiming for anymore, I just deal with the fallout.<br /></div><br /><br />I know what you mean, I stopped worrying about that sort of thing. I only have 2 choices anyway:<br />1) I use their platform<br />2) I don&#039;t use their platform<br /><br />In general Android isn&#039;t that bad, once you&#039;ve ironed out the initial kinks. And having vsync enabled by default is not bad either. Just makes it harder to benchmark during development :)</div>
    <div class="meta">Posted on 2012-08-13 08:39:49 by Scali</div>
   </div>
   <div class="post" id="post-216248">
    <div class="subject"><a href="#post-216248">Re: Case Study: Projection Transformation</a></div>
    <div class="body"><div class="quote"><br />Okay, work out the math and post it here, then we&#039;ll see how many instructions it takes. I&#039;d be surprised if you can come up with a solution with less than 4 instructions.<br /></div><br /><br />No code was ever produced.<br />The validity of your claims of doing manual perspective being more efficient is still up in the air.<br />Then again, in light of recent developments regarding perspective matrices, I&#039;m not surprised that no code was ever produced...</div>
    <div class="meta">Posted on 2012-09-15 17:52:28 by Scali</div>
   </div>
   <div class="post" id="post-216249">
    <div class="subject"><a href="#post-216249">Re: Case Study: Projection Transformation</a></div>
    <div class="body">Projection Transform implemented as a Vec4 !!<br /><br />Methods taken from my Pure Quaternion Camera class, based on knowledge gained from the journey taken within this thread !!<br />This code was already posted in my Blog, on this site.<br /><br />Credit to Dzmitry Malyshau (kvarkus, author of KRI engine) for proving to me that this is not just possible, but cheaper. He did not show me how to generate the values.<br /><br />Instructions for Vertex Shader authors included !!<br /><br /><pre><code><br />	// This function calculates the Projection Transform data, storing it as a Vec4, to be applied in the VS<br />	//<br />	void Perspective()<br />	{<br />		float ymax, xmax;<br />		float temp, temp2, temp3, temp4;<br />		ymax = m_fNear * tanf(Math::radians(m_fFOVy));<br />		xmax = ymax * m_fAspectRatio;<br />		UpdateProjectionTransform(-xmax, xmax, -ymax, ymax, m_fNear, m_fFar);<br />	}<br /><br /><br />inline void UpdateProjectionTransform(float left, float right, float bottom, float top, float znear, float zfar)<br />	{<br />		float temp, temp2, temp3, temp4;<br />		temp = 2.0 * znear;<br />		temp2 = right - left;<br />		temp3 = top - bottom;<br />		temp4 = zfar - znear;<br />		m_ProjectionValues[0] = temp / temp2;				// X scalar<br />		m_ProjectionValues[1] = temp / temp3;				// Y scalar<br />		m_ProjectionValues[2] = (-zfar - znear) / temp4;	// Z scalar<br />		m_ProjectionValues[3] = (-temp * zfar) / temp4;		// Z translate<br /><br />		// Note for shader programmers: clipspace calculation is as follows:<br />		// Clip.W&nbsp;  = -View.Z<br />		// Clip.XYZ =&nbsp; View.XYZ * Values.XYZ<br />		// Clip.Z&nbsp; +=&nbsp; Values.W<br />	}<br /></code></pre><br /><br /></div>
    <div class="meta">Posted on 2012-09-16 01:55:37 by Homer</div>
   </div>
   <div class="post" id="post-216250">
    <div class="subject"><a href="#post-216250">Re: Case Study: Projection Transformation</a></div>
    <div class="body">That&#039;s not the shader code I asked for.<br />Make something that takes an object-space vertex as input and produces proper output to be forwarded to the rasterizer stage.<br />Then we can run it through the shader compiler and compare its instruction count against a regular vertex shader like this:<br /><pre><code><br />cbuffer cb0<br />{<br />	row_major float4x4 mWorldViewProj;	// World * View * Projection transformation<br />};<br /><br />struct VS_INPUT<br />{<br />	float4 Position	: POSITION;<br />};<br /><br />struct VS_OUTPUT<br />{<br />	float4 Position	: POSITION;		// vertex position <br />};<br /><br />VS_OUTPUT main( in VS_INPUT Input )<br />{<br />	VS_OUTPUT Output;<br />	<br />	Output.Position = mul( Input.Position, mWorldViewProj );<br />	<br />	return Output;<br />}<br /></code></pre><br /><br />This results in the following output:<br /><pre><code><br />//<br />// Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111<br />//<br />//&nbsp;  fxc ProjectionShader.vsh<br />//<br />//<br />// Parameters:<br />//<br />//&nbsp;  row_major float4x4 mWorldViewProj;<br />//<br />//<br />// Registers:<br />//<br />//&nbsp;  Name&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Reg&nbsp;  Size<br />//&nbsp;  -------------- ----- ----<br />//&nbsp;  mWorldViewProj c0&nbsp; &nbsp; &nbsp;  4<br />//<br /><br />&nbsp; &nbsp; vs_2_0<br />&nbsp; &nbsp; dcl_position v0<br />&nbsp; &nbsp; mul r0, v0.y, c1<br />&nbsp; &nbsp; mad r0, v0.x, c0, r0<br />&nbsp; &nbsp; mad r0, v0.z, c2, r0<br />&nbsp; &nbsp; mad oPos, v0.w, c3, r0<br /><br />// approximately 4 instruction slots used<br /></code></pre><br /><br />As I already said earlier: 4 instructions.<br />So, can your code do it in 3 instructions or less?<br /><br />If I understood correctly, this is what you&#039;d need to do for projection alone:<br /><pre><code>cbuffer cb0<br />{<br />	float4 Values;<br />};<br /><br />struct VS_INPUT<br />{<br />	float4 Position	: POSITION;<br />};<br /><br />struct VS_OUTPUT<br />{<br />	float4 Position	: POSITION;		// vertex position <br />};<br /><br />VS_OUTPUT main( in VS_INPUT Input )<br />{<br />	VS_OUTPUT Output;<br />	<br />	Output.Position.w&nbsp;  = -Input.Position.z;<br />	Output.Position.xyz =&nbsp; Input.Position.xyz * Values.xyz;<br />	Output.Position.z&nbsp; +=&nbsp; Values.w;<br />	<br />	return Output;<br />}<br /></code></pre><br /><br />This results in 4 instructions already, and this is not a complete shader, since there is no transform applied to take the input vertex from object space to camera space:<br /><pre><code><br />//<br />// Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111<br />//<br />//&nbsp;  fxc ProjectionShader2.vsh<br />//<br />//<br />// Parameters:<br />//<br />//&nbsp;  float4 Values;<br />//<br />//<br />// Registers:<br />//<br />//&nbsp;  Name&nbsp; &nbsp; &nbsp; &nbsp;  Reg&nbsp;  Size<br />//&nbsp;  ------------ ----- ----<br />//&nbsp;  Values&nbsp; &nbsp; &nbsp;  c0&nbsp; &nbsp; &nbsp;  1<br />//<br /><br />&nbsp; &nbsp; vs_2_0<br />&nbsp; &nbsp; dcl_position v0<br />&nbsp; &nbsp; mad oPos.z, v0.z, c0.z, c0.w<br />&nbsp; &nbsp; mul r0.xy, v0, c0<br />&nbsp; &nbsp; mov oPos.xy, r0<br />&nbsp; &nbsp; mov oPos.w, -v0.z<br /><br />// approximately 4 instruction slots used<br /></code></pre><br /><br />So why exactly did we want to do this again?<br /><br />And while you&#039;re at it, answer my last post about clipping in the D3D pipeline thread as well.</div>
    <div class="meta">Posted on 2012-09-16 03:59:32 by Scali</div>
   </div>
   <div class="post" id="post-216251">
    <div class="subject"><a href="#post-216251">Re: Case Study: Projection Transformation</a></div>
    <div class="body">You can&#039;t just pass in a single WVP matrix unless you only have one object in your world. Therefore you are going to either, pass what changed from the major transforms, and multiply them on the shader, or, multiply and pass from the cpu, which you are omitting to mention (or measure).<br /><br />Here is the ViewSpace to ClipSpace transform, aka Projection matrix stage, without matrices (GLSL shader sourcecode), based on the Vec4 calculated in the previous post.<br /><br />This plaintext forms part of my surfaceshader generator, which takes in a pair of (vertexformat, material) semantics and generates an appropriate shader sourcecode and compiles it. Only what is being used appears in the source, and shader programs can be shared.<br /><br /><pre><code><br />						&quot;//perspective project\n&quot;<br />						&quot;vec4 get_projection(vec3 v, vec4 pr)&nbsp; &nbsp; {\n&quot;<br />						&quot;		return vec4( v.xy * pr.xy, v.z*pr.z + pr.w, -v.z);\n&quot;<br />						&quot;}\n&quot;<br /></code></pre><br /><br />And I challenge you again to show me how to multiply two matrices in 4 operations.<br /><br /></div>
    <div class="meta">Posted on 2012-09-16 04:11:28 by Homer</div>
   </div>
   <div class="post" id="post-216252">
    <div class="subject"><a href="#post-216252">Re: Case Study: Projection Transformation</a></div>
    <div class="body"><div class="quote"><br />You can&#039;t just pass in a single WVP matrix unless you only have one object in your world.</div><br /><br />Ah, I see you know about as much about shaders as you do about clipping...<br />What nonsense is this? Especially since we&#039;ve already disucssed it earlier.<br />At any time during the execution of the shader, you are rendering a single object.<br />You simply update the matrices between objects. Or how exactly did you propose to do it? Stuff the matrices for all objects into the shader at once, and use some kind of index field in the vertices?<br /><br /><div class="quote"> Therefore you are going to either, pass what changed from the major transforms, and multiply them on the shader, or, multiply and pass from the cpu, which you are omitting to mention.</div><br /><br />I omit to mention it because it&#039;s supposed to be common knowledge. It is also completely irrelevant.<br />Yes, you update shader constants between draw calls. That&#039;s the same for all shaders.<br /><br />And as I said in the previous post, that code takes 4 instructions alone. So how is that better than the normal approach, where you have 4 instructions for objectspace to clipspace, rather than just viewspace to clipspace?<br /><br /><div class="quote"><br />And I challenge you again to show me how to multiply two matrices in 4 operations.</div><br /><br />I don&#039;t NEED to multiply two matrices. I fail to see the relevance of this question.<br /><br />Also: answer the D3D Pipeline thread. Why do the clipped triangles have more vertices?</div>
    <div class="meta">Posted on 2012-09-16 04:24:50 by Scali</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=30911&amp;page=1" style="">&laquo;</a><a href="../?id=30911&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="30911" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=30911&amp;page=3">&gt;</a><a href="../?id=30911&amp;page=3">&raquo;</a></form>  </div>
 </body>
</html>