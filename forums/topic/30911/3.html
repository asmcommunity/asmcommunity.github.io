<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Case Study: Projection Transformation - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30911" />
  <link rel="prev" href="../?id=30911&amp;page=2" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=30911">Case Study: Projection Transformation</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=30911&amp;page=1" style="">&laquo;</a><a href="../?id=30911&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="30911" /><input type="number" name="page" min="1" max="3" step="1" value="3" onchange="this.form.submit();" /></form>   <div class="post" id="post-216253">
    <div class="subject"><a href="#post-216253">Re: Case Study: Projection Transformation</a></div>
    <div class="body">If you had two mesh object instances, you would need to multiply matrices.<br />Period.<br /></div>
    <div class="meta">Posted on 2012-09-16 04:27:50 by Homer</div>
   </div>
   <div class="post" id="post-216254">
    <div class="subject"><a href="#post-216254">Re: Case Study: Projection Transformation</a></div>
    <div class="body"><div class="quote"><br />If you had two mesh object instances, you would need to multiply matrices.<br />Period.<br /></div><br /><br />Because you say so?<br />This makes no sense whatsoever.<br />What do you even mean by &#039;two mesh object instances&#039; in this context?<br />Besides, I already mentioned (mat*mat)*vec vs mat*(mat*vec) earlier.<br />It sounds like you don&#039;t grasp basic matrix math.<br />As always: produce example code if you want to show something.<br /><br />Heck, this whole thread is ridiculous. &quot;Case study&quot;... Pah! Could you get any more pretentious?<br />&quot;Projection can be done without matrices!&quot;. No s***, Sherlock!<br />Then you come up with some code that uses 4 constants.<br />Wow, what a surprise!<br />Seeing as the average projection matrix looks like this (http://msdn.microsoft.com/en-us/library/windows/desktop/bb205351(v=vs.85).aspx):<br /><pre><code>xScale&nbsp; &nbsp;  0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0<br />0&nbsp; &nbsp; &nbsp; &nbsp; yScale&nbsp; &nbsp; &nbsp;  0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0<br />0&nbsp; &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; &nbsp; zf/(zn-zf)&nbsp; &nbsp; &nbsp; &nbsp; -1<br />0&nbsp; &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; &nbsp; zn*zf/(zn-zf)&nbsp; &nbsp; &nbsp; 0</code></pre><br />Hey look! Only 5 of these values are non-zero in the first place! And one of them is -1, which we can easily replace with a subtraction. So that&#039;s only 4 constants left! Wow, amazing that this can be done with a float4 constant!<br />What an amazing conclusion to a fascinating case study!<br />I bow down to your greatness, Homer!<br />I can&#039;t wait until you also explain how you can clip polygons without actually clipping them, but just doing a division by w!</div>
    <div class="meta">Posted on 2012-09-16 04:38:04 by Scali</div>
   </div>
   <div class="post" id="post-216257">
    <div class="subject"><a href="#post-216257">Re: Case Study: Projection Transformation</a></div>
    <div class="body">Wow, you understood it.<br /><br />You do realize this is not the only one, but it is the one I chose for my explanation in my blog, as it is the easiest to understand.<br />But they all produce the same output variables.<br /><br />Our total saving?<br /><br />Projection Matrix, 75%<br /><br />View Matrix, 50%<br /><br />World Matrix, 50%<br /><br />we used 41.6 % gpu bus width and slightly less hw ops on the gpu.<br /><br /><br />We can do something similar for the world and view transforms, if we accept that we can eliminate scale and shear from the transforms, so there is only rotation and translation.<br />They can be passed as 2xVec4, and although the math for the transformations through three spaces is roughly equivalent, we benefit in two ways - 1: we get the partials (world*view for example) and we get less data sent across the gpu bus, which is quickly becoming the worst bottleneck.<br /><br />This especially suits bone transforms, since we can (usually) be sure that they don&#039;t contain any scale keys.<br /><br /></div>
    <div class="meta">Posted on 2012-09-18 04:39:10 by Homer</div>
   </div>
   <div class="post" id="post-216258">
    <div class="subject"><a href="#post-216258">Re: Case Study: Projection Transformation</a></div>
    <div class="body"><div class="quote"><br />Wow, you understood it.</div><br /><br />Well obviously. My very first post was already pointing out the triviality of matrix operations being just another notation for linear operations. Then I tried to gently point out that anyone who understands basic matrix/vector algebra will implicitly also know how to do all that math without matrices and vectors.<br />Obvious math is obvious, it&#039;s right there: http://en.wikipedia.org/wiki/Matrix_multiplication#Matrix_product_.28two_matrices.29<br />Usually these basics of matrix mathematics are taught in highschool or at least first year college. You never finished school or something, Homer? For people who did, everything you said in this thread was painfully obvious, and warranted no &#039;case study&#039; of any kind.<br />Even for people who haven&#039;t finished school, this would be one of the first things they&#039;d learn when they were to start with 3d graphics programming (back in the late 80s/early 90s, a lot of 3d demos were written by guys who were only 16-18 years of age. And they did all this on systems without FPUs as well, requiring a deeper understanding in order to maintain precision, stability and performance. I recently wrote some 3d routines on Amiga and 16-bit x86 myself to see if I &#039;still had it&#039;. Apparently I do).<br /><br /><div class="quote"><br />Our total saving?<br /><br />Projection Matrix, 75%<br /><br />View Matrix, 50%<br /><br />World Matrix, 50%</div><br /><br />Again, produce code so that these savings can be verified.<br /><br /><div class="quote"><br />we used 41.6 % gpu bus width and slightly less hw ops on the gpu.</div><br /><br />That&#039;s funny, since a few posts ago I pointed out that you&#039;d actually need 3-4 EXTRA instructions on the GPU (by actually comparing matrix-based objectspace-to-clipspace code with your cameraspace-to-clipspace code).<br /><br />Aside from that, your comparison is flawed, because you only look at the matrices individually, and ignore any other shader variables.<br />Namely:<br />- A single matrix takes 64 bytes<br />- You claim 16 bytes for projection and 32 bytes for view and model each, so a total of 80 bytes.<br />- If we were to send a single model*view*projection matrix, it is still 64 bytes, which is actually 16 bytes <strong>*smaller*</strong> than your example. It would also require less instructions in the shader, as I already demonstrated earlier by comparing two shaders and looking at the generated instructions by the compiler.<br />Your approach gives up the flexibility of multiplying all matrices together. We&#039;ve already seen that you cannot combine the projection with other operations, and the same will probably go for view and world, if you would ever produce code for them.<br /><br /><div class="quote"><br />gpu bus, which is quickly becoming the worst bottleneck.</div><br /><br />Not at all.<br />Firstly, I already pointed out that a few bytes more or less are not an issue whatsoever (by using actual figures from practical code tests). Modern systems have oodles of bandwidth. Saving a few bytes on a bus that can handle a few GB/s isn&#039;t going to do much.<br />Secondly, you wrongly assume that the GPU bus is the only overhead.<br />The REAL overhead is in the communication between your application and the driver, in handing over the data.<br />Updating shader variables has such high overhead that a few extra instructions on the CPU and a few more bytes transferred are hidden entirely (burst transfers and all that).<br />Having said that, in any reasonable scenario it should still be the general CPU and GPU code that should form the bottlenecks, not so much the actual API calls/data transfer between CPU/GPU. As demonstrated by my examples of a skinned model on a PII 350 and an Android phone.<br /><br />Aside from that, your logic is flawed since it breaks some basic rules of optimization:<br />Move as much workload out of the innerloop as possible.<br />Namely, even if we assume that we can win some time by sending less data to the GPU, this isn&#039;t meaningful if it makes the GPU execute more code for every vertex or even every pixel.<br />We would be talking time saved once every object (perhaps 50 times per frame, in realistic scenarios), vs time wasted every vertex (thousands of times per frame, perhaps even millions for a modern high-end scenario such as Crysis).<br /><br />The problem is, it is impossible to argue with you.<br />Firstly, you seem dyslexic or whatever your problem is. It appears that your brain does not even process half the things I write in my posts. The opposite is also true: when you write posts, your brain seems to stumble over itself, confusing all kinds of terminology, resulting in some incomprehensible blurbs (cases in point: equating division-by-W to clipping, and equating normalization with homogeneous projection).<br />In this recent exchange it also looks like you were trying to use the geometry instancing technique as an example, but you didn&#039;t articulate that clearly at all, nor did you acknowledge that this would still only apply to instances of a single object, where you generally have multiple objects in a scene, even if you would use instancing. It&#039;s not a catch-all solution (not to mention that your claim for requiring matrix multiplication is complete nonsense, see below).<br />Secondly, you always propose these wildly pretentious claims, but never back anything up with actual code which would allow others to understand and verify your claims. Let alone that they could offer suggestions to improve the code.<br />Lastly: you still have not commented on the clipping issue in the D3D pipeline thread. Am I to conclude that you&#039;re still denying that there is more to clipping than just rendering the triangles entirely or rejecting them, despite the overwhelming evidence?<br /><br />If you weren&#039;t so convinced of your own greatness, perhaps you might actually turn out to be a nice guy, and perhaps we could actually have meaningful, constructive debates, from which we might both learn. You would, at any rate.<br />Case in point, my skinning shader: http://bhmfileformat.svn.sourceforge.net/viewvc/bhmfileformat/trunk/BHM3DSample/Data/VertexSkinShader.glsl?revision=55&amp;view=markup<br />As you can see, it uses 4 different world matrices per vertex, and a separate projection matrix (or actually view*projection to be exact, in this case. You see, that&#039;s the beauty of matrices... No, you don&#039;t *need* a matrix for projection, but if you use a matrix, you can easily concatenate it with the view matrix and possibly others, so that you get projection for free. *That* is why the projection setup is normally in matrix form).<br />However, despite your claims there is <strong>no matrix*matrix</strong> operation in the shader. It does mat*(mat*vec) rather than (mat*mat)*vec to save valuable instructions.<br /><pre><code><br />position&nbsp; = bones)] * Vertex * Weights[0];<br />position += bones)] * Vertex * Weights[1];<br />position += bones)] * Vertex * Weights[2];<br />position += bones)] * Vertex * Weights4;<br />...<br />gl_Position&nbsp; &nbsp; = ProjectionMatrix * position;<br /></code></pre><br /><br />Another little trick here is this:<br /><pre><code><br />float Weights4 = dot(Weights, vec4(-1,-1,-1, 1));<br /></code></pre><br />Instead of storing 4 weights per vertex, I only store 3. The total weight always has to sum up to 1, therefore the 4th weight can be inferred from the first three.<br />This saves 4 bytes per vertex. In my case the geometry consisted of about 6000 vertices if I&#039;m not mistaken. So I save 23k on a single object. Considerably more substantial than what I&#039;d get from any matrix reduction.<br />It also only costs me one instruction to calculate. Good tradeoff.<br />TIL</div>
    <div class="meta">Posted on 2012-09-18 05:53:59 by Scali</div>
   </div>
   <div class="post" id="post-216264">
    <div class="subject"><a href="#post-216264">Re: Case Study: Projection Transformation</a></div>
    <div class="body">The real point is that, of the three major transforms, we need to update them separately, and combine them in the shader, or we have to do it MANY times on the cpu, for a single scene.<br /><br />Example. The projection transform normally only changes if we changed the screen resolution (or just created a window). View transform changes once per frame, assuming the player wiggled a controller. World transform needs to change once for every rendered instance of a reference mesh.. possibly several times per frame.<br /><br />So being able to send the data in a smaller form, piecemeal, even if we have to do (almost as I claim, since I forgo scale) as much math on the gpu, it&#039;s usually going to be faster on the gpu, and, we are reducing our bus bandwidth, and achieving higher framerates.<br /><br />If we only ever had to send one matrix, once, I would be cheering for you.</div>
    <div class="meta">Posted on 2012-09-19 05:23:33 by Homer</div>
   </div>
   <div class="post" id="post-216265">
    <div class="subject"><a href="#post-216265">Re: Case Study: Projection Transformation</a></div>
    <div class="body"><div class="quote"><br />The real point is that, of the three major transforms, we need to update them separately, and combine them in the shader, or we have to do it MANY times on the cpu, for a single scene.</div><br /><br />Uhhh... Shaders are stateless. If you multiply inside a vertex shader, that multiply is done for EVERY vertex. Which is a LOT more often than whatever work you need to do on the CPU (which, as I said already, will mostly be hidden by the driver/bus overhead).<br /><br /><div class="quote"><br />Example. The projection transform normally only changes if we changed the screen resolution (or just created a window). View transform changes once per frame, assuming the player wiggled a controller.</div><br /><br />So we have already established that view*projection only changes once per frame at most... Gee, one whole matrix multiply per frame. You really think our multi-GHz, multi-core, SIMD-capable CPUs are up to that?<br />Not to mention that CPU and GPU work mostly asynchronously. So in many cases the CPU can work ahead and queue up work in the driver. So your matrix multiplies can be performed while the GPU is busy, which would otherwise be time wasted by the CPU waiting on the GPU anyway.<br /><br /><div class="quote"><br />World transform needs to change once for every rendered instance of a reference mesh.. possibly several times per frame.</div><br /><br />Oh dear, &#039;several times per frame&#039;... Compared to &#039;everytime per vertex&#039; (as stated, thousands to millions of times per frame). Yes, I really see where you&#039;re going with this... Wait, what?<br /><br /><div class="quote"><br />it&#039;s usually going to be faster on the gpu</div><br /><br />Wrong, see above.<br />As I already said, you are moving more workload into the innerloop.<br /><br /><div class="quote"><br /> and, we are reducing our bus bandwidth, and achieving higher framerates.</div><br /><br />Again, wrong.<br />The theoretical bus savings are immaterial given the other overhead.<br /><br />Perhaps you are not aware of this, but there was a time when ALL 3d mathematics were performed on the CPU. So instead of just a handful of matrix multiplies to set up shader constants, the CPU also had to do the thousands of multiplies for per-vertex T&amp;L and all that.<br />I think you have completely lost all perspective here (no pun intended).</div>
    <div class="meta">Posted on 2012-09-19 07:46:55 by Scali</div>
   </div>
   <div class="post" id="post-216273">
    <div class="subject"><a href="#post-216273">Re: Case Study: Projection Transformation</a></div>
    <div class="body"><br />Whatever you like, I&#039;ve made some major advances in my advanced material based generated shader scheme, and there are still no matrices anywhere. <br />I&#039;m happy with where I am going and not really interested in anything that is not constructive.<br /></div>
    <div class="meta">Posted on 2012-09-21 03:09:47 by Homer</div>
   </div>
   <div class="post" id="post-216275">
    <div class="subject"><a href="#post-216275">Re: Case Study: Projection Transformation</a></div>
    <div class="body"><div class="quote"><br />I&#039;m happy with where I am going and not really interested in anything that is not constructive.<br /></div><br /><br />If you think optimization tips and sharing experiences with tuning performance-critical code on various platforms are not constructive, then fine. I won&#039;t waste my time on you anymore.<br />I just hope other people have enough common sense to steer clear of your suggestions.</div>
    <div class="meta">Posted on 2012-09-21 03:29:48 by Scali</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=30911&amp;page=1" style="">&laquo;</a><a href="../?id=30911&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="30911" /><input type="number" name="page" min="1" max="3" step="1" value="3" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>