<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>What ever happened to stack!? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=21205" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=21205">What ever happened to stack!?</a></p>
   <div class="post" id="post-160481">
    <div class="subject"><a href="#post-160481">What ever happened to stack!?</a></div>
    <div class="body">Hi, this is my first day here, and I&#39;m reading all the begginning Win32 tutorials. I have had experience with real mode programming on 80x86&#39;s, but flat model memory and protect mode programming is completely new to me. I used the TASM compiler. After about 20 times of crashing my first DOS program, I went online and was told to put in a stack segment (At that time, I didn&#39;t even know what that was). However, in these programs, there is no stack segment specifying the stack size or it&#39;s initial values! I know the stack is still around because of local varaibles, but it seems to work differently. For example stack is a LIFO system, last in first out, which I used with only push and pop. How does automatic variables which require random access fit onto the stack? Thanks. </div>
    <div class="meta">Posted on 2005-05-26 15:16:40 by binarybob0001</div>
   </div>
   <div class="post" id="post-160491">
    <div class="subject"><a href="#post-160491">Re: What ever happened to stack!?</a></div>
    <div class="body">You&#39;re right, in win32 the stack is already set up for you. I&#39;m not 100% sure what you mean, i think you&#39;re asking- how is the stack used to store things other than push/pop values? Well, you can &quot;allocate&quot; space on the stack by altering the position of the stack pointer, called &#39;esp&#39;. So to allocate, say 100 bytes:<br /><br /><pre><code><br />sub esp,100<br /></code></pre><br /><br />then from esp to esp+100 you have memory to play with so you can do anything like<br /><br /><pre><code><br />mov ,eax<br />sub dword ptr ,3<br />not byte ptr <br /></code></pre><br /><br />etc. etc.<br /><br />then to &quot;free&quot; the memory you just add to esp again. In this case then, you&#39;d do: add esp,100<br /><br />hth<br /></div>
    <div class="meta">Posted on 2005-05-26 18:55:34 by stormix</div>
   </div>
   <div class="post" id="post-160494">
    <div class="subject"><a href="#post-160494">Re: What ever happened to stack!?</a></div>
    <div class="body">Bob,<br /><br />In Win32, the stack size and committed memory are set in the execulatble header, stack reserve and stack commit. This is usually set with the linker. If you are running 16 bit executables, you set the stack the old way.</div>
    <div class="meta">Posted on 2005-05-26 19:29:02 by hutch--</div>
   </div>
   <div class="post" id="post-160496">
    <div class="subject"><a href="#post-160496">Re: What ever happened to stack!?</a></div>
    <div class="body">In the flat memory model, you can use the LOCAL directive in MASM to allocate PROC variables on the stack. Variables allocated this way can be used only in the PROC where they&#39;re defined. MASM will insert code before the RET instruction to clean up the stack for you.<br /><br /><pre><code><br />ViewProc proc hWin:DWORD, uMsg:DWORD, wParam:DWORD, lParam:DWORD<br />local hDC:DWORD<br />local Ps:PAINTSTRUCT<br />.<br />.<br />.<br />ret<br /></code></pre></div>
    <div class="meta">Posted on 2005-05-26 20:08:14 by S/390</div>
   </div>
   <div class="post" id="post-160497">
    <div class="subject"><a href="#post-160497">Re: What ever happened to stack!?</a></div>
    <div class="body">and one more thing:<br /><br />if you&#39;re talking about nested automatic variables that can overlap, like in the example:<br /><br />( c++)<br /><br />int blah(int a, int b) {<br />&nbsp; &nbsp; int temp1;<br /><br />&nbsp; &nbsp; if (1) {<br />&nbsp; &nbsp; &nbsp; &nbsp; int temp2;<br />&nbsp; &nbsp; &nbsp; &nbsp; temp2 = 7;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; if (1) {<br />&nbsp; &nbsp; &nbsp; &nbsp; int temp3;<br />&nbsp; &nbsp; &nbsp; &nbsp; temp3 = 8;<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; temp1 = 2;<br />&nbsp; &nbsp; return (a + b + temp1);<br />}<br /><br />stupid compiler would allocate space for all 3 variables. a smarter ona would allocate for aonly 2. quite smarte would allocate space only for 1 variable. and finally very clever compiler will allocate space for no variable at all.<br /><br />i assume you&#39;ve already read <strong>stormix&#39;s</strong> post about allocating local variables :)</div>
    <div class="meta">Posted on 2005-05-26 21:09:44 by ti_mo_n</div>
   </div>
   <div class="post" id="post-160504">
    <div class="subject"><a href="#post-160504">Re: What ever happened to stack!?</a></div>
    <div class="body">Thanks everyone. I still have a couple of questions though. According to my reading every program thinks it has access to 4 gigs straight of memory. Where does the program start in memory. In real mode the program started after the stack segment which was why allocation was so important. In other words, does the program believe that it starts at address 0x00000000 where does it view its stack segment? How can you tell if there is no memory available? Sorry for asking so many questions in this one post, but I want to clear up all my memory questions so I can jump strait into windows in assembly! Another question, I was also told never ever to play with the code segment or stack segment registers(also their index registers). This seems to be just the opposite in winodws. Is esi, edi, ebp, ebx the only somewhat off limit registers (they must be pushed first), or are there other bad registers to play with?<br /><br />Lastly, I would like to say that the information on this site is outstanding. I have been struggling for the past six months to make my own window API rapper in C++, but the windows API information seemed to be relitively limited particularly in advanced controls like RICHEDIT. I am also a member of code guru and while the enviroment and information there is also excelent, this site has more of the stuff I&#39;m interested in. I know some of you may ask why after six months of work I don&#39;t break down and use MFC. The simple answer: I consider it poorly designed. My library may not be much better, but I&#39;m gonna try.</div>
    <div class="meta">Posted on 2005-05-27 02:27:16 by binarybob0001</div>
   </div>
   <div class="post" id="post-160508">
    <div class="subject"><a href="#post-160508">Re: What ever happened to stack!?</a></div>
    <div class="body"><div class="quote"><br />Where does the program start in memory. In real mode the program started after the stack segment which was why allocation was so important. In other words, does the program believe that it starts at address 0x00000000 where does it view its stack segment?<br /></div><br />Things like these are all taken care of by the compiler/linker and windows.<br />1. When compiling/linking, your program will be given a loading address. This is typically 400000h - but basically that&#39;s arbitrary, and could be anything. You can set this variable yourself, should you want to. Windows will try to load your executable at this address.<br />2. When windows loads your executable, it sets up pretty much everything for you. So, it also gives you a stack, and when your program starts, the registers are loaded with the relevant values.<br /><br /><div class="quote"><br /> How can you tell if there is no memory available?<br /></div><br />If your program wants more memory on startup than is available, it won&#39;t run. Furthermore, if you&#39;re referencing data in your own address space, this will already have been setup by the compiler. Hence, only if you&#39;re trying to store variables in arbitrary places would you have this problem. If your exe loads, then you know your data sections fit in memory.<br /> As for allocating more mem for your exe, this is a different question. It&#39;s done by calling API&#39;s and windows will tell you if there&#39;s available mem for you.<br /><br /><div class="quote"><br /> Sorry for asking so many questions in this one post, but I want to clear up all my memory questions so I can jump strait into windows in assembly! Another question, I was also told never ever to play with the code segment or stack segment registers(also their index registers). This seems to be just the opposite in winodws. Is esi, edi, ebp, ebx the only somewhat off limit registers (they must be pushed first), or are there other bad registers to play with?<br /></div><br />Exactly what do you mean by code segment and stack segment registers? Modifying the esp register isn&#39;t that big a problem, especially if you stay within you allocated stack space.<br /> As for the offlimit registers: basically you are right, however, keep in mind that when calling api&#39;s and the likes, you&#39;re going to be sharing the stack. For instance, if you create a window procedure, you should make sure to balance the stack before returning control to windows - otherwise things will go wrong.<br /><br />Fake<br /><br />Lastly, I would like to say that the information on this site is outstanding. I have been struggling for the past six months to make my own window API rapper in C++, but the windows API information seemed to be relitively limited particularly in advanced controls like RICHEDIT. I am also a member of code guru and while the enviroment and information there is also excelent, this site has more of the stuff I&#39;m interested in. I know some of you may ask why after six months of work I don&#39;t break down and use MFC. The simple answer: I consider it poorly designed. My library may not be much better, but I&#39;m gonna try.<br /><div class="quote"></div></div>
    <div class="meta">Posted on 2005-05-27 04:54:30 by Fake51</div>
   </div>
   <div class="post" id="post-160529">
    <div class="subject"><a href="#post-160529">Re: What ever happened to stack!?</a></div>
    <div class="body"><div class="quote"><br />In real mode the program started after the stack segment which was why allocation was so important. In other words, does the program believe that it starts at address 0x00000000 where does it view its stack segment?<br /></div><br /><br />Not true. In a DOS EXE file, the header information at the start of the file states where the program begins execution (relative to a DOS-assigned load address). It isn&#39;t necessarily the same place as the first stored byte of executable code. The header information also states where the stack is located (also relative to a DOS load address). It may not be apparent to you, but in real mode, segments are allowed to overlap, so that part of the stack segment may overlap the data segment. DOS compilers took advantage of that fact when generating code for the &quot;small&quot; memory model.<br /><br />In Win32, the four &quot;default&quot; segment registers, CS, DS, ES, SS are set up so their corresponding segments overlap. The overlap is defined so that location 0 in CS is the same as location 0 in the other three segments. The result is that the program appears to have exactly one segment, regardless of which (of the four) segment register you used. Unlike real mode, the segments can potentially span the whole 4G address space allowed by 32-bit addressing. The primary exception to the single segment &quot;flat&quot; memory model is the use of FS to define a segment containing thread information.<br /><br />The stack is located in memory where ESP says it&#39;s located. All the accessible memory locations are in the same segment.<br /><br /><div class="quote"> How can you tell if there is no memory available? <br /></div><br /><br />That depends on what you mean by &quot;no more&quot; memory.? The idea of &quot;no more&quot; memory presumes the existence of memory management software. Win32 manages memory by using hardware &quot;memory protection&quot; features. There are API functions for getting &quot;unallocated&quot; storage from the OS.<br /><br /><div class="quote">I was also told never ever to play with the code segment or stack segment registers(also their index registers). This seems to be just the opposite in winodws. Is esi, edi, ebp, ebx the only somewhat off limit registers (they must be pushed first), or are there other bad registers to play with?<br /></div><br /><br />In protected mode, you must not play with any of the segment registers. Attempting to load arbitrary values into segment registers can cause an exception, halting your program. All eight of the main registers can be combined in various addressing modes, with only a few invalid combinations. When interacting with Windows, either by calling APIs, or being called by Windows, you must respect the register saving conventions.<br /><br /><div class="quote">I know some of you may ask why after six months of work I don&#39;t break down and use MFC.</div><br /><br />Now, why would an assembly language programmer suggest using a C++ framework?</div>
    <div class="meta">Posted on 2005-05-27 22:03:25 by tenkey</div>
   </div>
   <div class="post" id="post-160580">
    <div class="subject"><a href="#post-160580">Re: What ever happened to stack!?</a></div>
    <div class="body"><div class="quote"><br />but the windows API information seemed to be relitively limited particularly in advanced controls like RICHEDIT.<br /></div><br />If you&#39;re still using win32.hlp, get hold of the PlatformSDK: http://www.microsoft.com/downloads/details.aspx?FamilyID=EBA0128F-A770-45F1-86F3-7AB010B398A3&amp;displaylang=en (or if you&#39;re not on broadband, order the CDs, you can use the online version at http://msdn.microsoft.com/ ).<br /></div>
    <div class="meta">Posted on 2005-05-29 20:10:31 by f0dder</div>
   </div>
  </div>
 </body>
</html>