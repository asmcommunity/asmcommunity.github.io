<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Modular IOCP Beta Demo - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=21279" />
  <link rel="prev" href="../?id=21279&amp;page=1" />  <link rel="next" href="../?id=21279&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=8">Networking</a> &raquo; <a href="../?id=21279">Modular IOCP Beta Demo</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=21279&amp;page=1" style="">&laquo;</a><a href="../?id=21279&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="21279" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=21279&amp;page=3">&gt;</a><a href="../?id=21279&amp;page=3">&raquo;</a></form>   <div class="post" id="post-161211">
    <div class="subject"><a href="#post-161211">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">Mark,<br /><br />I hope your ok. Sometimes cheering up a friend can leave you drained.<br /><br />I do see a need for WSABUF&#39;s but only in sending.<br />You see maximum throughput for the network is governed by the MTU/Packet size. I have a text somewhere on working this out so<br />at a later point ask me about tuning this.<br /><br />Anyways, if you send one buffer bigger than the MTU (Maximum Transmission Unit) size the packet has a <br />&quot;more packets to come&quot; flag set. So the ends of the connection expect to receive and to send more packets and they handshake<br />on this. If you want fast throughput, try to send data in single non-split packets. <br />Using a WSABUF buffer for this helps as you can split the data to be sent into MTU size buffers, but still do one send call.<br /><br />My assumption is that Winsock is smart enought to not try and put all the WSABUF data into one packet. Id have to actually test this.<br /><br />The other thing is that other users of your code may find a use for the buffer arrangement and forcing them to use one buffer<br />may not be good. Since WSABUF allows one or multiple buffers, id just use that approach.<br /><br />With the scaling of resources (threads, buffers and collections) my advice is to scale in percentages that the user can define.<br />This way they can track the peeks and define a percentage for that. A shrink and a grow percentage. <br />You dont want to shrink a buffer just to have the next call spike it right up again. <br /><br />My new version should be posted at some point today (Saturday) or tomorrow.<br /><br />Rgs, James.</div>
    <div class="meta">Posted on 2005-06-17 17:57:10 by James_Ladd</div>
   </div>
   <div class="post" id="post-161218">
    <div class="subject"><a href="#post-161218">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">I&#39;ve been a little more worried about &quot;nonconcurrency&quot; when you have &gt;1 worker thread.<br />Even though IO jobs posted on the IOCP will be processed in the order they are posted, they can complete out of order. This means that serialized IO jobs should be marked with a sequence number..which can in turn be used as an index into a perclient &quot;buffer collection&quot;.<br />I&#39;m not at the point where that issue has raised its head yet, but being aware of it is half way to handling it.<br /><br />For this reason, I have created two classes : Client and IOJob, and I use the IOJob as the completion key rather than the Client who &quot;owns it&quot;.<br />IOJobs are stored in a Pool, but are each marked with the &quot;client who owns it&quot;.<br />The reason why I chose to use the IOJob as the completionkey rather than the Client is because we now know which asynchronous &quot;partial operation&quot; has completed, and can handle it out-of-order without searching the Client for the matching OVL or anything like that.<br /><br />James, the &quot;Client&quot; is the object which owns the Socket, and also owns one or more outstanding (recyclable) &quot;IOJob&quot; objects.<br />These are just like using heap structs, except we can call procedures on a given struct instance...<br /><br />A class method is simply a procedure with a hidden parameter .. pThis, aka &quot;pStruct&quot; apon which the procedure is to act.<br /><br />An simple, useless but clear example of what an oop class method looks like if you were masm:<br /><pre><code><br />IOJob_SetOperation proc uses esi pIOJob:ptr IOJob, dwOperation:dword<br />assume esi:ptr IOJob<br />mov esi,pIOJob<br />push dwOperation<br />pop .operation<br />assume esi:nothing<br />ret<br />IOJob_SetOperation endp<br /></code></pre><br /><br />What that &quot;crappy method&quot; would like like to a human coding with masm and the OA32 macros:<br /><pre><code><br />Method IOJob.SetOperation uses esi dwOperation:dword<br />SetObject esi<br />push dwOperation<br />m2m .operation,dwOperation<br />MethodEnd<br /></code></pre><br /><br />Instances of classes are only a few bytes larger than structs, and nine times out of ten we can forgive this.. <br /><br />Classes which inherit from other classes are compacted during the build process so no bytes are wasted.<br /><br />There&#39;s only one copy of the code no matter how many instances of a class we make.<br /><br />Unless the methods are &quot;Dynamic&quot;, they do not occupy space in the object instances.<br /><br />I&#39;m going to get you to try this stuff if it kills me because:<br />A) because your code becomes more portable from project to project as it is modular in nature<br />B) because it helps you code faster, yet you retain full lowlevel control of the binary code you produce<br />C) because you can benefit from polymorphism and interact with existing C/C++/VB code, etc.<br />D) because you have the right background and the right inclination<br />E) because you get the best of both worlds, can quickly transliterate between them, etc<br />F) because the overheads are all in your mind<br />G) because it&#39;s too damned cool to ignore<br /><br />Have a nice day :)</div>
    <div class="meta">Posted on 2005-06-18 02:56:52 by Homer</div>
   </div>
   <div class="post" id="post-161265">
    <div class="subject"><a href="#post-161265">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">EvilHomer,<br /><br />Once I have a simple example working Ill try an oop example.<br />But not until then. I know the oop way has advantages. I wouldnt be an oop person everyday if<br />I didnt understand that. The Smalltalk language is my favourite, so your preching to the converted.<br /><br />One thing to keep in mind with communications if that event based programming is the way to go.<br />IOCP does this. And, no order if really guaranteed.<br /><br />BTW - Thanks for your help.<br /><br />Rgs, James.</div>
    <div class="meta">Posted on 2005-06-18 17:28:46 by James_Ladd</div>
   </div>
   <div class="post" id="post-161276">
    <div class="subject"><a href="#post-161276">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">Server beta demo was updated.<br />This time I have implemented a &quot;Pool Class&quot;, and derived from it an &quot;IOJob Allocator Class&quot;, which manages a &quot;Pool&quot; of &quot;IOJobs&quot;. Pool class is threadsafe - meaning the code below it, including Collection and &quot;Your Object&quot;, does not have to be threadsafe... and the only requirement of a &quot;Poolable Object&quot; is that it derives from Primer (I manipulate pOwner).<br />When I say &quot;Pool&quot; I am describing a special collection of &quot;self-recycling objects&quot;.<br />By this I mean that the Pool abstracts the normal Creation and Destruction of the objects it is managing.. it contains &quot;Used and Free lists&quot; of objects, and its job is essentially to ensure that a minimum number of objects are not destroyed but instead these objects (and their resources) are retained and made available through the abstracted Create.<br />The Pool class is naiive as to the Class of the objects it holds, but in my case, I am pooling a new object called IOJob.<br />The IOJob object contains wsabuf and overlapped structs, and is formed from code that has mostly been transferred from the Client class, which is now much simpler.<br />The Server object owns the IOJobs Pool and the Clients Collection.<br />Each Client can own one or more IOJobs managed by their Owner (Server) IOJobs pool.<br />When an IOJob is (re)allocated by the Pool, it is (re)marked as being Owned by a given Client.<br />This way the Clients merely &quot;implicitly own&quot; a number of IOJob objects in the Used part of the Pool.<br />IOJobs know which Client owns them.. not the other way around.<br />Since I use ptr to IOJob as my &quot;completionkey&quot; for completed IO jobs, everything falls into place.. the given IOJob which completed knows which Client owns it, and can immediately call methods in the IOJob class and the owner Client class, and via the Client could even call methods in the Server class, which would be silly, I&#39;m merely elaborating on the relationship between the objects.<br /><br />The updated demo has been written to implement all the above, plus a few other changes.<br />We no longer create N Clients, and/or call N AcceptEx etc.<br />We create one initial Client object and one initial Accept socket, and call AcceptEx ONCE (ie, queue ONE IOJob, which is an Accept)..<br />In the AcceptCompletion handler should be a line to (repeat the above), but I didn&#39;t add it yet, so only one client at a time.. I wanted to check the IO stuff was working, since I shifted a lot of code around.<br /><br />Please betatest :D<br /></div>
    <div class="meta">Posted on 2005-06-19 02:11:41 by Homer</div>
   </div>
   <div class="post" id="post-161301">
    <div class="subject"><a href="#post-161301">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">EvilHomer,<br /><br />Ill download your version and give it a test tonight.<br />A new version of FAStServer was posted. It works !!<br />It can be found here <a target="_blank" href="http://www.jamesladdcode.com">http://www.jamesladdcode.com</a><br /><br />Thanks for your help with it.<br /><br />Rgs, James.</div>
    <div class="meta">Posted on 2005-06-19 15:57:37 by James_Ladd</div>
   </div>
   <div class="post" id="post-161327">
    <div class="subject"><a href="#post-161327">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">I implemented a ClientPool, where Clients own IOJobs from Server&#39;s shared IOJobPool, and everything went wrong :(<br />I&#39;m not even getting AcceptIO&#39;s anymore, which seems weird.<br />I must be doing something critical in the wrong order .. I&#39;ll figure it tomorrow, yawn..<br /></div>
    <div class="meta">Posted on 2005-06-20 09:50:23 by Homer</div>
   </div>
   <div class="post" id="post-161341">
    <div class="subject"><a href="#post-161341">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">Homer,<br />Where can I get the latest to have a look at the issue ?<br />One suggestion I have is; do the absolute minimum to get the thing done, then add to it.<br />I have made several versions of FAStServer and then gone back to super simple basics. Because<br />something invariably goes wrong nad it is easier to work out if things are kept as simple as<br />they can be to get the job done. If you add the most minute of increments, then it has to be<br />the 3 or so calls you just added that went wrong. (Almost always).<br />Rgs, James.</div>
    <div class="meta">Posted on 2005-06-20 16:06:19 by James_Ladd</div>
   </div>
   <div class="post" id="post-161453">
    <div class="subject"><a href="#post-161453">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">The binary update is the same url as previously, but doesn&#39;t represent the current state of the source.<br /><br />I&#39;m hoping to catch you on the messaging thingy soon, I have some questions that would best be answered in realtime.. perhaps you can help :)<br /><br /></div>
    <div class="meta">Posted on 2005-06-24 10:31:42 by Homer</div>
   </div>
   <div class="post" id="post-161468">
    <div class="subject"><a href="#post-161468">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">EvilHomer,<br />Watch for me on messanger today. Ill be around and eager to talk.<br />Rgs, James.</div>
    <div class="meta">Posted on 2005-06-24 19:45:30 by James_Ladd</div>
   </div>
   <div class="post" id="post-161470">
    <div class="subject"><a href="#post-161470">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">I think I found the culprit :)<br />It&#39;s to do with the completionkey chosen for the listening socket&#39;s OnAccepted completions.<br />I looked back at your earlier work (one-socket version with acceptex) and noticed something odd.<br />You call CreateIOCompletionPort with all nulls at first, ok normal, but then when you bind the listen socket to the demo client&#39;s acceptio ovl, you were using NULL as the completionkey !!<br />When I added special casecode for completionkey=null and mimicked your behaviour, everything started working .. really nicely.. zip has been updated :)<br />Clients are accepted immediately, and the weird &quot;kicking the previous client on accept&quot; is gone.<br />It seems to be doing everything it&#39;s meant to be doing - the source could do with a tidy up now :P</div>
    <div class="meta">Posted on 2005-06-24 21:08:02 by Homer</div>
   </div>
   <div class="post" id="post-161487">
    <div class="subject"><a href="#post-161487">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">So far only receive code had been implemented, and a single recv io per client at that.<br />When I implemented send using overlapped asynchronous io, something failed - I got winsock error 10045 on my sends.<br />I&#39;ve since realized that my send io&#39;s completion key is not bound to the iocp.<br />The best solution seems to me : move the call to CreateIOCompletionPort from the Accepted handler to the IOJobPool_Allocate method, or near that call..<br /><br />In the meantime, I was messing around with something related: OA32 isn&#39;t designed to handle crosscalling of classes across modules, and I&#39;ve been playing with several simple hacks to get around it. Basically it&#39;s a chicken-egg situation I&#39;m trying to resolve, but if I don&#39;t find a satisfactory solution I&#39;ll simplify the Plugin to be a logic engine which performs no tasks but instead whose methods return values become triggers for operations performed within Server..<br /><br />Have a nice day :)</div>
    <div class="meta">Posted on 2005-06-26 03:01:51 by Homer</div>
   </div>
   <div class="post" id="post-161492">
    <div class="subject"><a href="#post-161492">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">I didn&#39;t find a satisfactory solution to the N chickens / N eggs / N baskets issue.<br />I therefore spent some time knocking all the meat off the bones of the Plugin module.. I&#39;ve stripped it down to a very basic callback class which performs only logical operations via a handful of staticabstracts. Then I made an EchoPlugin class which derives from Plugin, and neither of them contain references to other classes.. only to the XOVL struct. This is probably an all-around better solution but at the cost of some call overhead (we can&#39;t and don&#39;t make cross class calls from Plugin or its derivative(s)).<br />The idea is that Server calls various callbacks within Plugin, which may only operate on the given XOVL and generally which simply return a value indicating to Server which logical branch to follow.<br />OK that cleans up the Plugin side of things, and leaves me with a little work to do on Server tomorrow to see these changes through.<br />It doesn&#39;t get me closer to a neat solution to cross-calling within the Server class, however I&#39;m willing to be a little hacky with regards to the bare handful of Plugin method calls..</div>
    <div class="meta">Posted on 2005-06-26 10:22:24 by Homer</div>
   </div>
   <div class="post" id="post-161502">
    <div class="subject"><a href="#post-161502">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">EvilHomer,<br />Hmmn, sounds like things are moving along.<br />Dont forget to associate the socket for the acceptex call with the completion port BEFORE you do the accept.<br />Im sure you have worked this out.<br />Keep on it.<br />Rgs, James.</div>
    <div class="meta">Posted on 2005-06-26 15:55:39 by James_Ladd</div>
   </div>
   <div class="post" id="post-161508">
    <div class="subject"><a href="#post-161508">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">James - some potentially sticky questions ..<br />does it make more sense to you that the CreateIOCP binding to a compkey be performed as soon as an XOVL is (re)allocated? And do you know how many completionkeys can be associated with the same socket?<br />Finally, rather than binding a client socket and compkey on completion of Accept, is there a reason not to bind new client sockets to the iocp BEFORE they are accepted?<br /><br />Have a nice day :)<br /></div>
    <div class="meta">Posted on 2005-06-26 21:43:46 by Homer</div>
   </div>
   <div class="post" id="post-161511">
    <div class="subject"><a href="#post-161511">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">Ah, back in the saddle - it&#39;s compiling again after only three hours of cutting, pasting and generally manipulating code across a half dozen classes .. it&#39;s not WORKING, but it&#39;s compiling..<br /><br />I had a half dozen classes whose methods often called methods in arbitrary other classes.<br />This not only made the source difficult to build due to N-chicken-egg references, it also made it a little difficult to follow outside of a multiple document interface based ide.<br /><br />I&#39;ve been removing a whole bunch of these &quot;cross-calls&quot; so that most of the action now occurs in Server class - indeed IOJob has been almost totally gutted, and Client is looking thin also.<br /><br />I may have been a little overzealous, we&#39;ll see.<br /><br />Note that I&#39;m generally referring to problems I&#39;ve created for myself due to my indifferent approach to oop .. it is in my nature to explore possibilities and tread thin ice, and indeed since I am developing public code for the OA32 oop model, it is only right that I tread that ice before anyone else does - but enough messing around, the code is cleaned up and I&#39;ll now forge ahead.<br /><br /><br /></div>
    <div class="meta">Posted on 2005-06-27 00:19:19 by Homer</div>
   </div>
   <div class="post" id="post-161512">
    <div class="subject"><a href="#post-161512">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">EvilHomer,<br /><br />You should bind the socket you will accept on before AcceptEx if you want accept notifications.<br /><br />To know they are accept notifications you and not some other IO event you should have and<br />set an operation field in your completion key or extended overlapped struct. I choose to do it in<br />the completion key struct. eg:&nbsp; &nbsp; mov operation, OPERATION_ACCEPT.<br /><br />Then when you do a read, set the to OPERATION_READ. Etc etc.<br /><br />When the IO routine completes you will get a completion event and the completion key.<br />This key will tell you which operation the notification is for, however .....<br /><br />To have multiple operations on the go at one time, you should extend the OVERLAPPED structure as<br />this is the only one you can specify with each call to WSARecv or WSASend. You could keep the <br />common stuff in the single completion key associated with the socket, and the changing stuff in <br />the extended OVERLAPPED structure.<br /><br />Rgs, James.</div>
    <div class="meta">Posted on 2005-06-27 03:44:55 by James_Ladd</div>
   </div>
   <div class="post" id="post-161522">
    <div class="subject"><a href="#post-161522">Re: Modular IOCP Beta Demo</a></div>
    <div class="body"><br />James,<br /><br /><div class="quote">You should bind the socket you will accept on before AcceptEx if you want accept notifications.<br /></div><br /><br />Yep, bind the Listener before issuing AcceptEx - sure - but what about the sockets being accepted?<br />The examples (which are never truly asynch) always show the accepted client&#39;s socket being bound to the iocp during the completion of the accept on said client socket.. often the xovl that was used in the acceptex is rebound for client readIO, which is fine except that we&#39;re limited to a single completionkey, which you elect should be a perclient key.. Some examples, mine included, use a per-client-context and a per-io-context, a pointer to the latter being employed as the completionkey. <br />Is there any reason I can&#39;t bind &gt;1 completionkey to an accepted client socket, and is there any reason I can&#39;t pre-bind accepted sockets before they are accepted?<br /> </div>
    <div class="meta">Posted on 2005-06-27 09:01:29 by Homer</div>
   </div>
   <div class="post" id="post-161532">
    <div class="subject"><a href="#post-161532">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">EvilHomer,<br /><br />You should never bind the listener socket, only the accept socket !<br />So yes, you should pre-bind the &#39;to be accepted&#39; socket before the AcceptEx call.<br /><br />My example is a simple one, so I use a completion key without problems.<br />This should be changed to use an extended OVERLAPPED struct since this is the <br />only way to bind a per-call structure that will be passed back during completion.<br />The completion key is always the same for every IO completion because its bound<br />early. For parallelism and true asynchronous IO the OVERLAPPED struct should be<br />used, so you can specify a different (or same) OVERLAPPED struct on each <br />WSASend and WSARecv. <br /><br />I will be updating my example to use the OVERLAPPED struct approach very soon.<br /><br />Rgs, James.</div>
    <div class="meta">Posted on 2005-06-27 15:53:27 by James_Ladd</div>
   </div>
   <div class="post" id="post-161544">
    <div class="subject"><a href="#post-161544">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">Nevermind, I was talking gibberish.<br />It really doesn&#39;t matter WHAT I use as a completion key, because I do not use the completion key anymore.. I use pOVL (pXOVL) returned from GetQueuedCompletionStatus as a guide to the Client who is its owner via a pointer stored in xovl :)<br />My XOVL is actually a field of IOJob object class (think of IOJob as a struct with a xovl member), and in turn, XOVL contains a special &quot;backpointer field&quot; called piojob, so that given a pointer to an xovl, we can find the iojob which contains the given xovl..<br />IOJob also contains a pOwner field indicating which Client class object owns it.<br /><br />I&#39;ve reworked the Plugin baseclass and EchoPlugin derivative class which are used in the Protocol plugin DLL .. Plugin is a generic class which the Server thinks its talking to, and ProtocolPlugin derivatives of Plugin class are used to build different Plugin DLLs - that the Server can always talk to.<br /><br />I got the Plugin class methods hooked up and firing on the Server side, and the EchoPlugin derivation class in the Protocol dll is cooperating .. now I&#39;m considering how to allow the Plugin to queue sends via Server DLL components..perhaps allowing Plugin access to Server isn&#39;t a bad idea after all.. I&#39;m not inclined to provide a named export on the Server DLL for asynch sending !!<br /><br />Also I got WSASend to work, although there&#39;s still a small bug in that..<br />Anyhow, just a heads up to let you know how I&#39;m crawling..</div>
    <div class="meta">Posted on 2005-06-28 09:20:49 by Homer</div>
   </div>
   <div class="post" id="post-161555">
    <div class="subject"><a href="#post-161555">Re: Modular IOCP Beta Demo</a></div>
    <div class="body">EvilHomer,<br /><br />Sounds like your making good progress.<br /><br />My initial design for the plugin doing sends was to allow a call a server send function/method.<br />The server could then use whatever implementation it wanted. Most likely just on call to <br />WSASend.<br /><br />Ill be changing things in my example to use the extended overlapped approach.<br /><br />Rgs, James.</div>
    <div class="meta">Posted on 2005-06-28 15:52:37 by James_Ladd</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=21279&amp;page=1" style="">&laquo;</a><a href="../?id=21279&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="21279" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=21279&amp;page=3">&gt;</a><a href="../?id=21279&amp;page=3">&raquo;</a></form>  </div>
 </body>
</html>