<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>The stack - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30275" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=30275">The stack</a></p>
   <div class="post" id="post-213350">
    <div class="subject"><a href="#post-213350">The stack</a></div>
    <div class="body">assuming a C function like<br /><pre><code><br />int f( int x )<br /></code></pre><br />what will be the address of variable x on the stack?? is it ,  , ,??<br /><br />and in the case of<br /><pre><code><br />int f ( int y, int x )<br /></code></pre><br />what will be the addresses of x and y??</div>
    <div class="meta">Posted on 2010-10-15 07:28:17 by ashken</div>
   </div>
   <div class="post" id="post-213351">
    <div class="subject"><a href="#post-213351">Re: The stack</a></div>
    <div class="body">It&#039;s been a long night, so forgive me if I don&#039;t get this exactly right, but ...<br /><br />For most processors, the stack grows in the negative direction (decrementing), so once some data is placed on the stack (causing the esp to be adjusted in a negative direction), we can find the data at a positive offset of esp. If we have no stackframe, then the first input param is at esp+4 (since the return address is at esp+0)<br /><br />For the x86 processor, most compilers will only use the ebp register for procedures which require a STACK FRAME - that means that the procedure has one or more LOCAL VARIABLES - otherwise we don&#039;t normally expect to see ebp being used.<br /><br />In the cases where a stack frame is required, we&#039;ll normally see something like this:<br /><br /><pre><code><br />MyStupidProcedure proc arg1:DWORD<br />LOCAL MyDumbVariable[16]:BYTE<br /><br />push esp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;preserve value of esp on entry to procedure (for the return address)<br />mov ebp,esp&nbsp; &nbsp; &nbsp; ;we&#039;ll use ebp to access our stackframe (input params and any locals)<br />sub esp, 16&nbsp; &nbsp; &nbsp;  ;adjust esp to point PAST the locals so we dont trash anything on the stack<br /><br />;do stuff in there<br />;example - we can safely push and pop since esp wont trash anything now<br />;example - first input param is now at ebp+8 since we pushed one dword onto the stack<br /><br />pop esp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;restore the old esp so we can return to caller correctly<br />ret<br />MyStupidProcedure endp<br /></code></pre><br /><br />Hope this is useful!<br /></div>
    <div class="meta">Posted on 2010-10-15 08:21:25 by Homer</div>
   </div>
   <div class="post" id="post-213353">
    <div class="subject"><a href="#post-213353">Re: The stack</a></div>
    <div class="body">Ummm.... actually I don&#039;t think that is quite right...<br /><br /><pre><code><br />MyStupidProcedure proc arg1:DWORD<br />LOCAL MyDumbVariable[16]:BYTE<br /><br />; push esp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;preserve value of esp on entry to procedure (for the return address)<br />; no, no, no...<br /><br />push ebp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; preserve caller&#039;s ebp - they&#039;re probably using it<br /><br />mov ebp,esp&nbsp; &nbsp; &nbsp; ;we&#039;ll use ebp to access our stackframe (input params and any locals)<br />sub esp, 16&nbsp; &nbsp; &nbsp;  ;adjust esp to point PAST the locals so we dont trash anything on the stack<br /><br />;do stuff in there<br />;example - we can safely push and pop since esp wont trash anything now<br />;example - first input param is now at ebp+8 since we pushed one dword onto the stack<br /><br />; pop esp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;restore the old esp so we can return to caller correctly<br />; this would have popped from our &quot;local variable&quot; space, no?<br /><br />mov esp, ebp&nbsp; &nbsp; &nbsp; ; restore esp - &quot;free&quot; local variables<br />pop ebp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; restore caller&#039;s ebp - now esp is what it was on entry<br /><br />ret<br />MyStupidProcedure endp<br /></code></pre><br /><br />I may not have this right, either. When we say &quot;proc&quot; and &quot;endp&quot;, it generates some code (no? I avoid using &#039;em, myself...) so I may have done it twice...<br /><br />Maybe helpful to look at the calling code...<br /><br /><pre><code><br />; int f (int x)<br />push x<br />call f<br />add esp, 4<br />...<br /></code></pre><br /><br />When we &quot;push x&quot;, x is at . The &quot;call&quot; pushes the return address on the stack (not obvious unless we RTFM). So now x is at  (when we arrive at &quot;f:&quot;).<br /><br />With two parameters...<br /><br /><pre><code><br />; int f (int x, int y)<br />push y ; C pushes &#039;em right to left<br />push x<br />call f<br />add esp, 8<br /></code></pre><br /><br />The called function &quot;f&quot; can look like:<br /><br /><pre><code><br />; return address is at <br />mov ecx,  ; x<br />mov edx,  ; y<br />; do something with &#039;em<br />; mov eax, return value<br />ret<br /></code></pre><br /><br />Notice that this doesn&#039;t do &quot;sub esp, localsize&quot;. It is possible to use local variables without a stack frame, but it&#039;s a PITA to keep track of where our parameters are, and to restore esp (the return address *must* be the next thing on the stack when we come to &quot;ret&quot;!!!). So it is common to use ebp as a &quot;stack frame pointer&quot;...<br /><br /><pre><code><br />;  -&gt; return address, x -&gt; , y -&gt; <br />push ebp ; save caller&#039;s ebp<br />; now x -&gt; , etc<br />mov ebp, esp&nbsp; ; ebp = esp - stack frame pointer<br />; now x -&gt; , y -&gt; <br />sub esp, localsize ; if we want local variables<br />; now x -&gt; <br />; but x still at  - ain&#039;t that handy?<br /><br />; do something<br />; get return value in eax<br /><br />mov esp, ebp ; now esp is what it was after the &quot;push ebp&quot;<br />pop ebp&nbsp; ; and now esp -&gt; return address, and caller&#039;s ebp is restored<br />ret<br /></code></pre><br /><br />To further confuse the issue, a modern compiler (gcc, at least) doesn&#039;t actually use &quot;push x&quot;, etc. It generates some more complicated - but faster - code... but it is equivalent...<br /><br />Anyway, Ashken, the address of x (and y) depends on &quot;when&quot; - before the &quot;call f&quot;, or after?<br /><br />Are we confused yet? :)<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-10-15 14:05:00 by fbkotler</div>
   </div>
   <div class="post" id="post-213354">
    <div class="subject"><a href="#post-213354">Re: The stack</a></div>
    <div class="body"><div class="quote"><br />I may not have this right, either. When we say &quot;proc&quot; and &quot;endp&quot;, it generates some code (no? I avoid using &#039;em, myself...) so I may have done it twice...</div><br /><br /><pre><code>OPTION PROLOGUE:NONE<br />OPTION EPILOGUE:NONE<br />MyStupidProcedure proc arg1:DWORD<br />LOCAL MyDumbVariable[16]:BYTE<br /><br />&nbsp;  push ebp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; preserve caller&#039;s ebp - they&#039;re probably using it<br />&nbsp;  mov ebp, esp&nbsp; &nbsp; &nbsp; ;we&#039;ll use ebp to access our stackframe (input params and any locals)<br />&nbsp;  sub esp, 16&nbsp; &nbsp; &nbsp;  ;adjust esp to point PAST the locals so we dont trash anything on the stack<br /><br />&nbsp;  ;;----<br />&nbsp;  ;; Now, just to be clear: The 16 comes from the total size of all &#039;LOCAL&#039; variables allocated,<br />&nbsp;  ;; so if we did a:<br />&nbsp;  ;;&nbsp; &nbsp; LOCAL myVarA:DWORD<br />&nbsp;  ;;&nbsp; &nbsp; LOCAL myVarB:WORD<br />&nbsp;  ;;&nbsp; &nbsp; LOCAL myVarC:DWORD<br />&nbsp;  ;; Then we would subtract ESP by (SIZEOF(DWORD) +SIZEOF(WORD) +SIZEOF(DWORD))<br />&nbsp;  ;; or simply: sub esp, (4*3).... HOLD UP!!! Now why did I do that? SIZEOF(WORD) is 2 not 4.<br />&nbsp;  ;; The reason I do that is to keep things aligned on the stack and to prevent any possible stalls.<br />&nbsp;  ;; Get used to doing this, always round up to the next dword if you can.<br />&nbsp;  ;;--<br /><br />&nbsp;  ;do stuff in there<br />&nbsp;  ;example - we can safely push and pop since esp wont trash anything now<br />&nbsp;  ;example - first input param is now at ebp+8 since we pushed one dword onto the stack<br /><br />&nbsp;  ; pop esp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;restore the old esp so we can return to caller correctly<br />&nbsp;  ; this would have popped from our &quot;local variable&quot; space, no?<br /><br />&nbsp;  mov esp, ebp&nbsp; &nbsp; &nbsp; ; restore esp - &quot;free&quot; local variables<br />&nbsp;  pop ebp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; restore caller&#039;s ebp - now esp is what it was on entry<br />&nbsp;  ret<br /><br />MyStupidProcedure endp<br />OPTION PROLOGUE:PrologueDef<br />OPTION EPILOGUE:EpilogueDef<br /></code></pre><br /><br />Frank, yea, PROC/ENDP generate stuff, but MASM works using internal macros which can be &quot;turned off&quot; by setting the option to a NONE (empty macro) then resetting the default macro when you&#039;ve finished your procedure. Cool thing about that feature is, it still preforms the argument variable translation for you so the code is still easy to read, you just have to do the stack init/cleanup yourself.<br /><br /><pre><code>;; demo.asm - JWASM Epilogue &amp; Prologue Demo<br />;; Build With:<br />;; jwasm -elf -zcw -Fo=demo.o demo.asm &amp;&amp; gcc -s -nostartfiles -o demo demo.o<br />.386<br />.model flat, C<br />option casemap:none<br /><br />	%include @Environ(JWASM_INC)/jwasm.inc<br /><br />.code<br /><br />OPTION PROLOGUE:NONE<br />OPTION EPILOGUE:NONE<br />Say PROC msg:DWORD<br /><br />	push ebp<br />	mov ebp, esp<br /><br />		invoke puts, msg<br /><br />	leave<br />	ret<br /><br />Say ENDP<br />OPTION EPILOGUE:EpilogueDef<br />OPTION PROLOGUE:PrologueDef<br /><br />main PROC<br />	invoke Say, CTEXT(&quot;Hello, World!&quot;)<br />	xor eax, eax<br />	ret<br />main ENDP<br /><br />_start:<br /><br />	call main<br />	xor ebx, ebx<br />	xor eax, ebx<br />	xor ebx, eax<br />	xor eax, ebx<br />	inc eax<br />	int 80h<br /><br />end _start</code></pre></div>
    <div class="meta">Posted on 2010-10-15 15:22:02 by Synfire</div>
   </div>
   <div class="post" id="post-213355">
    <div class="subject"><a href="#post-213355">Re: The stack</a></div>
    <div class="body">Wot?<br /><br />I hope that&#039;s not supposed to clarify things for a beginner! If we&#039;re going to provide a &quot;fake crt0.o&quot; (the C &quot;startup files&quot;), shouldn&#039;t we fix up the stack before calling main? And what&#039;s that stuff after main returns? What if main doesn&#039;t return zero?<br /><br />I haven&#039;t got any &quot;jwasm.inc&quot; on my system. I can see that, for this program, it needs to include &quot;extern puts&quot;... anything else? (or does Masm/Jwasm spell it &quot;extrn&quot;?)<br /><br />Anyway, maybe Ashken can tell us which assembler he&#039;s using (makes a difference in syntax) and what OS (makes a difference whether we spell it &quot;main&quot; or &quot;_main&quot;), and perhaps we can come up with a more &quot;precise&quot; example that better illustrates the question at hand.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-10-15 17:31:52 by fbkotler</div>
   </div>
   <div class="post" id="post-213356">
    <div class="subject"><a href="#post-213356">Re: The stack</a></div>
    <div class="body"><div class="quote"><br />assuming a C function like<br /><pre><code><br />int f( int x )<br /></code></pre><br />what will be the address of variable x on the stack?? is it ,  , ,??<br /></div><br /><br />Assuming 32-bit machine - <br />However note that most C compilers generate a prologue for each function that performs the following:<br /><br /><pre><code><br />push ebp<br />mov&nbsp; ebp, esp<br /></code></pre><br /><br />Thus you&#039;re most likely going to access your function parameters using ebp:<br /><br />&nbsp;  mov eax, &nbsp; &nbsp; ; get param X<br /><br /></div>
    <div class="meta">Posted on 2010-10-15 18:00:27 by p1ranha</div>
   </div>
   <div class="post" id="post-213357">
    <div class="subject"><a href="#post-213357">Re: The stack</a></div>
    <div class="body"> :lol:<br /><br /><div class="quote"><br />I hope that&#039;s not supposed to clarify things for a beginner! If we&#039;re going to provide a &quot;fake crt0.o&quot; (the C &quot;startup files&quot;), shouldn&#039;t we fix up the stack before calling main? And what&#039;s that stuff after main returns? What if main doesn&#039;t return zero?<br /></div><br /><br />What do is just call an &#039;int main( void )&#039; function I don&#039;t do any argument initialization stuff like that and let GCC know that I don&#039;t want any startup code. On return, anything can be returned, that&#039;s the point of that craziness after the &#039;call main&#039;. Basically it just zeros ebx, swaps the values in ebx and eax (since eax will have our return value from the procedure) then increments eax (which should be zero after the swap). So I&#039;m basically doing sys_exit(main()); so that whatever main returns gets returned to the system... just in my own awkward little way. :lol:<br /><br /><div class="quote"><br />I haven&#039;t got any &quot;jwasm.inc&quot; on my system. I can see that, for this program, it needs to include &quot;extern puts&quot;... anything else? (or does Masm/Jwasm spell it &quot;extrn&quot;?)</div><br /><br />Yea, sorry about that. Force of habbit. The jwasm.inc file is like a wrap-up of all the standard headers (stdio.inc/stdlib.inc/etc.) and my base.mac from my personal include set. The only thing I&#039;m actually using out of it is the CTEXT macro and the prototype for puts.<br /><br /><pre><code>;; demo.asm - JWASM Epilogue &amp; Prologue Demo<br />;; Build With:<br />;; jwasm -elf -zcw -Fo=demo.o demo.asm &amp;&amp; gcc -s -nostartfiles -o demo demo.o<br /><br />.386<br />.model flat, C<br />option casemap:none<br /><br />&nbsp; &nbsp; CTEXT MACRO text:VARARG<br />&nbsp; &nbsp; LOCAL x<br />&nbsp; &nbsp; &nbsp; &nbsp; .CONST<br />&nbsp; &nbsp; &nbsp; &nbsp; IFIDNI &lt;text&gt;,&lt;&gt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x DB 0<br />&nbsp; &nbsp; &nbsp; &nbsp; ELSE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x DB text, 0<br />&nbsp; &nbsp; &nbsp; &nbsp; ENDIF<br />&nbsp; &nbsp; &nbsp; &nbsp; .CODE<br />&nbsp; &nbsp; &nbsp; &nbsp; EXITM &lt;OFFSET x&gt;<br />&nbsp; &nbsp; ENDM<br />&nbsp; &nbsp; puts proto c :DWORD<br /><br />.code<br /><br />OPTION PROLOGUE:NONE<br />OPTION EPILOGUE:NONE<br />Say PROC msg:DWORD<br /><br />&nbsp; &nbsp; push ebp<br />&nbsp; &nbsp; mov ebp, esp<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; invoke puts, msg<br /><br />&nbsp; &nbsp; leave<br />&nbsp; &nbsp; ret<br /><br />Say ENDP<br />OPTION EPILOGUE:EpilogueDef<br />OPTION PROLOGUE:PrologueDef<br /><br />main PROC<br />&nbsp; &nbsp; invoke Say, CTEXT(&quot;Hello, World!&quot;)<br />&nbsp; &nbsp; xor eax, eax<br />&nbsp; &nbsp; ret<br />main ENDP<br /><br />_start:<br /><br />&nbsp; &nbsp; ;; -- Good Demo of Why Commenting is Important Follows......<br />&nbsp; &nbsp; call main<br />&nbsp; &nbsp; xor ebx, ebx&nbsp; ; EBX := 0<br />&nbsp; &nbsp; xor eax, ebx&nbsp; ; <br />&nbsp; &nbsp; xor ebx, eax&nbsp; ; <br />&nbsp; &nbsp; xor eax, ebx&nbsp; ; EBX now holds the return value<br />&nbsp; &nbsp; inc eax&nbsp; &nbsp; &nbsp;  ; SYS_exit<br />&nbsp; &nbsp; int 80h<br /><br />end _start</code></pre></div>
    <div class="meta">Posted on 2010-10-15 19:21:12 by Synfire</div>
   </div>
   <div class="post" id="post-213358">
    <div class="subject"><a href="#post-213358">Re: The stack</a></div>
    <div class="body">Okay, on the assumption that &quot;more is better&quot; (not always true), and keeping in mind that we&#039;re addressing a beginner question...<br /><br /><pre><code><br />&nbsp; &nbsp; ;; -- Good Demo of Why Commenting is Important Follows......<br />&nbsp; &nbsp; call main<br />; suppose main returns 42...<br />&nbsp; &nbsp; xor ebx, ebx&nbsp; ; EBX := 0<br />; xor anything with itself = 0<br />&nbsp; &nbsp; xor eax, ebx&nbsp; ; <br />; eax still 42, ebx still 0<br />&nbsp; &nbsp; xor ebx, eax&nbsp; ; <br />; now ebx = 42 also<br />&nbsp; &nbsp; xor eax, ebx&nbsp; ; EBX now holds the return value<br />; and eax = 0, &#039;cause we xor something with itself!<br />; this is the part I didn&#039;t get, first time through<br />&nbsp; &nbsp; inc eax&nbsp; &nbsp; &nbsp;  ; SYS_exit<br />; SYS_exit is 1<br />&nbsp; &nbsp; int 80h<br />; this is for Linux, for those who don&#039;t know that.<br /></code></pre><br /><br />But maybe what Ashken needs the comments on is:<br /><br /><pre><code><br />OPTION PROLOGUE:NONE<br />OPTION EPILOGUE:NONE<br />Say PROC msg:DWORD<br />; this defines &quot;msg&quot; as &quot;&quot;<br /><br /><br />&nbsp; &nbsp; push ebp<br />&nbsp; &nbsp; mov ebp, esp<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; invoke puts, msg<br />; this is a macro which expands into:<br />; push msg - that is, push <br />; call puts<br />; add esp, 4 ; &quot;remove&quot; one parameter from stack<br /><br />&nbsp; &nbsp; leave<br />; this is not a macro, but a real CPU instruction<br />; it does the same as:<br />; mov esp, ebp<br />; pop ebp<br />; (but does it in just one byte)<br /><br />&nbsp; &nbsp; ret<br /><br />Say ENDP<br />OPTION EPILOGUE:EpilogueDef<br />OPTION PROLOGUE:PrologueDef<br /></code></pre><br /><br />Get into &quot;enter&quot; while we&#039;re here? Naw... ask if you wanna know, Ashken.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-10-15 21:38:37 by fbkotler</div>
   </div>
   <div class="post" id="post-213359">
    <div class="subject"><a href="#post-213359">Re: The stack</a></div>
    <div class="body">How about this...<br /><br /><pre><code>OPTION PROLOGUE:NONE<br />OPTION EPILOGUE:NONE<br />SomeProc PROC arg1:DWORD, arg2:dword<br />LOCAL ddVar1:DWORD<br />LOCAL ddVar2:DWORD<br />&nbsp;  push ebp<br />&nbsp;  mov ebp, esp<br />&nbsp;  sub esp, (4*2)<br /></code></pre><br /><table><tr><td>Reference&nbsp; &nbsp;  </td><td>Base Pointer Relative&nbsp; &nbsp; &nbsp;  </td><td>Stack Pointer Relative</td></tr><br /><tr><td>arg2</td><td>EBP + 12</td><td>ESP + 20</td></tr><br /><tr><td>arg1</td><td>EBP + 8</td><td>ESP + 16</td></tr><br /><tr><td>Ret Addr</td><td>EBP + 4</td><td>ESP + 12</td></tr><br /><tr><td>Old EBP</td><td>EBP + 0</td><td>ESP + 8</td></tr><br /><tr><td>ddVar1</td><td>EBP - 4</td><td>ESP + 4</td></tr><br /><tr><td>ddVar2</td><td>EBP - 8</td><td>ESP + 0</td></tr></table><br /><pre><code>&nbsp;  leave<br />&nbsp;  ret<br />SomeProc ENDP<br />OPTION PROLOGUE:PrologueDef<br />OPTION EPILOGUE:EpilogueDef</code></pre><br /></div>
    <div class="meta">Posted on 2010-10-16 03:04:25 by Synfire</div>
   </div>
   <div class="post" id="post-213360">
    <div class="subject"><a href="#post-213360">Re: The stack</a></div>
    <div class="body">Yeah! Now *that* answers the question! (P1ranha, too). I really thought that Homer made a typo, pushing esp where he meant ebp, and I got kinda sidetracked trying to clear that up...<br /><br />You got it now, Ashken? (you still with us?)<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-10-16 04:20:10 by fbkotler</div>
   </div>
   <div class="post" id="post-213361">
    <div class="subject"><a href="#post-213361">Re: The stack</a></div>
    <div class="body">thanx guys! am getting some concepts but some no!.anyway i just want the basic stuff mostly on interfacing between assembly and C ie calling C routines in ASM and vice versa.am using Nasm and the GCC based DJGPP trying to get a simple &quot;Hello world&quot; program. i&nbsp; tried this<br /><br />NASM<br /><pre><code><br /><br />;<br />;<br />;<br />segment .data<br />param db &quot;%d&quot;,0<br /><br />msg db &quot;Hello world!&quot;,0<br /><br />segment .bss<br />;<br />;<br />segment .text<br /><br />		global _start<br />		extern _printf<br /><br />_start:<br />	push ebp<br />	mov ebp,esp<br />	sub esp,32<br />	pusha<br />	mov ecx,<br />	mov edx,<br />	push ecx <br />	push edx<br /> 	<br />	call _printf<br />	pop edx<br />&nbsp; &nbsp; &nbsp; pop ecx<br />	popa<br />	mov esp,ebp<br />	pop ebp<br /><br /></code></pre>;<br /><br /> and for C<br /><br /><pre><code><br />int main()<br />{<br />&nbsp;  int p;<br />&nbsp;  p = start();<br />&nbsp;  return p;<br />}<br /></code></pre><br /><br />i must be doing alot of things awfully i just got this error<br /><pre><code><br /><br />C:\DOCUME~1\vini\Desktop\src\PCASM~1\prep&gt;gcc -o print.asm print.c<br />print.c:7:2: warning: no newline at end of file<br />c:/djgpp/tmp/ccShjznm.o:print.c:(.text+0x1d): undefined reference to `_start&#039;<br />collect2: ld returned 1 exit status<br /><br /></code></pre><br /><br />Any help!! please!</div>
    <div class="meta">Posted on 2010-10-16 05:04:08 by ashken</div>
   </div>
   <div class="post" id="post-213362">
    <div class="subject"><a href="#post-213362">Re: The stack</a></div>
    <div class="body"><strong>ashken</strong>,<br /><br />Wouldn&#039;t «<strong>gcc -o print.asm</strong>» use <strong>print.asm</strong> as <em>output</em> file name and <em>overwrite</em> it instead of compilation?<br /><br /><strong>popa</strong> retrieves <strong>eax</strong> from stack too, probably clobbering <strong>start()</strong>&#039;s return value.<br /><br />And last, but not least: <strong>how start() is supposed to return back to its caller?</strong></div>
    <div class="meta">Posted on 2010-10-16 06:36:18 by baldr</div>
   </div>
   <div class="post" id="post-213363">
    <div class="subject"><a href="#post-213363">Re: The stack</a></div>
    <div class="body">Yeah... you&#039;ve got a number of small problems, including the ones baldr mentions. They can be fixed.<br /><br /><pre><code><br />;<br />;<br />;<br />segment .data<br />param db &quot;%d&quot;,0<br />; this is to print an integer. use &quot;%s&quot; for a zero-terminated string.<br /><br />msg db &quot;Hello world!&quot;,0<br /><br />segment .bss<br />;<br />;<br />segment .text<br /><br />		global _start<br />; the name &quot;_start&quot; threw me for a loop! In Linux, &quot;_start&quot; is the name known to ld (the linker) as the default entrypoint. It may be okay in DJGPP, I&#039;m not certain. You might want to call it &quot;_my_asm_function&quot; or something...<br /><br />		extern _printf<br /><br />_start:<br />	push ebp<br />	mov ebp,esp<br />	sub esp,32<br />	pusha<br />; The only registers you explicitly use (besides ebp, which you save and restore correctly) are ecx and edx. You&#039;re allowed to trash them both (C calling convention). So you don&#039;t need to do this at all. As baldr points out, the &quot;popa&quot; will trash whatever is in eax - which is the value you want to return!&nbsp; Since you&#039;ve reserved space for a local variable, that can be used to get around the problem. I&#039;ll show you, but I&#039;d just not do &quot;pusha&quot; and &quot;popa&quot;, if I were you. If you alter ebx, esi, or edi, you are expected to save and restore them (C calling convention). Since you don&#039;t...<br /><br />;	mov ecx,<br />; this loads the &quot;&quot; of memory - you want the address! Some assemblers use &quot;offset&quot; here, in Nasm syntax we just do:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx, msg<br /><br />;	mov edx,<br />; same here:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; mov edx, param<br /><br />	push ecx&nbsp; &nbsp;  ; &quot;msg&quot; first<br />	push edx&nbsp; &nbsp;  ; then &quot;param&quot;<br /> 	; you could also have done:<br />&nbsp; &nbsp; &nbsp; &nbsp; ; push msg<br />&nbsp; &nbsp; &nbsp; &nbsp; ; push param<br /><br />	call _printf<br />&nbsp; &nbsp; &nbsp;  ; okay, printf returns number of items printed, as I recall. It&#039;ll be in eax.<br />	pop edx<br />&nbsp; &nbsp; &nbsp; pop ecx<br />&nbsp; &nbsp; &nbsp; ; since we don&#039;t care about the old values of ecx and edx, another way to &quot;balance the stack&quot; (which you need to do - C calling convention)...<br />&nbsp; &nbsp; &nbsp; ; sub esp, 4 * 2&nbsp; ; four bytes per parameter, two parameters<br />&nbsp; &nbsp; &nbsp; ; the two pops are fine here - not as good if you&#039;ve got many parameters<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ; since we&#039;re about to trash eax, we can stash it in a local variable:<br />&nbsp; &nbsp; &nbsp; &nbsp; ; mov , eax<br />	popa<br />&nbsp; &nbsp; &nbsp; &nbsp; ; mov eax, <br />&nbsp; &nbsp; &nbsp; &nbsp; ; as I said, I&#039;d just not pusha/popa, but that saves eax temporarily<br /><br />	mov esp,ebp<br />	pop ebp<br />&nbsp; &nbsp; &nbsp; &nbsp; ; and of course you need a<br />&nbsp; &nbsp; &nbsp; &nbsp; ret ; !<br /></code></pre><br /><br />Now, before we can invoke gcc, we have to assemble this with Nasm - gcc won&#039;t handle it.<br /><br /><pre><code><br />nasm -f coff print.asm<br /></code></pre><br /><br />That should produce &quot;print.obj&quot;, if all goes well. Now gcc was complaining about the lack of a newline in print.c, so you may want to make sure that ends on a blank line, but otherwise I think it&#039;s okay. As baldr points out, the &quot;-o&quot; switch to gcc sets the output file name, so you don&#039;t want the .asm filename there!<br /><br /><pre><code><br />gcc -o print.exe print.obj print.c<br /></code></pre><br /><br />I think that should do it, barring typos, postos, and brainos. :) If not, pay close attention to the error messages. There&#039;s information in &#039;em (honest!).<br /><br /><pre><code><br />C:\DOCUME~1\vini\Desktop\src\PCASM~1\prep&gt;gcc -o print.asm print.c<br />print.c:7:2: warning: no newline at end of file<br /></code></pre><br /><br />&quot;PCASM~1&quot;, eh? Using Dr. Carter&#039;s stuff? The warning isn&#039;t too big a deal (although we should try to avoid &#039;em!). As mentioned, you don&#039;t want &quot;-o print.asm&quot;!<br /><br /><pre><code><br />c:/djgpp/tmp/ccShjznm.o:print.c:(.text+0x1d): undefined reference to `_start&#039;<br />collect2: ld returned 1 exit status<br /></code></pre><br /><br />The undefined reference to &quot;_start&quot; is because you didn&#039;t assemble the .asm file to an .obj file and include it on the command line to gcc. The underscore tells me that djgpp uses an underscore on externals - I should have remembered that, but Linux doesn&#039;t, and I wasn&#039;t sure. And it tells me that &quot;start&quot; is probably going to be an okay name for your function. If it were a &quot;known entrypoint&quot;, as it is in Linux, I would expect &quot;already defined&quot; instead of &quot;undefined reference&quot;. I could be wrong...<br /><br />You might think about giving your function a more descriptive name (I suppose &quot;start&quot; is what you&#039;re doing). Maybe different names for the .c and .asm files, too. I think gcc will handle &quot;print.obj&quot; and &quot;print.c&quot; alright, but you could wind up with &quot;print.obj&quot; overwriting the other &quot;print.obj&quot; if you&#039;re not careful. :)<br /><br />I like names like &quot;mything.asm&quot; and &quot;callmything.c&quot;. but the &quot;~1&quot; in your error messages reminds me that you&#039;re limited to 8.3 filenames in djgpp. See, I told you there was information in &#039;em! :)<br /><br />If you can&#039;t get it working from that, get back to us with details...<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-10-16 08:50:39 by fbkotler</div>
   </div>
   <div class="post" id="post-213364">
    <div class="subject"><a href="#post-213364">Re: The stack</a></div>
    <div class="body">@ashken:<br /><br />According to your first post you have made a question other people did many times before too which doesn&#039;t need to be answered, actually.<br />Why don&#039;t you simply RTFM of your compiler about procedure parameter handling?!<br />I recommend WATCOM, which contains not only a very versatile C/FORTRAN compiler for almost any 16/32bit PC OS, but contains also all documentation about standard procedure parameter calling/return/structures/values... handling and their bending.<br />Download it for free and go through the manuals like I did here: ftp.openwatcom.org</div>
    <div class="meta">Posted on 2010-10-16 15:38:37 by TasmDev</div>
   </div>
   <div class="post" id="post-213365">
    <div class="subject"><a href="#post-213365">Re: The stack</a></div>
    <div class="body"><pre><code>BITS 32<br />EXTERN _printf<br />GLOBAL _SayHello<br />SECTION .text<br />_SayHello:<br />%define _arg1 EBP+8<br />&nbsp;  push ebp<br />&nbsp;  mov ebp, esp<br /><br />&nbsp; &nbsp; &nbsp; push dword [_arg1]<br />&nbsp; &nbsp; &nbsp; push dword dbHelloWorld<br />&nbsp; &nbsp; &nbsp; call _printf<br />&nbsp; &nbsp; &nbsp; add esp, (4 * 2) ; Clean up stack after CDecl Call: (SizeOf(Dword) * ArgumentCount)<br /><br />&nbsp; &nbsp; &nbsp; ;; After a C Function you basically add up all the argument you pass then add that to esp to<br />&nbsp; &nbsp; &nbsp; ;; correct the stack pointer. If you don&#039;t do this, it&#039;ll cause a segmentation fault when the function<br />&nbsp; &nbsp; &nbsp; ;; returns.<br /><br />&nbsp;  leave<br />&nbsp;  ret<br /><br />SECTION .data<br />dbHelloWorld db &quot; %d&quot;, 13, 10, 0<br /></code></pre><br /><br /><pre><code>#include &lt;stdio.h&gt;<br /><br />extern void SayIt( unsigned int );<br /><br />int main( void )<br />{<br />&nbsp;  SayIt(1);<br />&nbsp;  SayIt(2);<br />&nbsp;  SayIt(3);<br />&nbsp;  return(0);<br />}</code></pre><br /><br /><pre><code>CC = gcc<br />AS = nasm<br /><br />CFLAGS = -v -Wal<br />AFLAGS = -f coff<br /><br />all: demo.exe<br />debug: demo.exe ; gdb ./demo.exe<br />demo.exe : demo.c SayHello.o ; $(CC) $(CFLAGS) main.c -o demo.exe SayHello.o<br />SayHello.o : SayHello.asm ; $(AS) $(AFLAGS) SayHello.asm -o SayHello.o</code></pre><br /><br />Use GNU Make to build these (they should do what you want) then run &#039;make debug&#039;. Study what is going on in the debugger. Also, if you are getting used to intel syntax, I suggest modifying gdb to run in intel mode. Try the following .gdbinit script:<br /><br /><pre><code># .gdbinit - GDB Configuration File<br /><br />define bpl<br /> info breakpoints<br />end<br />document bpl<br />list breakpoints<br />end<br /><br />define bp<br /> break * $arg0<br />end<br />document bp<br />set a breakpoint on address<br />usage: bp addr<br />end<br /><br />define bpc <br /> clear $arg0<br />end<br />document bpc<br />clear breakpoint at function/address<br />usage: bpc addr<br />end<br /><br />define bpe<br /> enable $arg0<br />end<br />document bpe<br />enable breakpoint #<br />usage: bpe num<br />end<br /><br />define bpd<br /> disable $arg0<br />end<br />document bpd<br />disable breakpoint #<br />usage: bpd num<br />end<br /><br />define bpt<br /> tbreak $arg0<br />end<br />document bpt<br />set a temporary breakpoint on address<br />usage: bpt addr<br />end<br /><br />define bpm<br /> awatch $arg0<br />end<br />document bpm<br />set a read/write breakpoint on address<br />Usage: bpm addr<br />end<br /><br />define syntax<br />&nbsp; &nbsp; set disassembly-flavor $arg0<br />end<br />document syntax<br />sets the current assembly syntax<br />usage: syntax <br />end<br /><br />define regs<br />&nbsp; &nbsp; printf &quot;\t--------------------------------\n&quot;<br />&nbsp; &nbsp; printf &quot;\teax: 0x%08X\tebx: 0x%08X\n&quot;, $eax, $ebx<br />&nbsp; &nbsp; printf &quot;\tecx: 0x%08X\tedx: 0x%08X\n&quot;, $ecx, $edx<br />&nbsp; &nbsp; printf &quot;\tedi: 0x%08X\tesi: 0x%08X\n&quot;, $edi, $esi<br />&nbsp; &nbsp; printf &quot;\tesp: 0x%08X\tebp: 0x%08X\n&quot;, $esp, $ebp<br />&nbsp; &nbsp; printf &quot;\teip: 0x%08X\n&quot;, $eip<br />&nbsp; &nbsp; printf &quot;\t--------------------------------\n&quot;<br />&nbsp; &nbsp; printf &quot;\tcs:&nbsp; 0x%04X\tds:&nbsp; 0x%04X\n&quot;, $cs, $ds<br />&nbsp; &nbsp; printf &quot;\tes:&nbsp; 0x%04X\tfs:&nbsp; 0x%04X\n&quot;, $es, $fs<br />&nbsp; &nbsp; printf &quot;\tgs:&nbsp; 0x%04X\tss:&nbsp; 0x%04X\n&quot;, $gs, $ss<br />&nbsp; &nbsp; printf &quot;\t--------------------------------\n&quot;<br />&nbsp; &nbsp; printf &quot;\t\tODITSZ_A_P_C\n\t\t&quot;<br />&nbsp; &nbsp; if (($eflags &gt;&gt; 0xB) &amp; 1)<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;1&quot;<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;0&quot;<br />&nbsp; &nbsp; end<br />&nbsp; &nbsp; if (($eflags &gt;&gt; 0xA) &amp; 1)<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;1&quot;<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;0&quot;<br />&nbsp; &nbsp; end<br />&nbsp; &nbsp; if (($eflags &gt;&gt; 9) &amp; 1)<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;1&quot;<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;0&quot;<br />&nbsp; &nbsp; end<br />&nbsp; &nbsp; if (($eflags &gt;&gt; 8) &amp; 1)<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;1&quot;<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;0&quot;<br />&nbsp; &nbsp; end<br />&nbsp; &nbsp; if (($eflags &gt;&gt; 7) &amp; 1)<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;1&quot;<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;0&quot;<br />&nbsp; &nbsp; end<br />&nbsp; &nbsp; if (($eflags &gt;&gt; 6) &amp; 1)<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;1&quot;<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;0&quot;<br />&nbsp; &nbsp; end<br />&nbsp; &nbsp; if (($eflags &gt;&gt; 5) &amp; 1)<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;1&quot;<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;0&quot;<br />&nbsp; &nbsp; end<br />&nbsp; &nbsp; if (($eflags &gt;&gt; 4) &amp; 1)<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;1&quot;<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;0&quot;<br />&nbsp; &nbsp; end<br />&nbsp; &nbsp; if (($eflags &gt;&gt; 3) &amp; 1)<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;1&quot;<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;0&quot;<br />&nbsp; &nbsp; end<br />&nbsp; &nbsp; if (($eflags &gt;&gt; 2) &amp; 1)<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;1&quot;<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;0&quot;<br />&nbsp; &nbsp; end<br />&nbsp; &nbsp; if (($eflags &gt;&gt; 1) &amp; 1)<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;1&quot;<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;0&quot;<br />&nbsp; &nbsp; end<br />&nbsp; &nbsp; if ($eflags &amp; 1)<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;1&quot;<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; printf &quot;0&quot;<br />&nbsp; &nbsp; end<br />&nbsp; &nbsp; printf &quot; = 0x%08X\n&quot;, $eflags<br />end<br />document regs<br />displays the cpu registers<br />end<br /><br />define proc<br />&nbsp; &nbsp; info stack<br />&nbsp; &nbsp; info frame<br />&nbsp; &nbsp; info args<br />&nbsp; &nbsp; info locals<br />end<br />document proc<br />displays a lot of information about the current procedure<br />end<br /><br />define procs<br />&nbsp; &nbsp; info functions<br />end<br />document procs<br />list all procedures in current process<br />end<br /><br />define stack<br />&nbsp; &nbsp; info stack<br />end<br />document stack<br />displays the call stack<br />end<br /><br />define vars<br />&nbsp; &nbsp; info variables<br />end<br />document vars<br />display the variables in the current process<br />end<br /><br />define libs<br />&nbsp; &nbsp; info sharedlibrary<br />end<br />document libs<br />display shared libraries linked into the target<br />end<br /><br />define sigs<br />&nbsp; &nbsp; info signals<br />end<br />document sigs<br />display signal actions for target<br />end<br /><br />define threads<br />&nbsp; &nbsp; info threads<br />end<br />document threads<br />display threads in target<br />end<br /><br />define dasm<br />&nbsp; &nbsp; disassemble $arg0<br />end<br />document dasm<br />disassemble code at address/label<br />usage: dasm <br />end<br /><br />define start<br />&nbsp; &nbsp; tbreak _start<br />&nbsp; &nbsp; run<br />end<br />document start<br />run program; break on _start<br />end<br /><br />define init<br />&nbsp; &nbsp; tbreak _init<br />&nbsp; &nbsp; run<br />end<br />document init<br />run program; break on _init<br />end<br /><br />define main<br />&nbsp; &nbsp; tbreak main<br />&nbsp; &nbsp; run<br />end<br />document main<br />run program; break on _main<br />end<br /><br />define lsmain<br />&nbsp; &nbsp; tbreak __libc_start_main<br />&nbsp; &nbsp; run<br />endm<br />document lsmain<br />run program; break on __libc_start_main<br />end<br /><br /># Asm Simulations<br /><br />define tcf<br />&nbsp; &nbsp; if ( $eflags &amp; 1 )<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags &amp;~ 1<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags | 1<br />&nbsp; &nbsp; end<br />end<br />document tcf<br />toggle carry flag<br />end<br /><br />define tpf<br />&nbsp; &nbsp; if ( ($eflags &gt;&gt; 2) &amp; 1 )<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags &amp;~ 0x4<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags | 0x4<br />&nbsp; &nbsp; end<br />end<br />document tpf<br />toggle parity flag<br />end<br /><br />define taf<br />&nbsp; &nbsp; if ( ($eflags &gt;&gt; 4) &amp; 1)<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags &amp;~ 0x10<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags | 0x10<br />&nbsp; &nbsp; end<br />end<br />document taf<br />toggle auxiliary flag<br />end<br /><br />define tzf<br />&nbsp; &nbsp; if ( ($eflags &gt;&gt; 6) &amp; 1 )<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags &amp;~ 0x40<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags | 0x40<br />&nbsp; &nbsp; end<br />end<br />document tzf<br />toggle zero flag<br />end<br /><br />define tsf<br />&nbsp; &nbsp; if ( ($eflags &gt;&gt; 7) &amp; 1 )<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags &amp;~ 0x80<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags | 0x80<br />&nbsp; &nbsp; end<br />end<br />document tsf<br />toggle sign flag<br />end<br /><br />define ttf<br />&nbsp; &nbsp; if ( ($eflags &gt;&gt; 8) &amp; 1 )<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags &amp;~ 0x100<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags | 0x100<br />&nbsp; &nbsp; end<br />end<br />document ttf<br />toggle trap flag<br />end<br /><br />define tif<br />&nbsp; &nbsp; if ( ($eflags &gt;&gt; 9) &amp; 1 )<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags &amp;~ 0x200<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags | 0x200<br />&nbsp; &nbsp; end<br />end<br />document tif<br />toggle interrupt flag<br />end<br /><br />define tdf<br />&nbsp; &nbsp; if ( ($eflags &gt;&gt; 0xA) &amp; 1 )<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags &amp;~ 0x400<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags | 0x400<br />&nbsp; &nbsp; end<br />end<br />document tdf<br />toggle direction flag<br />end<br /><br />define tof<br />&nbsp; &nbsp; if ( ($eflags &gt;&gt; 0xB) &amp; 1 )<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags &amp;~ 0x800<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp; set $eflags = $eflags | 0x800<br />&nbsp; &nbsp; end<br />end<br />document tof<br />toggle overflow flag<br />end<br /><br />define pb<br />&nbsp; &nbsp; set * (unsigned char *) $arg0 = $arg1<br />end<br />document pb<br />patch byte at address to value<br />usage: pb addr val<br />end<br /><br />define pw<br />&nbsp; &nbsp; set * (unsigned short int *) $arg0 = $arg1<br />end<br />document pw<br />patch word at address to value<br />usage: pw addr val<br />end<br /><br />define pd<br />&nbsp; &nbsp; set * (unsigned long int *) $arg0 = $arg1<br />end<br />document pd<br />patch dword at address to value<br />usage: pd addr val<br />end<br /><br /># configuration defaults<br />set disassembly-flavor intel<br />set prompt \033[36m\033[39m\n:&nbsp; \b</code></pre><br /><br />I&#039;m sure if you play around with GDB and the source, (and re-read some of these posts) you&#039;ll definitely get whats going on. You&#039;re almost there man! Hang in there. :)<br /><br />Regards,<br />Bryant Keller</div>
    <div class="meta">Posted on 2010-10-16 15:55:02 by Synfire</div>
   </div>
   <div class="post" id="post-213366">
    <div class="subject"><a href="#post-213366">Re: The stack</a></div>
    <div class="body">@ Frank, Homer and all the guys who have spent their precious time to help me out, thank you guys.you have given me what i wanted, i asked for a sandwich and you gave me just.your cutting edge solutions have solved my particular problem.Despite the fact that you knew compiler manuals existed, you didn&#039;t RTFM me and for that, maximum RESPECT!!!<br /><br />oh! as for my first code which has lots of errors. i build it and it gave me a segmentation fault.<br /><pre><code><br />Microsoft Windows XP <br />(C) Copyright 1985-2001 Microsoft Corp.<br /><br />C:\Documents and Settings\vini\Desktop\src\PC ASM\prep&gt;print<br />Exiting due to signal SIGSEGV<br />General Protection Fault at eip=00006666<br />eax=48006425 ebx=00000000 ecx=00000011 edx=48006425 esi=00000054 edi=0000f588<br />ebp=0008f4e0 esp=0008e0bc program=C:\DOCUME~1\VINI\DESKTOP\SRC\PCASM~1\PREP\PRIN<br />T.EXE<br />cs: sel=01a7 &nbsp;base=02980000 &nbsp;limit=0009ffff<br />ds: sel=01af &nbsp;base=02980000 &nbsp;limit=0009ffff<br />es: sel=01af &nbsp;base=02980000 &nbsp;limit=0009ffff<br />fs: sel=017f &nbsp;base=000057a0 &nbsp;limit=0000ffff<br />gs: sel=01bf &nbsp;base=00000000 &nbsp;limit=0010ffff<br />ss: sel=01af &nbsp;base=02980000 &nbsp;limit=0009ffff<br />App stack: [0008f588..0000f588] &nbsp;Exceptn stack: [0000f4e8..0000d5a8]<br /><br />Call frame traceback EIPs:<br /> &nbsp;0x00006666<br /> &nbsp;0x000031d6<br /> &nbsp;0x000015fd<br /> &nbsp;0x00001631<br /> &nbsp;0x00002dd8<br /><br />C:\DOCUME~1\vini\Desktop\src\PCASM~1\prep&gt;<br /></code></pre></div>
    <div class="meta">Posted on 2010-10-16 16:18:45 by ashken</div>
   </div>
   <div class="post" id="post-213367">
    <div class="subject"><a href="#post-213367">Re: The stack</a></div>
    <div class="body">Just a few notes about your previous code....<br /><br /><pre><code>segment .data<br /><br />	param db &quot;%s&quot;,0 ; FIXED: %d is for integers, %s is for strings.<br />	msg db &quot;Hello world!&quot;,0<br /><br />;; This isn&#039;t needed, you&#039;re not using a BSS section.<br />;segment .bss<br /><br />segment .text<br /><br />		global _Entry<br />		extern _printf<br /><br />;; I&#039;m not comfortable with this name, Lets change it to Entry<br />;_start:<br />_Entry:<br />	push ebp<br />	mov ebp,esp<br />	;; Why do you allocate local variables at all?<br />	;; You&#039;re not using any. Again, unneeded.<br />	;sub esp,32<br /><br />	pusha<br /><br />		mov ecx, msg ; FIXED: We want the ADDRESS of the label, not the contents of the memory.<br />		mov edx, param ; FIXED: We want the ADDRESS of the label, not the contents of the memory.<br />		push ecx <br />		push edx<br />		call _printf<br />		pop edx<br />		pop ecx<br />		;; This could easily be done with ADD ESP, (4 * 2)<br /><br />	popa<br /><br />	mov esp,ebp<br />	pop ebp<br /><br />	;; FIXED: You are missing a RETurn here.<br />	ret</code></pre><br /><br />Read the comments, there are a few places where things could have gone wrong, most likely the &quot;FIXED&quot; sections. I&#039;ve made a few other modifications simply because I don&#039;t feel comfortable re-releasing the code without pointing out the issues with them. :p</div>
    <div class="meta">Posted on 2010-10-16 16:45:30 by Synfire</div>
   </div>
   <div class="post" id="post-213368">
    <div class="subject"><a href="#post-213368">Re: The stack</a></div>
    <div class="body">Just on inspection... &quot;unresolved external _SayIt&quot;... (since the global function in the .asm file is called &quot;_SayHello&quot;...) :) The fix is obvious. Nice example, as it shows passing a parameter, which we weren&#039;t doing. The &quot;.gdbinit&quot; should be a big help!<br /><br />TasmDev, why do you think Watcom is superior to gcc? Oh, I know - Tasm won&#039;t produce COFF. Easily fixed - http://www.nasm.us :) If you try it, Ashken, trailing underscores, not leading... Nice compiler, but a little &quot;oddball&quot;.<br /><br />SIGSEGV at 0x00006666 - jeez, it&#039;s the number of the beast on steroids! :) Almost certainly failure to &quot;clean up&quot; the stack properly somewhere, I would guess... Lack of the &quot;ret&quot; would do it, also. If you can&#039;t fix it, post the exact code that produced it.<br /><br />As for RTFM, excellent advice! Puts *me* to sleep, though... :)<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-10-16 19:56:42 by fbkotler</div>
   </div>
   <div class="post" id="post-213369">
    <div class="subject"><a href="#post-213369">Re: The stack</a></div>
    <div class="body">I&#039;m going to have to get sp00k to install an &quot;asshat counter&quot; on the forum for me so I can keep track of how many times I&#039;ve built something that worked fine, then made a last minute change (like modifying the name of a procedure or removing a macro) that has completely fubar the source. lmfao&nbsp; 8) Thanks for the catch man. The &quot;SayIt&quot;&#039;s should definitely be &quot;SayHello&quot;&#039;s, lol.</div>
    <div class="meta">Posted on 2010-10-16 21:13:42 by Synfire</div>
   </div>
  </div>
 </body>
</html>