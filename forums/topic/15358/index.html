<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Size optimized message handling. - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=15358" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=15358">Size optimized message handling.</a></p>
   <div class="post" id="post-119341">
    <div class="subject"><a href="#post-119341">Size optimized message handling.</a></div>
    <div class="body">Hi all.<br /><br />I am playing these days with some ideas about message handling procedures. Here is the last I write. The main idea is to avoid using of cmp/je series to determine what message we have and where to go to handle it, because this cost approx. 10..13 bytes per message whatevery we use &quot;cmp , WM_SOMETHING&quot; or &quot;cmp eax, WM_SOMETHING&quot;. My method use table with 4 bytes per message and subroutine 28 bytes long. Only restriction is that branch must be in bounds of 64kbytes.<br /><br />I am not very strong in speed optimizations and any opinion about this approach:  speed, cache, branch prediction, possible hidden problems, etc.  will be very helpfull.<br /><br />The source is in FASM format but I think it is readable for everyone.<br /><br /><pre><code><br />macro MessageList default, &#91;message, msghandler&#93; &#123;<br />  forward<br />        dw message, msghandler - $ - 2<br />  common<br />        dw 0, default - $ - 2<br />&#125;<br /><br /><br />;------------------------------------------------------<br />; proc JumpTo<br />; Searches for the message in the message table.<br />; Arguments&#58;<br />;   eax - message number to search in the table.<br />; Returns&#58;<br />;   ebx - address of the handler.<br />; Uses&#58;<br />;   ebx, edx - there is no need to preserve ebx,<br />;              because this procedure is for use<br />;              in message handlers where ebx is<br />;              preserved on the input.<br />;------------------------------------------------------<br />JumpTo&#58;<br />        mov     edx, &#91;esp&#93; ; get table address<br />        add     esp, 4  ; remove return address from stack.<br />.loop&#58;<br />        mov     ebx, &#91;edx&#93;<br />        add     edx, 4<br />        test    bx,bx<br />        jz      .exit<br /><br />        cmp     bx, ax<br />        jne     .loop<br /><br />.exit&#58;<br />        shr     ebx, 16<br />        add     ebx, edx<br />        jmp     ebx<br /><br />&#91;b&#93;Using&#58;&#91;/b&#93;<br />proc SizerWinProc, hwnd, wmsg, wparam, lparam<br />        enter<br />        push    esi edi ebx<br /><br />        mov  eax, &#91;wmsg&#93;<br />        call JumpTo<br />        MessageList .default,                   \<br />          WM_CREATE,            .create,        \<br />          WM_DESTROY,           .destroy,       \<br />          WM_MOVE,              .move,          \<br />          WM_PAINT,             .paint,         \<br />          WM_MOUSEMOVE,         .mousemove,     \<br />          WM_LBUTTONDOWN,       .buttondown,    \<br />          WM_LBUTTONUP,         .buttonup,      \<br />          WM_SETCURSOR,         .setcursor<br />....................<br /></code></pre></div>
    <div class="meta">Posted on 2003-09-25 00:45:00 by JohnFound</div>
   </div>
   <div class="post" id="post-119356">
    <div class="subject"><a href="#post-119356">Size optimized message handling.</a></div>
    <div class="body">Hi, <strong>JohnFound </strong><br />Cool idea to use 16 bit address :)<br /><br />imho, optimizing calls to Win API for speed is waste of time :confused: <br /><br />May be just avoid using of 16bit opcodes<br />And some aligment for table would be nice if it is big in size.<br /><pre><code>JumpTo&#58;<br />mov     edx, &#91;esp&#93; ; get table address<br />add     edx, 3<br />and     edx, -4<br /><br />.......<br /><br />call JumpTo<br />align 4<br />MessageList .default,   <br /></code></pre></div>
    <div class="meta">Posted on 2003-09-25 03:46:26 by S.T.A.S.</div>
   </div>
   <div class="post" id="post-119359">
    <div class="subject"><a href="#post-119359">Size optimized message handling.</a></div>
    <div class="body">Hi S.T.A.S.<br /><br />About Align, I simply don't know. Actually aligning is speed optimization... What will be the advantage of using align?</div>
    <div class="meta">Posted on 2003-09-25 04:01:34 by JohnFound</div>
   </div>
   <div class="post" id="post-119434">
    <div class="subject"><a href="#post-119434">Size optimized message handling.</a></div>
    <div class="body">OK, now one byte less in JumpTo procedure. :) Only difference is that default processing must be imediate after MessageList definition.<br />Come on, I actually need some criticism. Or you think all I write is masterpiece?  :grin: <br /><br /><pre><code><br />macro MessageList &#91;message, msghandler&#93; &#123;<br />  forward<br />        dw message, msghandler - $ - 2<br />  common<br />        dd 0<br />&#125;<br /><br />;------------------------------------------------------<br />; proc JumpTo<br />; Searches for the message in the message table.<br />; defined with MessageList macro.<br />; Arguments&#58;<br />;   eax - message number to search in the table.<br />;------------------------------------------------------<br />JumpTo&#58;<br />        mov     edx, &#91;esp&#93; ; get table address<br />        add     esp, 4  ; remove return address from stack.<br />.loop&#58;<br />        mov     ebx, &#91;edx&#93;<br />        add     edx, 4<br />        test    ebx,ebx<br />        jz      .exit<br /><br />        cmp     bx, ax<br />        jne     .loop<br /><br />.exit&#58;<br />        shr     ebx, 16<br />        add     ebx, edx<br />        jmp     ebx<br /><br />; How to use&#58;<br /><br />        mov     eax, &#91;wmsg&#93;<br />        call    JumpTo<br />        MessageList                                     \<br />            WM_CREATE,          .create,          \<br />            WM_DESTROY,         .destroy,       \<br />            WM_NOTIFY,          .notify<br /><br />        invoke  DefWindowProc, &#91;hwnd&#93;, &#91;wmsg&#93;, &#91;wparam&#93;, &#91;lparam&#93;<br /></code></pre></div>
    <div class="meta">Posted on 2003-09-25 10:16:25 by JohnFound</div>
   </div>
   <div class="post" id="post-119526">
    <div class="subject"><a href="#post-119526">Size optimized message handling.</a></div>
    <div class="body">Hi <strong>JohnFound </strong><br /><br />Alignment is usefull when we're reading dwords from memory, because CPU is optimized to read them from adreses like (0XXXXXXXXh &amp; 0FFFFFFFC).  Though, it can waste up to 3 bytes of memory</div>
    <div class="meta">Posted on 2003-09-25 20:27:16 by S.T.A.S.</div>
   </div>
   <div class="post" id="post-119528">
    <div class="subject"><a href="#post-119528">Size optimized message handling.</a></div>
    <div class="body">The Intel Optimization manual says that &quot;significant perfomance penalties&quot; can be incurred if data is misaligned:<br /><div class="quote"><strong>Assembly/Compiler Coding Rule 17</strong><br />Align data on natural operand size address boundaries. If the data will be accessed with vector instruction loads and stores, align the data on 16 byte boundaries.<br /><br />For best performance, align the data as follows:<br /><ul>[*]Align 8-bit data at any address<br />[*]Align 16-bit data to be contained within an aligned four byte word<br />[*]Align 32-bit data so that it's base address is a multiple of four<br />[*]Align 64-bit data so that it's base address is a multiple of eight<br />[*]Align 80-bit data so that it's base address is a multiple of sixteen<br />[*]Align 128-bit data so that it's base address is a multiple of sixteen<br />A 64-byte or greater data structure or array should be aligned so that it's base address is a multiple of 64. Sorting data in decreasing size order is one heuristic for assisting with natural alignment. As long as 16-byte boundaries (and cache lines) are never crossed, natural alignment is not strictly necessary, though it is an easy way to enforce this.</div></div>
    <div class="meta">Posted on 2003-09-25 20:53:54 by donkey</div>
   </div>
   <div class="post" id="post-119531">
    <div class="subject"><a href="#post-119531">Size optimized message handling.</a></div>
    <div class="body">If you process many messages <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=14107">( this )</a> method will only cost a couple bytes more and maybe faster, but the table is a little harder to generate.  If you are optimizing for size:<pre><code>        mov     edx, &#91;esp&#93; ; get table address<br />        add     esp, 4  ; remove return address from stack.</code></pre>...is the same as POP EDX.</div>
    <div class="meta">Posted on 2003-09-25 21:13:13 by bitRAKE</div>
   </div>
   <div class="post" id="post-119538">
    <div class="subject"><a href="#post-119538">Size optimized message handling.</a></div>
    <div class="body">Since the dispatch code is in a subroutine, the cost of the method is 4 bytes per message + 8 bytes per wndproc. The subroutine is a fixed (constant) overhead sizewise.<br /><br />Here is another search table approach...<br /><pre><code>  .code<br />   mov eax,uMsg               ; make the message ID a sentinel<br />   mov jtable,eax             ;   by storing it at start of table<br />   mov esi,offset end_jtable  ; point past end of table<br />jloop&#58;<br />   sub esi,8                  ; search backwards<br />   cmp eax,&#91;esi&#93;              ; check for matching message number<br />   jne jloop                  ; repeat if not a match<br />   jmp dword ptr &#91;esi+4&#93;      ; dispatch to message handler<br /><br />  .data<br />jtable label dword<br />   dd 0, doDefault            ; message ID set before search starts<br />   dd WM_DESTROY, doDestroy<br />   dd WM_CLOSE, doClose<br />end_jtable equ $<br /></code></pre>The cost is 13 bytes of setup, 7 bytes in the loop, 3 bytes of dispatch, 8 bytes per message.</div>
    <div class="meta">Posted on 2003-09-25 22:27:23 by tenkey</div>
   </div>
   <div class="post" id="post-119539">
    <div class="subject"><a href="#post-119539">Size optimized message handling.</a></div>
    <div class="body"><div class="quote"><br />The Intel Optimization manual says that &quot;significant perfomance penalties&quot; can be incurred if data is misaligned:<br /> </div><br /><br />Donkey, you are right, i read this too. But I wondering is this is reasonable in message processing, because it is slow process in generaly. Did, someone have any info, based on benchmarking/tests, how the speed of message handlers affects performance of the application in Windows. I can't figure out how to measure the performance in this case. Any ideas?<br /><br />bitRAKE: Of course you are right about &quot;pop edx&quot; and I am stupid here. :(  The good news is that now JumpTo is 22 bytes only. :) About binary tree - you know, usually we have max 20..30..40 messages to process. Do you think it is reasonable to use this method?</div>
    <div class="meta">Posted on 2003-09-25 22:27:40 by JohnFound</div>
   </div>
   <div class="post" id="post-119540">
    <div class="subject"><a href="#post-119540">Size optimized message handling.</a></div>
    <div class="body"><div class="quote"><br />About binary tree - you know, usually we have max 20..30..40 messages to process. Do you think it is reasonable to use this method? </div>No, it is not reasonable - as I have stated in that thread.  Just think of the cache misses in normal use.  Some testing has to be done to see where the turn over point is - how many messages would it take to make branching a faster method.  And it would be different for each CPU!</div>
    <div class="meta">Posted on 2003-09-25 22:35:08 by bitRAKE</div>
   </div>
   <div class="post" id="post-119542">
    <div class="subject"><a href="#post-119542">Size optimized message handling.</a></div>
    <div class="body">With some registers use change and string operations - 18 bytes for JumpTo procedure.<br /><pre><code>;------------------------------------------------------<br />; proc JumpTo<br />; Searches for the message in the message table.<br />; Arguments&#58;<br />;   ebx - message number to search in the table.<br />; Uses&#58;<br />;   eax, esi<br />;------------------------------------------------------<br />JumpTo&#58;<br />        pop     esi     ; get table address and remove return<br />                        ; address from the stack.<br />.loop&#58;<br />        lodsd<br />        test    eax,eax<br />        jz      .exit<br /><br />        cmp     bx, ax<br />        jne     .loop<br /><br />        shr     eax, 16<br />        add     esi, eax<br />.exit&#58;<br />        jmp     esi</code></pre><br /><br />bitRAKE, I am agree that I have to make some tests, but I can't figure out how to test the message processing speed for normal application. I don't want to make some mass message sending and to make time measure, because this will not give real results. I can make two variants of the same program - one with classic and one with table message processing, but how to test?<br /><br />Regards.</div>
    <div class="meta">Posted on 2003-09-25 23:50:54 by JohnFound</div>
   </div>
   <div class="post" id="post-119548">
    <div class="subject"><a href="#post-119548">Size optimized message handling.</a></div>
    <div class="body">To build the test you can &quot;record&quot; a real message loop and &quot;play back&quot; the values to the test routines.  Another option would be to generate the test data based on a computational model (could include random bits).</div>
    <div class="meta">Posted on 2003-09-26 00:53:42 by bitRAKE</div>
   </div>
   <div class="post" id="post-119659">
    <div class="subject"><a href="#post-119659">Size optimized message handling.</a></div>
    <div class="body">I can't understand your Balkan logic...<br />Are you an expert or just a newbie?<br /><br />&quot;But I wondering is this is reasonable in message processing, because<strong> it is slow process<br /> in generally.</strong>&quot;<br /><br /> It seems you are an expert here<br /><br /><br />&quot;Did, someone have any info, based on benchmarking/tests, how the speed of message<br /> handlers affects performance of the application in Windows.<br /><strong>I can't figure out how to measure the performance</strong> in this case. Any ideas?&quot;<br /><br />Here you just deny that &quot;<strong>it is slow process in generally</strong>&quot; and<br />it seems you are not an expert here<br /><br /><br />&quot;The good news is that now JumpTo is 22 bytes only.&quot;<br /><br />Who cares that your JumpTo is blab, bla bytes only<br />What about blah, bla bytes for  whole proc<br />Where is pop esi edi ebx ret and why you need proc and enter<pre><code><br />Using&#58;<br />proc SizerWinProc, hwnd, wmsg, wparam, lparam<br />        enter<br />        push    esi edi ebx<br /><br />        mov  eax, &#91;wmsg&#93;<br />        call JumpTo<br />        MessageList .default,  </code></pre>  <br /><br />&quot;My method use table with 4 bytes per message and subroutine 28 bytes long.&quot;<br /><br />Why do you use esi, edi,ebx ; preserve and restore them later<br />May be to use later lodsd (1 byte) and it is &quot;your method&quot; for<br />&quot;size optimization&quot;<br /><br /><br />&quot;Or you think all I write is masterpiece? &quot;<br />No, it is just a &quot;lame&quot; code<br />I assume you play with code for fun only and will be better<br />to search the forum for better examples<br /><br />Here is my &quot;master&quot; code: <pre><code><br />WndProc&#58;<br />	mov	eax, &#91;esp+2*4&#93;	; eax=uMsg stack param<br />	cmp	eax, bigMess	; bigMess = message with <br />	sbb	edx, edx	;     the biggest number +1	<br />	and	eax, edx	; The dword ptr &#91;TableProc+0*4&#93; is a<br />	jmp	dword ptr &#91;TableProc+eax*4&#93;	; pointer to DefWindowProc</code></pre><br /><br />&quot;Come on, I actually need some criticism.&quot;<br /> <br />Is it enough criticism for you?</div>
    <div class="meta">Posted on 2003-09-26 18:14:04 by lingo12</div>
   </div>
  </div>
 </body>
</html>