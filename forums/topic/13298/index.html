<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>FFT and IFFT for MASM - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=13298" />
    <link rel="next" href="../?id=13298&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=13298">FFT and IFFT for MASM</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=13298&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=13298&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="13298" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=13298&amp;page=2">&gt;</a><a href="../?id=13298&amp;page=2">&raquo;</a></form>   <div class="post" id="post-103100">
    <div class="subject"><a href="#post-103100">FFT and IFFT for MASM</a></div>
    <div class="body">Well after alot of hair pulling and only one migrane headache, I have a tested and fully opreating FFT algorithm for everyone to enjoy.  I plan to use this with some DSP work using the microphone but for anyone else's use, here it is:<pre><code>&#91;size=9&#93;<br />;_______________________________________<br />; FFT                                                                     Ver 1.2<br />; by NaN / Jaymeson Trudgen                                          May 12, 2003<br />;<br />; Written exclusively for the MASM32 assembly package maintained by Hutch--<br />; This algorithm is based on the Danielson-Lanczos algorithm.<br />;<br />; Inputs&#58;<br />;<br />;   lp_data    - A complex array of data to forward or resverse fourier transform<br />;                Real values are indexed evenly   &#40;0,2,4,6,..,N-2&#41;<br />;                Imaginary values are index oddly &#40;1,3,5,7,..,N-1&#41;<br />;                All array values are QWORD length, hence a complex value is 16 bytes.<br />;<br />;   nn         - Number of COMPLEX data points. For data array lenghts of N, this<br />;                Value MUST be N/2 AND EQUAL TO 2^k where k = positive integer<br />;                &#40;1,2,4,8,16,32,64,....,etc&#41;.  Note&#58; Padd data with zeros to fit<br />;                to one of these array sizes if not an exact fit.<br />;<br />;   isign      - THIS TERM IN NOT CHECK FOR ACCURACY AND CAN CORRUPT RESULTS IF<br />;                ANY OTHER VALUE THAN +1 or -1 IS PROVIDED.<br />;                +1 = Forward FFT &#40;time domain data -&gt; frequency domain data&#41;<br />;                -1 = Reverse FFT &#40;frequency domain data -&gt; time domain data&#41;<br />;<br />;   Normalize  - If this term is +1, then the output from a forward FFT will have<br />;                its energy content normalized to the width of the frequency <br />;                domain.  This should be done for purely scientific work, however<br />;                some DSP work may not require this at some stages.  For this<br />;                reason control has been provided to keep the algorithm as fast<br />;                as possible.<br />;<br />;<br />;  Visit the first and best Win32ASM community&#58;<br />;<br />;                &#91;url&#93;http&#58;//www.asmcommunity.net/board/&#91;/url&#93;<br />; <br />;_______________________________________<br />FFT PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD, &#58;DWORD<br /><br />.data<br />   NaNTwoPie   dq    -6.28318530717959<br />   <br />.code<br />   <br />FFT   PROC  USES EBX ESI EDI  lp_data&#58;DWORD, nn&#58;DWORD, isign&#58;DWORD, Normalize&#58;DWORD<br />      LOCAL fpu_temp &#58;DWORD<br />      LOCAL _n       &#58;DWORD<br />      LOCAL _n1      &#58;DWORD<br />      LOCAL mmax     &#58;DWORD<br />      LOCAL _m       &#58;DWORD<br />      LOCAL istep    &#58;DWORD<br />      LOCAL wr       &#58;QWORD<br />      LOCAL wpr      &#58;QWORD<br />      LOCAL wpi      &#58;QWORD<br />      LOCAL wi       &#58;QWORD<br />      LOCAL tempr    &#58;QWORD<br />      LOCAL tempi    &#58;QWORD<br />      <br />      finit<br />      <br />      mov eax, nn                         ; n=nn &lt;&lt; 1;<br />      shl eax, 1<br />      mov _n, eax<br /><br />      mov _n1, eax<br />      dec _n1<br />      <br />      xor esi, esi                        ; j=1;<br />      <br />      ; This is the bit-reversal section of the routine.<br /><br />      mov ebx, esi                        ; for &#40;i=1;i&lt;n;i+=2&#41;  NOTE&#58; EBX == i = 1<br /><br />      .while&#40; ebx &lt; _n1 &#41;<br />         <br />         .if&#40; esi &gt; ebx &#41;                 ; if &#40;j &gt; i&#41;<br /><br />            mov edx, lp_data<br />            fld  QWORD PTR &#91;edx+esi*8&#93;    ; SWAP&#40;data&#91;j&#93;,data&#91;i&#93;&#41;<br />            fld  QWORD PTR &#91;edx+ebx*8&#93;<br />            fstp QWORD PTR &#91;edx+esi*8&#93;<br />            fstp QWORD PTR &#91;edx+ebx*8&#93;<br /><br />            inc esi<br />            inc ebx<br /> <br />            fld  QWORD PTR &#91;edx+esi*8&#93;    ; SWAP&#40;data&#91;j+1&#93;,data&#91;i+1&#93;&#41;;<br />            fld  QWORD PTR &#91;edx+ebx*8&#93;<br />            fstp QWORD PTR &#91;edx+esi*8&#93;<br />            fstp QWORD PTR &#91;edx+ebx*8&#93;<br />            <br />            dec esi<br />            dec ebx         <br />         .endif<br />   <br />         mov edi, _n                     ; m=n &gt;&gt; 1;<br />         shr edi, 1                       ; edi == m <br /><br />         <br />         .while &#40;&#40;EDI &gt;= 1&#41;&amp;&amp;&#40;ESI &gt;= EDI&#41;&#41; ; while &#40;m &gt;= 2 &amp;&amp; j &gt; m&#41;<br />            sub esi, edi                  ; j -= m;<br />            shr edi, 1                    ; m &gt;&gt;= 1;<br />         .endw<br />         add esi, edi                     ; j += m;<br />      <br />         inc ebx                          ; i+=2<br />         inc ebx<br />      .endw<br /><br />      ; Here begins the Danielson-Lanczos section of the routine.<br />      <br />      xor edi, edi<br />      inc edi<br />      inc edi                             ; EDI == mmax=2;<br /><br />      <br />      .while&#40; _n &gt; edi&#41;                   ; while &#40;n &gt; mmax&#41; Outer loop executed log2 nn times.<br /><br />         mov mmax, edi<br />         <br />         mov eax, edi                     ; istep=mmax &lt;&lt; 1;<br />         shl eax, 1<br />         mov istep, eax<br /><br />         lea edx, isign<br />         fild DWORD PTR &#91;edx&#93;<br />         fmul QWORD PTR &#91;NaNTwoPie&#93;       ; theta=isign*&#40;-6.28318530717959/mmax&#41;;<br />         lea edx, mmax<br />         fild DWORD PTR &#91;edx&#93;<br />         fdiv<br />         <br />         fld st                           ; st0 = st1 = theta<br />         fsin                             ; st0 = sin&#40;theta&#41;<br />         lea edx, wpi<br />         fstp QWORD PTR &#91;edx&#93;             ; wpi = sin&#40;theta&#41; &#40;and pop'd&#41;<br />         <br />         xor eax, eax                     ; wtemp=sin&#40;0.5*theta&#41;<br />         inc eax<br />         inc eax<br />         mov fpu_temp, eax<br />         lea edx, fpu_temp<br />         fild DWORD PTR &#91;edx&#93;<br />         fdiv                             ; st0 - 0.5*theta<br />         fsin<br />                                          ; wpr = -2.0*wtemp*wtemp;<br />         fld st                           ; st0 = st1 = wtemp<br />         fmul                             ; st0 = wtemp^2<br />         fldz                             ; st0 = 0.0<br />         lea edx, wi<br />         fst  QWORD PTR &#91;edx&#93;             ;    wi = 0.0<br />         fld1<br />         lea edx, wr<br />         fst  QWORD PTR &#91;edx&#93;             ;    wr = 1.0<br />         fsub                             ; st0 = -1.0<br />         fld1                             <br />         fsub                             ; st0 = -2.0<br />         fmul                             ; st0 = -2.0*wtemp^2<br />         lea edx, wpr<br />         fstp QWORD PTR &#91;edx&#93;             ; st0 = wpr &#40;and pop to finish&#41;<br /><br />         ; EDI = mmax, EBX == i, ESI = j<br />         xor eax, eax<br />         mov _m, eax                      ; Here are the two nested inner loops.<br />         .while&#40; _m &lt; edi &#41;               ; &#40;m=1;m&lt;mmax;m+=2&#41;<br />            mov ebx, _m                   ; i = m<br />            inc ebx<br />            .while&#40; ebx &lt;= _n1&#41;            ; &#40;i=m;i&lt;=n;i+=istep&#41;<br />            <br />               mov esi, ebx               ; j = i+mmax<br />               add esi, edi               <br />               <br />               dec esi<br />               dec ebx<br />               <br />               mov edx, lp_data<br />               fld QWORD PTR &#91;edx+esi*8&#93;  ; fld data&#91;j&#93;     <br />               <br />               inc esi <br />               fld QWORD PTR &#91;edx+esi*8&#93;  ; fld data&#91;j+1&#93;  <br />               dec esi   <br />                  <br />               lea edx, wr<br />               fld QWORD PTR &#91;edx&#93;        ; fld wr<br />               lea edx, wi<br />               fld QWORD PTR &#91;edx&#93;        ; fld wi<br /><br />               fld st&#40;1&#41;   ; wr<br />               fld st&#40;4&#41;   ; data&#91;j&#93;<br />               fmul<br />               fld st&#40;1&#41;   ; wi<br />               fld st&#40;4&#41;   ; data&#91;j+1&#93;<br />               fmul<br />               fsub        ; st0 = wr*data&#91;j&#93; - wi*data&#91;j+1&#93;<br />               lea edx, tempr<br />               fstp QWORD PTR &#91;edx&#93;       ; tempr = wr*data&#91;j&#93; - wi*data&#91;j+1&#93;<br /><br />               fld st&#40;1&#41;   ; wr<br />               fld st&#40;3&#41;   ; data&#91;j+1&#93;<br />               fmul<br />               fld st&#40;1&#41;   ; wi<br />               fld st&#40;5&#41;   ; data&#91;j&#93;<br />               fmul<br />               fadd<br />               lea edx, tempi<br />               fstp QWORD PTR &#91;edx&#93;       ; tempi = wr*data&#91;j+1&#93; + wi*data&#91;j&#93;<br />               <br />               fstp st      ; Empty the stack<br />               fstp st<br />               fstp st<br />               fstp st         <br />               <br />               mov edx, lp_data<br />               fld QWORD PTR &#91;edx+ebx*8&#93;  ; fld data&#91;i&#93;<br />               lea ecx, tempr<br />               fld QWORD PTR &#91;ecx&#93;        ; fld tempr<br />               fsub<br />               fstp QWORD PTR &#91;edx+esi*8&#93; ; data&#91;j&#93; = data&#91;i&#93;-tempr<br /><br />               inc esi<br />               inc ebx<br />               <br />               fld QWORD PTR &#91;edx+ebx*8&#93;  ; fld data&#91;i+1&#93;<br />               lea ecx, tempi<br />               fld QWORD PTR &#91;ecx&#93;        ; fld tempi<br />               fsub<br />               fstp QWORD PTR &#91;edx+esi*8&#93; ; data&#91;j+1&#93; = data&#91;i+1&#93;-tempi<br /><br />               dec esi<br />               dec ebx<br />               <br />               lea ecx, tempr<br />               fld QWORD PTR &#91;ecx&#93;        ; fld tempr<br />               fld QWORD PTR &#91;edx+ebx*8&#93;  ; fld data&#91;i&#93;<br />               fadd<br />               fstp QWORD PTR &#91;edx+ebx*8&#93; ; data&#91;i&#93; += tempr<br />               <br />               inc ebx<br />               lea ecx, tempi<br />               fld QWORD PTR &#91;ecx&#93;        ; fld tempi<br />               fld QWORD PTR &#91;edx+ebx*8&#93;  ; fld data&#91;i+1&#93;<br />               fadd<br />               fstp QWORD PTR &#91;edx+ebx*8&#93; ; data&#91;i+1&#93; += tempi<br />               dec ebx<br />               <br />               inc ebx<br />               inc esi<br />               <br />               add ebx, istep             ; i+=istep<br />            .endw<br />         <br />            lea edx, wr                   <br />            fld QWORD PTR &#91;edx&#93;<br />            lea edx, wpr<br />            fld QWORD PTR &#91;edx&#93;<br />            lea edx, wi<br />            fld QWORD PTR &#91;edx&#93;<br />            lea edx, wpi<br />            fld QWORD PTR &#91;edx&#93;<br />            <br />            fld  st&#40;3&#41;  ; wr<br />            fld  st&#40;3&#41;  ; wpr<br />            fmul<br />            fld  st&#40;2&#41;  ; wi<br />            fld  st&#40;2&#41;  ; wpi<br />            fmul<br />            fsub<br />            fld  st&#40;4&#41;<br />            fadd        ; st0 = wr*wpr-wi*wpi+wr<br />            lea edx, wr<br />            fstp QWORD PTR &#91;edx&#93;<br />            <br />            fld  st&#40;1&#41;  ; wi<br />            fld  st&#40;3&#41;  ; wpr<br />            fmul<br />            fld  st&#40;4&#41;  ; wr<br />            fld  st&#40;2&#41;  ; wpi<br />            fmul<br />            fld  st&#40;3&#41;<br />            fadd        ; wi<br />            fadd        ; st0 = wi*wpr+wr*wpi+wi<br />            lea edx, wi<br />            fstp QWORD PTR &#91;edx&#93;<br />            <br />            fstp st     ; cleanup the stack<br />            fstp st<br />            fstp st<br />            fstp st<br />            <br />            inc _m                        ; m+=2<br />            inc _m<br />         .endw<br />         <br />         mov edi, istep                   ; mmax = istep<br />      .endw<br /><br />   xor eax, eax<br />   inc eax<br />   .if&#40; isign == eax &#41;&amp;&amp;&#40; Normalize == 1 &#41;<br />      <br />      lea edx, nn<br />      fld1<br />      fild DWORD PTR &#91;edx&#93;       ; load scale factor<br />      fdiv<br />      <br />      mov edx, lp_data<br />      xor ebx, ebx<br />   <br />      .while&#40; ebx &lt; _n &#41;;<br /><br />         fld QWORD PTR &#91;edx+ebx*8&#93;<br />         fld st&#40;1&#41;         <br />         fmul<br />         fstp QWORD PTR &#91;edx+ebx*8&#93;<br /><br />         inc ebx<br />      .endw<br />      fstp st<br />             <br />   .endif<br /><br />   ret<br />FFT    ENDP   &#91;/size&#93;</code></pre><br /><br />I know nothing about optomization.  If someone wishes to make it run fasters I can supply them with suitable test code to ensure the algorithm's integrity is correct.  If you do optomize it and prove to improve performace, place your name at the top for your hard work, increment the sub version number, and repost the solution.<br /><br />Happy DSP'n :tongue: <br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2003-05-14 21:06:37 by NaN</div>
   </div>
   <div class="post" id="post-103116">
    <div class="subject"><a href="#post-103116">FFT and IFFT for MASM</a></div>
    <div class="body">Maybe you could explain a little bit what FFT is for some of the mentally retarded folks here.  Myself included.</div>
    <div class="meta">Posted on 2003-05-14 23:13:16 by iblis</div>
   </div>
   <div class="post" id="post-103128">
    <div class="subject"><a href="#post-103128">FFT and IFFT for MASM</a></div>
    <div class="body">Any analog signal, digital or not, can be expressed as a sum of sines and cosines (which incremently differs by frequency), weather its an impulse (sharp spike in a sea of silence), or a sine wave itself.<br /><br />The FFT (fast fourier transform) is a fast algorithm that takes a signal pattern and decomposes it into its frequency components and their respective phase components for each frequency.  <br /><br />The IFFT (inverse fast fourier transform) does the opposite, taking freqency components and their phase and recreates a signal pattern.<br /><br />A good application is in sound processing, but it can be used in many other fields such as image processing (object detection).<br /><br />The basic theory comes from Eulers Identity:<br /><br />e^j@ = cos(@) + j*sin(@)<br /><br />where @=2*pi*f*t  (time domain)<br /><br /><br />My test code for the FFT had a data array of points defined by:<br /><br />data(x) = sin( 2*pi*5*x / 63)<br /><br />To make a total of 64 data points, which oscillated and produced 5 complete sine-waves (0-&gt;63 points in all):</div>
    <div class="meta">Posted on 2003-05-15 00:52:24 by NaN</div>
   </div>
   <div class="post" id="post-103131">
    <div class="subject"><a href="#post-103131">FFT and IFFT for MASM</a></div>
    <div class="body">The resulting data array is processed by the FFT, and the array is repopulated with its frequency and phase component values.<br /><br />Note each frequency location can be expressed by the Euler identity:<br /><br />x = Amplitude of signal at a given frequency<br />y = phase of the signal at a given frequency<br /><br />Individual frequency component 'z(f)' that is part of the fourier series to make the original signal is the:<br /><br />z(f) = x * e^j(2*pi*f*t + y)<br />z(f) = x * [ cos( 2*pi*f*t + y) + j.sin(2*pi*f*t + y) ]<br /><br />If you look this over carefully you will see that the two important factors for each frequency component is magnitude 'x' and phase 'y' for each frequency 'f'.  Below is the FFT output plot of only the frequency magnitudes of the origional signal posted above:</div>
    <div class="meta">Posted on 2003-05-15 01:01:42 by NaN</div>
   </div>
   <div class="post" id="post-103134">
    <div class="subject"><a href="#post-103134">FFT and IFFT for MASM</a></div>
    <div class="body">It should be noted that the NYQUEST frequency is defined as 1/2 the sampling frequency.  This translates to being half the data width.  So our 64 point array has a nyquist frequency at 32.<br /><br />Anything above this frequency is ALIASED to a lower frequency.  This is a phenomenon easily observed in car tires rotating on a highway.  How some how they seem to appear to stop rotating, and then start to rotate backwards.  We know they are rotating in one direction, and far faster than what we see!  However, our eyes can only sample up to a maximum frequency.  After this nyquist point, everything else appears to be less again, ultimately falling back to an apparent stand-still of the rolling tire.<br /><br />As well, all frequencies has an equal but opposit conjegate.  In math x^2 +25 =0, when we solve for the roots, we get +/- 5j.  All frequencies other than CONSTANT (0 Hertz) is on the j axis.  So there is a point at +5 and -5 from the math equation. Just as equally, the Magnitude plot shows the the +5j (at the start at 5Hz), and the -5j (near end at 59Hz (64-5)).<br /><br />Basically all real signal values (non-mathematicaly made) will have a mirrored relationship, pivoting on the Nyquest Frequency Location when FFT'd.<br /><br />Looking at this magnitude plot then, i know that there is only one frequency in the source signal.  5Hz.  Because this is where all the energy in the source signal is located.  All other frequencies have very little energy in their signals.  So low that it negligable and considered not there.<br /><br />Having a Magnitude still doesnt tell me the signal behavior completely.  We also need to see the Phase for each magnitude:</div>
    <div class="meta">Posted on 2003-05-15 01:15:35 by NaN</div>
   </div>
   <div class="post" id="post-103136">
    <div class="subject"><a href="#post-103136">FFT and IFFT for MASM</a></div>
    <div class="body">The phase relationship shows that the signal is and ODD signal.  This is because the average value is == 0! (remember you high school math here ~ even/odd relationships).<br /><br />sin(-x) == -sin(x)  (( Odd behavior ))<br />cos(-x) == cos(x)  (( Even behavior))<br /><br />The sign out front is the phase.  Having a negative phase, and a positive phase, for x, and -x show us that its a SIN function, not a cosine function.  The other plot showed us the magnitude for this function.<br /><br /><br />Now your question is why?<br /><br />I can easily take a sample of sound data and add digital effects, or simply pitch shift the signal by moving the frequency vaules up scale or down scale in magnitude and phase, and then IFFT to recreat the modified time valued signal.  <br /><br />This is similar to the &quot;Hello Sydney&quot; voice box used in the movie SCREAM.  It remodulated the voice to a lower pitch.  Essencially doing an FFT, adjusting the data down in frequency (cut &amp; paste like work) and then doing the IFFT to build a new signal and play it out (which you hear as a lower voice).<br /><br />In image processing, the frequency/phase patterns will act like a finger-print, and varry depending on the image contents.  This condenses alot of data into more manageable information for such things...<br /><br />The list goes on, and on.  <br />I hope this helps..<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2003-05-15 01:27:48 by NaN</div>
   </div>
   <div class="post" id="post-103148">
    <div class="subject"><a href="#post-103148">FFT and IFFT for MASM</a></div>
    <div class="body">By the way, your winamp displays a magnitude plot of its MP3.  Only it shows you up to the nyquist frequency, and not beyond (the mirrored aliased frequencies).<br /><br />Just to give you a quick example...</div>
    <div class="meta">Posted on 2003-05-15 02:15:54 by NaN</div>
   </div>
   <div class="post" id="post-103158">
    <div class="subject"><a href="#post-103158">FFT and IFFT for MASM</a></div>
    <div class="body">Wow, thanks NaN.   I still have no clue what you're talking about, but the last part about modifying sound waves made enough sense.  :alright:<br /><br />Should I ever have the inclination to mess with sound data, I'll be sure to check back here.</div>
    <div class="meta">Posted on 2003-05-15 03:16:40 by iblis</div>
   </div>
   <div class="post" id="post-103195">
    <div class="subject"><a href="#post-103195">FFT and IFFT for MASM</a></div>
    <div class="body">Ya it pretty cool stuff.. (math pays off if you stick with it long enought to learn what you can really do ;)  )<br /><br />As well, the FFT fingerprint patterns could be normalized even further and feed into a Neural Network to produce &quot;thought based&quot; results.  Ofcourse you would need to train it multiple times to learn what its looking for.. but this would be crude first step into recognition systems.<br /><br />:NaN:</div>
    <div class="meta">Posted on 2003-05-15 09:22:38 by NaN</div>
   </div>
   <div class="post" id="post-103227">
    <div class="subject"><a href="#post-103227">FFT and IFFT for MASM</a></div>
    <div class="body">NaN,<br />Thank you for post the fft source. <br /><br />FYI:<br />There are some suggestions for optimizatiom but that imposes some restrictions. <br />It is possible to get rid of the sin and cos calculation with a small table for <br />sin((+/-)2pi/N) and cos((+/-)2pi/N), as N is necessarily a power of 2 the table <br />would have just 56 elements for a limit of 2&lt;=N&lt;=16k, 60 elements for a limit of <br />N=32k and so forth. <br /><br />These and others optimizations were persented in the &quot;Faster FFTs&quot; article on Dr. <br />Dobb's magazine February 1995 in the column &quot;Algorithm Alley&quot;. The article presents<br />the C and assembler implementation - <a target="_blank" href="http://www.ddj.com/ftp/1995/1995.02/">http://www.ddj.com/ftp/1995/1995.02/</a> (asm only)<br /><br />Regards,<br /><br />RValois.</div>
    <div class="meta">Posted on 2003-05-15 13:49:45 by RValois</div>
   </div>
   <div class="post" id="post-103252">
    <div class="subject"><a href="#post-103252">FFT and IFFT for MASM</a></div>
    <div class="body">Great work.<br />You made NRiC code work, and I admire you.  :)  I think anyone who make NRiC code sane (in any language) deserves a &quot;stand-up ovation&quot;.<br /><br />Maybe this is a minor point, but... <br />Why would you do <strong>fld/fld/fmul</strong> or similar two load and 'op and pop reg stack' sequence, when they do not have distinctive advantage?  For example, in the innermost loop,<br /><pre><code><br />fld QWORD PTR &#91;ecx&#93;        ; fld tempi<br />fld QWORD PTR &#91;edx+ebx*8&#93;  ; fld data&#91;i+1&#93;<br />fadd<br /></code></pre><br />could be done by a shorter code (2 byte shorter, I guess), like<br /><pre><code><br />fld  qword ptr &#91;ecx&#93;<br />fadd qword ptr &#91;edx+8*ebx&#93;<br /></code></pre><br />On a P6, under ideal conditions, they run at the same speed.  On P5, all FPU instructions except <strong>fxch</strong> are not pairable, so the latter is slightly faster in decoding.</div>
    <div class="meta">Posted on 2003-05-15 18:05:30 by Starless</div>
   </div>
   <div class="post" id="post-103412">
    <div class="subject"><a href="#post-103412">FFT and IFFT for MASM</a></div>
    <div class="body"><div class="quote"><br />Great work.<br />You made NRiC code work, and I admire you.  :)  I think anyone who make NRiC code sane (in any language) deserves a &quot;stand-up ovation&quot;.<br /><br />Maybe this is a minor point, but... <br />Why would you do <strong>fld/fld/fmul</strong> or similar two load and 'op and pop reg stack' sequence, when they do not have distinctive advantage?  For example, in the innermost loop,<br /><pre><code><br />fld QWORD PTR &#91;ecx&#93;        ; fld tempi<br />fld QWORD PTR &#91;edx+ebx*8&#93;  ; fld data&#91;i+1&#93;<br />fadd<br /></code></pre><br />could be done by a shorter code (2 byte shorter, I guess), like<br /><pre><code><br />fld  qword ptr &#91;ecx&#93;<br />fadd qword ptr &#91;edx+8*ebx&#93;<br /></code></pre><br />On a P6, under ideal conditions, they run at the same speed.  On P5, all FPU instructions except <strong>fxch</strong> are not pairable, so the latter is slightly faster in decoding. </div><br /><br />Ya NaN you can save a lot of time from doing it the way Starless suggested trust me I know first hand.</div>
    <div class="meta">Posted on 2003-05-16 17:25:57 by x86asm</div>
   </div>
   <div class="post" id="post-103413">
    <div class="subject"><a href="#post-103413">FFT and IFFT for MASM</a></div>
    <div class="body">Well I wanted to do DSP also, but I'm not sure what all these fancy symbols mean and represent I mean what does &quot;sigma&quot; mean?! I have a DSP book by the name of &quot;BASIC Digital Signal Processing&quot; and in one case I believe for a DFT it has N/2-1 on top and N=0 on the bottom can any of you guys help me?</div>
    <div class="meta">Posted on 2003-05-16 17:29:51 by x86asm</div>
   </div>
   <div class="post" id="post-103419">
    <div class="subject"><a href="#post-103419">FFT and IFFT for MASM</a></div>
    <div class="body">Is it a symbol that looks like a cross between a '&amp;' and a 'S'.  If so its most likely the the symbol used to represent an Impulse (value 1 at time 0, and value 0 for all other times).<br /><br />However, im not sure if your refering to a sum ('E' like symbol), since you mentioned a start N=0 to N=N/2.  That sum is like a FOR loop:<br /><br /><pre><code> xor edx, edx<br /> mov n, edx<br /> .while n&lt;=N/2<br />    add edx, &#40;sigma term as a function of n&#41;<br />    inc n<br /> .endw</code></pre><br /><br />:NaN:</div>
    <div class="meta">Posted on 2003-05-16 18:13:56 by NaN</div>
   </div>
   <div class="post" id="post-103715">
    <div class="subject"><a href="#post-103715">FFT and IFFT for MASM</a></div>
    <div class="body">I've taken a shot at revising the code in an attempt for some cleanup and minor optimizations. These are generic only relative to pentitium (no specific target) in theory only. I haven't benchmarked or compared against previous -- someone may want to do this.<br /><br />Please note-- I changed the source into a subroutine/module (for my convenience only) so others that want to incoroporate in-line should take out what they don't need.  PLEASE NOTE, I commented out the FINIT statement (personal preference based on my typical use).<br /><br />The enclosed file contains the 1.3 revision and others files that make up a VB callable DLL that contains the FFT routine. See the included MS/Excel example for the VB example. <br /><br />I left a lot of (working) comments in, excuse the mess!<br /><br />Future revs may want to fine-tune the parallel computations - they are not as good as they could be. Also, some additional structure changes (trig table, integer math instead of fp, etc) can also help in a big way.</div>
    <div class="meta">Posted on 2003-05-18 09:57:08 by TheoMcCloskey</div>
   </div>
   <div class="post" id="post-104124">
    <div class="subject"><a href="#post-104124">FFT and IFFT for MASM</a></div>
    <div class="body">Thanks for you thoughts.. Im still trying to get a moment to look it over tho.  Work is getting busy again, and i just got back from my brother's wedding...<br /><br />Need to find more personal time... :ack:<br /><br />:NaN:</div>
    <div class="meta">Posted on 2003-05-20 21:46:41 by NaN</div>
   </div>
   <div class="post" id="post-104125">
    <div class="subject"><a href="#post-104125">FFT and IFFT for MASM</a></div>
    <div class="body"><div class="quote"><br />Thanks for you thoughts.. Im still trying to get a moment to look it over tho.  Work is getting busy again, and i just got back from my brother's wedding...<br /><br />Need to find more personal time... :ack:<br /><br />:NaN: </div><br /><br />NaN before you go you know the code you posted? Is that how the sigma sign is decoded? (it looks like a deformed &quot;E&quot;)<br />I have a BASIC Digital Signal Processing book, so far it has been good in explaining the theory and I don't have a problem with the math but this sigma is really stumping me. As I dont know how to interpret it.</div>
    <div class="meta">Posted on 2003-05-20 21:49:44 by x86asm</div>
   </div>
   <div class="post" id="post-104126">
    <div class="subject"><a href="#post-104126">FFT and IFFT for MASM</a></div>
    <div class="body"><div class="quote"><br />Thanks for you thoughts.. Im still trying to get a moment to look it over tho.  Work is getting busy again, and i just got back from my brother's wedding...<br /><br />Need to find more personal time... :ack:<br /><br />:NaN: </div><br /><br />Also NaN, I believe you have said that the FFT decomposes an analog signal into a sum of sines and cosines.  So in this case I can break down a WAV file into frequency domains and selectively amplifying the different frequency bands therefore emulating an EQ?</div>
    <div class="meta">Posted on 2003-05-20 21:55:42 by x86asm</div>
   </div>
   <div class="post" id="post-104127">
    <div class="subject"><a href="#post-104127">FFT and IFFT for MASM</a></div>
    <div class="body">Yes.. Its a Sum Opperator.  Its basically a mathematical symbol of a FOR-LOOP, looping about the ADD opperation and the variables expressed in the equation.<br /><pre><code>  n=5<br />   E &#40; 2n-1 &#41; = &#40;0-1&#41; + &#40;2-1&#41; + &#40;4-1&#41; + &#40;6-1&#41; + &#40;8-1&#41; + &#40;10-1&#41;<br />  n=0<br /><br />  n=5<br />   E &#40; 2n-1 &#41; = -1 + 1 + 3 + 5 + 7 + 9 = 24<br />  n=0<br />  <br />  <br />  E = 0<br />  FOR N = 0 TO 5<br />    E = E + &#40; 2n - 1&#41;<br />  NEXT N <br />  <br />  <br />  xor esi, esi<br />  xor ecx, ecx<br />  .while &#40;ecx &lt;=5&#41;<br />    mov eax, ecx<br />    shl eax, 1<br />    dec eax<br />    add esi, eax<br />  inc ecx<br />  .endw</code></pre><br /><br />Hope that is clear ;)<br /><br />You may also (rarely) come across a simular mathematical expression only the Sigmal 'E' is replaced with a large PI symbol.  This means the operator is to be MULTIPLY instead of ADD.  However, it is rarely found is common mathematics.<br /><br />Fun fact:<pre><code>  n=infinity<br />   E &#40; 1 + 1/n! &#41; = 1/1 + 1/1 +1/2 + 1/6 + ... + 1/infinit = e  &#40;exponetial e^1&#41;<br />  n=0</code></pre><br /><br />Enjoy<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2003-05-20 22:06:43 by NaN</div>
   </div>
   <div class="post" id="post-104208">
    <div class="subject"><a href="#post-104208">FFT and IFFT for MASM</a></div>
    <div class="body">NaN, I believe you mean...<br /><br />     n = infinity<br />        E  ( 1/n! ) = 1/1 + 1/1 +1/2 + 1/6 + ...  = e  <br />     n = 0<br /><br />otherwise you end up with a non-convergent series summation.</div>
    <div class="meta">Posted on 2003-05-21 11:47:38 by Poimander</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=13298&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=13298&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="13298" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=13298&amp;page=2">&gt;</a><a href="../?id=13298&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>