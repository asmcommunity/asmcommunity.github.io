<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>D3D Animation Support Module - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=15287" />
  <link rel="prev" href="../?id=15287&amp;page=2" />  <link rel="next" href="../?id=15287&amp;page=4" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=15287">D3D Animation Support Module</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=15287&amp;page=1" style="">&laquo;</a><a href="../?id=15287&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="15287" /><input type="number" name="page" min="1" max="6" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=15287&amp;page=4">&gt;</a><a href="../?id=15287&amp;page=6">&raquo;</a></form>   <div class="post" id="post-121732">
    <div class="subject"><a href="#post-121732">D3D Animation Support Module</a></div>
    <div class="body">Ok I'll admit I've had a go on Morrowind, it's my parental duty to make sure that content is suitable for my impressionable youngster :grin: <br />It's a wonderful game, but reminds me of Trespasser in that it's a bit slow...<br />Unfortunately if I spent all my time playing other peoples games, I'd never get around to writing my own games (or anything else), and I have to admit getting a lot more satisfaction from the latter than the former.<br /><br />Here's another version of FrameNode_Load which is handling the loading of the Mesh, textures and materials for our animated SkinMesh models..<br />If you look down below it , you'll find the necessary function which performs all that.<br /><br />FrameNode_Load PROC pData:DWORD, ParentFrame:DWORD, pSkinMeshOwner:DWORD<br />local  pSubObj:DWORD<br />local  pSubData:DWORD <br />local  pDataRef:DWORD <br />local pType:LPGUID<br />local NameBuf[256]:BYTE<br />local ErrBuf[256]:BYTE<br />local pmeshnode:LPMESHNODE<br />local panimationset:LPANIMATIONNODE<br />local dwSize:DWORD<br />local hFrame:LPFRAMENODE<br />local pmat:LPD3DXMATRIX<br />local dwsize:DWORD<br />local hname:DWORD<br />;local parentframe:DWORD<br />;===============================================================================<br />;Initialize locals (DX can be finicky - some output args can also be input args !!)<br />;===============================================================================<br />xor eax,eax<br />mov pSubObj,eax<br />mov pSubData,eax<br />mov pDataRef,eax<br />mov pType,eax<br />mov NameBuf[0],al<br />mov dwSize,eax<br />mov hFrame,eax<br />mov pmeshnode,eax<br />mov panimationset,eax<br />;m2m parentframe,ParentFrame<br />;===============================================================================<br />invoke IdentifyGUID, pData<br />;===============================================================================<br />.if eax==Frame<br />  mov hFrame,    $invoke (LinkedLists_AppendSibling,ParentFrame,NULL, sizeof FrameNode)<br />  .if hFrame==NULL<br />     Errr CTXT(&quot;Error - Failed to create FrameNode&quot;)<br />  .endif<br />  .if $mcall (pData,IDirectXFileData_GetName, NULL, addr dwSize)!=D3D_OK<br />    Errr CTXT(&quot;Failed to get Template Name Length&quot;)<br />  .elseif dwSize!=0<br />        mcall ,IDirectXFileData_GetName, addr NameBuf, addr dwSize<br />  .endif<br />  .if NameBuf[0]== NULL                                                                     ;  // Give a default name if none found<br />    invoke lstrcpy,addr NameBuf, CTXT(&quot;$NamelessTemplate$&quot;)<br />  .endif    <br />   invoke LinkedObjects_SetName, hFrame, addr NameBuf<br />;===============================================================================<br />      .elseif eax==FrameXFormMatrix  <br />;       // Read the Matrix data straight into our buffer(s)    <br />                        mov esi,$invoke (GlobalLock,ParentFrame)<br />                        assume esi:nothing<br />                        assume esi:ptr FrameNode<br />                        lea ebx,.OriginalMatrix<br />                        m2m pmat, ebx<br />		mcall ,IDirectXFileData_GetData, NULL, addr dwsize, addr pmat <br />                        .if eax==DXFILE_OK<br />                              lea ebx,.TransformationMatrix<br />                              m2m pmat, ebx<br />		      mcall ,IDirectXFileData_GetData, NULL, addr dwsize, addr pmat <br />                              .if eax != DXFILE_OK<br />                                      invoke GlobalUnlock,ParentFrame<br />  		              Errr CTXT (&quot;Couldn't read frame transformation matrix from an x file&quot;)<br />                             .endif<br />  		.else<br />                              invoke GlobalUnlock,ParentFrame<br />  		      Errr CTXT (&quot;Couldn't read frame transformation matrix from an x file&quot;)<br />  		.endif<br />                        invoke GlobalUnlock,ParentFrame<br />;===============================================================================<br />  .elseif eax==Mesh<br /><br />;** Create a meshnode, append it to the parent frame's list of meshes, and load the mesh into it<br />;** Note the usage of NULL for target object indicates it needs to be created as well as linked<br />                        mov esi,$invoke (GlobalLock,ParentFrame)<br />                        assume esi:nothing<br />                        assume esi:ptr FrameNode<br />                        mov pmeshnode,$invoke (LinkedLists_Append, .pMeshes, NULL, sizeof MeshNode)<br />                        .if .pMeshes==NULL                             ;is the list's root object NULL meaning no existing entries?<br />                                m2m .pMeshes,pmeshnode         ;if it is, then this meshnode is the new Root (top of List)<br />                        .endif<br />                        mov esi,pmeshnode<br />                        assume esi:nothing<br />                        assume esi:LPMESHNODE<br />                        mov .pD3DXSkinMesh,NULL             <br />                        mov .pD3DXBlendedMesh,NULL             <br />                        invoke MeshNode_Create, pmeshnode, pData  ;ok now attempt to load the mesh (may also be hierarchy!)<br />                        invoke GlobalUnlock,ParentFrame<br />                        invoke MessageBox,0,CTXT(&quot;MESH PARSED OK&quot;),CTXT(&quot;kk&quot;),MB_OK<br />;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------<br />        .endif<br />;------------------------------------------------------------------------------------------------------------------------------------------------------------------------------<br /><br /><br /><br /><br /><br />;   Scan for embedded templates<br /><br />    mcall ,IDirectXFileData_GetNextObject, ADDR pSubObj     <br />    .while eax!=DXFILEERR_NOMOREOBJECTS<br />        .if  eax==DXFILEERR_BADVALUE<br />            Errr CTXT(&quot;Parser Error - DXFILEERR_BADVALUE - in Frames Parser&quot;)<br />        .endif<br /><br />        .if ($mcall(pSubObj,IDirectXFileObject_QueryInterface, ADDR IID_IDirectXFileDataReference, ADDR pDataRef)) == DXFILE_OK<br />          .if ($mcall(pDataRef,IDirectXFileDataReference_Resolve,addr pSubData))==DXFILE_OK<br />            invoke IdentifyGUID,pSubData<br />            invoke MessageBox,0,CTXT(&quot;REFOBJECT IDENTIFIED&quot;),CTXT(&quot;YAYYYYYY&quot;),MB_OK<br />             invoke FrameNode_Load,pSubData, hFrame,pSkinMeshOwner<br />             _saferelease pSubData <br />          .endif<br />          _saferelease pDataRef<br />        .endif<br /><br />        .if ($mcall (pSubObj, IDirectXFileObject_QueryInterface,addr IID_IDirectXFileData, addr pSubData)) == DXFILE_OK<br />                invoke FrameNode_Load,pSubData, hFrame,pSkinMeshOwner<br />               _saferelease pSubData<br />        .endif    <br /><br /><br />         _saferelease pSubObj<br />         mcall ,IDirectXFileData_GetNextObject, ADDR pSubObj     <br />    .endw<br />ret<br />FrameNode_Load ENDP<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />(next please, Homer!)<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />MeshNode_Create PROC pThis:ptr MeshNode, pxofobj:ptr<br />local pmaterialsbuf:LPD3DXBUFFER<br />local axmaterial:LPD3DXMATERIAL <br />local padjacencybuf:LPD3DXBUFFER <br />local pboneoffsetbuf:LPD3DXBUFFER<br />local pbones:ptr<br />local padjacencyin:ptr<br />local pname:ptr<br />local dwnamelength:DWORD <br />local dwfacescount:DWORD<br />local dwnumbones:DWORD<br />local buffysize:DWORD<br />local UrMomma:DWORD<br />local namebuf[256]:BYTE<br />local ErrBuf[256]:BYTE<br />;=====================================================================================<br />xor eax,eax                                         ;initialize locals<br />mov pboneoffsetbuf,eax<br />mov padjacencyin,eax<br />mov padjacencybuf,eax<br />mov pmaterialsbuf,eax<br /><br />.if pThis==NULL<br />           Errr CTXT(&quot;Null Parent when creating MeshNode&quot;)<br />.endif<br />push esi                                                ;shove esi on the Stack for the remainder of this procedure<br />mov esi,$invoke (GlobalLock,pThis)    ;(and this is why - we're going to use it as our &quot;object pointer&quot;)<br />assume esi:nothing<br />assume esi:LPMESHNODE<br />mov .dwNumMaterials,NULL         ;just for safety in next call<br />mov .pBoneNamesBuf,NULL<br />mov .pD3DXSkinMesh,NULL<br /><br /> ;=====================================================================================<br /> ; ;*** Assume that the MeshNode was named when it was created ***<br /> ;=====================================================================================<br /><br />;*** load the mesh ***<br />invoke D3DXLoadSkinMeshFromXof, pxofobj, D3DXMESH_MANAGED, lpd3dDevice , addr padjacencybuf, <br />addr pmaterialsbuf, addr .dwNumMaterials, addr .pBoneNamesBuf, addr pboneoffsetbuf, addr .pD3DXSkinMesh<br />.if eax!=D3D_OK<br />    invoke GlobalUnlock,pThis<br />    pop esi<br />    Errr CTXT( &quot;Couldn't load skin mesh&quot; )<br />.endif<br />mov dwfacescount , $mcall (.pD3DXSkinMesh,ID3DXSkinMesh_GetNumFaces)<br />mov dwnumbones , $mcall (.pD3DXSkinMesh,ID3DXSkinMesh_GetNumBones)<br /><br />ifdef _DEBUG_<br />push esi<br />pushad<br />invoke wsprintf,addr ErrBuf,CTXT(&quot;SkinMesh Geometry consists of:&quot;,13,10,&quot;%lu Faces&quot;,13,10,&quot;%lu Bones&quot;,13,10,&quot;%lu Materials&quot;),dwfacescount ,dwnumbones,.dwNumMaterials<br />invoke MessageBox,0,addr ErrBuf,CTXT(&quot;LOADED SKINMESH GEOMETRY&quot;),MB_OK<br />popad<br />pop esi<br />endif<br />;=====================================================================================<br />.if dwnumbones&gt;0      ;*** IF BONES ARE FOUND, FETCH BONE INFO AND CONVERT SKINMESH TO BLENDED MESH<br />;push esi<br />;pushad<br />;invoke MessageBox,0,CTXT(&quot;BONES were found - converting SkinMesh to BlendedMesh.&quot;),CTXT(&quot;PROCESSING SKINMESH GEOMETRY&quot;),MB_OK<br />;popad<br />;pop esi<br />            mov eax,dwnumbones<br />            mov ebx,sizeof D3DXMATRIX <br />            mul ebx                                            ;Calculating size of BoneMatrices Buffer(s)<br />            mov buffysize,eax                           ;buffysize = &quot;enough room for #BONES * sizeof one Matrix&quot;<br /><br />            mov eax,dwfacescount<br />            mov ebx,3*sizeof DWORD      <br />            mul ebx                                                ;Calculating size of Adjacency Index Buffer<br />            mov UrMomma,eax                             ;UrMomma = #faces * (3 dwords per face)<br />            mov .pAdjacency,$invoke (GlobalAlloc, GPTR, UrMomma)               ;Allocate memory for Adjacency Buffer<br />            mov .pBoneMatrix  ,         $invoke (GlobalAlloc, GPTR, buffysize)   ;Allocate memory for Bone Matrix Array<br />            mov .pBoneOffsetMatrix ,$invoke (GlobalAlloc, GPTR, buffysize)   ;Allocate memory for Bone Offset Matrix Array<br /><br />            mov pbones,          $mcall (pboneoffsetbuf,ID3DXBuffer_GetBufferPointer) ;Get access to the actual buffer data<br />	mov padjacencyin, $mcall (padjacencybuf,ID3DXBuffer_GetBufferPointer) ;for both these two buffers<br />            mov dwnumbones, $mcall (.pD3DXSkinMesh,ID3DXSkinMesh_GetNumBones)<br />            mov .NumberOfBones,eax<br /><br />	invoke RtlMoveMemory, .pBoneOffsetMatrix, pbones, buffysize   ;Copy the BoneOffsetMatrices <br />	invoke RtlMoveMemory, .pAdjacency, padjacencyin, UrMomma      ;Copy Adjacency info<br /><br />	invoke MeshNode_GenerateMesh, pThis                                    ;Convert SkinMesh to BlendedMesh<br /><br />;=====================================================================================<br />.else       ;*** IF NO BONES ARE FOUND, BLEND THE MESH AND USE AS A STATIC MESH (NOT ANIMATED)<br />	mcall .pD3DXSkinMesh,ID3DXSkinMesh_GetOriginalMesh,addr .pD3DXBlendedMesh <br />	_saferelease .pD3DXSkinMesh<br />	m2m .dwAttrCount , .dwNumMaterials<br />.endif<br />;=====================================================================================<br />;=====================================================================================<br />;=====================================================================================<br />;=====================================================================================<br />;=====================================================================================<br />;=====================================================================================<br />;THE FOLLOWING CODE IS EXECUTED WHETHER THE MESH HAS BONES OR NOT<br />;// check for materials<br />;=====================================================================================<br />;Case - Materials were NOT found<br />;=====================================================================================<br />.if( (pmaterialsbuf == NULL) || ( .dwNumMaterials== 0)) ;** IF no materials are found, create a default material<br />		mov .pMeshMaterials , $invoke (GlobalAlloc, GPTR, sizeof D3DMATERIAL8)<br />		mov .dwNumMaterials,1<br />		mov .pMeshTextures,NULL<br /><br />		invoke RtlZeroMemory, .pMeshMaterials,  sizeof D3DMATERIAL8<br />                        mov ebx,.pMeshMaterials<br />                        assume ebx:ptr D3DMATERIAL8<br />                        fld fphalf<br />                        fst  .Diffuse.r<br />                        fst  .Diffuse.g<br />                        fst  .Diffuse.b<br />                        fst  .Specular.r<br />                        fst  .Specular.g<br />                        fst  .Specular.b<br />                        assume ebx:nothing<br />;=====================================================================================<br />;Case - One or more Materials have been found and must be processed...<br />;=====================================================================================<br />.else		;** IF Materials were found, we will load them<br />;push esi<br />;pushad<br />;invoke MessageBox,0,CTXT(&quot;Processing MATERIALS.&quot;),CTXT(&quot;Processing Mesh Geometry&quot;),MB_OK<br />;popad<br />;pop esi<br />                        mov eax,sizeof D3DMATERIAL8<br />                        mul  .dwNumMaterials        <br />		mov .pMeshMaterials, $invoke (GlobalAlloc, GPTR,EAX)<br />                        mov ebx,.dwNumMaterials        <br />                        shl ebx,2                        <br />                        push esi<br />                        push ebx<br />		mov .pMeshTextures,  $invoke (GlobalAlloc, GPTR,ebx)<br />                        pop ebx<br />                        pop esi<br />                        push esi<br />		invoke RtlZeroMemory, .pMeshTextures,ebx<br />   ;                     invoke MessageBox,0,CTXT(&quot;Materials and Textures buffers were allocated&quot;),CTXT(&quot;Looking Good&quot;),MB_OK<br />		mov axmaterial , $mcall (,ID3DXBuffer_GetBufferPointer)<br />;                        invoke MessageBox,0,CTXT(&quot;Got Pointer to Materials Buffer&quot;),CTXT(&quot;Looking Good&quot;),MB_OK<br />                        pop esi<br /><br />                        mov ecx,0<br />                        .while ecx&lt;.dwNumMaterials;		for( int i = 0; i &lt; dwMaterialCount; i++ )<br />		      push ecx                                                                ;(preserve loop counter during loop)<br />                              push esi<br /><br />                              mov edi,.pMeshMaterials                               ;theres a subtle difference between these<br />                              mov esi,axmaterial                                                ;Calculate source and destination<br /><br />                              mov ebx,sizeof D3DXMATERIAL                         ;for copying the current Material<br />                              imul ebx,ecx                                                          ;note that we are copying from<br />                              add esi,ebx                                                           ;a D3DXMATERIAL into a D3DMATERIAL<br />                              mov ebx,sizeof D3DMATERIAL8                           ;Do you know what it is?<br />                              imul ebx,ecx<br />                              add edi,ebx                       ;    aMaterial<em> = axmaterial<em>.MatD3D = Copy one material <em><br />                              assume esi:LPD3DXMATERIAL<br />                              m2m pname, .pTextureFilename    <br />                              assume esi:nothing<br />                              push esi<br />                              invoke RtlMoveMemory, edi, esi, sizeof D3DMATERIAL8    <br />                              pop esi<br />                        ;                   invoke wsprintf,addr namebuf,CTXT(&quot;Try to load %s&quot;), pname<br />                        ;                   invoke MessageBox,0,addr namebuf,CTXT(&quot;TEXTURE LOADER&quot;),MB_OK<br /><br />      ;** DOES This Material require a Texture to be loaded ?? Huh? Huh? Does it ??<br />		       .if pname != NULL 	;YES so load the texture<br />                                    pop esi<br />                                     pop ecx           <br />                                     push ecx<br />                                    push esi<br />                                     shl ecx,2<br />                                      assume esi:LPMESHNODE           <br />                                     mov esi,.pMeshTextures<br />                                     add esi,ecx                <br />                                    push esi            <br /> 			 invoke D3DXCreateTextureFromFileEx, lpd3dDevice, pname,<br />			 D3DX_DEFAULT, D3DX_DEFAULT,D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED,<br />                                     D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, esi<br />                                    pop esi<br />			.if eax==D3D_OK                                           <br />;                                           invoke wsprintf,addr namebuf,CTXT(&quot;W00T - Texture =  %s&quot;), pname<br />;                                           invoke MessageBox,0,addr namebuf,CTXT(&quot;TEXTURE LOADED&quot;),MB_OK<br />                                            jmp @F<br />			.endif<br />                                .endif<br />                               pop esi<br />                               pop ecx           <br />                               push ecx<br />                               push esi                                                             <br />                               shl ecx,2<br />                               assume esi:LPMESHNODE    <br />                               lea esi,.pMeshTextures<br />                               add esi,ecx     <br />		       mov dword ptr , NULL <br /><br />@@: <br />;                               invoke MessageBox,0,CTXT(&quot;Next Material&quot;),CTXT(&quot;MESHLOADER&quot;),MB_OK<br />                                pop esi<br />                               pop ecx                             ;** RESTORE LoopCounter<br />                                inc ecx                               ; and increment it for the next Material<br />		.endw                                        ;and LOOP until we have processed ALL MATERIALS<br /><br /> ;  invoke MessageBox,0,CTXT(&quot;All Materials (and Textures) have been processed and loaded.&quot;),CTXT(&quot;MESHLOADER&quot;),MB_OK<br /><br />;=====================================================================================<br />.endif                                                    ;(no more cases)<br />;=====================================================================================<br />_saferelease padjacencybuf <br />_saferelease pmaterialsbuf <br />_saferelease pboneoffsetbuf <br />;=====================================================================================<br />invoke GlobalUnlock,pThis<br />invoke MessageBox,0,CTXT(&quot;AWESOME&quot;),CTXT(&quot;MESHNODE CREATED&quot;),MB_OK<br />;=====================================================================================<br />pop esi<br />return S_OK<br />MeshNode_Create ENDP<br /><br /><br />(please disregard my debug messages, the function is working fine :))<br /><br /><br /><br />Next I'll re-enable the AnimationSet parsing code (also driven by FrameNode_Load) as it stands at the moment, then maybe you (maelstrom) might be inclined to help me improve the node hierarchy for storing them all.<br />I'm afraid it may not be quite flexible enough just yet. Hopefully by the end of the week, we'll be able to rend looped animations by name :)</div>
    <div class="meta">Posted on 2003-10-19 06:22:18 by Homer</div>
   </div>
   <div class="post" id="post-121733">
    <div class="subject"><a href="#post-121733">D3D Animation Support Module</a></div>
    <div class="body">Just incase more than two humans are reading this, and haven't bothered downloading the (quite broken) early zip of the entire module...<br /><br />;=====================================================================================<br />MeshNode STRUCT<br />    LO LinkedObject &lt;&gt;<br />;	// mesh variables<br />	pD3DXSkinMesh    LPD3DXSKINMESH ?	;&lt; Pointer to the D3DX skin mesh<br />	pD3DXBlendedMesh   LPD3DXMESH  ? 	;&lt; Pointer to the blended version<br />	pAdjacency                   DWORD ?       	;&lt; The adjacency array<br />;	// materials<br />	pMeshMaterials            DWORD ?		;&lt; Pointer to the array of material structs<br />	pMeshTextures             DWORD ?      	;&lt; The array of pTexture dwords<br />	dwNumMaterials           DWORD ?		;&lt; The number of materials<br />            NumberOfBones           DWORD ?<br />;	// skinning info<br />	dwAttrCount                   DWORD  ?                 ;&lt; The attribute count<br />            dwMaxFaceInfluence    DWORD ?	            ;&lt; Maximum face influence<br />	pBoneMatrix                 LPD3DXMATRIX  ?	;&lt; Bones' matrices array<br />	pBoneNamesBuf          LPD3DXBUFFER ?	;&lt; Bones' names buffer<br />	pBoneOffsetMatrix        LPD3DXMATRIX ?	;&lt; Bones' offset matrices<br />	pBoneCombinationBuf LPD3DXBUFFER ?     ;&lt; Bone combinations buffer<br />MeshNode ENDS<br />LPMESHNODE typedef ptr MeshNode<br />;=====================================================================================</div>
    <div class="meta">Posted on 2003-10-19 06:24:42 by Homer</div>
   </div>
   <div class="post" id="post-121734">
    <div class="subject"><a href="#post-121734">D3D Animation Support Module</a></div>
    <div class="body">MeshNode is meant to be able to be used for not just animated SkinMesh, but also for non-animated (dynamically animated) SkinMesh as well as animated unskinned meshes and plain old nonanimated unskinned meshes.<br /><br />In other words, it's a universal Mesh container and loader, which HAPPENS to be called by FrameNode_Load of the SkinMesh Loader, but is designed to be a generic and freely-callable helper function.<br /><br />Just thought I better mention that :tongue:</div>
    <div class="meta">Posted on 2003-10-19 06:29:01 by Homer</div>
   </div>
   <div class="post" id="post-121735">
    <div class="subject"><a href="#post-121735">D3D Animation Support Module</a></div>
    <div class="body">ah crap - I suppose u'll want this too :alright: <br /><br />MeshNode_GenerateMesh PROC pThis:LPMESHNODE<br />local padjacencyin:ptr<br />local dwfacecount, sizAdj:DWORD<br />local ErrBuf[256]:BYTE<br /><br />.if pThis==NULL<br />    Errr CTXT(&quot;MORON tried to Generate NULL MESHNODE OBJECT&quot;)<br />.endif<br />push esi<br />mov esi,pThis<br />assume esi:LPMESHNODE<br />.if .pD3DXSkinMesh==NULL<br />    pop esi<br />    Errr CTXT(&quot;MORON tried to Generate NULL pD3DXSkinMesh IN MESHNODE OBJECT&quot;)<br />.endif<br /><br />mov dwfacecount, $mcall (.pD3DXSkinMesh,ID3DXSkinMesh_GetNumFaces)<br /> mov ebx,3*4<br />mul ebx<br />mov sizAdj,eax<br />mov padjacencyin , $invoke (GlobalAlloc,GPTR, sizAdj)                      ;Allocate buffer for Adjacency info<br /><br />push esi<br />invoke RtlMoveMemory, padjacencyin, .pAdjacency, sizAdj      ;copy the adjacency buffer<br />pop esi<br /><br /><br />_saferelease .pD3DXBlendedMesh             ;Release the defunct pD3DXBlendedMesh, if any<br />;*** BLEND the mesh<br />mcall .pD3DXSkinMesh,ID3DXSkinMesh_ConvertToBlendedMesh, D3DXMESH_WRITEONLY, padjacencyin, .pAdjacency, addr .dwAttrCount, addr .pBoneCombinationBuf, 0 , 0, addr .pD3DXBlendedMesh <br />push eax<br />invoke GlobalFree, padjacencyin                     ;Free the temp Adjacency buffer<br />mov padjacencyin,NULL<br />pop eax<br />.if eax!=D3D_OK<br />   pop esi<br />   Errr CTXT( &quot;Couldn't convert SkinMesh to BlendedMesh&quot;)<br />.endif<br /><br /><br />; CALCULATE the max face influence count<br />mcall .pD3DXBlendedMesh,ID3DXBaseMesh_GetFVF<br />and eax,  D3DFVF_POSITION_MASK<br />.if eax != D3DFVF_XYZ <br />            sub eax,D3DFVF_XYZRHW<br />            shr eax,1<br />            inc eax<br />            mov .dwMaxFaceInfluence ,eax  	; = ((EAX - D3DFVF_XYZRHW) / 2) +1;<br />.else<br />            mov .dwMaxFaceInfluence , 1<br />.endif<br />ifdef _DEBUG_<br />pushad<br />invoke wsprintf,addr ErrBuf,CTXT(&quot;-= Converted SkinMesh to BlendedMesh =- &quot;,13,10, &quot;--Max Faces Influencing Vertices = %lu&quot;), .dwMaxFaceInfluence<br />invoke MessageBox,0,addr ErrBuf,CTXT(&quot;MeshNode_GenerateMesh&quot;),MB_OK<br />popad<br />endif<br />pop esi<br />return S_OK<br />MeshNode_GenerateMesh ENDP</div>
    <div class="meta">Posted on 2003-10-19 06:30:39 by Homer</div>
   </div>
   <div class="post" id="post-121736">
    <div class="subject"><a href="#post-121736">D3D Animation Support Module</a></div>
    <div class="body">Again, please dismiss debugging messages, overlook the general untidiness of code under review, ignore my ramblings, and please, let me know your thoughts !!<br /><br /><br />(last night I had the strangest dream, involving skeletons running around with their bones all clearly labelled... I need a vacation!!)</div>
    <div class="meta">Posted on 2003-10-19 06:32:38 by Homer</div>
   </div>
   <div class="post" id="post-121759">
    <div class="subject"><a href="#post-121759">D3D Animation Support Module</a></div>
    <div class="body">Keen as mustard :)<br /><br />Ok the parser is almost complete now, but I noticed something I did not expect.<br />I'm testing the code by loading Tiny.x, used in m$'s skinmesh examples.<br />Tiny.x contains TWO TOPLEVEL OBJECTS.<br />The first one is the Frames Hierarchy (and Mesh). We might think of this as being the Bones Hierarchy of the SkinMesh model's skeleton, because it is :)<br />This is where it gets a little weird. The example source I have seen for xfile parsers always expects that any AnimationSet(s) and Animation(s) are found somewhere within the Frames hierarchy. In the case of Tiny.x, that isn't so.<br />Tiny.x keeps its AnimationSet as TOPLEVEL OBJECT #2.<br />As a result I'm editing my SkinMesh_Create function (which is the Caller of FrameNode_Load) to check for and parse Animation Frames from there.<br />I will however leave the support for embedded animation parsing in the FrameNode_Load function. We might get into trouble if we try loading an XFile that contains Animations in both, as my Node structure wasn't designed to have more than one Root. Nevermind, we'll work around it :)<br />The main thing is that I'm having a good day and grinning like an idiot :grin:</div>
    <div class="meta">Posted on 2003-10-19 11:11:41 by Homer</div>
   </div>
   <div class="post" id="post-121786">
    <div class="subject"><a href="#post-121786">D3D Animation Support Module</a></div>
    <div class="body">Hey Homer<br /><br />Wow, slow down Homer you might pull something :grin:<br /><br /><strong><em>then maybe you (maelstrom) might be inclined to help me improve the node hierarchy</em></strong><br /><br />Cool, I'd love to help out if I can :alright:<br />Could you post or email me a zip containing the current project files?<br />Are you using DX8.1?<br /><br /><strong><em>last night I had the strangest dream, involving skeletons running around with their bones all clearly labelled... I need a vacation!!</em></strong><br /><br />LOL - go play Morrowind for a while :grin:<br /><br /><strong><em>I'm having a good day and grinning like an idiot</em></strong><br /><br />Oh I know that feeling :grin:<br /><br />Maelstrom</div>
    <div class="meta">Posted on 2003-10-19 19:53:45 by Maelstrom</div>
   </div>
   <div class="post" id="post-121796">
    <div class="subject"><a href="#post-121796">D3D Animation Support Module</a></div>
    <div class="body">This project is built on DX8.1<br />Due to filesize restrictions, it's quite painful for me to upload the entire project.<br />In fact, even if I remove all resources (xfiles, bmps etc) and unimplemented code modules (audio engine etc) and then rar and zip it, it's still over 300kb.<br />I have no choice but to upload separate zips.<br />This is fine because I keep related files in a folder hierarchy anyway - ie, the source is already bundled into tidy folders.<br /><br />You will have to create the folders yourself.<br />The Project folder contains two folders. One called XFILE contains xfiles and their textures. The other called Include contains a bunch of files and a bunch of folders.<br />I won't name the files in there but the Folders inside the Include folder are as follows: AudioEngine, Camera, SkinMesh, Terrain, Plants and Render.<br /><br />Of these, only Camera, SkinMesh and Render contain currently-implemented code.<br /><br />Having said that, I'm going to post the main asm file here now.<br />Please note my Naming convention - when I code a MASM project, it contains JUST ONE .ASM FILE, all other included files use the extension .INC<br />This means I can build my project even when I've been drinking too much beer :)<br /><br />Without further ado: the Win32 Skeleton :alright:<br />Take a look, let me know how you feel about it, I've spent no time optimizing this yet, and I'm sure there's many improvements to be made.<br /><br /><br /><br />; #########################################################################<br />.586p<br />.MMX<br />.MODEL FLAT,STDCALL<br />OPTION SCOPED        ; Local labels are enabled, global labels inside<br />                     ; PROC should be defined with double colons (LABEL::)<br />OPTION CASEMAP:NONE  ; case sensitivity enabled<br />OPTION LJMP<br />MAIN_THREAD_STACKSIZE_KB=32<br />;#########################################################################<br /><br /><br />;September 15 - been working hard on translating support for animated SkinMesh models :)<br />;September 17 - successful compile - begin debugging<br />;September 22 - debugged MeshNode_Create and MeshNode_GenerateMesh I think 100% working<br />;                       - have Frames Loader working better but falls over when trying to process Bone info hmmmz<br />;                       - conclusion = buggy frames loader = yucky hierarchy<br /><br />;September 31 - Adopted a new model for use of links in building of frames hierarchy<br />;October 1 - Eliminated a bug in the Materials Parser of Mesh Loader (esi was being trashed by RtlMoveMemory)<br />;October 2 - Working on AnimationSet Loader<br />;October 3 - Disabled call to SkinMesh_FindBones until I have debugged preceding code.<br />;                    Tomorrow's job will be isolating the bug.<br />;                    I'll begin by tidying up object creation code to properly null fields.<br />;October 4 - Bug resides somewhere in Animation Loader (no big suprise there)<br />;                    Began rebuilding Loader so that template identification happens before FrameNode_Load<br />;                    So that Frame templates are treated as a Case rather than given such importance.<br />;October 5 - MAJOR THINGS HAPPPENING<br />;                   Studied Scronty's FramesHierarchy example and noticed something VERY IMPORTANT<br />;                   He LOCKS AND UNLOCKS his dynamic objects when he creates them, <br />;                    and he LOCKS AND UNLOCKS them again before and after he accesses them !!!<br />;                   I've altered the LinkedList code to this end, which has made pLock redundant.<br />;                   THAT WAS A BASTARD OF A JOB !!<br />;                   I still haven't done the Destructors, and I disabled lots of stuff using LL to get LL working first.<br />;                   Next are the generic LL destructors.<br />;October 6 - Busily altering the ENTIRE CODEBASE to operate with OBJECT HANDLES<br />;                   rather than POINTERS. This is most distressing. My hair !! DOH :|<br />;October 11- Everythings hunky dory again - I just moved the call to LoadSkinMesh before I saved.<br />;October 12- moved call to skinmesh loader into its own Loader thread, created in WndProc on WM_CREATE.<br />;October 13- grr what happened to my SkinMesh loader? I'm no longer detecting nonframe templates !!?!<br />;October 19- SkinMesh loader told me it feels better than James Brown<br />;October 20- Published this source on Win32asmCommunity.net messageboard<br /><br />;=============================<br />    FAILED            EQU     0<br />    SUCCEEDED   EQU     0<br />;=============================<br />    DEFAULT_QUALITY                EQU     0<br />    DRAFT_QUALITY                     EQU     1<br />    PROOF_QUALITY                    EQU     2<br />    NONANTIALIASED_QUALITY   EQU     3<br />    ANTIALIASED_QUALITY          EQU     4<br />;=============================<br />GS_RUNNING equ 0                ;GameStates<br />GS_MENU equ 1<br />GS_LOADING equ 2<br />GS_SPLASH equ 3<br />;=============================<br />GM_MAIN equ 0                       ;MenuStates<br />GM_VIDEO equ 1<br />GM_AUDIO equ 2<br />GM_GAME equ 3<br />GM_BACK equ 4<br />;=================================================================<br />;We'll invent an object identification system so we can be lazy with our coding :)<br />OBJECT_TYPE_NOT_DEFINED equ 0<br />CHUNKY_3D_TEXT_OBJECT    equ 1<br />;=================================================================<br /><br />;###################################################################################<br />.data<br />include Include\Project.inc                                         ;This contains application data, api includes, structs, typedefs, etc.<br />include Include\MACRO_DegreesToRadians.inc      ;These Helper Macros leave stuff on the FP stack !!<br />include Include\MACRO_RadiansToDegrees.inc<br />;###################################################################################<br />.code<br />      include Include\RandomGen.inc                                ;A nice Mersenne Twister variant (author unknown - sorry!)<br />      include Include\dxutil_Timer.asm                              ;Thx Scronty<br />      include Include\LinkedLists_NamedObjects.inc        ;Thx Homer - LinkedList management         <br />      include Include\LinkedLists_SafeDelete.inc              ;Thx Homer - LinkedList management      <br />      include Include\SafeRelease_ObjectLL.inc <br />      include Include\SafeRelease_LL.inc <br />      include Include\LinkedLists_FindYoungestSibling.inc<br />      include Include\LinkedLists_AppendOrInsert.inc       ;Thx Homer - LinkedList management<br />      include Include\LinkedLists_Append.inc                    ;Thx Homer - LinkedList management<br />      include Include\LinkedLists_AppendSibling.inc         ;Thx Homer - LinkedList management<br />      include Include\LinkedLists_FindEntryByName.inc   ;Thx Homer - LinkedList management<br /><br />      include Include\Camera\PlayerObject.inc<br />      include Include\SafeRelease_Player.inc<br /><br />      include Include\Pick_ScreenToVector.inc<br />      include Include\Mouse_PickTest.inc                          ;Thx Scronty - called from Object_DrawInPosition<br /><br />      include Include\Object_LoadMeshFromXFile.inc<br />      include Include\Object_SafeRelease_MACRO.inc     ;Thx Homer - Application LinkedObject management<br />      include Include\SafeRelease_TexObject.inc<br />      include Include\Object_CreateLinked3DText.inc       ;Thx Homer - Application LinkedObject management<br />      include Include\Object_CalculateMatrix.inc                 ;Thx Homer The Wise<br />      include Include\Object_AlterRotationWithTime.inc      ;Thx Homer<br />      include Include\Object_DrawInPosition.inc                  ;Thx Homer<br /><br />      include Include\Plants\HerbGrower.inc<br />;      include Include\Terrain\Terrain_Create.inc       <br /><br />      include Include\CmpGUID.inc<br />      include Include\SkinMesh\IdentifyGUID.inc<br />      include Include\SkinMesh\MeshNode.inc<br />      include Include\SkinMesh\AnimationNode.inc<br />      include Include\SkinMesh\FrameNode.inc<br />      include Include\SkinMesh\SkinMesh.inc         ;Container support for SkinMeshes<br /><br />      include Include\DrawTextLine.inc<br />      include Include\Render_Text.inc<br />      include Include\D3DUtil_SetDeviceCursor.inc           ;Thx Homer<br />      include Include\D3D_CheckHardware.inc     <br />      include Include\Create3DAlphabet.inc<br />      include Include\Create2DPanel.inc    <br />      include Include\D3D_Initialize.inc                              ;called from WndProc        <br />      include Include\D3D_InitFonts.inc                             ;called from InitD3D, initialises a couple of D3D Fonts<br /><br />      include Include\ConvertDWColorToD3DXColor.inc    ;Thx Homer<br />      include  c:\masm32\include\d3dx8math_fkt.def         ;Thx Caleb .. contains LERP + much more<br />      include Include\Make3DText.inc                                 ;called from CreateLinked<br />      include Include\SetupCamera.inc                               ;called from Render, =setup camera view<br />      include Include\SetupLights.inc                                ;called from Render, creates a cool lightsource<br />      include Include\Render.inc             ;called from MessagePump, =main render proc<br />      include Include\CheckDeviceIsGoodToRender.inc<br />      <br />     include Include\LoaderThread.inc<br /><br />;include     \masm32\include\winextra.def<br />;include \masm32\include\oaidl.inc<br /> ;      include \masm32\include\dmplugin.def      ;directmusic includes --&gt;dmusicc.def--&gt;dmusici.def<br />  ;    include Include\AudioEngine\AudioEngineData.inc<br />   ;   include Include\AudioEngine\InitializeMusic.inc<br />; #########################################################################<br /><br /><br />.code<br />start:<br /><br />;============================================================================<br />;The following code snippet was used to test FP Compare macro<br />;============================================================================<br /> ;       fld fp2<br /> ;       fchs<br /> ;       fcomp fp1<br /> ;       __FJL Term1IsLower     <br /> ;       invoke MessageBox,0,CTXT(&quot;Term1 is NOT Lower than Term2&quot;),CTXT(&quot;FPTEST&quot;),MB_OK<br /> ;       jmp @F<br /> ;       Term1IsLower:<br /> ;       invoke MessageBox,0,CTXT(&quot;Term1 is Lower than Term2&quot;),CTXT(&quot;FPTEST&quot;),MB_OK<br /> ;  @@:<br />;============================================================================<br /><br />      call TRandomInit <br />      mov hInstance,         $invoke (GetModuleHandle,NULL)<br />      mov CommandLine, $invoke (GetCommandLine)      <br />      mov hIcon,                $invoke (LoadIcon,hInstance,500)    ; icon ID     <br />      mov hCursor,            $invoke (LoadCursor,NULL,IDC_ARROW)      <br />      mov sWid,                $invoke (GetSystemMetrics,SM_CXSCREEN)      <br />      mov sHgt,                 $invoke (GetSystemMetrics,SM_CYSCREEN)    <br />      call Main<br />      invoke ExitProcess,eax<br />      invoke InitCommonControls<br />      <br />; #########################################################################<br />Main proc<br />    SingleInstanceOnly CTXT(&quot;More_Ass_Than_Class&quot;)<br />    invoke RegisterWinClass,ADDR WndProc,CTXT(&quot;More_Ass_Than_Class&quot;),<br />                       hIcon,hCursor,COLOR_BTNFACE+1<br />    invoke CreateWindowEx,NULL,<br />                          CTXT(&quot;More_Ass_Than_Class&quot;),<br />                          ADDR szDisplayName,<br />                          WS_OVERLAPPED or WS_SYSMENU,<br />                          0,0,sWid,sHgt,<br />                          NULL,NULL,<br />                          hInstance,NULL<br />    mov hWnd,eax<br />    DisplayWindow hWnd,SW_SHOWNORMAL<br />    call MsgLoop<br />    ret<br />Main endp<br /><br />; #########################################################################<br />RegisterWinClass proc lpWndProc:DWORD, lpClassName:DWORD,<br />                      Icon:DWORD, Cursor:DWORD, bColor:DWORD<br />local wc:WNDCLASSEX<br /><br />    mov wc.cbSize,         sizeof WNDCLASSEX<br />    mov wc.style,          CS_BYTEALIGNCLIENT or \<br />                           CS_BYTEALIGNWINDOW<br />    m2m wc.lpfnWndProc,    lpWndProc<br />    mov wc.cbClsExtra,     NULL<br />    mov wc.cbWndExtra,     NULL<br />    m2m wc.hInstance,      hInstance<br />    m2m wc.hbrBackground,  bColor<br />    mov wc.lpszMenuName,   NULL<br />    m2m wc.lpszClassName,  lpClassName<br />    m2m wc.hIcon,          Icon<br />    m2m wc.hCursor,        Cursor<br />    m2m wc.hIconSm,        Icon<br />    invoke RegisterClassEx, ADDR wc<br />    ret<br />RegisterWinClass endp<br /><br />; ########################################################################<br /><br />.data <br />fff    FLOAT 0.0f<br />.code<br />MsgLoop proc<br />LOCAL msg:MSG<br /><br />         @@:<br />      invoke PeekMessage,addr msg,NULL,0,-1,PM_NOREMOVE<br />      .if eax==0                ;if its zero, no messages are waiting<br />         invoke CheckDeviceIsGoodToRender <br />          .if OkToRender==TRUE                    <br />                    invoke Render, hWnd, 0FFh<br />          .endif<br />      .else                        ;if WM's are waiting...<br />          invoke GetMessage,ADDR msg,NULL,0,0<br />          .if eax==0            ;if its zero, its time to die !!<br />            jmp @F<br />           .else<br />             invoke TranslateMessage, ADDR msg<br />             invoke DispatchMessage,  ADDR msg<br />             invoke CheckDeviceIsGoodToRender <br />              .if OkToRender==TRUE                    <br />                    invoke Render, hWnd, 0FFh<br />              .endif<br />           .endif<br />        .endif<br />        jmp @B     <br />    @@:<br /><br />    mov eax, msg.wParam<br />    ret<br /><br />MsgLoop endp<br /><br />; #########################################################################<br /><br />WndProc proc hWin,uMsg,wParam,lParam   :DWORD<br /><br />    LOCAL var,caW,caH    :DWORD<br />    LOCAL Rct    :RECT<br />    LOCAL buffer1,buffer2[128]:BYTE  ; these are two spare buffers<br />    LOCAL szDropFileName[260]:BYTE<br />    LOCAL vDist:D3DXVECTOR3<br />    local localColor1:D3DXCOLOR<br />    local localColor2:D3DXCOLOR<br />    local floctemp:FLOAT<br />    local rc:RECT<br /><br /><br />    .if uMsg == WM_SYSCOLORCHANGE<br /><br />    .elseif uMsg == WM_SIZE<br /><br />;-----------------------------------------------------------------------------------------------------------------------------<br />    .elseif uMsg==WM_CHAR<br />        mov eax,wParam<br />        .if al==&quot; &quot; &amp;&amp; AppState==GS_RUNNING<br />            mov AppState,GS_MENU<br />        .elseif al==0Dh &amp;&amp; AppState==GS_MENU<br />            .if MenuSelected==1<br />                    mov MenuState,GM_VIDEO<br />            .elseif MenuSelected==2<br />                    mov MenuState,GM_AUDIO<br />            .elseif MenuSelected==3<br />                    mov MenuState,GM_GAME<br />            .elseif MenuSelected==4<br />                 .if FadingMenu==FALSE<br />                    mov FadingMenu,TRUE<br />                    invoke DXUtil_Timer,TIMER_GETAPPTIME<br />                    fstp fTimeFadeBegan<br />                    mov AppState,GS_RUNNING        <br />                .endif<br />            .endif        <br /><br />        .elseif al==1Bh                                 ;ESCAPE KEY<br />            .if AppState==GS_RUNNING<br />                jmp dienow<br />            .else<br />                mov MenuState,GM_MAIN<br />                mov AppState,GS_RUNNING        <br />            .endif<br />        .endif<br /><br />     .elseif uMsg==WM_KEYDOWN &amp;&amp; AppState==GS_MENU<br />        mov eax,wParam<br />        .if MenuState==GM_MAIN<br />            .if eax==VK_DOWN<br />                .if MenuSelected&lt;4<br />                    inc MenuSelected<br />                .endif<br />            .elseif eax==VK_UP<br />                .if MenuSelected&gt;1  <br />                    dec MenuSelected<br />                .endif<br />            .endif<br />        .elseif MenuState==GM_VIDEO<br />            .if eax==VK_DOWN<br />                mov eax,ModesCounter<br />                .if MenuSelected&lt;eax<br />                    inc MenuSelected<br />                .endif<br />            .elseif eax==VK_UP<br />                .if MenuSelected&gt;1  <br />                    dec MenuSelected<br />                .endif<br />            .endif<br />        .endif<br /><br />     .elseif uMsg==WM_KEYDOWN &amp;&amp; AppState==GS_RUNNING<br />        mov eax,wParam<br />        .if eax==VK_UP<br />           fld fPlayerSpeed<br />           fistp fptemp<br />           mov eax,fptemp<br />           .if eax&gt;100<br />               fld fMaxSpeed<br />               fstp fPlayerSpeed<br />           .elseif eax==0<br />                 fld fp0pt1<br />               fstp fPlayerSpeed<br />           .endif<br />           fld fPlayerSpeed   <br />           fmul fp1pt04      <br />           fstp fPlayerSpeed  <br />@@:<br />        .elseif eax==VK_DOWN<br />            fld fPlayerSpeed<br />            fsub fp0pt04<br />            fstp fPlayerSpeed            <br />        .endif<br /><br />;-----------------------------------------------------------------------------------------------------------------------------<br />;-----------------------------------------------------------------------------------------------------------------------------<br />    .elseif uMsg==WM_MOUSEMOVE<br />        .if AppState==GS_RUNNING &amp;&amp; RightButtonState==FALSE         ;(if the user has not got rightbutton down)<br />     ;       invoke HandleMouseMove<br />        .endif<br /><br />;-----------------------------------------------------------------------------------------------------------------------------<br />    .elseif uMsg==WM_LBUTTONUP<br />        mov DisablePickUntilDickWadReleasesTheButton,FALSE<br />        mov DickWadHasDepressedButton,FALSE<br />        invoke ReleaseCapture<br />        return NULL<br />;-----------------------------------------------------------------------------------------------------------------------------<br />    .elseif uMsg==WM_LBUTTONDOWN<br />      .if AppState==GS_MENU <br />        .if MenuState==GM_MAIN        <br />           .if (MouseY&gt;155 &amp;&amp; MouseY&lt;174)<br />                .if (MouseX&gt;310 &amp;&amp; MouseX&lt;488)<br />                        mov MenuSelected,1<br />                        mov MenuState,GM_VIDEO<br />                .endif<br />            .elseif (MouseY&gt;185 &amp;&amp; MouseY&lt;206)<br />                .if (MouseX&gt;310 &amp;&amp; MouseX&lt;488)<br />                    mov MenuSelected,2<br />                    mov MenuState,GM_AUDIO<br />                .endif    <br />            .elseif  MouseY&gt;216 &amp;&amp; MouseY&lt;237 <br />                    .if MouseX&gt;229 &amp;&amp; MouseX&lt;484<br />                        mov MenuSelected,3<br />                        mov MenuState,GM_GAME<br />                    .endif<br />            .elseif  MouseY&gt;248 &amp;&amp; MouseY&lt;267 <br />                    .if MouseX&gt;373 &amp;&amp; MouseX&lt;426<br />                        mov MenuSelected,4                   <br />                        mov FadingMenu,TRUE<br />                        invoke DXUtil_Timer,TIMER_GETAPPTIME<br />                        fstp fTimeFadeBegan<br />                        mov AppState,GS_RUNNING   <br />                    .endif<br />            .endif<br /><br />        .elseif MenuState==GM_VIDEO<br />            mov eax,LastV2                                          ;Render sets these for us<br />            mov ebx,LastV1<br />           .if (MouseY&gt;ebx &amp;&amp; MouseY&lt;eax)<br />                .if (MouseX&gt;273 &amp;&amp; MouseX&lt;527)<br />                        mov AppState,GS_RUNNING<br />                .endif<br />            .endif<br />        .endif<br /><br />      .elseif AppState==GS_RUNNING<br />          invoke SetCapture,hWin                                ;Our window is to capture mouse activity<br />          mov DickWadHasDepressedButton,TRUE    ;this flag triggers the &quot;PickRay&quot; code<br />          return NULL<br />      .endif<br />;-----------------------------------------------------------------------------------------------------------------------------<br />    .elseif uMsg==WM_RBUTTONDOWN            ;Begin &quot;DRAGMODE&quot;<br />        mov RightButtonState,TRUE<br />        invoke GetCapture<br />        .if eax != NULL<br />            invoke Pick_ScreenToVector, hWin, addr vPickRayOrig, addr vPickRayDir<br />        .endif<br /><br />            m2m MouseX_DragBegan,MouseX<br />            m2m MouseY_DragBegan,MouseY<br /><br />;-----------------------------------------------------------------------------------------------------------------------------<br />    .elseif uMsg==WM_RBUTTONUP<br />        mov RightButtonState,FALSE<br /><br />;-----------------------------------------------------------------------------------------------------------------------------<br />    .elseif uMsg == WM_PAINT<br />        invoke Paint_Proc,hWin<br />        return 0<br /><br />    .elseif uMsg == WM_CLOSE<br /><br />    .elseif uMsg == WM_DESTROY<br />dienow:<br />        invoke DXUtil_Timer, TIMER_STOP<br />        fstp fTime<br />        invoke D3DCleanup<br />        invoke PostQuitMessage,NULL<br />        return 0<br /><br />    .elseif uMsg==WM_CREATE<br />                                    invoke GetClientRect,hWin,addr rc<br />                                    mov eax,rc.right<br />                                    sub eax,rc.left<br />                                    shr eax,1<br />                                    mov ebx,rc.bottom<br />                                    sub ebx,rc.top<br />                                    shr ebx,1<br />                                    mov MouseX_Centre,eax<br />                                    mov MouseY_Centre,ebx<br />                                    invoke SetCursorPos,eax,ebx<br />                                        <br />        .if $invoke (InitD3D,hWin)==S_OK<br />            invoke DXUtil_Timer, TIMER_START<br />            fstp fTime<br />;----------------------------------------------------------------------------------------------------------------------------------------------------<br />;This snippet was used to test the LinkedList codebase<br /> ; ;----------------------------------------------------------------------------------------------------------------------------------------------------<br /> ;               mov pSkins,$invoke (LinkedLists_AppendSibling,NULL,NULL,sizeof Object)<br /> ;                                     push eax<br /> ;                                     invoke LinkedObjects_SetName,eax,CTXT(&quot;heh&quot;)<br /> ;                                     invoke  LinkedLists_AppendSibling,eax,NULL,sizeof Object<br /> ;                                     invoke LinkedObjects_SetName,eax,CTXT(&quot;child1&quot;)<br /> ;                                     pop eax<br /> ;                                     invoke  LinkedLists_AppendSibling,eax,NULL,sizeof Object<br /> ;                                     invoke LinkedObjects_SetName,eax,CTXT(&quot;child2&quot;)<br /> ;               invoke saferelease_LL, pSkins<br /> ;               mov pSkins,$invoke (LinkedLists_AppendSibling,NULL,NULL,sizeof Object)<br /> ;                                     push eax<br /> ;                                     invoke LinkedObjects_SetName,eax,CTXT(&quot;heh&quot;)<br /> ;                                     invoke  LinkedLists_AppendSibling,eax,NULL,sizeof Object<br /> ;                                     invoke LinkedObjects_SetName,eax,CTXT(&quot;child1&quot;)<br /> ;                                     pop eax<br /> ;                                     invoke  LinkedLists_AppendSibling,eax,NULL,sizeof Object<br /> ;                                     invoke LinkedObjects_SetName,eax,CTXT(&quot;child2&quot;)<br /> ;               invoke saferelease_LL, pSk<br />;----------------------------------------------------------------------------------------------------------------------------------------------------<br />    <br />;        mov hLoaderThread,$invoke (CreateThread,NULL,NULL,addr LoaderThread,0,NULL,addr LoaderThreadID)<br />        mov pSkins,$invoke (SkinMesh_Create,CTXT(&quot;C:\masm32\directxex\xfile\tiny.x&quot;))  <br /><br /><br />        .else<br />            invoke MessageBox,0,CTXT(&quot;Failed to initialize Direct3D&quot;,13,10,&quot;I'm out of here !!&quot;),CTXT(&quot;Critical Error !!&quot;),MB_OK+MB_ICONERROR<br />            jmp dienow<br />        .endif    <br />    .endif<br />;----------------------------------------------------------------------------------------------------------------------------------------------------<br />    invoke DefWindowProc,hWin,uMsg,wParam,lParam<br />    ret<br /><br />WndProc endp<br /><br />; ########################################################################<br />TopXY proc wDim:DWORD, sDim:DWORD<br />    shr sDim, 1      ; divide screen dimension by 2<br />    shr wDim, 1      ; divide window dimension by 2<br />    mov eax, wDim    ; copy window dimension into eax<br />    sub sDim, eax    ; sub half win dimension from half screen dimension<br />    return sDim<br />TopXY endp<br />; #########################################################################<br />Paint_Proc proc hWin:DWORD<br />    LOCAL hDC,btn_hi,btn_lo:DWORD<br />    LOCAL Rct      :RECT<br />    LOCAL Ps       :PAINTSTRUCT<br />    mov hDC, $invoke (BeginPaint, hWin, addr Ps)<br />    mov btn_hi, $invoke (GetSysColor,COLOR_BTNHIGHLIGHT)<br />    mov btn_lo, $invoke (GetSysColor,COLOR_BTNSHADOW)<br />    return $invoke (EndPaint,hWin,ADDR Ps)<br />Paint_Proc endp<br />; ########################################################################<br /><br />end start<br /><br />:alright:             :alright:              :alright:<br /><br />ok here's the Project.inc file which is basically holds all our named variables and general application data...<br /><br /><br /> LPOBJECT typedef ptr Object<br />; #########################################################################<br /><br />;     api include files<br />;     ~~~~~~~~~~~~~<br />      include c:\masm32\include\windows.inc<br />      include c:\masm32\include\masm32.inc<br />      include c:\masm32\include\winmm.inc<br />      include c:\masm32\include\gdi32.inc<br />      include c:\masm32\include\user32.inc<br />      include c:\masm32\include\kernel32.inc<br />      include c:\masm32\include\Comctl32.inc<br />      include c:\masm32\include\comdlg32.inc<br />      include c:\masm32\include\shell32.inc<br />      include c:\masm32\include\oleaut32.inc<br />      include c:\masm32\include\advapi32.inc<br /><br />;    api libraries<br />;     ~~~~~~~~~<br />      includelib c:\masm32\lib\masm32.lib<br />      includelib c:\masm32\lib\winmm.lib<br />      includelib c:\masm32\lib\gdi32.lib<br />      includelib c:\masm32\lib\user32.lib<br />      includelib c:\masm32\lib\kernel32.lib<br />      includelib c:\masm32\lib\Comctl32.lib<br />      includelib c:\masm32\lib\comdlg32.lib<br />      includelib c:\masm32\lib\shell32.lib<br />      includelib c:\masm32\lib\oleaut32.lib<br />      includelib c:\masm32\lib\advapi32.lib<br /><br /><br /><br /><br />; D3D CRAP<br />;==========<br />     include c:\masm32\include\d3d8types.inc<br />      include c:\masm32\include\d3dx8.inc<br />      includelib c:\masm32\lib\d3dx8.lib<br />      includelib c:\masm32\lib\d3d8.lib<br />      includelib c:\masm32\lib\d3dx8d.lib<br />      include    c:\masm32\include\dxfile.inc<br />      includelib  c:\masm32\lib\d3dxof.lib<br />      includelib  c:\masm32\lib\dxguid.lib<br />      include     c:\masm32\include\d3dx8.inc<br />      include     c:\masm32\dx81include\d3dx8math.inc<br />      include      c:\masm32\include\d3dx8math_fkt.def<br />      includelib  c:\masm32\lib\msvcrt.lib<br />      include c:\masm32\include\ole32.inc<br />      includelib c:\masm32\lib\ole32.lib<br />      include     c:\masm32\include\winextra.def    <br /><br />;Any objects to be stored in LinkedLists should begin with the following data structure...<br />;#########################################################################<br />LPLINKEDOBJECT      typedef ptr LinkedObjectHeader <br />LinkedObjectHeader STRUCT<br />    ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />    hName                    DWORD ?                        ;Handle to the name of this linkedobject<br />    hChild                    LPLINKEDOBJECT      ?    ;Handle to my child if I have one<br />    hSibling                 LPLINKEDOBJECT      ?    ;Handle to my younger sibling if I have one<br />LinkedObjectHeader ENDS<br />LinkedObject typedef LinkedObjectHeader <br />;#########################################################################<br /> LPOBJECT typedef ptr Object<br />Object STRUCT<br />  LO                     LinkedObject &lt;&gt;         ;LinkedList support structure<br />  ObjectType          DWORD ?                ;We just might wanna know this if we have more than 1 kind<br />  bSelected            DWORD FALSE<br />  dwNumMaterials DWORD ?<br />  vLocation            D3DVECTOR &lt;&gt;        ;where in 3D space this object is currently located<br />  fYaw                    FLOAT ?                   ;Three angles = the 3D rotation (orientation) of the object<br />  fPitch                   FLOAT ?<br />  fRoll                    FLOAT ? <br />  vCenter              D3DVECTOR &lt;&gt;          ;Vector from ObjectOrigin to &quot;Best Center&quot;<br />  fRadius               FLOAT ?                   ;Radius of Object Bounding Sphere<br />  matLocal          D3DXMATRIX   &lt;&gt;                  ;will be used to manipulate the object according to the above info<br />  pMesh                 DWORD ?                ;Pointer to this object's Mesh<br />  pMeshMaterials DWORD ?                ;Pointer to array of D3DMATERIAL8 structs<br />  pMeshTextures DWORD ?                 ;Pointer to array of pTexture dwords<br />Object  ENDS<br />;#########################################################################<br /><br />; #########################################################################<br /><br />        ;=====================<br />        ; Some crappy prototypes<br />        ;=====================<br />        WinMain          PROTO :DWORD,:DWORD,:DWORD,:DWORD<br />        WndProc          PROTO :DWORD,:DWORD,:DWORD,:DWORD<br />        TopXY            PROTO :DWORD,:DWORD<br />        Paint_Proc       PROTO :DWORD<br />        RegisterWinClass PROTO :DWORD,:DWORD,:DWORD,:DWORD,:DWORD<br />        MsgLoop          PROTO<br />        Main             PROTO<br />        InitFonts PROTO :DWORD<br />        Create3DTextObject PROTO :DWORD, :DWORD, :DWORD, :DWORD<br />        Make3DText PROTO :DWORD, :DWORD, :DWORD, :DWORD, :DWORD, :DWORD,:DWORD,:DWORD<br />        EnumDisplayModes PROTO <br />        wsprintfA PROTO C :DWORD,:VARARG<br />        wsprintf equ &lt;wsprintfA&gt;<br /><br /><br /><br />        ;=====================<br />        ; Some crappy macros<br />        ;=====================<br />        include macros.inc<br /><br />    ; --------------------------------------------<br />    ; equates to use directly in the message loop<br />    ; --------------------------------------------<br />        m_hWnd   equ &lt;msg.hwnd&gt;<br />        m_Msg    equ &lt;msg.message&gt;<br />        m_wParam equ &lt;msg.wParam&gt;<br />        m_lParam equ &lt;msg.lParam&gt;<br /><br />    .data<br />        szDisplayName db &quot;Directxex&quot;,0<br />        szFont                db 'Comic Sans MS',0<br />        AppState             dd GS_SPLASH<br />        MenuState          dd GM_MAIN<br />        MenuSelected    dd 1<br />        pDisplayModesRoot dd     NULL       ;LinkedList Root Pointers<br />        pLLObjectsRoot  dd NULL<br />        hPlayerObject     dd NULL                 ;handle to Root of PlayerObjects (first Player=Local Player)<br />        pExtended           dd NULL                  ;Temp pointer to extended page<br />        lpD3D           dd NULL<br />        lpd3dDevice dd NULL<br />        OkToRender dd FALSE<br />        fTime FLOAT 0.0f<br />        ModesCounter    dd NULL                  ;#Video Modes<br />        PlayerName        db 256 dup(0)<br />        DickWadHasDepressedButton                         dd FALSE<br />        DisablePickUntilDickWadReleasesTheButton dd FALSE<br />        FadingMenu                                                      dd FALSE<br />        fTimeFadeBegan FLOAT 0.0f<br />        LoadingText db 256 dup(0)<br />        <br />    .data?<br />        hInstance dd ?<br />        CommandLine dd ?<br />        hIcon dd ?<br />        hCursor dd ?<br />        sWid dd ?<br />        sHgt dd ?<br />        hWnd dd ?<br />        dwNumOfVertices dd ?<br />        dwNumOfFaces dd ?<br />        FaceIndex          dd ?                  ;Index of Hit Face for MousePick<br />vPickRayDir D3DXVECTOR3 &lt;&gt;<br />vPickRayOrig D3DXVECTOR3 &lt;&gt;<br />        pFontLarge dd ?<br />        lp3DFont dd ?<br />        lp3DFontUL dd ?<br />        MouseX dd ?<br />        MouseY dd ?<br />        MouseX_Centre dd ?<br />        MouseY_Centre dd ?<br />        MouseX_DragBegan dd ?<br />        MouseY_DragBegan dd ?<br />        LastV1     dd ?                              ;Vertical Position - Beginning<br />        LastV2     dd ?                              ;Vertical Position - End<br />        matIdentity D3DXMATRIX &lt;&gt;    <br />        matView      D3DMATRIX &lt;&gt;<br />        matProj       D3DMATRIX &lt;&gt;<br /><br />;#########################################################################<br />;We couldn't define this till now becuz we needed d3dx8.inc for D3DXVECTOR3...<br />;Nevermind, we'll do it now - no harm done :)<br />;#########################################################################<br />    ;   A structure for our custom vertex type<br />CUSTOMVERTEX    STRUCT<br />x FLOAT ?<br />y FLOAT ?<br />z FLOAT ?<br />color          DWORD   ?<br />u              FLOAT ?<br />v              FLOAT ?<br />CUSTOMVERTEX    ENDS<br />    sizofCUSTOMVERTEX   EQU     (sizeof CUSTOMVERTEX)<br /><br />D3DVERTEX    struct  DWORD<br />     position       D3DXVECTOR3 &lt;&gt;      ;   // The position<br />     normal         D3DXVECTOR3 &lt;&gt;      ;   // The normal<br />     tu             FLOAT       0.0f    ;   // The texture coordinates<br />     tv             FLOAT       0.0f    ;   // The texture coordinates<br />D3DVERTEX    ENDS<br />sizeofD3DVERTEX   EQU     (sizeof D3DVERTEX)<br /><br />;This FVF is used for drawing 2D Textured Quads (&quot;billboards&quot;)<br /><br />TEXQUADVERTEX struct<br />     position       D3DXVECTOR3 &lt;&gt;      ;   // The position<br />     color           D3DCOLOR NULL        ;   // The color<br />     tu             FLOAT       0.0f    ;   // The texture coordinates<br />     tv             FLOAT       0.0f    ;   // The texture coordinates<br />TEXQUADVERTEX ends<br /><br />;D3DFVF_TEXQUADVERTEX equ D3DFVF_XYZRHW or D3DFVF_DIFFUSE or D3DFVF_TEX1<br />D3DFVF_TEXQUADVERTEX equ D3DFVF_XYZ or D3DFVF_DIFFUSE or D3DFVF_TEX1<br /><br />;#########################################################################<br />;   Our custom FVF, which describes our custom vertex structure<br />    D3DFVF_CUSTOMVERTEX EQU (D3DFVF_DIFFUSE OR D3DFVF_XYZ OR D3DFVF_NORMAL)<br />D3DFVF_VERTEX EQU (D3DFVF_XYZ OR D3DFVF_NORMAL OR D3DFVF_TEX1)<br /><br />;#########################################################################<br /><br />;Floating Point constants we wanna use, with nice simple naming convention.<br />.data<br />RightButtonState dd FALSE<br /><br />fPlayerSpeed FLOAT 0.0f<br />fMaxSpeed    FLOAT 100.0f<br />fp0                 FLOAT 0.0f<br />fp0pt999        FLOAT 0.999f<br />fp0pt04          FLOAT 0.040f<br />fp0pt1            FLOAT 0.10f<br />fp0pt2            FLOAT 0.20f<br />fpsmall          FLOAT 0.10f<br />fp0pt4            FLOAT 0.40f<br />fphalf             FLOAT 0.50f<br />fp1                 FLOAT 1.0f<br />fp1pt04 FLOAT 1.040f<br />fp1pt8 FLOAT 1.8f<br />fp2 FLOAT 2.0f<br />fp3 FLOAT 3.0f<br />fp4 FLOAT 4.0f<br />fp5 FLOAT 5.0f<br />fp10 FLOAT 10.0f<br />fp30 FLOAT 30.0f<br />fp45 FLOAT 45.0f<br />fpn10 REAL4 -10.0f<br />fp100 FLOAT 20.0f<br />fp255            FLOAT     255.0f<br />fp300 FLOAT 300.0f<br />                                   fp360 FLOAT 360.0f<br />                                   fp361 FLOAT 361.0f<br />fp400 FLOAT 400.0f<br />fp600 FLOAT 600.0f<br />fp800 FLOAT 800.0f<br />fp1000          FLOAT    1000.0f<br />fDisplayCamPitch FLOAT 0.0f<br />fDisplayCamYaw FLOAT 0.0f<br /><br />;#########################################################################<br /><br /><br />Ok, I'll post some more of it in a bit, in Zips as requested.<br />That gives you something to look at in the interim.<br /><br />Have a nice day :)</div>
    <div class="meta">Posted on 2003-10-19 23:26:37 by Homer</div>
   </div>
   <div class="post" id="post-121847">
    <div class="subject"><a href="#post-121847">D3D Animation Support Module</a></div>
    <div class="body">(hey - I think that might be the longest post I ever made here :tongue: )<br />I had something to say, but I forgot - too much beer makes Homer a dull Homer...</div>
    <div class="meta">Posted on 2003-10-20 12:27:39 by Homer</div>
   </div>
   <div class="post" id="post-121972">
    <div class="subject"><a href="#post-121972">D3D Animation Support Module</a></div>
    <div class="body">I just wanna make a note here for my own sanity's sake...<br />SkinMesh_Create is our entrypoint to the Frames parser.<br />The Frames parser in turn will call MeshNode_Create whose job is to load the Mesh and process any Materials/Textures in there.<br />Having done all that, we find ourselves back in SkinMesh_Create, where we have one last job to do - &quot;find the Bones of our MeshNode&quot;... <br /><br />SkinMesh_Create calls FrameNode_FindBones, passing it a handle to the Root Frame of our SkinMesh.<br />FrameNode_FindBones attempts to find any Frames which own a pMeshes field (no its not a pointer, my naming convention needs fixing since I changed the LinkedList codebase) and for any Frame that contains a pMeshes field, it calls MeshNode_FindBones.<br /><br />MeshNode_FindBones, having been handed a handle to a MeshNode, attempts to gain access to that meshnode's BoneNamesBuffer. Having done so, for every named Bone, it attempts to find the Frame of the same name, and then fetch a pointer to that frame's CombinedMatrix and copy it into an array of &quot;pointers to Matrices&quot; kept in the owner MeshNode under the handle pBoneMatrices.<br />What we are really doing is constructing in the MeshNode an array of matrixpointers, one per Bone.<br /><br />Anyone got a square to spare?<br /><br />This all seems a little e-tarded to me.<br />For starters, MeshNode is meant to be generic, how can it be if it supports an array of bonematrix pointers? It seems more logical to place this array in the owner SkinMesh, rather than in some far-flung meshnode of that SkinMesh, since the number of Bones won't be changing.<br />Furthermore, it seems crass to parse the BoneNamesBuffer of the MeshNode since we already HAVE the BoneNames in our Frames Hierarchy.<br />It occurs to me that this all could have been done DURING FRAMEPARSING ie when we find a Frame Transform Matrix we ideally should whack a pointer to it into our owner SKinMesh's BoneMatrix Pointers array, in the order of discovery during parsing. Of course, we are assuming that the Bone Names in the MeshNode's Bone Names Buffer are in the SAME ORDER OF APPEARANCE as the Frames of the same name. This seems to be the case.<br /><br />Your thoughts?</div>
    <div class="meta">Posted on 2003-10-21 09:25:37 by Homer</div>
   </div>
   <div class="post" id="post-122019">
    <div class="subject"><a href="#post-122019">D3D Animation Support Module</a></div>
    <div class="body">Hey Homer<br /><br />This is the way I'd look at it :-<br /><br />The skinmesh object encapsulates our model skin.<br />The model skin can be made up of 1 or more meshes.<br />Each mesh can be animated by 1 or more bones.<br /><br />It depends on what you want to do with the skin as to where you store the bone information.<br /><br />I want to be able to create models like lego, plug in an arm here, a leg there, a modular system.<br />- I want to chop off some dudes arm and beat him with it :grin:<br />- I want to blow off a leg and replace it with a bloody stump :eek:<br />- I want to drink a potion and have my arm change into a tenticle :rolleyes:<br /><br />This would require the mesh to store its bone and animation information, but I could be completely wrong.<br /><br />Maelstrom</div>
    <div class="meta">Posted on 2003-10-21 17:23:16 by Maelstrom</div>
   </div>
   <div class="post" id="post-122056">
    <div class="subject"><a href="#post-122056">D3D Animation Support Module</a></div>
    <div class="body">Please refer to my old Subdivided SkinMesh thread.<br /><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=8652&amp;highlight=subdivided+skinmesh">Here's a link to it</a> <br />Basically a SkinMesh cannot (should not) contain more than one Mesh.<br />Frames on the other hand are quite capable of this, in the context of a scene hierarchy - note that I have NEVER seen an xfile for a skinmesh model that contained more than one mesh, but I have placed multiple single-mesh models in a scene and saved the entire scene to an xfile, but our Parser isn't smart enough to handle that yet, and I don't intend to try loading scenefiles with the skinmesh loader, I'll use some of the code in there through a different entrypoint if I wish to implement a full blooded scene loader. It really makes little sense to put all your eggs in one basket anyway, far better to keep things modular, even as far as xfiles are concerned.<br />Meshes are capable of being designed with multiple Materials, but normally nobody bothers, they generally just use a single texture. The mechanism for multiple Materials allows us to rend a SkinMesh in SubSets. Should we take the time to create our models with multiple Materials, and use one Material per limb that we'd like to tear off, we can then flag our Render function to simply not draw some of the subsets, which would be an issue if we did not also create some hidden (occluded) surfaces - &quot;stump surfaces&quot;. Ok, so we can draw our dude with arms and legs and stuff missing, what about splitting them from his body?<br />Imagine we ripped off an arm, and want to draw it on the ground at the feet of the model. We simply create a second instance of the entire model (subsequent instances are cheap - it's just a reference) and flag all its limbs EXCEPT the arm to be skipped during Rending, and we attach this second instance of the model to its own Frame, so it can be transformed separately.<br />This way, we can still animate the arm all by itself if we like, and can cheaply do things like chop someone in half. <br /><br />In conclusion, this proposed system of Subdivided SkinMeshes supports stump texturing, allows for twitching, wriggling limbs on the ground, is cheap to implement, allows us to stick to highlevel render functions, and gives us a reason to implement proper Instancing of our loaded models which in turn leads to polymorphism (think about a crowd of people, all animated separately and textured separately, but all instances of a single loaded SkinMesh).</div>
    <div class="meta">Posted on 2003-10-22 01:13:17 by Homer</div>
   </div>
   <div class="post" id="post-122060">
    <div class="subject"><a href="#post-122060">D3D Animation Support Module</a></div>
    <div class="body">On a side note, I added a quicky codemodule called Debug (oddly enough) which consists of a couple of procs to create, write to and close a logfile, and a macro to drive calls to the write function.<br />About time I got my act together, really.<br />Spurious MessageBoxen being replaced judiciously with new Debug macro.<br />I was getting sick of commenting and uncommenting them all the time.<br />Also I'm considering altering the Linked Objects support code to use Heap objects instead of using GlobalAlloc, with a gut feeling that I can get rid of all the zillions of Lock and Unlock calls that have crept in since I last reworked it.<br />This may also grow into a Paged Object Manager, where object heaps are separate and are grown on demand by a MemoryManager class - your thoughts?</div>
    <div class="meta">Posted on 2003-10-22 01:29:30 by Homer</div>
   </div>
   <div class="post" id="post-122066">
    <div class="subject"><a href="#post-122066">D3D Animation Support Module</a></div>
    <div class="body">Hey Homer<br /><br />Ahh I forgot about that thread, now I remember where your going with the skinmesh.<br />Doing it that way would definitely be faster to render than dozens of smaller meshes.<br />The only drawback is that you can't change the mesh, replace an arm with a tenticle etc, but this isn't a major and could probably be worked around anyway.<br />I was also wondering about how a severed limb would react since it's part of the whole mesh but it should work ok.<br />Will be interesting to see in action.<br /><br />Am I correct in assuming the mesh vertices/faces/indices will be grouped by material?<br />What about bounding boxes, 1 per material group?<br />You could use the material to determine regional impact correct? find the impacted face and check its material = instant region?<br /><br />If your going to have a single mesh then I agree with your earlier thoughts about moving the bones information into the skinmesh structure.<br /><br />Moving to heap memory functions is a good idea, even MS suggests using them since the Global/Local functions are now obsolete.<br />A memory manager is always a good idea IMHO, allows you to easily track every byte of memory you use.<br /><br />Maelstrom</div>
    <div class="meta">Posted on 2003-10-22 02:27:05 by Maelstrom</div>
   </div>
   <div class="post" id="post-122076">
    <div class="subject"><a href="#post-122076">D3D Animation Support Module</a></div>
    <div class="body">My project is very broken again lol (implementing Heap based memory model)<br /><br />;October 22- Support Macros were added for creating, growing and destroying HEAPS.<br />;                 - SkinMesh Heap is being created and destroyed in Main procedure,<br />;                   created before the window is created, and destroyed when we return from the MessagePump loop.<br />;                 - We also create/destroy a heap for storing all Strings in Main procedure.<br />;                 - LinkedList functions &quot;SetName&quot;, &quot;KillName&quot; and &quot;SafeRelease_LL&quot; were modified for Heap memory<br /><br />When you call a DX mesh loading function, it always sorts the faces into per-Material collections,if that mesh contain multiple Materials. Handy, huh?<br />Well, m$ make little mention of this fact, and not many appreciate that you can do a bit more than just render texture groups with SubSet rendering functions.<br />I'm going to aim for a single-tex, single-material skinmesh first, then try for multi-tex (multi-Material) version, which is just a breath away from my notion of SubDivided SkinMesh.<br /><br />For the record, here are the new macros I'm using to implement Heaps and heap-based Objects...<br /><br />HeapObject MACRO hHeap, pReturn, objSize<br />mov pReturn,$invoke (HeapAlloc,hHeap,HEAP_NO_SERIALIZE or HEAP_ZERO_MEMORY or HEAP_GENERATE_EXCEPTIONS,objSize)<br />ENDM<br /><br />ResizeObject MACRO hHeap,pHeap, newSize<br />mov pHeap, $invoke (HeapReAlloc,hHeap, HEAP_NO_SERIALIZE or HEAP_ZERO_MEMORY or HEAP_GENERATE_EXCEPTIONS, pHeap, newSize)<br />ENDM<br /><br />FreeObject MACRO hHeap, pObject<br />invoke HeapFree,hHeap,HEAP_NO_SERIALIZE,pObject<br />ENDM<br /><br />CreateHeap MACRO hHeap, pHeap, initialSize<br />mov hHeap,$invoke (HeapCreate, HEAP_NO_SERIALIZE or HEAP_GENERATE_EXCEPTIONS,initialSize,0)<br />HeapObject hHeap, pHeap, initialSize<br />ENDM<br /><br />DestroyHeap MACRO hHeap, pHeap<br />FreeObject hHeap, pHeap<br />invoke HeapDestroy,hHeap<br />ENDM<br /><br />Damn, I hope this works out, lol.<br />I understand that internally, these functions rely on kernel-based CriticalSection functions, which has to be cheaper than Locking and Unlocking allocated memory.<br />Also I am led to believe there's a minor transitory bug in m$'s GlobalAlloc function where it sometimes fails to access the process heap. In English, that means that it wigs out when it feels like it, and without warning (possibly a timing glitch in the Kernel itself??) I'm told this method is more stable and easier to trace.<br /><br />As for Bounding geometry, I intend to firstly use a BoundingSphere around the entire model, and use BoundingBoxes around vertex groupings.<br />Of course, we nominally have to manually precalculate the latter by Locking the vertexbuffer.<br />This is made much easier if we have loaded the SkinMesh model already, since we can use the BoneCombination information to determine which vertices belong to (are influenced by) a given Bone. I expect MaxInfluences to be greater than one (Vertices affected by more than one Bone), which means it makes sense to transform the BoundingBoxes whenever we transform Bones, so we may as well have one BoundingBox per Bone, thus they will actually overlap.<br />Conclusion is that we should have one BoundingBox per Bone, and manipulate them at the same time, meaning BoundingBoxes are distorted during animation.<br />What good are they then, you might be wondering?<br />Well, if we wanted to know if a point was within a distorted box, we distort the point to suit the box. Same for a ray. Am I making sense or rambling here? lol</div>
    <div class="meta">Posted on 2003-10-22 04:43:14 by Homer</div>
   </div>
   <div class="post" id="post-122090">
    <div class="subject"><a href="#post-122090">D3D Animation Support Module</a></div>
    <div class="body">I really must stress the point that I don't intend to implement SubDiv until I have a basic animated model doing its thing on my screen.<br />Except fot the fact that I'm currently recoding LinkedObject support for the fourth time to support Heap mem, the battleplan is as follows:<br /><br />-Get SkinMesh Loader's FramesParser working (completed)<br />-Get SkinMesh Loader's MeshLoader working (completed)<br />-Get SkinMesh Loader's AnimationsParser working (95% complete)<br />-Implement static Rending of the SkinMesh (not even close)<br />-Implement Time-Based animation code (matrix applicator, haven't really started)<br />-Implement Time-Based animation code (animated Render, haven't really started)<br />-Implement multiple named AnimationSets in a single model's xfile (not attempted)<br />-Implement Hit-Detection (Model with Terrain, unimplemented)<br />-Implement Hit-Detection (Model with Ray, unimplemented)<br />-Implement Hit-Detection (Model with ParticleMesh, unimplemented)<br />-Implement Hit-Detection (Model with Model, unimplemented)<br /><br />It looks like I have a lot of work left, doesn't it?<br />In actuality I'm well over 60% towards completion :)</div>
    <div class="meta">Posted on 2003-10-22 05:56:34 by Homer</div>
   </div>
   <div class="post" id="post-122091">
    <div class="subject"><a href="#post-122091">D3D Animation Support Module</a></div>
    <div class="body">Hey, I'm going to have to start a separate thread to talk about related topics like my Organic Algorithm-based hierarchical vegetation !! (I got that idea from Vice City, the palmtrees sway in the wind, looks cool...)<br />I intend to populate the terrain with trees, shrubs and other plants which grow and die over Time, thus the landscape will constantly evolve.<br />I plan on using the structures and code developed for SkinMesh to achieve it, but animate them myself using a simple matrix hierarchy.<br />I'm considering applying the same logic to SkinMeshes themselves, altering the Scale over time so that the animated creatures grow too.</div>
    <div class="meta">Posted on 2003-10-22 06:05:31 by Homer</div>
   </div>
   <div class="post" id="post-122119">
    <div class="subject"><a href="#post-122119">D3D Animation Support Module</a></div>
    <div class="body">Did I mention that speed was like REALLY important to me?<br />I want a world that is complex and engaging !!</div>
    <div class="meta">Posted on 2003-10-22 09:11:44 by Homer</div>
   </div>
   <div class="post" id="post-122225">
    <div class="subject"><a href="#post-122225">D3D Animation Support Module</a></div>
    <div class="body">October 23-functions &quot;LinkedLists_Append&quot;, &quot;AppendSibling&quot;, &quot;FindEntryByName&quot; were modified for Heap memory,<br />also &quot;SafeRelease_PlayerObject&quot; , &quot;Object_LoadMeshFromXFile&quot; , &quot;SafeRelease_TexObject&quot; , &quot;SafeRelease_ObjectLL&quot; , &quot;AnimationNode_Load , _Destroy , _FindBone , _SetTime&quot; and lots more <br /><br />(I'm tired! Can you tell?)<br /><br /><br />What I've decided to do is implement several Heaps, not just one big whopping Heap. Later this will become the basis of a Paged memory manager, because each Heap will be comprised of N objects of a fixed size.<br />Therefore, the Manager Class functions are being altered to expect a Heap Handle and an Object Pointer.<br />We'll put all our chickens with our chickens, and our ducks with our ducks.<br />Birds of a Feather !!<br /><br />The Manager functions have been placed in a separate folder now, which tidies up the Include folder a heck of a lot.<br /><br />Give me another day, maybe two, and I'll be back where we were before, with a more robust and methodical Object Management Class of functions which supports polymorphism. Note that this OOP implementation is NOT following the standard, it's not REALLY a &quot;Class&quot; in the C sense, since my Objects do not contain virtual function pointers or anything sexy like that, they are just LinkedList-style objects and the set of Manager functions is external and global, but supports polymorphism through the use of a variable Heap handle.</div>
    <div class="meta">Posted on 2003-10-23 09:28:13 by Homer</div>
   </div>
   <div class="post" id="post-122427">
    <div class="subject"><a href="#post-122427">D3D Animation Support Module</a></div>
    <div class="body">Just for the sake of making a progress report (and keeping up my post ratio lol) here's the current state of my EntryPoint code block ...<br /><br /><br />.code<br />start:<br />      call TRandomInit <br />      invoke Debug_CreateLogFile, CTXT(&quot;DEBUG_LOG.TXT&quot;)      <br />      mov hInstance,         $invoke (GetModuleHandle,NULL)<br />      mov CommandLine, $invoke (GetCommandLine)      <br />      mov hIcon,                $invoke (LoadIcon,hInstance,500)    ; icon ID     <br />      mov hCursor,            $invoke (LoadCursor,NULL,IDC_ARROW)      <br />      mov sWid,                $invoke (GetSystemMetrics,SM_CXSCREEN)      <br />      mov sHgt,                 $invoke (GetSystemMetrics,SM_CYSCREEN)    <br />      call Main<br />      invoke Debug_CloseLogFile<br />      invoke ExitProcess,eax<br />      invoke InitCommonControls<br />      <br />; #########################################################################<br /><br />Main proc<br />    STRING MyClass,&quot;More_Ass_Than_Class&quot;<br />    SingleInstanceOnly addr MyClass<br />    invoke RegisterWinClass,ADDR WndProc,addr MyClass,<br />                       hIcon,hCursor,COLOR_BTNFACE+1<br />    CreateHeap hHeapOfPlayers, pPlayers, sizeof PlayerObject             ;Create Heap for Players (who knows...maybe MP)<br />    CreateHeap hSkinMeshHeap, pSkins, sizeof SkinMesh                     ;Create Heap for SkinMesh<br />    CreateHeap hHeapOfStrings, pStringsMemory, 0                               ;Create Heap for Strings<br />    CreateHeap hMeshNodeHeap, pMeshNodes,sizeof MeshNode        ;Create Heap for MeshNodes<br />    CreateHeap hFrameNodeHeap, pFrameNodes, sizeof FrameNode    ;Create Heap for FrameNodes<br />    CreateHeap hAnimNodeHeap, pAnimationNodes, sizeof AnimationNode ;  &quot;       &quot;       AnimationNodes<br />    CreateHeap hHeapOfObjects, pObjectNodes, sizeof Object              ;blah<br />    CreateHeap hHeapOfDisplayModes, pDisplayModesRoot, 0<br />    Debug CTXT(&quot;Heaps Created.&quot;,13,10)<br />    invoke CreateWindowEx,NULL,addr MyClass,ADDR szDisplayName,<br />                          WS_OVERLAPPED or WS_SYSMENU,<br />                          0,0,sWid,sHgt,<br />                          NULL,NULL,hInstance,NULL<br />    mov hWnd,eax<br />    DisplayWindow hWnd,SW_SHOWNORMAL<br />    call MsgLoop<br />    DestroyHeap hHeapOfDisplayModes, pDisplayModesRoot<br />    DestroyHeap hHeapOfObjects, pObjectNodes<br />    DestroyHeap hAnimNodeHeap, pAnimationNodes<br />    DestroyHeap hFrameNodeHeap, pFrameNodes<br />    DestroyHeap hMeshNodeHeap, pMeshNodes<br />    DestroyHeap hHeapOfStrings, pStringsMemory<br />    DestroyHeap hSkinMeshHeap,pSkins<br />    DestroyHeap hHeapOfPlayers, pPlayers<br />    ret<br />Main endp</div>
    <div class="meta">Posted on 2003-10-25 07:40:21 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=15287&amp;page=1" style="">&laquo;</a><a href="../?id=15287&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="15287" /><input type="number" name="page" min="1" max="6" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=15287&amp;page=4">&gt;</a><a href="../?id=15287&amp;page=6">&raquo;</a></form>  </div>
 </body>
</html>