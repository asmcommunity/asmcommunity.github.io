<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>D3D Animation Support Module - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=15287" />
  <link rel="prev" href="../?id=15287&amp;page=1" />  <link rel="next" href="../?id=15287&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=15287">D3D Animation Support Module</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=15287&amp;page=1" style="">&laquo;</a><a href="../?id=15287&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="15287" /><input type="number" name="page" min="1" max="6" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=15287&amp;page=3">&gt;</a><a href="../?id=15287&amp;page=6">&raquo;</a></form>   <div class="post" id="post-121005">
    <div class="subject"><a href="#post-121005">D3D Animation Support Module</a></div>
    <div class="body">Ok back again, still no luck :(<br /><br />The Parser correctly loads the skeleton for a while but theres still stack corruption occurring and I don't know where or why.<br />I've thought this through and theres another way I can tackle this problem.<br />I can try to build the hierarchy another way.<br />Instead of parsing it branch by branch, I can parse it level by level.<br />Let me elucidate: at the moment, our psuedocode looks similar to the following:<br /><br />-check for Frame object<br />-while Frame, <br />--Create ChildFrame and Link appropriately<br />--check for Data object<br />--if Data, call self on Data<br />--endif<br />--Get Next Object<br />-endw<br /><br /><br />What I'm considering doing is something like this:<br /><br />-check for Frame object<br />-while Frame,<br />--Create ChildFrame and Link<br />--shove pData into Frame so we can enumerate its children<br />--call Self<br />--Get Next Object<br />-endw<br /><br />What I'm driving at is that we can pass just ONE parm to the procedure being the handle of OUR current object, and it can act as a vessel for the procedure input params as well as being a container for the result.<br /><br />So if we (for example) find a frame with three children, we'd create three child frames, and shove the appropriate xof pointer in each one, and call self, passing only the child object handle.<br /><br />It's still nested and iterative but at least we can rest assured that the xofpointer is not being corrupted on the Stack, and we reduce the local stackframe size significantly. It's got to be a Good Thing, right?<br />The way I'll implement it is as follows:<br />The FramesLoader will use the pMeshes field of the FrameNode structure as a temporary holder for that frame's xof pointer.<br />When a Frame is completely parsed, the pMeshes will (again) be zeroed.<br />If a Frame is found to contain a Mesh, we'll shove the Mesh's xof pointer into an application global and pretend it didn't happen, until all the Frames are parsed, and deal with it then. We can do this because we know we have just one Mesh.</div>
    <div class="meta">Posted on 2003-10-10 11:53:11 by Homer</div>
   </div>
   <div class="post" id="post-121061">
    <div class="subject"><a href="#post-121061">D3D Animation Support Module</a></div>
    <div class="body">Ok screw that last post :mad: <br />I fired up ole faithful (OllyDebug) and got funky on this bug.<br />I tracked it down to my LinkedLists_AppendSiblings function, in the instance where it seeks the last sibling of a current node.<br />I added a new function (LinkedLists_FindLastSibling) which was effectively the SAME DAMN CODE, and replaced the offending code in AppendSiblings with a call to that instead.<br />I disabled all attempts to handle non Frame dataobjects.<br />I am now loading the Frames Hierarchy 100%.<br />SWEET !!<br /><br />Now I have to archive the current source and then try to get it to recognize the other Object types again (frame matrices, mesh, anime, etc)<br /><br />I feel better than James Brown :alright:</div>
    <div class="meta">Posted on 2003-10-11 05:03:49 by Homer</div>
   </div>
   <div class="post" id="post-121261">
    <div class="subject"><a href="#post-121261">D3D Animation Support Module</a></div>
    <div class="body">Huh? this is weird...<br /><br />I'm loading the Frames hierarchy all right .. but when I enabled handlers for the other x-entities like Mesh and FrameTransformMatrix, I am no longer detecting them during parsing AT ALL - and I was before, with the same code !!?!<br />If I don't get anywhere in the next few hours, I'll post the entire current SkinMesh Support source with the hope that YOU can help me get the darned parser working correctly ...</div>
    <div class="meta">Posted on 2003-10-13 17:26:46 by Homer</div>
   </div>
   <div class="post" id="post-121267">
    <div class="subject"><a href="#post-121267">D3D Animation Support Module</a></div>
    <div class="body">I rewrote the parser based on yet another cpp example, and it still parses frames ok, but it's still not detecting ANYTHING else...<br /><br />So here is my version, and below it is the cpp original, for the FrameParser function... note that I'm not handling anything except Frames in my version, but I AM trying to detect them...and not doing so :(<br /><br />If you can see any critical differences in the code, please let me know.<br />Also, I am happy to provide source for anything not provided here, if anyone is willing to take a look into this issue with me, just let me know what you want to see and I'll post the current source in this thread.<br /><br /><br /><br />FrameNode_Load PROC pData:DWORD, ParentFrame:DWORD, pSkinMeshOwner:DWORD<br />local  pSubObj:DWORD<br />local  pSubData:DWORD <br />local  pDataRef:DWORD <br />local pType:LPGUID<br />local NameBuf[256]:BYTE<br />local ErrBuf[256]:BYTE<br />local pmeshnode:LPMESHNODE<br />local panimationset:LPANIMATIONNODE<br />local dwSize:DWORD<br />local hFrame:LPFRAMENODE<br />local pmat:LPD3DXMATRIX<br />local dwsize:DWORD<br />local hname:DWORD<br />;===============================================================================<br />;Initialize locals (DX can be finicky - some output args can also be input args !!)<br />;===============================================================================<br />xor eax,eax<br />mov pSubObj,eax<br />mov pSubData,eax<br />mov pDataRef,eax<br />mov pType,eax<br />mov NameBuf[0],al<br />mov dwSize,eax<br />mov hFrame,eax<br />mov pmeshnode,eax<br />mov panimationset,eax<br />;=======================================================================================<br />;Create a new Frame,fetch Name of XFile DataObject, set FrameName to same, and attach Frame to &quot;Parent&quot;<br />;=======================================================================================<br />  mov hFrame,    $invoke (LinkedLists_AppendSibling,ParentFrame,NULL, sizeof FrameNode)<br />  .if hFrame==NULL<br />     Errr CTXT(&quot;Error - Failed to create FrameNode&quot;)<br />  .endif<br />  .if $mcall (pData,IDirectXFileData_GetName, NULL, addr dwSize)!=D3D_OK<br />    Errr CTXT(&quot;Failed to get Template Name Length&quot;)<br />  .elseif dwSize!=0<br />        mcall ,IDirectXFileData_GetName, addr NameBuf, addr dwSize<br />  .endif<br />  .if NameBuf[0]== NULL                                                                     ;  // Give a default name if none found<br />    invoke lstrcpy,addr NameBuf, CTXT(&quot;$NamelessTemplate$&quot;)<br />  .endif    <br />   invoke LinkedObjects_SetName, hFrame, addr NameBuf<br />;===============================================================================<br />;                                        Scan XFile DataObject for embedded objects<br />;===============================================================================<br />    mcall ,IDirectXFileData_GetNextObject, ADDR pSubObj     <br />    .while eax!=DXFILEERR_NOMOREOBJECTS<br />        .if  eax==DXFILEERR_BADVALUE<br />            Errr CTXT(&quot;Parser Error - DXFILEERR_BADVALUE - in Frames Parser&quot;)<br />        .endif<br />        .if ($mcall (pSubObj, IDirectXFileObject_QueryInterface,addr IID_IDirectXFileData, addr pSubData)) == S_OK<br />            invoke IdentifyTemplate,pSubData<br />            .if eax==Frame<br />                invoke FrameNode_Load,pSubData, hFrame,pSkinMeshOwner<br />            .elseif eax!=Unknown<br />              invoke MessageBox,0,CTXT(&quot;NONFRAME IDENTIFIED&quot;),CTXT(&quot;YAYYYYYY&quot;),MB_OK<br />            .endif<br />            _saferelease pSubData<br />        .endif    <br />        .if ($mcall(pSubObj,IDirectXFileObject_QueryInterface, ADDR IID_IDirectXFileDataReference, ADDR pDataRef)) == S_OK<br />          .if ($mcall(pDataRef,IDirectXFileDataReference_Resolve,addr pSubData))==DXFILE_OK<br />            invoke MessageBox,0,CTXT(&quot;REFOBJECT IDENTIFIED&quot;),CTXT(&quot;YAYYYYYY&quot;),MB_OK<br />             invoke FrameNode_Load,pSubData, hFrame,pSkinMeshOwner<br />             _saferelease pSubData <br />          .endif<br />          _saferelease pDataRef<br />        .endif<br />        _saferelease pSubObj<br />        mcall ,IDirectXFileData_GetNextObject, ADDR pSubObj     <br />    .endw<br />ret<br />FrameNode_Load ENDP<br /><br /><br /><br /><br /><br />00643 HRESULT ParseFrame( LPDIRECTXFILEDATA pFileData, CD3DFileObject* pParentFrame )<br />00644 {<br />00645     DWORD dwNameLen=80;<br />00646     TCHAR strName[80];<br />00647     if( FAILED( pFileData-&gt;GetName( strName, &amp;dwNameLen ) ) )<br />00648         return E_FAIL;<br />00649 <br />00650     CD3DFileObject* pFrame = new CD3DFileObject( strName );<br />00651 <br />00652     // Enumerate child objects.<br />00653     LPDIRECTXFILEOBJECT pChildObj;<br />00654     while( SUCCEEDED( pFileData-&gt;GetNextObject( &amp;pChildObj ) ) )<br />00655     {<br />00656         LPDIRECTXFILEDATA pChildData;<br />00657         if( SUCCEEDED( pChildObj-&gt;QueryInterface( IID_IDirectXFileData,<br />00658                             (VOID**)&amp;pChildData ) ) )<br />00659         {<br />00660             const GUID* pGUID;<br />00661             pChildData-&gt;GetType( &amp;pGUID );<br />00662 <br />00663             if( TID_D3DRMFrame == *pGUID )<br />00664                 ParseFrame( pChildData, pFrame );<br />00665 <br />00666             if( TID_D3DRMMesh == *pGUID )<br />00667                 ParseMesh( pChildData, pFrame );<br />00668 <br />00669             if( TID_D3DRMFrameTransformMatrix == *pGUID )<br />00670             {<br />00671                 DWORD dwSize;<br />00672                 VOID* pData;<br />00673                 if( FAILED( pChildData-&gt;GetData( NULL, &amp;dwSize, &amp;pData ) ) )<br />00674                 {<br />00675                     delete pFrame;<br />00676                     return NULL;<br />00677                 }<br />00678 <br />00679                 if( dwSize == sizeof(D3DMATRIX) )<br />00680                 {<br />00681                     // Convert from a left- to a right-handed cordinate system<br />00682                     D3DMATRIX* pmatFrame = (D3DMATRIX*)pData;<br />00683                     pmatFrame-&gt;_13 *= -1.0f;<br />00684                     pmatFrame-&gt;_31 *= -1.0f;<br />00685                     pmatFrame-&gt;_23 *= -1.0f;<br />00686                     pmatFrame-&gt;_32 *= -1.0f;<br />00687                     pmatFrame-&gt;_43 *= -1.0f;<br />00688                     pFrame-&gt;SetMatrix( pmatFrame );<br />00689                 }<br />00690             }<br />00691 <br />00692             pChildData-&gt;Release();<br />00693         }<br />00694 <br />00695         pChildObj-&gt;Release();<br />00696     }<br />00697 <br />00698     pParentFrame-&gt;AddChild( pFrame );<br />00699     return S_OK;<br />00700 }</div>
    <div class="meta">Posted on 2003-10-13 19:41:15 by Homer</div>
   </div>
   <div class="post" id="post-121272">
    <div class="subject"><a href="#post-121272">D3D Animation Support Module</a></div>
    <div class="body"><div class="quote"><br />I can partially understand the lack of interest if placed in the context of dx9 once more containing Frames support, however the dx9 includes I have seen for masm are far from complete, and the majority of the goodies in dx9 are not within reach of the average graphic card... <br /><br />HOWEVER<br /><br />The whole point of coding in asm (for me) is the speed and size benefits achieved in comparison to something more loathsome.<br />Maybe I am going to sound a little jaded (and even just plain old) by stating the obvious, that almost all commercial games were once hand-optimized for speed.<br />Even the average village idiot would agree that by optimizing the most-often called code we get to shave enough cpu cycles to put into other things like special effects.<br /><br />I have stated in the past that I am willing to go it alone if I am forced to, because all the best game houses were formed by talented amateurs like myself, but I am just a little ismuth in the middle of an ocean of high level coders who can implement standard code in a fraction of the time that I can in asm.<br />I would sorely like to take them to task, and have spent some time developing a set of helper api and macros to this end, based on the examples set forth by some of our regs on this board, including Caleb and Scronty.<br /><br />What's the problem? Do we need a &quot;Thomas&quot; around here to write tutorials aimed squarely at asmcoders?<br />The gear I base my work on is all cpp sourcecode.<br />I simply translate it directly and then look for optimisations.<br />That's one step up from one Scronty does (he has simply translated existing examples directly, without any further effort).<br />I don't expect to be congratulated for my work, but I kind of expected some show of interest in my optimisations because I know damn well that a lot of cpp coders waltz through here looking for a handout - and that's exactly what I have offered.<br />Furthermore, I don't like the masm object support code I have seen because it appears not to support dynamic arrays etc. So I coded an entire library of linked list support code because I wanted it and it wasn't available.<br />If you want something done (right or wrong, just at all), you have to do it yourself. I truly expected this thread to generate more interest in this forum, and I'm rather disappointed to see that most of us are still thinking in 2D terms ... </div><br /><br />How slow are DX Math helpers, can u give us some rough numbers, I'm preparing myself for a good laugh =P <br /><br />nah I wrote some 3D Matrix/vector manipulation code using the plain FPU as well, I feel there are quite slow but I would like to see how they compare to MS's code.</div>
    <div class="meta">Posted on 2003-10-13 20:57:46 by x86asm</div>
   </div>
   <div class="post" id="post-121320">
    <div class="subject"><a href="#post-121320">D3D Animation Support Module</a></div>
    <div class="body">I can't supply benchmark figures, the benchmark tests I devised were more &quot;feelgood&quot; tests which gave us an idea of how the functions compared over time under actual load.<br />What I can say is that close up, the differences are not acute, rather like comparing say matrix rotation math to triple plane trigonometry rotation math - the difference becomes pronounced when the number of elements being processed is reasonable - let alone high.<br /><br />I could quote a few relative examples, but I think you already agree without looking closer - and ultimately, why would I bother, if their code was fast enough?<br /><br />Only a hardware layer coder can appreciate hand optimized binary code, but anyone can appreciate the result.<br /><br />Right now though, I'm wondering if anyone is looking at the code I posted up there..</div>
    <div class="meta">Posted on 2003-10-14 08:40:25 by Homer</div>
   </div>
   <div class="post" id="post-121345">
    <div class="subject"><a href="#post-121345">D3D Animation Support Module</a></div>
    <div class="body">Hey EvilH<br /><br />Could you post the IdentifyTemplate code.<br /><br /><strong>Edit</strong><br /><br />The only differences I see off hand :-<br /><br />The C code initializes the <strong>dwNameLen</strong> variable to the size of the buffer. Should allow you to drop the second call to GetName in the elseif block and guarantees that the object name never exceeds the buffer size. Now it's not likely to be longer than 256 bytes but better safe than hairless.<br /><br />The DX9 docs I have say the success return value is DXFILE_OK, probably the same as D3D_OK, but again better to be safe.<br /><br />Maelstrom</div>
    <div class="meta">Posted on 2003-10-14 16:31:24 by Maelstrom</div>
   </div>
   <div class="post" id="post-121386">
    <div class="subject"><a href="#post-121386">D3D Animation Support Module</a></div>
    <div class="body">My IdentifyTemplate procedure is just a wrapper to my IdentifyGUID procedure..<br /><br />IdentifyTemplate PROC pxobj:DWORD<br />local pType:DWORD<br />.if ($mcall (pxobj,IDirectXFileData_GetType,addr pType))== D3D_OK<br />      return ($invoke (IdentifyGUID, pType))<br />.endif<br />return Unknown<br />IdentifyTemplate ENDP<br /><br />My IdentifyGUID procedure is just a wrapper to Scronty's CmpGUID procedure..<br /><br />;This procedure attempts to identify a template by its guid...<br />;Thanks Be to Scronty for the DXGUID include ;)<br />;(damn hope m$ havent updated... ah well :p)<br />.data?<br />szOut db 256 dup (?)<br />szJoin db 256 dup(?)<br />Unknown equ 0<br />Frame equ 1<br />Mesh equ 2<br />Material equ 3<br />Normals equ 4<br />TextureCoords equ 5<br />FrameXFormMatrix equ 6<br />RMInfo equ 7<br />RMVector equ 8<br />MeshFace equ 9<br />MaterialArray equ 10<br />MeshMaterialList equ 11<br />RMCoords2d equ 12<br />Matrix44 equ 13<br />Animation equ 14<br />AnimationSet equ 15<br />AnimationKey equ 16<br />FloatKeys equ 17<br />AmbientColor equ 18<br />DiffuseColor equ 19<br />SpecularColor equ 20<br />EmissiveColor equ 21<br />RMMaterialPower equ 22<br />ColorRGBA equ 23<br />ColorRGB equ 24<br />RMGuid equ 25<br />RMTextureFilename equ 26<br />RMTextureReference equ 27<br />RMIndexedColor equ 28<br />MeshVertexColors equ 29<br />RMMaterialWrap equ 30<br />RMBoolean equ 31<br />MeshFaceWraps equ 32<br />RMBoolean2d equ 33<br />RMTimedFloatKeys equ 34<br />AnimationOptions equ 35<br />RMFramePosition equ 36<br />RMFrameVelocity equ 37<br />RMFrameRotation equ 38<br />RMLight equ 39<br />RMCamera equ 40<br />RMAppData equ 41<br />RMLightUmbra equ 42<br />RMLightRange equ 43<br />RMLightPenumbra equ 44<br />RMLightAttenuation equ 45<br />RMInlineData equ 46<br />RMUrl equ 47<br />RMProgressiveMesh equ 48<br />RMExternalVisual equ 49<br />RMStringProperty equ 50<br />RMPropertyBag equ 51<br />RMRightHanded equ 52<br />DXFileHeader equ 53<br />.code<br /><br />IdentifyGUID PROC pType:DWORD<br />   <br />    .if $invoke (CmpGUID, pType, ADDR TID_D3DRMFrame, 16) == 1<br />           return Frame<br />    .elseif  $invoke (CmpGUID, pType, ADDR TID_D3DRMMesh, 16) ==1<br />         invoke MessageBox,0,CTXT(&quot;MESH IDENTIFIED&quot;),CTXT(&quot;YAYYYYYY&quot;),MB_OK<br />         return Mesh    <br />    .elseif $invoke (CmpGUID, pType, ADDR TID_D3DRMMaterial, 16 )==1<br />         return Material<br />    .elseif $invoke (CmpGUID, pType, ADDR TID_D3DRMMeshNormals, 16)==1<br />         return Normals   <br />    .elseif $invoke (CmpGUID, pType, ADDR TID_D3DRMMeshTextureCoords, 16)==1<br />         return TextureCoords<br />    .elseif $invoke (CmpGUID, pType, ADDR TID_D3DRMFrameTransformMatrix, 16)==1<br />         invoke MessageBox,0,CTXT(&quot;FrameXform&quot;),CTXT(&quot;YAYYYYYYY&quot;),MB_OK<br />         return FrameXFormMatrix<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMInfo, 16)==1<br />         return RMInfo<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMVector, 16)==1<br />         return RMVector<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMMeshFace, 16)==1<br />         return MeshFace<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMMaterialArray, 16)==1<br />         return MaterialArray<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMMeshMaterialList, 16)==1<br />         return MeshMaterialList<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMCoords2d, 16)==1<br />         return RMCoords2d<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMMatrix44, 16)==1<br />         return Matrix44<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMAnimation, 16)==1<br />          invoke MessageBox,NULL, CTXT(&quot;ANIMATION was discovered&quot;,13,10,&quot;SOMETHING WRONG?&quot;), CTXT(&quot;WEIRD&quot;), MB_OK<br />         return Animation<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMAnimationSet, 16)==1<br />          invoke MessageBox,NULL, CTXT(&quot;ANIMATIONSET was discovered&quot;,13,10,&quot;SOMETHING WRONG?&quot;), CTXT(&quot;WEIRD&quot;), MB_OK<br />         return AnimationSet<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMAnimationKey, 16)==1<br />         return AnimationKey<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMFloatKeys, 16)==1<br />         return FloatKeys<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMMaterialAmbientColor, 16)==1<br />         return AmbientColor<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMMaterialDiffuseColor, 16)==1<br />         return DiffuseColor<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMMaterialSpecularColor, 16)==1<br />         return SpecularColor<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMMaterialEmissiveColor, 16)==1<br />         return EmissiveColor<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMMaterialPower, 16)==1<br />         return RMMaterialPower<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMColorRGBA, 16)==1<br />         return ColorRGBA<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMColorRGB, 16)==1<br />         return ColorRGB<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMGuid, 16)==1<br />         return RMGuid<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMTextureFilename, 16)==1<br />         return RMTextureFilename<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMTextureReference, 16)==1<br />         return RMTextureReference<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMIndexedColor, 16)==1<br />         return RMIndexedColor<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMMeshVertexColors, 16)==1<br />         return MeshVertexColors<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMMaterialWrap, 16)==1<br />         return RMMaterialWrap<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMBoolean, 16)==1<br />         return RMBoolean<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMMeshFaceWraps, 16)==1<br />         return MeshFaceWraps<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMBoolean2d, 16)==1<br />         return RMBoolean2d<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMTimedFloatKeys, 16)==1<br />         return RMTimedFloatKeys<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMAnimationOptions, 16)==1<br />         return AnimationOptions<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMFramePosition, 16)==1<br />         return RMFramePosition<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMFrameVelocity, 16)==1<br />         return RMFrameVelocity<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMFrameRotation, 16)==1<br />         return RMFrameRotation<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMLight, 16)==1<br />         return RMLight<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMCamera, 16)==1<br />         return RMCamera<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMAppData ,16)==1<br />         return RMAppData<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMLightUmbra, 16)==1<br />         return RMLightUmbra<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMLightRange, 16)==1<br />         return RMLightRange<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMLightPenumbra, 16)==1<br />         return RMLightPenumbra<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMLightAttenuation, 16)==1<br />         return RMLightAttenuation<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMInlineData, 16)==1<br />         return RMInlineData<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMUrl, 16)==1<br />         return RMUrl<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMProgressiveMesh, 16)==1<br />         return RMProgressiveMesh<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMExternalVisual, 16)==1<br />         return RMExternalVisual<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMStringProperty, 16)==1<br />         return RMStringProperty<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMPropertyBag, 16)==1<br />         return RMPropertyBag<br />    .elseif $invoke (CmpGUID, pType,ADDR TID_D3DRMRightHanded, 16)==1<br />         return RMRightHanded<br />    .elseif $invoke (CmpGUID,pType,ADDR TID_DXFILEHeader,16)==1<br />        return DXFileHeader<br />    .else<br />        xor ecx,ecx<br />        .while ecx&lt;16<br />            push ecx<br />            xor eax,eax<br />            mov al,byte ptr pType<br />            invoke wsprintf,addr szJoin,CTXT(&quot;%lX&quot;),eax<br />            invoke lstrcat,addr szOut, addr szJoin<br />            pop ecx<br />            inc ecx<br />        .endw<br />        invoke MessageBox,0,addr szOut,CTXT(&quot;UNKNOWN GUID&quot;),MB_OK<br />        return Unknown<br />    .endif<br />IdentifyGUID ENDP<br /><br /><br />And finally, Scronty's CmpGUID procedure is as follows:<br /><br /><br />;-----------------------------------------------------------------------------<br />; Name: CmpGUID<br />; Desc: Compares two GUIDs and returns TRUE or FALSE.<br />;-----------------------------------------------------------------------------<br />CmpGUID proc lpfirstGUID:DWORD, lpsecondGUID:DWORD, bytestocompare:DWORD<br /><br />    push esi<br />    push edi<br />    push ebx<br /><br />    mov esi, lpfirstGUID        ; first GUID address<br />    mov edi, lpsecondGUID       ; second GUID address<br />    mov ecx, bytestocompare     ; number of bytes to compare<br /><br />    @@:<br />        push ecx<br />        mov al, BYTE PTR <br />        mov bl, BYTE PTR <br />        inc esi<br />        inc edi<br />        .if al!=bl<br />            jmp @F<br />        .endif<br />       cmp esi, ecx<br />        pop ecx<br />        dec ecx<br />    jnz @B<br /><br />;exit true<br />    pop ebx<br />    pop edi<br />    pop esi<br />    return 1<br /><br />;exit false<br />@@:<br />    pop ebx<br />    pop edi<br />    pop esi<br />    return 0<br /><br />CmpGUID endp<br /><br /><br />There's nothing magical or mystical about this code.<br />I define my returnvalues as equates, and call Scronty's Cmp procedure with a pair of pType (actually a pointer to a GUID).<br />If I can't find a matching GUID to the one we seek, I return 0=Unknown<br />In the version I have posted above, I also generate as a text string the hex value of the unidentified GUID and messagebox it.</div>
    <div class="meta">Posted on 2003-10-15 02:28:31 by Homer</div>
   </div>
   <div class="post" id="post-121522">
    <div class="subject"><a href="#post-121522">D3D Animation Support Module</a></div>
    <div class="body">Did anyone spot anything wrong in there?<br />Help!!!</div>
    <div class="meta">Posted on 2003-10-17 02:00:58 by Homer</div>
   </div>
   <div class="post" id="post-121589">
    <div class="subject"><a href="#post-121589">D3D Animation Support Module</a></div>
    <div class="body">Hey EvilH<br /><br />I can't see any obvious mistakes but I haven't used C for years so it's possible I'm overlooking something :(<br /><br />Correct me if I'm wrong but isn't the C code comparing the GUID pointers? Have you tried doing it this way?<br /><br />Maelstrom</div>
    <div class="meta">Posted on 2003-10-17 17:25:36 by Maelstrom</div>
   </div>
   <div class="post" id="post-121618">
    <div class="subject"><a href="#post-121618">D3D Animation Support Module</a></div>
    <div class="body">It appears to be comparing LPGUIDs yes I agree.<br />I have been using Scronty's CmpGUID because I assumed that he knew something which I did not - he's much better with cpp than I am.<br />I figured that if Scronty was comparing the data behind the pointers deliberately, there must be a good reason - like cpp performing that step internally maybe?<br />I don't know !! What  I can say is that it works.<br />If I was to try an experiment comparing two LPGUIDS instead of two GUIDS by pointer, how would I go about acquiring the (dx internal) GUID pointer for comparison purposes to the LPGUID I am handed ? Bear in mind that at the moment, I am performing comparisons with guids that WE define as data strings. Therefore we know the address of OUR copy of a guid, but obviously, that pointer will never match an internal lpguid !!<br />As a side note, I am considering splitting my IdentifyGUID function into a range of functions dedicated to identifying a particular template, for example, we might decide to call IsTemplateMesh and IsTemplateFrame etc even though I feel the current solution (catch-all) to be preferable when we keep the most common templates at the top of the procedure and early-out on them.<br />Quite some time back, when I was having more success than I am now in the parsing department, my code consisted of a series of CmpGuid calls - JUST LIKE I have in the IdentifyGuid function.</div>
    <div class="meta">Posted on 2003-10-18 00:05:30 by Homer</div>
   </div>
   <div class="post" id="post-121648">
    <div class="subject"><a href="#post-121648">D3D Animation Support Module</a></div>
    <div class="body">Hey EvilH<br /><br />I threw a little test proggy together.<br /><br /><pre><code><br />include adl.inc<br /><br />includelib f&#58;\sdk\dx9\lib\dxguid.lib<br /><br />extern TID_D3DRMFrame&#58;byte<br />extern TID_D3DRMMesh&#58;byte<br /><br />_CODE segment<br /><br />	_start&#58;<br />	<br />	lea eax, TID_D3DRMFrame<br />	lea ebx, TID_D3DRMMesh<br />	<br />	invoke ExitProcess, 0 <br /><br />_CODE ends<br /><br />	end _start<br /></code></pre><br /><br />The pointers in EAX and EBX point to the following arrays of bytes.<br />The numbers match but we still need to do a byte compare since these end up in our EXE, but at least we don't need to define them ourselves.<br />No luck getting the internal GUIDs which I assume are inside the DLL, probably linked the DXGUID lib.<br /><br /><pre><code><br />EAX &#58; 46 AB 82 3D - DA 62 - CF 11 - AB 39 00 20 AF 71 E4 33<br />EBX &#58; 44 AB 82 3D - DA 62 - CF 11 - AB 39 00 20 AF 71 E4 33<br /><br />; the following GUIDs are taken from RMXFGUID.H<br /><br />DEFINE_GUID&#40;TID_D3DRMFrame, 0x3d82ab46, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33&#41;;<br />DEFINE_GUID&#40;TID_D3DRMMesh, 0x3d82ab44, 0x62da, 0x11cf, 0xab, 0x39, 0x0, 0x20, 0xaf, 0x71, 0xe4, 0x33&#41;;<br /></code></pre><br /><br /><em>As a side note, I am considering splitting my IdentifyGUID function into a range of functions dedicated to identifying a particular template, for example, we might decide to call IsTemplateMesh and IsTemplateFrame etc even though I feel the current solution (catch-all) to be preferable when we keep the most common templates at the top of the procedure and early-out on them.</em><br /><br />I think a catch-all proc would be better but I'd probably use a LUT instead of hard coding the comparisons. I'd also integrate Scronty's CmdGUID function to elimate the call overhead since it's not likely to be called by anyone else.<br /><br />Maelstrom</div>
    <div class="meta">Posted on 2003-10-18 09:53:41 by Maelstrom</div>
   </div>
   <div class="post" id="post-121651">
    <div class="subject"><a href="#post-121651">D3D Animation Support Module</a></div>
    <div class="body">I tend to agree in general.<br />My GUIDS are defined in rmxfguid.inc, which is really rmxfguid.h<br />My include still has m$'s name on the header - so if it's good enough for them to define guids this way, I figured it would be good enough for me. Considering a guid is meant to be absolutely unique, the values should be static for these common templates, and it shouldn't matter, but if they are defined in an external lib (which I'm sure they are), then why did m$ ever release this .h file which defines them?<br /><br />I won't post the file here in case someone doesn't agree with their EULA :tongue: <br />but it contains a crapload of statements like this:<br /><br />TID_D3DRMMesh	GUID	{03d82ab44h, 062dah, 011cfh,&lt;0abh, 039h, 00h, 020h, 0afh, 071h, 0e4h, 033h&gt;}<br /><br />By the way I prefer Homer to EvilH - I'm not really bad, I'm just drawn that way..<br /><br />I failed to see how a LookupTable would be any faster for comparisons of 16 bytes, but I can see merit in performing four dword compares since the Length is a given - however I left Scronty's code alone since it's useful as a generic binary compare function, I figured I WOULD use it in other places than the xfile parser..</div>
    <div class="meta">Posted on 2003-10-18 10:39:17 by Homer</div>
   </div>
   <div class="post" id="post-121664">
    <div class="subject"><a href="#post-121664">D3D Animation Support Module</a></div>
    <div class="body">I've integrated IdentifyTemplate and IdentifyGUID, and I've altered Scronty's CmpGUID to perform four DWORD compares (we now assume GUID length to be 16 bytes)<br />So IdentifyTemplate no longer exists.<br /><br />I'm happy to post this revised source, but theres little point, since it behaves exactly as its predecessor :(</div>
    <div class="meta">Posted on 2003-10-18 12:59:13 by Homer</div>
   </div>
   <div class="post" id="post-121669">
    <div class="subject"><a href="#post-121669">D3D Animation Support Module</a></div>
    <div class="body">Hi, EvilHomer2k. Your project is very interesting, and I'm sorry so few people here find it interesting. But I think one should have 3 qualities, to be 100% interested in it: 1) to be fluent in asm; 2) to be good in asm-oop &amp; C++, as well as interest in 3D games' programming ; 3) to know higher maths and 3D algorithms. Also, one needs DX9, which can be a problem to some people. <br />1) fluency in asm - see how many people on this board are really active (less than 100)<br />2) oop &amp; C++ . All of the active people here know C++, but I doubt all of them use OOP. <br />3) higher maths, 3D algos &amp; games - hmm. I don't know much about this problem, I myself am first semester at uni, currently studying matrices. I think soon I'll try 3D coding myself. But I have always dreamt of making a nice 3D game or app. <br />4) To compete the other game creators, one needs not only coding skills, but also a good texture+models artist. Also, the latest videocards &amp; best cpus (I assume). <br />in the end, there are only a few people to get your attention :( <br /><br />To most people all of this is too much effort, and I personally am scared of seeing a product of mine ending like some of the games I've seen - with no customers. <br />I, in fact, do not know much about the world's gaming industry, but for now this is my point of view. I have a product, that doesn't have customers only because there are 2 or 3 better products in the world, no matter how much they cost. <br /> I'd appreciate any critics :) . <br />Btw, my PC crashes a lot when I install DX8. (that's a reason for having labelled a CD with DX8, that I have, &quot;in case of emergency&quot;) . I'm afraid I won't be able to install DX9. <br /><br /><br />Anyway, you have my full support for your project :alright: <br />I have a lot of experience in audio and 2D animation, maybe I can help sometimes ;)</div>
    <div class="meta">Posted on 2003-10-18 13:43:43 by Ultrano</div>
   </div>
   <div class="post" id="post-121711">
    <div class="subject"><a href="#post-121711">D3D Animation Support Module</a></div>
    <div class="body">Hey Homer,<br /><br />The LUT I was referring to was to replace the .if comparisons.<br /><br /><pre><code><br />m_guidLut label dword<br />  dd offset TID_D3DRMFrame, Frame<br />  dd offset TID_D3DRMMesh, Mesh<br />  ...<br />  dd 0<br /><br /><br />IdentifyGUID PROC pType&#58;DWORD<br /><br />  lea esi, m_guidLut<br /><br />  _top&#58;<br /><br />  cmp dword ptr &#91;esi&#93;, 0<br />  je _exit<br /><br />  invoke CmpGUID, pType, &#91;esi&#93;, 16<br />  test eax, eax<br />  jnz _match<br /><br />  add esi, 8<br />  jmp _top<br /><br />  _match&#58;<br /><br />  mov eax, &#91;esi+4&#93;<br />  ret<br /><br />  _exit&#58;<br /><br />  xor eax, eax<br />  ret<br /><br />IdentifyGUID ENDP<br /></code></pre><br /><br />Or something like that, it probably won't be any faster but it should be smaller.<br /><br />Also, why doesn't Scronty's CmpGUID function use a rep cmpsd loop? Wouldn't that be faster? Or is that what you've done now?<br /><br />Maelstrom</div>
    <div class="meta">Posted on 2003-10-18 19:32:13 by Maelstrom</div>
   </div>
   <div class="post" id="post-121712">
    <div class="subject"><a href="#post-121712">D3D Animation Support Module</a></div>
    <div class="body">I guess like me, when coding for the masses, Scronty tends to write his code in a way which is most easily understood by the reader - I'm sure his personal code is much more optimized, as mine is.<br /><br />;-----------------------------------------------------------------------------<br />; Name: CmpGUID<br />; Desc: Compares two GUIDs and returns TRUE or FALSE.<br />; Original code by Scronty<br />; Rudely optimized by Evil Homer without so much as asking<br />;-----------------------------------------------------------------------------<br />CmpGUID proc lpfirstGUID:DWORD, lpsecondGUID:DWORD<br /><br />    push esi<br />    push edi<br />    mov esi, lpfirstGUID        ; first GUID address<br />    mov edi, lpsecondGUID       ; second GUID address<br />    mov ecx, 4<br />    repe cmpsd<br />    jnz @F<br />    pop edi     ;exit true<br />    pop esi<br />    return 1<br /><br />@@:<br />    pop edi     ;exit false<br />    pop esi<br />    return 0<br /><br />CmpGUID endp</div>
    <div class="meta">Posted on 2003-10-18 19:52:56 by Homer</div>
   </div>
   <div class="post" id="post-121714">
    <div class="subject"><a href="#post-121714">D3D Animation Support Module</a></div>
    <div class="body">Here is the revised edition of IdentifyGUID...<br /><br />;This procedure attempts to identify a template by its guid...<br />;Thanks Be to Scronty for the DXGUID include ;)<br />;Thanks Be to Maelstrom for his comments concerning the codebase<br />;(damn hope m$ havent updated... ah well :p)<br /><br />Unknown equ 0<br />Frame equ 1<br />Mesh equ 2<br />Material equ 3<br />Normals equ 4<br />TextureCoords equ 5<br />FrameXFormMatrix equ 6<br />RMInfo equ 7<br />RMVector equ 8<br />MeshFace equ 9<br />MaterialArray equ 10<br />MeshMaterialList equ 11<br />RMCoords2d equ 12<br />Matrix44 equ 13<br />Animation equ 14<br />AnimationSet equ 15<br />AnimationKey equ 16<br />FloatKeys equ 17<br />AmbientColor equ 18<br />DiffuseColor equ 19<br />SpecularColor equ 20<br />EmissiveColor equ 21<br />RMMaterialPower equ 22<br />ColorRGBA equ 23<br />ColorRGB equ 24<br />RMGuid equ 25<br />RMTextureFilename equ 26<br />RMTextureReference equ 27<br />RMIndexedColor equ 28<br />MeshVertexColors equ 29<br />RMMaterialWrap equ 30<br />RMBoolean equ 31<br />MeshFaceWraps equ 32<br />RMBoolean2d equ 33<br />RMTimedFloatKeys equ 34<br />AnimationOptions equ 35<br />RMFramePosition equ 36<br />RMFrameVelocity equ 37<br />RMFrameRotation equ 38<br />RMLight equ 39<br />RMCamera equ 40<br />RMAppData equ 41<br />RMLightUmbra equ 42<br />RMLightRange equ 43<br />RMLightPenumbra equ 44<br />RMLightAttenuation equ 45<br />RMInlineData equ 46<br />RMUrl equ 47<br />RMProgressiveMesh equ 48<br />RMExternalVisual equ 49<br />RMStringProperty equ 50<br />RMPropertyBag equ 51<br />RMRightHanded equ 52<br />DXFileHeader equ 53<br /><br />;The LUT is sorted in the same order as the Equates above<br />;This avoids the need for implicitly declaring them in the table<br />;Note that the first value at offset 0 is illegal and we don't use it<br />;It's just there to maintain parity with the prior version of this code<br /><br />.data<br />TemplateLUT 	dd -1                                                       ;0=Unknown<br />                      	dd offset TID_D3DRMFrame<br />                       	dd offset TID_D3DRMMesh<br />                       	dd offset TID_D3DRMMaterial<br />                       	dd offset TID_D3DRMMeshNormals<br />		dd offset TID_D3DRMMeshTextureCoords<br />		dd offset TID_D3DRMFrameTransformMatrix<br />		dd offset TID_D3DRMInfo<br />		dd offset TID_D3DRMVector<br />		dd offset TID_D3DRMMeshFace<br />		dd offset TID_D3DRMMaterialArray<br />		dd offset TID_D3DRMMeshMaterialList<br />		dd offset TID_D3DRMCoords2d<br />		dd offset TID_D3DRMMatrix44<br />		dd offset TID_D3DRMAnimation<br />		dd offset TID_D3DRMAnimationSet<br />		dd offset TID_D3DRMAnimationKey<br />		dd offset TID_D3DRMFloatKeys<br />		dd offset TID_D3DRMMaterialAmbientColor<br />		dd offset TID_D3DRMMaterialDiffuseColor<br />		dd offset TID_D3DRMMaterialSpecularColor<br />		dd offset TID_D3DRMMaterialEmissiveColor<br />		dd offset TID_D3DRMMaterialPower<br />		dd offset TID_D3DRMColorRGBA<br />		dd offset TID_D3DRMColorRGB<br />		dd offset TID_D3DRMGuid<br />		dd offset TID_D3DRMTextureFilename<br />		dd offset TID_D3DRMTextureReference<br />		dd offset TID_D3DRMIndexedColor<br />		dd offset TID_D3DRMMeshVertexColors<br />		dd offset TID_D3DRMMaterialWrap<br />		dd offset TID_D3DRMBoolean<br />		dd offset TID_D3DRMMeshFaceWraps<br />		dd offset TID_D3DRMBoolean2d<br />		dd offset TID_D3DRMTimedFloatKeys<br />		dd offset TID_D3DRMAnimationOptions<br />		dd offset TID_D3DRMFramePosition<br />		dd offset TID_D3DRMFrameVelocity<br />		dd offset TID_D3DRMFrameRotation<br />		dd offset TID_D3DRMLight<br />		dd offset TID_D3DRMCamera<br />		dd offset TID_D3DRMAppData<br />		dd offset TID_D3DRMLightUmbra<br />		dd offset TID_D3DRMLightRange<br />		dd offset TID_D3DRMLightPenumbra<br />		dd offset TID_D3DRMLightAttenuation<br />		dd offset TID_D3DRMInlineData<br />		dd offset TID_D3DRMUrl<br />		dd offset TID_D3DRMProgressiveMesh<br />		dd offset TID_D3DRMExternalVisual<br />		dd offset TID_D3DRMStringProperty<br />		dd offset TID_D3DRMPropertyBag<br />		dd offset TID_D3DRMRightHanded<br />		dd offset TID_DXFILEHeader<br />                        dd 0                                                                 ;Table Terminator<br /><br />.code<br />IdentifyGUID PROC xof:DWORD<br />local pType:DWORD<br />    .if ($mcall (xof,IDirectXFileData_GetType,addr pType)) != DXFILE_OK<br />          invoke MessageBox,0,CTXT(&quot;FAILED to get template type, let alone ID it&quot;),CTXT(&quot;Parse Error&quot;),MB_OK+MB_ICONERROR<br />          return Unknown<br />    .endif<br />    push esi<br />    lea esi,TemplateLUT<br />    add esi,4                                       ;(skip first entry since its illegal)<br />    .while dword ptr != NULL<br />        invoke CmpGUID, pType, dword ptr<br />        .if eax==1                                          ;If we find a match, determine what it is..<br />            sub esi, offset TemplateLUT        ;first we'll subtract the start of the Table to get the Offset<br />            shr esi,2                                       ;then we'll divide by 4 because the Table is based on DWORDS<br />            mov eax,esi                                 ;Now we have an integer value which should match our Equates above<br />            pop esi                                         ;We'll restore esi to its former glory<br />            ret                                                ;and return the value we discovered to the Caller.<br />        .endif<br />        add esi,4<br />    .endw<br />    pop esi<br />    return Unknown</div>
    <div class="meta">Posted on 2003-10-18 20:52:59 by Homer</div>
   </div>
   <div class="post" id="post-121715">
    <div class="subject"><a href="#post-121715">D3D Animation Support Module</a></div>
    <div class="body">w00t !!<br />We are detecting other types again !!<br />Which is Damn Strange considering how it was fixed...<br />Obviously, the issue was in the template identifier.<br />What is less obvious is that although the opcodes have changed in that procedure (we use LUT now), the methodology remains unaltered.<br />Here's a lite object parse function, which is handling Frames and their FrameMatrices ... I'll turn the MeshLoader and AnimationSet parser functions back on as soon as my son is done playing Morrowind...<br /><br />FrameNode_Load PROC pData:DWORD, ParentFrame:DWORD, pSkinMeshOwner:DWORD<br />local  pSubObj:DWORD<br />local  pSubData:DWORD <br />local  pDataRef:DWORD <br />local pType:LPGUID<br />local NameBuf[256]:BYTE<br />local ErrBuf[256]:BYTE<br />local pmeshnode:LPMESHNODE<br />local panimationset:LPANIMATIONNODE<br />local dwSize:DWORD<br />local hFrame:LPFRAMENODE<br />local pmat:LPD3DXMATRIX<br />local dwsize:DWORD<br />local hname:DWORD<br />;local parentframe:DWORD<br />;===============================================================================<br />;Initialize locals (DX can be finicky - some output args can also be input args !!)<br />;===============================================================================<br />xor eax,eax<br />mov pSubObj,eax<br />mov pSubData,eax<br />mov pDataRef,eax<br />mov pType,eax<br />mov NameBuf[0],al<br />mov dwSize,eax<br />mov hFrame,eax<br />mov pmeshnode,eax<br />mov panimationset,eax<br />;m2m parentframe,ParentFrame<br />;===============================================================================<br />invoke IdentifyGUID, pData<br />;===============================================================================<br />.if eax==Frame<br />  mov hFrame,    $invoke (LinkedLists_AppendSibling,ParentFrame,NULL, sizeof FrameNode)<br />  .if hFrame==NULL<br />     Errr CTXT(&quot;Error - Failed to create FrameNode&quot;)<br />  .endif<br />  .if $mcall (pData,IDirectXFileData_GetName, NULL, addr dwSize)!=D3D_OK<br />    Errr CTXT(&quot;Failed to get Template Name Length&quot;)<br />  .elseif dwSize!=0<br />        mcall ,IDirectXFileData_GetName, addr NameBuf, addr dwSize<br />  .endif<br />  .if NameBuf[0]== NULL                                                                     ;  // Give a default name if none found<br />    invoke lstrcpy,addr NameBuf, CTXT(&quot;$NamelessTemplate$&quot;)<br />  .endif    <br />   invoke LinkedObjects_SetName, hFrame, addr NameBuf<br />;===============================================================================<br />      .elseif eax==FrameXFormMatrix  <br />;       // Read the Matrix data straight into our buffer(s)    <br />                        mov esi,$invoke (GlobalLock,ParentFrame)<br />                        assume esi:nothing<br />                        assume esi:ptr FrameNode<br />                        lea ebx,.OriginalMatrix<br />                        m2m pmat, ebx<br />		mcall ,IDirectXFileData_GetData, NULL, addr dwsize, addr pmat <br />                        .if eax==DXFILE_OK<br />                              lea ebx,.TransformationMatrix<br />                              m2m pmat, ebx<br />		      mcall ,IDirectXFileData_GetData, NULL, addr dwsize, addr pmat <br />                              .if eax==DXFILE_OK<br />               ;                       invoke MessageBox,0,CTXT(&quot;MATRIX !!&quot;),CTXT(&quot;Frames Loader&quot;),MB_OK<br />            	     .else<br />  		              Errr CTXT (&quot;Couldn't read frame transformation matrix from an x file&quot;)<br />                             .endif<br />  		.else<br />  		      Errr CTXT (&quot;Couldn't read frame transformation matrix from an x file&quot;)<br />  		.endif<br />                        invoke GlobalUnlock,ParentFrame<br />                   invoke MessageBox,0,CTXT(&quot;FRAMEMATRIX processed&quot;),CTXT(&quot;Frames Loader&quot;),MB_OK<br /><br />        .endif<br /><br /><br /><br /><br /><br /><br />;   Scan for embedded templates<br /><br />    mcall ,IDirectXFileData_GetNextObject, ADDR pSubObj     <br />    .while eax!=DXFILEERR_NOMOREOBJECTS<br />        .if  eax==DXFILEERR_BADVALUE<br />            Errr CTXT(&quot;Parser Error - DXFILEERR_BADVALUE - in Frames Parser&quot;)<br />        .endif<br /><br />        .if ($mcall(pSubObj,IDirectXFileObject_QueryInterface, ADDR IID_IDirectXFileDataReference, ADDR pDataRef)) == DXFILE_OK<br />          .if ($mcall(pDataRef,IDirectXFileDataReference_Resolve,addr pSubData))==DXFILE_OK<br />            invoke IdentifyGUID,pSubData<br />            invoke MessageBox,0,CTXT(&quot;REFOBJECT IDENTIFIED&quot;),CTXT(&quot;YAYYYYYY&quot;),MB_OK<br />             invoke FrameNode_Load,pSubData, hFrame,pSkinMeshOwner<br />             _saferelease pSubData <br />          .endif<br />          _saferelease pDataRef<br />        .endif<br /><br />        .if ($mcall (pSubObj, IDirectXFileObject_QueryInterface,addr IID_IDirectXFileData, addr pSubData)) == DXFILE_OK<br />                invoke FrameNode_Load,pSubData, hFrame,pSkinMeshOwner<br />               _saferelease pSubData<br />        .endif    <br /><br /><br />         _saferelease pSubObj<br />         mcall ,IDirectXFileData_GetNextObject, ADDR pSubObj     <br />    .endw<br />ret<br />FrameNode_Load ENDP</div>
    <div class="meta">Posted on 2003-10-18 21:17:08 by Homer</div>
   </div>
   <div class="post" id="post-121720">
    <div class="subject"><a href="#post-121720">D3D Animation Support Module</a></div>
    <div class="body">Hey Homer<br /><br />Go on admit it, your the one playing Morrowind :grin:<br />I must admit that I play the game, probably the best RPG I've played altho it has its good and bad points.<br />I would love to write a game along similar lines.<br /><br />I'm happy to hear that the code works again and I'm looking forward to seeing what you get up to next :alright:<br /><br />Maelstrom</div>
    <div class="meta">Posted on 2003-10-19 00:42:31 by Maelstrom</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=15287&amp;page=1" style="">&laquo;</a><a href="../?id=15287&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="15287" /><input type="number" name="page" min="1" max="6" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=15287&amp;page=3">&gt;</a><a href="../?id=15287&amp;page=6">&raquo;</a></form>  </div>
 </body>
</html>