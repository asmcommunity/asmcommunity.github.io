<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Another Poll... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=263" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=38">Object Oriented Programming</a> &raquo; <a href="../?id=263">Another Poll...</a></p>
   <div class="post" id="post-1367">
    <div class="subject"><a href="#post-1367">Another Poll...</a></div>
    <div class="body">Currently, as i have said before, Thomas and myself are busy hacking out a new 'compiler' tool to ease the development of Object Classes in MASM.   The entire developed syntax was basically an extension of Ernie's COM work.<br /><br />I quickly built an earlier version, but it needed more 'editor' like features ~ realizing we humans tend to change our minds :)  (Its still available on my web-site for those interested).  <br /><br />My question is concerning how many people are truely interested in this appending style of ASM programming?  I felt i got a luke warm reaction when I made the first version, and to my surprise i found out it wasnt the cumbersom tool design, but more often than not, people dont truely understand the High Level lingo of Objects and Classes.  (Quite understandable in an ASM world... :) )<br /><br />So, having explained my reasons, please choose the best option that fits how you feel about OOP in MASM.  Our second tool design is total new and fresh, and will continue regardless, but i would like to know how I should to begin to package &amp; introduce its strengths to the community...<br /><br />Thanx alot..<br /><br />NaN</div>
    <div class="meta">Posted on 2001-07-19 22:07:32 by NaN</div>
   </div>
   <div class="post" id="post-1375">
    <div class="subject"><a href="#post-1375">Another Poll (concerning OOP)...</a></div>
    <div class="body">I've edited your thread topic a bit so it would more easily attract people :grin:</div>
    <div class="meta">Posted on 2001-07-19 23:12:22 by Hiroshimator</div>
   </div>
   <div class="post" id="post-1379">
    <div class="subject"><a href="#post-1379">Another Poll (concerning OOP)...</a></div>
    <div class="body">Hmmm, there's no choice that fits me :(. I've got a pretty good concept<br />of OOP, and I think it can be very useful from time to time. But, I don't<br />know if it will be useful for me in asm. I guess it depends on a couple<br />of factors.<br /><br />First is it easy to use? If it's a lot more work than a procedural methods,<br />I'll stick to procedural methods.<br /><br />Second, how large is the overhead? As far as I can see, you should<br />be able to get the overhead down pretty much, but it will of course<br />depend on you implementation :).<br /><br />Will you use the COM? Or something that looks like it? In other ways,<br />will it be possible to use your tool to build interfaces for existing<br />COM objects?<br /><br />This sounds like a pretty interesting project, keep up the good work.</div>
    <div class="meta">Posted on 2001-07-20 00:23:49 by f0dder</div>
   </div>
   <div class="post" id="post-1399">
    <div class="subject"><a href="#post-1399">Another Poll (concerning OOP)...</a></div>
    <div class="body">To add some more details about the format of the objects: The classes are quite compact and there isn't much overhead. It definitely doesn't uses COM but it uses some of the basic things that COM uses (really basic things)..<br />A class is simply a structure with variables as normal data (dwords, words whatever you like), and a set of pointers to it's methods (not in a separate vtable, just plain in the structure). A method is simply a normal procedure, but with of course an lpThis as first parameter.<br />That's about it right now.. In the previous object tool NaN created the structure is initialized in the constructor with a set of movs, but we plan to do this smarter in the next version, like an already filled structure with initial data and a memory copy in the constructor, to save bytes and time.. The methods are invoked with about the same macro Ernie wrote to call COM object methods. <br />So I don't think there's much overhead. But I will not be writing everything in classes now (although the next object tool is, for cooperating easily), but for some things it can be very handy because every object has it's own data space..<br />However, if we want to implement some more high level things like inheritance (which could be useful too), we have a bigger problem. As the macro syntax of MASM is not powerfull enough to handle multi-layer multi-class inheritance (well maybe it can be done in macro's but we don't want 1000 lines of macros and another 1000 for each class definition :) ). A solution could be writing a preparser that parses the file before masm gets it but I think many people won't like this (because then wysi NOT wyc). Although the parser won't change much, only fill in the right address for a method call, I don't think people will like the idea of a parser that does things behind your back.. Maybe we add a poll for this though. <br /><br />Thomas<br /><br />P.S. If you want to get an example of the class definition, download the previous tool at <a target="_blank" href="http://nan32asm.cjb.net">NaN's site</a>, there is an example in the zip file.<br /><br />edit: Is it easy to use? Well it's not hard to modify the file by hand but it's not really fun to change all the definitions if you just want to add a method. But this is solved by the object tool. While the first object tool is simply a generator for a new class, the next will be able to load up existing files and let you modify procedure definitions, variables, methods etc on the fly like you would do in Visual C++. The tool preserves all your existing code and just changes the code as you would do it yourself.. It's not that it's too complicated to modify the class yourself, it's just that it's too much work:alright:</div>
    <div class="meta">Posted on 2001-07-20 04:24:20 by Thomas</div>
   </div>
   <div class="post" id="post-1411">
    <div class="subject"><a href="#post-1411">Another Poll (concerning OOP)...</a></div>
    <div class="body">to some  people, COM is a monster and dare not touch it. but to most, COM is a must and the reasons are undefine except to one individual. COM is quite new and will grow over the next 2 or 3 years (or better yet, it's growing right now!) if you're coding for windows and not understanding what COM is, i'm sure you will be behind as technology grows... i'm not windows' fan (you know... a thing that blow air when you're hot?) but still believe that your project will be a great asset for those who are coding in windows. and i think you should continue on that project cause the bar is running fast!<br /><br />reason why i don't code COM in masm:<br />VC++ has COM. :)<br /><br />masm is my hammer.</div>
    <div class="meta">Posted on 2001-07-20 07:14:35 by disease_2000</div>
   </div>
   <div class="post" id="post-1463">
    <div class="subject"><a href="#post-1463">Another Poll (concerning OOP)...</a></div>
    <div class="body"><div class="quote"><br />First is it easy to use? If it's a lot more work than a procedural methods, I'll stick to procedural methods. <br /></div><br /><br />Yes its easy to use.  As Thomas described, Its use is a direct parallel to how you would use COM's.. The difference is instead of &quot;coinvoke&quot; there is &quot;METHOD&quot;.  To create a new instance there is &quot;NEWOBJECT&quot; and to destroy this instance there is &quot;DESTROY&quot;.  (Theses are in my first package on my web-site).  To further this thought, once you have a class written the way you want it, it should be completely re-usable in ANY project (saving development time on future projects..). <br /><br />Currently, the first Object Creator tool only generates new class files for you (based on the methods/variables you want in your class).  This is easy to use, as it builds a template, and all you do is code your methods much like normal functions.  But if you want to add a new method, it required manual editing which is a bit more work.  (Just like COM's, there is a fucntion pointer system (generated by the Object creator)).  The function pointer system is based off Ernie's COM model. There is 4 separate lines to add in 4 sections + the method code to add per Method.  This can be annoying to keep modifying, and is why i devised the tool in the first place.  To keep it to the point of just adding Method code, and let the &quot;red-tape&quot; be taken care of by the Tool.<br /><br />So, In direct answer:  No, once the second version is complete it will be no more work than procedural  Methods.  (You still have to think about what you want ~ but this is the same in normal procedural coding :) )<br /><br /><div class="quote"><br />Second, how large is the overhead? As far as I can see, you should be able to get the overhead down pretty much, but it will of course depend on you implementation . <br /></div><br /><br />Again, Thomas has this pretty well wrapped up.  I would just like to add that what i was getting as was the # of lines needed to implement function pointing (described a bit above).  Its alot of repetative typing and easy to loose track of a typo in the midst of it!.   <strong>This is all set-up for the compiler however, non of this gets translated into code!! </strong>  It just allows the compiler to understand that some structure members are function offsets (Methods procs), so it wont complain when you compile something like &quot;invoke eax&quot; (which is basically what is in the METHOD macro).<br /><br /><div class="quote"><br />Will you use the COM? Or something that looks like it? In other ways, will it be possible to use your tool to build interfaces for existing COM objects? <br /></div><br /><br />Definitely!  The system is based off the COM structure but in no way is it COM.  Every method proc is essencially a funtion.  And thus has all the capabilities a function would.  What you choos to do in a method is up to you!<br /><br /><pre><code><br />More Facts&#58;<br />========<br /><br />The Class File has&#58;<br /> - The function pointing &quot;red-tape&quot; the MASM wants.<br /> - A structure having &#58;DWORD offsets for methods + variables<br />    - The Structure is termed a &quot;Class&quot; &#40;but still just a Struct&#41;<br />    - Every Class MUST have a &quot;Constructor&quot; method offset<br />    - Every Class MUST have a &quot;Destructor&quot; method offset<br />  - All Method Function code. &#40;just like normal functions + 1 more param LpTHIS&#41;<br /></code></pre><br /><br />Objects in more Detail<br />================<br /><br />When the above is compiled, only the Method Function code makes it to bits and bytes in your exe.  (In essence Classes are &quot;Function Organization&quot; practices).  <br /><br />To use a Class, an area of Dynamic memory is reserved (based on the Class stucture size ~ small!!), using the &quot;NEWOBJECT myClass&quot; Macro.  This allocated memory address is returned as an &quot;Object Instance&quot; pointer.   Just before the the macro returns this, the Class constructor method (a must) is called, were the function offsets are assigned to the &quot;Method&quot; members. <br /><br />So, an &quot;Instance&quot; has varaiables and a bunch of Method offsets.  Taking up minimal memory.  The varialbes are Private to the memory allocated (like a normal stucture allocated in memory).   <br /><br />When another &quot;instance&quot; is created, the Method offsets will again point to the same Method code, but the variables (all having the same Name) will be in a separate memory space, and thus be unqiue between instances.  This is why they are call &quot;Instances&quot; Every INSTANCE is unique in the data it holds, but its Variable names, and Method behaviour is not!.<br /><br />Method can be written to Do something like Get_Variable_Y, (which should retrieve the data from the instance's Y variable).<br /><br />When an instance calles a Method, secretely behind the scenes, the first parameter is the address pointer to the instance in memory (lpTHIS).  The method function then uses the address pointer to correctly get the Y variable data from the specific instance!!  This is how once 'function' can service an infinite # of instances, and correctly get the unique Y data in each Instance.<br /><br />So to recap in less English: (and simplified a bit)<br /><pre><code><br />.. Method Red Tape for MASM ...<br /><br />PointClass  STRUCT<br />     Destructor     RedTapeDefinedType1  ?<br />     X_DataVar     DD                               ?<br />     Y_DataVar     DD                               ?<br />     Get_Y            RedTapeDefinedType2  ? <br />     Get_X            RedTapeDefinedType3 ?<br />PointClass ENDS<br /><br />.code<br /><br />Constructor PROC lpTHIS&#58;DWORD, X_Data&#58;DWORD, Y_Data&#58;DWORD<br /><br />   mov edx,  lpTHIS<br />   assume edx&#58;PTR PointClass<br /><br />   mov &#91;edx&#93;.Get_Y, offset Get_Y_Function<br />   mov &#91;edx&#93;.Get_X, offset Get_X_Function<br />   mov &#91;edx&#93;.X_DataVar, X_Data<br />   mov &#91;edx&#93;.Y_DataVar, Y_Data<br /><br />   assume edx&#58;NOTHING<br />   ret<br />Constructor ENDP<br /><br />Get_Y_Function PROC lpTHIS&#58;DWORD<br />  mov edx, lpTHIS<br />  assume edx&#58;PTR PointClass<br /><br />  mov eax, &#91;edx&#93;.Y_DataVar<br /><br />  assume edx&#58;NOTHING<br />  ret<br />Get_Y_Function ENDP<br /></code></pre><br /><br />So in use you would see this:<br /><br /><pre><code><br />  NEWOBJECT PointClass, 10, 20<br />  mov Piont1, eax<br /><br />  NEWOBJECT PointClass, 0, 1002<br />  mov Piont2, eax<br /><br />  METHOD Point1, PointClass, Get_Y<br />  <br />  ;  EAX == 20<br />  <br />  METHOD Point2, PointClass, Get_Y<br /><br />  ; EAX == 1002<br /><br />  DESTROY Point1<br />  DESTROY Point2<br /></code></pre><br />  <br />If you notice in the Method code for Get_Y, it never specifically 'knows' the address of the varaible because it is given to the method when its entered. <br /><br />As well each instance is == to the structure size.  (20 bytes for this), and only one set of functions are needed for any number of instances.<br /><br />An example of its use could be better understood as a HTML_Link class.  Where each instance on creation places a Static Label on a window, saving its handle in the object class.  Each URL is stored within the instance as variable data, and has a method &quot;gotoURL&quot; for each instance.<br /><br />Th gotoURL method would be coded to recieve the given handle from the BN_CLICKED message a compare it to its own instance handle.  If it is the same, then do URL code..., esle return NULL.<br /><br />All URL instances encapsulate unique data about themselves (URL links), yet have a common method to do something about it (gotoURL).<br /><br />Anyways this has become WWWWWWWWWWWWAAAAAAAAAAAYYYYYYY tooooo long, so i stop while im ahead....  (my Girlfriend wants the computer back :rolleyes: )<br /><br />NaN<br />:stupid:  <em> bables too much</em></div>
    <div class="meta">Posted on 2001-07-20 13:36:34 by NaN</div>
   </div>
   <div class="post" id="post-1465">
    <div class="subject"><a href="#post-1465">Another Poll (concerning OOP)...</a></div>
    <div class="body">what if future version of masm has built-in oop?</div>
    <div class="meta">Posted on 2001-07-20 14:11:51 by disease_2000</div>
   </div>
   <div class="post" id="post-1473">
    <div class="subject"><a href="#post-1473">Another Poll (concerning OOP)...</a></div>
    <div class="body"><div class="quote">what if future version of masm has built-in oop?</div> <br /><br /><br />Well, we don't have it now.  Also, we don't know whether there will be a future version of MASM, we don't know whether there won't.  If there is, then appropriate modifications can be adapted.  Otherwise, it would appear this helps.<br /><br />However, I think the future MASM is closer to what the .NET MSIL program is, it's all interpreted :(<br /><br /><br />Thanks,<br />_Shawn</div>
    <div class="meta">Posted on 2001-07-20 15:30:49 by _Shawn</div>
   </div>
   <div class="post" id="post-1476">
    <div class="subject"><a href="#post-1476">Another Poll (concerning OOP)...</a></div>
    <div class="body">I choose the last option, but I'd like to add: I know it's going to slow my code down if I use it, but I know it will speed up my coding.  I think OOP in MASM is for people who want to stick with one language and get HLL features (IMHO).<br /><br />Personally, I'd prefer a preprocessor and to have the OO stuff integrated into ASM like a language extention.  I'd also like the ablity to reduce any object from object representation to basic ASM - this would allow the programmer to throw things together at a high level and then thrash around at a lower level optimizing stuff - destroying the object concept locally.</div>
    <div class="meta">Posted on 2001-07-20 16:29:54 by bitRAKE</div>
   </div>
   <div class="post" id="post-1480">
    <div class="subject"><a href="#post-1480">Another Poll (concerning OOP)...</a></div>
    <div class="body">i'm very interest in the tutorial :) if it's possible that you two can make one that is easy for beginner.</div>
    <div class="meta">Posted on 2001-07-20 16:49:30 by nop</div>
   </div>
   <div class="post" id="post-1501">
    <div class="subject"><a href="#post-1501">Another Poll (concerning OOP)...</a></div>
    <div class="body">Tutorials and Examples are definitely planned...  Kinda why i wanted such feedback to learn basically what the going views are, so i may better taylor tutorials.   <br /><br />All in all i think there results look good, but i will give it some more time and see...<br /><br />I would also like to say that BitRake is correct, it will add the overhead of function calling rather than directly coding functions inline with your code.  As well there tends to be more single-purpose functions.  So speed is ever so slightly diminished in most cases.  As well he is also correct in that it will help you code faster.  Good Classes allow for re-usability, and its best to write any class for this in mind.  However, I do tend to deviate when i feel that the extra overhead out weighs its re-usability use.   No one says you must adhear to any rules with this.  If you want to write a class while knowing something is in global memory and dont care for re-usability, then skip the &quot;Set_Parameter&quot; method to pass data to the instance and just write your code to reference it directly.  <br /><br />OOP pro's really tend to frown on this, but who cares if you can afford it here and there to save runing speed.  <br /><br />As well, I used the object 'format' and made a few modifications to handle all the tab selections on the new tool.  Currently there is 5 master selections in a tree-view and each selection has two tab displays (Properties and Actual code).  So in all there is 10 separate window 'displays' to toggle between when browsing the tree or tabs.  To do this, use &quot;ShowWindow&quot; alot!!!  I need to first hide all controls on one display, and then show all the correct controls for the new display.   This would be a nightmare if it wasnt for objects.  My solution was about 10 lines of code to manage....<br /><br />I built a TABDISPLAY class with no varialbes and only 4 methods (Tab_X_Create, Tab_X_Show, Tab_X_Hide, Tab_X_Destroy).   Then I erased the Method code generated (Actual Funtion Code) and edited the constructor to accept 4 parameters, and set the method offsets like so:<br /><pre><code><br />; This is the constructor &#40;Init&#41;<br />TABDISP_Init  PROC  lpTHIS&#58;DWORD, Create&#58;DWORD, Destroy&#58;DWORD, \<br />                                 Show&#58;DWORD, Hide&#58;DWORD, hWin&#58;DWORD<br />   mov eax, lpTHIS<br />   m2m &#40;TABDISP PTR &#91;eax&#93;&#41;.destroy, Destroy<br />   m2m &#40;TABDISP PTR &#91;eax&#93;&#41;.Hide, Hide<br />   m2m &#40;TABDISP PTR &#91;eax&#93;&#41;.Show, Show<br />   <br />   push hWin<br />   mov eax, Create<br />   call eax<br />   <br />   ret<br />TABDISP_Init ENDP<br /></code></pre><br />Sample Creation Code:<br /><pre><code><br />   ; Private Var TV Group &#40;Code Edit Tab&#41; ; --======================<br />   NEWOBJECT TABDISP, offset T2PrVarCreate, offset T2PrVarDestroy, \<br />                      offset T2PrVarShow,   offset T2PrVarHide, hWin<br />   mov hT2PrVar, eax<br /></code></pre><br />This allows me to assign a Method Routine to a given instance on creation (Rather than the same one for all instances). <br /><br />Every Unique tab display was written in a separate file, each having a these 4 behavior code for its unique display. <br /><pre><code>&#40;&#40; Sample&#58; Code Window Tab for Private Variables &#41;&#41;<br />.code<br />T2PrVarCreate PROC hWin&#58;DWORD<br />; Place all create code here for this tab display<br />   ; Do Edit Control<br />   invoke CreateWindowEx, WS_EX_CLIENTEDGE ,<br />            ADDR edClass, ADDR szObject,<br />            WS_CHILD or WS_HSCROLL or WS_VSCROLL or \<br />            ES_AUTOHSCROLL or ES_AUTOVSCROLL or \<br />            ES_MULTILINE or ES_LEFT,<br />            ED_X,ED_Y,ED_WD,ED_HT,hWin,Edit1ID,<br />            hInstance,NULL<br />   mov hEdit1, eax<br />  DebugPrint &quot;&gt;&gt; Tab 2 Private Var Created  &lt;&lt;&quot;<br />  ret<br />  <br />T2PrVarCreate ENDP<br /><br />T2PrVarShow PROC<br />  ; Do Show Window Stuff here for this display<br />  invoke ShowWindow, hEdit1, SW_SHOW<br />  DebugPrint &quot;&gt;&gt; Tab 2 Private Var Shown  &lt;&lt;&quot;<br />  ret<br />T2PrVarShow ENDP<br /><br />T2PrVarHide PROC<br />  ; Do Hide window stuff here for this display<br />  invoke ShowWindow, hEdit1, SW_HIDE<br />  DebugPrint &quot;&gt;&gt; Tab 2 Private Var Hidden  &lt;&lt;&quot;<br />  ret<br />T2PrVarHide ENDP<br /><br />T2PrVarDestroy PROC<br />  ; if needed, destroy any reserved memory created...<br />  DebugPrint &quot;&gt;&gt; Tab 2 Private Var Destroyed &lt;&lt;&quot;<br />  ret<br />T2PrVarDestroy ENDP<br /></code></pre><br />I create one instance of this class for each display, and then when the Tree-view message comes in saying Selection was made, no thinking is needed to decide which display it is and which display is currently shown.  <br /><br />I simply get the current object handle being displayed (stored globally) and call its Hide method (METHOD eax, TABDISP, Hide) and then get the lParam outa the tree selection (which houses the TABDISP handle for its selection) and call its show method (METHOD ecx, TABDISP, Show).<br /><br />Thats it for thinking it thru... all that deals with each display is nicely encapsulated in each file in to these four groups and since each insance is UNIQUE, yet has the same Method names I can do this with out problem.<br /><br />There is no real savings here as there is a 1:1 relation between the number of method's to write, and the number of instances created.  I would at least provide the same code in a proceedural way!, but using the Class i can easily manage them without a case-like if structure to determine which function should be executed next.. The uniqeness of each instance allowes me to 'bundle' fucntions together under common names as described above, and then the handler routine doesnt care about the specifics.. it just wants to &quot;hide&quot; one and &quot;show&quot; the next...<br /><br />Neat Trick eh?<br /><br />:alright: <br />NaN</div>
    <div class="meta">Posted on 2001-07-20 23:27:15 by NaN</div>
   </div>
   <div class="post" id="post-1705">
    <div class="subject"><a href="#post-1705">Another Poll (concerning OOP)...</a></div>
    <div class="body">Will the object constructor (actually the object creation method) take arguments?<br /><br />A variable ammount of arguments?<br /><br />Well, will it?<br /><br /><br />;=)</div>
    <div class="meta">Posted on 2001-07-22 18:43:46 by Ernie</div>
   </div>
   <div class="post" id="post-1713">
    <div class="subject"><a href="#post-1713">Another Poll (concerning OOP)...</a></div>
    <div class="body">correct me if i am wrong but OOP = using structs etc, so is this not already integrated into masm?</div>
    <div class="meta">Posted on 2001-07-22 21:13:04 by SubHuman</div>
   </div>
   <div class="post" id="post-1720">
    <div class="subject"><a href="#post-1720">Another Poll (concerning OOP)...</a></div>
    <div class="body">Nah, OOP isn't part of MASM. <br /><br />No matter, I do OOP all the time in MASM.<br /><br />OOP is about objects, and yes an object is just a glorified instanced structure.<br /><br />BUT, just having structures doesn't mean you have OOP. OOP means you can create, manupulate, employ, persist, and destroy objects. Not to mention the code development advantages of inheritance and encapsulation.<br /><br />Most of this has been worked out already by many people. The only piece I've never seen is implimentation inheritance (ie, reusing code from a base class without rewriting it).  I've never really needed this (or actually seen it as a great tool) or I'd have worked on it too.</div>
    <div class="meta">Posted on 2001-07-22 22:29:14 by Ernie</div>
   </div>
   <div class="post" id="post-1723">
    <div class="subject"><a href="#post-1723">Another Poll (concerning OOP)...</a></div>
    <div class="body"><div class="quote">Will the object constructor (actually the object creation method) take arguments? <br /><br />A variable ammount of arguments? <br /><br />Well, will it? </div><br /><br />Yes, the macro was designed for flexibility in this area.. the DESTROY macro however doesnt have a variable argument list... no need to make this process complex or problems could arise when one object destroys another object in a recursive nature (TreeView killing its Data Objects).. Simply go &quot;DESTROY TreeInstance&quot;, and the destructor of the TreeView Class 'should' recurse its own tree first, and destroy all the objects it houses.  In this situation, having a possible parameter list for 'some' classes would mean doing research on this class just to destroy it!!  (( These were my reasons in not providing the option in the destroy macro ))<br /><br />Back to you question, here is the actual NEWOBJECT macro...<br /><pre><code>NEWOBJECT MACRO ObjType&#58;REQ, args&#58;VARARG<br /><br />     LOCAL instring<br />     instring CATSTR &lt;invoke &gt;,&lt;&amp;ObjType&gt;,&lt;_Init, eax&gt;  <br />     IFNB &lt;args&gt;<br />        instring CATSTR instring, &lt;, &gt;, &lt;&amp;args&gt;<br />     ENDIF<br />     <br />     invoke GetProcessHeap<br />     invoke HeapAlloc, eax, NULL, SIZEOF ObjType<br />     <br />     push eax<br />     instring<br />     pop eax<br />ENDM</code></pre><br /><br />About inheritance, I did say at one point i had it figured out, but it then realized a fatal problem so its back in the R&amp;D department :grin: .  It has prooven to be a tricky foe,  there is solutions however, but nothing that  doesnt involve pre-processing befor ML.exe gets ahold of your ASM.  (Thomas pointed out that while there is very little change (modify your object structures), most people probably wouldnt like the lost of control with their code... as well as not seeing what is actually being piped into ML after the pre-processing).  The is other options available as well, but we decided to just get the version 2 up with the technical abilities the first one did + the editor features for re-loading and editing existing classes.  Once this is going another version will tackle these issues..<br /><br /><br />:alright: <br />NaN</div>
    <div class="meta">Posted on 2001-07-22 23:55:04 by NaN</div>
   </div>
  </div>
 </body>
</html>