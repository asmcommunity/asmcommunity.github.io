<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>iczelions tutorial#3 commented - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16252" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=16252">iczelions tutorial#3 commented</a></p>
   <div class="post" id="post-126204">
    <div class="subject"><a href="#post-126204">iczelions tutorial#3 commented</a></div>
    <div class="body">I thought I would post this as it is my commented version of tutorial#3 of eczelions tutorials.  I know he did a fairly good job of explaining it but I have put some debug stuff that i got from this message board and also tried to explain how I believe the program is running.  I know it looks a bit messy, hopefully it will still explain the process though<br /><br /><pre><code><br />.386                                 ;This is the Machine type<br />.model flat,stdcall             ;This is the syntax to use for calls<br />option casemap&#58;none      ;This allows the keys to be case sensitive<br /><br /><br />include windows.inc         ;various include bits<br />include kernel32.inc<br />include user32.inc<br />includelib kernel32.lib       ;and there associated libraries<br />includelib user32.lib<br /><br /><br />;have to define the prototype before calling it as a procedure.<br />WinMain proto &#58;DWORD,&#58;DWORD,&#58;DWORD,&#58;DWORD  <br /><br />.CONST ;numerical variables that don't change.<br />;	DBUG equ 1  ;we uncomment this to run debug instructions on the program<br /><br />.DATA<br /><br />		AppName db &quot;An Application&quot;,0                         ;String variables that don't change<br />		ClassName db &quot;A Class Name&quot;,0                       ;always finish with a terminating 0 as <br />		ErrorHandle db &quot;Incorrect Parent Handle&quot;,0      ;it is in ascii format<br />		ErrorMsgBoxTitle db &quot;Critical Error&quot;,0<br />		ErrorWindow db &quot;Could not create or update the window&quot;,0<br />.DATA?<br /><br />		hInstance HINSTANCE ?     ;strings that change<br />		CommandLine LPSTR ?<br /><br />.code                ;start of code section<br /><br />start&#58;                ;our first label<br /><br />		invoke GetModuleHandle,NULL   ;grab the handle for our module<br />		mov hInstance,eax                     ;put it into hInstance<br />		invoke GetCommandLine            ;grab the command line<br />		mov CommandLine,eax               ;put it in CommandLine<br />		invoke WinMain,hInstance,NULL,CommandLine,SW_SHOWDEFAULT  ;invoke our procedure<br />		invoke ExitProcess,eax               ;then exit<br /><br /><br />;this is the beginning of our procedure<br />WinMain proc hInst&#58;HINSTANCE,<br />             hPrevInst&#58;HINSTANCE,<br />             CmdLine&#58;LPSTR,<br />             CmdShow&#58;DWORD<br /><br /><br />LOCAL wc&#58;WNDCLASSEX  ;set up local variables.  wc is our windows class, msg is the messenger variable <br />LOCAL msg&#58;MSG               ;and hWnd is the handle of our Main Window.<br />LOCAL hWnd&#58;HWND<br /><br />		mov wc.cbSize,SIZEOF WNDCLASSEX               ;set the variables for the wc class<br />		mov wc.style,CS_HREDRAW+CS_VREDRAW<br />		mov wc.lpfnWndProc,OFFSET WinProc<br />		mov wc.cbClsExtra,NULL<br />		mov wc.cbWndExtra,NULL<br />		push hInstance<br />		pop wc.hInstance<br />		invoke LoadIcon,NULL,IDI_APPLICATION<br />		mov wc.hIcon,eax<br />		mov wc.hIconSm,eax<br />		invoke LoadCursor,NULL,IDC_ARROW<br />		mov wc.hCursor,eax<br />		mov wc.hbrBackground,COLOR_WINDOW+1<br />		mov wc.lpszMenuName,NULL<br />		mov wc.lpszClassName,OFFSET ClassName<br />		invoke RegisterClassEx,addr wc                           ;register our class<br />                invoke CreateWindowEx,                                     ;begin the creation of the window<br />				NULL,                            ;this will give us our window handle<br />				ADDR ClassName,<br />				ADDR AppName,<br />				WS_OVERLAPPEDWINDOW,<br />				CW_USEDEFAULT,<br />				CW_USEDEFAULT,<br />				CW_USEDEFAULT,<br />				CW_USEDEFAULT,<br />				NULL,<br />				NULL,<br />				hInst,<br />				NULL <br />		mov hWnd,eax                                                   ;place the handle in hWnd<br />		invoke ShowWindow,hWnd,SW_SHOWNORMAL  ;make the window visible <br />		invoke UpdateWindow,hWnd                              ;keep the window refreshed<br />                                                                                          ;**** The window doesn't display if the procedure is not running<br /><br />	IFDEF DBUG ;This section is only attached to the code if the DBUG variable is defined. ;debug section only<br />                                                                                                                                 ;used to check for errors<br />  		.IF !EAX                                ;execute next instruction if there was an error creating the window<br />    		INVOKE MessageBox,ESI,addr ErrorWindow,addr ErrorMsgBoxTitle,MB_OK ;message and exit if failure<br />    		JMP EXIT           ;after creating a notification box we jump to the exit<br />  		.ENDIF<br /><br />	ENDIF                 ;not that the . in front of IF means it is run at run time.  No . means it is run at assembly time<br /><br />	.WHILE TRUE         ;enter the message loop<br /><br />			invoke GetMessage,addr msg,NULL,0,0  ;get our message. usually wm_paint first up.<br /><br />	IFDEF DBUG   ;more debug script.. only gets assembled if we create the variable DBUG<br />		.IF eax==-1       ;another way of checking for values.  check to see if eax is -1<br />			invoke MessageBox, NULL,addr ErrorHandle,addr ErrorMsgBoxTitle, MB_OK		<br />    		JMP EXIT      ;invoke a message box and exit<br />    	                   .ENDIF<br />	ENDIF ;end of our debug section which was used to check if there was an error in the window handle.<br /><br />		.BREAK .IF &#40;!EAX&#41;  ;this is realtime code.. breaks the loop if eax is 0.  i.e. program is finished.<br />			invoke TranslateMessage, ADDR msg  ;translate message to ansi code.<br />			invoke DispatchMessage, ADDR msg   ; dispatch the message and run the procedure<br />			mov eax,msg.wParam  ;load the message for the exit process<br />	 	.ENDW ;I'm not sure if this is how the procedure is run.. i'm just guessing at present.<br />EXIT&#58; ;our exit label.. so that we can jump to the end of the loop if there is an error.<br />	ret ;return to the calling function.. i.e.  top of this program after invoke WinMain.  The next line is invoke exitprocess<br /><br />WinMain endp ;the end of our WinMain procedure.. this probably never really gets executed.<br /><br />WinProc proc hWnd&#58;HWND,uMsg&#58;UINT,wParam&#58;WPARAM,lParam&#58;LPARAM  ;the start of the window procedure<br /><br />	.IF uMsg==WM_DESTROY ;if we got the exit message from getmessage in WinMain.<br />		invoke PostQuitMessage,NULL ;then we invoke the quitmessage grabber<br />	.ELSE ;otherwise we run the default window cleaning stuff which takes care of all the <br />		invoke DefWindowProc,hWnd,uMsg,wParam,lParam  ;other messages.<br />		ret  ;then we return to WinMain.. <br />	.ENDIF ;if we use post quitmessage we will end up here to exit the loop.<br /><br />xor eax,eax ;after recieving the post quit message, we execute a zero out of eax.  I.E. this makes it 0<br /><br />ret ;then we return control to WinMain So that it can exit, because it has a 0 message.<br /><br />WinProc endp  ;this is just the end of the procedure<br /><br />end start  ;and this is the end of our program, that displayed a window.<br /></code></pre></div>
    <div class="meta">Posted on 2003-12-01 19:02:43 by Phase Verocity</div>
   </div>
  </div>
 </body>
</html>