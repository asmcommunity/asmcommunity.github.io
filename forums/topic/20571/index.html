<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>RandomGen - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20571" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=20571">RandomGen</a></p>
   <div class="post" id="post-157105">
    <div class="subject"><a href="#post-157105">RandomGen</a></div>
    <div class="body">I'm still using Mersenne Twister B.<br />Anyone willing to provide a randomgen with better distribution?<br /><br />(When I coded some 3D particle demos a while ago it became apparent that Mersenne B distributes values badly - when I generated random vectors for newly-emitted particles, they formed a &quot;Maltese cross&quot; pattern)...</div>
    <div class="meta">Posted on 2005-02-17 03:55:44 by Homer</div>
   </div>
   <div class="post" id="post-157129">
    <div class="subject"><a href="#post-157129">RandomGen</a></div>
    <div class="body">Have you tried the random generator that comes with the MASM32 lib?  It works quite well from my tests (compared to the other choices at the time).  I used a similar test with direct X to paint pixel patterns (or the lack there of).  This one was best...  but perhaps your particle streams will yeild something else?<br /><br /><pre><code>; #########################################################################<br />;<br />;                     Park Miller random number algorithm.<br />;<br />;                      Written by Jaymeson Trudgen &#40;NaN&#41;<br />;                   Optimized by Rickey Bowers Jr. &#40;bitRAKE&#41;<br />;<br />; #########################################################################<br /><br />      .486                      ; create 32 bit code<br />      .model flat, stdcall      ; 32 bit memory model<br />      option casemap &#58;none      ; case sensitive<br /><br />    .code<br /><br />; #########################################################################<br /><br />nrandom PROC base&#58;DWORD<br /><br />    mov eax, nrandom_seed<br /><br />    xor edx, edx<br />    mov ecx, 127773<br />    div ecx<br />    mov ecx, eax<br />    mov eax, 16807<br />    mul edx<br />    mov edx, ecx<br />    mov ecx, eax<br />    mov eax, 2836<br />    mul edx<br />    sub ecx, eax<br />    xor edx, edx<br />    mov eax, ecx<br />    mov nrandom_seed, ecx<br />    div base<br /><br />    mov eax, edx<br />    ret<br /><br />nrandom ENDP<br /><br />; #########################################################################<br /><br />nseed proc TheSeed&#58;DWORD<br /><br />    .data<br />      nrandom_seed dd 12345678<br />    .code<br /><br />    mov eax, TheSeed<br />    mov nrandom_seed, eax<br /><br />    ret<br /><br />nseed endp<br /><br />; #########################################################################<br /><br />    end</code></pre></div>
    <div class="meta">Posted on 2005-02-17 19:09:11 by NaN</div>
   </div>
   <div class="post" id="post-157137">
    <div class="subject"><a href="#post-157137">RandomGen</a></div>
    <div class="body">Interesting - I just attempted merging them in the following way:<br /><br />The &quot;guts&quot; function of the MersenneB procedures is called TBRandom, it generates binary randoms. <br />I modified your nrandom code to check the Base parameter is NULL - if so, forego the divide-by-base, call TBRandom, and xor the two randoms (ie, temper YOUR random with MINE). Then I replaced (in other procs) any call to TBRandom with a call to nrandom with NULL as Base param.<br /><br />The nrandom_seed is now being set up from Mersenne's init proc, thus I ditched your initializer proc.<br /><br />Just to let you know, your code alone has craptastic distribution, with obvious &quot;spikes&quot; that are far away from the &quot;core&quot; values.<br />I have some 3D code that is generating a bunch of randomly located and colored spheres, with nrandom alone it creates a &quot;cluster&quot; of these objects near the center, with outer distribution being 1) less dense and 2) marked by &quot;spikes&quot; ie clusters of objects that are remote from the &quot;core&quot; (beyond the edge of the distribution falloff).<br /><br />I did not notice any artifacts produced by pure Mersenne B in this situation, but since I know for a fact there's a distribution problem I went ahead and merged the random generators.<br /><br />I'm now getting wonderful distribution and I'd be willing to bet that I've increased the &quot;period&quot; of the random stream by a factor of several units.<br /><br />Here is my source for anyone who wants/needs a better and &quot;more random&quot; RandomGenerator:<br /><br /><pre><code><br />;MERSENNE TWISTER B <br />;Originally implemented in asm by Agner Fog<br />;Modified for ParkMiller tempering by Homer<br /><br />;=======================================================<br />      TRandomInit PROTO &#58;DWORD<br />      TBRandom PROTO                                    ;Binary Random<br />      TIRandom    PROTO &#58;DWORD,&#58;DWORD   ;Integer Random &#40;Min &gt; X Max&#41;<br />      TFRandom PROTO                                    ;Float Random &#40;0.0 &gt; X &lt;1.0&#41;<br />      nrandom PROTO &#58;DWORD                        ;Integer Random &#40;0 &gt; X &lt; Base&#41;<br />;=======================================================<br />TEMPERING EQU 1         ; comment out this line if no tempering<br /><br />IF 1<br />; define constants for MT11213A&#58;<br />N       = 351<br />M       = 175<br />R       = 19<br />MATRIX_A = 0E4BD75F5H<br />TEMU    = 11<br />TEMS    = 7<br />TEMT    = 15<br />TEML    = 17<br />TEMB    = 655E5280H<br />TEMC    = 0FFD58000H<br /><br />ELSE<br />; or constants for MT19937&#58;<br />N       = 624<br />M       = 397<br />R       = 31<br />MATRIX_A = 09908B0DFH<br />TEMU    = 11<br />TEMS    = 7<br />TEMT    = 15<br />TEML    = 18<br />TEMB    = 9D2C5680H<br />TEMC    = 0EFC60000H<br /><br />ENDIF<br /><br />LOWER_MASK = &#40;1 SHL R&#41; - 1     ; lower R bits<br />UPPER_MASK = -1 SHL R          ; upper 32-R bits<br /><br />;=======================================================<br /><br />.data<br />MT      DD      N     dup &#40;0&#41;   ; history buffer<br />TEMP    DQ      0   ; dual purpose&#58; conversion to float and MT buffer overrun<br />USE_MMX DB      0               ; 1 if use of MMX registers<br />PENDXOK DB      0               ; nonzero if number in PENDINGX is OK<br />MTI     DD      0               ; index into MT buffer<br />LMASK   DD      LOWER_MASK      ; constants<br />UMASK   DD      UPPER_MASK<br />MATA    DD      MATRIX_A<br />PENDINGX DQ     0               ; random number ready for submit in upper part<br />IFDEF   TEMPERING<br />TMB     LABEL   QWORD           ; constants<br />        DD      TEMB, TEMB<br />TMC     LABEL   QWORD<br />        DD      TEMC, TEMC<br />ENDIF<br /><br />;===================================================<br /><br />.code<br />TRandomInit PROC Seed<br /><br />        MOV EAX, Seed<br />        mov nrandom_seed,eax<br />        XOR     ECX, ECX<br /><br />R10&#58;    IMUL    EAX, 29943829        ; make random numbers and put them into buffer<br />        DEC     EAX<br />        MOV     MT&#91;ECX&#93;, EAX        <br />        ADD     ECX, 4<br />        CMP     ECX, N*4<br />        JB      R10<br />        MOV     &#91;MTI&#93;, ECX<br />        <br />; check microprocessor support for MMX instructions&#58;<br />        PUSHAD<br />        ; detect if CPUID instruction supported by microprocessor&#58;<br />        PUSHFD<br />        POP     EAX<br />        MOV     EBX, EAX<br />        XOR     EAX, 1 SHL 21<br />        PUSH    EAX<br />        POPFD<br />        PUSHFD<br />        POP     EAX<br />        XOR     EAX, EBX<br />        XOR     EDX, EDX<br />        AND     EAX, 1 SHL 21<br />        JZ      SHORT NOCPUID        ; CPUID instruction not supported<br />        XOR     EAX, EAX<br />        DB      0FH, 0A2H            ; CPUID&#58; get number of CPUID functions<br />        TEST    EAX, EAX<br />        JZ      SHORT NOCPUID        ; CPUID function 1 not supported<br />        MOV     EAX, 1<br />        DB      0FH, 0A2H            ; CPUID<br />        SHR     EDX, 23              ; bit 32 = MMX support<br />        AND     EDX, 1<br />NOCPUID&#58;MOV     &#91;USE_MMX&#93;, DL<br />        POPAD<br />        MOV     &#91;PENDXOK&#93;, 0        <br />        RET     0                    ; RET 4 if not _cdecl calling<br />TRandomInit ENDP<br /><br />;=======================================================<br />;Get random integer within given range<br />TIRandom PROC uses ebx ecx Min&#58;DWORD,Max&#58;DWORD<br />;        CALL    TBRandom             ; make random number<br />        invoke nrandom, NULL<br />        MOV     EDX, Max             ; max<br />        MOV     ECX, Min             ; min<br />        SUB     EDX, ECX<br />        JS      RERROR               ; max &lt; min<br />        INC     EDX                  ; max - min + 1<br />        MUL     EDX                  ; multiply random number by interval and truncate<br />        LEA     EAX, &#91;EDX+ECX&#93;       ; add min<br />        RET<br />RERROR&#58; MOV     EAX, 80000000H       ; error exit   <br />        RET<br />TIRandom ENDP<br /><br />;=======================================================<br />TFRandom PROC NEAR                    ; generate random float<br />;        CALL    TBRandom             ; random bits<br />        invoke nrandom, NULL<br />        MOV     EDX, EAX             ; fast conversion to float<br />        SHR     EAX, 12<br />        OR      EAX, 3FF00000H<br />        SHL     EDX, 20<br />        MOV     DWORD PTR &#91;TEMP+4&#93;, EAX<br />        MOV     DWORD PTR &#91;TEMP&#93;, EDX<br />        FLD1<br />        FLD     QWORD PTR &#91;TEMP&#93;     ; partial memory stall here<br />        FSUBR<br />        RET<br />; This conversion has a partial memory stall for combining two values in TEMP.<br />; A solution to this problem is to use pre-calculated values, as shown in<br />; MERSENNEp.ASM, but at the cost of slowing down TIRandom because it must<br />; prepare a float in case the next call is to TRandom.<br />        <br />TFRandom ENDP<br /><br />;===============================================================================<br /><br />TBRandom PROC                        ; generate random bits<br />        CMP     &#91;USE_MMX&#93;, 0         ; can we use MMX registers?<br />        MOV     ECX, &#91;MTI&#93;<br />        JE      R20<br /><br />; this version uses MMX registers<br />        CMP     ECX, N*4<br />        JNB     M70                  ; buffer is empty, fill it<br />M40&#58;    <br /><br />IFDEF   TEMPERING                    ; optional tempering<br />        CMP     &#91;PENDXOK&#93;, 0<br />        JE      SHORT M50<br />        MOV     EAX, DWORD PTR &#91;PENDINGX+4&#93; ; a tempered random number is allready pending<br />        MOV     &#91;PENDXOK&#93;, 0        <br />        RET<br /><br />M50&#58;    ; tempering of two random numbers in parallel<br />MTQ     = QWORD PTR MT<br />        MOVQ    MM0, MTQ&#91;ECX&#93;<br />        MOVQ    MM1, MM0<br />        PSRLD   MM0, TEMU<br />        PXOR    MM0, MM1<br />        MOVQ    MM1, MM0        <br />        PSLLD   MM0, TEMS<br />        PAND    MM0, &#91;TMB&#93;<br />        PXOR    MM0, MM1<br />        MOVQ    MM1, MM0        <br />        PSLLD   MM0, TEMT<br />        PAND    MM0, &#91;TMC&#93;<br />        PXOR    MM0, MM1<br />        MOVQ    MM1, MM0        <br />        PSRLD   MM0, TEML<br />        PXOR    MM0, MM1<br />        MOVD    EAX, MM0                ; return low number<br />        MOVQ    &#91;PENDINGX&#93;, MM0         ; save high number for next time<br />        EMMS<br />IF N AND 1                         ; check for the last odd one if N is odd<br />        CMP     ECX, &#40;N-1&#41;*4<br />        SETB    &#91;PENDXOK&#93;<br />ELSE        <br />        MOV     &#91;PENDXOK&#93;, 1<br />ENDIF        <br />        ADD     ECX, 8<br />        MOV     &#91;MTI&#93;, ECX        <br />        RET<br />        <br />ELSE    ; no tempering<br />        MOV     EAX, MT&#91;ECX&#93;<br />ENDIF         <br />        ADD     ECX, 4<br />        MOV     &#91;MTI&#93;, ECX        <br />        RET<br /><br />M70&#58;    ; buffer is empty. Fill it up<br />        MOVD    MM3, &#91;UMASK&#93;        ; load constants<br />        MOVD    MM4, &#91;LMASK&#93;<br />        MOVD    MM5, &#91;MATA&#93;<br />        MOV     ECX, OFFSET MT      ; kk<br />        MOV     EDX, OFFSET MT+M*4  ; km<br />        PUNPCKLDQ MM3, MM3          ; duplicate constants<br />        PUNPCKLDQ MM4, MM4<br />        PUNPCKLDQ MM5, MM5<br /><br />M80&#58;    ; kk loop, first part<br />        MOVQ    MM1, &#91;ECX&#93;          ; mt&#91;kk+1&#93; &#58; mt&#91;kk&#93;<br />        ; get misaligned pair &#40;mt&#91;kk+2&#93; &#58; mt&#91;kk+1&#93;&#41;<br />        MOVD    MM2, &#91;ECX+4&#93;        ; 0 &#58; mt&#91;kk+1&#93;<br />        PUNPCKLDQ MM2, &#91;ECX+8&#93;      ; mt&#91;kk+2&#93; &#58; mt&#91;kk+1&#93;<br />IF      M AND 1                     ; km is misaligned if M is odd. Get misaligned pair<br />        MOVD    MM0, &#91;EDX&#93;          ; 0 &#58; mt&#91;km&#93;<br />        PUNPCKLDQ MM0, &#91;EDX+4&#93;      ; mt&#91;km+1&#93; &#58; mt&#91;km&#93;<br />ELSE<br />        MOVQ    MM0, &#91;EDX&#93;          ; mt&#91;km+1&#93; &#58; mt&#91;km&#93;<br />ENDIF        <br />        PAND    MM1, MM3            ; &amp; UPPER_MASK<br />        PAND    MM2, MM4            ; &amp; LOWER_MASK<br />        POR     MM1, MM2            ; y1 &#58; y0<br />        MOVQ    MM2, MM1            ; y1 &#58; y0<br />        PSLLD   MM1, 31             ; copy bit 0 into all bits<br />        PSRAD   MM1, 31             ; -&#40;y &amp; 1&#41;<br />        PAND    MM1, MM5            ; &amp; MATRIX_A<br />        PSRLD   MM2, 1              ; y &gt;&gt; 1<br />        PXOR    MM2, MM1<br />        PXOR    MM0, MM2<br />        MOVQ    &#91;ECX&#93;, MM0          ; result into mt&#91;kk+1&#93; &#58; mt&#91;kk&#93;<br />        ADD     EDX, 8<br />        ADD     ECX, 8<br />        CMP     EDX, OFFSET MT + &#40;N-1&#41;*4<br />        JB      M80                 ; loop until km wraparound<br />        <br />        MOV     EAX, &#91;MT&#93;           ; copy beginning to end for kk wraparound<br />IF      &#40;M-N&#41; AND 1                 ; do the split km pair if M-N is odd<br />        MOV     &#91;EDX+4&#93;, EAX       <br />        MOVD    MM0, &#91;EDX&#93;<br />        PUNPCKLDQ MM0, &#91;MT&#93;         ; mt&#91;km+1&#93; &#58; mt&#91;km&#93;<br />        SUB     EDX, N*4            ; km wraparound<br />        JMP     SHORT M95<br />ELSE        <br />        MOV     &#91;EDX&#93;, EAX       <br />        SUB     EDX, N*4            ; km wraparound<br />ENDIF<br /><br />M90&#58;    ; second part of loop, where km has wrapped around<br />IF      &#40;M-N&#41; AND 1                 ; km is misaligned if M-N is odd. Get misaligned pair<br />        MOVD    MM0, &#91;EDX&#93;          ; 0 &#58; mt&#91;km&#93;<br />        PUNPCKLDQ MM0, &#91;EDX+4&#93;      ; mt&#91;km+1&#93; &#58; mt&#91;km&#93;<br />ELSE<br />        MOVQ    MM0, &#91;EDX&#93;          ; mt&#91;km+1&#93; &#58; mt&#91;km&#93;<br />ENDIF        <br />M95&#58;    MOVQ    MM1, &#91;ECX&#93;          ; mt&#91;kk+1&#93; &#58; mt&#91;kk&#93;<br />        ; get misaligned pair mt&#91;kk+2&#93; &#58; mt&#91;kk+1&#93;<br />        MOVD    MM2, &#91;ECX+4&#93;        ; 0 &#58; mt&#91;kk+1&#93;<br />        PUNPCKLDQ MM2, &#91;ECX+8&#93;      ; mt&#91;kk+2&#93; &#58; mt&#91;kk+1&#93;<br />        PAND    MM1, MM3            ; &amp; UPPER_MASK<br />        PAND    MM2, MM4            ; &amp; LOWER_MASK<br />        POR     MM1, MM2            ; y1 &#58; y0<br />        MOVQ    MM2, MM1            ; y1 &#58; y0<br />        PSLLD   MM1, 31             ; copy bit 0 into all bits<br />        PSRAD   MM1, 31             ; -&#40;y &amp; 1&#41;<br />        PAND    MM1, MM5            ; &amp; MATRIX_A<br />        PSRLD   MM2, 1              ; y &gt;&gt; 1<br />        PXOR    MM2, MM1<br />        PXOR    MM0, MM2<br />        MOVQ    &#91;ECX&#93;, MM0          ; result into mt&#91;kk+1&#93; &#58; mt&#91;kk&#93;<br />        ; loop epilog<br />        ADD     ECX, 8<br />        ADD     EDX, 8<br />        CMP     ECX, OFFSET MT + N*4<br />        JB      M90<br /><br />        XOR     ECX, ECX<br /><br />IFDEF   TEMPERING                    ; optional tempering<br />        MOV     &#91;MTI&#93;, ECX        <br />        EMMS<br />        JMP     M40<br />ELSE<br />        EMMS<br />        MOV     EAX, MT&#91;ECX&#93;<br />        ADD     ECX, 4<br />        MOV     &#91;MTI&#93;, ECX        <br />        RET<br />ENDIF        <br /><br />        <br />; this version for old processors without MMX support&#58;<br />R20&#58;    CMP     ECX, N*4<br />        JNB     SHORT R50            ; buffer is empty, fill it   <br />R40&#58;    MOV     EAX, MT&#91;ECX&#93;<br />        ADD     ECX, 4<br />        MOV     &#91;MTI&#93;, ECX<br />        <br />IFDEF   TEMPERING                    ; optional tempering<br />        MOV     EDX, EAX<br />        SHR     EAX, TEMU<br />        XOR     EAX, EDX<br />        MOV     EDX, EAX<br />        SHL     EAX, TEMS<br />        AND     EAX, TEMB<br />        XOR     EAX, EDX<br />        MOV     EDX, EAX<br />        SHL     EAX, TEMT<br />        AND     EAX, TEMC<br />        XOR     EAX, EDX<br />        MOV     EDX, EAX<br />        SHR     EAX, TEML<br />        XOR     EAX, EDX<br />ENDIF                <br />        RET<br /><br />        ; fill buffer with random numbers<br />R50&#58;    PUSH    EBX        <br />        MOV     ECX, OFFSET MT<br />        MOV     EDX, OFFSET MT + M*4<br />        ; kk loop<br />R60&#58;    MOV     EAX, &#91;ECX&#93;<br />        MOV     EBX, &#91;ECX+4&#93;<br />        AND     EAX, UPPER_MASK<br />        AND     EBX, LOWER_MASK<br />        OR      EAX, EBX<br />        SHR     EAX, 1<br />        SBB     EBX, EBX<br />        AND     EBX, MATRIX_A<br />        XOR     EAX, EBX<br />        XOR     EAX, &#91;EDX&#93;<br />        MOV     &#91;ECX&#93;, EAX<br />        ADD     EDX, 4<br />        CMP     EDX, OFFSET MT + N*4<br />        JB      SHORT R70<br />        MOV     EAX, &#91;MT&#93;<br />        MOV     &#91;EDX&#93;, EAX ; copy begin of table to after end to simplify kk+1 wraparound<br />        MOV     EDX, OFFSET MT<br />R70&#58;    ADD     ECX, 4<br />        CMP     ECX, OFFSET MT + N*4<br />        JB      R60                  ; loop end        <br />        XOR     ECX, ECX<br />        MOV     &#91;MTI&#93;, ECX        <br />        POP     EBX<br />        JMP     R40        <br />        <br />TBRandom ENDP<br /><br /><br /><br /><br />; ######################################################################### <br />; <br />;                     Park Miller random number algorithm. <br />; <br />;                      Written by Jaymeson Trudgen &#40;NaN&#41; <br />;                   Optimized by Rickey Bowers Jr. &#40;bitRAKE&#41; <br />; <br />; ######################################################################### <br />.data <br />nrandom_seed dd 12345678 <br />; ######################################################################### <br />.code <br /><br />nrandom PROC base&#58;DWORD <br />    mov eax, nrandom_seed <br />    xor edx, edx <br />    mov ecx, 127773 <br />    div ecx <br />    mov ecx, eax <br />    mov eax, 16807 <br />    mul edx <br />    mov edx, ecx <br />    mov ecx, eax <br />    mov eax, 2836 <br />    mul edx <br />    sub ecx, eax <br />    xor edx, edx <br />    mov eax, ecx <br />    mov nrandom_seed, ecx <br />    .if base!=0<br />        div base <br />        mov eax, edx <br />    .else<br />        push eax<br />        CALL    TBRandom             ; random bits<br />        pop ebx<br />        xor ebx,eax<br />    .endif<br />    ret <br /><br />nrandom ENDP <br /><br />; ######################################################################### <br /></code></pre></div>
    <div class="meta">Posted on 2005-02-17 22:58:47 by Homer</div>
   </div>
   <div class="post" id="post-157138">
    <div class="subject"><a href="#post-157138">RandomGen</a></div>
    <div class="body">Interesting... I should dig up my old DirectX compare program to see how your new creation weighs...  <br /><br />To be honest, i have no idea what your talking about (spikes etc).  But a picture is worth a thousand words (hint hint) ;)<br /><br />Regards,<br />:NaN:</div>
    <div class="meta">Posted on 2005-02-17 23:23:17 by NaN</div>
   </div>
   <div class="post" id="post-157140">
    <div class="subject"><a href="#post-157140">RandomGen</a></div>
    <div class="body">Yes visually it's easy to see what I mean.<br />When I refer to &quot;core&quot; values, I mean that MOST of the values generated congregate around zero, which is very obvious when you begin applying min/max constraints to the generated series... the distribution is tighter around zero, with a lower probability of values approaching the threshholds.<br />When I refer to &quot;spikes&quot;, I mean that there are singularities - for certain values near the threshholds, the probability rises sharply.. certain values are generated more often than others near the threshholds.<br /><br />What we see under your randomgen alone with my 3D visualisation is a high density around zero, with density decreasing towards the threshholds, but with &quot;Artifacts&quot; in the mostly-empy outer region which have consistant values, ie are far from random.<br /><br />I'll take some screenies on Monday and post them (I'm away for the weekend), but yes by all means dig your 2D visualisation tool out and compare the results yourself.</div>
    <div class="meta">Posted on 2005-02-18 00:33:02 by Homer</div>
   </div>
   <div class="post" id="post-157142">
    <div class="subject"><a href="#post-157142">RandomGen</a></div>
    <div class="body">Regarding the Park-Miller and m32lib nrandom functions, <a target="_blank" href="http://www.masmforum.com/simple/index.php?topic=555.0">this thread</a> might be of interest.</div>
    <div class="meta">Posted on 2005-02-18 02:33:51 by Jibz</div>
   </div>
   <div class="post" id="post-157171">
    <div class="subject"><a href="#post-157171">RandomGen</a></div>
    <div class="body">Hmm I didnt realize it was this &quot;crappy&quot;...  I cant find my old DirectX test examples.  But i did find my origional source (before it was cleaned up).<br /><br />I know at the time i was using this in my Direct X visual test for developing paterns.  Again, I got a very even distribution of pixels and colors, resulting in an overall grey image with no noticable patterns.<br /><br />Here is the very first source (badly written, but it was 4 years ago ;) )<br /><pre><code>RAND32 MACRO base&#58;REQ<br />  ; Random number generator based on the Real time clock<br />  ; and the Park, Miller random number algorithm<br />  ;<br />  ; Coded by NaN for WIN32ASM<br />  ; May 5, 2001<br />  ; rev 2.<br /><br /><br />  push ecx<br />  push edx<br /><br />  ifndef __RAND_BY_NAN__<br />  __RAND_BY_NAN__ equ 1<br />  <br />     .data? <br />     NaNRand dd ?<br />     .code<br /><br />  db 0fh,31h <br />  shr eax, 2<br />  add eax, 1<br />  mov NaNRand, eax<br />  endif<br />  <br />  mov eax, NaNRand    <br />  mov edx,0<br />  mov ecx, 127773 ;q<br />  div ecx      ; eax == floor&#40; seed / q&#41;<br />               ; edx == remainder<br />  SWAP eax, edx<br />  push edx<br />  mov ecx, 16807<br />  mul ecx      ; eax = mul of remainder * a<br />  pop edx      ; edx == floor of seed/q<br />  <br />  SWAP eax, edx<br />  push edx<br />  mov ecx, 2836<br />  mul ecx<br />  pop edx      ; edx == mull of rem * a<br />               ; eax == mull of seed/q * r<br />               <br />  sub edx, eax<br />  mov eax, edx    <br />  mov NaNRand, eax ; save next seed <br />  mov ecx, base<br />  mov edx, 0<br />  div ecx<br />  mov eax, edx<br />  pop edx<br />  pop ecx<br />ENDM</code></pre><br /><br />Give it a test if you dont mind and tell me if its better or worse than the MASM32 package.  I've been taking it for granted the 'optomizations' had not operational effect on its quality.  Perhaps I was wrong to assume this?<br /><br />Regards,<br />:NaN:</div>
    <div class="meta">Posted on 2005-02-18 23:49:47 by NaN</div>
   </div>
   <div class="post" id="post-157210">
    <div class="subject"><a href="#post-157210">RandomGen</a></div>
    <div class="body">I've uploaded some screen shots to http://www.homer.ultrano.com/Upload/CombinedVersusNRand.rtf<br /><br />The upper shot shows the combined generators, the lower shows nrandom alone .. camera positions are not the same, and static images don't do justice but all the same.. <br /><br />What I didn't show is a shot of mersenne by itself. I didn't bother because this visualisation tool doesn't show up its poor distribution.</div>
    <div class="meta">Posted on 2005-02-20 01:41:28 by Homer</div>
   </div>
   <div class="post" id="post-157222">
    <div class="subject"><a href="#post-157222">RandomGen</a></div>
    <div class="body">I've re-uploaded the RTF :(</div>
    <div class="meta">Posted on 2005-02-20 07:38:31 by Homer</div>
   </div>
   <div class="post" id="post-157246">
    <div class="subject"><a href="#post-157246">RandomGen</a></div>
    <div class="body">Man, Thanks for the pic, but i have no idea which is which.. nor how it prooves anything.<br /><br />Big dots dont tell me much.. but perhaps im missing somthing.<br /><br />My test generator had hundreds single pixels, randomly gererated x, then y, then a color (out of 16).  The overall screen appeared to be static like with no observable patters.   It seems to shift around, vibrantly.  If you let your eyes go, it would give you a sorta over all greyish look.  Which was enough to satisfy me, as grey is the expected out come of a random distribution of all the colors in the spectrum (over a large sampled area such as the screen space).<br /><br />Thanks anyways...<br />Regards,<br />:NaN:</div>
    <div class="meta">Posted on 2005-02-20 22:03:32 by NaN</div>
   </div>
   <div class="post" id="post-157250">
    <div class="subject"><a href="#post-157250">RandomGen</a></div>
    <div class="body">evilhomer,<br /><br />i don't know how you are using them, but if you are happy to gather up a large amount, and read them from a file, for whatever purposes, have a look at:<br /><br />http://michaelsilk.blogspot.com/2004/10/article-really-random-numbers.html<br /><br />it's simply really, using &quot;real&quot; random sources from sites around the net to create a nice stream for you.<br /><br />the code is written in java, but is trivial to adapt to what you like.<br /><br />hope it helps.<br /><br />-- Michael</div>
    <div class="meta">Posted on 2005-02-21 05:49:26 by abc123</div>
   </div>
   <div class="post" id="post-160674">
    <div class="subject"><a href="#post-160674">Re: RandomGen</a></div>
    <div class="body">In my applications, I fetch &quot;real randoms&quot; from a web source , I hash the values together, then I ror it with the tick count, and use the result as my Seed for the generator code posted earlier.<br />I&#39;m trying hard to make sure the Seed is truly random, so then we don&#39;t have to worry about the properties of random generators quite as much (we can&#39;t predict the series anymore).<br /></div>
    <div class="meta">Posted on 2005-06-01 08:51:48 by Homer</div>
   </div>
   <div class="post" id="post-160675">
    <div class="subject"><a href="#post-160675">Re: RandomGen</a></div>
    <div class="body">Homer,<br /><br />Its been a while but I did some work on random sequence generation some time ago using a 256 pixel square pad and used a mouse manually and with a little care it produces reliable random number sequences that appear to pass the ENT random tests written years ago by John Walker. It takes a while to create a sequence of any size but it was no big deal to use a shorter sequence as a seed to create far larger sequences that also test up very well. Back then I used two seperate random generator, NaN&#39;s version and a floating point version reseeding each other in a loop.<br /><br />The testing showed the method to be as good as atomic decay recordings and similar real world sources.</div>
    <div class="meta">Posted on 2005-06-01 09:09:08 by hutch--</div>
   </div>
   <div class="post" id="post-179924">
    <div class="subject"><a href="#post-179924">Re: RandomGen</a></div>
    <div class="body">Considering the &quot;Park Miller&quot; algo, isn&#39;t it possible that it outputs zero ? In that case it would be very problematic because it would output zero in every next calls.<br /><br />EDIT : To be more explicit,&nbsp; if the result of &quot;sub ecx, eax&quot; is equal to zero, the seed &quot;nrandom_seed&quot; and thus, the result, would never vary and stay equal to zero...<br /><br /><pre><code>; #########################################################################<br />;<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Park Miller random number algorithm.<br />;<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Written by Jaymeson Trudgen (NaN)<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Optimized by Rickey Bowers Jr. (bitRAKE)<br />;<br />; #########################################################################<br /><br />&nbsp; &nbsp; &nbsp; .486&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; create 32 bit code<br />&nbsp; &nbsp; &nbsp; .model flat, stdcall&nbsp; &nbsp; &nbsp; ; 32 bit memory model<br />&nbsp; &nbsp; &nbsp; option casemap :none&nbsp; &nbsp; &nbsp; ; case sensitive<br /><br />&nbsp; &nbsp; .code<br /><br />; #########################################################################<br /><br />nrandom PROC base:DWORD<br /><br />&nbsp; &nbsp; mov eax, nrandom_seed<br /><br />&nbsp; &nbsp; xor edx, edx<br />&nbsp; &nbsp; mov ecx, 127773<br />&nbsp; &nbsp; div ecx<br />&nbsp; &nbsp; mov ecx, eax<br />&nbsp; &nbsp; mov eax, 16807<br />&nbsp; &nbsp; mul edx<br />&nbsp; &nbsp; mov edx, ecx<br />&nbsp; &nbsp; mov ecx, eax<br />&nbsp; &nbsp; mov eax, 2836<br />&nbsp; &nbsp; mul edx<br />&nbsp; &nbsp; sub ecx, eax&nbsp; &nbsp; &nbsp;  &lt;- could this be equal to ZERO ??????<br />&nbsp; &nbsp; xor edx, edx<br />&nbsp; &nbsp; mov eax, ecx<br />&nbsp; &nbsp; mov nrandom_seed, ecx<br />&nbsp; &nbsp; div base<br /><br />&nbsp; &nbsp; mov eax, edx<br />&nbsp; &nbsp; ret<br /><br />nrandom ENDP<br /><br />; #########################################################################<br /><br />nseed proc TheSeed:DWORD<br /><br />&nbsp; &nbsp; .data<br />&nbsp; &nbsp; &nbsp; nrandom_seed dd 12345678<br />&nbsp; &nbsp; .code<br /><br />&nbsp; &nbsp; mov eax, TheSeed<br />&nbsp; &nbsp; mov nrandom_seed, eax<br /><br />&nbsp; &nbsp; ret<br /><br />nseed endp<br /><br />; #########################################################################<br /><br />&nbsp; &nbsp; end</code></pre><br /><br /></div>
    <div class="meta">Posted on 2006-04-20 08:28:37 by Axial</div>
   </div>
   <div class="post" id="post-179926">
    <div class="subject"><a href="#post-179926">Re: RandomGen</a></div>
    <div class="body">Not at all.<br />I&#39;m only using Park-Miller to &quot;mutate the seed&quot;.<br />Even if the Park-Miller outputs NULL in a given iteration, its merely used as an input permutation for the mersenne matrix. </div>
    <div class="meta">Posted on 2006-04-20 09:01:39 by Homer</div>
   </div>
   <div class="post" id="post-179930">
    <div class="subject"><a href="#post-179930">Re: RandomGen</a></div>
    <div class="body">Hi Homer,<br />I agree but do you think that this equation is mathematically possible if initial SEED != 0 ?<br /><br /><pre><code>((SEED / 127773) * 2836) - ((SEED mod 127773) * 16807) = 0</code></pre><br /><br />PS : I did ask because my maths starts to get *really* crappy :lol:<br /></div>
    <div class="meta">Posted on 2006-04-20 09:27:59 by Axial</div>
   </div>
   <div class="post" id="post-179937">
    <div class="subject"><a href="#post-179937">Re: RandomGen</a></div>
    <div class="body">I suppose its mathematically possible, yes, although I didn&#39;t check your example.<br />The selection of the &quot;initial random seed&quot; is something I mention in the comments which accompany that sourcecode. I mention it as a potentially useful feature, not a potentially desastrous condition..<br />There&#39;s roughly a 1 in 4.3 billion chance that the same initial seed will be used, which will yield the same output series, regardless of the fact that I have a feedback mechanism in place.<br /><br />This belies the fact that even if the initial seed handed to the park-miller stage produces zero as the output seed which it feeds to the mersenne stage, zero is a perfectly legal seed for the mersenne algorithm, it&#39;s not a simple linear function like parkmiller is.<br /></div>
    <div class="meta">Posted on 2006-04-20 10:48:45 by Homer</div>
   </div>
   <div class="post" id="post-180056">
    <div class="subject"><a href="#post-180056">Re: RandomGen</a></div>
    <div class="body">If seed = 2^31-1<br /><br />you will get an output of 0. I wonder if that answer the qn.</div>
    <div class="meta">Posted on 2006-04-22 12:02:04 by roticv</div>
   </div>
   <div class="post" id="post-180142">
    <div class="subject"><a href="#post-180142">Re: RandomGen</a></div>
    <div class="body">You answered perfectly ! Thank you Rotciv ! ;)<br />But may I ask you how you did compute that and if your sure about the fact that 7fffffffh is the only seed that returns 0 ?</div>
    <div class="meta">Posted on 2006-04-25 11:07:32 by Axial</div>
   </div>
   <div class="post" id="post-180198">
    <div class="subject"><a href="#post-180198">Re: RandomGen</a></div>
    <div class="body">Sorry for the late reply...<br /><br />Based on your equation of <pre><code>((SEED / 127773) * 2836) - ((SEED mod 127773) * 16807) = 0</code></pre><br /><br />It looks like there is infinite number of solutions for SEED, but of course we have one constrict which is SEED must be 32bit. However, the answer to your question whether there are other solutions, I would say that I am not too sure. I need to do further testing to solve this question.<br /><br />Furthermore your equation is not exactly correct, as you fail to take note that in the algorithm we only use only the 32bit part of the product. <br /><br />So I think your equation should have been<br /><br /><pre><code>((SEED / 127773) * 2836) mod 2^32- ((SEED mod 127773) * 16807) mod 2^32 = 0</code></pre><br /><br />As to how I solve it, I started off with <br /><br /><pre><code><br />(SEED / 127773) * 2836 = (SEED mod 127773) * 16807<br /></code></pre><br />Looking at it carefully, the easiest solution is of course when<br /><br />it&#39;s 16807 * 2836 and hence you have simultaneous equations where<br /><br />SEED / 127773 = 16807<br /><br />and<br /><br />SEED mod 127773 = 2836<br /><br />Working it out SEED has to be 16807 * 127773 + 2836 which gives you 7fffffffh.</div>
    <div class="meta">Posted on 2006-04-28 07:53:44 by roticv</div>
   </div>
  </div>
 </body>
</html>