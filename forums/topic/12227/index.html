<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>First Linked List, feedback appreciated - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=12227" />
    <link rel="next" href="../?id=12227&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=12227">First Linked List, feedback appreciated</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=12227&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=12227&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="12227" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=12227&amp;page=2">&gt;</a><a href="../?id=12227&amp;page=2">&raquo;</a></form>   <div class="post" id="post-93957">
    <div class="subject"><a href="#post-93957">First Linked List, feedback appreciated</a></div>
    <div class="body">Hi, after several days of struggling, I've got a simple doubly linked list going. I know there's been several threads about linked list, but I still would feel very happy if somebody would be kind enough to give some comments or advice, if having time or feeling very kind :)<br /><br />Cause I'm very uncertain of several things in the code, and how I solved stuff :eek:<br />The list only accepts entries with values sized DWORD, and it's GetNext, GetPrevious functions, returns pointers to entry's values.<br />This is short description of how the list works ~~~<br /><br />The list's 'Create' function allocates a struct with some variables and structs necessary for operation:<br /><br />LISTINFO STRUCT<br />                pCurrent                  DWORD ?	; points to current entry<br />                pHeadDummy 	DWORD ?	; points to a dummy entry always first, always empty<br />                pTailDummy             DWORD ? ; points to a dummy entry always last, always empty<br />                pRemove                 DWORD ? ; if non-NULL points to a entry to be deleted due next call to list<br />                nrEntries                 DWORD ? ; entries in list<br />                hHeap                     DWORD ?	; handle to list's heap<br />LISTINFO ends<br /><br />At lists startup, two empty entries are created, headDummy and tailDummy, first and last in list, pointing to eachother. All entries pushed into<br />the list will be between these two. I thought this solved some problems which came up regarding functions GetNext and GetPrevious entries from list.<br /><br />hHeap is handle to heap created for the list at Creation. I'm not at all sure about the heapfunctions, this is first time I used them. I initialize the heap size to 4096 and HEAP_NO_SERIALIZE. It seems to work ok, it seem to work growing automatically beyond that. Pls feedback on this with heapmemory in the program if anybody can help. (I noticed a big speed boost when I implemented heapallocs instead of globalallocs btw)<br /><br />pRemove is a pointer handling removal of entires. It is always NULL unless user wanted to remove an entry, if user calls the Remove-function, the function sets this pointer to current Entry position, and makes the entries surrounding current entry point to each other. However the current is not Freed from the heap until a next call to a list-function which shifts position in the list. This is because the current position should stay at same point until moved - if erasing immediately, I have to shift current position forward or backward in the list, and this would be a problem cause I dont know in which direction the user is scanning the list.<br /><br />The 'Create' function returns a pointer to this struct to the creator of the list, and the program has to pass this pointer to the list everytime it calls any list-function, thus there can be several different lists at one time.<br /><br />The entries struct are like so:<br /><br />ENTRY STRUCT<br />    val                        DWORD ?	; value<br />    pPrevious             DWORD ?	; pointer to previous entry<br />    pNext                   DWORD ? ; pointer to next entry<br />ENTRY ENDS<br /><br />the functions for the list are not many, they are:<br /><br />List_Create          PROTO<br />List_AddEntry       PROTO :DWORD, :DWORD<br />List_Start             PROTO :DWORD<br />List_End               PROTO :DWORD<br />List_GetNext        PROTO :DWORD<br />List_GetPrevious  PROTO :DWORD<br />List_Remove        PROTO :DWORD<br />List_GetNrEntries PROTO :DWORD<br />List_IsEmpty        PROTO :DWORD<br />List_Clear            PROTO :DWORD<br />List_Destroy        PROTO :DWORD<br /><br />+ one internal to the list, List_CheckIfRemove, which is called from List_Start, List_End, List_GetNext, List_GetPrevious, to check if there<br />is a request from last call to list, to remove an entry after moving in position in list.<br /><br />---<br /><br />attach a zipped source files, there is included a tiny program to test the list too, just adds some 1000 entries, then removes some, and displays the resulting entries.</div>
    <div class="meta">Posted on 2003-04-07 12:24:52 by david</div>
   </div>
   <div class="post" id="post-93960">
    <div class="subject"><a href="#post-93960">First Linked List, feedback appreciated</a></div>
    <div class="body">iirc HEAP_NO_SERIALIZE makes it unsafe to use the heap multithreaded - if you aren't employing other synchronization, and you intend for this module to be reusable, you probably shouldn't add that flag. As for the speed bost compared to Global/LocalAlloc, try adding HEAP_ZERO_MEMORY flag to all allocations and see if it doesn't end up around the same speed (I still advise you to use Heap* functions though). Also, you might consider whether you want to create a new heap, or just GetProcessHeap() - or perhaps specify the heap at setup time. (main advantage of using a separate heap is you can nullify all allocations at once with HeapDestroy - this is a bad workaround for leaking code though ;-)). Just a couple friendly advices :)<br /><br />Oh, you might also want to consider some more &quot;advanced&quot; techniques, like allocating blocks of link nodes, instead of chaining each and every one. This will improve locality and reduce heap fragmentation, at the expense of requiring some more logic in insert+delete routines (and some overhead when doing this) - depends on the needs I suppose.</div>
    <div class="meta">Posted on 2003-04-07 12:33:22 by f0dder</div>
   </div>
   <div class="post" id="post-93971">
    <div class="subject"><a href="#post-93971">First Linked List, feedback appreciated</a></div>
    <div class="body">Thanks Fodder,<br />I replaced the HEAP_NO_SERIALIZE with what you suggested. It's similar speed after altering.<br />I'll have to think about the advanced techniques you mention about allocating blocks of memory and stuff,<br />cant figure that out at the moment, :eek: <br />You're right, :grin: at the moment I HeapFree() every entry from the heap, and in the 'Destroy' function I just free the whole Heap like you mention. <br /><br />Uploading the updated version</div>
    <div class="meta">Posted on 2003-04-07 13:24:57 by david</div>
   </div>
   <div class="post" id="post-93976">
    <div class="subject"><a href="#post-93976">First Linked List, feedback appreciated</a></div>
    <div class="body">HEAP_NO_SERIALIZE shouldn't have much of a speed hit (the thread synchronization primitives of win32 seem &quot;okay&quot;), but the presence of it might make the code multithreading unsafe.<br /><br />I'm a bit surprised you say speed didn't change - did you add HEAP_ZERO_MEMORY to all HeapAllocs?<br /><br />indeed you did :). Btw, you may want to make a &quot;MYHEAPFLAGS&quot; equ so you can easily change stuff arond.<br /></div>
    <div class="meta">Posted on 2003-04-07 13:29:31 by f0dder</div>
   </div>
   <div class="post" id="post-93982">
    <div class="subject"><a href="#post-93982">First Linked List, feedback appreciated</a></div>
    <div class="body">Here is the results, almost similar, shouldnt they be? :)<br /><br />cycle counts for 5 go's of a testprogram - HEAP_NO_SERIALIZE<br /><br />6092595264<br />5944934464<br />5862925564<br />7820800064<br />5820429464<br /><br />cycle counts for 5 go's of a testprogram - HEAP_ZERO_MEMORY<br /><br />5754265664<br />5881741264<br />6186497864<br />6383719664<br />5842448064<br /><br />(testprogram is similar to the one in attached file, only in C)</div>
    <div class="meta">Posted on 2003-04-07 13:41:48 by david</div>
   </div>
   <div class="post" id="post-93984">
    <div class="subject"><a href="#post-93984">First Linked List, feedback appreciated</a></div>
    <div class="body">hrm, the HEAP_ZERO_MEMORY probably wont matter too much for such small allocs anyway. but try timing it with some &quot;substantial&quot; block allocations (couple megs).</div>
    <div class="meta">Posted on 2003-04-07 13:48:11 by f0dder</div>
   </div>
   <div class="post" id="post-93998">
    <div class="subject"><a href="#post-93998">First Linked List, feedback appreciated</a></div>
    <div class="body">heh...yea! :confused: .. ... when I try for more massive amounts of data the one version returns negative result of cycles, must be cause of I'm using the c-type __i64, and it's signed :(, I'll get back to you with this when I rewritten the timing thing, I'll try tomorrow! :grin:</div>
    <div class="meta">Posted on 2003-04-07 15:08:31 by david</div>
   </div>
   <div class="post" id="post-94000">
    <div class="subject"><a href="#post-94000">First Linked List, feedback appreciated</a></div>
    <div class="body">just use a &quot;massive&quot; loop, and GetTickCount() :). And don't remember to Sleep(0) (give up remaning timeslice) just before timing. And if you want to overkill, boost hread+process priority to realtime (be VERY careful with that though ;-)).</div>
    <div class="meta">Posted on 2003-04-07 15:12:16 by f0dder</div>
   </div>
   <div class="post" id="post-94013">
    <div class="subject"><a href="#post-94013">First Linked List, feedback appreciated</a></div>
    <div class="body">I dont know exactly what your test routine looks like.  But from experience, I've found i had to program two tests in series, both with a large amount of retries to get an average time. <br /><br />The first test is a &quot;debouncing&quot; test simply to waste time, while the windows OS finishes its new process alocation (since you just started the exe).  Remeber this is a multithreaded OS so it still does parallelism even when you think its not ;).<br /><br />The second test was my actualy trust worthy test... and all others in sucession.  I would often get something like:<br /><br />300 cycles  &lt;&lt;-- &quot;Debounce&quot; this<br />200 cycles  &lt;&lt;-- as it has OS overhead involved as well.<br />30 cycles<br />35 cycles<br />32 cycles<br />33 cycles<br />28 cycles<br />etc. etc. etc</div>
    <div class="meta">Posted on 2003-04-07 16:23:06 by NaN</div>
   </div>
   <div class="post" id="post-94028">
    <div class="subject"><a href="#post-94028">First Linked List, feedback appreciated</a></div>
    <div class="body">I'm way too tired to code now, but here's what it looks like <br /><br />#include &lt;stdio.h&gt;<br />#include &lt;iostream.h&gt;<br />#include &quot;asmList.h&quot;<br />#include &quot;windows.h&quot;<br /><br />void* hList;<br /><br />__int64 GetTimeStamp()<br />{<br />	DWORD hi, lo;<br />	__asm<br />	{<br />		rdtsc<br />		mov hi, edx<br />		mov lo, eax<br />	}<br />	return (__int64)((hi&lt;&lt;32) | lo);<br />}<br /><br />int _cdecl main()<br />{<br /><br />	__int64 start=GetTimeStamp();<br /><br />	hList=List_Create();<br />	for(long i=0;i&lt;3000000;i++)	// add approximately 1 mb of entries (edit:==about 3mb)<br />	{<br />		List_AddEntry(hList, i);<br />	}<br /><br />	// Traverse the linked list and<br />	// remove all entries whose value cant by 2 without remainder<br /><br />	long* val;<br />	List_Start(hList);<br />	while(true)<br />	{<br />		val=List_GetNext(hList);<br />		if(!val)break;<br />		if((*val % 2)!=0)List_Remove(hList);<br />	}<br /><br />	List_Clear(hList);<br /><br />	__int64 end=GetTimeStamp()-start;<br /><br />	printf(&quot;total cycles %i64\n\n&quot;, end);<br /><br />  List_Destroy(hList);<br /><br /><br />	return 0;<br />}<br /><br />as always, thanks for your replies, I really appreciate it!!!!!!!!</div>
    <div class="meta">Posted on 2003-04-07 17:00:39 by david</div>
   </div>
   <div class="post" id="post-94036">
    <div class="subject"><a href="#post-94036">First Linked List, feedback appreciated</a></div>
    <div class="body">Here is an example of what im getting at:<br /><pre><code>.586<br />.model flat,stdcall<br />option casemap&#58;none<br />include \masm32\include\windows.inc<br />include \masm32\include\masm32.inc<br />include \masm32\include\dmacros.inc<br />include \masm32\include\_macros_.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\user32.inc<br />include \masm32\include\debug.inc<br /><br />includelib \masm32\lib\kernel32.lib<br />includelib \masm32\lib\user32.lib<br />includelib \masm32\lib\masm32.lib<br />includelib \masm32\lib\debug.lib<br /><br />TimeTest_ON macro <br />          db 0fh,31h <br />          push edx       ; push high<br />          push eax       ; push low<br />endm<br /><br />TimeTest_OFF macro <br />          db 0fh,31h <br />          pop ebx        ; pop low<br />          pop ecx        ; pop hight<br />          sub eax,ebx    ; diff low<br />          sbb edx,ecx    ; diff high<br />endm<br />     <br />.code<br />start&#58;<br />     push esi<br />     mov esi, 0<br />   .while esi &lt; 10<br />   <br />     TimeTest_ON<br />     mov ecx,100h<br />test2&#58;<br /><br />;Test code here!      <br />     mov eax, 100000<br />     @@&#58;<br />     dec eax<br />     jnz @B<br />;Test code here!<br />      <br />     dec ecx<br />     jne test2<br />     ;PrintHex eax, &quot;ANS&quot;<br />     TimeTest_OFF<br /><br />     shr eax,8<br />     PrintDec eax, &quot;AVERAGE CLOCKS&quot;<br />     <br />     inc esi<br />   .endw<br />     pop esi<br />     <br />Here&#58;<br />     <br />     call ExitProcess<br />end start</code></pre><br /><br />ANd the results:<pre><code>eax = 301466, AVERAGE CLOCKS &#40;D&#58;\masm32\JProject\ClockTst\fpu.asm, 69&#41;<br />eax = 205035, AVERAGE CLOCKS &#40;D&#58;\masm32\JProject\ClockTst\fpu.asm, 69&#41;<br />eax = 219046, AVERAGE CLOCKS &#40;D&#58;\masm32\JProject\ClockTst\fpu.asm, 69&#41;<br />eax = 210533, AVERAGE CLOCKS &#40;D&#58;\masm32\JProject\ClockTst\fpu.asm, 69&#41;<br />eax = 203551, AVERAGE CLOCKS &#40;D&#58;\masm32\JProject\ClockTst\fpu.asm, 69&#41;<br />eax = 285120, AVERAGE CLOCKS &#40;D&#58;\masm32\JProject\ClockTst\fpu.asm, 69&#41;<br />eax = 209213, AVERAGE CLOCKS &#40;D&#58;\masm32\JProject\ClockTst\fpu.asm, 69&#41;<br />eax = 208310, AVERAGE CLOCKS &#40;D&#58;\masm32\JProject\ClockTst\fpu.asm, 69&#41;<br />eax = 208919, AVERAGE CLOCKS &#40;D&#58;\masm32\JProject\ClockTst\fpu.asm, 69&#41;<br />eax = 204437, AVERAGE CLOCKS &#40;D&#58;\masm32\JProject\ClockTst\fpu.asm, 69&#41;</code></pre><br /><br />See how the first = 150% longer than the rest.  The process start up can not be trusted.<br /><br />:NaN:</div>
    <div class="meta">Posted on 2003-04-07 17:24:53 by NaN</div>
   </div>
   <div class="post" id="post-94142">
    <div class="subject"><a href="#post-94142">First Linked List, feedback appreciated</a></div>
    <div class="body">NaN, why the &quot;db&quot; form instead of rdtsc?<br /><br />Do Sleep(0) before your actual test, to give up your remainder timeslice (and get a new, fresh timeslice just before the test).<br /><br />Pretouch any code pages used in the test to make sure they're paged in (this is one of the few occasions where EXE packing has a benefit, as it will make sure all pages are paged in).<br /><br />If you time algorithms that use dynamically allocated memory (that is, time the algorithms, not the allocation overheap), be sure to specify the HEAP_ZERO_MEMORY flag, as this also ensures pages are both reserved *AND* committed.<br /><br />Setting thread+process priority to realtime will give more correct results, but if your process loops forever you risk taking the rest of the system down with you (even on NT - but of course it requires privileges to raise process priority on NT).</div>
    <div class="meta">Posted on 2003-04-08 01:46:56 by f0dder</div>
   </div>
   <div class="post" id="post-94261">
    <div class="subject"><a href="#post-94261">First Linked List, feedback appreciated</a></div>
    <div class="body">Thanks for the tips, I wrote a new speed-test, I did something completely wrong before, totaly incorrect results.<br />This is new my version:<br /><br /><pre><code><br />.586<br />.model flat, stdcall<br />option casemap&#58;none<br /><br />include 	\masm32\include\windows.inc<br />include 	\masm32\include\user32.inc<br />include 	\masm32\include\kernel32.inc<br />include	asmList.inc<br />includelib	\masm32\lib\user32.lib<br />includelib	\masm32\lib\kernel32.lib<br /><br />.const<br /><br />NRTESTS equ 5 ; five test-runs<br /><br />.data<br /><br />bigNoHi dd 0<br />bigNoLo dd 6<br /><br />szAppName db &quot;speedTest&quot;,0<br />szResult db &quot;test nr&#58;%lu&#58; Cycles&#58;%I64d&quot;,13,10,0<br />szError db &quot;Error creating list&quot;,0<br />szFileName db &quot;SpeedTest-Results.txt&quot;,0<br />log db 1024 dup &#40;0&#41;<br /><br />.data?<br /><br />buffer db 256 dup &#40;?&#41;<br />timeStartHi dd ?<br />timeStartLo dd ?<br />iter dd ?<br />hFile dd ?<br /><br />.code<br /><br />start&#58;<br /><br />xor eax, eax<br />mov iter, eax<br /><br />rdtsc<br />mov timeStartHi, edx<br />mov timeStartLo, eax<br /><br />; --- test code begins ---<br /><br />invoke Sleep, 0<br /><br />; TEST CODE GOES HERE<br /><br />; --- test code ends ---<br /><br />rdtsc<br />clc<br />sub eax, timeStartLo ; total time for the test=timeEnd-timeStart<br />sbb edx, timeStartHi<br /><br />; ---- print the result and do more tests till done -----<br /><br />invoke wsprintf, ADDR buffer, ADDR szResult, iter, eax, edx  ; qword has to be pushed lodword, hidword order I think<br />invoke lstrcat, ADDR log, ADDR buffer ; add the result to textlog<br />invoke MessageBox, NULL,  ADDR buffer, ADDR szAppName, MB_OK<br /><br />inc iter<br />cmp iter, NRTESTS   ; do NRTESTS number of tests<br />jnz _doTest<br /><br />; all done, save textlog to disk and quit.<br /><br />invoke CreateFile, ADDR szFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL<br />mov hFile, eax<br />invoke lstrlen, ADDR log<br />invoke WriteFile, hFile, ADDR log, eax, ADDR iter, NULL<br />invoke CloseHandle, hFile<br /><br />invoke ExitProcess, 0<br /><br />_error&#58;<br />invoke MessageBox, NULL, szAppName, szError, MB_OK or MB_ICONERROR<br />invoke ExitProcess, 0<br /><br />end start<br /><br /></code></pre><br /><br />The result for the test became a little weird, that's why I wonder if something is still weird in this test code, look:<br /><br />HEAP_NO_SERIALIZE<br />test nr:0: Cycles:196293503<br />test nr:1: Cycles:1152612220<br />test nr:2: Cycles:1962245699<br />test nr:3: Cycles:2708017288<br />test nr:4: Cycles:3438762689<br /><br />HEAP_ZERO_MEMORY<br />test nr:0: Cycles:292842613<br />test nr:1: Cycles:1889110993<br />test nr:2: Cycles:3431464033<br />test nr:3: Cycles:4331828929<br />test nr:4: Cycles:5226363817<br /><br />(the testcode is push 500000*12bytes of data, and then scans through the whole list.)<br /><br />First thing, HEAP_NO_SERIALIZE seems faster, which it shouldn't be.<br />Then there's the test 0 in the results which is always one digit smaller everytime, everytime I run. Weird.<br /><br />attached these tests too</div>
    <div class="meta">Posted on 2003-04-08 08:29:08 by david</div>
   </div>
   <div class="post" id="post-94264">
    <div class="subject"><a href="#post-94264">First Linked List, feedback appreciated</a></div>
    <div class="body">Sleep(0) should be done _before_ rdtsc :)<br /><br />oh, and the format specifier used in the EXEs must be wrong ^_^</div>
    <div class="meta">Posted on 2003-04-08 08:36:33 by f0dder</div>
   </div>
   <div class="post" id="post-94445">
    <div class="subject"><a href="#post-94445">First Linked List, feedback appreciated</a></div>
    <div class="body">:grin: stupid me!<br /><br />Oh, the format, you mean the comments of the amount of data pushed in the list? It's DWORDs pushed, but I just meant that the memory allocated totally, if one adds the structs-the liftentries with next/previous-pointers to each DWORD pushed in the list, my mistake.<br /><br />edit: aahh, found what's wrong, I never read a new start time with rdtsc when doing the more tests in the loop, I must be idiot. now it works! :)</div>
    <div class="meta">Posted on 2003-04-08 16:21:14 by david</div>
   </div>
   <div class="post" id="post-94446">
    <div class="subject"><a href="#post-94446">First Linked List, feedback appreciated</a></div>
    <div class="body">nah, I mean the msgbox popping up with &quot;l64d&quot; or similar :) (ie, wrong format string used for wsprintf or whatever)</div>
    <div class="meta">Posted on 2003-04-08 16:22:23 by f0dder</div>
   </div>
   <div class="post" id="post-94973">
    <div class="subject"><a href="#post-94973">First Linked List, feedback appreciated</a></div>
    <div class="body">yezzzzz....:tongue: It should be %I64d .. I fixed it now.. thanks.<br /><br />Hmm...I'm adding Append and Prepend functions, to push value into front of list, and push value into back of list,<br />but I'm not really sure what's normally considered back and front of a linked list? :confused: <br /><br />I have my head dummy entry, and tail dummy entry, and think of them as to the left and right.<br />If I APPEND stuff into the list, it goes into the leftmost spot, after head dummy.<br />If I PREPEND stuff into the list, it goes into the rightmost spot, preceeding the tail-dummy.<br />I see the left side as front, and right side as back.<br /><br />List after appending values 1, 2 and 3, in that order, into  the front<br /><br />[ headdummy ] [ 3 ] [ 2 ] [ 1 ] [ tailDummy ]<br /><br />-------|----------------------------|--------------<br />----front--------------------------back------<br /><br />If I would prepend values 1, 2 and 3, in that order, into  the back, list would be<br /><br />[ headdummy ] [ 1 ] [ 2 ] [ 3 ] [ tailDummy ]<br /><br />------|-----------------------------|-----<br />----front--------------------------back--<br /><br /><br />Is front and back normally considered the other way around, or is this right?</div>
    <div class="meta">Posted on 2003-04-09 22:46:43 by david</div>
   </div>
   <div class="post" id="post-94979">
    <div class="subject"><a href="#post-94979">First Linked List, feedback appreciated</a></div>
    <div class="body">Prepend means to put in front.<br /><br />For example, many C compilers <strong>prepend</strong> an underscore (&quot;_&quot;) to a function name before passing it on to the linker. So what you define as <strong>Sleep</strong> will be given to the linker as <strong>_Sleep</strong>.<br /><br />An appendix of a book is placed in the back.<br /><br />By convention, the &quot;leftmost&quot; item is the &quot;first&quot; item. This corresponds with LISP notation.</div>
    <div class="meta">Posted on 2003-04-09 23:16:33 by tenkey</div>
   </div>
   <div class="post" id="post-95023">
    <div class="subject"><a href="#post-95023">First Linked List, feedback appreciated</a></div>
    <div class="body">Ah, thanks tenkey, my idea of start and end of list is right,<br />but I my understanding of words append and prepend is wrong.<br />Not too bad, I only have to change the names of my append &amp; prepend functions! :) <br /><br />I try a List_GetPos function now, which returns a pointer to the value in the list at a specified position.<br />It is super-slow method. But I can't think of better one, how could one else do???<br /><br />Like this:<br />If list has 10 entries, and variable 'nrEntriesInList' is 10,<br />the variable 'wantedPos' is the position of the entry whose value function should return, and the positions in list are specified as 0-9:<br /><br />(pseudo-pseudo code: )<br /><br />if ( wantedPos &gt;= nrEntriesInList ) return NULL<br />if (wantedPos &lt; nrEntriesInList/2 ) step forward from headDummy (wantedPos+1) times and return the value;<br />else <br />step backward from tailDummy (nrEntriesInList-wantedPos) times and return the value.<br /><br />This way I dont have to step forward from start 10 times if I want position 9 of 10 total for instance...but it still so slow,<br />what if list has super-many entries? would take forever to find entry 10000 of 20000 total entries. :(</div>
    <div class="meta">Posted on 2003-04-10 01:24:23 by david</div>
   </div>
   <div class="post" id="post-95040">
    <div class="subject"><a href="#post-95040">First Linked List, feedback appreciated</a></div>
    <div class="body">that's one of the bad properties about regular linked lists - it's not particularly fast to get an item from an index number. Again, linking &quot;blocks&quot; of nodes would make this faster, and again at the expense that arbitrary insertion/deletion would be slowed a lot.<br /><br />Btw, that _is_ a C=64 in your avatar, isn't it?</div>
    <div class="meta">Posted on 2003-04-10 02:18:13 by f0dder</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=12227&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=12227&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="12227" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=12227&amp;page=2">&gt;</a><a href="../?id=12227&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>