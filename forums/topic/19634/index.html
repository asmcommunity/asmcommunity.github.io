<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>SceneGraph support classes - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19634" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=19634">SceneGraph support classes</a></p>
   <div class="post" id="post-151127">
    <div class="subject"><a href="#post-151127">SceneGraph support classes</a></div>
    <div class="body">Moderators .. please re-enable .INC file extension :)<br /><br /><pre><code><br /><br /><br /><br />;==================================================================<br />;This is a BaseClass which implements a Node Hierarchy.<br />;No support for inserting or unlinking objects.<br />;Don't use the AppendSibling method unless you are seriously demented.<br />;It's a PRIVATE METHOD meant only to be called by AddChild method.<br />;As such, I have removed it from the Class Definition, so it won't waste space<br />;appearing in the vtable of object instances.<br /><br /><br />;AddChild    ;Adds given object as Child of THIS object<br />                  ;If THIS.Child exists, then &#40;icall this.AppendSibling, pNewObject&#41;<br />                  ;Else, add as THIS.Child == given object<br /><br />;AppendSibling ; Don't call this yourself - it's called by AddChild.<br />                        ; Adds given object as a Sibling of the Child of THIS object.<br />                        ; Should only be called where THIS.Child exists &#40;of course&#41;.<br />                        ; If THIS.Child.LastSibling exists, then add as YoungerSibling of THIS.Child.LastSibling <br />                        ; Else, add as THIS.Child.YoungerSibling == given object<br />                        ; Either Way, set THIS.Child.LastSibling == given object<br />;==================================================================<br /><br />class TreeNode, ,C++ compatible<br />    void AddChild&#58;pNewChild             ;Links a new object to the Tree, somewhere &quot;below&quot; THIS object &#40;read notes&#41;<br />    void DelTree                                 ;Deletes THIS object, plus anything &quot;below&quot; it in the Tree Hierarchy<br />    void SetName&#58;pName<br />    long pParent ;Pointer to the previous node <br />    long pChild   ;Pointer to the next node<br />    long pOlderSibling<br />    long pYoungerSibling<br />    long pLastSibling<br />    long pName<br />    long dwChildren                           ;&lt;--#Children owned by THIS object &#40;Child+#Siblings&#41;<br />    long dwNodeType<br />endclass <br /><br />TreeNode_TreeNode proc<br />    xor eax,eax<br />    mov &#91;ecx&#93;.TreeNode.dwChildren,eax<br />    mov &#91;ecx&#93;.TreeNode.pParent,eax<br />    mov &#91;ecx&#93;.TreeNode.pChild ,eax<br />    mov &#91;ecx&#93;.TreeNode.pOlderSibling,eax<br />    mov &#91;ecx&#93;.TreeNode.pYoungerSibling,eax<br />    mov &#91;ecx&#93;.TreeNode.pLastSibling, eax<br />    mov &#91;ecx&#93;.TreeNode.pName, eax<br />    mov &#91;ecx&#93;.TreeNode.dwNodeType, eax<br />    ret<br />TreeNode_TreeNode endp<br /><br />TreeNode_SetName proc pName<br />    invoke AllocString, pName         ;&lt;-- allocates heapmem for namestring, copies string into it, returns ptr<br />    mov &#91;ecx&#93;.TreeNode.pName,eax<br />    ret<br />TreeNode_SetName endp<br /><br />TreeNode_$TreeNode proc<br />    .if &#91;ecx&#93;.TreeNode.pName!=NULL<br />        free &#91;ecx&#93;.TreeNode.pName<br />    .endif<br />    .if &#91;ecx&#93;.TreeNode.pParent!=NULL<br />        mov ebx,&#91;ecx&#93;.TreeNode.pParent<br />        dec &#91;ebx&#93;.TreeNode.dwChildren<br />    .endif<br />    ret<br />TreeNode_$TreeNode endp<br /><br />;==================================================================<br />; *** PRIVATE METHOD - DELIBERATELY NOT DEFINED IN CLASSDEFINITION ***<br />;==================================================================<br />TreeNode_AppendSibling proc pNewSibling<br />    mov ebx, &#91;ecx&#93;.TreeNode.pChild                 ;&lt;--ebx=ptr to my child<br />    mov eax, &#91;ebx&#93;.TreeNode.pLastSibling       ;&lt;--eax=ptr to my child's LastSibling<br />    mov ecx,pNewSibling<br />    .if eax==NULL                                                   ;If my child has no Siblings yet<br />        mov &#91;ebx&#93;.TreeNode.pYoungerSibling, ecx ;Noting that we leave OlderSibling of  my child NULLed<br />        Message &quot;Added node as First Sibling of Child&quot;<br />    .else                                                                     ;But if we have one or more Siblings already<br />        mov &#91;eax&#93;.TreeNode.pYoungerSibling, ecx ;&lt;-- write new object to end of sibs<br />        mov &#91;ecx&#93;.TreeNode.pOlderSibling, eax      ;&lt;-- inform new object of its older sib<br />        Message &quot;Added node as Last Sibling of Child&quot;<br />    .endif<br />    mov &#91;ebx&#93;.TreeNode.pLastSibling, ecx        ;&lt;-- set Parent.Child of new last sib<br />    ret<br />TreeNode_AppendSibling endp<br />;==================================================================<br />;==================================================================<br /><br />TreeNode_AddChild proc pNewChild<br />    mov ebx,pNewChild<br />    mov &#91;ebx&#93;.TreeNode.pParent, ecx<br />    .if &#91;ecx&#93;.TreeNode.pChild!=NULL                                 ;If there's already atleast one child<br />;        icall ecx, TreeNode, AppendSibling,  pNewChild    ;Add Child to Parent.Child &#40;or end of its sibs&#41;<br />         push ecx<br />         invoke TreeNode_AppendSibling, pNewChild ;&lt;-- *** CALL PRIVATE METHOD AS PROC ***<br />    .else                                                                            ;Otherwise if theres no children at all<br />        mov &#91;ecx&#93;.TreeNode.pChild, ebx                            ;Add Child to Parent<br />        Message &quot;Added node as First Child&quot;<br />    .endif<br />    inc &#91;ecx&#93;.TreeNode.dwChildren<br />    ret<br />TreeNode_AddChild endp<br /><br />TreeNode_DelTree proc <br />    .if &#91;ecx&#93;.TreeNode.pYoungerSibling!=NULL<br />        icall  &#91;ecx&#93;.TreeNode.pYoungerSibling, TreeNode, DelTree;&lt;-- walk the Sibling chain &#40;call self on Sibling&#41;<br />    .endif<br />    .if &#91;ecx&#93;.TreeNode.pChild!=NULL<br />        icall  &#91;ecx&#93;.TreeNode.pChild, TreeNode, DelTree                   ;&lt;-- walk the Child chain &#40;call self on Child&#41;<br />    .endif<br />    delete ecx                                                                                   ;&lt;-- delete THIS object<br />    ret<br />TreeNode_DelTree endp<br /><br /></code></pre></div>
    <div class="meta">Posted on 2004-10-09 01:57:15 by Homer</div>
   </div>
   <div class="post" id="post-151128">
    <div class="subject"><a href="#post-151128">SceneGraph support classes</a></div>
    <div class="body"><pre><code><br />;===============================================<br />;This class implements a SwitchNode.<br />;This Node, like all Nodes, derives from the TreeNode baseclass.<br />;The job of this Node is to act as a fork in the road,<br />;by maintaining an Active Child from among its Children &#40;or elsewhere!&#41;<br />;which can be changed anytime &#40;for example by another Node&#41;.<br />;This causes the Tree Walker to walk the path we choose at runtime.<br />;===============================================<br />class SwitchNode,TreeNode,C++ compatible<br />    virtual GetTreePath<br />    virtual SetTreePath&#58;pNewActiveChild<br />    long pActiveChild        <br />endclass<br />;===============================================<br />SwitchNode_SwitchNode proc<br />    xor eax,eax<br />    mov &#91;ecx&#93;.SwitchNode.pActiveChild, eax<br />    mov &#91;ecx&#93;.SwitchNode.dwNodeType, NODETYPE_SWITCH<br />    ret<br />SwitchNode_SwitchNode endp<br />;===============================================<br />SwitchNode_$SwitchNode proc<br />    ret<br />SwitchNode_$SwitchNode endp<br />;===============================================<br />SwitchNode_SetTreePath proc pNewActiveChild<br />    m2m &#91;ecx&#93;.SwitchNode.pActiveChild, pNewActiveChild<br />    ret<br />SwitchNode_SetTreePath endp<br />;===============================================<br />SwitchNode_GetTreePath proc<br />    return &#91;ecx&#93;.SwitchNode.pActiveChild<br />SwitchNode_GetTreePath endp<br /><br /></code></pre></div>
    <div class="meta">Posted on 2004-10-09 01:58:24 by Homer</div>
   </div>
   <div class="post" id="post-151140">
    <div class="subject"><a href="#post-151140">SceneGraph support classes</a></div>
    <div class="body"><pre><code><br />TreeNode_WalkTree proc<br />$Message &quot;CurrentNode=%s&quot;,&#91;ecx&#93;.TreeNode.pName<br />.if &#91;ecx&#93;.TreeNode.pChild!=0                                            ;Try to walk Child of current node<br />    icall &#91;ecx&#93;.TreeNode.pChild, TreeNode, WalkTree<br />.endif<br />.if &#91;ecx&#93;.TreeNode.pYoungerSibling!=0                           ;Try to walk Siblings of current node<br />    icall &#91;ecx&#93;.TreeNode.pYoungerSibling, TreeNode, WalkTree<br />.endif<br />ret<br />TreeNode_WalkTree endp<br /></code></pre></div>
    <div class="meta">Posted on 2004-10-09 13:47:21 by Homer</div>
   </div>
  </div>
 </body>
</html>