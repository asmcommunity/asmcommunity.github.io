<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>masm proc - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16348" />
  <link rel="prev" href="../?id=16348&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=16348">masm proc</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=16348&amp;page=1" style="">&laquo;</a><a href="../?id=16348&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="16348" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-127147">
    <div class="subject"><a href="#post-127147">roticv</a></div>
    <div class="body">hi! roticv  i think i need to read  about  mod 01  and so on , but can you try to explane it ?<br /><br />thanks.</div>
    <div class="meta">Posted on 2003-12-09 12:08:51 by Nguga</div>
   </div>
   <div class="post" id="post-127148">
    <div class="subject"><a href="#post-127148">Re: mmmm...</a></div>
    <div class="body"><div class="quote"><em>Originally posted by Nguga </em><br />i come to this conclusion , that   LOCALS  make the code much more bigger then not using locals.<br /><br /><br /><br />after this i ask YOU all why use LOCALS ???<br /><br />well i can code enterely without LOCALS  , and is much more easy to do it<br />becouse i can use that everywere and can make new ones if i always need ...<br />so i do not see the point of using them :) </div><br /><br />First of all, the only savings you get by not zeroing out the global object only happens if you call this code exactly once. If you call the procedure more than once, you'll need to zero out that global variable, too. So you don't save much there by using globals.<br /><br />Also, note that global/static addresses are going to always be four-bytes long when encoded into an instruction. The first 128 bytes of local/automatic variables will only require a one-byte displacement. So if you reference the variables a large number of times, you can organize your local declarations so that most instructions only require a one-byte displacement, thus being shorter.  <br /><br />Locals and globals have completely different semantics. For example, you cannot write reentrant code using global variables. Likewise, when using static object (globals), the variables consume memory the entire lifetime of the application. Sure, your *code* is smaller, but the total amount of memory the program consumes is actually *larger* when using global/static variables (i.e., those bytes of data could just as easily have held a fair number of instructions).<br /><br />Generally, you should use the variable type (static/global, automatic/local) based on the *semantics* of the storage and not worry as much about the few extra bytes of instructions needed to access one data type versus the other.<br /><br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-12-09 13:11:07 by rhyde</div>
   </div>
   <div class="post" id="post-127165">
    <div class="subject"><a href="#post-127165">masm proc</a></div>
    <div class="body">I only whant to clarify one thing with that say hutch--<br /><div class="quote">or a LOCAL value that is created on the stack at the beginning of the procedure and destroyed at the exit of the procedure.<br /></div><br /><br />I dont understand destroyed, I think in two things, zeroize this locals before the return (this is a clean up of locals, you are not destroying nothing ;) ), or only return and this will only change the way you whant to access that locals, in fact, you can access esp, esp+4, esp+8, esp+(4*numberArgument), for the arguments, from the last to the first, the next is esp+(4*n)+(4) for the addres caller, and esp+(4*n)+(4)+(4) for the address of ebp, then you can access the locals at esp+(4*n)+(4)+(4)+(4*nL) where nL is the local to be accessed, if is a dword..., for example, this structure or representation in the stack:<br /><div class="quote"><br />      : DWORD ebp + 12<br />      : DWORD ebp + 8<br />: DWORD ebp + 4<br /> : DWORD ebp<br />-----   Base Pointer    -----<br />             : DWORD ebp - 4<br />             : DWORD ebp - 8<br />             : DWORD ebp - 12<br />-----  &quot;Top&quot; of Stack   -----<br /></div><br /><br />when you mov esp, ebp and pop ebp and ret 8 you can still access the value of the locals (and the arguments passed, etc) with esp+n, if they are not cleaned (not destroyed) before the return.. but shure.. that is tricky :D.<br /><br />Nice day or night.</div>
    <div class="meta">Posted on 2003-12-09 15:58:37 by rea</div>
   </div>
   <div class="post" id="post-127168">
    <div class="subject"><a href="#post-127168">masm proc</a></div>
    <div class="body">for nguga, you can do two things, modify a little your macro and for each name of local, define a <br /><br /><div class="quote"><br />%macro stack 1-*<br />.....<br />;======<br />;despues de -&gt;defenir_os_arg_locais %2,%1 ; chamar defenir local arg<br />%define %2_locebp somasizelocal <br />;======<br />.........<br /></div><br /><br /><br />and make a new macro for invoke, that let you check this, , for example...<br /><br /><pre><code><br />%macro invoke2ebp<br />........<br />%rep n ;el loop donde se hace el push de los argumentos...<br />%ifdef %1_locebp ;this<br />push ebp ; will do<br />sub dword&#91;esp&#93;, %1_locebp ;the work<br /><br />%elif .... ;here come the normal push &#40;for statics and others not locals&#41;<br />...<br />;the normal pushes...<br />...<br />stdpush ..<br />rotate.. and such things....<br />%endif<br />...<br />%endrep<br />....<br />%endmacro<br /></code></pre><br /><br />hope you get the idea, and you can use a 'automatic' way of simulate what make the other call ....<br /><br /><br />Nice day or night.</div>
    <div class="meta">Posted on 2003-12-09 16:14:33 by rea</div>
   </div>
   <div class="post" id="post-127183">
    <div class="subject"><a href="#post-127183">no thanks :)</a></div>
    <div class="body">hi all ! [[ ]]<br /><br /><br /><br />i will not make any kind of macro like MASM has  becouse i want to mantain<br />the logic of assembly not like the invoke macro that MASM has that is ilogical.<br /><br /><br /><br />as far we have seen here this proc made in MASM:<br /><br /><br /><br />TestProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM<br /><br />LOCAL opf:OPENFILENAMEA<br /><br />mov opf.lStructSize, SIZEOF OPENFILENAME <br />invoke GetOpenFileNameA,addr opf<br /><br />xor eax,eax<br />ret<br />TestProc endp<br /><br /><br /><br /><br />the output assembly generated is this for the :<br /><br />INVOKE GetOpenFileNameA,addr opf <br /><br /><br />.text:00401125 lea eax, <br />.text:00401128 push eax ; LPOPENFILENAMEA<br />.text:00401129 call GetOpenFileNameA<br /><br /><br /><br />that is ilogical for me , i rather prefer  this i got in NASM NAGOA<br /><br />what i code is real .<br /><br />proc          SaveBitmap<br />                <br />                stack opf,OPENFILENAME_size,buffer1,1020  <br />                sectiondata<br />                filter_bmp  db  &quot;*.bmp&quot;,0,&quot;*.bmp&quot;,0,0<br />                sectioncode<br /><br />                lea    eax,<br />                call	RtlZeroMemory,eax,OPENFILENAME_size<br />        	mov	dword ,OPENFILENAME_size<br />		mov	dword , 1020<br />		mov	dword ,filter_bmp<br />                push ebx<br />                lea    ebx,<br />                call	RtlZeroMemory,ebx,1020<br />                mov	dword ,ebx<br />                pop ebx<br />                lea    eax,<br />                call	GetSaveFileNameA,eax           <br />                cmp	eax, 0<br />		jz	.goOut<br />                call   SendMessageA,, WM_CAP_GRAB_FRAME, 0, 0<br />                call   SendMessageA,, WM_CAP_SAVEDIB,0,<br />		call   SendMessageA,, WM_CAP_SET_PREVIEW,TRUE, 0<br />                .goOut<br /><br />endproc<br /><br /><br /><br /><br /><br />then i could use the other aproach  of avoidind using  lea  .<br /><br /><br /><br /><br /><br /><br /><br /><br />proc          SaveBitmap<br />                <br />                stack opf,OPENFILENAME_size,buffer1,1020  <br />                sectiondata<br />                filter_bmp  db  &quot;*.bmp&quot;,0,&quot;*.bmp&quot;,0,0<br />                sectioncode<br /><br />                sub   ebp,OPENFILENAME_size                       ; make ebp points to opf<br />                call	RtlZeroMemory,ebp,OPENFILENAME_size  ; clean  opf<br />                add   ebp,OPENFILENAME_size                       ; let ebp be ebp<br />        	mov	dword ,OPENFILENAME_size<br />		mov	dword , 1020<br />		mov	dword ,filter_bmp<br />                sub   ebp,OPENFILENAME_size+1020                ; make ebp points to buffer1 size<br />                call	RtlZeroMemory,ebp,1020                       ; clean buffer1<br />                mov   eax,ebp<br />                add   ebp,OPENFILENAME_size+1020                ; make ebp be ebp<br />                mov	dword ,eax<br />                sub   ebp,OPENFILENAME_size                       ; make ebp  point to opf<br />                call	GetSaveFileNameA,ebp                        ; open dialog save of opf <br />                add   ebp,OPENFILENAME_size                      ; let ebp be ebp             <br />                cmp	eax, 0<br />		jz	.goOut<br />                call   SendMessageA,, WM_CAP_GRAB_FRAME, 0, 0<br />                call   SendMessageA,, WM_CAP_SAVEDIB,0,<br />		call   SendMessageA,, WM_CAP_SET_PREVIEW,TRUE, 0<br />                .goOut<br /><br />endproc<br /><br /><br /><br /><br /><br /><br /><br /><br />so the invoke macro of NAGOA NASM is for me more logical .</div>
    <div class="meta">Posted on 2003-12-09 18:15:51 by Nguga</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=16348&amp;page=1" style="">&laquo;</a><a href="../?id=16348&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="16348" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>