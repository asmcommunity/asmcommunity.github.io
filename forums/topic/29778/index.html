<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>the unicode or ansi strings - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29778" />
    <link rel="next" href="../?id=29778&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29778">the unicode or ansi strings</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29778&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29778&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29778" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29778&amp;page=2">&gt;</a><a href="../?id=29778&amp;page=2">&raquo;</a></form>   <div class="post" id="post-210349">
    <div class="subject"><a href="#post-210349">the unicode or ansi strings</a></div>
    <div class="body">how do i recognise the unicode or ansi strings in a buffer ?</div>
    <div class="meta">Posted on 2010-01-23 04:16:10 by dcskm4200</div>
   </div>
   <div class="post" id="post-210350">
    <div class="subject"><a href="#post-210350">Re: the unicode or ansi strings</a></div>
    <div class="body">unicode characters obey a certain binary encoding, its the best you can do</div>
    <div class="meta">Posted on 2010-01-23 05:58:28 by Homer</div>
   </div>
   <div class="post" id="post-210352">
    <div class="subject"><a href="#post-210352">Re: the unicode or ansi strings</a></div>
    <div class="body">Homer, maybe you should rename your &quot;binary exercise #2&quot; thread to something more descriptive?</div>
    <div class="meta">Posted on 2010-01-23 12:42:34 by r22</div>
   </div>
   <div class="post" id="post-210369">
    <div class="subject"><a href="#post-210369">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote">how do i recognise the unicode or ansi strings in a buffer ?</div>&quot;That depends&quot;.<br /><br />First, <em>unicode</em> is a pretty vague term - there&#039;s several different encodings... detecting utf-8 is going to be very different from detecting utf-16 or UCS-2. Also, are we talking arbitrary buffers/strings, or detecting the encoding of a file? <strong>Some</strong> unicode text files are encoded with a <a target="_blank" href="http://en.wikipedia.org/wiki/Byte-order_mark">BOM</a>.</div>
    <div class="meta">Posted on 2010-01-24 09:10:18 by f0dder</div>
   </div>
   <div class="post" id="post-210374">
    <div class="subject"><a href="#post-210374">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote"><br />how do i recognise the unicode or ansi strings in a buffer ?<br /></div><br /><br /><a target="_blank" href="http://msdn.microsoft.com/en-us/library/dd318672%28VS.85%29.aspx">IsTextUnicode</a> if you want to use the Windows API</div>
    <div class="meta">Posted on 2010-01-24 10:36:42 by donkey</div>
   </div>
   <div class="post" id="post-210383">
    <div class="subject"><a href="#post-210383">Re: the unicode or ansi strings</a></div>
    <div class="body">thanks all, Especially donkey.</div>
    <div class="meta">Posted on 2010-01-24 20:14:53 by dcskm4200</div>
   </div>
   <div class="post" id="post-210448">
    <div class="subject"><a href="#post-210448">Re: the unicode or ansi strings</a></div>
    <div class="body">I wouldn&#039;t trust that api - Microsoft&#039;s implementation of unicode is based on some very bad ideas, such as<br /><div class="quote">The number of characters in the string is odd. A string of odd length cannot (by definition) be Unicode text.</div><br /><br />This is a misleading and incorrect statement.<br />Unicode certainly does support 3-byte sequences, rendering the notion of &quot;16 bit unicode&quot; as a relic.<br />The following code assumes we already tested the first byte and determined that its greater than 128 (80h).<br />Anything less would be a single byte of american ascii.<br />Anything bigger MAY indicate the beginning of a unicode (or utf8-encoded unicode) multibyte sequence.<br />Here&#039;s my test for pure unicode sequence, returning 0,2 or 3 (#bytes in unicode codepoint).<br /><br /><pre><code><br />;Method: &nbsp; &nbsp;Parser.IsUnicodeChar<br />;Purpose: &nbsp; Determine if the given value in eax is a possible unicode character<br />;Returns: &nbsp; EAX = FALSE (not unicode), 2 (unicode length) or 3 (unicode length)<br />Method Parser.IsUnicodeChar,uses esi,dChar<br /> &nbsp; &nbsp;SetObject esi<br /> &nbsp; &nbsp;mov eax,dChar<br /> &nbsp; &nbsp;.if eax&gt;0010FFFFh<br /> &nbsp; &nbsp; &nbsp; &nbsp;;Its not unicode<br /> &nbsp; &nbsp; &nbsp; &nbsp;xor eax,eax<br /> &nbsp; &nbsp;.elseif eax&gt;=00100000h<br /> &nbsp; &nbsp; &nbsp; &nbsp;;Supplementary Private Use Area-B<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov eax,3<br /> &nbsp; &nbsp;.elseif eax&gt;=000F0000h<br /> &nbsp; &nbsp; &nbsp; ;Supplementary Private Use Area-A <br /> &nbsp; &nbsp; &nbsp;mov eax,3<br /> &nbsp; &nbsp;.elseif eax&gt;=000E0000h<br /> &nbsp; &nbsp; &nbsp;;Supplementary Special-purpose Plane 	SSP<br /> &nbsp; &nbsp; &nbsp;mov eax,3<br /> &nbsp; &nbsp;.elseif eax&gt;=00040000h<br /> &nbsp; &nbsp; &nbsp; &nbsp;;currently unassigned <br /> &nbsp; &nbsp; &nbsp; &nbsp;;It is NOT unicode<br /> &nbsp; &nbsp; &nbsp; &nbsp;return FALSE<br /> &nbsp; &nbsp;.elseif eax&gt;=00030000h<br /> &nbsp; &nbsp; &nbsp; &nbsp;;Tentatively designated as the Tertiary Ideographic Plane (TIP), but no characters have been assigned to it yet.<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov eax,3<br /> &nbsp; &nbsp;.elseif eax&gt;=00020000h<br /> &nbsp; &nbsp; &nbsp; &nbsp;;Supplementary Ideographic Plane 	SIP<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov eax,3<br /> &nbsp; &nbsp;.elseif eax&gt;=00010000h<br /> &nbsp; &nbsp; &nbsp; ;Supplementary Multilingual Plane 	SMP<br /> &nbsp; &nbsp; &nbsp; mov eax,3<br /> &nbsp; &nbsp;.else<br /> &nbsp; &nbsp; &nbsp; &nbsp;;Basic Multilingual Plane 	BMP<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov eax,2<br /> &nbsp; &nbsp;.endif<br />MethodEnd<br /></code></pre><br /><br />And do note that unicode codepoints within utf8 (or 16) are ENCODED - depending on the value of the codepoint, it can take 5 bytes to encode a 3-byte unicode character, etc... <br /><br />Have a nice day :)<br /><br /><br />(ps r22: I&#039;ve done a lot of work with detecting various text encodings &#039;on the fly&#039; lately, perhaps I&#039;ll write a thread dedicated to that topic in the near future, if anyone is interested)</div>
    <div class="meta">Posted on 2010-01-28 07:33:24 by Homer</div>
   </div>
   <div class="post" id="post-210449">
    <div class="subject"><a href="#post-210449">Re: the unicode or ansi strings</a></div>
    <div class="body">Saying that Microsoft&#039;s Unicode is &#039;wrong&#039; is a stretch, if you ask me.<br />There&#039;s unicode, and then there&#039;s unicode.<br />What you describe is UTF-8, which is one possible way to encode unicode characters.<br />However, the Win32API does not use this, they instead use the UCS-2 encoding. In UCS-2 indeed all odd-length strings must be non-unicode. So as far as the Win32API is concerned, they are correct (the API cannot handle UTF-8 encoding anyway, so why should they support detecting it?).<br /><br />UCS-2 is now obsolete yes... it is superceded by UTF-16 (where the above statement still holds, all strings are even length), which extends UCS-2 in a similar way that UTF-8 extends ANSI charactersets.<br />But can you blame Microsoft, even say they are &#039;wrong&#039;, when their unicode implementation dates back to the early days of Windows NT? Back then all unicode was 16-bit anyway.<br />They support UTF-8 in their .NET framework anyway (which isn&#039;t bogged down by Windows NT legacy). But obviously they can&#039;t just swap the Win32 API around to another encoding, it would break all existing unicode applications (clearly you realize that UTF-8 is not compatible with Win32 API?).<br />Knowing whether a string is unicode or not, is not enough, you need to know the actual encoding.<br />For UCS-2 or UTF-16, your code is as &#039;wrong&#039; as Microsoft&#039;s is for UTF-8.<br /><br />For more info on different versions of unicode and different encodings, see http://en.wikipedia.org/wiki/Unicode</div>
    <div class="meta">Posted on 2010-01-28 07:56:46 by Scali</div>
   </div>
   <div class="post" id="post-210450">
    <div class="subject"><a href="#post-210450">Re: the unicode or ansi strings</a></div>
    <div class="body">What I stated is that unicode codepoints can be 3 bytes long - eastern languages such as chinese and russian are using these.<br /><br />UTF-8 IS NOT UNICODE. It came later, it can be thought of as a compression scheme for unicode codepoints...(People looked at the old pure 16-bit unicode , and said &quot;gee, look at all those zeroes...&quot;), and happens to have the property that american ascii bytes are legal, and not encoded... but unicode codepoints are cleverly encoded, and the scheme can be extended anytime to handle longer (new) unicode codepoints, which is precisely what I was describing...<br /><br />utf-8 never contains &#039;pure&#039; unicode codepoints!<br /><br />Pure unicode is not encoded, its codepoints = the values in the byte sequence.<br />utf-8 encoded unicode is just that - its a binary packing scheme.<br />So if we have some utf-8 bytestream, we have to work hard to extract the unicode codepoint values from it.<br /><br />;U-00000000 – U-0000007F: 	0xxxxxxx<br />;U-00000080 – U-000007FF: 	110xxxxx 10xxxxxx<br />;U-00000800 – U-0000FFFF: 	1110xxxx 10xxxxxx 10xxxxxx<br />;U-00010000 – U-001FFFFF: 	11110xxx 10xxxxxx 10xxxxxx 10xxxxxx<br />;U-00200000 – U-03FFFFFF: 	111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx<br />;U-04000000 – U-7FFFFFFF: 	1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx<br /><br />You can see in the above table how utf-8 encodes unicode codepoints of up to 33 bits (yes, 33, so 5 byte unicode sequences have been defined, at least in theory).<br />The x&#039;s contain the bits which , when gathered together, contain our unicode codepoint value.<br />The 1&#039;s and 0&#039;s are there for sanity checking, and allow us to decode unicode from utf-8 (and detect bad encodings).<br />Note that the number of 1&#039;s in the high bits of the high order byte tells us how many bytes are in this encoded sequence, and how much work we need to do to get a U-value in the plain.<br /><br />It&#039;s worth mentioning that only the first four rows of this table are in common use, the last two are reserved for expansion... but even so, I count 21 x&#039;s on the fourth row, 21 bits won&#039;t fit into 16 whichever way you slice it.<br /><br /></div>
    <div class="meta">Posted on 2010-01-28 08:26:01 by Homer</div>
   </div>
   <div class="post" id="post-210451">
    <div class="subject"><a href="#post-210451">Re: the unicode or ansi strings</a></div>
    <div class="body">And having demonstrated the utf-8 encoding scheme, I see no point in utf-16 at all.<br />utf-8 is infinitely expandable, and has a smaller encoding than utf-16 for the larger codepoint values (utf-16 is based strongly on the historical notion of byte-pairs, potentially leading to a lot of junk bytes in the bytestream for mid-valued codepoints).<br />utf-8 does everything that utf-16 does, generally using fewer bits.<br /><br /></div>
    <div class="meta">Posted on 2010-01-28 08:37:20 by Homer</div>
   </div>
   <div class="post" id="post-210452">
    <div class="subject"><a href="#post-210452">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote">What I stated is that unicode codepoints can be 3 bytes long - eastern languages such as chinese and russian are using these.</div><br /><br />Which is incorrect. UTF-8 encoded unicode can have characters of 3 bytes long. UCS-2 or UTF-16 cannot.<br />But even then, it depends on the version of unicode supported. For example, although Java supports UTF-8, its is an older version of unicode, its char datatype is 16-bits, and as such it will not handle 3-byte characters.<br /><br />Unicode is a concept, just like the ASCII codes of characters.<br />Although technically all ASCII characters can fit into 7-bit, the most common encoding is to use 8-bits.<br />It&#039;s like a number. The number 23423 is an &#039;entity&#039;, so to speak. Storing it in a 16-bit word is a certain binary representation of that number. Storing it in a 32-bit word is a different binary representation of that same number. So what is the length of that number? Is it 2 bytes? Is it 4 bytes? Doesn&#039;t make sense... In theory it could be less than 2 bytes aswell, if you so choose.<br />Likewise, while there is only one code for each unicode character, there are various ways to represent these codes in binary. One is not more &#039;right&#039; than another. You cannot speak of THE length of a unicode character or string in terms of bytes, as it depends on the encoding used.<br /><br />And as was pointed out earlier, UTF-8 is not supported by the Win32API, so if we are to assume that the question was about detecting unicode or ansi strings in Windows, UTF-8 is completely irrelevant, and the IsTextUnicode() API is the right answer.</div>
    <div class="meta">Posted on 2010-01-28 08:38:19 by Scali</div>
   </div>
   <div class="post" id="post-210453">
    <div class="subject"><a href="#post-210453">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote">And having demonstrated the utf-8 encoding scheme, I see no point in utf-16 at all.</div><br /><br />The point of UTF-16 is that it&#039;s an extension of UCS-2, as UTF-8 is an extension of ASCII. Where all ASCII characters in a UTF-8 string can be freely read by any ASCII routine, any UCS-2 characters in UTF-16 can be read by any UCS-2 routine.</div>
    <div class="meta">Posted on 2010-01-28 08:41:41 by Scali</div>
   </div>
   <div class="post" id="post-210454">
    <div class="subject"><a href="#post-210454">Re: the unicode or ansi strings</a></div>
    <div class="body">That&#039;s true - unicode codepoints are an abstract, the encoding determines the actual bytelength.<br />Therefore, the statement that unicode characters must be of even length is ONLY true of UCS-2 and NOT true of unicode itself, therein lies the ambiguity of the statement made in the msdn documentation for that particular api.<br />Misleading, and incorrect, unless we&#039;re strictly talking about UCS-2 encoding, which is not actually stated.<br /><br />With a little work, it&#039;s possible to determine exactly which encoding scheme of all the above named is being employed, with a relatively high degree of confidence. For example, utf-8 will never contain FE or FF (excluding the BOM), utf-16 will never contain FFFE or FFFF (again the BOM), UCS-2 will typically contain a bunch of zeroes, and utf-16 will contain the occasional zero in the second byte of a pair. We can develop a fairly solid set of rules to crunch through, even if there&#039;s no BOM, to make an intelligent decision about each codepoint in the bytestream, and can even detect a change of encoding midstream.<br /><br />Microsoft&#039;s api can return a lot of false positives for an arbitrary sequence of bytes.</div>
    <div class="meta">Posted on 2010-01-28 08:51:23 by Homer</div>
   </div>
   <div class="post" id="post-210456">
    <div class="subject"><a href="#post-210456">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote"><br />That&#039;s true - unicode codepoints are an abstract, the encoding determines the actual bytelength.<br />Therefore, the statement that unicode characters must be of even length is ONLY true of UCS-2 and NOT true of unicode itself, therein lies the ambiguity of the statement made in the msdn documentation for that particular api.<br />Misleading, and incorrect, unless we&#039;re strictly talking about UCS-2 encoding, which is not actually stated.</div><br /><br />As I say, that&#039;s the result of legacy. UCS-2 was the first encoding for unicode. UCS-2 is actually a &#039;backronym&#039;.<br />See the original unicode 88 standard document: http://www.unicode.org/history/unicode88.pdf<br />While they clearly describe what we now know as UCS-2 (they specifically mention 16 bits), they only describe it as &#039;unicode&#039; or &#039;wide-body ASCII&#039;. Only after alternative encodings came into swing, the name UCS-2 was devised to refer to the original 16-bit encoding.<br />Therefore, when Microsoft originally designed their unicode API, unicode was indeed equivalent to UCS-2. It&#039;s too late to rename the API&#039;s now.<br />I&#039;m sure the MSDN will explain this somewhere, but it&#039;s common knowledge that within the context of the Win32 API, unicode and UCS-2 are equivalent. I think it will be more confusing for most people if they start to use UCS-2 or UTF-16 everywhere. People are used to referring to it as unicode, nothing else.<br /><br />Gives me the same feeling as the &#039;redefinition&#039; of things like KB and MB into KiBi and MeBi stuff.<br />I am so used to referring to powers-of-two with KB, MB etc, that I find it disturbing that people have now &#039;redefined&#039; KB to mean 1000 bytes rather than 1024 (which it always has, ever since computers were still made of wood), and insist that I must now start using KiBi to refer to something that I&#039;ve referred to as KB all my life. Sure, by THEIR definition, probably 99% of everything ever written about computers and storage is &#039;wrong&#039; when they use KB... but it was right at the time of writing. People should leave well enough alone.<br /><br /><div class="quote">Microsoft&#039;s api can return a lot of false positives for an arbitrary sequence of bytes.</div><br /><br />Microsoft&#039;s API wasn&#039;t meant to detect anything other than UCS-2. Which should be clear by the fact that it can only say whether it&#039;s &#039;unicode&#039; or not, which as I&#039;ve explained, means UCS-2 within this context.<br />What&#039;s the use of having a function that says &quot;This is unicode&quot; without saying WHICH encoding it is? Clearly you can only use the function if you want to know whether a certain string is ANSI or UCS-2. If it can be anything else, you should be shot if you even try to call this function in the first place.</div>
    <div class="meta">Posted on 2010-01-28 08:59:10 by Scali</div>
   </div>
   <div class="post" id="post-210457">
    <div class="subject"><a href="#post-210457">Re: the unicode or ansi strings</a></div>
    <div class="body">My personal belief is that started as a marketing ploy, the numbers look bigger, it must be better.<br />And I&#039;d like to petition Microsoft to stop using the term Unicode to refer to something it isn&#039;t, or at least rename their api to &quot;IsPossiblyUnicode&quot; :P (actually, it does state &quot;Determines if a buffer is LIKELY to contain a form of Unicode text.&quot;)<br /><br />And sure, that&#039;s great if you used a Microsoft api to generate the strings in the first place, but if the data is alien, the api is not suitable. Perhaps &quot;IsNotAmericanAscii&quot; would better describe this api.<br /><br />Debugging microsoft&#039;s Notepad while it opens a file is an eye opener. This thing jumps through hoops to determine the text encoding, it doesn&#039;t make any assumptions, it makes lots of tests (the more data the better), I don&#039;t think it calls that IsUnicode api once, and it does handle very well the case of switching encodings midstream (which happens if you paste data between textfiles that have different encodings, as a lot of programmers are known to do).</div>
    <div class="meta">Posted on 2010-01-28 09:10:00 by Homer</div>
   </div>
   <div class="post" id="post-210458">
    <div class="subject"><a href="#post-210458">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote">My personal belief is that started as a marketing ploy, the numbers look bigger, it must be better.<br />And I&#039;d like to petition Microsoft to stop using the term Unicode to refer to something it isn&#039;t, or at least rename their api to &quot;IsPossiblyUnicode&quot; :P<br /></div><br /><br />My personal belief is that you like to fight windmills.<br /><br /><div class="quote">And sure, that&#039;s great if you used a Microsoft api to generate the strings in the first place, but if the data is alien, the api is not suitable. Perhaps &quot;IsNotAmericanAscii&quot; would better describe this api.</div><br /><br />What exactly do you expect? How can Microsoft build an API for text encodings that didn&#039;t even exist? There is always the option of &#039;alien data&#039;. It&#039;s impossible to make an API that catches every possible encoding, now and in the future.<br />Personally I think you&#039;re doing something very wrong if you somehow managed to get hold of a string without knowing how it is encoded in the first place.<br />Aside from that, Microsoft is quite clear, both in the description of the API, and the return values themselves, that there are various levels of accuracy in the detection, and that the function should certainly not be assumed to be 100% reliable in all cases. They even give an example of how it can go wrong.<br />They also say &quot;Included in Windows NT 3.5 and later&quot;... NT 3.5, that was September 1994, to put things in perspective.</div>
    <div class="meta">Posted on 2010-01-28 09:14:22 by Scali</div>
   </div>
   <div class="post" id="post-210460">
    <div class="subject"><a href="#post-210460">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote"><br />And having demonstrated the utf-8 encoding scheme, I see no point in utf-16 at all.<br /></div><br /><br />strlen() speed :lol:</div>
    <div class="meta">Posted on 2010-01-28 09:58:16 by SpooK</div>
   </div>
   <div class="post" id="post-210470">
    <div class="subject"><a href="#post-210470">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote"><br /><a target="_blank" href="http://msdn.microsoft.com/en-us/library/dd318672%28VS.85%29.aspx">IsTextUnicode</a> if you want to use the <strong>Windows API</strong><br /></div><br /><br />Hi Homer, Scali<br /><br />I only suggested he use IsTextUnicode in the context of Windows and meant it to be used for detecting Unicode strings for use with the API, that&#039;s why I had the qualifying statement. Obviously if he wants to use a different Unicode encoding scheme he would be required to find a different, more flexible route. For the odd numbered byte length, Microsoft&#039;s documentation needs a few footnotes but in essence is correct within the scope of their definition of Unicode support. The documentation for Windows Unicode support clearly states:<br /><br /><div class="quote">While Unicode-enabled functions in Windows use UTF-16, it is also possible to work with data encoded in UTF-8 or UTF-7, which are are supported in Windows as multibyte character set code pages.</div><br /><br />It has always been Microsoft&#039;s habit to bend a definition to match the capabilities of its software. If you want to work in Windows you have to live with Microsoft&#039;s idiosyncrasies. <a target="_blank" href="http://msdn.microsoft.com/en-us/library/dd374089%28VS.85%29.aspx">Unicode in the Windows API</a><br /><br />As for the advantage of size for UTF-8 who seriously cares about size anymore, especially when dealing with text, even when it amounts to a few million wasted bytes. Fixed length is by definition faster to deal with in any number of functions than a variable length encoding. Any extensibility advantage of UTF-8 is easily negated by surrogate pairs in UTF-16.<br /><br />Edgar</div>
    <div class="meta">Posted on 2010-01-28 22:00:46 by donkey</div>
   </div>
   <div class="post" id="post-210473">
    <div class="subject"><a href="#post-210473">Re: the unicode or ansi strings</a></div>
    <div class="body">Yea, as I said, it&#039;s bound to be in MSDN somewhere. Here it is:<br />http://msdn.microsoft.com/en-us/library/dd374081(VS.85).aspx<br /><div class="quote">Unicode-enabled functions are described in Conventions for Function Prototypes. These functions use UTF-16 (wide character) encoding, which is the most common encoding of Unicode and the one used for native Unicode encoding on Windows operating systems.</div><br /><br />And as I already proved earlier, UCS-2 was the first unicode encoding, UTF-8 came later, at a time when the unicode functionality in the Win32API was already in use.<br />You can&#039;t blame Microsoft for naming their functions as &#039;unicode&#039; when only one encoding of unicode exists, which doesn&#039;t even have a specific name yet. As I alraedy said, UCS-2 is a backronym. Much like CISC for example. CPU designers didn&#039;t know that they were designing CISC CPUs at the time, the term wasn&#039;t even invented yet. When they came up with the RISC philosophy, they named the current philosophy CISC.<br />Same here.<br />Please, grow up. Not everything that Microsoft does has to have some kind of evil background to it. It&#039;s a character encoding for crying out loud.<br /><br />But, Microsoft does explain that unicode is UTF-16 in the Win32API, so I don&#039;t see the big deal. &#039;Unicode&#039; in itself doesn&#039;t say anything about encoding, and the encodings aren&#039;t interchangeable, so you&#039;d need to read the manual to see what encoding they use. And it&#039;s in there.<br /><br />I find the accusations towards Microsoft rather childish in nature. Saying they&#039;re &#039;wrong&#039;, or that they&#039;re trying to &#039;bend a definition&#039;. There WAS no definition at the time. If anything, it&#039;s the guys who invented UTF-8 and the UCS-2 names who &#039;bent the definition&#039;. Just like the guys who invented KiBi, MeBi and all that other nonsense.</div>
    <div class="meta">Posted on 2010-01-29 02:06:33 by Scali</div>
   </div>
   <div class="post" id="post-210474">
    <div class="subject"><a href="#post-210474">Re: the unicode or ansi strings</a></div>
    <div class="body">Interesting that the docs say it&#039;s UTF-16, I thought it was UCS-2... wonder how much code out there does simple *2 or /2 when dealing with ascii&lt;&gt;<em>unicode</em>...</div>
    <div class="meta">Posted on 2010-01-29 02:11:12 by f0dder</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29778&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29778&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29778" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29778&amp;page=2">&gt;</a><a href="../?id=29778&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>