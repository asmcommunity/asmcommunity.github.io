<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>the unicode or ansi strings - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29778" />
  <link rel="prev" href="../?id=29778&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29778">the unicode or ansi strings</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29778&amp;page=1" style="">&laquo;</a><a href="../?id=29778&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29778" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-210478">
    <div class="subject"><a href="#post-210478">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote"><br />Interesting that the docs say it&#039;s UTF-16, I thought it was UCS-2... wonder how much code out there does simple *2 or /2 when dealing with ascii&lt;&gt;<em>unicode</em>...<br /></div><br /><br />From what I understood, it WAS UCS-2, but it was expanded to UTF-16 in Windows 2000.</div>
    <div class="meta">Posted on 2010-01-29 05:42:15 by Scali</div>
   </div>
   <div class="post" id="post-210480">
    <div class="subject"><a href="#post-210480">Re: the unicode or ansi strings</a></div>
    <div class="body">For good old 7-bit american ascii, it is safe to make this assumption.<br />But not for U-codepoints in general, because utf-16 is similar to utf-8 in that there is a strict binary encoding of the U-value into the lower 10 bits of each byte (of each pair).<br />That is to say, we can&#039;t just look at a 16-bit value and say &quot;yeah, that&#039;s the U-code value&quot; like we can with UCS-2 (which I refer to as &#039;vanilla unicode&#039;).<br /></div>
    <div class="meta">Posted on 2010-01-29 07:24:57 by Homer</div>
   </div>
   <div class="post" id="post-210483">
    <div class="subject"><a href="#post-210483">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote"><br />Interesting that the docs say it&#039;s UTF-16, I thought it was UCS-2... wonder how much code out there does simple *2 or /2 when dealing with ascii&lt;&gt;<em>unicode</em>...<br /></div><br /><br />UCS-2 does not support surrogate pairs, UTF-16 does, otherwise they are identical. Supporting only UCS-2 would severely limit the available character sets, though for most APIs it is not an issue, the GDI and Uniscribe support supplementary characters.</div>
    <div class="meta">Posted on 2010-01-29 09:49:00 by donkey</div>
   </div>
   <div class="post" id="post-210485">
    <div class="subject"><a href="#post-210485">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote"><br />I find the accusations towards Microsoft rather childish in nature. Saying they&#039;re &#039;wrong&#039;, or that they&#039;re trying to &#039;bend a definition&#039;. There WAS no definition at the time. If anything, it&#039;s the guys who invented UTF-8 and the UCS-2 names who &#039;bent the definition&#039;. Just like the guys who invented KiBi, MeBi and all that other nonsense.<br /></div><br /><br />Uniscribe dates well past the addition of UTF-7 and UTF-8 however Microsoft did not alter their definition of Unicode, preferring to keep the old one. They did add support for the new encoding schemes however, this would be &quot;bending&quot; the definition. Because you seem to rely on the fact that they supported Unicode in the era of version 1 they are exempt from using the full range of encoding schemes in their definition. Whatever the reasons for the limitations in their software they continue to bend the definition to those limitations.<br /><br />Oh, and by the way UTF-8 started development in 1992 (called Plan 9 by the X/Open committee), Microsoft was completely aware that other Unicode encoding schemes were being developed and chose to support UTF-16, the more mature standard and call it and it alone Unicode. So, I would hope that its not my &#039;bent the definition&#039; statement that you&#039;re calling &#039;nonsense&#039; since it is well grounded in the history of Unicode.</div>
    <div class="meta">Posted on 2010-01-29 10:20:49 by donkey</div>
   </div>
   <div class="post" id="post-210486">
    <div class="subject"><a href="#post-210486">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote">Uniscribe dates well past the addition of UTF-7 and UTF-8 however Microsoft did not alter their definition of Unicode, preferring to keep the old one. They did add support for the new encoding schemes however, this would be &quot;bending&quot; the definition. Because you seem to rely on the fact that they supported Unicode in the era of version 1 they are exempt from using the full range of encoding schemes in their definition. Whatever the reasons for the limitations in their software they continue to bend the definition to those limitations.</div><br /><br />That&#039;s not what I said at all.<br />What I said was that &#039;Unicode&#039; at the time the Win32API was devised, only existed in the form of UCS-2. They cannot change the names of the APIs now that they are widely in use.<br /><br /><div class="quote">Oh, and by the way UTF-8 started development in 1992 (called Plan 9 by the X/Open committee)</div><br /><br />They STARTED in 1992. But the first Windows NT with Unicode support was RELEASED in 1993, so clearly Microsoft started on their Unicode API well before UTF-8.<br /><br /><div class="quote">Microsoft was completely aware that other Unicode encoding schemes were being developed and chose to support UTF-16, the more mature standard and call it and it alone Unicode</div><br /><br />Incorrect. Microsoft chose UCS-2, which was not known as UCS-2 yet, but only as Unicode, at that time (somewhere well before 1992, so before both UTF-8 and UTF-16 existed).<br />As I already said, Microsoft expanded it to UTF-16 in Windows 2000. Clearly UTF-8 wasn&#039;t really an option with the UCS-2 legacy they built up since 1992.<br />As I also said, with .NET they DO use UTF-8, because they could start with a clean slate there,<br /><br /><div class="quote">So, I would hope that its not my &#039;bent the definition&#039; statement that you&#039;re calling &#039;nonsense&#039; since it is well grounded in the history of Unicode.</div><br /><br />Nope, it&#039;s still nonsense, you got your facts all wrong.&nbsp; Which you wouldn&#039;t have, if you bothered to read my posts, because I&#039;ve already said everything I said in this post before.</div>
    <div class="meta">Posted on 2010-01-29 11:46:46 by Scali</div>
   </div>
   <div class="post" id="post-210487">
    <div class="subject"><a href="#post-210487">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote"><br />They STARTED in 1992. But the first Windows NT with Unicode support was RELEASED in 1993, so clearly Microsoft started on their Unicode API well before UTF-8.</div><br /><br />The standard for Unicode was published in April, 1992. It was only finalized earlier that year so I am assuming that Microsoft was making adjustments right up to the date of release and waited for the standard to be published before documenting it (which would be the sensible way to do it). And we are talking only about documenting it here, not when they began coding the APIs. They narrowed the scope of the definition (which was known to potentially support multiple standards at the time they documented the API) to fit their software&#039;s capability, that&#039;s what &quot;bending it&quot; means, I never said that they misrepresented it or were not factual in their interpretation. In fact I said quite the opposite, only that they needed perhaps a footnote and the Unicode statements (ie that Unicode text by definition could not have an odd numbers of bytes) they made were within the scope of their definition.</div>
    <div class="meta">Posted on 2010-01-29 14:22:26 by donkey</div>
   </div>
   <div class="post" id="post-210489">
    <div class="subject"><a href="#post-210489">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote">The standard for Unicode was published in April, 1992.</div><br /><br />Then how come I linked to a publication of the Unicode standard from 1988?<br />And why do various internet resources report that the Unicode 1.0 standard was published in 1991?<br />Give it up, UTF-8 was NOT in the official Unicode standard, and was added in later revision. This means that your entire argument falls apart.<br />UCS-2 was the ONLY encoding in the original 1988 publication, and also the ONLY encoding in the Unicode 1.0 standard. Also, it was NOT called UCS-2 yet.<br />The irony of it all... because Windows uses UCS-2/UTF-16, and Windows is about 90% of the entire market, the most common unicode encoding BY FAR is UCS-2/UTF-16.<br />Statistically, the chance that a unicode string is encoded with UCS-2/UTF-16 is far greater than UTF-8 or any other alternative encoding.</div>
    <div class="meta">Posted on 2010-01-29 15:30:42 by Scali</div>
   </div>
   <div class="post" id="post-210496">
    <div class="subject"><a href="#post-210496">Re: the unicode or ansi strings</a></div>
    <div class="body">I&#039;m not sure where you got that 1988 thing from...<br /><br />http://www.unicode.org/history/publicationdates.html<br /><br />This is the time line according to Unicode.org, the final arbiter on all questions involving the publications since after all they publish them. Volume 2 was the complete standard, Volume 1 was a working set.</div>
    <div class="meta">Posted on 2010-01-29 19:01:07 by donkey</div>
   </div>
   <div class="post" id="post-210499">
    <div class="subject"><a href="#post-210499">Re: the unicode or ansi strings</a></div>
    <div class="body">I&#039;m not interested in arguments about dates or semantics.<br />My interest is purely about recognizing unknown encodings with a reasonable degree of accuracy.<br />I don&#039;t think its viable to assume that &#039;we should already know which encoding was used&#039;, and even in the Windows world there&#039;s a wide range of encodings being used by a wider range of authors, so it&#039;s not unreasonable to suggest that it&#039;s not only possible, but likely that we&#039;ll encounter them.<br /><br />UTF-16 may be the most common, behind american ascii and UCS-2, I can&#039;t say, I haven&#039;t attempted to determine ratios or probabilities, I can only say that I have encountered all the popular encodings, both as filestreams and network data streams, and I&#039;m trying to deduce an algorithm which can determine which is being employed, without necessarily having access to the complete datastream.<br /><br />That being said, I have been starting with the assumption that the data is in fact utf-8, since this encoding seems to have the most strict binary encoding, with the greatest likelihood of detecting a BAD encoding with the minimum amount of data. utf-8 and utf-16 share some properties in their binary encoding, so it is easy to mistake one for the other... but utf-8&#039;s encoding scheme has a definitive character delimiter (bitpattern which describes the number of bytes in a legal encoding), and so it is indeed possible to distinguish between them. This is useful to me.<br /><br />I will be initially concentrating on distinguishing between various little-endian encodings, I hope to retrofit the algorithm for both LE and BE once I&#039;m satisfied that the algo is doing a reasonably good job of determining the encoding.<br /></div>
    <div class="meta">Posted on 2010-01-29 20:41:22 by Homer</div>
   </div>
   <div class="post" id="post-210503">
    <div class="subject"><a href="#post-210503">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote"><br />I&#039;m not sure where you got that 1988 thing from...<br /><br />http://www.unicode.org/history/publicationdates.html<br /><br />This is the time line according to Unicode.org, the final arbiter on all questions involving the publications since after all they publish them. Volume 2 was the complete standard, Volume 1 was a working set.<br /></div><br /><br />http://www.unicode.org/history/museum.html &lt;-- as you can see, the first standard proposal was published in 1988. This is what I linked to. Which you apparently didn&#039;t even notice.&nbsp; If you want to argue, at least bother to read the posts of the person you&#039;re arguing with. No respect.<br />Even so, this page proves yourself wrong, because it says the final 1.0 standard was released in 1991, not 1992 (as I already said... obviously Microsoft doesn&#039;t really care about which volume was published when. It&#039;s about the standard itself, not the books).<br />Try to be a BIT more meticulous in getting your data right. You don&#039;t even quote your own sources properly.<br /><br />I&#039;m not really sure what you&#039;re trying to argue anyway...<br />Your line of argument sounds like this to me:<br />June 1992: The second volume of the Unicode 1.0 standard was published. Microsoft only now discovers the glory of Unicode... and although Windows NT is scheduled for release the next year, they think &quot;Hey, this unicode lark is cool. Let&#039;s completely rewrite our entire API just a few months before the final release, and add this unicode stuff&quot;<br /><br />Sounds completely unlikely.<br /><br />What I&#039;m saying is this:<br />Unicode proposal is published in 1988. Microsoft (and IBM at the time) started development on Windows NT in November 1989. They had seen the Unicode proposal, and figured it would be a great way to solve the localization problems in legacy OSes. So they adopted Unicode from the get-go, designing their API around using both ASCII and Wide Characters.<br />When Windows NT was already in the final testing stages, somewhere in 1992, some people proposed the alternative UTF-8 encoding. With Windows NT having already been in development for a few years, and gearing up for the release, it was too late to incorporate UTF-8. The APIs were already finalized, documentation was already being written.<br /><br />Sounds highly likely.</div>
    <div class="meta">Posted on 2010-01-30 02:52:33 by Scali</div>
   </div>
   <div class="post" id="post-210504">
    <div class="subject"><a href="#post-210504">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote">My interest is purely about recognizing unknown encodings with a reasonable degree of accuracy.<br />I don&#039;t think its viable to assume that &#039;we should already know which encoding was used&#039;, and even in the Windows world there&#039;s a wide range of encodings being used by a wider range of authors, so it&#039;s not unreasonable to suggest that it&#039;s not only possible, but likely that we&#039;ll encounter them.</div><br /><br />As you say yourself, &quot;a reasonable degree of accuracy&quot;. It&#039;s never going to be possible to catch all. Therefore, if you don&#039;t know the encoding beforehand, you&#039;re basically fighting a lost battle.<br /><br />But I personally have never been in a situation where I didn&#039;t know the encoding used, so I wonder how you could ever get there. It seems that you can only reach such a situation when you once knew the encoding, but decided to ignore it at that point, and it came back to haunt you later.<br /><br />Let me just throw this out there: PETSCII.<br />Ever even heard of that? It&#039;s the character encoding used by Commodore, originally designed for their PET range. It was used in various other Commodore computers aswell, including the C64, the best-selling computer of all time.<br />If you haven&#039;t heard of this encoding before, you wouldn&#039;t have created a detection routine for it either. Yet it&#039;s perfectly possible to encounter PETSCII strings &#039;in the wild&#039;, given the huge popularity of the C64. QED.</div>
    <div class="meta">Posted on 2010-01-30 03:00:40 by Scali</div>
   </div>
   <div class="post" id="post-210506">
    <div class="subject"><a href="#post-210506">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote">But I personally have never been in a situation where I didn&#039;t know the encoding used, so I wonder how you could ever get there.</div>One very real example: text editors. You have to deal with a variety of formats... plain ascii, OEM codepages, unicode with BOM, unicode without BOM... those are the bare minimums, more adventurous editors might want to support EBDIC and other alien formats as well.<br /><br /><div class="quote">Yet it&#039;s perfectly possible to encounter PETSCII strings &#039;in the wild&#039;, given the huge popularity of the C64. QED.</div>A lot less likely than encountering an UTF-8 encoded document without a BOM. I doubt you&#039;d bump into PETSCII unless you were specifically looking for C=64 stuff?</div>
    <div class="meta">Posted on 2010-01-30 10:18:28 by f0dder</div>
   </div>
   <div class="post" id="post-210507">
    <div class="subject"><a href="#post-210507">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote"><br /><div class="quote">But I personally have never been in a situation where I didn&#039;t know the encoding used, so I wonder how you could ever get there.</div>One very real example: text editors. You have to deal with a variety of formats... plain ascii, OEM codepages, unicode with BOM, unicode without BOM... those are the bare minimums, more adventurous editors might want to support EBDIC and other alien formats as well.</div><br /><br />Exactly my point, isn&#039;t it?<br />This text file was once written by someone who DID know what encoding to use. Then it should have been remembered in some way. Either by storing a BOM in the file, or using some other kind of metadata... perhaps even as simple as just a file extension.<br />Anything that would describe the format.<br /><br />Obviously opening random text files with random editors is a lost battle, as I already said. You&#039;re never going to be able to determine 100% what kind of format the file is.<br />Besides, that is a VERY specific problem (caused by the user/owner of the text file). It&#039;s not a problem that normal applications should ever bump into. Any decent application should support decent fileformats which somehow define the encoding of the data properly. And obviously, any user input will also be in a known encoding at all times.<br /><br />In other words, I doubt that the sole existence of the IsTextUnicode() API function is for people writing text editors.<br /><br /><div class="quote">I doubt you&#039;d bump into PETSCII unless you were specifically looking for C=64 stuff?</div><br /><br />I doubt you&#039;d bump into anything other than UTF-16 unless you were specifically looking for non-Windows stuff?</div>
    <div class="meta">Posted on 2010-01-30 10:30:08 by Scali</div>
   </div>
   <div class="post" id="post-210512">
    <div class="subject"><a href="#post-210512">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote">In other words, I doubt that the sole existence of the IsTextUnicode() API function is for people writing text editors.</div>It actually seems like a slightly weird API function to me, anyway... can&#039;t think of a lot of (normal) situations where it&#039;d be useful.<br /><br /><div class="quote"><div class="quote">I doubt you&#039;d bump into PETSCII unless you were specifically looking for C=64 stuff?</div><br /><br />I doubt you&#039;d bump into anything other than UTF-16 unless you were specifically looking for non-Windows stuff?</div>I&#039;ve never <strong>bumped into</strong> UTF-16 (API calls don&#039;t really count as &quot;bump into&quot;) but I&#039;ve bumped into &quot;unclassified&quot; UTF-8 on <strong>several</strong> occasions. Usually related to web browsers or servers not having specified content-type correctly, but not limited to that.<br /></div>
    <div class="meta">Posted on 2010-01-30 20:20:53 by f0dder</div>
   </div>
   <div class="post" id="post-210515">
    <div class="subject"><a href="#post-210515">Re: the unicode or ansi strings</a></div>
    <div class="body"><div class="quote">It actually seems like a slightly weird API function to me, anyway... can&#039;t think of a lot of (normal) situations where it&#039;d be useful.</div><br /><br />That&#039;s what I&#039;ve been saying all along.<br /><br /><div class="quote">I&#039;ve never <strong>bumped into</strong> UTF-16 (API calls don&#039;t really count as &quot;bump into&quot;)</div><br /><br />You may have, but never noticed :)<br />Eg, Visual Studio will save files in UTF-16 format if you use special characters. But obviously it will open them correctly because it knows how to detect ASCII or UTF-16 source files.<br /><br /><div class="quote">but I&#039;ve bumped into &quot;unclassified&quot; UTF-8 on <strong>several</strong> occasions. Usually related to web browsers or servers not having specified content-type correctly, but not limited to that.</div><br /><br />That&#039;s what I&#039;ve been saying all along. If you don&#039;t know the encoding, something must have gone wrong.</div>
    <div class="meta">Posted on 2010-01-31 04:23:26 by Scali</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29778&amp;page=1" style="">&laquo;</a><a href="../?id=29778&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29778" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>