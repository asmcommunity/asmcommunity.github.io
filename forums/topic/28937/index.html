<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force] - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=28937" />
    <link rel="next" href="../?id=28937&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=28937">Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=28937&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=28937&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="28937" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=28937&amp;page=2">&gt;</a><a href="../?id=28937&amp;page=2">&raquo;</a></form>   <div class="post" id="post-204604">
    <div class="subject"><a href="#post-204604">Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">I&#039;ve decided to write a tutorial document about physics simulation, ostensibly for game development, and with stability and speed in mind.<br />If you have questions, or spot any errors, feel free to reply and I will make appropriate changes, but do note that I will be regularly deleting any bug reports from this thread afterwards, just to keep the thread &quot;tidy&quot; as this thread is not intended to contain informal discussion except where it directly bears on the work at hand.<br />This text will be updated at my leisure.<br /><br />With that said, here are my notes:<br /><br /><br /><br /><br /><br />3D Simulation:<br />Coordinate Systems, Transformation Matrices, and Similarity Transformations<br /><br />What&#039;s WORLD SPACE?<br />World Space is the fixed 3D space describing the entire world (universe), with its fixed set of axes and its fixed Origin.<br />The Origin of WorldSpace is simply (0,0,0) - that&#039;s the middle of our &#039;universe&#039;.<br />World Space never changes, but things can move around in it.<br /><br />OK, I knew that, What&#039;s BODY SPACE?<br />Body Space is the local coordinate system of some entity in our world.<br />In this Space, the Body is in its &quot;Bind Pose&quot;, ie, unrotated and untranslated.<br />Its probably easiest to understand using an example.<br />Let&#039;s say we defined a 3D Cube.<br />Its Origin is declared at (0,0,0), and it has no rotation.<br />We can say that the cube is DECLARED IN BODYSPACE.<br />We might want to Translate (move) it somewhere in WorldSpace, and also maybe Rotate it.<br />In fact, lets assume that we want MANY cubes in our world, at various locations and orientations.<br />In order to achieve this, we could either declare each cube&#039;s worldspace vertices explicitly, or we could build (for each cube instance) a TRANSFORMATION MATRIX which positions and orients (transforms) our &#039;reference cube&#039; from BodySpace into WorldSpace.<br />We simply apply this matrix to each vertex in our &#039;bodyspace declaration&#039;, and we now have the positions of those vertices in WorldSpace.<br />It&#039;s worth mentioning at this point that transforming values from one coordinate system to another does not change any mechanical quantity, its just a way of looking at the same data from a different point of view.<br />The numbers change, but only because we are seeing them in another frame of reference.<br />Transformation matrices move values between frames of reference.<br />From the point of view of a translated cube, it&#039;s located at 0,0,0 and the world origin is somewhere else :)&nbsp; <br /><br />And now for something completely different.<br /><br />Let&#039;s say we wanted to test for the intersection of a Ray and our Cube.<br />The Ray has been given in WorldSpace.<br />The Cube has been declared in BodySpace, and has six Planes to test against, also declared in BodySpace.<br />Do you think we should transform each Plane into WorldSpace and test it against the Ray?<br />No, thats painfully slow, and not necessary.<br />We can transform the Ray from WorldSpace into the BodySpace of our Cube EVEN WHEN IT IS ORIENTED AND POSITIONED.<br />This is backwards :)<br />Once we transform the Ray from WorldSpace into BodySpace, we can test it against the UNROTATED planes :)<br />How would we do this, since our transform matrix only goes from bodyspace to worldspace !!?!<br />All we need to do is find the &#039;inverse&#039; of our transform matrix<br />This makes a &#039;backwards matrix&#039;, which we can use to transform in the &#039;other direction&#039;. Calculating the Inverse of a general matrix is rather costly, but if we know that the matrix contains ONLY rotational information, then we can apply the &quot;Transpose&quot; operator to find its inverse... just imagine that we are flipping the Axes, but not the Angles about those axes, you&#039;ll see that its true.<br />Transpose() is MUCH faster than Inverse(), but ONLY useful for (typically 3x3) Rotation Matrices. If we wanted to use this method to quickly invert a 4x4 Matrix that contains only rotation and position, we would transpose the rotation elements of the matrix, and flip the signs of the positional elements.<br />If it contains anything else, we have to do it the hard way (not covered here).<br /><br />And now a tricky one.<br />Let&#039;s say we wanted some &#039;bee&#039; entity to orbit around our Cube, regardless of its orientation or position.<br />We want to move into the (translated and rotated) bodyspace of our cube, then we want to move and rotate (relative to the cube) in order to position our &#039;bee&#039;, and then we want to know where that bee is located in WorldSpace.<br /><br />Lets say the bee&#039;s transform (again, relative to cube bodyspace) is called B, <br />and that A = our Body-to-World matrix, and tA = our World-to-Body matrix <br /><br /> then:<br />C = A*B*Inverse(A)<br /><br />We have calculated a third matrix C whose function is to spit out the location of our bee in WorldSpace.<br />Using C to transform our bee ONCE is far cheaper than transforming it several times, especially when we come to &#039;articulated bodies&#039; such as &#039;Skinned Meshes&#039;, think about how you might find the end of your Big Toe in worldspace, you would have to transform your toe many times indeed.<br /><br />In summary, a Similarity Transform is used to get us from Space A to Space B, perform some manipulative transform in Space B, and get us back to Space A, where we started from.<br /><br />So now we know something about coordinate systems, transform matrices, and similarity transforms.<br /><br />Now I&#039;d like to turn this discussion toward physics simulation, and in particular, the simulation of Rigid Bodies in three dimensions. I will not make this a lesson in physics however, I will be concentrating on the application of matrices to differentiate and integrate the equations of motion.<br /><br />We will begin by discussing the &#039;Inertia Tensor&#039; in some detail, which will include the concept of Diagonalising a symmetric, orthogonal matrix (such as a tensor or general transform matrix), and a decription of the Primary Axes of Rotation.<br /><br />What&#039;s a RIGID BODY?<br />It&#039;s a geometric entity (such as a geometric primitive, a mesh, or even a random cloud of points) whose geometry never changes (although it may be free to rotate, it is never deformed), and which has MASS (due to the Density of the material from which it is formed - I will not explain simple concepts of physics in this article, although I will mention them, its up to YOU to find out what those are all about).<br /><br />What&#039;s an INERTIA TENSOR?<br />Also known as &quot;Mass Moment of Inertia Tensor&quot;, or simply &quot;MMOI tensor&quot;.<br />It&#039;s a matrix which describes the distribution of mass of a Body.<br />For some common geometries, this matrix is Known, we just plug in the appropriate values.<br />But we can calculate an Inertia Tensor for any Rigid Body, ie, ANY ARBITRARY GEOMETRY.<br />I&#039;ll explain how to do that immediately, and then explain how MMOI tensors are useful to us.<br /><br />To calculate the tensor, we NEED to know the Mass of the Body, and we may need to calculate the Center of Mass (COM) of the Body, which is NOT NECESSARILY the same as its Origin, OR its &#039;Centroid&#039;. Calculation of the COM is based on the concept that our Body is comprised of &quot;Particles of Mass&quot;, ie, we attribute some Mass to each Vertex in our Body (be patient, I&#039;ll get to that too).<br />For now, let&#039;s assume we KNOW what our Body weighs. We know the Mass. But we don&#039;t know the COM.<br /><br />Here&#039;s some sourcecode that calculates the COM by integrating over the Volume of the Body.<br />I won&#039;t explain how it works, investigate COM further in your own time, I have too much to cover !!<br /><br /><div class="quote"><br />	float3 CenterOfMass(const float3 *vertices, const int3 *tris, const int count) <br />	{<br />		// count is the number of triangles (tris) <br />		float3 com(0,0,0);<br />		float&nbsp; volume=0; // actually accumulates the volume*6<br />		for(int i=0; i &lt; count; i++)&nbsp; // for each triangle<br />		{<br />			float3x3&nbsp; A(vertices [ tris <em> [0] ],<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  vertices [ tris <em> [1] ],<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  vertices [ tris <em> [2] ]);&nbsp; <br />			float vol=Determinant(A);&nbsp; // dont bother to divide by 6 <br />			com += vol * (A.x+A.y+A.z);&nbsp; // divide by 4 at end<br />			volume+=vol;<br />		}<br />		com /= volume*4.0f; <br />		return com;<br />	}<br /></div><br /><br />Let&#039;s get back on track... <br />The MMOI tensor is defined as:<br />+Ixx -Ixy -Ixz<br />-Ixy +Iyy -Iyz<br />-Ixz -Iyz +Izz<br /><br />Note that some of the values in this matrix are repeated - in fact, its a Symmetrical matrix, because if we apply the Transpose operator to it (swap the Diagonals), the matrix is not changed at all.<br /><br />The elements of the tensor are calculated as follows:<br />m = &quot;sum of particle&quot;<br />Ixx = m.y^2+m.z^2 (ie, sum of all particle ysquared + zsquared)<br />Iyy = m.x^2+m.z^2<br />Izz = m.x^2+m.y^2<br />Ixy = m.x * m.y<br />Ixz = m.x * m.z<br />Iyz = m.y * m.z<br /><br />Armed with that information, we can now make a MMOI tensor for any shape, but lets take a look at some of the &quot;Known&quot; tensors for Primitives. Note that they are all &quot;diagonal&quot; matrices :)<br /><br />For a SOLID Sphere, the tensor is:<br />(2/5m.x*R^2) 0 0<br />0 (2/5m.y*R^2) 0<br />0 0 (2/5m.z*R^2)<br /><br />For a HOLLOW Sphere, the tensor is:<br />(2/3m.x*R^2) 0 0<br />0 (2/3m.y*R^2) 0<br />0 0 (2/3m.z*R^2)<br /><br />For a SOLID Box, the tensor is:<br />(m.y^2+m.z^2)/12 0 0<br />0 (m.x^2+m.z^2)/12 0<br />0 0 (m.x^2+m.y^2)/12<br /><br />There are more &#039;Known&#039; tensors for simple shapes, but the thing to notice about all of the above shapes is that the tensor is very much like an Identity matrix, except that we have some Scaled values in the diagonals instead of simply having 1.0 in there. These are all examples of &quot;diagonalised matrices&quot;.<br />For more complex shapes, the tensor we calculate will not always be diagonal.<br />The statements I am about to make are NOT meant to be obvious to the reader:<br />A diagonal tensor implies that the mass of the Body is evenly distributed about the axes... and for ANY arbitrary Body, there exists some orientation where this is TRUE.<br />If the tensor we calculated is not Diagonal, we can make it so (see Jacobian Rotation and Gauss-Jordan Elimination for two possible solutions), and in doing so, we can calculate a Matrix that gets us from BodySpace into &quot;Diagonalised BodySpace&quot;, and we can then Transpose it to find its counterpart, which moves us from DSpace back to BSpace. Furthermore, according to the Similarity Transform technique, we can find matrices that will get us from WorldSpace into DSpace, and as usual, we can Transpose it.<br /><br />Why is it NICE to work in the Diagonalised BodySpace? Why can&#039;t we just use a &quot;messy&quot; tensor?<br />We CAN, but its far slower than working in DSpace, because when we want to multiply the tensor with something else, we can treat the Diagonal (non-zero) elements as a Vector3,&nbsp; and ignore all the Zeros, a huge speedup!!<br />So, DSpace is really some Orientation of our BodySpace axes, ie, its a BSpace coordinate system that has been rotated about the Body&#039;s COM.<br />Are we comfortable with the concept of working in &quot;another spatial coordinate system&quot; other than WorldSpace?<br />We should be by now!<br /><br />Now we know what Diagonalised BodySpace is, and why it&#039;s nice, and what a Diagonal matrix is, and what a Diagonalised MMOI tensor is, but we still haven&#039;t explained WHY we need a tensor at all!<br />What is the Inertia Tensor GOOD FOR?<br /><br />Well, if we apply a Force to our Body, depending on where we apply it relative to the COM, it will try to move and/or rotate... the Inertia Tensor can be used to calculate how input forces affect the linear and angular momentum, which in turn cause this motion and rotation stuff to happen.... it can be used to calculate exactly how the body behaves when we poke it with a stick :)<br /><br />Ok, it might not be a stick, the forces can come from rockets, punches, explosions, motors, springs, gravity, whatever... forces cause changes in momentum, and the tensor is a tool to calculate that change.<br /><br />Now that we can calculate changes in (linear and angular, aka &#039;total&#039;) momentum, we know pretty much everything we need to know in order to simulate rigid bodies which conserve &quot;total momentum&quot; in response to input forces , ie, which &#039;conserve energy&#039; (one of the Laws of Physics).<br /><br />I won&#039;t cover collision detection and response in this article, suffice to say that it involves the calculation of collision forces at the moment of impact.<br /><br /><br />You&#039;re still here? Good !! That was a heck of a lot to take in, wasn&#039;t it?<br />I&#039;m sure it&#039;s already got you thinking :)<br /><br />A note about stability: FIX YOUR TIMESTEP. <br />It&#039;s so important, it deserves its own discussion !!<br />One of the WORST things you can do is simply hand &quot;fElapsedTime&quot; to your physics code. This is not obvious, but the result of &quot;jitter&quot; in the elapsed time is magnified and accumulated in the physical state of your entities. Just don&#039;t do it.<br />How do we fix our timestep in such a way that our simulation runs at the same speed on all machines? We use a Time Accumulator, in much the same way as we might measure the rendering framerate.<br /><br />Let&#039;s say that we&#039;ve decided to apply a fixed timestep of 0.100 seconds.<br />1. At the start of the simulation, we set fAccumulatedTime to zero.<br />2. Inside our Rendering loop, we add elapsed time to the accumulator.<br />3. Now we check if the accumulated time is greater than the Fixed TimeStep.<br />If it is, we subtract one TimeStep from the accumulator, and repeat Step 3.<br />This means that on slower machines we might be performing several physics updates for each rendered Frame, and the fps might suffer.. I won&#039;t talk about this now.<br />But if the accumulated time is LESS than a TimeStep (common on fast machines), then we are &quot;not yet ready to update the physics&quot; - and have &quot;spare time&quot;. It might be tempting to just render another Frame, but there&#039;s really not much point doing that since our entities haven&#039;t been updated, so we might think of other ways to use up this &quot;spare time&quot; that we have detected.<br />4. Since we have updated our Entities, we should now Render them all.<br /><br />Now our TimeStep is fixed, and still dependant on elapsed time :)<br />I cannot stress how important this is to creating a STABLE simulation, and we really don&#039;t want stuff flying off into infinity (or vibrating annoyingly) if we can avoid it, do we?<br /><br />It&#039;s almost time to start introducing some real code, so let&#039;s put together a quick list of major milestones that we&#039;re going to need to reach on our way to coolness:<br /><br />1. Mass<br />For starters, we can just plug in some arbitrary Mass value for each entity, but later we might want to calculate it from Density and Volume.<br /><br />2. Calculate Inertia Tensor (in BodySpace)<br />For starters, we can just plug in some Known tensor for each entity, but later we might want to calculate it from Mass and Geometry.<br /><br />3. Calculate Inverse of the Inertia Tensor (in WorldSpace)<br />This is MUCH easier if we have a Diagonal tensor to begin with.<br />We have talked of WorldSpace, BodySpace and DiagonalisedSpace.<br />Diagonalising a Body does two things : it shifts the origin of the Body to coincide with the Center of Mass of the Body, and it rotates the Body such that the Principle Axes of the Body coincide with the World Axes.<br /><br /> Ro is the (initial) bodyspace-to-worldspace rotation transform matrix for a given Body..<br />rotPos and linPos represent the rotation and translation in WSpace.<br />oRotPos and oLinPos represent the rotation and translation in BSpace.<br />diagRotPos and diagLinPos represent the rotation and translation in DSpace.<br /><br />The transform from BSpace to WSpace is :<br />(A) Rw = oRotPos * Ro + oLinPos <br />The transform from BSpace to DSpace is :<br />&nbsp; &nbsp; &nbsp; Rd = diagRotPos * Ro + diagLinPos<br />The transform from DSpace to BSpace is:<br />(B) Ro =&nbsp; transpose(diagRotPos) * (Rd - diagLinPos)<br />Finally, the transform from DSpace to WSpace is:<br />(C) Rw = rotPos * Rd + linPos<br /> Now substituting (B) in (A) :<br />&nbsp; &nbsp; &nbsp; Rw = oRotPos * trans(diagRotPos) * (Rd - diagLinPos) + oLinPos<br />(D) Rw = oRotPos * trans(diagRotPos) * (Rd - oRotPos * trans(diagRotPos)) * diagLinPos + oLinPos<br /><br />Compare (D) with (C) , we can see how to directly obtain World-relative rotation, position and velocity...<br />&nbsp; &nbsp; &nbsp;  rotPos = oRotPos * trans(diagRotPos)<br />&nbsp; &nbsp; &nbsp;  linPos = oLinPos - oRotPos * trans(diagRotPos) * diagLinPos<br />&nbsp; &nbsp; &nbsp;  rotVel = diagRotPos * oRotVel<br /><br />To calculate Initial linear Velocity (linVel) :<br />&nbsp; &nbsp; &nbsp;  COM is Rd = 0, so from (B) :<br />&nbsp; &nbsp; &nbsp;  COM_Ro = trans(diagRotPos) * (-diagLinPos)<br />&nbsp; &nbsp; &nbsp;  velocity of COM (BSpace) = oRotVel x COM_Ro<br />&nbsp; &nbsp; &nbsp;  velocity of COM (WSpace) =&nbsp; oRotPos * (oRotVel x COM_Ro) + oLinVel<br /><br />Enough of those formula, you&#039;re giving me a headache, and it makes me want to stop reading this right now!! If thats true, take a break, you&#039;ve earned it.<br /><br /><br /><br /><br /><br /><br />We&#039;re ready to start writing code!<br />I know, there&#039;s MOUNTAINS of stuff I have yet to cover, and so far, I&#039;ve really thrown you in at the deep end, forcing you to sink or swim. Unfair of me? Well just think, we&#039;ve covered all the HARD stuff, so now it&#039;s all downhill from here - it can only get easier. Other texts present the information from easiest to hardest, so you start off readin and think &quot;gee, this is all simple stuff that anyone can do&quot; , and by the time you get to the end, you&#039;re struggling to keep your head above water, panicking, and wondering what the hell you have gotten yourself into, and whether you can really do it. By presenting the hard stuff up front, anyone who is STILL reading has a fair idea of what to expect. I think that&#039;s more fair on the reader than giving them an inferiority complex apon reading the last page in the book :)<br /><br />GET CODING!<br />I will present all code using ObjAsm32&#039;s oopasm syntax.<br />If you don&#039;t like it, stiff cheese - this text is aimed at that audience, you can translate it.<br />Let&#039;s start with the entrypoiny to our Simulator, called from the main application loop.<br /><br /><div class="quote"><br />Object Simulator, SimID, Primer<br />	StaticMethod Simulate, real4<br />	StaticMethod Update<br />	DefineVariable fTimeAccumulator, real4, 0.0f<br />	DefineVariable fTimeStep, real4, 0.100f<br />ObjectEnd<br /><br />Method Simulator.Simulate, uses esi, fElapsedTime:real4<br />	SetObject esi<br />	;Accumulate the elapsed time<br />	fld fElapsedTime<br />	fadd .fTimeAccumulator<br />	fstp .fTimeAccumulator<br />	;Check if its time to update physics yet<br />@@:	fMin .fTimeAccumulator, .fTimeStep<br />	fstpReg eax<br />	.if eax==.fTimeStep<br />		;Yes, its time to update our physics<br />		OCall Simulator.Update<br />		;Subtract one physics timestep from the accumulator,<br />		;then jump back to see if we require further updates<br />		fld&nbsp; .fTimeAccumulator<br />		fsub .fTimeStep<br />		fstp&nbsp; .fTimeAccumulator<br />		jmp @B<br />	.endif<br />MethodEnd<br /></div><br /><br />It&#039;s a good start, yes?<br />Next, we will write our Update method.<br />We&#039;ll start with something rather basic, and extend apon it later.<br /><br /></div>
    <div class="meta">Posted on 2008-01-24 01:47:24 by Homer</div>
   </div>
   <div class="post" id="post-204605">
    <div class="subject"><a href="#post-204605">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">We&#039;re on a roll, so let&#039;s maintain our momentum, shall we?<br /><br />Here I shall present the Update method, which is called by Simulate(), and is responsible for advancing the physics state of our closed system (universe) by one full TimeStep.<br /><br />If we evolve the system forward in time and find we have a collision to deal with, we then Half the Timestep and try again, bisecting the timestep until we find a &quot;happy place&quot; BEFORE the intersection occurred, then we bisect the timestep AGAIN,&nbsp; and continue moving forwards in time, repeating this until the penetration depth is below a given threshold. By doing this, we have implemented a &quot;binary search in time&quot; to find the moment when the entities made contact (ie the &quot;kissing moment&quot;).<br />When we have found it, we then resolve the collision, apply the new forces, and continue to the end of the timestep.<br />You will notice that I will be using &quot;Runge-Kutta Integration&quot; aka RK4.<br />It&#039;s four times slower than Euler Integration that you learned at school, but its also 4 times more accurate.<br />This may be the only place that you&#039;ll see me choose accuracy over speed, but since integration is so important to simulating physics, I think its worth doing well.<br /><br /><div class="quote"><br />Method Simulator.Update,uses esi,DeltaTime:real4<br />local CurrentTime,TargetTime<br /><br />	SetObject esi<br />&nbsp; &nbsp; m2m TargetTime , DeltaTime	;Set up the &quot;time until end of complete Step&quot;<br />	mov CurrentTime,0<br />&nbsp; &nbsp; .repeat		;.while CurrentTime &lt; DeltaTime<br /><br />&nbsp; &nbsp; <br />&nbsp; &nbsp; 	fMin CurrentTime, DeltaTime<br />&nbsp; &nbsp; 	fstpReg eax<br />&nbsp; &nbsp; 	.break .if eax==DeltaTime<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; 	;Advance the State by one FULL RK Step<br />&nbsp; &nbsp; 	OCall RKInit			;set up for RK SUBSTEP<br />	&nbsp; &nbsp; OCall ComputeForces		;find linForce and rotForce (from linPos, linVel, rotPos, rotVel.)<br />	&nbsp; &nbsp; OCall RKStep123, 1		;perform the SUBSTEP<br /><br />&nbsp; &nbsp; 	OCall RKInit<br />	&nbsp; &nbsp; OCall ComputeForces	&nbsp; &nbsp; <br />	&nbsp; &nbsp; OCall RKStep123, 2<br /><br />&nbsp; &nbsp; 	OCall RKInit<br />	&nbsp; &nbsp; OCall ComputeForces	&nbsp; &nbsp; <br />	&nbsp; &nbsp; OCall RKStep123, 3<br /><br />&nbsp; &nbsp; 	OCall RKInit<br />&nbsp;  	&nbsp; &nbsp; OCall ComputeForces	&nbsp; &nbsp; <br />	&nbsp; &nbsp; OCall RKStep4<br />	&nbsp; &nbsp; <br />	&nbsp; &nbsp; <br />	&nbsp; &nbsp; ;Check for and resolve any collisions<br />		OCall CheckForCollisions<br />		.if eax == Penetrating<br />			; we simulated too far, so SUBDIVIDE TIMESTEP and try again..<br />			; By doing this, we have implemented a Binary Search in Time<br />			; for the &#039;moment of contact&#039; when the collision will occur.<br />			; IE, we are looking for the moment of &quot;KISSING CONTACT&quot;<br />			; In theory, its possible to calculate that Time,<br />			; and advance the system directly to that Time, which would<br />			; eliminate this binary-search approach, but I&#039;ll leave that<br />			; for a possible future reworking of this code.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fld TargetTime<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fmul r4_Half<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fstp TargetTime<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; blow up if we aren&#039;t moving forward each step, which is<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; probably caused by interpenetration at the frame start<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fMin DeltaTime, fEpsilon<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fstpReg eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==DeltaTime<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 	DbgWarning &quot;Error - failed to find non-penetrating state&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 	DbgWarning &quot;Physics Simulation Terminated!&quot;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 	<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 	int 3<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .else 			;either Touching or Clear<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />	&nbsp; &nbsp; &nbsp; &nbsp; ;Any (Touching) collision has already been Resolved.<br />	&nbsp; &nbsp; &nbsp; &nbsp; ;We should now check the Kinetic Energy of this body..<br />	&nbsp; &nbsp; &nbsp; &nbsp; ;If its close to zero, we can flag the body as being &#039;at rest&#039;.<br />	&nbsp; &nbsp; &nbsp; &nbsp; ;Bodies that are Resting are not tested as &quot;collision aggressors&quot;<br />	&nbsp; &nbsp; &nbsp; &nbsp; ;but can still be involved in collisions with MOVING bodies.<br />			;...<br />			;...<br /><br />			; We&#039;ve made a successful (sub)step, so update our timecounter(s)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m2m CurrentTime , TargetTime&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m2m TargetTime , DeltaTime<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; .until 0<br />&nbsp; &nbsp; ;We have moved the simulation ahead by one full timestep - yay!!!<br />&nbsp; &nbsp; <br />MethodEnd<br /></div><br /><br /><br />The idea is that CheckForCollisions() performs tests between pairs of Bodies, and terminates early if a collision OR touching state is found.<br />The collision is resolved immediately, forces calculated and applied, and the simulation continues.<br />This does not work for cases of multiple contact, I will give an example of how this affects our simulator, and then we will make the necessary changes to support multiple simultaneous contacts properly.<br /><br />Imagine that we have a pool table, and in the middle of the pool table is one ball, at rest (Ball A)<br />Two humans stand at each end of the table, and each has a pool ball placed on the table in front of them (Balls B and C).<br />Let&#039;s suppose that they each launch their ball toward Ball A, and furthermore that their balls both make contact with Ball A simultaneously.<br />In the real world, the result is that energy is transferred THROUGH Ball A, between Balls B and C, which then bounce away, leaving Ball B at rest.<br />Our simulator tests PAIRS of entities, and resolves collisions immediately.<br />If we tried doing this experiment with our simulator, Ball B would collide with Ball A, and they&#039;d both start moving... then Ball C would hit Ball A, and Ball A would be reflected back toward Ball B - it would NOT BE AT REST, and the simulation would not be correct.<br />It&#039;s just an example, but multiple contact resolution is desirable - and we can do it cheaply.<br /><br />The solution is to add a &quot;force accumulator&quot; to each Body.<br />During collision detection, contact forces are calculated but NOT applied immediately.<br />Our collision detector does NOT terminate when the first collision is found.<br />Instead, it checks ALL pairs of entities, accumulates forces for each entity involved in a collision, and then when it has completed, the accumulated force of each entity is applied, and the simulation can then continue.<br /><br />With that said, let&#039;s do a little work on the RigidBody class itself, and then we&#039;ll get back to the simulator.<br />We&#039;ll start with the guts, filling in the blanks as we go, which seems to be a theme among many programmers, and indeed, designers in general.<br /><br />Note that I am inheriting the D3D_Mesh class, but I will nonetheless be redefining most of the methods in that class.<br /><br /><div class="quote"><br />Object RigidBody, RigidBodyID, D3D_Mesh<br />; Runge-Kutta integration stuff - DONT SCREW WITH THESE<br />	DefineVariable linPos0,Vec3,{&lt;&gt;}<br />	DefineVariable linVel0,Vec3,{&lt;&gt;}<br />	DefineVariable rotVel0,Vec3,{&lt;&gt;}<br />	DefineVariable qRotPos0,Quaternion,{&lt;&gt;}<br />	DefineVariable rotPos0,Mat33,{&lt;&gt;}<br />	DefineVariable linVel1,Vec3,{&lt;&gt;}<br />	DefineVariable rotVel1,Vec3,{&lt;&gt;}<br />	DefineVariable linAcc1,Vec3,{&lt;&gt;}<br />	DefineVariable rotAcc1,Vec3,{&lt;&gt;}<br />	DefineVariable linVel2,Vec3,{&lt;&gt;}<br />	DefineVariable rotVel2,Vec3,{&lt;&gt;}<br />	DefineVariable linAcc2,Vec3,{&lt;&gt;}<br />	DefineVariable rotAcc2,Vec3,{&lt;&gt;}<br />	DefineVariable linVel3,Vec3,{&lt;&gt;}<br />	DefineVariable rotVel3,Vec3,{&lt;&gt;}<br />	DefineVariable linAcc3,Vec3,{&lt;&gt;}<br />	DefineVariable rotAcc3,Vec3,{&lt;&gt;}<br /><br />; Constant properties of body<br />	DefineVariable mass,real4<br />	DefineVariable oneOverMass,real4<br />	DefineVariable minusMG,real4			&nbsp; ; -mass * g<br />	DefineVariable cOfM,Vec3,{&lt;&gt;}			; centre of mass (in BSpace coords)<br />	DefineVariable Ix,real4				&nbsp; &nbsp; &nbsp;  ; Ix = sum of mx<br />	DefineVariable Iy,real4<br />	DefineVariable Iz,real4<br />	DefineVariable Ixx,real4					 	 ; Ixx = sum of m(y^2 + z^2)<br />	DefineVariable Iyy,real4<br />	DefineVariable Izz,real4 <br />	DefineVariable Ixy,real4						 ; Ixy = sum of mxy<br />	DefineVariable Iyz,real4						 ; these are in BSpace coords<br />	DefineVariable Izx,real4<br /><br />; DSpace stuff<br />	DefineVariable diagRotPos,Mat33,{&lt;&gt;}			 ; transform from BSpace to DSpace<br />	DefineVariable diagLinPos,Vec3,{&lt;&gt;}				 ; Rd = diagRotPos * Rb + diagLinPos<br />	DefineVariable diagIxx,real4					 ; transformed moment of inertia (DSpace)<br />	DefineVariable diagIyy,real4					 ; also 1 / I * h for Euler integrater<br />	DefineVariable diagIzz,real4<br />	DefineVariable oneOverDiagIxx,real4<br />	DefineVariable oneOverDiagIyy,real4 <br />	DefineVariable oneOverDiagIzz,real4<br />	DefineVariable diagIyyMinusIzzOverIxx,real4<br />	DefineVariable diagIzzMinusIxxOverIyy,real4<br />	DefineVariable diagIxxMinusIyyOverIzz,real4<br /><br />; damping <br />	DefineVariable linKD,&nbsp; real4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; linear damping (-ve and multiplied by mass)<br />	DefineVariable rotKDx, real4				; angular damping (-ve and multiplied by Ixx, etc..)<br />	DefineVariable rotKDy, real4<br />	DefineVariable rotKDz, real4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br /><br />; current state of body<br />	DefineVariable linPos,Vec3,{&lt;&gt;}			;linear position and velocity<br />	DefineVariable linVel,Vec3,{&lt;&gt;}			;of centre of mass (Rd = 0). (WorldSpace)<br /><br />	DefineVariable rotPos,Mat33,{&lt;&gt;}		; rotational position. <br />	; transform from DSpace to WorldSpace is:<br />	; Rw = rotPos * Rd + linPos<br /><br />	DefineVariable qRotPos,Quaternion,{&lt;&gt;}	; quaternion of rotPos matrix (matrix and quaternion are kept the same)<br />	DefineVariable rotVel,Vec3,{&lt;&gt;}&nbsp; &nbsp; &nbsp; &nbsp;  ; rotational velocity (DSpace)<br /><br />; current forces on body<br />	DefineVariable linForce,Vec3,{&lt;&gt;}&nbsp; &nbsp; &nbsp; ;&lt;- this is our Force Accumulator :)<br />	DefineVariable rotForce,Vec3,{&lt;&gt;}<br /><br />;Tags and Bools and other stuff I ADDED<br />	DefineVariable dBodyType,dword,NULL<br />	DefineVariable bHasKineticEnergy,BOOL,FALSE			;TRUE = moving, FALSE = resting<br />	;Only valid for Boxes and Clouds<br />	DefineVariable NumberOfBoundingVertices,dword,NULL<br />	DefineVariable pvBoundingVertices,Pointer,NULL<br />	DefineVariable CoefficientOfRestitution,real4,1.0f<br />ObjectEnd<br /></div><br /><br />That might seem like a lot, and it is.<br />It&#039;s a LOT more than you&#039;d find in , say, a particle simulator.<br />And I still haven&#039;t listed any Methods!<br />But many of those data fields are only needed when we are using non-primitive bodies, ie, when we need to diagonalise our inertia tensor because its not already diagonal (note : geometric primitives are).<br />And I won&#039;t be talking about diagonalising until later.<br />So you can effectively ignore many of them.<br />You may be wondering why there&#039;s four copies of some fields.<br />These are needed to pass information statefully between RK integration steps.<br />You might also want to know about that Quaternion / Matrix deal.<br />We will be converting our rotation matrix into a quat mainly to improve the stability by using it to constrain the matrix to &quot;orthonormality&quot; (orthogonal and normal). Also, we can find places where we can use the resulting quat to speed up some calculations.<br /><br />Here&#039;s the list of Methods for RigidBody:<br /><div class="quote"><br />	RedefineMethod Init, Pointer,Pointer,PointerLPVEC3,LPVEC3,LPQUAT,LPVEC3,real4,real4	;(ptr_oLinPos, ptr_oLinVel, ptr_oQRotPos,&nbsp; oRotVel,&nbsp; linKD, rotKD)<br />&nbsp; &nbsp; &nbsp; <br /><br />; functions to set up rigid body mass distribution<br />	StaticMethod clear<br />	StaticMethod setBox,LPVEC3,real4		;XYZ radius, Mass<br />	StaticMethod setCylinder,real4,real4,real4		;(radius, height, mass);<br />	StaticMethod setSphere,real4,real4				;(radius, mass);<br />	StaticMethod combine,Pointer,LPMAT33,LPVEC3		;(ptr_otherbody, ptr_rotPos, ptr_linPos);<br /><br />; functions for initialising rigid body etc<br />	StaticMethod InitMesh, Pointer, Pointer, Pointer&nbsp;  ;pOwner, pD3D, pTextureManager<br />	StaticMethod diagonalise<br />	StaticMethod setStepSize,real4<br /><br />; functions to update from one frame to another<br />	StaticMethod RKInit<br />	StaticMethod eulerStep<br />	StaticMethod RKStep123, dword<br />	StaticMethod RKStep4<br />	StaticMethod undo<br /><br /> functions to add force and torque<br />	StaticMethod addBodyTorque,LPVEC3					;(Vector3 &amp; torque);<br />	StaticMethod addWorldTorque,LPVEC3					;(Vector3 &amp; torque);<br />	StaticMethod addWorldWorldForce,LPVEC3,LPVEC3		;(Vector3 &amp; force, Vector3 &amp; pos);<br />	StaticMethod addWorldBodyForce,LPVEC3,LPVEC3		;(Vector3 &amp; force, Vector3 &amp; pos);<br />	StaticMethod addBodyBodyForce,LPVEC3,LPVEC3		;(Vector3 &amp; force, Vector3 &amp; pos);<br /><br />; functions to get current position and velocity of points<br />	StaticMethod findWorldPos,LPVEC3,LPVEC3			;(Vector3 &amp; bodyPos, Vector3 &amp; worldPos);<br />	StaticMethod findBodyPos,LPVEC3,LPVEC3			;(Vector3 &amp; worldPos, Vector3 &amp; bodyPos);<br />	StaticMethod findBodyWorldVel,LPVEC3,LPVEC3		;(Vector3 &amp; bodyPos, Vector3 &amp; worldVel);<br />	StaticMethod findWorldWorldVel,LPVEC3,LPVEC3		;(Vector3 &amp; worldPos, Vector3 &amp; worldVel);<br />	StaticMethod findWorldPosVel,LPVEC3,LPVEC3,LPVEC3;(Vector3 &amp; bodyPos, Vector3 &amp; worldPos, Vector3 &amp; worldVel);<br /><br />; functions for getting energy and momentum (for testing etc)<br />	StaticMethod energy<br />	StaticMethod momentum,LPVEC3,LPVEC3				;(Vector3 &amp; lin, Vector3 &amp; rot);<br /></div><br /><br />Whoa!! That&#039;s a fair whack of code we can expect in this class!!<br />Some of these methods are utilitiarian and you won&#039;t need them.<br />But most are required by our simulator.<br /><br />Next we&#039;ll start to look at the code for these methods, I&#039;ll be slapping the necessary physics information into the text on a need-to-know basis.<br />The main thing to note here is that before a body can be simulated, it needs to be Initialized.<br />We need to set up the initial physical state of the body.<br />For that, we have the Init method, and that&#039;s where I&#039;ll begin.<br /></div>
    <div class="meta">Posted on 2008-01-24 02:22:57 by Homer</div>
   </div>
   <div class="post" id="post-204606">
    <div class="subject"><a href="#post-204606">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">The Init method requires some discussion.<br /><br />The input params..<br />poLinPos, poLinVel&nbsp; = ptrs to initial position and velocity (WSpace)<br />poQRotPos&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = ptr to initial rotation quat (WSpace...will automatically be normalized)<br />poRotVel&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  = ptr to initial angular velocity (BSpace)<br />linKD, rotKD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  = damping constants. will get scaled by the mass.<br /><br />Initially, we should set all Matrices and Quaternions to &quot;Identity&quot; values.<br />Then we either call InitMesh to initialize the ancestpr D3D_Mesh object and calculate the inertia tensor, or alternatively,we can call one of the setGeometryShape (eg setBox) methods to set up our inertia tensor.<br />Then we call the Init method to set up the Mass properties. <br />Note that Init() will call diagonalise() even if the tensor is already diagonal.<br />This can be improved on.<br /><br />;-------------------------------------------------------------------------------------<br /><div class="quote"><br />Method RigidBody.Init,uses esi, poLinPos:LPVEC3, poLinVel:LPVEC3, poQRotPos:LPQUAT, poRotVel:LPVEC3,linKD:real4, rotKD:real4<br />LOCAL oRotPos:Mat33<br />LOCAL M1:Mat33<br />LOCAL t1:Vec3<br />LOCAL COM:Vec3		; centre of mass in old body coords<br />&nbsp; &nbsp; SetObject esi<br /><br />&nbsp; &nbsp; ;Set up 1/Mass<br />&nbsp; &nbsp; .if .fMass!=0<br />&nbsp; &nbsp; &nbsp;  fld1<br />&nbsp; &nbsp; &nbsp;  fld .mass<br />&nbsp; &nbsp; &nbsp;  fdiv<br />&nbsp; &nbsp; &nbsp;  fstp .oneOverMass<br />&nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp;  mov .oneOverMass,0<br />&nbsp; &nbsp; .endif&nbsp; &nbsp; <br /><br />&nbsp; &nbsp; ;find matrix of initial rotation (convert quaternion to mat33)<br />&nbsp; &nbsp; ;oRotPos = fromQuatL2(oQRotPos, mod2(oQRotPos))<br />&nbsp; &nbsp; mov edx,poQRotPos<br />&nbsp; &nbsp; Quaternion_mod2 .Quaternion<br />&nbsp; &nbsp; fstpReg eax<br />&nbsp; &nbsp; invoke Mat33_fromQuatL2, addr oRotPos, poQRotPos,eax<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Diagonalize the rotation matrix (using Jacobian rotation method):<br />&nbsp; &nbsp; ;If we can &#039;magically&#039; make all the non-diagonal (products of inertia) elements of<br />&nbsp; &nbsp; ;our intertia tensor matrix become zero, leaving only the diagonals,<br />&nbsp; &nbsp; ;we have found an orientation where the mass is evenly distributed around the axes...<br />	;The non-zero diagonals are called the principal moments of inertia of the object.&nbsp; &nbsp; <br />&nbsp; &nbsp; OCall diagonalise<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;You know what a TRANSPOSED matrix is, and what its use is?<br />&nbsp; &nbsp; ;Lets transpose our Diagonalised inertia tensor: M1 = transpose(diagRotPos)<br />&nbsp; &nbsp; invoke RtlMoveMemory,addr M1, addr .diagRotPos, sizeof Mat33<br />&nbsp; &nbsp; Mat33_transpose M1<br /><br />	;You know what a SIMILARITY TRANSFORM is, and what its use is?<br />	;Prepare a SIMILARITY TRANFORM MATRIX: rotPos = oRotPos * M1<br />&nbsp; &nbsp; invoke Mat33_multiply,addr .rotPos,addr oRotPos, addr M1<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Convert M1 into Quaternion form<br />&nbsp; &nbsp; ;qRotPos = fromMatrix(rotPos)<br />&nbsp; &nbsp; invoke Quaternion_fromMatrix, addr .qRotPos, addr .rotPos<br /><br />&nbsp; &nbsp; ;t1 = rotPos * diagLinPos<br />&nbsp; &nbsp; Vec3_mult_Mat33 .rotPos, .diagLinPos<br />&nbsp; &nbsp; fstp t1.z<br />&nbsp; &nbsp; fstp t1.y<br />&nbsp; &nbsp; fstp t1.x<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;linPos = oLinPos - t1<br />&nbsp; &nbsp; mov edx,poLinPos<br />&nbsp; &nbsp; fld .Vec3.x<br />&nbsp; &nbsp; fsub t1.x<br />&nbsp; &nbsp; fstp .linPos.x<br />&nbsp; &nbsp; fld .Vec3.y<br />&nbsp; &nbsp; fsub t1.y<br />&nbsp; &nbsp; fstp .linPos.y<br />&nbsp; &nbsp; fld .Vec3.z<br />&nbsp; &nbsp; fsub t1.z<br />&nbsp; &nbsp; fstp .linPos.z<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;rotVel = diagRotPos * oRotVel<br />&nbsp; &nbsp; mov edx,poRotVel&nbsp; &nbsp; <br />&nbsp; &nbsp; Vec3_mult_Mat33 .diagRotPos, .Vec3<br />&nbsp; &nbsp; fstp .rotVel.z<br />&nbsp; &nbsp; fstp .rotVel.y&nbsp;  <br />&nbsp; &nbsp; fstp .rotVel.x<br /><br />&nbsp; &nbsp; ;COM = transpose(diagRotPos) * (-diagLinPos)<br />&nbsp; &nbsp; Vec3_transMult .diagRotPos, .diagLinPos<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fstp COM.z<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fstp COM.y<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fstp COM.x<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;t1 = oRotVel x COM_Ro (note : crossproduct)<br />&nbsp; &nbsp; mov edx,poRotVel<br />&nbsp; &nbsp; CrossProduct .Vec3, COM<br />&nbsp; &nbsp; fstp t1.z<br />&nbsp; &nbsp; fstp t1.y<br />&nbsp; &nbsp; fstp t1.x<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;velocity of COM (world coords)<br />&nbsp; &nbsp; ;linVel = (oRotPos * t1) + oLinVel&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; Vec3_mult_Mat33 oRotPos, t1<br />&nbsp; &nbsp; mov edx,poLinVel<br />&nbsp; &nbsp; fadd .Vec3.z<br />&nbsp; &nbsp; fstp .linVel.z<br />&nbsp; &nbsp; fadd .Vec3.y<br />&nbsp; &nbsp; fstp .linVel.y<br />&nbsp; &nbsp; fadd .Vec3.x<br />&nbsp; &nbsp; fstp .linVel.x<br /><br />&nbsp; &nbsp; ;scale damping by mass<br />&nbsp; &nbsp; ;this-&gt;linKD&nbsp; = -linKD / oneOvermass&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; ;this-&gt;rotKDx = -rotKD * diagIxx<br />&nbsp; &nbsp; ;this-&gt;rotKDy = -rotKD * diagIyy<br />&nbsp; &nbsp; ;this-&gt;rotKDz = -rotKD * diagIzz<br />&nbsp; &nbsp; fld linKD<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fdiv.oneOverMass<br />&nbsp; &nbsp; fstp .linKD<br />&nbsp; &nbsp; fld rotKD<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fmul .diagIxx<br />&nbsp; &nbsp; fstp .rotKDx<br />&nbsp; &nbsp; fld rotKD<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fmul .diagIyy<br />&nbsp; &nbsp; fstp .rotKDy<br />&nbsp; &nbsp; fld rotKD<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fmul .diagIzz<br />&nbsp; &nbsp; fstp .rotKDz<br />&nbsp; &nbsp; <br />MethodEnd<br /></div><br /><br />RigidBody class can handle various kinds of primitive geometry, as well as complex geometries (meshes).<br />Furthermore, it can Combine the attributes of several Bodies (of any kind) into a single composite body!!<br />Let&#039;s look at one of the geometry selection methods.<br />Here&#039;s one of our Known tensors being initialized :)<br /><div class="quote"><br />Method RigidBody.setSphere,uses esi,radius:real4,mass:real4<br />&nbsp; &nbsp; SetObject esi<br />&nbsp; &nbsp; m2m .mass,mass<br />&nbsp; &nbsp; xor edx,edx<br />&nbsp; &nbsp; mov .cOfM.x,edx<br />&nbsp; &nbsp; mov .cOfM.y,edx<br />&nbsp; &nbsp; mov .cOfM.z,edx<br />&nbsp; &nbsp; mov .Ix,edx<br />&nbsp; &nbsp; mov .Iy,edx<br />&nbsp; &nbsp; mov .Iz,edx&nbsp; &nbsp;  <br />&nbsp; &nbsp; mov .Ixy,edx<br />&nbsp; &nbsp; mov .Iyz,edx<br />&nbsp; &nbsp; mov .Izx,edx&nbsp; 	<br />&nbsp; &nbsp; ;Ixx = Iyy = Izz = mass * radius * radius * 2.0 / 5.0;<br />&nbsp; &nbsp; fld radius<br />&nbsp; &nbsp; fmul st(0),st(0)<br />&nbsp; &nbsp; fmul mass<br />&nbsp; &nbsp; fadd st(0),st(0)<br />&nbsp; &nbsp; fdiv r4_5<br />&nbsp; &nbsp; fst&nbsp; .Ixx<br />&nbsp; &nbsp; fst&nbsp; .Iyy<br />&nbsp; &nbsp; fstp .Izz<br />&nbsp; &nbsp; mov .dBodyType,BODY_TYPE_SPHERE<br />MethodEnd<br /></div><br /><br />And while we&#039;re at it, here&#039;s the InitMesh method, which merely calls the ancestor D3D_Mesh.Init method, we need this if we wish to apply accurate physics to complex meshes.<br /><div class="quote"><br />Method RigidBody.InitMesh,uses esi,pOwner,pD3D,pTexManager<br />&nbsp; &nbsp;  SetObject esi<br />&nbsp; &nbsp;  ACall esi.Init, pOwner,pD3D,pTexManager<br />MethodEnd<br /></div><br /><br />Voila, inertia tensor for any kind of solid sphere, based on mass and radius.<br />With the exception of the diagonalise method, we&#039;ve pretty much got our body initializing code in place.<br />It&#039;s worth mentioning that I&#039;ll be extending the D3D material structure to add physical attributes to Materials which are then available for application to groups of faces of a given mesh.<br />We&#039;ll be able to describe the physical texture of a surface in more detail than mere optics!<br />Imagine if our pool table was covered in mud , or someone spilled a sticky drink on it :)<br /><br />Next we&#039;ll take a look at the diagonalise method, then we might take another good stare at our simulator class and start filling some gaps.<br />See, anyone can do this stuff :)<br /></div>
    <div class="meta">Posted on 2008-01-24 04:08:10 by Homer</div>
   </div>
   <div class="post" id="post-204608">
    <div class="subject"><a href="#post-204608">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">The diagonalise() method is used to find the transform to convert body from BSpace into DSpace. This makes the moment of inertia matrix diagonal, and makes the centre of mass coincide with the Body origin.<br />The transform from BSpace&#039; to DSpace is :<br />&nbsp;  Rd = diagRotPos * Ro + diagLinPos<br />;-------------------------------------------------------------------------------------<br /><br /><div class="quote"><br />Method RigidBody.diagonalise,uses esi<br />LOCAL identity:Mat33<br />LOCAL I:Mat33		; moment of inertia (old coords)<br />LOCAL cOfM:Vec3<br />	Mat33_identity identity<br />&nbsp;  <br />&nbsp; &nbsp; ;Vector3 cOfM(-Ix / mass, -Iy / mass, -Iz / mass);&nbsp;  // centre of mass in old coords<br />&nbsp; &nbsp; SetObject esi<br />&nbsp; &nbsp; fld .Ix<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fmul .oneOverMass<br />&nbsp; &nbsp; fstp cOfM.x<br />&nbsp; &nbsp; ;<br />&nbsp; &nbsp; fld .Iy<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fmul .oneOverMass<br />&nbsp; &nbsp; fstp cOfM.y<br />	;<br />&nbsp; &nbsp; fld .Iz<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fmul .oneOverMass<br />&nbsp; &nbsp; fstp cOfM.z<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; OCall clear<br />&nbsp; &nbsp; OCall combine, esi, addr identity, addr cOfM		; shift centre of mass to origin<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ;Build BSpace tensor<br />&nbsp; &nbsp; &nbsp; &nbsp; ;Ixx, -Ixy, -Izx,<br />&nbsp; &nbsp; &nbsp; &nbsp; ;-Ixy, Iyy, -Iyz,<br />&nbsp; &nbsp; &nbsp; &nbsp; ;-Izx, -Iyz, Izz<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; m2m I.M0,.Ixx<br />&nbsp;  	fld .Ixy<br />&nbsp;  	fchs<br />&nbsp;  	fstp I.M1<br />&nbsp;  	fld .Izx<br />&nbsp;  	fchs<br />&nbsp;  	fstp I.M2<br />&nbsp;  	;<br />&nbsp;  	fld .Ixy<br />&nbsp;  	fchs<br />&nbsp;  	fstp I.M3<br />&nbsp;  	m2m I.M4, .Iyy<br />&nbsp;  	fld .Iyz<br />&nbsp;  	fchs<br />&nbsp;  	fstp I.M5<br />&nbsp;  	;<br />&nbsp;  	fld .Izx<br />&nbsp;  	fchs<br />&nbsp;  	fstp I.M6<br />&nbsp;  	fld .Iyz<br />&nbsp;  	fchs<br />&nbsp;  	fstp I.M7<br />&nbsp;  	m2m I.M8, .Izz<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ; find diagonalising transform with eigen vectors<br />&nbsp; &nbsp; ; this is the transform that would get us from DSpace back into BSpace.<br />&nbsp; &nbsp; lea edx,.diagIxx	;ptr to target vecx, ie, Ixx Iyy Izz are all affected<br />&nbsp; &nbsp; invoke Mat33_eigenvectors,addr .diagRotPos,edx,addr I&nbsp;  <br />&nbsp; &nbsp; ; We actually want the inverse (from BSpace to DSpace).<br />&nbsp; &nbsp; ; Since the matrix is a rotation matrix, we can use transpose ()<br />&nbsp; &nbsp; Mat33_transpose .diagRotPos<br /><br />&nbsp; &nbsp; ;Calculate the Body&#039;s position in DSpace<br />&nbsp; &nbsp; ;diagLinPos = diagRotPos * cOfM<br />&nbsp; &nbsp; Vec3_mult_Mat33 .diagRotPos, cOfM<br /><br />; now precalculate some useful numbers for speed ups<br />	fld1<br />	fdiv .diagIxx<br />	fstp .oneOverDiagIxx<br />	fld1<br />	fdiv .diagIyy<br />	fstp .oneOverDiagIyy<br />	fld1<br />	fdiv .diagIzz<br />	fstp .oneOverDiagIzz<br />	fld1<br />	fdiv .mass<br />	fstp .oneOverMass<br />	fld .mass<br />	fchs<br />	fmul g<br />	fstp .minusMG<br />	fld&nbsp; .diagIyy<br />	fsub .diagIzz<br />	fdiv .diagIxx<br />	fstp .diagIyyMinusIzzOverIxx<br />	fld&nbsp; .diagIzz<br />	fsub .diagIxx<br />	fdiv .diagIyy<br />	fstp .diagIzzMinusIxxOverIyy<br />	fld&nbsp; .diagIxx<br />	fsub .diagIyy<br />	fdiv .diagIzz<br />	fstp .diagIxxMinusIyyOverIzz<br />	fld&nbsp; .diagIzz<br />	fsub .diagIyy<br />	fstp .diagIzzMinusIyy<br />	fld&nbsp; .diagIxx<br />	fsub .diagIzz<br />	fstp .diagIxxMinusIzz<br />	fld&nbsp; .diagIyy<br />	fsub .diagIxx<br />	fstp .diagIyyMinusIxx<br />MethodEnd<br /></div><br /><br />Mat33_eigenvectors is the heart of this method.<br />It diagonalizes the matrix using &quot;Jacobian rotation&quot;, where we &quot;rotate away&quot; the nonzero components of the tensor, and simultaneously builds a matrix which would &quot;undo&quot; all those rotations.<br />The result is that we get a diagonal matrix, and the inverse matrix that would convert the diagonal matrix into the original one.<br /><br />I won&#039;t show that code here, I will simply promise that it&#039;s in the sourcecode archive which will (soon) be attached to this document.<br /><br />Now assuming that we can supply the inertia tensor of an arbitrary body, we can now produce a DSpace tensor, and matrices to transform between DSpace and BSpace, for ANY arbitrary Body.<br />The beauty about working in DSpace is that since our tensor only contains three values, we can treat the tensor as a Vector, which is a huge speedup when we want to use it in our math :)<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-01-24 06:56:43 by Homer</div>
   </div>
   <div class="post" id="post-204609">
    <div class="subject"><a href="#post-204609">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">Let&#039;s leave the RigidBody class alone for a while, and get back to the simulator class.<br />I&#039;ve added a little more meat to the bare bones presented so far.<br />The main thing that should catch your eye is that the simulator class supports Springs, via Hooke&#039;s Law.<br />A Spring is a Constraint that we can apply to a pair of Bodies.<br />As its name suggests, a Spring can be stiff and rigid, or soft and flexible, but either way, its job is to maintain the distance between two anchor points on two Bodies, irrespective of their orientations.<br />We can also anchor one end of a Spring to a point in WorldSpace, effectively &#039;tethering&#039; the Body.<br />Springs are useful for ALL KINDS of things, and are an excellent introduction into the application of physical constraints (yes, theres many other kinds I won&#039;t talk about) in our simulation.<br /><br />I&#039;ve described Springs as a structure which keeps track of the two anchor points and who owns them.<br />A Spring knows which Body or Bodies it affects, not the other way around.<br />That&#039;s why I&#039;ve implemented Springs here in the simulator class rather than somewhere else.<br />In fact, I&#039;ve described two kinds : WorldSpring and BodySpring, using separate structs.<br /><br />Of course, we don&#039;t NEED springs, but having them is very nice.<br />Hey, we don&#039;t need Gravity either, but you can&#039;t make a necklace out of Gravity, or do pendulum stuff, or make a rope bridge, etc etc.<br /><br />The methods that mention &quot;random bodies&quot; are only there for demonstration purposes... they&#039;ll help us get an interesting demo together more quickly.<br /><br /><div class="quote"><br />Object Simulator,sid,Collection<br />	RedefineMethod Init, Pointer,Pointer,Pointer, real4,real4,real4, dword 	 ;pOwner,pD3D,pTexManager, fWorldX, fWorldY, fWorldZ, dNumRandomBodies<br />	RedefineMethod Done<br />	StaticMethod Simulate, real4								;fDeltaTime<br />	StaticMethod Create_Spring_WorldBody,LPVEC3,dword,dword		;pvAnchor, iBody, iHullVertex<br />	StaticMethod Create_Spring_BodyBody,dword,dword,dword,dword	;iBodyA, iHullVertexA, iBodyB, iHullVertexB<br />	StaticMethod GetTransform,LPD3DXMATRIX,dword<br />&nbsp; &nbsp; <br />	Private<br />		StaticMethod InitializeRandomBodies,dword<br />		StaticMethod ComputeForces<br />		StaticMethod Integrate,real4 			;fDeltaTime<br />		StaticMethod CheckForCollisions<br />		StaticMethod ResolveCollision,LPBODY,LPVEC3,LPVEC3	;pTouchingBody,pPointOnBody,pCollisionNormal<br />		StaticMethod CalculateVertices,dword	;dStateIndex <br />		StaticMethod Update<br />	PrivateEnd<br />	<br />	DefineVariable GravityActive,		BOOL,	TRUE<br />	DefineVariable DampingActive,		BOOL,	FALSE<br />	DefineVariable BodySpringsActive,	BOOL,	FALSE<br />	DefineVariable WorldSpringsActive,	BOOL,	FALSE<br />	DefineVariable Gravity,				real4, -0.86f<br />	DefineVariable CollisionNormal,		Vec3,	{&lt;&gt;}<br />	DefineVariable NumberOfWalls,		dword,6<br />	DefineVariable NumberOfBodySprings,	dword,NULL<br />	DefineVariable NumberOfWorldSprings,dword,NULL<br />	Embed BodySprings,&nbsp; DataCollection<br />	Embed WorldSprings, DataCollection<br />ObjectEnd<br /></div><br /><br />The ancestor collection is used to keep a list of all the Bodies in the simulation.<br />The embedded datacollections keep arrays of springs.<br />And I think we should take a closer look at springs next, so let&#039;s check out some structures:<br /><br /><div class="quote"><br />;The 3x3 Matrix structure, if you wish to address as 1D array<br />Mat33 struct<br />	M0 real4 ?<br />	M1 real4 ?<br />	M2 real4 ?<br />	M3 real4 ?<br />	M4 real4 ?<br />	M5 real4 ?<br />	M6 real4 ?<br />	M7 real4 ?<br />	M8 real4 ?<br />Mat33 ends<br /><br />;The 3x3 Matrix structure, if you wish to address as 2D array<br />mat33 struct<br />	M00 real4 ?<br />	M01 real4 ?<br />	M02 real4 ?<br />	M10 real4 ?<br />	M11 real4 ?<br />	M12 real4 ?<br />	M20 real4 ?<br />	M21 real4 ?<br />	M22 real4 ?<br />mat33 ends<br /><br />;World Springs tether a Body to a fixed point in WorldSpace.<br />world_spring struct<br />	pBody dd ?						;Body this Spring is attached to<br />&nbsp; &nbsp; BodyAnchor&nbsp; Vec3 &lt;&gt;				;Where in BodySpace this Spring is attached<br />&nbsp; &nbsp; HookesConstant real4 ?<br />&nbsp; &nbsp; WorldAnchor Vec3 &lt;&gt;				;Where in WorldSpace this Spring is anchored<br />&nbsp; &nbsp; Dampening real4 ?<br />world_spring ends<br /><br />;Body Springs tether two Bodies to each other.<br />;Again, attachment points are existing boundingvertices only.<br />body_spring struct<br />	pBodyA dd ?					;Body A<br />	pBodyB dd ?					;Body B<br />&nbsp; &nbsp; BodyAnchorA Vec3 &lt;&gt;			;Where in BSpace this Spring was attached to on Body A<br />&nbsp; &nbsp; HookesConstant real4 ?<br />&nbsp; &nbsp; BodyAnchorB Vec3 &lt;&gt;			;Where in BSpace this Spring was attached to on Body B&nbsp; <br />&nbsp; &nbsp; Dampening real4 ?<br />body_spring ends<br /><br /></div><br /><br />Note that our Springs support individual settings for &quot;flexibility&quot; (Hookes Const.) and &quot;stiffness&quot; (Dampening). By adding these, we get a lot more control if/when/where we want it, and it also causes our Vector fields to be aligned on dword boundaries, which in turn yields a nice speedup by preventing a performance penalty on some architectures.<br /><br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-01-24 07:47:24 by Homer</div>
   </div>
   <div class="post" id="post-204610">
    <div class="subject"><a href="#post-204610">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">I want to talk more about collision detection now.<br />Our first demo will not use collision detection at all, but I&#039;d still like to present it now.<br /><br /><div class="quote"><br />;Check all Bodies in the Simulator for collisions, and Resolve all Collisions.<br />Method Simulator.CheckForCollisions,uses esi ecx<br />LOCAL CollisionState,Counter<br />LOCAL vCollisionPoint:Vec3		;in worldspace, relative to body origin<br />LOCAL vCollisionNormal:Vec3		;for a wall, its the surface normal<br /><br />	SetObject esi	<br />&nbsp; &nbsp; mov CollisionState , Clear			&nbsp; &nbsp; ; be optimistic!<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />	;Checking each Body in the Simulator which is NOT &quot;at rest&quot;<br />	;to find if it has collided with ANYTHING (at rest or not).<br />	xor ecx,ecx<br />	.while ecx &lt; .dCount &amp;&amp; CollisionState!=Penetrating<br />		push ecx		<br />		shl ecx,2<br />		add ecx,.pItems<br />		OCall CheckBodyForCollisions,dword ptr,addr vCollisionPoint ,addr CollisionNormal<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if CollisionState == Clear<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov CollisionState ,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif&nbsp; eax==Touching<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;The Bodies are kissing - We can calculate the response force now<br />			mov Counter,0<br />			.repeat&nbsp; &nbsp; &nbsp; 	&nbsp; &nbsp; 	<br />				OCall ResolveCollision,dword ptr,pvCollisionPointOut,pvCollisionNormalOut<br />&nbsp; &nbsp; &nbsp; &nbsp;  	&nbsp;  		mov CollisionState,$OCall (CheckBodyForCollisions,dword ptr,addr vCollisionPoint,addr vCollisionNormal)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  	&nbsp;  		.break .if eax!=Penetrating|| Counter==100<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 		inc Counter<br />	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 	.until 0<br />			.if Counter==100<br />				DbgWarning &quot;Error - failed to resolve Collisions in 100 attempts&quot;<br />				int 3<br />			.endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;The Bodies are Penetrating - we&#039;ll let Simulator search for their kissing-time and tag them.<br />		.endif<br />	&nbsp; &nbsp; &nbsp; &nbsp; pop ecx<br />	&nbsp; &nbsp; &nbsp; &nbsp; inc ecx<br />	.endw<br /><br />	return CollisionState<br />;MethodEnd<br /></div><br /><br />Each Body will be checked for collisions against all other Bodies.<br />The code used to actually perform Body-Body tests is optimized (mainly, according to the types of bodies involved).<br />The ResolveCollision() method is used to accumulate collision forces in our Bodies (multiple contacts), and when testing is completed, this method will tell its caller whether ANY collisions occurred, and if so, the caller can then apply the accumulated forces to the bodies.<br />This implies that each Body will have to store its own &quot;kissing time&quot;, something I&#039;ll have to address !!<br />Resolving a collision implies that we know where and when the collision occurred, and this method will be among the first to know that information.<br />Resolving a collision can result in the bodies being moved clear of one another, or just touching.<br />This is important both for finding the kissing point, and for &quot;rolling contact&quot; :)<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-01-24 08:20:12 by Homer</div>
   </div>
   <div class="post" id="post-204627">
    <div class="subject"><a href="#post-204627">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">Now we&#039;ll turn our attention back to the RigidBody class again.<br />Let&#039;s take a look at those mysterious RK methods, starting with RKInit()<br />Its purpose is to find the &quot;current forces&quot; acting on the Body (linForce and rotForce), which we can obtain from the current Momentum (linear and angular).<br />In fact we don&#039;t even need to know the Momentum, because it is a product of Velocity (again, linear and angular).<br />F = ma , and a = dv/dt<br /><br /><br /><div class="quote"><br />;==================================================================================<br />Method RigidBody.RKInit,uses esi<br />	SetObject esi<br />	<br />	;save position before step is made<br />	m2m .linPos0.x,.linPos.x<br />	m2m .linPos0.y,.linPos.y<br />	m2m .linPos0.z,.linPos.z<br />	m2m .qRotPos0.x,.qRotPos.x<br />	m2m .qRotPos0.y,.qRotPos.y<br />	m2m .qRotPos0.z,.qRotPos.z<br />	m2m .qRotPos0.w,.qRotPos.w<br />	invoke RtlMoveMemory,addr .rotPos0,addr .rotPos,sizeof Mat33<br />	m2m .linVel0.x,.linVel.x<br />	m2m .linVel0.y,.linVel.y<br />	m2m .linVel0.z,.linVel.z<br />	m2m .rotVel0.x,.rotVel.x<br />	m2m .rotVel0.y,.rotVel.y<br />	m2m .rotVel0.z,.rotVel.z<br />	<br />	; built in damping and gravity<br />	fld .linKD<br />	fmul .linVel.x<br />	fstp .linForce.x<br />	<br />	fld .linKD<br />	fmul .linVel.y<br />	fadd .minusMG<br />	fstp .linForce.y<br />	<br /> 	fld .linKD<br />	fmul .linVel.z<br />	fstp .linForce.z<br /><br />	;<br />	fld .rotKDx<br />	fmul .rotVel.x<br />	fstp .rotForce.x<br />	fld .rotKDy<br />	fmul .rotVel.y<br />	fstp .rotForce.y<br />	fld .rotKDz<br />	fmul .rotVel.z<br />	fstp .rotForce.z<br />MethodEnd<br /></div><br /><br />If we know the current Forces acting on the Body, we can apply them to find the new (linear and angular) velocity, position, orientation, whatever we want.<br />RK integration requires four steps, Euler integration just one.<br />Let&#039;s see the code for performing the first 3 RK steps.<br />This method is used to advance the system.<br />Given an input state and input forces, it produces an output state and output forces.<br />Each step feeds its results into the next step.<br />Since the code for the first three steps is so similar, I have written it as one method with casecode.<br />The fourth step is somewhat different.<br /><br /><br /><div class="quote"><br /><br />Method RigidBody.RKStep123,uses esi, iStep<br />local l2, ftemp<br /><br />	SetObject esi<br />	<br />	fld&nbsp; .linForce.x<br />	fmul RKh2<br />	fmul .oneOverMass<br />	fld&nbsp; .rotVel.y<br />	fmul .rotVel.z<br />	fmul .diagIyyMinusIzzOverIxx<br />	fld&nbsp; .rotForce.x<br />	fmul .oneOverDiagIxx<br />	fadd<br />	fmul RKh2<br />	<br />	fld&nbsp; .linForce.y<br />	fmul RKh2<br />	fmul .oneOverMass<br />	fld&nbsp; .rotVel.z<br />	fmul .rotVel.x<br />	fmul .diagIzzMinusIxxOverIyy<br />	fld&nbsp; .rotForce.y<br />	fmul .oneOverDiagIyy<br />	fadd<br />	fmul RKh2<br /><br />	fld&nbsp; .linForce.z<br />	fmul RKh2<br />	fmul .oneOverMass<br />	fld&nbsp; .rotVel.x<br />	fmul .rotVel.y<br />	fmul .diagIxxMinusIyyOverIzz<br />	fld&nbsp; .rotForce.z<br />	fmul .oneOverDiagIzz<br />	fadd<br />	fmul RKh2<br />	<br />	.switch iStep<br />	.case 1<br />	&nbsp; &nbsp; ;rotAcc1.x = (rotVel.y * rotVel.z * diagIyyMinusIzzOverIxx + rotForce.x * oneOverDiagIxx) * RKh2;<br />	&nbsp; &nbsp; ;rotAcc1.y = (rotVel.z * rotVel.x * diagIzzMinusIxxOverIyy + rotForce.y * oneOverDiagIyy) * RKh2;<br />	&nbsp; &nbsp; ;rotAcc1.z = (rotVel.x * rotVel.y * diagIxxMinusIyyOverIzz + rotForce.z * oneOverDiagIzz) * RKh2;<br />	&nbsp; &nbsp; ;linAcc1 = linForce * oneOverMass * RKh2<br />	&nbsp; &nbsp; fstp .rotAcc1.z<br />	&nbsp; &nbsp; fstp .rotAcc1.y<br />	&nbsp; &nbsp; fstp .rotAcc1.x<br />	&nbsp; &nbsp; fstp .linAcc1.z<br />	&nbsp; &nbsp; fstp .linAcc1.y<br />	&nbsp; &nbsp; fstp .linAcc1.x<br />	&nbsp; &nbsp; fUnload<br /><br />	&nbsp; &nbsp; ;linVel1 = linVel<br />	&nbsp; &nbsp; ;rotVel1 = rotVel<br />	&nbsp; &nbsp; m2m .linVel1.x,.linVel.x<br />	&nbsp; &nbsp; m2m .linVel1.y,.linVel.y<br />	&nbsp; &nbsp; m2m .linVel1.z,.linVel.z<br />	&nbsp; &nbsp; m2m .rotVel1.x,.rotVel.x<br />	&nbsp; &nbsp; m2m .rotVel1.y,.rotVel.y<br />	&nbsp; &nbsp; m2m .rotVel1.z,.rotVel.z<br /><br />	&nbsp; &nbsp; ;linPos += RKh2 * linVel1<br />	&nbsp; &nbsp; fld .linVel1.x<br />	&nbsp; &nbsp; fmul RKh2<br />	&nbsp; &nbsp; fld .linVel1.y<br />	&nbsp; &nbsp; fmul RKh2<br />	&nbsp; &nbsp; fld .linVel1.z<br />	&nbsp; &nbsp; fmul RKh2<br />	&nbsp; &nbsp; fadd .linPos.z<br />	&nbsp; &nbsp; fstp .linPos.z<br />	&nbsp; &nbsp; fadd .linPos.y<br />	&nbsp; &nbsp; fstp .linPos.y	&nbsp; &nbsp; <br />	&nbsp; &nbsp; fadd .linPos.x<br />	&nbsp; &nbsp; fstp .linPos.x<br />	&nbsp; &nbsp; 	&nbsp; &nbsp; <br />	&nbsp; &nbsp; ;qRotPos.w -= RKh4 * (qRotPos0.x * rotVel1.x + qRotPos0.y * rotVel1.y + qRotPos0.z * rotVel1.z);<br />	&nbsp; &nbsp; ;qRotPos.x += RKh4 * (qRotPos0.w * rotVel1.x - qRotPos0.z * rotVel1.y + qRotPos0.y * rotVel1.z);<br />	&nbsp; &nbsp; ;qRotPos.y += RKh4 * (qRotPos0.z * rotVel1.x + qRotPos0.w * rotVel1.y - qRotPos0.x * rotVel1.z);<br />	&nbsp; &nbsp; ;qRotPos.z += RKh4 * (qRotPos0.x * rotVel1.y - qRotPos0.y * rotVel1.x + qRotPos0.w * rotVel1.z);<br />	&nbsp; &nbsp; fld .qRotPos0.x<br />	&nbsp; &nbsp; fmul .rotVel1.x<br />	&nbsp; &nbsp; fld .qRotPos0.y<br />	&nbsp; &nbsp; fmul .rotVel1.y<br />	&nbsp; &nbsp; fld .qRotPos0.z<br />	&nbsp; &nbsp; fmul .rotVel1.z<br />	&nbsp; &nbsp; fadd<br />	&nbsp; &nbsp; fadd<br />	&nbsp; &nbsp; fmul RKh4<br />	&nbsp; &nbsp; fstp .qRotPos.w<br />	&nbsp; &nbsp; ;<br />	&nbsp; &nbsp; fld .qRotPos0.w<br />	&nbsp; &nbsp; fmul .rotVel1.x<br />	&nbsp; &nbsp; fld .qRotPos0.z<br />	&nbsp; &nbsp; fmul .rotVel1.y<br />	&nbsp; &nbsp; fsub<br />	&nbsp; &nbsp; fld .qRotPos0.y<br />	&nbsp; &nbsp; fmul .rotVel1.z<br />	&nbsp; &nbsp; fadd<br />	&nbsp; &nbsp; fmul RKh4<br />	&nbsp; &nbsp; fstp .qRotPos.x<br />	&nbsp; &nbsp; ;<br />	&nbsp; &nbsp; fld .qRotPos0.x<br />	&nbsp; &nbsp; fmul .rotVel1.y<br />	&nbsp; &nbsp; fld .qRotPos0.y<br />	&nbsp; &nbsp; fmul .rotVel1.x<br />	&nbsp; &nbsp; fsub<br />	&nbsp; &nbsp; fld .qRotPos0.w<br />	&nbsp; &nbsp; fmul .rotVel1.z<br />	&nbsp; &nbsp; fadd<br />	&nbsp; &nbsp; fmul RKh4<br />	&nbsp; &nbsp; fstp .qRotPos.z<br />		;<br />	&nbsp; &nbsp; fld .qRotPos0.z<br />	&nbsp; &nbsp; fmul .rotVel1.x<br />	&nbsp; &nbsp; fld .qRotPos0.w<br />	&nbsp; &nbsp; fmul .rotVel1.y<br />	&nbsp; &nbsp; fadd<br />	&nbsp; &nbsp; fld .qRotPos0.x<br />	&nbsp; &nbsp; fmul .rotVel1.z<br />	&nbsp; &nbsp; fsub<br />	&nbsp; &nbsp; fmul RKh4<br />	&nbsp; &nbsp; fstp .qRotPos.y&nbsp; &nbsp; <br />	&nbsp; &nbsp; <br />	&nbsp; &nbsp; ;linVel += linAcc1<br />	&nbsp; &nbsp; ;rotVel += rotAcc1<br />	&nbsp; &nbsp; fld .linAcc1.x<br />	&nbsp; &nbsp; fadd .linVel.x<br />	&nbsp; &nbsp; fld .linAcc1.y<br />	&nbsp; &nbsp; fadd .linVel.y<br />	&nbsp; &nbsp; fld .linAcc1.z<br />	&nbsp; &nbsp; fadd .linVel.z<br />	&nbsp; &nbsp; fld .rotAcc1.x<br />	&nbsp; &nbsp; fadd .rotVel.x<br />	&nbsp; &nbsp; fld .rotAcc1.y<br />	&nbsp; &nbsp; fadd .rotVel.y	&nbsp; &nbsp; <br />	&nbsp; &nbsp; fld .rotAcc1.z<br />	&nbsp; &nbsp; fadd .rotVel.z<br /><br />	.case 2<br />	&nbsp; &nbsp; ;rotAcc2.x = (rotVel.y * rotVel.z * diagIyyMinusIzzOverIxx + rotForce.x * oneOverDiagIxx) * RKh2;<br />	&nbsp; &nbsp; ;rotAcc2.y = (rotVel.z * rotVel.x * diagIzzMinusIxxOverIyy + rotForce.y * oneOverDiagIyy) * RKh2;<br />	&nbsp; &nbsp; ;rotAcc2.z = (rotVel.x * rotVel.y * diagIxxMinusIyyOverIzz + rotForce.z * oneOverDiagIzz) * RKh2;<br />	&nbsp; &nbsp; ;linAcc2 = linForce * oneOverMass * RKh2<br />	&nbsp; &nbsp; fstp .rotAcc2.z<br />	&nbsp; &nbsp; fstp .rotAcc2.y<br />	&nbsp; &nbsp; fstp .rotAcc2.x<br />	&nbsp; &nbsp; fstp .linAcc2.z<br />	&nbsp; &nbsp; fstp .linAcc2.y<br />	&nbsp; &nbsp; fstp .linAcc2.x<br />	&nbsp; &nbsp; fUnload<br /><br />	&nbsp; &nbsp; ;linVel2 = linVel;<br />	&nbsp; &nbsp; ;rotVel2 = rotVel;<br />	&nbsp; &nbsp; m2m .linVel2.x,.linVel.x<br />	&nbsp; &nbsp; m2m .linVel2.y,.linVel.y<br />	&nbsp; &nbsp; m2m .linVel2.z,.linVel.z<br />	&nbsp; &nbsp; m2m .rotVel2.x,.rotVel.x<br />	&nbsp; &nbsp; m2m .rotVel2.y,.rotVel.y<br />	&nbsp; &nbsp; m2m .rotVel2.z,.rotVel.z	&nbsp; &nbsp; <br />	&nbsp; &nbsp; <br />	&nbsp; &nbsp; ;linPos = linPos0 + RKh2 * linVel2<br />	&nbsp; &nbsp; fld RKh2<br />	&nbsp; &nbsp; fld .linVel2.x<br />	&nbsp; &nbsp; fmul RKh2<br />	&nbsp; &nbsp; fld .linVel2.y<br />	&nbsp; &nbsp; fmul RKh2<br />	&nbsp; &nbsp; fld .linVel2.z<br />	&nbsp; &nbsp; fmul RKh2<br />	&nbsp; &nbsp; fadd .linPos0.z<br />	&nbsp; &nbsp; fstp .linPos.z<br />	&nbsp; &nbsp; fadd .linPos0.y<br />	&nbsp; &nbsp; fstp .linPos.y	&nbsp; &nbsp; <br />	&nbsp; &nbsp; fadd .linPos0.x<br />	&nbsp; &nbsp; fstp .linPos.x<br /><br />	&nbsp; &nbsp; ;qRotPos.w = qRotPos0.w - RKh4 * (qRotPos0.x * rotVel2.x + qRotPos0.y * rotVel2.y + qRotPos0.z * rotVel2.z);<br />	&nbsp; &nbsp; ;qRotPos.x = qRotPos0.x + RKh4 * (qRotPos0.w * rotVel2.x - qRotPos0.z * rotVel2.y + qRotPos0.y * rotVel2.z);<br />	&nbsp; &nbsp; ;qRotPos.y = qRotPos0.y + RKh4 * (qRotPos0.z * rotVel2.x + qRotPos0.w * rotVel2.y - qRotPos0.x * rotVel2.z);<br />	&nbsp; &nbsp; ;qRotPos.z = qRotPos0.z + RKh4 * (qRotPos0.x * rotVel2.y - qRotPos0.y * rotVel2.x + qRotPos0.w * rotVel2.z);<br />		fld&nbsp; .qRotPos0.w<br />		fld&nbsp; .qRotPos0.x<br />		fmul .rotVel2.x<br />		fld&nbsp; .qRotPos0.y<br />		fmul .rotVel2.y<br />		fld&nbsp; .qRotPos0.z<br />		fmul .rotVel2.z<br />		fadd<br />		fadd<br />		fmul RKh4<br />		fsub<br />		fstp .qRotPos.w<br />		;<br />		fld&nbsp; .qRotPos0.w<br />		fmul .rotVel2.x<br />		fld&nbsp; .qRotPos0.z<br />		fmul .rotVel2.y<br />		fsub<br />		fld&nbsp; .qRotPos0.y<br />		fmul .rotVel2.z<br />		fadd<br />		fmul RKh4<br />		fadd .qRotPos0.x<br />		fstp .qRotPos.x<br />		;<br />		fld&nbsp; .qRotPos0.z<br />		fmul .rotVel2.x<br />		fld&nbsp; .qRotPos0.w<br />		fmul .rotVel2.y<br />		fadd<br />		fld&nbsp; .qRotPos0.z<br />		fmul .rotVel2.z<br />		fsub<br />		fmul RKh4<br />		fadd .qRotPos0.y<br />		fstp .qRotPos.y	<br />		;<br />		fld&nbsp; .qRotPos0.x<br />		fmul .rotVel2.y<br />		fld&nbsp; .qRotPos0.y<br />		fmul .rotVel2.x<br />		fsub<br />		fld&nbsp; .qRotPos0.w<br />		fmul .rotVel2.z<br />		fadd<br />		fmul RKh4<br />		fadd .qRotPos0.z<br />		fstp .qRotPos.z<br /><br />	&nbsp; &nbsp; ;linVel = linVel1 + linAcc2<br />	&nbsp; &nbsp; ;rotVel = rotVel1 + rotAcc2<br />	&nbsp; &nbsp; fld .linAcc2.x<br />	&nbsp; &nbsp; fadd .linVel1.x<br />	&nbsp; &nbsp; fld .linAcc2.y<br />	&nbsp; &nbsp; fadd .linVel1.y<br />	&nbsp; &nbsp; fld .linAcc2.z<br />	&nbsp; &nbsp; fadd .linVel1.z<br />	&nbsp; &nbsp; fld .rotAcc2.x<br />	&nbsp; &nbsp; fadd .rotVel1.x<br />	&nbsp; &nbsp; fld .rotAcc2.y<br />	&nbsp; &nbsp; fadd .rotVel1.y	&nbsp; &nbsp; <br />	&nbsp; &nbsp; fld .rotAcc2.z<br />	&nbsp; &nbsp; fadd .rotVel1.z<br /><br />	.case 3<br />	&nbsp; &nbsp; ;rotAcc3.x = (rotVel.y * rotVel.z * diagIyyMinusIzzOverIxx + rotForce.x * oneOverDiagIxx) * RKh;<br />	&nbsp; &nbsp; ;rotAcc3.y = (rotVel.z * rotVel.x * diagIzzMinusIxxOverIyy + rotForce.y * oneOverDiagIyy) * RKh;<br />	&nbsp; &nbsp; ;rotAcc3.z = (rotVel.x * rotVel.y * diagIxxMinusIyyOverIzz + rotForce.z * oneOverDiagIzz) * RKh;<br />	&nbsp; &nbsp; ;linAcc3 = linForce * oneOverMass * RKh<br />	&nbsp; &nbsp; fstp .rotAcc3.z<br />	&nbsp; &nbsp; fstp .rotAcc3.y<br />	&nbsp; &nbsp; fstp .rotAcc3.x<br />	&nbsp; &nbsp; fstp .linAcc3.z<br />	&nbsp; &nbsp; fstp .linAcc3.y<br />	&nbsp; &nbsp; fstp .linAcc3.x<br />	&nbsp; &nbsp; fUnload<br />	&nbsp; &nbsp; <br />	&nbsp; &nbsp; ;linVel3 = linVel<br />	&nbsp; &nbsp; ;rotVel3 = rotVel<br />	&nbsp; &nbsp; m2m .linVel3.x,.linVel.x<br />	&nbsp; &nbsp; m2m .linVel3.y,.linVel.y<br />	&nbsp; &nbsp; m2m .linVel3.z,.linVel.z<br />	&nbsp; &nbsp; m2m .rotVel3.x,.rotVel.x<br />	&nbsp; &nbsp; m2m .rotVel3.y,.rotVel.y<br />	&nbsp; &nbsp; m2m .rotVel3.z,.rotVel.z	&nbsp; <br /><br />	&nbsp; &nbsp; ;linPos = linPos0 + RKh * linVel3<br />	&nbsp; &nbsp; fld RKh<br />	&nbsp; &nbsp; fld .linVel3.x<br />	&nbsp; &nbsp; fmul RKh<br />	&nbsp; &nbsp; fld .linVel3.y<br />	&nbsp; &nbsp; fmul RKh<br />	&nbsp; &nbsp; fld .linVel3.z<br />	&nbsp; &nbsp; fmul RKh<br />	&nbsp; &nbsp; fadd .linPos0.z<br />	&nbsp; &nbsp; fstp .linPos.z<br />	&nbsp; &nbsp; fadd .linPos0.y<br />	&nbsp; &nbsp; fstp .linPos.y	&nbsp; &nbsp; <br />	&nbsp; &nbsp; fadd .linPos0.x<br />	&nbsp; &nbsp; fstp .linPos.x<br />	&nbsp; &nbsp; <br />	&nbsp; &nbsp; ;qRotPos.w = qRotPos0.w - RKh2 * (qRotPos0.x * rotVel3.x + qRotPos0.y * rotVel3.y + qRotPos0.z * rotVel3.z);<br />	&nbsp; &nbsp; ;qRotPos.x = qRotPos0.x + RKh2 * (qRotPos0.w * rotVel3.x - qRotPos0.z * rotVel3.y + qRotPos0.y * rotVel3.z);<br />	&nbsp; &nbsp; ;qRotPos.y = qRotPos0.y + RKh2 * (qRotPos0.z * rotVel3.x + qRotPos0.w * rotVel3.y - qRotPos0.x * rotVel3.z);<br />	&nbsp; &nbsp; ;qRotPos.z = qRotPos0.z + RKh2 * (qRotPos0.x * rotVel3.y - qRotPos0.y * rotVel3.x + qRotPos0.w * rotVel3.z);<br />	&nbsp; &nbsp; fld&nbsp; .qRotPos0.w<br />	&nbsp; &nbsp; fld&nbsp; .qRotPos0.x<br />	&nbsp; &nbsp; fmul .rotVel3.x<br />	&nbsp; &nbsp; fld&nbsp; .qRotPos0.y<br />	&nbsp; &nbsp; fmul .rotVel3.y<br />	&nbsp; &nbsp; fld&nbsp; .qRotPos0.z<br />	&nbsp; &nbsp; fmul .rotVel3.z<br />	&nbsp; &nbsp; fadd<br />	&nbsp; &nbsp; fadd<br />	&nbsp; &nbsp; fmul RKh2<br />	&nbsp; &nbsp; fsub<br />	&nbsp; &nbsp; fstp .qRotPos.w<br />	&nbsp; &nbsp; ;<br />	&nbsp; &nbsp; fld&nbsp; .qRotPos0.w<br />	&nbsp; &nbsp; fmul .rotVel3.x<br />	&nbsp; &nbsp; fld&nbsp; .qRotPos0.z<br />	&nbsp; &nbsp; fmul .rotVel3.y<br />		fsub<br />	&nbsp; &nbsp; fld&nbsp; .qRotPos0.y<br />	&nbsp; &nbsp; fmul .rotVel3.z<br />	&nbsp; &nbsp; fadd<br />	&nbsp; &nbsp; fmul RKh2<br />	&nbsp; &nbsp; fadd .qRotPos0.x<br />	&nbsp; &nbsp; fstp .qRotPos.x<br />		;<br />	&nbsp; &nbsp; fld&nbsp; .qRotPos0.z<br />	&nbsp; &nbsp; fmul .rotVel3.x<br />	&nbsp; &nbsp; fld&nbsp; .qRotPos0.w<br />	&nbsp; &nbsp; fmul .rotVel3.y<br />		fadd<br />	&nbsp; &nbsp; fld&nbsp; .qRotPos0.x<br />	&nbsp; &nbsp; fmul .rotVel3.z<br />	&nbsp; &nbsp; fsub<br />	&nbsp; &nbsp; fmul RKh2<br />	&nbsp; &nbsp; fadd .qRotPos0.y<br />	&nbsp; &nbsp; fstp .qRotPos.y<br />	&nbsp; &nbsp; ;<br />	&nbsp; &nbsp; fld&nbsp; .qRotPos0.x<br />	&nbsp; &nbsp; fmul .rotVel3.y<br />	&nbsp; &nbsp; fld&nbsp; .qRotPos0.y<br />	&nbsp; &nbsp; fmul .rotVel3.x<br />		fsub<br />	&nbsp; &nbsp; fld&nbsp; .qRotPos0.w<br />	&nbsp; &nbsp; fmul .rotVel3.z<br />	&nbsp; &nbsp; fadd<br />	&nbsp; &nbsp; fmul RKh2<br />	&nbsp; &nbsp; fadd .qRotPos0.z<br />	&nbsp; &nbsp; fstp .qRotPos.z<br />	&nbsp; &nbsp; <br />	&nbsp; &nbsp; ;linVel = linVel1 + linAcc3<br />	&nbsp; &nbsp; ;rotVel = rotVel1 + rotAcc3<br />	&nbsp; &nbsp; fld .linAcc3.x<br />	&nbsp; &nbsp; fadd .linVel1.x<br />	&nbsp; &nbsp; fld .linAcc3.y<br />	&nbsp; &nbsp; fadd .linVel1.y<br />	&nbsp; &nbsp; fld .linAcc3.z<br />	&nbsp; &nbsp; fadd .linVel1.z<br />	&nbsp; &nbsp; fld .rotAcc3.x<br />	&nbsp; &nbsp; fadd .rotVel1.x<br />	&nbsp; &nbsp; fld .rotAcc3.y<br />	&nbsp; &nbsp; fadd .rotVel1.y	&nbsp; &nbsp; <br />	&nbsp; &nbsp; fld .rotAcc3.z<br />	&nbsp; &nbsp; fadd .rotVel1.z<br />	&nbsp; &nbsp; <br />	.endsw	<br />	fstp .rotVel.z<br />	fstp .rotVel.y<br />	fstp .rotVel.x<br />	fstp .linVel.z<br />	fstp .linVel.y<br />	fstp .linVel.x<br /><br />	Quaternion_normalize .qRotPos<br />&nbsp; &nbsp; ;rotPos.fromQuatL2(qRotPos, l2);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // make new orthogonal matrix from quaternion.<br />	invoke Mat33_fromQuatL2,addr .rotPos,addr .qRotPos, l2	<br /><br />	;linForce.x = linKD * linVel.x;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // built in damping and gravity<br />&nbsp; &nbsp; ;linForce.y = linKD * linVel.y+ minusMG;<br />&nbsp; &nbsp; ;linForce.z = linKD * linVel.z <br />	;rotForce.x = rotKDx * rotVel.x;<br />	;rotForce.y = rotKDy * rotVel.y;<br />	;rotForce.z = rotKDz * rotVel.z;<br /><br />	fld .linKD<br />	fmul .linVel.x<br />	fstp .linForce.x	<br />	fld .linKD<br />	fmul .linVel.y<br />	fadd .minusMG<br />	fstp .linForce.y	<br />	fld .linKD<br />	fmul .linVel.z<br />	fstp .linForce.z<br /><br />	fld .rotKDx<br />	fmul .rotVel.x<br />	fstp .rotForce.x<br />	fld .rotKDy<br />	fmul .rotVel.y<br />	fstp .rotForce.y<br />	fld .rotKDz<br />	fmul .rotVel.z<br />	fstp .rotForce.z<br />MethodEnd<br /></div><br /><br /></div>
    <div class="meta">Posted on 2008-01-25 20:37:42 by Homer</div>
   </div>
   <div class="post" id="post-204632">
    <div class="subject"><a href="#post-204632">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">Hi Homer<br />I got some time to read the whole post, but now I have. It is an excellent work&nbsp; :thumbsup:. While reading it, some questions come to my mind.<br /><br /><ul><br /><li>1. When we create our world entities, we define their mass and geometrical properties like weight, inertia tensor, etc. All these are done outside the application in a sort of design environment, so we dont have to compute it so we can concentrate on collisions and animations. Am I right with this assumption? If yes, do you know of such an environment?</li><br /><li>2. Im a little unsure if it is possible synchronize the physics simulation with the rendering while we have no contact of our entities. It would be my first approach. Im sure if this is what you suggest at the top of your second post, before we began to split the time slice to find the contact (kissing) moment.</li><br /><li>3. You say you cumulate forces and dont apply them immediately, When do you apply them? At the end of a physic simulation time slice (= rendering?)</li><br /><li>4. In the simulator object you tell us about springs. Are they always connected to the entities or is there a way to say them to be active depending on the distance between the entities?</li><br /><li>5. Im interested to know how you resolve the collision of entities. Are you using a sort of BSP/Octree algo for this?</li><br /></ul><br /><br />Regards,<br /><br />Biterider<br /><br /></div>
    <div class="meta">Posted on 2008-01-26 01:38:45 by Biterider</div>
   </div>
   <div class="post" id="post-204633">
    <div class="subject"><a href="#post-204633">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body"><div class="quote"><br />&nbsp; &nbsp; * 1. When we create our world entities, we define their mass and geometrical properties like weight, inertia tensor, etc. All these are done outside the application in a sort of design environment, so we dont have to compute it so we can concentrate on collisions and animations. Am I right with this assumption? If yes, do you know of such an environment?<br /></div><br />You can calculate all of these values at initialization time for any arbitrary body.<br />No environment I know of will hand you these values.<br />The only thing you can&#039;t calculate is Density, and you can look up the density of any material on the web.<br /><br /><div class="quote"><br />&nbsp; &nbsp; * 2. Im a little unsure if it is possible synchronize the physics simulation with the rendering while we have no contact of our entities. It would be my first approach. Im sure if this is what you suggest at the top of your second post, before we began to split the time slice to find the contact (kissing) moment.<br /></div><br />It is not desirable to synchronize rendering and physics!<br />Usually, we would like to perform several physics passes for each rendered frame - but if this takes too long, we find ourselves rendering more than one frame per physics update, which is USELESS - because &quot;nothing has moved&quot;. If we have a choice about how we spend our spare time, it should not be wasted by rendering the SAME FRAME of video if nothing has moved!<br /><br /><div class="quote"><br />&nbsp; &nbsp; * 3. You say you cumulate forces and dont apply them immediately, When do you apply them? At the end of a physic simulation time slice (= rendering?)<br /></div><br />We should apply the accumulated forces in RK Step#1, so that they are considered throughout the physics timestep, and alter the output state.<br />In the code I have shown that we calculate &quot;current forces&quot; in the RKInit method, but I have not shown that force being added to the existing force, which is only because the code I am presenting was designed for single contacts, we&#039;ll correct this as we go, well spotted.<br /><br /><div class="quote"><br />&nbsp; &nbsp; * 4. In the simulator object you tell us about springs. Are they always connected to the entities or is there a way to say them to be active depending on the distance between the entities?<br /></div><br />Springs, like anything, can be enabled or disabled. Our springs so far allow you to define the distance that you wish to maintain, the maximum amount of stretch, and the maximum amount of compression.<br />You don&#039;t have to use them at all, but later, we will use them in simple demos for pendulums and ropes, and later still, we can use them in articulated bodies (ragdolls).<br />They are, without doubt, the most useful and powerful &quot;constraint&quot; we will ever need.<br /><br /><div class="quote"><br />&nbsp; &nbsp; * 5. Im interested to know how you resolve the collision of entities. Are you using a sort of BSP/Octree algo for this?<br /></div><br />Collision resolution involves the calculation of the moment of impact, the &quot;collision normal&quot;, and the force generated by the collision (based on velocity and mass of the entities involved).<br />We calculate the resulting force for each body, then we shove it into each body&#039;s force accumulator, where it will linger until we update that body&#039;s state.<br /><br /></div>
    <div class="meta">Posted on 2008-01-26 03:08:06 by Homer</div>
   </div>
   <div class="post" id="post-204634">
    <div class="subject"><a href="#post-204634">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">Here&#039;s the Rk Step #4 method<br /><br /><div class="quote"><br />Method RigidBody.RKStep4,uses esi<br />LOCAL rotVel4:Vec3<br />LOCAL l2, ftemp<br />	SetObject esi	<br />	<br />&nbsp; &nbsp; ;linPos = linPos0 + (linVel1 + 2.0 * (linVel2 + linVel3) + linVel) * RKh6&nbsp; <br />&nbsp; &nbsp; fld&nbsp; .linVel2.x<br />&nbsp; &nbsp; fadd .linVel3.x<br />&nbsp; &nbsp; fadd st(0),st(0)<br />&nbsp; &nbsp; fadd .linVel.x<br />&nbsp; &nbsp; fadd .linVel1.x<br />&nbsp; &nbsp; fmul RKh6<br />&nbsp; &nbsp; fadd .linPos0.x<br />&nbsp; &nbsp; fstp .linPos.x<br />&nbsp; &nbsp; ;<br />&nbsp; &nbsp; fld&nbsp; .linVel2.y<br />&nbsp; &nbsp; fadd .linVel3.y<br />&nbsp; &nbsp; fadd st(0),st(0)<br />&nbsp; &nbsp; fadd .linVel.y<br />&nbsp; &nbsp; fadd .linVel1.y<br />&nbsp; &nbsp; fmul RKh6<br />&nbsp; &nbsp; fadd .linPos0.y<br />&nbsp; &nbsp; fstp .linPos.y<br />&nbsp; &nbsp; ;<br />&nbsp; &nbsp; fld&nbsp; .linVel2.z<br />&nbsp; &nbsp; fadd .linVel3.z<br />&nbsp; &nbsp; fadd st(0),st(0)<br />&nbsp; &nbsp; fadd .linVel.z<br />&nbsp; &nbsp; fadd .linVel1.z<br />&nbsp; &nbsp; fmul RKh6<br />&nbsp; &nbsp; fadd .linPos0.z<br />&nbsp; &nbsp; fstp .linPos.z&nbsp; &nbsp; <br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;rotVel4 = (rotVel1 + rotVel) * 0.5 + rotVel2 + rotVel3<br />&nbsp; &nbsp; fld&nbsp; .rotVel1.x<br />&nbsp; &nbsp; fadd .rotVel.x<br />&nbsp; &nbsp; fmul r4_Half<br />&nbsp; &nbsp; fadd .rotVel2.x<br />&nbsp; &nbsp; fadd .rotVel3.x<br />&nbsp; &nbsp; fstp rotVel4.x<br />&nbsp; &nbsp; ;<br />&nbsp; &nbsp; fld&nbsp; .rotVel1.y<br />&nbsp; &nbsp; fadd .rotVel.y<br />&nbsp; &nbsp; fmul r4_Half<br />&nbsp; &nbsp; fadd .rotVel2.y<br />&nbsp; &nbsp; fadd .rotVel3.y<br />&nbsp; &nbsp; fstp rotVel4.y<br />&nbsp; &nbsp; ;<br />&nbsp; &nbsp; fld&nbsp; .rotVel1.z<br />&nbsp; &nbsp; fadd .rotVel.z<br />&nbsp; &nbsp; fmul r4_Half<br />&nbsp; &nbsp; fadd .rotVel2.z<br />&nbsp; &nbsp; fadd .rotVel3.z<br />&nbsp; &nbsp; fstp rotVel4.z<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;qRotPos.w = qRotPos0.w - RKh6 * (qRotPos0.x * rotVel4.x + qRotPos0.y * rotVel4.y + qRotPos0.z * rotVel4.z);<br />&nbsp; &nbsp; ;qRotPos.x = qRotPos0.x + RKh6 * (qRotPos0.w * rotVel4.x - qRotPos0.z * rotVel4.y + qRotPos0.y * rotVel4.z);<br />&nbsp; &nbsp; ;qRotPos.y = qRotPos0.y + RKh6 * (qRotPos0.z * rotVel4.x + qRotPos0.w * rotVel4.y - qRotPos0.x * rotVel4.z);<br />&nbsp; &nbsp; ;qRotPos.z = qRotPos0.z + RKh6 * (qRotPos0.x * rotVel4.y - qRotPos0.y * rotVel4.x + qRotPos0.w * rotVel4.z);<br />	fld&nbsp; .qRotPos0.w<br />	fld&nbsp; .qRotPos.x<br />	fmul rotVel4.x<br />	fld&nbsp; .qRotPos.y<br />	fmul rotVel4.y	<br />	fld&nbsp; .qRotPos.z<br />	fmul rotVel4.z<br />	fadd<br />	fadd<br />	fmul RKh6<br />	fsub<br />	fstp .qRotPos.w<br />	;<br />	fld&nbsp; .qRotPos0.w<br />	fmul rotVel4.x<br />	fld&nbsp; .qRotPos0.z<br />	fmul rotVel4.y<br />	fsub<br />	fld&nbsp; .qRotPos0.y<br />	fadd rotVel4.z<br />	fadd<br />	fmul RKh6<br />	fadd .qRotPos0.x<br />	fstp .qRotPos.x<br />	;<br />	fld&nbsp; .qRotPos0.z<br />	fmul rotVel4.x<br />	fld&nbsp; .qRotPos0.w<br />	fmul rotVel4.y<br />	fadd<br />	fld&nbsp; .qRotPos0.x<br />	fadd rotVel4.z<br />	fsub<br />	fmul RKh6<br />	fadd .qRotPos0.y<br />	fstp .qRotPos.y<br />	;	<br />	fld&nbsp; .qRotPos0.x<br />	fmul rotVel4.y<br />	fld&nbsp; .qRotPos0.y<br />	fmul rotVel4.x<br />	fsub<br />	fld&nbsp; .qRotPos0.w<br />	fadd rotVel4.z<br />	fadd<br />	fmul RKh6<br />	fadd .qRotPos0.z<br />	fstp .qRotPos.z<br />	<br />	Quaternion_normalize .qRotPos<br />&nbsp; &nbsp; ;rotPos.fromQuatL2(qRotPos, l2);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  // make new orthogonal matrix from quaternion.<br />	invoke Mat33_fromQuatL2,addr .rotPos,addr .qRotPos, l2<br />	<br />&nbsp; 	;linVel = linVel1 + (linAcc1 + 2.0 * linAcc2 + linAcc3 + linForce * oneOverMass * RKh2) * (1.0 / 3.0)<br />&nbsp; 	fld .linAcc2.x<br />&nbsp; 	fadd st(0),st(0)<br />&nbsp; 	fadd .linAcc1.x<br />&nbsp; 	fadd .linAcc3.x<br />&nbsp; 	fld .linForce.x<br />&nbsp; 	fmul .oneOverMass<br />&nbsp; 	fmul RKh2<br />&nbsp; 	fadd<br />&nbsp; 	fdiv r4_3<br />&nbsp; 	fadd .linVel1.x<br />&nbsp; 	fstp .linVel.x<br />&nbsp; 	;<br />&nbsp; 	fld .linAcc2.y<br />&nbsp; 	fadd st(0),st(0)<br />&nbsp; 	fadd .linAcc1.y<br />&nbsp; 	fadd .linAcc3.y<br />&nbsp; 	fld .linForce.y<br />&nbsp; 	fmul .oneOverMass<br />&nbsp; 	fmul RKh2<br />&nbsp; 	fadd<br />&nbsp; 	fdiv r4_3<br />&nbsp; 	fadd .linVel1.y<br />&nbsp; 	fstp .linVel.y<br />&nbsp; 	;<br />&nbsp; 	fld .linAcc2.z<br />&nbsp; 	fadd st(0),st(0)<br />&nbsp; 	fadd .linAcc1.z<br />&nbsp; 	fadd .linAcc3.z<br />&nbsp; 	fld .linForce.z<br />&nbsp; 	fmul .oneOverMass<br />&nbsp; 	fmul RKh2<br />&nbsp; 	fadd<br />&nbsp; 	fdiv r4_3<br />&nbsp; 	fadd .linVel1.z<br />&nbsp; 	fstp .linVel.z<br /> <br />&nbsp; 	;rotVel4.x = rotVel1.x + (rotAcc1.x + 2.0 * rotAcc2.x + rotAcc3.x + (rotVel.y * rotVel.z * diagIyyMinusIzzOverIxx + rotForce.x * oneOverDiagIxx) * RKh2) * (1.0 / 3.0);<br />&nbsp; 	fld .rotAcc2.x<br />&nbsp; 	fadd st(0),st(0)<br />&nbsp; 	fadd .rotAcc1.x<br />&nbsp; 	fadd .rotAcc3.x<br />&nbsp; 	fld&nbsp; .rotVel.y<br />&nbsp; 	fmul .rotVel.z<br />&nbsp; 	fmul .diagIyyMinusIzzOverIxx<br />&nbsp; 	fld .rotForce.x <br />&nbsp; 	fmul .oneOverDiagIxx<br />&nbsp; 	fadd<br />&nbsp; 	fadd<br />&nbsp; 	fmul RKh2<br />&nbsp; 	fdiv r4_3<br />&nbsp; 	fadd .rotVel1.x<br />&nbsp; 	fstp rotVel4.x<br />&nbsp; 	<br />&nbsp; 	;rotVel4.y = rotVel1.y + (rotAcc1.y + 2.0 * rotAcc2.y + rotAcc3.y + (rotVel.z * rotVel.x * diagIzzMinusIxxOverIyy + rotForce.y * oneOverDiagIyy) * RKh2) * (1.0 / 3.0);<br />&nbsp; 	fld .rotAcc2.y<br />&nbsp; 	fadd st(0),st(0)<br />&nbsp; 	fadd .rotAcc1.y<br />&nbsp; 	fadd .rotAcc3.y<br />&nbsp; 	fld&nbsp; .rotVel.z<br />&nbsp; 	fmul .rotVel.x<br />&nbsp; 	fmul .diagIzzMinusIxxOverIyy<br />&nbsp; 	fld .rotForce.y<br />&nbsp; 	fmul .oneOverDiagIyy<br />&nbsp; 	fadd<br />&nbsp; 	fadd<br />&nbsp; 	fmul RKh2<br />&nbsp; 	fdiv r4_3<br />&nbsp; 	fadd .rotVel1.y<br />&nbsp; 	fstp rotVel4.y<br /><br />&nbsp; 	;rotVel4.z = rotVel1.z + (rotAcc1.z + 2.0 * rotAcc2.z + rotAcc3.z + (rotVel.x * rotVel.y * diagIxxMinusIyyOverIzz + rotForce.z * oneOverDiagIzz) * RKh2) * (1.0 / 3.0);<br />&nbsp; 	fld .rotAcc2.z<br />&nbsp; 	fadd st(0),st(0)<br />&nbsp; 	fadd .rotAcc1.z<br />&nbsp; 	fadd .rotAcc3.z<br />&nbsp; 	fld&nbsp; .rotVel.x<br />&nbsp; 	fmul .rotVel.y<br />&nbsp; 	fmul .diagIxxMinusIyyOverIzz<br />&nbsp; 	fld .rotForce.z<br />&nbsp; 	fmul .oneOverDiagIzz<br />&nbsp; 	fadd<br />&nbsp; 	fadd<br />&nbsp; 	fmul RKh2<br />&nbsp; 	fdiv r4_3<br />&nbsp; 	fadd .rotVel1.z<br />&nbsp; 	fstp rotVel4.z<br /><br /><br />&nbsp; &nbsp; ;rotVel = rotVel4<br />&nbsp; &nbsp; m2m .rotVel.x, rotVel4.x<br />&nbsp; &nbsp; m2m .rotVel.y, rotVel4.y<br />&nbsp; &nbsp; m2m .rotVel.z, rotVel4.z<br />&nbsp; &nbsp; <br />MethodEnd<br /></div><br /><br />When we have called 4 RK steps, we have a new position (of COM), new velocities (linear and angular), and a new orientation (quaternion).<br />We can now render our body :)<br /><br /></div>
    <div class="meta">Posted on 2008-01-26 03:23:06 by Homer</div>
   </div>
   <div class="post" id="post-204644">
    <div class="subject"><a href="#post-204644">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">Just for comparison&#039;s sake, and for those of you who are uncomfortable with the RK four-step dance, here is the Euler equivalent of the four RK steps:<br /><br /><div class="quote"><br />Method RigidBody.eulerStep,uses esi<br />LOCAL l2, ftemp<br /><br />	SetObject esi<br />	<br />&nbsp; &nbsp; ;linPos += RKh * linVel<br />&nbsp; &nbsp; ;linVel += linForce * oneOverMass * RKh&nbsp; &nbsp; <br />&nbsp; &nbsp; fld .linVel.x<br />&nbsp; &nbsp; fld .linVel.y<br />&nbsp; &nbsp; fld .linVel.z<br />&nbsp; &nbsp; fld RKh<br />&nbsp; &nbsp; fmul st(1),st(0)<br />&nbsp; &nbsp; fmul st(2),st(0)<br />&nbsp; &nbsp; fmul st(3),st(0)<br />&nbsp; &nbsp; fUnload<br />&nbsp; &nbsp; fadd .linPos.z<br />&nbsp; &nbsp; fstp .linPos.z<br />&nbsp; &nbsp; fadd .linPos.y<br />&nbsp; &nbsp; fstp .linPos.y<br />&nbsp; &nbsp; fadd .linPos.x<br />&nbsp; &nbsp; fstp .linPos.x<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; fld .linForce.x<br />&nbsp; &nbsp; fld .linForce.y<br />&nbsp; &nbsp; fld .linForce.z<br />&nbsp; &nbsp; fld RKh<br />&nbsp;  	fmul .oneOverMass<br />&nbsp; &nbsp; fmul st(1),st(0)<br />&nbsp; &nbsp; fmul st(2),st(0)<br />&nbsp; &nbsp; fmul st(3),st(0)<br />&nbsp; &nbsp; fUnload<br />&nbsp; &nbsp; fadd .linVel.z<br />&nbsp; &nbsp; fstp .linVel.z<br />&nbsp; &nbsp; fadd .linVel.y<br />&nbsp; &nbsp; fstp .linVel.y<br />&nbsp; &nbsp; fadd .linVel.x<br />&nbsp; &nbsp; fstp .linVel.x<br /><br />&nbsp; &nbsp; ;qRotPos.w -= RKh2 * (qRotPos0.x * rotVel.x + qRotPos0.y * rotVel.y + qRotPos0.z * rotVel.z);<br />&nbsp; &nbsp; fld .qRotPos.w<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.x<br />&nbsp; &nbsp; fmul .rotVel.x<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.y<br />&nbsp; &nbsp; fmul .rotVel.y<br />&nbsp; &nbsp; fadd<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.z<br />&nbsp; &nbsp; fmul .rotVel.z<br />&nbsp; &nbsp; fadd<br />&nbsp; &nbsp; fmul RKh2<br />&nbsp; &nbsp; fsub<br />&nbsp; &nbsp; fstp .qRotPos.w<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;qRotPos.x += RKh2 * (qRotPos0.w * rotVel.x - qRotPos0.z * rotVel.y + qRotPos0.y * rotVel.z);<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.w<br />&nbsp; &nbsp; fmul .rotVel.x<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.z<br />&nbsp; &nbsp; fmul .rotVel.y<br />&nbsp; &nbsp; fsub<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.y<br />&nbsp; &nbsp; fmul .rotVel.z<br />&nbsp; &nbsp; fadd<br />&nbsp; &nbsp; fmul RKh2<br />&nbsp; &nbsp; fadd .qRotPos.x<br />&nbsp; &nbsp; fstp .qRotPos.x<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;qRotPos.y += RKh2 * (qRotPos0.z * rotVel.x + qRotPos0.w * rotVel.y - qRotPos0.x * rotVel.z);<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.z<br />&nbsp; &nbsp; fmul .rotVel.x<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.w<br />&nbsp; &nbsp; fmul .rotVel.y<br />&nbsp; &nbsp; fadd<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.x<br />&nbsp; &nbsp; fmul .rotVel.z<br />&nbsp; &nbsp; fsub<br />&nbsp; &nbsp; fmul RKh2<br />&nbsp; &nbsp; fadd .qRotPos.y<br />&nbsp; &nbsp; fstp .qRotPos.y<br /><br />&nbsp; &nbsp; ;qRotPos.z += RKh2 * (qRotPos0.x * rotVel.y - qRotPos0.y * rotVel.x + qRotPos0.w * rotVel.z);<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.x<br />&nbsp; &nbsp; fmul .rotVel.y<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.y<br />&nbsp; &nbsp; fmul .rotVel.x<br />&nbsp; &nbsp; fsub<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.w<br />&nbsp; &nbsp; fmul .rotVel.z<br />&nbsp; &nbsp; fadd<br />&nbsp; &nbsp; fmul RKh2<br />&nbsp; &nbsp; fadd .qRotPos.z<br />&nbsp; &nbsp; fstp .qRotPos.z<br /><br />&nbsp; &nbsp; ;l2 = qRotPos.x * qRotPos.x + qRotPos.y * qRotPos.y + qRotPos.z * qRotPos.z + qRotPos.w * qRotPos.w;<br />&nbsp; &nbsp; fld .qRotPos.x<br />&nbsp; &nbsp; fmul st(0),st(0)<br />&nbsp; &nbsp; fld .qRotPos.y<br />&nbsp; &nbsp; fmul st(0),st(0)&nbsp; &nbsp; <br />&nbsp; &nbsp; fld .qRotPos.z<br />&nbsp; &nbsp; fmul st(0),st(0)<br />&nbsp; &nbsp; fld .qRotPos.w<br />&nbsp; &nbsp; fmul st(0),st(0)<br />	fadd<br />	fadd<br />	fadd<br />	fst l2		;length of quaternion<br />	<br />	fabs		;we want it to be 1.0 length (or really close)<br />	fld1		;so we&#039;ll check to see if we need to Normalize quaternion<br />	fsub<br />	fstp ftemp	<br />	fMin ftemp, fEpsilon<br />	fstpReg eax<br />	.if eax==ftemp&nbsp; &nbsp; <br />&nbsp;  		; normalise to unit length (approximately)<br />&nbsp; &nbsp; &nbsp; &nbsp;  ;n = (l2 + 1.0) / (2.0 * l2);<br />&nbsp; &nbsp; &nbsp; &nbsp; ;qRotPos.x *= n;<br />&nbsp; &nbsp; &nbsp; &nbsp; ;qRotPos.y *= n;<br />&nbsp; &nbsp; &nbsp; &nbsp; ;qRotPos.z *= n;<br />&nbsp; &nbsp; &nbsp; &nbsp; ;qRotPos.w *= n;<br />&nbsp; &nbsp; &nbsp; &nbsp;  ;l2 *= n * n;<br />&nbsp; &nbsp; &nbsp; &nbsp;  fld l2<br />&nbsp; &nbsp; &nbsp; &nbsp;  fld1<br />&nbsp; &nbsp; &nbsp; &nbsp;  fadd<br />&nbsp; &nbsp; &nbsp; &nbsp;  fld l2<br />&nbsp; &nbsp; &nbsp; &nbsp;  fadd st(0),st(0)<br />&nbsp; &nbsp; &nbsp; &nbsp;  fdiv<br />&nbsp; &nbsp; &nbsp; &nbsp;  fstp ftemp<br />&nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp;  fld .qRotPos.x<br />&nbsp; &nbsp; &nbsp; &nbsp;  fmul ftemp<br />&nbsp; &nbsp; &nbsp; &nbsp;  fld .qRotPos.y<br />&nbsp; &nbsp; &nbsp; &nbsp;  fmul ftemp<br />&nbsp; &nbsp; &nbsp; &nbsp;  fld .qRotPos.z<br />&nbsp; &nbsp; &nbsp; &nbsp;  fmul ftemp<br />&nbsp; &nbsp; &nbsp; &nbsp;  fld .qRotPos.w<br />&nbsp; &nbsp; &nbsp; &nbsp;  fmul ftemp<br />&nbsp; &nbsp; &nbsp; &nbsp;  fstp .qRotPos.w<br />&nbsp; &nbsp; &nbsp; &nbsp;  fstp .qRotPos.z<br />&nbsp; &nbsp; &nbsp; &nbsp;  fstp .qRotPos.y<br />&nbsp; &nbsp; &nbsp; &nbsp;  fstp .qRotPos.x<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp;  fld ftemp<br />&nbsp; &nbsp; &nbsp; &nbsp;  fmul st(0),st(0)<br />&nbsp; &nbsp; &nbsp; &nbsp;  fstp l2&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;make new (orthogonal) matrix from quaternion.<br />&nbsp; &nbsp; ;rotPos.fromQuatL2(qRotPos, l2)<br />	invoke Mat33_fromQuatL2,addr .rotPos,addr .qRotPos, l2<br />	<br />	;calculate angular velocity with Eulers equations<br />&nbsp; &nbsp; ;rotVel1.x = rotVel.x + (rotVel.y * rotVel.z * diagIyyMinusIzzOverIxx + rotForce.x * oneOverDiagIxx) * RKh<br />&nbsp; &nbsp; fld&nbsp; .rotVel.y<br />&nbsp; &nbsp; fmul .rotVel.z<br />&nbsp; &nbsp; fmul .diagIyyMinusIzzOverIxx<br />&nbsp; &nbsp; fld&nbsp; .rotForce.x<br />&nbsp; &nbsp; fmul .oneOverDiagIxx<br />&nbsp; &nbsp; fadd<br />&nbsp; &nbsp; fmul RKh<br />&nbsp; &nbsp; fadd .rotVel.x<br />&nbsp; &nbsp; fstp .rotVel1.x<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;rotVel1.y = rotVel.y + (rotVel.z * rotVel.x * diagIzzMinusIxxOverIyy + rotForce.y * oneOverDiagIyy) * RKh;<br />&nbsp; &nbsp; fld&nbsp; .rotVel.z<br />&nbsp; &nbsp; fmul .rotVel.x<br />&nbsp; &nbsp; fmul .diagIzzMinusIxxOverIyy<br />&nbsp; &nbsp; fld&nbsp; .rotForce.y<br />&nbsp; &nbsp; fmul .oneOverDiagIyy<br />&nbsp; &nbsp; fadd<br />&nbsp; &nbsp; fmul RKh<br />&nbsp; &nbsp; fadd .rotVel.y<br />&nbsp; &nbsp; fstp .rotVel1.y<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;rotVel1.z = rotVel.z + (rotVel.x * rotVel.y * diagIxxMinusIyyOverIzz + rotForce.z * oneOverDiagIzz) * RKh;<br />&nbsp; &nbsp; fld&nbsp; .rotVel.x<br />&nbsp; &nbsp; fmul .rotVel.y<br />&nbsp; &nbsp; fmul .diagIxxMinusIyyOverIzz<br />&nbsp; &nbsp; fld&nbsp; .rotForce.z<br />&nbsp; &nbsp; fmul .oneOverDiagIzz<br />&nbsp; &nbsp; fadd<br />&nbsp; &nbsp; fmul RKh<br />&nbsp; &nbsp; fadd .rotVel.z<br />&nbsp; &nbsp; fstp .rotVel1.z<br /><br />&nbsp; &nbsp; ;rotVel = rotVel1<br />	m2m .rotVel.x, .rotVel1.x<br />	m2m .rotVel.y, .rotVel1.y<br />	m2m .rotVel.z, .rotVel1.z<br />MethodEnd<br /></div><br /><br />Now I will show you the combine() method, which is EXTREMELY useful.<br />Usng this method, we can combine the mass properties of two or more Bodies (of any kind!!) into a single Body for the purposes of Physics updates.<br />Note that this does not include collision detection, we&#039;ll still need the geometric hulls of each component body , but we can apply the resulting forces to the composite &#039;parent&#039; body.<br />So now, we can make an axe with a wooden handle and a metal head, and combine them into one, then throw it at someone we don&#039;t like :)<br /><div class="quote"><br />Method RigidBody.eulerStep,uses esi<br />LOCAL l2, ftemp<br /><br />	SetObject esi<br />	<br />&nbsp; &nbsp; ;linPos += RKh * linVel<br />&nbsp; &nbsp; ;linVel += linForce * oneOverMass * RKh&nbsp; &nbsp; <br />&nbsp; &nbsp; fld .linVel.x<br />&nbsp; &nbsp; fld .linVel.y<br />&nbsp; &nbsp; fld .linVel.z<br />&nbsp; &nbsp; fld RKh<br />&nbsp; &nbsp; fmul st(1),st(0)<br />&nbsp; &nbsp; fmul st(2),st(0)<br />&nbsp; &nbsp; fmul st(3),st(0)<br />&nbsp; &nbsp; fUnload<br />&nbsp; &nbsp; fadd .linPos.z<br />&nbsp; &nbsp; fstp .linPos.z<br />&nbsp; &nbsp; fadd .linPos.y<br />&nbsp; &nbsp; fstp .linPos.y<br />&nbsp; &nbsp; fadd .linPos.x<br />&nbsp; &nbsp; fstp .linPos.x<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; fld .linForce.x<br />&nbsp; &nbsp; fld .linForce.y<br />&nbsp; &nbsp; fld .linForce.z<br />&nbsp; &nbsp; fld RKh<br />&nbsp;  	fmul .oneOverMass<br />&nbsp; &nbsp; fmul st(1),st(0)<br />&nbsp; &nbsp; fmul st(2),st(0)<br />&nbsp; &nbsp; fmul st(3),st(0)<br />&nbsp; &nbsp; fUnload<br />&nbsp; &nbsp; fadd .linVel.z<br />&nbsp; &nbsp; fstp .linVel.z<br />&nbsp; &nbsp; fadd .linVel.y<br />&nbsp; &nbsp; fstp .linVel.y<br />&nbsp; &nbsp; fadd .linVel.x<br />&nbsp; &nbsp; fstp .linVel.x<br /><br />&nbsp; &nbsp; ;qRotPos.w -= RKh2 * (qRotPos0.x * rotVel.x + qRotPos0.y * rotVel.y + qRotPos0.z * rotVel.z);<br />&nbsp; &nbsp; fld .qRotPos.w<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.x<br />&nbsp; &nbsp; fmul .rotVel.x<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.y<br />&nbsp; &nbsp; fmul .rotVel.y<br />&nbsp; &nbsp; fadd<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.z<br />&nbsp; &nbsp; fmul .rotVel.z<br />&nbsp; &nbsp; fadd<br />&nbsp; &nbsp; fmul RKh2<br />&nbsp; &nbsp; fsub<br />&nbsp; &nbsp; fstp .qRotPos.w<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;qRotPos.x += RKh2 * (qRotPos0.w * rotVel.x - qRotPos0.z * rotVel.y + qRotPos0.y * rotVel.z);<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.w<br />&nbsp; &nbsp; fmul .rotVel.x<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.z<br />&nbsp; &nbsp; fmul .rotVel.y<br />&nbsp; &nbsp; fsub<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.y<br />&nbsp; &nbsp; fmul .rotVel.z<br />&nbsp; &nbsp; fadd<br />&nbsp; &nbsp; fmul RKh2<br />&nbsp; &nbsp; fadd .qRotPos.x<br />&nbsp; &nbsp; fstp .qRotPos.x<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;qRotPos.y += RKh2 * (qRotPos0.z * rotVel.x + qRotPos0.w * rotVel.y - qRotPos0.x * rotVel.z);<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.z<br />&nbsp; &nbsp; fmul .rotVel.x<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.w<br />&nbsp; &nbsp; fmul .rotVel.y<br />&nbsp; &nbsp; fadd<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.x<br />&nbsp; &nbsp; fmul .rotVel.z<br />&nbsp; &nbsp; fsub<br />&nbsp; &nbsp; fmul RKh2<br />&nbsp; &nbsp; fadd .qRotPos.y<br />&nbsp; &nbsp; fstp .qRotPos.y<br /><br />&nbsp; &nbsp; ;qRotPos.z += RKh2 * (qRotPos0.x * rotVel.y - qRotPos0.y * rotVel.x + qRotPos0.w * rotVel.z);<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.x<br />&nbsp; &nbsp; fmul .rotVel.y<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.y<br />&nbsp; &nbsp; fmul .rotVel.x<br />&nbsp; &nbsp; fsub<br />&nbsp; &nbsp; fld&nbsp; .qRotPos0.w<br />&nbsp; &nbsp; fmul .rotVel.z<br />&nbsp; &nbsp; fadd<br />&nbsp; &nbsp; fmul RKh2<br />&nbsp; &nbsp; fadd .qRotPos.z<br />&nbsp; &nbsp; fstp .qRotPos.z<br /><br />&nbsp; &nbsp; ;l2 = qRotPos.x * qRotPos.x + qRotPos.y * qRotPos.y + qRotPos.z * qRotPos.z + qRotPos.w * qRotPos.w;<br />&nbsp; &nbsp; fld .qRotPos.x<br />&nbsp; &nbsp; fmul st(0),st(0)<br />&nbsp; &nbsp; fld .qRotPos.y<br />&nbsp; &nbsp; fmul st(0),st(0)&nbsp; &nbsp; <br />&nbsp; &nbsp; fld .qRotPos.z<br />&nbsp; &nbsp; fmul st(0),st(0)<br />&nbsp; &nbsp; fld .qRotPos.w<br />&nbsp; &nbsp; fmul st(0),st(0)<br />	fadd<br />	fadd<br />	fadd<br />	fst l2		;length of quaternion<br />	<br />	fabs		;we want it to be 1.0 length (or really close)<br />	fld1		;so we&#039;ll check to see if we need to Normalize quaternion<br />	fsub<br />	fstp ftemp	<br />	fMin ftemp, fEpsilon<br />	fstpReg eax<br />	.if eax==ftemp&nbsp; &nbsp; <br />&nbsp;  		; normalise to unit length (approximately)<br />&nbsp; &nbsp; &nbsp; &nbsp;  ;n = (l2 + 1.0) / (2.0 * l2);<br />&nbsp; &nbsp; &nbsp; &nbsp; ;qRotPos.x *= n;<br />&nbsp; &nbsp; &nbsp; &nbsp; ;qRotPos.y *= n;<br />&nbsp; &nbsp; &nbsp; &nbsp; ;qRotPos.z *= n;<br />&nbsp; &nbsp; &nbsp; &nbsp; ;qRotPos.w *= n;<br />&nbsp; &nbsp; &nbsp; &nbsp;  ;l2 *= n * n;<br />&nbsp; &nbsp; &nbsp; &nbsp;  fld l2<br />&nbsp; &nbsp; &nbsp; &nbsp;  fld1<br />&nbsp; &nbsp; &nbsp; &nbsp;  fadd<br />&nbsp; &nbsp; &nbsp; &nbsp;  fld l2<br />&nbsp; &nbsp; &nbsp; &nbsp;  fadd st(0),st(0)<br />&nbsp; &nbsp; &nbsp; &nbsp;  fdiv<br />&nbsp; &nbsp; &nbsp; &nbsp;  fstp ftemp<br />&nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp;  fld .qRotPos.x<br />&nbsp; &nbsp; &nbsp; &nbsp;  fmul ftemp<br />&nbsp; &nbsp; &nbsp; &nbsp;  fld .qRotPos.y<br />&nbsp; &nbsp; &nbsp; &nbsp;  fmul ftemp<br />&nbsp; &nbsp; &nbsp; &nbsp;  fld .qRotPos.z<br />&nbsp; &nbsp; &nbsp; &nbsp;  fmul ftemp<br />&nbsp; &nbsp; &nbsp; &nbsp;  fld .qRotPos.w<br />&nbsp; &nbsp; &nbsp; &nbsp;  fmul ftemp<br />&nbsp; &nbsp; &nbsp; &nbsp;  fstp .qRotPos.w<br />&nbsp; &nbsp; &nbsp; &nbsp;  fstp .qRotPos.z<br />&nbsp; &nbsp; &nbsp; &nbsp;  fstp .qRotPos.y<br />&nbsp; &nbsp; &nbsp; &nbsp;  fstp .qRotPos.x<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp;  fld ftemp<br />&nbsp; &nbsp; &nbsp; &nbsp;  fmul st(0),st(0)<br />&nbsp; &nbsp; &nbsp; &nbsp;  fstp l2&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;make new (orthogonal) matrix from quaternion.<br />&nbsp; &nbsp; ;rotPos.fromQuatL2(qRotPos, l2)<br />	invoke Mat33_fromQuatL2,addr .rotPos,addr .qRotPos, l2<br />	<br />	;calculate angular velocity with Eulers equations<br />&nbsp; &nbsp; ;rotVel1.x = rotVel.x + (rotVel.y * rotVel.z * diagIyyMinusIzzOverIxx + rotForce.x * oneOverDiagIxx) * RKh<br />&nbsp; &nbsp; fld&nbsp; .rotVel.y<br />&nbsp; &nbsp; fmul .rotVel.z<br />&nbsp; &nbsp; fmul .diagIyyMinusIzzOverIxx<br />&nbsp; &nbsp; fld&nbsp; .rotForce.x<br />&nbsp; &nbsp; fmul .oneOverDiagIxx<br />&nbsp; &nbsp; fadd<br />&nbsp; &nbsp; fmul RKh<br />&nbsp; &nbsp; fadd .rotVel.x<br />&nbsp; &nbsp; fstp .rotVel1.x<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;rotVel1.y = rotVel.y + (rotVel.z * rotVel.x * diagIzzMinusIxxOverIyy + rotForce.y * oneOverDiagIyy) * RKh;<br />&nbsp; &nbsp; fld&nbsp; .rotVel.z<br />&nbsp; &nbsp; fmul .rotVel.x<br />&nbsp; &nbsp; fmul .diagIzzMinusIxxOverIyy<br />&nbsp; &nbsp; fld&nbsp; .rotForce.y<br />&nbsp; &nbsp; fmul .oneOverDiagIyy<br />&nbsp; &nbsp; fadd<br />&nbsp; &nbsp; fmul RKh<br />&nbsp; &nbsp; fadd .rotVel.y<br />&nbsp; &nbsp; fstp .rotVel1.y<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;rotVel1.z = rotVel.z + (rotVel.x * rotVel.y * diagIxxMinusIyyOverIzz + rotForce.z * oneOverDiagIzz) * RKh;<br />&nbsp; &nbsp; fld&nbsp; .rotVel.x<br />&nbsp; &nbsp; fmul .rotVel.y<br />&nbsp; &nbsp; fmul .diagIxxMinusIyyOverIzz<br />&nbsp; &nbsp; fld&nbsp; .rotForce.z<br />&nbsp; &nbsp; fmul .oneOverDiagIzz<br />&nbsp; &nbsp; fadd<br />&nbsp; &nbsp; fmul RKh<br />&nbsp; &nbsp; fadd .rotVel.z<br />&nbsp; &nbsp; fstp .rotVel1.z<br /><br />&nbsp; &nbsp; ;rotVel = rotVel1<br />	m2m .rotVel.x, .rotVel1.x<br />	m2m .rotVel.y, .rotVel1.y<br />	m2m .rotVel.z, .rotVel1.z<br />MethodEnd<br /><br /></div><br /><br />We&#039;re almost ready to put it all together :)<br /></div>
    <div class="meta">Posted on 2008-01-26 20:53:20 by Homer</div>
   </div>
   <div class="post" id="post-204663">
    <div class="subject"><a href="#post-204663">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">My first public demo sourcecode will support two kinds of SPRINGS, so it&#039;s worth taking some time to talk about the physics of Springs, and some of the things we might use them for.<br /><br />Springs are a kind of CONSTRAINT.<br />Before I give equations for Springs, it&#039;s worth considering some even more primitive constraints.<br /><br />The simplest constraint I can think of is called a &quot;point constraint&quot;, whereby a point on entity A is forced to coincide with a point on entity B (and usually, vice-versa)... if A moves in space, then B is dragged along with it.. similarly, if we move B, then A is forced to move, so that &quot;we do not violate the constraint&quot;.<br />What if we wanted to maintain a certain distance between those points ? We might call this a &quot;rod constraint&quot; - we can imagine a stiff rod that separates the points, and which may not be compressed or stretched.<br />We can calculate the distance between them fairy easily using pythagorus theorem .. we&#039;d use a DotProduct.<br />Let&#039;s say that pA and pB are our two endpoints.<br />D = SquareRoot (pA dot pB)<br />We can also find the Normal Vector (direction) between the two points:<br />N = Normal (pB - pA)<br /><br />The formula for a rod constraint might look something like this:<br />B = D * N<br />We are saying that &quot;the new location of Point B is based on the Distance between A and B, multiplied by (in the Direction of) the Normal from A to B&quot;.<br /><br />OK, if you can understand how that works, you are ready to introduce elasticity into the equation.<br />In fact, our Spring constraint will not directly determine a new Position, rather, it will calculate a Force which we can then introduce into our simulator, which will bear on the velocity, and thus affect the position.<br /><br />The most simple spring equation looks like this:<br />F = -kD<br />where D is the vector difference in position between the two Points being constrained, and k is the Spring Constant which describes the &quot;tightness&quot; of the Spring.... larger values mean that the spring applies more force between the two endpoints, thus it will be &quot;stiffer&quot;, and will require more force to stretch or compress it (and will apply more force to the endpoints)... smaller values wll make the spring more &quot;elastic&quot; and so it will require less force to stretch or compress the spring (and take longer to reach equilibrium).<br />The negative sign indicates that this Spring will attempt to bring these two endpoints together, rather than pushing them apart.. it will try to achieve a distance of zero, given enough time.<br /><br />In the real world, springs are not perfect - they lose energy as heat, so they don&#039;t oscillate forever, they will eventually reach equilibrium. We need to introduce some Damping to simulate this energy loss, otherwise our Spring will oscillate forever (if there was no other forces).<br /><br />So, our Spring equation becomes a little more complex:<br />F = - kD - bv<br />where b is the coefficient of damping and v is the relative velocity between the two points connected by the spring. Larger values for b increase the amount of damping so the object will come to rest more quickly, b=0 will allow the spring to oscillate forever, while negative values will actually accelerate the objects over time making your simulation explode...d&#039;oh!<br /><br />Generally, we don&#039;t want our Spring to bring the endpoints together, we want the Spring to maintain a given Distance between the endpoints... our formula becomes:<br />F = -k(D-d) * (N) - bv<br />where D is the CURRENT distance between the two points connected to the spring, d is the desired distance of separation, and N is the unit length direction vector between the two points: a to b, when applying the force to point a and vice versa.<br /><br />Using this formula, we can implement all three kinds of constraints: Point, Rod and Spring, by setting the coefficients accordingly.<br /><br />We can use Springs to make the Camera follow the Player, to simulate a Rope Bridge that sways and stretches as we walk across it, we can simulate Leaf Springs in a car, we can even use Springs to simulate SemiRigid (deformable) bodies such as a plate of jelly :)<br />The list of things you can do with Springs is almost endless, it just requires a little imagination :)<br /><br />Springs are related to Point constraints, as we have seen - they apply force to the two endpoints.<br />If both endpoints belong to rigid bodies, we can take advantage of one of the laws of physics to apply the force to both bodies at once : &quot;For every action, there is an equal and opposite reaction&quot;.<br />If we calculate the force applied to A, then the force applied to B is -F , and in the direction -N :)<br /><br />But why stop at applying springs to Position only?<br />We can apply springs to acceleration, torque, or any other quantity that we wish to control over time.<br />Let&#039;s say we wish to bring an object from its current Velocity to its maximum Velocity over a given amount of Time... we can use a Spring to do that, easy!! This is an example of a Motor.<br /><br />You should be starting to see just how useful Springs are to a physics simulation.<br /><br />It is worth reiterating that Springs apply force to the endpoints, ie, the points at which they are attached.<br />For a rigid body, typically the endpoint will be on the surface of the body, NOT its center of mass.<br />Usually, this means that our linear spring force will cause both linear and angular forces to be applied to the body or bodies, because we will typically be applying our force &quot;off-center&quot;....<br /><br />If you had a cube resting on a smooth surface, and you placed your finger in the center of one of its side faces, and gave it a push, it would slide along... but if you pushed it off-center, it would tend to want to Roll rather than slide.. yes?<br /><br />Having calculated the Force to be applied to the attachment point of a Body, we should remember to apply the force AT THAT POINT, and NOT simply apply it to the center of mass.<br /><br />In the next exciting instalment, I&#039;ll explain exactly how to do this, which by the way, will be very important later when we wish to resolve collisions :)<br /><br /><br /></div>
    <div class="meta">Posted on 2008-01-30 21:58:22 by Homer</div>
   </div>
   <div class="post" id="post-204665">
    <div class="subject"><a href="#post-204665">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body"><br />So... how do we apply a linear Force to a Point on our Body?<br /><br />I will assume that we know the current State of the Body, which importantly, includes its Angular Velocity.<br />Angular Velocity is a 3D Vector which describes how fast the Body is rotating, and in which Direction.<br />Most physics texts use the symbol W to describe angular velocity.<br />The length of the vector describes how fast the rotation is changing, typically in Radians per Second.<br />The direction of the Vector describes the 3D rotation axis... looking along that vector, the Body rotation is Clockwise.<br /><br />Remembering our Linear equations, we know that a Body has some Mass, and that a Body which is moving linearly has some Linear Momentum.. it would require some Linear Force to change that momentum, and thus the speed and/or direction of motion.<br />The angular equivalent of Linear Force is called Torque, and the angular equivalent of Linear Momentum is called (suprise!) Angular Momentum.<br />A body that is rotating has some Angular Momentum - that is to say, it would require some Torque (rotational Force) to change the angular momentum, and thus to change the speed and/or direction of rotation.<br /><br />Angular Velocity is generally considered in BodySpace rather than in WorldSpace.<br />The reason is due to the following formula:<br />T = R  F<br />where :<br />T = torque (in BodySpace)<br />F = Force (in BodySpace) which is being applied to the Body<br />R = vector from centre of mass to the point on the Body where a Force is being applied.<br /><br />Assume that we have a diagonalised Inertia Tensor. You may recall that it looks like this:<br /><br />&nbsp; &nbsp;  Ixx 0 0<br />I = 0 Iyy 0<br />&nbsp; &nbsp;  0 0 Izz<br /><br />We can calculate the new rotation matrix R from the existing rotation matrix r and the angular velocity W as follows:<br />R = r * Wb<br /><br />Just remember that W is a vector, while r and R are rotation matrices or quaternions.<br /><br />We can find out how a Torque force changes the Angular Velocity using Euler&#039;s Equations as follows:<br />dW.x = ((Iyy-Izz) / Ixx) * (W.y*W.z) + (T.x / Ixx)<br />dW.y = ((Izz-Ixx) / Iyy) * (W.z*W.x) + (T.y / Iyy)<br />dW.z = ((Ixx-Iyy) / Izz) * (W.x*W.y) + (T.z / Izz)<br />where dW is the Change in Angular Velocity due to the Torque, with respect to the Inertia Tensor.<br />Please do notice that angular velocity can change even if theres no Torque (T).<br /><br />Having read all of that, you should be able to calculate the Torque due to an external Force, and thus the change in angular velocity (dW) due to torque.<br />Once we have that, we can calculate the NEW angular velocity by adding dW to the CURRENT angular velocity... and we can also find the NEW Orientation by multiplying the CURRENT Orientation with dW.<br /><br />I&#039;ve described how an input Force, when applied to a point on a Body, affects changes in orientation, but I have not shown how the input Force affects changes in linear momentum.<br />Expect me to update this post, I&#039;m not really happy with it... it&#039;s hard to describe these equations without using visual aids such as diagrams, and a picture tells a thousand words.<br />Still, it&#039;s nice to see that Inertia Tensor finally being used for something!<br /><br /></div>
    <div class="meta">Posted on 2008-01-31 00:45:24 by Homer</div>
   </div>
   <div class="post" id="post-204666">
    <div class="subject"><a href="#post-204666">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body"><br />Forgive the rambling nature of the previous post.<br />This time I&#039;ll give a decent example, rather than a bunch of theory.<br /><br />Let&#039;s suppose we wish to poke a Body with a stick - we wish to apply an external Force to some point on the surface of a Body.... and let&#039;s assume that we know the CURRENT state of the Body, and that from the current (linear and angular) Velocity, we have calculated the INTERNAL (linear) Force and (angular) Torque of the Body - that is to say, those Forces with respect to the Center of Mass (COM) which are products of its (linear and angular) momentum (aka Inertia). Let us also assume (for now) that the point of application of external force on the Body is given in WorldSpace, and so is the external Force.<br /><br />So.. we know the current State, we know the internal forces, we have an external force F being applied at some point P on the Body, and both F and P are given in World coordinates.<br />We want to find the new internal forces after we applied the force, so we can then integrate those and thus find the new State of the Body. Where do we begin?<br /><br />We begin by making the point P relative to the center of mass.<br />That&#039;s as simple as subtracting the position COM (vector) from the Point (vector).<br />We now have a vector, in worldspace, from COM to P, let&#039;s call it V.<br /><br />Next, we find the CROSSPRODUCT of V and F.<br />The result is the &quot;change in Torque&quot; due to our applied force, given in WorldSpace, with respect to COM.<br />However, our internal torque (rotForce) is stored in diagonalised BodySpace (DSpace).<br />We stored it that way because even though our Body might be rotating in worldspace, it never rotates in bodyspace - this gives us a fixed reference coordinate system to work with, even though our world-relative coordinate system is rotating. So the next thing we need to do is transform the worldspace deltaTorque into diagonalised bodyspace. We can do that by multiplying it with the Transpose of the current rotation matrix.<br />Remember, our rotation matrix (rotPos) is used to transform from diagonalised bodyspace to worldspace.... we use it to orient the diagonalised bodyspace declaration of the body geometry.<br />If it rotates us from DSpace to WSpace, then its inverse (and transpose, since its a rot matrix) must transform us from WSpace back into DSpace, yes?<br /><br />V = WorldPoint - COMposition<br />wspcTorque = CrossProduct (V,F) <br />m = Transpose(rotPos)<br />dspcTorque = m * F<br /><br />In fact, rather than transposing the rotPos matrix, I have provided an EVEN FASTER function.<br />Its name is &quot;Vec3_transMult&quot;.<br />It &quot;premultiplies&quot; a Vector by the transpose of a matrix, leaving the resulting Vec3 on the fpu stack.<br />Thus, dspcTorque = transMult (rotPos, F) , and we don&#039;t need to find m.<br />Finally, to find the NEW Torque, we simply add the result to our CURRENT Torque:<br />rotForce = rotForce + dspcTorque<br /><br />That takes care of the rotational side of this exercise, but we haven&#039;t mentioned the linear side yet.<br />Surely, if we poke the Body with a stick, it doesn&#039;t JUST rotate, it probably moves linearly too, yes?<br />Yep, so how do we find the new linForce?<br />We keep linear force in WorldSpace coordinates, and the input Force is also in WorldSpace, so we just add them together:<br />linForce = linForce + F<br /><br />Hangon, did we just apply the same force to our Body twice?<br />What about the law of conservation of momentum?<br />How is it that we are applying the same energy twice? Is this correct?<br />Yes, it is correct.<br />The linear momentum and the angular momentum are separate quantities, we calculate them separately.<br />We have NOT applied the same Force to the Body twice, we have applied the same Force to two completely separate components of the physical state.<br /><br />At this point, we can calculate the new internal forces from the current internal forces and an external force. We know that our integrator will use those forces to update the body&#039;s other variables such as position. When we get to collision response, we&#039;ll be able to calculate the forces resulting from collisions then we can apply those forces to our Body or bodies, and let the integrator handle the rest.<br /></div>
    <div class="meta">Posted on 2008-01-31 02:31:21 by Homer</div>
   </div>
   <div class="post" id="post-204675">
    <div class="subject"><a href="#post-204675">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">So - are we enjoying this rant so far?<br />Let me know your thoughts before I continue to collision detection/response stuff.<br /></div>
    <div class="meta">Posted on 2008-02-01 01:01:01 by Homer</div>
   </div>
   <div class="post" id="post-204676">
    <div class="subject"><a href="#post-204676">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">yes! yes! :D We want more! <br /></div>
    <div class="meta">Posted on 2008-02-01 04:14:47 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-204681">
    <div class="subject"><a href="#post-204681">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">It&#039;s a little beyond my understanding at the moment Homer, but I do enjoy reading and trying to understand it. Keep up the good work.<br />Rags</div>
    <div class="meta">Posted on 2008-02-01 13:16:38 by rags</div>
   </div>
   <div class="post" id="post-204682">
    <div class="subject"><a href="#post-204682">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">I&#039;m same as Rags.</div>
    <div class="meta">Posted on 2008-02-01 13:35:46 by LocoDelAssembly</div>
   </div>
   <div class="post" id="post-204686">
    <div class="subject"><a href="#post-204686">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">That is acceptable - to be honest, it&#039;s a little above me too, for I must translate this complex stuff into terms I can understand (my background in math is poor, I am mostly self-taught) ... and documenting my own understanding may help shed light on this stuff for you guys too (certainly, writing these notes in common language makes it more accessible than using greek notation !!) However, my motivation is also selfish to some degree, because the act of writing out my thoughts and perceptions etches them into my memory, and clarifies my own understand further... it&#039;s easy enough to understand any small detail, but seeing them put together into a context and understanding how the small pieces fit together to create something greater, THAT is enlightening.<br /><br />I am putting together my first collision detection and response posts, and will provide them shortly.<br />To be honest, I am working on the code implementation of all this stuff as I go, and finding small issues to fix each day, which is the main reason I am yet to post any solid code - the code changes so often right now, it resembles a life form. But each day brings a small success, and any progress is good progress in my book.<br /><br />Please take your time to read and re-read all the posts so far, and tell me if you struggle with anything in particular that I might perhaps have shed more light on (or explained better), totally forgot to mention, etc. Eventually this document will be enshrined in the form of an e-book and/or a dedicated wiki.<br /><br /><br /></div>
    <div class="meta">Posted on 2008-02-02 04:33:39 by Homer</div>
   </div>
   <div class="post" id="post-204721">
    <div class="subject"><a href="#post-204721">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">Today I&#039;d like to shed a little more light on this mysterious thing called an RK4 Integrator.<br />My example code will be VERY simple, its really just to help understand the process.<br />I will be showing position , velocity and acceleration just using single floats, so this could be considered a &quot;one dimensional&quot; example.<br /><br />Euler integration is inaccurate because it is a linear solution being applied to a curved problem... Euler totally ignores this fact, and is only truly accurate when the timestep is infinitely small (ouch!)<br />RK4 is much more accurate than Euler integration, in fact its 5 orders more accurate.<br />Euler integration accumulates numerical error very quickly, and leads to unstable simulation.<br />RK4 is not our ONLY choice, but its a very nice choice, and not too difficult to implement...<br /><br />For starters, let us describe what the Current State of our Body might look like:<br /><br /><div class="quote"><br />State struct<br />	position real4 ?<br />	velocity real4 ?<br />	derived Derivative &lt;&gt;<br />State ends<br /></div><br /><br />As you might recall, the (first) derivative of position is velocity, and the first derivative of velocity (second derivative of position) is acceleration.<br />Do not confuse DERIVED velocity with ACTUAL velocity.<br />Derived values are only temporary, intermediate values that we use to update our REAL ones.<br />This example stores the derived values in a struct also:<br /><div class="quote"><br />Derivative struct<br />	derived_velocity&nbsp; &nbsp; &nbsp;  real4 ?<br />	derived_acceleration real4 ?<br />Derivative ends<br /></div><br /><br />This example is using a VARIABLE TIMESTEP, which I have said before is a bad idea, but lets see it anyway.<br />The entrypoint to our RK4 code is here:<br /><div class="quote"><br />integrate proc pstate, ftimedelta<br />LOCAL _b:State<br />LOCAL _c:State<br />LOCAL _d:State<br />LOCAL halftime:real4<br /><br />	;Find the midpoint of the timestep<br />	fld ftimedelta<br />	fmul r4_Half<br />	fstp halftime<br /><br />	invoke evaluateA,pstate<br />	invoke evaluate, addr d_b, pstate,	halftime<br />	invoke evaluate, addr d_c, d_b,		halftime<br />	invoke evaluate, addr d_d, d_c,		ftimedelta<br /><br />	;Now we calculate a kind of average of the four derived values,<br />	;and add the resulting delta to our initial state values:<br /><br />	;dxdt = 1.0f/6.0f * (a.dx + 2.0f*(b.dx + c.dx) + d.dx)<br />	;dvdt = 1.0f/6.0f * (a.dv + 2.0f*(b.dv + c.dv) + d.dv)<br />	;state.x = state.x + dxdt*dt<br />	;state.v = state.v + dvdt*dt<br />	<br />	mov edx,pstate<br />	fld&nbsp; _b.derived.derived_velocity<br />	fadd _c.derived.derived_velocity<br />	fadd st(0),st(0)<br />	fadd .State.derived.derived_velocity<br />	fadd _d.derived.derived_velocity<br />	fdiv r4_6<br />	fadd .State.position<br />	fstp .State.position<br /><br />	fld&nbsp; _b.derived.derived_acceleration<br />	fadd _c.derived.derived_acceleration<br />	fadd st(0),st(0)<br />	fadd .State.derived.derived_acceleration<br />	fadd _d.derived.derived_acceleration<br />	fdiv r4_6<br />	fadd .State.velocity<br />	fstp .State.velocity<br /><br />	ret<br /><br />integrate endp<br /></div><br /><br />Now lets talk about whats happenening here before we look at any more code.<br />RK4 works by calculating the derivatives at the start of the timestep, halfway through, and at the end of the timestep, and then it averages out the error over the timestep, and finally updates the state values.<br />The first thing we see is some code to find &quot;half the timestep&quot;.<br />Next, we see a call to &quot;evaluateA&quot;.<br />This function calculates the derivates of the given State struct at the start of the timestep, and stores them inside there.<br />Then we see three calls to &quot;evaluate&quot;.<br />This function takes an input state&#039;s derivates and calculates new derivatives at a given Time.<br />Each set of derivatives is used to forge a new State struct, each feeding into the next stage.<br />Finally, we see the code which updates our State based on all those derivatives that we found.<br /><br /><div class="quote"><br />;Calculate the Derivatives at the start of the timestep..<br />;We will store these in the given State structure<br />evaluateA proc pState<br />	mov edx,pState<br />	;derived velocity = initial velocity<br />	m2m .Derived.derived_velocity, .State.velocity<br />	;derived acceleration = initial acceleration<br />	acceleration .State<br />	fstp .Derived.derived_acceleration<br />	ret<br />evaluate endp<br /></div><br /><br />That one is pretty simple - we only call it once, to calculate State&#039;s derived values.<br /><br /><div class="quote"><br />evaluate proc pStateOut,pStateIn, ftimedelta<br />LOCAL state:State<br />	mov edx,pStateOut<br />	mov eax,pStateIn<br />	;output position = input position + (derived_velocity * timedelta)<br />	fld .State.derived.derived_velocity<br />	fmul ftimedelta<br />	fadd .State.position<br />	fstp .State.position<br />	;output velocity = input velocity + (derived_acceleration * timedelta)<br />	fld .State.derived.derived_acceleration<br />	fmul ftimedelta<br />	fadd .State.velocity<br />	fstp .State.velocity<br />	;Now calculate the derived values for the new state values<br />	invoke evaluateA,pStateOut<br />	ret<br />evaluate endp<br /></div><br /><br />Slightly more complex - we calculate new state values via given derivatives, and then we hand the new state to evaluateA to find ITS derivatives.<br /><br /><div class="quote"><br />.data<br />fk real4 10.0f<br />fb real4 1.0f<br />.code<br />acceleration macro state<br />	;This demo macro implements a spring with damping<br />	;returns a value on the fpu stack<br />	; - k*state.x - b*state.v<br />	fld fk<br />	fmul state.position<br />	fld fb<br />	fmul state.velocity<br />	fsub<br />endm<br /></div><br /><br />This macro implements a Spring and Damper using Hooke&#039;s spring formula.<br />We can put anything we want here, we could find acceleration due to forces, or whatever.<br />This is just an example showing how to CORRECTLY implement Runge-Kutta fourth order numerical integration.<br /><br />I guess the most important things to take home from all of this are:<br />A) Don&#039;t screw with your current state values during the integration stages - wait until the end<br />B) Derivatives are &quot;delta values&quot; that tell us how much some value changes - which is why we can&#039;t screw with our current state until we have blended the four derivatives and obtained our final delta values.<br />C) RK4 works by sampling the derivatives four times, enabling us to average out the error over the timestep.<br /><br />Did this post help you to understand RK4 implementation?<br /></div>
    <div class="meta">Posted on 2008-02-06 09:46:23 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=28937&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=28937&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="28937" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=28937&amp;page=2">&gt;</a><a href="../?id=28937&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>