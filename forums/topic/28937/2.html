<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force] - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=28937" />
  <link rel="prev" href="../?id=28937&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=28937">Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=28937&amp;page=1" style="">&laquo;</a><a href="../?id=28937&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="28937" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-204732">
    <div class="subject"><a href="#post-204732">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">It&#039;s time to talk about Collision Detection and Resolution.<br />How do we detect when two (or more) bodies collide, and what happens if we do?<br />I will (for now) ignore the problems associated with objects that travel very fast, and will concentrate on the typical scenario, where objects cannot pass through each other in a single timestep, ie, we can detect their collision.<br />Most of the time, we won&#039;t see our object nicely kissing each other, we will instead see them penetrating one another. This is known as &quot;interpenetration&quot;. In order to resolve this situation, there are two schools of thought. <br />The most common solution is to try to measure the penetration depth, and use that to determine an appropriate IMPULSE force which would correct the Position of each Body to the &quot;kissing position&quot;, which we know is slightly &quot;back in time&quot; , ie , occurs at some moment in the current timestep, then resolve the collision between the bodies conventionally (calculate new forces for the bodies resulting from the impact), and finally, advance the bodies for the remainder of the timestep.<br />Impulses are forces which are applied immediately.. normally we apply forces to acceleration, and accelerations only alter the position and orientation over time.. impulses can be thought of as accelerations which occur over an infinitely small amount of time, &quot;instantly&quot; changing our position and orientation. This might seem somewhat hacky, and it is.<br />A more accurate solution is to search for the kissing moment in the current timestep by rewinding our bodies to their initial state, and then subdividing the timestep, and checking for collision, repeating this until we find a penetration depth that is within acceptable tolerance. This scheme can be thought of as a &quot;binary search&quot; of the current timestep. Again, once we find the &quot;kissing point&quot;, we can resolve the collision conventionally. It&#039;s a lot more expensive, but we can limit the collision check to the bodies involved in THIS collision and its not too bad a tradeoff.<br /><br />The most common collision we will ever see involves the penetration of a surface by a Point, such as the corner of a cube and a flat floor. As we will see, MANY of our collision tests are based on Point tests.<br />A flat surface such as a Triangle has a Surface Normal vectir which describes the direction it is facing.<br />The Surface Normal, along with a fourth value called &quot;PlaneD&quot;, when stored as a 4D vector, together describe a PLANE.<br />Planes are theoretical flat surfaces in 3D which extend to infinity.<br />The normal vector describes the direction they face, and the PlaneD value describes the shortest possible distance from the World Origin to that unique plane, which just happens to be along that Normal.<br />Although several triangles may share a single plane (such as the face of a cube made of 2 triangles), every plane is unique , even if it faces the same direction, due to the PlaneD (plane distance) value.<br />If we wish to test for the intersection of a given Point and Plane, all we need to do is measure the distance between them... negative values indicate that the Point is &quot;behind the plane&quot;, while positive values tell us that it is &quot;in front of the plane&quot;, and zero would indicate that the point is resting apon the plane.<br />Since our computer does not have infinite precision and is prone to small numerical errors, we give a little tolerance to give the plane a little &quot;thickness&quot;, so we might say if the value is between -.001 and +.001, its resting on the plane, ie, its close enough to zero for me.<br />A similar logic is used when testing for collision of a Sphere and a Plane, because we can think of a Sphere as being &quot;a Point with some Thickness&quot; where the thickness equals the sphere radius... first we measure the distance from the sphere&#039;s origin to the plane, and then we take the sphere&#039;s radius into account.<br />If the distance is more than the radius, the sphere is totally in front of the plane.<br />If the distance is less than a radius, but not less than -2*radius, we have an intersection.<br />If the distance is less than -2*radius, the sphere is totally behind the plane.<br />Testing for collision between two spheres is even easier... we just compare the distance between their origins to the sum of their radii, and determine similarly to the aforementioned sphere/point test.<br />Using that information, we are now able to perform tests between planes, spheres, and a whole family of &quot;Stuff with flat faces&quot; such as cubes and &quot;arbitrary meshes&quot;.<br />And by extension of this kind of thinking, we can detect for collisions with more difficult geometries such as cylinders and ellipses (egg shapes).<br /><br />In my next post, we&#039;ll look at resolving simple collisions (math ahoy!), followed immediately by a discussion of more complex &quot;multiple, simultaneous&quot; collisions.<br /></div>
    <div class="meta">Posted on 2008-02-06 22:51:43 by Homer</div>
   </div>
   <div class="post" id="post-204747">
    <div class="subject"><a href="#post-204747">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">Entertaining and informative thread. <br /><br />As an addendum, for the purpose of optimization, using a bounding sphere (a sphere that encloses every vertex in a mesh/object) can be used to cull (avoid useless calculation) the amount of collision detection necessary. If the simpler sphere-to-sphere collision test passes you can move on to the more complex testing and interpolation.<br /><br />Also, you mentioned &quot;&quot;subdividing the timestep, and checking for collision, repeating this until we find a penetration depth that is within acceptable tolerance.&quot;&quot; I&#039;ve never dealt with the implementation, but I wonder if using the acceleration, velocity and start position vectors and solving for the variable time (when the positions are kissing) would be more efficient (it would certainly be more precise) than subdividing the time-step?<br /><br />An excellent resource keep at it!</div>
    <div class="meta">Posted on 2008-02-08 09:54:14 by r22</div>
   </div>
   <div class="post" id="post-204758">
    <div class="subject"><a href="#post-204758">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">Nice stuff.&nbsp; I sadly haven&#039;t got time to read most of it, but I&#039;ll assume that it&#039;s pretty good.&nbsp; It&#039;s at least good that someone&#039;s talking about physics stuff, but it looks like it could make use of some SSE.&nbsp; I&#039;ve got some electrodynamics using SSE in the screensaver that I&#039;ll hopefully be demoing soon.<br /><br />*sigh* I guess I should get back to work. :sad: I&#039;m way behind, but pretty close now, so it shouldn&#039;t be much longer.</div>
    <div class="meta">Posted on 2008-02-09 23:35:55 by hackulous</div>
   </div>
   <div class="post" id="post-204784">
    <div class="subject"><a href="#post-204784">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">I absolutely agree with both of you...<br /><br />Yes, a hierarchy of collision hulls can be used, and Sphere is certainly the most simply hull, I believe I touched on this already, and certainly mean to cover this in more detail.<br /><br />Of course SSE would help , where available.<br />I have deliberately and almost completely avoided the entire concept of optimizing, since this thread is meant to contain the fundamental knowledge required to implement physics on ANY platform.<br />My example code is meant to remain as readable as possible, not as fast as possible for a specific platform...I could have simply provided formulae and algorithms in pseudocode, but programmers want to see programs, and asmcoders are my audience, so I chose a language which asmcoders might easily understand.<br /><br />Believe me when I say that I am only putting in text the concepts in my mind, and as such, you are welcome to point out any mistakes that I make.<br />I am not a physicist, and I am not a mathematician, but I am human, and worse than that, I am mostly self-taught.<br /><br /></div>
    <div class="meta">Posted on 2008-02-12 00:06:27 by Homer</div>
   </div>
   <div class="post" id="post-204805">
    <div class="subject"><a href="#post-204805">Re: Physics - Matrices, Rigid Bodies and Stuff ... [Using the Force]</a></div>
    <div class="body">Just a quick post so you know I am still alive.<br /><br />We will begin exploring collision detection and resolution via the example of a Mass Particle - a particle that has some mass.<br />No, I am not going to suggest we make our engine around the concept of mass particles stuck together with stiff springs, like some do, I am going to state:<br />1) Particles are all linear, theres no rotation stuff<br /><br />2) For the linear (not angular) side of the question, we can treat the center of mass (COM) of ANY rigid body as a Mass Particle<br /><br />3) The solution of the angular side of the equation relies on our ability to solve the particle equation for a reference point other than COM.<br /><br />So I repeat, we will learn how to handle collision detection / resolving for a single point with Mass, then apply what we learned to the geometry of the arbitrary Rigid Body .. we will learn the stuff we need for the linear side of the coin, and then we will learn how to apply that to solve the angular stuff for more complex entities :)</div>
    <div class="meta">Posted on 2008-02-16 04:07:37 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=28937&amp;page=1" style="">&laquo;</a><a href="../?id=28937&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="28937" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>