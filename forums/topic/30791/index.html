<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Programs by code,languages by semantics - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30791" />
    <link rel="next" href="../?id=30791&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=30791">Programs by code,languages by semantics</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=30791&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=30791&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="30791" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=30791&amp;page=2">&gt;</a><a href="../?id=30791&amp;page=2">&raquo;</a></form>   <div class="post" id="post-215531">
    <div class="subject"><a href="#post-215531">Programs by code,languages by semantics</a></div>
    <div class="body">Hi all,<br />programs quality should be marked in an analogue<br />way as refrigerators and freezers, i.e following<br />a catagorization alike the EU one about energy saving<br /><br /><a target="_blank" href="http://en.wikipedia.org/wiki/European_Union_energy_label">http://en.wikipedia.org/wiki/European_Union_energy_label</a><br /><br />that a program is open source doesnt mean<br />it is a good tool, nor open source is enough<br />to tell how good it is.<br /><br />i am finding a way to attribute a &quot;class&quot; to a program<br />working on an empirical foumula; many different ideas,<br />related to code density, &quot;activity&quot;,<br />semantics in the source language etc.<br /><br />this will indirectly avoid people overbloating on their &quot;facts&quot;<br />about HLL or on the contrary, telling the old story that<br />raw coding the machine imply too much time and effort.<br /><br />once having a class A,B,C for example as a goal for your app,<br />time and effort will be measured from the output,<br />and how the output code works on the destination machine.<br />i.e, not only from the source point of view.<br /><br />your opinions ?<br />Cheers,<br /><br />-- <br />.:mrk<br />&nbsp; .:x64lab:.<br /> group <a target="_blank" href="http://groups.google.com/group/x64lab">http://groups.google.com/group/x64lab</a><br /> site <a target="_blank" href="http://sites.google.com/site/x64lab">http://sites.google.com/site/x64lab</a> </div>
    <div class="meta">Posted on 2011-12-07 10:13:04 by hopcode</div>
   </div>
   <div class="post" id="post-215535">
    <div class="subject"><a href="#post-215535">Re: Programs by code,languages by semantics</a></div>
    <div class="body">And if the program does exactly what you need it to do how do you gauge it based on your criteria?&nbsp; And what about user feedback?&nbsp; For example: some people like Windows, some people don&#039;t.<br /><br />Unlike the traditional benchmarks for hardware - it can be very difficult to provide unbiased ratings for software.&nbsp; Market share is &quot;usually&quot; a good indicator of a programs worth beyond statistics such as lines of code.<br /><br />From a supplier point of view is it easier to make revisions and maintain code in language X over language Y?&nbsp; Will you have enough personnel with the necessary expertise to do the job?<br /><br />Crap, I&#039;m starting to sound like a corporate manager!&nbsp; :shock:</div>
    <div class="meta">Posted on 2011-12-07 18:48:26 by p1ranha</div>
   </div>
   <div class="post" id="post-215542">
    <div class="subject"><a href="#post-215542">Re: Programs by code,languages by semantics</a></div>
    <div class="body">Hi p1,<br />thanks for answering.<br /><div class="quote"><br />Crap, I&#039;m starting to sound like a corporate manager!&nbsp; :shock: </div><br />if You like it, it sounds ok; OSI is a corporation too,<br />FSF a foundation. &quot;foundation&quot;, &quot;corporation&quot; these are just labels.<br />You will agree upon the fact that quality code has <br />requirements just like the free one. for my side, i am a <br />free-and-open-source-developer. sharing knowledge, as far as i can,<br />is the only quality development line i know.<br /><br /><div class="quote"><br />Will you have enough personnel with the necessary expertise to do the job? </div><br />it depends on which tools one uses to make tests on the output code.<br /><div class="quote"><br />From a supplier point of view is it easier to make revisions and maintain code in language X over language Y? </div><br />the following lines rapresents an assignment after<br />a cast from/to classes in Qt.<br /><pre><code>c_labitem *labitem =<br />&nbsp; &nbsp; (c_labitem*)(<br />&nbsp; &nbsp; &nbsp; (item-&gt;data(column,Qt::UserRole))<br />&nbsp; &nbsp; &nbsp;  .toLongLong(0));<br />&nbsp; ...</code></pre><br />and that all sounds to me this crude way:<br /><br /> <pre><code><br />&nbsp; 000000013FDC10FB&nbsp; 488B02&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov rax,<br />&nbsp; 000000013FDC10FE&nbsp; 41B920000000&nbsp;  mov r9d,00000020<br />&nbsp; 000000013FDC1104&nbsp; 488D542428&nbsp; &nbsp; &nbsp; lea rdx,<br />&nbsp; 000000013FDC1109&nbsp; 498BCA&nbsp; &nbsp;  mov rcx,r10<br />&nbsp; 000000013FDC110C&nbsp; FF5010&nbsp; &nbsp; &nbsp; call qword <br />&nbsp; 000000013FDC110F&nbsp; 90&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  nop<br />&nbsp; 000000013FDC1110&nbsp; 33D2&nbsp; &nbsp; &nbsp; &nbsp;  xor edx,edx<br />&nbsp; 000000013FDC1112&nbsp; 488BC8&nbsp; &nbsp;  mov rcx,rax<br />&nbsp; 000000013FDC1115&nbsp; FF1545710000 call qword [000000013FDC8260] ;QtCore4.?toLongLong@QVariant<br />&nbsp; 000000013FDC111B&nbsp; 488BD8&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  mov rbx,rax<br />&nbsp; 000000013FDC111E&nbsp; 488D4C2428&nbsp; &nbsp; lea rcx,<br />&nbsp; 000000013FDC1123&nbsp; FF153F710000 call qword [000000013FDC8268] ;QtCore4.??1QVariant<br />&nbsp; ...</code></pre><br />Qt is a wonderful framework. i like it but<br />i dont use it. the compiler makes a fast and good job on it.<br />one is free to use the language/framework he likes,imho <br /><br />but the output code will be benchmarked;<br /> - cycles<br /> - density<br /> - activity/load<br /> - goal<br /><br /><strong>programs by code</strong>, i.e output code running on a system<br />while for languages, assume please the following:<br /><br />when one want to start learning assembly i suggest <br />&quot;Art of Assembly&quot; because of R.Hyde&#039;s exaustiveness<br />in examples and visual explanations; and NASM as tool. <br />What ?&nbsp; :shock: NASM, spelled NASM<br />a real assembly tool like NASM. i like it personally only at 40%<br />but it is common like english speaking among coders.<br /><br />HLA isnt assembly, by definition; it is HL,<br />where assembly is not a language, nor HL. <br />assembly means giving a machine functional opcodes <br />to let it work for a goal. people believe it is assembly.<br />that belief makes &quot;semantics&quot;.<br /><br />programs by code as i said, <strong>and languages by semantics.</strong><br /><br /><div class="quote"><br />Unlike the traditional benchmarks for hardware - it can be very difficult to provide unbiased ratings for software.</div><br /><br />yeap, but a multidimensional tool for multidimensional<br />kriteria is being required... and not yet invented.<br />anyway, tuning software is a bit like classifying it good/bad<br />automatically.<br /><br /><div class="quote"><br />And if the program does exactly what you need it to do how do you gauge it based on your criteria?</div><br />one can emulate 80386 on a Quad Core<br />wasting the astronomical power of Quad Core.<br />(in numerical and timing terms)<br /><br />or one can use an old 386 machine, wasting lot<br />of energy and resources, temperatures, indirect<br />Co2 emission etc. (in thermal and energy-saving terms).<br /><br /><div class="quote"><br />And what about user feedback?&nbsp; For example: some people like Windows, some people don&#039;t.</div><br />arent hobbists already at work out there, comparing browser vs browser, or<br />firewall vs firewall ? a scientific way to benchmark the output code <br />allows you to repeat the experiment under the same conditions and have back <br />the same results. hobbists will have a super-tool to be lucky with.<br /><br /><div class="quote"><br />Market share is &quot;usually&quot; a good indicator of a programs worth beyond statistics such as lines of code.</div><br /><br />isnt it exciting the idea to be everytime on the point<br />to break that funny roaring capitalismus lying in front of<br />one&#039;s own eyes ?<br /><br />VV peace VV<br /><br />Cheers,<br />hopcode<br /><br /></div>
    <div class="meta">Posted on 2011-12-08 12:06:57 by hopcode</div>
   </div>
   <div class="post" id="post-215543">
    <div class="subject"><a href="#post-215543">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote"><br />one can emulate 80386 on a Quad Core<br />wasting the astronomical power of Quad Core.<br />(in numerical and timing terms)<br /><br />or one can use an old 386 machine, wasting lot<br />of energy and resources, temperatures, indirect<br />Co2 emission etc. (in thermal and energy-saving terms).</div><br /><br />Not sure what point you&#039;re trying to make here, but I&#039;d like to point out that a 386 CPU used FAR less power than any modern CPU. 386 processors did not even require any kind of cooling whatsoever. Not even a heatsink.<br />A 386 at 25 MHz was 2.89W:<br />http://www.alternatewars.com/BBOW/Computing/Computing_Power.htm<br /><br />It wasn&#039;t until the mid-90s that active cooling was introduced, and the MHz-race ensued, making CPUs go from &lt; 10W to 100W+ in just a few years time. They&#039;ve never gone down since... Those &#039;superhot&#039; Athlons and Pentium 4/D processors we used to ridicule, were no more than the 130W that today&#039;s high-end CPUs require.</div>
    <div class="meta">Posted on 2011-12-08 12:37:46 by Scali</div>
   </div>
   <div class="post" id="post-215546">
    <div class="subject"><a href="#post-215546">Re: Programs by code,languages by semantics</a></div>
    <div class="body">Hi Scali,<br />granted that i am not an overclockers, correct me if i am wrong.<br /><br /><div class="quote"><br />I&#039;d like to point out that a 386 CPU used FAR less power than any modern CPU. 386 processors did not even require any kind of cooling whatsoever. Not even a heatsink. A 386 at 25 MHz was 2.89W </div><br /><br />ok, i did some fast calculations and Tc at 2.89W is ~90째 Celsius from this paper<br /><a target="_blank" href="http://datasheets.chipdb.org/Intel/x86/386/datashts/27242006.pdf">http://datasheets.chipdb.org/Intel/x86/386/datashts/27242006.pdf</a> chap 5.2, table 6 and fig. 4<br />where max Tc should be 110째 and power dissipation ~3,5 Watt.<br />now,<br /><br /><div class="quote"><br />...making CPUs go from &lt; 10W to 100W+ in just a few years time...</div><br /><br />one should decide how to pay the penalties. in fact whenever 30 x 386 machines reach<br />my 95watt profile Quad Core,&nbsp; 100 of them cannot equal the speed and the Tc of one only of my 4 cores<br />running at ~43째 (watt=0), Norton and Vista payed, installed and running.<br /><br />i can conlude the following:<br />technology is not simply technology, but the consequences of technology;<br />rich lands run payed software at a relatively low cost; on the contrary poor lands, <br />that can afford only 100 x 386 machines practically for free need a suplementary technology <br />like cloud or parallel computing to solve their problems dued to their extreme circumstancies. <br />but this results to be a double penalty in my opinion; i would say, <strong>the trap</strong><br />hidden under the leaves in the forest, and bushes of colorfoul wild strawberries all<br />around.<br /><br />whenever people suspect that payed software is not so good as it seems,<br />or they blog telling us their sharp opinions about payed software -open source too<br />they have no way to &quot;benchmark&quot; it and prove how/whether <br />that software is good or bad.<br />this lack of proofs makes the market as described <br />above by p1ranha, a &quot;good indicator&quot;.<br /><br />Cheers,<br /><br />.:mrk<br /> .:x64lab:.<br /> group http://groups.google.com/group/x64lab<br /> site http://sites.google.com/site/x64lab <br /></div>
    <div class="meta">Posted on 2011-12-08 19:41:12 by hopcode</div>
   </div>
   <div class="post" id="post-215549">
    <div class="subject"><a href="#post-215549">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote"><br />one should decide how to pay the penalties. in fact whenever 30 x 386 machines reach<br />my 95watt profile Quad Core,&nbsp; 100 of them cannot equal the speed and the Tc of one only of my 4 cores<br />running at ~43째 (watt=0), Norton and Vista payed, installed and running.</div><br /><br />I think you just phrased it wrong, or I don&#039;t get what you meant.<br /><div class="quote">one can emulate 80386 on a Quad Core<br />wasting the astronomical power of Quad Core.<br />(in numerical and timing terms)<br /><br />or one can use an old 386 machine, wasting lot<br />of energy and resources, temperatures, indirect<br />Co2 emission etc. (in thermal and energy-saving terms).</div><br /><br />The way I read it, you have it exactly the wrong way around. If you were to emulate the speed of a 386 with a quad-core you&#039;d be wasting a lot of energy, since even at idle speeds a modern CPU is more powerhungry than a 386 was at full speed.<br /><br />Obviously if you DON&#039;T emulate the speed of a 386, but use the full power of a modern CPU, it will be more power-efficient, because although it may use more than 40 times as much energy, it is far more than 40 times as fast.<br />But that is not what you said.<br /><br />The temperature figures you quote are completely irrelevant: ~90C is more or less the maximum safe temperature at which silicon can operate. This maximum temperature has been more or less constant over the years, despite all advances in manufacturing process. You will generally find that this is the maximum temperature for any chip, and therefore it is the recommended maximum case temperature for case designs.<br /><br />However, you should look at HOW this temperature is reached. As I said, a 386 does not have any cooling whatsoever, where a modern CPU needs a big heatsink and fan in order to stay below 90 degrees. Without it, an modern CPU would overheat instantly.<br />So a 386 generates a LOT less heat (which is obvious, since it is ~3W, not 100W+).<br /><br />Therefore, if you only need the processing power of a 386, it is better to use that 386. A 386 running 100% all the time is more power-efficient than a modern CPU idling.</div>
    <div class="meta">Posted on 2011-12-09 01:49:31 by Scali</div>
   </div>
   <div class="post" id="post-215550">
    <div class="subject"><a href="#post-215550">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote"><br />If you were to emulate the speed of a 386 with a quad-core you&#039;d be wasting a lot of energy, since even at idle speeds a modern CPU is more powerhungry than a 386 was at full speed.<br />Obviously if you DON&#039;T emulate the speed of a 386, but use the full power of a modern CPU, it will be more power-efficient, because although it may use more than 40 times as much energy, it is far more than 40 times as fast.<br />But that is not what you said.</div><br />perhaps ;)&nbsp; but this i what a was speaking about<br /><a target="_blank" href="http://en.wikipedia.org/wiki/Thermal_resistance">dT = Q x R</a><br />also, i didnt mean the max. presumed safe temperature as in Your following quote<br /><div class="quote"><br />The temperature figures you quote are completely irrelevant: ~90C is more or less the maximum safe temperature...</div><br /><br />the real missing point now is the general vision of the things; given the following<br /><br /><div class="quote"><br />Therefore, if you only need the processing power of a 386, it is better to use that 386. A 386 running 100% all the time is more power-efficient than a modern CPU idling. </div><br /><br />386 doesnt exist, and whenever it exists it holds <strong>in no way</strong> the comparison<br />with the course of technology.<br /><br />Cheers,<br /><br /></div>
    <div class="meta">Posted on 2011-12-09 04:07:52 by hopcode</div>
   </div>
   <div class="post" id="post-215551">
    <div class="subject"><a href="#post-215551">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote"><br />perhaps ;)&nbsp; but this i what a was speaking about<br /><a target="_blank" href="http://en.wikipedia.org/wiki/Thermal_resistance">dT = Q x R</a><br />also, i didnt mean the max. presumed safe temperature as in Your following quote</div><br /><br />What does thermal resistance have to do with anything?<br />Temperature in chips/computers is a direct result of the current passing through them.<br />There is less current passing through a 386 than through a modern CPU, ergo it generates less heat.<br />Just because modern CPUs have larger cooling solutions that dissipate heat better than a 386 doesn&#039;t take away the fact that more heat is generated.<br />In other words: larger currents pass through the system.<br />In other words: more energy is consumed.<br /><br /><div class="quote"><br />386 doesnt exist, and whenever it exists it holds <strong>in no way</strong> the comparison<br />with the course of technology.</div><br /><br />Again, I don&#039;t see your point.<br />You really need to try and explain yourself better, and support your statements with some arguments, because you present some conclusions, with no indication whatsoever of how you reached them.<br />It makes it hard to follow what exactly you are trying to say.<br />386 doesn&#039;t exist? Sure it does! I have one myself.<br />Aside from that, you were the one who brought up the 386 in particular.<br />The issue however is not related to 386 alone.<br />There are plenty of CPUs that are below the idle power consumption of a modern CPU, going all the way up to Pentium III, which may use up to ~30W at 100% load, but due to early power saving features, the average will be much lower.<br />See here for example:<br />http://www.anandtech.com/show/4083/the-sandy-bridge-review-intel-core-i7-2600k-i5-2500k-core-i3-2100-tested/21<br />Even at idle, a Phenom II X6 still uses 20W. Many Pentium II/III CPUs will use less power on average workloads than that CPU at idle.<br />It&#039;s just ridiculous, really.</div>
    <div class="meta">Posted on 2011-12-09 04:35:58 by Scali</div>
   </div>
   <div class="post" id="post-215552">
    <div class="subject"><a href="#post-215552">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote"><br />http://www.anandtech.com/show/4083/the-sandy-bridge-review-intel-core-i7-2600k-i5-2500k-core-i3-2100-tested/21<br />Even at idle, a Phenom II X6 still uses 20W. Many Pentium II/III CPUs will use less power on average workloads than that CPU at idle.<br />It&#039;s just ridiculous, really.<br /></div><br />i dont see why and how it&#039;s ridicoulous. in the example above, all listed CPUs are of<br />relative modern times. people who invented them didnt think to win the competition <br />with the wonderful but very very old 386&#039;s heat dissipation and low watt consumption.<br />one should think relative, not absolutely. that is the reason i inserted a<br />386 in our discussion. i quote it again<br /><div class="quote"><br />one can emulate 80386 on a Quad Core<br />wasting the astronomical power of Quad Core.<br />(in numerical and timing terms)<br /><br />or one can use an old 386 machine, wasting lot<br />of energy and resources, temperatures, indirect<br />Co2 emission etc. (in thermal and energy-saving terms).<br /></div><br />you cannot have both. technology tries to solve the problem<br />in different ways. but one should decide in every moment <br />the penalty according to the case.<br />not agreeing with the fact doesnt mean that the fact is ridiculous.<br />not agreiing with the fact means ignoring how technology<br />evolves.<br />i hope it is plain now.<br />Cheers,<br /><br /><br /></div>
    <div class="meta">Posted on 2011-12-09 05:01:33 by hopcode</div>
   </div>
   <div class="post" id="post-215553">
    <div class="subject"><a href="#post-215553">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote"><br />i dont see why and how it&#039;s ridicoulous.</div><br /><br />Well, I think it&#039;s quite obvious:<br />In the old days, all my computers were cooled passively. They didn&#039;t generate a lot of heat, and more importantly: they did not generate any noise. Okay, so 386&#039;es don&#039;t quite fit in there, since most of them had a fan in the PSU, but most other home/personal computers of the time did not... from a C64 to a NES, Amiga, Atari ST, etc... At any rate, it wasn&#039;t the CPU that caused the need for cooling. With a different/external PSU, a 386 system could be fanless, like the others.<br />Then we went to heatsinks on our CPUs... not too bad, at least they don&#039;t make noise...<br />But then we got fans too... and we didn&#039;t stop at the CPU... noooo, the GPU would get big fans as well.<br />Especially in the days of early Athlon/Pentium 4, PCs were horribly noisy.<br />These days it&#039;s reasonably under control, as long as your system is idle, that is... If you system runs at 100%, it&#039;s still incredibly noisy.<br /><br />And that&#039;s just one of the problems. Another one is how useless laptops are with these powerhungry CPUs. It&#039;s hard to find a laptop that can last for more than 2-3 hours on a single battery... which doesn&#039;t weigh a ton... and doesn&#039;t try to burn a hole in your lap.<br /><br /><div class="quote"><br />one should think relative, not absolutely. that is the reason i inserted a<br />386 in our discussion. i quote it again<br /><div class="quote"><br />one can emulate 80386 on a Quad Core<br />wasting the astronomical power of Quad Core.<br />(in numerical and timing terms)<br /><br />or one can use an old 386 machine, wasting lot<br />of energy and resources, temperatures, indirect<br />Co2 emission etc. (in thermal and energy-saving terms).<br /></div><br /></div><br /><br />That is still broken logic, as the quadcore will generate more heat, consume more energy, and as such will cause more CO2 emissions than a 386 (yes, even when the quadcore is completely idle, as demonstrated by the Anandtech article I linked earlier: modern quadcores range from 3W-20W when idle).<br /><br /><div class="quote"><br />you cannot have both.</div><br /><br />You can, actually. Just not from the ridiculousness that is the x86 architecture.<br />ARM is a fine example of how CPUs can be both power-efficient, and deliver modern levels of performance.<br />You can get a quadcore ARM processor in a tablet or smartphone, with no special cooling required, and with reasonable battery life.<br />No doubt ARM-based laptops will be quite popular once Windows 8 arrives.<br /><br /><div class="quote"><br />not agreeing with the fact doesnt mean that the fact is ridiculous.<br />not agreiing with the fact means ignoring how technology<br />evolves.<br />i hope it is plain now.<br />Cheers,<br /></div><br /><br />Technology involves in more ways than just the x86-world.<br />Because Intel and AMD failed to deliver power-efficient solutions, many other hardware vendors jumped into that market. Are you ignoring that?</div>
    <div class="meta">Posted on 2011-12-09 06:39:36 by Scali</div>
   </div>
   <div class="post" id="post-215556">
    <div class="subject"><a href="#post-215556">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote"><br />And that&#039;s just one of the problems. Another one is how useless laptops are with these powerhungry CPUs. It&#039;s hard to find a laptop that can last for more than 2-3 hours on a single battery... which doesn&#039;t weigh a ton... and doesn&#039;t try to burn a hole in your lap.<br /></div><br /><br />I too find it a sorry state of affairs for those exact reasons.<br /><br /><div class="quote"><br />Technology involves in more ways than just the x86-world.<br />Because Intel and AMD failed to deliver power-efficient solutions, many other hardware vendors jumped into that market.<br /></div><br /><br />As you mentioned earlier, obviously Intel and AMD aren&#039;t the only companies trying to provide users with powerful solutions.&nbsp; However, that power comes at a price.<br /><br />I recently purchased an nVidia GTX 560 Ti graphics card for my system.&nbsp; The card itself takes up two slots and is nearly as thick as a CDROM player.&nbsp; It has a heatsink, pipes, and two fans to cool it.&nbsp; Wicked fast card card that never breaks a sweat playing anything I&#039;ve thrown at it.<br /><br />The computer case that houses all my components contains 4 120mm fans to keep air moving through.&nbsp; Fortunately, I still don&#039;t require water cooling my system just yet.<br /><br />Until science discovers some other method besides silicon that can be economically manufactured and reasonably priced I believe we&#039;ll be dealing with cooling/power/efficiency issues for a long time...<br /><br /></div>
    <div class="meta">Posted on 2011-12-09 07:51:25 by p1ranha</div>
   </div>
   <div class="post" id="post-215557">
    <div class="subject"><a href="#post-215557">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote"><br />As you mentioned earlier, obviously Intel and AMD aren&#039;t the only companies trying to provide users with powerful solutions.&nbsp; However, that power comes at a price.</div><br /><br />Luckily you still have a choice with videocards.<br />You can either use onboard graphics, which requires no additional cooling at all...<br />Or you could choose a card with a passive cooling solution.<br />The more low-end cards are generally passively cooled anyway. And specialist brands offer passively cooled versions of high-end cards as well.<br />With CPUs, you&#039;re not that lucky: it&#039;s very hard to find x86 CPUs that can be passively cooled at all, outside the horribly underperforming Atoms of this world.<br />And non-x86 CPUs aren&#039;t an option for desktop systems at this moment, since most software won&#039;t work on them.<br /><br /><div class="quote"><br />Fortunately, I still don&#039;t require water cooling my system just yet.</div><br /><br />I actually DO have watercooling on my CPU.<br />These days there are inexpensive kits from brands such as Corsair. Intel and AMD are even starting to offer them as &#039;stock&#039; cooling solutions.<br />I don&#039;t use it because a fan solution can&#039;t keep my system cool. I use it because the watercooling moves the heat to a radiator which can be cooled with a 120mm case fan, which is a nice and silent solution.</div>
    <div class="meta">Posted on 2011-12-09 08:01:00 by Scali</div>
   </div>
   <div class="post" id="post-215558">
    <div class="subject"><a href="#post-215558">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote"><br />...Another one is how useless laptops are with these powerhungry CPUs. It&#039;s hard to find a laptop that can last for more than 2-3 hours on a single battery... which doesn&#039;t weigh a ton... and doesn&#039;t try to burn a hole in your lap.<br /></div><br />my laptop is a Siemens 32 bit Xp Os. running ZoneAlarm and Kaspersky disconnected<br />battery dies after 1 hour and 10 minutes. disabling them and running <strong>20 or more</strong> of my tools working in background<br />battery lives almost 3 hours and 45 mins. <strong>programs by code</strong><br /><br /><div class="quote"><br />That is still broken logic, as the quadcore will generate more heat, consume more energy, and as such will cause more CO2 emissions than a 386 (yes, even when the quadcore is completely idle, as demonstrated by the Anandtech article I linked earlier: modern quadcores range from 3W-20W when idle).</div><br /><br />no, because the point is marking code as &quot;good&quot; when it keeps the CPU at an almost idle state <br />while it executes its task though.<br /><br /><div class="quote"><br />you cannot have both.</div><br /><div class="quote"><br />You can, actually. Just not from the ridiculousness that is the x86 architecture.<br />ARM is a fine example of how CPUs can be both power-efficient, and deliver modern levels of performance.<br /></div><br />i wouldnt say &quot;ridiculosness&quot; to 386 anyway, for the reasons involving what technology is,<br />as i explained above.<br />but ARM is another namespace, another chapter, worth to be investigated. for the reasons<br />i told above about thermal performances of 386 machines, i suggested already and publicly those people obsessioned from 386 and &quot;Dos-is-not-dead&quot; ghost to resolve to ARM.<br />obviously, You couldnt have known it before i explicitely<br />manifested here on board.<br />now,<br />Q: what about 386 machines ?<br />A: they actually do not exist.<br /><br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2011-12-09 08:07:45 by hopcode</div>
   </div>
   <div class="post" id="post-215559">
    <div class="subject"><a href="#post-215559">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote"><br />no, because the point is marking code as &quot;good&quot; when it keeps the CPU at an almost idle state <br />while it executes its task though.</div><br /><br />I think that depends on what the task is and does.<br />If it&#039;s mainly IO-bound, then yes, it should keep the CPU idle while it is waiting for IO to complete (rather than spinning the CPU uselessly while polling for results).<br />It cannot complete faster than the IO allows it to.<br />However, if it&#039;s a computational task, then the more important thing is how quickly it gets the job done. Running the CPU at 100%, but for a shorter amount of time, means the CPU gets to be idle longer.<br />Generally you&#039;ll just want the code to have the shortest possible execution time. The actual CPU load is not that relevant. If you don&#039;t want 100% CPU usage, you can always limit the amount of cores the process can have, or lower its priority. You have all the control you want.<br /><br /><div class="quote"><br />for the reasons i told above about thermal performances of 386 machines, i suggested already and publicly those people obsessioned from 386 and &quot;Dos-is-not-dead&quot; ghost to resolve to ARM.</div><br /><br />From here it looked more like you thought that modern CPUs used less power than old CPUs.<br /><br /><div class="quote"><br />Q: what about 386 machines ?<br />A: they actually do not exist.<br /></div><br /><br />Not sure why you keep saying that. 386 CPUs clearly DO exist. In fact, NASA still uses them:<br />http://www.cpushack.com/space-craft-cpu.html</div>
    <div class="meta">Posted on 2011-12-09 08:18:32 by Scali</div>
   </div>
   <div class="post" id="post-215563">
    <div class="subject"><a href="#post-215563">Re: Programs by code,languages by semantics</a></div>
    <div class="body">IO-constraint is a good point in the list of the to-be-solved things already,<br />and i have any idea at the moment.<br /><div class="quote"><br />From here it looked more like you thought that modern CPUs used less power than old CPUs.<br /></div><br />no, again. because the thing is complex, and i try to express in few words <br />what i mean. you demand low wattage and hi computational<br />power from a machine. they both should be always bound together.<br /><br /><div class="quote"><br />Not sure why you keep saying that. 386 CPUs clearly DO exist. In fact, NASA still uses them:<br />http://www.cpushack.com/space-craft-cpu.html<br /></div><br />good, but dont forget the point: <strong>Programs by code</strong>.<br />now, if You provide source code (or binaries), that would be worth <br />for a new discussion thread. perhaps they have patented code i would like to benchmark;<br />code that both You and me cannot imagine, capable on 386 to decode<br />a youtube video at the same computational power and low energy<br />requirements of a recent ARM processor.<br /><br />Cheers,<br /><br /><br /></div>
    <div class="meta">Posted on 2011-12-11 06:07:32 by hopcode</div>
   </div>
   <div class="post" id="post-215564">
    <div class="subject"><a href="#post-215564">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote"><br />no, again. because the thing is complex, and i try to express in few words <br />what i mean. you demand low wattage and hi computational<br />power from a machine. they both should be always bound together.</div><br /><br />Firstly, I demand no such thing.<br />I&#039;m just pointing out a flaw in what *YOU* said (not me):<br /><div class="quote">one can emulate 80386 on a Quad Core<br />wasting the astronomical power of Quad Core.<br />(in numerical and timing terms)<br /><br />or one can use an old 386 machine, wasting lot<br />of energy and resources, temperatures, indirect<br />Co2 emission etc. (in thermal and energy-saving terms).</div><br /><br />Again, this is *WRONG*. A 386 does not generate a lot of heat and does not consume a lot of energy compared to a modern quadcore. Hence there is no way I can make sense of this statement.<br />The only thing you WOULD be wasting with the 386 is time, since obviously the 386 does not have a lot of computing power.<br />However, the point is this:<br />Say you perform a task that takes 1 hour to complete on a 386, and 1 second to complete on the quadcore.<br />The quadcore then is more energy-efficient *if* you turn it off after it is complete. If you leave the quadcore idling for the remainder of the hour, it will still have used more power than the 386.<br /><br />I really don&#039;t see why you keep arguing against that. In fact, you&#039;re not even arguing at all.<br />Arguing would imply that you present arguments to support your position, which you haven&#039;t done at all. You just don&#039;t acknowledge my arguments, which are clear as day.<br /><br />Secondly, I don&#039;t demand low wattage and high computational power. I would just like the two to be a bit more balanced. Modern-day computing power in a &lt; 10W TDP envelope would be interesting indeed for small and/or silent devices. It should be possible with today&#039;s technology to have the performance of 5-10 year old CPUs at &lt; 10W. That should still be sufficient power for most everyday tasks.<br /><br /><div class="quote"><br />good, but dont forget the point: <strong>Programs by code</strong>.</div><br /><br />What do you mean by that exactly? &quot;Programs by code&quot;?<br />Programs are code, but other than that I don&#039;t see what you are driving at here.<br />Could you explain that?<br /><br /><div class="quote"><br />perhaps they have patented code i would like to benchmark;<br />code that both You and me cannot imagine, capable on 386 to decode<br />a youtube video at the same computational power and low energy<br />requirements of a recent ARM processor.</div><br /><br />I think you&#039;re barking up the wrong tree there.<br />There are chips on the market that are capable of playing HD video at under 3W. But they are not conventional CPUs, they are video decoding chips.<br />Most modern GPUs contain very efficient video decoding circuitry as well, requiring little or no CPU power to play videos.<br />For example, if I play this video in 1080p: http://www.youtube.com/watch?v=12NRj4RD0Io<br />My CPU usage remains below 10%, and the CPU and GPU do not come out of idle mode, with low voltage and clockspeed (it runs at 1.2 GHz and 0.8v, where it runs at 2.8 GHz or more at full speed/turbo, and 1.2v):<br /><img src="http://bohemiq.scali.eu.org/EfficientYouTube.png" /><br />So that is an example of energy-efficient &#039;code&#039;.<br />Although ARM CPUs are more efficient than x86 CPUs, in this case it is irrelevant, as ARM systems work the same way: special video decoding circuitry handles the decoding more efficiently than a general purpose CPU.</div>
    <div class="meta">Posted on 2011-12-11 08:48:58 by Scali</div>
   </div>
   <div class="post" id="post-215565">
    <div class="subject"><a href="#post-215565">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote"><br />However, the point is this:<br />Say you perform a task that takes 1 hour to complete on a 386, and 1 second to complete on the quadcore.<br />The quadcore then is more energy-efficient *if* you turn it off after it is complete. If you leave the quadcore idling for the remainder of the hour, it will still have used more power than the 386.<br /></div><br />the NASA ?&nbsp; :lol:<br />it happens already,after moving the mouse on Windows and then restarting<br />the PC to let changes become effective. also,<br />show me code please, spelled &quot;<strong>Programs by code</strong>&quot;, not videos<br />Cheers,<br /><br />.:mrk<br />&nbsp; .:x64lab:.<br /> group http://groups.google.com/group/x64lab<br /> site http://sites.google.com/site/x64lab </div>
    <div class="meta">Posted on 2011-12-11 12:06:48 by hopcode</div>
   </div>
   <div class="post" id="post-215566">
    <div class="subject"><a href="#post-215566">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote"><br />the NASA ?&nbsp; :lol:<br />it happens already,after moving the mouse on Windows and then restarting<br />the PC to let changes become effective.</div><br /><br />Is anyone else having as much trouble following this guy as I am?<br />I feel lost in a sea of non-sequiturs.<br /><br /><div class="quote"><br />show me code please, spelled &quot;<strong>Programs by code</strong>&quot;</div><br /><br />What code? What programs? What are you talking about?</div>
    <div class="meta">Posted on 2011-12-11 12:11:30 by Scali</div>
   </div>
   <div class="post" id="post-215567">
    <div class="subject"><a href="#post-215567">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote"><br />What code? What programs? What are you talking about?<br /></div><br />I told You about it above in the subject.<br /><strong>Programs by code,languages by semantics</strong><br /><br /><br /></div>
    <div class="meta">Posted on 2011-12-11 12:46:52 by hopcode</div>
   </div>
   <div class="post" id="post-215568">
    <div class="subject"><a href="#post-215568">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote"><br />I told You about it above in the subject.<br /><strong>Programs by code,languages by semantics</strong><br /></div><br /><br />And I asked you to clarify, because I don&#039;t understand what you mean.</div>
    <div class="meta">Posted on 2011-12-11 13:20:32 by Scali</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=30791&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=30791&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="30791" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=30791&amp;page=2">&gt;</a><a href="../?id=30791&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>