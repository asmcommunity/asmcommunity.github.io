<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Programs by code,languages by semantics - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30791" />
  <link rel="prev" href="../?id=30791&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=30791">Programs by code,languages by semantics</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=30791&amp;page=1" style="">&laquo;</a><a href="../?id=30791&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="30791" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-215569">
    <div class="subject"><a href="#post-215569">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote"><br />And I asked you to clarify, because I don&#039;t understand what you mean.<br /></div><br />well, i think my answer to p1rahna is plain.<br /><br />p.s.<br />i remain logged</div>
    <div class="meta">Posted on 2011-12-11 13:30:57 by hopcode</div>
   </div>
   <div class="post" id="post-215570">
    <div class="subject"><a href="#post-215570">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote">Is anyone else having as much trouble following this guy as I am?</div><br /><br /><strong>To Scali</strong><br />Very much so. I&#039;m not sure if it&#039;s a language barrier or what, but I think the &quot;code&quot; he&#039;s talking about is some kind of benchmarking code he wants someone to write...(?)<br /><br /><strong>To hopcode</strong><br />My understanding of this thread is; you want to come up with some form a standard for benchmarking software for general speed, stability, development times, etc.<br /><br />If that&#039;s the case, give up. There is no way you&#039;ll ever create an impartial system for judging all cases of development because very few people develop in the same fashion. Theoretically, it&#039;s a neat idea. But there is very little practical use for such a system/software.<br /><br />Now, as for individually analysing each aspect of development to improve your OWN methodology is always a good idea. You can optimize software speed by simply counting the clock-cycles of your software and validating that against some high performance counters. For obtaining the best stability, I suggest adapting some form of safety critical design standard, I personally have adapted quite a bit of NASA&#039;s standard into my own coding style [1]. And for the sake of analysing development times, learn to create a analyse GANTT charts to find out where you spend the most time working and try to figure out what parts you might be able to multi-task.<br /><br />You see, most of these things have been addressed individually and overall performance mostly boils down to the skill of the individuals working on each project. Trying to create a classification system which tells consumers and developers how a specific software stands up to your idea of &quot;good software&quot; is just ridiculous. You should think of software as a solution to a problem which can evolve to fit various adaptations of the problem. &quot;Good&quot; and &quot;Bad&quot; are just your opinion on a developer&#039;s solution in your given situation. What really should be done is to remove all forms of classifications from software and let the users decide on their own. People <strong>are</strong> capable of doing that.<br /><br />[1] www.hq.nasa.gov/office/codeq/doctree/871913.pdf<br /><br />Now, as for the 386 argument.. I don&#039;t really see how you can say that it doesn&#039;t exist any more. I quite regularly develop on 8-bit systems! 16-bit systems if I&#039;m feeling a need for heavy processing. For people like me, the 386 is still considered a high-end chip. I think the most modern CPU I have is an Intel Atom 32-bit processor in my first generation netbook. These quad-core systems are something I just don&#039;t have a use for and probably won&#039;t for quite a while.<br /><br /><hr /><br /><br />I&#039;m probably completely off base with the conversation, like Scali, I have trouble following your discussion and I&#039;m completely lost on what you mean by things like &#039;show me code please, spelled &quot;Programs by code&quot;, not videos&#039;.&nbsp; I&#039;m sure if you clarified yourself much better, people might make better sense of the discussion.<br /><br />If I am completely off base on what your discussing, sorry :lol:<br /><br />Regards,<br />Bryant Keller</div>
    <div class="meta">Posted on 2011-12-11 18:03:59 by Synfire</div>
   </div>
   <div class="post" id="post-215572">
    <div class="subject"><a href="#post-215572">Re: Programs by code,languages by semantics</a></div>
    <div class="body">Hi Synfire,<br /><strong>Y</strong>-ou is you You<br /><strong>y</strong>-ou is you all<br /><br />i see that from Your link and Your statements You have understood very well what the matter is.<br /><strong>ergo</strong> its not a language problem. whenever it is so, dont forget please that<br />not all people over the planet speak the language you speak.<br /><br />i am discussing the same subject &quot;<strong>Programs by code,languages by semantics</strong>&quot; <br />on 2 other external forums, using almost the same language&nbsp; that people<br />understand enough;from them i have already recieved some valuable hints.<br /><br />i didnt set it on the moral side &quot;bad&quot; &quot;good&quot; etc, also please dont set it so up.<br /><strong>good</strong> is that code that can hi computational power and minimal resource<br />requirements.<br />should i explain it again for Scali too ?<br /><br />Cheers,<br />.:mrk<br />&nbsp; .:x64lab:.<br /> group http://groups.google.com/group/x64lab<br /> site http://sites.google.com/site/x64lab <br /></div>
    <div class="meta">Posted on 2011-12-11 19:30:23 by hopcode</div>
   </div>
   <div class="post" id="post-215573">
    <div class="subject"><a href="#post-215573">Re: Programs by code,languages by semantics</a></div>
    <div class="body">btw, Syn<br />thanks for Your link. i had taken a fast look to it<br /><div class="quote"><br />[1] www.hq.nasa.gov/office/codeq/doctree/871913.pdf<br /></div><br />it&#039;s the <strong>O</strong>verbloating <em>par excellence</em>.<br />is that really Your personal concrete thinking and coding way ?<br />Cheers,<br /><br /></div>
    <div class="meta">Posted on 2011-12-11 19:45:13 by hopcode</div>
   </div>
   <div class="post" id="post-215574">
    <div class="subject"><a href="#post-215574">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote">whenever it is so, dont forget please that<br />not all people over the planet speak the language you speak.</div><br /><br />I believe that was the point I was making....<br /><br /><div class="quote">i didnt set it on the moral side &quot;bad&quot; &quot;good&quot; etc, also please dont set it so up.</div><br /><br />I feel the language barrier is kicking in again here. I didn&#039;t suggest any moral baring on the terms good and bad. My suggesting was that the view of good is always going to be subjective. Because of this, creating a &quot;standard&quot; would be futile.<br /><br /><div class="quote"><strong>good</strong> is that code that can hi computational power and minimal resource<br />requirements.</div><br /><br />But how can you standardize something like that? Both of these terms are subjective to the specific project. My minimal resource requirements usually include something along the lines of an 8-bit AVR and a Linux HID module. Neither of those are going to be useful if someone is developing a video game or something that does scientific number crunching.<br /><br /><div class="quote">btw, Syn<br />thanks for Your link. i had taken a fast look to it<br /></div><br /><br />No problem.<br /><br /><div class="quote">it&#039;s the <strong>O</strong>verbloating <em>par excellence</em>.<br />is that really Your personal concrete thinking and coding way ?</div><br /><br />To be honest, it really depends on the project itself. The idea of safety critical development is to apply fault protection to applications which simply cannot fail. If you write something which might cause harm to a person or an environment, you must take as many steps as possible to prevent this. That&#039;s not something people who write consumer products deal with a lot, but not all programmers are writing consumer products.</div>
    <div class="meta">Posted on 2011-12-11 23:32:35 by Synfire</div>
   </div>
   <div class="post" id="post-215576">
    <div class="subject"><a href="#post-215576">Re: Programs by code,languages by semantics</a></div>
    <div class="body">High computational power AND low resource requirements?<br />If your idea of &#039;high computational power&#039; is SPEED, then these terms are mutually exclusive.<br />There is ALWAYS a tradeoff between speed and size, this is an observable and undeniable philosophical truth of programming, at every level this is true, at the lowlevel decision of which opcodes to use, at the highlevel choice of which algorithm to use, and even inside every variant of the algorithm, you trade speed for size, so choose your poison! There is no middle ground, unless you accept mediocrity.</div>
    <div class="meta">Posted on 2011-12-12 01:00:28 by Homer</div>
   </div>
   <div class="post" id="post-215577">
    <div class="subject"><a href="#post-215577">Re: Programs by code,languages by semantics</a></div>
    <div class="body"><div class="quote"><br />My suggesting was that the view of good is always going to be subjective. Because of this, creating a &quot;standard&quot; would be futile.</div><br /><br />On top of that, even things that you COULD objectively measure, such as total program size, memory consumption, total running time and such, have only limited use.<br />Namely, there is a large variety of hardware out there. What is the best/smallest/fastest/etc for one configuration may not necessarily hold true for another.<br />For example, one could write an optimized routine for MMX-capable CPUs. This may be the best possible implementation known to man... But it still works within the limits of MMX. For newer CPUs, which have newer instructionsets, such as SSE or AVX, the MMX version is likely to be quite suboptimal.<br /><br />In fact, I know from experience that optimized code for one MMX-capable CPU (eg Pentium MMX) is not necessarily very efficient for another CPU (eg Pentium II), because of architectural differences (in this case, the code was written for the lower latencies of the Pentium MMX, and could not deal with the higher latencies that the Pentium II had. The routine had to be rewritten to deal with the new architecture, but this resulted in slightly lower performance on Pentium MMX).<br /><br />So in theory, the optimal code (whether it be speed, size, power consumption, or whatever other criteria) is very specific to a single system (and goes beyond just the CPU as well, as the YouTube example above demonstrates: some systems can offload work from the CPU to dedicated processing units).<br />In practice, you will only find such optimized code for systems with fixed hardware specs, such as game consoles. For most applications, the code is not really optimized for a specific system, but is written in a way so that it performs acceptably on a wide variety of configurations. In this sense, optimizing is more about avoiding pitfalls on specific systems than on extracting the absolute maximum out of the hardware.</div>
    <div class="meta">Posted on 2011-12-12 07:44:08 by Scali</div>
   </div>
   <div class="post" id="post-215579">
    <div class="subject"><a href="#post-215579">Re: Programs by code,languages by semantics</a></div>
    <div class="body">Hi Synfire,<br /><div class="quote"><br />...the lines of an 8-bit AVR...<br /></div><br />i find interesting the AVR point You said,<br />because a clever tuning/profiling/<strong>benchmarking</strong> the code in there is not an option.<br />Actually i dont know nothing about AVR, and i may ask You something.<br /><br />for <strong>Scali</strong>, i am sorry; i think he is completely out-of-scope; <br />apart the divine inspiration he got from the IO-constraints,<br />he is always there on stating something obvious again (no<br />offense)<br /><br />for the other, were they speaking about &quot;standards&quot; or <br />about &quot;subjective computing&quot; ?;&nbsp; i will try to understand.<br /><br />for now i can provide the following quote that <br />will give you an enlightenment<br /><br /><pre><code>&quot;First, energy-efficiency is a key metric for these designs. <br />Second, energy-proportional computing must be the ultimate goal <br />for both hardware architecture and software-application design. <br />While this ambition is noted in macro-scale computing in large-scale data centers,<br />the idea of micro-scale energy-proportional computing in microprocessors is even more challenging. <br />For microprocessors operating within a finite energy budget, energy efficiency corresponds <br />directly to higher performance, so the quest for extreme energy efficiency <br />is the ultimate driver for performance.&quot;</code></pre><br /><br />consider it a present for you and an hommage to <br />R. Noyce for his birthday, coming from this paper<br /><br />http://cacm.acm.org/magazines/2011/5/107702-the-future-of-microprocessors/fulltext<br /><br />Cheers,<br /><br />p.s please,Syn,do it for me,<br />dont debase Your posts again with the matter of the language<br />barrier kicking again. i know what You are capable of from<br />Your code.<br />You may think to confess to Yourself the following truth:&nbsp; ;)<br /><em>&quot;Yes, I understand what hopcode said&quot;</em><br /><br />..:mrk<br />&nbsp; .:x64lab:.<br /> group http://groups.google.com/group/x64lab<br /> site http://sites.google.com/site/x64lab </div>
    <div class="meta">Posted on 2011-12-12 17:20:02 by hopcode</div>
   </div>
   <div class="post" id="post-215585">
    <div class="subject"><a href="#post-215585">Re: Programs by code,languages by semantics</a></div>
    <div class="body">well,after 3 days thinking upon it, (i am quite slow in comprehension&nbsp; :))<br />i have learned it at heart like a psalm, because i think it&#039;s revealing.<br /><ul><br /><li> <strong>K</strong> multi-Kore</li><br /><li> <strong>A</strong> embedded Accelerators</li><br /><li> <strong>C</strong> Cache</li><br /><li> <strong>DCL</strong> dynamic customizable logic (DCL)</li><br /></ul><br />then considering <strong>IO</strong>-constraints, as from Scali&#039;s suggestion<br />let us bake a general function for the computational power (delta cp)<br />of some code running on a system<br /><br /><pre><code>dcp = f(dcl,k,a,c,io)</code></pre><br /><br />where the cache above will be bound to<br /><ul><br /><li> <strong>is</strong> instruction set</li><br /><li> <strong>ds</strong> data set</li><br /><li> <strong>t</strong> threading capability (common feature to SW and HW)</li><br /></ul><br /><pre><code>dc = f(t,is,ds)</code></pre><br /><br />this is for now,<br />any else ingredient/modificatin to the fantastic recipe ?<br /><br />Cheers,<br /><br />.:mrk<br />&nbsp; .:x64lab:.<br /> group http://groups.google.com/group/x64lab<br /> site http://sites.google.com/site/x64lab<br /></div>
    <div class="meta">Posted on 2011-12-15 01:33:46 by hopcode</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=30791&amp;page=1" style="">&laquo;</a><a href="../?id=30791&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="30791" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>