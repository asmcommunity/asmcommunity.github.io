<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>SafeArrayGetElement - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=28830" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=28830">SafeArrayGetElement</a></p>
   <div class="post" id="post-203737">
    <div class="subject"><a href="#post-203737">SafeArrayGetElement</a></div>
    <div class="body">I am having trouble with<br /><br />invoke SafeArrayGetElement, param1, ADDR counter, EDI<br /><br />invoke SafeArrayGetElement, IN, IN, OUT<br /><br />I am sure my param 1 is a pointer to a safearray as it has worked in other function calls.&nbsp; And I have been able to read param1’s elements videlicet: cDims, fFeatures, cbElements, and there seems to be some pvData too, but its Greek to me.<br />I have tried calling this function from counter = 0 to well below –1, but I only get DISP_E_BADINDEX.&nbsp; I tried multidimensional arrays in place of counter but that just gives me E_INVALIDARG.&nbsp; And just imagine the number of multidimensional arrays you could try.&nbsp; I have tried qword counters and many other things in place of counter and that just freezes the Excel worksheet that is calling the DLL that this function is in.<br /><br />I know there are some bogus functions, but I have seen a lot of examples of this called on the net.&nbsp; But I have not seen it called in an assembly DLL for a VB macro in an Excel worksheet.<br /><br />I do believe it would be easier to write the param1 data to a file and have the dll work on the file data. But I desire to figure this one out.<br /><br />I have tried locking and unlocking the safearray first too.<br /><br />I have tried different things in param3 like VARIANTs too. But that results in more exceptional freezes.<br /><br />VB sucks.<br /><br />Why do they – the people who live over there and do that to them-- make functions that don’t work?<br /></div>
    <div class="meta">Posted on 2007-11-25 18:31:11 by roaknog</div>
   </div>
   <div class="post" id="post-203738">
    <div class="subject"><a href="#post-203738">Re: SafeArrayGetElement</a></div>
    <div class="body">Make sure you&#039;re passing the ADDRESS where the indices in question are stored, and not the indices themselves.<br /><br />That&#039;s all I can say without seeing the code.</div>
    <div class="meta">Posted on 2007-11-25 19:01:30 by ti_mo_n</div>
   </div>
   <div class="post" id="post-203771">
    <div class="subject"><a href="#post-203771">Re: SafeArrayGetElement</a></div>
    <div class="body">I finally got it to work.&nbsp; SafeArrayPutElement is persnickety.&nbsp; I could feel my head get hot in my endeavor to code for it.<br /><br /><pre><code>.686 <br />.model flat, stdcall<br />option casemap:none <br /><br /><br />	include user32.inc<br />	include oleaut32.inc<br />	include kernel32.inc<br /><br />	includelib user32.lib<br />	includelib oleaut32.lib<br />	includelib kernel32.lib<br /><br /><br /><br />	GetElementsFromSafearray	PROTO p1:DWORD, p2:DWORD<br />	OutputNumber			PROTO p1:DWORD<br />	PutElementsIntoSafearray	PROTO p1:DWORD, p2:DWORD<br />	wsprintfA			PROTO C :DWORD,:VARARG<br />	wsprintf			EQU &lt;wsprintfA&gt;<br /><br /><br /><br />.data<br />; structures<br />	SAFEARRAYBOUND			STRUC<br />	cElements			DWORD 0<br />	Lbound				DWORD 0<br />	SAFEARRAYBOUND			ENDS<br />	aDim				SAFEARRAYBOUND &lt;&gt;<br />	SAFEARRAY			STRUC		; size = 12 bytes <br />	cDims				WORD 0		; Count of dimensions in this array.<br />	fFeatures			WORD 0		; Flags used by the SafeArray<br />	cbElements			DWORD 0		; Size of an element of the array. Does not include size of pointed-to data.<br />	cLocks				DWORD 0		; Number of times the array has been locked without corresponding unlock.<br />	pvData				DWORD 0<br />	rgsabound1			SAFEARRAYBOUND &lt;&gt;, &lt;&gt;<br />	SAFEARRAY			ENDS<br />	PSAFEARRAY			TYPEDEF PTR SAFEARRAY<br />	p_s_a				PSAFEARRAY 0<br />	ARRAY				STRUC<br />	my_array			DWORD 1000 dup (0)<br />	ARRAY				ENDS<br />	array				ARRAY &lt;&gt;<br />	PARRAY				TYPEDEF PTR ARRAY<br /><br />; general variables<br />	cw_msg				DB 10, 13, 10, 13, &#039;&nbsp; &nbsp;  Freehafer&#039;&#039;s 32 Bit Safearray Program Is Terminated!&#039;, 10, 13, 10, 13, &#039;&nbsp; &nbsp;  (c)2007 INNIEA PUBLISHING CO.&nbsp; R&#039;, 153, 142, &#039;K NOG!&#039;, 10, 13, 10, 13, &#039;&nbsp; &nbsp;  Hit enter key to exit . . . &#039;, 0<br />	create_msg			DB &#039;Call to SafeArrayCreate is bad.&#039;, 0<br />	input_msg			DB 10, 13, 10, 13, &#039;&nbsp; &nbsp;  Input a zero based index number: &#039;, 0<br />	total_index_count		DWORD 17<br /><br />; put safearray element procedure variables<br />	put_error_msg			DB &#039;Call to SafeArrayPutElement is bad.&#039;, 0<br />	aindex				DWORD 1000 dup (0)<br />	ai				DWORD 1000 dup (0)<br /><br />; get safearray element procedure variables<br />	buffy				DB 512 dup (?)<br />	new_line			DB 10, 13, 10, 13, &#039;&nbsp; &nbsp;  Index = %d&nbsp; &nbsp;  Value = %d.&#039;, 0<br />	get_error_msg			DB &#039;Call to SafeArrayGetElement is bad.&#039;, 0<br /><br />; display number procedure variable<br />	num_char_written		DD 0<br />	bytes_to_write			DB 0<br /><br />; input number procedure variables<br />	num_char_read			DD 0<br />	bytes_to_read			DB 0<br /><br />; get handles procedure variables<br />	w_std_handle			DD 0<br />	r_std_handle			DD 0<br /><br /><br /><br />.code<br />start:<br />	call GetHandles<br />	invoke WriteConsole, w_std_handle, ADDR input_msg, sizeof input_msg, ADDR num_char_written, 0<br />	call InputNumber<br />	mov total_index_count, EAX<br /><br />	mov DWORD PTR , 0<br />	mov DWORD PTR , 1<br />	mov EAX, total_index_count<br />	mov DWORD PTR , EAX<br />	lea EAX, DWORD PTR <br />	invoke	SafeArrayCreate, 2, 1, EAX<br />	.if EAX == 0<br />		invoke MessageBoxA, 0, ADDR create_msg, 0, 0<br />	.endif<br />	mov p_s_a, EAX<br /><br />	invoke PutElementsIntoSafearray, p_s_a, total_index_count<br />	invoke GetElementsFromSafearray, p_s_a, total_index_count<br /><br />	ASSUME ESI:PARRAY<br />	mov ESI, EAX<br />	mov ECX, 0<br />	mov EBX, 0<br />	.while ECX &lt; total_index_count<br />		mov EAX, DWORD PTR <br />		add EBX, 4<br />		pusha<br />		invoke wsprintf, ADDR buffy, ADDR new_line, ECX, EAX<br />		invoke WriteConsole, w_std_handle, ADDR buffy, EAX, ADDR num_char_written, 0<br />		popa<br />		inc ECX<br />	.endw<br />	ASSUME ESI:NOTHING<br /><br />	invoke WriteConsole, w_std_handle, ADDR cw_msg, sizeof cw_msg, ADDR num_char_written, 0<br />	invoke ReadConsole, r_std_handle, ADDR bytes_to_read, 1, ADDR num_char_read, 0<br />	invoke ReadConsole, r_std_handle, ADDR bytes_to_read, 1, ADDR num_char_read, 0<br />	invoke ExitProcess, 0<br /><br /><br /><br />;________________________________________________________________________________<br /><br /><br /><br />GetElementsFromSafearray proc	USES ESI EDI EBX ECX EDX	psa:DWORD, limit:DWORD<br />	LOCAL hres:DWORD<br />	LOCAL counter:DWORD<br />	LOCAL each_item:DWORD<br />	LOCAL counter_plus:DWORD<br />	mov DWORD PTR , 0<br />	mov counter, 0<br />	mov counter_plus, 0<br />	mov EBX, limit<br />	.while counter &lt; EBX<br />		mov ECX, counter<br />		mov EAX, counter<br />		mov DWORD PTR , EAX<br />		lea EDI, DWORD PTR <br />		lea ECX, DWORD PTR <br />		invoke SafeArrayGetElement, psa, ECX, EDI<br />			; EXTRACT VALUES AND PUT THEM IN pointer_array for EAX<br />			pusha<br />			mov EBX, counter_plus<br />			mov ECX, DWORD PTR <br />			mov DWORD PTR , ECX<br />			mov DWORD PTR , ECX	; save it in array<br />			invoke wsprintf, ADDR buffy, ADDR new_line, counter, each_item<br />			invoke WriteConsole, w_std_handle, ADDR buffy, EAX, ADDR num_char_written, 0<br />			popa<br />			; END EXTRACT VALUES AND PUT THEM IN pointer_array for EAX<br />		mov hres, EAX<br />		inc counter<br />		add counter_plus, 4<br />	.endw<br />	.if hres != 0<br />		invoke MessageBoxA, 0, ADDR get_error_msg, 0, 0<br />	.endif<br />	lea EAX, DWORD PTR <br />	ret<br />GetElementsFromSafearray endp<br /><br /><br /><br />;________________________________________________________________________________<br /><br /><br /><br />GetHandles proc<br />	invoke GetStdHandle, -11<br />	mov w_std_handle, EAX<br />	invoke GetStdHandle, -10<br />	mov r_std_handle, EAX<br />	ret<br />GetHandles endp<br /><br /><br /><br />;________________________________________________________________________________<br /><br /><br /><br />InputNumber proc		USES EBX ECX EDX<br />	LOCAL IN_NUMBER:DWORD<br />	mov IN_NUMBER, 0<br />read_loop:<br />	mov EBX, 0<br />	invoke ReadConsole, r_std_handle, ADDR bytes_to_read, 1, ADDR num_char_read, 0<br />	mov AL, bytes_to_read<br />	cmp AL, 0<br />	jne not_special<br />	jmp short exit_read<br />not_special:<br />	cmp al,&#039;0&#039;<br />	jb exit_read<br />	cmp AL, &#039;9&#039;<br />	ja exit_read<br />	sub AL, &#039;0&#039;<br />	mov BL, AL<br />	mov EAX, IN_NUMBER<br />	mov ECX, 10<br />	mul ECX<br />	mov IN_NUMBER, EAX<br />	add IN_NUMBER, EBX<br />	jmp short read_loop<br />exit_read:<br />	mov EAX, IN_NUMBER<br />	ret<br />InputNumber endp<br /><br /><br /><br />;________________________________________________________________________________<br /><br /><br /><br />OutputNumber proc	USES EBX ECX EDX		OUT_NUMBER:DWORD<br />	LOCAL counter:DWORD<br />	mov EAX, OUT_NUMBER<br />	mov EBX, 10<br />	mov counter, 0<br />display_number_loop_next_divide:<br />	mov EDX, 0<br />	div EBX<br />	push EDX<br />	inc counter<br />	cmp EAX, 0<br />	jne display_number_loop_next_divide<br />display_number_out_loop:<br />	pop EDX<br />	add DL, 48<br />	mov bytes_to_write[0], DL<br />	invoke WriteConsole, w_std_handle, ADDR bytes_to_write, 1, ADDR num_char_written, 0<br />	dec counter<br />	.IF (counter &gt; 0)<br />		jmp display_number_out_loop<br />	.ENDIF<br />	ret<br />OutputNumber endp<br /><br /><br /><br />;________________________________________________________________________________<br /><br /><br /><br />PutElementsIntoSafearray proc	USES EBX ECX EDX	psa:DWORD, limit:DWORD<br />	LOCAL hres:DWORD<br />	LOCAL counter:DWORD<br />	mov EBX, limit<br />	mov counter, 0<br />	.while counter &lt; EBX<br />		mov EDX, counter<br />		mov DWORD PTR , EDX<br />		mov EAX, DWORD PTR <br />		imul EAX, 13<br />		mov DWORD PTR , EAX<br />		lea ECX, DWORD PTR <br />		lea EDX, DWORD PTR <br />		invoke SafeArrayPutElement, psa, EDX, ECX<br />		mov hres, EAX<br />		inc counter<br />	.endw<br />	.if hres != 0<br />		invoke MessageBoxA, 0, ADDR put_error_msg, 0, 0<br />	.endif<br />	mov EAX, 0<br />	ret<br />PutElementsIntoSafearray endp<br /><br /><br /><br />;________________________________________________________________________________<br /><br /><br /><br />end start<br /><br /></code></pre></div>
    <div class="meta">Posted on 2007-12-01 08:57:19 by roaknog</div>
   </div>
  </div>
 </body>
</html>