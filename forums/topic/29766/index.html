<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Problem with Protected Mode and GDT - Will not sync DS register with date seg. - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29766" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=34">OS Development</a> &raquo; <a href="../?id=29766">Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></p>
   <div class="post" id="post-210247">
    <div class="subject"><a href="#post-210247">Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></div>
    <div class="body">Hello ASMCommunity.&nbsp; As the subject states, I am having problems with Protected Mode setup, more specifically with the &#039;after routines&#039; of the GDT.&nbsp; My main problem lies with the act of synchronizing the data segment register(s) with the data descriptor that I have, as well as the code segment via a far jump in relation to my code descriptor in the table.&nbsp; The odd thing is, that my code executes code after the LGDT instruction such as a message printing routine, and then enables protected mode.<br /><br />Here, I am stuck with none of my usual debugging options ... printing a message to the screen to see where the trouble part of the code is, Protected Mode having no Interrupts in normal operation.<br /><br />Could the problem be that I have the LGDT &#039;nested&#039; in it&#039;s own separate function which is called by the main program and then returns to it.&nbsp; I seriously question this however, as the following print function works just fine.<br /><br />Here is the GDT setup scrap of my code:<br /><pre><code>gdtset:		;function to setup and load the Global Descriptor Table<br />	xor ax, ax		;clear ax register		<br />	mov es, ax<br />	mov si, gdt		;start of GDT table into SI register<br />	mov di, 	;locate GDT at 500h in memory<br />	mov cx, 	;size of the GDT (defined my fancy footwork)<br />	push ds			;remember pre-modified DS register<br />	mov ds, ax<br /><br />	cld			;clear the direction flag<br />	rep movsb		;move byte from DS:SI to ES:DI<br /><br />	pop ds			;restore pre-modified DS register<br /><br />	lgdt		;load the Global Descriptor Table<br /><br />	lea si, 	;load the address of the GDT Setup Message into SI<br />	call prntstr		;print the string<br />ret</code></pre><br /><br /><br />Just to give a little more information on where everything is at...<br />&nbsp; &nbsp;  7C00&nbsp; -&gt;&nbsp; 7E00&nbsp; &nbsp;  :Bootsector<br />&nbsp; &nbsp;  7E00&nbsp; -&gt;&nbsp; 79FF&nbsp; &nbsp; &nbsp; :Bootloader&nbsp; &nbsp;  (this code)<br />&nbsp; &nbsp;  9200&nbsp; -&gt;&nbsp; _undetermined_&nbsp; &nbsp;  :Kernel<br /><br />&nbsp; &nbsp;  79FF&nbsp;  -&gt;&nbsp; 7BFF&nbsp; &nbsp;  :Stack&nbsp; &nbsp;  (extending down from 7BFF obviously)<br />&nbsp; &nbsp;  500&nbsp; &nbsp; -&gt;&nbsp; _undetermined_&nbsp; &nbsp;  :GDT<br /><br /><br />You probably should have access to the full source code in it&#039;s actual context, so I am providing an attachment file.<br /><br />For months now, this has baffled me.&nbsp; It is just so bizarre to me, when much of the online tutorials use almost the exact same setup.<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3049" target="_blank">bootloader.asm</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-01-18 09:58:54 by XeonX369</div>
   </div>
   <div class="post" id="post-210249">
    <div class="subject"><a href="#post-210249">Re: Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></div>
    <div class="body">I&#039;ve skimmed through and have noticed five things.<br /><br />First, and not of great importance, you are setting the &quot;accessed&quot; flag for your GDT entries (0x9B &amp; 0x93 instead of 0x9A &amp; 0x92). This is not necessary as the processor will set this flag upon use.<br /><br />Second, and of relative importance, your <strong>ORG</strong> statement doesn&#039;t seem to reflect an actual load address. <strong>jmp code:.bootkrnl</strong> is probably jumping closer to the bottom (0x0000) of memory than up near 0x7XXX. The same goes for <strong>lgdt</strong> or any other absolute address reference.<br /><br />Third, and of great importance, your stack (0x7BFF) is set to be immediately above your code. For sanity reasons, it should be moved further up or down. Moving the stack down to 0x7000 will give you enough breathing room to do what you need to do, but should fail out fairly reliably in case there is some nasty stack corruption. Also, make sure you align your stack on a DWORD boundary, e.g. 0x7C00-0x7A00 instead of 0x7BFF-0x79FF. Remember, a <strong>push</strong> will decrement and then move, and a <strong>pop</strong> will move and then increment.<br /><br />Fourth, and of greater importance, I don&#039;t see a demonstration of the the segment registers being loaded immediately after the jump to protected mode.<br /><br />Fifth, and of greatest importance, for maximum stability, there should be no calls/rets, stack usage or anything else between setting the Protected Mode (#PE) flag in CR0 and jumping to 32-bit protected mode. You should inline <strong>pmoden</strong>.<br /><br />Here is an example of the fourth and fifth points...<br /><br /><pre><code><br /><br />;... some RM init code...<br /> &nbsp;mov eax,cr0<br /> &nbsp;or al,1<br /> &nbsp;mov cr0,eax<br /> &nbsp;jmp GDT_CODE:.PROTECTED_MODE<br /><br /><br />PROTECTED_MODE:<br /> &nbsp;mov ax,GDT_DATA<br /> &nbsp;mov ds,ax<br /> &nbsp;mov es,ax<br /> &nbsp;mov fs,ax<br /> &nbsp;mov gs,ax<br /> &nbsp;mov ss,ax<br />&nbsp; mov eax,STACK_BASE<br /> &nbsp;mov esp,eax<br /> &nbsp;mov ebp,eax<br />;... some PM init code...<br />jmp KERNEL<br /></code></pre></div>
    <div class="meta">Posted on 2010-01-18 12:13:59 by SpooK</div>
   </div>
   <div class="post" id="post-210250">
    <div class="subject"><a href="#post-210250">Re: Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></div>
    <div class="body">Hello Spook and thank you for replying.&nbsp; To start off, I took your advice for the accessed flag in the GDT entries and decided to change them for minor &#039;aesthetic&#039; reasons, and I thank you for pointing that out.<br /><br />With the ORG directive, I purely didn&#039;t realize that this should be an actual address, and was told on another forum site (OSDev, I believe) that I could get away with an offset from where it was loaded into (7E00) and that it was recommended.&nbsp; I suppose that this wasn&#039;t the most wise thing, now that you give an explanation.<br /><br />The double ward alignment does make much sense with me, and I now have my stack set at 7C00 expanding downwards.&nbsp; Please let me know if this is an acceptable position as I have had issues with the stack concept in the past (mostly positioning).&nbsp; I kept my SP set to 0200h to denote a 510-byte stack.&nbsp; Is this a good size?<br /><br />I realize that I should have inserted some register &#039;refreshing&#039; code, but I was a bit over-zealous with the &#039;undo&#039; function this morning and must have scrapped this in the version that I uploaded.&nbsp; I have promptly re-inserted it.&nbsp; I load the Data Segment registers with a &#039;variable&#039; in the GDT section which is specified simply as &#039;data.&#039;&nbsp; <br /> <pre><code>pmoden:			;inline function to enable Protected Mode<br />		cli			;permanently clear interrupts<br />		mov eax, cr0		;move contents of ControlRegister0 into ExtendedAX register<br />		or al, 01h		;compare AL to value 1<br />		mov cr0, eax		;move CR0 into EAX register<br />	<br />	jmp code:.pmode		;jump to 32 bit code to straighten out EIP<br /><br />	<br />	.pmode<br />		mov ax, data		;align all data segments with the data descriptor<br />		mov ds, ax<br />		mov es, ax<br />		mov fs, ax<br />		mov gs, ax<br /><br />		mov ax, 7C00h		;align stack segment<br />		mov ss, ax<br />		mov eax, 0200h		;align base and stack pointers<br />		mov esp, eax<br />		mov ebp, eax<br /><br />		jmp code:9200h	;jump to residence of Kernel<br />		hlt		;halt processor from executing this binary</code></pre><br /><br />The frustrating thing is that this version of the code does not want to even boot.&nbsp; I can&#039;t get it to go in Qemu or Bochs, and it won&#039;t run on my PC hardware off of floppy.&nbsp; I am still stupefied at it, and wish more help.&nbsp; Am I perhaps loading the segment registers incorrectly.<br /><br />Also as an aside question, Do you recommend setting up a comprehensive segmentation layout for &#039;General Code/Data&#039; , Kernel Code/Date, Stack, Bootloader/Bootsector, and Descriptor Tables?&nbsp; Would this just be &#039;junk&#039; with the implementation of Paging, or would it be even better to do alongside Paging?<br /><br />Many, Many Thanks for your assistance.</div>
    <div class="meta">Posted on 2010-01-18 14:27:31 by XeonX369</div>
   </div>
   <div class="post" id="post-210254">
    <div class="subject"><a href="#post-210254">Re: Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></div>
    <div class="body"><div class="quote"><br />With the ORG directive, I purely didn&#039;t realize that this should be an actual address, and was told on another forum site (OSDev, I believe) that I could get away with an offset from where it was loaded into (7E00) and that it was recommended. &nbsp;I suppose that this wasn&#039;t the most wise thing, now that you give an explanation.<br /></div><br /><br />If CS and DS was 0x7E00, and the IP was 0x0000, then using <strong>ORG 0x0000</strong> should work for your loader... while in Real Mode that is. Most people enable Protected Mode as one big flat address space (one big segment) instead of using legacy segmentation techniques.<br /><br /><div class="quote"><br />The double ward alignment does make much sense with me, and I now have my stack set at 7C00 expanding downwards. &nbsp;Please let me know if this is an acceptable position as I have had issues with the stack concept in the past (mostly positioning). &nbsp;I kept my SP set to 0200h to denote a 510-byte stack. &nbsp;Is this a good size?<br /><br />I realize that I should have inserted some register &#039;refreshing&#039; code, but I was a bit over-zealous with the &#039;undo&#039; function this morning and must have scrapped this in the version that I uploaded. &nbsp;I have promptly re-inserted it. &nbsp;I load the Data Segment registers with a &#039;variable&#039; in the GDT section which is specified simply as &#039;data.&#039; &nbsp;<br /> <pre><code><br />;...<br />		mov ax, 7C00h		;align stack segment<br />		mov ss, ax<br />		mov eax, 0200h		;align base and stack pointers<br />		mov esp, eax<br />		mov ebp, eax<br /><br />		jmp code:9200h	;jump to residence of Kernel<br />		hlt		;halt processor from executing this binary</code></pre><br /></div><br /><br />In Protected Mode, <strong>SS</strong> is expecting a GDT entry index, and is usually set as one large flat segment like code and data... making <strong>ESP</strong> &amp; <strong>EBP</strong> absolute 32-bit pointers for the entire address space.<br /><br />The above code should just about hang/triple-fault on a stack operation since there is no 31744th (0x7C00) GDT entry to reference. Also, IIRC, max for GDT is ~8K entries.<br /><br />Review the code I posted in my previous reply; <strong>STACK_BASE</strong> would be 0x7C00 in your case.<br /><br /><div class="quote"><br />The frustrating thing is that this version of the code does not want to even boot. &nbsp;I can&#039;t get it to go in Qemu or Bochs, and it won&#039;t run on my PC hardware off of floppy. &nbsp;I am still stupefied at it, and wish more help. &nbsp;Am I perhaps loading the segment registers incorrectly.<br /></div><br /><br />Start putting in dummy code that &quot;hangs&quot; and cycles some video character (0x000B8000) data in a loop. Temporarily add a jump to said dummy code after each significant portion of initialization. If you see the 2 top-left cells cycling through characters/colors, it is working up to that point and you can proceed to the next probable point of failure.<br /><br />For example:<br /><br /><pre><code><br /><br />hang16:<br />mov ax,0xB800<br />mov gs,ax<br />mov bx,0<br />inc DWORD<br />jmp hang16<br /><br /><br />hang32:<br />inc DWORD[0x000B8000]<br />jmp hang32<br /></code></pre><br /><br /><div class="quote"><br />Also as an aside question, Do you recommend setting up a comprehensive segmentation layout for &#039;General Code/Data&#039; , Kernel Code/Date, Stack, Bootloader/Bootsector, and Descriptor Tables? &nbsp;Would this just be &#039;junk&#039; with the implementation of Paging, or would it be even better to do alongside Paging?<br /></div><br /><br />I usually go with system (Ring 0) and user (Ring 3) code/data entries for all segment selectors, and a TSS entry for the task register in the case of running Ring 3 code. This effectively disables segmentation and the associated overhead, in which has been mostly deprecated (FS/GS can still be used) in Long Mode anyhow.</div>
    <div class="meta">Posted on 2010-01-18 16:41:11 by SpooK</div>
   </div>
   <div class="post" id="post-210258">
    <div class="subject"><a href="#post-210258">Re: Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></div>
    <div class="body">I once again thank you for your speedy response, with many gratuitous thanks for setting up this forum as a place to discuss Assembly matters.&nbsp; I will give your recommendations a try when I have access to my proper computing environment (I am on a poor quality laptop now), which will be either latter tonight or tomorrow.<br /><br />Until then, I wish to ask:&nbsp; Why exactly is segmentation completely scrapped in 64-bit long mode.&nbsp; To me, this goes against the previous strategy of &quot;backwards compatible.&quot;&nbsp; I realize that Segmentation is quite old and almost never used in mainstream today, but I wonder how one would efficiently implement Multi-tasking.&nbsp; I suppose that the logical response is software based multi-tasking, but I once again ask for an aside form of advice.&nbsp; What is, in your opinion, the best means to setup software multitasking?<br /><br />I am most likely getting a new computer during this coming spring (new laptop for university) with 64-bit processor obviously, and am looking forward to taking my current project to the 64-bit platform.&nbsp; Does this work with the same strategy as 32-bit mode where it is best to enable it sooner than latter.&nbsp; I know that Paging is a necessity in this case, but is it easy to set up with no Interrupt routines?</div>
    <div class="meta">Posted on 2010-01-18 20:00:42 by XeonX369</div>
   </div>
   <div class="post" id="post-210261">
    <div class="subject"><a href="#post-210261">Re: Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></div>
    <div class="body"><div class="quote"><br />Until then, I wish to ask:&nbsp; Why exactly is segmentation completely scrapped in 64-bit long mode.&nbsp; To me, this goes against the previous strategy of &quot;backwards compatible.&quot;&nbsp; I realize that Segmentation is quite old and almost never used in mainstream today, but I wonder how one would efficiently implement Multi-tasking.&nbsp; I suppose that the logical response is software based multi-tasking, but I once again ask for an aside form of advice.&nbsp; What is, in your opinion, the best means to setup software multitasking?<br /></div><br /><br />Probably because segmentation was a solution for a now obsolete problem. Making segmentation less significant helps decrease processing overhead... there is less need for some heavy &quot;sanity&quot; checks.<br /><br />Hardware multitasking, dealing with LDTs, etc... have proven to be less efficient than software multitasking on the x86. Software can make smarter decisions on what needs to be preserved during a task switch, in which can make a decent impact on performance. Also, the need for more than 8K processes/threads quickly renders hardware multitasking useless.<br /><br /><div class="quote"><br />I am most likely getting a new computer during this coming spring (new laptop for university) with 64-bit processor obviously, and am looking forward to taking my current project to the 64-bit platform.&nbsp; Does this work with the same strategy as 32-bit mode where it is best to enable it sooner than latter.&nbsp; I know that Paging is a necessity in this case, but is it easy to set up with no Interrupt routines?<br /></div><br /><br />That depends on the design.<br /><br />Personally, I utilize Real Mode and the BIOS as much as possible prior to initializing Long Mode. That way, the downtime for interrupt/exception processing is minimized... and you still have good old CTRL+ALT+DEL available.<br /><br />As for the jump to Long Mode, you can actually jump to it straight from Real Mode, skipping Protected Mode altogether.<br /><br />A big advantage for developing for the x86_64 architecture is the advanced baseline. With 32-bit Protected Mode, you have the 386, 486, Pentium, etc... all adding a little bit more and more. Is there an FPU, or isn&#039;t there? Is there PCI, or ISA only? RDTSC, CPUID, single page invalidation, etc.<br /><br />With the x86_64, I am virtually guaranteed not to deal with the ISA bus, to have PCI, Local APIC, SYSCALL, MMX/SSE and all the other useful instructions added since the 80386. I can also still run 32-bit applications natively with Compatibility Mode.<br /><br />Overall, the x86_64 is a really decent design, allowing us to make a slow but safe march into mainstream 64-bit computing while making the process fun (in more than one way) for developers.</div>
    <div class="meta">Posted on 2010-01-19 01:42:15 by SpooK</div>
   </div>
   <div class="post" id="post-210270">
    <div class="subject"><a href="#post-210270">Re: Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></div>
    <div class="body">Hello again Spook,<br /> I am back at my workstation and have tried your recommendations...to no avail.&nbsp; I still get the same, what appears to be not booting.&nbsp; I tried out your debug code, inserting it just before the code to enable protected mode.&nbsp; The most strange thing happened:&nbsp; It apparently had run through it.&nbsp; Absolutely does it not work until after this point, but I found it interesting that this would be the case, when the printing messages functions just do not work.&nbsp; For a visual &#039;demonstration,&#039; I have attached a picture (labeled &quot;nonfunct_debugcode.png&quot;).<br /><br />I decided to try and &#039;reverse&#039; the additions which I had made, and another ambiguity popped up.&nbsp; With the ORG directive set to the old value of 0000h, everything works until the LGDT instruction, for reasons which you have explained.&nbsp; I just wonder why the new ORG 7E00h directive appears to be non-functioning, when the debug code runs through fine.&nbsp; I have also attached screenshots of the results using the separate directives.<br /><br />Just to double check my stack setup, am I doing things correctly?<br /><pre><code><br />	.pmode<br />		mov ax, data		;align all data segments with the data descriptor<br />		mov ds, ax<br />		mov es, ax<br />		mov fs, ax<br />		mov gs, ax<br /><br />		mov ss, ax		;align stack segment with data descriptor<br />		mov eax, 7C00h		;align base and stack pointers<br />		mov esp, eax<br />		mov ebp, eax</code></pre><br /><br />I don&#039;t know where I had been told that SS was to take the value of the &quot;highest&quot; byte that the stack would grow down from, and that (e)sp and (e)bp were to be the total &#039;size&#039; of the stack.&nbsp; My knowledge of the stack is seriously sketchy now.&nbsp; The values of the SS (7C00) and SP (0200) registers previously set in 16-bit mode had re-enforced this interpretation of these registers.&nbsp; Oh well, I find that such ambiguities make this process fun.<br /><br />I have included my most recent full source code for this, with what little changes I have made.</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3050" target="_blank">nonfunct_debugcode.png</a></li>
      <li><a href="../../attachments/?id=3052" target="_blank">nonfunct_with7E00.png</a></li>
      <li><a href="../../attachments/?id=3054" target="_blank">partfunct_with0000.png</a></li>
      <li><a href="../../attachments/?id=3056" target="_blank">bootloader.asm</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-01-19 10:05:47 by XeonX369</div>
   </div>
   <div class="post" id="post-210290">
    <div class="subject"><a href="#post-210290">Re: Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></div>
    <div class="body">I have used your debug instruction more thoroughly, with the exact instruction causing an &#039;error&#039; being<br /><pre><code>mov cr0, eax</code></pre><br />in the routine to enable Protected Mode. <br /><br />I still find it quite odd that the debug appears to be reached and yet all of the printing functions are not being reached.<br /><br />I will continue to search the internet for information and look forward to your reply.</div>
    <div class="meta">Posted on 2010-01-20 10:59:06 by XeonX369</div>
   </div>
   <div class="post" id="post-210296">
    <div class="subject"><a href="#post-210296">Re: Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></div>
    <div class="body"><div class="quote"><br />I have used your debug instruction more thoroughly, with the exact instruction causing an &#039;error&#039; being<br /><pre><code>mov cr0, eax</code></pre><br />in the routine to enable Protected Mode. <br /></div><br /><br />It could also mean that the subsequent jump to Protected Mode is failing, as well.<br /><br />Put the following code at the very beginning of your loader...<br /><br /><pre><code><br />START:<br />cli<br />mov bx,START<br />jmp $<br /></code></pre><br /><br />... run it in Bochs and check out the log file. Make sure the value of BX in the log is the same as the expected/desired load address.<br /><br /><div class="quote"><br />I still find it quite odd that the debug appears to be reached and yet all of the printing functions are not being reached.<br /></div><br /><br />It could be a problem similar to above. It could also be the fact that the direction flag is not being purposely cleared with CLD before using LODSB.<br /><br /><div class="quote"><br />I will continue to search the internet for information and look forward to your reply.<br /></div><br /><br /><a target="_blank" href="http://wiki.osdev.org/Babystep1">Bootloader Tutorial @ OSDev.org</a></div>
    <div class="meta">Posted on 2010-01-20 16:03:04 by SpooK</div>
   </div>
   <div class="post" id="post-210315">
    <div class="subject"><a href="#post-210315">Re: Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></div>
    <div class="body">Running Bochs with the &quot;check BX&quot; code, the register dump is:<br /><pre><code>00095536000i | RAX=0000000000000e00&nbsp; RBX=0000000000007e00<br />00095536000i | RCX=0000000000090002&nbsp; RDX=0000000000000000<br />00095536000i | RSP=0000000000000200&nbsp; RBP=0000000000000000<br />00095536000i | RSI=00000000000e7c9a&nbsp; RDI=000000000000ffac<br />00095536000i |&nbsp; R8=0000000000000000&nbsp;  R9=0000000000000000<br />00095536000i | R10=0000000000000000&nbsp; R11=0000000000000000<br />00095536000i | R12=0000000000000000&nbsp; R13=0000000000000000<br />00095536000i | R14=0000000000000000&nbsp; R15=0000000000000000<br />00095536000i | IOPL=0 id vip vif ac vm rf nt of df if tf sf ZF af PF cf<br />00095536000i | SEG selector&nbsp; &nbsp;  base&nbsp; &nbsp; limit G D<br />00095536000i | SEG sltr(index|ti|rpl)&nbsp; &nbsp;  base&nbsp; &nbsp; limit G D<br />00095536000i |&nbsp; CS:7e00( 0004| 0|&nbsp; 0) 0007e000 0000ffff 0 0<br />00095536000i |&nbsp; DS:0000( 0005| 0|&nbsp; 0) 00000000 0000ffff 0 0<br />00095536000i |&nbsp; SS:7c00( 0005| 0|&nbsp; 0) 0007c000 0000ffff 0 0<br />00095536000i |&nbsp; ES:7e00( 0005| 0|&nbsp; 0) 0007e000 0000ffff 0 0<br />00095536000i |&nbsp; FS:0000( 0005| 0|&nbsp; 0) 00000000 0000ffff 0 0<br />00095536000i |&nbsp; GS:0000( 0005| 0|&nbsp; 0) 00000000 0000ffff 0 0<br />00095536000i |&nbsp; MSR_FS_BASE:0000000000000000<br />00095536000i |&nbsp; MSR_GS_BASE:0000000000000000<br />00095536000i | RIP=0000000000000004 (0000000000000004)<br />00095536000i | CR0=0x60000010 CR2=0x0000000000000000<br />00095536000i | CR3=0x00000000 CR4=0x00000000</code></pre><br /><br />What I found of interest here, is that bochs says that the base of the DS register is <strong>0000</strong> and CS is <strong>0007E000</strong>.&nbsp; Am I not setting my registers as I think I am, or am I just mis-reading?<br /><br />The BX register indeed does contain the value intended.&nbsp; Does the R prefix of the registers mean that I am running Bochs in 64-bit emulation mode?&nbsp; I just started the configuration of Bochs today, so it was a bit rushed.<br /><br />Also, I feel that in order to give a better view of my current environment state,&nbsp; I should show you my bootsector, and current bootloader.&nbsp; They are as an attachment file.<br /><br />In light of my switch to a flat segment (to facilitate long mode in the future), should I change the segment registers at the beginning of the bootloader code into a flat 0000 like the ones in the bootsector?</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3058" target="_blank">bootsector.asm</a></li>
      <li><a href="../../attachments/?id=3059" target="_blank">bootloader.asm</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-01-21 14:02:03 by XeonX369</div>
   </div>
   <div class="post" id="post-210318">
    <div class="subject"><a href="#post-210318">Re: Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></div>
    <div class="body"><div class="quote"><br />What I found of interest here, is that bochs says that the base of the DS register is <strong>0000</strong> and CS is <strong>0007E000</strong>. &nbsp;Am I not setting my registers as I think I am, or am I just mis-reading?<br /></div><br /><br /><strong>jmp 7E00h:boot</strong> in your loader code answers the above. This is a 16-bit far jump, the first word sets CS and the second word sets IP.<br /><br />Note that in x86 segmentation, segments are calculated by the value of the segment register * 16. 0x7E00:0x0000 = 0x0007E000 and not 0x00007E00.<br /><br />Change it to <strong>jmp 0000:7E00h</strong> and you now have one less problem :)<br /><br />This is also duplicated in the boot code at the end as <strong>jmp 7E00h:0000h</strong>. This will need fixing as well.<br /><br />Finally, you are repeating this mistake in your bootsector <strong>readdsk</strong> function. Notice that DS is set to zero in your Bochs log, this is why no data references are working as you would expect... your data is over 400KB away from where your code thinks it is.</div>
    <div class="meta">Posted on 2010-01-21 18:04:40 by SpooK</div>
   </div>
   <div class="post" id="post-210389">
    <div class="subject"><a href="#post-210389">Re: Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></div>
    <div class="body">Thanks Spook for the information on the Real Mode addressing issues I have been having.&nbsp; I have checked up on this for of addressing and have found that the sector should be multiplied by 16 and the offset added.&nbsp; I found this to be quite easy (in hex).<br /><br />My code now runs full through until the jump to the Kernel space.&nbsp; I have decided to load the kernel into 100000h address, as a result of a recommendation from others.<br /><br />The code is:<br /> <pre><code>jmp code:100000h ;jump to residence of Kernel</code></pre><br /><br />I hope that this is correct, and falls in line with the rest of the code that I corrected.&nbsp; I have the &#039;code&#039; segment as the base (which is 0, correct?) * 16&nbsp; and then add the offset (which is the address to the loading point of the kernel).<br /><br />I really do hope that I am doing this correctly.&nbsp; Just to check and see, the kernel loading code is as so.<br /><pre><code>.rddsk<br />	mov ax, 0xFFFF		;load FFFFh into AX register (can&#039;t directly manipulate ES)<br />	mov es, ax		;set ES to contents of AX (location of memory to read to)<br />	mov bx, 0010h		;set offset to 0010h<br /><br />	mov ah, 02h		;place 02h (read function) into AH<br />	mov al, 12h		;read 18 sectors<br />	mov ch, 00h		;read from cylinder 1<br />	mov cl, 04h		;read from sector 4<br />	mov dh, 00h		;read from head 0<br />	mov dl, 	;read from drive<br /><br />	int 13h			;call int 13h to read from disk</code></pre><br /><br />I appreciate your continued help in this slight problem.&nbsp; So close ... yet so far...</div>
    <div class="meta">Posted on 2010-01-25 10:48:45 by XeonX369</div>
   </div>
   <div class="post" id="post-210390">
    <div class="subject"><a href="#post-210390">Re: Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></div>
    <div class="body">Think about 0xFFFF:0x0010, where that is, and what it means. <a target="_blank" href="http://wiki.osdev.org/Memory_Map_%28x86%29">Hint</a>.<br /><br />Analyze the maximum amount of addressable address space while using 16-bit (es:bx) addressing.</div>
    <div class="meta">Posted on 2010-01-25 11:01:03 by SpooK</div>
   </div>
   <div class="post" id="post-210391">
    <div class="subject"><a href="#post-210391">Re: Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></div>
    <div class="body">With the FFFFh:0010h:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FFFFh * 10h = FFFF0h<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FFFF0h + 10h = 100000h<br /><br />This means that it will be above the addressable limits of 16 bit address mode:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2h ^ 10h = 10000h<br /><br />But doesn&#039;t the A20 line open up a bunch of new memory?&nbsp; Why do many tutorials that I see enable A20, and then load the&nbsp; kernel before 32-bit protected mode is enabled?<br /><br />Or is it that A20 provides:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2h ^ 14h = 100000h<br /><br />If my above supposition is true, then how will I actually load the kernel if in protected mode, you cannot use interrupts?&nbsp; Should I switch to my old 9200h setup (without the errors)?&nbsp; Also, what stack size is recommended for a 32-bit kernel?<br /><br />Thanks.</div>
    <div class="meta">Posted on 2010-01-25 11:17:42 by XeonX369</div>
   </div>
   <div class="post" id="post-210394">
    <div class="subject"><a href="#post-210394">Re: Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></div>
    <div class="body"><div class="quote"><br />With the FFFFh:0010h:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FFFFh * 10h = FFFF0h<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FFFF0h + 10h = 100000h<br /><br />This means that it will be above the addressable limits of 16 bit address mode:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2h ^ 10h = 10000h<br /></div><br /><br />IIRC, 16-bit segmentation wraps on 64KB boundaries. This means that 0xFFFF:0x0010 = 0x0000F0000 and not 0x00100000.<br /><br />If you are looking for a fairly reliable way to load data beyond the 1MB mark while in 16-bit Real Mode, look into <a target="_blank" href="http://wiki.osdev.org/Unreal_Mode">Unreal Mode</a>.</div>
    <div class="meta">Posted on 2010-01-25 13:57:41 by SpooK</div>
   </div>
   <div class="post" id="post-210398">
    <div class="subject"><a href="#post-210398">Re: Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></div>
    <div class="body">And if I decided to load the kernel to 9200h, what then would I do?<br />I have tried both, with the obvious 100000h &#039;problem&#039; (&quot;unreal&quot; mode seems to be not elegant (OCD, anyone)), and 9200h does the same triple fault.<br /><br />Perhaps I ought to look at the kernel for a code error.&nbsp; I know it should be printing an information string.<br /><br />EDIT:&nbsp; The kernel is not mis-behaving and indeed should print a string.&nbsp; I have clarified in the past that it works with GRUB, but I just hate using other people&#039;s software.<br /><br />EDIT:&nbsp; The problem indeed lies with the jump instruction.&nbsp; It will not accept any values that I give it, even if the kernel is loaded into a section of memory under 64k.</div>
    <div class="meta">Posted on 2010-01-25 15:20:46 by XeonX369</div>
   </div>
   <div class="post" id="post-210463">
    <div class="subject"><a href="#post-210463">Re: Problem with Protected Mode and GDT - Will not sync DS register with date seg.</a></div>
    <div class="body">I believe that I have found a cause (or at least a partial one).&nbsp; My kernel file is over 36864 bytes in size, when it is only composed of a simple string printing routine, and a clear screen routine, as well as a &#039;pre-kernel&#039; which is the actual code jumped to.<br /><br />Here is where things get weird for me:&nbsp; assembling the &#039;pre-kernel&#039; with the aout format will yield a file size which is expected.&nbsp; Linking then gives an oddly large file size, as stated above.&nbsp; Assembling the &#039;pre-kernel&#039; in elf format will give about the same expected size; and yet when linked, the file is an expected about 3KB.&nbsp; I have my linker script setup to specify the correct entry point, and the place to be loaded to, as well as the sections of text and bss.<br /><br />Any thoughts on this?</div>
    <div class="meta">Posted on 2010-01-28 11:39:56 by XeonX369</div>
   </div>
  </div>
 </body>
</html>