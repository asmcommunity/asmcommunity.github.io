<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Device Capabalities from WPiAL - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=15894" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=15894">Device Capabalities from WPiAL</a></p>
   <div class="post" id="post-123179">
    <div class="subject"><a href="#post-123179">Device Capabalities from WPiAL</a></div>
    <div class="body">The following code is exactly as it appears in the online PDF version of Windows Programming In Assembly Language.<br /><br />When I compile it and run, I get a couple different results on Win98:<br />1.  It opens a window and displays some text.  A second or two later, my system reboots. (compiled with no options)<br />2.  I get a complete system crash.  Exception 0D at 003B: 00000404 (compiled with -w option)<br /><br />Anyone see where the problem is?<br /><br />page 355<div class="quote"><br />// GDCaps.hla:<br />//<br />// Displays the device capabilities for the video display device.<br />// Inspired by &quot;DEVCAPS1.C&quot; by Charles Petzold<br /><br />program GDCaps;<br />#include( &quot;w.hhf&quot; ) // Standard windows stuff.<br />#include( &quot;wpa.hhf&quot; ) // &quot;Windows Programming in Assembly&quot; specific stuff.<br />#include( &quot;memory.hhf&quot; ) // tstralloc is in here<br />#include( &quot;strings.hhf&quot; ) // str.put is in here<br />?@nodisplay := true; // Disable extra code generation in each procedure.<br />?@nostackalign := true; // Stacks are always aligned, no need for extra code.<br /><br />// dct_t and dcTemplate_c are used to maintain the device context data<br />// structures throughout this program. Each entry in the dcTemplate_c<br />// array specifies one of the values we'll obtain from Windows via<br />// a GetDeviceCap call. The fieldName entry should contain the name<br />// of the device capability field to get from Windows. This name must<br />// exactly match the corresponding w.GetDeviceCap index value with the<br />// exception of alphabetic case (it doesn't need to be all upper case)<br />// and you don't need the leading &quot;w.&quot; The desc entry should contain<br />// a short description of the field.<br />//<br />// This is the only place you'll need to modify this code to retrieve<br />// and display any of the GetDeviceCap values.<br /><br />type<br />dct_t :record<br />fieldName :string;<br />desc :string;<br />endrecord;<br /><br />const<br />dcTemplate_c :dct_t[] :=<br />[<br />dct_t:[ &quot;HorzSize&quot;, &quot;Width in millimeters&quot; ],<br />dct_t:[ &quot;VertSize&quot;, &quot;Height in millimeters&quot; ],<br />dct_t:[ &quot;HorzRes&quot;, &quot;Width in pixels&quot; ],<br />dct_t:[ &quot;VertRes&quot;, &quot;Height in pixels&quot; ],<br />dct_t:[ &quot;BitsPixel&quot;, &quot;Color Bits/pixel&quot; ],<br />dct_t:[ &quot;Planes&quot;, &quot;Color planes&quot; ],<br />dct_t:[ &quot;NumBrushes&quot;, &quot;Device brushes&quot; ],<br />dct_t:[ &quot;NumPens&quot;, &quot;Device pens&quot; ],<br />dct_t:[ &quot;NumFonts&quot;, &quot;Device fonts&quot; ],<br />dct_t:[ &quot;NumColors&quot;, &quot;Device colors&quot; ],<br />dct_t:[ &quot;AspectX&quot;, &quot;X Aspect value&quot; ],<br />dct_t:[ &quot;AspectY&quot;, &quot;Y Aspect value&quot; ],<br />dct_t:[ &quot;AspectXY&quot;, &quot;Diag Aspect value&quot; ],<br />dct_t:[ &quot;LogPixelsX&quot;, &quot;Display pixels (horz)&quot; ],<br />dct_t:[ &quot;LogPixelsY&quot;, &quot;Display pixels (vert)&quot; ],<br />dct_t:[ &quot;SizePalette&quot;, &quot;Size of palette&quot; ],<br />dct_t:[ &quot;NumReserved&quot;, &quot;Reserved palette entries&quot; ],<br />dct_t:[ &quot;ColorRes&quot;, &quot;Color resolution&quot; ]<br />];<br /><br />DCfields_c := @elements( dcTemplate_c );<br />// The deviceCapRecord_t and deviceCapabilities_t types are record objects<br />// that hold the values we're interested in obtaining from the<br />// w.GetDevCaps API function. The #for loop automatically constructs all<br />// the fields of the deviceCapRecord_t record from the dcTemplate_c constant<br />// above.<br /><br />type<br />deviceCapRecord_t :record<br />#for( i in dcTemplate_c )<br />@text( i.fieldName ) :int32;<br />#endfor<br />endrecord;<br /><br />deviceCapabilities_t :union<br />fields :deviceCapRecord_t;<br />elements :int32[ DCfields_c ];<br />endunion;<br /><br />static<br />hInstance: dword; // &quot;Instance Handle&quot; supplied by Windows.<br />wc: w.WNDCLASSEX; // Our &quot;window class&quot; data.<br />msg: w.MSG; // Windows messages go here.<br />hwnd: dword; // Handle to our window.<br />// Record that holds the device capabilities that this<br />// program uses:<br />appDevCaps: deviceCapabilities_t;<br /><br />readonly<br />ClassName: string := &quot;GDCapsWinClass&quot;; // Window Class Name<br />AppCaption: string := &quot;Get Device Capabilities&quot;;// Caption for Window<br />// The following data type and DATA declaration<br />// defines the message handlers for this program.<br /><br />type<br />MsgProc_t: procedure( hwnd:dword; wParam:dword; lParam:dword );<br />MsgProcPtr_t:<br />record<br />MessageValue: dword;<br />MessageHndlr: MsgProc_t;<br />endrecord;<br /><br />// The dispatch table:<br />//<br />// This table is where you add new messages and message handlers<br />// to the program. Each entry in the table must be a tMsgProcPtr<br />// record containing two entries: the message value (a constant,<br />// typically one of the wm.***** constants found in windows.hhf)<br />// and a pointer to a &quot;tMsgProc&quot; procedure that will handle the<br />// message.<br />readonly<br />Dispatch: MsgProcPtr_t; @nostorage;<br />MsgProcPtr_t<br />MsgProcPtr_t:[ w.WM_DESTROY, &amp;QuitApplication ],<br />MsgProcPtr_t:[ w.WM_CREATE, &amp;Create ],<br />MsgProcPtr_t:[ w.WM_PAINT, &amp;Paint ],<br />// Insert new message handler records here.<br />MsgProcPtr_t:[ 0, NULL ]; // This marks the end of the list.<br /><br />// Create-<br />//<br />// This function reads an application-specific set of device capabilities<br />// from Windows using the w.GetDevCaps API function. This function stores<br />// the device capabilities into the global appDevCaps record.<br />procedure Create;<br />var<br />hdc :dword;<br /><br />begin Create;<br />GetDC( hwnd, hdc );<br />// Generate a sequence of calls to GetDeviceCaps that<br />// take the form:<br />//<br />// GetDeviceCaps( w.FIELDNAMEINUPPERCASE );<br />// mov( eax, appDevCaps.FieldName );<br />//<br />// Where the field names come from the deviceCapabilities_t type.<br /><br />#for( field in dcTemplate_c )<br />GetDeviceCaps( @text( &quot;w.&quot; + @uppercase( field.fieldName, 0 )) );<br />mov( eax, @text( &quot;appDevCaps.fields.&quot; + field.fieldName ));<br />#endfor<br /><br />ReleaseDC;<br />end Create;<br /><br />// QuitApplication:<br />//<br />// This procedure handles the &quot;wm.Destroy&quot; message.<br />// It tells the application to terminate. This code sends<br />// the appropriate message to the main program's message loop<br />// that will cause the application to terminate.<br />procedure QuitApplication( hwnd: dword; wParam:dword; lParam:dword );<br />begin QuitApplication;<br />w.PostQuitMessage( 0 );<br />end QuitApplication;<br /><br />// Paint:<br />//<br />// This procedure handles the &quot;wm.Paint&quot; message.<br />// This procedure displays several lines of text with<br />// different colors.<br />procedure Paint( hwnd: dword; wParam:dword; lParam:dword ); @nodisplay;<br /><br />var<br />hdc: dword; // Handle to video display device context<br />ps: w.PAINTSTRUCT; // Used while painting text.<br />rect: w.RECT; // Used to invalidate client rectangle.<br />outStr: string;<br /><br />type<br />dclbl_t: record<br />theName :string;<br />desc :string;<br />endrecord;<br /><br />static<br />DClabels :dct_t[ DCfields_c ] := dcTemplate_c;<br /><br />begin Paint;<br />push( ebx );<br />push( edi );<br />// Allocate temporary storage for a string object<br />// (automatically goes away when we return):<br />tstralloc( 256 );<br />mov( eax, outStr );<br />// When Windows requests that we draw the window,<br />// fill in the string in the center of the screen.<br />// Note that all GDI calls (e.g., DrawText) must<br />// appear within a BeginPaint..EndPaint pair.<br /><br />BeginPaint( hwnd, ps, hdc );<br />for( mov( 0, ebx ); ebx &lt; DCfields_c; inc( ebx )) do<br />// Sneaky trick: Although the global appDevCaps is really<br />// a structure, this code treats it as an array of<br />// dwords (because that's what it turns out to be).<br />str.put<br />(<br />outStr,<br />DClabels.desc[ ebx*8 ],<br />&quot; (&quot;,<br />DClabels.fieldName[ ebx*8 ],<br />&quot;): &quot;,<br />appDevCaps.elements[ ebx*4 ]<br />);<br />intmul( 20, ebx, edx ); // Compute y-coordinate for output.<br />TextOut( 10, edx, outStr, str.length( outStr ) );<br />endfor;<br /><br />EndPaint;<br /><br />pop( edi );<br />pop( ebx );<br />end Paint;<br /><br />// The window procedure. Since this gets called directly from<br />// windows we need to explicitly reverse the parameters (compared<br />// to the standard STDCALL declaration) in order to make HLA's<br />// Pascal calling convention compatible with Windows.<br />//<br />// This is actually a function that returns a return result in<br />// EAX. If this function returns zero in EAX, then the event<br />// loop terminates program execution.<br />procedure WndProc( hwnd:dword; uMsg:uns32; wParam:dword; lParam:dword );<br />@stdcall;<br /><br />begin WndProc;<br />// uMsg contains the current message Windows is passing along to<br />// us. Scan through the &quot;Dispatch&quot; table searching for a handler<br />// for this message. If we find one, then call the associated<br />// handler procedure. If we don't have a specific handler for this<br />// message, then call the default window procedure handler function.<br />mov( uMsg, eax );<br />mov( &amp;Dispatch, edx );<br /><br />forever<br />mov( (type MsgProcPtr_t ).MessageHndlr, ecx );<br />if( ecx = 0 ) then<br />// If an unhandled message comes along,<br />// let the default window handler process the<br />// message. Whatever (non-zero) value this function<br />// returns is the return result passed on to the<br />// event loop.<br />w.DefWindowProc( hwnd, uMsg, wParam, lParam );<br />exit WndProc;<br />elseif( eax = (type MsgProcPtr_t ).MessageValue ) then<br /><br />// If the current message matches one of the values<br />// in the message dispatch table, then call the<br />// appropriate routine. Note that the routine address<br />// is still in ECX from the test above.<br />push( hwnd ); // (type tMsgProc ecx)(hwnd, wParam, lParam)<br />push( wParam ); // This calls the associated routine after<br />push( lParam ); // pushing the necessary parameters.<br />call( ecx );<br />sub( eax, eax ); // Return value for function is zero.<br />break;<br />endif;<br />add( @size( MsgProcPtr_t ), edx );<br />endfor;<br /><br />end WndProc;<br /><br />// Here's the main program for the application.<br />begin GDCaps;<br /><br />// Set up the window class (wc) object:<br />mov( @size( w.WNDCLASSEX ), wc.cbSize );<br />mov( w.CS_HREDRAW | w.CS_VREDRAW, wc.style );<br />mov( &amp;WndProc, wc.lpfnWndProc );<br />mov( NULL, wc.cbClsExtra );<br />mov( NULL, wc.cbWndExtra );<br />mov( w.COLOR_WINDOW+1, wc.hbrBackground );<br />mov( NULL, wc.lpszMenuName );<br />mov( ClassName, wc.lpszClassName );<br />// Get this process' handle:<br />w.GetModuleHandle( NULL );<br />mov( eax, hInstance );<br />mov( eax, wc.hInstance );<br />// Get the icons and cursor for this application:<br />w.LoadIcon( NULL, val w.IDI_APPLICATION );<br />mov( eax, wc.hIcon );<br />mov( eax, wc.hIconSm );<br />w.LoadCursor( NULL, val w.IDC_ARROW );<br />mov( eax, wc.hCursor );<br />// Okay, register this window with Windows so it<br />// will start passing messages our way. Once this<br />// is accomplished, create the window and display it.<br />w.RegisterClassEx( wc );<br />w.CreateWindowEx<br />(<br />NULL,<br />ClassName,<br />AppCaption,<br />w.WS_OVERLAPPEDWINDOW,<br />w.CW_USEDEFAULT,<br />w.CW_USEDEFAULT,<br />w.CW_USEDEFAULT,<br />w.CW_USEDEFAULT,<br />NULL,<br />NULL,<br />hInstance,<br />NULL<br />);<br />mov( eax, hwnd );<br />w.ShowWindow( hwnd, w.SW_SHOWNORMAL );<br />w.UpdateWindow( hwnd );<br />// Here's the event loop that processes messages<br />// sent to our window. On return from GetMessage,<br />// break if EAX contains false and then quit the<br />// program.<br />forever<br />w.GetMessage( msg, NULL, 0, 0 );<br />breakif( !eax );<br />w.TranslateMessage( msg );<br />w.DispatchMessage( msg );<br />endfor;<br />// The message handling inside Windows has stored<br />// the program's return code in the wParam field<br />// of the message. Extract this and return it<br />// as the program's return code.<br />mov( msg.wParam, eax );<br /><br />w.ExitProcess( eax );<br /><br />end GDCaps;</div></div>
    <div class="meta">Posted on 2003-11-01 22:39:19 by Kain</div>
   </div>
   <div class="post" id="post-123357">
    <div class="subject"><a href="#post-123357">Device Capabalities from WPiAL</a></div>
    <div class="body">Well, I cut and paste your code into my editor, compiled and ran it under Win XP.<br />The code was developed under Win2000, so it runs there as well.<br />My suspicion is that there is some capability request that isn't supported under 98.<br />However, it shouldn't crash.  Unfortunately, I don't have Win98 available, so I can't track this problem down.<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-11-03 14:18:07 by rhyde</div>
   </div>
   <div class="post" id="post-123362">
    <div class="subject"><a href="#post-123362">Device Capabalities from WPiAL</a></div>
    <div class="body"><div class="quote"><br />Well, I cut and paste your code into my editor, compiled and ran it under Win XP.<br />The code was developed under Win2000, so it runs there as well.<br />My suspicion is that there is some capability request that isn't supported under 98.<br />However, it shouldn't crash.  Unfortunately, I don't have Win98 available, so I can't track this problem down.<br />Cheers,<br />Randy Hyde </div><br /><br />I downloaded and compiled directly from the source file, same problem: Gives me a reboot while  displaying text to the window (though it doesn't freeze anymore).<br /><br />I will try with my Windows ME as well and see if the problem persists.</div>
    <div class="meta">Posted on 2003-11-03 16:11:52 by Kain</div>
   </div>
   <div class="post" id="post-123431">
    <div class="subject"><a href="#post-123431">Device Capabalities from WPiAL</a></div>
    <div class="body">Windows ME is also not compatible with GDcaps.exe<br /><br />Resulted in an unrecoverable out of bounds crash.</div>
    <div class="meta">Posted on 2003-11-04 16:00:10 by Kain</div>
   </div>
   <div class="post" id="post-123440">
    <div class="subject"><a href="#post-123440">Device Capabalities from WPiAL</a></div>
    <div class="body"><div class="quote"><br />Windows ME is also not compatible with GDcaps.exe<br /><br />Resulted in an unrecoverable out of bounds crash. </div><br /><br />Was that an HLA exception or a Windows code?<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-11-04 18:10:42 by rhyde</div>
   </div>
   <div class="post" id="post-123442">
    <div class="subject"><a href="#post-123442">Device Capabalities from WPiAL</a></div>
    <div class="body">Can't say for sure.  My monitor went blank and an &quot;out of bounds&quot; message began bouncing around the screen.<br /><br />This happened to me once before when I switched to a display mode not supported by my graphics card.<br /><br />It is really odd.  I can't find anything in the code that might be doing this.  I'll try to run it stepped mode on Olly debug to see if I can catch exactly where the reboot happens on the win98 version later this evening.  It's probably the same thing on the WinME.</div>
    <div class="meta">Posted on 2003-11-04 18:47:09 by Kain</div>
   </div>
   <div class="post" id="post-123456">
    <div class="subject"><a href="#post-123456">Device Capabalities from WPiAL</a></div>
    <div class="body">Okay, I traced it twice, and both times, crash occured on same instruction.<br /><br />1.  04001729  FF1534200004    CALL DWORD ptr [&lt;&amp;user32.updatewindow&gt;]<br />2.  0400172F  &gt;6A 00                 PUSH 0                                      -&gt; msgfiltermax 0<br /><br />As I trace from address 1 into address 2, system crashes.  Probably not much help but worth a try.  It has me stumped.<br /><br />The problem persists over different operating systems (win98, winME), and using different assemblers (masm32, fasm)<br /><br />My guess is that the problem is somewhere in the message handling system... when running without ollydebug, it outputs the entire window and prints all the information before crashing (eliminates possible error in updatewindow).</div>
    <div class="meta">Posted on 2003-11-04 22:17:51 by Kain</div>
   </div>
   <div class="post" id="post-123540">
    <div class="subject"><a href="#post-123540">Device Capabalities from WPiAL</a></div>
    <div class="body"><div class="quote"><br />Okay, I traced it twice, and both times, crash occured on same instruction.<br /><br />1.  04001729  FF1534200004    CALL DWORD ptr [&lt;&amp;user32.updatewindow&gt;]<br />2.  0400172F  &gt;6A 00                 PUSH 0                                      -&gt; msgfiltermax 0<br /><br />As I trace from address 1 into address 2, system crashes.  Probably not much help but worth a try.  It has me stumped.<br /><br />The problem persists over different operating systems (win98, winME), and using different assemblers (masm32, fasm)<br /><br />My guess is that the problem is somewhere in the message handling system... when running without ollydebug, it outputs the entire window and prints all the information before crashing (eliminates possible error in updatewindow). </div><br /><br />What was the value pushed onto the stack before the call to updatewindow?<br />This is the window handle and it would be interesting to see if it is valid.<br />Also, if you're running OllyDbg, check the handle value passed to updatewindow and verify that it's the handle of the GDCaps application (OllyDbg will display this information for you, off to the right of the instruction). One last check is to verify that the stack is dword-aligned prior to the call (can't imagine it wouldn't be, but just in case).<br /><br />Another thing to check is the address of the pointer to the updatewindow routine. If you double-click on the call (in OllyDbg), a dialog box pops up that displays the address of the routine's pointer variable. View this address in memory and verify that it's non-null. In the same block of memory you should see several different like-valued pointers (e.g., on my system they're addresses like 77d4bc70, 77d447f6, etc.).<br /><br />Also note that updatewindow winds up sending a message to the window procedure.<br />so you might set a breakpoint in the Paint procedure and see if you make it that far (if not, set a<br />breakpoint in the wndproc procedure and see if you get that far). Then you should be able to trace to the offending instruction.<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-11-05 13:33:36 by rhyde</div>
   </div>
  </div>
 </body>
</html>