<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Help with Input and Output - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30949" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=115">DOS &amp; BIOS</a> &raquo; <a href="../?id=30949">Help with Input and Output</a></p>
   <div class="post" id="post-216450">
    <div class="subject"><a href="#post-216450">Help with Input and Output</a></div>
    <div class="body">I&#039;m new to assembly and i am fooling around with DOS and bios interrupts. My problem is that when you accept get a character from an interrupt (Dos or Bios) then is the value given to you in ASCII or is it a string like in C. Also when I accept an integer and try to display it on the screen I get some weird looking things. I would like help with a few things<br />1. How to accept an integer from a user and display the integer <br />2. How to accept a character and display the character to the screen<br />3. How to accept individual characters and use them to build a string of characters that can be later displayed<br />4. How do I initialize an uninitialized variable in declared in <br />I am using the nasm assembler and fooling around with real mode flat and real mode segmented models. The book that i&#039;m reading are Jeff Dunteman: Step by Step Programming with DOS and Linux, and Michael Abrash&#039;s Blackbook of Graphics programming. I already read the entire content of Dunteman&#039;s book but am now trying to apply them and I want to learn how to assembly code in order to be able to tackle Michael&#039;s Book.<br /><br />This is what i got so far, it is supposed to read in a character and display it to the screen.<br />But when it displays it I see some weird symbols and not the character I typed.<br /><br /><br /><br /><br />mov dx,welcome<br />call Write<br />mov dx,CRLF<br />call Write<br />call Input<br />sub ah,ah<br />mov dx,ax<br />call Write<br /><br />mov ax,04C00h<br />int 21h<br /><br />Write:<br />mov ah,09<br />int 21h<br />ret<br /><br />Input:<br />mov ah,07<br />int 10h<br />ret<br /><br /><br />welcome db &quot;Please enter an integer: &quot;,0Dh,OAh,&quot;$&quot;<br />CRLF db 0Dh,0Ah,&quot;$&quot;<br /><br />num1 resb 1</div>
    <div class="meta">Posted on 2013-01-28 19:11:51 by Snake4eva</div>
   </div>
   <div class="post" id="post-216451">
    <div class="subject"><a href="#post-216451">Re: Help with Input and Output</a></div>
    <div class="body">Hi Snake4eva,<br /><br />My sincere apologies. I wrote up an extensive reply yesterday, but the Forum dropped it in the bit-bucket. I think I exceeded my login time. In any case, I&#039;ve been too demoralized to repeat it. Wasn&#039;t very good, but it was long. Sorry. But you&#039;ve edited your post, and that gives me something to work with...<br /><br /><pre><code><br /><br /><br /><br /><br />mov dx,welcome<br />call Write<br />mov dx,CRLF<br />call Write<br />; so far, so good<br />; but what&#039;s this supposed to do?<br />call Input<br />sub ah,ah<br />; dx needs to point to a $-terminated string<br />; this wouldn&#039;t point to a $-terminated string<br />; regardless of your input subroutine<br />mov dx,ax<br />call Write<br /><br />mov ax,04C00h<br />int 21h<br /><br />Write:<br />mov ah,09<br />int 21h<br />ret<br /><br />Input:<br />mov ah,07 ; say what?<br />int 10h<br />ret<br /><br /><br />welcome db &quot;Please enter an integer: ,0Dh,OAh,&quot;$&quot;<br />CRLF db 0Dh,0Ah,&quot;$&quot;<br /><br />num1 resb 1<br /></code></pre><br />It&#039;s been a while since I ran dos, but the BIOS interrupt int 10h/7 scrolls the screen, last I knew. Did you mean int 21h/7? That would get you a character.<br /><br />In any case, to get to your question 1.) We really can&#039;t &quot;get an integer&quot; from the keyboard - we get ascii codes. The ascii codes for characters representing decimal digits are &#039;0&#039; or 30h or 48 greater than the number they represent. Simple for a single digit - more complicated for multi-digit numbers. Lemme try a slight re-work of your code...<br /><pre><code><br /><br /><br /><br /><br />mov dx,welcome<br />call Write<br />mov dx,CRLF<br />call Write<br />call Input<br />; here we initialize that uninitialized variable<br />mov , al<br />; and $-terminate it<br />mov byte , &#039;$&#039;<br />mov dx, num1 ; address of our $-terminated string<br />call Write<br /><br />mov ax,04C00h<br />int 21h<br /><br />Write:<br />mov ah,09<br />int 21h<br />ret<br /><br />Input:<br />mov ah,07<br />int 21h<br />ret<br /><br /><br />welcome db &quot;Please enter an integer: ,0Dh,OAh,&quot;$&quot;<br />CRLF db 0Dh,0Ah,&quot;$&quot;<br /><br />num1 resb 2 ; note space for the &#039;$&#039;!<br /></code></pre><br />That&#039;s untested, but &quot;ought&quot; to be pretty close. At this point, we aren&#039;t dealing with a &quot;number&quot; (integer), but merely repeating the character that was entered. To make it a number...<br /><pre><code><br />;...<br />call input<br />sub al, &#039;0&#039;<br />mov , al<br />mov byte , &#039;$&#039;<br />;...<br /></code></pre><br />At this point, we&#039;re not ready to print the number... try it with &#039;7&#039;, that should produce the number 7, which is the ascii code for the &quot;beep&quot; (called &quot;BEL&quot;). You won&#039;t see anything, but should hear it! To convert it back to a character we can print...<br /><pre><code><br />;...<br />add byte , &#039;0&#039;<br />mov dx, num1<br />call Write<br />;...<br /></code></pre><br />We haven&#039;t accomplished much - just converted a character to the number and then back into a character. It&#039;s a start. You can do some &quot;arithmetic&quot; on the number, if you want. Obviously, if the result is greater than 9, it&#039;s going to take more than one character to represent it. You should be able to come up with an example of that - it&#039;s about the most frequently asked question of all time! We can come up with something if you need help (not right now... sorry).<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2013-01-30 09:47:08 by fbkotler</div>
   </div>
   <div class="post" id="post-216452">
    <div class="subject"><a href="#post-216452">Re: Help with Input and Output</a></div>
    <div class="body">Thank you fbkotler for answering my question I&#039;ve moved on quite a bit since I last edited this post. I have learn how to use mov ah,0 int 10h and mov ah,09 int 10h to read and display character which brings me to another question. If only ascii values can be obtained from the keyboard input then how do you construct a multi-digit number from individual ascii digits? This question is very important because I would like to start doing some basic arithmetic with assembly. Also can you explain <br />sub al, &#039;0&#039;<br />mov , al<br />mov byte , &#039;$&#039;<br /><br />what is the purpose of the sub al,&#039;0&#039; and how does it help to convert the ascii code back into a digit. Please give me the complicated technical explanation even if it involves boolean algebra on the bits.&nbsp;  </div>
    <div class="meta">Posted on 2013-01-30 19:09:39 by Snake4eva</div>
   </div>
   <div class="post" id="post-216454">
    <div class="subject"><a href="#post-216454">Re: Help with Input and Output</a></div>
    <div class="body">Well... we can discuss where the bits are, but there&#039;s really no mystery to it: the ascii codes for the characters representing the decimal digits 0 thru 9 are 30h thru 39h. You could do it this way, if you wanna bash bits...<br /><pre><code><br />; character in al from keyboard (or ???)<br />; convert from character to number<br />and al, 0FFh ; strip off the 3 from 3?h<br />;....<br />; do something with it, if you want<br />; but still a single decimal digit, please<br />; convert number to character<br />or al, 30h ; add (or &quot;or&quot;) the 30h back on<br />; print it<br />; ...<br /></code></pre><br />But add/sub &#039;0&#039; is clearer to read, IMO.<br /><br />You asked a similar question about a year ago...<br />http://www.asmcommunity.net/board/index.php?topic=30843.msg215714#msg215714<br />Maybe you didn&#039;t &quot;get&quot; the way we tried to explain it. We can try again...<br /><br />First get some text from the victim (&quot;user&quot;, I mean) - say &quot;1234&quot;. You can get this with int 21h/0Ah, or with &quot;file-read&quot; on stdin, or you can get it byte-by-byte yourself. If you use dos interrupts, there&#039;s a good chance your &quot;string&quot; (C defines &quot;string&quot; as zero-terminated, so not a &quot;string&quot; in the C sense) is terminated with a carriage return (ascii 0Dh or 13). In addition, we know how many characters were entered (probably includes the CR).<br /><br />Zero out a register to use as &quot;result so far&quot;. Get a character. Make sure it&#039;s valid. Subtract &#039;0&#039; to convert to a number. Multiply the &quot;result so far&quot; by ten. Add the new number to &quot;result so far&quot;. Repeat until done.<br /><br />You could arrange to start at the end of the string - at the &quot;one&#039;s place&quot; - and multiply each digit by increasing powers of ten, or figure out what power of ten to multiply by from the length of the string... but I think it&#039;s easier to just multiply a &quot;result so far&quot;...<br /><pre><code><br />mov si, buffer ; buffer + 2 for int 21h/0Ah<br />; call this if you like<br />atoi: ; to reuse a name...<br />mov di, 10 ; multiply by ten<br />xor ax, ax ; &quot;result so far&quot;<br />.top:<br />xor bx, bx ; or use movzx<br />mov bl, <br />inc si<br />cmp bl, 13 ; CR - must be done<br />jz .done<br />cmp bl, 0 ; zero-terminated?<br />jz .done<br />cmp bl, &#039;0&#039;<br />jb .done ; or &quot;.invalid&quot; if you care<br />cmp bl, &#039;9&#039;<br />ja .done<br />sub bl, &#039;0&#039;<br />; note that now the full bx is our number<br />mul di ; multiply &quot;result so far&quot; by ten<br />; jc .overflow?<br />add ax, bx<br />; jc .overflow<br />jmp .top<br />.done:<br />; number is in ax<br />; ret?<br /></code></pre><br />That could be improved, no doubt, if it&#039;s even right, but should get you an integer to play with.<br /><br />To print a number, you want to divide it repeatedly by ten and keep the remainders. We get &#039;em in the &quot;wrong order&quot; to print &#039;em right away. I like to push &#039;em on the stack, but if you don&#039;t like excessive pushing and popping, you can start at the &quot;end&quot; of the buffer and store &#039;em right to left. Either pad the left end with spaces (looks nice for numbers printed in a column), or keep track of how far left you got and start your print position there. Or just put &#039;em in the buffer in the &quot;wrong&quot; order and do a &quot;string reverse&quot; at the end.<br /><br />Here&#039;s an &quot;easy&quot; way...<br /><pre><code><br />; prints the value of ax as decimal, hex, and binary ascii<br />; nasm -f bin -o showax.com showax.asm<br /><br />org 100h<br /><br />section .text<br />&nbsp; &nbsp; mov ax, 12345<br /><br />&nbsp; &nbsp; call ax2dec<br />&nbsp; &nbsp; call newline<br />&nbsp; &nbsp; call ax2hex<br />&nbsp; &nbsp; call newline<br />&nbsp; &nbsp; call ax2bin<br /><br />&nbsp; &nbsp; mov ah, 4Ch<br />&nbsp; &nbsp; int 21h<br />;--------------<br /><br />;--------------<br />ax2dec:<br />&nbsp; &nbsp; push ax<br />&nbsp; &nbsp; push bx<br />&nbsp; &nbsp; push cx<br />&nbsp; &nbsp; push dx<br /><br />&nbsp; &nbsp; mov bx, 10&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; divide by ten<br />&nbsp; &nbsp; xor cx, cx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; zero our counter<br />.push_digit:<br />&nbsp; &nbsp; xor dx, dx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; clear dx for the div<br />&nbsp; &nbsp; div bx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; dx:ax/bx -&gt; ax quotient, dx remainder<br />&nbsp; &nbsp; push dx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; save remainder<br />&nbsp; &nbsp; inc cx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; bump digit counter<br />&nbsp; &nbsp; or ax, ax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; is quotient zero?<br />&nbsp; &nbsp; jnz .push_digit&nbsp; &nbsp;  ; no, do more<br /><br />&nbsp; &nbsp; mov ah, 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; print character subfunction<br />.pop_digit:<br />&nbsp; &nbsp; pop dx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; get remainder back<br />&nbsp; &nbsp; add dl, &#039;0&#039;&nbsp; &nbsp; &nbsp; &nbsp;  ; convert to ascii character<br />&nbsp; &nbsp; int 21h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; print it<br />&nbsp; &nbsp; loop .pop_digit&nbsp; &nbsp;  ; cx times<br /><br />&nbsp; &nbsp; pop dx<br />&nbsp; &nbsp; pop cx<br />&nbsp; &nbsp; pop bx<br />&nbsp; &nbsp; pop ax<br />&nbsp; &nbsp; ret<br />;-------------------<br /><br />;-------------------<br />ax2hex:<br />&nbsp; &nbsp; push cx<br />&nbsp; &nbsp; push dx<br /><br />&nbsp; &nbsp; mov cx, 4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; four digits to show<br /><br />.top<br />&nbsp; &nbsp; rol ax, 4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; rotate one digit into position<br />&nbsp; &nbsp; mov dl, al&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; make a copy to process<br />&nbsp; &nbsp; and dl, 0Fh&nbsp; &nbsp; &nbsp; &nbsp;  ; mask off a single (hex) digit<br />&nbsp; &nbsp; cmp dl, 9&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; is it in the &#039;A&#039; to &#039;F&#039; range?<br />&nbsp; &nbsp; jbe .dec_dig&nbsp; &nbsp; &nbsp; &nbsp; ; no, skip it<br />&nbsp; &nbsp; add dl, 7&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; adjust<br />.dec_dig:<br />&nbsp; &nbsp; add dl, 30h&nbsp; &nbsp; &nbsp; &nbsp;  ; convert to character<br /><br />&nbsp; &nbsp; push ax<br />&nbsp; &nbsp; mov ah, 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; print the character<br />&nbsp; &nbsp; int 21h<br />&nbsp; &nbsp; pop ax<br /><br />&nbsp; &nbsp; loop .top<br /><br />&nbsp; &nbsp; pop dx<br />&nbsp; &nbsp; pop cx<br />&nbsp; &nbsp; ret<br />;--------------------------<br /><br />;--------------------------<br />ax2bin:<br />&nbsp; &nbsp; push cx<br />&nbsp; &nbsp; push dx<br />&nbsp; &nbsp; mov cx, 16<br />.top<br />&nbsp; &nbsp; rcl ax, 1&nbsp; &nbsp;  ; rotate and set/clear carry<br />&nbsp; &nbsp; mov dl, &#039;0&#039;<br />&nbsp; &nbsp; adc dl, 0&nbsp; &nbsp;  ; make it &#039;1&#039; if carry set<br /><br />&nbsp; &nbsp; push ax<br />&nbsp; &nbsp; mov ah, 2&nbsp; &nbsp;  ; print it<br />&nbsp; &nbsp; int 21h<br />&nbsp; &nbsp; pop ax<br /><br />&nbsp; &nbsp; loop .top<br /><br />&nbsp; &nbsp; pop dx<br />&nbsp; &nbsp; pop cx<br />&nbsp; &nbsp; ret<br />;----------------------------<br /><br />;----------------------------<br />newline:<br />&nbsp; &nbsp; push ax<br />&nbsp; &nbsp; push dx<br /><br />&nbsp; &nbsp; mov ah, 2&nbsp; &nbsp; &nbsp;  ; print character in dl<br />&nbsp; &nbsp; mov dl, 13&nbsp; &nbsp; &nbsp; ; carriage return<br />&nbsp; &nbsp; int 21h<br />&nbsp; &nbsp; mov dl, 10&nbsp; &nbsp; &nbsp; ; and linefeed<br />&nbsp; &nbsp; int 21h<br /><br />&nbsp; &nbsp; pop dx<br />&nbsp; &nbsp; pop ax<br />&nbsp; &nbsp; ret<br />;----------------------------<br /></code></pre><br />That&#039;s pretty simple-minded (but at least it&#039;s tested - used to work!), but it&#039;ll print a number. You can save the characters to a string and print &#039;em all at once. Don&#039;t forget to terminate your string with a &#039;$&#039; or a zero... or keep track of the length - whichever your print routine expects. Don&#039;t forget to leave room in your buffer for the terminator... and maybe a minus sign, if you get to that...<br /><br />Best,<br />Frank<br /><br /><br /></div>
    <div class="meta">Posted on 2013-01-30 22:46:56 by fbkotler</div>
   </div>
   <div class="post" id="post-216456">
    <div class="subject"><a href="#post-216456">Re: Help with Input and Output</a></div>
    <div class="body"> I am learning assembly in a systematic way in order to do some VGA programming. I am familiar with high level languages C and C++ but really enjoy more low level stuff. This is the format that I plan to progress my assembly language practice<br />1. Input/Output<br />2. Storage/Variable(declaration, type creation, initialization etc)<br />3. File access<br />4. Communicating with Hardware (printer, floppy disk, hard drive)<br />5. High level concepts (Arrays, heap, link list, class etc)<br />6. Advanced Mathematics and algorithm implementation<br /><br />I am currently learning I/O and Storage through Dos and Bios services int 21h and int 10h and with your posts i am becoming more comfortable with variables but I think i may need considerable help with 3,4 and 6. So please look forward for a lot more questions from me as I progress through the list.<br /><br />Also for the I got the sub al, &#039;0&#039; bitwise operation to convert to number<br />Eg:<br />al = 31h<br />sub al,&#039;0&#039;<br />Gives<br /> 00110001<br />-00110000<br />=00000001<br /><br />But I don&#039;t get the<br />and al,0ffh<br />Suppose al = 30h<br />When I do the bitwise and i don&#039;t see how the three is stripped off<br />11111111<br />00110000<br />= 00110000 which is the original Ascii character 30h am I doing something wrong?</div>
    <div class="meta">Posted on 2013-01-31 09:52:26 by Snake4eva</div>
   </div>
   <div class="post" id="post-216459">
    <div class="subject"><a href="#post-216459">Re: Help with Input and Output</a></div>
    <div class="body">Nope, you&#039;re not doing anything wrong, I am:<br /><pre><code><br />and al, 0FFh ; strip off the 3 from 3?h<br /></code></pre><br />meant:<br /><pre><code><br />and al, 0Fh ; strip off the 3 from 3?h<br /></code></pre><br />Sorry &#039;bout that!<br /><br />VGA programming, eh? Well I guess it&#039;s good if someone preserves the ancient wisdom. :)<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2013-01-31 14:34:52 by fbkotler</div>
   </div>
   <div class="post" id="post-216461">
    <div class="subject"><a href="#post-216461">Re: Help with Input and Output</a></div>
    <div class="body">That&#039;s my job :)</div>
    <div class="meta">Posted on 2013-01-31 16:45:31 by Scali</div>
   </div>
   <div class="post" id="post-216462">
    <div class="subject"><a href="#post-216462">Re: Help with Input and Output</a></div>
    <div class="body">What do you mean ancient wisdom? I know that there are newer graphics standards after VGA but isn&#039;t it the basis for all the new analogue video standards. I know DVI uses a different standard. </div>
    <div class="meta">Posted on 2013-01-31 16:49:07 by Snake4eva</div>
   </div>
   <div class="post" id="post-216463">
    <div class="subject"><a href="#post-216463">Re: Help with Input and Output</a></div>
    <div class="body"><div class="quote"><br />What do you mean ancient wisdom? I know that there are newer graphics standards after VGA but isn&#039;t it the basis for all the new analogue video standards. I know DVI uses a different standard.<br /></div><br /><br />DVI is merely a connection between videocard and display device. VGA is a display adapter, whose 15-pin analog connector has become known as &#039;VGA&#039; as well, but other than that, DVI and VGA have little to do with eachother.<br /><br />You mentioned VGA programming, which would mean programming the display adapter. Which is indeed ancient technology, and completely irrelevant in today&#039;s world.<br />VGA is not exactly the &#039;basis&#039; for newer standards. It is an ancient standard, with a weird ALU on board, and a planar oriented display memory, with a palettized RAMDAC.<br />These days we either use truecolour linear framebuffers or we use hardware-accelerated drawing, based on triangles.<br /><br />That&#039;s why VGA is &#039;ancient wisdom&#039;. It&#039;s cool to play around with VGA and all... but it&#039;s completely meaningless in today&#039;s world.</div>
    <div class="meta">Posted on 2013-02-07 09:47:35 by Scali</div>
   </div>
   <div class="post" id="post-216464">
    <div class="subject"><a href="#post-216464">Re: Help with Input and Output</a></div>
    <div class="body">I am an electronics student and for my final year project I would like to build a simple GPU that addresses some of the problems involved with 3D animations. My approach is to avoid the transistor and conquer method used in most modern GPU&#039;s. I was initially considering building it to work with the VGA standard but in light of your revelation it seems that I need to reconsider my design model. Can you please explain the operation of DVI and how it differs from analogue VGA standards. What&#039;s confusing me is that colours are continuous analogue signals so I wonder how DVI display monitors work in the digital domain if they are representing analogue information. </div>
    <div class="meta">Posted on 2013-02-11 10:00:09 by Snake4eva</div>
   </div>
   <div class="post" id="post-216469">
    <div class="subject"><a href="#post-216469">Re: Help with Input and Output</a></div>
    <div class="body">In the world of computers, nothing is analog.<br />In fact, before VGA, monitors used a TTL connection, with separate R, G, B signals, and intensity. With CGA, you had a global intensity, so you basically just had R, G, B and I, totalling 2^4 possibilities: 16 colours.<br />EGA introduced separate intensities for R, G and B, so you had 2^6 possibilities: 64 colours.<br /><br />Since VGA had a total palette of 2^18 colours (6 bits for R, G and B each), it would have required a lot of complex wiring if they would stick with TTL. So instead, they moved to analog RGB signals, where the RAMDAC would just translate each 6-bit value to analog voltages. This way the intensity was implicit in the R, G, B signals, and only 3 wires were required.<br />These analog signals could be used to drive the CRT circuitry.<br /><br />But once LCD screens arrived, the signals had to be processed in digital form anyway, so analog VGA signals were run through an ADC again inside the monitor, to get an internal framebuffer, which would then feed the pixels continuously (most LCD monitors only have 18 to 20-bit colour precision anyway, and they often use a form of dithering to simulate the full 24-bit that most videocards output... some can even do 30-bit (10:10:10)).<br /><br />Since digital technology had progressed a lot anyway, it became feasible to just have a high-speed digital link between the videocard and the screen directly. So the RAMDAC on the videocard could be skipped, as well as the ADC inside the monitor. The framebuffer is just transferred digitally.<br /><br />None of this really matters if you want to build a GPU though. You can just use standard components for VGA and/or DVI signals. The important part of a GPU is how you fill that framebuffer.</div>
    <div class="meta">Posted on 2013-02-12 06:09:45 by Scali</div>
   </div>
  </div>
 </body>
</html>