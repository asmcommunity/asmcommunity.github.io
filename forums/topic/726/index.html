<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>segment...group... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=726" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=726">segment...group...</a></p>
   <div class="post" id="post-4347">
    <div class="subject"><a href="#post-4347">segment...group...</a></div>
    <div class="body">I am porting some .asm code from its old assembler MASM 5.0 to the newest MASM 6.15....as usual, I ran into problems:<br /><br />the following error is generated:<br /><br />1)<br />EXTERN macro name,xxx<br /><br />returns error saying syntax error: macro<br />this error goes away when I make change to EXTERN, just use anything<br />other than it (e.g. EXTERN_) it will work...is EXTERN some kind of<br />preservered keyword or something??<br /><br />2) LINK time error:<br /> Assembling: io.asm<br />c.ah(351) : error A2214: GROUP directive not allowed with /coff option<br />NMAKE : fatal error U1077: 'C:\PROGRA~1\MICROS~2\VC98\BIN\ml.exe' :<br />return code<br />'0x1'<br />Stop.<br /><br />I must compile it using /coff because even if I don't, when it links, it<br />tries to convert it to /coff anyway, which will return a related<br />error....<br /><br />I am pretty new to MASM (actually I was porting a whole lot of win16 C<br />codes then all of a sudden this .asm file appear out of nowhere...)...so<br />please help!!!<br /><br />The 2nd problem is what's really bugging me right now....so please help!!!</div>
    <div class="meta">Posted on 2001-08-21 15:36:08 by mathfeel</div>
   </div>
   <div class="post" id="post-4364">
    <div class="subject"><a href="#post-4364">segment...group...</a></div>
    <div class="body">With a few variations,<br /><br />drv:\path\ml /c /coff yourfile.asm<br /><br />is the correct syntax for 32 bit MASM files with ML.EXE.<br /><br />drv:\path\Link /SUBSYSTEM:WINDOWS yourfile.obj your resourcefile.obj<br /><br />The second obj module can be a RES file instead of an obj file converted by CVTRES.EXE.<br /><br />Porting 16 bit C to 32 bit MASM is not going to be any real joy, you have both different OS architecture and a format of ASM file produced by VC that does not build directly in MASM.<br /><br />If you have MASM32, have a look at the library format to see how it works, 32 bit assembler does not use SEGMENT definitions, just .model FLAT STDCALL.<br /><br />Regards,<br /><br /><a href="mailto:hutch@pbq.com.au">hutch@pbq.com.au</a></div>
    <div class="meta">Posted on 2001-08-21 20:08:37 by hutch--</div>
   </div>
   <div class="post" id="post-4368">
    <div class="subject"><a href="#post-4368">segment...group...</a></div>
    <div class="body">The default calling convention for 32-bit C/C++ is CDECL, where the <strong>caller</strong> cleans up the stack. The .h files use the C macro WINAPI to force STDCALL calling convention for API functions. Callbacks use the C macro CALLBACK to force STDCALL convention.<br /><br />EXTERN is the new name of EXTRN.<br /><br />GROUP is unnecessary in Win32.<br /><br />If the asm file has instructions containing address registers, you will need to rewrite the MASM code.<pre><code>    ; address registers are in &#91;&#93;<br />    mov cx,&#91;di&#93;<br />    mov ax,&#91;bx+si&#93;<br />    add ax,&#91;bx&#93;</code></pre>Eliminate all loads and stores of segment registers.<br /><br />Since the file is called IO.ASM, you <strong>might</strong> be able to use IN and OUT under Win 9x/ME. Depends on the ports used. You will need a driver to use ports under Win NT/2k/XP. If the file uses INT to do I/O, you will need to rewrite the MASM code.</div>
    <div class="meta">Posted on 2001-08-21 21:05:56 by tank</div>
   </div>
   <div class="post" id="post-4371">
    <div class="subject"><a href="#post-4371">segment...group...</a></div>
    <div class="body">hutch, porting (properly written) 16-bit C to win32asm will be easier<br />than porting 16bit applications to win32, simply because there haven't<br />been extremely major changes to the underlying API. Too bad that<br />there is long between &quot;properly&quot; written C applications :).<br /><br />Anyway, if you're porting 16 bit C -&gt; win32asm, do NOT start by<br />producing a 16bit asm file, and try to translate that to win32asm.<br />It will be a very very very tedious task. You will be dealing with<br />understanding compiler optimzations, *and* hand-translating<br />long sequences of 16bit code to 32bit. Better attack it in smaller<br />bits... look at a C function, figure out what it does, write the same<br />(from scratch) in 32bit asm. Sorry, but it's the only proper way to do<br />it. Which should also stop you from doing it unless there is a darned<br />good reason :).</div>
    <div class="meta">Posted on 2001-08-21 22:00:04 by f0dder</div>
   </div>
   <div class="post" id="post-4404">
    <div class="subject"><a href="#post-4404">segment...group...</a></div>
    <div class="body">mathfeel,<br /><br />search the GROUP statements in you file and at let's have a look at them. Maybe it is a implicite GROUP statement like DOSSEG, so look for this string too.<br /><br />japheth</div>
    <div class="meta">Posted on 2001-08-22 03:04:53 by japheth</div>
   </div>
   <div class="post" id="post-4488">
    <div class="subject"><a href="#post-4488">segment...group...</a></div>
    <div class="body">well...I am not exactly porting 16-bit C to 32-bit asm...<br />I have source code for a certain program that has both 16-bit C and 16-bit asm...I am just trying to make it work (C and asm under a 32-bit compiler/assember)....<br /><br />I think I understand that GROUP is unnecessary in win32, but the problem is I can't just remove the group statement (tried to comment it out...all hell break lose)...if it helps, I am posting the code here.  The GROUP statement are at toward the end of the CODE...but the GROUP that it defined, DGROUP, is referred many places inside the code...SO, TELL ME, HOW CAN I REMOVE ALL THE GROUP STATEMENTS SO THAT IT ASSEMBLES!  I don't know how to mess with it because I am not very familiar with MASM (GOD, AFTER THIS I AM GOING TO WORK ON THAT!!):<br /><br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />C.AH starts here:<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />;	macros and defines for C86PLUS assembly language code<br />;	Copyright (C) 1986 Computer Innovations, Inc, ALL RIGHTS RESERVED<br /><br />TRUE	equ	1<br />FALSE	equ	0<br /><br />;       ifndef  BOOT_STRAP<br />BOOT_STRAP equ	FALSE<br />;       endif<br /><br />;	decode the cpu type information<br />;	format is:	CPU_[0123][7]<br /><br /> <br />SET_CPU	macro	cpu,ndp,setcpu,setndp<br />	ifdef	CPU_&amp;cpu&amp;ndp<br />		CPU_TYPE =	cpu<br />		ifidn	&lt;ndp&gt;,&lt;7&gt;<br />			NDP_TYPE =	cpu<br />		else<br />			NDP_TYPE =	0<br />		endif<br />		setcpu<br />		setndp<br />	endif<br />endm<br /><br />SET_CPU	0,7,.8086,.8087<br />SET_CPU	1,7,.186,.8087<br />SET_CPU	2,7,.286c,.287<br />SET_CPU	3,7,.286c,.287<br />SET_CPU	0,&lt; &gt;,.8086,.8087<br />SET_CPU	1,&lt; &gt;,.186,.8087<br />SET_CPU	2,&lt; &gt;,.286c,.287<br />SET_CPU	3,&lt; &gt;,.286c,.287<br /><br /><br />;	decode the memory model information<br /><br />ifdef SMALL_<br />	FAR_DATA	EQU FALSE<br />	FAR_CODE	EQU FALSE<br />endif<br /><br />ifdef MEDIUM_<br />	FAR_DATA	EQU FALSE<br />	FAR_CODE	EQU TRUE<br />endif<br />	<br />ifdef LARGE_<br />	FAR_DATA	EQU TRUE<br />	FAR_CODE	EQU TRUE<br />endif<br /><br />;	set the defaults if needed<br /><br />ifndef FAR_CODE<br />	FAR_CODE equ	FALSE<br />endif<br /> <br />ifndef 	FAR_DATA<br />	FAR_DATA equ	FALSE<br />endif<br /><br />ifndef SET_SSDS<br />	SET_SSDS equ	TRUE<br />endif<br /> <br />ifndef SET_DS<br />	SET_DS	 equ	FALSE<br />endif<br /><br />ifndef USCORE<br />	UNDERSCORE	equ	FALSE<br />else <br />	UNDERSCORE equ TRUE<br />endif<br /><br />;EXTERN	macro	name,	xxx<br />EXTRN_ macro name,xxx<br />	ifidn	&lt;xxx&gt;,&lt;cp&gt;<br />		if	FAR_CODE eq TRUE<br />			if UNDERSCORE eq TRUE<br />				extrn	_&amp;name:far<br />			else<br />				extrn	name:far<br />			endif<br />		else<br />			if UNDERSCORE eq TRUE<br />				extrn	_&amp;name:near<br />			else<br />				extrn	name:near<br />			endif<br />		endif<br />	else<br />		ifidn	&lt;xxx&gt;,&lt;dp&gt;<br />			if	FAR_DATA eq TRUE<br />				if UNDERSCORE eq TRUE<br />					extrn	_&amp;name:dword<br />				else<br />					extrn	name:dword<br />				endif<br />			else<br />				if UNDERSCORE eq TRUE<br />					extrn	_&amp;name:word<br />				else<br />					extrn	name:word<br />				endif<br />			endif<br />		else<br />			if UNDERSCORE eq TRUE<br />				extrn	_&amp;name:xxx<br />			else<br />				extrn	name:xxx<br />			endif<br />		endif<br />	endif<br />endm<br /><br />GOSUB	macro	name<br />	if UNDERSCORE EQ TRUE<br />		if FAR_CODE EQ TRUE<br />			call	far ptr _&amp;name<br />		else<br />			call 	near ptr _&amp;name<br />		endif<br />	else<br />		if FAR_CODE EQ TRUE<br />			call	far ptr name<br />		else<br />			call 	near ptr name<br />		endif<br />	endif<br />endm<br /><br /><br />FUN_PROC macro	name<br />	if UNDERSCORE EQ TRUE<br />		public	_&amp;name<br />	else <br />		public 	name<br />	endif<br />	if	FAR_CODE eq TRUE<br />		if UNDERSCORE EQ TRUE<br />			_&amp;name	PROC	far<br />		else<br />			name	PROC	far<br />		endif<br />		ARG_BASE =	6<br />		ARG_OFF	 =	6<br />		AUTO_OFF =	0<br />	else<br />		if UNDERSCORE EQ TRUE<br />			_&amp;name	PROC	near<br />		else<br />			name	PROC	near<br />		endif<br />		ARG_BASE =	4<br />		ARG_OFF	 =	4<br />		AUTO_OFF =	0<br />	endif<br />endm<br /><br />FUN_BEG	macro	name,locals,regs<br />	if UNDERSCORE EQ TRUE<br />		_TEXT	segment<br />		assume	cs:_TEXT,ds:DGROUP<br />	else<br />		@CODE	segment<br />		assume 	cs:@CODE,ds:DGROUP<br />	endif<br />	FUN_PROC name<br />	enter	locals,0<br />	irp	yy,&lt;di,si,ds&gt;<br />		ifidn	&lt;yy&gt;,&lt;ds&gt;<br />			if	SET_DS eq TRUE<br />				assume	ds:nothing<br />			endif<br />		endif<br />		irp	xx,&lt;regs&gt;<br />			ifidn	&lt;xx&gt;,&lt;yy&gt;<br />				ifidn	&lt;xx&gt;,&lt;ds&gt;<br />					if	SET_DS eq TRUE<br />						assume	ds:DGROUP<br />						push	ds<br />						mov	ax,DGROUP<br />						mov	ds,ax<br />					endif<br />				else<br />					push	xx<br />				endif<br />			endif<br />		endm<br />	endm<br />endm<br /><br />FUN_LEAVE macro	regs<br />	irp	yy,&lt;ds,si,di&gt;<br />		irp	xx,&lt;regs&gt;<br />			ifidn	&lt;xx&gt;,&lt;yy&gt;<br />				ifidn	&lt;xx&gt;,&lt;ds&gt;<br />					if	SET_DS eq TRUE<br />						pop	ds<br />					endif<br />				else<br />					pop	xx<br />				endif<br />			endif<br />		endm<br />	endm<br />	leave<br />	ret<br />endm<br /><br />FUN_END	macro	name<br />	if UNDERSCORE EQ TRUE<br />		_&amp;name	endp<br />		_TEXT	ends<br />	else<br />		name	endp<br />		@CODE	ends<br />	endif<br />endm<br /><br />FUN_AUTO	macro	name,	siz<br />	ifidn	&lt;siz&gt;,&lt;cp&gt;<br />		if	FAR_CODE eq TRUE<br />			AUTO_OFF = AUTO_OFF - 4<br />		else<br />			AUTO_OFF = AUTO_OFF - 2<br />		endif<br />	else<br />		ifidn	&lt;siz&gt;,&lt;dp&gt;<br />			if	FAR_DATA eq TRUE<br />				AUTO_OFF = AUTO_OFF - 4<br />			else<br />				AUTO_OFF = AUTO_OFF - 2<br />			endif<br />		else<br />			AUTO_OFF = AUTO_OFF - siz<br />		endif<br />	endif<br />	if UNDERSCORE EQ TRUE<br />		_&amp;name = AUTO_OFF<br />	else<br />		name = AUTO_OFF<br />	endif<br />endm<br /><br />FUN_ARG	macro	name,siz<br />	name	=	ARG_OFF<br />	ifidn	&lt;siz&gt;,&lt;cp&gt;<br />		if	FAR_CODE eq TRUE<br />			ARG_OFF	= ARG_OFF + 4<br />		else<br />			ARG_OFF	= ARG_OFF + 2<br />		endif<br />	else<br />		ifidn	&lt;siz&gt;,&lt;dp&gt;<br />			if	FAR_DATA eq TRUE<br />				ARG_OFF	= ARG_OFF + 4<br />			else<br />				ARG_OFF	= ARG_OFF + 2<br />			endif<br />		else<br />			ARG_OFF	= ARG_OFF + siz<br />		endif<br />	endif<br />endm<br /><br />if	CPU_TYPE eq 0<br />	enter	macro	a,b<br />		push	bp<br />		mov	bp,sp<br />		ifdif	&lt;a&gt;,&lt;0&gt;<br />			sub	sp,a<br />		endif<br />	endm<br /> <br />	leave	macro<br />		mov	sp,bp<br />		pop	bp<br />	endm<br /> <br />	PUSHA	MACRO<br />		PUSH	AX<br />		PUSH	CX<br />		PUSH	DX<br />		PUSH	BX<br />		PUSH	BX		;; Dummy value for SP<br />		PUSH	BP<br />		PUSH	SI<br />		PUSH	DI<br />	ENDM<br /> <br />	POPA	MACRO<br />		POP	DI<br />		POP	SI<br />		POP	BP<br />		POP	BX		;; Dummy value for SP<br />		POP	BX<br />		POP	DX<br />		POP	CX<br />		POP	AX<br />	ENDM<br />endif<br /><br /> <br />;	define basic segments<br /><br />if UNDERSCORE EQ FALSE			; c86 compiler segment conventions<br />@CODE	Segment Byte Public 'CODE'<br />@CODE	EndS<br />@DATAB	Segment PARA Public 'DATAB'<br />@DATAB	EndS<br />@DATAC	Segment Byte Public 'DATAC'<br />@sb	label	Byte<br />@sw	label	word<br />@DATAC	EndS<br />@DATAI	Segment Byte Public 'DATAI'<br />@ib	label	Byte<br />@iw	label	word<br />@DATAI	EndS<br />@DATAT	Segment Byte Public 'DATAT'<br />@DATAT	EndS<br />@DATAU	Segment Byte Public 'DATAU'<br />@ub	label	Byte<br />@uw	label	word<br />@DATAU	EndS<br />@DATAV	Segment Byte Public 'DATAV'<br />@DATAV	EndS<br /><br />DGroup	Group	@DATAB,@DATAC,@DATAI,@DATAT,@DATAU,@DATAV<br /><br />else 					; c86plus and microsoft<br />_TEXT	segment	byte public 'CODE'<br />_TEXT	ends<br />if	BOOT_STRAP eq TRUE<br />	C_ETEXT	segment	byte public 'ENDCODE'<br />	C_ETEXT	ends<br />endif<br />if	BOOT_STRAP eq TRUE<br />	if	SET_SSDS eq FALSE<br />		DGROUP	group	NULL,_DATA,_BSS,NEARHEAP,STACK<br />	else<br />		DGROUP	group	NULL,_DATA,_BSS,STACK<br />	endif<br />else<br />	DGROUP	group	NULL,_DATA,_BSS<br />endif<br /><br />NULL	segment	para public 'BEGDATA'<br />	assume	ds:DGROUP<br />NULL	ends<br />_DATA	segment word public 'DATA'<br />	assume	ds:DGROUP<br />_DATA	ends<br />_BSS	segment	word public 'BSS'<br />	assume	ds:DGROUP<br />_BSS	ends<br />if	BOOT_STRAP eq TRUE<br />	if	SET_SSDS eq FALSE<br />		NEARHEAP	segment para public 'BSS'<br />			assume	ds:DGROUP<br />		NEARHEAP	ends<br />	endif<br />	STACK	segment	para stack 'STACK'<br />	STACK	ends<br />endif<br /><br />endif					; c86plus and microsoft<br /><br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />C.AH Ends here<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br /><br />the line that I am compiling this with is:<br />ml /D &quot;CPU_2&quot; /D &quot;LARGE&quot; /D &quot;USCORE&quot; /Zi /c /coff IO.ASM<br />and linking:<br />lib /VERBOSE /MACHINE:IX86 /SUBSYSTEM:CONSOLE /OUT:\PATH\name.lib</div>
    <div class="meta">Posted on 2001-08-22 15:39:30 by mathfeel</div>
   </div>
   <div class="post" id="post-4778">
    <div class="subject"><a href="#post-4778">segment...group...</a></div>
    <div class="body">And just how much assembly code do you have?<br /><br />If it's just one small .ASM file plus this assembly header file, you're better off rewriting it without the header file.<br /><br />Take out the ASM file(s) and create a C file that replaces the missing functions (you can let the linker tell you what they are). Once you've got the C code compiling and linking, go back, make sense of the ASM code, and rewrite it! That's because the assembly header won't properly handle 32-bit code of any kind.<br /><br />If the ASM code is large, there's a very good chance that it uses addressing modes which are invalid in Win32 code -- which means you can't avoid a major rewrite.</div>
    <div class="meta">Posted on 2001-08-24 17:24:08 by tank</div>
   </div>
  </div>
 </body>
</html>