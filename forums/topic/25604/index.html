<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>display the number of capitals letters in the sentence - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25604" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25604">display the number of capitals letters in the sentence</a></p>
   <div class="post" id="post-186926">
    <div class="subject"><a href="#post-186926">display the number of capitals letters in the sentence</a></div>
    <div class="body">Hello everyone : )<br /><br />i&#39;m working on :<br /><br /><br /><div class="quote"><br /><br />Write a program that takes an input sentence from the user and on next line display the number of capitals letters in the sentence.&nbsp; <br /> <br />Note: <br />?&nbsp; &nbsp; &nbsp;  User is not allowed to enter a sentence with more than 9 Capital letters.<br /><br /></div><br /><br /><br />what i did is :<br /><br /> <br /><pre><code><br />.MODEL SMALL<br />.STACK 100H<br />.DATA<br /><br />MSG1 DB &#39;PLEASE ENTER YOUR SENTENCE:&nbsp; $&#39;<br /><br />MSG2 DB 0DH,0AH,&#39;THE NUMBER OF CAPITAL LETTERS IN SENTENCE :$&#39;<br /><br />MSG3 DB 0DH,0AH,&#39;You have entered more than 9 capital liter $&#39;<br /><br /><br />.CODE<br /><br />MAIN PROC<br /><br /><br />MOV AX,@DATA ;initialize DS<br />MOV DS,AX<br /><br /><br />;DISPLAY MSG1<br /><br />LEA DX,MSG1&nbsp; ;GET MSG1<br />MOV AH,9&nbsp; ;DISPLAY STRING<br />INT 21H&nbsp; ;DISPLAY MSG1<br /><br /><br />;READ&nbsp; CHARCHTER<br /><br />;if the user has entered more than 9 capital liter exit ...<br /><br />MOV bx,0<br />mov cx,9<br /><br />MOV AH,1&nbsp; ;READ sentenc<br /><br /> <br /><br /><br />TOP:<br /><br />INT 21h<br /><br />Mov bl,al<br /><br />cmp bl,&#39;A&#39;<br /><br />JGE Count<br /><br />CMP bl,&#39;Z&#39;<br />JLE Count<br /><br /><br />Count:<br /><br />INC bx<br />LOOP TOP<br /><br /><br />LEA DX,MSG2&nbsp; ;GET MSG2<br />MOV AH,9&nbsp; ;DISPLAY STRING<br />INT 21H&nbsp; ;DISPLAY MSG1<br /><br />mov ah,2<br />mov DX,BX<br />INT 21H<br /><br /> <br /><br />MOV AH,4CH ; return control to DOS<br />INT 21H<br /><br />MAIN ENDP<br /><br /> END MAIN<br /><br />END</code></pre><br /><br /><br />My problem is on counting the number of capital letters .<br /><br />Can anyone help please ?<br /><br /></div>
    <div class="meta">Posted on 2006-12-12 07:37:47 by Rooro</div>
   </div>
   <div class="post" id="post-186927">
    <div class="subject"><a href="#post-186927">Re: display the number of capitals letters in the sentence</a></div>
    <div class="body">1. homework.. read the rules<br />2. use buffered input, that way your little bit of code will work...<br /></div>
    <div class="meta">Posted on 2006-12-12 10:07:18 by evlncrn8</div>
   </div>
   <div class="post" id="post-186928">
    <div class="subject"><a href="#post-186928">Re: display the number of capitals letters in the sentence</a></div>
    <div class="body">A to Z goes from 41 to 5A inclusive.<br />So dump a letter at a time into al and cmp it<br /><br />zzzz<br />mov al,<br />cmp al,41<br />jb zzzz<br />cmp al,5A<br />ja zzzz<br /></div>
    <div class="meta">Posted on 2006-12-12 10:13:23 by eek</div>
   </div>
   <div class="post" id="post-186930">
    <div class="subject"><a href="#post-186930">Re: display the number of capitals letters in the sentence</a></div>
    <div class="body"><br />evlncrn8<br /><br />Sorry , i did know that i have not do this , but what i need is only small help : )<br /><br /><div class="quote">use buffered input, that way your little bit of code will work...</div><br /><br />what do you mean by : buffered ?<br /><br />i&#39;m new in assembly languge.<br /><br /><br /><br />_____________________________________________<br /><br />eek Thanks ...<br /><br />i did another code , but still having problem which is when i want to read a sentenc from the user the program takes only one character !<br /><br /><br /><br /><pre><code><br /><br />.MODEL SMALL<br />.STACK 100H<br />.DATA<br /><br />MSG1 DB &#39;PLEASE ENTER YOUR SENTENCE:&nbsp; $&#39;<br /><br />MSG2 DB 0DH,0AH,&#39;THE NUMBER OF CAPITAL LETTERS IN <br /><br />SENTENCE :$&#39;<br /><br />MSG3 DB 0DH,0AH,&#39;You have entered more than 9 capital <br /><br />LETTERS $&#39;<br /><br /><br />.CODE<br /><br />MAIN PROC<br /><br /><br />MOV AX,@DATA	;initialize DS<br />MOV DS,AX<br /><br />mov bX,0<br />;DISPLAY MSG1<br /><br />LEA DX,MSG1 	;GET MSG1<br />MOV AH,9		;DISPLAY STRING<br />INT 21H		;DISPLAY MSG1<br /><br /><br />MOV AH,1		;READ sentenc<br /><br />TOP:<br />INT 21h<br /><br /><br />WHILE_:<br /><br /><br />cmp al,0dh<br /><br />je END_WHILE<br /><br /><br />cmp al,&#39;A&#39;<br />CMP al,&#39;Z&#39;<br />JMP Count<br /><br />LOOP TOP<br /><br />Count:<br /><br />INC bx<br /><br />cmp bx,9<br />JLE Display1<br />JG Display2<br /><br /><br /><br />END_WHILE:<br /><br /><br />Display1:<br /><br />LEA DX,MSG2 	;GET MSG1<br />MOV AH,9		;DISPLAY STRING<br />INT 21H		;DISPLAY MSG1<br /><br />mov ah,2<br />mov DX,BX<br />INT 21H<br /><br /><br />Display2:<br /><br />LEA DX,MSG3 	;GET MSG1<br />MOV AH,9		;DISPLAY STRING<br />INT 21H		;DISPLAY MSG1<br /><br /><br />MOV AH,4CH	; return control to DOS<br />INT 21H<br /><br /><br /><br />MAIN ENDP<br /><br />	END MAIN<br /><br />END<br /></code></pre></div>
    <div class="meta">Posted on 2006-12-12 12:02:13 by Rooro</div>
   </div>
   <div class="post" id="post-186934">
    <div class="subject"><a href="#post-186934">Re: display the number of capitals letters in the sentence</a></div>
    <div class="body">Thats because I very wickedly wrote code that loops forever. :D<br />To see if you might figure that out, as part of your homework.<br />You&#39;ll need to increment the routine along the string so it loads the next letter after the test.<br /><br />mov bx,0<br />mov cx,<br />zzzz<br />inc &nbsp; &nbsp; &nbsp; ;increment the pointer<br />mov al,<br />dec cx<br />cmp al,41<br />jb zzzz<br />cmp al,5A<br />ja zzzz<br />inc bx&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;set to zero at start, to count capitals<br />inc cx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;prevents double cx decrement<br />loopnz zzzz&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;This decrements cx and<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;falls through when cx=0 <br /><br />There is one more error in there, it won&#39;t count the very first letter so you&#39;ll need to have a go at that.</div>
    <div class="meta">Posted on 2006-12-12 20:29:43 by eek</div>
   </div>
   <div class="post" id="post-186935">
    <div class="subject"><a href="#post-186935">Re: display the number of capitals letters in the sentence</a></div>
    <div class="body">Actually that last one would still loop too much<br /><br /><br />mov bx,0<br />mov cx,<br />dec si&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;si string pointer<br />zzzz<br />inc si<br />mov al,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;or lodsb, which does both inc and mov<br />dec cx<br />cmp cx,FFFF<br />jz xxxx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;This escapes from eternal looping<br />cmp al,41<br />jb zzzz<br />cmp al,5A<br />ja zzzz<br />inc bx<br />inc cx<br />loopnz zzzz<br />xxxx<br /><br />Its pretty guffy code, but if it works your teacher is unlikely to accuse you of copying it from anyone... :D</div>
    <div class="meta">Posted on 2006-12-12 21:09:29 by eek</div>
   </div>
   <div class="post" id="post-186936">
    <div class="subject"><a href="#post-186936">Re: display the number of capitals letters in the sentence</a></div>
    <div class="body">And if you want to do buffered keyboard input then its<br /><br />mov ah,0A<br />int 21<br /><br />which you&#39;ll need to googlie for info.<br /></div>
    <div class="meta">Posted on 2006-12-12 21:32:20 by eek</div>
   </div>
   <div class="post" id="post-186960">
    <div class="subject"><a href="#post-186960">Re: display the number of capitals letters in the sentence</a></div>
    <div class="body">Here is the complete code I wrote in TASM 3.2. It uses 8086 instructions throughout the code and is pretty self explanatory. I have commented every single line of the code but if you find it hard to understand, post back and I&#39;ll explain it more.<br /><br />The , ,  and  procedures are part of the <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=25410.0">OASML 1.0</a> library and I have just removed their description parts just to save some space. The  procedure is the procedure that counts the number of upper-case letters in a null-terminated string and then returns the result in the AX register. The trick that I&#39;ve used is to subtract 65 from any character/byte and then compare it to the value 25. Values higher than that are not upper-case.<br /><br />For example, if you have the character &#39;B&#39; which has the ASCII of 66 (0x42), you should subtract 65 from it to get 1. 1 is in the range 0&lt;1&lt;25, therefore, the letter is upper-case. Another example is when you have the character &#39;f&#39; with the ASCII code of 102 (0x66). You can now subtract 65 from it to get 37 which is not in the range 0...25, therefore, this is not an upper-case letter. Here is the code:<br /><br />P.S: The program does not use the DOS trap except for the termination part and it also uses Null-terminated strings throughout the code. <br /><br /><pre><span style="font-size:2>.8086<br />.MODEL SMALL<br />.STACK 400h<br />.DATA<br />&nbsp; Prompt&nbsp; &nbsp; &nbsp; &nbsp; DB&nbsp; &nbsp; &nbsp; &nbsp; &#39;Please enter your sentence: &#39;, 0<br />&nbsp; NoString&nbsp; &nbsp; &nbsp; DB&nbsp; &nbsp; &nbsp; &nbsp; &#39;You did not type anything!&#39;, 0<br />&nbsp; TotalCaps&nbsp; &nbsp; &nbsp;DB&nbsp; &nbsp; &nbsp; &nbsp; &#39;The number of capital letters in sentence: &#39;, 0<br />&nbsp; MoreThan9&nbsp; &nbsp; &nbsp;DB&nbsp; &nbsp; &nbsp; &nbsp; &#39;You have entered more than 9 capital letters!&#39;, 0<br />.DATA?<br />&nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; DB&nbsp; &nbsp; &nbsp; &nbsp; 0FFh DUP(?)<br />.CODE<br />; ------------------------------<br />WriteInt PROC<br />&nbsp; PUSH&nbsp; &nbsp; AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Push the AX register onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Push the CX register onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Push the DX register onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; OFFSET @@__WriteIntEP&nbsp; ; Push the offset of the EP onto the stack<br />&nbsp; MOV&nbsp; &nbsp; &nbsp;CX , 0Ah&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Divide by 10 each time<br />&nbsp; @@__WriteIntInnerLoop:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Inner loop<br />&nbsp; &nbsp; XOR&nbsp; &nbsp; &nbsp;DX , DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Clear out the remainder register<br />&nbsp; &nbsp; DIV&nbsp; &nbsp; &nbsp;CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Divide by CX<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Push the remainder onto the stack<br />&nbsp; &nbsp; TEST&nbsp; &nbsp; AX , AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; See if the number is zero<br />&nbsp; &nbsp; JE&nbsp; &nbsp; &nbsp; @@__WriteIntEL&nbsp; &nbsp; &nbsp; &nbsp;; Jump to the end of the loop if yes<br />&nbsp; &nbsp; CALL&nbsp; &nbsp; @@__WriteIntInnerLoop; Repeat the same routine<br />&nbsp; @@__WriteIntEL:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; End of the loop<br />&nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Pop the remainder<br />&nbsp; &nbsp; OR&nbsp; &nbsp; &nbsp; AL , 30h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Convert the number to character<br />&nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;AH , 0Eh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Printing proc<br />&nbsp; &nbsp; DW&nbsp; &nbsp; &nbsp; 10CDh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Issue the interrupt<br />&nbsp; &nbsp; RET&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Repeat the same action<br />&nbsp; @@__WriteIntEP:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; End of the procedure<br />&nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Pop the DX register from the stack<br />&nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Pop the CX register from the stack<br />&nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Pop the AX register from the stack<br />&nbsp; RET&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Return to the calling procedure<br />WriteInt ENDP<br />; ------------------------------<br />CountUpper PROC<br />&nbsp; PUSH&nbsp; &nbsp; BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Push the base index onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Push the data register onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; BP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Push the base pointer onto the stack<br />&nbsp; MOV&nbsp; &nbsp; &nbsp;BP , SP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Move the stack pointer to the base pointer<br />&nbsp; MOV&nbsp; &nbsp; &nbsp;BX , WORD PTR  ; BX points to the string<br />&nbsp; XOR&nbsp; &nbsp; &nbsp;AX , AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Clear out our result, 0 Caps letters found<br />&nbsp; @@__CountUpperLoop:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; The main loop<br />&nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;DL , BYTE PTR &nbsp; &nbsp;; Read one byte at a time, not really good<br />&nbsp; &nbsp; TEST&nbsp; &nbsp; DL , DL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; See if we have reached the end of the string<br />&nbsp; &nbsp; JE&nbsp; &nbsp; &nbsp; @@__CountUpperEP&nbsp; &nbsp; &nbsp;; Jump to ... if yes<br />&nbsp; &nbsp; INC&nbsp; &nbsp; &nbsp;BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Move to the next byte of the string<br />&nbsp; &nbsp; SUB&nbsp; &nbsp; &nbsp;DL , 40h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Subtract 65 from any byte/character<br />&nbsp; &nbsp; CMP&nbsp; &nbsp; &nbsp;DL , 19h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; See if the upper boundary is &gt; 25<br />&nbsp; &nbsp; JA&nbsp; &nbsp; &nbsp; @@__CountUpperLoop&nbsp; &nbsp;; Jump to ... if yes<br />&nbsp; &nbsp; INC&nbsp; &nbsp; &nbsp;AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; We have found an upper-case letter<br />&nbsp; &nbsp; JMP&nbsp; &nbsp; &nbsp;@@__CountUpperLoop&nbsp; &nbsp;; Keep searching in the string<br />&nbsp; @@__CountUpperEP:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; End of the procedure routine<br />&nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;BP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Restore the base pointer<br />&nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Restore the data register<br />&nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Restore the base index<br />&nbsp; RET&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Return to the calling procedure<br />CountUpper ENDP<br />; ------------------------------<br />NextLine PROC<br />&nbsp; PUSH&nbsp; &nbsp; AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Preserve the accumulator&#39;s value<br />&nbsp; MOV&nbsp; &nbsp; &nbsp;AH , 0Eh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Request Write-Character function<br />&nbsp; MOV&nbsp; &nbsp; &nbsp;AL , 0Dh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; The Carriage Return (CR)<br />&nbsp; DW&nbsp; &nbsp; &nbsp; 10CDh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Print the character<br />&nbsp; MOV&nbsp; &nbsp; &nbsp;AL , 0Ah&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; The Line Feed (LF)<br />&nbsp; DW&nbsp; &nbsp; &nbsp; 10CDh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Print the character<br />&nbsp; POP&nbsp; &nbsp; &nbsp;AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Restore the accumulator&#39;s value<br />&nbsp; RET&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Return to the calling procedure<br />NextLine ENDP<br />; ------------------------------<br />ReadString PROC<br />&nbsp; TEST&nbsp; &nbsp; AX , AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; See if the requested string length is zero<br />&nbsp; JE&nbsp; &nbsp; &nbsp; @@__ReadStringEP&nbsp; &nbsp; &nbsp; &nbsp;; Jump to the end of the procedure if yes<br />&nbsp; PUSH&nbsp; &nbsp; BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Push the base index onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Push the count register onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Push the data register<br />&nbsp; PUSH&nbsp; &nbsp; BP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Push the base pointer onto the stack<br />&nbsp; MOV&nbsp; &nbsp; &nbsp;BP , SP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Move the stack pointer to the base pointer<br />&nbsp; MOV&nbsp; &nbsp; &nbsp;BX , WORD PTR  ; BX points to the destination string now<br />&nbsp; MOV&nbsp; &nbsp; &nbsp;CX , AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Move the requested length to the CX register<br />&nbsp; XOR&nbsp; &nbsp; &nbsp;DX , DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; DX is the number of characters entered until now<br />&nbsp; JMP&nbsp; &nbsp; &nbsp;@@__ReadStringLoop&nbsp; &nbsp; &nbsp;; Jump to the main loop<br />&nbsp; @@__ReadStringHandleBS:&nbsp; &nbsp; &nbsp; &nbsp; ; Handle the BackSpace key<br />&nbsp; &nbsp; TEST&nbsp; &nbsp; DX , DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; See if the number of entered characters is zero<br />&nbsp; &nbsp; JE&nbsp; &nbsp; &nbsp; @@__ReadStringLoop&nbsp; &nbsp;; Shouldn&#39;t handle the BS key if it is<br />&nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;AH , 0Eh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Character Printing function<br />&nbsp; &nbsp; DW&nbsp; &nbsp; &nbsp; 10CDh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Navigatre to the previous character<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Preserve the string&#39;s offset<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Preserve the counter&#39;s state<br />&nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;AX , 0A00h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; AH = 0Ah (Print Character), AL = 00 (Character)<br />&nbsp; &nbsp; XOR&nbsp; &nbsp; &nbsp;BX , BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Print in the current page<br />&nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;CX , 0001h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Only once<br />&nbsp; &nbsp; DW&nbsp; &nbsp; &nbsp; 10CDh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Print the null-byte/character now<br />&nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Restore the counter<br />&nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Restore the string&#39;s offset<br />&nbsp; &nbsp; DEC&nbsp; &nbsp; &nbsp;DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Decrement the number of typed characters<br />&nbsp; &nbsp; DEC&nbsp; &nbsp; &nbsp;BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Move to the previous block in the string<br />&nbsp; @@__ReadStringLoop:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; The main loop<br />&nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;AH , 01h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Check for keystrokes<br />&nbsp; &nbsp; DW&nbsp; &nbsp; &nbsp; 16CDh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Issue the interrupt<br />&nbsp; &nbsp; JE&nbsp; &nbsp; &nbsp; @@__ReadStringLoop&nbsp; &nbsp;; Keep checking until a key is pressed<br />&nbsp; XOR&nbsp; &nbsp; &nbsp;AH , AH&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Get Keystroke function<br />&nbsp; DW&nbsp; &nbsp; &nbsp; 16CDh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Issue the interrupt<br />&nbsp; CMP&nbsp; &nbsp; &nbsp;AL , 0Dh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; See if the user has pressed the enter key<br />&nbsp; JE&nbsp; &nbsp; &nbsp; @@__ReadStringCP&nbsp; &nbsp; &nbsp; &nbsp;; Jump to ... if yes<br />&nbsp; CMP&nbsp; &nbsp; &nbsp;AL , 08h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; See if the user has pressed the backspace key<br />&nbsp; JE&nbsp; &nbsp; &nbsp; @@__ReadStringHandleBS ; Jump to ... if yes<br />&nbsp; MOV&nbsp; &nbsp; &nbsp;BYTE PTR  , AL&nbsp; &nbsp; &nbsp;; Put the read character into the string<br />&nbsp; MOV&nbsp; &nbsp; &nbsp;AH , 0Eh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Character Printing function<br />&nbsp; DW&nbsp; &nbsp; &nbsp; 10CDh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Print the character<br />&nbsp; INC&nbsp; &nbsp; &nbsp;BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Move to the next byte in the string<br />&nbsp; INC&nbsp; &nbsp; &nbsp;DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Number of typed characters should be incremented<br />&nbsp; DEC&nbsp; &nbsp; &nbsp;CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; The character limit is decremented<br />&nbsp; JNE&nbsp; &nbsp; &nbsp;@@__ReadStringLoop&nbsp; &nbsp; &nbsp;; Keep reading if the limit is not zero yet<br />&nbsp; @@__ReadStringCP:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Checkpoint<br />&nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;AX , DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Move the written characters to the result<br />&nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;BYTE PTR  , 00h&nbsp; ; Terminate the string right here<br />&nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;BP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Restore the base pointer<br />&nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Restore the data register<br />&nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Restore the count register<br />&nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Restore the base index<br />&nbsp; @@__ReadStringEP:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; End of the procedure routine<br />&nbsp; &nbsp; RET&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Return to the calling procedure<br />ReadString ENDP<br />; ------------------------------<br />WriteStr PROC<br />&nbsp; PUSH&nbsp; &nbsp; AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Push the accumulator onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Push the BX Register onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; BP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Push the base pointer<br />&nbsp; MOV&nbsp; &nbsp; &nbsp;BP , SP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Move the content of SP into the base pointer<br />&nbsp; MOV&nbsp; &nbsp; &nbsp;BX , WORD PTR  ; BX = String<br />&nbsp; MOV&nbsp; &nbsp; &nbsp;AH , 0Eh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Write character<br />&nbsp; @@__WriteStrInnerLoop:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Inner loop<br />&nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;AL , BYTE PTR &nbsp; &nbsp;; Move the current character from BX to AL<br />&nbsp; &nbsp; TEST&nbsp; &nbsp; AL , AL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; See if it is null<br />&nbsp; &nbsp; JE&nbsp; &nbsp; &nbsp; @@__WriteStrEP&nbsp; &nbsp; &nbsp; &nbsp;; Jump to the EP if yes<br />&nbsp; &nbsp; DW&nbsp; &nbsp; &nbsp; 10CDh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Print the character<br />&nbsp; &nbsp; INC&nbsp; &nbsp; &nbsp;BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Move to the next character<br />&nbsp; &nbsp; JMP&nbsp; &nbsp; &nbsp;@@__WriteStrInnerLoop; Repeat the inner loop<br />&nbsp; @@__WriteStrEP:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; End of the procedure routine<br />&nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;BP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Pop the Base pointer<br />&nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Pop the BX register<br />&nbsp; &nbsp; POP&nbsp; &nbsp; &nbsp;AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Pop the accumulator<br />&nbsp; RET&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Return to the caller proc<br />WriteStr ENDP<br />; ------------------------------<br />START:<br />&nbsp; ASSUME&nbsp; CS:@CODE, DS:@DATA, SS:@STACK<br />&nbsp; MOV&nbsp; &nbsp; &nbsp;AX , @DATA&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Put the data segment in the accumulator<br />&nbsp; MOV&nbsp; &nbsp; &nbsp;DS , AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Transfer this segment to the DS register<br /> <br /> <br />&nbsp; PUSH&nbsp; &nbsp; OFFSET Prompt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Push the offset of the intro prompt<br />&nbsp; CALL&nbsp; &nbsp; WriteStr&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Write the intro to the screen<br />&nbsp; ADD&nbsp; &nbsp; &nbsp;SP , 0002h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Remove the intro&#39;s offset from the stack<br /> <br /> <br />&nbsp; MOV&nbsp; &nbsp; &nbsp;AX , 00FFh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Our buffer is 255 bytes long<br />&nbsp; PUSH&nbsp; &nbsp; OFFSET Buffer&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Push the buffer&#39;s offset into the stack<br />&nbsp; CALL&nbsp; &nbsp; ReadString&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Read the user&#39;s input<br />&nbsp; ADD&nbsp; &nbsp; &nbsp;SP , 0002h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Remove the buffer&#39;s offset<br />&nbsp; CALL&nbsp; &nbsp; NextLine&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Move to the next line in the console<br /> <br /> <br />&nbsp; TEST&nbsp; &nbsp; AX , AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; See if the number of bytes read is zero<br />&nbsp; JNE&nbsp; &nbsp; &nbsp;@@__TypedString&nbsp; &nbsp; &nbsp; &nbsp; ; Jump to ... if not<br />&nbsp; PUSH&nbsp; &nbsp; OFFSET NoString&nbsp; &nbsp; &nbsp; &nbsp; ; Tell the user he has not entered anything<br />&nbsp; CALL&nbsp; &nbsp; WriteStr&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Do this right now!<br />&nbsp; ADD&nbsp; &nbsp; &nbsp;SP , 0002h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Remove the string&#39;s offset<br />&nbsp; JMP&nbsp; &nbsp; &nbsp;@@EP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Jump to the end of the program<br /> <br /> <br />&nbsp; @@__TypedString:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; The user has typed something<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; OFFSET Buffer&nbsp; &nbsp; &nbsp; &nbsp; ; Push the buffer&#39;s offset into the stack<br />&nbsp; &nbsp; CALL&nbsp; &nbsp; CountUpper&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Count the upper case letters, AX = Count<br />&nbsp; &nbsp; ADD&nbsp; &nbsp; &nbsp;SP , 0002h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Remove the buffer&#39;s offset<br />&nbsp; &nbsp; CMP&nbsp; &nbsp; &nbsp;AX , 000Ah&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; See if the caps letters are &lt; 10<br />&nbsp; &nbsp; JB&nbsp; &nbsp; &nbsp; @@__PrintCount&nbsp; &nbsp; &nbsp; &nbsp;; Jump to ... if yes<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; OFFSET MoreThan9&nbsp; &nbsp; &nbsp;; We have more than 9 caps letters here<br />&nbsp; &nbsp; CALL&nbsp; &nbsp; WriteStr&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Tell the user about this<br />&nbsp; &nbsp; ADD&nbsp; &nbsp; &nbsp;SP , 0002h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Remove the string&#39;s offset<br />&nbsp; &nbsp; JMP&nbsp; &nbsp; &nbsp;@@EP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Jump to the end of the program<br /> <br /> <br />&nbsp; @@__PrintCount:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Where we tell the upper-case letter count<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; OFFSET TotalCaps&nbsp; &nbsp; &nbsp;; Push the prompt&#39;s offset into the stack<br />&nbsp; &nbsp; CALL&nbsp; &nbsp; WriteStr&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Give the prompt to the user<br />&nbsp; &nbsp; ADD&nbsp; &nbsp; &nbsp;SP , 0002h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Remove the prompt&#39;s offset<br />&nbsp; &nbsp; CALL&nbsp; &nbsp; WriteInt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; AX = Number of caps letters, print it<br /> <br /> <br />&nbsp; @@EP:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; End of the program<br />&nbsp; &nbsp; MOV&nbsp; &nbsp; &nbsp;AX , 04C00h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; AH=0x4C (Exit), AL=0x00 (No errors)<br />&nbsp; &nbsp; DW&nbsp; &nbsp; &nbsp; 21CDh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Issue the interrupt<br />END START</span></pre></div>
    <div class="meta">Posted on 2006-12-15 00:39:18 by XCHG</div>
   </div>
   <div class="post" id="post-186991">
    <div class="subject"><a href="#post-186991">Re: display the number of capitals letters in the sentence</a></div>
    <div class="body"><br />Hi,<br /><br />the previos example surely works, but i tried a shorter version ( Masm 16bit ):<br /><pre><code><br />.model tiny<br />dos equ 21h<br />print macro string<br />&nbsp; lea dx,string<br />&nbsp; mov ah,09<br />&nbsp; int dos<br />endm<br />.data <br />msg1 db &quot;Enter sentence (and press Enter)&quot;,13,10,&quot;$&quot;<br />msg2 db 13,10,&quot;counted capitals : $&quot;<br />.code<br />.startup<br />&nbsp; &nbsp; &nbsp; &nbsp;  print msg1<br />&nbsp; &nbsp; &nbsp; &nbsp;  xor cx,cx<br />@@:<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ah,01<br />&nbsp; &nbsp; &nbsp; &nbsp; int&nbsp;  21h<br />&nbsp; &nbsp; &nbsp; &nbsp; cmp al,0dh<br />&nbsp; &nbsp; &nbsp; &nbsp; je @f<br />&nbsp; &nbsp; &nbsp; &nbsp; .if al&gt;=&#39;A&#39;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  .if al&lt;=&#39;Z&#39;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc cl<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp cl,9<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jae @f<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; jmp @b<br />@@:<br />&nbsp; &nbsp; print msg2<br />&nbsp; &nbsp; or cl,30h<br />&nbsp; &nbsp; mov dl,cl<br />&nbsp; &nbsp; mov ah,02<br />&nbsp; &nbsp; int dos<br />.exit<br />end<br /></code></pre><br /><br />u don&#39;t have to write novels even when u are programming in Assembler :)<br /></div>
    <div class="meta">Posted on 2006-12-17 12:52:11 by kermit</div>
   </div>
   <div class="post" id="post-187002">
    <div class="subject"><a href="#post-187002">Re: display the number of capitals letters in the sentence</a></div>
    <div class="body">The shortest path is not always the best. What if the user presses the Back-space key? What if you made the program write the characters to a buffer in order to solve this problem but the user entered a dollar sign as one of the characters? Your program is using the DOS trap thus working with the dollar-terminated strings.<br /><br />Let?s say you decide to use null-terminated strings instead to be able to solve the dollar-sign related issue. In this case, you are going to have to use the 0x10 trap in the IVT and you are left to handle the back-space key yourself. You are going to have to get the cursor position, decrement the column, put a null-byte there, remove that character from your buffer too and etc?<br /><br />Of course you can still use the DOS trap but not like above.<br /></div>
    <div class="meta">Posted on 2006-12-18 12:55:26 by XCHG</div>
   </div>
   <div class="post" id="post-187018">
    <div class="subject"><a href="#post-187018">Re: display the number of capitals letters in the sentence</a></div>
    <div class="body">really All of thanks to all of you ...&nbsp; ;)<br /><br /><br /> eek<br /><br />thanks for your help , and I get your idea : )<br /><br />specially :<br /><div class="quote"><br />And if you want to do buffered keyboard input then its<br /><br />mov ah,0A<br />int 21<br /></div><br /><br />_________________________________<br /><br />XCHG<br /><br />great , I will improve my self in assembly by your code , thanks a lot <br /><br /><br />__________________________________<br /><br />kermit<br /><br />thanks for your help , this new short way is new for me ! i will try to get it :)<br /><br /><br />______________________<br /><br /><br />this is what I have done :<br /><br /><br /><pre><code>.MODEL SMALL<br />.STACK 100H<br />.DATA<br />MSG1 DB &#39;PLEASE ENTER YOUR SENTENCE:&nbsp; $&#39;<br />MSG2 DB 0DH,0AH,&#39;THE NUMBER OF CAPITAL LETTERS IN SENTENCE :$&#39;<br />MSG3 DB 0DH,0AH,&#39;You have entered more than 19 CAPITAL LETTERS $&#39;<br /><br />.CODE<br />MAIN PROC<br /><br />MOV AX,@DATA ;initialize DS<br />MOV DS,AX<br />;DISPLAY MSG1<br />LEA DX,MSG1&nbsp; ;GET MSG1<br />MOV AH,9&nbsp; ;DISPLAY STRING<br />INT 21H&nbsp; ;DISPLAY MSG1<br /> <br /><br />; start of loop reading the input<br />; one character at a time<br />mov bX,0&nbsp;  ; initialize CAPITAL LETTERS counter<br />loop_top:<br />MOV AH,1&nbsp;  ;READ A CHARACTDR<br />INT 21h<br />cmp al,0dh&nbsp; ; end of line?<br />je Display1&nbsp; ; yes, then stop<br />; test for capital letters<br />cmp al,&#39;A&#39;<br />JL loop_end&nbsp; ; if char &lt; &#39;A&#39; then go to the end of the loop<br />CMP al,&#39;Z&#39;<br />JG loop_end&nbsp; ; if char &gt; &#39;Z&#39; then go to the end of the loop<br />INC bx&nbsp; &nbsp; ; increment capital letter counter<br /> <br />cmp bx,19<br />JG Display2&nbsp;  ; more than 19 capital letters<br /><br />loop_end:<br />jmp loop_top<br />Display1:<br />LEA DX,MSG2&nbsp;  ;GET MSG1<br />MOV AH,9&nbsp;  ;DISPLAY STRING<br />INT 21H&nbsp;  ;DISPLAY MSG1<br />CMP bx,9<br />JLE Display3<br /> <br />mov ah,2<br />mov dl,&#39;1&#39;<br />int 21h<br /><br />mov dl,bl&nbsp;  ; print the number of characters<br />add dl,&#39;0&#39;&nbsp; ;To convert the number of characters from ASCII to decimal number<br />SUB dl,10<br />MOV AH,2&nbsp;  ;display the number of character that is in dl<br />INT 21H<br />jmp exit_program <br />Display3:<br />mov dl,bl&nbsp;  ; print the number of characters<br />add dl,&#39;0&#39;&nbsp; ;To convert the number of characters from ASCII to decimal number<br />MOV AH,2&nbsp;  ;display the number of character that is in dl<br />INT 21H<br /> <br /> <br />jmp exit_program ; all done<br /> <br /> <br /><br />Display2:<br />LEA DX,MSG3&nbsp;  ;GET MSG3<br />MOV AH,9&nbsp;  ;DISPLAY STRING<br />INT 21H&nbsp;  ;DISPLAY MSG3<br /> <br />exit_program:<br />MOV AH,4CH&nbsp; ; return control to DOS<br />INT 21H<br /> <br />MAIN ENDP<br /> END MAIN<br />ENDF</code></pre></div>
    <div class="meta">Posted on 2006-12-19 11:39:39 by Rooro</div>
   </div>
  </div>
 </body>
</html>