<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>More about ranges - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4419" />
    <link rel="next" href="../?id=4419&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=4419">More about ranges</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=4419&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=4419&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="4419" /><input type="number" name="page" min="1" max="5" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=4419&amp;page=2">&gt;</a><a href="../?id=4419&amp;page=5">&raquo;</a></form>   <div class="post" id="post-30728">
    <div class="subject"><a href="#post-30728">More about ranges</a></div>
    <div class="body">Continuetion our talks of checking ranges.<br />Complex statements to check numerous ranges with 1 jcc.<br />Example:<br />If valid hex digit.<br /><pre><code><br />.if &#40;dl&gt;=&quot;0&quot; &amp;&amp; dl&lt;=&quot;9&quot;&#41; || &#40;dl&gt;=&quot;A&quot; &amp;&amp; dl&lt;=&quot;F&quot;&#41; || &#40;dl&gt;=&quot;a&quot; &amp;&amp; dl&lt;=&quot;f&quot;&#41;<br /><br />	xor eax,eax<br />	lea ecx,&#91;edx-30h&#93;<br />	cmp ecx,9<br />	adc eax,eax ;byte shorter than adc eax,0<br />	lea ecx,&#91;edx-'A'&#93;<br />	cmp ecx ,&#40;'F'-'A'&#41;<br />	adc eax,eax<br />	lea ecx,&#91;edx-'a'&#93;<br />	cmp ecx,&#40;'f'-'a'&#41;<br />	adc eax,eax<br />	je @notvalid<br /></code></pre><br /><br />Any practical idea is wellcome.</div>
    <div class="meta">Posted on 2002-03-25 05:46:31 by The Svin</div>
   </div>
   <div class="post" id="post-30757">
    <div class="subject"><a href="#post-30757">More about ranges</a></div>
    <div class="body">hi!<br /><br />I tried your code, with 'F' as string and it say, it's invalid ...<br />So it should be 'G'-'A' instead of 'F'-'A'.<br />the same with cmp eax, 9 ... that should be cmp eax, 10<br /><br />Also, since you test only DL, but use EDX in your calculation, you should remove the upper-bytes.<br /><br />But the rest is nice done :) <br /><br />So, your code should be :<br /><br /><pre><code><br />and edx, 0FFh<br />xor eax,eax<br />lea ecx,&#91;edx-30h&#93;<br />cmp ecx,10<br />adc eax,eax ;byte shorter than adc eax,0<br />lea ecx,&#91;edx-'A'&#93;<br />cmp ecx ,&#40;'G'-'A'&#41;<br />adc eax,eax<br />lea ecx,&#91;edx-'a'&#93;<br />cmp ecx,&#40;'g'-'a'&#41;<br />adc eax,eax<br />je @notvalid<br /></code></pre><br /><br />Cu, JNS<br />----<br /><a target="_blank" href="http://www.emucheater.com">http://www.emucheater.com</a><br /><a target="_blank" href="http://cyberpad.psxemu.com">http://cyberpad.psxemu.com</a></div>
    <div class="meta">Posted on 2002-03-25 09:14:08 by Jens Duttke</div>
   </div>
   <div class="post" id="post-30768">
    <div class="subject"><a href="#post-30768">More about ranges</a></div>
    <div class="body">You are right, thanks.<br />As too dl - edx, your right of course, but we may put in HLL explonative statemet edx instead of dl, I was absent minded - forgot to change dl to edx :)</div>
    <div class="meta">Posted on 2002-03-25 09:59:09 by The Svin</div>
   </div>
   <div class="post" id="post-30786">
    <div class="subject"><a href="#post-30786">More about ranges</a></div>
    <div class="body">hi!<br /><br />I've just played a bit with some code, since I am a bit bored now. :grin: <br /><br />... and found another solution, to solve the problem of validating hex-values, which is a bit shorter than The Svins :) <br /><br /><pre><code><br />sub	cl, 48<br />xor	edx, edx<br />mov	eax, 1<br />shld	edx, eax, cl<br />shl	eax, cl<br />and	eax, 007E03FFh<br />and	edx, 007E0000h<br />or	eax, edx<br />jz	@invalid<br /></code></pre><br /><br />The char need to be in cl.<br /><br />Cu, Jens<br />----<br /><a target="_blank" href="http://www.emucheater.com">http://www.emucheater.com</a><br /><a target="_blank" href="http://cyberpad.psxemu.com">http://cyberpad.psxemu.com</a></div>
    <div class="meta">Posted on 2002-03-25 11:50:03 by Jens Duttke</div>
   </div>
   <div class="post" id="post-30793">
    <div class="subject"><a href="#post-30793">More about ranges</a></div>
    <div class="body">Nice code,Jens.<br />I wish you being bored as long as possible to play with some code for us.<br />:)<br />There are cople thing I want to say.<br />1. It is shorter, all right.<br />3 bytes shorter. But you've changed character. Assume you get it as WM_CHAR<br />and need validate it without change. Then you need at least 2 more bytes.<br /><br />2. Let think of it as just an example or how to check if value is in one of acceptable<br />ranges and we need to check it with little possible jcc.<br />I gave my code as just an example of one universal possible solution.<br />It checks 3 ranges but can check as many as you need.<br />Logic simple if edx at least in one of acceptable ranges in the checking<br />CF will be set and eax will be &gt; 0 at the end.<br /><br />Now I'm asking you about two things.<br /> - Please comment your method<br /> - Tell us if the method may be used with variable number of ranges,<br />and if it is, tute us how to use this approach.<br />  If not, may be you have some different interesting general ideas how to<br /> check numerous ranges with little jcc.</div>
    <div class="meta">Posted on 2002-03-25 12:43:56 by The Svin</div>
   </div>
   <div class="post" id="post-30801">
    <div class="subject"><a href="#post-30801">More about ranges</a></div>
    <div class="body"><div class="quote"><br />But you've changed character. Assume you get it as WM_CHAR<br />and need validate it without change. Then you need at least 2 more bytes.<br /></div><br /><br />What do you mean ? which character do i change ? you mean the sub cl, 48 ? ... you could simply change that to lea ecx, like you do it in your code.<br /><br /><div class="quote"><br /><strong> - Please comment your method<br /> - Tell us if the method may be used with variable number of ranges,<br />and if it is, tute us how to use this approach.<br />  If not, may be you have some different interesting general ideas how to<br /> check numerous ranges with little jcc. </div><br /><br />hehe, ok<br /><br />1. It's like a range-in-range test<br /><br />You have a range of 64 bytes.<br /><br />These 64 bytes are represented by the &quot;bitMap&quot; :<br /><br />007E0000007E03FFh<br /><br />binary it's this :<br /><br />1111110000000000000000000000000011111100000001111111111<br /><br />like you see ... we have 3 ranges ... the first range (the 6 1's) are the lowercase letters, then the uppercase letters and then the numbers.<br /><br />now, let's assume the &quot;input char&quot; is '4' = 52d<br /><br />1. we subtract 48 -&gt; the result is 4<br />2. Now we set byte number 4 to 1 ... this is done with the shifts<br />3. and now, you AND our &quot;bitMap&quot; with the number, where bit number 4 is set<br />4. If the result is != 0 it matched and the number is valid ... if not it's invalid.<br /><br />Sorry, my english is not that good, and I don't know how to explain such &quot;complex&quot; things correctly.<br /><br />I hope you understand what i mean.<br /><br />So, this method is useful, if you have only a small &quot;overall-range&quot;<br />but with many &quot;matched&quot; values and many &quot;unmatched&quot; values.<br /><br />for example you could also check for<br /><br />1010010101010110101010100100000111100101010101011011101110101110<br /><br />that would be with normal jumps<br /><br />cmp dl, 0<br />jz @invalid<br />cmp dl, 4<br />jz @invalid<br />cmp dl, 6<br />jz @invalid<br />cmp dl, 10<br />jz @invalid<br />cmp dl, 14<br />jz @invalid<br />... and so on ...<br /><br />While my code has always the same length ... only the 2 lines<br />and	eax, 007E03FFh<br />and	edx, 007E0000h<br />need to be changed<br /><br />Maybe someone, who is better in english and understand what i mean, can comment the code. :)  <br /><br />Cu, Jens<br />----<br /><a target="_blank" href="http://www.emucheater.com">http://www.emucheater.com</a><br /><a target="_blank" href="http://cyberpad.psxemu.com">http://cyberpad.psxemu.com</a></div>
    <div class="meta">Posted on 2002-03-25 13:22:15 by Jens Duttke</div>
   </div>
   <div class="post" id="post-30805">
    <div class="subject"><a href="#post-30805">More about ranges</a></div>
    <div class="body"><div class="quote"><br />What do you mean ? which character do i change ? you mean the sub cl, 48 ? ... you could simply change that to lea ecx, like you do it in your code. <br /></div><br />In my code the character is in edx and I don't change it<br />In your code:<br /><div class="quote">The char need to be in cl. </div> <br />And you change it.<br />To avoid it you need one more register or more instructions.<br /><br />Thanks for comments.</div>
    <div class="meta">Posted on 2002-03-25 13:51:16 by The Svin</div>
   </div>
   <div class="post" id="post-30812">
    <div class="subject"><a href="#post-30812">More about ranges</a></div>
    <div class="body">Very creative approach <strong>Jens Duttke</strong>!  I like it, and will be using something similar in the future. Eliminates two-state small table lookups. :)</div>
    <div class="meta">Posted on 2002-03-25 14:11:53 by bitRAKE</div>
   </div>
   <div class="post" id="post-30813">
    <div class="subject"><a href="#post-30813">More about ranges</a></div>
    <div class="body">Jens,<br />BTW, Thomas, is keeping public snippet lib on his site<br /><a target="_blank" href="http://www.madwizard.org"></a> <br />I'm sure many asm programmers would be happy to see your work there.<br /><br />I want to say the same to Nexo, bullyNaza and all new things in asm creaters.</div>
    <div class="meta">Posted on 2002-03-25 14:18:00 by The Svin</div>
   </div>
   <div class="post" id="post-30846">
    <div class="subject"><a href="#post-30846">More about ranges</a></div>
    <div class="body">Jens, I've analyzed your method.<br />Man... You are very talanted!<br />I'm glad I asked you for comments.</div>
    <div class="meta">Posted on 2002-03-25 17:02:55 by The Svin</div>
   </div>
   <div class="post" id="post-30861">
    <div class="subject"><a href="#post-30861">More about ranges</a></div>
    <div class="body"><div class="quote"><br />small table lookups. :) </div>ahh ... that's the word which was missing ... look-up-table.<br />That explains it the best. :)<br /><br />Cu, Jens</div>
    <div class="meta">Posted on 2002-03-25 18:49:57 by Jens Duttke</div>
   </div>
   <div class="post" id="post-30864">
    <div class="subject"><a href="#post-30864">More about ranges</a></div>
    <div class="body">Yeah, I'd call it a 'bit register lookup' :grin:<br />Sounds like a good name for the technique?<br />What would that be in German?</div>
    <div class="meta">Posted on 2002-03-25 19:02:59 by bitRAKE</div>
   </div>
   <div class="post" id="post-30867">
    <div class="subject"><a href="#post-30867">More about ranges</a></div>
    <div class="body">Extending the concept, here are other possible schemes:<br /><br /><pre><code><br />ebx,ecx,edx,esi = up to 4 &#40;5 if we use EBP, 6 if we use ESP&#41; indexes we want to check<br />eax             = temporary register<br />edi             = scratch register &#40;must be set to zero initially&#41;<br /></code></pre><br /><br />1) if ALL of the indexes are INSIDE of bounds, jump label<br /><br />PseudoCode: IF (ebx&gt;=LOWER1 &amp;&amp; ebx&lt;UPPER1) &amp;&amp; (ecx&gt;=LOWER2 &amp;&amp; ecx&lt;UPPER2) &amp;&amp; (edx&gt;=LOWER3 &amp;&amp; edx&lt;UPPER3) &amp;&amp; (esi&gt;=LOWER4 &amp;&amp; esi&lt;UPPER4) THEN GOTO label<br /><br /><pre><code><br />                                xor             edi,edi<br />                                ;<br />                                lea             eax,&#91;ebx-UPPER1&#93;<br />                                cmp             eax,LOWER1-UPPER1<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;ecx-UPPER2&#93;<br />                                cmp             eax,LOWER2-UPPER2<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;edx-UPPER3&#93;<br />                                cmp             eax,LOWER3-UPPER3<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;esi-UPPER4&#93;<br />                                cmp             eax,LOWER4-UPPER4<br />                                adc             edi,edi<br />                                ;<br />                                jz              label<br /></code></pre><br /><br />---<br /><br />2) if ALL of the indexes are OUTSIDE of bounds, jump label<br /><br />PseudoCode: IF (ebx&lt;LOWER1 &amp;&amp; ebx&gt;=UPPER1) &amp;&amp; (ecx&lt;LOWER2 &amp;&amp; ecx&gt;=UPPER2) &amp;&amp; (edx&lt;LOWER3 &amp;&amp; edx&gt;=UPPER3) THEN GOTO label<br /><br /><pre><code><br />                                xor             edi,edi<br />                                ;<br />                                lea             eax,&#91;ebx-LOWER1&#93;<br />                                cmp             eax,UPPER1-LOWER1<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;ecx-LOWER2&#93;<br />                                cmp             eax,UPPER2-LOWER2<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;edx-LOWER3&#93;<br />                                cmp             eax,UPPER3-LOWER3<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;esi-LOWER4&#93;<br />                                cmp             eax,UPPER4-LOWER4<br />                                adc             edi,edi<br />                                ;<br />                                jz              label<br /></code></pre><br /><br />---<br /><br />3) if ANY of the indexes are INSIDE of bounds, jump label<br /><br />PseudoCode: IF (ebx&gt;=LOWER1 &amp;&amp; ebx&lt;UPPER1) || (ecx&gt;=LOWER2 &amp;&amp; ecx&lt;UPPER2) || (edx&gt;=LOWER3 &amp;&amp; edx&lt;UPPER3) || (esi&gt;=LOWER4 &amp;&amp; esi&lt;UPPER4) THEN GOTO label<br /><br /><pre><code><br />                                xor             edi,edi<br />                                ;<br />                                lea             eax,&#91;ebx-LOWER1&#93;<br />                                cmp             eax,UPPER1-LOWER1<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;ecx-LOWER2&#93;<br />                                cmp             eax,UPPER2-LOWER2<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;edx-LOWER3&#93;<br />                                cmp             eax,UPPER3-LOWER3<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;esi-LOWER4&#93;<br />                                cmp             eax,UPPER4-LOWER4<br />                                adc             edi,edi<br />                                ;<br />                                jnz             label<br /></code></pre><br /><br /><br />---<br /><br />4) if ANY of the indexes are OUTSIDE of bounds, jump label<br /><br />PseudoCode: IF (ebx&lt;LOWER1 &amp;&amp; ebx&gt;=UPPER1) || (ecx&lt;LOWER2 &amp;&amp; ecx&gt;=UPPER2) || (edx&lt;LOWER3 &amp;&amp; edx&gt;=UPPER3) || (esi&lt;LOWER4 &amp;&amp; esi&gt;=UPPER4) THEN GOTO label<br /><br /><pre><code><br />                                xor             edi,edi<br />                                ;<br />                                lea             eax,&#91;ebx-UPPER1&#93;<br />                                cmp             eax,LOWER1-UPPER1<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;ecx-UPPER2&#93;<br />                                cmp             eax,LOWER2-UPPER2<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;edx-UPPER3&#93;<br />                                cmp             eax,LOWER3-UPPER3<br />                                adc             edi,edi<br />                                ;<br />                                lea             eax,&#91;esi-UPPER4&#93;<br />                                cmp             eax,LOWER4-UPPER4<br />                                adc             edi,edi<br />                                ;<br />                                jnz              label<br /></code></pre><br /><br />---<br /><br />As you easily noted, if you invert ANY with ALL (or viceversa) and you also invert INSIDE with OUTSIDE (or viceversa) and the final branch instruction, then the code is perfectly the same.<br />That's why 3) and 4) are the same, and 1) and 4 are the same as well (of course with inverted branch).<br />This is exactly like to say that:<br />a OR b OR c<br />is perfectly equivalent to:<br />NOT ( (NOT a) AND (NOT b) AND (NOT c) )<br /><br />---<br /><br />Some remarks and general rules to help understanding, so this moves from &quot;black magic&quot; to something very intuitive, and expecially simple and easy to use:<br /><br />a) the LEA,CMP trick simply sets the carry flag if we're inside the bounds, and clears it if we're outside the bounds.<br /><br />b) said that, then we can use ADC reg,0 to accumulate in reg that single carry value, but we can also perform other operations, like RCL (more on this below). Note that instead of the 0 constant we can use a register, which makes the code smaller and thus faster (at least for cache considerations).<br /><br />c) now think again about the a) point. We can not invert the behaviour of CMP (i.e. the result it gives), but we could exploit the CMC instruction where it matters to complement the carry flag. For example:<br /><br />    LEA     EAX,<br />    CMP     EAX,UPPER1-LOWER1<br />    CMC                        ; this inverts the carry flag, and thus the result<br />    ADC     EDI,0              ; where 0 will be in a register, preferably<br /><br />But CMC may not be the fastest solution.<br />Having multiple indexes to check, we can use RCL:<br /><br />    LEA     EAX,<br />    CMP     EAX,UPPER1-LOWER1<br />    RCL     EDI,1<br />many times, and then apply a XOR mask to our final EDI register result, so that after the XOR we get a zero result if the bit mask is the one we wanted, in order to satisfy all the conditions we want in order to perform the final branch.<br /><br />But we don't even need that.. yes, we CAN invert the behaviour of CMP. How? Simply inverting the range:<br />    LEA     EAX,<br />    CMP     EAX,UPPER1-LOWER1<br />becomes:<br />    LEA     EAX,<br />    CMP     EAX,LOWER1-UPPER1<br /><br />So, to sum it all:<br /><br />---<br /><br />we can produce a carry flag depending on if an index is in range or not (i.e. carry=1 if inside bounds):<br /><br />    LEA     EAX,<br />    CMP     EAX,UPPER1-LOWER1<br /><br />or, if the lower range is 0, then we can use just:<br /><br />    CMP     EBX,UPPER1<br /><br />we can get inverted CMP behaviour (i.e. carry=1 if outside bounds) by simply doing:<br /><br />    LEA     EAX,<br />    CMP     EAX,LOWER1-UPPER1<br /><br />or, if the lower range is 0, then we can use:<br /><br />    CMP     EBX,UPPER1<br />    CMC     ;beware as CMC may get slow if abused, in some CPU's<br /><br />---<br /><br />Now that we've the power to produce a carry, inverted or not, depending on a lower..upper (or 0..upper) range, we can &quot;accumulate&quot; these carry flag results, one for each condition/index we want to check, using one of the following methods:<br /><br />    ADC     reg,0    ; instead of 0 we can use a register which is known to be zero)<br />the above ADC will increment reg every time a carry flag was found set. A typical use is in the &quot;OR&quot; constructs.. i.e. if the final result of reg is not 0, then at least one ADC had a carry to add, and thus at least one condition was true (or false, depending if we produced the carry flag inverted or not).<br /><br />we could set up reg e.g. to 4, and then SBB (subtract if the carry flag is found set) at each index/condition check: if our initial reg (which was set to the value 4) then reachs 0, we're sure that all 4 conditions were true. But we don't need this extra overhead: we can invert the conditions and use ADC.. thus use less instructions (remember the OR -&gt; AND tranform of above?).<br /><br />also, we could collect all carry flags via RCL reg,1 .. then XOR the final result with a mask, so that after the XOR we get a zero result if the bit mask is the one we wanted, in order to satisfy all the conditions we want to perform the final branch. But, again, we can instead always use ADC and simply invert the CMP result each specific time that we want so. This way we save the extra XOR.<br /><br />Finally, we can accumulate a result by doing ADC reg,reg caring only that the reg was 0 *initially*. This because by being able to exploit the &quot;inverted CMP&quot; trick I exposed, we only care that the final result of all those ADC's will be 0 or not (to then either JZ label or JNZ label).<br /><br />Note that ADC reg,reg doesn't take advantage of reg being eax (ADC reg,0 instead does). Neither LEA or XOR do take advantage of reg being eax. However, CMP does.. so I'm using EAX as temporary register in my lower..upper checks.<br /><br />---<br /><br />With the above explanation I tryed to move the discussion from black magic to something easy and intuitive to control.<br />Now there's something important to add.<br /><br />After years of experience, I designed my programming language's compiler in a way that privileges the optimizer to the compiler.. i.e. the compiler doesn't try to be _excessively_ smart, while the optimizer does.<br /><br />So a sequence like:<br /><br />PseudoCode: IF (ebx&gt;=LOWER1 &amp;&amp; ebx&lt;UPPER1) || (ecx&gt;=LOWER2 &amp;&amp; ecx&lt;UPPER2) || (edx&gt;=LOWER3 &amp;&amp; edx&lt;UPPER3) || (esi&gt;=LOWER4 &amp;&amp; esi&lt;UPPER4) THEN GOTO label<br /><br />gets initially compiled to:<br /><pre><code><br />                                lea             eax,&#91;ebx-LOWER1&#93;<br />                                cmp             eax,UPPER1-LOWER1<br />                                jc              label<br />                                lea             eax,&#91;ebx-LOWER2&#93;<br />                                cmp             eax,UPPER2-LOWER2<br />                                jc              label<br />                                lea             eax,&#91;ecx-LOWER3&#93;<br />                                cmp             eax,UPPER3-LOWER3<br />                                jc              label<br />                                lea             eax,&#91;esi-LOWER4&#93;<br />                                cmp             eax,UPPER4-LOWER4<br />                                jc              label<br /></code></pre><br /><br />and then the optimizer (for how it is designed) could recognize this typical scheme (also aided by some side info), seek for another free register (it chooses, if present, one that incidentally is already known to be zeroed), and change the above code sequence in part or completely to:<br /><br /><pre><code><br />                               ;xor             edi,edi              &#40;only if necessary&#41;<br />                                lea             eax,&#91;ebx-LOWER1&#93;<br />                                cmp             eax,UPPER1-LOWER1<br />                                adc             edi,edi<br />                                lea             eax,&#91;ecx-LOWER2&#93;<br />                                cmp             eax,UPPER2-LOWER2<br />                                adc             edi,edi<br />                                lea             eax,&#91;edx-LOWER3&#93;<br />                                cmp             eax,UPPER3-LOWER3<br />                                adc             edi,edi<br />                                lea             eax,&#91;esi-LOWER4&#93;<br />                                cmp             eax,UPPER4-LOWER4<br />                                adc             edi,edi<br />                                jne             label<br /></code></pre><br /><br />But I didn't even bother to implement this.<br /><br />Why? Because if we really want to exploit the power of assembly, then we should always use our brain, not just use others' code or a technique blindly. Note that in case all of our conditions are related by &quot;OR&quot;, all of the above is absolutely stupid, since it will check all of 4 conditions when maybe even just the first was sufficient to exit this big &quot;IF&quot; construct.<br /><br />In my programming language, I can set for each high level instruction (in this case &quot;IF&quot;) an optimizer setting which then the editor normally hides. This optimizer setting, in this case, would be &quot;optimize or not&quot;, and to which extent.<br /><br />Extensive use of nearly totally AUTOMATIC profiling then fine-tunes these specific instruction optimizer's settings.<br /><br />I try to keep things as much automatic as possible, although of course I'm here to advocate the use of hand written assembly. Yet being myself such a great fan of assembly has made me write a very efficient optimizer for my LLL/MLL/HLL language's compiler.<br /><br />You should also be aware that if e.g. you have 4 conditions and &quot;if any of them is valid you will jump&quot;, then you better put the most probable one as the first one to test (and so on), so that _statistically_ your routine will perform better. In my language I've a set of tools that help me also on these issues.. of course the goal is to produce extremely efficient code in less time than if I had to write it directly in hand optimized assembly. Honestly I'm very, very happy with the results.. and that's why I've always adviced you all to spend no less than half of your development time on your very own development tools.. that's the most intelligent and productive thing you could do.. at the end it pays with the interests, more than you may imagine. And it will feel &quot;yours&quot; more than anything else.<br /><br /><br />---<br /><br /><br />Fortunately this contribution wasn't NASM or MASM or anything specific ;)</div>
    <div class="meta">Posted on 2002-03-25 19:18:40 by Maverick</div>
   </div>
   <div class="post" id="post-30879">
    <div class="subject"><a href="#post-30879">More about ranges</a></div>
    <div class="body"><div class="quote"><br />hi!<br /><br />I've just played a bit with some code, since I am a bit bored now. :grin: <br /><br />... and found another solution, to solve the problem of validating hex-values, which is a bit shorter than The Svins :) <br /><br /><pre><code><br />sub	cl, 48<br />xor	edx, edx<br />mov	eax, 1<br />shld	edx, eax, cl<br />shl	eax, cl<br />and	eax, 007E03FFh<br />and	edx, 007E0000h<br />or	eax, edx<br />jz	@invalid<br /></code></pre><br /><br />The char need to be in cl.<br /><br />Cu, Jens<br />---- </div>Hi Jens :)<br /><br />For 32 bits, you can use this &quot;register look up&quot; technique instead:<br /><br /><pre><code><br />    LEA     EAX,&#91;ECX-STARTVALUE&#93;<br />    ROL     EAX,CL          ;EAX = 1111 1111 1100 0000 0111 1110 ....<br />    JS      .label<br /></code></pre><br />Just remember that the mask must be reversed in this case.</div>
    <div class="meta">Posted on 2002-03-25 20:31:31 by Maverick</div>
   </div>
   <div class="post" id="post-30880">
    <div class="subject"><a href="#post-30880">More about ranges</a></div>
    <div class="body">Sorry, there was a typo. Correct code:<br /><br /><pre><code><br />    LEA     ECX,&#91;ECX-STARTVALUE&#93;<br />    ROL     EAX,CL          ;EAX = 1111 1111 1100 0000 0111 1110 ....<br />    JS      .label<br /></code></pre></div>
    <div class="meta">Posted on 2002-03-25 20:33:40 by Maverick</div>
   </div>
   <div class="post" id="post-30890">
    <div class="subject"><a href="#post-30890">More about ranges</a></div>
    <div class="body">The Intel Manual states the the destination is <em>undefined</em> if the shift count is greaterthan the size of the destination of SHLD/SHRD!  If this method is used then the shift count should be restricted to 0-31 for this instruction.<br /><br />I offer this alternative:<pre><code>bts eax,ecx    ; works for all ecx<br />ror ecx,6      ; 0-31 32-63  ;also&#58; bt ecx,5<br />mov edx,eax    ;  1     1<br />sbb ecx,ecx    ;  0     1<br />xor eax,ecx    ;  1     0<br />xor edx,eax    ;  0     1<br />and eax,MASK1<br />and edx,MASK2<br />or eax,edx<br />je INVLD</code></pre>But ecx needs to be in range 0-63. :(</div>
    <div class="meta">Posted on 2002-03-25 21:45:50 by bitRAKE</div>
   </div>
   <div class="post" id="post-30892">
    <div class="subject"><a href="#post-30892">More about ranges</a></div>
    <div class="body">I think this is much better... :)<pre><code>	sub ecx,min    ; zero base<br />	mov edx,MASK1  ; load flags<br />	xor eax,eax    ; initialize result store<br />	bt edx,ecx     ; test<br />	mov edx,MASK2  ; load flags<br />	rcl eax,1      ; store result<br />	bt edx,ecx     ; test<br />	rcl eax,1      ; store result<br />; more masks...&#58;&#41;<br />	shr ecx,5      ; which bit?<br />	bt eax,ecx     ; test proper bit of results<br />	jc INVLD       ;5 cycles + branch on Athlon</code></pre>Limited to 1024 values tested - quite enough for characters.  No memory access and no branch mis-predict is a big plus.  And the macro:<pre><code>; register look-up<br />reglu MACRO INVLD,min,masks&#58;VARARG<br />	LOCAL y,msk<br /><br />	IF min NE 0<br />		sub ecx,min    ; zero base<br />	ENDIF<br />	y=0<br />	FOR msk, &lt;&amp;masks&gt;<br />		IF y EQ 0<br />			mov edx,msk    ; load flags<br />			xor eax,eax    ; initialize results<br />			bt edx,ecx     ; test<br />		ELSE<br />			mov edx,msk    ; load flags<br />			rcl eax,1      ; store result<br />			bt edx,ecx     ; test<br />		ENDIF<br />		y = y + 1<br />	ENDM<br />	rcl eax,1      ; store result<br />	shr ecx,5      ; which bit?<br />	bt eax,ecx     ; test proper bit of results<br />	jnc INVLD      ;<br />ENDM</code></pre>And the above goal is accomplished with:<pre><code>	reglu @Invalid,30h,007E0000h,007E03FFh</code></pre>Sorry, but I get carried away:<pre><code>_HEXADECIMAL EQU &lt;30h,007E0000h,007E03FFh&gt;<br />_ALPHANUMERIC EQU &lt;30h,000007FFh,0FFFE07FFh,0FFFE03FFh&gt;<br /><br />reglu @Invalid, _HEXADECIMAL<br />reglu @Invalid, _ALPHANUMERIC</code></pre>Not bad, if I do say so myself. :)<br /><br /><strong>Note to Athlon Programmers</strong>: <strong>BT</strong> <u>is</u> a vector path instruction!!<br /><span style="font-size:9px>(That is lessthan 4 + masks + branch cycles)</span></div>
    <div class="meta">Posted on 2002-03-25 22:34:18 by bitRAKE</div>
   </div>
   <div class="post" id="post-30913">
    <div class="subject"><a href="#post-30913">More about ranges</a></div>
    <div class="body">hi!<br /><br /><div class="quote"><br />Yeah, I'd call it a 'bit register lookup' :grin:<br />Sounds like a good name for the technique?<br />What would that be in German? </div>German translations of stuff like this sucks.<br /><br />But i would call it 'bitmap register lookup' :grin: <br /><br />Cu, Jens</div>
    <div class="meta">Posted on 2002-03-26 01:30:05 by Jens Duttke</div>
   </div>
   <div class="post" id="post-30950">
    <div class="subject"><a href="#post-30950">More about ranges</a></div>
    <div class="body">Maverick,<br />You wrote very good demonstrative article on topic.<br />Also manipulation with carry and adc with the range teq. can lead us to calculate right label to jump at the end. It's especially powerfull when condition ranges is unproportional to cases.<br />So if cond 1,2,3 is met jmp to proc1 but if cond 2,5,8 is met jump to proc2 and if only 2,3 is met jump to proc3.<br />In real code the end looks just as:<br /><br />    jmp dpt <br /><br />where reg is the reg that previously used in manipulation with<br />cf through adc and additional intruction to generate right case value. We often use the aproach in our database query coding.</div>
    <div class="meta">Posted on 2002-03-26 05:23:34 by The Svin</div>
   </div>
   <div class="post" id="post-30956">
    <div class="subject"><a href="#post-30956">More about ranges</a></div>
    <div class="body"><div class="quote"><br />Maverick,<br />You wrote very good demonstrative article on topic.<br />Also manipulation with carry and adc with the range teq. can lead us to calculate right label to jump at the end. It's especially powerfull when condition ranges is unproportional to cases.<br />So if cond 1,2,3 is met jmp to proc1 but if cond 2,5,8 is met jump to proc2 and if only 2,3 is met jump to proc3.<br />In real code the end looks just as:<br /><br />    jmp dpt <br /><br />where reg is the reg that previously used in manipulation with<br />cf through adc and additional intruction to generate right case value. We often use the aproach in our database query coding. </div>Yup, I use the XOR mask technique in my compiler for complex constructs where AND and OR (even XOR) are mixed.. but that was a &quot;trade secret&quot; and I didn't feel to mention it. :grin:<br /><br />I feel a bit ashamed about that.. but I'm a jealous guy. :tongue:</div>
    <div class="meta">Posted on 2002-03-26 05:51:41 by Maverick</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=4419&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=4419&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="4419" /><input type="number" name="page" min="1" max="5" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=4419&amp;page=2">&gt;</a><a href="../?id=4419&amp;page=5">&raquo;</a></form>  </div>
 </body>
</html>