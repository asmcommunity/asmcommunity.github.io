<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>More about ranges - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4419" />
  <link rel="prev" href="../?id=4419&amp;page=2" />  <link rel="next" href="../?id=4419&amp;page=4" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=4419">More about ranges</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=4419&amp;page=1" style="">&laquo;</a><a href="../?id=4419&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="4419" /><input type="number" name="page" min="1" max="5" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=4419&amp;page=4">&gt;</a><a href="../?id=4419&amp;page=5">&raquo;</a></form>   <div class="post" id="post-31010">
    <div class="subject"><a href="#post-31010">More about ranges</a></div>
    <div class="body">hi!<br /><br /><div class="quote"><br />No misunderstanding.  Read the quote above from the Intel Manual.  Memory lookups are different than register lookups.</div><br /><br />Ohh ... after reading it 5 times (damn complex written, if english isn't your native language :grin: ), I understand it.<br />And yes, i was wrong and your are right. :) <br /><br />And again, I learned something new about the x86 ... ;) <br /><br />But now the different between the size of your macro and this short code with memory access is even larger ... and it's nearly unbelievable that 140 bytes can be read/handled faster than 60 bytes, so i will test it with the code i used for the strlen-routines.<br /><br />Cu, Jens</div>
    <div class="meta">Posted on 2002-03-26 10:47:19 by Jens Duttke</div>
   </div>
   <div class="post" id="post-31014">
    <div class="subject"><a href="#post-31014">More about ranges</a></div>
    <div class="body">Certainly, there is going to be a 'crossover' point for each processor - where it is better to use the table over using straight code.  It will be interesting to see what this point is for each processor.  This is the same reason 'compiled sprites' are faster than the sprites stored in data - <strong>Maverick</strong> knows what I'm talking about here - he mentioned he was using compiled sprites.<br /><br /><strong>Jens</strong>, I am glad that you learned something - I too was caught by this instruction.  In 16-bit code the count can only access 32k - where one would think it would be able to access 64k.  I spent a couple hours debugging this one! :)</div>
    <div class="meta">Posted on 2002-03-26 11:19:35 by bitRAKE</div>
   </div>
   <div class="post" id="post-31018">
    <div class="subject"><a href="#post-31018">More about ranges</a></div>
    <div class="body">I'd like to extend what I wrote some posts above about advanced uses of the<br />carry flag. When you check for a bound, e.g. from 0 (included) to 32 (excluded),<br />you can do, as we saw in that post, a simple:<br /><pre><code><br />                CMP     ECX,32<br /></code></pre><br />now the carry flag will be set if ECX is within 0 (included) to 32 (excluded).<br />(note that the &quot;from included to excluded&quot; is what is typically used in bound<br />checkings, for example for arrays).<br /><br />We can now exploit another trick:<br /><pre><code><br />                SBB     EAX,EAX<br /></code></pre><br />regardless of what was in EAX before, now EAX will be all zeros if the carry<br />flag was set by CMP (which is like to say &quot;if we were inside the bounds&quot;, but<br />EAX will be all ones (i.e. FFFFFFFF hex) if the carry was clear (i.e. if we<br />were out of bounds).<br /><br />Now we can use the EAX mask we obtained to do many interesting tricks, using<br />for example the AND, OR and XOR instructions.<br /><br />To remain in topic with this thread, we may want to select one of two 32 bit<br />values depending on if ECX is within the bounds or not.<br /><br /><br />On P6 and higher:<br /><pre><code><br />                MOV     EBX,MASK1<br />                MOV     EAX,MASK2<br />                CMP     ECX,32<br />                CMOVC   EAX,EBX<br /></code></pre><br />Now EAX will contain MASK1 or MASK2, depending if ECX is within bounds or not.<br /><br /><br />For CPU's &lt;= P5 we can do instead:<br /><pre><code><br />                MOV     EAX,MASK2<br />                CMP     ECX,32<br />                SBB     EBX,EBX<br />                AND     EBX,MASK1^MASK2          ; MASK1 xor MASK2<br />                XOR     EAX,EBX<br /></code></pre><br />How does it work? It's simple.. and maybe it's about time to remove the magic<br />also from the tricks that use another very useful instruction: XOR.<br /><br />So, we already know that, after SBB, EBX will be either all 0's or all 1's,<br />depending if ECX is within the bounds we've specified or not.<br />Now, for example, do you recall the formula to implement linear interpolation?<br /><br />It's just a:<br /><br />result = (A*(1-alpha))+(B*alpha)     ; where alpha is from 0.0 to 1.0<br /><br />but the above can be rewritten this way, which is perfectly equivalent (but simply more optimized):<br /><br />result = A+(alpha*(B-A))<br /><br />i.e. we start from A and then account only for the difference between B and A,<br />&quot;to fill the gap&quot;.<br /><br />We can use the same technique to set a value, and eventually fix it later as<br />much as needed to transform it into another value. We could have written it<br />also this way:<br /><pre><code><br />                MOV     EAX,MASK2<br />                CMP     ECX,32<br />                SBB     EBX,EBX<br />                AND     EBX,MASK1-MASK2         ; difference between MASKs<br />                ADD     EAX,EBX<br /></code></pre><br />It's just that I prefer to use logical instructions instead of arithmetic<br />ones, when possible (there are good reasons to do so, but I do not want to<br />make this post too long).<br /><br />---<br /><br />So now we've a P6 (using CMOV) or P5 method to select the right mask.. and<br />we can finally test it:<br /><pre><code><br />                BT      EAX,ECX<br />                JNC     .notvalid<br /></code></pre><br />But BT may be a slow instruction in some CPU's .. so here's an alternative<br />method:<br /><pre><code><br />                SHR     EAX,CL<br />                JC      .notvalid<br /></code></pre><br />Just remember two things if you use the above:<br />1) ECX must not be higher than 31 .. because otherwise unfortunately Intel does<br />not *guarantee* a correct carry flag :( So place a AND ECX,31 before the SHR.<br />2) You must increment of 1 unit CL to obtain the same result obtained with BT.<br />You may account for this in the LEA instruction, or rotate the masks, etc..<br /><br />---<br /><br />To sum it all this is my code for &quot;bitmap register lookup&quot;. I've to admit<br />that my own programming language's compiler/optimizer gave me some hints,<br />because I was too lazy to think about some of the above things myself. ;)<br /><pre><code><br />                MOV     EBX,MASK1<br />                MOV     EAX,MASK2<br />                CMP     ECX,32            ; ECX is a 0..63 index<br />                CMOVC   EAX,EBX<br />                BT      EAX,ECX<br />                JNC     .notvalid<br /></code></pre><br />Maybe it can be improved furtherly.. but I've no time right now. I will try<br />later perhaps, since I'd like to send this stuff to Thomas' snippets section;<br />together with the profile code (BTW, <strong>grv575</strong>, since I'd like to give you proper<br />credits for your MASM translation, please could you give me your full name,<br />or anyway the name you prefer to be credited with?); and maybe also send the<br />stuff about CMP and the carry flag. Later I may add other contributions,<br />since I'm trying to be less asshole and maybe share the little I know. Also,<br />I proven myself my ignorance on the x86 by the ROL wrong assumptions.. I've<br />really to clean my mind a bit about the 68000 and start doing some serious<br />x86 assembly instead.. like learning flags after all opcodes, etc.. lazyness<br />sucks. :)<br /><br /><br />ISHEX? (lowercase and uppercase supported)<br />;input: AL = character to test<br /><pre><code><br />                LEA     ECX,&#91;EAX-'0'&#93;<br />                MOV     EBX,007E03FFh                   ; MASK1<br />                MOV     EAX,007E0000h                   ; MASK2<br />                CMP     CL,32<br />                CMOVC   EAX,EBX<br />                BT      EAX,ECX<br />                JNC     .not_a_hex_number<br /></code></pre><br /><br />Finally, to know if a character is numeric, we can use the other technique<br />I exposed:<br /><br />ISNUMERIC?<br />;input: CL = character to test<br /><pre><code><br />                LEA     EAX,&#91;ECX-'0'&#93;<br />                CMP     AL,9<br />                JNC     .not_a_number<br /></code></pre><br /><br />Really gotta go now.. have a nice day.</div>
    <div class="meta">Posted on 2002-03-26 12:11:11 by Maverick</div>
   </div>
   <div class="post" id="post-31023">
    <div class="subject"><a href="#post-31023">More about ranges</a></div>
    <div class="body">You know, I'm tired and stressed and I always leave errors behind.<br /><br />My last code:<br /><pre><code><br />                LEA     EAX,&#91;ECX-'0'&#93;<br />                CMP     AL,9<br />                JNC     .not_a_number<br /></code></pre><br /><br />should have CMP AL,10 instead of CMP AL,9<br /><br />Sorry for the error, I was in a hurry and overlooked some things.<br />But all the other code should be error free.<br /><br />---<br /><br />Now, in reply to bitRAKE:<br /><br /><div class="quote">Certainly, there is going to be a 'crossover' point for each processor - where it is better to use the table over using straight code. It will be interesting to see what this point is for each processor. This is the same reason 'compiled sprites' are faster than the sprites stored in data - Maverick knows what I'm talking about here - he mentioned he was using compiled sprites.</div>It's quicker to just profile the two routines under _real_ conditions, and then see which one performs better. In a loop, I believe yours will be much faster.. but since profiling is such a quick and reliable operation, why not just profile it where/when/how you will use it? A different scenario can make one better or worse, so it's always better to keep more routines.. someday you'll have a use for any of them.<br /><br />On thing that we all (Athlon owners) must not forget when evaluating these techniques, though, is that the Athlon has got much more generous L1 I/D caches than Intel CPU's. <br />That's why about my fonts/sprites routine (as in most of my work) I prefer to simply have a routine that generates the code for the print_font / draw_sprite routine.<br />So when I'll get my hands on a Pentium IV I'll know if it's the case to differentiate between generating precompiled code, or maybe e.g. RLE sprites.<br />Also, having a code generator makes profiling possible *at run time* and self adaptation to the host CPU. This last one is a technique I use a lot.   <br /><br />The problem is always time.. so many things to do, so many ideas.. so little free time for them.<br />I wish my contracts were expired soon.. lotsa boring non-assembly-coding stuff there.</div>
    <div class="meta">Posted on 2002-03-26 12:45:50 by Maverick</div>
   </div>
   <div class="post" id="post-31025">
    <div class="subject"><a href="#post-31025">More about ranges</a></div>
    <div class="body"><strong>Maverick</strong>, you have explained my code above, nicely. :)<br />See post: <a target="_blank" href="http://www.asmcommunity.net/board/showthread.php?s=&amp;postid=31018.msg30890">http://www.asmcommunity.net/board/showthread.php?s=&amp;postid=31018.msg30890</a><br /><br />Still it is limited in that ECX must be in range [0-63] + '0'  Else there is overlap of mask, for example if ECX = 128.</div>
    <div class="meta">Posted on 2002-03-26 12:48:57 by bitRAKE</div>
   </div>
   <div class="post" id="post-31040">
    <div class="subject"><a href="#post-31040">More about ranges</a></div>
    <div class="body">Maverick, you don't have to credit me it was just a straightforward translation.  I'm just glad you took the time to post this code.  Kinda surprised me that it gets exact cycle counts on my machine even in ring 3.<br /><br />Btw, if anyone knows offhand how to get 64bit alignment for the code &amp; data segments maybe you could post that.  Don't know how important that was for the algo so I just used align 4 for the .data and align 16 for the .code.  Does it make a difference when you switch processors?</div>
    <div class="meta">Posted on 2002-03-26 14:13:00 by grv575</div>
   </div>
   <div class="post" id="post-31047">
    <div class="subject"><a href="#post-31047">More about ranges</a></div>
    <div class="body"><div class="quote"><br />Btw, if anyone knows offhand how to get 64bit alignment for the code &amp; data segments maybe you could post that.  Don't know how important that was for the algo so I just used align 4 for the .data and align 16 for the .code.  Does it make a difference when you switch processors? </div>Yes it makes a difference in many ways, check out this post:<br /><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=3941.msg26814">http://www.asmcommunity.net/board/index.php?topic=3941.msg26814</a></div>
    <div class="meta">Posted on 2002-03-26 14:35:20 by bitRAKE</div>
   </div>
   <div class="post" id="post-31071">
    <div class="subject"><a href="#post-31071">More about ranges</a></div>
    <div class="body"><div class="quote"><br /><strong>Maverick</strong>, you have explained my code above, nicely. :)<br />See post: <a target="_blank" href="http://www.asmcommunity.net/board/showthread.php?s=&amp;postid=31018.msg30890">http://www.asmcommunity.net/board/showthread.php?s=&amp;postid=31018.msg30890</a><br /><br />Still it is limited in that ECX must be in range [0-63] + '0'  Else there is overlap of mask, for example if ECX = 128. </div>If you refer to my code, yes, I already said that.. in the line:<br /><pre><code><br />        CMP     ECX,32            ; ECX is a 0..63 index<br /></code></pre><br />It's easy to extend my method to have more that two masks, anyway.. but from a certain moment on, I'd rather prefer a memory based one.</div>
    <div class="meta">Posted on 2002-03-26 17:10:23 by Maverick</div>
   </div>
   <div class="post" id="post-31075">
    <div class="subject"><a href="#post-31075">More about ranges</a></div>
    <div class="body"><div class="quote"><br />If you refer to my code, yes, I already said that.. in the line:<br /><pre><code><br />        CMP     ECX,32            ; ECX is a 0..63 index<br /></code></pre><br />It's easy to extend my method to have more that two masks, anyway.. but from a certain moment on, I'd rather prefer a memory based one. </div>Yes, you say that in the comment, but your code responds incorrectly to values out of range.  The last version I present responds correctly to values out of range.  I'm sorry, my rushed replied are not explicit enough.</div>
    <div class="meta">Posted on 2002-03-26 17:35:53 by bitRAKE</div>
   </div>
   <div class="post" id="post-31080">
    <div class="subject"><a href="#post-31080">More about ranges</a></div>
    <div class="body"><div class="quote">Maverick, you don't have to credit me it was just a straightforward translation. I'm just glad you took the time to post this code. Kinda surprised me that it gets exact cycle counts on my machine even in ring 3.</div>I'd like to insist, not only because of the work on the MASM translation, but also because I saw other posts of you (just to name one, the Chi square deviation test for random generators, but there were others) which were very interesting and IMHO a very good thing for the board.<div class="quote">Btw, if anyone knows offhand how to get 64bit alignment for the code &amp; data segments maybe you could post that. Don't know how important that was for the algo so I just used align 4 for the .data and align 16 for the .code. Does it make a difference when you switch processors?</div>It matters a lot. For example, if you keep some variables near your code (which is anyway bad, because so you waste inst &amp; data cache by doubling the same stuff, thus exploiting the cache only half) you get a much higher risk: if you write to a variable which is in the same cache line of your code, then it will be &quot;misidentified&quot; as self modifying code, and you will incur in *major* penalties (I'm talking even about thousands cycles for each write here!). Having it at least in another cache line fixes some, although not all of the problems.<br />Also, on my Athlon if you align loops at multiples of 2 then they will be faster than if they're at odd addresses. In general an alignment of 16 is very important for instruction decoding, expecially on loops, which imposes even more severe &quot;restrictions&quot;.<br />Sorry, I can't help about how to achieve alignment under MASM.. but I can about any memory allocator ( e.g. C/C++'s malloc() ) which by itself doesn't support aligned allocations ( laaaame :) ). Also, making things cache-line aligned makes you exploit the cache better.<br /><br />A thing that I use much but I've never seen elsewhere (although it has been probably used by a lot of coders) is to specify not only the alignment, but also the offset.. for a higher control. I use this e.g. to get an inner loop already aligned (without having to pad with NOPs, equivalent instructions, or even worse an explicit JMP), but also because the limited associativity of caches sometimes imposes, to exploit the caches well, to have different lower bits values in the addresses of multiple data buffers you access.<br /><br />PS: This is some old WatcomC/C++ code of mine to fix the limitations of malloc():<br /><br />---<pre><code>/****************************************************************************<br />;*<br />;* HEAPALLOCATE<br />;*<br />;*    INPUT&#58;  <br />;*   U32&gt; Size of requested memory &#40;in bytes&#41;<br />;*   U32&gt; Memory alignment, e.g. 4 = LONGWORD aligned, 65536 = $xxxx0000<br />;*   U32&gt; Memory alignment offset, e.g. $8000 = from half of   ^^^^^^^^^<br />;*<br />;*   OUTPUT&#58;<br />;*     P32&gt; ^ to the allocated memory<br />;*<br />;*     NOTE&#58; Memory alignment must be a power of 2 &#40;example&#58; 4,16,32,256..&#41;<br />;*     NOTE&#58; The bank will always be at least 32bytes aligned automatically<br />;*     NOTE&#58; The constant MEMSAFE is used to allow out of limit R/W<br />;*<br />;*   FAILED&#58;<br />;*          0 = All right. The P32 returned is valid.<br />;*  &#40;error&#41; 1 = Out of memory. The P32 returned is 0.<br />;*<br />*/<br /><br />P32 _HEAPALLOCATE&#40;U32 Size, U32 Alignment, U32 Offset&#41; &#123;<br />   P32 truept, mempt;<br />   // --<br />   if &#40;Size==0&#41; return&#40;0&#41;;<br />   if &#40;Alignment&lt;32&#41; Alignment=32;<br />   truept=&#40;P32&#41;malloc&#40;4+Alignment+Size+MEMSAFE&#41;;<br />   if &#40;truept==NULL&#41; &#123;<br />      ERROR&#40;&quot;Not enough memory.&quot;&#41;;<br />      return&#40;0&#41;;<br />   &#125; else &#123;<br />      mempt=&#40;P32&#41;&#40;&#40;&#40;U32&#41;truept+4+Alignment&#41;&amp;&#40;-Alignment&#41;&#41;+&#40;Offset&amp;&#40;Alignment-1&#41;&#41;;<br />      *&#40;P32U32&#41;&#40;mempt-4&#41;=&#40;U32&#41;truept;<br />      SUCCESS&#40;&#41;;<br />      return&#40;mempt&#41;;<br />   &#125;<br />&#125;<br /><br />P32 HEAPALLOCATE&#40;U32 Size, U32 Alignment, U32 Offset&#41; &#123;<br />   return&#40;_HEAPALLOCATE&#40;Size,Alignment,Offset&#41;&#41;;<br />&#125;<br /><br />P32 HEAPALLOCATE&#40;U32 Size, U32 Alignment&#41; &#123;<br />   return&#40;_HEAPALLOCATE&#40;Size,Alignment,0&#41;&#41;;<br />&#125;<br /><br />P32 HEAPALLOCATE&#40;U32 Size&#41; &#123;<br />   return&#40;_HEAPALLOCATE&#40;Size,0,0&#41;&#41;;<br />&#125;<br /><br />/*<br />;* End of HEAPALLOCATE routine<br />;****************************************************************************<br />;*<br />;* HEAPFREE<br />;*<br />;*    INPUT&#58;  <br />;*     P32&gt; ^ to the allocated memory<br />;*<br />*/<br /><br />void HEAPFREE&#40;P32 Pointer&#41; &#123;<br />   if &#40;Pointer!=0&#41; &#123;<br />      free&#40;&#40;P32&#41;*&#40;P32U32&#41;&#40;Pointer-4&#41;&#41;;<br />   &#125;<br />&#125;<br /><br />/*<br />;* End of HEAPFREE routine<br />;****************************************************************************<br />;*<br />;* HEAPAVAILABLE<br />;*<br />;*   OUTPUT&#58;<br />;*   U32&gt; size of available block<br />;*<br />*/<br /><br />U32 HEAPAVAILABLE&#40;&#41; &#123;<br />   U32 tn, m, n;<br />   P32 pt;<br />   // --<br />   tn=0; m=0; n=2&lt;&lt;28;<br />   loop&#58; tn++; pt=&#40;P32&#41;malloc&#40;m+n&#41;; if&#40;pt!=0&#41; free&#40;pt&#41;; else &#123; n&gt;&gt;=1; goto loop; &#125;<br />   m=m+n; n&gt;&gt;=1; if &#40;n&gt;65536&#41; goto loop;<br />   // --<br />   return&#40;m+n&#41;;<br />&#125;<br /><br />/*<br />;* End of HEAPAVAILABLE routine<br />;***************************************************************************/</code></pre>---<br /><br />Under Windows VirtualAlloc() returns memory with an alignement of at least 4096.. which will be enough for the usual needs.<br /><br /><span style="font-size:9px>bitRAKE: Edited for readablity CODE tags to QUOTE tags.</span></div>
    <div class="meta">Posted on 2002-03-26 18:10:39 by Maverick</div>
   </div>
   <div class="post" id="post-31085">
    <div class="subject"><a href="#post-31085">More about ranges</a></div>
    <div class="body"><div class="quote"><br />Yes, you say that in the comment, but your code responds incorrectly to values out of range.  The last version I present responds correctly to values out of range.</div>Yes, your method never branches for out of bounds, but is twice as slow as mine.. so I don't see the benefits (even adding cmp/jae would not make my method twice as slow). Also, bound checking is a requirement that I don't have, since I wouldn't use that method to check if a char is HEX anyway (it would be very easy to add it, though, and probably not having to resort to a stupid cmp/jae, even).<br />My method was just in response to this last code I saw from Jens, sorry if it instead seemed something else:<br /><br /><br /><pre><code><br />       xor	edx, edx<br />       mov	eax, 1<br />       shld	edx, eax, cl<br />       shl	eax, cl<br />       and	eax, MASK1<br />       and	edx, MASK2<br />       or	eax, edx<br />       jz	@invalid<br /></code></pre><br />That needs a 0..63 index, and 64 iterations of which on my Athlon runs at an average of 11.84375 cycles per iteration. Also, it doesn't really work, since one mask will interfere with the other, giving wrong results.<br /><br /><br />Then (but I saw it after writing mine) you wrote this routine:<br /><pre><code><br />	mov edx,MASK2  ; load flags<br />	xor eax,eax    ; initialize result store<br />	bt edx,ecx     ; test<br />	mov edx,MASK1  ; load flags<br />	rcl eax,1      ; store result<br />	bt edx,ecx     ; test<br />	rcl eax,1      ; store result<br />	shr ecx,5      ; which bit?<br />	bt eax,ecx     ; test proper bit of results<br />	jc INVLD       ;5 cycles + branch on Athlon<br /></code></pre><br />64 iterations of which on my Athlon run at an average of 4.000 cycles per iteration.<br />(I had to invert the masks on your routine and change JNC to JC in mine below just to make results consistent: it doesn't change the execution speeds).<br /><br /><br />I simply explained step by step the reasoning that instead made me write this very different code:<br /><pre><code><br />                MOV     EBX,MASK1<br />                MOV     EAX,MASK2<br />                CMP     ECX,32            ; ECX is a 0..63 index<br />                CMOVC   EAX,EBX<br />                BT      EAX,ECX<br />                JC      .notvalid<br /></code></pre><br />64 iterations of which on my Athlon runs at an average of 2.000 cycles per iteration.<br /><br /><br />(note that in all 3 cases cycles are referred to the 007E0000007E03FF test mask, but just because it was the first example available).<br /><br /><br />I should make you notice that to check if e.g. a char is alphanumeric using your method (with e.g. n masks to cover the whole 0..255 range, or up to where it is required) or Jen's new one based on memory is overkill. Traditional LEA/CMP/Jxx methods (checking for _invalid_ ranges) will be anyway faster, and will have the further advantage to exit maybe at the first *statistically* convenient condition.<br />My post was just about having 64 bit look up tables (because that was the topic, and I wrote my post after seeing Jens's code and The Svin's comments that followed).. and the applications were just examples to explain the technique better. As I said before I wouldn't test for HEX or alphanumeric using this technique, but 64 bit (or 96, etc..) bitmap lookup tables based on registers can be useful elsewhere. So let's not cling on an example, it was just a practical example to explain things better. I wish that our posts weren't read only by me, you and some others.. but that even beginners could fully learn not just to copy n'paste, but how they really work inside, and at an intuitive level. That's why of my dumb-style explanations of things like CMP/LEA, carry flags, SBB, XOR and so on. I may write e.g. an explanation about why the triple XOR trick (to swap variables) work, yet if I write it in a dumbo style and with dumbo examples is just because being understood also by beginners here is our highest goal.</div>
    <div class="meta">Posted on 2002-03-26 19:12:02 by Maverick</div>
   </div>
   <div class="post" id="post-31088">
    <div class="subject"><a href="#post-31088">More about ranges</a></div>
    <div class="body">Hi Maverick,<br />I like your code with BT JC but you have a problem with MASK1,MASK2 and registers..<br />Try to use memory:<br /><br />MASKS dd 0,1,2,3,4,5,6,bla,bla...<br /><br />and <br />	BT , ecx<br />	jnc @invalid</div>
    <div class="meta">Posted on 2002-03-26 19:32:06 by buliaNaza</div>
   </div>
   <div class="post" id="post-31090">
    <div class="subject"><a href="#post-31090">More about ranges</a></div>
    <div class="body"><pre><code><br />.data<br />hexmask dd 0,1FF0000h,7Eh,7Eh,0,0,0,0<br />.code<br />bt  hexmask,edx<br />jnc nothex<br /></code></pre></div>
    <div class="meta">Posted on 2002-03-26 19:37:43 by The Svin</div>
   </div>
   <div class="post" id="post-31091">
    <div class="subject"><a href="#post-31091">More about ranges</a></div>
    <div class="body">Hi buliaNaza :)<br /><br />Yes, when using tables in memory BT is a full featured instruction.<br /><br />Or maybe I didn't get what you really meant?<br /><br />I presented simply a 2 reg based 64 bit method, just because I saw Jens's one and The Svin's reactions to it, and thus I thought it was of big interest to many, possibly.<br /><br />I'd sure use BT straight from (precached) memory in many situations, I never excluded that option ;)  (nor I excluded bitRAKE's one, for the matter.. each solution has its applycations... one should always test all the possible ones on the _real_ problem, and profile to find the best one).</div>
    <div class="meta">Posted on 2002-03-26 19:39:26 by Maverick</div>
   </div>
   <div class="post" id="post-31092">
    <div class="subject"><a href="#post-31092">More about ranges</a></div>
    <div class="body"><div class="quote"><br /><pre><code><br />.data<br />hexmask dd 0,1FF0000h,7Eh,7Eh,0,0,0,0<br />.code<br />bt  hexmask,edx<br />jnc nothex<br /></code></pre> </div><br /><br />I hate to say that.. but if my code took 2.000 cycles per iteration, the above takes (on pre-cached, perfectly aligned, etc.. data) 8.3125 cycles per iteration.<br /><br />I'd use the memory method on considerably bigger than 64 bit tables. My method may be extended beyond 64 bit, of course, up to where it's useful.</div>
    <div class="meta">Posted on 2002-03-26 19:43:13 by Maverick</div>
   </div>
   <div class="post" id="post-31102">
    <div class="subject"><a href="#post-31102">More about ranges</a></div>
    <div class="body">Impressive solution, <strong>Maverick</strong> and as you said, each has its uses.  Your method scales very well on the Athlon, taking a cycle for each dword.<br /><br />Updated macro:<pre><code>; bitmap register lookup<br />reglu MACRO INVLD,min,masks&#58;VARARG<br />	LOCAL y,msk<br /><br />	y = 0 - &#40;min AND -32&#41;<br />	IF &#40;min + y&#41; NE 0<br />		sub ecx, min + y<br />	ENDIF<br /><br />	FOR msk, &lt;&amp;masks&gt;<br />		IF y LE 0<br />			y=0-y<br />			mov eax,msk<br />		ELSE<br />			mov edx,msk<br />			cmp ecx,y<br />			cmovc eax,edx<br />		ENDIF<br />		y = y + 32<br />	ENDM<br />	bt eax,ecx<br />	jnc INVLD<br />ENDM<br /><br />;Example&#58;<br />	reglu @Invalid, 30h, 007E03FFh,007E0000h</code></pre>This only works for the range of masks provided - no testing is done for values greater or less, and you save two cycles over macro above.  Also, 32-bit masks must be in reverse order of above macro.  There is a more optimized way to handle the constants to try and ensure that the SUB/CMP are sign extended bytes and the mask moves to minimize instruction size, but it is harder and I'll hand code it. :tongue:</div>
    <div class="meta">Posted on 2002-03-26 22:51:26 by bitRAKE</div>
   </div>
   <div class="post" id="post-31132">
    <div class="subject"><a href="#post-31132">More about ranges</a></div>
    <div class="body">About my MASK1/MASK2 select on CMP code:<br />On P6 of course the CMOVC method is still the fastest.. but for P5 &amp; Co. change my:<br /><br />change:<br /><pre><code><br />MOV EAX,MASK2<br />CMP ECX,32<br />SBB EBX,EBX<br />AND EBX,MASK1^MASK2 ; MASK1 xor MASK2<br />XOR EAX,EBX <br /></code></pre><br />to:<br /><pre><code><br />CMP ECX,32<br />SBB EBX,EBX<br />MOV EAX,MASK2<br />AND EBX,MASK1^MASK2<br />XOR EAX,EBX<br /></code></pre><br />or<br /><pre><code><br />CMP ECX,32<br />SBB EBX,EBX<br />MOV EAX,MASK2<br />AND EBX,MASK1-MASK2<br />ADD EAX,EBX<br /></code></pre><br />(which is the same thing, but for some may look simpler).<br /><br />The 2nd version will probably pair better on the Pentium, and it's really faster even on the Athlon.</div>
    <div class="meta">Posted on 2002-03-27 06:33:49 by Maverick</div>
   </div>
   <div class="post" id="post-31133">
    <div class="subject"><a href="#post-31133">More about ranges</a></div>
    <div class="body"><div class="quote">I hate to say that.. but if my code took 2.000 cycles per iteration</div> <br />It's OK, Maveric.<br />But I'm again complitly lost, wich your code do mean.<br />Could you give, full example piece of your code checking<br />if Hex.<br />I saw just part of it wich use 64 bit mask, it's not all range of<br />byte, where is the begining?</div>
    <div class="meta">Posted on 2002-03-27 06:33:51 by The Svin</div>
   </div>
   <div class="post" id="post-31135">
    <div class="subject"><a href="#post-31135">More about ranges</a></div>
    <div class="body">With &quot;2nd version&quot; I mean the 2nd and 3rd snippet, i.e. the newer version with instructions order rearranged.<br />The &quot;1st version&quot; is implyed to be my older one.<br /><br />The Svin:<br />Damn me when I made an applicative example on that technique.. it was not really meant to be anything else than an example to see in use the technique.<br /><br />What I really mean is that this is a 64 (or 96, 128, etc..) &quot;bitmap register lookup&quot;, and nothing else. I'm not really discussing of possible applications here, if I did it was just to provide an example. I was only interested offering an equivalent of Jens' code that you and bitRAKE showed to find useful.. the method is a generic bitmap register lookup table, the applications are up to you.<br /><br />About &quot;ISHEX?&quot; serious code.. well.. personally I wouldn't even check if a string is HEX, lowercase or uppercase.<br />I'd just make sure that the conversion routine already gets all upperacase chars, for example. But here we're really going off topic.<br /><br />If I wrote and showed my simple routine is just because you and bitRAKE said you'd have other uses for that than a simple HEX validity check.<br /><br />Mine was just meant as a generic contribution, the applications or special optimizations are up to you.. I just showed an algorithm and an implementation.. but unfortunately also a bad applicative example.<br /><br />I believe there are a lot of various uses for this algorithm.</div>
    <div class="meta">Posted on 2002-03-27 06:43:15 by Maverick</div>
   </div>
   <div class="post" id="post-31141">
    <div class="subject"><a href="#post-31141">More about ranges</a></div>
    <div class="body">That means that th code you compared can not be compared.<br />One checks 256 possibility range the other 64 possibilities.<br />In PMMX btw your profile shows 5 ticks for bt memory version.</div>
    <div class="meta">Posted on 2002-03-27 07:26:48 by The Svin</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=4419&amp;page=1" style="">&laquo;</a><a href="../?id=4419&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="4419" /><input type="number" name="page" min="1" max="5" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=4419&amp;page=4">&gt;</a><a href="../?id=4419&amp;page=5">&raquo;</a></form>  </div>
 </body>
</html>