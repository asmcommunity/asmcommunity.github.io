<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>String pattern match - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17089" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=17089">String pattern match</a></p>
   <div class="post" id="post-132539">
    <div class="subject"><a href="#post-132539">String pattern match</a></div>
    <div class="body">Easy pattern matching function. Example:<br /><br />--------<br /><strong>Pattern</strong> = &quot;% is % and %&quot;<br /><strong>TestString</strong> = &quot;John is a man and he is single&quot;<br />Function returns: &quot;<strong>TRUE</strong>&quot; <br /><strong>String1</strong> = &quot;John&quot;<br /><strong>String2</strong> = &quot;a man&quot;<br /><strong>String3</strong> = &quot;he is single&quot;<br />---------<br /><br /><strong>Usage:</strong><br />local str1[100]:byte,str2[100]:byte,str3[100]:byte<br />invoke MatchPattern,CTEXT(&quot;John is a man and he is single&quot;),CTEXT(&quot;% is % and %&quot;),addr str1,addr str2,addr str3<br />Notes: <br /> - Unlimited number of output strings. Add an address of 0 to mark explicit end. <br /> - Case sensitive<br /><br />Marking an explicit end:<br />invoke MatchPattern,.........,addr str3<strong>,0</strong><br /><br /><pre><code>	<br />MatchPattern proc C uses ebx ecx edx esi edi StringInput,FormatString,str1&#58;VARARG<br />	local phase<br />	;----&#91; prepare stuff &#93;----------\<br />	mov phase,0<br />	mov edi,str1<br />	mov esi,StringInput<br />	mov ebx,FormatString<br />	;-------------------------------/<br />	<br />	<br /> _again&#58;<br />	xor edx,edx<br />	.while byte ptr&#91;ebx+edx&#93;!=0 &amp;&amp; byte ptr&#91;ebx+edx&#93;!=&quot;%&quot;<br />		inc edx<br />	.endw<br />	or edx,edx<br />	jz @F<br />	invoke uArrayCmp,ebx,esi,edx<br />	or eax,eax<br />	jnz _ret<br />	add ebx,edx<br />	add esi,edx<br />	@@&#58;<br />	.if byte ptr&#91;ebx&#93;==0<br />		cmp byte ptr&#91;esi&#93;,0<br />		je  _good<br />		jmp _ret<br />	.endif<br />	<br />	; now I have &quot;%&quot; at &#91;ebx&#93;<br />	inc ebx<br />	xor edx,edx<br />	.while byte ptr&#91;ebx+edx&#93;!=0 &amp;&amp; byte ptr&#91;ebx+edx&#93;!=&quot;%&quot;<br />		inc edx<br />	.endw<br />	.if !edx<br />		.if edi<br />			.while byte ptr&#91;esi&#93;<br />				mov al,&#91;esi&#93;<br />				mov &#91;edi&#93;,al<br />				inc esi<br />				inc edi<br />			.endw<br />			mov byte ptr&#91;edi&#93;,0<br />		.endif<br />		jmp _good<br />	.endif<br />	invoke uArrayFind,esi,ebx,edx<br />	or eax,eax<br />	jz _ret<br />	dec eax<br />	.if edi<br />		.while eax<br />			mov cl,&#91;esi&#93;<br />			mov &#91;edi&#93;,cl<br />			dec eax<br />			inc esi<br />			inc edi<br />		.endw<br />                                mov byte ptr&#91;edi&#93;,0<br />	.else<br />		add esi,eax<br />	.endif<br />	.if edi<br />		inc phase<br />		mov edi,phase<br />		mov edi,str1&#91;edi*4&#93;<br />	.endif<br />	jmp _again<br />	<br />	<br /> _good&#58;	mov eax,1<br />	ret<br />_ret&#58;	xor eax,eax<br />	ret<br />MatchPattern endp	<br /></code></pre><br />The helper funcs:<br /><pre><code><br />uArrayCmp proc uses ebx ecx edx str1,str2,LenI<br />	mov ecx,str1<br />	mov edx,str2<br />	xor eax,eax<br />	cmp LenI,0<br />	je _ret<br />_again&#58;<br />	mov al,&#91;ecx&#93;<br />	mov bl,&#91;edx&#93;<br />	inc ecx<br />	inc edx<br />	dec LenI<br />	sub al,bl<br />	jnz _ret<br />	cmp LenI,0<br />	jne _again<br /> _ret&#58;	movsx eax,al<br />	ret<br />uArrayCmp endp<br />	<br />	<br />uArrayFind proc uses ebx ecx edx esi edi Where,What,LenI<br />	mov esi,Where<br />	mov edi,What<br />	cmp byte ptr&#91;edi&#93;,0<br />	je _ret<br />	cmp LenI,0<br />	je _ret<br />	mov edx,LenI<br /> _again&#58;<br />	mov al,&#91;esi&#93;<br />	mov bl,&#91;edi&#93;<br />	or edx,edx<br />	jz _good<br />	or al,al<br />	jz _ret<br />	inc esi<br />	inc edi<br />	dec edx<br />	.if al!=bl<br />	 sub edi,What<br />	 sub esi,edi<br />	 mov edi,What<br />	 inc esi<br />	 mov edx,LenI<br />	.endif<br />	jmp _again<br /> _good&#58;<br />	sub edi,What<br />	sub esi,Where<br />	sub esi,edi<br />	mov eax,esi<br />	inc eax<br />	ret<br />  _ret&#58; xor eax,eax<br />	ret<br />uArrayFind endp<br /></code></pre><br /><br /><br />keywords: pattern match regexp regular expressions $1</div>
    <div class="meta">Posted on 2004-02-04 14:08:37 by Ultrano</div>
   </div>
   <div class="post" id="post-134106">
    <div class="subject"><a href="#post-134106">String pattern match</a></div>
    <div class="body"><strong>Ultrano</strong>, You may find the following code of interest:  <a target="_blank" href="http://ghettographics.org/mpr/hacks/mgrep.c.txt"> mgrep</a></div>
    <div class="meta">Posted on 2004-02-18 19:42:18 by Poimander</div>
   </div>
  </div>
 </body>
</html>