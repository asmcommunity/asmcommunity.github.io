<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Console App - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29245" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29245">Console App</a></p>
   <div class="post" id="post-206577">
    <div class="subject"><a href="#post-206577">Console App</a></div>
    <div class="body">I use multiple instances of a console program to interact with a server. I have automated many of the tasks with scripts. While these scripts are executing, lots of flicker and all the text is scrolling down the screen. I execute the app from withwin my program via shell. Is it possible to run a console program in a invisible window?<br /><br />your suggestions are very appreciated :shock:<br /><br />Klod<br /></div>
    <div class="meta">Posted on 2008-12-28 18:40:53 by Klod</div>
   </div>
   <div class="post" id="post-206601">
    <div class="subject"><a href="#post-206601">Re: Console App</a></div>
    <div class="body">The code and ideas you&#039;re searching for are inside this proc:<br /><pre><code><br />BatchProcess proc uses ebx ecx edx FormatString<br />	local hRead,hWrite,bytesRead,thisProcess,HasErrors,HasWarnings<br />	local startupinfo:STARTUPINFO,pinfo:PROCESS_INFORMATION,sat:SECURITY_ATTRIBUTES<br />	local buffer[1024]:byte<br />	<br />	invoke ShowCompilationWindow<br />	mov HasErrors,0<br />	mov HasWarnings,0<br />	<br />	mov ecx,FormatString<br />	.while byte ptr<br />		.if word ptr==&quot;1%&quot;<br />			mov word ptr,&quot;s%&quot;<br />		.endif<br />		inc ecx<br />	.endw<br />	invoke wsprintf,addr buffer,FormatString,addr ProjectName,addr ProjectName,addr ProjectName<br />	;---------[ check if it&#039;s to copy file ]-----------------------------\<br />	lea eax,buffer<br />	.if dword ptr==&#039;ypoc&#039; &amp;&amp; byte ptr==32 ; if command begins with &quot;copy &quot;<br />		add eax,5<br />		.while byte ptr &amp;&amp; byte ptr!=32<br />			inc eax<br />		.endw<br />		.if byte ptr==0<br />			msgbox &quot;File copy no destination specified!&quot;<br />			mov HasErrors,1 ; no destination specified<br />			jmp _done<br />		.endif<br />		mov byte ptr,0<br />		inc eax<br />		<br />		invoke CopyFile,addr buffer[5],eax,0<br />		.if !eax<br />			print &quot;Could not copy file&quot;<br />		.endif<br />		<br />		jmp _done<br />	.endif<br />	;------------------------------------------------------------------/<br />	<br />	<br />	mov sat.nLength,sizeof SECURITY_ATTRIBUTES<br />	mov sat.lpSecurityDescriptor,NULL<br />	mov sat.bInheritHandle,TRUE<br />	invoke CreatePipe,addr hRead,addr hWrite,addr sat,NULL<br />	.if eax==NULL<br />		msgbox &quot;Can&#039;t create pipe. Reboot PC!&quot;<br />		xor eax,eax<br />		ret<br />	.endif<br />	mov startupinfo.cb,sizeof STARTUPINFO<br />	invoke GetStartupInfo,addr startupinfo<br />	mov eax,hWrite<br />	mov startupinfo.hStdOutput,eax<br />	mov startupinfo.hStdError,eax<br />	mov startupinfo.dwFlags,STARTF_USESHOWWINDOW+STARTF_USESTDHANDLES<br />	mov startupinfo.wShowWindow,SW_HIDE<br />	;invoke MessageBox,hwndEdit,addr buffer,addr ProjectName,0<br />	invoke CreateProcess,0,addr buffer,0,0,1,HIGH_PRIORITY_CLASS,0,0,addr startupinfo,addr pinfo<br />	mov thisProcess,eax<br />	.if !eax<br />		invoke wsprintf,addr buffer,CTEXT(&quot;can&#039;t execute this command:&quot;,13,10,&quot;%s&quot;),FormatString<br />		invoke MessageBox,hwndEdit,addr buffer,CTEXT(&quot;Batch compilation error&quot;),MB_ICONERROR<br />		xor eax,eax<br />		ret<br />	.endif<br />	invoke CloseHandle,hWrite<br />	.while TRUE<br />		lea edi,buffer<br />		mov ecx,1024/4<br />		xor eax,eax<br />		rep stosd<br />		invoke ReadFile,hRead,addr buffer,1023,addr bytesRead,0<br />		.if eax==NULL<br />			invoke SendMessage,compWin_hWnd,EM_SETSEL,-1,0<br />			invoke SendMessage,compWin_hWnd,EM_REPLACESEL,0,CTEXT(13,10)<br />			invoke SendMessage,compWin_hWnd,EM_SETSEL,-1,0<br />			.break<br />		.else<br />			invoke uInStrI,addr buffer,CTEXT(&quot;error&quot;)<br />			.if eax<br />				mov HasErrors,1<br />			.endif<br />			invoke uInStrI,addr buffer,CTEXT(&quot; warning &quot;)<br />			.if eax<br />				mov HasWarnings,1<br />			.endif<br />			invoke SendMessage,compWin_hWnd,EM_SETSEL,-1,0<br />			invoke SendMessage,compWin_hWnd,EM_REPLACESEL,0,addr buffer<br />		.endif<br />	.endw<br />	invoke CloseHandle,hRead<br />	<br /> _done:<br />	.if !HasErrors &amp;&amp; !HasWarnings<br />		invoke ShowWindow,compWin_hWnd,SW_HIDE<br />	.endif<br />	mov eax,HasErrors<br />	xor eax,1<br />	ret<br />BatchProcess endp<br /></code></pre><br />Basically, you use CreatePipe, and send this for the app to write into or read from. </div>
    <div class="meta">Posted on 2008-12-30 05:32:37 by Ultrano</div>
   </div>
   <div class="post" id="post-206602">
    <div class="subject"><a href="#post-206602">Re: Console App</a></div>
    <div class="body">Here&#039;s a standalone proc in C, that retrieves text, outputtedin stdout and stderr from a program you execute<br /><pre><code><br />char* uSysExecute2(const char* pExeName,const char* params){<br />	SECURITY_ATTRIBUTES sat = {sizeof(SECURITY_ATTRIBUTES),0,true};<br />	HANDLE hRead,hWrite;<br />	if(!CreatePipe(&amp;hRead,&amp;hWrite,&amp;sat,0)){<br />		print(&quot;no pipe&quot;);<br />		return 0;<br />	}<br />	STARTUPINFO info;<br />	info.cb=sizeof(info);<br />	GetStartupInfo(&amp;info);<br />	info.hStdOutput=hWrite;<br />	info.hStdError=hWrite;<br />	info.dwFlags=STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;<br />	info.wShowWindow=SW_HIDE;<br />	PROCESS_INFORMATION pinfo;<br />	char* cmdline = ustrmix(pExeName,&quot; &quot;,params);<br />	if(!CreateProcess(0,cmdline,0,0,1,NORMAL_PRIORITY_CLASS,0,0,&amp;info,&amp;pinfo)){<br />		prints(&quot;Error executing process:&quot;);<br />		prints(cmdline);<br />		xfree(cmdline);<br />		return 0;<br />	}<br />	xfree(cmdline);<br />	CloseHandle(hWrite);<br />	<br /><br />	char* result=(char*)xmalloc(1); int resultLen=0;<br />	char tmp[512];<br />	<br />	for(;;){<br />		DWORD numbytes;<br />		memclear(tmp,sizeof(tmp));<br />		if(!ReadFile(hRead,tmp,sizeof(tmp)-1,&amp;numbytes,0))break;<br />		int tmplen = ustrlen(tmp);<br />		result = (char*)xresize(result,resultLen+tmplen+1);<br />		ustrcpy(result+resultLen,tmp);<br />		resultLen+=tmplen;<br />	}<br />	CloseHandle(hRead);<br />	return result;<br />}<br /></code></pre></div>
    <div class="meta">Posted on 2008-12-30 05:34:39 by Ultrano</div>
   </div>
   <div class="post" id="post-206607">
    <div class="subject"><a href="#post-206607">Re: Console App</a></div>
    <div class="body">Hi Ultrano<br />Thanks for your reply<br />This should be enough to to send me down the right path. I will have to brush up on pipes, since its quite some time that I played around with it.<br /><br />Thanks<br />Klod<br /></div>
    <div class="meta">Posted on 2008-12-30 19:52:48 by Klod</div>
   </div>
  </div>
 </body>
</html>