<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Waiting, blocking, scheduling - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=28732" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=113">Low Level Concepts</a> &raquo; <a href="../?id=28732">Waiting, blocking, scheduling</a></p>
   <div class="post" id="post-202995">
    <div class="subject"><a href="#post-202995">Waiting, blocking, scheduling</a></div>
    <div class="body">(following up from <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=28730">this thread</a>)<br /><br /><div class="quote"><br />One more thing to note is that the &quot;WaitForSingleObject&quot; locks the calling thread until the event object&#039;s state is changed to &quot;signalled&quot;. Instead of that, I think, depending on your needs, it is better to create an event object using the &quot;CreateEvent&quot; Win32 API. Then create a thread using the &quot;CreateThread&quot; Win32 API and check the state of that event with the &quot;WaitForSingleObject&quot; with really small values for its time-out. Then you will have a running program while the other process is running.<br /></div><br /><br />That would be silly, XCHG, and almost as bad as the typical <span class="strike">hutch</span>hacky code that polls GetExitCodeProcess...<br /><br />Either you WaitForSingleObject on pi.hProcess and block until the process is done (works great, no CPU usage, etc.) or you use MsgWaitForMultipleObjects if you don&#039;t want to block your messageloop (I think edgar/donkey has an example of that somewhere).<br /></div>
    <div class="meta">Posted on 2007-09-20 08:09:18 by f0dder</div>
   </div>
   <div class="post" id="post-203002">
    <div class="subject"><a href="#post-203002">Waiting, blocking, scheduling</a></div>
    <div class="body"><div class="quote"><br />That would be silly, XCHG<br /></div><br /><br />Why exactly would that be silly? How do you think Windows handles events? It creates a separate thread, not accessible/visible to the programmer, to watch the state of a certain event handle.</div>
    <div class="meta">Posted on 2007-09-20 14:34:48 by XCHG</div>
   </div>
   <div class="post" id="post-203003">
    <div class="subject"><a href="#post-203003">Waiting, blocking, scheduling</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br />That would be silly, XCHG<br /></div><br /><br />Why exactly would that be silly? How do you think Windows handles events? It creates a separate thread, not accessible/visible to the programmer, to watch the state of a certain event handle.<br /></div><br />Have a look at &quot;Windows Internals&quot; (formerly known as &quot;Inside Windows 2000&quot;), and/or any decent book on OS/kernel internals... trust me, it doesn&#039;t do it the way you&#039;re saying :)<br /><br />The short version: when you <strong>Wait</strong> on an object, the thread is removed from the ready-list, and thus takes no CPU time, it isn&#039;t even <strong>considered</strong> for scheduling. The thread is also added to a &quot;waiter list&quot; for the object it&#039;s <strong>Wait</strong>ing on. Whenever the object is &quot;ready&quot; or &quot;triggered&quot;, the threads on the waiter-list are awakened again (unless of course they&#039;re waiting for multiple objects with waitall=true).<br /></div>
    <div class="meta">Posted on 2007-09-20 16:32:01 by f0dder</div>
   </div>
   <div class="post" id="post-203009">
    <div class="subject"><a href="#post-203009">Waiting, blocking, scheduling</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br /><div class="quote"><br />That would be silly, XCHG<br /></div><br /><br />Why exactly would that be silly? How do you think Windows handles events? It creates a separate thread, not accessible/visible to the programmer, to watch the state of a certain event handle.<br /></div><br />Have a look at &quot;Windows Internals&quot; (formerly known as &quot;Inside Windows 2000&quot;), and/or any decent book on OS/kernel internals... trust me, it doesn&#039;t do it the way you&#039;re saying :)<br /><br />The short version: when you <strong>Wait</strong> on an object, the thread is removed from the ready-list, and thus takes no CPU time, it isn&#039;t even <strong>considered</strong> for scheduling. The thread is also added to a &quot;waiter list&quot; for the object it&#039;s <strong>Wait</strong>ing on. Whenever the object is &quot;ready&quot; or &quot;triggered&quot;, the threads on the waiter-list are awakened again (unless of course they&#039;re waiting for multiple objects with waitall=true).<br /><br /></div><br /><br />So quoting you, Windows does NOT create a thread to watch over the state of an event object. What is important now is: how does Windows realize whether the the state of an event object is &quot;signalled&quot; or not?<br /><br />About the &quot;short version&quot;: I don&#039;t think I was even discussing the program&#039;s calling thread! I was talking about the threads created by the Windows OS to watch on the state of event objects.</div>
    <div class="meta">Posted on 2007-09-21 02:51:20 by XCHG</div>
   </div>
   <div class="post" id="post-203010">
    <div class="subject"><a href="#post-203010">Waiting, blocking, scheduling</a></div>
    <div class="body"><div class="quote"><br />how does Windows realize whether the the state of an event object is &quot;signalled&quot; or not?<br /></div><br />Simple, once the event goes into &quot;signalled&quot; state, the threads on the object&#039;s waiter-list are awakened. There&#039;s no &quot;continuousl monitoring&quot; going on, the code responsible for signalling an event also wakes up the listeners.<br /><br />Since different object types are signalled due to different events, there&#039;s a lot of places in the kernel that&#039;s responsible for this code... <br /><br />Anyways, &quot;Inside Windows 2000&quot; chapter 3, the <strong>synchronization</strong> part, describes this all very well (and a lot better than I can ;)). Bottom line is, no, there&#039;s no hidden threads or other voodoo.<br /><br />A very basic example would be calling SetEvent - in this case, it&#039;s basically the kernel mode version of SetEvent that&#039;s responsible for waking up the waiting threads.</div>
    <div class="meta">Posted on 2007-09-21 04:46:23 by f0dder</div>
   </div>
   <div class="post" id="post-203011">
    <div class="subject"><a href="#post-203011">Waiting, blocking, scheduling</a></div>
    <div class="body">With the &quot;SetEvent&quot; Win32 API, the programmer is setting the state of an event object to &quot;signalled&quot; and that will obviously give the Windows OS an opportunity to see the list of waiting threads for the thread that is the owner of a specific event object.<br /><br />However, with &quot;WaitForSingleObject&quot;, you are NOT doing anything and Windows has to wait until the state of an event object is set to &quot;signalled&quot; in the given time-out. So how do you justify this whole &quot;waiting&quot;? According to your posts, it happens &quot;magically&quot; and Windows, just out of the blue, notices that the state of an event has been set to &quot;signalled&quot;. I don&#039;t know if it is just me or... but I don&#039;t buy that. Windows, either way, should set up a mechanism to check on the state of event objects associated with a thread. Now it will set up another thread to watch over those; it can check those in its IRQ0 handler; it might do it with periodic interrupts or perhaps something else but the bottom line is that it <strong>must</strong> check on the state of event handles associated with a thread periodically in order to detect the change in their state.<br /><br />About voodoos and such; everybody knows that Windows is full of these tricks. The GUI is literally hardwired into the OS. What sane OS does that? I am not trying to raise a flame war here; so I guess it&#039;d be better for you to lock this thread or shoot me in the head&nbsp; :P</div>
    <div class="meta">Posted on 2007-09-21 06:01:28 by XCHG</div>
   </div>
   <div class="post" id="post-203012">
    <div class="subject"><a href="#post-203012">Waiting, blocking, scheduling</a></div>
    <div class="body">It&#039;s by no means magic, it&#039;s simply a decently designed scheduler :)<br /><br />The scheduler schedules threads. Threads can be in various states, like &quot;running&quot;, &quot;ready to run&quot;, &quot;waiting&quot;. It has the concept of a &quot;ready-list&quot;, which (surprisingly enough :P) is a list of threads that are ready to run. If your thread isn&#039;t on a the ready-list, it&#039;s not even <strong>considered</strong> for scheduling, and thus uses no CPU time.<br /><br />A threads that is waiting is moved off the ready-list. Waitable objects have a list of threads that are waiting on them, and the thread is of course added to that list. Once a waitable object is triggered (how it&#039;s triggered depends on the type of object), this list is processed, and threads are moved back to the ready-list if they aren&#039;t waiting on other objects as well.<br /><br />Of course if a time-out is set for the wait, there <strong>will</strong> be some periodic checking to see if the time-out has elapsed, initiated by the timer IRQ, no way to avoid that, obviously... but the time spent doing this is minimal compared to a typical polling approach. And waits without timeouts are used often, too (GetMessage, ReadFile, ...).<br /><br />Now, the beautiful thing is that (apart from timeout checking of course) there isn&#039;t any &quot;monitoring of events&quot; going on. Consider waiting on a process or thread - those waitable objects are triggered as part of process and thread termination, respectively. <br /><br />Of course some events get triggered as the result of an interrupt or other interaction; ie., a console input event is usually because mouse or keyboard input. A waitable timer of course depends on a timer IRQ. But this is triggered via interrupts, not by polling (in your words: &quot;<em>check<strong></strong> on the state of event handles associated with a thread periodically</em>&quot;).<br /><br />Again, check out Windows Internals, it explains it better than I can... it&#039;s hard to explain it short anyway, because there&#039;s so many interlocking aspects: scheduling, synchronization, object management, etc.<br /></div>
    <div class="meta">Posted on 2007-09-21 06:42:45 by f0dder</div>
   </div>
   <div class="post" id="post-203014">
    <div class="subject"><a href="#post-203014">Re: Waiting, blocking, scheduling</a></div>
    <div class="body">Further reading for XCHG, with definite timing-results:<br />http://www.asmcommunity.net/board/index.php?topic=25803.0</div>
    <div class="meta">Posted on 2007-09-21 14:15:49 by Ultrano</div>
   </div>
   <div class="post" id="post-203053">
    <div class="subject"><a href="#post-203053">Re: Waiting, blocking, scheduling</a></div>
    <div class="body">exact quote :) :<br /><br />&quot;blabla... how will windows know object changed etc... blabla... must look periodically... blabla...wont know it by divine power etc... blabla. word. &quot;&nbsp; :)<br /><br />i think what xchg misses is :<br /><br />how do you think the object gets its state changed in the first place, mmh?<br /><br />short answer: its always windows that changes the state in the first place, so it&#039;s really not very difficult for him to call your crappy callbacks :) at this precise moment without waiting a nanosecond more. makes sense now?<br /><br />-either it&#039;s some other code that triggers the state change: an api call, a routine in the OS that is called subsequently to another action... in this case, i guess windows leaves room at the end of this code (that changes the relevant object&#039;s state) to sequencively call all the userdefined code (ie you callbacks) of the threads that were concerned about this object changing its state. No different threads needed, all is called synchronously.<br /><br />-or it&#039;s changed by some IRQ: user event like keyboard or mouse, or the timer...this is irq code that will be called regardless of everything else. Then i guess windows again leaves room a the end of this code to call your code that was waiting for the object, or (more likely?) will set some flags to later change the state of the relevant objects... which falls back to the first case.<br /><br /><br /><br />i hope it sheds some light.<br /><br />this is closely related to &quot;the minimal amount of multitasking needed to make an OS like this work&quot;, which is only one, i believe. ONE thread for the whole OS, plus the unavoidable hardware IRQs for external events and timer. thats all. The IRQs briefly buffer some bytes and change some flags, and in the background the OS loop, well, loops forever locking these flags and bytes and updates things accordingly. The ONLY need for atomicity is atomicity between the OS and the IRQs. Then if you want you add your first app, that gets a chunk of code executed after the OS loop, then you add another app, etc...<br /><br />of course things likely are more complex than that, the OS loop is itself fragmented in chunks etc...but many threads for the OS alone is theoretically absolutely not needed.<br /><br />fodder, please correct me if i&#039;m wrong :)<br /><br />oh, and having the GUI be run as a server on top of everything else is the damn _best_ way to get a sluggish piece of unresponsive crap under your mouse... yeah you, i&#039;m talking about X/linux here :D ... although i have to admit that the huge amount of processing power today seems to finally have swallowed this sluggishness&nbsp; :)<br /><br />solar os is non-preemptive, and seems to work :)<br />There also was an old OS on acorn processors (i read so) that was nonpreemptive.<br /><br />sigh...<br /><br />all this confusion with polling and multithreading , for many people i guess, is due to the preponderance of unix in the academic fields, and in the teaching of computer science...<br /><br />while thinking in terms of multithread _can_ be nice, doing everything with polling, mutexes, producer/consumer etc... its imho not the right way of doing things, it&#039;s overkill and ignorance of the machine... as long as the hardware doesnt work this way. <br /><br />All these are _abstractions_ offered by the OS, thats all. Oh wait, let&#039;s make two threads that send things to each other through a stack/filo... yeah, right, as if you couldnt _call_a ****ing function! this s also induced by the flat memory model and again the unix concept that threads are isolated, so its just plain a pain the... neck to make them communicate simply so thats why you resort to locking objects and such... and you&#039;ve got to wait for a whole OS loop just to get your data get to the other end.<br /><br />Then, of course where i&#039;m screwed, is when nowadays we&#039;ve got real hardware multiprocessing, all this &quot;nonsense&quot; suddenly comes in very handy because research on atomicity problems, concurrency, deadlocks etc has already been studied :)<br /><br />oh well , that&#039;ll be all for today, kids :) , i think i&#039;ll multitask to something else now :D<br /><br /></div>
    <div class="meta">Posted on 2007-09-25 03:54:43 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-203054">
    <div class="subject"><a href="#post-203054">Re: Waiting, blocking, scheduling</a></div>
    <div class="body">oh, and don&#039;t try and start me up on fork() :D<br /></div>
    <div class="meta">Posted on 2007-09-25 04:04:29 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-203061">
    <div class="subject"><a href="#post-203061">Re: Waiting, blocking, scheduling</a></div>
    <div class="body">Did unix originally even have threads? Took a while before it was implemented on linux afaik, because &quot;our processes are so lightweight we don&#039;t need threads&quot;...<br /></div>
    <div class="meta">Posted on 2007-09-25 07:42:08 by f0dder</div>
   </div>
   <div class="post" id="post-203062">
    <div class="subject"><a href="#post-203062">Re: Waiting, blocking, scheduling</a></div>
    <div class="body">i dont know if unix did have threads... in fact, i never grasped the difference&nbsp; between processes and theeads and i use the two words equally (and i&#039;m wrong) ... well i guess its more or less that threads are different parts of a process that run using the same adress space so they can share data? sounds cool... so what i said about common variables isnt true...that way you could also call shared code? not bad... well i guess i should ve known since i even must have done it in my courses. so what changes when thread switches? just eip?<br /></div>
    <div class="meta">Posted on 2007-09-25 08:01:23 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-203064">
    <div class="subject"><a href="#post-203064">Re: Waiting, blocking, scheduling</a></div>
    <div class="body">ok, i&#039;ve read (some) wikipedia. that&#039;s it : threads share adress space, and as such data seg, code seg, librairies, handles etc.. <br /><br />wht changes in a thread switch is eip, regs and stack seg... no wonder its faster (even if still yuck) than processes, where you&#039;ve got to rape data cache and all page tables... duh! and wikipedia says &quot;on NT/OS2 threads are cheap and processes are expensive, while on other systems theres not much difference... well, i guess that just means on &quot;other systems&quot; the change of page tables is&nbsp; nothing compared to the &quot;base bloat&quot; background noise.<br /></div>
    <div class="meta">Posted on 2007-09-25 10:00:41 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-203066">
    <div class="subject"><a href="#post-203066">Re: Waiting, blocking, scheduling</a></div>
    <div class="body">In OS theory, every active sequential computation is a <strong>process</strong>. So what are called tasks and threads are also processes, as far as theory goes.<br /><br />When processes are implemented in a real OS, isolation of resources becomes formalized, and in Windows, <u>terminology</u> is adjusted to distinguish between raw OS processes that can <strong>freely</strong> share resources (threads), and groups of processes that are isolated somewhat from each other (Windows processes).<br /><br />Vendor specific terminology is not new. What most of us call files are known on one series of mainframes as a dataset, since the 1960s.</div>
    <div class="meta">Posted on 2007-09-25 12:38:19 by tenkey</div>
   </div>
   <div class="post" id="post-203067">
    <div class="subject"><a href="#post-203067">Re: Waiting, blocking, scheduling</a></div>
    <div class="body"><div class="quote"><br />ok, i&#039;ve read (some) wikipedia. that&#039;s it : threads share adress space, and as such data seg, code seg, librairies, handles etc.. <br /></div><br /><br />Yep, the concept of &quot;threads&quot; becomes more clear when you approach OS Development. They are just a name for clearly distinguished routines within a program *space* that have been scheduled for execution.<br /><br />On a side note, properly coded multi-threaded applications can lead to more efficient parallel processing for systems with more than one CPU/Core.<br /><br /><div class="quote"><br />wht changes in a thread switch is eip, regs and stack seg... no wonder its faster (even if still yuck) than processes, where you&#039;ve got to rape data cache and all page tables... duh!<br /></div><br /><br />That assumes a perfect process/thread scheduling scenario. This can change when one process or even one thread blocks. The OS must continue to cycle through processes/threads without wasting *too much* time on excessive scheduling techniques. Unless two threads within the same process are scheduled back-to-back, you will most likely have to go through the fun of trashing the cache and reloading the PDBR.</div>
    <div class="meta">Posted on 2007-09-25 12:38:50 by SpooK</div>
   </div>
   <div class="post" id="post-203069">
    <div class="subject"><a href="#post-203069">Re: Waiting, blocking, scheduling</a></div>
    <div class="body"><strong>tenkey:</strong> things have developed and progressed a bit since OS theory was invented back in the dinosaur age ;)<br /><br />In windows terminology, a &quot;process&quot; is basically a container of resources: kernel objects (which can be files, sockets, pipes, mutexes, etc.), a memory space, and thread(s).<br /><br />A thread has a thread context, which includes the CPU registers &quot;and some other stuff&quot;, and each thread has it&#039;s own stack.<br /></div>
    <div class="meta">Posted on 2007-09-25 16:03:30 by f0dder</div>
   </div>
   <div class="post" id="post-203073">
    <div class="subject"><a href="#post-203073">Re: Waiting, blocking, scheduling</a></div>
    <div class="body">For once, I can&#039;t complain about &#039;progress&#039; - I think these are natural evolutions, and are robust and well-defined concepts, things I don&#039;t normally associate with Bill$oft</div>
    <div class="meta">Posted on 2007-09-26 09:02:07 by Homer</div>
   </div>
   <div class="post" id="post-203087">
    <div class="subject"><a href="#post-203087">Re: Waiting, blocking, scheduling</a></div>
    <div class="body"><div class="quote"><br />Did unix originally even have threads? Took a while before it was implemented on linux afaik, because &quot;our processes are so lightweight we don&#039;t need threads&quot;...<br /><br /></div>FreeBSD had threads by 2003 so Unix surely had them before then.&nbsp; Unix did not have threads before 1989.</div>
    <div class="meta">Posted on 2007-09-27 21:02:21 by drhowarddrfine</div>
   </div>
  </div>
 </body>
</html>