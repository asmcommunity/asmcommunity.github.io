<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Should multiple inheritance be implemented? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20682" />
    <link rel="next" href="../?id=20682&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=38">Object Oriented Programming</a> &raquo; <a href="../?id=20682">Should multiple inheritance be implemented?</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=20682&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=20682&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="20682" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=20682&amp;page=2">&gt;</a><a href="../?id=20682&amp;page=2">&raquo;</a></form>   <div class="post" id="post-157610">
    <div class="subject"><a href="#post-157610">Should multiple inheritance be implemented?</a></div>
    <div class="body">Hey guys<br /><br />The question is mainly for the authors of ObjAsm and ATC, but I'd be happy to hear other peoples thoughts on the matter.<br />So lets start with the following questions.<br /><br />1. is multiple inheritance possible with a macro model, or do we need a preprocessor?<br />2. is it a desired feature, or is single inheritance enough?<br />3. and if the interest is there, how do we implement it while maintaining minimal overhead?</div>
    <div class="meta">Posted on 2005-03-02 01:37:35 by Maelstrom</div>
   </div>
   <div class="post" id="post-157613">
    <div class="subject"><a href="#post-157613">With respect to ATC</a></div>
    <div class="body">The response from the JAVA authors I know is generally that multiple inheritance leads to headache and heartache.<br />I have enough of both of these in my day to day life without them spilling over into my programming time (which I consider quality time).<br />If I want to code stuff that uses multiple inheritance, I think I'll use JAVA.<br />That is, if I can think of a valid reason to apply it.<br />Since I cannot for the life of me think of a single situation which warrants multiple inheritance, I'm happy to leave sleeping dogs lie.<br /><br />Can it be implemented using buildtime macros? Yes. Buildtime macros can act as a preprocessor.<br /><br />Should we implement this in ATC? No. ATC was never designed to be that powerful. It was meant to be Light and Fast, which it is.<br /><br />Can you think of a single situation where infinite-depth single inheritance is not capable of doing the job of multiple N-deep inheritance?</div>
    <div class="meta">Posted on 2005-03-02 06:53:47 by Homer</div>
   </div>
   <div class="post" id="post-157616">
    <div class="subject"><a href="#post-157616">Should multiple inheritance be implemented?</a></div>
    <div class="body"><div class="quote"><br />If I want to code stuff that uses multiple inheritance, I think I'll use JAVA.<br /></div><br />I thought one of the design decisions of JAVA was to NOT include multiple inheritance support?<br /><br />The benefit of multiple inheritance is that you can make &quot;mixin&quot; classes - classes that can add functionality without messing up your class hierarchy. So, you can write these mixin classes *once*, and use them with multiple other classes.<br /><br />Probably not very useful in assembly, though :)</div>
    <div class="meta">Posted on 2005-03-02 07:04:07 by f0dder</div>
   </div>
   <div class="post" id="post-157622">
    <div class="subject"><a href="#post-157622">Should multiple inheritance be implemented?</a></div>
    <div class="body"><div class="quote"><div class="quote"><br />If I want to code stuff that uses multiple inheritance, I think I'll use JAVA.<br /></div><br />I thought one of the design decisions of JAVA was to NOT include multiple inheritance support?<br /></div><br />Java includes a limited version of multiple inheritance in the form of Interfaces. It allows your class to implement multiple interfaces, but only allows you to extend (and re-use implementation of) a single base class (or if you like, &quot;super class&quot;).<br /><div class="quote">The benefit of multiple inheritance is that you can make &quot;mixin&quot; classes - classes that can add functionality without messing up your class hierarchy. So, you can write these mixin classes *once*, and use them with multiple other classes.</div><br />That is correct, &quot;mix-in&quot; classes can prove to be a useful design technique. However, it's not the only benefit of multiple-inheritance... I believe it was Grady Booch that said, that multiple-inheritance is like a parachute; you don't need it often, but when you do, you really want to have it. Bertrand Meyer also says that removing (or should I say, limiting) multiple-inheritance from an OO language leads to emulation in ways that are usually inappropriate. Personally, I'm not a Java programmer, so I can't provide my own examples... but in C++ I use it when appropriate and have no issues with it. I think Bjarne Stroustrup makes it most clear why and when multiple-inheritance is needed.<br /><div class="quote">Probably not very useful in assembly, though :)</div><br />IMHO using a paradigm in a language that doesn't support it makes no sense. So I dislike the whole notion of OO in assembly as it exists on this forum.<br /><br />P.S. If anyone wants references to above mentioned opinions of people other than me, just ask.</div>
    <div class="meta">Posted on 2005-03-02 12:42:37 by death</div>
   </div>
   <div class="post" id="post-157628">
    <div class="subject"><a href="#post-157628">Should multiple inheritance be implemented?</a></div>
    <div class="body"><div class="quote">IMHO using a paradigm in a language that doesn't support it makes no sense. So I dislike the whole notion of OO in assembly as it exists on this forum. </div><br /><br />I see languages like languages and techniques like tehniques.<br /><br />I always say and remember that OO and structuerd programming born in diferent days than the high-level languages. Even that this last ones use the technique (insert the technique like reserved word of the language) like a model you will find that some guys dont get how to use some constructions/patterns or models because they dosent understand it, they understand the high-level meaing (like I understand while ... then) but they dont understand the paradigm of structured programming.<br /><br /><br />Also some times you will find that some ones dont get the idea of modelate instructions and modelate data. For example dont get where to put a &quot;for&quot;, then they see see a exampe and use it and say, hey it is working!!!!!!!, then you use such model without understand, but because you know that it works ;).<br /><br /><br /><br /><br />Im not a language expert, but I think that have some ral support in assemblers for OO(objet-oriented), SS(structured programming) or other paradigm should be nice :).<br /><br /><br /><br /><br />Whant a proof that the HLLS dosent implicate x paradigm???, delete while, for, if, case, but you will get the core of the HLL, ie the isntructions that are really part of the language ;), also delete the OO paradigm for example of the resrver words of java and you wll get the core of the language. One thing that all languages have is the secuence (one instruction follow the other at less in the source).<br /><br /><br /><br /><br /><br /><br />I think that there is a missunderstood when is sayed for example that structured progarmming the porpuose is to delete te GOTO statement, while you can still programm in a structured way (we know it, because we know that if use jumps), the point is not to remove the GOTO statement, the porpuose of structured progarmming is have structure in the programms!, is writed in a way of HLL statements (if, while, then,...), but is only a representation of the language (ie the sintaxis).<br /><br /><br /><br /><br />Im not an expert in languages, but is some thing that atrack me, then this  is what I think about the subject ;).</div>
    <div class="meta">Posted on 2005-03-02 13:58:45 by rea</div>
   </div>
   <div class="post" id="post-157634">
    <div class="subject"><a href="#post-157634">Should multiple inheritance be implemented?</a></div>
    <div class="body">Hey guys<br /><br />Keep the opinions coming, I'd still like to hear from NaN, Biterider, and Ultrano.</div>
    <div class="meta">Posted on 2005-03-02 15:06:09 by Maelstrom</div>
   </div>
   <div class="post" id="post-157635">
    <div class="subject"><a href="#post-157635">Should multiple inheritance be implemented?</a></div>
    <div class="body">Hello rea.<br /><br />I didn't quite grasp most of what you're trying to say, but I think you're treating a certain 'feature' or 'paradigm support' of a language as a separate part added to the language without considering interaction with other language features. This doesn't work... there aren't any successful languages that have a &quot;feature shopping-list&quot;. One part of the language must interact well, and also support other parts of the language.<br /><br />You also seem to treat such language constructs as 'keywords'. They are not just keywords, but are also concepts. They have semantics, and the syntax is usually over-emphasized (that is not to say syntax is not important... after all, it's what you see on the screen). However, from reading the last paragraph you've written, I think you also realize that a paradigm is really all about concepts. A language supports a paradigm by realizing those concepts into language semantics.<br /><br />Native assembly does not, and should not, IMHO, support these concepts directly. You don't have classes in assembly. You don't have nesting in assembly. Assembly is the building blocks for such support in a higher-level language. After all, what's a higher-level language providing other than a higher-level abstraction?<br /><br /><div class="quote">One thing that all languages have is the secuence (one instruction follow the other at less in the source).</div><br /><br />Well, that's not necessarily true. I have vague idea of things such as dataflow/reduction machines, parallelized-execution languages and perhaps some non-imperative languages might fit in as well.<br /><br /><div class="quote">I think that there is a missunderstood when is sayed for example that structured progarmming the porpuose is to delete te GOTO statement, while you can still programm in a structured way (we know it, because we know that if use jumps), the point is not to remove the GOTO statement, the porpuose of structured progarmming is have structure in the programms!, is writed in a way of HLL statements (if, while, then,...), but is only a representation of the language (ie the sintaxis).</div><br /><br />There is a difference between an OO language and a language supporting OO. C++ for example, is not an OO language. Java is. C++ actually supports four (as I see it) different paradigms directly, which can all be used in a valid way. Those are C-esque, Abstract Data Typing, Object Orientation and Generic Programming. Some times, these paradigms support each other, and other times, they don't. A good C++ programmer knows how to make them interact well. The same thing can be said for SP; An SP language wouldn't have a GOTO construct. A language supporting SP may have one.</div>
    <div class="meta">Posted on 2005-03-02 15:13:39 by death</div>
   </div>
   <div class="post" id="post-157643">
    <div class="subject"><a href="#post-157643">Should multiple inheritance be implemented?</a></div>
    <div class="body">I understand that a certain paradigm impact the language or is like I see it, becasuse a paradigm is a way to modelate and in such way modelate wath can be modeleted with the paradigm provided.<br /><br /><br /><br />For example we have english, but if you write poetry your style of writing should be influenced a little be the poetry style (you see a paradigm there), altought the langage himself can offer the words for suport that style, the style himself dosent depend in the language (altought I think and near to be sure that write poetry in english is diferent than spanish, but poetry still poetry in any language).<br /><br /><br />I know some languages, but the best example to show that they use techniques is exactly C++ with the same set language (ie. yes, delete the suport of SS and OO) you get the same set, this is the part that interact with such paradigms. If the &quot;core&quot; language (int, bool, +, &amp;, ...), altought some things will be hard to choice if is part of the paradigm or the language.<br /><br /><br /><br />Im separating the paradigm from the language because some times dosent matter that the language try to <em>impose</em> the semantic to use, if te programer dont know the paradigm, is for that Im separating the language from the paradigm, I agree that the language must follow some &quot;specs&quot; for use the paradigm, but certainly when you tallk about OO you are not talking about certain langage, thus OO is not necesary a high level language, is a model/tool.<br /><br /><br />Another proof that certain paradigm not implicate high level language is that there are a lot o HLLs suporting SS or OO. Then the language can be impacted be the paradigm to help in <strong>the</strong> modelation. (correction here  he-&gt;the)<br /><br /><br /><br /><br /><br />Another proof that HLL dosent implicate the paradigm is that a new comer to the language dosent matter that have a nice sintaxis to follow, ie class name {...}, also dosent matter that have structs/unions or any to modelate data, if the user dosent understand the paradigm/modelation, he/she will not able to use the HLL, is for that I put before the example about the &quot;for&quot; and a array, that they know where to use, but dont know why (they have watched and example and know to use the example but dont get how the modelation of data impact the modelation of instructions and viceversa)..... <br /><br />Following that if you know the paradigm should be very easy to switch from one language to other at less that the other language have a very dificult sintaxis or other paradigm implied this last will modificate the way you use the language....<br /><br />Another proof that those paradigms dosent implicate a HLL is that we can write a entire book about the subject without insert a HLL. Altought we should use something for anotate :).<br /><br /><br /><br /><br /><br /><br /><br /><br />And what I have learned/watched from some friends is that they dosent know/see where start the language definition and semantic of the language ad where start the paradigm, is for that some people dont get if divide a function in subfunctions, put a array, traverse the structure, .....<br /><br /><br /><br /><br />By the way, because the paradigm serves more to modelate is for that some people doesnt know how to programm, even that they can understand the sintaxis of the language and sometimes the intrinsic semantic of such language (the core) ie, like where to put locals and his scope..... that are the more clear or easy semantics (altought dont know if you can consider this some part of the semantic of the language) that I can see from the language himself, but the paradigm have his own semantic not related to the language himself but how you use the paradigm for get a final modelation.<br /><br /><br /><br /><br /><br />Like you have stated, asm is the &quot;final&quot; end of the compilers (operations and operands ), you consider asm like a suport for get those languages to support SS, OO, procedural, etc. I consider such paradigms only techniques for modelation (even the language can suport or be orientated/specialized). Like that can be used in any language even asm or a secuence of any operation and operand, altought I accept the part that some part of the language must interact nice with the other like a &quot;glue&quot; between the language and the paradigm.<br /><br /><br /><div class="quote">as a separate part added to the language without considering interaction with other language features. </div> I agree with that, but the paradigm dosent depend in the language, depend in himself, the understand (concient/inconcient) of such paradigm will help in design programs in such language, pheraphs more than know the  sintaxis and pheraphs the semantics that are implied.<br /><br /><br /><div class="quote">A language supports a paradigm by realizing those concepts into language semantics. </div><br /><br />I agree, but there is a interesting draw back, the one that I have talked, because the paradigm dosent depend in the langauge himself, and that altought the language have some semantics, the user o te language will haev to suffer in the side of understand the semantics of the language and pheraphs the semantics of the paradigm himself. That is... for example, some one can understand finally what is a local/scope and this is the semantic of the language, but it will cost more to understand where to use locals, I have friends that dosent <strong>practice</strong> much programming, one has been watching when I was doing a programm and say some like &quot;how you can go with writing like that, that is I see that you start in some place and a the next moment you have others functions and the program is nearly working, I cant do that&quot;, by the way, Im sure that this person know the sintaxis of the language and can understand vaguely or pheraphs near to nice the <strong>semantics of the language</strong> (instead of sintaxis), but If Im not wrong is that this person doesnt know the semantics of Structured programming.<br /><br />I see such example other time like a proof that HLL dosent implicate a paradigm and viceversa. The semantics of SS are somewhat &quot;hided&quot; and even that the persons can understand &quot;while&quot; because is clear meaning (altought they are not hided because there is a clear name of a construction but dosent implicate that you will use in the correct way), they hardly will go with more complex constructions because they dosent understand the paradigm. But sometimes happend that is sufficient to understand the semantics of the language, or watch some examples for get the idea and stick with the patern that you have learned.<br /><br /><br />Im sure you use SS in assember, or some of us use it, even that some dosent use .while, .repeat, .if...., remember that is the concept of have structure in the programs, never is talked about a sintaxis for maintain such structure... only is spelled that there should be a easy way to see such structure.... but I think they are not referin<strong>g</strong> to <strong>&quot;</strong>if<strong>&quot;</strong> easely.<br /><br /><br />;), keep in touch.</div>
    <div class="meta">Posted on 2005-03-02 23:08:19 by rea</div>
   </div>
   <div class="post" id="post-157651">
    <div class="subject"><a href="#post-157651">Should multiple inheritance be implemented?</a></div>
    <div class="body"><div class="quote">For example we have english, but if you write poetry your style of writing should be influenced a little be the poetry style (you see a paradigm there), altought the langage himself can offer the words for suport that style, the style himself dosent depend in the language (altought I think and near to be sure that write poetry in english is diferent than spanish, but poetry still poetry in any language).</div><br />Which is an important point. Realizing that poetry is different in English than in Spanish is the key. You can say Smalltalk is an object-oriented language, and you can say Java is an object-oriented language, but writing a Smalltalk-style object-oriented program in Java is not going to work (well).<br /><br /><div class="quote">Im separating the paradigm from the language because some times dosent matter that the language try to <em>impose</em> the semantic to use, if te programer dont know the paradigm, is for that Im separating the language from the paradigm, I agree that the language must follow some &quot;specs&quot; for use the paradigm, but certainly when you tallk about OO you are not talking about certain langage, thus OO is not necesary a high level language, is a model/tool.</div><br />That is partially correct. The general meaning of a paradigm is a point-of-view of how things should be done. I most definitely don't claim that you can't do &quot;object-oriented programming&quot; in assembly, I just claim that it is not worth it 99% of the time. As I said above, what is considered good in one language may not fit well in another language.</div>
    <div class="meta">Posted on 2005-03-03 05:53:34 by death</div>
   </div>
   <div class="post" id="post-157674">
    <div class="subject"><a href="#post-157674">Should multiple inheritance be implemented?</a></div>
    <div class="body">The C++ model of multiple inheritance gives some idea of how a compatible and &quot;efficient&quot; form can be created for ASM. But it feels awkward.<br /><br />I have also looked at the Eiffel model, but that's difficult or impossible to do under a macro system, as it can identify multiple inheritance of the same base class as a single base class.<br /><br />The alternate (Smalltalk) model of inheritance does not use &quot;embedding&quot; or &quot;inlining&quot; of inherited components. It uses delegation, where the object asks another object to handle a method if it doesn't have a definition. Embedding is merely an optimization for this model. I get the impression that those who use such object systems see no need for multiple inheritance.</div>
    <div class="meta">Posted on 2005-03-03 17:44:30 by tenkey</div>
   </div>
   <div class="post" id="post-157681">
    <div class="subject"><a href="#post-157681">Should multiple inheritance be implemented?</a></div>
    <div class="body">The c++ model of multiple inheritance can be quite messy! that's quite one way to do it...</div>
    <div class="meta">Posted on 2005-03-03 22:47:56 by f0dder</div>
   </div>
   <div class="post" id="post-157700">
    <div class="subject"><a href="#post-157700">Should multiple inheritance be implemented?</a></div>
    <div class="body">Hey guys<br /><br />Does anyone have a link or info on how C++ handles OOP?<br /><br /><div class="quote">Can you think of a single situation where infinite-depth single inheritance is not capable of doing the job of multiple N-deep inheritance?</div><br /><br />Not if your creating the object hierarchy from scratch, but it you want to derive from several *existing* classes that you don't want to modify, or can't modify, then the only way to create an object that inherits these classes is multiple inheritance. Correct me if I'm wrong. :-D</div>
    <div class="meta">Posted on 2005-03-04 16:46:21 by Maelstrom</div>
   </div>
   <div class="post" id="post-157701">
    <div class="subject"><a href="#post-157701">Should multiple inheritance be implemented?</a></div>
    <div class="body">Obviously, MI can be emulated, like most anything else... The question is why prefer manual emulation to direct support?<br /><br />For information on how some C++ implementations implement the object model, there's a great (but a bit out-dated) book by Lippman - &quot;Inside The C++ Object Model&quot;. Some parts of it are not an easy read.<br /><br />C++ doesn't enforce this model. From C++ point of view, there are no such things as vtbl or vptr... but I guess it's the de-facto standard (with many little deviations, but the concept is standard).</div>
    <div class="meta">Posted on 2005-03-04 17:18:04 by death</div>
   </div>
   <div class="post" id="post-157702">
    <div class="subject"><a href="#post-157702">Should multiple inheritance be implemented?</a></div>
    <div class="body"><div class="quote">Does anyone have a link or info on how C++ handles OOP?</div><br /><a target="_blank" href="http://msdn.microsoft.com/library/en-us/vclang98/HTML/pluslang.asp?frame=true">Try here</a></div>
    <div class="meta">Posted on 2005-03-04 17:44:13 by drhowarddrfine</div>
   </div>
   <div class="post" id="post-157704">
    <div class="subject"><a href="#post-157704">Should multiple inheritance be implemented?</a></div>
    <div class="body"><div class="quote"><div class="quote">Can you think of a single situation where infinite-depth single inheritance is not capable of doing the job of multiple N-deep inheritance?</div><br /><br />Not if your creating the object hierarchy from scratch, but it you want to derive from several *existing* classes that you don't want to modify, or can't modify, then the only way to create an object that inherits these classes is multiple inheritance. Correct me if I'm wrong. :-D</div><br /><br />You can create a new hierarchy and hide the old object classes behind proxy objects. Less efficient, but it still allows reuse of existing code. You can even call these proxy objects &quot;interfaces&quot;.<br /><br />I'm pretty much a fan of aggregation in most forms of &quot;derivation&quot;. Where inheritance makes most sense to me, so far, is in separating interface (abstract class with zero code) from implementation, and in shallow frameworks which provide subroutine callback &quot;hooks&quot; and basic services through inheritance.</div>
    <div class="meta">Posted on 2005-03-04 18:50:17 by tenkey</div>
   </div>
   <div class="post" id="post-157706">
    <div class="subject"><a href="#post-157706">Should multiple inheritance be implemented?</a></div>
    <div class="body">Hey guys<br /><br /><strong>tenkey</strong><br />Do you mean something like what DX does to support previous versions?<br /><br /><strong>drhowarddrfinedrhoward</strong><br />Thanks for the link but I was looking for how C++ constructs an object in memory, I should have been more specific.<br /><br /><strong>death</strong><br />Thanks, the book sounds like it contains what I was looking for.</div>
    <div class="meta">Posted on 2005-03-04 19:48:53 by Maelstrom</div>
   </div>
   <div class="post" id="post-157710">
    <div class="subject"><a href="#post-157710">Should multiple inheritance be implemented?</a></div>
    <div class="body">When I was coding ATC, I thought a bit about this matter, but since I saw no-one uses it, the ratio usefulness/effort is 0. So, I didn't bother to implement it, and I won't. But since you all are interested how this stuff looks in memory and code, below's an example. All the functions are virtual, so that I show the most complex form of the layout with 3 classes. If all functions were normal (&quot;void&quot; in ATC), it would be easier - remove the vTables, calling is direct... and well - you get scalar programming.<br /><br /><pre><code><br />;Foreword&#58; &quot;one&quot; and &quot;two&quot; must not know and care what derived <br />;classes like &quot;three&quot; do. So, &quot;three&quot; has to do all the fun. <br />;I'll skip the &quot;C++ compatible&quot; keyword at three places here,<br />;for clarity<br /><br /><br />class one<br />	virtual f1<br />	virtual f2<br />	long x1<br />	long x2<br />endclass<br />class two<br />	virtual f3<br />	virtual f4<br />	long y1<br />	long y2<br />endclass<br /><br />class three,one+two ; derive from both, order matters<br />	virtual f5<br />	long z1<br />	long z2<br />endclass<br /><br />;================&#91; AUTOMATICALLY CREATED BY ATC &#93;=======================\<br />one_vTable&#58;<br />	dd one_destructor<br />	dd one_f1<br />	dd one_f2<br /><br />two_vTable&#58;<br />	dd two_destructor<br />	dd two_f3<br />	dd two_f4<br /><br />three_vTable1&#58;<br />	dd three_destructor<br />	dd one_f1<br />	dd one_f2<br />	dd three_f5<br />three_vTable2&#58;<br />	dd three_destructor2<br />	dd two_f3<br />	dd two_f4<br /><br /><br /><br /><br />three struct<br />	vTable1		dd ?<br />	x1		dd ?<br />	x2		dd ?<br />	<br />	vTable2		dd ?<br />	y1		dd ?<br />	y2		dd ?<br />	<br />	z1		dd ?<br />	z2		dd ?<br />three ends<br /><br /><br /><br /><br /><br /><br />three_constructor proc ; ECX is _this<br />	;----&#91; call constructors &#93;---------------------------\<br />	push ecx<br />	call one_one<br />	pop  ecx<br />	<br />	push ecx<br />	add ecx,12 ; from this offset, the object data of two begins<br />	; why 12 ? because we have the dwords vTable1+x1+x2 at offset 0<br />	call two_two	; &quot;two&quot; doesn't know anything about the outside world<br />	pop ecx<br />	;----------------------------------------------------/<br />	;-----&#91; update vTable1 and vTable2 &#93;--------------------\<br />	mov &#91;ecx&#93;.three.vTable1,offset three_vTable1<br />	mov &#91;ecx&#93;.three.vTable2,offset three_vTable2<br />	;-------------------------------------------------------/<br />	<br />	;---&#91; finally, call three_three &#93;-------\<br />	push ecx<br />	call three_three<br />	pop ecx<br />	;---------------------------------------/<br />	mov eax,ecx ; EAX should have _this, but I want ECX to have it too in ATC<br />	ret<br />three_constructor endp<br /><br />three_destructor proc IgnorableArgument1&#58;DWORD<br />	push ecx<br />	call three_$three<br />	pop ecx<br />	<br />	push ecx<br />	add ecx,12<br />	call two_$two<br />	pop ecx<br />	<br />	push ecx<br />	call one_$one<br />	pop ecx<br /><br />	free ecx<br />      <br />	ret<br />three_destructor endp<br /><br />three_destructor2 proc IgnorableArgument1&#58;DWORD ; called when &quot;two&quot; tries to commit suicide<br />	sub ecx,12<br />	invoke three_destructor,IgnorableArgument1<br />	ret<br />three_destructor2 endp<br /><br />;=======================================================================/<br /><br />;OK, now let's make some proc in ATCv99 <br />	<br />main proc<br />	local t<br />	set t as three<br />	<br />	mov t,new&#40;three&#41;<br />	<br />	pcall t.f1<br />	pcall t.f2<br />	pcall t.f3<br />	pcall t.f4<br />	pcall t.f5<br />	<br />	mov ecx,t<br />	mov &#91;ecx&#93;.three.z1,7<br />	mov &#91;ecx&#93;.three.z2,8<br /><br />	delete t<br />	ret<br />main endp<br /><br />;The above code will result in&#58;<br /><br />main proc<br />	local t<br />	mov t,malloc&#40;sizeof three&#41;<br />	mov ecx,eax<br />	call three_constructor<br /><br />	<br />	;---&#91; t-&gt;f1&#40;&#41; &#93;--------------\<br />	mov ecx,t<br />	mov eax,&#91;ecx&#93;.three.vTable1<br />	call dword ptr&#91;eax+4&#93;<br />	;----------------------------/<br />	<br />	;---&#91; t-&gt;f2&#40;&#41; &#93;------------\<br />	mov ecx,t<br />	mov eax,&#91;ecx&#93;.three.vTable1<br />	call dword ptr&#91;eax+8&#93;<br />	;--------------------------/<br /><br />	;---&#91; t-&gt;f3&#40;&#41; &#93;---------------\<br />	mov ecx,t<br />	mov eax,&#91;ecx&#93;.three.vTable2<br />	add ecx,12<br />	call dword ptr&#91;eax+4&#93;<br />	;-----------------------------/<br /><br />	;---&#91; t-&gt;f4&#40;&#41; &#93;--------------\<br />	mov ecx,t<br />	mov eax,&#91;ecx&#93;.three.vTable2<br />	add ecx,12<br />	call dword ptr&#91;eax+8&#93;<br />	;----------------------------/<br /><br />	;---&#91; t-&gt;f5&#40;&#41;   &#93;----------\<br />	mov ecx,t<br />	mov eax,&#91;ecx&#93;.three.vTable1<br />	call dword ptr&#91;eax+12&#93;<br />	;--------------------------/<br /><br />	; t-&gt;z1 = 7<br />	mov ecx,t<br />	mov &#91;ecx&#93;.three.z1,7<br />	<br />	; t-&gt;z2 = 8<br />	mov &#91;ecx&#93;.three.z2,8<br /><br />	;----&#91; delete t &#93;----------------------------\<br />	push 1 ; C++ standard, where we delete from<br />	mov ecx,t<br />	mov eax,&#91;ecx&#93;<br />	call dword ptr&#91;eax&#93; ; in other words, calls three_destructor &#40;unless we have derived from &quot;three&quot;&#41;<br />	;--------------------------------------------/<br /><br />	ret<br />main endp<br /></code></pre><br /><br />It's possible to be done with macros, it won't be really hard to make, but with that ratio of 0 (and with my personal disinterest in this), ATC won't support multiple inheritance.</div>
    <div class="meta">Posted on 2005-03-04 21:51:22 by Ultrano</div>
   </div>
   <div class="post" id="post-157768">
    <div class="subject"><a href="#post-157768">Should multiple inheritance be implemented?</a></div>
    <div class="body">Hey Ultrano<br /><br />Thanks for the info :alright:<br /><br />Do you know how C++ handles virtual bases?<br /><br /><pre><code><br />A   A             A<br />|   |            / \<br />B   C    --&gt;    B   C<br /> \ /             \ /<br />  D               D<br /></code></pre></div>
    <div class="meta">Posted on 2005-03-06 21:50:59 by Maelstrom</div>
   </div>
   <div class="post" id="post-157793">
    <div class="subject"><a href="#post-157793">Should multiple inheritance be implemented?</a></div>
    <div class="body">It's quite easy. Now, let's change the above class definition of &quot;three&quot; to:<br /><pre><code><br />class three,one+two ; derive from both, order matters<br />   virtual f5<br />   long z1<br />   long z2<br />   virtual f2 ; override one_f2<br />   virtual f3 ; override two_f3<br />   void f7 ; a static method<br />endclass <br /></code></pre><br /><br />The only changes in the whole code will be in the virtual table of &quot;three&quot;:<br /><br /><pre><code><br />three_vTable1&#58;<br />   dd three_destructor<br />   dd one_f1<br />   dd three_f2  ; &lt;---- changed<br />   dd three_f5<br />three_vTable2&#58;<br />   dd three_destructor2<br />   dd three_f3 ; &lt;----- changed<br />   dd two_f4 <br /></code></pre><br /><br />The icall/pcall/ncall/ocall/hcall macros will not behave any differently when calling overriden methods - they just read the proc address from the method offset in the given vTable, and call the code at that retrieved address. <br /><br /><br />pcall t.f7   ;  t-&gt;f7();<br />Normal (static) methods are not registered in the vTable, they are converted to <br /><br />mov ecx,t<br />call three_f7<br /><br />In other words, brought down to simple scalar programming. At compile-time the compiler (or ATC/ObjAsm) decides which proc it should really call in here. <br /><br /><br /><br /><br />A good reference for these things can be ATC itself - when you force it to display the code that it generates. This is done by specifying:<br />DisplayClassHardcode = 1<br />before you include class.inc<br />Another good reference is the asm output of any VC++ -compliant C++ compiler - with debugging and optimizations disabled (otherwise a lot of garbage code can get in your way).<br />It's actually best to examine both references - since ATC by default has the destructor being virtual, while in C++ you usually define a static destructor. I disabled static destructors in ATC, because they're something you'll never really need in a Cpp-compatible asm app.</div>
    <div class="meta">Posted on 2005-03-07 11:20:53 by Ultrano</div>
   </div>
   <div class="post" id="post-157799">
    <div class="subject"><a href="#post-157799">Should multiple inheritance be implemented?</a></div>
    <div class="body">Hey Ultrano<br /><br />Thanks for the info on virtual functions but I was asking about virtual bases. I should have been a little more verbose in my post but I was in a hurry at the time :grin:<br /><br />With multiple inheritance you could end up with the same class included multiple times, but if you specify the base as virtual C++ will only place a single instance of the class in the object.<br /><br />Consider the following class hierarchy.<br /><br /><pre><code><br />A   A<br />|   |<br />B   C<br /> \ /<br />  D<br /></code></pre><br /><br />Class D contains two copies of class A.<br />C++ allows you to specify class A as a virtual base in classes B and C which prevents more than one copy of A making its way into class D.<br />The class hierarchy now looks like this.<br /><br /><pre><code><br />  A <br /> / \ <br />B   C <br /> \ / <br />  D<br /></code></pre><br /><br />Do you know how C++ handles this?<br />I would look at C++ asm output but I don't have a copy of C++.</div>
    <div class="meta">Posted on 2005-03-07 15:04:48 by Maelstrom</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=20682&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=20682&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="20682" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=20682&amp;page=2">&gt;</a><a href="../?id=20682&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>