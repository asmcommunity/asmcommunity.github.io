<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Idea : fast accurate Inertia Tensor for arbitrary meshes - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=24760" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=24760">Idea : fast accurate Inertia Tensor for arbitrary meshes</a></p>
   <div class="post" id="post-180860">
    <div class="subject"><a href="#post-180860">Idea : fast accurate Inertia Tensor for arbitrary meshes</a></div>
    <div class="body">Having scoured the internet for information on this topic, I narrowed by search down to two methods, which I will discuss, and then I&#39;ll describe my idea.<br />Please, feel free to comment - I have no idea what I&#39;m doing :)<br /><br />Note : both these methods take advantage of the fact that &quot;moments of inertia are additive, since they are integrals&quot;.. also note that many variations exist for each of these methods, but they seem to be the backbone in general.<br /><br />Method 1 : &quot;Atomic Mass method&quot;..<br />This method requires we &quot;know&quot; the Mass of the Body.<br />We think of our mesh as a collection of &quot;point masses&quot;. More specifically, we distribute the Mass of the Body over the N Vertices of its Mesh.. each Vertex gets attributed to it a piece of the Body&#39;s total Mass.<br />We calculate the Moment of Inertia for each Vertex, adding the results to find the total MOI of the Body, and then build our Inertia Tensor (3x3 matrix) from the total MOI.<br /><br />Method 2 : &quot;Tetrahedral Integration method&quot;..<br />This method presumes the Body has constant Density.<br />We find the Center of Mass of our Body, and immediately shift the Mesh Vertices so the Origin of the Body == Center of Mass (COM).<br />Next, we start iterating through all the Faces of the Mesh (which are presumed to be Triangles).<br />For each Triangle, we add a fourth point, being the COM, which creates a Tetrahedron pyramid which projects from the COM to the surface of the Body.<br />With a little work, we can accurately calculate the Volume of each Tetrahedron, and if we presume to know the Body Density, then we can easily calculate the Mass of each Tetrahedron.<br />With a bit more work, we can calculate the MOI of each Tetrahedron, and thus the MOI of the entire Body.<br />Far more accurate than Method 1, but much more work, and much slower.<br /><br />OK, now for the good stuff.. my idea is based on a puzzle posted a little while ago on this board regarding two Balls of equal mass and size but of different density (ie different Material).<br />It occured to me that, at least as far as rigid body dynamics is concerned, these two Balls will react the same way to impulses - ie, they behave the same way when we push them around.<br />Basically, we can get the best of both methods, if we use Method 2 to calculate partial Masses, and use Method 1 to calculate the partial MOIs.. this greatly simplifies the math (making it a lot faster and easier to implement) while retaining ALL the accuracy.<br /><br />Postscript : I neglected to mention one particular aspect of my idea.<br />I&#39;ve discussed briefly how to calculate the mass of an arbitrary tetrahedron (ie chunk of body) - notice that for each tetrahedron, we have calculated a Mass.. this mass should be distributed among the three vertices of each Face, rather than the four vertices of the tetrahedron, such that &quot;we are shoving all the mass to the Body&#39;s outer shell&quot;.. now it should make more sense why I mentioned the hollow and solid Balls earlier.<br />What I&#39;m really trying to say is that we only use the tetrahedrons to calculate Volume (and thus Mass), and that once we have the Mass, we go back to an Atomic (point-based) way of thinking, and distribute Mass over each Face, and thus over the entire Volume.<br />What we&#39;re really achieving is A) accurate calculation of Volume and Mass and B) accurate distribution of Mass over Volume.<br /></div>
    <div class="meta">Posted on 2006-05-23 08:35:57 by Homer</div>
   </div>
   <div class="post" id="post-180867">
    <div class="subject"><a href="#post-180867">The ideal formula for Volume of arbitrary tetrahedrons sharing common Origin</a></div>
    <div class="body">We don&#39;t need to mess around with Determinant math..or rather, we can lever one feature of my proposed method in order to take advantage of a mathematical anomoly, and simplify the fomula and the math involved in calculating arbitrary tetrahedron volume.<br /><br />Recall that we are using the Body Origin (==COM) as one point in each Tetrahedron..<br />Lagrange showed that the tetrahedron formed by Origin(0,0,0) and the three points M(x,y,z), M&#39;(x&#39;,y&#39;,z&#39;), M&quot;(x&quot;,y&quot;,z&quot;) has volume<br /><br />&nbsp; &nbsp; 1/6 . <br /><br />We can implement this formula 8)<br /></div>
    <div class="meta">Posted on 2006-05-23 12:15:06 by Homer</div>
   </div>
   <div class="post" id="post-180972">
    <div class="subject"><a href="#post-180972">Re: Idea : fast accurate Inertia Tensor for arbitrary meshes</a></div>
    <div class="body">This is not tested yet, but should work just fine.<br />If anyone cares to write an MMX version, I&#39;m sure it would be faster.<br /><pre><code><br />;This procedure calculates the Volume of <br />;an arbitrary tetrahedron projected from<br />;the Origin, ie has one vertex at (0,0,0)<br />;The following solution was found by Lagrange:<br />;V = 1/6 . <br />;<br />;Input Params are three pointers to three vertices of the tetrahedron<br />;Output is returned on the FPU stack<br />.data<br />fp6 REAL4 6.0f<br />.code<br />Calc_Tetrahedron_Volume proc uses esi edi ecx pv1,pv2,pv3<br />	<br />	mov esi,pv1<br />	mov edi,pv2<br />	mov ecx,pv3<br /><br />	fld .Vec3.x<br />	fmul .Vec3.y<br />	fld .Vec3.y<br />	fmul .Vec3.x<br />	fsub<br />	fmul .Vec3.z<br /><br />	fld .Vec3.y<br />	fmul .Vec3.x<br />	fld .Vec3.x<br />	fmul .Vec3.y<br />	fsub<br />	fmul .Vec3.z<br />	<br />	fld .Vec3.x<br />	fmul .Vec3.y<br />	fld .Vec3.y<br />	fmul .Vec3.x<br />	fsub<br />	fmul .Vec3.z<br />	<br />	fadd<br />	fadd<br />	fdiv fp6<br />	ret<br /><br />Calc_Tetrahedron_Volume endp<br /></code></pre><br /></div>
    <div class="meta">Posted on 2006-05-24 11:44:01 by Homer</div>
   </div>
   <div class="post" id="post-180993">
    <div class="subject"><a href="#post-180993">Re: Idea : fast accurate Inertia Tensor for arbitrary meshes</a></div>
    <div class="body">after changing the fdiv with an appropriate fmul, the proc takes 30cycles here,<br />only optimizable to 29cycles when I remove the prologue/epilogue. <br />14 cycles go for just the proc, and 15 cycles go for the FPU part. <br />Can&#39;t optimize it with SSE, the data members are not used f2f (as SSE loves it). <br /><br /><pre><code><br />align 16<br />f016 real4 0.16666666666666666666<br /><br />option prologue:none<br />option epilogue:none<br />Calc_Tetrahedron_Volume proc pv1,pv2,pv3<br />	push edi<br />&nbsp; &nbsp; &nbsp; &nbsp; push esi<br />&nbsp; &nbsp; &nbsp; &nbsp; push ecx<br />	mov esi,<br />	mov edi,<br />	mov ecx,<br />	fld .Vec3.x<br />	fmul .Vec3.y<br />	fld .Vec3.y<br />	fmul .Vec3.x<br />	fsub<br />	fmul .Vec3.z<br /><br />	fld .Vec3.y<br />	fmul .Vec3.x<br />	fld .Vec3.x<br />	fmul .Vec3.y<br />	fsub<br />	fmul .Vec3.z<br />	<br />	fld .Vec3.x<br />	fmul .Vec3.y<br />	fld .Vec3.y<br />	fmul .Vec3.x<br />	fsub<br />	fmul .Vec3.z<br />	<br />	fadd<br />	fadd<br />	fmul f016<br />	<br />	pop ecx<br />	pop esi<br />	pop edi<br />	retn 12<br />Calc_Tetrahedron_Volume endp<br />option prologue:PrologueDef<br />option epilogue:EpilogueDef<br /></code></pre><br /> <br /></div>
    <div class="meta">Posted on 2006-05-24 16:10:38 by Ultrano</div>
   </div>
   <div class="post" id="post-181013">
    <div class="subject"><a href="#post-181013">Re: Idea : fast accurate Inertia Tensor for arbitrary meshes</a></div>
    <div class="body">Cool&nbsp; 8)<br /><br />I&#39;ll be interested in comparing the output of this procedure to a known regular geometry, such as a Cube (2 triangles per flat surface * 6 surfaces = 12 tetrahedral primitives projected from the cube&#39;s center of mass / body origin).<br />That will tell me immediately whether this formula is garbage or not :)<br /><br />Unfortunately, I just switched motherboards and reinstalled everything, and DebugCenter is no longer working for me.. so I&#39;ll have to figure out what&#39;s wrong there first (I&#39;m too lazy to write output code for a simple test).<br /></div>
    <div class="meta">Posted on 2006-05-24 23:40:12 by Homer</div>
   </div>
   <div class="post" id="post-181016">
    <div class="subject"><a href="#post-181016">Re: Idea : fast accurate Inertia Tensor for arbitrary meshes</a></div>
    <div class="body"><div class="quote"><br />after changing the fdiv with an appropriate fmul, the proc takes 30cycles here,<br />only optimizable to 29cycles when I remove the prologue/epilogue. <br />14 cycles go for just the proc, and 15 cycles go for the FPU part. <br />Can&#39;t optimize it with SSE, the data members are not used f2f (as SSE loves it). <br /></div><br />why not? the data structs shouildnt be your master<br />customized data, until all physics etc is done and final output to customvertex format<br />an MMX version requires different data anyway<br />ok if all masscalculation is done only with this formula for all object, if everymass is 6 times bigger or not does it matter?<br /><br /></div>
    <div class="meta">Posted on 2006-05-25 02:53:50 by daydreamer</div>
   </div>
   <div class="post" id="post-181019">
    <div class="subject"><a href="#post-181019">Re: Idea : fast accurate Inertia Tensor for arbitrary meshes</a></div>
    <div class="body"><strong>daydreamer,</strong><br />hmm, prolly my SSE experience isn&#39;t enough, but here&#39;re my thoughts on it:<br />z0,z1 and z2 should be in one 128-bit unit/struct for max-speed. Then, we&#39;re doing cross-multiplications of x and y members of the 3 vertices. Enough arguments to make SSE optimization seem useless - I doubt it can be done in 15 cycles. <br /><br /><br /><strong>Homer,</strong><br />about DebugCenter - maybe you lost some Registry data - this happened to me when I changed my mobo+cpu last week. (but I also had trouble with a bad HDD partition cluster just after the bootsector...). </div>
    <div class="meta">Posted on 2006-05-25 06:21:49 by Ultrano</div>
   </div>
   <div class="post" id="post-181020">
    <div class="subject"><a href="#post-181020">Re: Idea : fast accurate Inertia Tensor for arbitrary meshes</a></div>
    <div class="body">Updated the fpu code a bit,<br /><pre><code><br />align 16<br />f016 real4 0.16666666666666666666666666666667<br /><br /><br />option prologue:none<br />option epilogue:none<br />Calc_Tetrahedron_Volume proc pv1,pv2,pv3<br />	pushi ecx,esi,edi<br />	mov esi,<br />	mov edi,<br />	mov ecx,<br />	fld .Vec3.x<br />	fmul .Vec3.y<br />	fld .Vec3.y<br />	fmul .Vec3.x<br />	fsub<br />	fmul .Vec3.z<br /><br />	fld .Vec3.y<br />	fmul .Vec3.x<br />	fld .Vec3.x<br />	fmul .Vec3.y<br />	fsub<br />	fmul .Vec3.z<br />	fadd<br />	<br />	fld .Vec3.x<br />	fmul .Vec3.y<br />	fld .Vec3.y<br />	fmul .Vec3.x<br />	fsub<br />	fmul .Vec3.z<br />	<br />	<br />	fadd<br />	fmul f016<br />	fabs<br />	<br />	poppi ecx,esi,edi<br />	retn 12<br />Calc_Tetrahedron_Volume endp<br />option prologue:PrologueDef<br />option epilogue:EpilogueDef<br /></code></pre><br /><br />Tested it with a 2x2x2 box, and yes - it works :) - gives a volume=8<br /><br /><pre><code><br />.data<br />	align 16	<br />	t0 Vec3 &lt;-1.0,-1.0,-1.0&gt;<br />	t1 Vec3 &lt; 1.0,-1.0,-1.0&gt;<br />	t2 Vec3 &lt; 1.0, 1.0,-1.0&gt;<br />	t3 Vec3 &lt;-1.0, 1.0,-1.0&gt;<br />	t4 Vec3 &lt;-1.0,-1.0,1.0&gt;<br />	t5 Vec3 &lt; 1.0,-1.0,1.0&gt;<br />	t6 Vec3 &lt; 1.0, 1.0,1.0&gt;<br />	t7 Vec3 &lt;-1.0, 1.0,1.0&gt;<br />	<br />	<br />	<br />.code<br />	<br /><br />adx macro p0,p1,p2,p3<br />	invoke Calc_Tetrahedron_Volume,addr p0,addr p1,addr p2<br />	fadd sum<br />	fstp sum<br />	invoke Calc_Tetrahedron_Volume,addr p0,addr p2,addr p3<br />	fadd sum<br />	fstp sum<br />endm<br /><br /><br />main proc<br />	local sum:real8<br />		<br />	fldz<br />	fstp sum<br />		<br />	adx t0,t1,t2,t3<br />	adx t1,t5,t6,t2<br />	adx t0,t4,t7,t3<br />	adx t0,t1,t5,t4<br />	adx t3,t2,t6,t7<br />	adx t4,t5,t6,t7<br />	<br />	PrintDouble sum ; prints 8.0<br />	<br />	<br />	ret<br />main endp<br /></code></pre></div>
    <div class="meta">Posted on 2006-05-25 06:48:19 by Ultrano</div>
   </div>
   <div class="post" id="post-181022">
    <div class="subject"><a href="#post-181022">Re: Idea : fast accurate Inertia Tensor for arbitrary meshes</a></div>
    <div class="body">OK sweet, it WORKS, and thats always good :)<br />As for my registry entries, well, I reinstalled oa32, so registry entries shouldn&#39;t be an issue.. I think the installer writes them now.<br /><br />I will ask Biterider when I see him what he thinks, I know other users have had problems getting DebugCenter working too.. I have not in the past..<br /><br />Anyway, YAY, it WORKS, great !! I&#39;ll go ahead and write code for simple (single mesh) objects which does the following:<br />1 - Calculate CenterOfMass by averaging the Vertices<br />2 - Shift the Mesh origin to coincide with COM by shifting all the Vertices explicitly<br />3 - Calculate Volume using Lagrange&#39;s method<br /><br />All that we need to do after that is to decide what Density the material of the Body, and then calculate Mass = Volume * Density<br /><br />At that point, I can start to think about calculating MOI for each tetra..<br /><br />This is all seeming too easy :)</div>
    <div class="meta">Posted on 2006-05-25 07:28:19 by Homer</div>
   </div>
   <div class="post" id="post-181024">
    <div class="subject"><a href="#post-181024">Re: Idea : fast accurate Inertia Tensor for arbitrary meshes</a></div>
    <div class="body"><div class="quote"><br /><strong>daydreamer,</strong><br />hmm, prolly my SSE experience isn&#39;t enough, but here&#39;re my thoughts on it:<br />z0,z1 and z2 should be in one 128-bit unit/struct for max-speed. Then, we&#39;re doing cross-multiplications of x and y members of the 3 vertices. Enough arguments to make SSE optimization seem useless - I doubt it can be done in 15 cycles. <br /></div><br />you must think different<br />smallest denominator 3 arguments x 4 packed operations =12 packed operations<br />you make one proc that unrolled several calculations<br />MMX solution: inside parenteses :psub psub pmadd pmadd<br />outside parenteses:pmadd pmadd<br />remove final multiplication and work with densities that are stored 1/6<br />because dont wanna lose presicion and speed when working with integers a mul 1/6 is impossible anyway<br /></div>
    <div class="meta">Posted on 2006-05-25 08:21:10 by daydreamer</div>
   </div>
   <div class="post" id="post-181025">
    <div class="subject"><a href="#post-181025">Re: Idea : fast accurate Inertia Tensor for arbitrary meshes</a></div>
    <div class="body">uhm a code solution, instead of vague description of the idea would be more helpful imho :)<br />but anyway, at this point we don&#39;t know the higher-level usage of the proc (what kind of code calls Calc_Tetrahedron_Volume), so we&#39;ll leave the further optimization for later ;)</div>
    <div class="meta">Posted on 2006-05-25 08:47:59 by Ultrano</div>
   </div>
   <div class="post" id="post-181059">
    <div class="subject"><a href="#post-181059">Re: Idea : fast accurate Inertia Tensor for arbitrary meshes</a></div>
    <div class="body">Example Pseudocode to calculate total Volume and total Mass of arbitrary Mesh:<br /><br />Calc_Object_Mass proc pFaces,pVertices,dwVertexStride,fDensity:REAL4<br />local fVolumeAccumulator:REAL8<br />mov fVolumeAccumulator,0<br />;Faces are triple word-sized Indices into Vertex array<br />foreach Face:<br />- grab indices<br />- multiply by Stride<br />- add base of vertex array<br />(such that we have pV1, pV2, pV3)<br />-invoke Calc_Tetreahedron_Volume,pV1,pV2,pV3<br />-fadd fVolumeAccumulator<br />-fstp fVolumeAccumulator<br />endfor<br />fld fVolumeAccumulator<br />fmul fDensity<br />ret ;return total Mass = total Volume * Density<br />Calc_Object_Mass endp<br /><br />So yes we can see that its not necessary to wrap the tetra-volume code as a proc, and really, the same goes for this proc.. not shown here is code for calculating the partial MOI of each tetra and the accumulation of them to find total MOI.<br /><br />I&#39;m in bed sick with the flu so I hope this post&nbsp; made sense :)<br /><br /></div>
    <div class="meta">Posted on 2006-05-26 01:14:14 by Homer</div>
   </div>
   <div class="post" id="post-181062">
    <div class="subject"><a href="#post-181062">Re: Idea : fast accurate Inertia Tensor for arbitrary meshes</a></div>
    <div class="body">Got my problem with DebugCenter fixed (thanks Biterider).<br />I performed my own small test of Lagrange&#39;s tetravolume formula and discovered that it can return negative values, so the formula SHOULD be:<br /><br />fabs (1/6 *  )<br /><br />as implied by Ultrano&#39;s demo code (there&#39;s no such thing as negative volume in a 3 dimensional universe).<br />If we simply accepted the negative results, I think we&#39;d arrive at a total volume of zero :P<br /><br />Two thumbs up to Ultrano&nbsp; 8)</div>
    <div class="meta">Posted on 2006-05-26 03:42:26 by Homer</div>
   </div>
   <div class="post" id="post-181117">
    <div class="subject"><a href="#post-181117">Re: Idea : fast accurate Inertia Tensor for arbitrary meshes</a></div>
    <div class="body">Now we can get down and dirty..<br />The following class encapsulates everything we&#39;ve discussed so far, and a little more.<br />I have not tested this code heavily, and I&#39;m not sure that I am calculating the MOI correctly, so let&#39;s check out the code and then talk about it :)<br /><br />PS : Corrected a bug in calculation of PointMasses..<br /><br /><pre><code><br />.data<br />fhalf REAL4 0.500f<br />.code<br /><br />RBID equ 93945<br />Object RigidBody,RBID,Primer<br />	StaticMethod 	Load,				Pointer,REAL4<br />	StaticMethod 	CorrectTheOrigin,	Pointer<br />	StaticMethod	Calc_Tetra_MOI,		REAL4,Pointer,Pointer,Pointer,Pointer<br />	;<br />	DefineVariable pMesh,Pointer,NULL<br />	DefineVariable dwNumFaces,dword,NULL<br />	DefineVariable dwNumVerts,dword,NULL<br />	DefineVariable dwStride,dword,NULL<br />	DefineVariable dwFVF,dword,NULL<br />ObjectEnd<br /><br />Method RigidBody.Done,uses esi<br />	SetObject esi<br />	SafeRelease .pMesh	<br />MethodEnd<br /><br />Method RigidBody.Load,uses esi,pName,fDensity:REAL4<br />LOCAL pmaterials,numMaterials,pfaces,pverts<br />LOCAL pV1,pV2,pV3<br />LOCAL fPartialMass:REAL4<br />LOCAL fTotalMass:REAL4<br />LOCAL vMOI:Vec3<br />	SetObject esi<br />	invoke D3DXLoadMeshFromX,pName,D3DXMESH_SYSTEMMEM,<br />&nbsp; &nbsp; &nbsp; pD3DDevice, NULL,<br />&nbsp; &nbsp; &nbsp; addr pmaterials,NULL, addr numMaterials,addr .pMesh<br />&nbsp; &nbsp; .if eax!=S_OK<br />		DbgWarning &quot;Failed to load xfile&quot;<br />&nbsp; &nbsp; .else<br />		;Query the loaded Mesh object for more information<br />		mov .dwNumFaces,	$ICall (.pMesh::ID3DXMesh.GetNumFaces)<br />		mov .dwNumVerts,	$ICall (.pMesh::ID3DXMesh.GetNumVertices)<br />		mov .dwFVF,		$ICall (.pMesh::ID3DXMesh.GetFVF)<br />		mov .dwStride,		$ICall (.pMesh::ID3DXMesh.GetNumBytesPerVertex)<br /><br />		ICall .pMesh::ID3DXMesh.LockIndexBuffer,D3DLOCK_READONLY,addr pfaces<br />		.if eax==S_OK<br />			ICall .pMesh::ID3DXMesh.LockVertexBuffer,NULL,addr pverts<br />			.if eax==S_OK			<br />				;See notes regarding this Method<br />				OCall CorrectTheOrigin,pverts<br />				<br />				;Zero out some local Accumulators<br />				mov vMOI.x,0<br />				mov vMOI.y,0<br />				mov vMOI.z,0<br />				mov fTotalMass,0<br />				<br />				;We will process all Faces in the mesh<br />				;Faces are &#39;triple words&#39;<br />				xor ecx,ecx<br />				.while ecx&lt;.dwNumFaces<br />					push ecx	;ecx is &quot;current face counter&quot;					<br />					<br />					;For each Face, grab 3 word sized indices<br />					;and convert them into Vertex Pointers<br />					add ecx,pfaces<br />					movzx eax,word ptr<br />					mul .dwStride<br />					add eax,pverts<br />					mov pV1,eax<br />					movzx eax,word ptr<br />					mul .dwStride<br />					add eax,pverts<br />					mov pV2,eax<br />					movzx eax,word ptr<br />					mul .dwStride<br />					add eax,pverts<br />					mov pV3,eax<br />					<br />					;Now that we have ptrs to the<br />					;three vertices of the current Face,<br />					;we can calculate the Partial Volume<br />					;for the Tetrahedron formed by those<br />					;three vertices and the Origin, then<br />					;we can easily obtain the Partial Mass<br />					;by multiplying (Mass=Volume*Density)<br />					invoke Calc_Tetrahedron_Volume,pV1,pV2,pV3<br />					fmul fDensity<br />					fst fPartialMass<br />					fadd fTotalMass<br />					fstp fTotalMass<br />					<br />					;Now that we have found the Tetrahedron&#39;s Mass,<br />					;we can calculate the Moments of Inertia of<br />					;the Tetrahedron using the PointMass method..<br />					;(note, we ignore the point at the Origin)<br />					OCall Calc_Tetra_MOI,fPartialMass,pV1,pV2,pV3,addr vMOI<br />					<br />					pop ecx<br />					add ecx,6<br />				.endw<br />				DbgFloat fTotalMass,&quot;Combined Mass of all Tetrahedrons&quot;<br />				lea eax,vMOI<br />				DbgVec3 eax,&quot;Combined MOI of all PointMasses&quot;<br /><br />				ICall .pMesh::ID3DXMesh.UnlockVertexBuffer<br />			.endif<br />			ICall .pMesh::ID3DXMesh.UnlockIndexBuffer<br />		.endif<br />&nbsp; &nbsp; .endif<br />MethodEnd<br /><br />;This method calculates the Moments of Inertia of a Tetrahedron,<br />;by distributing the Mass over the outermost Face&#39;s 3 vertices<br />;and then treating the Face as a set of Point Masses..<br />Method RigidBody.Calc_Tetra_MOI,uses esi,fPartialMass:REAL4,pV1,pV2,pV3,pMOI<br />LOCAL fRay1:REAL4<br />LOCAL fRay2:REAL4<br />LOCAL fRay3:REAL4<br />LOCAL fRayTotal:REAL8<br />LOCAL fMass1:REAL8<br />LOCAL fMass2:REAL8<br />LOCAL fMass3:REAL8<br />LOCAL fSanity:REAL4<br />	SetObject esi<br />	;We must distribute the Tetrahedral Mass over the three<br />	;face vertices (V1,V2,V3) based on their distances from<br />	;the Origin (L1,L2,L3)<br />	<br />	;Step 1 : Calculate three ray lengths<br />	mov eax,pV1<br />	fld&nbsp; .Vec3.x<br />	fmul .Vec3.x<br />	fld&nbsp; .Vec3.y<br />	fmul .Vec3.y<br />	fld&nbsp; .Vec3.z<br />	fmul .Vec3.z<br />	fadd<br />	fadd<br />	fsqrt<br />	fstp fRay1<br />	<br />	mov eax,pV2<br />	fld&nbsp; .Vec3.x<br />	fmul .Vec3.x<br />	fld&nbsp; .Vec3.y<br />	fmul .Vec3.y<br />	fld&nbsp; .Vec3.z<br />	fmul .Vec3.z<br />	fadd<br />	fadd<br />	fsqrt<br />	fstp fRay2<br /><br />	mov eax,pV3<br />	fld&nbsp; .Vec3.x<br />	fmul .Vec3.x<br />	fld&nbsp; .Vec3.y<br />	fmul .Vec3.y<br />	fld&nbsp; .Vec3.z<br />	fmul .Vec3.z<br />	fadd<br />	fadd<br />	fsqrt<br />	fstp fRay3<br />	<br />	;Step 2 - Distribute the Mass according to<br />	;the ratios of the ray lengths..<br />	;First, add all three Ray Lengths together.<br />	;Next, divide each Ray length by the &#39;total length&#39;<br />	;This yields three fractions which are roughly 1/3<br />	;and which should add together to equal 1.0<br />	;Multiply each fraction by the input Mass, and thus<br />	;we have distributed that Mass over the three Vertices<br />	;according to their distance from the Origin.<br />	fld&nbsp; fRay1<br />	fadd fRay2<br />	fadd fRay3<br />	fstp fRayTotal<br />	;<br />	fld&nbsp; fRay1<br />	fdiv fRayTotal<br />	fmul fPartialMass<br />	fstp fMass1<br />	fld&nbsp; fRay2<br />	fdiv fRayTotal<br />	fmul fPartialMass<br />	fstp fMass2<br />	fld&nbsp; fRay3<br />	fdiv fRayTotal<br />	fmul fPartialMass<br />	fstp fMass3<br />	<br />	;Sanity Check.. do PointMasses add up to PartialMass?<br />;	fld fMass1<br />;	fadd fMass2<br />;	fadd fMass3<br />;	fstp fSanity<br />;	DbgFloat fSanity,&quot;total of partial masses in tetra&quot;<br />;	DbgFloat fPartialMass,&quot;mass of tetra&quot;<br /><br />	;Step 3 - Calculate the MOI of each Point-Mass, then<br />	;add the three resulting MOIs in a vec3 accumulator..<br />	;I=mr^2<br />	mov ebx,pMOI<br />	<br />	;Calculate MOI of PointMass#1 with respect to each Axis<br />	mov eax,pV1<br />	fld&nbsp; .Vec3.x	<br />	fmul .Vec3.x<br />	fmul fMass1<br />	fadd .Vec3.x<br />	fstp .Vec3.x<br />	fld&nbsp; .Vec3.y<br />	fmul .Vec3.y<br />	fmul fMass1<br />	fadd .Vec3.y<br />	fstp .Vec3.y<br />	fld&nbsp; .Vec3.z	<br />	fmul .Vec3.z<br />	fmul fMass1<br />	fadd .Vec3.z<br />	fstp .Vec3.z<br />	<br />	;Calculate MOI of PointMass#2 with respect to each Axis<br />	mov eax,pV2<br />	fld&nbsp; .Vec3.x	<br />	fmul .Vec3.x<br />	fmul fMass2<br />	fadd .Vec3.x<br />	fstp .Vec3.x<br />	fld&nbsp; .Vec3.y<br />	fmul .Vec3.y<br />	fmul fMass2<br />	fadd .Vec3.y<br />	fstp .Vec3.y<br />	fld&nbsp; .Vec3.z	<br />	fmul .Vec3.z<br />	fmul fMass2<br />	fadd .Vec3.z<br />	fstp .Vec3.z<br /><br />	;Calculate MOI of PointMass#3 with respect to each Axis<br />	mov eax,pV3<br />	fld&nbsp; .Vec3.x	<br />	fmul .Vec3.x<br />	fmul fMass3<br />	fadd .Vec3.x<br />	fstp .Vec3.x<br />	fld&nbsp; .Vec3.y<br />	fmul .Vec3.y<br />	fmul fMass3<br />	fadd .Vec3.y<br />	fstp .Vec3.y<br />	fld&nbsp; .Vec3.z	<br />	fmul .Vec3.z<br />	fmul fMass3<br />	fadd .Vec3.z<br />	fstp .Vec3.z<br />MethodEnd<br /><br />;This method does several things:<br />;- measure the size of the Mesh<br />;- calculate how far &#39;out of center&#39; it is<br />;- recenter the mesh such that the CenterOfMass<br />;&nbsp; coincides with the Origin of the mesh<br />Method RigidBody.CorrectTheOrigin,uses esi ecx,pverts<br />LOCAL vError:Vec3<br />LOCAL min:Vec3<br />LOCAL max:Vec3<br />	SetObject esi<br />	;Zero out the temp min,max vectors<br />	xor ecx,ecx<br />	mov min.x,ecx<br />	mov min.y,ecx<br />	mov min.z,ecx<br />	mov max.x,ecx<br />	mov max.y,ecx<br />	mov max.z,ecx<br />	;Find the absolute min,max of all Vertices<br />	.while ecx&lt;.dwNumVerts<br />		push ecx<br />		mov eax,.dwStride<br />		mul ecx<br />		add eax,pverts<br />		fMin .Vec3.x,min.x<br />		fstp min.x<br />		fMin .Vec3.y,min.y<br />		fstp min.y<br />		fMin .Vec3.z,min.z<br />		fstp min.z<br />		fMax .Vec3.x,max.x<br />		fstp max.x	<br />		fMax .Vec3.y,max.y<br />		fstp max.y<br />		fMax .Vec3.z,max.z<br />		fstp max.z<br />		pop ecx<br />		inc ecx<br />	.endw<br />	<br />	;Calculate how far out of Center the mesh is<br />	fld max.x<br />	fsub min.x<br />	fmul fhalf<br />	fadd min.x<br />	fstp vError.x<br />	;<br />	fld max.y<br />	fsub min.y<br />	fmul fhalf<br />	fadd min.y<br />	fstp vError.y<br />	;<br />	fld max.z<br />	fsub min.z<br />	fmul fhalf<br />	fadd min.z<br />	fstp vError.z<br />	<br />	;Recenter the Mesh by adjusting the Vertices<br />	xor ecx,ecx<br />	.while ecx&lt;.dwNumVerts<br />		push ecx<br />		mov eax,.dwStride<br />		mul ecx<br />		add eax,pverts<br />		fld .Vec3.x<br />		fadd vError.x<br />		fstp .Vec3.x<br />		fld .Vec3.y<br />		fadd vError.x<br />		fstp .Vec3.y<br />		fld .Vec3.z<br />		fadd vError.x<br />		fstp .Vec3.z<br />		pop ecx<br />		inc ecx<br />	.endw	<br />	<br />MethodEnd<br /><br /></code></pre><br /></div>
    <div class="meta">Posted on 2006-05-28 02:07:30 by Homer</div>
   </div>
   <div class="post" id="post-181118">
    <div class="subject"><a href="#post-181118">Re: Idea : fast accurate Inertia Tensor for arbitrary meshes</a></div>
    <div class="body">For those who are too lazy to study the code closely, here&#39;s a description of what&#39;s going on in laymans terms..<br /><br />We load a static Mesh from an XFile.<br />We check how far &#39;out of center&#39; the Mesh is, and correct the error, recentering the Mesh so that the Mesh Origin and the Center Of Mass are coincidental.. (unsure if I did this correctly).<br />We iterate through all the Faces in the Mesh... for each Face, we obtain pointers to its three Vertices, and then we hand those three pointers to our handy, dandy Tetrahedron Volume calculator (which assumes the fourth Vertex is at the Origin of the Body).<br />This tells us the Volume of each &quot;chunk of flesh&quot;, from which we immediately obtain the Mass (since Density is a given).<br />The Mass of each Tetrahedron is then distributed across the three Vertices of the Face (imagine we&#39;re shoving all the Mass to the outer shell of the 3D Body represented by the Mesh), which basically gives us three PointMasses for each Tetrahedron.<br />We calculate the Moments of Inertia for each PointMass, and we sum them (add them up) to find the Total MOI of the Body.<br />Thanks for flying with Homer Brainwaves :D</div>
    <div class="meta">Posted on 2006-05-28 02:26:55 by Homer</div>
   </div>
   <div class="post" id="post-181215">
    <div class="subject"><a href="#post-181215">Re: quick FPU to SSE conversion</a></div>
    <div class="body">;;Method RigidBody.Calc_Tetra_MOI<br />;;Step 1 : Calculate three ray lengths<br />mov eax, pV1<br />mov ecx, pV2<br />mov edx, pV3<br />movdqa xmm0, <br />movdqa xmm1, <br />movdqa xmm2, <br />mulps xmm0, xmm0<br />mulps xmm1, xmm1<br />mulps xmm2, xmm2<br />movhlps xmm3, xmm0<br />movhlps xmm4, xmm1<br />movhlps xmm5, xmm2&nbsp; <br />addps xmm0, xmm3<br />addps xmm1, xmm4<br />addps xmm2, xmm5<br />pshufd xmm3, xmm0, 1<br />pshufd xmm4, xmm1, 1<br />pshufd xmm5, xmm2, 1&nbsp; <br />addps xmm0, xmm3<br />addps xmm1, xmm4<br />addps xmm2, xmm5<br />sqrtss xmm0, xmm0<br />sqrtss xmm1, xmm1<br />sqrtss xmm2, xmm2<br />movss fRay1, xmm0<br />movss fRay2, xmm1<br />movss fRay3, xmm2<br /><br />I&#39;m assuming that the vectors are stored<br />align 16<br />dword x, y, z, 0.0f<br />If this ISN&#39;T the case then 6 more instructions are required<br />movdqa xmm0, <br />movdqa xmm1, <br />movdqa xmm2, <br />;;then<br />pslldq xmm0, 4<br />pslldq xmm1, 4<br />pslldq xmm2, 4<br />por xmm0, <br />por xmm1, <br />por xmm2, <br /><br />and global data<br />ScalarZero dd 0.0f, 0h, 0h, 0h<br /><br />I didn&#39;t use HADDPS for compatibility issues, so the code can be run on systems with only SSE/2.</div>
    <div class="meta">Posted on 2006-05-30 20:59:25 by r22</div>
   </div>
   <div class="post" id="post-181226">
    <div class="subject"><a href="#post-181226">Re: Idea : fast accurate Inertia Tensor for arbitrary meshes</a></div>
    <div class="body">takes ~500 cycles <br />You mean SSE2 (on a quick look), movdqa and pshufd aren&#39;t present in SSE, I guess - masm doesn&#39;t recognize these 2 instructions. <br />My Sempron doesn&#39;t support them (and btw I am quite happy by its performance, no upgrading for 2-4 years more)</div>
    <div class="meta">Posted on 2006-05-31 02:06:15 by Ultrano</div>
   </div>
  </div>
 </body>
</html>