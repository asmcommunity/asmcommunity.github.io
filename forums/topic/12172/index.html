<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Conversion - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=12172" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=12172">Conversion</a></p>
   <div class="post" id="post-93518">
    <div class="subject"><a href="#post-93518">Conversion</a></div>
    <div class="body">Does anyone know or have a routine/algo that converst ascii to double?  <br /><br />I can code my own version, but im hung up on translating the fraction into binary.. <br /><br />ie) 0.75 -&gt; 0.1100 <br /><br />Because 1 * 0.5 + 1 * 0.25  = 0.75<br /><br />But devising an algorithm has been challenging to say the least.<br /><br />I've seen an example that does this:<br /><br />0.75 * 2 = 1.5 (bit 1 = 1; sub 1 from result and do it again)<br />0.5 * 2 = 1.0   (bit 2 = 1; sub 1 from result and do it again)<br />0.0 * 2 = 0.0   (bit 3 = 0; do nothing..)<br />etc.<br /><br />But this is still Human math.. not machine.  <br /><br />Any help would be appreciated..<br />Thanx!<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2003-04-05 15:41:43 by NaN</div>
   </div>
   <div class="post" id="post-93533">
    <div class="subject"><a href="#post-93533">Conversion</a></div>
    <div class="body">Well i got a routine working now..  and fairly small.   But fitting bits over two DWORDS, and normalizing everything is now the issue... <br /><br />The hard part is the bit stream.  A double such as 23.75 has a real component (23) and a fraction (75/100).  I now have an algo that will make &quot;75&quot; turn into binary &quot;1100...&quot; up to 32 bits since it fills a dedicated register in a loop.  <br /><br />But i may need 100 bits, it depends on how the number is conditioned and where the normalization exponent exists:<br /><br /><br /><br />I have to now think of a good scheme that will turn 23 into normal two's:<br /><br />10111 &lt; = 23<br /><br />Turn 75 into a fraction:<br /><br />11 &lt; 0.75<br /><br />Append them together<br /><br />10111.11<br /><br />Normalize them and determine the exponent<br /><br />1.011111 e4<br /><br />Drop the first &quot;1.&quot; since normalized and fit 52 bits plus a sign bit and exponent:<br /><br /><span class="strike">01111100000000000000000000000000000000000000000000<br /><br />Where S=0 for positive, and Exp = 4 + 3FF = 403h  (100 0000 0011)<br /><br />Resulting in a final QWORD:<br /><br />(0)(10000000011)(01111100000000000000000000000000000000000000000000)<br />MSB<br /><br /><br /><br />Oh well.. still hacking at it..<br />:NaN:</div>
    <div class="meta">Posted on 2003-04-05 18:24:11 by NaN</div>
   </div>
   <div class="post" id="post-93569">
    <div class="subject"><a href="#post-93569">Conversion</a></div>
    <div class="body">Hey Bazik, I've been seachin the web all night looking for a proven algorithm (in any language) that does the IEEE double precision standard conversion.  So far i have yet to find one source.<br /><br />You seem to know how to find the unfindable.. you think you can hack this ;)<br />(Cause im not finding anything that isnt too general, or too &quot;theory&quot;).<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2003-04-06 00:50:21 by NaN</div>
   </div>
   <div class="post" id="post-93582">
    <div class="subject"><a href="#post-93582">Conversion</a></div>
    <div class="body">NaN,<br /><br />Why not use the FPU?</div>
    <div class="meta">Posted on 2003-04-06 01:53:07 by iblis</div>
   </div>
   <div class="post" id="post-93668">
    <div class="subject"><a href="#post-93668">Conversion</a></div>
    <div class="body">NAN<br /><br />If you don't have any restriction against using the FPU, you will find a string-to-float function (FpuAtoFL) in the FPU.lib library available with MASM32, with full source code. It may be of some use to you.<br /><br />If your intention is to do the conversion <u>without using the FPU</u>, you can look at the MixFromA function in the Mix.lib library available from Hutch's site, also with full source code. It uses only integer maths to get a &quot;fixed point&quot; binary value (16-bit signed integer portion + 16-bit fractional portion). You could easily modify the procedure to yield the IEEE floating point format since you have demonstrated your knowledge of that format.<br /><br />Raymond</div>
    <div class="meta">Posted on 2003-04-06 11:24:29 by Raymond</div>
   </div>
   <div class="post" id="post-94019">
    <div class="subject"><a href="#post-94019">Conversion</a></div>
    <div class="body">Ya.. i somehow thought it would be simple to write my own formatting routine.  But one problem layered up to the next and so on.  Before i knew it im focused on solving everything one step at a time and the simple reality of &quot;cheating&quot; with the FPU can easily be done ( :rolleyes: ).  <br /><br />Thanx for bringing me back to my senses....<br />:NaN:</div>
    <div class="meta">Posted on 2003-04-07 16:45:39 by NaN</div>
   </div>
   <div class="post" id="post-94057">
    <div class="subject"><a href="#post-94057">Conversion</a></div>
    <div class="body">NaN<br /><br />Couldn't resist trying it myself. I still prefer using the FPU which has much more flexibility. I gave up trying to add code to the following procedure in order to convert input given in scientific notation. I will let someone attempt that.<br /><br />The following procedure has been tested on several samples and seems to be reliable. No effort has been made to optimize it.<br /><br />Enjoy<br /><br />Raymond<br /><pre><code>;*******************************************<br />;                             AtoR4<br />;     This procedure converts a null-terminated decimal string<br />;     to a REAL4 number using only CPU instructions &#40;MASM syntax&#41;.<br />;     Limitations&#58; the integer portion must be less than 2^32,<br />;                  number of decimal digits 9 max.<br />;                  scientific notation not supported<br />;<br />;     Returns EAX with 0 for success, -1 for invalid source<br />;     and REAL4 result at destination address if successful.<br />;<br />;     Raymond Filiatreault, April 2003<br />;<br />;*************************************************<br /><br />AtoR4 proc USES ebx esi edi lpsource&#58;DWORD, lpdest&#58;DWORD<br /><br />LOCAL mul10 &#58;DWORD<br /><br />;----------------------------------------------------------------------<br />;The integer portion will be converted to binary and accumulated in EBX<br />;The decimal portion will be converted to binary and accumulated in ECX<br />;EDI will be used to retain the sign and the count of decimal digits<br />;ESI is used as a pointer to the source string<br />;<br />;----------------------------------------------------------------------<br /><br />xor   ebx,ebx<br />xor   ecx,ecx<br />xor   edi,edi<br />mov   esi,lpsource<br />mov   mul10,10<br /><br />@@&#58;<br />movzx eax,byte ptr &#91;esi&#93;<br />inc   esi<br />cmp   al,&quot; &quot;<br />jz    @B                ;get rid of leading blanks<br /><br />.if   al == &quot;+&quot;<br />      movzx eax,byte ptr &#91;esi&#93;<br />      inc   esi<br />.elseif al == &quot;-&quot;<br />      stc<br />      rcr   edi,1       ;keep negative sign as most significant bit of EDI<br />      movzx eax,byte ptr &#91;esi&#93;<br />      inc   esi<br />.endif<br /><br />;**********     Convert integer portion to binary    ************<br /><br />integer&#58;<br />.if   al == &quot;.&quot;<br />      jz    decimal<br />.elseif   al == 0<br />      jmp    finish<br />.elseif   al &gt;= &quot;0&quot; &amp;&amp; al &lt;= &quot;9&quot;<br />      sub   al,&quot;0&quot;<br />      xchg  eax,ebx<br />      mul   mul10<br />      .if   edx &gt; 0<br />            jmp   error ;integer portion exceeds 2^32<br />      .endif<br />      add   ebx,eax<br />.else<br />      jmp   error       ;invalid character<br />.endif<br />movzx eax,byte ptr &#91;esi&#93;<br />inc   esi<br />jmp   integer<br /><br />;************     Convert decimal portion to binary    **************<br /><br />decimal&#58;<br />movzx eax,byte ptr &#91;esi&#93;<br />inc   esi<br />.if   al == 0<br />      jmp   finish<br />.elseif   al &gt;= &quot;0&quot; &amp;&amp; al &lt;= &quot;9&quot;<br />      sub   al,&quot;0&quot;<br />      xchg  eax,ecx<br />      mul   mul10<br />      .if   edx &gt; 0<br />            jmp   error ;decimal portion would have more than 9 digits<br />      .endif<br />      add   ecx,eax<br />.else<br />      jmp   error       ;invalid character<br />.endif<br />inc   edi               ;bump count of decimal digits<br />jmp   decimal<br /><br />;********  Convert decimal portion to aligned binary fraction  **********<br /><br />finish&#58;<br />mov   eax,edi<br />shl   eax,1<br />shr   eax,1             ;to get rid of possible negative sign<br /><br />.if   eax &gt; 9<br />      jmp   error       ;more than 9 decimal digits<br />.elseif   eax != 0<br />      push  ecx<br />      mov   ecx,eax<br />      mov   eax,10<br />   @@&#58;<br />      dec   ecx<br />      jz    @F<br />      mul   mul10<br />      jmp   @B<br />   @@&#58;<br />      mov   ecx,eax<br />      pop   edx<br />      xor   eax,eax<br />      div   ecx<br />.endif<br /><br />;---------------------------------------------------------------------<br />;     Combine the binary integer portion with the binary fraction,<br />;     compute the biased exponent, insert the sign and join everything.<br />;     A null integer must be treated differently than a non-null one.<br />;----------------------------------------------------------------------<br /><br />.if   ebx == 0          ;integer portion = 0?<br />      .if   eax == 0    ;decimal portion also = 0?<br />            mov   esi,lpdest<br />            mov   &#91;esi&#93;,eax   ;store 0 as the REAL4<br />            jmp   eXit        ;return with success code<br />      .endif<br /><br />      bsr   ecx,eax     ;get location of most significant &quot;1&quot; bit of fraction<br />      sub   ecx,32      ;-&gt;negative position of that bit from the left +1<br />      mov   edx,ecx<br />      add   edx,7fh     ;gives the biased exponent<br />      ror   edx,8       ;shift the biased exponent to the upper 8 bits<br />      shl   edi,1       ;get sign bit in C flag<br />      rcr   edx,1       ;transfer it to EDX<br />                        ;sign and biased exponent now in EDX<br />                        ;according to IEEE format<br />      neg   ecx<br />      shl   eax,cl      ;pushes out most significant &quot;1&quot; bit<br />      shr   eax,9       ;positions significand bits according to IEEE format<br />      or    eax,edx     ;assemble REAL4<br /><br />.else<br />      bsr   ecx,ebx     ;get location of most significant &quot;1&quot; bit of integer<br />      mov   edx,ecx<br />      add   edx,7fh     ;gives the biased exponent<br />      ror   edx,8       ;shift the biased exponent to the upper 8 bits<br />      shl   edi,1       ;get sign bit in C flag<br />      rcr   edx,1       ;transfer it to EDX<br />                        ;sign and biased exponent now in EDX<br />                        ;according to IEEE format<br />      sub   ecx,32<br />      neg   ecx<br />      shld  ebx,eax,cl  ;pushes out most significant &quot;1&quot; bit of integer<br />                        ;while pushing in most significant bits of decimal<br />      shr   ebx,9       ;positions significand bits according to IEEE format<br />      or    ebx,edx     ;assemble REAL4<br />      mov   eax,ebx<br />.endif<br /><br />mov   edi,lpdest<br />mov   &#91;edi&#93;,eax         ;store result<br />xor   eax,eax<br />jmp   eXit<br /><br />error&#58;<br />mov   eax,-1<br />eXit&#58;<br />ret<br /><br />AtoR4 endp<br /></code></pre></div>
    <div class="meta">Posted on 2003-04-07 20:03:16 by Raymond</div>
   </div>
  </div>
 </body>
</html>