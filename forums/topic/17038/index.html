<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>addressing - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17038" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=17038">addressing</a></p>
   <div class="post" id="post-132216">
    <div class="subject"><a href="#post-132216">addressing</a></div>
    <div class="body">Can I use both relative and absolute addressing for JMP/CALL or can I only use one?</div>
    <div class="meta">Posted on 2004-01-31 20:05:45 by Maddox</div>
   </div>
   <div class="post" id="post-132217">
    <div class="subject"><a href="#post-132217">addressing</a></div>
    <div class="body">Maddox,<br />Before any of us take a crack at answering you, why don't you explain either by code example or prose, what you mean by relative, direct, or indirect addressing.  Then we will all be singing from the same song book.  Ratch</div>
    <div class="meta">Posted on 2004-01-31 21:07:20 by Ratch</div>
   </div>
   <div class="post" id="post-132221">
    <div class="subject"><a href="#post-132221">addressing</a></div>
    <div class="body"><div class="quote"><br />Maddox,<br />Before any of us take a crack at answering you, why don't you explain either by code example or prose, what you mean by relative, direct, or indirect addressing.  Then we will all be singing from the same song book.  Ratch </div><br /><br />If I want to jump to another memory address that is 20h bytes away do I JMP 20 or do I JMP 6F101230(example)? And does CALL work the same way?<br /><br />The reason is when I look at assembly generated by w32dasm I have no idea if it puts the full address at jmps to make it easier to read or if that is really how it looks. Also in ASM source they use labels which causes the compiler to do those calculations for you.<br /><br />Are we singing from the same book now?</div>
    <div class="meta">Posted on 2004-01-31 21:52:33 by Maddox</div>
   </div>
   <div class="post" id="post-132222">
    <div class="subject"><a href="#post-132222">addressing</a></div>
    <div class="body">e9 jump = take current va, add dword from va+1, add size of opcode = destination it will jump to, e8 works the same way,  e9= long jump, eb = short jump (2 byte opcode, 1 byte = eb (jmp short), next byte is the amount it will change the eip by (if its &lt;127 then its going forwards, greater than 127, its going backwards.. i think heh), you really need to look at it in opcode form to understand, w32dasm etc calculates the addresses for you and yes assembler does use labels, but those labels are only for the coder etc to understand the code easier, the assembler (not compiler then calculates the va's of the labels when its making the executable and updates the opcodes with the va's etc..</div>
    <div class="meta">Posted on 2004-01-31 21:59:38 by evlncrn8</div>
   </div>
   <div class="post" id="post-132223">
    <div class="subject"><a href="#post-132223">addressing</a></div>
    <div class="body">Maddox,<br />Well, lets talk just about jumps then.  If you want to code a jump to an address 20 bytes forward of your present address, you code JMP $+20.  If you code it JMP 20, MASM does not know if you want to jump to address 20 or 20 bytes forward, so it will tell you that you can only jump to a label.  The JMP instruction hardware uses the operand to jump that number of bytes forward or backword, so the assembler has to figure out the signed displacement from the current address and stuff it into the instruction operand.  If the displacement is more than what 16 bits can represent, then the assembler must select the 32-bit jump instruction.  I know nothing about W32DASM, and this is a MASM form.  Usually an assembler will output an object file which has addresses relative to the segments (.CODE, .DATA.,.DATA?, etc). Included with these displacements is relocation information which the linker uses to make absolute addresses for the exe file.  Ratch</div>
    <div class="meta">Posted on 2004-01-31 22:26:49 by Ratch</div>
   </div>
   <div class="post" id="post-132224">
    <div class="subject"><a href="#post-132224">addressing</a></div>
    <div class="body"><div class="quote"><br />e9 jump = take current va, add dword from va+1, add size of opcode = destination it will jump to, e8 works the same way,  e9= long jump, eb = short jump (2 byte opcode, 1 byte = eb (jmp short), next byte is the amount it will change the eip by (if its &lt;127 then its going forwards, greater than 127, its going backwards.. i think heh), you really need to look at it in opcode form to understand, w32dasm etc calculates the addresses for you and yes assembler does use labels, but those labels are only for the coder etc to understand the code easier, the assembler (not compiler then calculates the va's of the labels when its making the executable and updates the opcodes with the va's etc.. </div><br /><br />Wow... one long sentence. Does w32dasm mess with the address in the opcode?</div>
    <div class="meta">Posted on 2004-01-31 22:27:08 by Maddox</div>
   </div>
   <div class="post" id="post-132225">
    <div class="subject"><a href="#post-132225">addressing</a></div>
    <div class="body">nope, rather w32dasm generates the address from the opcode, have a look at the opcodes and do the math using the info in my previous long sentence</div>
    <div class="meta">Posted on 2004-01-31 22:30:03 by evlncrn8</div>
   </div>
   <div class="post" id="post-132226">
    <div class="subject"><a href="#post-132226">addressing</a></div>
    <div class="body"><div class="quote"><br />Maddox,<br />Well, lets talk just about jumps then.  If you want to code a jump to an address 20 bytes forward of your present address, you code JMP $+20.  If you code it JMP 20, MASM does not know if you want to jump to address 20 or 20 bytes forward, so it will tell you that you can only jump to a label.  The JMP instruction hardware uses the operand to jump that number of bytes forward or backword, so the assembler has to figure out the signed displacement from the current address and stuff it into the instruction operand.  If the displacement is more than what 16 bits can represent, then the assembler must select the 32-bit jump instruction.  I know nothing about W32DASM, and this is a MASM form.  Usually an assembler will output an object file which has addresses relative to the segments (.CODE, .DATA.,.DATA?, etc). Included with these displacements is relocation information which the linker uses to make absolute addresses for the exe file.  Ratch </div><br /><br />And when you use CALL?</div>
    <div class="meta">Posted on 2004-01-31 22:30:44 by Maddox</div>
   </div>
   <div class="post" id="post-132227">
    <div class="subject"><a href="#post-132227">addressing</a></div>
    <div class="body">It is the same, just that there is no 8bit variation of call just the 32bit.</div>
    <div class="meta">Posted on 2004-01-31 22:40:23 by roticv</div>
   </div>
   <div class="post" id="post-132228">
    <div class="subject"><a href="#post-132228">addressing</a></div>
    <div class="body">Maddox,<br /><div class="quote">And when you use CALL?</div><br />A CALL is used when you want the return address of the next instruction to be first PUSHed onto the stack.  Then the CALL instruction does a  JMP to the specified location.  After the processing is finished at that location where a subroutine resides, a RET instruction is coded.  This takes the top stack entry and uses it to JMP to where if came from. That is all explained in the x86 documentation.  This is the last basic question I will answer.  Ratch</div>
    <div class="meta">Posted on 2004-01-31 22:52:14 by Ratch</div>
   </div>
   <div class="post" id="post-132229">
    <div class="subject"><a href="#post-132229">addressing</a></div>
    <div class="body"><div class="quote"><br />Maddox,<br />Before any of us take a crack at answering you, why don't you explain either by code example or prose, what you mean by relative, direct, or indirect addressing.  Then we will all be singing from the same song book.  Ratch </div><br /><br />What is there to explain? His question was crystal clear.</div>
    <div class="meta">Posted on 2004-01-31 23:19:39 by comrade</div>
   </div>
   <div class="post" id="post-132232">
    <div class="subject"><a href="#post-132232">addressing</a></div>
    <div class="body"><div class="quote"><br />If the displacement is more than what 16 bits can represent, then the assembler must select the 32-bit jump instruction.<br /></div><br />Wrong. It's when the displacement cannot be expressed as a signed byte.<br /><br />Also, it's worth mentioning that the displacement is calculated from the byte *after* the opcode - ie, if you're at adress 8 and doing &quot;jmp $+10&quot;, this would be encoded &quot;EB 00&quot;. If you're at address 10 doing &quot;jmp 8&quot;, you get &quot;EB FC&quot;. (Modulu-2 addition: (0x10 + 0x02) + 0xFC = 0x08).<br /><br />Maddox, perhaps this answer is simpler. There's a number of different ways to do the CALL and JMP instructions. Of the simple ones, there's EB (direct jump, signed byte EIP-displacement), E9 (direct jump, signed dword EIP-displacement), E8 (direct call, signed dword EIP-displacement). FF25 (indirect jmp, absolute dword address), FF15 (indirect call, absolute dword address).<br /><br />Note that indirect means just that - the CPU looks at the dword specified in the absolute address, specified by the opcode, fetches the dword address there, and calls/jmps to that location.<br /><br />To complicate matters, there's scale+index+base forms (stuff like &quot;call &quot;), inter-segment jump/call, et cetera. And of course I'm assuming 32bit code, stuff looks a bit different in 16bit.</div>
    <div class="meta">Posted on 2004-02-01 00:08:22 by f0dder</div>
   </div>
   <div class="post" id="post-132237">
    <div class="subject"><a href="#post-132237">addressing</a></div>
    <div class="body">comrade,<br /><div class="quote">What is there to explain? His question was crystal clear</div><br />Then why don't you take a turn at answering it? Ratch</div>
    <div class="meta">Posted on 2004-02-01 01:19:37 by Ratch</div>
   </div>
   <div class="post" id="post-132238">
    <div class="subject"><a href="#post-132238">addressing</a></div>
    <div class="body">f0dder,<br /><div class="quote">Wrong. It's when the displacement cannot be expressed as a signed byte.</div><br />Yes, you are correct.  The switchover occurs at the byte limit.  Sorry for the confusion.  Ratch</div>
    <div class="meta">Posted on 2004-02-01 01:23:32 by Ratch</div>
   </div>
   <div class="post" id="post-132240">
    <div class="subject"><a href="#post-132240">addressing</a></div>
    <div class="body">Thanks for the information guys, it is much appreciated.</div>
    <div class="meta">Posted on 2004-02-01 01:50:23 by Maddox</div>
   </div>
  </div>
 </body>
</html>