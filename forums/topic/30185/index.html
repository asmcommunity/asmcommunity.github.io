<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>FNV-1 hashing algorithm - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30185" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=30185">FNV-1 hashing algorithm</a></p>
   <div class="post" id="post-212871">
    <div class="subject"><a href="#post-212871">FNV-1 hashing algorithm</a></div>
    <div class="body">Ok, I&#039;ve started working on my own version of h2incn - a program that will parse C header files and convert them into Nasm compatible .inc files. After creating the initial program outline I am now ready to begin adding in the preprocessing support.<br /><br />One of the things that I need is a fast way of performing lookups of defines and typedefs. I&#039;ve settled on using hash maps and the hash function algorithm FNV-1 which, according to the authors, provides for a nice dispersion across a hash map. Thus I begin by defining a hash map to contain the key/value pairs and develop the hashing function.<br /><br />I want the hashing function and the hash map to be capable of holding arbitrary types and data sizes. Thus the routines being developed do not depend on simple character strings (although you can indeed supply them to the functions). That way, the routines may be used to hold objects of all types for any purpose ( token processing, game world objects, in-memory databases, caching, etc. ).<br /><br />The following is my Nasm modified version of the FNV-1 hash algorithm for use in both 32-bit and 64-bit systems. Note that the 32-bit version uses the standard C calling convention while the 64-bit version uses either Windows or Linux fastcall calling conventions. It may be optimized further (an exersize left for the reader) but I&#039;m quite happy with it. I would love to know if others find use for it and what their collision findings are...<br /><br /><pre><code><br />;<br />; FNV1HASH.ASM<br />;<br />; Copyright (C)2010 Rob Neff<br />; Source code is licensed under the new/simplified 2-clause BSD OSI license.<br />;<br />; This function implements the FNV-1 hash algorithm.<br />; This source file is formatted for Nasm compatibility although it<br />; is small enough to be easily converted into another assembler format.<br />;<br />; Example C/C++ call:<br />;<br />; #ifdef __cplusplus<br />; extern &quot;C&quot; {<br />; #endif<br />;<br />; unsigned int FNV1Hash(char *buffer, unsigned int len, unsigned int offset_basis);<br />;<br />; #ifdef __cplusplus<br />; }<br />; #endif<br />;<br />; int hash;<br />;<br />; /* obtain 32-bit FNV1 hash */<br />; hash = FNV1Hash(buffer, len, 2166136261);<br />;<br />; /* if desired - convert from a 32-bit to 16-bit hash */<br />; hash = ((hash &gt;&gt; 16) ^ (hash &amp; 0xFFFF));<br />;<br /><br /><br /><br />%ifidni __BITS__,32<br />;<br />; 32-bit C calling convention<br />;<br /><br />%define buffer <br />%define len <br />%define offset_basis <br /><br />global _FNV1Hash<br /><br />_FNV1Hash:<br />&nbsp;  push ebp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; set up stack frame<br />&nbsp;  mov&nbsp; ebp, esp<br />&nbsp;  push esi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; save registers used<br />&nbsp;  push edi<br />&nbsp;  push ebx<br />&nbsp;  push ecx<br />&nbsp;  push edx<br /><br />&nbsp;  mov&nbsp; esi, buffer&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;esi = ptr to buffer<br />&nbsp;  mov&nbsp; ecx, len&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;ecx = length of buffer (counter)<br />&nbsp;  mov&nbsp; eax, offset_basis&nbsp; &nbsp; &nbsp; ;set to 2166136261 for FNV-1<br />&nbsp;  mov&nbsp; edi, 1000193h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;FNV_32_PRIME = 16777619<br />&nbsp;  xor&nbsp; ebx, ebx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;ebx = 0<br />nextbyte:<br />&nbsp;  mul&nbsp; edi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;eax = eax * FNV_32_PRIME<br />&nbsp;  mov&nbsp; bl, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;bl = byte from esi<br />&nbsp;  xor&nbsp; eax, ebx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;al = al xor bl<br />&nbsp;  inc&nbsp; esi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;esi = esi + 1 (buffer pos)<br />&nbsp;  dec&nbsp; ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;ecx = ecx - 1 (counter)<br />&nbsp;  jnz&nbsp; nextbyte&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;if ecx != 0, jmp to NextByte<br /><br />&nbsp;  pop&nbsp; edx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; restore registers<br />&nbsp;  pop&nbsp; ecx<br />&nbsp;  pop&nbsp; ebx<br />&nbsp;  pop&nbsp; edi<br />&nbsp;  pop&nbsp; esi<br />&nbsp;  mov&nbsp; esp, ebp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; restore stack frame<br />&nbsp;  pop&nbsp; ebp<br />&nbsp;  ret&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; eax = fnv1 hash<br /><br />%elifidni __BITS__,64<br />;<br />; 64-bit function<br />;<br /><br />%ifidni __OUTPUT_FORMAT__,win64<br />;<br />; 64-bit Windows fastcall convention:<br />;&nbsp; &nbsp; ints/longs/ptrs: RCX, RDX, R8, R9<br />;&nbsp; &nbsp;  floats/doubles: XMM0 to XMM3<br />;<br />global FNV1Hash<br /><br />FNV1Hash:<br />&nbsp;  xchg rcx, rdx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;rcx = length of buffer<br />&nbsp;  xchg r8, rdx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;r8 = ptr to buffer<br /><br />%elifidni __OUTPUT_FORMAT__,elf64<br />;<br />; 64-bit Linux fastcall convention<br />;&nbsp; &nbsp; ints/longs/ptrs: RDI, RSI, RDX, RCX, R8, R9<br />;&nbsp; &nbsp;  floats/doubles: XMM0 to XMM7<br />;<br />global _FNV1Hash<br /><br />_FNV1Hash:<br />&nbsp;  mov&nbsp; rcx, rsi<br />&nbsp;  mov&nbsp; r8, rdi<br /><br />%endif<br /><br />&nbsp;  mov&nbsp; rax, rdx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;rax = offset_basis - set to 14695981039346656037 for FNV-1<br />&nbsp;  mov&nbsp; r9, 100000001B3h&nbsp; &nbsp; &nbsp;  ;r9 = FNV_64_PRIME = 1099511628211<br />&nbsp;  mov&nbsp; r10, rbx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;r10 = saved copy of rbx<br />&nbsp;  xor&nbsp; rbx, rbx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;rbx = 0<br />nextbyte:<br />&nbsp;  mul&nbsp; r9&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;rax = rax * FNV_64_PRIME<br />&nbsp;  mov&nbsp; bl, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;bl = byte from r8<br />&nbsp;  xor&nbsp; rax, rbx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;al = al xor bl<br />&nbsp;  inc&nbsp; r8&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;inc buffer pos<br />&nbsp;  dec&nbsp; rcx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;rcx = rcx - 1 (counter)<br />&nbsp;  jnz&nbsp; nextbyte&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;if rcx != 0, jmp to nextbyte<br />&nbsp;  mov&nbsp; rbx, r10&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;restore rbx<br />&nbsp;  ret&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;rax = fnv1 hash<br /><br />%endif<br /></code></pre><br /><br />Note the difference in housekeeping required in 32-bit code compared to it&#039;s 64-bit big brother. As a leaf function(a function which makes no other calls) this code becomes incredibly small and fast. The function prologue/epilogue can be made ridiculously easy on 64-bit systems using the fastcall convention.<br /><br />Optimizing for register pressure is so much simpler since Windows and Linux allow us to trash the R10 and R11 registers along with the registers used for parameters.<br /><br />In a nutshell: keep your assembly code small, your parameter list within the fastcall convention, create leaf functions if you can (unless calling your own functions), and write portable code.&nbsp; :)</div>
    <div class="meta">Posted on 2010-08-21 15:26:31 by p1ranha</div>
   </div>
   <div class="post" id="post-212887">
    <div class="subject"><a href="#post-212887">Re: FNV-1 hashing algorithm</a></div>
    <div class="body">Btw, pre-dividing by symbol-length might be nice, too. Below are statistics from a C++ preprocessor parser of mine, parsing the whole &lt;windows.h&gt;&nbsp; tree:<br /><br /><pre><code><br />time0 = 187<br />Bench results:<br />	hashtab2::find:	avg=215/259		min=47	last=47	max=164635, count=181320<br />	hashtab2::add:	avg=198/273		min=47	last=152	max=77302, count=17947<br />MaxSymSize = 70<br />Sym[1] = 0<br />Sym[2] = 5<br />Sym[3] = 7<br />Sym[4] = 128<br />Sym[5] = 117<br />Sym[6] = 167<br />Sym[7] = 264<br />Sym[8] = 429<br />Sym[9] = 539<br />Sym[10] = 638<br />Sym[11] = 755<br />Sym[12] = 871<br />Sym[13] = 881<br />Sym[14] = 897<br />Sym[15] = 818<br />Sym[16] = 807<br />Sym[17] = 798<br />Sym[18] = 856<br />Sym[19] = 781<br />Sym[20] = 786<br />Sym[21] = 789<br />Sym[22] = 804<br />Sym[23] = 671<br />Sym[24] = 579<br />Sym[25] = 571<br />Sym[26] = 522<br />Sym[27] = 471<br />Sym[28] = 431<br />Sym[29] = 404<br />Sym[30] = 349<br />Sym[31] = 318<br />Sym[32] = 256<br />Sym[33] = 217<br />Sym[34] = 185<br />Sym[35] = 163<br />Sym[36] = 98<br />Sym[37] = 121<br />Sym[38] = 87<br />Sym[39] = 67<br />Sym[40] = 45<br />Sym[41] = 50<br />Sym[42] = 35<br />Sym[43] = 30<br />Sym[44] = 32<br />Sym[45] = 19<br />Sym[46] = 19<br />Sym[47] = 12<br />Sym[48] = 12<br />Sym[49] = 9<br />Sym[50] = 9<br />Sym[51] = 6<br />Sym[52] = 3<br />Sym[53] = 4<br />Sym[54] = 5<br />Sym[55] = 2<br />Sym[56] = 3<br />Sym[57] = 0<br />Sym[58] = 0<br />Sym[59] = 1<br />Sym[60] = 0<br />Sym[61] = 1<br />Sym[62] = 1<br />Sym[63] = 0<br />Sym[64] = 0<br />Sym[65] = 0<br />Sym[66] = 0<br />Sym[67] = 0<br />Sym[68] = 0<br />Sym[69] = 1<br />Sym[70] = 1<br /></code></pre></div>
    <div class="meta">Posted on 2010-08-22 06:17:59 by Ultrano</div>
   </div>
   <div class="post" id="post-213027">
    <div class="subject"><a href="#post-213027">Re: FNV-1 hashing algorithm</a></div>
    <div class="body">Also see the CrapWow (?) Hash:<br /><br />http://www.team5150.com/~andrew/noncryptohashzoo/CrapWow.html<br /><br />with inlined GAS and C implementations.</div>
    <div class="meta">Posted on 2010-09-01 11:51:44 by Wolfshook</div>
   </div>
  </div>
 </body>
</html>