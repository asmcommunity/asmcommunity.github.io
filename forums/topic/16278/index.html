<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>IRET causes page fault (0D) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16278" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=16278">IRET causes page fault (0D)</a></p>
   <div class="post" id="post-126424">
    <div class="subject"><a href="#post-126424">IRET causes page fault (0D)</a></div>
    <div class="body">Hy, I am continuing to play with W2k device drivers, and this time I've achieved a <br />result I've desired for a long time: to hook an interrupt under w2k.<br />I was using as a guideline a good free sample driver from <a target="_blank" href="www.beyondlogic.org">www.beyondlogic.org</a> but <br />it is written in C. Anyway it works and I hope to translate it in assembly because <br />it shows the &quot;legal&quot; way for interrupt hooking under w2k: IoConnectInterrupt() and <br />DPCs.<br />The driver contains, among others, those 2 functions: the &quot;ISR&quot; and the DPC.<br />One may suppose that the ISR, whose goal is only to request the DPC, is a true ISR but <br />it is not the case. It doesn't terminate with an IRET and the address that <br />IoConnectInterrupt puts in the IDT is another one. So I decided to go for a <br />manual entry of my ISR's address into the IDT and wrote a driver in pure assembly.<br />The success is partial, I've been able to install my (short) ISR, it is correctly executed when I <br />generate the interrupt but....here is the hell!! I doesn't succeed in returning from my ISR!<br />I am completely lost into the labyrinth of the Kernel code.... :)<br />If I put an IRET instruction at the end of the routine it causes a page fault. Why? <br />The selector is 0008, system code. I only changed the four bytes of the vector with <br />the address of my ring0 routine...I doesn't touched the selector which should be the <br />same of my driver because the ISR is executed well. <br />So the question is? How can I return??<br /><br />Regards,<br />fooCoder</div>
    <div class="meta">Posted on 2003-12-03 14:40:51 by fooCoder</div>
   </div>
   <div class="post" id="post-126425">
    <div class="subject"><a href="#post-126425">grammar...</a></div>
    <div class="body">#define doesn't    don't  <br /><br />Pardon...but I am very tired :)</div>
    <div class="meta">Posted on 2003-12-03 14:44:09 by fooCoder</div>
   </div>
   <div class="post" id="post-126480">
    <div class="subject"><a href="#post-126480">IRET causes page fault (0D)</a></div>
    <div class="body">Hi fooCoder<br /><br />That's a nice example showing how to hook hardware interrupts via IoConnectInterrupt, thanks.  For software interrupts it seems there's still no 'official' way to do that other than modifying the IDT directly I suppose.  <br /><br />From the sounds of it you went the SIDT route to point to your new interrupt handler, then I assume you generated that interrupt to test it out.  There is one issue I'm aware of that might be the source of your trouble, depending on how you generated the 'fake' interrupt.  This may have no bearing on your hardware int, but it's worth keeping in mind anyway. From my notes,<br /><br /><br />An interrupt can be generated by:<br /><br />1. Inserting directly into code, i.e. as &quot;INT 6&quot;, or 06CDh<br /><br />In this case, an &quot;INT x&quot; will push as a return address a pointer to the address *after* the INT<br /> <br />2. Create a condition which creates the desired interrupt<br />   i.e. &quot;lea eax, eax&quot; (C08Dh) generates an &quot;Invalid Opcode&quot; error INT 6<br /><br />In this case, the return address points to the line which *caused* the error, so ESP in the Interrupt handling routine must be adjusted by 2 bytes (or however many bytes the faulting instruction is)<br /><br />...<br />add dword ptr , 2<br />iretd<br /><br /><br />OK, this is one issue that might be giving you what sounds like a stack problem. Note also the use of the 32 bit operand IRETD and not the 16 bit IRET.  If I remember correctly this caused me problems and IRETD was necessary.  Actually, I just resurrected my old Win98 code and got it running OK under a Win2K driver, then I changed the IRETD to an IRET and got a nice BSOD, so... ;-)<br /><br /><br />There is also this disclaimer in Undocument Windows NT:<br /><br />---------------------------------<br />You can apply the same technique for hooking software interrupts to hook hardware interrupts or exceptions although you should use the documented loConnectlnterrupt() function to hook hardware interrupts. You have to write an interrupt handler keeping in mind the type of interrupt it is hooking into because the stack frame might differ in various situations. The new interrupt handler must be written in Assembly language because of the restrictions imposed by 32-bit compilers.<br />--------------------------------<br /><br />I don't quite understand the last line considering the C code example you mentioned, but the text clearly warns about being careful with the stack frame depending on the type of interrupt.  If you're having problems with a specific interrupt I could throw it in my code and see if it works.<br /><br />Regards,<br />Kayaker</div>
    <div class="meta">Posted on 2003-12-04 01:20:01 by Kayaker</div>
   </div>
   <div class="post" id="post-126499">
    <div class="subject"><a href="#post-126499">A possible solution....</a></div>
    <div class="body">Hy Kayaker,<br /><br />thank you for your precious advice, I've experienced with INT D9 before, to test how to <br />write correctly into the IDT and then I've turned on INT vector 37 which is IRQ7 - LPT1.<br />I'll try to test the different behaviour of different interrupt types to solve those <br />stack problems. I've &quot;discovered&quot; that one might use particular care when using ESI register <br />in driver routines, like DriverUnload()...so I push it before and pop after the ESI code.<br /><br />After writing my post I found one possible solution to the IRETD problem: I looked at <br />the 37h vector before I installed my ISR. It simply pointed to the following code:<br /><br />push 00000037; vector number<br />jmp  FixedAddress; Fixed address into the kernel<br /><br />I noticed that other vectors use the same technique, they push their number and jumps<br />to a fixed routine.<br />So, I changed my faulting IRET with the same code! And It works!!!<br />Once my ISR has completed its work, it calls the original code...<br />But note that FixedAddress changes between different subversions of win2k! So I need to <br />rebuild my driver for every machine because the jump is fixed.<br />A better way should be to jump at the old vector address directly. I implemented this <br />solution too because I save the original vector into four bytes and restore it when <br />DriverUnload.<br /><br />.data<br />;<br /><br />b1  db 0<br />b2  db 0<br />b3  db 0<br />b4  db 0<br /><br />;<br /><br />Note that I try to write the original vector in little endian form into the 4 bytes and <br />then I read it in esi. Esi should contain the right address and jump to it.<br />;<br />mov edi, offset b1<br />mov esi, <br />jmp esi; jmp to the original vector saved in b1,b2,b3,b4<br />;<br /><br />It works fine but I am uncertain because the byte values I expect to read from the old vector, <br />and that I substitute with the corresponding ones of my ISR, are different from what I expect.<br />Anyway my ISR installs itself correctly and restore the old vector correctly after DriverUnload.<br />The jump works fine...is it a coincidence??<br /><br />Now I've another annoying problem....but it is ridiculous in respect of the previous...my driver <br />code doesn't succeed in unmasking the IRQ 7! I use this code (in DriverDispatch where I do all but <br />I tried in DriverEntry too):<br /><br />;;;;;<br />	;UNMASK IRQ7 on PIC 1<br />	mov  dx, 00021H<br />	in   al, dx; usually 0E0h<br />        shl  al, 1<br />	shr  al, 1<br />	;mov  al, 060h; ANOTHER DIRECT WAY ON MY PC<br />        out  dx, al<br />	;Enable IRQ generation on LPT1<br />	mov  edx, 0037Ah<br />        in   al, dx<br />        or   al, 010H<br />        out  dx, al<br />;;;;;<br />This code works well in DOS mode but not into my driver...it doesn't unmask the IRQ.<br />When I try this code from the debugger it works well, in particular OUT 60h on port 21h <br />unmasks the IRQ, but when I exit the debugger IRQ7 is masked again so my ISR is ignored.<br />How could I test my driver then? I ran the C code sample which contains &quot;exactly&quot; the same <br />instruction:<br /><br />mov         edx,37Ah<br />in          al,dx<br />or          al,10h<br />out         dx,al<br /><br />Once I've ran the C driver the IRQ7 remains unmasked forever and this allows me to use my <br />ISR....is it possible that the C-DPC, which remains installed, periodically re-unmask the IRQ?<br /><br />I don't know...what I can say is that when the IRQ7 is unmasked my ISR works.<br /><br />A few words about the &quot;equipment&quot; I use: A primitive homemade cable link connects DATA BIT 0 with the -ACK PIN.<br />3 leds are normally attached LPT1. I use another driver to send values directly to the parallel port. <br />Certain values cause the leds to turn on. But if I send a 1, the signal re-enters via the -ACK pin and <br />causes an IRQ to happen. Then my ISR starts and I notify this because it turns on a particular led.<br />Then I manually send a 0 to the port and turn off all the leds.<br />If I set bit 1 again...the nice game continues :)<br /><br />I don't know if someone can be interested in viewing all the source code, but when I'll be finished <br />I could post it.<br /><br />Regards,<br />fooCoder</div>
    <div class="meta">Posted on 2003-12-04 04:19:52 by fooCoder</div>
   </div>
   <div class="post" id="post-126636">
    <div class="subject"><a href="#post-126636">damn</a></div>
    <div class="body">Hy,<br /><br />I am trying all sort of combinations...but I don't succeed in unmasking IRQ7.<br /><br />This is the code and it should work:<br /><br />                   ;code<br />                   mov  dx, 0x0021<br />                   in   al, dx<br />                   shl  al, 1<br />                   shr  al, 1<br />                   out  dx, al; al = 60h<br /><br />The most frustrating thing is that, when I debug my driver, I can also write to the ports directly by the debugger...and in this case the IRQ is unmasked until I remain into the Debugger itself. When I exit and then reenter the Debugger IRQ7 is masked again!<br /><br />So it is the system who is periodically masking the IRQs....(or the DBG when it finishes)....<br /><br />I don't know if it is a matter of code privilege....I can access other ports without problems.<br />Is there a system map of the IRQ status somewhere in memory?<br /><br />Summarizing, it seems that this code, executed from a ring 0 driver, is simply ignored while the same Out from a Debugger causes the desired unmasking.<br /><br />Can anyone help me?<br /><br />Regards,<br />fooCoder</div>
    <div class="meta">Posted on 2003-12-05 06:06:41 by fooCoder</div>
   </div>
   <div class="post" id="post-126659">
    <div class="subject"><a href="#post-126659">IRET causes page fault (0D)</a></div>
    <div class="body">Hi<br /><br />I'm not really familiar with unmasking IRQ's, but is it possible that since (if) you are jumping to the original interrupt handler from your ISR, instead of IRETD to whereever you generated the hardware exception, then all you are doing is passing control back to Windows which is by default remasking the IRQ?  In reality this may be what one might often do, chain back to the previous ISR after you are done handling that particular interrupt, but in certain cases you may not want to do that.  <br /><br />If you yourself are generating the exception/interrupt in some manner, and there is little likelihood of it coming from an external source, then I don't know that there would be much reason to return control to the original handler.  Normally you would check this in your ISR, you could insert a unique sequence of bytes just before the faulting instruction and test for them as an offset from ESP once inside your ISR, then you either jmp cs: or IRETD.  You may need this controlling step for an effective hook/filter.<br /><br />Cheers,<br />Kayaker</div>
    <div class="meta">Posted on 2003-12-05 10:54:37 by Kayaker</div>
   </div>
   <div class="post" id="post-126666">
    <div class="subject"><a href="#post-126666">IRETD works well!</a></div>
    <div class="body">Hy Kayaker,<br /><br />a good new! As you said IRETD works!!! :) Now I don't need to do those risky jumps or to re-pass control to the original handler. It is wonderful! :)<br /><br />The &quot;bad&quot; new is that, I think so after further investigations, IRQ masking is completely managed somewhere into the core of W2K. It is not so surprisingly because the same IRQ can be shared between different drivers/devices.<br /><br />When a driver call IoConnectInterrupt the system creates a particular object that is responsible for the managing of that particular IRQ. I think that the entry in the IDT points to that object, this to the &quot;fake&quot; ISR and that requests the DPC. In the C sample there aren't I/O operations directed to port 20/21 (PIC). It is W2K that take care of all this!<br /><br />It seems that it is not the original handler (which I now avoid with IRETD) that is responsible for the masking.<br /><br />So, unless I discover how to directly unmask (and keep unmasked) those IRQs, which I consider almost impossible, I can only try to directly translate the C sample and put my operations into the DPC &quot;legally&quot; :)<br /><br />But, once unmasked, I could hook directly the vector...because it works. :)<br /><br />Greetings,<br />fooCoder</div>
    <div class="meta">Posted on 2003-12-05 11:59:25 by fooCoder</div>
   </div>
   <div class="post" id="post-126670">
    <div class="subject"><a href="#post-126670">IRET causes page fault (0D)</a></div>
    <div class="body">Why hook it directly and mess with masking yourself, if there's a 'legal' and well-defined method of doing it? Does it bring any advantages at all?</div>
    <div class="meta">Posted on 2003-12-05 12:14:29 by f0dder</div>
   </div>
   <div class="post" id="post-126792">
    <div class="subject"><a href="#post-126792">....</a></div>
    <div class="body">Hy Fodder,<br /><br />There are two reasons:<br /><br />[1] - The &quot;legal&quot; method is not well documented as it should be (in my personal opinion). I am going to translate the C driver in ASM because MS doesn't give alternatives. Their DDK is not intended for people who want to &quot;understand&quot; how to write a Device Driver. A lot of objects and functions are undocumented but you have to use them into your &quot;C&quot; code.<br />[2] - Exact cognition of what I am doing. It is related to the first reason and in general is the explanation of why I am using assembly to code.<br /><br />Regards,<br />fooCoder</div>
    <div class="meta">Posted on 2003-12-06 08:29:23 by fooCoder</div>
   </div>
   <div class="post" id="post-126794">
    <div class="subject"><a href="#post-126794">IRET causes page fault (0D)</a></div>
    <div class="body">As long as you don't think direct hooking is the proper approach for release applications :)</div>
    <div class="meta">Posted on 2003-12-06 08:33:53 by f0dder</div>
   </div>
   <div class="post" id="post-126909">
    <div class="subject"><a href="#post-126909">Why a &quot;legal&quot; way?</a></div>
    <div class="body">Just acheive a result and move on. Personally I first save the original interrupt vector than over write it than restore it when done. The reason the IRETD isn't working is because the driver is in the same context as the interrupts and IRETD is an intersegment jump. So you are getting a fault.</div>
    <div class="meta">Posted on 2003-12-07 11:30:46 by mrgone</div>
   </div>
   <div class="post" id="post-126968">
    <div class="subject"><a href="#post-126968">IRET causes page fault (0D)</a></div>
    <div class="body">Hi<br /><br />Just to clarify, IRETD is used to return from an ISR whether there be a task switch or not, the difference lies in how it behaves.  The fact that there may or may not be an intersegment jump (CPL=0 to CPL=3) should have no bearing on whether there's a fault.  IRETD simply reverses what the processor does when calling an interrupt or exception.  This is explained best by the Intel manual Vol 1 Chap. 6:<br /><br />--------------------------<br />If the code segment for the handler procedure has the same privilege level as the currently<br />executing program or task, the handler procedure uses the current stack; if the handler executes at a more privileged level, the processor switches to the stack for the handler?s privilege level.<br /><br />...<br /><br />A return from an interrupt or exception handler is initiated with the IRET instruction. The IRET instruction is similar to the far RET instruction, except that it also restores the contents of the EFLAGS register for the interrupted procedure:<br /><br />When executing a return from an interrupt or exception handler from the same privilege level as the interrupted procedure, the processor performs these actions:<br />1. Restores the CS and EIP registers to their values prior to the interrupt or exception.<br />2. Restores the EFLAGS register.<br />3. Increments the stack pointer appropriately<br />4. Resumes execution of the interrupted procedure.<br /><br />When executing a return from an interrupt or exception handler from a different privilege level than the interrupted procedure, the processor performs these actions:<br />1. Performs a privilege check.<br />2. Restores the CS and EIP registers to their values prior to the interrupt or exception.<br />3. Restores the EFLAGS register.<br />4. Restores the SS and ESP registers to their values prior to the interrupt or exception,<br />resulting in a stack switch back to the stack of the interrupted procedure.<br />5. Resumes execution of the interrupted procedure.<br />--------------------------<br /><br /><br />As for doing things in the &quot;legal&quot; way, unless you're just doing a quick ring 0 hack for personal reasons, I would have to agree you shouldn't tie up the CPU in your ISR, or disable interrupts for extended periods of time with CLI/STI to prevent reentrancy issues, especially if you're doing any kind of I/O operations.  This is the kind of thing DPC's seemed designed for, something I hope to learn more about, and the DDK kind of emphasizes with an inescapable logic:<br /><br />--------------------------<br />Because ISRs must execute as quickly as possible, drivers must usually postpone the completion of servicing an interrupt until after the ISR returns. Therefore, the system provides support for deferred procedure calls (DPCs), which can be queued from ISRs and which are executed at a later time and a lower IRQL than the ISR.<br />--------------------------<br /><br />Kayaker</div>
    <div class="meta">Posted on 2003-12-07 22:03:32 by Kayaker</div>
   </div>
   <div class="post" id="post-126975">
    <div class="subject"><a href="#post-126975">Not quite</a></div>
    <div class="body">An intersegment jump means it changes segments and has nothing to do with privilege level. An IRETD instruction is a RET Far instruction meaning intersegment jump.</div>
    <div class="meta">Posted on 2003-12-07 23:31:05 by mrgone</div>
   </div>
   <div class="post" id="post-126982">
    <div class="subject"><a href="#post-126982">IRET causes page fault (0D)</a></div>
    <div class="body">OK, maybe it's a matter of semantics then.  You are correct that an IRET is an intersegment (far) jump in that it makes use of the saved CS register to determine which address, as a long pointer, to return to, even if there is no change in segments (or privilege level) per se, this is my understanding of the matter.  <br /><br />When you used the term 'context' and intersegment jump I thought you meant it to indicate a true segment/ring change (i.e cs: 08 -&gt; 1B).  Other than that I don't understand what you were getting at, why the fact that the ISR and interrupt may be in the same driver context has anything to do why IRETD might cause a fault.  It doesn't matter, all I was trying to get across was that IRETD should work in either case without faulting.</div>
    <div class="meta">Posted on 2003-12-08 01:28:09 by Kayaker</div>
   </div>
   <div class="post" id="post-126993">
    <div class="subject"><a href="#post-126993">The CS selector</a></div>
    <div class="body">I beleive is 02. The Windows system uses it and the driver uses the same CS selector. There for it would not be an intersegment jump. It needs a different CS selector for IRETD. Atleast that's as far as I got with it. The system uses all the memory in one big 4gig flat memory space. Look at the descriptors. The data segment is selector 10h.<br /><br />This is actually Win2K GDT at  logical address 80036000h and the second 64 bit entry is the system CS segment descriptor as indicated by type feild &quot;9B&quot; and the base is 0 and upper limit is actually CFFFFh X 4k granularity bit set =3,489656832d. Almost the full 4 gig.<br /><br />00000050  00 00 00 00 00 00 00 00-FF FF 00 00 00 9B CF 00   ................<br />00000060  FF FF 00 00 00 93 CF 00-FF FF 00 00 00 FB CF 00   ................<br />00000070  FF FF 00 00 00 F3 CF 00-AB 20 00 F0 22 8B 00 80   ......... ..&quot;...<br />00000080  01 00 00 F0 DF 93 C0 FF-FF 0F 00 00 00 F3 40 00   ..............@.<br />00000090  FF FF 00 04 00 F2 00 00-00 00 00 00 00 00 00 00   ................<br />000000A0  68 00 40 00 47 89 00 80-68 00 A8 00 47 89 00 80   h.@.G...h...G...</div>
    <div class="meta">Posted on 2003-12-08 02:46:15 by mrgone</div>
   </div>
   <div class="post" id="post-127369">
    <div class="subject"><a href="#post-127369">...working...</a></div>
    <div class="body">Hi,<br /><br />I am happy that my original thread has stimulated such interesting observations. :)<br /><br />To Fodder : No, I'd be VERY careful before releasing and application with a direct interrupt hook! I am working on my pc alone, where I can experiment at my own risk. :)<br /><br />My goal is now to translate this &quot;famous&quot; C example into asm. It seemed to me a relatively easy task but it is not so.<br /><br />I've translated the DriverEntry function, with HalGetInterruptVector and IoConnectInterrupt, without having syntax problems...the driver is correctly compiled.<br /><br />But I get a KeBugException (another page fault =&gt; KERNEL MODE EXCEPTION NOT HANDLED) at the IoCreateDevice function.<br /><br /><br />NTSTATUS <br />  IoCreateDevice(<br />  IN PDRIVER_OBJECT  DriverObject,<br />  IN ULONG  DeviceExtensionSize,<br />  IN PUNICODE_STRING  DeviceName  OPTIONAL,<br />  IN DEVICE_TYPE  DeviceType,<br />  IN ULONG  DeviceCharacteristics,<br />  IN BOOLEAN  Exclusive,<br />  OUT PDEVICE_OBJECT  *DeviceObject<br />  );<br /><br /><br /><br />This is the disassembly of the working C driver:<br /><br />...........................<br />  000103A9: 8B 5D 08           mov         ebx,dword ptr <br />  000103AC: 8D 45 FC           lea         eax,<br />  000103AF: 50                 push        eax<br />  000103B0: 6A 01              push        1<br />  000103B2: 6A 00              push        0<br />  000103B4: 8D 45 F0           lea         eax,<br />  000103B7: 6A 22              push        22h<br />  000103B9: 50                 push        eax<br />  000103BA: 6A 10              push        10h<br />  000103BC: 53                 push        ebx<br />  000103BD: FF 15 84 04 01 00  call        dword ptr [__imp__IoCreateDevice@28]<br />  000103C3: 85 C0              test        eax,eax<br />...........................<br /><br />And this is my function (working in other cases) :<br /><br />	lea ecx, DeviceObject; <br />	mov esi, DriverObject; <br />	lea edi, DeviceNameUnicode<br /><br />	push ecx<br />	push 1<br />	push 0<br />	push 022h; DeviceType FILE_DEVICE_PARALLEL_PORT is indeed  = 016h ??<br />	push edi<br />	push 010h; DeviceExtensionSize<br />	push esi<br />	call IoCreateDevice<br /><br />	test eax, eax<br /><br />This funtion works in other cases when DeviceExtensionSize=0 and DeviceType = 8010h.<br />Do you know if I have to change those values? I got them directly from the disassembled code (10h &amp; 22h).<br /><br />Greetings,<br />fooCoder</div>
    <div class="meta">Posted on 2003-12-11 04:46:24 by fooCoder</div>
   </div>
   <div class="post" id="post-127416">
    <div class="subject"><a href="#post-127416">You can cure that...</a></div>
    <div class="body">&quot;KERNEL MODE EXCEPTION NOT HANDLED&quot;<br /><br />   You can block that BSOD by handing both debug exceptions:<br /><br />1 #DB Debug Fault/TrapNo Any code or data reference or the INT 1 instruction.<br /><br />and<br /><br />3 #BP Breakpoint Trap No INT 3 instruction.</div>
    <div class="meta">Posted on 2003-12-11 13:28:18 by mrgone</div>
   </div>
  </div>
 </body>
</html>