<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>COM memory arena? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30157" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=115">DOS &amp; BIOS</a> &raquo; <a href="../?id=30157">COM memory arena?</a></p>
   <div class="post" id="post-212667">
    <div class="subject"><a href="#post-212667">COM memory arena?</a></div>
    <div class="body">So I&#039;m working on a DOS project (writing a game engine in 8086 assembler, to be specific.) I&#039;d like to build it as a COM file, mostly to save myself the hassle of linking individual bits together. If Wikipedia is to be believed, DOS&#039;s memory-management facilities are not available to COM programs; it states that &quot;all memory is available to the application.&quot; This suits me fine, as I wanted a couple facets of memory management to line up with the rest of the engine more neatly, and it wasn&#039;t all that hard to hack up replacements for the routines I need. The thing is, I&#039;m also trying to write the engine to play nicely with its operating environment; I want it to be able to make a nice clean exit and leave the computer in exactly the same state it found it, and I want to make sure that I know how to do my own memory management without clobbering any drivers or other TSR software loaded into conventional memory.<br /><br />I&#039;m currently figuring that it&#039;s a safe assumption that the program will be loaded fairly low in memory, so I don&#039;t need to bother with reading or writing below the start of the program segment, which means that I only need to worry about stuff that&#039;s been loaded under the top boundary of the conventional memory area (it&#039;s my understanding that this is where DOS and drivers tend to go.) I see an entry in the Program Segment Prefix for memory size, and what I&#039;m wondering is if this reflects the actual, physical amount of conventional memory installed, or the amount free when my program was loaded; i.e., can I rely on that value to tell me where I should not write past?</div>
    <div class="meta">Posted on 2010-08-14 14:54:02 by commodorejohn</div>
   </div>
   <div class="post" id="post-212668">
    <div class="subject"><a href="#post-212668">Re: COM memory arena?</a></div>
    <div class="body">Check out the <a target="_blank" href="http://maven.smith.edu/~thiebaut/ArtOfAssembly/CH13/CH13-8.html#HEADING8-103">PSP in AoA 16</a> for a more detailed explanation.<br /><br />I think in general, you are safe to stay within the 64KB segment that is assigned to your COM. DOS is a single-tasking OS, and unless you have many TSR&#039;s loaded, this should be a workable assumption.<br /><br />Anything beyond that, and you are going to want to utilize the <a target="_blank" href="http://www.ctyme.com/intr/int-21.htm">DOS INT 0x21 API</a>. In particular to your question, take a look at <a target="_blank" href="http://www.ctyme.com/intr/rb-2934.htm">INT 0x21, Function 0x48 - Allocate Memory</a>; the notes in that link also have a few hints for you.<br /><br />As for Wikipedia&#039;s statement, it is more to the extent that DOS&#039; memory-management facilities are not <em>implicitly</em> available to COM programs.</div>
    <div class="meta">Posted on 2010-08-14 15:24:47 by SpooK</div>
   </div>
   <div class="post" id="post-212671">
    <div class="subject"><a href="#post-212671">Re: COM memory arena?</a></div>
    <div class="body">Hmm. I see in the Int 21/48 documentation that &quot;COM programs are initially allocated the largest available memory block&quot; - that would seem to support Wikipedia&#039;s description. Is the COM file itself just loaded into the first &lt;= 64KB of that block, then? If not, how do I find out the location and size of the block?</div>
    <div class="meta">Posted on 2010-08-14 16:48:32 by commodorejohn</div>
   </div>
   <div class="post" id="post-212674">
    <div class="subject"><a href="#post-212674">Re: COM memory arena?</a></div>
    <div class="body">Before you can allocate anything in a dos .com program (and most .exe programs), you&#039;ll have to do a &quot;resize memory block&quot; interrupt. After that the &quot;malloc&quot; interrupt should work normally. (Wikipedia doesn&#039;t know everything. :) )<br /><br />You can almost(!) certainly use the entire 64k block - but your stack is at the top of it. You can arbitrarily use memory above that... at some small risk of trashing a TSR or so. The &quot;right&quot; way is to &quot;resize memory block&quot; first (keep the whole 64k unless you&#039;re desperate for every scrap of memory), and then &quot;malloc&quot; as usual.<br /><br />(according to my possibly faulty memory)<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-08-14 19:22:37 by fbkotler</div>
   </div>
   <div class="post" id="post-212675">
    <div class="subject"><a href="#post-212675">Re: COM memory arena?</a></div>
    <div class="body">Hmm, okay. Thanks for the information!</div>
    <div class="meta">Posted on 2010-08-14 19:44:27 by commodorejohn</div>
   </div>
   <div class="post" id="post-212738">
    <div class="subject"><a href="#post-212738">Re: COM memory arena?</a></div>
    <div class="body">Oh, one other thing. If I am going to resize the application block down to something smaller than 64KB, will I have to manually move the stack pointer first?</div>
    <div class="meta">Posted on 2010-08-16 15:07:52 by commodorejohn</div>
   </div>
   <div class="post" id="post-212741">
    <div class="subject"><a href="#post-212741">Re: COM memory arena?</a></div>
    <div class="body"><div class="quote"><br />Oh, one other thing. If I am going to resize the application block down to something smaller than 64KB, will I have to manually move the stack pointer first?<br /></div><br /><br />I would assume that DOS doesn&#039;t do anything else beyond the initial load. So yes, assume you need to move/preserve the stack prior to resizing.</div>
    <div class="meta">Posted on 2010-08-16 18:46:13 by SpooK</div>
   </div>
   <div class="post" id="post-213332">
    <div class="subject"><a href="#post-213332">Re: COM memory arena?</a></div>
    <div class="body">After digging out, dusting off and reviewing several good old DOS programming references (see list below), I&#039;ve compiled a bit more information on this subject...<br /><br />A .COM program is initially allocated *all* available &quot;transient program area&quot; (TPA) memory, in one contiguous block (typically &gt; 500KB), with the PSP at the bottom and the file image loaded immediately above that. The DS, SS, CS and ES segment registers are all loaded with this same base memory address == PSP. The IP is loaded with 100h which is the first byte of the COM file which must be an executable instruction. DOS sets the stack pointer to zero (which is effectively 10000h == 64KB) then pushes one word of zero onto the stack, so SP==0FFFEh when the program first runs (if the block is smaller than 64KB then DOS set the stack pointer to the top of the block minus 2). This zero on top of the stack serves as the return address for the COM program as a whole - i.e. if the COM program executes a NEAR RET instruction, then the zero is popped off the stack and used as the address to continue program execution - and this is where the first word of the PSP comes in (The PSP is located at offset zero). The first word of the PSP is a two byte instruction: &quot;<span class="mono">int 20</span>&quot;, which is the old style method for program termination dating back to MS-DOS version 1.<br /><br />An .EXE program is also initially allocated the whole TPA memory block by default. The EXE file has a header which includes two parameters set by the linker (the minimum required and the maximum desired memory), which tell the DOS loader how much extra memory (above and beyond that required by the program&#039;s code, data and stack), to allocate the program at run time. The linker sets this maximum to 0FFFFh by default, so the loader always gives it as much as it can - i.e. the whole TPA. When DOS loads an EXE program, the DS and ES segment registers are set to point to the PSP, the SS:SP and the CS:IP values are obtained from the EXE header structure prepared by the linker. (The runtime CS and SS values are equal to the values in the DOS header added to the image load address, which is the segment address of the top of the PSP.) Whew!<br /><br />Here is the structure definition of the PSP from the <a target="_blank" href="http://www.amazon.com/Microsoft-MS-DOS-Programmers-Reference-Press/dp/1556153295">MS-Dos Programmer&#039;s Reference</a>:<br /><br /><pre><code>PSP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; STRUC &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;program segment prefix<br />PspInt20 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Int 20h instruction<br />PspNextParagraph &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;segment address of next para<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;reserved<br />PspDispatcher &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db &nbsp; &nbsp; &nbsp;5 DUP (?) &nbsp; &nbsp; &nbsp; ;long call to MS-DOS<br />PspTerminateVector &nbsp; &nbsp; &nbsp;dd &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Termination address (Int 22h)<br />PspControlCVector &nbsp; &nbsp; &nbsp; dd &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;CTRL+C handler (Int 23h)<br />PspCritErrorVector &nbsp; &nbsp; &nbsp;dd &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Critical Err handler (Int 24h)<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;11 DUP (?) &nbsp; &nbsp; &nbsp;;reserved<br />PspEnvironment &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;seg addr of environment<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;23 DUP (?) &nbsp; &nbsp; &nbsp;;reserved<br />PspFCB_1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;16 DUP (?) &nbsp; &nbsp; &nbsp;;default FCB #1<br />PspFCB_2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;16 DUP (?) &nbsp; &nbsp; &nbsp;;default FCB #2<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dd &nbsp; &nbsp; &nbsp;? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;reserved<br />PspCommandTail &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;db &nbsp; &nbsp; &nbsp;128 DUP (?) &nbsp; &nbsp; ;command tail string (default DTA)<br />PSP &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ENDS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;program segment prefix<br /></code></pre><br /><br />(Note that this official definition leaves out one important detail: the first byte of the <span class="mono">PspCommandTail</span> is actually a count of bytes equal to the length of the string which follows.) But the part you are probably most interested in is the <span class="mono">PspNextParagraph</span> member which points to the top of the programs memory block. Here is what the Programmer&#039;s Reference has to say about it:<br /><br /><div class="quote"><strong>PspNextParagraph</strong><br />Specifies the segment address of the first paragraph immediately following the program. (This address does not point to the free memory available for the program to use.) Programs use this field to determine quickly whether they were allocated sufficient memory to run successfully<br /></div><br /><br />Thus, the memory block containing the program is typically much bigger than 64KB and can be computed by: <span class="mono">(PSP.PspNextParagraph - DS) * 16</span>.<br /><br />DOS actually allocates two memory blocks for each program: one for the program and one for a copy of all the &nbsp;environment variables. The <span class="mono">PspEnvironment</span> member points to this other memory block which contains all the ASCIIZ environment variables placed in series and terminated with a zero length string.<br /><br />There is no need to use the memory allocation functions unless you plan on giving some of the memory back. Regarding the DOS Int 21 memory allocation routines, there are three that are useful:<br /><ul><br /><li>Function <strong>48h - Allocate Memory</strong> Call params: AH = 48h, BX = paragraphs (16 bytes each) to be allocated. Return value: AX = segment address of newly allocated block.</li><br /><li>Function <strong>49h - Free Allocated Memory</strong> Call params: AH = 49h, ES - segment address of block to be freed. Return value: None. &nbsp;(CF clear if successful.)</li><br /><li>Function <strong>4Ah - Set Memory Block Size</strong> Call params: AH = 4Ah, BX = new requested block size in paragraphs, ES - segment of block to be modified. Return value: None. (CF clear if successful.)</li><br /></ul><br /><br />In all cases, each of these functions return with the carry flag bit clear if it was successful and set if there was an error. If there was an error, then AX contains the error code. If function 48h or 4Ah fails to allocate the requested size, then BX is returned with the largest available size.<br /><br />So here is an example snippet (taken from Ray Duncan&#039;s book - see below) of a well-behaved .COM program written in ASM which correctly adjusts its stack and reduces its memory block size:<br /><br /><pre><code> &nbsp; &nbsp; &nbsp; &nbsp;org &nbsp; &nbsp; 100h<br />main &nbsp; &nbsp;proc &nbsp; &nbsp;far &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;entry point from DOS (ES =&gt; PSP)<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; sp, OFFSET stk &nbsp;;adjust stack pointer<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ah,4ah &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;func 4Ah - Modify Memory Block<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; bx,400h &nbsp; &nbsp; &nbsp; &nbsp; ;400h paras == 16,384 bytes<br /> &nbsp; &nbsp; &nbsp; &nbsp;int &nbsp; &nbsp; 21h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;call DOS function 4Ah<br /> &nbsp; &nbsp; &nbsp; &nbsp;jc &nbsp; &nbsp; &nbsp;error &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;jump if function failed<br /> &nbsp; &nbsp; &nbsp; &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;our memblk is now 16KB<br /> &nbsp; &nbsp; &nbsp; &nbsp;.<br />error: &nbsp;. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;handle error<br /> &nbsp; &nbsp; &nbsp; &nbsp;.<br /> &nbsp; &nbsp; &nbsp; &nbsp;dw &nbsp; &nbsp; &nbsp;256 dup (?) &nbsp; &nbsp; ;256 byte stack<br />stk &nbsp; &nbsp; equ &nbsp; &nbsp; $ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;base of new stack<br /> &nbsp; &nbsp; &nbsp; &nbsp;.<br /> &nbsp; &nbsp; &nbsp; &nbsp;.<br /></code></pre><br /><br /><br /><br />For low level DOS programming, I would highly recommend the following two Microsoft Press books (used versions are available for mere pennies + shipping):<br /><a target="_blank" href="http://www.amazon.com/Microsoft-MS-DOS-Programmers-Reference-Press/dp/1556153295">MS-DOS Programmer&#039;s Reference</a><br /><a target="_blank" href="http://www.amazon.com/Advanced-MS-DOS-Programming-Microsoft-Programmers/dp/1556151578/">Advanced MS-DOS Programming</a> By Ray Duncan<br /></div>
    <div class="meta">Posted on 2010-10-12 16:16:35 by ridgerunner</div>
   </div>
   <div class="post" id="post-213333">
    <div class="subject"><a href="#post-213333">Re: COM memory arena?</a></div>
    <div class="body">Okay. That&#039;s kind of what I had assumed, but it&#039;s good to get all the details. Thanks for the help!</div>
    <div class="meta">Posted on 2010-10-12 16:22:39 by commodorejohn</div>
   </div>
   <div class="post" id="post-213341">
    <div class="subject"><a href="#post-213341">Re: COM memory arena?</a></div>
    <div class="body"><strong>commodorejohn</strong>,<br /><br />There is also word at PSP:6, it contains number of bytes available in segment for .Com program. Usually it contains value around 0xFF00, but when .Com is loaded in UMA, it depends on actual memory block size.</div>
    <div class="meta">Posted on 2010-10-13 04:42:49 by baldr</div>
   </div>
  </div>
 </body>
</html>