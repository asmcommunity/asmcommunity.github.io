<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>VFW32 is a rag - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=13358" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=13358">VFW32 is a rag</a></p>
   <div class="post" id="post-103533">
    <div class="subject"><a href="#post-103533">VFW32 is a rag</a></div>
    <div class="body">Heya - I recently looked at Scronty's vfw32 example (cam viewer) - and I decided to implement the code myself, using a single webcam.<br />Well, I found a peculiarity in the code Scronty used to save bitmaps (which bears a striking similarity to the dekstop capture code from BackOrifice :tongue: )<br />Here's the deal.<br />He fetches the dc of a given window, then creates a compatible bitmap - so far so good - but if the window is minimized, it saves a black rectangle, if the window is hidden, it saves the desktop area under the client window, and if the window is visible but partially obscured, it saves overlapping windows image data (unless you move the client window to the top of the z order at the last moment - which defeats the purpose of wanting to hide it !!)<br />All I want to do is to save the webcam image to a file, without displaying it onscreen. Why does this have to be difficult??</div>
    <div class="meta">Posted on 2003-05-17 10:34:06 by Homer</div>
   </div>
   <div class="post" id="post-103618">
    <div class="subject"><a href="#post-103618">VFW32 is a rag</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br />I'd started to look into saving the image differently after posting the last webcam viewer, however grabbing the dc of the window and saving that was far easier than the &quot;correct&quot; way.<br /><br />The only other way would be to grab the video feed and load a DIB manually.<br /><br />Yet again...the PSDK tells you what you *can* do, but not *how* to do it.:mad: <br /><br /><br />Once code has been built that can actually grab the video feed and save it, then you'd be able to build a proggy that allows you to take a picture from out of someones webcam and upload it to an ftp site without them knowing.<br /><br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2003-05-17 21:33:17 by Scronty</div>
   </div>
   <div class="post" id="post-103623">
    <div class="subject"><a href="#post-103623">VFW32 is a rag</a></div>
    <div class="body">Heh - yes, that's true, but then again, there are legitimate reasons for wanting to not display the stream onscreen too - aren't there ? :tongue:</div>
    <div class="meta">Posted on 2003-05-17 23:03:00 by Homer</div>
   </div>
   <div class="post" id="post-103629">
    <div class="subject"><a href="#post-103629">VFW32 is a rag</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br />One legitimate reason would be a security system where you want the PC to save the video feed transparently, and only actually *see* the video feed when you want to (i.e. a camera in a dairy/local shop).<br /><br />I think I've figured it out:alright: .<br /><br />What you need to do is to set a CallBack proc which gets sent the video feed.<br /><br />This is what I've modified in the &quot;3 webcam viewer&quot; proggy:<br /><br />1) Add the prototype at top of code:<br /><pre><code><br />FrameCallbackProc proto &#58;DWORD, &#58;DWORD<br /></code></pre><br />2) In the CBN_SELCHANGE message handler for hComboCapture1 put:<br /><pre><code><br />invoke SendMessage, hWndCap1, WM_CAP_SET_CALLBACK_FRAME, 0, FrameCallbackProc<br /></code></pre><br />after the &quot;WM_CAP_SET_PREVIEW&quot; line.<br /><br />3) In the WM_CLOSE message Handler:<br /><pre><code><br />invoke SendMessage, hWndCap1, WM_CAP_SET_CALLBACK_FRAME, 0, NULL<br /></code></pre><br />to get rid of the callback routine.<br /><br />4) In the WM_INITDIALOG message handler:<br /><pre><code><br />        mov eax, hWnd<br />        mov ghWndMain, eax<br /></code></pre><br /><br />5) Add new data:<br /><pre><code><br />    sztmplPreviewFrame      db  &quot;Preview frame# %ld &quot;,0<br />    dwFrameNum              dd  0<br /><br />    Buffer                  db  128 DUP &#40;0&#41;<br />    ghWndMain               dd  0<br /></code></pre><br /><br />6) Add the VIDEOHDR structure definition:<br /><pre><code><br />VIDEOHDR STRUCT<br />  lpData            DWORD      ?<br />  dwBufferLength    DWORD      ?<br />  dwBytesUsed       DWORD      ?<br />  dwTimeCaptured    DWORD      ?<br />  dwUser            DWORD      ?<br />  dwFlags           DWORD      ?<br />  dwReserved        DWORD      ?<br />VIDEOHDR ENDS<br /></code></pre><br /><br />7) And add the CallBack proc:<br /><pre><code><br />; FrameCallbackProc&#58; frame callback function <br />; hWnd&#58;              capture window handle <br />; lpVHdr&#58;            pointer to struct containing captured <br />;                    frame information <br />FrameCallbackProc PROC hWnd&#58;DWORD, lpVHdr&#58;DWORD<br />LOCAL hdc&#58;HDC<br />LOCAL memdc&#58;HDC<br />LOCAL hSaveBMFile&#58;HANDLE<br />LOCAL dwBytes&#58;DWORD<br />LOCAL bmpinfo&#58;BITMAPINFO<br />LOCAL dwBPP&#58;DWORD<br />LOCAL dwNumColors&#58;DWORD<br />LOCAL hBitmap&#58;HBITMAP<br />LOCAL pBits&#58;DWORD<br />LOCAL dwWidth&#58;DWORD<br />LOCAL dwHeight&#58;DWORD<br />LOCAL rc&#58;RECT<br /><br /><br />    .if hWnd == 0<br />        xor eax, eax<br />        ret<br />    .endif<br /><br />    invoke wsprintf, ADDR Buffer, ADDR sztmplPreviewFrame, dwFrameNum<br />    inc dwFrameNum<br /><br />    invoke SetWindowText, ghWndMain, ADDR Buffer<br /><br /><br />; grab the video data and display it<br /><br />    invoke GetDC, hWnd<br />    mov hdc,eax<br /><br />    invoke GetWindowRect, hWnd, ADDR rc<br />    mov eax, rc.right<br />    sub eax, rc.left<br />    mov dwWidth,eax<br />    mov eax, rc.bottom<br />    sub eax, rc.top<br />    mov dwHeight,eax<br /><br /><br />    invoke CreateCompatibleDC, hdc<br />    mov memdc,eax<br />    invoke GetDeviceCaps, hdc, BITSPIXEL<br />    mov dwBPP,eax<br />    mov dwNumColors,0<br /><br />    mov bmpinfo.bmiHeader.biSize,sizeof BITMAPINFOHEADER<br />    mov eax,dwWidth<br />    mov bmpinfo.bmiHeader.biWidth,eax<br />    mov eax,dwHeight<br />    mov bmpinfo.bmiHeader.biHeight,eax<br />    mov bmpinfo.bmiHeader.biPlanes,1<br />    mov ax,word ptr &#91;dwBPP&#93;<br />    mov bmpinfo.bmiHeader.biBitCount,ax<br />    mov bmpinfo.bmiHeader.biCompression,BI_RGB<br />    mov bmpinfo.bmiHeader.biSizeImage,0<br />    mov bmpinfo.bmiHeader.biXPelsPerMeter,0<br />    mov bmpinfo.bmiHeader.biYPelsPerMeter,0<br />    mov eax,dwNumColors<br />    mov bmpinfo.bmiHeader.biClrUsed,eax<br />    mov bmpinfo.bmiHeader.biClrImportant,eax<br />    invoke CreateDIBSection,hdc,addr bmpinfo, DIB_PAL_COLORS,addr pBits, NULL, 0<br />    mov hBitmap,eax<br />    invoke SetBitmapBits, hBitmap, lpVHdr.VIDEOHDR.dwBytesUsed, lpVHdr.VIDEOHDR.lpData<br />    invoke SelectObject, memdc, hBitmap<br />    invoke BitBlt, hdc, 0,0, dwWidth, dwHeight, memdc, 0,0, SRCCOPY<br /><br />    invoke DeleteObject ,hBitmap<br />    invoke DeleteDC, memdc<br />    invoke ReleaseDC, hWnd, hdc<br /><br />    mov eax, 1<br />    ret<br />FrameCallbackProc ENDP<br /></code></pre><br /><br />This proc uses large chunks of code from the &quot;prSaveImage&quot; proc which creates a DIB and bitblts the callback-supplied image data onto the window.<br /><br />If the &quot;invoke BitBlt, hdc, 0,0, dwWidth, dwHeight, memdc, 0,0, SRCCOPY&quot; line is commented out, you'll see that no image is shown on the capture window.<br /><br />It is inside this callback proc where you'd add a &quot;copyright&quot; text onto the image/ upload via ftp/ analyse the image and compare it to previously stored image (i.e. for checking if the images have changed)/etc.<br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2003-05-17 23:26:05 by Scronty</div>
   </div>
   <div class="post" id="post-103639">
    <div class="subject"><a href="#post-103639">VFW32 is a rag</a></div>
    <div class="body">Thanks Scronty, but NAAAAH !!!<br /><br />I just want to grab FRAMES, into BMP files, not save an avi stream, and I found a way to do it without using vfw32 and without the need for any bmpsave code...<br />Here's how I did it:<br /><br /><br />ReConnectCam PROC<br />                    invoke SendMessage, hWndCap1, WM_CAP_DRIVER_DISCONNECT, 0, 0<br />                    invoke SendMessage, hWndCap1, WM_CAP_DRIVER_CONNECT, CamIndex , 0<br />                    invoke SendMessage, hWndCap1, WM_CAP_SET_PREVIEWRATE, 50, 0<br />                    invoke SendMessage, hWndCap1, WM_CAP_SET_SCALE, TRUE, 0<br />                     invoke SendMessage, hWndCap1, WM_CAP_SET_PREVIEW, TRUE, 0<br />                    ret<br />ReConnectCam ENDP<br /><br />MyThread PROC parm:DWORD<br />@@: invoke Sleep,10000<br />        .if CamAvailable==TRUE<br />             invoke ReConnectCam<br />             invoke SendMessage, hWndCap1, WM_CAP_GRAB_FRAME, 0, 0<br />             invoke SendMessage, hWndCap1, WM_CAP_SAVEDIB, 0, CTXT(&quot;CUNT.BMP&quot;)<br />        .endif<br />        jmp @B<br />MyThread ENDP<br /><br />The main window can be hidden using SW_HIDE and it will still work.<br />This code only acquires the cam when it is going to grab a frame, so it is available at all other times. The democode is saving every 10 seconds to the same file.<br />When you send the GRAB_FRAME message, you lose the camera connection, which in the case of this democode is ok, but note theres another message similar to that one which maintains the connection , should you wish this.<br /><br />I no longer include vfw32 lib or inc files at all.<br />I send the WM's implicitly, the capBlah functions just do the same thing anyway - useless overhead, all you really require are the WM equates.<br />WM_CAP_SAVEDIB was base+25.<br />It's also called WM_CAP_FILE_SAVEDIB.<br /><br />Thanks for the reply, Scronty, I do appreciate it and I too found little information available for this kind of thing. My code is going to be used in a video conferencing application, where you don't want to see your own ugly mug, you want to see THEIRS ... this arrangement allows me to simply continually send data streamed and compressed from the same image file, opened with FILE_SHARE_WRITE access.</div>
    <div class="meta">Posted on 2003-05-18 01:48:03 by Homer</div>
   </div>
   <div class="post" id="post-103649">
    <div class="subject"><a href="#post-103649">VFW32 is a rag</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br />Thanks for supplying another method for this.<br /><br />You seemed to miss the point of the code I just gave.:tongue: <br />Even though in the code it bitblts the DIB to the windows DC, it was only doing that to show that the image data was there.<br />In your case, you'd send the data to a &quot;savebitmap&quot; proc for saving, instead of displaying it.<br /><br />Also:<br />Depending on what you wish to do, depends upon which methods to use. For yourself, grabbing a frame and saving it might be best. For myself, I was only saving a bitmap because I didn't know how else to grab a frame and send it to the &quot;attachment&quot; code for emailing.<br /><br />Using WM_CAP_SET_CALLBACK_FRAME I can now grab a single frame and send the data to the proc for encrypting the base64 attachment.<br /><br />You've mentioned that you're planning on using this for sending compressed images for video conferencing.<br />Is the networking code in a separate dll? I don't understand the need to save an image as a bitmap, when you could just send the image data directly to the compression proc.<br /><br />Definitely interesting stuff, though:grin: :cool: .<br /><br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2003-05-18 03:45:32 by Scronty</div>
   </div>
   <div class="post" id="post-103723">
    <div class="subject"><a href="#post-103723">VFW32 is a rag</a></div>
    <div class="body"><div class="quote"><br />I don't understand the need to save an image as a bitmap, when you could just send the image data directly to the compression proc.</div>With the kind of video conferencing he is doing {loook at the BMP name}, he might want to have a look himself after the clients are done 'conferencing'. :)</div>
    <div class="meta">Posted on 2003-05-18 10:17:17 by bitRAKE</div>
   </div>
   <div class="post" id="post-104194">
    <div class="subject"><a href="#post-104194">VFW32 is a rag</a></div>
    <div class="body">Yep ok, now I'm done messing with that, I'll be trying on some other methods too :)<br />I can see your point guys, I couldn't understand the difficulty with just grabbing a frame to a bmp outright - but found it was simply not well documented.<br />Thanks for the heads up, I originally did want to access the stream directly, and could only find info on creating avi's with a callback, which at the time was way off track.<br />bitRAKE, I just have little imagination for var names, k? :tongue: <br />I apologise if I offended anyone there heh - an oversight.<br />Surely if it were part of some evil plot, I might try a bit harder with the filename :)<br /><br />Scronty, did you have any issues with the dinput8 include?</div>
    <div class="meta">Posted on 2003-05-21 10:32:23 by Homer</div>
   </div>
   <div class="post" id="post-104245">
    <div class="subject"><a href="#post-104245">VFW32 is a rag</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br /><div class="quote">Scronty, did you have any issues with the dinput8 include?</div> <br />Nope, since I've never translated them:tongue: . ALso: I haven't go around to checking the DInput inc file you've made, since I've been busy trying it get these Fasm DX example up and running. When they're done, I'll be taking a look at all the other files I never got around to making.<br /><br />The only time I've used DInput in asm was when I was mucking about with Sergeys' (hardcode) DX example when he had Bizare Creations up and running.<br /><br />It was during the time I was mucking about with that, and also using DInput in VC++ proggys, that I decided to leave the friggin' stupid thing alone.<br /><br />I found that DInput has a problem allowing you to select various combinations of keys 9at least...DInput running on my 'puter has problems).<br /><br />You *should* be able to allow as many keys down at once as the users hands/fingers can. However.. DInput failed quite often when holding down only three keys at the same time.<br /><br />That's why I use the &quot;key array&quot; solution:<br />Have an array 256 bytes long. Each byte will represent whether a key is down or up.<br />During WM_KEYDOWN and WM_KEYUP messages, just place TRUE or FALSE in the array for whichever key is being pressed/released.<br /><br />During the idle time in the messagepump (where the call to &quot;render&quot; takes place), have a bunch of .if....endif to check for the keys you need to process.<br /><br />Windows is going to send your application the WM_KEYDOWN and WM_KEYUP messages whether you want it to or not, so there's not going to be much of a speed hit. You could even check for those particular messages *within* the messagepump.<br /><br />With this system, I found that the users control/&quot;feedback of action&quot; was practically immediate compared with a *very* slight delay when using DInput.<br /><br />As I mentioned ages ago in a thread far, far away...<br />DInput would be the better solution if you're coding for a joystick/car wheel/etc. However... since I only have a mouse and keyboard, using a key and mouse array is far faster and easier to implement.<br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2003-05-21 17:20:30 by Scronty</div>
   </div>
   <div class="post" id="post-104247">
    <div class="subject"><a href="#post-104247">VFW32 is a rag</a></div>
    <div class="body">I dislike DI for various reasons, but it may be blameless here.<br />Check out <a target="_blank" href="http://www.dribin.org/dave/keyboard/one_html/">http://www.dribin.org/dave/keyboard/one_html/</a> .<br />Does it actually work with the key array, and fail only when using DI?<br /><br />/* edit: typo */</div>
    <div class="meta">Posted on 2003-05-21 19:33:13 by Jan Wassenberg</div>
   </div>
   <div class="post" id="post-104267">
    <div class="subject"><a href="#post-104267">VFW32 is a rag</a></div>
    <div class="body">Scronty,<br />     I was using a DI function which fills a 256 byte buffer of flags which are formatted in the same way as the usual api keybuffer, yep, understand that premise, just had no luck with DI8 - I simply followed your lead and modified the m$ header such that it supported mcall - following your d3d includes as a template.<br /> Well, I got DI to initialize without reporting any error codes, but it simply never sets any of the flags in the buffer when I call the polling function - which is meant to refresh the entire 256 byte set whenever it is called.<br />Nevermind, I'll leave it too for now, I was actually hoping Bogdan might throw some light on the issue, thus I posted my entire support code for DI8 and not just the inc.<br />Anyways, something else to tinker with when time permits :)</div>
    <div class="meta">Posted on 2003-05-21 22:59:37 by Homer</div>
   </div>
  </div>
 </body>
</html>