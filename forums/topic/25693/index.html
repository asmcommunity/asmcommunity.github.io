<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>OASML 2.0 (Open-source Assembly Library) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25693" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25693">OASML 2.0 (Open-source Assembly Library)</a></p>
   <div class="post" id="post-187463">
    <div class="subject"><a href="#post-187463">OASML 2.0 (Open-source Assembly Library)</a></div>
    <div class="body">OASML 2.0 is the second version of the Open-source Assembly Library<br />which is a huge update to the first version.<br />The OASML 2.0 library is intended to simplify your task of programming<br />in the 16-bit Real-mode architecture of CPU by implementing hundreds<br />of procedures and describing every single line of the code with<br />comments so that you can understand what really is happening.<br /><br />Below is the list of the major updates and bug fixes in OASML 2.0 and<br />also the important features of the library:<br /><br /><br />&nbsp; ? OASML 2.0 now supports access to the XMS memory with easy-to-use<br />&nbsp; &nbsp; procedures. You need not create any structures or anything to be<br />&nbsp; &nbsp; able to work with XMS. All you have to do is to allocate, deallocate<br />&nbsp; &nbsp; write to, read from and etc. The procedures in the  unit<br />&nbsp; &nbsp; handle the structures for you in the stack.<br /><br />&nbsp; ? OASML 2.0, although based on 16-bit architecture, simulates<br />&nbsp; &nbsp; 32-bit AND 64-bit values. This means that you can write 32/64 bit<br />&nbsp; &nbsp; values to the screen, read 32/64 bit numerical values from the<br />&nbsp; &nbsp; screen, convert these values to hex, binary, octal and vice versa.<br /><br />&nbsp; ? A QWORD unit is added to the library which allows 64-bit numerical<br />&nbsp; &nbsp; values to be manipulated through the simulation of 64-bit instructions.<br /><br />&nbsp; ? The  unit now contains 48 procedures including Length-Dependent<br />&nbsp; &nbsp; procedures that allow the maximum size of the source/destination to<br />&nbsp; &nbsp; be specified in order to avoid buffer overflows.<br /><br />&nbsp; ? A new unit is added to the library called  which<br />&nbsp; &nbsp; allows simple operations to be carried out on the graphics mode<br />&nbsp; &nbsp; of 320.200. Operations include drawing horizontal/vertical lines,<br />&nbsp; &nbsp; filling the screen, changing pallets and etc.<br /><br />&nbsp; ? A  unit is added to the library which facilitates<br />&nbsp; &nbsp; direct access to the Text-Mode Video Memory. Using this unit<br />&nbsp; &nbsp; you can write directly to the Video Memory of the Text Mode<br />&nbsp; &nbsp; of 80.25 characters.<br /><br />&nbsp; ? The  unit of the library now contains 39 procedures<br />&nbsp; &nbsp; that work with absolute values, logarithms, consines, sines,<br />&nbsp; &nbsp; conversion from angles in degrees to radians and etd.<br /><br />&nbsp; ? The  unit, short form of Miscellaneous, now contains<br />&nbsp; &nbsp; more procedures dealing with various computations.<br /><br />&nbsp; ? Length-dependent procedures are also added to the  unit<br />&nbsp; &nbsp; to allow you specify the maximum length of the buffer in cases<br />&nbsp; &nbsp; that the procedure needs to copy bytes to the destination. Other<br />&nbsp; &nbsp; procedures are also added to this unit such as .<br /><br />&nbsp; ? The  unit now contains 45 procedures with a lot of new<br />&nbsp; &nbsp; additions such as the  procedure which<br />&nbsp; &nbsp; allows a 64-bit QWORD value to be printed to the screen as<br />&nbsp; &nbsp; a hexadecimal value including the zeros to the left.<br /><br />&nbsp; ? The ,  and the  procedures<br />&nbsp; &nbsp; had a minor bug in OASML 1.0 that is now fixed in OASMl 2.0.<br /><br />&nbsp; ? The  procedure used to remove its parameter<br />&nbsp; &nbsp; from the stack which is now fixed.<br /><br />&nbsp; ? The , , ,  and the<br />&nbsp; &nbsp;  procedures are now optimized for both speed and size.<br /><br />&nbsp; ? A lot of string-related procedures now would not destroy the AX<br />&nbsp; &nbsp; register. These procedures are , , ,<br />&nbsp; &nbsp;  and etc.<br /><br />&nbsp; ? Some procedures used to be incompatible with 8086 instructions,<br />&nbsp; &nbsp; such as the  procedure. This problem is fixed<br />&nbsp; &nbsp; in OASMl 2.0.<br />&nbsp; &nbsp; <br />&nbsp; ? For a complete list of updates, you can view the  file<br />&nbsp; &nbsp; in the OASML 2.0 package. The file  lists the bugs<br />&nbsp; &nbsp; that are fixed in this version of the library.<br /><br />More information: You can visit <a target="_blank" href="http://www.ASMTrauma.com/Details/OASML2.0.htm">THIS page</a>.<br />Download OASML 2.0: You can download OASML 2.0 <a target="_blank" href="http://www.ASMTrauma.com/Downloads/ASMLibs/OASML2.0.zip">HERE</a>.<br /><br />I&#39;d be glad to hear your suggestions and/or comments.</div>
    <div class="meta">Posted on 2007-01-12 03:59:16 by XCHG</div>
   </div>
   <div class="post" id="post-187464">
    <div class="subject"><a href="#post-187464">Re: OASML 2.0 (Open-source Assembly Library)</a></div>
    <div class="body"><div class="quote">The  unit now contains 48 procedures including Length-Dependent<br />&nbsp; &nbsp; procedures that allow the maximum size of the source/destination to<br />&nbsp; &nbsp; be specified in order to avoid buffer overflows.</div>congrats. is there some general behavior in case some of buffer overflows? what happens? Designing this took me some while, so i wonder about yours ;)<br /><br />also, why the 8086 support? do you think there will be usage for that?</div>
    <div class="meta">Posted on 2007-01-12 06:12:12 by vid</div>
   </div>
   <div class="post" id="post-187488">
    <div class="subject"><a href="#post-187488">Re: OASML 2.0 (Open-source Assembly Library)</a></div>
    <div class="body">Hello vid,<br /><br />I thought of a return value in case of the buffer overflows and generally, length-dependent procedures because normal string procedures in the library do not return a value and just do what they are supposed to do except when a return value is expected from them like the ?StrGetChar? procedure. In length-dependent procedures, I used the AX register to indicate information related to the operation that the procedure has done. For example, if either the source or the destination lengths are zero, AX will be set to zero and the procedure will terminate immediately. That is the best method I could come up with. Perhaps there are other ways around it, too.<br /><br />The AX register will also be set to the number of bytes copied to the destination string including or excluding the null-terminator. I have written the default behavior of each of these procedures in their comment block. I?d be glad to hear your insights on this.</div>
    <div class="meta">Posted on 2007-01-13 00:08:34 by XCHG</div>
   </div>
   <div class="post" id="post-187574">
    <div class="subject"><a href="#post-187574">Re: OASML 2.0 (Open-source Assembly Library)</a></div>
    <div class="body"><div class="quote"> Description : Concatenates the maximum number of AX bytes from the source string<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to the destination string and would terminate the destination<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string upon success. The AX register will then be equal to the<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length of the final string. See note(s).</div><br />i think you didn&#39;t really catch the point with this design. Primary purpose is to make sure, that DESTINATION string never overflows it&#39;s buffer size. This is hard with your current design, because you need to know current size of dest string, to set AX to such value it won&#39;t overflow.<br /><br />Now, yours AX can prevent read overflow of source string, but preventing overflow of dest string is much more important.<br /><br />for my ideas of design, see FASMLIBs string routines: <a target="_blank" href="http://fasmlib.flatassembler.net/src/str.inc">http://fasmlib.flatassembler.net/src/str.inc</a>. Shortly: with EVERY string, you must also pass it&#39;s buffer size.</div>
    <div class="meta">Posted on 2007-01-17 00:23:57 by vid</div>
   </div>
   <div class="post" id="post-187576">
    <div class="subject"><a href="#post-187576">Re: OASML 2.0 (Open-source Assembly Library)</a></div>
    <div class="body">I was talking about procedures such as  that accept the number of bytes to copy and not the maximum size of the buffer. In this case, I think it would be irrational to ask the user to provide the length of both the source and the destination. It would be like &quot;I have 3 bytes of space in my destination buffer but please copy as many as 10 bytes&quot;.<br /><br />I have implemented the &quot;Both src and dest length&quot; mechanism on procedures such as &quot;lStrScanForChars&quot; with parameters like this:<br /><pre><span style="font-size:2><br />&nbsp; &nbsp; Parameter(s) :<br />&nbsp; &nbsp; &nbsp; WORD Param1 = Offset of the string to search into.<br />&nbsp; &nbsp; &nbsp; WORD Param2 = Maximum length of .<br />&nbsp; &nbsp; &nbsp; WORD Param3 = Offset of the string to search for.<br />&nbsp; &nbsp; &nbsp; WORD Param4 = Maximum length of .</span></pre><br /><br />Or in the  procedure with the below parameters<br /><pre><span style="font-size:2><br />&nbsp; &nbsp; Parameter(s) :<br />&nbsp; &nbsp; &nbsp; WORD Param1 = Source string&#39;s offset.<br />&nbsp; &nbsp; &nbsp; WORD Param2 = Source string&#39;s maximum length.<br />&nbsp; &nbsp; &nbsp; WORD Param3 = Destination string&#39;s offset.<br />&nbsp; &nbsp; &nbsp; WORD Param4 = Destination string&#39;s maximum length.<br />&nbsp; &nbsp; &nbsp; WORD Param5 = Number of bytes to copy.<br />&nbsp; &nbsp; &nbsp; WORD Param6 = Starting index inside the source string.</span></pre><br /><br />So should we really have a procedure like:<br /><br />int lStrCopy (char* Destination, int DestinationLength, char* Source, int SourceLength)<br /><br />or should it be:<br /><br />int lStrCopy (char* Destination, int DestinationMaxLen, char* Source);<br /><br />Thank you for your response vid.<br /><br /></div>
    <div class="meta">Posted on 2007-01-17 02:14:22 by XCHG</div>
   </div>
   <div class="post" id="post-187581">
    <div class="subject"><a href="#post-187581">Re: OASML 2.0 (Open-source Assembly Library)</a></div>
    <div class="body"><div class="quote"><br />In this case, I think it would be irrational to ask the user to provide the length of both the source and the destination. It would be like &quot;I have 3 bytes of space in my destination buffer but please copy as many as 10 bytes&quot;.<br /></div><br />It&#39;s not irrational once you consider typical usage scenarios.<br /><br />Without the buffer-size parameter, you always need to make sure you never pass a too large value to the function. Not very surprisingly, people often forget this - a google search for &quot;buffer overflow&quot; gives you two million reasons to add checking code (okay, 1.8mil, and the overflows are of various nature, but you get the drift).<br /><br />Adding a &quot;SourceBufferLength&quot; parameter seems a bit over-paranoid, it would take some pretty extreme situations to cause, say, a pagefault, or informating leaking. But if you want to be 100% safe...<br /><br />Anyway, for a 16bit library, &quot;who cares&quot; - 16bit x86 is not going to be used for anything critical, it&#39;s not going to be interfaced to a network, etc etc etc.<br /></div>
    <div class="meta">Posted on 2007-01-17 03:27:24 by f0dder</div>
   </div>
   <div class="post" id="post-187584">
    <div class="subject"><a href="#post-187584">Re: OASML 2.0 (Open-source Assembly Library)</a></div>
    <div class="body">f0dder: i did pretty new approach in FASMLIB that makes usage of source buffer length useful in some cases. here are basic rules:<br /><br />- length of buffer is passed for EVERY string (thus you also get some generality and don&#39;t need to browse docs so much)<br />- whenever string buffer overflows, chars in buffer are filled as they were if buffer was long enough, and ERR_BUFFER_FULL error is returned. <br />- in case of ERR_BUFFER_FULL, destination string is NOT zero terminated. That is because i await every error is catched with FASMLIB (jc error... soooo easy)<br />- if source string is not zero-terminated within buffer, no error is thrown, but only chars in buffer are actually used.<br /><br />this allows user to use same string libraries on non-zero-terminated string buffers (like section name in PE header), just by ignoring ERR_BUFFER_FULL. <br /><br />Also to read from such buffer, you don&#39;t even have to catch and ignore errors. No errors are returned in such case.<br /><br />Many people may dislike not terminating buffer with zero, but you are protected twice: <br />1. error is returned in such case. you can end with non-zero-terminated string only when you decide to ignore ERR_BUFFER_FULL.<br />2. still, when working with string using FASMLIB routines, you pass string length, so these won&#39;t ever overflow buffer.<br /><br />I found this solution to be most flexible, and still pretty safe.</div>
    <div class="meta">Posted on 2007-01-17 05:49:35 by vid</div>
   </div>
   <div class="post" id="post-187585">
    <div class="subject"><a href="#post-187585">Re: OASML 2.0 (Open-source Assembly Library)</a></div>
    <div class="body">Hmmm... ignoring errors is generally a pretty bad idea. IMHO things like PE header sections should be handled by special-case code.<br /><br />I also prefer not to modify output buffer in the case it&#39;s too small - it can be dangerous trying to process partial information.</div>
    <div class="meta">Posted on 2007-01-17 08:29:47 by f0dder</div>
   </div>
   <div class="post" id="post-187593">
    <div class="subject"><a href="#post-187593">Re: OASML 2.0 (Open-source Assembly Library)</a></div>
    <div class="body">it&#39;s not simple &quot;ignoring errors&quot; :D<br />it is ignoring ERR_BUFFER_FULL only, which notifies you that only first part of buffer is filled, and buffer is not zero-terminated.<br /><br /><div class="quote">I also prefer not to modify output buffer in the case it&#39;s too small - it can be dangerous trying to process partial information.</div>Every time partial information is stored, you get error. You work with partial information only if you decide to specifically ignore this error. In case of error buffer could be left as-is aswell, this way is just the procedure more powerful for very special cases (like PE header section name).<br /><br />I just designed functions so that they are fine for everyday use, but also make it possible for you to use them for more special cases, so you don&#39;t need another set of procedures (like you proposed). You just use them in sligthly different matter</div>
    <div class="meta">Posted on 2007-01-17 12:46:17 by vid</div>
   </div>
   <div class="post" id="post-187604">
    <div class="subject"><a href="#post-187604">Re: OASML 2.0 (Open-source Assembly Library)</a></div>
    <div class="body">How about the speed? How many clock cycles approximately would it take to copy a null-terminated string of 65536 bytes into another using specific lengths? I performed a benchmark on Delphi&#39;s default StrCopy function which does not have length checking on either the source or the destination and for the source and the destination strings aligned on a DWORD boundary it took ~301714 clock cycles for the first run.<br /><br />Window&#39;s lstrcpy function took ~207709 clock cycles for the same source and destination at the first run. I am wondering how many clock cycles it would take to copy a string into another with both the source and the destination buffer&#39;s length checks. Window&#39;s default lstrcpyn which checks the destination buffer&#39;s length only took ~566910 clock cycle for the same source and string which is unacceptable.<br /></div>
    <div class="meta">Posted on 2007-01-18 02:07:00 by XCHG</div>
   </div>
   <div class="post" id="post-187606">
    <div class="subject"><a href="#post-187606">Re: OASML 2.0 (Open-source Assembly Library)</a></div>
    <div class="body">more realistic case would be 65536 copies of 20byte strings.<br />i haven&#39;t benchmarked it yet, but procs are generaly not fast.<br /><br />it&#39;s hard to compare, since my procs do little more than typical strcpy() or strcat(), because of that buffer checking. </div>
    <div class="meta">Posted on 2007-01-18 04:56:50 by vid</div>
   </div>
  </div>
 </body>
</html>