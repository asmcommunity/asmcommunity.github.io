<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Parser - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29911" />
  <link rel="prev" href="../?id=29911&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29911">Parser</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29911&amp;page=1" style="">&laquo;</a><a href="../?id=29911&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29911" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-211421">
    <div class="subject"><a href="#post-211421">Re: Parser</a></div>
    <div class="body">Out of curiosity... how difficult do you think it would be to create some kind of &#039;pseudo shader language&#039;?<br />That is, to define a grammar that is sorta like HLSL/GLSL, which can be parsed and then sent through one of various backends to generate eg:<br />- D3D-compatible HLSL code.<br />- OpenGL-compatible GLSL code.<br />- D3D-compatible assembly code.<br />- OpenGL-compatible assembly code.<br />- nVidia Cg-compatible code.<br /><br />It would solve the &#039;missing link&#039; between the APIs (and could be expanded to consoles etc aswell).</div>
    <div class="meta">Posted on 2010-04-23 07:43:50 by Scali</div>
   </div>
   <div class="post" id="post-211433">
    <div class="subject"><a href="#post-211433">Re: Parser</a></div>
    <div class="body">I think it (the grammar) would be a bit of a no-brainer, really.<br />I&#039;ve had no major problems describing very complex and expressive grammars, while I&#039;d classify HLSL-like languages as being fairly rudimentary (although it can be elegant in its crudeness).<br /><br />I did have some trouble describing recursive grammars, but that was due to my own inexperience with EBNF.<br />My current issues stem from the fact that I&#039;m trying to write an interpreter in the ABSENCE of a grammar (!)&nbsp; while simultaneously developing the grammar - I&#039;m using a component based model in the hope that the components will be reusable - which is why I&#039;m trying not to get too bogged down with implementing the semantics of one specific grammar.<br /><br /><br /></div>
    <div class="meta">Posted on 2010-04-23 13:27:19 by Homer</div>
   </div>
   <div class="post" id="post-211445">
    <div class="subject"><a href="#post-211445">Re: Parser</a></div>
    <div class="body">I stripped mention of the IF directive from the baseclass...<br /><br />I&#039;ve implemented the generic &#039;interpreter baseclass&#039;, and derived from it an &#039;Evaluator&#039; class, which implements a dozen or so Reduction Node handlers which implement the Rules of my example grammar. So far, so good.<br /><br />The interpreter seeks to &#039;resolve&#039; nonterminal child tokens of reductions.<br />If successful, the resulting token is passed back up the tree where it replaces its &#039;imposter&#039;, and if nodes are found to contain only one token after being resolved, they are &#039;collapsed&#039; (the node is destroyed, and its only token is passed up the tree).<br />Typically, the handler methods then &#039;solve&#039; using the simplified (resolved) token sequence.<br /><br />I haven&#039;t implemented a whole lot of grammar yet, but it&#039;s enough to show to my peers for their consideration.<br />If all continues to go well and my peers think this solution looks viable, I will post the interpreter class and derived Evaluator class and test grammar.<br /><br />BTW some small changes were made to the Parser class.<br />How many people actually looked at that code?<br />I mean more than a cursory glance?<br />It would be nice to get some feedback.<br />I have my own ideas about things that suck about it that need fixing.<br />Please feel free to be blunt.<br /></div>
    <div class="meta">Posted on 2010-04-24 09:10:54 by Homer</div>
   </div>
   <div class="post" id="post-211449">
    <div class="subject"><a href="#post-211449">Re: Parser</a></div>
    <div class="body">I am up to processing a &lt;Assign&gt; = &lt;Expression&gt; ... and I&#039;ve already simplified &lt;Expression&gt; into (in my example case) &lt;Value&gt;.<br />At this point, I&#039;m ready to set the value of a (possibly new) buildtime variable.<br />My interpreter class needs to start keeping a list of typed values it&#039;s learned.<br />Milestone, albeit a small one.<br /><br />I&#039;ve developed a design pattern for writing new Reduction Node handlers:<br />We simply look at the Rules to find the handful of possible token sequences, and write a handler that deals with those cases.<br /><br />Also, I&#039;ve adopted a mechanism for &#039;simplifying&#039; the parsetree in a homogenous way: just before returning from recursion, I check if the current Reduction contains exactly one token.<br />If it does, I return that token.. notifying the caller (Interpret method) that the Reduction was &#039;simplified&#039;, and that it can throw away the reduction, and overwrite the token that represents it with the returned token.<br /><br />This allows me to pass tokens back up the tree, &#039;collapsing&#039; it as much as possible.<br />In turn, this allows each node to perform its function with &#039;already minimalised&#039; components.<br />And it also acts as a kind of automatic garbage collection, so our memory usage remains modest during buildtime.<br /><br />All clear sailing, captain geek!<br /></div>
    <div class="meta">Posted on 2010-04-24 11:23:03 by Homer</div>
   </div>
   <div class="post" id="post-211450">
    <div class="subject"><a href="#post-211450">Re: Parser</a></div>
    <div class="body">Just wanna say:<br /><br />My current test program is<br /><br /><div class="quote"><br />x=y=z<br /></div><br /><br />Since z is undefined, this should generate an ERROR !!!!!!<br /><br />But if we had two lines<br /><br /><div class="quote"><br />z=2<br />x=y=z<br /></div><br /><br />this expression is now &#039;solvable&#039;... we should set x= (y= (z=2) )<br /><br />I dont currently have any means to hand back an error, but I deliberately chose an erroroneous statement knowing i would have to deal with error cases, this is what 25 years of programming experience has taught me: expect the unexpected.<br /><br /><br /><br />My parse tree looks something like:<br />Assign x = Assign y = z<br /><br />(simplification)<br /></div>
    <div class="meta">Posted on 2010-04-24 11:35:42 by Homer</div>
   </div>
   <div class="post" id="post-211451">
    <div class="subject"><a href="#post-211451">Re: Parser</a></div>
    <div class="body">Here is an update of the relevant files, old and new.<br />Enough to show everyone how I am thinking.<br />Implementation nuances, hell, anything, can change, but here is a workable recursive solver, without any elegance or any context awareness, implementing part of a concrete grammar from a partial concrete parsetree.<br />Be dazzled.<br />Be awed.<br />Say gee, that looks easy.<br /><br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3114" target="_blank">Parser.inc</a></li>
      <li><a href="../../attachments/?id=3115" target="_blank">Interpreter.inc</a></li>
      <li><a href="../../attachments/?id=3116" target="_blank">Evaluator.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-04-24 11:47:05 by Homer</div>
   </div>
   <div class="post" id="post-211461">
    <div class="subject"><a href="#post-211461">Re: Parser</a></div>
    <div class="body">I&#039;ve been working on my first derived interpreter, which I call Evaluator.<br />The goal will be to solve complex expressions (ie those which resemble equations).<br />To spice things up , I am supporting the resolving of statements of such order of complexity as:<br /><br /><div class="quote"><br />a*=b+6/j+=0.5<br /></div><br /><br />For this particular case, my solver for such expressions will not be taking advantage of the parsetree structure, and no operator precedence is being implemented for AssignOps (see below)... however operator precedence does apply for &#039;regular&#039; math operators within complex expressions, as purely math subexpressions ARE resolved according to the tree structure.<br /><br />I am &quot;flattening&quot; the expression into a linear sequence of tokens, and then simplifying it by repeatedly solving the rightmost subexpression, where a subexpression is something like:<br />Id &lt;AssignOp&gt; &lt;Value&gt;<br /><br />and AssignOp is =, +=, -=, *=, /=<br />and Value is something like a Number or an Id.<br /><br /><br />This is the same approach I used in the XASM project.<br />It is appropriate when the complex expression contains one or more linear (directed) dependencies.<br />It cannot be used to solve expressions containing interdependencies (simultaneous equations).<br />But it&#039;s just fine for a chain of &#039;x=y=z&#039; style of statement.<br /><br />Anyway I&#039;m pretty close, its just painstakingly slow with lots of rebuilding and testing.<br />And everytime I touch the existing grammar, the software needs to be updated to reflect the changes, so I&#039;ve had to limit myself to try not to meddle in the grammar while simultaneously trying to write an interpreter for it lol.<br /><br /></div>
    <div class="meta">Posted on 2010-04-25 21:34:00 by Homer</div>
   </div>
   <div class="post" id="post-211477">
    <div class="subject"><a href="#post-211477">Re: Parser</a></div>
    <div class="body"><br />My previous post is utter nonsense - I was heading down the wrong road.<br />I was having problems because the tree produced by my Grammar was untidy.<br />The grammar was restructured to produce &#039;more atomic&#039; parsetree nodes.<br /><br />I&#039;ve scrapped my weekend&#039;s work and reverted the code to a more complete version of what I started with - a recursive solver which marshals calls to user handler functions based on observation of the type of sentential structure represented by a given node.<br />I&#039;ve written several utility functions to assist in manipulating content of Reductions (parsetree nodes), and eliminated the need to pass return values (other than &#039;syntax error&#039;) back through the recursion.<br />Also a potential memory leak was fixed, and a small bug in the GUI code.<br />The code is currently very robust although quite naive - all the &#039;handlers&#039; that are meant to &#039;resolve&#039; the parsetree contents are currently being redirected to &#039;DefaultHandler&#039;.<br /><br />DefaultHandler&#039;s behavior is to recursively resolve each NonTerminal child token in a Reduction, and then replace said NonTerminal token with the &#039;exploded&#039; token(s) which it was representing. This is what I previously called &#039;flattening a subtree&#039; - we still do it. Now we&#039;re meant to resolve the &#039;flattened&#039; sentential structure(s) at some point during the RETURN FROM RECURSION.<br /><br />As an example, I&#039;ll describe the handling of the IF directive, where we get to implement &#039;conditional interpretation&#039; by testing a condition before ever looking at the contents of the IF case (&lt;Statements&gt;).<br /><br /><div class="quote"><br />&lt;If Statement&gt; ::= if &lt;Cond&gt; &lt;Statements&gt; endif<br /></div><br /><br />We have four tokens in this reduction.<br />The first and last are Terminals, so we can leave them alone.<br />But &lt;Cond&gt; and &lt;Statements&gt; are NonTerminals, they represent subtrees to be recursed, at the bottom of which we expect to find some Terminal(s) to be returned.<br />So we&#039;ll recurse the &lt;Cond&gt; subtree , as we process the tokens from left to right.<br /><br />The &lt;Cond&gt; handler will recursively expand its tokens, and once it has done so, the Condition can be tested, noting that all of its tokens are now Terminals. Having tested the condition, the handler can replace the &lt;Cond&gt; tokens with simply TRUE or FALSE, and return to its caller.<br /><br />At this point, we&#039;ve returned to our original handler, and our Reduction might now look like this:<br /><div class="quote"><br />if &lt;TRUE&gt; &lt;Statements&gt; endif<br /></div><br /><br />Our current handler can now see that the condition was found to be TRUE, we might continue to process the &lt;Statements&gt; token, which is next in the left-to-right series.<br />If the condition had been FALSE, we might do nothing.<br /><br />In either case, this &#039;if&#039; node should destroy all its tokens before returning to its caller, because whether true or false, we have completely &#039;SOLVED&#039; this node, and don&#039;t need to return any tokens to a parent node.<br /><br /><br />Attached is a revised grammar file, I&#039;m not included to repost the other files yet, maybe later today.<br />This one can much better handle nested stuff (braced subexpressions of any kind), linearly dependant assign sequences (x=y=z) and other stuff. Some very primitive support for 32bit x86 asm is also there, but is not important yet.<br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3117" target="_blank">Test3.grm.txt</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-04-27 19:10:17 by Homer</div>
   </div>
   <div class="post" id="post-211487">
    <div class="subject"><a href="#post-211487">Re: Parser</a></div>
    <div class="body">Very good news :) &lt;Add_Exp&gt; and &lt;Assignment&gt; are implemented: and the technique is working flawlessly :)<br />The interpreter can now solve math expressions that use named variables and/or integers, with Addition operator.<br /><br />simple example:<br /><div class="quote"><br />x=10<br />y=1963<br />x=x+y<br /></div><br /><br />is interpreted perfectly:<br />-Variable x is defined as integer 10.<br />-Variable y is defined as integer 1963.<br />-Variable x is redefined as integer 1973.<br /><br />I&#039;ll try to complete the Addition handler for the remaining literal data types (float, string), as I can then quickly spit out the functions for handling the remaining math operators (-, *, /)<br /><br />Edit]<br />I&#039;ve also implemented the &lt;Assign Expr&gt; , which is used for &quot;subsequent assignments, and also to implement &quot;assignment modifiers&quot; (+=, -=, *=, /=) for example:<br /><div class="quote"><br />x = 10<br />y = x += 15 - x<br /></div><br /><br />In order to understand how the calculation is performed, <br />We can imagine that the Math Operators (+, -, *, /) and the Assign Operators (equ, =, +=, -=, *=, /=) are nested delimiters for math subexpressions... our parsetree structure encodes this &#039;nesting&#039;.<br />If we add some braces to better show this, our example becomes:<br /><div class="quote"><br />y = ( x = (x + (15 - (x))))<br /></div><br /><br />Now we can see the exact order in which the calculation will be performed, which is dictated by the structure of our parsetree, which is dictated in turn by the constraints that our Grammar imposes apon the input plaintext being interpreted.<br /><br />We don&#039;t have to figure out how to solve the equations, we just have to write handlers for the most primitive math operations of 2 operands and 1 operator, and then let the recursive solver make sense of it all for us, as it walks the parsetree structure.<br /><br /><br /></div>
    <div class="meta">Posted on 2010-04-28 07:51:46 by Homer</div>
   </div>
   <div class="post" id="post-211488">
    <div class="subject"><a href="#post-211488">Re: Parser</a></div>
    <div class="body">I guess next is to implement the remaining pure math operators, and then do some tests to see how nested braces mess up my existing code (they should not affect anything in theory, we&#039;ll see huh).<br />At that point, the Evaluator will be essentially complete, and I&#039;ll be ready to release a new demo, updated sourcecode, and decide what to implement next :)<br /><br />I&#039;ve left myself a lot of &#039;markers&#039; in my sourcecode where missing stuff belongs, that makes it easier to pick my next target, I don&#039;t need to think so hard about what is possible if I have a todo list at hand.<br />But basically, I just need to implement more handlers.<br />Once I&#039;ve completely implemented the existing grammar, I&#039;ll release a third demo/sourcecode, then it will be time for a formal discussion about general programming grammars (not just asm) - what we like, what we loathe, what we&#039;d have if we could invent it, etc.<br /><br /></div>
    <div class="meta">Posted on 2010-04-28 09:51:22 by Homer</div>
   </div>
   <div class="post" id="post-211504">
    <div class="subject"><a href="#post-211504">Re: Parser</a></div>
    <div class="body">So far, my grammar only defines 4 literal datatypes: integer, float, hex, and string.<br />The code responsible for handling Additions now supports all but hex, which I&#039;ll add in a few moments.<br /><br />I have allowed additions of strings, but only with other strings.<br />Addition of floats with other types will result in a float.<br />Hex and Integer types are treated synonymously.<br /><br />Although I&#039;ll be taking this opportunity to sweep the code for potential improvements, I believe I&#039;m well on track to implementing a robust expression evaluator and solver (&quot;interpreter&quot;). I will have to be careful what I implement if I intend this to be made available in a generic yet still useful form.<br />In fact, as soon as the math stuff is in place, I&#039;ll probably call it a day on this class and then derive a class which implements more syntax-specific (language-specific) stuff.<br />I think the expression solver, even just doing maths, is useful as a standalone thing, just in case someone asks me for the millionth time how to write a calculator application :D Talk about overkill eh?<br /><br />Some examples:<br /><div class="quote"><br />Addition of strings:<br />a = &quot;hello &quot; + &quot;there, &quot;<br />b = &quot;Ralf&quot;<br />c = a + b<br /><br />Expressions with mixed datatypes:<br />q = 40<br />x = 15.704 - 16 * q<br /></div><br /><br />The only invalid kind of expression so far is:<br /><div class="quote"><br />Addition of String and Non-String is ILLEGAL !!!<br />a = &quot;tom&quot;<br />b = a + 27<br /></div><br /><br />About datatype conversions:<br />In light of that last example, its worth mentioning that we could allow indirect addition of strings and nonstrings, via some new directive such as CHR...<br />ie b = a + CHR(13) + CHR(10)<br />That would be perfectly reasonable under a &quot;BASIC&quot; kind of grammar.<br />And most languages support some variation on this, so its a good example.</div>
    <div class="meta">Posted on 2010-04-29 03:45:00 by Homer</div>
   </div>
   <div class="post" id="post-211509">
    <div class="subject"><a href="#post-211509">Re: Parser</a></div>
    <div class="body">It was getting late, so I thought I&#039;d tackle a relatively quick and easy one before bed..<br /><br />I&#039;ve implemented the &lt;Negate Exp&gt; handler.<br />This is used to negate the value of an immediate or variable within the context of a math expression.<br />This is NOT the mathematical Subtraction operation, although it uses the same symbol...<br />My parser can tell what we&#039;re trying to do based on the context it appears in.<br /><br />Eg<br /><div class="quote"><br />x = -x + s<br />y = 7 + -J &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;Z equals Seven &nbsp;Plus Negated J&quot;<br />z = 7 - -J &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;Z equals Seven Minus Negated J&quot;<br /></div><br /><br />&lt;Negate Exp&gt; appears quite late in the rules, its near the bottom of the &lt;Expression&gt; tree, just before &lt;Value&gt;.<br />This means that we can negate literals easily, but we need to use braces if we want to negate an entire expression.<br />eg&nbsp; -(expression)<br />And I haven&#039;t implemented the &#039;brace stripper&#039; yet... guess thats next, though I really do wanna complete the remaining math operators.<br /><br /><br /></div>
    <div class="meta">Posted on 2010-04-29 11:28:01 by Homer</div>
   </div>
   <div class="post" id="post-211519">
    <div class="subject"><a href="#post-211519">Re: Parser</a></div>
    <div class="body"><br />Made some subtle but important changes.<br />It&#039;s now possible for a node handler to destroy all of its own tokens, and return to its caller &quot;an empty reduction&quot;.<br />This allows me to &#039;clip solved children&#039; from a parent node after expanding and before processing it.<br />It means that anything we completely dealt with is eliminated from the parsetree, and will not appear in the content of parent nodes, and so will not affect their handler. It is a very nice improvement, just hard to explain exactly how without ranting for pages on the ramifications.<br /><br />Tonight will be implementing one of the remaining three math operators!<br /><br /></div>
    <div class="meta">Posted on 2010-04-30 02:16:16 by Homer</div>
   </div>
   <div class="post" id="post-211520">
    <div class="subject"><a href="#post-211520">Re: Parser</a></div>
    <div class="body"><br />Yaknow, everything goes better on Fridays.<br />I implemented Subtractions in 5 minutes flat.<br />It&#039;s actually NOT a new handler - the Add_Exp handler should handle +, -, &amp;, | ( And , Or ) .<br />Yay! I can add, I can subtract, and with various datatypes.<br />Damned if this thing is not beginning to look like more than a whole bunch of debug strings :P<br /></div>
    <div class="meta">Posted on 2010-04-30 04:05:33 by Homer</div>
   </div>
   <div class="post" id="post-211525">
    <div class="subject"><a href="#post-211525">Re: Parser</a></div>
    <div class="body">Another 5 minutes to implement mul/div... Mult_Exp handler was implemented.<br />Now the interpreter can solve expressions with add/sub/mul/div for mixed datatypes.<br />The&lt;Mult_Exp&gt; handler looks pretty much like the &lt;Add Exp&gt; handler, but is a descendant/child node..<br />The Mult_Exp handler implements multiplication and division, it is located in the grammar just below the Add_Exp node, and just above the Negate_Exp node.<br />This means that multiplications and divisions are handled before additions and subtractions, which implements the correct mathematical operator precedence !!!<br />We get correct precedence for free, due to the structure of our grammar - I keep saying how important that structure is, now you can start to see how we benefit from a well structured grammar.<br /><br /><br />What else do I need? I will sure add POW, AND and OR tomorrow... (^, &amp;, |)<br />And I&#039;ll need to handle braces..<br />Any math operators I forgot?<br />I think tomorrow I&#039;ll have a full algebraic solver, will be time to post a demo and source update :)<br /><br />When you get things really RIGHT at the core of your implementation, everything just clicks into place, and its SO sweet!<br /></div>
    <div class="meta">Posted on 2010-04-30 09:27:50 by Homer</div>
   </div>
   <div class="post" id="post-211526">
    <div class="subject"><a href="#post-211526">Re: Parser</a></div>
    <div class="body">Having correctly implemented and tested with one math operator, it only took ten minutes to implement the other three major math operators - I wish all my projects were so linear in nature lol.<br />Speaking of linearity, I&#039;m looking forward to implementing IF/ELSEIF/ELSE/ENDIF logic, but I&#039;m not sure it belongs in this, which is meant to be a baseclass... I think I will take my own advice, and finish off the math stuff, and stop work on this class and derive a new one for further work.<br /><br />Implemented:<br />=, +=, -=, /=, *=, +, - , /, *<br /><br />Unimplemented: ^, ()<br /><br />Almost there :D<br /><br /><br /></div>
    <div class="meta">Posted on 2010-04-30 09:36:12 by Homer</div>
   </div>
   <div class="post" id="post-211539">
    <div class="subject"><a href="#post-211539">Re: Parser</a></div>
    <div class="body"><br />A new rule &lt;PowExp Expr&gt; was added to the grammar.<br />This rule implements Powers, eg 2^3, and the rule is located just below the multiplication/division node.<br />This means that Power operator takes precedence over Mul/Div operator, which is correct.<br />Floating point powers are supported (!), with the returned datatype recast on demand if necessary.<br /><br />Eg<br />x = J^2<br />x = Q^0.5 &lt;-- this is one way to do a sqrt<br /><br /><br />I have also introduced the &#039;engineering exponent&#039; (e) suffix for any kind of Value.<br />But there&#039;s two caveats to using it, so I have not yet implemented it in the solver.<br />The first caveat is that positive exponents must NOT contain a + sign.<br />The second is that the &#039;e&#039; needs to be clearly delimited from the preceding Value by whitespace.<br />This is the first real difficulty I&#039;ve had, and it&#039;s clearly a problem that needs to be handled another way.... I know Braces would help to clarify to the parser what we intend, but this will do for now.<br /><br />Eg<br />x = 1.0e2 will not work<br />x = 1.0 e 2 will work<br />x =&nbsp; 20e-2 will not work<br />x = 20 e-2 will work<br />x = y <br /><br />So that really just leaves me braces, and whether I go ahead and implement the &#039;e&#039; (... *10^n) <br />Pretty much I think I&#039;m ready to post an updated demo :)<br /><br />I actually found very little information on the internet regarding the details of implementing a parsetree solver, which was distressing. And any sourcecodes I was able to find were far more obscure and unintelligable than my own.<br />If anyone would like to ask questions about any part of this interpreter framework, please feel free :)<br /><br /></div>
    <div class="meta">Posted on 2010-05-01 02:28:08 by Homer</div>
   </div>
   <div class="post" id="post-211540">
    <div class="subject"><a href="#post-211540">Re: Parser</a></div>
    <div class="body">Braces (nested subexpressions) have been implemented.<br />This was actually VERY easy.. Braced subexpressions are defined under the &lt;Value&gt; rule as follows:<br /><div class="quote"><br />&lt;Value&gt; &nbsp; &nbsp; &nbsp; ::= &nbsp; &lt;Literal&gt;				! Could be a simple Literal value (eg integer, string, float etc)<br />		 &nbsp; &nbsp;| &#039;(&#039; &lt;Expression&gt; &nbsp;&#039;)&#039;			! Could be a braced (sub)expression (ie nesting support for expressions)<br />		 &nbsp; &nbsp;| ID &#039;++&#039;					! Could be Name++<br />		 &nbsp; &nbsp;| ID &#039;--&#039;					! Cound be Name--<br />		 &nbsp; &nbsp;| ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;				! Could be Name<br /></div><br /><br />See the second one down? It says that any Value in an Expression can contain an entire (Braced Expression).<br />When my interpreter reaches a Value node, I check for and eliminate braces, then pass whatever remains naively to the default handler for recursion. That&#039;s all! I don&#039;t need to deal with the subexpression, or even take any notice that I have one, rather than say, a Literal value... I just let the default handler deal with it. Done.<br /><br />My test data was:<br />x= 15 * (2^(1+1))<br />y = 100^0.5<br /><br />And the answers were 60 (integer) and 10.0 (float).<br />Correct.<br /><br />Note in the second line, that the interpreter has decided that the answer should be a float.<br />If we operate on a floating point number and an integer (or hex) number, the result will always be a float.<br />Just remember that these are not real datatypes, these types are just telling us which numerical representation of a number was used. It is in the interest of consistency that the input datatypes should determine the output datatype.<br />Where possible, the datatype of the leftmost entity will be retained.<br />For example:<br />0x1 + 1 = 0x2<br />1 + 0x1 = 2<br /><br /></div>
    <div class="meta">Posted on 2010-05-01 03:36:25 by Homer</div>
   </div>
   <div class="post" id="post-211541">
    <div class="subject"><a href="#post-211541">Re: Parser</a></div>
    <div class="body">Conditional operators (&lt;,&lt;=,==,&gt;=,&gt;) are implemented, aka the &lt;Compare Expr&gt; node.<br /><br />This node attempts to resolve comparison expressions into a single BOOLEAN token.<br />Although, I have not explicitly defined BOOLEAN as a datatype - I am simply returning integer 0 or 1.<br />This is compatible with statements such as &quot;repeat until 0&quot;.<br />We can define TRUE and FALSE at buildtime.<br /><br />Since IF is not implemented, these operators remain practically useless.<br />I will implement IF logic in my derived class - but I felt the conditional operators themselves should be implemented in the Evaluator class.<br /><br /></div>
    <div class="meta">Posted on 2010-05-01 06:15:11 by Homer</div>
   </div>
   <div class="post" id="post-211542">
    <div class="subject"><a href="#post-211542">Re: Parser</a></div>
    <div class="body">Attached is an update of relevant files.<br />I am tempted to add &quot;trig&quot; support to the Evaluator class, but that can wait.<br />For the time being, I will consider the Evaluator class to be &#039;reasonably complete&#039;.<br />Of course that will prove not to be the case, right??<br /><br />I will now turn my attention to a new derived class called MacroEngine.<br />Here is where I will implement any &#039;buildtime directives&#039;, which include the IF directive.<br />After that, I will be starting to exhaust my primitive experimental grammar.<br />I will be asking for your input to help design a nice clean programming syntax :)<br /><br />This will also be the final post I make in this thread.<br />However, I will leave the thread unlocked for people to ask questions.<br /><br /> ok I just had to implement SHL/SHR/&lt;&lt;/&gt;&gt; ... you&#039;&#039; have to get the next exciting update from the new thread (Macro Engine)<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3120" target="_blank">Tokenizer.rar</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-05-01 07:29:30 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29911&amp;page=1" style="">&laquo;</a><a href="../?id=29911&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29911" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>