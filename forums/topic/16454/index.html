<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Building a Camera Matrix - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16454" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=16454">Building a Camera Matrix</a></p>
   <div class="post" id="post-127974">
    <div class="subject"><a href="#post-127974">Building a Camera Matrix</a></div>
    <div class="body">Heya...<br />I'm currently using D3DXMatrixLookAtLH to implement a fixed view of a 3d scene, and having done some digging around, there seems to be a few schools of thought about which is the better way to update the viewmatrix (read &quot;cameramatrix&quot;) when rotation in multiple axes is desired. I don't want to talk about Quaternions here. When we rotate the view around an axis, it messes up the other axes, so obviously it's craptarded to manipulate the vectors used in a call to D3DXMatrixLookAtLH, this is a cheesy solution and it leads to gimbal lock, which is a mathematical effect seen when we rotate 90 degrees on an axis, we have effectively switched some axes around, and everything goes haywire.<br />A better solution is to build the viewmatrix ourselves, taking into account the combined rotations and / or translations of the camera (us).<br />Here is a c++ function which is supposed to do it, followed by my asm translation of the same. Unfortunately, mine isn't working, and I'm not sure why.<br />And so I'm asking for your opinions on this issue, your comments, and your impressions on this solution and if possible, your eagle eye to spot the error in my translation...<br />My personal first impression was that since we are entirely building the matrix, there seems to be no need for the initial call to create an IdentityMatrix :)<br />Someone please call me an idiot and tell me that this is EXACTLY what D3DXMatrixLookAtLH does internally, and put me out of my misery :rolleyes:<br /><br />//-- ---------------------------------------------------------------------------<br />// Name : updateViewMatrix()<br />// Desc : Builds a view matrix suitable for Direct3D.<br />//<br />// Here's what the final matrix should look like:<br />//<br />//  |   rx     ux     lx    0 |<br />//  |   ry     uy     ly    0 |<br />//  |   rz     uz     lz    0 |<br />//  | -(r.e) -(u.e) -(l.e)  1 |<br />//<br />// Where r = Right vector<br />//       u = Up vector<br />//       l = Look vector<br />//       e = Eye position in world space<br />//       . = Dot-product operation<br />//<br />//-----------------------------------------------------------------------------<br />void updateViewMatrix( void )<br />{<br />	D3DXMATRIX view;<br />	D3DXMatrixIdentity( &amp;view );<br /><br />	D3DXVec3Normalize( &amp;g_vLook, &amp;g_vLook );<br />	D3DXVec3Cross( &amp;g_vRight, &amp;g_vUp, &amp;g_vLook );<br />	D3DXVec3Normalize( &amp;g_vRight, &amp;g_vRight );<br />	D3DXVec3Cross( &amp;g_vUp, &amp;g_vLook, &amp;g_vRight );<br />	D3DXVec3Normalize( &amp;g_vUp, &amp;g_vUp );<br /><br />	view._11 = g_vRight.x;<br />                view._12 = g_vUp.x;<br />                view._13 = g_vLook.x;<br />	view._14 = 0.0f;<br /><br />	view._21 = g_vRight.y;<br />                view._22 = g_vUp.y;<br />                view._23 = g_vLook.y;<br />	view._24 = 0.0f;<br /><br />	view._31 = g_vRight.z;<br />                view._32 = g_vUp.z;<br />                view._33 = g_vLook.z;<br />	view._34 = 0.0f;<br /><br />	view._41 = -D3DXVec3Dot( &amp;g_vEye, &amp;g_vRight );<br />	view._42 = -D3DXVec3Dot( &amp;g_vEye, &amp;g_vUp );<br />	view._43 = -D3DXVec3Dot( &amp;g_vEye, &amp;g_vLook );<br />	view._44 =  1.0f;<br /><br />	g_pd3dDevice-&gt;SetTransform( D3DTS_VIEW, &amp;view ); <br />}<br /><br /><br />==========================================<br /><br />Now for my version..<br /><br />updateViewMatrix proc<br />local view:D3DXMATRIX <br />local fptemp:FLOAT<br />;        invoke D3DXMatrixIdentity ,addr view   ;unnecessary, since we are filling the entire Matrix<br /><br />        invoke D3DXVec3Normalize, addr g_vLook, addr g_vLook <br />        invoke D3DXVec3Cross, addr g_vRight, addr g_vUp, addr g_vLook <br />        invoke D3DXVec3Normalize, addr g_vRight, addr g_vRight <br />        invoke D3DXVec3Cross, addr g_vUp, addr g_vLook, addr g_vRight <br />        invoke D3DXVec3Normalize, addr g_vUp, addr g_vUp<br /><br />        m2m view._11 , g_vRight.x<br />        m2m view._12 , g_vUp.x;<br />        m2m view._13 , g_vLook.x;<br />        m2m view._14 , fp0<br /><br />        m2m view._21 , g_vRight.y;<br />        m2m view._22 , g_vUp.y;<br />        m2m view._23 , g_vLook.y;<br />        m2m view._24 , fp0<br /><br />        m2m view._31 , g_vRight.z;<br />        m2m view._32 , g_vUp.z;<br />        m2m view._33 , g_vLook.z;<br />        m2m view._34 , fp0<br /><br />        invoke D3DXVec3Dot, addr g_vEye, addr g_vRight <br />        mov fptemp,eax<br />        fld fptemp<br />        fchs<br />        fstp view._41<br /><br />        invoke D3DXVec3Dot, addr g_vEye, addr g_vUp <br />        mov fptemp,eax<br />        fld fptemp<br />        fchs<br />        fstp view._42<br /><br />        invoke D3DXVec3Dot, addr g_vEye, addr g_vLook <br />        mov fptemp,eax<br />        fld fptemp<br />        fchs<br />        fstp view._43 <br />        m2m view._44 ,  fp1<br />        <br />        mov ecx,CApp_OnlyInstance<br />        mcall .CApp.g_pd3dDevice,IDirect3DDevice8_SetTransform, D3DTS_VIEW, addr view <br />        ret<br />updateViewMatrix endp<br /><br />As always, I appreciate any and all feedback in respect to my humble postings.<br />Thanks in advance,<br />                                Homer.</div>
    <div class="meta">Posted on 2003-12-16 02:42:59 by Homer</div>
   </div>
   <div class="post" id="post-127975">
    <div class="subject"><a href="#post-127975">Building a Camera Matrix</a></div>
    <div class="body">This may seem a little crass, but would it be a workable solution to calculate the LookAt position vector by projecting a ray (from the Camera Position) an arbitrary distance in the LookIn direction, and then simply using D3DXMatrixLookAtLH to generate an acceptable viewmatrix? Could we use trig to calc this, and would it avoid gimbal lock, given that we can perform trig-based math on fixed axes?</div>
    <div class="meta">Posted on 2003-12-16 03:11:43 by Homer</div>
   </div>
   <div class="post" id="post-127996">
    <div class="subject"><a href="#post-127996">Building a Camera Matrix</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br />You are an idiot ;) .<br /><br />The following code has been cut out of my &quot;fly&quot; example. The proggy had a &quot;space-buggy&quot; for the player, plus a spacebuggy for the enemy. The camera was set behind and above the players' spacebuggy (the code for placing the camera behind/above has been removed from the following code).<br /><br /><pre><code><br />;#########################################<br />;   the camera &#40;view&#41;<br /><br /><br />    INVOKE D3DXVec3Normalize, ADDR  lookat_vector,ADDR   lookat_vector<br />    INVOKE D3DXVec3Cross, ADDR  right_vector,ADDR   up_vector,ADDR   lookat_vector<br />    INVOKE D3DXVec3Normalize, ADDR  right_vector,ADDR   right_vector<br />    INVOKE D3DXVec3Cross, ADDR  up_vector, ADDR   lookat_vector, ADDR   right_vector<br />    INVOKE D3DXVec3Normalize, ADDR  up_vector, ADDR   up_vector<br /><br /><br />    INVOKE D3DXMatrixRotationAxis, addr rollmatrix, addr lookat_vector, Roll<br />    invoke D3DXVec3TransformCoord, addr right_vector , addr right_vector, addr rollmatrix<br />    invoke D3DXVec3TransformCoord, addr up_vector, addr up_vector, addr rollmatrix <br /><br />    INVOKE D3DXMatrixRotationAxis, addr yawmatrix, addr up_vector, Yaw<br />    invoke D3DXVec3TransformCoord, addr lookat_vector , addr lookat_vector, addr yawmatrix<br />    invoke D3DXVec3TransformCoord, addr right_vector, addr right_vector, addr yawmatrix <br />    <br />    INVOKE D3DXMatrixRotationAxis, addr pitchmatrix, addr right_vector, Pitch<br />    invoke D3DXVec3TransformCoord, addr lookat_vector , addr lookat_vector, addr pitchmatrix<br />    invoke D3DXVec3TransformCoord, addr up_vector, addr up_vector, addr pitchmatrix <br /><br /><br />    fldz<br />    fst matView.D3DXMATRIX._14<br />    fst matView.D3DXMATRIX._24<br />    fstp matView.D3DXMATRIX._34<br />    fld1<br />    fstp matView.D3DXMATRIX._44<br />    <br />    fld right_vector.x<br />    fstp matView.D3DXMATRIX._11<br />    fld up_vector.x<br />    fstp matView.D3DXMATRIX._12<br />    fld lookat_vector.x<br />    fstp matView.D3DXMATRIX._13<br />    <br />    fld right_vector.y<br />    fstp matView.D3DXMATRIX._21<br />    fld up_vector.y<br />    fstp matView.D3DXMATRIX._22<br />    fld lookat_vector.y<br />    fstp matView.D3DXMATRIX._23<br />    <br />    fld right_vector.z<br />    fstp matView.D3DXMATRIX._31<br />    fld up_vector.z<br />    fstp matView.D3DXMATRIX._32<br />    fld lookat_vector.z<br />    fstp matView.D3DXMATRIX._33<br /><br /><br />    INVOKE D3DXVec3Dot, addr position_vector, addr right_vector<br />    fchs<br />    fstp matView.D3DXMATRIX._41<br />    INVOKE D3DXVec3Dot, addr position_vector, addr up_vector<br />    fchs<br />    fstp matView.D3DXMATRIX._42<br />    INVOKE D3DXVec3Dot, addr position_vector, addr lookat_vector<br />    fchs<br />    fstp matView.D3DXMATRIX._43<br /></code></pre><br /><br />Some things to note:<br /><br /><strong>rollmatrix</strong>, <strong>yawmatrix</strong> and <strong>pitchmatrix</strong> are just:<br /><pre><code><br />LOCAL rollmatrix&#58;D3DMATRIX<br />LOCAL pitchmatrix&#58;D3DMATRIX<br />LOCAL yawmatrix&#58;D3DMATRIX<br /></code></pre><br />inside the same proc (since they're recreated each time they're used).<br /><br /><br /><strong>Roll</strong>, <strong>Yaw</strong> and <strong>Pitch</strong> are angles of the object in radians (meaning... 0 or 2*PI is no rotation, while PI would be a 180 degree rotation).<br /><br /><br /><strong>lookat_vector</strong>, <strong>right_vector</strong>, <strong>up_vector</strong> and <strong>position_vector</strong> are just:<br /><pre><code><br />    lookat_vector       D3DXVECTOR3     &lt;0.0f, 0.0f, 1.0f&gt;<br />    up_vector           D3DXVECTOR3     &lt;0.0f, 1.0f, 0.0f&gt;<br />    right_vector        D3DXVECTOR3     &lt;1.0f, 0.0f, 0.0f&gt;<br />    position_vector     D3DXVECTOR3     &lt;0.0f, 10.0f, -30.0f&gt;<br /></code></pre><br />inside the programs <strong>.data</strong> section.<br />Remember: the camera needs a postion in world space (position_vector) plus a direction (the other vectors).<br /><br /><strong>matView</strong> is just your typical D3DMATRIX matrice. It can either be in your <strong>.data</strong> section or used as LOCALs.<br />i.e.<br /><pre><code><br />...<br />LOCAL matView&#58;D3DMATRIX <br />...<br />mov ecx,CApp_OnlyInstance<br />mcall &#91;ecx&#93;.CApp.g_pd3dDevice,IDirect3DDevice8_SetTransform, D3DTS_VIEW, addr matView<br /></code></pre><br /><br />~~~~~~~~~~~~~~~~~~~~~<br /><br />Using movement/rotation code like this makes it *very* easy to move something around.<br />i.e.<br />To move an object (camera/particle/pig) forward/backwards in the directions it's facing, you just:<br /><pre><code><br />    fld lookat_vector.x<br />    fmul fpSpeed<br />    fadd position_vector.x<br />    fstp position_vector.x<br />    <br />    fld lookat_vector.y<br />    fmul fpSpeed<br />    fadd position_vector.y<br />    fstp position_vector.y<br />    <br />    fld lookat_vector.z<br />    fmul fpSpeed<br />    fadd position_vector.z<br />    fstp position_vector.z<br /></code></pre><br />just before you build the matrice (i.e. just *after* the last D3DXVec3TransformCoord call).<br /><br />Lastly:<br />The D3DXVec3Dot calculations have their signs changed (using <strong>fchs</strong>) because <strong>position_vector</strong> is in *world* coordinates, and we're wanting to change it (back) to *view* coordinates.<br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2003-12-16 06:49:47 by Scronty</div>
   </div>
   <div class="post" id="post-127998">
    <div class="subject"><a href="#post-127998">Building a Camera Matrix</a></div>
    <div class="body">This is wonderful - I was wondering to myself earlier today how I might manage to combine a PitchYawRoll matrix with a viewmatrix, and you have answered a question which I hadn't even gotten around to answering yet :)<br />I am humbled by the simplicity of your answer. Thanks !!<br />I'm grateful as always for your input, and I do appreciate you taking the time to help me out. Every little thing I pick from ur brain brings me closer to realizing my dream of garage Indy, 80's fashion. Dare to dream :alright:</div>
    <div class="meta">Posted on 2003-12-16 07:27:38 by Homer</div>
   </div>
   <div class="post" id="post-128070">
    <div class="subject"><a href="#post-128070">Building a Camera Matrix</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br />Stop greasing. Ya making me hungry (grease == grilled lamb chops to me).<br /><br />A few things I forgot to inlcude in my previous post:<br /><br />The supplied code is used for <strong>all</strong> objects in a game (whether they be a camera or computer-controlled or the player/s themselves).<br />This means that it'd actually make sense to chuck that code into its own proc and just call it for every object.<br /><br />There're no comments in that code as it was copy/pasted from the first commented code.<br />So I'll comment it now...;) <br /><br />The D3DXVec3Normalize, D3DXVec3Cross, D3DXVec3Normalize, D3DXVec3Cross, D3DXVec3Normalize lines are to get rid of gimbal-lock. For people who don't know what this is: When you rotate objects on all three axis, a small error creeps into the calculations due to floating-point rounding errors. Recalculating the look/right/up vectors each time eliminates this error.<br /><br />The D3DXMatrixRotationAxis, D3DXVec3TransformCoord, D3DXVec3TransformCoord, etc lines are for rotation about the X/Y/Z axis (yaw/pitch/roll). Looking at the code, you'll see that every calculation for each rotation matrice (roll/pitch/yaw) updates their opposing vectors.  i.e. the Roll matrix updates the up/right vectors. This makes sure that the main vectors (look/up/right) are <strong>always</strong> at right-angles to each other.<br /><br />This stuff:<br /><pre><code>    fldz<br />    fst matView.D3DXMATRIX._14<br />    fst matView.D3DXMATRIX._24<br />    fstp matView.D3DXMATRIX._34<br />    fld1<br />    fstp matView.D3DXMATRIX._44<br /><br />.. etc<br /></code></pre><br />... loads up our matrix (whether a camera or any other object) with the correct values.<br /><br />And finally, this bit:<br /><pre><code><br />just makes sure the <strong>position</strong> of the object is correct.<br /><br />Note that the previous code-snippet creates a matrice in <strong>view</strong> space.<br />To get a normal objects real matrix (i.e. a normal object is everything that *isn't* a camera), I use immediately after the previous code:<br /><pre><code>INVOKE D3DXMatrixInverse, ADDR MatrixOfObject, NULL, ADDR MatrixOfObject</code></pre><br />where MatrixOfObject is whatever mat*** you're using (i.e. the same matice that's used in place of matView above).<br />Just remember to use that last D3DXMatrixInverse call, otherwise the matrice will be totally stuffed up ;) .<br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2003-12-16 19:42:34 by Scronty</div>
   </div>
   <div class="post" id="post-128074">
    <div class="subject"><a href="#post-128074">Building a Camera Matrix</a></div>
    <div class="body">Yep, that works.<br />Hey, that c++ code was pretty close imho to your version, as was my translation.<br />1000 ways to skin a cat, as they say.<br />I don't mean to piss in your pocket, but yes, u have more experience than me in this field and on this platform. I tend to call a spade a friggin shovel.<br />Thanks.<br /><br />I'll be away for a few days at the Metal For The Brain gig in Canberra, as a pretence for buying a crapload of fireworks for New Year. Hopefully I'll finish implementing a cheapass version of ArcBall camera control before I leave, and if so I'll post again, if not, it can wait until I get back.<br />Have you ever tried animating a camera view using animation keyframe data?<br />Does Maya and/or 3DS export camera path matrix keys as a series of view matrices, or as separate position/rotation/scale keys? (I am guessing the latter, which seems redundant in respect to a single camera's viewpoint)<br />IE when u draw some curves and then attach a camera to the curve...<br />I'm obviously talking about cutscenes here :)<br />If as seems likely that I won't be around much for the rest of the Silly Season, have a great Christmas/New Year, and don't get too wasted daddy :)<br />(My son is about to start high school and I feel so old lol)</div>
    <div class="meta">Posted on 2003-12-16 20:45:45 by Homer</div>
   </div>
  </div>
 </body>
</html>