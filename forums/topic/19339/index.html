<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Confusing way of Balancing the Stack? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19339" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=19339">Confusing way of Balancing the Stack?</a></p>
   <div class="post" id="post-149267">
    <div class="subject"><a href="#post-149267">Confusing way of Balancing the Stack?</a></div>
    <div class="body">Hi,<br /><br />Sorry if this has been asked before, but I'm having trouble understanding how MASM balances the stack.<br /><br />I've been disassembling a couple of programs to see how MASM generated the code and I came across this oddity. The program I disassembled was Iczelion's Tutorial 3 WIN program.<br /><br />Now I know that each time new data is added to the stack the stack pointer is decremented. So it makes sense that undoing that would involve adding to the stack. This much I understand however, what I don't understand is why MASM added the amount that it did.<br /><br />Here is the program that I was disassembling:<br /><br /><pre><code>.386<br />.model flat,stdcall<br />option casemap&#58;none<br />include \masm32\include\windows.inc<br />include \masm32\include\user32.inc<br />include \masm32\include\kernel32.inc<br />includelib \masm32\lib\user32.lib<br />includelib \masm32\lib\kernel32.lib<br /><br />WinMain proto &#58;DWORD,&#58;DWORD,&#58;DWORD,&#58;DWORD<br /><br />.data<br />ClassName db &quot;SimpleWinClass&quot;,0<br />AppName  db &quot;Our First Window&quot;,0<br /><br />.data?<br />hInstance HINSTANCE ?<br />CommandLine LPSTR ?<br />.code<br />start&#58;<br />	invoke GetModuleHandle, NULL<br />	mov    hInstance,eax<br />	invoke GetCommandLine<br />	mov    CommandLine,eax<br />	invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT<br />	invoke ExitProcess,eax<br /><br />WinMain proc hInst&#58;HINSTANCE,hPrevInst&#58;HINSTANCE,CmdLine&#58;LPSTR,CmdShow&#58;DWORD<br />	LOCAL wc&#58;WNDCLASSEX<br />	LOCAL msg&#58;MSG<br />	LOCAL hwnd&#58;HWND<br />	mov   wc.cbSize,SIZEOF WNDCLASSEX<br />	mov   wc.style, CS_HREDRAW or CS_VREDRAW<br />	mov   wc.lpfnWndProc, OFFSET WndProc<br />	mov   wc.cbClsExtra,NULL<br />	mov   wc.cbWndExtra,NULL<br />	push  hInstance<br />	pop   wc.hInstance<br />	mov   wc.hbrBackground,COLOR_WINDOW+1<br />	mov   wc.lpszMenuName,NULL<br />	mov   wc.lpszClassName,OFFSET ClassName<br />	invoke LoadIcon,NULL,IDI_APPLICATION<br />	mov   wc.hIcon,eax<br />	mov   wc.hIconSm,eax<br />	invoke LoadCursor,NULL,IDC_ARROW<br />	mov   wc.hCursor,eax<br />	invoke RegisterClassEx, addr wc<br />	INVOKE CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\<br />           WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\<br />           CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\<br />           hInst,NULL<br />	mov   hwnd,eax<br />	invoke ShowWindow, hwnd,SW_SHOWNORMAL<br />	invoke UpdateWindow, hwnd<br />	.WHILE TRUE<br />		invoke GetMessage, ADDR msg,NULL,0,0<br />		.BREAK .IF &#40;!eax&#41;<br />		invoke TranslateMessage, ADDR msg<br />		invoke DispatchMessage, ADDR msg<br />	.ENDW<br />	mov     eax,msg.wParam<br />	ret<br />WinMain endp<br /><br />WndProc proc hWnd&#58;HWND, uMsg&#58;UINT, wParam&#58;WPARAM, lParam&#58;LPARAM<br />	.IF uMsg==WM_DESTROY<br />		invoke PostQuitMessage,NULL<br />	.ELSE<br />		invoke DefWindowProc,hWnd,uMsg,wParam,lParam		<br />		ret<br />	.ENDIF<br />	xor eax,eax<br />	ret<br />WndProc endp<br />end start<br /></code></pre><br /><br />The function that is balanced weird is WinMain. <br /><br />The function starts out in the disassembly like this:<br /><pre><code><br />PUSH ebp<br />MOV ebp, esp<br />ADD esp, 0xB0<br /></code></pre><br /><br />0xB0 is hexidecimal for 176. Now what I don't understand is why 176. After reading the first of Iczelion's tuts I was under the impression that you added to the stack pointer the amount of bytes that you pushed on to the stack. In his example, after pushing 3 DWORD(I assume) parameters on to the stack, he added 12 to the stack pointer.<br /><br /><pre><code>    push  &#91;third_param&#93;               ; Push the third parameter<br />    push  &#91;second_param&#93;            ; Followed by the second<br />    push  &#91;first_param&#93;                ; And the first<br />    call    foo<br />    add    sp, 12                                ; The caller balances the stack frame</code></pre><br /><br />Reading this I assumed that for each 4 byte parameter you add 4 to the stack. So for 3 parameters, you add 12(3 * 4) correct?<br /><br />But the WinMain function only accepts 4 parameters each of DWORD size. So 4 * 4 = 16 not 176. So why 176? I figuared it must have something to do with the local variables that are intialized at the beginning of the function.  Turns out that can't be the case either.<br /><br />Three variables are intialized in the WinMain function each of a certain type: WNDCLASSEX, MSG, HWND. I figuared that each of these structures must add up to 176 bytes or at least 160 bytes(176 - 16). WNDCLASSEX is about 48 bytes.<br /><br />Here it is in BASIC Style Code:<br /><pre><code> WNDCLASSEX Structure<br />  cbSize        as  DWORD<br />  style         as  DWORD<br />  lpfnWndProc   as  DWORD<br />  cbClsExtra    as  DWORD<br />  cbWndExtra    as  DWORD<br />  hInstance     as  DWORD<br />  hIcon         as  DWORD<br />  hCursor       as  DWORD<br />  hbrBackground as  DWORD<br />  lpszMenuName  as  DWORD<br />  lpszClassName as  DWORD<br />  hIconSm       as  DWORD<br /> WNDCLASSEX EndStructure</code></pre><br /><br />MSG is about 28 bytes:<br /><br /><pre><code><br />  POINT Structure<br />    x as DWORD<br />    y as DWORD<br />  POINT EndStructure <br /><br />  MSG Structure<br />    hwnd    as DWORD<br />    message as DWORD<br />    wParam  as DWORD<br />    lParam  as DWORD<br />    time    as DWORD<br />    pt      as POINT  <br />  MSG EndStructure<br /></code></pre><br /><br />hwnd is a DWORD so that's 4 bytes.<br /><br />Add them all together we get about 80 bytes. That's half of what I'd need in order to meet 160 and even less for 176. <br /><br />So after trying my hardest to figuare out what exactly I'm missing I've decided to ask you guys. Again, I'm sorry if this has been asked before but a search of the forum didn't turn up anything usefull for me so I had to start a new topic.<br /><br />Any help anyone can give me as to why and how the stack should be balanced here will be greatly appreciated. Thank you.</div>
    <div class="meta">Posted on 2004-09-07 01:25:24 by Anon32</div>
   </div>
   <div class="post" id="post-149269">
    <div class="subject"><a href="#post-149269">Confusing way of Balancing the Stack?</a></div>
    <div class="body">Yours disassembler is wrong. It should be<br /><pre><code><br />.text&#58;00401031 ; int __stdcall sub_401031&#40;HINSTANCE hInstance&#41;<br />.text&#58;00401031 sub_401031      proc near               ; CODE XREF&#58; start+26p<br />.text&#58;00401031 <br />.text&#58;00401031 hWnd            = dword ptr -50h<br />.text&#58;00401031 Msg             = MSG ptr -4Ch<br />.text&#58;00401031 var_30          = WNDCLASSEXA ptr -30h<br />.text&#58;00401031 hInstance       = dword ptr  8<br />.text&#58;00401031 <br />.text&#58;00401031                 push    ebp<br />.text&#58;00401032                 mov     ebp, esp<br />.text&#58;00401034                 add     esp, 0FFFFFFB0h<br /></code></pre><br /><br />However I still do not know why there is an add esp, -0B0h.  The &quot;add&quot; is for local variables, but the local variables are not that big from what I can see. Of course alignment does not make sense, since i only hear of stack needing to be aligned to dword.<br /><br />Anyway stdcall calling convention is usually used. Callee function clears up the stack. No need to the caller function does not need to balance the stack so<br /><pre><code><br />    push  &#91;third_param&#93;               ; Push the third parameter<br />    push  &#91;second_param&#93;            ; Followed by the second<br />    push  &#91;first_param&#93;                ; And the first<br />    call    foo<br />    add    esp, 12                                ; The caller balances the stack frame<br /></code></pre><br />Is not the normal case.<br /><br />Anyway the stack is balanced at the end of the routine with<br /><pre><code><br />.text&#58;00401114                 leave<br />.text&#58;00401115                 retn    10h<br /></code></pre></div>
    <div class="meta">Posted on 2004-09-07 02:34:38 by roticv</div>
   </div>
   <div class="post" id="post-149299">
    <div class="subject"><a href="#post-149299">Confusing way of Balancing the Stack?</a></div>
    <div class="body">83 C4 B0 is ADD ESP,-50h. That's just the size of those three items. The disassembler is slightly in error.</div>
    <div class="meta">Posted on 2004-09-07 12:00:37 by Sephiroth3</div>
   </div>
   <div class="post" id="post-149342">
    <div class="subject"><a href="#post-149342">Confusing way of Balancing the Stack?</a></div>
    <div class="body">Thanks Sephiroth3 and roticv!<br /><br />Out of curiousity, what disassembler do you guys use?</div>
    <div class="meta">Posted on 2004-09-08 05:06:15 by Anon32</div>
   </div>
   <div class="post" id="post-149343">
    <div class="subject"><a href="#post-149343">Confusing way of Balancing the Stack?</a></div>
    <div class="body">ida</div>
    <div class="meta">Posted on 2004-09-08 05:22:31 by roticv</div>
   </div>
   <div class="post" id="post-149356">
    <div class="subject"><a href="#post-149356">Confusing way of Balancing the Stack?</a></div>
    <div class="body"><div class="quote">83 C4 B0 is ADD ESP,-50h. That's just the size of those three items. The disassembler is slightly in error.</div><br />Don't worried it, that's for human eyes only. Assembler (ex: MASM, TASM...) know how do this:<br /><br />test.asm (My test source.)<br /><pre><code>.code<br />start&#58;<br />    add eax, 0ffffffb0h<br />    add eax, -50h<br />    add eax, 0ffb0h<br />    add eax, 0b0h<br />    add eax, 0ffffb000h</code></pre><br /><br />test.lst (MASM assembled)<br /><pre><code> 00000000			        .code<br />                            start&#58;<br /> 00000000   2   83 C0 B0	    add eax, 0ffffffb0h<br /> 00000003   2   83 C0 B0	    add eax, -50h<br /> 00000006   2   05 0000FFB0	    add eax, 0ffb0h<br /> 0000000B   2   05 000000B0	    add eax, 0b0h<br /> 00000010   2   05 FFFFB000	    add eax, 0ffffb000h</code></pre></div>
    <div class="meta">Posted on 2004-09-08 08:27:34 by Kestrel</div>
   </div>
   <div class="post" id="post-149393">
    <div class="subject"><a href="#post-149393">Confusing way of Balancing the Stack?</a></div>
    <div class="body">There is a magic rule for balancing the stack, its like the law of gravity, what goes up must come down. For however many bytes you use on the stack at procedure entry, you must correct it at the procedure exit.<br /><br />With a stack frame you reverse the usage of ESP/EBP, you can use the technique used by MASM with LEAVE as it is designed to defeat a stall on exit or if you don't use a stack frame, you can use the version of RET that corrects the stack by a set number of bytes.<br /><br />Convention has it that you use ESP+ addresses for parameters, ESP- addresses for locals and it generally works OK but there is no hard and fast rule as to where you start your local addresses and if you bother to look at some of the later VC generated code, it often puts locals at ESP+ addresses as part of its optimisation.<br /><br />As long as you observe the requirement for the stack to be the same on exit as entry, you can do more or less whatever you like.</div>
    <div class="meta">Posted on 2004-09-08 19:48:39 by hutch--</div>
   </div>
   <div class="post" id="post-149394">
    <div class="subject"><a href="#post-149394">Confusing way of Balancing the Stack?</a></div>
    <div class="body">remember various calling conventions: STDCALL has the called function clean the stack, C has the caller clean the stack. FASTCALL is evil, it puts some parameters in registers, others in stack :)</div>
    <div class="meta">Posted on 2004-09-08 20:22:21 by f0dder</div>
   </div>
  </div>
 </body>
</html>