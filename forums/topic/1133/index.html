<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>&quot;Fiction point&quot; logic - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=1133" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=1133">&quot;Fiction point&quot; logic</a></p>
   <div class="post" id="post-7422">
    <div class="subject"><a href="#post-7422">&quot;Fiction point&quot; logic</a></div>
    <div class="body">Introduction to &quot;fiction point&quot; logic.<br />=============================<br />One of most common tasks wich is included in 1000s basic and complex alorithms<br />is to scan for some basic datatype (byte,word,dword) element .<br />Mostly we have given condition:<br />1. Address to start from<br />2. Length (wich with address and direction determins range start-end)<br />3. Value we need to scan memory for<br />4. Direction<br />---------------------------<br />History<br /><br />In the old days of xx86 the most used way to accomplish the task was several<br />opcodes united by mnemonic  SCAS <br />(scasb(scan for byte),scasw(scan for word),scasd(scasd))<br />like:<br />	mov al,ByteToSearch<br />	mov edi,address<br />	mov ecx,length<br />repne	scasb<br />	jne	notfound<br />	;if z flag set edi = address of byte searched +1<br />All of you of course know it, I write this section only for that looking though different ways we<br />keep in mind such things as pointer,size,address ect.<br />----------<br />However since days of Pentium this method is far from fastest one.<br />Faster way became creating a loop, incrementing pointer (if we search forward) decreamenting counter<br />and comparing both if current element from the pointer is what we are searching for and check if counter<br />is zero.<br />There are numerous ways how to do it, for example (just to see logic):<br /><br />	mov edi,offset String-1<br />	mov ecx,LengthToSearh<br />	mov al,ByteToSearch<br />@@:	inc edi<br />	cmp ,al<br />	je Found<br />	dec ecx<br />	jne @B<br />;here is code for notfound case<br />	....<br />	....<br />found:<br /><br />It may be done it other way all I want you to pay attention to is that in this logic we need to do:<br />1. Increment pointer<br />2. Decrement counter<br />3. Check if element from current pointer = searched element<br />4. Check if counter = 0<br />----------------------------------------------------------------------------------------------------------<br />The second step of progress is to remove one of this for basic operations - incrementing the pointer.<br />'Cause we already decrementing the counter we can use the counter as index to the pointer to shift<br />current address by one element.<br />It's obvious when we need to search backwardly:<br />	mov edi,offset of string-1<br />	mov ecx,length<br />	mov al,ByteToSearch<br />@@:	cmp byte ptr ,al ;start from the last byte<br />	je found<br />	dec ecx		;dec index &amp; counter in ecx to shift pointer to 1 element lower address<br />	jne @B<br />the same would be with words or dword the only difference is that we mastab (mul) index by the size of <br />the operand cmp ecx*4],eax - for dwords.<br /><br />To understand how to use this method searching forward consider to things that address<br />is a sum of mul. index * sizeof operand and base adress.<br />Let base adress = A<br />Size of operand = 1<br />Index = B<br />Then <br />B*1 = B<br />B-B = 0<br />A+B-B = A<br />in code:<br />	mov ecx,Size	;ecx = Size = last index B<br />	mov edi,offset string ;edi = A<br />	add edi,ecx	;edi = A+B<br />	neg ecx		;ecx = - B<br />Then now  = offset string<br />And now we can increment ecx until it 0, shifting at the same time pointer forward with each incremenation.<br /><br />	mov ecx,Size<br />	mov edi,offset string<br />	mov al,ByteToSearch<br />@@:	cmp byte ptr ,al<br />	je found<br />	inc ecx<br />	jne @B<br />	....<br /><br />found:	add edi,ecx ;edi = address of searched byte<br />This way we elimenate needs for incrementing the poiner.<br /><br />All the above was written to prepare us to final part: &quot;fiction point logic&quot;<br />Let's ask ourself - what if we knew for sure that there IS searched byte in a given range?<br /><br />Obviously in that case we wouldn't need the counter at all!<br />And here &quot;fiction point&quot; logic will help us.<br />We can simply insert the byte in address wich serve us as boundry.<br />It may be last byte or first byte out of range:<br /><pre><code><br />.data?<br />temp db ?<br />...<br />.code<br />	mov edi,offset string-1<br />	mov ecx,Size<br />	mov al,&#91;edi&#93;&#91;ecx&#93;&#91;1&#93; ;save the byte we a going to replace<br />	mov temp,al<br />	mov al,ByteToSearch<br />	mov &#91;edi&#93;&#91;ecx&#93;&#91;1&#93;,al ;insert searched byte<br /><br />@@&#58;	cmp &#91;edi&#93;,al<br />	lea edi,&#91;edi+1&#93;<br />	jne @B<br />	dec edi ;edi = addr of found byte<br />	add ecx,offset string ;address of inserted byte<br />	cmp ecx,edi ;cmp addr of inserted byte with address of found byte<br />	mov &#91;ecx&#93;,al ; mov back the replaced byte<br />	jne found ; if not equal we found the byte else there was no such a byte in the range<br />	<br />	....	; here is code if the byte was not found<br />found&#58;              ;edi = addr of found byte<br /><br />Though you can see some more code in prologue and epilogue the code is very little clocks<br />consuming. And we remove one instruction form the loop wich is much more important.<br />Of course, implementation of the &quot;fiction point&quot; logic may be quite different.<br />I recommend try it with your own ideas.<br /><br />I started &quot;Basics of Asm32&quot; again.<br /></code></pre></div>
    <div class="meta">Posted on 2001-09-18 07:04:34 by The Svin</div>
   </div>
  </div>
 </body>
</html>