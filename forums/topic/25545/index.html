<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>masm - proc with pointer to struct as parameter - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25545" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25545">masm - proc with pointer to struct as parameter</a></p>
   <div class="post" id="post-186607">
    <div class="subject"><a href="#post-186607">masm - proc with pointer to struct as parameter</a></div>
    <div class="body"><pre><code>.386<br />.model flat,stdcall<br />option casemap:none<br />include windows.inc<br />include user32.inc<br />includelib user32.lib&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; calls to functions in user32.lib and kernel32.lib<br />include kernel32.inc<br />includelib kernel32.lib<br /><br />WinMain proto :DWORD,:DWORD,:DWORD,:DWORD<br />WndProc proto hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM<br />PopulateWndClassEx proto wcAdr:DWORD,lpfnWndProc:DWORD,hInst:HANDLE,clsName:DWORD<br /><br /><br />.DATA&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; initialized data<br />ClassName db &quot;SimpleWinClass&quot;,0&nbsp; &nbsp; &nbsp;  ; the name of our window class<br />AppName db &quot;Our First Window&quot;,0&nbsp; &nbsp; &nbsp;  ; the name of our window<br /><br />.DATA?&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Uninitialized data<br />hInstance HINSTANCE ?&nbsp; &nbsp; &nbsp;  ; Instance handle of our program<br />CommandLine LPSTR ?<br />.CODE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Here begins our code<br />PopulateWndClassEx proc wcAdr:DWORD,lpfnwndproc:DWORD,hInst:HANDLE,clsName:DWORD<br />&nbsp; &nbsp; push eax<br />&nbsp; &nbsp; push ebx<br />&nbsp; &nbsp; push ecx<br />&nbsp; &nbsp; mov ebx,wcAdr<br />&nbsp; &nbsp; mov (WNDCLASSEX PTR ).cbSize, SIZEOF WNDCLASSEX<br />&nbsp; &nbsp; mov (WNDCLASSEX PTR ).style, CS_HREDRAW or CS_VREDRAW<br />&nbsp; &nbsp; mov ecx,lpfnwndproc<br />&nbsp; &nbsp; mov (WNDCLASSEX PTR ).lpfnWndProc,ecx<br />&nbsp; &nbsp; mov (WNDCLASSEX PTR ).cbClsExtra,NULL<br />&nbsp; &nbsp; mov (WNDCLASSEX PTR ).cbWndExtra,NULL<br />&nbsp; &nbsp; mov ecx,hInst<br />&nbsp; &nbsp; mov (WNDCLASSEX PTR ).hInstance,ecx<br />&nbsp; &nbsp; mov (WNDCLASSEX PTR ).hbrBackground,COLOR_WINDOW+1<br />&nbsp; &nbsp; mov (WNDCLASSEX PTR ).lpszMenuName,NULL<br />&nbsp; &nbsp; mov ecx,clsName<br />&nbsp; &nbsp; mov (WNDCLASSEX PTR ).lpszClassName,ecx<br />&nbsp; &nbsp; invoke LoadIcon,NULL,IDI_APPLICATION<br />&nbsp; &nbsp; mov (WNDCLASSEX PTR ).hIcon,eax<br />&nbsp; &nbsp; mov (WNDCLASSEX PTR ).hIconSm,eax<br />&nbsp; &nbsp; invoke LoadCursor,NULL,IDC_ARROW<br />&nbsp; &nbsp; mov (WNDCLASSEX PTR ).hCursor,eax<br />&nbsp; &nbsp; pop ecx<br />&nbsp; &nbsp; pop ebx<br />&nbsp; &nbsp; pop eax<br />&nbsp; &nbsp; ret<br />PopulateWndClassEx EndP<br /><br /><br /><br />start:<br />invoke GetModuleHandle, NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; get the instance handle of our program.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Under Win32, hmodule==hinstance mov hInstance,eax<br />mov hInstance,eax<br />invoke GetCommandLine&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; get the command line. You don&#39;t have to call this function IF<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; your program doesn&#39;t process the command line.<br />mov CommandLine,eax<br />invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT&nbsp; &nbsp; &nbsp;  ; call the main function<br />invoke ExitProcess, eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; quit our program. The exit code is returned in eax from WinMain.<br /><br />WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD<br />&nbsp; &nbsp; LOCAL wc:WNDCLASSEX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; create local variables on stack<br />&nbsp; &nbsp; LOCAL msg:MSG<br />&nbsp; &nbsp; LOCAL hwnd:HWND<br />;&nbsp; &nbsp; invoke PopulateWndClassEx,addr wc,OFFSET WndProc,hInstance,OFFSET ClassName<br />;//BEGIN (normal) alternative block to the invoke above<br />&nbsp; &nbsp; mov&nbsp;  wc.cbSize,SIZEOF WNDCLASSEX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; fill values in members of wc<br />&nbsp; &nbsp; mov&nbsp;  wc.style, CS_HREDRAW or CS_VREDRAW<br />&nbsp; &nbsp; mov&nbsp;  wc.lpfnWndProc, OFFSET WndProc<br />&nbsp; &nbsp; mov&nbsp;  wc.cbClsExtra,NULL<br />&nbsp; &nbsp; mov&nbsp;  wc.cbWndExtra,NULL<br />&nbsp; &nbsp; push&nbsp; hInstance<br />&nbsp; &nbsp; pop&nbsp;  wc.hInstance<br />&nbsp; &nbsp; mov&nbsp;  wc.hbrBackground,COLOR_WINDOW+1<br />&nbsp; &nbsp; mov&nbsp;  wc.lpszMenuName,NULL<br />&nbsp; &nbsp; mov&nbsp;  wc.lpszClassName,OFFSET ClassName<br />&nbsp; &nbsp; invoke LoadIcon,NULL,IDI_APPLICATION<br />&nbsp; &nbsp; mov&nbsp;  wc.hIcon,eax<br />&nbsp; &nbsp; mov&nbsp;  wc.hIconSm,eax<br />&nbsp; &nbsp; invoke LoadCursor,NULL,IDC_ARROW<br />&nbsp; &nbsp; mov&nbsp;  wc.hCursor,eax<br />;//END alternative (normal) execution block<br />&nbsp; &nbsp; invoke RegisterClassEx, addr wc&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; register our window class<br />&nbsp; &nbsp; invoke CreateWindowEx,NULL,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ADDR ClassName,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ADDR AppName,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WS_OVERLAPPEDWINDOW,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CW_USEDEFAULT,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CW_USEDEFAULT,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CW_USEDEFAULT,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CW_USEDEFAULT,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NULL,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NULL,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hInst,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NULL<br />&nbsp; &nbsp; mov&nbsp;  hwnd,eax<br />&nbsp; &nbsp; invoke ShowWindow, hwnd,CmdShow&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; display our window on desktop<br />&nbsp; &nbsp; invoke UpdateWindow, hwnd&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; refresh the client area<br /><br />&nbsp; &nbsp; .WHILE TRUE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Enter message loop<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke GetMessage, ADDR msg,NULL,0,0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .BREAK .IF (!eax)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke TranslateMessage, ADDR msg<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke DispatchMessage, ADDR msg<br />&nbsp;  .ENDW<br />&nbsp; &nbsp; mov&nbsp; &nbsp;  eax,msg.wParam&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; return exit code in eax<br />&nbsp; &nbsp; ret<br />WinMain endp<br /><br />WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM<br />&nbsp; &nbsp; .IF uMsg==WM_DESTROY&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; if the user closes our window<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PostQuitMessage,NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; quit our application<br />&nbsp; &nbsp; .ELSE<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke DefWindowProc,hWnd,uMsg,wParam,lParam&nbsp; &nbsp; ; Default message processing<br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; .ENDIF<br />&nbsp; &nbsp; xor eax,eax<br />&nbsp; &nbsp; ret<br />WndProc endp<br /><br />end start</code></pre><br />What I want is PopulateWndClassEx populate the structure found at wcAddr (partially hard-coded properties, but also via parameters supplied). The code won&#39;t work with &quot;invoke PopulateWndClassEx ...&quot;, but why ? For simplification, some pseudocode using C syntax:<br /><pre><code>void PopulateWndClassEx(WNDCLASSEX* wcAddr,HANDLE hInst,&lt;...&gt;) {<br />/* What I have to do is dereferencing the pointer *wcAddr:*/<br />(*wcAddr).style = &lt;...&gt; /*and give values to the members of the struct*/<br />}</code></pre><br />The asm code for PopulateWndClassEx has been written after reading http://www.hep.wisc.edu/~pinghc/asm5.html</div>
    <div class="meta">Posted on 2006-11-18 05:18:11 by bhavacakra</div>
   </div>
   <div class="post" id="post-186608">
    <div class="subject"><a href="#post-186608">Re: masm - proc with pointer to struct as parameter</a></div>
    <div class="body">code fixed, there were some typos (my fault). here is it, as somebody may find it useful:<br /><pre><code><br />.386<br />.model flat,stdcall<br />option casemap:none<br />include windows.inc<br />include user32.inc<br />includelib user32.lib&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; calls to functions in user32.lib and kernel32.lib<br />include kernel32.inc<br />includelib kernel32.lib<br /><br />WinMain proto :DWORD,:DWORD,:DWORD,:DWORD<br />WndProc proto hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM<br />PopulateWndClassEx proto wcAdr:DWORD,lpfnWndProc:DWORD,hInst:HANDLE,clsName:DWORD<br /><br /><br />.DATA&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; initialized data<br />ClassName db &quot;SimpleWinClass&quot;,0&nbsp; &nbsp; &nbsp; &nbsp; ; the name of our window class<br />AppName db &quot;Our First Window&quot;,0&nbsp; &nbsp; &nbsp; &nbsp; ; the name of our window<br /><br />.DATA?&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Uninitialized data<br />hInstance HINSTANCE ?&nbsp; &nbsp; &nbsp; &nbsp; ; Instance handle of our program<br />CommandLine LPSTR ?<br />.CODE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Here begins our code<br />PopulateWndClassEx proc wcAdr:DWORD,lpfnwndproc:DWORD,hInst:HANDLE,clsName:DWORD<br />	mov ebx,wcAdr<br />	mov (WNDCLASSEX PTR ).cbSize, SIZEOF WNDCLASSEX<br />	mov (WNDCLASSEX PTR ).style, CS_HREDRAW or CS_VREDRAW<br />	mov ecx,lpfnwndproc<br />	mov (WNDCLASSEX PTR ).lpfnWndProc,ecx<br />	mov (WNDCLASSEX PTR ).cbClsExtra,NULL<br />	mov (WNDCLASSEX PTR ).cbWndExtra,NULL<br />	mov ecx,hInst<br />	mov (WNDCLASSEX PTR ).hInstance,ecx<br />	mov (WNDCLASSEX PTR ).hbrBackground,COLOR_WINDOW+1<br />	mov (WNDCLASSEX PTR ).lpszMenuName,NULL<br />	mov ecx,clsName<br />	mov (WNDCLASSEX PTR ).lpszClassName,ecx<br />	invoke LoadIcon,NULL,IDI_APPLICATION<br />	mov (WNDCLASSEX PTR ).hIcon,eax<br />	mov (WNDCLASSEX PTR ).hIconSm,eax<br />	invoke LoadCursor,NULL,IDC_ARROW<br />	mov (WNDCLASSEX PTR ).hCursor,eax<br />	ret<br />PopulateWndClassEx EndP<br />;or alternative to it:<br />PopulateWndClassExAssume proc wcAdr:DWORD,lpfnwndproc:DWORD,hInst:HANDLE,clsName:DWORD<br />	ASSUME ebx:PTR WNDCLASSEX<br />	mov ebx,wcAdr<br />	<br />	mov .cbSize, SIZEOF WNDCLASSEX<br />	mov .style, CS_HREDRAW or CS_VREDRAW<br />	mov ecx,lpfnwndproc<br />	mov .lpfnWndProc,ecx<br />	mov .cbClsExtra,NULL<br />	mov .cbWndExtra,NULL<br />	mov ecx,hInst<br />	mov .hInstance,ecx<br />	mov .hbrBackground,COLOR_WINDOW+1<br />	mov .lpszMenuName,NULL<br />	mov ecx,clsName<br />	mov .lpszClassName,ecx<br />	invoke LoadIcon,NULL,IDI_APPLICATION<br />	mov .hIcon,eax<br />	mov .hIconSm,eax<br />	invoke LoadCursor,NULL,IDC_ARROW<br />	mov .hCursor,eax<br />	ASSUME ebx:nothing<br />	ret<br />PopulateWndClassExAssume EndP<br /><br /><br />start:<br />invoke GetModuleHandle, NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; get the instance handle of our program.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Under Win32, hmodule==hinstance mov hInstance,eax<br />mov hInstance,eax<br />invoke GetCommandLine&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; get the command line. You don&#39;t have to call this function IF<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; your program doesn&#39;t process the command line.<br />mov CommandLine,eax<br />invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT&nbsp; &nbsp; &nbsp; &nbsp; ; call the main function<br />invoke ExitProcess, eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; quit our program. The exit code is returned in eax from WinMain.<br /><br />WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD<br />&nbsp; &nbsp; LOCAL wc:WNDCLASSEX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; create local variables on stack<br />&nbsp; &nbsp; LOCAL msg:MSG<br />&nbsp; &nbsp; LOCAL hwnd:HWND<br />&nbsp; &nbsp; invoke PopulateWndClassEx,addr wc,OFFSET WndProc,hInstance,OFFSET ClassName<br />&nbsp; &nbsp; invoke RegisterClassEx, addr wc&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; register our window class<br />&nbsp; &nbsp; invoke CreateWindowEx,NULL,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ADDR ClassName,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ADDR AppName,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WS_OVERLAPPEDWINDOW,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CW_USEDEFAULT,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CW_USEDEFAULT,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CW_USEDEFAULT,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CW_USEDEFAULT,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NULL,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NULL,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hInst,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NULL<br />&nbsp; &nbsp; mov&nbsp;  hwnd,eax<br />&nbsp; &nbsp; invoke ShowWindow, hwnd,CmdShow&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; display our window on desktop<br />&nbsp; &nbsp; invoke UpdateWindow, hwnd&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; refresh the client area<br /><br />&nbsp; &nbsp; .WHILE TRUE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Enter message loop<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke GetMessage, ADDR msg,NULL,0,0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .BREAK .IF (!eax)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke TranslateMessage, ADDR msg<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke DispatchMessage, ADDR msg<br />&nbsp;  .ENDW<br />&nbsp; &nbsp; mov&nbsp; &nbsp;  eax,msg.wParam&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; return exit code in eax<br />&nbsp; &nbsp; ret<br />WinMain endp<br /><br />WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM<br />&nbsp; &nbsp; .IF uMsg==WM_DESTROY&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; if the user closes our window<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PostQuitMessage,NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; quit our application<br />&nbsp; &nbsp; .ELSE<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke DefWindowProc,hWnd,uMsg,wParam,lParam&nbsp; &nbsp;  ; Default message processing<br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; .ENDIF<br />&nbsp; &nbsp; xor eax,eax<br />&nbsp; &nbsp; ret<br />WndProc endp<br /><br />end start <br /></code></pre></div>
    <div class="meta">Posted on 2006-11-18 09:07:46 by bhavacakra</div>
   </div>
  </div>
 </body>
</html>