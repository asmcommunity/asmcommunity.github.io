<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Triangles and the Plane Equation - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=18787" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=18787">Triangles and the Plane Equation</a></p>
   <div class="post" id="post-145441">
    <div class="subject"><a href="#post-145441">Triangles and the Plane Equation</a></div>
    <div class="body">Please help :)<br /><br />I want to classify a point (3d vertex) against a triangle's plane.<br />In order to do this, first I must calculate the Surface Normal of the triangle.<br />This is achieved by obtaining the Cross Product of any two Edges of the triangle.<br />To calculate two Edges U,V from vertices A,B and C, we simply perform some vertex subtractions, U=B-A , V=C-A<br />We then obtain the Cross Product of U and V vectors, which is the Surface Normal of the Triangle - but before we use it, we Normalize it to ensure it has Unit Length.<br /><br />Having calculated the triangle's SurfaceNormal, we can now obtain &quot;d&quot; (distance from Origin to nearest point on Plane).<br /><br />d  is calculated by obtaining the Dot Product of the Normal Vector and a Point Vector which must lay on the Plane (just use any of the Vertices).<br /><br />I'm confused as to how to use d to calculate the distance of arbitrary points from the plane - and thus determine which side they are on... any help here?</div>
    <div class="meta">Posted on 2004-07-05 10:56:15 by Homer</div>
   </div>
   <div class="post" id="post-145442">
    <div class="subject"><a href="#post-145442">Triangles and the Plane Equation</a></div>
    <div class="body">That sound so much like the vectors that I have to study for my maths exams ;) . The method of obtaining the normal of a plane is the same as what I learnt. I do not think you need to find d. To find point on the plane, just use the express the plane equation in dot product form.<br /><br /> maybe this is irrelevant because I am not very sure what are you asking. :grin:</div>
    <div class="meta">Posted on 2004-07-05 11:59:29 by roticv</div>
   </div>
   <div class="post" id="post-145443">
    <div class="subject"><a href="#post-145443">Triangles and the Plane Equation</a></div>
    <div class="body">What I want is the shortest distance from any point to the plane, signed, showing which side it lays on.</div>
    <div class="meta">Posted on 2004-07-05 12:06:40 by Homer</div>
   </div>
   <div class="post" id="post-145444">
    <div class="subject"><a href="#post-145444">Triangles and the Plane Equation</a></div>
    <div class="body">I see I see.... First find the normal, lets call it n.<br />Let A be a point on the plane and U be the point from the plane that you want to find.<br />Find the direction vector UA.<br />Shortest distance = UA dot unit vector of n<br /><br />I am not sure about the showing which side it lies on.</div>
    <div class="meta">Posted on 2004-07-05 12:15:18 by roticv</div>
   </div>
   <div class="post" id="post-145447">
    <div class="subject"><a href="#post-145447">Triangles and the Plane Equation</a></div>
    <div class="body">The sign of the result :) Thanks :)</div>
    <div class="meta">Posted on 2004-07-05 12:22:50 by Homer</div>
   </div>
   <div class="post" id="post-145450">
    <div class="subject"><a href="#post-145450">Triangles and the Plane Equation</a></div>
    <div class="body">Here's some not-working code to look at - see if you can spot the issue.<br />(Polygons are Triangles, Triangles are just 3x3d vectors for vertices)<br /><br /><br /><pre><code><br />;Nx=UyVz - UzVy<br />;Ny=UzVx - UxVz<br />;Nz=UxVy - YyVx<br />D3DXVec3Cross proc uses ebx ecx pOut, pv1, pv2<br />mov eax,pv1<br />mov ebx,pv2<br />mov ecx,pOut<br />assume eax&#58;ptr D3DXVECTOR3<br />assume ebx&#58;ptr D3DXVECTOR3<br />assume ecx&#58;ptr D3DXVECTOR3<br />fld &#91;eax&#93;.y<br />fmul &#91;ebx&#93;.z<br />fld &#91;eax&#93;.z<br />fmul &#91;ebx&#93;.y<br />fsub<br />fstp &#91;ecx&#93;.x<br /><br />fld &#91;eax&#93;.z<br />fmul &#91;ebx&#93;.x<br />fld &#91;eax&#93;.x<br />fmul &#91;ebx&#93;.z<br />fsub<br />fstp &#91;ecx&#93;.y<br /><br />fld &#91;eax&#93;.x<br />fmul &#91;ebx&#93;.y<br />fld &#91;eax&#93;.y<br />fmul &#91;ebx&#93;.x<br />fsub<br />fstp &#91;ecx&#93;.z<br /><br />assume eax&#58;nothing<br />assume ebx&#58;nothing<br />assume ecx&#58;nothing<br />ret<br />D3DXVec3Cross endp<br /><br />;DotProduct = &#40;x1*x2 + y1*y2 + z1*z2&#41;<br />D3DXVec3Dot proc pv1,pv2<br />mov ebx,pv1<br />mov ecx,pv2<br />fld &#91;ebx&#93;.D3DXVECTOR3.x<br />fmul &#91;ecx&#93;.D3DXVECTOR3.x<br />fld &#91;ebx&#93;.D3DXVECTOR3.y<br />fmul &#91;ecx&#93;.D3DXVECTOR3.y<br />fld &#91;ebx&#93;.D3DXVECTOR3.z<br />fmul &#91;ecx&#93;.D3DXVECTOR3.z<br />fadd<br />fadd<br />ret<br />D3DXVec3Dot endp<br /><br /><br />;Calculate the &quot;Surface Normal&quot; of a Polygon surface &#40;ours are all triangles&#41;<br />;&#40;Think of it as an arrow pointing in the direction the surface is facing&#41;<br />;pNormalOut&#58; pointer to a 3DVector to receive the returned Normal vector<br />;pPolygon&#58; pointer to a Triangle<br />SurfaceNormal proc pNormalOut&#58;DWORD, pPolygon&#58;DWORD<br />local v1&#58;D3DXVECTOR3<br />local v2&#58;D3DXVECTOR3<br />local fLen&#58;FLOAT<br /><br />;We need to calculate two EDGE VECTORS from the triangle vertices<br />mov ebx,pPolygon<br />lea ecx,v1<br />fld    &#91;ebx&#93;.Triangle.Point1.x<br />fsub &#91;ebx&#93;.Triangle.Point2.x<br />fstp &#91;ecx&#93;.D3DXVECTOR3.x<br />fld    &#91;ebx&#93;.Triangle.Point2.y<br />fsub &#91;ebx&#93;.Triangle.Point1.y<br />fstp &#91;ecx&#93;.D3DXVECTOR3.y<br />fld    &#91;ebx&#93;.Triangle.Point1.z<br />fsub &#91;ebx&#93;.Triangle.Point2.z<br />fstp  &#91;ecx&#93;.D3DXVECTOR3.z<br /><br />;$Message &quot;Side1.x=%lX&quot;,v1.x<br />;$Message &quot;Side1.y=%lX&quot;,v1.y<br />;$Message &quot;Side1.z=%lX&quot;,v1.z<br /><br />lea ecx,v2<br />fld    &#91;ebx&#93;.Triangle.Point2.x<br />fsub &#91;ebx&#93;.Triangle.Point3.x<br />fstp  &#91;ecx&#93;.D3DXVECTOR3.x<br />fld    &#91;ebx&#93;.Triangle.Point2.y<br />fsub &#91;ebx&#93;.Triangle.Point3.y<br />fstp &#91;ecx&#93;.D3DXVECTOR3.y<br />fld    &#91;ebx&#93;.Triangle.Point2.z<br />fsub &#91;ebx&#93;.Triangle.Point3.z<br />fstp &#91;ecx&#93;.D3DXVECTOR3.z<br />;$Message &quot;Side2.x=%lX&quot;,v2.x<br />;$Message &quot;Side2.y=%lX&quot;,v2.y<br />;$Message &quot;Side2.z=%lX&quot;,v2.z<br /><br />;Calculate vector normal of polygon = crossproduct of any 2 _SIDES_ of the triangle<br />invoke D3DXVec3Cross, pNormalOut, addr v2, addr v1<br /><br /><br />;Now Normalize the Normal so it has Unit Length &#40;3d Length=1.0&#41;<br />mov ebx,pNormalOut                        ;First calculate the Length of the un-normalized Vector<br />fld &#91;ebx&#93;.D3DXVECTOR3.x     <br />fmul &#91;ebx&#93;.D3DXVECTOR3.x<br />fld &#91;ebx&#93;.D3DXVECTOR3.y<br />fmul &#91;ebx&#93;.D3DXVECTOR3.y<br />fld &#91;ebx&#93;.D3DXVECTOR3.z<br />fmul &#91;ebx&#93;.D3DXVECTOR3.z<br />fadd<br />fadd<br />fsqrt   <br />fstp fLen                                   ;fLen= sqrt &#40;x^2 + Y^2 + z^2&#41;<br />fld &#91;ebx&#93;.D3DXVECTOR3.z       ;Then, Divide Vector Components by fLen to Unitize them &#40;without altering the Vector&#41;<br />fdiv fLen<br />fstp &#91;ebx&#93;.D3DXVECTOR3.z<br />fld &#91;ebx&#93;.D3DXVECTOR3.y<br />fdiv fLen<br />fstp &#91;ebx&#93;.D3DXVECTOR3.y<br />fld &#91;ebx&#93;.D3DXVECTOR3.x<br />fdiv fLen<br />fstp &#91;ebx&#93;.D3DXVECTOR3.x<br /><br />ret<br />SurfaceNormal endp<br />;================================================================<br /><br />.data<br />fp0 FLOAT 0.0f<br />.code<br />ClassifyPoint proc pPolygon&#58;DWORD, pPoint&#58;DWORD<br />local vNormal&#58;D3DXVECTOR3<br />local fDistance&#58;FLOAT<br /><br />fld fp0<br />fst vNormal.x<br />fst vNormal.y<br />fstp vNormal.z<br /><br />invoke SurfaceNormal, addr vNormal, pPolygon                    ;Calculate the Normal of the polygon surface<br /><br />  mov ebx,pPolygon                       ;Offset the Point Being Tested by - the &quot;Origin&quot; used in the Normal calculation<br />  mov ecx,pPoint                       ;This has the effect of offsetting the Plane to the Point, less the Normal.<br />  fld &#91;ebx&#93;.D3DXVECTOR3.x<br />  fsub &#91;ecx&#93;.D3DXVECTOR3.x<br />  fstp &#91;ebx&#93;.D3DXVECTOR3.x<br />  fld &#91;ebx&#93;.D3DXVECTOR3.y<br />  fsub &#91;ecx&#93;.D3DXVECTOR3.y<br />  fstp &#91;ebx&#93;.D3DXVECTOR3.y<br />  fld &#91;ebx&#93;.D3DXVECTOR3.z<br />  fsub &#91;ecx&#93;.D3DXVECTOR3.z<br />  fstp &#91;ebx&#93;.D3DXVECTOR3.z<br /><br />invoke D3DXVec3Dot, addr vNormal, pPoint                         ; Get which side of surface is point<br />fstp fDistance<br /><br />fld fDistance<br />fabs                   ;absolute &#40;unsigned&#41; value of distancefromplane<br />fcomp fEpsilon              ;if returnvalue &lt; floating tolerance &#40;small float value like 0.001&#41;<br />__FJG @F<br />return COINCIDING           ;then we say it's close enough to being smack on the Plane<br />@@&#58;                             ;but if the &#40;unsigned&#41; distancefromplane isnt really small<br /><br />mov eax,fDistance          ;then we check the sign of the distancefromplane<br />and eax,80000000h         ;by checking the sign bit &#40;31&#41;<br />.if eax!=0                          ;and if its set, the distance is negative<br />    return BEHIND             ;meaning the point is BEHIND the plane<br />.endif                               ;otherwise, if the distance is positive,<br />return INFRONT              ;then the point is INFRONT of the plane.<br />ClassifyPoint endp<br />;================================================================<br />.data<br />testtri D3DXVECTOR3  &lt;10.0f,10.0f,20.0f&gt;,&lt;10.0f,20.0f,20.0f&gt;,&lt;15.0,15.0f,5.0f&gt;<br />testvec  D3DXVECTOR3 &lt;0.0f,0.0f, 6.0f&gt; <br /><br /></code></pre></div>
    <div class="meta">Posted on 2004-07-05 12:28:18 by Homer</div>
   </div>
   <div class="post" id="post-145484">
    <div class="subject"><a href="#post-145484">Triangles and the Plane Equation</a></div>
    <div class="body">Nevermind, I got it working :)<br /><br />Ignore the filename, the attached example binary+src merely classifies a 3d point against a 3d triangle and tells you whether the point lays on the plane of the triangle, or on either side of it. The plane is discovered from the triangle geometry. An Epsilon value is used to give the plane some &quot;thickness&quot; to negate fpu inaccuracy.<br />The example also employs the use of a CVector array manager which I intend to employ in a fast-sorting algorithm for a bspgen.</div>
    <div class="meta">Posted on 2004-07-06 01:07:56 by Homer</div>
   </div>
   <div class="post" id="post-145502">
    <div class="subject"><a href="#post-145502">Triangles and the Plane Equation</a></div>
    <div class="body">Somehow it seems that the vectors crap that I learnt in college came in handy here ;). At least it works here..</div>
    <div class="meta">Posted on 2004-07-06 06:53:47 by roticv</div>
   </div>
   <div class="post" id="post-145505">
    <div class="subject"><a href="#post-145505">Triangles and the Plane Equation</a></div>
    <div class="body">Yes you helped in a small way, and I appreciated it.<br />I guess a lot of my interests are not broad interests, however I was disqualified from college in year 11 (long story) and missed this part of math... I've had a long hard slog teaching myself over the past few years, and I daresay I wouldn't have cared if I'd listened the first time !!</div>
    <div class="meta">Posted on 2004-07-06 08:47:45 by Homer</div>
   </div>
  </div>
 </body>
</html>