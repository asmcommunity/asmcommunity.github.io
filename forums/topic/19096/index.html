<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>anyway to find out the size of the ... parameters on the sta - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19096" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=19096">anyway to find out the size of the ... parameters on the sta</a></p>
   <div class="post" id="post-147638">
    <div class="subject"><a href="#post-147638">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body">i have a C++ static  function with variable number of arguments as declared below<br /><br />static int variablecall(int karl,int k2,...)<br /><br />from looking at the calling code<br /><pre><code><br />ret1 = ct.variablecall&#40;2,10,50,40,30,40&#41;;<br />00401C0D  push        28h  <br />00401C0F  push        1Eh  <br />00401C11  push        28h  <br />00401C13  push        32h  <br />00401C15  push        0Ah  <br />00401C17  push        2    <br />00401C19  call        callingtest&#58;&#58;variablecall &#40;401D70h&#41; <br />00401C1E  add         esp,18h <br />00401C21  mov         dword ptr &#91;ret1&#93;,eax <br />	ret1 = ct.variablecall&#40;2,10,50,40&#41;;<br />00401C24  push        28h  <br />00401C26  push        32h  <br />00401C28  push        0Ah  <br />00401C2A  push        2    <br />00401C2C  call        callingtest&#58;&#58;variablecall &#40;401D70h&#41; <br />00401C31  add         esp,10h <br />00401C34  mov         dword ptr &#91;ret1&#93;,eax <br /></code></pre><br />it is CDECL style where the CALLER cleans up the stack<br />so my question, is there anyway inside the function to tell the size on the stack that the variable arguments take up? maybe based on the EBP,ESP values when the function is called.<br /><br />and here is the dissasembly of the function<br />ESP obivously would be the current stack pointer<br /><br /><pre><code><br />static int variablecall&#40;int karl,int k2,...&#41;<br />		&#123;<br />00401D70  push        ebp  <br />00401D71  mov         ebp,esp <br />00401D73  push        ecx  <br />			int test;<br />			test = karl;<br />00401D74  mov         eax,dword ptr &#91;karl&#93; <br />00401D77  mov         dword ptr &#91;test&#93;,eax <br />			test = test*2;<br />00401D7A  mov         ecx,dword ptr &#91;test&#93; <br />00401D7D  shl         ecx,1 <br />00401D7F  mov         dword ptr &#91;test&#93;,ecx <br />			return test;<br />00401D82  mov         eax,dword ptr &#91;test&#93; <br />		&#125;<br /></code></pre><br />obviously when the function is first entered esp would be the current stack pointer<br />but before ebp is pushed and set to the local base pointer, what is it before?<br />the base pointer of whatever function /scope is calling right?<br /><br />if i make a naked function is there anyway to compare the ebp when the function is ended and the stack pointer to find out the size difference that the total parameters make? or are other factors taken into account for the EBP when it enters? (such as local variables in the calling scope?)<br /><br />or is there any other way to find out the size of variable arguments?</div>
    <div class="meta">Posted on 2004-08-08 01:28:44 by klumsy</div>
   </div>
   <div class="post" id="post-147653">
    <div class="subject"><a href="#post-147653">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body">Pheraphst <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=16474">Stack question</a> can help a little.<br /><br />Have a nice day or night.</div>
    <div class="meta">Posted on 2004-08-08 10:05:51 by rea</div>
   </div>
   <div class="post" id="post-147767">
    <div class="subject"><a href="#post-147767">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body">that link was informative and useful<br />though it was dealing with calling c/c++ varargs procedures<br /><br />when what i want to do is BE such a procedure.. finding out the size of the varargs..<br />but i think it could be impossible, since the CALLEr manages the stack frame and its the caller who knows the size of the varargs..<br />even if it was possible i found another problem MSVC++ promotes datatypes .. i.e a float to a double before sending it through, and this wouldn't go down well in my example (where i want to basically just copy the varargs to a stackframe of another function call.)<br />so i've given up with doing it with varargs, but now just pass in a pointer to a structure containing the data i need..<br />but learnt a lot in the process.</div>
    <div class="meta">Posted on 2004-08-09 17:52:28 by klumsy</div>
   </div>
   <div class="post" id="post-147795">
    <div class="subject"><a href="#post-147795">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body">And always is nice that ;), keep moving!<br /><br />Have a nice day or night.</div>
    <div class="meta">Posted on 2004-08-09 22:58:08 by rea</div>
   </div>
   <div class="post" id="post-147796">
    <div class="subject"><a href="#post-147796">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body">It's not impossible.  Just make sure you write the procedure such that at least one perameter divulges the number of arguments.  printf() for example moves along the stack in accordance with the format string passed to it.  Some people choose to have the first argument be the number of successive arguments.  Other people might like to terminate the argument list with some signaling value.  It really all depends on how the procedure is designed.</div>
    <div class="meta">Posted on 2004-08-09 23:09:14 by iblis</div>
   </div>
   <div class="post" id="post-147799">
    <div class="subject"><a href="#post-147799">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body">in my scenario i can Only send through the args, i can't actually send through the size,<br />however i have any idea that i think would work with at least MSVC++<br /><br />the caller seems to clean up the stack consistantly in the instruction after CALL is called<br />with this command<br />add         esp,10h<br /><br />so wouldn't it be possible to get the RETURN address of CALL from the stack, to find where the next command<br />add esp,10h would be, and read the bytes to get the 10h to find out how many bytes, and adjust that according to the static parameters as well?</div>
    <div class="meta">Posted on 2004-08-09 23:30:29 by klumsy</div>
   </div>
   <div class="post" id="post-147801">
    <div class="subject"><a href="#post-147801">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body">Sorry that I cant understand perfectly what you whant...<br /><br />But I whant only show some things that I name diferent, clean can have diferent applications: feel the space with 0's, because there is some garbage (and reuse the space) or data to protect after use (only a break febore the fill will show it), or other 'no meaning' number. But add esp, 10h is aligning the stack, the data still there (Dont know much about pagining  and how stack grows, but normally still accesible lower addres esp).<br /><br /><br />Have a nice day or night.</div>
    <div class="meta">Posted on 2004-08-09 23:49:53 by rea</div>
   </div>
   <div class="post" id="post-147804">
    <div class="subject"><a href="#post-147804">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body"><div class="quote"><br />the caller seems to clean up the stack consistantly in the instruction after CALL is called<br /></div><br />This is standard C call behaviour<br /><br /><div class="quote"><br />so wouldn't it be possible to get the RETURN address of CALL from the stack, to find where the next command add esp,10h would be, and read the bytes to get the 10h to find out how many bytes, and adjust that according to the static parameters as well?<br /></div><br />No - the ESP adding might be done at _any_ point later on, and could cover multiple function calls... this can happen when optimizations are turned on.</div>
    <div class="meta">Posted on 2004-08-10 00:37:36 by f0dder</div>
   </div>
   <div class="post" id="post-147805">
    <div class="subject"><a href="#post-147805">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body">ok using my example code posted in the first example.<br /><br />when the vararg procedure is called..<br /><pre><code><br />ret1 = ct.variablecall&#40;2,10,50,40,30,40&#41;;<br />00401C0D  push        28h  <br />00401C0F  push        1Eh  <br />00401C11  push        28h  <br />00401C13  push        32h  <br />00401C15  push        0Ah  <br />00401C17  push        2    <br />00401C19  call        callingtest&#58;&#58;variablecall &#40;401D70h&#41; <br />00401C1E  add         esp,18h <br />00401C21  mov         dword ptr &#91;ret1&#93;,eax <br /></code></pre><br /><br />the static would look something like this<br /><br /><br />... (whatever was on there before)<br />28h    -  cause by the function call, a vararg<br />1Eh    -  as above<br />28h    -  as aboive<br />32h    -  as above<br />0Ah    - a non variable argument for the vararg function<br />2        - a non static  argument for the vararg function<br />RETURNADDRESS - the return address from the call callingtest:variablecall<br />OLDEBP - when our vararg function is first entered it pushes the current EBP on the static<br />(local viarables if existing (which we the maker of this function can know how many, so for now we'll ignore this<br /><br />so if we want to get the return address (so we can read from the code after it)<br /><br />mov eax, (or i could be wrong adn its plus 8<br /><br />and then eax would be pointing to this line on code<br /><br />add         esp,18h <br /><br />in <br /><pre><code><br />00401C19  call        callingtest&#58;&#58;variablecall &#40;401D70h&#41; <br />00401C1E  add         esp,18h <br />00401C21  mov         dword ptr &#91;ret1&#93;,eax <br /></code></pre><br />so we can read from the actual code to get the 18h (i might get the offset wrong but lets start from where we were.<br />mov eax, (or i could be wrong adn its plus 8)<br />mov eax,byte ptr  (to get the 18h (or whatever it is) from the add esp,18h since we know that msvc++ will always put this instruction after the vararg function returns<br />so now eax will contain 24 (18h) (in this example), and we know that we had 2 static parameter so 8 bytes, so 24 - 8 = 16, which should be the size of the  varargs which it actually is..<br /><br />so i think that this technique would be an accurate method to find the size of the varargs function calls with msvc++ (using a hack of reading the code that msvc++ makes, having an assumption of what it will write)</div>
    <div class="meta">Posted on 2004-08-10 00:38:43 by klumsy</div>
   </div>
   <div class="post" id="post-147807">
    <div class="subject"><a href="#post-147807">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body"><div class="quote"><br />No - the ESP adding might be done at _any_ point later on, and could cover multiple function calls... this can happen when optimizations are turned on.<br /></div><br />if it covered multiple function calls then the function calls would have incorrect stack pointers when they entered right? as for otpomisations on, i have looked at alot of examples WITH optmisations on and haven't seen an example yet.. but i know it _could_ happen..</div>
    <div class="meta">Posted on 2004-08-10 00:42:18 by klumsy</div>
   </div>
   <div class="post" id="post-147808">
    <div class="subject"><a href="#post-147808">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body">I finally get it, I think... ;)<br /><br /><div class="quote">so my question, is there anyway inside the function to tell the size on the stack that the variable arguments take up? maybe based on the EBP,ESP values when the function is called.</div><br /><br />Yes like in the refered post, you can use a direct comparation of ebp and esp, guess also a comparation of the old ebp and the new ebp (in the case of stack frame), but like you &quot;arguee&quot; (dont know if is the word, you will fail when in the anterior stack frame have used some local I see that you understand well that, but dont know how to go with that.<br /><br />You should get the idea that you will need inline a little asm in your C code, in the refered post is used eax to pass the actual esp address, because is where the locals of this scope end, and start the scope of the arguments passed, that is the key, choose a register that will be trashed inside the proc with varargs, then, inside the proc, you can calculate the size of the arguments passed, before or after a stack frame is created, with the value passed in  the register of choice...<br /><br />some like:<br /><br /><pre><code><br />asm&#123;<br /> mov eax esp<br />&#125;<br />ret1 = ct.variablecall&#40;2,10,50,40,30,40&#41;;<br /></code></pre><br /><br />inside your variable call you will need the calculation ;).<br /><br />Will be interesting see this type of pass variable arguments and instead the caller align the stack, use some like ret  ... exist that mnemonic?... but pheraphs only help for know the count of variable args....<br /><br /><br />Have a nice day or night.</div>
    <div class="meta">Posted on 2004-08-10 00:58:23 by rea</div>
   </div>
   <div class="post" id="post-147809">
    <div class="subject"><a href="#post-147809">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body">About the optimization...<br /><br />In the board, searching.. but dont know the exact keywords..., but when I see was this<br /><br />ct.variablecall(2,10,50,40,30,40);<br />ct.variablecall(2,10,50,40,30,40);<br />ct.variablecall(2,10,50,40,30,40);<br />ct.variablecall(2,10,50,40,30,40);<br /><br />.. Imagine that you pass diferent values and diferent lenghts, then in this case, for each call will be a: add  esp,18h,  the optimizer only do a: add esp,18h*nCalls (for this constant lenght case), see that after that aligment all the scopes where mad, regarded to the original caller, his scope was at 18h*nCalls far at the very last call (we should see how is handled local scope??.. a local variable of the original scope should not be accesible), (my recomendation is imagine how the scopes look before the aligment, and for what that type of aligment is valid whitout affect reentrant code, or the funtions scope, and not programm crash) but because now I understand you only whant know inside the called function, then<br /><br /><pre><code>asm&#123;<br /> mov eax esp<br />&#125;<br />ret1 = ct.variablecall&#40;2,10,50,40,30,40&#41;;<br />asm&#123;<br /> mov eax esp<br />&#125;<br />ret1 = ct.variablecall&#40;2,10,50,40,30,40&#41;;<br /><br />asm&#123;<br /> mov eax esp<br />&#125;<br />ret1 = ct.variablecall&#40;2,10,50,40,30,40&#41;;<br /><br />asm&#123;<br /> mov eax esp<br />&#125;<br />ret1 = ct.variablecall&#40;2,10,50,40,30,40&#41;;<br /><br />asm&#123;<br /> mov eax esp<br />&#125;<br />ret1 = ct.variablecall&#40;2,10,50,40,30,40&#41;;<br />asm&#123;<br /> mov eax esp<br />&#125;<br />ret1 = ct.variablecall&#40;2,10,50,40,30,40&#41;;<br /></code></pre><br /><br />Also if optimizer is turned on, because the function is designed for that.</div>
    <div class="meta">Posted on 2004-08-10 01:07:47 by rea</div>
   </div>
   <div class="post" id="post-147813">
    <div class="subject"><a href="#post-147813">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body"><br />asm{<br /> mov eax esp<br />}<br />ret1 = ct.variablecall(2,10,50,40,30,40);<br /></div><br /><br />that would work and is a good idea (however if one the the values say 2,10,this-&gt;that,4)<br />would happen then its possible the this-&gt;that etc would ruin my register :(<br />anyhow i don't want to do asm from Outside the function call, only inside..<br />i'm going to experiment a little with the optomisations and see if they do indeed 'wreck' my idea.<br />i'm pretty sure that architectural (like function calls) are someting the optomiser keeps quite standard not to introduce horrid little weird bugs..</div>
    <div class="meta">Posted on 2004-08-10 01:50:01 by klumsy</div>
   </div>
   <div class="post" id="post-147815">
    <div class="subject"><a href="#post-147815">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body">ok you are right, with full optomisations it consecture varargs calls it does just do one add esp, N*whatever<br />so another question, is there anythign you can write in code to tell the compiler NOT to optomise that section of code?</div>
    <div class="meta">Posted on 2004-08-10 02:19:34 by klumsy</div>
   </div>
   <div class="post" id="post-147828">
    <div class="subject"><a href="#post-147828">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body"><div class="quote"><br />ok you are right, with full optomisations it consecture varargs calls it does just do one add esp, N*whatever<br /></div><br />Darn, didn't see this before I had done a simple C+asmlisting that shows this happening. It's not just with varags, it's for all C calling convention routines. <br /><br />Oh. and EBP,ESP comparisons can't be used either, as the optimizer can choose to not use standard frames, and instead treat EBP as yet a register.<br /><br /><div class="quote"><br />so another question, is there anythign you can write in code to tell the compiler NOT to optomise that section of code?<br /></div><br /><a target="_blank" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vccelng/htm/pragm_21.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vccelng/htm/pragm_21.asp</a><br /><br />...how come you can't pass a &quot;this is the end of parameters&quot; thingy?</div>
    <div class="meta">Posted on 2004-08-10 07:31:59 by f0dder</div>
   </div>
   <div class="post" id="post-147837">
    <div class="subject"><a href="#post-147837">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body">The thing is that at runtime, you can only know the diference from addressses, all the information of the languge in code is lost.<br /><br />Then you will not know what type of argument was passed at runtime, the only way is pass information about the arguments passed is pass extra information, like iblis say about the control string of printf, not only the number but the type %s,%d, .... .<br /><br />2,10,this-&gt;that,4<br /><br />you will dont know the diference of the arguments passed, ..., Dont remember exactly how work a macro (or function?) that handle varargs in C, pheraphs only return the number of arguments passed, but without what type they are, you should get this information somewhere else. Look at the disassembly of that thing.<br /><br /><br />Have a nice day or night.</div>
    <div class="meta">Posted on 2004-08-10 10:43:41 by rea</div>
   </div>
   <div class="post" id="post-147859">
    <div class="subject"><a href="#post-147859">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body">the reason in my sceaniro is i wanted to make a methoddispacher method similar to that in my artcile (in the article rather than vararguments) i just pass in a structure that contains the parameters..<br />so in this one i would pass in a static ptr to the address, a static pointer the the class instance &quot;this&quot;, and variable arguments, which would relate exactly to the arguments of the function to call. so it would copy form the varargs to the stack for the called function..<br /><br />so without finding the size of the varargs i'd need the user to know the size and put that in, or use a terminator as you say.<br /><br />however what stopped me from using this idea is how c++ automatically promotes certian datatypes (i.e a float to a double, which would mean that if my tobecalled function excepts a float, c++ promoting the vararg float to a double would mess up the whole list of parameters/stack frame anyhow so i've given up this idea, but was still interested in the topic of this thread for curiousities sake.)<br />i'm curious why c/c++ automatically promotes a float to a double (since a float is already 32 bits), my assumption is so that people who pass in a double as a float for printf or something, don't make printf break, (because its already converted to a double).<br /><br />the reason i don't trust a terminator is what if one of the parameters contains the same value.<br /><br /><div class="quote"><br />Oh. and EBP,ESP comparisons can't be used either, as the optimizer can choose to not use standard frames, and instead treat EBP as yet a register.<br /></div><br />since i'd be implementing the vararg function i'd be using naked and using my own stack frames..<br />however i don't think i'd be able to work it out frm comparing ebp and esp, and ebp would also be influences by the CALLER scopes local variables and such wouldn't it?<br /><br />so i think i'll stay with my technique mentioned in the article, where i just pass in a pointer to a structure adn the size of the structure. but its been an interesting journey.<br /><br />over and out.<br />thanks for all the knowledge</div>
    <div class="meta">Posted on 2004-08-10 18:45:02 by klumsy</div>
   </div>
   <div class="post" id="post-147863">
    <div class="subject"><a href="#post-147863">anyway to find out the size of the ... parameters on the sta</a></div>
    <div class="body"><div class="quote"><br />i'm curious why c/c++ automatically promotes a float to a double (since a float is already 32 bits), my assumption is so that people who pass in a double as a float for printf or something, don't make printf break, (because its already converted to a double).</div>Because the original Unix C compilers made that automatic promotion, and that info was published in the classic Kernighan and Ritchie (K&amp;R) book on C. Of course, every compiler writer implemented this to stay compatible with Unix C, and be faithful to K&amp;R. When C and C++ were finally getting standardized, there was too much code (and too many compilers) that relied on the auto-promo assumptions. So it's still part of the language wherever argument types are not specified.</div>
    <div class="meta">Posted on 2004-08-10 21:56:34 by tenkey</div>
   </div>
  </div>
 </body>
</html>