<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>PROFILE and get 100% precise, consistent and stable results. - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4420" />
    <link rel="next" href="../?id=4420&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=4420">PROFILE and get 100% precise, consistent and stable results.</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=4420&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=4420&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="4420" /><input type="number" name="page" min="1" max="3" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=4420&amp;page=2">&gt;</a><a href="../?id=4420&amp;page=3">&raquo;</a></form>   <div class="post" id="post-30729">
    <div class="subject"><a href="#post-30729">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body">I'd be of more help on this board if MASM here wasn't the standard.<br />I don't want to criticize others' choice, be clear, even more considering that almost everybody here is using MASM.. but personally I find it very non-asm to use INVOKE, .IF, etc.. I have my own High Level Assembler and I think that pure assembly should never have such MASM specific constructs.<br />After all, this is win32asm board, not win32masm board. So what stops me most in supporting the board is that every larger piece of assembly code I write would break on the used-by-most-people MASM.<br /><br />Personally I find NASM much better.. because of local labels, forward referencing and many other minor reasons.. also, if powerful macros support are what keep you all tied to MASM, then NASM has a very powerful macro processor as well. About Win32 and DirectX API support well, what can I say, I do all of them perfectly with NASM.. so I don't see how MASM would be superior in this regard as well.<br /><br />Even worse, today I use more and more my own assembler (built in my language's compiler), so I have it hard to releases even public NASM code.<br /><br />Anyway, when I do so (i.e. write some NASM code instead of my own language's and compiler's code) I thought it'd be better to release it (as NASM code), instead of not doing it just because everybody else uses MASM. I'd like to contribute to the board, when possible.<br /><br />Anyway, for a start (I'll see by the reactions if it's worth or not to convert to NASM other stuff) here is a routine I use to profile code, I've already posted it in WatcomC++'s inline asm syntax, but that's a very limited assembler, so now I converted it to NASM syntax and posting again.<br />If anybody is interested in converting my NASM code to MASM, he can do the conversion and post it here publicly.<br />Sincerely I can't do the -&gt; MASM conversion by myself, because I don't have the time, and because personally I don't like MASM.<br /><br /><strong>PROFILE</strong>:<br /><br />The use is very simple: set up your CPU registers as you would, then instead of &quot;CALL yoursubroutine&quot; use &quot;PROFILE yoursubroutine&quot; (PROFILE is a macro), and you will get in the 64bit variable  how many precise cycles it took to your routine to execute (if it took less than 2^32 cycles, you can well access  as a 32bit variable). Note that the routine self-adapts itself to any past, present and future CPU (so you don't have to subtract x cycles depending on your CPU), it automatically removes the cost of the last RET in the subroutine it tests, and it calls it several times to ensure that the caches are setup (you can also test it uncached, though, but only in ring0.. e.g. in protected mode Dos, where I used this PROFILE routine most), and to do it correctly it saves and restores the CPU registers at each call.. so the only limitation here is that (being the routine to be tested called more than one time) external pointers or counters must be initialized in your own routine.. about CPU registers instead it's transparent, and behaves like if yoursubroutine to the tested was called only once.<br /><br />The advantages of this routine? It's 100% precise, consistent and stable, this is my first goal and I've never seen one that behaved better (that's why I wrote this). It self adapts to any CPU.. saving you from this major hassle. It can be used to profile whole subroutines by just using PROFILE instead of CALL, and giving a 64bit result, it can be used to profile long-executing routines as well. I still use it much for comparing different versions of a subroutine on the same dataset, to choose the best one. Also, it's precise down to 0 cycles.. so that's the most interesting thing IMO.. since it's reliable and can be used to test any routine in a perfectly precise way.<br /><br />Have a look at the source to get a better insight if this &quot;doc&quot; didn't answer to all of your questions. Here's the source anyway:<br /><br /><br />PS: I may release an &quot;inlined test&quot; profiler later today, which has its own advantages in some specific cases (you want to test the routine only 1 time, being cached or not; and/or you don't want to call a subroutine).. but of course it won't produce results as much consistent and reliable as the routine I just released.<br />Also, on the old Pentium I had (and hopefully still have somewhere in my HD) a version of PROFILE which, using the MSR's, reported not only the CPU cycles but also stalls, UV execution counts, etc.. etc.. Too bad this stuff is CPU model specific.</div>
    <div class="meta">Posted on 2002-03-25 06:15:07 by Maverick</div>
   </div>
   <div class="post" id="post-30774">
    <div class="subject"><a href="#post-30774">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body"><strong>Maverick</strong>, I moved to MASM from NASM when the development of that assembler became stagnant.  Athough it seems to have been kept alive, I believe it has been surpassed by better assemblers: SpASM and FASM.  This comment is in regaurd to producing Win32 programs (yes, NASM has the niche between Linux and Windows ASM).</div>
    <div class="meta">Posted on 2002-03-25 10:31:25 by bitRAKE</div>
   </div>
   <div class="post" id="post-30775">
    <div class="subject"><a href="#post-30775">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body">bitRake, tranlsate Meveric code to MASM, please.<br />So more people can use it.</div>
    <div class="meta">Posted on 2002-03-25 10:36:05 by The Svin</div>
   </div>
   <div class="post" id="post-30807">
    <div class="subject"><a href="#post-30807">bin2inc2masm32users</a></div>
    <div class="body">maverick, <br /><br />i also prefer nasm, or even tasm, over masm, for non-gui things. keep posting nasm sources, masm/tasm users can use they easily by compiling the snippet to a raw binary, and then using a bin2inc tool, or a tool f00der posted in this board to make bin-&gt;coff to link it to their code<br /><br />ancev</div>
    <div class="meta">Posted on 2002-03-25 13:54:24 by ancev</div>
   </div>
   <div class="post" id="post-30820">
    <div class="subject"><a href="#post-30820">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body">heck, you can just assemble with nasm and link the .obj with masm<br />or tasm or &lt;whatever&gt;.</div>
    <div class="meta">Posted on 2002-03-25 14:37:08 by f0dder</div>
   </div>
   <div class="post" id="post-30828">
    <div class="subject"><a href="#post-30828">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body">Hate to keep progs I don't use.<br />Post example then, I'll disasm it and took opcode.<br />Hate new syntax, new compilers and anything new wich is actually not new but different names for old things.<br /><br />I've offten heard like HLL programmers missundersood D.Knuth words, they say that Knuth &quot;found usefull to be able to learn new<br />language each week&quot;, the truth is Donald never said that nonsence he told about &quot;new machine language&quot; in other words<br />to learn new machine, new opcode etc. Feel difference.</div>
    <div class="meta">Posted on 2002-03-25 15:19:07 by The Svin</div>
   </div>
   <div class="post" id="post-30849">
    <div class="subject"><a href="#post-30849">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body">ancev: I will, thank you. Also, if I find some 15 minutes I will write a post about that whole bound checking thing, extending the new post/contribution originated by The Svin. I think it's an interesting subject.<br /><br />f0dder: right, but when one uses macros (I admire who writes such good macros as e.g. bitRAKE does, but I prefer to keep their use at a minimum, again, because for me asm should be asm, and HLA should be HLA), then those macros won't go into the .OBJ files.<br />Although I don't use the real power of macros, I like to extensively use them e.g. to rename things. I had to search/replace e.g. 'DWORD' in the source I provided (I don't like that word, I prefer a much more logical 'U32').</div>
    <div class="meta">Posted on 2002-03-25 17:23:22 by Maverick</div>
   </div>
   <div class="post" id="post-30851">
    <div class="subject"><a href="#post-30851">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body">True, if you use macros to &quot;call&quot; the code to be timed, some source<br />level changes will have to be done.<br /><br />And yes, &quot;u32&quot; is nicer than &quot;dword&quot;, I use u/s{8,16,32} in my C<br />source, as well as u/sint and similar. Shorter to write, etc.</div>
    <div class="meta">Posted on 2002-03-25 17:27:23 by f0dder</div>
   </div>
   <div class="post" id="post-30872">
    <div class="subject"><a href="#post-30872">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body">Same here.. but I do all uppercase (system code/data and system types), and mixed lower/uppercase (application code/data and types), and all lowercase (local data).</div>
    <div class="meta">Posted on 2002-03-25 19:33:17 by Maverick</div>
   </div>
   <div class="post" id="post-30904">
    <div class="subject"><a href="#post-30904">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body">Thanks for the macro Maverick.  Gives very accurate results here.<br />I've translated it to MASM syntax if anyone wants it.</div>
    <div class="meta">Posted on 2002-03-26 00:00:15 by grv575</div>
   </div>
   <div class="post" id="post-31017">
    <div class="subject"><a href="#post-31017">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body">Thanks, grv575.<br /><br />Meveric, it's the best I saw.</div>
    <div class="meta">Posted on 2002-03-26 11:53:15 by The Svin</div>
   </div>
   <div class="post" id="post-31019">
    <div class="subject"><a href="#post-31019">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body">Thanks Alex, I'm honoured by your comment. :)</div>
    <div class="meta">Posted on 2002-03-26 12:11:40 by Maverick</div>
   </div>
   <div class="post" id="post-31884">
    <div class="subject"><a href="#post-31884">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body">First, thanks this quite useful and it already is being used heavily by me. <br /><br />The results are rock solid (precision) but on my win98/PII I'm getting tick counts that are one lower than expected.  I know that pairing is good but 0 cycles is better than expected ;)<br /><br />Seriously, no dis intended &amp; this isn't a real problem but I was wondering if anyone else has seen this? <br /><br />Maybe I've mutated the routine &amp; slimed myself but all I'm doing is running the same test that grv575 did. Well I'm actually doing more with it but in another proggie.</div>
    <div class="meta">Posted on 2002-03-31 19:39:08 by Mutant Slime</div>
   </div>
   <div class="post" id="post-31910">
    <div class="subject"><a href="#post-31910">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body">Yes, on the surface, i have to say im also impressed by the ease of this handy tool.  Good job Maverick!<br /><br />However, i have noticed a range of #'s develop with the random # algo's being discussed in another recient thread.   The profiler agrees, to a ball park range, and discovered (to no surprise) that the order of instructions preceeding the profiler affects the outcome.  adding nop's and other things before the PROFILE comment does affect things, even if you keep the profile macro's together as he has done.<br /><br />To consolidate this I've found by adding &quot;ALIGN 4&quot; before all critical areas eliminates this varience.  Here is the code (to give you the idea)<pre><code>.586<br />.model flat,stdcall<br /><br />include profile.inc<br /><br />include \masm32\include\windows.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\masm32.inc<br />include \masm32\include\debug.inc<br />includelib \masm32\lib\masm32.lib<br />includelib \masm32\lib\debug.lib<br /><br />nrandom PROTO &#58;DWORD<br />mrandom PROTO &#58;DWORD<br />nseed   PROTO &#58;DWORD<br /><br />.code<br /><br />start&#58;<br />	invoke nseed, 1234565<br />nop<br />nop<br />align 4<br />	PROFILE simple_test<br />	PrintDword PROFILECYCLES<br />	PrintDword PROFILECYCLES+4<br />	invoke nseed, 1234565<br />nop<br />align 4<br />	PROFILE simple_test2<br />	PrintDword PROFILECYCLES<br />	PrintDword PROFILECYCLES+4<br /><br />	invoke ExitProcess,0<br /><br /><br />align 4<br />simple_test proc		<br />     invoke nrandom, 10<br />	ret<br />simple_test endp<br /><br /><br />align 4<br />simple_test2 proc		<br />     invoke mrandom, 10<br />	ret<br />simple_test2 endp<br /><br />;#########################################################################<br />;<br />;  Park Miller random number algorithm.<br />;<br />;  Written by Jaymeson Trudgen &#40;NaN&#41;<br />;  Optimized by bitRAKE &#40;Rickey Bowers Jr.&#41;<br />;  <br />;  Size&#58; 55 Bytes,  CPU Time&#58; 98 Ticks<br />;#########################################################################<br /><br />align 4<br />nrandom PROC base&#58;DWORD<br /><br />	mov eax, nrandom_seed<br /><br />	xor edx, edx<br />	mov ecx, 127773<br />	div ecx<br />	mov ecx, eax<br />	mov eax, 16807<br />	mul edx<br />	mov edx, ecx<br />	mov ecx, eax<br />	mov eax, 2836<br />	mul edx<br />	sub ecx, eax<br />	xor edx, edx<br />	mov eax, ecx<br />	mov nrandom_seed, ecx<br />	div base<br /><br />	mov eax, edx<br />	ret<br /><br />nrandom ENDP<br /><br />;   #########################################################################<br /><br />align 4<br />nseed proc TheSeed&#58;DWORD<br /><br />    .data<br />      nrandom_seed dd 12345678<br />    .code<br /><br />    mov eax, TheSeed<br />    mov nrandom_seed, eax<br /><br />    ret<br /><br />nseed endp<br /><br />;   #########################################################################<br />align 4<br />mrandom PROC base&#58;DWORD<br /><br />    mov eax, nrandom_seed<br /><br />    xor edx,edx<br />    push 127773<br />    div DWORD PTR &#91;esp&#93;<br />    push eax<br />    mov eax, 16807<br />    mul edx<br />    pop edx<br />    push eax<br />    mov eax, 2836<br />    mul edx<br />    pop edx<br />    sub edx, eax<br />    mov eax, edx    <br />    mov nrandom_seed, edx<br />    push base<br />    mov edx, 0<br />    div DWORD PTR &#91;esp&#93;<br />    add esp,8<br />    mov eax, edx<br /><br />    ret<br />mrandom ENDP<br /><br />end start</code></pre><br /><br />This kept the comparisons the same on every try and *mix* of nop's etc.  <br /><br />With this in place the evalations are consistantly 95 : 102 between the two different versions of random # gen's. (Which still agree's with my brute for method described on the other thread).<br /><br />Anyways, Thanx again for this handy tool Maverick!  I think this would make a nice addition to the MASM package :grin: ( Not trying to be offending to your assembler preference ).<br /><br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-03-31 22:56:05 by NaN</div>
   </div>
   <div class="post" id="post-31919">
    <div class="subject"><a href="#post-31919">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body"><div class="quote"><br />First, thanks this quite useful and it already is being used heavily by me. <br /><br />The results are rock solid (precision) but on my win98/PII I'm getting tick counts that are one lower than expected.  I know that pairing is good but 0 cycles is better than expected ;)<br /><br />Seriously, no dis intended &amp; this isn't a real problem but I was wondering if anyone else has seen this? <br /><br />Maybe I've mutated the routine &amp; slimed myself but all I'm doing is running the same test that grv575 did. Well I'm actually doing more with it but in another proggie. </div>That is probably due because of the (documented) fact that the cost of the RET is automatically (and intentionally) removed by the routine. So profiling a routine that just RET results in 0 cycles. One or two NOP plus a RET result in 1 cycle, etc..<br /><br />As Microsoft would say, &quot;that is a feature, not a bug&quot;.. but this time it's true. ;)</div>
    <div class="meta">Posted on 2002-04-01 00:33:29 by Maverick</div>
   </div>
   <div class="post" id="post-31922">
    <div class="subject"><a href="#post-31922">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body"><div class="quote"><br />Yes, on the surface, i have to say im also impressed by the ease of this handy tool.  Good job Maverick!<br /><br />However, i have noticed a range of #'s develop with the random # algo's being discussed in another recient thread.   The profiler agrees, to a ball park range, and discovered (to no surprise) that the order of instructions preceeding the profiler affects the outcome.  adding nop's and other things before the PROFILE comment does affect things, even if you keep the profile macro's together as he has done.<br /><br />To consolidate this I've found by adding &quot;ALIGN 4&quot; before all critical areas eliminates this varience.  Here is the code (to give you the idea)<pre><code>.586<br />.model flat,stdcall<br /><br />include profile.inc<br /><br />include \masm32\include\windows.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\masm32.inc<br />include \masm32\include\debug.inc<br />includelib \masm32\lib\masm32.lib<br />includelib \masm32\lib\debug.lib<br /><br />nrandom PROTO &#58;DWORD<br />mrandom PROTO &#58;DWORD<br />nseed   PROTO &#58;DWORD<br /><br />.code<br /><br />start&#58;<br />	invoke nseed, 1234565<br />nop<br />nop<br />align 4<br />	PROFILE simple_test<br />	PrintDword PROFILECYCLES<br />	PrintDword PROFILECYCLES+4<br />	invoke nseed, 1234565<br />nop<br />align 4<br />	PROFILE simple_test2<br />	PrintDword PROFILECYCLES<br />	PrintDword PROFILECYCLES+4<br /><br />	invoke ExitProcess,0<br /><br /><br />align 4<br />simple_test proc		<br />     invoke nrandom, 10<br />	ret<br />simple_test endp<br /><br /><br />align 4<br />simple_test2 proc		<br />     invoke mrandom, 10<br />	ret<br />simple_test2 endp<br /><br />;#########################################################################<br />;<br />;  Park Miller random number algorithm.<br />;<br />;  Written by Jaymeson Trudgen &#40;NaN&#41;<br />;  Optimized by bitRAKE &#40;Rickey Bowers Jr.&#41;<br />;  <br />;  Size&#58; 55 Bytes,  CPU Time&#58; 98 Ticks<br />;#########################################################################<br /><br />align 4<br />nrandom PROC base&#58;DWORD<br /><br />	mov eax, nrandom_seed<br /><br />	xor edx, edx<br />	mov ecx, 127773<br />	div ecx<br />	mov ecx, eax<br />	mov eax, 16807<br />	mul edx<br />	mov edx, ecx<br />	mov ecx, eax<br />	mov eax, 2836<br />	mul edx<br />	sub ecx, eax<br />	xor edx, edx<br />	mov eax, ecx<br />	mov nrandom_seed, ecx<br />	div base<br /><br />	mov eax, edx<br />	ret<br /><br />nrandom ENDP<br /><br />;   #########################################################################<br /><br />align 4<br />nseed proc TheSeed&#58;DWORD<br /><br />    .data<br />      nrandom_seed dd 12345678<br />    .code<br /><br />    mov eax, TheSeed<br />    mov nrandom_seed, eax<br /><br />    ret<br /><br />nseed endp<br /><br />;   #########################################################################<br />align 4<br />mrandom PROC base&#58;DWORD<br /><br />    mov eax, nrandom_seed<br /><br />    xor edx,edx<br />    push 127773<br />    div DWORD PTR &#91;esp&#93;<br />    push eax<br />    mov eax, 16807<br />    mul edx<br />    pop edx<br />    push eax<br />    mov eax, 2836<br />    mul edx<br />    pop edx<br />    sub edx, eax<br />    mov eax, edx    <br />    mov nrandom_seed, edx<br />    push base<br />    mov edx, 0<br />    div DWORD PTR &#91;esp&#93;<br />    add esp,8<br />    mov eax, edx<br /><br />    ret<br />mrandom ENDP<br /><br />end start</code></pre><br /><br />This kept the comparisons the same on every try and *mix* of nop's etc.  <br /><br />With this in place the evalations are consistantly 95 : 102 between the two different versions of random # gen's. (Which still agree's with my brute for method described on the other thread).<br /><br />Anyways, Thanx again for this handy tool Maverick!  I think this would make a nice addition to the MASM package :grin: ( Not trying to be offending to your assembler preference ).<br /><br />:alright:<br />NaN </div>When doing the NASM-&gt;MASM translation, if I recall correctly grv575 said he couldn't respect the alignment rules. That will definitely be a problem, as reported.<br />Also, a problem may also be (but unprobably) the fact that MASM defaults to short form of instructions.. but as I said that will unlikely cause problems.<br /><br />Could you perform the same tests using NASM? Just to see what is the problem (I think alignment which wasn't 100% accurate in the MASM translation).</div>
    <div class="meta">Posted on 2002-04-01 00:37:25 by Maverick</div>
   </div>
   <div class="post" id="post-31927">
    <div class="subject"><a href="#post-31927">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body">PS: I tested my routine on a PentiumII / Windows98 and works perfectly. It must be something specific in MASM or in the MASM version.</div>
    <div class="meta">Posted on 2002-04-01 01:26:54 by Maverick</div>
   </div>
   <div class="post" id="post-31944">
    <div class="subject"><a href="#post-31944">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body">Well i dont know about NASN, but from what i see, there is no way the macro can *know* where the routine is, to be aligned better when called upon.<br /><br />This is why i added &quot;ALIGN 4&quot; before the procs that would be called.<div class="quote">align 4<br />simple_test proc		<br />     invoke nrandom, 10<br />	ret<br />simple_test endp</div><br /><br />As well, since the PROFILE macro doesnt parse for multiple arguments (params of the routine being profiled), i added another align to the actual routine such that the invoke would be &quot;smother&quot; between procs.<div class="quote">align 4<br />nrandom PROC base:DWORD<br /> ...<br />nrandom ENDP</div><br /><br />When this was done, MASM would align the addresses of each proc on a 4 byte boundry which would keept the loading of the adresses into the pipelines consistant (i think).  <br /><br />When they werent, any extra bytes added in the code anywhere preceeding the procs, would eventually trickle down and affect the stating address of each proc, and thus cause more overhead when off alignment.<br /><br /><br />The only way i see NASM doing this is by automatically aligning every proc behind the scenes ??? (but im only guessing).<br /><br />Anywho, hope this sheds more light..<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-04-01 03:52:29 by NaN</div>
   </div>
   <div class="post" id="post-31946">
    <div class="subject"><a href="#post-31946">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body">ah.. yeah, I got it wrong then last time ;)<br />I thought you meant that the PROFILE macro had to be aligned to give proper results (i.e. CALL PROFILE had to be aligned), which didn't make much sense to me at all, to be honest.<br /><br />The fact that the routines you test should be aligned is simple: I profile a simple RET as a reference, and that simple RET *is* aligned. The whole purpose of my PROFILE code is to reliably compare different routines under the same identical conditions.. so you must provide the same identical conditions for all routines you've to test.. including the built in PROFILE RET test.<br /><br />I makes a lot of sense then that they all must begin with same alignment.<br /><br />This alignment is not 4, this alignment must be 64 (a whole cache line). I hope you can do that with MASM.. because it's the way I specified it in my original Na(S)N code ;)<br /><br />I hope that clears all the doubts, sorry if I misunderstood the previous post.</div>
    <div class="meta">Posted on 2002-04-01 04:12:06 by Maverick</div>
   </div>
   <div class="post" id="post-31964">
    <div class="subject"><a href="#post-31964">PROFILE and get 100% precise, consistent and stable results.</a></div>
    <div class="body">No probs here :)<br /><br /><br />Hey bitRAKE!, heres a stumper for you:  I racked my brain on this for a couple of hours and got nowhere fast!<br /><br />Write a custom ALIGN 64 or ALIGN 32 macro..  <br /><br />I thought it would be simple to do, at first.  Then i ran into MASM's irritable way of doing things.<br /><br />My method was:<br /><pre><code><br />MyAlign64 MACRO<br />  BB equ  64 - &#40;$ MOD 64&#41;<br />  repeat BB<br />     nop<br />  endm<br />endm<br /></code></pre><br /><br />But you see, this would be too simple.... I found out that $ is termed as 'imedExpr' where repeat wants a 'constExpr'.<br /><br />The fix in C terms would be casting the type of expression to constant, &quot; BB equ (constExpr)( 64 - ($ MOD 64))&quot;  <br /><br />But this is where i stale-mated and decided to see if you have any wisdom to shed on this idea....<br /><br />Good luck!<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-04-01 06:45:48 by NaN</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=4420&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=4420&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="4420" /><input type="number" name="page" min="1" max="3" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=4420&amp;page=2">&gt;</a><a href="../?id=4420&amp;page=3">&raquo;</a></form>  </div>
 </body>
</html>