<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Trying to convert my FASM code to NASM - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29651" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29651">Trying to convert my FASM code to NASM</a></p>
   <div class="post" id="post-209373">
    <div class="subject"><a href="#post-209373">Trying to convert my FASM code to NASM</a></div>
    <div class="body">Ok i figured out how to redo the macros(I think). but when i run the last bit of code i get &quot;error: expression syntax error&quot; <br />Also... How would I go about storing these values in memory(RAM) so I don&#039;t take up space in my program reserving bytes... this is in a bootloader so I know i only got about 1MiB or so.<br /><pre><code>%macro siprint 1 ;screen interrupt print<br />	mov &nbsp;si, %1 ;move text into SI<br />	call print_string<br />%endmacro<br />%macro add_crlfterm 2 ;string, length(start of offset)&nbsp;  adds CR+LF+null terminator<br />	mov [%1+%2], 13<br />	mov [%1+%2+1], 10<br />	mov [%1+%2+2], 0x00<br />%endmacro<br /><br />%macro add_crlf_and_print 2&nbsp; ;combine the two above functions<br />	add_crlfterm %1, %2<br />	siprint %1<br />%endmacro<br />cpustring resb 15 ;reserve 15 bytes... 12 for cpuid, 3 for crlf and null terminator<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov eax, 0x00	;Set CPUID Parameter<br /><br />	xor ebx, ebx	;Clear Output<br />	xor edx, edx<br />	xor ecx, ecx<br /><br />	CPUID		;Call CPUID<br /><br />	mov dword , ebx&nbsp; &nbsp; &nbsp; ;Throw output into the string<br />	mov dword , edx<br />	mov dword , ecx<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; add_crlf_and_print , 12; Print CPUID to screen</code></pre></div>
    <div class="meta">Posted on 2009-10-29 00:02:06 by Goose007</div>
   </div>
   <div class="post" id="post-209374">
    <div class="subject"><a href="#post-209374">Re: Trying to convert my FASM code to NASM</a></div>
    <div class="body">You&#039;re getting an expression syntax error because you&#039;re code is generating an invalid syntax. When we hand process the code it looks like this.<br /><br /><pre><code>	mov [+12], 13<br />	mov [+12+1], 10<br />	mov [+12+2], 0x00<br />	mov&nbsp; si,  ;move text into SI<br />	call print_string</code></pre><br /><br />That&#039;s not right by any means. Try using &#039;add_crlf_and_print cpustring, 12&#039; instead. In NASM the label alone will decode to the address whereas the label enclosed in brackets expands to the &quot;value of&quot;. You&#039;re wanting to use the address so you need to drop the brackets to generate.<br /><br /><pre><code>	mov , 13 ; ADDRESS + 12 = CR<br />	mov , 10 ; ADDRESS + 12 + 1 = LF<br />	mov , 0x00 ; ADDRESS + 12 + 2 = NULL Terminator<br />	mov&nbsp; si, cpustring ;move the ADDRESS of text into SI<br />	call print_string</code></pre></div>
    <div class="meta">Posted on 2009-10-29 00:21:43 by Synfire</div>
   </div>
   <div class="post" id="post-209376">
    <div class="subject"><a href="#post-209376">Re: Trying to convert my FASM code to NASM</a></div>
    <div class="body">lol well i changed it now I get a different error for the same line. I should have used NASM in the first place... I feel like i learned everything backwards using FASM for to long.<br /><br /><pre><code>add_crlf_and_print cpustring, 12</code></pre><br /><br />&quot;operation size not specified&quot;</div>
    <div class="meta">Posted on 2009-10-29 00:34:35 by Goose007</div>
   </div>
   <div class="post" id="post-209378">
    <div class="subject"><a href="#post-209378">Re: Trying to convert my FASM code to NASM</a></div>
    <div class="body"><div class="quote">NASM, by design, chooses not to remember the types of variables you declare. Whereas MASM will remember, on seeing var dw 0, that you declared var as a word?size variable, and will then be able to fill in the ambiguity in the size of the instruction mov var,2, NASM will deliberately remember nothing about the symbol var except where it begins, and so you must explicitly code mov word ,2.</div></div>
    <div class="meta">Posted on 2009-10-29 01:35:42 by baldr</div>
   </div>
   <div class="post" id="post-209381">
    <div class="subject"><a href="#post-209381">Re: Trying to convert my FASM code to NASM</a></div>
    <div class="body">baldr: Thanks alot. As far as resb and such, how would I go about saving this info in a specific address in RAM instead of adding the 15 reserved bytes to my code? like say I wanted to put it at an address not it use... like 0x8000:0x0000 and write to it kinda like<br /><br />%define cpustring 0x8000:0x0000<br /><br /><br />this way I&#039;m only adding 4 bytes to my app instead of 15... and since this seems to happen alot. I&#039;d be saving alot more space the further along I go. how would I own this memory space? or do i not even need to worry about that till I write my malloc and free functions.<br /><br />Sorry I have 5 or 6 books on the way from Amazon(well some used books take forever to ship, but I can&#039;t complain cuz I got it for $0.15 and 4$ shipping for one of them) and I&#039;m just a bit anxious.</div>
    <div class="meta">Posted on 2009-10-29 08:52:51 by Goose007</div>
   </div>
   <div class="post" id="post-209383">
    <div class="subject"><a href="#post-209383">Re: Trying to convert my FASM code to NASM</a></div>
    <div class="body">One thing you could do is put your cpuinfo buffer in &quot;section .bss&quot;. There are no &quot;segments&quot; in a flat binary file, of course. What Nasm does (acting as its own linker), is put &quot;section .text&quot; first, followed by &quot;section .data&quot;, with &quot;section .bss&quot; last - this doesn&#039;t add anything to your file, Nasm just assigns numbers to your labels. You want this *after* your padding and boot signature...<br /><br />section .text<br />jmp short overBPB<br />nop<br />; your boot/bios parameter block<br />overBPB:<br />; set up segment registers!!!<br />; your code<br />times 510 - ($ - $$) db 0<br />db 55h, 0AAh ; or 0AAh, 55h... been a while... :)<br />section .bss<br />cpuinfo resb 13<br />; etc...<br /><br />You could also put it at a specific segment:offset, but this would involve manipulating segment registers (ds). You probably don&#039;t want to do that. Why do you want to do cpuid in a bootsector anyway? Space is tight! Concentrate on loading something else (your &quot;second stage&quot;, probably) - the only thing a bootsector is good for (IMO)...<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2009-10-29 12:34:32 by fbkotler</div>
   </div>
   <div class="post" id="post-209387">
    <div class="subject"><a href="#post-209387">Re: Trying to convert my FASM code to NASM</a></div>
    <div class="body">Lol sorry this is in the second stage, but that&#039;s besides what i was really wanting to know... I have tried the following<br /><br /><pre><code> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov bx, 0200h<br />	mov ds, bx<br />	<br />	mov eax, 0x00	;Set CPUID Parameter<br /><br />	xor ebx, ebx	;Clear Output<br />	xor edx, edx<br />	xor ecx, ecx<br />	<br />	CPUID			;Call CPUID<br />	<br />	mov , ebx	;mov , ebx<br />	mov , edx	;mov , edx<br />	mov , ecx	;mov , ecx<br /><br />	call tstfunc<br />	call EOF<br /><br />tstfunc:<br />	push ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; save Ax register<br />	push bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; and the rest of them too<br />	push cx<br />	push dx<br />	push ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; ditto DS<br />	MOV BX,0200h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; segment &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />	MOV DS,BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />	MOV BX,00h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; offset &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />	MOV AH,0x0E &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Print function for int 10<br />	MOV CX,12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; print 12 characters<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .print_it: &nbsp; &nbsp; &nbsp; &nbsp;<br />	MOV AL, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; move char into AL to print it &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />	INT 10h &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; print char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />	INC BX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; increment BX by 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />	loop .print_it<br />	pop ds &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; restore DS<br />	pop dx<br />	pop cx<br />	pop bx<br />	pop ax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; restore registers<br />	ret &nbsp; &nbsp; &nbsp;</code></pre> <br /><br /><br />this works, but when i try to make it a macro it doesn&#039;t...<br /><br /><pre><code>%macro write_to_memory	3<br />	PUSH		AX			;Push registers<br />	PUSH		BX<br />	PUSH		DS			;And data segment<br />	MOV 		BX, %1			;Which segment to write to<br />	MOV		DS, BX			;Move it to the data segment<br />	MOV		BX, %2			;Which offset are we writing to<br />	MOV		, %3		;Write third parameter to destination (data to memory)<br />	POP 		DS<br />	POP		BX<br />	POP		AX<br />	RET<br />%endmacro<br />write_to_memory 0200h, 0000h, ebx<br />...<br />call testfunc</code></pre><br /><br />I assume this has to do withthe fact that i&#039;m setting BX when that&#039;s what I&#039;m reading from. but it doesn&#039;t seem to work for the other registers either..</div>
    <div class="meta">Posted on 2009-10-29 20:21:46 by Goose007</div>
   </div>
   <div class="post" id="post-209389">
    <div class="subject"><a href="#post-209389">Re: Trying to convert my FASM code to NASM</a></div>
    <div class="body">Possible problem... int 10h/0Eh sometimes uses bh for video &quot;page&quot; and bl for color/attribute - depends on bios. If substituting si (or di) for bx doesn&#039;t help, that&#039;s not it. (sorry... you said that *did* work...)<br /><br />Your macro expands (in part) to:<br /><br />mov , ebx<br /><br />That&#039;s probably not &quot;right&quot;, but you should get two characters out of it... and you said edx/ecx didn&#039;t work either... Since your macro ends in &quot;ret&quot;, you ought to be &quot;call&quot;ing it. Could that be it?<br /><br />... and you say this *is* the &quot;second stage&quot;... Jeez, I&#039;m batting 000 here! If that call/ret doesn&#039;t help, I&#039;m stumped, I guess!<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2009-10-29 22:10:15 by fbkotler</div>
   </div>
   <div class="post" id="post-209390">
    <div class="subject"><a href="#post-209390">Re: Trying to convert my FASM code to NASM</a></div>
    <div class="body">lol sorry my mind is scrambled... just found out me and my wife are having a baby the other day. I haven&#039;t been exactly .... paying as much attention to this as I was originally planning on at the moment. trying to learn ASM when you&#039;re thinking about other things in the background can be detrimental to your coding... i even typed &quot;crib&quot; on a line when she came in and asked me a question... wierd... anyway enough rambling... I will try it out in about 30 minutes when i get to my ASM machine.</div>
    <div class="meta">Posted on 2009-10-29 22:27:10 by Goose007</div>
   </div>
   <div class="post" id="post-209391">
    <div class="subject"><a href="#post-209391">Re: Trying to convert my FASM code to NASM</a></div>
    <div class="body">WOW!!! I can&#039;t believe i left RET in the macro... my final macro looks like this<br /><br /><pre><code>%macro write_to_memory	3<br />	PUSH		DS<br />	PUSH		BX<br />	MOV 		BX, %1			;Which segment to write to<br />	MOV		DS, BX			;Move it to the data segment<br />	POP		BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Restore BX in case we&#039;re reading from it<br />	MOV		SI, %2			;Which offset are we writing to<br />	MOV		, %3		;Write third parameter to destination (data to memory)<br />	POP		DS<br />%endmacro</code></pre><br /><br />OK I&#039;m still trying to remember the use for each of the registers(I know i&#039;ve been using them incorrectly)... I have been reading the Intel manual... till my books get here anyway. Thanks for pointing that out for me fbkotler!!</div>
    <div class="meta">Posted on 2009-10-29 22:40:24 by Goose007</div>
   </div>
   <div class="post" id="post-209392">
    <div class="subject"><a href="#post-209392">Re: Trying to convert my FASM code to NASM</a></div>
    <div class="body">Don&#039;t forget that your macro uses <strong>si</strong> as a scratch register (<strong>write_to_memory 0x2000, 0, si</strong> will write 0 to [0x2000:0] regardless of the <strong>si</strong> value upon invocation, for example).<br /><br />You can use 32-bit code in 16-bit code easily, just don&#039;t forget about segment limits of 0xFFFF (or you will get #PF). Here is the example:<br /><br /><pre><code><br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  eax, 80*25-2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; op-size override prefix (66) here<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; 0xb800<br />&nbsp; &nbsp; &nbsp; &nbsp; pop&nbsp; &nbsp;  es<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  dword , 0x1400+&#039;X&#039;+0x14000000+&#039;Y&#039;*0x10000; op-size and addr-size override prefixes (67 66) here<br /></code></pre><br /><br />This puts red &#039;XY&#039; on blue background in lower right corner of 80*25 text screen.</div>
    <div class="meta">Posted on 2009-10-30 02:02:27 by baldr</div>
   </div>
   <div class="post" id="post-209411">
    <div class="subject"><a href="#post-209411">Re: Trying to convert my FASM code to NASM</a></div>
    <div class="body">First, congratulations to you and &quot;Mrs. Goose007&quot; :) Having a child *will* distract you from learning asm - and a bunch of other things!<br /><br />Don&#039;t worry too much about &quot;misusing&quot; registers. Don&#039;t overwrite ones you&#039;re &quot;using&quot;, of course.&nbsp; They&#039;re called &quot;general purpose&quot; registers (not segment registers - they&#039;re quite different!). In 16-bit code, memory references are limited to bx, si, di, and bp. Some registers are implied operands to certain instructions, so they aren&#039;t entirely &quot;created equal&quot;, but mostly you can use &#039;em as you wish. As Baldr points out, you can use 32-bit registers in 16-bit code, so &quot;mov al, &quot; will work, but &quot;mov al, &quot; won&#039;t. The former requires an &quot;address override prefix&quot; (67h) - Nasm will emit that automatically. The total offset must be within the 16-bit limit of 0FFFFh. There&#039;s a &quot;trick&quot; to get around that, but don&#039;t worry about it yet.<br /><br />If I can make a couple of suggestions, you don&#039;t need to clear ebx, ecx, and edx before &quot;cpuid&quot; - they&#039;ll be overwritten anyway. Your &quot;write_to_memory&quot; macro isn&#039;t the most &quot;efficient&quot; way to do it. Might be better to do something like:<br /><br />push ds<br />push 200h<br />pop ds ; or go through another register - &quot;mov ds, 200h&quot; won&#039;t work<br />mov si, 0 ; ? if that&#039;s what you want<br />call get_vendor_string<br />; maybe call your &quot;print&quot; function before restoring ds?<br />pop ds<br />...<br /><br />...<br />get_vendor_string:<br />xor eax. eax<br />cpuid<br />mov , ebx<br />mov , edx<br />mov , ebx<br />; mov word , 0A0Dh for CR/LF, if you want - bigger buffer!<br />ret<br /><br />At this point, eax will contain the &quot;maximum level&quot; supported by cpuid - doing cpuid with a larger value will give confusing results (my Pentium IV reports 16 cores, if I ask it that!). There&#039;s an exception to that... if eax=8000000h works, you can get a longer &quot;cpuname&quot; string, including Hz, using eax = 8000001h, 80000002h, etc. This is for Linux, but could be converted to your environment easily:<br /><br />global _start<br /><br />section .bss<br />&nbsp; &nbsp; namestring resb 48<br /><br />section .text<br />_start:<br /><br />&nbsp; &nbsp; mov eax, 80000000h<br />&nbsp; &nbsp; cpuid<br />&nbsp; &nbsp; cmp eax, 80000004h<br />&nbsp; &nbsp; jb exit ; bail out if not supported<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; mov edi, namestring<br /><br />&nbsp; &nbsp; mov eax, 80000002h<br />&nbsp; &nbsp; cpuid<br />&nbsp; &nbsp; call savestring<br /><br />&nbsp; &nbsp; mov eax, 80000003h<br />&nbsp; &nbsp; cpuid<br />&nbsp; &nbsp; call savestring<br /><br />&nbsp; &nbsp; mov eax, 80000004h<br />&nbsp; &nbsp; cpuid<br />&nbsp; &nbsp; call savestring<br /><br />; print the string<br />&nbsp; &nbsp; mov ecx, namestring<br />&nbsp; &nbsp; mov edx, 48<br />&nbsp; &nbsp; mov ebx, 1<br />&nbsp; &nbsp; mov eax, 4<br />&nbsp; &nbsp; int 80h<br /><br />exit:<br />&nbsp; &nbsp; mov eax, 1<br />&nbsp; &nbsp; int 80h<br /><br />savestring:<br />&nbsp; &nbsp; stosd<br />&nbsp; &nbsp; mov eax, ebx<br />&nbsp; &nbsp; stosd<br />&nbsp; &nbsp; mov eax, ecx<br />&nbsp; &nbsp; stosd<br />&nbsp; &nbsp; mov eax, edx<br />&nbsp; &nbsp; stosd<br />&nbsp; &nbsp; ret<br /><br />I don&#039;t know if that will help you, but I recently discovered it and I think it&#039;s kinda &quot;cool&quot;. You probably will eventually want to &quot;capture&quot; the info for later use, rather than printing it.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2009-10-30 15:44:11 by fbkotler</div>
   </div>
  </div>
 </body>
</html>