<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Tutorial: adding custom instructions - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=7486" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=7486">Tutorial: adding custom instructions</a></p>
   <div class="post" id="post-54442">
    <div class="subject"><a href="#post-54442">Tutorial: adding custom instructions</a></div>
    <div class="body">This is the small tutuorial I've written once for the fasm discussion list, and I decided to post it here also for those who haven't got it yet. If anyone needs it, I can write and post here the next parts.<br /><br />Example 1 - simple approach<br />---------------------------<br />Consider we want to have the &quot;bignop&quot; instruction, without any<br />arguments, which will generate 7 bytes of value 90h.<br />First step: add this name to the table, so fasm will recognize this<br />instruction. This name is 6 bytes long, so you should find<br />instructions_6 table and put there two new lines (remember to keep the<br />alphabetical order!):<br /><br /><pre><code><br />db 'bignop',0<br />dw bignop_instruction-assembler<br /></code></pre><br /><br />This will define our new instruction, saying the handler procedure is<br />bignop_instruction, and the additional parameter is zero.<br />Now, when fasm meets this instruction in preprocessed and parsed<br />source, it will jump to your handler (the bignop_instruction label),<br />with the additional parameter in AL register.<br />So the only thing left to do is to write this instruction handler. You<br />may add it to &quot;assemble.inc&quot;, but the best solution is to create new<br />&quot;custom.inc&quot; file, and put &quot;include 'custom.inc'&quot; at the end of<br />&quot;assemble.inc&quot; file. If your editor can't handle text files larger than<br />64k, just write the following command at the DOS prompt:<br /><br />echo include 'custom.inc' &gt;&gt; assemble.inc<br /><br />Now create the &quot;custom.inc&quot; file, and put the bignop_instruction<br />handler there:<br /><br /><pre><code><br />bignop_instruction&#58;<br />        mov     al,90h<br />        mov     ecx,7<br />        rep     stos byte &#91;edi&#93;<br />        jmp     instruction_assembled<br /></code></pre><br /><br />This handler will just generate 7 bytes of code, without reading any<br />arguments, and then pass the control back to assembler. Every<br />instruction handler should be ended with this jump.<br /><br />Now recompile the fasm and try the new instruction! ;)<br /><br />Example 2 - argument processing<br />-------------------------------<br />Now we will add the &quot;varnop&quot; instruction, which will expect an<br />argument being a number specifying the length of the instruction.<br />The instruction handler is:<br /><br /><pre><code><br />varnop_instruction&#58;<br />        lods    byte &#91;esi&#93;<br />        cmp     al,'&#40;'<br />        jne     invalid_argument<br />        cmp     byte &#91;esi&#93;,'.'<br />        je      invalid_value<br />        call    get_dword_value<br />        mov     ecx,eax<br />        mov     al,90h<br />        rep     stos byte &#91;edi&#93;<br />        jmp     instruction_assembled<br /></code></pre><br /><br />This handler expects the number at ESI, so it loads a byte and<br />checks if it is a number expression (marked by a &quot;(&quot; byte). If it<br />isn't, jumps to the error handler (look at &quot;errors.inc&quot; to see what<br />errors can be handled, you can also add your own - it's simple).<br />Also, if the second byte is &quot;.&quot; it means this is floating point<br />number, and we don't want it. Then we can call the &quot;get_dword_value&quot;<br />procedure with esi pointing to the first byte after &quot;(&quot; character, and<br />the whole expression is processed, the result number is stored in EAX<br />register. Now handler generates this count of NOPs and exits.<br /><br />There are many procedures that will process arguments for you, here<br />is the list of the most useful of them:<br /><br />1. When argument is a number, call one of the following procedures with<br />   ESI pointing to the first byte after &quot;(&quot;:<br /><br />    get_byte_value - returns number in AL<br />    get_word_value - returns number in AX<br />    get_dword_value - returns number in EAX<br />    get_pword_value - returns number in DX:EAX<br />    get_qword_value - returns number in EDX:EAX<br />    get_value - converts number of any type and returns it in EDX:EAX<br /><br />2. When argument is a register, the first byte at ESI is 10h, load<br />   the second byte to AL and call:<br /><br />   convert_register - accepts only general purpose registers, sets<br />                      the AH to size of register (1, 2 or 4) and AL<br />                      to the register code number<br /><br />   convert_mmx_register - accepts only MMX registers, AH is set to<br />                          the register size (8 or 16) and AL to the<br />                          register code number<br /><br />   These procedures set also the  variable to the same<br />   value as AH register. If the  is already set to<br />   something but 0, and sizes don't match, the error handler is<br />   called.<br />   You can also process the second byte manually, you can see the<br />   possible second byte values looking at the &quot;symbols&quot; table in<br />   &quot;tables.inc&quot; file.<br /><br />3. To process size overrides, after loading the first byte of an<br />   argument into AL call get_size_operator procedure. If there is<br />   a size override, it sets the  to proper value, and<br />   loads the first byte of next symbol into AL, otherwise it does<br />   nothing.<br /><br />4. When argument is the memory (the first byte is &quot;[&quot;), call the<br />   get_address procedure with ESI pointing to the first byte after<br />   &quot;[&quot;. It will return an address value in EDX, base register code<br />   in BH, index register code in BL, index scale in CL, address<br />   size override in CH and the segment register code in<br />    variable. You can just pass the unchanged BX,<br />   CX and EDX registers to the store_instruction procedure, with<br />    set to instruction code and  set to<br />   the register code or instruction extension - the whole opcode will<br />   be generated then and stored at EDI. If  is set to 0Fh,<br />   the  should contain the value of second opcode byte.<br /><br />To make 16-bit version of instruction (regardless the &quot;use16&quot; or<br />&quot;use32&quot; setting), call the operand_16bit_prefix procedure before<br />generation an opcode. To make 32-bit version, call the<br />operand_32bit_prefix.<br /><br />Please look at the various instruction handlers in &quot;assemble.inc&quot; for<br />the more complex examples.<br /><br />Example 3 - common handler<br />--------------------------<br /><br />We can make the common handler for the both of above instructions,<br />using the additional parameter field:<br /><br />in &quot;tables.inc&quot;:<br /><br /><pre><code><br />db 'bignop',7<br />dw bignop_instruction-assembler<br /></code></pre><br /><br />and<br /><br /><pre><code><br />db 'varnop',0<br />dw bignop_instruction-assembler<br /></code></pre><br /><br />in &quot;custom.inc&quot;:<br /><br /><pre><code><br />bignop_instruction&#58;<br />        xor     ecx,ecx<br />        or      cl,al<br />        jnz     .store<br />        lods    byte &#91;esi&#93;<br />        cmp     al,'&#40;'<br />        jne     invalid_argument<br />        cmp     byte &#91;esi&#93;,'.'<br />        je      invalid_value<br />        call    get_dword_value<br />        mov     ecx,eax<br />      .store&#58;<br />        mov     al,90h<br />        rep     stos byte &#91;edi&#93;<br />        jmp     instruction_assembled<br /></code></pre><br /><br />If the additional parameter is 0, it reads the count argument,<br />otherwise it uses the AL as a count.<br /><br />Have a nice customizing!</div>
    <div class="meta">Posted on 2002-08-22 04:27:54 by Tomasz Grysztar</div>
   </div>
   <div class="post" id="post-54501">
    <div class="subject"><a href="#post-54501">Excellent!!!</a></div>
    <div class="body">This was realy what I needed!!! Thanks alot!<br />Keep up good working man! ;)<br /><br />Only one thing... It would be very nice to try a 64-bit version of fasm too (...that supports 16-bit, 32-bit and 64-bit registers etc. if it's possible!?!?)<br /><br />You are a great man!</div>
    <div class="meta">Posted on 2002-08-22 14:01:49 by NewToAssembly</div>
   </div>
   <div class="post" id="post-54582">
    <div class="subject"><a href="#post-54582">Tutorial: adding custom instructions</a></div>
    <div class="body">And, if it is possible, please post those 'next parts' in email list too :).</div>
    <div class="meta">Posted on 2002-08-23 05:49:34 by Aquila</div>
   </div>
   <div class="post" id="post-54829">
    <div class="subject"><a href="#post-54829">Tutorial: adding custom instructions</a></div>
    <div class="body">Let me see if I understand this right....<br /><br />We write code to genrate the code bytes we want for an instruction....<br /><br />Reassemble FASM, and it will recognize them as instructions just like mov and add....<br /><br />Kinda like a tiny assembler in the assembler...<br /><br />If that is what it is, a really nice idea.</div>
    <div class="meta">Posted on 2002-08-25 10:33:12 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-54925">
    <div class="subject"><a href="#post-54925">Tutorial: adding custom instructions</a></div>
    <div class="body">It will be really good If you comment your source code too. ;)<br /><br />------ (If It's possible to do so hehe...) :)</div>
    <div class="meta">Posted on 2002-08-26 09:38:54 by Prayut1981</div>
   </div>
  </div>
 </body>
</html>