<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Physics - 3D Simulation of Rigid Bodies - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29070" />
    <link rel="next" href="../?id=29070&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29070">Physics - 3D Simulation of Rigid Bodies</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29070&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29070&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29070" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29070&amp;page=2">&gt;</a><a href="../?id=29070&amp;page=2">&raquo;</a></form>   <div class="post" id="post-205358">
    <div class="subject"><a href="#post-205358">Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">Hello :)<br />In this thread I&#039;ll be presenting my 3D simulator engine object, which I&#039;ve been writing as a donation to the ObjAsm32 rapid program development package. I&#039;ll be providing all my current sourcecode, as well as describing both the details of the code and how the parts all fit together.<br />The engine still doesn&#039;t have a NAME, I&#039;m open to your suggestions !!<br />I&#039;ve been describing various parts of the engine in various other threads, but I wasn&#039;t prepared to provide the meat for those bones until I was satisfied that it was reasonably stable, and it seems to be.<br />The sourcecode is still being developed, and changes will be made without notice. Deal with it.<br /><br />Where do I start?<br />The engine is OBJECT ORIENTED - it uses CLASSES, and OBJECTS and such.<br />There&#039;s the main class, whose name is D3D_PhysicsSimulator.<br />The code that drives all of the Bodies being simulated is in that class.<br />The main simulator class uses a handful of &#039;utility classes&#039;.<br />Some of these it uses to represent our simulated Bodies, and others provide list-management functionality so we can keep lists of Bodies and other stuff.<br /><br />Bodies are represented by a class called CollisionHull.<br />This class describes and provides functions to simulate one single physical body of unknown geometry - its a BASE CLASS.<br />Directly deriving from CollisionHull is a class called Sphere.<br />This class provides basic support for physics and collisions involving Spherical geometry.<br />So if we were to create an instance of Sphere, that sphere object inherits all the stuff thats in CollisionHull, and is our most primitive physical, collidable Body.<br />Directly deriving from Sphere is a class called Box.<br />It provides functionality for Box/Box and Box/Sphere collisions.<br />Note that when we create a Box, it inherits the Sphere stuff, a Box has a Sphere that completely surrounds and encloses it.<br />When simulating Boxes, we use the Sphere to accelerate collision testing.<br /><br />Here&#039;s what I have in mind, eventually..<br /><div class="quote"><br />;CollisionHull<br />; Sphere<br />;&nbsp; Box<br />;&nbsp;  Cylinder<br />;&nbsp; &nbsp; Cone<br /></div><br /><br />In my next post, we&#039;ll start looking at these classes, but not in too much detail.<br />We&#039;ll just look at the &#039;class definitions&#039; and see what we have in store for us.<br /></div>
    <div class="meta">Posted on 2008-05-24 23:11:48 by Homer</div>
   </div>
   <div class="post" id="post-205360">
    <div class="subject"><a href="#post-205360">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body"><br />Let&#039;s get this show on the road :)<br /><br /><pre><code><br />SimID equ 83453<br />Object D3D_PhysicsSimulator, SimID, Streamable<br /><br />	RedefineMethod Init, 								Pointer, real4<br />	RedefineMethod Done<br />	StaticMethod Add_Body_Body_Spring,					Pointer,Pointer,Pointer,Pointer<br />	StaticMethod Add_Body_World_Spring,					Pointer,Pointer,Pointer<br />	StaticMethod Add_Box,								Pointer,Pointer,Pointer,Pointer,real4<br />&nbsp; &nbsp; StaticMethod ToggleWorldSprings<br />&nbsp; &nbsp; StaticMethod ToggleBodySprings<br />	StaticMethod ToggleGravity<br />	StaticMethod ToggleDamping<br />&nbsp; &nbsp; StaticMethod Update,								real8<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; StaticMethod GetPtrToConfig,						Pointer, dword<br />&nbsp; &nbsp; StaticMethod ComputeForces<br />&nbsp; &nbsp; StaticMethod Simulate,								real8&nbsp; &nbsp; <br />&nbsp; &nbsp; StaticMethod Integrate,								real8<br />&nbsp; &nbsp; StaticMethod CheckCollisions,						real8<br />&nbsp; &nbsp; StaticMethod Sweep_Body_Against_World_Planes,		Pointer<br />&nbsp; &nbsp; StaticMethod FindExactCollisionTime,				Pointer, Pointer, real8, real8, Pointer<br />&nbsp; &nbsp; StaticMethod ResolveCollision_BodyBody,				Pointer,Pointer<br /><br />&nbsp; &nbsp; DefineVariable SourceConfigurationIndex,			dword,0<br />&nbsp; &nbsp; DefineVariable TargetConfigurationIndex,			dword,1<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; DefineVariable DampingActive,						BOOL,TRUE	<br />&nbsp; &nbsp; DefineVariable WorldSpringsActive,					BOOL,FALSE<br />&nbsp; &nbsp; DefineVariable BodySpringsActive,					BOOL,FALSE<br />&nbsp; &nbsp; DefineVariable GravityActive,						BOOL,TRUE<br /><br /><br />&nbsp; &nbsp; Embed Bodies, 		Collection<br />&nbsp; &nbsp; Embed BodySprings, 	DataCollection<br />&nbsp; &nbsp; Embed WorldSprings, DataCollection<br />&nbsp; &nbsp; Embed Walls,		DataCollection<br />ObjectEnd<br /></code></pre><br /><br />This is the class definition for the main Simulator class.<br />Lets describe whats going on for those of you who are new to OOP, or at least to OA32.<br />SimID : Each class has a unique class id, I&#039;ve chosen one at random.<br />Streamable : This class is derived from (inherits from) a class called &#039;Streamable&#039;, which provides support for streaming data to and from files (say, to load and save the state of the simulator).<br />Redefined Methods : These are methods which already exist in the ancestor class (Streamable) that we wish to OVERRIDE. Redefining of existing methods is just one of several ways to override methods when using OA32.<br />The INIT and DONE methods are very important, their C++ counterparts are the Constructor and Destructor methods.<br />Static Methods : These are standard methods, very similar to PROCEDURES.<br />Data Variables : You can think of these as fields of a Struct - when we create an instance of this class, the memory object we receive is basically a struct described by the data variables.<br />However unlike a struct, we&#039;re able to optionally specify the default data in each field, so new objects can be created with a mixture of initialized and uninitialized data fields.<br />Embedded Objects : These are like Friend Classes in C++ , each Embed statement inserts an entire copy of the Class Definition whose name appears in the statement.<br /><br />We can see that there are four embedded objects, one of them is a Collection object, and the other three are DataCollection objects.<br />These two classes are part of OA32&#039;s ever-growing arsenal of hand-optimized plug-in code objects. <br />The Collection object manages an array of pointers to arbitrary OA32 class object instances.<br />Collection doesn&#039;t care what kind of objects they are, only that they provide a &#039;Done&#039; method.<br />When the Collection object is &#039;destroyed&#039;, it will automatically call the Done method for each Object whose pointer is contained in the managed array, so each Object can thus perform its own cleanup, if required... and if an object doesn&#039;t need to clean any resources up, we don&#039;t need to provide a Done method at all, the call will be marshalled to the ancestor class.<br />DataCollection objects are a simple twist on the Collection object - they manage arrays of heap-allocated memory chunks (ie structs) of arbitrary size.<br />When a DataCollection is destroyed, each managed memory object is automatically released.<br /><br />Thats enough ranting about the internals of OA32, this is not an OA32 thread.<br />But we need to understand the layout of OA32&#039;s class definitions so we can understand the other classes and how they fit in.<br />Next time we&#039;ll look at class definitions for the RigidBody utility classes, and then it will be time to begin wading through the Methods.<br /></div>
    <div class="meta">Posted on 2008-05-25 08:26:01 by Homer</div>
   </div>
   <div class="post" id="post-205364">
    <div class="subject"><a href="#post-205364">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">The next class we&#039;ll look at is called CollisionHull.<br />Essentially, this class describes a Rigid Body of unknown geometry.<br />It provides some essential functionality that will be required regardless of the actual shape of the bodies we are working with, so I use it as a &#039;base class&#039;.. then I go on to describe several other classes which all inherit the functionality of CollisionHull, but describe a specific geometric shape.<br /><br /><pre><code><br />CollisionHullID equ 48838<br />Object CollisionHull,CollisionHullID,Streamable<br />	RedefineMethod	Init,											Pointer<br />	StaticMethod	TransformVertices, 								Pointer, Pointer<br />	StaticMethod	Transform_Vec3_WorldToBody,						Pointer,Pointer<br />	StaticMethod	Transform_Vec3_BodyToWorld,						Pointer,Pointer<br />	StaticMethod	Get_Transform_Mat44,							dword<br />	StaticMethod	ClassifyPlanePoint,								Pointer,Pointer<br />	StaticMethod	Point_Sweep_Plane,								Pointer,Pointer,Pointer,Pointer<br />	StaticMethod	Resolve_Collision_PointNormal,					Pointer,Pointer,dword<br />	StaticMethod	Resolve_Collision_PointBodyFace,				Pointer,Pointer,dword<br />	StaticMethod	Apply_Accumulated_Response,						dword<br />	StaticMethod	Get_Closing_And_Relative_Velocities,			Pointer,dword,dword<br />	StaticMethod	Try_To_Sleep,									Pointer,Pointer<br />	StaticMethod	Integrate,										Pointer,Pointer,real8<br />	<br />	;Identifies which geometric primitive best describes this Body..<br />	;Note that this field is NOT filled, YOU HAVE TO FILL IT when you create a primitive<br />	DefineVariable dType, dword, NULL<br />	<br />	;Mass properties of the Body<br />	;See the &#039;Setup_Mass&#039; methods in the derived Geometry classes<br />	DefineVariable	Mass,real4,0.0<br />&nbsp; &nbsp; DefineVariable	OneOverMass,real4,0.0			;We use 1/Mass , where 0=infinite mass<br />&nbsp; &nbsp; DefineVariable	InverseBodyInertiaTensor,Mat33,{&lt;&gt;}<br />&nbsp; &nbsp; ;Coefficient of Restitution, for absorbing Collision energy<br />&nbsp; &nbsp; DefineVariable	CoefficientOfRestitution,real4,1.0&nbsp;  <br />&nbsp; &nbsp; ;Number of Vertices used to describe the Body&#039;s geometry (only valid for Cubes at the moment) <br />	DefineVariable	NumberOfBoundingVertices, dword, 0<br />	;This array contains the BODYSPACE declaration of the bounding vertices.<br />	;This is static data, we use it as a reference<br />	DefineVariable&nbsp; aBodyBoundingVertices, PointArray, {&lt;&gt;}<br />	;This array contains the WORLDSPACE declaration of the bounding vertices.<br />	;Its content depends on the current orientation and position of the Body<br />	;and is found by tranforming the above array.<br />	DefineVariable&nbsp; aWorldBoundingVertices, PointArray, {&lt;&gt;}<br /><br />	;Bodies which have very low energy can be put to sleep.<br />	DefineVariable bIsAwake, BOOL, TRUE<br />	<br />	;We&#039;ll put the rendering matrix here<br />	DefineVariable matRender, D3DXMATRIX, {&lt;&gt;}<br />	<br /><br />	;While checking a given body for collisions, we use this counter<br />	;to remember the number of simultaneous collisions for this Body<br />	DefineVariable dNumSimultaneousCollisions,dword,0<br />	;The collision impulses are converted into delta &#039;change in velocity&#039; (linear and angular)<br />	;and they are accumulated in these variables, pending &#039;final resolution&#039;,<br />	;where we take the Average of the deltas due to each simultaneous impulse.<br />	;This could be improved to Weight the result by comparing the Impulse magnitudes<br />	;or some other such scheme, but an Average will yield a &#039;mostly right&#039; behaviour<br />	;which is &#039;good enough for now&#039;, and certainly a lot faster.<br />	DefineVariable vAccumulated_Delta_Velocity,Vec3,{&lt;&gt;}<br />	DefineVariable vAccumulated_Delta_AngMomentum,Vec3,{&lt;&gt;}<br /><br />	;Bodies have two Physics States (Configurations)<br />	;We switch the Source and Target for each Physics TimeStep<br />&nbsp; &nbsp; DefineVariable	aConfigurations,configuration,{&lt;&gt;}<br />&nbsp; &nbsp; DefineVariable&nbsp; _theres_two_,configuration,{&lt;&gt;}<br />ObjectEnd<br /></code></pre><br /><br />I have nothing to say about this class right now, I&#039;ll edit this post later.<br />Note that pretty much all of the guts of the PHYSICS stuff is handled in this class.<br />The geometry-specific subclasses we&#039;ll look at next don&#039;t contain any PHYSICS stuff.<br />Ignoring constructor/destructors, they only contain COLLISION DETECTION stuff.<br /><br /></div>
    <div class="meta">Posted on 2008-05-26 00:35:22 by Homer</div>
   </div>
   <div class="post" id="post-205365">
    <div class="subject"><a href="#post-205365">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">I want to lay these classes down and move onto the actual code in the Methods as soon as possible, so I&#039;m going to forge on and throw the next class at you, and hope that I can engage your interest long enough to bear with me, we&#039;re nearly there :)<br /><br /><pre><code><br />;------------------------------------------------------------<br />;Spheres are derived from CollisionHull.<br />;The Sphere is the most primitive geometric shape,<br />;and is the fastest and cheapest for intersection tests.<br />SphereID equ 343455<br />Object Sphere, SphereID, CollisionHull<br />	RedefineMethod Init, Pointer, Pointer, Pointer, real4	<br />	StaticMethod Sphere_versus_Sphere,Pointer,dword<br />	StaticMethod Sphere_versus_Plane, Pointer,dword<br />	StaticMethod Sphere_Sweep_Plane,Pointer,Pointer,Pointer,Pointer<br />	StaticMethod Sphere_Sweep_Sphere,Pointer,dword,dword<br />	StaticMethod Setup_Mass,real4<br />	DefineVariable fRadius, real4, 0.0	;Sphere&#039;s radius<br />ObjectEnd<br /></code></pre><br /><br />This class describes a geometric Sphere, as you can see it inherits from CollisionHull.<br />Like I said, the collision-geometry classes only contain collision-detect methods.<br />Theres just one more class to go, then we can get our hands dirty.<br /></div>
    <div class="meta">Posted on 2008-05-26 00:48:13 by Homer</div>
   </div>
   <div class="post" id="post-205366">
    <div class="subject"><a href="#post-205366">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">Here&#039;s the last class we&#039;ll be looking at in this thread.<br />Its a 3D box :)<br /><br /><pre><code><br />BoxID equ 74435<br />Object Box, BoxID, Sphere<br />	RedefineMethod Init,			 	Pointer, Pointer, Pointer, Pointer, Pointer<br />	RedefineMethod Done<br />	RedefineMethod Setup_Mass,			real4<br />	StaticMethod IsPointInBox,			Pointer,Pointer<br />	StaticMethod Box_Find_Closest_Plane,Pointer,Pointer,Pointer<br />	StaticMethod Box_versus_Plane,		Pointer,Pointer<br />	StaticMethod Box_versus_Sphere,		Pointer,dword<br />	StaticMethod Box_versus_Box,		Pointer,dword<br />	DefineVariable vRadius, 			Vec3, {&lt;&gt;}			;xyz axial half-lengths of unrotated box<br />	DefineVariable vJointOffsetVector, 	Vec3, {&lt;&gt;}	<br />	DefineVariable pPlanes,				Pointer, NULL		;array of 6 Planes<br />ObjectEnd<br /></code></pre><br /><br />It is HIGHLY worth mentioning that the Box class inherits from the Sphere class !!!<br />EVERY BOX IS SURROUNDED BY A THEORETICAL SPHERE.<br /><br />Oh whats this - JointOffsetVector?<br />We won&#039;t be using that thing any time soon, its for &quot;articulated physics&quot;, where we start joining things together with hinges and other joints, to make machines and ragdolls and such.<br /><br />Are we there yet? Are we there yet?<br />Why yes kids, that&#039;s the last of these odd-looking things I&#039;ll post, from now on we get to SEE SOME CODE and talk about code and get back onto coding topics and generally code ourselves into a corner. Yes, I will be picking up the pace now :)<br /><br /></div>
    <div class="meta">Posted on 2008-05-26 01:06:17 by Homer</div>
   </div>
   <div class="post" id="post-205368">
    <div class="subject"><a href="#post-205368">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">Lets start by looking at the constructor and destructor methods (Init and Done), because that will help people who don&#039;t really understand this whole oop thing yet.<br /><br />Before we can run our simulation, we&#039;ll obviously need to create an instance of the simulator class... how do we do that?<br /><br /><pre><code><br />.data<br />PtrToMySimulator dd NULL<br />.code<br />mov PtrToMySimulator, $New (D3D_PhysicsSimulator)<br />OCall PtrToMySimulator::D3D_PhysicsSimulator.Init, NULL, 100.0<br /></code></pre><br /><br />OA32 lets you pass real4 (floating point) values directly, 100.0 is the half-size of my World, there will be bounding-planes placed at plus and minus 100 on the x,y and z axes.<br />When we create a new class object (instance) in OA32, we need to manually call the Init method, but generally, the Done method will be called automatically when the object is Destroyed.<br /><br />So, we&#039;ve created a new Simulator object, and stored its pointer.<br />Then, we&#039;ve called the Init method APON THAT INSTANCE of the class.<br />That&#039;s where OOP methods differ from common procedures.<br />Methods are passed a pointer to the INSTANCE of the class apon which they should operate.<br />This pointer is passed silently, as an invisible parameter, which in a debugger, appears as the first param of the proc (last param pushed).<br />You may as well imagine that there is an invisible &#039;pThis&#039; param which is the first param of any Method, because that is EXACTLY what is happening.. OA32 and C++ hide it from view, but both allow you to access it within a Method.<br />Let&#039;s take a look what&#039;s inside the D3D_PhysicsSimulator.Init method :)<br /><br /><pre><code><br />;Sets up six collision planes at the extremes of the world<br />;fWorldSize is the axial half-length of the World Cube,<br />;ie the Distance from the World Origin to the six Planes.<br />Method D3D_PhysicsSimulator.Init,uses esi edi,pOwner:Pointer,fWorldSize:real4<br />	SetObject esi<br /><br />	Acall esi.Init, pOwner	<br /><br />	;Initialize Embeddeds<br />&nbsp; &nbsp; OCall .Bodies::Collection.Init,esi,16,256,-1<br />&nbsp; &nbsp; OCall .BodySprings::DataCollection.Init,esi,16,256,-1<br />&nbsp; &nbsp; OCall .WorldSprings::DataCollection.Init,esi,16,256,-1<br />&nbsp; &nbsp; OCall .Walls::DataCollection.Init,esi,16,256,-1<br />&nbsp; &nbsp; <br />	;Create 6 &#039;Walls&#039; on the borders of the World<br />	;Theyre just the planes of an inward-facing cube<br />	<br />	;Front and Back Planes<br />	mov edi,$MemAlloc(sizeof D3DXPLANE)<br />	mov .D3DXPLANE.x,0<br />	mov .D3DXPLANE.y,0<br />	fld1<br />	fchs<br />	fstp .D3DXPLANE.z<br />	fld fWorldSize<br />	fstp .D3DXPLANE.w<br />	OCall .Walls::DataCollection.Insert,edi<br />	<br />	mov edi,$MemAlloc(sizeof D3DXPLANE)<br />	mov .D3DXPLANE.x,0<br />	mov .D3DXPLANE.y,0<br />	fld1<br />	fstp .D3DXPLANE.z<br />	fld fWorldSize<br />	fstp .D3DXPLANE.w<br />	OCall .Walls::DataCollection.Insert,edi<br /><br />	;Top and Bottom Planes<br />	mov edi,$MemAlloc(sizeof D3DXPLANE)<br />	mov .D3DXPLANE.x,0<br />	mov .D3DXPLANE.z,0<br />	fld1<br />	fchs<br />	fstp .D3DXPLANE.y<br />	fld fWorldSize<br />	fstp .D3DXPLANE.w<br />	OCall .Walls::DataCollection.Insert,edi<br />	<br />	mov edi,$MemAlloc(sizeof D3DXPLANE)<br />	mov .D3DXPLANE.x,0<br />	mov .D3DXPLANE.z,0<br />	fld1<br />	fstp .D3DXPLANE.y<br />	fld fWorldSize<br />	fstp .D3DXPLANE.w<br />	OCall .Walls::DataCollection.Insert,edi<br /><br /><br />	;Left and Right Planes<br />	mov edi,$MemAlloc(sizeof D3DXPLANE)<br />	mov .D3DXPLANE.y,0<br />	mov .D3DXPLANE.z,0<br />	fld1<br />	fchs<br />	fstp .D3DXPLANE.x<br />	fld fWorldSize<br />	fstp .D3DXPLANE.w<br />	OCall .Walls::DataCollection.Insert,edi<br />	<br />	mov edi,$MemAlloc(sizeof D3DXPLANE)<br />	mov .D3DXPLANE.y,0<br />	mov .D3DXPLANE.z,0<br />	fld1<br />	fstp .D3DXPLANE.x<br />	fld fWorldSize<br />	fstp .D3DXPLANE.w<br />	OCall .Walls::DataCollection.Insert,edi		<br />MethodEnd<br /></code></pre><br /><br />The first line says &quot;SetObject esi&quot;<br />This sets esi to be a pointer to &quot;This Object Instance&quot;, and also sets up a masm &#039;assume esi:ptr ThisClassName&#039; so that we may address any of the Data Variable fields in this object instance via &#039;.VariableName&#039;<br /><br />Then we see an &#039;ACall esi.Init, pOwner&#039;<br />ACall = ANCESTOR CALL (my daddys class)<br />OCall = OBJECT CALL&nbsp; (my own class)<br />The ACall is passing the call the the ANCESTOR CLASS&#039;s Init method.<br />If we want it, must manually pass the call on, or it wont happen.<br />These are the small things that make C++ and OA32 largely different - we can choose, and we can abuse, once we know whats going on... we have choices that are not available in C++.<br /><br />Next, we see some calls to initialize the &#039;embedded objects&#039; in the simulator class.<br />Embedded objects are created automagically, but you still need to initialize them, and unlike the objects you create yourself, you are responsible for destroying them too.<br />That means that the simulator class will also need a DONE method, whose job will be, at minimum, to call the Done method of each Embedded object.<br />For those of you who are new to OOP, please appreciate that Embedded objects are a rather advanced feature of OA32, and that theres other ways to get the same result.<br /><br />Then we see some code which is defining the world bounding planes.<br />Its not very efficient but its a good OOP example.<br />I&#039;m allocating six D3DXPLANE structs as memory objects, and storing their pointers in a DataCollection.<br />Each struct is being filled out with values that describe my six World Bounding Planes.<br /><br />Now that we&#039;ve been reminded that theres a DONE method, I better show you that too.<br /><pre><code><br />;We must clean up the Embedded classes by hand<br />Method D3D_PhysicsSimulator.Done,uses esi<br />	SetObject esi<br />	DbgWarning &quot;Closing down&quot;<br />&nbsp; &nbsp; OCall .Bodies::Collection.Done<br />&nbsp; &nbsp; OCall .BodySprings::DataCollection.Done<br />&nbsp; &nbsp; OCall .WorldSprings::DataCollection.Done<br />&nbsp; &nbsp; OCall .Walls::DataCollection.Done<br />MethodEnd<br /></code></pre><br /><br />Since theyre Embeddeds, we must manually call their Done method when we&#039;re Done.<br />If thats an advanced feature, you should have no trouble with the simple ones :P<br /><br />I&#039;d appreciate some feedback, am I hitting this from the right angle? Is the informal discussion helpful or annoying? Let me know your thoughts :)<br /><br /></div>
    <div class="meta">Posted on 2008-05-26 01:44:21 by Homer</div>
   </div>
   <div class="post" id="post-205369">
    <div class="subject"><a href="#post-205369">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">Bodies, BodySprings, WorldSprings, Walls.<br /><br />Our simulator looks after four lists of STUFF.<br />Notice how much I like Stuff? Who doesn&#039;t? Heh.<br /><br />Bodies - list of objects that derive from CollisionHull (ie Spheres and/or Boxes)<br />BodySprings - list of structs that describe inter-body springs (covered later)<br />WorldSprings - list of structs that describe springs that tether bodies to worldspace (later)<br />Walls - our set of six World Bounding Planes, hey, its a start.<br /><br />Well, you&#039;re still here, perhaps this is going to get interesting after all :)<br /><br />So - we created an instance of the Simulator class, and we Initialized it.<br />Now what?<br />In my demo, I create one or more BOXES.<br />You&#039;ll notice that the Simulator class provides a method for this, whose name is, suprisingly, Add_Box :)<br /><br />That will be the next exciting episode. Stay tuned! More after these infomercials.<br /><br /></div>
    <div class="meta">Posted on 2008-05-26 02:00:28 by Homer</div>
   </div>
   <div class="post" id="post-205375">
    <div class="subject"><a href="#post-205375">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">Now that we&#039;ve created an instance of our Simulator, we&#039;ll want to create one or more Rigid Bodies. Here is the code for the Add_Box method, which creates a 3D Box to our specifications and stores it in the simulator&#039;s collection of Bodies...<br /><br /><pre><code><br />;You must describe a new Box by the Worldspace Position of its Center of Mass,<br />;with the axial half-widths of the unrotated Box,<br />;and with the initial Orientation as a 3x3 rotation matrix (Mat33).<br />;pvJointOffset is OPTIONAL, it indicates that the Rotational origin<br />;of this Box is somewhere other than its center, useful for Articulated Bodies.<br />;If present, this vector&#039;s orientation will be tied to that of the Box,<br />;and the rotated vector can later be used to transform from box space to joint space.<br />Method D3D_PhysicsSimulator.Add_Box,uses esi, pvBoxOrigin_WorldSpace, pmatBoxOrientation, pvBoxRadius, pvJointOffset, fDensity:real4<br />LOCAL pbox<br />	SetObject esi<br />	mov pbox, $New(Box)<br />	OCall pbox::Box.Init,esi,pvBoxOrigin_WorldSpace, pmatBoxOrientation, pvBoxRadius, pvJointOffset<br />	mov eax,pbox<br />	mov .Box.dType, BODY_TYPE_BOX<br />	OCall pbox::Box.Setup_Mass, fDensity<br />	OCall .Bodies::Collection.Insert, pbox<br />	mov eax,pbox<br />MethodEnd<br /></code></pre><br /><br />As you can see, we specify the size of the box we want and the density of the material from which it is made... the method creates the box, calculates its mass from its density and size, and adds it to the collection.<br />It&#039;s not really my place to describe what a 3x3 matrix is, just know that we can use one to describe an arbitrary 3D orientation for our Box. I&#039;ll probably be talking more about &#039;Mat33&#039; later, just think of it as a math tool in the same way that a Vector is a math tool.<br /><br />I won&#039;t bother showing the Box.Init code today, as that will require an entire post - its simple and small code, but I need to talk about inheritance and other oopish stuff in that context.<br />Would you like to see the code for the Box.Setup_Mass method? :)<br /><pre><code><br />;Set up the Mass and Inertia Tensor<br />;Since our Box is described in BodySpace, we can build a &#039;Diagonal&#039; Inertia Tensor<br />Method Box.Setup_Mass, uses esi, fDensity:real4<br />LOCAL tempmat:Mat33<br /><br />	SetObject esi<br />	DbgVec3 .vRadius, &quot;Axial Half-Lengths of Box&quot;<br />	fld1<br />	<br />	;Calculate volume = length*width*height<br />	fld .vRadius.x<br />	fadd st(0),st(0)<br />	fld .vRadius.y<br />	fadd st(0),st(0)<br />	fmul<br />	fld .vRadius.z<br />	fadd st(0),st(0)<br />	fmul<br />	;Calculate Mass=Density*Volume<br />	fmul fDensity	<br />	fst .Mass<br /><br />	;Calculate 1/Mass	<br />	fdiv<br />	fstp .OneOverMass<br /><br />	;Calculate MOI Tensor for unrotated box<br /><br />	;InertiaTensor(0,0) = 1/12 * (Mass*(dY2*dY2+dZ2*dZ2))<br />	;InertiaTensor(1,1) = 1/12 * (Mass*(dX2*dX2+dZ2*dZ2))<br />	;InertiaTensor(2,2) = 1/12 * (Mass*(dX2*dX2+dY2*dY2))<br /><br />	;	WE REALLY WANT THE INVERSE OF THIS TENSOR<br />	;	We never use the tensor, we only ever use the Inverse tensor<br />	;	We can find the inverse tensor directly (without needing to Invert the tensor)<br /><br />	;InverseBodyInertiaTensor(0,0) = 12 / (Mass*(dY2*dY2+dZ2*dZ2))<br />	;InverseBodyInertiaTensor(1,1) = 12 / (Mass*(dX2*dX2+dZ2*dZ2))<br />	;InverseBodyInertiaTensor(2,2) = 12 / (Mass*(dX2*dX2+dY2*dY2))<br />	<br />	fld r4_12<br />	fld&nbsp; .vRadius.y<br />	fadd st(0),st(0)<br />	fmul st(0),st(0)<br />	fld .vRadius.z<br />	fadd st(0),st(0)<br />	fmul st(0),st(0)<br />	fadd<br />	fmul .Mass<br />	fdiv<br />	fstp .InverseBodyInertiaTensor.m00<br />	mov&nbsp; .InverseBodyInertiaTensor.m01,0<br />	mov&nbsp; .InverseBodyInertiaTensor.m02,0<br />	;<br />	fld r4_12<br />	mov .InverseBodyInertiaTensor.m10,0<br />	fld&nbsp; .vRadius.x<br />	fadd st(0),st(0)<br />	fmul st(0),st(0)<br />	fld .vRadius.z<br />	fadd st(0),st(0)<br />	fmul st(0),st(0)<br />	fadd<br />	fmul .Mass<br />	fdiv<br />	fstp tempmat.m11<br />	mov .InverseBodyInertiaTensor.m12,0<br />	;<br />	fld r4_12<br />	mov&nbsp; .InverseBodyInertiaTensor.m20,0<br />	mov&nbsp; .InverseBodyInertiaTensor.m21,0	<br />	fld&nbsp; .vRadius.x<br />	fadd st(0),st(0)<br />	fmul st(0),st(0)<br />	fld&nbsp; .vRadius.y<br />	fadd st(0),st(0)<br />	fmul st(0),st(0)<br />	fadd<br />	fmul .Mass<br />	fdiv<br />	fstp .InverseBodyInertiaTensor.m22<br />&nbsp; &nbsp; &nbsp;  ;Later, we&#039;ll transform this BodySpace matrix into WorldSpace...<br />MethodEnd<br /></code></pre><br /><br />OK, the calculating of Volume from dimensions of box, and Mass from volume and density, maybe some of you remember that stuff from school.<br />But the Inertia Tensor, you&#039;ve maybe never heard of before.<br />The tensor describes how the mass of a body is distributed over its volume (its shape).<br />We can calculate the tensor for any arbitrary closed volume of any shape, but the tensors for a bunch of common geometries like boxes, spheres, cylinders etc is KNOWN, you can find tables of these on the web.<br /><br />In the comments you&#039;ll see that we actually require not the Tensor itself, but its INVERSE.<br />Normally, inverting a matrix is an expensive operation.<br />Since the tensor is NOT a normal, orthographic matrix (unlike an orientation matrix), we cannot simply use the &#039;transpose trick&#039; to avoid performing a full Inversion of the tensor.<br />We have to do it &#039;the long way&#039;, which is really expensive.<br />I&#039;ve provided a Mat33_Inverse function which CAN do it.<br />But if we provide a bodyspace tensor which is DIAGONALIZED, we dont need to Invert it, because we know that if the tensor looks like this:<br /><br />ixx 0 0<br />0 iyy 0<br />0 0 izz<br /><br />then the inverse matrix must look like this:<br />1/ixx 0 0<br />0 1/iyy 0<br />0 0 1/izz<br /><br />and consequently, if ixx = 1/12 * Mass * (y^2 + z^2)<br />then we know that 1/ixx = 12 / Mass * (y^2 + z^2)<br />YES? :)<br /><br />noting that this is ONLY true if the matrix is nice and diagonal in the first place (only has values in the topleft to bottomright diagonals, and is otherwise full of zeroes, like Identity matrix)<br /><br />So you can see now that I was able, in this case, to avoid the InvertMatrix.<br />Now we&#039;ve created our simulator, created a box, and initialized its mass properties.<br />This object is essentially now ready to begin being simulated, but if we want to position the object somewhere specific in the world, now would be a great time to do it.<br />Yeah, we haven&#039;t actually set the initial Position yet !!<br />Theres also the initial Angular Momentum and Linear Velocity to set up if we choose to.<br />Or you can just start simulating right now, with the body at (0,0,0) in world space, no linear velocity, and no angular momentum (or velocity).<br /><br />I think we&#039;re about ready to start looking at how we drive the simulator.<br />Theres a method called D3D_PhysicsSimulator.Update which you should be calling from your main program loop (eg from your &#039;windows message pump&#039; loop).<br />This method has just one param, which is the amount of time that you wish to advance the simulation. Ideally, this should be the ELAPSED TIME between iterations of that driving loop.<br />The simulator will add this value to an internal &#039;time accumulator&#039;, and will make one call to the D3D_PhysicsSimulator.Simulate method, passing it the fixed timestep value of 0.100 seconds. This method will return a value that is either 0.100 (nothing happened) or less (something collided), and the returned value (&#039;amount of time consumed this frame&#039;) is subtracted from the time accumulator. D3D_PhysicsSimulator.Update will continue making calls to D3D_PhysicsSimulator.Simulate until the time accumulator contains less than 0.100 (until theres not enough time for a full step). When that happens, it returns to the caller (your main loop code).<br /><br />That pretty much takes care of describing the entrypoint code.<br />Its time to show you the D3D_PhysicsSimulator.Update method.<br />But you&#039;ll have to wait until the next post for that :)<br /><br /><br /></div>
    <div class="meta">Posted on 2008-05-27 01:19:29 by Homer</div>
   </div>
   <div class="post" id="post-205377">
    <div class="subject"><a href="#post-205377">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">Lets take a look at the Collision class constructors:<br /><br /><pre><code><br />Method CollisionHull.Init,uses esi, pOwner<br />	SetObject esi<br />	ACall esi.Init, pOwner<br />	invoke RtlZeroMemory,addr .aConfigurations, sizeof configuration * 2<br />MethodEnd<br /><br />Method Sphere.Init, uses esi, pOwner, pvSphereOrigin_WorldSpace, pmatSphereOrientation, fRadius:real4<br />	SetObject esi<br />	ACall esi.Init, pOwner<br />	invoke RtlZeroMemory,addr .aConfigurations, sizeof configuration*2<br />	<br />	m2m .fRadius, fRadius<br /><br />	mov eax,pvSphereOrigin_WorldSpace<br />	m2m .aConfigurations.CMPosition.x, .Vec3.x<br />	m2m .aConfigurations.CMPosition.y, .Vec3.y<br />	m2m .aConfigurations.CMPosition.z, .Vec3.z<br />	<br />	mov eax,pmatSphereOrientation<br />	m2m .aConfigurations.Orientation.m00, .Mat33.m00<br />	m2m .aConfigurations.Orientation.m01, .Mat33.m01<br />	m2m .aConfigurations.Orientation.m02, .Mat33.m02<br />	m2m .aConfigurations.Orientation.m10, .Mat33.m10<br />	m2m .aConfigurations.Orientation.m11, .Mat33.m11<br />	m2m .aConfigurations.Orientation.m12, .Mat33.m12<br />	m2m .aConfigurations.Orientation.m20, .Mat33.m20<br />	m2m .aConfigurations.Orientation.m21, .Mat33.m21<br />	m2m .aConfigurations.Orientation.m22, .Mat33.m22<br />MethodEnd<br /><br />Method Box.Init, uses edi esi, pOwner, pvBoxOrigin_WorldSpace, pmatBoxOrientation, pvBoxRadius, pvJointOffset<br />LOCAL fRadius<br />	SetObject esi<br />		<br />	;Find the radius of the box&#039;s Sphere<br />	mov edx,pvBoxRadius<br />	fld .Vec3.x<br />	fmul st(0),st(0)<br />	fld .Vec3.y<br />	fmul st(0),st(0)<br />	fld .Vec3.z<br />	fmul st(0),st(0)<br />	fadd<br />	fadd<br />	fsqrt<br />	fstp fRadius<br />	DbgFloat fRadius, &quot;Theoretical BoundingSphere radius for this Box&quot;<br />	<br />	;Initialize the Ancestor (Sphere), which will record Position (of COM) and Orientation<br />	ACall esi.Init,&nbsp; pOwner, pvBoxOrigin_WorldSpace, pmatBoxOrientation, fRadius<br />	<br />	;Copy box&#039;s axial half-widths<br />	mov eax,pvBoxRadius<br />	m2m .vRadius.x, .Vec3.x<br />	m2m .vRadius.y, .Vec3.y<br />	m2m .vRadius.z, .Vec3.z<br />	<br />	;If theres a Joint Offset vector, grab it<br />	.if pvJointOffset!=0<br />		mov edx,pvJointOffset<br />		m2m .vJointOffsetVector.x, .Vec3.x<br />		m2m .vJointOffsetVector.y, .Vec3.y<br />		m2m .vJointOffsetVector.z, .Vec3.z<br />	.endif<br /><br />	;Set up the Box Points (in Box space)<br />	mov .NumberOfBoundingVertices,8<br />	lea edi,.aBodyBoundingVertices<br />	<br />	mov eax,pvBoxRadius	<br />	;minminmin<br />	fld .Vec3.x<br />	fld .Vec3.y<br />	fld .Vec3.z	<br />	fchs<br />	fstp .Vec3.z<br />	fchs<br />	fstp .Vec3.y<br />	fchs<br />	fstp .Vec3.x<br />	add edi,sizeof Vec3<br />	;minminmax<br />	fld .Vec3.x<br />	fld .Vec3.y<br />	m2m .Vec3.z,.Vec3.z<br />	fchs<br />	fstp .Vec3.y<br />	fchs<br />	fstp .Vec3.x<br />	add edi,sizeof Vec3<br />	;minmaxmin<br />	fld .Vec3.x<br />	m2m .Vec3.y,.Vec3.y<br />	fld .Vec3.z	<br />	fchs<br />	fstp .Vec3.z<br />	fchs<br />	fstp .Vec3.x<br />	add edi,sizeof Vec3<br />	;minmaxmax<br />	fld .Vec3.x<br />	m2m .Vec3.y,.Vec3.y<br />	m2m .Vec3.z,.Vec3.z<br />	fchs<br />	fstp .Vec3.x<br />	add edi,sizeof Vec3<br />	;maxminmin<br />	m2m .Vec3.x, .Vec3.x<br />	fld .Vec3.y<br />	fld .Vec3.z<br />	fchs<br />	fstp .Vec3.z<br />	fchs<br />	fstp .Vec3.y<br />	add edi,sizeof Vec3<br />	;maxminmax<br />	m2m .Vec3.x, .Vec3.x<br />	fld .Vec3.y<br />	fchs<br />	fstp .Vec3.y<br />	m2m .Vec3.z, .Vec3.z<br />	add edi,sizeof Vec3<br />	;maxmaxmin<br />	m2m .Vec3.x, .Vec3.x<br />	m2m .Vec3.y, .Vec3.y<br />	fld .Vec3.z<br />	fchs<br />	fstp .Vec3.z<br />	add edi,sizeof Vec3<br />	;maxmaxmax<br />	m2m .Vec3.x, .Vec3.x<br />	m2m .Vec3.y, .Vec3.y<br />	m2m .Vec3.z, .Vec3.z<br />	<br /><br />	mov .pPlanes,$MemAlloc(6*sizeof Vec4)<br />	mov edi,eax<br /><br />	;Left and Right Planes<br />	mov .D3DXPLANE.y,0<br />	mov .D3DXPLANE.z,0<br />	fld1<br />	fchs<br />	fstp .D3DXPLANE.x<br />	fld .vRadius.x<br />	fstp .D3DXPLANE.w<br />	add edi,sizeof Vec4<br />	<br />	mov .D3DXPLANE.y,0<br />	mov .D3DXPLANE.z,0<br />	fld1<br />	fstp .D3DXPLANE.x<br />	fld .vRadius.x<br />	fstp .D3DXPLANE.w<br />	add edi,sizeof Vec4<br /><br />	;Top and Bottom Planes<br />	mov .D3DXPLANE.x,0<br />	mov .D3DXPLANE.z,0<br />	fld1<br />	fchs<br />	fstp .D3DXPLANE.y<br />	fld .vRadius.y<br />	fstp .D3DXPLANE.w<br />	add edi,sizeof Vec4<br />	<br />	mov .D3DXPLANE.x,0<br />	mov .D3DXPLANE.z,0<br />	fld1<br />	fstp .D3DXPLANE.y<br />	fld .vRadius.y<br />	fstp .D3DXPLANE.w<br />	add edi,sizeof Vec4<br />	<br />	;Front and Back Planes<br />	mov .D3DXPLANE.x,0<br />	mov .D3DXPLANE.y,0<br />	fld1<br />	fchs<br />	fstp .D3DXPLANE.z<br />	fld .vRadius.z<br />	fstp .D3DXPLANE.w<br />	add edi,sizeof Vec4<br />	<br />	mov .D3DXPLANE.x,0<br />	mov .D3DXPLANE.y,0<br />	fld1<br />	fstp .D3DXPLANE.z<br />	fld .vRadius.z<br />	fstp .D3DXPLANE.w<br />	add edi,sizeof Vec4<br />	<br />MethodEnd<br /></code></pre><br /><br />I&#039;m going to leave it to you to examine whats happening in each of these, what I want to talk about is the hierarchical aspect here.<br />We&#039;re going to make a Box, whose class derives from Sphere.<br />Making a Box (via D3D_PhysicsSimulator.Add_Box) will cause Box.Init to be called.<br />Within this method is a line which performs &quot;ACall Init&quot;, which actually is placing a call to the Init method in the ancestor class .. ie, Sphere.Init is being called.<br />The Sphere class derives from the CollisionHull class.<br />The Sphere.Init method contains a line which performs &quot;ACall Init&quot; - can you guess what this will do? Yes, it calls the ancestor class&#039;s Init method.. CollisionHull.Init is called.<br />That&#039;s all we really care about...<br />... but just to complete the story, CollisionHull.Init contains &#039;ACall Init&#039; also. Who is CollisionHull&#039;s daddy? Its Streamable (who we haven&#039;t met, and won&#039;t be).<br />Streamable.Init contains an &#039;ACall Init&#039; as well.<br />Streamable&#039;s daddy is called Primer, and Primer is the most primitive ObjAsm32 class, the root of all ObjAsm32 classes (like IUnknown is to COM interfaces).<br /><br />When we make a class A, and derive from it a class B, then class B inherits ALL the stuff from class A... all of the methods, and all of the Data fields.<br />This means that our Box object contains all the data fields for Box, Sphere AND CollisionHull, and has access to all the methods of those classes.&nbsp; *see footnote<br />In terms of collision detection, as mentioned in another thread, I wrap each Box with a theoretical Sphere, used to accelerate collision testing... this is how I achieved that.<br />Every box has data that describes a sphere which totally encloses that box, stored in the fields it inherited from the Sphere class.<br /><br />Note that the Sphere class defines a method called &quot;Setup_Mass&quot;.<br />Note that the Box class REDEFINES the method called &quot;Setup_Mass&quot;.<br />If we call Setup_Mass apon a Box, we get Box.Setup_Mass.<br />And if we call it apon a Sphere, we get Sphere.Setup_Mass.<br />They won&#039;t both be called unless we deliberately do it.<br /><br />So, now I&#039;ve had my oopish rant, we can get back to the entrypoint code..<br /><br /><pre><code><br />;Advances the physics simulation by one TimeStep for each TimeStep that has elapsed.<br />;This method decouples rendering from physics in regards to Time.<br />;Your application should call this from its main loop, <br />;it&#039;s your entrypoint to drive the simulation.<br />Method D3D_PhysicsSimulator.Update,uses esi,deltaTime:real8<br />.data<br />PhysicsTimeAccumulator 	real8 0.000f<br />PhysicsTimeStep 		real8 0.100f<br />.code<br />	SetObject esi<br />	.if .Bodies.dCount==0<br />		ret<br />	.endif<br />	;Accumulator = Accumulator + deltaTime<br />&nbsp; &nbsp; fld&nbsp; deltaTime					;Add the deltaTime to the Accumulator<br />&nbsp; &nbsp; fadd PhysicsTimeAccumulator<br />&nbsp; &nbsp; fstp PhysicsTimeAccumulator<br />	.repeat<br /><br />		fld&nbsp;  PhysicsTimeAccumulator	<br />		fsub&nbsp; PhysicsTimeStep<br />		fstpReg eax<br />		.if eax!=0 &amp;&amp; eax!=80000000h<br />		&nbsp; &nbsp; .ifBitSet eax,BIT31						;accumulator &lt; timestep	<br />		&nbsp; &nbsp; 	;DbgWarning &quot;not time yet&quot;	&nbsp; &nbsp; 	<br />		&nbsp; &nbsp; 	.break	;Do nothing, its not time yet<br />		&nbsp; &nbsp; .endif<br />		.endif	<br />		<br />		OCall Simulate, PhysicsTimeStep				;Advance the simulation by one TimeStep&nbsp; <br />		fchs										;counter = counter - consumed<br />		fadd PhysicsTimeAccumulator<br />		fstp PhysicsTimeAccumulator<br /><br />	.until 0<br /><br />MethodEnd<br /></code></pre><br /><br />Again, I&#039;ll leave it to you to examine what is happening in there, but essentially we&#039;re making sure that the simulation is synchronized to realtime, while also (as much as possible) operating in discrete (fixed) timesteps.<br />If you have questions, ask them!<br /><br /><br />* except for PRIVATE methods, which OA32 does indeed support.<br /><br /></div>
    <div class="meta">Posted on 2008-05-27 05:56:54 by Homer</div>
   </div>
   <div class="post" id="post-205382">
    <div class="subject"><a href="#post-205382">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">The D3D_PhysicsSimulator.Update method (we just looked at) is chopping up the incoming &#039;elapsed time&#039; into&nbsp; &#039;timesteps&#039; of 0.100 seconds , and attempting to advance the simulation by 0.100 seconds for each timestep that is &#039;available&#039;.<br />In order to attempt to advance the simulation, it makes calls to a method called D3D_PhysicsSimulator.Simulate, lets take a look at that:<br /><br /><br /><pre><code><br />;This method will attempt to advance the simulation by DeltaTime.<br />;However, if a Collision is detected DURING this timeframe,<br />;the simulation will be advanced to THAT time, and the collision resolved.<br />;Returns FPU value = amount of time &#039;consumed&#039; (DeltaTime or less)<br /><br />Method D3D_PhysicsSimulator.Simulate,uses esi, DeltaTime:real8<br />		SetObject esi<br /><br />		;Apply any &#039;contact resolution&#039; from the previous iteration, and then<br />		;calculate Force and Torque (due to current linear/angular momentum, and gravity)<br />		OCall esi.ComputeForces<br /><br />		;Integrate our system forward by &#039;remaining time&#039; (from Source to Target configuration)	<br />&nbsp; &nbsp; 	OCall esi.Integrate, DeltaTime<br />&nbsp; &nbsp; <br />	&nbsp; &nbsp; ;Perform sweep-testing of unique pairs of bodies, and also checking for body/Wall collisions<br />	&nbsp; &nbsp; OCall CheckCollisions, DeltaTime<br /><br />		;Swap the configurations: source becomes target, target becomes source<br />		push .SourceConfigurationIndex<br />		m2m&nbsp; .SourceConfigurationIndex, .TargetConfigurationIndex<br />		pop&nbsp; .TargetConfigurationIndex<br />	&nbsp; &nbsp; <br />	DbgWarning &quot;Simulated One TimeStep&quot;<br />MethodEnd<br /></code></pre><br /><br />This simple method is the very heart of the physics simulator, and if this simulator was driving a game engine, we&#039;d have to say that this piece of code is central to the entire game engine. Its that important.<br /><br />1. Compute the current linear and angular Force of each Body<br />2. Integrate the entire system to the End of the current TimeStep<br />3. Check for and handle Collisions which occur during the current timestep<br />4. Swap the &#039;global config indices&#039;<br /><br />If we look back to the definition for the CollisionHull class, we can see that each Rigid Body in our simulation has TWO &#039;configuration&#039; structs within its data fields.<br />One of these is the &quot;current&quot; physical state of the body, and the other is the &quot;target&quot; physical state at the end of the current timestep.<br />After each iteration of the simulator, these two are switched around so that the target state becomes the new source state.<br />But rather than copying/movng data around in each and every simulated body, I&#039;m simply switching a couple of indexing fields, toggling their values between (0, 1) and (1,0).<br />These indexing fields affect all simulated bodies, so they are kept in the simulator class.<br /><br />In the next post, we&#039;ll begin to get our hands dirty.<br /><br /></div>
    <div class="meta">Posted on 2008-05-27 21:26:06 by Homer</div>
   </div>
   <div class="post" id="post-205383">
    <div class="subject"><a href="#post-205383">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">This ones gonna be huge.<br />Here&#039;s the ComputeForces method.<br />Just ignore all the stuff regarding Springs if you like, I won&#039;t be discussing springs - but its interesting to note that springs directly mess with the force and torque at this early stage.<br />And for the moment, I will also disregard collision response.<br />We&#039;re really interested in how we get Force and Torque from the current state of a body plus external influences. <br /><br /><pre><code><br />;Calculate instantaneous Force and Torque<br />Method D3D_PhysicsSimulator.ComputeForces,uses esi edi ebx<br />LOCAL ftemp,fmag<br />LOCAL pSpringStructure<br />LOCAL pBody0, pConfiguration0<br />LOCAL pBody1, pConfiguration1<br />LOCAL U0:Vec3,	U1:Vec3<br />LOCAL VU0:Vec3, VU1:Vec3<br />LOCAL Position0:Vec3,Position1:Vec3<br />LOCAL RelativeVelocity:Vec3<br />LOCAL SpringVector:Vec3, Spring:Vec3<br />	SetObject esi<br />	<br />	;Calculate internal forces due to momentum<br />&nbsp; &nbsp; xor ecx,ecx<br />&nbsp; &nbsp; .while ecx&lt;.Bodies.dCount<br />		push ecx&nbsp; &nbsp; <br /> <br />		mov edx,.Bodies.pItems<br />		mov edi,dword ptr			;edi = current body<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  	<br /> 		;If this Body encountered COLLISIONS in the PREVIOUS iteration,<br />		;the Sum of the Resolved Impulses is still waiting to be Applied...<br />		;They were stored in the Target configuration, but we&#039;ve swapped configs since then,<br />		;so we can now find them in the Source configuration :)<br />		.if .CollisionHull.dNumSimultaneousCollisions!=0<br />			DbgWarning &quot;Applying Accumulated Collision Response&quot;<br />			OCall edi::CollisionHull.Apply_Accumulated_Response, .SourceConfigurationIndex<br />		.endif			<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />		;get ptr to current body&#039;s source config<br />		mov eax,sizeof configuration<br />		xor edx,edx<br />		mul .SourceConfigurationIndex<br />		lea edx,.CollisionHull.aConfigurations<br />		add eax,edx								;eax = pconfiguration<br />			<br />		;Set Force and Torque to zero<br />		xor edx,edx<br />		mov .configuration.Torque.x,edx<br />		mov .configuration.Torque.y,edx<br />		mov .configuration.Torque.z,edx<br />		mov .configuration.CMForce.x,edx<br />		mov .configuration.CMForce.y,edx<br />		mov .configuration.CMForce.z,edx<br /><br />		;If Gravity is enabled, apply it to Force.Y<br />		.if .GravityActive==TRUE&nbsp; &nbsp;  <br />			fld Gravity<br />			fmul .CollisionHull.Mass<br />			fstp .configuration.CMForce.y<br />		.endif<br /><br />		;Calculate Force due to Velocity, and Torque due to AngularVelocity<br />&nbsp; &nbsp; &nbsp; &nbsp; .if .DampingActive==TRUE<br />			;Configuration.CMForce += -Kdl * Configuration.CMVelocity<br />			;Configuration.Torque += -Kda * Configuration.AngularVelocity&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />			__ScaleFloat3 .configuration.CMVelocity,mKdl <br />			__AddToFloat3 .configuration.CMForce,&nbsp; .configuration.CMForce<br />			__ScaleFloat3 .configuration.AngularVelocity, mKda<br />			__AddToFloat3 .configuration.Torque,.configuration.Torque<br />		.else&nbsp; &nbsp; &nbsp; &nbsp; <br />			__ScaleFloat3 .configuration.CMVelocity,mNoKdl <br />			__AddToFloat3 .configuration.CMForce,&nbsp; .configuration.CMForce&nbsp;  <br />			__ScaleFloat3 .configuration.AngularVelocity, mNoKda<br />			__AddToFloat3 .configuration.Torque,.configuration.Torque<br />		.endif&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; ;&nbsp; &nbsp; lea edx,.configuration.CMVelocity&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; ;&nbsp; &nbsp; DbgVec3 edx,&quot;Velocity&quot;<br />&nbsp; &nbsp; ;&nbsp; &nbsp; lea edx,.configuration.CMForce&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; ;&nbsp; &nbsp; DbgVec3 edx,&quot;Force&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />		pop ecx<br />		inc ecx<br />	.endw<br />&nbsp; &nbsp; <br />	;Calculate forces due to Body-World Springs<br />	.if .WorldSpringsActive==TRUE&nbsp; &amp;&amp; .WorldSprings.dCount!=0&nbsp; <br />		xor ecx,ecx<br />		.while ecx &lt; .WorldSprings.dCount<br />			push ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; 	<br />&nbsp; &nbsp; &nbsp; &nbsp; 	;Get ptr to affected Body from the Spring struct<br />			mov eax,.WorldSprings.pItems<br />			mov eax,<br />			mov pSpringStructure,eax&nbsp; &nbsp; &nbsp; &nbsp; 	<br />			mov edx, .BodyWorldSpring.pBody<br />			mov pBody0,edx			<br />			;Get ptr to affected Body&#039;s source config<br />			mov eax,sizeof configuration<br />			mul .SourceConfigurationIndex<br />			mov edx,pBody0<br />			lea edx,.CollisionHull.aConfigurations<br />			add eax,edx<br />			mov pConfiguration0, eax<br /><br />			;Transform the AnchorPoint (on the Body) from BodySpace to WorldSpace<br />			mov ebx,pSpringStructure<br />			lea edx, .BodyWorldSpring.vAnchorBody<br />			lea ebx, .configuration.CMPosition<br />			lea eax, .configuration.Orientation<br />			Vec3_transform .Vec3, .Mat33, .Vec3<br />			__StowFloat3 Position0<br /><br />			;Calculate the change in rest length (compressed or stretched spring),<br />			;and also the Magnitude of that change<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Mag2 Position0, .BodyWorldSpring.vAnchorWorld	<br />			fst fmag	; = current spring length squared			<br /><br />			mov edx,pSpringStructure<br />			fld .BodyWorldSpring.fRestLength<br />			fmul .BodyWorldSpring.fRestLength	;*** avoid fsqrt penalty<br />			fsub<br />			fstp ftemp	; = deviation in spring length <br />		<br />			.if ftemp==0 || ftemp==80000000h<br />				;The spring is at rest length, no need for spring forces				<br />			.else<br />				;Calculate WorldSpace Position of AnchorPoint (on the Body), relative to Body&#039;s COM<br />				mov eax,pConfiguration0<br />				__SubFloat3 Position0, .configuration.CMPosition<br />				__StowFloat3 U0<br />				;Calculate WorldSpace Velocity at AnchorPoint (on the Body)<br />				CrossProduct .configuration.AngularVelocity, U0<br />				__AddToFloat3 VU0, .configuration.CMVelocity<br />			&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />				mov edx,pSpringStructure<br />				__SubFloat3 Position0, .BodyWorldSpring.vAnchorWorld&nbsp;  <br />				fld mKws<br />				fmul ftemp<br />				fmul st(3),st(0)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />				fmul st(2),st(0)<br />				fmul<br />				__StowFloat3 Spring<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />				; Project Velocity onto Spring to get damping vector... basically a Gram-Schmidt projection<br />				; DampingForce = -Kwd*(DotProduct(VU,Spring)/DotProduct(Spring,Spring)) * Spring<br />				; Spring += DampingForce<br />				; Then&nbsp; we can apply our Spring Force as follows:<br />				; CMForce = CMForce + Spring<br />				; Torque&nbsp; = Torque + CrossProduct(U,Spring)<br />				DotProduct VU0, Spring<br />				DotProduct Spring,Spring<br />				fabs<br />				fdiv<br />				fmul fmag<br />				fmul mKwd<br />				fstp ftemp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />				__ScaleFloat3 Spring, ftemp<br />				__AddToFloat3 Spring,Spring<br />				__ScaleFloat3 Spring, fmag<br />				mov eax,pConfiguration0<br />				__AddToFloat3 .configuration.CMForce,&nbsp; .configuration.CMForce<br />				CrossProduct U0, Spring<br />				__AddToFloat3 .configuration.Torque, .configuration.Torque<br /><br />			.endif<br />			pop ecx<br />			inc ecx<br />		.endw<br />	.endif&nbsp; <br /><br />	;Calculate forces due to Body-Body Springs<br />&nbsp; &nbsp; .if .BodySpringsActive==TRUE &amp;&amp; .BodySprings.dCount!=0<br />		xor ecx,ecx<br />		.while ecx &lt; .BodySprings.dCount<br />			push ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; 	<br />			mov eax,.BodySprings.pItems<br />			mov eax,<br />			mov pSpringStructure,eax <br /><br />			; We need to transform the anchorpoints in the Spring<br />			; from their respective bodyspaces into worldspace&nbsp; &nbsp; &nbsp; &nbsp; 	&nbsp; &nbsp;  	<br />			mov edx, .BodyBodySpring.pBody0<br />			mov pBody0,edx<br />			mov eax,sizeof configuration<br />			mul .SourceConfigurationIndex<br />			mov edx,pBody0<br />			lea edx,.CollisionHull.aConfigurations<br />			add eax,edx<br />			mov pConfiguration0, eax<br />			mov ebx,pSpringStructure<br />			OCall pBody0::CollisionHull.Transform_Vec3_BodyToWorld,addr .BodyBodySpring.vBody0Anchor,eax<br />			__StowFloat3 Position0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />			mov eax,pSpringStructure<br />			mov edx, .BodyBodySpring.pBody1<br />			mov pBody1,edx<br />			mov eax,sizeof configuration<br />			mul .SourceConfigurationIndex<br />			mov edx,pBody1<br />			lea edx,.CollisionHull.aConfigurations<br />			add eax,edx<br />			mov pConfiguration1, eax&nbsp; &nbsp;  <br />			mov ebx,pSpringStructure<br />			mov edx,pConfiguration1<br />			OCall pBody1::CollisionHull.Transform_Vec3_BodyToWorld,addr .BodyBodySpring.vBody1Anchor, eax<br />			__StowFloat3 Position1<br /><br />			;Calculate the change in rest length (compressed or stretched spring),<br />			;and also the Magnitude of that change<br />			mov edx,pSpringStructure<br />			Vec3_Length&nbsp; Position0, Position1<br />			fst fmag	; = current spring length			<br />			mov edx,pSpringStructure<br />			fsub .BodyBodySpring.fRestLength<br />			fstp ftemp	; = deviation in spring length 			<br /><br />			.if ftemp==0 || ftemp==80000000h<br />				;The spring is at rest length, no need for spring forces				<br />			.else<br />				mov eax,pConfiguration0<br />				__SubFloat3 Position0, .configuration.CMPosition<br />				__StowFloat3 U0<br />				CrossProduct .configuration.AngularVelocity, U0<br />				__AddToFloat3 VU0, .configuration.CMVelocity<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />				mov eax,pConfiguration1<br />				__SubFloat3 Position1, .configuration.CMPosition<br />				__StowFloat3 U1<br />				CrossProduct .configuration.AngularVelocity, U1<br />				__AddToFloat3 VU1, .configuration.CMVelocity<br /><br />				__SubFloat3&nbsp; VU0, VU1<br />				__StowFloat3 RelativeVelocity <br />				__SubFloat3&nbsp; Position0, Position1<br />				__StowFloat3 SpringVector<br />				invoke D3DXVec3Normalize, addr SpringVector,addr SpringVector<br /><br />				; Spring = -K * SpringVector * deviation * magnitude<br />				__LoadFloat3 SpringVector&nbsp; &nbsp; <br />				fld mKbs<br />				fmul ftemp<br />				fmul st(3),st(0)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />				fmul st(2),st(0)<br />				fmul<br />				__StowFloat3 Spring<br />&nbsp; &nbsp; &nbsp;  <br />				DotProduct VU0, 	 Spring		;Perform a Gram-Smidt Projection<br />				DotProduct Spring, 	 Spring	<br />				fdiv<br />				fmul mKbd						; * Dampening<br />				fmul fmag						; * Magnitude<br />				fstp ftemp<br />				__ScaleFloat3 Spring, ftemp<br />				__AddToFloat3 Spring, Spring&nbsp; <br /><br />				mov eax,pConfiguration0<br />				__LoadFloat3 Spring<br />				__AddToFloat3 .configuration.CMForce, .configuration.CMForce <br />				mov eax,pConfiguration1<br />				__LoadFloat3 Spring<br />				__SubFromFloat3 .configuration.CMForce, .configuration.CMForce<br /><br />				CrossProduct U0, Spring&nbsp; <br />				mov eax,pConfiguration0<br />				__AddToFloat3 .configuration.Torque, .configuration.Torque&nbsp;  <br />				CrossProduct U1, Spring<br />				mov eax,pConfiguration1<br />				__SubFromFloat3 .configuration.Torque, .configuration.Torque<br />				.endif<br />&nbsp; &nbsp; &nbsp; &nbsp; 	<br />			pop ecx<br />			inc ecx<br />		.endw<br />	.endif<br />MethodEnd<br /></code></pre><br /><br />It wouldn&#039;t be fair to throw all those math macros at you without a source of reference.<br />Attached is a file containing a whole plethora of useful and relevant math functions, many of them in macro form.<br /><br />In the next post, we&#039;ll be looking at the simulator&#039;s Integrate method, which takes the force and torque, and applies them for some Time, to calculate the Target configs.<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2578" target="_blank">Some_Handy_Math.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2008-05-27 22:32:51 by Homer</div>
   </div>
   <div class="post" id="post-205389">
    <div class="subject"><a href="#post-205389">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">Here is the simulator&#039;s Integrate method.<br />As you can see, its really just a wrapper function that calls the CollisionHull.Integrate method owned by each simulated Body... the D3D_PhysicsSimulator.Integrate method is responsible for calculating the Target configurations of ALL bodies in the simulation, based on their Source (current) configurations, the current Forces, and the amount of Time.<br /><br /><pre><code><br />;Calculate the Target configurations based on the Source configurations and DeltaTime,<br />;and Transform the Bounding Vertices to their new Orientation and Position in WorldSpace<br />Method D3D_PhysicsSimulator.Integrate,uses esi edi, DeltaTime:real8<br />LOCAL psrc,ptgt<br />	SetObject esi	<br />&nbsp; &nbsp; xor ecx,ecx<br />&nbsp; &nbsp; .while ecx&lt;.Bodies.dCount<br />&nbsp; &nbsp; 	push ecx<br />&nbsp; &nbsp; 	<br />&nbsp; &nbsp; 	mov eax,.Bodies.pItems<br />&nbsp; &nbsp; 	mov edi, dword ptr 					;ptr to nth Body<br />&nbsp; &nbsp; 	mov psrc,$OCall (GetPtrToConfig,edi,.SourceConfigurationIndex)<br />&nbsp; &nbsp; 	mov ptgt,$OCall (GetPtrToConfig,edi,.TargetConfigurationIndex)<br />&nbsp; &nbsp; 	<br />&nbsp; &nbsp; 	;Integrate the Physics state (from Source to Target configuration)<br />&nbsp; &nbsp; 	OCall edi::CollisionHull.Integrate,psrc,ptgt,DeltaTime<br />&nbsp; &nbsp; 	<br />&nbsp; &nbsp; 	mov edx,ptgt<br />&nbsp; &nbsp; 	lea edx,.configuration.CMPosition<br />&nbsp; &nbsp; 	DbgVec3 edx,&quot;Integrated Position (Target config)&quot;<br /><br />&nbsp; &nbsp; 	pop ecx<br />&nbsp; &nbsp; 	inc ecx<br />&nbsp; &nbsp; .endw<br />MethodEnd<br /></code></pre><br /><br />and since that was just a tease, I&#039;ll give you the real deal too.<br />The CollisionHull.Integrate method is responsible for calculating the Target configuration of one Body, based on its source config, its current forces, and Time.<br /><br /><pre><code><br />;Updates the Target configuration based on the Source configuration and DeltaTime<br />Method CollisionHull.Integrate,uses esi ebx, pSource, pTarget, DeltaTime:real8<br />LOCAL matTemp:Mat33<br />LOCAL matTemp2:Mat33<br />LOCAL ftemp<br /><br /><br />	SetObject esi<br />	;Only bodies which are Awake need to be Integrated<br />	.if .bIsAwake==TRUE<br />	<br />		;Check if this Awake body should be put to sleep		<br />		OCall esi.Try_To_Sleep, pSource, pTarget<br />		.if eax==TRUE<br />			ExitMethod<br />		.endif	<br />		<br />		DbgFloat DeltaTime<br /><br />	&nbsp; &nbsp; ; New Position is integrated from Old Linear Velocity, applied for some Time:<br />	&nbsp; &nbsp; ; Target.CMPosition = Source.CMPosition + DeltaTime * Source.CMVelocity<br />	&nbsp; &nbsp; mov edx,pSource<br />	&nbsp; &nbsp; mov eax,pTarget<br />	&nbsp; &nbsp; __ScaleFloat3 .configuration.CMVelocity, DeltaTime<br />		__AddToFloat3 .configuration.CMPosition, .configuration.CMPosition<br /><br />	&nbsp; &nbsp; ; New Velocity is integrated from Linear Force, applied for some Time:<br />	&nbsp; &nbsp; ;Target.CMVelocity = Source.CMVelocity + (Body.OneOverMass * Source.CMForce * DeltaTime)<br />	&nbsp; &nbsp; mov edx,pSource<br />		__LoadFloat3 .configuration.CMForce<br />		fld .OneOverMass<br />		fmul DeltaTime	 <br />		fmul st(3),st(0)<br />		fmul st(2),st(0)<br />		fmul<br />		__StowFloat3&nbsp; .configuration.CMVelocityChange<br />		__AddFloat3	&nbsp; .configuration.CMVelocity, .configuration.CMVelocityChange<br />		__AddToFloat3 .configuration.CMVelocity, .configuration.CMVelocity	<br /><br /><br />	&nbsp; &nbsp; ;Thats it for Linear stuff, time to do the Angular stuff...	&nbsp; &nbsp; <br />	&nbsp; &nbsp; ;First we&#039;ll calculate Angular Momentum because its kinda easy..<br />		; Angular Momentum is integrated from Torque Force, applied for some Time:<br /><br />	&nbsp; &nbsp; ;Target.AngularMomentum = Source.AngularMomentum + (DeltaTime * Source.Torque)	&nbsp; &nbsp; <br />	&nbsp; &nbsp; mov eax,pSource<br />	&nbsp; &nbsp; mov edx,pTarget<br />		__ScaleFloat3 .configuration.Torque, DeltaTime<br />		__AddToFloat3 .configuration.AngularMomentum, .configuration.AngularMomentum	&nbsp; &nbsp; <br />	&nbsp; &nbsp; <br />	&nbsp; &nbsp; ;If theres no Source angular velocity, then Orientation cannot change<br />	&nbsp; &nbsp; ;and we can avoid a whole lot of calculations<br />;	&nbsp; &nbsp; mov edx,pSource<br />;	&nbsp; &nbsp; fld .configuration.AngularVelocity.x<br />;	&nbsp; &nbsp; fabs<br />;	&nbsp; &nbsp; fld .configuration.AngularVelocity.y<br />;	&nbsp; &nbsp; fabs<br />;	&nbsp; &nbsp; fld .configuration.AngularVelocity.z<br />;	&nbsp; &nbsp; fabs<br />;	&nbsp; &nbsp; fadd<br />;	&nbsp; &nbsp; fadd<br />;	&nbsp; &nbsp; fstpReg eax<br />;		.if eax==0<br />;			;No source velocity, no need to change the orientation, or the World InvInertiaTensor<br />;			mov eax,pSource<br />;			mov edx,pTarget<br />;			invoke RtlMoveMemory,addr .configuration.Orientation,addr .configuration.Orientation,sizeof Mat33<br />;	&nbsp; &nbsp; 	<br />;	&nbsp; &nbsp; 	mov eax,pSource<br />;	&nbsp; &nbsp; 	mov edx,pTarget<br />;	&nbsp; &nbsp; 	invoke RtlMoveMemory,addr .configuration.InverseWorldInertiaTensor,addr .configuration.InverseWorldInertiaTensor,sizeof Mat33<br />;	&nbsp; &nbsp; 	<br />;	&nbsp; &nbsp; .else<br />	&nbsp; &nbsp;  <br />		&nbsp; &nbsp; ;In order to find the new Orientation, we will need to apply angular velocity for some Time..<br />		&nbsp; &nbsp; ;We&#039;ll be using a &#039;skew&#039;symmetric matrix&#039;, which is built from our angular velocity vector...<br />		&nbsp; &nbsp; ;That matrix will be multiplied by the Body&#039;s Orientation, and scaled by DeltaTime.<br />		&nbsp; &nbsp; ;This gives us an &#039;offset rotation matrix&#039; and so finally, <br />		&nbsp; &nbsp; ;the original Orientation matrix will be Added:<br />		&nbsp; &nbsp; ; OffsetOrientation = (DeltaTime * SkewSymmetric(Source.AngularVelocity) * Source.Orientation)<br />		&nbsp; &nbsp; ; Target.Orientation = Source.Orientation + OffsetOrientation<br />		&nbsp; &nbsp; ;We can create a SkewSymmetric Mat33 from a Vec3 using the STAR or TILDE Matrix Operator.<br />		&nbsp; &nbsp; ;I&#039;ve provided a Mat33_star macro for this purpose.		&nbsp; &nbsp; <br />		&nbsp; &nbsp; <br />		&nbsp; &nbsp; ;Prepare the SkewSymmetric matrix, and Scale it by Time<br />			mov edx,pSource<br />			Mat33_star matTemp, .configuration.AngularVelocity<br />			lea eax,matTemp<br />			Mat33_mult_Scalar eax, DeltaTime<br />		&nbsp; &nbsp; <br />			;Apply the scaled SS matrix to the Orientation to find Offset Rotation<br />			mov edx,pSource<br />			invoke Mat33_multiply,addr matTemp2, addr .configuration.Orientation, addr matTemp<br />		&nbsp; &nbsp; <br />			;Adding the Source and Offset Orientations<br />			mov eax,pSource<br />			lea edx,.configuration.Orientation ;Source.Orientation<br />			mov ebx,pTarget<br />			lea ebx,.configuration.Orientation	;Target.Orientation<br />			lea ecx,matTemp2						;Offset.Orientation<br />			Mat33_Add&nbsp; ebx, ecx, edx&nbsp; &nbsp; <br />		&nbsp; &nbsp; <br />			;Orthogonalizing the result to prevent Skew	<br />			mov edx,pTarget<br />			invoke OrthonormalizeOrientation,addr .configuration.Orientation<br />		&nbsp; &nbsp; <br />			;Since the Orientation has changed, we need to update the Worldspace InverseInertiaTensor as well<br /><br />			; Transform the InvInertiaTensor from BSpace into WSpace via a Similarity transform:<br />			; Target.InverseWorldInertiaTensor = Target.Orientation * Body.InverseBodyInertiaTensor * Transpose(Target.Orientation)	<br />			mov edx,pTarget<br />			invoke RtlMoveMemory,addr matTemp,addr .configuration.Orientation,sizeof Mat33<br />			Mat33_transpose matTemp<br />			;<br />			mov edx,pTarget<br />			invoke Mat33_multiply,addr matTemp2, addr .InverseBodyInertiaTensor,&nbsp; addr matTemp <br />			;<br />			mov edx,pTarget<br />			invoke Mat33_multiply,addr .configuration.InverseWorldInertiaTensor,addr matTemp2,addr .configuration.Orientation<br />	;	.endif<br /><br />	&nbsp; &nbsp; <br />		;If theres ANY target angular momentum, we&#039;ll extract the target angular velocity from it<br />		mov edx,pTarget<br />		fld .configuration.AngularMomentum.x<br />		fabs<br />		fld .configuration.AngularMomentum.y<br />		fabs<br />		fld .configuration.AngularMomentum.z<br />		fabs<br />		fadd<br />		fadd<br />		fstpReg eax<br />		.if eax==0 			<br />			;There&#039;s no angular momentum, so we dont need to derive the angular velocity - its zero<br />			mov .configuration.AngularVelocity.x,eax<br />			mov .configuration.AngularVelocity.y,eax<br />			mov .configuration.AngularVelocity.z,eax<br />		.else&nbsp; <br />			; Target.AngularVelocity = Target.InverseWorldInertiaTensor * Target.AngularMomentum			<br />			mov eax,edx<br />			Vec3_mult_Mat33 .configuration.InverseWorldInertiaTensor, .configuration.AngularMomentum<br />			__StowFloat3 	.configuration.AngularVelocity<br />		.endif<br />		<br />	&nbsp;  	;Update the WorldSpace vertices for new orientation and position<br />	&nbsp;  	mov edx,pTarget<br />	&nbsp;  	OCall TransformVertices, addr .configuration.CMPosition, addr .configuration.Orientation<br />	.endif<br /> <br />MethodEnd<br /><br /></code></pre><br /><br />Thats a lot to take in.<br />I&#039;m going camping and hiking in the mountains for a couple of days, that should give you time to read over these posts and perhaps develop some questions.<br /><br /></div>
    <div class="meta">Posted on 2008-05-28 19:56:05 by Homer</div>
   </div>
   <div class="post" id="post-205418">
    <div class="subject"><a href="#post-205418">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">Near the start of the CollisionHull.Integrate method is a call to &#039;TryToSleep&#039;.<br />The comments should explain clearly enough whats happening here.<br />You&#039;ll see a reference to &#039;TransformVertices&#039; - if we put a body to sleep, we have to manually perform this call - otherwise the Integrate method will do it&nbsp; (scroll down for more info).<br /><br /><pre><code><br />;This method will put a body to sleep if it isn&#039;t moving.<br />;Sleeping bodies don&#039;t need to be Integrated, <br />;and they cannot be the CAUSE of any collisions.<br />Method CollisionHull.Try_To_Sleep,uses esi,pSource, pTarget<br />	SetObject esi<br />&nbsp; &nbsp; mov edx,pSource&nbsp;  <br />&nbsp; &nbsp; ; integrate primary quantities... First, we&#039;ll do the Linear stuff...<br />	Vec3Dot .configuration.CMForce, .configuration.CMForce<br />	fsub fEpsilon<br />	fstpReg eax<br />	.ifBitSet eax,BIT31<br />		;We have very low Linear velocity - what about Angular Momentum?<br />		Vec3Dot .configuration.AngularMomentum, .configuration.AngularMomentum<br />		fsub fEpsilon<br />		fstpReg eax<br />		.ifBitSet eax,BIT31		<br />			;This body is very low in energy, so it can &#039;sleep&#039; from now on				<br />			mov .bIsAwake,FALSE<br />			DbgWarning &quot;Body has low energy - Putting body to sleep&quot;<br />			;Clone the source config into target config<br />			invoke RtlMoveMemory,pTarget,pSource,sizeof configuration<br />			mov edx,pSource<br />			;Ensure that our worldspace vertex array is up to date<br />			OCall esi.TransformVertices,addr .configuration.CMPosition, addr .configuration.Orientation<br />			mov eax,TRUE<br />		.endif<br />	.endif	<br />MethodEnd<br /></code></pre><br /><br />Near the end of the CollisionHull.Integrate method is a call to &#039;TransformVertices&#039;, which transforms our set of (unrotated) bodyspace boundary points (vertices) into worldspace, according to the TARGET configuration.<br />It&#039;s this set of TRANSFORMED points, representing our Oriented and Positioned body, which we will use for Collision Testing - we must think of the Target configuration of a body as describing a &#039;proposed future state&#039; which may or may not be acceptable due to collisions.<br /><br /><pre><code><br />;Transform all the hull&#039;s bounding vertices from BodySpace to WorldSpace<br />Method CollisionHull.TransformVertices,uses ebx esi,pvPosition, pmatOrientation<br /><br />	SetObject esi<br />&nbsp; &nbsp; ;Transform each point from bodyspace into worldspace<br />&nbsp; &nbsp; xor ecx,ecx<br />&nbsp; &nbsp; .while ecx&lt;.NumberOfBoundingVertices<br />		push ecx<br />		<br />		mov eax,sizeof Vec3<br />		mul ecx<br />		push eax<br />		lea edx,.aBodyBoundingVertices<br />		add eax,edx										;edi=ptr to source point in bodyspace<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ;worldpoint = transform (bodypoint,rotation,translation)<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ebx,pmatOrientation<br />&nbsp; &nbsp; &nbsp; &nbsp; mov edx,pvPosition<br />&nbsp; &nbsp; &nbsp; &nbsp; Vec3_transform .Vec3, .Mat33, .Vec3<br />&nbsp; &nbsp; &nbsp; &nbsp; lea eax,.aWorldBoundingVertices	 	;target vertices (WorldSpace)<br />&nbsp; &nbsp; &nbsp; &nbsp; pop edx<br />&nbsp; &nbsp; &nbsp; &nbsp; add eax,edx&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; __StowFloat3 .Vec3<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; 	pop ecx<br />&nbsp; &nbsp; 	inc ecx<br />&nbsp; &nbsp; .endw&nbsp; &nbsp;  	<br />MethodEnd<br /></code></pre><br /><br />Next we&#039;ll cover my existing collision detection code in some detail - but I won&#039;t be explaining the algorithms, as I have done that here : http://www.asmcommunity.net/board/index.php?topic=29056.0</div>
    <div class="meta">Posted on 2008-05-31 23:34:25 by Homer</div>
   </div>
   <div class="post" id="post-205427">
    <div class="subject"><a href="#post-205427">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body"><br />Before we delve into the wonderful world of collision handling, lets review one of the very first methods that we looked at:<br /><br /><pre><code><br />;This method will attempt to advance the simulation by DeltaTime.<br />;However, if a Collision is detected DURING this timeframe,<br />;the simulation will be advanced to THAT time, and the collision resolved.<br />;Returns FPU value = amount of time &#039;consumed&#039; (DeltaTime or less)<br /><br />Method D3D_PhysicsSimulator.Simulate,uses esi, DeltaTime:real8<br />	SetObject esi<br /><br />	;Apply any &#039;contact resolution&#039; from the previous iteration, and then<br />	;calculate Force and Torque (due to current linear/angular momentum, and gravity)<br />	OCall esi.ComputeForces<br /><br />	;Integrate our system forward by &#039;remaining time&#039; (from Source to Target configuration)	<br />	OCall esi.Integrate, DeltaTime<br />&nbsp;  <br />	;Perform sweep-testing of unique pairs of bodies, and also checking for body/Wall collisions<br />	OCall CheckCollisions, DeltaTime<br /><br />	;Swap the configurations: source becomes target, target becomes source<br />	push .SourceConfigurationIndex<br />	m2m&nbsp; .SourceConfigurationIndex, .TargetConfigurationIndex<br />	pop&nbsp; .TargetConfigurationIndex<br />	&nbsp; &nbsp; <br />	DbgWarning &quot;Simulated One TimeStep&quot;<br />MethodEnd<br /></code></pre><br /><br />We&#039;ve covered what happens inside the Integrate method.... it calculated the set of Target configurations at DeltaTime - it figured out where our Bodies will be at &quot;now+deltatime&quot;.<br />Then we see a call to the CheckCollisions method.... that&#039;s our next stop.<br />This method will return a float on the fpu stack - if theres no collisions, the value will be DeltaTime... but if theres a collision, the value will be &quot;time until collision&quot; - somewhat less than DeltaTime, and greater or equal to zero.<br />The returned value is telling us how far we ended up advancing the system, ie, it tells us how much of the timestep was actually consumed.. when we return to the Update method, that much time will be subtracted from the &#039;Time Accumulator&quot;.<br />This means that any &quot;unused time&quot; (due to collision) is accumulated and spent in the next iteration (of the Update method&#039;s timestepping loop).<br /><br />I will now show you the CheckCollisions method - but I warn you, this method is quite likely to change without notice as I am still far from happy with it.... and, its a big one.<br /><pre><code><br />; This method advances the System to fCurrentDeltaTime or the earliest collision, whichever is first.<br />; Returns the &quot;used&quot; amount of FrameTime on the fpu (fCurrentDeltaTime or less)<br />Method D3D_PhysicsSimulator.CheckCollisions,uses esi edi, fCurrentDeltaTime:real8<br />LOCAL CollisionState<br />LOCAL pBody,pConfiguration<br />LOCAL pWall<br />LOCAL pOtherBody<br />local pt:Vec3<br />LOCAL ftemp:real8<br />LOCAL results[8]:dword<br />LOCAL fLastClearTime:real8<br />LOCAL fFirstCollisionTime:real8<br />LOCAL fbig:real8<br />LOCAL ptgtA<br />LOCAL vtemp:Vec3<br />LOCAL templist<br />LOCAL iAggressor, cnt<br /><br /><br /><br />	SetObject esi<br />	mov templist, $New(DwordCollection,Init,0,16,256,-1)<br /><br />	mov CollisionState,Clear	;Be optimistic<br />	fldz<br />	fstp fLastClearTime<br />	fld1<br />	fstp fFirstCollisionTime<br /><br /><br />;---------------------------------------------------------------------------------------------------------<br />;			Part One -	Find the EARLIEST COLLISION TIME, and Collect all Bodies which Collide at that Time<br />;						We&#039;ll use a two-stage filter that handles body/body and body/plane collisions<br /><br />	mov dword ptr fFirstCollisionTime[0],-1<br /><br />	mov pOtherBody,0<br /><br />	;For each Body in the Simulation:<br />	xor ecx,ecx<br />	mov iAggressor,ecx<br />	.while ecx&lt;.Bodies.dCount &amp;&amp; CollisionState!=Penetrating<br />		<br />		mov eax,.Bodies.pItems<br />		mov eax,dword ptr<br />&nbsp; &nbsp; &nbsp; &nbsp; mov pBody,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov edi,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,sizeof configuration<br />&nbsp; &nbsp; &nbsp; &nbsp; mul .TargetConfigurationIndex<br />&nbsp; &nbsp; &nbsp; &nbsp; mov edx,pBody<br />&nbsp; &nbsp; &nbsp; &nbsp; lea edx,.CollisionHull.aConfigurations<br />&nbsp; &nbsp; &nbsp; &nbsp; add eax,edx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov pConfiguration,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ;------------------------------------------------------------------------<br />&nbsp; &nbsp; &nbsp; &nbsp; ;Test the current Body against the World Bounding Planes<br />		OCall Sweep_Body_Against_World_Planes,pBody <br />		mov pWall,edx<br />		.if eax==Colliding<br />			fstp ftemp<br />		.endif<br />		.if eax==Penetrating			<br />			;The Body&#039;s Sphere is penetrating a World Plane at the start of the timestep<br />			;We&#039;ll need to perform an instantaneous check of the Body geometry NOW<br />			;This is going to get messy since we can only test the TARGET config,<br />			;and so we&#039;ll need to integrate this body BACK to where it started from..<br />			OCall esi.GetPtrToConfig,pBody,.SourceConfigurationIndex<br />			push eax<br />			OCall esi.GetPtrToConfig,pBody,.TargetConfigurationIndex<br />			pop ebx<br />			OCall pBody::CollisionHull.Integrate, ebx,eax,r8_0<br />			;OK, now we can do our instantaneousintersection test<br />			;REPLACE THIS CODE , IT MAY NOT BE A BOX<br />			OCall pBody::Box.Box_versus_Plane,addr results,pWall<br />			fUnload<br />			.if eax==Penetrating<br />				;Its a HUGE problem - the Body is intersecting the plane at the START of timestep<br />				DbgWarning &quot;Error - Body intersects World Plane at start of timestep&quot;<br />				int 3<br />				;fld fCurrentDeltaTime<br />				;fmul r4_Half<br />				;fstp fCurrentDeltaTime<br />				;OCall templist::DwordCollection.DisposeAll<br />				;pop ecx<br />				;jmp @rep<br />			.elseif eax==Colliding<br />				DbgWarning &quot;Body and Plane are Colliding NOW&quot;<br />				fldz<br />				fld fCurrentDeltaTime<br />				BitToggle pWall,BIT31	;mark 2nd body as being a plane<br />				jmp @F <br />			.else<br />				;A collision is imminent - use a smaller search window<br />				DbgWarning &quot;We&#039;re CLEAR again, but not for long...&quot;<br />				fld fCurrentDeltaTime<br />				fmul r4_Quarter<br />				fmul r4_Half<br />				fstp ftemp<br />				BitToggle pWall,BIT31	;mark 2nd body as being a plane<br />				OCall FindExactCollisionTime,pBody,pWall,r8_0,ftemp,addr results<br />				jmp @f<br />			.endif<br /><br />		.elseif eax==Colliding<br />			;This Body is quite close to the Plane.	<br />			;Let&#039;s perform a Binary Search for the &#039;EXACT&#039; Body/Plane collision time<br />			DbgWarning &quot;Finding exact collision for PRE-COLLIDING sphere/plane&quot;<br />			BitToggle pWall,BIT31	;mark 2nd body as being a plane<br />			OCall FindExactCollisionTime,pBody,pWall,fLastClearTime,fCurrentDeltaTime,addr results<br />@@:			fstp fbig<br />			fstp ftemp<br />			.if eax==Colliding		;result = Colliding/Clear<br />				;is it the earliest time?<br />				fld fbig<br />				fsub fFirstCollisionTime<br />				fstpReg eax<br />				.if eax==0 || eax==80000000h<br />					;its equal to the earliest time, so collect it<br />					OCall templist::DwordCollection.Insert, pBody<br />					OCall templist::DwordCollection.Insert, pWall<br />				.else<br />					.ifBitSet eax,BIT31<br />						;its the earliest time so far - toss out our old list<br />						OCall templist::DwordCollection.DisposeAll<br />						fld&nbsp; ftemp<br />						fstp fFirstCollisionTime<br />						;Collect it<br />						OCall templist::DwordCollection.Insert, pBody<br />						OCall templist::DwordCollection.Insert, pWall<br />					.endif<br />				.endif<br />			.endif<br />		.endif<br />		<br />		;------------------------------------------------------------------------<br />		;Test (every Body further in the list) against the current Body	<br />		mov ecx,iAggressor<br />		inc ecx<br />		.while ecx&lt;.Bodies.dCount<br />			push ecx<br />			<br />			mov eax,.Bodies.pItems<br />			mov eax,dword ptr<br />			mov pOtherBody,eax<br />			;Coarse testing<br />			OCall edi::Sphere.Sphere_Sweep_Sphere, pOtherBody, .SourceConfigurationIndex,.TargetConfigurationIndex<br />			.if eax==Penetrating<br />				fld1<br />				fldz<br />				jmp @Collision&nbsp; 	<br />			.elseif eax==Colliding<br />@Collision:		fmul fCurrentDeltaTime<br />				fstp fbig	;first penetrating time<br />				fmul fCurrentDeltaTime<br />				fstp ftemp	;last clear time				<br />				;Fine testing <br />				OCall FindExactCollisionTime, pBody, pOtherBody, ftemp, fbig, addr results<br />				fstp fbig<br />				fstp ftemp				<br />				.if eax==Colliding		;result = Colliding/Clear<br />					;is it the earliest time?<br />					fld ftemp<br />					fsub fFirstCollisionTime					<br />					fstpReg eax<br />					.if eax==0 || eax==80000000h<br />						;its equal to the earliest time, so collect it<br />						OCall templist::DwordCollection.Insert, pBody<br />						OCall templist::DwordCollection.Insert, pOtherBody<br />					.else<br />						.ifBitSet eax,BIT31<br />							;its the earliest time so far - toss out our old list<br />							OCall templist::DwordCollection.DisposeAll<br />							fld&nbsp; ftemp<br />							fstp fFirstCollisionTime<br />							fld fbig<br />							fstp fLastClearTime<br />							;Collect it<br />							OCall templist::DwordCollection.Insert, pBody<br />							OCall templist::DwordCollection.Insert, pOtherBody<br />						.endif<br />					.endif<br />				.endif<br />			.endif<br />			<br />			pop ecx<br />			inc ecx<br />		.endw				;each body at a greater index than Aggressor (ie each unique body pair)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; inc iAggressor<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,iAggressor<br />&nbsp; &nbsp; .endw					;each Aggressor Body in the Simulation<br /><br /><br />;----------------------------------------------------------------------------------------------------------------------<br />&nbsp; &nbsp; ;At this point, we have identified the EXACT time that the first collision will occur during this frame,<br />&nbsp; &nbsp; ;AND, we have made a list of all the Pairs of bodies which collide simultaneously.<br />;----------------------------------------------------------------------------------------------------------------------<br /><br />	;Quick check to see if the list of potential collisions is empty<br />	mov edx,templist<br />	.if .DwordCollection.dCount==0<br />		DbgWarning &quot;NO COLLISIONS DETECTED&quot;<br />		Destroy templist<br />		fld fCurrentDeltaTime<br />		mov eax,Clear<br />		ExitMethod<br />	.endif<br /><br />	;Goody, we have &#039;potential&#039; collisions to process<br />	DbgFloat fLastClearTime<br />	DbgFloat fFirstCollisionTime<br />	DbgDec .DwordCollection.dCount<br />		&nbsp; &nbsp; 	<br />	;wind the entire simulation to the exact impact time<br />	DbgWarning &quot;Winding entire simulation to IMPACT time&quot;				&nbsp; &nbsp; 	<br />	OCall Integrate, fFirstCollisionTime		&nbsp; &nbsp; 	<br />;			&nbsp; &nbsp; 	<br /><br /><br />	<br />	;------------------------------------------------------------------------<br />	;		Part Two - Process the set of simultaneous collisions<br /><br />&nbsp;  		<br />	;Loop for all Pairs of potential colliders<br />	xor ecx,ecx<br />	mov edx,templist<br />	mov eax,.DwordCollection.dCount<br />	shr eax,1			;divide by two for #Pairs<br />	mov cnt,eax<br />	.while ecx&lt;cnt<br />		push ecx<br />		<br />		mov pBody, 		$OCall (templist::DwordCollection.DeleteAt,0)<br />		mov pOtherBody, $OCall (templist::DwordCollection.DeleteAt,0)<br /><br />		;We&#039;re finally ready to resolve the current Collision, but before we do,<br />		;it would be a good idea to determine what KIND of collision it was<br />		;since we support two kinds : body/body, and body/worldplane<br />		.ifBitSet pOtherBody, BIT31<br />			;Since the high bit is set, BodyB is actually a WORLD PLANE, and not a Body at all.<br />			BitToggle pOtherBody, BIT31	;get rid of that flag bit<br />			<br />			;Grab a pointer to Body A&#039;s Target config <br />			OCall esi.GetPtrToConfig,pBody,.TargetConfigurationIndex<br />			mov ptgtA, eax<br />			<br />			OCall pBody::Box.Box_versus_Plane,addr results,pOtherBody<br />			;We now have a LIST of which points of Body collided with the Plane !!!<br />			xor ecx,ecx<br />			mov edx,pBody<br />			.while ecx&lt;.CollisionHull.NumberOfBoundingVertices<br />				push ecx<br />				mov eax, results<br />				DbgDec&nbsp; eax,&quot;POINTCOLLIDER RESULT&quot;<br />				.if results==Colliding<br />					DbgWarning &quot;RESOLVING COLLISION - BODYPOINT AND WALL PLANE&quot;							<br />					mov eax,sizeof Vec3<br />					mul ecx<br />					mov edx,pBody<br />					lea edx,.CollisionHull.aWorldBoundingVertices<br />					add eax,edx<br />					OCall pBody::CollisionHull.Resolve_Collision_PointNormal, eax, pOtherBody,ptgtA<br />					mov edx,pBody<br />				.endif<br />				pop ecx<br />		&nbsp;  	 	inc ecx<br />			.endw	<br />;;<br />		.else<br />			;Its a Body/Body collision... we have a method just for this<br />			OCall ResolveCollision_BodyBody, pBody,pOtherBody<br />		.endif<br /><br />		pop ecx<br />		inc ecx<br />	.endw<br />	Destroy templist<br />	mov eax,TRUE<br />	fld fFirstCollisionTime		;Return the USED amount of time (one partial timestep)<br /><br />MethodEnd<br /></code></pre><br /><br />I am pretty sure you&#039;ll have questions about this method.... and it&#039;s exposed a bunch more methods that we&#039;ll need to look at too.<br />Basically what&#039;s going on here is that we have two loops, one nested within the other.<br />The outer loop checks every Body A in the simulator...<br />First, it checks for collision of the Body A with World Bounding Planes.<br />Then we get to the inner loop, which checks every simulated Body B at a higher index than the current Body A.... and so we compare each unique pair of Bodies against one another.<br />The collision detection begins with Sphere tests, and then drops to fine geometric tests.<br />Is there anybody out there?<br /><br /></div>
    <div class="meta">Posted on 2008-06-02 02:58:08 by Homer</div>
   </div>
   <div class="post" id="post-205428">
    <div class="subject"><a href="#post-205428">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">Yes, I&#039;m here. I&#039;m just reading, accumulating knowledge - but I don&#039;t have enough to chime-in and start a debate on this topic. I&#039;ve been keeping my peripheral vision on dynamics for quite some time, but never found it usable or beneficial for my works - so I haven&#039;t focused on it for more than a day. <br />The ways to do the broad-phase collision and idea for per-object rest/active state are obvious and already mentioned. It&#039;s just tiny clever optimizations that can be done there (which actually may speed it all up by a few orders of magnitude). The narrow-phase - seems like it should be done slowly like all existing dynamics engines do it. <br /><br />Just one idea - about &quot;waking&quot; objects from sleep: Let&#039;s say we have a tower, made of bricks, that is currently in rest. When we hit a brick in the middle, we activate it. On activation, an object should wake-up all inactive objects, whose sphere intersects the current object&#039;s sphere, and are placed _above_ the current object. The bad alternative would be to keep a list of depending inactive objects. Also, depending on an object&#039;s mass, only forces above a given magnitude should activate this object. </div>
    <div class="meta">Posted on 2008-06-02 05:02:18 by Ultrano</div>
   </div>
   <div class="post" id="post-205429">
    <div class="subject"><a href="#post-205429">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">Ultrano - I&#039;m yet to properly implement resting contact - I intend to do that after I add friction - but I&#039;ve put a little thought toward the stacking problem too.<br />It occurs to me that when the middle brick is struck (and thus woken), it will immediately cause and detect collisions with the bricks above and below it, waking them both.<br />If there is insufficient force to move the lower brick due to low friction, that body will immediately go back to sleep - but the one above it - and those in turn above that one - will remain awake as they will begin to fall under gravity.</div>
    <div class="meta">Posted on 2008-06-02 09:25:45 by Homer</div>
   </div>
   <div class="post" id="post-205452">
    <div class="subject"><a href="#post-205452">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">funny I have made an animation, just ran some bricks in a physics simulationmode in Carrara, few months ago<br /><br />now when you where talking about thresholds and make use of OOP, why couldnt we have all kinds of thresholds in the class BRICK ?like thresholds for if they gonna start to tilt and fall down because of underlying brick has moved so its not supporting it enough, could have a threshold on how much difference between positions between two bricks before we need to start a calculation of possible, how much area that supports upholding is just a simple fmul the rectangle you can get out of the differences, the absolute difference in x,z you use to subtract xsize,zsize to get the support area+ checks threshold for not too much over 49% difference of position in one of the axis<br />couldnt you kinda make something similar to BSPtree for a brickwall, building up a tree on how brick 1 is affecting brick 2 and 3 above itand in turn how brick 2 and 3 is in turn affecting other bricks, so at runtime its just run thru this tree when doing physics, instead of mass checking all bricks?<br /></div>
    <div class="meta">Posted on 2008-06-05 01:08:42 by daydreamer</div>
   </div>
   <div class="post" id="post-205459">
    <div class="subject"><a href="#post-205459">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">Simulation of physics without consideration of Mass is as believable as Donkey Kong.<br />Thresholds are not desirable, we only use them where we absolutely must as maintaining them is an overhead with no other benefit or use.<br />The simulation of equilibrium at the center of mass is an automatic feature of a good simulator.</div>
    <div class="meta">Posted on 2008-06-07 09:16:49 by Homer</div>
   </div>
   <div class="post" id="post-205461">
    <div class="subject"><a href="#post-205461">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">I&#039;ve implemented much of the new collision response code that I&#039;ve been posting... to be precise, I&#039;ve enabled the Frictionless impulse code.<br />With a couple of bugfixes and some screwing around, I now have a WONDERFUL stable simulation, but my stupid Body won&#039;t go to sleep when it settles down on the floor.<br />I&#039;m getting microcollisions that ensure the Body never truly sleeps... at least its not falling through the floor :P<br />Somehow I&#039;ll need to check if Gravity is the key player and put the bugger to sleep if thats the case.<br /></div>
    <div class="meta">Posted on 2008-06-08 05:04:26 by Homer</div>
   </div>
   <div class="post" id="post-205462">
    <div class="subject"><a href="#post-205462">Re: Physics - 3D Simulation of Rigid Bodies</a></div>
    <div class="body">I&#039;m just now uploading a small movie (5 meg avi) showing the latest incarnation of the engine - a box falling with some initial rotation onto a frictionless surface, bouncing about, and settling to a stop.<br /><br />http://stig.servehttp.com/homer/tiger.avi<br /></div>
    <div class="meta">Posted on 2008-06-08 10:09:15 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29070&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29070&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29070" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29070&amp;page=2">&gt;</a><a href="../?id=29070&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>