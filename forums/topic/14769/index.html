<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Cube Root - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=14769" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=14769">Cube Root</a></p>
   <div class="post" id="post-114496">
    <div class="subject"><a href="#post-114496">Cube Root</a></div>
    <div class="body">Hello,<br />I've written a routine to approximate the cube root of a real number and I'm looking for some improvements. The method is not iterative, it only needs to be calculated once. It uses a rational quartic polynomial to approximate the cube root as described in the source code. The paper which I got this from insists it is accurate to 24 bits. The core of it requires only 5 muls and 1 div, but I'm looking to clean it up a bit. Any ideas are greatly appreciated<br /><br />Here is the function:<br /><br /><pre><code><br />CubeRoot proc uses eax ecx edx x&#58;real4<br />LOCAL exp&#58;DWORD<br /><br />    fld x                       ;we have to work with absolute value<br />    fabs<br />    fxtract                     ;get exponent<br />    fxch<br />    fistp exp<br />    <br />    mov eax,exp<br />    cdq<br />    mov ecx,3<br />    idiv ecx                    ;eax=n, edx=exponent for y<br />    cmp edx,0<br />    jl @F<br />    sub edx,3                   ;adjust eax and edx so -3 &lt;= edx &lt;0<br />    inc eax<br />@@&#58;<br />    mov exp,edx<br />    fild exp<br />    fxch<br />    fscale                      ;this produces y, a value in &#91;1/8,1&#41;<br />    fstp st&#40;1&#41;<br />    <br />    fld st&#40;0&#41;                   ;calculate P&#40;y&#41;. 3 muls 5 adds<br />    fmul real8 ptr CC&#91;8*0&#93;<br />    fld real8 ptr CC&#91;8*1&#93;<br />    fadd st&#40;0&#41;,st&#40;1&#41;<br />    fmul st&#40;0&#41;,st&#40;0&#41;<br />    fxch<br />    fadd real8 ptr CC&#91;8*2&#93;<br />    fadd st&#40;0&#41;,st&#40;1&#41;<br />    fxch<br />    fadd real8 ptr CC&#91;8*3&#93;<br />    fmulp st&#40;1&#41;,st&#40;0&#41;<br />    fadd real8 ptr CC&#91;8*4&#93;<br />    <br />    fld st&#40;1&#41;                   ;calculate Q&#40;y&#41;. 2 muls 5 adds<br />    fld real8 ptr CC&#91;8*5&#93;<br />    fadd st&#40;0&#41;,st&#40;1&#41;<br />    fmul st&#40;0&#41;,st&#40;0&#41;<br />    fxch<br />    fadd real8 ptr CC&#91;8*6&#93;<br />    fadd st&#40;0&#41;,st&#40;1&#41;<br />    fxch<br />    fadd real8 ptr CC&#91;8*7&#93;<br />    fmulp st&#40;1&#41;,st&#40;0&#41;<br />    fadd real8 ptr CC&#91;8*8&#93;<br />    <br />    fdivp st&#40;1&#41;,st&#40;0&#41;          ;CubeRoot&#40;y&#41; ~= P&#40;y&#41;/Q&#40;y&#41;<br />    <br />    mov exp,eax                ;load up n<br />    <br />    fild exp<br />    fxch<br />    fscale                     ;CubeRoot&#40;x&#41; = 2^n * CubeRoot&#40;y&#41;<br />    fstp st&#40;1&#41;<br />    fstp st&#40;1&#41;<br />    test x,80000000h           ;restore sign<br />    jz @F<br />    fchs<br />@@&#58;<br />    ret<br />CubeRoot endp<br /></code></pre><br /><br />--Chorus</div>
    <div class="meta">Posted on 2003-08-19 20:27:27 by chorus</div>
   </div>
   <div class="post" id="post-114524">
    <div class="subject"><a href="#post-114524">Cube Root</a></div>
    <div class="body">Comment #1<br />Unless you start with a finite precise number in your source REAL4, you cannot get a cube root of that number with more than 8 bits of precision regardless of the procedure being used (the REAL4 itself only has 24 bits of precision).<br /><br />If you do start with a finite precise number in your source REAL4, the most precision you could get is 21 bits, i.e. a third of the 64 bits of precision used by the FPU data registers.<br /><br />And if you are not already aware of it, what you would normally consider as a precise decimal number such as 1.35 would NOT be a precise binary number when converted to a REAL4.<br /><br />(Similarly, a square root would only yield 12 bits of precision on the same REAL4 number.) <br /><br />Comment #2<br />Your code to extract a cubic root would be a lot shorter if you use the logarithmic instructions and your result would be the most precise (still only to 8 bits) instead of being an approximation.<br /><br />Raymond</div>
    <div class="meta">Posted on 2003-08-19 23:23:27 by Raymond</div>
   </div>
   <div class="post" id="post-114529">
    <div class="subject"><a href="#post-114529">Cube Root</a></div>
    <div class="body"><div class="quote"><em>Originally posted by Raymond </em><br />Your code to extract a cubic root would be a lot shorter if you use the logarithmic instructions and your result would be the most precise (still only to 8 bits) instead of being an approximation.</div><br /><br />For double precision and so-called extended precision numbers, I agree with Raymond.<br /><br />But, for single precision numbers, log approach is slow.  Approximation can be as accurate as log approach, and much faster.  One can verify this by using Sun's FDLIBM.  After all, the reason why we use single precision numbers is  for speed (and smaller memory requirement).</div>
    <div class="meta">Posted on 2003-08-20 00:21:33 by Starless</div>
   </div>
   <div class="post" id="post-114582">
    <div class="subject"><a href="#post-114582">Thanks</a></div>
    <div class="body">Thanks for your comments :) A couple of remarks:<br /><br />1) I am aware that certain numbers cannot be expressed exactly in either real4, real8 or for that matter any amount of precision. Unfortunately, there's really nothing I can do about it...<br /><br />2) The input, of course, is dependent on the individual application. For example, my application is actually only concerned with integers. The code is easily modified because the only two lines that depend on input precision are the function prototype and the first fld (or fild)<br /><br />3) From what I understand the alternative approach (to calculate with logs) uses f2xm1 and fyl2x, and both these instructions use a lot of clock cycles. In your opinion, Raymond, do you think these instructions would be faster than my approach (with muls and divs)? It was my impression that the general x^y code would be much slower than, say, using Newton's method (or mine). Personally, I need speed and not size for my application<br /><br />4) Output precision is real8. Again, the source document claims that the maximum error of the approximating polynomial is &lt;2^(-24) in the interval [1/8,1). I have not been able to verify this on a large scale, but the few values I have observed seem to hold this true. (By the way, the original document can be found at <a target="_blank" href="http://www.worldserver.com/turk/computergraphics/CubeRoot.pdf">http://www.worldserver.com/turk/computergraphics/CubeRoot.pdf</a>).<br /><br />5) For extending the precision of this approximation, one can either use Newton's method, or arbitrary precision math. Both of these are described in Numerical Recipes (an online version of which is at <a target="_blank" href="http://www.nr.com">http://www.nr.com</a>)<br /><br />6) To starless, since all the operations are done on the FPU stack, there should be no speed difference between a real4 or real8 implementation except for the very first instruction. All stack operations are done as real8s by default (I believe)<br /><br />What really concerns me about my proc, actually, is the fxtract and two fscales. If any one can think of any cleve ways of getting rid of these, i'd be interested to know... I think the fscales in particular wipe out most of the performance gains from eliminating the muls...<br /><br />Again, Thanks for your comments<br />--Chorus</div>
    <div class="meta">Posted on 2003-08-20 09:51:07 by chorus</div>
   </div>
   <div class="post" id="post-114589">
    <div class="subject"><a href="#post-114589">Re: Thanks</a></div>
    <div class="body">2) and 6) Not only would the parameters passed to the routine need changing, but also the FPU would have to be put into an extended percision mode.<br /><br />4) Would not this error compound as these approximations are continually used to approximate the cube roots of larger numbers?<br /><br />Thanks for the link to the original text and keep up the good work.</div>
    <div class="meta">Posted on 2003-08-20 11:12:22 by bitRAKE</div>
   </div>
   <div class="post" id="post-114594">
    <div class="subject"><a href="#post-114594">Cube Root</a></div>
    <div class="body">1.- The FPU functions with 80-bit registers such all FPU operations are performed with extended precision, i.e. REAL10.<br /><br />2.- That precision is equivalent to approximately 19 decimal significant digits. The list of constants supplied in your .asm file initializes REAL8 variables which only have the precision equivalent to approximately 16 decimal significant digits. All those digits exceeding the 16th or 17th digit are thus totally useless for improving the precision of any computation.<br /><br />3.- The following proc relying on logarithms to compute the cubic root takes approximately 1.22 microsecs (based on 1000000 loops) as compared to approximately 1.16 microsecs with your proc on my computer (P4 1.5GHz). The difference is quite minimal.<br />When results are compared to those obtained with the Windows' calculator, the log proc is precise to the 16th significant digit. Your proc is precise to the 8th decimal digit.<br /><pre><code>CubeLog proc uses eax ecx edx x&#58;DWORD<br /><br />      finit<br />      fld1<br />      fld   st<br />      fadd  st,st<br />      fadd                    ;st=3<br />      fild  x                 ;st=x, st1=3<br />      fabs<br />      fxtract                 ;st=man, st1=exp, st2=3<br />      fincstp                 ;st7=man, st=exp, st1=3<br />      fst   st&#40;2&#41;             ;st7=man, st=exp, st1=3, st2=exp<br />      fprem                   ;st7=man, st=expmod3, st1=3, st2=exp<br />      fdecstp                 ;st=man, st1=expmod3, st2=3, st3=exp<br />      fscale                  ;st=man*2^expmod3, st1=expmod3, st2=3, st3=exp<br />      fstp  st&#40;1&#41;             ;st=man*2^expmod3, st1=3, st2=exp<br />      fld1                    ;st=1, st1=man*2^expmod3, st2=3, st3=exp<br />      fdiv  st,st&#40;2&#41;          ;st=1/3, st1=man*2^expmod3, st2=3, st3=exp<br />      fxch                    ;st=man*2^expmod3, st1=1/3, st2=3, st3=exp<br />      fyl2x                   ;st=log2&#40;man*2^expmod3&#41;*1/3, st1=3, st2=exp<br />      f2xm1<br />      fld1<br />      fadd                    ;st=2^&#91;log2&#40;man*2^expmod3&#41;*1/3&#93;, st1=3, st2=exp<br />      fincstp                 ;st7=2^&#91;log2&#40;man*2^expmod3&#41;*1/3&#93;, st=3, st1=exp<br />      fdiv  st&#40;1&#41;,st          ;st7=2^&#91;log2&#40;man*2^expmod3&#41;*1/3&#93;, st=3, st1=exp/3<br />      fdecstp                 ;st=2^&#91;log2&#40;man*2^expmod3&#41;*1/3&#93;, st1=3, st2=exp/3<br />      fstp  st&#40;1&#41;             ;st=2^&#91;log2&#40;man*2^expmod3&#41;*1/3&#93;, st1=exp/3<br />      fscale                  ;st=2^&#91;log2&#40;man*2^expmod3&#41;*1/3&#93;*2^exp/3, st1=exp/3<br />      ffree st&#40;1&#41;             ;st=cube root &#40;x&#41;<br />      test x,80000000h<br />      jz @F<br />      fchs                    ;restore sign<br />  @@&#58;<br /><br />      ret<br /><br />CubeLog endp<br /></code></pre><br />Raymond</div>
    <div class="meta">Posted on 2003-08-20 12:59:18 by Raymond</div>
   </div>
   <div class="post" id="post-114595">
    <div class="subject"><a href="#post-114595">Cube Root</a></div>
    <div class="body">Bitrake,<br /><br />  Thank you very much for your comments :)<br /><br />  Regarding the FPU precision mode, I think by default the FPU is in double precision mode. Or at least, that's what I remember FINIT does, and I think Windows will call this before the application process is started (can anyone verify this?). So I believe when the first fld (or fild) is called, regardless of the original source, the value will be converted to real8 on the stack. I suppose you could change the precision to extended to buy yourself some extra bits in the calculation, but that will likely be taken care of at the application level.<br /><br />  As for error accumulating I'm not sure what you mean. The procedure I wrote is not iterative so taken by itself the error should not get worse as the number gets larger (at least not worse *percentage* wise, it will however double in magnitude as the original number doubles, etc.). For Newton's method, the error should actually *decrease* as more iterations are called. The source code that I attached in my OP has a more detailed explaination<br /><br />Thanks<br /><br />--Chorus</div>
    <div class="meta">Posted on 2003-08-20 13:07:40 by chorus</div>
   </div>
   <div class="post" id="post-114626">
    <div class="subject"><a href="#post-114626">Cube Root</a></div>
    <div class="body">1.  Chorus reply 6:<br />Actually, you can save memory with SP coefficients.  What I told you is from my experience.  Try transcribing Sun's FDLIBM, and compare the speed with log approach.  You'll see what I meant only when you actually do it.<br /><br />2.   Raymond's second comment 1:<br />That is not true for all FPU instructurions.  An example to falsify your claim is fdiv.  Try changing PC bits and fdiv.  You will see that in some cases, x86 FPU fails to pass IEEE test.  (But, lower precision makes fdiv faster.)<br /><br />3.  Finally...<br />PC bits are set to 3 when CPU starts up.  But, several OSes change it to 2 claiming that extended precision is unreliable.  Windows is one of them.  One advantage of log approch is that several transcendental functions are always done in extended precision, regardless of your PC setting. log and exponential functions are among them.  On the other hand, basic operations like add/mul/sub/div are sensitive to PC setting.<br /><br />And, cube root is relatively smooth function (compared to other frequently used functions) and you don't lose much even if your coefficients are in SP.  --  And I told you Sun's FDLIBM is as accurate as log approach.  The results are 1 ulp apart at the worst.  1 ulp of SP number.  How large error is that?  ;)</div>
    <div class="meta">Posted on 2003-08-20 16:28:56 by Starless</div>
   </div>
   <div class="post" id="post-114632">
    <div class="subject"><a href="#post-114632">Cube Root</a></div>
    <div class="body">About the extraction of the 3rd root, it reminds me an interesting approach on the site optimalcode.com (which is strangely dead now).<br />It was a 'DKC' solver (from the name of the danish creator), which was a function approximator, it was able to compute approximations on trigonometric functions with very few terms and good accuracy, but should work on exponentiations. I don't know much about the algorithms behind.<br />Perhaps you should try the Chebyshev (or Chebychev, or with tch...)  method to get a better approximation.<br /><br />Some years ago, I also saw a binary digit nth-root extractor. It was in Byte. Perhaps could you find it somewhere ?<br /><br />JC</div>
    <div class="meta">Posted on 2003-08-20 16:56:14 by MCoder</div>
   </div>
   <div class="post" id="post-114645">
    <div class="subject"><a href="#post-114645">Cube Root</a></div>
    <div class="body">Starless, I'll give your approach a try and see if I can reduce the size of the code (I assume that's what you mean by saving memory... ? Otherwise I'm not sure what there is to gain...)<br /><br />MCoder, I was just looking into a Rational Chebyshev Approximation. I'm thinking I can get a pretty good approximation for x^(1/3) in the interval [-1/8,1/8] and use the same idea of scaling down x, calculating the root and then scaling back up. I need to get to a computer with Mathematica or something to calculate the coefficients... I don't think my calculator will solve the approximation to the necessary precision...<br /><br />As an aside, I tried replacing one of the fscale's in my code with multiplying by the corresponding integer value (2^n). This is much faster (increasing the algo by 20% or so), but only works if 0 &lt;= n &lt;32. ie., doesn't work for negative values of n (corresponding to 0&lt;x&lt;1) or very large values of n.<br /><br />--Chorus</div>
    <div class="meta">Posted on 2003-08-20 17:34:13 by chorus</div>
   </div>
   <div class="post" id="post-114646">
    <div class="subject"><a href="#post-114646">Cube Root</a></div>
    <div class="body"><div class="quote"><br />As an aside, I tried replacing one of the fscale's in my code with multiplying by the corresponding integer value (2^n). This is much faster (increasing the algo by 20% or so), but only works if 0 &lt;= n &lt;32. ie., doesn't work for negative values of n (corresponding to 0&lt;x&lt;1) or very large values of n.</div>Could use Agner Fogs method of avoiding fscale.<br /><br /><pre><code>fstp TBYTE PTR &#91;esp&#93;<br /><br />; adjust the exponent<br />add &#91;esp+8&#93;, eax<br /><br />; load the scaled value<br />fld TBYTE PTR &#91;esp&#93;</code></pre></div>
    <div class="meta">Posted on 2003-08-20 17:47:39 by bitRAKE</div>
   </div>
   <div class="post" id="post-114668">
    <div class="subject"><a href="#post-114668">Cube Root</a></div>
    <div class="body"><div class="quote">fstp TBYTE PTR <br /><br />; adjust the exponent<br />add , eax<br /><br />; load the scaled value<br />fld TBYTE PTR </div><br />For those who may not be aware, the above code would trash the stack if used as is. Most probably bitRAKE would have preceded that with<br /> <strong>sub esp,10</strong> to reserve space on the stack and later restore the stack with a<br /> <strong>add esp,10</strong><br /><br />chorus<br /><br />I was curious about the efficiency of the FpuXexpY function of the Fpulib and surprised at its speed compared to the other algo I posted. The main reason for the speed improvement was that the reciprocal of 3 had to be precalculated and in memory before calling the function.<br /><br />The following proc comes at 0.70 microseconds as compared to the other figures reported previously. Significantly faster and still providing the most precision. Hard to believe but the simple computation of the reciprocal of 3 within the proc itself would add some 0.4 microseconds!!!<br /><pre><code><br />CubeLogA proc uses eax ecx edx x&#58;DWORD<br /><br />.data<br />      recip3      dt    0.333333333333333333<br /><br />.code<br />      finit<br />      fld   recip3<br />      fild  x<br />      fabs<br />      fyl2x                   ;-&gt;log2&#40;Src1&#41;*exponent<br />      fld   st&#40;0&#41;             ;copy the logarithm<br />      frndint                 ;keep only the characteristic<br />      fsub  st&#40;1&#41;,st          ;keeps only the mantissa<br />      fxch                    ;get the mantissa on top<br />      f2xm1                   ;-&gt;2^&#40;mantissa&#41;-1<br />      fld1<br />      fadd                    ;add 1 back<br />      fscale                  ;scale it with the characteristic<br />      fstp  st&#40;1&#41;             ;copy result over and &quot;pop&quot; it<br />      test x,80000000h<br />      jz @F<br />      fchs                    ;restore sign<br />  @@&#58;<br />      ret<br /><br />CubeLogA endp<br /></code></pre><br /><br />Raymond</div>
    <div class="meta">Posted on 2003-08-20 19:11:06 by Raymond</div>
   </div>
   <div class="post" id="post-114700">
    <div class="subject"><a href="#post-114700">Cube Root</a></div>
    <div class="body">One more detail which may be difficult to explain. As stated in the previous post, computing the reciprocal of 3 within the proc was adding some 0.40 microsecond.<br /> <br />This was relatively constant whether the value of 3 was built on the FPU or loaded from memory as a floating point (REAL4, REAL8 or REAL10) or an integer (WORD or DWORD) before performing the division of 1.<br /><br />This was also relatively constant when dividing 1 directly by a value of 3 from memory whether declared as a floating point (REAL4, REAL8) or a DWORD integer.<br /><br />HOWEVER, dividing 1 directly by a value of 3 from memory declared as a <strong>WORD</strong> only added 0.05 microseconds to the proc.:confused: <br /><br />Raymond</div>
    <div class="meta">Posted on 2003-08-20 23:13:09 by Raymond</div>
   </div>
   <div class="post" id="post-114834">
    <div class="subject"><a href="#post-114834">Timings</a></div>
    <div class="body">Hello Raymond,<br />  I love the simplicity of your method. I can't argue about having smaller *and* faster code :)<br /><br />  However, there must be a big difference between your processor and mine... when I compare the latest code of yours vs my original, mine seems to runs about 30% faster... I'm running AMD Athlon 1100 MHz. I'm just using a simple rdtsc to count clocks after 1000000 iterations, like so:<br /><br /><pre><code><br />start&#58;<br /><br />    mov ecx,1000000<br />    rdtsc<br />    mov FirstTimeLo,eax<br />    mov FirstTimeHi,edx<br />    <br />@@&#58;<br />    push 8<br />    call CubeRoot<br />;    call CubeLogA    <br />    fstp st&#40;0&#41;<br />    dec ecx<br />    jnz @B<br />    <br />    rdtsc<br />    sub eax,FirstTimeLo<br />    sbb edx,FirstTimeHi<br /><br />;I'm dividing down by 1000 to make sure there's nothing<br />;in edx that I'm missing, although I expect it to be zero<br /><br />    mov ecx,1000<br />    idiv ecx<br />    <br />    invoke dwtoa,eax,addr szOutput<br />    invoke MessageBox,NULL,addr szOutput,NULL,MB_OK<br />    invoke ExitProcess,NULL<br /></code></pre><br /><br />After running it at least a dozen times your proc comes up around 200 million clocks and mine around 140 million...<br /><br />Perhaps the P4 executes the f2xm1 and fyl2x much faster...<br /><br />(BTW with your method you have to test for zero at the beginning b/c of the log base 2)<br /><br />Regards<br />--Chorus<br /><br />PS I looked into approximating the cube root in the range [-1/8,1/8] to try to simplify my method a little (I was hoping, for instance to eliminate the need to check for the sign). This doesn't seem to work very well because the derivative disappears at 0. Rational polynomial approximation doesn't seem to like that very much, though I'm going to try other ideas. In the mean time, I'm going to try Bitrakes' suggestion for replacing fscale, although I think it's a little more complicated than his post because the top bit of the 10BYTE is for sign... it'll have to be preserved somehow.. I think a simple rol value,1 ought to do the trick...</div>
    <div class="meta">Posted on 2003-08-21 15:24:23 by chorus</div>
   </div>
   <div class="post" id="post-114882">
    <div class="subject"><a href="#post-114882">Cube Root</a></div>
    <div class="body">It's surprising at times how different computers will perform with a given set of instructions. For example, I have a little program to extract square roots with up to 10,000 decimals in the answer. That program was running  almost twice as fast on my previous P3-550 than on my P4-1500!!!<br /><br />Your AMD seems to be a lot more efficient than my P4. Using the rstdc (instead of the millisec timer of Windows), I'm getting 1200 cycles for my procedure and 1700 for yours. Maybe its a P4-150 that I got.:( <br /><br />When I looked at bitRAKE's suggestion for scaling, I was also annoyed at first about the sign bit. Giving more thought to it, that sign bit will not get affected unless your scaling factor would be so big (positive or negative) as to exceed the range of the REAL10 format, which is quite improbable unless you feed it garbage.<br /><br />Raymond</div>
    <div class="meta">Posted on 2003-08-21 22:35:02 by Raymond</div>
   </div>
   <div class="post" id="post-115011">
    <div class="subject"><a href="#post-115011">bleh</a></div>
    <div class="body">Ok, after taking a number of different ideas I've got a much revamped version:<br /><br />1) I managed to eliminate the integer divide by using magic number division (thanks to The Svin for these constants, I stole them from one of his posts :) )<br />2) The two fscales and one fxtract are gone, I'm doing the scaling manually using the real10 format. (For anyone unfamiliar with real10 format, check out Intel's Architecture Software Developer's Manual, Volume 1)<br />3) All conditional jumps are removed<br />4) At the bottom, I use a real4 scale value to simultaneously restore the sign of the original value and adjust the exponent<br />5) The constants have been recalculated and reordered. I'm not sure if the values will load any quicker if they are in the order that they get used, but I figured it couldn't hurt<br /><br />This code now runs about twice as fast as yours on my machine. Strangely, I thought I could get better performance by rearranging the instructions (trying to get better pairing) but I couldn't make much of a difference. So I've left it in a more &quot;readable&quot; manner.<br /><br />I still can't touch your procedure for precision, although I do have an idea to improve it, I don't really feel like going through it right now. The idea is pretty simple: The proc maps the input value to the range [1/8,1) which naturally breaks down to three separate regions [1/8,1/4), [1/4,1/2), and [1/2,1). My idea is simple: to have 3 sets of constants, one corresponding to a distinct approximation function in each of the three ranges. This should bring the error down to around &lt;1e-12 or so.<br /><br />Again, if anyone has any improvements I'd be glad to hear them<br /><br />Thanks<br />--Chorus<br /><br /><br /><pre><code><br />.data<br />    CC real8    6.3637179600061402163539320738081<br />       real8  -12.065381127146011865968174543024<br />       real8   1.15441272092408400896359030695808<br />       real8     1.32216597568937846186167818505031<br />       real8   82.614153385222731367127241292588<br />       <br />       real8   65.00227162585858862822658857792<br />       real8  -90.424005465780377990655280610327<br />       real8    2.31555198682175862934814370456<br />       real8  5985.3903660662530599695396031034<br /><br /><br />.code<br />CubeRoot proc uses eax ecx edx x&#58;dword<br />LOCAL mant&#91;3&#93;&#58;DWORD<br />    fild x                        ;get the input value into a real10 format<br />    fstp real10 ptr mant          ; so we can adjust the exponent<br />    mov ecx,7FFFh<br />    mov eax,2863311531            ;Use magic number &quot;division&quot; of exponent by three to get<br />    and ecx,dword ptr &#91;mant+8&#93;    ; remainder and quotient. Some constants are used here<br />    mul ecx                       ; because of the bias on the real10 stored value.<br />    shr edx,1<br />    lea eax,&#91;edx*2&#93;&#91;edx-3FFFh+3&#93;<br />    sub ecx,eax<br />    mov dword ptr &#91;mant+8&#93;,ecx    ;Store back the adjusted exponent<br />    fld real8 ptr CC&#91;0*8&#93;         ;Start loading our constants to calculate P&#40;y&#41;<br />    fld real8 ptr CC&#91;1*8&#93;         ; the first polynomial<br />    fld real8 ptr CC&#91;2*8&#93;<br />    fld real10 ptr mant<br />    fmul real8 ptr CC&#91;3*8&#93;<br />    fadd st&#40;2&#41;,st&#40;0&#41;<br />    faddp st&#40;1&#41;,st&#40;0&#41;<br />    fmul st&#40;0&#41;,st&#40;0&#41;<br />    fadd st&#40;2&#41;,st&#40;0&#41;<br />    faddp st&#40;1&#41;,st&#40;0&#41;<br />    fmulp st&#40;1&#41;,st&#40;0&#41;<br />    fadd real8 ptr CC&#91;4*8&#93;        ;P&#40;y&#41;<br />    fld real8 ptr CC&#91;5*8&#93;         ;The second polynomial Q&#40;y&#41;<br />    fld real8 ptr CC&#91;6*8&#93;<br />    fld real8 ptr CC&#91;7*8&#93;<br />    fld real10 ptr mant<br />    fadd st&#40;2&#41;,st&#40;0&#41;<br />    faddp st&#40;1&#41;,st&#40;0&#41;<br />    fmul st&#40;0&#41;,st&#40;0&#41;<br />    fadd st&#40;2&#41;,st&#40;0&#41;<br />    faddp st&#40;1&#41;,st&#40;0&#41;<br />    fmulp st&#40;1&#41;,st&#40;0&#41;<br />    fadd real8 ptr CC&#91;8*8&#93;        ;Q&#40;y&#41;<br />    fdivp st&#40;1&#41;,st&#40;0&#41;             ;P&#40;y&#41;/Q&#40;y&#41;<br />    mov eax,x                     ;Build a real4 value with the following properties&#58;<br />    add edx,7Fh-1554h<br />    and eax,80000000h            ; 1&#41; Has same sign as original value<br />    shl edx,23                   ; 2&#41; Has exponent of cube root<br />    add edx,eax<br />    mov dword ptr &#91;mant&#93;,edx<br />    fmul real4 ptr &#91;mant&#93;        ;Multiply by our value to simultaneously correct<br />    ret                          ; sign and exponent<br />CubeRoot endp<br /></code></pre></div>
    <div class="meta">Posted on 2003-08-22 10:49:32 by chorus</div>
   </div>
   <div class="post" id="post-115013">
    <div class="subject"><a href="#post-115013">oops</a></div>
    <div class="body">Oops... doesn't work with x = 0. Just throw in a cmp x,0/je @@ReturnFromTheProc after the fild :)</div>
    <div class="meta">Posted on 2003-08-22 10:57:06 by chorus</div>
   </div>
  </div>
 </body>
</html>