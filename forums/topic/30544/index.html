<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>How to do GPU programming using assembly? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30544" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=30544">How to do GPU programming using assembly?</a></p>
   <div class="post" id="post-214303">
    <div class="subject"><a href="#post-214303">How to do GPU programming using assembly?</a></div>
    <div class="body">I am new to this topic so i don&#039;t think i know much about it.<br /><br />As the topic says, i want to do general computing on the GPU. I know that there are full blown API like DirectX and OpenGL to help people do that. But i what i want to do is not really anything as complex as drawing vertices, textures and so on; which DirectX and OpenGL makes them easy to do so thanks to their API procedures. I want to start with stuff as simple as adding two numbers on the GPU and maybe do a personalized JPEG decoder that uses the GPU (preferably on assembly).<br /><br />I have been looking around at a few books and tutorials and i see that DirectX and OpenGL starts doing the big stuff in small steps right away with their API procedures. I just want to know how to directly access to the video instructions and memory. But i am also aware that although what i am trying sounds simple it might not be so due to the abstraction layers and how the drivers might be manipulating the instructions due to individual hardware implementations of the graphics cards.</div>
    <div class="meta">Posted on 2011-04-18 09:29:18 by banzemanga</div>
   </div>
   <div class="post" id="post-214307">
    <div class="subject"><a href="#post-214307">Re: How to do GPU programming using assembly?</a></div>
    <div class="body">Write your own shader? Or use DirectCompute/OpenCL/CUDA. Can&#039;t think of any other way.</div>
    <div class="meta">Posted on 2011-04-18 17:11:13 by ti_mo_n</div>
   </div>
   <div class="post" id="post-214308">
    <div class="subject"><a href="#post-214308">Re: How to do GPU programming using assembly?</a></div>
    <div class="body">No, i don&#039;t want to start anything complicated like making my own shader. Let&#039;s start simple. Add two numbers on the GPGPU. Move a value to a register or video memory location.</div>
    <div class="meta">Posted on 2011-04-18 18:02:48 by banzemanga</div>
   </div>
   <div class="post" id="post-214309">
    <div class="subject"><a href="#post-214309">Re: How to do GPU programming using assembly?</a></div>
    <div class="body">There are two major libraries to assist in writing GPU-based code: they are CUDA and GPGPU.<br /><br />If you insist on creating your own solution, then you cannot avoid writing a shader function (actually, you can&#039;t ever avoid this but I digress).<br />The typical solution is to use a custom pixel shader, along with your own custom Pixel Format for passing your data to/from the GPU code, via &#039;custom textures&#039; which are just flat arrays of your custom pixel structure, and using &#039;render-to-texture&#039; to capture the output back from the pixel shader.<br /><br />There are of course other avenues, which may be more or less efficient depending on your requirements.<br /><br />Just to add two numbers together, you can get away with reading and writing shader variables, with the most braindead shader code ever, and no textures.<br />Shader functions are meant to primarily operate apon their input args, however it&#039;s our function, we can make it do what we want.<br /></div>
    <div class="meta">Posted on 2011-04-19 00:52:07 by Homer</div>
   </div>
   <div class="post" id="post-214310">
    <div class="subject"><a href="#post-214310">Re: How to do GPU programming using assembly?</a></div>
    <div class="body">You can write assembly only with DirectX 9 shaders (SM3.0 max) or OpenGL vertex/fragment programs (SM2.0 max), which is not REAL assembly, but more like bytecode as in Java/.NET, or by using Cuda (again a sort of pseudo-assembly).<br />DX10+ and newer OpenGL versions only support HLSL/GLSL for shaders, since there&#039;s no point in using assembly when it&#039;s a bytecode language anyway.<br /><br />Programming directly on the GPU isn&#039;t going to work, since all GPUs are massively different. A GeForce 7-series has a completely different architecture and instructionset to a GeForce 8-series, and so on. Not to mention the differences between nVidia, AMD and Intel GPUs. For that reason, there really aren&#039;t any interfaces available for any GPU to write native assembly directly. It&#039;s just useless, as it will only run on that particular GPU.<br /><br />So in short, I wouldn&#039;t even bother trying to use assembly. Just stick to the C-like languages of the particular APIs. There&#039;s nothing to gain with assembly, and lots to lose.<br /><br />The difference between writing graphics shaders (vertex/geometry/pixel/etc) and using GPGPU (Cuda/DirectCompute/OpenCL/Stream) is mainly in the flexibility of memory access.<br />Graphics shaders have very limited input and output. The input can only come from a vertex buffer or a texture. And the output can only go to a single pixel. Another limitation is that you cannot use the same texture as both input and output, which means that shaders cannot access each other&#039;s data.<br /><br />With GPGPU, there is a local storage buffer. This allows you to share data between shaders, which allows you to solve a lot more problems (or solve the same problems in more efficient ways, by requiring less render passes).<br /><br />But really, if you just want to add 2+2 together on a GPU, you&#039;re already going to need quite a bit of setup code. The programming model generally looks something like this:<br />1) Initialize the device through the API (create a device object, create a context etc).<br />2) Initialize your input and output buffers.<br />3) Initialize your GPU code (in most cases this means actually sending the ASCII source code to the driver to have it compiled, and it will return you an object representing the compiled code. Cuda allows you to compile the shader and link it directly to your program. It just appears as an extern &quot;C&quot; function).<br />4) Set the input and output buffers for your GPU code.<br />5) Execute the GPU code.<br />6) Read back the results from the output buffers on the CPU.<br /><br />Another thing you have to realize is that the execution model is vastly different from a CPU. On a GPU you never just want to run a single addition or such. A GPU is a massively parallel architecture. Its speed does not come from its linear processing power, but from the fact that it can run many (slow) threads at the same time.<br />With GPGPU you generally execute a grid of data at the same time (this can be structured as 1D, 2D or 3D, depending on what makes the most sense for your particular code).<br />Basically all shaders in the grid run the exact same code (it&#039;s a form of SIMD), but they are all fed with different input grid coordinates. You use these grid coordinates to determine what input to sample from the input buffer, and where to write the output. So basically you are executing an array at a time.</div>
    <div class="meta">Posted on 2011-04-19 05:20:16 by Scali</div>
   </div>
   <div class="post" id="post-214311">
    <div class="subject"><a href="#post-214311">Re: How to do GPU programming using assembly?</a></div>
    <div class="body">Thanks for your responses and explanations.<br /><br />Now i see <strong>ti_mo_n</strong> meant by writing my &quot;own shader&quot;. One of the simplest way to make the GPU do calculations is to get through the shaders pipeline to do the simple steps through big leaps for me.<br /><br />I did expect the possibility that because many GPUs are massively different in architecture, device drivers would do some coding/decoding to tell the GPU what instructions are to execute. But i still hang on the other possibility of being to program on it directly.<br /><br />I did a little research and i found out that OpenCL is the only open standard (pseudo-)assembly(?) option out there. CUDA and ATI Stream are pretty much private high-level language standards. And even OpenCL for GPCPU programming is rather a new thing. OpenCL 1.1 was standarized on 2010! Only one year ago! DirectX is only for Windows; while for some reason i am a little reluctant about GLSL.<br /><br />Probably the only way to access the GPU directly is by creating my own custom device driver which i could just forget about it. Also, the custom driver will only work on that specific device.<br /><br />I hoped that GPUs would have certain standard in the architecture like AMD and Intel CPUs. Different on the inside but have mostly the same general instruction sets.<br /><br />What i really wanted to do was something like a custom JPEG decoder that uses the GPU instead of the CPU. And i hoped it would something simple enough to be able to work on a really old computer with old graphics card.<br /><br />Which it brings to what i am now confused about. How did earlier versions DirectX took advantage of older graphics cards when older graphics cards didn&#039;t have much SIMD instructions capability to be considered GPGPU in the first place? Does it mean that DirectX did the computations on the CPU and then send the preliminary results to the graphics card 2D acceleration pipeline for final processing?</div>
    <div class="meta">Posted on 2011-04-19 06:53:26 by banzemanga</div>
   </div>
   <div class="post" id="post-214312">
    <div class="subject"><a href="#post-214312">Re: How to do GPU programming using assembly?</a></div>
    <div class="body">OpenCL has no assembly, only a C-like language.<br />And you should be very VERY glad that GPUs do NOT have an architectural standard such as Intel&#039;s x86. Videocards have evolved at a much faster rate than CPUs, and pack a lot more processing power in a single chip, exactly for that reason: There is no architectural standard. You can do anything you like (such as Intel attempting to build a GPU with a set of Atom-like x86 cores with extended SIMD units, aka Larrabee), as long as you can write a driver that will support DirectX and/or OpenGL (and these days they&#039;re so similar that if you can support one, you can support the other as well).<br /><br />GPGPU is still relatively new. The first videocards to support OpenCL/DirectCompute/Cuda are the GeForce 8-series. And you can probably just forget about doing something like JPG decoding without GPGPU.<br /><br />How older DirectX/OpenGL worked is a very long story, but I&#039;ll try to make it as short as possible.<br />Evolution of videocards and APIs:<br />1) 3D was completely CPU-based. The CPU would perform all lighting, transforming, rasterizing and finally the actual pixel drawing.<br />(Pre-accelerator era, CGA/EGA/VGA)<br />2) The innerloop of the triangle filling routine was accelerated by the videocard. A triangle is rendered as two scanline-oriented quads (upper and lower half). The CPU could pass these quads to the videocards, and the scanlines were filled automatically. Basic texturing and shading could be applied as well, but the CPU still had to do the setup to calculate the gradients for the quads.<br />(Early VooDoo cards, pre-D3D to early D3D)<br />3) Rasterizing and triangle gradient setup were accelerated by the videocard. The CPU could now feed triangles in screenspace directly to the videocard.<br />(Roughly D3D5-era)<br />4) The dawn of the GPU: Transforming and lighting were accelerated by the videocard. The CPU could now pass triangles in object space (which could be stored in videomemory, since they would be static throughout the lifetime of the object), transform matrices and light parameters to the GPU, and the GPU would completely accelerate the drawing process from start to finish.<br />(D3D7-era)<br />5) The dawn of programmable shaders: Up to now, the lighting and shading were fixed-function, and operated as a state machine. The CPU would set a few states to control how the GPU would perform shading. This state machine has become so complex, and because of multitexturing, it already worked in multiple stages, that it started to make sense to model these states as simple instructions with input and output registers. The fixed-function T&amp;L and shading operations could now be &#039;scripted&#039; in an assembly-like language.<br />(D3D8-era)<br />6) Unified shaders and GPGPU: Up to now, vertex processing and pixel processing were two seperate types of operations, requiring separate types of execution units. The GPU would have a small set of vertex units, which would have high precision floating point, and a relatively powerful instructionset. Then it would have a larger set of pixel units, which were more aimed at texturing, and had lower precision arithmetic, and a simpler, less powerful instructionset. You basically had to use two languages when programming: vertex shader language and pixel shader language.<br />But now, all shaders were made unified. So now you could use the same high-precision powerful instructions for pixel shaders as for vertex shaders. The hardware now also used a single large array of shader units, which could dynamically be allocated to whatever shaders were running (effectively an automatic load balancing system between vertex processing and pixel processing).<br />At this time, nVidia also introduced the first real GPGPU: the GeForce 8-series. Its unified shaders were linked to a large shared cache, and could be used outside the graphics pipeline, which had been hardwired up to now (if you wanted to do any calculations, you&#039;d always have to set up geometry and render actual triangles, in order to make pixel shaders execute and output data to a buffer).<br />(D3D10-era)<br /><br />So in short: Yes, at first the CPU did everything, then very gradually, the GPU started to take over. At first the GPU would just have hardwired functionality, so it was not programmable at all. The first generation of &#039;programmable&#039; GPUs were barely more &#039;programmable&#039; than the last generation of state-based fixed function GPUs (especially regarding pixel processing. At first vertex shaders were the biggest step forward. Pixel shaders were very limited).</div>
    <div class="meta">Posted on 2011-04-19 08:00:45 by Scali</div>
   </div>
   <div class="post" id="post-214314">
    <div class="subject"><a href="#post-214314">Re: How to do GPU programming using assembly?</a></div>
    <div class="body">Thank you very much Scali. You are such a knowledge mine. I have learned so much from your replies that it would probably take me weeks or months of research to&nbsp; to dig up the answers from articles or books.</div>
    <div class="meta">Posted on 2011-04-19 16:50:02 by banzemanga</div>
   </div>
   <div class="post" id="post-214322">
    <div class="subject"><a href="#post-214322">Re: How to do GPU programming using assembly?</a></div>
    <div class="body">You&#039;re welcome. I&#039;ve been doing graphics since the days of Amiga and PCs with VGA cards. So I&#039;ve experienced pretty much the entire development of 3d acceleration and APIs from the beginning.<br />I guess a big problem with finding information on the internet is that it&#039;s difficult to place it in the proper context. Videocards and APIs have changed a lot over the years, and there&#039;s a lot of outdated, useless, or even downright wrong information out there.<br /><br />I&#039;ve written a JPG decoder myself (just CPU though), and I have some experience with Cuda and DirectCompute, so I might be able to help.<br />F0dder also mentioned some GPU-accelerated JPG stuff to me a while ago. I think it was done with Cuda. One of the experimental things there was a &#039;trial-and-error&#039; approach to the decoding of the Huffman bitstream. They would cut up the stream in small pieces, and have many threads decode parts of them in parallel.<br />The stream pieces had no clear beginning and ending, so the threads would just have to try to find a starting point for decoding, and just find out where it leads to.<br /><br />Most of the other parts of JPG decoding are very straightforward for a SIMD-oriented parallel architecture. It&#039;s mainly just operations on 8x8 matrices.</div>
    <div class="meta">Posted on 2011-04-22 05:14:39 by Scali</div>
   </div>
   <div class="post" id="post-214386">
    <div class="subject"><a href="#post-214386">Re: How to do GPU programming using assembly?</a></div>
    <div class="body">I found some CUDA jpeg decoder stuff on sourceforge yeah, but there was also some article somewhere - don&#039;t have any links available, so you can probably google it faster than I can, heading off to bed.<br /><br />But the gist was that jpeg decoding on GPU isn&#039;t super easy, you have a massive bottleneck around the huffman decode part which is very hard to parallelize; it&#039;s basically, as scali mentions, a trial and error hackjob. Syncing between the GPU threads is very expensive, if even possible at all.</div>
    <div class="meta">Posted on 2011-05-18 18:23:46 by f0dder</div>
   </div>
   <div class="post" id="post-214388">
    <div class="subject"><a href="#post-214388">Re: How to do GPU programming using assembly?</a></div>
    <div class="body">I think this was the one: http://www.eecg.toronto.edu/~moshovos/CUDA08/arx/JPEG_report.pdf</div>
    <div class="meta">Posted on 2011-05-18 18:32:29 by Scali</div>
   </div>
   <div class="post" id="post-214494">
    <div class="subject"><a href="#post-214494">Re: How to do GPU programming using assembly?</a></div>
    <div class="body">After abandoning this i decided to come back with a different approach. I tried using OpenCL with ATI Stream since i have a ATI video card. I managed to make a simple program that does some simple math computation. But pretty much let it go because the compiled code was some kind of byte code like it was mentioned before and it had to be re-run with another additional software provided by ATI.<br /><br />So, i remembered about creating a custom shader on DirectX was also a possibility. So i was wondering if i could get the output of the shader and cast it into one of the variables of my application. I have almost zero knowledge of programming with DirectX so i need some help. And i can&#039;t find the missing pieces i need from the tutorials i get online.<br /><br />So let&#039;s assume this simple shader which returns the value of a variable which was set equals to &#039;1&#039;:<br /><pre><code><br />//shaderl.hls<br />int global_dx;<br /><br />int output() {<br />	global_dx = 1;<br />	return global_dx;<br />}</code></pre><br /><br />And then my application which prints the value of the shader to the console:<br /><pre><code><br />//main.cpp<br />#include &lt;iostream&gt;<br />#include &lt;d3d11.h&gt;<br />#include &lt;d3dx11.h&gt;<br />#include &lt;d3dx10.h&gt;<br /><br />// include the Direct3D Library file<br />#pragma comment (lib, &quot;d3d11.lib&quot;)<br />#pragma comment (lib, &quot;d3dx11.lib&quot;)<br />#pragma comment (lib, &quot;d3dx10.lib&quot;)<br /><br />using namespace std;<br /><br />int main() {<br />	ID3D10Blob *VS;<br />	D3DX11CompileFromFile(&quot;shaders.hls&quot;, 0, 0, &quot;output&quot;, &quot;vs_5_0&quot;, 0, 0, 0, &amp;VS, 0, 0);<br /><br /> 	//I need help here<br />	//int value_from_shader = DX_function_calls_shader_function;<br />	//cout &lt;&lt; value_from_shader&nbsp; &lt;&lt; endl;<br /><br />	std::system(&quot;pause&quot;);<br />	return 0;<br />}</code></pre><br />I need to know how i call the shader function from my application.</div>
    <div class="meta">Posted on 2011-06-19 16:51:18 by banzemanga</div>
   </div>
   <div class="post" id="post-214495">
    <div class="subject"><a href="#post-214495">Re: How to do GPU programming using assembly?</a></div>
    <div class="body">You don&#039;t &#039;call&#039; the shader, you set the active shaders to the pipeline (the name of the function reflects the part of the pipeline where it is set, see http://msdn.microsoft.com/en-us/library/ff476882(v=vs.85).aspx).<br />There are 6 different types of shaders in Direct3D 11, each with their own function to set them as active:<br />- Vertex shaders: VSSetShader()<br />- Hull shaders (step 1 of tessellation): HSSetShader()<br />- Domain shaders (step 2 of tessellation): DSSetShader()<br />- Geometry shaders: GSSetShader()<br />- Pixel shaders: PSSetShader()<br /><br />Wait, that&#039;s only 5, and I said 6. But we covered the whole pipeline already.<br />That&#039;s because these 5 shaders are all used simultaneously during rendering (although some of them are optional). This is the *graphics* pipeline, after all. So you set all the shaders you want to use, and then you set up geometry to be rendered. That is how you &#039;execute&#039; the shaders.<br /><br />The last type of shader is the compute shader. You set this with the CSSetShader() function. However, it is not executed during rendering. There is a special function to run a compute shader. Instead of the Draw() functions, you use the Dispatch() functions to execute compute shaders. The graphics pipeline is not used in this case. You specify input and output buffers for your compute shader, a more generalized version of the textures and render targets that you&#039;d use in rendering. There is also no fixed-function hardware in between (like with rendering, you still get &#039;automatic&#039; perspective divide, clipping, triangle setup and everything), only your shader code is executed, nothing else.<br /><br />The data you get in the blob after compiling a shader is still just bytecode. It is not native to your videocard, the bytecode will be compiled to native code by the driver. The main reason why D3D allows you access to the bytecode (unlike OpenGL/OpenCL) is to be able to pre-compile shaders. This makes them more compact, and it makes your application start more quickly, since most of the compilation is already done. There&#039;s also the benefit that you don&#039;t need to distribute the source code of your shaders.<br /><br />So what you want to do, extract values from a shader, can only be done in 2 ways:<br />1) Use a compute shader, Dispatch() it, and extract the output from the output buffer.<br />2) Set up geometry so you can execute your graphics shaders and capture the results you want in the pixels of a rendertarget. Then extract the output from the rendertarget.<br /><br />Clearly compute shaders are the nicer option.</div>
    <div class="meta">Posted on 2011-06-20 03:51:39 by Scali</div>
   </div>
   <div class="post" id="post-214501">
    <div class="subject"><a href="#post-214501">Re: How to do GPU programming using assembly?</a></div>
    <div class="body">It&#039;s also good to know that you can run Compute Shaders on DX10-capable hardware (I.E. you don&#039;t need a DX11 gfx adapter).</div>
    <div class="meta">Posted on 2011-06-23 08:07:11 by ti_mo_n</div>
   </div>
   <div class="post" id="post-214502">
    <div class="subject"><a href="#post-214502">Re: How to do GPU programming using assembly?</a></div>
    <div class="body"><div class="quote"><br />It&#039;s also good to know that you can run Compute Shaders on DX10-capable hardware (I.E. you don&#039;t need a DX11 gfx adapter).<br /></div><br /><br />To be exact: *some* DX10-capable hardware can run Compute Shaders. There are 3 versions of Compute Shaders:<br />CS4.0: DX10.0 class (GeForce 8-series and up).<br />CS4.1: DX10.1 class (Radeon 4000-series and up).<br />CS5.0: DX11 class<br /><br />They do require driver support (it&#039;s an optional feature for DX11 in DX10/DX10.1 downlevel mode. For a true DX11 device, CS support is required, so all DX11 hardware supports it). nVidia and AMD have driver support for their DX10.0/10.1 devices. Intel does not supply drivers with compute shader support (although afaik AMD only supports 4000-series and up, even though 2000 and 3000 series are also DX10.0 and DX10.1 respectively). So although their DX10+ hardware might be capable of compute shaders in theory, you cannot use them.<br />I don&#039;t have experience with other GPU brands (S3? XGI?), so I don&#039;t know if any brand other than nVidia and AMD support compute shaders in practice.<br /><br />Also, obviously you need a DX11-capable OS, so it only works on Windows 7 or Vista with SP2 and the Platform Update.</div>
    <div class="meta">Posted on 2011-06-23 10:04:46 by Scali</div>
   </div>
  </div>
 </body>
</html>