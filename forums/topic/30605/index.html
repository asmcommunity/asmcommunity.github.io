<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>code with jump is faster than code without... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30605" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=30605">code with jump is faster than code without...</a></p>
   <div class="post" id="post-214699">
    <div class="subject"><a href="#post-214699">code with jump is faster than code without...</a></div>
    <div class="body">Hi,<br /><br />I finally decided to learn some assembler, mainly to understand what my C/C++ compiler (gcc) is doing behind the scenes, and how I can improve the performance of my code.<br />One thing I&#039;ve read again and again is that jumps are bad performance-wise and should be avoided. To test that, I implemented a (rather nonsensical) example in C in two ways and looked at the assembler output from gcc. Here&#039;s the C code of the first implementation:<br /><br /><pre><code>int main()<br />{<br /><br />	int a = 0;<br />	int i = 0;<br />	int j = 0;<br />	int k = 0;<br />	<br />	for (i=0; i&lt;100000; i++)<br />	{<br />		for (j=0; j&lt;100000; j++)<br />		{<br />			k = 4;<br />			if (a != 0)<br />				k = 5;<br />		}<br />	}<br />	<br />	return 0;<br />}</code></pre><br /><br />And here&#039;s the second implementation:<br /><pre><code>int main()<br />{<br /><br />	int a = 0;<br />	int i = 0;<br />	int j = 0;<br />	int k = 0;<br />	<br />	for (i=0; i&lt;100000; i++)<br />	{<br />		for (j=0; j&lt;100000; j++)<br />		{			<br />			k = 5;<br />			if (a == 0)<br />				k = 4;<br />			<br />		}<br />	}<br />	<br />	return 0;<br />}</code></pre><br /><br />Semantically, the two are the same. The only difference is that the condition in the if clause is false in the first case, and true in the second. The corresponding assembler code created by gcc is identical except for the if-clause, obviously. For the first implementation, it is<br /><pre><code>...<br />	movl	$4, -24(%ebp)<br />	cmpl	$0, -12(%ebp)<br />	je	L6<br />	movl	$5, -24(%ebp)<br />L6:<br />	movl	$0, -28(%ebp)<br />...<br /></code></pre><br /><br />For the second implementation, the assembler code is<br /><pre><code>...<br />	movl	$5, -24(%ebp)<br />	cmpl	$0, -12(%ebp)<br />	jne	L6<br />	movl	$4, -24(%ebp)<br />L6:<br />	movl	$0, -28(%ebp)<br />...<br /></code></pre><br /><br />This means that in the first implementation the jump is executed every single time, whereas it is never executed in the second implementation (at the cost of an extra mov instruction). However, the first implementation runs significantly FASTER than the second! This would imply that the extra mov instruction of the 2nd implementation is worse than the jump... Why is that?<br /><br />I&#039;m on Mac OS X, by the way.<br /><br />Thanks,<br />Alex</div>
    <div class="meta">Posted on 2011-07-24 10:18:53 by awe</div>
   </div>
   <div class="post" id="post-214700">
    <div class="subject"><a href="#post-214700">Re: code with jump is faster than code without...</a></div>
    <div class="body">Less instructions is faster...<br />Not sure what your question is?<br />You are not sure about how a jump is executed by the CPU?<br />As long as it can predict a jump properly, it only takes a single cycle (on some CPUs it is even 0 cycles, depends on how the CPU pipeline is designed). In both cases, the jump is easy to predict, since it is always the same (it doesn&#039;t matter whether the jump is taken or not).<br />So, the fact that it can skip the mov in the second case, means it is faster.<br /><br />Problems with performance are more related to mispredictions.<br />Aside from that, a jump still takes 1 cycle, even if it is predicted properly... So if you can design your code in a way that it doesn&#039;t need the jump at all, you can save a cycle (techniques such as loop-unrolling for example, which save a number of jumps).</div>
    <div class="meta">Posted on 2011-07-24 10:37:12 by Scali</div>
   </div>
   <div class="post" id="post-214703">
    <div class="subject"><a href="#post-214703">Re: code with jump is faster than code without...</a></div>
    <div class="body">Hi Scali,<br /><br />yes, I was aware that less instructions usually means faster code. However, pretty much every assembler book I&#039;ve seen preaches that jumps should be avoided as much as possible. That made me think that jumps are much more expensive than just one clock cycle. <br />One book on performance that I&#039;ve read suggests that high-level code should be written in such a way that the more likely outcome of an if-clause should be coded first to avoid the jump in most cases. It went on to state that in some cases it might even still be faster to have two assignments if it means that the jump can be skipped. That&#039;s what I wanted to test with my second implementation.<br /><br />Out of curiosity, roughly how many clock cycles does the mov instructions take in this case?<br /><br />Thanks,a<br />Alex</div>
    <div class="meta">Posted on 2011-07-24 18:45:13 by awe</div>
   </div>
   <div class="post" id="post-214705">
    <div class="subject"><a href="#post-214705">Re: code with jump is faster than code without...</a></div>
    <div class="body">What book is that, and how old is it? Sounds like it&#039;s a bit outdated. You have to realize that CPUs are a moving target. I often see assembly programmers still using instruction sequences that were optimal for 386 CPUs back in the late 80s, but are disastrous on today&#039;s machines. Each CPU has its own optimization rules, so be sure to learn the right rules for your CPU.<br /><br />An if-clause is more than just a jump however. It&#039;s also a comparison. And again, the problem is predictability.<br /><br />Your example just has perfect predictability, so you&#039;re not measuring the cost of a mispredicted jump. If the jump would get mispredicted half the time, you&#039;d see something completely different. In your case, it&#039;s no different from an unconditional jump. The CPU just has to update the instruction pointer. That&#039;s not a very expensive operation.<br /><br />A mov from memory takes two to three cycles on most modern x86 CPUs, assuming the data is in L1-cache (which it is in your case).<br /><br />Hardly anyone writes about assembly optimizations anymore. The most up-to-date resources I know are the <a target="_blank" href="http://www.intel.com/Assets/PDF/manual/248966.pdf">Intel Optimization Manuals</a>, and <a target="_blank" href="http://www.agner.org/optimize/">Agner Fog&#039;s resources</a>. (Yes, AMD has some optimization manuals as well, but they aren&#039;t very good, it&#039;s mostly just some basic examples, without much in-depth info about the architecture).</div>
    <div class="meta">Posted on 2011-07-25 02:36:25 by Scali</div>
   </div>
   <div class="post" id="post-214706">
    <div class="subject"><a href="#post-214706">Re: code with jump is faster than code without...</a></div>
    <div class="body">With respect to conditional jumps, if you plan on hand-optimizing asm then you should be aware of branch-prediction predicates.<br />You can basically give a hint for the cpu as to which logical branch will be taken MOST of the time, and it will use that to optimize the cache.</div>
    <div class="meta">Posted on 2011-07-25 08:52:55 by Homer</div>
   </div>
   <div class="post" id="post-214740">
    <div class="subject"><a href="#post-214740">Re: code with jump is faster than code without...</a></div>
    <div class="body"><div class="quote">With respect to conditional jumps, if you plan on hand-optimizing asm then you should be aware of branch-prediction predicates.<br />You can basically give a hint for the cpu as to which logical branch will be taken MOST of the time, and it will use that to optimize the cache.</div>Do those branch hints actually make a difference for <strong>any</strong> existing CPUs? I like the idea of them, but were under the impression they didn&#039;t really mean much in the real world?</div>
    <div class="meta">Posted on 2011-07-27 14:15:36 by f0dder</div>
   </div>
   <div class="post" id="post-214741">
    <div class="subject"><a href="#post-214741">Re: code with jump is faster than code without...</a></div>
    <div class="body"><div class="quote"><br />Do those branch hints actually make a difference for <strong>any</strong> existing CPUs? I like the idea of them, but were under the impression they didn&#039;t really mean much in the real world?<br /></div><br /><br />They were introduced on the Pentium 4, if I&#039;m not mistaken?<br />No idea if Intel kept them in later CPUs, or if AMD adopted them.<br />If I recall correctly, the idea was that the &#039;cs&#039; and &#039;ds&#039; prefix byte in front of a conditional jump would force the prediction logic to predict the jump als &#039;always jump&#039; or &#039;never jump&#039;.<br />Then again, perhaps prediction has become so good that it doesn&#039;t really add much anymore.<br />I don&#039;t think I&#039;ve ever seen a compiler emit these predicates in actual code.</div>
    <div class="meta">Posted on 2011-07-27 15:52:51 by Scali</div>
   </div>
   <div class="post" id="post-214750">
    <div class="subject"><a href="#post-214750">Re: code with jump is faster than code without...</a></div>
    <div class="body">Sparc seems to rely heavily on branch prediction. I don&#039;t know whether branch prediction was a part of RISC design from the beginning or not, but I believe it has been around for awhile.<br /><br />I don&#039;t have time right now but if I remember I will try to post a some assembly output from Solaris&#039;s compiler for Sparc and we should be able to see if it uses branch prediction or not.</div>
    <div class="meta">Posted on 2011-07-28 04:51:05 by JoeCoder</div>
   </div>
   <div class="post" id="post-214751">
    <div class="subject"><a href="#post-214751">Re: code with jump is faster than code without...</a></div>
    <div class="body"><div class="quote"><br />However, pretty much every assembler book I&#039;ve seen preaches that jumps should be avoided as much as possible. That made me think that jumps are much more expensive than just one clock cycle. </div><br /><br />I don&#039;t know because I haven&#039;t seen the books you have seen but I could easily believe that kind of opinion is the result of parroting the same brainless mantra of not using GOTOs ever in code. In some HLL GOTO is appropriate, in others not. In assembly you will see how the machine works and you quickly realize jumps/branches etc. are one of the most commonly-used instructions. You have very little way of controlling program flow without explicit jumps, and on certain processors you have no way to control flow without jumps.<br /><br /><div class="quote">One book on performance that I&#039;ve read suggests that high-level code should be written in such a way that the more likely outcome of an if-clause should be coded first to avoid the jump in most cases. It went on to state that in some cases it might even still be faster to have two assignments if it means that the jump can be skipped. That&#039;s what I wanted to test with my second implementation.</div><br /><br />The whole point of a high level language and an optimizing compiler&nbsp; for that language is to free the HLL coder from having to worry about issues like how to code your program according to what&#039;s best on the machine and allow you to focus on coding the correct solution in your problem domain. If an HLL can&#039;t provide abstraction, and the compiler for that HLL can&#039;t optimize it, you may as well be coding in assembly.<br /><br /></div>
    <div class="meta">Posted on 2011-07-28 05:01:02 by JoeCoder</div>
   </div>
   <div class="post" id="post-214752">
    <div class="subject"><a href="#post-214752">Re: code with jump is faster than code without...</a></div>
    <div class="body"><div class="quote"><br />Sparc seems to rely heavily on branch prediction. I don&#039;t have time right now but if I remember I will try to post a some assembly output from Solaris&#039;s compiler for Sparc and we should be able to see if it uses branch prediction or not.<br /></div><br /><br />Well, I was talking about x86, where <strong>predication</strong> (*not* prediction) is a relatively new feature (predication being a static &#039;hint&#039; or &#039;predicate&#039; embedded in the code to tell the CPU what to expect for a given branch instruction).<br />Clearly, on CPUs where predication has been part of the instructionset for much longer, you will see compilers emitting code for them. On Itanium for example, it is quite crucial to use predication, since the CPU was not designed to do branch prediction at all. It strictly depends on the compiler to predict branches, or in the worst case, it will execute both sides of the branch in parallel (and thus at half speed), until the result of the branch is known and the incorrect side of the branch can be terminated.</div>
    <div class="meta">Posted on 2011-07-28 05:02:01 by Scali</div>
   </div>
   <div class="post" id="post-214754">
    <div class="subject"><a href="#post-214754">Re: code with jump is faster than code without...</a></div>
    <div class="body"><div class="quote"><br />I don&#039;t know because I haven&#039;t seen the books you have seen but I could easily believe that kind of opinion is the result of parroting the same brainless mantra of not using GOTOs ever in code. In some HLL GOTO is appropriate, in others not. In assembly you will see how the machine works and you quickly realize jumps/branches etc. are one of the most commonly-used instructions. You have very little way of controlling program flow without explicit jumps, and on certain processors you have no way to control flow without jumps.</div><br /><br />In fact, if you read Agner Fog&#039;s recent Sandy Bridge additions to his optimization manuals, he actually argues for MORE jumps...<br />That is, Sandy Bridge has a micro-op cache (much like the trace cache on the Pentium 4), which can cache pre-decoded x86 instructions for loops.<br />Agner Fog argues that since this cache is relatively small, you should not unroll loops. This way you can fit more into the cache, which will effectively be faster.<br />So the CPU will actually take more jumps this way.<br /><br /><div class="quote"><br />The whole point of a high level language and an optimizing compiler&nbsp; for that language is to free the HLL coder from having to worry about issues like how to code your program according to what&#039;s best on the machine and allow you to focus on coding the correct solution in your problem domain. If an HLL can&#039;t provide abstraction, and the compiler for that HLL can&#039;t optimize it, you may as well be coding in assembly.<br /></div><br /><br />Garbage in == garbage out.<br />The problem with programming languages is that they only describe the algorithms, but not the actual input and output. It does a static analysis of the code, but not a dynamic one.<br />So in most cases, a compiler cannot reasonably predict what the most likely path will be.<br />You&#039;ll need profiling of actual code at runtime to make certain optimizations to the code. And even then, it&#039;s mostly lies and statistics.<br />Take for example something like a movie encoder/decoder. The type of movie you will use to profile it, may greatly affect your profiling results. If you take an entirely black image, then it will be encoded massively differently from a movie with lots of high-frequency noise.<br />You need human intelligence and creativity for certain tasks.<br /><br />Pet-peeve of mine, people who think the compiler will solve everything, and as such, they don&#039;t even bother to think about optimization issues in the first place (which means they&#039;ll never learn).<br />So I certainly don&#039;t agree that you might as well use assembly for things the HLL doesn&#039;t solve. There are many aspects that a HLL won&#039;t solve for you, most of them have to do with developing software in general. Writing the code is just the last stage of a long and complex process. Whether you use a HLL or assembly shouldn&#039;t matter all that much. Just the last few minor details that you can tweak in assembly.</div>
    <div class="meta">Posted on 2011-07-28 05:15:04 by Scali</div>
   </div>
   <div class="post" id="post-214755">
    <div class="subject"><a href="#post-214755">Re: code with jump is faster than code without...</a></div>
    <div class="body">Solaris Studio compilers do indeed use branch prediction on Sparc. I&#039;m going to post a few fragments of the assembly and disassembly generated by Solaris Studio F95 on a Towers of Hanoi program I found on the net.<br /><br />First a piece of the assembly. You can see the branch prediction control if you look at the BLE instructions. PT means &quot;predict taken&quot;. PN means &quot;predict not taken&quot;<br /><br /><pre><code><br />			.L900000140:<br />/* 000000	&nbsp;  7 */		save	%sp,-392,%sp<br /><br />!&nbsp; &nbsp; 8		&nbsp; &nbsp; &nbsp; !&nbsp; &nbsp; &nbsp; starting_post, goal_post)<br />!&nbsp; &nbsp; 9		&nbsp; &nbsp; &nbsp; !&nbsp; <br />!&nbsp;  10		&nbsp; &nbsp; &nbsp; !&nbsp;  integer, intent (in) ::&nbsp; &amp;<br />!&nbsp;  11		&nbsp; &nbsp; &nbsp; !&nbsp;  number_of_disks, starting_post, goal_post<br />!&nbsp;  12		&nbsp; &nbsp; &nbsp; !&nbsp;  integer :: free_post<br />!&nbsp;  13		&nbsp; &nbsp; &nbsp; !&nbsp;  ! all_posts is the sum of the post values 1+2+3<br />!&nbsp;  14		&nbsp; &nbsp; &nbsp; !&nbsp;  ! so that the free post can be determined<br />!&nbsp;  15		&nbsp; &nbsp; &nbsp; !&nbsp;  ! by subtracting the starting_post and the<br />!&nbsp;  16		&nbsp; &nbsp; &nbsp; !&nbsp;  ! goal_post from this sum.<br />!&nbsp;  17		&nbsp; &nbsp; &nbsp; !&nbsp;  integer, parameter :: all_posts = 6<br />!&nbsp;  18		&nbsp; &nbsp; &nbsp; ! <br />!&nbsp;  19		&nbsp; &nbsp; &nbsp; !&nbsp;  if (number_of_disks &gt; 0) then<br /><br />/* 0x0004	&nbsp; 19 */		ld	[%i0],%l7<br />/* 0x0008	&nbsp; &nbsp;  */		cmp	%l7,0<br />/* 0x000c	&nbsp; &nbsp;  */		ble,pn	%icc,.L77000046<br /><br />!&nbsp;  20		&nbsp; &nbsp; &nbsp; !&nbsp; &nbsp; &nbsp; free_post =&nbsp; &amp;<br /><br />/* 0x0010	&nbsp; 20 */		or	%g0,6,%l1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />! predecessor blocks: .L900000140<br /><br />			.L77000041:<br />/* 0x0014	&nbsp; 20 */		ld	[%i2],%l5<br />/* 0x0018	&nbsp; &nbsp;  */		ld	[%i1],%l6<br /><br />!&nbsp;  21		&nbsp; &nbsp; &nbsp; !&nbsp; &nbsp; &nbsp; all_posts - starting_post - goal_post<br />!&nbsp;  22		&nbsp; &nbsp; &nbsp; !&nbsp; &nbsp; &nbsp; call hanoi (number_of_disks - 1,&nbsp; &amp;<br /><br />/* 0x001c	&nbsp; 22 */		add	%l7,-1,%l2<br />/* 0x0020	&nbsp;  0 */		sethi	%hi(hanoi_module.hanoi.STR$4),%i4<br />/* 0x0024	&nbsp; 20 */		sub	%l1,%l5,%l0<br />/* 0x0028	&nbsp;  0 */		add	%i4,%lo(hanoi_module.hanoi.STR$4),%i4<br />/* 0x002c	&nbsp; 20 */		sub	%l0,%l6,%l4<br />/* 0x0030	&nbsp; 19 */		cmp	%l2,0<br />/* 0x0034	&nbsp; &nbsp;  */		ble,pn	%icc,.L77000057<br />/* 0x0038	&nbsp; 20 */		st	%l4,[%fp-16]<br /><br />! Registers live out of .L77000041: <br />! o0 sp l1 l2 l4 l5 l6 l7 i0 i1 i2 i4 fp i7 gsr <br />! <br />		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />! predecessor blocks: .L77000041<br /><br />			.L77000050:<br />/* 0x003c	&nbsp; 20 */		add	%l4,%l6,%o5<br />/* 0x0040	&nbsp; 22 */		add	%l7,-2,%i5<br />/* 0x0044	&nbsp; 20 */		sub	%l1,%o5,%l3<br />/* 0x0048	&nbsp; 22 */		sllx	%i5,32,%o3<br />/* 0x004c	&nbsp; &nbsp;  */		srl	%l3,0,%o4<br />/* 0x0050	&nbsp; &nbsp;  */		add	%fp,-44,%o2<br />/* 0x0054	&nbsp; &nbsp;  */		or	%o3,%o4,%o0<br />/* 0x0058	&nbsp; &nbsp;  */		stx	%o0,[%fp-48]<br />/* 0x005c	&nbsp; &nbsp;  */		or	%g0,%i1,%o1<br />/* 0x0060	&nbsp; &nbsp;  */		call	hanoi_module.hanoi_	! params =&nbsp; %o0 %o1 %o2	! Result = <br />/* 0x0064	&nbsp; &nbsp;  */		add	%fp,-48,%o0<br /><br />/* 0x0214	&nbsp; &nbsp;  */		call	__f90_slw_ch	! params =&nbsp; %o0 %o1 %o2	! Result = <br />/* 0x0218	&nbsp; &nbsp;  */		add	%fp,-112,%o0<br />/* 0x021c	&nbsp; &nbsp;  */		ld	[%i2],%l5<br />/* 0x0220	&nbsp; &nbsp;  */		add	%fp,-112,%o0<br />/* 0x0224	&nbsp; &nbsp;  */		call	__f90_slw_i4	! params =&nbsp; %o0 %o1	! Result = <br />/* 0x0228	&nbsp; &nbsp;  */		or	%g0,%l5,%o1<br />/* 0x022c	&nbsp; &nbsp;  */		call	__f90_eslw	! params =&nbsp; %o0	! Result = <br />/* 0x0230	&nbsp; &nbsp;  */		add	%fp,-112,%o0<br />/* 0x0234	&nbsp; 19 */		cmp	%i3,0<br />/* 0x0238	&nbsp; &nbsp;  */		ble,pt	%icc,.L77000046<br />/* 0x023c	&nbsp; &nbsp;  */		nop<br /></code></pre><br /><br />Now here&#039;s a piece of disassembly. I should have lined up both these pieces but I just wanted to show the different instructions generated for BLE,PT and BLE,PN.<br /><br /><pre><code><br />hanoi_module.hanoi_()<br />&nbsp; &nbsp; hanoi_module.hanoi_:&nbsp; &nbsp; &nbsp;  9d e3 be 78&nbsp; save&nbsp; &nbsp; &nbsp; %sp, -0x188, %sp<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x4:&nbsp;  ee 06 20 00&nbsp; ld&nbsp; &nbsp; &nbsp; &nbsp; [%i0], %l7<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x8:&nbsp;  80 a5 e0 00&nbsp; cmp&nbsp; &nbsp; &nbsp;  %l7, 0x0<br />&nbsp; &nbsp; hanoi_module.hanoi_+0xc:&nbsp;  04 40 00 ba&nbsp; ble,pn&nbsp; &nbsp; %icc, +0x2e8&nbsp; &lt;hanoi_module.hanoi_+0x2f4&gt;<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x10:&nbsp; a2 10 20 06&nbsp; mov&nbsp; &nbsp; &nbsp;  0x6, %l1<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x14:&nbsp; ea 06 a0 00&nbsp; ld&nbsp; &nbsp; &nbsp; &nbsp; [%i2], %l5<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x18:&nbsp; ec 06 60 00&nbsp; ld&nbsp; &nbsp; &nbsp; &nbsp; [%i1], %l6<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x1c:&nbsp; a4 05 ff ff&nbsp; add&nbsp; &nbsp; &nbsp;  %l7, -0x1, %l2<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x20:&nbsp; 39 00 00 6d&nbsp; sethi&nbsp; &nbsp;  %hi(0x1b400), %i4<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x24:&nbsp; a0 24 40 15&nbsp; sub&nbsp; &nbsp; &nbsp;  %l1, %l5, %l0<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x28:&nbsp; b8 07 23 60&nbsp; add&nbsp; &nbsp; &nbsp;  %i4, 0x360, %i4<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x2c:&nbsp; a8 24 00 16&nbsp; sub&nbsp; &nbsp; &nbsp;  %l0, %l6, %l4<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x30:&nbsp; 80 a4 a0 00&nbsp; cmp&nbsp; &nbsp; &nbsp;  %l2, 0x0<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x34:&nbsp; 04 40 00 37&nbsp; ble,pn&nbsp; &nbsp; %icc, +0xdc&nbsp;  &lt;hanoi_module.hanoi_+0x110&gt;<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x38:&nbsp; e8 27 bf f0&nbsp; st&nbsp; &nbsp; &nbsp; &nbsp; %l4, [%fp - 0x10]<br /><br />&nbsp; &nbsp; hanoi_module.hanoi_+0x218: 90 07 bf 90&nbsp; add&nbsp; &nbsp; &nbsp;  %fp, -0x70, %o0<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x21c: ea 06 a0 00&nbsp; ld&nbsp; &nbsp; &nbsp; &nbsp; [%i2], %l5<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x220: 90 07 bf 90&nbsp; add&nbsp; &nbsp; &nbsp;  %fp, -0x70, %o0<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x224: 40 01 1a a9&nbsp; call&nbsp; &nbsp; &nbsp; +0x46aa4&nbsp; &nbsp; &nbsp; &lt;__f90_slw_i4&gt;<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x228: 92 10 00 15&nbsp; mov&nbsp; &nbsp; &nbsp;  %l5, %o1<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x22c: 40 01 1a aa&nbsp; call&nbsp; &nbsp; &nbsp; +0x46aa8&nbsp; &nbsp; &nbsp; &lt;__f90_eslw&gt;<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x230: 90 07 bf 90&nbsp; add&nbsp; &nbsp; &nbsp;  %fp, -0x70, %o0<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x234: 80 a6 e0 00&nbsp; cmp&nbsp; &nbsp; &nbsp;  %i3, 0x0<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x238: 04 48 00 2f&nbsp; ble,pt&nbsp; &nbsp; %icc, +0xbc&nbsp;  &lt;hanoi_module.hanoi_+0x2f4&gt;<br />&nbsp; &nbsp; hanoi_module.hanoi_+0x23c: 01 00 00 00&nbsp; nop<br /></code></pre></div>
    <div class="meta">Posted on 2011-07-28 06:54:23 by JoeCoder</div>
   </div>
   <div class="post" id="post-214773">
    <div class="subject"><a href="#post-214773">Re: code with jump is faster than code without...</a></div>
    <div class="body">Oh, by the way... there&#039;s a more basic kind of &#039;predication&#039; that x86 processors have been using since... the classic Pentium I believe.<br />Quite simply: If the target address for a conditional jump is lower than the current address, predict that the jump will be taken, else predict that it will not be taken.<br /><br />The basic idea for that is simple: It is the structure for a loop (jump back N times, until the loop is finished, then fall through). This way a loop will have at most one bad prediction: at the last iteration.<br />So when you build conditional jumps, you can place the jump target either above or below your jump, depending on whether you think the most common case is to take the jump or not.</div>
    <div class="meta">Posted on 2011-07-30 11:43:50 by Scali</div>
   </div>
  </div>
 </body>
</html>