<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>assembler for linux? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25376" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25376">assembler for linux?</a></p>
   <div class="post" id="post-185552">
    <div class="subject"><a href="#post-185552">assembler for linux?</a></div>
    <div class="body">i plan on starting to use assembly in linux; and i&#39;m struggling in choose which assembler.&nbsp; I see fasm, nasm have linux support.&nbsp; Which of these would be a good choice under linux? It doesnt seem like nasm is being updated much anymore but it is still widely used. Fasm is getting updates and there is a little more support for it.&nbsp; What are your opinions?&nbsp; Which other assemblers are good under a linux platform?&nbsp; <br /><br />Would the syntax be the same on a windows&nbsp; and linux platform for nasm/fasm; just a different layout for each binary?</div>
    <div class="meta">Posted on 2006-09-26 20:40:16 by Macleon</div>
   </div>
   <div class="post" id="post-185553">
    <div class="subject"><a href="#post-185553">Re: assembler for linux?</a></div>
    <div class="body">FASM is still been developed and supports 64-bit. NASM supports 16 and 32-bit modes, but not 64-bit mode. NASM has more or less reached its design goal as an assembler for some time now, so it has been in &quot;maintenance status&quot; (bug fixes) ever since.<br /><br />Both are open-source. FASM is written in FASM (self-assembles, but pretty much locked to running on the x86). NASM is written in C, and designed to be portable, which is why it is still widely used.<br /><br /><a target="_blank" href="http://www.tortall.net/projects/yasm/"><u>YASM</u></a> is another assembler that you might be interested in. It is suppose to pick-up where NASM left-off. YASM supports NASM syntax, GAS (AT&amp;T) syntax and 64-bit Long Mode.<br /><br />As for the differences between Windows and Linux, as long as you are dealing with 32-bit Protected Mode or 64-bit Long Mode, there is not much difference. API calls work generally the same, they just do different things and have different effects on the system. The syntax has more to do with the x86 architecture than the platform it runs on.<br /><br />As for my personal opinion. I&#39;ve dealt with both FASM and NASM, and I tend to favor NASM as the syntax and macro facilities make more sense to me (simple, yet powerful). I also tend to favor NASM because the documentation supporting it is clear, concise... and abundant :P<br /><br />You&#39;ll have to figure out which syntax you like and go with NASM/YASM or FASM. You can also take a look at <a target="_blank" href="http://asm.sourceforge.net/"><u>THIS LINK</u></a> for tutorials and pointers on ASM under Linux.<br /><br />Have fun :)</div>
    <div class="meta">Posted on 2006-09-26 21:16:15 by SpooK</div>
   </div>
   <div class="post" id="post-185555">
    <div class="subject"><a href="#post-185555">Re: assembler for linux?</a></div>
    <div class="body">oh that seems good; since yasm is similiar to nasm, will the same syntax used in nasm work in yasm? so i would be able to assemble any nasm scripts in yasm.</div>
    <div class="meta">Posted on 2006-09-26 21:34:30 by Macleon</div>
   </div>
   <div class="post" id="post-185556">
    <div class="subject"><a href="#post-185556">Re: assembler for linux?</a></div>
    <div class="body">With exception of 64-bit instructions, yes.<br /><br />As for the rest, YASM&#39;s homepage explains it all ;)</div>
    <div class="meta">Posted on 2006-09-26 21:45:29 by SpooK</div>
   </div>
   <div class="post" id="post-185562">
    <div class="subject"><a href="#post-185562">Re: assembler for linux?</a></div>
    <div class="body">might i know what of NASM syntax makes more sense than in FASM to you?<br /><br />I can take it about macrosyntax, it&#39;s &quot;senseness&quot; is matter of opinion. To me, all macrofeatures of FASM are really simple, the hard thing is how to combine them. Unfortunatelly i haven&#39;t dealt with NASM macrosyntax to compare.<br /><br />and, until i see NASM macro to encrypt part of resulting binary with RSA, i consider FASM&#39;s macrosystem at least more powerful</div>
    <div class="meta">Posted on 2006-09-27 05:00:08 by vid</div>
   </div>
   <div class="post" id="post-185569">
    <div class="subject"><a href="#post-185569">Re: assembler for linux?</a></div>
    <div class="body">FASM&#39;s macro power was never in question, this is a natural attribute of any complex tool.<br /><br />As for &quot;makes more sense to me&quot;, it is just that in general... something that clicks with *me* and makes me more comfortable using.<br /><br />I&#39;ve dealt with FASM&#39;s macro syntax and capabilities when I was designing an include file for FASM support in the Win32ASM Project. Although I began to understand how powerful it was, it didn&#39;t help because I still didn&#39;t like it. NASM has the right level of complexity for me.<br /><br /><table><br /><tr><td>MASM</td><td>vs.</td><td>TASM</td><td>vs.</td><td>NASM</td><td>vs.</td><td>FASM</td></tr><br /><tr><td>Pepsi</td><td>vs.</td><td>Shasta</td><td>vs.</td><td>Coke</td><td>vs.</td><td>RC Cola</td></tr><br /><tr><td>Intel</td><td>vs.</td><td>3DFX</td><td>vs.</td><td>nVidia</td><td>vs.</td><td>ATI</td></tr><br /></table><br /><br />I wouldn&#39;t dive into any philosophical debate as to why. It is as simple as &quot;personal taste&quot; ;)</div>
    <div class="meta">Posted on 2006-09-27 13:54:22 by SpooK</div>
   </div>
   <div class="post" id="post-185570">
    <div class="subject"><a href="#post-185570">Re: assembler for linux?</a></div>
    <div class="body">just a detail: was you dealing with it when it had nested macros using fix? like<br /><br />macro a {<br /> macro b m_<br />&nbsp;  blabla<br /> _m<br />}<br />m_ fix {<br />_m fix }<br /><br />because that WAS real hell, fortunatelly we conviced tomasz (nicer version: tomasz realized) that it&#39;s not good approach.<br /><br />Now it is much clearer</div>
    <div class="meta">Posted on 2006-09-27 15:17:12 by vid</div>
   </div>
   <div class="post" id="post-185572">
    <div class="subject"><a href="#post-185572">Re: assembler for linux?</a></div>
    <div class="body">I&#39;m a bit mixed wrt. FASM&#39;s macro system.<br /><br />It clearly is very poweful, and I like it&#39;s use of curly brackets... but the whole &#39;equ&#39; vs. &#39;=&#39; vs. &#39;fix&#39; can be a bit confusing, and the system does seem a bit &quot;ad hoc&quot;. I also miss masm-style EXITM in fasm and nasm macros, it sometimes means that instead of writing functionality once, you need to build it into various things.<br /></div>
    <div class="meta">Posted on 2006-09-27 16:49:43 by f0dder</div>
   </div>
   <div class="post" id="post-185573">
    <div class="subject"><a href="#post-185573">Re: assembler for linux?</a></div>
    <div class="body"><div class="quote">until i see NASM macro to encrypt part of resulting binary with RSA, i consider FASM&#39;s macrosystem at least more powerful</div><br /><br />I personally don&#39;t have the time to code it, but it can be done in NASM. The NASM %ASSIGN directive allows you to preform algorithmic computations. I&#39;m sure it would be a very complex project, but I don&#39;t see any reason why it couldn&#39;t be done. For example, there is a macro for NASM which can calculate Win32 symbol hashes, shown below.<br /><br /><pre><code>; HASH - NASM macro for calculating win32 symbol hashes<br />; Author - Anonymous<br />; Usage: HASH instruction, &#39;SymbolName&#39;<br />;<br />%macro HASH 2<br />&nbsp; &nbsp; &nbsp; %assign i 1&nbsp;  ; i = 1<br />&nbsp; &nbsp; &nbsp; %assign h 0&nbsp;  ; h = 0<br />&nbsp; &nbsp; &nbsp; %strlen len %2&nbsp;  ; len = strlen(%2)<br />&nbsp; &nbsp; &nbsp; %rep len<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  %substr char %2 i ; fetch next character<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  %assign h \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (h&lt;&lt;0x13) + \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  (h&gt;&gt;0x0d) + \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  char&nbsp; ; rotate and add<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  %assign i i+1&nbsp; ; increment i<br />&nbsp; &nbsp; &nbsp; %endrep<br />&nbsp; &nbsp; &nbsp; %1 h&nbsp; &nbsp; ; return instruction with hash<br />%endmacro</code></pre><br /><br /><pre><code><br />;<br />; Examples:<br />; <br /> <br />HASH push, &#39;LoadLibraryA&#39;&nbsp; ; push dword 0xec0e4e8e<br />HASH {mov eax,}, &#39;LoadLibraryA&#39;&nbsp; ; mov eax,0xec0e4e8e<br />HASH dd, &#39;LoadLibraryA&#39;&nbsp;  ; dd 0xec0e4e8e<br />HASH dd, &#39;ExitProcess&#39;&nbsp;  ; dd 0x73e2d87e</code></pre><br /><br />This code was designed for the newer versions of NASM which support %strlen and %substr.<br /><br />Regards,<br />Bryant Keller</div>
    <div class="meta">Posted on 2006-09-27 17:46:36 by Synfire</div>
   </div>
   <div class="post" id="post-185575">
    <div class="subject"><a href="#post-185575">Re: assembler for linux?</a></div>
    <div class="body"><strong>Synfire:</strong> that functionality would still have been prettier in MASM though, because of EXITM. It&#39;s a shame that FASM and NASM macrosystems weren&#39;t built from the start to support that, since it&#39;s a very powerful feature.<br /><br />Oh, and stuff like crypting output (FASM) will only work if you output directly to PE, as far as I can tell. But it does show that fasm can do some &quot;pretty cute stuff&quot;. It&#39;s the natural choice for the init stubs of my packer/crypter :)<br /></div>
    <div class="meta">Posted on 2006-09-27 17:58:41 by f0dder</div>
   </div>
   <div class="post" id="post-185581">
    <div class="subject"><a href="#post-185581">Re: assembler for linux?</a></div>
    <div class="body">I agree, EXITM would be a great addition to NASM.</div>
    <div class="meta">Posted on 2006-09-27 21:32:43 by Synfire</div>
   </div>
   <div class="post" id="post-185582">
    <div class="subject"><a href="#post-185582">Re: assembler for linux?</a></div>
    <div class="body">From what i know, inline macros are only MASM&#39;s non-subjective advantage against FASM. Even tomasz grysztar agreed it is &quot;problem&quot; of FASM philosophy. I still believe it could be supported, but it wouldn&#39;t be very clear to FASM logic... i believe it is not clean in MASM too. Even MASM philosophy, which allows this, can on other side be confusing, because you don&#39;t have preprocessing and assembling clearly separated.<br /><br />about &quot;=&quot; vs. &quot;equ&quot; vs. &quot;fix&quot;... i don&#39;t see no confusion. there was some with &quot;equ&quot; vs. &quot;fix&quot; some time ago, but not now. all &quot;fix&quot;es are replaced before doing anything else. This can be called pre-preprocessing. &quot;fix&quot; is used to alternate macro syntax, for example if you don&#39;t like word <strong>macro</strong> and you like <strong>%define</strong>, you can change all <strong>%define</strong>s to macros. Now, &quot;fix&quot; is just a thingy to alter macro syntax, not really useful...<br /><br />After that, eg. after everything is &quot;fix&quot;ed, comes preprocessing stage. Here, &quot;equ&quot; takes effect. After some equation is defined (like <strong>a equ 123</strong>), any &quot;a&quot; symbol (that is not part of command for preprocessor), will be replaced. Here can be some confusion with &quot;that is not part of command for preprocessor&quot;, but this cannot be avoided. How is it with replacing equates inside preprocessor commands (like macro definition) in MASM?<br /><br />&quot;=&quot; is assembly time and doesn&#39;t cause any trouble against &quot;equ&quot;. This is much more confusing in MASM, where &quot;a equ 3+b&quot; can be defintion of both numeric constant (always &quot;=&quot; in FASM) or textual substition (always &quot;equ&quot; in FASM), depending on whether right side is computable, so <pre><code>a equ 3+b<br />b equ 3<br />dd a*5 ;gives 3+b*5, evaluated to 18</code></pre><br />and <pre><code>b equ 3<br />a equ 3+b ;evaluates to 6<br />dd a*5 ;gives a*5, evaluated to 30</code></pre><br />and you also have no way to define textual substition for expression that is computable.<br /><br />And more to FASM over MASM, you have macro overloading opposed to recursive macro, which is a great advantage. You can create recursive macros with overloading, but not vice versa. And when you want to &quot;extend&quot; instruction functionality in MASM, you have to assemble it yourself... MazeGen could tell...<br /><br />PS: sorry if my knowledge of MASM if wrong, i know this from discussion with others, not from my personal experience, so i am not sure if things work the way i say...</div>
    <div class="meta">Posted on 2006-09-28 02:07:14 by vid</div>
   </div>
  </div>
 </body>
</html>