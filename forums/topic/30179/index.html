<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Filter in AT&amp;T syntax with AS and LD - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30179" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=117">Unix</a> &raquo; <a href="../?id=30179">Filter in AT&amp;T syntax with AS and LD</a></p>
   <div class="post" id="post-212834">
    <div class="subject"><a href="#post-212834">Filter in AT&amp;T syntax with AS and LD</a></div>
    <div class="body">If someone is interested, here is the source code for a small Linux filter, written in AT&amp;T syntax.<br /><br /><pre><code><br />#File: lower2upper.s<br />#Build the running application at the command line with:<br />#<br />#	as -o lower2upper.o lower2upper.s<br />#	ld -o lower2upper lower2upper.o<br />#<br />#	With:<br />#<br />#	./ lower2upper lower2upper.s upper.new<br /># <br />#	at the command line, you&#039;ll find upper.new, an uppercase version of your original source file.<br /><br />	.globl	_start<br /><br />	#Constants<br /><br />	.equ	SYS_EXIT,1<br />	.equ	SYS_READ,3<br />	.equ	SYS_WRITE,4<br />	.equ	SYS_OPEN,5<br />	.equ	SYS_CLOSE,6<br />	.equ	LINUX_SYSCALL,0x80<br />	.equ	O_RDONLY,0<br />	.equ	O_CREAT_WRONLY_TRUNC,03101<br />	.equ	STDIN,0<br />	.equ	STDOUT,1<br />	.equ	STDERR,2<br />	.equ	END_OF_FILE,0<br />	.equ	NUMBER_ARGUMENTS,2<br /><br />	.section .bss<br /><br />	.equ	BUFFER_SIZE,500<br />	.lcomm	BUFFER_DATA,BUFFER_SIZE<br /><br />	.section .text<br /><br />	#STACK POSITIONS<br /><br />	.equ	ST_SIZE_RESERVE,8<br />	.equ	ST_FD_IN,-4<br />	.equ	ST_FD_OUT,-8<br />	.equ	ST_ARGC,0 		#Number of arguments<br />	.equ	ST_ARGV_0,4 		#program name<br />	.equ	ST_ARGV_1,8		#Input file name<br />	.equ	ST_ARGV_2,12		#Output file name<br /><br />_start:<br /><br />	movl	%esp,%ebp		#save stack pointer<br />	subl	$ST_SIZE_RESERVE,%esp	#space for file descriptors<br /><br />	#open input file<br /><br />	movl	$SYS_OPEN,%eax		#eax = open syscall<br />	movl	ST_ARGV_1(%ebp),%ebx	#ebx = input file handle<br />	movl	$O_RDONLY,%ecx		#ecx = read only flag<br />	movl	$0666,%edx		#doesnâ€™t really matter for reading	<br />	int	$LINUX_SYSCALL		#transfer to kernel<br />	movl	%eax,ST_FD_IN(%ebp)	#save file descriptor<br /><br />	#open output file<br /><br />	movl 	$SYS_OPEN,%eax		#eax = open syscall<br />	movl	ST_ARGV_2(%ebp),%ebx	#ebx = output file handle<br />	movl	$O_CREAT_WRONLY_TRUNC,%ecx<br />	movl	$0666,%edx		#create new file<br />	int	$LINUX_SYSCALL		#transfer to kernel<br />	movl 	%eax,ST_FD_OUT(%ebp)	#store file descriptor<br /><br />read_loop_begin:<br /><br />	movl	$SYS_READ,%eax		#read block from input file<br />	movl	ST_FD_IN(%ebp),%ebx	#ebx = input file descriptor<br />	movl	$BUFFER_DATA,%ecx	#ecx = read position<br />	movl	$BUFFER_SIZE,%edx	#edx = buffer size<br />	int	$LINUX_SYSCALL		#transfer to kernel<br />	cmpl	$END_OF_FILE,%eax	#end of file reached?<br />	jle	end_loop		#yes: jump<br /><br />continue_read_loop:<br /><br />	#no: convert the block to upper case<br /><br />	pushl	$BUFFER_DATA		#buffer location<br />	pushl	%eax			#buffer size<br />	call	convert_to_upper	<br />	popl	%eax			#restore buffer size<br />	addl	$4,%esp			#adjust stack<br /><br />	#write block to output file<br /><br />	movl	%eax,%edx		#edx = buffer size<br />	movl	$SYS_WRITE,%eax<br />	movl	ST_FD_OUT(%ebp),%ebx	#ebx = file descriptor<br />	movl	$BUFFER_DATA,%ecx	#ecx = write position<br />	int	$LINUX_SYSCALL		#transfer to kernel<br />	jmp	read_loop_begin		#continue read/write loop<br /><br />end_loop:<br /><br />	#close output file<br /><br />	movl	$SYS_CLOSE,%eax<br />	movl	ST_FD_OUT(%ebp),%ebx<br />	int	$LINUX_SYSCALL		#transfer to kernel<br /><br />	#close input file<br /><br />	movl	$SYS_CLOSE,%eax<br />	movl	ST_FD_IN(%ebp),%ebx<br />	int	$LINUX_SYSCALL		#transfer to kernel<br /><br />	#terminate<br /><br />	addl	$ST_SIZE_RESERVE,%esp<br />	movl	$SYS_EXIT,%eax<br />	movl	$0,%ebx<br />	int	$LINUX_SYSCALL		#transfer to kernel<br /><br /><br />#convert_to_upper<br />#Task:		Convert a block to upper case.<br />#Input:		&nbsp; = buffer length<br />#		 = buffer<br />#Output:	Function overwrites the current buffer with upper-cassified version.<br /><br />	#constants<br /><br />	.equ 	LOWERCASE_A,&#039;a&#039;		#lower search boundary<br />	.equ	LOWERCASE_Z,&#039;z&#039;		#upper search boundary<br />	.equ	UPPER_CONVERSION,&#039;A&#039; - &#039;a&#039;<br />	.equ	ST_BUFFER_LEN,8 	#buffer length<br /> 	.equ	ST_BUFFER,12 		#actual buffer<br /><br />convert_to_upper:<br /><br />	pushl	%ebp<br />	movl	%esp,%ebp<br />	movl	ST_BUFFER(%ebp),%eax	#eax = actual buffer<br />	movl	ST_BUFFER_LEN(%ebp),%ebx#ebx = buffer length<br />	movl	$0,%edi			#edi = current buffer offset<br />	cmpl	$0,%ebx			#buffer length = 0?<br />	je	end_convert_loop	#yes: jump<br /><br />convert_loop:<br /><br />	movb	(%eax,%edi,1),%cl	#no: get current byte<br /><br />	#go to the next byte unless it is between &#039;a&#039; and &#039;z&#039;<br /><br />	cmpb	$LOWERCASE_A,%cl<br />	jl	next_byte<br />	cmpb	$LOWERCASE_Z,%cl<br />	jg	next_byte<br /><br />	#otherwise convert the byte to uppercase<br /><br />	addb	$UPPER_CONVERSION,%cl<br />	movb	%cl,(%eax,%edi,1)	#store it back<br /><br />next_byte:<br /><br />	incl	%edi 			#next byte<br />	cmpl	%edi,%ebx		#end reached?<br />	jne	convert_loop		#no: play it again<br /><br />end_convert_loop:<br /><br />	popl	%ebp			#yes: back to caller<br />	ret<br /></code></pre> <br /><br />It&#039;s only an easy example, to show the principle by using <strong>as</strong> and <strong>ld</strong> for building a complete assembly language application. Nothing special. The program doesn&#039;t make any error detection for the system calls, but should run correct under x86 based 32 bit Linux.<br /><br />Gunther<br /> <br /><br /></div>
    <div class="meta">Posted on 2010-08-19 18:02:16 by Gunther</div>
   </div>
  </div>
 </body>
</html>