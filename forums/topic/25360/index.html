<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>zep2 simulator - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25360" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25360">zep2 simulator</a></p>
   <div class="post" id="post-185421">
    <div class="subject"><a href="#post-185421">zep2 simulator</a></div>
    <div class="body">Hello, i&#39;ve just started with learning ASM at school, which is fun and all, only the down side is, is that we use a simulator for our ASM code and we dont use it on a real processor like Intel (80x86).<br />The simulator is called &quot;Zep2 Proccesor simulator&quot;, i dont think anyone here ever heard about it. I think its only used here, in the netherlands, thats where im from.<br /><br />But we are also allowed to use ASM for the 80x86 processor, so i&#39;ve choosed to do that, but all i need to do now is to port the code that i have for the Zep2 simulator to MASM code. And thats where i need a little help.<br /><br />I&#39;ll show you a piece of code that the Zep2 uses and ill try to explain what it does, R1 and R2 are&nbsp; the only registers that are availible.<br /><br /><br /><pre><code><br />##<br /><br />begin load R2, -2;&nbsp; //laad R2 met -2 -&gt; Load R2 with -2<br /><br />&nbsp; &nbsp; &nbsp; load R1,R2;&nbsp;  //inhoud R2 naar R1 -&gt; content of R2 to R1<br /><br />&nbsp; &nbsp; &nbsp; inc R1;&nbsp; &nbsp; &nbsp;  //tel 1 op bij inhoud R1 -&gt; add +1 to R1<br /><br />&nbsp; &nbsp; &nbsp; store R1,0xf; //bewaar inhoud R1 op adres 0xf -&gt; Save content of R1 to address 0xf<br /><br />&nbsp; &nbsp; &nbsp; nop;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //doe niets (no operation) -&gt; no operation<br /><br />&nbsp; &nbsp; &nbsp; halt;&nbsp; &nbsp; &nbsp; &nbsp; //end of program..?<br /><br />## <br /></code></pre><br /><br />Dutch comment on the left (you can ignore that), english comment on the right.<br />Now this is a program we had to write, nothing special as you can see.<br />But i wanted to change this code so it can be assembled with a MASM compiler.<br />Im not sure but i think the &#39;load&#39; command here is the equivalent of &#39;mov&#39; in &#39;real&#39; ASM.<br /><br />So my question is, how would this piece of code look like if it was written with MASM...???</div>
    <div class="meta">Posted on 2006-09-21 13:35:28 by vivendi</div>
   </div>
   <div class="post" id="post-185422">
    <div class="subject"><a href="#post-185422">Re: zep2 simulator</a></div>
    <div class="body">Here is a direct translation of instructions... but please note that program logic will not follow while using an actual OS like Windows.<br /><br /><pre><code><br />;EAX replaces R1<br />;EBX replaces R2<br /><br />; begin load R2, -2;&nbsp; //laad R2 met -2 -&gt; Load R2 with -2<br />mov ebx, -2<br /><br />; load R1,R2;&nbsp;  //inhoud R2 naar R1 -&gt; content of R2 to R1<br />mov eax,ebx<br /><br />; inc R1;&nbsp; &nbsp; &nbsp;  //tel 1 op bij inhoud R1 -&gt; add +1 to R1<br />inc eax<br /><br />; store R1,0xf; //bewaar inhoud R1 op adres 0xf -&gt; Save content of R1 to address 0xf<br />mov dword addr [0xf],eax<br /><br />; nop;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //doe niets (no operation) -&gt; no operation<br />nop<br /><br />;halt;&nbsp; &nbsp; &nbsp; &nbsp; //end of program..?<br />hlt<br /></code></pre><br /><br />If you were to copy this flat binary output to a floppy disk (make it bootable) and boot it, that is about as close as you could get with that processor simulator.<br /><br />Since you want to use MASM, I will have to assume you wish to program under DOS/Win32. In that case, accessing memory address of &quot;0xf&quot; won&#39;t mean much of anything... and might actually cause the program to crash.<br /><br />As you can see, &quot;mov&quot; covers the loading of immediate values and data by referencing memory address values. So in this case, &quot;mov&quot; replaces &quot;load&quot; and &quot;store&quot;, but the MASM does the work in translating those instructions to the needed opcodes.<br /><br />Finally, &quot;hlt&quot; is not guaranteed to work and not recommended. I would suggest simply returning (&quot;ret&quot;) from the program to end it (Win32 API or DOS COM File).<br /><br />PS: Please clarify that the &quot;load&quot; and &quot;store&quot; instructions operate as you indicated, because &quot;load&quot; (load destination,source) works opposite of &quot;store&quot; (store source,destination) if that is the case... which is unusual and might create confusion when working with Intel-based ASM syntax.</div>
    <div class="meta">Posted on 2006-09-21 15:15:02 by SpooK</div>
   </div>
   <div class="post" id="post-185424">
    <div class="subject"><a href="#post-185424">Re: zep2 simulator</a></div>
    <div class="body">Thanks alot for the useful explanation and code :)<br />And indeed the line where it has to place the value in a memory address fails.<br />I gives me this error:<br /><br /><div class="quote"><br />error A2008: syntax error : addr<br /></div><br /><br />But besides that (like you already said) i dont think 0xf is a real memory address in Windows, is it?<br />What would be a real memory address that i could place data in..??</div>
    <div class="meta">Posted on 2006-09-21 16:23:51 by vivendi</div>
   </div>
   <div class="post" id="post-185427">
    <div class="subject"><a href="#post-185427">Re: zep2 simulator</a></div>
    <div class="body">My MASM is a little rusty. It should be along the lines of &quot;mov dword ptr[0x0f]&quot;. So that is &quot;dword ptr&quot; and <strong>not</strong> &quot;dword addr&quot;.<br /><br />0x0F is a real address in that it exists. With Paging enabled, 0x0F (0x0000000F since we are talking about 32-bit addressing) could be a virtual address that points to any part of physical RAM (or not pointed at all, which would cause a Page Fault). Read up on the paging mechanism to understand how this works.<br /><br />When you have pre-established APIs and modern-day assemblers, like DOS INTs or the Win32 API provided by the underlying OS along with MASM, you rarely address memory directly (unless you know *exactly* what you are doing). Memory is usually addressed through the use of labels and pointers.<br /><br />Example of addressing a label...<br /><br /><pre><code><br />.data<br />my_variable dd 0 ;A DWORD variable in memory<br /><br />.code<br />mov dword ptr, eax ;Store value of EAX to address indicated by my_variable label<br />;IN MASM, the above instruction can also be like this...<br />mov my_variable, eax<br /></code></pre><br /><br />Labels are calculated at the time of assembly, and thus all labels are replaced with real/virtual addresses that the program is &quot;expecting&quot;. MASM is C-like in that when you address a label, it treats it as if you are accessing the value held at the address of that label, and not the label itself... which is why that second instruction example also works (MASM masks the extra work for you).<br /><br />There are also instances where you allocate a chunk of memory and save the pointer to that chunk.<br /><br />Example of addressing a pointer...<br /><br /><pre><code><br />.data<br />my_pointer DD 0 ;DWORD Sized Pointer<br /><br />.code<br />invoke _malloc, 4096 ;Allocate 4KB, result will be in EAX<br />mov my_pointer, eax ;Store the address pointer of the allocated memory<br />mov dword ptr, &#39;test&#39; ;Store the 4 byte ASCII string &quot;test&quot; into the first 4 bytes of the newly allocated memory<br /><br />;do some other stuff with EAX...<br />mov eax,1234<br /><br />;oh no, we lost our pointer... let&#39;s get it back!!!<br />mov eax, my_pointer ;Load the address pointer back into EAX<br />mov dword ptr, &#39;done&#39; ;Store the 4 byte ASCII string &quot;done&quot; into the next 4 bytes<br /></code></pre><br /><br />_malloc is a standard C call that attempts to allocate a chunk of memory (of desired size) and returns the address if successful, otherwise it returns &quot;zero&quot; (NULL) indicating an error. After we store the pointer value to the address of &quot;my_pointer&quot;, we use the same pointer that is still in EAX to address the memory chunk and store the string &quot;test&quot; to it. This is the other way to address memory on the x86, direct address number or by using a register that has the address. The above example also shows why you would want to &quot;save&quot; pointers and other run-time generated data.<br /><br />As you can see, a Label is simply defined in the source and converted at assembly-time... and a pointer is usually an uknown value and gathered at run-time.<br /><br />I know this isn&#39;t the &quot;best&quot; explanation, but I hope it is one you will understand and connect with :)</div>
    <div class="meta">Posted on 2006-09-21 19:06:40 by SpooK</div>
   </div>
   <div class="post" id="post-185429">
    <div class="subject"><a href="#post-185429">Re: zep2 simulator</a></div>
    <div class="body">Thanks alot for the explanation! So if i get this right, its better to now assign a value directly to an address, its better to use labels/pointers for this, right?<br />I tried that, and the file assembles fine, except for one warning that i get.<br /><br />This is the code:<br /><pre><code><br />.386<br />.model small<br />.stack<br />.data<br />	my_var dd 0<br /><br />.code<br /><br />main proc<br /><br />	mov eax, -2<br />	mov ebx, eax<br />	inc eax<br />	mov dword ptr, eax<br />	nop<br /><br />main endp<br />end<br /></code></pre><br />BTW: my_var is set to &#39;0&#39;, does this mean it has the value &#39;0&#39;, like it could have been &#39;34&#39;, or does it mean that the variable is defined but doesn&#39;t have a value yet?<br /><br />And this is the Warning:<br /><div class="quote"><br />LINK : warning L4038: program has no starting address<br /></div><br /><br /></div>
    <div class="meta">Posted on 2006-09-22 00:23:13 by vivendi</div>
   </div>
   <div class="post" id="post-185432">
    <div class="subject"><a href="#post-185432">Re: zep2 simulator</a></div>
    <div class="body">That is correct, do not specify memory addresses as hard-coded numbers (i.e. rely on labels instead) unless you are certain of what you are doing and why (i.e. Operating System Development is riddled with dealing in certain static PC memory locations). Reason being is that labels are resolved at assembly/link time to help prevent error, amongst other advantages that you will soon realize when you start developing larger and more complex programs.<br /><br />On to the program. Generic program basics 101. You have 3 basic sections of a program. Code, Initialized Data and Uninitialized Data.<br /><br />Code (.code) is the obvious one, where your program logic is kept in its machine/byte code format.<br /><br />Initialized Data (.data) is set to whatever you specify at assembly/compile time and is included in the program executable file. This is what guarantees that &quot;my_var&quot; is indeed set to an initial value of &quot;0&quot; in your example.<br /><br />Uninitialized Data (.bss) is *not* held within the program executable file, but the program executable will specify how much memory should be reserved (like using malloc) and that amount will be reserved at load time. Any worthy OS/loader will make sure this Uninitialized Data section is zeroed-out by default, but play it safe and don&#39;t depend on initial values of any Uninitialized Data.<br /><br />As for your linker warning (seems like you are targeting DOS), you have to specify what version of MASM/LINK you are using, what type of binary you are trying to produce from the linker (COM/EXE/etc...) and what OS you are trying to target (DOS/WinXP/etc...) before I can give you any advisement. It would also help if you posted what command-line options you are giving to MASM and LINK.<br /><br />There is sort of a learning curve in dealing with x86 ASM programming principles, but it is easy to adapt to once you understand the architecture. To help you further, you should read the <a target="_blank" href="http://www.asmcommunity.net/x86book/"><u>x86 Book</u></a> or some of <a target="_blank" href="http://www.asmcommunity.net/tutorials/"><u>Iczelion&#39;s Tutorials</u></a> (I think there is even a few in Dutch) in order to familiarize yourself with programming basics.<br /><br />PS: Also, please tell us your current programming experience/level so we can assist you further.</div>
    <div class="meta">Posted on 2006-09-22 01:49:11 by SpooK</div>
   </div>
   <div class="post" id="post-185437">
    <div class="subject"><a href="#post-185437">Re: zep2 simulator</a></div>
    <div class="body">Thanks alot for your explanation. i really appreciate that!<br />About the info you want, im using Windows XP, the linker is making .exe files for me. When i open the exe file a DOS window pops up, so i guess im targetting DOS.<br />About the linker that im using, i haven&#39;t downloaded MASM itself, but i have a tool which is the MASM linker (or something like that).<br />You can still get it from http://www.coderz.nl/_downloads/ASM.zip if you want to check it out.<br />Im assembling my code with this command:<br /><br />ml.exe mycode.asm<br /><br />thats all. It creates an .obj file and an .exe file.<br />I&#39;ve seen Iczelions tutorial, but thats targeted to real Win32 programming, i would rather stay with the basics so i can play around with values in memory, kinda like im doing now. So yeah, i guess i want to stay with DOS programming for now.<br /><br />I&#39;ve been programming in C/C++ for some time now, i&#39;ve learned basic console programming and slightly advanced Win32 apps. Also know some things about winsock.<br />I also know J2EE, but just the basics.<br /><br />That&#39;s basically it, i hope i haven&#39;t forgot to mention something... </div>
    <div class="meta">Posted on 2006-09-22 03:55:54 by vivendi</div>
   </div>
   <div class="post" id="post-185445">
    <div class="subject"><a href="#post-185445">Re: zep2 simulator</a></div>
    <div class="body"><u>The short and easy answer</u><br />You just need to change &quot;end&quot; to &quot;end main&quot; at the end of &quot;my_code.asm&quot; for it to resolve the starting address. This helps classify main as not only a procedure, but the program starting point as well.<br /><br /><u>The long and tough answer</u><br />Playing around with DOS is going to *force* you to conform to 16-bit programming techniques such as Segmentation. Even more so, is the fact that you will need to use DOS Interrupts for program control. Between those two, you are probably going to cause more work for yourself than anything else. I would highly suggest sticking to Win32 console programming as it offers the flat address space and all the other wonders of 32-bit Protected Mode programming.<br /><br />For example, here is the first quirk about DOS programming... how to exit a program...<br /><br /><pre><code><br />	mov ax,0x4C00 ;&quot;Exit Program&quot;<br />	int 0x21 ;Execute DOS Interrupt<br /></code></pre><br /><br />In Win32 Console programming, it could be as simple as &quot;ret&quot; or even &quot;ExitProcess&quot;. In DOS, you will have to rely on obscure interrupt numbers and references.<br /><br />As for your source code example... &quot;mov dword ptr, eax&quot; would no longer apply&quot;. You will have to load a Segment Selector/Register as the segment reference in the standard segment:offset address format. Default operation is to use BX as the offset for all addressing. Strings in DOS are terminated with &#39;$&#39; and not &#39;\0&#39;. You rely on 16-bit Registers (ax/bx/cx/dx/etc...) and not the 32-bit ones (eax/ebx/ecx/edx/etc...)<br /><br />The list goes on (which is partially described by <a target="_blank" href="http://www.xs4all.nl/~smit/asm01001.htm#firstprg"><u>THIS LINK</u></a>)... and on top of that, you cannot depend on Windows DOS (actually &quot;command&quot;) boxes... an emulator like DOSBox would be more appropriate.<br /><br />In the end, you will probably be learning more quirks about an obsolete operating system and depreciated operating mode (16-bit Real Mode) than you will actual assembly language programming. If you insist though, I would suggest heading over to <a target="_blank" href="http://webster.cs.ucr.edu/AoA/"><u>Randy Hyde&#39;s place</u></a> and picking up a copy of AoA for DOS/16-bit Edition. If you plan on switching to Win32 programming, head over to the same place and pick up Windows/32-bit Edition of AoA... just beware that the 32-bit Edition centers around Randy Hyde&#39;s HLA and not MASM. ;)</div>
    <div class="meta">Posted on 2006-09-22 12:58:53 by SpooK</div>
   </div>
   <div class="post" id="post-185454">
    <div class="subject"><a href="#post-185454">Re: zep2 simulator</a></div>
    <div class="body">wow, thanks for clearing that up. I think im going for the win32 asm then.<br />So im gonna stick to win32 console programming instead :)<br /><br />The book i have is only about 16-bit and you said with the link you gave, that its about HLA and not MASM, i dont know how much that differs from eachother..?<br />Im gonna start reading it, the beginning looks familair, but if you know more resources on the net about win32 console ASM, or maybe a good book about this, then please let me know.<br /></div>
    <div class="meta">Posted on 2006-09-23 05:02:14 by vivendi</div>
   </div>
   <div class="post" id="post-185462">
    <div class="subject"><a href="#post-185462">Re: zep2 simulator</a></div>
    <div class="body">Console programming using the Win32 API only differs from window programs in that you probably won&#39;t use any GUI functions. Practically everything you need that is external to your program will be an API call to one of the many libraries, utilizing the STDCALL convention.<br /><br />Your biggest friend will probably be the MSDN website, they have a list of all Win32 API functions, what they do and how to use them.<br /><br />Since you have programmed in C, you should probably look up MSVCRT functions... those will be your Standard C Library equivalents in Windows. MSVCRT still uses the CCALL convention, as opposed to most other Win32 API Calls.<br /><br />Just be aware, when you use Assembly Language in a particular OS... it is usually more about the API calls (especially in user interfacing) and less about the Assembly Language programming. Console programming offers the best approach to learn more about the actual Assembly Language since the I/O is rather limited (i.e. printf/scanf). Where you do have control is in algorithm development and other techniques to make your program more efficient. Usually you try to develop the most efficient way to store and manipulate your data, then worry about which instructions you will utilize to do so.</div>
    <div class="meta">Posted on 2006-09-23 12:46:45 by SpooK</div>
   </div>
  </div>
 </body>
</html>