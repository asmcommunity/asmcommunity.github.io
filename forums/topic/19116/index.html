<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>C++ inards (pre-article) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19116" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=19116">C++ inards (pre-article)</a></p>
   <div class="post" id="post-147772">
    <div class="subject"><a href="#post-147772">C++ inards (pre-article)</a></div>
    <div class="body">i've been working lately on making different algorithms for calling C++ methods using pointers and all manner of things, dealing with normal methods and virtual methods..<br />just wanna post some of my examples here, and see if anybody likes them (though they are inline assembler examples that can easily be modified to call in memory C++ objects from ASM code in the same process, also maybe people might be able to point out some errors in my logic or understanding. b.t.w these are MSVC++ specific as other compilers probably implement things differently.. one thing to note is i haven't tested/made allowances for classes that use multiple inheritence<br /><br />first issue is getting a pointer to the method. The folowing inline assembly will do it for virtual and non virtual methods, however it won't do it if you only have an empty &quot;shell interface&quot; definiton of the class (i.e virtual BOOL Shutdown() = 0;<br /><pre><code><br />_asm<br />&#123;<br />  mov eax,Test&#58;&#58;DoIt;<br />&#125;<br /></code></pre><br /><br />If you just have a 'shell interface' though, that won't compile, and maybe you want to rather get that address from C/C++, or actually maybe you know its a virtual method, and you want to rather get it from the pointer to the instance of the class. well first lets try getting it with C++ code..<br />first thing you need to do is use a method pointer..<br /><br /><pre><code><br />//here is what the method actually looks like for reference<br />virtual long DoIt&#40;long x&#41;;<br />...<br />// and now we need to declare a pointer to a method<br />long &#40;Test&#58;&#58;*pfn2&#41;&#40;long x&#41;;  //method pointer<br />// and now set the method pointer.<br />pfn2 = &amp;Test&#58;&#58;DoIt;<br />// now do the impossible, cast a method pointer as a function pointer<br />void * ptr = *&#40;&#40;void **&#41;&amp;pfn2 &#41;;<br /></code></pre><br />now we have a pointer to a method (but we can't actually just use that as a function pointer because of difference in calling convention. b.t.w if the function pointer is pointing to a nonvirtual method the address is the actual address of the method , however if its a virtual method.. its a pointer to a stub, that looks up the instance, and calls an entry in the virtual table (calling either this address of the actual address will both work.)<br />that stub always (as far as i've seen) looks like this<br /><pre><code><br />//00401EF0 8B 01            mov         eax,dword ptr &#91;ecx&#93; <br />//00401EF2 FF 60 04         jmp         dword ptr &#91;eax+4&#93; <br /></code></pre><br />the only difference between each time, is the +4 or the 5th byte which is an index into the virtual table.. <br />so i've this routine here that call be called on the address we got from the method pointer to see if it points to a virtual or non virtual method<br /><pre><code><br />static BOOL ismethodptrvirtual&#40;void * methodptr&#41;<br />	&#123;<br />		BOOL returnval;<br />		_asm<br />		&#123;<br />			mov eax,methodptr;<br />			mov ebx,&#91;eax&#93;<br />			mov eax,TRUE<br />			cmp ebx,60FF018Bh			<br />			je skip<br />			mov eax,FALSE<br />			skip&#58;<br />			mov returnval,eax<br />		&#125;		<br />		return returnval;<br />	&#125;<br /></code></pre><br />the next thing is maybe we already know the virtual table index (quite easy to calculate by looking at the class definition since msvc++ puts everything in the order it was declared, also you can altneratively do<br />myobj-&gt;doit(1); in a test app, and see the Assembly that msvc++ produces (or debug the app to see it).also the offset is goign to be DWORD aligned so first method be at offset 4, 2nd at offset 8 etc..<br />anyhow i made this function to go inside the virtual table and get the adddress of a virtual method based on the instance and offset.<br /><pre><code><br />static PVOID virtualaddress&#40;void* thisptr,int methodoffset&#41;<br />	&#123;<br />		PVOID returnval;		<br />		_asm<br />		&#123;<br />			mov eax,thisptr;<br />			mov eax,&#91;eax&#93; ; //point to the start of virtualtable<br />			mov ebx,methodoffset;<br />			mov eax,&#91;eax+ebx*4&#93;<br />			mov returnval,eax<br />		&#125;<br />		return returnval;<br />	&#125;<br /></code></pre><br />now that we can get the address of a method in many different ways.. How about calling this method..<br />nonstaTIC C++ methods use the THISCALL calling convention which is basically the STDCALL (called method cleans up the stack) with the hidden 'this' instance pointer also being sent, with MSVC++ the 'this' pointer is passed in ECX register.. and all the parameters like STDCALL are pushed on the the stack in right to left order. (but since the stack goes downwards, basically in memory in left to right order ) so if you want to call<br />this particular method manually you could do.. the return value is normally returned in eax, but 8 bit structures are returned in eax:edx, and floats are returned in ST0 - so will have to be accessed seperately, not covered in this article<br /><pre><code><br />// to do the equivilant of the following<br />// int mine = obj1.doIt&#40;43&#41;;<br />//where you allready have the pointer to doIt in PVOID doitptr;<br />_asm<br />&#123;<br />  push43<br />  mov ecx,obj1<br />  call &#91;doitptr&#93;<br />  mov mine,eax<br />&#125;<br /></code></pre><br />however we want to make a more generic technique to call functions.. so this is the solution..<br />first this is how it is called.<br /><pre><code><br />//here is the definition of the method used in this example<br /><br />virtual	BOOL	Startup&#40;HWND hPrimaryWnd, DWORD modeFlags&#41;;<br /><br />// and i know that it is the first method in the virtual table, <br />//and we have an instance of this class called<br />//m_pEngine<br />//here is the structure containing the parameters to pass to the function<br />struct <br />	&#123;<br />		HWND  wndhandle;<br />		DWORD c;<br />	&#125; mystruct = &#123;tmphwnd,VJEMODE_PRESENTATION&#125;;<br /><br />//use the virtualaddress method we have already <br />//covered to get the address from the instance.<br /><br />address = &#40;DWORD&#41; thiscall&#58;&#58;virtualaddress&#40;m_pEngine,1&#41;;<br /><br />//use the my callmethod passing in the instance of the object, <br />//the adress, the structure containing <br />//the arguments for the function and the size of the arugments &#40;structure&#41;<br /><br />thiscall&#58;&#58;callmethod&#40;m_pEngine,address,&#40;const void*&#41;&amp;mystruct,sizeof&#40;mystruct&#41;&#41;;<br /><br /></code></pre><br />and that is all. now here the actual code for callmethod. basically we copy the structure to the stack (as if we had pushed the parmeters backwards), put the instance of the object into ECX and call the address. and return what is returned in EAX<br /><pre><code><br />static DWORD callmethod&#40;void* thisptr, DWORD address,const void* arguments,size_t argsize&#41;<br />	&#123;<br />	DWORD returnval;               <br />	_asm<br />	&#123;<br />        mov   ecx, argsize    // get size of arguments for the function			    <br />        sub   esp, ecx         // adjust the stack pointer to give room to copy these arguments there<br />        shr   ecx, 2            // divide by 4 &#40;because we'll copy DWORDS over at a time&#41;<br />        mov   esi, arguments   // get the pointer to the start of the arguments buffer &#40;Source&#41;		<br />        mov   edi, esp         // start of destination stack frame &#40;destination&#41;<br />        rep   movsd            // copy arugments to stack frame<br />        mov   ecx, thisptr     // THISCALL passes &quot;this&quot; in ecx<br />        call  &#91;address&#93;        // call the function <br />        mov   returnval, eax   // return value returns in eax, so we better save it<br />    &#125;<br />	return returnval;<br />&#125; <br /></code></pre><br />also if we are just calling a virtual method, and we know the offset, i combined my getvirtualaddress method with the one here to produce this<br /><pre><code><br />static DWORD callvirtualmethod&#40;void *thisptr,int methodoffset,const void* arguments,size_t argsize&#41;<br />&#123;<br />  DWORD returnval;    <br />  _asm<br />   &#123;<br />        mov   ecx, argsize  // get size of arguments for the function		<br />        sub   esp, ecx        // adjust the stack pointer to give room to copy these arguments there<br />        shr   ecx,2              // divide by 4 &#40;because we'll copy DWORDS over at a time&#41;<br />        mov   esi, arguments    // get the pointer to the start of the arguments buffer &#40;Source&#41;<br />        mov   edi, esp          // start of destination stack frame &#40;destination&#41;<br />        rep   movsd             // copy arugments to stack frame<br />        mov	  eax, thisptr      // get the &quot;this&quot; pointer <br />        mov   eax, &#91;eax&#93; 	    // point to the start of virtualtable<br />        mov   ebx, methodoffset // offset into the virtualtable<br />        mov   ecx, thisptr	    // THISCALL passes &quot;this&quot; in ecx<br />        call  &#91;eax+ebx*4&#93;       // call the function &#40;the address of virtualtable+offset*4&#41;<br />        mov   returnval, eax    // return value returns in eax, so we better save it<br />    &#125;<br />	return returnval;<br /><br />	&#125;<br /></code></pre><br /><br />which enables you do do the following<br /><pre><code><br />//instead of the following used in the last example <br /><br />address = &#40;DWORD&#41; thiscall&#58;&#58;virtualaddress&#40;m_pEngine,1&#41;;<br />thiscall&#58;&#58;callmethod&#40;m_pEngine,address,&#40;const void*&#41;&amp;mystruct,sizeof&#40;mystruct&#41;&#41;;<br /><br />//you can just do this directly<br /><br />thiscall&#58;&#58;callvirtualmethod&#40;m_pEngine,1,&#40;const void*&#41;&amp;mystruct,sizeof&#40;mystruct&#41;&#41;;<br /><br /></code></pre><br />which is really useful, but often you might get the pointer directly using other methods so &quot;callmethod&quot; itself is useful. There is one more technique i have done so far.. ussually it wouldn't be of use to anybody, but in my case of HOOK methods, it is absolutely essential. Early on in the article i showed getting an address to a method pointer. I also pointed out that if that method pointer points to a virtual method, it doesn't point directly to it, but rather to some stub code that looks up the actual address from the virtual table based on an offset specified in the stub code as below<br /><pre><code><br />//00401EF0 8B 01            mov         eax,dword ptr &#91;ecx&#93; <br />//00401EF2 FF 60 04         jmp         dword ptr &#91;eax+4&#93; <br /></code></pre><br />for hooking purposes there isn't enough bytes (6) for me to install a safe hook, and also if i hooked this function then it would only hook calls to the method that were called through a method pointer rather that any other way. so i made a function that checks the address, and if it starts with the faith bytes 60FF018B as above it knows its this stub, and then it grabs the 5th byte as the offset, and then manually looks up the vtable itself and gets the actual address of the function. that code is below. (it has alot of comments in this one)<br /><pre><code><br />static PVOID dereferencemethodptr&#40;void* thisptr,void * methodptr&#41;<br />&#123;<br />  PVOID returnval;<br />  //issues if size of pointer is more than 4 bytes &#40;multiple inheritance it might be different&#41;<br />  //if a method pointer points to a nonstatic &#40;but not virtual&#41; function, then it points directly<br />  //to that function<br />  //if it points to a nonstatic VIRTUAL function, then it points to a stub that C++ creates that looks <br /> //the the following<br />	//00401EF0 8B 01            mov         eax,dword ptr &#91;ecx&#93; <br />                //00401EF2 FF 60 04         jmp         dword ptr &#91;eax+4&#93; <br />  //as far as i've seen , irregardless of anything i've seen so far , or compiler optomisation options<br />  //it seems to be exactly the same as above, other than the last byte &#40;the +4&#41; <br />  //which is actually the information<br />  //we need to be able to look up the function in the vtable.. so we can read it directly from this code.<br />  //so first we check to see if the first 4 bytes are 8b01FF60 &#40;or is it 60FF018B?&#41; and if it is grab the <br />  //address + 4.. otherwise just treat the address as what it is.<br />  _asm<br />  &#123;<br />   mov eax,methodptr;<br />   mov ebx,&#91;eax&#93;<br />   cmp ebx,60FF018Bh<br />   jne skip<br />   //if its a virtual method<br />   xor ebx,ebx<br />   mov bl,byte ptr &#91;eax + 4&#93;; //grab the 5th byte which is the +4 &#40;or +whatever&#41; offset in the virtual table<br />   mov eax,thisptr; //ptr to the instance of the class<br />   mov eax,&#91;eax&#93; ;//start of virtual table<br />   mov eax,&#91;eax+ebx&#93;;//get the address of the method from getting it from the virtual table with offset<br />   skip&#58;<br />   mov returnval,eax<br />  &#125;<br />return returnval;	<br />&#125;<br /></code></pre><br /><br />end of article..<br />------------------<br />feedback from people in this community is sought after desperately, maybe i've made some wrong assumptions , or overlooked some important things.. so if you find this interesting, or find any errors in my logic.<br />i know that it may not faithfully always work (though alot of it still will) for classes with multiple inheritence, or with other compilers than MSVC++, but maybe in the future i'll look into both of those issues.</div>
    <div class="meta">Posted on 2004-08-09 19:33:34 by klumsy</div>
   </div>
   <div class="post" id="post-147827">
    <div class="subject"><a href="#post-147827">C++ inards (pre-article)</a></div>
    <div class="body">nice and correct :alright:<br />Classes with more than 31 virtuals are not rare, so the 5 bytes (60FF018Bh) will change to A0FF018Bh, and the next 4 bytes are the offset in vtable. <br />Also, it should be accented on where the constructor and destructor are: constructor is always static, the destructor can be marked as virtual, and if so - it's at offset 0 of the vtable.<br />Multiple inheritance is actually a really easy matter - the new class just has a copy of its parent's vtable, modified a little. <br /><br />The approach of tutoring with inline asm is a little confusing - the purpose of the article gets really lost - but anyway it's ok as long as the reader can think of a (the) way to use it in asm :) <br />Maybe at this point I should remind that here on this board there is a whole macro base for interfacing of C++ code, named &quot;ATC&quot; :)   Of course the basics should be learnt but it gets really annoying to be hardcoding calls to C++ functions if some good software is about to be made. <br />And again, nice article :alright:<br /><br />  ah, and don't care about other compilers than MSVC - because this is the actual standard everyone works with.</div>
    <div class="meta">Posted on 2004-08-10 07:29:24 by Ultrano</div>
   </div>
   <div class="post" id="post-147858">
    <div class="subject"><a href="#post-147858">C++ inards (pre-article)</a></div>
    <div class="body">yeah thanks for the extra info, my destructor is virtual thus the zero 0, you have given alot of good info.. i had also wonder about the case when the vtable offset would be more than 32.. i'll have to adjust my library.<br /><br />the prob with multiple inheritance i have is not necciarily the vtable, but non virtual (and maybe virtual function) that are being referenced by a METHOD pointer, as the method pointer's size can change (not just 4 bytes) but actually 8 or 12 and contain offset and other information as per<br /><a target="_blank" href="http://weblogs.asp.net/oldnewthing/archive/2004/02/09/70002.aspx">http://weblogs.asp.net/oldnewthing/archive/2004/02/09/70002.aspx</a><br /><br />as for tutoring in inline assembly being a bit confusing..<br />do you mean thast i put comments describing it inside the comments with the code (which i probably should change to make it more readible. or using inline assembler alltogether (which is purposeful because i'm trying to build a library of functions so that C programmers can use it without having to do any inline assembly at all (other than the ocassional mov eax, ThisClass::thisMethod, mov myptr,eax) sort of thing. and my intended audience is mostly  programmers who willl need to understand a little under the hood , but be able to use the techniques - either to make some callback methodology from C, to implement and link together a scripting language, manual RPC technique, or to use madCHook to hook functions (my main intention of doing this all)<br /><br />thanks again for all the insights though.</div>
    <div class="meta">Posted on 2004-08-10 18:22:47 by klumsy</div>
   </div>
  </div>
 </body>
</html>