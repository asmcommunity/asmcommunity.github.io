<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>FPS from fElapsedTime - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19962" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=19962">FPS from fElapsedTime</a></p>
   <div class="post" id="post-153161">
    <div class="subject"><a href="#post-153161">FPS from fElapsedTime</a></div>
    <div class="body">Heya :)<br />I have a question concerning calculation of FramesPerSecond.<br />Looking around, I note that pretty much everyone does this by incrementing a counter once per Frame...<br />I do it a little differently, and want to know if anyone can see a problem with my method.It works like this:<br /><br />I get fElapsedTime (in Seconds) as a QWORD on the fpu stack using highperf timer.<br />Now get its reciprocal (1/fElapsedTime) to calculate the fps.<br /><br />Thinking about this a little with this example: if the elapsed time between Frames was 500ms (half a second), according to my formula , fps = 1 / 0.5, which equals 2 fps. Seems ok, right?<br /><br />This method gives fps as a floating point value, more accurate than simply integer value.</div>
    <div class="meta">Posted on 2004-11-17 21:47:29 by Homer</div>
   </div>
   <div class="post" id="post-153162">
    <div class="subject"><a href="#post-153162">FPS from fElapsedTime</a></div>
    <div class="body">It works fine if you want the projected FPS from one frame, or don't mind averaging across several frames to get a human readable digital figure.  I imagine it would produce a nice graph - really I imagine an tachometer with a needle bouncing... :)</div>
    <div class="meta">Posted on 2004-11-17 22:00:31 by bitRAKE</div>
   </div>
   <div class="post" id="post-153168">
    <div class="subject"><a href="#post-153168">FPS from fElapsedTime</a></div>
    <div class="body">Thats basically what it looks like :)<br /><br />My current testbed project is getting (roughly !!) between 59.995 and 60.005 frames per second, which worried me at first, I thought I'd screwed up somewhere until I had a friend run it and report around half that framerate.</div>
    <div class="meta">Posted on 2004-11-18 01:36:01 by Homer</div>
   </div>
   <div class="post" id="post-153174">
    <div class="subject"><a href="#post-153174">FPS from fElapsedTime</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br />The idea with regards to incrementing a counter every frame is so you can display the actual frames per second.<br />Every second you set the displayed value to the counted frames.<br />This stops the displayed fps from flickering all over the place.<br />Also:<br />If the fps isn't actually updated once per second then you're only really displaying the rendering time of the previous frame (i.e. it is no longer displaying frames per second).<br /><br />So if you're going to use the 1/fElapsedTime method then you'll have to add up each value until 1 second has elapsed, then divide the summed value by the number of frames elapsed.<br />In other words...<br />You'll <em>still</em> have to keep an incrementing counter for each frame so that you'd know how many frames to divide the summed value by.<br /><br />(Unless you only update the displayed value once per second using only the previous frames' elapsed time in the calculation). :P <br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2004-11-18 04:59:41 by Scronty</div>
   </div>
   <div class="post" id="post-153178">
    <div class="subject"><a href="#post-153178">FPS from fElapsedTime</a></div>
    <div class="body">I do see your point about the flickering fps. Very annoying :)<br />The formula itself is ok though, and if I wanted fps rounded off to an integer value, I could just fistp it, right? I mean sure, that will be as much as 1fps error, but would you agree that the inc integer method suffers from the same error, since the &quot;total&quot; elapsed time will pretty much never fall on a full second, its always going to be one side or the other of 1.0 seconds, ie when OVER 1 second, the &quot;remainder&quot; elapsed time contributes to the NEXT second worth of frames - thus we are at least 1 fps in error.. agreed? And if I based my fps on the TOTAL ELAPSED TIME instead of the elapsed time between iterations, would that not make for extremely accurate results?<br />I'm quite tired and I hope I am not making a fool of myself here :P</div>
    <div class="meta">Posted on 2004-11-18 06:36:26 by Homer</div>
   </div>
   <div class="post" id="post-153186">
    <div class="subject"><a href="#post-153186">FPS from fElapsedTime</a></div>
    <div class="body">Would be interesting to have a counter for all the calculations?, I guess that would be more like Have a sistem for Real values and measure not  only the PFS,  but the calculation of the new world, the rendering, etc. Also trigered by events a new graph or measurement. In that way, measuring each part of your engine you will know where to put attention, pheraphs FPS are a static for the end user, but for the developer would be nice have a static of how fast is the IA calculations for simple and for complex events...<br /><br />That would be like profiling ;) and making graphs with labels about the events trigered. You can measure one thing, or all the things at the same time and then make a graph of usage.<br /><br /><br />Also a side note, I am reading a book about quality, production, related to work not programming, but there is sayed that a graph only show to us numbers eg. they only say how many car accidents there are, pheraphs a more detailed can show to us car accident by drugs, simple accident, etc. But anyway they dosent say how we low the static about car accidents. What I mean is that we need to interpret the graph for get a real result and use for such a measurement tool oriented to programm parts.</div>
    <div class="meta">Posted on 2004-11-18 07:48:49 by rea</div>
   </div>
   <div class="post" id="post-153194">
    <div class="subject"><a href="#post-153194">FPS from fElapsedTime</a></div>
    <div class="body">I liked to use a method which took all frames into account but in which the most recent had the most influence :)<br /><br />NewFrameRate = (OldFrameRate + CurrentFrameRate) / 2<br /><br />CurrentFrameRate would be calculated say each frame with the method you propose. Only problem with that method is if the frames are actually taking a shorter time than your timer can measure. This happens alot with GetTickCount on Win 9x.</div>
    <div class="meta">Posted on 2004-11-18 11:57:15 by EÃ³in</div>
   </div>
   <div class="post" id="post-153199">
    <div class="subject"><a href="#post-153199">FPS from fElapsedTime</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br />Having the FPS accurate to within 1 or 2 frames is fine. The FPS is supposed to be a guide to roughly how many frames per second the program is running at on the machine. It's <em>not</em> meant to be so accurate as to be used in actual updating of rendered objects :P .<br /><br />This is the way I see it:<br />There are two main uses of time in a game.<br />(1) Time used for internal calculations for updating rendered objects (i.e. fElapsedTime).<br />(2) Time used for the updating of displayed data (i.e. an FPS counter).<br /><br />For (1), you'd use the Performance Counter or timeGetTime to find the last elapsed time <em>once</em> and use this value for <em>all</em> rendered objects which move during that frame update.<br /><br />For (2) it doesn't really matter which method you use for calculating the FPS. I'm only concerned with it being displayed in a sensible manner (i.e. the displayed FPS is only changed once per second so it doesn't flicker and the value is actually readable).<br /><br />Also note that (2) would mean anything which is only for display on the screen and <em>not</em> for updating rendered objects.<br />i.e. this could include timings for text for a game console message to scroll at a certain speed. The text might be set to scroll upwards one line every 2 seconds.<br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2004-11-18 16:23:21 by Scronty</div>
   </div>
   <div class="post" id="post-153207">
    <div class="subject"><a href="#post-153207">FPS from fElapsedTime</a></div>
    <div class="body">Sometimes its not good to get the elapsed time once for an entire frame worth of rendering - as an example of this, look at m$'s d3d particles demo - they create a blur effect by rendering the particles several times per frame via the time elapsed during the rending of the previous particle instance :) <br />I modified your Timer codebase a long time ago to have an eighth switch which gives the elapsed time but does not update the internal vars - this one you can call anytime while rending, but only after getting the once-per-frame Elapsed time (which I do immediately at the start of each frame). It returns the time that has elapsed since the start of the frame.<br /><br />I don't plan on using the FPS value for anything at all, I was simply interested in why everyone wants to express it as an integer :) I think I might change it to show Frames over Time instead of fine FPS.</div>
    <div class="meta">Posted on 2004-11-18 20:55:45 by Homer</div>
   </div>
   <div class="post" id="post-153257">
    <div class="subject"><a href="#post-153257">FPS from fElapsedTime</a></div>
    <div class="body">OK, now to overengineer this :)<br />Let's view actual momentary FPS rate (i.e. 1/elapsed) as input, and the user display as output. For the function we're designing, we have the contradictory goals of rapid signal tracking (minimize output error WRT input) vs. stability (minimize second derivative).<br /><br />Rapid tracking is important so that we notice changes to the scene immediately - e.g. impact of switching to a higher LOD level.<br />Of course we want the output to be legible, so it must not change too often.<br /><br />As Scronty mentions, just sampling 1x per second takes care of legibility, but we can't see how the signal actually changes.<br />E?in's IIR filter (*) isn't bad, but we can modify it to track the signal more rapidly (similar to a sliding-window average, it will otherwise lag behind the actual input).<br /><br />To calculate FPS, we first need the elapsed time. There's an annoying detail - some platforms only expose a ms timer, so we may need to wait a few frames until the elapsed time is &quot;measurable&quot; (say 4x timer resolution).<br />Now, what we will do is increase or decrease the gain on the IIR filter (making it track the signal more or less rapidly), depending on whether it looks like the input is actually changing, or just jittering.<br />Looking at some graphs, it turns out spikes ( \/ ) and jumps are mostly noise; when we see those in the history buffer, the gain is decreased. On the other hand, when output is consistently above or below the input, the function is actually changing, and we need to increase gain to keep up.<br /><br />We then stuff this gain value (implemented as exponential bias) a.k.a. &quot;sharpness&quot; into a simple IIR filter: old = new*gain + old*(1.0-gain).<br />Finally, the user-visible FPS value is updated if it differs &quot;enough&quot; from this newly calculated FPS.<br /><br />Here's the C code:<pre><code><br />	static double avg_fps = 30.0;<br />	double cur_fps = avg_fps;<br /><br />	// get elapsed time &#91;s&#93; since last update<br />	static double last_t;<br />	const double t = get_time&#40;&#41;;<br />	ONCE&#40;last_t = t - 33e-3&#41;;	// first call&#58; 30 FPS<br />	const double dt = t - last_t;<br /><br />	// &#40;in case timer resolution is low&#41;&#58; count frames until<br />	// timer value has changed &quot;enough&quot;.<br />	static double min_dt;<br />	ONCE&#40;min_dt = timer_res&#40;&#41; * 4.0&#41;;<br />		// chosen to reduce error but still yield rapid updates.<br />	static uint num_frames = 1;<br />	if&#40;dt &lt; min_dt&#41;<br />	&#123;<br />		num_frames++;<br />		return;<br />	&#125;<br /><br />	// dt is big enough =&gt; we will update.<br />	// calculate approximate current FPS &#40;= 1 / elapsed time per frame&#41;.<br />	last_t = t;<br />	cur_fps = 1.0 / dt * num_frames;<br />	num_frames = 1;	// reset for next time<br /><br /><br />	// average and smooth cur_fps.<br />	//<br />	// filter design goals&#58; steady output, but rapid signal tracking.<br />	//<br />	// implemented as a variable-gain IIR filter with knowledge of typical<br />	// function characteristics. this is easier to stabilize than a PID<br />	// scheme, since it is based on averaging actual function values,<br />	// instead of trying to minimize output-vs-input error.<br />	// there are some similarities, though&#58; same_side ~= I, and<br />	// bounced ~= D.<br /><br />	//<br />	// check cur_fps function for several characteristics that<br />	// help decide if it's actually changing or just jittering.<br />	//<br /><br />#define REL_ERR&#40;correct, measured&#41; &#40;fabs&#40;&#40;correct&#41; - &#40;measured&#41;&#41; / &#40;correct&#41;&#41;<br />#define SIGN_EQ&#40;x0, x1, x2&#41; &#40; &#40;&#40;x0&#41; * &#40;x1&#41;&#41; &gt; 0.0 &amp;&amp; &#40;&#40;x1&#41; * &#40;x2&#41;&#41; &gt; 0.0 &#41;<br />#define ONE_SIDE&#40;x, x0, x1, x2&#41; SIGN_EQ&#40;x-x0, x-x1, x-x2&#41;<br /><br />	// cur_fps history and changes over past few frames<br />	static double h2, h1 = 30.0, h0 = 30.0;<br />	h2 = h1; h1 = h0; h0 = cur_fps;<br />	const double d21 = h1 - h2, d10 = h0 - h1, d20 = h0 - h2;<br />	const double e20 = REL_ERR&#40;h2, h0&#41;, e10 = REL_ERR&#40;h1, h0&#41;;<br />	const double e0 = REL_ERR&#40;avg_fps, h0&#41;;<br /><br />	// indicators that the function is jittering<br />	const bool bounced = d21 * d10 &lt; 0.0 &amp;&amp; e20 &lt; 0.05 &amp;&amp; e10 &gt; 0.10;<br />		// /\ or \/<br />	const bool jumped = e10 &gt; 0.30;<br />		// large change &#40;have seen semi-legitimate changes of 25%&#41;<br />	const bool close = e0 &lt; 0.02;<br />		// cur_fps - avg_fps is &quot;small&quot;<br /><br />	// &quot;same-side&quot; check for rapid tracking of the function.<br />	// if the past few samples have been consistently above/below the average,<br />	// the function is moving up/down and we need to catch up.<br />	static int same_side;<br />		// consecutive times the last 3 samples have been on the same side.<br />	if&#40;!ONE_SIDE&#40;avg_fps, h0, h1, h2&#41;&#41;	// not all on same side&#58;<br />		same_side = 0;					// reset counter<br />	// &#40;only increase if not too close to average,<br />	// so that this isn't triggered by jitter alone&#41;<br />	if&#40;!close&#41;<br />		same_side++;<br /><br /><br />	//<br />	// determine filter gain, based on above characteristics.<br />	//<br /><br />	static double gain;	// sensitivity to changes in cur_fps &#40;&#91;0,1&#93;&#41;<br />	double bias = 0.0;	// &#40;unlimited&#41; exponential change to gain<br /><br />	// ignore &#40;gain -&gt; 0&#41; large jumps.<br />	if&#40;jumped&#41;<br />		bias -= 4.0;<br />	// don't let a &quot;bounce&quot; affect things too much.<br />	else if&#40;bounced&#41;<br />		bias -= 1.0;<br />	// otherwise, function is normal here.<br />	else<br />	&#123;<br />		// function is changing, we need to track it rapidly.<br />		// note&#58; check close again so we aren't too loose if the function<br />		// comes closer to the average again &#40;meaning it probably<br />		// wasn't really changing&#41;.<br />		if&#40;same_side &gt;= 2 &amp;&amp; !close&#41;<br />			bias += min&#40;same_side, 4&#41;;<br />	&#125;<br /><br />	// bias = 0&#58; no change. &gt; 0&#58; increase &#40;n-th root&#41;. &lt; 0&#58; decrease &#40;^n&#41;<br />	double e = &#40;bias &gt; 0&#41;? 1.0 / bias &#58; -bias;<br />	if&#40;e == 0.0&#41; e = 1.0;<br />	gain = pow&#40;0.08, e&#41;;<br />		// default&#58; fairly insensitive to changes &#40;~= 16 sample average&#41;<br /><br /><br />	// IIR filter<br />	static double old = 30.0;<br />	old = cur_fps*gain + old*&#40;1.0-gain&#41;;<br />	avg_fps = old;<br /><br />	// update fps counter if it differs &quot;enough&quot;<br />	// currently, that means off by more than 5 FPS or 5%.<br />	const double difference = fabs&#40;avg_fps-fps&#41;;<br />	const double threshold = fminf&#40;5.f, 0.05f*fps&#41;;<br />	if&#40;difference &gt; threshold&#41;<br />		fps = &#40;int&#41;avg_fps;<br /></code></pre><br /><br />Ever since I wasted a few hours on this, all subsequent projects have had a nice FPS display :)<br />I am very happy with the signal tracking, but the &gt;update fps counter if it differs &quot;enough&quot;&lt; part is kind of dirty. Can anyone think of a better way?<br /><br /><br />*: IIR = infinite impulse response. function output depends on all previous inputs (typically via &quot;state&quot; influencing output, calculated from previous input). If you send in a pulse (dirac function) input, the output will still &quot;ring&quot; (non-zero) later.<br />opposite is FIR (finite ..), where the output only depends on a sliding window of the last N inputs (no state); after the pulse has moved out of the window, output returns to 0.<br /><br /><br />phew! Thus ends our &quot;going overboard with control theory&quot; party. Any survivors? :)</div>
    <div class="meta">Posted on 2004-11-20 09:07:26 by Jan Wassenberg</div>
   </div>
   <div class="post" id="post-153292">
    <div class="subject"><a href="#post-153292">FPS from fElapsedTime</a></div>
    <div class="body">I'm impressed :)<br />I'll take the time to translate this for my own benchmarking purposes, and I'll add it to my current ogl engine dll project as an afterthought for end-users :)</div>
    <div class="meta">Posted on 2004-11-21 03:27:12 by Homer</div>
   </div>
   <div class="post" id="post-153323">
    <div class="subject"><a href="#post-153323">FPS from fElapsedTime</a></div>
    <div class="body">:)<br /><br />hehe, just feed it into a compiler, that's a lot less work - it's not time-critical ;) But if you do translate it, could you send me a copy? I'd be interested to see how it looks.</div>
    <div class="meta">Posted on 2004-11-21 15:22:51 by Jan Wassenberg</div>
   </div>
   <div class="post" id="post-153371">
    <div class="subject"><a href="#post-153371">FPS from fElapsedTime</a></div>
    <div class="body">Here's an almost-completed translation which consumed five minutes of my life.. I'll finish it up next time I find five minutes to waste, unless someone beats me to it ;)<br /><br /><pre><code><br />REL_ERR macro correct, measured<br />    fld correct<br />    fsub measured<br />    fdiv correct<br />    fabs<br />endm<br /><br />SIGN_EQ macro x0,x1,x2<br />    fld x0<br />    fmul x1<br />    fstp ftemp<br />    .if ftemp &amp; 80000000h == 0<br />        fld x1<br />        fmul x2<br />        fstp ftemp<br />        .if ftemp &amp; 80000000 == 0<br />            exitm &lt;TRUE&gt;<br />        .endif<br />    .endif<br />    exitm &lt;FALSE&gt;<br />endm    <br /><br />ONE_SIDE macro x,x0,x1,x2<br />    LOCAL xx,yy,zz<br />    fld x<br />    fsub x0<br />    fstp xx<br />    fld x<br />    fsub x1<br />    fstp yy<br />    fld x<br />    fsub x2<br />    fstp zz<br />    exitm &lt;SIGN_EQ &#40;xx,yy,zz&#41;&gt;<br />endm<br /><br />.data<br />avg_fps REAL8 30.0f<br />cur_fps  REAL8 30.0f<br />last_t     REAL8 0.0f<br />t             REAL8 0.0f<br />min_dt   REAL8 0.20f        ;minimum elapsed time is 200ms<br />h0 REAL8 30.0f<br />h1 REAL8 30.0f<br />h2 REAL8 30.0f<br />d10 REAL8 0.0f<br />d20 REAL8 0.0f<br />d21 REAL8 0.0f<br />e0   REAL8 0.0f<br />e10 REAL8 0.0f<br />e20 REAL8 0.0f<br />gain REAL8 0.0f      ;// sensitivity to changes in cur_fps &#40;&#91;0,1&#93;&#41; <br />bias REAL8 0.0f      ;// &#40;unlimited&#41; exponential change to gain <br /><br />num_frames dd 1<br />bBounced BOOL FALSE<br />bJumped BOOL FALSE<br />bClose BOOL FALSE<br />same_side dd 0<br /><br />.code<br />;   // get elapsed time &#91;s&#93; since last update <br />    invoke Timer, TIMER_GETELAPSEDTIME<br />    fstp dt<br /><br />;   // &#40;in case timer resolution is low&#41;&#58; count frames until <br />;   // timer value has changed &quot;enough&quot;. <br />;   ONCE&#40;min_dt = timer_res&#40;&#41; * 4.0&#41;; <br />      // chosen to reduce error but still yield rapid updates. <br />   fld t<br />   fcomp min_dt<br />   __FJG @F   if&#40;dt &lt; min_dt&#41; <br />   inc num_frames<br />   ret <br />@@&#58;<br /><br />;   // dt is big enough =&gt; we will update. <br />;   // calculate approximate current FPS &#40;= 1 / elapsed time per frame&#41;. <br />   fld t<br />   fstp last_t<br />   fld1<br />   fdiv t<br />   fmul num_frames<br />   fstp cur_fps<br />   cur_fps = 1.0 / dt * num_frames; <br />   mov num_frames , 1;   // reset for next time <br /><br />;   // average and smooth cur_fps. <br />;   // <br />;   // filter design goals&#58; steady output, but rapid signal tracking. <br />;   // <br />;   // implemented as a variable-gain IIR filter with knowledge of typical <br />;   // function characteristics. this is easier to stabilize than a PID <br />;   // scheme, since it is based on averaging actual function values, <br />;   // instead of trying to minimize output-vs-input error. <br />;   // there are some similarities, though&#58; same_side ~= I, and <br />;   // bounced ~= D. <br /><br />;   // <br />;   // check cur_fps function for several characteristics that <br />;   // help decide if it's actually changing or just jittering. <br />;   // <br /><br /><br /><br />;   // cur_fps history and changes over past few frames <br /><br />    fld h1<br />    fstp h2<br />    fld h0<br />    fstp h1<br />    fld cur_fps<br />    fstp h0                 ;   h2 = h1; h1 = h0; h0 = cur_fps; <br />    fld h1                  ;d21 = h1 - h2<br />    fsub h2<br />    fstp d21<br />    fld h0<br />    fsub h1<br />    fstp d10                ;d10 = h0 - h1<br />    fld h0<br />    fsub h2<br />    fstp d20                ; d20 = h0 - h2; <br />    REL_ERR &#40;h2, h0&#41;    ;e20 = REL_ERR&#40;h2, h0&#41;<br />    fstp e20<br />    REL_ERR &#40;h1,h0&#41;     ;e10 = REL_ERR&#40;h1, h0&#41;; <br />    fstp e10<br />    REL_ERR &#40;avg_fps, h0&#41;   ;e0 = REL_ERR&#40;avg_fps, h0&#41;; <br />    fstp e0 <br /><br />;   // indicators that the function is jittering <br />   bBounced = d21 * d10 &lt; 0.0 &amp;&amp; e20 &lt; 0.05 &amp;&amp; e10 &gt; 0.10; <br />        fld d21<br />        fmul d10<br />        fstp ftemp<br />        .if ftemp &amp; 80000000 != 0       ;d21 * d10 &lt; 0.0  &#40;testing bit 31 for sign is valid for fp values&#41;<br />            fld e20                                ;&amp;&amp; e20 &lt; 0.05 <br />            fcomp r4_0_5<br />            __FJGE @F<br />            fld e10                                ;&amp;&amp; e10 &gt; 0.10<br />            fcomp r4_0_1<br />            __FJLE @F<br />            mov bBounced, TRUE<br />        .else<br />@@&#58;     mov bBounced, FALSE                <br />        .endif<br />        <br />;      // /\ or \/ <br />   const bool jumped = e10 &gt; 0.30; <br />        mov bJumped, FALSE<br />        fld e10<br />        fcomp r4_0_3<br />        __FJLE @F<br />        mov bJumped, TRUE<br />@@&#58;<br />            <br />;      // large change &#40;have seen semi-legitimate changes of 25%&#41; <br />   const bool close = e0 &lt; 0.02; <br />        mov bClose, FALSE<br />        fld e0<br />        fcomp r4_0_02<br />        __FJGE @F<br />        mov bClose, TRUE<br /><br />;      // cur_fps - avg_fps is &quot;small&quot; <br /><br />;   // &quot;same-side&quot; check for rapid tracking of the function. <br />;   // if the past few samples have been consistently above/below the average, <br />;   // the function is moving up/down and we need to catch up. <br />;      // consecutive times the last 3 samples have been on the same side. <br />   <br />   .if&#40;!ONE_SIDE&#40;avg_fps, h0, h1, h2&#41;&#41;              ; // not all on same side&#58; <br />      mov same_side , 0                     ;               // reset counter <br />   .endif<br />;   // &#40;only increase if not too close to average, <br />;   // so that this isn't triggered by jitter alone&#41; <br />   .if !bClose <br />      inc same_side<br />    .endif<br /><br />;   // <br />;   // determine filter gain, based on above characteristics. <br />;   // <br /><br />;   // ignore &#40;gain -&gt; 0&#41; large jumps. <br />   .if bJumped<br />     fld bias<br />     fsub r4_4_0;      bias -= 4.0; <br />     fstp bias<br /><br />;   // don't let a &quot;bounce&quot; affect things too much. <br />   .elseif bBounced<br />     fld bias<br />     fsub r4_1_0;      bias -= 1.0; <br />     fstp bias   <br /><br />;// otherwise, function is normal here. <br />   .else <br />;      // function is changing, we need to track it rapidly. <br />;      // note&#58; check close again so we aren't too loose if the function <br />;      // comes closer to the average again &#40;meaning it probably <br />;      // wasn't really changing&#41;. <br />      .if &#40;same_side &gt;= 2&#41; &amp;&amp; !bClose<br />         fld same_side          ;         bias += min&#40;same_side, 4&#41;; <br />         fcomp r4_4_0<br />         __FJL @F<br />         fld r4_4_0<br />         jmp past<br />@@&#58; fild same_side<br />past&#58; fadd bias<br />         fstp bias<br />   .endif<br /><br />;   // bias = 0&#58; no change. &gt; 0&#58; increase &#40;n-th root&#41;. &lt; 0&#58; decrease &#40;^n&#41; <br />   double e = &#40;bias &gt; 0&#41;? 1.0 / bias &#58; -bias; <br />   if&#40;e == 0.0&#41; e = 1.0; <br />   gain = pow&#40;0.08, e&#41;; <br />      // default&#58; fairly insensitive to changes &#40;~= 16 sample average&#41; <br /><br /><br />   // IIR filter <br />   static double old = 30.0; <br />   old = cur_fps*gain + old*&#40;1.0-gain&#41;; <br />   avg_fps = old; <br /><br />   // update fps counter if it differs &quot;enough&quot; <br />   // currently, that means off by more than 5 FPS or 5%. <br />   const double difference = fabs&#40;avg_fps-fps&#41;; <br />   const double threshold = fminf&#40;5.f, 0.05f*fps&#41;; <br />   if&#40;difference &gt; threshold&#41; <br />      fps = &#40;int&#41;avg_fps; <br /></code></pre></div>
    <div class="meta">Posted on 2004-11-22 14:46:26 by Homer</div>
   </div>
  </div>
 </body>
</html>