<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Linked-List object arrays in MASM - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=7361" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=7361">Linked-List object arrays in MASM</a></p>
   <div class="post" id="post-53406">
    <div class="subject"><a href="#post-53406">Linked-List object arrays in MASM</a></div>
    <div class="body">Here's my 20 cents worth - singly-linked bidirectional Linked List arrays...<br /> - hope ya like it :)<br /><pre><code><br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />;Notes from the Author;<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />;<br />;The following Procedures were coded by EvilHomer at 3&#58;54 in the morning.<br />;They are all that is required for basic management of<br />;multiple simultaneous Linked Lists,<br />;provided all entries are of the same type &#40;one type of Entry, one type of List&#41;.<br />;If you like this code, we can improve it so that<br />;it can take another param for the type of LinkedObject &#40;type of List&#41;.<br />;<br />;AddEntry - input param lpPrev is pointer to last entry before the new one<br />;         - ie which entry to insert or append the new one behind...<br />;         - For a new list, theres no Parent, so you can use NULL<br />;         - Procedure handles insertions as well as appending.<br />;         - Return value is pointer to the new entry,<br />;         - Return value NULL indicates failure.<br />;<br />;KillEntry- input param lpThis is pointer to entry to be deleted. Simple.<br />;         - Procedure handles link patching intelligently.<br />;         - No return value.<br />;<br />;-------------------------------------------------------------------<br />;Structure of an Entry in a Linked List<br />;-------------------------------------------------------------------<br /><br />LinkedObject STRUCT     ;Example structure is minimal - add some more fields to it &#58;&#41;<br />    pPrev DWORD ?       ;Pointer to my daddy if I have one &#40;previous&#41;<br />    pNext DWORD ?       ;Pointer to my child if I have one &#40;next&#41;<br />    pLock DWORD ?       ;handle for freeing this memory<br />LinkedObject ENDS<br /><br />;-------------------------------------------------------------------<br />;KillEntry Procedure<br />;-Removes an entry from a Linked-List.<br />;-Examines Parent&lt;--&lt;THIS&gt;--&gt;Child links and<br />;-Patches- Parent&lt;--&gt;Child &#40;Bypassing Self&#41;.<br />;-Also detects and patches NewRoot and NewLast nodes.<br />;-Releases the allocated memory used by the killed entry.<br />;-In other words, flawless and transparent removal<br />;-of a single entry in our List.<br />;-------------------------------------------------------------------<br /><br />KillEntry PROC lpThis&#58;PTR LinkedObject    ;pointer to entry to be deleted<br /><br />    mov esi,&#91;lpThis&#93;.pPrev          ;&#40;Fetch possible Parent&#41;<br />    .if esi !=0                     ;I have a Parent and thus am not Root..<br />        mov edi,&#91;lpThis&#93;.pNext      ;&#40;Fetch possible Child&#41;<br />        .if esi !=0                   ;..and I also have a Child..<br />            push edi                    ;&#40;ChildPointer&#41;<br />            pop &#91;esi&#93;.lpNext            ;link Parent to Child, bypassing me<br />            push esi                    ;&#40;ParentPointer&#41;<br />            pop &#91;edi&#93;.lpPrev            ;link Child to Parent, bypassing me<br />        .else                       ;..and I have no Child..<br />            mov &#91;esi&#93;.lpNext,NULL       ;Kill Parent's link to me<br />        .endif                          ;&#40;setting it as Last&#41;<br /><br />    .else                           ;I am Root and have no Parent..<br />        mov edi,&#91;lpThis&#93;.pNext      ;&#40;Fetch possible Child&#41;<br />        .if esi !=0                   ;..but I do have a Child<br />            mov &#91;edi&#93;.lpPrev,NULL       ;Kill Child's link to Parent<br />        .endif                          ;&#40;setting it as Root&#41;<br />    .endif     ; &#40;no parent and no child? alone? nothing to repair then&#41;<br />    mov eax,&#91;lpThis&#93;.pLock          ;This bit happens regardless...<br />    push eax                        ;&#40;handle to memory object&#41;<br />    invoke GlobalUnlock,eax         ;Unlock this memory<br />    pop eax                         ;&#40;handle to memory object&#41;<br />    invoke GlobalFree,eax           ;Release this memory<br />    return TRUE                     ;cya<br />KillEntry ENDP<br /><br />;-------------------------------------------------------------------<br />;NewEntry Procedure<br />;-Adds an entry to a Linked-List...<br />;-Allocates memory for a new entry,<br />;-Examines Parent&lt;---&gt;Child links and<br />;-Patches- Parent&lt;--&lt;THIS&gt;--&gt;Child &#40;Inserting Self&#41;.<br />;-Bidirection links are preserved.<br />;-------------------------------------------------------------------<br />NewEntry PROC lpPrev&#58;PTR LinkedObject    ;Pointer to Previous entry<br />LOCAL lpThis,lpOldChild&#58;PTR LinkedObject<br />LOCAL hMem&#58;DWORD<br /><br />    szText szGAE,&quot;GlobalAlloc err #%lu&quot;<br />    szText szGLE,&quot;GlobalLock err #%lu&quot;<br /><br />    invoke GlobalAlloc,GHND,sizeof LinkedObject<br />    mov hMem,eax<br />    .if eax != NULL<br />        invoke GlobalLock,hMem<br />        .if eax != NULL<br />            mov lpThis,eax<br />            push hMem<br />            pop  &#91;lpThis&#93;.pLock     ;Remember my unlock handle               <br />            mov esi,lpPrev<br />            push &#91;esi&#93;.lpNext<br />            pop lpOldChild          ;store possible child<br />            .if esi != NULL             ;I have a Parent and thus am not Root<br />                push lpThis<br />                pop &#91;esi&#93;.lpNext        ;Tell Parent hes my new daddy- APPENDING<br />                push lpPrev<br />                pop &#91;lpThis&#93;.lpPrev     ;Tell Myself I have a Parent<br />                .if lpOldChild != NULL  ;and that Parent had a Child - INSERTING!<br />                    push lpThis<br />                    pop  &#91;lpOldChild&#93;.lpPrev ;Tell Child I'm their new sugardaddy<br />                    push lpOldChild<br />                    pop &#91;lpThis&#93;.lpNext      ;Tell Myself I have a Child<br />                .endif                  ;I have no kids to worry about or<br />            .endif                      ;I am Root with No Parent and No Child           <br />            return lpThis               ;Return pointer to the new Object in EAX<br />        .else                   ;GlobalLock failed...<br />            invoke GetLastError<br />            invoke wsprintf,addr ErrBuf,addr szGLE,eax<br />            invoke MessageBox,addr szGLE,addr szDisplayName,MB_OK+MB_ICONERROR<br />            invoke GlobalFree,hMem  ;Free the memory we Failed to Lock<br />        .endif<br />    .else                       ;GlobalAlloc failed...<br />        invoke GetLastError<br />        invoke wsprintf,addr ErrBuf,addr szGAE,eax<br />        invoke MessageBox,addr szGAE,addr szDisplayName,MB_OK+MB_ICONERROR<br />    .endif<br />    xor eax,eax<br />    ret             ;Return ERROR in eax since we have Failed<br /><br />AddEntry ENDP<br /><br />;-------------------------------------------------------------------<br /></code></pre><br />Any thoughts on this ever-popular topic?<br /><br />added [ code][ /code] block - scronty</div>
    <div class="meta">Posted on 2002-08-15 01:31:24 by Homer</div>
   </div>
   <div class="post" id="post-53454">
    <div class="subject"><a href="#post-53454">Linked-List object arrays in MASM</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br />Attached is an example based upon the code you posted.<br /><br />I've also added a new proc (KillEntryPlusChildren) which, as you can see by the name, deletes the given node, plus its children.<br /><br />It'll be interesting to see how this progresses. There're linked-list examples in other forums here, so we might as well make this one more Game Programming related.<br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2002-08-15 08:37:29 by Scronty</div>
   </div>
   <div class="post" id="post-53485">
    <div class="subject"><a href="#post-53485">Linked-List object arrays in MASM</a></div>
    <div class="body">Nice idea, a good addition, killing children recursively...<br />heres the code from later that day after I'd had some sleep...<br />It is much better as it can handle objects yet to be defined,<br />and can handle objects of differing sizes within a single list.<br />Also I cleared up those lil typo's due to tiredness..<br /><pre><code><br />;;;;;;;;;;;;;;;;;;;;;;;<br />;Notes from the Author;<br />;;;;;;;;;;;;;;;;;;;;;;;<br />;<br />;The following Procedures were coded by EvilHomer at 3&#58;54 in the morning of August 15 2002.<br />;They were first modified at 9&#58;00 pm of the same day.<br />;References to false LinkedObject fields corrected.<br />;Code in AddEntry altered to include an ObjectSize param for new entries,<br />;and to use that rather than sizeof LinkedObject.<br /><br />;Since the functions provided here assumes that the  Object they are<br />;creating or destroying is a LinkedObject and make no OTHER assumptions<br />;about the true nature of the Object they are creating or destroying,<br />;if we simply ensure that all our Objects begin with a LinkedObject as<br />;a Header, then any Object Pointer can become a Linked List!!<br />;Make sure that all Objects to be stored this way have a Structure Definition<br />;which begins with a LinkedObject entity.<br />;This means we can basically treat AddEntry in the same way as <br />;a C++ coder would use the &quot;new&quot; directive.<br /><br />;AddEntry - input param lpPrev is pointer to last entry before the new one<br />;         - ie which entry to insert or append the new one behind...<br />;         - For a new list, theres no Parent, so you can use NULL<br />;         - Procedure handles insertions as well as appending.<br />;         - Return value is pointer to the new entry.<br />;<br />;KillEntry- input param lpThis is pointer to entry to be deleted. Simple.<br />;         - Procedure handles link patching intelligently.<br />;         - No return value.<br />;<br /><br />;-------------------------------------------------------------------<br />;Structure of an Entry in a Linked List<br />;-------------------------------------------------------------------<br /><br />LinkedObject STRUCT     ;Example structure is minimal - add some more fields to it &#58;&#41;<br />    pPrev DWORD ?       ;Pointer to my daddy if I have one &#40;previous&#41;<br />    pNext DWORD ?       ;Pointer to my child if I have one &#40;next&#41;<br />    pLock DWORD ?       ;handle for freeing this memory<br />LinkedObject ENDS<br /><br />;-------------------------------------------------------------------<br />;KillEntry Procedure<br />;-Removes an entry from a Linked-List.<br />;-Examines Parent&lt;--&lt;THIS&gt;--&gt;Child links and<br />;-Patches- Parent&lt;--&gt;Child &#40;Bypassing Self&#41;.<br />;-Also detects and patches NewRoot and NewLast nodes.<br />;-Releases the allocated memory used by the killed entry.<br />;-In other words, flawless and transparent removal<br />;-of a single entry in our List.<br />;-------------------------------------------------------------------<br /><br />KillEntry PROC lpThis&#58;PTR LinkedObject    ;pointer to entry to be deleted<br /><br />    mov esi,&#91;lpThis&#93;.pPrev          ;&#40;Fetch possible Parent&#41;<br />    .if esi !=0                     ;I have a Parent and thus am not Root..<br />        mov edi,&#91;lpThis&#93;.pNext      ;&#40;Fetch possible Child&#41;<br />        .if esi !=0                   ;..and I also have a Child..<br />            push edi                    ;&#40;ChildPointer&#41;<br />            pop &#91;esi&#93;.pNext            ;link Parent to Child, bypassing me<br />            push esi                    ;&#40;ParentPointer&#41;<br />            pop &#91;edi&#93;.pPrev            ;link Child to Parent, bypassing me<br />        .else                       ;..and I have no Child..<br />            mov &#91;esi&#93;.pNext,NULL       ;Kill Parent's link to me<br />        .endif                          ;&#40;setting it as Last&#41;<br /><br />    .else                           ;I am Root and have no Parent..<br />        mov edi,&#91;lpThis&#93;.pNext      ;&#40;Fetch possible Child&#41;<br />        .if esi !=0                   ;..but I do have a Child<br />            mov &#91;edi&#93;.pPrev,NULL       ;Kill Child's link to Parent<br />        .endif                          ;&#40;setting it as Root&#41;<br />    .endif     ; &#40;no parent and no child? alone? nothing to repair then&#41;<br />    mov eax,&#91;lpThis&#93;.pLock          ;This bit happens regardless...<br />    push eax                        ;&#40;handle to memory object&#41;<br />    invoke GlobalUnlock,eax         ;Unlock this memory<br />    pop eax                         ;&#40;handle to memory object&#41;<br />    invoke GlobalFree,eax           ;Release this memory<br />    return TRUE                     ;cya<br />KillEntry ENDP<br /><br />;-------------------------------------------------------------------<br />;NewEntry Procedure<br />;-Adds an entry to a Linked-List...<br />;-Allocates memory for a new entry,<br />;-Examines Parent&lt;---&gt;Child links and<br />;-Patches- Parent&lt;--&lt;THIS&gt;--&gt;Child &#40;Inserting Self&#41;.<br />;-Bidirection links are preserved.<br />;-------------------------------------------------------------------<br />NewEntry PROC lpPrev&#58;PTR LinkedObject, ObjectSize&#58;DWORD<br />LOCAL lpThis,lpOldChild&#58;PTR LinkedObject<br />LOCAL hMem&#58;DWORD<br /><br />    szText szGAE,&quot;GlobalAlloc err #%lu&quot;<br />    szText szGLE,&quot;GlobalLock err #%lu&quot;<br /><br />    invoke GlobalAlloc,GHND,ObjectSize<br />    mov hMem,eax<br />    .if eax != NULL<br />        invoke GlobalLock,hMem<br />        .if eax != NULL<br />            mov lpThis,eax<br />            push hMem<br />            pop  &#91;lpThis&#93;.pLock     ;Remember my unlock handle               <br />            mov esi,lpPrev<br />            push &#91;esi&#93;.pNext<br />            pop lpOldChild          ;store possible child<br />            .if esi != NULL             ;I have a Parent and thus am not Root<br />                push lpThis<br />                pop &#91;esi&#93;.pNext        ;Tell Parent hes my new daddy- APPENDING<br />                push lpPrev<br />                pop &#91;lpThis&#93;.pPrev     ;Tell Myself I have a Parent<br />                .if lpOldChild != NULL  ;and that Parent had a Child - INSERTING!<br />                    push lpThis<br />                    pop  &#91;lpOldChild&#93;.pPrev ;Tell Child I'm their new sugardaddy<br />                    push lpOldChild<br />                    pop &#91;lpThis&#93;.pNext      ;Tell Myself I have a Child<br />                .endif                  ;I have no kids to worry about or<br />            .endif                      ;I am Root with No Parent and No Child           <br />            return lpThis               ;Return pointer to the new Object in EAX<br />        .else                   ;GlobalLock failed...<br />            invoke GetLastError<br />            invoke wsprintf,addr ErrBuf,addr szGLE,eax<br />            invoke MessageBox,addr szGLE,addr szDisplayName,MB_OK+MB_ICONERROR<br />            invoke GlobalFree,hMem  ;Free the memory we Failed to Lock<br />        .endif<br />    .else                       ;GlobalAlloc failed...<br />        invoke GetLastError<br />        invoke wsprintf,addr ErrBuf,addr szGAE,eax<br />        invoke MessageBox,addr szGAE,addr szDisplayName,MB_OK+MB_ICONERROR<br />    .endif<br />    xor eax,eax<br />    ret             ;Return ERROR in eax since we have Failed Like Foo<br /><br /><br />AddEntry ENDP<br /><br />;-------------------------------------------------------------------<br /></code></pre><br />added [ code][ /code] block, and changed the expletive to &quot;foo&quot; - Scronty</div>
    <div class="meta">Posted on 2002-08-15 11:15:29 by Homer</div>
   </div>
   <div class="post" id="post-53486">
    <div class="subject"><a href="#post-53486">Linked-List object arrays in MASM</a></div>
    <div class="body">I have implemented it similarly to the &quot;new&quot; directive in C++<br />I can invoke NewEntry,pSpaceShips,sizeof SpaceShip for example.<br />Since Linked Lists have bad access-time symmetry, I implement multiple Lists<br />to keep Bullets, Enemies, etc.<br />This way I can perform faster searches and reduce linear access times.</div>
    <div class="meta">Posted on 2002-08-15 11:23:02 by Homer</div>
   </div>
   <div class="post" id="post-53488">
    <div class="subject"><a href="#post-53488">Linked-List object arrays in MASM</a></div>
    <div class="body">Please omit and excuse the obscenity in the final comments.</div>
    <div class="meta">Posted on 2002-08-15 11:35:34 by Homer</div>
   </div>
   <div class="post" id="post-53535">
    <div class="subject"><a href="#post-53535">Linked-List object arrays in MASM</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br />Attached is the example proggy with the adjusted AddEntry proc (ObjectSize).<br /><br />I've also added Sibling fieldnames in the LINKEDOBJECT structure. No procs for them yet.<br />With Siblings, you can have your Bullets/Power/Shields/etc included inside the same main object, and search each Siblings' list individually.<br /><br />Also added is a couple of Application-Specific fields. These are fields which would be different from application-to-application.<br />The fields are pName and hNameLock, following the convention of the other fields.<br />The NewName and KillName procs are implemented and working.<br />I've placed the KillName calls inside the Kill* procs for the nodes themselves, so that the cleanup process is less visible (i.e. with a few fieldnames, it'd be awkward to have to call each Kill&lt;fieldname&gt; for each field).<br /><br />The NewName proc will have to be adjusted so that it takes into account any prior allocated Name memory.<br /><br />NOTE: I've changed the &quot;lock&quot; fields to use a prepended 'h' instead of 'p', as these are handles, and not necessarily memory pointers (though they sometimes seem to be the same thing).<br /><br />For faster search qualities, there could be an option to have an <strong>index</strong> structure as the root, which holds pointers to each Child or Sibling. <br />The idea being, that a &quot;level&quot; or &quot;object&quot; would be generated before the gamelevel begins.<br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2002-08-15 20:47:02 by Scronty</div>
   </div>
   <div class="post" id="post-53567">
    <div class="subject"><a href="#post-53567">Linked-List object arrays in MASM</a></div>
    <div class="body">Bidirectional siblings, eh?<br />Nice one !!<br />Very powerful feature, basically our LinkedList just became a rudimentary Neural Network !!<br /><br />My interpretation of the Siblings approach would be to actually keep different types of Objects in the main Tree, and to have each list of Siblings represent similar Objects in that Group, which could in turn be Parented to an Owner or Creator...<br /><br />example .. particles emitted by a particle emitter would have other particles from that emitter as siblings, would have the emitter as parent, and then we could use the child to indicate a subparticle owned by the particle.<br /><br />Players would have a bunch of weapons but only have one equipped at a time.<br />That weapon would be the player's child weapon, and its siblings would include all the other weapons available to the player. All those siblings are owned by the same parent, and in the same way we can parent flying bullets to their creators/originators so that a bullet &quot;knows who fired it&quot;.<br /><br />I would have assumed that the unique address of a given instanced object would be enough of a unique identifier, but the strings approach would sure make a game-editor much clearer :)<br /><br />ok since we are going down the track of multilinkig (siblings) we may as well go the whole hog and implement the parent/child links as pointers to two lists of N parents and N children, giving us the full power of a Neural Network array, as older/younger siblings are basically a secondary parent/child set.<br />This way an object may be Owned by N objects, and may in turn Own N objects.<br /><br />What u think?</div>
    <div class="meta">Posted on 2002-08-16 03:32:23 by Homer</div>
   </div>
   <div class="post" id="post-53632">
    <div class="subject"><a href="#post-53632">Linked-List object arrays in MASM</a></div>
    <div class="body">We don't need more parent branches, but N children would be nice.<br /><br />Here's another couple of procs,<br />one for the LinkedList include, and one for the GameObjects include...<br /><pre><code>FindYoungestSibling PROC lpThis&#58;LPLINKEDOBJECT<br />    mov esi,lpThis<br />    assume esi&#58;ptr LinkedObject    <br />    .while &#91;esi&#93;.pYoungerSibling        ;while there's a younger sibling<br />        mov esi,&#91;esi&#93;.pYoungerSibling   ;walk to that younger sibling<br />    .endw<br />    assume esi&#58;nothing<br />    return esi                          ;return the address of the youngest sibling<br />FindYoungestSibling ENDP<br /><br />AddPlayer PROC lpPlayers&#58;DWORD,lpPlayerName&#58;DWORD<br />LOCAL lpThis&#58;PTR LinkedPlayerObject<br />    invoke FindYoungestSibling,lpPlayers            ;Ensure we are Appending<br />    invoke NewEntry,eax,sizeof LinkedPlayerObject   ;create memory object for Player<br />    mov lpThis,eax<br />    invoke NewName,lpThis,lpPlayerName              ;Set Name in Linked PlayerObject<br />    m2m &#91;lpThis&#93;.Weapon,lpDefaultWeapon           ;Initialize new Player further<br />    m2m &#91;lpThis&#93;.Score,NULL                                   ;prolly need more here<br />    inc NumPlayers<br />    return TRUE<br />AddPlayer ENDP</code></pre></div>
    <div class="meta">Posted on 2002-08-16 11:13:49 by Homer</div>
   </div>
   <div class="post" id="post-53756">
    <div class="subject"><a href="#post-53756">Linked-List object arrays in MASM</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br />I've begun implementing the Sibling code.<br />Also implemented is the FindYoungestSibling proc (which is used in the appending of new Siblings).<br /><br />Attached is a zip of the EXE only, since the code is still in the middle of development.<br /><br />I've had to split the AddEntry proc into two procs. One for Appending, and one for Insertion. This is because (as you already realise) there isn't any fundamental difference between a Parent/Child relationship and an OlderSibling/YoungerSibling relationship.<br /><br />The way the Append proc works is, if the given Parent hasn't got a Child, then a Child is appended. If the Parent already has a Child, then a Sibling of that Child is appended.<br />The Insertion proc hasn't been built yet. However this, I would imagine, would require a param which told the proc whether a Child or a Sibling is being Inserted.<br /><br />An Update proc will also be required, so that a current Sibling could be made a Child, or a current Child could be made into a Sibling.<br /><br />As you can see by the proggy, I've also begun a visual representation of the linked list.<br />It displays the whole list correctly (i.e. every object in the list can be displayed), however I still have to build some kind of &quot;auto-alignment&quot; proc for drawing the text. Any Siblings are offset to the right by 100 pixels. This means that any Siblings of Mesh1 will overwrite the text to the right of it.<br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2002-08-17 08:25:52 by Scronty</div>
   </div>
   <div class="post" id="post-53810">
    <div class="subject"><a href="#post-53810">Linked-List object arrays in MASM</a></div>
    <div class="body">I have a complete linked list here <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=3179&amp;highlight=linked+list">http://www.asmcommunity.net/board/index.php?topic=3179&amp;highlight=linked+list</a><br /><br />I did a little coding on state and process management based on the concept of stacked linked list.<br /><br />I hope this will help. :alright:</div>
    <div class="meta">Posted on 2002-08-17 17:12:17 by stryker</div>
   </div>
   <div class="post" id="post-53887">
    <div class="subject"><a href="#post-53887">Linked-List object arrays in MASM</a></div>
    <div class="body">Here's my version:<br /><br /><pre><code><br />; #########################################################################<br />; LinkedList.inc<br />; The following code is for educational purposes only.<br />; However, since linkedlists are a fundamental part of programming,<br />; feel free to use this file as you please.<br />; #########################################################################<br />;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />; Initial Linkedlist Code&#58;<br />;             KillEntry, AddEntry, plus initial structure<br />;             EvilHomer2k,  15 August 2002, 3&#58;54 in the morning.<br />;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />; Initial Example Program&#58;<br />;             bug fixes, and the addition of KillEntryPlusChildren<br />;             Scronty,      15 August 2002, 11&#58;24pm.<br />;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />; Initial Linkedlist Code Update&#58;<br />;             References to false LinkedObject fields corrected.<br />;             Code in AddEntry altered to include an ObjectSize param for<br />;             new entries.<br />;             EvilHomer2k,  15 August 2002, 9&#58;00 pm.<br />;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />; Example Program Update&#58;<br />;             Implemented EvilHomer2ks altered AddEntry param &#40;ObjectSize&#41;.<br />;             Added Sibling fieldnames in LINKEDOBJECT struct &#40;no procs&#41;.<br />;             Added Application-Specific fieldnames in LINKEDOBJECT<br />;             struct &#40;NAME&#41;.<br />;             Added NewName and KillName procs for the NAME fieldnames.<br />;             Scronty,      16 August 2002, 11&#58;08am.<br />;             --------<br />;             Changed name of AddEntry procedure to AddChildEntry.<br />;             Added procedure&#58; AddSiblingEntry<br />;             Added procedure&#58; KillEntryPlusYoungerSiblings<br />;             Modified procedure&#58; KillEntry to also patch Sibling links.<br />;             EvilHomer,    18 August 2002, 11&#58;02pm.<br />;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />; Current Table of Procedures&#58;<br />; ============================<br />; -AddChildEntry<br />; -AddSiblingEntry<br />; -NewName<br />; -KillName<br />; -KillEntry                    &#40;not recursive&#41;&#40;Checks all links&#41;<br />; -KillEntryPlusChildren        &#40;recursive&#41;&#40;does not check Sibling links&#41;<br />; -KillEntryPlusYoungerSiblings &#40;recursive&#41;&#40;does not check Parent-Child links&#41;<br />;<br />;-------------------------------------------------------------------<br />;Structure of an Entry in a Linked List<br />;-------------------------------------------------------------------<br /><br />_LINKEDOBJECT STRUCT    ;Example structure is minimal - add some more fields to it<br /><br />    ; Everything between the &quot;~~~~&quot; lines are mandatory.<br />    ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />    pParent           DWORD ?       ;Pointer to my parent if I have one &#40;Parent&#41;<br />    pChild            DWORD ?       ;Pointer to my child if I have one &#40;Child&#41;<br />    pOlderSibling     DWORD ?       ;Pointer to my older sibling if I have one &#40;Older Sibling&#41;<br />    pYoungerSibling   DWORD ?       ;Pointer to my younger sibling if I have one &#40;Younger Sibling&#41;<br />    hLock             DWORD ?       ;Handle for freeing this memory<br />    ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br /><br />    ; Add Application-Specific fields here<br />    ;_____________________________________<br />    ; NAME<br />    pName     DWORD ?       ;Pointer to the name of this object &#40;Name&#41;<br />    hNameLock DWORD ?       ;Handle for freeing the Names' memory<br />    ;_____________________________________<br /><br />_LINKEDOBJECT ENDS<br />    LINKEDOBJECT        TYPEDEF   _LINKEDOBJECT<br />    LPLINKEDOBJECT      TYPEDEF   PTR _LINKEDOBJECT<br /><br />; #########################################################################<br /><br />; macros&#58;<br />; CTEXT macro<br />; eg.<br />; invoke MessageBox, NULL, CTEXT&#40;&quot;Hello World!&quot;&#41;, NULL, MB_OK<br />CTEXT macro y&#58;vararg<br />    local sym<br /><br />    const segment<br />	<br />    ifidni &lt;y&gt;, &lt;&gt;<br />        sym db 0<br />    else<br />        sym db y, 0<br />    endif<br />    const ends<br />    exitm &lt;offset sym&gt;<br />endm<br />;## 'return' Macro ##<br />return MACRO returnvalue<br />    mov eax, returnvalue<br />    ret<br />ENDM<br /><br />; #########################################################################<br />.data <br /><br />    ERRbuff              db      128 DUP &#40;0&#41;<br /><br />; #########################################################################<br />.code<br />KillName PROC lpThis&#58;PTR LINKEDOBJECT<br />    push edi<br /><br />    mov eax, lpThis<br />    mov edi, eax<br /><br />    .if &#91;edi&#93;.LINKEDOBJECT.hNameLock != NULL                  ;I have a Name<br />        mov eax,&#91;edi&#93;.LINKEDOBJECT.hNameLock                  ;This bit happens regardless...<br />        invoke GlobalUnlock,eax                               ;Unlock this memory<br />        mov eax,&#91;edi&#93;.LINKEDOBJECT.hNameLock                  ;Grab the handle to this memory<br />        invoke GlobalFree,eax                                 ;Release this memory<br />        ;_____________________________________<br />        ;Null-out Name fields<br />        mov &#91;edi&#93;.LINKEDOBJECT.pName, NULL<br />        mov &#91;edi&#93;.LINKEDOBJECT.hNameLock, NULL<br />        ;_____________________________________<br /><br />        invoke MessageBox,NULL,CTEXT&#40;&quot;Killed Name!&quot;&#41;,CTEXT&#40;&quot;Success!&quot;&#41;,MB_OK<br />    .endif<br /><br />    pop edi<br /><br />    return TRUE<br />KillName  ENDP<br /><br />NewName PROC lpThis&#58;PTR LINKEDOBJECT, pszNewName&#58;DWORD<br />LOCAL dwSize&#58;DWORD<br /><br />    push edi<br />    push esi<br /><br />    mov eax, lpThis<br />    mov edi, eax<br /><br />    ;________________________________<br />    ;Get the string length<br />    mov eax, pszNewName<br />    @@&#58;<br />    mov dl, &#91;eax&#93;<br />    inc eax<br />    cmp dl, 0<br />    jne @B<br />    sub eax, pszNewName<br />    dec eax               ;  correct count<br />    mov dwSize, eax<br />    ;________________________________<br />    mov eax, dwSize<br />    inc eax<br />    invoke GlobalAlloc,GPTR,eax                               ;Allocate memory for name<br />    mov &#91;edi&#93;.LINKEDOBJECT.hNameLock, eax                     ;Remember the unlock handle<br />    .if eax != NULL<br />        invoke GlobalLock,&#91;edi&#93;.LINKEDOBJECT.hNameLock<br />        mov &#91;edi&#93;.LINKEDOBJECT.pName, eax<br />        .if eax != NULL<br />            ;________________________________<br />            ;Copy name into allocated memory<br />            cld<br />            mov esi, &#91;pszNewName&#93;<br />            mov eax, &#91;edi&#93;.LINKEDOBJECT.pName<br />            mov edi, eax<br />            mov ecx, dwSize<br />            <br />            shr ecx, 2<br />            rep movsd<br />            <br />            mov ecx, dwSize<br />            and ecx, 3<br />            rep movsb<br />            inc edi<br />            mov BYTE PTR &#91;edi&#93;, 0                             ;Appended a 0<br />            ;________________________________<br /><br />            mov eax, lpThis<br />            invoke MessageBox,NULL,CTEXT&#40;&quot;Added Name!&quot;&#41;,&#91;eax&#93;.LINKEDOBJECT.pName,MB_OK<br /><br />            ;Return the node-pointer back to the caller<br />            mov eax, lpThis<br />            pop esi<br />            pop edi<br />            return eax                                        ;Return pointer to the new Object in EAX<br />        .else                                                 ;GlobalLock failed...<br />            invoke GetLastError<br />            invoke wsprintf,addr ERRbuff,CTEXT&#40;&quot;GlobalLock err #%lu&quot;&#41;,eax<br />            invoke MessageBox,NULL, addr ERRbuff,CTEXT&#40;&quot;Error!&quot;&#41;,MB_OK+MB_ICONERROR<br />            invoke GlobalFree,&#91;edi&#93;.LINKEDOBJECT.hNameLock          ;Free the memory we Failed to Lock<br />            mov &#91;edi&#93;.LINKEDOBJECT.hNameLock, NULL<br />        .endif<br />    .else                                                     ;GlobalAlloc failed...<br />        invoke GetLastError<br />        invoke wsprintf,addr ERRbuff,CTEXT&#40;&quot;GlobalAlloc err #%lu&quot;&#41;,eax<br />        invoke MessageBox,NULL,addr ERRbuff,CTEXT&#40;&quot;Error!&quot;&#41;,MB_OK+MB_ICONERROR<br />    .endif<br /><br />    pop esi<br />    pop edi<br /><br />    xor eax,eax<br />    ret                                                       ;Return ERROR in eax since we have Failed<br /><br />NewName ENDP<br /><br /><br />;-------------------------------------------------------------------<br />;KillEntry Procedure<br />;-Removes an entry from a Linked-List.<br />;-Revised to handle parent-child and/or sibling links.<br />;-Examines Parent&lt;--&lt;THIS&gt;--&gt;Child links and<br />;-Patches- Parent&lt;--&gt;Child &#40;Bypassing Self&#41;.<br />;-Examines OlderSibling&lt;--&lt;THIS&gt;--YoungerSibling links and<br />;-Patches- OlderSibling&lt;--&gt;YoungerSibling &#40;Bypassing Self&#41;.<br />;-Also detects and patches NewRoot and NewLast nodes.<br />;-Releases the allocated memory used by the killed entry.<br />;-In other words, flawless and transparent removal<br />;-of a single entry in our List.<br />;-------------------------------------------------------------------<br />KillEntry PROC lpThis&#58;PTR LinkedObject    ;pointer to entry to be deleted<br />    push edi<br />    push esi<br /><br />    mov eax, lpThis<br />    mov edi, eax<br /><br />    ;Kill any Name for this node<br />    invoke KillName, edi<br /><br />    .if &#40;&#91;edi&#93;.LINKEDOBJECT.pParent != NULL&#41; || &#40;&#91;edi&#93;.LINKEDOBJECT.pOlderSibling != NULL&#41;  ;I have a Parent and thus am not Root..<br />        .if &#91;edi&#93;.LINKEDOBJECT.pChild != NULL              ;..and I also have a Child..<br />            mov eax, &#91;edi&#93;.LINKEDOBJECT.pParent            ;&#40;fetch ParentPointer&#41;<br />            mov esi, eax<br />            mov eax, &#91;edi&#93;.LINKEDOBJECT.pChild             ;&#40;fetch ChildPointer&#41;<br />            mov &#91;esi&#93;.LINKEDOBJECT.pChild, eax             ;link Parent to Child, bypassing me<br />            mov eax, &#91;edi&#93;.LINKEDOBJECT.pChild             ;&#40;ChildPointer&#41;      <br />            mov esi, eax<br />            mov eax, &#91;edi&#93;.LINKEDOBJECT.pParent             ;&#40;ParentPointer&#41;<br />            mov &#91;esi&#93;.LINKEDOBJECT.pParent, eax             ;link Child to Parent, bypassing me<br />        .else                                               ;..and I have no Child..<br />            mov eax, &#91;edi&#93;.LINKEDOBJECT.pParent<br />            mov esi, eax<br />            mov &#91;esi&#93;.LINKEDOBJECT.pChild,NULL             ;Kill Parent's link to me<br />        .endif<br />        ;----------<br />        .if &#91;edi&#93;.LINKEDOBJECT.pYoungerSibling !=NULL  ;..and I have a younger sibling<br />            mov eax, &#91;edi&#93;.LINKEDOBJECT.pOlderSibling<br />            mov esi,eax<br />            mov eax,&#91;edi&#93;.LINKEDOBJECT.pYoungerSibling<br />            mov &#91;esi&#93;.LINKEDOBJECT.pYoungerSibling,eax<br />            mov eax,&#91;edi&#93;.LINKEDOBJECT.pYoungerSibling<br />            mov esi,eax<br />            mov eax,&#91;edi&#93;.LINKEDOBJECT.pOlderSibling<br />            mov &#91;esi&#93;.LINKEDOBJECT.pOlderSibling,eax<br />        .else                                               ;..I have no younger sibling..<br />            mov eax, &#91;edi&#93;.LINKEDOBJECT.pOlderSibling<br />            mov esi, eax<br />            mov &#91;esi&#93;.LINKEDOBJECT.pYoungerSibling,NULL     ;Kill Parent's link to me<br />       .endif                                            ;&#40;setting it as Last&#41;<br />        invoke MessageBox,NULL,CTEXT&#40;&quot;killed Child!&quot;&#41;,CTEXT&#40;&quot;Success!&quot;&#41;,MB_OK<br /><br />    .else                                                 ;I am Root and have no Parent..<br />        .if &#91;edi&#93;.LINKEDOBJECT.pChild != NULL              ;..but I do have a Child<br />            mov eax, &#91;edi&#93;.LINKEDOBJECT.pChild<br />            mov esi, eax<br />            mov &#91;esi&#93;.LINKEDOBJECT.pParent,NULL           ;Kill Child's link to Parent<br />        .endif                                            ;&#40;setting it as Root&#41;<br />        .if &#91;edi&#93;.LINKEDOBJECT.pYoungerSibling != NULL    ;..but I do have a Child<br />            mov eax, &#91;edi&#93;.LINKEDOBJECT.pYoungerSibling<br />            mov esi, eax<br />            mov &#91;esi&#93;.LINKEDOBJECT.pOlderSibling,NULL     ;Kill Child's link to Parent<br />        .endif                                            ;&#40;setting it as Root&#41;<br />        <br />        invoke MessageBox,NULL,CTEXT&#40;&quot;killed Root!&quot;&#41;,CTEXT&#40;&quot;Success!&quot;&#41;,MB_OK<br />    .endif   <br /><br />    ; &#40;no parent and no child? alone? nothing to repair then&#41;<br /><br />    mov eax,&#91;edi&#93;.LINKEDOBJECT.hLock                      ;This bit happens regardless...<br />    invoke GlobalUnlock,eax                               ;Unlock this memory<br />    mov eax,&#91;edi&#93;.LINKEDOBJECT.hLock                      ;Grab the handle to this memory<br />    invoke GlobalFree,eax                                 ;Release this memory<br /><br />    pop esi<br />    pop edi<br /><br />    return TRUE                                           ;cya<br />KillEntry ENDP<br /><br />;-------------------------------------------------------------------<br />;AddChildEntry Procedure<br />;-Adds an entry to a Linked-List...<br />;-Allocates memory for a new entry,<br />;-Examines Parent&lt;---&gt;Child links and<br />;-Patches- Parent&lt;--&lt;THIS&gt;--&gt;Child &#40;Inserting Self&#41;.<br />;-Bidirection links are preserved.<br />;-------------------------------------------------------------------<br />AddChildEntry PROC lpParent&#58;PTR LINKEDOBJECT, ObjectSize&#58;DWORD<br />LOCAL lpOldChild&#58;PTR LINKEDOBJECT<br />LOCAL hMem&#58;DWORD<br />    push edi<br />    push esi<br /><br />    mov eax, lpParent<br />    mov esi, eax<br /><br />    invoke GlobalAlloc,GPTR,ObjectSize<br />    mov hMem,eax<br />    .if eax != NULL<br />        invoke GlobalLock,hMem<br />        mov edi, eax<br />        .if eax != NULL<br />            mov eax, hMem<br />            mov &#91;edi&#93;.LINKEDOBJECT.hLock, eax                 ;Remember my unlock handle<br />            .if esi != NULL                                   ;I have a Parent and thus am not Root<br />                mov eax, &#91;esi&#93;.LINKEDOBJECT.pChild<br />                mov lpOldChild, eax                           ;store possible child<br />                mov &#91;esi&#93;.LINKEDOBJECT.pChild, edi             ;Tell Parent hes my new daddy- APPENDING<br />                mov &#91;edi&#93;.LINKEDOBJECT.pParent, esi             ;Tell Myself I have a Parent<br />                mov eax, lpOldChild<br />                .if eax != NULL                               ;and that Parent had a Child - INSERTING!<br />                    mov eax, lpOldChild<br />                    mov esi, eax<br />                    mov &#91;esi&#93;.LINKEDOBJECT.pParent, edi         ;Tell Child I'm their new sugardaddy<br />                    mov &#91;edi&#93;.LINKEDOBJECT.pChild, esi         ;Tell Myself I have a Child<br />                    invoke MessageBox,NULL,CTEXT&#40;&quot;Child Inserted!&quot;&#41;,CTEXT&#40;&quot;Success!&quot;&#41;,MB_OK<br />                .else<br />                    mov &#91;edi&#93;.LINKEDOBJECT.pChild, NULL<br />                    invoke MessageBox,NULL,CTEXT&#40;&quot;Child Appended!&quot;&#41;,CTEXT&#40;&quot;Success!&quot;&#41;,MB_OK<br />                .endif                                        ;I have no kids to worry about or<br />            .else                                             ;I am Root with No Parent and No Child<br />                mov &#91;edi&#93;.LINKEDOBJECT.pParent, NULL<br />                mov &#91;edi&#93;.LINKEDOBJECT.pChild, NULL<br />                mov &#91;edi&#93;.LINKEDOBJECT.pOlderSibling, NULL<br />                mov &#91;edi&#93;.LINKEDOBJECT.pYoungerSibling, NULL<br />                invoke MessageBox,NULL,CTEXT&#40;&quot;Added Root!&quot;&#41;,CTEXT&#40;&quot;Success!&quot;&#41;,MB_OK<br />            .endif<br /><br />            ;_____________________________________<br />            ;Null-out Application-Specific fields<br />            mov &#91;edi&#93;.LINKEDOBJECT.pName, NULL<br />            mov &#91;edi&#93;.LINKEDOBJECT.hNameLock, NULL<br />            ;_____________________________________<br />            mov eax, edi<br />            pop esi<br />            pop edi<br />            return eax                                        ;Return pointer to the new Object in EAX<br />        .else                                                 ;GlobalLock failed...<br />            invoke GetLastError<br />            invoke wsprintf,addr ERRbuff,CTEXT&#40;&quot;GlobalLock err #%lu&quot;&#41;,eax<br />            invoke MessageBox,NULL, addr ERRbuff,CTEXT&#40;&quot;Error!&quot;&#41;,MB_OK+MB_ICONERROR<br />            invoke GlobalFree,hMem                            ;Free the memory we Failed to Lock<br />        .endif<br />    .else                                                     ;GlobalAlloc failed...<br />        invoke GetLastError<br />        invoke wsprintf,addr ERRbuff,CTEXT&#40;&quot;GlobalAlloc err #%lu&quot;&#41;,eax<br />        invoke MessageBox,NULL,addr ERRbuff,CTEXT&#40;&quot;Error!&quot;&#41;,MB_OK+MB_ICONERROR<br />    .endif<br /><br />    pop esi<br />    pop edi<br /><br />    xor eax,eax<br />    ret                                                       ;Return ERROR in eax since we have Failed<br /><br />AddChildEntry ENDP<br /><br /><br /><br /><br />;-------------------------------------------------------------------<br />;AddSiblingEntry Procedure<br />;-Adds an entry to a Linked-List...<br />;-Allocates memory for a new entry,<br />;-Examines OlderSibling&lt;---&gt;YoungerSibling links and<br />;-Patches- Parent&lt;--&lt;THIS&gt;--&gt;Child &#40;Inserting Self&#41;.<br />;-Bidirection links are preserved.<br />;-------------------------------------------------------------------<br />AddSiblingEntry PROC lpParent&#58;PTR LINKEDOBJECT, ObjectSize&#58;DWORD<br />LOCAL lpOldChild&#58;PTR LINKEDOBJECT<br />LOCAL hMem&#58;DWORD<br />    push edi<br />    push esi<br /><br />    mov eax, lpParent<br />    mov esi, eax<br /><br />    invoke GlobalAlloc,GPTR,ObjectSize<br />    mov hMem,eax<br />    .if eax != NULL<br />        invoke GlobalLock,hMem<br />        mov edi, eax<br />        .if eax != NULL<br />            mov eax, hMem<br />            mov &#91;edi&#93;.LINKEDOBJECT.hLock, eax                 ;Remember my unlock handle<br />            .if esi != NULL                                   ;I have a Parent and thus am not Root<br />                mov eax, &#91;esi&#93;.LINKEDOBJECT.pYoungerSibling<br />                mov lpOldChild, eax                           ;store possible child<br />                mov &#91;esi&#93;.LINKEDOBJECT.pYoungerSibling, edi   ;Tell Parent hes my new daddy- APPENDING<br />                mov &#91;edi&#93;.LINKEDOBJECT.pOlderSibling, esi     ;Tell Myself I have a Parent<br />                mov eax, lpOldChild<br />                .if eax != NULL                               ;and that Parent had a Child - INSERTING!<br />                    mov eax, lpOldChild<br />                    mov esi, eax<br />                    mov &#91;esi&#93;.LINKEDOBJECT.pOlderSibling, edi  ;Tell Child I'm their new sugardaddy<br />                    mov &#91;edi&#93;.LINKEDOBJECT.pYoungerSibling, esi         ;Tell Myself I have a Child<br />                    invoke MessageBox,NULL,CTEXT&#40;&quot;Sibling Inserted!&quot;&#41;,CTEXT&#40;&quot;Success!&quot;&#41;,MB_OK<br />                .else<br />                    mov &#91;edi&#93;.LINKEDOBJECT.pChild, NULL<br />                    invoke MessageBox,NULL,CTEXT&#40;&quot;Sibling Appended!&quot;&#41;,CTEXT&#40;&quot;Success!&quot;&#41;,MB_OK<br />                .endif                                        ;I have no kids to worry about or<br />            .else                                             ;I am Root with No Parent and No Child<br />                mov &#91;edi&#93;.LINKEDOBJECT.pParent, NULL<br />                mov &#91;edi&#93;.LINKEDOBJECT.pChild, NULL<br />                mov &#91;edi&#93;.LINKEDOBJECT.pOlderSibling, NULL<br />                mov &#91;edi&#93;.LINKEDOBJECT.pYoungerSibling, NULL<br />                invoke MessageBox,NULL,CTEXT&#40;&quot;Added Root!&quot;&#41;,CTEXT&#40;&quot;Success!&quot;&#41;,MB_OK<br />            .endif<br /><br />            ;_____________________________________<br />            ;Null-out Application-Specific fields<br />            mov &#91;edi&#93;.LINKEDOBJECT.pName, NULL<br />            mov &#91;edi&#93;.LINKEDOBJECT.hNameLock, NULL<br />            ;_____________________________________<br />            mov eax, edi<br />            pop esi<br />            pop edi<br />            return eax                                        ;Return pointer to the new Object in EAX<br />        .else                                                 ;GlobalLock failed...<br />            invoke GetLastError<br />            invoke wsprintf,addr ERRbuff,CTEXT&#40;&quot;GlobalLock err #%lu&quot;&#41;,eax<br />            invoke MessageBox,NULL, addr ERRbuff,CTEXT&#40;&quot;Error!&quot;&#41;,MB_OK+MB_ICONERROR<br />            invoke GlobalFree,hMem                            ;Free the memory we Failed to Lock<br />        .endif<br />    .else                                                     ;GlobalAlloc failed...<br />        invoke GetLastError<br />        invoke wsprintf,addr ERRbuff,CTEXT&#40;&quot;GlobalAlloc err #%lu&quot;&#41;,eax<br />        invoke MessageBox,NULL,addr ERRbuff,CTEXT&#40;&quot;Error!&quot;&#41;,MB_OK+MB_ICONERROR<br />    .endif<br /><br />    pop esi<br />    pop edi<br /><br />    xor eax,eax<br />    ret                                                       ;Return ERROR in eax since we have Failed<br /><br />AddSiblingEntry ENDP<br /><br /><br />;-------------------------------------------------------------------<br />;KillEntryPlusChildren Procedure<br />;-Removes an entry from a Linked-List.<br />;-Examines Parent&lt;--&lt;THIS&gt;--&gt;Child links and<br />;-Patches- Parent &#40;Deleting Self&#41;.<br />;-Also detects Child links and recursively removes them.<br />;-Releases the allocated memory used by the killed entry.<br />;-In other words, flawless and transparent removal<br />;-of a single entry in our List.<br />;-------------------------------------------------------------------<br />KillEntryPlusChildren PROC lpThis&#58;PTR LinkedObject    ;pointer to entry to be deleted<br />    push edi<br />    push esi<br /><br />    mov eax, lpThis<br />    mov edi, eax<br /><br />    .if &#91;edi&#93;.LINKEDOBJECT.pParent != NULL                              ;I have a Parent and thus am not Root..<br />        mov eax, &#91;edi&#93;.LINKEDOBJECT.pParent<br />        mov esi, eax<br />        mov &#91;esi&#93;.LINKEDOBJECT.pChild,NULL                             ;Kill Parent's link to me<br />        .if &#91;edi&#93;.LINKEDOBJECT.pChild !=NULL                           ;..and I also have a Child..<br />            invoke KillEntryPlusChildren, &#91;edi&#93;.LINKEDOBJECT.pChild    ; Kill Child<br />            ;Kill any Name for this node<br />            invoke KillName, lpThis<br />            invoke MessageBox,NULL,CTEXT&#40;&quot;killed Child Node!&quot;&#41;,CTEXT&#40;&quot;Success!&quot;&#41;,MB_OK<br />        .else<br />            ;Kill any Name for this node<br />            invoke KillName, lpThis<br />            invoke MessageBox,NULL,CTEXT&#40;&quot;killed End Node!&quot;&#41;,CTEXT&#40;&quot;Success!&quot;&#41;,MB_OK<br />        .endif<br /><br />    .else                                                             ;I am Root with No Parent<br />        .if &#91;edi&#93;.LINKEDOBJECT.pChild != NULL                          ;..and I also have a Child..<br />            invoke KillEntryPlusChildren, &#91;edi&#93;.LINKEDOBJECT.pChild    ; Kill Child<br />        .endif<br />        ;Kill any Name for this node<br />        invoke KillName, lpThis<br />        invoke MessageBox,NULL,CTEXT&#40;&quot;Killed Root!&quot;&#41;,CTEXT&#40;&quot;Success!&quot;&#41;,MB_OK<br /><br />    .endif<br /><br />    invoke GlobalUnlock,&#91;edi&#93;.LINKEDOBJECT.hLock                      ;Unlock this memory<br />    invoke GlobalFree,&#91;edi&#93;.LINKEDOBJECT.hLock                        ;Release this memory<br /><br />    pop esi<br />    pop edi<br /><br />    return TRUE                     ;cya<br />KillEntryPlusChildren ENDP<br /><br /><br />;-------------------------------------------------------------------<br />;KillEntryPlusYoungerSiblings Procedure<br />;-Removes an entry from a Linked-List.<br />;-Examines OlderSibling&lt;--&lt;THIS&gt;--&gt;YoungerSibling links and<br />;-Patches- OlderSibling&lt;--&gt;YoungerSibling &#40;Deleting Self&#41;.<br />;-Also detects Child links and recursively removes them.<br />;-Releases the allocated memory used by the killed entry.<br />;-In other words, flawless and transparent removal<br />;-of a single entry in our List plus its Younger Siblings.<br />;-------------------------------------------------------------------<br />KillEntryPlusYoungerSiblings PROC lpThis&#58;PTR LinkedObject    ;pointer to entry to be deleted<br />    push edi<br />    push esi<br /><br />    mov eax, lpThis<br />    mov edi, eax<br /><br />    .if &#91;edi&#93;.LINKEDOBJECT.pOlderSibling != NULL                  ;I have a Parent and thus am not Root..<br />        mov eax, &#91;edi&#93;.LINKEDOBJECT.pOlderSibling<br />        mov esi, eax<br />        mov &#91;esi&#93;.LINKEDOBJECT.pYoungerSibling,NULL               ;Kill Parent's link to me<br />        .if &#91;edi&#93;.LINKEDOBJECT.pYoungerSibling !=NULL             ;..and I also have a Child..<br />            invoke KillEntryPlusYoungerSiblings, &#91;edi&#93;.LINKEDOBJECT.pYoungerSibling; Kill Child<br />            ;Kill any Name for this node<br />            invoke KillName, lpThis<br />            invoke MessageBox,NULL,CTEXT&#40;&quot;killed Child Sibling Node!&quot;&#41;,CTEXT&#40;&quot;Success!&quot;&#41;,MB_OK<br />        .else<br />            ;Kill any Name for this node<br />            invoke KillName, lpThis<br />            invoke MessageBox,NULL,CTEXT&#40;&quot;killed End Sibling Node!&quot;&#41;,CTEXT&#40;&quot;Success!&quot;&#41;,MB_OK<br />        .endif<br /><br />    .else                                                             ;I am Root with No Parent<br />        .if &#91;edi&#93;.LINKEDOBJECT.pChild != NULL                          ;..and I also have a Child..<br />            invoke KillEntryPlusYoungerSiblings &#91;edi&#93;.LINKEDOBJECT.pYoungerSibling    ; Kill Child<br />        .endif<br />        ;Kill any Name for this node<br />        invoke KillName, lpThis<br />        invoke MessageBox,NULL,CTEXT&#40;&quot;Killed Root!&quot;&#41;,CTEXT&#40;&quot;Success!&quot;&#41;,MB_OK<br /><br />    .endif<br /><br />    invoke GlobalUnlock,&#91;edi&#93;.LINKEDOBJECT.hLock                      ;Unlock this memory<br />    invoke GlobalFree,&#91;edi&#93;.LINKEDOBJECT.hLock                        ;Release this memory<br /><br />    pop esi<br />    pop edi<br /><br />    return TRUE                     ;cya<br />KillEntryPlusYoungerSiblings ENDP<br /></code></pre></div>
    <div class="meta">Posted on 2002-08-18 08:06:06 by Homer</div>
   </div>
  </div>
 </body>
</html>