<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Physics - 3D Collision Detection and Response - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29056" />
    <link rel="next" href="../?id=29056&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29056">Physics - 3D Collision Detection and Response</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29056&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29056&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29056" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29056&amp;page=2">&gt;</a><a href="../?id=29056&amp;page=2">&raquo;</a></form>   <div class="post" id="post-205273">
    <div class="subject"><a href="#post-205273">Physics - 3D Collision Detection and Response</a></div>
    <div class="body">I&#039;ve been working on a physics component (for and with ObjAsm32/DX9) for some time now.<br />Its a 3D multibody simulator which so far supports springs, gravity and the usual stuff.<br />The integrator is currently just a Euler integrator, being driven in fixed timesteps of 0.100 seconds and synchronized to realtime via a &#039;time accumulator&#039;... the only way that the integrator differs from the gamut of other simulators is the way it behaves when a collision is detected - the simulation is wound forward to the exact moment of collision, and the unused portion of the frametime is returned to the Time Accumulator pending the next update.<br />In terms of geometry, supported so far are only Spheres and Oriented Boxes, however complex meshes can be driven via the transform of a rigid body.<br />So.. we can take any old mesh object, and wrap it in a box, or a sphere.<br /><br />The collision hulls are (barely) hierarchical in nature... all Boxes naturally have a Sphere, and so collision detection begins with spheres, regardless of the actual geometry of the bodies.<br />I have mentioned in another post why I like sphere tests, but I&#039;ll briefly say it again: sphere tests are slightly modified point tests, and theyre very cheap... to determine if two 3D spheres are intersecting at a given instant in time, we measure the distance between their origins, if that distance is less than the sum of the sphere radii, then theyre intersecting.<br /><br />Collision tests generally fall into two categories, sometimes called &#039;macro and micro&#039;, or &#039;coarse and fine&#039;, or &#039;swept and instantaneous&#039;.<br />Instantaneous tests are cheaper, but theres a drawback, particularly noticeable when bodies have high velocity (ie are moving quickly)... since their position is updated by relatively large amounts each frame, theres a chance of us &#039;missing&#039; collisions (our collision detector simply does not see them occur) and so fast-moving objects can go right through walls, and each other, which obviously isn&#039;t correct.<br />The solution to this problem is to use a Swept test.<br />Swept tests are able to check for intersection of the bodies all the way along their respective paths of travel, they can tell us not only if there will be a collision, but when and where it will occur.<br />By predicting collisions slightly into the future in this way, the problem of high velocity collision detection is solved, at least for spheres.<br />But in my current demo, my objects are not spheres, they are boxes, and they are able to rotate freely.<br /><br />Since thats true, we know that when the Spheres around our boxes first touch, then the Boxes are certainly NOT Penetrating - theyre probably Clear of one another, and theres a small chance they are Colliding (touching at the corners).<br />My sphere-sweep test returns TWO collision times : the time when the spheres would begin to touch, and the time when the spheres would begin to separate (had they passed through one another).<br />I know that my &#039;actual&#039; collision time, no matter what geometry my bodies are, is somewhere between these two times.<br />Now I have narrowed down the actual collision time to quite a small window of time and I still haven&#039;t bothered to look at what actual geometry they use :)<br />At this point I begin to do that, I have case-code for the &#039;actual&#039; geometry type of my bodies.<br />So, I have a method which, given the start and end of the search window, will find the exact moment of collision of the two bodies with specific geometry, and return that time.<br />This method uses a binary search which involves integrating the two offending bodies to various test times while shrinking the search window.<br />Note that the search is restricted to manipulation of two of N bodies, THIS is different to many other simulators and offers a big speedup.<br />Anyway, having found and returned the exact time the boxes will collide in the current frame, the entire simulation is wound forward to that time, and the collision between those two bodies is resolved, leaving the system in a fit state to continue integrating happily forwards.<br /><br />So - we have the Sweep phase, where we sweep-test the boundingspheres of all unique pairings of rigid bodies, whose job is to tell us the earliest collision of two bodies.<br />Then we have the binary search for exact collision of two moving and rotating bodies of arbitrary geometry.<br />Then we glitch the system forwards to the collision time, ready to resolve the collision.<br /><br />The collision resolving scheme is able to handle multiple simultaneous point collisions between two bodies, which it currently does by calculating the due impulse for each point collision, calculating the change in velocity (linear and angular) due to each impulse, summing these deltas, and then applying the averages of those sums to the bodies.<br />I&#039;m not at all sure that efficient or even correct but the results are plausible, and look far more correct than simulators which just solve the first collision they see and move on... when you drop a box flat onto a plane, it should bounce straight up with no rotation, but in those simulators, the box will bounce away at an angle, and with some spin. <br /><br />Well, that pretty much covers the mysterious inner workings of my simulator, I&#039;d love to hear your comments and suggestions.<br /><br />Why am I doing this? Why not just use an existing engine?<br />This is a wide open field and still the subject of much active research, and well, lets face it, playing with 3D physics stuff is FUN :D<br />I believe that most physics engines trot out the same algorithms in the same order and produce code that benchmarks similarly as a result... I don&#039;t think it would take much of a leap in paradigm to put most of them to shame.<br />The number one reason that some of these products receive commercial attention at all is simply because they are proven in the marketplace, and the cost of a license is a small fraction of the cost of developing an in-house solution.<br />Since I am not constrained by the leather straps of commercial reality (I don&#039;t stand to make a single cent of profit), I&#039;m able to develop projects like this at my leisure, and without being forced to make compromises in order to meet some unrealistic deadline.<br /><br />If you&#039;d like to help develop this code (with the understanding that it will become a part of the OA32 library, and essentially open-sourced) I&#039;d also love to hear from you.<br /></div>
    <div class="meta">Posted on 2008-05-12 04:56:22 by Homer</div>
   </div>
   <div class="post" id="post-205274">
    <div class="subject"><a href="#post-205274">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">I&#039;ve just added a new test to the collision detection scheme...<br />At the start of the Sphere/Sphere sweep test, I now calculate the Closing Velocity between the two spheres (not to be confused with the Relative Velocity, which is a vector).<br />The sign of the Closing Velocity tells me whether the Spheres are approaching or separating.<br />If they&#039;re separating, I let them continue without further checking, EVEN IF THE BODIES ARE CURRENTLY PENETRATING.<br />If they&#039;re moving apart, and they&#039;re penetrating, letting them go will only improve the situation, without the need to apply any heavy-handed &quot;penetration correction&#039; impulses (something I&#039;ve tried to avoid).<br />But more importantly, if they&#039;re moving apart, and they&#039;re clear, we know that collision is not possible, so we can exit the sweep test for this pair of bodies early.<br />So, we don&#039;t even need to perform the Sphere Sweep itself unless we know the Spheres are generally moving toward one another !!!<br />In hindsight, it is obvious that this test should be the first test we perform, I&#039;m just sorry it took me so long to realize it, and I&#039;m suprised that it is not mentioned more frequently in general literature, but I guess that this is just an example of what I&#039;m talking about - the algorithms are out there, they just need to be strung together in optimal order.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-05-12 09:29:51 by Homer</div>
   </div>
   <div class="post" id="post-205276">
    <div class="subject"><a href="#post-205276">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">Errata: I stated that my Sphere Sweep test returned two Time values: the time that the spheres first touched, and the time that they first separated. Then I said I searched between these times for the moment of collision.<br />This is not quite accurate.<br /><br />As stated, my search for the perfect collision time takes two input times, however it returns two output times, since we cannot be assured of finding a &#039;perfect time&#039; due to numerical accuracy.<br />The two time values returned represent the most advanced time that the Bodies were still found to be Clear, and the least advanced time that&nbsp; the Bodies were found to still be Penetrating.<br />The maximum difference between these two times is an Epsilon value of 0.0001 seconds, and the &#039;perfect&#039; time is somewhere between the two returned values.<br /><br />I am currently winding the simulation to the lower of the two returned values, where the Bodies are expected to be in a legal and Clear configuration, because I know that if I was to advance all the way to the higher returned time I would have Penetration to deal with.<br />Now I find the closest Plane on body A to body B, and then test the points of body B against it, noting which points crossed the test plane. This planar test has an error threshold, which allows points just slightly outside the plane to count as being coplanar... <br />The points found to be coplanar are treated to a final test to determine whether they are indeed within the volume of the test box...<br />Points that are Clear are ignored.<br />Points that are Penetrating cause an int3, this is quite alarming, this state should not be possible, since we integrated the system to the LAST DISCOVERED &#039;CLEAR&#039; TIME !!!!<br />Points that are Colliding (coplanar) within the threshold are sent to the collision resolver.<br />Having tested all the points of body B against body A, I perform the entire test again with the Bodies switched about, testing body A&#039;s points against body B&#039;s closest plane.<br />This sounds exhaustive, and it is, but it ensures that all of the correct points (and none of the wrong ones) will end up producing a collision response...They call all these point collisions &#039;microcollisions&#039;.<br />Having all these little impulses acting at once gives us much more realistic behaviour during collisions, at the cost of a little extra processing.<br />I intend to fake the physics for a lot of non-critical stuff in my game engine, and I don&#039;t plan on simulating zillions of objects with a single simulator, so I think can afford to have the extra accuracy.<br />In regards to large numbers of bodies, I intend to associate an instance of my simulator with each partioned chunk of my game world, connected via portals.<br />The mini-simulators will be able to pass objects between them via the portals.<br />In this way, spatial partitioning is applied to the simulator.<br />Individual simulator instances can be put to sleep when inactive.<br />As long as we don&#039;t have too many bodies in one partition of our worldspace, we have avoided the problem of the cost of the sweep growing exponentially with respect to the number of bodies being simulated in the entire game.. that is to say, we can afford to correctly simulate bodies that are not necessarily near the player, and do it in realtime, whereas we might be tempted to cull the simulation by visibility otherwise in order to meet our framerate quota.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-05-12 11:38:49 by Homer</div>
   </div>
   <div class="post" id="post-205282">
    <div class="subject"><a href="#post-205282">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">I couldn&#039;t sleep last night, thoughts kept running through my mind.<br />One of them was in regards to my &#039;search for perfect collision time&#039;.<br />It occurred to me that although my current code guarantees that I find the upper and lower bounds of the collision time accurate to one ten thousandth of a second (0.0001), since I have not (and indeed cannot) calculate the EXACT time (due to numerical precision), I can not calculate the EXACT point(s) of collision on both bodies !!!<br />The reason for this is Velocity.<br />When the velocity is small, the change in position per frame (displacement) is also small.<br />At high velocity, even a very small amount of time can produce a large displacement.<br />I am currently between zero and one ten thousandth of a second away from the EXACT collision time, so my two bodies are displaced by one ten thousandth of their total change in velocity for this frame.<br /><br />I said I can&#039;t predict the exact time of collision, because of numerical precision.<br />But the collision time is not what we REALLY want, is it?<br />WHY are we obtaining the collision time?<br />We want it so we can place our objects at the time of collision, so then we can find our microcollisions, right?<br /><br />Well, even if we can&#039;t find the exact collision time, can we find the exact positions of the bodies at the moment of collision ?<br /><br />Lets think about this: right now, we&#039;re about to put the bodies at two specific locations , at a time just before collision occurred.<br />Also, we&#039;ve already missed an opportunity to note which point(s) penetrate, since we&#039;ve been staring at these points over a number of integration positions during our Search.<br />Finally, we know the velocities of the bodies... we even know how much it changed (acceleration) during the frame.<br />If we treat the Velocities to a binary division, we can estimate exact collisions to several more orders of accuracy than we currently can...<br />Hey, this is a stream of consciousness here, but here&#039;s an idea... if we were to double the velocity, and half the time, we would get to the same position, yes?<br />Lets half our velocity, and double the size of our remaining search window, until we run low on velocity.<br />Now that we have rescued our search window size from the clutches of numerical oblivion and also gotten rid of that nasty Velocity, we can consume the remaining search window size by running through a few bonus iterations of our Search.<br />Of course, we&#039;re going to have to preserve the Source states of our pair of bodies during this second round of Search iterations, because we&#039;re only doing it to more accurately estimate the exact configurations of the bodies at the exact collision time.<br />We can pilfer the configurations for the positions of the offending Points and restore the Source configs of the pair of bodies before leaving the Search method.<br />Perhaps the &#039;search&#039; method could be able to handle resolving of collisions and never need to return a result , making the second round of collision testing unnecessary...<br />Anyway, once we return, the simulation will be wound to the slightly-incorrect pre-collision time, so we shouldn&#039;t resolve the collisions until we return.<br />We&#039;re now resolving the collisions at the exact collision points, but possibly a fragment of a second earlier than we should have.<br />For me, this is preferable to processing collisions that haven&#039;t happened yet, and in the wrong place. The reason is this: each of our point-collisions is actually two points coming together at the collision moment - theres a place on EACH body that is meeting at a collision point, and at the moment of impact, these points coincide.<br />I wish to observe this constraint, I wish that the worldspace collision point, the collision point on body A, and the collision point on body B all coincide when I resolve the collision.<br />I would rather hand my collision resolver accurate positions, and suffer a tiny time-glitch (for those two bodies only) than be perfectly timely and perfectly wrong.<br /><br />I guess this post isnt very well thought out at all, its just junk on my brain really.<br />Anyone out there got any ideas?<br />I don&#039;t care if they&#039;re crappy, I&#039;d still love to hear them.<br /><br /></div>
    <div class="meta">Posted on 2008-05-13 00:09:25 by Homer</div>
   </div>
   <div class="post" id="post-205287">
    <div class="subject"><a href="#post-205287">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">I have two tiny ideas, that might help in optimization:<br />1) before doing expensive swept-sphere tests, simply do an instantenous sphere-sphere hittest, but each object&#039;s sphere radius is increased by the length of its velocity-vector. <br />2) find collision-times by using the approach ADCs ICs use (by bit-toggling, comparison). So, 32-bit a FP value will take no more than 32 steps to be found. This needs the comparison/test to be made into a linear function/thing, though. <br /><br />Also, after the broad-phase, we have the count of objects/tests we&#039;ll have to do in the narrow-phase. If that count is too high, maybe it&#039;ll be a good thing to use simpler/faster algorithms for the narrow-phase. </div>
    <div class="meta">Posted on 2008-05-13 12:09:34 by Ultrano</div>
   </div>
   <div class="post" id="post-205293">
    <div class="subject"><a href="#post-205293">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">Heya Ultrano :)<br />Thanks for replying, I&#039;m happy to see you&#039;re taking an interest.<br />I presume that the only reason that this thread has received over 100 views on its first day is that there&#039;s simply nothing else going on around here lately... I further presume that everyone is just busy like me, and not ready to announce their work... anyway, here&#039;s my two cents worth:<br /><br />#1 - The swept sphere test is not expensive (well, its relatively cheap, its a modified version of the instantaneous sphere test), and indeed it incorporates a test for instantaneous intersection at the start of the frame, and incorporates the velocities to test for collision all the way along the travel paths, which is what you&#039;re trying to achieve by expanding the spheres via their velocities - its just tonnes more accurate than testing with expanded spheres, and can tell me not just IF, but WHERE and WHEN.<br />But to be completely fair, I had exactly the same idea as you before I found this algo.<br /><br />This link leads to a page that explains the sphere-sphere sweep algorithm in detail:<br />http://www.gamasutra.com/features/19991018/Gomez_2.htm<br /><br />#2 - The problem with the approach that ADCs use is the same problem I have : they are not numerically accurate, they are STEPPED (insert fond memories of building R2R ladders using discrete components HERE). My problem is not finding the collision time - the search I&#039;ve implemented is actually a kind of binary search, and very fast and efficient, given that it handles rotating bodies of arbitrary geometry.<br />No, the problem is that I run out of numerical precision.<br />I can, as stated, find the collision moment accurate to 0.0001 seconds and I can do that in about 12 iterations of my search algo, no matter what geometry the bodies are, no matter what speed they are moving AND ROTATING at , in 3D space.<br />But this still leaves me with a potential error of between 0 and 0.0001 seconds.<br />If we then take into account the Closing Velocity of the two bodies, and multiply that by our presumed collision time, the Bodies will be very close to being in the correct positions for collision, but they wont be EXACTLY in position.<br />Observe that the point of collision on each body coincide in worldspace at the time the collision occurs - if we have not positioned our bodies correctly, those points will not coincide... and if they dont coincide, then we cannot accurately resolve the collision, we&#039;ll be handing the collision resolver bodyspace locations which are slightly wrong.<br />I&#039;d rather produce nice collision responses and have two offending bodies glitch slightly in Time than have all my bodies perfectly time-synchronized but producing incorrect collision responses. <br />So the problem I am really trying to solve is NOT&nbsp; &quot;find the exact collision time&quot; (because theres no such thing as exact due to numerical precision), the REAL problem I wish to solve is &quot;find the configurations of the offending bodies at the collision time&quot;.<br />Since this involves multiplying the Velocity by the collision time to find the displacement of each body, any error in the calculated time is multiplied too, producing positional error.<br />Perhaps I should simply turn my attention to this positional error, possibly applying it as a threshold during fine collision testing.<br /><br />#3 - my broad-phase detector (the n-body swept sphere test) returns information about the pair of bodies whose spheres will collide FIRST in the current frame : which pair of bodies, and when.<br />My narrow-phase detector is handed this information, which it then uses to search for the exact collision time and the set of simultaneous collision points involved.<br />So my narrow-phase stuff is all just working with one pair of bodies, and the binary timesearch algo is amongst that code, so I am only performing test integrations with one pair of bodies, independent to the rest of the simulation.<br />The entire simulation is wound to the collision time, the set of collisions is resolved for the offending bodypair, and the entire simulator is now in a fit state, but it has not reached the end of the timestep, so we return the unused time to the simulator&#039;s &#039;time accumulator&#039;, where it will be spent in the next timestep.<br />Excluding the binary timesearch, the cost of narrow-phase testing is thus linear for a given pair of geometries.<br />The most complex pair of geometries I currently handle is Box/Box.<br />I consider a Box as a cloud of points and planes, so the code can be adapted for arbitrary hulls, but I really don&#039;t see any value in simulating complex meshes - collision testing against them perhaps, but we&#039;d associate a proxy hull with a mesh to accelerate its physics.<br />That&#039;s what I&#039;m currently doing.<br />In my current democode, for testing purposes, I have m$&#039;s tiger.x mesh surrounded by a box surrounded by a sphere, and I make two instances, and bash them into each other.<br />The BOX is the physical proxy, but Boxes always have a Sphere in my system.<br />When I want to draw a tiger, I use the translation and rotation of its proxy hull.<br />So anyway, its the BOX that is the thing that has Mass and Velocity and such, the Tiger is just sharing its transform.<br /></div>
    <div class="meta">Posted on 2008-05-14 01:36:04 by Homer</div>
   </div>
   <div class="post" id="post-205299">
    <div class="subject"><a href="#post-205299">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">Now that I&#039;ve talked about my current code and current ideas and such, perhaps it would be good to look closely at the way I&#039;m resolving collisions.<br /><br />We have a pair of bodies which are positioned at the moment of impact, and which are hell-bent on penetrating each other unless we do something about it.<br />We&#039;re sure that they are touching in one or more places (not penetrating yet).<br />Each place where they touch is a COLLISION.<br />It might be just one place, or it might be a few places.<br />My system will detect them all, solving each separately, then applying an averaged response.<br />But I&#039;m jumping the gun.<br />Let&#039;s look at the example of two Boxes...<br /><br />I&#039;ve said before that I consider a Box to be a cloud of Points and Planes.<br />In fact, my Boxes contain an array of eight Points, and six Planes, describing the Box with no rotation and positioned at world zero... ie, this is a BodySpace declaration of the geometry.<br />I never screw with the data in these arrays, they are kept intact at all times.<br />Whenever I integrate a Body into a new configuration (adjust its physics variables), I transform the array of BodySpace points into WorldSpace, giving me an oriented and positioned set of eight vertices in worldspace coords. And when I wish to perform collision testing, I transform those worldspace vertices into the BodySpace of my test body, so I am able to test the points against the UNROTATED PLANES on my test body.<br />Thus, my narrow-phase collision detection tests are usually performed in the Space of some specific body.<br />So... at the cost of one extra transform per point, I&#039;m able to perform reasonably cheap tests and avoid transforming some other dynamic data (the planes in this example).<br />For the record, my demo code does not actually use the planes at all, they are redundant, but it still performs point tests in body space.<br />Anyway, back on track, we&#039;re able to identify WHICH POINTS ARE TOUCHING.<br />Let&#039;s now treat ONE of these collisions, and check out how I resolved it...<br /><br />When a Collision occurs in my system, its always due to an aggressor Point of body A colliding with one of the faces of body B (noting that faces are always planar - theyre flat).<br />Some physics engines solve collisions in &#039;collision space&#039;.<br />This is not desirable, it requires extra transformations for no good reason.<br />I solve my collisions in WorldSpace, relative to the point of impact.<br />I calculate an Impulse due to the collision, and then I apply that Impulse at the point of collision to both bodies, scaled by their mass-relationship.<br />The application of this impulse will produce a change in linear velocity, and usually, also a change in angular velocity.<br />I note these delta values per body, but I don&#039;t apply them... there might be several simultaneous collision points, I loop through all of them, summing the deltas, not applying them.<br />Now that I&#039;ve run out of test points, I average the sum of the delta values, and apply the average.<br />This probably sounds a little expensive, and might seem like I&#039;m applying the average of the impulses to the bodies, but in fact, I am applying the average of the EFFECT of the impulses on each body.<br />The result of doing this is that we get more realistic behaviour from the simulator.<br />For example, if we drop a box flat onto a flat plane such that two flat planes meet and we have four collision points, the box should bounce back up without any spin - it should not rotate.<br />If we resolve the four collisions as suggested, each will produce a rotation, but they will cancel out, and give us the correct result !!! More samples equals more quality, so long as we&#039;re dealing with reasonable numbers of points... This system might sound rather naiive, however consider that it naiively is solving point/face, point/edge, edge/face, edge/edge and face/face collisions, all within the same optimized loop and without apparent effort or extra cost.<br /><br />Would you do it this way?<br />What would you do differently?<br />Why?<br /><br /></div>
    <div class="meta">Posted on 2008-05-15 01:46:39 by Homer</div>
   </div>
   <div class="post" id="post-205300">
    <div class="subject"><a href="#post-205300">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">I&#039;ve added some code to allow individual bodies to be put to sleep...<br />If a body is not moving and/or rotating, we don&#039;t need to Integrate it, and it can never act as an Aggressor or &#039;cause&#039; any collisions... so when a body&#039;s energy becomes very low, I&#039;ll make it go to sleep.<br />The body is woken once more if it is involved in a collision.<br />Later I intend to extend this theme to allow me to put the entire simulator to sleep - because I intend to create several instances of the simulator at once, each representing a region of space, each looking after a chunk of my world.<br />Anyway, as usual, the cheapest operation we can perform is the one we DONT perform, so this represents a nice speedup, especially as the number of bodies increases.<br /><br /><br />Oops.. Sleeping bodies are not affected by Gravity :D I&#039;ll have to be more careful about putting Bodies to sleep !!! <br />I guess my next move will be to go back to testing with a single body and some fixed world bounding planes and start to implement &#039;resting contact&#039;.<br /><br /><br /></div>
    <div class="meta">Posted on 2008-05-15 21:44:17 by Homer</div>
   </div>
   <div class="post" id="post-205314">
    <div class="subject"><a href="#post-205314">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">Basically, I need to devise some categories for general collisions.<br />The &#039;normal&#039; sort of collision, we&#039;ll call a Collision (no confusion here).<br />But theres at least two more kinds of collision, and they are due to friction.<br />&#039;Rolling Friction&#039; can cause &#039;Rolling Contact&#039;.<br />And &#039;Static Friction&#039; can cause &#039;Static Contact.<br />Only the last kind can put a Body to sleep.<br />At the moment, friction is implemented as simply a Dampening scalar.<br />This is not enough.<br />We need to model friction better than this, so we can create rolling and sliding behaviours, particularly for round shapes but also generally. We actually don&#039;t need to describe two new kinds of contact, what we need is to handle friction properly when resolving collisions.<br />And we still need to recognize when a Body is effectively at equilibrium (low energy) so we can put it to sleep, but we should be looking at the current Forces due to internal and external energies rather than velocities and such, so that gravity and static contact is taken into account automatically.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-05-18 06:02:41 by Homer</div>
   </div>
   <div class="post" id="post-205328">
    <div class="subject"><a href="#post-205328">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">I&#039;ve half-corrected the problem of Sleeping bodies not being affected by Gravity - it was how I was deciding that a body has &#039;low energy&#039; - I was checking velocities, when I should have been checking the FORCES (linear and angular).<br />My &#039;ComputeForces&#039; method is responsible for calculating the INTERNAL force and torque which are due to velocity (linear and angular), and also account for any EXTERNAL forces due to Gravity, Springs, Rockets, Punches, Grenades, or whatever.<br />I should check for low energy after a collision is resolved.<br />This would allow bodies to fall (or be pulled by springs) into a colliding, AND low-energy state.<br /><br />I&#039;m pretty much completely dissatisfied with my existing collision processing.<br />By the time the earliest set of collisions in the current timeframe between two bodies is detected and resolved, the detection loop has terminated.<br />What if a body is involved in collisions with multiple bodies, and its simultaneous?<br />My existing code will detect the second collision, but by then, the first collision has been resolved, and the velocities have changed, so the second collision will be resolved incorrectly, and the overall simulation will be wrong.<br />Also, since my existing code begins the detection loop from the start, it will probably loop uselessly through a bunch of non-colliding bodies before it finds something to chew on, when it should have picked up where it left off at the most recent offending pair.<br />To fix that, the counters for that loop should be stored as class variables of the simulator instance, rather than as stack locals of some specific procedure.<br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-05-19 20:31:48 by Homer</div>
   </div>
   <div class="post" id="post-205329">
    <div class="subject"><a href="#post-205329">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">As I said, I&#039;m not a happy camper, my so-called microcollision engine is not able to handle multiple bodies colliding at once? I&#039;m making some big changes, pushing much of the collision detection code further back into the engine, and out of the Simulate method.<br />I&#039;ll be doing something like this:<br />Make a list of potential collisions, and as I do so, toss out any &#039;older&#039; ones, leaving a list of potential collisions at time X.<br />Now advance the simulation to time X and process all of those collisions.<br />Now we can return to the Simulate method, and toggle the simulator&#039;s &#039;configuration index&#039;.<br /><br />I like this solution, my code is object oriented, so pushing code deeper into the engine is actually desirable as it more cleanly partitions the engine&#039;s functionality - at the cost of a few cycles of call overhead, we eliminate a lot of repetition of binary code snippets, and our sourcecode looks more tidy as a bonus.<br />The solution only requires that one big chunk of Simulate() is moved into CheckCollisions(), there&#039;s no need to add anything, or track those counters as I suggested previously.<br /><br /><br /></div>
    <div class="meta">Posted on 2008-05-19 23:20:34 by Homer</div>
   </div>
   <div class="post" id="post-205339">
    <div class="subject"><a href="#post-205339">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">Hey Homer!<br /><br />I&#039;m an undergraduate student n am mid way through my course. I&#039;m completely new to assembly programming as i&#039;ve mentioned in the post you replied to. Though i came here looking to dig into assembly programming to expand my horizons my true interests lie in 3D n Physics engine development. But in reality i&#039;ve never actually initiated work in that field. I&#039;m a bit lazy i admit but never the less i have a good understanding of physics and i&#039;ve always wondered how they are implemented in an engine. Reading your posts has helped me fill this gap to some extent and i&#039;m more than excited to aid you in this in anyway i can. :D<br />&nbsp; &nbsp;  As far as my opinion on your methods goes, i like your sphere sweep, and your collision resolving algos though i feel your hesitation to &quot;put objects to sleep&quot; is not justified. See you can comfortably put an object to sleep(ofcourse when its in a state of low energy) until you find out in the instance of the sweep of the aggressor the &quot;sleeping&quot; object in question is about to participate in the oncoming collision(this is the time you wake it up). Until then the forces acting on this object (gravity,friction..) produce no visible effects though they are constantly acting on it.</div>
    <div class="meta">Posted on 2008-05-20 06:59:52 by SNce</div>
   </div>
   <div class="post" id="post-205342">
    <div class="subject"><a href="#post-205342">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">I&#039;ll begin to post my sourcecode soon, but right now I&#039;m making fast and furious changes to it, so I&#039;ll wait until I&#039;m a little more ok with it, and save everyone reading this a lot of pain.<br /><br />The collision detection has changed a lot, for example.<br />I&#039;m now collecting a list of &#039;potential collisions&#039; in a loop that relies on Sphere/Sphere and Sphere/Plane sweep tests, as well as determining the earliest collision time X.<br />This gives me a short list of body pairs whose spheres all collide with something at time X.<br />Now thats in place, I need to perform fine collision checking on that list, which is where I&#039;m at right now. I had avoided using any kind of lists previously, but thats the only way I can see of dealing with arbitrary multiple simultaneous collisions and yielding accurate results.<br /><br />In some ways the algo I&#039;m using hasn&#039;t changed a lot - but the code implementation has changed considerably, and for the better. What I have set in place now more closely resembles a series of filters which becomes more and more fine.<br />It&#039;s a multi-pass culling scheme, nothing more, nothing less.<br />And that&#039;s exactly what I think will give me the best results, and where I think I should be going with this.... for large numbers of bodies, other authors will suggest using some kind of &#039;bounding volume tree&#039; which must be maintained as bodies move about... I think partitioning the simulator is a better solution since I don&#039;t expect huge numbers of bodies in one place.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-05-20 09:42:53 by Homer</div>
   </div>
   <div class="post" id="post-205347">
    <div class="subject"><a href="#post-205347">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">I&#039;m reasonably happy with the changes I&#039;ve made to the collision detection.<br />It involved a complete rewrite of the main loop, which I&#039;ll describe in pseudocode below.<br />The coarse and fine tests are both incorporated in the main loop, so only one pass is needed.<br />The collision time found by this loop is the time that the arbitrary geometries collide, NOT the time when their bounding spheres do, ie, the result is FINE.<br /><br /><pre><code><br />0. Create a temporary collection to hold collision data<br />1. For X = 0 to #Bodies<br />2. BodyA = Bodies<br />3. Perform sweep test of A&#039;s sphere against the set of World Bounding Planes<br />Will the sphere will touch a plane during the current frame?<br />4. NO - goto 9<br />5. YES - Perform Binary Search for exact collision of geometry of A with a specific Plane<br />Is this the earliest &#039;exact&#039; collision time we&#039;ve found?<br />6. MORE - goto 9<br />7. LESS - Note the time, flush the temp collection, and goto 8<br />8. SAME - Shove the Body and Plane into our temp collection<br />8. For Y = X+1 to #Bodies<br />9. BodyB = Bodies<br />10. Perform sweep test of A&#039;s sphere against B&#039;s sphere<br />Will the spheres collide during the current frame?<br />11. NO - goto 16<br />12. YES - Perform Binary Search for exact collision of geometry of A with B<br />Is this the earliest &#039;exact&#039; collision time we&#039;ve found?<br />13. MORE - goto 16<br />14. LESS - Note the time, flush the temp collection, and goto 15<br />15. SAME - Shove the two Bodies into our temp collection<br />16. Next Y<br />17. Next X<br /></code></pre><br /><br />At this point, we have found the exact time that the earliest collision occurs, and we&#039;ve made a list of all the pairs of bodies which collide at that time (since there may be more than two bodies all simultaneously colliding, such as in a game of pool).<br />Now we rattle through that list, and resolve the collision for each pair of bodies.<br />I&#039;ll show you the pseudocode for that in my next post, I&#039;d like to hear your comments regarding the above pseudocode before I continue.<br /><br /></div>
    <div class="meta">Posted on 2008-05-22 01:46:11 by Homer</div>
   </div>
   <div class="post" id="post-205353">
    <div class="subject"><a href="#post-205353">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">Nothing to say? Either I&#039;m doing a great job with this thread, or a lousy one :)<br /><br />Today I&#039;m going to talk about how I resolve collisions.<br />In my simulator, I currently treat two kinds of collision, but the solution is really the same as you&#039;ll see.<br />The first kind of collision is where a Point on the boundary of Body A has collided with one of the Faces of Body B.<br />The second kind is where a Point on the boundary of Body A has collided with a World Bounding Plane.<br /><br />In order to resolve a collision, we will be calculating an IMPULSE.<br />And in order to do that, we need a Collision Normal, and a Collision Point.<br />For the second type of collision, the Normal is simply that of the Plane.<br />But for the first type, the collision normal must be calculated from the state of the two bodies.<br />So I&#039;m going to pretend we have a Normal and a Point, and forget about what Kind of collision it is - the goal is to get our hands on an Impulse.<br /><br />Impulses are a lot like forces, except that forces change momentum gradually over time, whereas impulses act &#039;instantly&#039; - we can say that impulse = the time-integral of force.<br />Impulses are related to force in that they cause a change in momentum, but time is not part of the equation.<br /><br />We can calculate the world-relative velocity as experienced at the collision point.<br />This is partly based on the linear velocity of the Body&#039;s center of mass, and partly on the angular velocity of the Body. We want the post-collision velocity of the POINT to be the negative of the that velocity..<br />When the collision occurs, the Body will impart force against the collision surface.... it will hit it hard because it has some mass.<br />The collision response involves how much energy is returned to the Body after the collision.<br />This energy is our Impulse, and its direction is related to the Closing velocity and the Collision Normal.... if we ignore anything you may know that I am YET to mention about interaction of bodies during collisions, we can think of the impulse as being a slapping, instantaneous kind of force that is equal and opposite to the slapping, instantaneous force of the collision itself.<br />The minimum stuff we need is the collision surface&#039;s normal, and the closing velocity at the Point.<br />We calculate the force of the collision at the collisionpoint, reverse its sign, and we have our impulse.<br />Now guess where we have to apply our impulse?<br />Yes, the impulse needs to be applied at the collisionpoint.<br />Now we&#039;re sick of working with respect to the collisionpoint, we want to relate this stuff back to our Body...Usually, we&#039;re applying this force off-center with respect to the Body, which means that we&#039;ll get some &#039;spin&#039; as well as simply linear movement... it will want to rotate.<br />We calculate the force and torque that this applied force caused to our Body&#039;s center of mass.<br />This is our collision response force and torque, as applied at the center of mass.<br />This pair of values is only valid for one Body.<br />If theres another Body involved in the collision, we need to flip the sign of our impulse, and apply it to the other body, repeating much (but not all) of the above process.<br />Thats what I meant when I said the solution is the same... for two bodies, we just flip the direction of our impulse and apply it to the second body, easy.<br />Remember, equal and opposite.<br />In fact for two bodies its &#039;slightly&#039; more complex, because the mass ratio of the bodies should be taken into account, weighting the response energy for each body by the other body&#039;s mass.<br />This will make a heavy body impart much force on a small body and vice versa, which is physically correct.<br /><br />Now, what we do with the collision response force and torque is up for debate...<br />How, and when, do we apply the response?<br />Bear in mind that we probably have several points colliding at once, and we don&#039;t want to apply ALL of the response energy to each point, or we&#039;ll get too much impulse overall.<br />I currently count the point-collisions per body and then wait until the next timestep to apply the response (from the previous timestep) in ComputeForces where the response is simply added to the &#039;internal&#039; force and torque values.<br /><br />There is one final complication to consider.<br />The Bodies are (probably) not EXACTLY positioned correctly for collision resolution.<br />There is a small error tolerance in the positive (separation) direction.<br />This small error will result in a discrepancy in the impulse that we calculate.<br />The solution is to rely on the (negative of the) pre-collision velocity of the Point - we want to scale the post-collision stuff to equal that, so we just need to figure out a scaling value that will get us from the (value) we have to the (value) we want it to be after the collision.<br />This ensures that our Bodies end up with the correct velocity, and bounce off happily into the wild blue yonder.<br />I am yet to actually implement the solution of &#039;the final complication&#039;..<br /><br />So how am I doing? You guys actually getting anything out of my rant?<br />Wanna see more math? Got questions? etc</div>
    <div class="meta">Posted on 2008-05-23 04:02:05 by Homer</div>
   </div>
   <div class="post" id="post-205355">
    <div class="subject"><a href="#post-205355">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">I&#039;ve implemented that final bit of code to Scale the impulse magnitude.<br />I take the impulse and calculate the change to linear velocity due to that impulse.<br />Then I divide that change in velocity by abs(ClosingVelocity) since thats the velocity that I actually wanted to see. This gives me a scaling value, which I then apply to the Impulse.<br />Finally, I once more calculate the change to linear velocity due to the impulse, and this time I also do that for angular momentum as well, since now I&#039;m working with the correct magnitude of force.<br />Doing this makes sure that our post-collision states are correct, even if we provide slightly incorrect collision data.... if we don&#039;t do it, we&#039;ll gain or lose energy each time we collide, completely unrealistic and unwanted behavior.<br /><br />I&#039;m no longer simply calculating delta values to add to the simulator, I&#039;m now calculating the PRECISE post-collision values, and directly replacing the state values.<br />OK not directly, since I still accumulate and average, but now I&#039;m accumulating and averaging Final State Values, not Delta values.<br />I know what output state I want for linear velocity, which allows me to forcefully scale the output to eliminate all sources of error.... or does it? :P<br />Oh, and in regards to my Averaging of the Point responses per Body, I&#039;ve found one paper which does use this approach, so I feel a little vindicated, since this was something I thought of all by myself :)<br /><br />In my current demo I am dropping a box with no rotation, and letting it fall under gravity &quot;and no other forces&quot; until it slams into the floor plane, where I detect four point-collisions.<br />Here&#039;s some debug spew showing the results of one Point/Plane collision, which clearly show that this is required, and that this solution works. Note that these are 3D (x,y,z) vectors:<br /><br /><div class="quote"><br />edx -&gt; [ 0.000000000000E+0000, -4.467054748535E+0001,&nbsp; 0.000000000000E+0000], Velocity at CollisionPoint<br />edx -&gt; [ 0.000000000000E+0000,&nbsp; 2.634777526855E+0002,&nbsp; 0.000000000000E+0000], COLLISION IMPULSE<br />edx -&gt; [ 0.000000000000E+0000,&nbsp; 5.105207824707E+0001,&nbsp; 0.000000000000E+0000], DeltaVelocity<br />edx -&gt; [ 0.000000000000E+0000,&nbsp; 2.305429229736E+0002,&nbsp; 0.000000000000E+0000], RESCALED COLLISION IMPULSE<br />edx -&gt; [ 0.000000000000E+0000,&nbsp; 4.467054748535E+0001,&nbsp; 0.000000000000E+0000], RESCALED DeltaVelocity<br /></div><br /><br />There&#039;s one special case in the collision detection that I am yet to completely handle, but otherwise I am seeing STABLE RESULTS !!!! :D :D :D :D :D<br />If I enable Damping that is.. otherwise, I am getting just a smidge too much response energy...<br />Without Damping, I get a collision velocity of 4.46 on the first bounce, and 4.56 on the second bounce, and it will grow, we&#039;ll start bouncing off the roof, then directly between the roof and floor, eventually the simulator will explode.<br />With Damping, I get 4.41 and 4.409, and it seems to be almost perfectly numerically stable, and repeatable, with the exception of that special case I mentioned.<br /><br />The special case is where I detect that a Body&#039;s Sphere is penetrating a World Bounding Plane at the START of the TimeStep.<br />Its not necessarily a problem since the actual geometries may not be overlapping at that time.<br />Thats all I need to add and I think I&#039;ll be about ready to start posting code here and hopefully you guys can help test and harden and improve this thing further&nbsp; 8)<br /><br /></div>
    <div class="meta">Posted on 2008-05-24 05:38:31 by Homer</div>
   </div>
   <div class="post" id="post-205356">
    <div class="subject"><a href="#post-205356">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">This recent change to Scale collision response impulses has a problem.<br />It completely disregards our &#039;coefficient of restitution&#039; (E).<br />We end up with a result that always has E=1.0, a &quot;perfectly elastic collision&quot;.<br /><br />What am I talking about? <br /><br />The value E is used to describe how objects react when they collide - its a measure of how &#039;bouncy&#039; they are. A value of 1.0 means it is &#039;perfectly bouncy&#039;, so that no energy is lost during the collision. Think of a rubber &#039;super-ball&#039;. A value of 0.0 would indicate something like a lump of wet clay, it will not bounce at all, will it?<br /><br />I shall now some pseudocode which sheds some light on the actual math being used to calculate the collision impulse for a point on a body and a fixed Plane. This is the original, without the rescaling stuff. <br />Lets take a look at it:<br /><br /><pre><code><br />1. vR = vCollisionPoint - Body.CMPosition<br />2. vVelocity = Body.CMVelocity + CrossProduct(Body.AngularVelocity,vR)<br />3. fClosingVelocity = vVelocity Dot vCollisionNormal<br />4. IF fClosingVelocity is POSITIVE (bit 31 is clear) then RET<br />5. fImpulseNumerator = -(1 + Body.CoefficientOfRestitution) * fClosingVelocity <br />6. fImpulseDenominator = Body.OneOverMass + DotProduct(CrossProduct(Body.InverseWorldInertiaTensor * CrossProduct(vR,vCollisionNormal),vR),vCollisionNormal)&nbsp;  	<br />7. vImpulse = (fImpulseNumerator/fImpulseDenominator) * vCollisionNormal<br />8. vDeltaVelocity = vImpulse * Body.OneOverMass<br />9. vDeltaAngMomentum = vImpulse<br /></code></pre><br /><br />In order to fix the incorrect impulse, I added this:<br /><br /><pre><code><br />9. fScalar = abs(fClosingVelocity) / SQRT(DotProduct(vDeltaVelocity,vDeltaVelocity))<br />10. vImpulse = vImpulse * fScalar<br />11. vDeltaVelocity = vImpulse * Body.OneOverMass (yes, AGAIN)<br />12. vDeltaAngMomentum = vImpulse<br /></code></pre><br /><br />And the problem with THAT?<br />Now our delta velocity has been &#039;SHAPED&#039; to be exactly what we wanted, right?<br />If E=1.0 then yeah its fine - but for any other value of E, we need a smaller output value.<br />So what I did to solve this is move E right out of the original equation until we&#039;ve got our fScalar value:<br /><br /><pre><code><br />5. fImpulseNumerator = -2 * fClosingVelocity <br />6. fImpulseDenominator = Body.OneOverMass + DotProduct(CrossProduct(Body.InverseWorldInertiaTensor * CrossProduct(vR,vCollisionNormal),vR),vCollisionNormal)&nbsp;  	<br />7. vImpulse = (fImpulseNumerator/fImpulseDenominator) * vCollisionNormal<br />8. vDeltaVelocity = vImpulse * Body.OneOverMass<br />9. fScalar = abs(fClosingVelocity) / SQRT(DotProduct(vDeltaVelocity,vDeltaVelocity))<br />10. vImpulse = vImpulse * fScalar * Body.CoefficientOfRestitution<br />11. vDeltaVelocity = vImpulse * Body.OneOverMass (yes, AGAIN)<br />12. vDeltaAngMomentum = vImpulse<br /></code></pre><br /><br />Heh.<br /><br /><br />Oh yeah footnote : I tried getting rid of the SQRT in the above code, but doing so yielded too much error in the output.. collisions dont happen often in a simulation so I&#039;ll just wear it.<br /></div>
    <div class="meta">Posted on 2008-05-24 20:18:21 by Homer</div>
   </div>
   <div class="post" id="post-205357">
    <div class="subject"><a href="#post-205357">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">I&#039;ve added code to handle the special case of a sphere penetrating a world bounding plane at the START of the timestep.<br />I test for instantaneous intersection of the Body geometry and the plane.. if none is found, I handle it almost as usual - I hand execution to the binary search as usual, but I use a much-reduced search window since I know that the collision is near the start of the timestep, this eliminates a few iterations from the search.<br />But if I find that the geometry of the Body penetrates the plane at the start of the timestep, I have an int 3 breakpoint.<br /><br />The int 3 is never being triggered - the simulation is stable and smooth until I get bored.<br />Sweet!<br /><br />Also, I switched the Gravity axis to check all six of the world bounding planes are behaving themselves, and they are.<br /><br />Happy days :)<br /></div>
    <div class="meta">Posted on 2008-05-24 22:21:11 by Homer</div>
   </div>
   <div class="post" id="post-205420">
    <div class="subject"><a href="#post-205420">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">I found that my solution has problems when angular velocity is a large proportion of the closing velocity.... we get too much collision response energy, uh oh.<br /><br />So I started examining some of the more high-tech solutions for resolving simultaneous multi-point collisions, including a scary thing called a Jacobian.<br />Amongst the various papers I read, one of them mentioned something that caught my eye.<br />It said &quot;collision point or region&quot;.<br /><br />Collision Region.<br />Perhaps I could use a single point to resolve a multi-point collision after all...<br />We can consider all the points involved in a collision between two Bodies as a single-point collision to be resolved, and for each such inter-body collision, directly add the resulting changes in velocities per body. Should work... agree, or not?<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-06-01 03:34:37 by Homer</div>
   </div>
   <div class="post" id="post-205432">
    <div class="subject"><a href="#post-205432">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">Its time to talk about Friction.<br />Think you know what friction is? Try defining it :)<br /><br />Actually, that&#039;s not a fair question because there are TWO kinds of friction.<br /><br />Static friction acts on Bodies which are AT REST.<br />It can be defined as a force which resists motion tangent to a contact surface.<br />Think of a Body in resting contact with a flat floor plane. If you try to push the Body sideways, static friction will fight you... the more you push, the more static friction will push back, CANCELLING your efforts to get the Body moving. If you increase your efforts and push harder, at some point you will OVERCOME Static Friction, and the Body will begin to move.<br />Static friction does not affect a Moving body, so it will no longer play a part.<br /><br />Dynamic Friction acts on Bodies which are MOVING.<br />It can ALSO be defined as a force which resists motion tangent to a contact surface.<br />The effect it has on the Body is to eat away at any momentum that is tangent (parallel to) the surface... it slows our Body down, taking away its energy and its velocity over time.<br />Eventually, it will cause our Body to come to Rest, and Static friction will become relevant once more.<br /><br />We&#039;ll explore the implementation of a collision resolver which employs friction over the next few days. But before we do, lets talk about the properties of a physical Material.<br /><br />In the Really Real World, everything is made up of some kind of material.<br />The tyres on your car are made of Rubber.<br />The car itself is made of Metal.<br />The tree we&#039;re about to hit is made of Wood.<br /><br />When two Bodies collide and/or slide against one another, the friction between them depends very much apon the interaction of a pair of Materials.<br />Wet ice applied to wet ice will obviously have very low friction - and dry rubber against dry concrete will obviously have much higher friction - yes?<br /><br />The problem is that different pairs of Materials will have very different friction coefficients.<br />Tables of friction coefficients CAN be found on the web... but will generally be INCOMPLETE and you will need to find the missing values by pure experimentation.<br /><br />So we create a table containing friction coefficients for various pairs of materials... during collision resolving, we look up the appropriate cell in this table based on the material composition of the Bodies involved in the collision :)<br /><br />Theres a lot more to this Friction stuff that I haven&#039;t mentioned, such as Rolling Friction...<br /></div>
    <div class="meta">Posted on 2008-06-02 22:17:23 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29056&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29056&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29056" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29056&amp;page=2">&gt;</a><a href="../?id=29056&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>