<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Physics - 3D Collision Detection and Response - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29056" />
  <link rel="prev" href="../?id=29056&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29056">Physics - 3D Collision Detection and Response</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29056&amp;page=1" style="">&laquo;</a><a href="../?id=29056&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29056" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-205434">
    <div class="subject"><a href="#post-205434">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">Here&#039;s an idea of what the table of friction coefficients might look like (and sorry about the formatting)... each cell contains a pair of values... static and dynamic friction coefficients for given pair of materials... or just 0 for &quot;unknown&quot; - this is just me starting to collate some useful data, wanna help fill some of these fields?<br /><br />Slippery conditions = something slippery is lubricating the surface(s), eg oil or water<br />Sticky conditions = something like race tyres on concrete<br /><br /><pre><code><br />.data<br /><br />MyTableElement struct<br />	_Static&nbsp; real4 ?<br />	_Dynamic real4 ?<br />MyTableElement ends<br /><br />MyTableRow struct<br />	Wood	MyTableElement &lt;&gt;<br />	Stone	MyTableElement &lt;&gt;<br />	Ice		MyTableElement &lt;&gt;<br />	Glass	MyTableElement &lt;&gt;<br />	Metal	MyTableElement &lt;&gt;<br />	Rubber	MyTableElement &lt;&gt;<br />	Velcro	MyTableElement &lt;&gt;<br />	Meat	MyTableElement &lt;&gt;<br />MyTableRow ends<br /><br />;--------------------------------------------------------------------------------------------------------------------------------------<br />;				WOOD			STONE			ICE			GLASS			METAL			RUBBER			VELCRO			MEAT<br />;--------------------------------------------------------------------------------------------------------------------------------------<br /><br />;-------------------<br />;NORMAL CONDITIONS<br />;-------------------<br />;WOOD<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.5f,0.4f&gt;,	&lt;0.2f,0.1f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;STONE<br />MyTableRow	{&lt;0.5f,0.4f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;1.0f,0.8f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;ICE<br />MyTableRow	{&lt;0.2f,0.1f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.1f,0.03f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;GLASS<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.1f,0.03f&gt;,	&lt;0.95f,0.4f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;METAL<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.6f,0.4f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;RUBBER<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;1.0f, 0.8f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;VELCRO<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;6.0f,4.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;MEAT<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br /><br />;-------------------<br />;STICKY CONDITIONS<br />;-------------------<br />;WOOD<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;STONE<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;1.5f,1.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;ICE<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;GLASS<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;METAL<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;RUBBER<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;1.5f,1.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;VELCRO<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;MEAT<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br /><br />;---------------------<br />;SLIPPERY CONDITIONS<br />;---------------------<br />;WOOD<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;STONE<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.7f,0.5f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;ICE<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;GLASS<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;METAL<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.1f,0.05f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;RUBBER<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.7f,0.5f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;VELCRO<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />;MEAT<br />MyTableRow	{&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;,	&lt;0.0f,0.0f&gt;}<br />.code<br /><br /></code></pre></div>
    <div class="meta">Posted on 2008-06-02 22:44:26 by Homer</div>
   </div>
   <div class="post" id="post-205436">
    <div class="subject"><a href="#post-205436">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body"><br />Here&#039;s a pretty picture of a collision thats about to occur.<br />Its showing some vectors with respect to the Center of Mass, but in fact we&#039;ll be interested in these vectors with respect to each Point of Collision.<br /><br />The green line indicates the closing velocity of the Body.<br />The red line indicates the component of the closing velocity which is perpendicular with the collision normal.... our coefficient of restitution plays against the Red Line.<br />The yellow line indicates the component of the closing velocity which is tangent to the collision normal.... our coefficients of friction play against the Yellow Line.<br /><br />I just wanted to visually show you what these vectors are because we&#039;ll be using them.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2583" target="_blank">Boing.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2008-06-02 23:21:08 by Homer</div>
   </div>
   <div class="post" id="post-205437">
    <div class="subject"><a href="#post-205437">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">RELATIVE VELOCITY<br />If our Body is colliding with some unmovable scenery in the World (such as our World Bounding Planes), then the Relative Velocity of the Collision is simply that of the Body.<br /><div class="quote"><br />RelativeVelocity = BodyA.CMVelocity<br /></div><br />But if our Body is colliding with another Body, then the Relative Velocity is given as:<br /><div class="quote"><br />RelativeVelocity = BodyA.CMVelocity - BodyB.CMVelocity <br /></div><br /><br />COLLISION NORMAL<br />If our Body is colliding with some unmovable scenery in the World (such as our World Bounding Planes) then the Normal is that of the collision surface.. ie for collision with a flat floor plane, the Collision Normal would be &lt;0.0, 1.0, 0.0&gt;<br /><div class="quote"><br />CollisionNormal = SurfaceNormal<br /></div><br />But if our Body is colliding with another Body, then the Collision Normal is taken from the relative velocities of the Bodies (at center of mass), and by convention, it is with respect to Body A:<br /><div class="quote"><br />CollisionNormal = Normalize (RelativeVelocity )<br /></div><br />Note that the Collision Normal is a NORMAL (has a length of 1.0)<br /><br />CLOSING VELOCITY<br />With the correct Collision Normal in hand, the closing velocity is given as:<br /><div class="quote"><br />ClosingVelocity = DotProduct (RelativeVelocity , CollisionNormal)<br /></div><br />That works regardless of what kind of collision we have.<br />Note that this scalar value is with respect to the Center(s) of Mass, and does not tell us enough information alone to resolve the collision - it does not take rotation into account (&quot;angular effects&quot;). But its a good start.<br /><br />In the next post, we&#039;ll begin to look at how we resolve a collision at the Particle level.<br />Then we&#039;ll expand on that to handle RigidBody collisions.<br /><br /><br /></div>
    <div class="meta">Posted on 2008-06-03 03:43:06 by Homer</div>
   </div>
   <div class="post" id="post-205439">
    <div class="subject"><a href="#post-205439">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">Let us consider a single Point-collision between two Bodies (or a Body and a fixed surface).<br />We are handed the WorldSpace coordinate of the point of collision, and we are able to transform WorldSpace coordinates into any given BodySpace.<br />At the moment of impact, we are certain that if we transform the collision-point into the space of any Body involved in the collision, that Point will rest apon the Bounding Hull of that Body.<br />In other words, for a Body-Body collision, we can find the BodySpace coordinate of the collision point for EACH body&#039;s space.<br />I&#039;m trying to reinforce something I mentioned earlier - that a Point collision actually involves TWO points - one on each of the colliding entities that happen to meet when the collision occurs.<br />These Points are the places on each entity where the collision-response Impulse should be applied :)<br /><br />So we can begin to describe a general-purpose method for resolving point-based collisions...<br /></div>
    <div class="meta">Posted on 2008-06-03 05:55:53 by Homer</div>
   </div>
   <div class="post" id="post-205445">
    <div class="subject"><a href="#post-205445">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">Here&#039;s an example function which resolves the collision of two PARTICLES.<br />Particles don&#039;t have any Orientation, so this code does NOT handle &#039;Angular Effects&#039;.<br />Because of this, we will *NOT* be using this function.<br />It&#039;s simply an example.<br />Remember that ALL collisions can be expressed in terms of Particle collisions, so the solution for a Rigid Body is sure to be quite similar to this :)<br /><br /><pre><code><br />Method Particle.resolveVelocity,uses esi,pOtherParticle, pvContactNormal, duration:real8<br />LOCAL separatingVelocity:real8,newSepVelocity:real8,restitution:real8, accCausedSepVelocity:real8, impulse:real8<br />LOCAL deltaVelocity:real8,ftemp:real8<br />LOCAL accCausedVelocity:Vec3, impulsePerIMass:Vec3<br />	SetObject esi<br /><br />	; Find the velocity in the direction of the contact.<br />	OCall esi.calculateSeparatingVelocity, pOtherParticle<br />	fstp separatingVelocity<br />	<br />	; Check whether it needs to be resolved.<br />	.if separatingVelocity &gt; 0<br />		; The contact is either separating or stationary - there’s no impulse required.<br />		ExitMethod<br />	.endif<br />	<br />	OCall esi.calculateRestitution, pOtherBody<br />	fstp restitution<br /><br />	; Calculate the new separating velocity.<br />	; newSepVelocity = -separatingVelocity * restitution;<br />	fld separatingVelocity<br />	fchs<br />	fmul restitution<br />	fstp newSepVelocity<br />	<br />	; Check the velocity build-up due to acceleration only.<br />	OCall esi.getLastFrameAcceleration<br />	__StowFloat3 accCausedVelocity<br />	 <br />	.if pOtherParticle!=0<br />		OCall pOtherBody::Particle.getLastFrameAcceleration<br />		__SubFromFloat3 accCausedVelocity, accCausedVelocity<br />	.endif<br />	<br />	;accCausedSepVelocity = accCausedVelocity * contactNormal * duration<br />	mov edx,pvContactNormal<br />	DotProduct accCausedVelocity, .Vec3<br />	fmul duration<br />	fstp accCausedVelocity<br />	<br />	; If we’ve got a closing velocity due to acceleration build-up,<br />	; remove it from the new separating velocity.<br />	.if accCausedSepVelocity &lt; 0<br />		;newSepVelocity += restitution * accCausedSepVelocity;<br />		fld accCausedSepVelocity<br />		fmul restitution<br />		fadd newSepVelocity<br />		fstp newSepVelocity<br /><br />		; Make sure we haven’t removed more than was there to remove.<br />		.if (newSepVelocity &lt; 0)<br />			fmov newSepVelocity , 0.0<br />		.endif<br />	.endif<br />	<br />	;deltaVelocity = newSepVelocity - separatingVelocity<br />	fld newSepVelocity<br />	fsub separatingVelocity<br />	fstp deltaVelocity<br /><br /><br />	; We apply the change in velocity to each object in proportion to<br />	; its inverse mass (i.e., those with lower inverse mass  get less change in velocity).<br />	fld .inverseMass	<br />	.if pOtherParticle!=0<br />		mov edx,pOtherParticle<br />		fadd .Particle.inverseMass<br />		 totalInverseMass += particle[1]-&gt;getInverseMass();<br />	.endif<br />	fstp totalInverseMass<br />	<br />	; If all particles have infinite mass, then impulses have no effect.<br />	.if totalInverseMass &lt;= 0<br />		ExitMethod<br />	.endif<br />	<br />	; Calculate the impulse to apply.<br />	;impulse = deltaVelocity / totalInverseMass;<br />	fld deltaVelocity<br />	fdiv totalInverseMass<br />	fstp impulse<br />	<br />	; Find the amount of impulse per unit of inverse mass.<br />	; impulsePerIMass = contactNormal * impulse<br />	mov edx,pvContactNormal<br />	CrossProduct .Vec3, impulse<br />	__StowFloat3 impulsePerIMass<br />	<br />	; Apply impulses in the direction of the contact, and proportional to the inverse mass.	<br />	;particle.velocity += impulsePerIMass * particle.inverseMass<br />	__ScaleFloat3 impulsePerIMass, .inverseMass<br />	__AddToFloat3 .Velocity, .Velocity<br />	.if pOtherParticle!=0	<br />		; Particle 1 goes in the opposite direction - note how we flip the sign<br />		;particle.velocity += impulsePerIMass * -particle.inverseMass<br />		mov edx,pOtherParticle<br />		fld .Particle.inverseMass<br />		fchs<br />		fstp ftemp		<br />		__ScaleFloat3 impulsePerIMass, ftemp<br />		__AddToFloat3 .Particle.Velocity, .Particle.Velocity<br />		<br />	.endif<br />	<br />MethodEnd<br /></code></pre><br /><br />Next we&#039;ll expand on this to handle angular effects for rigid bodies, and then we&#039;ll add isotropic friction.<br /></div>
    <div class="meta">Posted on 2008-06-03 22:49:48 by Homer</div>
   </div>
   <div class="post" id="post-205447">
    <div class="subject"><a href="#post-205447">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">Before I go on, I&#039;d like to talk about Contact Space.<br />Some of the math problems we&#039;re going to face (especially friction) can be rather difficult to solve if we attempt to solve them in the spatial systems we&#039;re familiar with (worldspace, bodyspace).... but can easily be solved if we move the problem into CONTACT space.<br />In this spatial coordinate system, one of the Axes (say, X) will be our Contact Normal.<br />The other two othogonal axes (Y, Z) are arbitrary - we&#039;ll look at one way to choose them.<br /><br />In order to transform coordinates from worldspace to Contact space, we&#039;ll build a 3x3 transformation matrix. Since this matrix is actually a pure rotation matrix, we can use the Transpose Trick to transform coordinates back the other way (contact-to-world).<br /><br /><br />Now I&#039;m going to show you a NEW TRICK.<br />This is a really efficient way to build a Rotation Matrix, given just one Vector, and the assumption that this Vector will always be the X Axis in the new coordinate system.<br /><br />The 3x3 matrix we&#039;re building can be thought of as a set of 3 column-vectors.<br />Given a vector with components abc, the matrix will look like this:<br />a d g<br />b e h<br />c f i<br /><br />So we&#039;ll need to find two vectors (def and ghi) which are orthogonal to abc and each other.<br />Orthogonal means that they&#039;re 90 degrees apart.<br />The most common ways to find these vectors involve finding the major and minor axes used by our input vector, then performing some cross-products.<br />I&#039;m going to show you a cheating way which just makes the above a stupid idea.<br />Imagine if we have a 2D (XY) set of axes, if we swap the X and Y values, we just rotated the system by 90 degrees - yes?<br />The same is true in a 3D system - except that we ROTATE the axes.<br />abc = acb<br />def = bac<br />ghi = cba<br /><br />So all we have to do is write the same vector component values out into each Column of our matrix, rotating the components as we go.<br />If the input vector was (0.0,0.86,0.5) , then the matrix would be:<br /><br />0.0 0.5 0.86<br />0.86 0.0 0.5 <br />0.5 0.86 0.0<br /><br />We&#039;ll shove our Contact Normal in the first column, and fill out the rest as described.<br />Once we&#039;ve shoved those orthogonal axis vectors in the two remaining columns, we&#039;re done, thats our transform matrix - how we FOUND these orthogonal axes is NOT RELEVANT - if we can find them &quot;as a Given&quot; and with no cost - then why shouldn&#039;t we use them?<br /><br />Perhaps this solution isnt quite right - maybe we need to also toggle the Sign in places - who can contribute to solve this rather simple seeming problem?<br /><br />Actually, I&#039;m SURE that some of the signs are wrong, because that looks suspiciously like a General Rotation Matrix to me !!<br />However - we&#039;ll be transforming data into and out of the coordinate system described by our matrix - its only being used as a TRANSIENT space - we don&#039;t care about the DIRECTION of the two discovered axes - so the SIGN issue really is not an issue at all :)<br /><br /><br /></div>
    <div class="meta">Posted on 2008-06-04 02:27:19 by Homer</div>
   </div>
   <div class="post" id="post-205450">
    <div class="subject"><a href="#post-205450">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body"><br />Anyway, just in case my little cheat is insufficient / Direction is important to us, the following macro was added to the Handy Math include (attached previously).<br />It creates a rotation matrix that transforms coordinates from &#039;Contact Space&#039; into WorldSpace.<br />Since its a pure Rotation matrix, we can use the jolly Transpose trick to transform from WorldSpace to ContactSpace (&quot;TransMult&quot; function)...<br /><br /><pre><code><br />;Creates an Orthogonal set of Normal Vectors (axes) from a given Vector, as Columns of a Mat33<br />;DO NOT USE EDX<br />Mat33_OrthoNormalBasis macro Mat,V<br /><br />	;The X column vector is taken directly from our collision Normal<br />&nbsp; &nbsp; m2m Mat.m00, V.x<br />&nbsp; &nbsp; m2m Mat.m10, V.y<br />&nbsp; &nbsp; m2m Mat.m20, V.z<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Pick an axis which is orthogonal to the Major axis<br />&nbsp; &nbsp; fAbsMax V.x, V.y<br />&nbsp; &nbsp; fstpReg edx<br />&nbsp; &nbsp; .if edx==V.x&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; fld Mat.m00<br />&nbsp; &nbsp; &nbsp; &nbsp; fchs&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; fld Mat.m20<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp;  ;s = 1 /sqrt(m20*m20 + m00*m00)<br />&nbsp; &nbsp; &nbsp; &nbsp; ; The new X-axis is at right angles to the world Y-axis<br />&nbsp; &nbsp;  ;&nbsp;  m01 = m20*s<br />&nbsp; &nbsp;  ;&nbsp;  m11 = 0<br />&nbsp; &nbsp;  ;&nbsp;  m21 = m00*s<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ; The new Y-axis is at right angles to the new X- and Z- axes<br />&nbsp; &nbsp; &nbsp; ;&nbsp; m02 = m10*m01<br />&nbsp; &nbsp; &nbsp; ;&nbsp; m12 = m20*m01 - m00*m21<br />&nbsp; &nbsp; &nbsp; ;&nbsp; m22 = -m10*m01<br />&nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp;  fld1<br />&nbsp; &nbsp; &nbsp; &nbsp;  fld Mat.m20<br />&nbsp; &nbsp; &nbsp; &nbsp;  fmul st(0),st(0)<br />&nbsp; &nbsp; &nbsp; &nbsp;  fld Mat.m00<br />&nbsp; &nbsp; &nbsp; &nbsp;  fmul st(0),st(0)<br />&nbsp; &nbsp; &nbsp; &nbsp;  fadd<br />&nbsp; &nbsp; &nbsp; &nbsp;  fsqrt<br />&nbsp; &nbsp; &nbsp; &nbsp;  fdiv<br />&nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp;  fmul st(2),st(0)<br />&nbsp; &nbsp; &nbsp; &nbsp;  fmul<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; Mat.m11,0<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp Mat.m01&nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; fstp Mat.m21<br />&nbsp; &nbsp; &nbsp; &nbsp; fld&nbsp; Mat.m10<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul Mat.m01<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp Mat.m02<br />&nbsp; &nbsp; &nbsp; &nbsp; fld&nbsp; Mat.m20<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul Mat.m01<br />&nbsp; &nbsp; &nbsp; &nbsp; fld&nbsp; Mat.m00<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul Mat.m21<br />&nbsp; &nbsp; &nbsp; &nbsp; fsub&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; fstp Mat.m12<br />&nbsp; &nbsp; &nbsp; &nbsp; fld&nbsp; Mat.m10&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; fmul Mat.m01<br />&nbsp; &nbsp; &nbsp; &nbsp; fchs<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp Mat.m22<br /><br />&nbsp; &nbsp; .else&nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; fld Mat.m10<br />&nbsp; &nbsp; &nbsp; &nbsp; fld Mat.m20<br />&nbsp; &nbsp; &nbsp; &nbsp; fchs<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ;s = 1/sqrt(m20*m20 + m10*m10)<br />&nbsp; &nbsp; &nbsp; &nbsp; ; The new X-axis is at right angles to the world X-axis<br />&nbsp; &nbsp; &nbsp;  ; m01 = 0<br />&nbsp; &nbsp; &nbsp;  ; m11 = -m20*s<br />&nbsp; &nbsp; &nbsp;  ; m21 = m10*s<br />&nbsp; &nbsp; &nbsp; &nbsp; ; The new Y-axis is at right angles to the new X- and Z- axes<br />&nbsp; &nbsp; &nbsp; &nbsp; ;m02 = m10*m21 - m20*m11<br />&nbsp; &nbsp; &nbsp; &nbsp; ;m12 = -m00*m21<br />&nbsp; &nbsp; &nbsp; &nbsp; ;m22 = m00*m11<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp;  fld1<br />&nbsp; &nbsp; &nbsp; &nbsp;  fld Mat.m20<br />&nbsp; &nbsp; &nbsp; &nbsp;  fmul st(0),st(0)<br />&nbsp; &nbsp; &nbsp; &nbsp;  fld Mat.m10<br />&nbsp; &nbsp; &nbsp; &nbsp;  fmul st(0),st(0)<br />&nbsp; &nbsp; &nbsp; &nbsp;  fadd<br />&nbsp; &nbsp; &nbsp; &nbsp;  fsqrt<br />&nbsp; &nbsp; &nbsp; &nbsp;  fdiv<br />		 ;<br />		 fmul st(2),st(0)<br />		 fmul<br />		 ;<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; Mat.m01,0<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp Mat.m11<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp Mat.m21<br />&nbsp; &nbsp; &nbsp; &nbsp; fld&nbsp; Mat.m10<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul Mat.m21<br />&nbsp; &nbsp; &nbsp; &nbsp; fld&nbsp; Mat.m20<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul Mat.m11<br />&nbsp; &nbsp; &nbsp; &nbsp; fsub<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp Mat.m02<br />&nbsp; &nbsp; &nbsp; &nbsp; fld&nbsp; Mat.m00&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; fmul Mat.m21<br />&nbsp; &nbsp; &nbsp; &nbsp; fchs&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; fstp Mat.m12<br />&nbsp; &nbsp; &nbsp; &nbsp; fld&nbsp; Mat.m00<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul Mat.m11<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp Mat.m22<br /><br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp;  <br />endm<br /></code></pre><br /></div>
    <div class="meta">Posted on 2008-06-04 23:16:29 by Homer</div>
   </div>
   <div class="post" id="post-205451">
    <div class="subject"><a href="#post-205451">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body"><br />Now that we&#039;re able to toss our collision Normal at a macro and spit out a matrix, we&#039;re ready to go on.<br /><br />Our goal is to calculate the impulse at the collision, right?<br />And from there, we&#039;d like to be able to calculate the change in velocity of each object, given that&nbsp; impulse. <br />For the moment, we&#039;re NOT considering Friction - and for Frictionless collisions, the impulses generated at the contact are only applied along the collision normal.<br />Read that again - the IMPULSE is applied ONLY along the collision normal.<br />We’d like to end up with a simple number that tells us the change in velocity AT THE CONTACT POINT, in the direction of the contact normal, for each unit of impulse, something like a SIGNED SCALAR (signed float used as multiplier) would be nice, yes?<br />It&#039;s important to realize that the linear and angular stuff in our Bodies is separate stuff. We have to treat them separately, and then combine them at the end. <br />So lets start with the linear component.<br /><br />The linear component is very simple, noting that this is ONLY for the Linear component <br />The linear change in velocity for a unit impulse will be in the direction of the impulse, with a magnitude given by the inverse mass:<br />DeltaVelocity * Impulse = inverseMass<br />If theres two Bodies involved, inverseMass will be the Sum of their masses (add them).<br /><br />The angular stuff is a bit more tricky, we have to do it in three parts.<br /><pre><code><br />torquePerUnitImpulse =CrossProduct (relativeContactPosition , contactNormal)<br />rotationPerUnitImpulse =inverseInertiaTensor * torquePerUnitImpulse<br />velocityPerUnitImpulse =CrossProduct (rotationPerUnitImpulse , relativeContactPosition)<br /></code></pre><br /><br />The first equation tells us the amount of impulsive torque generated from a unit of impulse.<br />The second one tells us the change in angular velocity for a unit of impulsive torque.<br />And the third tells us the velocity at the contact point which is due only to the body rotating...<br /><br />It is a velocity in world space. When it comes to implementing Friction, we&#039;ll need to transform this Worldspace vector into contact coordinates. This would give us a vector of velocities that a unit impulse would cause. Note that since we DONT have Friction, we&#039;re only interested in the velocity in the direction of the contact normal.<br />In contact coordinates this is the X axis, so our value is the x component of the resulting vector:<br />velocityPerUnitImpulseContact = Mat33_transMult (ContactToWorld,velocityPerUnitImpulse)<br />angularComponent = velocityPerUnitImpulseContact.x<br /><br />Of course we COULD do it that way.<br />But we already know a faster way to find the scalar component of one Vector along another:<br />angularComponent&nbsp; = DotProduct (velocityPerUnitImpulse , contactNormal)<br /><br />For frictionless collisions, the result will be the same, so for frictionless collisions,we don&#039;t actually NEED to use the ContactSpace matrix.<br />But I wanted to show it to you now so that it will &#039;click&#039; in your mind when we do get around to adding Friction.<br /><br />For each object in the collision, we&#039;re now able to calculate the change in both Linear and Angular velocity: at the contact point, and PER UNIT impulse. We now add those velocity values together to get one overall value (even if theres two bodies) which describes the total change in velocity at the collision point.<br /><br />We now know the closing velocity at the contact point.<br />The desired separating velocity is the negative of that.<br />Since we now know the desired separating velocity, we can now calculate an impulse which would produce that velocity change.<br />Then we just need to Apply it..<br /></div>
    <div class="meta">Posted on 2008-06-05 00:10:50 by Homer</div>
   </div>
   <div class="post" id="post-205456">
    <div class="subject"><a href="#post-205456">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">It&#039;s time to start putting together everything we&#039;ve learned :)<br /><br /><pre><code><br />;This is the entrypoint for collision response.<br />Method CollisionHull.CalculateResponse, uses esi, pTargetConfigA,pTargetConfigB,pvContactPoint,pvContactNormal, pBodyB, bWantFriction:BOOL<br />LOCAL relativeContactPositionA:Vec3<br />LOCAL relativeContactPositionB:Vec3<br />LOCAL contactVelocity:Vec3<br />LOCAL desiredDeltaVelocity:real8,&nbsp; restitution:real8<br />LOCAL velocityFromAcc:real4<br />LOCAL impulsiveTorque:Vec3,impulse:Vec3 ;,rotationChange:Vec3<br />LOCAL ContactToWorld:Mat33<br /><br />	SetObject esi<br /><br />&nbsp; &nbsp; ; Calculate a set of axes at the contact point.<br />&nbsp; &nbsp; mov eax,pvContactNormal<br />&nbsp; &nbsp; Mat33_OrthoNormalBasis ContactToWorld, .Vec3<br /><br />&nbsp; &nbsp; ; Find the relative position of the contact<br />&nbsp; &nbsp; mov eax,pvContactPoint<br />&nbsp; &nbsp; mov edx,pTargetConfigA<br />&nbsp; &nbsp; __SubFloat3 .Vec3, .configuration.CMPosition<br />&nbsp; &nbsp; __StowFloat3 relativeContactPositionA&nbsp; &nbsp; <br />&nbsp; &nbsp; fld .CoefficientOfRestitution<br />&nbsp; &nbsp; .if pBodyB!=0<br />	&nbsp; &nbsp; mov eax,pvContactPoint<br />	&nbsp; &nbsp; mov edx,pTargetConfigB<br />	&nbsp; &nbsp; __SubFloat3 .Vec3, .configuration.CMPosition<br />	&nbsp; &nbsp; __StowFloat3 relativeContactPositionB<br />	&nbsp; &nbsp; mov edx,pBodyB<br />	&nbsp; &nbsp; fadd .CollisionHull.CoefficientOfRestitution<br />	&nbsp; &nbsp; fmul r4_Half<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; fstp restitution<br /><br />&nbsp; &nbsp; ; Find the relative velocity at the contact point.<br />&nbsp; &nbsp; OCall esi.calculateLocalVelocity, pTargetConfigA,addr relativeContactPositionA, addr ContactToWorld<br />	__StowFloat3 contactVelocity<br />&nbsp; &nbsp; .if pBodyB!=0<br />&nbsp; &nbsp; 	OCall pBodyB::CollisionHull.calculateLocalVelocity, pTargetConfigB, addr relativeContactPositionB, addr ContactToWorld<br />&nbsp; &nbsp; 	__SubFromFloat3 contactVelocity, contactVelocity<br />&nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; ; Calculate the acceleration-induced velocity accumulated this frame<br />&nbsp; &nbsp; mov velocityFromAcc,0<br />&nbsp; &nbsp; .if .bIsAwake==TRUE<br />&nbsp; &nbsp; 	mov eax,pTargetConfigA<br />&nbsp; &nbsp; 	mov edx,pvContactNormal<br />&nbsp; &nbsp; &nbsp; &nbsp; DotProduct .Vec3, .configuration.CMVelocityChange<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp velocityFromAcc<br />&nbsp; &nbsp; .endif<br />	mov edx,pBodyB<br />&nbsp; &nbsp; .if edx!=0 &amp;&amp; .CollisionHull.bIsAwake==TRUE&nbsp; &nbsp;  	<br />&nbsp; &nbsp; 	mov eax,pTargetConfigB<br />&nbsp; &nbsp; 	mov edx,pvContactNormal<br />&nbsp; &nbsp; &nbsp; &nbsp; DotProduct .Vec3, .configuration.CMVelocityChange<br />&nbsp; &nbsp; &nbsp; &nbsp; fchs<br />&nbsp; &nbsp; &nbsp; &nbsp; fadd velocityFromAcc<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp velocityFromAcc<br />&nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp;  velocityLimit equ r4_Quarter <br />&nbsp; &nbsp; ; Calculate the desired change in velocity for resolution<br />	; desiredDeltaVelocity = -contactVelocity.x -thisRestitution * (contactVelocity.x - velocityFromAcc)<br />&nbsp; &nbsp; ; If the velocity is very slow, limit the restitution<br />&nbsp; &nbsp; fld contactVelocity.x<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fld contactVelocity.x<br />&nbsp; &nbsp; fabs<br />&nbsp; &nbsp; fsub velocityLimit<br />&nbsp; &nbsp; fstpReg eax<br />&nbsp; &nbsp; .ifBitSet eax,BIT31	&nbsp; &nbsp; ;if abs(contactVelocity.x) &lt; velocityLimit&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ;thisRestitution = 0<br />&nbsp; &nbsp; .else<br />&nbsp; &nbsp; 	fsub restitution<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; fld contactVelocity.x<br />&nbsp; &nbsp; fsub velocityFromAcc<br />&nbsp; &nbsp; fmul<br />&nbsp; &nbsp; fstp desiredDeltaVelocity<br /></code></pre><br /><br />Setting up stuff that we&#039;ll need to resolve the collision... pretty much everything we do will be with respect to the Contact point... we&#039;re solving each point-collision with respect to BOTH bodies (if theres two), which reduces the amount of calculations overall.<br /><br />1. The first thing we do is set up our Contact-to-World transform.<br />2. Then we calculate the position of the contact point, relative to the Body or Bodies.<br />We also compute the average Coefficient of Restitution for the Body or Bodies.<br />3. Next, we calculate the absolute velocity of the contact point, relative to the Bodies, and in Contact coords.<br />4. And then we calculate the magnitude of the change in velocity due solely to acceleration during this Frame along the collision normal.<br />5. Finally, we calculate the change in velocity we&#039;d LIKE to see along the collision normal.<br />This, combined with Step 4, will allow us to SCALE the output to exactly what we&#039;d LIKE to see.<br /><br />Stay tuned for the rest of this method!</div>
    <div class="meta">Posted on 2008-06-05 21:07:48 by Homer</div>
   </div>
   <div class="post" id="post-205457">
    <div class="subject"><a href="#post-205457">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">Here&#039;s the rest of that method.<br /><br /><pre><code><br />	; Calculate impulse in Contact coords<br />	.if bWantFriction==FALSE<br />		OCall esi.CalculateFrictionlessImpulse, addr impulse, pvContactNormal, addr ContactToWorld, addr relativeContactPositionA, addr relativeContactPositionB, pTargetConfigA, pBodyB, pTargetConfigB<br />	.else<br />		;Look up the Friction Coefficients based on the Materials of both Bodies<br />		mov eax,sizeof MyTableElement<br />		mul .dMaterialType<br />		.if pBodyB!=0<br />			mov edx,pBodyB<br />			push eax<br />			mov eax,sizeof MyTableRow<br />			mul .CollisionHull.dMaterialType<br />			pop edx<br />			add eax,edx<br />		.endif<br />		lea edx,FrictionTable<br />		add eax,edx			<br />		OCall esi.CalculateFrictionImpulse, addr impulse, addr ContactToWorld, addr contactVelocity,addr relativeContactPositionA,addr relativeContactPositionB,pTargetConfigA,pBodyB,pTargetConfigB, eax<br />	.endif<br /><br />&nbsp; &nbsp; ; Convert impulse from Contact to World coords<br />&nbsp; &nbsp; Vec3_mult_Mat33 ContactToWorld, impulse<br />	__StowFloat3 impulse<br /><br />&nbsp; &nbsp; ; Split the impulse into linear and angular components,<br />&nbsp; &nbsp; ; and apply them to the Body(s) <br />&nbsp; &nbsp; CrossProduct relativeContactPositionA, impulse<br />&nbsp; &nbsp; __StowFloat3 impulsiveTorque&nbsp;  <br />&nbsp; &nbsp; mov eax,pTargetConfigA<br />&nbsp;  <br />	; This is how we would convert ImpulseTorque into Delta-Angular-Velocity<br />	; BUT WE WILL NOT BOTHER because this Simulator loves Angular Momentum <br />	; and so it will extract the Angular Velocity directly from Angular Momentum<br />&nbsp;  ; Vec3_mult_Mat33 .configuration.InverseWorldInertiaTensor,&nbsp; impulsiveTorque<br />&nbsp;  ; __StowFloat3 rotationChange<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ; Here we&#039;re getting linear acceleration (delta-velocity) from the impulse by removing Mass<br />	__ScaleFloat3 impulse, .OneOverMass<br />&nbsp; &nbsp; __AddToFloat3 .vAccumulated_Delta_Velocity,&nbsp; .vAccumulated_Delta_Velocity<br />&nbsp; &nbsp; ; Here we&#039;re just collecting the change in angular momentum due to Torque<br />&nbsp; &nbsp; __LoadFloat3 impulsiveTorque<br />	__AddToFloat3 .vAccumulated_Delta_AngMomentum, .vAccumulated_Delta_AngMomentum		<br />	inc .dNumSimultaneousCollisions<br /><br />&nbsp; &nbsp; .if pBodyB!=0&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ; Work out body one&#039;s linear and angular changes<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ; NOTE :: Crossed members have been SWITCHED<br />&nbsp; &nbsp; &nbsp; &nbsp; ; We have FLIPPED THE SIGN - we want to apply the equal, opposite impulse<br />		CrossProduct impulse, relativeContactPositionB<br />		__StowFloat3 impulsiveTorque&nbsp; <br />		&nbsp; &nbsp;  <br />	;	This is how we would convert ImpulseTorque into Delta-Angular-Velocity<br />	;	BUT WE WILL NOT BOTHER because this Simulator loves Angular Momentum <br />	;	and so it will extract the Angular Velocity directly from Angular Momentum<br />	;	mov eax,pTargetConfigB<br />	;	Vec3_mult_Mat33 .configuration.InverseWorldInertiaTensor, impulsiveTorque<br />	;	__StowFloat3 rotationChange<br />		<br />		; Here we&#039;re getting linear acceleration (delta-velocity) from the impulse by removing Mass<br />		; Note that this time we have FLIPPED THE SIGN - we want to apply the equal, opposite impulse<br />		mov edx,pBodyB		<br />		__NegScaleFloat3 impulse, .CollisionHull.OneOverMass<br />&nbsp; &nbsp; 	__AddToFloat3 .CollisionHull.vAccumulated_Delta_Velocity,&nbsp; .CollisionHull.vAccumulated_Delta_Velocity<br />&nbsp; &nbsp; 	; Collect ye olde momentum<br />&nbsp; &nbsp; 	__LoadFloat3 impulsiveTorque&nbsp; &nbsp; <br />		__AddToFloat3 .CollisionHull.vAccumulated_Delta_AngMomentum, .CollisionHull.vAccumulated_Delta_AngMomentum<br />		inc .CollisionHull.dNumSimultaneousCollisions<br /><br />&nbsp; &nbsp; .endif<br />	<br />MethodEnd<br /></code></pre><br /><br />1. We calculate the Impulse using either with or without Friction.<br />2. The impulse we calculated is in Contact coords, so we convert it to World coords.<br />3. We split the impulse into Linear and Angular components, and apply them to the Body(s).<br /><br />As you can see, I&#039;m not applying them directly - I&#039;m accumulating them so that each Body has the average effect of N impulses applied to it simultaneously - this isnt strictly correct, the real problem is a simultaneous equation, and the real solution involves &#039;Jacobians&#039;, something I&#039;m not too familiar with... but the average of the change in momenta due to N impulses is pretty close and looks believable at a fraction of the cost of the Jacobian solution.<br /><br />Although theres a lot going on here, the really interesting stuff is buried out of sight.. Now I suppose you want to see the new methods whose names were exposed in that source?<br />We&#039;ll do that in the next post :)<br /><br />PS : Attached is an update of the Handy Math includefile, which contains some new stuff including the __NegScaleFloat3 macro, as well as 90% of the other odd-looking macros you&#039;ve seen me using (the remainder can be found in OA32&#039;s fMath includefile)<br />ONLY REGISTERED MEMBERS CAN SEE DOWNLOAD LINKS.<br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2589" target="_blank">Some_Handy_Math.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2008-06-06 00:41:45 by Homer</div>
   </div>
   <div class="post" id="post-205458">
    <div class="subject"><a href="#post-205458">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body"><br />Here&#039;s the first new method we have to look at.<br />This one calculates the velocity of a Point on a moving Body, and expresses it in Contact coordinates , where the X axis is the Collision Normal, and the Y and Z axes are &#039;PLANAR&#039;.<br /><br /><pre><code><br />;Calculate the Velocity at CollisionPoint (in Contact coordinates)<br />;Returns Vec3 on fpu<br />Method CollisionHull.calculateLocalVelocity,uses esi,pTargetConfig,pmatContactToWorld, pvrelativeContactPosition<br />LOCAL velocity:Vec3<br />LOCAL accVelocity:Vec3<br />LOCAL vout:Vec3<br />	SetObject esi<br />	<br />&nbsp; &nbsp; ; Work out the velocity of the contact point.<br />&nbsp; &nbsp; mov eax,pvrelativeContactPosition<br />&nbsp; &nbsp; mov edx,pTargetConfig<br />&nbsp; &nbsp; CrossProduct .configuration.AngularVelocity ,.Vec3<br />&nbsp; &nbsp; __AddToFloat3 velocity, .configuration.CMVelocity<br />&nbsp; &nbsp; __StowFloat3 velocity<br /><br />&nbsp; &nbsp; ; Turn the velocity into contact-coordinates.<br />&nbsp; &nbsp; mov eax,pmatContactToWorld<br />&nbsp; &nbsp; Vec3_transMult .Mat33, velocity<br />&nbsp; &nbsp; __StowFloat3 vout<br /><br />&nbsp; &nbsp; ; Convert &quot;the change in velocity that was due to acceleration In This Frame&quot; into contact-coordinates.<br />&nbsp; &nbsp; mov eax,pmatContactToWorld<br />&nbsp; &nbsp; Vec3_transMult .Mat33, .configuration.CMVelocityChange<br />&nbsp; &nbsp; __StowFloat3 accVelocity<br /><br />&nbsp; &nbsp; ; We ignore any component of acceleration in the contact normal direction, <br />&nbsp; &nbsp; ; we are only interested in &#039;planar&#039; acceleration<br />&nbsp; &nbsp; mov accVelocity.x,0<br /><br />&nbsp; &nbsp; ; Add the planar velocities - if there&#039;s enough friction they will be removed during velocity resolution<br />	__AddFloat3&nbsp; vout, accVelocity<br /><br />MethodEnd<br /><br /></code></pre><br /></div>
    <div class="meta">Posted on 2008-06-06 22:35:31 by Homer</div>
   </div>
   <div class="post" id="post-205472">
    <div class="subject"><a href="#post-205472">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">Nobody noticed the little bug in there so I won&#039;t mention EBX.<br /><br />Here&#039;s your daily dose of fiber :)<br />Please excuse the &#039;debug&#039; macros, as this code was recently debugged and implemented.<br /><br /><pre><code><br />;desiredDeltaVelocity is passed silently as input on FPU<br />Method CollisionHull.CalculateFrictionlessImpulse,uses esi,pvimpulseContactOut,pvContactNormal, pmatContactBasis,pvRelativeContactPositionA, pvRelativeContactPositionB, pconfigA,pBodyB,pconfigB<br />LOCAL deltaVelWorld:Vec3<br />LOCAL deltaVelocity:real8<br />LOCAL desiredDeltaVelocity:real8<br />	fstp desiredDeltaVelocity		;&lt;--<br />	DbgFloat desiredDeltaVelocity<br />	<br />	SetObject esi<br />	<br />&nbsp; &nbsp; ; Build a vector that shows the change in velocity (in world space)<br />&nbsp; &nbsp; ; for a UNIT impulse in the direction of the contact normal.&nbsp;  <br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Calculate the Torque per Unit of Impulse<br />&nbsp; &nbsp; mov eax,pvContactNormal				<br />&nbsp; &nbsp; mov ecx,pvRelativeContactPositionA	<br />&nbsp; &nbsp; CrossProduct .Vec3, .Vec3 	<br />&nbsp; &nbsp; __StowFloat3 deltaVelWorld&nbsp; &nbsp; 			;torquePerUnitImpulse = CrossProduct(relativeContactPosition,contactNormal)&nbsp; &nbsp; <br />&nbsp; &nbsp; lea edx,deltaVelWorld<br />&nbsp; &nbsp; DbgVec3 edx,&quot;torquePerUnitImpulse&quot;<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Use InverseInertiaTensor to convert Torque into rotationPerUnitImpulse<br />&nbsp; &nbsp; mov ecx,pconfigA<br />&nbsp; &nbsp; Vec3_mult_Mat33&nbsp; .configuration.InverseWorldInertiaTensor, deltaVelWorld<br />&nbsp; &nbsp; __StowFloat3 deltaVelWorld <br />&nbsp; &nbsp; lea edx,deltaVelWorld<br />&nbsp; &nbsp; DbgVec3 edx,&quot;rotationPerUnitImpulse&quot;<br /><br />	;Find the Linear Velocity that is due to rotation and that is along the collision normal<br />&nbsp; &nbsp; mov ecx,pvRelativeContactPositionA		;velocityPerUnitImpulse = CrossProduct(rotationPerUnitImpulse, relativeContactPosition)<br />	CrossProduct deltaVelWorld,&nbsp; .Vec3<br />	__StowFloat3 deltaVelWorld<br />	<br />&nbsp; &nbsp; ; Work out the change in velocity in contact coordinates.<br />&nbsp; &nbsp; ;ImpulseDenominator = Body.OneOverMass + DotProduct(velocityPerUnitImpulse,CollisionNormal)		<br />&nbsp; &nbsp; mov eax,pvContactNormal<br />&nbsp; &nbsp; DotProduct deltaVelWorld, .Vec3<br />&nbsp; &nbsp; fadd .OneOverMass<br />&nbsp; &nbsp; fstp deltaVelocity<br /><br />&nbsp; &nbsp; ; Check if we need the second body&#039;s data<br />&nbsp; &nbsp; .if pBodyB!=0&nbsp; &nbsp; <br />&nbsp; &nbsp; 	int 3<br />&nbsp; &nbsp; &nbsp; &nbsp; ; Go through the same transformation sequence again<br />	&nbsp; &nbsp; mov eax,pvContactNormal<br />	&nbsp; &nbsp; mov ecx,pvRelativeContactPositionB<br />	&nbsp; &nbsp; CrossProduct .Vec3, .Vec3 <br />	&nbsp; &nbsp; __StowFloat3 deltaVelWorld&nbsp;  <br />	&nbsp; &nbsp; mov ecx,pconfigB<br />	&nbsp; &nbsp; Vec3_mult_Mat33&nbsp; .configuration.InverseWorldInertiaTensor, deltaVelWorld<br />		__StowFloat3 deltaVelWorld <br />	&nbsp; &nbsp; mov ecx,pvRelativeContactPositionB<br />		CrossProduct deltaVelWorld,&nbsp; .Vec3<br />		__StowFloat3 deltaVelWorld<br />		<br />&nbsp; &nbsp; &nbsp; &nbsp; ; Add the change in velocity due to rotation<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,pvContactNormal<br />&nbsp; &nbsp; &nbsp; &nbsp; DotProduct deltaVelWorld, .Vec3<br />&nbsp; &nbsp; &nbsp; &nbsp; fadd deltaVelocity<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,pBodyB<br />&nbsp; &nbsp; &nbsp; &nbsp; fadd .CollisionHull.OneOverMass<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp deltaVelocity<br />&nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; ; Calculate the required size of the impulse<br />&nbsp; &nbsp; mov edx,pvimpulseContactOut<br />&nbsp; &nbsp; fld desiredDeltaVelocity<br />&nbsp; &nbsp; fdiv deltaVelocity<br />&nbsp; &nbsp; fstp .Vec3.x<br />&nbsp; &nbsp; mov&nbsp; .Vec3.y,0 <br />&nbsp; &nbsp; mov&nbsp; .Vec3.z,0<br />&nbsp; &nbsp; DbgVec3 edx,&quot;IMPULSE contact space&quot;<br />&nbsp; &nbsp; <br />MethodEnd<br /></code></pre><br /><br />The goal of this method is to produce a vector that contains an Impulse, given in ContactSpace coordinates. Remember that in Contact space, the X axis points along our Collision Normal, so X will contain the impulse along the collision normal, the one we really want. The Y and Z axes, which lay along the collision surface, are totally not used in a Frictionless collision, so we just set them to Zero.<br />You can take a look back to the Response method if you&#039;re interested in what happens to the returned impulse vector.<br /><br />One method to go, and I believe we&#039;re done here.<br />Next we&#039;ll be looking at the FRICTIONAL impulse calculation.<br />Take the time to study the above method, as the Frictional version is quite similar, although a little more complex (we&#039;ll be using those Y and Z fields of the contactspace impulse).<br /><br />After we&#039;ve covered the last method, you&#039;ll realize that THIS method could have been implemented without any mention of &#039;contact space&#039; at all.<br />The reason we&#039;ve wasted our time converting to and from contact space is to give you the foundation knowledge to understand the Frictional version, where this WILL be required.<br /></div>
    <div class="meta">Posted on 2008-06-08 21:43:57 by Homer</div>
   </div>
   <div class="post" id="post-205474">
    <div class="subject"><a href="#post-205474">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">Here&#039;s the final piece of the puzzle.<br />With this method in place, we have a fully-functional collision detection and response system that accurately simulates collisions between multiple rigid bodies comprised of materials with known physical properties.<br /><br /><pre><code><br />;desiredDeltaVelocity is passed silently as input on FPU<br />Method CollisionHull.CalculateFrictionImpulse,uses esi,pvimpulseContactOut, pmatContactBasis,pvContactVelocity,pvrelativeContactPositionA,pvrelativeContactPositionB,pconfigA,pBodyB,pconfigB, LP_frictions<br />LOCAL impulseToTorque:Mat33, tempmat:Mat33<br />LOCAL deltaVelWorld:Mat33, deltaVelWorld2:Mat33<br />LOCAL deltaVelocity:Mat33, impulseMatrix:Mat33<br />LOCAL velKill:Vec3<br />LOCAL inverseMass:real8, planarImpulse:real8<br />LOCAL desiredDeltaVelocity:real8<br />	fstp desiredDeltaVelocity	<br />	SetObject esi<br />	<br />	fld .OneOverMass<br />	fstp inverseMass<br /><br />&nbsp; &nbsp; ; The equivalent of a cross product in matrices is multiplication<br />&nbsp; &nbsp; ; by a skew symmetric matrix - we build the matrix for converting<br />&nbsp; &nbsp; ; between linear and angular quantities.<br />&nbsp; &nbsp; mov eax,pvrelativeContactPositionA<br />&nbsp; &nbsp; Mat33_star impulseToTorque, .Vec3<br />&nbsp; &nbsp; DbgMat33 impulseToTorque, &quot;impulseToTorque matrix&quot;<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ; Build the matrix to convert contact impulse --&gt; change in velocity in world coordinates.<br />&nbsp; &nbsp; mov eax,pconfigA<br />&nbsp; &nbsp; invoke Mat33_multiply,addr tempmat, 		&nbsp; addr impulseToTorque, addr .configuration.InverseWorldInertiaTensor<br />&nbsp; &nbsp; invoke Mat33_multiply,addr deltaVelWorld, 	&nbsp; addr tempmat ,		addr impulseToTorque <br />&nbsp; &nbsp; Mat33_neg deltaVelWorld<br />	DbgMat33 deltaVelWorld,&quot;impulseToDeltaVelocity WORLDSPACE&quot;<br />&nbsp; &nbsp; .if pBodyB!=0<br />&nbsp; &nbsp; 	mov eax,pvrelativeContactPositionA<br />&nbsp; &nbsp; 	Mat33_star impulseToTorque, .Vec3<br />	&nbsp; &nbsp; invoke Mat33_multiply,addr tempmat, 		&nbsp; addr impulseToTorque, addr .configuration.InverseWorldInertiaTensor<br />	&nbsp; &nbsp; invoke Mat33_multiply,addr deltaVelWorld2, 	&nbsp; addr tempmat ,		addr impulseToTorque <br />		Mat33_neg deltaVelWorld2<br />&nbsp; &nbsp; &nbsp; &nbsp; ; Add to the total delta velocity.<br />&nbsp; &nbsp; &nbsp; &nbsp; ;deltaVelWorld += deltaVelWorld2;<br />&nbsp; &nbsp; &nbsp; &nbsp; lea eax,deltaVelWorld<br />&nbsp; &nbsp; &nbsp; &nbsp; lea edx,deltaVelWorld2<br />&nbsp; &nbsp; &nbsp; &nbsp; Mat33_addto eax,edx<br />&nbsp; &nbsp; &nbsp; &nbsp; fld inverseMass<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,pBodyB<br />&nbsp; &nbsp; &nbsp; &nbsp; fadd .CollisionHull.OneOverMass<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp inverseMass<br />&nbsp; &nbsp; .endif&nbsp; &nbsp; <br />&nbsp; &nbsp; ; Do a change-of-basis to convert into contact coordinates.<br />&nbsp; &nbsp; mov eax,pmatContactBasis<br />&nbsp; &nbsp; Mat33_Transpose deltaVelocity, .Mat33	;Contact-To-World transform&nbsp; &nbsp; <br />	DbgMat33 deltaVelocity,&quot;Transpose of ContactToWorld = WorldToContact&quot;<br />&nbsp; &nbsp; invoke Mat33_multiply,addr tempmat,		&nbsp; addr deltaVelocity,addr deltaVelWorld<br />&nbsp; &nbsp; invoke Mat33_multiply,addr deltaVelocity, addr tempmat, 	 pmatContactBasis<br />&nbsp; &nbsp; DbgMat33 deltaVelocity,&quot;impulseToDeltaVelocity CONTACTSPACE&quot;<br /><br />&nbsp; &nbsp; ; Add in the linear velocity change<br />&nbsp; &nbsp; fld inverseMass<br />&nbsp; &nbsp; fadd deltaVelocity.m00<br />&nbsp; &nbsp; fstp deltaVelocity.m00<br />&nbsp; &nbsp; fld inverseMass<br />&nbsp; &nbsp; fadd deltaVelocity.m11<br />&nbsp; &nbsp; fstp deltaVelocity.m11<br />&nbsp; &nbsp; fld inverseMass<br />&nbsp; &nbsp; fadd deltaVelocity.m22<br />	fstp deltaVelocity.m22<br />	DbgMat33 deltaVelocity,&quot;impulseMatrix&quot;<br /><br />&nbsp; &nbsp; ; Invert to get the impulse needed per unit velocity<br />&nbsp; &nbsp; invoke Mat33_inv,addr impulseMatrix ,addr deltaVelocity<br />	DbgMat33 impulseMatrix,&quot;impulseMatrix inverted&quot;<br /><br />&nbsp; &nbsp; ; Find the target velocities to kill<br />&nbsp; &nbsp; mov edx,pvContactVelocity<br />&nbsp; &nbsp; fld desiredDeltaVelocity<br />&nbsp; &nbsp; fstp velKill.x<br />&nbsp; &nbsp; fld .Vec3.y<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fstp velKill.y<br />&nbsp; &nbsp; fld .Vec3.z<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fstp velKill.z<br />&nbsp; &nbsp; ; Find the impulse to kill target velocities<br />&nbsp; &nbsp; Vec3_mult_Mat33 impulseMatrix, velKill<br />&nbsp; &nbsp; mov eax,pvimpulseContactOut<br />&nbsp; &nbsp; __StowFloat3 .Vec3<br /><br />&nbsp; &nbsp; ; Check if theres enough PLANAR IMPULSE to overcome STATIC FRICTION<br />&nbsp; &nbsp; fld .Vec3.y<br />&nbsp; &nbsp; fmul st(0),st(0)<br />&nbsp; &nbsp; fld .Vec3.z<br />&nbsp; &nbsp; fmul st(0),st(0)<br />&nbsp; &nbsp; fadd<br />&nbsp; &nbsp; fsqrt<br />&nbsp; &nbsp; fstp planarImpulse<br />&nbsp; &nbsp; ;if (planarImpulse &gt; impulseContact.x * STATIC friction)<br />&nbsp; &nbsp; fld .Vec3.x<br />&nbsp; &nbsp; mov edx,LP_frictions<br />&nbsp; &nbsp; fmul .MyTableElement._Static<br />&nbsp; &nbsp; fsub planarImpulse<br />&nbsp; &nbsp; fstpReg eax<br />&nbsp; &nbsp; .ifBitSet eax,BIT31<br />&nbsp; &nbsp; &nbsp; &nbsp; ; We need to use DYNAMIC friction<br />&nbsp; &nbsp; 	mov eax,pvimpulseContactOut&nbsp; &nbsp; 	&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; fld .Vec3.y<br />&nbsp; &nbsp; &nbsp; &nbsp; fdiv planarImpulse<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp .Vec3.y<br />&nbsp; &nbsp; &nbsp; &nbsp; fld .Vec3.z<br />&nbsp; &nbsp; &nbsp; &nbsp; fdiv planarImpulse<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp .Vec3.z<br />&nbsp; &nbsp; &nbsp; &nbsp; ;impulseContact.x =&nbsp; deltaVelocity.data[0] +<br />&nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp; 			&nbsp; &nbsp; deltaVelocity.data[1]*friction*impulseContact.y +<br />&nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp; &nbsp; 				deltaVelocity.data[2]*friction*impulseContact.z;<br />&nbsp; &nbsp; &nbsp; &nbsp; ;impulseContact.x = desiredDeltaVelocity / impulseContact.x;<br />&nbsp; &nbsp; &nbsp; &nbsp; ;impulseContact.y *= friction * impulseContact.x;<br />&nbsp; &nbsp; &nbsp; &nbsp; ;impulseContact.z *= friction * impulseContact.x;<br />&nbsp; &nbsp; &nbsp; &nbsp; fld desiredDeltaVelocity<br />&nbsp; &nbsp; &nbsp; &nbsp; fld deltaVelocity.m11<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul .MyTableElement._Dynamic<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul .Vec3.y <br />&nbsp; &nbsp; &nbsp; &nbsp; fadd deltaVelocity.m00<br />&nbsp; &nbsp; &nbsp; &nbsp; fld deltaVelocity.m22<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul .MyTableElement._Dynamic<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul .Vec3.z<br />&nbsp; &nbsp; &nbsp; &nbsp; fadd<br />&nbsp; &nbsp; &nbsp; &nbsp; fdiv<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp .Vec3.x<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; fld&nbsp; .Vec3.y<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul .MyTableElement._Dynamic<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp .Vec3.y<br />&nbsp; &nbsp; &nbsp; &nbsp; fld&nbsp; .Vec3.z<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul .MyTableElement._Dynamic<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp .Vec3.z&nbsp; &nbsp;  <br />&nbsp; &nbsp; .endif<br />MethodEnd<br /></code></pre><br /></div>
    <div class="meta">Posted on 2008-06-09 00:47:40 by Homer</div>
   </div>
   <div class="post" id="post-205482">
    <div class="subject"><a href="#post-205482">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">Well, perhaps not the final piece.<br />Having implemented all this stuff in a demo, I found that my demo was &#039;mostly stable&#039; - but that under certain conditions, bodies were able to penetrate the world bounding planes and cause the simulator to enter into an infinite loop.<br />The above system was supposed to make penetrations an impossible thing, but nonetheless under rare circumstances the system is failing, and the immediate problem is unexpected (inter)penetration of one or more bodies.<br />So, we&#039;re going to need to resolve these penetrations when they occur.<br />One way we could do that is simply to &#039;move&#039; the bodies out of penetration along the collision normal, but that is not accurate.. it assumes that only LINEAR motion was responsible for the penetration, and indeed it causes error in our body&#039;s state since we didn&#039;t correct the velocity(s) and other stuff.. so what are we gonna do?<br /><br />To resolve a penetration, we wish to &#039;go backwards in Time&#039; until the Penetration becomes a Collision, resolve the collision, and then &#039;go forwards in Time&#039; so that our Body is back in sync with the rest of the simulation. But our goal won&#039;t be to calculate how much negative Time we need...<br />The reason that we didn&#039;t detect this Penetration BEFORE it occurred (as we planned to) is that there&#039;s a relatively high velocity at the point of collision, so the Time involved is so small that it becomes problematic in terms of numerical precision... it escaped our temporal search , it must be really small, so we can&#039;t use Time.<br />We&#039;ll need to directly manipulate the physical states of our body(s), and work with the Velocities instead.<br /><br />Let us assume that our system can at least tell us how deep the penetration is..<br />The penetration was caused by the motion of the body (or bodies). <br />We must recognize that this motion has two components - linear and angular.<br />Each component is partly responsible for the collision.<br />Can we determine HOW MUCH each is responsible? Yep, we sure can.<br />If we review the calculation of a collision response impulse, the first thing we did was calculate the total velocity at the collisionpoint due to both angular and linear motion.<br />We were able to determine how much velocity was due to Angular motion alone, yes?.<br />That is what we need now.<br />We need to find two Scaling values which represent the contributions of the linear and angular motions to the total penetration depth, and from them, calculate the translation and rotation required to bring that penetration depth to Zero.<br />I think we&#039;ll tackle this one in stages, its not huge, but its mathematically hairy - even though it only uses stuff we&#039;ve already seen.<br /><br /><br /></div>
    <div class="meta">Posted on 2008-06-12 00:45:48 by Homer</div>
   </div>
   <div class="post" id="post-205483">
    <div class="subject"><a href="#post-205483">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body"><br />We need to separate the angular and linear parts of this problem... we&#039;re trying to find the amount of the penetration due to EACH component, based on their &#039;relative intensities&#039;.<br />Here&#039;s the most important method we&#039;ll require to solve this problem - it tells us the momentum of a given Body, along a given direction :)<br />If we wanted the Velocity, we could remove the Mass component (momemtum=velocity * mass).<br /><br /><pre><code><br />;**Returns float on FPU<br />;Given a Collision Normal and a Contact Point, <br />;this method calculates the Linear Momentum<br />;that is due ONLY to rotation, and which is in<br />;the direction of the Collision Normal.<br />Method CollisionHull.Calculate_AngularMomentum_along_Normal,uses esi,pvContactNormal, pvrelativeContactPosition, pconfig<br />LOCAL angularInertiaWorld:Vec3<br />	SetObject esi<br />	;Calculate Torque per unit impulse at contact point<br />	mov edx,pvContactNormal<br />	mov eax,pvrelativeContactPosition<br />	CrossProduct .Vec3, .Vec3			;torque = R cross N = change in angular momentum over time<br />	__StowFloat3 angularInertiaWorld<br />	mov edx,pconfig<br />	;Convert Torque into Angular Momentum<br />	Vec3_mult_Mat33 .configuration.InverseWorldInertiaTensor, angularInertiaWorld		;rotation = !I * torque = change in angular velocity	<br />	__StowFloat3 angularInertiaWorld<br />	;Find the Linear part of that Angular motion<br />	mov edx,pvrelativeContactPosition<br />	CrossProduct angularInertiaWorld , .Vec3<br />	__StowFloat3 angularInertiaWorld<br />	;Find the Linear part that is along the Normal<br />	mov edx,pvContactNormal<br />	DotProduct angularInertiaWorld ,&nbsp; .Vec3		<br />MethodEnd<br /></code></pre><br /><br />This method returns a floating point value representing the given Body&#039;s momentum in the given direction... since its a direction, you MUST provide a Normal vector. We&#039;ll be passing the Collision Normal, but we COULD use this method to find the Body&#039;s momentum in ANY given direction.<br />It&#039;s telling us how much the Rotation Motion is responsible for total linear motion at a given Point on the Body.<br />Our solver will use this value to determine how much the Linear Motion is responsible for total linear motion at that Point, so we then know how much EACH is responsible.<br />From there we can solve our problem.</div>
    <div class="meta">Posted on 2008-06-12 02:39:56 by Homer</div>
   </div>
   <div class="post" id="post-205484">
    <div class="subject"><a href="#post-205484">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">The entrypoint for our penetration-solver is called Resolve_Penetration (oddly enough).<br />Here&#039;s the first few lines from that method.<br /><br /><br /><pre><code><br />;Corrects a Penetration of two Bodies, but does not resolve the Collision<br />Method CollisionHull.Resolve_Penetration, uses esi, pvContactNormal, pvrelativeContactPosition, pOtherBody, pSourceA,pTargetA,pSourceB,pTargetB,fPenetrationDepth:real8<br />LOCAL angularInertiaWorld:Vec3<br />LOCAL angularMoveA:real4, angularMoveB:real4<br />LOCAL linearMoveA:real4, linearMoveB:real4<br />LOCAL linearChangeA:Vec3, linearChangeB:Vec3<br />LOCAL angularChangeA:Vec3, angularChangeB:Vec3<br />LOCAL totalMoveA:real4,totalMoveB:real4<br />local maxMagnitude:real8<br />local totalInertia:real8<br />local angularMomentumA:real8, angularMomentumB:real8<br />LOCAL targetAngularDirectionA:Vec3,targetAngularDirectionB:Vec3<br />LOCAL projection:Vec3<br />LOCAL ftemp<br /><br />	SetObject esi<br />&nbsp; &nbsp; ; We need to find the momentum of each object in the direction<br />&nbsp; &nbsp; ; of the contact normal which is due to rotation only...<br /> 	OCall 						esi.Calculate_AngularMomentum_along_Normal, pvContactNormal, pvrelativeContactPosition, pSourceA<br /> 	fstp&nbsp; angularMomentumA<br /> 	OCall pOtherBody::CollisionHull.Calculate_AngularMomentum_along_Normal, pvContactNormal, pvrelativeContactPosition, pSourceB<br /> 	fst&nbsp; angularMomentumB 	<br /> 	;Now calculate the TOTAL momentum with respect to the collision normal<br /> 	fadd&nbsp; angularMomentumA			 	<br /> 	fadd .OneOverMass					;Add the Linear component of momentum<br /> 	mov edx,pOtherBody<br /> 	fadd .CollisionHull.OneOverMass<br /> 	fstp&nbsp; totalInertia<br /><br /></code></pre><br /><br />You can see we&#039;re calculating the linear momentum along the collision normal which is solely due to the Rotation of each Body, as well as the Total linear momentum (again, along the collision normal). Don&#039;t get confused about the terms Inertia and Momentum ... the only real difference is that one is the signed opposite of the other... although not strictly correct, I use these terms interchangeably in my variable names.<br />Now let&#039;s see how we use those results to calculate that part of PenetrationDepth that is attributable to the Linear and to the Angular motions:<br /><pre><code><br />	;Determine how much the Linear and Angular motions each contributed to the Penetration,<br />	;and thereby, how much each must contribute to the Correction.<br />&nbsp; &nbsp; fld angularMomentumA<br />&nbsp; &nbsp; fdiv totalInertia<br />&nbsp; &nbsp; fmul fPenetrationDepth<br />&nbsp; &nbsp; fstp angularMoveA<br />&nbsp; &nbsp; ;<br />&nbsp; &nbsp; fld .OneOverMass<br />&nbsp; &nbsp; fdiv totalInertia<br />&nbsp; &nbsp; fmul fPenetrationDepth<br />&nbsp; &nbsp; fstp linearMoveA<br />&nbsp; &nbsp; ;<br />&nbsp; &nbsp; fld angularMomentumB<br />&nbsp; &nbsp; fdiv totalInertia<br />&nbsp; &nbsp; fmul fPenetrationDepth<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fstp angularMoveB<br />&nbsp; &nbsp; ;<br />&nbsp; &nbsp; mov edx,pOtherBody<br />&nbsp; &nbsp; fld .CollisionHull.OneOverMass<br />&nbsp; &nbsp; fdiv totalInertia<br />&nbsp; &nbsp; fmul fPenetrationDepth<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fstp linearMoveB<br /></code></pre><br /><br />Now we are in business&nbsp; 8)<br />From these two partial-PenDepth values we can calculate the changes in linear and angular position that are required to balance the equations such that the PenDepth &#039;disappears&#039; (is equal to zero), and then adjust the linear and angular Velocities to suit.<br />We&#039;ll see how to do that next time :)<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-06-12 08:17:28 by Homer</div>
   </div>
   <div class="post" id="post-205487">
    <div class="subject"><a href="#post-205487">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">I&#039;ve added a little &#039;floor grid&#039; to my demo so that we can better visualize the collisions of the demo body and the floor plane.<br /><br />Here&#039;s a wishlist of other stuff I basically forgot about.<br />Chances are this list will grow!<br /><br />-Improved support for Edge and Face collisions (reduced number of Point collision responses)<br />-Some basic gui menu controls for manipulating and resetting the demo simulation<br />-()<br /><br />And now we return you to your feature program.</div>
    <div class="meta">Posted on 2008-06-13 02:53:48 by Homer</div>
   </div>
   <div class="post" id="post-205491">
    <div class="subject"><a href="#post-205491">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">OK lets get some closure on the current issue.<br />Here&#039;s the entire procedure, with small recent changes.<br />Take note of the &#039;angularLimit&#039; threshold, which is used to limit the amount of Rotational correction, which places more load on the Linear correction.<br />This threshold is mostly for body/body collisions, where the bodies may vary greatly in mass, causing acute projections for the body with smaller mass.<br /><br /><pre><code><br />;Corrects a Penetration but does not resolve the Collision<br />Method CollisionHull.Resolve_Penetration, uses esi, pvContactNormal, pvrelativeContactPositionA, pvrelativeContactPositionB,pOtherBody, pSourceA,pTargetA,pSourceB,pTargetB,fPenetrationDepth:real8<br />LOCAL angularInertiaWorld:Vec3<br />LOCAL angularMoveA:real4, angularMoveB:real4<br />LOCAL linearMoveA:real4, linearMoveB:real4<br />LOCAL linearChangeA:Vec3, linearChangeB:Vec3<br />LOCAL angularChangeA:Vec3, angularChangeB:Vec3<br />LOCAL totalMoveA:real4,totalMoveB:real4<br />local maxMagnitude:real8<br />local totalInertia:real8<br />local angularMomentumA:real8, angularMomentumB:real8<br />LOCAL targetAngularDirectionA:Vec3,targetAngularDirectionB:Vec3<br />LOCAL projection:Vec3<br />LOCAL ftemp<br /><br />	SetObject esi<br />	<br />	DbgFloat fPenetrationDepth<br />	<br />&nbsp; &nbsp; ; We need to find the momentum of each object in the direction<br />&nbsp; &nbsp; ; of the contact normal which is due to rotation only...<br /> 	OCall esi.Calculate_AngularMomentum_along_Normal, pvContactNormal, pvrelativeContactPositionA, pSourceA<br /> 	fabs<br /> 	DbgFST angularMomentumA<br /> 	.if pOtherBody!=0<br />	 	OCall pOtherBody::CollisionHull.Calculate_AngularMomentum_along_Normal, pvContactNormal, pvrelativeContactPositionB, pSourceB<br />	 	fabs<br />	 	DbgFST angularMomentumB <br />	 	fadd	<br />	 	mov edx,pOtherBody<br /> 		fadd .CollisionHull.OneOverMass<br />	.endif	<br />	<br /> 	;Now calculate the TOTAL momentum with respect to the collision normal<br /> 	fadd .OneOverMass					;Add the Linear component of momentum<br /> 	DbgFSTP totalInertia<br /><br /><br />	;Determine how much the Linear and Angular motions each contributed to the Penetration,<br />	;and thereby, how much each must contribute to the Correction.<br />&nbsp; &nbsp; fld angularMomentumA<br />&nbsp; &nbsp; fdiv totalInertia<br />&nbsp; &nbsp; fmul fPenetrationDepth<br />&nbsp; &nbsp; DbgFSTP angularMoveA<br />&nbsp; &nbsp; ;whatevers left over is the linear correction<br />&nbsp; &nbsp; fld fPenetrationDepth<br />&nbsp; &nbsp; fsub angularMoveA<br />&nbsp; &nbsp; DbgFSTP linearMoveA<br />&nbsp; &nbsp; ;<br />	<br />&nbsp; &nbsp; ; To avoid angular projections that are too great <br />&nbsp; &nbsp; ; (when mass is large but inertia tensor is small) <br />&nbsp; &nbsp; ; we will limit the angular move.<br />&nbsp; &nbsp; mov edx,pvContactNormal<br />&nbsp; &nbsp; mov eax,pvrelativeContactPositionA<br />&nbsp; &nbsp; DotProduct .Vec3,.Vec3<br />&nbsp; &nbsp; DbgFSTP ftemp<br />&nbsp; &nbsp; __ScaleFloat3 .Vec3, ftemp<br />&nbsp; &nbsp; __AddToFloat3 projection, .Vec3<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ; Use the small angle approximation for the sine of the angle <br />&nbsp; &nbsp; ; i.e. the magnitude would be sine(angularLimit) * projection.magnitude<br />&nbsp; &nbsp; ; but we approximate sine(angularLimit) to angularLimit<br />&nbsp; &nbsp; ; maxMagnitude = angularLimit * projection.magnitude<br />&nbsp; &nbsp; DotProduct projection,projection<br />&nbsp; &nbsp; fsqrt<br />&nbsp; &nbsp; fmul angularLimit<br />&nbsp; &nbsp; fst maxMagnitude<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; DbgFSTP ftemp<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; fMin angularMoveA, ftemp				;if (angularMoveA &lt; -maxMagnitude)<br />&nbsp; &nbsp; fstpReg eax<br />&nbsp; &nbsp; .if eax==angularMoveA&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; 	DbgWarning &quot;FLOOR CLAMP on angular correction&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; fld linearMoveA<br />&nbsp; &nbsp; &nbsp; &nbsp; fadd angularMoveA<br />&nbsp; &nbsp; &nbsp; &nbsp; DbgFSTP totalMoveA<br />&nbsp; &nbsp; &nbsp; &nbsp; fld maxMagnitude<br />&nbsp; &nbsp; &nbsp; &nbsp; fchs<br />&nbsp; &nbsp; &nbsp; &nbsp; DbgFSTP angularMoveA<br />&nbsp; &nbsp; &nbsp; &nbsp; fld totalMoveA<br />&nbsp; &nbsp; &nbsp; &nbsp; fsub angularMoveA<br />&nbsp; &nbsp; &nbsp; &nbsp; DbgFSTP linearMoveA&nbsp; &nbsp; <br />&nbsp; &nbsp; .else								<br />	&nbsp; &nbsp; fMax angularMoveA, maxMagnitude&nbsp; 	;elseif (angularMoveA &gt; maxMagnitude)<br />	&nbsp; &nbsp; fstpReg eax<br />	&nbsp; &nbsp; .if eax==angularMoveA <br />		&nbsp; &nbsp; DbgWarning &quot;CEILING CLAMP on angular correction&quot;&nbsp; &nbsp; &nbsp;  <br />			fld linearMoveA<br />			fadd angularMoveA<br />			DbgFSTP totalMoveA		&nbsp; &nbsp;  <br />		&nbsp; &nbsp; fld maxMagnitude<br />		&nbsp; &nbsp; DbgFSTP angularMoveA<br />	&nbsp; &nbsp; &nbsp; &nbsp; fld totalMoveA<br />	&nbsp; &nbsp; &nbsp; &nbsp; fsub angularMoveA<br />	&nbsp; &nbsp; &nbsp; &nbsp; DbgFSTP linearMoveA<br />	&nbsp; &nbsp; .endif<br /> 	.endif<br /><br />&nbsp; &nbsp; ; We have the linear amount of movement required by ROTATING the rigid body (in angularMoveA). <br />&nbsp; &nbsp; ; We now need to calculate the desired rotation to achieve that.<br />&nbsp; &nbsp;  .if (angularMoveA == 0 || angularMoveA==80000000h)&nbsp; &nbsp; &nbsp; &nbsp; <br />		; Easy case - no angular movement means no rotation.<br />		fldz<br />		fst angularChangeA.x<br />		fst angularChangeA.y<br />		fstp angularChangeA.z&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />	.else&nbsp; &nbsp; &nbsp; &nbsp; <br />		; Work out the direction we&#039;d like to rotate in.<br />		; targetAngularDirection = CrossProduct (relativeContactPositionA,contactNormal)<br />		mov edx,pvrelativeContactPositionA<br />		mov eax,pvContactNormal<br />		CrossProduct .Vec3, .Vec3		;torque<br />		__StowFloat3 targetAngularDirectionA	;Its a Direction because we used a Normal vector<br />		; Convert the &#039;Torque&#039; into &#039;change in Angular Velocity&#039;<br />		mov eax,pTargetA<br />		Vec3_mult_Mat33 .configuration.InverseWorldInertiaTensor, targetAngularDirectionA	;= desired angular velocity<br />		;Scale the Angular Velocity by our DESIRED angular velocity<br />		fld angularMoveA<br />		fdiv angularMomentumA<br />		fmul st(3),st(0)<br />		fmul st(2),st(0)<br />		fmul		<br />		__StowFloat3 angularChangeA<br />		lea edx,angularChangeA<br />		DbgVec3 edx,&quot;angularChangeA&quot;<br />		;The result is the change in angular momentum required to produce the desired change in angular velocity<br />	.endif	<br />	; Linear change is easier - it is just the linear movement along the contact normal.<br />	mov edx,pvContactNormal<br />	__ScaleFloat3 .Vec3, linearMoveA<br />	__StowFloat3 linearChangeA		<br />	lea edx,linearChangeA<br />	DbgVec3 edx,&quot;linearChangeA&quot;<br />	; Now we can apply the values we&#039;ve calculated.<br />	OCall esi.Apply_Correction, addr linearChangeA, addr angularChangeA, pSourceA, pTargetA<br />	;------------------------------------------------------------------------------------------------------<br />	<br />	<br /><br /> 	;Now we go through almost the exact same sequence, for the Other Body<br /> 	.if pOtherBody!=0<br /><br />		fld angularMomentumB<br />		fdiv totalInertia<br />		fmul fPenetrationDepth<br />		fchs<br />		DbgFSTP angularMoveB<br /><br />		mov edx,pOtherBody<br />		fld .CollisionHull.OneOverMass<br />		fdiv totalInertia<br />		fmul fPenetrationDepth<br />		fchs<br />		DbgFSTP linearMoveB<br /><br /><br />	&nbsp; &nbsp; mov edx,pvContactNormal<br />	&nbsp; &nbsp; mov eax,pvrelativeContactPositionB<br />	&nbsp; &nbsp; DotProduct .Vec3,.Vec3<br />	&nbsp; &nbsp; DbgFSTP ftemp<br />	&nbsp; &nbsp; __ScaleFloat3 .Vec3, ftemp<br />	&nbsp; &nbsp; __AddToFloat3 projection, .Vec3<br />	&nbsp; &nbsp; <br />	&nbsp; &nbsp; ; Use the small angle approximation for the sine of the angle <br />	&nbsp; &nbsp; ; i.e. the magnitude would be sine(angularLimit) * projection.magnitude<br />	&nbsp; &nbsp; ; but we approximate sine(angularLimit) to angularLimit<br />	&nbsp; &nbsp; ; maxMagnitude = angularLimit * projection.magnitude<br />	&nbsp; &nbsp; DotProduct projection,projection<br />	&nbsp; &nbsp; fsqrt<br />	&nbsp; &nbsp; fmul angularLimit<br />	&nbsp; &nbsp; fst maxMagnitude<br />	&nbsp; &nbsp; fchs<br />	&nbsp; &nbsp; DbgFSTP ftemp<br /><br />	&nbsp; &nbsp; fMin angularMoveB, ftemp<br />	&nbsp; &nbsp; fstpReg eax<br />	&nbsp; &nbsp; .if eax==angularMoveB<br />	&nbsp; &nbsp; &nbsp; &nbsp; fld linearMoveB<br />	&nbsp; &nbsp; &nbsp; &nbsp; fadd angularMoveB<br />	&nbsp; &nbsp; &nbsp; &nbsp; DbgFSTP totalMoveB<br />	&nbsp; &nbsp; &nbsp; &nbsp; fld maxMagnitude<br />	&nbsp; &nbsp; &nbsp; &nbsp; fchs<br />	&nbsp; &nbsp; &nbsp; &nbsp; DbgFSTP angularMoveB<br />	&nbsp; &nbsp; &nbsp; &nbsp; fld totalMoveB<br />	&nbsp; &nbsp; &nbsp; &nbsp; fsub angularMoveB<br />	&nbsp; &nbsp; &nbsp; &nbsp; DbgFSTP linearMoveB<br />	&nbsp; &nbsp; .else<br />		&nbsp; &nbsp; fMax angularMoveB, maxMagnitude<br />		&nbsp; &nbsp; fstpReg eax<br />		&nbsp; &nbsp; .if eax==angularMoveB<br />				fld linearMoveB<br />				fadd angularMoveB<br />				DbgFSTP totalMoveB	&nbsp; &nbsp;  <br />			&nbsp; &nbsp; fld maxMagnitude<br />			&nbsp; &nbsp; DbgFSTP angularMoveB<br />		&nbsp; &nbsp; &nbsp; &nbsp; fld totalMoveB<br />		&nbsp; &nbsp; &nbsp; &nbsp; fsub angularMoveB<br />		&nbsp; &nbsp; &nbsp; &nbsp; DbgFSTP linearMoveB<br />		&nbsp; &nbsp; .endif<br />	 	.endif 	<br /><br />	&nbsp; &nbsp; .if (angularMoveB == 0 || angularMoveB==80000000h)&nbsp; &nbsp; &nbsp; &nbsp; <br />			fldz<br />			fst angularChangeB.x<br />			fst angularChangeB.y<br />			fstp angularChangeB.z&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />		.else&nbsp; &nbsp; &nbsp; &nbsp; <br />			mov edx,pvContactNormal<br />			mov eax,pvrelativeContactPositionB<br />			CrossProduct .Vec3, .Vec3<br />			__StowFloat3 targetAngularDirectionB<br />			mov eax,pTargetB<br />			Vec3_mult_Mat33 .configuration.InverseWorldInertiaTensor, targetAngularDirectionB<br />			fld angularMoveB<br />			fdiv angularMomentumB<br />			fmul st(3),st(0)<br />			fmul st(2),st(0)<br />			fmul<br />			__StowFloat3 angularChangeB<br />			lea edx,angularChangeB<br />			DbgVec3 edx,&quot;angularChangeB&quot;<br />		.endif<br />		mov edx,pvContactNormal<br />		__ScaleFloat3 .Vec3, linearMoveB<br />		__StowFloat3 linearChangeB<br />		OCall pOtherBody::CollisionHull.Apply_Correction, addr linearChangeB, addr angularChangeB, pSourceB, pTargetB&nbsp;  <br /><br />	.endif<br />	<br />	&nbsp; &nbsp; &nbsp; &nbsp; 	<br />	;Now we COULD move Forwards in time if we were really worried about time-syncing our bodies...<br />	;...OR we can simply live with the tiny time-glitch<br />	<br />MethodEnd<br /></code></pre><br /><br /><br />And you&#039;ll also be interested in this:<br /><pre><code><br />;Called by Resolve_Penetration<br />Method CollisionHull.Apply_Correction,uses esi, pvLinearChange, pvAngularChange, pSource, pTarget<br />LOCAL matTemp:Mat33<br />LOCAL matTemp2:Mat33<br />	SetObject esi<br />	<br />	; Apply the change in position&nbsp; &nbsp;  <br />	mov edx,pTarget<br />	mov eax,pvLinearChange<br />	__AddFloat3				.configuration.CMPosition,.Vec3<br />	__StowFloat3 			.configuration.CMPosition&nbsp; &nbsp; &nbsp; &nbsp;  	<br />	; And the change in orientation <br />	mov edx,pTarget<br />	mov eax,pvAngularChange<br />	__AddFloat3 			.configuration.AngularMomentum,.Vec3<br />	__StowFloat3 			.configuration.AngularMomentum<br />	<br />	;We&#039;ve changed the POSITION and ANGULAR MOMENTUM<br />	;We need to fix up the Linear and Angular Velocities<br /><br />	;AngVelocity from AngMomentum as seen in INTEGRATE...<br />	;Make a new Orientation matrix based on the Angular Change<br />	mov eax,pvAngularChange<br />	Mat33_star matTemp, .Vec3<br />	mov edx,pSource<br />	invoke Mat33_multiply,addr matTemp2, addr .configuration.Orientation, addr matTemp<br />	mov eax,pSource<br />	lea edx,.configuration.Orientation ;Source.Orientation<br />	mov ebx,pTarget<br />	lea ebx,.configuration.Orientation	;Target.Orientation<br />	lea ecx,matTemp2						;Offset.Orientation<br />	Mat33_Add&nbsp; ebx, ecx, edx&nbsp; <br />	mov edx,pTarget<br />	invoke OrthonormalizeOrientation,addr .configuration.Orientation	<br />	;Fix up the Inertia Tensor for the new Orientation<br />	mov edx,pTarget<br />	Mat33_SimilarityTransform .configuration.InverseWorldInertiaTensor, matTemp, .InverseBodyInertiaTensor, .configuration.Orientation<br />	; Extract new Angular Velocity from the new Tensor and Momentum<br />	; Target.AngularVelocity = Target.InverseWorldInertiaTensor * Target.AngularMomentum			<br />	mov eax,edx<br />	Vec3_mult_Mat33 .configuration.InverseWorldInertiaTensor, .configuration.AngularMomentum<br />	__StowFloat3 	.configuration.AngularVelocity<br />	<br />	mov edx,pSource<br />	;Ensure that our worldspace vertex array is up to date<br />	OCall esi.TransformVertices,addr .configuration.CMPosition, addr .configuration.Orientation<br /><br />	;Scale the LINEAR Velocity as follows:<br />	;CMVelocity and CMVelocityChange from CHANGE IN POSITION<br />	;S						 = (new target.CMPosition - old target.CMPosition) / (old target.CMPosition-src.CMPosition)<br />	;target.CMVelocity		 = target.CMVelocity * S<br />	;target.CMVelocityChange = target.CMVelocityChange * S	<br />	<br />MethodEnd<br /><br /></code></pre><br /><br />Please note that I am NOT correcting the Linear Velocity - the last few lines of code are incomplete.<br />Also, note that the &quot;angularLimit&quot; threshold is completely arbitrary - you pretty much have to experiment to find a nice value but I find that 0.2 works nicely for me.<br /><br />When you&#039;ve had a chance to look that code over, I&#039;ll post an updated version of the simulator&#039;s CheckCollisions method, which calls this new penetration-correction stuff.<br /></div>
    <div class="meta">Posted on 2008-06-16 02:21:24 by Homer</div>
   </div>
   <div class="post" id="post-205492">
    <div class="subject"><a href="#post-205492">Re: Physics - 3D Collision Detection and Response</a></div>
    <div class="body">Theres a reason why I did not bother to adjust the linear velocity.<br />And this will lead to a separate discussion of the solver, where we will see that positional correction is NOT NEEDED.<br />But I digress.<br /><br />For now, please note that when Penetration occurs, it is ALWAYS SHALLOW - its limited to the TIME EPSILON of the &quot;FindExactCollisionTime&quot; method... so when we advanced the system into the penetration state, we did so by the smallest possible margin.<br />The positional error, for which we corrected, was small.<br />The velocity correction is small too.<br />So small.<br />Important?<br />Conservation of energy.<br /><br />We corrected the position, and not the velocity.<br /><br />What if we DIDNT correct the position - and used the penetration point for collision resolution?<br />The velocity issue would disappear - and we&#039;d have a little angular error instead..<br />Would you not say that is more acceptable than wearing, or having to correct, the error in TOTAL momentum?</div>
    <div class="meta">Posted on 2008-06-16 04:59:07 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29056&amp;page=1" style="">&laquo;</a><a href="../?id=29056&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29056" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>