<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>I Need Documentation :) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=10931" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=10931">I Need Documentation :)</a></p>
   <div class="post" id="post-82413">
    <div class="subject"><a href="#post-82413">I Need Documentation :)</a></div>
    <div class="body">Hello every1 im new at Asm programming ive learn some thing all by my self but i need more help !<br />Fasm is great thing for beginers, but there is one thing i wish Fasm to have, &quot;tutorials&quot;.<br />If any1 have some samples or some documentation (about using Common Controls,opening files and reading files or similar)  about Fasm and not Mas32 or Nasm ... (cause i dont know how to convert them in Fasm) i will be happy if you send it to me!<br /><br /><br />I Usually work in Delphi, and im very Good !<br />Thnx in advance !<br />By Yall!<br />:eek:</div>
    <div class="meta">Posted on 2003-02-18 03:42:06 by Casper</div>
   </div>
   <div class="post" id="post-82427">
    <div class="subject"><a href="#post-82427">I Need Documentation :)</a></div>
    <div class="body">Casper,<br /><br />You have to check Iczelion's tutorials,there is no specific documentation about common controls,etc.. for the Fasm users.The manipulation of win32API is based on the same principles,it doesn't matter if you<br />are a Masm32 or Fasm coder.<br /><br />Regards,<br /><br />Vortex</div>
    <div class="meta">Posted on 2003-02-18 05:00:53 by Vortex</div>
   </div>
   <div class="post" id="post-82428">
    <div class="subject"><a href="#post-82428">Ok Ill Do My Best !</a></div>
    <div class="body">Thnx Vorex ! <br />I already have tutorials u mentioned  ill try to understand them !<br />Bye</div>
    <div class="meta">Posted on 2003-02-18 05:02:59 by Casper</div>
   </div>
   <div class="post" id="post-82566">
    <div class="subject"><a href="#post-82566">I Need Documentation :)</a></div>
    <div class="body">just wondering has any1 thought of converting those tutorials of izcelion's... i have started converting the pe tutorials but just the source<br />not the explanations. maybe this would help people when having fasm related code when reading those tuts...just a thought :)</div>
    <div class="meta">Posted on 2003-02-19 03:32:51 by keyoke</div>
   </div>
   <div class="post" id="post-82571">
    <div class="subject"><a href="#post-82571">Cool</a></div>
    <div class="body">Hey keyoke can u sand me ur sample from Pe tutorial, i want to learn everything :)<br /><br />Bye</div>
    <div class="meta">Posted on 2003-02-19 03:42:51 by Casper</div>
   </div>
   <div class="post" id="post-82572">
    <div class="subject"><a href="#post-82572">I Need Documentation :)</a></div>
    <div class="body">wouldn't it be better to make a general from masm to fasm tutorial instead of remaking all existing ones?</div>
    <div class="meta">Posted on 2003-02-19 03:57:17 by Hiroshimator</div>
   </div>
   <div class="post" id="post-82582">
    <div class="subject"><a href="#post-82582">I Need Documentation :)</a></div>
    <div class="body">ok casper i will upload the file later when i get home<br /><br />hiroshimator i dont know about that because sometimes it's better to see like a whole example.....sometimes i spend hours trying to use some common control but when i look in the tuts it's easy when presented in a whole example. the fasm help docs help for alot of stuff aswell so they are good.<br />i dunno do ya think its better to have a general tut...? maybe have a general one aswell well as examples like icz's tut's</div>
    <div class="meta">Posted on 2003-02-19 05:09:14 by keyoke</div>
   </div>
   <div class="post" id="post-82583">
    <div class="subject"><a href="#post-82583">Thnx Man</a></div>
    <div class="body">I Cant wait to download ur samples :)<br />I Hope Ill be able to go deeper in asm programming with ur Help !</div>
    <div class="meta">Posted on 2003-02-19 05:37:26 by Casper</div>
   </div>
   <div class="post" id="post-82601">
    <div class="subject"><a href="#post-82601">no problem</a></div>
    <div class="body">casper,<br />here is wat ive converted so far..<br /><br />PE Tutorial 2<br />PE Tutorial 5 incomplete<br /><br />Win32Asm Tutorial 2<br />Win32Asm Tutorial 3 incomplete<br /><br />the reason i'm  doing this is to practise with fasm i'm also really new to fasm. the incomplete tutorials i'm busy converting at the moment they will be ready by this weekend probably so i didnt give u the incomplete versions. hope this will help u. i dont have much spare time or they would be finished before then :( wish i could spend all my time learning asm :)<br /><br />later</div>
    <div class="meta">Posted on 2003-02-19 08:00:50 by keyoke</div>
   </div>
   <div class="post" id="post-82605">
    <div class="subject"><a href="#post-82605">Thnx :) keyoke</a></div>
    <div class="body">:)</div>
    <div class="meta">Posted on 2003-02-19 08:17:58 by Casper</div>
   </div>
   <div class="post" id="post-82607">
    <div class="subject"><a href="#post-82607">I Need Documentation :)</a></div>
    <div class="body">Some of the Iczelion's tutorials have been already converted, there are even different versions made by other people, you can find everything in this thread:<br /><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=7358">http://www.asmcommunity.net/board/index.php?topic=7358</a></div>
    <div class="meta">Posted on 2003-02-19 08:25:07 by Tomasz Grysztar</div>
   </div>
   <div class="post" id="post-82608">
    <div class="subject"><a href="#post-82608">I Need Documentation :)</a></div>
    <div class="body">I'd say starting from Iczelions tutorial 5 it really doesn't matter which assembler's code you plug in since he doesn't deal with the specific assembler anymore but exclusively with how to program for windows.<br /><br />it's only in the first 4 that he goes into things like 'invoke' and some other MASM constructs a bit.</div>
    <div class="meta">Posted on 2003-02-19 08:27:44 by Hiroshimator</div>
   </div>
   <div class="post" id="post-82731">
    <div class="subject"><a href="#post-82731">Thnx to everyone !</a></div>
    <div class="body">I would like to special thnx keyoke, privalov for support ;)<br />last night i figure out lots of things in Fasm ( opening files, write in files, creating common controls and... ). I was awake all night and I didnt know that Asm is that easy :)<br />Once Again thnx :) <br /><br />PS<br />Sorry for my bad English but my mather language is Bosnian !<br /><br />C Ya</div>
    <div class="meta">Posted on 2003-02-20 03:33:09 by Casper</div>
   </div>
   <div class="post" id="post-82742">
    <div class="subject"><a href="#post-82742">I Need Documentation :)</a></div>
    <div class="body">no problem casper<br />i have one or two changes to make to pe tut 2 ill post it again when it's more correct<br />later :)</div>
    <div class="meta">Posted on 2003-02-20 04:25:00 by keyoke</div>
   </div>
   <div class="post" id="post-82754">
    <div class="subject"><a href="#post-82754">For All Newbies (Like MySelf) :)</a></div>
    <div class="body">Tonight Ill start to write some tutorials for all those who r new at Fasm scene !<br />I know how hard it is to begin from nothing ! <br />It will contain small examples writen in Fasm for More information  contact me ...<br />I have to tell you one more thing for all newbies, never give up. If you stuck with something<br /> just come here on this forum and Ask there is lots of peepz here who will help Ya !<br /><br />Bye Yall</div>
    <div class="meta">Posted on 2003-02-20 05:29:53 by Casper</div>
   </div>
   <div class="post" id="post-82855">
    <div class="subject"><a href="#post-82855">I Need Documentation :)</a></div>
    <div class="body">Copyright 2000 Eric Isaacson. Reproduced with permission from the<br />A86/A386 assembler documentation, available at <a target="_blank" href="http://eji.com/a86">http://eji.com/a86</a> .<br />Contact Eric Isaacson if you wish to post this elsewhere.<br /><br />{edit by Rob.Rice the notes that were here have ben moved the end of the list}<br /><br /><br /><br />The 86 Instruction Set<br />Opcodes    Instruction  CPU    Description<br /><br />67 or nil     A2 (prefix)        3 Use 16-bit address (indexing) in next instruction<br />67 or nil     A4 (prefix)        3 Use 32-bit address (indexing) in next instruction<br />37            AAA                  ASCII adjust AL (carry into AH) after addition<br />D5 0A         AAD                  ASCII adjust before division (AX = 10*AH + AL)<br />D4 0A         AAM                  ASCII adjust after multiply (AL/10: AH=Quo AL=Rem)<br />3F            AAS                  ASCII adjust AL (borrow from AH) after subtraction<br />14 ib         ADC AL,ib            Add with carry immediate byte into AL<br />15 iv         ADC eAX,iv           Add with carry immediate vword into eAX<br />80 /2 ib      ADC rmb,ib           Add with carry immediate byte into regmem byte<br />10 /r         ADC rmb,rb           Add with carry byte register into regmem byte<br />83 /2 ib      ADC rmv,ib           Add with carry immediate byte into regmem vword<br />81 /2 iv      ADC rmv,iv           Add with carry immediate vword into regmem vword<br />11 /r         ADC rmv,rv           Add with carry vword register into regmem vword<br />12 /r         ADC rb,rmb           Add with carry regmem byte into byte register<br />13 /r         ADC rv,rmv           Add with carry regmem vword into vword register<br />04 ib         ADD AL,ib            Add immediate byte into AL<br />05 iv         ADD eAX,iv           Add immediate vword into eAX<br />80 /0 ib      ADD rmb,ib           Add immediate byte into regmem byte<br />00 /r         ADD rmb,rb           Add byte register into regmem byte<br />83 /0 ib      ADD rmv,ib           Add immediate byte into regmem vword<br />81 /0 iv      ADD rmv,iv           Add immediate vword into regmem vword<br />01 /r         ADD rmv,rv           Add vword register into regmem vword<br />02 /r         ADD rb,rmb           Add regmem byte into byte register<br />03 /r         ADD rv,rmv           Add regmem vword into vword register<br />0F 20         ADD4S              N Add CL nibbles BCD, DS:SI into ES:DI (CL even,NZ)<br />0F 58 /r      ADDPS ro,rmo       P3 Add four values in parallel, rmo into ro<br />F3 0F 58 /r   ADDSS ro,rmo       P3 Add bottom value of rmo into ro<br />24 ib         AND AL,ib            Logical-AND immediate byte into AL<br />25 iv         AND eAX,iv           Logical-AND immediate vword into eAX<br />80 /4 ib      AND rmb,ib           Logical-AND immediate byte into regmem byte<br />20 /r         AND rmb,rb           Logical-AND byte register into regmem byte<br />83 /4 ib      AND rmv,ib           Logical-AND immediate byte into regmem vword<br />81 /4 iv      AND rmv,iv           Logical-AND immediate vword into regmem vword<br />21 /r         AND rmv,rv           Logical-AND vword register into regmem vword<br />22 /r         AND rb,rmb           Logical-AND regmem byte into byte register<br />23 /r         AND rv,rmv           Logical-AND regmem vword into vword register<br />0F 55 /r      ANDNPS ro,rmo      P3 Logical AND rmo into the bitwise complement of ro<br />0F 54 /r      ANDPS ro,rmo       P3 Logical AND rmo into ro <br />63 /r         ARPL rmw,rw        2 Adjust RPL of regmem word not smaller than RPL of rw<br />62 /r         BOUND rv,m2v       2 INT 5 if rw not between 2 vwords at  inclusive<br />0F BC/r       BSF rvermv         3 Set rv to lowest position of NZ bit in ev<br />0F BD/r       BSR rv,rmv         3 Set rv to highest position of NZ bit in ev<br />0F C8+r       BSWAP rd           4 Swap bytes 1,4 and 2,3 of dword register<br />0F BA/4 ib    BT rv/m,ib         3 Set Carry flag to bit #ib of array at rv/m<br />0F A3/r       BT rv/m,rv         3 Set Carry flag to bit #rv of array at rv/m<br />0F BA/7 ib    BTC rv/m,ib        3 Set CF to, then compl bit ib of array at rv/m<br />0F BB/r       BTC rv/m,rv        3 Set CF to, then compl bit rv of array at rv/m<br />0F BA/6 ib    BTR rv/m,ib        3 Set CF to, then reset bit ib of array at rv/m<br />0F B3/r       BTR rv/m,rv        3 Set CF to, then reset bit rv of array at rv/m<br />0F BA/5 ib    BTS rv/m,ib        3 Set CF to, then set bit ib of array at rv/m<br />0F AB/r       BTS rv/m,rv        3 Set CF to, then set bit rv of array at rv/m<br />9A cp         CALL cp              Call far segment, immediate 4- or 6-byte address<br />E8 cv         CALL cv              Call near, offset relative to next instruction<br />FF /3         CALL mp              Call far: segment, address at regmem memory location<br />FF /2         CALL rmv             Call near, offset absolute at regmem vword<br />0F FF ib      CALL80 ib          N Call 8080-emulation code at INT number ib<br />98            CBW                  Convert byte into word (AH = top bit of AL)<br />99            CDQ                3 Convert dword to qword (EDX = top bit of EAX)<br />F8            CLC                  Clear carry flag<br />FC            CLD                  Clear direction flag so SI and DI will increment<br />FA            CLI                  Clear interrupt enable flag; interrupts disabled<br />0F 12/0       CLRBIT rmb,CL      N Clear bit CL of regmem byte<br />0F 13/0       CLRBIT rmw,CL      N Clear bit CL of regmem word<br />0F 1A/0 ib    CLRBIT rmb,ib      N Clear bit ib of regmem byte<br />0F 1B/0 ib    CLRBIT rmw,ib      N Clear bit ib of regmem word<br />0F 06         CLTS               2 Clear task switched flag<br />F5            CMC                  Complement carry flag<br />0F 4n /r      CMOVcond rv,rmv    P2 Move if condition  (see Jcond, all conds except eCXZ))<br />3C ib         CMP AL,ib            Subtract immediate byte from AL for flags only<br />3D iv         CMP eAX,iv           Subtract immediate vword from eAX for flags only<br />80 /7 ib      CMP rmb,ib           Subtract immediate byte from regmem byte for flags only<br />38 /r         CMP rmb,rb           Subtract byte register from regmem byte for flags only<br />83 /7 ib      CMP rmv,ib           Subtract immediate byte from regmem vword for flags only<br />81 /7 iv      CMP rmv,iv           Subtract immediate vword from regmem vword, flags only<br />                                                              32<br /><br />39 /r         CMP rmv,rv           Subtract vword register from regmem vword for flags only<br />3A /r         CMP rb,rmb           Subtract regmem byte from byte register for flags only<br />3B /r         CMP rv,rmv           Subtract regmem vword from vword register for flags only<br />0F 26         CMP4S              N Compare CL nibbles BCD, DS:SI - ES:DI (CL even,NZ)<br />0F C2 /r 00   CMPEQPS ro,rmo     P3 Compare 4 values ro to rmo in parallel, all-ones if equal<br />F3 0F C2/r 00 CMPEQSS ro,rmo     P3 Compare bottom value of ro to rmo, set all-ones if equal<br />0F C2 /r 02   CMPLEPS ro,rmo     P3 Compare 4 values ro to rmo in parallel, all-ones if lessequal<br />F3 0F C2/r 02 CMPLESS ro,rmo     P3 Compare bottom value ro to rmo, set all-ones if lessequal<br />0F C2 /r 01   CMPLTPS ro,rmo     P3 Compare 4 values ro to rmo in parallel, all-ones if less than<br />F3 0F C2/r 01 CMPLTSS ro,rmo     P3 Compare bottom value of ro to rmo, set all-ones if less than<br />0F C2 /r 04   CMPNEQPS ro,rmo    P3 Compare 4 values ro to rmo in parallel, all-ones if not equal<br />F3 0F C2/r 04 CMPNEQSS ro,rmo    P3 Compare bottom value of ro to rmo, set all-ones if not equal<br />0F C2 /r 06   CMPNLEPS ro,rmo    P3 Compare 4 values ro to rmo in parallel, all-ones if not LE<br />F3 0F C2/r 06 CMPNLESS ro,rmo    P3 Compare bottom value of ro to rmo, set all-ones if not LE<br />0F C2 /r 05   CMPNLTPS ro,rmo    P3 Compare 4 values ro to rmo in parallel, all-ones if not less<br />F3 0F C2/r 05 CMPNLTSS ro,rmo    P3 Compare bottom value of ro to rmo, set all-ones if not less<br />0F C2 /r 07   CMPORDPS ro,rmo    P3 Compare 4 values ro to rmo in parallel, all-ones if ordered<br />F3 0F C2/r 07 CMPORDSS ro,rmo    P3 Compare bottom value of ro to rmo, set all-ones if ordered<br />0F C2 /r ib   CMPPS ro,rmo,ib    P3 Compare 4 parallel values ro to rmo, all-ones if cond ib<br />F3 0F C2/r ib CMPSS ro,rmo,ib    P3 Compare bottom value ro to rmo, all-ones if condition ib<br />A6            CMPS mb,mb           Compare bytes  - ES:, advance SI,DI<br />A7            CMPS mv,mv           Compare vwords  - ES:, advance SI,DI<br />A6            CMPSB                Compare bytes DS: - ES:, advance SI,DI<br />A7            CMPSD              3 Compare dwords DS: - ES:, advance SI,DI<br />A7            CMPSW                Compare words DS: - ES:, advance SI,DI<br />0F C2 /r 03   CMPUNORDPS ro,rmo  P3 Compare 4 parallel values ro to rmo, all-ones if unordered<br />F3 0F C2/r 03 CMPUNORDSS ro,rmo  P3 if unordered<br />0F C7 /1      CMPX8 mq           5 If EDXEAX=mq then mq:=ECXEBX, else EAXEDX:=mq<br />0F B0 /r      CMPXCHG rmb,rb     4 If AL=eb then set eb to rb, else set AL to eb<br />0F B1 /r      CMPXCHG rmv,rv     4 If eAX=ev then set ev to rv, else set eAX to ev<br />0F 2F /r      COMISS ro,rmo      P3 Ordered compare bottom value of ro to rmo, set 86 flags<br />0F A2         CPUID              5 If EAX=1 set EDXEAX to CPU identification values<br />99            CWD                  Convert word to doubleword (DX = top bit of AX)<br />98            CWDE               3 Sign-extend word AX to doubleword EAX<br />0F 2A /r      CVTPI2PS ro,rmq    P3 Convert 4 signed integers to 4 floating-point values<br />0F 2D /r      CVTPS2PI rq,rmo    P3 Four floating-point values rounded to 4 signed integers<br />F3 0F 2A /r   CVTSI2SS ro,rmd    P3 Bottom signed integer to bottom floating-point<br />F3 0F 2D /r   CVTSS2SI rd,rmo    P3 Bottom floating-point rounded to bottom signed integer<br />0F 2C /r      CVTTPS2PI rq,rmo   P3 Four floating-point values truncated to 4 signed ints<br />F3 0F 2C /r   CVTTSS2SI rd,rmo   P3 Bottom floating-point truncated to bottom signed integer <br />2E            CS (prefix)          Use CS segment for the following memory reference<br />27            DAA                  Decimal adjust AL after addition<br />2F            DAS                  Decimal adjust AL after subtraction<br />FE /1         DEC rmb              Decrement regmem byte by 1<br />FF /1         DEC rmv              Decrement regmem vword by 1<br />48+rv         DEC rv               Decrement vword register by 1<br />F6 /6         DIV rmb              Unsigned divide AX by regmem byte (AL=Quo AH=Rem)<br />F7 /6         DIV rmv              Unsigned div eDXeAX by rm vword (eAX=Quo eDX=Rem)<br />0F 5E /r      DIVPS ro,rmo       P3 Divide four values in parallel, ro by rmo<br />F3 0F 5E /r   DIVSS ro,rmo       P3 Divide bottom values, ro by rmo<br />3E            DS (prefix)          Use DS segment for the following memory reference<br />0F 77         EMMS               M Empty MMX state<br />C8 iw 00      ENTER iw,0         1 Make stack frame, iw bytes local storage, 0 levels<br />C8 iw 01      ENTER iw,1         1 Make stack frame, iw  bytes local storage, 1 level<br />C8 iw ib      ENTER iw,ib        1 Make stack frame, iw  bytes local storage, ib levels<br />26            ES (prefix)          Use ES segment for the following memory reference<br />              F(any)               Floating point set is in Chapter 7<br />0F 0E         FEMMS              3D Faster entry/exit of MMX state<br />0F AE /1      FXRSTOR m          P3 Restore the 87 and SIMD register sets from memory<br />0F AE /0      FXSAVE m           P3 Save the 87 and SIMD register sets to memory (512 bytes)<br />F4            HLT                  Halt<br />F6 /7         IDIV rmb             Signed divide AX by regmem byte (AL=Quo AH=Rem)<br />F7 /7         IDIV rmv             Signed divide eDXeAX by rm vword (eAX=Quo eDX=Rem)<br />F6 /5         IMUL rmb             Signed multiply (AX = AL * regmem byte)<br />F7 /5         IMUL rmv             Signed multiply (eDXeAX = eAX * regmem vword)<br />0F AF /r      IMUL rv,rmv        3 Signed multiply regmem vword into vword register<br />6B /r ib      IMUL rv,ib         1 Signed multiply imm byte into vword register<br />69 /r iv      IMUL rv,iv         1 Signed multiply imm vword into vword register<br />69 /r iv      IMUL rv,rmv,iv     1 Signed multiply (rv = regmem vword * imm vword)<br />6B /r ib      IMUL rv,rmv,ib     1 Signed multiply (rv = regmem vword * imm byte)<br />E4 ib         IN AL,ib             Input byte from immediate port into AL<br />EC            IN AL,DX             Input byte from port DX into AL<br />E5 ib         IN eAX,ib            Input vword from immediate port into eAX<br />ED            IN eAX,DX            Input vword from port DX into eAX<br />FE /0         INC rmb              Increment regmem byte by 1<br />FF /0         INC rmv              Increment regmem vword by 1<br />40+rv         INC rv               Increment vword register by 1<br />6C            INS rmb,DX         1 Input byte from port DX into , advance DI<br />6D            INS rmv,DX         1 Input vword from port DX into , advance DI<br />6C            INSB               1 Input byte from port DX into ES:, advance DI<br />6D            INSD               3 Input dword from port DX into ES:, advance DI<br />6D            INSW               1 Input vword from port DX into ES:, advance DI<br />CC            INT 3                Interrupt 3 (trap to debugger)                  (far call, with flags<br />CD ib         INT ib               Interrupt numbered by immediate byte               pushed first)<br />CE            INTO                 Interrupt 4 if overflow flag is 1<br />0F 08         INVD               4 Invalidate the Data Cache without writing<br />0F 01 /7      INVLPG m           4 Invalidate the TLB Entry that points to m<br />CF            IRET                 Interrupt return (far return and pop flags)<br />CF            IRETD              3 Interrupt return (pop EIP, ECS, Eflags)<br />77 cb         JA cb                Jump short if above (CF=0 and ZF=0)     above=UNSIGNED<br />73 cb         JAE cb               Jump short if above or equal (CF=0)<br />72 cb         JB cb                Jump short if below (CF=1)         below=UNSIGNED<br />76 cb         JBE cb               Jump short if below or equal (CF=1 or ZF=1)<br />72 cb         JC cb                Jump short if carry (CF=1)<br />E3 cb         JCXZ cb              Jump short if CX register is zero<br />74 cb         JE cb                Jump short if equal (ZF=1)<br />E3 cb         JECXZ cb           3 Jump short if ECX register is zero<br />7F cb         JG cb                Jump short if greater (ZF=0 and SF=OF)     greater=SIGNED<br />7D cb         JGE cb               Jump short if greater or equal (SF=OF)<br />7C cb         JL cb                Jump short if less (SF&gt;OF)                          less=SIGNED<br />7E cb         JLE cb               Jump short if less or equal (ZF=1 or SF&gt;OF)<br />EB cb         JMP cb               Jump short (signed byte relative to next instruction)<br />EA cp         JMP cp               Jump far (4- or 6-byte immediate address)<br />E9 cv         JMP cv               Jump near (vword offset relative to next instruction)<br />0F 8n cv      Jcond LONG cv      3 Jump, if condition, to offset &gt;127 away<br />FF /4         JMP rmv              Jump near to regmem vword (absolute offset)<br />FF /5         JMP md               Jump far (4-byte address in memory doubleword)<br />76 cb         JNA cb               Jump short if not above (CF=1 or ZF=1)<br />72 cb         JNAE cb              Jump short if not above or equal (CF=1)<br />73 cb         JNB cb               Jump short if not below (CF=0)<br />77 cb         JNBE cb              Jump short if not below or equal (CF=0 and ZF=0)<br />73 cb         JNC cb               Jump short if not carry (CF=0)<br />75 cb         JNE cb               Jump short if not equal (ZF=0)<br />7E cb         JNG cb               Jump short if not greater (ZF=1 or SF&gt;OF)<br />7C cb         JNGE cb              Jump short if not greater or equal (SF&gt;OF)<br />7D cb         JNL cb               Jump short if not less (SF=OF)<br />7F cb         JNLE cb              Jump short if not less or equal (ZF=0 and SF=OF)<br />71 cb         JNO cb               Jump short if not overflow (OF=0)<br />7B cb         JNP cb               Jump short if not parity (PF=0)<br />79 cb         JNS cb               Jump short if not sign (SF=0)<br />75 cb         JNZ cb               Jump short if not zero (ZF=0)<br />70 cb         JO cb                Jump short if overflow (OF=1)<br />7A cb         JP cb                Jump short if parity (PF=1)<br />7A cb         JPE cb               Jump short if parity even (PF=1)<br />7B cb         JPO cb               Jump short if parity odd (PF=0)<br />78 cb         JS cb                Jump short if sign (SF=1)<br />74 cb         JZ cb                Jump short if zero (ZF=1)<br />9F            LAHF                 Load: AH = flags  SF ZF xx AF xx PF xx CF<br />0F 02 /r      LAR rv,rmv         2 Load: high(rw) = Access Rights byte, selector ew<br />0F AE /2      LDMXCSR md         P3 Load md into SIMD control and status register<br />C5 /r         LDS rv,mp            Load regmem pointer into DS and vword register<br />8D /r         LEA rv,m             Calculate regmem offset given by m, place in rv<br />C9            LEAVE              1 Set SP to BP, then POP BP (reverses previous ENTER)<br />C4 /r         LES rv,mp            Load regmem pointer into ES and vword register<br />0F B4 /r      LFS rv,mp          3 Load regmem pointer into FS and vword register<br />0F 01 /2      LGDT m             2 Load 6 bytes at m into Global Descriptor Table reg<br />0F B5 /r      LGS rv,mp          3 Load regmem pointer into GS and vword register<br />0F 01 /3      LIDT m             2 Load 6 bytes into Interrupt Descriptor Table reg<br />0F 00 /2      LLDT rmw           2 Load selector ew into Local Descriptor Table reg<br />0F 01 /6      LMSW rmw           2 Load regmem word into Machine Status Word<br />F0            LOCK (prefix)        Assert BUSLOCK signal for the next instruction<br />0F 33/r       LODBITS rb,rb      N Load AX with DS:SI,bit rb (incr. SI,rb), rb+1 bits<br />0F 3B/0 ib    LODBITS rb,ib      N Load AX with DS:SI,bit rb (incr. SI,rb), ib+1 bits<br />AC            LODS mb              Load byte  into AL, advance SI<br />AD            LODS mv              Load vword  into eAX, advance SI<br />AC            LODSB                Load byte  into AL, advance SI<br />AD            LODSD              3 Load dword  into EAX, advance SI<br />AD            LODSW                Load word  into AX, advance SI<br />E2 cb         LOOP cb              noflags DEC CX; jump short if CX&gt;0<br />E1 cb         LOOPE cb             noflags DEC CX; jump short if CX&gt;0 and equal (ZF=1)<br />E0 cb         LOOPNE cb            noflags DEC CX; jump short if CX&gt;0 and not equal<br />E0 cb         LOOPNZ cb            noflags DEC CX; jump short if CX&gt;0 and ZF=0<br />E1 cb         LOOPZ cb             noflags DEC CX; jump short if CX&gt;0 and zero (ZF=1)<br />0F 03 /r      LSL rv,rmv         2 Load: rv = Segment Limit, selector ev<br />0F B2 /r      LSS rv,mp          3 Load regmem pointer into SS and vword register<br />0F 00 /3      LTR rmw            2 Load regmem word into Task Register<br />0F F7 /r      MASKMOVQ rq,rq     P3 Set  to rq1, controlled by rq2 mask (8 sign bits)<br />0F 5F /r      MAXPS ro,rmo       P3 Maximum 4 parallel pairs, rmo into ro<br />F3 0F 5F /r   MAXSS ro,rmo       P3 Maximum bottom pair, rmo into ro<br />0F 5D /r      MINPS ro,rmo       P3 Minimum 4 parallel pairs, rmo into ro<br />F3 0F 5D /r   MINSS ro,rmo       P3 Minimum bottom pair, rmo into ro<br />A0 iv         MOV AL,xb            Move byte variable (offset iv) into AL<br />A1 iv         MOV eAX,xv           Move vword variable (offset iv) into eAX<br />0F 22 /4      MOV CR4,rd         5 Move rd into control register 4<br />0F 22 /n      MOV CRn,rd         3 Move rd into control register n (=0,2, or 3)<br />0F 23 /n      MOV DRn,rd         3 Move rd into debug register n (=0,1,2,3)<br />0F 23 /n      MOV DRn,rd         3 Move rd into debug register n (=6,7)<br />0F 26 /n      MOV TRn,rd         3 Move rd into test register TRn (=6,7)<br />C6 /0 ib      MOV rmb,ib           Move immediate byte into regmem byte<br />88 /r         MOV rmb,rb           Move byte register into regmem byte<br />C7 /0 iv      MOV rmv,iv           Move immediate vword into regmem vword<br />89 /r         MOV rmv,rv           Move vword register into regmem vword<br />8C /r         MOV rmw,segreg       Move segment register into regmem word<br />B0+rb ib      MOV rb,ib            Move immediate byte into byte register<br />8A /r         MOV rb,rmb           Move regmem byte into byte register<br />0F 20 /4      MOV rd,CR4         5 Move control register 4 into rd<br />0F 20 /n      MOV rd,CRn         3 Move control register n (=0,2, or 3) into rd<br />0F 21 /n      MOV rd,DRn         3 Move debug register n (=0,1,2,3) into rd<br />0F 21 /n      MOV rd,DRn         3 Move debug register n (=6,7) into rd<br />0F 24 /n      MOV rd,TRn         3 Move test register TRn (=6,7) into rd<br />B8+rw iv      MOV rv,iv            Move immediate vword into vword register<br />8B /r         MOV rv,rmv           Move regmem vword into vword register<br />8E /r         MOV segreg,mw        Move regmem word into segment register (except CS)<br />A2 iv         MOV xb,AL            Move AL into byte variable (offset iv)<br />A3 iv         MOV xv,eAX           Move eAX into vword register (offset iv)<br />0F 29 /r      MOVAPS mo,ro       P3 Move from ro into mo which must be 16-byte aligned<br />0F 28 /r      MOVAPS ro,rmo      P3 Move from 16-byte-aligned mo into ro <br />0F 7E /r      MOVD rmd,rq        M Move low half of rq to doubleword <br />0F 6E /r      MOVD rq,rmd        M Move doubleword to rq, zero-extend <br />0F 12 /r      MOVHLPS ro,ro      P3 Move the high half of ro2 to the low half of ro1<br />0F 17 /r      MOVHPS mq,ro       P3 Move the high half of ro to mq<br />0F 16 /r      MOVHPS ro,mq       P3 Move mq to the high half of ro <br />0F 16 /r      MOVLHPS ro,ro      P3 Move the low half of ro2 to the high half of ro1<br />0F 13 /r      MOVLPS mq,ro       P3 Move the low half of ro to mq<br />0F 12 /r      MOVLPS ro,mq       P3 Move mq to the low half of ro<br />0F 50 /r      MOVMSKPS rd,ro     P3 Set rd to the four sign bits of ro<br />0F 2B /r      MOVNTPS mo,ro      P3 Non-temporal move from ro into aligned mo <br />0F E7 /r      MOVNTQ mq,rq       P3 Non-temporal move from rq into aligned mq<br />0F 7F /r      MOVQ rmq,rq        M Move rq to quadword <br />0F 6F /r      MOVQ rq,rmq        M Move quadword to rq<br />A4            MOVS mb,mb           Move byte  to ES:, advance SI,DI<br />A5            MOVS mv,mv           Move vword  to ES:, advance SI,DI<br />A4            MOVSB                Move byte DS: to ES:, advance SI,DI<br />A5            MOVSD              3 Move dword DS: to ES:, advance SI,DI<br />A5            MOVSW                Move word DS: to ES:, advance SI,DI<br />F3 0F 11 /r   MOVSS mq,ro        P3 Move bottom value of ro into mq<br />F3 0F 10 /r   MOVSS ro,romq      P3 Move single-precision number into bottom value of ro<br />0F BF /r      MOVSX rd,rmw       3 Move word to dword, with sign-extend<br />0F BE /r      MOVSX rv,rmb       3 Move byte to vword, with sign-extend<br />0F 11 /r      MOVUPS mo,ro       P3 Move ro into mo which can be unaligned<br />0F 10 /r      MOVUPS ro,rmo      P3 Move rmo into ro;  mo can be unaligned<br />0F B7 /r      MOVZX rd,rmw       3 Move word to dword, with zero-extend<br />0F B6 /r      MOVZX rv,rmb       3 Move byte to vword, with zero-extend<br />8C /r         MOVZX rw,seg       3 Move segment register into regmem word<br />F6 /4         MUL rmb              Unsigned multiply (AX = AL * regmem byte)<br />F7 /4         MUL rmv              Unsigned multiply (eDXeAX = eAX * regmem vword)<br />0F 59 /r      MULPS ro,rmo       P3 Multiply four values in parallel, rmo into ro<br />F3 0F 59 /r   MULSS ro,rmo       P3 Multiply bottom values, rmo into ro<br />F6 /3         NEG rmb              Two's complement negate regmem byte<br />F7 /3         NEG rmv              Two's complement negate regmem vword<br />              NIL (prefix)         Special &quot;do-nothing&quot; opcode assembles no code<br />90            NOP                  No Operation<br />F6 /2         NOT rmb              Reverse each bit of regmem byte<br />F7 /2         NOT rmv              Reverse each bit of regmem word<br />0F 16/0       NOTBIT rmb,CL      N Complement bit CL of regmem byte<br />0F 17/0       NOTBIT rmw,CL      N Complement bit CL of regmem word<br />0F 1E/0 ib    NOTBIT rmb,ib      N Complement bit ib of regmem byte<br />0F 1F/0 ib    NOTBIT rmw,ib      N Complement bit ib of regmem word<br />66 or nil     O2 (prefix)        3 Use 16-bit data operand in the next instruction<br />66 or nil     O4 (prefix)        3 Use 32-bit data operand in the next instruction<br />0C ib         OR AL,ib             Logical-OR immediate byte into AL<br />0D iv         OR eAX,iv            Logical-OR immediate word into eAX<br />80 /1 ib      OR rmb,ib            Logical-OR immediate byte into regmem byte<br />08 /r         OR rmb,rb            Logical-OR byte register into regmem byte<br />83 /1 ib      OR rmv,ib            Logical-OR immediate byte into regmem word<br />81 /1 iv      OR rmv,iv            Logical-OR immediate word into regmem word<br />09 /r         OR rmv,rv            Logical-OR word register into regmem word<br />0A /r         OR rb,rmb            Logical-OR regmem byte into byte register<br />0B /r         OR rv,rmv            Logical-OR regmem word into word register<br />0F 56 /r      ORPS ro,rmo        P3 Logical-OR rmo into ro <br />E6 ib         OUT ib,AL            Output byte AL to immediate port number ib<br />E7 ib         OUT ib,eAX           Output word eAX to immediate port number ib<br />EE            OUT DX,AL            Output byte AL to port number DX<br />EF            OUT DX,eAX           Output word eAX to port number DX<br />6E            OUTS DX,rmb        1 Output byte  to port number DX, advance SI<br />6F            OUTS DX,rmv        1 Output word  to port number DX, advance SI<br />6E            OUTSB              1 Output byte DS: to port number DX, advance SI<br />6F            OUTSD              3 Output dword DS: to port number DX, advance SI<br />6F            OUTSW              1 Output word DS: to port number DX, advance SI<br />0F 6B /r      PACKSSDW rq,rmq    M Pack dword to word data (signed saturate)<br />0F 63 /r      PACKSSWB rq,rmq    M Pack word to byte data (signed saturate)<br />0F 67 /r      PACKUSWB rq,rmq    M Pack word to byte data (unsigned saturate)<br />0F FC /r      PADDB rq,rmq       M Packed add wrap-around<br />0F FE /r      PADDD rq,rmq       M Packed add wrap-around<br />0F EC /r      PADDSB rq,rmq      M Packed add signed saturate<br />0F ED /r      PADDSW rq,rmq      M Packed add signed saturate<br />0F DC /r      PADDUSB rq,rmq     M Packed add unsigned saturate<br />0F DD /r      PADDUSW rq,rmq     M Packed add unsigned saturate<br />0F FD /r      PADDW rq,rmq       M Packed add <br />0F DB /r      PAND rq,rmq        M Packed bitwise AND<br />0F DF /r      PANDN rq,rmq       M Packed bitwise AndNot<br />0F E0 /r      PAVGB rq,rmq       P3 Packed average unsigned bytes<br />0F 0F /r BF   PAVGUSB rq,rmq     3D Packed average unsigned bytes<br />0F E3 /r      PAVGW rq,rmq       P3 Packed average unsigned words<br />0F 74 /r      PCMPEQB rq,rmq     M Packed compare bytes for equality<br />0F 76 /r      PCMPEQD rq,rmq     M Packed compare dwords for equality<br />0F 75 /r      PCMPEQW rq,rmq     M Packed compare words for equality<br />0F 64 /r      PCMPGTB rq,rmq     M Packed compare for greater (signed bytes)<br />0F 66 /r      PCMPGTD rq,rmq     M Packed compare for greater (signed dwords)<br />0F 65 /r      PCMPGTW rq,rmq     M Packed compare for greater (signed words)<br />0F C5 /r ib   PEXTRW rd,rq,ib    P3 Extract word number ib from rq and place in rd<br />0F 0F /r 1D   PF2ID rq,rmq       3D Packed floating to 32-bit integer<br />0F 0F /r 1C   PF2IW rq,rmq       A Packed floating to 16-bit integer<br />0F 0F /r AE   PFACC rq,rmq       3D Packed floating accumulate<br />0F 0F /r 9E   PFADD rq,rmq       3D Packed floating add<br />0F 0F /r B0   PFCMPEQ rq,rmq     3D Packed floating compare equal<br />0F 0F /r 90   PFCMPGE rq,rmq     3D Packed floating compare greater equal<br />0F 0F /r A0   PFCMPGT rq,rmq     3D Packed floating compare greater<br />0F 0F /r A4   PFMAX rq,rmq       3D Packed floating maximum<br />0F 0F /r 94   PFMIN rq,rmq       3D Packed floating minimum<br />0F 0F /r B4   PFMUL rq,rmq       3D Packed floating multiply<br />0F 0F /r 8A   PFNACC rq,rmq      A Packed floating negative accumulate<br />0F 0F /r 8E   PFPNACC rq,rmq     A Packed floating mixed pos-neg accumulate<br />0F 0F /r 96   PFRCP rq,rmq       3D Packed floating reciprocal approximation<br />0F 0F /r A6   PFRCPIT1 rq,rmq    3D Packed floating reciprocal first iteration step<br />0F 0F /r B6   PFRCPIT2 rq,rmq    3D Packed floating second iteration step<br />0F 0F /r A7   PFRSQIT1 rq,rmq    3D Packed floating reciprocal sq. root first iteration<br />0F 0F /r 97   PFRSQRT rq,rmq     3D Packed floating reciprocal sq. root approximation<br />0F 0F /r 9A   PFSUB rq,rmq       3D Packed floating subtract<br />0F 0F /r AA   PFSUBR rq,rmq      3D Packed floating reverse subtract<br />0F 0F /r 0D   PI2FD rq,rmq       3D Packed 32-bit integer to floating<br />0F 0F /r 0C   PI2FW rq,rmq       A Packed 16-bit integer to floating<br />0F C4 /r ib   PINSRW rq,rmd,ib   P3 Insert bottom word of rmd into word ib of rq<br />0F F5 /r      PMADDWD rq,rmq     M Packed multiply words and add<br />0F EE /r      PMAXSW rq,rmq      P3 Packed maximum (signed words)<br />0F DE /r      PMAXUB rq,rmq      P3 Packed maximum (unsigned bytes)<br />0F EA /r      PMINSW rq,rmq      P3 Packed minimum (signed words)<br />0F DA /r      PMINUB rq,rmq      P3 Packed minimum (unsigned bytes)<br />0F D7 /r      PMOVMSKB rd,rq     P3 Set rd to the eight sign bits of rq<br />0F 0F /r B7   PMULHRW rq,rmq     3D Packed 16-bit integer multiply with round<br />0F E4 /r      PMULHUW rq,rmq     P3 Packed unsigned-multiply words, store high words<br />0F E5 /r      PMULHW rq,rmq      M Packed signed-multiply words, store high words<br />0F D5 /r      PMULLW rq,rmq      M Packed multiply words, store low words<br />1F            POP DS               Set DS to top of stack, increment SP by 2<br />07            POP ES               Set ES to top of stack, increment SP by 2<br />0F A1         POP FS             3 Set FS to top of stack, increment SP by 2<br />0F A9         POP GS             3 Set GS to top of stack, increment SP by 2<br />8F /0         POP mv               Set memory word to top of stack, increment SP by 2<br />58+rw         POP rv               Set word register to top of stack, increment SP by 2<br />17            POP SS               Set SS to top of stack, increment SP by 2<br />61            POPA               1 Pop DI,SI,BP,x ,BX,DX,CX,AX (SP value is ignored)<br />61            POPAD              3 Pop EDI,ESI,EBP,x,EBX,EDX,ECX,EAX (ESP ign.)<br />9D            POPF                 Set flags register to top of stack, increment SP by 2<br />9D            POPFD              3 Set eflags reg to top of stack, incr SP by 2<br />0F EB /r      POR rq,rmq         M Packed bitwise OR<br />0F 0D /0      PREFETCH mb        3D Prefetch 32 bytes or more into L1 cache <br />0F 18 /1      PREFETCH0 m        P3 Prefetch  memory into all cache<br />0F 18 /2      PREFETCH1 m        P3 Prefetch  memory into all cache except level 0<br />0F 18 /3      PREFETCH2 m        P3 Prefetch  memory into all cache except levels 0,1<br />0F 18 /0      PREFETCHNTA m      P3 Prefetch  memory into all cache, non-temporal<br />0F 0D /1      PREFETCHW mb       3D Prefetch 32 bytes or more into L1 cache <br />0F F6 /r      PSADBW rq,rmq      P3 Set rq to the sum of 8 unsigned absolute differences<br />0F 70 /r ib   PSHUF rq,rmq,ib    P3 Shuffle words rmq into rq using 2-bit maps in ib<br />0F 72 /6 ib   PSLLD rq,ib        M Packed shift left dwords by ib  bits<br />0F F2 /r      PSLLD rq,rmq       M Packed shift left dwords by rmq  bits<br />0F 73 /6 ib   PSLLQ rq,ib        M Packed shift left rq  by ib  bits<br />0F F3 /r      PSLLQ rq,rmq       M Packed shift left rq  by rmq  bits<br />0F 71 /6 ib   PSLLW rq,ib        M Packed shift left words by ib  bits<br />0F F1 /r      PSLLW rq,rmq       M Packed shift left words by rmq  bits<br />0F 72 /4 ib   PSRAD rq,ib        M Packed SAR dwords by ib  bits<br />0F E2 /r      PSRAD rq,rmq       M Packed SAR dwords by rmq  bits<br />0F 71 /4 ib   PSRAW rq,ib        M Packed SAR words by ib  bits<br />0F E1 /r      PSRAW rq,rmq       M Packed SAR words by rmq  bits<br />0F 72 /2 ib   PSRLD rq,ib        M Packed SHR dwords by ib  bits<br />0F D2 /r      PSRLD rq,rmq       M Packed SHR dwords by rmq  bits<br />0F 73 /2 ib   PSRLQ rq,ib        M Packed SHR rq  by ib  bits<br />0F D3 /r      PSRLQ rq,rmq       M Packed SHR rq  by rmq  bits<br />0F 71 /2 ib   PSRLW rq,ib        M Packed SHR words by ib  bits<br />0F D1 /r      PSRLW rq,rmq       M Packed SHR words by rmq  bits<br />0F F8 /r      PSUBB rq,rmq       M Packed subtract bytes, wrap-around <br />0F FA /r      PSUBD rq,rmq       M Packed subtract dwords, wrap-around <br />0F E8 /r      PSUBSB rq,rmq      M Packed subtract bytes, signed saturate<br />0F E9 /r      PSUBSW rq,rmq      M Packed subtract words, signed saturate<br />0F D8 /r      PSUBUSB rq,rmq     M Packed subtract bytes, unsigned saturate<br />0F D9 /r      PSUBUSW rq,rmq     M Packed subtract words, unsigned saturate<br />0F F9 /r      PSUBW rq,rmq       M Packed subtract words, wrap-around <br />0F 0F /r BB   PSWAPD rq,rmq      A Packed swap doubleword <br />0F 68 /r      PUNPCKHBW rq,rmq   M Unpack high data, bytes to words<br />0F 6A /r      PUNPCKHDQ rq,rmq   M Unpack high data, dwords to qwords<br />0F 69 /r      PUNPCKHWD rq,rmq   M Unpack high data, words to dwords<br />0F 60 /r      PUNPCKLBW rq,rqmd  M Unpack low data, bytes to words<br />0F 62 /r      PUNPCKLDQ rq,rqmd  M Unpack low data, dwords to qwords<br />0F 61 /r      PUNPCKLWD rq,rqmd  M Unpack low data, words to dwords<br />0F EF /r      PXOR rq,rmq        M Packed bitwise exclusive-OR<br />0E            PUSH CS              Set  to CS, then decrement SP by 2<br />1E            PUSH DS              Set  to DS, then decrement SP by 2<br />06            PUSH ES              Set  to ES, then decrement SP by 2<br />0F A0         PUSH FS            3 Set  to FS, then decrement SP by 2<br />0F A8         PUSH GS            3 Set  to GS, then decrement SP by 2<br />6A ib         PUSH ib            1 Push sign-extended immediate byte<br />68 iv         PUSH iv            1 Set  to immediate vword, then decrement SP by v<br />FF /6         PUSH mv              Set  to memory vword, then decrement SP by v<br />50+rv         PUSH rv              Set  to vword register, then decrement SP by v<br />16            PUSH SS              Set  to SS, then decrement SP by 2<br />60            PUSHA              1 Push AX,CX,DX,BX,original SP,BP,SI,DI<br />60            PUSHAD             3 Push EAX,ECX,EDX,EBX,original ESP,EBP,ESI,EDI<br />68 id         PUSHD id           3 Set  to immediate dword, then decrement SP by 4<br />9C            PUSHF                Set  to flags register, then decrement SP by 2<br />9C            PUSHFD             3 Set  to eflags reg, then decr SP by 4<br />68 iw         PUSHW iw           3 Set  to immediate word, then decrement SP by 2<br />D0 /2         RCL rmb,1            Rotate 9-bit quantity (CF, regmem byte) left once<br />D2 /2         RCL rmb,CL           Rotate 9-bit quantity (CF, regmem byte) left CL times<br />C0 /2 ib      RCL rmb,ib         1 Rotate 9-bit quantity (CF, regmem byte) left ib times<br />D1 /2         RCL rmv,1            Rotate v+1-bit quantity (CF, regmem word) left once<br />D3 /2         RCL rmv,CL           Rotate v+1-bit quantity (CF, regmem word) left CL times<br />C1 /2 ib      RCL rmv,ib         1 Rotate v+1-bit quantity (CF, regmem word) left ib times<br />0F 53 /r      RCPPS ro,rmo       P3 Set ro to four approximate reciprocals from rmo<br />F3 0F 53 /r   RCPSS ro,rmo       P3 Set ro to bottom approximate reciprocal from rmo<br />D0 /3         RCR rmb,1            Rotate 9-bit quantity (CF, regmem byte) right once<br />D2 /3         RCR rmb,CL           Rotate 9-bit quantity (CF, regmem byte) right CL times<br />C0 /3 ib      RCR rmb,ib         1 Rotate 9-bit quantity (CF, regmem byte) right ib times<br />D1 /3         RCR rmv,1            Rotate v+1-bit quantity (CF, regmem word) right once<br />D3 /3         RCR rmv,CL           Rotate v+1-bit quantity (CF, regmem word) right CL times<br />C1 /3 ib      RCR rmv,ib         1 Rotate v+1-bit quantity (CF, regmem word) right ib times<br />0F 32         RDMSR              5 Read Model Specific Reg #ECX to EDXEAX<br />0F 33         RDPMC              P2 Read Performance Monitoring Counter #ECX to EDXEAX<br />0F 31         RDTSC              5 Read Time Stamp Counter to EDXEAX<br />F3            REP (prefix)         Repeat following MOVS,LODS,STOS,INS, or OUTS CX times<br />65            REPC (prefix)      N Repeat following CMPS or SCAS CX times or until CF=0<br />F3            REPE (prefix)        Repeat following CMPS or SCAS CX times or until ZF=0<br />64            REPNC (prefix)     N Repeat following CMPS or SCAS CX times or until CF=1<br />F2            REPNE (prefix)       Repeat following CMPS or SCAS CX times or until ZF=1<br />F2            REPNZ (prefix)       Repeat following CMPS or SCAS CX times or until ZF=1<br />F3            REPZ (prefix)        Repeat following CMPS or SCAS CX times or until ZF=0<br />C3            RET                  Return to caller (near or far, depending on PROC)<br />C2 iw         RET iw               RET, then pop iw  bytes pushed before Call<br />CB            RETF                 Return to far caller (pop offset, then seg)<br />CA iw         RETF iw              RET (far), pop offset, seg, iw bytes<br />C3            RETN                 Return to near caller (pop offset only)<br />C2 iw         RETN iw              RET (near), pop offset, iw bytes pushed before Call<br />D0 /0         ROL rmb,1            Rotate 8-bit regmem byte left once<br />D2 /0         ROL rmb,CL           Rotate 8-bit regmem byte left CL times<br />C0 /0 ib      ROL rmb,ib         1 Rotate 8-bit regmem byte left ib times<br />D1 /0         ROL rmv,1            Rotate 16- or 32-bit regmem vword left once<br />D3 /0         ROL rmv,CL           Rotate 16- or 32-bit regmem vword left CL times<br />C1 /0 ib      ROL rmv,ib         1 Rotate 16 or 32-bit regmem vword left ib times<br />0F 28/0       ROL4 rmb           N Rotate nibbles: Heb=Leb   HAL,Leb=LAL  LAL=Heb<br />D0 /1         ROR rmb,1            Rotate 8-bit regmem byte right once<br />D2 /1         ROR rmb,CL           Rotate 8-bit regmem byte right CL times<br />C0 /1 ib      ROR rmb,ib         1 Rotate 8-bit regmem byte right ib times<br />D1 /1         ROR rmv,1            Rotate 16- or 32-bit regmem vword right once<br />D3 /1         ROR rmv,CL           Rotate 16- or 32-bit regmem vword right CL times<br />C1 /1 ib      ROR rmv,ib         1 Rotate 16- or 32-bit regmem vword right ib times<br />0F 2A/0       ROR4 rmb           N Rotate nibbles: Leb=Heb   Heb=LAL  AL=eb<br />0F AA         RSM                5 Resume from System Management mode<br />0F 52 /r      RSQRTPS ro,rmo     P3 Set ro to 4 approx reciprocal square roots from rmo<br />F3 0F 52 /r   RSQRTSS ro,rmo     P3 Set ro to bottom approx reciprocal square root from rmo<br />9E            SAHF                 Store AH into flags  SF ZF xx AF xx PF xx CF<br />D0 /4         SAL rmb,1            Multiply regmem byte by 2, once<br />D2 /4         SAL rmb,CL           Multiply regmem byte by 2, CL times<br />C0 /4 ib      SAL rmb,ib         1 Multiply regmem byte by 2, ib times<br />D1 /4         SAL rmv,1            Multiply regmem vword by 2, once<br />D3 /4         SAL rmv,CL           Multiply regmem vword by 2, CL times<br />C1 /4 ib      SAL rmv,ib         1 Multiply regmem vword by 2, ib times<br />D0 /7         SAR rmb,1            Signed divide regmem byte by 2, once<br />D2 /7         SAR rmb,CL           Signed divide regmem byte by 2, CL times<br />C0 /7 ib      SAR rmb,ib         1 Signed divide regmem byte by 2, ib times<br />D1 /7         SAR rmv,1            Signed divide regmem vword by 2, once<br />D3 /7         SAR rmv,CL           Signed divide regmem vword by 2, CL times<br />C1 /7 ib      SAR rmv,ib         1 Signed divide regmem vword by 2, ib times<br />1C ib         SBB AL,ib            Subtract with borrow immediate byte from AL<br />1D iv         SBB eAX,iv           Subtract with borrow immediate word from eAX<br />80 /3 ib      SBB rmb,ib           Subtract with borrow immediate byte from regmem byte<br />18 /r         SBB rmb,rb           Subtract with borrow byte register from regmem byte<br />83 /3 ib      SBB rmv,ib           Subtract with borrow immediate byte from regmem word<br />81 /3 iv      SBB rmv,iv           Subtract with borrow immediate word from regmem word<br />19 /r         SBB rmv,rv           Subtract with borrow word register from regmem word<br />1A /r         SBB rb,rmb           Subtract with borrow regmem byte from byte register<br />1B /r         SBB rv,rmv           Subtract with borrow regmem word from word register<br />AE            SCAS mb              Compare bytes AL - ES:, advance DI<br />AF            SCAS mv              Compare vwords eAX - ES:, advance DI<br />AE            SCASB                Compare bytes AL - ES:, advance DI<br />AF            SCASD              3 Compare dwords EAX - ES:, advance DI<br />AF            SCASW                Compare words AX - ES:, advance DI<br />0F 14/0       SETBIT rmb,CL      N Set bit CL of regmem byte<br />0F 15/0       SETBIT rmw,CL      N Set bit CL of regmem word<br />0F 1C/0 ib    SETBIT rmb,ib      N Set bit ib of regmem byte<br />0F 1D/0 ib    SETBITrmew,ib      N Set bit ib of regmem word<br />0F 9n /r      SETcond rmb        3 Set rm byte to 1 if condition, 0 if not (all conds except eCXZ)<br />0F AE FF      SFENCE             P3 Guarantee previous stores are visible before next stores are<br />0F 01 /0      SGDT m             2 Store 6-byte Global Descriptor Table register to m<br />D0 /4         SHL rmb,1            Multiply regmem byte by 2, once<br />D2 /4         SHL rmb,CL           Multiply regmem byte by 2, CL times<br />C0 /4 ib      SHL rmb,ib         1 Multiply regmem byte by 2, ib times<br />D1 /4         SHL rmv,1            Multiply regmem word by 2, once<br />D3 /4         SHL rmv,CL           Multiply regmem word by 2, CL times<br />C1 /4 ib      SHL rmv,ib         1 Multiply regmem word by 2, ib times<br />0F A5/r       SHLD rmv,rv,CL     3 Set ev to high of ((ev,rv) SHL CL)<br />0F A4/r ib    SHLD rmv,rv,ib     3 Set ev to high of ((ev,rv) SHL ib)<br />D0 /5         SHR rmb,1            Unsigned divide regmem byte by 2, once<br />D2 /5         SHR rmb,CL           Unsigned divide regmem byte by 2, CL times<br />C0 /5 ib      SHR rmb,ib         1 Unsigned divide regmem byte by 2, ib times<br />D1 /5         SHR rmv,1            Unsigned divide regmem word by 2, once<br />D3 /5         SHR rmv,CL           Unsigned divide regmem word by 2, CL times<br />C1 /5 ib      SHR rmv,ib         1 Unsigned divide regmem word by 2, ib times<br />0F AD/r       SHRD rmv,rv,CL     3 Set ev to low of ((rv,ev) SHR CL)<br />0F AC/r ib    SHRD rmv,rv,ib     3 Set ev to low of ((rv,ev) SHR ib)<br />0F C6 /r ib   SHUFPS ro,rmo,ib   P3 Shuffle ro to bottom 2, rmo to top 2 values of ro, map ib<br />0F 01 /1      SIDT m             2 Store 6-byte Interrupt Descriptor Table register to m<br />0F 00 /0      SLDT rmw           2 Store Local Descriptor Table register to regmem word<br />0F 01 /4      SMSW rmw           2 Store Machine Status Word to regmem word<br />0F 51 /r      SQRTPS ro,rmo      P3 Set ro to four square roots from rmo<br />F3 0F 51 /r   SQRTSS ro,rmo      P3 Set ro to bottom square root from rmo<br />36            SS                   Use SS segment for the following memory reference<br />F9            STC                  Set carry flag<br />FD            STD                  Set direction flag so SI and DI will decrement<br />FB            STI                  Set interrupt enable flag, interrupts enabled<br />0F AE /3      STMXCSR md         P3 Store SIMD control and status register to md<br />0F 31/r       STOBITS rb,rb      N Store AX to ES:DI,bit rb (incr. DI,rb), rb+1 bits<br />0F 39/0 ib    STOBITS rb,ib      N Store AX to ES:DI,bit rb (incr. DI,rb), ib+1 bits<br />AA            STOS mb              Store AL to byte , advance DI<br />AB            STOS mv              Store eAX to word , advance DI<br />AA            STOSB                Store AL to byte ES:, advance DI<br />AB            STOSD              3 Store EAX to dword ES:, advance DI<br />AB            STOSW                Store AX to word ES:, advance DI<br />0F 00 /1      STR rmw            2 Store Task Register to regmem word<br />2C ib         SUB AL,ib            Subtract immediate byte from AL<br />2D iv         SUB eAX,iv           Subtract immediate word from eAX<br />80 /5 ib      SUB rmb,ib           Subtract immediate byte from regmem byte<br />28 /r         SUB rmb,rb           Subtract byte register from regmem byte<br />83 /5 ib      SUB rmv,ib           Subtract immediate byte from regmem word<br />81 /5 iv      SUB rmv,iv           Subtract immediate word from regmem word<br />29 /r         SUB rmv,rv           Subtract word register from regmem word<br />2A /r         SUB rb,rmb           Subtract regmem byte from byte register<br />2B /r         SUB rv,rmv           Subtract regmem word from word register<br />0F 22         SUB4S              N Sub CL nibbles BCD, DS:SI - ES:DI (CL even,NZ)<br />0F 5C /r      SUBPS ro,rmo       P3 Subtract four values in parallel, rmo from ro<br />F3 0F 5C /r   SUBSS ro,rmo       P3 Subtract bottom value of rmo from ro<br />0F 34         SYSENTER           P2 Fast transition from ring 3 code to ring 0 system kernel code<br />0F 35         SYSEXIT            P2 Fast transition from ring 0 code to ring 3 application code<br />A8 ib         TEST AL,ib           AND immediate byte into AL for flags only<br />A9 iv         TEST eAX,iv          AND immediate word into eAX for flags only<br />F6 /0 ib      TEST rmb,ib          AND immediate byte into regmem byte for flags only<br />84 /r         TEST rmb,rb          AND byte register into regmem byte for flags only<br />F7 /0 iv      TEST rmv,iv          AND immediate word into regmem word for flags only<br />85 /r         TEST rmv,rv          AND word register into regmem word for flags only<br />84 /r         TEST rb,rmb          AND regmem byte into byte register for flags only<br />85 /r         TEST rv,rmv          AND regmem word into word register for flags only<br />0F 10/0       TESTBIT rmb,CL     N Test bit CL of regmem byte, set Z flag<br />0F 11/0       TESTBIT rmv,CL     N Test bit CL of regmem word, set Z flag<br />0F 18/0 ib    TESTBIT rmb,ib     N Test bit ib of regmem byte, set Z flag<br />0F 19/0 ib    TESTBIT rmw,ib     N Test bit ib of regmem word, set Z flag<br />0F 2E /r      UCOMISS ro,rmo     P3 Unordered compare bottom value of ro to rmo, set 86 flags<br />0F 15 /r      UNPCKHPS ro,rmo    P3 Set ro to high values rmo3 ro3 rmo2 ro2<br />0F 14 /r      UNPCKLPS ro,rmo    P3 Set ro to low values rmo1 ro1 rmo0 ro0<br />0F 00 /4      VERR rmw           2 Set ZF=1 if segment can be read, selector ew<br />0F 00 /5      VERW rmw           2 Set ZF=1 if segment can be written to, selector ew<br />9B            WAIT                 Wait until floating-point operation is completed<br />0F 09         WBINVD             4 Write Back and Invalidate the Data Cache<br />0F 30         WRMSR              5 Write EDXEAX to Model Specific Reg #ECX<br />0F C0 /r      XADD rmb,rb        4 Exchange eb with rb then add into new eb<br />0F C1 /r      XADD rmv,rv        4 Exchange ev with rv then add into new ev<br />9r            XCHG eAX,rv          Exchange eAX with vword register<br />86 /r         XCHG rmb,rb          Exchange byte register with regmem byte<br />87 /r         XCHG rmv,rv          Exchange vword register with regmem vword<br />86 /r         XCHG rb,rmb          Exchange regmem byte with byte register<br />9r            XCHG rv,eAX          Exchange eAX with vword register<br />87 /r         XCHG rv,rmv          Exchange regmem vword with vword register<br />D7            XLAT mb              Set AL to memory byte <br />D7            XLATB                Set AL to memory byte DS:<br />34 ib         XOR AL,ib            Exclusive-OR immediate byte into AL<br />35 iv         XOR eAX,iv           Exclusive-OR immediate word into eAX<br />80 /6 ib      XOR rmb,ib           Exclusive-OR immediate byte into regmem byte<br />30 /r         XOR rmb,rb           Exclusive-OR byte register into regmem byte<br />83 /6 ib      XOR rmv,ib           Exclusive-OR immediate byte into regmem word<br />81 /6 iv      XOR rmv,iv           Exclusive-OR immediate word into regmem word<br />31 /r         XOR rmv,rv           Exclusive-OR word register into regmem word<br />32 /r         XOR rb,rmb           Exclusive-OR regmem byte into byte register<br />33 /r         XOR rv,rmv           Exclusive-OR regmem word into word register<br />0F 57 /r      XORPS ro,rmo       P3 Exclusive-OR rmo into ro<br /><br />A digit x means that instruction works only on the x86 or later<br />processor.  Other letters and symbols indicate other<br />processor-specific instruction sets. See the note just before the<br />chart.<br />How to Read the Instruction Set Chart<br /><br />The following chart summarizes the machine instructions you can<br />program with A86.  In order to use the chart, you need to learn<br />the meanings of the specifiers (each given by 2 lower case<br />letters) that follow most of the instruction mnemonics.  Each<br />specifier indicates the type of operand (register byte, immediate<br />word, etc.) that follows the mnemonic to produce the given<br />opcodes.  The &quot;v&quot; type, for A86, is the same as &quot;w&quot; -- it denotes<br />a 16-bit word.  On A386, &quot;v&quot; denotes either a word or doubleword,<br />depending on the presence of an operand override prefix byte.<br /><br />&quot;c&quot; means the operand is a code label, pointing to a part of the<br />    program to be jumped to or called.  A86 will also accept a<br />    constant offset in this place (or a constant segment-offset<br />    pair in the case of &quot;cp&quot;).  &quot;cb&quot; is a label within about 128<br />    bytes (in either direction) of the current location.  &quot;cv&quot; is<br />    a label within the same code segment as this program; &quot;cp&quot; is<br />    a pair of constants separated by a colon -- the segment value<br />    to the left of the colon, and the offset to the right.  The<br />    offset is always a word in A86; it can be either a word or a<br />    doubleword in A386.  Note that in both the cb and cv cases,<br />    the object code generated is the offset from the location<br />    following the current instruction, not the absolute location<br />    of the label operand.  In some assemblers (most notably for<br />    the Z-80 processor) you have to code this offset explicitly<br />    by putting &quot;$-&quot; before every relative jump operand in your<br />    source code.  You do NOT need to, and should not do so with<br />    A86.<br /><br />&quot;rm&quot; means the operand is an Effective Address.  The concept of<br />    an Effective Address is central to the 86 machine<br />    architecture, and thus to 86 assembly language programming.<br />    It is described in detail at the start of this chapter.  We<br />    summarize here by saying that an Effective Address is either<br />    a general purpose register, a memory variable, or an indexed<br />    memory quantity.  For example, the instruction &quot;ADD rb,eb&quot;<br />    includes the instructions: ADD AL,BL, and ADD CH,BYTEVAR, and<br />    ADD DL,B.<br /><br />&quot;i&quot;  means the operand is an immediate constant, provided as part<br />    of the instruction itself.  &quot;ib&quot; is a byte-sized constant;<br />    &quot;iv&quot; is a constant occupying a 16-bit or 32-bit word.  The<br />    operand can also be a label, defined with a colon.  In that<br />    case, the immediate constant which is the location of the<br />    label is used.  Examples:  &quot;MOV rw,iw&quot; includes the<br />    instructions: MOV AX,17, or MOV SI,VAR_ARRAY, where<br />    &quot;VAR_ARRAY:&quot; appears somewhere in the program, defined with a<br />    colon.  NOTE that if VAR_ARRAY were defined without a colon,<br />    e.g., &quot;VAR_ARRAY DW 1,2,3&quot;, then &quot;MOV SI,VAR_ARRAY&quot; would be<br />    a &quot;MOV rw,ew&quot; NOT a &quot;MOV rw,iw&quot;.  The MOV would move the<br />    contents of memory at VAR_ARRAY (in this case 1) into SI,<br />    instead of the location of the memory. To load the location,<br />    you can code &quot;MOV SI,OFFSET VAR_ARRAY&quot;.<br /><br />&quot;m&quot; means a memory variable or an indexed memory quantity; i.e.,<br />    any Effective Address EXCEPT a register.<br /><br />&quot;r&quot; means the operand is a general purpose register.  The 8 &quot;rb&quot;<br />    registers are AL,BL,CL,DL,AH,BH,CH, or DH. The &quot;rv&quot; registers<br />    include the 16-bit registers AX,BX,CX,DX,SI,DI,SP,BP, and, in<br />    A386, also the 32-bit registers<br />    EAX,EBX,ECX,EDX,ESI,EDI,EBP,ESP.<br /><br />&quot;rv/m&quot; is used in the Bit Test instructions to denote either a<br />    word-or-doubleword register, or an array of bits in memory<br />    that can any length.<br /><br />NOTE: The following chart gives all instructions for all<br />processors through the Pentium 3.  You must take care to use only<br />the instructions appropriate for the target processor of your<br />program (the P switch will enforce this for you: see Chapter 3).<br />If an instruction form does not run on all processors, there is a<br />designator just before the description field.  &quot;N&quot; means the<br />instruction runs only on NEC processors (which are rare nowdays).<br />A digit x means the instruction runs on the x86 or later: 1 for<br />186, 2 for 286, 3 for 386, 4 for 486, 5 for Pentium.<br />Instructions with 3 or greater are recognized only by my A386<br />assembler, received only by those who purchase the extended<br />registered package. Also for A386 only are the MMX instructions<br />denoted by &quot;M&quot;, the Pentium Pro/ Pentium 2 instructions denoted<br />by &quot;P2&quot;, the Pentium 3 instructions (also known as the &quot;Streaming<br />SIMD Extensions&quot;) denoted by &quot;P3&quot;, the AMD 3Dnow instructions<br />denoted by &quot;3D&quot;, and the AMD Athlon instructions denoted by &quot;A&quot;.<br />The Athlon also supports all the Pentium 3 instructions that do<br />not involve the SIMD registers (these are mostly extensions to<br />the MMX instruction set).</div>
    <div class="meta">Posted on 2003-02-20 21:30:44 by rob.rice</div>
   </div>
  </div>
 </body>
</html>