<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>carry flag - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=28458" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=28458">carry flag</a></p>
   <div class="post" id="post-201277">
    <div class="subject"><a href="#post-201277">carry flag</a></div>
    <div class="body">i just wondered what does affect the carry flag?</div>
    <div class="meta">Posted on 2001-06-19 04:58:00 by [-alloces-]</div>
   </div>
   <div class="post" id="post-201278">
    <div class="subject"><a href="#post-201278">carry flag</a></div>
    <div class="body">Shifts, rolls, rolls through carry (rcr), shift aritmetic right, addition, subtraction, add with carry, subtract with borrow. All affect the carry flag, explanation below.

And-ing, or-ing, xor-ing, and negation all clear it, not sure if they can set it though. Mul and IMul are also stated as affecting the carry flag, but I'm not sure how (probably similar to addition).

Also a couple of obvious ones:
STC set carry        - it sets the carry flag :D
CLC clear carry      - it clears the carry flag :D
CMC complement carry - logical nots the carry flag

Shifts, and rolls (plus all their variants) treat the carry the same way: The bit that falls off the end drops into the carry part. Rolls copy this bit to the begining as well as the carry flag, and roll through carry treats it like rolling a 33bit number.

Addition and subtraction are very similar in the way they both affect the carry flag too. When you add two numbers together, the result must be the same bit length as the two operands (because you cannot add an 8bit value to a 16 or 32bit value), and mathematics tells us that adding two (N)bit numbers together can result in a number which is (N + 1)bits long (0FFh + 0FFh = 1FEh (9bits long)). This extra bit is then stored for your personal convenience in the carry bit.

I think all the bitwise operators all clear the carry flag (other than NOT which doesn't affect any flags), I'm not sure about negation, it may be similar to a subtraction/addition.

Mirno</div>
    <div class="meta">Posted on 2001-06-19 06:12:00 by Mirno</div>
   </div>
   <div class="post" id="post-201279">
    <div class="subject"><a href="#post-201279">carry flag</a></div>
    <div class="body">thanks for the detailed answer mirno!</div>
    <div class="meta">Posted on 2001-06-19 06:17:00 by [-alloces-]</div>
   </div>
   <div class="post" id="post-201280">
    <div class="subject"><a href="#post-201280">carry flag</a></div>
    <div class="body">NEG clears CF unless all the bits are 1, in which case it sets it (leaving the operand unchanged). DEC and INC leave the carry flag unchanged, but they do affect the zero and sign flags. OR, XOR, and AND always clear the carry flag. NOT affects no flags.</div>
    <div class="meta">Posted on 2001-06-22 06:36:00 by Larry Hammick</div>
   </div>
  </div>
 </body>
</html>