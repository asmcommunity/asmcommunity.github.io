<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>C2DArray and CArrayManager - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19647" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=38">Object Oriented Programming</a> &raquo; <a href="../?id=19647">C2DArray and CArrayManager</a></p>
   <div class="post" id="post-151186">
    <div class="subject"><a href="#post-151186">C2DArray and CArrayManager</a></div>
    <div class="body"><pre><code><br />;This class implements a 2D array of arbitrary-sized elements.<br />;This is accomplished by deriving from the CArrayManager class.<br />include CArrayManager.inc<br />;New array instances should be initialized via SetArraySize before being used.<br />;This can take some time if the array is large.<br />;Methods are provided for accessing array elements via their 2D coordinate.<br /><br />class C2DArray, CArrayManager, C++ compatible<br />virtual SetArraySize&#58;dwWidth,dwHeight,iElementSize<br />virtual GetPtrXY&#58;_X,_Y              ;returns ptr to Element, or NULL=out of array bounds<br />virtual SetXY&#58;_X,_Y, pElement  ;shoves pElement's content into arrayelement &#91;X,Y&#93;<br />long dwWidth<br />long dwHeight<br />endclass<br /><br />C2DArray_C2DArray proc<br />ret<br />C2DArray_C2DArray endp<br /><br />C2DArray_$C2DArray proc<br />ret<br />C2DArray_$C2DArray endp<br /><br />;This proc not only initializes the internal array size variables,<br />;it also pushes Width*Height objects of ElementSize into internal buffer.<br />C2DArray_SetArraySize proc dwWidth,dwHeight,dwElementSize<br />local pmem<br />local me<br />mov me,ecx<br />m2m &#91;ecx&#93;.C2DArray.dwWidth, dwWidth<br />m2m &#91;ecx&#93;.C2DArray.dwHeight, dwHeight<br />m2m &#91;ecx&#93;.C2DArray.dwElementSize, dwElementSize<br />mov pmem, malloc &#40;dwElementSize&#41;<br />xor ecx,ecx<br />.while ecx&lt;dwHeight<br />    push ecx<br />    xor ecx,ecx<br />    .while ecx&lt;dwWidth<br />        push ecx<br />        icall me, C2DArray, push_back, pmem<br />        pop ecx<br />        inc ecx<br />    .endw<br />    pop ecx<br />    inc ecx<br />.endw<br />free pmem<br />ret<br />C2DArray_SetArraySize endp<br /><br />C2DArray_GetPtrXY proc _X, _Y<br />mov eax, _Y<br />mul &#91;ecx&#93;.C2DArray.dwWidth;_X<br />add eax,_X<br />icall ecx, C2DArray, GetPtrToNth, eax<br />.if eax==-1         ;Failure?<br />    xor eax,eax   ;Our failure returncode<br />.endif<br />ret<br />C2DArray_GetPtrXY endp<br /><br />C2DArray_SetXY proc _X,_Y,pElement<br />icall ecx, C2DArray, GetPtrXY, _X, _Y<br />.if eax!=0<br />    xor ebx,ebx<br />    mov esi,eax<br />    mov edi,pElement<br />    .while ebx&lt;&#91;ecx&#93;.C2DArray.dwElementSize<br />        mov al,byte ptr&#91;esi&#93;<br />        mov byte ptr&#91;edi&#93;,al<br />        inc esi<br />        inc edi<br />        inc ebx<br />    .endw<br />    return TRUE<br />.endif<br />return FALSE<br />C2DArray_SetXY endp<br /></code></pre><br /><br /><pre><code><br />;Author - Homer<br />;Date - 13 July 2004<br />;Title - CArrayManager class<br />;Description - <br />;// This class manages an array of entries of arbitrary size.<br />;// By default it acts like CVector, with DWORD sized elements.<br />;// Use the SetElementSize method to set the elementsize to anything you choose.<br />;// Added a Count field which is updated internally and reflects the #entries in the array<br /><br />class CArrayManager, , C++ compatible<br />void SetElementSize&#58;dwSize ;Tell the instance of CArrayManager what size its elements are<br />void GetPtrToNth&#58;dwIndex ;Returns pointer to Nth element, or -1 = out of bounds<br />void push_back&#58;pData      ;This method will store an entire struct to the array as a single element.<br />void pop_back&#58;pReturn    ;This method will return an entire data element to your receiving struct<br />void Find                     ;&lt;-- Find element in array, return -1 or address of element in array<br />void FindIndex            ;&lt;-- Find element in array, return -1 or INDEX of element in array<br />void Delete&#58;dwIndex  ;&lt;-- Delete array element by index, array content is shifted back to fill gap<br />long pBase                 ;&lt;-- This points to the BaseAddress of the array memory<br />long dwNextPlace       ;&lt;-- This holds offset to next empty write location<br />long cbSize                 ;&lt;-- This holds the current size of the buffer in bytes<br />long dwElementSize<br />long Count<br />endclass<br /><br />CArrayManager_GetPtrToNth proc dwIndex<br />mov eax,&#91;ecx&#93;.CArrayManager.dwElementSize<br />mov ebx,&#91;ecx&#93;.CArrayManager.cbSize<br />sub ebx,eax<br />mul dwIndex<br />.if eax&gt;=ebx     ;BoundsChecking - are we trying to read beyond occupied arraymem?<br />    return -1<br />.endif                 <br />add eax,&#91;ecx&#93;.CArrayManager.pBase<br />ret<br />CArrayManager_GetPtrToNth endp<br /><br />CArrayManager_SetElementSize proc dwSize<br />m2m &#91;ecx&#93;.CArrayManager.dwElementSize, dwSize<br />ret<br />CArrayManager_SetElementSize endp<br /><br />CArrayManager_CArrayManager proc                      ;*** CONSTRUCTOR ***<br />mov eax,1024                             ;Initialize the array @ 1024 bytes &#40;256 dword entries&#41;<br />mov &#91;ecx&#93;.CArrayManager.cbSize,eax<br />mov &#91;ecx&#93;.CArrayManager.pBase, malloc &#40;eax&#41;<br />mov &#91;ecx&#93;.CArrayManager.dwElementSize,4     ;&lt;--dword sized by default<br />ret<br />CArrayManager_CArrayManager endp<br /><br />CArrayManager_$CArrayManager proc                    ;*** DESTRUCTOR ***<br />free &#91;ecx&#93;.CArrayManager.pBase              ;Release the array memory<br />ret<br />CArrayManager_$CArrayManager endp<br /><br />CArrayManager_push_back proc pData&#58;DWORD<br />mov ebx,&#91;ecx&#93;.CArrayManager.pBase              ;Calculate the address of the next empty place<br />mov eax,&#91;ecx&#93;.CArrayManager.dwNextPlace    ;in the array &#40;=pBase+dwNextPlace&#41;<br />add ebx,eax<br />pushad<br />invoke RtlMoveMemory,ebx,pData,&#91;ecx&#93;.CArrayManager.dwElementSize ;Store the data at the next place in array<br />popad<br />add eax,&#91;ecx&#93;.CArrayManager.dwElementSize<br />;mov &#91;ecx&#93;.CArrayManager.dwNextPlace,eax    ;Increment the NextPlace index<br />.if eax&gt;=&#91;ecx&#93;.CArrayManager.cbSize               ;If we are out of bounds<br />    add eax,&#91;ecx&#93;.CArrayManager.dwElementSize      ;Grow the array<br />    mov &#91;ecx&#93;.CArrayManager.cbSize,eax             ;noting the new size<br />    mov ebx,&#91;ecx&#93;.CArrayManager.pBase<br />    mov &#91;ecx&#93;.CArrayManager.pBase, remalloc &#40;&#91;ecx&#93;.CArrayManager.pBase, eax&#41;<br />.endif<br />mov eax,&#91;ecx&#93;.CArrayManager.dwElementSize<br />add &#91;ecx&#93;.CArrayManager.dwNextPlace,eax<br />inc  &#91;ecx&#93;.CArrayManager.Count<br />ret<br />CArrayManager_push_back endp<br /><br />CArrayManager_pop_back proc pReturn&#58;DWORD<br />mov eax,&#91;ecx&#93;.CArrayManager.dwElementSize<br />sub &#91;ecx&#93;.CArrayManager.dwNextPlace,eax       ;Decrement the NextPlace index<br />mov ebx,&#91;ecx&#93;.CArrayManager.pBase            ;Calculate the address of the last element<br />add ebx,&#91;ecx&#93;.CArrayManager.dwNextPlace<br />pushad<br />invoke RtlMoveMemory,pReturn, ebx, &#91;ecx&#93;.CArrayManager.dwElementSize<br />popad<br />invoke RtlZeroMemory,ebx,&#91;ecx&#93;.CArrayManager.dwElementSize<br />dec  &#91;ecx&#93;.CArrayManager.Count<br />ret  <br />CArrayManager_pop_back endp<br /><br />CArrayManager_Delete proc uses esi edi dwIndex&#58;DWORD<br />mov edi,&#91;ecx&#93;.CArrayManager.pBase <br />mov eax,dwIndex<br />mul &#91;ecx&#93;.CArrayManager.dwElementSize<br />add edi,eax<br />add eax,&#91;ecx&#93;.CArrayManager.dwElementSize<br />.while eax&lt;&#91;ecx&#93;.CArrayManager.cbSize<br />    mov ebx,&#91;ecx&#93;.CArrayManager.dwElementSize<br />    add ebx,edi<br />    pushad<br />    invoke RtlMoveMemory,edi,ebx,&#91;ecx&#93;.CArrayManager.dwElementSize<br />    popad<br />    add eax,&#91;ecx&#93;.CArrayManager.dwElementSize<br />    add edi,&#91;ecx&#93;.CArrayManager.dwElementSize<br />.endw<br />mov eax,&#91;ecx&#93;.CArrayManager.dwElementSize<br />sub &#91;ecx&#93;.CArrayManager.dwNextPlace,eax<br />dec  &#91;ecx&#93;.CArrayManager.Count<br />ret<br />CArrayManager_Delete endp<br /><br />CArrayManager_Find proc pFind&#58;DWORD<br />mov esi,pFind<br />mov ebx,&#91;ecx&#93;.CArrayManager.pBase<br />.while ebx &lt; &#91;ecx&#93;.CArrayManager.dwNextPlace<br />    push ebx<br />    mov al,byte ptr&#91;ebx&#93;<br />    .if byte ptr&#91;esi&#93;==al<br />        mov ecx,&#91;ecx&#93;.CArrayManager.dwElementSize<br />        .while al==byte ptr&#91;ebx&#93; &amp;&amp; ecx!=0<br />            mov al,byte ptr&#91;ebx&#93;<br />            inc esi<br />            inc ebx<br />            dec ecx<br />        .endw<br />        .if ecx==0<br />            pop ebx<br />            return ebx<br />        .endif<br />    .endif<br />    pop ebx<br />    add ebx,&#91;ecx&#93;.CArrayManager.dwElementSize<br />    add esi,&#91;ecx&#93;.CArrayManager.dwElementSize<br />.endw<br />return -1<br />CArrayManager_Find endp<br /><br />CArrayManager_FindIndex proc pFind&#58;DWORD<br />local dwIndex<br />mov dwIndex,0<br />mov esi,pFind<br />mov ebx,&#91;ecx&#93;.CArrayManager.pBase<br />.while ebx &lt; &#91;ecx&#93;.CArrayManager.dwNextPlace<br />    push ebx<br />    mov al,byte ptr&#91;ebx&#93;<br />    .if byte ptr&#91;esi&#93;==al<br />        mov ecx,&#91;ecx&#93;.CArrayManager.dwElementSize<br />        .while al==byte ptr&#91;ebx&#93; &amp;&amp; ecx!=0<br />            mov al,byte ptr&#91;ebx&#93;<br />            inc esi<br />            inc ebx<br />            dec ecx<br />        .endw<br />        .if ecx==0<br />            pop ebx<br />            return dwIndex<br />        .endif<br />    .endif<br />    pop ebx<br />    add ebx,&#91;ecx&#93;.CArrayManager.dwElementSize<br />    add esi,&#91;ecx&#93;.CArrayManager.dwElementSize<br />    inc dwIndex<br />.endw<br />return -1<br />CArrayManager_FindIndex endp<br /></code></pre><br /><br />Example snippet<br /><pre><code><br />set pArray as C2DArray<br />mov pArray , new &#40;C2DArray&#41;<br />pcall pArray.SetArraySize, 150, 100, 32 ;X,Y,ElementSize<br />pcall pArray.SetXY,101,0, pElement   ;simple enough?<br />.<br />.<br />.<br />delete pArray<br /></code></pre></div>
    <div class="meta">Posted on 2004-10-11 02:17:24 by Homer</div>
   </div>
   <div class="post" id="post-151233">
    <div class="subject"><a href="#post-151233">C2DArray and CArrayManager</a></div>
    <div class="body">Cool :)  . Just make Find and FindIndex preserve esi and edi. Not suited for multithreaded apps, but is perfect for single-threaded.</div>
    <div class="meta">Posted on 2004-10-12 14:10:39 by Ultrano</div>
   </div>
   <div class="post" id="post-151239">
    <div class="subject"><a href="#post-151239">C2DArray and CArrayManager</a></div>
    <div class="body">Yeah, I know it should have thread synchronisation of some kind (I used CriticalSection lock for CVector), and as soon as a project warrants it, I'll add it to appropriate baseclasses.. for now it seems ok - I just implemented a MazeGenerator using this code, worked great... speaking of which, that may be of some interest to you :)</div>
    <div class="meta">Posted on 2004-10-13 01:23:22 by Homer</div>
   </div>
   <div class="post" id="post-151243">
    <div class="subject"><a href="#post-151243">C2DArray and CArrayManager</a></div>
    <div class="body">Cool :) but I make games only for PalmOS ^^&quot;<br />Soon will be released this one:<br /><img src="http://www.ultrano.com/projects/ToxicBalls.gif" />, later - more and more games :grin:<br />I implemented macros in the GAS for ARM, but still no ATC :) My boss demands that I write most of the code in C ^^&quot;</div>
    <div class="meta">Posted on 2004-10-13 07:07:21 by Ultrano</div>
   </div>
   <div class="post" id="post-151244">
    <div class="subject"><a href="#post-151244">C2DArray and CArrayManager</a></div>
    <div class="body">Looks like fun :)</div>
    <div class="meta">Posted on 2004-10-13 09:15:08 by Homer</div>
   </div>
  </div>
 </body>
</html>