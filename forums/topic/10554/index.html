<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Opcode #7 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=10554" />
    <link rel="next" href="../?id=10554&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=10554">Opcode #7</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=10554&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=10554&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="10554" /><input type="number" name="page" min="1" max="8" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=10554&amp;page=2">&gt;</a><a href="../?id=10554&amp;page=8">&raquo;</a></form>   <div class="post" id="post-79376">
    <div class="subject"><a href="#post-79376">Opcode #7</a></div>
    <div class="body">Before starting to learn bitfields in opcode blocks,<br />and discussing what advantages and disadvantages<br />wait us in those field usage, I find it usefull to train<br />memorizing one of most used and important bit field - reg field.<br />This field is used in modr/m block, sib block and also <br />inside several 1 byte opcodes.<br />Reg bit field has 3 bits and therefor can contain <br />2^3=8 possible values reffering to 8 common use registers.<br /><br />000 = EAX<br />001 = ECX<br />010 = EDX<br />011 = EBX<br />100 = ESP<br />101 = EBP<br />110 = ESI<br />111 = EDI<br /><br />Reg fild also can mean 1 different set of registers - partial registers.<br />We discuss when it happens later, for now about second set of meaning<br />enough to say that first 4 values reffer to low partial registers in the same<br />order as they reffer to full registers:<br />000 = AL<br />001 = CL<br />010 = DL<br />011 = BL<br />and the second 4 values reffer to high part registers in the same order<br />100 = AH<br />101 = CH<br />110 = DH<br />111 = BH<br /><br />We firstly learn situation where full registers only can be used - in one byte opcode<br />with REG field.<br />In such an opcode high 5 bits are CODE bitfield<br />and low 3 bits are REG bitfield.<br /><br />I wrote a simple training application to train decoding\encoding 1 byte opcodes<br />with reg field.<br /><br />Soon later I include detail artical.<br />Hope you find the use of the app more productive then trying to memorize<br />all this bitfields by simple looking at some documentation text<br />Let me know if you want source.</div>
    <div class="meta">Posted on 2003-01-31 19:45:21 by The Svin</div>
   </div>
   <div class="post" id="post-79463">
    <div class="subject"><a href="#post-79463">Opcode #7</a></div>
    <div class="body">Before, in opcode articals, it was enough to use OllyDbg<br />to practice with discussed opcode issues.<br />I was planning to go to most important issue regarding<br />opcode - addressing.<br />But that issue involves understanding bit fields size of<br />wich in bits not multiple by 4.<br />Format of two most important blocks: byte moder/m and byte sib<br />has bit fields that are not multiple by four, and that means<br />that you can in your brain associate some bitfield with<br />one or more hex digits.<br />Their format in bits is 2:3:3.<br />That means that 2 highest bits in byte means one thing, next 3<br />other thing, and next 3 the third.<br />But when you see it in hex you see two hex figures.<br />Each of the figures constructed from bits of two close bitfields.<br />Each figure in hex associated with nibble - 4 bits.<br />So fields 2:3:3 in hex include 2 bits from first field and two bits<br />from second field in the high nibble and last bit from second field<br />with all 3 bits of third field in low nibble.<br />for example value in byte moder/m that says that both operands<br />are register and the registers are edx edi<br />in hex is F9 (for example mov edi,ecx is 8B F9, <br />sub edi,ecx is 2B F9, pay attention to the second byte of<br />both opcodes - it's the same and it's modr/m byte)<br />in bits separated in nibbles is 1111 1001<br />and actualy in bit field format is 11 111 001<br />were 11 - mod (11 value in mode means both operand are registers)<br />     111- reg (111 stands for edi in reg field)<br />     001- reg or mem indirect reg pointer(001 stands for ecx in reg field)<br />more to say that the same meaning of modr/m(both operands are registers<br />and the registers are edx edi) could be coded as 11 001 111<br />in nimbles 1100 1111 in hex CF wich make it all more complicated to understand.<br />Well, I hope I've said enough to spook you out of reading and you probably<br />decide that all this mumbo-jumbo not for you.<br /><br />For the rest who are still reading I continue :)<br />A few words of importance to be able construct and extract bit<br />fields, and importance of understanding addressing in opcode can't<br />list even 1% of advantages you can get in coding knowing it.<br />But I try.<br />To construct ANY address (in byte modr/m and byte sib) all you need to<br />know is meaning:<br />1. 8 possible values in reg field<br />2. 4 possible values in mod field in byte modm/r<br />3. 4 possible values in S field in bytes sib.<br />Then you need to know a few simple general rules, and few exeptions.<br />Of course if you working with HEX you also need fluently extract \ construct<br />bit fields from/in HEX. We'll eventualy learn it step by step, as additinal<br />bonus it'll give us ability to train something of position systems and<br />arithmetics wich is extrimly usefull for those who create and optimize <br />algorithms in low level.<br />Would you try memorize it in HEX you need 2^10 values :)<br />(256 for modrm + 3 * 256 in )<br /><br />Now about importance of knowing addressing construction in opcode,<br />after we are finished you'll be able determing size of any opcode<br />in a fly when typing mnemonics. Addreesing part in opcode is most size<br />consuming, we always deal with operands and that means we always deal<br />with specifying operand in other words - their addressing (including<br />registers). Exeption is mnemonics where operands predefined:<br />for example chain opcodes, that also explain why those opcode are<br />short - they don't have address part.<br /><br />Without knowing opcode addressing part, it's practically useless to<br />figure out (looking at just mnemonicd) wich code is shorter or what is<br />size of opcode.<br />Example for those who don't know address coding.<br />Look at two different codes that do the same:<br />1. mov edx,<br /><br />2. xor eax,eax<br />   mov edx,<br /><br />Looking at mnemonics it seem that the second code has more lines,<br />and even last line alone has more blocks, characters, etc. and therefor<br />seems to reffer to longer opcode.<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />It's an illusion :)<br />The second version opcodes is 2 bytes shorter then the first:<br /><br />8B 14 8D 00 00 00 00  MOV EDX,<br /><br />33 C0            XOR EAX,EAX<br />8B 14 88         MOV EDX,<br /><br />I don't think that Privalov or betov or any of those who know specifics<br />of opcode address part would hesitate a second about right answer.<br />All of us who don't know right answer about what size addressing part<br />takes and want to know it in the future, will be able to do it in short<br />while after some not very hard work.<br /><br />About encoding bit fields: though it is not so easy in hex with formats<br />5:3 or 2:3:3, it is easy while coding in asm source in bynary.<br />For example code field in &quot;inc reg&quot; instruction is 01000 and then<br />3 bit field of reg.<br />so eax=000 then inc eax is 01000 000.<br />The only problem here is that assembler does not accept if we write<br />space between two bit fields, it needs us to write 01000000b and<br />such a way leads to look that again is hard to see fields in.<br />We can write a simple macro that could help us easily write bit field with separator.<br />We give our macro name bcr wich states for &quot;a Byte opcode with Code and Reg <br />fields&quot;<br />bcr macro _code,_reg<br />db _code&amp;_reg_&amp;b<br />endm<br />now we can write instead of db 01000000b<br />	bcr 01000,000 ;inc eax<br />	bcr 01000,001 ;inc ecx and so on...<br /><br />	bcr 10010,000 ;xchg eax,eax or nop<br />	bcr 10010,001 ;xchg eax,ecx<br />        ....<br />	bcr 10010,111 ;xchg eax,edi<br /><br />the same way we can do very simple macros that would help us<br />code modr/m and sib bytes wich have bit fields format 2:3:3<br />modrm macro _mod,_regcode,_rm<br />db _mod&amp;_regcode_rm&amp;b<br />endm<br />and 'cause byte sib has the same format we can just define<br />bsib equ modrm<br />now can code seeing easily all filds value:<br />	modrm 11,000,101<br /><br />for example code for mov reg1,reg2 is 8Bh and after it is following<br />byte modr/m where in mod field 11.<br />examples:<br />	db 8bh<br />	modrm 11,000,001 ; mov eax,ecx (eax=000,ecx=001)<br />	db 8bh<br />	modrm 11,111,001 ; mov edi,ecx (edi=111)<br />	db 8bh<br />	modrm 11,001,111 ; mov ecx,edi<br />I gave examples just to show that there is no problem to code<br />bitfields in bynary. <br />In details we discuss byte modr/m later.<br /><br />For now enough with bitfields importance propoganda :)<br /><br />Let's actually start studing meaning of those fields.<br /><br />We start studying from REG field using it in 1 byte opcodes<br />that have format 5:3 (5 upper bits for code field and 3 low bits <br />for register field)<br />We'll do it for several reason.<br />1. Why start with REG field?<br />Reg field is most used field in addressing, getting used to<br />values in it makes a lot easier going further with opcodes addressing<br />parts. Reg field can be used in 2 fields of byte modr/m and 2 fields<br />of byte sib. Bytes modr/m and sib are used for specifying address in<br />overwelming majority of opcodes. They altogether have 6 fields and<br />in 4 of them is place for reg field values.<br />2. Why start with 1 byte opcodes of CODE:REG 5:3 format.<br />First of all it is the simplest format that uses bit field that is not<br />multiple by 4.<br />So we start getting used to such a format in both binary and hex and<br />we start with easyest of them, so after we got used to it we can easier<br />proceed with 2:3:3 format.<br />In addition to it in 5:3 format there is only one operand wich is also<br />makes decoding\encoding easier.<br /><br />Start training programm regfield.exe.<br />It has 3 tabs.<br />First tab called reference and serve you to generate 1 byte opcodes<br />in two formats: bynary(where bits separated in two bit fields: code (5 upper <br />bits) and reg(3 lower bits)), and hex with 2 hex digits.<br />You can see current opcode on your right.<br /><br />You can see buttons that are for choosing instructions and operands.<br />I explain something that could serve you as additional hints when you go<br />to testing(decoding\encoding) parts.<br /><br />Those buttons set in order of growing code values of instructions they are <br />reffering to.<br />Look at first column - instruction column.<br />Click buttons of this column from up to down looking and code bit field.<br />As you can see they reffer to CODES:<br />INC - 01000<br />DEC - 01001<br />PUSH- 01010<br />POP - 01011<br />-----------<br />XCHG -10010<br /><br />first for start from 01000 and go in step 1 increasing order<br />from 01000 to 1011<br />The last button(xchg) code though has a &quot;gap&quot; between next to it upper<br />button(pop) and is not 01100 but 10010. You may memorize it as exeption.<br />As to the code xchg itself in my time I memorized it taking note<br />that upper four bits are mirrowing bits(1001) and of course in hex<br />it's very easy to remember that it makes first digit 9.<br />(as the biggest decimal digit or as first digit in opcode &quot;nop&quot;<br /> wich is originaly is opcode for xchg eax,eax = nop)<br /><br />the same about reg operand buttons -<br />they placed in growing codes order<br />the first column from 000 to 011 codes<br />second column from 100 to 111 codes<br /><br />Play with it and pay attention how value of last bit in code field affect<br />second hex digit - if it's 0 the last hex digit = reg field value,<br />if it's 1 = the last hex digit = reg field value + 8. 'Cause last<br />bit in code value is bit 3 in low nimble of byte and bit 3 = 2^3 = 8<br /><br />...to be continued.</div>
    <div class="meta">Posted on 2003-02-01 14:24:28 by The Svin</div>
   </div>
   <div class="post" id="post-79472">
    <div class="subject"><a href="#post-79472">Opcode #7</a></div>
    <div class="body">Can you create some slogan to memorize growing order<br />of registers?<br />First try on aicent Athlantida language:<br />A(ei) C(see) D(dee) B(bee) SuP BuP SI DIe<br />(eAx,eCx,eDx,eBx,eSP,eBP,eSI,eDI)<br />:)<br />which in free translation means:<br />Hei, Look! a Bee felt dead in your soup!<br /><br />Can you offer something better?</div>
    <div class="meta">Posted on 2003-02-01 15:37:06 by The Svin</div>
   </div>
   <div class="post" id="post-79598">
    <div class="subject"><a href="#post-79598">Opcode #7</a></div>
    <div class="body">I made changes to the app.<br />Now it displays test results.</div>
    <div class="meta">Posted on 2003-02-02 13:30:43 by The Svin</div>
   </div>
   <div class="post" id="post-79643">
    <div class="subject"><a href="#post-79643">Opcode #7</a></div>
    <div class="body">A few more words about the testing programm.<br />The first tab is kinda a small and premetive assembler,<br />wich knows only five instructions, and use of<br />them with only full general purpose registers, but it doesn't<br />encode machine code from source text - it encodes it from the buttons pressed.<br />The other two tabs aske you to be:<br />- Disassembler (tab &quot;tell mnemonic&quot;)<br />- Assembler (tab &quot;tell opcode&quot;)<br /><br />In tab &quot;tell mnemonic&quot; dialog you can see the same interface as in &quot;reference&quot; tab: buttons with instructions and registers on your left and opcode in bynary <br />(where bynary byte groupped not 4:4 but 5:3 giving<br />you more hints of how to understand it)<br />and HEX.<br />After buttons from both groups (instructions and registers)<br />are pressed, programm checks if you correctly disassemle(decode)<br />opcode and if you are right - it writes &quot;correct&quot; msg and generates a new<br />opcode for you to decode, if you are wrong - it informs you of<br />it, depresses buttons and waits for your new try.<br /><br />Little hints to say:<br />if the first hex digit 4 - it's inc or dec reg<br />if the first hex digit 5 - it's push or pop reg<br />if 9 - it's xchg eax,reg<br />which one of 2 possible opcode it is, seen whether the second hex digit &gt;=8.<br />If you still have  problems with binary to hex convertion in a fly<br />there is thread &quot;test yourself for fast hex2bin convertion&quot;<br />where are several training programms for hex to bin and dec to bin<br />convertions, along with some explonation of &quot;mind alogoriths&quot;.<br /><br />The last tab &quot;Tell opcode&quot; asks you to encode (or assemble) mnemonics.<br />It asks you to encode mnemonics both in bynary and hex.<br />It's important for us to do it in both systems, we need to<br />learn to &quot;see&quot; bit fields in hex opcode.<br />To encode in bits press buttons, in hex - write 2 hex digits in low black<br />edit window. You can press test button after that or<br />space while in hex edit window.<br /><br />The least meaning of it is to memorize those opcodes, though, I think, it's<br />usefull to memorize that those extrimly used opcodes are 1 byte, main<br />purpose it fuenlty work with reg field, this field as you will see<br />used in addressing and some value in some combination might mean something<br />else than register, knowing well wich value to wich register reffer<br />will help without additinal work to know what size of opcode you get<br />in some addressing version with some particular registers.<br />This will help you not only while you coding in hex but first of all in<br />coding in asm mnemonics when you chose one or another register.<br /><br />Decode\encode - untill you have at least 100 right answers (in last<br />version you can see your results). In couple days you wouldn't ever forget<br />bit values for the register nor opcode and size for instructions used<br />in the training programms.<br /><br />IMHO though, you may say that you learn it well<br />if you can get 100 right results without any wrong in no more than 5 minutes<br />time.</div>
    <div class="meta">Posted on 2003-02-02 18:41:43 by The Svin</div>
   </div>
   <div class="post" id="post-79650">
    <div class="subject"><a href="#post-79650">Opcode #7</a></div>
    <div class="body">inc dec push pop xchg eax,reg<br />are the only 1 byte opcodes that use arbittrary reg operand.<br />But it is not the only opcodes that use the only one reg operand.<br />For example mnemonic bswap reg reffer to 2 bytes opcode:<br />00001111:11001reg<br />first byte 00001111(0Fh) has the only purpose to<br />tell processor that the following opcode is from &quot;new&quot;<br />instruction set. Remember this byte, you can it in other<br />opcode as the sign.<br />Actuall &quot;usefull&quot; part for processor here is also 1 byte<br />in format 5:3. Where last part is known for you reg field.<br />So<br />  bswap eax = 0FC8  (11001 000)<br />  bswap ecx = 0FC9  (11001 001)<br />  ....<br />  bswap edi = 0FCF  (11001 111)<br /><br />You can also use your ability to decode\encode reg field<br />on opcode last bit field in opcodes that uses actually modr/m<br />but have just one reg operand.<br />Example for it MUL REG, IMUL REG.<br />But first let's make clear about 16 bit registers.<br />I'm almost sure that all of your remember havilly discussed<br />prefix 66h.<br />All opcodes that reffer to 16 bit registers absolutly<br />the same as opcodes that reffer to extended registers<br />exept that in 32bit mode they have prefix 66h leadig opcode.<br />So <br />INC EAX = 40h  INC AX = 66h 40h<br />DEC ECX = 49h  DEC CX = 66h 49h<br />...<br />BSWAP EDI = 0F CF   BSWAP DI = 66 0F CF</div>
    <div class="meta">Posted on 2003-02-02 19:30:08 by The Svin</div>
   </div>
   <div class="post" id="post-79657">
    <div class="subject"><a href="#post-79657">Opcode #7</a></div>
    <div class="body">Let's discuss partial registers.<br />We take for example MUL,IMUL instructions, their<br />formats are:<br />MUL 	1111011w:11 100 reg<br />IMUL	1111011w:11 101 reg<br />First of all we can see that 1st bytes of both <br />instructions are identical.<br />And we can see symbol &quot;w&quot; on the least significant<br />bit place. Depending on its value in hex first byte<br />will look as F7 (w=1) or F6 (w=0).<br />Discussing partial registers set we are most interested<br />on this particular bit.<br />If w = 1 it says processor that value in reg field<br />need to be decoded as full register<br />if w = 0 - reg field means partial register.<br /><pre><code><br />w = 1               w = 0<br />reg     value       reg<br />EAX      000        AL<br />ECX      001        CL<br />EDX      010        DL<br />EBX      011        BL<br /><br />ESP      100        AH<br />EBP      101        CH<br />ESI      110        DH<br />EDI      111        BH<br /></code></pre><br />We have 8 general purpose registers but only 4 of them<br />have 2 partial registers each, it gives purfect opportunity<br />to code 8=2*4 both partial and full registers with the same<br />3 bit values and destinguish wich set is used by value of w bit.<br />You might ask yet we use additinal bit why they didn't give<br />partial and full registers different values using 4 bits -<br />in the case they  would have had 16 different values - enough<br />to encode all 16 registers both partial and full.<br />It's good question - the answer is that value of bit w affect<br />only register meaning as register operand and doesn't affect<br />if register as pointer, and pointer can be only full register.<br />Now in addressing like reg,<br />all for reg fields are used and there is the only one operand<br />that can be partial register. Where register used as register<br />or as indirect pointer, code specifying register is the same<br />there are fields like mode which specify wether register in<br />reg field is pointer or register.<br /> In current encoding system all this 4 fields takes 3*4=12 bit<br />and can be included in two bytes  along with<br />fields scale and mod in them. Would they give 4 bits for reg<br />field the only reg fields had taken 16 bits and for scale<br />and mod they would need to find additinal space increasing<br />size of every instruction.</div>
    <div class="meta">Posted on 2003-02-02 20:39:54 by The Svin</div>
   </div>
   <div class="post" id="post-79764">
    <div class="subject"><a href="#post-79764">Opcode #7</a></div>
    <div class="body">Nice little app, I like it. It's fun and educational (in conjucntion with your &quot;opcode threads&quot; :)).<br />I'll read the entire thread in more detail as soon as my head stoops acing, which I hope is soon.</div>
    <div class="meta">Posted on 2003-02-03 12:09:13 by scientica</div>
   </div>
   <div class="post" id="post-79771">
    <div class="subject"><a href="#post-79771">Opcode #7</a></div>
    <div class="body">Thank you,scientica.<br /><br />I continue.<br /><br />Now you may understand how assembler encode opcode looking<br />at statments in our source like:<br /><br /> byte ptr ...<br /> word ptr ...<br /> dword ptr ...<br /><br />In most cases(with 32 bit default size) if:<br /> dword ptr   - assembler sets bit w in opcode to 1<br /> word ptr    - also sets bit w to 1 and add prefix 66h before opcode<br /> byte ptr    - sets bit w to 0<br /><br />(Again take notion of opcode size using 16 bits operands - it always<br /> leads to additinal 66h prefix byte)<br /><br />Back to MUL/IMUL reg opcode:<br /><pre><code><br />MUL 	1111011w&#58;11 100 reg<br />IMUL	1111011w&#58;11 101 reg<br /></code></pre><br />Bytes here separated by column.<br />The only difference you can see in second byte and only<br />in the middle 3 bits field of it.<br />A little introductory about &quot;nature&quot; of this byte.<br />The second byte is so called in documentation syntax byte &quot;modr/m&quot;.<br />It has 3 bit fields in format 2:3:3 bits.<br /><pre><code><br />bits 7,6  &#58;mod<br />bits 5,4,3&#58;code or reg<br />bits 2,1,0&#58;mem or reg<br /></code></pre><br />Before further discussion insert several instructions<br />in OllyDbg of any of following formats:<br /><pre><code><br />	mov reg,reg<br />	sub reg,reg<br />	add reg,reg<br />	and reg,reg<br /></code></pre><br />It all be 2 bytes opcodes and the byte (byte[1]) of<br />any those opcodes is byte modr/m<br />For better illustration insert several different instructions<br />but with the same reg operands.<br />For example:<br /><pre><code><br />	mov ecx,edi<br />	add ecx,edi<br />	sub ecx,edi<br />       ....<br /></code></pre><br />You probably can see the same 2nd byte in opcode of all this<br />instructions (I've said probably, 'cause it's possible to<br />encode instructions of such a format in two ways - soon<br />you'll understand why)<br /><br />take second byte of any of these opcodes and convert it to bynary<br />format.<br />Now separate 8 bits in parts 2:3:3 (** *** ***)<br />In two last 3bits fields you can see codes for used in your<br />mnemonics registers.<br />for example in case of mov ecx,edi<br />8BCF           MOV ECX,EDI<br />the second byte CF in HEX, in bynary 1100 1111 separated in 2:3:3<br />11 001(ecx) 111(edi)<br /><br />In this example second field (code or reg) is used to specify reg.<br />But not always, with some codes it used as extentinal bit of code <br />bit field.<br />As it is in MUL/iMUL reg opcodes.<br /><pre><code><br /><br />MUL 	1111011w&#58;11 &#91;100&#93; reg<br />IMUL	1111011w&#58;11 &#91;101&#93; reg<br /></code></pre><br />Along with 1111011w 100 extention means MUL, 101 - IMUL.<br />Remeber that all my words would mean almost nothing to<br />you without practice:<br />Code in OllyDbg in hex several instructions of MUL/IMUL,reg<br />format.<br />Using as the first byte F7(bit w = 1) leads to treating reg field<br />as one from full registers set,F6(w=0) - from partial registers set.<br />Using values in second byte (E*) in last hex digit &lt; 8 means<br />that last bit in code/reg field will be 0 and field itself = 100<br />that will create MUL instruction and last hex digit will be = regfield value.<br />using values &gt;= 8 sets last bit in code/reg fild to 1 (101 in code/reg field)<br />and that will created iMUL instruction and value of last hex digit will be<br />value of regfield + 8.<br />Don't be afraid - it's difficalt to discribe by words but easy to see<br />in debugger, if you get dioriented - read this again, and try practice back<br />to OllyDbg.<br /><br />After you feel comfortable with encoding MUL/iMUL,reg - try simular <br />instructions DIV/iDIV reg.<br />Their formats are:<br /><pre><code><br />DIV  1111011w&#58;11 110 reg<br />iDIV 1111011w&#58;11 111 reg<br /></code></pre><br /><br />If you are carefull low level coder you've noted that they not only<br />almost identical to each other but aslo almost identical to MUL/iMUL.<br />It's thrue indeed.<br />Difference between the four opcodes formats only in cod\reg field.<br />This field specifys wich one of the four (MUL,iMUL,DIV,iDIV) operations<br />is used.<br /><pre><code><br />code/r    instruction<br />100	   MUL<br />101	  iMUL<br />110	   DIV<br />111	  iDIV<br /></code></pre><br />It reffers not only to MUL,iMUL,DIV,iDIV reg  <br />But also to MUL,iMUL,DIV,iDIV <br />Insert in OllyDbg:<br /><pre><code><br />	MUL EBX<br /> 	iMUL EBX<br />	DIV EBX<br />	iDIV EBX<br />	MUL &#91;EBX&#93;<br />	iMUL &#91;EBX&#93;<br />	DIV &#91;EBX&#93;<br />	iDIV &#91;EBX&#93;<br /></code></pre><br />Take the second byte of each opcode.<br />Convert it to bynary, separate bynary digits in format 2:3:3 (** *** ***)<br />and compare difference.<br />For example in such a format:<br /><pre><code><br />Second byte	instruction<br />11 100 011	MUL EBX<br />11 101 011	iMUL EBX<br />... and so on.<br /></code></pre><br />Do it by your own hands.<br />It is much usefull than staring at my text ;)<br />Much better if you can write training program that formalize<br />this system with MUL,iMUL,DIV,iDIV.<br />Simular to what you could see in this thread, with refference<br />in first tab and training to decode\encode in 2 other tabs.<br />Might be it'd be fun for you and become first step in writing<br />your own assembler\debugger.<br />I wish you luck.</div>
    <div class="meta">Posted on 2003-02-03 13:13:38 by The Svin</div>
   </div>
   <div class="post" id="post-79908">
    <div class="subject"><a href="#post-79908">Opcode #7</a></div>
    <div class="body">I took my self the liberty (I hope you don't mind Svin) of translating the macros to fasm syntax (I took me a while, since I RTFM, but now I've learned yet anothering to day :))<br />The macros are used just as the orignal ones.<br /><pre><code>macro bcr _code, _reg<br />&#123;<br /> db _code#_reg#b<br />&#125;<br /><br />macro modrm _mode, _reg, _rm<br />&#123;<br /> db _mode#_reg#_rm#b<br />&#125;<br /><br />macro bsib _scale, _index, _base<br />&#123;<br /> db _scale#_index#_base#b<br />&#125;</code></pre></div>
    <div class="meta">Posted on 2003-02-04 11:49:09 by scientica</div>
   </div>
   <div class="post" id="post-79959">
    <div class="subject"><a href="#post-79959">Opcode #7</a></div>
    <div class="body"><div class="quote">I hope you don't mind Svin</div> <br />Of course, I don't :)<br /><br />Fist of all for the future exersizes I'd recommend<br />use Hiew. You may of course use OllyDbg or any<br />other tool that has assembler\disassembler, but many<br />things involving hex coding with ability in a fly<br />to see &quot;mnemonics results&quot; is more comfortable to do<br />it hex editor such as &quot;Hiew&quot;.<br />For those who read &quot;Opcode&quot; articals from the begining<br />and have premade &quot;testopcode&quot; app with nopes.<br />If you hardly working on opcode studing and often<br />need opcode test\reference, maybe you consider next<br />steps.<br />make cmd of bat with single line<br />\hiew.exe \testopcode.exe<br />Then make in some hidden place of you start button menu<br />link to the bat and assing short key for example ctrl+shift+h.<br />So any time when you have doubts about opcode and want make<br />so test to check them you could bring hiew with loaded nops app<br />by one keystrike.<br />Hiew has three mode to display contents of loaded file:<br />ASCII\HEX\ASSEMBLY<br />You can switch between them pressing Enter.<br />If loaded PE file into Hiew press F8 and then F5 to get to<br />programm entry point.<br />So usual combination after Hiew is loaded with PE file:<br />dbl Enter, F8, F5.<br />To start entering opcode press F3.<br />If you want to save what you entered into file - press F9,<br />if not dbl Esc. If you just what remove changes but yet want<br />to continue editing - press Esc just once.<br />Editing in Asm mode you can see both HEX and MNEMONICs just<br />in time when you typing. In instead of HEX bytes you want to<br />enter asm mneminics - press tab while in editing mode it<br />brings you window where you can insert menemonics.<br />Next subject to discuss will be detailed explonation of<br />addressing in opcode relaited to bytes  and .</div>
    <div class="meta">Posted on 2003-02-04 17:33:04 by The Svin</div>
   </div>
   <div class="post" id="post-80022">
    <div class="subject"><a href="#post-80022">Opcode #7</a></div>
    <div class="body">the RTA assembler is nice too <br /><br />-&gt; <a target="_blank" href="http://www.anticrack.de/modules.php?op=modload&amp;name=Downloads&amp;file=index&amp;req=getit&amp;lid=3834">http://www.anticrack.de/modules.php?op=modload&amp;name=Downloads&amp;file=index&amp;req=getit&amp;lid=3834</a><br /><br />using Hiew is cool, but for those who have 2k/xp it isn't =) since the fullscreen dos is pretty small</div>
    <div class="meta">Posted on 2003-02-05 07:34:38 by wizzra</div>
   </div>
   <div class="post" id="post-80097">
    <div class="subject"><a href="#post-80097">Opcode #7</a></div>
    <div class="body">Introduction to modr/m and sib blocks.<br /><br />I hope you used training programm and now<br />remember well all values for registers for<br />both sets (full and partials), and also remember<br />how to code 16 bit registers in 32bit code where<br />default size of operand = 32.<br />If not - you'd better stop reading this and read previous<br />posts along with training yourself with those values.<br />In code format in bits 2:3:3 it becomes more complicated<br />to encode reg fields not having their values in mind.<br /><br />Don't warry if reading introduction you would have<br />questions - every mentioned point of it we will discuss<br />below with examples and exersizes untill full understanding.<br /><br />Bytes  and  are used to specify operands.<br /><br />1st thing we should learn:<br />There might be the only byte  or byte +<br />There might NOT be the only byte  without byte .<br />You can logically treat byte  as Extention of byte <br /><br />2nd thing we should learn:<br />Both bytes  and  have bits fields format 2:3:3<br />that means that 2 high bits of byte, 3 middle, and 3 last mean<br />different things.<br />2 upper bits in modr/m is called mod, may have 2^2=4 possible<br />values wich mean one of four following possible things:<br />11 - there is no memory operands, all operand(s) is (are) registers<br />00,01,10 - one of operands is memory operand. <br />(we discuss difference between 00,01,10 modes later)<br />2 upper bits in byte SIB (Scale Index Base) may have 2^2=4 possible<br />values wich mean one of 4 possible scales (multipyers) used with<br />index register (1,2,4,8).<br />The rest two 3 bits fields in both modr/m and sib usually<br />are fields for registers used in addressing, but also may mean something<br />else wich we learn in short time.<br /><br />3rd thing we should learn:<br />What kind of operands bytes   specify and what<br />they don't.<br />They don't specify predefiend operands. (For example there<br />can not be byte modr/m sib in instructions like chains, or<br />place for result in MUL\DIV opcodes also predefined)<br />They don't specify imm operands, from processor point of view<br />imm operand is not operands but part of opcode.<br />They specify only not predefined registers and places for values<br />to calculate memory address of memory operand <br />along with displacement (if any)<br />wich need to be count with the calculation of the address.<br />(displacement imm value (if any) follows immideatly after <br />part of opcode, size of it specifyed in field mod of <br />00-no displacement<br />01-8 bit displacement value<br />10-32 bit displacement value)<br />Now let's answer 3 simple questions:<br />How processor knows:<br />1. 1 or 2 operands are used?<br />2. What set of registers: full or partial specifys value in reg fields<br />of bytes modr/m and sib?<br />3. If there 2 operands wich one is &quot;destination&quot; and wich one is &quot;source&quot;?<br /><br />There common answer for all these three answers that all the info<br />processor takes from {code} block of opcode, not from modr/m and sib.<br /><br />To observe it in real opcode let us forget for a moment about existence<br />of memory operands.<br />If only reg operands are used (in other words - if there is no mem oprenads)<br />then value of mod field in modr/m will be 11<br />In bits it looks like<br />[8bits of code field]:11 *** ***<br />for example mov reg, reg:<br />100010dw:11 reg reg<br /><br />Answer for first quesiton: proccessor knows that there 2 or 1 operands<br />from upper bits of reg field.<br />If there is the only one operand then reg_code of it is placed <br />in a field mem/r of modm/r byte(last 3 bits)<br />And field code or reg(middle 3 bits) is used for code extantion.<br /><br />Example:<br />	MUL EBX<br />1111 011 1: 11 100 011<br /><br />Look at second byte 11 100 011<br />11 - mod field - 11 in mode means &quot;registers only&quot;<br />100 -code or reg field - in this case we have the only 1 operand<br />     and that means here this field is &quot;code extention&quot;<br />011 - 011 code for EBX register. In case with one operand this<br />      operand is always placed in last field of modr/m byte.<br /><br />To get used to the info:<br />Construct opcode changing opcode<br /> 1. in field &quot;code or reg&quot;, with the rest bit unchanged.<br /> 2. in field &quot;mem or reg&quot;<br /><br />If there are two operands both fields &quot;code or reg&quot; and &quot;mem or reg&quot;<br />is used for placement of the operands.<br /><pre><code><br />Example&#58;<br />	MOV EAX,EBX<br />1000 1011&#58; 11 000 011<br />Last byte &#40;modr/m&#41;<br />11 - only registers used<br />000 - code for EAX<br />011 - code for EBX<br /></code></pre><br /><br />Answer for second question<br />2. What set of registers: full or partial specifys value in reg fields<br />of bytes modr/m and sib?<br /><br />It also specified in code block, not in memr/m and sib.<br />For this perpose code block has bit &quot;w&quot;.<br />But we should remember that partial register can be used only<br />as register and never as pointer.<br /><br />If bit w = 1 then reg fields specifys full registers<br />if it is 0 - partial ones.<br /><br />Example with one register.<br /><pre><code><br />Mul reg has general format<br />1111 011w&#58;11 100 reg<br /><br /> with bit w = 1<br />1111 0111&#58;11 100 001 = MUL ECX<br /> with bit w = 0<br />1111 0110&#58;11 100 001 = MUL CL<br /></code></pre><br />as you see last byte (byte modr/m) is inentcal in both<br />cases, difference is in first byte (code block) and<br />the difference is in value of last bit, bit &quot;w&quot;<br />if value of w = 1 we have MUL ECX if w=0 - MUL CL.<br />Play with opcodes &quot;DIV,iDIV,MUL,iMUL reg&quot; changing last<br />bit of first byte and look how it's changing meaning of<br />value of operand between interpretation it as full\partial register.<br /><pre><code><br />Example with 2 reg operands&#58;<br />one opcode for MOV reg,reg has the following format&#58;<br />1000 101w&#58; 11 reg reg<br />with w=1<br />1000 1011&#58; 11 000 001 means MOV EAX,ECX<br />with w=0<br />1000 1010&#58; 11 000 001 means MOV AL,CL<br /></code></pre><br />As you can see byte modr/m again identical, the only<br />difference is in byte of code in value of w bit.<br /><br />Play with other instructions that use to reg operands.<br />For example sub reg,reg ; add reg,reg etc.<br />Insert such an instruction and then change last bit of the first<br />byte and see how it reflect in operands switching them from<br />full to partial regs set.<br /><br /><br />And the last third question:<br />3. If there 2 operands wich one is &quot;destination&quot; and wich one is &quot;source&quot;?<br /><br />It is also defined by &quot;code&quot; block, not by &quot;memr/m&quot; block.<br />For this is bit &quot;d&quot; wich states for &quot;direction&quot;.<br /><pre><code><br />Example with mov reg,reg<br />1000 10dw&#58;11 reg reg<br />1000 1011&#58;11 000 001 = MOV EAX,ECX<br />1000 1001&#58;11 000 001 = MOV ECX,EAX<br /></code></pre><br />Again you can see that we can have no difference in modr/m<br />and yet we cannot say without knowing value of bit &quot;d&quot;<br />wich of to registers is being copied to wich.<br /><br />It gives a possibility to encode MOV EAX,ECX in two possible<br />ways:<br /><pre><code><br />1000 1011&#58;11 000 001<br />1000 1001&#58;11 001 000 <br /></code></pre><br />both this codes do the same.<br />Now try it for yorself - insert some instruction of format INSTR REG,REG<br />and try to encode the same instruction than you assembler did.<br />for example I now inserting in OllyDbg:<br />add eax,ecx<br />OllyDbg generates opcode: 03 C1<br />in binary 0000 0011: 11 000 001<br />now I'm trying to encode it different way<br />first I change value in d bit from 1 to 0 and get in first byte<br />0000 0001<br />then I exchange bit values in second byte between last 2 3bits fields<br />that are for registers and get<br />11 001 000<br />full opcode now:<br />0000 0001:11 001 000 in hex 01C8<br />I insert it in OllyDbg and it shows in menemonics the same add eax,ecx<br />So both 03 C1 and 01 C8 are the same instruction.<br />Look again at their opcodes in binary:<br /><pre><code><br />	ADD EAX,ECX<br />0000 0011&#58;11 000 001 ;EAX=000 ECX=001<br />0000 0001&#58;11 001 000<br /></code></pre></div>
    <div class="meta">Posted on 2003-02-05 15:51:14 by The Svin</div>
   </div>
   <div class="post" id="post-80272">
    <div class="subject"><a href="#post-80272">Opcode #7</a></div>
    <div class="body">Memory operands specification in bytes modr/m and sib.<br />A few simple things to keep in mind.<br />Wether here 1 or 2 opreands only one of it can be memory operand.<br />Specification of memory operands means point to places that<br />used to calculate ADDRESS of the operand.<br /><br />Again format of modr/m byte (main byte that used to<br />specify operands and wich follow immediatly after code block)<br />2:3:3<br />2 upper bits - mode<br />3 middle bits - reg or code extention<br />3 low bits - reg or mem<br />Let's talk of last bit field.<br />What does it mean &quot;reg or mem&quot;?<br />What actuall meaning value in it can have?<br />There may be different interpratations of the last <br />3 bits of byte modr/m<br /><pre><code><br />1. If mod = 11 then value &quot;reg or mem&quot; means register.<br />2. If mod = 00,01 or 10 value in &quot;reg or mem&quot; field may mean<br />    - register as pointer to memory<br />    - &quot;flag&quot; that memory operand is specifyed by following sib byte<br />    - &quot;flag&quot; that memory operand is specifyed by direct value address.<br /></code></pre><br />Examples:<br />(in all example byte modr/m is second byte of opcode)<br /><pre><code><br />-----------------------------------------<br />	MOV EAX,&#91;EBX&#93;;<br /> 8B03   byte modr/m here is 03; in bynary<br />	00 000 011<br />        00 mod field means &quot;using mem operand without displacement&quot;<br />	000 - code for eax<br />	011 - code for ebx<br />look at difference between&#58;<br />MOV EAX,EBX    modr/m 11 000 011<br />MOV EAX,&#91;EBX&#93;  modr/m 00 000 011<br />the only difference is in field &quot;mod&quot;<br />for MOV EAX,EBX it is 11<br />for MOV EAX,&#91;EBX&#93; it is 00<br />----------------------------------------<br />	MOV EBX,dword ptr &#91;400000h&#93;<br />8B 1D 00004000<br />	byte modr/m 1D in bynary <br />	00 011 101;mod 00 codr 011 &#40;ebx&#41; memr 101.<br />code 101&#40;ebp&#41; in &quot;mem or reg&quot; field with mod = 00<br />means that no register is used to calculate address of operand<br />and that the address is in following byte modr/m dword.<br />Note&#58; 101 does not mean here &#91;ebp&#93;!<br />------------------------------------------<br />	MOV EBX,&#91;eax*4&#93;&#91;ecx&#93;&#91;3&#93;<br />8B 5C 81 03<br />byte modr/m 5C ; 81 -SIB ; 03 - displacement.<br />in bynary&#58;<br />	01 011 100<br />mod 	01 - means that displacement used and it has 1 byte size.<br />codr	011- code for EBX register<br />memr	100 - if 100 code is used in memr field it means<br />	      that byte SIB is present and it follows the byte modrm.<br />	      It relaited only to &quot;mem&quot; modes &#40;00,01,10&#41;<br />	      and only to field memr.<br />Note&#58; 100 does not mean here &#91;esp&#93;!<br />------------------------------------------<br /></code></pre><br />Now we discuss all of it in details.<br />For a start we take construction <br />INSTR reg, <br />or INSTR ,reg; what is important for us here<br />that instruction uses two operands and one of them is pointer to<br />memory.<br />Let say that register used as reg might be any general purpose<br />register, full or partial, and register used as pointer <br />might be any full general purpose register except for esp and ebp.<br /><br />With given conditions opcode for<br /><pre><code><br />	instr reg1,reg2<br />	and<br />	instr reg1,&#91;reg2&#93;<br /></code></pre><br />is identical exept of value of bit field mod.<br />In case of instr reg1,reg2  mod =11<br />In case of instr reg1, mod =00<br />Example:<br /><pre><code><br />mov eax,ebx          8BC3  1000 1011&#58;&#91;b&#93;11&#91;/b&#93; 000 011<br />mov eax,&#91;ebx&#93;        8B03  1000 1011&#58;&#91;b&#93;00&#91;/b&#93; 000 011<br /></code></pre><br /><br />At last we can see some sence in bit &quot;d&quot; of code field.<br />Indeed, register as memory pointer can be only in bitfield memr<br />but along with <br />instr reg,<br />we need also<br />instr ,reg<br />In both of this cases byte modr/m is the same,<br />the difference to specify wich one of the two operands<br />is source and wich is destination can be seen in value<br />of bit &quot;d&quot; in code block<br />Example:<br /><pre><code><br />mov eax,&#91;ebx&#93; 8B03   1000 10&#91;b&#93;1&#91;/b&#93;1&#58;00 000 011<br />mov &#91;ebx&#93;,eax 8903   1000 10&#91;b&#93;0&#91;/b&#93;1&#58;00 000 011<br /></code></pre>  <br /><br />Now again about <strong>size</strong> of operand.<br />What the difference between<br /><pre><code><br /> dword ptr &#91;ebx&#93;<br /> word ptr &#91;ebx&#93;<br /> byte ptr &#91;ebx&#93;<br /></code></pre><br /><br />We must remember 2 simple things<br />-that memory operand specifyed in opcode is not the operand itself<br />but address of the operand, to be more accurate - values in registers and<br />displacement immediate value (if any) that is used to calculate<br />address of the operand.<br />-address of operand is always address of the lowest byte of operand.<br />In other words is byte ptr addrx, word ptr addrx, operand of any size<br />ptr addrx have the same address.<br />In 32 bit addressing mode address offset value is always 32bit value<br />(if prefix 67h is not present) and registers that used to calculate<br />the address are always taken as 32 bit registers.<br />To specify size of operand used known to us bit &quot;w&quot; in code block<br />and prefix 66h.<br />Example:<br /><pre><code><br />&#40;bit D = 1;from mem to reg&#41;<br />mov eax,dword ptr &#91;ebx&#93;      8B 03 1000 101&#91;b&#93;1&#91;/b&#93; 00 000 011<br />mov ax,word ptr &#91;ebx&#93;     66 8B 03 &#40;all the same but prefix 66 present&#41;<br />mov al,byte ptr &#91;ebx&#93;        8A 03 1000 101&#91;b&#93;0&#91;/b&#93; 00 000 011<br /></code></pre><br /><br />Now encode all this 3 opcodes with bit D = 0 and look at the results.<br />(bit &quot;d&quot; is bit[1] in byte code in present examples byte code<br />has values 8B, in first two opcode and 8A in the last one)</div>
    <div class="meta">Posted on 2003-02-06 18:34:34 by The Svin</div>
   </div>
   <div class="post" id="post-80277">
    <div class="subject"><a href="#post-80277">Opcode #7</a></div>
    <div class="body">Advantage to know opcode format is mostly<br />usefull to get in a fly impression what size <br />of opcode could be produced from your menemoncis.<br />Most opcodes size can be calulated as size of<br />code block (wich in overvelming majority of<br />most most used instructions = 1 byte) plus<br />size for operand specifications.<br />With detailed examples of this articles upto<br />now you can assume that in most constructions like<br /> instr reg,reg<br />instr = 1 byte, and address part is also 1 byte.<br />Altogether 2 bytes.<br />If reg is 16 bits add also 1 byte for prefix.<br /><br />in formats like:<br /> instr reg,<br /> instr ,reg<br />address part is also 1 byte if  doesn't mean <br />or . So if you can use ebp and esp as registers<br />without any size penalties but using them as pointers<br />without displasment costs you extra byte.<br />For the rest registers all calculations are the same,<br />wither you use them as registers or as pointers.<br />Using word operands also cost you extra byte for prefix.</div>
    <div class="meta">Posted on 2003-02-06 19:35:15 by The Svin</div>
   </div>
   <div class="post" id="post-80519">
    <div class="subject"><a href="#post-80519">Opcode #7</a></div>
    <div class="body">Displacemt, or what mod = 00,01,10 is about.<br />We know that is we have two operands as registers<br />all we need to specify them is the only byte modr/m<br />wich have 11 is field &quot;mod&quot; and code for two registers<br />in the rest two field.<br />For example byte 11 000 001 specifys two register operands<br />eax and ecx, 11 011 111 specifys two register operands ebx and edi<br />and so on...<br />We also know that if we have to specify to operands: one of them<br />as register and other as register-pointer(any one but esp or ebp)<br />the only modrm byte will also be enough.<br />In this case we mod = 00, field &quot;code or reg&quot; contents code of<br />register operand as register, and field &quot;mem or reg&quot; contents<br />code for register as pointer.<br />For example byte 00 000 001 specifys eax as register and  as<br />pointer;00 011 111 - ebx as register and  as pointer.<br /><br />Let's say at last why there could not be  of  specifyed<br />by the only one address byte - modrm.<br />Code for  placed in field &quot;mem or reg&quot; with mod = 00 has<br />special &quot;flag&quot; meaning - it means that there is no registers<br />used as pointer and addressing is &quot;directed&quot; by following dword.<br />Code for  with any of 00,01,10 mods has special meaning too -<br />it tells that byte SIB is present and addressing registers is in SIB<br />not in field &quot;mem or reg&quot;.<br /><br />Of course, you can write mnemonics mov reg,; or mov reg,<br />but format to encode the meaning will be different then with any<br />other register used in place for register pointer (&quot;mem or reg&quot; field).<br />We discuss how to encode mov reg, or mov reg, later in short<br />time.<br /><br />For now we bring to our attention meaning of mod = 00,01,10.<br />We come here to very intersted point for optimization:<br />in many instructions immideate dword operand can be encoded using<br />single byte.<br />We talking here of signed byte and signed dword respectivly.<br />If value is negative and &gt;= -128, signed dword has the same value<br />in least significant byte as in byte of the same value<br />and all upper bits set to 1.<br /><br />Example:<br /><pre><code><br /> -2=<br />FFFFFFFEh as dword<br />      FEh as byte.<br /></code></pre><br />If value is positive and &lt;=127 signed dword has the same value in<br />least significan byte as in byte of the same value and all upper<br />bits set to 0.<br />Example<br /><pre><code><br /> 2=<br />00000002h as dword<br />      02h as byte<br /></code></pre><br />This allow processor perform &quot;signed byte to signed dword&quot; extention,<br />in other words - use a signed byte as dword operand &quot;extenting&quot;<br />value of most significant bit of the byte to all upper bits of<br />dword.<br />&quot;Byte to dword extention&quot; can creatically decrease size using<br />to encode dword imm. value 4 times less space then otherwize.<br /><br />To understand how to encode in code that there is &quot;extended to dword byte&quot;<br />we need to diffrentiate to types of imm. values.<br /><pre><code><br />1. Imm. value used as operand&#58;<br />	and eax,03 ; 03 is imm. value as  operand.<br />2. Imm. value as displacement&#58;<br />	and eax,&#91;ecx&#93;&#91;3&#93; ;3 is imm value as displacement that needs<br />			 ;to be counted in calculation of address<br /></code></pre><br />These two types are encoded in different ways.<br />Firstly we'll learn how &quot;displacement&quot; is encoded.<br />Now by term &quot;membytes&quot; I mean part of opcode that has byte modm/r and<br />sib(if sib present).<br />&quot;If there is displacment&quot; is specifyed by value in mod field.<br />mod = 00: there is no displacemt (exeption code for ebp in mem/r field<br />that means that there is &quot;only 32 bit displacement and no register pointers&quot;)<br />mod = 01: there is displacement and it is coded in single byte.<br />mod = 10: there is displacement and it is coded in dword.<br /><br />Examples:<br /><pre><code><br />	mov eax,&#91;ebx&#93;<br />8B03.<br />03 is byte modrm = 00 000 011 ;00&#40;mod&#41; - no displacement<br />			      ;000 - eax<br />			      ;011 - &#91;ebx&#93;<br />	mov eax,&#91;ebx&#93;&#91;-2&#93;<br />8B43 FE <br />43 is byte modrm = 01 000 011 ;01&#40;mod&#41; - displacement in one single byte<br />			      ;000 - eax<br />			      ;011 - &#91;ebx&#93;<br />FE - is the displacent in &quot;extended byte&quot; processor extends it<br />to FFFFFFFEh<br /><br />	mov eax,&#91;ebx&#93;&#91;410000h&#93;<br />8B 83 00 00 41 00<br />83 is byte moder/m = 10 000 011 ;10&#40;mod&#41; - displacement in dword<br />				;000 - eax<br />				;011 - &#91;ebx&#93;<br /><br />And last four bytes is dword 00410000h - imm. value of displacement<br />coded in all 32 bits.<br /></code></pre><br />Now we can say how assembler encode  as pointer.<br />Instead of using mod 00 is uses mod 01 (displacement as byte)<br />and instr reg, is encoded actually as instr reg,[0]<br /><pre><code><br />You can insert two instructions like&#58;<br />	mov eax,&#91;ebp&#93;<br />	mov eax,&#91;ebp&#93;&#91;0&#93;<br />and any like that, to see that it is the same opcode.<br /><br />Take a notion for that using&#58;<br />	instr reg,&#91;ebp&#93;<br />is 1 byte longer than&#58; <br />	instr reg,&#91;any reg but ebp or esp&#93;<br /><br />At the same time&#58;<br />	instr reg,&#91;ebp&#93;&#91;displacement &lt;&gt; 0&#93;<br />has the same size as&#58;<br />	instr reg,&#91;any reg&#93;&#91;displacement &lt;&gt; 0&#93;<br /></code></pre><br />Though in the example reg is the first operand and pointer<br />to memory the second, size and encoding will be the same<br />if you exchange their places. The difference will be only<br />in value of bit &quot;d&quot; of code block, not in size and values in membytes.</div>
    <div class="meta">Posted on 2003-02-08 08:17:59 by The Svin</div>
   </div>
   <div class="post" id="post-80567">
    <div class="subject"><a href="#post-80567">Opcode #7</a></div>
    <div class="body">SIB byte.<br />Here we'll discuss:<br />- What tells processor that there is sib byte?<br />- Format of sib byte<br />- ESP can not be index register. What happens if there is esp code<br />  in place for index.<br />- Again about EBP - we can't get short opcode<br />  for  without displacement.<br />- How instr reg, is encoded.<br />- Address formula - line equation.<br />-----------------------------------------------------------<br />- What tells processor that there is sib byte?<br />Remember that sib byte might be only if there is modr/m byte<br />preceeding it.<br />In other words there might be modr/m without sib, but<br />there can not be sib without modr/m.<br />Presence of sib byte needed only if there is a need to calculate<br />memory address.<br />So processor knows about presence of sib by two thing:<br />* mod field says that there is mem operand (mods 00,01,10)<br />* mem or reg field has special &quot;flag&quot; value 100 (code for esp)<br />so modr/m bytes with format:<br />00 *** 100<br />01 *** 100<br />10 *** 100<br />all tell that there is sib byte wich follows the modr/m byte.<br />------------------------------------------------------------<br />- Format of sib byte:<br />SS:III:BBB<br /><pre><code><br />In general foramt of sib byte is&#58;<br />SS&#58; two upper bits content code for scale <br />    &#40;multiplyer&#41; of index register<br />00 = 1<br />01 = 2<br />10 = 4<br />11 = 8<br />for example sib <br />for &#91;reg&#93;&#91;reg&#93;  is 00 *** ***<br />    &#91;reg*2&#93;&#91;reg&#93;   01 *** ***<br />    &#91;reg*4&#93;&#91;reg&#93;   10 *** ***<br />    &#91;reg*8&#93;&#91;reg&#93;   11 *** ***<br />III&#58;3bits code for index register - <br />    any general purpose register but esp<br />for example<br />    &#91;eax&#93;&#91;reg&#93;     00 000 ***<br />    &#91;ecx*8&#93;&#91;reg&#93;   11 001 ***<br />    &#91;edx&#93;&#91;reg&#93;     00 010 ***<br />    &#91;ebx*2&#93;&#91;reg&#93;   01 011 *** &#40;01 = scale 2; 011 - ebx; *** code for base reg&#41;<br />BBB&#58;3bits code for base register.<br />    &#91;ecx*4&#93;&#91;eax&#93;   10 001 000 &#40;10 = scale 4; 001 -ecx as index;000 eax as base&#41;<br /><br /></code></pre><br /><br />I'm curious if anybody read this :).<br />Make some some noise, please :)</div>
    <div class="meta">Posted on 2003-02-08 18:15:11 by The Svin</div>
   </div>
   <div class="post" id="post-80641">
    <div class="subject"><a href="#post-80641">Opcode #7</a></div>
    <div class="body"><div class="quote"><br />I'm curious if anybody read this :).<br />Make some some noise, please :) </div><br /><br />I'm reading it, and learing it (at least I think I'm learning it :)).</div>
    <div class="meta">Posted on 2003-02-09 05:59:21 by scientica</div>
   </div>
   <div class="post" id="post-80681">
    <div class="subject"><a href="#post-80681">Opcode #7</a></div>
    <div class="body">Very good.<br />I have a good company then :)</div>
    <div class="meta">Posted on 2003-02-09 10:01:44 by The Svin</div>
   </div>
   <div class="post" id="post-80703">
    <div class="subject"><a href="#post-80703">Opcode #7</a></div>
    <div class="body">- ESP can not be index register. What happens if there is esp code<br />  in place for index.<br /><br />  If in index field placed code for esp (100) then index is ignored,<br />  whatever is in scale field in the sib - doesn't matter:<br />  Only base field is taken in count to calculate address and<br />  the result of address calculations will be the same as if<br />  the were not byte sib at all and value of base field were placed<br />  to &quot;mem or reg&quot; field of byte modr/m<br />  in other words this two addresses is idenical:<br /><pre><code><br />  modr/m        sib<br />  ** *** 101    ** 100 reg<br />  ** *** reg    &#40;no sib byte&#41;<br />  example with real opcode&#58;<br />  &#91;eax&#93; might be coded two ways with and without sib&#58;<br />  modr/m<br />  00 reg 000<br />  modr/m      sib<br />  00 reg 100  ** 100 000<br />  whatever you'd place in scale field - result will be the<br />  same&#58; addressing reg,&#91;eax&#93;<br /></code></pre><br />If you have question what for it could be needed, - the answer<br />is to make it able to code addressing like: reg,<br />So it is answer to next our question:<br />- How instr reg, is encoded<br />It also amswers how  is coded.<br /><pre><code><br />  modm/r byte       sib<br />mod rcode memr   ss  iii  bbb<br />00  reg   100    any 100  100<br />if mod 01 or 10 with the above format that would mean<br />mod 01 reg,&#91;esp&#93;&#91;displacement byte&#93;<br />mod 10 reg,&#91;esp&#93;&#91;displacement dword&#93;<br /></code></pre><br />(displacement imm. value follow immideatly after sib <br /> in the case).<br />So the only reason to use SIB while not using index register<br />is to encode  as base pointer.<br /><br />What if we have reversed situation?<br />If have the only index with scale and no base register?<br />Answer to the question also explain one of our questions:<br />- Again about EBP - we can't get short opcode<br />  for  without displacement.<br /><br />Placement code for ebp(101) in &quot;base&quot; field with mod = 00 has<br />the same effect as placement  ebp code in &quot;mem or reg&quot; field<br />of modr/m byte with (again!) mod=00.<br />It means 2 things:<br />-that there is no &quot;Base&quot; register.<br />-there is imm. 32 bit displacement used as base.<br /><br />It result in paradoxial result:<br /><br />you can encode  with just one sib<br />but encoding    will result in sib + 4 bytes<br />for displacement!<br /><pre><code><br />Example&#58;<br />mnemonic&#58;	mov eax,&#91;ebx*4&#93;&#91;ecx&#93;<br />opcode&#58;         8B0499 <br />		where 8B is &quot;code&quot;;04 modr/m;99 sib<br />mnemonic&#58;	mov eax,&#91;ebx*4&#93;<br />opcode&#58;		8B049D 00 00 00 00<br />		where 8B is &quot;code&quot;;04 modr/m;94 sib<br />		add 4 byte 00 00 00 00 - displacement!<br /></code></pre></div>
    <div class="meta">Posted on 2003-02-09 12:44:59 by The Svin</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=10554&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=10554&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="10554" /><input type="number" name="page" min="1" max="8" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=10554&amp;page=2">&gt;</a><a href="../?id=10554&amp;page=8">&raquo;</a></form>  </div>
 </body>
</html>