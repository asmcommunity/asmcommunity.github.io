<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>How do i change the background color of a Window using native API in C++? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30869" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=30869">How do i change the background color of a Window using native API in C++?</a></p>
   <div class="post" id="post-215937">
    <div class="subject"><a href="#post-215937">How do i change the background color of a Window using native API in C++?</a></div>
    <div class="body">Ok, so i am trying to do something as simple as changing the background color of the window when the mouse is over it. I have tried so many things, most of them in comment and none of them worked:<br /><br /><pre><code>#pragma comment(linker,&quot;\&quot;/manifestdependency:type=&#039;win32&#039; \<br />name=&#039;Microsoft.Windows.Common-Controls&#039; version=&#039;6.0.0.0&#039; \<br />processorArchitecture=&#039;*&#039; publicKeyToken=&#039;6595b64144ccf1df&#039; language=&#039;*&#039;\&quot;&quot;)<br /><br />#include &lt;Windows.h&gt;<br /><br />LRESULT CALLBACK WindowProcedure<br />	(<br />		HWND WindowHandle,<br />		UINT Message,<br />		WPARAM WordParameter,<br />		LPARAM LongParameter<br />	)<br />{<br />	PAINTSTRUCT PaintStructure;<br />	HDC DeviceContextHandle;<br />	TRACKMOUSEEVENT MouseEvent;<br />	RECT Rectangle;<br /><br />	switch(Message)<br />	{<br />	case WM_ERASEBKGND:<br />		//SetClassLongPtr(WindowHandle, GCLP_HBRBACKGROUND, RGB(0,0,0));<br />		break;<br />	case WM_MOUSEHOVER:<br />		//GetWindowRect(WindowHandle, &amp;Rectangle);<br />		//RedrawWindow(WindowHandle, &amp;Rectangle, NULL, RDW_UPDATENOW);<br />		//PostMessage(WindowHandle, WM_PAINT, 200, NULL);<br />		break;<br />	case WM_MOUSEMOVE:<br />		MouseEvent.cbSize = sizeof(TRACKMOUSEEVENT);<br />		MouseEvent.dwFlags = TME_HOVER;<br />		MouseEvent.dwHoverTime = 100;<br />		MouseEvent.hwndTrack = WindowHandle;<br />		TrackMouseEvent(&amp;MouseEvent);<br />		break;<br />	case WM_PAINT:<br />		/*if (WordParameter == 200) {<br />			DeviceContextHandle = GetDC(WindowHandle);<br />			SetBkColor(DeviceContextHandle, RGB(0,0,0));<br />		}*/<br />		DeviceContextHandle = BeginPaint(WindowHandle, &amp;PaintStructure);<br />		//SetBkColor(DeviceContextHandle, RGB(0,0,0));<br />		EndPaint(WindowHandle, &amp;PaintStructure);<br />		break;<br />	case WM_DESTROY:<br />		PostQuitMessage(WM_QUIT);<br />		break;<br />	default:<br />		return DefWindowProc(WindowHandle, Message, WordParameter, LongParameter);<br />	}<br />	return 0;<br />}<br /><br />int WINAPI wWinMain<br />	(<br />		HINSTANCE CurrentInstance,<br />		HINSTANCE PreviousInstance,<br />		LPWSTR CommandLine,<br />		int CommandShow<br />	)<br />{<br />	WNDCLASSEX WindowClass = {0};<br />	WindowClass.cbSize = sizeof(WNDCLASSEX);<br />	WindowClass.style = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;<br />	WindowClass.lpfnWndProc = WindowProcedure;<br />	WindowClass.cbClsExtra = NULL;<br />	WindowClass.cbWndExtra = NULL;<br />	WindowClass.hInstance = CurrentInstance;<br />	WindowClass.hIcon = NULL;<br />	WindowClass.hCursor = LoadCursor(NULL, IDC_ARROW);<br />	WindowClass.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);<br />	WindowClass.lpszMenuName = NULL;<br />	WindowClass.lpszClassName = &quot;Main Class&quot;;<br />	WindowClass.hIcon = NULL;<br />	RegisterClassEx(&amp;WindowClass);<br /><br />	RECT Rectangle = {0, 0, 640, 480};<br />	AdjustWindowRect(&amp;Rectangle, WS_OVERLAPPEDWINDOW, FALSE);<br /><br />	HWND WindowHandle = CreateWindowEx<br />		(<br />			WS_EX_CONTEXTHELP,<br />			&quot;Main Class&quot;,<br />			&quot;Window Title&quot;,<br />			WS_OVERLAPPEDWINDOW,<br />			CW_USEDEFAULT,<br />			CW_USEDEFAULT,<br />			Rectangle.right - Rectangle.left,<br />			Rectangle.bottom - Rectangle.top,<br />			NULL,<br />			NULL,<br />			CurrentInstance,<br />			NULL<br />		);<br /><br />	ShowWindow(WindowHandle, CommandShow);<br />	UpdateWindow(WindowHandle);<br />	<br />	MSG Message = {0};<br />	while(Message.message != WM_QUIT)<br />	{<br />		if (PeekMessage(&amp;Message, 0, 0, 0, PM_REMOVE)) {<br />			TranslateMessage(&amp;Message);<br />			DispatchMessage(&amp;Message);<br />		}<br />	}<br /><br />	return (int)Message.wParam;<br />}</code></pre><br /><br />-I tried to Send/PostMessage back to WM_PAINT and change the background color.<br />-I tried using SetClassLongPtr() which worked but it did not update the Window automatically. I had to resize/minimize/restore window for it to show the effects.<br />-Most of the forums say to use WM_ERASEBKGND but doesn&#039;t say how specifically. Therefore i can&#039;t get it working neither.<br /><br />I tried so many combinations with no luck so i need help.&nbsp; :sad:</div>
    <div class="meta">Posted on 2012-04-05 18:34:27 by banzemanga</div>
   </div>
   <div class="post" id="post-215938">
    <div class="subject"><a href="#post-215938">Re: How do i change the background color of a Window using native API in C++?</a></div>
    <div class="body"><div class="quote"><br />-I tried using SetClassLongPtr() which worked but it did not update the Window automatically. I had to resize/minimize/restore window for it to show the effects.</div><br /><br />I think you should do SetClassLongPtr(), followed by an InvalidateRect(hWnd, NULL) to force a redraw of your window (resizing/minimizing etc would also trigger an InvalidateRect()).</div>
    <div class="meta">Posted on 2012-04-06 05:13:19 by Scali</div>
   </div>
   <div class="post" id="post-215940">
    <div class="subject"><a href="#post-215940">Re: How do i change the background color of a Window using native API in C++?</a></div>
    <div class="body">Thanks Scali. InvalidateRect() is some weird name for a function that updates the Window. I thought that i had to use UpdateWindow() or RedrawWindow() in some weird way; which did not work by the way.<br /><br />I have a questions about custom controls. I found out that the way Window creates default controls is by creating child-windows with predetermined properties. And this goes for Buttons, text-boxes, combo-boxes, text-labels, etc. So any custom control for the GUI that i would like to make i would probably have to draw the images and them paste them on top of child windows and have them react to different messages.<br /><br />1) Does it mean that for every button i make i would have to make a child window and attach a callback function for each of them?<br />2) What about when making game menus and stuff? Are those also child Windows?</div>
    <div class="meta">Posted on 2012-04-06 17:51:56 by banzemanga</div>
   </div>
   <div class="post" id="post-215941">
    <div class="subject"><a href="#post-215941">Re: How do i change the background color of a Window using native API in C++?</a></div>
    <div class="body"><div class="quote"><br />Thanks Scali. InvalidateRect() is some weird name for a function that updates the Window. I thought that i had to use UpdateWindow() or RedrawWindow() in some weird way; which did not work by the way.</div><br /><br />Well, technically it&#039;s not a function that updates a window.<br />You&#039;ll have to know a bit about the basics of the GUI for it to make sense.<br />Windows did not support any kind of backbuffering, historically (memory was expensive in the olden days). So what it does instead, is to redraw windows on-the-fly. When Windows overlap on screen, it marks the overlapping parts with rectangles (in general, windows are rectangular in shape).<br />Parts of a window that need to be redrawn are &#039;invalidated&#039; (marked &#039;dirty&#039;) by the system. This results in new WM_PAINT messages being sent to the window (including the actual rectangle that needs to be redrawn). There is also a ValidateRect() function that marks a rectangle as &#039;clean&#039; again.<br /><br />So that&#039;s pretty much how Windows works: something happens that marks (part of) your window as &#039;dirty&#039;/invalidated, then your window redraws it and marks it validated again. Lather, rinse, repeat.<br />(Since Vista/Aero, things don&#039;t work entirely like this anymore. Because the whole UI is now drawn with the GPU, each window gets its own backbuffer as a texture in videomemory. As a result, overlapping windows don&#039;t physically draw on top of eachother anymore. The GPU just renders each window using the z-buffer, but the actual textures containing the window contents are unaffected by the overlapping. This also means that in Aero-mode, you get a lot less invalidate/validate action).<br /><br />By calling InvalidateRect() yourself, you can mark a region of a window for redrawing. Passing NULL instead of an actual rectangle means that the entire window needs to be redrawn.</div>
    <div class="meta">Posted on 2012-04-07 04:54:23 by Scali</div>
   </div>
  </div>
 </body>
</html>