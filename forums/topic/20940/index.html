<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>LinkedList Evolutions (ATC) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20940" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=38">Object Oriented Programming</a> &raquo; <a href="../?id=20940">LinkedList Evolutions (ATC)</a></p>
   <div class="post" id="post-158943">
    <div class="subject"><a href="#post-158943">LinkedList Evolutions (ATC)</a></div>
    <div class="body">Here&#39;s a little somethin I&#39;ve been using a lot lately.<br />With the exception of untested BackPointer stuff, it&#39;s solid as a rock? :P<br />If anyone improves / extends this code, please post your version update here for all to use :)<br /><br /><pre><code><br />;=====================================================================<br />;April 14 2005<br />;EvilHomer proudly presents:<br />;LinkedList Class for ATC version 3.1<br />;A general-purpose (naive) heap-object array manager.<br />;Now supports BackPointers, Insertion and Deletion.<br />;<br />;=====================================================================<br />;<br />;Two methods are supplied for adding Objects to an instance of LinkedList.<br />;1) Append<br />; This method appends an object you allocated with malloc to the end of a LinkedList.<br />; Use this if you prefer to allocate your own memory, but DO use malloc to do it.<br />;2) AddNewObject<br />; This method will malloc a new object of given size and append it for you.<br />; It will return a pointer to the object, which you can then use to set data in the new object.<br />;<br />;Note about destruction / cleanup :<br />;When you delete the LinkedList instance, it will automatically free any objects it contains.<br />;This can be handy, but DO note the following:<br />;It will not clean up or release any data stored within those objects, as it is naive as to exactly<br />;which kind, or size, of objects it is actually storing.<br />;There is currently NO support for deletion / insertion of objects.<br />;=====================================================================<br />;This structure describes the Nodes stored in the LinkedList<br />;Each Node contains a ptr to the next Node , and also <br />;contains a ptr to some object Owned by the Node.<br />;<br />;Here is an ascii representation of the Tree topology.<br />;As you can see, it couldn&#39;t be more simple.<br />;<br />;Root<br />;&nbsp;  |<br />;Node0 --&gt; Object0<br />;&nbsp;  |<br />;Node1 --&gt; Object1<br />;&nbsp;  |<br />;NodeN --&gt; ObjectN<br />;&nbsp;  |<br />;(NULL)<br />;<br />;=====================================================================<br />LinkedNode struct<br />pLinkFwd&nbsp; &nbsp; &nbsp; dd ?&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;ptr to the next Node<br />pLinkBack&nbsp; &nbsp;  dd ?&nbsp; &nbsp; &nbsp; &nbsp;  ;ptr to the previous Node<br />pObjectData dd ?&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;This Node&#39;s ObjectPtr<br />LinkedNode ends<br />;=====================================================================<br /><br />class LinkedList, ,C++ compatible<br />;Allocate a new Object and Append it to the LinkedList (returns ptr)<br />void GetFirst&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Fetches the &#39;first&#39; object in list and presets internal iteration ptr<br />void GetNext&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Fetches the &#39;next&#39; object in list and updates internal iteration ptr<br />void GetPrev&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Fetches the &#39;previous&#39; object in list, updates internal&nbsp; iteration ptr<br />void GetNth:dwIndex&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Fetches the &#39;Nth&#39; object in list <br />void Append:SomeObjectPointer&nbsp;  ;Append an existing object to the LinkedList<br />void AddNewObject:dwObjectSize ;Allocates new Object of given Size, Appends, returns pObject<br /><br />void GetNodeByDataObject:pObject ;Finds container LinkedNode for given Object<br />void InsertAfter:pObjectParent, pObjectNew ;Insert an Object after a given Object in the List<br />void DeleteObject:pObjectToDelete&nbsp; ;Deletes an arbitrary object from the List<br /><br />long pFirstNode&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;A quick, handy link to the First Node in the chain<br />long pLastNode&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;A quick, handy link to the Last Node in the chain<br />long pCurrentNode&nbsp; &nbsp;  ;An iteration pointer for walking the Nodes (see GetFirst/GetNext)<br />long NumNodes<br />endclass<br /><br />;=====================================================================<br /><br />LinkedList_LinkedList proc<br />ret<br />LinkedList_LinkedList endp<br /><br />LinkedList_Append proc pObjectData<br />local pnode<br />inc .LinkedList.NumNodes&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;We can increment our counter now, its ok<br />mov pnode, malloc(sizeof LinkedNode)&nbsp; &nbsp; &nbsp; ;Allocate a new LinkedNode struct<br />m2m .LinkedNode.pObjectData, pObjectData ;Store ptr to payload Object in Node<br />.if .LinkedList.pFirstNode==0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;If there&#39;s no First Node in the List<br />&nbsp; &nbsp; mov .LinkedList.pFirstNode, eax&nbsp; &nbsp; &nbsp; &nbsp; ;then this will be the First Node<br />.else&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;else if there&#39;s already a First Node<br />&nbsp; &nbsp; mov ebx, .LinkedList.pLastNode&nbsp; &nbsp; &nbsp; &nbsp; ;fetch the Last Node<br />&nbsp; &nbsp; mov .LinkedNode.pLinkFwd,eax&nbsp; &nbsp; &nbsp; &nbsp; ;point fwd from old lastnode to new node<br />&nbsp; &nbsp; mov .LinkedNode.pLinkBack, ebx&nbsp; &nbsp;  ;point back from new node to old lastnode<br />.endif<br />mov .LinkedList.pLastNode,eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;We just made a new Last Node<br />ret<br />LinkedList_Append endp<br /><br />LinkedList_$LinkedList proc<br />local me<br />mov me,ecx<br />mov ecx,.LinkedList.pFirstNode<br />.while ecx!=0<br />&nbsp; &nbsp; .if .LinkedNode.pObjectData!=0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;If this node has Object data<br />&nbsp; &nbsp; &nbsp; &nbsp; free&nbsp; .LinkedNode.pObjectData&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Free the Object data (we hope)<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; push .LinkedNode.pLinkFwd&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;preserve address of next node<br />&nbsp; &nbsp; free ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;destroy this node<br />&nbsp; &nbsp; pop ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;restore address of next node<br />.endw<br />ret<br />LinkedList_$LinkedList endp<br /><br />LinkedList_GetFirst proc&nbsp;  <br />&nbsp; &nbsp; mov eax, .LinkedList.pFirstNode&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;&lt;-- Starting with the FIRST node&nbsp; &nbsp; <br />&nbsp; &nbsp; .if eax!=0&nbsp; ;&lt;-- check for NULL first node (no content in LL)<br />&nbsp; &nbsp; &nbsp; &nbsp; mov .LinkedList.pCurrentNode, eax&nbsp; &nbsp; &nbsp; ;&lt;-- Set up the current node<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,.LinkedNode.pObjectData&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;&lt;-- Return the node&#39;s Object ptr<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; ret<br />LinkedList_GetFirst endp<br /><br />LinkedList_GetNth proc dwIndex<br />&nbsp; &nbsp; mov eax, .LinkedList.pFirstNode&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;&lt;-- Starting with the FIRST node&nbsp; <br />&nbsp; &nbsp; .while dwIndex!=0 &amp;&amp; eax!=0<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,.LinkedNode.pLinkFwd<br />&nbsp; &nbsp; &nbsp; &nbsp; dec dwIndex<br />&nbsp; &nbsp; .endw<br />&nbsp; &nbsp; .if eax!=0<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,.LinkedNode.pObjectData&nbsp; &nbsp; <br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; ret<br />LinkedList_GetNth endp<br /><br />LinkedList_GetNext proc<br />&nbsp; &nbsp; mov eax, .LinkedList.pCurrentNode&nbsp; &nbsp; &nbsp;  ;&lt;-- Starting with the current node<br />&nbsp; &nbsp; .if eax!=0<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax, .LinkedNode.pLinkFwd&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;&lt;-- Increment the current node <br />&nbsp; &nbsp; &nbsp; &nbsp; mov .LinkedList.pCurrentNode,eax&nbsp; &nbsp; &nbsp; &nbsp; ;&lt;-- Set up the incremented current node<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax!=0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov eax,.LinkedNode.pObjectData&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;&lt;-- Return the node&#39;s Object ptr<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; ret<br />LinkedList_GetNext endp<br /><br />LinkedList_GetPrev proc<br />&nbsp; &nbsp; mov eax, .LinkedList.pCurrentNode&nbsp; &nbsp; &nbsp;  ;&lt;-- Starting with the current node<br />&nbsp; &nbsp; .if eax!=0<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax, .LinkedNode.pLinkBack&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;&lt;-- Decrement the current node <br />&nbsp; &nbsp; &nbsp; &nbsp; mov .LinkedList.pCurrentNode,eax&nbsp; &nbsp; &nbsp; &nbsp; ;&lt;-- Set up the incremented current node<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax!=0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov eax,.LinkedNode.pObjectData&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;&lt;-- Return the node&#39;s Object ptr<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; ret<br />LinkedList_GetPrev endp<br /><br />LinkedList_AddNewObject proc dwObjectSize<br />&nbsp; &nbsp; push malloc (dwObjectSize)<br />&nbsp; &nbsp; icall ecx, LinkedList, Append, eax<br />&nbsp; &nbsp; .if eax==0<br />&nbsp; &nbsp; &nbsp; &nbsp; pop eax<br />&nbsp; &nbsp; &nbsp; &nbsp; Message &quot;LinkedList_AddNewObject : malloc failed !!!&quot;<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; pop eax<br />&nbsp; &nbsp; ret<br />LinkedList_AddNewObject endp<br /><br />LinkedList_GetNodeByDataObject proc pObject<br />.if pObject==0<br />&nbsp; &nbsp; return NULL<br />.endif<br />.if .LinkedList.pFirstNode==0<br />&nbsp; &nbsp; return NULL<br />.endif<br />mov eax, .LinkedList.pFirstNode<br />mov ebx,pObject<br />.while eax!=0<br />&nbsp; &nbsp; .if .LinkedNode.pObjectData==ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; mov eax,.LinkedNode.pLinkFwd<br />.endw<br />ret<br />LinkedList_GetNodeByDataObject endp<br /><br />LinkedList_InsertAfter proc pObjectParent, pObjectNew<br />local pnode<br />.if pObjectParent==0<br />&nbsp; &nbsp; ret<br />.endif<br />inc .LinkedList.NumNodes&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;We can increment our counter now, its ok<br />mov pnode, malloc(sizeof LinkedNode)&nbsp; &nbsp; &nbsp; ;Allocate a new LinkedNode struct<br />m2m .LinkedNode.pObjectData, pObjectNew;Store ptr to payload Object in Node<br /><br />; Try to find the LinkedNode which owns the object we wish to insert behind.<br />; If this returns NULL, then pObjectParent isn&#39;t stored in the List<br />; Otherwise it returns a ptr to the LinkedNode containing pObjectParent<br />; which we want to manipulate.<br /><br />icall ecx, LinkedList, GetNodeByDataObject, pObjectParent<br />.if eax!=0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;eax=Parent<br />&nbsp; &nbsp; mov ebx,pnode&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;ebx=This<br />&nbsp; &nbsp; push&nbsp; .LinkedNode.pLinkFwd&nbsp; ;pushed old Child<br />&nbsp; &nbsp; m2m .LinkedNode.pLinkFwd,pnode ;link Parent forward to This<br />&nbsp; &nbsp; mov .LinkedNode.pLinkBack,eax&nbsp; &nbsp; ;link This back to Parent<br />&nbsp; &nbsp; pop eax<br />&nbsp; &nbsp; .if eax!=0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;If there was an old Child<br />&nbsp; &nbsp; &nbsp; &nbsp; mov .LinkedNode.pLinkBack,ebx&nbsp;  ;link old Child back to This<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; .if eax== .LinkedList.pLastNode&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;If the old Child was the Last Node<br />&nbsp; &nbsp; &nbsp; &nbsp; m2m&nbsp; .LinkedList.pLastNode, pnode&nbsp; &nbsp; &nbsp; ;make This the new Last Node<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; inc .LinkedList.NumNodes<br />.endif<br />ret<br />LinkedList_InsertAfter endp<br /><br />LinkedList_DeleteObject proc pObject<br />.if pObject==0<br />&nbsp; &nbsp; ret<br />.endif<br /><br />; Fetch the LinkedNode containing pObject<br />icall ecx, LinkedList, GetNodeByDataObject, pObject<br />.if eax==0<br />&nbsp; &nbsp; ret<br />.endif<br /><br />dec .LinkedList.NumNodes<br /><br />; If we are deleting First Node, make the Next node be First node<br />.if eax==.LinkedList.pFirstNode<br />&nbsp; &nbsp; m2m .LinkedList.pFirstNode, .LinkedNode.pLinkFwd<br />.endif<br /><br />; If we are deleting Current Node, make the Next node be Current node<br />.if eax==.LinkedList.pCurrentNode<br />&nbsp; &nbsp; m2m .LinkedList.pCurrentNode, .LinkedNode.pLinkFwd<br />.endif<br /><br />; If we are deleting Last Node, the Last node is NULL<br />.if eax==.LinkedList.pLastNode<br />&nbsp; &nbsp; mov .LinkedList.pLastNode,0<br />.endif<br /><br />; If This node had a Parent, patch the Parent&#39;s link<br />.if .LinkedNode.pLinkBack!=0 <br />&nbsp; &nbsp; mov ebx,&nbsp; .LinkedNode.pLinkBack<br />&nbsp; &nbsp; m2m .LinkedNode.pLinkFwd,&nbsp; .LinkedNode.pLinkFwd<br />.endif<br /><br />; If This node had a Child, patch the Child&#39;s link<br />.if .LinkedNode.pLinkFwd!=0<br />&nbsp; &nbsp; mov ebx, .LinkedNode.pLinkFwd<br />&nbsp; &nbsp; m2m .LinkedNode.pLinkBack,&nbsp; .LinkedNode.pLinkBack<br />.endif<br /><br />; Free pObject and its Node container<br />push eax<br />free pObject<br />pop eax<br />free eax<br /><br />ret<br />LinkedList_DeleteObject&nbsp; endp<br /><br /><br /></code></pre><br /></div>
    <div class="meta">Posted on 2005-04-12 23:50:38 by Homer</div>
   </div>
   <div class="post" id="post-158945">
    <div class="subject"><a href="#post-158945">Re: LinkedList Evolutions (ATC)</a></div>
    <div class="body">Nice work. I suggest adding forward and backward iterators. Take a look at the OA32 Collection object. <br />It is one of the most important objects!<br /><br /><pre><code>Object Collection, CollectionID, Streamable<br />? StaticMethod? ? ? Delete,? ? ? ? ?Pointer? ? ? ? ? ? ? ?;-&gt; Item<br />? StaticMethod? ? ? DeleteAt,? ? ? ?dword? ? ? ? ? ? ? ? ?;Index in range [0..Count-1]<br />? StaticMethod? ? ? DeleteAll<br />? DynamicMethod? ? ?DestroyItem,? ? Pointer? ? ? ? ? ? ? ?;Override for data structures<br />? StaticMethod? ? ? Dispose,? ? ? ? Pointer? ? ? ? ? ? ? ?;-&gt; Item<br />? StaticMethod? ? ? DisposeAt,? ? ? dword? ? ? ? ? ? ? ? ?;Index in range [0..Count-1]<br />? StaticMethod? ? ? DisposeAll<br />? RedefineMethod? ? Done<br />? StaticMethod? ? ? FirstThat,? ? ? Pointer, Pointer? ? ? ;-&gt; Proc, -&gt; Parameter<br />? StaticMethod? ? ? ForEach,? ? ? ? Pointer, Pointer? ? ? ;-&gt; Proc, -&gt;Parameter<br />? StaticMethod? ? ? ForEachRev,? ? ?Pointer, Pointer? ? ? ;ForEach in reverse order<br />? DynamicMethod? ? ?GetItem,? ? ? ? Pointer? ? ? ? ? ? ? ?;-&gt; Stream<br />? StaticMethod? ? ? IndexOf,? ? ? ? Pointer? ? ? ? ? ? ? ?;-&gt; Item<br />? RedefineMethod? ? Init,? ? ? ? ? ?Pointer, dword, dword, dword ;-&gt; Owner, Cnt, Inc, Lim<br />? StaticMethod? ? ? Insert,? ? ? ? ?Pointer? ? ? ? ? ? ? ?;-&gt; Item<br />? StaticMethod? ? ? InsertAt,? ? ? ?dword, Pointer? ? ? ? ;Index, -&gt; Item<br />? StaticMethod? ? ? ItemAt,? ? ? ? ?dword? ? ? ? ? ? ? ? ?;Index in range [0..Count-1]<br />? StaticMethod? ? ? LastThat,? ? ? ?Pointer, Pointer? ? ? ;-&gt; Proc, -&gt; Parameter<br />? RedefineMethod? ? Load,? ? ? ? ? ?Pointer, Pointer? ? ? ;-&gt; Stream, -&gt; Owner<br />? StaticMethod? ? ? PutAt,? ? ? ? ? dword, Pointer? ? ? ? ;Index, -&gt; Item<br />? DynamicMethod? ? ?PutItem,? ? ? ? Pointer, Pointer? ? ? ;-&gt; Stream, -&gt; Item<br />? PrivateMethod? ? ?SetLimit,? ? ? ?dword? ? ? ? ? ? ? ? ?;Sets new limit (internal method)<br />? StaticMethod? ? ? Shrink<br />? RedefineMethod? ? Store,? ? ? ? ? Pointer? ? ? ? ? ? ? ?;-&gt; Stream<br /><br />? DefineVariable? ? pItems,? ? ? ? ?Pointer,? ? NULL<br />? DefineVariable? ? dCount,? ? ? ? ?dword,? ? ? 0<br />? DefineVariable? ? dLimit,? ? ? ? ?dword,? ? ? 0<br />? DefineVariable? ? dDelta,? ? ? ? ?dword,? ? ? 0<br />? DefineVariable? ? dMaxSize,? ? ? ?dword,? ? ? 0<br />ObjectEnd</code></pre><br /><br />Regards,<br /><br />Biterider</div>
    <div class="meta">Posted on 2005-04-13 00:43:54 by Biterider</div>
   </div>
   <div class="post" id="post-158967">
    <div class="subject"><a href="#post-158967">Re: LinkedList Evolutions (ATC)</a></div>
    <div class="body">I respect that, I really do.<br />I reposted the code with such support methods.<br />The code hasn&#39;t been tested, but looked ok at a glance.<br />All existing methods were modified to support backpointers.<br />New methods were added which exploit backpointers.<br />I&#39;d call my GetNodeByDataObject a private method and let the users deal just with their own objects and not need to know about LinkedNodes.<br />I&#39;ve not needed to insert/delete arbitrarily for a while now, but anyways.. yes very, VERY useful to have an object list / array manager of some kind, and I&#39;ve been playing with plenty lately :)<br /><br />What&#39;s with the Limiting of the element count? Are you storing a flat array of pointers rather than linked nodes and thus are limited by hard page size?<br /><br /></div>
    <div class="meta">Posted on 2005-04-13 11:46:11 by Homer</div>
   </div>
   <div class="post" id="post-158981">
    <div class="subject"><a href="#post-158981">Re: LinkedList Evolutions (ATC)</a></div>
    <div class="body">Hi EvilHomer2k<br /><br />The use of iterators makes the live easier and depending on the specific problem to solve, a linked list can be faster than a Collection or not.<br /><br />The Collection approach uses the Borland strategy. Basically it is an expandable array of pointers that points to objects or memory structures. The Collection object handles it items as objects, that means that they are destroyed (the destructor is invoked and the object is freed from memory) when disposed. On the other side, the DataCollection handles it items as memory chunks. When they are disposed, they are simply removed from memory.<br /><br />The Collection object are initialized with some parameters that are specific for the pointer array; the initial size, the grow factor and the max size. Usually, the last parameter is set to a very big number (COLLECTIONMAXSIZE) that can never be reached, but you can set it to a specific number to keep things under control. If this limit is reached an error condition is triggered and passed to the owner of the collection to handle it. <br /><br />As said before, for some tasks, a linked list can be easier and faster than a collection but for a width use of it, iterators will be a nice thing. Considder to pass an auxiliary parameter to the iteration procedure!&nbsp; 8)<br /><br />Regards,<br /><br />Biterider<br /></div>
    <div class="meta">Posted on 2005-04-14 01:56:18 by Biterider</div>
   </div>
   <div class="post" id="post-159010">
    <div class="subject"><a href="#post-159010">Re: LinkedList Evolutions (ATC)</a></div>
    <div class="body">In my object base (\masm32\ultrano\bank\base.inc , provided with Ilix) , there are the ObjVector, HookVector and VarVector already, with iterations done easily:<br /><pre><code><br /><br />foreach FocusedWorkspace, invoke ShowWindow,EDX,SW_HIDE<br />(this one actually hides all windows, listed in the FocusedWorkspace vector)<br /><br />(some advanced)<br />	; delete all windows from pSrc, insert them in pDest<br />	foreach pSrcWorkspace,multi icall pSrcWorkspace,ObjVector,delete,EDX | icall 				pDest,ObjVector,insert,EDX<br /><br />	.ForEach pWorkspaces<br />		mov pCurWorkspace,EDX<br />		.if FindInObjVector(pCurWorkspace,hWnd)<br />			m2m pWorkspace,pCurWorkspace<br />		.endif<br />	.EndForEach pWorkspaces<br /><br />; show absolutely all windows<br />foreach pWorkspaces, multi mov CurWorkspace,edx | foreach CurWorkspace,invoke ShowWindow,edx, SW_SHOW<br /></code></pre><br /><br />Reminds me a bit of Perl&#39;s regular expressions, but at least it&#39;s readable once you know how to use these objects and macros. <br />The only &quot;bad&quot; thing about these is that they&#39;re thread-safe, which if you code a single-threaded app, is a few useless instructions in extra. But for multithreading it&#39;s perfect :)<br />If you&#39;re interested, I can send you the macros and objects (their latest version, two days ago)</div>
    <div class="meta">Posted on 2005-04-14 14:02:28 by Ultrano</div>
   </div>
   <div class="post" id="post-159101">
    <div class="subject"><a href="#post-159101">Re: LinkedList Evolutions (ATC)</a></div>
    <div class="body">Certainly interested in the macros.<br />Didn&#39;t that stuff use arrays of static pointers, Ultrano?<br />I like linkedlists because we don&#39;t need to decide on a page size, a number of pages, etc.<br /><br />Ultrano&#39;s SmallAlloc codebase used a system of linked page structs, converging both the speed of linear lookups with the flexibility of linkedlists.<br />It&#39;s limitation was that it has to allocate at least one page for each objecttype (in terms of struct size) - so it is potentially quite wasteful.<br /><br />Linear arrays don&#39;t cope well with arbitrary insertions and deletions, and searching for &quot;holes&quot; in arrays is messy.<br /><br />My LinkedList class provides the ability to create chains of objects which may not necessarily be the same object type - elements are naive pointers.<br />It&#39;s not a total solution to memory management by a long shot, but a useful &quot;utility&quot; class apon which more complex classes can be built.<br />At least that&#39;s how I use it..<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2005-04-17 06:22:40 by Homer</div>
   </div>
   <div class="post" id="post-159113">
    <div class="subject"><a href="#post-159113">Re: LinkedList Evolutions (ATC)</a></div>
    <div class="body">http://www.ultrano.com/ilix/UltraVector.zip<br /><br />base.lib contains all my global oop objects and helper functions<br />ultrabase.lib is just for compatibility when linking the above lib with a project that doesn&#39;t know what ATC is (asm or C/C++)<br />vectors.asm is just the source of the vectors - to see how they work. This code is already compiled and included in base.lib<br />base.inc - the only file I ever need to include when starting a new project<br />class.inc - the current ATC<br /><br />Vectors here take 1kB &quot;pages&quot;. <br />Assume we have 5 elements in a vector (element #0...4).<br />When we delete #2,&nbsp;  then #3 and #4 are shifted left to the beginning of the array. <br /><br />There is no universal approach to managing dynamic arrays of objects, when we take speed and extra-memory usage into account. Thus, the programmer needs to choose which existing approach to use, or create a specific one for his current needs. Here I just give another option - already existing and well-tested - to eventually save you time. <br />When managing objects in my multithreaded apps, my first choice is ObjVector. HookVector I already introduced some time ago - but just lately I&#39;ve started using it a lot - and it&#39;s literally saving me hundreds of lines of boring code, while maintaining app safety (because of the multithreading). <br /><br />SmallAlloc is definitely not wasteful when you use it the way it was meant to be used . Allocating strings and the like with it is a no-no, as I accented on in the readme.txt for it. <br /><br />But anyway, it&#39;s up to the programmer to choose what functions to use. </div>
    <div class="meta">Posted on 2005-04-17 11:43:39 by Ultrano</div>
   </div>
   <div class="post" id="post-159585">
    <div class="subject"><a href="#post-159585">Re: LinkedList Evolutions (ATC)</a></div>
    <div class="body">Regarding threadsafe arrays:<br /><br />I&#39;ve added a locking mechanism to LinkedList (it uses CriticalSection), but I&#39;ve implemented it using a compiletime switch so you can build with or without the locking mechanism.<br />This may or may not suit you depending on the implementation.<br /><br />Bah, who am I kidding? I&#39;ll be the only one to ever use this stuff :|<br /></div>
    <div class="meta">Posted on 2005-05-05 13:06:03 by Homer</div>
   </div>
   <div class="post" id="post-159588">
    <div class="subject"><a href="#post-159588">Re: LinkedList Evolutions (ATC)</a></div>
    <div class="body"><div class="quote"><br />Bah, who am I kidding? I&#39;ll be the only one to ever use this stuff :|<br /></div><br />Welcome to the club :| (though I&#39;ve said this a million times already). Today I remembered all my projects ended up like that - with me being the only user. Only ATC is an exception - with whole two users lol. Thus I&#39;m no longer eager to make that 3D engine for PC - I&#39;m much better off using my code alone and selling it, instead of trying to help others sell products that use my code. Then showing what can be done with asm can inspire coders here.. it&#39;s my only hope of helping/sharing now :/ . I think I managed to move some people with the &quot;Dreamer&quot; software. Perhaps if they see Dreamer2 that uses all code that I&#39;ve published here, I&#39;ll manage to contribute more... leading to the creation of more fast and great asm-coded apps. </div>
    <div class="meta">Posted on 2005-05-05 13:50:25 by Ultrano</div>
   </div>
   <div class="post" id="post-159589">
    <div class="subject"><a href="#post-159589">Re: LinkedList Evolutions (ATC)</a></div>
    <div class="body">Also, I&#39;m not sure - but since September 2004 till now there has been a major drop in the productivity of many many people, teams and companies. Maybe it&#39;s just that my expectations went high. <br />Gotten used to the all good and new content that came up often, when Sept. or Oct. came , it was as unpleasant for me as if I no longer had internet. </div>
    <div class="meta">Posted on 2005-05-05 14:10:06 by Ultrano</div>
   </div>
   <div class="post" id="post-159590">
    <div class="subject"><a href="#post-159590">Re: LinkedList Evolutions (ATC)</a></div>
    <div class="body">Ah, on the thread-safe matter: Why don&#39;t you use the following macros of mine for locking. I&#39;ve been using them for a lot of time now - they are both faster, safer and smaller (require only 2 bytes, not a whole criticalsection)<br /><pre><code><br />iTryLockObject macro<br />	local _again,_bad,_good <br />	_again:<br />	xor eax,eax<br />	cmp .isdead,0<br />	jne _bad<br />	mov al,1<br />	xchg .locked,al<br />	or al,al<br />	jz _good<br />	pushad<br />	invoke SwitchToThread	; may change it with &#39;Sleep,0&#39;<br />	popad<br />	jmp _again<br />&nbsp; _good:mov eax,1<br />&nbsp; _bad: <br />endm<br /><br /><br />iTryLockObjectFast macro	; 0 = object is DEAD&nbsp; <br />	local _bad		; 1 = WE locked the object , it&#39;s OK now to work with it&nbsp; &nbsp; &lt;=== use &quot;.if eax==1&quot;<br />	xor eax,eax		; 2 = the object is already locked by another proc<br />	cmp .isdead,0<br />	jne _bad<br />	mov al,1<br />	xchg .locked,al<br />	inc al<br />&nbsp;  _bad:<br />endm<br /><br />iUnlockObject macro<br />	push eax<br />	xor al,al<br />	xchg .locked,al<br />	pop eax<br />endm<br /><br />iKillObject macro<br />	push eax<br />	mov al,1<br />	xchg .isdead,al<br />	pop eax<br />endm<br /><br /><br /><br /><br /><br />iTryLockObject2 macro LockedElement:REQ<br />	local _again,_bad,_good <br />	_again:<br />	xor eax,eax<br />	cmp .isdead,0<br />	jne _bad<br />	mov al,1<br />	xchg .LockedElement,al<br />	or al,al<br />	jz _good<br />	pushad<br />	invoke SwitchToThread	; may change it with &#39;Sleep,0&#39;<br />	popad<br />	jmp _again<br />&nbsp; _good:mov eax,1<br />&nbsp; _bad: <br />endm<br /><br />iUnlockObject2 macro LockedElement:REQ<br />	push eax<br />	xor al,al<br />	xchg .LockedElement,al<br />	pop eax<br />endm<br /><br /></code></pre><br /><br />The code to use them is like:<br /><pre><code><br />myobj struct<br />&nbsp; isdead db ?<br />&nbsp; islocked db ?<br /> ;.... now put the struct members you want to lock here<br />myobj ends<br /><br /><br />assume ecx:ptr myobj<br />mov ecx,pSomeObject1<br />iTryLockObject<br />.if eax ; if this object is alive<br />&nbsp; &nbsp; ; do stuff with it<br />&nbsp; &nbsp; ;....<br /> <br />&nbsp; &nbsp; ; finally, unlock it<br />&nbsp; &nbsp; mov ecx,pSomeObject1<br />&nbsp; &nbsp; iUnlockObject<br />.endif<br /><br />assume ecx:nothing<br /><br /></code></pre><br /><br /><br /></div>
    <div class="meta">Posted on 2005-05-05 14:20:45 by Ultrano</div>
   </div>
   <div class="post" id="post-159669">
    <div class="subject"><a href="#post-159669">Re: LinkedList Evolutions (ATC)</a></div>
    <div class="body">Simple is an understatement.<br />That&#39;s cross-thread safe, but not cross-process safe.<br />Still, I like it :)<br /><br />Actually, I&#39;m just depressed that my favorite machine has self-destructed.<br />I&#39;m sitting here on a 333 looking at motherboard prices.<br />A dual would be nice :)</div>
    <div class="meta">Posted on 2005-05-06 09:22:34 by Homer</div>
   </div>
  </div>
 </body>
</html>