<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Dynamic Memory Allocation? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=22606" />
    <link rel="next" href="../?id=22606&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=22606">Dynamic Memory Allocation?</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=22606&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=22606&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="22606" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=22606&amp;page=2">&gt;</a><a href="../?id=22606&amp;page=2">&raquo;</a></form>   <div class="post" id="post-169563">
    <div class="subject"><a href="#post-169563">Dynamic Memory Allocation?</a></div>
    <div class="body">I am working on a project where I would like for the address where my numbers are stored to change each time the program is restarted. Here is my code:<br /><br /><pre><code><br />		invoke 	GlobalAlloc,GMEM_MOVEABLE or GMEM_ZEROINIT,MEMSIZE<br />		mov&nbsp; 	hMemory,eax<br />		invoke 	GlobalLock,hMemory<br />		mov&nbsp; 	pMemory,eax<br />		mov&nbsp; &nbsp;  pMemory,30<br /></code></pre><br /><br />All my allocations are setup fine but the actual address where the memory is located does not change when the program is restarted. I would like for this to happen. Any ideas?</div>
    <div class="meta">Posted on 2006-01-15 19:16:08 by resistance_is_futile</div>
   </div>
   <div class="post" id="post-169565">
    <div class="subject"><a href="#post-169565">Re: Dynamic Memory Allocation?</a></div>
    <div class="body">There&#39;s very high chance that the memory allocation will get the same addres (given the same allocation size) upon every application restart (well it&#39;s even relatively high upon every OS restart).<br /><br />1) if you allocate more than 1 chunks of mem (say 5-6), then just allocate them in different order every time you start your app. The chunks will have same addresses, but each time they&#39;re reatarted, will contain different data. (this is what Blizzard&#39;s Diablo 2 does)<br />2) allocate a bit more bites, then create a random number and store your data at the allocated chunk offset by the random number. Don&#39;t forget to Free the memory using the original pointer - not the offset one.<br />3) Highly fragment the memory then allocate required chunk. (Not recommended :P)</div>
    <div class="meta">Posted on 2006-01-15 19:35:15 by ti_mo_n</div>
   </div>
   <div class="post" id="post-169567">
    <div class="subject"><a href="#post-169567">Re: Dynamic Memory Allocation?</a></div>
    <div class="body">rif,<br /><br />With an old API like GlobalAlloc() it is advisable to use the FIXED flag as the rest of its capacity is effectively out of date. If what you want is a different address each start, the suggestion from ti_mo_n is a good one and all you need to do is use an API like GetTickCount() as a seed to alter the offset each time you start the app. I gather you are trying to defeat something like in memory patching and this will make it harder for them to access your program but try out another idea in conjunction with it, change the allocation order each time the app starts up for different memory blocks and it will make the address even harder to track.</div>
    <div class="meta">Posted on 2006-01-15 22:23:22 by hutch--</div>
   </div>
   <div class="post" id="post-169575">
    <div class="subject"><a href="#post-169575">Re: Dynamic Memory Allocation?</a></div>
    <div class="body">Okay this is what I have and it does not seem to be working..<br /><br /><pre><code><br /><br />		invoke 	GlobalAlloc,GMEM_FIXED,MEMSIZE	<br />		mov&nbsp; 	pMemory,eax						<br />		invoke	GlobalHandle,pMemory			<br />		mov		aMemory,eax						<br />		invoke	GetTickCount					<br />		add		aMemory,eax						<br />		invoke	GlobalLock,aMemory				<br />		mov		aMemory,eax						<br />		mov		aMemory,30						<br /></code></pre></div>
    <div class="meta">Posted on 2006-01-16 03:53:11 by resistance_is_futile</div>
   </div>
   <div class="post" id="post-169576">
    <div class="subject"><a href="#post-169576">Re: Dynamic Memory Allocation?</a></div>
    <div class="body">resistance, you don&#39;t need GlobalLock when you use the GMEM_FIXED flag to GlobalAlloc. But you might as well use HeapAlloc anyway, since that&#39;s what GlobalAlloc does internally.<br /><br />As for the usefulness of this, for somebody RE&#39;ing your app it would be trivial to find the allocation calls and fetch the pointers you&#39;re storing...&nbsp; resistance IS futile :)<br /></div>
    <div class="meta">Posted on 2006-01-16 04:31:14 by f0dder</div>
   </div>
   <div class="post" id="post-169578">
    <div class="subject"><a href="#post-169578">Re: Dynamic Memory Allocation?</a></div>
    <div class="body">I realize that the returned value is the pointer. I just read a few articles that convinced me lol. I know it would be easy to RE my program.. That is kind of the point of the program. However, I cannot discuss this here, thus leading to short code postings and program reference. Another method of RE&#39;ing my program is to simply use a debugger to re-write the programs actual instructions in memory. As said before, I would very much like to get this program working any help is much appreciated. I want to go with the random number via GetTickCount() but I do not know how to go about in changing the code to suit my needs.<br /><br /><br /></div>
    <div class="meta">Posted on 2006-01-16 04:58:36 by resistance_is_futile</div>
   </div>
   <div class="post" id="post-169582">
    <div class="subject"><a href="#post-169582">Re: Dynamic Memory Allocation?</a></div>
    <div class="body">Well, use HeapAlloc to allocate a block of memory + some_extra_amount. Store this (base) pointer (you&#39;ll need it when freeing the memory later). Next, call GetTickCount (or use RDTSC), mask by some value, and add that to the base pointer - store this pointer, this will be what you use for accessing the memory.<br /><br />Let&#39;s say you need to allocate 1024 bytes:<br /><br /><pre><code><br />MAGIC_VALUE equ 64				; just some size<br /><br />.data?<br />baseptr	DWORD ?<br />usedptr DWORD ?<br /><br />.code<br /><br />invoke	GetModuleHandle, 0<br />invoke	HeapAlloc, eax, 0, 1024 + MAGIC_VALUE<br />mov		, eax<br />mov		, eax<br /><br />rdtsc<br />and		eax, MAGIC_VALUE<br />add		, eax<br /></code></pre><br /><br />You use <strong>usedptr</strong> when referring to your memory, and <strong>baseptr</strong> when you need to free the memory again. <em>rdtsc</em> is better than GetTickCount since it&#39;s harder to break on (requires access to a control register etc.) - and I doubt you&#39;ll find anybody today running windows on less than a pentium.<br /></div>
    <div class="meta">Posted on 2006-01-16 07:32:25 by f0dder</div>
   </div>
   <div class="post" id="post-169584">
    <div class="subject"><a href="#post-169584">Re: Dynamic Memory Allocation?</a></div>
    <div class="body">resistance_is_futile,<br /><br />There is a trick that is a left over from hash tables and that is to set the numeric range of deviation you require as offset variation in your allocated buffer then feed the GetTickCount result to a modulo of the offset range. This means you have a fast and reasonably random way to alter the offset each time your app starts that is always within the range you set.<br /><br />This is the basic idea as a code snippet<br /><pre><code><br />&nbsp; &nbsp; xor edx, edx&nbsp; &nbsp; &nbsp; &nbsp; ; clear EDX<br />&nbsp; &nbsp; mov eax, tickcount&nbsp; ; GetTickCount result<br />&nbsp; &nbsp; div cnt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; offset count range<br />&nbsp; &nbsp; mov eax, edx&nbsp; &nbsp; &nbsp; &nbsp; ; copy remainder of division to EAX<br /></code></pre><br /><br />Just check the result as I grabbed this out of a hash table example I have without testing it in your context.<br /></div>
    <div class="meta">Posted on 2006-01-16 09:24:05 by hutch--</div>
   </div>
   <div class="post" id="post-169598">
    <div class="subject"><a href="#post-169598">Re: Dynamic Memory Allocation?</a></div>
    <div class="body"><pre><code><br />		invoke&nbsp; GetModuleHandle,0<br />		mov		,eax<br />		invoke	HeapAlloc, eax,HEAP_ZERO_MEMORY, 1024 + MAGIC_VALUE<br />		mov		, eax<br />		mov		, eax<br />		invoke	GetTickCount<br />		and		eax, MAGIC_VALUE<br />		add		, eax<br /></code></pre><br /><br />okay this returns an error<br /><br /><pre><code><br />		invoke&nbsp; GetProcessHeap<br />		mov		,eax<br />		invoke	HeapAlloc, eax,HEAP_ZERO_MEMORY, 1024 + MAGIC_VALUE<br />		mov		, eax<br />		mov		, eax<br />		invoke	GetTickCount<br />		and		eax, MAGIC_VALUE<br />		add		, eax<br /></code></pre><br /><br />This works fine but does not change the address of the value in the allocated block..<br /></div>
    <div class="meta">Posted on 2006-01-16 20:08:57 by resistance_is_futile</div>
   </div>
   <div class="post" id="post-169599">
    <div class="subject"><a href="#post-169599">Re: Dynamic Memory Allocation?</a></div>
    <div class="body">*cough* sorry, of course you need GetProcessHeap and not GetModuleHandle. Also, it should be &quot;and eax, MAGIC_VALUE-1&quot;, where MAGIC_VALUE must be a power of two - if you want non-powers-of-two, do a DIV and use the modulus (like the code hutch pasted).<br /><br />And really, rdtsc instead of GetTickCount. Just &quot;.586&quot; (or perhaps .586p if masm is picky) at the top of your code instead of the usual .386.<br /></div>
    <div class="meta">Posted on 2006-01-16 20:52:50 by f0dder</div>
   </div>
   <div class="post" id="post-169603">
    <div class="subject"><a href="#post-169603">Re: Dynamic Memory Allocation?</a></div>
    <div class="body">You will not change the offset this way as it is assemble time, not run time calculated.<br /><br />1024 + MAGIC_VALUE<br /><br />You need to calculate the &quot;MAGIC_VALUE&quot; at runtime then add it to the normal start address with ADD.<br /><br />The current method you are using will always be the same as its built into the executable file as a single value. (1024+offset).<br /><br />Here is a quick way to do what you are after. Its written in expanded form so its clear to understand.<br /><br /><span class="mono"><br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br />&nbsp; &nbsp; include \masm32\include\masm32rt.inc<br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br /><br />comment * -----------------------------------------------------<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Build this&nbsp; template with<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &quot;CONSOLE ASSEMBLE AND LINK&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; ----------------------------------------------------- *<br /><br />&nbsp; &nbsp; .code<br /><br />start:<br />&nbsp;  <br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br /><br />&nbsp; &nbsp; call main<br />&nbsp; &nbsp; inkey<br />&nbsp; &nbsp; exit<br /><br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br /><br />main proc<br /><br />&nbsp; &nbsp; LOCAL hMem&nbsp; :DWORD&nbsp; &nbsp; &nbsp; ; the original memory handle<br />&nbsp; &nbsp; LOCAL pMem&nbsp; :DWORD&nbsp; &nbsp; &nbsp; ; the offset to memory to use<br />&nbsp; &nbsp; LOCAL rang&nbsp; :DWORD&nbsp; &nbsp; &nbsp; ; integer range of additional offset<br />&nbsp; &nbsp; LOCAL tcnt&nbsp; :DWORD&nbsp; &nbsp; &nbsp; ; variable for GetTickCount<br /><br />&nbsp; &nbsp; mov rang, 65536&nbsp; &nbsp; &nbsp; &nbsp;  ; 64k offset range<br /><br />&nbsp; &nbsp; invoke GlobalAlloc,GMEM_FIXED,1024*1024&nbsp; &nbsp;  ; allocate 1 meg<br />&nbsp; &nbsp; mov hMem, eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; copy return address to a pointer<br /><br />&nbsp; &nbsp; invoke GetTickCount<br />&nbsp; &nbsp; mov tcnt, eax<br /><br />&nbsp; &nbsp; xor edx, edx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; clear EDX<br />&nbsp; &nbsp; mov eax, tcnt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; GetTickCount result<br />&nbsp; &nbsp; div rang&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; offset count range<br /><br />&nbsp; &nbsp; mov eax, hMem<br />&nbsp; &nbsp; add eax, edx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; add the remainder to the original memory address<br /><br />&nbsp; &nbsp; add eax, 7&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; align the data by 8 bytes<br />&nbsp; &nbsp; and eax, -8<br /><br />&nbsp; &nbsp; mov pMem, eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; unique offset each time its run.<br /><br />&nbsp; ; ****************<br />&nbsp; ; show the results<br />&nbsp; ; ****************<br />&nbsp; &nbsp; print str$(edx),&quot; added offset to memory&quot;,13,10<br />&nbsp; &nbsp; print str$(hMem),&quot; original memory address&quot;,13,10<br />&nbsp; &nbsp; print str$(pMem),&quot; altered memory address&quot;,13,10<br /><br />&nbsp; &nbsp; invoke GlobalFree,hMem&nbsp; ; free the original memory handle when finished<br /><br />&nbsp; &nbsp; ret<br /><br />main endp<br /><br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br /><br />end start<br /></span><br /><br />PS: Something I should have mentioned, instead of an offset in the range of 0 to 65535, you will get better results again by using a prime number just over or just under the range you require as you will always get a remainder that way.</div>
    <div class="meta">Posted on 2006-01-17 01:06:56 by hutch--</div>
   </div>
   <div class="post" id="post-169609">
    <div class="subject"><a href="#post-169609">Re: Dynamic Memory Allocation?</a></div>
    <div class="body"><div class="quote"><br />You will not change the offset this way as it is assemble time, not run time calculated.<br /></div><br />Sure he will, since a (AND bounded/masked) rdtsc value is added later on. You could argue, though, that using a different alloc size (not just a different add value) would be a good idea, since it makes it harder to do a heap walk and find right-sized blocks.<br /><br />Aligning the memory like hutch does is a good idea btw, to avoid performance penalties. Addresses won&#39;t be *just* as random, but should still be fine.<br /><br />Oh, and never make a &quot;RandomAlloc proc&quot; since this will give attackers a single point of attack - a macro would be better.<br /><br /></div>
    <div class="meta">Posted on 2006-01-17 02:44:34 by f0dder</div>
   </div>
   <div class="post" id="post-169610">
    <div class="subject"><a href="#post-169610">Re: Dynamic Memory Allocation?</a></div>
    <div class="body">okay well i tried a few things.. Rearranging code, etc. However, none of this code is giving me what I want. Here is the code and results:<br /><br /><pre><code><br />.386<br />.model flat,stdcall<br />option casemap:none<br /><br />include training.inc<br /><br />.code<br /><br />start:<br />	mov		rang, 65536<br />	<br />&nbsp; &nbsp; invoke	GlobalAlloc,GMEM_FIXED,1024*1024<br />&nbsp; &nbsp; mov		hMem,eax<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; invoke	GetTickCount<br />&nbsp; &nbsp; mov		tcnt,eax<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; xor		edx,edx<br />&nbsp; &nbsp; mov		eax,tcnt<br />&nbsp; &nbsp; div		rang<br />&nbsp; &nbsp; mov		eax,edx<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ; Here I tried something a little different and get the same result each time<br />&nbsp; &nbsp; ;mov		eax,hMem<br />&nbsp; &nbsp; mov		eax, <br />&nbsp; &nbsp; ;add		eax,edx<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; add		eax,7<br />&nbsp; &nbsp; and		eax,-8<br />&nbsp; &nbsp; mov		pMem,eax<br /><br />&nbsp; &nbsp; <br />	invoke GetModuleHandle,NULL<br />	mov&nbsp; &nbsp; hInstance,eax<br />	invoke GetCommandLine<br />	invoke InitCommonControls<br />	invoke WinMain,hInstance,NULL,CommandLine,SW_SHOWDEFAULT<br />	invoke ExitProcess,eax<br /></code></pre><br /><br />Now when the processes memory is searched for the value, I retrieve the same address each time.. This address would be 00403085. I want this address to change. I do not know if maybe there was a misunderstanding or what. All the numbers are generated fine and very random. But it seems that this is where it is going wrong:<br /><br /><pre><code><br />&nbsp; &nbsp; ; Here I tried something a little different and get the same result each time<br />&nbsp; &nbsp; ;mov		eax,hMem<br />&nbsp; &nbsp; mov		eax, <br />&nbsp; &nbsp; ;add		eax,edx<br /></code></pre><br /><br />The new address is not calculated and does not change. Really weird considering everything else works perfect. Any ideas guys?</div>
    <div class="meta">Posted on 2006-01-17 02:54:27 by resistance_is_futile</div>
   </div>
   <div class="post" id="post-169612">
    <div class="subject"><a href="#post-169612">Re: Dynamic Memory Allocation?</a></div>
    <div class="body">resistance_is_futile,<br /><br />I actually code that small example so you had a working method of changing a buffer offset each time the app started. Now while its not the only way to perform such a task, it does work correctly and I suggest that you should actually bother to put it into a file and build it to see that it does deliver different results each time it starts.<br /><br />Once you actually understand what is going on you can code whatever you like but you need to know enough about it first to do that.<br /><br /><span class="mono"><br />&nbsp; &nbsp; 1024 + MAGIC_VALUE<br /></span><br /><br />You may have read the wrong part of the posting, both values are added at assembly time and are inserted into the code as an immediate.</div>
    <div class="meta">Posted on 2006-01-17 03:31:03 by hutch--</div>
   </div>
   <div class="post" id="post-169613">
    <div class="subject"><a href="#post-169613">Re: Dynamic Memory Allocation?</a></div>
    <div class="body">Edit: Just got a hold of the latest macro file release...<br /><br />However, inkey is not working for some reason (wait_key issue?).<br /><br />Any I did try to compile your program before, but was a little behind on a macro file release. it compiled fine. So how exactly do i implement this method into my win32 program? I dont want to just show the results. I need to use the address to store a changing number.</div>
    <div class="meta">Posted on 2006-01-17 03:45:48 by resistance_is_futile</div>
   </div>
   <div class="post" id="post-169614">
    <div class="subject"><a href="#post-169614">Re: Dynamic Memory Allocation?</a></div>
    <div class="body"><strong>resistance</strong>, here&#39;s a fully working test app that shows how to do it with a MACRO for ease of use.<br /><br />RDTSC is used insted of GetTickCount to make breaking on the random-alloc a bit harder - this requires a pentium, but who runs windows on a 486 these days? :)<br /><br /><strong>EDIT:</strong> posted the code inline as well, it&#39;s small enough for that.<br /><br /><pre><code><br />.586<br />.model flat,stdcall<br />option casemap:none<br />option proc:private<br /><br />incAPI MACRO files:VARARG<br />	FOR file, &lt;files&gt;<br />		include		file&amp;.inc<br />		includelib	file&amp;.lib<br />	ENDM<br />ENDM<br /><br />CTEXT MACRO y:VARARG<br />	LOCAL sym<br /><br />	CONST segment<br />		IFIDNI &lt;y&gt;,&lt;&gt;<br />			sym db 0<br />		ELSE<br />			sym db y,0<br />		ENDIF<br />	CONST ends<br /><br />	EXITM &lt;OFFSET sym&gt;<br />ENDM<br /><br />include		&lt;windows.inc&gt;<br />incAPI		&lt;kernel32,user32&gt;<br /><br />ASSUME FS:NOTHING<br /><br />MAGIC_VALUE equ 13373				; the max displacement - doesn&#39;t have to be a power of 2<br /><br />RANDOMALLOC	MACRO size:REQ, baseptr:REQ, usedptr:REQ<br />	invoke	GetProcessHeap<br />	invoke	HeapAlloc, eax, 0, size + MAGIC_VALUE<br /><br />	mov		baseptr, eax<br />	mov		usedptr, eax<br /><br />	rdtsc						; get Time Stamp Counter in EDX:EAX - requires pentium<br />	mov		ecx, MAGIC_VALUE<br />	xor		edx, edx<br />	div		ecx<br />	add		usedptr, edx		; add the modulus/displacement<br />ENDM<br /><br />;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />; DATA? section<br />;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />.data?<br />	free_this_later		DWORD ?<br />	use_this_pointer	DWORD ?<br />	buf					BYTE 256 DUP (?)<br /><br />;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />; CODE section<br />;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />.code<br /><br />ENTRY32:<br />	RANDOMALLOC	1024, free_this_later, use_this_pointer<br />	; now you have a 1024-byte buffer accessible through &quot;use_this_pointer&quot;. once you&#39;re<br />	; done and want to free the memory, you free the base pointer - &quot;free_this_later&quot;.<br />		invoke	wsprintf, addr buf, CTEXT(&quot;Pointer: %d&quot;), use_this_pointer<br />	invoke	MessageBox, 0, addr buf, CTEXT(&quot;Check this out&quot;), MB_OK<br /><br />	; just for fun, fill the buffer<br />	mov		edi, use_this_pointer<br />	mov		ecx, 1024/4<br />	rep		stosd<br /><br />	; free the memory<br />	invoke	GetProcessHeap<br />	invoke	HeapFree, eax, 0, free_this_later<br /><br />	invoke	ExitProcess, 0<br /><br />END ENTRY32 <br /></code></pre><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1392" target="_blank">RandomAlloc.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-01-17 04:59:52 by f0dder</div>
   </div>
   <div class="post" id="post-169615">
    <div class="subject"><a href="#post-169615">Re: Dynamic Memory Allocation?</a></div>
    <div class="body">As I now know what you are trying to do, here is an example that shows you one way of doing it. This one uses the nrandom procedure from the masm32 library. I have commented out the &quot;inkey&quot; and it should build OK with your installation.<br /><br />Now what you need to do to get the swing of this is to pull your head <strong>OUT</strong> of a debugger at the moment and do a bit of simple software engineering first.<br /><br />It allocates 16384 DWORD slots in memory, fills them full of random junk in approximately addressing DWORD range then it generates a random location within that 16k range for your own variable to be placed. The reason for doing this is they will not find you variable with a simple search of the memory as it is already filled with junk. You can play with the fill range so it better matches the range in which your variable occurs.<br /><br /><span class="mono"><br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br />&nbsp; &nbsp; include \masm32\include\masm32rt.inc<br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br /><br />comment * -----------------------------------------------------<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Build this&nbsp; template with<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &quot;CONSOLE ASSEMBLE AND LINK&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; ----------------------------------------------------- *<br />&nbsp; &nbsp; .code<br />start:<br />&nbsp;  <br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br /><br />&nbsp; &nbsp; call main<br />&nbsp; &nbsp; ;;;; inkey<br />&nbsp; &nbsp; exit<br /><br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br /><br />main proc<br /><br />&nbsp; &nbsp; LOCAL hMem&nbsp; :DWORD&nbsp; &nbsp; &nbsp; ; the original memory handle<br />&nbsp; &nbsp; LOCAL pMem&nbsp; :DWORD&nbsp; &nbsp; &nbsp; ; the offset to memory to use<br /><br />&nbsp; ; *********************<br />&nbsp; ; allocate 16384 DWORDS<br />&nbsp; ; *********************<br />&nbsp; &nbsp; invoke GlobalAlloc,GMEM_FIXED,16384*4<br />&nbsp; &nbsp; mov hMem, eax<br /><br />&nbsp; &nbsp; invoke GetTickCount<br />&nbsp; &nbsp; invoke nseed, eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; seed the random generator<br /><br />&nbsp; &nbsp; push esi<br />&nbsp; &nbsp; push edi<br /><br />&nbsp; &nbsp; mov esi, 16384&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; loop this many times<br />&nbsp; &nbsp; mov edi, hMem&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; put buffer address in edi<br />&nbsp; ; *******************************<br />&nbsp; ; fill buffer full of random junk<br />&nbsp; ; *******************************<br />&nbsp; lpst:<br />&nbsp; &nbsp; invoke nrandom,1024*1024*4&nbsp; ; 4 meg range of random numbers<br />&nbsp; &nbsp; add eax, 1024*1024*4&nbsp; &nbsp; &nbsp; &nbsp; ; add 4 meg<br />&nbsp; &nbsp; mov , eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; write result to buffer<br />&nbsp; &nbsp; add edi, 4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; set next address in buffer<br />&nbsp; &nbsp; sub esi, 1<br />&nbsp; &nbsp; jnz lpst<br /><br />&nbsp; &nbsp; pop edi<br />&nbsp; &nbsp; pop esi<br /><br />&nbsp; ; ****************************************<br />&nbsp; ; create the location for your own address<br />&nbsp; ; ****************************************<br />&nbsp; &nbsp; invoke GetTickCount<br />&nbsp; &nbsp; invoke nseed, eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; reseed the random generator<br />&nbsp; &nbsp; invoke nrandom,16384&nbsp; &nbsp; &nbsp; &nbsp; ; range is 16384<br />&nbsp; &nbsp; lea eax, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; multiply by 4 for aligned location<br /><br />&nbsp; ; *********************************************<br />&nbsp; ; add the offset to the original memory address<br />&nbsp; ; *********************************************<br />&nbsp; &nbsp; mov edx, hMem<br />&nbsp; &nbsp; add edx, eax<br />&nbsp; &nbsp; mov pMem, edx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; &lt;&lt;&lt;&lt; This is the address to write your variable to<br /><br />&nbsp; ; *******************<br />&nbsp; ; display the results<br />&nbsp; ; *******************<br />&nbsp; &nbsp; print str$(hMem),&quot; original memory address&quot;,13,10<br />&nbsp; &nbsp; print str$(pMem),&quot; altered memory address&quot;,13,10<br /><br />&nbsp; &nbsp; invoke GlobalFree,hMem&nbsp; ; free the original memory handle when finished<br /><br />&nbsp; &nbsp; ret<br /><br />main endp<br /><br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br /><br />end start<br /></span></div>
    <div class="meta">Posted on 2006-01-17 07:29:37 by hutch--</div>
   </div>
   <div class="post" id="post-169616">
    <div class="subject"><a href="#post-169616">Re: Dynamic Memory Allocation?</a></div>
    <div class="body">The additional 16k-index buffer indirection buys you nothing, since you can still read the hmem and pmem values and use those directly...<br /><br />But whatever. <strong>resistance</strong>, choose what you want. I know which one I&#39;d choose personally :)<br /></div>
    <div class="meta">Posted on 2006-01-17 07:46:07 by f0dder</div>
   </div>
   <div class="post" id="post-169619">
    <div class="subject"><a href="#post-169619">Re: Dynamic Memory Allocation?</a></div>
    <div class="body">Usually what happens is if someone uses a particular idea, they don&#39;t lay it out in simplified form complete with commentary to show how its done. Filling the buffer just prevents scanning the buffer for the first non zero value and as it changes every time the app starts, there is no established pattern of memory usage.<br /><br />What you tend to do when you need to do something like this is use a very UNsimplified method. You certainly could lay the app out so that the two memory pointers were easy to find but its no big deal to make them much harder to find and track. The range of tricks are many but finally this type of random location of a variable is what he was after so I have tried to make the example simple enough to understand.<br /><br />We all know the theory that you can break anything if you take long enough and the best you can do is stretch the time spent in disassemblers, debuggers and the like to try and get the job done. If it takes long enough, you have succeeded.<br /><br />Regards,<br /><br />hutch at movsd dot com</div>
    <div class="meta">Posted on 2006-01-17 09:42:48 by hutch--</div>
   </div>
   <div class="post" id="post-169647">
    <div class="subject"><a href="#post-169647">Re: Dynamic Memory Allocation?</a></div>
    <div class="body"><div class="quote"><br /><strong>resistance</strong>, here&#39;s a fully working test app that shows how to do it with a MACRO for ease of use.<br /><br />RDTSC is used insted of GetTickCount to make breaking on the random-alloc a bit harder - this requires a pentium, but who runs windows on a 486 these days? :)<br /><br /><strong>EDIT:</strong> posted the code inline as well, it&#39;s small enough for that.<br /><br /><pre><code><br />.586<br />.model flat,stdcall<br />option casemap:none<br />option proc:private<br /><br />incAPI MACRO files:VARARG<br />	FOR file, &lt;files&gt;<br />		include		file&amp;.inc<br />		includelib	file&amp;.lib<br />	ENDM<br />ENDM<br /><br />CTEXT MACRO y:VARARG<br />	LOCAL sym<br /><br />	CONST segment<br />		IFIDNI &lt;y&gt;,&lt;&gt;<br />			sym db 0<br />		ELSE<br />			sym db y,0<br />		ENDIF<br />	CONST ends<br /><br />	EXITM &lt;OFFSET sym&gt;<br />ENDM<br /><br />include		&lt;windows.inc&gt;<br />incAPI		&lt;kernel32,user32&gt;<br /><br />ASSUME FS:NOTHING<br /><br />MAGIC_VALUE equ 13373				; the max displacement - doesn&#39;t have to be a power of 2<br /><br />RANDOMALLOC	MACRO size:REQ, baseptr:REQ, usedptr:REQ<br />	invoke	GetProcessHeap<br />	invoke	HeapAlloc, eax, 0, size + MAGIC_VALUE<br /><br />	mov		baseptr, eax<br />	mov		usedptr, eax<br /><br />	rdtsc						; get Time Stamp Counter in EDX:EAX - requires pentium<br />	mov		ecx, MAGIC_VALUE<br />	xor		edx, edx<br />	div		ecx<br />	add		usedptr, edx		; add the modulus/displacement<br />ENDM<br /><br />;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />; DATA? section<br />;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />.data?<br />	free_this_later		DWORD ?<br />	use_this_pointer	DWORD ?<br />	buf					BYTE 256 DUP (?)<br /><br />;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />; CODE section<br />;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />.code<br /><br />ENTRY32:<br />	RANDOMALLOC	1024, free_this_later, use_this_pointer<br />	; now you have a 1024-byte buffer accessible through &quot;use_this_pointer&quot;. once you&#39;re<br />	; done and want to free the memory, you free the base pointer - &quot;free_this_later&quot;.<br />		invoke	wsprintf, addr buf, CTEXT(&quot;Pointer: %d&quot;), use_this_pointer<br />	invoke	MessageBox, 0, addr buf, CTEXT(&quot;Check this out&quot;), MB_OK<br /><br />	; just for fun, fill the buffer<br />	mov		edi, use_this_pointer<br />	mov		ecx, 1024/4<br />	rep		stosd<br /><br />	; free the memory<br />	invoke	GetProcessHeap<br />	invoke	HeapFree, eax, 0, free_this_later<br /><br />	invoke	ExitProcess, 0<br /><br />END ENTRY32 <br /></code></pre><br /><br /></div><br /><br />okay now what about setting the value at the address to 30 (which is like 1E in hex) and increasing it by one<br />after a certain action like lets say a button is pushed? wouldn&#39;t it be something like this:<br /><br /><pre><code><br />mov , 1Eh<br /><br />then..<br /><br />.if wParam == 1001<br />&nbsp;  inc <br />.endif<br /></code></pre><br /><br />right? Just checking before I go jumping into it</div>
    <div class="meta">Posted on 2006-01-18 01:53:22 by resistance_is_futile</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=22606&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=22606&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="22606" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=22606&amp;page=2">&gt;</a><a href="../?id=22606&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>