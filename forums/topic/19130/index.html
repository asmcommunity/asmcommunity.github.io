<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Heaps of problems - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19130" />
    <link rel="next" href="../?id=19130&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=19130">Heaps of problems</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=19130&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=19130&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="19130" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=19130&amp;page=2">&gt;</a><a href="../?id=19130&amp;page=2">&raquo;</a></form>   <div class="post" id="post-147895">
    <div class="subject"><a href="#post-147895">Heaps of problems</a></div>
    <div class="body">The color counting scheme I am currently using is way too slow for large images so I came up with a new way to do it.<br /><br />1: Create an array of 256 DWORDs and fill with 0<br />2: Each time a color is processed use the low order byte to index the secondary array<br />3: If no secondary array is found allocate one on the heap, consisting of the second byte + pointer to tertiary array<br />3a: Create a tertiary array and put in the color + count (1)<br />4: If the secondary array is found then scan it for the second byte<br />5: If the second byte is not found then add a new tertiary array and put in the color + count (1)<br />6: If the secondary array is found then scan the tertiary for our color<br />7: If it's found then increment the global count, the color count and return<br />8: If not found then add the color to the tertiary array<br /><br />Problem is that I can't get it working. It will work fine for a while then just stop. I have allocated the heap as follows:<br /><br />invoke HeapCreate,0,0,0<br /><br />Do I have to make it moveable ? Is there something else I am doing wrong here ?<br /><br />Sorry about the length of the code...<br /><pre><code>SearchTable FRAME hColorHeap,pArray,color,pCount<br />	uses edi,esi,ebx<br />	LOCAL tv	&#58;D<br />	; Get the red color<br />	movzx ebx,B&#91;color&#93;<br />	mov esi,&#91;color&#93;<br />	mov edi,&#91;pArray&#93;<br /><br />	; Get the offset to the appropriate node<br />	mov eax,&#91;edi+ebx*4&#93;<br />	or eax,eax<br />	jz &gt;&gt;.NEW_NODE<br />		; Scan the second level table for our index<br />		mov edi,eax<br />		invoke HeapSize,&#91;hColorHeap&#93;,NULL,edi<br />		mov ebx,eax<br />		movzx edx,W&#91;color&#93;<br />		shr edx,8<br />		xor eax,eax<br />		L0&#58;<br />			mov ecx,&#91;edi+eax&#93; ; &#91;color=red&#93;&#91;b&#93;&lt; EXCEPTION HERE&#91;/b&#93;&#91;/color&#93;<br />			cmp ecx,edx<br />			je &gt;&gt;.NODE_FOUND<br />			add eax,8<br />			cmp eax,ebx<br />			jl &lt;L0<br /><br />	.NODE_NOT_FOUND<br />		; There is no existing node for the color<br />		mov eax,ebx<br />		add eax,8<br />		invoke HeapReAlloc,&#91;hColorHeap&#93;,HEAP_ZERO_MEMORY,edi,eax<br />		or eax,eax<br />		jnz &gt;L1<br />			PrintError<br />			PrintText&#40;&quot;Why is this zero&quot;&#41;<br />		L1&#58;<br />		mov edi,eax<br />		mov ecx,&#91;pArray&#93;<br />		movzx edx,B&#91;color&#93;<br />		mov &#91;ecx+edx*4&#93;,edi<br /><br />		; move the index into the array<br />		mov &#91;edi+ebx&#93;,edx ;;;;;<br /><br />		; add the first item<br />		invoke HeapAlloc,&#91;hColorHeap&#93;,HEAP_ZERO_MEMORY,8<br />		; move the address of the first entry into the node<br />		mov D&#91;edi+ebx+4&#93;,eax<br /><br />		; Set the item<br />		mov &#91;eax&#93;,esi<br />		mov D&#91;eax+4&#93;,1<br /><br />		mov eax,&#91;pCount&#93;<br />		or eax,eax<br />		jz &gt;L2<br />			inc D&#91;eax&#93;<br />		L2&#58;<br />		mov eax,1<br />		ret<br /><br />	.NODE_FOUND<br />		/*<br />		We have found the second byte of the color in the<br />		master list. We now have to see if our color is in<br />		the list.<br />		On entry the color list base address is found at &#91;edi+eax+4&#93;<br />		*/<br />		<br />		; First we have to find out how many colors are in the array<br />		mov &#91;tv&#93;,edi<br />		mov edi,&#91;edi+eax+4&#93;<br />		invoke HeapSize,&#91;hColorHeap&#93;,NULL,edi<br />		mov ebx,eax<br />		; Scan the node for our color<br />		L3&#58;<br />			mov ecx,&#91;edi+eax&#93;<br />			cmp ecx,esi<br />			je &gt;&gt;.FOUND<br />			add eax,8<br />			cmp eax,ebx<br />			jl &lt;L3<br /><br />		; The color wasn't found so expand the node and add it<br />		lea eax,&#91;ebx+8&#93;<br />		invoke HeapReAlloc,&#91;hColorHeap&#93;,HEAP_ZERO_MEMORY,edi,eax<br />		mov edi,eax<br /><br />		; Update the node array with the new address<br />		mov ecx,&#91;tv&#93;<br />		mov &#91;ecx+4&#93;,edi<br /><br />		; Add the new color<br />		mov &#91;edi+ebx&#93;,esi<br />		mov D&#91;edi+ebx+4&#93;,1<br /><br />		; increment the count if necessary<br />		mov eax,&#91;pCount&#93;<br />		or eax,eax<br />		jz &gt;L4<br />			inc D&#91;eax&#93;<br />		L4&#58;<br />		mov eax,1<br />		ret<br /><br /><br />	.NEW_NODE<br />		/*<br />		ADD NEW NODE<br />		on entry &#91;edi+ebx*4&#93; points to this base <br />		Allocate 8 bytes for the new node<br />		&#91;Node&#93; = second byte of color<br />		&#91;Node+4&#93; = Address of 3rd level array<br />		*/<br /><br />		; Allocate a node<br />		invoke HeapAlloc,&#91;hColorHeap&#93;,HEAP_ZERO_MEMORY,8<br />		mov &#91;edi+ebx*4&#93;,eax<br /><br />		; Point EDI to our new node<br />		mov edi,eax<br /><br />		; Add our first item<br />		; Store the second byte of the color in the first DWORD<br />		movzx eax,W&#91;color&#93;<br />		shr eax,8<br />		mov &#91;edi&#93;,eax<br /><br />		; Create a color value list<br />		invoke HeapAlloc,&#91;hColorHeap&#93;,HEAP_ZERO_MEMORY,8<br />		; Store the address of the list in the second DWORD<br />		mov &#91;edi+4&#93;,eax<br /><br />		; Fill in the color information<br />		mov ecx,&#91;color&#93;<br />		mov &#91;eax&#93;,ecx<br />		<br />		; Set the initial count to 1<br />		mov D&#91;eax+4&#93;,1<br /><br />		; If not a NULL pointer, increment the totals count<br />		mov eax,&#91;pCount&#93;<br />		or eax,eax<br />		jz &gt;L5<br />			inc D&#91;eax&#93;<br />		L5&#58;<br />		mov eax,1<br />		ret<br /><br />	.FOUND<br />		; edi+eax contains the pointer to the node item<br />		mov edx,&#91;edi+eax+4&#93;<br />		inc edx<br />		mov &#91;edi+eax+4&#93;,edx<br />		mov eax,edx<br />		ret<br /><br />ENDF</code></pre><br /><div class="quote">=========================================<br />Exception code: EXCEPTION_ACCESS_VIOLATION<br />Instruction pointer: 00401831h<br /><br />eax=00001060 ebx=00001060 ecx=00020208 edx=01250000 esi=00D6E4F7<br />edi=01252FA0 ebp=0022F4FC esp=0022F4F8 eip=00401831<br />CS=001B DS=0023 SS=0023 ES=0023 FS=0038 GS=0000  O D i S Z A p C<br />----------------------------------------------------------------</div></div>
    <div class="meta">Posted on 2004-08-11 12:12:57 by donkey</div>
   </div>
   <div class="post" id="post-147897">
    <div class="subject"><a href="#post-147897">Heaps of problems</a></div>
    <div class="body">How about using a two-level hierarchy? Either a 256 pointers to 64k-dword arrays, or 64k pointers to 256b-dword arrays?<br /><br />Or perhaps use a hash table? You wouldn't have to use linked lists per hash entry, as you know the max indexes you'll ever get (2^24) - although allocating the hash index arrays should of course be done dynamically, otherwise you might as well do a 64meg table for color counting :)</div>
    <div class="meta">Posted on 2004-08-11 13:03:16 by f0dder</div>
   </div>
   <div class="post" id="post-147899">
    <div class="subject"><a href="#post-147899">Heaps of problems</a></div>
    <div class="body">Hi f0dder,<br /><br />The problem is to try to get some better speed than from the brute force type approach. I have a single level right now but if you consider a 1000*1000 image (not unreasonable) it contains 1 Million of pixels. That's 1 million searches, in a photo there are generally 10,000 to 100,000 unique colors, worst case could be billions of compares. The Griffon helicopter photo takes approx 1/2 to process with a single level search, and it rises exponentially until you hit around 5 sec for a 1280*1024. That was the reason for the new algoritm, creating huge (64K) static arrays is out of the question, an average photo would be in the mulitmegabytes, I originally tried a linked list but it GPF'ed quicker than this method. I keep getting problems with the HeapReAlloc function, it will work fine for 700-800 colors then return 0.</div>
    <div class="meta">Posted on 2004-08-11 13:21:23 by donkey</div>
   </div>
   <div class="post" id="post-147906">
    <div class="subject"><a href="#post-147906">Heaps of problems</a></div>
    <div class="body">I assume by &quot;searching for color&quot; you mean searching an entire linked list... yep, this would be slow.<br /><br />Now, the max memory you would use for counting colors would be (2^24)*4 = 64meg - this is too much, I agree.<br /><br />Using a 64k entry table would require 256kb for the main table, and 256 bytes for each additional table (up to 256kb + 64meg if you're really unlucky about the color distribution).<br /><br />Btw it might be beneficial to convert the RGB data to some other color model - I might be wrong about this, but I think the RGB values generally vary a lot, whereas if you convert to some &quot;light level&quot; based scheme, it will probably be easier to index.<br /><br />Can you post a jpg or png of the helicopter? I'd like to play a bit :) -  btw, what's your system specs?</div>
    <div class="meta">Posted on 2004-08-11 13:50:57 by f0dder</div>
   </div>
   <div class="post" id="post-147908">
    <div class="subject"><a href="#post-147908">Heaps of problems</a></div>
    <div class="body">System specs are 512MB memory, 134MB used, PIII 650 mobile.<br /><br />BTW here is the semi-brute force method,it works fine (or appears to) but is slow, by slow I mean a 961 x 637 image with 128377 unique colors takes 2 seconds to count. The griffon (helicopter) image is 1.75 MB zipped so it's a bit too much to post and it is pretty much moot unless you have the exact same image I have.<br /><pre><code>SearchTable FRAME hHeap,pArray,color,pCount<br />	uses edi,esi,ebx<br /><br />	; pArray points to an array of 256 QWORDS<br /><br />	mov ebx,&#91;color&#93;<br />	mov esi,ebx<br />	and ebx,0ffh<br />	mov edi,&#91;pArray&#93;<br /><br />	mov eax,&#91;edi+ebx*8&#93;<br />	or eax,eax<br />	jz &gt;&gt;.NEWNODE<br />		; scan for our color<br />		mov ebx,&#91;edi+ebx*8+4&#93;<br />		shl ebx,3<br />		mov edi,eax<br />		mov eax,ebx<br />		sub eax,8<br />		&#58;<br />			mov ecx,&#91;edi+eax&#93;<br />			cmp ecx,esi<br />			je &gt;&gt;.FOUND<br />			sub eax,8<br />			jns &lt;<br /><br />	.NEWCOLOR<br />		mov eax,ebx<br />		add eax,8<br />		invoke HeapReAlloc,&#91;hHeap&#93;,0,edi,eax<br /><br />		; add the color<br />		mov &#91;eax+ebx&#93;,esi<br />		mov D&#91;eax+ebx+4&#93;,1<br /><br />		; update the pointer in the master list<br />		mov ecx,esi<br />		and ecx,0ffh<br />		mov edi,&#91;pArray&#93;<br />		mov &#91;edi+ecx*8&#93;,eax<br />		inc D&#91;edi+ecx*8+4&#93;<br /><br />		mov eax,&#91;pCount&#93;<br />		or eax,eax<br />		jz &gt;<br />			inc D&#91;eax&#93;<br />		&#58;<br />		mov eax,1<br />		ret<br /><br />	.NEWNODE<br />		invoke HeapAlloc,&#91;hHeap&#93;,0,8<br />		mov &#91;edi+ebx*8&#93;,eax<br />		mov D&#91;edi+ebx*8+4&#93;,1<br /><br />		mov &#91;eax&#93;,esi<br />		mov D&#91;eax+4&#93;,1<br /><br />		mov eax,&#91;pCount&#93;<br />		or eax,eax<br />		jz &gt;<br />			inc D&#91;eax&#93;<br />		&#58;<br />		mov eax,1<br />		ret<br /><br />	.FOUND<br />		inc D&#91;edi+eax+4&#93;<br />		mov eax,&#91;edi+eax+4&#93;<br />		ret<br /><br />ENDF</code></pre></div>
    <div class="meta">Posted on 2004-08-11 14:18:56 by donkey</div>
   </div>
   <div class="post" id="post-147911">
    <div class="subject"><a href="#post-147911">Heaps of problems</a></div>
    <div class="body">I'm playing around a bit now. My &quot;2-level idea&quot; certainly sucks, all of R,G,B are too spread so they're not suitable as index values. Might help using a different color model, but haven't tested.<br /><br />A C++ std::map structure didn't really speed up stuff - doesn't seem worse either, though. So perhaps a dedicated tree structure would be a bit better than the bruteforce two-level approach.<br /><br />Going to test a hash table approach shortly...</div>
    <div class="meta">Posted on 2004-08-11 15:24:48 by f0dder</div>
   </div>
   <div class="post" id="post-147916">
    <div class="subject"><a href="#post-147916">Heaps of problems</a></div>
    <div class="body">Just allocate 64MB. :)<br /><br />@@:<br />mov eax, <br />add esi, 4<br />inc <br />dec ecx<br />jne @B<br /><br />(Unroll the loop maybe?)<br />Then post process that array for a list of colors/counts.</div>
    <div class="meta">Posted on 2004-08-11 16:00:24 by bitRAKE</div>
   </div>
   <div class="post" id="post-147917">
    <div class="subject"><a href="#post-147917">Heaps of problems</a></div>
    <div class="body">:grin: Thanks bitRAKE, but I think a 64MB buffer is a bit much<br /><br />Thanks f0dder, I wouldn't be too bothered normally, for TBPaint the semi-brute force algo can count an image strip in worst case 0.02 seconds so for my purposes it was and still is fine. But I want it in my graphics.lib and I'm not satisfied with the performance on photo quality images. This would not be too bad but it is used for several functions, calculating the best color table for an image when reducing the color count, reordering the color table, the histogram function, and the color count itself. So it is a fairly critical function and speed is important when it's in the lib. For now I am going to put in the brute force algorithm as I essentially only have until Saturday morning and then I'll be gone, I want to get this lib useful before that.</div>
    <div class="meta">Posted on 2004-08-11 16:15:37 by donkey</div>
   </div>
   <div class="post" id="post-147919">
    <div class="subject"><a href="#post-147919">Heaps of problems</a></div>
    <div class="body">Donkey,<br /><br />This thread got me to thinking about color counting and I have an idea that I'm playing with right now.  Let me see how it turns out before really go into any depth on it.  But basically, it is a 2d array (for red, green) and a 256 byte allocation for the blues on each of these (assuming one blue is found for this reg-green pair).<br /><br />Once again, let me play with it more.  But I think it'll be fast enough for ya.  I'll provide a C function that I'm doing my testing and also use the vc++ toolkit and provide you with an ASM output if this works out well.<br /><br />I'll get back with ya on this soon.<br /><br />Relvinian</div>
    <div class="meta">Posted on 2004-08-11 16:38:00 by Relvinian</div>
   </div>
   <div class="post" id="post-147920">
    <div class="subject"><a href="#post-147920">Heaps of problems</a></div>
    <div class="body">Hi  Relvinian,<br /><br />Sounds good, sort of a modified version of mine but with a static size at the end. I would have to see how big the array could grow in a real image though. I need to be able to extract the following information...<br /><br />1: The total number of colors<br />2: The number of instances the first BYTE appears<br />3: A complete list of unique colors with their individual counts<br /><br />Big order but it has to be capable of doing all the things that the brute force algo does as it is a worker function called by alot of other functions. #2 is optional as there are alot of very fast ways to do that.</div>
    <div class="meta">Posted on 2004-08-11 16:48:54 by donkey</div>
   </div>
   <div class="post" id="post-147922">
    <div class="subject"><a href="#post-147922">Heaps of problems</a></div>
    <div class="body"><div class="quote"><br />Hi  Relvinian,<br /><br />Sounds good, sort of a modified version of mine but with a static size at the end. I would have to see how big the array could grow in a real image though. I need to be able to extract the following information...<br /><br />1: The total number of colors<br />2: The number of instances the first BYTE appears<br />3: A complete list of unique colors with their individual counts<br /><br />Big order but it has to be capable of doing all the things that the brute force algo does as it is a worker function called by alot of other functions. #2 is optional as there are alot of very fast ways to do that. </div><br /><br />Donkey,<br /><br />Well this is the source file in C.  It is pretty fast.   It'll return the number of colors and can be easily adapted for item #3.  Option #2 would be a little bit of extra work but still doable.<br /><br />Anyway, here is the code.  The pImageData param assumes the raw pixel data in 32-bit format.  CX, CY are the width and height of the image to process.    Let me know how this function works for your tests.<br /><br />If you want the ASM version, let me know and I'll post it.<br /><br /><pre><code><br />int CountColors&#40;LPVOID pImageData, const int CX, const int CY&#41;<br />&#123;<br />	BYTE*		Array&#91;256&#93;&#91;256&#93; = &#123;0&#125;;<br />	DWORD*	pColor;<br /><br />	int x, y, i;<br />	int nCount;<br /><br />	// start with the first pixel<br />	pColor = &#40;DWORD*&#41;pImageData;<br /><br />	// Step through each of the scan lines of the image<br />	for &#40;y = 0; y &lt; CY; ++y&#41;<br />	&#123;<br />		for &#40;x = 0; x &lt; CX; ++x, ++pColor&#41;<br />		&#123;<br />			BYTE Red, Green, Blue;<br />			BYTE* pBlueArray;<br /><br />			// get the 'r' value from the pixel<br />			Red = &#40;BYTE&#41;&#40;*pColor &gt;&gt; 16&#41;;<br /><br />			// get the 'g' value from the pixel<br />			Green = &#40;BYTE&#41;&#40;*pColor &gt;&gt; 8&#41;;<br /><br />			// get the 'b' value from the pixel<br />			Blue = &#40;BYTE&#41;&#40;*pColor&#41;;<br /><br />			// see if we have already allocated an array of Blue bytes<br />			if &#40;Array&#91;Red&#93;&#91;Green&#93; == NULL&#41;<br />				Array&#91;Red&#93;&#91;Green&#93; = &#40;BYTE*&#41;HeapAlloc&#40;GetProcessHeap&#40;&#41;, HEAP_ZERO_MEMORY, 256&#41;;<br /><br />			// set the blue byte indicator to true<br />			pBlueArray = Array&#91;Red&#93;&#91;Green&#93;;<br />			pBlueArray&#91;Blue&#93; = TRUE;<br />		&#125;<br />	&#125;<br /><br />	// now that we have the colors marked, we need to count the flags set<br />	nCount = 0;<br />	for &#40;x = 0; x &lt; 256; ++x&#41;<br />	&#123;<br />		for &#40;y = 0; y &lt; 256; ++y&#41;<br />		&#123;<br />			if &#40;Array&#91;x&#93;&#91;y&#93;&#41;<br />			&#123;<br />				// some blues are marked, walk the count and add up<br />				BYTE* pBlues = Array&#91;x&#93;&#91;y&#93;;<br />				for &#40;i = 0; i &lt; 256; ++i&#41;<br />				&#123;<br />					if &#40;pBlues&#91;i&#93;&#41;<br />						++nCount;<br />				&#125;<br /><br />				// free allocation<br />				HeapFree&#40;GetProcessHeap&#40;&#41;, 0, pBlues&#41;;<br />			&#125;<br />		&#125;<br />	&#125;<br /><br />	return nCount;<br />&#125;<br /></code></pre><br /><br />Relvinian</div>
    <div class="meta">Posted on 2004-08-11 17:47:54 by Relvinian</div>
   </div>
   <div class="post" id="post-147923">
    <div class="subject"><a href="#post-147923">Heaps of problems</a></div>
    <div class="body">Hi Relvinian,<br /><br />Yes the ASM version would be great, I'm extremely lame at any language but ASM, can't even figure out the C compiler by myself. Option 2 is not at all important, it was used in the histogram function but I have thought of a better histogram algorithm and already implemented it, it is faster than can be done with any type of color counter, it scans huge images in the blink of an eye. My needs are now just total colors and instances per RGB color.</div>
    <div class="meta">Posted on 2004-08-11 17:56:51 by donkey</div>
   </div>
   <div class="post" id="post-147924">
    <div class="subject"><a href="#post-147924">Heaps of problems</a></div>
    <div class="body"><div class="quote"><br />Hi Relvinian,<br /><br />Yes the ASM version would be great, I'm extremely lame at any language but ASM, can't even figure out the C compiler by myself. Option 2 is not at all important, it was used in the histogram function but I have thought of a better histogram algorithm and already implemented it, it is faster than can be done with any type of color counter, it scans huge images in the blink of an eye. My needs are now just total colors and instances per RGB color. </div><br /><br />Here's the RAW asm file from that C function.  I'll let you convert it to GoAsm format.  :)  If you want me to put it into Masm format with a epilogue and prologue code, let me know.  Also, the array is on the stack and may want to be moved to the heap.<br /><br />Anyway, let me know if you want to me &quot;polish&quot; it up!<br /><br /><pre><code><br />_TEXT	SEGMENT<br />tv508 = -262152						; size = 4<br />tv172 = -262152						; size = 4<br />tv213 = -262148						; size = 4<br />_Array$ = -262144					; size = 262144<br />_pImageData$ = 8					; size = 4<br />_CX$ = 12						; size = 4<br />_CY$ = 16						; size = 4<br />_CountColors@12 PROC NEAR				; COMDAT<br />; File d&#58;source	estjunk.c<br />	push	ebp<br />	mov	ebp, esp<br />	and	esp, -8					; fffffff8H<br />	mov	eax, 262156				; 0004000cH<br />	call	__chkstk<br />	push	ebx<br />	push	esi<br />	push	edi<br />	xor	eax, eax<br />	mov	ecx, 65535				; 0000ffffH<br />	lea	edi, DWORD PTR _Array$&#91;esp+262172&#93;<br />	mov	DWORD PTR _Array$&#91;esp+262168&#93;, 0<br />	rep stosd<br />	mov	eax, DWORD PTR _CY$&#91;ebp&#93;<br />	test	eax, eax<br />	mov	edi, DWORD PTR _pImageData$&#91;ebp&#93;<br />	jle	SHORT $L74058<br />	mov	DWORD PTR tv172&#91;esp+262168&#93;, eax<br />$L74056&#58;<br />	mov	eax, DWORD PTR _CX$&#91;ebp&#93;<br />	test	eax, eax<br />	jle	SHORT $L74057<br />	mov	DWORD PTR tv213&#91;esp+262168&#93;, eax<br />$L74059&#58;<br />	mov	ecx, DWORD PTR &#91;edi&#93;<br />	mov	bl, BYTE PTR &#91;edi&#93;<br />	mov	eax, ecx<br />	shr	eax, 16					; 00000010H<br />	shr	ecx, 8<br />	movzx	esi, al<br />	shl	esi, 8<br />	movzx	eax, cl<br />	add	esi, eax<br />	cmp	DWORD PTR _Array$&#91;esp+esi*4+262168&#93;, 0<br />	lea	esi, DWORD PTR _Array$&#91;esp+esi*4+262168&#93;<br />	jne	SHORT $L74070<br />	push	256					; 00000100H<br />	push	8<br />	call	DWORD PTR __imp__GetProcessHeap@0<br />	push	eax<br />	call	DWORD PTR __imp__HeapAlloc@12<br />	mov	DWORD PTR &#91;esi&#93;, eax<br />$L74070&#58;<br />	mov	edx, DWORD PTR &#91;esi&#93;<br />	movzx	ecx, bl<br />	add	edi, 4<br />	sub	DWORD PTR tv213&#91;esp+262168&#93;, 1<br />	mov	BYTE PTR &#91;ecx+edx&#93;, 1<br />	jne	SHORT $L74059<br />$L74057&#58;<br />	sub	DWORD PTR tv172&#91;esp+262168&#93;, 1<br />	jne	SHORT $L74056<br />$L74058&#58;<br />	xor	esi, esi<br />	lea	eax, DWORD PTR _Array$&#91;esp+262168&#93;<br />	mov	DWORD PTR tv508&#91;esp+262168&#93;, 256	; 00000100H<br />$L74072&#58;<br />	mov	edi, eax<br />	mov	ebx, 256				; 00000100H<br />$L74075&#58;<br />	mov	edx, DWORD PTR &#91;edi&#93;<br />	test	edx, edx<br />	je	SHORT $L74076<br />	lea	eax, DWORD PTR &#91;edx+1&#93;<br />	mov	ecx, 64					; 00000040H<br />$L74080&#58;<br />	cmp	BYTE PTR &#91;eax-1&#93;, 0<br />	je	SHORT $L74081<br />	add	esi, 1<br />$L74081&#58;<br />	cmp	BYTE PTR &#91;eax&#93;, 0<br />	je	SHORT $L74111<br />	add	esi, 1<br />$L74111&#58;<br />	cmp	BYTE PTR &#91;eax+1&#93;, 0<br />	je	SHORT $L74112<br />	add	esi, 1<br />$L74112&#58;<br />	cmp	BYTE PTR &#91;eax+2&#93;, 0<br />	je	SHORT $L74113<br />	add	esi, 1<br />$L74113&#58;<br />	add	eax, 4<br />	sub	ecx, 1<br />	jne	SHORT $L74080<br />	push	edx<br />	push	0<br />	call	DWORD PTR __imp__GetProcessHeap@0<br />	push	eax<br />	call	DWORD PTR __imp__HeapFree@12<br />$L74076&#58;<br />	add	edi, 4<br />	sub	ebx, 1<br />	jne	SHORT $L74075<br />	sub	DWORD PTR tv508&#91;esp+262168&#93;, 1<br />	mov	eax, edi<br />	jne	SHORT $L74072<br />	pop	edi<br />	mov	eax, esi<br />	pop	esi<br />	pop	ebx<br />	mov	esp, ebp<br />	pop	ebp<br />	ret	12					; 0000000cH<br />_CountColors@12 ENDP<br />_TEXT	ENDS<br /></code></pre></div>
    <div class="meta">Posted on 2004-08-11 18:06:03 by Relvinian</div>
   </div>
   <div class="post" id="post-147925">
    <div class="subject"><a href="#post-147925">Heaps of problems</a></div>
    <div class="body"><div class="quote"><br />Hi Relvinian,<br /><br />Yes the ASM version would be great, I'm extremely lame at any language but ASM, can't even figure out the C compiler by myself. Option 2 is not at all important, it was used in the histogram function but I have thought of a better histogram algorithm and already implemented it, it is faster than can be done with any type of color counter, it scans huge images in the blink of an eye. My needs are now just total colors and instances per RGB color. </div><br /><br />Donkey,<br /><br />I did some quick tests with images on this C code.   All tests were from ranges of 30x30 to 1024x768.  The times are from 13ms to 88ms on a P4.</div>
    <div class="meta">Posted on 2004-08-11 18:08:32 by Relvinian</div>
   </div>
   <div class="post" id="post-147926">
    <div class="subject"><a href="#post-147926">Heaps of problems</a></div>
    <div class="body">Hi Relvinian,<br /><br />Thanks !! I can translate it myself, the labels are all there so it's pretty easy to do mostly just search and replace stuff.</div>
    <div class="meta">Posted on 2004-08-11 18:10:23 by donkey</div>
   </div>
   <div class="post" id="post-147927">
    <div class="subject"><a href="#post-147927">Heaps of problems</a></div>
    <div class="body">Hi Relvinian,<br /><br />Looking through the listing file I think it will be easier to directly translate the C source. I'll get to it tonight. BTW you're obviously a C programmer first, nobody whose primary language was assembly would use CX as a parameter :grin:</div>
    <div class="meta">Posted on 2004-08-11 18:26:40 by donkey</div>
   </div>
   <div class="post" id="post-147928">
    <div class="subject"><a href="#post-147928">Heaps of problems</a></div>
    <div class="body"><div class="quote"><br />Hi Relvinian,<br /><br />Looking through the listing file I think it will be easier to directly translate the C source. I'll get to it tonight. BTW you're obviously a C programmer first, nobody whose primary language was assembly would use CX as a parameter :grin: </div><br /><br />Yep, I started programming a long time ago.   First was BASIC on the Atari 6502 chip set (back in 1980), then moved to M65 (assembly for the 6502).   In 1992 is when I started programming professionally as a career in C.  Moved to C++ in 1995.   Just started programming in assembly for the x86 in March of this year.  So ASM still takes me a little bit of time to do but I'm learning at a fast rate.<br /><br />I'll go ahead and convert my C function to ASM for ya too.  I'll be in Masm format but if I remember correctly, there's a MASM-&gt;GoAsm converter that does a good job.<br /><br />Relvinian</div>
    <div class="meta">Posted on 2004-08-11 18:37:04 by Relvinian</div>
   </div>
   <div class="post" id="post-147929">
    <div class="subject"><a href="#post-147929">Heaps of problems</a></div>
    <div class="body">Hi,<br /><br />This is my translation of the function with a few changes to remove some unnecessary loops as I use only 32 bit DIB sections internally. Note that in raw format the RGB components are reversed. It is very very fast and simple. Thanks :alright: <br /><pre><code>CountColors FRAME hImage<br />	LOCAL pArray			&#58;D<br />	LOCAL hHeap			&#58;D<br />	LOCAL nCount			&#58;D<br />	LOCAL cbImage			&#58;D<br />	LOCAL dibs			&#58;BITMAP<br /><br />	invoke GlobalAlloc,GMEM_ZEROINIT,65536*4<br />	mov &#91;pArray&#93;,eax<br /><br />	invoke HeapCreate,0,0,0<br />	mov &#91;hHeap&#93;,eax<br /><br />	; Blue*Green = EAX<br />	; Red = ECX<br /><br />	; offset Array = EDI<br />	; pColor = EBX<br /><br />	invoke GetObject,&#91;hImage&#93;,SIZEOF BITMAP,offset dibs<br />	mov eax,&#91;dibs.bmWidthBytes&#93;<br />	mul D&#91;dibs.bmHeight&#93;<br />	mov &#91;cbImage&#93;,eax<br /><br />	mov edi,&#91;pArray&#93;<br />	mov ebx,&#91;dibs.bmBits&#93;<br />	add &#91;cbImage&#93;,ebx<br /><br />	.MARKCOLORS<br />		mov ecx,&#91;ebx&#93;<br />		mov eax,ecx<br />		shr ecx,16<br />		and ecx,0ffh<br />		and eax,0ffffh<br />		mov esi,&#91;edi+eax*4&#93;<br />		or esi,esi<br />		jnz &gt;<br />			push eax,ecx<br />			invoke HeapAlloc,&#91;hHeap&#93;,HEAP_ZERO_MEMORY,256<br />			mov esi,eax<br />			pop ecx,eax<br />			mov &#91;edi+eax*4&#93;,esi<br />		&#58;<br />		mov B&#91;esi+ecx&#93;,0FFh<br />	add ebx,4<br />	cmp ebx,&#91;cbImage&#93;<br />	jl &lt;.MARKCOLORS<br /><br />	mov D&#91;nCount&#93;,0<br />	mov ebx,65535<br />	L1&#58;<br />		mov eax,&#91;edi+ebx*4&#93;<br />		or eax,eax<br />		jz &gt;.NOARRAY<br />			mov edx,255<br />			.COUNTMARKS<br />				mov cl,&#91;eax+edx&#93;<br />				add cl,cl<br />				adc D&#91;nCount&#93;,0<br />				dec edx<br />			jns &lt;.COUNTMARKS<br />		.NOARRAY<br />		dec ebx<br />		jns &lt;L1<br /><br />	invoke GlobalFree,&#91;pArray&#93;<br />	invoke HeapDestroy,&#91;hHeap&#93;<br />	mov eax,&#91;nCount&#93;<br />	ret<br />ENDF</code></pre></div>
    <div class="meta">Posted on 2004-08-11 19:59:17 by donkey</div>
   </div>
   <div class="post" id="post-147934">
    <div class="subject"><a href="#post-147934">Heaps of problems</a></div>
    <div class="body">Looks good there Donkey.<br /><br />I'm sure there's plenty of room for some basic optimization in my algo of course...:)<br /><br />Anyway, glad you found the code to be some what worthwhile.<br /><br />Relvinian<br /><br />PS - How are the performance tests?   You said it was nice and fast.   Acceptable for your LIB stuff now?</div>
    <div class="meta">Posted on 2004-08-11 20:42:06 by Relvinian</div>
   </div>
   <div class="post" id="post-147935">
    <div class="subject"><a href="#post-147935">Heaps of problems</a></div>
    <div class="body">Yup, I did a few simple things like removing the MUL for Blur*Green and just using the WORD instead as well as setting the Red flag to 0FFh so I could use the carry flag instead of a JZ to increment the count. All in all it tests at almost exactly 10x faster than my brute force approach so I have added it to my lib, with proper credit ofcourse. As well, there is a histogram function and an AdjustLuma function.</div>
    <div class="meta">Posted on 2004-08-11 21:01:34 by donkey</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=19130&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=19130&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="19130" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=19130&amp;page=2">&gt;</a><a href="../?id=19130&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>