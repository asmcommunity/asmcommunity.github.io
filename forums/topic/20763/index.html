<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>BSP Game Engine (MASM, OpenGL, ATC) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20763" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=22">Recruitment</a> &raquo; <a href="../?id=20763">BSP Game Engine (MASM, OpenGL, ATC)</a></p>
   <div class="post" id="post-158046">
    <div class="subject"><a href="#post-158046">BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">As any of you who are likely to read this would know, I&#39;ve recently completed code for importing a trianglesoup from an OBJ file, optimizing it, generating a BSPTree from it, and saving it to a custom file format.<br /><br />I am looking for expressions of interest in a collaborative and open-sourced BSP-based game engine project. You don&#39;t need to be familiar with OpenGL, ATC or OOP models, but it would be helpful.<br /><br />The only requirements are an interest in MASM coding and 3D games and a willingness to learn and to try new things.<br /><br />The project will be comprised of three interrelated components:<br />-Game Engine Core<br />-Game Server<br />-Game Client<br /><br />I&#39;d like to see the Core capable of operating in Game or Developer modes, so that N users could join a &quot;game&quot;, and edit the same world at the same time. I might be planning too far in advance, but if this is an underlying design paradigm then a lot of rework can be avoided later.<br /><br />Please correspond via this thread unless otherwise advised.<br /></div>
    <div class="meta">Posted on 2005-03-17 01:52:25 by Homer</div>
   </div>
   <div class="post" id="post-158146">
    <div class="subject"><a href="#post-158146">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">sounds interesting, I don&#39;t know alot about BSP but have willingness to learn and try new things as you put it.<br /><br />Here is what I did, close to a year ago.? It includes a .OBJ mesh and can read up to 4-sided polys. left mouse button rotates, right button zooms.<br /><br />http://drarem.ms11.net/wankergl4.zip</div>
    <div class="meta">Posted on 2005-03-20 10:54:54 by drarem</div>
   </div>
   <div class="post" id="post-158149">
    <div class="subject"><a href="#post-158149">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">I dont know much about BSP, I want to code something 3d in masm<br />I could contribute with SSE, generating/rotating/transform on the fly two circles parallel,animation rotates around several axis+ sizechange, esc quits, best viewed at 8bit color<br />http://web.telia.com/~u45113685/asm/SSEexpbak2.zip<br /><br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2005-03-20 13:49:39 by daydreamer</div>
   </div>
   <div class="post" id="post-158389">
    <div class="subject"><a href="#post-158389">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">I see OBJ as an intermediate file format.<br />Easy to read, easy to modify, terribly inefficient.<br /><br />My OBJ loader code reindexes all 2D and 3D indices to unique instances of those values.<br />That is to say, it eliminates duplicates of Vec2 and Vec3 values and repairs indices.<br />At that point I am ready to process the polygons in some way.<br />BSP is what I&#39;m using at the moment, implementing the tree generator wasn&#39;t too hard.<br /><br />A BSP Tree node is basically a struct that contains three things:<br />Some kind of ID tag identifying a Polygon from which a Dividing Plane was obtained, and two pointers to Child nodes which will contain all the Polygons which exist on either side of the aforementioned Divider plane.<br /><br />BSPNode struct<br />SplitterPolyID dd ?<br />pFront dd ?<br />pBack dd ?<br />BSPNode ends<br /><br />When I say Polygon, it means Triangle.<br />If we can afford to make the assumption that more complex polygons are always FLAT (planar),<br />then this stuff will work for any polygon, but generally speaking, this stuff is for Triangles.<br /><br />Generating a Tree from a Polygon List involves choosing from that list one Polygon to use as a Dividing Plane, then classifying all the other Polys against that Plane, and sorting them into two Child Lists, and handing each to a Child Node for recursive processing.<br />Polygons which are cut by the dividingplane must be split into several new polygons, and the original polygon should be discarded.<br /><br />Once the Tree has been generated, it&#39;s very easy to render a correct scene given any position for the camera.<br />Starting at the root node, you check if the camera is in front of or behind the node&#39;s dividingplane, and then &quot;walk the other side child, then the same side child&quot;, then render the dividingplane&#39;s poly.<br />Read that three times and it will become as clear as mud :)<br /><br />I&#39;ve put a recent version of the code at http://homer.ultrano.com/BSPGenerator.zip<br />Let me know what&#39;s missing and I&#39;ll remedy it.<br />Take a look at this code and see if you can stomach it.<br />The manager class VertexManager needs to be renamed as Vec3Manager.<br />All management classes need overhauling, Ultrano has recently provided me with source to smAlloc MM so that I might create a more streamlined fixed-size-element array manager.<br /></div>
    <div class="meta">Posted on 2005-03-24 21:00:54 by Homer</div>
   </div>
   <div class="post" id="post-158500">
    <div class="subject"><a href="#post-158500">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">after message 18 polygons gonna be processed<br />message:MeshLoader Instance @3C3F10<br />after that it crashes and windows comes ups with message<br /><br />do you mind if I test it with something more funnier than a hipolycountcube?</div>
    <div class="meta">Posted on 2005-03-28 12:28:50 by daydreamer</div>
   </div>
   <div class="post" id="post-159455">
    <div class="subject"><a href="#post-159455">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">No, test it with whatever you liked.<br />My final version of the old bspgenerator was fed the following geometry successfully:<br />I created 24 triangles in Maya, and rotated each of them randomly , and with a small random translation each, resulting in an intersecting mangled mess.<br />I then exported that to OBJ and fed the OBJ to the old BSPgen.<br />Successfully processed this complex beastie.<br />The old OBJ importer was bad at importing large models.<br /><br />Currently rewriting BSP code to support new HSM file format.<br />HSM is a class for importing OBJ and a file format for exporting.<br />Maya6.0 compatible.<br />Better materials handling.<br />Handles larger models (tested with a 7000 poly model recently, haven&#39;t really pushed it at all)<br />Should not be bugs in loader code at all.<br /><br />If you want to get in now on this revision, I&#39;ll put up the existing codebase.<br />I&#39;m rewriting the BSPgen to handle triangles AND quads at once intelligently.<br />IE a triangle can be split into a triangle and a quad, rather than three triangles.<br />HSM already handles both polygons and keeps them grouped by material, meaning it&#39;s easy to render just the faces of a particular material in an object comprised of &gt;1 material, or to render the object&#39;s faces in order of materials, eliminating texture thrashing.<br /><br /></div>
    <div class="meta">Posted on 2005-05-02 03:14:32 by Homer</div>
   </div>
   <div class="post" id="post-159881">
    <div class="subject"><a href="#post-159881">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">Hi Home2k, I&#39;m returned again too look whats going on. Probaly you forgot me. I was some where other place doing some thing unknown stuff%). I see you try to Render BSP, should I post ProbinkGL again? A new version: Collision works now with gravity and jumping!! But theres some problem with calculating FPS probaly, so it is possible to go throught wall or floor. Are you interest?</div>
    <div class="meta">Posted on 2005-05-08 17:24:33 by valka</div>
   </div>
   <div class="post" id="post-159906">
    <div class="subject"><a href="#post-159906">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">Sure post it again, though I doubt I can use much of it.<br />I&#39;m not loading a BSP someone else made.<br />I&#39;m loading a BSP I generated with my own generator, so things are a bit nonstandard, as you can see above.<br />Still, I&#39;m sure I can use the lightmap stuff.<br /><br />I&#39;m pretty sure I understand why you are crashing through surfaces.<br />My collision detections are not dependant on time.<br />My algorithm does not require the intersection time to produce accurate collisions and responses.<br />I have posted code in regard to sphere/plane collisions.<br />These are parts A and B of a two-stage test.<br />We actually test a theoretical line from the old to the new sphere origins against the plane of the triangle, and then if we find a collision, we test the resulting intersectionpoint on the plane against the triangle geometry to make sure it&#39;s inside the triangle.<br /><br />Does this sound anything like your existing collision detection framework?<br /></div>
    <div class="meta">Posted on 2005-05-09 10:31:48 by Homer</div>
   </div>
   <div class="post" id="post-159934">
    <div class="subject"><a href="#post-159934">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">Cool! An own generated BSP. Here&#39;s the source of latest ProbnikGL: http://www.hot.ee/valk777/ProbnikGL_0_08.rar<br />You will find that I use OOP much, but I can&#39;t call them OOP modules because they still depend on other modules or main .asm file. What else? Collision detection is not good in ProbnikGL, I can&#39;t find mistake or something that I could change to make it better. Source is big and I don&#39;t remember well how it actually works%)</div>
    <div class="meta">Posted on 2005-05-10 09:17:53 by valka</div>
   </div>
   <div class="post" id="post-159966">
    <div class="subject"><a href="#post-159966">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">Im interested. What should I do? I hope I can get to this site everyday. I always everyday at masmforum use name Farabi. I dont know about C programming. I upload my own project here. Please check at GL init function on GUI.inc on my code to see the Open GL code.</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=622" target="_blank">GT2.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2005-05-11 22:13:57 by realvampire</div>
   </div>
   <div class="post" id="post-160038">
    <div class="subject"><a href="#post-160038">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">You should begin by bringing yourself up to speed.<br />Check out all the stuff I&#39;ve posted regarding BSP and collision detections.<br />You need to understand what a surface normal is.<br />You need to understand what an infinite plane is.<br />Infinity is not something we calculate :)<br />You need to understand how to test what side of a plane any 3D point lays.<br />Is the point in front of the plane, behind the plane, or resting on the plane?<br />Once you understand these few things, try writing some demo code to test a point and a plane.<br />It doesn&#39;t need any window at all, we can use messagebox or something.. I mean really simple.<br />That stuff covers about 40 percent of our math requirements in this project.<br />Having all this under your belt, yell out again and I&#39;ll lay some more homework on you :)<br />Also, feel free to whine in public if you find yourself stumped.<br />This stuff can look scary at first, but really, we&#39;ll write a few procs and then it&#39;ll be a matter of calling procs as usual, nothing scary about it :)<br /></div>
    <div class="meta">Posted on 2005-05-12 22:00:59 by Homer</div>
   </div>
   <div class="post" id="post-160078">
    <div class="subject"><a href="#post-160078">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">Hi. DO you have a 3D rotation code? I have never completed it.</div>
    <div class="meta">Posted on 2005-05-13 22:36:45 by realvampire</div>
   </div>
   <div class="post" id="post-160081">
    <div class="subject"><a href="#post-160081">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body"><br />I have all kinds of 3D rotation code :)<br />You have to be very specific about this stuff.<br />What do you want to rotate? How do you want to rotate it?<br /><br />By what, I mean, are we rotating a 3D object with many vertices in it?<br />Are we rotating just a 3D line around a 3D point? Etc.<br /><br />By how, I mean, are we rotating around a particular axis, like X, Y and Z?<br />Or are we rotating about an arbitrary axis, ie a 3D line as our axis of rotation?<br /><br />Then we have to consider other things like - does the target of our rotation have a 3D offset to its rotation origin (ie, is it built off-center), and is this rotation part of a hierarchy ie a human limb chain?<br /><br />Rotation can be very simple, or very hard, depending on what you want to do.<br />The first way I learned to rotate was using trigonometry (sine and cosine), and I was only able to perform this in 2D. Later I learned how to perform it in 3D using trigonometry.<br />Now I can perform it using matrix math as well.<br /><br />glRotatef is an OpenGL function which takes four params, and is probably the simplest way to rotate stuff.<br />The first param is a floating point Angle in degrees.<br />The other three define a vector which forms the rotation axis.<br />For example, to rotate about the Y axis, we set the rotation axis to 0.0f,1.0f,0.0f<br />We call it just before constructing our objects within our Render procedure.<br /><br />The function calculates and then combines the rotation matrix with the current world matrix and applies the result as the new world matrix.<br />This means after we call it, everything we draw gets rotated - we have in fact rotated the world by the opposite 3D rotation, and are drawing things straight :)<br />By surrounding such calls with calls to glPushMatrix and glPopMatrix, we can perform rotations which are not cumulative.<br />By nesting this behaviour in code we can perform relative rotation and hierarchical rotation.<br />Once we understand all this stuff we should learn how to use matrices ourselves and provide our own matrix math procs or macros, and learn to apply the rotation matrices we create (by multiplying them with the world matrix) and also we should learn how to &quot;slap a translation into a 4x4 rotation matrix&quot; to quickly create combined translation/rotation matrices.<br />One step at a time :)<br /></div>
    <div class="meta">Posted on 2005-05-14 01:21:10 by Homer</div>
   </div>
   <div class="post" id="post-160123">
    <div class="subject"><a href="#post-160123">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">Homer - Tell me, have you looked in ProbnikGL source? IT SUCKS??? TELL ME THAT IT SUCKS, I KNOW IT :D</div>
    <div class="meta">Posted on 2005-05-16 13:18:16 by valka</div>
   </div>
   <div class="post" id="post-160134">
    <div class="subject"><a href="#post-160134">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">I haven&#39;t reviewed his repost yet, since as many of you are aware, my daily driver recently&nbsp; spontaneously combusted, demoting me to a lowly 333.<br />I do however have a clear recollection of the source from when he was developing it, at the time he was adding lightmap support.<br />To be honest, at first glace it appears awful, then after a while, you&#39;ll realize it&#39;s actually quite efficient code, it&#39;s an objectless and naiive approach he&#39;s taken. That&#39;s not a bad thing imho :)<br />I don&#39;t recall anything particularly obtuse about his source, but perhaps he&#39;s rewritten it for the worse since then.. I&#39;m not in a position to test it, so I haven&#39;t bothered looking.<br />My biggest priority at the moment is a new motherboard :(</div>
    <div class="meta">Posted on 2005-05-17 02:38:12 by Homer</div>
   </div>
   <div class="post" id="post-160337">
    <div class="subject"><a href="#post-160337">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">Hai. After this is finish. I have understand anything I need.<br /><br /><pre><code><br />RotatingXYZ proc x:dword,y:dword,z:dword,xAng:dword,yAng:dword,zAng:dword<br />	LOCAL xt,yt,zt:dword<br />	LOCAL xt2,yt2,zt2:dword<br />	LOCAL xt3,yt3,zt3:dword<br />	<br />	<br />	<br />	<br />;&nbsp; &nbsp; &nbsp; &nbsp; Rotate around x-axis&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />;&nbsp; &nbsp; &nbsp; &nbsp; YT = Y * COS(xang) - Z * SIN(xang) / 256&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />;&nbsp; &nbsp; &nbsp; &nbsp; ZT = Y * SIN(xang) + Z * COS(xang) / 256&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />;&nbsp; &nbsp; &nbsp; &nbsp; Y = YT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />;&nbsp; &nbsp; &nbsp; &nbsp; Z = ZT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />	<br />	<br />	invoke UMGetPosRound,y,xAng<br />	mov yt,edx<br />	invoke UMGetPosRound,z,xAng<br />	sub eax,yt<br />	mov yt,eax<br />	<br />	invoke UMGetPosRound,y,xAng<br />	mov zt,eax<br />	invoke UMGetPosRound,z,xAng<br />	add edx,zt<br />	mov zt,edx<br /><br />;&nbsp; &nbsp; &nbsp; &nbsp; Rotate around y-axis&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />;&nbsp; &nbsp; &nbsp; &nbsp; XT = X * COS(yang) - Z * SIN(yang) / 256&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />;&nbsp; &nbsp; &nbsp; &nbsp; ZT = X * SIN(yang) + Z * COS(yang) / 256&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />;&nbsp; &nbsp; &nbsp; &nbsp; X = XT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />;&nbsp; &nbsp; &nbsp; &nbsp; Z = ZT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />	<br />	<br />	invoke UMGetPosRound,x,yAng<br />	mov xt2,edx<br />	invoke UMGetPosRound,z,yAng<br />	sub eax,xt<br />	mov xt2,eax<br />	<br />	invoke UMGetPosRound,x,yAng<br />	mov zt2,eax<br />	invoke UMGetPosRound,z,yAng<br />	add edx,zt2<br />	mov zt2,edx<br /><br />;&nbsp; &nbsp; &nbsp; &nbsp; Rotate around z-axis&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />;&nbsp; &nbsp; &nbsp; &nbsp; XT = X * COS(zang) - Y * SIN(zang) / 256&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />;&nbsp; &nbsp; &nbsp; &nbsp; YT = X * SIN(zang) + Y * COS(zang) / 256&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />;&nbsp; &nbsp; &nbsp; &nbsp; X = XT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />;&nbsp; &nbsp; &nbsp; &nbsp; Y = YT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;<br />	<br />	<br />	invoke UMGetPosRound,x,zAng<br />	mov xt3,edx<br />	invoke UMGetPosRound,y,zAng<br />	sub eax,xt3<br />	mov xt3,eax<br />	<br />	invoke UMGetPosRound,x,zAng<br />	mov yt3,eax<br />	invoke UMGetPosRound,y,zAng<br />	add edx,yt3<br />	mov yt3,edx<br />	<br />	<br />	mov edx,xt3<br />;	add edx,xt2<br />	<br />	mov eax,yt3<br />;	add eax,yt<br />	<br />	<br />	<br />	xor ecx,ecx<br />	add ecx,500<br />	<br />	<br />	ret<br />RotatingXYZ endp<br /></code></pre><br /><br />I confused about the result, what should I do with all the value, just add it all?</div>
    <div class="meta">Posted on 2005-05-22 02:02:47 by realvampire</div>
   </div>
   <div class="post" id="post-160359">
    <div class="subject"><a href="#post-160359">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">This is what we call a compound rotation.<br />The algorithm you are using creates a lot of error, due to rotation about one axis rotating another axis.<br /><br />Your algorithm has three parts.<br />You are really performing three separate rotations.<br />You are rotating about X, which modifies Y and Z.<br />You are rotating about Y, which modifies X and Z.<br />You are rotating about Z, which modifies X and Y.<br /><br />You don&#39;t add anything.<br />You have input X,Y,Z values, some math operations, then X,Y,Z output values.<br /><br />Try simplifying the algo to only rotate about a single axis at a time to understand it better.<br /></div>
    <div class="meta">Posted on 2005-05-22 22:34:58 by Homer</div>
   </div>
   <div class="post" id="post-160369">
    <div class="subject"><a href="#post-160369">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">This is a single rotation.<br /><br /><pre><code><br />	invoke UMGetPosRound,x,zAng<br />	mov xt3,edx<br />	invoke UMGetPosRound,y,zAng<br />	sub eax,xt3<br />	mov xt3,eax<br />	<br />	invoke UMGetPosRound,x,zAng<br />	mov yt3,eax<br />	invoke UMGetPosRound,y,zAng<br />	add edx,yt3<br />	mov yt3,edx<br /></code></pre><br /><br />And what should I do next?</div>
    <div class="meta">Posted on 2005-05-23 06:40:45 by realvampire</div>
   </div>
   <div class="post" id="post-160402">
    <div class="subject"><a href="#post-160402">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">The reason you are confused is because you are looking at a code snippet which you don&#39;t understand, and totally ignoring the comments which are giving you 2D trig formula for rotation of a point about a given axis.<br /><br />Rotation around the X axis :<br />;&nbsp; &nbsp; &nbsp; &nbsp; YT = Y * COS(xang) - Z * SIN(xang) / 256 <br />;&nbsp; &nbsp; &nbsp; &nbsp; ZT = Y * SIN(xang) + Z * COS(xang) / 256<br /><br />Let&#39;s make this more clear.<br />Where Theta is an angle of rotation (amount to rotate)<br />New Y = ( Old Y * ( COS THETA)) - ( Old Z * ( SIN THETA ))<br />New Z = ( Old Y * ( SIN THETA )) + ( Old Z * ( COS THETA ))<br /><br />Ignoring the /256 because its a stupid scalar and is not part of the formula.<br /><br />Now, here&#39;s the part where you kick yourself.<br />Your 3D point (X, Y, Z) when rotated about the X axis WILL NOT ALTER X VALUE.<br />Rotation around X affects Y and Z only.<br />So - in the above example, take ANY 3D point in space (XYZ), plug the values into the above formula, and out comes the new XYZ (in our case, X doesnt change)<br /></div>
    <div class="meta">Posted on 2005-05-24 08:05:32 by Homer</div>
   </div>
   <div class="post" id="post-160403">
    <div class="subject"><a href="#post-160403">Re: BSP Game Engine (MASM, OpenGL, ATC)</a></div>
    <div class="body">For the record, even though this formula and its 3D variant work, they are imperfect.<br />For rotating about a single axis, we&#39;re really doing a 2D rotation, and thats fine, trig will work ok.<br />But as soon as you want to apply a compound rotation, you&#39;ll have problems with that method.<br />Still, it&#39;s the same place I started learning this stuff, and I&#39;d say it&#39;s still worth learning this method.<br /></div>
    <div class="meta">Posted on 2005-05-24 08:09:02 by Homer</div>
   </div>
  </div>
 </body>
</html>