<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>prime numbers algorithm - very slow - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=14031" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=14031">prime numbers algorithm - very slow</a></p>
   <div class="post" id="post-108372">
    <div class="subject"><a href="#post-108372">prime numbers algorithm - very slow</a></div>
    <div class="body">This is an inferior prime numbers search algorithm, which I have since optimized so as to work 8 times faster...but even so, it is way slower than the sieve algorithm discussed <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=13322">here</a><br /><br />Create a table of primes...<br />A(x,0)=x+1 th prime<br />A(x,1)=next odd number divisible by A(x,0)<br />start <br />2 (x=0)<br />3 (x=1)<br />m=# primes<br />n=# being checked<br />counting n in twos beginning at 5,<br />x=1 to m-1<br />if n&lt;=A(x,1), then A(x,1)=A(x,1)+2*A(x,0); flag=1<br />next x<br />if flag=0 then A(m,0)=n; A(m,1)=n*3; m=m+1;<br />next n<br /><br />The programs check and store primes up to the size of array (mx) or memory allocated (memtoalloc). They could do with some optimization... 16384 primes found in 4 seconds on a Pentium III. But it's a non-optimal algorithm anyway...<br /><br />BASIC and HLA (Assembly) source code and executable included.<br /><br /><pre><code><br />mx=1000<br />dim a&#40;mx,1&#41;<br />cls<br /><br />Print&quot;Searching for primes...&quot;<br />print&quot;2&quot;&#58;a&#40;0,0&#41;=2<br />print&quot;3&quot;&#58;a&#40;1,0&#41;=3&#58;a&#40;1,1&#41;=3*3<br />m=2&#58;n=5<br /><br />n1&#58;<br />f=0<br />for j=m-1 to 1 step -1<br />if n&gt;=a&#40;j,1&#41; then a&#40;j,1&#41;=a&#40;j,1&#41;+2*a&#40;j,0&#41;&#58;f=1<br />next j<br />if f=0 then A&#40;m,0&#41;=n&#58;A&#40;m,1&#41;=n*3&#58;m=m+1&#58;'print m&quot;th prime is&quot;n<br />if m&lt;1000 then n=n+2&#58;goto n1<br />print m&quot;primes found&quot;<br /></code></pre><br /><br /><pre><code><br />// **********************************<br />// Prime Numbers Search Program <br />//         Coded using HLA<br />// <br />// **********************************<br /><br />program primes;<br />#include&#40; &quot;stdlib.hhf&quot; &#41;;<br /><br />const<br />     memtoalloc &#58;=$2000;  <br />static &#40;4&#41;<br /><br />     memaddr&#58; pointer to byte;<br />     numprimes&#58; int32&#58;=2 * 8;                 // 2 primes found so far<br />     number&#58; int32&#58;=3;<br />     flag&#58; int32;<br /> <br />     t&#58;time.timerec;<br /><br />begin primes;<br /><br />     console.cls&#40;&#41;;<br />     console.gotoxy&#40;4, 15&#41;;<br />     stdout.put &#40; &quot;Primes Search Program.&quot;, nl&#41;;<br />     console.gotoxy&#40;5, 15&#41;;<br />     stdout.put &#40; &quot;        Coded using HLA&quot;, nl, nl&#41;;<br /><br />     stdout.put &#40; &quot;Initializing memory. Initial Time&#58; &quot;&#41;;<br />     time.curTime&#40;t&#41;;<br />     stdout.puti16Size&#40;t.hours, 2, '0'&#41;; stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.mins, 2, '0'&#41;;   stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.secs, 2, '0'&#41;;<br /><br />// Allocate RAM; On return EAX contains address; <br />     malloc &#40;memtoalloc&#41;;<br /><br />// Store memory address<br />     mov &#40;eax, memaddr&#41;;<br /><br />// Clear memory<br />     mov &#40;memaddr, esi&#41;;<br />     xor &#40;eax, eax&#41;;      // Fill mem with 0<br />     mov &#40;memtoalloc, ecx&#41;;<br />     sub &#40;4, ecx&#41;;<br />clm1&#58;<br />     mov &#40;edx, &#91;esi+ecx&#93;&#41;;<br /><br />     sub &#40;4, ecx&#41;;<br />     jns clm1;<br /><br />// Commencing Message<br />     stdout.put &#40; nl, nl,&quot;Commencing Search.         Time&#58; &quot;&#41;;<br />     time.curTime&#40;t&#41;;<br />     stdout.puti16Size&#40;t.hours, 2, '0'&#41;; stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.mins, 2, '0'&#41;;   stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.secs, 2, '0'&#41;;   stdout.put&#40;nl&#41;;<br /><br /><br />// Check clocks<br />          rdtsc;                       // First measure of time<br />                                       // rdtsc takes 13 cycles on Pentium MMX,<br />          push &#40;edx&#41;;                  // I store the 64 bit cycle count on the stack. <br />          push &#40;eax&#41;;<br /><br />     mov &#40;memaddr, esi&#41;;<br />     mov &#40;2, eax&#41;;<br />     mov &#40;eax, &#91;esi+4&#93;&#41;;<br />     mov &#40;3, eax&#41;;<br />     mov &#40;eax, &#91;esi+12&#93;&#41;;<br />     lea &#40;edx, &#91;eax+eax*2&#93;&#41;;<br />     mov &#40;edx, &#91;esi+8&#93;&#41;;<br /><br />     mov &#40;number, eax&#41;;<br /><br />nx&#58;<br />     mov &#40;numprimes, ecx&#41;;<br /><br />nx_&#58;<br />     sub &#40;8, ecx&#41;;<br /><br />     xor &#40;ebx, ebx&#41;;                   // flag<br />     add &#40;2, eax&#41;;<br /><br />nxj&#58;<br />     cmp &#40;eax, &#91;esi+ecx&#93;&#41;;<br />     jb nxk;<br /><br />     mov &#40;&#91;esi+ecx+4&#93;, edx&#41;;<br />     lea &#40;edx, &#91;edx*2&#93;&#41;;<br />     add &#40;edx, &#91;esi+ecx&#93;&#41;;<br />     mov &#40;1, ebx&#41;;<br /><br />nxk&#58;<br />     sub &#40;8, ecx&#41;;<br />     jne nxj;<br /><br />     or &#40;ebx, ebx&#41;;<br />     jne nx;<br /><br />     mov &#40;numprimes, ecx&#41;;<br /><br />     mov &#40;eax, &#91;esi+ecx+4&#93;&#41;;<br />     lea &#40;edx, &#91;eax*2&#93;&#41;;<br />     mov &#40;edx, &#91;esi+ecx&#93;&#41;;<br />//     stdout.put&#40;&#40;type uns32 eax&#41;, nl&#41;;<br /><br />     add &#40;8, ecx&#41;;<br />     mov &#40;ecx, numprimes&#41;;<br /><br />     cmp &#40;ecx, memtoalloc&#41;;<br />     jne nx_;<br /><br />     mov &#40;eax, number&#41;;<br /><br />// Check clocks<br />          rdtsc;                       // Second measure of time<br />          push &#40;edx&#41;;<br />          push &#40;eax&#41;;<br /><br />// Completion Message<br />     stdout.put &#40; nl, nl,&quot;Search Stopped at Time&#58; &quot;&#41;;<br />     time.curTime&#40;t&#41;;<br />     stdout.puti16Size&#40;t.hours, 2, '0'&#41;; stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.mins, 2, '0'&#41;;   stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.secs, 2, '0'&#41;;<br /><br />// Report<br />     mov &#40;ecx, numprimes&#41;;<br />     shr &#40;3, ecx&#41;;<br />     stdout.put &#40;nl, &#40;type uns32 ecx&#41;, &quot; Primes found  in &quot;&#41;;<br /><br />// Retrieve 2nd rdtsc<br />          pop &#40;eax&#41;;<br />          pop &#40;edx&#41;;<br /><br />          sub &#40;&#91;esp&#93;, eax&#41;;             // subtract first from second<br />          sbb &#40;&#91;esp+4&#93;,edx&#41;;            // result in EDX&#58;EAX<br /><br />          add &#40;8, esp&#41;;                 // remove first edx, eax from stack<br /><br />    if &#40;edx=0&#41; then <br />         stdout.putu32&#40;eax&#41;;<br />         stdout.put&#40;&quot; clock cycles = &quot;, nl&#41;;<br />    else<br />         stdout.put &#40;&quot;$&quot;,edx,&quot; &quot;,eax, &quot; clock cycles = &quot;, nl&#41;;<br />    endif;<br /><br /><br />end primes;<br /></code></pre></div>
    <div class="meta">Posted on 2003-06-26 21:25:41 by V Coder</div>
   </div>
   <div class="post" id="post-108373">
    <div class="subject"><a href="#post-108373">prime numbers algorithm - very slow</a></div>
    <div class="body">Here is the 'optimized' version. It fixes up some jump targets, keeps some values in registers, and does not cycle through all the primes for each number being checked...not at once anyway...<br /><br />As a result, it is some orders faster.<br /><br />However, the algorithm still works in O n^2 time, which is very inefficient... cf Bubbe sort as opposed to Heap or Quick sort.<br /><br /><pre><code>'defint a-h, j-z<br />open &quot;c&#58;\primes2.txt&quot; for output as #1<br />mx=2000<br />dim a&#40;mx,1&#41;<br />cls<br /><br />Print&quot;Searching for primes...&quot;<br />print&quot;2&quot;&#58;a&#40;0,0&#41;=2<br />print&quot;3&quot;&#58;a&#40;1,0&#41;=3&#58;a&#40;1,1&#41;=3*3<br />m=2&#58;n=5<br /><br />n1&#58;<br />f=0<br />j=0<br />n2&#58;<br />if n&gt;a&#40;j,1&#41; then a&#40;j,1&#41;=a&#40;j,1&#41;+2*a&#40;j,0&#41;&#58;goto n2<br />if n=a&#40;j,1&#41; then n=n+2&#58; goto n1<br />j=j+1&#58; if j&lt;m then n2<br />A&#40;m,0&#41;=n&#58;A&#40;m,1&#41;=n*3&#58;m=m+1&#58;'print m&quot;th prime is&quot;n<br />if m&lt;mx then n=n+2&#58;goto n1<br />print m&quot;primes found&quot;<br /><br />close #1</code></pre><br /><br /><pre><code>// **********************************<br />// Primes Numbers Search Program <br />//         Coded using HLA<br />// <br />// **********************************<br /><br />program primes;<br />#include&#40; &quot;stdlib.hhf&quot; &#41;;<br /><br />const<br />     memtoalloc &#58;=$10000;  <br />static &#40;4&#41;<br /><br />     memaddr&#58; pointer to byte;<br />     numprimes&#58; int32&#58;=2 * 8;                 // 2 primes found so far<br />     number&#58; int32&#58;=3;<br />     flag&#58; int32;<br /> <br />     t&#58;time.timerec;<br /><br />begin primes;<br /><br />     console.cls&#40;&#41;;<br />     console.gotorc&#40;4, 15&#41;;<br />     stdout.put &#40; &quot;Primes Search Program.&quot;, nl&#41;;<br />     console.gotorc&#40;5, 15&#41;;<br />     stdout.put &#40; &quot;        Coded using HLA&quot;, nl, nl&#41;;<br /><br />     stdout.put &#40; &quot;Initializing memory. Initial Time&#58; &quot;&#41;;<br />     time.curTime&#40;t&#41;;<br />     stdout.puti16Size&#40;t.hours, 2, '0'&#41;; stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.mins, 2, '0'&#41;;   stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.secs, 2, '0'&#41;;<br /><br />// Allocate RAM; On return EAX contains address; <br />     malloc &#40;memtoalloc&#41;;<br /><br />// Store memory address<br />     mov &#40;eax, memaddr&#41;;<br /><br />// Clear memory<br />     mov &#40;memaddr, esi&#41;;<br />     xor &#40;eax, eax&#41;;      // Fill mem with 0<br />     mov &#40;memtoalloc, ecx&#41;;<br />     sub &#40;4, ecx&#41;;<br />clm1&#58;<br />     mov &#40;edx, &#91;esi+ecx&#93;&#41;;<br /><br />     sub &#40;4, ecx&#41;;<br />     jns clm1;<br /><br />// Commencing Message<br />     stdout.put &#40; nl, nl,&quot;Commencing Search.         Time&#58; &quot;&#41;;<br />     time.curTime&#40;t&#41;;<br />     stdout.puti16Size&#40;t.hours, 2, '0'&#41;; stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.mins, 2, '0'&#41;;   stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.secs, 2, '0'&#41;;   stdout.put&#40;nl&#41;;<br /><br /><br />// Check clocks<br />          rdtsc;                       // First measure of time<br />                                       // rdtsc takes 13 cycles on Pentium MMX,<br />          push &#40;edx&#41;;                  // I store the 64 bit cycle count on the stack. <br />          push &#40;eax&#41;;<br /><br />     mov &#40;memaddr, esi&#41;;<br />     mov &#40;2, eax&#41;;                     // first prime<br />     mov &#40;eax, &#91;esi+4&#93;&#41;;<br />     mov &#40;3, eax&#41;;                     // second prime<br />     mov &#40;eax, &#91;esi+12&#93;&#41;;<br />     lea &#40;edx, &#91;eax+eax*2&#93;&#41;;           // next number for 3<br />     mov &#40;edx, &#91;esi+8&#93;&#41;;<br /><br />     mov &#40;number, eax&#41;;<br /><br />n0&#58;<br />     add &#40;2, eax&#41;;                     // n=5 first time<br />     mov &#40;8, ecx&#41;;                     // j=1<br /><br />n2&#58;<br />     cmp &#40;eax, &#91;esi+ecx&#93;&#41;;<br />     je n0;<br /><br />     jb nx;<br /><br />     mov &#40;&#91;esi+ecx+4&#93;, edx&#41;;<br />     lea &#40;edx, &#91;edx*2&#93;&#41;;<br />     add &#40;edx, &#91;esi+ecx&#93;&#41;;<br />     jmp n2;                           //<br />n2a&#58;<br />     cmp &#40;eax, &#91;esi+ecx&#93;&#41;;<br />     je n0;<br />     jb nx;<br />     add &#40;edx, &#91;esi+ecx&#93;&#41;;<br />     jmp n2a;<br /><br />nx&#58; <br />     add &#40;8, ecx&#41;;                     // j=j+1<br />     cmp &#40;ecx, numprimes&#41;;             // if j&lt;m then n1<br />     jb n2;<br /><br />     mov &#40;numprimes, ecx&#41;;<br /><br />     mov &#40;eax, &#91;esi+ecx+4&#93;&#41;;<br />     lea &#40;edx, &#91;eax+eax*2&#93;&#41;;<br />     mov &#40;edx, &#91;esi+ecx&#93;&#41;;<br />//     stdout.put&#40;&#40;type uns32 eax&#41;, nl&#41;;<br /><br />     add &#40;8, ecx&#41;;<br />     mov &#40;ecx, numprimes&#41;;<br /><br />     cmp &#40;ecx, memtoalloc&#41;;<br />     jne n0;<br /><br />     mov &#40;eax, number&#41;;<br /><br />// Check clocks<br />          rdtsc;                       // Second measure of time<br />          push &#40;edx&#41;;<br />          push &#40;eax&#41;;<br /><br />// Completion Message<br />     stdout.put &#40; nl, nl,&quot;Search Stopped at Time&#58; &quot;&#41;;<br />     time.curTime&#40;t&#41;;<br />     stdout.puti16Size&#40;t.hours, 2, '0'&#41;; stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.mins, 2, '0'&#41;;   stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.secs, 2, '0'&#41;;<br /><br />// Report<br />     mov &#40;ecx, numprimes&#41;;<br />     shr &#40;3, ecx&#41;;<br />     stdout.put &#40;nl, &#40;type uns32 ecx&#41;, &quot; Primes found  in &quot;&#41;;<br /><br />// Retrieve 2nd rdtsc<br />          pop &#40;eax&#41;;<br />          pop &#40;edx&#41;;<br /><br />          sub &#40;&#91;esp&#93;, eax&#41;;             // subtract first from second<br />          sbb &#40;&#91;esp+4&#93;,edx&#41;;            // result in EDX&#58;EAX<br /><br />          add &#40;8, esp&#41;;                 // remove first edx, eax from stack<br /><br />    if &#40;edx=0&#41; then <br />         stdout.putu32&#40;eax&#41;;<br />         stdout.put&#40;&quot; clock cycles = &quot;, nl&#41;;<br />    else<br />         stdout.put &#40;&quot;$&quot;,edx,&quot; &quot;,eax, &quot; clock cycles = &quot;, nl&#41;;<br />    endif;<br /><br /><br />end primes;</code></pre></div>
    <div class="meta">Posted on 2003-06-26 21:39:19 by V Coder</div>
   </div>
   <div class="post" id="post-108376">
    <div class="subject"><a href="#post-108376">prime numbers algorithm - very slow</a></div>
    <div class="body">Hints on further optimization purely as a matter of programming challenge are welcome.<br /><br />I accept that this algorithm is WAAYYY slow. For discussion of better routines go to the link in the first panel.<br /><br />(Yeah, I code in HLA, whcih uses brackets, and <strong>source, destination</strong>. The Intel <strong>dest, source</strong> order used by most other Assemblers is <u>obviously</u> <em>wrong</em>. But its more popular So what?!?)</div>
    <div class="meta">Posted on 2003-06-26 21:48:07 by V Coder</div>
   </div>
   <div class="post" id="post-108475">
    <div class="subject"><a href="#post-108475">prime numbers algorithm - very slow</a></div>
    <div class="body">Erm, what do you mean, &quot;wrong&quot;? Isn't that up to Intel to decide? Since they're, um, the <strong>makers</strong> of the processor and all.</div>
    <div class="meta">Posted on 2003-06-27 17:03:00 by Sephiroth3</div>
   </div>
   <div class="post" id="post-108484">
    <div class="subject"><a href="#post-108484">prime numbers algorithm - very slow</a></div>
    <div class="body">I felt is was wrong, too.  But that is coming from 680x0 programming.  Now it seems very natural and I wouldn't have it any other way.  I can really understand where <strong>V Coder</strong> is coming from.</div>
    <div class="meta">Posted on 2003-06-27 18:35:29 by bitRAKE</div>
   </div>
   <div class="post" id="post-108601">
    <div class="subject"><a href="#post-108601">prime numbers algorithm - very slow</a></div>
    <div class="body">My apologies: My 'HLA versus other assemblers' barb was probably more fitted to the Crusades, right? ;)<br /><br />My real point was this though: &quot;Don't just complain that it is written in HLA. Plus, in case you're trying to understand the code, remember to reverse instruction order.&quot;<br /><br />I sometimes code in MASM format and include it in my HLA code with #asm ........ #endasm. However, I am trying to avoid needing to do so. But the algorithm can be understood and copied easily once these differences are noted beforehand...</div>
    <div class="meta">Posted on 2003-06-28 21:57:17 by V Coder</div>
   </div>
   <div class="post" id="post-108603">
    <div class="subject"><a href="#post-108603">prime numbers algorithm - very slow</a></div>
    <div class="body"><div class="quote">// Clear memory<br />     mov (memaddr, esi);<br />     xor (eax, eax);      // Fill mem with 0<br />     mov (memtoalloc, ecx);<br />     sub (4, ecx);<br />clm1:<br />     mov (edx, );<br /><br />     sub (4, ecx);<br />     jns clm1;</div><br /><br />Why do you clear <strong>eax</strong>, though store <strong>edx</strong> into memory?</div>
    <div class="meta">Posted on 2003-06-28 22:18:31 by comrade</div>
   </div>
   <div class="post" id="post-108612">
    <div class="subject"><a href="#post-108612">prime numbers algorithm - very slow</a></div>
    <div class="body"><strong>comrade</strong><br /><br />Now that is a major error which I had not noticed!!! Thanks.<br /><br />I copied that code from another program I have been working on, and it was corrected there already so long ago (just over a month perhaps) that I cannot remember correcting it...<br /><br />(Strictly speaking, of course, I need not clear the memory at all, since the data will be written to the memory whenever the index is updated to reflect there is another prime found... This is probably why the program does not report any error, and the list of primes is correct.)</div>
    <div class="meta">Posted on 2003-06-29 00:56:51 by V Coder</div>
   </div>
   <div class="post" id="post-108849">
    <div class="subject"><a href="#post-108849">prime numbers algorithm - very slow</a></div>
    <div class="body">V Coder wrote:<br /><strong><span style="font-size:9px>However, the algorithm still works in O n^2 time, which is very inefficient</span></strong><br /><br />Most algorithms that are available run in polynomial time so O(n2) isn't bad.</div>
    <div class="meta">Posted on 2003-06-30 22:35:48 by Poimander</div>
   </div>
  </div>
 </body>
</html>