<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Simple fahrenheight to celsius function using sse - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=22458" />
    <link rel="next" href="../?id=22458&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=22458">Simple fahrenheight to celsius function using sse</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=22458&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=22458&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="22458" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=22458&amp;page=2">&gt;</a><a href="../?id=22458&amp;page=2">&raquo;</a></form>   <div class="post" id="post-168537">
    <div class="subject"><a href="#post-168537">Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">I&#39;ve just started using sse but quicly ran into a problem... How can I &quot;mov&quot; the value of a 128bit to a string?<br /><br /><pre><code>FireToCelc proc x:DWORD<br />; formula: (5*(x-32))/9<br />; or: (0.5555555555555556)*(x-32)<br />&nbsp; &nbsp; movss xmm0, x<br />&nbsp; &nbsp; movss xmm1, _32<br />&nbsp; &nbsp; subss xmm0, xmm1 ; xmm0 = x - 32<br />&nbsp; &nbsp; movss xmm1, _5o9<br />&nbsp; &nbsp; mulss xmm0, xmm1 ; xmm0 = (0.5555555555555556)*(x-32)<br /><br />&nbsp; &nbsp; ret<br />FireToCelc endp</code></pre><br /><br />Is there some kind of TwordToAscii function?</div>
    <div class="meta">Posted on 2005-12-04 12:32:55 by Lenin</div>
   </div>
   <div class="post" id="post-168538">
    <div class="subject"><a href="#post-168538">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">C library (msvcrt.dll) has the <strong><a target="_blank" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_crt_sprintf.2c_.swprintf.asp">sprintf</a></strong> function. Calling it with &quot;%f&quot; (or &quot;%+.1f&quot; if you want the temperature) format is the fastest method. Alternatively, you can write your own &quot;float2ascii&quot;.</div>
    <div class="meta">Posted on 2005-12-04 12:44:31 by ti_mo_n</div>
   </div>
   <div class="post" id="post-168542">
    <div class="subject"><a href="#post-168542">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">Using: <pre><code>&nbsp; &nbsp; invoke wsprintf, addr buffer, addr lpFmt, xmm0</code></pre><br /><br />Gives me an error.... Do I need to first convert the 128bit register into a 32bit one?</div>
    <div class="meta">Posted on 2005-12-04 13:21:23 by Lenin</div>
   </div>
   <div class="post" id="post-168543">
    <div class="subject"><a href="#post-168543">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">not <strong>user32.dll</strong>&#39;s wsprintf, but <strong>msvcrt.dll</strong>&#39;s sprintf. wsprintf doesn&#39;t support floating point values.<br /><br />sprintf should be called exactly the same as wsprintf, but you CAN&#39;T supply a XMM register as the operand, because it&#39;s both 128-bit and packed. Store the result somewhere in memory and supply that value as the third parameter.<br /><br />something like:<br /><br /><pre><code>movss , xmm0<br />invoke sprintf, addr buffer, addr lpFmt, result</code></pre><br /><br />and make sure that the buffer is large enough to hold the string. Otherwise you may get &#39;buffer overrun&#39; which may lead to Denial of Service. I always make the buffers 256-bytes long ^^&quot;</div>
    <div class="meta">Posted on 2005-12-04 13:25:28 by ti_mo_n</div>
   </div>
   <div class="post" id="post-168546">
    <div class="subject"><a href="#post-168546">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">Oh&nbsp; :P Still I don&#39;t know how to link to msvcrt.dl ... I searched trough masm32&#39;s include and lib folders but couldn&#39;t find anything.... </div>
    <div class="meta">Posted on 2005-12-04 14:01:35 by Lenin</div>
   </div>
   <div class="post" id="post-168548">
    <div class="subject"><a href="#post-168548">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">the include file isn&#39;t really necessary (at least in TASM ^^&quot;). As for the lib: use something like &quot;implib&quot; to make LIBs from DLLs. implib produces LIBs for TASM.<br /><br />That&#39;s why I use(d) TASM: much less trouble :P ;)<br /><br />This might be useful if you opt to write your own float2ascii: <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=22401.0">&gt; * &lt;</a></div>
    <div class="meta">Posted on 2005-12-04 14:09:33 by ti_mo_n</div>
   </div>
   <div class="post" id="post-168553">
    <div class="subject"><a href="#post-168553">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">Would it be something like this then?<br /><br /><pre><code>FloatToAscii proc float:QWORD, lpOut:DWORD<br />&nbsp; &nbsp; LOCAL temp:DWORD, temp2:DWORD<br />.data<br />&nbsp; &nbsp; Milion dd 1000000<br />.code<br />&nbsp; &nbsp; ; turn to truncation mode?<br />&nbsp; &nbsp; finit<br />&nbsp; &nbsp; fld float<br />&nbsp; &nbsp; fist temp<br />&nbsp; &nbsp; fsub temp<br />&nbsp; &nbsp; ; turn to round-to-nearest-integer mode?<br />&nbsp; &nbsp; fmul Milion<br />&nbsp; &nbsp; fistp temp2<br />&nbsp; &nbsp; ; now reprent it as &quot;temp . temp2&quot;<br />&nbsp; &nbsp; ret<br />FloatToAscii endp</code></pre></div>
    <div class="meta">Posted on 2005-12-04 17:17:48 by Lenin</div>
   </div>
   <div class="post" id="post-168554">
    <div class="subject"><a href="#post-168554">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">Store million as 1000000.0 (floating point value). finit initializes the FPU, so you should do finit first and change the rounding mode AFTER it. A good habit is to do one &quot;finit&quot; at the beginning of your program if you plan to use the FPU. No more <strong>finit</strong>s are required (unless you&#39;re doing very funny things ^^&quot;).<br /><br />1. enable truncation:<br /><pre><code>fstcw <br />or , 0300h<br />fldcw </code></pre><br /><br />2. enable rounding to nearest integer:<br /><pre><code>fstcw <br />and , NOT 0300h ; 1111110011111111 (0FCFFh)<br />fldcw </code></pre><br /><br />controlword is a 16-bit (word) variable<br /><br />You can also write this proc using the SSE.<br /><br />After this proc you have 2 integers, so use user32.dll&#39;s &#39;wsprintf&#39; function like this:<br /><br /><pre><code>invoke wsprintf, addr buffer, addr format, temp, temp2</code></pre><br />1. &quot;buffer&quot; must be large enough to store the string<br />2. &quot;format&quot; must be &quot;%d.%d&quot; (note the decimal point between each %d. you can use comma instead of dot)<br /><br />after all of this you can simply do<br /><pre><code>invoke MessageBox, 0, addr buffer, 0, 0</code></pre><br />:)</div>
    <div class="meta">Posted on 2005-12-04 17:43:34 by ti_mo_n</div>
   </div>
   <div class="post" id="post-168555">
    <div class="subject"><a href="#post-168555">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">Thanks a lot for your help :) Still I&#39;m getting some weird results...<br /><br />Here for example:<br /><pre><code>.data<br />&nbsp; &nbsp; _5o9 REAL4 0.5555555555555556f<br />.code<br />&nbsp; &nbsp; invoke FloatToAscii, _5o9, addr buffer<br />&nbsp; &nbsp; invoke MessageBox, eax, 0, MB_OK ; gives me 1.555556 , almost right<br /></code></pre><br /><br />But when I use it with my procedure....<br /><pre><code><br />FireToCelc proc x:DWORD<br />; formula: (0.5555555555555556)*(x-32)<br />&nbsp; &nbsp; movss xmm0, x<br />&nbsp; &nbsp; movss xmm1, _32<br />&nbsp; &nbsp; subss xmm0, xmm1 ; xmm0 = x - 32<br />&nbsp; &nbsp; movss xmm1, _5o9<br />&nbsp; &nbsp; mulss xmm0, xmm1 ; xmm0 = (0.5555555555555556)*(x-32)<br />&nbsp; &nbsp; movss result, xmm0<br />&nbsp; &nbsp; invoke FloatToAscii, result, addr buffer<br />&nbsp; &nbsp; ret<br />FireToCelc endp<br /><br />FloatToAscii proc float:DWORD, lpOut:DWORD<br />&nbsp; &nbsp; LOCAL temp:DWORD, temp2:DWORD, cWord:WORD<br />.data<br />&nbsp; &nbsp; format db &quot;%d.%d&quot;,0<br />&nbsp; &nbsp; Milion REAL4 1000000.0<br />.code<br />&nbsp; &nbsp; ; turn to truncation mode<br />&nbsp; &nbsp; fstcw cWord<br />&nbsp; &nbsp; or cWord, 0300h<br />&nbsp; &nbsp; fldcw cWord<br /><br />&nbsp; &nbsp; fld float<br />&nbsp; &nbsp; fist temp<br />&nbsp; &nbsp; fsub temp<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ; turn to round-to-nearest-integer mode<br />&nbsp; &nbsp; fstcw cWord<br />&nbsp; &nbsp; and cWord, not 0300h<br />&nbsp; &nbsp; fldcw cWord<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; fmul Milion<br />&nbsp; &nbsp; fistp temp2<br />&nbsp; &nbsp; invoke wsprintf, lpOut, addr format, temp, temp2<br />&nbsp; &nbsp; mov eax, lpOut<br />&nbsp; &nbsp; ret<br />FloatToAscii endp</code></pre><br /><br />No matter what value I enter, I always get -18.-2147483648....</div>
    <div class="meta">Posted on 2005-12-04 19:35:31 by Lenin</div>
   </div>
   <div class="post" id="post-168556">
    <div class="subject"><a href="#post-168556">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">oops ^^&quot; it&#39;s not 0300h but 0C00h (and &quot;NOT 0C00h&quot; instead of &quot;NOT 0300h&quot;) :)Â  &quot;0300h&quot; and &quot;NOT 0300h&quot; switch between 64-bit precision and 32-bit precision, respectively.<br /><br />and do &quot;fisub temp&quot; instead of &quot;fsub temp&quot;.<br /><br />now you should get 0.555556 from 0.555555555555555555555.<br /><br />remember to NOT multiply by more than 1&#39;000&#39;000&#39;000 otherwise the result will be larger than 0xFFFFFFFF so it won&#39;t fit in 32-bit variable. if yuo want more than 9 places, then repeat the steps (fistp-&gt;fsub-&gt;fmul) to obtain them.<br /><br />as for the second bug: it must be somewhere inside the SSE function. confirm that the result is correct before calling FloatToAscii.<br /><br />/edit<br /><br />the SSE function is correct. &#39;FloatToAscii&#39; should not end with mov eax, lpOut :) add &quot;mov , temp&quot; and &quot;mov , temp2&quot;Â  or whatever. you&#39;re not returning/storing the results, so they get lost.</div>
    <div class="meta">Posted on 2005-12-04 20:01:03 by ti_mo_n</div>
   </div>
   <div class="post" id="post-168560">
    <div class="subject"><a href="#post-168560">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">I don&#39;t see why FloatToAscii shouldn&#39;t return a pointer to the buffer it altered... I was checking functions like itoa and they do return a pointer to a buffer.... Since after the proc is called the buffer contains the final result I don&#39;t see the need to return the two dwords obtained trough the proccess... Still I could be totally wrong and in that case please corect me ;)<br /><br />I did some minor changes in the code... Now FloatToAscii seems to be working but I can&#39;t make it work with FireToCelc... Now it&#39;s always returning -17.777779 ...<br /><br /><pre><code>.data<br />&nbsp; &nbsp; _32&nbsp; REAL4 32.0f<br />&nbsp; &nbsp; _5o9 REAL4 0.5555555555555556f<br />.code<br />&nbsp; &nbsp; (...)<br />&nbsp; &nbsp; invoke GetDlgItemInt, hWnd, IDC_FIREN, NULL, FALSE<br />&nbsp; &nbsp; invoke FireToCelc, eax<br />&nbsp; &nbsp; invoke FloatToAscii, eax, addr buffer<br />&nbsp; &nbsp; invoke SetDlgItemText, hWnd, IDC_CELSIUS, addr buffer<br />&nbsp; &nbsp; (...)<br /><br />FireToCelc proc x:DWORD<br />.data<br />&nbsp; &nbsp; result dd ?<br />.code<br />; formula: (0.5555555555555556)*(x-32)<br />&nbsp; &nbsp; movss xmm0, x<br />&nbsp; &nbsp; movss xmm1, _32<br />&nbsp; &nbsp; subss xmm0, xmm1 ; xmm0 = x - 32<br />&nbsp; &nbsp; movss xmm1, _5o9<br />&nbsp; &nbsp; mulss xmm0, xmm1 ; xmm0 = (0.5555555555555556)*(x-32)<br />&nbsp; &nbsp; movss result, xmm0<br />&nbsp; &nbsp; mov eax, result<br />&nbsp; &nbsp; ret<br />FireToCelc endp<br /><br />FloatToAscii proc float:DWORD, lpOut:DWORD<br />&nbsp; &nbsp; LOCAL temp:DWORD, temp2:DWORD, cWord:WORD<br />.data<br />&nbsp; &nbsp; format db &quot;%d.%d&quot;,0<br />&nbsp; &nbsp; Milion REAL4 1000000.0<br />.code<br />&nbsp; &nbsp; ; turn to truncation mode<br />&nbsp; &nbsp; fstcw cWord<br />&nbsp; &nbsp; or cWord, 0C00h<br />&nbsp; &nbsp; fldcw cWord<br /><br />&nbsp; &nbsp; fld float<br />&nbsp; &nbsp; fist temp<br />&nbsp; &nbsp; fisub temp<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ; turn to round-to-nearest-integer mode<br />&nbsp; &nbsp; fstcw cWord<br />&nbsp; &nbsp; and cWord, not 0C00h<br />&nbsp; &nbsp; fldcw cWord<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; fmul Milion<br />&nbsp; &nbsp; fabs ; to avoid having numbers like -1.-486<br />&nbsp; &nbsp; fistp temp2<br />&nbsp; &nbsp; invoke wsprintf, lpOut, addr format, temp, temp2<br />&nbsp; &nbsp; mov eax, lpOut<br />&nbsp; &nbsp; ret<br />FloatToAscii endp<br />end start</code></pre></div>
    <div class="meta">Posted on 2005-12-04 23:21:03 by Lenin</div>
   </div>
   <div class="post" id="post-168564">
    <div class="subject"><a href="#post-168564">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">Sorry, I missed the &quot;wsprintf&quot; line. It was late and I was sleepy :P<br /><br />As for the FireToCelc: You pass an integer value, while you should pass a single-precision floating point value. There IS a way to make this function work with integers, but it will require SSE2 (load scalar integer -&gt; convert to single-precision float, if I recall correclty). The simpliest (but definitely NOT the fastest) way to convert integer to float is &quot;fild -&gt; fstp&quot; pair with truncation enabled.</div>
    <div class="meta">Posted on 2005-12-05 06:40:39 by ti_mo_n</div>
   </div>
   <div class="post" id="post-168570">
    <div class="subject"><a href="#post-168570">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body"><pre><code>FireToCelc proc x:DWORD<br />.data<br />&nbsp; &nbsp; result dd ?<br />.code<br />; formula: (0.5555555555555556)*(x-32)<br />&nbsp; &nbsp; fld x<br />&nbsp; &nbsp; fstp result<br />&nbsp; &nbsp; movss xmm0, result<br />&nbsp; &nbsp; movss xmm1, _32<br />&nbsp; &nbsp; subss xmm0, xmm1 ; xmm0 = x - 32<br />&nbsp; &nbsp; movss xmm1, _5o9<br />&nbsp; &nbsp; mulss xmm0, xmm1 ; xmm0 = (0.5555555555555556)*(x-32)<br />&nbsp; &nbsp; movss result, xmm0<br />&nbsp; &nbsp; mov eax, result<br />&nbsp; &nbsp; ret<br />FireToCelc endp</code></pre><br /><br />Keep getting -17.777779 ... I wonder if the error is in &quot;movss result, xmm0&quot;, is result large enough to hold xmm0?</div>
    <div class="meta">Posted on 2005-12-05 11:28:45 by Lenin</div>
   </div>
   <div class="post" id="post-168571">
    <div class="subject"><a href="#post-168571">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">fild x, not fld x. you&#39;re loading an integer. The SSE part is fine - I&#39;ve tested it.<br /><br />movss result, xmm0 moves 32-bit floating point value located at the beginning (bits: 0-31) of the xmm register, NOT the whole xmm register.Â  scalar operations operate on bits 0-31 of SSE registers. they produce single result from single operands. it is 1/4 of SSE&#39;s power. Packed SSE is the true power: they produce 4 results from 8 operands (multiple data) from single instruction (hence the name:Â  SIMD ). scalar sse is good way to omit using the FPU. all the things in this topic can be written using scalar sse only.<br /><br />packed version is: movups or movaps. it loads 128-bits (4 single precision floating point values [16 bytes]) from/(to) a xmm register to/(from) a memory location (either <strong><u>A</u></strong>ligned, or <strong><u>U</u></strong>naligned, hence the names: mov<strong><u>a</u></strong>ps and mov<strong><u>u</u></strong>ps). the aligned version requires that the memory operand is 16-byte aligned.</div>
    <div class="meta">Posted on 2005-12-05 12:34:42 by ti_mo_n</div>
   </div>
   <div class="post" id="post-168573">
    <div class="subject"><a href="#post-168573">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">Oh thanks a lot for the explanation :) May I bother you a little more? :P Now everything is running finely but I would like to know how I would rewrite the FloatToAscii function using sse or sse2... I beleive there&#39;s no need to use packed sse here, is it? I would just like to know if there are opcodes to operate on integers on sse, and if so is there some kind of reference with it&#39;s opcodes?</div>
    <div class="meta">Posted on 2005-12-05 13:07:28 by Lenin</div>
   </div>
   <div class="post" id="post-168574">
    <div class="subject"><a href="#post-168574">MMX SSE SSE2 explaination, SSE version of float 2 ascii</a></div>
    <div class="body">To deal with integers inside XMM reigsters you need SSE2.<br /><br />MMX instructions operate on MMX registers (which are alias to FPU registers) and are integer instructions. They&#39;re great to write audio or video codecs, for example (hence the name: <strong><u>M</u></strong>ulti<strong><u>m</u></strong>edia E<strong><u>x</u></strong>tensions).<br /><br />SSE intructions operate on 32-bit (single precision) floating point values when using XMM registers, and on Integer values when using MMX registers. They&#39;re designed for 3d functions where they can aid video cards. They were supposed to be Intel&#39;s response to AMD&#39;s 3dnow! instructions. 3dnow! instructions use 3dnow! registers (which are alias to FPU registers, like MMX). 3dnow! registers are 64-bit and they hold 2 single-precision (32 bit) floating-point values, each.<br /><br />SSE2 instructions operate on both MMX registers and XMM registers and are both single-precision FP, and integer intructions. Additinally they support &#39;integer &lt;-&gt; floating point&#39; conversion and can operate on 64-bit (double precision) floating-point values (and the support the appropriate conversion methods). They&#39;re designed to aid advanced maths applications, like speech recognition, etc.<br /><br />Of course everyone can find their own application to these instructions :)<br /><br />After this short introduction ( :P ) we see that we need either 3dnow! or SSE2 :) Let&#39;s stick to SSE2 (mainly because I&#39;m not familiar enough with AMD&#39;s architecture ^^&quot; ).<br /><br />SSE, SSE2 and MMX instructions can be freely mixed inside the application. You have to remember 2 things, though: some instructions (MMX ones and few SSE/2) require a MMX register as an operand (these are 64-bit operations) and some instructions require a XMM register a an operand (these are 128-bit instructions). The second thing is that when Intel added the SSE2 they also increased the functionality of some already existing SSE and MMX instructions. So if you have SSE2-capable processor, you may -for example- use a SSE instruction with a MMX register, but someone with a CPU supporting SSE, but not SSE2, will get Undefined Instruction (#UD) Exception, regardlles of the fact that it&#39;s a SSE instrucion. So you have to remember that SSE2 is not only new instructions, but also an &#39;upgrade&#39; of the SSE and MMX ones. Don&#39;t forget about it if you want your app to work on a wide variety of CPUs. ...Well, to be honest - you don&#39;t have to care, because nowadays almost everyone has Athlon XP or Pentium 4 :P But it&#39;s nice to check wheter the CPU supports MMX/SSE/SSE2 or not, before using a MMX/SSE/SSE2 function :) Windows XP requires a Pentium-class CPU, so it&#39;s guaranteed that the win32 app may use CPUID instruction (you don&#39;t have to check everything from 8086 through 286, 386, 486 to pentium :) ).<br /><br />...But let&#39;s get to the point already ^^&quot;<br /><br />As I&#39;ve said earlier: Scalar instructions keep their operands and results in low-order dword (bits: 0-31) of XMM registers. Packed instructions use whole XMM register to produce multiple data from multiple operands in one instruction.<br /><br />To load an integer into a XMM register you use MOVD instruction. MOVD instruction is a MMX instruction, but requires SSE2 to operate on XMM registers. CVTSI2SS instruction converts a scalar integer and stores it in a XMM register. This conversion instruction actually LOADS and converts the value, so we don&#39;t need the MOVD here (I mentioned it just for you to know ;) ).<br /><br />So the only thing you must add is:<br /><br /><pre><code>CVTSI2SS xmm0, x</code></pre><br /><br />(and pray for your compiler to support SSE2 :P )<br /><br />CVTSI2SS means: <strong><u>C</u></strong>o<strong><u>v</u></strong>er<strong><u>t</u></strong> <strong><u>S</u></strong>calar <strong><u>I</u></strong>nteger <strong><u>2</u></strong>  <strong><u>S</u></strong>calar <strong><u>S</u></strong>ingle-precision value.<br /><br />That&#39;s it. After this instruction you have a ready-to-work floating-point value :)<br /><br />You must admit that it&#39;s a heck of a long introduction for such a short thing to say :P<br /><br />Now the FloatToAscii function:<br /><br />Both the FPU and SSE2 each have their own control register which controls how certain operations are handled. Especially precision and rounding mode. With SSE2 everything is simple: there are seperate instructions for single-precision operations (SSE) and separate ones for double-precision operations. With FPU we can control it by properly setting bits 8 and 9. So simply it means that when we switch to SSE we have one thing less to worry about :) Now the rounding mode: SSE operation depend on the MXCSR register. This register works much like FPU control word, except that this one is 32-bit (FPU&#39;s control word is... well.. word :P ). In order to alter it, we need to store it somewhere (just like in case of FPU&#39;s CW), set the flags as we want it, and load it back into the CPU. We store the MXCSR with the STMXCSR instruction (&quot;Store MXCSR&quot;) and load it back with LDMXCSR instruction (&quot;Load MXCSR&quot;). After we have stored it, we alter the bits 13 and 14 which control the rounding mode (we need to set them both if we need truncaton and clear them both if we need round-to-nearest-integer).<br /><br />The algo goes as follows:<br /><br /><pre><code>cvttss2si xmm0, floatÂ  Â ;xmm0 = integral part of &#39;float&#39; stored as integer<br />movssÂ  Â  Â xmm1, floatÂ  Â ;xmm1 = float<br />cvtsi2ssÂ  xmm0, xmm0Â  Â  ;xmm0 = integral part of float stored as &#39;float&#39;<br />subssÂ  Â  Â xmm1, xmm0Â  Â  ;xmm1 = fractional part of &#39;float&#39;<br />movssÂ  Â  Â xmm2, million ;xmm2 = multiplier<br />cvttss2si temp, xmm0<br />mulssÂ  Â  Â xmm1, xmm2Â  Â  ;xmm1 = multiplied fractional part<br />cvttss2si temp2, xmm1<br />invoke wsprintf.... blah blah blah</code></pre><br /><br />If I didn&#39;t make any mistake, then this should do it.<br /><br />one word about the conversion instructions: note the double &quot;T&quot; in 3 of 4 conversions used above. this additional &quot;T&quot; means that the conversion should be made with truncation REGARDLESS of the MXCSR register. These are very nice instrustions, because they allow us to perform many differect conversions without the need to alter the MXCSR in any way :)<br /><br />The above code has a single small dependency (compared to 8 using the FPU code), the code is free of any redundant instructions (like setting/resetting the control word), we don&#39;t need the additional variable to store the control word or MXCSR, and ..hey! it&#39;s SSE! It&#39;s cool to code with :P :)<br /><br />I hope the above works properly.<br /><br />You may ask why we need 2 conversions, and how does the whole aglorithm works. Here comes the explaination:<br /><br />cvttss2si xmm0, float<br />This first instruction loads the &#39;float&#39; variable, converts it to integer using truncation (regardless fo MXCSR) and stores it as scalar integer in bits 0-31 inside the XMM0. after this we have integer (which is integral part od &quot;float&quot;, because the fractional part gets truncated) in low-order dword of xmm0.<br /><br />movssÂ  Â  Â xmm1, float<br />This one is straightforward: it simply moves the &quot;float&quot; into bits 0-31 of xmm1 (scalar single precision value)<br /><br />cvtsi2ssÂ  xmm0, xmm0<br />this one converts the contents of xmm0. you see: we have stored an INTEGER inside the xmm, bu we need a FLOAT to substract it later. That&#39;s why we must convert this integer to float.<br /><br />subssÂ  Â  Â xmm1, xmm0<br />now we substract one scalar single-precision from another.<br /><br />movssÂ  Â  Â xmm2, million<br />now we load the multiplier (1000000.0)<br /><br />cvttss2si temp, xmm0<br />the value of xmm0 (which is scalar single-precision float) gets converted into an integer and stored in a memory operand (&quot;temp&quot;)<br /><br />mulssÂ  Â  Â xmm1, xmm2<br />now the fractional part gets multiplied<br /><br />cvttss2si temp2, xmm1<br />the same is done as it was to the xmm0<br /><br />Example:<br />&#39;float&#39; = 321.123<br /><br /><pre><code>cvttss2si xmm0, floatÂ  Â ;xmm0 = 321<br />movssÂ  Â  Â xmm1, flaotÂ  Â ;xmm1 = 321.123<br />cvtsi2ssÂ  xmm0, xmm0Â  Â  ;xmm0 = 321.0<br />subssÂ  Â  Â xmm1, xmm0Â  Â  ;xmm1 = 0.123<br />movssÂ  Â  Â xmm2, million ;xmm2 = 1000000.0<br />cvttss2si temp, xmm0Â  Â  ;store 321<br />mulssÂ  Â  Â xmm1, xmm2Â  Â  ;xmm1 = 123000.0<br />cvttss2si temp2, xmm1Â  Â ;store 123000</code></pre><br /><br />when you display it, you&#39;ll get &quot;321.123000&quot;<br /><br />I think that&#39;s all.</div>
    <div class="meta">Posted on 2005-12-05 13:55:16 by ti_mo_n</div>
   </div>
   <div class="post" id="post-168575">
    <div class="subject"><a href="#post-168575">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">Thanks a lot for the wonderfull explanation :) It&#39;ll be a refference to me from now on...<br /><br />Your code didn&#39;t compile, so I had to change it a little...<br /><br /><pre><code>FloatToAscii proc float:DWORD, lpOut:DWORD<br />&nbsp; &nbsp; LOCAL temp:DWORD, temp2:DWORD<br />.data<br />&nbsp; &nbsp; format db &quot;%d.%d&quot;,0<br />&nbsp; &nbsp; million REAL4 1000000.0<br />.code<br />&nbsp; &nbsp; cvttss2si eax, float&nbsp; &nbsp; ;xmm0 = integral part of &#39;float&#39; stored as integer<br />&nbsp; &nbsp; movss&nbsp; &nbsp;  xmm0, float&nbsp;  ;xmm1 = float<br />&nbsp; &nbsp; cvtsi2ss&nbsp; xmm1, eax&nbsp; &nbsp;  ;xmm3 = integral part of float stored as &#39;float&#39;<br />&nbsp; &nbsp; subss&nbsp; &nbsp;  xmm0, xmm1&nbsp; &nbsp; ;xmm1 = fractional part of &#39;float&#39;<br />&nbsp; &nbsp; movss&nbsp; &nbsp;  xmm2, million ;xmm2 = multiplier<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;  temp, eax<br />&nbsp; &nbsp; mulss&nbsp; &nbsp;  xmm0, xmm2<br />&nbsp; &nbsp; cvttss2si eax, xmm0<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;  temp2, eax<br />&nbsp; &nbsp; invoke&nbsp; &nbsp; wsprintf, lpOut, addr format, temp, temp2<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;  eax, lpOut<br />&nbsp; &nbsp; ret<br />FloatToAscii endp</code></pre><br /><br />Thanks you once again :)</div>
    <div class="meta">Posted on 2005-12-05 16:22:20 by Lenin</div>
   </div>
   <div class="post" id="post-168576">
    <div class="subject"><a href="#post-168576">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">Oh yes - I forgot that the conversion instructions must reference the GP registers as their destinations <img src="http://img202.imageshack.us/img202/4277/s22oy.gif" /><br /><br /><div class="quote">The source operand can be an XMM register or a 32-bit memory location. The destination operand is a general-purpose register.</div></div>
    <div class="meta">Posted on 2005-12-05 16:26:19 by ti_mo_n</div>
   </div>
   <div class="post" id="post-168581">
    <div class="subject"><a href="#post-168581">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">Hehe I can&#39;t sleep so I&#39;m trying to improve the algo... I&#39;m quite pleased with the function, but there are some results that are annoyng me... They are having zeros at the end of decimal places ie: 1.990000 and negative numbers having two negative signs ie: -7.-149 ....<br /><br />I have an idea on the first one: Get how many decimal digits are there, like there are 4 decimal digits in 0.1234, then use that number to&nbsp;  select a member of an array that has x zeros.... Look:<br /><br /><pre><code>&nbsp; &nbsp; array REAL4 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0<br /><br />&nbsp; &nbsp; num = 0.1234<br />&nbsp; &nbsp; len = getDecimaldigits(num) ; len = 4<br />&nbsp; &nbsp; mulss xmm0, array[(len-1)*4] ; xmm0 = xmm0*10000.0<br />&nbsp; &nbsp; cvttss2si ecx, xmm0 ; ecx = 1234<br />&nbsp; &nbsp; (etc...)</code></pre><br /><br />The problem here is how to get the number of decimal digits... The only way I can think of is to convert it into a string and then strlen it... But that would be terribly unefficient...<br /><br />I don&#39;t know how I would solve the second one tough, do you know wich bits store the sign of the number?<br /><br />Here&#39;s the code so far...<br /><pre><code>FloatToAscii proc float:DWORD, lpOut:DWORD<br />.data<br />&nbsp; &nbsp; format db &quot;%d.%d&quot;,0<br />&nbsp; &nbsp; million REAL4 1000000.0<br />.code<br />&nbsp; &nbsp; cvttss2si eax, float&nbsp; &nbsp; ;eax = integral part of &#39;float&#39; stored as integer<br />&nbsp; &nbsp; movss&nbsp; &nbsp;  xmm0, float&nbsp;  ;xmm1 = float<br />&nbsp; &nbsp; cvtsi2ss&nbsp; xmm1, eax&nbsp; &nbsp;  ;xmm3 = integral part of float stored as &#39;float&#39;<br />&nbsp; &nbsp; subss&nbsp; &nbsp;  xmm0, xmm1&nbsp; &nbsp; ;xmm1 = fractional part of &#39;float&#39;<br />&nbsp; &nbsp; mulss&nbsp; &nbsp;  xmm0, million<br />&nbsp; &nbsp; cvttss2si ecx, xmm0<br />&nbsp; &nbsp; invoke&nbsp; &nbsp; wsprintf, lpOut, addr format, eax, ecx<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;  eax, lpOut<br />&nbsp; &nbsp; ret<br />FloatToAscii endp</code></pre></div>
    <div class="meta">Posted on 2005-12-06 00:56:48 by Lenin</div>
   </div>
   <div class="post" id="post-168585">
    <div class="subject"><a href="#post-168585">Re: Simple fahrenheight to celsius function using sse</a></div>
    <div class="body">ti_mo_n,<br /><br />Why don&#39;t you save what you have written into our x86 book?&nbsp; ;)<br /><br />Regards,<br />Victor</div>
    <div class="meta">Posted on 2005-12-06 04:36:50 by roticv</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=22458&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=22458&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="22458" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=22458&amp;page=2">&gt;</a><a href="../?id=22458&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>