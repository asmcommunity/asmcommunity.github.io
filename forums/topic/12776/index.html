<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>win32asm equivalent of C's malloc? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=12776" />
    <link rel="next" href="../?id=12776&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=12776">win32asm equivalent of C's malloc?</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=12776&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=12776&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="12776" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=12776&amp;page=2">&gt;</a><a href="../?id=12776&amp;page=2">&raquo;</a></form>   <div class="post" id="post-98969">
    <div class="subject"><a href="#post-98969">win32asm equivalent of C's malloc?</a></div>
    <div class="body">as the title suggests :D<br /><br />obviously i cant use interrupts...so how would i go abt doing sumthing like that...or would i just have to set aside space in the data section...fanks</div>
    <div class="meta">Posted on 2003-04-23 23:36:32 by AnotherWay83</div>
   </div>
   <div class="post" id="post-98983">
    <div class="subject"><a href="#post-98983">win32asm equivalent of C's malloc?</a></div>
    <div class="body">AnotherWay83,<br /><br />Win32 is in fact well endowed with memory allocation functions and they can be tailored more or less to what you require. With lots of small allocations GlobalAlloc() has the correct granularity as does the OLE string memory functions, if you want access to the heap memory, HeapAlloc() works fine and you can allocate system memory with a memory mapped file which is of global scope which is very useful for inter app communication.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2003-04-24 01:01:20 by hutch--</div>
   </div>
   <div class="post" id="post-98993">
    <div class="subject"><a href="#post-98993">win32asm equivalent of C's malloc?</a></div>
    <div class="body">There is no &quot;global&quot; memory in win32 - GlobalAlloc allocates heap memory, too. On NT it even ends up in HeapAlloc (with some special flags). You're better off using HeapAlloc for all generic allocations - that way you can also specify your own heap, if you want to (GetProcessHeap is best for &quot;normal&quot; stuff though).<br /><br />For &quot;special needs&quot;, VirtualAlloc. You can reserve memory and not commit it until necessary that way. You get 64k allocation granularity, so for large stuff like framebuffers, valloc would be a good thing too. It's a slow routine though, so only suitable for a few large allocs, or specialized stuff such as controlling reserve/commit. Also useful if you need special page protection flags.<br /><br />Memory Mapped files are good if you need to share memory between processes. It's also the only way to do that. For all other purposes, stay way from it, as memory access speed is somewhat slower with these - and the allocation overhead is very large, too. There's other problems with these, too, especially on 9x (because of the horrible private/global address space split on 9x systems).<br /><br />Stay away from the &quot;OLE String&quot; memory functions hutch talk about, they're made for strings, not generic memory allocs. Seems silly to use them. If you want other methods, look at CoTaskMemAlloc, or the IMalloc interface, etc.<br /><br />Generally, my advice is to go with HeapAlloc unless you need one of the other methods.</div>
    <div class="meta">Posted on 2003-04-24 02:04:06 by f0dder</div>
   </div>
   <div class="post" id="post-99008">
    <div class="subject"><a href="#post-99008">win32asm equivalent of C's malloc?</a></div>
    <div class="body">Anotherway83,<br /><br />Try this one:<br /><br /><pre><code><br /><br />.386<br />.model flat,stdcall<br />option casemap&#58;none<br /><br />include \masm32\include\windows.inc<br />include \masm32\include\kernel32.inc<br />includelib \masm32\lib\kernel32.lib<br />includelib msvcrt.lib<br /><br />printf PROTO C a1&#58;DWORD,a2&#58;VARARG<br />malloc PROTO C &#58;DWORD<br />free   PROTO C &#58;DWORD<br /><br />.data<br />msg db 'pMemory=%X',0<br />.code<br />start&#58;<br />invoke malloc,100<br />push esi<br />mov esi,eax<br />invoke printf,addr msg,esi<br />invoke free,esi<br />pop esi<br />invoke ExitProcess,0<br />end start<br /><br /></code></pre></div>
    <div class="meta">Posted on 2003-04-24 03:44:53 by Vortex</div>
   </div>
   <div class="post" id="post-99010">
    <div class="subject"><a href="#post-99010">win32asm equivalent of C's malloc?</a></div>
    <div class="body">f0dder,<br /><br />you are technically wrong in restricting OLE memory to one application type, it works just as well in arrays, video, general purpose data and is particularly useful where there are many small allocations.<br /><br />Finally memory is memory, if you can read and write to it, it does the job and avoiding one particular type on a person disposition is a mistake.<br /><br />OLE string memory is both fast allocation and easy to use in a range of sizes.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2003-04-24 04:01:16 by hutch--</div>
   </div>
   <div class="post" id="post-99011">
    <div class="subject"><a href="#post-99011">win32asm equivalent of C's malloc?</a></div>
    <div class="body">Your ole string functions are made for string, and allocation thus has more overhead than just allocation the memory. If there's other &quot;ole memory&quot; functions, those would probably be files - but imho it's silly using string functions for memory.<br /><br /><div class="quote"><br />Finally memory is memory, if you can read and write to it, it does the job and avoiding one particular type on a person disposition is a mistake.<br /></div><br />The various routines have different allocation- and access-speed parameters though. This matters especially for VirtualAlloc and MMF.<br /><br />Most of (if not all) the other routines end up allocating heap memory, even using HeapAlloc for it - so you might as well use the shortest route and do HeapAlloc. If you don't like specifying all those parms to HeapAlloc, fine, write your own simple-interface wrapper around it.<br /><br />I believe IMalloc and CoTaskMemAlloc(which is just a wrapper around the IMalloc interface) memory had memory pooling, something that can speed up when you have lots of allocs/deallocs. Possibly ole strings had too - but again, ole strings also does stuff related to string conversion etc.</div>
    <div class="meta">Posted on 2003-04-24 04:06:01 by f0dder</div>
   </div>
   <div class="post" id="post-99016">
    <div class="subject"><a href="#post-99016">win32asm equivalent of C's malloc?</a></div>
    <div class="body">Oh, and please don't see this as &quot;f0dder says B because hutch says A&quot;. My statements are based on theory as well as imperical observations. I've done quite some researching on this - unfortunately, I think I forgot to update my site with the findings, so it is probably scattered around a lot of posts on this board. I'll probably do all the research again and write up a detailed essay to clear any misconceptions, but here's a short roundup.<br />P is PSDK, F is my comments.<br /><br />Global/LocalAlloc:<br />P: don't use local/globalalloc, they're deprecated<br />F: they end up allocation heap memory anyway.<br /><br />VirtualAlloc:<br />F: slow allocation, can't be &quot;reallocated&quot;. Pros are that is has advanced management, page protection, and 64k granularity. Good for few really-large allocs, or &quot;advanced stuff&quot;.<br /><br />Memory Mapped Files:<br />F: slow allocation, somewhat slower access speed because of the underlying techniques. Big problems on 9x because MMF are allocated in the (very) limited global part of the address space. Also, paging file is forced to grow, since MMF are backed up by the paging file when not backed by a file handle. Only way to allocate &quot;global&quot; memory - so use it when you have to do this, and otherwise not.<br /><br />SysAllocStringByteLen:<br />P: Allocates a new string of len bytes, copies len bytes from the passed string into it, and then appends a null character.<br />F: you don't have to specify the source string, effectively just alocating memory - however, it should still allocate one byte more, has a little additional overhead, and end up using heap memory anyway. Uses memory pooling which can speed up stuff when you have lots of allocs/deallocs - but rather than using this function just because of pooling, write your own decent code for this - gives more control. This routine *does* have a bunch of overhead, like messing around with TLS etc. Uses CoGetMalloc as backend allocator.<br /><br />CoGetMalloc:<br />P: Retrieves a pointer to the default OLE task memory allocator (which supports the system implementation of the IMalloc interface) so applications can call its methods to manage memory.<br />F: returns a pointer to CoTaskMemAlloc.<br /><br />CoTaskMemAlloc:<br />P: Allocates a block of task memory in the same way that IMalloc::Alloc does<br />F: wrapper around the IMalloc interface.<br /><br />IMalloc interface:<br />You'll probably have to use this when dealing with COM. Allocated heap memory, possibly (can't remember) has pooling like SysAllocStringByteLen. Same speed (allocation/access) as heap memory, but doesn't let you specify flags like &quot;HEAP_ZERO_MEMORY&quot;. Less control (can matter), overhead of calling through vtable (won't matter often - and in those cases, you're probably using your own heap anyway).</div>
    <div class="meta">Posted on 2003-04-24 04:28:28 by f0dder</div>
   </div>
   <div class="post" id="post-99018">
    <div class="subject"><a href="#post-99018">win32asm equivalent of C's malloc?</a></div>
    <div class="body">f0dder,<br /><br />What about the malloc func. from the C run-time DLLs?</div>
    <div class="meta">Posted on 2003-04-24 04:34:22 by Vortex</div>
   </div>
   <div class="post" id="post-99020">
    <div class="subject"><a href="#post-99020">win32asm equivalent of C's malloc?</a></div>
    <div class="body">That will of course depend on the libc malloc implementation :) - it has to end up in OS memory routines, but there's of course a lot of different stuff libc can do to speed up stuff. vs.net libc basically ends up doing HeapAlloc, though, without too much extracode. I wouldn't depend on a libc malloc if I was writing asm apps. HeapAlloc==good :), IMalloc/CoTaskMemAlloc is fine and lets you _easily_ install spy/hook.<br /><br />For normal code, I do C++, and thus use new or malloc. For specialized needs, I do specialized allocation routines - for instance pool memory allocation.</div>
    <div class="meta">Posted on 2003-04-24 04:41:45 by f0dder</div>
   </div>
   <div class="post" id="post-99021">
    <div class="subject"><a href="#post-99021">win32asm equivalent of C's malloc?</a></div>
    <div class="body">f0dder,<br /><br />Thanks for the info.I guess,you are reading the disasm.<br />listing of these memory allocation functions to find the best<br />one.;)</div>
    <div class="meta">Posted on 2003-04-24 04:47:25 by Vortex</div>
   </div>
   <div class="post" id="post-99022">
    <div class="subject"><a href="#post-99022">win32asm equivalent of C's malloc?</a></div>
    <div class="body">Yes, I've been timing, tracing and disassembling, since PSDK didn't give &quot;extensive&quot; information. So of course some implementation details can differ on future systems. However, I think it shows that HeapAlloc is the best generic routine (gives you control, most direct path on current windows versions, and in the best speed class), followed by IMalloc if you need COM memory allocations or easy spying. And that the rest should be avoided unless you need to use them.</div>
    <div class="meta">Posted on 2003-04-24 05:05:11 by f0dder</div>
   </div>
   <div class="post" id="post-99025">
    <div class="subject"><a href="#post-99025">win32asm equivalent of C's malloc?</a></div>
    <div class="body">AnotherWay83,<br /><br />You can make your own choice as to what you use without having to listen. Most of the functions are easy enough to use so just dial up what you want.<br /><br />f0dder,<br /><br />Your own testing previously that you posted in here about a year ago broke your own theory of allocation speed and with large numbers of small allocations, OLE string memory is just faster because its designed to do just that. Remember the PRE ALLOCATED characteristic of OLE string memory ?<br /><br />Theories about how different versons of Windows handles memory does not give you priority of HeapAlloc() and if you remember, it was in fact slower because of its overhead, just like everyone else knows.<br /><br />Now spare us this dogma, just reread your own testing posted here about a year ago.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2003-04-24 06:19:23 by hutch--</div>
   </div>
   <div class="post" id="post-99026">
    <div class="subject"><a href="#post-99026">win32asm equivalent of C's malloc?</a></div>
    <div class="body">Appearantly you didn't read the previous postings nor the current.<br />If you would care to read the current post, you will see I have positive things to say about com string memory:<br /><div class="quote"><br />Uses memory pooling which can speed up stuff when you have lots of allocs/deallocs - but rather than using this function just because of pooling, write your own decent code for this - gives more control. <br /></div><br />&quot;preallocated memory&quot; is nonsense, it's pooling. The same type that is done with HeapAlloc if you enable the &quot;low fragmentation heap&quot;.<br /><br /><div class="quote"><br />You can make your own choice as to what you use without having to listen. Most of the functions are easy enough to use so just dial up what you want.<br /></div><br />So I'm telling him what to do and you're not? *cough*. At least I'm trying to give some reasons as to why I make the suggestions I do - it's up to people to make their own minds from that, and as with anything else, people shouldn't take anything for granted but do their own research.<br /><br />---<br /><br />I should really redo all this testing from scratch, along with a thorough explanation of the entire stuff. In one centralized place instead of scattered around multiple posts.</div>
    <div class="meta">Posted on 2003-04-24 06:28:34 by f0dder</div>
   </div>
   <div class="post" id="post-99028">
    <div class="subject"><a href="#post-99028">win32asm equivalent of C's malloc?</a></div>
    <div class="body">f0dder,<br /><br />we have heard you own theories on memory allocation before and your own testing broke it. Anyone can come up with a memory allocation technique based on managing their own block of memory but this is not espousing the virtues of one technique over another, it replacing all of them with your own.<br /><br />Pooled memory IS preallocated and this is how OLE string memory works, your own results also discovered this about a year ago.<br /><br />Yawn.<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2003-04-24 06:35:11 by hutch--</div>
   </div>
   <div class="post" id="post-99042">
    <div class="subject"><a href="#post-99042">win32asm equivalent of C's malloc?</a></div>
    <div class="body">Back then, the tone got rather hostile. Don't really want this again.<br />Yes, I made a some wrong guesses back then, and I corrected them.<br />The following isn't just directed to you, hutch - I assume you already know a lot of this, whether you agree with it or not. But there's a lot of other people on this board too :)<br /><br /><div class="quote"><br />Pooled memory IS preallocated and this is how OLE string memory works, your own results also discovered this about a year ago.<br /></div><br />Well, it's a question of definition perhaps? I understand it as &quot;the memory is pre-allocated, so a low-level alloc func wont have to be called for first alloc&quot;. Iirc, the way the OLE string memory works, the pools are initially empty, but will of course be filled as you do allocations - this wont benefit you until you free a string and alloc afterwards, but that's generally the way pools work. I hope we're not arguing about term definition here :).<br /><br />It also showed that for raw/initial allocations (ie, where the benefits of a pool wouldn't come into play), the OLEString was still a bit faster - but also that speeds were equal if I rounded memory request size to 16, like OLEString does.<br /><br />I belive that should be fairly accurate, but I will do the tests again.<br /><br />Now, the interesting point is... interface vs. implementation. You've been saying a bit about this yourself, and well... of course you shouldn't depend on implementation (I get the opinion that you agree on this by the previous posts?)<br /><br />The OLEString doesn't guarantee that memory allocation is pooled, does it? If so, I have missed the point where this is stated. You can argue that this is unlikely to change, but then one can argue that the other memory routines are unlikely to change (et cetera).<br /><br />If we look at only the interface, what PlatformSDK tells us, I get this impression:<br /><br />- HeapAlloc allows more flexibility. You can specify the heap where you allocate, whether to get &quot;random&quot; or &quot;zeroed&quot; (will affect allocation speed), et cetera. OLEString doesn't let you, and the &quot;NULL,size&quot; way of allocating doesnt' say what the memory will be filled with - ie, undefined.<br /><br />Also, you can't depend on the allocation granularity of neither HeapAlloc nor OLEString - the interface doesn't specify them. <br /><br />So... if you want to rely on the interface, not the implementation, I would say it's smarter to use a flexible &quot;low-level allocator&quot; and implement your own aligned/pooled strategy ontop of this. That way you will get consistent results on current and future windows versions.<br /><br />Why use HeapAlloc instead of some other &quot;low-level&quot; routine? After all, VirtualAlloc is far more lowlevel? Couple of reasons. HeapAlloc has HeapRealloc. HeapAlloc is listed as the preferred win32 method these days, so it's not unreasonable to guess that it won't be all messed up in the near future. Furthermore, HeapAlloc currently performs just as well as the other &quot;low level&quot; routines (when you don't take into account smarter strategies like pooling).<br /><br />At least this makes sense to me?<br />Disassembly, tracing and timing empirically are good methods to get a general idea of how stuff performs, and I've used all these methods myself. However, this must not be used as a definitive guide on which to chose; if something isn't documented in the interface, you shouldn't rely on it, no matter how unlikely it seems it will be changed in the future. Yes, I sometimes forget about this too, I'm just human after all. But it's worth keeping in mind.<br /><br />I'll try writing a &quot;definitive&quot; guide to this all, taking into account both what the interfaces say, and how it's done in the implementations. I have access to win2k, winxp, and win98se rigs, and will probably have a look at all of them. I hope I can come up with something crystal clear and objective, with some good explanations of my thoughts and code details. Will take some time, but I feel it ought to be done.</div>
    <div class="meta">Posted on 2003-04-24 07:56:40 by f0dder</div>
   </div>
   <div class="post" id="post-99050">
    <div class="subject"><a href="#post-99050">win32asm equivalent of C's malloc?</a></div>
    <div class="body">f0dder,<br /><br />what about that &quot;easy spying&quot; of COM memory? Hopefully you dont mean that IMallocSpy stuff, which is really rubbish.<br /><br />This memory pooling thing is true for this &quot;SysAllocString&quot; family, not for CoTaskMem/IMalloc. And its definitely not a good idea to use it (besides for BSTRs of course) because that makes finding memory leaks almost impossible.<br /><br />Japheth</div>
    <div class="meta">Posted on 2003-04-24 09:01:53 by japheth</div>
   </div>
   <div class="post" id="post-99054">
    <div class="subject"><a href="#post-99054">win32asm equivalent of C's malloc?</a></div>
    <div class="body">I was referring to IMallocSpy, but didn't really read into it - what makes it rubbish?<br /><br />Yes, seems like the pooling is only valid for the ole string stuff, my mistake. It's been a while since I messed with this last, and I tend to write my own stuff when I need things that aren't documented behaviour ;-)<br /><br /><br />Your point about memory leaks is a very good one - it's a good idea to write your own wrapper functions that can toggle between either normal or &lt;whatever funky scheme&gt; transperently in the internals. Debug version? Add debug code. Release version? use pooled memory or whatever other clever speed increasing scheme you can come up with :alright:</div>
    <div class="meta">Posted on 2003-04-24 09:15:29 by f0dder</div>
   </div>
   <div class="post" id="post-99100">
    <div class="subject"><a href="#post-99100">win32asm equivalent of C's malloc?</a></div>
    <div class="body">thanks everyone for ur replies, lots of interesting info, i have much to learn :D<br /><br />thanks vortex for that code snippet, i didn't know u could use PROTO C...i guess that informs the assembler that its actually a C function...? i will read the docs for more info on that</div>
    <div class="meta">Posted on 2003-04-24 14:05:16 by AnotherWay83</div>
   </div>
   <div class="post" id="post-99113">
    <div class="subject"><a href="#post-99113">win32asm equivalent of C's malloc?</a></div>
    <div class="body">PROTO C tells ml.exe that the procdure is using the C calling convention and naming, in the help file \masm32\help\masm32.hlp there is an explanation of the different Calling Conventions.</div>
    <div class="meta">Posted on 2003-04-24 14:55:23 by scientica</div>
   </div>
   <div class="post" id="post-99215">
    <div class="subject"><a href="#post-99215">win32asm equivalent of C's malloc?</a></div>
    <div class="body">To answer the original question directly:<br /><br /><br />This is actual code generated by my compiler which in a previous generation was a c output compiler which used malloc() where VirtualAlloc is now used. The code before the VirtualAlloc is used to make sure that FileBuf was not already allocated. If it was, the memory is released and than reallocated. The commented lines are the user code that caused the code to be generated. <br /><br /><pre><code><br />; LN&#58;4609 BUFFER FileBuf=FilBufSiz<br />mov eax, dword &#91;FilBufSiz&#93;<br />push eax<br />cmp &#91;FileBuf+4&#93;,0<br />je _Lbl777<br />invoke  VirtualFree,&#91;FileBuf&#93;,0,MEM_RELEASE<br />mov &#91;FileBuf&#93;,0<br />mov &#91;FileBuf+4&#93;,0<br />_Lbl777&#58;<br />pop eax<br />mov &#91;FileBuf+4&#93;,eax<br />invoke  VirtualAlloc,0,eax,MEM_COMMIT,PAGE_READWRITE<br />mov &#91;FileBuf&#93;,eax<br /></code></pre></div>
    <div class="meta">Posted on 2003-04-24 20:58:25 by msmith</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=12776&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=12776&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="12776" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=12776&amp;page=2">&gt;</a><a href="../?id=12776&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>