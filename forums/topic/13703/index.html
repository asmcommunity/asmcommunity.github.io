<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>My line count app sooo slow. - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=13703" />
    <link rel="next" href="../?id=13703&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=13703">My line count app sooo slow.</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=13703&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=13703&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="13703" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=13703&amp;page=2">&gt;</a><a href="../?id=13703&amp;page=2">&raquo;</a></form>   <div class="post" id="post-106141">
    <div class="subject"><a href="#post-106141">My line count app sooo slow.</a></div>
    <div class="body">Here is a simple HLA utility I wrote to count the lines in a file. I ran it against a file with about 250,000 lines and it counted in a little under a minute. As a comparison, I used the WC command from I believe the MKS toolkit and it returned the line count within a few seconds.<br /><br />Why is my routine so slow? <br /><br /><br />Thanks all.<br /><br /><br /><br />// LineCount-<br />//<br />//  This program will count the number of lines<br />//  in the file specified on the command line <br /><br />//  Calling the program:<br />//		LineCount inFile<br /><br /><br />program LineCount;<br /><br />#include( &quot;stdlib.hhf&quot; );<br /><br />#macro inc64( dest ):noOvrFlw;<br />inc( (type dword dest) );<br />jnz noOvrFlw;<br />inc( (type dword dest[4]) );<br />noOvrFlw:<br />#endmacro<br /><br /><br />static<br />	f: 			file;<br />	inFile:		String;<br />	uns64Result: dword;<br />	i:			int32;<br /><br />begin LineCount;<br /><br />	arg.c();<br />	mov (eax, i);<br />	if( i &lt;&gt; 2 ) then<br />		stdout.put( &quot;Usage: LineCount inFile&quot;, stdio.lf);<br />		exit LineCount;<br />	endif;<br /><br />	mov ( arg.v(1), inFile );<br />	mov( 0, (type dword uns64Result[0]));<br />	mov( 0, (type dword uns64Result[4]));<br /><br />	f.create();<br />	f.open( inFile, fileio.r );<br /><br />	while( !f.eof() ) do<br />		f.a_gets();<br />		inc64(uns64Result);<br />	endwhile;<br /><br />	f.close();<br />	stdout.put( (type uns64 uns64Result[0]), stdio.lf );<br /><br />end LineCount;:confused:</div>
    <div class="meta">Posted on 2003-06-05 22:31:57 by C. Wardell</div>
   </div>
   <div class="post" id="post-106142">
    <div class="subject"><a href="#post-106142">My line count app sooo slow.</a></div>
    <div class="body">#macro inc64( dest );<br />add( 1, (type dword dest) );<br />adc( 0, (type dword dest[4]) );<br />#endmacro<br /><br /><br />Beyond that the slow down is in reading the file only a line at a time!  Another way would be to read the file in large chunks and count the lines in a chunk of bytes.  Which I'm sure the a_gets(); function is already doing to get a line, or reading the file a byte at a time! :)</div>
    <div class="meta">Posted on 2003-06-05 22:49:10 by bitRAKE</div>
   </div>
   <div class="post" id="post-106148">
    <div class="subject"><a href="#post-106148">My line count app sooo slow.</a></div>
    <div class="body">I needed a 64 Bit # some of the counts I do are in excess of 5 Billion. This is the Inc macro I am using as sugested by Randy. It works, but no where near as fast as I would have hoped.<br /><br />:mad:</div>
    <div class="meta">Posted on 2003-06-06 00:41:25 by C. Wardell</div>
   </div>
   <div class="post" id="post-106149">
    <div class="subject"><a href="#post-106149">My line count app sooo slow.</a></div>
    <div class="body">I have suggested a replacement macro above without branching.  I have never used HLA before - my suggestions are based on knowledge of ASM only and assumptions of HLA syntax based on examples seen (flame away or ignore me :)).  Really, I know how to increment a 64-bit number. ;)<br /><br />...or you could use the FPU stack, or keep the value in registers if they are preserved.<br /><br />The bottleneck is the algorithm - a_gets(); already counts(only knows how to count to one ;)) the lines to <em>stop</em> at them.  If you had the code for a_gets(); then you could take out the stopping part and add inc64.</div>
    <div class="meta">Posted on 2003-06-06 00:48:04 by bitRAKE</div>
   </div>
   <div class="post" id="post-106158">
    <div class="subject"><a href="#post-106158">My line count app sooo slow.</a></div>
    <div class="body"><strong>bitRake</strong>,<br /><br />The only problem with the new macro is that additions affect the carry flag, whereas increment/decrement leaves the carry as is. Wardell note this may or may not affect any other calculations you are doing... So, this is not necessarily a replacement for your inc64 macro.<br />{But in the given circumstances, it is the MOST OPTIMAL inc64...}<br /><br /><br /><strong>Wardell</strong>,<br /><br />General comments...<br /><br />1. For the task you are doing, you will scarcely need 64 bits: You should scarcecly need 32 bits (4 billion) to count the number of bytes in a file, much less the nuumber of lines in a file. You have reached 250,000 which is not quite a 20 bit number. I would say, stick with a 32 bit nuumber. Don't put in 64 bit numbers just because you have a nifty inc64 macro.<br /><br />2. Of course this is just a test program for something bigger, but, hey, optimizations are in order: you are not doing anything with the registers. Why not use one as a counter?<br /><br />while( !f.eof() ) do<br />f.a_gets();<br />inc ebx;<br />endwhile;<br /><br />3. Is there a better way to read a line? eg... <br />fileio.readLn(  );<br />I'm not sure how to port it to the format you are using, ,probably<br />f.readLn();<br /><br />4. The code for a_gets() is in hla\libsrc\fileio\fgets.hla</div>
    <div class="meta">Posted on 2003-06-06 03:01:31 by V Coder</div>
   </div>
   <div class="post" id="post-106173">
    <div class="subject"><a href="#post-106173">My line count app sooo slow.</a></div>
    <div class="body">Unfortunately, We do need 64 Bit #'s. We have well over 4.5 Billion rows in our database. What this program is designed to do is to take the Max Sequence ID from the database and genereate ID's for the next incoming flat file that is to be loaded into the data warehouse.  (Actually our next ID is around 7 Billion )<br /><br /><br />Does your suggestion using the EBX register support #'s over 4 Billion?</div>
    <div class="meta">Posted on 2003-06-06 10:00:13 by C. Wardell</div>
   </div>
   <div class="post" id="post-106174">
    <div class="subject"><a href="#post-106174">My line count app sooo slow.</a></div>
    <div class="body">Let me clarify my last post.<br /><br />The line count program works hand in hand with my AddId program. So I guess they both suffer from the same bottle neck.  When dealing with such huge files and many of them, optimization can save days of processing.<br /><br />Your suggestions are greatly appreciated..<br /><br />Thank you,<br />Charlie<br /><br /><br /><br />// AddId-<br />//<br />//  This program will read each line in the <br />//  file specified on the command line and<br />//  append an auto incrementing ID to the end<br />//  of each record. The id will start at the<br />//  number passed in on the command line.<br /><br />//  Calling the program:<br />//		AddId inFile startingID FieldSep outfile <br />//		inFile: the name of the file to be read<br />//		startingID: is the ID to assign to the first record<br />//		fieldSep: the ID should first be prefixed by this character<br /><br />//		AddId myFile.dat 1000 ~ &gt; myFile.id<br /><br /><br />program AddId;<br /><br />#include( &quot;stdlib.hhf&quot; );<br /><br />#macro inc64( dest ):noOvrFlw;<br />inc( (type dword dest) );<br />jnz noOvrFlw;<br />inc( (type dword dest[4]) );<br />noOvrFlw:<br />#endmacro<br /><br /><br />static<br />	f: 			file;<br />	f2:			file;<br />	inFile:		String;<br />	fieldSep:	String;<br />	currentRec: String;<br />	digitStr:	String;<br />	uns64Result: dword;<br />	i:			int32;<br /><br />begin AddId;<br /><br />	arg.c();<br />	mov (eax, i);<br />	if( i &lt;&gt; 4 ) then<br />		stdout.put( &quot;Usage: AddId inFile StartingID fieldSep &gt; outFile&quot; );<br />		exit AddId;<br />	endif;<br /><br /><br />	mov ( arg.v(1), inFile );<br />	mov ( arg.v(3), fieldSep );<br />	<br />	arg.v(2);<br />	mov( eax, digitStr ); 									// digitStr is type &lt;&lt;string&gt;&gt;.<br />	conv.strTou64( digitStr, 0 ); 				// Result comes back in EDX:EAX<br />	mov( eax, (type dword uns64Result[0]));<br />	mov( edx, (type dword uns64Result[4]));<br />	strfree( digitStr );<br /><br />	f.create();<br />	f.open( inFile, fileio.r );<br /><br />	while( !f.eof() ) do<br />		f.a_gets();<br />		mov( eax, currentRec );<br />		inc64(uns64Result);<br /> 		stdout.put( currentRec, &quot;|&quot;, (type uns64 uns64Result[0]), stdio.cr, stdio.lf );<br />		strfree( currentRec );<br />	endwhile;<br />	<br />	f.close();<br /><br />end AddId;</div>
    <div class="meta">Posted on 2003-06-06 10:06:26 by C. Wardell</div>
   </div>
   <div class="post" id="post-106196">
    <div class="subject"><a href="#post-106196">I know this is the hla group but...</a></div>
    <div class="body">I know this is the hla group but it seems hla over complicates things?<br /><br />by why not...<br /><br />Spasm Syntax<br /><pre><code><br />; Line Count test<br />; Look maw! no libraries<br /><br />&#91;push | push #1 | #+1&#93;  <br />&#91;pop | pop #1 | #+1&#93;          <br />&#91;call | push #L&gt;2 | call #1&#93;<br />&#91;TextToCount&#58; B$ &quot;1<br />&quot; #3000 0&#93;<br /><br />Main&#58;<br />        mov esi TextToCount<br />        mov ecx 0       <br />L1&#58;    inc esi | mov ax W$esi<br />        cmp ax 0000 | je L3&gt;  <br />        cmp ax 0A0D | jne L1&lt;                  <br />        inc ecx | jmp L1&lt; <br />L3&#58;    inc ecx<br />        <br />        call 'KERNEL32.ExitProcess' 0<br />        ret<br /></code></pre><br /><br /><br />or Masm32 syntax<br /><pre><code><br />; #################################################<br /><br />    .486<br />    .model flat, stdcall<br />    option casemap &#58;none   ; case sensitive<br /><br />; #################################################<br /><br />    include \masm32\include\windows.inc<br />    include \masm32\include\user32.inc<br />    include \masm32\include\kernel32.inc<br />    include \masm32\include\gdi32.inc<br />    include \masm32\include\masm32.inc<br />    include \masm32\include\debug.inc<br /><br />    includelib \masm32\lib\user32.lib<br />    includelib \masm32\lib\kernel32.lib<br />    includelib \masm32\lib\gdi32.lib<br />    includelib \masm32\lib\masm32.lib<br />    includelib \masm32\lib\debug.lib<br />    <br />    main PROTO<br /><br />    .data<br />    TextToCount db &quot;Test Line&quot;,13,10<br />                db &quot;Line Two&quot;,0<br /><br />; #################################################<br /><br />    .code<br /><br />start&#58;<br /><br />    call main<br /><br />    invoke ExitProcess,0<br /><br />; #################################################<br />main proc<br /><br />        mov esi, OFFSET TextToCount<br />        mov ecx, 0<br /><br />@@&#58;<br />        inc esi<br />        mov ax, word ptr &#91;esi&#93;<br />        cmp ax, 0000<br />        je @F<br />        cmp ax, 0A0Dh<br />        jne @B<br />        inc ecx<br />        jmp @B<br /><br />@@&#58;<br />        inc ecx <br /><br />        PrintDec ecx<br />    ret<br /><br />main endp<br /><br />; ################################################# <br />end start<br /></code></pre><br /><br />You are really counting the number of CRLF aren't you?<br /><br />I apologize for this post, I am no master asm guy.<br />I am a former C programmer and am lost as to why hla simplifies things.<br /><br />?Need more than 4 million, change it and use 64bit.<br />or read your file in chunks. What happens in the futur when it becomes<br />100 milion?<br /><br />Once again sorry, my goal isnt to start a war with randy. :eek:<br /><br />RobotBob</div>
    <div class="meta">Posted on 2003-06-06 15:36:20 by RobotBob</div>
   </div>
   <div class="post" id="post-106198">
    <div class="subject"><a href="#post-106198">Re: My line count app sooo slow.</a></div>
    <div class="body"><div class="quote"><br />Here is a simple HLA utility I wrote to count the lines in a file. I ran it against a file with about 250,000 lines and it counted in a little under a minute. As a comparison, I used the WC command from I believe the MKS toolkit and it returned the line count within a few seconds.<br /><br />Why is my routine so slow? <br /><br /><br />Thanks all.<br /> </div><br /><br />All the time is begin spent in stdin.a_gets.<br /><br />Two comments:<br /><br />1. stdin.a_gets allocates storage for the new line on the heap by calling stralloc, which calls malloc, which calls Win32's global allocation routines. Memory allocation is a big time hog in most OSes. It doesn't help that you never free the storage, so this winds up causing paging to occur (most likely, because you're reading so many lines, and that is *slow*).<br /><br />2. Here's what stdin.a_gets is doing:<br />      a. Windows may or may not buffer up file data in its own internal buffs<br />      b. The HLA StdLib reads a chuck of the data to an internal buffer<br />      c. stdin.a_gets allocates storage and copies the data to that buffer<br />          and then reallocates the buffer to the size of the string read.<br />      d. You process the string.<br /><br />This requires several copies of the data, plus the expense of the malloc calls.  This is all expensive!<br /><br />Under normal circumstances, the right solution would be to map the file into memory using memory mapped I/O and then simply scan through the data in memory searching for line feeds. However, because your file can be so large, this is not a possibility. Therefore, the next best solution is to read the file a large block at a time into a memory buffer and scan through that buffer. I'd recommend reading the file in at least 64K blocks. <br /><br />For the absolute best performance, don't bother using the HLA Standard Library routines - they add an extra layer between your application and the OS. While the extra time is probably negligible, if all you're doing is text I/O, using the Win32 API functions is just as easy as using the HLA Standard Library (other than you've got to figure out what functions to call). You'll want to look up w.CreateFile, w.Read, and w.CloseHandle for the task at handle.<br /><br />Also, don't use the scans instruction to search for those line feeds if speed is really important. A short loop that tests each character individually (or better yet, a loop that tests a dword at a time) runs faster.<br />A modification of the HLA Standard Library str.zlen routine might be a good approach (note that if you subtract $0a0a0a0a from a dword, searching for line feed becomes the easier case of searching for zero in a string).<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-06-06 15:57:34 by rhyde</div>
   </div>
   <div class="post" id="post-106201">
    <div class="subject"><a href="#post-106201">My line count app sooo slow.</a></div>
    <div class="body">Here are the results: <br /><br />Using my the AppID in HLA took 1hr 28 Minutes on a 1.4 Gig file -<br /><br />What shocked me is that the same app written in MS VC++ took 8 Minutes.. :o</div>
    <div class="meta">Posted on 2003-06-06 16:35:26 by C. Wardell</div>
   </div>
   <div class="post" id="post-106213">
    <div class="subject"><a href="#post-106213">read in chunks</a></div>
    <div class="body">Why not multi thread it and each thread read a block of the file.<br />at the end add up all of your invidual line counts?<br /><br />8 minutes seems excessive to me, also. One hour would not be acceptable,obviously. Granted it is 1.4 Gig file.<br /><br />But simple word cmp on moderate chunks will fly, we are measure this in<br />milliseconds. The simple word compare flys through my text copy of 'war and peace', it doesn't even register one second on my machine.<br /><br />As randy mentioned you must keep the os from paging, if you allow it.<br />all of your 'speed up' work goes to trash.<br /><br />Once again I could be wrong, not a guru (never hope to be, gurus must constantly prove that). I 've only spent a god awful amount of time parsing things.<br /><br />Good luck Wardell<br /><br />RobotBob</div>
    <div class="meta">Posted on 2003-06-06 19:31:05 by RobotBob</div>
   </div>
   <div class="post" id="post-106215">
    <div class="subject"><a href="#post-106215">My line count app sooo slow.</a></div>
    <div class="body">Use MMX to scan for end of line, and use multiple threads so something is done while loading the next block from disk - like <strong>RobotBob</strong> suggests.  The line count can be done in the time to read the file from disk. :)<br /><br />Read here:<br /><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=3525&amp;highlight=long+string+length">http://www.asmcommunity.net/board/index.php?topic=3525&amp;highlight=long+string+length</a></div>
    <div class="meta">Posted on 2003-06-06 19:46:32 by bitRAKE</div>
   </div>
   <div class="post" id="post-106217">
    <div class="subject"><a href="#post-106217">My line count app sooo slow.</a></div>
    <div class="body">Thank you all for your input, by the way, did I mention I was a newbie to ASM and don't know what the hell I am doing?</div>
    <div class="meta">Posted on 2003-06-06 20:09:08 by C. Wardell</div>
   </div>
   <div class="post" id="post-106218">
    <div class="subject"><a href="#post-106218">:)</a></div>
    <div class="body">I find most of the people on this board first assume<br />a person is not a beginner, to prevent from insulting <br />them by implying that. <br />-robotbob</div>
    <div class="meta">Posted on 2003-06-06 20:21:49 by RobotBob</div>
   </div>
   <div class="post" id="post-106233">
    <div class="subject"><a href="#post-106233">My line count app sooo slow.</a></div>
    <div class="body">I think randall.hyde means something like the below (sorry for asm code instead of hla).<br /><pre><code><br />.data?<br />hFile dd ?<br />dd1 dd ?<br />highdd dd ?<br />buffer db 1024 dup &#40;?&#41;<br />.code<br />...<br />invoke CreateFile,OFFSET FileName, GENERIC_READ, FILE_SHARE_READ,0,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,0<br />mov hFile,eax<br />invoke GetFileSize, eax, offset highdd<br />xchg esi,eax ;esi = low dword<br />mov edi, highdd<br />L1&#58;<br />sub esi,1024<br />jns @F<br />dec edi<br />@@&#58;<br />invoke ReadFile,hFile, offset buffer,1024,offset dd1,0<br />lea edx,buffer<br />mov eax,1024<br />L2&#58;<br />xor ecx,ecx<br />cmp byte ptr&#91;edx+eax&#93;, 13h<br />sete cl<br />cmp byte ptr&#91;edx+1+eax&#93;, 13h<br />sete cl<br />add counter, ecx<br />sub eax,2<br />jnz L2<br />test edi,edi<br />jnz L1<br />test esi,esi<br />jnz L1<br /></code></pre><br />Something like that but I think there is some bug in it.</div>
    <div class="meta">Posted on 2003-06-06 23:17:44 by roticv</div>
   </div>
   <div class="post" id="post-106238">
    <div class="subject"><a href="#post-106238">My line count app sooo slow.</a></div>
    <div class="body">Wow,<br /><br />This small project has really turned into a treasure trove of technique. The reason why I chose the HLA was to learn some of the ins and outs of asm before jumping into asm directly.<br /><br />To tell you the truth, I am at a loss with the suggestions that have been presented. Holy smokes it looks like greek to me. Now I have been programming for about 16 years and my hat is off to all of you.  I did some asm programming on the 6502 and a86 back in the late 80's but it seemed much simpler then.  What a rude awakening. <br /><br />I guess what I need to do is to go through each line of code to see what the sugestions are actually accomplishing.  Any links to a fast refresher course? <br /><br />Thanks again,<br />Charlie</div>
    <div class="meta">Posted on 2003-06-07 00:00:19 by C. Wardell</div>
   </div>
   <div class="post" id="post-106247">
    <div class="subject"><a href="#post-106247">My line count app sooo slow.</a></div>
    <div class="body">Well all it has is just 2 loops.<br />The first loop is to read 1024 chunk at a time.<br />The second loop is to scan the for CRLF (actually scanning for just LF or CR would be sufficient). I made it 2 scan 2 bytes at a time since CRLF takes up 2 space it the possibility of LF or CR to appear twice in the 2bytes should not be possible. (Well I used xor ecx,ecx and sete cl to reduce branching.)<br /><br />Seriously I do not find asm as hard as some people claims it is. <br /><a target="_blank" href="http://www.madwizard.org/view.php?page=tutorials.contents&amp;PHPSESSID=9f2dc59c35d62979bcfbc18c04a17a52">http://www.madwizard.org/view.php?page=tutorials.contents&amp;PHPSESSID=9f2dc59c35d62979bcfbc18c04a17a52</a><br />(Thomas's tutorial to asm) <br /><br /><div class="quote">I'd recommend reading the file in at least 64K blocks</div> <br />And since randall.hyde suggest using 64k blocks, just change the 1024 to 65536 and to use HeapAlloc/VirtualAlloc to create a buffer for the data and scan through the buffer for CRLF.</div>
    <div class="meta">Posted on 2003-06-07 01:21:14 by roticv</div>
   </div>
   <div class="post" id="post-106248">
    <div class="subject"><a href="#post-106248">Some Faster HLA Code</a></div>
    <div class="body">Here's a quick and dirty solution.<br />Not really faster than what a *good* C implementation will produce, but won't be an order of magnitude slower:<br /><br /><pre><code><br />program fastLC;<br />#include&#40; &quot;stdlib.hhf&quot; &#41;<br />#include&#40; &quot;w.hhf&quot; &#41;<br /><br />const<br />	bufSize_c &#58;= 64*1024;<br />	<br />static<br />	bytesRead	&#58;dword;<br />	filename	&#58;string;<br />	handle		&#58;dword;<br />	count		&#58;uns64;<br />	<br />var<br />	buffer		&#58;char&#91; bufSize_c &#93;;<br /><br />begin fastLC;<br /><br />	if&#40; arg.c&#40;&#41; &lt;&gt; 2 &#41; then<br />	<br />		stdout.put&#40; &quot;usage&#58; fastlc &lt;&lt;filename&gt;&gt;&quot; &#41;;<br />		exit fastLC;<br />		<br />	endif;<br />	<br />	mov&#40; arg.v&#40; 1 &#41;, filename &#41;;<br />	w.CreateFile<br />	&#40; <br />		filename, <br />		w.GENERIC_READ, <br />		0, <br />		NULL, <br />		w.OPEN_EXISTING, <br />		0, <br />		null <br />	&#41;;<br />	if&#40; eax = w.INVALID_HANDLE_VALUE &#41; THEN<br />	<br />		stdout.put&#40; &quot;Could not open file '&quot;, filename, &quot;'&quot; nl &#41;;<br />		exit fastLC;<br />		<br />	endif;<br />	mov&#40; eax, handle &#41;;<br />	forever<br />	<br />		lea&#40; edi, buffer &#41;;<br />		w.ReadFile&#40; handle, &#91;edi&#93;, bufSize_c, bytesRead, NULL &#41;;<br />		breakif&#40; bytesRead = 0 &#41;;<br />		xor&#40; edi, edi &#41;;<br />		while&#40; edi &lt; bytesRead &#41; do<br />		<br />			if&#40; buffer&#91;edi&#93; = stdio.lf &#41; then<br />			<br />				inc&#40; &#40;type dword count&#41; &#41;;<br />				if&#40; @z &#41; then<br />					<br />					inc&#40; &#40;type dword count&#91;4&#93;&#41; &#41;;<br />					<br />				endif;<br />				<br />			endif;<br />			inc&#40; edi &#41;;<br />			<br />		endwhile;<br />		<br />	endfor;<br />	w.CloseHandle&#40; handle &#41;;<br />	stdout.put&#40; &quot;Number of lines in '&quot;, filename, &quot;' is &quot;, count, nl &#41;;<br />			 	<br />end fastLC;<br /></code></pre><br /><br />Now, to really speed things up, you've got to work on the loop that scans the string for line feeds. As I mentioned earlier, you really want to process this four bytes at a time. Or better yet, use the MMX registers or SSE register and do it eight bytes at a time. Speeding this code up is where you'll beat the pants off a C implementation. Everything else is system or OS dependent and whether you use a HLL or assembly won't make much difference.<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-06-07 01:34:10 by rhyde</div>
   </div>
   <div class="post" id="post-106249">
    <div class="subject"><a href="#post-106249">My line count app sooo slow.</a></div>
    <div class="body">Oh, I forgot to mention,<br />A quick test with an arbitrary 1,000,000+ line source file took about 14.8 seconds to process (the arbitrary file was a C file produced by compiling HLA's bison code into C, and then I duplicated that output about 8-12 times).  Most of the lines were fairly long.<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-06-07 01:36:26 by rhyde</div>
   </div>
   <div class="post" id="post-106250">
    <div class="subject"><a href="#post-106250">My line count app sooo slow.</a></div>
    <div class="body"><div class="quote"><br />Oh, I forgot to mention,<br />A quick test with an arbitrary 1,000,000+ line source file took about 14.8 seconds to process (the arbitrary file was a C file produced by compiling HLA's bison code into C, and then I duplicated that output about 8-12 times).  Most of the lines were fairly long.<br />Cheers,<br />Randy Hyde </div><br />I Also forgot to mention that my version of WC produced comparable timings.<br />This is on a 300 MHz PII machine, btw.<br />Now WC does more work, so this isn't very impressive, but then I've not tuned the assembly code at all, either.<br /><br />You might want to take a look at Terje Mathisen's WC program from many years ago. This was an 8086 (!) program that really kicked butt at scanning through text files looking for words, lines, etc. Don't know that his algorithm (using a 64K lookup table) would still fly today, but it had some interesting ideas for speeding up the code).<br /><br />There is no question in my mind that with some very straight-forward changes to this code, you can easily double the speed. Going wild, you should be able to quadruple it, at least.<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-06-07 01:41:24 by rhyde</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=13703&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=13703&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="13703" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=13703&amp;page=2">&gt;</a><a href="../?id=13703&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>