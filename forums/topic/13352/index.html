<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>help with .hhf and program - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=13352" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=13352">help with .hhf and program</a></p>
   <div class="post" id="post-103466">
    <div class="subject"><a href="#post-103466">help with .hhf and program</a></div>
    <div class="body">I tried to write the advapi32.hhf, here is procedure GetUserNameA I transfered:<br />------------------------------------------<br />  GetUserNameA: procedure <br />               (<br />                var  lpBuffer:      var;<br />                     nSize:         dword<br />               );      <br />               @stdcall; <br />               @returns(&quot;eax&quot;); <br />               @external(&quot;__imp__GetUserNameA@8&quot;);<br />--------------------------------------------<br />Is it correct to write it like that? <br /><br />then I like to call it in my program:<br />-----------------------------------<br />static<br />  dwSize: dword := w.MAX_PATH;<br />  aUserName: Char;<br />//  aUserName: String;     //can I use string here? <br />                           //How to convert Char to string? <br /><br />begin UserName;<br />  GetUserNameA( aUserName, dwSize);<br />-----------------------------------<br /><br />Thank you for your help.</div>
    <div class="meta">Posted on 2003-05-17 02:48:32 by henryw</div>
   </div>
   <div class="post" id="post-104067">
    <div class="subject"><a href="#post-104067">Re: help with .hhf and program</a></div>
    <div class="body"><div class="quote"><br />I tried to write the advapi32.hhf, here is procedure GetUserNameA I transfered:<br />------------------------------------------<br />  GetUserNameA: procedure <br />               (<br />                var  lpBuffer:      var;<br />                     nSize:         dword<br />               );      <br />               @stdcall; <br />               @returns(&quot;eax&quot;); <br />               @external(&quot;__imp__GetUserNameA@8&quot;);<br />--------------------------------------------<br />Is it correct to write it like that? <br /><br />then I like to call it in my program:<br />-----------------------------------<br />static<br />  dwSize: dword := w.MAX_PATH;<br />  aUserName: Char;<br />//  aUserName: String;     //can I use string here? <br />                           //How to convert Char to string? <br /><br />begin UserName;<br />  GetUserNameA( aUserName, dwSize);<br />-----------------------------------<br /><br />Thank you for your help. </div><br /><br />The easy way to convert zero-terminated strings to HLA is to use<br />str.cpyz or str.a_cpyz<br />(see <a target="_blank" href="http://webster.cs.ucr.edu/Page_hla/HLADoc/HTMLDoc/HLAStdlib.html#pgfId-1072115">http://webster.cs.ucr.edu/Page_hla/HLADoc/HTMLDoc/HLAStdlib.html#pgfId-1072115</a>).<br /><br />However, Win32 API functions that return string data typically return the string<br />length in EAX, knowing a little bit about the HLA string format can help you manipulate the<br />strings more efficiently.  E.g.,<br /><br />static<br />   s:str.strvar(256);<br />    .<br />    .<br />    .<br />  mov( s, edi );<br />  w.GetUserName( , (type str.strRec ).MaxStrLen) );<br />  mov( eax, (type str.strRec ).length );<br /><br />How this works:<br /><br />HLA strings are a pointer to an array of bytes. At offset -4 from this pointer<br />HLA stores the current length of the string, at offset -8 from this pointer HLA<br />stores the maximum length of the string. The str.strvar macro statically allocates<br />storage for a string and initializes its maximum length field (it also initializes<br />it to the empty string by setting the current length to zero and zero-terminating it).<br /><br />The code example above loads &quot;s&quot; into edi (remember, strings in HLA are pointers,<br />so s is a pointer to the data structure just described above). This code passes<br />the address of the character buffer (which s points at) and the maximum string<br />length to GetUserName. On return, EAX contains the current length, which this code<br />stores into the current length field of the HLA string variable.<br />Note that Win32 API functions preserve EDI, so there is no need to reload it across this call.<br /><br />Another option, of course, is to use zero terminated strings in HLA, though they are<br />quite a bit less efficient than HLA strings.<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-05-20 12:31:53 by rhyde</div>
   </div>
   <div class="post" id="post-104112">
    <div class="subject"><a href="#post-104112">help with .hhf and program</a></div>
    <div class="body">Thank you for your reply, I'll try to read more documents with HLA.</div>
    <div class="meta">Posted on 2003-05-20 19:07:46 by henryw</div>
   </div>
   <div class="post" id="post-104161">
    <div class="subject"><a href="#post-104161">help with .hhf and program</a></div>
    <div class="body">Just swich the key procedure &amp; the procedure name like this:<br /><br />procedure GetUserNameA <br />(<br />var lpBuffer: var;<br />nSize: dword<br />); <br />@stdcall; <br />@returns(&quot;eax&quot;); <br />@external(&quot;__imp__GetUserNameA@8&quot;);<br /><br />this worked for me...</div>
    <div class="meta">Posted on 2003-05-21 04:35:38 by mistronr1</div>
   </div>
   <div class="post" id="post-104221">
    <div class="subject"><a href="#post-104221">help with .hhf and program</a></div>
    <div class="body">Another way to do things is: &quot;Everything is DWORD&quot;.<br />This is approach MASM adopted. As put Iczelion in one of his tutorials:<br /><br /><div class="quote">The size of each parameter is NOT essential. For your information, currently MASM always regards each parameter as a DWORD no matter which size specifier you use.</div> <br /><br />You can look at inc files in Hutch's MASM32 package and find out that all function prototypes look like:<br /><br /><pre><code><br />GetTokenInformation PROTO &#58;DWORD,&#58;DWORD,&#58;DWORD,&#58;DWORD,&#58;DWORD<br />GetTrusteeTypeW PROTO &#58;DWORD<br />GetUserNameA PROTO &#58;DWORD,&#58;DWORD<br /></code></pre><br /><br />Not too much descriptive of course, but actually inc files are not help files and anyway you should consult<br />your Win32 Reference. I don't know all pros and cons  of these two different approaches.<br />It's a good topic for discussion. Personally I prefer everything-is-dword. It looks more straightforward and clear<br />especially for beginners like myself.<br /><br />To put long story a little bit shorter prototype:<br /><br /><pre><code><br />static<br />   GetUserName&#58; procedure&#40; p0&#58; dword; p1&#58; dword&#41;; <br />                        @stdcall; <br />                        @returns&#40;&quot;eax&quot;&#41;; <br />                        @external&#40;&quot;__imp__GetUserNameA@8&quot;&#41;;<br /><br /></code></pre><br /><br />also works.<br /><br />Regards, GJ</div>
    <div class="meta">Posted on 2003-05-21 13:03:04 by Green Joe</div>
   </div>
   <div class="post" id="post-104234">
    <div class="subject"><a href="#post-104234">help with .hhf and program</a></div>
    <div class="body"><div class="quote"><br />Another way to do things is: &quot;Everything is DWORD&quot;.<br />This is approach MASM adopted. As put Iczelion in one of his tutorials:<br /><br /> <br /><br />Not too much descriptive of course, but actually inc files are not help files and anyway you should consult<br />your Win32 Reference. I don't know all pros and cons  of these two different approaches.<br />It's a good topic for discussion. Personally I prefer everything-is-dword. It looks more straightforward and clear<br />especially for beginners like myself.<br /><br /><br />Regards, GJ </div><br /><br />The HLA Standard Library header files for windows takes the &quot;structured&quot; approach, of course<br />(that's more &quot;high level&quot; after all). The cool thing about HLA is that it will support the &quot;everything-is-<br />dword&quot; approach as well as the structured approach.  Most of the time I find the structured approach to be better, but sometimes the &quot;everything-is-a-dword&quot; approach is more convenient.<br /><br />One interesting aspect of the difference between these two approaches is the fact that MASM requires that you specify the &quot;addr&quot; operator when you want to pass the address of an object as a reference parameter, e.g.,<br /><br />  invoke HasRefParm, addr parameter<br /><br />In HLA, with the appropriate declaration, all you've got to do is this:<br /><br />   HasRefParm( parameter );<br /><br />OTOH, if you want to pass the value of a dword variable as the parameter, rather than the address of that dword variable, you do the following in MASM:<br /><br />  invoke HasRefParm, dwordValue<br /><br />In HLA, you have to do the following:<br /><br />   HasRefParm( val dwordValue ); //Tells HLA to pass the value rather than the address of dwordValue<br /><br />Fortunately, this latter case isn't all that frequent, but it is one more thing you've got to be aware of.<br /><br />HLA's parameter passing mechanisms are quite sophisticated; this means that they can be quite overwhelming for beginners just approaching this stuff.  I can easily see why someone would prefer the &quot;everything-is-a-dword&quot; approach.  OTOH, once you figure all this stuff out, it begins to make a lot of sense to use typed parameters.<br /><br />One other nice thing about the HLA header files for Windows is that they generally specify HLA string types whenever an API function expects a zero-terminated string address. This is convenient because you can use HLA's string functions to do a lot of manipulation on those strings before passing them on to Windows.  This trick is a bit less convenient when using the &quot;everything-is-a-dword&quot; approach.<br /><br />In any case, the whole issue of passing parameters by value and reference to Windows functions is complex. So much so, that I'm probably going to devote an early chapter to this one subject in my &quot;Windows Programming in Assembly&quot; book.<br /><br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-05-21 15:35:42 by rhyde</div>
   </div>
   <div class="post" id="post-104373">
    <div class="subject"><a href="#post-104373">encounter a new problem with UuidToStringA</a></div>
    <div class="body">Thank you for all your help.<br /><br />I encountered a new problem, how to write a procedure like UuidToStringA in .hhf?<br /><br />The second parameter is char**, so I do not know how to translate it.</div>
    <div class="meta">Posted on 2003-05-22 20:03:53 by henryw</div>
   </div>
   <div class="post" id="post-104494">
    <div class="subject"><a href="#post-104494">Re: encounter a new problem with UuidToStringA</a></div>
    <div class="body"><div class="quote"><br />Thank you for all your help.<br /><br />I encountered a new problem, how to write a procedure like UuidToStringA in .hhf?<br /><br />The second parameter is char**, so I do not know how to translate it. </div><br /><br />char** objects are simply pointers to pointers.<br />So you just pass a dword value that is a pointer (probably to an array of strings).<br /><br />e.g.,<br /><br />type<br />   strarray_t:string[256];<br />static<br />    strarray:strarray_t;<br /><br />procedure procWithCharStarStar( s:strarray_t );<br />    .<br />    .<br />    .<br /><br />  procWithCharStarStar( &amp;strarray);<br /><br /><br />The &quot;pure&quot; way to do it is like this:<br /><br />type<br />   pchar: pointer to char;<br />   ppchar : pointer to pchar;<br /><br />procedure hasPPchar( p:ppchar );<br />   .<br />   .<br />   .<br /><br />The real trick is how to dereferece the pointer inside the procedure.<br />Usually, char** objects are really just pointers to string arrays.<br />This means you use the pointer passed to the procedure as a pointer<br />to an array of four-byte string pointers (easy enough to deal with).<br />If it's really a pointer to a pointer to a character and you want to access<br />the individual character, you use double indirection, e.g.,<br /><br />mov( p, ebx );  // get pointer to pointer<br />mov( , ebx ); // get pointer to char<br />mov( , ch );   // Get the character<br /><br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-05-23 10:54:39 by rhyde</div>
   </div>
   <div class="post" id="post-104546">
    <div class="subject"><a href="#post-104546">help with .hhf and program</a></div>
    <div class="body">Thank you Randy.<br /><br />But does it mean a HLA style string can not work as a receiver to the result of the <br /><br />procedure with pointer to pointers object? The function like UuidToString always return a <br /><br />null terminated string.<br /><br />The way following can work, but I do not know if it is correct enough:<br />--------------------------------------------<br />   UuidToStringA: procedure<br />   (<br />   UUID: dword;<br />   GUIDStr: dword<br />   );<br />   @stdcall;<br />   @returns(&quot;eax&quot;);<br />   @external(&quot;__imp__UuidToStringA@8&quot;);<br />--------------------------------------------<br />static <br />  MyGuid:w.GUID;<br />  aMacAddr: str.strvar(256);<br />  aGUIDStr: str.strvar(256);<br />  pGUID: pointer to char;  //pointer to whatever, char, byte...<br /><br />begin MacAdd;<br />  UuidCreateSequential(&amp;MyGuid);<br /><br />  UuidToStringA(&amp;MyGuid, &amp;pGUID);<br /><br />  mov(pGUID, eax);<br />  str.cpyz(, aGUIDStr);<br />  str.upper(aGUIDStr);<br />  str.substr(aGUIDStr, aMacAddr, 24, 12);<br />  <br />     w.MessageBox<br />     (<br />       0,<br />       aMacAddr,<br />       &quot;UserName&quot;,<br />       w.MB_OK<br />      );</div>
    <div class="meta">Posted on 2003-05-23 19:06:44 by henryw</div>
   </div>
   <div class="post" id="post-104748">
    <div class="subject"><a href="#post-104748">help with .hhf and program</a></div>
    <div class="body"><div class="quote"><br />Thank you Randy.<br /><br />But does it mean a HLA style string can not work as a receiver to the result of the <br /><br />procedure with pointer to pointers object? The function like UuidToString always return a <br /><br />null terminated string.<br /><br />The way following can work, but I do not know if it is correct enough:<br />--------------------------------------------<br />   UuidToStringA: procedure<br />   (<br />   UUID: dword;<br />   GUIDStr: dword<br />   );<br />   @stdcall;<br />   @returns(&quot;eax&quot;);<br />   @external(&quot;__imp__UuidToStringA@8&quot;);<br />--------------------------------------------<br />static <br />  MyGuid:w.GUID;<br />  aMacAddr: str.strvar(256);<br />  aGUIDStr: str.strvar(256);<br />  pGUID: pointer to char;  //pointer to whatever, char, byte...<br /><br />begin MacAdd;<br />  UuidCreateSequential(&amp;MyGuid);<br /><br />  UuidToStringA(&amp;MyGuid, &amp;pGUID);<br /><br />  mov(pGUID, eax);<br />  str.cpyz(, aGUIDStr);<br />  str.upper(aGUIDStr);<br />  str.substr(aGUIDStr, aMacAddr, 24, 12);<br />  <br />     w.MessageBox<br />     (<br />       0,<br />       aMacAddr,<br />       &quot;UserName&quot;,<br />       w.MB_OK<br />      ); </div><br /><br /><br />Okay, what UuidToStringA is really asking for is the address of a zero-terminated<br />string pointer.  UuidToString will allocate sufficient storage for the zero terminated<br />string and store the address of that string in the pointer who address you pass<br />to UuidToStr.  Here's what the calling sequence should look like:<br /><br />static<br />      pGUID: pointer to char;  // Note that you do not initialize this pointer...<br />        .<br />        .<br />        .<br />    UuidToStringA(&amp;MyGuid, &amp;pGUID);<br /><br />// Now pGUID points at a zero terminated array of characters somewhere.<br />// You can pass pGUID to a string conversion function like str.cpyz if you<br />// want to convert it to an HLA string, or you can operate on it directly using<br />// HLA's zero-terminated string functions.<br /><br />According to the Win32 documentation, it is your responsibility to call<br />rpcStringFree to free the storage associated with pGUID when you are<br />done using it (in particular, do *not* call the HLA Stdlib's free function to<br />do this).<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-05-25 13:43:16 by rhyde</div>
   </div>
  </div>
 </body>
</html>