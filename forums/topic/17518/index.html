<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>My useful Macro's and Procs! - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17518" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=17518">My useful Macro's and Procs!</a></p>
   <div class="post" id="post-135535">
    <div class="subject"><a href="#post-135535">My useful Macro's and Procs!</a></div>
    <div class="body">Hi all,<br /><br />I just wanted to post a few of my macro's and procs!<br />Most are enhanced versions of common macros!<br />Some have become invaluable to me!<br />Please note that some Procs/Macros might depend on others, for example, Many use my mAlloc() macro to allocate memory!<br />Take them, modify them and use them freely!</div>
    <div class="meta">Posted on 2004-03-10 00:44:48 by SubEvil</div>
   </div>
   <div class="post" id="post-135536">
    <div class="subject"><a href="#post-135536">My useful Macro's and Procs!</a></div>
    <div class="body">This macro is an enhancement to the commonly used return macro in the MASM package.<br />My version is more &quot;intelligent&quot; (I hope) and will somewhat &quot;optimize&quot; the coding depending on the value returned!<br />I kept my (untidy) comments which can be easily removed or replaced!<br /><br /><pre><code><br />;; -----------------<br />;; return val in eax<br />;; -----------------<br />return MACRO val&#58;REQ ;; .type == OPATTR<br />;  LOCAL val ;; Declares val as a local variable only, used incase of name conflicts<br />  IF &#40;.type&#40;val&#41;&#41; AND 00010000y ;; Register == 16<br />    IFDIFI &lt;val&gt;, &lt;eax&gt; ;; No need to use ! before eax cause it's not a variable<br />      mov eax, val<br />    ELSE<br />      ;; if val == eax ... then all we need to do is use ret, no additional code!<br />      ;.err &lt;return should not be used if the return value is already in eax&gt;<br />    ENDIF<br />  ELSEIF &#40;.type&#40;val&#41;&#41; AND 00000010y ;; Memory Variable<br />    mov eax, val<br />  ELSEIF &#40;.type&#40;val&#41;&#41; AND 00000100y ;; Constant == 4<br />    IF val EQ 0 ;; Test for zero<br />      xor eax, eax  ;; slightly more efficient for zero<br />    ELSE<br />      mov eax, val<br />    ENDIF<br />  ELSE<br />    mov eax, val<br />  ENDIF<br />  ret<br />ENDM<br /></code></pre></div>
    <div class="meta">Posted on 2004-03-10 00:45:21 by SubEvil</div>
   </div>
   <div class="post" id="post-135537">
    <div class="subject"><a href="#post-135537">My useful Macro's and Procs!</a></div>
    <div class="body"><pre><code><br /><br />;; This is a simple macro to display a message in a message box.<br />;; Not really needed except for ... debuggin!<br />;; eg. mDebugMsg &quot;Here&quot;<br />;; I use it constantly to provide me with general/quick visual feedback of what code is currently being executed<br />;; Can theoretically sit anywhere in code as it preserves all registers and flags before calling the messagebox with my message<br />;; This macro is generally the same as mErrorMsg, but I usually remove this macro once I'm done and know what's going on in my code<br />;; I often use it in .if or while statements to check things out. <br />mDebugMsg MACRO Text&#58;REQ<br />  LOCAL szDebugMsgText<br />  .const<br />    szDebugMsgText db Text, 0<br />    IFNDEF szDebugMsgTitle<br />      szDebugMsgTitle db &quot;Debug Message&quot;, 0<br />    ENDIF<br />  .code<br />    pushad ; Push all registers<br />    pushfd ; Push all flags<br />    invoke MessageBox, NULL, addr szDebugMsgText, addr szDebugMsgTitle, MB_OK + MB_ICONWARNING<br />    popfd<br />    popad<br />ENDM<br /></code></pre></div>
    <div class="meta">Posted on 2004-03-10 00:49:07 by SubEvil</div>
   </div>
   <div class="post" id="post-135538">
    <div class="subject"><a href="#post-135538">My useful Macro's and Procs!</a></div>
    <div class="body"><pre><code><br />;; Very similar to the above macro mDebugMsg but allows you to define a custom title instead of the standard &quot;Debug Message&quot; used above!<br />;; Also, I leave this macro in my code for error reporting!<br />mErrorMsg MACRO MsgText&#58;REQ, MsgTitle<br />  LOCAL MsgText<br />  LOCAL MsgTitle<br />  LOCAL szErrorMsgText<br />  LOCAL szErrorMsgTempTitle<br />  .const<br />    szErrorMsgText db MsgText, 0<br />  IFB &lt;MsgTitle&gt;<br />    IFNDEF szErrorMsgTitle<br />      szErrorMsgTitle DB &quot;Error&quot;, 0<br />    ENDIF<br />    .code<br />      invoke MessageBox, NULL, addr szErrorMsgText, addr szErrorMsgTitle, MB_OK + MB_ICONERROR<br />  ELSE<br />    szErrorMsgTempTitle db MsgTitle, 0<br />    .code<br />      invoke MessageBox, NULL, addr szErrorMsgText, addr szErrorMsgTempTitle, MB_OK + MB_ICONERROR<br />  ENDIF<br />ENDM<br /></code></pre></div>
    <div class="meta">Posted on 2004-03-10 00:51:50 by SubEvil</div>
   </div>
   <div class="post" id="post-135539">
    <div class="subject"><a href="#post-135539">My useful Macro's and Procs!</a></div>
    <div class="body"><pre><code><br />;; Allocates memory using HeapAlloc function<br />;; Used to directly return the memory location in code!<br />;; eg. mov Buffer, mAlloc&#40;32&#41;<br />;; The above will allocate 32 bytes of memory using the ProcessHeap<br /><br />mAlloc MACRO AllocSize&#58;REQ<br />  IFNDEF szHeapAllocErrorTitle<br />    .const<br />      szHeapAllocErrorTitle DB &quot;HeapAlloc Error&quot;, 0<br />      szHeapAllocSTATUS_NO_MEMORY DB &quot;STATUS_NO_MEMORY Message received after call to HeapAlloc&quot;, 0<br />      szHeapAllocSTATUS_ACCESS_VIOLATION DB &quot;STATUS_NO_MEMORY Message received after call to HeapAlloc&quot;, 0<br />    .code<br />  ENDIF<br />  call GetProcessHeap<br />  invoke HeapAlloc, eax, HEAP_GENERATE_EXCEPTIONS or HEAP_ZERO_MEMORY, AllocSize<br />  .if eax == STATUS_NO_MEMORY<br />    invoke MessageBox, NULL, addr szHeapAllocSTATUS_NO_MEMORY, addr szHeapAllocErrorTitle, MB_OK + MB_ICONERROR<br />  .elseif eax == STATUS_ACCESS_VIOLATION<br />    invoke MessageBox, NULL, addr szHeapAllocSTATUS_ACCESS_VIOLATION, addr szHeapAllocErrorTitle, MB_OK + MB_ICONERROR<br />  .endif<br />  EXITM &lt;eax&gt;<br />ENDM<br /></code></pre></div>
    <div class="meta">Posted on 2004-03-10 00:59:23 by SubEvil</div>
   </div>
   <div class="post" id="post-135540">
    <div class="subject"><a href="#post-135540">My useful Macro's and Procs!</a></div>
    <div class="body"><pre><code><br />;; Frees the above allocated memory<br /><br />mFree MACRO FreeAddr&#58;REQ<br />  call GetProcessHeap<br />  invoke HeapFree, eax, NULL, FreeAddr<br />  .if eax == NULL<br />    mGetLastError &quot;Error Freeing Heap Memory&quot;, &quot;HeapFree Error&quot;<br />  .endif<br />ENDM<br /></code></pre></div>
    <div class="meta">Posted on 2004-03-10 01:02:16 by SubEvil</div>
   </div>
   <div class="post" id="post-135541">
    <div class="subject"><a href="#post-135541">My useful Macro's and Procs!</a></div>
    <div class="body">The next Macro is used after an API call that returns error messages and codes using GetLastError. The Macro will extract the error code, and message from the Windows Resource files, so the exact Windows message is displayed. For example:<br /><br /><pre><code><br />  invoke RegisterClassEx, addr wc<br />  .if eax == NULL<br />    mGetLastError &quot;Error processing call to RegisterClassEx for new Window class&quot;, &quot;RegisterClassEx Error&quot;<br />  .endif<br /></code></pre><br /><br /><br /><pre><code><br />;; Used to retrieve the GetLastError code for most Windows API's<br />;; I use this macro extensively and it's VERY useful.<br />;; It will automatically get the apropriate Windows Error code and description.<br />;; It will also add a custom message at the top.<br />;; I use it with the custom message to tell me where in my code it generated an error.<br />;; This macro is essential to error reporting and saves a lot of lines of code<br />;; eg. mGetLastError &quot;A call to CreateWindowEx generated the following error&quot;, &quot;CreateWindowEx Error&quot;<br />;; I've tried to save some memory by doing several checks and only assigning memory to strings when neaded!<br /><br />mGetLastError MACRO CustomMsg, CustomMsgTitle<br />  LOCAL szCustomMsg<br />  LOCAL szCustomMsgTitle<br />  IFNB &lt;CustomMsg&gt;<br />    IF @SizeStr&#40;CustomMsg&#41; NE 2<br />      .const<br />        szCustomMsg DB CustomMsg, 0Dh, 0Ah, &quot;Error Code &quot;, 0<br />    ELSEIFNDEF szGetLastErrorMsgPrefix<br />      .const<br />        szGetLastErrorMsgPrefix DB &quot;Error Code &quot;, 0<br />    ENDIF<br />  ELSEIFNDEF szGetLastErrorMsgPrefix<br />    .const<br />      szGetLastErrorMsgPrefix DB &quot;Error Code &quot;, 0<br />  ENDIF<br />  IFNB &lt;CustomMsgTitle&gt;<br />    .const<br />      szCustomMsgTitle DB CustomMsgTitle, 0<br />  ELSEIFNDEF szGetLastErrorMsgTitle<br />    .const<br />      szGetLastErrorMsgTitle DB &quot;GetLastError&quot;, 0<br />  ENDIF<br />  IFNDEF hFullErrorMsg<br />    .data<br />      hFullErrorMsg DD 0<br />      hGetLastErrorMsg DD 0<br />      hGetLastErrorCode DD 0<br />    .const<br />      szGeneralErrorMsgSpacer DB &quot;&#58; &quot;, 0<br />  ENDIF<br />  .code<br />    mov hGetLastErrorCode, mAlloc&#40;11&#41;<br />    push NULL<br />    push NULL<br />    push offset hGetLastErrorMsg<br />    push NULL<br />    invoke GetLastError<br />    push eax<br />    invoke dw2str, eax, hGetLastErrorCode<br />    push NULL<br />    push FORMAT_MESSAGE_ALLOCATE_BUFFER or FORMAT_MESSAGE_FROM_SYSTEM<br />    call FormatMessage<br />    ;; This is uncommented to show the general format of the above function call<br />;    invoke FormatMessage, FORMAT_MESSAGE_ALLOCATE_BUFFER or FORMAT_MESSAGE_FROM_SYSTEM, NULL, eax, NULL, addr hGetLastErrorMsg, NULL, NULL<br />    IFNB &lt;CustomMsg&gt;<br />      IF @SizeStr&#40;CustomMsg&#41; NE 2<br />        invoke lstrlen, hGetLastErrorMsg<br />        add eax, @SizeStr&#40;&lt;CustomMsg&gt;&#41; + 2 + &#40;11 + 11 + 2&#41;<br />        mov hFullErrorMsg, mAlloc&#40;eax&#41;<br />        invoke lstrcat, hFullErrorMsg, addr szCustomMsg<br />      ELSE<br />        invoke lstrlen, hGetLastErrorMsg<br />        add eax, 11 + 11 + 2<br />        mov hFullErrorMsg, mAlloc&#40;eax&#41;<br />        invoke lstrcat, hFullErrorMsg, addr szGetLastErrorMsgPrefix<br />      ENDIF<br />    ELSE<br />      invoke lstrlen, hGetLastErrorMsg<br />      add eax, 11 + 11 + 2<br />      mov hFullErrorMsg, mAlloc&#40;eax&#41;<br />      invoke lstrcat, hFullErrorMsg, addr szGetLastErrorMsgPrefix<br />    ENDIF<br />    invoke lstrcat, hFullErrorMsg, hGetLastErrorCode<br />    invoke lstrcat, hFullErrorMsg, addr szGeneralErrorMsgSpacer<br />    invoke lstrcat, hFullErrorMsg, hGetLastErrorMsg<br />    IFNB &lt;CustomMsgTitle&gt;<br />      invoke MessageBox, NULL, hFullErrorMsg, addr szCustomMsgTitle, MB_OK + MB_ICONERROR<br />    ELSE<br />      invoke MessageBox, NULL, hFullErrorMsg, addr szGetLastErrorMsgTitle, MB_OK + MB_ICONERROR<br />    ENDIF<br />    invoke LocalFree, hGetLastErrorMsg<br />    invoke HeapFree, App.Heap, NULL, hFullErrorMsg<br />    invoke HeapFree, App.Heap, NULL, hGetLastErrorCode<br />ENDM<br /></code></pre></div>
    <div class="meta">Posted on 2004-03-10 01:09:54 by SubEvil</div>
   </div>
   <div class="post" id="post-135542">
    <div class="subject"><a href="#post-135542">My useful Macro's and Procs!</a></div>
    <div class="body">I have found the next procedure invaluable. For debuggin purposes, sometimes I want to display a register or variable's value, and SEE with my own eyes what the value is, and how it changed. The next proc was one of the first assembler procs I wrote. All it does is convert and display the 32bit value in a messagebox. But also, because I often want to do some calculation on the variable, it stores the string value in the clipboard. So be warned, using it will remove clipboard data, but the value can then simply be used to past in Calculator. Also, it will preserve all registers and flags, so it can theoretically be used ANYWHERE in code without affecting your algorithm.<br /><br />eg. invoke MsgDD, eax<br /><br /><pre><code><br />;; MsgDD is somewhat similar to the dw2str function, it basically just converts the input falue to a string representation!<br />;; Then it copies the value to the clipboard, I did this cause I usually use this value in a calculation or to paste in Notepad<br />;; Then show the value in a messagebox. The function also preserves the registers and flags, so it can be used anywhere in code!<br />;; I use it extensivesly when debugging to check values as they go by.<br />;; eg. invoke MsgDD, eax<br />;; This will display the value in eax for me and won't affect the program so I can use it anywhere!<br /><br />MsgDD PROC Val  &#58;DWORD ;USES eax ecx edx esi edi Val &#58;DWORD<br />  LOCAL hAlloc  &#58;DWORD <br /><br />  pushad ; Push all registers<br />  pushfd ; Push all flags<br /><br />  ;; NB Memory used for the clipboard is allocated with GlobalAlloc and NOT freed!<br />  invoke GlobalAlloc, GMEM_MOVEABLE and GMEM_DDESHARE, 11<br />  .if eax == NULL<br />    mGetLastError &quot;Error allocating memory for MsgDD&quot;, &quot;GlobalAlloc Error&quot;<br />  .elseif<br />    mov hAlloc, eax<br /><br />    mov   edi, hAlloc ; edi stores the beginning offset of our string<br /><br />    mov   eax, Val      ; eax now contains input value for division later<br />    mov   esi, edi      ; copy the offset of our string to esi &#40;now both esi &amp; ecx contain the offset&#41;<br />    mov   ecx, 0Ah      ; 0Ah == 10 == Decimal system &#40;similar to Radix parameter of _itoa&#41;<br /><br />  @@&#58;<br />    xor   edx, edx            ; Clear edx for division<br />    div   ecx                 ; Divide eax by 10 &#40;Radix&#41;<br />    add   dl, 30h             ; Add 48 to the value &#40;This is value for 0 &#40;zero&#41; on ASCII table&#41;<br />    mov   byte ptr &#91;edi&#93;, dl  ; Move our new ASCII value into string position<br />    inc   edi                 ; Move to next string value<br />    test  eax, eax            ; Test to see if we've reached 0 &#40;zero&#41;<br />    jnz   short @B            ; If &#40;!Zero?&#41; Then ... Go Back to beginning<br />    mov   byte ptr &#91;edi&#93;, 0   ; Place our terminating zero into position<br />    dec   edi                 ; Decrement ecx so we can begin reversing string<br /><br />  @@&#58;                   ; This section reverses our string<br />    mov   dl, &#91;esi&#93;<br />    mov   al, &#91;edi&#93;<br />    mov   &#91;edi&#93;, dl<br />    dec   edi<br />    mov   &#91;esi&#93;, al<br />    inc   esi<br />    cmp   esi, edi<br />    jb    short @B<br /><br />    ;;Clipboard<br />    invoke OpenClipboard, NULL<br />    .if eax == NULL<br />      mGetLastError &quot;&quot;, &quot;OpenClipboard Error&quot;<br />    .else<br />      invoke EmptyClipboard<br />      .if eax == NULL<br />        mGetLastError &quot;&quot;, &quot;EmptyClipboard Error&quot;<br />      .else<br />        invoke SetClipboardData, CF_TEXT, hAlloc<br />        .if eax == NULL<br />          mGetLastError &quot;&quot;, &quot;SetClipboardData Error&quot;<br />        .endif<br />      .endif<br />      invoke CloseClipboard<br />      .if eax == NULL<br />        mGetLastError &quot;&quot;, &quot;CloseClipboard Error&quot;<br />      .endif<br />    .endif<br /><br />    invoke MessageBox, NULL, hAlloc, sz&#40;&quot;MsgDD&quot;&#41;, MB_OK  ; Finally display our message<br />  .endif<br />  popfd<br />  popad<br />  ret<br />MsgDD ENDP<br /></code></pre></div>
    <div class="meta">Posted on 2004-03-10 01:19:20 by SubEvil</div>
   </div>
   <div class="post" id="post-135543">
    <div class="subject"><a href="#post-135543">My useful Macro's and Procs!</a></div>
    <div class="body">MsgHex is exactly the same as the above function, but displays the Hex value in a messagebox, instead of Decimal. I wrote this function while writing my GetPixel conversion to display RGB values which are usually better viewed as Hex values.<br /><br /><pre><code><br />MsgHex PROC Val &#58;DWORD<br />  LOCAL hAlloc  &#58;DWORD <br /><br />  pushad ; Push all registers<br />  pushfd ; Push all flags<br /><br />  ;; NB Memory used for the clipboard is allocated with GlobalAlloc and NOT freed!<br />  invoke GlobalAlloc, GMEM_MOVEABLE and GMEM_DDESHARE, 11<br />  .if eax != NULL<br />    mov hAlloc, eax<br /><br />    mov   edi, hAlloc   ; edi stores the beginning offset of our string<br /><br />    mov   eax, Val      ; eax now contains input value for division later<br />    mov   esi, edi      ; copy the offset of our string to esi &#40;now both esi &amp; ecx contain the offset&#41;<br />    mov   ecx, 10h      ; 10h == 16 == Hex system &#40;similar to Radix parameter of _itoa&#41;<br /><br />  @@&#58;<br />    xor   edx, edx            ; Clear edx for division<br />    div   ecx                 ; Divide eax by 16 &#40;Radix&#41;<br />    .IF &#40;dl &gt; 9&#41;<br />      sub   dl, 9<br />      add   dl, 40h<br />    .ELSE<br />      add   dl, 30h<br />    .ENDIF<br />    mov   byte ptr &#91;edi&#93;, dl  ; Move our new ASCII value into string position<br />    inc   edi                 ; Move to next string value<br />    test  eax, eax            ; Test to see if we've reached 0 &#40;zero&#41;<br />    jnz   short @B            ; If &#40;!Zero?&#41; Then ... Go Back to beginning<br />    mov   byte ptr &#91;edi&#93;, 0   ; Place our terminating zero into position<br />    dec   edi                 ; Decrement ecx so we can begin reversing string<br /><br />  @@&#58;                   ; This section reverses our string<br />    mov   dl, &#91;esi&#93;<br />    mov   al, &#91;edi&#93;<br />    mov   &#91;edi&#93;, dl<br />    dec   edi<br />    mov   &#91;esi&#93;, al<br />    inc   esi<br />    cmp   esi, edi<br />    jb    short @B<br /><br />    ;;Clipboard<br />    invoke OpenClipboard, NULL<br />    .if eax == NULL<br />      mGetLastError &quot;&quot;, &quot;OpenClipboard Error&quot;<br />    .else<br />      invoke EmptyClipboard<br />      .if eax == NULL<br />        mGetLastError &quot;&quot;, &quot;EmptyClipboard Error&quot;<br />      .else<br />        invoke SetClipboardData, CF_TEXT, hAlloc<br />        .if eax == NULL<br />          mGetLastError &quot;&quot;, &quot;SetClipboardData Error&quot;<br />        .endif<br />      .endif<br />      invoke CloseClipboard<br />      .if eax == NULL<br />        mGetLastError &quot;&quot;, &quot;CloseClipboard Error&quot;<br />      .endif<br />    .endif<br /><br />    invoke MessageBox, NULL, hAlloc, sz&#40;&quot;MsgHex&quot;&#41;, MB_OK  ; Finally display our message<br />  .elseif<br />    mGetLastError &quot;Error allocating memory for MsgHex&quot;, &quot;GlobalAlloc Error&quot;<br />  .endif<br />  popfd<br />  popad<br />  ret<br />MsgHex ENDP<br /></code></pre></div>
    <div class="meta">Posted on 2004-03-10 01:23:49 by SubEvil</div>
   </div>
   <div class="post" id="post-135544">
    <div class="subject"><a href="#post-135544">My useful Macro's and Procs!</a></div>
    <div class="body"><pre><code><br />;; This function is an extention to MsgDD<br />;; I wrote it cause sometimes I want to display a message with my value,<br />;; cause perhaps I'm displaying several values and if I don't display a small message with it, I won't know where I am!<br />;; eg. invoke MsgTxtDD, eax, sz&#40;&quot;WinSock generated the following Error&#58; &quot;&#41;, sz&#40;&quot;WinSock Error&quot;&#41;<br />;; Very useful to me when debugging! So the above will show a message and the value returned<br />;; Also preserves registers and flags! Only really useful during debugging stage!<br />MsgTxtDD PROC inVal &#58;DWORD, pText&#58;DWORD, pTitle &#58;DWORD<br />  LOCAL pAlloc &#58;DWORD <br />  LOCAL pFinalAlloc &#58;DWORD <br /><br />  pushad ; Push all registers<br />  pushfd ; Push all flags<br /><br />  ;; NB Memory used for the clipboard is allocated with GlobalAlloc and NOT freed!<br />  invoke GlobalAlloc, GMEM_MOVEABLE and GMEM_DDESHARE, 11<br />  .if eax== NULL<br />    mGetLastError &quot;Error allocating memory for MsgTxtDD&quot;, &quot;GlobalAlloc Error&quot;<br />  .elseif<br />    mov pAlloc, eax<br /><br />    mov   edi, pAlloc ; edi stores the beginning offset of our string<br /><br />    mov   eax, inVal      ; eax now contains input value for division later<br />    mov   esi, edi      ; copy the offset of our string to esi &#40;now both esi &amp; ecx contain the offset&#41;<br />    mov   ecx, 0Ah      ; 0Ah == 10 == Decimal system &#40;similar to Radix parameter of _itoa&#41;<br /><br />  @@&#58;<br />    xor   edx, edx            ; Clear edx for division<br />    div   ecx                 ; Divide eax by 10 &#40;Radix&#41;<br />    add   dl, 30h             ; Add 48 to the value &#40;This is value for 0 &#40;zero&#41; on ASCII table&#41;<br />    mov   byte ptr &#91;edi&#93;, dl  ; Move our new ASCII value into string position<br />    inc   edi                 ; Move to next string value<br />    test  eax, eax            ; Test to see if we've reached 0 &#40;zero&#41;<br />    jnz   short @B            ; If &#40;!Zero?&#41; Then ... Go Back to beginning<br />    mov   byte ptr &#91;edi&#93;, 0   ; Place our terminating zero into position<br />    dec   edi                 ; Decrement ecx so we can begin reversing string<br /><br />  @@&#58;                   ; This section reverses our string<br />    mov   dl, &#91;esi&#93;<br />    mov   al, &#91;edi&#93;<br />    mov   &#91;edi&#93;, dl<br />    dec   edi<br />    mov   &#91;esi&#93;, al<br />    inc   esi<br />    cmp   esi, edi<br />    jb    short @B<br /><br />    ;;Clipboard<br />    invoke OpenClipboard, NULL<br />    .if eax== NULL<br />      mGetLastError &quot;&quot;, &quot;OpenClipboard Error&quot;<br />    .else<br />      invoke EmptyClipboard<br />      .if eax == NULL<br />        mGetLastError &quot;&quot;, &quot;EmptyClipboard Error&quot;<br />      .else<br />        invoke SetClipboardData, CF_TEXT, pAlloc<br />        .if eax == NULL<br />          mGetLastError &quot;&quot;, &quot;SetClipboardData Error&quot;<br />        .endif<br />      .endif<br />      invoke CloseClipboard<br />      .if eax == NULL<br />;        mGetLastError &quot;&quot;, &quot;CloseClipboard Error&quot;<br />      .endif<br />    .endif<br /><br />    .if pText == NULL<br />      .if pTitle == NULL<br />        IFNDEF szMsgTxtDDTitle<br />          .const<br />            szMsgTxtDDTitle db &quot;MsgTxtDD&quot;, 0<br />          .code<br />        ENDIF<br />        invoke MessageBox, NULL, pAlloc, addr szMsgTxtDDTitle, MB_OK  ; Finally display our message<br />      .else<br />        invoke MessageBox, NULL, pAlloc, pTitle, MB_OK  ; Finally display our message<br />      .endif<br />    .else<br />      invoke lstrlen, pText<br />      add eax, 11<br />      mov pFinalAlloc, mAlloc&#40;eax&#41;<br />      invoke lstrcat, pFinalAlloc, pText<br />      invoke lstrcat, pFinalAlloc, pAlloc<br /><br />      .if pTitle == NULL<br />        IFNDEF szMsgTxtDDTitle<br />          .const<br />            szMsgTxtDDTitle db &quot;MsgTxtDD&quot;, 0<br />          .code<br />        ENDIF<br />        invoke MessageBox, NULL, pFinalAlloc, addr szMsgTxtDDTitle, MB_OK  ; Finally display our message<br />      .else<br />        invoke MessageBox, NULL, pFinalAlloc, pTitle, MB_OK  ; Finally display our message<br />      .endif<br />      mFree&#40;pFinalAlloc&#41;<br />    .endif<br />  .endif<br />  popfd<br />  popad<br />  ret<br />MsgTxtDD ENDP<br /></code></pre></div>
    <div class="meta">Posted on 2004-03-10 01:27:26 by SubEvil</div>
   </div>
   <div class="post" id="post-135545">
    <div class="subject"><a href="#post-135545">My useful Macro's and Procs!</a></div>
    <div class="body"><pre><code><br />;; Basically the same as the above mGetLastError except it retrieves the Winsock API error for most of the WinSock API functions<br /><br />mWSAGetLastError MACRO CustomMsg, CustomMsgTitle<br />  LOCAL szCustomMsg<br />  LOCAL szCustomMsgTitle<br />  IFNB &lt;CustomMsg&gt;<br />    IF @SizeStr&#40;CustomMsg&#41; NE 2<br />      .const<br />        szCustomMsg DB CustomMsg, 0Dh, 0Ah, &quot;Error Code &quot;, 0<br />    ELSEIFNDEF szGetLastErrorMsgPrefix<br />      .const<br />        szGetLastErrorMsgPrefix DB &quot;Error Code &quot;, 0<br />    ENDIF<br />  ELSEIFNDEF szGetLastErrorMsgPrefix<br />    .const<br />      szGetLastErrorMsgPrefix DB &quot;Error Code &quot;, 0<br />  ENDIF<br />  IFNB &lt;CustomMsgTitle&gt;<br />    .const<br />      szCustomMsgTitle DB CustomMsgTitle, 0<br />  ELSEIFNDEF szWSAGetLastErrorMsgTitle<br />    .const<br />      szWSAGetLastErrorMsgTitle DB &quot;WSAGetLastError&quot;, 0<br />  ENDIF<br />  IFNDEF hFullErrorMsg<br />    .data<br />      hFullErrorMsg DD 0<br />      hGetLastErrorMsg DD 0<br />      hGetLastErrorCode DD 0<br />    .const<br />      szGeneralErrorMsgSpacer DB &quot;&#58; &quot;, 0<br />  ENDIF<br />  .code<br />    mov hGetLastErrorCode, mAlloc&#40;11&#41;<br />    push NULL<br />    push NULL<br />    push offset hGetLastErrorMsg<br />    push NULL<br />    invoke WSAGetLastError<br />    push eax<br />    invoke dw2str, eax, hGetLastErrorCode<br />    push NULL<br />    push FORMAT_MESSAGE_ALLOCATE_BUFFER or FORMAT_MESSAGE_FROM_SYSTEM<br />    call FormatMessage<br />    IFNB &lt;CustomMsg&gt;<br />      IF @SizeStr&#40;CustomMsg&#41; NE 2<br />        invoke lstrlen, hGetLastErrorMsg<br />        add eax, @SizeStr&#40;&lt;CustomMsg&gt;&#41; + 2 + &#40;11 + 11 + 2&#41;<br />        mov hFullErrorMsg, mAlloc&#40;eax&#41;<br />        invoke lstrcat, hFullErrorMsg, addr szCustomMsg<br />      ELSE<br />        invoke lstrlen, hGetLastErrorMsg<br />        add eax, 11 + 11 + 2<br />        mov hFullErrorMsg, mAlloc&#40;eax&#41;<br />        invoke lstrcat, hFullErrorMsg, addr szGetLastErrorMsgPrefix<br />      ENDIF<br />    ELSE<br />      invoke lstrlen, hGetLastErrorMsg<br />      add eax, 11 + 11 + 2<br />      mov hFullErrorMsg, mAlloc&#40;eax&#41;<br />      invoke lstrcat, hFullErrorMsg, addr szGetLastErrorMsgPrefix<br />    ENDIF<br />    invoke lstrcat, hFullErrorMsg, hGetLastErrorCode<br />    invoke lstrcat, hFullErrorMsg, addr szGeneralErrorMsgSpacer<br />    invoke lstrcat, hFullErrorMsg, hGetLastErrorMsg<br />    IFNB &lt;CustomMsgTitle&gt;<br />      invoke MessageBox, NULL, hFullErrorMsg, addr szCustomMsgTitle, MB_OK + MB_ICONERROR<br />    ELSE<br />      invoke MessageBox, NULL, hFullErrorMsg, addr szWSAGetLastErrorMsgTitle, MB_OK + MB_ICONERROR<br />    ENDIF<br />    invoke LocalFree, hGetLastErrorMsg<br />    invoke HeapFree, App.Heap, NULL, hFullErrorMsg<br />    invoke HeapFree, App.Heap, NULL, hGetLastErrorCode<br />ENDM<br /></code></pre></div>
    <div class="meta">Posted on 2004-03-10 01:29:44 by SubEvil</div>
   </div>
   <div class="post" id="post-135567">
    <div class="subject"><a href="#post-135567">My useful Macro's and Procs!</a></div>
    <div class="body">You need to zip the source files with a readme, and upload to this site, it would make it a neat and clean download for all those interested.</div>
    <div class="meta">Posted on 2004-03-10 10:42:08 by DarkStar</div>
   </div>
   <div class="post" id="post-135592">
    <div class="subject"><a href="#post-135592">My useful Macro's and Procs!</a></div>
    <div class="body">You should use VKim debug macros for debugging purposes. Its much easier than using message box, even with your macros.</div>
    <div class="meta">Posted on 2004-03-10 20:12:11 by Mikky</div>
   </div>
  </div>
 </body>
</html>