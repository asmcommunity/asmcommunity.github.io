<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>segmentation fault and ddd tool - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30672" />
    <link rel="next" href="../?id=30672&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=30672">segmentation fault and ddd tool</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=30672&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=30672&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="30672" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=30672&amp;page=2">&gt;</a><a href="../?id=30672&amp;page=2">&raquo;</a></form>   <div class="post" id="post-215032">
    <div class="subject"><a href="#post-215032">segmentation fault and ddd tool</a></div>
    <div class="body">Hello!<br /><br />I have a piece of code here that I just can&#039;t get to work. I get segmentation fault and now I&#039;m trying to apply a ddd tool to understand the problem. I haven&#039;t used ddd before but there seem to be some kind of a problem around the subroutines&nbsp; fgets or gettext. I have been putting a breakpoint&nbsp; at various places but I guess I&#039;m doing some mistake here.&nbsp; <br /><br />fgets reads what comes from the keyboard and then I&#039;m supposed to transfer that piece of text(in this case, for the moment, 2 numbers ) into a buffer (INBUFFERT ) with gettext. But I&#039;m obviously doing something wrong here.<br /><br />Putting a breakpoint at fgets and then stepi I get the message &quot;a syntax error in expression, near 0x123d30&quot;<br />Here&#039;s the code:<br /><pre><code><br />.equ 	MAXPOS, 40<br />.equ 	POS, 44<br />.equ 	MINPOS, 48<br /><br />.data <br />Head:		.asciz	&quot;Start of testprogram.Put in 2 numbers!&quot;<br />Show_Integ:	.asciz	&quot;%d\n&quot;<br />Buf:		.skip	64<br />N:		.long	0<br />T:		.long	0<br />Show:		.asciz	&quot;%s\n&quot;<br /><br />Intg:		.long	0<br /><br />UTBUFFERT:	.skip 128<br />INBUFFERT:	.skip 128<br /><br />.text<br />.globl main, puttext, outimage, inimage, getint<br /><br /><br />main:		<br />		pushl		$Head		/*Head lagras på stacken*/<br />		call		puttext		/*Denna text läggs nu in i UTBUFFERT*/<br />		call		outimage	/*Texten tas från UTBUFFERT och skrivs nu ut på skärmen*/<br />		call		inimage<br />		movl		$5, N<br />		call		getint<br />		<br />		call		printgetint_end<br />		call		exit<br /><br />printgetint_end:	<br />		pushl	%eax<br />		pushl	$Show_Integ<br />		call	printf		<br />		addl	$8, %esp	<br />		movl	$0, %eax<br />		ret<br /><br />puttext:<br />		pushl	%ebp<br />		movl	%esp, %ebp<br />		movl	$UTBUFFERT, %ecx<br />		movl	8(%ebp), %ebx<br /><br />next:		movb	(%ebx), %al<br />		cmpb	$0, %al<br />		je	puttextLoopEnd<br />		movb	%al, (%ecx)<br />		incb	%cl<br />		incb	%bl<br />		jmp	next<br /><br />puttextLoopEnd:<br />		movl	%ebp, %esp<br />		popl	%ebp<br />		ret<br /><br />outimage:	<br />		pushl	$UTBUFFERT<br />		pushl	$Show<br />		call 	printf<br />		addl	$8, %esp <br />		ret<br /><br />inimage:	<br />		pushl	stdin<br />		pushl	$79<br />		pushl	Buf<br />		call	fgets<br />		addl	$12,%esp<br />		xorl	%ecx, %ecx		/*position = 0*/<br /><br />gettext:	pushl	%ebp<br />		movl	%esp, %ebp<br />		movl	$INBUFFERT, %ebx<br /><br />gettext_loop:<br />		movb	(%eax), %dl<br />		cmpb	$13, %dl<br />		je	end_gettext<br />		movb	%dl, (%ebx)<br />		incl	%eax<br />		incl	%ebx<br />		incl	%ecx<br />		jmp	gettext_loop<br /><br />end_gettext:<br />		movl	%ecx, MAXPOS(%ebp)<br />		movl	$0, %ecx<br />		movl	%ebp, %esp<br />		popl	%ebp<br />		ret<br /><br />getint:	<br />		popl	%ebp<br />		movl	%esp, %ebp<br />		movl	$1, %edi<br />		call	getinpos<br /><br />getchar:	<br />		movl	$INBUFFERT, (%ebx)<br />		cmpb	$45, (%ebx)		/*check to see if the character = &#039;-&#039;*/<br />		je	increase_charN		/*if so, jump to increase_charN*/<br />		jmp	getchar_loop		/*if not, jump to getchar_loop*/<br /><br />getchar_loop:<br />		cmpb	$32, (%ebx)<br />		je	increase_char	<br />		movzx	(%ebx), %eax<br />		pushl	%eax<br />		incl	%ecx<br />		incl	%ebx<br />		jmp	getchar_loop<br /><br />increase_char:	incl	%ecx<br />		incl	%ebx<br />		jmp	setinpos<br /><br />getint_loop:<br />		popl	%eax<br />		subl	$48, %eax<br />		imul	%edi, %eax<br />		addl	%eax, Intg<br />		imul	$10, %edi<br />		decl	%ecx<br />		cmpl	$0, %ecx<br />		je	getint_end<br />		jmp	getint_loop<br />getint_end:<br />		xorl	%eax, %eax<br />		movl	Intg, %eax<br />		movl	%ebp, %esp<br />		popl	%ebp<br />		ret<br /><br />setinpos:<br />		cmpl	$0, %ecx<br />		jb	setinpos_zero<br />		cmpl	MAXPOS(%ebp), %ecx<br />		jg	setinpos_max	<br />		movl	%ecx, POS(%ebp)<br />		jmp	getint_loop<br /><br />setinpos_zero:	<br />		movl	$0, %ecx<br />		movl	%ecx, MINPOS(%ebp)<br />		jmp	getint_loop<br /><br />setinpos_max:	<br />		movl	MAXPOS(%ebp), %ecx<br />		movl	%ecx, POS(%ebp)<br />		jmp	getint_loop<br /><br />getinpos:	<br />		cmpl	$0, %ecx<br />		je	getchar<br />		movl	POS(%ebp), %ecx<br />		movl	%ecx, %ebx<br />		ret<br /><br /><br />getint_loopN:<br />		popl	%eax<br />		subl	$48, %eax<br />		imul	%edi, %eax<br />		addl	%eax, Intg<br />		imul	$10, %edi<br />		decl	%ecx<br />		cmpl	$0, %ecx<br />		je	getint_end<br />		jmp	getint_loopN<br />getint_endN:<br />		xorl	%eax, %eax<br />		movl	Intg, %eax<br />		movl	%ebp, %esp<br />		popl	%ebp<br />		ret<br /><br />setinposN:<br />		cmpl	$0, %ecx<br />		jb	setinpos_zeroN<br />		cmpl	MAXPOS(%ebp), %ecx<br />		jg	setinpos_maxN	<br />		movl	%ecx, POS(%ebp)<br />		jmp	getint_loopN<br /><br />setinpos_zeroN:	<br />		movl	$0, %ecx<br />		movl	%ecx, MINPOS(%ebp)<br />		jmp	getint_loopN<br /><br />setinpos_maxN:	<br />		movl	MAXPOS(%ebp), %ecx<br />		movl	%ecx, POS(%ebp)<br />		jmp	getint_loopN<br /><br />increase_charN:<br />		incl	%ecx<br />		incl	%ebx<br />		jmp	setinposN<br /><br />getchar_loopN:<br />		cmpb	$32, (%ebx)<br />		je	increase_charN	<br />		movzx	(%ebx), %eax<br />		pushl	%eax<br />		incl	%ecx<br />		incl	%ebx<br />		jmp	getchar_loopN<br /></code></pre><br />With the code I just want to take the first number and print it out. If it&#039;s a negative number there are subroutines to take care of that. At least I hope they do. <br />Since I get the error message &quot;Segmentation fault&quot; I thought that&nbsp; with the ddd tool it should be easy to find out this problem but I don&#039;t think so. I understand that there is some kind of problem with the stack so I&#039;m looking up the source - backtrace in order to see the stack but it doesn&#039;t help me. What&nbsp; shall I do in order to solve this problem?<br />Can anyone please help me out here?<br /><br />Anders <br /><br /><br /></div>
    <div class="meta">Posted on 2011-09-20 06:15:54 by anders11</div>
   </div>
   <div class="post" id="post-215036">
    <div class="subject"><a href="#post-215036">Re: segmentation fault and ddd tool</a></div>
    <div class="body">Two things I&#039;ve found quickly glancing at your code:<br /><br />From main() you<br /><pre><code><br />		call		getint<br /></code></pre><br /><br />and the very first thing you do inside getint is<br /><br /><pre><code><br />		popl	%ebp<br /></code></pre><br /><br />You probably meant to <br /><br /><pre><code><br />		pushl	%ebp<br /></code></pre><br /><br />Secondly, in gettext() you<br /><br /><pre><code><br />gettext:	pushl	%ebp<br /></code></pre><br /><br />but you have a condition within your code that calls itself without a balanced pop:<br /><pre><code><br />		je	end_gettext<br /></code></pre><br /><br />You&#039;ll need to rework that logic.<br />Hope that helps you some.<br /></div>
    <div class="meta">Posted on 2011-09-20 19:10:43 by p1ranha</div>
   </div>
   <div class="post" id="post-215043">
    <div class="subject"><a href="#post-215043">Re: segmentation fault and ddd tool</a></div>
    <div class="body">Thanks a lot for answering. I&nbsp; fixed the first in getint and now it&#039;s pushl %ebp, ofcourse. But I can&#039;t see your second point in <br /><pre><code><br />je end_gettext<br /></code></pre><br />- you say that I here have a condition without a balanced pop. But in end_gettext I do have a balanced pop:<br /><pre><code><br />end_gettext:<br />		 movl	 %ecx, MAXPOS(%ebp)<br />		 movl	 $0, %ecx<br />		 movl	 %ebp, %esp<br />		 popl	 %ebp<br />		 ret<br /></code></pre><br /><br />Or isn&#039;t this a balanced pop?<br /><br /></div>
    <div class="meta">Posted on 2011-09-21 09:55:58 by anders11</div>
   </div>
   <div class="post" id="post-215044">
    <div class="subject"><a href="#post-215044">Re: segmentation fault and ddd tool</a></div>
    <div class="body">I&#039;ve taken the following code blocks out so you can see what p1ranha is talking about.<br /><br /><pre><code>getint_loop:<br />		popl	%eax<br />		subl	$48, %eax<br />		imul	%edi, %eax<br />		addl	%eax, Intg<br />		imul	$10, %edi<br />		decl	%ecx<br />		cmpl	$0, %ecx<br />		je	getint_end<br />		jmp	getint_loop<br />getint_end:</code></pre><br /><br /><pre><code>getint_loopN:<br />		popl	%eax<br />		subl	$48, %eax<br />		imul	%edi, %eax<br />		addl	%eax, Intg<br />		imul	$10, %edi<br />		decl	%ecx<br />		cmpl	$0, %ecx<br />		je	getint_end<br />		jmp	getint_loopN<br />getint_endN:</code></pre><br /><br />Each time the code loops in these two blocks, your procedure is pushing data onto the stack without cleaning it up. So when the pop/ret occurs at the end of the procedure, the EIP stored on the stack has been corrupted which causes a segmentation fault.</div>
    <div class="meta">Posted on 2011-09-21 10:42:58 by Synfire</div>
   </div>
   <div class="post" id="post-215064">
    <div class="subject"><a href="#post-215064">Re: segmentation fault and ddd tool</a></div>
    <div class="body">Thanks a lot for answering.I&#039;m not sure that I understand this. If I put in for example the numbers 314 and -2125 then as a start my program will in the getchar_loop push 3 then 1 and then 4 on to the stack . Later on coming down to getint_loop I will pop out 4 then 1 and then 3 with popl %eax. What is not correct here ? I push three times on to the stack and then I pop off three times from the stack ? Isn&#039;t this balanced, or what do I not understand here?<br />In the getint_procedure I&#039;m popping not pushing? Do you mean that I have to do<br />pushl %ebp<br />movl%esp, %ebp<br /> code<br />movl % ebp, %esp<br />popl %ebp<br />in these routines, or what?<br /><br />I thought that&nbsp; my problem was somwhere with fgets. What I have in fgets (i e %eax) I have to put in the INBUFFERT with gettext. I thought that my problem was somewhere here? <br /><br /></div>
    <div class="meta">Posted on 2011-09-22 08:29:53 by anders11</div>
   </div>
   <div class="post" id="post-215067">
    <div class="subject"><a href="#post-215067">Re: segmentation fault and ddd tool</a></div>
    <div class="body">Edit: my bad.</div>
    <div class="meta">Posted on 2011-09-22 12:08:12 by p1ranha</div>
   </div>
   <div class="post" id="post-215068">
    <div class="subject"><a href="#post-215068">Re: segmentation fault and ddd tool</a></div>
    <div class="body">You&#039;re right, there is a minor problem calling fgets.<br /><pre><code><br />pushl Buf<br /></code></pre><br />should be:<br /><pre><code><br />pushl $Buf<br /></code></pre><br /><br />You also specify a &quot;size&quot; of $79, but you&#039;ve only got a buffer of 64 bytes! That, in itself, does not solve your problem - still segfaults.<br /><br />After the fgets, you copy the text to another buffer. Why? There&#039;s a problem there, too - you look for $13 (a carriage return) to mark the end of the input text, but fgets puts $10 (a linefeed) there, so I don&#039;t think that loop is going to end!<br /><br />If I may say so, you seem to be making this a lot more complicated than it needs to be. To begin with, you copy your &quot;prompt&quot; (Head) to another buffer and print that. Why not print it where it is?<br /><br />Why not use scanf to get your numbers? Perhaps that&#039;s the &quot;assignment&quot;, to do that yourself? Not a bad thing to learn how to do, in any case...<br /><br />You get into some real &quot;spagetti code&quot; in keeping track of the &quot;position&quot;. I&#039;m having trouble following it (I&#039;m not very familiar with AT&amp;T syntax, which doesn&#039;t help!). I think you may have an unbalanced push/pop in there, but I&#039;m not sure.<br /><br />I&#039;d try a slightly different approach:<br /><br />Zero up a register to use for &quot;result so far&quot;.<br />looptop:<br />get a character from the string<br />make sure it&#039;s a valid digit - if not, done? Or return an error?<br />subtract 48 to convert character to number<br />multiply &quot;result so far&quot; by ten<br />add your new number<br />back to looptop<br /><br />You can probably get &quot;your method&quot; to work, too. I&#039;m still working on it - no joy yet!<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2011-09-22 14:18:14 by fbkotler</div>
   </div>
   <div class="post" id="post-215073">
    <div class="subject"><a href="#post-215073">Re: segmentation fault and ddd tool</a></div>
    <div class="body">Oh, I see. I (the pesky user) am supposed to enter two numbers on one line with a space between &#039;em. I was expecting to enter one number, hit &quot;enter&quot; and enter the second number. If I do that, segfault. If I do it right, it doesn&#039;t segfault. Doesn&#039;t give a &quot;sensible&quot; answer, either. What&#039;s it &quot;supposed&quot; to do, anyway? Add the two numbers?<br /><br />In any case, when you find the space ($32) in the string, I think you&#039;ll want to reset %edi to $1 - you&#039;ve multiplied it by ten for each digit in the first number. If you want to do something other than add the two numbers together in &quot;Intg&quot;, you may want to save the first number to someplace else, and re-zero &quot;Intg&quot;, too. I think it would be easier, and more flexible, to get the two numbers separately... depending on what the &quot;assignment&quot; (or the program specification) calls for.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2011-09-23 00:05:15 by fbkotler</div>
   </div>
   <div class="post" id="post-215085">
    <div class="subject"><a href="#post-215085">Re: segmentation fault and ddd tool</a></div>
    <div class="body">Thanks for answering. Some questions and comments;<br />should the buffer be 79x4=316 bytes?<br />you say that &quot;but fgets puts $10 (a linefeed) there &quot;&nbsp; &nbsp; Sorry, I don&#039;t understand what you mean, from where do fgets put&nbsp; $10? <br /><br />I can&#039;t use fscanf according to the assignment. I&#039;m only allowed to use fgets and printf. So gettext has to read the characters and put them in a buffer. (INBUFFERT)<br /><br />The loop to convert a string to an integer does work. That can&#039;t be a problem.&nbsp; <br /><br />In order to make the code more comprehensible for other people I cut it down and showed only parts of it. But&nbsp; I believe that I cut it down to much. I therefore put out the code again&nbsp; -but extended with more explanations.&nbsp; Hopefully it is easier to understand now.<br /><pre><code><br />.equ 	MAXPOS, 40<br />.equ 	POS, 44<br />.equ 	MINPOS, 48<br /><br />.data <br />Head:		.asciz	&quot;Start of testprogram.Put in 2 numbers!&quot;<br />Show_Integ:	.asciz	&quot;%d\n&quot;<br />Buf:		.skip	316<br />N:		.long	0<br />T:		.long	0<br />Show:		.asciz	&quot;%s\n&quot;<br /><br />Intg:		.long	0<br /><br />UTBUFFERT:	.skip 128<br />INBUFFERT:	.skip 128<br /><br />.text<br />.globl main, puttext, outimage, inimage, getint<br /><br /><br />main:						/*main,Upp and pp1 is part of the testprogram*/<br />		pushl		$Head		/*Head is pushed on to the stack*/<br />		call		puttext		/*This piece of text is now being pointed to the buffer UTBUFFERT*/<br />		call		outimage	/*The text is taken from UTBUFFERT and is written on the screen*/<br />		call		inimage	<br />		movl		$2, N<br /><br />Upp:		call		getint		/*getint takes the numbers being written on the screen and tranfers*/ 								/*them from strings to integers*/<br />		movl		%eax, T		/*the returned value is being transfered to memoryadress T*/<br />		cmpl		$0, %eax	<br />		jge		pp1<br />		call		getoutpos	/*if it&#039;s a negative number call getoutpos and */ 	<br />						/*return the position in %eax*/		<br />		decl		%eax		/*decrease the position with 1*/<br />		pushl		%eax		/*push the position on to the stack*/<br />		call		setoutpos	/**/<br /><br />pp1:		movl		T, %edx<br />		addl		%edx, Sum <br />		pushl		%edx<br />		call		putint<br />		pushl		$&#039;+&#039;<br />		pushl		putchar<br />		decl		%eax<br />		pushl		%eax<br />		call		getoutpos		<br />		decl		%eax<br />		pushl		%eax<br />		call		setoutpos		<br />		<br />		pushl		$&#039;=&#039;<br />		call		putchar<br />		pushl		Sum<br />		call		outimage<br />				<br />		call		exit<br /><br /><br />puttext:<br />		pushl	%ebp<br />		movl	%esp, %ebp<br />		movl	$UTBUFFERT, %ecx<br />		movl	8(%ebp), %ebx<br /><br />next:		movb	(%ebx), %al<br />		cmpb	$0, %al<br />		je	puttextLoopEnd<br />		movb	%al, (%ecx)<br />		incb	%cl<br />		incb	%bl<br />		jmp	next<br /><br />puttextLoopEnd:<br />		movl	%ebp, %esp<br />		popl	%ebp<br />		ret<br /><br />outimage:	<br />		pushl	$UTBUFFERT<br />		pushl	$Show<br />		call 	printf<br />		addl	$8, %esp <br />		ret<br /><br />inimage:					/*Inimage uses fgets so that gettext can read in the numbers from	the keyboard*/<br />		pushl	stdin<br />		pushl	$20<br />		pushl	$Buf<br />		call	fgets			/*the numbers being typed in is now in %eax*/<br />		addl	$12,%esp<br />		xorl	%ecx, %ecx		/*position = 0*/<br />gettext:	pushl	%ebp			/*gettext takes what is written from the keyboard and moves the*/<br />		movl	%esp, %ebp		/*characters from %eax to %dl*/<br />		subl	$128, %esp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  /*making space on the stack*/<br />		movl	$INBUFFERT, %ebx<br /><br />gettext_loop:<br />		movb	(%eax), %dl<br />		cmpb	$13, %dl		/*When I&#039;ve put in two numbers and hit carriage return, = $13*/ 						/*this will be the endpoint and when done we jump to 							end_gettext*/		<br />		je	end_gettext<br />		movb	%dl, (%ebx)<br />		incl	%eax<br />		incl	%ebx<br />		incl	%ecx<br />		jmp	gettext_loop<br /><br />end_gettext:<br />		movl	%ecx, MAXPOS(%ebp)	/*move the number of characters into MAXPOS*/<br />		movl	$0, %ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />		movl	%ebp, %esp<br />		popl	%ebp<br />		ret<br />getint:	<br />		pushl	%ebp<br />		movl	%esp, %ebp<br />		movl	$1, %edi<br />		call	getinpos<br /><br />getchar:	/*return a character and increase the position with 1*/<br />		movl	$INBUFFERT, (%ebx)<br />		cmpb	$45, (%ebx)		/*check to see if the character = &#039;-&#039;*/<br />		je	increase_charN		/*if so, jump to increase_charN*/<br />		jmp	getchar_loop		/*if not, jump to getchar_loop*/<br /><br />getchar_loop:<br />		cmpb	$32, (%ebx)		/*check to see if we&#039;re at the end, ie space*/<br />		je	increase_char		/*if space jump to increase_char*/<br />		movzx	(%ebx), %eax		/*else move byte from INBUFFERT to %eax */<br />		pushl	%eax			/*push the moved byte on to the stack*/<br />		incl	%ecx<br />		incl	%ebx<br />		jmp	getchar_loop<br /><br />increase_char:	incl	%ecx<br />		incl	%ebx<br />		jmp	setinpos<br /><br />getint_loop:					/*transfer the string to integer*/<br />		popl	%eax			/*pop out a number*/<br />		subl	$48, %eax		/*transfer the character to an integer*/<br />		imul	%edi, %eax		/*1st step, multiply with 1,2nd step, multiply with 10 and so on....*/<br />		addl	%eax, Intg		/*add the integer to Intg*/<br />		imul	$10, %edi		/*multiply edi with 10*/<br />		decl	%ecx			/*decrease the position*/<br />		cmpl	$1, %ecx		/*if the position = 1*/<br />		je	getint_end		/*jump to getint_end*/<br />		jmp	getint_loop<br />getint_end:<br />		xorl	%eax, %eax<br />		movl	Intg, %eax<br />		movl	%ebp, %esp<br />		popl	%ebp<br />		ret<br /><br />setinpos:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /*set the position to n*/<br />		cmpl	$0, %ecx		/*check to see that the position isn&#039;t below zero*/<br />		jb	setinpos_zero<br />		cmpl	MAXPOS(%ebp), %ecx	/*or bigger than maxpos*/<br />		jg	setinpos_max	<br />		movl	%ecx, POS(%ebp)<br />		jmp	getint_loop<br /><br />setinpos_zero:	<br />		movl	$0, %ecx		/*if pos&lt;0 , %ecx = 0*/ <br />		movl	%ecx, MINPOS(%ebp)<br />		jmp	getint_loop<br /><br />setinpos_max:	<br />		movl	MAXPOS(%ebp), %ecx	/*if pos&gt;MAXPOS,%ecx = MAXPOS*/<br />		movl	%ecx, POS(%ebp)<br />		jmp	getint_loop<br /><br />getinpos:	/*return the position*/				<br />		cmpl	$0, %ecx		/*if the position = 0*/<br />		je	getchar			/*jump to getchar*/<br />		movl	POS(%ebp), %ecx		/*else move the position to %ecx and then %ebx and return*/<br />		movl	%ecx, %ebx<br />		ret<br /><br /><br />getint_loopN:<br />		popl	%eax<br />		subl	$48, %eax<br />		imul	%edi, %eax<br />		addl	%eax, Intg<br />		imul	$10, %edi<br />		decl	%ecx<br />		cmpl	$0, %ecx<br />		je	getint_end<br />		jmp	getint_loopN<br />getint_endN:<br />		xorl	%eax, %eax<br />		movl	Intg, %eax<br />		movl	%ebp, %esp<br />		popl	%ebp<br />		ret<br /><br />setinposN:<br />		cmpl	$0, %ecx<br />		jb	setinpos_zeroN<br />		cmpl	MAXPOS(%ebp), %ecx<br />		jg	setinpos_maxN	<br />		movl	%ecx, POS(%ebp)<br />		jmp	getint_loopN<br /><br />setinpos_zeroN:	<br />		movl	$0, %ecx<br />		movl	%ecx, MINPOS(%ebp)<br />		jmp	getint_loopN<br /><br />setinpos_maxN:	<br />		movl	MAXPOS(%ebp), %ecx<br />		movl	%ecx, POS(%ebp)<br />		jmp	getint_loopN<br /><br />increase_charN:<br />		incl	%ecx<br />		incl	%ebx<br />		jmp	setinposN<br /><br />getchar_loopN:<br />		cmpb	$32, (%ebx)<br />		je	increase_charN	<br />		movzx	(%ebx), %eax<br />		pushl	%eax<br />		incl	%ecx<br />		incl	%ebx<br />		jmp	getchar_loopN<br /><br />putint:		pushl	%ebp		<br />		movl	%esp,%ebp<br />		movl	$0, %edi		<br />		popl	%edx		/*pop out the integer */<br />		movl	%edx, %eax<br />conversion_loop:	/*convert the integer to a string*/<br />		movl	$0, %edx<br />		idivl	%edi		/*divide eax with edi, quota eax/edi in eax, remainder in edx*/<br />		addl	$48, %edx<br />		pushl	%edx<br />		incl	%ecx<br />		cmpl	$0, %ecx<br />		je	end_conversion_loop<br />		jmp	conversion_loop<br /><br />end_conversion_loop:<br />		movl	%ecx, POSOUT(%ebp)<br />		movl	$UTBUFFERT, %edx<br /><br />copy_reversing_loop:<br />		popl	%eax<br />		movb	%al,(%edx)<br />		decl	%ecx<br />		incl	%edx<br />		<br />		cmpl	$0, %ecx	<br />		je	end_copy_reversing_loop<br />		jmp	copy_reversing_loop<br /><br />end_copy_reversing_loop:<br />		movl	%ebp, %esp<br />		popl	%ebp<br />		ret<br /><br />putchar:	/*transfer a character*/<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushl	%ebp<br />		movl	%esp, %ebp<br />		popl	%eax<br />		movl	$UTBUFFERT, %edx<br />		movl	POSOUT(%ebp), %edx <br />		movb	%al, %edx<br />		movl	POSOUT(%ebp), %ecx<br />		incl	%ecx<br />		movl	%ecx, POSOUT(%ebp)<br />		movl	%ebp,%esp<br />		ret<br /><br />getoutpos:	/*return position for UTBUFFERT*/<br />		pushl	%ebp<br />		movl	%esp, %ebp<br />		movl	POSOUT(%ebp),%eax<br />		movl	$UTBUFFERT, %ebx<br />		movl	%eax, %ebx<br />		movb	(%ebx), %dl<br />		xorl	%edx, %edx<br />		movl	%ebp, %esp<br />		popl 	%ebp<br />		ret<br /><br />setoutpos:/*set position for UTBUFFERT*/	<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushl	%ebp<br />		movl	%esp, %ebp<br />		cmpl	$0, %eax<br />		jb	setoutpos_zero<br />		cmpl	MAXPOSIN(%ebp), %eax<br />		jg	setoutpos_max<br />		movl	%eax, POSOUT(%ebp)<br />		movl	%esp, %ebp<br />		popl	%ebp<br />		ret<br /><br />setoutpos_zero:<br />		movl	$0, %eax<br />		movl	%eax, POSOUT(%ebp)<br />		movl	%esp, %ebp<br />		popl	%ebp<br />		ret<br /><br />setoutpos_Max:	movl	MAXPOSIN(%ebp), %eax<br />		movl	%eax, POSOUT(%ebp)<br />		movl	%esp, %ebp<br />		popl	%ebp<br />		ret<br /></code></pre><br /> Hopefully it&#039;s not too much code here.<br />The assignment in short; I want to read the numbers that I&#039;ve put in and transfer them to integers. If the numbers are negative it will&nbsp; go through the getint_loopN routine (my solution)<br />Later on (it&#039;s not shown here) these numbers will be added together. But for now I just show this piece of code. I need to have one buffert for the input(INBUFFERT) and then one buffert for the output(UTBUFFERT).<br />The numbers that I&#039;ve put in will later on be shown on the screen so if I add 314SPC-125 this will be shown on the screen: 314-125=189.&nbsp; <br /><br />The testprogram will add the + sign after 314 and therefore, since I&#039;ve added the – sign on 125, decrease the position.<br />I realise now that I have to make space on the stack in order to push something on to it. I&#039;m not really that comfortable with the stack.&nbsp; <br /><br />When it comes to the transfer from string to integer that part of the code is OK, I&#039;ve allready got that part to work. <br /><br />I have to save the position since I have to have control of every position all the time. But I&#039;m not really sure that 40, 44, 48 and so on are the correct places on the stack.<br /> The testprogram is written by the teacher and can&#039;t be changed. <br /><br />You&#039;re not supposed to add the two numbers in Intg, this is a conversionpart, if I have the number 314 it will be 4 + 10 + 300 (= 314). The addition of the two integers is taking place in Sum. <br />Hopefully all this makes it more comprehensible and that it&#039;s not too much of code here<br /><br />Anders</div>
    <div class="meta">Posted on 2011-09-25 09:28:33 by anders11</div>
   </div>
   <div class="post" id="post-215086">
    <div class="subject"><a href="#post-215086">Re: segmentation fault and ddd tool</a></div>
    <div class="body">This doesn&#039;t even assemble, as posted. (G)as upchucks on line 271, as it should, and when I &quot;fix&quot; that, gcc comes up with a bunch of undefined references (beginning with &quot;Sum&quot;). I don&#039;t think you&#039;ve pasted in the right thing.<br /><br />Since I don&#039;t think this is the &quot;right&quot; program, I suppose there&#039;s no sense in mentioning the errors...<br /><br /><div class="quote"><br />should the buffer be 79x4=316 bytes?<br /></div><br />The buffer needs to be &quot;big enough&quot;, and you need to be careful to tell fgets that much, or less. A 32-bit number could take up to 10 digits. You want two of &#039;em. Plus a possible minus sign on each, plus the space, plus the linefeed...<br /><div class="quote"><br />you say that &quot;but fgets puts $10 (a linefeed) there &quot;&nbsp; &nbsp; Sorry, I don&#039;t understand what you mean, from where do fgets put&nbsp; $10?<br /></div><br />... at the end of the text... before the...<br />...plus the terminating zero! (don&#039;t forget the terminating zero!!!) I make that 25 bytes. Count &#039;em yourself! No harm in making the buffer bigger than it needs to be.<br /><div class="quote"><br />I realise now that I have to make space on the stack in order to push something on to it.<br /></div><br />Actually, you don&#039;t need to make space on the stack to push something onto it, you need to make space on the stack for your &quot;local&quot; variables - &quot;MAXPOS&quot;, &quot;POS&quot;, and &quot;MINPOS&quot;. Remember that these &quot;local&quot; or &quot;automatic&quot; variables are freed when you exit a function. I&#039;m not sure that putting these variables on the stack is the best idea...<br /><div class="quote"><br /> I&#039;m not really that comfortable with the stack.<br /></div><br />It gets easier with practice, but the stack is always tricky - and it has to be right!<br /><br />For example...<br /><pre><code><br />main:						/*main,Upp and pp1 is part of the testprogram*/<br />		pushl		$Head		/*Head is pushed on to the stack*/<br />		call		puttext		/*This piece of text is now being pointed to the buffer UTBUFFERT*/<br /></code></pre><br />By rights, you should:<br /><pre><code><br />addl $4, %esp<br /></code></pre><br />To &quot;balance&quot; or &quot;clean up&quot; the stack. Since you don&#039;t &quot;ret&quot; from main, but call &quot;exit()&quot; instead, this won&#039;t do any harm. You do this a couple more times in &quot;main&quot; before you &quot;call exit&quot; - push a parameter to a function and then don&#039;t &quot;clean up&quot; after the function returns. Not the end of the world, but kind of a &quot;bad habit&quot; perhaps...<br /><br />Anyway, post the one that assembles (if you&#039;ve got one that assembles) - what you&#039;ve posted needs a lot of work!<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2011-09-25 11:52:41 by fbkotler</div>
   </div>
   <div class="post" id="post-215087">
    <div class="subject"><a href="#post-215087">Re: segmentation fault and ddd tool</a></div>
    <div class="body">As Frank had mentioned before, assembly in itself is not difficult, it&#039;s learning the many conventions that all need to fall into place before your programs actually work.&nbsp; To help ease the process and lessen the complexity you may wish to try using the <a target="_blank" href="http://www.asmcommunity.net/projects/nasmx/">NASMX</a> package which was designed to do just that for the <a target="_blank" href="http://www.nasm.us">Nasm Assembler</a>.&nbsp; Frank is a noted Nasm guru.&nbsp; There are quite a few demos for both Linux and Windows that you can base your beginning programs from.&nbsp; You&#039;ll find it very helpful for learning and using assembly.&nbsp; Then later on, if you so choose, you can dive deeper into the complexity that NASMX is shielding you from...</div>
    <div class="meta">Posted on 2011-09-25 12:47:00 by p1ranha</div>
   </div>
   <div class="post" id="post-215132">
    <div class="subject"><a href="#post-215132">Re: segmentation fault and ddd tool</a></div>
    <div class="body">Hi, again<br /><br />Thank you for helping me out here. <br />I&#039;ve been dealing with this program for a week now, changed quite a bit in it and I&#039;ve got it to work a little bit better now. I needed to put some effort into the stack. Heres the code so far, now it works fine down to conversion_loop where I get segfault. <br /><pre><code><br /><br />.data <br />Head:		.asciz	&quot;Start of testprogram.Put in 2 numbers!&quot;<br />Show_Integ:	.asciz	&quot;%d\n&quot;<br />Buf:		.skip	316<br />N:		.long	0<br />T:		.long	0<br />Show:		.asciz	&quot;%s\n&quot;<br />Sum:		.long	0<br />Intg:		.long	0<br />MAXPOS:		.long 	0<br />INPOS:		.long	0<br />OUTPOS:		.long	0<br />UTBUFFERT:	.skip 128<br />INBUFFERT:	.skip 128<br /><br />.text<br />.globl main, puttext, outimage, inimage, getint<br /><br /><br />main:						/*main,Upp and pp1 is part of the testprogram*/<br />		pushl		$Head		/*Head is pushed on to the stack*/<br />		call		puttext		/*This piece of text is now being pointed to the buffer UTBUFFERT*/<br />		call		outimage	/*The text is taken from UTBUFFERT and is written on the screen*/<br />		call		inimage<br />		movl		$2, N<br />		<br />Upp:		call 		getint	<br />		movl		%eax ,T<br />		<br />pp1:		movl		T, %edx<br />		addl		%edx, Sum<br />		pushl		%edx<br />		call		putint<br />		pushl		$&#039;+&#039;<br />		call		putchar<br />		decl		N<br />		cmpl		$0, N<br />		jne		Upp<br />		call		getoutpos<br />		decl		%eax<br />		pushl		%eax<br />		call		setoutpos<br />		pushl		&#039;=&#039;<br />		call		putchar<br />		pushl		Sum<br />		call		putint<br />		call 		outimage<br />		call		exit<br />		<br />puttext:<br />		pushl	%ebp<br />		movl	%esp, %ebp<br />		movl	$UTBUFFERT, %ecx<br />		movl	8(%ebp), %ebx<br /><br />next:		movb	(%ebx), %al<br />		cmpb	$0, %al<br />		je	puttextLoopEnd<br />		movb	%al, (%ecx)<br />		incb	%cl<br />		incb	%bl<br />		jmp	next<br />puttextLoopEnd:<br />		movl	%ebp, %esp<br />		popl	%ebp<br />		ret<br /><br />outimage:	<br />		pushl	$UTBUFFERT<br />		pushl	$Show<br />		call 	printf<br />		addl	$8, %esp <br />		ret<br />inimage:					/*Inimage uses fgets so that we with gettext can read in the numbers from 							the keyboard*/<br />		pushl	stdin<br />		pushl	$79<br />		pushl	$Buf<br />		call	fgets			/*the numbers being typed in is now in %eax*/<br />		addl	$12,%esp<br />		xorl	%ecx, %ecx		/*position = 0*/<br /><br />gettext:<br />		movl	$INBUFFERT, %ebx<br />gettext_loop:<br />		movb	(%eax), %dl<br />		cmpb	$10, %dl		/*When I&#039;ve put in two numbers and hit carriage return, = $10*/ 						/*this will be the endpoint and when done we jump to 							end_gettext*/		<br />		je	end_gettext<br />		movb	%dl, (%ebx)<br />		incl	%eax<br />		incl	%ebx<br />		incl	%ecx<br />		jmp	gettext_loop<br />end_gettext:<br />		incl	%ebx<br />		movb	$32, (%ebx)<br />		movl	%ecx, MAXPOS<br />		ret<br /><br />getint:	<br />		xorl	%ecx, %ecx<br />		movl	$1, %edi<br />		<br />		<br />setinpos:<br />		cmpl	$0, %ecx		<br />		jb	setinpos_zero<br />		cmpl	MAXPOS, %ecx	<br />		jg	setinpos_max	<br />		movl	%ecx, INPOS<br />		jmp	getinpos<br /><br />setinpos_zero:	<br />		movl	$0, %ecx		<br />		movl	%ecx, INPOS<br />		jmp	getinpos<br />setinpos_max:	<br />		movl	MAXPOS, %ecx	<br />		movl	%ecx, INPOS<br />		jmp	getinpos<br /><br />getinpos:						<br />		movl	INPOS, %ecx		<br />		movl	%ecx, %ebx<br />		<br />getchar:	<br />		movl	$INBUFFERT, %ebx<br />		<br />		/*cmpb	$45, (%ebx)		<br />		je	increase_charN	*/	<br />		<br />getchar_loop:<br />		cmpb	$32, (%ebx)		<br />		je	increase_char		<br />		movzx	(%ebx), %eax		<br />		pushl	%eax			<br />		incl	%ecx<br />		incl	%ebx<br />		jmp	getchar_loop<br /><br />increase_char:	<br />		incl	%ebx<br />		movl	%ebx, INPOS<br /><br />getint_loop:					<br />		cmpl	$0, %ecx<br />		je	getint_end<br />		popl	%eax			<br />		subl	$48, %eax		<br />		imul	%edi, %eax		<br />		addl	%eax, Intg		<br />		imul	$10, %edi<br />		decl	%ecx		<br />		jmp	getint_loop<br />getint_end:<br />		xorl	%eax, %eax<br />		movl	Intg, %eax<br />		ret<br /><br />putint:		pushl	%ebp<br />		movl	%esp, %ebp<br />		xorl	%eax, %eax<br />		movl	$10, %edi<br />		/*subl	$4, %esp*/<br />		movl	8(%ebp), %eax<br /><br />putint_loop:	<br />		movl	$0, %edx<br />		idivl	%edi<br />		addl	$48, %edx<br />		<br />		pushl	%edx<br />		incl	%ecx<br />		cmpl	$0, %eax<br />		je	end_putint_loop<br />		jmp	putint_loop<br /><br />end_putint_loop:<br />		movl	$UTBUFFERT, %edx<br />		movl	OUTPOS, %edx<br />		xorl	%ebx, %ebx<br />copy_reversing_loop:<br />		cmpl	$0, %ecx<br />		je	end_copy_reversing_loop<br />		decl	%ecx<br />		popl	%eax<br />		movb	(%eax), %bl<br />		movb	%bl, (%edx)<br />		incl	%edx<br />		jmp	copy_reversing_loop<br /><br />end_copy_reversing_loop:<br />		movl	%edx, OUTPOS<br />		xorl	%edx, %edx<br />		movl	%ebp, %esp<br />		addl	$4, %esp<br />		popl	%ebp		<br />		ret<br /><br />putchar:<br />		pushl	%ebp<br />		movl	%esp, %ebp<br />		movl	8(%ebp), %ecx<br />		movl	$UTBUFFERT, %edx<br />		movl	OUTPOS, %edx<br />		movb	%cl, (%edx)<br />		incl	%edx<br />		movl	%edx, OUTPOS<br />		movl	%ebp, %esp<br />		addl	$4, %esp		<br />		popl	%ebp<br />		ret<br /><br />getoutpos:	<br />		xorl	%eax, %eax<br />		movl	OUTPOS, %eax<br />		ret<br /><br />setoutpos:<br />		pushl	%ebp<br />		movl	%esp, %ebp<br />		movl	8(%ebp), %ecx<br />		movl	$UTBUFFERT, %edx<br />		movl	OUTPOS, %edx<br />		cmpl	$0, T<br />		jb	neg_sign<br />		movb	%cl, (%edx)<br />		jmp	end_setoutpos<br /><br />neg_sign:	<br />		xorl	%ecx, %ecx<br />		movl	&#039;-&#039;, %ecx<br />		movb	%cl, (%edx)<br />end_setoutpos:<br />		incl	%edx<br />		movl	%edx, OUTPOS<br />		movl	%ebp, %esp		<br />		addl	$4, %esp<br />		popl	%ebp<br />		ret<br /></code></pre><br />When I run it through the debugger everything (the stack and the registers)looks fine, i e they have the appropriate numbers, till I reach the conversion_loop, line 180 something.After popl %eax, %eax gets the value 51, i e 3 as a string, which is correct but in the next step, <br /><pre><code><br />movb	(%eax), %bl<br />movb	%bl, (%edx)<br /></code></pre><br />the debugger stops and says that there is a segfault here.&nbsp; I can&#039;t really find any answers to this when I google on it. <br />So, the first step, converting the string to integer now works fine but trying the opposite,&nbsp; from integer to string, just doesn&#039;t work. I&#039;ve tried the movzx instruction but the assembler doesn&#039;t like that either. And a dozen of other combinations, but I guess that There is something fundamental here that I don&#039;t grasp. Can you help me out on this one? There is propably something here with %eax and pop.<br />Thank you for the advice on NASMX - I will look into that. <br /><br />Anders<br />&nbsp; </div>
    <div class="meta">Posted on 2011-10-05 14:08:19 by anders11</div>
   </div>
   <div class="post" id="post-215133">
    <div class="subject"><a href="#post-215133">Re: segmentation fault and ddd tool</a></div>
    <div class="body">I can&#039;t quit follow your explaination. In &quot;copy_reversing_loop&quot;, I see:<br /><pre><code><br />movb	(%eax), %bl<br /></code></pre><br />This is where the segfault occurs. I entered &quot;1 2&quot; for numbers. At this point, %eax is 0x31 - the ascii character &#039;1&#039;. I don&#039;t know what it&#039;s &quot;supposed&quot; to be, but 0x31 is not valid memory, so it segfaults.<br /><br />Did you mean:<br /><pre><code><br />movb %al, %bl<br /></code></pre><br />?<br />That gets you by that instruction, but it segfaults on the next one:<br /><pre><code><br />movb	%bl, (%edx)<br /></code></pre><br />%edx, at this point, is zero - loaded from &quot;OUTPOS&quot;. What did you intend it to be? I&#039;m thinking maybe one or another of your buffers?<br /><br />Best,<br />Frank<br /><br /> <br /><br /></div>
    <div class="meta">Posted on 2011-10-05 15:43:07 by fbkotler</div>
   </div>
   <div class="post" id="post-215164">
    <div class="subject"><a href="#post-215164">Re: segmentation fault and ddd tool</a></div>
    <div class="body">Hi, again!<br />I been redoing the code again. <br /><pre><code><br /><br />.data <br />Head:		.asciz	&quot;Start of testprogram.Put in 2 numbers!&quot;<br />Show_Integ:	.asciz	&quot;%d\n&quot;<br />Buf:		.skip	316<br />N:		.long	0<br />T:		.long	0<br />Show:		.asciz	&quot;%s\n&quot;<br />Sum:		.long	0<br />Intg:		.long	0<br />MAXPOS:		.long	0	<br />START_INPOS:	.long 	0<br />END_INPOS:	.long	0<br />START_OUTPOS:	.long	0<br />END_OUTPOS:	.long	0<br />UTBUFFERT:	.skip 128<br />INBUFFERT:	.skip 128<br /><br />.text<br />.globl main, puttext, outimage, inimage, getint<br /><br /><br />main:						/*main,Upp and pp1 is part of the testprogram*/<br />		pushl		$Head		/*Head is pushed on to the stack*/<br />		call		puttext		/*This piece of text is now being pointed to the buffer UTBUFFERT*/<br />		call		outimage	/*The text is taken from UTBUFFERT and is written on the screen*/<br />		call		inimage<br />		movl		$2, N<br />		<br />Upp:		call 		getint	<br />		movl		%eax ,T<br />		<br />pp1:		movl		T, %edx<br />		addl		%edx, Sum<br />		pushl		%edx<br />		call		putint<br />		pushl		$&#039;+&#039;<br />		call		putchar<br />		decl		N<br />		cmpl		$0, N<br />		jne		Upp<br />		call		getoutpos<br />		decl		%eax<br />		pushl		%eax<br />		call		setoutpos<br />		pushl		&#039;=&#039;<br />		call		putchar<br />		pushl		Sum<br />		call		putint<br />		call 		outimage<br />		call		exit<br />		<br />puttext:<br />		pushl	%ebp<br />		movl	%esp, %ebp<br />		movl	$UTBUFFERT, %ecx<br />		movl	8(%ebp), %ebx<br /><br />next:		movb	(%ebx), %al<br />		cmpb	$0, %al<br />		je	puttextLoopEnd<br />		movb	%al, (%ecx)<br />		incb	%cl<br />		incb	%bl<br />		jmp	next<br />puttextLoopEnd:<br />		movl	%ebp, %esp<br />		popl	%ebp<br />		ret<br /><br />outimage:	<br />		pushl	$UTBUFFERT<br />		pushl	$Show<br />		call 	printf<br />		addl	$8, %esp <br />		ret<br />inimage:					/*Inimage uses fgets so that we with gettext can read in the numbers from 							the keyboard*/<br />		pushl	stdin<br />		pushl	$79<br />		pushl	$Buf<br />		call	fgets			/*the numbers being typed in is now in %eax*/<br />		addl	$12,%esp<br />		xorl	%ecx, %ecx		/*position = 0*/<br /><br />gettext:<br />		movl	$INBUFFERT, %ebx<br />gettext_loop:<br />		movb	(%eax), %dl<br />		cmpb	$10, %dl		/*When I&#039;ve put in two numbers and hit carriage return, = $13*/ 						/*this will be the endpoint and when done we jump to 							end_gettext*/		<br />		je	end_gettext<br />		movb	%dl, (%ebx)<br />		incl	%eax<br />		incl	%ebx<br />		incl	%ecx<br />		jmp	gettext_loop<br />end_gettext:<br />		incl	%ebx<br />		movb	$32, (%ebx)<br />		movl	%ecx, MAXPOS<br />		xorl	%ecx, %ecx<br />		ret<br /><br />getint:	<br />		movl	$1, %edi<br />		<br />		movl	END_INPOS, %ecx<br />		movl	$0, END_INPOS<br /><br />setinpos:	<br />		movl	%ecx, START_INPOS<br />		cmpl	$0, %ecx		<br />		jb	setinpos_zero<br />		cmpl	MAXPOS, %ecx	<br />		jg	setinpos_max	<br />		<br />		jmp	getinpos<br /><br />setinpos_zero:	<br />		movl	$0, %ecx		<br />		movl	%ecx,START_INPOS<br />		jmp	getinpos<br />setinpos_max:	<br />		movl	MAXPOS, %ecx	<br />		movl	%ecx, START_INPOS<br />		jmp	getinpos<br /><br />getinpos:						<br />		movl	START_INPOS, %ecx		<br />		movl	%ecx, %ebx<br />		<br />getchar:	<br />		movl	$INBUFFERT, %ebx<br />		xorl	%eax, %eax<br />		/*cmpb	$45, (%ebx)		<br />		je	increase_charN	*/	<br />		<br />getchar_loop:<br />		cmpb	$32, (%ebx)		<br />		je	increase_char		<br />		movzx	(%ebx), %eax		<br />		pushl	%eax			<br />		incl	%ecx<br />		incl	%ebx<br />		jmp	getchar_loop<br /><br />increase_char:	<br />		incl	%ecx<br />		movl	%ecx, END_INPOS<br />		decl	%ecx<br /><br />getint_loop:					<br />		cmpl	START_INPOS, %ecx<br />		je	getint_end<br />		popl	%eax			<br />		subl	$48, %eax		<br />		imul	%edi, %eax		<br />		addl	%eax, Intg		<br />		imul	$10, %edi<br />		decl	%ecx		<br />		jmp	getint_loop<br />getint_end:<br />		xorl	%eax, %eax<br />		movl	Intg, %eax<br />		ret<br /><br />putint:		pushl	%ebp<br />		movl	%esp, %ebp<br />		xorl	%eax, %eax<br />		movl	$10, %edi<br />		/*subl	$4, %esp*/<br />		movl	8(%ebp), %eax<br />		xorl	%ecx, %ecx<br />		movl	END_OUTPOS, %ecx<br />		movl	%ecx, START_OUTPOS<br />		movl	$0, END_OUTPOS<br /><br />putint_loop:	<br />		movl	$0, %edx<br />		idivl	%edi<br />		addl	$48, %edx<br />		<br />		pushl	%edx<br />		incl	%ecx<br />		cmpl	$0, %eax<br />		je	end_putint_loop<br />		jmp	putint_loop<br /><br />end_putint_loop:<br />		xorl	%eax, %eax<br />		xorl	%ebx, %ebx<br />		xorl	%edx, %edx<br />		movl	$UTBUFFERT, %ebx<br />		movl	%ecx,END_OUTPOS<br />		<br />copy_reversing_loop:<br />		cmpl	START_OUTPOS, %ecx<br />		je	end_copy_reversing_loop<br />		decl	%ecx<br />		popl	%edx<br />		/*movzx	(%edx), %ebx*/<br />		movb	%dl, %al<br />		movb	%al, (%ebx)<br />		incl	%ebx<br />		jmp	copy_reversing_loop<br /><br />end_copy_reversing_loop:<br />		<br />		xorl	%ebx, %ebx<br />		movl	%ebp, %esp<br />		/*addl	$4, %esp*/<br />		popl	%ebp		<br />		ret<br /><br />putchar:<br />		pushl	%ebp<br />		movl	%esp, %ebp<br />		xorl	%eax, %eax<br />		xorl	%edx, %edx<br />		movl	8(%ebp), %eax<br />		movl	$UTBUFFERT, %edx<br />		movl	END_OUTPOS, %ecx<br />		movb	%al, (%edx)<br />		incl	%ecx<br />		movl	%ecx, END_OUTPOS<br />		movl	%ebp, %esp<br />		/*addl	$4, %esp*/		<br />		popl	%ebp<br />		ret<br /><br />getoutpos:	<br />		xorl	%eax, %eax<br />		movl	END_OUTPOS, %eax<br />		ret<br /><br />setoutpos:<br />		pushl	%ebp<br />		movl	%esp, %ebp<br />		movl	8(%ebp), %ecx<br />		movl	$UTBUFFERT, %edx<br />		movl	END_OUTPOS, %edx<br />		cmpl	$0, T<br />		jb	neg_sign<br />		movb	%cl, (%edx)<br />		jmp	end_setoutpos<br /><br />neg_sign:	<br />		xorl	%ecx, %ecx<br />		movl	&#039;-&#039;, %ecx<br />		movb	%cl, (%edx)<br />end_setoutpos:<br />		incl	%ecx<br />		movl	%ecx, END_OUTPOS<br />		movl	%ebp, %esp		<br />		addl	$4, %esp<br />		popl	%ebp<br />		ret<br /></code></pre><br />And I believe that I&#039;m following your suggestion. The problem now is that the buffer, UTBUFFERT, is not empty, so I have to empty it in&nbsp; some way before starting to fill it up with new stuff. In the lab it says that we should do &quot;an automatic outimage&quot; in order to get an empty buffer to work with. But I don&#039;t understand how that should be done. Do you?<br /><br />Yes, I want %edx to be the buffer, UTBUFFERT.&nbsp; <br />Is it better to work with puts instead of printf for printing out on the screen?<br />I guess that another problem for me is that I have to work with byte, not long, for the positions, i e START_INPOS, END_INPOS and so on...... So that I should do incb %cl and incb %bl instead of incl %ecx and incl %ebx, or?<br />Then I will step through the buffert in bytesteps.?<br />Anders </div>
    <div class="meta">Posted on 2011-10-08 09:44:48 by anders11</div>
   </div>
   <div class="post" id="post-215166">
    <div class="subject"><a href="#post-215166">Re: segmentation fault and ddd tool</a></div>
    <div class="body"><div class="quote"><br />The problem now is that the buffer, UTBUFFERT, is not empty, so I have to empty it in&nbsp; some way before starting to fill it up with new stuff.<br /></div><br />Why?<br /><div class="quote"><br />In the lab it says that we should do &quot;an automatic outimage&quot; in order to get an empty buffer to work with. But I don&#039;t understand how that should be done. Do you?<br /></div><br />No. I haven&#039;t the slightest idea what &quot;an automatic outimage&quot; might be. Perhaps you should ask &quot;locally&quot;. If you really need an empty buffer to work with (dunno why you would), you could zero-fill an existing buffer (&quot;rep stosb&quot; might come in handy), or you could &quot;zalloc()&quot;(?) a new one...<br /><div class="quote"><br />Yes, I want %edx to be the buffer, UTBUFFERT. <br /></div><br />Well, make it so:<br /><pre><code><br />movl $UTBUFFERT, %edx<br /></code></pre><br /><div class="quote"><br />Is it better to work with puts instead of printf for printing out on the screen?<br /></div><br />My preference would be to use system calls, and leave gcc out of it entirely! :) Since you&#039;re not using any of the &quot;features&quot; of printf(), puts() should work just as well. puts() adds a newline at the end of your text, which you might not want - usually it&#039;s not a problem...<br /><div class="quote"><br />I guess that another problem for me is that I have to work with byte, not long, for the positions, i e START_INPOS, END_INPOS and so on......<br /></div><br />Well, you&#039;ve got &#039;em declared as &quot;.long&quot;. I&#039;m not sure what you mean by this. In fact, I have no idea what the purpose of your various &quot;...POS&quot; variables is!<br /><div class="quote"><br />So that I should do incb %cl and incb %bl instead of incl %ecx and incl %ebx, or?<br />Then I will step through the buffert in bytesteps.?<br /></div><br />If you really, truely want to increment just bytes, the byte-sized registers should work. It shouldn&#039;t do any harm to use the full 32-bit registers... and might keep you out of trouble. :)<br /><br />I worked up a &quot;simplified&quot; version of what I think you&#039;re trying to do. It doesn&#039;t get two numbers on one line. so isn&#039;t quite what you want, but it may give you some ideas of a simpler way to approach this...<br /><pre><code><br />.data <br />prompt:		.asciz	&quot;Start of testprogram.Put in 2 numbers!\nFirst number:\n&quot;<br />prompt2:	.asciz	&quot;Second number:\n&quot;<br />firstnum:	.long	0<br />secondnum:	.long	0<br />Sum:		.long	0<br /><br />.text<br />.globl main<br /><br /><br />main:						/*main,Upp and pp1 is part of the testprogram*/<br />		pushl		$prompt		/*prompt is pushed on to the stack*/<br />		call		printf<br />		addl		$4, %esp<br />		call		getint		/*getint takes the numbers being written on the screen and tranfers*/ 								/*them from strings to integers*/<br />		movl		%eax, firstnum<br /><br />		pushl		$prompt2<br />		call		printf<br />		addl		$4, %esp<br />		call		getint<br />		mov		%eax, secondnum<br />		<br />		pushl		firstnum<br />		call		putint<br />		pushl		$&#039;+&#039;<br />		call		putchar<br />		addl		$4, %esp<br />		pushl		secondnum<br />		call		putint<br />		pushl		$&#039;=&#039;<br />		call		putchar<br />		addl		$4, %esp<br />		movl		firstnum, %eax<br />		addl		secondnum, %eax<br />		movl		%eax, Sum<br />		pushl		Sum<br />		call		putint<br />		addl		$4, %esp<br />		pushl		$10<br />		call		putchar<br />		addl		$4, %esp<br />				<br />		pushl		$0&nbsp; # claim no error<br />		call		exit<br /><br /><br />getint:	<br />		pushl	%ebp<br />		movl	%esp, %ebp<br />		subl	$16, %esp # make a buffer<br />		movl	%esp, %ebx<br /><br />		pushl	stdin<br />		pushl	$16<br />		pushl	%ebx # our buffer<br />		call	fgets<br />		addl	$12, %esp<br /><br />		xorl	%eax, %eax # zero result<br />		xorl	%edx, %edx # and sign indicator<br />		cmpb	$&#039;-&#039;, (%ebx)<br />		jnz	getintloop<br />		incl	%ebx # skip the &#039;-&#039;<br />		incl	%edx # and set the &quot;sign indicator&quot;<br />getintloop:<br />		movsx	(%ebx), %ecx # get a character<br />		incl	%ebx # and get ready for next one<br /># make sure we have a valid character<br />		cmpb	$&#039;0&#039;, %cl<br />		jl	invalid<br />		cmpb	$&#039;9&#039;, %cl<br />		ja	invalid<br /># multiply result by ten, subtract &#039;0&#039; from character, and add it<br />		leal	(%eax, %eax, 4), %eax<br />		leal	-0x30(%ecx, %eax, 2), %eax<br /><br />		jmp	getintloop<br />invalid:<br />		testl	%edx, %edx<br />		jz	ispositive<br />		negl	%eax<br />ispositive:<br />		movl	%ebp, %esp<br />		popl	%ebp<br />		ret<br />				<br />putint:<br />		pushl	%ebp<br />		movl	%esp, %ebp<br />		movl	8(%ebp), %eax<br />		movl	$10, %ebx<br />		xorl	%ecx, %ecx<br />		xorl	%edi, %edi<br />		test	%eax, %eax<br />		jns	pushloop<br />		incl	%edi<br />		negl	%eax<br />pushloop:<br />		xorl	%edx, %edx<br />		divl	%ebx<br />		incl	%ecx<br />		addb	$&#039;0&#039;, %dl<br />		pushl	%edx<br />		testl	%eax, %eax<br />		jnz	pushloop<br />		testl	%edi, %edi<br />		jz	poploop<br />		pushl	$&#039;-&#039;<br />		incl	%ecx<br />poploop:<br />		popl	%eax<br />		pushl	%ecx<br />		pushl	%eax<br />		call	putchar<br />		addl	$4, %esp<br />		popl	%ecx<br />		loopl	poploop<br />		movl	%ebp, %esp<br />		popl	%ebp<br />		ret<br /></code></pre><br /><br />Best,<br />Frank<br /><br /><br /></div>
    <div class="meta">Posted on 2011-10-08 14:38:57 by fbkotler</div>
   </div>
   <div class="post" id="post-215178">
    <div class="subject"><a href="#post-215178">Re: segmentation fault and ddd tool</a></div>
    <div class="body">I guess I can use some of that, thankyou, but I&nbsp; can&#039;t really do it the way you&#039;ve done it. You have to put in the numbers once with space inbetween them and then cr.So, I have to put the input numbers in the inbuffer and I then print out what I have converted and put in the outbuffer. The inbuffer will for example look like this: <br />314SPC-55CR<br />this means that spc will have position 3 and the - sign position 4. In the outbuffer and what I will print out&nbsp; will then look like this:<br />314-55=259<br />So, the minus sign will have position 3 , i e I have to keep track of the position. But I don&#039;t think that this is an issue for me, I have control of this.<br /> I believe that right now I have to clean the outbuffer(UTBUFFERT), since I have put in the first piece of text (&quot;Start of program.Put in two numbers!&quot;)(in the testprogram it will be five numbers but I work with two so far just to make things easier for the moment) and that is right now in the outbuffer and this has to be cleaned out before I put in something new. When the text is cleaned out I can then start to fill up the buffer again. (I can&#039;t use the stosb from standard library). And what is in the outbuffer will then be printed out. So, my issue right now is how to clean the outbuffer. <br /><br />Do you know how to do that. ?<br /><br />Anders<br /></div>
    <div class="meta">Posted on 2011-10-09 11:42:11 by anders11</div>
   </div>
   <div class="post" id="post-215180">
    <div class="subject"><a href="#post-215180">Re: segmentation fault and ddd tool</a></div>
    <div class="body">Yeah. &quot;stosb&quot; is not a library call, but a real CPU instruction. It is equivalent to:<br /><pre><code><br /># buffer in edi<br />movb %al, (%edi)<br />incl %edi<br /></code></pre><br />All in a single, one-byte instruction. If you don&#039;t want to use it, the above equivalent should work - use any register, doesn&#039;t have to be edi (but &quot;stosb&quot; works with edi). But it shouldn&#039;t be any problem to re-use a &quot;dirty&quot; buffer - the new input will overwrite the old. (linefeed - 10 - not CR - 13 though)<br /><br />With some small rearrangements, the code I posted can be used to get 2 (or 5) numbers from the same buffer, too. Too nice a day to get into this now. I&#039;ll get back to ya after dark - remind me if I forget!<br /><br />Best,<br />Frank<br /><br /><br /></div>
    <div class="meta">Posted on 2011-10-09 12:13:35 by fbkotler</div>
   </div>
   <div class="post" id="post-215183">
    <div class="subject"><a href="#post-215183">Re: segmentation fault and ddd tool</a></div>
    <div class="body">I have to redo the subroutine outimage, now itlooks like this:<br /><pre><code><br />outimage:	<br />		pushl	$UTBUFFERT<br />		pushl	$Show<br />		call 	printf<br />		addl	$8, %esp <br />		ret<br /></code></pre><br /><br />But if I want to use puts instead of printf and include emptying the buffer after printing out, how should I do that?<br /><br />Anders</div>
    <div class="meta">Posted on 2011-10-09 14:30:57 by anders11</div>
   </div>
   <div class="post" id="post-215185">
    <div class="subject"><a href="#post-215185">Re: segmentation fault and ddd tool</a></div>
    <div class="body"><pre><code><br />outimage:	<br />		pushl	$UTBUFFERT<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call 	puts<br />		addl	$4, %esp <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movl $UTBUFFERT + $BUFFSIZ, %ecx<br />clearloop:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movb $0, (%ecx)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop clearloop<br />		ret<br /></code></pre><br />Something like that... if you insist on clearing the buffer. It isn&#039;t dark yet!<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2011-10-09 15:53:44 by fbkotler</div>
   </div>
   <div class="post" id="post-215186">
    <div class="subject"><a href="#post-215186">Re: segmentation fault and ddd tool</a></div>
    <div class="body">Well, I enjoyed the nice day, and then took a nice nap. I should have taken the nap before I posted the above! That isn&#039;t going to work at all. Sorry.<br /><pre><code><br />outimage:	<br />		pushl	$UTBUFFERT<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call 	puts<br />		addl	$4, %esp <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movl $BUFFSIZ, %ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movl $UTBUFFERT, edx<br />clearloop:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movb $0, (%edx)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; incl %edx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop clearloop<br />		ret<br /></code></pre><br />That&#039;s not tested either. It&#039;s closer, at least... I think.<br /><br />I made those &quot;small rearrangements&quot; to the code I posted earlier, so you can put more than one number on a line. Made a lot of mistakes - many segfaults! Maybe that nap should have been longer...<br /><br />What I did was to use fgets to get some user input into a buffer. I made it a subroutine I called &quot;getstring&quot; - would have been simpler to do it inline, we&#039;re only doing it once!<br /><br />Then I parsed this buffer to get up to five numbers into it, and store them in an array. I pass this subroutine the address of the buffer, the address of the array, and the address of a place to put the number of numbers found. Probably should have passed in the maximum number of numbers to get, rather than hard-coding it to 5. Actually I think I forgot to make it stop at 5 - this thing needs more work! Anyway, I ASSume that the first thing in the buffer is a number, and send it off to &quot;atoi&quot; to convert characters to the number that they represent. Here&#039;s my &quot;atoi&quot;:<br /><pre><code><br />atoi:	<br />		pushl	%ebp<br />		movl	%esp, %ebp<br />		pushl	%ebx<br />		movl	8(%ebp), %edx<br /><br />		xorl	%eax, %eax # zero result<br />		xorl	%ebx, %ebx # and sign indicator<br />		cmpb	$&#039;-&#039;, (%edx)<br />		jnz	getintloop<br />		incl	%edx # skip the &#039;-&#039;<br />		incl	%ebx # and set the &quot;sign indicator&quot;<br />getintloop:<br />		movsx	(%edx), %ecx # get a character<br />		incl	%edx # and get ready for next one<br /># make sure we have a valid character<br />		cmpb	$&#039;0&#039;, %cl<br />		jl	invalid<br />		cmpb	$&#039;9&#039;, %cl<br />		ja	invalid<br /># multiply result by ten, subtract &#039;0&#039; from character, and add it<br />		leal	(%eax, %eax, 4), %eax<br />		leal	-0x30(%ecx, %eax, 2), %eax<br /><br />		jmp	getintloop<br />invalid:<br />		testl	%ebx, %ebx<br />		jz	ispositive<br />		negl	%eax<br />ispositive:<br />		popl	%ebx<br />		movl	%ebp, %esp<br />		popl	%ebp<br />		ret<br /></code></pre><br /><br />As you know(?), C requires that certain registers be preserved, but %ecx and %edx can be &quot;trashed&quot;... so we do. But they&#039;re not really &quot;trashed&quot;, we happen to know that %edx is the next position in the buffer after the invalid character was found, and %ecx - well, just %cl, actually - holds the invalid character that caused atoi to quit. I make use of these facts in &quot;get5numbers&quot; to keep track of the &quot;position&quot; in the buffer, and whether there&#039;s another number, or if we&#039;re done...<br /><br />If you&#039;re &quot;not supposed to know&quot; about &quot;leal&quot;, you could replace that part with a multiply of the &quot;result so for&quot; by ten, and convert the character to a number by subtracting &#039;0&#039;, and adding it to the &quot;result so far&quot;. That leal &quot;trick&quot; was shown to me by Herbert Kleebauer (output from a compiler, supposedly), and I think it&#039;s &quot;cute&quot; so I use it...<br /><br />Here&#039;s my &quot;get5numbers&quot;:<br /><pre><code><br />get5numbers:<br />		pushl	%ebp<br />		movl	%esp, %ebp<br />		pushl	%ebx<br />		pushl	%esi<br /><br />		movl	16(%ebp), %edx #buffer<br />		movl	12(%ebp), %ebx #array<br />		xorl	%esi, %esi # count of numbers<br />getnumloop:<br />		pushl	%edx<br />		call	atoi<br />		addl	$4, %esp<br />		movl	%eax, (%ebx)<br />		addl	$4, %ebx<br />		incl	%esi # count<br /># FIXME: stop if 5 here!<br />		cmpb	$10, %cl<br />		je	getnumdone<br />		cmpb	$&#039; &#039;, %cl<br />		je	getnumloop<br /><br />getnumdone:<br />		movl	8(%ebp), %ebx<br />		movl	%esi, (%ebx)<br /><br />		popl	%esi<br />		popl	%ebx<br />		movl	%ebp, %esp<br />		popl	%ebp<br />		ret<br /></code></pre><br /><br />That&#039;s not well commented (ask, if you need to), and not very &quot;robust&quot;. As long as the pesky user follows instructions, it&#039;s kinda okay, I guess...<br /><br />Anyway, then I call a routine to add&nbsp; up however many numbers we claim to have found, and store the result in &quot;sum&quot;.<br /><br />Then I &quot;build&quot; a string to print - using the same buffer (we&#039;re done with it), converting each number in the buffer back to text, putting a &quot; + &quot; after it (except for the last one - put &quot; = &quot; there), convert the sum, ... and don&#039;t forget to zero-terminate the string! Then print it with &quot;puts&quot;. I modified the ending to end with &quot;ret&quot; instead of calling &quot;exit&quot; - just to &quot;prove&quot; I hadn&#039;t butchered the stack. :)<br /><br />You DO need to keep track of your &quot;position&quot; in the buffer, of course, but you&#039;ve got it in a register, and shouldn&#039;t need to keep track of it in a separate variable. If you want to do that, try updating the variable(s) &quot;inline&quot;, instead of jumping around to do it. Not worth a subroutine (IMO), and I think that&#039;s where you&#039;re crashing...<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2011-10-10 06:52:01 by fbkotler</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=30672&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=30672&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="30672" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=30672&amp;page=2">&gt;</a><a href="../?id=30672&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>