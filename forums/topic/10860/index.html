<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Some 3D snippets plus LL updated - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=10860" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=10860">Some 3D snippets plus LL updated</a></p>
   <div class="post" id="post-81875">
    <div class="subject"><a href="#post-81875">Some 3D snippets plus LL updated</a></div>
    <div class="body">Here's some code snippets to get you thinking.<br />First, a structure defining a Camera you can move about in 3D space.<br />I have one of these in my Player structure, but you can do without it.<br />Then, a function to update the camera and view matrix over time.<br />Also attatched you will find an update to my LinkedList include.<br />The update addresses destroying linked 2D object hierarchies.<br /><pre><code><br />;---------------------------------------------------------------------------------------------------<br />CAMERA STRUCT<br />vPosition D3DXVECTOR3 &lt;&gt;        ;3D position of eye of the beholder &#40;where I'm at&#41;<br />vVelocity D3DXVECTOR3 &lt;&gt;        ;3D motion velocity vector &#40;where I'm going&#41;<br />fYaw FLOAT ?                               ;current Yaw rotation &#40;left-right&#41;<br />fPitch FLOAT ?		                 ;fcurrent Pitch rotation &#40;up-down&#41;<br />fYawVelocity FLOAT ?                  ;rotation coefficients	<br />fPitchVelocity FLOAT ?	     ;for angular velocity	&#40;how fast I'm turning&#41;<br />matOrientation D3DXMATRIX &lt;&gt; ;holds the local Orientation Matrix<br />matView D3DXMATRIX &lt;&gt;           ;holds the local View Matrix<br />CAMERA ENDS<br />LPCAMERA typedef ptr CAMERA<br />;---------------------------------------------------------------------------------------------------<br /></code></pre><br />Now, here's some code that handles basic physics for the camera.<br />It doesn't do gravity.<br />It lets you rotate and move the camera smoothly with velocity and time.<br />It maintains an orientation matrix.<br />It create a viewmatrix.<br /><pre><code><br />UpdateCamera PROC fElapsed&#58;FLOAT,pCAMERA&#58;LPCAMERA<br />LOCAL fSpeed&#58;FLOAT			  ;  FLOAT fSpeed             = 3 * fElapsedTime<br />LOCAL fAngularSpeed&#58;FLOAT			  ;  FLOAT fAngularSpeed = 1 * fElapsedTime<br />LOCAL qR&#58;D3DXQUATERNION<br />.data<br />fp09 FLOAT 0.9f<br />fp0 FLOAT 0.0f<br />.code<br />    push esi<br />    fld fElapsed	 			  ;  calculate speed and angular speed<br />    fst fAngularSpeed<br />    fmul fp3<br />    fstp fSpeed<br /><br />;    // De-accelerate the camera movement &#40;for smooth motion&#41;<br />;   vVelocity=vVelocity*0.9<br />    mov esi,pCAMERA<br />    fld &#91;esi&#93;.CAMERA.vVelocity.x		;Slow down the XYZ velocity<br />    fmul fp09<br />    fstp &#91;esi&#93;.CAMERA.vVelocity.x<br />    fld &#91;esi&#93;.CAMERA.vVelocity.y<br />    fmul fp09<br />    fstp &#91;esi&#93;.CAMERA.vVelocity.y<br />    fld &#91;esi&#93;.CAMERA.vVelocity.z<br />    fmul fp09<br />    fstp &#91;esi&#93;.CAMERA.vVelocity.z<br />    fld &#91;esi&#93;.CAMERA.fYawVelocity		;slow down the rotational velocity<br />    fmul fp09<br />    fstp &#91;esi&#93;.CAMERA.fYawVelocity<br />    fld &#91;esi&#93;.CAMERA.fPitchVelocity<br />    fmul fp09<br />    fstp &#91;esi&#93;.CAMERA.fPitchVelocity<br /><br /><br />.data<br />vT D3DXVECTOR3 &lt;&gt;<br />.code<br /><br />;    Calculate the Position delta vector &#40;change of position&#41;<br />;    Note this does not take camera orientation into consideration, we do that in a moment...<br />;    D3DXVECTOR3 vT = m_vVelocity * fSpeed;<br /> <br />    fld &#91;esi&#93;.CAMERA.vVelocity.x<br />    fmul fSpeed<br />    fstp vT.x<br />    fld &#91;esi&#93;.CAMERA.vVelocity.y<br />    fmul fSpeed<br />    fstp vT.y<br />    fld &#91;esi&#93;.CAMERA.vVelocity.z<br />    fmul fSpeed<br />    fstp vT.z<br /><br />;   Rotate the Position delta vector to suit the current camera orientation<br />    invoke D3DXVec3TransformNormal, addr vT, addr vT, addr &#91;esi&#93;.CAMERA.matOrientation<br /><br />;   Add the oriented Position delta vector to the CAMERA Position vector<br />;   &#40;move the camera in the appropriate direction&#41;<br />;    vPosition += vT;<br />    fld vT.x<br />    fadd &#91;esi&#93;.CAMERA.vPos.x<br />    fstp &#91;esi&#93;.CAMERA.vPos.x<br />    fld vT.y<br />    fadd &#91;esi&#93;.CAMERA.vPos.y<br />    fstp &#91;esi&#93;.CAMERA.vPos.y<br />    fld vT.z<br />    fadd &#91;esi&#93;.CAMERA.vPos.z<br />    fstp &#91;esi&#93;.CAMERA.vPos.z<br /><br />;   Make sure that the camera can never go below Y=1 so it can't go underground<br />    mov eax,fp1<br />    .if   &#91;esi&#93;.CAMERA.vPos.y &lt; eax<br />         m2m &#91;esi&#93;.CAMERA.vPos.y, fp1<br />    .endif<br /><br />;    Update the yaw-pitch-rotation vector<br />     fld fAngularSpeed     ;    fYaw   += fAngularSpeed * fYawVelocity;<br />     fmul &#91;esi&#93;.CAMERA.fYawVelocity<br />     fadd &#91;esi&#93;.CAMERA.fYaw<br />     fstp &#91;esi&#93;.CAMERA.fYaw<br /><br />     fld fAngularSpeed	;    fPitch += fAngularSpeed * fPitchVelocity;<br />     fmul &#91;esi&#93;.CAMERA.fPitchVelocity<br />     fadd &#91;esi&#93;.CAMERA.fPitch<br />     fld fp0		;    if&#40; fPitch &lt; 0.0f &#41;      fPitch = 0.0f;<br />     fcomp   <br />     jge NoFix1<br />     fstp fptemp<br />     fld fp0<br />     jmp NoFix2<br />NoFix1&#58;			  if&#40; fPitch &gt; D3DX_PI/2 &#41; fPitch = D3DX_PI/2<br />     fld FPPIHALF <br />     fcomp<br />     jge NoFix2<br />     fstp fptemp<br />     fld FPPIHALF<br />NoFix2&#58;         <br />     fstp &#91;esi&#93;.CAMERA.fPitch<br /><br /><br />    invoke D3DXQuaternionRotationYawPitchRoll, addr qR, &#91;esi&#93;.CAMERA.fYaw, &#91;esi&#93;.CAMERA.fPitch, fp0<br />    invoke D3DXMatrixAffineTransformation, addr &#91;esi&#93;.CAMERA.matOrientation, fp1pt25, NULL, addr qR, addr &#91;esi&#93;.CAMERA.vPosition<br />    invoke D3DXMatrixInverse, addr &#91;esi&#93;.CAMERA.matView, NULL, addr &#91;esi&#93;.CAMERA.matOrientation<br />    pop esi<br />    ret<br />UpdateCamera ENDP</code></pre></div>
    <div class="meta">Posted on 2003-02-14 23:42:03 by Homer</div>
   </div>
  </div>
 </body>
</html>