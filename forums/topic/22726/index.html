<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>BSP - finding the Portals - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=22726" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=22726">BSP - finding the Portals</a></p>
   <div class="post" id="post-170222">
    <div class="subject"><a href="#post-170222">BSP - finding the Portals</a></div>
    <div class="body">Notes to myself (and anyone else who cares) regarding the process of extracting connectivity information (portals) from a Leafy BSPTree..<br /><br />So - we&#39;ve created a Leafy BSPTree, which contains convex clusters of Faces in its Leaves, and no Faces are in non-leaf nodes..<br /><br />Step 1: for each non-leaf node, create a large, rectangular polygon which rests on the node&#39;s splitting plane.. we&#39;ll call it a SuperPlane. I&#39;m going to use two Triangles for this, so I can take advantage of the existing and PROVEN triangle-splitting functionality we used to create the BSPTree.. <br /><br />Step 2: for each SuperPlane, cut the all the triangles it contains using &quot;the Planes from all OTHER nodes in the BSPTree&quot;. Each node now contains a list of &quot;potential portal faces&quot;. It&#39;s like a crazy rectangular pizza.<br /><br />Step 3: Push the &quot;potential faces&quot; down the BSPTree until they land in a Leaf.<br />IMPORTANT: if we ever find the Face is coplanar with a Plane, send a reference of it down BOTH sides. Note that this will happen ALWAYS at the node of origin,&nbsp; and in theory, should not happen ever again (unless we re-used an existing plane as a splittingplane, which would mean we made a mistake when we created our BSPTree)<br /><br />Step 4: each Leaf now contains a bunch of &quot;potential portal facereferences&quot; sourced from various parent nodes. <br />For each of these FaceRefs, search all OTHER LEAVES for a duplicate of that faceref.. if we find none, destroy the faceref, because we WANT to find two of them.<br />If we find two of them, note which two Leaves they appear in, and then find the Parent nodes of each of those Leaves... now cut the FaceRef against all the geometric Faces owned by the Parent Node&#39;s two leaves (&quot;against all faces in both leaves planes&quot;).. any fragments of the &quot;potential portals&quot; that lie BEHIND any of the leafpolygons are discarded.. coplanars are ignored.. any fragments that survive this process ARE PORTALS. Mark each set of surviving portal fragments with an Index or Pointer to the OTHER LEAF.. since we&#39;re really talking about two sides of a doorway leading between two Leafs.<br /><br />Can anyone help to optimize this algorithm?<br />I had one idea early on.. note that this algorithm totally ignores coplanar faces.<br />When we first create our rectangular polygon, we know that any Faces in that node&#39;s leaves which are coplanar with the cutting plane are WALLS (not a hole).<br />If we can come up with an algo to cut coplanar polygons, we can use these coplanar geometric faces to eliminate some of the &quot;potential portal faces&quot; BEFORE we shove them down into the Leaves..<br /><br />Wow, confused? Enlightened? Don&#39;t care?</div>
    <div class="meta">Posted on 2006-03-06 02:24:40 by Homer</div>
   </div>
   <div class="post" id="post-170257">
    <div class="subject"><a href="#post-170257">Re: BSP - finding the Portals</a></div>
    <div class="body">I started out by creating a new OA32 Object called (oddly enough) &quot;Portal&quot;.<br />The Portal object is a container for a DwordCollection of Triangle faces, and supports a VertexBuffer (implemented as a DataCollection of Vec3&#39;s).<br />I&#39;m keeping the Portal vertices separate from the main geometric vertexbuffer during the discovery of Portals, for two reasons.<br />#1 - I am expecting a LOT of vertices to be actually redundant (ie, to be created, and then later deleted again). <br />#2 - Portals are not textured, so the size (and thus the FVF) of these vertices differs from that of our geometric vertices.<br />After all the splitting I&#39;ll feed the surviving vertices into the main vertexbuffer and increase their size to match the FVF being used.<br /><br />So, now I have three new Objects which are unique to this project:<br />BSPTree (contains code to import geometry from xfile etc)<br />BSPNode (contains most of the tree generator code, as its recursive)<br />Portal (contains bugger all code, which might soon change)<br /><br />I&#39;ve added code to BSPNode such that after we&#39;ve finished sorting the input faces of a non-leaf BSPNode against its Plane, a Portal object is created and filled with two triangles comprising a large rectangle which lays on that Plane.<br />This occurs for every non-leaf Node during tree generation, ie, for all the BSPNodes that actually HAVE a splitting plane (leaves don&#39;t have one).<br />I stored each new Portal in a global Collection, and also locally in the BSPNode that shares its Plane.<br /><br />So, we&#39;ve got a bunch of &quot;large portals&quot; strewn throughout the BSPTree, and also kept in a linear list, and all that done DURING the tree generation.<br /><br />The next stage requires that the BSPTree is completed, because it involves splitting each of our &quot;large portals&quot; using &quot;every Plane except itself&quot; as the Cutting Plane (therefore we need to have decided on all our Planes).<br /><br />So, this is where I&#39;m currently up to.<br />I&#39;ve done everything above up to completing the tree generation : all the faces in convex clusters in the leaves of the tree, planes and large portals at all the other nodes.<br /><br />I&#39;ve been staring at the algorithm by Nathan Whitaker quite a lot, and something occurred to me, but I&#39;m going to have to describe his procedure to explain what I have in mind..<br /></div>
    <div class="meta">Posted on 2006-03-07 01:21:24 by Homer</div>
   </div>
   <div class="post" id="post-170259">
    <div class="subject"><a href="#post-170259">Re: BSP - finding the Portals</a></div>
    <div class="body"><br />Nathan says basically that we should mark each large portal with the splitplane it lies on (a pointer to the BSPNode makes more sense to me) and pass the large portals down the BSPTree until they reach a LeafNode.<br />He actually suggests we mark each PortalPolygon, but I was thinking to keep the Polygons together as coplanar sets (Portals).<br />I guess Nathan&#39;s idea is better than the alternative, which involves multiple Lists and is messy..<br />This means I&#39;ll have to change the way I&#39;ve designed my Portal object.<br /><br />Anyway, Nathan goes on to say that as we filter the Portal fragments down the BSPTree to the Leaves, if we ever find a fragment to be Coplanar with a CuttingPlane (which they ALL are, when they start out) then we should send &quot;a reference to that Polygon down BOTH sides of the tree&quot;, which is important, because after all the Portal fragments have been filtered down into the Leaves, we need to search for each Polygon&#39;s mate in all the other Leaves.<br />If we can find a PortalPoly reference in two different Leaves, then we&#39;ve discovered a Potential Portal, and if we CANNOT find it in two different leaves, then its NOT A PORTAL so kill it.<br />If we find a Potential Portal, we clip its geometry against all the faces in both of the Leaves in which it appears, and whatever remains is an Actual Portal.<br />Each leaf now needs to contain a Pointer to the the Actual Portal, which in turn contains Pointers to both of the Leaves it was found in.<br />So, an Actual Portal is a Portal (as I originally described it) with two more Pointers ;)<br /><br />Anyway, back to my brilliant idea.<br />It occurs to me that since we sent ALL the faces down into the Leaves when we originally made the Tree, that it is redundant to &quot;split each large portal against all Other Planes&quot;, we can ignore that step. Here&#39;s why.<br />If we just send the &quot;large portals&quot; down the Tree, once they get to the Leaves, they&#39;re going to be cut against the Planes of any Faces in those Leaves, and the Planes in the BSPNodes are just a SUBSET of the Planes of All Faces ;)<br />It occurs to me that the only Faces that a Portal needs to be cut with are those which bound the Leaf it exists in and those of the Faces in that Leaf.<br />Perhaps thats nonsense, anyone care to comment?<br /></div>
    <div class="meta">Posted on 2006-03-07 02:04:15 by Homer</div>
   </div>
   <div class="post" id="post-170269">
    <div class="subject"><a href="#post-170269">Re: BSP - finding the Portals</a></div>
    <div class="body">OK, let&#39;s describe the current problem.<br /><br />I have a Tree containing N nonleaf nodes, and each nonleaf node contains a Portal object... these Portal objects each contain two triangles at this point.<br />I need to cut each Portal&#39;s triangles up using N planes.<br />Now each nonleaf node contains a Portal which is a crazy rectangular pizza of N triangles.<br />In order to reduce complexity of the program, I extend my Face structure to include a Tag identifying what BSPNode (and thus what Plane) it originated from.<br />I use these ExtendedFaces to describe PortalPolygons.<br />Back to the Pizza..<br />I send each rectangular Pizza down the Tree, piece by piece, and catch all the pieces in the LeafNodes in a DwordCollection.<br />Now for each Leaf, I can discover the Portals by looking for leafs which contain matching pieces of pizza .. ie, the same triangle from the same plane.. ie, two REFS to the SAME TRIANGLE.<br />When I send my Triangles down the Tree, I can use the same method I did when I created the Tree, that is, to use FaceRefs stored in DwordCollections, and destroying the DwordCollection behind me (without destroying the payload objects) and I&#39;m PRETTY sure I&#39;m making no sense to anyone but myself at this point... after all, DwordCollections are not a standard OA32 object.<br />They&#39;re a Collection which doesn&#39;t destroy the object instances it carries.<br />More specifically, they&#39;re a collection of arbitrary dword values.<br />I find them useful for sorting purposes.<br />If I keep objects temporarily in these while sorting them from list to list, I can destroy redundant lists safely (container is destroyed, the contents are not), I just have to make sure I clean up the objects myself if it&#39;s time to die.<br /><br /></div>
    <div class="meta">Posted on 2006-03-07 06:22:27 by Homer</div>
   </div>
   <div class="post" id="post-170368">
    <div class="subject"><a href="#post-170368">Re: BSP - finding the Portals</a></div>
    <div class="body"><br />I&#39;ve completed the next stage of &quot;portal discovery&quot;...<br />Recapping the rather cryptic postings I made previously, I have done the following:<br />1) Import triangle soup from XFile<br />2) Build Leafy BSPTree (convex clusters of faces in Leaves, SplittingPlanes in all other Nodes), and while doing so, calculate the Bounds of the input geometry for each Node.<br />3) Create a large flat rectangle at each non-leaf node which rests on the node&#39;s SplittingPlane and extends to the Bounds of the node we precalculated. (I used two Triangles to describe the rectangle, so I could recycle some existing code in the next step)<br />4) Cut each &quot;large rectangle&quot; using &quot;all the other splitting planes&quot;. Mark each resulting &quot;fragment&quot; with the id of (or ptr to) the BSPNode it was constructed apon.<br /><br />That last step can take extremely long time, much longer than the time taken to build the entire BSPTree.. I&#39;m crying.. It makes the entire algorithm painfully slow to implement, and I can see that there is a way to speed this stage up, which I described at the end of the first posting I made in this thread.. we can eliminate a lot of Fragments early by performing some Clipping against any Faces which were found to be COPLANAR.<br /><br />The next stage which I haven&#39;t done yet:<br />5) Send all the Fragments down the Tree, and collect them in the LeafNodes.. if a Fragment is coplanar with any splitting plane, send it down BOTH sides.<br /><br />The last step is:<br />6) Search for instances of a Fragment which appear in two different Leaves. This is an ACTUAL PORTAL as opposed to a &quot;potential portal&quot;.<br />Whatever is not an actual portal, kill it.. we only want the real ones.<br />Mark each pair of real portals with &quot;a pointer to its mating leaf&quot;.<br /><br />That&#39;s all !!<br /></div>
    <div class="meta">Posted on 2006-03-10 00:00:09 by Homer</div>
   </div>
   <div class="post" id="post-170401">
    <div class="subject"><a href="#post-170401">Re: BSP - finding the Portals</a></div>
    <div class="body">I think I&#39;m applying the algo incorrectly.<br />Here&#39;s how I think I should be doing it:<br /><br />We&#39;ve created the large flat rectangles (our &#39;initialized Potential Portals&#39;) at each CuttingPlane (each non-leaf Node) of the BSPTree.<br />We should now &#39;frogmarch&#39; the Portal geometry down the Tree into the Leaves, cutting it against each cutting plane exactly as we did when we constructed the BSPTree.<br />Starting at the RootNode, we cut the largerectangle against the Plane, and we output the distributed triangles into the child nodes. Then we recurse each child, and thus the entire Tree.<br />Once this process is completed, all the PotentialPortal geometry is stored in the Leaves, ready to be clipped against the Faces in that Leaf.<br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2006-03-10 17:25:13 by Homer</div>
   </div>
   <div class="post" id="post-170405">
    <div class="subject"><a href="#post-170405">Re: BSP - finding the Portals</a></div>
    <div class="body">I&#39;ve implemented the algorithm as described in the previous post, and it works, and it&#39;s a crapload faster.<br />I had to change the way I handle the destruction of &quot;faces made redundant through splitting&quot; in order to implement &quot;the duplication of references to coplanar faces&quot;.. basically a face can&#39;t be destroyed until all Nodes have been processed, in case there&#39;s more than one Reference to it.<br /><br />I&#39;m ready for the final stage of Portal discovery - the search for Mating References in Other Leaves.<br />This will be very easy since in my implementation, a &#39;Mate&#39; face is simply a duplicate Pointer, I just have to compare a bunch of Pointers.<br /><br />To find the &quot;true portals&quot;, we do the following..<br /><br />For each LeafNode:<br />&nbsp; For each pFace in the Node&#39;s Portal object:<br />&nbsp; &nbsp; If the Face has NOT been marked as &quot;a true portal&quot;,<br />&nbsp; &nbsp; &nbsp; Search all Other Leaves for a copy of pFace<br />&nbsp; &nbsp; &nbsp; If Found, <br />&nbsp; &nbsp; &nbsp; &nbsp;  Mark each Face with a ptr to &quot;the other Leaf&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp;  Mark each Face as being &quot;a true portal&quot;<br />&nbsp; &nbsp; &nbsp; Else <br />&nbsp; &nbsp; &nbsp; &nbsp;  Destroy pFace<br />&nbsp; &nbsp; &nbsp; EndIf<br />&nbsp; &nbsp; EndIf<br /></div>
    <div class="meta">Posted on 2006-03-10 19:51:03 by Homer</div>
   </div>
   <div class="post" id="post-170416">
    <div class="subject"><a href="#post-170416">Re: BSP - finding the Portals</a></div>
    <div class="body">Well, today I implemented the function to &quot;find mating portal faces&quot; - and bugger me, it worked the first time - which is REALLY suprising because I FORGOT TO CLIP THE PORTALFACES TO THE FACES IN THE SAME LEAF.<br /><br />I guess I&#39;m not finding ALL the portals at the moment, but it is finding a whole bunch.<br /><br />Anyways, here&#39;s the function I threw together, and the structure being used for PortalFaces.<br />Note that I made a linear list of the LeafNodes during the building of the Tree, and now I&#39;m simply iterating each item in the list.<br />Remember, a real Portal face connects two Leaves.<br />Its geometry exists in both Leaves.<br />I decided to store a pair of ptrs in each PortalFace which indicate the two Leaves that the Portal is connecting...<br /><br /><pre><code><br /><br />PortalFace struct<br />	pVertex1	dd ?<br />	pVertex2	dd ?<br />	pVertex3	dd ?<br />	pOwnerNode	dd ? ;ptr to the BSPNode whose Plane the PortalFace was created apon<br />	pLeafA		dd ? ;ptr to LeafNode <br />	pLeafB		dd ? ;ptr to LeafNode<br />PortalFace ends<br /><br />Method BSPTree.FindActualPortals, uses esi<br />LOCAL numLeaves<br />LOCAL numFaces,numOtherFaces<br />LOCAL pLeafNode,pOtherLeafNode<br />LOCAL pFace,pFaces,pOtherFace,pOtherFaces<br /><br />	SetObject esi<br /><br />	;For each LeafNode:<br />	mov eax,pLeafNodes<br />	m2m numLeaves,.DwordCollection.dCount<br />	xor ecx,ecx<br />	.while ecx&lt;numLeaves<br />		push ecx<br />		;(Obtain ptr to LeafNode)<br />		mov pLeafNode,$OCall (pLeafNodes::DwordCollection.ItemAt,ecx)		<br />		;For each PortalFace in the Node&#39;s Portal Object:<br />		mov eax,.BSPNode.pPortals<br />		mov ebx,.Portal.pFaces<br />		mov pFaces,ebx<br />		m2m numFaces,.DwordCollection.dCount<br />		xor ecx,ecx<br />		.while ecx&lt;numFaces<br />			push ecx			<br />			;(Obtain ptr to PortalFace)<br />			mov pFace,$OCall (pFaces::DwordCollection.ItemAt,ecx)			<br />			;If this PortalFace has NOT been marked as a &quot;true portal&quot;<br />			;(we skip KNOWN portals)<br />			.if .PortalFace.pLeafA==NULL<br />				;Search &quot;all OTHER Leaves&quot; for this pointer..<br />				xor ecx,ecx<br />				.while ecx&lt;numLeaves<br />					push ecx					<br />					mov pOtherLeafNode,$OCall (pLeafNodes::DwordCollection.ItemAt,ecx)<br />					.if eax!=pLeafNode ;Don&#39;t search the Same Leaf<br />						mov eax,.BSPNode.pPortals<br />						mov ebx,.Portal.pFaces	<br />						mov pOtherFaces,ebx<br />						m2m numOtherFaces,.DwordCollection.dCount<br />						xor ecx,ecx<br />						.while ecx&lt;numOtherFaces<br />							push ecx<br />							OCall pOtherFaces::DwordCollection.ItemAt,ecx<br />							.if eax==pFace<br />								;We have a MATCH !!!								<br />								DbgWarning &quot;TRUE PORTAL FOUND&quot;<br />								;Mark the PortalFace with the ptrs<br />								;to the TWO leaves it connects<br />								m2m .PortalFace.pLeafA, pLeafNode<br />								m2m .PortalFace.pLeafB, pOtherLeafNode<br />								;Correct the Stack so we can exit early<br />								pop eax<br />								pop eax<br />								jmp @F<br />								<br />							.endif<br />							pop ecx<br />							inc ecx<br />						.endw<br />					.endif<br />					;Search Other Leaves <br />					pop ecx<br />					inc ecx<br />				.endw		<br />				;The search Failed, so pFace ain&#39;t a Portal<br />				OCall pFacesToKill::DwordCollection.Insert, pFace<br />			.endif	<br />@@:			;Check next Face in current Leaf<br />			pop ecx<br />			inc ecx<br />		.endw		<br />		;Check next Leaf<br />		pop ecx<br />		inc ecx<br />	.endw<br />	<br />MethodEnd<br /></code></pre><br /><br /><br /></div>
    <div class="meta">Posted on 2006-03-11 09:30:02 by Homer</div>
   </div>
   <div class="post" id="post-170424">
    <div class="subject"><a href="#post-170424">Re: BSP - finding the Portals</a></div>
    <div class="body">I have a suggestion that would speed up portal searching exponentially, err logarithmically.<br /><br />Instead of using a List why not a red/black linked tree or a sorted list.<br />By doing this your search time for each ptr to ptr comparison would be log(n) because you would be using a binary search instead of a brute force iterative one.<br /><br />Unless you have a red/black binary search tree implementation it would probably be easier to just run the list through a radix sort (4n) or a quicksort (n log(n)).</div>
    <div class="meta">Posted on 2006-03-11 21:30:52 by r22</div>
   </div>
   <div class="post" id="post-170427">
    <div class="subject"><a href="#post-170427">Re: BSP - finding the Portals</a></div>
    <div class="body">I dunno if theres ever enough leafnodes to warrant it, even when we&#39;re dealing with relatively large worlds.<br /><br />The geometry files I&#39;ve been using to test this baby are &#39;tiger.x&#39; and &#39;brokentiny.x&#39; which are roughly 600 and 8000 triangles respectively.<br />If anything needs to be optimized, its in the tree generator itself.<br />600 triangles are processed in about a minute on a 500mhz machine, and 8000 in about 5 minutes.. I&#39;m yet to throw anything more substantial at it.<br /><br />Still, I&#39;m listening, and appreciate the input.<br /><br />Let me complete the project by implementing the &quot;clipping to leaf faces&quot; which I omitted, and then I&#39;ll post the whole thing, and I will then invite you to tear it apart (philosophically speaking) in search of &#39;the most optimal implementation&#39;.<br /><br /></div>
    <div class="meta">Posted on 2006-03-11 23:55:16 by Homer</div>
   </div>
   <div class="post" id="post-178353">
    <div class="subject"><a href="#post-178353">Re: BSP - finding the Portals</a></div>
    <div class="body">Here&#39;s a beta copy of the Binary.<br /><br />Guys, please test this puppy and let me know your thoughts.<br />Rest assured that I intend to post the entire sourcecode, I just want to hear some feedback so I can make last-minute changes BEFORE I post it.<br />After that, I&#39;ll be looking at optimizing the existing codebase before implementing ANYTHING further (there&#39;s a lot of stuff I have in mind, such as a radiosity lightmap generator, and a CSG editor which performs boolean operations on objects encoded as BSPTrees).</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1446" target="_blank">3DEditor.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-03-14 03:20:14 by Homer</div>
   </div>
   <div class="post" id="post-178354">
    <div class="subject"><a href="#post-178354">Re: BSP - finding the Portals</a></div>
    <div class="body">Hi Homer<br />I get sereral times the error message &quot;Object ID = 23, Error Code = 201&quot; when I import Tiger.x ...<br /><br />Biterider</div>
    <div class="meta">Posted on 2006-03-14 03:55:05 by Biterider</div>
   </div>
   <div class="post" id="post-178355">
    <div class="subject"><a href="#post-178355">Re: BSP - finding the Portals</a></div>
    <div class="body">When you IMPORT? Can anyone verify this?<br /><br />Here&#39;s what I get when I import Tiger.x..<br /><br /><div class="quote"><br />XFile Loaded - Optimizing<br />XFile Optimized - Importing<br />Materials and textures Imported<br />Mesh Variables Noted<br />.dwFVF = 258t<br />.dwNumBytesPerVertex = 20t<br />.dwNumVertices = 303t<br />.dwNumFaces = 602t<br />eax = 1t, NumTexCoordSets in VertexFormat<br />eax = 1t, #TextureCoord Sets in each Vertex<br />Flexible Vertex Format Cracked<br />Calculated World Bounds<br />Vertices Imported<br />Faces Imported<br />yayyy<br /></div><br /><br />I&#39;ve made a number of changes to the Import function, however I don&#39;t get any such problems (iirc, 23 is Collection and 201 is &quot;index oob&quot; - generally the result of a failed Insert due to a Collection being initialized with insufficient slack space)<br /><br />I&#39;m really interested since this does not occur here.. ever.<br /></div>
    <div class="meta">Posted on 2006-03-14 04:18:40 by Homer</div>
   </div>
   <div class="post" id="post-178357">
    <div class="subject"><a href="#post-178357">Re: BSP - finding the Portals</a></div>
    <div class="body">That&#39;s the output of the 3DEDITOR window<br /><br /><pre><code>XFile Loaded - Optimizing<br />XFile Optimized - Importing<br />Materials and textures Imported<br />Mesh Variables Noted<br />.dwFVF = 258t<br />.dwNumBytesPerVertex = 20t<br />.dwNumVertices = 303t<br />.dwNumFaces = 602t<br />eax = 1t, NumTexCoordSets in VertexFormat<br />eax = 1t, #TextureCoord Sets in each Vertex<br />Flexible Vertex Format Cracked<br />Calculated World Bounds<br />Vertices Imported<br />Faces Imported<br />yayyy</code></pre><br /><br />If it gives you a hint, the error 201 occurs more than 200 times.<br /></div>
    <div class="meta">Posted on 2006-03-14 04:37:53 by Biterider</div>
   </div>
   <div class="post" id="post-178360">
    <div class="subject"><a href="#post-178360">Re: BSP - finding the Portals</a></div>
    <div class="body">I modified the zip posted earlier to include a MessageBox after impoting and before I populate a listview control. Please try this one.<br />The result will tell me where to look for this bug, which oddly, I can&#39;t seem to trigger on this machine.<br />Note that I&#39;ve got a fair bit of error checking already, it&#39;s got me interested..<br /></div>
    <div class="meta">Posted on 2006-03-14 06:45:22 by Homer</div>
   </div>
   <div class="post" id="post-178368">
    <div class="subject"><a href="#post-178368">Re: BSP - finding the Portals</a></div>
    <div class="body">AHAH !! Found the bug..<br /><br />The bug was caused by some code which &quot;walks the attributetable in parallel&quot; while processing the Faces in a linear loop.. this is required for importing Meshes with multiple Materials (or multiple Textures), so that each Face can be marked with the Material it uses (so that I can lump all the Faces together for BSP processing instead of dealing with N subsets).<br /><br />The bug caused the parallel walker to stray beyond the bounds of the attributetable into &quot;uninitialized memoryville&quot;, and subsequently was returning random junk for the current AttributeID .. which was then used as an Index into the Materials collection, which specifically caused the 201 error.<br /><br />Fixed :)<br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1468" target="_blank">3DEditor_Update2.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-03-14 09:52:17 by Homer</div>
   </div>
   <div class="post" id="post-178392">
    <div class="subject"><a href="#post-178392">Re: BSP - finding the Portals</a></div>
    <div class="body"><br />This bug had eluded me because of the arbitrary content of the memory being illegally accessed.. and because since I have not yet implemented any code to render, I had been disregarding the imported Materials.<br /><br />That being said, I&#39;m looking forward to some feedback.<br />Provided I don&#39;t hear any more horror stories, I&#39;ll post the source.<br /></div>
    <div class="meta">Posted on 2006-03-15 01:19:47 by Homer</div>
   </div>
   <div class="post" id="post-178398">
    <div class="subject"><a href="#post-178398">Re: BSP - finding the Portals</a></div>
    <div class="body">There were no errors when loading tiger.x<br /><pre><code><br />XFile Loaded - Optimizing<br />XFile Optimized - Importing<br />Mesh Variables Noted<br />.dwFVF = 258t<br />.dwNumBytesPerVertex = 20t<br />.dwNumVertices = 303t<br />.dwNumFaces = 602t<br />eax = 0t, Result of GetAttributeTable<br />.D3DXATTRIBUTERANGE.AttribId = 0t<br />.D3DXATTRIBUTERANGE.FaceStart = 0t<br />.D3DXATTRIBUTERANGE.FaceCount = 602t<br />.D3DXATTRIBUTERANGE.VertexStart = 0t<br />.D3DXATTRIBUTERANGE.VertexCount = 303t<br />Materials and textures Imported<br />eax = 1t, NumTexCoordSets in VertexFormat<br />eax = 1t, #TextureCoord Sets in each Vertex<br />Flexible Vertex Format Cracked<br />Calculated World Bounds<br />Vertices Imported<br />AttrID = 0t, Initial AttributeID<br />Faces Imported<br />yayyy<br /></code></pre><br /><br />On Manual Edit, only the Vertices table is filled. I tested 3DEditor.exe with ~50 textured .x files and several .x files without textures&nbsp; (files from an arbitrary 3D game). Half of the .x files were binary, the other - text. <br />Only one file failed to load, but it turned out its texture files were missing. </div>
    <div class="meta">Posted on 2006-03-15 12:48:01 by Ultrano</div>
   </div>
   <div class="post" id="post-178414">
    <div class="subject"><a href="#post-178414">Re: BSP - finding the Portals</a></div>
    <div class="body">Thanks for the feedback - yeah, I haven&#39;t finished the code for the component editor by a long shot, but I was interested to know if it shows the vertex format correctly for various FVFs (the number of columns should change depending on the FVF of the mesh).<br /><br />Also, do the values make sense (are Normals always between 0.0 and 1.0, are the UVs ever negatively signed (flipped)) ?<br /><br />Does the BSPGenerator appear to be working ok? Are &quot;Actual Portals&quot; being discovered at the end of the BSP processing? (the funky colours are just an indicator of what the program is doing)<br /><br />Finally, do the vertices created during the BSPGen processing have sane values? (refresh the listview by changing the component type, it will be rebuilt - I might change this..)<br /><br />One thing for sure, it leaks like a sieve if you load more than once per execution.. not all resources are deallocated correctly. I&#39;ll do that next.<br />I&#39;ve been preoccupied with getting the BSP stuff finished because I intend to use it as the basis of a realtime CSG editor (solid modeller)..<br />The idea is to define a handful of &quot;brushes&quot; (convex primitives), build a BSPTree for each, and then allow the user to combine multiple brushes using boolean operators (add, subtract, intersect), creating more complex brushes, with their complete 3d model as the most complex brush.<br />Note this indirectly allows a careful user of such an editor the ability to define the cuttingplanes of their BSP solid-modelled complex object (heh) because they are really building a revised BSPTree with each operation they perform..<br /></div>
    <div class="meta">Posted on 2006-03-16 00:43:18 by Homer</div>
   </div>
   <div class="post" id="post-178434">
    <div class="subject"><a href="#post-178434">Re: BSP - finding the Portals</a></div>
    <div class="body">3DEditor (the 2nd update) always exits when I press &quot;Generate BSP&quot; (that&#39;s why I thought it wasn&#39;t implemented). Before exiting, it displays &quot;Generating BSPTree&quot; in the main dbg window, and then &quot;WEIRDNESS : NOTHING TO SORT&quot; in BSPNode.Sort. The same stuff happens with tiger.x. <br />Most files don&#39;t have normals specified. Wherever they&#39;re present, they&#39;re ok: for instance (-1,0,0), (1,0,0),(-0.49,-0.74,-0.44),(0,-0.97,0.2)<br /><br />UVs are regular - from 0.0 to 1.0 . </div>
    <div class="meta">Posted on 2006-03-17 04:50:51 by Ultrano</div>
   </div>
  </div>
 </body>
</html>