<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>BHM File Format - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29830" />
  <link rel="prev" href="../?id=29830&amp;page=5" />  <link rel="next" href="../?id=29830&amp;page=7" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29830">BHM File Format</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29830&amp;page=1" style="">&laquo;</a><a href="../?id=29830&amp;page=5" style="">&lt;</a><input type="hidden" name="id" value="29830" /><input type="number" name="page" min="1" max="7" step="1" value="6" onchange="this.form.submit();" /><a href="../?id=29830&amp;page=7">&gt;</a><a href="../?id=29830&amp;page=7">&raquo;</a></form>   <div class="post" id="post-215805">
    <div class="subject"><a href="#post-215805">Re: BHM File Format</a></div>
    <div class="body">I have access to an actual Android phone now, a Samsung Galaxy S Plus.<br />First thing I did was to debug the texturing.<br />If you have an Android phone with OpenGL ES 1.0, try this:<br />http://bohemiq.scali.eu.org/OpenGLES.apk<br /><br />On my phone it got about 45 fps (with CPU skinning, since there is no shader support in OpenGL ES 1.0).<br /><br />Then I took OpenGL ES 2.0 to task:<br />http://bohemiq.scali.eu.org/OpenGLES2.apk<br /><br />It runs entirely on shaders, and gets 60 fps on my phone.<br /><br />Here is a video of it: http://www.youtube.com/watch?v=zSphFf2j2zM</div>
    <div class="meta">Posted on 2012-02-26 14:45:17 by Scali</div>
   </div>
   <div class="post" id="post-215810">
    <div class="subject"><a href="#post-215810">Re: BHM File Format</a></div>
    <div class="body"><div class="quote"><br />Another thing I will be doing is to make a cleaner separation between GLUT and my own code. Since the iPhone doesn&#039;t have GLUT, I had to use an alternative framework there. By making clean entrypoints for the init() and renderFrame() functions, it will be much easier to adapt the code to run inside any OpenGL wrapper.<br />I may want to ditch GLUT anyway, since the real GLUT is old and abandoned, and the newer implementations I&#039;ve tried, weren&#039;t that great.<br />I was told to check out GLFW, so I might just give that a whirl. Would be a good test to see if it really works without GLUT.<br /><br />Another thing that the iPhone doesn&#039;t have is GLU. I only used the gluPerspective() function, but that was partly because of laziness. There should really be a proper function for that in the GLUX library. GLU and GLUT are just more pieces of legacy that should be stripped from my framework.<br /></div><br /><br />Following up on this...<br />For now, I have decided not to look into other rendering frameworks. I already had to write custom code for the iPhone and the Android to host my OpenGL engine.<br />And now I want to host the OpenGL engine inside a .NET application.<br /><br />Namely, we have been using an internal tool to visualize the BHM files in a tree, and inspect their contents. Since we mainly use it for storing 3d objects and scenes, we put in a window that could preview the 3d data. This way you could quickly inspect exported data from 3dsmax.<br /><br />Initially I wanted to release the BHM visualization tool without the 3d component as part of the open source project. But then we had the problem that we had to maintain two versions: one with the 3d renderer, and one without. After all, we don&#039;t want to release the 3d renderer as open source.<br />Then I figured I could make a single version which would try to load the engine component dynamically. If it can&#039;t find it, the window is not displayed.<br />From there, I figured I could also make an engine component based on the OpenGL engine, which is already open source anyway.<br /><br />So today I&#039;ve been working on making my own Windows-specific code for creating an OpenGL context and such, and I no longer need GLUT on Windows now.<br />I&#039;ve also made a minimal .NET wrapper, so now the OpenGL context can be created on any WinForms Control.<br />So... by the looks of it, the visualizer can be released complete with the 3d renderer soon. I just need to do a lot of code cleanup.<br /><br />I&#039;ll still be loading the engine component dynamically, so that I can test with both the OpenGL and D3D renderers. After all, the D3D renderer is the one we&#039;re using mostly.</div>
    <div class="meta">Posted on 2012-03-01 10:38:39 by Scali</div>
   </div>
   <div class="post" id="post-215812">
    <div class="subject"><a href="#post-215812">Re: BHM File Format</a></div>
    <div class="body">I&#039;m glad you decided to drop GLUT.<br />My recommendation for a windowing solution is to use SDL, since its already cross platform and the license is liberal, meaning one set of code will work everywhere.<br />Don&#039;t bother writing a specific platform solution where one already exists across many platforms!<br /></div>
    <div class="meta">Posted on 2012-03-02 04:21:16 by Homer</div>
   </div>
   <div class="post" id="post-215813">
    <div class="subject"><a href="#post-215813">Re: BHM File Format</a></div>
    <div class="body">Well... there are two problems with using third-party solutions.<br />The first is that most of them insist on hosting their own window and doing everything for you. Which is okay if you just want an app with one window, but that&#039;s not what I am looking for right now.<br /><br />The second is that I hate SDL with a vengeange. It seems SDL is the main reason why many emulators run like total crap on my Android phone. I can&#039;t even emulate a C64 at full speed without frameskip? I mean, really? On a 1.4 GHz phone?<br />My OpenGLES stuff runs at 60 fps, and UAE4Droid will easily do 50 fps with an emulated Amiga, so why would a C64 be so slow? Same with dosbox. It can barely get low-end 386 speeds, and you need to use frameskip. What on earth for?<br /><br />Likewise, I noticed quite significant differences in speed between the original GLUT, OpenGLUT and FreeGLUT. How can you make something this simple, that slow?<br /><br />So no, I&#039;ll just roll my own code, thank you.</div>
    <div class="meta">Posted on 2012-03-02 05:32:56 by Scali</div>
   </div>
   <div class="post" id="post-215814">
    <div class="subject"><a href="#post-215814">Re: BHM File Format</a></div>
    <div class="body">An interesting observation while rolling my own OpenGL initialization code:<br />Normally you are told that you always need to use the CS_OWNDC style for the window that you are attaching OpenGL to.<br />Now the problem is, in .NET this style does not exist.<br />At first I just ignored it, as I was not quite sure what the significance of that flag was anyway, regarding OpenGL, or whether or not .NET would set it by default anyway (after all, it&#039;s still using native windows underneath).<br />And I just happened to be developing on my laptop, which ran the code just fine on its Intel X3100 IGP.<br /><br />When I tested the code on my desktop, with an nVidia GeForce GTX460, the code failed.<br />That is, it initalized correctly, and the renderloop was running, but nothing was being drawn on my window.<br />So I tested the native code with CS_OWNDC, and then the OpenGL code would run as expected. So the problem is related to the DC somehow.<br /><br />At first I tried to manually set the CS_OWNDC style on the window class of the .NET window in native code. However, that did not seem to work either. If I tried GetDC() after that, it returned an invalid handle. So I decided to dive a little deeper into CS_OWNDC, and found this page:<br />http://blogs.msdn.com/b/oldnewthing/archive/2006/06/01/612970.aspx<br />(Great blog anyway, full of interesting Windows factoids, and I really like the author&#039;s style).<br /><br />So, apparently CS_OWNDC caches the DC for your window, and makes sure you always receive the same DC when you call GetDC(). It never destroys or reinitializes this DC, so the state becomes persistent, unlike with regular windows.<br /><br />And that explains what I have been seeing: As a nice programmer, I try to call GetDC() only when I need the DC, and do ReleaseDC() as soon as I&#039;m done.<br />Now the problem here is, I attach the OpenGL context to the DC, then I release it again. Now when I call GetDC() again with CS_OWNDC, I get the same DC, with the OpenGL context attached. So if I then want to call SwapBuffers(), it works fine.<br />If I don&#039;t have CS_OWNDC, I can get an entirely different DC, and SwapBuffers() won&#039;t do anything, because there is no OpenGL context attached to that particular DC.<br /><br />So, what to do when you can&#039;t set CS_OWNDC? Well, just hog the DC handle. I just do a GetDC() when I create and attach the OpenGL context, and I don&#039;t ReleaseDC() until the OpenGL context is discarded.<br />Effectively this is no different from CS_OWNDC, as the DC would persist in the DC cache anyway, as long as the window was alive.<br />However, what is different is that if you call GetDC() multiple times for the same window, you get different DCs everytime. As a result, the application behaves exactly like other &#039;normal&#039; windows, without persistent state, and you won&#039;t run into strange problems when you think you have two different DC&#039;s, but they are actually the same one. Also, CS_OWNDC can conflict with CS_CLASSDC, a problem that we do not have now. So I personally think that hogging the DC handle is a slightly nicer way than using the CS_OWNDC flag.<br /><br />It&#039;s just a tad strange that:<br />1) OpenGL on Windows promotes, even forces, such dirty use of DC&#039;s. The preferred usage of DCs on Windows in normal applications is to release a DC as soon as you&#039;re done.<br />Why does OpenGL want to attach itself to the DC in the first place? Direct3D is attached to the window handle instead, DC&#039;s are not used at all.<br />2) Apparently on some systems it will work if you don&#039;t use CS_OWNDC, yet GetDC() and ReleaseDC() everytime, while on others it doesn&#039;t.<br />I wonder why it works anyway... Does the driver do something clever under the bonnet, so that it attaches to the window anyway, rather than just the DC? Or does it somehow make the system return the same DC everytime (either through setting CS_OWNDC silently, or some other magic)?<br /><br />Update: I&#039;ve tested on a system with an ATi Radeon X1900XTX card as well, and it does the same thing as the Intel driver: it works even if you don&#039;t use CS_OWNDC and don&#039;t store the DC permanently. So it seems nVidia is the odd one out here...</div>
    <div class="meta">Posted on 2012-03-02 12:20:43 by Scali</div>
   </div>
   <div class="post" id="post-215815">
    <div class="subject"><a href="#post-215815">Re: BHM File Format</a></div>
    <div class="body"><div class="quote"><br />My recommendation for a windowing solution is to use SDL, since its already cross platform and the license is liberal, meaning one set of code will work everywhere.<br /></div><br /><br />If you want to abstract away different platforms and along with some OpenGL nuisances, <a target="_blank" href="http://www.sfml-dev.org/">SFML</a> is a decent approach.</div>
    <div class="meta">Posted on 2012-03-02 23:56:26 by SpooK</div>
   </div>
   <div class="post" id="post-215827">
    <div class="subject"><a href="#post-215827">Re: BHM File Format</a></div>
    <div class="body">Speaking of OpenGL nuisances...<br />I tested my code with the same multithreaded window framework that I used for D3D earlier, and I ran into an interesting issue:<br /><img src="http://bohemiq.scali.eu.org/OGLClaws.png" /><br /><br />The framerates are very uneven, and the animation is not smooth either. This was on a GeForce GTX460. So I figured I&#039;d also try it on some other machines, one with an ATi Radeon X1900XTX, and one with an AMD Radeon HD5770. Both ran more smoothly.<br />In D3D the GTX460 had no such problem, so I just reported it as a driver issue. I guess nVidia wants to prioritize OpenGL tasks... which works fine with a single task, but as Raymond Chen of The Old New Thing always says: What if TWO applications would do this?<br />Or in this case, just two or more threads from the same application.<br /><br />Anyway, here&#039;s the binaries if you want to test it (Win32, .NET 4.0):<br />http://bohemiq.scali.eu.org/OGLMT.zip</div>
    <div class="meta">Posted on 2012-03-07 10:19:10 by Scali</div>
   </div>
   <div class="post" id="post-215828">
    <div class="subject"><a href="#post-215828">Re: BHM File Format</a></div>
    <div class="body">Due to scheduling, using multiple threads to render a single frame is fraught with disaster and I would never recommend it. I would #1 recommend only EVER using one thread to perform rendering.<br />Now, I know you&#039;re thinking, what about background loaders and so on?<br />The render path can be controlled from other threads, this is not the same thing as PERFORMING rendering from multiple threads. <br />If you need to drive your visual object transforms from a thread other than the rendering thread, then you&#039;re going to need some way of synchronizing them other than a hard mutex, usually this will be based on time, and involve artificially lagging something.<br /><br />Even setting your thread priorities won&#039;t save you from being scheduled.<br /></div>
    <div class="meta">Posted on 2012-03-07 23:43:15 by Homer</div>
   </div>
   <div class="post" id="post-215832">
    <div class="subject"><a href="#post-215832">Re: BHM File Format</a></div>
    <div class="body"><div class="quote"><br />Due to scheduling, using multiple threads to render a single frame is fraught with disaster and I would never recommend it. I would #1 recommend only EVER using one thread to perform rendering.</div><br /><br />Firstly, did you even bother to look at the screenshot? It&#039;s not a single frame, it&#039;s 10 concurrent renderers. So your entire post does not apply. I am talking about completely different issues (as usual). I want to use multiple OpenGL/D3D windows from the same application, so that I can render to multiple GPUs and screens at the same time, and have additional accelerated windows inside the UI of the application. There is no rendering from different threads than the rendering thread, there are just multiple rendering threads. Which works fine in general, except that on nVidia there seems to be a driver glitch when using OpenGL (but not D3D).<br /><br />Secondly, since D3D and especially OpenGL are connected to the window and thread they are created with, it is generally not even possible to use the same context from different threads (although D3D11 allows you to create additional contexts with limited functionality which you can use to prepare commands, which can later be executed by the main context in the main thread).<br />It&#039;s only logical, since the context is connected to one GPU (and SLI/CrossFire is also one GPU as far as the application is concerned, multiple GPUs are virtualized into a single one for the application), and you need to send commands in a strict order.</div>
    <div class="meta">Posted on 2012-03-08 03:24:27 by Scali</div>
   </div>
   <div class="post" id="post-215836">
    <div class="subject"><a href="#post-215836">Re: BHM File Format</a></div>
    <div class="body">OpenGL also allows you to create multiple contexts, and to share resources across contexts, I&#039;m not saying it can&#039;t be done, I&#039;m saying one thread per context means no artificial stalling due to mutexing.<br /><br />But I see you&#039;re already doing that, and the only reason that your windows are not rendering at the same rate is because the OS thread scheduler is not democratic, it performs poorly in terms of load balancing.<br /><br />So I think my comments were in line.<br /><br /></div>
    <div class="meta">Posted on 2012-03-08 21:09:11 by Homer</div>
   </div>
   <div class="post" id="post-215837">
    <div class="subject"><a href="#post-215837">Re: BHM File Format</a></div>
    <div class="body"><div class="quote"><br />But I see you&#039;re already doing that, and the only reason that your windows are not rendering at the same rate is because the OS thread scheduler is not democratic, it performs poorly in terms of load balancing.</div><br /><br />Incorrect.<br />Because as I already said:<br />1) When using Direct3D on the same videocard, there is no issue with load balancing:<br /><img src="http://bohemiq.scali.eu.org/D3DClaws.png" /><br />I have also done tests with just rendering the windows with a framecounter in the title bar, and no D3D or OpenGL rendering at all. The OS scheduler is not the problem.<br /><br />2) I have tested on two other systems, which did not show the problem either. Even though they are slower systems, and the framerates were lower on average, the animation remained smooth because the load remained balanced properly.<br /><br /><div class="quote"><br />So I think my comments were in line.<br /></div><br /><br />I don&#039;t. You were talking about, and I quote: &quot;using multiple threads to render a single frame&quot;.<br />Which is the opposite of my situation: &quot;Rendering multiple frames, with one thread each&quot;.<br />The rest of your post was just Captain Obvious on multithreading. I&#039;m not sure with what intent you posted it, but if you think I didn&#039;t already know about that, you&#039;re sorely mistaken.<br /><br />And this post again... If you bothered to READ my earlier post, you&#039;d know that I had already eliminated the OS scheduler as the root cause, because, and I quote:<br />&quot;This was on a <strong>GeForce GTX460</strong>. So I figured I&#039;d also try it on some <strong>other machines</strong>, one with an <strong>ATi Radeon X1900XTX</strong>, and one with an <strong>AMD Radeon HD5770</strong>. Both <strong>ran more smoothly</strong>.<br /><strong>In D3D</strong> the GTX460 had no such problem, so I just reported it as a driver issue.&quot;<br /><br />Next time, have the decency to READ a post before you reply.</div>
    <div class="meta">Posted on 2012-03-09 01:40:59 by Scali</div>
   </div>
   <div class="post" id="post-215843">
    <div class="subject"><a href="#post-215843">Re: BHM File Format</a></div>
    <div class="body">I am absolutely certain that windows directx would be doing a GetDC(windowhandle) under the hood, because its GOT to query for the rendering surface before it can write to it, opengl is just exposing this factoid.<br />I like that you bothered to re-post about the thread latency issue, blaming the drivers doesn&#039;t mean s***, they are chained, are they app level? running already and concurrent with the os (bet theres still balancer on it)? etc surely u took some time to qualify ur results and didnt merely observe ?<br /></div>
    <div class="meta">Posted on 2012-03-09 05:31:52 by Homer</div>
   </div>
   <div class="post" id="post-215845">
    <div class="subject"><a href="#post-215845">Re: BHM File Format</a></div>
    <div class="body"><div class="quote"><br />I am absolutely certain that windows directx would be doing a GetDC(windowhandle) under the hood, because its GOT to query for the rendering surface before it can write to it, opengl is just exposing this factoid.</div><br /><br />No it doesn&#039;t.<br />A DC is just a GDI-specific object.<br />DirectX is implemented at the same level as GDI:<br />http://msdn.microsoft.com/en-us/library/windows/desktop/ff729480(v=vs.85).aspx<br />In fact, since Vista, GDI is actually running on top of Direct3D, at least, when using Aero.<br />So there is no reason why you would need a DC object whatsoever for Direct3D. ANd likewise you would not need one for OpenGL either in theory.<br />As I said, the DC thing is probably a legacy thing. OpenGL has been around on Windows NT longer than Direct3D has, and was originally a software-only implementation. In that light, its ties with GDI are more logical.<br /><br /><div class="quote"><br />I like that you bothered to re-post about the thread latency issue, blaming the drivers doesn&#039;t mean s***, they are chained, are they app level? running already and concurrent with the os (bet theres still balancer on it)? etc surely u took some time to qualify ur results and didnt merely observe ?<br /></div><br /><br />Excuse me if I don&#039;t play along with your little charade.</div>
    <div class="meta">Posted on 2012-03-09 06:04:54 by Scali</div>
   </div>
   <div class="post" id="post-215847">
    <div class="subject"><a href="#post-215847">Re: BHM File Format</a></div>
    <div class="body">I perform a bunch of concurrent threaded operations in my framework, each has a spend limit and can bail out early if the limit is breached, subject to the minimum cap on framerate. OpenGL contexts are device contexts, the DC isnt deprecated, its a thing.</div>
    <div class="meta">Posted on 2012-03-09 06:21:52 by Homer</div>
   </div>
   <div class="post" id="post-215848">
    <div class="subject"><a href="#post-215848">Re: BHM File Format</a></div>
    <div class="body"><div class="quote"><br />OpenGL contexts are device contexts, the DC isnt deprecated, its a thing.<br /></div><br /><br />OpenGL contexts are OpenGL contexts, . They are *a* context, not *the* Device Context as defined by GDI and GetDC().<br />Which should be quite obvious, since GDI and GetDC() are Windows-specific, and OpenGL is not.<br />And even on Windows, the OpenGL context is NOT the DC (as pointed out, DCs are not persistent, unlike OpenGL). An OpenGL context is referred to by a HGLRC (handle to a GL rendering context) in Windows, not by a HDC.<br /><br />http://msdn.microsoft.com/en-us/library/dd374379(v=vs.85).aspx<br /><div class="quote">Remarks<br /> <br />A rendering context is not the same as a device context.</div></div>
    <div class="meta">Posted on 2012-03-09 06:27:18 by Scali</div>
   </div>
   <div class="post" id="post-215883">
    <div class="subject"><a href="#post-215883">Re: BHM File Format</a></div>
    <div class="body">Under opengl, its like Lua contexts - you create a master context, and register all resources there, and notify the system that you intend to share them to a set of child contexts. So the problems of multithreading (almost) go away.<br /></div>
    <div class="meta">Posted on 2012-03-13 01:19:36 by Homer</div>
   </div>
   <div class="post" id="post-215895">
    <div class="subject"><a href="#post-215895">Re: BHM File Format</a></div>
    <div class="body">nVidia just released a driver update: 296.10.<br />The starving issue is still there though.<br />nVidia has not responded to my bug report yet either.</div>
    <div class="meta">Posted on 2012-03-14 07:56:21 by Scali</div>
   </div>
   <div class="post" id="post-215936">
    <div class="subject"><a href="#post-215936">Re: BHM File Format</a></div>
    <div class="body">Just got a reply from nVidia. They confirmed the bug and said that the engineers already identified the problem in the driver. A fix will be made available in a future release. Cool!</div>
    <div class="meta">Posted on 2012-04-05 14:37:49 by Scali</div>
   </div>
   <div class="post" id="post-215995">
    <div class="subject"><a href="#post-215995">Re: BHM File Format</a></div>
    <div class="body">Just installed the new <a target="_blank" href="http://www.nvidia.co.uk/object/win7-winvista-64bit-301.42-whql-driver-uk.html">301.42 driver</a>.<br />And they fixed my bug! That was quick!<br /><img src="http://bohemiq.scali.eu.org/OGLClaws2.png" /></div>
    <div class="meta">Posted on 2012-05-24 02:20:50 by Scali</div>
   </div>
   <div class="post" id="post-215996">
    <div class="subject"><a href="#post-215996">Re: BHM File Format</a></div>
    <div class="body">very cool!</div>
    <div class="meta">Posted on 2012-05-25 04:16:10 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29830&amp;page=1" style="">&laquo;</a><a href="../?id=29830&amp;page=5" style="">&lt;</a><input type="hidden" name="id" value="29830" /><input type="number" name="page" min="1" max="7" step="1" value="6" onchange="this.form.submit();" /><a href="../?id=29830&amp;page=7">&gt;</a><a href="../?id=29830&amp;page=7">&raquo;</a></form>  </div>
 </body>
</html>