<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>BHM File Format - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29830" />
  <link rel="prev" href="../?id=29830&amp;page=4" />  <link rel="next" href="../?id=29830&amp;page=6" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29830">BHM File Format</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29830&amp;page=1" style="">&laquo;</a><a href="../?id=29830&amp;page=4" style="">&lt;</a><input type="hidden" name="id" value="29830" /><input type="number" name="page" min="1" max="7" step="1" value="5" onchange="this.form.submit();" /><a href="../?id=29830&amp;page=6">&gt;</a><a href="../?id=29830&amp;page=7">&raquo;</a></form>   <div class="post" id="post-214592">
    <div class="subject"><a href="#post-214592">Re: BHM File Format</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br />Seems to work.<br /></div><br /><br />Works on 10.7/Lion.<br /></div><br /><br />Nice.<br />I&#039;ve managed to get it to build in Xcode as well now. I believe that Xcode can actually build the .app for you automatically, but so far it can only successfully build the binary, and drops it in the build/Debug or build/Release dir.</div>
    <div class="meta">Posted on 2011-07-12 19:34:07 by Scali</div>
   </div>
   <div class="post" id="post-214593">
    <div class="subject"><a href="#post-214593">Re: BHM File Format</a></div>
    <div class="body"><div class="quote"><br />You can easily calc the frame time from fps, so it&#039;s no big deal really (Saw the fps-argument before, always thought it was nonsensical. Guess it&#039;s another internet hype. You&#039;re talking to a guy who&#039;s been doing gfx for over 20 years. You develop a natural feel for these things over time).<br />3000 fps: 1000/3000 = 0.33 ms per frame<br />5400 fps: 1000/5400 = 0.18 ms per frame<br />6000 fps: 1000/6000 = 0.16 ms per frame<br />10000 fps: 1000/10000 = 0.10 ms per frame<br /></div><br /><br />Yes you can calc, but it&#039;s 1/x, and yes when I see a number I too try and think of the other one.<br />I acknowledge that you&#039;re extremely skilled (not ironic here) (and not trying to compete in any way). But just because you have developed the ability to convert (and even feel the meaning) does not mean it&#039;s not a more relevant way of doing things.<br /><br />* You can add milliseconds. You cant add fps. *<br />(or substract)<br />Addition is more easily wired in the brain.<br />You more hardly &quot;see&quot; OS or app loop overhead in an fps number (or any kind of overhead in the render).<br />*** You cant say &quot;this optimisation won me x fps&quot;. You can say it won you x milliseconds. *** <br />(or this stack of effects will cost me x)<br />Papers describing effects and techniques now use milliseconds.<br /><br />Fps has its use in the 2-120 range cause it expresses motion smoothness. It&#039;s an important measure when you finished your app but I think during development maybe it&#039;s the other way around.<br />Besides I still think a scolling graph showing a few hundred last frametimes (oooor fps if you want :) ) would be a very superior indicator than an fps numeric counter that either refreshes a few times a second, or moves so fast you cant see what&#039;s going on.<br />I suspect big modern engines have quite maany aaaawful ugly spikes (or drops) on such a graph, but that&#039;s just me.<br /><br /><div class="quote"><br />In a way it&#039;s amazing to see just how fast a GPU has become these days. This scene has more polygons and more complex rendering than an entire Quake level. Yet the performance is determined more by the OS overhead than by the actual GPU rendering time.<br />But as I said, when you get into more &#039;realistic&#039; framerates, these differences won&#039;t matter much.<br />For example, if you want to run at 100 fps, your frame time is 1000/100 = 10 ms. A ~0.3 ms margin between the OSes is negligible... Say you get 10.3 ms frametime instead, that would be 97 fps instead. Not a big deal really.<br /></div><br /><br />Exactly. But you&#039;re in the 2-120 range.<br /><br />Anyway I&#039;m not saying it&#039;s a huge deal, but still better know it and use it.<br />Regards<br /></div>
    <div class="meta">Posted on 2011-07-12 19:52:08 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-214594">
    <div class="subject"><a href="#post-214594">Re: BHM File Format</a></div>
    <div class="body">I glanced at the thread. Of course you know what I mean. Didnt mean to hijack it with know-it-all offtopic things, hope thats ok.<br /><br />&#039;night.<br /></div>
    <div class="meta">Posted on 2011-07-12 20:16:36 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-214596">
    <div class="subject"><a href="#post-214596">Re: BHM File Format</a></div>
    <div class="body"><div class="quote"><br />But just because you have developed the ability to convert (and even feel the meaning) does not mean it&#039;s not a more relevant way of doing things.</div><br /><br />I never claimed otherwise.<br /><br /><div class="quote"><br />* You can add milliseconds. You cant add fps. *<br />(or substract)</div><br /><br />Which I didn&#039;t do.<br /><br /><div class="quote"><br />Fps has its use in the 2-120 range cause it expresses motion smoothness. It&#039;s an important measure when you finished your app but I think during development maybe it&#039;s the other way around.</div><br /><br />The fps counter is mainly there for that reason. It&#039;s an easy indication of how smoothly my app will be running.<br /><br /><div class="quote"><br />Besides I still think a scolling graph showing a few hundred last frametimes (oooor fps if you want :) ) would be a very superior indicator than an fps numeric counter that either refreshes a few times a second, or moves so fast you cant see what&#039;s going on.<br />I suspect big modern engines have quite maany aaaawful ugly spikes (or drops) on such a graph, but that&#039;s just me.</div><br /><br />I&#039;m not sure about that, to be honest.<br />I mean, if you have spikes, they are either annoying enough that you don&#039;t need some kind of graph to point them out... or they are too small to notice in practice.<br />In the former case, you probably already know why they&#039;re there, and how to solve them (if at all possible... eg if you have to load new content at runtime, you will always have some kind of spike).<br />In the latter case, who cares?<br /><br /><div class="quote"><br />Exactly. But you&#039;re in the 2-120 range.</div><br /><br />Why do you think I picked 100 fps?<br />Anything over 100-120 fps is pretty much irrelevant. In fact, these days, with crappy flat panels, most computers can&#039;t even go over 60 Hz anymore, so anything over 60 fps would be irrelevant.<br />I mean, it&#039;s nice as a measure of which OS has the least overhead in OpenGL, but other than that it&#039;s completely meaningless whether you get 3000 fps or 10000 fps.<br />Right now I&#039;m just aiming to make the framework as efficient as possible, then I will build on that.<br />When I&#039;m doing a complete scene with all effects enabled, I&#039;m only worried about getting smooth framerates. Not the highest possible framerates... as long as the framerate is over ~100, that means you can add more eyecandy. Eyecandy matters, not framerate.<br /><br /><div class="quote"><br />Anyway I&#039;m not saying it&#039;s a huge deal, but still better know it and use it.</div><br /><br />I disagree... I can only put one counter in my application (especially if I put it in the window title... but even in the console it&#039;d be harder to follow if a lot of numbers float by... and I can&#039;t really be arsed to put an entire separate window up with a graph etc... besides, that will have a considerable effect on performance). FPS is more &#039;intuitive&#039; to most people (pretty much all games use it too). Besides, I only care about whether my stuff can hit smooth framerates.</div>
    <div class="meta">Posted on 2011-07-13 03:20:01 by Scali</div>
   </div>
   <div class="post" id="post-214606">
    <div class="subject"><a href="#post-214606">Re: BHM File Format</a></div>
    <div class="body"><img src="http://img804.imageshack.us/img804/583/unledjax.jpg" /><br /><br />(like, you know, fraps)<br />(maybe an almost imperceptible overhead but well nothing is free)<br /><br />I did this years ago on the &quot;engine&quot; i did for mobile phones. I was proud of it! I think I even could see the periodical spikes of my occasional renormalisation square root. Or maybe it was the garbage collector waking up, who knows. I stand my ground :). Microstutters, you know. You don&#039;t always really notice but still it reduces the quality of animation.<br />Besides, for benchmarking purposes, when the engine crawls (or not), it&#039;s way more descriptive than average/min/max fps&nbsp; over a dozen of seconds.<br /></div>
    <div class="meta">Posted on 2011-07-13 18:56:10 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-214607">
    <div class="subject"><a href="#post-214607">Re: BHM File Format</a></div>
    <div class="body">Another concern I had is, are the milliseconds measured by software the real ones on the display?<br /><br />First we know that LCD panels buffer, delay and postprocess frames, which maybe could introduce jitter.<br /><br />Second, the graphic cards are more and more pipelined and desynchronised.<br />I read once that the video blit, even when it returns to the app, is now JUST A POINT IN A COMMAND BUFFER processed by the drivers or video hardware.<br />How precise is that stuff I ask?<br />Could aswell deliver bursts of 10 frames 10 times slower.<br /><br />I also heard SLI introduced microstutters with a period of 2 or maybe much more.<br /><br />So I thought of something great:<br />Like fraps, but instead of displaying an fps counter, you blink a little square black and white in sequence.<br />Then you put a a little device with a highspeed luminosity sensor on that part of the screen, and display a nice logging graph on a little lcd. I bet this would be awesome.<br /><br />Tell me if I should stop hijacking your thread.<br /></div>
    <div class="meta">Posted on 2011-07-13 19:18:42 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-214609">
    <div class="subject"><a href="#post-214609">Re: BHM File Format</a></div>
    <div class="body"><div class="quote"><br />First we know that LCD panels buffer, delay and postprocess frames, which maybe could introduce jitter.</div><br /><br />I think it&#039;s safe to assume that this delay is constant.<br /><br /><div class="quote"><br />Second, the graphic cards are more and more pipelined and desynchronised.<br />I read once that the video blit, even when it returns to the app, is now JUST A POINT IN A COMMAND BUFFER processed by the drivers or video hardware.<br />How precise is that stuff I ask?<br />Could aswell deliver bursts of 10 frames 10 times slower.</div><br /><br />Again, the delay should be pretty much constant. Effectively you may be measuring how quickly the buffer is emptied by the GPU, rather than how quickly it is filled, but that doesn&#039;t really matter that much.<br /><br /><div class="quote"><br />I also heard SLI introduced microstutters with a period of 2 or maybe much more.</div><br /><br />SLI and CrossFire just suck. But there&#039;s not much you can do about it as a programmer. It&#039;s all hardwired in the drivers, you have no control over it.<br /><br />I think what you are looking for is more of a profiler than any kind of frame counter. Something like VTune is more useful for that than any kind of timer you&#039;d write manually.</div>
    <div class="meta">Posted on 2011-07-14 01:40:54 by Scali</div>
   </div>
   <div class="post" id="post-214610">
    <div class="subject"><a href="#post-214610">Re: BHM File Format</a></div>
    <div class="body">I got rid of the CML dependency for GLUX now.</div>
    <div class="meta">Posted on 2011-07-14 05:26:45 by Scali</div>
   </div>
   <div class="post" id="post-214653">
    <div class="subject"><a href="#post-214653">Re: BHM File Format</a></div>
    <div class="body"><div class="quote"><br />I still have an old Celeron Northwood-based laptop with a Radeon IGP340M. I figured it&#039;d be a nice idea to try and run it there.</div><br /><br />Just did a test with the 0.1a release on this old laptop... I had merged the CPU fallback path into the BHM code before releasing, but never actually tested it.<br />I&#039;m happy to report that the CPU fallback path is still in place and working like a charm (including the full skinning animation, visually pretty much identical to the GLSL and ASM versions, although the lighting is per-vertex rather than per-pixel obviously). I even get 63 fps out of the old machine.<br />(if anyone has been paying attention to the README.txt, I&#039;ve also rewritten the required OpenGL functionality bit... This time it only requires multitexturing, anything else is optional... so basically it&#039;s OpenGL 1.2 spec I guess).<br /></div>
    <div class="meta">Posted on 2011-07-19 17:33:53 by Scali</div>
   </div>
   <div class="post" id="post-214961">
    <div class="subject"><a href="#post-214961">Re: BHM File Format</a></div>
    <div class="body">I&#039;ve had some fun with my OpenGL code...<br />Firstly I&#039;ve hacked GLUT so that I could force an OpenGL 3.0+ core profile, which disables any deprecated functionality.<br />Then I modified my code so that it works only with non-deprecated functionality.<br /><br />After doing that, the code was portable to OpenGL ES.<br />So I tried to port it to the iPhone, and here it is:<br /><img src="http://bohemiq.scali.eu.org/BHMiPhone.png" /></div>
    <div class="meta">Posted on 2011-09-07 04:43:21 by Scali</div>
   </div>
   <div class="post" id="post-214981">
    <div class="subject"><a href="#post-214981">Re: BHM File Format</a></div>
    <div class="body">I have come to a decision...<br />The current BHM3DSample is written with a lot of OpenGL legacy code. The advantage is that it can run on a wide variety of hardware. The disadvantage is that the code cannot run in an OpenGL ES environment, or with an OpenGL 3.0+ core profile.<br /><br />I have already cleaned out the legacy code for the OpenGL ES version on iPhone.<br />I will use this version for the next version of the BHM3DSample. I will give up backward compatibility, but the code will be smaller and cleaner than it is now.<br />The backward compatibility is not really an issue: the current code is already in the SVN, so people can still access it. It is also in the earlier release.<br />So I will just add a section to the readme file that points people to the older version, if they are having trouble running the current one on their system.<br /><br />Another thing I will be doing is to make a cleaner separation between GLUT and my own code. Since the iPhone doesn&#039;t have GLUT, I had to use an alternative framework there. By making clean entrypoints for the init() and renderFrame() functions, it will be much easier to adapt the code to run inside any OpenGL wrapper.<br />I may want to ditch GLUT anyway, since the real GLUT is old and abandoned, and the newer implementations I&#039;ve tried, weren&#039;t that great.<br />I was told to check out GLFW, so I might just give that a whirl. Would be a good test to see if it really works without GLUT.<br /><br />Another thing that the iPhone doesn&#039;t have is GLU. I only used the gluPerspective() function, but that was partly because of laziness. There should really be a proper function for that in the GLUX library. GLU and GLUT are just more pieces of legacy that should be stripped from my framework.</div>
    <div class="meta">Posted on 2011-09-10 16:53:43 by Scali</div>
   </div>
   <div class="post" id="post-214982">
    <div class="subject"><a href="#post-214982">Re: BHM File Format</a></div>
    <div class="body">Yes :)</div>
    <div class="meta">Posted on 2011-09-11 03:39:08 by Homer</div>
   </div>
   <div class="post" id="post-214985">
    <div class="subject"><a href="#post-214985">Re: BHM File Format</a></div>
    <div class="body">Code is now updated on sf.net.<br />If you are looking to replace some legacy GL math, you may want to look at some of the code here:<br />http://bhmfileformat.svn.sourceforge.net/viewvc/bhmfileformat/trunk/BHM3DSample/GL/GLUXMath.cpp?revision=52&amp;view=markup<br /><br />I have drop-in replacements for glFrustum(), gluLookAt() and gluPerspective(), as well as variations that resemble the D3DX-equivalents (for one, using radians instead of degrees... who ever uses degrees anyway? Also weird, from a computer engineering point-of-view: FPUs only work with radians (as do most programming languages)... using degrees means that you will need to transform into radians at some point, which is just useless extra overhead).<br /><br />Edit: To clarify the above &#039;backward compatibility&#039;. That only goes for things below OpenGL (ES) 2.0 spec. So it&#039;s still quite compatible. Basically as long as you have GLSL support, it should work.<br />It still works on my Intel X3100 IGP, which is exactly OpenGL 2.0.<br />It just won&#039;t work on hardware that only supports fixed function or assembly programs. The framework now forces you to use GLSL for everything, and unlike the old framework, mixing GLSL with legacy code is no longer guaranteed to work, and is not recommended.</div>
    <div class="meta">Posted on 2011-09-11 12:22:04 by Scali</div>
   </div>
   <div class="post" id="post-215081">
    <div class="subject"><a href="#post-215081">Re: BHM File Format</a></div>
    <div class="body">Had a quick look at GLFW... Doesn&#039;t seem to solve my main problem with classic GLUT: I cannot specify anything about the GL context it creates. This means I cannot force core 3.0+ profiles.<br />Some modern GLUT-ports do have that functionality. I had hacked it into the original GLUT source code, for the main reason that GLUT seems to perform much better than freeglut.</div>
    <div class="meta">Posted on 2011-09-23 17:08:38 by Scali</div>
   </div>
   <div class="post" id="post-215251">
    <div class="subject"><a href="#post-215251">Re: BHM File Format</a></div>
    <div class="body">I have my own version of GLEXT which I grow on demand.<br />It has little to no legacy junk.<br />And our framework allows you to request major and minor version :P<br />There&#039;s only two developers so we cater to ourselves, within reason.<br />So far, so good :)</div>
    <div class="meta">Posted on 2011-10-18 04:06:51 by Homer</div>
   </div>
   <div class="post" id="post-215255">
    <div class="subject"><a href="#post-215255">Re: BHM File Format</a></div>
    <div class="body">Yes, if you want something done right, you have to do it yourself :)<br />My problem is in the fact that I was aiming for platform-independent code.<br />GLUT is available on a wide variety of platforms, so people could easily recompile my code for their platform of choice.<br />If I make my own version, then I will have to maintain support for all platforms myself (or people will have to write their own port of it).<br /><br />So in that sense it&#039;s a bit of a shame that there doesn&#039;t seem to be a nice standard framework that already does what I want.<br />However, freeglut introduces some extensions that do what I want (just not entirely in the way that I would want it). So perhaps I could just check for the presence of these extensions, and use them if available. And I could adjust my hacked version of regular GLUT to be compatible with freeglut&#039;s API, but without freeglut&#039;s apparent performance issues (as mentioned earlier: http://www.asmcommunity.net/board/index.php?topic=29830.msg211342#msg211342).</div>
    <div class="meta">Posted on 2011-10-19 05:40:19 by Scali</div>
   </div>
   <div class="post" id="post-215260">
    <div class="subject"><a href="#post-215260">Re: BHM File Format</a></div>
    <div class="body">Sounds workable :)<br />I&#039;ve just implemented a scouring parser to snarf all the inputs to the VS against a runtime-extendable list of typedefs, rawkin it!<br />We&#039;re looking at the possibility of using Behavior Tree logic to drive the shader execution pathway! And stuff!</div>
    <div class="meta">Posted on 2011-10-21 09:51:19 by Homer</div>
   </div>
   <div class="post" id="post-215739">
    <div class="subject"><a href="#post-215739">Re: BHM File Format</a></div>
    <div class="body">The BHM3DSample is now also ported to Android:<br />http://scalibq.wordpress.com/2012/02/04/porting-bhm3dsample-to-android-some-well-a-lot-of-stressful-development/<br /><br /><img src="http://scalibq.files.wordpress.com/2012/02/androidbhm.png" /></div>
    <div class="meta">Posted on 2012-02-04 11:45:52 by Scali</div>
   </div>
   <div class="post" id="post-215754">
    <div class="subject"><a href="#post-215754">Re: BHM File Format</a></div>
    <div class="body">Good work! - what context? lol<br /></div>
    <div class="meta">Posted on 2012-02-08 23:26:53 by Homer</div>
   </div>
   <div class="post" id="post-215755">
    <div class="subject"><a href="#post-215755">Re: BHM File Format</a></div>
    <div class="body">Oh, I think the blog mentions that actually.. OpenGL ES 1.0, since the emulator does not support anything else.<br />But I get your point from the other thread.<br />And OpenGL ES is a lot better than regular OpenGL in that respect.<br />I&#039;ll have to port the OpenGL ES 2.0 code as well, but I&#039;d need access to an actual phone to test it.</div>
    <div class="meta">Posted on 2012-02-09 04:45:48 by Scali</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29830&amp;page=1" style="">&laquo;</a><a href="../?id=29830&amp;page=4" style="">&lt;</a><input type="hidden" name="id" value="29830" /><input type="number" name="page" min="1" max="7" step="1" value="5" onchange="this.form.submit();" /><a href="../?id=29830&amp;page=6">&gt;</a><a href="../?id=29830&amp;page=7">&raquo;</a></form>  </div>
 </body>
</html>