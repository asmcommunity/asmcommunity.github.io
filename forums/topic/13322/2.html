<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>prime numbers - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=13322" />
  <link rel="prev" href="../?id=13322&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=13322">prime numbers</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=13322&amp;page=1" style="">&laquo;</a><a href="../?id=13322&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="13322" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-104083">
    <div class="subject"><a href="#post-104083">primary numbers</a></div>
    <div class="body">Counting primes has already been done upto 4.10^22=2^75 !<br /><a target="_blank" href="http://numbers.computation.free.fr/Constants/Primes/Pix/pixproject.html">http://numbers.computation.free.fr/Constants/Primes/Pix/pixproject.html</a><br /><br />Also, a very fast Eratosthenes algorithm has been designed by Achim Flammenkamp.<br /><a target="_blank" href="http://wwwhomes.uni-bielefeld.de/achim/prime_sieve.html">http://wwwhomes.uni-bielefeld.de/achim/prime_sieve.html</a><br />His C code is able to count all primes upto 2^32 in 3.5 minutes on a P133 !<br /><br />If you really want to search for something new, try:<br /><a target="_blank" href="http://www.primepuzzles.net">http://www.primepuzzles.net</a><br />which proposes interesting weekly challenges to code about prime numbers.<br /><br />JC</div>
    <div class="meta">Posted on 2003-05-20 14:50:18 by MCoder</div>
   </div>
   <div class="post" id="post-104110">
    <div class="subject"><a href="#post-104110">primary numbers</a></div>
    <div class="body">hahaha, ha hahaha. took me 30 seconds to compute 3 to 8128129, took me combined(estimated) 3 weeks with modulo compare.<br /><br />btw 4,399,999,991 is prime<br />with this <br /><br /><a target="_blank" href="ftp://ftp.rsok.com/pub/source/sieve2310_64bit.c">ftp://ftp.rsok.com/pub/source/sieve2310_64bit.c</a><br /><br />looks like that algo in the .c can be approved apon. 1 to 4,399,999,991 is about 299mb, winzip compressed to 243mb</div>
    <div class="meta">Posted on 2003-05-20 18:51:31 by Qages</div>
   </div>
   <div class="post" id="post-104317">
    <div class="subject"><a href="#post-104317">primary numbers</a></div>
    <div class="body">bitRAKE, nice code.<br /><br />Can we get away from the Sieve based algos and head more toward the N^2 based ones?</div>
    <div class="meta">Posted on 2003-05-22 07:55:49 by Homer</div>
   </div>
   <div class="post" id="post-104325">
    <div class="subject"><a href="#post-104325">primary numbers</a></div>
    <div class="body"><strong>EvilHomer2k</strong>, sure, like what?</div>
    <div class="meta">Posted on 2003-05-22 08:40:09 by bitRAKE</div>
   </div>
   <div class="post" id="post-104326">
    <div class="subject"><a href="#post-104326">primary numbers</a></div>
    <div class="body">EvilHomer2k: if you need to check for primeness, try the chinese remainder algorithm to quickly detect if a number is composite (non-prime), instead of doing dumb divisions.<br />I think someone on this board is able to write a very efficient version of this algorithm.<br /><br />JC</div>
    <div class="meta">Posted on 2003-05-22 08:44:49 by MCoder</div>
   </div>
   <div class="post" id="post-104372">
    <div class="subject"><a href="#post-104372">primary numbers</a></div>
    <div class="body">I was able to quickly write an algo to test for possible Mersenne primes below N &lt; 2^31 using the algo above for primes. I have tested all prime N, (2^N - 1) for factoring by all prime numbers &lt; N.  Now I just need to reduce the list further.</div>
    <div class="meta">Posted on 2003-05-22 19:54:26 by bitRAKE</div>
   </div>
   <div class="post" id="post-104424">
    <div class="subject"><a href="#post-104424">primary numbers</a></div>
    <div class="body">Mersenne primes have already been exhaustively explored upto 2^7000000 !<br /><a target="_blank" href="http://www.mersenne.org">http://www.mersenne.org</a><br />Prime95 is a wonderful tool for factoring and finding such primes.<br />I spent some YEARS of factoring on this project before starting my own, but I'm still impressed by its ASM implementation (FFT, P-1, ECM, etc...).<br />I strongly encourage you to try to devote your time to other prime problems, since this subject has been already explored A LOT.<br />This is why I suggested  the <a target="_blank" href="www.primepuzzles.net">www.primepuzzles.net</a> page, which contains new problems, or records to break.<br /><br />Other interesting projects are ECMNET or NFSNET which try to factor numbers with more than 300 digits (!).<br /><br />About primality proving, chinese remainder theorem is a fast technique to determine if a number is composite. If the test finds 1, you have to use other techniques to check if the number is prime, and testing small divisors is the slowest of all possible techniques (even in ASM). If you don't believe me, try to factor a 50 digits number !<br /><br />JC</div>
    <div class="meta">Posted on 2003-05-23 02:42:16 by MCoder</div>
   </div>
   <div class="post" id="post-104467">
    <div class="subject"><a href="#post-104467">primary numbers</a></div>
    <div class="body"><strong>MCoder</strong>, thanks for the help.  I'm aware of Prime95 and I'm just exploring some of the research that has been done.  I have begun to explore up to 2^(2^31) -- just simple pruning of the possible primes.  I have no plans on trying to factor large numbers by simple division.</div>
    <div class="meta">Posted on 2003-05-23 08:34:35 by bitRAKE</div>
   </div>
   <div class="post" id="post-104727">
    <div class="subject"><a href="#post-104727">primary numbers</a></div>
    <div class="body">bitRake, I referred to the sieve of arosthenes (?) variant you posted in this thread - the 2^N stuff...<br />I was wondering if anyone had a go at the algo proposed by the Indian guy (no idea about the name) who proposed an effiecient probability-based way of calulating all the primes in a given RANGE, and provided a way of estimating the Time it would take.<br />There's some really neat ranged variants of the Sieve out there but I was hoping to get away from that line of thought entirely.</div>
    <div class="meta">Posted on 2003-05-25 11:20:44 by Homer</div>
   </div>
   <div class="post" id="post-104755">
    <div class="subject"><a href="#post-104755">primary numbers</a></div>
    <div class="body">I thought that the &quot;Indian guy&quot; found a way to test a number for primality with 100% accuracy. As I understand it, there is a method that is faster but sometimes (rarly) reports the wrong result.</div>
    <div class="meta">Posted on 2003-05-25 15:38:42 by gliptic</div>
   </div>
   <div class="post" id="post-106418">
    <div class="subject"><a href="#post-106418">primary numbers</a></div>
    <div class="body">@Gliptic,<br /><br />yes they algo is faster in theory but very very slow in practice, or in other words: today inpracticable. The problem with it is the fact that today nobody known how to work with large modular polynomials in a very fast manner. To remeber they method need an modular Polynom exponetation with polynoms as base. For larger numbers the count  of the needed coefficients of these polynoms are very big.<br />A good ECM, elliptic curve method, is magnitudes faster.<br /><br />The two question with finding primes are:<br />Want we to check only some numbers for primality, or<br />want we to compute and count all succesive primes.<br /><br />For the first case i have some stuff that checks number upto 2^32-1 in only about 1200 cylces.<br />The trick is we dont need to factorize such numbers or to use chineese remainders, because other nice peoples have counted all Strong Provable Primes upto certain bounds. So we have to check such numbers upto 2^32-1 only with a Strong Pseudo Prime Test (most called Rabin Miller Test) with fixed bases 2,7,61 if the Number is smaller as 4759123141. If these three combined test don't fail then it is fact that the tested number must be prime, because all numbers upto this bound have been tried today.<br /><br />For the second case upto 2^32-1 my 8/30 comp sieve implementation compute all 203.280.221 primes upto 2^32-1 in about 28 seconds on a P4 1.5GHz. On this computation we produce a binary file of 138Mb on disk that holds all these primes. This file can be used for random access to all these primes, in average 1-2 ms are needed for each number to test.<br /><br />Hagen</div>
    <div class="meta">Posted on 2003-06-08 18:38:21 by Hagen</div>
   </div>
   <div class="post" id="post-108688">
    <div class="subject"><a href="#post-108688">primary numbers</a></div>
    <div class="body">hm, i have written this for a contest, this program checks for a prime number and <br />prints out, if it is prime. If not, it shows you the divisor and the time needed for  the calculation...<br /><br />this algo is not very good, but on my 500Mhz K62 i need about 1 ms to check every number up to  2^32 (tested with a prime 2147483647)<br /><pre><code>TestIt proc hWnd&#58;DWORD<br />	<br />    invoke timeGetTime<br />	<br />	mov Time1,eax<br />	xor eax,eax<br />	xor ebx,ebx<br />	xor edx,edx<br />	xor ecx,ecx<br />	mov falsch,0<br />	<br />	;ALGO<br />	mov eax,DWORD ptr&#91;Zahl&#93;<br />	mov ecx,eax<br />	mov ebx,2<br />	div ebx<br />	test edx,1<br />	je KEINE_PRIMZAHL<br />	<br />    fninit<br />    fild Zahl<br />    fsqrt<br />    fistp Zahl ;fist akzeptiert nur 16,32 bit<br />    mov esi,DWORD ptr&#91;Zahl&#93;<br />    inc esi<br />    dec ebx<br />	_LOOP&#58;<br />	  mov eax,ecx<br />	  xor edx,edx	  <br />	  add ebx,2	;immer die ungeraden Zahlen nehmen<br />	  cmp ebx,esi ;sind wir schon bei der Wurzel?<br />	  jge WEITER ;wenn ja, dann ist schl?ss<br />	  div ebx ;ansonsten teilen<br />	  cmp edx,0 ;wenn kein Rest da ist != Primzahl<br />	  je KEINE_PRIMZAHL<br />	  jmp _LOOP	<br />	<br />	<br />	KEINE_PRIMZAHL&#58;<br />	  <br />	  mov falsch,1<br />	  jmp WEITER<br />	  <br />	;ALGOENDE <br />	<br />	<br />	<br />	<br />	<br />    WEITER&#58;<br />	invoke timeGetTime<br />	<br />	sub eax,Time1<br />	invoke wsprintf,offset Ausgabe_buffer,offset Ausgabe_template,eax<br />        invoke wsprintf,offset Ausgabe_buffer2,offset Teilbar_template,ebx<br />	<br />	ret<br />TestIt endp<br /></code></pre></div>
    <div class="meta">Posted on 2003-06-29 13:56:48 by CDW</div>
   </div>
   <div class="post" id="post-108751">
    <div class="subject"><a href="#post-108751">primary numbers</a></div>
    <div class="body"><pre><code><br />	mov eax,DWORD ptr&#91;Zahl&#93;<br />	mov ecx,eax<br />	mov ebx,2<br />	div ebx<br />	test edx,1<br />	je KEINE_PRIMZAHL<br /></code></pre><br /><br />Should be faster if you use<br /><pre><code><br />mov eax, dword ptr &#91;Zahl&#93;<br />mov ecx, eax<br />shr eax, 1<br />jnc KEINE_PRIMZAHL<br />sub ebx, ebx<br />inc ebx<br /></code></pre><br />Anyway no need to clear eax, ecx, edx and ebx at the start of the algo.<br /><br />Just my thoughts. ;)</div>
    <div class="meta">Posted on 2003-06-30 03:45:18 by roticv</div>
   </div>
   <div class="post" id="post-108912">
    <div class="subject"><a href="#post-108912">primary numbers</a></div>
    <div class="body"><pre><code><br /><br />function IsPrime&#40;N&#58; Cardinal&#41;&#58; Boolean; register;<br />// test if N is prime, do some small Strong Pseudo Prime test in certain bounds<br />// not PIC safe !!<br />asm<br />       TEST  EAX,1	      // Odd&#40;N&#41; ??<br />       JNZ   @@1<br />       CMP   EAX,2	      // N == 2 ??<br />       SETE  AL<br />       RET<br />@@1&#58;   CMP   EAX,73	      // N  &lt; 73 ??<br />       JB    @@C<br />       JE    @@E	      // N == 73 ??<br />       PUSH  ESI<br />       PUSH  EDI<br />       PUSH  EBX<br />       PUSH  EBP<br />       PUSH  EAX	      // save N as Param for @@5<br />       LEA   EBP,&#91;EAX - 1&#93;    // M == N -1, Exponent<br />       MOV   ECX,32	      // calc remaining Bits of M and shift M'<br />       MOV   ESI,EBP<br />@@2&#58;   DEC   ECX<br />       SHL   ESI,1<br />       JNC   @@2<br />       PUSH  ECX	      // save Bits as Param for @@5<br />       PUSH  ESI	      // save M' as Param for @@5<br />       CMP   EAX,08A8D7Fh     // N &gt;= 9080191 ??<br />       JAE   @@3<br />// now if &#40;N &lt; 9080191&#41; and SPP&#40;31, N&#41; and SPP&#40;73, N&#41; then N is prime<br />       MOV   EAX,31<br />       CALL  @@5	      // 31^&#40;&#40;N-1&#41;&#40;2^s&#41;&#41; mod N<br />       JC    @@4<br />       MOV   EAX,73	      // 73^&#40;&#40;N-1&#41;&#40;2^s&#41;&#41; mod N<br />       PUSH  OFFSET @@4<br />       JMP   @@5<br />// now if &#40;N &lt; 4759123141&#41; and SPP&#40;2, N&#41; and SPP&#40;7, N&#41; and SPP&#40;61, N&#41; then N is prime<br />@@3&#58;   MOV   EAX,2<br />       CALL  @@5<br />       JC    @@4<br />       MOV   EAX,7<br />       CALL  @@5<br />       JC    @@4<br />       MOV   EAX,61<br />       CALL  @@5<br />@@4&#58;   SETNC AL<br />       ADD   ESP,4 * 3<br />       POP   EBP<br />       POP   EBX<br />       POP   EDI<br />       POP   ESI<br />       RET<br />// do a Strong Pseudo Prime Test<br />@@5&#58;   MOV   EBX,&#91;ESP + 12&#93;   // N on stack<br />       MOV   ECX,&#91;ESP +  8&#93;   // remaining Bits<br />       MOV   ESI,&#91;ESP +  4&#93;   // M'<br />       MOV   EDI,EAX	      // T = b, temp. Base<br />@@6&#58;   DEC   ECX<br />       MUL   EAX<br />       DIV   EBX<br />       MOV   EAX,EDX<br />       SHL   ESI,1<br />       JNC   @@7<br />       MUL   EDI<br />       DIV   EBX<br />       AND   ESI,ESI<br />       MOV   EAX,EDX<br />@@7&#58;   JNZ   @@6<br />       CMP   EAX,1	      // b^&#40;&#40;N -1&#41;&#40;2^s&#41;&#41; mod N ==  1 mod N ??<br />       JE    @@A<br />@@8&#58;   CMP   EAX,EBP	      // b^&#40;&#40;N -1&#41;&#40;2^s&#41;&#41; mod N == -1 mod N ?? , EBP = N -1<br />       JE    @@A<br />       DEC   ECX	      // second part to 2^s<br />       JNG   @@9<br />       MUL   EAX<br />       DIV   EBX<br />       CMP   EDX,1<br />       MOV   EAX,EDX<br />       JNE   @@8<br />@@9&#58;   STC<br />@@A&#58;   RET<br />@@B&#58;   DB    3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71<br />@@C&#58;   MOV   EDX,OFFSET @@B<br />       MOV   ECX,18<br />@@D&#58;   CMP   AL,&#91;EDX + ECX&#93;<br />       JE    @@E<br />       DEC   ECX<br />       JNL   @@D<br />@@E&#58;   SETE  AL<br />end;<br /><br /><br /></code></pre><br /><br />Ok, is Delphi inlined assembler, but very fast. (extracted from my Delphi Encryption Compendium)<br /><br />Hagen</div>
    <div class="meta">Posted on 2003-07-01 12:22:52 by Hagen</div>
   </div>
   <div class="post" id="post-147426">
    <div class="subject"><a href="#post-147426">primary numbers</a></div>
    <div class="body"><div class="quote"><br />I was able to quickly write an algo to test for possible Mersenne primes below N &lt; 2^31 using the algo above for primes. I have tested all prime N, (2^N - 1) for factoring by all prime numbers &lt; N.  Now I just need to reduce the list further. </div><br /><br />Tell me more bitRAKE...<br /><br />I'm looking into the Mersenne thing now briefly myself.</div>
    <div class="meta">Posted on 2004-08-05 00:15:19 by V Coder</div>
   </div>
   <div class="post" id="post-147428">
    <div class="subject"><a href="#post-147428">primary numbers</a></div>
    <div class="body">bitRAKE, I've finally got back to this a year later. Now understanding the sieve routine...<br /><br />If you insert a checkpoint at __x, you will find that checking primes up to sqrroot of maxbits (perhaps the bulk of the work) is done in about 90% of the time. At that point you can save the table and close. The rest is just counting the number of set bits. No multiplications etc. needed again...<br /><br />PS... I guess an advanced bit counting routine, eg mmx will be faster, but since the counting is sooo much faster than the multiplies, etc... it is pointless to optimize the fastest part of the code...<br /><br /><br /><div class="quote"><br />All the prime up to 2^24 in 783ms!<br />1,077,870 primes (16,777,213 is prime) :)<br /><br />All primes up to 2^30 (over one billion!) in 86 seconds!!!<br />(Only 32 seconds on an XP2800+, Dual DDR.)<br />54,400,027 primes (<strong>1,073,741,789</strong> is prime) :)</div></div>
    <div class="meta">Posted on 2004-08-05 00:39:43 by V Coder</div>
   </div>
   <div class="post" id="post-147743">
    <div class="subject"><a href="#post-147743">primary numbers</a></div>
    <div class="body"><strong>V Coder</strong>, you are correct a population count would be faster - I was just coding in a hurry to confirm the results of the sieve.  With regard to Mersenne primes, I was just using the sieve along with other algorithms from <a target="_blank" href="http://www.mersenne.org/">http://www.mersenne.org/</a> to quickly reduce the number of test cases - although I haven't tested any very large numbers for primeness.</div>
    <div class="meta">Posted on 2004-08-09 11:16:41 by bitRAKE</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=13322&amp;page=1" style="">&laquo;</a><a href="../?id=13322&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="13322" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>