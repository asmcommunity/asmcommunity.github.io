<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Paged Memory Pool - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17154" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=17154">Paged Memory Pool</a></p>
   <div class="post" id="post-132999">
    <div class="subject"><a href="#post-132999">Paged Memory Pool</a></div>
    <div class="body">I found this in a book about WDM Driver programming: <br /><div class="quote"><br />Win32 executable files, including kernel-mode drivers, are internally composed of one or more <br />sections. A section can contain code or data and, generally speaking, has additional attributes <br />such as being readable, writable, sharable, executable, and so on. A section is also the smallest <br />unit that you can designate when you're specifying pagability. When loading a driver image, the <br />system puts sections whose literal names begin with &quot;page&quot; or &quot;.eda&quot; (the start of &quot;.edata&quot;) into <br />the paged pool <br /></div> <br />Questions:<br /><br />How can I make one section of my driver to be loaded in to the NONPAGED pool WITHOUT using<br />the <strong>MmLockPagableCodeSection</strong> and <strong>MmLockPagableDataSection</strong> functions?<br /><br />There are some section name that makes the Driver to be loaded in to the NONPAGED POOL?</div>
    <div class="meta">Posted on 2004-02-09 07:34:56 by Opcode</div>
   </div>
   <div class="post" id="post-133010">
    <div class="subject"><a href="#post-133010">Paged Memory Pool</a></div>
    <div class="body">Yes, these section names were listed in an obvious place. I don't remember the names, nor I'd like to download the DDK and install it, but there are such sections for sure. The place, where the driver is initiated, is always in a non-paged section</div>
    <div class="meta">Posted on 2004-02-09 11:37:09 by Ultrano</div>
   </div>
   <div class="post" id="post-133011">
    <div class="subject"><a href="#post-133011">Paged Memory Pool</a></div>
    <div class="body">hmm looking at an old project of mine, the section entering macros are<br />VxD_LOCKED_DATA_SEG<br />VxD_LOCKED_DATA_ENDS<br />VxD_LOCKED_CODE_SEG<br />VxD_LOCKED_CODE_ENDS<br />this is for '98</div>
    <div class="meta">Posted on 2004-02-09 11:40:25 by Ultrano</div>
   </div>
   <div class="post" id="post-133016">
    <div class="subject"><a href="#post-133016">Paged Memory Pool</a></div>
    <div class="body">Thanks for the effort, Ultrano, but the <strong>MmLockPagableCodeSection</strong><br />and <strong>MmLockPagableDataSection</strong> functions if from <strong>Windows NT/2k/XP DDK</strong>, <br />they don?t exist for VxD programming.</div>
    <div class="meta">Posted on 2004-02-09 12:07:13 by Opcode</div>
   </div>
   <div class="post" id="post-133033">
    <div class="subject"><a href="#post-133033">Paged Memory Pool</a></div>
    <div class="body">Hi<br /><br />Reading a little further along in that document (from Programming the MS Windows Driver Model), it looks like the code and data sections are in NON-PAGEABLE sections by default anyway.  It goes on to say if you want to override the default compiling you can set that with a #pragma statement (not sure how that would convert to a MASM statement):<br /><br /><em>The traditional way of telling the compiler to put code into a particular section is to use the alloc_text pragma. Since not every compiler will necessarily support the pragma, the DDK headers either define or don?t define the constant ALLOC_PRAGMA to tell you whether to use the pragma. You can then invoke the pragma to specify the section placement of individual subroutines in your driver, as follows:<br /><br />#ifdef ALLOC_PRAGMA<br />  #pragma alloc_text(PAGE, AddDevice)<br />  #pragma alloc_text(PAGE, DispatchPnp)<br />#endif<br /><br />These statements serve to place the AddDevice and DispatchPnp functions into the paged pool.<br /><br />To control the placement of data variables, you use a different pragma under the control of a different preprocessor macro symbol:<br /><br />#ifdef ALLOC_DATA_PRAGMA<br />  #pragma data_seg(&quot;PAGEDATA&quot;)<br />#endif<br />The data_seg pragma causes all static data variables declared in a source module after the appearance of the pragma to go into the paged pool.<br /><br />To revert to the default code section, just code #pragma code_seg with no argument:<br />#pragma code_seg()<br />Similarly, to revert to the regular nonpaged data section, code #pragma data_seg with no argument:<br />#pragma data_seg()</em><br /><br /><br />Now, in looking at the section characteristics of one of my drivers it appears the .text, .data, and .rdata sections all have the NON-PAGEABLE flag (08000000) set by default in MASM with no extra linking options.  I use the following:<br /><br />LINK /ENTRY:DriverEntry /driver /base:0x10000 /align:32 /subsystem:native /OUT:%drv1%.sys %drv%.obj /DEBUG /DEBUGTYPE:CV  <br /><br />The only section that compiles as PAGEABLE (except for .reloc) is the INIT section, which happens to be the IAT. Like other PE's, the Import table is initialized by the PE loader, and thereafter exist hardcoded as absolute addresses residing in the non-paged .rdata section. You can see all this with a PE editor and disassembly.  Interestingly, the .text and INIT sections are mapped as CODE, the rest as IDATA types.<br /><br />So it seems you don't have to specify NON-PAGEABLE in general, instead just the opposite.  One thing that would be nice to control though is being able to put your DriverEntry routine in the INIT section,<br /><br /><em>...you can also direct code into the INIT section if it?s not needed once your driver finishes initializing. For example:<br /><br />#pragma alloc_text(INIT, DriverEntry)<br />This statement forces the DriverEntry function into the INIT section. The system will release the memory it occupies when it returns. </em><br /><br />I'm not sure how one would declare that though since LINK.exe doesn't seem to support the /SECTION specifier with an INIT section.  Maybe someone has some further ideas in controlling the compile options for drivers.<br /><br />Kayaker</div>
    <div class="meta">Posted on 2004-02-09 18:24:21 by Kayaker</div>
   </div>
   <div class="post" id="post-133066">
    <div class="subject"><a href="#post-133066">Paged Memory Pool</a></div>
    <div class="body">Whole driver's image is nonpageable by default. You don't have to do any special for this. If you want to make some part of the driver to be discardable as needed use section names starting with &quot;PAGE&quot;. Initializing code can be placed into &quot;INIT&quot; section and also will be paged. Masm smart enough and you can use names right in .code directive for naming code sections like this:<br /><pre><code>.code INIT</code></pre>Unfortunatelly only .code directive supports this feature. For data sections use common SEGMENT directive.<br /><br /><pre><code>;@echo off<br />;goto make<br /><br />.386<br />.model flat, stdcall<br />option casemap&#58;none<br /><br />include \masm32\include\w2k\ntstatus.inc<br />include \masm32\include\w2k\ntddk.inc<br /><br />include \masm32\include\w2k\ntoskrnl.inc<br /><br />includelib \masm32\lib\w2k\ntoskrnl.lib<br /><br />;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58; PAGED DATA &#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;<br /><br />PAGEDAT1 SEGMENT<br />	PagedDword1 DWORD 0<br />PAGEDAT1 ENDS<br /><br />PAGEDAT2 SEGMENT<br />	PagedDword2 DWORD 0<br />PAGEDAT2 ENDS		<br />		<br />;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58; NONPAGED DATA &#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;<br /><br />.data<br />NonpagedDword DWORD 0<br /><br />;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58; NONPAGED CODE &#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;<br /><br />.code<br /><br />NonpageableProc proc<br />	mov eax, NonpagedDword<br />	ret<br />NonpageableProc endp<br /><br />;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58; PAGED CODE &#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;&#58;<br /><br />.code PAGED1<br /><br />PageableProc1 proc<br />	mov eax, PagedDword1<br />	ret<br />PageableProc1 endp<br /><br />.code PAGED2<br /><br />PageableProc2 proc<br />	mov eax, PagedDword2<br />	ret<br />PageableProc2 endp<br /><br />.code INIT<br /><br />DriverEntry proc pDriverObject&#58;PDRIVER_OBJECT, pusRegistryPath&#58;PUNICODE_STRING<br />	mov eax, STATUS_DEVICE_CONFIGURATION_ERROR<br />	ret<br />DriverEntry endp<br /><br />end DriverEntry<br /><br />&#58;make<br /><br />set drv=skeleton<br /><br />\masm32\bin\ml /nologo /c /coff %drv%.bat<br />\masm32\bin\link /nologo /driver /base&#58;0x10000 /out&#58;%drv%.sys /subsystem&#58;native /ignore&#58;4078 %drv%.obj<br /><br />del %drv%.obj<br /><br />echo.<br />pause</code></pre><br />PS: And don't use /align:32 linker option as I usually do while compiling drivers. If you do, multiple sections with different attributes will be placed into one memory page (4Kb). If only one very small section marked as nonpaged whole 4Kb will be nonpaged.</div>
    <div class="meta">Posted on 2004-02-10 04:04:18 by Four-F</div>
   </div>
   <div class="post" id="post-133069">
    <div class="subject"><a href="#post-133069">Paged Memory Pool</a></div>
    <div class="body">I had understood badly the text of Walter Oney.<br />I thought that name PAGE in the section would make with that it <br />was placed in PAGED POOL memory.<br /><br />Thanks again, Kayaker and Four-F ! :alright:  :alright:  :alright: <br />I wait to always be able to find its precious aids in this forum.</div>
    <div class="meta">Posted on 2004-02-10 05:02:05 by Opcode</div>
   </div>
  </div>
 </body>
</html>