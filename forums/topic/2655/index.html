<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>fade gfx... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=2655" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=2655">fade gfx...</a></p>
   <div class="post" id="post-16858">
    <div class="subject"><a href="#post-16858">fade gfx...</a></div>
    <div class="body">fade efect is (from my opinion) a great efect, but using GetPixel()and SetPixel() even in asm is very slow to generate it. I read some where in msdn or win32 help library, that we could use palettes to create fade efect, but palettes is a thing that i never used before, if some one knows how to use palettes to create a fade efect.... thanks in advance<br /><br />the best<br /><br />jean (coder7345)</div>
    <div class="meta">Posted on 2001-12-30 18:21:27 by coder</div>
   </div>
   <div class="post" id="post-16887">
    <div class="subject"><a href="#post-16887">fade gfx...</a></div>
    <div class="body"><div class="quote"><br />but using GetPixel()and SetPixel() even in asm is very slow to generate it.<br /></div><br /><br />I doubt you can get algorithms using get/setpixel much faster in<br />asm than in C. Not fast enough anyway. The trick is to use an<br />internal memory buffer and set these bytes to a bitmap... not trivial<br />stuff, but if you have platformsdk it's not too many hours to figure<br />out either. Unless you're using fullscreen DirectDraw, I would give<br />up the idea of using palettes.</div>
    <div class="meta">Posted on 2001-12-30 22:37:54 by f0dder</div>
   </div>
   <div class="post" id="post-16905">
    <div class="subject"><a href="#post-16905">fade gfx...</a></div>
    <div class="body">From the PSDK:<pre><code>void DrawAlphaBlend &#40;HWND hWnd, HDC hdcwnd&#41;<br />&#123;<br />    HDC hdc;               // handle of the DC we will create <br />    BLENDFUNCTION bf;      // structure for alpha blending<br />    HBITMAP hbitmap;       // bitmap handle<br />    BITMAPINFO bmi;        // bitmap header<br />    VOID *pvBits;          // pointer to DIB section<br />    ULONG   ulWindowWidth, ulWindowHeight;      // window width/height<br />    ULONG   ulBitmapWidth, ulBitmapHeight;      // bitmap width/height<br />    RECT    rt;            // used for getting window dimensions<br />    UINT32   x,y;          // stepping variables<br />    UCHAR ubAlpha;         // used for doing transparent gradient<br />    UCHAR ubRed;        <br />    UCHAR ubGreen;<br />    UCHAR ubBlue;<br />    float fAlphaFactor;    // used to do premultiply<br />            <br />    // get window dimensions<br />    GetClientRect&#40;hWnd, &amp;rt&#41;;<br />    <br />    // calculate window width/height<br />    ulWindowWidth = rt.right - rt.left;  <br />    ulWindowHeight = rt.bottom - rt.top;  <br /><br />    // make sure we have at least some window size<br />    if &#40;&#40;!ulWindowWidth&#41; || &#40;!ulWindowHeight&#41;&#41;<br />        return;<br /><br />    // divide the window into 3 horizontal areas<br />    ulWindowHeight = ulWindowHeight / 3;<br /><br />    // create a DC for our bitmap -- the source DC for AlphaBlend <br />    hdc = CreateCompatibleDC&#40;hdcwnd&#41;;<br />    <br />    // zero the memory for the bitmap info<br />    ZeroMemory&#40;&amp;bmi, sizeof&#40;BITMAPINFO&#41;&#41;;<br /><br />    // setup bitmap info <br />    // set the bitmap width and height to 60% of the width and height of each of the three horizontal areas. Later on, the blending will occur in the center of each of the three areas.<br />    bmi.bmiHeader.biSize = sizeof&#40;BITMAPINFOHEADER&#41;;<br />    bmi.bmiHeader.biWidth = ulBitmapWidth = ulWindowWidth - &#40;ulWindowWidth/5&#41;*2;<br />    bmi.bmiHeader.biHeight = ulBitmapHeight = ulWindowHeight - &#40;ulWindowHeight/5&#41;*2;<br />    bmi.bmiHeader.biPlanes = 1;<br />    bmi.bmiHeader.biBitCount = 32;         // four 8-bit components<br />    bmi.bmiHeader.biCompression = BI_RGB;<br />    bmi.bmiHeader.biSizeImage = ulBitmapWidth * ulBitmapHeight * 4;<br /><br />    // create our DIB section and select the bitmap into the dc<br />    hbitmap = CreateDIBSection&#40;hdc, &amp;bmi, DIB_RGB_COLORS, &amp;pvBits, NULL, 0x0&#41;;<br />    SelectObject&#40;hdc, hbitmap&#41;;<br /><br />    // in top window area, constant alpha = 50%, but no source alpha<br />    // the color format for each pixel is 0xaarrggbb <br />    // set all pixels to blue and set source alpha to zero<br />    for &#40;y = 0; y &lt; ulBitmapHeight; y++&#41;<br />        for &#40;x = 0; x &lt; ulBitmapWidth; x++&#41;<br />            &#40;&#40;UINT32 *&#41;pvBits&#41;&#91;x + y * ulBitmapWidth&#93; = 0x000000ff; <br /><br />    bf.BlendOp = AC_SRC_OVER;<br />    bf.BlendFlags = 0;<br />    bf.SourceConstantAlpha = 0x7f;  // half of 0xff = 50% transparency<br />    bf.AlphaFormat = 0;             // ignore source alpha channel<br /><br />    if &#40;!AlphaBlend&#40;hdcwnd, ulWindowWidth/5, ulWindowHeight/5, <br />                    ulBitmapWidth, ulBitmapHeight, <br />                    hdc, 0, 0, ulBitmapWidth, ulBitmapHeight, bf&#41;&#41;<br />        return;                     // alpha blend failed<br />    <br />    // in middle window area, constant alpha = 100% &#40;disabled&#41;, source <br />    // alpha is 0 in middle of bitmap and opaque in rest of bitmap <br />    for &#40;y = 0; y &lt; ulBitmapHeight; y++&#41;<br />        for &#40;x = 0; x &lt; ulBitmapWidth; x++&#41;<br />            if &#40;&#40;x &gt; &#40;int&#41;&#40;ulBitmapWidth/5&#41;&#41; &amp;&amp; &#40;x &lt; &#40;ulBitmapWidth-ulBitmapWidth/5&#41;&#41; &amp;&amp;<br />                &#40;y &gt; &#40;int&#41;&#40;ulBitmapHeight/5&#41;&#41; &amp;&amp; &#40;y &lt; &#40;ulBitmapHeight-ulBitmapHeight/5&#41;&#41;&#41;<br />                //in middle of bitmap&#58; source alpha = 0 &#40;transparent&#41;.<br />                // This means multiply each color component by 0x00.<br />                // Thus, after AlphaBlend, we have a, 0x00 * r, <br />                // 0x00 * g,and 0x00 * b &#40;which is 0x00000000&#41;<br />                // for now, set all pixels to red<br />                &#40;&#40;UINT32 *&#41;pvBits&#41;&#91;x + y * ulBitmapWidth&#93; = 0x00ff0000; <br />            else<br />                // in the rest of bitmap, source alpha = 0xff &#40;opaque&#41; <br />                // and set all pixels to blue <br />                &#40;&#40;UINT32 *&#41;pvBits&#41;&#91;x + y * ulBitmapWidth&#93; = 0xff0000ff; <br />            endif;<br />    <br />    bf.BlendOp = AC_SRC_OVER;<br />    bf.BlendFlags = 0;<br />    bf.AlphaFormat = AC_SRC_ALPHA;  // use source alpha <br />    bf.SourceConstantAlpha = 0xff;  // opaque &#40;disable constant alpha&#41;<br />   <br />    if &#40;!AlphaBlend&#40;hdcwnd, ulWindowWidth/5, ulWindowHeight/5+ulWindowHeight, ulBitmapWidth, ulBitmapHeight, hdc, 0, 0, ulBitmapWidth, ulBitmapHeight, bf&#41;&#41;<br />        return;<br /><br />    // bottom window area, use constant alpha = 75% and a changing<br />    // source alpha. Create a gradient effect using source alpha, and <br />    // then fade it even more with constant alpha<br />    ubRed = 0x00;<br />    ubGreen = 0x00;<br />    ubBlue = 0xff;<br />    <br />    for &#40;y = 0; y &lt; ulBitmapHeight; y++&#41;<br />        for &#40;x = 0; x &lt; ulBitmapWidth; x++&#41;<br />        &#123;<br />            // for a simple gradient, base the alpha value on the x <br />            // value of the pixel <br />            ubAlpha = &#40;UCHAR&#41;&#40;&#40;float&#41;x / &#40;float&#41;ulBitmapWidth * 255&#41;;<br />            //calculate the factor by which we multiply each component<br />            fAlphaFactor = &#40;float&#41;ubAlpha / &#40;float&#41;0xff; <br />            // multiply each pixel by fAlphaFactor, so each component <br />            // is less than or equal to the alpha value.<br />            &#40;&#40;UINT32 *&#41;pvBits&#41;&#91;x + y * ulBitmapWidth&#93; <br />                = &#40;ubAlpha &lt;&lt; 24&#41; |                       //0xaa000000<br />                 &#40;&#40;UCHAR&#41;&#40;ubRed * fAlphaFactor&#41; &lt;&lt; 16&#41; |  //0x00rr0000<br />                 &#40;&#40;UCHAR&#41;&#40;ubGreen * fAlphaFactor&#41; &lt;&lt; 8&#41; | //0x0000gg00<br />                 &#40;&#40;UCHAR&#41;&#40;ubBlue   * fAlphaFactor&#41;&#41;;      //0x000000bb<br />        &#125;<br />    bf.BlendOp = AC_SRC_OVER;<br />    bf.BlendFlags = 0;<br />    bf.AlphaFormat = AC_SRC_ALPHA;   // use source alpha <br />    bf.SourceConstantAlpha = 0xbf;   // use constant alpha, with <br />                                     // 75% opaqueness<br />    AlphaBlend&#40;hdcwnd, ulWindowWidth/5, <br />               ulWindowHeight/5+2*ulWindowHeight, ulBitmapWidth, <br />               ulBitmapHeight, hdc, 0, 0, ulBitmapWidth, <br />               ulBitmapHeight, bf&#41;;<br />    // do cleanup<br />    DeleteObject&#40;hbitmap&#41;;<br />    DeleteDC&#40;hdc&#41;;<br />&#125;</code></pre></div>
    <div class="meta">Posted on 2001-12-30 23:50:34 by bitRAKE</div>
   </div>
   <div class="post" id="post-16910">
    <div class="subject"><a href="#post-16910">fade gfx...</a></div>
    <div class="body"><a target="_blank" href="http://www.asmcommunity.net/board/showthread.php?s=&amp;postid=16909.msg16909">Just posted an MMX alpha blend algo HERE.</a></div>
    <div class="meta">Posted on 2001-12-31 00:33:29 by bitRAKE</div>
   </div>
  </div>
 </body>
</html>