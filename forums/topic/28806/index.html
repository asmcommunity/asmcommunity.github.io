<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>3n+1 Collatz Problem - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=28806" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=28806">3n+1 Collatz Problem</a></p>
   <div class="post" id="post-203546">
    <div class="subject"><a href="#post-203546">3n+1 Collatz Problem</a></div>
    <div class="body">ever heard of this? try to get some information on wikipedia...<br />it is an UNSOLVED mathematical problem..<br /><br />if an integer number is odd then it will proccessd by 3n+1<br />if an integer is not odd then it will be processed by n / 2<br />odd = n mod 2<br /><br />this will repeat until n reaches 1..<br />and then an infinity sequence of 4,2,1,4,2,1 will haappen..<br /><br />so what the... why is this described as an unsolved problem?<br />if n is of power of 2 it will always get divided by 2 and if its then 2 a 3*1+1 is happening.. and then its again 4 and the algo is stuck in 4,2,1.... <br /><br />why the hell is this an unsolved mathematical problem????<br /><br /><pre><code>main<br />&nbsp; &nbsp; call collatz 23<br /><br />func collatz(int n)<br />&nbsp; while n &gt; 1<br />&nbsp; &nbsp; show n<br />&nbsp; &nbsp; if n mod 2 = 0 Then<br />&nbsp; &nbsp; &nbsp; n = 3 * n + 1<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; &nbsp; &nbsp;n = n / 2<br />&nbsp; &nbsp; end if<br />&nbsp; wend<br />&nbsp; &nbsp; show n<br />end func</code></pre><br /><br />as you will see collatz 23 outputs:<br />70,35... .. ... 5 .. until it reaches 16 16 is power of 2.. and the thing described above will happen..<br />so it is totally sensless how big the numbers will rise.. if they are power of two then it will result in 4,2,1...<br /><br />don&#039;t blame me for posting this.. but am i a genius or all others be blind.. or i don&#039;t get the whole point...</div>
    <div class="meta">Posted on 2007-11-10 10:55:47 by Emod</div>
   </div>
   <div class="post" id="post-203549">
    <div class="subject"><a href="#post-203549">Re: 3n+1 Collatz Problem</a></div>
    <div class="body">What you&#039;ve shown isn&#039;t a mathematical proof, it requires running the program...<br /></div>
    <div class="meta">Posted on 2007-11-10 11:12:48 by f0dder</div>
   </div>
   <div class="post" id="post-203551">
    <div class="subject"><a href="#post-203551">Re: 3n+1 Collatz Problem</a></div>
    <div class="body">hmm that&#039;s a point.. guess I try to figure it out this evening :lol:</div>
    <div class="meta">Posted on 2007-11-10 11:18:18 by Emod</div>
   </div>
   <div class="post" id="post-203553">
    <div class="subject"><a href="#post-203553">Re: 3n+1 Collatz Problem</a></div>
    <div class="body">We are either geniuses, or fools, because I, too, can&#039;t see where is the problem.<br /><br />- multiplying by 3 and adding 1 will always produce an even number, thus enabling a division in next turn<br />- dividing by 2 will much more likelky produce an even number, thus enabling even further division. and this likeness is greater than 2:3<br /><br />so the number, in long run, must decrease.<br /><br />or am I missing something? o_O ?</div>
    <div class="meta">Posted on 2007-11-10 14:50:31 by ti_mo_n</div>
   </div>
   <div class="post" id="post-203556">
    <div class="subject"><a href="#post-203556">Re: 3n+1 Collatz Problem</a></div>
    <div class="body"><div class="quote"><br />- multiplying by 3 and adding 1 will always produce an even number, thus enabling a division in next turn</div><br /><br />3*1 + 1 =&#160; 4 Even<br />3*2 + 1 =&#160; 7 Odd<br />3*3 + 1 = 10 Even<br />3*4 + 1 = 13 Odd<br />3*5 + 1 = 16 Even<br /><br />:roll:<br /><br />And dividing by two perhaps statistically will produce an even number, but obviously there are Ns that are even numbers but dividing them by two produces an odd number (like n = 10).<br /><br />The remark about 3*n + 1 is not appliable to what ti_mo_n is refering to. Check his post below</div>
    <div class="meta">Posted on 2007-11-10 15:12:57 by LocoDelAssembly</div>
   </div>
   <div class="post" id="post-203557">
    <div class="subject"><a href="#post-203557">Re: 3n+1 Collatz Problem</a></div>
    <div class="body">you multiply by 3 and add 1 only if the number is odd (I was reffering to the &quot;problem&quot;, not to numbers in general ;) ). even numbers have to be divided by 2.<br /><br />about the second thing: even numbers end with 0, 2, 4, 6, 8. among them, (adequately large) numbers ending with 0, 4, and 8 will produce further divisions in next turn.<br /><br />so, statistically, the sequence is supposed to AT MOST (the most pessimistic scenario) stop. It can never rise, because for every 2 multiplications by 3, there are 3 divisions by 2. And this is the MOST pessimistic scenario. Computers can prove that up to, like, 2^64 the sequence DECREASES, so I see absolutely NO reason, why any larger number should lock in a dead loop (produce a cycle and thus never reach 1). In other words:&nbsp; if a number like 738472992384 decreases to 1, then why &quot;xxxxxxxxxxxxxxx738472992384&quot; [x being any digit) should not? If the &quot;738472992384&quot; will decrease then this &quot;xxxxxxxxxxxxxxx738472992384&quot; wil also decrease to AT LEAST &quot;xxxxxxxxxxxxxxx1&quot; (because &quot;738472992384&quot; decreases to 1), and then you multiply it by 3, which will produce an even number, and -statistically- two divisions of it. So the number&quot;xxxxxxxxxxxxxxx1&quot; should -statistically- decrease by 3:2 in ~4 turns. And then just repeat the process: once again you get some number, with some ending. And that ending has beed proved to decrease to 1, so.......... and so on, and so on.</div>
    <div class="meta">Posted on 2007-11-10 15:29:37 by ti_mo_n</div>
   </div>
   <div class="post" id="post-203558">
    <div class="subject"><a href="#post-203558">Re: 3n+1 Collatz Problem</a></div>
    <div class="body"><div class="quote"><br />you multiply by 3 and add 1 only if the number is odd (I was reffering to the &quot;problem&quot;, not to numbers in general ;) ). even numbers have to be divided by 2.</div><br /><br />The remark was very stupid from my part then :P</div>
    <div class="meta">Posted on 2007-11-10 15:57:21 by LocoDelAssembly</div>
   </div>
   <div class="post" id="post-203563">
    <div class="subject"><a href="#post-203563">Re: 3n+1 Collatz Problem</a></div>
    <div class="body">Yes it&#039;s just like f0dder said.. theres just no mathematical written formular or proof but the logic is easy to follow everyone can imagine after a while why the numbers will decrease.. but I think I even figured out an mathematical proof or at least a starting point yesterday but I&#039;m not at home right now so I cant lookup it was something like<br /><br />(3*n+1)=2^x<br /><br />if you solve it to n you get<br /><br />n=(2^x-1)/3<br /><br />that means n for the case of an power of 2 number..<br /><br />so if you put this n into the formular 3*n+1<br /><br />3*((2^x-1)/3)+1<br /><br />then every number of x will result in an power of 2<br />so that means just that 3n+1 will come to a power of 2 of course and if this happens then<br /><br />(3*((2^x-1)/3)+1)/(2^x)<br /><br />where 2^x just represents the div n 2 the times needed for coming to 1<br />it will always result in 1....</div>
    <div class="meta">Posted on 2007-11-10 21:34:50 by Emod</div>
   </div>
   <div class="post" id="post-203852">
    <div class="subject"><a href="#post-203852">Re: 3n+1 Collatz Problem</a></div>
    <div class="body">Hello to all.<br />I knew of this &quot;problem&quot; in the early 90s, (or late 80s?) in Scientific american, (it was called &quot;hailstone numbers).<br /><br />I have made some research runing a program, (is easy to code) all the time the series hits a power of 2, and plumet to the 4,2, 1 cycle. Every time, the series hits the 2^n precipice.<br /><br />But the problem is unsolved because *** In imposible to prove that it will always do so***<br />it means that in the wole domain of natural numbers, there could be a cycle diferent from the 4,2,1 and who never leads to a power of 2. AFAYK there is no such cycle, but THERE IS NO WAY TO PROVE IT, or disprove either. <br /><br />this is not as frivolous as it semes, it points to a deep and serious&nbsp; flaw in the matemathical reasoning, for a beter and extended expalantion see &quot;Godel Echer and Bach an eternal golden braid&quot;<br /><br />saludos<br /><br />Carlos Pacheco<br /><br /></div>
    <div class="meta">Posted on 2007-12-09 16:25:18 by Carlos</div>
   </div>
   <div class="post" id="post-203858">
    <div class="subject"><a href="#post-203858">Re: 3n+1 Collatz Problem</a></div>
    <div class="body">I am familiar with that book, I don&#039;t know how it relates to this problem.<br />As for Proof, you must mean mathematical proof, not empirical proof, which is the philosophical proof and the natural truth.</div>
    <div class="meta">Posted on 2007-12-10 05:43:56 by Homer</div>
   </div>
   <div class="post" id="post-203859">
    <div class="subject"><a href="#post-203859">Re: 3n+1 Collatz Problem</a></div>
    <div class="body">Hi Homer,<br />It&#039;s related, by the central theme of the book, the &quot;Godel incompletenes theorem&quot;, who states that any formal system (like mathematics, logic etc), no mater how powerfull, is not powerfull enoght to &quot;look&quot; into it&#039;s inards, that there will be some truths and falsities in the formal system (known or not) that can be deduced by the same system.<br /><br />This is the reason you can have empirical proof, by making the calculations by hand or by computer, that the 3n+1, n/2 problem is finite, (it hits the 4,2,1 secuence), but not mathematical proof of it, mathematics is not powerfull enought to reach this trut.<br /><br />And its not the only trut, there hare many more that haunt the mathematicians, and it&#039;s not fixed by &quot;refining&quot; mathematics, cause &quot;It&#039;s not a bug, it&#039;s a feature&quot; ;)<br /><br />Saludos<br />Carlos Pacheco&nbsp;  </div>
    <div class="meta">Posted on 2007-12-10 09:46:25 by Carlos</div>
   </div>
   <div class="post" id="post-203860">
    <div class="subject"><a href="#post-203860">Re: 3n+1 Collatz Problem</a></div>
    <div class="body">1. Every number can be expressed in form &quot;x+y&quot;, where y is less than 2^64, the sequence is proved to decrease to the &quot;4, 2, 1&quot; cycle.<br />2. x may be presented in a &quot;x1 + x2 + x3 + ..... + xn&quot; form where each of these xs are less than, or equal y.<br />3. if each of these xs decrease to 1 (because every number less than or equal to y does), then they form something like &quot;1+1+1+1+1+1+......&quot; which yields a number<br />4. treat this new number as another, new, &quot;x+y&quot;<br />5. go to 1 until the number if finite and less than 2^64.<br />7. It is proved that this number will decrease to 1.<br /><br />Isn&#039;t it proof enough?</div>
    <div class="meta">Posted on 2007-12-10 12:04:38 by ti_mo_n</div>
   </div>
   <div class="post" id="post-203865">
    <div class="subject"><a href="#post-203865">Re: 3n+1 Collatz Problem</a></div>
    <div class="body">Hi ti_mo_n<br /><br />No it is not, the problem is the statement &quot;where y is les than 2^64&quot;, it is a artificial boundary, and in mathematlcal induction this is a no-no, the reasonign sould be true for ALL numbers, not just numbers below a limit, it&#039;s ike saying &quot;I found a formula to compute prime numbers below the 2^16 limit&quot; if the formula fails over these limits, then it&#039;s not a general formula, end the problem remains unsolved.<br /><br />Salu2<br /><br />Carlos</div>
    <div class="meta">Posted on 2007-12-11 10:07:01 by Carlos</div>
   </div>
   <div class="post" id="post-203866">
    <div class="subject"><a href="#post-203866">Re: 3n+1 Collatz Problem</a></div>
    <div class="body">Hi Carlos.<br />OK, I see your point. Sure, maths is bugged :P</div>
    <div class="meta">Posted on 2007-12-11 20:55:30 by ti_mo_n</div>
   </div>
   <div class="post" id="post-203869">
    <div class="subject"><a href="#post-203869">Re: 3n+1 Collatz Problem</a></div>
    <div class="body">The central theme of the book is not godel&#039;s incompleteness theorem, its the interaction and sameness of the three fields of mathematics, visual art and musical composition.<br />I can understand that you are driven by math, and see math as the centerpiece of that work.<br />But that was not the intention of the author.<br />He was implying that there is an underlying homogeny and harmony between these fields, and that with perspective, each can be viewed as a work of another field.<br />He was implying that there is a common chord, a uniting theme, which he failed to describe, but nonetheless I agree with his perception in this regard.</div>
    <div class="meta">Posted on 2007-12-12 05:43:26 by Homer</div>
   </div>
   <div class="post" id="post-203916">
    <div class="subject"><a href="#post-203916">Re: 3n+1 Collatz Problem</a></div>
    <div class="body"><pre><code>; Collatz Conjecture:<br />	mov eax,Test_Number ; try 27<br />	jmp _0<br />_1:	lea eax, <br />_0:	shr eax,1<br />	je _x<br />	jc _1<br />	jmp _0<br />_x:</code></pre>Very easy to test smaller numbers. (c: I read that building a cycle tree can allow very large numbers to be tested. Certainly, not a proof of anything - no one has found a case that fails. I find it easy to think about the bit pattern of the number and know it will always reach one (i.e. carry flag set on exit). Multiplying by three and adding one has the effect of moving the one bits higher - they will all eventually carry to a single bit.<br /><br />Imagine the number bits can be cut down the middle lengthwise - so we have two copies. Now stack up the copies, shifting the top copy over one bit - we add one, so that space is a one bit. We don&#039;t have to add the whole thing - just count the bits in the least column. There is two one bits because it was odd.<br /><br />It&#039;s tempting to do the addition and work with smaller numbers, but if you keep duplicating the whole stack and shifting it then it&#039;s easier to see how it&#039;ll always result in a power of 2. Really, should show some pictures - much easier to see.<br /><br />For example the sequence for 7: 7 22 11 34 17 52 26 13 40 20 10 5 16.<br /><br />If we didn&#039;t divide by two, it would be:<pre><code>7<br />22<br />68&nbsp;  = 22*3 + 2<br />208&nbsp; = 68*3 + 4<br />640&nbsp; = 208*3 + 16<br />2048 = 640*3 + 128<br /><br />&nbsp; &nbsp; mov eax,7<br />_0: bsf edx,eax<br />&nbsp; &nbsp; xor ecx,ecx<br />&nbsp; &nbsp; lea eax,<br />&nbsp; &nbsp; bts ecx,edx<br />&nbsp; &nbsp; cmp eax,ecx<br />&nbsp; &nbsp; je _x<br />&nbsp; &nbsp; add eax,ecx<br />&nbsp; &nbsp; jmp _0:<br />_x:</code></pre>The divide by two step just keeps the numbers smaller. Clearly, the least bit is being propagated to fill the zero holes between the least and most significant set bit, but how can one explain mathematically that this is so?</div>
    <div class="meta">Posted on 2007-12-15 01:28:38 by bitRAKE</div>
   </div>
   <div class="post" id="post-203931">
    <div class="subject"><a href="#post-203931">Re: 3n+1 Collatz Problem</a></div>
    <div class="body">Here is a general routine to test <strong>very</strong> large numbers. :)<br />- only touches needed memory<br />- doesn&#039;t shift bignum (divide by two)<br />- doesn&#039;t test whole bignum for exit<pre><code>use32<br /><br />TestBuffer rb 32*1024 ; 32k<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ; a big number to test: 2^65536 + 3<br />&nbsp; &nbsp; &nbsp; &nbsp; mov dword ,3<br />&nbsp; &nbsp; &nbsp; &nbsp; mov dword ,1<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; push 32*1024/4 ; L1 cache size (c:<br />&nbsp; &nbsp; &nbsp; &nbsp; push TestBuffer<br />&nbsp; &nbsp; &nbsp; &nbsp; call CollatzArrayQ<br />&nbsp; &nbsp; &nbsp; &nbsp; jc ErrorNeedBiggerBuffer<br /><br />; check Collatz Conjecture on multi-percision number<br />;<br />; carry flag set on array overflow<br />; carry flag clear on pass<br />; (otherwise it loops forever: not likely, but hasn&#039;t been proven)<br />;<br />; NOTE: array should be twice the size of number to test - too large<br />; is not a problem as only active bits are operated on.<br />CollatzArrayQ:<br />&nbsp; &nbsp; &nbsp; &nbsp; label .arr at esp+4+32<br />&nbsp; &nbsp; &nbsp; &nbsp; label .len at esp+8+32<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; pushad<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ebx,[.arr]<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,[.len]<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,1<br />&nbsp; &nbsp; &nbsp; &nbsp; mov esi,ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; lea ebp,<br />; address past number in EDI (active end marker)<br />; (need at least one zero dword on end!)<br />.z:&nbsp; &nbsp; &nbsp;dec eax<br />&nbsp; &nbsp; &nbsp; &nbsp; test dword ,-1<br />&nbsp; &nbsp; &nbsp; &nbsp; je .z<br />&nbsp; &nbsp; &nbsp; &nbsp; lea edi,<br />&nbsp; &nbsp; &nbsp; &nbsp; cmp edi,ebp<br />&nbsp; &nbsp; &nbsp; &nbsp; je .over<br /><br />; advance to lowest set bit<br />.0:&nbsp; &nbsp; &nbsp;test ,ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; jne .1<br />&nbsp; &nbsp; &nbsp; &nbsp; rol ecx,1<br />&nbsp; &nbsp; &nbsp; &nbsp; jnc .0 ; HINT: taken<br />&nbsp; &nbsp; &nbsp; &nbsp; add esi,4<br />&nbsp; &nbsp; &nbsp; &nbsp; cmp esi,ebp&nbsp; &nbsp; &nbsp;; end<br />&nbsp; &nbsp; &nbsp; &nbsp; cmovnc esi,ebx&nbsp; ; reset<br />&nbsp; &nbsp; &nbsp; &nbsp; jmp .0<br />; ESI is first set bit, multiply by three and add ESI<br />; all (virtual) lower bits are zero.<br />.1:<br />&nbsp; &nbsp; &nbsp; &nbsp; ; test if buffer is == ESI then done!<br />&nbsp; &nbsp; &nbsp; &nbsp; cmp ,ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; jne .kx ; HINT: taken<br />&nbsp; &nbsp; &nbsp; &nbsp; ; if EDI==ESI+4 or (ESI+4==EBP &amp;&amp; EDI==EBX)<br />&nbsp; &nbsp; &nbsp; &nbsp; ; (faster than testing all of buffer)<br />&nbsp; &nbsp; &nbsp; &nbsp; mov edx,edi<br />&nbsp; &nbsp; &nbsp; &nbsp; lea eax,<br />&nbsp; &nbsp; &nbsp; &nbsp; cmp edi,ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; cmove edx,ebp<br />&nbsp; &nbsp; &nbsp; &nbsp; cmp eax,edx<br />&nbsp; &nbsp; &nbsp; &nbsp; je .x<br />.kx:<br />&nbsp; &nbsp; &nbsp; &nbsp; push ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; push esi<br />.2:<br />&nbsp; &nbsp; &nbsp; &nbsp; xor edx,edx<br />&nbsp; &nbsp; &nbsp; &nbsp; add ecx,<br />&nbsp; &nbsp; &nbsp; &nbsp; adc edx,0<br />&nbsp; &nbsp; &nbsp; &nbsp; shl dword ,1<br />&nbsp; &nbsp; &nbsp; &nbsp; adc edx,0<br />&nbsp; &nbsp; &nbsp; &nbsp; add ,ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; adc edx,0<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ecx,edx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; add esi,4<br />&nbsp; &nbsp; &nbsp; &nbsp; cmp esi,ebp&nbsp; &nbsp; &nbsp;; end<br />&nbsp; &nbsp; &nbsp; &nbsp; cmovnc esi,ebx&nbsp; ; reset<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; cmp esi,edi<br />&nbsp; &nbsp; &nbsp; &nbsp; jne .2<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; test ecx,ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; je .5<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; cmp edi,<br />&nbsp; &nbsp; &nbsp; &nbsp; je .over<br />&nbsp; &nbsp; &nbsp; &nbsp; mov ,ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; add edi,4<br />&nbsp; &nbsp; &nbsp; &nbsp; cmp edi,ebp&nbsp; &nbsp; &nbsp;; end<br />&nbsp; &nbsp; &nbsp; &nbsp; cmovnc edi,ebx&nbsp; ; reset<br /><br />.5:&nbsp; &nbsp; &nbsp;pop esi<br />&nbsp; &nbsp; &nbsp; &nbsp; pop ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; jmp .0<br /><br />.x:&nbsp; &nbsp; &nbsp;popad<br />&nbsp; &nbsp; &nbsp; &nbsp; clc<br />&nbsp; &nbsp; &nbsp; &nbsp; retn 8<br /><br />.over:&nbsp; popad<br />&nbsp; &nbsp; &nbsp; &nbsp; stc<br />&nbsp; &nbsp; &nbsp; &nbsp; retn 8</code></pre>(FASM syntax)<br /><br />It&#039;s all in L1 cache, and pretty fast, too! The wrap around buffer idea works like a FIFO - consuming one bits at the tail, while the head advances.<br /><br />Edit: there is an error in it somewhere, but I&#039;m done with it for now.</div>
    <div class="meta">Posted on 2007-12-15 12:49:36 by bitRAKE</div>
   </div>
   <div class="post" id="post-203965">
    <div class="subject"><a href="#post-203965">Re: 3n+1 Collatz Problem</a></div>
    <div class="body"><div class="quote">Status of the 3x+1 class record progress as of: Dec 13, 2007. Intervals are indicated in blocks of 20,000,000,000,000 (20 E+12 or 20 trillion numbers). Calculation of a single block takes approximately 20 days of (idle) time on a Pentium 1000 MHz.</div><a target="_blank" href="http://www.ericr.nl/wondrous/progress.html">Basically, a trillion per day, per Ghz</a>.<br /><br />Naturally, I&#039;m currious how my routine compares:<br /><br />Currently, they are working on 7 * 2^53 block of numbers. I ran a test of my algorithm for 2^24 numbers (in that block range) which took 38781ms. Which means it is roughly 25 times <strong>slower</strong>. Their algorithm is tuned for this size and uses very large data structures. I might be able to double the speed of my algorithm, but confirming ranges of numbers is not what it&#039;s designed for.</div>
    <div class="meta">Posted on 2007-12-16 11:42:18 by bitRAKE</div>
   </div>
   <div class="post" id="post-204263">
    <div class="subject"><a href="#post-204263">Re: 3n+1 Collatz Problem</a></div>
    <div class="body"><div class="quote">The central theme of the book is not godel&#039;s incompleteness theorem, its the interaction and sameness of the three fields of mathematics, visual art and musical composition.<br />I can understand that you are driven by math, and see math as the centerpiece of that work.<br />But that was not the intention of the author.<br />He was implying that there is an underlying homogeny and harmony between these fields, and that with perspective, each can be viewed as a work of another field.<br />He was implying that there is a common chord, a uniting theme, which he failed to describe, but nonetheless I agree with his perception in this regard.</div><br /><br />You are right Homer. the central theme of the book is not Godek &#039;s incompleteness theorem, is artificial inteligence, but the &quot;Hailstone numbers&quot; (3n+1,n/2 prroblem) crops up in one of the chapters (sadly I don have the book at hand to see wich one), very close to the MUI problem, as a early proff of the incompletness theorem<br />h<br />Saludos y Feliz a√±o nuevo (happy new year)<br /><br />Carlos</div>
    <div class="meta">Posted on 2007-12-30 23:55:03 by Carlos</div>
   </div>
  </div>
 </body>
</html>