<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>A way to make Assembly more programmer-friendly? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29405" />
  <link rel="prev" href="../?id=29405&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=29405">A way to make Assembly more programmer-friendly?</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29405&amp;page=1" style="">&laquo;</a><a href="../?id=29405&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29405" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-207601">
    <div class="subject"><a href="#post-207601">Re: A way to make Assembly more programmer-friendly?</a></div>
    <div class="body"><div class="quote"><br /><div class="quote">Why would you want to have the actual register names? Whatever registers the compiler picks will be fine.</div>Yeah, at least for trivial code like this - and when you need Ã¼berspeed and hand allocation, just <em>how</em> often do you need to call external routines? Also, you tend to need to interleave instructions, which means you can&#039;t use the highlevel assembly construct anyway.<br /><br />The idea seems entirely pointless to me. You&#039;d only find a handful of niche developer who think this could be a good idea... most will prefer either having a strong static typed language that can detect a lot of problems at compile-time (and offers power static analysis), or a dynamic language where type information can be determined at runtime. Assembly falls flat between those two chairs (some assemblers does at least support types, but then you&#039;re stuck with retard header files that assumes everything is a DWORD).<br /><br />If you think static typing is a bad thing, you&#039;ve probably spent too much time writing boring code that does little but interface with the PlatformSDK... which is a prime example of a package that is hellish to use because of it&#039;s legacy, and could do with a nice rewrite - you <strong>do</strong> need an insane amount of typecasting all over the place when using the PSDK in anything higher but C.<br /></div><br /><br />Well I have recently been coding with Objective C and Apple iPhone and we have released (with a great help from Ilian) an application for Walkers which is called Walkers Flavour Racers on the Apple Store. The next one is for O2 so to be honest, I think I know what I&#039;m talking about when I say these, commercially speaking, these things are not even counted when it comes to selling applications. I think it depends what your reasons are for coding. If you want to actually sell applications, Assembly will definitely will be the last programming language in the list of choices since it takes a lot of time to develop a simple application, not many people know it (because of its complexity, the amount of time it needs to develop applications and etc) and many others.</div>
    <div class="meta">Posted on 2009-05-13 09:02:51 by XCHG</div>
   </div>
   <div class="post" id="post-207602">
    <div class="subject"><a href="#post-207602">Re: A way to make Assembly more programmer-friendly?</a></div>
    <div class="body"><strong>XCHG</strong>: ...which are all great reasons it doesn&#039;t make sense trying to make something to cater for a lot of developers, or to try and make assembly a &quot;viable commercial production language&quot;. <strong>We</strong> use it for speed or because we plain enjoy it, and imho that&#039;s a fine enough position for the language - aside for those two reasons (which can be justification enough!), imho other languages are better for most purposes.<br /><br />The thing <strong>*I*</strong> enjoy about assembly is WYCIWYG and full control of the CPU - if I want high-level code, I use a high(er)-level language. YMMV :)</div>
    <div class="meta">Posted on 2009-05-13 09:08:29 by f0dder</div>
   </div>
   <div class="post" id="post-207603">
    <div class="subject"><a href="#post-207603">Re: A way to make Assembly more programmer-friendly?</a></div>
    <div class="body"><div class="quote"><br /><strong>XCHG</strong>: ...which are all great reasons it doesn&#039;t make sense trying to make something to cater for a lot of developers, or to try and make assembly a &quot;viable commercial production language&quot;. <strong>We</strong> use it for speed or because we plain enjoy it, and imho that&#039;s a fine enough position for the language - aside for those two reasons (which can be justification enough!), imho other languages are better for most purposes.<br /><br />The thing <strong>*I*</strong> enjoy about assembly is WYCIWYG and full control of the CPU - if I want high-level code, I use a high(er)-level language. YMMV :)<br /></div><br /><br />You think I don&#039;t enjoy Assembly? I really do but it bothers me that I can&#039;t pick it as a language to do a commercial application with knowing the potential of Assembly.</div>
    <div class="meta">Posted on 2009-05-13 09:33:03 by XCHG</div>
   </div>
   <div class="post" id="post-207604">
    <div class="subject"><a href="#post-207604">Re: A way to make Assembly more programmer-friendly?</a></div>
    <div class="body">No no, I do think you enjoy assembly :) - I just stated why <em>I</em> enjoy it, which might not be the same for everybody else - as I wrote, YMMV.</div>
    <div class="meta">Posted on 2009-05-13 09:35:49 by f0dder</div>
   </div>
   <div class="post" id="post-207610">
    <div class="subject"><a href="#post-207610">Re: A way to make Assembly more programmer-friendly?</a></div>
    <div class="body"><div class="quote"><br />No no, I do think you enjoy assembly :) - I just stated why <em>I</em> enjoy it, which might not be the same for everybody else - as I wrote, YMMV.<br /></div><br /><br />Yeah I also love the fact that Assembly, once you understand the whole structure, instruction set and etc, is the easiest and the most powerful way of writing programs. These are the things that I wanted to solve:<br /><br />1) Nobody will ever pick Assembly as a language to write commercial applications.<br />2) Assembly will eventually be phased out considering how fast HW is becoming more and more advanced.<br />3) Using Assembly will eventually become useless considering the great deal of time put into making compilers more and more sophisticated.</div>
    <div class="meta">Posted on 2009-05-14 04:25:47 by XCHG</div>
   </div>
   <div class="post" id="post-207611">
    <div class="subject"><a href="#post-207611">Re: A way to make Assembly more programmer-friendly?</a></div>
    <div class="body">I know what you want man.<br />You want a new half-way language, something that is quick to develop without losing control.<br />Join us!</div>
    <div class="meta">Posted on 2009-05-14 06:11:01 by Homer</div>
   </div>
   <div class="post" id="post-207613">
    <div class="subject"><a href="#post-207613">Re: A way to make Assembly more programmer-friendly?</a></div>
    <div class="body">What about PB? For example code snippet:<br />http://www.powerbasic.com/support/pbforums/showpost.php?p=315270&amp;postcount=7<br /><br />There is always the possibility of writing your own compiler/assembler. That&#039;s a lot of work though (but quite rewarding.)</div>
    <div class="meta">Posted on 2009-05-14 13:06:19 by MarkJ</div>
   </div>
   <div class="post" id="post-207615">
    <div class="subject"><a href="#post-207615">Re: A way to make Assembly more programmer-friendly?</a></div>
    <div class="body">This paradox is obviously solved with VS2k5+ C++ : you have inline asm in x86, the HLL parts are compiled+optimized very nicely, your own external .asm code is inspected by the linker and nicely inlined (with almost-perfect register allocation around your inspected asm code). The inline asm is barebones but has easy access to the local HLL symbols, while the external .asm files can use powerful macros. Then, intrinsics to automatically allocate registers (be it in static or inlined context). Add to that knowledge of the compiler&#039;s output, and together all those features create the holy grail: complete power+flexibility+ease+optimization+anything at your tips at any time, without the huge drawbacks we&#039;re used to get when choosing a path in the current line of code. </div>
    <div class="meta">Posted on 2009-05-14 13:59:10 by Ultrano</div>
   </div>
   <div class="post" id="post-207616">
    <div class="subject"><a href="#post-207616">Re: A way to make Assembly more programmer-friendly?</a></div>
    <div class="body">Ultrano, are you sure that we can inline external ASM code? Do you have an example handy?</div>
    <div class="meta">Posted on 2009-05-14 15:41:21 by ChaperonNoir</div>
   </div>
   <div class="post" id="post-207617">
    <div class="subject"><a href="#post-207617">Re: A way to make Assembly more programmer-friendly?</a></div>
    <div class="body">Well, actually external asm is not inlined (I just observed good register-allocation around calls to it), but inline asm is. </div>
    <div class="meta">Posted on 2009-05-14 16:00:30 by Ultrano</div>
   </div>
   <div class="post" id="post-207618">
    <div class="subject"><a href="#post-207618">Re: A way to make Assembly more programmer-friendly?</a></div>
    <div class="body">C++ isn&#039;t perfect, though - especially not when you do win32 API level programming, since the PlatformSDK was clearly designed back in the C days, and not really brought up to date. Too many typecasts needed, <strong>ugly</strong> use of the preprocessor (ever tried having a WriteFile member function in one of your classes?), and the C++ standard library isn&#039;t as rich as some of the newer languages... not to mention that libc string functions are evil, and C++&#039;s std::string sucks. I still like the language, though, and it <strong>is</strong> very powerful and flexible, and has compilers that generate nice code.<br /><br />Are you sure the compiler/linker analyzes external modules wrt. register allocation, though? I&#039;ve never heard of such a feature, and it would seem like quite some work. Isn&#039;t it just that it knows about standard calling conventions and tries to optimize for that?<br /><br />Also, inline assembly doesn&#039;t work for x64 compilers. I don&#039;t really see this as a problem, though, since anything worth writing in assembly is usually worth writing in an external module.<br /><br />Oh, and I&#039;m not a super huge fan of MMX/SSE/whatever intrinsics - the idea is great, but when I (who, admittedly, isn&#039;t the supermosthardcore optimizer :)) can get quite better results than the compiler spits out, it has a way to go yet. But intrinsics aren&#039;t portable anyway, so you might as well go and write assembly... unless you&#039;re using intrinsics for prototyping and then go and hand-optimize afterwards.<br /><br />As for PowerBASIC... I&#039;d stay clear of it. It has awful code generation, the language is pretty unflexible and limited, the only way of using external modules is through DLLs, and you kinda <em>have</em> to drop to inline assembly to get decent performance when you aren&#039;t doing simple API-bound stuff. And the debugger sucks.</div>
    <div class="meta">Posted on 2009-05-14 17:45:42 by f0dder</div>
   </div>
   <div class="post" id="post-207619">
    <div class="subject"><a href="#post-207619">Re: A way to make Assembly more programmer-friendly?</a></div>
    <div class="body">Hehe, I completely agree with you f0dder. <br /><br />And all these obvious typecasts always get on my nerves. They all do nothing, but you always need them. It seems that if you compile your code as C code you don&#039;t need them but who would want to do that?<br /><br />Not to mention the DLL hell. If you Release with Visual 2005, you need to install the winsx redistributable package for 2005. If you release with Visual 2008 (like me), you need to install the redistributable package for 2008. There&#039;s like no way to easily link to the good old standard MSVCRT.DLL with Visual Studio 2005/2008. It seems that the GNU tools on Windows link to MSVCRT.DLL, maybe I try to convert some of my projects to the GNU compiler.<br /><br /><br /></div>
    <div class="meta">Posted on 2009-05-14 21:20:10 by ChaperonNoir</div>
   </div>
   <div class="post" id="post-207621">
    <div class="subject"><a href="#post-207621">Re: A way to make Assembly more programmer-friendly?</a></div>
    <div class="body"><strong>ChaperonNoir</strong>: yes, the libc DLL situation with newer Visual C is hell, and it&#039;s damn annoying, and I&#039;m not particular fond of having to use .msi installers to get &quot;clean&quot; installs... using the redistrutable exe installer sucks, and dropping the runtime DLLs to each of your installed application folders does too. Sigh. But I wouldn&#039;t want to use old MSVCRT.DLL either.<br /><br />The PlatformSDK could be - at least mostly - fixed up to behave nice with C++, but it would be a gigantic undertaking. At least outside the domain of small programs, you aren&#039;t/shouldn&#039;tbe spending most of your time with API code and typecasts :)</div>
    <div class="meta">Posted on 2009-05-15 03:27:39 by f0dder</div>
   </div>
   <div class="post" id="post-207623">
    <div class="subject"><a href="#post-207623">Re: A way to make Assembly more programmer-friendly?</a></div>
    <div class="body"><strong>ChaperonNoir</strong>, you should try intel compiler, it&#039;s way waay more relaxed with the need for typecasting than ms compiler. Oh, and cl with /Zl switch and msvcrt.lib passed to linker should work...</div>
    <div class="meta">Posted on 2009-05-15 09:02:48 by drizz</div>
   </div>
   <div class="post" id="post-207624">
    <div class="subject"><a href="#post-207624">Re: A way to make Assembly more programmer-friendly?</a></div>
    <div class="body"><div class="quote"><strong>ChaperonNoir</strong>, you should try intel compiler, it&#039;s way waay more relaxed with the need for typecasting than ms compiler.</div>It can&#039;t be, since it wouldn&#039;t be following the standard. Are you compiling in C rather than C++ mode?<br /><br /><div class="quote">Oh, and cl with /Zl switch and msvcrt.lib passed to linker should work...</div>Probably unsafe - there&#039;s things here and there in libc/c++ that depend on the data structure (as defined in the headers) - using the 2005/2008 headers but linking against generic old MSVCRT isn&#039;t something I&#039;d recommend (having just experienced a game that was linked against <strong>old</strong> msvcrt headers, and crashed when running against a more recent library).</div>
    <div class="meta">Posted on 2009-05-15 10:41:31 by f0dder</div>
   </div>
   <div class="post" id="post-207626">
    <div class="subject"><a href="#post-207626">Re: A way to make Assembly more programmer-friendly?</a></div>
    <div class="body">yes f0dder c++ mode.<br /><br />small example:<br /><pre><code>coffeedev.cpp(15) : error C2664: &#039;CoffLib::Open&#039; : cannot convert parameter 1 from &#039;const char [9]&#039; to &#039;unsigned char *&#039;<br />&nbsp; &nbsp; &nbsp; &nbsp; Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast<br />coffeedev.cpp(40) : error C2664: &#039;CoffObj::Open&#039; : cannot convert parameter 1 from &#039;PDWORD&#039; to &#039;BYTE *&#039;<br />&nbsp; &nbsp; &nbsp; &nbsp; Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast<br />coffeedev.cpp(49) : error C2664: &#039;strncmp&#039; : cannot convert parameter 1 from &#039;BYTE (*)[8]&#039; to &#039;const char *&#039;<br />&nbsp; &nbsp; &nbsp; &nbsp; Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast<br />coffeedev.cpp(56) : error C2664: &#039;strncmp&#039; : cannot convert parameter 1 from &#039;BYTE (*)[8]&#039; to &#039;const char *&#039;<br />&nbsp; &nbsp; &nbsp; &nbsp; Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast<br />coffeedev.cpp(71) : error C2440: &#039;=&#039; : cannot convert from &#039;PBYTE&#039; to &#039;PIMAGE_SYMBOL&#039;<br />&nbsp; &nbsp; &nbsp; &nbsp; Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast<br />coffeedev.cpp(122) : error C2664: &#039;CoffImage::Open&#039; : cannot convert parameter 1 from &#039;const char [9]&#039; to &#039;BYTE *&#039;<br />&nbsp; &nbsp; &nbsp; &nbsp; Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast<br />coffeedev.cpp(134) : error C2440: &#039;initializing&#039; : cannot convert from &#039;BYTE *&#039; to &#039;PIMAGE_IMPORT_DESCRIPTOR&#039;<br />&nbsp; &nbsp; &nbsp; &nbsp; Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast or function-style cast<br /></code></pre><br />Those are the only errors that <strong>cl</strong> shows but not <strong>icl</strong>. Anyway, i think we are <u>offtopic</u>&nbsp; :)</div>
    <div class="meta">Posted on 2009-05-15 14:54:33 by drizz</div>
   </div>
   <div class="post" id="post-207627">
    <div class="subject"><a href="#post-207627">Re: A way to make Assembly more programmer-friendly?</a></div>
    <div class="body"><div class="quote"><br /><strong>ChaperonNoir</strong>, you should try intel compiler, it&#039;s way waay more relaxed with the need for typecasting than ms compiler. Oh, and cl with /Zl switch and msvcrt.lib passed to linker should work...<br /></div><br /><br />I have it and I think it&#039;s a good compiler if you remove the totality of the Runtime and keep only the code.<br />The following C code gives this assembly code, I think that the compiler is doing a good job here.<br />Extern &quot;C&quot; is something I like to add but here it&#039;s not necessary because the entry point is passed to the linker via commandline.<br /><pre><code><br />#include &lt;stdio.h&gt;<br />#include &lt;string.h&gt;<br /><br />extern &quot;C&quot; void mainCRTStartup()<br />{<br />	static char myString&#91;] = &quot;hello&quot;;<br />	printf(myString);<br /><br />	int size = strlen(myString);<br />	printf(&quot;%d&quot;,size);<br /><br />}<br /></code></pre><br /><pre><code>&nbsp; &nbsp; &nbsp; &nbsp;ALIGN&nbsp; &nbsp; &nbsp;16<br />	PUBLIC _mainCRTStartup<br />_mainCRTStartup	PROC NEAR <br />.B1.1:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Preds .B1.0<br /><br />;;; {<br /><br />$LN1:<br />$LN3:<br /><br />;;; 	static char myString&#91;] = &quot;hello&quot;;<br />;;; 	printf(myString);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; &nbsp; OFFSET FLAT: myString.9660.0.1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;7.9<br />$LN5:<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; &nbsp; DWORD PTR [__imp__printf]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;7.2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; LOE ebx ebp esi edi<br />.B1.6:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Preds .B1.1<br />&nbsp; &nbsp; &nbsp; &nbsp; pop&nbsp; &nbsp; &nbsp; &nbsp;ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;7.2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; LOE ebx ebp esi edi<br />.B1.2:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Preds .B1.6<br />$LN7:<br /><br />;;; <br />;;; 	int size = strlen(myString);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;ecx, OFFSET FLAT: myString.9660.0.1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;9.13<br />&nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp; &nbsp; &nbsp;eax, eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;9.13<br />L4:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;<br />&nbsp; &nbsp; &nbsp; &nbsp; movzx&nbsp; &nbsp; &nbsp;edx, BYTE PTR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;9.13<br />&nbsp; &nbsp; &nbsp; &nbsp; test&nbsp; &nbsp; &nbsp; edx, edx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;9.13<br />&nbsp; &nbsp; &nbsp; &nbsp; je&nbsp; &nbsp; &nbsp; &nbsp; L3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Prob 50%&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;9.13<br />&nbsp; &nbsp; &nbsp; &nbsp; movzx&nbsp; &nbsp; &nbsp;edx, BYTE PTR [1+ecx+eax]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;9.13<br />&nbsp; &nbsp; &nbsp; &nbsp; add&nbsp; &nbsp; &nbsp; &nbsp;eax, 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;9.13<br />&nbsp; &nbsp; &nbsp; &nbsp; test&nbsp; &nbsp; &nbsp; edx, edx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;9.13<br />&nbsp; &nbsp; &nbsp; &nbsp; jne&nbsp; &nbsp; &nbsp; &nbsp;L4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Prob 50%&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;9.13<br />&nbsp; &nbsp; &nbsp; &nbsp; dec&nbsp; &nbsp; &nbsp; &nbsp;eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;9.13<br />L3:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; LOE eax ebx ebp esi edi<br />.B1.7:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Preds .B1.2<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; &nbsp; eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;9.13<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; &nbsp; OFFSET FLAT: ??_C@_02A@?$CFd?$AA@&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;9.13<br />$LN9:<br /><br />;;; 	printf(&quot;%d&quot;,size);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; &nbsp; DWORD PTR [__imp__printf]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;10.2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; LOE ebx ebp esi edi<br />.B1.8:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Preds .B1.7<br />&nbsp; &nbsp; &nbsp; &nbsp; add&nbsp; &nbsp; &nbsp; &nbsp;esp, 8&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;10.2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; LOE ebx ebp esi edi<br />.B1.3:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Preds .B1.8<br /><br />;;; <br />;;; }<br />$LN11:<br />&nbsp; &nbsp; &nbsp; &nbsp; ret&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;12.1<br />&nbsp; &nbsp; &nbsp; &nbsp; ALIGN&nbsp; &nbsp; &nbsp;16<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; LOE<br />; mark_end;<br />_mainCRTStartup ENDP</code></pre><br /><br />You have to admit that this is good code. And I&#039;d say that the Visual C++ code is even better. This code is linked with MSVCRT.DLL using msvcrt.lib from MASM32\lib\ and it will work on every version of windows thanks to that.<br /></div>
    <div class="meta">Posted on 2009-05-15 17:51:57 by ChaperonNoir</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29405&amp;page=1" style="">&laquo;</a><a href="../?id=29405&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29405" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>