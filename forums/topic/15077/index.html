<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Storing command line in an .exe - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=15077" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=15077">Storing command line in an .exe</a></p>
   <div class="post" id="post-117083">
    <div class="subject"><a href="#post-117083">Storing command line in an .exe</a></div>
    <div class="body">This program sucessfully stores the filename from the command line<br />into SOURCE_FILE. But when I incorporated it into shred2.asm (next) it doesn't<br />work. Thanks.<br /><br />;  test.asm  Com file<br />;   store command line<br />;<br />model      tiny<br />code<br /><br />org     100h     <br /><br />BEGIN:<br />        jmp     parse<br /><br />   file            db      'filename' ; marker right before where<br />   SOURCE_FILE     db      128 dup (0);filename is stored<br />   TARGET_PATH     db      128 dup (0)<br />        <br />        VALID_IN	db	'abcdefghijklmnopqrstuvwxyz,;=',9<br />	VALID_OUT	db	'ABCDEFGHIJKLMNOPQRSTUVWXYZ',4 dup(32)<br />	VALID_NUM	equ	$ - VALID_OUT + 1<br /><br />        NO_PARMS     db         10,10,13,'Nothing on command line. ',10,13,13,'$'<br />               <br />        OK           db         'File found.$' <br /><br />parse:     ; Parse command line <br /><br />	mov	si,80h	; PSP parameter byte count pointer<br />	mov	cl, ; Move byte count to CL<br />	xor	ch,ch	; Zero CH<br />        jcxz    NO_PARMS_PASSED; If CX is zero,  no parameters<br />	mov	dx,cx			; Save byte count in dx<br />	inc	si			; Point to parameter area<br />	mov	di,si			; Copy SI to DI for cleanup routine<br />	cld			; Set direction flag to forward<br /><br />CLEAN_PARMS:	; Change valid delimiters to blanks, lower to <br />                ; upper case<br /><br />	lodsb			; Load each character to AL<br />	push	di			; Save DI on stack<br />	mov	di,offset VALID_IN; Point to table of valid inputs<br />	push	cx			; Save CX on stack<br />        mov     cx,VALID_NUM         ; Set CX to number of inputs       <br />                                          <br />                                      ; to look for<br />        repne   scasb                   ; See if any are in AL<br />	jcxz	CLEAN_END		; If not, change nothing<br />	mov	bx,VALID_NUM; Set up BX to point to valid output<br />	sub	bx,cx		; This will leave BX one off<br />	mov	al,VALID_OUT ; Load the valid output to AL<br /><br />CLEAN_END:<br /><br />	pop	cx			; Restore CX<br />	pop	di			; Restore DI<br />	stosb				; Store modified AL back to PSP<br />        loop    CLEAN_PARMS             ; Loop until CX is zero<br /><br />        mov     cx,dx       ; Restore number of bytes in PSP to CX<br />        mov     dx,2              ; Set DX to look for up to 2 parameters<br />	mov	bx,offset SOURCE_FILE; Set BX to address of 1st  <br />                                     ; parameter <br />	mov	al,' '      ; Set up to scan for first non-blank<br />	mov	di,81h  ; Set DI to PC-DOS parameter pointer<br /><br />FIND_PARMS ; Start looking for parameters<br /><br />        repe    scasb                   ; Scan while blanks<br />	mov	si,di			; Set SI to second non-blank byte<br />	dec	si			; Adjust it to first non-blank byte<br />	inc	cx			; Adjust CX to compensate<br />	jcxz	PARMS_LOADED		; If CX is zero, no parameters left<br />	mov	di,bx			; Set DI to parameter hold area<br />	mov	ax,cx			; Store CX to first byte of hold area<br />	stosb				; DI is adjusted to second byte here<br />STORE:<br />        lodsb                           ; Load each byte to AL<br />	cmp	al,' '                  ; Is it a blank?<br />	jz	END_STORE		; Yes, end of this parameter<br /><br />        stosb				; No, store the byte to hold area<br /><br />END_STORE:<br /><br />	loopnz	STORE			; Keep looking<br />	sub	,cx 		; Store number of bytes in each<br />	jcxz	PARMS_LOADED		; If CX is zero, no more parameters<br />	dec	byte ptr 		; parameter to first byte of hold area<br />	mov	di,si			; Set up to scan for next non-blank<br />	dec	di			; Adjust DI to point to the blank<br />	inc	cx			; Adjust CX to compensate<br />	dec	dx			; Decrement DX counter<br />	cmp	dx,0			; Is DX zero?<br />	jz	PARMS_LOADED		; Yes, all expected parameters loaded<br />        add     bx,128                  ; No, point to next part of hold<br />area<br />	jmp	FIND_PARMS		; Go back and look for more<br /><br />PARMS_LOADED:				; All parameters are loaded<br />        jmp     short finish<br /><br />NO_PARMS_PASSED:			; Exit with an error if there<br /><br />        lea     dx, NO_PARMS      ; are no parameters passed<br /><br />ERROR_EXIT:				; Print Error Message and Exit<br /><br />	mov	ah,9			; Display error header<br />	int	21h<br />        mov     ax,4c01h<br />        int     21h<br />finish:<br />        mov     ah,9<br />        lea     dx,OK<br />        int     21h<br />        mov     ax,4c00h<br />        int     21h<br />end     begin<br /><br />; SHRED2.ASM  Ver 1e     8/24/03     Andy Kennedy 1996 - 2003<br />;                                                    <br />;        Works through Win 98  <br />;        Supports Long Filenames <br />;<br />;        Overwrite a file with random bytes,<br />;        truncates it to zero bytes,<br />;        set file time and date to 12:59:58 pm  1/1/80,<br />;        renames it and then deletes it.<br />;        Single files only. (For Safety)<br />;                                                        <br />; Use full path when not in current directory  Ex. a:\test<br />;<br />; Works across drives, handles periods in the path names  1a   10/8/96<br />;                                                         1b    5/2002 <br />;        ***** FILE is NOT recoverable !!!!  ****         1c    9/02<br />;                                                         1d    3/29/03<br />;                                                         1e    8/24/03<br />model       small<br />stack       200h<br /><br />data?   ; can contain ONLY un-initialized data<br />         <br />random       db         64000 dup(?) <br /><br />data<br /><br />handle       dw           ?<br />file_size    dd           ?<br />name_size    dw           ?<br /><br />prompt       db       13,10,13,10,9,'File Shredder   Ver. 1e',13,10 <br />             db       13,10,'This file will NOT be recoverable !!',13,10<br />             db       13,10,'File name to SHRED --&gt; $' <br /><br />not_there    db       13,10,13,10,'File not present.',13,10,'$'<br />emsg2        db       13,10,13,10,'Error moving file pointer.',13,10,'$'<br />emsg3        db       13,10,13,10,'Error writing to file.',13,10,'$'<br /><br />NO_PARMS     db       13,10,13,10,'Nothing on command line.',13,10,13,10,'$'<br />VALID_IN     db      'abcdefghijklmnopqrstuvwxyz,;=',9<br />VALID_OUT    db      'ABCDEFGHIJKLMNOPQRSTUVWXYZ',4 dup(32)<br />VALID_NUM    equ     $ - VALID_OUT + 1<br /><br />done_msg     db       13,10,13,10,'File has been shredded.',13,10,'$'<br />prescence    db       'Andrew Kennedy 2003'                             <br />         <br />n            db       'file'<br />file_name    db       128 dup(?)  ; DOS maximum path length<br />storage      db       150 dup(?)<br />eraser_name  db      '????????.',0<br /><br />code<br /><br />start:                              <br />             mov          ah,15     ; clear the screen<br />             int          10h<br />             mov          ah,0<br />             int          10h<br /><br />             <br />             mov          ax,@data<br />             mov          ds,ax              <br />             mov          es,ax  ; need for LFN functions<br /><br />parse:     ; Parse command line<br /><br />	mov	si,80h			; PSP parameter byte count pointer<br />	mov	cl, 		; Move byte count to CL<br />	xor	ch,ch			; Zero CH<br />        jcxz    NO_PARMS_PASSED      ; If CX is zero, there are no parameters<br />	mov	dx,cx			; Save byte count in dx<br />	inc	si			; Point to parameter area<br />	mov	di,si			; Copy SI to DI for cleanup routine<br />	cld				; Set direction flag to forward<br /><br />CLEAN_PARMS:	; Change valid delimiters to blanks, lower to upper case<br /><br />	lodsb				; Load each character to AL<br />	push	di			; Save DI on stack<br />	mov	di,offset VALID_IN	; Point to table of valid inputs<br />	push	cx			; Save CX on stack<br />        mov     cx,VALID_NUM         ; Set CX to number of inputs to look<br />for<br />        repne   scasb                   ; See if any are in AL<br />	jcxz	CLEAN_END		; If not, change nothing<br />	mov	bx,VALID_NUM		; Set up BX to point to valid output<br />	sub	bx,cx			; This will leave BX one off<br />	mov	al,VALID_OUT 	; Load the valid output to AL<br /><br />CLEAN_END:<br /><br />	pop	cx			; Restore CX<br />	pop	di			; Restore DI<br />	stosb				; Store modified AL back to PSP<br />        loop    CLEAN_PARMS             ; Loop until CX is zero<br /><br />        mov     cx,dx                 ; Restore number of bytes in PSP to<br />CX<br />        mov     dx,2                  ; Set DX to look for up to 2 parameters<br />        mov     bx,offset file_name   ; Set BX to address of 1st parameter<br />	mov	al,' '                  ; Set up to scan for first non-blank<br />	mov	di,81h			; Set DI to PC-DOS parameter pointer<br /><br />FIND_PARMS:	; Start looking for parameters, load to program storage<br /><br />        repe    scasb                   ; Scan while blanks<br />	mov	si,di			; Set SI to second non-blank byte<br />	dec	si			; Adjust it to first non-blank byte<br />	inc	cx			; Adjust CX to compensate<br />	jcxz	PARMS_LOADED		; If CX is zero, no parameters left<br />	mov	di,bx			; Set DI to parameter hold area<br />	mov	ax,cx			; Store CX to first byte of hold area<br />	stosb				; DI is adjusted to second byte here<br />STORE:<br />        lodsb                           ; Load each byte to AL<br />	cmp	al,' '                  ; Is it a blank?<br />	jz	END_STORE		; Yes, end of this parameter<br /><br />        stosb				; No, store the byte to hold area<br /><br />END_STORE:<br /><br />	loopnz	STORE			; Keep looking<br />	sub	,cx 		; Store number of bytes in each<br />	jcxz	PARMS_LOADED		; If CX is zero, no more parameters<br />	dec	byte ptr 		; parameter to first byte of hold area<br />	mov	di,si			; Set up to scan for next non-blank<br />	dec	di			; Adjust DI to point to the blank<br />	inc	cx			; Adjust CX to compensate<br />	dec	dx			; Decrement DX counter<br />	cmp	dx,0			; Is DX zero?<br />	jz	PARMS_LOADED		; Yes, all expected parameters loaded<br />        add     bx,128                  ; No, point to next part of hold<br />area<br />	jmp	FIND_PARMS		; Go back and look for more<br /><br />PARMS_LOADED:				; All parameters are loaded<br />        jmp     short change  <br />        int     3  <br />NO_PARMS_PASSED:			; Exit with an error if there<br /><br />        lea     dx, NO_PARMS      ; are no parameters passed<br />        jmp     ERROR_EXIT<br /><br />; Change any read-only attribute<br /><br />change:<br />             lea          dx,file_name  + 2<br />             mov          ax,4301h<br />             mov          cx,00000000b   ; remove read-only attribute<br />             int          21h<br /><br />;INT 21 - Windows95 - LONG FILENAME - CREATE OR OPEN FILE<br />;	AX = 716Ch<br />;	BX = access mode and sharing flags (see #01782,also AX=6C00h);<br />;	CX = attributes<br />;	DX = action (see #01781)<br />;	DS:SI -&gt; ASCIZ filename<br />   <br />	mov	ax,716Ch	; create file<br />	xor	cx,cx		; file attributes<br /><br />; file access modes (bits)	<br />;     000 read-only<br />;     001 write-only<br />;     010 read-write<br />;     100 read-only, do not modify file's last-access time<br /><br />             mov          bx,2             ; access mode (R/W)<br />             mov          dx,2             ; open file<br />             lea          si,file_name + 2 ; sets the file name<br />             int          21h<br />             mov          ,ax        ; Save file handle<br />             jnc          short get_size     ; No errors, go on<br />no_file:             <br />             mov          dx,offset not_there; Get error message<br />             jmp          error              ; and go display/exit<br />get_size:<br />             mov          ax,4202h           ; Set file pointer<br />             mov          bx,        ; for this file<br />             xor          cx,cx              ; relative to end of file<br />             xor          dx,dx              ; offset 0 bytes<br />             int          21h<br />             jnc          save_size           <br />err2:<br />             mov          dx,offset emsg2    ; Get error message<br />             jmp          error              ; and go display/exit<br /><br />save_size:<br />             mov          word ptr ,ax     ; Save low word of<br />file size<br />             mov          word ptr ,dx ; Save high word<br /><br />             mov          ax,4200h           ; Move file pointer<br />             mov          bx,        ; for this file<br />             xor          cx,cx              ; relative to beginning of file<br />             xor          dx,dx              ; offset 0 bytes<br />             int          21h<br />             jc           err2               ; Errors: go handle<br /><br />next_bunch:<br />             mov          cx,64000           ; Assume 64,000 bytes or more<br />left<br />                                             ; to do<br /><br />             sub          word ptr ,cx   ; Is there ? - subtract<br />it<br />             sbb          word ptr ,0 ; from saved file size<br />             <br />             jae          wipe                ; There were 64,000 bytes or<br /><br />                                              ; more left<br />             <br />             mov          cx,word ptr  ; Get number of bytes left<br />             add          cx,64000                ; back CX (undo subtraction)<br /><br />wipe:<br />             mov          ah,40h             ; Write file<br />             mov          bx,        ; Handle<br />             mov          dx,offset random   ; Write the random bytes<br />             int          21h<br />             jnc          check_size         ; No errors, go on<br /><br />err3:<br />             mov          dx,offset emsg3    ; Get appropriate error message<br />             jmp          error              ; and go display/exit<br /><br />check_size:<br />             cmp          ax,cx               <br />             jnz          err3               <br />             cmp          ax,64000           ; Full 64,000 bytes written,<br />             je           next_bunch         ; yes, go check for more<br /><br />             mov          bx,        ; close file <br />             mov          ah,3eh<br />             int          21h<br />     <br />; Truncate file to zero bytes        <br /><br />             mov          ah,3ch        ; truncate file to zero bytes<br />             mov          cx,0<br />             mov          dx,offset file_name + 2<br />             int          21h<br />                        <br />             mov          bx,   ; close file<br />             mov          ah,3eh<br />             int          21h<br />             <br />; Store the path <br /><br />scan:<br />             lea      si,<br />             xor      cx,cx<br />             mov      di,si<br />             mov      cx,<br /><br />             mov      al,'\'              <br />             add      di,cx<br />             std                          ; scan from right to left<br />             dec      di<br />             repne    scasb               <br />             jnz      short no_path       ;  No slash is present<br />             add      cx,1                ; <br /><br />no_path:<br />             mov      di,offset storage<br />             cld                          ; change directions and scan <br />             rep      movsb               ; from left to right<br />             mov      al,00<br />             stosb                        ; make path ASCIZ<br /><br />; Add on eraser_name to end of storage<br /><br />add_eraser:<br /><br />             mov      cx,<br />             mov      si,cx              <br />             lea      di,storage    <br />             mov      al,00             ; stops at the byte after the &quot;00&quot;<br />             repnz    scasb               <br />             dec      di                ; backup one<br /><br />             xor      cx,cx<br />             mov      si,offset eraser_name       <br />             mov      cx,9  ; # of characters            <br />             rep      movsb                    <br /><br />; Rename and delete file   (LFN)<br /><br />rename:<br />             mov          dx,offset file_name + 2  ; old file name<br />             mov          di,offset storage        <br />             mov          ax,7156h                 ; LFN support<br />             int          21h<br /> <br />; Change file date and time<br /><br />        mov     ax,716Ch        ; open file<br />        xor     cx,cx	  ; file attributes<br /><br />; file access modes (bits) FOR BX Register<br />;       000 read-only<br />;	001 write-only<br />;	010 read-write<br />;	100 read-only, do not modify file's last-access time<br />;       set bit 14 - commit file after every write operation<br /><br />        mov     bx,100000000000010b         ; access mode (R/W) and commit<br />                                            ; file after every write<br />        <br />; Bitfields for Windows 95 long-name open action: DX Register<br />; Bit(s)	Description	(Table 01781)<br />;  0	open file (fail if file does not exist)<br />;  1	truncate file if it already exists (fail if file does not exist)<br />;  4	create new file if file does not already exist (fail if exists)<br />; Note:	the only valid combinations of multiple flags are bits 4&amp;0 and 4&amp;1<br /><br />        mov     dx,1              ; open file<br />        lea     si,storage        ; sets the file name<br />        int     21h<br />        mov     bx,ax             ; save file handle<br />        push    bx<br /><br />        mov     ax,5701h ; change file date<br />                         ; BITS 5-10 are minutes, 11-15 are hours<br />        mov     cx,677dh ; 12:59:58 pm  110011101111101b     <br />                         ;<br />                         ; BITS 0-4 are day, 5-8 are month, 9-15 (year -<br />1980)<br />        mov     dx,021h  ; 1/1/80    0000000000100001b<br />        int     21h<br /><br />        pop     bx  <br /><br />;INT 21 U - DOS 4.0+ - COMMIT FILE<br />;	AH = 6Ah<br />;	BX = file handle<br />      <br />        mov     ah,6ah<br />        int     21h	 <br />        int     3<br /><br />        mov     ah,3eh   ; close file<br />        int     21h<br />   <br />; INT 21 - Windows95 - LONG FILENAME - DELETE FILE<br />;           AX = 7141h<br />;           DS:DX -&gt; ASCIZ long name of file to delete<br /><br /><br />             mov          dx,offset storage    ; delete file<br />             mov          ax,7141h             <br />             xor          si,si<br />             int          21h<br />             <br />             xor          ax,ax                ; Zero out file_name<br />             mov          di,offset storage + 2<br />             mov          cx,150<br />             repnz        stosb                   <br /><br /><br />finito:<br />             mov          ah,9               <br />             mov          dx,offset done_msg <br />             int          21h<br />             mov          ax,4c00h           ; Set errorlevel to 0<br />             int          21h<br /><br />error:<br />             mov          ah,9                <br />             int          21h<br />             mov          ax,4c01h           ; Set errorlevel to 1<br />             int          21h<br /><br />ERROR_EXIT:				; Print Error Message and Exit<br /><br />        lea     dx, NO_PARMS      ; are no parameters passed<br />	mov	ah,9			; Display error header<br />	int	21h<br />        mov     ax,4c01h<br />        int     21h<br /><br /><br />end     start</div>
    <div class="meta">Posted on 2003-09-05 08:29:26 by skywalker</div>
   </div>
   <div class="post" id="post-117127">
    <div class="subject"><a href="#post-117127">Storing command line in an .exe</a></div>
    <div class="body">You are accessing the command line with the wrong segment. Use the initial value of DS.</div>
    <div class="meta">Posted on 2003-09-05 16:16:47 by Sephiroth3</div>
   </div>
   <div class="post" id="post-117145">
    <div class="subject"><a href="#post-117145">Storing command line in an .exe</a></div>
    <div class="body">You are accessing the command line with the wrong segment. Use the initial value of DS.<br /><br />What exactly do you mean. <br /><br />model small<br />stack 200h<br /><br />data? ; can contain ONLY un-initialized data<br /><br />random db 64000 dup(?)<br /><br />data<br /><br />handle dw ?<br />file_size dd ?<br />name_size dw ?<br /><br />prompt db 13,10,13,10,9,'File Shredder Ver. 1e',13,10<br />db 13,10,'This file will NOT be recoverable !!',13,10<br />db 13,10,'File name to SHRED --&gt; $'<br /><br />not_there db 13,10,13,10,'File not present.',13,10,'$'<br />emsg2 db 13,10,13,10,'Error moving file pointer.',13,10,'$'<br />emsg3 db 13,10,13,10,'Error writing to file.',13,10,'$'<br /><br />NO_PARMS db 13,10,13,10,'Nothing on command line.',13,10,13,10,'$'<br />VALID_IN db 'abcdefghijklmnopqrstuvwxyz,;=',9<br />VALID_OUT db 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',4 dup(32)<br />VALID_NUM equ $ - VALID_OUT + 1<br /><br />done_msg db 13,10,13,10,'File has been shredded.',13,10,'$'<br />prescence db 'Andrew Kennedy 2003'<br /><br />n db 'file'<br />file_name db 128 dup(?) ; DOS maximum path length<br />storage db 150 dup(?)<br />eraser_name db '????????.',0<br /><br />code<br /><br />start:<br />mov ah,15 ; clear the screen<br />int 10h<br />mov ah,0<br />int 10h<br /><br /><br />mov ax,@data<br />mov ds,ax<br />mov es,ax ; need for LFN functions</div>
    <div class="meta">Posted on 2003-09-05 19:26:03 by skywalker</div>
   </div>
   <div class="post" id="post-117154">
    <div class="subject"><a href="#post-117154">Storing command line in an .exe</a></div>
    <div class="body"><div class="quote"><br />You are accessing the command line with the wrong segment. Use the initial value of DS.<br /><br />What exactly do you mean. <br /><br />model small<br />; ......<br />code<br /><br />start:<br />mov ah,15 ; clear the screen<br />int 10h<br />mov ah,0<br />int 10h<br /><br />mov ax,@data<br />mov ds,ax<br />mov es,ax ; need for LFN functions </div>When a DOS EXE starts up, DS and ES point to the PSP to give you access to the command line arguments just like in a COM file. Here you change both DS and ES to your new data segment before you get a chance to access your command arguments.</div>
    <div class="meta">Posted on 2003-09-05 20:17:20 by tenkey</div>
   </div>
  </div>
 </body>
</html>