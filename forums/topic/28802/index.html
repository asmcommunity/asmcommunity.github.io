<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>OOP Implementation - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=28802" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=28802">OOP Implementation</a></p>
   <div class="post" id="post-203524">
    <div class="subject"><a href="#post-203524">OOP Implementation</a></div>
    <div class="body">Hi,<br />I don&#039;t know if this belongs here. If not please move or delete it ;)<br /><br />I have a question.. I&#039;m writing a compiler myself and I got a simple base now like calling API functions, variables, arrays and so on. Now I want to take it a step further and implement OOP but I have one big problem.. I guess I don&#039;t get the point how this should work. When I take a look at ObjAsm to figure out how this works I just end up totally confused. I think its because I am confused by all these macros and cannot figure it out how all this works together. Does someone know where I could find some simple explanation how things work or some technical documentation on OOP?<br /><br />I came up in my mind with a solution myself.. it would work but I don&#039;t think it is called OOP &quot;standard&quot;<br /><br />my idea was:<br /><br />for example we have the class DOG<br /><br /><pre><code>class Dog<br />color dword<br /><br />func bark()<br />end class</code></pre><br /><br />now this is compiled as template and linked to the pe file<br />if then you would do<br /><br /><pre><code>x new dog</code></pre><br /><br />the mem sizeofclassdog would be allocated<br />the variables would be go first to this memblock by copymemory from codesection<br />and then the bark function would be copied to mem<br />dog.color.addr would have now address from mem stored and if dog.color is accsessed it modifies memory<br />dog.bark.addr also address of mem would now be used for<br />x.bark<br /><br />but I see the problem when<br /><br /><pre><code>func bark()<br /> color = 2<br />end func</code></pre><br /><br />would happen... because.. now.. some mov ,2 would happen...<br />so I decided.. this must be the wrong way....<br /><br />I would be pleased if some smart mind could give me just some simple examples how to create a simple class in mem<br />how to format and some baisc code maybe even if in assembler if I get the raw idea I think I could finally get it..<br /><br />Thanks for reading,<br />Emod</div>
    <div class="meta">Posted on 2007-11-08 18:02:44 by Emod</div>
   </div>
   <div class="post" id="post-203526">
    <div class="subject"><a href="#post-203526">Re: OOP Implementation</a></div>
    <div class="body">you should first separate few points of OOP:<br /><br />1. objects<br />2. automatic resource freeing<br />3. structured exception handling<br /><br />each of these is a separate issue.<br /><br />1: <br />Each object can have data and methods. Methods that are not virtual (can&#039;t be overloaded) can be called as normal functions. Virtual (overloadable) methods must be pointed by vtab (virtual table). Virtual table is array of pointers to methods. <br /><br />Each class with virtual methods has it&#039;s virtual table. If object has some virtual methods, then very first (hidden from programmer) variable is pointer to class&#039;s virtual table. This pointer can be also used as run-time type info, because it is unique for every class. If object has some data, they are following the pointer to virtual table.<br /><br />If class X inherits class Y, then both object of X and virtual table of X must be compatible with that of Y&#039;s. That means, order of things (variables and pointers to virtual methods) must be same. Of course, there can be more data and methods added at the end by X, that is the point of inheritance.<br /><br />When calling virtual method, you must load pointer to according function (method) for your object from virtual table it points to.<br /><br />2: Simply, your compiler has to detect all resource aquisition, and automatically insert code for resource freeing at all appropriate places (including throwing exception). <br /><br />3: This is a big topic itself, and there are many ways to do it, all have some advantages and disadvantages. I won&#039;t discuss it now much.</div>
    <div class="meta">Posted on 2007-11-08 19:48:07 by vid</div>
   </div>
   <div class="post" id="post-203527">
    <div class="subject"><a href="#post-203527">Re: OOP Implementation</a></div>
    <div class="body">Thanks vid helped me a lot espacially the tip with the virtual table. I did not have any clue about this before. Guess I will have a deeper look in this topic and look for more information on this. I hope I can figure a way out.</div>
    <div class="meta">Posted on 2007-11-09 01:13:08 by Emod</div>
   </div>
   <div class="post" id="post-203529">
    <div class="subject"><a href="#post-203529">Re: OOP Implementation</a></div>
    <div class="body"><strong>Emod:</strong> C++ has a &quot;thiscall&quot; calling convention for member functions. The standard on x86 is to load &quot;this&quot; (ie., pointer to the object instance) into ECX. Then you reference all data through ECX+offset instead of static offsets.<br /></div>
    <div class="meta">Posted on 2007-11-09 06:51:33 by f0dder</div>
   </div>
   <div class="post" id="post-203530">
    <div class="subject"><a href="#post-203530">Re: OOP Implementation</a></div>
    <div class="body">Well let me tell what I got so far from reading. I did not know anything about all this before and how this must be handled by compiler I just <u>used</u> classes before.<br /><br />Reading about Virtual Table always ended up in COM Objects where I think I understand. you just have an IUnknown interface getting the first 3 dwords which are pointers to 3 function queryinteface addref and release so you must call ptr to ptr.. and.. whatever maybe then you get the interface or something. I stopped reading at this point because I was totally confused. Ok if I use a vtable for <u>classes</u> I think its something totally different? isn&#039;t it? I just have to do my own table without the QueryInterface and all this stuff but the principle should be the same? or does every class need such a vtable then so that he accesses all functions and data of the class through this inteface?<br /><br />hmm f0dder did you mean something like<br /><br /><pre><code>class dog<br />dword color<br />func changecol<br />this.color = 2<br />end func<br />end class</code></pre><br /><br />?</div>
    <div class="meta">Posted on 2007-11-09 08:05:13 by Emod</div>
   </div>
   <div class="post" id="post-203531">
    <div class="subject"><a href="#post-203531">Re: OOP Implementation</a></div>
    <div class="body">some examples:<br /><br />this is some OOP pseudocode:<br /><pre><code><br />class a<br />{<br /> &nbsp;method m1();<br /> &nbsp;virtual method m2();<br /> &nbsp;virtual method m3();<br /> &nbsp;int data1;<br />}<br />class b inherits a<br />{<br /> &nbsp;overloaded method m2();<br /> &nbsp;overloaded method m3();<br /> &nbsp;method m4();<br /> &nbsp;virtual method m5();<br /> &nbsp;int data2;<br />}<br /></code></pre><br /><br />in pseudo assembly:<br /><pre><code><br />;method a::m1()<br />proc a__m1 &nbsp;...<br /><br />;method a::m2()<br />proc a__m2 &nbsp;...<br /><br />;method b::m2()<br />proc b__m2 &nbsp;...<br /><br />;method a::m3()<br />proc a__m3 &nbsp;...<br /><br />;method b::m3()<br />proc b__m3 &nbsp;...<br /><br />;method b::m4()<br />proc b__m4 &nbsp;...<br /><br />;method b::m5()<br />proc b__m5 &nbsp;...<br /><br />;virtual table for a<br />a__vtab: <br /> &nbsp;dd a__m2 &nbsp; ;pointer to implementation of method m2<br /> &nbsp;dd a__m3 &nbsp; ;pointer to implementation of method m3<br /><br />;virtual table for b<br />b__vtab:<br /> &nbsp;dd b__m2<br /> &nbsp;dd b__m3<br /> &nbsp;dd b__m5 &nbsp; <br /><br />;instance &quot;foo&quot; of class &quot;a&quot;<br />foo:<br />dd a__vtab &nbsp;;pointer to vtab<br />dd 10 &nbsp; ;value of data1 member<br /><br />;instance &quot;bar&quot; of class &quot;b&quot;<br />bar:<br />dd b__vtab &nbsp;;pointer to vtab<br />dd 10 &nbsp; ;value of data1 member<br />dd 15 &nbsp; ;value of data2 member<br /><br />;calling non-virtual method foo.m1()<br />mov ecx, foo<br />call a__m1<br /><br />;calling foo.m3()<br />mov ecx, foo<br />mov eax, dword ptr  &nbsp; ;eax = address of virtual table<br />call dword ptr  &nbsp;;call pointer from virtual table<br /><br />;calling bar.m3() - same as previous<br />mov ecx, bar<br />mov eax, dword ptr  &nbsp; ;eax = address of virtual table<br />call dword ptr  &nbsp;;call pointer from virtual table<br /></code></pre><br />As you can see the last 2 pieces of code, calling of virtual method for instance of class a, is same as calling virtual method for instance class b. That is because class b inherited class a, and everything that is in class a object, is also in class b object, and in same order. <br /><br />That means you can write procedure that will work with class &quot;a&quot;, and then pass to it instance of class &quot;b&quot;, and it will work fine. That procedure doesn&#039;t have to know anything about class &quot;b&quot;, and still you can use it with it. This is one of most important points of OOP.</div>
    <div class="meta">Posted on 2007-11-09 08:09:16 by vid</div>
   </div>
   <div class="post" id="post-203532">
    <div class="subject"><a href="#post-203532">Re: OOP Implementation</a></div>
    <div class="body">Wow, genius! :shock: thank you that&#039;s some great and simple code! Thanks for this piece I will study it and see what I can get and make of it. I&#039;ll let you know. Thanks for taking the time to write this down and helping me!</div>
    <div class="meta">Posted on 2007-11-09 08:18:43 by Emod</div>
   </div>
   <div class="post" id="post-203533">
    <div class="subject"><a href="#post-203533">Re: OOP Implementation</a></div>
    <div class="body">yes, the way is very similar to COM objects. Of course, all COM objects inherited IUnknown with it&#039;s 3 methods, but you can use same idea and not inherit IUnknown.<br /><br /><div class="quote">Ok if I use a vtable for classes I think its something totally different? isn&#039;t it?</div><br />no, COM used vtable only for classes too. When you get an object instance, first member is pointer to vtable. There is only one vtable per object. Data are contained in object instance, along with pointer to vtable, not in vtable.<br /><br />Try it yourself: allocate two instances of same COM class, and compare it&#039;s pointers (first dword). You will see it is same<br /><br />Data (member variabes) are stored in object instance, so every object can have different values of them. But methods are same for every instance of same class, so storing pointers to methods in object instance would be unscessary wasting of memory. For that reason, they are stored in single place, in virtual table, and object instance just holds pointer to that virtual table.<br /><br />In COM objects, every single method was in virtual table. That is because COM was used for inter-language and inter-process communication. In case when you don&#039;t need this, you only must place virtual (overloadable) methods to virtual table. Others methods can be can be called directly as procedures.<br /><br />Reason why virtual procedures must be placed in virtual table can be seen in my previous example. Imagine some procedure which works with class &quot;a&quot; objects. You can pass both instance of class &quot;a&quot; or instance of class &quot;b&quot; to it. If such procedure wants to call method m2(), it should call &quot;a__m2&quot; if object is instance of class &quot;a&quot;, and it should call &quot;b__m2&quot; if object is instance of class &quot;b&quot;. This is easily accomplished by placing pointers into virtual table.<br /><br />Hope i didn&#039;t confuse you too much :)<br /><br />PS: I updated the example code, there was slight mistake in it</div>
    <div class="meta">Posted on 2007-11-09 08:23:36 by vid</div>
   </div>
  </div>
 </body>
</html>