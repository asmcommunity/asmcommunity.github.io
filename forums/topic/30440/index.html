<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>I cant get this code worked!!  - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30440" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=30440">I cant get this code worked!! </a></p>
   <div class="post" id="post-213900">
    <div class="subject"><a href="#post-213900">I cant get this code worked!! </a></div>
    <div class="body">hi,<br /><br />There is a source code about windows services on Iczelion&#039;s web page, named &quot;beepserv&quot;.<br />I tried to run that code but it didnt work. <br />Each time I run &quot;beepserv.exe&quot;, StartServiceCtrlDispatcher function returns zero, that is, it gives error.<br />How will I get it run properly?<br /><br />Here is the code:<br /><br />beepserv.asm<br /><pre><code><br /><br />.386<br />.model flat,stdcall<br />include&nbsp; &nbsp;  windows.inc<br />include&nbsp; &nbsp;  kernel32.inc<br />include&nbsp; &nbsp;  user32.inc<br />include&nbsp; &nbsp;  advapi32.inc<br />include&nbsp; &nbsp;  beepserv.inc<br /><br />;Why doesn&#039;t C/C++ have<br />;this feature<br />includelib&nbsp; advapi32.lib<br />includelib&nbsp; kernel32.lib<br />includelib&nbsp; user32.lib<br /><br />;just a space saving macro<br />LOAD MACRO&nbsp; dest, src<br />&nbsp;  mov eax, src<br />&nbsp;  mov dest, eax<br />ENDM<br /><br />.data<br />;The name of the service<br />SERVICE_NAME&nbsp; &nbsp; &nbsp;  BYTE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;BeepService&quot;,0<br />;The beep interval in ms.<br />Delay&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dd&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  2000<br /><br />;Flags holding current state of service<br />fPaused&nbsp; &nbsp; &nbsp;  BOOL&nbsp; &nbsp; &nbsp; &nbsp;  FALSE<br />fRunning&nbsp; &nbsp;  BOOL&nbsp; &nbsp; &nbsp; &nbsp;  FALSE<br /><br />szBuffer&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  db&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  MAX_PATH dup(0)<br />ERROR_MESSAGE&nbsp; &nbsp; &nbsp; db&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &quot;In StartServiceCtrlDispatcher&quot;,0<br /><br />;Thread for the actual work<br />hThread&nbsp; &nbsp; &nbsp;  HANDLE&nbsp; &nbsp; &nbsp;  NULL<br /><br />;Event used to hold ServiceMain from completing<br />evTerminate&nbsp; &nbsp;  HANDLE&nbsp; &nbsp; &nbsp;  NULL<br /><br /><br />.data?<br />;Handle used to communicate status info with<br />;the SCM. Created by RegisterServiceCtrlHandler<br />hStatus DWORD&nbsp; &nbsp; &nbsp;  ?<br />sStatus&nbsp;  SERVICE_STATUS&nbsp;  &lt;&gt;<br />;<br />sTable&nbsp;  SERVICE_TABLE_ENTRY&nbsp;  &lt; 0, 0 &gt;<br />;This next one is unused but here for the zeros<br />;Because the table must be null terminated.<br />;Each exe can contain multiple services<br />;just add them here as tables.<br />sTable2&nbsp;  SERVICE_TABLE_ENTRY&nbsp;  &lt; 0, 0 &gt;<br /><br /><br />.code<br />start:<br />&nbsp;  ;Register with the SCM<br />&nbsp;  mov&nbsp; sTable.lpServiceProc, offset ServiceMain<br />&nbsp;  LOAD sTable.lpServiceName, offset SERVICE_NAME<br />&nbsp;  INVOKE StartServiceCtrlDispatcher, ADDR sTable<br /><br />&nbsp;  .IF eax == 0<br />&nbsp; &nbsp; &nbsp; INVOKE ErrorHandler, ADDR ERROR_MESSAGE<br />&nbsp;  .ENDIF<br /><br />&nbsp;  INVOKE ExitProcess, eax<br /><br />;This is the function that does all of the<br />;work.&nbsp; In our case we beep (ohhh exciting).<br />;But much more productive work could be done<br />;here. ;)<br />Thread proc param:DWORD<br />&nbsp;  INFINITE_LP:<br />&nbsp; &nbsp; &nbsp; INVOKE Beep, 200, 200<br />&nbsp; &nbsp; &nbsp; INVOKE Sleep, Delay<br />&nbsp;  jmp INFINITE_LP<br />&nbsp;  xor eax, eax<br />&nbsp;  ret<br />Thread endp<br /><br /><br />;Initializes the service by starting its thread<br />Init proc<br />&nbsp;  LOCAL id:DWORD<br />&nbsp;  INVOKE CreateThread, 0, 0, Thread, 0, 0, ADDR id<br />&nbsp;  mov&nbsp; hThread, eax<br />&nbsp;  .IF eax != 0<br />&nbsp; &nbsp; &nbsp; mov&nbsp; fRunning, 1<br />&nbsp; &nbsp; &nbsp; mov&nbsp; eax, 1<br />&nbsp;  .ENDIF<br />&nbsp;  ret<br />Init endp<br /><br />;Resumes a paused service<br />Resume proc<br />&nbsp;  mov&nbsp; fPaused, FALSE<br />&nbsp;  INVOKE ResumeThread, hThread<br />&nbsp;  ret<br />Resume endp<br /><br />;Pauses the service<br />Pause proc<br />&nbsp;  mov fPaused, TRUE<br />&nbsp;  INVOKE SuspendThread, hThread<br />&nbsp;  ret<br />Pause endp<br /><br /><br />;Stops the service by allowing ServiceMain to<br />;complete<br />Stop proc<br />&nbsp;  mov fRunning, FALSE<br />&nbsp;  ;This will release ServiceMain<br />&nbsp;  INVOKE SetEvent, evTerminate<br />&nbsp;  ret<br />Stop endp<br /><br /><br /><br />ErrorHandler proc err:DWORD<br />&nbsp;  INVOKE MessageBoxA, NULL, ADDR szBuffer, ADDR SERVICE_NAME, MB_OK or MB_ICONERROR<br />&nbsp;  INVOKE ExitProcess, err<br />&nbsp;  ret<br />ErrorHandler endp<br /><br />;This function consolidates the activities of<br />;updating the service status with<br />;SetsStatus.&nbsp; More overhead for the programmer<br />;because Micro$oft doesn&#039;t make quality code.<br />SendStatus proc dwCurrentState:DWORD, dwWin32ExitCode:DWORD,&nbsp; \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dwServiceSpecificExitCode:DWORD, dwCheckPoint:DWORD, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dwWaitHint:DWORD<br />&nbsp;  LOCAL success:BOOL<br /><br />&nbsp;  mov sStatus.dwServiceType, SERVICE_WIN32_OWN_PROCESS<br />&nbsp;  LOAD sStatus.dwCurrentState, dwCurrentState<br />&nbsp;  .IF dwCurrentState == SERVICE_START_PENDING<br />&nbsp; &nbsp; &nbsp; mov sStatus.dwControlsAccepted, 0<br />&nbsp;  .ELSE<br />&nbsp; &nbsp; &nbsp; mov sStatus.dwControlsAccepted, \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SERVICE_ACCEPT_STOP or \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SERVICE_ACCEPT_PAUSE_CONTINUE or \<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SERVICE_ACCEPT_SHUTDOWN<br />&nbsp;  .ENDIF<br />&nbsp;  .IF dwServiceSpecificExitCode == 0<br />&nbsp; &nbsp; &nbsp; LOAD sStatus.dwWin32ExitCode, dwWin32ExitCode<br />&nbsp;  .ELSE<br />&nbsp; &nbsp; &nbsp; mov sStatus.dwWin32ExitCode, \<br />&nbsp; &nbsp; &nbsp; &nbsp;  ERROR_SERVICE_SPECIFIC_ERROR<br />&nbsp;  .ENDIF<br /><br />&nbsp;  LOAD sStatus.dwServiceSpecificExitCode, dwServiceSpecificExitCode<br />&nbsp;  LOAD sStatus.dwCheckPoint, dwCheckPoint<br />&nbsp;  LOAD sStatus.dwWaitHint, dwWaitHint<br /><br />&nbsp;  ;Pass the status record to the SCM<br />&nbsp;  INVOKE SetServiceStatus, hStatus, ADDR sStatus<br />&nbsp;  mov eax, 1<br />&nbsp;  ret<br />SendStatus endp<br /><br /><br />;Dispatches events received from the service<br />;control manager<br />CtrlHandler proc controlCode:DWORD<br />&nbsp;  LOCAL currentState:DWORD<br />&nbsp;  LOCAL success:BOOL<br /><br />&nbsp;  mov&nbsp;  currentState,&nbsp; &nbsp; &nbsp; 0<br />&nbsp;  mov&nbsp;  eax, controlCode<br /><br />&nbsp;  .IF eax == SERVICE_CONTROL_STOP<br />&nbsp; &nbsp; &nbsp; LOAD currentState, SERVICE_STOP_PENDING<br />&nbsp; &nbsp; &nbsp; ;Tell the SCM what&#039;s happening<br />&nbsp; &nbsp; &nbsp; INVOKE SendStatus, SERVICE_STOP_PENDING, NO_ERROR, 0, 1, 5000<br />&nbsp; &nbsp; &nbsp; ;Not much to do if not successful<br />&nbsp; &nbsp; &nbsp; ;Stop the service<br />&nbsp; &nbsp; &nbsp; call Stop<br />&nbsp; &nbsp; &nbsp; ret<br /><br />&nbsp;  ;Pause the service<br />&nbsp;  .ELSEIF eax == SERVICE_CONTROL_PAUSE<br />&nbsp; &nbsp; &nbsp; .IF fRunning != 0 &amp;&amp; fPaused == 0<br />&nbsp; &nbsp; &nbsp; &nbsp;  ;Tell the SCM what&#039;s happening<br />&nbsp; &nbsp; &nbsp; &nbsp;  INVOKE SendStatus, SERVICE_PAUSE_PENDING, NO_ERROR, 0, 1, 1000<br />&nbsp; &nbsp; &nbsp; &nbsp;  call Pause<br />&nbsp; &nbsp; &nbsp; &nbsp;  mov&nbsp; currentState, SERVICE_PAUSED;<br />&nbsp; &nbsp; &nbsp; &nbsp;  jmp SCHandler<br />&nbsp; &nbsp; &nbsp; .ENDIF<br /><br />&nbsp;  ;Resume from a pause<br />&nbsp;  .ELSEIF eax == SERVICE_CONTROL_CONTINUE<br />&nbsp; &nbsp; &nbsp;  .IF fRunning != 0 &amp;&amp; fPaused == 0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Tell the SCM what&#039;s happening<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INVOKE SendStatus, SERVICE_CONTINUE_PENDING, NO_ERROR, 0, 1, 1000<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call Resume<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov currentState, SERVICE_RUNNING<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jmp SCHandler<br />&nbsp; &nbsp; &nbsp;  .ENDIF<br /><br />&nbsp;  ;Update current status<br />&nbsp; .ELSEIF eax == SERVICE_CONTROL_INTERROGATE<br />&nbsp; &nbsp;  ;it will fall to bottom and send status<br />&nbsp; &nbsp;  ;Do nothing in a shutdown. Could do cleanup<br />&nbsp; &nbsp;  ;here but it must be very quick.<br /><br />&nbsp; .ELSEIF eax == SERVICE_CONTROL_SHUTDOWN<br />&nbsp; &nbsp;  ;Do nothing on shutdown<br />&nbsp; &nbsp; &nbsp; ret<br /><br />&nbsp; .ENDIF<br /><br /> SCHandler:<br />&nbsp; &nbsp;  INVOKE SendStatus, currentState, NO_ERROR, 0, 0, 0<br />&nbsp; &nbsp;  ret<br />CtrlHandler endp<br /><br />;Handle an error from ServiceMain by cleaning up<br />;and telling SCM that the service didn&#039;t start.<br />terminate proc error:DWORD<br /><br />&nbsp;  ;if evTerminate has been created, close it.<br />&nbsp;  .IF evTerminate != 0<br />&nbsp; &nbsp; &nbsp; push evTerminate<br />&nbsp; &nbsp; &nbsp; call CloseHandle<br />&nbsp;  .ENDIF<br /><br />&nbsp; &nbsp; ;Send a message to the scm to tell about<br />&nbsp; &nbsp; ;stopage<br />&nbsp;  .IF hStatus != 0<br />&nbsp; &nbsp; &nbsp;  INVOKE SendStatus, SERVICE_STOPPED, error, 0, 0, 0<br />&nbsp;  .ENDIF<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ;If the thread has started kill it off<br />&nbsp; &nbsp; .IF hThread != 0<br />&nbsp; &nbsp; &nbsp; push hThread<br />&nbsp; &nbsp; &nbsp; call CloseHandle<br />&nbsp;  .ENDIF<br /><br />&nbsp;  ;Do not need to close hStatus<br />terminate endp<br /><br /><br />;ServiceMain is called when the SCM wants to<br />;start the service. When it returns, the service<br />;has stopped. It therefore waits on an event<br />;just before the end of the function, and<br />;that event gets set when it is time to stop.<br />;It also returns on any error because the<br />;service cannot start if there is an eror.<br />ServiceMain proc argc:DWORD, argv:DWORD<br />&nbsp;  LOCAL success:BOOL<br />&nbsp;  LOCAL temp:DWORD<br /><br />&nbsp;  ;immediately call Registration function<br />&nbsp;  INVOKE RegisterServiceCtrlHandler, ADDR SERVICE_NAME,&nbsp; CtrlHandler<br />&nbsp;  mov&nbsp; hStatus, eax<br /><br />&nbsp;  .IF eax == 0<br />&nbsp; &nbsp; &nbsp; call GetLastError<br />&nbsp; &nbsp; &nbsp; push eax<br />&nbsp; &nbsp; &nbsp; call terminate<br />&nbsp; &nbsp; &nbsp; ret<br />&nbsp;  .ENDIF<br /><br />&nbsp;  ;Notify SCM of progress<br />&nbsp;  INVOKE SendStatus, SERVICE_START_PENDING, NO_ERROR, 0, 1, 5000<br /><br />&nbsp;  ;create the termination event<br />&nbsp;  INVOKE CreateEvent, 0, TRUE, FALSE, 0<br />&nbsp;  mov evTerminate, eax<br /><br />&nbsp;  .IF eax == 0<br />&nbsp; &nbsp; &nbsp; call GetLastError<br />&nbsp; &nbsp; &nbsp; push eax<br />&nbsp; &nbsp; &nbsp; call terminate<br />&nbsp; &nbsp; &nbsp; ret<br />&nbsp;  .ENDIF<br /><br />&nbsp;  ;Notify SCM of progress<br />&nbsp;  INVOKE SendStatus, SERVICE_START_PENDING, NO_ERROR, 0, 2, 1000<br /><br />&nbsp;  ;Notify SCM of progress<br />&nbsp;  INVOKE SendStatus, SERVICE_START_PENDING, NO_ERROR, 0, 3, 5000<br /><br />&nbsp;  ;Start the service itself<br />&nbsp;  call Init<br />&nbsp;  mov success, eax<br />&nbsp;  .IF eax == 0<br />&nbsp; &nbsp; &nbsp; call GetLastError<br />&nbsp; &nbsp; &nbsp; push eax<br />&nbsp; &nbsp; &nbsp; call terminate<br />&nbsp; &nbsp; &nbsp; ret<br />&nbsp;  .ENDIF<br /><br />&nbsp;  ;Notify SCM of progress<br />&nbsp;  INVOKE SendStatus, SERVICE_RUNNING, NO_ERROR, 0, 0, 0<br /><br />&nbsp;  ;Wait for stop signal, and then terminate<br />&nbsp;  INVOKE WaitForSingleObject, evTerminate, INFINITE<br />&nbsp;  push 0<br />&nbsp;  call terminate<br />&nbsp;  ret<br /><br />ServiceMain endp<br /><br />end start<br /><br /><br /><br /><br /></code></pre></div>
    <div class="meta">Posted on 2011-01-14 16:28:22 by hakand</div>
   </div>
  </div>
 </body>
</html>