<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Some GFX advice.. - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=5167" />
  <link rel="prev" href="../?id=5167&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=5167">Some GFX advice..</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=5167&amp;page=1" style="">&laquo;</a><a href="../?id=5167&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="5167" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-36673">
    <div class="subject"><a href="#post-36673">Some GFX advice..</a></div>
    <div class="body"><div class="quote"><br />What is &quot;Only loose 4 bits - instead of 6&quot; mean?</div>This means that one extra bit of each source is preserved, but would only be noticable is certain situations: performing several blend operations on a primary colored gradient.  Remember we are talking about 24 million colors here and the two extra preserved bits are least-significant.</div>
    <div class="meta">Posted on 2002-05-05 13:58:32 by bitRAKE</div>
   </div>
   <div class="post" id="post-36676">
    <div class="subject"><a href="#post-36676">Some GFX advice..</a></div>
    <div class="body">The purpose of the shifting is allow the signed multiply to use all the bits of the alpha as unsigned data - each resulting word of the alpha registers (registers MM4/5 in the algo above) is transformed into ALPHA*128.  This leaves the top bit clear - preserving the sign of (DEST - SOURCE) for the signed addition.<br /><br />This code is untested and you can easily unroll the code to do four pixel in one loop for more speed. :)<pre><code>SolidAlphaBlend PROC buff&#58;DWORD, len&#58;DWORD, color&#58;DWORD<br />	mov eax,buff<br />	mov ecx,len ; number of pixels<br />	shr ecx,1<br />	dec ecx<br /><br />	pxor mm7,mm7<br /><br />	movd mm6,color		; ....ARGB<br />	movq mm4,mm6		; ....ARGB<br />;	punpckldq mm6,mm6	; ARGBARGB ; no need for this! ;&#41;<br /><br />	psrlw mm4,1			; ....VW..<br />	punpcklwd mm4,mm4	; VWVW....<br />	punpckhdq mm4,mm4	; VWVWVWVW<br />; mm4 = &#123;each word alpha*128&#125;<br />;	movq mm3,mm6 ; code fat be gone... ;&#41;<br />;	punpcklbw mm1,mm7 ; no need for this &#58;&#41;<br />	punpcklbw mm6,mm7 ; low bytes! &#58;P<br /><br />; mm3 = unpacked color<br />; mm7 = 0<br />@@&#58;<br />	movq mm0,&#91;eax+ecx*8&#93;<br />	dec ecx<br />	movq mm2,mm0		; FEDCBA98<br />	punpcklbw mm0,mm7	; .E.C.A.8<br />	punpckhbw mm2,mm7	; .F.D.B.9<br />	psubsw mm0,mm6<br />	psubsw mm2,mm6<br />	psllw mm0,1<br />	psllw mm2,1<br />	pmulhw mm0,mm4<br />	pmulhw mm2,mm4<br />	paddsw mm0,mm6<br />	paddsw mm2,mm6<br />	packuswb mm0,mm2<br />	movq &#91;eax+ecx*8&#93;,mm0<br />	jnz @B<br /><br />	ret<br />SolidAlphaBlend ENDP</code></pre>The explaination is hard to do in few words - would be better to read the other thread where the algo developed (<a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=2595">HERE</a>).  You'll also see <strong>E?in</strong>'s work on the algo and he presents an alternate for non-MMX CPU's at the top.</div>
    <div class="meta">Posted on 2002-05-05 14:08:36 by bitRAKE</div>
   </div>
   <div class="post" id="post-36712">
    <div class="subject"><a href="#post-36712">Some GFX advice..</a></div>
    <div class="body">Thank you for your willingness to help.  I think i now understand and will walk thu what i think is happening correct me if this is wrong (but i do get a solution, so i think i got it):<pre><code>SolidAlphaBlend PROC buff&#58;DWORD, len&#58;DWORD, color&#58;DWORD<br />	mov eax,buff<br />	mov ecx,len ; number of pixels<br />	shr ecx,1<br />	dec ecx<br /><br />	pxor mm7,mm7<br /><br />	movd mm6,color		; ....ARGB<br />	movq mm4,mm6		; ....ARGB<br />	punpckldq mm6,mm6	; ARGBARGB</code></pre><br />	psrlw mm4,1			; ....VW..</code></pre><br />Divide the unpacked data by two to get effectively Alpha*256/2 + Blue*2, or the 128*Alpha your getting at.<pre><code><br />	punpcklwd mm4,mm4	; VWVW....	punpckhdq mm4,mm4	; VWVWVWVW<br />; mm4 = &#123;each word alpha*128&#125;</code></pre><br />This *is* 128 times the A char + Blue/2, now copied into all four word locations.<pre><code><br />	movq mm3,mm6<br />&#91;b&#93;	punpcklbw mm1,mm7&#91;/b&#93;  ;??????<br />	punpckhbw mm3,mm7<br /><br />; mm3 = unpacked color<br />; mm7 = 0</code></pre><br />mm1 is undefined to start with, but the high bytes of each word is now formatted to 0. mm3 is the same but now: .A.B.G.R, ok.<pre><code><br />@@&#58;<br />	movq mm0,&#91;eax+ecx*8&#93;<br />	dec ecx<br />	movq mm2,mm0		; FEDCBA98<br />	punpcklbw mm0,mm7	; .E.C.A.8<br />	punpckhbw mm2,mm7	; .F.D.B.9<br />	psubsw mm0,mm3<br />	psubsw mm2,mm3<br /></code></pre><br />Ok, 8 bytes (two pixels) are read, and unpacked into words over two mmx registers.  Then the difference is found between each unpacked values (A-a),(B-b),(G-g),(R-r) for the two pixels vs. the set blend 'rgb' color.<pre><code><br />	psllw mm0,1<br />	psllw mm2,1</code></pre><br />Now multiply each unpacked difference word by 2 thru the two pixels. This is setting up for the upcomming code.<pre><code><br />	pmulhw mm0,mm4<br />	pmulhw mm2,mm4</code></pre><br />Ok, now each unpacked word component for ARGB of each pixel is multiplied by:<br /> [ 2*(R-r) ] *[ 128*Alpha + Blue/2 ] == [(R-r)*Alpha*256 + (R-r)*Blue].<br /> <br />This command also takes the upper word of the dword result. This totaly ignores the (R-r)*Blue because 2^8 * 2^8 = 2^16 and is dropped. <br /><br />Also, if alpha == 256 the result is just (R-r).  If alpha is 0, then its 0. Alpha = 128 its (R-r)/2. And this is applied evenly thru all components of both pixels.  As i see now, this is how a percentage is found.  With a resolution of 1/256% alpha per step between 0-&gt;255.<pre><code><br />	paddsw mm0,mm3<br />	paddsw mm2,mm3</code></pre><br />Now the %(R-r) is added to the 'r' blend color to start with.  Effectively adding a percentage of the difference of the two colors as I stated in the earlier equation:  D + Alpha%(S-D) for alpha blend.<pre><code><br />	packuswb mm0,mm2<br />	movq &#91;eax+ecx*8&#93;,mm0<br />	jnz @B<br />	ret<br />SolidAlphaBlend ENDP</code></pre><br />Repack the two pixels A'B'G'R'A'B'G'R', and save them.  Then loop onto the next two pixels.<br /><br />Thanx I think i got it.... Umm i dont think the line <strong>punpcklbw mm1,mm7</strong> is used or needed tho?<br /><br />Thanx again bitRake and Eoin!<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-05-05 17:59:03 by NaN</div>
   </div>
   <div class="post" id="post-36714">
    <div class="subject"><a href="#post-36714">Some GFX advice..</a></div>
    <div class="body"><span style="font-size:24px>*lol*</span> <br /><br />I totally analysed that algo over the last couple of hours, slowly taking my post together, and i see you editted in an explaination 10 min befor i finished :grin:<br /><br />Thanx anyways!  The hard way was a good learning experience ;)<br /><br />:NaN:</div>
    <div class="meta">Posted on 2002-05-05 18:03:20 by NaN</div>
   </div>
   <div class="post" id="post-36718">
    <div class="subject"><a href="#post-36718">Some GFX advice..</a></div>
    <div class="body">Sorry, I do that a lot because I don't like making a thousand posts.  Also, note after reading your post I made three corrections to the code.  You seem to have a good grasp of it - way to go!  Look at the rigisters with some test data in Ollydbg is the best way, imho.</div>
    <div class="meta">Posted on 2002-05-05 18:09:39 by bitRAKE</div>
   </div>
   <div class="post" id="post-36733">
    <div class="subject"><a href="#post-36733">Some GFX advice..</a></div>
    <div class="body">Never used Ollydbg.  Will have to check it out. <br /><br /><br />Errors that crashed my machine *again* gave me reason to get Ollydbg sooner than i thought. :)  * I like the User Interface, but wish you can close a file without exiting, so i can recompile :rolleyes: .<br /><br />Anyways, with its help i saw an error we have both overlooked.  Well actually two, from the same source: the way the memory is being called and saved to.  You're decrementing backwards in memory (which is ok), but you start with 8 bytes beyond the bitmap boundry, and finish 8 bytes too soon when you dec/jnz in a loop.  As well, the more serious problem was that the source bytes are not 1:1 to the destination bytes, since ECX was being decremented before the MMX algo and its save point (This is what crashed the machine ~ hard ;)  )<br /><br />So here is my fix to your source and works well now.<br /><pre><code>SolidAlphaBlend PROC buff&#58;DWORD, len&#58;DWORD, color&#58;DWORD<br />	mov eax,buff<br />	mov ecx,len ; number of pixels<br />	shr ecx,1<br />	dec ecx<br /><br />	pxor mm7,mm7<br /><br />	movd mm6,color		; ....ARGB<br />	movq mm4,mm6		; ....ARGB<br /><br />	psrlw mm4,1			; ....VW..<br />	punpcklwd mm4,mm4	; VWVW....<br />	punpckhdq mm4,mm4	; VWVWVWVW<br />	punpcklbw mm6,mm7 ; low bytes! &#58;P<br /><br />     xor edx, edx<br />.while &#40;edx &lt; ecx &#41;<br />	movq mm0,&#91;eax+edx*8&#93;<br />	movq mm2,mm0		; FEDCBA98<br />	punpcklbw mm0,mm7	; .E.C.A.8<br />	punpckhbw mm2,mm7	; .F.D.B.9<br />	psubsw mm0,mm6<br />	psubsw mm2,mm6<br />	psllw mm0,1<br />	psllw mm2,1<br />	pmulhw mm0,mm4<br />	pmulhw mm2,mm4<br />	paddsw mm0,mm6<br />	paddsw mm2,mm6<br />	packuswb mm0,mm2<br />	movq &#91;eax+edx*8&#93;,mm0<br />	inc edx<br />.endw<br /><br />     ret<br />SolidAlphaBlend ENDP</code></pre><br /><br />Thanx again bitRAKE for all your help!<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-05-05 20:01:58 by NaN</div>
   </div>
   <div class="post" id="post-36739">
    <div class="subject"><a href="#post-36739">Some GFX advice..</a></div>
    <div class="body">Here is the fixed loop.<pre><code>SolidAlphaBlend PROC buff&#58;DWORD, len&#58;DWORD, color&#58;DWORD<br />	mov eax,buff<br />	mov ecx,len ; number of bytes<br />	shr ecx,3 ; &#40;4 bytes/pixel&#41; / &#40;2 bytes/loop&#41;<br /><br />	pxor mm7,mm7<br /><br />	movd mm6,color		; ....ARGB<br />	movq mm4,mm6		; ....ARGB<br />	punpcklbw mm6,mm7<br /><br />	psrlw mm4,1		; ....VW..<br />	punpcklwd mm4,mm4	; VWVW....<br />	punpckhdq mm4,mm4	; VWVWVWVW<br />	jmp _1<br /><br />	ALIGN 8<br /><br />_0&#58;	movq mm0,&#91;eax+ecx*8&#93;<br />	movq mm2,mm0		; FEDCBA98<br />	punpcklbw mm0,mm7	; .E.C.A.8<br />	punpckhbw mm2,mm7	; .F.D.B.9<br />	psubsw mm0,mm6<br />	psubsw mm2,mm6<br />	psllw mm0,1<br />	psllw mm2,1<br />	pmulhw mm0,mm4<br />	pmulhw mm2,mm4<br />	paddsw mm0,mm6<br />	paddsw mm2,mm6<br />	packuswb mm0,mm2<br />	movq &#91;eax+ecx*8&#93;,mm0<br />_1&#58;	dec ecx<br />	jns _0<br /><br />	ret<br />SolidAlphaBlend ENDP</code></pre>Unroll and interleave two loops (using two more MMX registers), then unroll again for 8 pixels in one loop, and add prefetch instruction, then your really cooking...</div>
    <div class="meta">Posted on 2002-05-05 21:47:31 by bitRAKE</div>
   </div>
   <div class="post" id="post-36820">
    <div class="subject"><a href="#post-36820">Some GFX advice..</a></div>
    <div class="body">Thanx bitRAKE, but i dont follow this 'unroll' business.  <br /><br />The is 'spare' mmx reg's, sure.  But it dont see how fetching 16 bytes and doing the process two times over in one loop, is any fanster (relatively) than fetching 8 bytes, and one process.<br /><br />They both loop, and since the MMX reg field is only 8 bytes, after this your saturated for performance savings, right?  I mean, another instruction is another instruction, weather i do two times in a loop, or one times in a loop, the same number of executions are the same??<br /><br />Thanx.<br />:NaN:</div>
    <div class="meta">Posted on 2002-05-06 10:50:24 by NaN</div>
   </div>
   <div class="post" id="post-36822">
    <div class="subject"><a href="#post-36822">Some GFX advice..</a></div>
    <div class="body">There are forward dependancies and my cacheline size is 64 bytes.  You could not unroll, but you'd need an inner/outer loop.  This is strange territory as processors become very different on what they need in the code: manual prefetch, prefetch instruction, or nothing (auto-prefetch Athlon XP/P4).</div>
    <div class="meta">Posted on 2002-05-06 10:59:19 by bitRAKE</div>
   </div>
   <div class="post" id="post-36824">
    <div class="subject"><a href="#post-36824">Some GFX advice..</a></div>
    <div class="body">Ah yes, that evil *transparent* cashe ;)<br /><br />I forgot about this.  Thanx!</div>
    <div class="meta">Posted on 2002-05-06 11:03:24 by NaN</div>
   </div>
   <div class="post" id="post-36825">
    <div class="subject"><a href="#post-36825">Some GFX advice..</a></div>
    <div class="body">On faster CPU's there will be no performance gain without prefetch - that is why FSB (front side bus) speed is so important - most software doesn't prefetch.  So, the CPU is stuck pulling data from main memory into --&gt; L2 cache --&gt; L1 cache.  P4 even has an L3 cache, iirc. :eek:</div>
    <div class="meta">Posted on 2002-05-06 11:16:32 by bitRAKE</div>
   </div>
   <div class="post" id="post-40249">
    <div class="subject"><a href="#post-40249">Some GFX advice..</a></div>
    <div class="body">hello..<br />i try to use DoAlpha() proc, but i get a white window :(<br />I've debuged, and api return values are ok. So probably the code is bad in some api param.<br /><pre><code><br />&#91;b&#93;WM_CREATE&#91;/b&#93;<br />invoke LoadBitmap,hInstance,addr BitmapName<br />mov hBitmap,eax<br />&#40;...&#41;<br />&#91;b&#93;WM_PAINT&#91;/b&#93;<br />invoke BeginPaint,hWnd,addr ps<br />mov hdc,eax<br />CALL	DoAlpha<br />invoke EndPaint,hWnd,addr ps<br /></code></pre><br /><br />Now DoAlpha() code<br /><pre><code><br />DoAlpha   PROC USES esi edi<br /> ;============================================<br />	LOCAL bm       &#58;BITMAP<br />	LOCAL bmi      &#58;BITMAPINFO<br />	LOCAL lpBits   &#58;DWORD<br />	LOCAL SDC      &#58;DWORD<br />	LOCAL OldBM    &#58;DWORD<br />	LOCAL hBm&#58;DWORD<br />	LOCAL BMDC     &#58;DWORD<br />	LOCAL hMemDC&#58;DWORD<br /><br />invoke CreateCompatibleDC,hdc<br />mov hMemDC,eax<br /><br />invoke GetObject, hBitmap, sizeof BITMAP, addr bm<br />     <br />invoke RtlZeroMemory, addr bmi.bmiHeader, sizeof BITMAPINFOHEADER<br /><br />mov eax, sizeof BITMAPINFOHEADER<br />mov bmi.bmiHeader.biSize, eax    <br />mov eax, bm.bmWidth<br />mov bmi.bmiHeader.biWidth, eax<br />mov eax, bm.bmHeight<br />neg eax<br />mov bmi.bmiHeader.biHeight, eax<br />mov bmi.bmiHeader.biPlanes, 1<br />mov bmi.bmiHeader.biCompression, BI_RGB<br />mov bmi.bmiHeader.biBitCount, 32<br />    <br />invoke CreateDIBSection, hMemDC,addr bmi, DIB_RGB_COLORS,  addr lpBits, NULL, NULL<br /><br />mov hBm, eax         ;LOCAL handle<br /><br />invoke SelectObject,hMemDC,eax<br /><br />invoke BitBlt, hMemDC, 0,0,250,250,hdc, 0,0, SRCCOPY <br /><br />     ; Do Alpha.<br />     mask_50_alpha_24 equ 0111111101111111011111111b<br />     xor edx, edx<br />     mov eax, bm.bmWidth<br />     mul bm.bmHeight<br />     mov ecx, eax<br />     mov esi, lpBits<br />     mov edi, 00FFFFFFh<br />     .while&#40; ecx &#41;<br /><br />     mov eax,&#91;esi&#93; ;get src pixel 1<br />     and eax, mask_50_alpha_24<br /><br />     mov edx, edi ;get src pixel 2<br />     and edx, mask_50_alpha_24<br /><br />     add eax,edx<br />     shr eax,1<br />     mov &#91;esi&#93;,eax ;place 50% blended result pixel back<br />     add esi, 4<br />     dec ecx<br />     .endw     <br /><br />     xor edx, edx<br />     mov eax, bm.bmWidth<br />     mul bm.bmHeight<br />     mov ecx, eax<br />     mov esi, lpBits<br />     mov edi, 00FFFFFFh<br />     .while&#40; ecx &#41;<br /><br />     mov eax,&#91;esi&#93; ;get src pixel 1<br />     and eax, mask_50_alpha_24<br /><br />     mov edx, edi ;get src pixel 2<br />     and edx, mask_50_alpha_24<br /><br />     add eax,edx<br />     shr eax,1<br />     mov &#91;esi&#93;,eax ;place 50% blended result pixel back<br />     add esi, 4<br />     dec ecx<br />     .endw     <br />     <br />     invoke BitBlt, hdc, 0,0,250,250,hMemDC, 0, 0, SRCCOPY <br />     <br />     invoke DeleteDC, hMemDC ;BMDC<br />     invoke DeleteObject, hBm<br />          <br />     <br />     ret<br />DoAlpha ENDP<br /></code></pre><br /><br />I don't know if i've to use directly the hdc of BeginPaint in DoAlpha or if i've to Create a compatible one.<br />:confused::confused:<br /><br />thanks in advance...<br /><br />Jean / Coder7345</div>
    <div class="meta">Posted on 2002-05-27 18:46:16 by coder</div>
   </div>
   <div class="post" id="post-40263">
    <div class="subject"><a href="#post-40263">Some GFX advice..</a></div>
    <div class="body">It's either your bitmasks on the bitblts or the way you create the dib bitmap.  I think you might have to initialize the dib or createcompatiblebitmap for it.</div>
    <div class="meta">Posted on 2002-05-27 23:01:47 by grv575</div>
   </div>
   <div class="post" id="post-40854">
    <div class="subject"><a href="#post-40854">Some GFX advice..</a></div>
    <div class="body">well the problem is solved. :)<br /><br />i've another question... is lpBits pointing to (width * height) dwords of RRGGBB pixel colors?</div>
    <div class="meta">Posted on 2002-05-31 16:35:40 by coder</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=5167&amp;page=1" style="">&laquo;</a><a href="../?id=5167&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="5167" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>