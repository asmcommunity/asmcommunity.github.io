<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Some GFX advice.. - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=5167" />
    <link rel="next" href="../?id=5167&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=5167">Some GFX advice..</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=5167&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=5167&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="5167" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=5167&amp;page=2">&gt;</a><a href="../?id=5167&amp;page=2">&raquo;</a></form>   <div class="post" id="post-36467">
    <div class="subject"><a href="#post-36467">Some GFX advice..</a></div>
    <div class="body">Hey all, <br /><br />Im seeking some advice on what to do:<br /><br />I want to suppy a bitmap background for my edit control im working on.  I already have a bitmap interface working, and looks pretty sweet.  But the problem is the text becomes *very* hard to read at points (not surprisingly).<br /><br />I was wondering if any of you graphics guru's knew of a way to diminish the overal bitmap a shade..  Like fading it out, but still have its relative colors in tact.<br /><br />Basically draw 'faintly'...  or in terms of GDI, bitblt a &quot;faint&quot; bitmap ;)<br /><br />(( I tried drawing the text in a layered style to give a shadow around it, but it look bulky :(  ))</div>
    <div class="meta">Posted on 2002-05-04 05:03:33 by NaN</div>
   </div>
   <div class="post" id="post-36486">
    <div class="subject"><a href="#post-36486">Some GFX advice..</a></div>
    <div class="body">If you're happy to limit to Win2k,ME,XP you could simply use alpha blt and paint the image onto whatever color you want to fade it to.<br /><br />Otherwise you'll probably have to do the fading yourself. That's not to bad though as bitRAKE's alphablending routine will do that for you, and pretty damn quickly as well. Create a 32bit DIB Section, bitblt the bitmap into it then loop through the image data with the routine.</div>
    <div class="meta">Posted on 2002-05-04 07:18:26 by Eóin</div>
   </div>
   <div class="post" id="post-36491">
    <div class="subject"><a href="#post-36491">Well</a></div>
    <div class="body">If its reading text over any bitmap that you need i guess you can draw a shadow margin arround it, or a lighter one if the background is dark like i see in your image, could be better but...<br /><br />About fast alpha blending, i guess you need that yiu can use the fast 50% alphablending algorithm we sometimes use in HE: and with a mask both pixels then shift them right and finally add them<br /><br /><pre><code><br /><br />mask_50_alpha_24 equ 0.11111110.11111110.1111.1110b<br /><br />mov eax,&#91;esi&#93; ;get src pixel 1<br />and eax,mask_50_alpha_24<br />shr eax,1<br /><br />mov ebx,&#91;edi&#93; ;get src pixel 2<br />and ebx,mask_50_alpha_24<br />shr ebx,1<br /><br />add eax,ebx<br />mov &#91;esi&#93;,eax ;place 50% blended result pixel back<br /><br /></code></pre><br /><br />this is not quite accurate but its fast and should do fine for many controls ;)</div>
    <div class="meta">Posted on 2002-05-04 09:46:32 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-36492">
    <div class="subject"><a href="#post-36492">Some GFX advice..</a></div>
    <div class="body"><pre><code>mask_50_alpha_24 equ 0.11111110.11111110.11111111b<br /><br />mov eax,&#91;esi&#93; ;get src pixel 1<br />and eax,mask_50_alpha_24<br /><br />mov ebx,&#91;edi&#93; ;get src pixel 2<br />and ebx,mask_50_alpha_24<br /><br />add eax,ebx<br />shr eax,1<br />mov &#91;esi&#93;,eax ;place 50% blended result pixel back</code></pre>Only loose 4 bits - instead of 6.  One less instruction.</div>
    <div class="meta">Posted on 2002-05-04 09:56:44 by bitRAKE</div>
   </div>
   <div class="post" id="post-36498">
    <div class="subject"><a href="#post-36498">Some GFX advice..</a></div>
    <div class="body">Thanx E?in, but i would like to ideally allow it to work on all boxes (might be able to let 95 slide tho).<br /><br />BogdanOntanu and bitRAKE, Thanks *alot* for the source, more than expected.  But can anyone give me an idea what his *actually* does.  (( Im a bit ignorant of graphic stuff like whatever Alpha-Blend means?? ))  <br /><br />What is &quot;Only loose 4 bits - instead of 6&quot; mean??<br /><br />I also found this on the MSDN, <a target="_blank" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/gdi/bitmaps_2b00.asp">Alpha Example</a> , But i think this is overkill.  (i dunno really).  But instead of the AlphaBlend API, replace it with the suggested routine above??  <br /><br />Thing is i *really* dont know what alpha blend does, other than *somehow* makes the fog effect im looking for. :confused:<br /><br /><br />Thanx<br />:NaN:</div>
    <div class="meta">Posted on 2002-05-04 11:12:24 by NaN</div>
   </div>
   <div class="post" id="post-36505">
    <div class="subject"><a href="#post-36505">Some GFX advice..</a></div>
    <div class="body">Well i found more info on it:<div class="quote">Alpha blending is the process of combining a translucent foreground color with a background color, thereby producing a new blended color. The degree of the foreground color's translucency may range from completely transparent to completely opaque. If the foreground color is completely transparent, the blended color will be the background color. Conversely, if it is completely opaque, the blended color will be the foreground color. Of course, the translucency can range between these extremes, in which case the blended color is computed as a weighted average of the foreground and background colors. </div><br /><br /><div class="quote">alpha blending <br />A technique by which the color in a source bitmap is combined with that in a destination bitmap to produce a new destination bitmap. <br />GDI performs per-pixel alpha blending, according to the formula: Blend = Alpha * Source + (1 - Alpha) * Destination. This formula is used to compute the alpha blend at each pixel, for each of the red, green, and blue color channels. </div><br /><br />I think im starting to see the picture better (pardon the pun ;).<br />But if you have more advice, please tell ;)<br /><br /><strong>Another quick question</strong>, how exactly does the DIB bitmap data play in terms of a buffer length needed, for different color depths?  I *assume* if its 265 color, than one byte per pixel, but if its say x Million colors, there would be up to 4 bytes per pixel (right)?  Which means the above algo would need to be modified right?? And more GDI processing on just what the bitmap *is* ??<br /><br />Thanx</div>
    <div class="meta">Posted on 2002-05-04 12:28:48 by NaN</div>
   </div>
   <div class="post" id="post-36507">
    <div class="subject"><a href="#post-36507">Some GFX advice..</a></div>
    <div class="body">Can I suggest bitRAKEs alpha blending routine over the 50% one. You'll only need to do blending once for the image, then just keep the blended image in memory. This means that speed isn't the primary goal.<br /><br />By using bitRAKEs routine you'll allow the user specify varying degrees of fading. In some case 50% may not be enough. Generally a watermarking effect would look better and for this you probably want about 90% blending.<br /><br />As for DIBs, for 32 bit you need 4 bytes per pixel, once blended however you could blit the image into a 8 bit colour DC and delete the 32 bit version to save memory.</div>
    <div class="meta">Posted on 2002-05-04 13:21:57 by Eóin</div>
   </div>
   <div class="post" id="post-36538">
    <div class="subject"><a href="#post-36538">Some GFX advice..</a></div>
    <div class="body">Eoin, I *totaly* agree, and am 90% there already.  The way im currently showing the background is by creating a 'storage' DC and making a complete copy of the source bitmap (full sized), and placing this Master Copy into to the storage DC.<br /><br />Then when resize messages comes along, i use the stored master and 'chop' a centered section out and blt it to a 'Sized' DC and bitmap.  (this is where i would add the Alpha Blend).<br /><br />When its time to paint, i do a bitblt of the Sized BM (with the pre formatted background image), onto the back buffer, and redraw the text over top.<br /><br />This complexity saves speed when drawing, cause the background remains static on the sized DC, ready for one quick copy (untill the window size changes ~ which shouldnt be all to often ;) )<br /><br />So i will follow your advice here.  I would like to allow the user to 'select' the degree of blend. <br /><br />Where im still lost is controlling DC's color depths.  I know enough to get around with GDI, but I've never tried or even thought about the issue of color depths, cause till now all i did was  select bitmaps, and blt them (color stuff was done automatically).  But now Is appearent that to propely do the alpha blend, i will need to *somehow* create specific bitmaps, and *somehow* find their color depths.  If you know of these API's off hand it would be appreciated :)  ( I will still try to find them on my own however, im not that lazy ;)  )<br /><br />Again Thanx for the advice, You've all been a great help so far!<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-05-04 16:11:28 by NaN</div>
   </div>
   <div class="post" id="post-36543">
    <div class="subject"><a href="#post-36543">Some GFX advice..</a></div>
    <div class="body">I always do color conversion the easy way too, with BitBlt. When you create the DIBSection set the height and width of the BITMAPINFOHEADER to the match your bitmap. And set biPlanes to 1, biBitCount to 32 &amp; biCompression to BI_RGB. Everything else is set to 0.<br /><br />When you BitBlt the bitmap into this its converetd to 32bit for you. This is perfect since this is the format bitRAKE wrote his algo to work with, thats the only reason why you need to perform the conversion in the first place. Also since you're dealing with 4 bytes per pixel there's no padding to worry about. So a simpe loop through each pixel pair applying the routine will do the job nice and quickly.<br /><br />Once blended you can use BitBlt to do whatever you want to the bitmap.</div>
    <div class="meta">Posted on 2002-05-04 16:55:10 by Eóin</div>
   </div>
   <div class="post" id="post-36547">
    <div class="subject"><a href="#post-36547">Some GFX advice..</a></div>
    <div class="body">Thanx Eoin! <br /><br />(( I was looking way off base here ))  ~ I think i can get started now ;)<br /><br />BTW: Can BitBlt safely blit from a DIB to a DDB??  Ie, if i create the DIB for the alpha blend, and select it to a DC, can i leave it and rely on it as the source for when copying to the back buffer (created as a compatible bitmap of the primary DC ( assumed to be a DDB ) )<br /><br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-05-04 17:03:49 by NaN</div>
   </div>
   <div class="post" id="post-36553">
    <div class="subject"><a href="#post-36553">Some GFX advice..</a></div>
    <div class="body">I've never ever had any problems so I'd assume it ok. <br /><br />But if someone out there has may they speak up. :)</div>
    <div class="meta">Posted on 2002-05-04 17:58:49 by Eóin</div>
   </div>
   <div class="post" id="post-36560">
    <div class="subject"><a href="#post-36560">Some GFX advice..</a></div>
    <div class="body">Well here is my Souce for future reference/searchs:<br />SizedBM, and BACKDC are the source bitmap and DC that is<br />pre-existing before this routine is called.  The SizedBM is replaced<br />with the alphablended routine, which is ready for direct<br />copying onto the back buffer when WM_PAINT comes along.<br /><pre><code>;=========================================================================================================<br /> DoAlpha   PROC USES esi edi<br />;=========================================================================================================<br />     LOCAL bm       &#58;BITMAP<br />     LOCAL bmi      &#58;BITMAPINFO<br />     LOCAL lpBits   &#58;DWORD<br />     LOCAL hBitmap  &#58;DWORD<br />     LOCAL SDC      &#58;DWORD<br />     LOCAL OldBM    &#58;DWORD<br /><br />     LOCAL BMDC     &#58;DWORD<br /><br />     invoke GetObject, &#91;ebx&#93;.ECon.IMG.SizedBM, sizeof BITMAP, addr bm           ; Get Src Bitmap Size<br />     <br />     invoke RtlZeroMemory, addr bmi.bmiHeader, sizeof BITMAPINFOHEADER          ; Zero the Header<br /><br />     mov eax, sizeof BITMAPINFOHEADER                                           ; Fill 32 bit bitmap <br />     mov bmi.bmiHeader.biSize, eax                                              ; header, RGB mode<br />    <br />     mov eax, bm.bmWidth<br />     mov bmi.bmiHeader.biWidth, eax<br />     mov eax, bm.bmHeight<br />     neg eax                                                                    ; make this a top-&gt;down bitmap<br />     mov bmi.bmiHeader.biHeight, eax<br />     mov bmi.bmiHeader.biPlanes, 1<br />     mov bmi.bmiHeader.biCompression, BI_RGB<br />     mov bmi.bmiHeader.biBitCount, 32            ; 32 bits per pixel<br />    <br />     invoke CreateDIBSection, &#91;ebx&#93;.ECon.IMG.BACKDC,addr bmi, DIB_RGB_COLORS,   ; Make the DIB section<br />                               addr lpBits, NULL, NULL<br />     mov hBitmap, eax                                                           ; Save the handle<br />     <br />     invoke GetDC, &#91;ebx&#93;.ECon.hWnd                                              ; Get the main DC<br />     mov SDC, eax<br />     invoke CreateCompatibleDC, eax                                             ; Create a Temp DC<br />     mov BMDC, eax       <br />     invoke ReleaseDC, &#91;ebx&#93;.ECon.hWnd, SDC                                     ; Release the source DC<br />     invoke SelectObject, BMDC, hBitmap                                         ; Select the new DIB<br />     mov OldBM, eax                                                             ; Save the OLD BM<br />     <br />     invoke BitBlt, BMDC, 0,0,                                                  ; Copy to the Sized BM the<br />                    &#91;ebx&#93;.ECon.WIN.DRCT.right,&#91;ebx&#93;.ECon.WIN.DRCT.bottom,       ; and do RGB conversion<br />                    &#91;ebx&#93;.ECon.IMG.BACKDC, 0,0, SRCCOPY <br />     <br />     <br />     ; Do Alpha.<br />     mask_50_alpha_24 equ 0111111101111111011111111b<br />     xor edx, edx<br />     mov eax, bm.bmWidth<br />     mul bm.bmHeight<br />     mov ecx, eax                                                               ; Get the # of RGB quad's<br />     mov esi, lpBits<br />     mov edi, 00FFFFFFh<br />     .while&#40; ecx &#41;<br /><br />     mov eax,&#91;esi&#93; ;get src pixel 1<br />     and eax, mask_50_alpha_24<br /><br />     mov edx, edi ;get src pixel 2<br />     and edx, mask_50_alpha_24<br /><br />     add eax,edx<br />     shr eax,1<br />     mov &#91;esi&#93;,eax ;place 50% blended result pixel back<br />     add esi, 4<br />     dec ecx<br />     .endw     <br /><br />     xor edx, edx<br />     mov eax, bm.bmWidth<br />     mul bm.bmHeight<br />     mov ecx, eax                                                               ; Get the # of RGB quad's<br />     mov esi, lpBits<br />     mov edi, 00FFFFFFh<br />     .while&#40; ecx &#41;<br /><br />     mov eax,&#91;esi&#93; ;get src pixel 1<br />     and eax, mask_50_alpha_24<br /><br />     mov edx, edi ;get src pixel 2<br />     and edx, mask_50_alpha_24<br /><br />     add eax,edx<br />     shr eax,1<br />     mov &#91;esi&#93;,eax ;place 50% blended result pixel back<br />     add esi, 4<br />     dec ecx<br />     .endw     <br />     <br />     invoke BitBlt, &#91;ebx&#93;.ECon.IMG.BACKDC, 0,0,                                 ; Copy Alpha'd DC<br />                    &#91;ebx&#93;.ECon.WIN.DRCT.right,&#91;ebx&#93;.ECon.WIN.DRCT.bottom,       ; To SizedBM on BACKDC<br />                    BMDC, 0, 0, SRCCOPY <br />     <br />     invoke SelectObject, BMDC, OldBM<br />     invoke DeleteDC, BMDC<br />     invoke DeleteObject, hBitmap<br />          <br />     <br />     ret<br />DoAlpha ENDP</code></pre><br /><br /><strong>One last question,</strong> Im doing the Alpha blend twice to get 75% reduction.  How would i determin a variable percent reduction with this algo.  Is it even possible with this.  The equate looks kinda specific to me, but i dont fully understand how it is derived anyways :rolleyes:<br /><br /><strong>However,</strong></div>
    <div class="meta">Posted on 2002-05-04 18:56:16 by NaN</div>
   </div>
   <div class="post" id="post-36566">
    <div class="subject"><a href="#post-36566">Some GFX advice..</a></div>
    <div class="body">The equ makes sure that once you use shr to average the source pixels, the most insignificant bit of one color doesn't become the most significant bit of another color. (The last 3 bytes of a 32 bit color each signify one of the three basic colors)<br /><br />Edit: forgot to post what is the thing that happens.<br /><br />First the most insignificant bit of the first two colors is removed, then the two colors are added, and shifted right once. If you need 75% reduction use a bitmask the removes the two most insignificant bits of the first two colors, and get 3 times as much white into it (That's what the 0FFFFFFh stand for)<br /><br />so:<br />mask_50_alpha_24 equ 0111111101111111011111111b<br />becomes:<br />mask_50_alpha_24 equ 0111111001111110011111111b<br /><br />and add after:<br />and edx, mask_50_alpha_24<br />the following<br />lea edx, ; gets 3 times white<br /><br />and change:<br />shr eax,1<br />to:<br />shr eax,2 ; divide by 4 for the 3 whites and 1 source</div>
    <div class="meta">Posted on 2002-05-04 19:29:58 by _js_</div>
   </div>
   <div class="post" id="post-36571">
    <div class="subject"><a href="#post-36571">Some GFX advice..</a></div>
    <div class="body">Gotcha,<br /><br />But i guess 75% was a poor choice to ask the question on.  I have in mind an Up/Down counter form 0-100%, and allow the user to DYNAMICALLY set the level of blend.  <br /><br />I guest i would then need to write the slower:<br /><br />Blend = Alpha * Source + (1 - Alpha) * Destination<br /><br />Algo for each R, G, and B bytes?<br /><br />Right?<br />:NaN:</div>
    <div class="meta">Posted on 2002-05-04 19:49:08 by NaN</div>
   </div>
   <div class="post" id="post-36579">
    <div class="subject"><a href="#post-36579">Some GFX advice..</a></div>
    <div class="body">Yes, but that would be slow I think, you could search for a different algo, perhaps try 'or'ing it with 256 different shades of white depending on the slider? (00.00.00, 01.01.01, ... , ff.ff.ff) It that would distort the image somewhat but be faster.</div>
    <div class="meta">Posted on 2002-05-04 20:25:49 by _js_</div>
   </div>
   <div class="post" id="post-36625">
    <div class="subject"><a href="#post-36625">Some GFX advice..</a></div>
    <div class="body">This is a good idea, but i have the advantage here.  The routine is *only* called when a new bitmap is sent *or* when the window is resized.  So i can take more time to get the job done, (if needed).  But as always, faster is prefered!<br /><br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-05-05 03:29:46 by NaN</div>
   </div>
   <div class="post" id="post-36636">
    <div class="subject"><a href="#post-36636">Some GFX advice..</a></div>
    <div class="body">I've been looking at bitRAKEs algo, I forgot that it blends two images together, which you don't want to do. But its easy to change it to blend one image towards a certain colour.<br /><br /><pre><code>	mov eax,lpBits<br />	mov ecx,Count ; number of pixels/2<br />	dec ecx<br />	pxor mm7,mm7	<br />	movq mm1,DesiredColour ;<br />Format 0AABBGGRRAABBGGRRh<br />	movq mm0,&#91;eax+ecx*8&#93;<br />@@&#58;	movq mm4,mm1; &lt;- Here<br />	movq mm2,mm0<br />	psrlw mm4,1<br />	movq mm3,mm1<br />	movq mm5,mm4<br />	punpcklbw mm0,mm7<br />	punpcklbw mm1,mm7<br />	punpckhbw mm2,mm7<br />	punpckhbw mm3,mm7<br />	psubsw mm0,mm1<br />	psubsw mm2,mm3<br />	punpcklwd mm4,mm4<br />	punpckhwd mm5,mm5<br />	punpckhdq mm4,mm4<br />	punpckhdq mm5,mm5<br />	psllw mm0,1<br />	psllw mm2,1<br />	pmulhw mm0,mm4<br />	pmulhw mm2,mm5<br />	paddsw mm0,mm1<br />	paddsw mm2,mm3<br />	packuswb mm0,mm2<br />	movq &#91;edx+ecx*8&#93;,mm0<br />	dec ecx<br />	movq mm0,&#91;eax+ecx*8&#93;<br />	;movq mm1,&#91;edx+ecx*8&#93; ; &lt;- Here<br />	jnz @B</code></pre> <br /><br />I may have the red and blue of the desiredColor format wrong here, plus I'm doing this in my head at the momnet so the changes I've made to the origional (indicated by &quot;&lt;- Here&quot;) may not work. But hopefully they will.</div>
    <div class="meta">Posted on 2002-05-05 06:24:05 by Eóin</div>
   </div>
   <div class="post" id="post-36651">
    <div class="subject"><a href="#post-36651">Some GFX advice..</a></div>
    <div class="body">Woo Hoo! :)<br /><br />My first valid reason to dive into MMX ;)<br /><br />Think its safe to say everyone has MMX by now.  However, if someone didnt, what would this code do on their machines, anything?</div>
    <div class="meta">Posted on 2002-05-05 10:37:46 by NaN</div>
   </div>
   <div class="post" id="post-36662">
    <div class="subject"><a href="#post-36662">Some GFX advice..</a></div>
    <div class="body"><strong>NaN</strong>, that algo is overkill for what your trying to do.  I've marked all the instructions below that can be moved outside the loop because they are constant:<pre><code>@@&#58;	movq mm4,mm1 ;*<br />	movq mm2,mm0<br />	psrlw mm4,1 ;*<br />	movq mm3,mm1 ;*<br />	movq mm5,mm4 ;*<br />	punpcklbw mm0,mm7<br />	punpcklbw mm1,mm7 ;*<br />	punpckhbw mm2,mm7<br />	punpckhbw mm3,mm7 ;*<br />	psubsw mm0,mm1<br />	psubsw mm2,mm3<br />	punpcklwd mm4,mm4 ;*<br />	punpckhwd mm5,mm5 ;*<br />	punpckhdq mm4,mm4 ;*<br />	punpckhdq mm5,mm5 ;*<br />	psllw mm0,1<br />	psllw mm2,1<br />	pmulhw mm0,mm4<br />	pmulhw mm2,mm5<br />	paddsw mm0,mm1<br />	paddsw mm2,mm3<br />	packuswb mm0,mm2<br />	movq &#91;edx+ecx*8&#93;,mm0<br />	dec ecx<br />	movq mm0,&#91;eax+ecx*8&#93;<br />	movq mm1,mm6 ;*<br />	jnz @B</code></pre>If you wanted to support non-MMX CPU's then you'd have to test if MMX is suported, and execute alternate code or not support the feature.  These instructions would produce an exception on unsupported processors.  Of course, an alternate version of your control would be another option.</div>
    <div class="meta">Posted on 2002-05-05 12:22:29 by bitRAKE</div>
   </div>
   <div class="post" id="post-36669">
    <div class="subject"><a href="#post-36669">Some GFX advice..</a></div>
    <div class="body">Sounds good.<br /><br />And ya.. i did a study on MMX this morning and commented the crap outa it.  I really dont know *what* it does, but it definitely is not the alpha blend.  As well, i see no area for selecting % opacity.<br /><br />And the 'edx' hidden at the bottom managed to crash Win98SE real good (reboot).<br /><br /><br />Here is my commented version:<pre><code>     mov COLOR&#91;0&#93;, 0FFFFFFh<br />     mov COLOR&#91;1&#93;, 0FFFFFFh<br />     lea eax, COLOR<br />     movq mm1, &#91;eax&#93;                        ; mm1 = Color &#40;white&#41;<br />     ;  Format 0AABBGGRRAABBGGRRh<br />     <br />     xor edx, edx<br />     mov eax, bm.bmWidth<br />     mul bm.bmHeight<br />     mov ecx, eax                            ; Get the # of RGB quad's<br />     shr ecx, 1                              ; Divide by two<br />     mov eax, lpBits                         ; place lpBits in eax<br /><br />     ; FUNTION&#58; Blend = Alpha * Source + &#40;1 - Alpha&#41; * Destination <br />     ; -----------------------------------------------------------<br /><br />     dec ecx                                 ; Dec eax the count<br />     pxor mm7,mm7	                         ; Format mm7 to zero<br />     <br />     <br />     movq mm0,&#91;eax+ecx*8&#93;                    ;                     mm0 = first 8 bytes<br />@@&#58;  movq mm4,mm1                    ;&lt;- Her ;                     mm4 = mm1          &#40;copy of color&#41;<br />	movq mm2,mm0                            ;                     mm2 = mm0          &#40;copy of src data&#41;<br />	psrlw mm4,1                             ;                     mm4 = mm4 &gt;&gt; 1     &#40;packed word&#41;                                                               <br />	movq mm3,mm1                            ;                     mm3 = mm1          &#40;copy of color&#41;<br />	movq mm5,mm4                            ;                     mm5 = mm4          &#40;copy of shifted mask&#41;<br />	punpcklbw mm0,mm7                       ; A = mm0, 0 = mm7 -&gt; mm0 = 0A0A0A0A LSB &#40;lower 4 data&#41;<br />	punpcklbw mm1,mm7                       ; B = mm1, 0 = mm7 -&gt; mm1 = 0B0B0B0B LSB &#40;lower 4 color&#41;<br />	punpckhbw mm2,mm7                       ; A = mm2, 0 = mm7 -&gt; mm2 = 0A0A0A0A LSB &#40;upper 4 data&#41;<br />	punpckhbw mm3,mm7                       ; B = mm3, 0 = mm7 -&gt; mm3 = 0B0B0B0B LSB &#40;upper 4 color&#41;<br />	psubsw mm0,mm1                          ; sined&amp;sat sub w  -&gt; mm0 = mm0 - mm1    &#40;lower data - color&#41;<br />	psubsw mm2,mm3                          ; sined&amp;sat sub w  -&gt; mm2 = mm2 - mm3    &#40;upper data - color&#41;<br />	punpcklwd mm4,mm4                       ;                     mm4 = AAaaAAaa LSB &#40;lower 2 shift color&#41;<br />	punpckhwd mm5,mm5                       ;                     mm5 = AAaaAAaa LSB &#40;upper 2 shift color&#41;<br />	punpckhdq mm4,mm4                       ;                     mm4 = AAAAaaaa LSB &#40;lower 1 shift color&#41;<br />	punpckhdq mm5,mm5                       ;                     mm5 = AAAAaaaa LSB &#40;upper 1 shift color&#41;<br />	psllw mm0,1                             ;                     mm0 = mm0 &lt;&lt; 1     &#40;lower data-color*2 &#41;<br />	psllw mm2,1                             ;                     mm2 = mm2 &lt;&lt; 1     &#40;upper data-color*2 &#41;<br />	pmulhw mm0,mm4                          ; MSW&#40; w * w &#41;     -&gt; mm0 = mm0 * mm4    &#40;MSW   low&#40;col&#41;*low&#40;dif&#41;2&#41;<br />	pmulhw mm2,mm5                          ; MSW&#40; w * w &#41;     -&gt; mm2 = mm2 * mm5    &#40;MSW   upr&#40;col&#41;*upr&#40;dif&#41;2&#41;<br />	paddsw mm0,mm1                          ; sined&amp;sat add w  -&gt; mm0 = mm0 + mm1    &#40;MSW low + B0B0B0B0 low color&#41;<br />	paddsw mm2,mm3                          ; sined&amp;sat add w  -&gt; mm2 = mm2 + mm3    &#40;MSW upr + B0B0B0B0 upr color&#41;<br />	packuswb mm0,mm2                        ; pack uns W-&gt;b    -&gt; mm0 = 22002200 LSB &#40;pack resulting 2 DWORDS&#41;<br />	movq &#91;eax+ecx*8&#93;,mm0                    ; over write the first 8 bytes &#40;2 pixel RGB's&#41;<br />	dec ecx                                 ; next incremente<br />	movq mm0,&#91;eax+ecx*8&#93;                    ;                     mm0 = next 8 bytes<br />     ;movq mm1,&#91;edx+ecx*8&#93; ; &lt;- Here<br />	jnz @B                                  ; loop Back if  ecx == 0 &#40;movq is transparent&#41;</code></pre><br /><br />I can see it being re-worked into an equation of this form:<br />Dest + Alpha(Color - Destination).  And i see hints of this <br />happening, (Data - Color).  But what i dont get is the logical <br />shifting (both right and left shifts) and the High order multiply??  <br />What are they trying to do? Are theses routines attempting to build or fractionize the difference (alpha)??<br /><br /><br />Anyways, it only makes a dark blue image when tested.<br /><br />However, Eoin, thanx for the src, its has still been a good learning lesson so far!<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-05-05 13:30:29 by NaN</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=5167&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=5167&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="5167" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=5167&amp;page=2">&gt;</a><a href="../?id=5167&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>