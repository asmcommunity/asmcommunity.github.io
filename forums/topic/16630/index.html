<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Very Important To Think About - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16630" />
    <link rel="next" href="../?id=16630&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=16630">Very Important To Think About</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=16630&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=16630&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="16630" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=16630&amp;page=2">&gt;</a><a href="../?id=16630&amp;page=2">&raquo;</a></form>   <div class="post" id="post-129213">
    <div class="subject"><a href="#post-129213">Very Important To Think About</a></div>
    <div class="body">GUYS AND GALS!!!<br /><br />When 64-bit processors become redily available, does that mean that 32-bit assembling will become obsolete?? does it mean that we'll have to learn 64-bit assembler or perhaps C++ 64-bit edition?<br /><br /><br />i'm new to programming and so i want to make sure if i invest my time in learning assembly, i won't be doing it in vain (when considering the long term) because there is a lot of time needed to understand how to use assembly as opposed to c++ ...<br /><br />your insights would be greatly appreciated<br /><br />thanks.</div>
    <div class="meta">Posted on 2003-12-28 23:29:39 by quaze</div>
   </div>
   <div class="post" id="post-129221">
    <div class="subject"><a href="#post-129221">Very Important To Think About</a></div>
    <div class="body">imho, changes won't be so drastical. They'll happen, but in a very very long timespan. If you learn x86 , you'll be able to learn the new asm in a few days max. C++ coders won't feel the change at all - they'll have only another datatype - &quot;dlong&quot; maybe, and if they ever used UINT64, their code will run faster. I'm not sure about the fpu, but as those new cpus support x86, too , I think code won't change drastically (like jumping/falling from x86 to motorola). <br />So, relax and enjoy the ride :grin:<br />:alright:</div>
    <div class="meta">Posted on 2003-12-29 02:52:29 by Ultrano</div>
   </div>
   <div class="post" id="post-129233">
    <div class="subject"><a href="#post-129233">Very Important To Think About</a></div>
    <div class="body">Many of us already have the 64bit version of masm's compiler , ml.exe version 8, and are just waiting for an excuse to buy a 64bit processor ourselves :tongue:</div>
    <div class="meta">Posted on 2003-12-29 05:52:51 by Homer</div>
   </div>
   <div class="post" id="post-129254">
    <div class="subject"><a href="#post-129254">Very Important To Think About</a></div>
    <div class="body">I agree with Ultrano in the way that if you know the 'base language' you can migrate more fast to the new language, I remember after reading some oop things, I decide to stik with C, then I find somewhere a very good tutorial on C++ and all that I know for C++ I learned in 1 day ;).<br /><br />So learn 32bits-asm and you can get the idea more fast on 64 bits, and like say EvilHomer2k, you probably in this moment dont have a 64bits procesor, then practice with a 32bits processor, and when you have a 64 bit processor, practice in it!!!.<br /><br /><br />Yes lear asm32 it will not be in vain.<br /><br />Have a nice day or night.</div>
    <div class="meta">Posted on 2003-12-29 09:58:36 by rea</div>
   </div>
   <div class="post" id="post-129290">
    <div class="subject"><a href="#post-129290">Very Important To Think About</a></div>
    <div class="body">Is the asm syntax the same with a 64-bit compiler though?</div>
    <div class="meta">Posted on 2003-12-29 18:03:06 by quaze</div>
   </div>
   <div class="post" id="post-129312">
    <div class="subject"><a href="#post-129312">Yes</a></div>
    <div class="body">The syntax for AMD64 is &quot;exactly&quot; the same as 32bit<br /><br />Only there are more registers R0-R16 and use REAX in instead of EAX, of course some new nstructions exist but be happy ... i think on 64bits ASM will be evem more powerfull than it is today on 32bits.<br /><br />The CPU will be able to execute the 32bit code exactly as 32bits CPU can execute 16bit code , So there will be 64&gt;32&gt;16 in the same CPU<br /><br />So no big deal about syntax, and i am also working to an assembler compatible with MASM/TASM that will use the same syntax for 16/32/64/whatever :)<br /><br />Besides understanding ASM means having more knowledge. <br /><br />Having more knowledge  is never a minus, It is ALWAYS good<br /><br />It was quite a help for me in understanding all HLL programming languages and their pitfalls.<br /><br />I know ASM, C,C++,Visual Basic, Visual Fox,Forth, Pascal, Delphi,Prolog,Lisp<br /><br />And ASM never hides me anything (not include HLA) while all other languages lie (besides FORTH)<br />I guess in a stupid hope to make you understand things faster. Knowing without knowledge its a funny ideed that hunts Earth today.<br /><br />The slow learning of ASM is a myth. <br /><br />Taken from ZERO (aka with no pre C/HLL propaganda) i can learn everybody/anybody ASM in about 30minutes no matter what CPU/syntax.  Ask Eugen who have learned from me :P<br /><br />Of course if you mind is cluttered with C++ and other HLL and propaganda it will take a little longer to take this off your head... and you might not want to.<br /><br />I know ASM on this CPUs:8080,8086/80386/80485/Pentium1,2,3,4/Intel/AMD, <br />Z80 Z8, Z8000, 80C59, some bit slice TI and NS, Motorola 6804,68000,680020,680030<br /><br />And i never had any problem learning them because i know <strong>ASM CONCEPTS</strong>, not exact syntax (that comes in time) <br /><br />Just the same as in C/C++/HLL i know the <strong>HLL CONCEPTS</strong> and when i need exact syntax i (rarely) RTFM :grin:<br /><br />So if you want to pretend you know something and or be &quot;in the trend&quot; and or make a sucessfull career and make a lot of money then learn C++/Java/.NET or whatever is today's &quot;image of sucess&quot;<br /><br />You know:<br />&quot;In order to have sucess one must always project an image of success&quot; :grin:<br /><br />But if you seek knowledge and absolute truth then go with ASM.<br /><br />However this might not be the path for you :P</div>
    <div class="meta">Posted on 2003-12-29 21:04:54 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-129327">
    <div class="subject"><a href="#post-129327">Very Important To Think About</a></div>
    <div class="body"><div class="quote"><br />or whatever is today's &quot;image of sucess&quot;<br /></div><br /><br />Hehe... &quot;today's image of success&quot;. C/C++ has been here for a while, and will be here for a while.</div>
    <div class="meta">Posted on 2003-12-29 22:40:24 by f0dder</div>
   </div>
   <div class="post" id="post-129350">
    <div class="subject"><a href="#post-129350">Very Important To Think About</a></div>
    <div class="body">The new IA-64 architecture is not compatible with the previous systems. Is it right?<br />What are the cons and pros of IA-64?</div>
    <div class="meta">Posted on 2003-12-30 05:09:36 by Vortex</div>
   </div>
   <div class="post" id="post-129352">
    <div class="subject"><a href="#post-129352">Very Important To Think About</a></div>
    <div class="body">What I learnt from google is that Intel made a cpu that isn't compatible with x86. :rolleyes: <br />:sweat:  <br /> Either they were naive, or they wanted to really try what would happen. :notsure: <br />AMD meanwhile created x86-64, which is completely compatible with our x86 code :cool: , running at full speed! I didn't find what has happened for some time, but now I see Intel understood they can't make everybody in the world start recompiling or rebuilding their software just to use that parallel processing thing. That parallel processing imho is kind of present in AMD's current cpus,  I optimize/use such stuff. <br />So, Intel ate their fist and their lazy option was to get license from AMD about that AMD64 system (x86-64). So, Intel are now building a cpu  Yawmill (pronounced &quot;<strong>Yawn</strong>&quot;  &quot;<strong>meow</strong>&quot; I think :grin:  <em>jk</em>). <br />So, <strong>our code is safe</strong>, and my optimizations too :grin:<br /><br /><strong>Long live AMD</strong> :alright:</div>
    <div class="meta">Posted on 2003-12-30 06:05:28 by Ultrano</div>
   </div>
   <div class="post" id="post-129353">
    <div class="subject"><a href="#post-129353">Very Important To Think About</a></div>
    <div class="body">(Awww Bogdan, you didnt play with 6502/6510? :tongue: )<br /><br />omg that instruction set is terrible !!<br />I agree with Ultrano :)</div>
    <div class="meta">Posted on 2003-12-30 06:31:57 by Homer</div>
   </div>
   <div class="post" id="post-129388">
    <div class="subject"><a href="#post-129388">Very Important To Think About</a></div>
    <div class="body">Outstanding opinions from undoubtedly the most wisest programmers this world has to offer.<br /><br />Thank you for your insightful opinions ... Please keep them coming :)</div>
    <div class="meta">Posted on 2003-12-30 23:11:35 by quaze</div>
   </div>
   <div class="post" id="post-129389">
    <div class="subject"><a href="#post-129389">Very Important To Think About</a></div>
    <div class="body">It took ten years (1985-1995, the epoch was the release of Windows 95) before people stopped writing 16-bit DOS code and started writing 32-bit code, en-masse. Don't expect the transition from 32-bits to 64-bits to happen any sooner. The problem with the transition is that it will be a decade before everyone has a 64-bit processor (and a 64-bit OS!) on their desks. And people who write software, except for certain niche markets, aren't about to give up the mass market for dubious performance improvements.<br /><br />95% of the world's applications aren't going to be improved by going to 64 bits. The main feature of the 64 bit processors is that they break the 4 GB/process barrier. Outside of video editing, databases, and a few other specialized application, few apps need more than 4GB (or anywhere near that much, for that matter).<br /><br />Sure, the 64-bit CPUs have a few new instructions; but few programmers use all the existing 32-bit instructions. It's not like those extra 64-bit instructions are going to make that big of a difference.<br /><br />And HLLs, where most software is written today, won't be able to make much use of the advanced 64-bit instructions (though, with the use of large pointers, they can take advantage of the extra memory; do expect lots of programs to break in the 32-&gt;64-bit transition, as happened in the 16-&gt;32-bit transition, though).<br /><br />Personally, I'm waiting for the 256-bit processor :-)<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-12-31 00:05:24 by rhyde</div>
   </div>
   <div class="post" id="post-129419">
    <div class="subject"><a href="#post-129419">Very Important To Think About</a></div>
    <div class="body">Some of us in the mainframe world have been working on 64 bit machines for several years now:<br /><br /><a target="_blank" href="http://researchweb.watson.ibm.com/journal/rd/464/plambeck.html">http://researchweb.watson.ibm.com/journal/rd/464/plambeck.html</a><br /><br />:grin:</div>
    <div class="meta">Posted on 2003-12-31 10:57:43 by S/390</div>
   </div>
   <div class="post" id="post-129433">
    <div class="subject"><a href="#post-129433">Very Important To Think About</a></div>
    <div class="body">I still think 64-bit processors are silly for normal workstation use. And it's not like most apps can benefit from 64bit datatypes anyway. Imo, intel did the right stuff in breaking free from x86 - that architecture is so hopeless, really, and should have been abandoned far ago. Too bad AMD are such a bunch of bigots, but I guess that's what you get from people who can't design their own stuff and have to copy other peoples architecture...</div>
    <div class="meta">Posted on 2003-12-31 12:46:30 by f0dder</div>
   </div>
   <div class="post" id="post-129450">
    <div class="subject"><a href="#post-129450">Very Important To Think About</a></div>
    <div class="body"><div class="quote"><em>Originally posted by f0dder </em><br />I still think 64-bit processors are silly for normal workstation use. And it's not like most apps can benefit from 64bit datatypes anyway. <br /></div><br /><br />I remember almost this exact same quote when we transitioned from eight-bits to 16-bits and from<br />16-bits to 32-bits!<br /><br /><div class="quote"><br />Imo, intel did the right stuff in breaking free from x86 - that architecture is so hopeless, really, and should have been abandoned far ago. Too bad AMD are such a bunch of bigots, but I guess that's what you get from people who can't design their own stuff and have to copy other peoples architecture...</div><br /><br />Of course, they thought the same thing when they created the iAPX-432 architecture to replace the x86 architecture. Let's see a show of hands: how many remember the iAPX-432?<br /><br />I'm not suggesting the IA-64 will die, but whether or not it will succeed is still a very open question. I agree that Intel probably made the right move for the long term; but the x86 has defied all predictions concerning longevity in the past. It remains to be seen if 64 bits is the end of the road.<br /><br />Of course, the big problem with the IA-64 is that if you're going to give up x86 compatibility, why go with an Intel offering? (And Intel has finally admitted that the IA-64 is *not* IA-32 compatible when they admitted that *software* emulation of the IA-32 on the IA-64 is *faster* than the built-in hardware emulation :)).<br /><br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-12-31 14:35:54 by rhyde</div>
   </div>
   <div class="post" id="post-129451">
    <div class="subject"><a href="#post-129451">Very Important To Think About</a></div>
    <div class="body"><div class="quote"><br />Some of us in the mainframe world have been working on 64 bit machines for several years now:<br /><br /><a target="_blank" href="http://researchweb.watson.ibm.com/journal/rd/464/plambeck.html">http://researchweb.watson.ibm.com/journal/rd/464/plambeck.html</a><br /><br />:grin: </div><br /><br />Mainframes, minis (workstations), and even Macs!<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-12-31 14:38:01 by rhyde</div>
   </div>
   <div class="post" id="post-129626">
    <div class="subject"><a href="#post-129626">Very Important To Think About</a></div>
    <div class="body">Personally I'm glad to see that Intel gives up a legacy of x86, because x86 was developed (if I'm not wrong) in 1977 (8086 processor in 1978) and lots of things are really different in these days (protected mode from 286, 32 bits from 386, optimizations...). I believe somebody has to set up new platform after x86 and I think IA-64 is really stronger than x86, even than AA-64 (AMD x86-64).<br />Don't beat me, AMD guys ;)</div>
    <div class="meta">Posted on 2004-01-02 15:48:02 by MazeGen</div>
   </div>
   <div class="post" id="post-129629">
    <div class="subject"><a href="#post-129629">Very Important To Think About</a></div>
    <div class="body">I admit the IA-64 has strong points, but did you ever see its instruction set? &quot;mamma mia&quot; I say. It's even worse than those C coding competitions where unreadability is most important. Did you see the asm code to do &quot;dwArray1[5]=x&quot;? <br />If IA-64 gets major percentage of the market, I'll get a Mac and throw my PC from the 10th floor. Or I'd never code in asm for it. Of course, it's just my personal opinion ;).</div>
    <div class="meta">Posted on 2004-01-02 16:35:21 by Ultrano</div>
   </div>
   <div class="post" id="post-129632">
    <div class="subject"><a href="#post-129632">Very Important To Think About</a></div>
    <div class="body">yeah, BogdanOntanu is right, it is the concept, not the syntax :) where it may be confusing or diff architecture it is still the same.<br />BogdanOntanu, it is time to learn ARM now :D to make the resume bigger:P</div>
    <div class="meta">Posted on 2004-01-02 16:59:56 by wizzra</div>
   </div>
   <div class="post" id="post-129644">
    <div class="subject"><a href="#post-129644">Very Important To Think About</a></div>
    <div class="body">I opened a thread &quot;looking ahead to 64-bit assembly&quot; in the <a target="_blank" href="http://www.masmforum.com/viewforum.php?f=23">GoAsm Assembler and Tools forum</a>.  This was solely in the context of windows programming for which <a target="_blank" href="http://www.GoDevTool.com">GoAsm</a> was written.<br /><br />Here is an edited version of my post:-<br /> <br />Although GoAsm64 is some way ahead, here are some 64-bit issues as I see them in the context of assembler programming for Windows.<br /><br /><strong><u>The 64-bit processor concerned</u></strong><br />I have concentrated on the AMD64 processor, as a logical first step for GoAsm64.  Intel have a X86-64 type chip in the pipeline, and hopefully it will have a similar register make-up to the AMD64 and use the same instructions (but will it support 3DNow!?).  If there are significant differences, then we are all in trouble.<br />Anyway, for the AMD64 to work in 64-bit mode, it requires a 64-bit operating system.  It appears that in due course, a new version of Microsoft's XP64 (codenamed &quot;Anvil&quot;) will become available for this processor.  The existing and published XP64 which now ships with Itanium based machines also has a compatibility mode, which can run 32-bit Windows programs by software emulation.  It's not clear to me whether the AMD64 would require software emulation to run 32-bit programs when running under a 64-bit operating system or whether such programs could be run more directly.<br />The AMD64 can also run in 32-bit mode, using a 32-bit operating system such as XP. This is called &quot;legacy mode&quot;.  In legacy mode, the processor is not working to its full capacity.  For example, the stack remains at 32-bits and none of the processor register extensions are available for use.<br /><br /><strong><u>Using the same source script for both 32 and 64-bit versions</u></strong><br />Assembler programmers will probably want to make two different versions of their programs, one for 32-bit operating systems and XP64 compatibility mode, and one for 64-bit operating systems.  Preferably the same source script would be used in each case.  For some time Microsoft has been planning towards this and has introduced some new switchable data types which it has recommended for use.  These data types appear in various structures in the header files in the SDK.  These are then switched automatically to the 64 bit versions by using #define _WIN64.<br />The same system can be used in assembler to make sure structures and data sizes are correct when assembling the 64-bit version.  The assembler would also need to change the default size of various instructions such as PUSH, POP, CALL, JMP, Jxx, and LOOPxx.  The simplest way to switch these would be for the assembler to switch to 64-bit mode if it sees (for example in GoAsm) the #define _WIN64 switch at the top of the source script, or in the command line using /d _WIN64 (probably GoAsm would not insist on the leading underscore, and would also recognise simply WIN64 or maybe WP64 as used by some Microsoft tools).<br />This seems to be a better solution to the switching issue than switching specific instructions, (for example switching from PUSH to a pseudo-mnemonic PUSHQ using #ifdef or #ifndef).<br /><br /><strong><u>Calling the correct APIs</u></strong><br />It seems from information available on the MSDN, the APIs will still be available in DLLs for programs to call.  This quote is from the XP 64 FAQ's:-<br /><div class="quote">Developers with 32-bit Windows skills will be comfortable and productive creating the next generation of application for Windows XP 64-Bit Edition. Developers will find the development environment virtually identical to the development environment for 32-bit Windows; the Microsoft Win64 application programming interface (API) is the same as the Microsoft Win32? API. The existing APIs have been modified where necessary to allow them to reflect the precision of the platform on which they are running. The result is programming simplicity and a short learning curve for the developer?writing code for 64-bit Windows is just like writing code for 32-bit Windows. </div><br />It seems that in XP64 the APIs have the same names as those in 32-bit XP and even have both Ansi and Wide versions as before. Clearly though, they act in quite different ways, since they will be working with 64 bits of data sent to them on the stack and not 32 bits.  It seems from the above quote that the API switches into 64-bit mode if the caller is a 64-bit program.  This would appear to be the simplest way to achieve the required result - for program development anyway!<br /><br /><strong><u>Identifying the new 64-bit registers</u></strong><br />Here I have followed the names used in the AMD64 manual:-<br />The general purpose registers, (as extended to 64 bits):-<br />AL,AH,AX,EAX,RAX<br />BL,BH,BX,EBX,RBX<br />CL,CH,CX,ECX,RCX<br />DL,DH,DX,EDX,RDX<br />BP,EBP,RBP<br />SI,ESI,RSI<br />DI,EDI,RDI<br />SP,ESP,RSP<br /><br />The low-bytes of all the general purpose registers (first 8-bits) are now addressable.  The syntax could be (as suggested in the AMD64 specs):-<br />BPL, SIL, DIL, SPL<br /><br />The new general purpose registers (64 bits).  Since the first 8, 16 and 32-bits of these are addressable (as well as the whole register), some way needs to be found to distinguish between these.  The AMD64 specs suggest:- <br /><br />The first byte of each register - R8B to R15B<br />The first word of each register - R8W to R15W<br />The first dword of each register - R8D to R15D<br />The whole register - R8 to R15<br /><br />The MMX registers (64 bit) - MM1 to MM7<br /><br />The floating point registers (shared with MMX) - ST0 to ST7<br /><br />The XMM registers (128 bits) - XMM0 to XMM7<br /><br />The new XMM registers (128 bits) - XMM8 to XMM15<br /><br /><strong><u>More data mixed up with code?</u></strong><br />The AMD64 makes use of RIP-Relative addressing.  RIP is the new 64-bit instruction pointer (it replaces EIP).  The AMD64 processor can read data at an address relative to the RIP at any one time using an 32-bit offset value.  Up to now relative addressing was only used for jumps to a new instruction place.  For this to work, it probably makes no difference to the processor whether the data is in executable or non-executable areas and the processor may in fact be blind to this.  Since RIP-relative addressing could shorten code considerably (no need for large displacement values to be included in the instruction) the assembler will need to use it as much as possible.  There is probably a lot of scope here for optimisation either automatically or manually.<br /><br /><strong><u>Pointers</u></strong><br />These point to a particular place in memory (they are an address of something in memory).  In 64-bit mode all pointers will be 64 bits, whereas in 32-bit mode they are 32 bits.  In practice, I don't think this will matter much.  For example in 64-bit mode to put the address of a particular string (labelled &quot;MyString&quot;) into RBX you would use (GoAsm syntax):-<br /><pre><code>MOV RBX,ADDR MyString<br /></code></pre>which is similar to its 32-bit equivalent:-<br /><pre><code>MOV EBX,ADDR MyString<br /></code></pre><br /><strong><u>New instructions</u></strong><br />There are only a handful of new instructions required.<br /><br /><strong><u>Net gloom</u></strong><br />There has been a lot of gloom in earlier threads about Longhorn, and Microsoft's apparent wish to envelop us all in .net fog in due course.  To my mind, Microsoft will be ensuring that current Windows executables will work on future machines and Windows operating systems.  That must mean that the API's will always be available in DLLs even if in the far future this works through some sort of wrapper.  If this is right it means that Windows assembler programmers will be able to continue to program normally into the far future.  Also I believe 32-bits will not just disappear. Many applications will work perfectly well in 32-bits, even under future 64-bit systems (and I am not talking about Itanium).  They will not need the extra power available from 64-bits.</div>
    <div class="meta">Posted on 2004-01-03 03:37:42 by jorgon</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=16630&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=16630&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="16630" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=16630&amp;page=2">&gt;</a><a href="../?id=16630&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>