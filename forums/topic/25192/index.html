<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Syntax Parsing - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25192" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25192">Syntax Parsing</a></p>
   <div class="post" id="post-184395">
    <div class="subject"><a href="#post-184395">Syntax Parsing</a></div>
    <div class="body">Has anyone come across any decent information for text parsing for syntax and key words?<br /><br />Since compilers do this in a couple of passes, I thought this would be a good place to ask the question.&nbsp; What I&#39;m fishing for here is some sort of structured approach that is easily expandable for new syntax.&nbsp; Otherwise I would simply write something like IF &#39;A&#39; and &#39;B&#39; and &#39;C&#39; then syntax#1.<br /><br />Regards,<br />:NaN:</div>
    <div class="meta">Posted on 2006-08-10 18:46:36 by NaN</div>
   </div>
   <div class="post" id="post-184399">
    <div class="subject"><a href="#post-184399">Re: Syntax Parsing</a></div>
    <div class="body">Hi Nan,<br /><br />The 2 main methods used are BNF and fully parenthesized.<br /><br />Most modern compilers use the BNF recursive (stack based) algorithm or some form of it. Most parse engines like YACC, BISON, etc. generate some form of BNF.<br /><br />There are many &quot;hits&quot; for these two terms on Google, but many of the BNF explanations use the term &quot;fully parenthesied&quot; either loosely or in a different context than I am using it. I found one book on the fully parenthesied method over 10 years ago, but cannot remember the name of it. There are tons of books and articles on the BNF method.<br /><br />Fully parenthesized is an older form but has several advantages including better determination of where a syntax error has occurred in an expression. It is generally easier to generate code from this type of parser. It is mainly out of vogue because is is not inherently recursive.<br /><br />Most modern compilers do this in a single pass generating asm code for a backend assembler.<br /><br />Mike</div>
    <div class="meta">Posted on 2006-08-11 01:07:13 by msmith</div>
   </div>
   <div class="post" id="post-184401">
    <div class="subject"><a href="#post-184401">Re: Syntax Parsing</a></div>
    <div class="body">Source code -&gt; abstract syntax tree -&gt; optimizers (generic as well as arch-dependant) -&gt; direct object file output without use of intermediate assembly step.<br /></div>
    <div class="meta">Posted on 2006-08-11 04:30:18 by f0dder</div>
   </div>
   <div class="post" id="post-184418">
    <div class="subject"><a href="#post-184418">Re: Syntax Parsing</a></div>
    <div class="body">Thanks.. That pointed me in the right direction for enough info to work with.<br /><br />Regards,<br />:NaN:</div>
    <div class="meta">Posted on 2006-08-11 21:48:58 by NaN</div>
   </div>
   <div class="post" id="post-184419">
    <div class="subject"><a href="#post-184419">Re: Syntax Parsing</a></div>
    <div class="body">I got one of those books on how compilers work, Designing Compilers in C, or something like that.&nbsp; They have a section on just this topic.&nbsp; You&#39;ll probably find the book at the library.&nbsp; It&#39;s easier to read than the Aho book.</div>
    <div class="meta">Posted on 2006-08-11 22:30:00 by drhowarddrfine</div>
   </div>
  </div>
 </body>
</html>