<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Spasm users, a question or two please... And some other stuf - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=479" />
  <link rel="prev" href="../?id=479&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=479">Spasm users, a question or two please... And some other stuf</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=479&amp;page=1" style="">&laquo;</a><a href="../?id=479&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="479" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-3014">
    <div class="subject"><a href="#post-3014">Spasm users, a question or two please... And some other stuf</a></div>
    <div class="body">I am very much a code reuse person for the obvious reason that I hate writing the same code over and over again. You can store bits of code in other files and paste them in when needed, you can include files into your code if it helps to keep large blocks of complex code out of your logic code but the bottom line is if a language cannot build blocks of binary code that can be reused, its still in the novelty range, Libraries are one of the great leaps forward in creating programs of any reasonable size.<br /><br />Bogdans case is an unusual one in that he is building a complete game from scratch and there would not be that much code available for it. Trivial things like numerical conversions, parsing routines, search algorithms, display functions and the like are not things that you need to keep recreating, it just makes your coding slow and unreliable if you dont construct building blocks to make bigger things with.<br /><br />The notions of scope being bandied around here are unusual, I see no reason why an assembler should aviod things like scope control, MASM has had this for years and if you need the capacity, its there to use. If assembler was restricted to a global bag of binary, it would have died out years ago. You can write assembler that way but it is rarely ever done and only on very small programs and it does not work any better or build any smaller.<br /><br />High level concepts like code reuse, LOCAL variables, true modularity in libraries are the things that make a modern assembler very powerful and extendable to the extent of being able to compete within a timeframe that can be acheived, going backwards is a formula to send assembler to the scrap heap.<br /><br />For Kenny, you have no alternative but to learn how assembler hangs together and if you want to build a piece of assembler that is generated by a C compiler, you will need to understand how it works in MASM. get the form of startup code from the existing range of MASM code, produce the include files that you need for the API calls and make it compatible with MASM and you should be able to build it.<br /><br />Pursuing simpicity will not help you here, you have chosen to ry and use generated assembler, not written assembler so you have to learn how to convert it.<br /><br />Regards,<br /><br /><a href="mailto:hutch@pbq.com.au">hutch@pbq.com.au</a></div>
    <div class="meta">Posted on 2001-08-04 21:29:02 by hutch--</div>
   </div>
   <div class="post" id="post-3020">
    <div class="subject"><a href="#post-3020">Spasm users, a question or two please... And some other stuf</a></div>
    <div class="body">Bogdan, I don't want to have a war against you... but I don't think<br />you're right. Sure, every man has his own opinions and all, so don't<br />tell me I'm wrong... I have quite a couple years of experience, at<br />least enough to know what I'm talking about.<br /><br />If you think copy&amp;paste is what I talk about when saying reusable<br />code, please think again. This is probably the worst form...<br /><br /><div class="quote"><br />BTW. i just wonder why any beginner and C oriented programmer<br />are so much intrested into less typeing? <br /></div><br /><br />Not only beginners, also pros. And why? Because if it is done *right*,<br />it can save you so much time... WITHOUT being a bad and limiting<br />thing. But I don't suppose you know anything about this?<br /><br /><div class="quote"><br />Because of &quot;organization&quot; we have a lots of &quot;modular&quot; files into<br />diffrent folders.  Each file does specific actions and deals with<br />diffrent parts of our application....I thought its a good ideea at<br />the moment (somehow i still belive it is...damn me  )<br /></div><br /><br />If you can't keep head or tails of your different modules, you obviously<br />did something wrong at some stage. Did you do any pre-design<br />before you started hacking away?<br /><br /><div class="quote"><br />Now it is very hard to find one procedure in so many files and it<br />takes us some time until we find ALL links between diffrent<br />modules both physical and (worst) logical... <br /></div><br /><br />Well, the whole idea of modularisation is to keep the links *FEW*.<br />Too keep as much code/data local as possible... otherwise there<br />aren't many reasons to modularise, considering the fast hard drives<br />and processors these days...<br /><br /><div class="quote"><br />So you see Modularization, encapsulation, code reuse and this<br />stuff are not necesary good....strange enough this is true esp for<br />huge applications <br /></div><br /><br />Sure, a hammer can also be bad if you don't know how to use it<br />correctly... you might end hammering your fingers...<br /><br /><div class="quote"><br />There is a PROC at the hardware processor level: CALL/RET and<br />Stack mechanism (they added ENTER and LEAVE there lately)<br /></div><br /><br />PROC is not at hardware level. DUH there is call and ret.. but this<br />still does not handle stack automation at ALL.<br /><br /><div class="quote"><br />Once again i have to point it out that helpers like<br />LOCALS. .IF .WHILE and such are a big problem for beginners andget them confused... <br /></div><br /><br />They actually make life easier. A bit too easy sometimes. So easy<br />that people don't know wtf is going on behind their backs.<br /><br /><br />Kenny, you really DO need to understand locals. They aren't all<br />that hard, and they are VERY important when dealing with multiple<br />threads et al.</div>
    <div class="meta">Posted on 2001-08-04 22:40:52 by f0dder</div>
   </div>
   <div class="post" id="post-3036">
    <div class="subject"><a href="#post-3036">Spasm users, a question or two please... And some other stuf</a></div>
    <div class="body">Fodder, any link to some consistant Application that you wrote<br />in Assembly with a programmers'group? What kind of Application?<br /><br />Do you mostly build the same kind of Application? (i mean, for<br />example, do you write games mostly, or dBases for clients?).<br /><br /><br />Betov.</div>
    <div class="meta">Posted on 2001-08-05 03:13:41 by Betov</div>
   </div>
   <div class="post" id="post-3042">
    <div class="subject"><a href="#post-3042">Spasm users, a question or two please... And some other stuf</a></div>
    <div class="body">My problem here is not really to know if Modular programming is good<br />or bad. I begun programming in 1968 and have written enough Asm things<br />before SpAsm to be fully convinced that Modular programming is nothing<br />but the wide open door to make Asm as bad as C is.<br /><br />A difficulty in this thread is that we are debating two things at a <br />time: The modularity in user source(s) management and the containement <br />of code with the symbols scope concept (and these two are not necessary <br />bounded to each other).<br /><br />My problem, as an Assembler author, is that i have both to satisfy<br />users wishes and to maintain some consistancy in the overall design,<br />while i mean to push my &quot;Specific Programming style&quot; concept.<br /><br /><br />For the point of Containement (i mean, for example, what Fodder said<br />about a chunk of code being turned unable to call some 'private'<br />routine of another chunk), as i do not see any reason for doing this,<br />i will certainaly never make it possible.<br /><br />Now, for the Sources management, and for the possibility of reusing<br />previously written routines, though i consider it bad as a whoole,<br />i *do* have to make it possible because this is on the user choice.<br /><br />There are several ways for this. One way is what i did in the <br />Menu option: It opens a Dialog where the user have access to various <br />Snipets. Once choosen, the Snippet is in the ClipBoard, ready to be <br />pasted in the source. At my opinion, this is elegant solution because <br />the user *sees* what he is doing, he can modify and adapt to actual <br />specific requirements what he has just pasted.<br /><br />I have some plan to implement an additional feature that would allow<br />the user to have his own Snippets collection in an external file, that<br />would be added to the Dialog internal Snippets Data. May be, putting <br />it all external would be better...<br /><br />Now, i would like some answer, from a Modules_concept_defender about<br />my ante-previous post (about the &quot;pseudo-include&quot; thing, making chunks<br />of source appear as as many different files managed a Tab Control).<br />Would this be a practice solution? I wish opinions on this point <br />because the implementation of this feature raises very difficult <br />design problems that i do not wish to solve for nope (for example, the<br />Tab Data must be &quot;Tree organised&quot; in order to hold cases like 1000 of <br />different Pseudo-files... a killing problem).<br /><br /><br />Betov.</div>
    <div class="meta">Posted on 2001-08-05 04:47:18 by Betov</div>
   </div>
   <div class="post" id="post-3063">
    <div class="subject"><a href="#post-3063">Hi</a></div>
    <div class="body">First Betov,<br />============<br /><br />i still dont think a unique big file is useable for a huge app like HE game....<br /><br />include files are a usefull tool even with all its problems ... not haveing this in your assembler will sure be a problem IMHO<br /><br />But i agree about containment: ANY assembler that will restrict my freedom to call/jump to any code section i so like will go stright to my recycle bin .... where it deserves to be <br /><br />Assembler is about full control and power, let HLL deal with containment encapsualtion and stuff, i will do those better with my own brain.<br /><br /><br /><br />Then fodder,<br />==============<br /><br />I also dont want to start a war against you here <br /><br />and of course i am programming from the beginning just before Z80 and I8080 come into the market (from about 20years) and have done LOTS of programs using ASM, C, Pascal, FORTH, DBase, FoxPro VisualFoxpro, Visual C++, Basic, Prolog,LISP...<br /><br />I wrote all kinds of applications from GAMES to DATABASES and RADAR simulators or SECURITY applications<br /><br />I have my own software company, big companys from Romania use my database programs every day, lots of small ones also....etc etc<br /><br />The huge ASM application we where talking about (HE game) is 300.000 lines of code...do you realize that? holding my heads and tails inside it its a breeze .... belive me we have modularized it the best way we could ...<br /><br />you still dont get it that PROC is just a macro gizmo for CALL/RET and ENTER/LEAVE and this instructions do affect the STACK...no problem you will in time ...<br /><br />Stack automation? you mean nameing labels for local variables...well this label management was the first job of the assembler compiler and will still be its job long time from now....<br /><br />If you want less typeing into programming....well .... maybe you choosed the wrong job after all....<br /><br />keep the links &quot;few&quot; in a 300k lines program? maybe in a little proggy that does allmost nothing...maybe<br /><br />I guess i know to use the &quot;hammer&quot; and the &quot;needle&quot; never damaged my fingers until now ;)<br /><br />LOCALS are very simple to explain:<br /><br />They are variables keept on STACK for just as long the procedure is running (until the RET or LEAVE instructions that is)<br /><br />This is done by adjusting (substracting) the Stack ESP pointer with the size of ALL local vars...the base for local vars is saved in EBP register for easy acces (usually) <br /><br />so all subsequent PUSH/ POP or other Stack management is done &quot;under&quot; your local variables and do not modify them<br /><br />using those local variables by names is rezolved by the assembler that replaces their names with the corect ESP based address like ,  etc<br /><br />when the procedure terminates it restores the stack pointer to the correct value and so efectively will overwrite your locals if new operations are done on STACK from now on....<br /><br />i might say this way of working with procedures was my first thing i have learned from my ASM teacher (long time ago) using M80 one of the first Microsoft Macro Assemblers</div>
    <div class="meta">Posted on 2001-08-05 11:29:53 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-3067">
    <div class="subject"><a href="#post-3067">Spasm users, a question or two please... And some other stuf</a></div>
    <div class="body">Betov, I was once implementing a 32bit debugger for a custom dos extender<br />a while back. The debugger is lot now though :(, so is the extender.<br />None of the source was ever released, and the project didn't have<br />a name. I still curse at microsoft for writing such a buggy &quot;OS&quot; (dos).<br />Hard drive crashes suck.<br />I have also helped with bits and pieces of Qlib, a nice environment<br />for developing 32bit dos applications. I didn't play a very big part<br />there, though. Yes, this was all asm.<br /><br />Currently, I'm implementing a toy OS kernel.<br />And this is a place where modularity and containment (imho) is important.<br />I want the VMM to be a subsystem of its own, process management<br />to be a subsystem of its own, etc. The less inter-module links there<br />are, the easier will the kernel be to manage, and the easier can I<br />change the internals of one subsystem without having to change<br />hundreds of other locations.<br /><br />As for the rest of my programming project, this is mostly C code.<br />The commercial projects I work on at the moment don't have a need<br />for asm. There aren't really any speed critical parts. One of the applications<br />has a lot of complicated &quot;engineering-style&quot; math, but I'm not working<br />on that part of the program. And rewriting the math to asm would<br />be a VERY demanding task, especially since the engineers constantly<br />make little tweaks and whatnot to the formulas. And they aren't<br />really time sensitive, either. They're already about a thousand times<br />(or more) faster than the engineers sitting with calculators, pen<br />and paper... which is what they did before our app was developed.<br /><br /><br />Bogdan... I was a bit annoyed (for various reasons) when I wrote<br />the the last post, so I sounded a bit more harsh than I intended.<br />I don't really have anything to add, except that I very well know what<br />proc does and how locals work...</div>
    <div class="meta">Posted on 2001-08-05 12:37:41 by f0dder</div>
   </div>
   <div class="post" id="post-3094">
    <div class="subject"><a href="#post-3094">Spasm users, a question or two please... And some other stuf</a></div>
    <div class="body">Kenny:<br /><br />First, asm sources from M$ C compiler don't contain the necessary 'includelib' lines. Either update the output code (using hutchs-- function to lib tool, for example), or add the libs from the VS configuration dialog (linker tab) to the commandline (see example below).<br /><br />Second, you need to include a defaultlib switch, for the C library crap.<br /><br />Third, I don't own the DirectX SDK, so I couldn't link it successfully. It's your job.<br /><br />Ex. (from compile.bat)<br /><br />link -subsystem:windows -defaultlib:libc.lib -libpath:d:\vs98\vc98\lib -libpath:d:\vs98\vc98\mfc\lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib vertices.obj<br /><br />Note that DX8 libs are missing here.<br />Hopefully this works...</div>
    <div class="meta">Posted on 2001-08-05 17:47:34 by -SMK-</div>
   </div>
   <div class="post" id="post-3099">
    <div class="subject"><a href="#post-3099">Spasm users, a question or two please... And some other stuf</a></div>
    <div class="body">Try that in a sec, but I want to offer some advice.<br /><br />Bogdan, instead of C&amp;P, why not just define your re-usable code as a macro? That's what I used to do when I was programming in SpAsm.<br /><br /><br /><br />Then everytime I wanted to mov eax, ebx I would just type myreusablecode instead.<br /><br />I forget the code in MASM, but it's something like:<br />myreusablecode MACRO<br />mov eax, ebx<br />myreusablecode ENDM<br /><br />in C++, I just use #define :)</div>
    <div class="meta">Posted on 2001-08-05 19:08:57 by Kenny</div>
   </div>
   <div class="post" id="post-3103">
    <div class="subject"><a href="#post-3103">Spasm users, a question or two please... And some other stuf</a></div>
    <div class="body">YOU'RE A GENIUS! Man I don't know how to thank you!<br /><br />I guess you could say that you solved about 10 of my problems that have been plaguing me the last 6 months just with one message :)<br /><br />:alright: :alright: :alright: <br /><br />P.S. Was this common knowledge and I was just in the dark?</div>
    <div class="meta">Posted on 2001-08-05 19:41:20 by Kenny</div>
   </div>
   <div class="post" id="post-3142">
    <div class="subject"><a href="#post-3142">Spasm users, a question or two please... And some other stuf</a></div>
    <div class="body">Wow , I've created a rather busy thread.<br /><br /><br />Anyway, I'm not against modulization, I just wish it was made easier to do.  I'd break my program into files like:<br /><br />main.asm   &lt;-WinMaim!!<br /><br />file.asm      &lt;-file I/O<br /><br />paint.asm   &lt;-screen Out, vid ops<br /><br />And so on....<br /><br />But it's a pain to use a global value/proc define in main.asm in file.asm.  Or to call a proc defined in file.asm in main.asm.<br /><br />Now I add in paint.asm, and pretty soon the maze of EXTREN and PUBLIC definition start to get a little confusing.  EXTRENDEF?  The MASM32 help file is of no help, it's short and cryptic.  More of a definition than an explanation.  <br /><br />I've tried searching for clear explanations, but have found very little information.  I've looked at several multi-file assembly sources, but have seen no consistent method of resolving extrenals.<br /><br />Would it be good to put all my globals into a global stucture?  Then I could declare the stucture PUBLIC?<br /><br />hutch-- says it is easy &quot;once you get use to it&quot;.  Multi-file programming, weather it is assmebly or C++ or &lt;lang&gt;,  its the hardest thing for me to get used to(learn).  For some reason, the abstract idea that just because it is defined in another file, it is out of scope, I can grasp.  The way to overcome it is the problem.</div>
    <div class="meta">Posted on 2001-08-06 14:53:51 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-3143">
    <div class="subject"><a href="#post-3143">Spasm users, a question or two please... And some other stuf</a></div>
    <div class="body">CoffeeDrinker, I would have an include file per asm file that defines<br />the public function definitions. Which are probably easiest to get<br />working via the PROTO command in masm.</div>
    <div class="meta">Posted on 2001-08-06 15:06:06 by f0dder</div>
   </div>
   <div class="post" id="post-3146">
    <div class="subject"><a href="#post-3146">Spasm users, a question or two please... And some other stuf</a></div>
    <div class="body">Yea, just include the file and call the procs or use the macros. Everything should be global if you use only one base file:<br /><br />main.asm<br /> -&gt; includes paint.asm<br /> -&gt; includes files.asm<br />... ect...</div>
    <div class="meta">Posted on 2001-08-06 15:16:02 by Kenny</div>
   </div>
   <div class="post" id="post-3148">
    <div class="subject"><a href="#post-3148">Spasm users, a question or two please... And some other stuf</a></div>
    <div class="body">I don't include the asm files. I include the .inc files, and assemble<br />the asm files separately, then link them all together. That's the way<br />*I* like it :). But do whatever suits you.</div>
    <div class="meta">Posted on 2001-08-06 15:28:08 by f0dder</div>
   </div>
   <div class="post" id="post-3161">
    <div class="subject"><a href="#post-3161">Quick</a></div>
    <div class="body">Just a simple quick answer ....<br /><br />Kenny,<br />========<br />we dont use macros instead of C&amp;P because the code in not EXACTLY the same, LOOKs somehow the same but is slightly diffrent every time...<br /><br />Using Parameters is just  to slow ;) because this code is important: either AI for thousands of units, or BLIT routines, or unit's data access routines<br /><br />Besides Macros MUST be placed in front on the include files...and this annoyes me and makes them harder to find in the big code..<br /><br />But we use macros and parameters to ease our task from time to time...<br /><br />F0dder,<br />=========<br />Sorry man i also did not wanted to be or sound harsh either ....<br /><br />Please excuse.<br /><br />we dont use the &quot;link many object files&quot; method because we still want to be able to search in the big .LST files all appearances of a function call or variable references<br /><br />and we change many files many times anyway</div>
    <div class="meta">Posted on 2001-08-06 20:26:40 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-3162">
    <div class="subject"><a href="#post-3162">Spasm users, a question or two please... And some other stuf</a></div>
    <div class="body"><div class="quote"><br />Sorry man i also did not wanted to be or sound harsh either .... <br /></div><br /><br />bogdan, that's perfectly OK. Neither of us have english as our native<br />language, and I bet both of us have a LOT of things to look after,<br />and can be a &quot;bit&quot; stressed at times :). I don't know of a nice way,<br />either, to create a full listing when using separate object files. But<br />my experience is that the map files generated by the GNU linker is<br />better than the microsoft linker. Also, look for a product called &quot;bugtrapper&quot;<br />... it does a lot of nice things :).</div>
    <div class="meta">Posted on 2001-08-06 20:43:36 by f0dder</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=479&amp;page=1" style="">&laquo;</a><a href="../?id=479&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="479" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>