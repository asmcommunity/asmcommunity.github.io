<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>(Helpful) String Procedures - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=3416" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=3416">(Helpful) String Procedures</a></p>
   <div class="post" id="post-22632">
    <div class="subject"><a href="#post-22632">(Helpful) String Procedures</a></div>
    <div class="body">I'm working on a few helpful string procedures (due to all the parsing questions -- including questions that I had).  I hope this helps someone -- also optimization points are welcome.<br /><br />3 procedures so far:<br /><br />Find_First_Of<br />Find_Last_Of<br />Find_First_Not_Of   <br />required arguements:<br />1) the string to be searched<br />2) the separators to be found<br />3) the starting position<br /><br />How it works:<br />1) Find_First_Of<br />returns the first instance of a given separator<br />assuming the sentence was: &quot;Hello everyone how are you doing&quot;<br />and the separator was &quot; &quot; (a space) it would return the 5 in eax<br />first letter in the string is at starting position (0)<br /><br />2)Find_Last_Of<br />find last occurance of separator<br /><br />3)Find_First_Not_Of<br />find first occurance of something that's not a separator<br /><br /><pre><code><br />; #########################################################################<br />;<br />;               Find First Of / Find_Last_Of / Find_First_Not_Of<br />; Suppose you had a string -- a paragraph of prose, perhaps -- and you wanted<br />; break it up into individual words.  You would need to find where the <br />; separators were, and those could be any of a number of different characters;<br />; there could be spaces, commas, periods, colons and so on.  This is a procedure<br />; where for any one of a given set of characters occurs in a string -- this could<br />; tell you where the delimiter for the words are.  I hope this makes someones<br />; life a little easier &#58;-&#41;  Cheers, Walter Reid &#40;Sliver&#41;<br />;<br />;<br />; Works like this&#58;<br />; invoke Find_First_Of, string to be searched, separators, starting position<br />; returns the locations of the first separator in eax<br />;<br />; invoke Find_First_Of, string to be searched, separators, starting position<br />; returns the location of the last separator in eax<br />; #########################################################################<br /><br />      .386<br />      .model flat, stdcall<br />      option casemap &#58;none   ; case sensitive<br /><br />; #########################################################################<br /><br />      include \masm32\include\windows.inc<br /><br />      include \masm32\include\user32.inc<br />      include \masm32\include\kernel32.inc<br />      include \masm32\include\masm32.inc<br />      include \masm32\include\debug.inc<br />            <br />      includelib \masm32\lib\user32.lib<br />      includelib \masm32\lib\kernel32.lib<br />      includelib \masm32\lib\masm32.lib<br />      includelib \masm32\lib\debug.lib<br />      <br />      Main   PROTO<br />      Find_First_Of  PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD<br />      Find_Last_Of  PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD<br />      Find_First_Not_Of  PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD      <br /><br />      Find_Last_Of proc lpszSource&#58;DWORD, lpszTarget&#58;DWORD, StartPos&#58;DWORD<br />      LOCAL val&#58;DWORD<br /><br />        mov val, 0          <br />        mov edi, lpszTarget<br />        xor ecx, ecx<br />        <br />        start_scan&#58;<br />            mov esi, lpszSource<br />            add esi, StartPos<br />            add esi, ecx           <br />            <br />        next&#58;    <br />            mov al, byte ptr &#91;esi&#93;<br />            inc esi<br />            <br />            cmp al,  byte ptr &#91;edi&#93;<br />            je found<br />            inc ecx<br /><br />            cmp al, 0<br />            jne next<br /><br />        found2&#58;<br />            mov ecx, val<br />            inc edi<br />            cmp byte ptr &#91;edi&#93;, 0<br />            jne start_scan<br />            jmp done<br />            <br />        found&#58;<br />            mov val, ecx<br />            jmp found2<br /><br />        done&#58;<br />            mov eax, ecx<br />            <br />            ret<br />    Find_Last_Of endp<br /><br /><br />    Find_First_Of proc lpszSource&#58;DWORD, lpszTarget&#58;DWORD, StartPos&#58;DWORD<br />        LOCAL val&#58;DWORD<br />        <br />        mov val, 100<br />        <br />        mov edi, lpszTarget<br />        <br />        start_scan&#58;<br />            mov esi, lpszSource<br />            add esi, StartPos<br />            xor ecx, ecx<br />            <br />        next&#58;<br />            mov al, byte ptr &#91;esi&#93;<br />            inc esi<br /><br />            cmp ecx, val<br />            je found<br /><br />            cmp al,  byte ptr &#91;edi&#93;<br />            je found<br />            inc ecx<br />            <br />            cmp al, 0<br />            je start_scan<br /><br />            jmp next<br /><br />        found&#58;<br />            mov val, ecx<br />            xor ecx, ecx<br />         <br />            inc edi<br />            cmp byte ptr &#91;edi&#93;, 0<br />            jne start_scan<br />            <br />        done&#58;<br />            mov eax, val<br />            add eax, StartPos<br />            ret<br />    Find_First_Of endp<br /><br />    Find_First_Not_Of proc lpszSource&#58;DWORD, lpszTarget&#58;DWORD, StartPos&#58;DWORD<br />        LOCAL val&#58;DWORD<br />        <br />        mov val, 100     <br />        xor ecx, ecx<br />        <br />        mov esi, lpszSource<br />        add esi, StartPos<br />            <br />        start_scan&#58;<br />            mov edi, lpszTarget<br />            <br />        next&#58;<br />            mov al, byte ptr &#91;esi&#93;<br />            cmp al, 0<br />            je done<br />            <br />            cmp al,  byte ptr &#91;edi&#93;<br />            jne no_match<br /><br />        match&#58;<br />            inc esi<br />            cmp byte ptr &#91;esi&#93;, 0<br />            je done<br /><br />            inc ecx<br />            jmp start_scan<br /><br />        no_match&#58;<br />            inc edi<br />            cmp byte ptr &#91;edi&#93;, 0<br />            jne next<br />                        <br />            mov val, ecx<br />            <br />        done&#58;<br />            mov eax, val<br />            add eax, StartPos<br />            <br />            ret<br />    Find_First_Not_Of endp<br />; #########################################################################<br /><br />    .data<br />      Msg1        db &quot;Hi! My name is Walter.  How are you?&quot;,0<br />      Msg2        db &quot;aeioufaefeaio&quot;,0      <br />      Txt         db &quot; ?.!,&quot;,0<br />      Txt2        db &quot;uoaei&quot;,0<br />; #########################################################################<br /><br /><br />    .code<br /><br />    start&#58;<br />      invoke Main<br />      invoke ExitProcess,0<br /><br />Main proc<br /><br />    invoke Find_First_Of, ADDR Msg1, ADDR Txt, 0<br />    PrintText &quot;Find the first separator &#40; ?.!,&#41;  -- starting at pos 0&quot;<br />    PrintText &quot;in the sentance 'Hi! My name is Walter.  How are you?'&quot;<br />    PrintDec eax<br />    PrintText &quot;Value returned is from the first character &#40;0&#41;&quot;<br /><br />    PrintText &quot; &quot;<br />    PrintText &quot; &quot;<br />    <br />    invoke Find_First_Of, ADDR Msg1, ADDR Txt2, 14<br />    PrintText &quot;Find the first vowel &#40;uoaei&#41; -- starting at pos 14 &#40;space after 'is'&#41;&quot;<br />    PrintText &quot;in the sentance 'Hi! My name is Walter.  How are you?'&quot;<br />    PrintDec eax<br />    PrintText &quot;Value returned is from the first character &#40;0&#41;&quot;<br /><br />    PrintText &quot; &quot;<br />    PrintText &quot; &quot;<br />    PrintText &quot; &quot;<br />    PrintText &quot; &quot;<br />    <br />    invoke Find_Last_Of, ADDR Msg1, ADDR Txt, 0<br />    PrintText &quot;Find the last separator &#40; ?.!,&#41; -- starting at pos 0&quot;<br />    PrintText &quot;in the sentance 'Hi! My name is Walter.  How are you?'&quot;<br />    PrintDec eax<br />    PrintText &quot;Value returned is from the first character &#40;0&#41;&quot;<br /><br />    PrintText &quot; &quot;<br />    PrintText &quot; &quot;<br />    <br />    invoke Find_Last_Of, ADDR Msg1, ADDR Txt2, 0<br />    PrintText &quot;Find the last vowel &#40;uoaei&#41; -- starting at pos 0&quot;<br />    PrintText &quot;in the sentance 'Hi! My name is Walter.  How are you?'&quot;<br />    PrintDec eax<br />    PrintText &quot;Value returned is from the first character &#40;0&#41;&quot;<br /><br /><br />    PrintText &quot; &quot;<br />    PrintText &quot; &quot;<br />    PrintText &quot; &quot;<br />    PrintText &quot; &quot;<br />    <br />    invoke Find_First_Not_Of, ADDR Msg2, ADDR Txt2, 0<br />    PrintText &quot;Find the first not of separator &#40;uoaei&#41; -- starting at pos 0&quot;<br />    PrintText &quot;in the sentance 'aeioufaefeaio'&quot;<br />    PrintDec eax<br />    PrintText &quot;Value returned is from the first character &#40;0&#41;&quot;<br /><br />    PrintText &quot; &quot;<br />    PrintText &quot; &quot;<br />    <br />    invoke Find_First_Not_Of, ADDR Msg2, ADDR Txt2, 6<br />    PrintText &quot;Find the first not of separator &#40;uoaei&#41; -- starting at pos 6&quot;<br />    PrintText &quot;in the sentance 'aeioufaefeaio'&quot;<br />    PrintDec eax<br />    PrintText &quot;Value returned is from the first character &#40;0&#41;&quot;<br />    <br />            <br />    ret<br /><br />Main endp<br /><br />    end start<br /><br /><br /><br /><br />    <br /><br /><br /></code></pre></div>
    <div class="meta">Posted on 2002-02-03 11:00:33 by Sliver</div>
   </div>
   <div class="post" id="post-22639">
    <div class="subject"><a href="#post-22639">(Helpful) String Procedures</a></div>
    <div class="body">Very nice indeed, here's another useful function:<br /><br /><pre><code>ParseString Proc uses ebx esi edi pStr&#58;DWORD,sPos&#58;DWORD,pBuf&#58;DWORD<br />	InRange MACRO a,b,c<br />		lea ecx,&#91;a-b&#93;<br />		lea edx,&#91;a-c-1&#93;<br />		xor edx,ecx<br />		or  ebx,edx<br />	EndM<br />	<br />	Ranges MACRO<br />		InRange eax,'a','z'<br />		InRange eax,'0','9'<br />		InRange eax,'A','Z'<br />	EndM<br />	<br />	mov esi,pStr<br />	mov edi,pBuf<br />	add esi,sPos<br />	assume esi&#58;ptr byte<br />	assume edi&#58;ptr byte<br />	<br />	@@&#58;	movzx eax,&#91;esi&#93;<br />		xor ebx,ebx<br />		test eax,eax<br />		jz  nlb<br />		Ranges<br />		js @F<br />	inc esi<br />	jmp @B<br />	<br />	@@&#58;	mov &#91;edi&#93;,al		<br />		inc esi<br />		inc edi<br />		<br />		movzx eax,&#91;esi&#93;<br />		xor ebx,ebx<br />		test eax,eax<br />		jz  nlb<br />		Ranges<br />	js @B		<br />	<br />nlb&#58;mov &#91;edi&#93;,0	<br />	mov eax,esi<br />	sub eax,pStr		<br />ret<br />ParseString EndP</code></pre> <br /><br />Usage is simple, call the function with a pointer to the string you wish to parse, the start position and a pointer to a buffer to contain the parse part.<br /><br />.data<br />szTest db &quot;This is a test&quot;,0<br /><br />.data?<br />Pos dd ?<br />Buf db 64 dup (?)<br /><br />.code<br />Invoke ParseString,addr szTest,0,addr Buf<br />mov Pos,eax ; Buf contains &quot;This&quot;,0<br /><br />Invoke ParseString,addr szTest,Pos,addr Buf<br />mov Pos,eax ; Buf contain &quot;is&quot;,0<br /><br />...<br />... <br /><br />Hope someone finds it helpful.</div>
    <div class="meta">Posted on 2002-02-03 11:32:01 by Eóin</div>
   </div>
   <div class="post" id="post-22654">
    <div class="subject"><a href="#post-22654">(Helpful) String Procedures</a></div>
    <div class="body">This isn't really a &quot;gem&quot; nor it is helpful but it's fun :grin: he! he! he!<br /><br />String Reverse<br />Output: dlrow leurc olleh<br /><br /><pre><code><br />.386<br />.MODEL flat, stdcall<br />option casemap&#58;none<br /><br />INCLUDE \masm32\include\windows.inc<br />INCLUDE \masm32\include\kernel32.inc<br />INCLUDELIB \masm32\lib\kernel32.lib<br />INCLUDE \masm32\include\user32.inc<br />INCLUDELIB \masm32\lib\user32.lib<br /><br />.data<br /><br />    mystringdata db &quot;hello cruel world&quot;, 0<br />    buffer       db 20 DUP&#40;0&#41;<br />    <br />.code<br /><br />Start&#58;<br /><br />    invoke lstrlen, OFFSET mystringdata<br />    mov ecx, eax<br />    mov esi, OFFSET mystringdata<br />    mov edi, OFFSET buffer<br />    <br />    @@&#58;<br />        dec ecx<br />        mov dl, BYTE ptr &#91;esi+ecx&#93;<br />        mov BYTE ptr&#91;edi&#93;, dl <br />        inc edi<br />        or ecx, ecx<br />        ja @b<br />    <br />    invoke MessageBox, 0, OFFSET buffer, 0, 0<br />    invoke ExitProcess, 0<br />    <br />END Start<br /></code></pre><br /><br />Reverses string until the center character then reverses up the string again.<br />Output: dlrow leuel world<br /><br /><pre><code><br />.386<br />.MODEL flat, stdcall<br />option casemap&#58;none<br /><br />INCLUDE \masm32\include\windows.inc<br />INCLUDE \masm32\include\kernel32.inc<br />INCLUDELIB \masm32\lib\kernel32.lib<br />INCLUDE \masm32\include\user32.inc<br />INCLUDELIB \masm32\lib\user32.lib<br /><br />.data<br /><br />    mystringdata db &quot;hello cruel world&quot;, 0<br />    <br />.code<br /><br />Start&#58;<br /><br />    invoke lstrlen, OFFSET mystringdata<br />    mov ecx, eax<br />    mov esi, OFFSET mystringdata<br />    mov edi, OFFSET mystringdata<br />    <br />    @@&#58;<br />        dec ecx<br />        mov dl, BYTE ptr &#91;esi+ecx&#93;<br />        mov BYTE ptr&#91;edi&#93;, dl <br />        inc edi<br />        or ecx, ecx<br />        ja @b<br />        <br />    mov BYTE ptr&#91;edi&#93;, cl<br />    <br />    invoke MessageBox, 0, OFFSET mystringdata, 0, 0<br />    invoke ExitProcess, 0<br />    <br />END Start</code></pre><br /><br />You can remove that mov ecx, eax and change some parts of the code. I love to use ecx in this way :grin:</div>
    <div class="meta">Posted on 2002-02-03 13:00:31 by stryker</div>
   </div>
   <div class="post" id="post-22661">
    <div class="subject"><a href="#post-22661">(Helpful) String Procedures</a></div>
    <div class="body">Move String...<br /><br /><a target="_blank" href="http://www.asmcommunity.net/board/showthread.php?threadid=3418">http://www.asmcommunity.net/board/showthread.php?threadid=3418</a></div>
    <div class="meta">Posted on 2002-02-03 13:54:26 by stryker</div>
   </div>
   <div class="post" id="post-22696">
    <div class="subject"><a href="#post-22696">(Helpful) String Procedures</a></div>
    <div class="body">umberg6007 ,<br /> <br />Don't be so hasty! I need to reverse strings all the time. So I'll definitely have a look at your routine for any new tricks. <br /><br />DNA, as you may already know, has two strands that are paired up in a way so that you only have to describe one &amp; the other is the &quot;reverse complement&quot; which you can calculate quite easily by reversing the string then swapping a&lt;--&gt;t &amp; c&lt;--&gt;g. Suffice it to say that there are many situations where it's quicker to actually do this calculation up front than to fudge it on the fly.</div>
    <div class="meta">Posted on 2002-02-03 17:14:16 by rafe</div>
   </div>
   <div class="post" id="post-22700">
    <div class="subject"><a href="#post-22700">(Helpful) String Procedures</a></div>
    <div class="body">rafe,<br /><br />DNA sounds like a lot of fun in the string parsing area, tons of room for creative thinking in byte twiddling.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-02-03 17:30:19 by hutch--</div>
   </div>
   <div class="post" id="post-22703">
    <div class="subject"><a href="#post-22703">(Helpful) String Procedures</a></div>
    <div class="body">DNA? I didn't know that it's the same at the opposite end starting at the center, must have slipped my mind. Time to dig up my biology book :grin: he! he! he!</div>
    <div class="meta">Posted on 2002-02-03 17:49:42 by stryker</div>
   </div>
   <div class="post" id="post-22705">
    <div class="subject"><a href="#post-22705">(Helpful) String Procedures</a></div>
    <div class="body">truth is I'm over my head &amp; drowning  &amp; loving it all the same ... But the boss likes the work so far &amp; I keep the post-docs in line... mostly. I only had one formal programming course in my life &amp; I'm already having to deal with big-O, wacked algos on strings &amp; trees on a daily basis... data mining (what me gloat?)<br /><br />String stuff is a must in bio-comp but the field is rapidly moving to Diff eq systems to model the molecules. :grin: more to learn<br /><br />Unfortunately, I've got little time to actually code in asm but the creative stuff &amp; learning is fun. Work's a handful &amp; the current home situation doesn't allow me much down time right now.<br /><br />hutch--, Oh yea, that string search variant I was rambling on about a few weeks back is already in the lit... no IP issues. more later in another thread.<br /><br />mmm.... not from the center oops ! caught me skimming. humble apologies. but restriction enzymes look for....</div>
    <div class="meta">Posted on 2002-02-03 18:06:01 by rafe</div>
   </div>
  </div>
 </body>
</html>