<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Intervent Crypt routine - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30649" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=30649">Intervent Crypt routine</a></p>
   <div class="post" id="post-214924">
    <div class="subject"><a href="#post-214924">Intervent Crypt routine</a></div>
    <div class="body">We have developed an application in Delphi, and there the small database can be Encrypted.&nbsp; We new that the encryption is no fool proof, but we were in an impression that it is not easily breakable. To our horror we discovered that the crypting of this database is actually nothing. The password can be encrypted and found in <strong>less than a minute</strong>. There are even tools available im web to do just that.<br /><br />The Encrypting and Decrypted is done in this way:<br /><br />procedure EncryptBuffer(var Buffer; NumBytes: Integer;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Key1: Byte; Key2: Byte);<br />begin<br />&nbsp; asm<br />&nbsp; &nbsp;  PUSH&nbsp; &nbsp;  EDI<br />&nbsp; &nbsp;  PUSH&nbsp; &nbsp;  EBX<br />&nbsp; &nbsp;  XOR&nbsp; &nbsp; &nbsp; &nbsp; ECX,ECX<br />&nbsp; &nbsp;  MOV&nbsp; &nbsp; &nbsp; &nbsp; ECX,NumBytes<br />&nbsp; &nbsp;  JCXZ&nbsp; &nbsp;  @@Done<br />&nbsp; &nbsp;  XOR&nbsp; &nbsp; &nbsp; &nbsp; EBX,EBX<br />&nbsp; &nbsp;  MOV&nbsp; &nbsp; &nbsp; BL,Key1<br />&nbsp; &nbsp;  MOV&nbsp; &nbsp; &nbsp; &nbsp; BH,Key2<br />&nbsp; &nbsp;  MOV&nbsp; &nbsp; &nbsp; EDI,Buffer<br />&nbsp;  @@Loop1:<br />&nbsp; &nbsp;  XOR&nbsp; &nbsp; &nbsp; &nbsp; EAX,EAX<br />&nbsp; &nbsp;  MOV&nbsp; &nbsp; &nbsp;  AL,<br />&nbsp; &nbsp;  XOR&nbsp; &nbsp; &nbsp; &nbsp; AL,BL<br />&nbsp; &nbsp;  XOR&nbsp; &nbsp; &nbsp; &nbsp; AL,BH<br />&nbsp; &nbsp;  MOV&nbsp; &nbsp; &nbsp;  ,AL<br />&nbsp; &nbsp;  INC&nbsp; &nbsp; &nbsp; &nbsp; BL<br />&nbsp; &nbsp;  DEC&nbsp; &nbsp; &nbsp; &nbsp; BH<br />&nbsp; &nbsp;  INC&nbsp; &nbsp; &nbsp;  EDI<br />&nbsp; &nbsp;  LOOP&nbsp; &nbsp; &nbsp; @@Loop1<br />&nbsp;  @@Done:<br />&nbsp; &nbsp;  POP&nbsp; &nbsp; &nbsp; &nbsp; EBX<br />&nbsp; &nbsp;  POP&nbsp; &nbsp; &nbsp; &nbsp; EDI<br />&nbsp; end;<br />end;<br /><br />procedure DecryptBuffer(var Buffer; NumBytes: Integer;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Key1: Byte; Key2: Byte);<br />begin<br />&nbsp; asm<br />&nbsp; &nbsp;  PUSH&nbsp; &nbsp;  EDI<br />&nbsp; &nbsp;  PUSH&nbsp; &nbsp;  EBX<br />&nbsp; &nbsp;  XOR&nbsp; &nbsp; &nbsp; &nbsp; ECX,ECX<br />&nbsp; &nbsp;  MOV&nbsp; &nbsp; &nbsp;  ECX,NumBytes<br />&nbsp; &nbsp;  JCXZ&nbsp; &nbsp;  @@Done<br />&nbsp; &nbsp;  XOR&nbsp; &nbsp; &nbsp; &nbsp; EBX,EBX<br />&nbsp; &nbsp;  MOV&nbsp; &nbsp; &nbsp;  BL,Key1<br />&nbsp; &nbsp;  MOV&nbsp; &nbsp; &nbsp;  BH,Key2<br />&nbsp; &nbsp;  MOV&nbsp; &nbsp; &nbsp; &nbsp; EDI,Buffer<br />&nbsp;  @@Loop1:<br />&nbsp; &nbsp;  XOR&nbsp; &nbsp; &nbsp; &nbsp; EAX,EAX<br />&nbsp; &nbsp;  MOV&nbsp; &nbsp; &nbsp;  AL,<br />&nbsp; &nbsp;  XOR&nbsp; &nbsp; &nbsp; &nbsp; AL,BH<br />&nbsp; &nbsp;  XOR&nbsp; &nbsp; &nbsp; &nbsp; AL,BL<br />&nbsp; &nbsp;  MOV&nbsp; &nbsp; &nbsp; &nbsp; ,AL<br />&nbsp; &nbsp;  INC&nbsp; &nbsp; &nbsp; &nbsp; BL<br />&nbsp; &nbsp;  DEC&nbsp; &nbsp; &nbsp; &nbsp; BH<br />&nbsp; &nbsp;  INC&nbsp; &nbsp; &nbsp; &nbsp; EDI<br />&nbsp; &nbsp;  LOOP&nbsp; &nbsp; &nbsp;  @@Loop1<br />&nbsp;  @@Done:<br />&nbsp; &nbsp;  POP&nbsp; &nbsp; &nbsp; &nbsp; EBX<br />&nbsp; &nbsp;  POP&nbsp; &nbsp; &nbsp; &nbsp; EDI<br />&nbsp; end;<br />end;<br /><br />So my question is, is there anything we could <strong>quite fast and simply </strong> do to alter this code in some way, so at least those ready made tools could not break it? Maybe one more assembler line somewhere there in between?<br />Of course the right way to do would be to switch to some other database. But the conversion will take time, and some instant, temporary help would be great.<br /><br />In the old days I used to know something about CHASM assembler. But the time has passed, and I am not able to change anything in that code.<br /><br />Any suggestions, please?<br />Mark</div>
    <div class="meta">Posted on 2011-08-27 11:23:02 by Mark Laitila</div>
   </div>
   <div class="post" id="post-214925">
    <div class="subject"><a href="#post-214925">Re: Intervent Crypt routine</a></div>
    <div class="body">Making the code more convoluted will not help, as the implementation/approach is obviously flawed.<br /><br />If you want real encryption, look into provable encryption algorithm such as <a target="_blank" href="http://en.wikipedia.org/wiki/Blowfish_%28cipher%29">Blowfish</a>. Find an open-source implementation, link to its encryption/decryption functions, and be done with it.<br /><br />The other -- more intrusive -- option is to utilize an alternative database software such as <a target="_blank" href="http://www.sqlite.org/">SQLite</a>, which have <a target="_blank" href="http://www.hwaci.com/sw/sqlite/see.html">encryption capabilities</a>.</div>
    <div class="meta">Posted on 2011-08-27 12:42:33 by SpooK</div>
   </div>
   <div class="post" id="post-214926">
    <div class="subject"><a href="#post-214926">Re: Intervent Crypt routine</a></div>
    <div class="body">For AES library see Brian Gladman&#039;s <a target="_blank" href="http://www.gladman.me.uk/">Cryptographic Technology</a> website.&nbsp; Good stuff there.</div>
    <div class="meta">Posted on 2011-08-27 13:32:43 by p1ranha</div>
   </div>
   <div class="post" id="post-214927">
    <div class="subject"><a href="#post-214927">Re: Intervent Crypt routine</a></div>
    <div class="body"><div class="quote"><br />Making the code more convoluted</div><br />Those existing &quot;password recovery&quot; tools know and have the original ASM-code and that way they have had easy way in. My idea was not to try to make the <em>code and logic more messy</em>. Just <strong>a bit different</strong> would be fine, so the recovery utility would not work.<br />I completely understand the remaining weakness. <br /><br /><div class="quote">If you want real encryption, look into provable encryption algorithm</div> Of course, there are tons of crypting routines. Take a week or two, and you will know much more about encryption and the use of those libraries than you knew earlier:)<br /><br /><div class="quote">The other -- more intrusive -- option is to utilize an alternative database </div><br />I also did mention in the original question that it would be an real option <br /><br />At this point I really was after <u>a quick hack</u>. Maybe one more XOR:ing with some value, to get some modification to the existing logic.<br /><br />Thanks for the suggestions anyway<br />Mark</div>
    <div class="meta">Posted on 2011-08-27 16:25:53 by Mark Laitila</div>
   </div>
   <div class="post" id="post-214928">
    <div class="subject"><a href="#post-214928">Re: Intervent Crypt routine</a></div>
    <div class="body">Yes, there is something quick and easy.<br /><br />Random Number Generator algorithms are always predictable, given an initial known seed value. That is to say, they spew out the same sequence of &#039;random&#039; values, given the same starting value.<br /><br />Pick one, give it a known seed, and then xor your data with generated randoms - have the decoder do the same thing, starting with the same known seed.<br /><br />Now you have a private key encryption, using an unknown cypher.<br /></div>
    <div class="meta">Posted on 2011-08-27 22:05:48 by Homer</div>
   </div>
   <div class="post" id="post-214929">
    <div class="subject"><a href="#post-214929">Re: Intervent Crypt routine</a></div>
    <div class="body"><div class="quote">Random Number Generator algorithms are always predictable, given an initial known seed value. </div> They are predictable, but once you do not have the ASM code nor the 20 char long password, it should not be childrens play. Once someone unassembles our application code and finds the logic, then they will get through.<br /><br />My original thought was, that maybe there is some 2 lines of change to the ASM code, that would prevent the existing cracker apps to get through. <br />And one would at least have to unassembe our app. Is this kind of simple ASM change possible?<br /><br /><div class="quote">That is to say, they spew out the same sequence of &#039;random&#039; values, given the same starting value.</div> I have used for years string crypting so, that I first add 10 chars of truly randomized data to the beginning. And after that I add the actual string encrypted, with simple crypt algorithm. Every crypted character feeds <u>new seed value</u> to the next char to be crypted. <br /><br />I am not quite sure if that included ASM snippet uses this logic or not? With my encryption, those those 10 random chars at the beginning seem to be enough to keep 99.5% of snoopers away.<br /><br />By reading the ASM snippet, I think it is not possible to use this kind of approach at all? Add let&#039;s say 2 byte to the beginning? As the routine logic takes f.ex 20 bytes in and it has to put exactly 20 bytes out too.<br /><br /><div class="quote">Pick one, give it a known seed, and then xor your data with generated randoms - have the decoder do the same thing, starting with the same known seed.</div> If this was a real suggestion, then <u>my</u> first problem I can&#039;t do that in ASM.<br /><br />Maybe there is no quick hack available at all?&nbsp; <br /><br />I thank for all the comments I have got this far.<br />Mark</div>
    <div class="meta">Posted on 2011-08-28 04:12:40 by Mark Laitila</div>
   </div>
   <div class="post" id="post-214930">
    <div class="subject"><a href="#post-214930">Re: Intervent Crypt routine</a></div>
    <div class="body"><div class="quote"><br />If this was a real suggestion, then <u>my</u> first problem I can&#039;t do that in ASM.</div><br /><br />Then don&#039;t do it in asm?<br />A bit of random and xoring bytes together can be done in most languages.<br />I really don&#039;t see why your encryption code was written in ASM in the first place.<br />It doesn&#039;t make it more secure.</div>
    <div class="meta">Posted on 2011-08-28 04:46:48 by Scali</div>
   </div>
   <div class="post" id="post-214931">
    <div class="subject"><a href="#post-214931">Re: Intervent Crypt routine</a></div>
    <div class="body"><div class="quote">Then don&#039;t do it in asm?</div> All right, this may be a good advice, with modern compute force.<br /><br /><div class="quote"><br />I really don&#039;t see why your encryption code was written in ASM in the first place.<br />It doesn&#039;t make it more secure.</div> According to those third party developers, security has not originally (8..10 yrs ago) played the major role with that language choice. But the <strong>speed</strong> has. <br />SQL query scanning through some 200+ MByte database, there he fractions of a second start to matter.<br /><br />After all, the advice on the first line may be the one I really should follow now.<br /><br />Thanks<br />Mark<br /></div>
    <div class="meta">Posted on 2011-08-28 06:29:23 by Mark Laitila</div>
   </div>
   <div class="post" id="post-214932">
    <div class="subject"><a href="#post-214932">Re: Intervent Crypt routine</a></div>
    <div class="body"><div class="quote"><br />According to those third party developers, security has not originally (8..10 yrs ago) played the major role with that language choice. But the <strong>speed</strong> has. <br />SQL query scanning through some 200+ MByte database, there he fractions of a second start to matter.</div><br /><br />The code you posted was extremely trivial asm, not something that a reasonbly decent compiler cannot do.<br />Sure, if it was highly optimized SSE code, then it may be out of reach of a compiler... But this was just vanilla 386 code, nothing fancy.<br />Writing something in ASM doesn&#039;t automatically make it faster.<br />On the contrary, most programmers cannot optimize as well as a modern compiler.<br />For example, your code uses the &#039;loop&#039; instruction, which is considerably slower than just sub ecx, 1 jnz. Something every compiler knows, but apparently not the person who wrote that asm.<br /><br />I could write a C-version and compile it, and benchmark to prove the point... but I don&#039;t think I have to.</div>
    <div class="meta">Posted on 2011-08-28 07:40:22 by Scali</div>
   </div>
   <div class="post" id="post-214935">
    <div class="subject"><a href="#post-214935">Re: Intervent Crypt routine</a></div>
    <div class="body">Okay, I had some time to kill, so I decided to write a C version.<br />I hope you realize that the algo is fully reversible, and EncryptBuffer is exactly the same as DecryptBuffer().<br /><br />In C, the entire algo can be put on one line, it is THAT simple.<br />Here is my full test program:<br /><pre><code><br />#include &quot;stdafx.h&quot;<br />#include &lt;Windows.h&gt;<br />#include &lt;string&gt;<br /><br />void EncryptBuffer(char* Buffer, unsigned int NumBytes, char Key1, char Key2)<br />{<br />&nbsp; __asm<br />&nbsp; {<br />	 PUSH&nbsp; &nbsp;  EDI<br />	 PUSH&nbsp; &nbsp;  EBX<br />	 XOR&nbsp; &nbsp; &nbsp; &nbsp; ECX,ECX<br />	 MOV&nbsp; &nbsp; &nbsp; &nbsp; ECX,NumBytes<br />	 JCXZ&nbsp; &nbsp;  Done<br />	 XOR&nbsp; &nbsp; &nbsp; &nbsp; EBX,EBX<br />	 MOV&nbsp; &nbsp; &nbsp; BL,Key1<br />	 MOV&nbsp; &nbsp; &nbsp; &nbsp; BH,Key2<br />	 MOV&nbsp; &nbsp; &nbsp; EDI,Buffer<br />&nbsp;  Loop1:<br />	 XOR&nbsp; &nbsp; &nbsp; &nbsp; EAX,EAX<br />	 MOV&nbsp; &nbsp; &nbsp;  AL,<br />	 XOR&nbsp; &nbsp; &nbsp; &nbsp; AL,BL<br />	 XOR&nbsp; &nbsp; &nbsp; &nbsp; AL,BH<br />	 MOV&nbsp; &nbsp; &nbsp;  ,AL<br />	 INC&nbsp; &nbsp; &nbsp; &nbsp; BL<br />	 DEC&nbsp; &nbsp; &nbsp; &nbsp; BH<br />	 INC&nbsp; &nbsp; &nbsp;  EDI<br />	 LOOP&nbsp; &nbsp; &nbsp; Loop1<br />&nbsp;  Done:<br />	 POP&nbsp; &nbsp; &nbsp; &nbsp; EBX<br />	 POP&nbsp; &nbsp; &nbsp; &nbsp; EDI<br />&nbsp; }<br />}<br /><br />void DecryptBuffer(char* Buffer, unsigned int NumBytes, char Key1, char Key2)<br />{<br />	__asm<br />	{<br />	 PUSH&nbsp; &nbsp;  EDI<br />	 PUSH&nbsp; &nbsp;  EBX<br />	 XOR&nbsp; &nbsp; &nbsp; &nbsp; ECX,ECX<br />	 MOV&nbsp; &nbsp; &nbsp;  ECX,NumBytes<br />	 JCXZ&nbsp; &nbsp;  Done<br />	 XOR&nbsp; &nbsp; &nbsp; &nbsp; EBX,EBX<br />	 MOV&nbsp; &nbsp; &nbsp;  BL,Key1<br />	 MOV&nbsp; &nbsp; &nbsp;  BH,Key2<br />	 MOV&nbsp; &nbsp; &nbsp; &nbsp; EDI,Buffer<br />&nbsp;  Loop1:<br />	 XOR&nbsp; &nbsp; &nbsp; &nbsp; EAX,EAX<br />	 MOV&nbsp; &nbsp; &nbsp;  AL,<br />	 XOR&nbsp; &nbsp; &nbsp; &nbsp; AL,BH<br />	 XOR&nbsp; &nbsp; &nbsp; &nbsp; AL,BL<br />	 MOV&nbsp; &nbsp; &nbsp; &nbsp; ,AL<br />	 INC&nbsp; &nbsp; &nbsp; &nbsp; BL<br />	 DEC&nbsp; &nbsp; &nbsp; &nbsp; BH<br />	 INC&nbsp; &nbsp; &nbsp; &nbsp; EDI<br />	 LOOP&nbsp; &nbsp; &nbsp;  Loop1<br />&nbsp;  Done:<br />	 POP&nbsp; &nbsp; &nbsp; &nbsp; EBX<br />	 POP&nbsp; &nbsp; &nbsp; &nbsp; EDI<br />	}<br />}<br /><br />void EncryptBufferC(char* pBuffer, unsigned int length, char key1, char key2)<br />{<br />	for (unsigned int i = 0; i &lt; length; i++)<br />		pBuffer<em> ^= (key1++ ^ key2--);<br />}<br /><br />int _tmain(int argc, _TCHAR* argv&#91;])<br />{<br />	char Key1 = 0x34;<br />	char Key2 = 0x73;<br /><br />	char testString&#91;] = &quot;Testing testing&quot;;<br /><br />	LARGE_INTEGER frequency, startTime, endTime;<br /><br />	QueryPerformanceFrequency(&amp;frequency);<br /><br />	QueryPerformanceCounter(&amp;startTime);<br /><br />	int len = strlen(testString);<br /><br />	for (int i = 0; i &lt; 1000000; i++)<br />		EncryptBuffer( testString, len, Key1, Key2 );<br /><br />	QueryPerformanceCounter(&amp;endTime);<br /><br />	printf(&quot;ASM time: %f\n&quot;, (endTime.QuadPart-startTime.QuadPart)/(double)frequency.QuadPart);<br /><br />	QueryPerformanceCounter(&amp;startTime);<br /><br />	for (int i = 0; i &lt; 1000000; i++)<br />		EncryptBufferC( testString, len, Key1, Key2 );<br /><br />	QueryPerformanceCounter(&amp;endTime);<br /><br />	printf(&quot;C time: %f\n&quot;, (endTime.QuadPart-startTime.QuadPart)/(double)frequency.QuadPart);<br /><br />	getchar();<br /><br />	return 0;<br />}<br /></code></pre><br /><br />The results on my Core2 Duo laptop speak volumes:<br />ASM time: 0.073059<br />C time: 0.032137<br /><br />The simple C version is more than twice as fast.</div>
    <div class="meta">Posted on 2011-08-30 07:55:06 by Scali</div>
   </div>
   <div class="post" id="post-214936">
    <div class="subject"><a href="#post-214936">Re: Intervent Crypt routine</a></div>
    <div class="body"><div class="quote">The simple C version is more than twice as fast.<br /></div> Thanks, not bad at all, for a voluntary work:) I thought that ASM would do it better especially with this kind of tasks. But the Compiler Optimizations, they really seem to be quite good now a days.<br /><br />&gt; void EncryptBufferC(char* pBuffer, unsigned int length, char key1, <br />&gt;char&nbsp; key2)<br /><br />I believe I am able to convert that to Delphi/Pascal.&nbsp; I&#039;ll have to go a bit further anyway, and use algorithm that feeds the new seed after every character, so the crypting will not be quite as simple to break . I again hope this fix will not choke the DB engine.<br /><br />I really should switch to a new DB engine, but that would have tons of side effects and code re-writing. I&#039;ll have to go this way right now, and with simple fixes try to make the crypting a bit tighter.<br /><br />Thanks for the benchmark sample.<br />Mark</div>
    <div class="meta">Posted on 2011-08-30 11:28:04 by Mark Laitila</div>
   </div>
   <div class="post" id="post-214937">
    <div class="subject"><a href="#post-214937">Re: Intervent Crypt routine</a></div>
    <div class="body">Hello,<br />If you want a simple modification you can for example insert ROL and ROR instructions like this:<br /><pre><code>...<br />&nbsp; &nbsp;  XOR&nbsp; &nbsp; &nbsp; AL,BL<br />&nbsp; &nbsp;  ROL AL,3<br />&nbsp; &nbsp;  XOR&nbsp; &nbsp; &nbsp; AL,BH<br />...<br />&nbsp; &nbsp;  XOR&nbsp; &nbsp; &nbsp; &nbsp; AL,BH<br />&nbsp; &nbsp;  ROR AL,3<br />&nbsp; &nbsp;  XOR&nbsp; &nbsp; &nbsp; &nbsp; AL,BL<br />...<br /></code></pre>This of course means old passwords will not work,&nbsp; but then you might as well use completely different algorithm?!<br /><br />Now another question is:<br /><div class="quote"><br />The password can be encrypted and found in less than a minute</div><br />What is the relation between password and key1 key2. How is the password stored and converted to key1 and key2?<br />If the password is entered in plain text by the user (<span style="font-size:14pt>?</span>) you can for example add an extra prefix check + shuffling&nbsp; for the plain text password.<br />old: 1234ABCD<br />new: MARK-ABCD1234<br /><br />This way the converted key1key2 would be the same and the algorithm would remain unchanged, but the actual plain text password would be different. The hack-user would still be able to find old password but it wouldn&#039;t be acceptable by the program. <br /><br />Please explain password - key1.key2 relation.<br /></div>
    <div class="meta">Posted on 2011-08-30 11:37:28 by drizz</div>
   </div>
   <div class="post" id="post-214938">
    <div class="subject"><a href="#post-214938">Re: Intervent Crypt routine</a></div>
    <div class="body">Well, it&#039;s been a while since I&#039;ve done Delphi, but I think it will be something like this:<br /><br /><pre><code><br />for i := 0 to NumBytes<br />begin<br />&nbsp; Buffer<em> := Buffer<em> xor Key1 xor Key2;<br />&nbsp; Key1 := Key1 + 1;<br />&nbsp; Key2 := Key2 - 1;<br />end<br /></code></pre><br /><br /><div class="quote"><br />I thought that ASM would do it better especially with this kind of tasks. But the Compiler Optimizations, they really seem to be quite good now a days.</div><br /><br />Well, it&#039;s not assembly&#039;s fault, it&#039;s the fault of whoever wrote that code.<br />They didn&#039;t do a good job of optimizing. Not just &#039;now a days&#039; either. &#039;loop&#039; has been a slow instruction at least since the Pentium, back in 1992. So I bet that even some 20 years ago, the compiler would have beaten this assembly code.<br /><br />It is possible to come up with code that is as good or better than the compiler. But not every programmer can do that. And a lot of these programmers either don&#039;t even know that they can&#039;t, or they refuse to admit it.</div>
    <div class="meta">Posted on 2011-08-30 11:40:10 by Scali</div>
   </div>
  </div>
 </body>
</html>