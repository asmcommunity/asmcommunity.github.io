<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>String ASSEMBLY tutorial - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17393" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=17393">String ASSEMBLY tutorial</a></p>
   <div class="post" id="post-134676">
    <div class="subject"><a href="#post-134676">String ASSEMBLY tutorial</a></div>
    <div class="body">this tutorial was based on a tutorial downloaded from <a target="_blank" href="www.alloces.cjb.net">www.alloces.cjb.net</a><br />Thanks vit$oft , Donkey , Rotivc , and all  the others  for  helping ! its steel open !<br /><br />   - - - - - - - - - - - - - - - - - - - - -<br />     String ASSEMBLY tutorial   <br />     NASM  Syntax  by  Nguga  <br />   - - - - - - - - - - - - - - - - - - - - - <br /><br />Five commands to copy , move and scan strings<br />=============================================<br /><br /> this for byte<br /> - - - - - - -<br /><br /> LODSB Load          Byte  string<br /> STOSB Write         Byte  string<br /> MOVSB Move         Byte  string<br /> SCASB Scan          Byte  string for e.g. characters<br /> CMPSB Compare   Byte  two strings with each other<br /><br /> this for word<br /> - - - - - - -<br /><br /> LODSW Load         Word  string<br /> STOSW Write        Word  string<br /> MOVSW Move        Word  string<br /> SCASW Scan          Word  string for e.g. characters<br /> CMPSW Compare   Word  two strings with each other<br /><br /><br /> this for dword<br /> - - - - - - -<br /><br /> LODSD Load        Dword  string<br /> STOSD Write       Dword  string<br /> MOVSD Move       Dword  string<br /> SCASD  Scan        Dword  string for e.g. characters<br /> CMPSD Compare  Dword  two strings with each other<br /><br /><br />Rules<br />=============================================<br /><br />- Source String must be loaded on ESI register<br /><br />- Destination String is loaded on EDI register<br /><br />- Registers ESI and EDI  are  incremented or<br />  decremented automatically during execution<br />  of string commands <br /><br />- When we repeat string commands , then the <br />  ECX  register is used as a counter<br /><br /><br />- If we want to go from right to left on the String<br />                        <br />  we have to set the direction flag to 1 ( DF=1 ) <br />  and the assembler instruction to do that is:<br /><br />  STD   ;===&gt; set direction flag to 1  (DF=1)<br />  <br /><br /><br /><br />- if we want to go from left to right of the String<br />                        <br />  we must set the direction flag to 0   ( DF=0 )<br />  and the assembler instruction to do that is:<br /><br />  CLD   ;===&gt; set direction flag to 0 (DF=0)<br /><br /><br /><br /><br />- REP INSx/OUTSx does not change DX register (data go repeatedly from/to the same I/O port)<br /><br />- When a string instruction is used without REPx prex, (E)CX register does not change.<br /><br />- Even when REPx prefix is not used, (E)SI,(E)DI registers are changed.<br /><br />- LODSX, STOSx, MOVSx, INSx, OUTSx never change flags.<br /><br />- SCASx, CMPSx do set flags corresponding to the last B/W/D scanned, compared.<br /><br />- LODSx may be used with REPx prefix but it is useless.<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />LOADSB or LOADSW or LOADSD     ( loads in EAX )<br />===============================================<br /><br />- loads EAX with the String in ESI<br /><br />- then after this instruction The ESI register is incremented <br />  or decremented depending of the state of the direction flag.<br />  is incremented or decremented by Byte or Word depending on<br />  the instruction we use LOADSB ( byte ) or LOADSW ( word )<br />  <br /><br />Litle Example <br />- - - - - - - -<br /><br />A string will be scaned  until there is a &quot;,&quot; <br />or the end of string is reached.<br /><br /><br /><br /><br />%include &quot;\lab\vasm\inc\nagoa.inc&quot;<br /><br /><br /><br /><br />..start:<br /><br />section data<br />String db &quot;K2?34&quot;,0<br />String_lenght equ $-String      ; lenght of string<br />section code<br /><br />mov ecx,String_lenght           ; lenght of the string to to ecx (counter)<br />mov esi,String                  ; ESI points to first element (&quot;K&quot;) in the string<br />cld                             ; lets go from left to right :)<br /><br />stringloop:<br />	LODSB                   ; load EAX with the first element of the String<br />	cmp al,&quot;?&quot;              ; since we used a byte we compare with lower part of eax ( al )<br />	loopne stringloop       ; loop if not equal limit of the loop is = ecx <br />        cmp al,&quot;?&quot;<br />        jne .out_<br />        call MessageBoxA ,NULL,&quot;works !&quot;,&quot;msg&quot;,MB_OK<br />        xor eax,eax<br />        ret<br />.out_<br />call MessageBoxA ,NULL,&quot;no bad !&quot;,&quot;msg&quot;,MB_OK<br />xor eax,eax<br />ret<br />     <br />        <br />        <br /><br /><br /><br /><br /><br /><br /><br /><br /><br />STOSB  or STOSW  or STOSD  ( loads in EDI )<br />===============================================<br /><br />- copy the content of EAX to EDI<br />  a byte STOSB  or a word STOSW<br /><br /><br />mov ecx , String_lenght     ; will loop String_lenght times<br /><br />mov esi ,String             ; ESI is pointing to first element of the string<br /><br />lodsb                       ;take one character from the source on esi to eax<br />stosb                       ;and copy it from eax to edi<br />loop ourloop                ;loop until ecx &gt; 0<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />MOVSB  or MOVSW  or MOVSD  ( move string )<br />=========================================<br /><br />- move the contents of ESI to EDI<br /><br /><br /><br /><br />Litle Example <br />- - - - - - - - <br /><br />- A string is copied bitwise<br /><br /><br />%include &quot;\lab\vasm\inc\nagoa.inc&quot;<br /><br /><br /><br /><br />..start:<br />section data<br /><br />	Quelle db    &quot;The string that will be copied!&quot;,0<br />	Quelle_1 equ $-Quelle       <br />	Ziel resb Quelle_1          ;the destination buffer<br />	<br />section code<br /><br />	mov esi,Quelle       ;save the address of Quelle in esi<br />	mov edi,Ziel         ;save the address of Ziel in edi<br />	mov ecx,Quelle_1<br />	cld                     ;from left to right<br /><br />copy:<br />	movsb              ;Quelle ---&gt; Ziel<br />	loop copy<br /><br />cmp  esi,Ziel<br />jne .out_<br />call MessageBoxA , NULL,esi,&quot;ESI -&gt; Ziel !&quot;,MB_OK<br />xor eax,eax<br />ret<br /><br />.out_<br />call MessageBoxA , NULL,esi,&quot;ESI not Ziel :( ...&quot;,MB_OK<br />xor eax,eax<br />ret<br />	<br /><br /><br /><br /><br /><br /><br /><br />REP instruction           ( Similar to LOOP )<br />==============================================<br /><br />- with REP command the instruction is repeated <br />  until the counter ECX is zero .<br />  (the loop is not executed when ECX=0 )<br /><br />- after every execution of REP the ecx register is<br />  decremented by 1<br /><br />-  REP variants<br />   -----------  <br />-  REPE   repeat while Equal<br />-  REPNE  repeat while Not Equal<br /><br />( REP    commands works more quickly than the LOOP command )<br /><br /><br /><br />Example<br />-------<br /><br /><br />	mov ecx,String_Lenght    ; will loop String_Lenght times = ecx <br />	rep movsb                ; movsb  will be executed until ecx=0<br />	<br /><br /><br /><br /><br /><br /><br />- several variants for REP<br /><br /><br /><br />SCASB  or  SCASW or  SCASD      ( scan strings )<br />===============================================<br /><br /><br />- compare the content of EAX with the content of EDI<br /><br />- Internally the content of EAX is subtratcted from the content<br />  of EDI but the result isn't saved. <br /><br />- The EDI register is incremented or decremented after every SCAS command<br /><br /><br /><br /><br />Litle Example<br />--------------<br /><br />- The content of a string is scaned until there is<br />  a &quot;z&quot; or the end of the string is reached.<br /><br /><br /> <br />%include &quot;\lab\vasm\inc\nagoa.inc&quot;<br /><br /><br /><br />code32<br /><br />..start:<br /><br />section data<br /><br />	string1 db &quot;abczdef&quot;,0<br />	string1_1 equ $-string1    ;length of string1<br />	caracter db &quot;z&quot;,0<br /><br />section code<br />  <br />	mov edi,string1            ; edi is pointing to &quot;a&quot;<br />        mov al,&quot;z&quot;                <br />	mov ecx,string1_1          ; number of loops to do in ecx<br />        cld                        ;  go from from left to right<br />	repne scasb                ; scan string in edi if not equal<br />	je caracter_found          ; is caracter &quot;z&quot; ? if so stop if not go if ecx not 0<br /><br /><br />        call MessageBoxA , NULL,&quot;caracter ?z? NOT found ! &quot;,edi,MB_OK<br />        xor eax,eax<br />        ret<br /><br />caracter_found:<br />call MessageBoxA , NULL,&quot; caracter ?z? found !&quot;,edi,MB_OK<br />xor eax,eax<br />ret<br /><br /><br /><br /><br /><br /><br />CMPSB  or CMPSW  or CMPSD  ( COMPARE STRING )<br />======================================<br /><br />- compare the content of ESI with EDI<br /><br />- The result of the comparison is saved in the<br />  status register .<br /><br /><br /><br /><br /><br />Litle Example <br />--------------<br /><br />- Two strings are compared to equality<br /><br /><br /><br /><br />%include &quot;\lab\vasm\inc\nagoa.inc&quot;<br /><br /><br /><br /><br /><br />..start:<br /><br />section data<br /><br />	String1 db &quot;ola meu&quot;,0<br />	String2 db &quot;ola meu&quot;,0<br />	StringSize  equ $-String2                      ;length of String<br />	<br />section code<br /><br />mov esi,String1<br />mov edi,String2<br />mov ecx,StringSize+1<br />cld                                   ; from left to right ... <br />repe cmpsb<br />or ecx,ecx<br />jnz notcorrect<br />call MessageBoxA , NULL,&quot;yes string are equal !&quot;,&quot;msg&quot;,MB_OK<br />xor eax,eax<br />ret<br /><br />notcorrect:<br />call MessageBoxA , NULL,&quot;string are NOT equal !&quot;,&quot;msg&quot;,MB_OK<br />xor eax,eax<br />ret<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />=============================================<br /><br /><br /><br />just an example not using this INSTRUCTIONS :)<br /><br /><br /><br />%include &quot;\lab\vasm\inc\nagoa.inc&quot;<br /><br /><br /><br />..start:<br /><br /><br />section data<br />password db &quot;ola amigo&quot;,0<br />user_pass db &quot;ola amigo&quot;,0<br />user_pass_1 equ  $ - user_pass -1   ; lenght user_pass<br />section code<br /><br /><br />cmpString:<br />push ecx<br />push ebx<br />push edi<br />push esi<br /><br />mov  ecx,user_pass_1<br />mov  eax,password<br />mov  ebx,user_pass<br /> <br />.good_caracter_go_next<br />xor edi,edi<br />xor esi,esi<br />mov edi,<br />mov esi,<br />cmp di,si<br />je    .increment_decrement_stuff<br />jmp .BadBoy<br />.increment_decrement_stuff<br />inc  eax<br />inc  ebx<br />dec ecx<br />cmp ecx,0<br />je .GoodBoy  <br />jmp .good_caracter_go_next<br /><br />                                             <br /><br />.BadBoy<br />call MessageBoxA , NULL,&quot;BAD BOY !!! &quot;,&quot;INFO&quot;,MB_OK<br />jmp .out_<br /><br />.GoodBoy<br /><br />call MessageBoxA , NULL,&quot;GOOD BOY !!! &quot;,&quot;INFO&quot;,MB_OK<br /><br />.out_<br />pop esi<br />pop edi<br />pop ebx<br />pop ecx<br />xor eax,eax<br />ret<br /><br />=============================================</div>
    <div class="meta">Posted on 2004-02-24 07:25:07 by Nguga</div>
   </div>
   <div class="post" id="post-134678">
    <div class="subject"><a href="#post-134678">String ASSEMBLY tutorial</a></div>
    <div class="body">please feel free to improve this tutorial in case any errors or to add more info :)</div>
    <div class="meta">Posted on 2004-02-24 07:26:57 by Nguga</div>
   </div>
   <div class="post" id="post-134680">
    <div class="subject"><a href="#post-134680">String ASSEMBLY tutorial</a></div>
    <div class="body">Take a look at <a target="_blank" href="http://www.asmcommunity.net/board/phpwiki/index.php/AllAboutStrings">http://www.asmcommunity.net/board/phpwiki/index.php/AllAboutStrings</a><br /><br />Ye,s Alloces tutorial was the tutorial that got me into understanding the string opcodes.</div>
    <div class="meta">Posted on 2004-02-24 07:45:55 by roticv</div>
   </div>
   <div class="post" id="post-134690">
    <div class="subject"><a href="#post-134690">String ASSEMBLY tutorial</a></div>
    <div class="body">Nice work, Nguga. A few typos:<br />LOADSB should read LODSB etc., STOSSD should read STOSD.<br />Sometimes a picture or ASCII-Art will tell more then a bunch of lines.<br /><br />Some more rules which may not seem obvious to beginners:<br /><ul><br />[*] REP INSx/OUTSx does not change DX register (data go repeatedly from/to the same I/O port)<br />[*] When a string instruction is used without REPx prefix, (E)CX register does not change.<br />[*] Even when REPx prefix is not used, (E)SI,(E)DI registers are changed.<br />[*] LODSX, STOSx, MOVSx, INSx, OUTSx never change flags.<br />[*] SCASx, CMPSx do set flags corresponding to the last B/W/D scanned, compared.<br />[*] LODSx may be used with REPx prefix but it is useless.<br /><br /><br />Interresting things happen when strings moved with MOVSx overlap partially<br />in memory. Four combination may arise depending on DF and ESI&lt;&gt;EDI relation:<br /><br /><pre><code><br />**** &quot;shift&quot; string to the left  &#40;ESI&gt;EDI, DF=0&#41;<br />before        EDI   ESI   ECX=5 DF=0<br />               |     |<br />           |00|11|22|33|44|55|66|77|88|99|<br /><br />after                        EDI   ESI   ECX=0<br />REP MOVSB                     |     |<br />           |00|33|44|55|66|77|66|77|88|99|<br /><br /><br />**** &quot;multiply&quot; string from the left &#40;ESI&lt;EDI, DF=0&#41;<br />before        ESI   EDI   ECX=5 DF=0<br />               |     |<br />           |00|11|22|33|44|55|66|77|88|99|<br /><br />after                        ESI   EDI   ECX=0 DF=0<br />REP MOVSB                     |     |<br />           |00|11|22|11|22|11|22|11|88|99|<br /><br />**** &quot;multiply&quot; string from the right &#40;ESI&gt;EDI, DF=1&#41;<br />before                       EDI   ESI   ECX=5 DF=1<br />                              |     |<br />           |00|11|22|33|44|55|66|77|88|99|<br /><br />after         EDI   ESI   ECX=0<br />REP MOVSB      |     |<br />           |00|11|88|77|88|77|88|77|88|99|<br /><br />**** &quot;shift&quot; string  to the right &#40;ESI&lt;EDI, DF=1&#41;<br />before                       ESI   EDI   ECX=5 DF=1<br />                              |     |<br />           |00|11|22|33|44|55|66|77|88|99|<br /><br />after         ESI   EDI   ECX=0<br />REP MOVSB      |     |<br />           |00|11|22|33|22|33|44|55|66|99|<br /><br /></code></pre></div>
    <div class="meta">Posted on 2004-02-24 08:46:39 by vit$oft</div>
   </div>
   <div class="post" id="post-134702">
    <div class="subject"><a href="#post-134702">String ASSEMBLY tutorial</a></div>
    <div class="body">I think that ESI and EDI should be preserved for the O.S.<br />(push/pop).<br /><br />By the way, what do you think about this function, is it good?<br /><br />  strlenX:<br />    push ebp<br />    mov ebp,esp<br />    push edi<br />    push esi<br />      mov edi,<br />      xor ecx,ecx<br />      xor al,al<br />      cld<br />      doit:<br />        inc ecx<br />        scasb<br />        jne doit<br />      dec ecx<br />      mov eax,ecx<br />    pop esi<br />    pop edi<br />    leave <br />    retn 04h<br /><br /><br />Regards,<br />Mariano.:alright:</div>
    <div class="meta">Posted on 2004-02-24 10:04:24 by Eternal Idol Birmingham</div>
   </div>
   <div class="post" id="post-134706">
    <div class="subject"><a href="#post-134706">String ASSEMBLY tutorial</a></div>
    <div class="body">Would this be better than the previous?<br /><br />  strlenX:<br />    push ebp<br />    mov ebp,esp<br />    push edi<br />    push esi<br />      mov edi,<br />      xor ecx,ecx<br />      xor al,al<br />      cld<br />      not ecx<br />      repne scasb<br />      not ecx<br />      dec ecx<br />      mov eax,ecx<br />    pop esi<br />    pop edi<br />    leave <br />    retn 04h<br /><br />:alright:</div>
    <div class="meta">Posted on 2004-02-24 10:26:36 by Eternal Idol Birmingham</div>
   </div>
   <div class="post" id="post-134774">
    <div class="subject"><a href="#post-134774">String ASSEMBLY tutorial</a></div>
    <div class="body">If you want a simple byte scanner, I would choose something like<br /><pre><code><br />proc StrLen, hString    ; proc StrLen &#91;hString&#93;<br />        enter<br />        mov     eax,&#91;hString&#93;<br />  .scan&#58;<br />        cmp     byte&#91;eax&#93;,0<br />        lea     eax,&#91;eax+1&#93;<br />        jne     .scan<br />        sub     eax,&#91;hString&#93;; return value in eax<br />        return <br /></code></pre></div>
    <div class="meta">Posted on 2004-02-25 06:00:26 by roticv</div>
   </div>
   <div class="post" id="post-134779">
    <div class="subject"><a href="#post-134779">String ASSEMBLY tutorial</a></div>
    <div class="body">================================================<br /><br /><br /><br />Thanks vit$oft , Donkey , rotivc , and all  the others  for  helping me :)<br /><br /><br /><br /><br /><br /><br />just an example not using this INSTRUCTIONS :)<br /><br /><br /><br />%include &quot;\lab\vasm\inc\nagoa.inc&quot;<br /><br /><br /><br />..start:<br /><br /><br />section data<br />password db &quot;ola amigo&quot;,0<br />user_pass db &quot;ola amigo&quot;,0<br />user_pass_1 equ  $ - user_pass -1   ; lenght user_pass   = 9<br />section code<br /><br /><br />cmpString:<br />push ecx<br />push ebx<br />push edi<br />push esi<br /><br />mov  ecx,user_pass_1<br />mov  eax,password<br />mov  ebx,user_pass<br /> <br />.good_caracter_go_next<br />xor edi,edi<br />xor esi,esi<br />mov edi,<br />mov esi,<br />cmp di,si<br />je    .increment_decrement_stuff<br />jmp .BadBoy<br />.increment_decrement_stuff<br />inc  eax<br />inc  ebx<br />dec ecx<br />cmp ecx,0<br />je .GoodBoy  <br />jmp .good_caracter_go_next<br /><br />                                             <br /><br />.BadBoy<br />call MessageBoxA , NULL,&quot;BAD BOY !!! &quot;,&quot;INFO&quot;,MB_OK<br />jmp .out_<br /><br />.GoodBoy<br /><br />call MessageBoxA , NULL,&quot;GOOD BOY !!! &quot;,&quot;INFO&quot;,MB_OK<br /><br />.out_<br />pop esi<br />pop edi<br />pop ebx<br />pop ecx<br />xor eax,eax<br />ret<br /><br />============================================</div>
    <div class="meta">Posted on 2004-02-25 09:00:06 by Nguga</div>
   </div>
  </div>
 </body>
</html>