<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Calling Convention - Cygwin gcc compiler - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29859" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29859">Calling Convention - Cygwin gcc compiler</a></p>
   <div class="post" id="post-210949">
    <div class="subject"><a href="#post-210949">Calling Convention - Cygwin gcc compiler</a></div>
    <div class="body">Hello Assembly Expert and Professional,<br /><br />I am trying to understand the whole calling convention process.<br /><br />Here is my test4.c source code:<br /><br /><pre><code><br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br /><br />/*Global Variable*/<br />int a = 1;<br /><br />void stack2(int d)<br />{<br /> &nbsp; &nbsp;/*Local Stack 2 Variable*/<br /> &nbsp; &nbsp;int f = d;<br /> &nbsp; &nbsp;printf(&quot;Parameter d: %i\nLocal variable f: %i\n&quot;, d, f);<br /><br /> &nbsp; &nbsp;printf(&quot;Stack 2\n&quot;);<br /><br /> &nbsp; &nbsp;if(f == 1)<br /> &nbsp; &nbsp;{<br /> &nbsp; &nbsp; &nbsp; &nbsp;printf(&quot;Calling Stack 3\n&quot;);<br /> &nbsp; &nbsp;}<br /> &nbsp; &nbsp;else<br /> &nbsp; &nbsp;{<br /> &nbsp; &nbsp; &nbsp; &nbsp;printf(&quot;Exiting Stack2()\n&quot;);<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp;printf(&quot;Parameter d: %i\nLocal variable f: %i\n&quot;, d, f);<br /> &nbsp; &nbsp;}<br /><br /> &nbsp; &nbsp;printf(&quot;Exiting Stack2()\n&quot;);<br /> &nbsp; &nbsp;printf(&quot;Parameter d: %i\nLocal variable f: %i\n&quot;, d, f);<br /><br /> }<br /><br />void stack1(int c)<br />{<br /> &nbsp; &nbsp;/*Local Stack 1 Variable*/<br /> &nbsp; &nbsp;int e = c;<br /> &nbsp; &nbsp;printf(&quot;Parameter c: %i\nLocal variable e: %i\n&quot;, c, e);<br /> &nbsp; &nbsp;<br /> &nbsp; &nbsp;printf(&quot;Stack 1\n&quot;);<br /><br /> &nbsp; &nbsp;if(e == 1)<br /> &nbsp; &nbsp;{<br /> &nbsp; &nbsp; &nbsp; &nbsp;printf(&quot;Calling Stack 2\n&quot;);<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp;stack2(e);<br /> &nbsp; &nbsp;}<br /> &nbsp; &nbsp;else<br /> &nbsp; &nbsp;{<br /> &nbsp; &nbsp; &nbsp; &nbsp;printf(&quot;Exiting Stack1()\n&quot;);<br /> &nbsp; &nbsp; &nbsp; &nbsp;printf(&quot;Parameter c: %i\nLocal variable e: %i\n&quot;, c, e);<br /> &nbsp; &nbsp;}<br /><br /> &nbsp; &nbsp;printf(&quot;Exiting Stack1()\n&quot;);<br /> &nbsp; &nbsp;printf(&quot;Parameter c: %i\nLocal variable e: %i\n&quot;, c, e);<br /><br />}<br /><br />int main(int argc, char** argv)<br />{<br /> &nbsp; &nbsp;/*Local Main Variable*/<br /> &nbsp; &nbsp;int b = a;<br /> &nbsp; &nbsp;printf(&quot;Local variable b: %i\n&quot;, b);<br /><br /> &nbsp; &nbsp;<br /> &nbsp; &nbsp;printf(&quot;Main\n&quot;);<br /><br /> &nbsp; &nbsp;/*Calling Stack 1*/<br /> &nbsp; &nbsp;stack1(b);<br /><br /> &nbsp; &nbsp;printf(&quot;Exiting Main()\n&quot;);<br /> &nbsp; &nbsp;printf(&quot;Local variable b: %i\n&quot;, b);<br /><br /> &nbsp; &nbsp;return (EXIT_SUCCESS);<br />}<br /></code></pre><br /><br />I convert it into assembly<br /><br />gcc -S -masm=intel -o test4.s test4.c<br /><br />test4.s:<br /><br /><pre><code><br />file	&quot;test4.c&quot;<br />	.intel_syntax noprefix<br />.globl _a<br />	.data<br />	.align 4<br />_a:<br />	.long	1<br />	.section .rdata,&quot;dr&quot;<br />	.align 4<br />LC0:<br />	.ascii &quot;Parameter d: %i\12Local variable f: %i\12\0&quot;<br />LC1:<br />	.ascii &quot;Stack 2\0&quot;<br />LC2:<br />	.ascii &quot;Calling Stack 3\0&quot;<br />LC3:<br />	.ascii &quot;Exiting Stack2()\0&quot;<br />	.text<br />.globl _stack2<br />	.def	_stack2;	.scl	2;	.type	32;	.endef<br />_stack2:<br />	push	ebp<br />	mov	ebp, esp<br />	sub	esp, 40<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC0<br />	call	_printf<br />	mov	DWORD PTR , OFFSET FLAT:LC1<br />	call	_puts<br />	cmp	DWORD PTR , 1<br />	jne	L2<br />	mov	DWORD PTR , OFFSET FLAT:LC2<br />	call	_puts<br />	jmp	L3<br />L2:<br />	mov	DWORD PTR , OFFSET FLAT:LC3<br />	call	_puts<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC0<br />	call	_printf<br />L3:<br />	mov	DWORD PTR , OFFSET FLAT:LC3<br />	call	_puts<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC0<br />	call	_printf<br />	leave<br />	ret<br />	.section .rdata,&quot;dr&quot;<br />	.align 4<br />LC4:<br />	.ascii &quot;Parameter c: %i\12Local variable e: %i\12\0&quot;<br />LC5:<br />	.ascii &quot;Stack 1\0&quot;<br />LC6:<br />	.ascii &quot;Calling Stack 2\0&quot;<br />LC7:<br />	.ascii &quot;Exiting Stack1()\0&quot;<br />	.text<br />.globl _stack1<br />	.def	_stack1;	.scl	2;	.type	32;	.endef<br />_stack1:<br />	push	ebp<br />	mov	ebp, esp<br />	sub	esp, 40<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />	mov	DWORD PTR , OFFSET FLAT:LC5<br />	call	_puts<br />	cmp	DWORD PTR , 1<br />	jne	L6<br />	mov	DWORD PTR , OFFSET FLAT:LC6<br />	call	_puts<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	call	_stack2<br />	jmp	L7<br />L6:<br />	mov	DWORD PTR , OFFSET FLAT:LC7<br />	call	_puts<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />L7:<br />	mov	DWORD PTR , OFFSET FLAT:LC7<br />	call	_puts<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />	leave<br />	ret<br />	.def	___main;	.scl	2;	.type	32;	.endef<br />	.section .rdata,&quot;dr&quot;<br />LC8:<br />	.ascii &quot;Local variable b: %i\12\0&quot;<br />LC9:<br />	.ascii &quot;Main\0&quot;<br />LC10:<br />	.ascii &quot;Exiting Main()\0&quot;<br />	.text<br />.globl _main<br />	.def	_main;	.scl	2;	.type	32;	.endef<br />_main:<br />	lea	ecx, <br />	and	esp, -16<br />	push	DWORD PTR <br />	push	ebp<br />	mov	ebp, esp<br />	push	ecx<br />	sub	esp, 36<br />	call	___main<br />	mov	eax, DWORD PTR _a<br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC8<br />	call	_printf<br />	mov	DWORD PTR , OFFSET FLAT:LC9<br />	call	_puts<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	call	_stack1<br />	mov	DWORD PTR , OFFSET FLAT:LC10<br />	call	_puts<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC8<br />	call	_printf<br />	mov	eax, 0<br />	add	esp, 36<br />	pop	ecx<br />	pop	ebp<br />	lea	esp, <br />	ret<br />	.def	_puts;	.scl	2;	.type	32;	.endef<br />	.def	_printf;	.scl	2;	.type	32;	.endef<br /></code></pre><br /><br />So I decided to modify the stack (ESP &amp; EBP) to play around with it:<br /><br /><pre><code><br />	.file	&quot;test4.c&quot;<br />	.intel_syntax noprefix<br />.globl _a<br />	.data<br />	.align 4<br />_a:<br />	.long	1<br />	.section .rdata,&quot;dr&quot;<br />	.align 4<br />LC0:<br />	.ascii &quot;Parameter d: %i\12Local variable f: %i\12\0&quot;<br />LC1:<br />	.ascii &quot;Stack 2\0&quot;<br />LC2:<br />	.ascii &quot;Calling Stack 3\0&quot;<br />LC3:<br />	.ascii &quot;Exiting Stack2()\0&quot;<br />	.text<br />.globl _stack2<br />	.def	_stack2;	.scl	2;	.type	32;	.endef<br />_stack2:<br />	push	ebp<br />	mov	ebp, esp<br />	<strong>sub	esp, 4</strong><br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC0<br />	call	_printf<br />	<br />	mov	DWORD PTR , OFFSET FLAT:LC1<br />	call	_puts<br />	<br />	cmp	DWORD PTR , 1<br />	jne	L2<br />	<br />	mov	DWORD PTR , OFFSET FLAT:LC2<br />	call	_puts<br />	<br />	jmp	L3<br />L2:<br />	mov	DWORD PTR , OFFSET FLAT:LC3<br />	call	_puts<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC0<br />	call	_printf<br />L3:<br />	mov	DWORD PTR , OFFSET FLAT:LC3<br />	call	_puts<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC0<br />	call	_printf<br />	<br />	leave<br />	ret<br />	.section .rdata,&quot;dr&quot;<br />	.align 4<br />LC4:<br />	.ascii &quot;Parameter c: %i\12Local variable e: %i\12\0&quot;<br />LC5:<br />	.ascii &quot;Stack 1\0&quot;<br />LC6:<br />	.ascii &quot;Calling Stack 2\0&quot;<br />LC7:<br />	.ascii &quot;Exiting Stack1()\0&quot;<br />	.text<br />.globl _stack1<br />	.def	_stack1;	.scl	2;	.type	32;	.endef<br />_stack1:<br />	push	ebp<br />	mov	ebp, esp<br />	<strong>sub	esp, 4</strong><br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />	<br />	ov	DWORD PTR , OFFSET FLAT:LC5<br />	call	_puts<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />	<br />	cmp	DWORD PTR , 1<br />	jne	L6<br />	<br />	mov	DWORD PTR , OFFSET FLAT:LC6<br />	call	_puts<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	call	_stack2<br />	<br />	jmp	L7<br />L6:<br />	mov	DWORD PTR , OFFSET FLAT:LC7<br />	call	_puts<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />L7:<br />	mov	DWORD PTR , OFFSET FLAT:LC7<br />	call	_puts<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />	<br />	leave<br />	ret<br />	.def	___main;	.scl	2;	.type	32;	.endef<br />	.section .rdata,&quot;dr&quot;<br />LC8:<br />	.ascii &quot;Local variable b: %i\12\0&quot;<br />LC9:<br />	.ascii &quot;Main\0&quot;<br />LC10:<br />	.ascii &quot;Exiting Main()\0&quot;<br />	.text<br />.globl _main<br />	.def	_main;	.scl	2;	.type	32;	.endef<br />_main:<br />	lea	ecx, <br />	and	esp, -16<br />	push	DWORD PTR <br />	push	ebp<br />	mov	ebp, esp<br />	push	ecx<br />	<br />	<strong>sub	esp, 4</strong><br />	<br />	call	___main<br />	<br />	mov	eax, DWORD PTR _a<br />	mov	<strong>DWORD PTR </strong>, eax<br />	<br />	mov	eax, <strong>DWORD PTR </strong><br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC8<br />	call	_printf<br />	<br />	mov	DWORD PTR , OFFSET FLAT:LC9<br />	call	_puts<br />	<br />	mov	eax, <strong>DWORD PTR </strong><br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC8<br />	call	_printf<br />	<br />	mov	eax, <strong>DWORD PTR </strong><br />	mov	DWORD PTR , eax<br />	call	_stack1<br />	<br />	mov	DWORD PTR , OFFSET FLAT:LC10<br />	call	_puts<br />	<br />	mov	eax, <strong>DWORD PTR </strong><br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC8<br />	call	_printf<br />	<br />	mov	eax, 0<br />	add	esp, 4<br />	<br />	pop	ecx<br />	pop	ebp<br />	lea	esp, <br />	ret<br />	.def	_puts;	.scl	2;	.type	32;	.endef<br />	.def	_printf;	.scl	2;	.type	32;	.endef<br /></code></pre><br /><br />and my error output:<br /><br />gcc -o test4.exe test4.s<br /><br />test4.exe:<br /><br /><pre><code><br />Local variable b: 1<br />Main<br />Local variable b: 1<br />Parameter c: 1<br />Local variable e: 1<br />Stack 1<br />Parameter c: 1<br />Local variable e: 4202774<br />Exiting Stack1()<br />Parameter c: 1<br />Local variable e: 4202798<br />Exiting Stack1()<br />Parameter c: 1<br />Local variable e: 4202798<br /> &nbsp; &nbsp; &nbsp;3  test4 3704 _cygtls::handle_exceptions: Error while dumping state<br />(probably corrupted stack)<br />Segmentation fault (core dumped)<br /></code></pre><br /><br />I noticed that there was a change on EBP after the printf() or puts() function has been called. <br /><br />However, it can be fix by changing the sub esp, 8 beside sub esp, 4.... but why? Since I only have 1 variable.....<br /><br />Anyone mind enlighten me?<br /><br />Thanks.<br /><br /><span style="font-size:8pt><em>Edit by SpooK: You missed a code block ;)</em></span><br /></div>
    <div class="meta">Posted on 2010-03-10 23:39:58 by deathhex</div>
   </div>
   <div class="post" id="post-210950">
    <div class="subject"><a href="#post-210950">Re: Calling Convention - Cygwin gcc compiler</a></div>
    <div class="body"><div class="quote"><br />I noticed that there was a change on EBP after the printf() or puts() function has been called. <br /><br />However, it can be fix by changing the sub esp, 8 beside sub esp, 4.... but why? Since I only have 1 variable.....<br /><br />Anyone mind enlighten me?<br /><br />Thanks.</div><br /><br />Try compiling with the optimization flag (-O): gcc -O -S -masm=intel -o test4.s test4.c<br />Without optimizations, the compiler will just use the most basic translation from C to assembly possible. It will not look for any opportunity to combine multiple operations into one.</div>
    <div class="meta">Posted on 2010-03-11 02:06:33 by Scali</div>
   </div>
   <div class="post" id="post-210954">
    <div class="subject"><a href="#post-210954">Re: Calling Convention - Cygwin gcc compiler</a></div>
    <div class="body">It isn&#039;t entirely clear to me what you&#039;ve done. Changed &quot;sub esp, 40&quot; to &quot;sub esp, 4&quot;??? You&#039;re clobbering your stack when you do &quot;mov &quot;, etc. I think. Look closely at why gcc is subtracting 40. I believe it&#039;s leaving a &quot;reusable argument area&quot; used for calls to printf, etc. Rather than pushing parameters and cleaning up the stack afterwards, as we might do, gcc has been doing it this way for... a while. Without subtracting &quot;enough&quot; from esp, kaboom! I *think* that&#039;s what&#039;s happening...<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-03-11 03:45:14 by fbkotler</div>
   </div>
   <div class="post" id="post-210964">
    <div class="subject"><a href="#post-210964">Re: Calling Convention - Cygwin gcc compiler</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br />I noticed that there was a change on EBP after the printf() or puts() function has been called. <br /><br />However, it can be fix by changing the sub esp, 8 beside sub esp, 4.... but why? Since I only have 1 variable.....<br /><br />Anyone mind enlighten me?<br /><br />Thanks.</div><br /><br />Try compiling with the optimization flag (-O): gcc -O -S -masm=intel -o test4.s test4.c<br />Without optimizations, the compiler will just use the most basic translation from C to assembly possible. It will not look for any opportunity to combine multiple operations into one.<br /></div><br /><br />gcc -O -S -masm=intel -o test4.s test4.c<br /><br /><pre><code><br />	.file	&quot;test4.c&quot;<br />	.intel_syntax noprefix<br />	.section .rdata,&quot;dr&quot;<br />	.align 4<br />LC0:<br />	.ascii &quot;Parameter d: %i\12Local variable f: %i\12\0&quot;<br />LC1:<br />	.ascii &quot;Stack 2\0&quot;<br />LC2:<br />	.ascii &quot;Calling Stack 3\0&quot;<br />LC3:<br />	.ascii &quot;Exiting Stack2()\0&quot;<br />	.text<br />.globl _stack2<br />	.def	_stack2;	.scl	2;	.type	32;	.endef<br />_stack2:<br />	push	ebp<br />	mov	ebp, esp<br />	push	ebx<br />	sub	esp, 20<br />	mov	ebx, DWORD PTR <br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , OFFSET FLAT:LC0<br />	call	_printf<br />	mov	DWORD PTR , OFFSET FLAT:LC1<br />	call	_puts<br />	cmp	ebx, 1<br />	jne	L2<br />	mov	DWORD PTR , OFFSET FLAT:LC2<br />	call	_puts<br />	jmp	L3<br />L2:<br />	mov	DWORD PTR , OFFSET FLAT:LC3<br />	call	_puts<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , OFFSET FLAT:LC0<br />	call	_printf<br />L3:<br />	mov	DWORD PTR , OFFSET FLAT:LC3<br />	call	_puts<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , OFFSET FLAT:LC0<br />	call	_printf<br />	add	esp, 20<br />	pop	ebx<br />	pop	ebp<br />	ret<br />	.section .rdata,&quot;dr&quot;<br />	.align 4<br />LC4:<br />	.ascii &quot;Parameter c: %i\12Local variable e: %i\12\0&quot;<br />LC5:<br />	.ascii &quot;Stack 1\0&quot;<br />LC6:<br />	.ascii &quot;Calling Stack 2\0&quot;<br />LC7:<br />	.ascii &quot;Exiting Stack1()\0&quot;<br />	.text<br />.globl _stack1<br />	.def	_stack1;	.scl	2;	.type	32;	.endef<br />_stack1:<br />	push	ebp<br />	mov	ebp, esp<br />	push	ebx<br />	sub	esp, 20<br />	mov	ebx, DWORD PTR <br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />	mov	DWORD PTR , OFFSET FLAT:LC5<br />	call	_puts<br />	cmp	ebx, 1<br />	jne	L6<br />	mov	DWORD PTR , OFFSET FLAT:LC6<br />	call	_puts<br />	mov	DWORD PTR , 1<br />	call	_stack2<br />	jmp	L7<br />L6:<br />	mov	DWORD PTR , OFFSET FLAT:LC7<br />	call	_puts<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />L7:<br />	mov	DWORD PTR , OFFSET FLAT:LC7<br />	call	_puts<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />	add	esp, 20<br />	pop	ebx<br />	pop	ebp<br />	ret<br />	.def	___main;	.scl	2;	.type	32;	.endef<br />	.section .rdata,&quot;dr&quot;<br />LC8:<br />	.ascii &quot;Local variable b: %i\12\0&quot;<br />LC9:<br />	.ascii &quot;Main\0&quot;<br />LC10:<br />	.ascii &quot;Exiting Main()\0&quot;<br />	.text<br />.globl _main<br />	.def	_main;	.scl	2;	.type	32;	.endef<br />_main:<br />	lea	ecx, <br />	and	esp, -16<br />	push	DWORD PTR <br />	push	ebp<br />	mov	ebp, esp<br />	sub	esp, 24<br />	mov	DWORD PTR , ecx<br />	mov	DWORD PTR , ebx<br />	call	___main<br />	mov	ebx, DWORD PTR _a<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , OFFSET FLAT:LC8<br />	call	_printf<br />	mov	DWORD PTR , OFFSET FLAT:LC9<br />	call	_puts<br />	mov	DWORD PTR , ebx<br />	call	_stack1<br />	mov	DWORD PTR , OFFSET FLAT:LC10<br />	call	_puts<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , OFFSET FLAT:LC8<br />	call	_printf<br />	mov	eax, 0<br />	mov	ecx, DWORD PTR <br />	mov	ebx, DWORD PTR <br />	mov	esp, ebp<br />	pop	ebp<br />	lea	esp, <br />	ret<br />.globl _a<br />	.data<br />	.align 4<br />_a:<br />	.long	1<br />	.def	_printf;	.scl	2;	.type	32;	.endef<br />	.def	_puts;	.scl	2;	.type	32;	.endef<br /><br /></code></pre><br /><br />I think it work because of mov instructions...<br /><br /><br /><br /><div class="quote"><br />It isn&#039;t entirely clear to me what you&#039;ve done. Changed &quot;sub esp, 40&quot; to &quot;sub esp, 4&quot;??? You&#039;re clobbering your stack when you do &quot;mov &quot;, etc. I think. Look closely at why gcc is subtracting 40. I believe it&#039;s leaving a &quot;reusable argument area&quot; used for calls to printf, etc. Rather than pushing parameters and cleaning up the stack afterwards, as we might do, gcc has been doing it this way for... a while. Without subtracting &quot;enough&quot; from esp, kaboom! I *think* that&#039;s what&#039;s happening...<br /><br />Best,<br />Frank<br /></div><br /><br />Yes, I am trying to understand it that why I toying around with the  turn out to be unwanted result. <br /><br />Referring to http://en.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames<br /><br /><pre><code><br />void stack1(int c)<br />{<br />&nbsp; &nbsp; /*Local Stack 1 Variable*/<br />&nbsp; &nbsp; int e = c;<br />&nbsp; &nbsp; printf(&quot;Parameter c: %i\nLocal variable e: %i\n&quot;, c, e);<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; printf(&quot;Stack 1\n&quot;);<br /><br />&nbsp; &nbsp; if(e == 1)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Calling Stack 2\n&quot;);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; stack2(e);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Exiting Stack1()\n&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Parameter c: %i\nLocal variable e: %i\n&quot;, c, e);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; printf(&quot;Exiting Stack1()\n&quot;);<br />&nbsp; &nbsp; printf(&quot;Parameter c: %i\nLocal variable e: %i\n&quot;, c, e);<br /><br />}<br /></code></pre><br /><br />if the C source code converted to assembly source code, it should look like<br /><br /><pre><code><br />LC4:<br />	.ascii &quot;Parameter c: %i\12Local variable e: %i\12\0&quot;<br />LC5:<br />	.ascii &quot;Stack 1\0&quot;<br />LC6:<br />	.ascii &quot;Calling Stack 2\0&quot;<br />LC7:<br />	.ascii &quot;Exiting Stack1()\0&quot;<br />	.text<br />.globl _stack1<br />	.def	_stack1;	.scl	2;	.type	32;	.endef<br />_stack1:<br />	push	ebp<br />	mov	ebp, esp<br />	sub	esp, 4<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />	<br />	mov	DWORD PTR , OFFSET FLAT:LC5<br />	call	_puts<br />	<br />	cmp	DWORD PTR , 1<br />	jne	L6<br />	<br />	mov	DWORD PTR , OFFSET FLAT:LC6<br />	call	_puts<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	call	_stack2<br />	<br />	jmp	L7<br />L6:<br />	mov	DWORD PTR , OFFSET FLAT:LC7<br />	call	_puts<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />L7:<br />	mov	DWORD PTR , OFFSET FLAT:LC7<br />	call	_puts<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />	<br />&nbsp; &nbsp; &nbsp; &nbsp; add	esp, 4<br />	leave<br />	ret<br />	.def	___main;	.scl	2;	.type	32;	.endef<br />	.section .rdata,&quot;dr&quot;<br /></code></pre></div>
    <div class="meta">Posted on 2010-03-11 08:43:23 by deathhex</div>
   </div>
   <div class="post" id="post-210965">
    <div class="subject"><a href="#post-210965">Re: Calling Convention - Cygwin gcc compiler</a></div>
    <div class="body">Sorry for grammatical mistake<br /><br /><div class="quote"><br /><div class="quote"><br />I noticed that there was a change on EBP after the printf() or puts() function has been called. <br /><br />However, it can be fix by changing the sub esp, 8 beside sub esp, 4.... but why? Since I only have 1 variable.....<br /><br />Anyone mind enlighten me?<br /><br />Thanks.</div><br /><br />Try compiling with the optimization flag (-O): gcc -O -S -masm=intel -o test4.s test4.c<br />Without optimizations, the compiler will just use the most basic translation from C to assembly possible. It will not look for any opportunity to combine multiple operations into one.<br /></div><br /><br />gcc -O -S -masm=intel -o test4.s test4.c<br /><br /><pre><code><br />	.file	&quot;test4.c&quot;<br />	.intel_syntax noprefix<br />	.section .rdata,&quot;dr&quot;<br />	.align 4<br />LC0:<br />	.ascii &quot;Parameter d: %i\12Local variable f: %i\12\0&quot;<br />LC1:<br />	.ascii &quot;Stack 2\0&quot;<br />LC2:<br />	.ascii &quot;Calling Stack 3\0&quot;<br />LC3:<br />	.ascii &quot;Exiting Stack2()\0&quot;<br />	.text<br />.globl _stack2<br />	.def	_stack2;	.scl	2;	.type	32;	.endef<br />_stack2:<br />	push	ebp<br />	mov	ebp, esp<br />	push	ebx<br />	sub	esp, 20<br />	mov	ebx, DWORD PTR <br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , OFFSET FLAT:LC0<br />	call	_printf<br />	mov	DWORD PTR , OFFSET FLAT:LC1<br />	call	_puts<br />	cmp	ebx, 1<br />	jne	L2<br />	mov	DWORD PTR , OFFSET FLAT:LC2<br />	call	_puts<br />	jmp	L3<br />L2:<br />	mov	DWORD PTR , OFFSET FLAT:LC3<br />	call	_puts<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , OFFSET FLAT:LC0<br />	call	_printf<br />L3:<br />	mov	DWORD PTR , OFFSET FLAT:LC3<br />	call	_puts<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , OFFSET FLAT:LC0<br />	call	_printf<br />	add	esp, 20<br />	pop	ebx<br />	pop	ebp<br />	ret<br />	.section .rdata,&quot;dr&quot;<br />	.align 4<br />LC4:<br />	.ascii &quot;Parameter c: %i\12Local variable e: %i\12\0&quot;<br />LC5:<br />	.ascii &quot;Stack 1\0&quot;<br />LC6:<br />	.ascii &quot;Calling Stack 2\0&quot;<br />LC7:<br />	.ascii &quot;Exiting Stack1()\0&quot;<br />	.text<br />.globl _stack1<br />	.def	_stack1;	.scl	2;	.type	32;	.endef<br />_stack1:<br />	push	ebp<br />	mov	ebp, esp<br />	push	ebx<br />	sub	esp, 20<br />	mov	ebx, DWORD PTR <br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />	mov	DWORD PTR , OFFSET FLAT:LC5<br />	call	_puts<br />	cmp	ebx, 1<br />	jne	L6<br />	mov	DWORD PTR , OFFSET FLAT:LC6<br />	call	_puts<br />	mov	DWORD PTR , 1<br />	call	_stack2<br />	jmp	L7<br />L6:<br />	mov	DWORD PTR , OFFSET FLAT:LC7<br />	call	_puts<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />L7:<br />	mov	DWORD PTR , OFFSET FLAT:LC7<br />	call	_puts<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />	add	esp, 20<br />	pop	ebx<br />	pop	ebp<br />	ret<br />	.def	___main;	.scl	2;	.type	32;	.endef<br />	.section .rdata,&quot;dr&quot;<br />LC8:<br />	.ascii &quot;Local variable b: %i\12\0&quot;<br />LC9:<br />	.ascii &quot;Main\0&quot;<br />LC10:<br />	.ascii &quot;Exiting Main()\0&quot;<br />	.text<br />.globl _main<br />	.def	_main;	.scl	2;	.type	32;	.endef<br />_main:<br />	lea	ecx, <br />	and	esp, -16<br />	push	DWORD PTR <br />	push	ebp<br />	mov	ebp, esp<br />	sub	esp, 24<br />	mov	DWORD PTR , ecx<br />	mov	DWORD PTR , ebx<br />	call	___main<br />	mov	ebx, DWORD PTR _a<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , OFFSET FLAT:LC8<br />	call	_printf<br />	mov	DWORD PTR , OFFSET FLAT:LC9<br />	call	_puts<br />	mov	DWORD PTR , ebx<br />	call	_stack1<br />	mov	DWORD PTR , OFFSET FLAT:LC10<br />	call	_puts<br />	mov	DWORD PTR , ebx<br />	mov	DWORD PTR , OFFSET FLAT:LC8<br />	call	_printf<br />	mov	eax, 0<br />	mov	ecx, DWORD PTR <br />	mov	ebx, DWORD PTR <br />	mov	esp, ebp<br />	pop	ebp<br />	lea	esp, <br />	ret<br />.globl _a<br />	.data<br />	.align 4<br />_a:<br />	.long	1<br />	.def	_printf;	.scl	2;	.type	32;	.endef<br />	.def	_puts;	.scl	2;	.type	32;	.endef<br /><br /></code></pre><br /><br />I think it work because of less mov instructions were used to shift data on the stack? Please correct me if I am wrong.<br /><br /><br /><div class="quote"><br />It isn&#039;t entirely clear to me what you&#039;ve done. Changed &quot;sub esp, 40&quot; to &quot;sub esp, 4&quot;??? You&#039;re clobbering your stack when you do &quot;mov &quot;, etc. I think. Look closely at why gcc is subtracting 40. I believe it&#039;s leaving a &quot;reusable argument area&quot; used for calls to printf, etc. Rather than pushing parameters and cleaning up the stack afterwards, as we might do, gcc has been doing it this way for... a while. Without subtracting &quot;enough&quot; from esp, kaboom! I *think* that&#039;s what&#039;s happening...<br /><br />Best,<br />Frank<br /></div><br /><br />Yes, I am trying to understand it that why I am toying around with the ... but it turn out to be unwanted result. <br /><br />Referring to http://en.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames<br /><br /><pre><code><br />void stack1(int c)<br />{<br />&nbsp; &nbsp; /*Local Stack 1 Variable*/<br />&nbsp; &nbsp; int e = c;<br />&nbsp; &nbsp; printf(&quot;Parameter c: %i\nLocal variable e: %i\n&quot;, c, e);<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; printf(&quot;Stack 1\n&quot;);<br /><br />&nbsp; &nbsp; if(e == 1)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Calling Stack 2\n&quot;);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; stack2(e);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; else<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Exiting Stack1()\n&quot;);<br />&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Parameter c: %i\nLocal variable e: %i\n&quot;, c, e);<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; printf(&quot;Exiting Stack1()\n&quot;);<br />&nbsp; &nbsp; printf(&quot;Parameter c: %i\nLocal variable e: %i\n&quot;, c, e);<br /><br />}<br /></code></pre><br /><br />if the C source code are convert to assembly source code, it should look similar to:<br /><br /><pre><code><br />LC4:<br />	.ascii &quot;Parameter c: %i\12Local variable e: %i\12\0&quot;<br />LC5:<br />	.ascii &quot;Stack 1\0&quot;<br />LC6:<br />	.ascii &quot;Calling Stack 2\0&quot;<br />LC7:<br />	.ascii &quot;Exiting Stack1()\0&quot;<br />	.text<br />.globl _stack1<br />	.def	_stack1;	.scl	2;	.type	32;	.endef<br />_stack1:<br />	push	ebp<br />	mov	ebp, esp<br />	sub	esp, 4<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />	<br />	mov	DWORD PTR , OFFSET FLAT:LC5<br />	call	_puts<br />	<br />	cmp	DWORD PTR , 1<br />	jne	L6<br />	<br />	mov	DWORD PTR , OFFSET FLAT:LC6<br />	call	_puts<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	call	_stack2<br />	<br />	jmp	L7<br />L6:<br />	mov	DWORD PTR , OFFSET FLAT:LC7<br />	call	_puts<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />L7:<br />	mov	DWORD PTR , OFFSET FLAT:LC7<br />	call	_puts<br />	<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	eax, DWORD PTR <br />	mov	DWORD PTR , eax<br />	mov	DWORD PTR , OFFSET FLAT:LC4<br />	call	_printf<br />	<br />&nbsp; &nbsp; &nbsp; &nbsp; add	esp, 4<br />	leave<br />	ret<br />	.def	___main;	.scl	2;	.type	32;	.endef<br />	.section .rdata,&quot;dr&quot;<br /></code></pre><br /><br />Again correct me if I am wrong.<br /><br />Thank you.<br /></div>
    <div class="meta">Posted on 2010-03-11 09:03:34 by deathhex</div>
   </div>
   <div class="post" id="post-210967">
    <div class="subject"><a href="#post-210967">Re: Calling Convention - Cygwin gcc compiler</a></div>
    <div class="body">Well, I wouldn&#039;t say you were &quot;wrong&quot;, but if you expect gcc to emit code just like your wikibook says, your expectations are incorrect.<br /><br />The amount gcc subtracts from esp for local variables has always been a mystery. D. J. Delorie (author of the 32-bit dos port of gcc) suggested, in one post, that if you really cared what the rationale was, you could look at the source (he pointed out the specific place in the source). I never cared enough.<br /><br />As Scali points out, it matters what optimization switch you use (as well as gcc version). If you try &quot;-Os&quot;, I think you&#039;ll see code closer to what the book says. The vital difference being that arguments to printf, et al, are being pushed on the stack, instead of moved. This allows a smaller amount to be subtracted from esp.<br /><br />I still don&#039;t get what you&#039;re trying to do here, deathhex...<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-03-11 13:14:13 by fbkotler</div>
   </div>
   <div class="post" id="post-211021">
    <div class="subject"><a href="#post-211021">Re: Calling Convention - Cygwin gcc compiler</a></div>
    <div class="body"><div class="quote"><br />Well, I wouldn&#039;t say you were &quot;wrong&quot;, but if you expect gcc to emit code just like your wikibook says, your expectations are incorrect.<br /><br />The amount gcc subtracts from esp for local variables has always been a mystery. D. J. Delorie (author of the 32-bit dos port of gcc) suggested, in one post, that if you really cared what the rationale was, you could look at the source (he pointed out the specific place in the source). I never cared enough.<br /><br />As Scali points out, it matters what optimization switch you use (as well as gcc version). If you try &quot;-Os&quot;, I think you&#039;ll see code closer to what the book says. The vital difference being that arguments to printf, et al, are being pushed on the stack, instead of moved. This allows a smaller amount to be subtracted from esp.<br /><br />I still don&#039;t get what you&#039;re trying to do here, deathhex...<br /><br />Best,<br />Frank<br /><br /><br /></div><br /><br />I am trying to deal with stack frame (function) and its local variable.<br /><br />Frank, are you familiar with gdb?<br /><br />Let said I debug a program a come to a assembly instruction:<br /><br />mov ax, DWORD PTR  // DWORD PTR  is a variable<br /><br />how to I print the content of DWORD PTR  using gdb?<br /><br />print&nbsp; DWORD PTR  is not working for me.<br /><br />Thanks.</div>
    <div class="meta">Posted on 2010-03-16 05:17:40 by deathhex</div>
   </div>
   <div class="post" id="post-211022">
    <div class="subject"><a href="#post-211022">Re: Calling Convention - Cygwin gcc compiler</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br />Well, I wouldn&#039;t say you were &quot;wrong&quot;, but if you expect gcc to emit code just like your wikibook says, your expectations are incorrect.<br /><br />The amount gcc subtracts from esp for local variables has always been a mystery. D. J. Delorie (author of the 32-bit dos port of gcc) suggested, in one post, that if you really cared what the rationale was, you could look at the source (he pointed out the specific place in the source). I never cared enough.<br /><br />As Scali points out, it matters what optimization switch you use (as well as gcc version). If you try &quot;-Os&quot;, I think you&#039;ll see code closer to what the book says. The vital difference being that arguments to printf, et al, are being pushed on the stack, instead of moved. This allows a smaller amount to be subtracted from esp.<br /><br />I still don&#039;t get what you&#039;re trying to do here, deathhex...<br /><br />Best,<br />Frank<br /><br /><br /></div><br /><br />I am trying to deal with stack frame (function) and its local variable.<br /><br />Frank, are you familiar with gdb?<br /><br />Let said I debug a program a come to a assembly instruction:<br /><br />mov ax, DWORD PTR  // DWORD PTR  is a variable<br /><br />how to I print the content of DWORD PTR  using gdb?<br /><br />print&nbsp; DWORD PTR  is not working for me.<br /><br />Thanks.<br /></div><br /><br />Sorry for the serious language problem here... must having cognitive problem over here...<br /><br />Correction:<br /><br />I am trying to deal with stack frame (function) and its local variable.<br /><br />Frank, are you familiar with gdb?<br /><br />Let said I want to debug a program and come across some assembly instruction:<br /><br />mov ax, DWORD PTR  // DWORD PTR  is a variable<br /><br />how do I print the content of DWORD PTR  by using gdb?<br /><br />print&nbsp; DWORD PTR  is not working for me.<br /><br />Thanks.</div>
    <div class="meta">Posted on 2010-03-16 05:26:04 by deathhex</div>
   </div>
   <div class="post" id="post-211032">
    <div class="subject"><a href="#post-211032">Re: Calling Convention - Cygwin gcc compiler</a></div>
    <div class="body">I know of gdb, yeah. I don&#039;t know about &quot;familiar&quot;. We&#039;re not close friends.<br /><br />I prefer a different debugger, Patrick Alken&#039;s &quot;Assembly Language Debugger&quot;:<br /><br />http://ald.sf.net<br /><br />I don&#039;t know if that&#039;ll work in Cygwin or not...<br /><br />Rather than try to figure out how to do what you want in gdb, so I can tell you, I&#039;m going to suggest RTFM. Besides the gdb manual itself, there are a number of tutorials about, showing gdb &quot;sessions&quot; to debug code...<br /><br />http://linuxfocus.berlios.de/English/July2004/article343.shtml<br /><br />http://www.ffnn.nl/pages/articles/linux/gdb-gnu-debugger-intro.php<br /><br />http://www.ibm.com/developerworks/linux/library/l-debug/<br /><br />http://www.ibm.com/developerworks/library/l-gdb/<br /><br />I&#039;ve observed that gdb is happier if we include debugging info - &quot;-F dwarf&quot; (dwarf is supposed to be the &quot;native&quot; debug info format for gdb. I&#039;ve never noticed any difference between &quot;stabs&quot; and &quot;dwarf&quot;, to be honest). Also, a &quot;nop&quot; right after your &quot;_start:&quot; label (if it&#039;s in your code) seems to help.<br /><br />Also, gdb reads &quot;.gdbinit&quot; from current or home directory. Chuck Crayne showed us his .gdbinit - good for both 64-bit and 32-bit - I&#039;m sure I saved it, but I can&#039;t find it at the moment. :( This one if from Jeff Owens, I think...<br /><br />All of this is for Linux. I don&#039;t know how much of it applies to Cygwin.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3085" target="_blank">gdbinit.txt</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-03-16 21:56:13 by fbkotler</div>
   </div>
   <div class="post" id="post-211325">
    <div class="subject"><a href="#post-211325">Re: Calling Convention - Cygwin gcc compiler</a></div>
    <div class="body">in GDB you could print the EBP value by:<br /><br />x $EBP-n<br /><br />or <br /><br />x $EBP+n<br /><br />where n is an integer value.<br /><br /><br />Thank you.</div>
    <div class="meta">Posted on 2010-04-14 09:21:38 by deathhex</div>
   </div>
  </div>
 </body>
</html>