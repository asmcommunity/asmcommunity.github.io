<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Updated OBJ IMPORTER CLASS (ATC) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=21029" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=21029">Updated OBJ IMPORTER CLASS (ATC)</a></p>
   <div class="post" id="post-159365">
    <div class="subject"><a href="#post-159365">Updated OBJ IMPORTER CLASS (ATC)</a></div>
    <div class="body">Maya 6.0 has changed the OBJ and MTL file formats.<br />I&#39;ve revised my OBJ importer to suit.<br />This version handles Materials better than ever.<br />Multiple Materials with one or more textures is fine.<br />Materials without texture? fine.<br />Faces sorted by Material to eliminate texture thrashing during rendering.<br />Exports to HSM binary file format (Custom file format, reasonably tight).<br />Can render at the import stage.<br />Can supply an executable demo to load and render a model.<br />Collision detection with object surfaces not yet implemented, and may never be,<br />as I&#39;ll probably throw theoretical hulls of simpler geometry around entire objects.<br />The World will be a BSP generated from a larger one of these models, and it&#39;ll have proper surface collision detection, as creating Planes is a natural part of creating a BSP.<br /><br />Also included: HSM class for loading and rendering HSM binary files.<br />Optimized rendering and memory usage.<br /><br /><br />Anyone alive?<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=571" target="_blank">HSM.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2005-04-28 11:12:46 by Homer</div>
   </div>
   <div class="post" id="post-159371">
    <div class="subject"><a href="#post-159371">Re: Updated OBJ IMPORTER CLASS (ATC)</a></div>
    <div class="body">Please try to use attachments instead of creating such huge posts, makes things easier to read :)</div>
    <div class="meta">Posted on 2005-04-28 15:37:07 by SpooK</div>
   </div>
   <div class="post" id="post-159388">
    <div class="subject"><a href="#post-159388">Re: Updated OBJ IMPORTER CLASS (ATC)</a></div>
    <div class="body">mmk :P</div>
    <div class="meta">Posted on 2005-04-29 02:57:22 by Homer</div>
   </div>
   <div class="post" id="post-159394">
    <div class="subject"><a href="#post-159394">Re: Updated OBJ IMPORTER CLASS (ATC)</a></div>
    <div class="body">Nice HSM format :D<br />And nice coding style ;)<br /><br />&gt; Anyone alive?<br />I&#39;m kind of, uni was suffocating me this week, and now I&#39;m off to coding a 3D demo game for some new phone that I don&#39;t have yet ^^&quot;. It&#39;s a pity I can&#39;t develop for PC - making good use of the cpu and gpu, but at least - I&#39;ve got an &quot;undiscovered country&quot; here :)</div>
    <div class="meta">Posted on 2005-04-29 11:46:26 by Ultrano</div>
   </div>
   <div class="post" id="post-159395">
    <div class="subject"><a href="#post-159395">Re: Updated OBJ IMPORTER CLASS (ATC)</a></div>
    <div class="body">The importer now better supports large models.<br />I&#39;ve screwed down the HSM binary file format even further.<br />I no longer support importing of FaceGroups.<br />I no longer export UNUSED MATERIALS (imported from the OBJ) to the HSM file.<br /><br />HSM class now supplies its own Render method which has been optimized further by converting indicies into pointers at load time - we perform no vertex lookups at runtime, yet our faces are still built from the same shared vertex array.<br /><br />What&#39;s wrong with my coding style? :)<br />Does it look horrible to you?<br />What suggestions would you make to improve this?<br /><br />I&#39;ll post an updated zip tomorrow,there&#39;s a small bug in the HSM quad renderer I&#39;d like to resolve first.</div>
    <div class="meta">Posted on 2005-04-29 12:04:44 by Homer</div>
   </div>
   <div class="post" id="post-159396">
    <div class="subject"><a href="#post-159396">Re: Updated OBJ IMPORTER CLASS (ATC)</a></div>
    <div class="body"><div class="quote"><br />What&#39;s wrong with my coding style? :)<br />Does it look horrible to you?<br />What suggestions would you make to improve this?<br /></div><br />Now your coding style is very very good ;) , it is properly idented and well-commented. This was not the case before ^^&quot; . But hey, my coding style was also bad till a few months ago :P . So bad that I couldn&#39;t immediately understand code I had written a year ago... I remembered how it worked just for one year - then - poof, nothing. </div>
    <div class="meta">Posted on 2005-04-29 12:41:04 by Ultrano</div>
   </div>
   <div class="post" id="post-159407">
    <div class="subject"><a href="#post-159407">Re: Updated OBJ IMPORTER CLASS (ATC)</a></div>
    <div class="body">I resolved the issue in the HSM class render method.<br /><br />There is a problem with the Vertex Normals I&#39;m importing, with regards to untextured materials.<br /><br />Rather, there appears to be a problem in Maya 6.0&#39;s OBJ exporter - for some reason, it&#39;s exporting pervertex normals with all the same values per face - ie, sets of face normals rather than &quot;corner normals&quot;.<br />Example - if we export two adjacent quad faces at angles to each other (six vertices), we get six normals containing just two values (the face normal of each quad face).<br /><br />It becomes really obvious since I added lighting and a toggle for smooth/flat shading - flat shading always looks nice, since the vertex normals are all facing in the same direction per face - but smooth shading looks absolutely ghastly.<br />The solution is to average the existing normals, or recalc them entirely.<br />In the former case, for each vertex, we find all faces which share this vertex, and then we average all normals applicable to that vertex.<br />In the latter case, we don&#39;t bother importing or exporting Normals at all, we calculate face normals for each vertex-per-face and then average them as before.<br /><br />Sigh.<br />I don&#39;t want to take this much further until I resolve all current issues, but soon I&#39;d like to write a manager for instances of load-once reference objects, I&#39;d like to revisit my BSP code with regards to supporting quads as well as triangles, I want to be able to embed instances of ref objects within BSP leaf nodes so we only have to perform collision detection between the object and the BSP planes which form the leaf node.<br /><br />Collision detection is a little expensive.<br />The leaf nodes in a BSP have an interesting property - they denote a region of space which is bounded by the planes of all nodes between that leaf and the bsp root.<br />If we want to perform optimized collision detection between a moving object and the world, we need to identify which surfaces the object could possibly hit.<br />If we calculate (and track) which leafnode an object is currently in, we can reduce the number of planar collision tests required to (Tree Depth) tests.<br /><br />The regions enclosed by leafnodes are not totally enclosed spaces, or else we couldn&#39;t visit them :P<br />This means its possible IN THEORY for vertices of an object to exist in two or more leafnodes at once.<br />We can create special planes which totally separate the leafnodes.<br />They are invisible planes over the &quot;entrances&quot; to a leafnode.<br />We&#39;ll call them &quot;interleaf portals&quot;, which each join two leafnodes.<br />We can perform collision detection against these planes as well, and if an object begins passing through a portal, we mark it as being in both leafnodes.<br />If the object totally passes through the portal, we remove the reference to the object in the node which it has exited.<br /><br />Ultrano - tell me more about your current work - even though you are not PC coding, I&#39;m sure we can still trade ideas and algorithms.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2005-04-30 04:14:09 by Homer</div>
   </div>
   <div class="post" id="post-159413">
    <div class="subject"><a href="#post-159413">Re: Updated OBJ IMPORTER CLASS (ATC)</a></div>
    <div class="body">Basically, I&#39;m trying to make a vertical-scrolling spaceship/airfighter shooter for mobile devices. Just a few days ago the task was a bit shifted - I have to develop it for a <a target="_blank" href="http://www.qoollabs.com/mobile.htm">QooL</a> phone. I tested a lot of ideas on making the game run smoothly on 100MHz, too -but I just wasted my time then. For instance, I took a whole week in making 2D tilemapping (+ lots of artwork), but it was taking lots of memory to look OK, then by accident I found out that 3D rendering actually is fast enough and looks better. And the only bottleneck is the cpu cache - I should make textures to fit nicely in there. Which will be solved nicely by my next idea:<br />I found out I should be using 4-bit color (with 8 palettes for each texture) instead of the current 8-bit with 32 global palettes. I use palettes just because I need shading(to look much better). Thus, I&#39;ll be more likely keeping palettes in cache :) . For sure it will all looks better, I wonder if it&#39;ll be faster too. <br />Anyway that shooter is very much still in initial development ^^&quot; - today I have to remake my tools and engine to use 4-bit color. Then, finishing my level and event editors.<br />And finally - making as many meshes and general design as I can ^^&quot;. <br /><br />I study a lot from PSX&#39;s design and games, and right now only the artwork and level design are problematic ^^&quot; . <br />Culling and the like have been already implemented, and dropping 2000 objects to DrawMesh(), of which only 10 are visible, does not introduce any noticeable slowdown, so it won&#39;t be a problem. <br />I use two camera rays (I defined a ray as a structure of a position vector and a rotation vector) to render first the level, then render the enemy/friend airfighters. Thus, I can easily animate moving through the whole world in non-linear ways. For instance, if I want a battle to be fought while circling around some building - it will be done extremely easily :). (and I will save the bother of designing more buildings :&gt; )<br /><br />Music is essential in games, and sync-ing it with some timer-events can boost the user experience. This sync has been something I wanted to make for 3-4 years already, and now I have the chance - for being a musician too :) . <br /><br />So, for now I&#39;ve got everything under control. Once I set up one level of the game, and&nbsp; it turns out good, I will have more people in my gamedev team :) . </div>
    <div class="meta">Posted on 2005-04-30 07:41:43 by Ultrano</div>
   </div>
   <div class="post" id="post-159428">
    <div class="subject"><a href="#post-159428">Re: Updated OBJ IMPORTER CLASS (ATC)</a></div>
    <div class="body"><br />Have you considered using some kind of heightmapping for terrain generation?<br /><br />Using these can dramatically cut down development time because &quot;editing&quot; the terrain geometry is performed by &quot;painting&quot; the bitmap from which height information is sourced.<br /><br />It means you and/or your artists can worry more about making nice models and level designs..<br /><br /><br /></div>
    <div class="meta">Posted on 2005-05-01 06:51:46 by Homer</div>
   </div>
   <div class="post" id="post-159434">
    <div class="subject"><a href="#post-159434">Re: Updated OBJ IMPORTER CLASS (ATC)</a></div>
    <div class="body">Yes, I thought a bit about it, but I find it easier just to subdivide a textured quad, and then use a magnet to form relief. And probably it will run faster. Also I don&#39;t want to code anymore on the engine - I need some game demo quickly, and the engine is ok as it is. Last night, for the latter reason I also decided to delay the moving to 4-bit palettes. I want transparent textures too, which is already implemented in the engine now - but it will take more code to make that possible for 4-bit ^^&quot;. My morale drops lower and lower if I don&#39;t see results, and thus I decided to immediately start building the game :) . I hope till tonight it will be possible to play a dynamically-generated level, to blast some enemy planes :&gt; . <br />The first game should be just like a debute should be - with little financial and development investments to see if there&#39;s market for such games. Simple, OK-looking, but good enough to get customers :) . And good enough to lead to some deals with OEMs (right now, the QooL labs). <br />I was looking at some awesome games till now, and my morale was going down a bit, but when I revisited &quot;1942&quot; and the like, I started feeling much better. That game shows the raw basics, and finally it&#39;s up to my creativity to build on top of these basics :) . And also now I remember the ideas I had for &quot;1942&quot; that I&#39;ve had for more than 6 years - before I started coding. <br /><br />I miss the ObjVector and VarVector classes, and the &quot;foreach&quot; macro here a lot T_T . I&#39;ve completed 7 &quot;managers&quot; so far, and around 5 more are to be done. And for each manager, I have to remake a new vector-manager. Later I&#39;ll miss classes with virtuals (for enemy and friends&#39; AI and graphics) - function pointers are by default wrong when your app boots T_T . But I&#39;ll cope with that, though I&#39;ll lose a few more hours :) . <br /><br />But otherwise, the game in its state looks promising and extendable, - I just need to code more extentions and complete the 5 extra managers. <br />A &quot;manager&quot; is actually an engine: explosions manager, 3D effects manager, bullet manager, code-effect manager (for animation of data), SFX manager, dynamic-music manager and so on... <br />Extentions are: types of bullets, enemies, explosions, effects ...</div>
    <div class="meta">Posted on 2005-05-01 09:21:01 by Ultrano</div>
   </div>
   <div class="post" id="post-159438">
    <div class="subject"><a href="#post-159438">Re: Updated OBJ IMPORTER CLASS (ATC)</a></div>
    <div class="body">Sounds like you are in &quot;manager Hell&quot; - something I can relate to :)<br /><br />I performed a test for transparent materials today for HSM class actually.<br />I&#39;ve discovered that the transparency information for MTL materials is what is stored in the Tf fields. There&#39;s three floats, I&#39;d assumed they were &quot;default color&quot;. They are alpha values, and all three seem to always have the same value -&nbsp; RGB per-channel alpha? Anyway, I implemented a quick alpha blend of a textured object without a hitch.<br />What I need to do now is make this thing smarter.<br />I&#39;ve not rendered objects of mixed opaque and transparent (translucent) materials yet, but I know when I want to that I have to do thiings in a certain order.<br />Rendering needs to be performed TWICE.<br />I must render all the opaque surfaces first, and then all the transparent materials second.<br />Materials should have been sorted so that all 100% opaque materials appear first.<br />This will cause my renderer to render those first.<br />We should note at load time which Material, if any, is the first of the transparent materials.<br />During rendering, when we find the first transparent material in an object, we should quit the render loop for that object. Render all the opaque surfaces of all visible objects.<br />Now the materials with alpha values need to be rendered. Render all the objects again, this time starting at the first transparent material. <br />We should disable depth testing for this second pass if we have not sorted them in view Z depth.<br />Now all surfaces will be rendered correctly (I think).<br />Just something to bear in mind for alpha transparency stuff :)<br />I fixed a small bug in the OBJ to HSM code regarding texture coordinates.<br />Vertex normals are still screwy, but seem to have no effect on textured objects even under lighting and with smooth shading, which I find peculiar - perhaps opengl can tell they are illegal somehow?<br /></div>
    <div class="meta">Posted on 2005-05-01 11:07:18 by Homer</div>
   </div>
  </div>
 </body>
</html>