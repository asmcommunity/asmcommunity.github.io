<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Why doesn't my Hotkey work - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=7647" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=7647">Why doesn't my Hotkey work</a></p>
   <div class="post" id="post-55633">
    <div class="subject"><a href="#post-55633">Why doesn't my Hotkey work</a></div>
    <div class="body">Hey guys,<br />I add a hotkey using RegisterHotkey but it doesn't work what's wrong?<br />Here is the peice of code: <br /><pre><code><br />;######################################################################<br />;<br />;    WndProc - procedura glownego okna programu<br />;<br />;<br />;<br />;<br />;######################################################################<br /><br /><br />	include Dialer.inc<br /><br /><br />;######################################################################<br />;<br />;      Stale&#58; identyfikatory obiektow formy, stringi<br />;<br />;######################################################################<br /><br />.const<br /><br />	szBlank		db 0,0<br />	public szAppName<br />	szAppName	db &quot;Dialer by Liquid&quot;,0<br /><br />	szErr_NoSel	db &quot;Select connection first.&quot;,0<br />        szErr_CantConn	db &quot;Can't initialize connection.&quot;,0<br /><br />	szINIFile	db &quot;LDialer.ini&quot;,0         ; plik konfiguracyjny<br />	szSection1	db &quot;Options&quot;,0            ; sekcje i wartosci w pliku INI<br /><br />	szKey1		db &quot;Number&quot;,0<br />        szKey3		db &quot;Password&quot;,0<br />	szKey2		db &quot;Login&quot;,0<br />	szKey4		db &quot;Selected&quot;,0<br />	szKey5		db &quot;Infinite&quot;,0<br />	szKey6		db &quot;AutoStart&quot;,0<br />	szKey7		db &quot;AutoDial&quot;,0<br />	szKey8		db &quot;Retries&quot;,0<br />	szKey9		db &quot;RunMinimized&quot;,0<br />	szKey10		db &quot;WaveFile&quot;,0<br />	szKey11		db &quot;PlaySound&quot;,0<br />	szKey12		db &quot;Reconnect&quot;,0<br />          openfile            db &quot;open&quot;,0<br />;######################################################################<br />;<br />;      zmienne&#58; obiekty, struktury, inne zmienne<br />;<br />;######################################################################<br /><br />.data<br /><br />    note NOTIFYICONDATA &lt;&gt;                    ; potrzebne by korzystac z tray'a<br />    public rasParams<br />    rasParams RASDIALPARAMSA &lt;&gt;               ; parametry polaczenia, konieczne do wywolania RasDial<br /><br />    public nCount<br />    nCount	dd 0                          ; uzywany jako licznik<br />    nConnC	dd 0                          ; j.w. zlicza proby polaczen<br />    public nValue<br />    nValue	dd 0<br /><br />    public bAStart<br />    bAStart	dd 0<br />    public bInfinite<br />    bInfinite	dd 0<br />    public bADial<br />    bADial	dd 0<br />    public bRMinim<br />    bRMinim	dd 0<br />    public bPlaySnd<br />    bPlaySnd	dd 0<br />    public bReconnect<br />    bReconnect	dd 0<br />    public bReconn<br />    bReconn	dd 0<br /><br />.data?<br /><br />    extern hInstance&#58;DWORD<br />    extern hIcon&#58;DWORD<br />    extern nMemAddr&#58;DWORD                     ; adres pamieci przydzielonej dynamicznie<br /><br />    extern hRThread&#58;DWORD<br /><br />    public hConnection<br />    hConnection	dd ?                          ; uchwyt isntniejacego polaczenia po wywolaniu RasDial<br />    hPopupMenu  dd ?                          ; uchwyt Menu poderecznego programu<br />    hStatusPopup dd ?<br />    public hThread<br />    hThread	dd ?			      ; uchwyt nowego watku<br />    public hMThread<br />    hMThread	dd ?			      ; uchwyt watku minimalizujacego okno glowne<br />    public hSThread<br />    hSThread	dd ?<br />    public hDThread<br />    hDThread	dd ?<br />    hStatusWnd  dd ?                          ; uchwyt StatusBar'a<br />    public bConnect<br />    bConnect	dd ?                          ; flaga, czy polaczenie istnieje<br />    public hDlg<br />    hDlg	dd ?<br />    public hOpts<br />    hOpts 	dd ?<br />    public szWaveFile<br />    szWaveFile	db 512 dup &#40;?&#41;<br /><br />.code<br /><br />;######################################################################<br />;<br />;      Glowna procedura okna programu, zdarzenia itp.<br />;<br />;######################################################################<br />	<br /><br />WndProc proc hWnd&#58;HWND,uMsg&#58;DWORD, wParam&#58;DWORD, lParam&#58;DWORD<br /><br /><br />	LOCAL nSize&#58;DWORD<br />	LOCAL nConn&#58;DWORD<br />	LOCAL szName&#91;512&#93;&#58;BYTE<br />	LOCAL szTemp&#91;256&#93;&#58;BYTE<br />	LOCAL pt&#58;POINT<br />	LOCAL rcSize&#58;RECT<br />	LOCAL szSecret&#91;10&#93;&#58;BYTE<br />	LOCAL rasStatus&#58;RASCONNSTATUSA<br />	LOCAL ti&#58;TOOLINFO<br /><br />    <br />    <br />	pushad<br /><br />	;######################################################################<br />	;   Procedura inicjalizacyjna, czyli co prog ma zrobic gdy sie uruchomi<br />	;######################################################################<br />	<br /><br />	<br /><br />    .if uMsg==WM_INITDIALOG                               ; to co zrobimy gdy uworzy sie okno glowne<br /> <br /><br />	push &#91;hWnd&#93;<br />        pop  &#91;hDlg&#93;<br /> ; invoke SendMessage,hWnd,WM_SETHOTKEY,VK_F12,0<br />	 <br />;	invoke RegisterHotKey, hWnd, zID, MOD_CONTROL or MOD_ALT, VK_F11<br />        ; ########################## TOOLTIP ##################################<br />invoke RegisterHotKey, hWnd, IDC_DIAL, MOD_CONTROL, VK_F11;Here I add my hotkey combination<br />		szText szToolTip,&quot;Tooltips_class32&quot;<br />		invoke	CreateWindowEx, WS_EX_TOPMOST, offset szToolTip, NULL, 0, \<br />			CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, \<br />			NULL, NULL, hInstance, NULL<br /><br />		mov ebx, eax<br />		mov ti.cbSize,sizeof TOOLINFO<br />		mov ti.uFlags,TTF_SUBCLASS+TTF_IDISHWND<br />		mov ti.hWnd, 0<br />		push hInstance<br />		pop ti.hInst<br />		push hWnd<br />		pop ti.uId<br />		szText szBTip,&quot;Yeah, u now see a tooltip. Cool huh? ;-&#41;&quot;<br />		mov ti.lpszText,offset szBTip<br />		invoke SendMessage,ebx,TTM_ADDTOOL,0,addr ti<br />		invoke SendMessage,ebx,TTM_SETDELAYTIME,TTDT_INITIAL,10000<br />		invoke SendMessage,ebx,TTM_SETDELAYTIME,TTDT_AUTOPOP,2000<br /><br /><br /><br />        invoke LoadMenu,hInstance,IDM_MENU<br />        invoke SetMenu,hWnd,eax<br /><br />        invoke CreateStatusWindow,WS_CHILD or WS_VISIBLE or SBS_SIZEGRIP,offset szBlank,hWnd,IDC_STATUS<br />        mov hStatusWnd,eax                               ; tworzymy statusbar i zapisujemy handle<br /><br />	sub	eax,eax<br />	invoke	SetTimer,eax,eax,200,offset StatusThread<br />	mov	hThread,eax<br /><br />        invoke SendMessage,hWnd,WM_SETICON,TRUE,hIcon    ; ustawiamy ikone dla okna glownego<br /><br />        invoke GetDlgItem,hWnd,IDC_HANGUP<br />        invoke EnableWindow,eax,FALSE<br /><br />	;##################### Tworzenie popup menu #####################<br /><br />        invoke CreatePopupMenu                           ; tworzymy PopupMenu<br />        mov hPopupMenu,eax                               ; zapisujemy jego handle<br />        push eax<br />        pop ebx<br />        szText szMenu1,&quot;&amp;Open program&quot;                  ; tworzymy kolejne pozycje w menu<br />        invoke AppendMenu,ebx,MF_STRING,IDM_RESTORE,offset szMenu1<br />        invoke AppendMenu,ebx,MF_SEPARATOR,NULL,NULL<br />        szText szMenu2,&quot;&amp;Exit&quot;<br />        invoke AppendMenu,ebx,MF_STRING,IDM_EXIT,offset szMenu2<br /><br />        ;##################### Tworzenie popup menu do statusu #########<br /><br />        invoke CreatePopupMenu<br />        mov hStatusPopup,eax<br />        push eax<br />        pop ebx<br />        szText szMenu11,&quot;Clear log&quot;<br />        invoke AppendMenu,ebx,MF_STRING,IDM_RESTORE,offset szMenu11<br />        szText szMenu12,&quot;Save log to file...&quot;<br />        invoke AppendMenu,ebx,MF_STRING,IDM_RESTORE,offset szMenu12<br /><br /><br />	; ################### Tworzenie ikony w trayu ####################<br /><br />        mov note.cbSize,sizeof NOTIFYICONDATA            ; ustawiamy parametry by umiescic ikone w trayu<br />	push hWnd<br />	pop note.hwnd                                    ; zapisanie handle okna<br />	mov note.uID,IDI_TRAY                            ; identyfikator ikony<br />	mov note.uFlags,NIF_ICON+NIF_MESSAGE+NIF_TIP     ; parametry &#40; Ikona, komunikat oraz hint<br />	mov note.uCallbackMessage,WM_SHELLNOTIFY         ; komunikat wysylany do okna przy zdarzeniu<br />	invoke LoadIcon,hInstance,IDI_ICON               ; pobranie ikony z zasobow i zapis<br />	mov note.hIcon,eax<br />	invoke lstrcpy,addr note.szTip,addr szAppName    ; ustawienie stringa na hint<br />	invoke Shell_NotifyIcon,NIM_ADD,addr note        ; umieszczenie ikony w tray'u<br /><br />        ;################# Wyszukanie dostepnych polaczen #############<br /><br />        sub eax,eax                                      ; wyzerowanie parametrow, konieczne przed wywolaniem<br />	mov nSize,eax<br />	mov nConn,eax<br /><br />        invoke RasEnumEntries,NULL,NULL,nMemAddr,addr nSize,addr nConn ; zwraca rozmiar poptrzebnej pamieci<br /><br />        mov edi,nMemAddr                          ; pierwsza struktura RASENTRYNAME musi miec odpowiedni dwSize<br />        push &#91;nSize&#93;<br />        pop &#91;edi&#93;<br /><br />	mov edi,nMemAddr<br />	mov eax,RASENTRYSIZE<br />	mov &#91;edi&#93;,eax<br /><br />	invoke RasEnumEntries,NULL,NULL,nMemAddr,addr nSize,addr nConn ; pobranie dostepnych polaczen<br /><br />        sub esi,esi<br />	mov edi,nMemAddr<br />	assume edi&#58;ptr RASENTRYNAMEA<br />        .while esi!=&#91;nConn&#93;                       ; petla w ktorej dodajemy pozycje do combobox'a<br />           invoke lstrcpy,addr szName,addr &#91;edi&#93;.szEntryName ; skopiowanie stringa ktory bedzie wyswietlony<br />           invoke SendDlgItemMessage,hWnd,IDC_COMBO,CB_ADDSTRING,0,addr szName ; dodanie stringa do comboboxa<br />           add edi,RASENTRYSIZE                   ; pustawienie pointera na nastepnu wpis<br />           inc esi<br />        .endw<br /><br />	; ###################### Odczytanie ustawien zapisanych w pliku #########<br /><br />	invoke GetPrivateProfileString,offset szSection1,offset szKey1,addr szBlank,addr szName,255,offset szINIFile<br />	invoke SetDlgItemText,hWnd,IDE_NUMBER,addr szName<br /><br />	invoke GetPrivateProfileString,offset szSection1,offset szKey2,addr szBlank,addr szName,255,offset szINIFile<br />        invoke SetDlgItemText,hWnd,IDE_LOGIN,addr szName<br /><br />	invoke GetPrivateProfileString,offset szSection1,offset szKey3,addr szBlank,addr szName,255,offset szINIFile<br />        invoke SetDlgItemText,hWnd,IDE_PASS,addr szName<br /><br />        invoke GetPrivateProfileString,offset szSection1,offset szKey4,addr szBlank,addr szName,255,offset szINIFile<br />	invoke SendDlgItemMessage,hWnd,IDC_COMBO,CB_FINDSTRINGEXACT,0,addr szName         ; szuka nazwy zachowanego polaczenia<br />	.if eax!=CB_ERR<br />		invoke SendDlgItemMessage,hWnd,IDC_COMBO,CB_SETCURSEL,eax,0     ; jesli znaleziono - zaznaczamy<br />        .endif<br /><br />        invoke GetPrivateProfileString,offset szSection1,offset szKey10,addr szBlank,addr szWaveFile,255,offset szINIFile<br /><br />	;####################### Sprawdzenie czy ma byc uruchomiony zminimalizowany ############<br /><br />        invoke GetPrivateProfileString,offset szSection1,offset szKey9,addr szBlank,addr szName,50,offset szINIFile<br />        lea eax,szName<br />        cmp byte ptr &#91;eax&#93;,31h<br />        jnz __not_checked0<br />        	mov dword ptr bRMinim,1<br />		invoke PostMessage,hWnd,WM_SIZE,SIZE_MINIMIZED,0<br />     __not_checked0&#58;<br /><br />	invoke GetPrivateProfileString,offset szSection1,offset szKey11,addr szBlank,addr szName,50,offset szINIFile<br />        lea eax,szName<br />        cmp byte ptr &#91;eax&#93;,31h<br />        jnz __not_checked5<br />        	mov dword ptr bPlaySnd,1<br />     __not_checked5&#58;<br /><br />	invoke	GetPrivateProfileString,offset szSection1,offset szKey5,addr szBlank,addr szName,50,offset szINIFile<br />        lea	eax,szName<br />        cmp	byte ptr &#91;eax&#93;,31h<br />        jnz	__not_checked1<br />        	mov	dword ptr bInfinite,1<br />     __not_checked1&#58;<br /><br />	invoke	GetPrivateProfileString,offset szSection1,offset szKey6,addr szBlank,addr szName,50,offset szINIFile<br />        lea	eax,szName<br />        cmp	byte ptr &#91;eax&#93;,31h<br />        jnz	__not_checked2<br />        	mov	dword ptr bAStart,1<br />     __not_checked2&#58;<br /><br />        invoke	GetPrivateProfileString,offset szSection1,offset szKey12,addr szBlank,addr szName,50,offset szINIFile<br />        lea	eax,szName<br />        cmp	byte ptr &#91;eax&#93;,31h<br />        jnz	__not_checked6<br />        	mov	dword ptr bReconnect,1<br />     __not_checked6&#58;<br /><br />	invoke	GetPrivateProfileString,offset szSection1,offset szKey8,addr szBlank,addr szName,50,offset szINIFile<br /><br />	sub	esi,esi<br />	sub	ebx,ebx<br />	mov	ecx,ebx<br />	lea	edi,szName<br />	movsx esi,byte ptr &#91;edi&#93;<br />	inc	edi<br />     __jump1&#58;<br />     	lea	eax,&#91;ebx*4+ebx&#93;<br />	xor	ecx,ecx<br />	mov	cl,&#91;edi&#93;<br />	lea	ebx,&#91;eax*2+esi-30h&#93;<br />	mov	esi,ecx<br />	test	esi,esi<br />	jz	__jump2<br />	inc	edi<br />	jmp	__jump1<br />     __jump2&#58;<br /><br />	mov	nValue,ebx<br />	mov	nCount,ebx<br /><br />	invoke	GetPrivateProfileString,offset szSection1,offset szKey7,addr szBlank,addr szName,50,offset szINIFile<br />        lea	eax,szName<br />        cmp	byte ptr &#91;eax&#93;,31h<br />        jnz __not_checked3<br />        	mov	dword ptr bADial,1<br />        	invoke	PostMessage,hDlg,WM_COMMAND,IDC_DIAL,0<br />     __not_checked3&#58;<br /><br />    	;######################################################################<br />	;  Procedura zamkniecia programu; co ma sie wykonac po wyjsciu<br />	;######################################################################<br /><br />    .elseif uMsg==WM_CLOSE<br /><br />        pushad<br />	__exit_program&#58;<br />	szText szMsg1,&quot;Are you sure you want quit?&quot; ; obsluga pozniej<br />	invoke MessageBoxA,hWnd,offset szMsg1,offset szAppName,MB_YESNO or MB_ICONQUESTION<br />	.if eax==IDYES   ; potwierdzenie checi zamkniecia programu<br />	invoke UnregisterHotKey, hWnd,IDC_DIAL;zID<br />		mov rasStatus.dwSize, 0A0h<br />		invoke RasGetConnectStatus,hConnection,addr rasStatus<br />		.if rasStatus.rasconnstate==RASCS_DONE<br />			szText szMsg2,&quot;Connection is now established. Close it?&quot;<br />			invoke MessageBoxA,hWnd,offset szMsg2,offset szAppName,MB_YESNOCANCEL or MB_ICONQUESTION<br />			.if eax==IDYES<br />			invoke UnregisterHotKey, hWnd,IDC_DIAL<br />				invoke RasHangUp,hConnection<br />			.elseif eax==IDCANCEL<br />				jmp __nothing<br />			.endif<br />		.else<br />			invoke RasHangUp,hConnection<br />		.endif<br /><br />        	invoke IsDlgButtonChecked,hWnd,IDC_INFINITE<br /><br />		invoke GetDlgItemText,hWnd,IDE_NUMBER,addr szName,255<br />		invoke WritePrivateProfileString,offset szSection1,offset szKey1,addr szName, offset szINIFile<br /><br />		invoke GetDlgItemText,hWnd,IDE_LOGIN,addr szName,255<br />		invoke WritePrivateProfileString,offset szSection1,offset szKey2,addr szName, offset szINIFile<br /><br />		invoke GetDlgItemText,hWnd,IDE_PASS,addr szName,255<br />		invoke WritePrivateProfileString,offset szSection1,offset szKey3,addr szName, offset szINIFile<br /><br />		invoke WritePrivateProfileString,offset szSection1,offset szKey10,addr szWaveFile, offset szINIFile<br /><br />		invoke ConvertText,addr szName,&#91;nValue&#93;<br />;<br />        	invoke WritePrivateProfileString,offset szSection1,offset szKey8,addr szName, offset szINIFile<br /><br />		lea edx,szName<br />		sub ebx,ebx<br />		<br />	.if uMsg== WM_HOTKEY ;Here is my WM_HOTKEY<br /><br /> 	invoke	PostMessage,hDlg,WM_COMMAND,IDC_DIAL,0<br />	    .endif<br />                .if &#91;bInfinite&#93;==BST_CHECKED<br />			mov byte ptr &#91;edx&#93;,31h<br />			mov byte ptr &#91;edx+1&#93;,bl<br />		.else<br />		        mov byte ptr &#91;edx&#93;,30h<br />			mov byte ptr &#91;edx+1&#93;,bl<br />		.endif<br /><br />		invoke WritePrivateProfileString,offset szSection1,offset szKey5,addr szName, offset szINIFile<br /><br />		lea edx,szName<br />		sub ebx,ebx<br />                .if bAStart==1<br />			mov byte ptr &#91;edx&#93;,31h<br />			mov byte ptr &#91;edx+1&#93;,bl<br />		.else<br />		        mov byte ptr &#91;edx&#93;,30h<br />			mov byte ptr &#91;edx+1&#93;,bl<br />		.endif<br /><br />		invoke WritePrivateProfileString,offset szSection1,offset szKey6,addr szName, offset szINIFile<br /><br />                lea edx,szName<br />		sub ebx,ebx<br />                .if bADial==1<br />			mov byte ptr &#91;edx&#93;,31h<br />			mov byte ptr &#91;edx+1&#93;,bl<br />		.else<br />		        mov byte ptr &#91;edx&#93;,30h<br />			mov byte ptr &#91;edx+1&#93;,bl<br />		.endif<br /><br />		invoke WritePrivateProfileString,offset szSection1,offset szKey7,addr szName, offset szINIFile<br /><br />                lea edx,szName<br />		sub ebx,ebx<br />                .if bRMinim==1<br />			mov byte ptr &#91;edx&#93;,31h<br />			mov byte ptr &#91;edx+1&#93;,bl<br />		.else<br />		        mov byte ptr &#91;edx&#93;,30h<br />			mov byte ptr &#91;edx+1&#93;,bl<br />		.endif<br /><br />		invoke WritePrivateProfileString,offset szSection1,offset szKey9,addr szName, offset szINIFile<br /><br />                lea edx,szName<br />		sub ebx,ebx<br />                .if bPlaySnd==1<br />			mov byte ptr &#91;edx&#93;,31h<br />			mov byte ptr &#91;edx+1&#93;,bl<br />		.else<br />		        mov byte ptr &#91;edx&#93;,30h<br />			mov byte ptr &#91;edx+1&#93;,bl<br />		.endif<br /><br />		invoke WritePrivateProfileString,offset szSection1,offset szKey11,addr szName, offset szINIFile<br /><br />                lea edx,szName<br />		sub ebx,ebx<br />                .if bReconnect==1<br />			mov byte ptr &#91;edx&#93;,31h<br />			mov byte ptr &#91;edx+1&#93;,bl<br />		.else<br />		        mov byte ptr &#91;edx&#93;,30h<br />			mov byte ptr &#91;edx+1&#93;,bl<br />		.endif<br /><br />		invoke WritePrivateProfileString,offset szSection1,offset szKey12,addr szName, offset szINIFile<br /><br />		invoke SendDlgItemMessage,hWnd,IDC_COMBO,CB_GETCURSEL,0,0      ; sprawdza co zaznaczone<br />		.if eax!=CB_ERR<br />			lea ebx,szName<br />			invoke SendDlgItemMessage,hWnd,IDC_COMBO,CB_GETLBTEXT,eax,ebx ; pobiera string zaznaczonego elementu<br />                	invoke WritePrivateProfileString,offset szSection1,offset szKey4,addr szName,offset szINIFile<br />                .endif<br /><br />		invoke Shell_NotifyIcon,NIM_DELETE,addr note  ; wywalamy ikone z traya, bo po co nam ona?<br /><br />		invoke EndDialog,hWnd,0  ; i wychodzimy<br />	.endif<br />	__nothing&#58;<br />	popad<br />	sub eax,eax<br /> 	ret<br /> 	;######################################################################<br /> 	;  Procedura obslugi okna; jesli zminimalizowany - nie ma go na pasku zadan<br /> 	;######################################################################<br /><br />    .elseif uMsg==WM_SIZE<br />        .if wParam==SIZE_MINIMIZED<br /> 		invoke ShowWindow,hWnd,SW_HIDE<br />        .elseif wParam==SIZE_RESTORED<br /> 		invoke ShowWindow,hWnd,SW_SHOW<br />        .endif<br /><br />	;######################################################################<br />	;  Procedura obslugi ikony w trayu; zdarzenia<br />	;######################################################################<br /><br />    .elseif uMsg==WM_SHELLNOTIFY<br />	.if wParam==IDI_TRAY                               ; klikniecie na ikone w trayu?<br />		.if lParam==WM_RBUTTONDOWN                 ; prawym klawiszem<br />			invoke GetCursorPos,addr pt            ; sprawdzamy gdzie znajduje sie mysz<br />			invoke TrackPopupMenu,hPopupMenu,TPM_RIGHTALIGN,pt.x,pt.y,NULL,hWnd,NULL  ; wyswietlamy menu<br />		.elseif lParam==WM_LBUTTONDBLCLK           ; to jednak byl lewy klawisz<br />			invoke SendMessage,hWnd,WM_COMMAND,IDM_RESTORE,0<br />		.endif<br />	.endif<br /><br />	;######################################################################<br />	;  Procedura ponownego laczenia, jesli ustawione jest powtarzanie polaczenia<br />	;######################################################################<br /><br />    .elseif uMsg==WM_CONNECT<br />                invoke RasHangUp,hConnection<br /><br /> 		inc dword ptr &#91;nConnC&#93;<br /><br />        	szText szRedial,&quot;Redialing, attempt nr.&quot;<br />		invoke lstrcpy,addr szName,offset szRedial<br />		invoke lstrlen,offset szRedial<br /><br />		lea eax,&#91;szName+eax&#93;<br />       		invoke ConvertText,eax,&#91;nConnC&#93;<br /><br />        	invoke SendDlgItemMessage,hDlg,IDC_LIST,LB_ADDSTRING,0,addr szName<br /><br /> 		.if &#91;bInfinite&#93;==1<br /><br />      			invoke CreateThread,0,0,offset ConnectProc,0,0,offset hDThread<br /> 		.else<br /> 			cmp dword ptr &#91;nCount&#93;,0<br /> 			jz __end_calling<br /> 			dec dword ptr &#91;nCount&#93;<br /> 			jz __end_calling<br /><br />  			invoke CreateThread,0,0,offset ConnectProc,0,0,offset hDThread<br /> 		     __end_calling&#58;<br /> 		.endif<br /><br />	;######################################################################<br />	; Zdarzenia; polecenia uzytkownika<br />	;######################################################################<br /><br />    .elseif uMsg==WM_COMMAND<br />	pushad<br />	mov eax,wParam<br />	.if lParam==0<br />		mov eax,wParam<br />		.if ax==IDM_RESTORE<br />                	invoke SetForegroundWindow,hWnd<br /><br />                	invoke ShowWindow,hWnd,SW_RESTORE  ; przywracamy okno glowne<br /><br />		.elseif ax==IDM_EXIT<br />			 jmp __exit_program<br />                .endif<br />	.endif<br /><br />		;######################################################################<br />		;  Przycisk &quot;Connect&quot;, uruchomienie procedury laczenia<br />		;######################################################################<br /><br />  	.if ax== IDC_DIAL<br /><br /><br />	    invoke SendDlgItemMessage,hWnd,IDC_LIST,LB_RESETCONTENT,0,0<br /><br />	    invoke SendDlgItemMessage,hWnd,IDC_COMBO,CB_GETCURSEL,0,0  ; sprawdza co jest zaznaczone w combo boxie<br /><br />	    .if eax==CB_ERR<br />		invoke AddToList,offset szErr_NoSel         ; jesli nic, wyswietla komunikat w oknie statusu<br />	    .else<br />		mov ecx,sizeof RASENTRYNAME                 ; rozmiar<br />		imul eax                                    ; jest mnozony przez numer zaznaczonego polaczenia<br />        	mov edi,nMemAddr<br />        	assume edi&#58;ptr RASENTRYNAMEA<br />        	add edi,eax                                 ; ustawiamy pointer na wybrane polaczenie<br /><br />        	push sizeof RASDIALPARAMSA+3 		    ; odpowiednie dwSize pierwszego wpisu<br />        	pop rasParams.dwSize<br /><br />		invoke SendDlgItemMessage,hWnd,IDC_COMBO,CB_GETCURSEL,0,0  ; sprawdza co zaznaczone<br />		invoke SendDlgItemMessage,hWnd,IDC_COMBO,CB_GETLBTEXT,eax,offset rasParams.szEntryName<br />                                                            ; i zapisuje nazwe w strukturze potrzebnej do wywolania<br />		invoke lstrcpy,offset rasParams.szCallbackNumber, offset szBlank  ; nie uzywane<br />		invoke GetDlgItemText,hWnd,IDE_NUMBER,offset rasParams.szPhoneNumber,RAS_MaxPhoneNumber ; numer gdzie dzwonimy<br />		invoke GetDlgItemText,hWnd,IDE_LOGIN,offset rasParams.szUserName,UNLEN  ; login -  &quot;ppp&quot;<br />		invoke GetDlgItemText,hWnd,IDE_PASS,offset rasParams.szPassword,PWLEN   ; haslo - &quot;ppp&quot;<br />		invoke lstrcpy,offset rasParams.szDomain,offset szBlank        ; nie uzywane<br /><br />		sub eax,eax<br />		mov hConnection,eax<br />		mov nConnC,eax<br />		inc eax<br />		mov &#91;bConnect&#93;,eax<br /><br />		.if bReconnect==1<br />			mov dword ptr &#91;bReconn&#93;,1<br />		.else<br />			mov dword ptr &#91;bReconn&#93;,0<br />		.endif<br /><br />		mov eax,&#91;nValue&#93;<br />		mov &#91;nCount&#93;,eax<br /><br />		invoke ConnectProc<br />		.if eax==0<br />		    inc dword ptr &#91;nConnC&#93;<br />		    invoke WindowsDisable<br />        	    szText szNewText,&quot;Dialing...&quot;<br />		    invoke SendDlgItemMessage,hDlg,IDC_LIST,LB_ADDSTRING,0,addr szNewText<br />	        .else<br />		   invoke AddToList,offset szErr_CantConn      ; nie powiodlo sie, modem moze byc zajety przez inny prog<br />	       	.endif<br />            .endif<br /><br />		;######################################################################<br />		; Przycisk &quot;Disconnect&quot;; zakonczenie polaczenia / wywolywania polaczenia<br />		;######################################################################<br /><br />	.elseif ax==IDC_HANGUP<br /><br />		invoke RasHangUp,hConnection<br /><br />                sub eax,eax<br />                mov &#91;bConnect&#93;,eax<br />		invoke WindowsEnable			; uaktywniamy odpowiednie przyciski, etc<br />        	szText szERROR_Terminating,&quot;Terminating...&quot;<br />        	invoke SendDlgItemMessage,hDlg,IDC_LIST,LB_ADDSTRING,0,offset szERROR_Terminating<br /><br />        	invoke	KillTimer,0,hRThread<br /><br />		;######################################################################<br />		; &quot;Options&quot; w menu glownym<br />		;######################################################################<br /><br />	.elseif ax==IDM_OPTIONS<br /><br />		invoke DialogBoxParam,hInstance,IDD_OPTIONS,hDlg,offset OptionsProc,NULL<br /><br />		;######################################################################<br />		; &quot;Exit&quot; w menu glownym<br />		;######################################################################<br /><br />	.elseif ax==IDM_EXIT1<br />		invoke SendMessage,hWnd,WM_COMMAND,IDM_EXIT,0<br /><br />		;######################################################################<br />		; &quot;About&quot; w menu glownym<br />		;######################################################################<br /><br />	.elseif ax==IDM_ABOUT<br />		szText	szAbout, &quot;Dialer by Liquid      &quot;,13,10,&quot;liquidx@go2.pl&quot;,13,10,13,10, \<br />				&quot;Special thanx to Aquarius&quot;,13,10,13,10,&quot;23.9.2000&quot;<br /><br />		invoke	MessageBoxA,hWnd,offset szAbout,offset szAppName,MB_OK<br /><br />		;######################################################################<br />		;	&quot;Save log...&quot; w menu, zapisuje status do pliku<br />		;#####################################################################<br /><br />	.elseif ax==IDM_LOG<br />                invoke CreateThread,0,0,offset SaveLogThread,0,0,offset hMThread<br />	.elseif	ax==IDM_TIMER<br />		invoke DialogBoxParamA,hInstance,2000,hWnd,offset TimerDlgProc,0<br />	.endif<br /><br />	popad<br />    .endif<br />__koniec&#58;<br />    popad<br /><br />    sub eax,eax                              ; coz... wychodzimy z procedury<br />    ret<br />WndProc endp<br /><br /><br />;######################################################################<br />;   Koniec programu<br />;######################################################################<br /><br />end<br /></code></pre><br /><br />Thanx<br /><br /><em><span style="font-size:9px>[ code ] tags added by bazik</span></em></div>
    <div class="meta">Posted on 2002-08-31 12:57:24 by Duker</div>
   </div>
   <div class="post" id="post-55734">
    <div class="subject"><a href="#post-55734">Why doesn't my Hotkey work</a></div>
    <div class="body">May be registerhokey must be into other place?</div>
    <div class="meta">Posted on 2002-09-01 14:44:24 by Duker</div>
   </div>
   <div class="post" id="post-56534">
    <div class="subject"><a href="#post-56534">Why doesn't my Hotkey work</a></div>
    <div class="body">Guys Help me plz why don't you answer?</div>
    <div class="meta">Posted on 2002-09-07 13:31:31 by Duker</div>
   </div>
   <div class="post" id="post-56537">
    <div class="subject"><a href="#post-56537">Why doesn't my Hotkey work</a></div>
    <div class="body">Duker, taking a quick look through your code, my best guess is that the line<br /><pre><code><br /> .if uMsg == WM_HOTKEY<br /></code></pre><br />should be changed to a .ELSEIF to be in the same .IF as WM_CLOSE and WM_SIZE, etc.<br />Otherwise, I think the assembler will take the code to be inside the WM_CLOSE and so will be skipped over if the uMsg is not WM_CLOSE<br /><br />--Chorus</div>
    <div class="meta">Posted on 2002-09-07 13:52:19 by chorus</div>
   </div>
   <div class="post" id="post-56542">
    <div class="subject"><a href="#post-56542">Why doesn't my Hotkey work</a></div>
    <div class="body">Thanx Chorus, Nice guess I'll try and will post the answer whether if it works or not</div>
    <div class="meta">Posted on 2002-09-07 14:08:57 by Duker</div>
   </div>
   <div class="post" id="post-56544">
    <div class="subject"><a href="#post-56544">Why doesn't my Hotkey work</a></div>
    <div class="body">Here's a sample hotkey program:<pre><code>&#91;size=9&#93;format pe gui 4.0<br />entry start<br /><br />INCLUDE '\fasm\include\kernel.inc'<br />INCLUDE '\fasm\include\user.inc'<br />INCLUDE '\fasm\include\macro\stdcall.inc'<br />INCLUDE '\fasm\include\macro\import.inc'<br /><br />section '.idata' import data readable writeable<br />    library kernel, 'KERNEL32.DLL',\<br />            user, 'USER32.DLL'<br />    kernel&#58;<br />        import GetModuleHandle,'GetModuleHandleA'<br /><br />    user&#58;<br />        import RegisterClass,'RegisterClassA',\<br />               CreateWindowEx,'CreateWindowExA',\<br />               DefWindowProc,'DefWindowProcA',\<br />               GetMessage,'GetMessageA',\<br />               TranslateMessage,'TranslateMessage',\<br />               DispatchMessage,'DispatchMessageA',\<br />               LoadCursor,'LoadCursorA',\<br />               PostQuitMessage,'PostQuitMessage',\<br />               RegisterHotKey,'RegisterHotKey',\<br />               UnregisterHotKey, 'UnregisterHotKey',\<br />               MessageBox, &quot;MessageBoxA&quot;<br /><br />start&#58;<br /><br />    invoke  LoadCursor, NULL, IDC_ARROW<br />    mov     &#91;wc.hCursor&#93;, eax<br />    mov     &#91;wc.lpfnWndProc&#93;, WndMsg<br />    mov     &#91;wc.hbrBackground&#93;, COLOR_BTNFACE+1<br />    mov     &#91;wc.lpszClassName&#93;, appclass<br />    invoke  RegisterClass, wc<br />    invoke  GetModuleHandle, NULL<br />    invoke  CreateWindowEx, NULL, appclass, appclass, WS_VISIBLE+WS_OVERLAPPEDWINDOW,\<br />                            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,\<br />                            NULL, NULL, eax, NULL<br /><br />    __msg_lp&#58;<br /><br />        invoke  GetMessage, msg, NULL, 0, 0<br />        test    eax, eax<br />        jz      __msg_lp_ex<br />        invoke  DispatchMessage,msg<br />        jmp     __msg_lp<br /><br />    __msg_lp_ex&#58;<br /><br />        retn<br /><br />WndMsg&#58;<br /><br />    hWnd    equ DWORD &#91;ebp+8&#93;<br />    iMsg    equ DWORD &#91;ebp+12&#93;<br />    lParam  equ DWORD &#91;ebp+16&#93;<br />    wParam  equ DWORD &#91;ebp+20&#93;<br /><br />    CTRL_X  = 1000<br />    VK_X    = 58h<br /><br />    push    ebp<br />    push    esp<br />    pop     ebp<br /><br />    mov     eax, iMsg<br /><br />    cmp     eax, WM_HOTKEY<br />    je      __hotkey<br />    cmp     eax, WM_CREATE<br />    je      __create<br />    cmp     eax, WM_DESTROY<br />    je      __destroy<br />    pop     ebp<br />    jmp     &#91;DefWindowProc&#93;<br /><br />    __hotkey&#58;<br /><br />        invoke  MessageBox, 0, 0, 0, 0<br />        jmp     __lresult<br /><br />    __create&#58;<br /><br />        invoke  RegisterHotKey, hWnd, CTRL_X, MOD_CONTROL, VK_X<br />        jmp     __lresult<br /><br />    __destroy&#58;<br /><br />        invoke  UnregisterHotKey, hWnd, CTRL_X<br />        invoke  PostQuitMessage, NULL<br /><br />    __lresult&#58;<br /><br />    xor     eax,eax<br />    leave<br />    retn    16<br /><br />    appclass        DB &quot;Hotkey&quot;, 0<br />    wc              WNDCLASS<br />    msg             MSG&#91;/size&#93;</code></pre>I'm too lazy too look at your code. :)<br /><br />Also make sure RegisterHotKey returns succesfully. The problem might be that there is a possibility of a conflict. I mean that the key combination you tried to register already exists... MS suggests you use GlobalAddAtom to obtain the hotkey identifier.<br /><br /><br /><br />Oh I forgot, during WM_HOTKEY, wParam contains the key identifier and lParam(HiWord == Virtual Key Code and LoWord == can either be MOD_ALT, MOD_CONTROL, MOD_SHIFT, MOD_WIN depending on what you specified on RegisterHotKey) so you might want to do some error checkings first, if you have more than 1 hot key registered.</div>
    <div class="meta">Posted on 2002-09-07 14:12:11 by stryker</div>
   </div>
   <div class="post" id="post-56550">
    <div class="subject"><a href="#post-56550">Why doesn't my Hotkey work</a></div>
    <div class="body">Thanx stryker,<br />But do I have to declare <br />VK_X =56h in MASM?</div>
    <div class="meta">Posted on 2002-09-07 14:41:03 by Duker</div>
   </div>
   <div class="post" id="post-56552">
    <div class="subject"><a href="#post-56552">Why doesn't my Hotkey work</a></div>
    <div class="body">no, you don't have to. It's already included on WINDOWS.inc. It's 58h not 56h - I should change the font formatting to remove confusion. :)<br /><br />stupid terminal font. :)<br /><br />I just changed the above formatting to lucida console.</div>
    <div class="meta">Posted on 2002-09-07 14:52:21 by stryker</div>
   </div>
   <div class="post" id="post-56554">
    <div class="subject"><a href="#post-56554">Why doesn't my Hotkey work</a></div>
    <div class="body">Thanks Stryker,<br />And another one question? don't you know a program that converts a button and shows you the code of the key?</div>
    <div class="meta">Posted on 2002-09-07 15:00:15 by Duker</div>
   </div>
   <div class="post" id="post-56592">
    <div class="subject"><a href="#post-56592">Why doesn't my Hotkey work</a></div>
    <div class="body">&gt;&gt; converts a button and shows<br />&gt;&gt; you the code of the key?<br /><br />Could you elaborate more? I don't seem to understand the question? :stupid:</div>
    <div class="meta">Posted on 2002-09-07 21:39:09 by stryker</div>
   </div>
   <div class="post" id="post-57725">
    <div class="subject"><a href="#post-57725">Why doesn't my Hotkey work</a></div>
    <div class="body">How did you get the code of VK_X? <br />VK_X =58h? I need a program that will convert a virtual key to hex.<br />Thanx</div>
    <div class="meta">Posted on 2002-09-14 07:12:22 by Duker</div>
   </div>
  </div>
 </body>
</html>