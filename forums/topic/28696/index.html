<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Fast 2D Approximation of 3D View Frustum - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=28696" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=28696">Fast 2D Approximation of 3D View Frustum</a></p>
   <div class="post" id="post-202715">
    <div class="subject"><a href="#post-202715">Fast 2D Approximation of 3D View Frustum</a></div>
    <div class="body"><br />Given that we can quickly extract the eight corner vertices&nbsp; (and if desired, the Planes) of a 3D View Frustum, it should be possible to determine from those a 2D approximation of said 3D Frustum.<br />Attached is an image which describes the concept visually, you can see a 3D view frustum partly rotated in 3D space, and around it, a 2D Frustum which completely encloses it using just four 2D coords.<br />I would like to hear your ideas :)<br />How would you go about approximating this 2D Hull, given that rotation of the 3D Frustum is completely arbitrary?<br /><br />What I have in mind: I intend to compare the approximated 2D Frustum against a large Terrain HeightMap in order to identify which pixels (Terrain Vertices) are actually visible, and to keep track of them using a list of ScanLines representing them as cheaply as possible. The goal is to write a new Terrain Engine which dynamically samples the visible landscape in the most efficient way possible (only generating newly-visible vertices at the frustum boundaries), eliminating the concept of (and problems related to) patch-based management systems for large environments.<br />It&#039;s not as cool as my &#039;sparse radial oversampling&#039; concept I proposed a few years ago, however its far cooler than anything I&#039;ve actually produced so far.<br /><br />So if you&#039;re bored, get a pen and paper and try to devise an algo for degenerating the 3D frustum into a 2D hull that has only four edges :)<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2405" target="_blank">2DFrustum.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-08-24 01:44:33 by Homer</div>
   </div>
   <div class="post" id="post-202716">
    <div class="subject"><a href="#post-202716">Re: Fast 2D Approximation of 3D View Frustum</a></div>
    <div class="body">Edit: Expensive algo scrapped.. read on..</div>
    <div class="meta">Posted on 2007-08-24 03:24:26 by Homer</div>
   </div>
   <div class="post" id="post-202732">
    <div class="subject"><a href="#post-202732">Re: Fast 2D Approximation of 3D View Frustum</a></div>
    <div class="body">first I want to perform a simple estimation of what is clipped belowscreen, based on playersy vs terrainmaxheight and if player looksup/looksforward, checks against a thresholdangle and clipout belowscreen and clipout abovescreen<br /><br />shouldnt we simple use y=k*x+c for clippinglines and simple have a precalculated LUT for angle-&gt;k constants<br />ok we have a point px,py and we simple put in px in our formula and fmul and compare against clippingline1 and fmul and compare again against clippingline2<br />I dont know if its possible to get performance outta the beast fpu is with issuing several fmuls in a row, but I code a SSE clip solution, as 4 lines to clip against make it perfect for that<br /></div>
    <div class="meta">Posted on 2007-08-25 03:42:21 by daydreamer</div>
   </div>
   <div class="post" id="post-202733">
    <div class="subject"><a href="#post-202733">Re: Fast 2D Approximation of 3D View Frustum</a></div>
    <div class="body">Edit : Expensive code for Expensive Algo scrapped - read on</div>
    <div class="meta">Posted on 2007-08-25 04:03:24 by Homer</div>
   </div>
   <div class="post" id="post-202735">
    <div class="subject"><a href="#post-202735">Re: Fast 2D Approximation of 3D View Frustum</a></div>
    <div class="body">I got a new idea and thought what the heck why not OOP eventbased structure ala<br />proc render;<br />3dtransformanddraw(arrayoftrianglestrips);<br />endproc<br /><br />proc onmousemoveleft;<br />angle--;<br />addstripstoleft(arrayoftrianglestrips); //adds new strips depending on terrainsquare side*sin(45) against how much viewfrustrum moves, because tilted 45 degree when a terrainsquare takes up maximum xspace and yspace<br />remstripstoright(arrayoftrianglestrips);<br />endproc<br />proc onmousemoveright;<br />angle++;<br />addstripstoright(arrayoftrianglestrips);<br />remstripstoleft(arrayoftrianglestrips);<br />endproc<br />proc onforwardmove;<br />xyz++;<br />addscanlineofstripsfront;<br />removescanlineofstripsback;<br />endproc<br />proc onbackwardmove;<br />xyz--;<br />addscanlineofstripsback;<br />removescanlineofstripsfront;<br />endproc<br />proc onangleminmax; //only work in same 2 quadrants the whole time with small angles and change coordinates to those 2 quadrants when its nesserary to rotate more<br />rotatewholequadrant(arrayoftrianglestrips);<br />endproc<br /></div>
    <div class="meta">Posted on 2007-08-25 07:08:03 by daydreamer</div>
   </div>
   <div class="post" id="post-202741">
    <div class="subject"><a href="#post-202741">Re: Fast 2D Approximation of 3D View Frustum</a></div>
    <div class="body">Having read that, I am inclined to throw away my expensive-looking code and algorithm.<br />I really only want to create &quot;a simple 2D hull that tightly fits the view frustum&#039;s 2D projection&#039;, ie, I want a decent APPROXIMATION of the view frustum, and in 2 dimensions.<br /><br />I have been staring at my old code for &#039;extracting the 3D view frustum from the current projection and view matrices&#039;, which works by &#039;deforming a unit cube&#039; via the Inverse of the aforementioned Transform matrices.<br />It occurs to me that rather than deforming a 3D Cube, I could be deforming a much simpler 3D geometry to begin with...<br /><br /><br />The following code deforms a Unit Square into a 3D Frustum Trapezoid.<br />We still need to get rid of the Y component in the output vertices,<br />but nonetheless we&#039;ve now got a relatively accurate and still tightly-fitting four-sided hull, and we&#039;ve eliminated mountains of processing..<br /><pre><code><br />.data<br />FrustumSquare D3DXVECTOR3 &lt;-0.5f,&nbsp; 0.0f,&nbsp; 0.0f&gt;, 	;left middle front<br />					 &lt;-0.5f,&nbsp; 0.0f,&nbsp; 1.0f&gt;,	&nbsp; &nbsp; &nbsp;  ;left middle back<br />					 &lt; 0.5f,&nbsp; 0.0f,&nbsp; 1.0f&gt;,	&nbsp; &nbsp; &nbsp; &nbsp; ;right middle back<br />					&nbsp; &lt; 0.5f,&nbsp; 0.0f,&nbsp; 0.0f&gt;		;right middle front<br />.code<br />ApproxFrustumVerticesFromView proc uses esi edi ecx,pmatView,pmatProj,pOutputVertices<br />LOCAL matComb:D3DXMATRIX<br />LOCAL imatComb:D3DXMATRIX<br />	invoke D3DXMatrixMultiply,addr matComb, pmatView, pmatProj<br />	invoke D3DXMatrixInverse, addr imatComb,NULL, addr matComb	<br />	xor ecx,ecx<br />	lea esi,FrustumSquare<br />	mov edi,pOutputVertices<br />	.while ecx&lt;4<br />		push ecx<br />		invoke D3DXVec3TransformCoord, edi,esi, addr imatComb<br />		add esi,sizeof Vec3<br />		add edi,sizeof Vec3<br />		pop ecx<br />		inc ecx<br />	.endw<br />	ret<br />ApproxFrustumVerticesFromView endp<br /></code></pre><br /><br />Happy Day :)<br /></div>
    <div class="meta">Posted on 2007-08-25 11:13:40 by Homer</div>
   </div>
   <div class="post" id="post-202742">
    <div class="subject"><a href="#post-202742">Re: Fast 2D Approximation of 3D View Frustum</a></div>
    <div class="body">The last pieces of the puzzle:<br /><br /><pre><code><br /><br />externdef g_dHalfMapSize:dword					;eg 512 if bitmap is 1024 x 1024 pixels<br />externdef g_fHalfWorldSize:real4 				;eg 5000.0f if World is 10,000 units across<br /><br />;Functions to convert (&#039;Map&#039;) coords from 2D &#039;HeightMapSpace&#039; to 3D WorldSpace, and back again..<br />;Note that for 3D, the Y axis is NOT a valid 3D component and is essentially ignored.<br /><br />;Convert 3D World Coordinate into 2D PixelMap Coordinate<br />WorldSpaceToHeightMappingSpace proc pvOut:ptr D3DXVECTOR2, pvIn:ptr D3DXVECTOR3<br />LOCAL multiplier	<br />	mov edx,pvIn<br />	mov eax,pvOut<br />	fld 	g_fHalfWorldSize<br />	fidiv 	g_dHalfMapSize<br />	fst 	multiplier<br />	fmul	.D3DXVECTOR3.x<br />	fiadd	g_dHalfMapSize<br />	fstp	.D3DXVECTOR2.x<br />	fld 	.D3DXVECTOR3.z<br />	fmul	multiplier<br />	fiadd	g_dHalfMapSize<br />	fstp	.D3DXVECTOR2.y	<br />	ret<br />WorldSpaceToHeightMappingSpace endp<br /><br />;Convert 2D PixelMap Coordinate into 3D WorldSpace Coordinate (with Y set to zero)<br />HeightMappingSpaceToWordSpace proc pvOut:ptr D3DXVECTOR3, pvIn:ptr D3DXVECTOR2 <br />LOCAL multiplier	<br />	mov edx,pvIn<br />	mov eax,pvOut<br />	fld 	g_dHalfMapSize<br />	fidiv 	g_fHalfWorldSize<br />	fstp 	multiplier<br />	;Convert 2D X to 3D X<br />	fld		.D3DXVECTOR2.x<br />	fisub	g_dHalfMapSize<br />	fmul	multiplier<br />	fstp	.D3DXVECTOR3.x<br />	;Convert 2D Y to 3D Z<br />	fld 	.D3DXVECTOR2.y<br />	fisub	g_dHalfMapSize<br />	fmul	multiplier<br />	fstp	.D3DXVECTOR3.z<br />	;Clamp 3D Y = 0<br />	fldz<br />	fstp	.D3DXVECTOR3.y<br />HeightMappingSpaceToWordSpace endp<br /><br /></code></pre><br /><br />and the driving method of the Camera class...<br /><br /><pre><code><br />;This method returns an array of four 2D coords<br />;which represent an approximation of the View frustum<br />;mapped into HeighMap Space, that we will use to<br />;identify the currently visible HeighMap Pixels (Terrain Vertices)<br />;and which we will store as a Y-Sorted List of X-Spans<br />;The caller is responsible for MemFreeing the returned array..<br />Method Camera.Build2DFrustum,uses esi<br />LOCAL Out3D[4]:D3DXVECTOR3<br />	SetObject esi<br />	;Extract APPROXIMATE 3D version of Frustum Vertices<br />	invoke ApproxFrustumVerticesFromView,addr .m_view,addr .m_projection,addr Out3D<br />	;Map the 3D WorldSpace coords into 2D HeightmapSpace coords<br />	push $MemAlloc (sizeof D3DXVECTOR2*4)<br />	lea edx,Out3D<br />	xor ecx,ecx	<br />	.while ecx&lt;4<br />		push eax<br />		push edx<br />		invoke WorldSpaceToHeightMappingSpace,eax, edx<br />		pop edx<br />		pop eax<br />		add eax, sizeof D3DXVECTOR2<br />		add edx, sizeof D3DXVECTOR3<br />		inc ecx<br />	.endw<br />	;Return ptr to array of 2D output coords <br />	pop eax<br />MethodEnd<br /><br /></code></pre><br /><br />There, now we have all that we need to obtain our 2D frustum in HeightMapping Space :)<br />Now we need to Rasterize ... identify which Pixels of the HeightMap are inside the 2D approximated frustum, and create a Y-Sorted list of X-Spans identifying which HeightMap Pixels are visible.. then we have to contrast that with the List created in the PREVIOUS FRAME in order to identify which Pixels are new (need to generate Vertices for them), and which Pixels and Spans are now redundant (need to trash those Vertices).<br />Then, use the new and old SpanList and VB to build a new VB and IB.<br />Finally, switch the current and spare SpanList and VB for the Next frame.<br /><br />The reason we drive all of this from the Camera class is because we don&#039;t need to do ANY of this until the Camera View changes (in position and/or orientation), and the chances of our Camera class containing methods with names such as &#039;onViewChanged&quot; are very good indeed..<br /><br />Have a nice day :)<br /></div>
    <div class="meta">Posted on 2007-08-25 13:32:42 by Homer</div>
   </div>
   <div class="post" id="post-202746">
    <div class="subject"><a href="#post-202746">Re: Fast 2D Approximation of 3D View Frustum</a></div>
    <div class="body">About the original problem, why not choose the 4 longest edges (2D) as lying on the lines of that quad. In the rare case of having a fifth edge being at least 50% of the shortest of these 4 edges, test whether to use it with permuting the subset-of-4-edges and calculating respective surface-area, to find the smallest area and the respective subset-of-4-edges. </div>
    <div class="meta">Posted on 2007-08-25 17:59:40 by Ultrano</div>
   </div>
   <div class="post" id="post-202749">
    <div class="subject"><a href="#post-202749">Re: Fast 2D Approximation of 3D View Frustum</a></div>
    <div class="body"><div class="quote"><br />proc render;<br />3dtransformanddraw(arrayoftrianglestrips);<br />endproc<br /><br />proc onforwardmove;<br />xyz++;<br />addscanlineofstripsfront;<br />removescanlineofstripsback;<br />endproc<br /></div><br />in my already existing halfbaked terrainengine proc render already exist, except it doesnt support rotation yet<br />all those addscanlineofstripsfront is gonna be based on scanline conversion comparing old scanline and add or rem strips and directly read from heightmap<br />because I have interest of get my trianglestrips perform a little better than a single run across the screen on the cost of garbage right outside left and right of screen I intentionally want a SLOPPY 2dfrustrum calculation so garbage will not accidently get inside screenspace<br /><br />by extending quads at one end of a trianglestrip by overwriting others we can have a performancegain because we not need to perform any removescanlinestrips<br />but need have a buffer on unused stripdata between the strips and unused data for whole strips<br />my data look like an array of trianglestrips ala scanlines on a bitmap<br />I want an opinion on how much bufferspace between scanlines should be enough to perform extension up in memory+when adding and vertexpointer++ when removing when rotation of camera gives me an uneven movement of this &quot;scrolling&quot; and also dont want to accidently get it to be so huge so it gets to be performancehit when GPU reads vertexbuffer<br /></div>
    <div class="meta">Posted on 2007-08-26 05:05:31 by daydreamer</div>
   </div>
   <div class="post" id="post-202756">
    <div class="subject"><a href="#post-202756">Re: Fast 2D Approximation of 3D View Frustum</a></div>
    <div class="body"><strong>homer:</strong> I think you should keep the expensive code + algorithm instead of editing it out, since it can be a useful learning experience to follow the evolution of an algorithm... although a &quot;read on&quot; &quot;warning&quot; and strike-through&#039;ing the slower stuff is a good idea.<br />goes back to lurking.<br /></div>
    <div class="meta">Posted on 2007-08-27 05:05:23 by f0dder</div>
   </div>
   <div class="post" id="post-202776">
    <div class="subject"><a href="#post-202776">Rasterizing the 2D Frustum Hull</a></div>
    <div class="body">My goal is to compare the 2D region (enclosed by the 2D Frustum Hull) against the 2D HeightMap to determine which Terrain Vertices (HeightMap Pixels) are Visible, and which are not.<br />My existing Rasterizing code is loosely based on Bresenham&#039;s Line Drawing algo.<br /><br />The Frustum Hull is described as four 2D coordinates (A, B, C, D) arranged as two Interpolation Edges (AB, CD). When rasterizing, we will simultaneously walk along both EdgeAB and EdgeCD.<br />However, rather than scanning Pixels at some strange 2D angle, I will describe how to calculate Horizontal Spans of pixels (in X) at each ScanLine (in Y).<br /><br />Let&#039;s look at the linear equation which describes a 2D Edge (X,Y)<br />1. Gradient = dY / dX (where d is &#039;delta&#039;).<br /><br />We can transpose this Formula to solve to dX or dY as follow:<br />2. dX = dY / Gradient<br />3. dY = dX * Gradient<br /><br />So, for a given HeightMap Y coordinate, we can now find a matching X coordinate on any Edge.<br />Or for a given X coord, we can find Y on any Edge.<br /><br />Now we can quickly find the XY Maxima and Minima, and scan using a nested loop.<br />At each Y, we can calculate X on each Edge.<br />If both X values are legal (lay along their respective Edge), we&#039;ve identified a Span.<br /><br /></div>
    <div class="meta">Posted on 2007-08-30 00:37:53 by Homer</div>
   </div>
   <div class="post" id="post-202777">
    <div class="subject"><a href="#post-202777">Re: Fast 2D Approximation of 3D View Frustum</a></div>
    <div class="body">I decided to try a different way, so I went modelling a trianglestrip which I intend to import and modify at runtime to upperhalf will form a skydome and lowerhalf will keep crap outside of 2dfrustrum and add appropiate number of meshes on the floor, so you can just insert Y&#039;s there<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2411" target="_blank">trianglestrip.jpg</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-08-30 00:51:12 by daydreamer</div>
   </div>
   <div class="post" id="post-202828">
    <div class="subject"><a href="#post-202828">Re: Fast 2D Approximation of 3D View Frustum</a></div>
    <div class="body">Apart from the skydome, you have almost exactly described my &quot;sparse radial oversampling&#039; concept.<br /><br />I have written (efficient) code to rasterize the 2D frustum hull edges into a contiguous series of Spans, as you would find in a more lowlevel software renderer / polygon filler.<br />Each Span represents a horizontal run of pixels that we would normally use to Fill the 2d hull, and each Span owns a small list of Terrain Vertices...<br />The SpanBuffer is dynamic.. when I have rasterized the hull, I take the output Spans, and I Clip the Spans ALREADY in the SpanBuffer (from previous Frame) against the new Spans, expanding and shrinking the SpanList both in X and Y as required to accomodate the New set. During this process, any redundant Spans (and their Vertices) are trashed, and any new Spans and their Vertices are generated.<br />We touch as few Vertices as possible, we edit the SpanList as little as possible.<br />Now we have updated the SpanList, we can use its contents to feed a TriangleStrip Generator.<br />We can generate one TriangleStrip between the Vertices contained in each two Spans.<br />We will have several relatively short TriStrips, which is slightly less efficient than generating one single TriStrip.. but there are no &#039;mutant&#039; vertices joining the TriStrips in this scheme.. and it will work where subsequent spans are displaced in X and/or are of different lengths (do not align at their ends).<br /><br />How would you create a single tri-strip for pixels arranged in arbitrary linear runs?<br /><div class="quote"><br />&nbsp; &nbsp;  ---<br />&nbsp;  ----------<br />&nbsp; -------------------<br />&nbsp;  ---------------------------<br />&nbsp; &nbsp; &nbsp; --------------------------<br />&nbsp; &nbsp; &nbsp; &nbsp;  ----------------------<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ------------------<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  -------------<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ----- <br /></div><br /><br />It is time now to write my Tesselator, I am inclined to:<br />A) expand the 2d hull slightly beyond the actual view frustum<br />B) while creating a tristrip between two spans A and B, ignore any vertices in row A which have no Y-neighbour in span B. This means that the edges of our tesselation will look as jagged as my ascii art - which is fine, because that is happening just beyond the actual view ;)<br /><br />I could add a few triangular Filler polygons at the problem locations to solve this issue completely .. but I am attracted to the workaround on several levels.. a somewhat expanded view would allow the activation of nearby entities without requiring us to continually measure their proximity.. what do you think?<br /><br /></div>
    <div class="meta">Posted on 2007-09-03 00:29:04 by Homer</div>
   </div>
   <div class="post" id="post-202839">
    <div class="subject"><a href="#post-202839">Re: Fast 2D Approximation of 3D View Frustum</a></div>
    <div class="body">I have almost finished writing the pixel-to-span rasterizer and span-to-trianglestrip tesselator stuff.<br />Everything builds fine, but I&#039;m yet to test it properly, and theres a couple of functions unwritten, especially a function to generate a newly visible Vertex&#039;s UV values.<br /><br />That was deliberate, because this terrain engine will be using single pass multi-texturing.<br />I have not decided exactly what I plan to do, but likely it will be similar to my previous &#039;terrain texture generator&#039; code, which was based on my guesses about the internals of a free utility called T2, which would be excellent if it only used bilinear or some other kind of filter versus the staircase effect..<br /><br />There will be a Base texture painted using texture stage 0.<br />Its very coarse looking in the real world, but when blended with some other textures, can help add a different feel to different regions of the world.<br />There will be several layers of terrain texture, with weighting applied by per vertex alpha blending... so perhaps four more texture stages used up<br />On top of that will be a spare layer or two for &#039;Splatting&#039; temporary textures on the Terrain.<br />We have EIGHT stages available for single pass blending (on a non prehistoric video card), and we can apply different kinds of blends at each Stage.<br />Early testing will be just two stages.<br /><br />I&#039;ve shoved all the spanlist and rasterizing and tesselating code into an object called SpanList, and changed my Camera class to create one of these support objects during its Init method.<br />Each Camera will own a SpanList.. I don&#039;t like this, I&#039;ll change it again later, I just wanted to make clear the association between Camera and SpanList.<br /><br />So, I&#039;m ready to test (and probably, debug) what I have done, but I am inclined to now make a firm decision about how the UV Blending Weights will be calculated, and write a Vertex generator, before I even begin testing the existing code (did I mention it compiled ok? lol)<br /><br />I&#039;m thinking that the terrain detail textures,although requiring separate Teture stages, can share common UV coordinates, so my Vertex Format might look something like this:<br /><div class="quote"><br />TerrainVertex struct<br />vPosition&nbsp;  D3DXVECTOR3 &lt;&gt;&nbsp;  ;Position of Vertex in 3D WorldSpace<br />vNormal&nbsp; &nbsp;  D3DXVECTOR3 &lt;&gt;&nbsp; &nbsp;  ;We need per vertex normals for nice Lighting<br />TexUVBase D3DXVECTOR2 &lt;&gt;&nbsp; &nbsp;  ;Texture Coords for BaseTexture<br />TexUVDetail D3DXVECTOR &lt;&gt;&nbsp; &nbsp;  ;Texture Coords for all Detail Textures<br />TerrainVertex ends<br /></div><br /><br />One extra 2D vector per vertex - nothin to worry about :)<br /></div>
    <div class="meta">Posted on 2007-09-04 08:29:31 by Homer</div>
   </div>
  </div>
 </body>
</html>