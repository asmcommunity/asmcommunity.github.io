<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>checking if file is PE - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=6533" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=6533">checking if file is PE</a></p>
   <div class="post" id="post-47165">
    <div class="subject"><a href="#post-47165">checking if file is PE</a></div>
    <div class="body">i am kinda newbie to this PE matter, so having some unclear stuff<br />in icz tutorial about this topic he created program for checking <br />if certain file is PE<br />i saw that he used memory mapping file<br />to map selected file in memory and then check to see if its PE<br /><br />so my question is, in order to check if file is valid PE, is it really necessairly<br />to do memory mapping of file or its possible to it by checking file on hdd<br />somthing like, open file for read, do checks at certain offsets in file to compare<br />for PE characteristics (like PE\0\0 and other) ?<br /><br />ps. one more thing, when file is memory mapped, its loaded in memory exactly as it<br />is on hard disk right?<br />ok, so i readed somewhere that kernel loader when loading exe PE files<br />use this MMF technique, and i also readed that PE at hdd and in memory are<br />not same, so how come is that? does kernel loader use some kind different MMF<br />specially designed for loading PE files or what</div>
    <div class="meta">Posted on 2002-07-11 17:04:55 by Mikky</div>
   </div>
   <div class="post" id="post-47168">
    <div class="subject"><a href="#post-47168">checking if file is PE</a></div>
    <div class="body">It is absolutely not necessary to memory map the file. Simply open the file, read IMAGE_DOS_HEADER structure. Verify its signature is equal to &quot;MZ&quot;, if no - abort. Then, <strong><u>SetFilePointer</u></strong> to IMAGE_DOS_HEADER.e_lfanew and read IMAGE_NT_HEADERS structure. Verify signature is &quot;PE&quot;.</div>
    <div class="meta">Posted on 2002-07-11 17:11:28 by comrade</div>
   </div>
   <div class="post" id="post-47180">
    <div class="subject"><a href="#post-47180">checking if file is PE</a></div>
    <div class="body">are u sure about this?<br />i mean, all those structures that describes PE headers, are they applied on PE file in memory or in hard disc??<br />is there any difference between them (my ps. question in 1st post)<br /><br />i also found on some other places (like famous matt pietrik PE tutorial) that he also used MMF method for this in his sample program</div>
    <div class="meta">Posted on 2002-07-11 20:51:53 by Mikky</div>
   </div>
   <div class="post" id="post-47181">
    <div class="subject"><a href="#post-47181">checking if file is PE</a></div>
    <div class="body">When you use file mapping the file's content is exacly the same as it is on the hard disk. the sections of the PE file that are affected by being loaded into memory are only effected if the PE file was loaded by the windows PE loader.</div>
    <div class="meta">Posted on 2002-07-11 21:04:26 by Kudos</div>
   </div>
   <div class="post" id="post-47191">
    <div class="subject"><a href="#post-47191">checking if file is PE</a></div>
    <div class="body">hi all<br /> lots of info 'bout pe<br />Microsoft Portable Executable and Common Object File Format Specification <br /><a target="_blank" href="http://www.microsoft.com/hwdev/download/hardware/PECOFF.pdf">http://www.microsoft.com/hwdev/download/hardware/PECOFF.pdf</a><br />later</div>
    <div class="meta">Posted on 2002-07-11 22:54:04 by b0z0</div>
   </div>
   <div class="post" id="post-47192">
    <div class="subject"><a href="#post-47192">checking if file is PE</a></div>
    <div class="body">Mikky,<br /><br />Comrade has told you the right way to test if a file is a 32 bit PE file. Read the &quot;e_lfanew&quot; member of the MZ header to determine if the file is a PE file.<br /><br />An even easier way is to read the 1st 500 bytes or so of the file and search for the string PE with two ascii zeros appended.<br /><br />If its there, the file is a PE file, if its not, its not a PE file.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-07-11 23:35:04 by hutch--</div>
   </div>
   <div class="post" id="post-47196">
    <div class="subject"><a href="#post-47196">checking if file is PE</a></div>
    <div class="body">hutch--,<br /><br />I've seen some files with very big DOS part, thus your advise is not completely correct.<br />If dword on 3Ch from start (e_lfanew) points on P,E,0,0 (50, 45, 00, 00), then it is PE.</div>
    <div class="meta">Posted on 2002-07-12 00:26:53 by masquer</div>
   </div>
   <div class="post" id="post-47203">
    <div class="subject"><a href="#post-47203">checking if file is PE</a></div>
    <div class="body"><div class="quote"><em>in order to check if file is valid PE, is it really necessairly<br />to do memory mapping of file or its possible to it by checking file on hdd<br />somthing like, open file for read, do checks at certain offsets in file to compare<br />for PE characteristics (like PE<div class="quote"><em>in order to check if file is valid PE, is it really necessairly<br />to do memory mapping of file or its possible to it by checking file on hdd<br />somthing like, open file for read, do checks at certain offsets in file to compare<br />for PE characteristics (like PE\0\0 and other) ?</em></div><br /><br />It' absolutelly indifferent what method you use to read file contents.<br />Actually it's different in way how OS loads it in memory, but for checking if file PE or not it's not important.<br /><br /><div class="quote"><em>ps. one more thing, when file is memory mapped, its loaded in memory exactly as it<br />is on hard disk right?<br />ok, so i readed somewhere that kernel loader when loading exe PE files<br />use this MMF technique, and i also readed that PE at hdd and in memory are<br />not same, so how come is that?</em></div><br /><br />Right and wrong at the same time.<br />PE consist of number of sections. Sections, among other, have some characteristics:<br /><strong>RawOffset<br />VirtualOffset<br />RawSize<br />VirtualSize<br />...</strong><br /><br />Sections are aligned. But alignment can be different on HDD and in memory.<br />There are fields SectionAlignment and FileAlignment in optional header.<br />SectionAlignment is alignment in memory.<br />FileAlignment is alignment on HDD.<br />The alignment in memory can't be &lt; page size (4k), because sections have different access right.<br />.text - executable &amp; readable<br />.data - readable &amp; writable<br />and so on.<br />But on HDD sections can have smaller alignment (to save disk space).<br /><br />So RawOffset of section is offset from beginning of file.<br />But VirtualOffset is offset from image base in memory.<br />If SectionAlignment != FileAlignment<br />  RawOffset != VirtualOffset<br /><br />Loader not maps PE header in memory because of PE header is needed only by loader itself.<br />When PE is loaded header is useless.<br />.text, .rdata, .rsrc sections are mapped as is, because of read only attribute.<br />.data section remains as on HDD before every first writing to it by executable itself.<br />.reloc also is needed only by loader itself and only if it can't map PE to preferable ImageBase.<br />Also in every PE that is importing something, there is import directory.<br />At load time OS loader changes the part of import directory called IAT (Import Address Table).<br />It happens only if import is not binded.<br />So, as you can see, there is some little difference.<br />There are also other section types.<br /><br /><div class="quote"><em>does kernel loader use some kind different MMF<br />specially designed for loading PE files or what</em></div><div class="quote"><em>in order to check if file is valid PE, is it really necessairly<br />to do memory mapping of file or its possible to it by checking file on hdd<br />somthing like, open file for read, do checks at certain offsets in file to compare<br />for PE characteristics (like PE\0\0 and other) ?</em></div><br /><br />It' absolutelly indifferent what method you use to read file contents.<br />Actually it's different in way how OS loads it in memory, but for checking if file PE or not it's not important.<br /><br /><div class="quote"><em>ps. one more thing, when file is memory mapped, its loaded in memory exactly as it<br />is on hard disk right?<br />ok, so i readed somewhere that kernel loader when loading exe PE files<br />use this MMF technique, and i also readed that PE at hdd and in memory are<br />not same, so how come is that?</em></div><br /><br />Right and wrong at the same time.<br />PE consist of number of sections. Sections, among other, have some characteristics:<br /><strong>RawOffset<br />VirtualOffset<br />RawSize<br />VirtualSize<br />...</strong><br /><br />Sections are aligned. But alignment can be different on HDD and in memory.<br />There are fields SectionAlignment and FileAlignment in optional header.<br />SectionAlignment is alignment in memory.<br />FileAlignment is alignment on HDD.<br />The alignment in memory can't be &lt; page size (4k), because sections have different access right.<br />.text - executable &amp; readable<br />.data - readable &amp; writable<br />and so on.<br />But on HDD sections can have smaller alignment (to save disk space).<br /><br />So RawOffset of section is offset from beginning of file.<br />But VirtualOffset is offset from image base in memory.<br />If SectionAlignment != FileAlignment<br />  RawOffset != VirtualOffset<br /><br />Loader not maps PE header in memory because of PE header is needed only by loader itself.<br />When PE is loaded header is useless.<br />.text, .rdata, .rsrc sections are mapped as is, because of read only attribute.<br />.data section remains as on HDD before every first writing to it by executable itself.<br />.reloc also is needed only by loader itself and only if it can't map PE to preferable ImageBase.<br />Also in every PE that is importing something, there is import directory.<br />At load time OS loader changes the part of import directory called IAT (Import Address Table).<br />It happens only if import is not binded.<br />So, as you can see, there is some little difference.<br />There are also other section types.<br /><br /><div class="quote"><em>does kernel loader use some kind different MMF<br />specially designed for loading PE files or what</em></div> and other) ?</em></div><br /><br />It' absolutelly indifferent what method you use to read file contents.<br />Actually it's different in way how OS loads it in memory, but for checking if file PE or not it's not important.<br /><br /><div class="quote"><em>ps. one more thing, when file is memory mapped, its loaded in memory exactly as it<br />is on hard disk right?<br />ok, so i readed somewhere that kernel loader when loading exe PE files<br />use this MMF technique, and i also readed that PE at hdd and in memory are<br />not same, so how come is that?</em></div><br /><br />Right and wrong at the same time.<br />PE consist of number of sections. Sections, among other, have some characteristics:<br /><strong>RawOffset<br />VirtualOffset<br />RawSize<br />VirtualSize<br />...</strong><br /><br />Sections are aligned. But alignment can be different on HDD and in memory.<br />There are fields SectionAlignment and FileAlignment in optional header.<br />SectionAlignment is alignment in memory.<br />FileAlignment is alignment on HDD.<br />The alignment in memory can't be &lt; page size (4k), because sections have different access right.<br />.text - executable &amp; readable<br />.data - readable &amp; writable<br />and so on.<br />But on HDD sections can have smaller alignment (to save disk space).<br /><br />So RawOffset of section is offset from beginning of file.<br />But VirtualOffset is offset from image base in memory.<br />If SectionAlignment != FileAlignment<br />  RawOffset != VirtualOffset<br /><br />Loader not maps PE header in memory because of PE header is needed only by loader itself.<br />When PE is loaded header is useless.<br />.text, .rdata, .rsrc sections are mapped as is, because of read only attribute.<br />.data section remains as on HDD before every first writing to it by executable itself.<br />.reloc also is needed only by loader itself and only if it can't map PE to preferable ImageBase.<br />Also in every PE that is importing something, there is import directory.<br />At load time OS loader changes the part of import directory called IAT (Import Address Table).<br />It happens only if import is not binded.<br />So, as you can see, there is some little difference.<br />There are also other section types.<br /><br /><div class="quote"><em>does kernel loader use some kind different MMF<br />specially designed for loading PE files or what</em></div><br /><br />AFAIK, the method of MMF used by loader is absolutely the same.<br /><br />PS: There are bunch of functions in Imagehlp.dll (find in your %System%) for working with PE:<br />ImageNtHeader<br />ImageRvaToSection<br />ImageDirectoryEntryToData<br />etc...<br />Consult your API-ref.<br /><br />PPS: I also have seen some files with nonstandart size of DOS stub.</div>
    <div class="meta">Posted on 2002-07-12 02:58:46 by Four-F</div>
   </div>
   <div class="post" id="post-47213">
    <div class="subject"><a href="#post-47213">checking if file is PE</a></div>
    <div class="body">masquer,<br /><br />You are right of course as the suggestion I made for a simplified method did not take into account programs that are designed to run in both DOS and win32.<br /><br />If a simplified method is required, just scan the whole file to find P,E,0,0. The MZ header member &quot;e_lfanew&quot; never fails but it requires loading the MZ header into a structure first.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-07-12 05:28:51 by hutch--</div>
   </div>
   <div class="post" id="post-47292">
    <div class="subject"><a href="#post-47292">checking if file is PE</a></div>
    <div class="body">thanks for the answers guys, now i am beginning to get somthing ;)<br />i have few new questions<br /><br />1. ok so which method is better or lets say faster<br />if we use MMF here to load a big exe file thats going to be<br />slower than to check file from hdd which includes lets say not more<br />than 1kb reading from file<br /><br />2.ImageBase is member of optional header structure, <br />this is from Icezilion PE tut<br /><div class="quote"><br />It's the preferred load address for <br />      the PE file. For example, if the value in this field is 400000h, the PE <br />      loader will try to load the file into the virtual address space starting <br />      at 400000h. The word &quot;preferred&quot; means that the PE loader may <br />      not load the file at that address if some other module already occupied <br />      that address range.<br /></div><br /><br />i dont understand this, if every process runs in its own 4gb memory space<br />doesnt this mean that it has all that memory for it self so loader can load<br />PE everytime at prefered address becouse there is nothing else there<br />but our program...??<br />how can &quot;some other module already occupied that address range.&quot;<br />if there is no other program in my program memory space or maybe this <br />prefered address applys for real physical address in RAM<br />not the virtual that win32 creates for our programs?<br /><br />3. i dont understand all those alignments stuff<br />like FileAlignment and SectionAlignment (members of optional header struct)<br />what are they for? like the things are not complicated enought<br /><br />4. PE is portable so it can executes on different procesors right?<br />ok, but how is that posible if we compiled PE file on x86 so it will have x86 instuctions in it, now how can that file with x86 instuctions execute on i.e. alpha processor??<br />all that zeros and ones in file will represent somthing completly different thing on alpha processor</div>
    <div class="meta">Posted on 2002-07-12 15:54:16 by Mikky</div>
   </div>
   <div class="post" id="post-47294">
    <div class="subject"><a href="#post-47294">checking if file is PE</a></div>
    <div class="body">1. No matter. If your file is big enough MMF will load only needed part.<br /><br />2. Every process run in separate address space, and for every process there is an address 00400000h.<br /><br />3. FileAlignment and SectionAlignment is an alignment in file on disk and in memory respectively :rolleyes: I think it is needed for portability reason.<br /><br />4. If you use x86 instruction, sure you can't run it on Alpha and vice versa. :) PE is just provide unified storage for code and data, which can vary on each platform</div>
    <div class="meta">Posted on 2002-07-12 16:32:55 by masquer</div>
   </div>
   <div class="post" id="post-47313">
    <div class="subject"><a href="#post-47313">checking if file is PE</a></div>
    <div class="body">Well, there are many things in there besides your program. However, in Windows 95 and higher any address between 0x400000 and 0x80000000 is free. But for DLL's, there may be another module at the preferred address. Thus, a DLL could end up in a different address in another address space (but it will make another copy of the data if a page in a nonshared is changed)</div>
    <div class="meta">Posted on 2002-07-12 20:19:12 by Sephiroth3</div>
   </div>
   <div class="post" id="post-47349">
    <div class="subject"><a href="#post-47349">checking if file is PE</a></div>
    <div class="body">In NT and derivates you can find DLL's even at 0x60000000 and such. See this <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=6561">post</a> for a routine to reserve the largest block possible of your process' address space.</div>
    <div class="meta">Posted on 2002-07-13 03:10:04 by Maverick</div>
   </div>
   <div class="post" id="post-47352">
    <div class="subject"><a href="#post-47352">checking if file is PE</a></div>
    <div class="body"><div class="quote"><em>2.ImageBase is member of optional header structure, this is from Icezilion PE tut</em></div><br />It's from COFF (PE) format.<br /><div class="quote"><em>how can &quot;some other module already occupied that address range.&quot;</em></div><br />DLLSkeleton.dll in Tut #17 has ImageBase=10000000.<br />It's linker dafault. If your proggy use more than 2 dll compiled with default image base, loader can't map its to the same address.<br />It should lelocate one of the dll to another free memory.<br />And .reloc section in every dll is for this job.<br /><div class="quote"><em>i dont understand all those alignments stuff...</em></div><br />Icz tuts is good, but it's only very basic knowledge.<br />If you want really understand how all this stuff works don't ask it here.<br />It takes very much time to explain it. Look for PE format description and read.<br />One link is above, another is at the bottom of Icezilion's PE-tut #1 (Luevelsmeyer).<br />Also you can find somethig interesting with the help of google.com.<br />IMO it's best way to learn PE.</div>
    <div class="meta">Posted on 2002-07-13 04:05:16 by Four-F</div>
   </div>
   <div class="post" id="post-47364">
    <div class="subject"><a href="#post-47364">checking if file is PE</a></div>
    <div class="body">Hutch, hrm, simplified method? Might be a little less code<br />to read in &quot;whatever amount&quot; of bytes and do PE,0,0 scanning...<br />but it's not &quot;simpler&quot;. Furthermore, as already mentioned,<br />it can fail to identify PEs because of large DOS stubs, and<br />it can even give false positivies. And there's no reason<br />whatsoever not do do PE identification the &quot;right&quot; way...<br /><br />I've attached a simple example with a simplistic (read: not<br />enough error handling) way of detecting PE files. If you're<br />worried about using too much stack for the MZ header (heh),<br />you could do away with a DWORD instead of the MZ struct, and<br />do a few more SetFilePointer calls.<br /><br />There's a bunch of different ways to handle PE manipulation.<br />The approach typically used (and shown by iczelion in his<br />PE tutorials) involve file mapping. If you're going to use<br />that approach, you might as well do the PE checking as part<br />of setting up the filemapping (instead of calling a &quot;isPEFile&quot;<br />and only doing work if it returns true, call openPEFile and<br />bail out if it's not a PE). I usually map in the PE files as<br />the windows loader does, so I can use RVAs directly as pointers;<br />I'm not coding malware, so using &quot;an amount&quot; of memory is not a<br />problem for me.<br /><br />As for which approach is faster? Dunno if you can feel any<br />difference on such a small operation... it's not going to<br />matter much. MMF *is* slower than normal ReadFile I/O, both<br />in setup time and access speed, but it's not going to be<br />noticeable if you are *only* going to check if a file is a<br />valid PE file.<br /><br />Mikky, about ImageBase... 0x400000 is usually :) free in a<br />process address space, so your app can be loaded there. However,<br />other Imagebases might not be free, especially on 9x that is<br />split into user/shared/kernel. There's also issues when loading<br />DLLs, but fortunately those usually have relocations (even if<br />most developers are too ignorant to set a different imagebase<br />than linker default).<br /><br />Alignment... section alignment has to do with x86 page protection.<br />file alignment is as far as I can tell to make paging operations<br />faster, and the minimum file alignment of 0x200 corresponds nicely<br />with the IDE sector size (afair, if you open a file in uncached<br />mode, you must read sector-aligned and sector-multiple sizes).<br /><br />The PE *format* is portable across processors, but that doesn't<br />mean you can execute x86 on an alpha. Just that you can use the<br />same file format, and thus that a fair amount of the loader code<br />can be kept from machine to machine.</div>
    <div class="meta">Posted on 2002-07-13 07:08:30 by f0dder</div>
   </div>
  </div>
 </body>
</html>