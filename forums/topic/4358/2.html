<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>DayOfWeek (PROC) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4358" />
  <link rel="prev" href="../?id=4358&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=4358">DayOfWeek (PROC)</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=4358&amp;page=1" style="">&laquo;</a><a href="../?id=4358&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="4358" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-101343">
    <div class="subject"><a href="#post-101343">DayOfWeek (PROC)</a></div>
    <div class="body">woah, nice algo!! This is one of those problems that looks easy but you have to sit down and think about it.</div>
    <div class="meta">Posted on 2003-05-05 16:10:08 by x86asm</div>
   </div>
   <div class="post" id="post-102200">
    <div class="subject"><a href="#post-102200">DayOfWeek (PROC)</a></div>
    <div class="body"><strong>x86asm</strong>,<br /><strong>&quot;This is one of those problems that looks easy but you have<br />to sit down and think about it.&quot;</strong><br />We have already correct algorithm (in C) and<br />it is not a big deal to make our proc fastest...Here:<pre><code><br />; Work out what the day of the week is for a given date<br />; Speed optimized x86 assembly &#40;PIII&#41; by Lingo<br />;<br />; C Algorithm by Tomohiko Sakamoto<br />; int dayofweek&#40;int d, int m, int y&#41; &#123;<br />;   static int t&#91;&#93; = &#123; 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 &#125;;<br />;   y -= m &lt; 3;<br />;   return &#40; y + y/4 - y/100 + y/400 + t&#91;m-1&#93; + d&#41; % 7;<br />; &#125;<br />; year  = &#91;1, 9999+&#93;<br />; month = &#91;1, 12&#93;<br />; day   = &#91;1, 31&#93;<br /><br />DayOfWeekL  PROTO year&#58;DWORD, month&#58;DWORD, day&#58;DWORD<br /><br />.data<br />Align 4<br />monthdata   dword 0,3,2,5,0,3,5,1,4,6,2,4<br />.code<br />OPTION PROLOGUE&#58;NONE              ; turn it off<br />OPTION EPILOGUE&#58;NONE              ;<br />Align 16                          ; Align 16 before the proc<br />DayOfWeekL  PROC year&#58;DWORD, month&#58;DWORD, day&#58;DWORD<br />  mov  ecx, &#91;esp+8&#93;               ; ecx=month<br />  mov  edx, &#91;esp+4&#93;	          ; edx=year<br />  cmp  ecx, 3                     ; test if month is &lt; 3<br />  sbb  edx, 0                     ; if month &lt; 3 then dec edx-&gt;years<br />  mov  ecx, &#91;monthdata + ecx*4-4&#93; ; ecx-&gt; monthdata&#91;m-1&#93;  <br />  mov  eax, edx                   ; eax=edx=years<br />  imul edx, 0A3D8h                ; dividing edx=years by 100 == imul edx, 0A3D8h / shr edx, 22 <br />  add  ecx, &#91;esp+12&#93;              ; add day; ecx= monthdata&#91;m-1&#93; + day<br />  add  ecx, eax                   ; ecx-&gt; monthdata&#91;m-1&#93; + day + years <br />  shr  eax, 2                     ; eax= years/4<br />  add  eax, ecx                   ; eax= monthdata&#91;m-1&#93; + day + years + years/4<br />  mov  ecx, &#91;esp&#93;                 ; ecx-&gt;return address<br />  mov  &#91;esp+12&#93;, ecx              ; ecx-&gt;return address to right place<br />  shr  edx, 22                    ; end of dividing ; edx=years/100<br />  sub  eax, edx                   ; eax= monthdata&#91;m-1&#93; +day + years + years/4 - years/100<br />  shr  edx, 2                     ; edx=years/400<br />  add  eax, edx                   ; eax= monthdata&#91;m-1&#93; +day + years + years/4 - years/100 + years/400<br />  mov  edx, 24924925h             ; dividing eax by 7 == mul edx, eax ; 24924925h=dword &#40;1/7 * 2^35&#41;<br />  mov  ecx, eax                   ; ecx= monthdata&#91;m-1&#93;  + day + years + years/4 - years/100 + years/400<br />  mul  edx                        ; dividing eax by 7 -&gt;result in edx<br />  mov  eax, ecx                   ; eax= monthdata&#91;m-1&#93; + day + years + years/4 - years/100 + years/400<br />  lea  ecx, &#91;edx+edx*2&#93;           ; multiplying edx by 7 -&gt;<br />  lea  edx, &#91;ecx+edx*4&#93;           ; -&gt;result in edx  <br />  add  esp, 3*4                   ; clearing the stack from 3 dword parameters<br />  sub  eax, edx                   ; eax= &#40;monthdata&#91;m-1&#93; + day + years + years/4 - years/100 + years/400&#41; % 7<br />  ret                             ; faster return then return 3*4 	<br />DayOfWeekL  ENDP                  ;<br />OPTION PROLOGUE&#58;PROLOGUEDEF       ; turn back on the defaults<br />OPTION EPILOGUE&#58;EPILOGUEDEF       ;<br />&#91;B&#93;Notes&#58;&#91;/B&#93;<br />- Dividing by 100 -&gt; imul edx, 0A3D8h / shr edx, 22 works<br />for all edx in range 0 to AAB2h&#40;43 698&#41;<br />- Dividing by 7 -&gt; mov edx, 24924925h / mul edx works<br />for all eax in range 0 to 55555559h&#40;1 431 655 769&#41;<br /><br />The proc is 80 bytes long and can execute in 19 clocks.<br />Let's analyze it in memory&#58;<br /><br /><br />&#91;B&#93;- Instruction fetch and decoding &#40;11 clocks&#41;&#91;/B&#93;<br />To mark where each ifetch block begins we need &#91;B&#93;Align 16&#91;/B&#93; before<br />the proc &#40;we have to know where the first ifetch block begins&#41;&#58;<br /><br />The first ifetch block begins at 4012E0h. It ends with an unfinished<br />instruction at 4012F0h and the next block will begin at the beginning<br />of this instruction &#40;4012EEh&#41;.<br />The second ifetch block begins at 4012EEh. It ends with an unfinished<br />instruction at 4012FEh and the next block will begin at the beginning<br />of this instruction &#40;4012FD&#41;.<br />The third ifetch block begins at 4012FDh. It ends with an unfinished<br />instruction at 40120Dh and the next block will begin at the beginning<br />of this instruction &#40;40130B&#41;.<br />The fourth block begins at 40130Bh. It ends with an unfinished<br />instruction at 40131Bh and the next block will begin at the beginning<br />of this instruction &#40;401319&#41;.<br />The fifth block begins at 401319h. It ends with an unfinished<br />instruction at 401329h and the next block will begin at the beginning<br />of this instruction &#40;401327&#41;.<br />The sixth block begins at 401327h and covers the rest of the proc.<br /><br />We write D0 as expected decoder at 4012E0h, 4012EEh, 4012FDh, 40130Bh,<br />401319h and 401327.<br /><br />Three of the instructions generate 2 mops&#91;B&#93;<br />&#40;sbb edx, 0 / add ecx, dword ptr &#91;esp+0Ch&#93; / mov dword ptr &#91;esp+0Ch&#93;, ecx&#41;&#91;/B&#93;<br />and one instruction generates 4 mops &#91;B&#93;&#40;ret&#41;&#91;/B&#93;. They must go into decoder D0.  <br /><br />Every ifetch block &#40;without the second&#41; contained two decode blocks &#40;see below&#41;<br />The number of clock cycles it takes to decode this is the number of D0<br />instructions, which are 11.<br />We haven't  loop so that no further analysis of instruction fetching is needed.<br /><br />We can reduce decode clock cycles by manipulating instruction lengths,<br />but in this case it is useless because fetch and decoding are not the bottleneck. <br /><br />&#91;B&#93;Align 16&#91;/B&#93; <br />&#91;B&#93;4012E0&#91;/B&#93;  8B4C2408        mov  ecx, dword ptr &#91;esp+8&#93;         ;&#91;B&#93;D0&#91;/B&#93; 1mop<br />4012E4  8B542404        mov  edx, dword ptr &#91;esp+4&#93;         ;D1 1mop<br />4012E8  83F903          cmp  ecx, 3                         ;D2 1mop<br />4012EB  83DA00          sbb  edx, 0                         ;&#91;B&#93;D0&#91;/B&#93; 2mops<br /><br />&#91;B&#93;4012EE&#91;/B&#93;  8B0C8D448B4000  mov  ecx, dword ptr &#91;ecx*4+408B44h&#93; ;&#91;B&#93;D0&#91;/B&#93; 1mop <br />4012F5  8BC2            mov  eax, edx                       ;D1 1mop<br />4012F7  69D2D8A30000    imul edx, edx, 0A3D8h               ;D2 1mop<br /><br />&#91;B&#93;4012FD&#91;/B&#93;  034C240C        add  ecx, dword ptr &#91;esp+0Ch&#93;       ;&#91;B&#93;D0&#91;/B&#93; 2mops<br />401301  03C8            add  ecx, eax                       ;D1 1mop<br />401303  C1E802          shr  eax, 2                         ;D2 1mop<br />401306  03C1            add  eax, ecx                       ;&#91;B&#93;D0&#91;/B&#93; 1mop <br />401308  8B0C24          mov  ecx, dword ptr &#91;esp&#93;           ;D1 1mop<br /><br />&#91;B&#93;40130B&#91;/B&#93;  894C240C        mov  dword ptr &#91;esp+0Ch&#93;, ecx       ;&#91;B&#93;D0&#91;/B&#93; 2mops<br />40130F  C1EA16          shr  edx, 16h                       ;D1 1mop<br />401312  2BC2            sub  eax, edx                       ;D2 1mop<br />401314  C1EA02          shr  edx, 2                         ;&#91;B&#93;D0&#91;/B&#93; 1mop<br />401317  03C2            add  eax, edx                       ;D1 1mop<br /><br />&#91;B&#93;401319&#91;/B&#93;  BA25499224      mov  edx, 24924925h                 ;&#91;B&#93;D0&#91;/B&#93; 1mop<br />40131E  8BC8            mov  ecx, eax                       ;D1 1mop<br />401320  F7E2            mul  eax, edx                       ;D2 1mop<br />401322  8BC1            mov  eax, ecx                       ;&#91;B&#93;D0&#91;/B&#93; 1mop<br />401324  8D0C52          lea  ecx, &#91;edx+edx*2&#93;               ;D1 1mop<br /><br />&#91;B&#93;401327&#91;/B&#93;  8D1491          lea  edx, &#91;ecx+edx*4&#93;               ;&#91;B&#93;D0&#91;/B&#93; 1mop<br />40132A  83C40C          add  esp, 0Ch                       ;D1 1mop<br />40132D  2BC2            sub  eax, edx                       ;D2 1mop<br />40132F  C3              ret                                 ;&#91;B&#93;D0&#91;/B&#93; 4mops<br />Length&#58; 40132Fh-4012E0h+1=50h=80 bytes                      ;Total&#58; &#91;B&#93;11 D0&#91;/B&#93;s<br /><br /><br />&#91;B&#93;- Register stalls&#91;/B&#93;<br />No register is read in this proc without being written to at least<br />a few clock cycles before, so there can be no register read stalls. <br /><br />&#91;B&#93;- Execution &#40;19 clocks&#41;&#91;/B&#93;<br />Counting the mops for the different ports we get&#58;<br />port 0 or 1&#58; 12 mops<br />port 0 only&#58; 7 mops<br />port 2&#58; 5 mops<br />port 3&#58; 1 mop<br />port 4&#58; 1 mop<br />Assuming that the mops that can go to either port 0 or 1 are distributed<br />optimally, the execution time will be 10 clocks, but we have dependency<br />chains and ports 0 and 1 are saturated, so<br />the execution time will be 14 clocks&#40;see below&#41;.<br /><br />&#91;B&#93;Note&#58;&#91;/B&#93;<br />A series of instructions where each instruction depends on the result of<br />the preceding one is called a dependency chain. Long dependency chains<br />prevent out-of-order and parallel execution.<br /> <br />4012E0  8B4C2408        mov  ecx, dword ptr &#91;esp+8&#93;        ;1mop p2 rESPwECX<br /><br />4012E4  8B542404        mov  edx, dword ptr &#91;esp+4&#93;        ;1mop p2 rESPwEDX<br />4012E8  83F903          cmp  ecx, 3                        ;1mop p01 rECXwF<br /><br />4012EB  83DA00          sbb  edx, 0                        ;2mops p01 rwEDXrwF<br />4012EE  8B0C8D448B4000  mov  ecx, dword ptr &#91;ecx*4+408B44h&#93;;1mop p2 rwECX<br /> <br />4012F5  8BC2            mov  eax, edx                      ;1mop p01 rEDXwEAX<br />4012F7  69D2D8A30000    imul edx, edx, 0A3D8h              ;1mop p0 rwEDXwF<br /><br />4012FD  034C240C        add  ecx, dword ptr &#91;esp+0Ch&#93;      ;2mops p01 p2 rESPrwECXwF<br /><br />401301  03C8            add  ecx, eax                      ;1mop p01 rEAXrwECXwF<br />401303  C1E802          shr  eax, 2                        ;1mop p0 rwEAXwF<br /><br />401306  03C1            add  eax, ecx                      ;1mop p01 rECXrwEAXwF<br />401308  8B0C24          mov  ecx, dword ptr &#91;esp&#93;          ;1mop p2 rESPwECX<br /><br />40130B  894C240C        mov  dword ptr &#91;esp+0Ch&#93;, ecx      ;2mops p3 p4 rECXrESP<br />40130F  C1EA16          shr  edx, 16h                      ;1mop p0 rwEDXwF<br /><br />401312  2BC2            sub  eax, edx                      ;1mop p01 rEDXrwEAX<br />401314  C1EA02          shr  edx, 2                        ;1mop p0 rwEDXwF<br /><br />401317  03C2            add  eax, edx                      ;1mop p01 rEDXrwEAXwF<br />401319  BA25499224      mov  edx, 24924925h                ;1mop p01 wEDX<br /><br />40131E  8BC8            mov  ecx, eax                      ;1mop p01 rEAXwECX<br />401320  F7E2            mul  eax, edx                      ;1mop p0  rwEAXrwEDXwF<br /><br />401322  8BC1            mov  eax, ecx                      ;1mop p01 rECXwEAX<br />401324  8D0C52          lea  ecx, &#91;edx+edx*2&#93;              ;1mop p0  rEDXwECX<br /><br />401327  8D1491          lea  edx, &#91;ecx+edx*4&#93;              ;1mop p0 rECXrwEDX<br />40132A  83C40C          add  esp, 0Ch                      ;1mop p01 rwESPwF<br /><br />40132D  2BC2            sub  eax, edx                      ;1mop p01 rEDXrwEAX<br /><br />40132F  C3              ret		<br /><br />We must add 8 clocks since the slow imul and mul instructions have a delay of<br />4 clocks each. The execution time will be 14 clocks + 8 = 22 clocks<br /><br />Five instructions after &#91;B&#93;imul&#91;/B&#93; &#40;3 clocks&#41; are executed &quot;for free&quot; because they<br />are in the 4 clocks delay of &#91;B&#93;imul edx, edx, 0A3D8h&#91;/B&#93; and don't depend<br />on &#91;B&#93;imul&#91;/B&#93; instruction.<br /><br />The expected execution time will be 14 clocks + 8 - 3 = 19 clocks.<br /><br /><br />&#91;B&#93;- Retirement &#40;10 clocks&#41;&#91;/B&#93;<br />The time needed for retirement is the number of mops divided by 3, and rounded<br />up to nearest integer. This gives 28/3 =10 clocks for retirement. <br /><br />In conclusion, the proc can execute in 19 clocks. </code></pre><br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-05-09 21:09:34 by lingo12</div>
   </div>
   <div class="post" id="post-102206">
    <div class="subject"><a href="#post-102206">DayOfWeek (PROC)</a></div>
    <div class="body"><strong>lingo12</strong>, the most wonderful part of your algos are the explainations! :alright:<br />(I have saved the whole thing and posted in the snippet library <a target="_blank" href="http://www.madwizard.org/snippets/viewSnippet.php?s_ID=64">- here -</a>)<br /><br />Takes 12 cycles on an Athlon. Hard to get faster. :)<br /><br /><pre><code>; Divide by 100<br />	imul	edx, eax, 147AFh ; valid until C800 &#40;51 200&#41;<br />	shr	edx, 23<br /><br />; Divide by 7<br />	imul	edx, eax, 12493h ; valid until E000 &#40;57 344&#41;<br />	shr	edx, 19</code></pre></div>
    <div class="meta">Posted on 2003-05-09 22:03:42 by bitRAKE</div>
   </div>
   <div class="post" id="post-102267">
    <div class="subject"><a href="#post-102267">DayOfWeek (PROC)</a></div>
    <div class="body">Thank you bitRAKE,<br /><br /><strong>&quot;; Divide by 100<br />imul edx, eax, 147AFh ; valid until C800 (51 200)<br />shr edx, 23&quot;</strong><br /><br />imul<strong> EDX, EDX,</strong> 0A3D8h / SHR EDX,22 <br />This free EAX register and I use it for &quot;parallel&quot; execution of next code.<br /><br /><br /><strong>&quot;; Divide by 7<br />imul edx, eax, 12493h ; valid until E000 (57 344)<br />shr edx, 19 &quot;</strong><br /><br />with:<br />&quot;mov  edx, 24924925h <br />mul   edx&quot;<br />I just <strong>avoid SHR EDX, b</strong> instruction in the end.<br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-05-10 07:56:09 by lingo12</div>
   </div>
   <div class="post" id="post-102273">
    <div class="subject"><a href="#post-102273">DayOfWeek (PROC)</a></div>
    <div class="body"><strong>lingo12</strong>, yes I saw the use of MUL in the end to save the the SHR - there are already enough dependancies there - creative choice.<div class="quote">imul<strong> EDX, EDX,</strong> 0A3D8h / SHR EDX,22 <br />This free EAX register and I use it for &quot;parallel&quot; execution of next code.</div>I did not know this was a problem on P3 - does not appear to effect the execution speed on Athlon.<br /><br />Save a byte?:<pre><code>	add	eax, edx<br />	shl	edx, 3<br />	add	esp, 3*4<br />	sub	eax, edx<br />	ret</code></pre>I don't think the proc works for Year=0 and Month &lt; 3.</div>
    <div class="meta">Posted on 2003-05-10 08:58:34 by bitRAKE</div>
   </div>
   <div class="post" id="post-102311">
    <div class="subject"><a href="#post-102311">DayOfWeek (PROC)</a></div>
    <div class="body">bitRAKE,<br /><strong>&quot;I don't think the proc works for Year=0 and Month &lt; 3.&quot;</strong><br /><br />Just use years between 1 to 9999<br /><br />It is old &quot;war&quot; -&gt; Millennium Start = 2000 or 2001?<br /><a target="_blank" href="http://www.hermetic.ch/cal_stud/beattie.htm">http://www.hermetic.ch/cal_stud/beattie.htm</a><br /><br />If you want to use year 0 you can add <br />&quot;adc edx, 0&quot; after &quot;sbb edx,0&quot;, but it is just more code... <pre><code>  mov  ecx, eax                   ; ecx= monthdata&#91;m-1&#93;  + day + years + years/4 - years/100 + years/400<br />  mul  edx                        ; dividing eax by 7 -&gt;result in edx&#91;B&#93;<br />  lea  eax, &#91;edx+ecx&#93;           ; add n/7 to eax&#40;n&#41;<br />  shl  edx, 3                   ; edx= n/7 * 8&#91;/B&#93;<br /> ; mov  eax, ecx                   ; eax= monthdata&#91;m-1&#93; + day + years + years/4 - years/100 + years/400<br /> ; lea  ecx, &#91;edx+edx*2&#93;           ; multiplying edx by 7 -&gt;<br /> ; lea  edx, &#91;ecx+edx*4&#93;           ; -&gt;result in edx <br />  add  esp, 3*4                   ; clearing the stack from 3 dword parameters<br />  sub  eax, edx                   ; eax= &#40;monthdata&#91;m-1&#93; + day + years + years/4 - years/100 + years/400&#41; % 7<br />  ret                             ; faster return then return 3*4</code></pre><br /><br />Cute idea!!! I'll use it...Thanks again!<br /><br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-05-10 15:50:02 by lingo12</div>
   </div>
   <div class="post" id="post-120095">
    <div class="subject"><a href="#post-120095">DayOfWeek (PROC)</a></div>
    <div class="body">There is another formula for calculating day of a week. It follows:<br /><pre><code>w = k + &#91;2,6m - 0,2&#93; - 2C + Y + &#91; C / 4 &#93; + &#91;Y / 4&#93; &#40;mod 7&#41;</code></pre><br />k:day<br />m:month<br />Y=yy<u>yy</u><br />C=<u>yy</u>yy<br /><br /><pre><code>&#91;x&#93; means floor&#91;x&#93; i.e. biggest integer not bigger than x</code></pre></div>
    <div class="meta">Posted on 2003-09-30 09:24:33 by inFinie</div>
   </div>
   <div class="post" id="post-120329">
    <div class="subject"><a href="#post-120329">DayOfWeek (PROC)</a></div>
    <div class="body">Hi, <br /><br /><strong>lingo12</strong> (May 10th, 2003 09:50 PM) &gt; <em>Just use years between 1 to 9999</em><br /><strong>bitRAKE</strong> (March 22nd, 2002 03:25 AM) &gt; <em>year  = [0, 9999+]</em><br /><br />In 1582 Pope Gregory XIII introduced the Gregorian calendar to replace Julius Caesar's Julian calendar. <br />i.e.<br />...<br />October 16 1582<br />October 15 1582<br />October 4 1582<br />October 3 1582<br />...</div>
    <div class="meta">Posted on 2003-10-03 00:34:11 by P2M</div>
   </div>
   <div class="post" id="post-120557">
    <div class="subject"><a href="#post-120557">DayOfWeek (PROC)</a></div>
    <div class="body">FYI, the algorithm attributed to <strong>Tomohiko Sakamoto</strong> is originally due to <strong>Gauss</strong>.</div>
    <div class="meta">Posted on 2003-10-05 13:54:28 by Poimander</div>
   </div>
   <div class="post" id="post-122419">
    <div class="subject"><a href="#post-122419">DayOfWeek (PROC)</a></div>
    <div class="body"><div class="quote"><br />FYI, the algorithm attributed to <strong>Tomohiko Sakamoto</strong> is originally due to <strong>Gauss</strong>. <br /> </div><br />Poimander, could I ask you an offtopic, personal question:<br />I admire your comands of The English Language.<br />It's a rare thing nowdays, espacially for the American.<br />Could you tell us, please, what's your educational background?<br />You sound as a hell of a scolar :)</div>
    <div class="meta">Posted on 2003-10-25 06:18:42 by The Svin</div>
   </div>
   <div class="post" id="post-122747">
    <div class="subject"><a href="#post-122747">DayOfWeek (PROC)</a></div>
    <div class="body">Hi <strong>Svin</strong>, I'm definitely not a scholar. I'm just a student of asm.</div>
    <div class="meta">Posted on 2003-10-28 20:23:04 by Poimander</div>
   </div>
   <div class="post" id="post-122916">
    <div class="subject"><a href="#post-122916">DayOfWeek (PROC)</a></div>
    <div class="body">I've been just curious about where you were graduated :)</div>
    <div class="meta">Posted on 2003-10-30 08:31:55 by The Svin</div>
   </div>
   <div class="post" id="post-123209">
    <div class="subject"><a href="#post-123209">DayOfWeek (PROC)</a></div>
    <div class="body">Bla-bla-bla<br /><br /><pre><code><br />; Tested for D&#58;M&#58;Y=&#91;1&#58;3&#58;1900-28&#58;2&#58;2100&#93;<br /><br />dataseg<br />align 4<br />tbl dd 6,2,1,4,6,2,4,0,3,5,1,3<br /><br />codeseg<br />proc DayOfWeek day,month,year<br />	mov edx,&#91;month&#93;<br />	mov eax,&#91;year&#93;<br />	mov ecx,&#91;day&#93;<br />	cmp edx,3<br />	sbb eax,0<br />	add ecx,&#91;tbl+4*&#40;edx-1&#41;&#93;<br />	mov edx,24924925h<br />	imul eax,1461<br />	shr eax,2<br />	add eax,ecx<br />	mov ecx,eax<br />	imul edx<br />	lea eax,&#91;edx+ecx&#93;<br />	shl edx,3<br />	sub eax,edx<br />	ret<br />endp<br /></code></pre></div>
    <div class="meta">Posted on 2003-11-02 10:10:24 by Nexo</div>
   </div>
   <div class="post" id="post-166078">
    <div class="subject"><a href="#post-166078">Re: DayOfWeek (PROC)</a></div>
    <div class="body">If you&#39;re only interested in 20th and 21th century dates you can use the following <br />simplified routines:<br /><br /><pre><code><br />;-----------------------------------------------------------------------------<br />;<br />;  DayOfWeek: Simplified code routine for dates in the range: 1899&lt;year&lt;2100 <br />;<br />;  Modify the Gaussian calendrical algorithm using the fact that <br />;  floor(1/400*year)-floor(1/100*year) = -15 = -1 mod (7) for the 20th <br />;  and 21th centuries.<br />; <br />;-----------------------------------------------------------------------------<br /><br />Align 16<br />DayOfWeek PROC year:DWORD, month:DWORD,day:DWORD<br />.DATA<br />cData DB 0,3,2,5,0,3,5,1,4,6,2,4<br />.CODE<br />    mov eax, month  ; eax=month<br />    mov ecx, year     ; ecx=year<br />    cmp eax, 3<br />    sbb ecx, 0         ; year -= (month&lt;3)<br />    <br />    movzx eax, BYTE PTR cData<br />    <br />    add eax, ecx          ; eax = year + cData<br />    add eax, day          ; eax = year + day + cData<br />    shr ecx, 2              ; ecx = year/4<br />    add eax, ecx          ; eax = year/4 + year + day + cData<br />    dec eax                 ; eax = -1 + year/4 + year + day + cData<br />    <br />    mov ecx, 7<br />    xor edx, edx<br />    div ecx<br />    mov eax, edx            ; eax = (-1 + year/4 + year + day + cData)%7<br /><br />    ret<br />DayOfWeek ENDP<br /><br />;-----------------------------------------------------------------------------<br /><br />Align 16<br />DayOfWeek2 PROC USES ebx year:DWORD, month:DWORD,day:DWORD<br />    mov eax, month     ; eax=month<br />    mov ebx, year        ; ecx=year<br />    cmp eax, 3<br />    sbb ebx, 0             ; year -= (month&lt;3)<br /><br />    mov eax, 00000000011011010110110010101100b ;06D6CACh <br />    mov edx, 00000000110011110011000011000000b ;0CF30C0h<br />    mov ecx, month<br />    dec ecx<br />    shl ecx, 1<br />    shr eax, cl<br />    shr edx, cl<br />    and eax, 3<br />    and edx, 3<br />    add eax, edx      ; eax = (0CF30C0h&gt;&gt;(2*(month-1)))&amp;3+(06D6CACh&gt;&gt;(2*(month-1)))&amp;3<br />                            ;     = cData<br />                            <br />    add eax, ebx      ; eax = year + cData<br />    add eax, day      ; eax = year + day + cData<br />    shr ebx, 2          ; ebx = year/4<br />    add eax, ebx      ; eax = year/4 + year + day + cData<br />    dec eax             ; eax = -1 + year/4 + year + day + cData<br /><br />    mov ebx, 7<br />    xor edx, edx<br />    div ebx<br />    mov eax, edx      ; eax = (-1 + year/4 + year + day + cData)%7<br /><br />    ret<br />DayOfWeek2 ENDP<br /><br />;-----------------------------------------------------------------------------<br /></code></pre></div>
    <div class="meta">Posted on 2005-09-18 14:58:20 by Poimander</div>
   </div>
   <div class="post" id="post-166081">
    <div class="subject"><a href="#post-166081">Re: DayOfWeek (PROC)</a></div>
    <div class="body">There is the following routine as well:<br /><pre><code><br />;-----------------------------------------------------------------------------<br />;<br />; DayOfWeek: Simplified code routine for dates in the range: 1899&lt;year&lt;2100 <br />;<br />;            Modify the Gaussian calendrical algorithm using the fact that <br />;            floor(1/400*year)-floor(1/100*year) = -15 = -1 mod (7) for the 20th <br />;            and 21th centuries.<br />; <br />;-----------------------------------------------------------------------------<br /><br />Align 16      <br />DayOfWeek3 PROC year:DWORD, month:DWORD, day:DWORD<br />.DATA<br />cData DB 0,3,2,5,0,3,5,1,4,6,2,4<br />.CODE<br />    mov eax, month        ; eax=month<br />    mov ecx, year           ; ecx=year<br />    cmp eax, 3<br />    sbb ecx, 0                ; year -= (month&lt;3)<br />    <br />    movzx eax, BYTE PTR cData<br />    <br />&nbsp; &nbsp; lea ecx,  ; ecx = 5*year-4<br />&nbsp; &nbsp; shr ecx, 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; ecx = floor(5*year/4) - 1<br />&nbsp; &nbsp; add eax, ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; eax = floor(5*year/4) - 1 + cData<br />&nbsp; &nbsp; add eax, day&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; eax = day + floor(5*year/4) - 1 + cData<br /><br />    mov ecx, 7<br />    xor edx, edx<br />    div ecx<br />    mov eax, edx             ; eax = (day + floor(5*year/4) - 1 + cData)%7<br /><br />    ret<br />DayOfWeek3 ENDP<br /></code></pre><br /></div>
    <div class="meta">Posted on 2005-09-18 18:09:47 by Poimander</div>
   </div>
   <div class="post" id="post-166112">
    <div class="subject"><a href="#post-166112">Re: DayOfWeek (PROC)</a></div>
    <div class="body">In the interest of thoroughness there is one additional routine I should mention:<br /><pre><code><br />;-----------------------------------------------------------------------------<br />;<br />; DayOfWeek: Simplified code routine for dates in the range: 1899&lt;year&lt;2100 <br />;<br />; Modify the Gaussian calendrical algorithm using the fact that <br />; floor(1/400*year)-floor(1/100*year) = -15 = -1 mod (7) for the 20th <br />; and 21th centuries.<br />;-----------------------------------------------------------------------------<br /><br />Align 16      <br />DayOfWeek4 PROC year:DWORD, month:DWORD, day:DWORD<br />;.DATA<br />;cData DB 0,3,2,5,0,3,5,1,4,6,2,4<br />.CODE<br />    mov eax, month         ; eax = month<br />    mov ecx, year          ; ecx = year<br />    cmp eax, 3<br />    sbb ecx, 0             ; year -= (month&lt;3)<br /><br />    movzx eax, BYTE PTR cData<br /><br />    lea ecx,    ; ecx = 5*year<br />    and ecx, not 3         ; ecx = 5*year - (5*year mod(4)) = 4*floor(5*year/4)<br />    lea eax,  ; eax = -1 + 8*floor(5*year/4) + cData  <br />    add eax, day           ; eax = -1 + 8*floor(5*year/4) + cData + day<br />    <br />    mov ecx, 7<br />    xor edx, edx<br />    div ecx<br />    mov eax, edx           ; eax = (-1 + floor(5*year/4) + cData + day)%7<br /><br />    ret<br />DayOfWeek4 ENDP<br /></code></pre></div>
    <div class="meta">Posted on 2005-09-19 21:37:36 by Poimander</div>
   </div>
   <div class="post" id="post-166126">
    <div class="subject"><a href="#post-166126">Re: DayOfWeek (PROC)</a></div>
    <div class="body">I&#39;m using Opera br. and can not scroll vertically all that is typed between &quot;code&quot; statements in this version on forum - no verticall scroll bar in the &quot;code&quot; window.</div>
    <div class="meta">Posted on 2005-09-20 17:11:35 by The Svin</div>
   </div>
   <div class="post" id="post-166129">
    <div class="subject"><a href="#post-166129">Re: DayOfWeek (PROC)</a></div>
    <div class="body">The Svin,<br /><br />FYI, I am using Opera 8.02 and I <strong>do</strong> get a vertical scroll bar in the &quot;code&quot; area. By the way, the latest version of Opera is now free, no ads.<br /><br />    <a target="_blank" href="http://opera.com/free/">Opera</a><br /><br /> <br /></div>
    <div class="meta">Posted on 2005-09-20 18:37:27 by Greg</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=4358&amp;page=1" style="">&laquo;</a><a href="../?id=4358&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="4358" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>