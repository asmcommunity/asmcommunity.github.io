<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>InString fix - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=6368" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=6368">InString fix</a></p>
   <div class="post" id="post-45798">
    <div class="subject"><a href="#post-45798">InString fix</a></div>
    <div class="body">Seems something failed in the testing of the last version. Here is a version that I have modified that uses a design by EKO where the comparison loop is run backwards. The advantage of his design is the lower branch overhead when a first character match is found.<br /><br />It has a 4 insruction long main loop which is where the speed is, a 2 instruction pre match count thanks to EKO and a 5 instruction long match loop so generally the loop code is efficient enough.<br /><br />The prologue code can be made smaller using a design by Alex (The Svin) but I have not had time to do it. The real speed is in the loop code so its not a performance problem.<br /><br />This version re-reads the 1st character in the matching loop so that it works properly on a single character. For patterns longer than 1 character, you can start on the next character but it is common when working with ascii text to search for 1 character so the extra iteration is necessary.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a><br /><br /><pre><code><br />; #########################################################################<br /><br />InString proc startpos&#58;DWORD,lpSource&#58;DWORD,lpPattern&#58;DWORD<br /><br />  ; ------------------------------------------------------------------<br />  ; InString searches for a substring in a larger string and if it is<br />  ; found, it returns its position in eax. <br />  ;<br />  ; It uses a one &#40;1&#41; based character index &#40;1st character is 1,<br />  ; 2nd is 2 etc...&#41; for both the &quot;StartPos&quot; parameter and the returned<br />  ; character position.<br />  ;<br />  ; Return Values.<br />  ; If the function succeeds, it returns the 1 based index of the start<br />  ; of the substring.<br />  ;  0 = no match found<br />  ; -1 = substring same length or longer than main string<br />  ; -2 = &quot;StartPos&quot; parameter out of range &#40;less than 1 or longer than<br />  ; main string&#41;<br />  ; ------------------------------------------------------------------<br /><br />    LOCAL sLen&#58;DWORD<br />    LOCAL pLen&#58;DWORD<br /><br />    push ebx<br />    push esi<br />    push edi<br /><br />    invoke StrLen,lpSource<br />    mov sLen, eax           ; source length<br />    invoke StrLen,lpPattern<br />    mov pLen, eax           ; pattern length<br /><br />    cmp startpos, 1<br />    jge @F<br />    mov eax, -2<br />    jmp isOut               ; exit if startpos not 1 or greater<br />  @@&#58;<br /><br />    dec startpos            ; correct from 1 to 0 based index<br /><br />    cmp  eax, sLen<br />    jl @F<br />    mov eax, -1<br />    jmp isOut               ; exit if pattern longer than source<br />  @@&#58;<br /><br />    sub sLen, eax           ; don't read past string end<br />    inc sLen<br /><br />    mov ecx, sLen<br />    cmp ecx, startpos<br />    jg @F<br />    mov eax, -2<br />    jmp isOut               ; exit if startpos is past end<br />  @@&#58;<br /><br />  ; ----------------<br />  ; setup loop code<br />  ; ----------------<br />    mov esi, lpSource<br />    mov edi, lpPattern<br />    mov al, &#91;edi&#93;           ; get 1st char in pattern<br /><br />    add esi, ecx            ; add source length<br />    neg ecx                 ; invert sign<br />    add ecx, startpos       ; add starting offset<br /><br />    jmp Scan_Loop<br /><br />    align 16<br /><br />  ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br /><br />  Pre_Scan&#58;<br />    inc ecx                 ; start on next byte<br /><br />  Scan_Loop&#58;<br />    cmp al, &#91;esi+ecx&#93;       ; scan for 1st byte of pattern<br />    je Pre_Match            ; test if it matches<br />    inc ecx<br />    jnz Scan_Loop<br /><br />    jmp No_Match<br /><br />  Pre_Match&#58;<br />    lea ebx, &#91;esi+ecx&#93;      ; put current scan address in EBX<br />    mov edx, pLen           ; put pattern length into EDX<br /><br />  Test_Match&#58;<br />    mov ah, &#91;ebx+edx-1&#93;     ; load last byte of pattern length in main string<br />    cmp ah, &#91;edi+edx-1&#93;     ; compare it with last byte in pattern<br />    jne Pre_Scan            ; jump back on mismatch<br />    dec edx<br />    jnz Test_Match          ; 0 = match, fall through on match<br /><br />  ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br /><br />  Match&#58;<br />    add ecx, sLen<br />    mov eax, ecx<br />    inc eax<br />    jmp isOut<br />    <br />  No_Match&#58;<br />    xor eax, eax<br /><br />  isOut&#58;<br />    pop edi<br />    pop esi<br />    pop ebx<br /><br />    ret<br /><br />InString endp<br /><br />; ########################################################################<br /></code></pre></div>
    <div class="meta">Posted on 2002-06-30 03:09:25 by hutch--</div>
   </div>
   <div class="post" id="post-50263">
    <div class="subject"><a href="#post-50263">Error in Assembling.</a></div>
    <div class="body">Hutch,<br /><br />I cut and pasted, but I get an error in assembling. <br /><br />.386<br />.model flat, stdcall  ; 32 bit memory model<br />option casemap :none  ; case sensitive<br /><br />align 16<br />c:\masm32\m32lib\instring.asm(81) : error A2189: invalid combination with segment alignment : 16<br /><br />Is there a reason for this, that I am missing?<br /><br />Enjoy your work,  P1<br /><br />PS:  InString is intermittantly throwing GPF's.  I was hoping this revised one would help.</div>
    <div class="meta">Posted on 2002-07-26 12:17:15 by Pone</div>
   </div>
   <div class="post" id="post-50392">
    <div class="subject"><a href="#post-50392">InString fix</a></div>
    <div class="body">Pone,<br /><br />Change the processor model to 486 or higher to use align 16.<br /><br />I have done extensive testing on this algo as I had to debug an unusual condition with the last one buit you must make sure that the memory locations of both the source and the destination are valid and the length must not exceed the actual length of the source.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-07-27 07:19:32 by hutch--</div>
   </div>
   <div class="post" id="post-50422">
    <div class="subject"><a href="#post-50422">mistake ?</a></div>
    <div class="body">hutch i think  you have mistake in the code <br /><br /><br /><pre><code><br /><br />  Pre_Scan&#58;<br />    inc ecx                 ; start on next byte<br /><br />  Scan_Loop&#58;<br />    cmp al, &#91;esi+ecx&#93;     <br />    je Pre_Match          <br />    inc ecx<br />    jnz Scan_Loop<br /><br />    jmp No_Match<br /><br />  Pre_Match&#58;<br />    lea ebx, &#91;esi+ecx&#93;      <br />    mov edx, pLen           <br />  Test_Match&#58;<br />    mov ah, &#91;ebx+edx-1&#93;         cmp ah, &#91;edi+edx-1&#93;   <br />    jne Pre_Scan            ;------&gt; here . you jmp to pre scan and in Pre_Scan you inc ecx and dont check for zero<br /></code></pre><br /><br />bye<br /><br />eko</div>
    <div class="meta">Posted on 2002-07-27 10:30:18 by eko</div>
   </div>
   <div class="post" id="post-50423">
    <div class="subject"><a href="#post-50423">InString fix</a></div>
    <div class="body">hiiiiiiiiiiiiiiiiii<br /><br />i had few more ideas to instring . <br />and here it now <br />3 version of in string .<br />1.  case sensitive  - i improved it alittle more than the last time <br />2.  case insensitive <br />3.  whole word <br />4. whole word 2nd version . using faster way to check if its a char<br />bye<br /><br />eko<br /><br />p.s <br />if you need more speed . and you know the length of your string and pattern,loss the strlen function and set two more parameters to the function <br />stringlen,patternln<br /><br />EDIT : update 4 files .. look up</div>
    <div class="meta">Posted on 2002-07-27 10:32:27 by eko</div>
   </div>
   <div class="post" id="post-50510">
    <div class="subject"><a href="#post-50510">InString fix</a></div>
    <div class="body">The code that tests for zero is well before the main scan loop.<br /><pre><code><br />    invoke StrLen,lpSource<br />    mov sLen, eax           ; source length<br />    invoke StrLen,lpPattern<br />    mov pLen, eax           ; pattern length<br /></code></pre><br /><br />It exits the scan loop when the counter = zero<br /><br /><pre><code><br />Scan_Loop&#58;<br />    cmp al, &#91;esi+ecx&#93;       ; scan for 1st byte of pattern<br />    je Pre_Match            ; test if it matches<br />    inc ecx<br />    jnz Scan_Loop    ; &lt;&lt;&lt;&lt; exit point here<br /><br />    jmp No_Match<br /></code></pre><br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-07-28 03:27:58 by hutch--</div>
   </div>
   <div class="post" id="post-50521">
    <div class="subject"><a href="#post-50521">InString fix</a></div>
    <div class="body">i think you didnt understand me .....<br /><br /><pre><code><br />  Pre_Scan&#58;<br />    inc ecx                 ; start on next byte<br /><br />  Scan_Loop&#58;<br />    cmp al, &#91;esi+ecx&#93;     <br />    je Pre_Match          <br />    inc ecx<br />    jnz Scan_Loop<br /><br />    jmp No_Match<br /><br />  Pre_Match&#58;<br />    lea ebx, &#91;esi+ecx&#93;      <br />    mov edx, pLen           <br />  Test_Match&#58;<br />    mov ah, &#91;ebx+edx-1&#93;         cmp ah, &#91;edi+edx-1&#93;   <br />    jne Pre_Scan            ;------&gt; here you jmp to inc ecx .but what if ecx +esi was the last byte . so you inc ecx and you will get overflow<br /></code></pre><br />if you do it like that you should jmp to <br /><pre><code><br />   cmp al, &#91;esi+ecx&#93;     <br />    je Pre_Match          <br />Pre_Scan&#58;<br />    inc ecx<br />    jnz Scan_Loop<br /><br />    jmp No_Match<br /></code></pre> <br /> but have a look in my new instring version.</div>
    <div class="meta">Posted on 2002-07-28 05:48:10 by eko</div>
   </div>
   <div class="post" id="post-50589">
    <div class="subject"><a href="#post-50589">InString fix</a></div>
    <div class="body">The .386 was what left in the original instring.asm, when I cut and pasted the updated proc code.<br /><br />Enjoy your work,  P1</div>
    <div class="meta">Posted on 2002-07-28 16:20:49 by Pone</div>
   </div>
   <div class="post" id="post-52229">
    <div class="subject"><a href="#post-52229">InString fix</a></div>
    <div class="body">hi hutch,<br /><br />you really need to fix instring as both versions (masm32 and fix) are faulty, look at what eko meant:<br /><br />   Pre_Loop:<br />    pop ecx                 ; restore ECX &lt;- if ecx was 8 and ebx was 9 (it was last byte to search)<br />    inc ecx                 ; start on next byte &lt;- then ecx = 9<br /><br />  Loop_Start:<br />    cmp al,        ;not maching       <br />    je Pre_Sub<br />    inc ecx                 ;here ecx=0A<br />    cmp ecx, ebx            ; now ecx &gt; ebx and the loop never ends until the <br />			    ;overflow in ecx OR the routine finds matching byte in the memory<br />                            ;beyond string range, and even gives a wrong hit on substring itself<br />                            ;trace with a debbuger to see it <br />    jne Loop_Start<br /><br />in the attached program the routine gives a wrong hit, worse when I stuffed it into a dll it gave access violations because of ecx overflow<br /><br />P.S. sorry, I pulled the wrong proc out from the dll. still your updated one gives me the same wrong hit, just don't have a time to trace into it with a debbuger right now.</div>
    <div class="meta">Posted on 2002-08-08 13:15:43 by ramzez</div>
   </div>
   <div class="post" id="post-52260">
    <div class="subject"><a href="#post-52260">Pointer over-run.</a></div>
    <div class="body">ramzez,<br /><br />I've known about this, since Hutch posted this.<br />But I have been too busy to offer any help on it.<br /><br />I pulled it into VS, to look it and noticed that the pointer over-run the end of the string until hitting the process memory limit and then GPF.<br /><br />Enjoy your work,  P1</div>
    <div class="meta">Posted on 2002-08-08 20:43:47 by Pone</div>
   </div>
   <div class="post" id="post-52281">
    <div class="subject"><a href="#post-52281">InString fix</a></div>
    <div class="body">Sorry to be a bit slow but I have had a lot to do recently.<br /><br />The problem with the algo was not the additional inc ecx but the exit condition. JNZ allowed a mismatch to run past the end of the buffer in some instances as it only tests zero, not zero or more. I modified the algo by using a test for sign so that the counter coming up to zero or higher would exit properly.<br /><br />This is how I tested the results.<br /><pre><code><br />            .data<br />              buffer3 db &quot;This is a test&quot;,0,&quot;with trailing string data&quot;,0<br />              buffer4 db &quot;t&quot;,0<br />              buffer5 db &quot;string&quot;,0<br />            .code<br /><br />            invoke InStringx,1,ADDR buffer3, ADDR buffer4<br />            ShowReturn hWnd, eax<br /><br />            invoke InStringx,1,ADDR buffer3, ADDR buffer5<br />            ShowReturn hWnd, eax<br /></code></pre><br />I have tested various combinations of matches, mismatches and tested for a match past the end of the first terminating zero and the results I am getting will only match before the first terminating zero and will mismatch any other combination.<br /><br />The reason why I have persisted with this format is to keep the main scan loop down to 4 instructions as it is the most critical in a scanner for speed. The branch compare to test the full string match does not particularly effect the main algorithm speed. The branch compare loop uses an early out on mismatch to keep the branch time down and EKO's design of scanning the match backwards to reduce the number of instructions needed to set it up.<br /><br />This is the code below, it has on;ly 1 instruction different, it changes a JNZ to a JS.<br /><pre><code><br />; #########################################################################<br /><br />InStringx proc startpos&#58;DWORD,lpSource&#58;DWORD,lpPattern&#58;DWORD<br /><br />  ; ------------------------------------------------------------------<br />  ; InString searches for a substring in a larger string and if it is<br />  ; found, it returns its position in eax. <br />  ;<br />  ; It uses a one &#40;1&#41; based character index &#40;1st character is 1,<br />  ; 2nd is 2 etc...&#41; for both the &quot;StartPos&quot; parameter and the returned<br />  ; character position.<br />  ;<br />  ; Return Values.<br />  ; If the function succeeds, it returns the 1 based index of the start<br />  ; of the substring.<br />  ;  0 = no match found<br />  ; -1 = substring same length or longer than main string<br />  ; -2 = &quot;StartPos&quot; parameter out of range &#40;less than 1 or longer than<br />  ; main string&#41;<br />  ; ------------------------------------------------------------------<br /><br />    LOCAL sLen&#58;DWORD<br />    LOCAL pLen&#58;DWORD<br /><br />    push ebx<br />    push esi<br />    push edi<br /><br />    invoke StrLen,lpSource<br />    mov sLen, eax           ; source length<br />    invoke StrLen,lpPattern<br />    mov pLen, eax           ; pattern length<br /><br />    cmp startpos, 1<br />    jge @F<br />    mov eax, -2<br />    jmp isOut               ; exit if startpos not 1 or greater<br />  @@&#58;<br /><br />    dec startpos            ; correct from 1 to 0 based index<br /><br />    cmp  eax, sLen<br />    jl @F<br />    mov eax, -1<br />    jmp isOut               ; exit if pattern longer than source<br />  @@&#58;<br /><br />    sub sLen, eax           ; don't read past string end<br />    inc sLen<br /><br />    mov ecx, sLen<br />    cmp ecx, startpos<br />    jg @F<br />    mov eax, -2<br />    jmp isOut               ; exit if startpos is past end<br />  @@&#58;<br /><br />  ; ----------------<br />  ; setup loop code<br />  ; ----------------<br />    mov esi, lpSource<br />    mov edi, lpPattern<br />    mov al, &#91;edi&#93;           ; get 1st char in pattern<br /><br />    add esi, ecx            ; add source length<br />    neg ecx                 ; invert sign<br />    add ecx, startpos       ; add starting offset<br /><br />    jmp Scan_Loop<br /><br />    align 16<br /><br />  ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br /><br />  Pre_Scan&#58;<br />    inc ecx                 ; start on next byte<br /><br />  Scan_Loop&#58;<br />    cmp al, &#91;esi+ecx&#93;       ; scan for 1st byte of pattern<br />    je Pre_Match            ; test if it matches<br />    inc ecx<br />    js Scan_Loop            ; exit on sign inversion<br /><br /> ;     cmp ecx, 0           ; works but 1 instruction longer<br /> ;     jl Scan_Loop<br /><br />    jmp No_Match<br /><br />  Pre_Match&#58;<br />    lea ebx, &#91;esi+ecx&#93;      ; put current scan address in EBX<br />    mov edx, pLen           ; put pattern length into EDX<br /><br />  Test_Match&#58;<br />    mov ah, &#91;ebx+edx-1&#93;     ; load last byte of pattern length in main string<br />    cmp ah, &#91;edi+edx-1&#93;     ; compare it with last byte in pattern<br />    jne Pre_Scan            ; jump back on mismatch<br />    dec edx<br />    jnz Test_Match          ; 0 = match, fall through on match<br /><br />  ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br /><br />  Match&#58;<br />    add ecx, sLen<br />    mov eax, ecx<br />    inc eax<br />    jmp isOut<br />    <br />  No_Match&#58;<br />    xor eax, eax<br /><br />  isOut&#58;<br />    pop edi<br />    pop esi<br />    pop ebx<br /><br />    ret<br /><br />InStringx endp<br /><br />; ########################################################################<br /></code></pre><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-08-08 23:30:26 by hutch--</div>
   </div>
   <div class="post" id="post-52341">
    <div class="subject"><a href="#post-52341">Ready for Prime Time.</a></div>
    <div class="body">Well, this fixed several of my apps, that had intermittant GPFs.<br /><br />Enjoy your work,  P1   :alright:<br /><br />PS:  I do MASM32 work as time permits.</div>
    <div class="meta">Posted on 2002-08-09 09:30:58 by Pone</div>
   </div>
   <div class="post" id="post-53481">
    <div class="subject"><a href="#post-53481">fine now</a></div>
    <div class="body">I tested it in the dll with an application that does navigation within an exported outlook folder text file or the like. THe app searches for the line &quot;subject&quot; and displays results in a listbox. I tested with ~2 mb files, there's of course multiple hits and everything seems to be fine, no wrong hits anymore.</div>
    <div class="meta">Posted on 2002-08-15 11:00:07 by ramzez</div>
   </div>
   <div class="post" id="post-53543">
    <div class="subject"><a href="#post-53543">InString fix</a></div>
    <div class="body">Guys,<br /><br />Thanks for verifying the procedure, the problem is always testing a procedure across a wide enough set of conditions to get it right.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-08-15 21:47:41 by hutch--</div>
   </div>
  </div>
 </body>
</html>