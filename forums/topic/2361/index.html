<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Recursive QuickSort (revised): - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=2361" />
    <link rel="next" href="../?id=2361&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=2361">Recursive QuickSort (revised):</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=2361&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=2361&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="2361" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=2361&amp;page=2">&gt;</a><a href="../?id=2361&amp;page=2">&raquo;</a></form>   <div class="post" id="post-15029">
    <div class="subject"><a href="#post-15029">Recursive QuickSort (revised):</a></div>
    <div class="body"><pre><code>COMPARE macro item1,item2<br />	mov edx,&#91;ebx + item1*4&#93;<br />	cmp edx,&#91;ebx + item2*4&#93;<br />ENDM<br /><br /><br />EXCHANGE macro item1,item2<br />	mov edx,&#91;ebx + item1*4&#93; ; edx is the only free reg<br />	push DWORD PTR &#91;ebx + item2*4&#93;<br />	mov &#91;ebx + item2*4&#93;,edx<br />	pop DWORD PTR &#91;ebx + item1*4&#93;<br />ENDM<br /><br /><br /><br />QuickSort PROC uses esi edi ebx, qARRAY&#58;DWORD, qLOW&#58;DWORD, qHIGH&#58;DWORD<br />	mov ebx, qARRAY<br />	mov esi, qLOW<br />	mov edi, qHIGH<br />	call PARTITION<br />	ret ; let MASM do it's &quot;magic&quot; on this ret<br /><br />; Partition the array defined by index range &#91;esi,edi&#93; into<br />; two ranges&#58; one with items lessthanequal item &#40;ecx&#41; and<br />; one with items greaterthanequal item &#40;ecx&#41;.  Recursively process<br />; sub-partitions.  If there are zero/one items greater then it is<br />; possible to skip the upper partition.  Don't move items<br />; equal to pivot item.<br />;<br />; OnEntry&#58;<br />;     ebx = Array pointer &#40;doesn't change&#41;<br />;     esi = Lower index &#91;0,edi-1&#93;<br />;     edi = Upper index &#91;1,+&#93;<br />PARTITION&#58;<br />	mov eax,edi<br />	push esi<br />	push edi<br />	sub eax,esi ; width of partition - 1<br />	jle @exit ; must be &gt;1 elements to sort<br /><br />	; bad choice for sorted data<br />	mov ecx,esi ; choose pivot<br />;;;;	inc esi ; avoid moving pivot<br /><br />	inc edi ; counter first dec<br /><br />@low&#58;	inc esi<br />	dec eax<br />	js @done<br />	COMPARE ecx,esi ; index1, index2<br />	jge @low<br />	; esi item needs to be moved into high partition<br />@high&#58;	dec edi<br />	dec eax<br />	js @done<br />	COMPARE ecx,edi ; index1, index2<br />	jle @high<br />	EXCHANGE esi,edi<br />	jmp @low<br />; esi=edi ; &#40;esi&#41; item part of high partition<br />@done&#58;	dec esi<br />	EXCHANGE ecx,esi<br />	cmp edi,&#91;esp&#93;<br />	jge @half<br />	dec esi ; pivot is sorted<br />	mov eax,&#91;esp&#93;<br />	mov &#91;esp&#93;,esi<br />	xchg edi,eax<br />	xchg esi,eax<br />	call PARTITION<br />	pop edi<br />	pop esi<br />	jmp PARTITION<br />;fix highhalf size of one skip<br />@half&#58;	pop edi ; pivot was greatest item<br />	pop esi<br />	dec edi ; reduce partition size by one<br />	jmp PARTITION<br />@exit&#58;	add esp,8<br />	db 0C3h ; ret ; force _REAL_ ret in MASM<br /><br />QuickSort ENDP</code></pre>This should be pretty fast - I haven't had time to time it.  :)  I want to make a few changes, but I'm thinking it over some more.  <strong>Hutch</strong>, shouldn't have any problem digesting this one.  Warning: there is much going on here, so be careful making changes.</div>
    <div class="meta">Posted on 2001-12-15 05:45:56 by bitRAKE</div>
   </div>
   <div class="post" id="post-15245">
    <div class="subject"><a href="#post-15245">Recursive QuickSort (revised):</a></div>
    <div class="body">Okay, revised again.  :)  This version shows how to sort strings using this algo.  I've added some comments, but they wouldn't be of much help unless you know what quick sort is - mainly they state why I choose the pivot item I have, and how to change it.  The registers have been changed to favor windows code within the COMPARE/EXCHANGE macros (ie only ECX needs to be saved - windows saves the rest).<pre><code>;COMPARE macro item1,item2<br />;	mov edx,&#91;ebx + item1*4&#93;<br />;	cmp edx,&#91;ebx + item2*4&#93;<br />;ENDM<br /><br />COMPARE macro item1,item2<br />	push ecx<br />	invoke lstrcmp,DWORD PTR &#91;ebx + item1*4&#93;,DWORD PTR &#91;ebx + item2*4&#93;<br />	cmp eax,0<br />	pop ecx<br />ENDM<br /><br /><br />EXCHANGE macro item1,item2<br />	mov edx,&#91;ebx + item1*4&#93;<br />	mov eax,&#91;ebx + item2*4&#93;<br />	mov &#91;ebx + item2*4&#93;,edx<br />	mov &#91;ebx + item1*4&#93;,eax<br />ENDM<br /><br /><br /><br />QuickSort PROC uses esi edi ebx, qARRAY&#58;DWORD, qLOW&#58;DWORD, qHIGH&#58;DWORD<br />	push ebp ; an extra register, oh boy!<br />	mov ebx, qARRAY<br />	mov esi, qLOW<br />	mov edi, qHIGH<br />	call PARTITION<br />	pop ebp<br />	ret ; let MASM do it's &quot;magic&quot; on this ret<br /><br />; Partition the array defined by index range &#91;esi,edi&#93; into<br />; two ranges&#58; one with items lessthanequal item &#40;ecx&#41; and<br />; one with items greaterthanequal item &#40;ecx&#41;.  Recursively process<br />; sub-partitions.  If there are zero/one items greater then it is<br />; possible to skip the upper partition.  Don't move items<br />; equal to pivot item.<br />;<br />; OnEntry&#58;<br />;     ebx = Array pointer &#40;doesn't change&#41;<br />;     esi = Lower index &#91;0,edi-1&#93;<br />;     edi = Upper index &#91;1,+&#93;<br />; During Main Section of Code&#58;<br />;     ebx = &#40;see above&#41;<br />;     esi = top index of lower partition<br />;     ebp = bottom index of upper partition<br />;     edi = &#40;ebp-esi&#41; gap between partition, approaches zero<br />;     ecx = pivot index<br />; eax/edx = &#40;disposable&#41;<br />PARTITION&#58;<br />		push esi<br />		push edi<br />		mov ebp,edi<br />		sub edi,esi		; width of partition - 2<br />		jle @exit		; must be &gt;1 elements to sort<br /><br />		; bad choice for sorted data<br />		mov ecx,esi		; choose pivot<br />		; better choice?<br />;		lea ecx,&#91;esi+ebp&#93;<br />;		shr ecx,1<br />;Note&#58; You can choose any pivot you want - algorithm doesn't move<br />;  items that equal the pivot - including the pivot, which is<br />;  required!  A general solution would choose the mid-point item<br />;  for the case of partially sorted data.  I have chosen the first<br />;  item to reduce the size of the partition at the start.  Uncomment<br />;  the following line if you choose another pivot method - it is not<br />;  needed because pivot item lies between partitions by definition.<br />;		dec esi			; counter first inc<br />		inc ebp			; counter first dec<br /><br />@low&#58;		inc esi<br />		dec edi<br />		js @donel ; esi is out of range or part of upper partition<br />		COMPARE ecx,esi ; array, index1, index2<br />		jge @low<br /><br />; esi item needs to be moved into high partition<br />@high&#58;		dec ebp<br />		dec edi<br />		js @doneh ; ebp is out of range or part of lower partition<br />		COMPARE ecx,ebp ; array, index1, index2<br />		jle @high<br /><br />		EXCHANGE esi,ebp<br />		jmp @low<br /><br /><br />; esi=ebp ; &#40;esi&#41; item part of upper partition<br />@doneh&#58;		inc ebp<br />@donel&#58;		dec esi<br />		EXCHANGE ecx,esi<br />		dec esi ; pivot is sorted<br />		mov edi,&#91;esp&#93;<br />		mov &#91;esp&#93;,esi<br />		mov esi,ebp<br />		call PARTITION<br />		pop edi<br />		pop esi<br />		jmp	PARTITION<br /><br />@exit&#58;		add esp,8<br />		retn ;db 0C3h; force _REAL_ ret in MASM PROC<br />QuickSort ENDP<br /><br />;Initial State&#58; &#40;general&#41;<br />;<br />;   esi      ecx      edi<br />;    |---n---|-|---n---|<br />;             P<br />;<br />;My choice of Pivot&#58;<br />;<br />;      esi             edi<br />;    |-|-------n-------|<br />;     P<br />;<br />;<br />;Possible Results&#58; &#40;P = pivot index&#41;<br />;<br />;      esi             edi<br />;    |-|-------n-------|     all items are &gt;= pivot<br />;     P                      inc esi, partition new range<br />;<br />;        esi           edi<br />;    |-|-|-----n-------|     one item =&lt; pivot, rest &gt;= pivot<br />;       P                    inc esi, inc esi, partition new range<br />;<br />;  esi--n--edi esi--n--edi<br />;    |---n---|-|---n---|     some items =&lt; pivot, some items &gt;= pivot<br />;             P              partition range #1, partition range #1<br />;<br />;  esi           edi<br />;    |------n------|-|-|     one item &gt;= pivot, rest &lt;= pivot<br />;                   P        dec edi, partition new range<br />;<br />;  esi             edi<br />;    |------n--------|-|     all items are &lt;= pivot<br />;                     P      dec edi, dec edi, partition new range<br />;</code></pre></div>
    <div class="meta">Posted on 2001-12-17 23:09:33 by bitRAKE</div>
   </div>
   <div class="post" id="post-15246">
    <div class="subject"><a href="#post-15246">Recursive QuickSort (revised):</a></div>
    <div class="body">Write a nonrecursive version bitrake, and do comparative timings.<br />I'm too lazy to do that sorta stuff myself, but I'd like to know how<br />much faster you can get a nonrecursive version :).</div>
    <div class="meta">Posted on 2001-12-17 23:17:48 by f0dder</div>
   </div>
   <div class="post" id="post-15248">
    <div class="subject"><a href="#post-15248">Recursive QuickSort (revised):</a></div>
    <div class="body"><strong>Hutch--</strong>, has a non-recursive version in MASM32 7.0.  I like recursion - it makes for small code, and I think the above is faster than <strong>Hutch--</strong>'s.   Realistically, testing them is real work - I'm sure they have different performance characteristics - like the string searches do.  <strong>Hutch--</strong>'s is made just to sort DWORDs, mine is made to sort anything you can write the two macros for - you don't even need an array of pointers if you don't want - you could index the structures directly.  It's general, and still pretty fast.  I'm happy with it.  :)<br /><br /><strong>Edit</strong>: Okay, I'll try a non-recursive version, maybe.  ;)   There isn't much to some of those theories at the machine level.  I'd be better to optimise the sorting of the small partitions.<br /><br /><strong>Edit</strong>: {clip}  :tongue:  Need to think before hitting the keys.</div>
    <div class="meta">Posted on 2001-12-17 23:39:23 by bitRAKE</div>
   </div>
   <div class="post" id="post-41224">
    <div class="subject"><a href="#post-41224">Recursive QuickSort (revised):</a></div>
    <div class="body">Hi bitRAKE,<br /><br />i have studied a bit the algo and found out that the strcmp function isn't case sensitive and btw a bit slow, i suggest to use a self made compare function. This is how it looks like then:<pre><code>QuickSort proto &#58;DWORD,&#58;DWORD,&#58;DWORD<br />EisoCmp proto &#58;DWORD,&#58;DWORD<br /><br />QuickSort PROC uses esi edi ebx, qARRAY&#58;DWORD, qLOW&#58;DWORD, qHIGH&#58;DWORD<br />	push ebp ; an extra register, oh boy!<br />	mov ebx, qARRAY<br />	mov esi, qLOW<br />	mov edi, qHIGH<br />	call PARTITION<br />	pop ebp<br />	ret ; let MASM do it's &quot;magic&quot; on this ret<br /><br />PARTITION&#58;<br />		push esi<br />		push edi<br />		mov ebp,edi<br />		sub edi,esi		; width of partition - 2<br />		jle @exit		; must be &gt;1 elements to sort<br />		mov ecx,esi		; choose pivot<br />		inc ebp			; counter first dec<br />@low&#58;		inc esi<br />		dec edi<br />		js @donel ; esi is out of range or part of upper partition<br />		<br />		invoke EisoCmp,DWORD PTR &#91;ebx + ecx*4&#93;,DWORD PTR &#91;ebx + esi*4&#93;<br />		cmp eax,0<br />		<br />		jge @low<br />@high&#58;		dec ebp<br />		dec edi<br />		js @doneh ; ebp is out of range or part of lower partition<br />		<br />		invoke EisoCmp,DWORD PTR &#91;ebx + ecx*4&#93;,DWORD PTR &#91;ebx + ebp*4&#93;<br />		cmp eax,0<br />		<br />		jle @high<br />		mov edx,&#91;ebx + esi*4&#93;<br />		mov eax,&#91;ebx + ebp*4&#93;<br />		mov &#91;ebx + ebp*4&#93;,edx<br />		mov &#91;ebx + esi*4&#93;,eax<br />		jmp @low<br />@doneh&#58;		inc ebp<br />@donel&#58;		dec esi<br />		mov edx,&#91;ebx + ecx*4&#93;<br />		mov eax,&#91;ebx + esi*4&#93;<br />		mov &#91;ebx + esi*4&#93;,edx<br />		mov &#91;ebx + ecx*4&#93;,eax<br />		<br />		<br />		dec esi ; pivot is sorted<br />		mov edi,&#91;esp&#93;<br />		mov &#91;esp&#93;,esi<br />		mov esi,ebp<br />		call PARTITION<br />		pop edi<br />		pop esi<br />		jmp	PARTITION<br /><br />@exit&#58;		add esp,8<br />		db 0C3h ; ret ; force _REAL_ ret in MASM<br /><br />QuickSort ENDP<br /><br /><br />EisoCmp PROC a&#58;DWORD,b&#58;DWORD<br />	push esi<br />	push edi<br />	xor eax,eax<br />	mov esi,a<br />	mov edi,b<br />next&#58;	mov al,&#91;esi&#93;<br />	mov ah,&#91;edi&#93;<br />	cmp ax,0<br />	jz same<br />	cmp al,ah<br />	jb lower<br />	ja higher<br />	inc esi<br />	inc edi<br />	jmp next<br />same&#58;	xor eax,eax<br />	pop edi<br />	pop esi<br />	ret<br />lower&#58;	or eax,-1<br />	pop edi<br />	pop esi<br />	ret<br />higher&#58;	mov eax,1<br />	pop edi<br />	pop esi<br />	ret<br />EisoCmp ENDP</code></pre>It's performing faster and better now(smaller compare plus no push and po for ecx reg.), but still there is a bug somewhere and i can't find it out, because the stack is sorted now for 99%.<br /><br />:alright:<br /><span style="font-size:9px><strong>bitRAKE</strong>: added code tags.</span></div>
    <div class="meta">Posted on 2002-06-03 09:46:59 by eisodur</div>
   </div>
   <div class="post" id="post-41226">
    <div class="subject"><a href="#post-41226">Recursive QuickSort (revised):</a></div>
    <div class="body">Hello <strong>eisodur</strong>, see how easy it is to create quicksorts for different types of data?  I think the error lies in not testing each string for the end.  It should work okay if both strings are the same length, otherwise it overruns them.<br /><br />I am wrong in my statement above - I don't know why it wouldn't work, but will test it later this evening.</div>
    <div class="meta">Posted on 2002-06-03 10:03:50 by bitRAKE</div>
   </div>
   <div class="post" id="post-41227">
    <div class="subject"><a href="#post-41227">Recursive QuickSort (revised):</a></div>
    <div class="body">Other sort routine (universal)<br /><br /><pre><code><br />global SortTable&#58;proc<br /><br />; Free reg &#123;eax,esi&#125;<br />struc sSort<br />CompL	dd ?	;&gt;ecx=Index,edi=Item,&lt;al=?&#40;i&#40;Item&#40;Index&#41;&#41;&lt;&#40;Item&#41;&#41;<br />CompG	dd ?	;&gt;edx=Index,edi=Item,&lt;al=?&#40;i&#40;Item&#40;Index&#41;&#41;&gt;&#40;Item&#41;&#41;<br />Swap	dd ?	;&gt;ecx,edx=Indexs<br />Create	dd ?	;&gt;edi=Index; &lt;edi=Item<br />Destroy dd ?	;&gt;edi=Item<br />ends<br /><br />; ebx=sSort<br />; ecx=Left<br />; edx=Right<br />proc SortTable<br />	push	ecx			; ecx=cL; &#91;esp&#93;=Left	??????????<br />	mov	ebp,edx 		; edx=cR;  ebp =Right	Left ? Right<br />	lea	edi,&#91;ecx+edx&#93;<br />	shr	edi,1			; edi=&#40;cL+cR&#41;/2<br />	call	&#91;ebx+sSort.Create&#93;	; cM=Create&#40;edi&#41;<br />	dec	ecx<br />@@lpL&#58;	inc	ecx			; cL++<br />@@lpV&#58;	call	&#91;ebx+sSort.CompL&#93;	; ? CompL&#40;I&#40;cL&#41;,cM&#41;<br />	test	al,al<br />	jne	@@lpL<br />	inc	edx<br />@@lpR&#58;	dec	edx			; cR--<br />	call	&#91;ebx+sSort.CompG&#93;	; ? CompG&#40;I&#40;cR&#41;,cM&#41;<br />	test	al,al<br />	jne	@@lpR<br />	cmp	ecx,edx 		; cL,cR<br />	je	@@skS_<br />	jg	@@skS<br />	call	&#91;ebx+sSort.Swap&#93;	; Swap&#40;cL,cR&#41;<br />@@skS_&#58; inc	ecx			; cL++<br />	dec	edx			; cR--<br />@@skS&#58;	cmp	ecx,edx 		; ? &#40;cL&lt;=cR&#41;<br />	jle	@@lpV<br />	call	&#91;ebx+sSort.Destroy&#93;	; Destroy&#40;cM&#41;<br />	pop	eax			; eax=Left<br />	cmp	edx,eax 		; ? &#40;cR&lt;Left&#41;<br />	jl	@@skS0<br />	push	ecx ebp 		; cL Right<br />	mov	ecx,eax 		; ecx=Left<br />	call	SortTable		; SortTable&#40;Left,cR&#41;<br />	pop	ebp ecx 		; Right cL<br />@@skS0&#58; cmp	ecx,ebp 		; ? &#40;cL&gt;=Right&#41;<br />	jge	@@ret<br />	mov	edx,ebp 		; edx=Right<br />	jmp	SortTable		; SortTable&#40;cL,Right&#41;<br />@@ret&#58;	ret<br />endp<br /></code></pre></div>
    <div class="meta">Posted on 2002-06-03 10:05:41 by Nexo</div>
   </div>
   <div class="post" id="post-41323">
    <div class="subject"><a href="#post-41323">Recursive QuickSort (revised):</a></div>
    <div class="body"><strong>Nexo</strong>, why are there CompL, CompG?<pre><code>COMPARE macro item1,item2<br />	mov	eax,item1<br />	mov	edx,item2<br />	call	&#91;ebx+sSort.Comp&#93;<br />ENDM<br /><br />EXCHANGE macro item1,item2<br />	mov	eax,item1<br />	mov	edx,item2<br />	call	&#91;ebx+sSort.Swap&#93;<br />ENDM</code></pre>Now each array is an object with methods and the QuickSort code isn't duplicated. :)<br /><br /><br /><strong>eisodur</strong>, how about this?<pre><code>COMPARE macro item1,item2<br />	LOCAL next,done<br /><br />	push ecx<br />	mov edx,&#91;ebx + item1*4&#93;<br />	mov ecx,&#91;ebx + item2*4&#93;<br />next&#58;<br />	mov al,&#91;edx&#93;<br />	inc edx<br />	cmp al,&#91;ecx&#93;<br />	jne done<br />	inc ecx<br />	cmp al,0<br />	jne next<br />done&#58;<br />	pop ecx<br />ENDM</code></pre>Much less overhead than your PROC. :)</div>
    <div class="meta">Posted on 2002-06-03 22:48:58 by bitRAKE</div>
   </div>
   <div class="post" id="post-41345">
    <div class="subject"><a href="#post-41345">Recursive QuickSort (revised):</a></div>
    <div class="body">Hello there,<br /><br />it's a fast one but i think something is missing...<br /><br /><br />(You do the compare but return no results so it's just everytime eax&gt;0. Even when the strings are same)</div>
    <div class="meta">Posted on 2002-06-04 03:32:35 by eisodur</div>
   </div>
   <div class="post" id="post-41363">
    <div class="subject"><a href="#post-41363">Recursive QuickSort (revised):</a></div>
    <div class="body"><strong>eisodur</strong>, I don't use <strong>AL</strong> for the return value - the flags are set with the correct relationship &lt; = &gt;. :)  The only thing I see wrong is that it is a signed byte comparision and it should be unsigned, imho.<br /><br />Unsigned byte string compare:<pre><code>COMPARE macro item1,item2<br />	LOCAL next,done<br /><br />	push edi<br />	push ecx<br />	xor eax,eax ; remove if movzx is used<br />	xor edx,edx<br />	mov edi,&#91;ebx + item1*4&#93;<br />; item1/item2 could be ECX, so store last into ECX<br />	mov ecx,&#91;ebx + item2*4&#93;<br />next&#58;<br />	mov al,&#91;edi&#93; ; movzx eax, BYTE PTR &#91;edi&#93; is better<br />	inc edi<br />	mov dl,&#91;ecx&#93; ;  ; movzx edx, BYTE PTR &#91;ecx&#93; is better<br />	inc ecx<br />	cmp eax,edx<br />	jne done<br />	cmp eax,0<br />	jne next<br />done&#58;<br />	pop ecx<br />	pop edi<br />ENDM</code></pre>I'd be better use to change the <strong>Jcc</strong>'s in the algo for unsigned branching. :)</div>
    <div class="meta">Posted on 2002-06-04 06:00:25 by bitRAKE</div>
   </div>
   <div class="post" id="post-41373">
    <div class="subject"><a href="#post-41373">Recursive QuickSort (revised):</a></div>
    <div class="body">I give here a result of my stack before and after the call to QuickSort, hope that it says enough to someone to see what's going wrong.<br /><br />The unsorted stack just before the call:<br /><br />00ECFF68   00ECFF74<br />00ECFF6C   00000000<br />00ECFF70   0000000D<br />00ECFF74   00ED0056  ASCII &quot;ALLES&quot;<br />00ECFF78   00ED0050  ASCII &quot;ALLEs&quot;<br />00ECFF7C   00ED004C  ASCII &quot;als&quot;<br />00ECFF80   00ED0048  ASCII &quot;BBB&quot;<br />00ECFF84   00ED0044  ASCII &quot;AAA&quot;<br />00ECFF88   00ED0040  ASCII &quot;ALL&quot;<br />00ECFF8C   00ED003C  ASCII &quot;ALL&quot;<br />00ECFF90   00ED0038  ASCII &quot;all&quot;<br />00ECFF94   00ED0034  ASCII &quot;all&quot;<br />00ECFF98   00ED0030  ASCII &quot;ALL&quot;<br />00ECFF9C   00ED002C  ASCII &quot;AAB&quot;<br />00ECFFA0   00ED0028  ASCII &quot;CCC&quot;<br />00ECFFA4   00ED0024  ASCII &quot;BBB&quot;<br />00ECFFA8   00ED0020  ASCII &quot;AAA&quot;<br /><br />Now the sorted stack just after QuickSort is done:<br /><br />00ECFF74   00ED0020  ASCII &quot;AAA&quot;<br />00ECFF78   00ED0044  ASCII &quot;AAA&quot;<br />00ECFF7C   00ED002C  ASCII &quot;AAB&quot;<br />00ECFF80   00ED0030  ASCII &quot;ALL&quot;<br />00ECFF84   00ED0040  ASCII &quot;ALL&quot;<br />00ECFF88   00ED003C  ASCII &quot;ALL&quot;<br />00ECFF8C   00ED0056  ASCII &quot;ALLES&quot;<br />00ECFF90   00ED0038  ASCII &quot;all&quot;<br />00ECFF94   00ED0050  ASCII &quot;ALLEs&quot;<br />00ECFF98   00ED0048  ASCII &quot;BBB&quot;<br />00ECFF9C   00ED0024  ASCII &quot;BBB&quot;<br />00ECFFA0   00ED0028  ASCII &quot;CCC&quot;<br />00ECFFA4   00ED0034  ASCII &quot;all&quot;<br />00ECFFA8   00ED004C  ASCII &quot;als&quot;<br /><br />-is the jle @exit not timed well?<br />-or is the pivot not replaced well?<br /><br />I don't know, but i'm beginning to hallucinate here and nead a brake after debugging for 2 days.:confused:</div>
    <div class="meta">Posted on 2002-06-04 08:10:15 by eisodur</div>
   </div>
   <div class="post" id="post-41383">
    <div class="subject"><a href="#post-41383">Recursive QuickSort (revised):</a></div>
    <div class="body">I HAVE IT  AND I AM REALLLLLY GLAD!!:grin: :grin: <br /><br />The problem was that there is one to many inc ebp.<br /><br />When this happens there is skipped one element in the partioning.<br /><br />Here follows the QuickSort that works with me:<pre><code>QuickSort PROC uses esi edi ebx, qARRAY&#58;DWORD, qLOW&#58;DWORD, qHIGH&#58;DWORD<br />	push ebp ; an extra register, oh boy!<br />	mov ebx, qARRAY<br />	mov esi, qLOW<br />	mov edi, qHIGH<br />	call PARTITION<br />	pop ebp<br />	ret ; let MASM do it's &quot;magic&quot; on this ret<br /><br />PARTITION&#58;<br />		push esi<br />		push edi<br />		mov ebp,edi<br />		sub edi,esi		; width of partition - 2<br />		jle @exit		; must be &gt;1 elements to sort<br />		mov ecx,esi		; choose pivot<br />		inc ebp			; counter first dec<br />@low&#58;		inc esi<br />		dec edi<br />		js @donel ; esi is out of range or part of upper partition<br />		<br />		invoke EisoCmp,DWORD PTR &#91;ebx + ecx*4&#93;,DWORD PTR &#91;ebx + esi*4&#93;<br />		cmp eax,0<br />		<br />		jge @low<br />@high&#58;		dec ebp<br />		dec edi<br />		js @donel ; ebp is out of range or part of lower partition<br />		<br />		invoke EisoCmp,DWORD PTR &#91;ebx + ecx*4&#93;,DWORD PTR &#91;ebx + ebp*4&#93;<br />		cmp eax,0<br />		<br />		jle @high<br />		mov edx,&#91;ebx + esi*4&#93;<br />		mov eax,&#91;ebx + ebp*4&#93;<br />		mov &#91;ebx + ebp*4&#93;,edx<br />		mov &#91;ebx + esi*4&#93;,eax<br />		jmp @low<br /><br />@donel&#58;		dec esi<br />		mov edx,&#91;ebx + ecx*4&#93;<br />		mov eax,&#91;ebx + esi*4&#93;<br />		mov &#91;ebx + esi*4&#93;,edx<br />		mov &#91;ebx + ecx*4&#93;,eax<br />		<br />		<br />		dec esi ; pivot is sorted<br />		mov edi,&#91;esp&#93;<br />		mov &#91;esp&#93;,esi<br />		mov esi,ebp<br />		call PARTITION<br />		pop edi<br />		pop esi<br />		jmp	PARTITION<br /><br />@exit&#58;		add esp,8<br />		db 0C3h ; ret ; force _REAL_ ret in MASM<br /><br />QuickSort ENDP<br /><br /><br />EisoCmp PROC a&#58;DWORD,b&#58;DWORD<br />	push esi<br />	push edi<br />	xor eax,eax<br />	mov esi,a<br />	mov edi,b<br />next&#58;	mov al,&#91;esi&#93;<br />	mov ah,&#91;edi&#93;<br />	cmp ax,0<br />	jz same<br />	cmp al,ah<br />	jb lower<br />	ja higher<br />	inc esi<br />	inc edi<br />	jmp next<br />same&#58;	xor eax,eax<br />	pop edi<br />	pop esi<br />	ret<br />lower&#58;	or eax,-1<br />	pop edi<br />	pop esi<br />	ret<br />higher&#58;	mov eax,1<br />	pop edi<br />	pop esi<br />	ret<br />EisoCmp ENDP</code></pre>This code is fine you can optimise it with bitRAKE's strcmp macro, but do not try it with the ole32 strcmp.<br /><br />Thanks goes 2 bitRake for this fine QuickSort routine.<br /><br />:alright:</div>
    <div class="meta">Posted on 2002-06-04 09:03:09 by eisodur</div>
   </div>
   <div class="post" id="post-41388">
    <div class="subject"><a href="#post-41388">Recursive QuickSort (revised):</a></div>
    <div class="body">Keep up the good work folks, sort routines are very useful, particularly when the can do a multiple of different data types. I dabbled with sort routines last year but ran out of time to play with them, when I get some more time and a bit more working brain, I would like to have a go at them again as there is some interesting stuff that can be done.<br /><br />Hybrid sorts seem to have the legs at the moment, I had a lot of useful input from JIBZ who was working on them as well, Classical quick sorts combined with alternative sort types when the quick sort count went too low helped them to get faster.<br /><br />I think the C++ STL INTRO sort is the current fast one but there is room to go faster if its done right.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-06-04 09:42:59 by hutch--</div>
   </div>
   <div class="post" id="post-41390">
    <div class="subject"><a href="#post-41390">Recursive QuickSort (revised):</a></div>
    <div class="body"><div class="quote"><br />I HAVE IT  AND I AM REALLLLLY GLAD!!:grin: :grin: <br /><br />The problem was that there is one to many inc ebp.<br /><br />When this happens there is skipped one element in the partioning.</div>That is great!  Sounds like there was bug in the routine.<br />Thanks for the help. :)</div>
    <div class="meta">Posted on 2002-06-04 10:23:54 by bitRAKE</div>
   </div>
   <div class="post" id="post-41438">
    <div class="subject"><a href="#post-41438">Recursive QuickSort (revised):</a></div>
    <div class="body"><strong>Stack usage</strong><br /><br />A common implementation is to always subpartition in the same order. In this case, the worst case stack usage is proportional to the number of items to sort (N). Stack usage can be reduced to log2(N) by choosing to subpartition the smaller partition before the larger one.</div>
    <div class="meta">Posted on 2002-06-04 16:35:03 by tenkey</div>
   </div>
   <div class="post" id="post-41449">
    <div class="subject"><a href="#post-41449">Recursive QuickSort (revised):</a></div>
    <div class="body"><strong>tenkey</strong>, thanks - I will implement in next revision.</div>
    <div class="meta">Posted on 2002-06-04 17:22:34 by bitRAKE</div>
   </div>
   <div class="post" id="post-41481">
    <div class="subject"><a href="#post-41481">Recursive QuickSort (revised):</a></div>
    <div class="body">I just had a poke tyhrough the stuff I was working on last year and found a working algo that may be useful in writing a hybrid sort algo where the main work is done by a quick sort and the auxilary sort is done by an insertion sort.<br /><br />I have seen the insertion sort used in a couple of ways, one is to check the gap size that the quick sort is working on and under a threshold, pass it off to the insertion sort as it is a lot more efficient on small gaps than the quick sort.<br /><br />Hope it is useful, Jibz coded the original in C.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a><br /><br /><pre><code><br />; ########################################################################<br /><br />insertsort2 proc Arr&#58;DWORD, lb&#58;DWORD, ub&#58;DWORD<br /><br />  ; parameters<br />  ; -- -------------------------------------------------<br />  ; Arr         base address of array<br />  ; lb          index of lower member of array to sort<br />  ; ub          index of upper member of array to sort<br />  ; ---------------------------------------------------<br /><br />    push ebx<br />    push esi<br />    push edi<br /><br />    mov esi, Arr            ; offset of array in ESI<br />    mov eax, lb             ; lower bound<br />    shl eax, 2              ; mul by 4<br />    add esi, eax            ; add offset to array<br />    mov ecx, 1<br />    inc ub<br />    mov ebx, ub             ; upper bound in EBX<br />    sub ebx, lb             ; sub lower bound from upper<br /><br />  iStart&#58;<br />    mov edi, &#91;esi+ecx*4&#93;<br />    mov edx, ecx<br /><br />  inner&#58;<br />  ; -----------------<br />  ; unroll loop by 2<br />  ; -----------------<br />    mov eax, &#91;esi+edx*4-4&#93;<br />    cmp eax, edi<br />    jle wExit<br />    mov &#91;esi+edx*4&#93;, eax<br />    dec edx<br />    jz wExit<br /><br />    mov eax, &#91;esi+edx*4-4&#93;<br />    cmp eax, edi<br />    jle wExit<br />    mov &#91;esi+edx*4&#93;, eax<br />    dec edx<br />    jnz inner<br /><br />  wExit&#58;<br />    mov &#91;esi+edx*4&#93;, edi<br />    inc ecx<br />    cmp ecx, ebx<br />    jl iStart<br /><br />    pop edi<br />    pop esi<br />    pop ebx<br /><br />    ret<br /><br />insertsort2 endp<br /><br />; ##########################################################################<br /></code></pre></div>
    <div class="meta">Posted on 2002-06-04 21:14:03 by hutch--</div>
   </div>
   <div class="post" id="post-41490">
    <div class="subject"><a href="#post-41490">Recursive QuickSort (revised):</a></div>
    <div class="body">Thanks, <strong>Hutch--</strong>.  There is much here to think about.  Don't we usually search a large body of information, fitting it to a model, and then sort?  I mean in a very general sense of software mechanics.  A person could keep themselves busy for the rest of their life with just sort and search. :grin:</div>
    <div class="meta">Posted on 2002-06-04 22:51:31 by bitRAKE</div>
   </div>
   <div class="post" id="post-41498">
    <div class="subject"><a href="#post-41498">Recursive QuickSort (revised):</a></div>
    <div class="body"><div class="quote"><br />Hope it is useful, Jibz coded the original in C.</div><br /><br />Hi.<br />If you still have the C version, I would be glad to see it.<br /><br />Thanks.</div>
    <div class="meta">Posted on 2002-06-05 00:58:13 by JCP</div>
   </div>
   <div class="post" id="post-41589">
    <div class="subject"><a href="#post-41589">Recursive QuickSort (revised):</a></div>
    <div class="body"><div class="quote"><br /><strong>Nexo</strong>, why are there CompL, CompG?<pre><code>COMPARE macro item1,item2<br />	mov	eax,item1<br />	mov	edx,item2<br />	call	&#91;ebx+sSort.Comp&#93;<br />ENDM<br /><br />EXCHANGE macro item1,item2<br />	mov	eax,item1<br />	mov	edx,item2<br />	call	&#91;ebx+sSort.Swap&#93;<br />ENDM</code></pre>Now each array is an object with methods and the QuickSort code isn't duplicated. :)<br /></div><br />It is not always good. For example:<br /><pre><code><br />Create<br />	mov edi,&#91;Array+4*edi&#93;<br /><br />Swap<br />	mov eax,&#91;Array+4*ecx&#93;<br />	mov esi,&#91;Array+4*edx&#93;<br />	mov &#91;Array+4*edx&#93;,eax<br />	mov &#91;Array+4*ecx&#93;,esi<br /><br />CompL<br />	cmp &#91;Array+4*ecx&#93;,edi<br /><br />CompG<br />	cmp &#91;Array+4*edx&#93;,edi<br /></code></pre></div>
    <div class="meta">Posted on 2002-06-05 12:26:47 by Nexo</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=2361&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=2361&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="2361" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=2361&amp;page=2">&gt;</a><a href="../?id=2361&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>