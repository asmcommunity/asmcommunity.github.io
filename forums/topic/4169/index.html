<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Base64 Attachment Decoder - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4169" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=4169">Base64 Attachment Decoder</a></p>
   <div class="post" id="post-28626">
    <div class="subject"><a href="#post-28626">Base64 Attachment Decoder</a></div>
    <div class="body">Hello,<br />I know how to encrypt files into Base64 encrypted form so I can send them as an attachment with email. Now, I want to know how do I decode an encrypted attachment. <br /><br />If I got the code &quot;xxxxx.................xxxx&quot; which is encrypted into Base64, I want to get the original file. <br /><br />Orig.exe - &quot;xxxxxxxxxxxxxxxxxxx&quot; (encrypted)<br />Orig.exe - &quot;yyyyyyyyyyyyyyyyyyy&quot; (not encrypted)<br /><br />Here is the code for encoding (I didn't write it):<br /><br />encodeBase64	Proc<br /><br />       xor     esi,esi <br />       call    over_enc_table<br />       db      &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;<br />       db      &quot;abcdefghijklmnopqrstuvwxyz&quot;<br />       db      &quot;0123456789+/&quot;<br />over_enc_table:<br />        pop     edi<br />        push    ebp<br />        xor     ebp,ebp<br />baseLoop:<br />        movzx   ebx,byte ptr <br />        shr     bl,2<br />        and     bl,00111111b<br />        mov     bh,byte ptr <br />        mov     byte ptr ,bh<br />        inc     esi<br /><br />        mov     bx,word ptr <br />        xchg    bl,bh<br />        shr     bx,4<br />        mov     bh,0<br />        and     bl,00111111b<br />        mov     bh,byte ptr <br />        mov     byte ptr ,bh<br />        inc     esi<br /><br />        inc     eax<br />        mov     bx,word ptr <br />        xchg    bl,bh<br />        shr     bx,6<br />        xor     bh,bh<br />        and     bl,00111111b<br />        mov     bh,byte ptr <br />        mov     byte ptr ,bh<br />        inc     esi<br /><br />        inc     eax<br />        xor     ebx,ebx<br />        movzx   ebx,byte ptr <br />        and     bl,00111111b<br />        mov     bh,byte ptr <br />        mov     byte ptr ,bh<br />        inc     esi<br />        inc     eax<br /><br />        inc     ebp<br />        cmp     ebp,24<br />        jna     DontAddEndOfLine<br /><br />        xor     ebp,ebp                         <br />        mov     word ptr ,0A0Dh<br />        inc     esi<br />        inc     esi<br />        test    al,00h                          <br />        org     $-1<br /><br />DontAddEndOfLine:<br /><br />        inc     ebp<br />        sub     ecx,3<br />        or      ecx,ecx<br />        jne     baseLoop<br /><br />        mov     ecx,esi<br />        add     edx,esi<br />        pop     ebp<br />        ret<br /><br />encodeBase64	EndP<br /><br /><br />edx - Where to store encrypted data<br />eax - what to encrypt<br /><br />Output:<br />ecx - size of encrypted data</div>
    <div class="meta">Posted on 2002-03-12 14:17:27 by Cube</div>
   </div>
   <div class="post" id="post-28744">
    <div class="subject"><a href="#post-28744">Base64 Attachment Decoder</a></div>
    <div class="body">Hi, <br /><br />be carefull using this proc. IMHO this implemetation is wrong because I can't see the padding required if the data to be encoded has a length which is not a multiple of 3 Bytes.<br /><br />In order to decode base64 simple implement a translates the alphabet A..Z a..z + / in reverse order. Skip all other chars even line breaks. Other chars may be used for error detection. <br /><br />check out RFC1521 for more Info ..<br /><br />Bye Miracle</div>
    <div class="meta">Posted on 2002-03-13 04:44:39 by miracle</div>
   </div>
   <div class="post" id="post-28753">
    <div class="subject"><a href="#post-28753">Base64 Attachment Decoder</a></div>
    <div class="body">What exactly do you mean by 'a translates the alphabet A..Z a..z + / in reverse order' ??<br /><br />Is it ok if I won't check lines breaks and keep encoding the data into the original binary file ?</div>
    <div class="meta">Posted on 2002-03-13 06:22:05 by Cube</div>
   </div>
   <div class="post" id="post-28754">
    <div class="subject"><a href="#post-28754">Base64 Attachment Decoder</a></div>
    <div class="body">Hi, <br /><br />it could look like this (without table)<br /><br /><pre><code><br /><br />xxxLoop&#58;<br />	; -- test for end of stream here ..<br /><br />	xor	eax, eax<br />	mov	al, &#91;edi + ecx&#93;<br />	cmp	al, 02Bh	; +<br />	je	xxxSpec1<br />	cmp	al, 02Fh	; /<br />	je	xxxSpec2<br /><br />	cmp	al, 30h	; 0<br />	jl	xxxIllegal<br />	cmp	al, 39h	; 9<br />	jle	xxxNumber<br /><br />	cmp	al, 41h	; A<br />	jl	xxxIllegal<br />	cmp	al, 5Ah	; Z<br />	jle	xxxCapital<br /><br />	cmp	al, 61h	; a<br />	jl	xxxIllegal<br />	cmp	al, 7Ah	; z<br />	jle	xxxLetter<br /><br />xxxIllegal&#58;<br />	; -- if not al == 0Ah || al == 0Dh transmission error<br /><br />xxxNumber&#58;	add	eax, 4<br />	putbits	lpBuffer, eax<br />	jmp	xxxMore<br /><br />xxxCapital&#58;	sub	eax, 65<br />	putbits	lpBuffer, eax<br />	jmp	xxxMore<br /><br />xxxLetter&#58;	sub	eax, 71<br />	putbits	lpBuffer, eax<br />	jmp	xxxMore<br /><br />xxxSpec1&#58;	putbits	lpBuffer, 62<br />	jmp	xxxMore<br /><br />xxxSpec2&#58;	putbits	lpBuffer, 63<br />	jmp	xxxMore<br /><br />xxxMore&#58;	inc	ecx<br />	jmp	xxxLoop<br /><br /></code></pre><br /><br />Bye Miracle</div>
    <div class="meta">Posted on 2002-03-13 06:57:48 by miracle</div>
   </div>
   <div class="post" id="post-28756">
    <div class="subject"><a href="#post-28756">Base64 Attachment Decoder</a></div>
    <div class="body">Hi, <br /><br />or use a table like this to get the 6 bit value from 8 bit encoded stream. Use the encoded byte as an offset in table, but consider that yuo'll need an error detection ..<br /><br /><pre><code><br />lpTable&#58;	db	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0<br />	db	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0<br />	db	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 0, 0, 0, 63<br />	db	52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 0, 0<br />	db	0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14<br />	db	15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 0<br />	db	0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40<br />	db	41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 0, 0, 0, 0, 0<br />	db	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0<br />	db	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0<br />	db	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0<br />	db	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0<br />	db	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0<br />	db	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0<br />	db	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0<br />	db	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0<br /><br /></code></pre><br /><br />Bye Miracle</div>
    <div class="meta">Posted on 2002-03-13 07:12:59 by miracle</div>
   </div>
   <div class="post" id="post-29135">
    <div class="subject"><a href="#post-29135">Base64 Attachment Decoder</a></div>
    <div class="body">Some stuff i wrote about one year ago, if not longer... It does padding and all that stuff too...<br /><br /><pre><code><br />.data<br />	alphabet	db &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;<br />	<br />.code<br />base64encode PROC source&#58;DWORD, destination&#58;DWORD, sourcelen&#58;DWORD<br />	push edi<br />	push esi<br />	push ebx<br />	mov  esi, source<br />	mov  edi, destination<br />@@base64loop&#58;<br />	xor eax, eax<br />	.IF sourcelen == 1<br />		lodsb						;source ptr + 1<br />		mov ecx, 2					;bytes to output = 2<br />		mov edx, 03D3Dh					;padding = 2 byte<br />		dec sourcelen					;length - 1<br />	.ELSEIF sourcelen == 2<br />		lodsw						;source ptr + 2<br />		mov ecx, 3					;bytes to output = 3<br />		mov edx, 03Dh					;padding = 1 byte<br />		sub sourcelen, 2				;length - 2<br />	.ELSE<br />		lodsd<br />		mov ecx, 4					;bytes to output = 4<br />		xor edx, edx					;padding = 0 byte<br />		dec esi						;source ptr + 3 &#40;+4-1&#41;<br />		sub sourcelen, 3				;length - 3 <br />	.ENDIF<br /><br />	xchg al,ah						; flip eax completely<br />	rol  eax, 16						; can this be done faster<br />	xchg al,ah						; ??<br /><br />	@@&#58;<br />	push  eax<br />	and   eax, 0FC000000h					;get the last 6 high bits<br />	rol   eax, 6						;rotate them into al<br />	mov   al,  byte ptr &#91;offset alphabet+eax&#93;		;get encode character<br />	stosb							;write to destination<br />	pop   eax<br />	shl   eax, 6						;shift left 6 bits<br />	dec   ecx<br />	jnz   @B						;loop<br />	<br />	cmp   sourcelen, 0<br />	jnz   @@base64loop					;main loop<br />	<br />	mov   eax, edx						;add padding and null terminate<br />	stosd							;  &quot;     &quot;    &quot;     &quot;     &quot;<br /><br />	pop   ebx<br />	pop   esi<br />	pop   edi<br />	ret<br />base64encode ENDP<br /></code></pre><br /><br /><pre><code><br />.data<br />	; ASCII-43 -&gt; BASE64 mapping table<br />	base64table 	db 62,0,0,0,63,52,53,54,55,56,57,58,59,60,61,0<br />			db 0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13<br />			db 14,15,16,17,18,19,20,21,22,23,24,25,0,0,0,0<br />			db 0,0,26,27,28,29,30,31,32,33,34,35,36,37,38<br />			db 39,40,41,42,43,44,45,46,47,48,49,50,51<br />			<br />.code<br />base64decode PROC source&#58;DWORD, destination&#58;DWORD<br />	push   ebx<br />	push   esi<br />	push   edi<br />	mov    esi, source<br />	mov    edi, destination<br />	invoke lstrlen, source<br />	shr    eax, 2<br />	mov    ecx, eax<br />	push   ecx<br />@@outer_loop&#58;<br />	xor    ebx, ebx<br />	mov    ecx, 4<br />	lodsd<br />@@inner_loop&#58;<br />	push   eax<br />	and    eax, 0FFh<br />	sub    al, 43<br />	or     bl, &#91;offset base64table+eax&#93;<br />	shl    ebx, 6<br />	pop    eax<br />        shr    eax, 8<br />        dec    ecx<br />        jnz    @@inner_loop<br />        mov    eax, ebx<br />        rol    ax, 8<br />        rol    eax, 16<br />        rol    ax, 8<br />        stosd<br />        dec    edi<br />        pop    ecx<br />        dec    ecx<br />        jnz    @@outer_loop<br />        pop    edi<br />        pop    esi<br />        pop    ebx<br />        ret<br />base64encode ENDP<br /></code></pre><br /><br />Same as the one above but with error detection...<br /><br /><pre><code><br />	; ASCII -&gt; BASE64 mapping table<br />	base64table	db 43 dup &#40;255&#41;<br />		 	db 62,255,255,255,63,52,53,54,55,56,57,58,59,60,61,255<br />			db 255,255,0,255,255,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13<br />			db 14,15,16,17,18,19,20,21,22,23,24,25,255,255,255,255<br />			db 255,255,26,27,28,29,30,31,32,33,34,35,36,37,38<br />			db 39,40,41,42,43,44,45,46,47,48,49,50,51<br />			db 132 dup &#40;255&#41;<br /><br />base64decode PROC source&#58;DWORD, destination&#58;DWORD, sourcelen&#58;DWORD<br />	push   esi<br />	push   edi<br />	push   ebx<br />	<br />	mov    esi, source		; esi &lt;- source<br />	mov    edi, destination		; edi &lt;- destination<br />	mov    ecx, sourcelen<br />	shr    ecx, 2<br />	cld<br />	<br />	;-------------&#91;decoding part&#93;---------------<br />	<br />@@outer_loop&#58;<br />	push   ecx<br />	mov    ecx, 4<br />	xor    ebx, ebx<br />	lodsd<br />@@inner_loop&#58;<br />	push   eax<br />	and    eax, 0ffh<br />	mov    al, byte ptr &#91;offset base64table+eax&#93;<br />	cmp    al, 255<br />	je     @@invalid_char<br />	shl    ebx, 6<br />	or     bl, al<br />	pop    eax<br />	shr    eax, 8<br />	dec    ecx<br />	jnz    @@inner_loop<br />	mov    eax, ebx<br />	shl    eax, 8 <br />	xchg   ah, al<br />	ror    eax, 16<br />	xchg   ah, al<br />	stosd<br />	dec    edi<br />	pop    ecx<br />	dec    ecx<br />	jnz    @@outer_loop<br />	xor    eax, eax<br />	jmp    @@decode_done<br />	<br />	;-------------------------------------------<br />	<br />@@invalid_char&#58;<br />	mov    eax, -1<br />@@decode_done&#58;<br />	pop    ebx<br />	pop    edi<br />	pop    esi<br />	ret<br />base64decode ENDP<br /></code></pre></div>
    <div class="meta">Posted on 2002-03-15 07:02:19 by Zynaps</div>
   </div>
   <div class="post" id="post-30648">
    <div class="subject"><a href="#post-30648">Base64 Attachment Decoder</a></div>
    <div class="body">High-speed decoding action BASE64.<br /><br />; From Internet network library by Stepan Polovnikov<br />; SMTP/BASE64 decoder<br /><br />tblB64	db &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;<br /><br />label tblDecode dword<br />Fi	dd 256 dup (?)<br />Se	dd 256 dup (?)<br />Th	dd 256 dup (?)<br />Fo	dd 256 dup (?)<br /><br />; 22333333 11112222 00000011<br />BuildTableDecoder:<br />	lea	edi,<br />	mov	ebx,edi<br />	mov	ecx,4*256<br />	mov	eax,01000000h<br />	rep	stosd<br />	mov	ecx,64<br />	xor	edi,edi<br />@@lp:	lodsb<br />	lea	edx,<br />	mov	,edx<br />	mov	edx,edi<br />	mov	dh,dl<br />	shr	dl,4<br />	shl	dh,4<br />	mov	,edx<br />	mov	edx,edi<br />	mov	dh,dl<br />	shr	dl,2<br />	shl	dh,6<br />	shl	edx,8<br />	mov	,edx<br />	mov	edx,edi<br />	shl	edx,16<br />	mov	,edx<br />	inc	edi<br />	dec	ecx<br />	jne	@@lp<br />	ret<br /><br />Decoder:<br />; Input:<br />; esi - source buffer<br />; eax - source length<br />; ecx - destination buffer<br />; Output:<br />; eax&lt;&gt;0 OR ZF=0 - invalid chars<br />	lea	edi,<br />	shr eax,2<br />@@lp:	xor	ebp,ebp<br />	mov	edx,	; get 4 chars<br />	add	esi,4<br />	mov	ebx,3 ; decode fouth char<br />	shld	ebx,edx,8<br />	add	ebp,<br />	shld	ebx,edx,16  ; decode third char<br />	and	ebx,0FFh<br />	add	ebp,<br />	movzx	ebx,dh  ; decode second char<br />	add	ebp,<br />	and	edx,0FFh<br />	add	ebp, ; decode first char<br />	test	ebp,0FF000000h ; check invalid chars<br />	jne	@@err<br />	mov	,ebp<br />	add	ecx,3<br />	dec eax<br />	jne	@@lp<br />@@err:	ret</div>
    <div class="meta">Posted on 2002-03-24 13:46:05 by Nexo</div>
   </div>
   <div class="post" id="post-31121">
    <div class="subject"><a href="#post-31121">Base64 Attachment Decoder</a></div>
    <div class="body">Hi Nexo,<br /><br /><pre><code><br />Decoder&#58;<br />; Input&#58;<br />; esi - source buffer<br />; eax - source length<br />; ecx - destination buffer<br />; Output&#58;<br />; eax&lt;&gt;0 OR ZF=0 - invalid chars<br /><br />	lea	edi, &#91;tblDecode&#93;<br />	;shr	eax, 2<br />@@lp&#58;						; <br />	;xor	ebp, ebp<br />	mov	edx, &#91;esi&#93;		; get 4 chars<br />	add	esi, 4<br />	mov	ebx, 3			; decode fouth char<br />	shld	ebx, edx, 8<br />    mov     ebp, &#91;edi+4*ebx&#93;<br />	shld	ebx, edx,16		; decode third char<br />	and	ebx, 0FFh<br />	add	ebp, &#91;edi+4*&#40;ebx+200h&#41;&#93;<br />	movzx	ebx, dh		; decode second char<br />	add	ebp, &#91;edi+4*&#40;ebx+100h&#41;&#93;<br />	and	edx, 0FFh<br />	add	ebp, &#91;edi+4*edx&#93;	; decode first char<br />	;test	ebp, 0FF000000h	; check invalid chars<br />          js   @@err         ; just change in table  1 with 0FFh or other neg value <br />	;jne	@@err<br />	mov	&#91;ecx&#93;, ebp	; slow -&gt;writing in unaligned buffer !!! <br />        add     ecx, 3<br />	;dec	eax			; <br />          sub   eax, 4<br />          jg      @@lp<br />	;jne	@@lp<br />          ret  ; and you should return number of written bytes in eax		<br />@@err&#58;<br />	;Begin error managing proc  -&gt; CRLF and &quot;=&quot; are NOT invalid chars <br />	;Example&#58; if you received  e-mail the  attachment may be<br />	; BASE64 encoded and it has CRLF after every 76 or less encoded characters<br />	; this proc must skip CRLF and return to the loop...<br />	; If  the last  1 or 2 characters from the buffer are &quot;=&quot;<br />	; this proc must decrement number of written bytes....<br />	; More info for this example in RFC 2045  - Internet Message Bodies            <br />.......<br />.......<br />	ret</code></pre></div>
    <div class="meta">Posted on 2002-03-27 03:59:42 by buliaNaza</div>
   </div>
   <div class="post" id="post-31163">
    <div class="subject"><a href="#post-31163">Base64 Attachment Decoder</a></div>
    <div class="body">I am Sorry, but it is the old draft code from joint design. I have no direct concept about BASE64. This code was a starting point for usage BASE64, UUE, XXE decoding actions. I have made some editing the code, that it was not absolutely correct in this case. :(<br />	 For watching CRLF and '=' it is possible to use addition:<br />mov edx, ; get 4 chars <br />cmp dl, 0Dh<br />je CRLF<br />cmp dl, 0Ah<br />je CRLF<br />cmp dl, '='<br />je end_msg<br />...<br />CRLF:<br />inc esi<br />dec eax<br />jne @@ lp<br />ret<br /><br />mov , ebp - here works buffering and the postponed writing. In result it works most more effectively, than decoding action of separate entry characters.<br />	 I only have tried to display a procedure of operation with tables at packing groups bit and no more.</div>
    <div class="meta">Posted on 2002-03-27 10:53:53 by Nexo</div>
   </div>
  </div>
 </body>
</html>