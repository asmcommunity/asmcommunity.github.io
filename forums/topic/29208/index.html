<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Some Assembly Questions From A New Programmer - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29208" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29208">Some Assembly Questions From A New Programmer</a></p>
   <div class="post" id="post-206287">
    <div class="subject"><a href="#post-206287">Some Assembly Questions From A New Programmer</a></div>
    <div class="body">Hey everyone! Thank you for reading my thread. I have been interested in programming for quite some time now, but I have never had the time or motivation to do it. I moderate a forum that revolves around online games and various &quot;tools&quot; and programs, in which our members program both for free or for a fee. I think it&#039;s about time I begin to contribute some quality programs, and from what I have read, assembly is where it is at.<br /><br />I have never programmed before in my life, well at least until I picked up a copy of Randall Hyde&#039;s &quot;The Art of Assembly Language&quot;. HLA boasts to be as powerful as ASM, but also more time-efficient, which was everything I could have hoped for. I had a look at some documents and articles on various Assemblers before reading the book, and MASM32 and TASM also sound quite interesting. <br /><br />I have almost finished chapter 1 of The Art of Assembly Language, but because of the lack of source code available and variety of tutorials (or lack of) for HLA in general, I am considering changing to MASM32 or TASM. <br /><br />My Question) Should I stick with HLA, and just continue working through the book? Keep in mind my goal is to learn Assembly, but also to be able to program, in the shortest time possible. The Art of Assembly book states that it &quot;weeds&quot; you out of HLA procedures, so hopefully by the end I&#039;ll have a decent knowledge of true ASM (Win-32).<br /><br />Thanks!<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-11-11 02:38:22 by Matt</div>
   </div>
   <div class="post" id="post-206288">
    <div class="subject"><a href="#post-206288">Re: Some Assembly Questions From A New Programmer</a></div>
    <div class="body">As soon as you are comfortable with HLA, stop using it.<br />Why? Because to stagnate is to rot - if you&#039;re not in a state of growth, you are dying.<br />Although HLA is a nice place to start, I would not suggest you stick with it - because its an interpreted language, and you&#039;ll never have absolute control over your code if you use an interpreted language.<br /><br />Once you&#039;re familiar with HLA, I would recommend taking a look at ObjAsm32.<br />HLA is a preprocessor which emits asm.<br />ObjAsm32 is what Randy was trying to achieve in MASM before he gave up and wrote HLA - a highlevel object oriented programming environment which only exists at buildtime - no preprocessor!<br />Randy gave up because MASM has some serious limitations that he was never able to work around.<br />Biterider has managed to find ways around them :)<br /><br />It&#039;s perfectly suitable for rapid application development, and has a similar look and feel to HLA, so you&#039;ll be right at home. Furthermore, the key developers of ObjAsm32 are both administrators of this forum! (Biterider wrote most of OA32, I&#039;ve been actively developing under it and contributing to its expansion for the past couple of years).<br />HLA is aimed at orienting students in the ways of asm, whereas OA32 is geared toward commercial development.<br /><br />Of course, I am biased but do note that I use OA32 for ALL my programming requirements since I was pressed into using it.... now I&#039;m addicted! If I want a new feature in OA32, I can ask Biterider for it and usually he agrees with me and it gets added immediately (whether I provide the code or not). OA32 has a smart update feature which allows you to keep up to date with changes without waiting for the next major public release, so it is very much an organic living thing which is in a state of constant growth.<br /><br /></div>
    <div class="meta">Posted on 2008-11-11 03:38:24 by Homer</div>
   </div>
   <div class="post" id="post-206289">
    <div class="subject"><a href="#post-206289">Re: Some Assembly Questions From A New Programmer</a></div>
    <div class="body">Thank you for the very detailed and informative reply. I was under the impression that I would be able to write and use pure ASM (the only way I know how to describe untouched/modified Assembly for Windows XP) when necessary, but use HLA&#039;s additional &quot;procedures&quot; if I wanted to save some time.<br /><br />One major problem that I am having is mainly the overload of information. Often I have to google stuff from the Art of Assembly Language book because of my lack of prior programming knowledge, and I end up viewing info that relates to a multitude of assemblers! I am having a hard time knowing what to apply and what assembler it applies to :(.<br /><br />Maybe I should just &quot;complete&quot; the Art of Assembly Language, meaning read it all, do my best to understand all of the concepts and then turn to ObjAsm32. What kind of documentation does it have though? And are there any specific tutorials I should follow? <br /><br />Thanks!<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-11-11 04:10:32 by Matt</div>
   </div>
   <div class="post" id="post-206290">
    <div class="subject"><a href="#post-206290">Re: Some Assembly Questions From A New Programmer</a></div>
    <div class="body">I&#039;ve been programming in asm for over 25 years and I still have to google stuff.<br /><br />ObjAsm32 has a helpfile (not that useful) and a set of examples (more useful) but you&#039;ll be able to ask questions and have them answered by the key players... I have a lot of respect for Randy, however he doesn&#039;t have the time nor the inclination to answer each and every question, and we do... so yes, follow through with what you are doing, and then move on.</div>
    <div class="meta">Posted on 2008-11-11 07:05:10 by Homer</div>
   </div>
   <div class="post" id="post-206294">
    <div class="subject"><a href="#post-206294">Re: Some Assembly Questions From A New Programmer</a></div>
    <div class="body">Thank you very much! And I have decided to just go with MASM32 for now, as I was able to find a whole lot of helpful stuff (specifically for beginners like myself).<br /><br />I&#039;m looking forwards to Objasm32, and it&#039;s great that you can offer help, which you have already done allot of for me. :D</div>
    <div class="meta">Posted on 2008-11-12 01:26:31 by Matt</div>
   </div>
   <div class="post" id="post-206296">
    <div class="subject"><a href="#post-206296">Re: Some Assembly Questions From A New Programmer</a></div>
    <div class="body">Good choice..&nbsp; MASM is not exactly the best assembler in the world, it has some real limitations (I think all assemblers do), but its macro engine is very powerful, which is how OA32 was realized.<br />OA32 is mostly a set of macros for MASM, coding under OA32 is somewhere between pure asm and HLA, but really, its just MASM and some macros and some procedures.<br />You can freely mix pure MASM code with OA32 code, and you don&#039;t need a fancy preprocessor to make it work.<br /><br />However eventually we&#039;d like to write a preprocessor like HLA.<br />But not for the same reasons.<br />We wish to cross to other platforms, and other assemblers, so our preprocessor will be a &#039;babelfish&#039; which translates sourcecode into asm source for the platform and assembler of choice... but for the moment, we&#039;re stuck with MASM.<br /><br />In terms of commercial viability, one of the key features of OA32 is that you can use pre-assembled objects (classes) in a project, which vastly improves build times. I&#039;m not sure that HLA offers this.<br /><br /></div>
    <div class="meta">Posted on 2008-11-12 02:54:30 by Homer</div>
   </div>
   <div class="post" id="post-206302">
    <div class="subject"><a href="#post-206302">Re: Some Assembly Questions From A New Programmer</a></div>
    <div class="body">Once again, thanks for the insight. I have a question though, it may sound stupid and I think I know what the answer will be. My question is, if I use OA32, will it be as &quot;efficient&quot; as pure ASM? For example, as fast, small and clean (meaning no junk code) as if I just used MASM32? <br /><br />Thanks!</div>
    <div class="meta">Posted on 2008-11-13 05:25:47 by Matt</div>
   </div>
   <div class="post" id="post-206303">
    <div class="subject"><a href="#post-206303">Re: Some Assembly Questions From A New Programmer</a></div>
    <div class="body">Objects are junks. Any object oriented language adds &quot;junk&quot; to your code. Code pure, code simple, code low level&nbsp; :lol: However, you must know that the efficiency of your code is mostly related to the code that you write. Not what the compiler might add to your code.</div>
    <div class="meta">Posted on 2008-11-13 06:46:38 by XCHG</div>
   </div>
   <div class="post" id="post-206304">
    <div class="subject"><a href="#post-206304">Re: Some Assembly Questions From A New Programmer</a></div>
    <div class="body">I can understand your point of view, but fortunately they are other coders that don’t see it like you.<br />The key difference from the 2 perspectives is the project scale. If you want to code a “Hello World” app, everybody will agree with you that brute assembler is the best choice in terms of size. If you intend to code something bigger and you want to base your new work on the proven code you just developed, OOP is a genuine alternative, if not the best. I agree again, that they are exceptions, but exceptions confirm the rule.<br /><br />In terms of speed, OOP isn’t necessary slower that pure assembler and… you have always the choice to mix both when you believe that you can do it better.<br /><br />There is a general misconception about OOP. In its simplest form, OOP behaves exactly like traditional procedural programming. When you add more features because you want to do some more sophisticated tasks, OOP simplifies the code making it less prone to errors.<br /><br />OOP is more complicated than brute assembler because you need to learn new rules. Unfortunately not everybody is able to learn to take benefit of it and it is good so.<br /><br />My 2 cents…<br /><br />Regards,<br /><br />Biterider<br /></div>
    <div class="meta">Posted on 2008-11-13 12:33:41 by Biterider</div>
   </div>
   <div class="post" id="post-206308">
    <div class="subject"><a href="#post-206308">Re: Some Assembly Questions From A New Programmer</a></div>
    <div class="body">As I mentioned, OA32 is little more than a bunch of macros for MASM.<br />You&#039;ll still have to get your hands dirty and use lots of &#039;pure asm&#039;.<br />However you&#039;ll be able to do things which are really difficult and hard to debug using asm alone - and you&#039;ll find it much easier to recycle your code from one project into another project.<br /><br />Imagine that an application is a house, its made from bricks.<br />Now imagine you wish to build a house.<br />Do you want to make each and every brick by hand, make sure its nice and square and fits well with all the other bricks - or would you use bricks that already exist and have been laboriously optimized?<br /><br />Now imagine you want to build ANOTHER house, of vastly different design.<br />Wouldn&#039;t it be easier (and faster) to recycle those bricks you used previously than to start making new bricks from the ground up?<br /><br />The bloat in a typical OA32 object is minimal (just a few bytes of call indirection for some kinds of methods, none if they are &#039;bound&#039; methods), and OA32 is capable of emitting linear asm just like HLA so you can see exactly what its doing and tweak the parts of the code that annoy you. Most of the OA32 macros are merely wrappers for &#039;pure asm&#039; code snippets, making your code easier to read and shorter to type, you can poke around inside them and see exactly whats in them, its all open sourced.<br /><br />Furthermore, OA32 has some really useful debugging support built into it, allowing you to emit messages at runtime, dump chunks of arbitrary memory, view strings, registers, and other goodness which you can&#039;t easily do in a typical debug environment. (Think of this as an enhancement to, not a replacement for a good debugger).<br />Also, it can detect resource leaks such as unreleased handles and objects and alert you to them. You can build your code with full, partial, or NO debug support.<br /><br />Yes, hand crafted asm will always have the edge, but that&#039;s exactly the point - 99% of your code under OA32 IS HAND CRAFTED ASM - this is where OA32 differs from any other object oriented programming environment (except one, ATC, which is no longer public).<br /><br /></div>
    <div class="meta">Posted on 2008-11-13 18:14:57 by Homer</div>
   </div>
   <div class="post" id="post-206323">
    <div class="subject"><a href="#post-206323">Re: Some Assembly Questions From A New Programmer</a></div>
    <div class="body">Thanks allot Homer and Biterider, you&#039;ve helped me more than I could imagine. I&#039;m glad you cleared everything up for me, and I think I have a better understand on what I should be learning now.<br /><br />It was mentioned that I could use my code in OOP languages (I assume &#039;Object Orientated Programming&#039;). I know you can use ASM code in Delphi (I&#039;m not sure about MASM32 or ObjAsm32), but are there any other languages which support the code? </div>
    <div class="meta">Posted on 2008-11-15 05:05:17 by Matt</div>
   </div>
   <div class="post" id="post-206324">
    <div class="subject"><a href="#post-206324">Re: Some Assembly Questions From A New Programmer</a></div>
    <div class="body">sure, a number of languages support &#039;inline asm&#039; - but this is never powerful or well featured, for example you can&#039;t generally use macros inside inline asm, it&#039;s limited to linear code, no tricks, no fun.</div>
    <div class="meta">Posted on 2008-11-15 08:51:27 by Homer</div>
   </div>
  </div>
 </body>
</html>