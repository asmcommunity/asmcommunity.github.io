<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Not going to second drive - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25992" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=25992">Not going to second drive</a></p>
   <div class="post" id="post-189425">
    <div class="subject"><a href="#post-189425">Not going to second drive</a></div>
    <div class="body">It&#39;s not going to the F: drive.<br /><br />; This code MAY contain Random PE Compression, Anti Siege Engine,<br />; and IBI(c) Technology&nbsp;  <br />;<br />;&nbsp; If you besiege a city for a long time while attempting to capture it,<br />;&nbsp; you must not chop down its trees, for you may eat fruit from them and should not<br />;&nbsp; cut them down.&nbsp; Deuteronomy 20:19&nbsp; &nbsp; <br />;<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Works thru WinXP SP2<br />;<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MUST USE tasm31.exe and tlink51.exe to compile !!<br />;<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WON&#39;T FIND FILES WITH MORE THAN A 3 CHAR EXTENSION !!<br />;<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Lengthened path to 128 characters<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Change to drive to search floppies<br />;<br />lf&nbsp; &nbsp; &nbsp; equ&nbsp; &nbsp;  0ah&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; ASCII line feed<br />cr&nbsp; &nbsp; &nbsp; equ&nbsp; &nbsp;  0dh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; ASCII carriage return<br />ff&nbsp; &nbsp; &nbsp; equ&nbsp; &nbsp;  0ch&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; ASCII form feed<br />tab&nbsp; &nbsp;  equ&nbsp; &nbsp;  09h<br />eom&nbsp; &nbsp;  equ&nbsp; &nbsp;  &#39;$&#39;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; end of message flag<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Program Segment Prefix<br />default_fcb	equ	05ch<br />command		equ	80h	 <br />default_dta	equ	080h<br /><br />; This is the format for the DOS Data Transfer Area&nbsp; <br />; searches for a file match in directories.				<br /><br />DTA	STRUC<br />	RESERVED	db	21 dup (?)<br />	ATTRIBUTE	db	0<br />	TIME		dw	0<br />	DATE		dw	0<br />	DTA_SIZE	dd	0<br />	NAME_FOUND	db	13 dup (?)<br />DTA	ENDS<br /><br />cseg	segment	para public &#39;CODE&#39;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; assume&nbsp; cs:cseg,ds:data,es:data,ss:stak<br /><br />; This is the main program that sets up the initial conditions for	<br />; SDIR which, in turn, does a recursive search.		<br />;									<br />; Reads:	PATH_NAME						<br />; Writes:	FILE_NAME						<br />; Calls:	SDIR					<br /><br />whereis	proc	far<br />&nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; ds&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; save final return<br />&nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp;  ax,ax<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; ax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  bp,sp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; save pointer to final return<br />		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 		&nbsp;  ; in case we want to exit<br />				&nbsp; &nbsp; &nbsp; &nbsp;  ; inside recursive routine<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  ax,data&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; make data segment addressable<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  es,ax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; via ES<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; clr_screen <br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; infile&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; get name of search target<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  ax,data&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; make data segment addressable<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  ds,ax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; via DS<br />&nbsp; &nbsp; &nbsp; &nbsp; jnc&nbsp; &nbsp;  short whereis2&nbsp;  ; jump if filename was ok<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; filename was missing,<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp;  dx,offset msg1&nbsp; &nbsp;  ; print error message and exit<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp;  ah,9<br />&nbsp; &nbsp; &nbsp; &nbsp; int&nbsp;  21h<br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br /><br />whereis2:<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  di,offset PATH_NAME<br />&nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp;  al,al&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Search for the zero at the end<br />&nbsp; &nbsp; &nbsp; &nbsp; cld&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; of PATH_NAME<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  cx,128&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Max path length<br />&nbsp; &nbsp; &nbsp; &nbsp; repnz&nbsp;  scasb<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  bx,di<br />&nbsp; &nbsp; &nbsp; &nbsp; dec&nbsp; &nbsp;  bx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; DS:BX points to end of PATH_NAME<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  dx,0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Tell SDIR this is first<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; SDIR&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Now do the recursive search<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  ax,match_count&nbsp; &nbsp; &nbsp; ; were any matches found?<br />&nbsp; &nbsp; &nbsp; &nbsp; or&nbsp; &nbsp; &nbsp; ax,ax<br />&nbsp; &nbsp; &nbsp; &nbsp; jz&nbsp; &nbsp; &nbsp; whereis8&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; no,jump<br />&nbsp; &nbsp; &nbsp; &nbsp; ret&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; yes,just exit<br /><br />whereis8:<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp;  dx,offset msg2&nbsp; &nbsp; &nbsp; ; no, print &quot;no match&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp;  ah,9<br />&nbsp; &nbsp; &nbsp; &nbsp; int&nbsp;  21h<br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; this is a special crash<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; exit, which may be taken<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; from inside recursed proc.<br />whereis9:<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp;  sp,bp<br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br /><br />whereis	endp<br /><br />clr_screen&nbsp; &nbsp; &nbsp; proc&nbsp; &nbsp; near&nbsp; &nbsp; ; clear screen using direct video writes<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; faster than DOS functions<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; &nbsp; &nbsp; ax<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; &nbsp; &nbsp; es <br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  ax,0b800h&nbsp;  ; Start at memory 0b800<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  es,ax<br />&nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp; &nbsp; &nbsp;  di,di<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  cx,2000&nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp; &nbsp;  ax,0720h&nbsp; &nbsp; ; Black bg, white fg, 20h = space char<br />&nbsp; &nbsp; &nbsp; &nbsp; rep&nbsp; &nbsp; &nbsp; &nbsp;  stosw<br />&nbsp; &nbsp; &nbsp; &nbsp; pop&nbsp; &nbsp; &nbsp; &nbsp;  ax<br />&nbsp; &nbsp; &nbsp; &nbsp; pop&nbsp; &nbsp; &nbsp; &nbsp;  es<br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br /><br />clr_screen&nbsp; &nbsp; &nbsp; endp<br /><br />;&nbsp; This procedure searches all the files in the current directory	<br />;&nbsp; looking for a match.&nbsp; It also prints the full name for each match. <br />;									<br />;&nbsp;  DS:BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Pointer to end of current path name&nbsp; &nbsp; &nbsp; <br />;&nbsp;  DS:DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Old disk transfer area (DTA)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />;									<br />; Reads:	Disk Transfer Area (DTA)				<br />; Writes:	Disk Transfer Area (DTA)				<br />; Calls:	BUILD_NAME, FMATCH, PNAME		<br />;		NMATCH, BUILD_STAR_NAME, SSUB	<br /><br />SDIR	PROC	NEAR<br /><br />	PUSH	SI			; Need to restore on exit<br />	PUSH	DX<br />	CALL	BUILD_NAME		; Build the absolute search name<br />	CALL	FMATCH			; See if there is a match here<br />	JC	sdir2 			; No match, check subdirectories<br /><br />	CALL	PNAME			; Write name of match.<br />sdir1:<br />	CALL	NMATCH			; Find the next match<br />	JC	sdir2			; No match, search sub-directories<br /><br />	CALL	PNAME			; Match, write absolute name<br />	JMP	sdir1			; Look for the next matching name<br /><br />sdir2:					; No match, so try sub-directories.<br />	POP	DX			; Restore DTA<br />	PUSH	DX<br />	CALL	BUILD_STAR_NAME		; Search for all directories<br />	CALL	FMATCH			; Get first entry<br />	JC	SDIR5			; There are no entries<br />	MOV	SI,DX			; Put address of DTA into SI<br />	TEST	.ATTRIBUTE,10H	; Is it a directory entry?<br />	JNZ	SDIR4			; Yes, then search sub-directory<br />SDIR3:<br />	CALL	NMATCH			; No, then find the next match<br />	JC	SDIR5			; There are no more entries<br />	TEST	.ATTRIBUTE,10H	; Is this a directory?<br />	JZ	SDIR3			; No, then try again<br />SDIR4:<br />	CMP	.NAME_FOUND,&#39;.&#39;	; Is this a . or .. directory?<br />	JE	SDIR3			; Yes, skip to next directory<br />	CALL	SSUB			; Search the sub-directory<br />	PUSH	AX			; Now reset the DTA<br />	MOV	AH,1AH<br />	INT	21H<br />	POP	AX<br />	JMP	SDIR3<br />SDIR5:<br />	POP	DX<br />	POP	SI<br />	RET<br /><br />SDIR	ENDP<br /><br />; This procedure searches the subdirectory whose name is in the DTA <br />;						<br />;&nbsp; &nbsp; &nbsp;  DS:BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  End of the current path name&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />;	DS:.NAME_FOUND	Name of subdirectory for search		<br />; Reads:	PATH_NAME						<br />; Writes:	PATH_NAME						<br />; Calls:	SDIR					<br /><br />SSUB	PROC	NEAR<br /><br />	PUSH	DI<br />	PUSH	SI<br />	PUSH	AX<br />	PUSH	BX<br />	CLD				; Set for increment<br />	MOV	SI,DX			; Put address of DTA into SI<br />	ADD	SI,OFFSET NAME_FOUND	; Set to start of sub-directory name<br />	MOV	DI,BX			; DS:DI -- 0 at end of path name<br /><br />ssub1:					; Copy sub-directory to path name<br />	LODSB				; Copy one character<br />	STOSB<br />	OR	AL,AL			; Was it a 0?<br />	JNZ	ssub1			; No, keep copying<br />	MOV	BX,DI			; Set BX to end of new path name<br />	STD				; Set flag for decrement<br />	STOSB				; Store a 0 at end of string<br />	MOV	AL,&#39;\&#39;<br />	STOSB				; Place &#39;\&#39; at end of path name<br />	CALL	SDIR			; Search this new path<br />	POP	BX			; Restore the old end-of-path<br />	MOV	BYTE PTR ,0		; And store a zero here<br />	POP	AX<br />	POP	SI<br />	POP	DI<br />	RET<br /><br />SSUB	ENDP<br /><br />; This procedure prints the matched name after the path name		<br />;<br />; DS:DX&nbsp; &nbsp;  Pointer to current disk transfer area&nbsp; &nbsp; <br />;									<br />; Reads:	PATH_NAME, NAME_FOUND (in DTA)				<br />; Calls:	pasciiz, CRLF					<br /><br />PNAME	PROC	NEAR<br /><br />	PUSH	AX<br />	PUSH	DX<br />&nbsp;  MOV&nbsp; &nbsp;  DX,OFFSET PATH_NAME<br />&nbsp;  MOV&nbsp; &nbsp;  AL,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Save character at end of path<br />&nbsp;  MOV&nbsp; &nbsp;  BYTE PTR ,0&nbsp; &nbsp; &nbsp; &nbsp;  ; Set for end of string <br />&nbsp;  CALL	pasciiz<br />&nbsp;  MOV&nbsp; &nbsp;  ,AL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Restore character<br />&nbsp;  POP&nbsp; &nbsp;  DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Recover old pointer<br />&nbsp;  PUSH	DX<br />&nbsp;  ADD	DX,OFFSET NAME_FOUND<br />&nbsp;  CALL	pasciiz<br />&nbsp;  CALL&nbsp; &nbsp; CRLF<br />&nbsp;  ; pause at each screenful of files found<br />&nbsp;  inc&nbsp; &nbsp;  match_count&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; count names displayed<br /><br />&nbsp;  push	ax<br />&nbsp;  push	bx<br />&nbsp;  mov	ax,match_count<br />&nbsp;  mov	dx,0<br />&nbsp;  mov&nbsp; &nbsp;  cx,18h&nbsp; &nbsp; &nbsp; &nbsp; ; 18h = 24 decimal<br />&nbsp;  div&nbsp; &nbsp;  cx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ax/cx<br />&nbsp;  and&nbsp; &nbsp;  dx,dx&nbsp; &nbsp; &nbsp; &nbsp;  ; any bits set to 1 indicate a remainder,<br />&nbsp;  jnz&nbsp; &nbsp;  PNAME9&nbsp; &nbsp; &nbsp; &nbsp; ; so pause and display a message<br /><br />	mov	dx,offset Press_a_Key1&nbsp; <br />	mov	ah,09h<br />	int	21h<br /><br />	mov	ah,08h<br />	int	21h<br /><br />	mov	dx,offset Press_a_Key2<br />	mov	ah,09h<br />	int	21h<br /><br />PNAME9:<br />	pop	bx<br />	pop	ax<br /><br />	POP	DX<br />&nbsp;  POP&nbsp; &nbsp;  AX&nbsp; &nbsp;  <br />	RET<br />PNAME	ENDP<br /><br />;&nbsp; This procedure builds an absolute search name from PATH_NAME		<br />;&nbsp; followed by FILE_NAME.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />;									<br />; Reads:	FILE_NAME						<br />; Calls:	BUILD		to build the name			<br /><br />BUILD_NAME	PROC	NEAR<br />	PUSH	SI<br />	MOV	SI,OFFSET FILE_NAME<br />	CALL	BUILD<br />	POP	SI<br />	RET<br />BUILD_NAME	ENDP<br /><br />BUILD_STAR_NAME		PROC	NEAR<br />	PUSH	SI<br />	MOV	SI,OFFSET STAR_NAME<br />	CALL	BUILD<br />	POP	SI<br />	RET<br />BUILD_STAR_NAME		ENDP<br /><br />; This procedure appends the string at DS:SI to PATH_NAME in		<br />; PATH_NAME.&nbsp; It knows where the path name ends from knowing how	<br />; long PATH_NAME is.							<br />;									<br />;	DS:SI		Name of file					<br />;	DS:BX		End of PATH_NAME				<br />;									<br />; Reads:	DS:SI							<br />; Writes:	PATH_NAME						<br /><br />BUILD	PROC	NEAR<br />	PUSH	AX<br />	PUSH	DI<br />	MOV	DI,BX<br />&nbsp;  CLD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Set direction for increment<br /><br />build1:<br />&nbsp;  LODSB&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Copy one character of name<br />&nbsp;  STOSB<br />&nbsp;  OR&nbsp; &nbsp; &nbsp; AL,AL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; End of string yet?<br />&nbsp;  JNZ&nbsp; &nbsp;  build1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; No, keep copying<br />	POP	DI<br />	POP	AX<br />	RET<br />BUILD	ENDP<br /><br />;&nbsp; This procedure finds the first match between the name given by	<br />;&nbsp; DS:DX and the directory entries found in the directory PATH_NAME.	<br />;									<br />;&nbsp; DS:DX		Pointer to current disk transfer area		<br />; Returns:								<br />;	CF	0	A match was found				<br />;		1	No match found					<br />;	AX		Error code returned:				<br />;		2	File not found					<br />;		18	No more files					<br />;	DS:DX		Pointer to new disk transfer area		<br />;									<br />; Reads:	PATH_NAME						<br />; Writes:	dbuff<br /><br />FMATCH	PROC	NEAR<br />	PUSH	CX<br />&nbsp;  CMP&nbsp; &nbsp;  DX,0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; First one?<br />&nbsp;  JA&nbsp; &nbsp; &nbsp; allocate&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; No, then allocate space<br />	MOV	DX,OFFSET dbuff-TYPE DTA<br />allocate:<br />&nbsp;  add&nbsp; &nbsp;  dx,type DTA&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; no, then allocate room for new DTA<br /><br />;&nbsp;  Bitfields for file attributes:<br />;Bit(s)	Description	(Table 01420)<br />; 7	shareable (Novell NetWare)<br />; 7	pending deleted files (Novell DOS, OpenDOS)<br />; 6	unused<br />; 5	archive<br />; 4	directory<br />; 3	volume label<br />;	execute-only (Novell NetWare)<br />; 2	system<br />; 1	hidden<br />; 0	read-only<br /><br />&nbsp;  mov&nbsp; &nbsp;  cx,00010111b&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; search for ALL files and dirs<br />&nbsp;  MOV&nbsp; &nbsp;  AH,1AH&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Set disk transfer address<br />&nbsp;  INT&nbsp; &nbsp;  21H<br />&nbsp;  PUSH&nbsp; &nbsp; DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Need DX for address of search name<br />&nbsp;  MOV&nbsp; &nbsp;  DX,OFFSET PATH_NAME<br />&nbsp;  MOV&nbsp; &nbsp;  AH,4EH&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Call for &quot;find first match&quot;<br />&nbsp;  INT&nbsp; &nbsp;  21H<br />&nbsp;  POP&nbsp; &nbsp;  DX<br />&nbsp;  POP&nbsp; &nbsp;  CX<br />&nbsp;  RET&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Return with carry flag info<br />FMATCH	ENDP<br /><br />; Get next match for filename<br />; (very similar to Get first match routine)<br /><br />; Returns:								<br />;	CF	0	A match was found				<br />;		1	No match found					<br />;	AX		Error code returned:				<br />;		2	File not found					<br />;		18	No more files					<br />;									<br />; Reads:	PATH_NAME						<br />; Writes:	dbuff					<br /><br />NMATCH	PROC	NEAR<br />	PUSH	CX<br />	PUSH	DX<br />	MOV	DX,OFFSET PATH_NAME<br />&nbsp;  MOV&nbsp; &nbsp;  CX,10H&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Attribute for files and directories<br />&nbsp;  MOV&nbsp; &nbsp;  AH,4FH&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Call for &quot;Find next match&quot;<br />	INT	21H<br />	POP	DX<br />	POP	CX<br />&nbsp;  RET&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Return with carry flag intact<br />NMATCH	ENDP<br /><br />;&nbsp;  Send CRLF sequence to the screen. <br /><br />CRLF	PROC	NEAR<br />	PUSH	AX<br />	PUSH	DX<br />	MOV	AH,02<br />	MOV	DL,0AH<br />	INT	21H<br />	MOV	DL,0DH<br />	INT	21H<br />	POP	DX<br />	POP	AX<br />	RET<br />CRLF	ENDP<br /><br />;&nbsp; Display ASCIIZ string <br />;&nbsp; Call with DS:DX = string addr<br /><br />pasciiz	PROC	NEAR<br />	PUSH	AX<br />	PUSH	DX<br />	PUSH	SI<br />&nbsp;  CLD&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Set direction for increment<br />&nbsp;  MOV&nbsp; &nbsp;  SI,DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Set up pointer to string<br />	MOV	AH,2<br /><br />pasciiz1:<br />&nbsp;  LODSB&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Get character<br />&nbsp;  or&nbsp; &nbsp; &nbsp; al,al&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; if zero,all done<br />	jz	pasciiz2<br />	MOV	DL,AL<br />&nbsp;  INT&nbsp; &nbsp;  21H&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Write one character<br />&nbsp;  jmp&nbsp; &nbsp;  pasciiz1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; loop till string exhausted<br /><br />pasciiz2:<br />	POP	SI<br />	POP	DX<br />	POP	AX<br />	RET<br />pasciiz	ENDP<br /><br />infile&nbsp; proc&nbsp; &nbsp; near&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; process name of input file<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; DS:SI &lt;- addr command line <br />	mov	si,offset command<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ES:DI &lt;- addr filespec buffer<br />	mov	di,offset FILE_NAME<br />	cld<br />&nbsp;  lodsb&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; any command line present?<br />&nbsp;  or&nbsp; &nbsp; &nbsp; al,al&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; return error status if not.<br />	jz	infile4<br /><br />infile1:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; scan over leading blanks<br />&nbsp;  lodsb&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; to file name<br />&nbsp;  cmp&nbsp; &nbsp;  al,cr&nbsp; &nbsp; &nbsp; &nbsp;  ; if we hit carriage return<br />&nbsp;  jz&nbsp; &nbsp; &nbsp; infile4&nbsp; &nbsp; &nbsp;  ; filename is missing.<br /><br />&nbsp;  cmp&nbsp; &nbsp;  al,20h&nbsp; &nbsp; &nbsp; &nbsp; ; is this a blank?<br />&nbsp;  jz&nbsp; &nbsp; &nbsp; infile1&nbsp; &nbsp; &nbsp;  ; if so keep scanning.<br /><br />&nbsp;  xor&nbsp; &nbsp;  ah,ah&nbsp; &nbsp; &nbsp; &nbsp;  ; reset &quot;.&quot; found flag<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; found first char of name<br />infile2: 			<br /><br />&nbsp;  cmp&nbsp; &nbsp;  al,&#39;\&#39;&nbsp; &nbsp; &nbsp; &nbsp; ; if slash,reset &quot;.&quot; flag<br />	jne	infile22<br />&nbsp;  xor&nbsp;  ah,ah<br /><br />infile22:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; check if extension specified<br /><br />	cmp	al,&#39;.&#39;<br />	jne	infile24<br />	inc	ah<br /><br />infile24:<br />&nbsp;  stosb&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; move last char. to output<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; file name buffer. <br />&nbsp;  lodsb&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; check next character, found<br />&nbsp;  cmp&nbsp; &nbsp;  al,cr&nbsp; &nbsp; &nbsp; &nbsp;  ; carriage return yet?&nbsp;  <br />&nbsp;  je&nbsp; &nbsp; &nbsp; infile3&nbsp; &nbsp; &nbsp;  ; yes,exit with success code<br /><br />&nbsp;  cmp&nbsp; &nbsp;  al,&#39;/&#39;&nbsp; &nbsp; &nbsp; &nbsp; ; or if we hit a switch delimiter<br />&nbsp;  jne infile26<br /><br />infile25:<br />&nbsp;  lodsb&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; get the switch char and save it<br />&nbsp;  or&nbsp; &nbsp; &nbsp; al,20h&nbsp; &nbsp; &nbsp; &nbsp; ; force to lower case<br />&nbsp;  mov byte ptr es:switch,al<br />&nbsp;  jmp&nbsp; &nbsp;  infile3&nbsp; &nbsp; &nbsp;  ; then jump to finish up<br /><br />infile26:<br />&nbsp;  cmp&nbsp; &nbsp;  al,20h&nbsp; &nbsp; &nbsp; ; is this a blank?<br />&nbsp;  jne&nbsp; &nbsp;  infile2&nbsp; &nbsp;  ; if not keep moving chars.<br /><br />infile27:<br />&nbsp;  lodsb&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; search up to end, in case of switch<br />&nbsp;  cmp al,&#39;/&#39;<br />&nbsp;  je&nbsp; &nbsp; &nbsp; infile25&nbsp; &nbsp; ; found switch,go save it<br /><br />&nbsp;  cmp al,cr<br />&nbsp;  jne&nbsp; &nbsp;  infile27&nbsp; &nbsp; ; otherwise, fscan until CR found<br /><br />infile3:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; found end of input name<br />&nbsp;  or&nbsp; &nbsp; &nbsp; ah,ah&nbsp; &nbsp; &nbsp;  ; was &quot;.&quot; found?<br />&nbsp;  jnz&nbsp; &nbsp;  infile35&nbsp; &nbsp; ; yes,jump<br /><br />&nbsp;  mov&nbsp; &nbsp;  al,&#39;.&#39;&nbsp; &nbsp; &nbsp; ; no,force ext to wildcard<br />&nbsp;  stosb<br />&nbsp;  mov&nbsp; &nbsp;  al,&#39;*&#39;<br />&nbsp;  stosb<br /><br />infile35:<br />&nbsp;  xor&nbsp; &nbsp;  al,al&nbsp; &nbsp; &nbsp;  ; store trailing null byte<br />&nbsp;  stosb&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; exit with CY=0 as success flag<br />&nbsp;  clc&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp;  ret<br /><br />infile4:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; exit with carry =1<br />&nbsp;  stc&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; for error flag<br />	ret<br />infile&nbsp; endp <br /><br />cseg	ends<br /><br />data 		segment para public &#39;DATA&#39;<br /><br />STAR_NAME	db	&#39;*.*&#39;,0<br /><br />PATH_NAME&nbsp; &nbsp; &nbsp;  db&nbsp; &nbsp; &nbsp; &#39;f:\&#39;,0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db&nbsp; &nbsp; &nbsp; 131 dup (0)&nbsp;  ; Space for 128 character path name<br /><br />FILE_NAME&nbsp; &nbsp; &nbsp;  db&nbsp; &nbsp; &nbsp; 13 dup (0)&nbsp; &nbsp; ; Save room for full DOS file name<br /><br />msg1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db&nbsp; &nbsp; &nbsp; cr,lf<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db&nbsp; &nbsp; &nbsp; &#39;&nbsp; &nbsp;  WHERE&nbsp; Fast File Finder&nbsp; (c) Copyright Andrew Kennedy 2004&#39;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db&nbsp; &nbsp; &nbsp; cr,lf<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db&nbsp; &nbsp; &nbsp; cr,lf<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db&nbsp; &nbsp; &nbsp; &#39;&nbsp; &nbsp;  WHERE *.asm&#39;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db&nbsp; &nbsp; &nbsp; cr,lf<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db&nbsp; &nbsp; &nbsp; cr,lf<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db&nbsp; &nbsp; &nbsp; &#39;&nbsp; &nbsp;  Hit CTRL C to end search.&#39;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db	&nbsp; &nbsp; cr,lf,eom<br /><br />msg2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db&nbsp; &nbsp; &nbsp; &nbsp; cr,lf<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db&nbsp; &nbsp; &nbsp; &nbsp; &#39;No match found.&#39;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db&nbsp; &nbsp; &nbsp; &nbsp; cr,lf,eom<br /><br />Press_a_Key1&nbsp; &nbsp; db&nbsp; &nbsp; &nbsp; &nbsp; &#39;-- Press a key --&#39;,eom<br />Press_a_Key2&nbsp; &nbsp; db&nbsp; &nbsp; &nbsp; &nbsp; cr,&#39;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &#39;,cr,eom<br /><br />match_count&nbsp; &nbsp;  dw&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; &nbsp;  ; number of filenames matching<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; input filespec<br /><br />switch&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; &nbsp;  ; char following / saved here<br /><br />dbuff&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  equ&nbsp; &nbsp;  $&nbsp; &nbsp; &nbsp; &nbsp;  ; this starts the scratch area<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; which will be used as search<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; buffers. It is right under<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; the stack, which is made very<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; large to give it room.<br />data		ends <br /><br />stak&nbsp;  segment para stack &#39;STACK&#39; ; large stack for increased speed<br />	db	32768 dup (?)<br />stak&nbsp;  ends<br /><br />end&nbsp; &nbsp;  whereis<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br /><br /></div>
    <div class="meta">Posted on 2007-05-30 17:04:40 by skywalker</div>
   </div>
  </div>
 </body>
</html>