<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Editable button - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20133" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=20133">Editable button</a></p>
   <div class="post" id="post-154225">
    <div class="subject"><a href="#post-154225">Editable button</a></div>
    <div class="body">Today (2 hours ago) I was playing with buttons and the result was the code pasted here. The idea is good (was born while I was playing with Blender 3D (3 hours ago)). And in a while, I will be playing the &quot;try sleeping&quot; thing. Maybe the code gives some ideas to somebody.<br /><br /><pre><code><br />;Filename&#58; editbtn.asm<br />.486<br />.model flat, stdcall<br />option casemap&#58;none<br /><br />;_______________________________________________________________________________<br />;INCLUDE FILES<br /><br />      include \masm32\include\windows.inc<br />      include \masm32\include\kernel32.inc<br />      include \masm32\include\user32.inc<br />      <br />      includelib \masm32\lib\kernel32.lib<br />      includelib \masm32\lib\user32.lib<br /><br />;_______________________________________________________________________________<br />;MACROS<br /><br />      include \masm32\macros\macros.asm<br /><br />;_______________________________________________________________________________<br />;PROTOTYPES<br /><br />      WinMain proto &#58;dword,&#58;dword,&#58;dword,&#58;dword<br /><br />;_______________________________________________________________________________<br />.data<br /><br />      szClassName       db &quot;win32asmblenderbutton&quot;,0<br />      szHowItWorks      db &quot;Start editing button&#58; &#91;SHIFT&#93;+&#91;LBUTTON&#93;&quot;,13,10<br />                        db &quot;End editing button&#58; &#91;ENTER&#93; or &#91;ESC&#93;&quot;,0<br /><br />;_______________________________________________________________________________<br />.data?<br /><br />      hInstance         HINSTANCE ?<br />      hwnd              HWND ?<br />      oldButtonProc     dword ?<br />      hBlenderButton1   dword ?<br />      hBlenderButton2   dword ?<br />      hBlenderButton3   dword ?<br />      hBlenderButton4   dword ?<br />      hBlenderButton5   dword ?<br />      <br />;_______________________________________________________________________________<br />.code<br /><br />;===============================================================================<br />;WinMain &#40;hInst, hPrevIns, CmdLine, CmdShow&#41;<br />;===============================================================================<br />WinMain proc hInst&#58;HINSTANCE, hPrevIns&#58;HINSTANCE, CmdLine&#58;LPSTR, CmdShow&#58;DWORD<br />      LOCAL wc&#58;WNDCLASSEX<br />      LOCAL msg&#58;MSG<br /><br />      ;----- &#91;register superclass button &#40;Blender style button&#41;&#93; -----<br />      mov         wc.cbSize,sizeof WNDCLASSEX<br />      invoke      GetClassInfoEx, NULL, CADD&#40;&quot;BUTTON&quot;&#41;,addr wc<br />      push        wc.lpfnWndProc<br />      pop         oldButtonProc<br />      mov         wc.lpfnWndProc, offset ButtonProc<br />      push        hInst<br />      pop         wc.hInstance<br />      mov         wc.lpszClassName, CTXT&#40;&quot;BLENDERBUTTON&quot;&#41;<br />      invoke      RegisterClassEx, addr wc<br /><br />      ;----- &#91;register our app&#93; -----<br />      mov         wc.style, CS_HREDRAW or CS_VREDRAW<br />      mov         wc.cbClsExtra, NULL<br />      mov         wc.cbWndExtra, NULL<br />      mov         wc.lpfnWndProc, offset WndProc<br />      push        hInst<br />      pop         wc.hInstance<br />      mov         wc.lpszClassName, offset szClassName<br />      mov         wc.lpszMenuName, NULL<br />      mov         wc.hbrBackground, COLOR_WINDOW<br />      invoke      LoadIcon, NULL, IDI_APPLICATION<br />      mov         wc.hIcon, eax<br />      mov         wc.hIconSm, NULL<br />      invoke      LoadCursor, NULL, IDC_ARROW<br />      mov         wc.hCursor, eax<br />      invoke      RegisterClassEx, addr wc<br />      invoke      CreateWindowEx, NULL, addr szClassName, CADD&#40;&quot;Testing an editable button &#40;by Kecol&#41;&quot;&#41;,\<br />                        WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT,\<br />                        CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInst, NULL<br />      mov         hwnd, eax<br />      invoke      ShowWindow, hwnd, CmdShow<br />      invoke      UpdateWindow, hwnd<br />      .WHILE TRUE<br />            invoke      GetMessage, addr msg, NULL, 0, 0<br />            .BREAK .IF &#40;!eax&#41;<br />            invoke      TranslateMessage, addr msg<br />            invoke      DispatchMessage, addr msg<br />      .ENDW<br />      mov         eax, msg.wParam<br />      ret<br />WinMain endp<br /><br />;===============================================================================<br />;WndProc &#40;hWnd, uMsg, wParam, lParam&#41;<br />;===============================================================================<br />WndProc proc hWnd&#58;HWND, uMsg&#58;UINT, wParam&#58;WPARAM, lParam;LPARAM<br />      LOCAL _buffer&#91;256&#93;&#58;byte<br />      <br />      .IF uMsg == WM_CREATE<br />            invoke      CreateWindowEx, NULL, CADD&#40;&quot;BLENDERBUTTON&quot;&#41;, CADD&#40;&quot;Click me with SHIFT key down&quot;&#41;,\<br />                              WS_CHILD or WS_VISIBLE, 10, 50, 400, 100, hWnd, 500, hInstance, NULL<br />            mov         hBlenderButton1, eax<br />            <br />            invoke      CreateWindowEx, NULL, CADD&#40;&quot;BLENDERBUTTON&quot;&#41;, CADD&#40;&quot;button 2&quot;&#41;,\<br />                              WS_CHILD or WS_VISIBLE, 500, 400, 120, 20, hWnd, 501, hInstance, NULL<br />            mov         hBlenderButton2, eax<br /><br />            invoke      CreateWindowEx, NULL, CADD&#40;&quot;BLENDERBUTTON&quot;&#41;, CADD&#40;&quot;button 3&quot;&#41;,\<br />                              WS_CHILD or WS_VISIBLE, 100, 300, 160, 30, hWnd, 502, hInstance, NULL<br />            mov         hBlenderButton3, eax<br /><br />            invoke      CreateWindowEx, NULL, CADD&#40;&quot;BLENDERBUTTON&quot;&#41;, CADD&#40;&quot;button 4&quot;&#41;,\<br />                              WS_CHILD or WS_VISIBLE, 600, 100, 100, 20, hWnd, 503, hInstance, NULL<br />            mov         hBlenderButton4, eax<br /><br />            invoke      CreateWindowEx, NULL, CADD&#40;&quot;BLENDERBUTTON&quot;&#41;, CADD&#40;&quot;button 5&quot;&#41;,\<br />                              WS_CHILD or WS_VISIBLE, 300, 270, 200, 30, hWnd, 504, hInstance, NULL<br />            mov         hBlenderButton5, eax<br /><br />            invoke      MessageBox, hWnd, addr szHowItWorks, CADD&#40;&quot;How it works&quot;&#41;, MB_OK<br /><br />      .ELSEIF uMsg == WM_COMMAND<br />            mov         eax, wParam<br />            .IF ax &gt;= 500 &amp;&amp; ax &lt;=504<br />                  invoke      GetWindowText, lParam, addr _buffer, 255<br />                  mov         _buffer&#91;255&#93;, 0<br />                  invoke      MessageBox, hWnd, addr _buffer, CADD&#40;&quot;Button is Talking!!!&quot;&#41;, MB_OK<br />            .ENDIF<br />      .ELSEIF uMsg == WM_CLOSE<br />            invoke      DestroyWindow, hBlenderButton1<br />            invoke      DestroyWindow, hBlenderButton2<br />            invoke      DestroyWindow, hBlenderButton3<br />            invoke      DestroyWindow, hBlenderButton4<br />            invoke      DestroyWindow, hBlenderButton5<br />            invoke      PostQuitMessage, NULL<br />            ret<br />      .ELSE<br />            invoke      DefWindowProc, hWnd, uMsg, wParam, lParam<br />            ret<br />      .ENDIF<br /><br />      xor         eax, eax<br />      ret<br />WndProc endp<br /><br />;===============================================================================<br />;ButtonProc&#40;hWnd, uMsg, wParam, lParam&#41;<br />;===============================================================================<br />ButtonProc proc hWnd&#58;HWND, uMsg&#58;UINT, wParam&#58;WPARAM, lParam&#58;LPARAM<br />      LOCAL _buffer&#91;256&#93;&#58;byte<br />      LOCAL point&#58;POINT<br />      LOCAL hParent&#58;HWND<br />      LOCAL hEdit&#58;HWND<br />      LOCAL msg&#58;MSG<br />      LOCAL rect&#58;RECT<br />      LOCAL _width&#58;dword<br />      LOCAL _height&#58;dword<br />      <br />      ;----- &#91;WM_LBUTTONUP is the only message that need be intercepted&#93; -----<br />      ;----- &#91;and it works only if SHIFT KEY IS DOWN&#93; -----<br /><br />      .IF uMsg==WM_LBUTTONUP &amp;&amp; wParam == MK_SHIFT<br /><br />            invoke      GetWindowText, hWnd, addr _buffer, 255    ;save the text to be<br />            mov         _buffer&#91;255&#93;, 0                           ;used in edit control.<br />            invoke      ShowWindow, hWnd, SW_HIDE                 ;hide button.<br />            mov         hParent, FUNC &#40;GetParent, hWnd&#41;           ;get button parent.<br />            invoke      GetWindowRect, hWnd, addr rect            ;get button screen pos<br />            mov         eax, rect.right                           ;and transform it<br />            sub         eax, rect.left          ;width            ;to client ones.<br />            mov         _width, eax<br />            mov         eax, rect.bottom<br />            sub         eax, rect.top           ;height<br />            mov         _height, eax<br />            invoke      ScreenToClient, hParent, addr rect<br /><br />            ;----- &#91;Create an EDIT control in button place with button text&#93; -----<br /><br />            invoke      CreateWindowEx,\<br />                              NULL, CADD&#40;&quot;EDIT&quot;&#41;, addr _buffer,\<br />                              WS_CHILD + WS_VISIBLE + WS_BORDER + ES_CENTER,\<br />                              rect.left, rect.top, _width, _height,\<br />                              hParent, NULL, hInstance, NULL<br />            mov         hEdit, eax<br />            invoke      ShowWindow, hEdit, SW_NORMAL              ;show edit control<br />            invoke      SetFocus, hEdit                           ;set focus in it<br />            invoke      SendMessage, hEdit, EM_SETSEL, 0, -1<br />            ;----- &#91;empty queue processing the remaining messages&#93; -----<br /><br />            .WHILE TRUE<br />                  invoke      PeekMessage, addr msg, hParent, 0, 0, PM_REMOVE<br />                  .BREAK .IF eax == 0                             ;empty queue<br />                  invoke      TranslateMessage, addr msg<br />                  invoke      DispatchMessage, addr msg<br />            .ENDW<br /><br />            ;----- &#91;queue is empty and now I can process only hEdit message&#93; -----<br />            ;----- &#91;exit from loop only if ENTER or ESC are pressed&#93; -----<br /><br />            .WHILE TRUE<br />                  invoke      GetMessage, addr msg, NULL, 0, 0<br />                  mov         eax, msg.hwnd<br />                  .IF eax == hEdit<br />                        .IF msg.message == WM_KEYDOWN<br />                              .IF msg.wParam == VK_RETURN<br />                                    mov   eax, TRUE<br />                                    .BREAK<br />                              .ELSEIF msg.wParam==VK_ESCAPE<br />                                    mov   eax, FALSE<br />                                    .BREAK<br />                              .ENDIF<br />                        .ENDIF<br />                        invoke      TranslateMessage, addr msg<br />                        invoke      DispatchMessage, addr msg<br />                  .ENDIF<br />            .ENDW<br />            ;----- &#91;if&#40;eax&#41; set new text in button&#93; -----<br />            .IF eax == TRUE<br />                  invoke      GetWindowText, hEdit, addr _buffer, 255<br />                  mov         _buffer&#91;255&#93;, 0<br />                  .IF eax != 0<br />                        invoke      SetWindowText, hWnd, addr _buffer<br />                        ;here can go a routine to send hParent window that<br />                        ;the text was changed. EXAMPLE&#58;<br />                        ;invoke     GetWindowLong, hWnd, GWL_ID<br />                        ;mov        edx, 12345        ;text was changed msg<br />                        ;shl        edx, 16<br />                        ;or         edx, eax        <br />                        ;invoke     SendMessage, hParent, WM_COMMAND, eax, hWnd<br />                  .ENDIF<br />            .ENDIF<br />            invoke      ShowWindow, hWnd, SW_NORMAL   ;show the button<br />            invoke      DestroyWindow, hEdit          ;destroy edit control<br />      .ELSE<br />defproc&#58;    invoke      CallWindowProc, oldButtonProc, hWnd, uMsg, wParam, lParam<br />            ret<br />      .ENDIF<br />      xor         eax, eax<br />      ret<br />ButtonProc endp<br /><br />;===============================================================================<br />;PROGRAM START HERE<br />;===============================================================================<br />start&#58;<br />      invoke      GetModuleHandle, NULL<br />      mov         hInstance, eax<br />      invoke      WinMain, hInstance, NULL, NULL, SW_NORMAL<br />      invoke      ExitProcess, eax<br />end start<br /></code></pre><br /><br />Kecol.-</div>
    <div class="meta">Posted on 2004-12-15 23:32:24 by Kecol</div>
   </div>
   <div class="post" id="post-154230">
    <div class="subject"><a href="#post-154230">Editable button</a></div>
    <div class="body">Very nice :)<br /><br />I can't think of a specific case in which you'd use buttons like this this late at night, but I'm sure there's some application out there somewhere.</div>
    <div class="meta">Posted on 2004-12-16 01:18:06 by sirchess</div>
   </div>
   <div class="post" id="post-154234">
    <div class="subject"><a href="#post-154234">Editable button</a></div>
    <div class="body">sirchess, it's too late for me (sun is just for appearing again right now). Maybe tomorrow play again with the &quot;edit button&quot; and get a better use of it. Blender 3D use this kind of button (MUCH BETTER) in its UI (user interface).<br /><br />Thank you for reading, saving, compiling and replying.<br /><br />Kecol.-</div>
    <div class="meta">Posted on 2004-12-16 02:40:54 by Kecol</div>
   </div>
   <div class="post" id="post-154252">
    <div class="subject"><a href="#post-154252">Editable button</a></div>
    <div class="body">I have used Blender before and I remember it being very nice.<br /><br /><pre><code>;----- &#91;empty queue processing the remaining messages&#93; -----<br /><br />            .WHILE TRUE<br />                  invoke      PeekMessage, addr msg, hParent, 0, 0, PM_REMOVE<br />                  .BREAK .IF eax == 0                             ;empty queue<br />                  invoke      TranslateMessage, addr msg<br />                  invoke      DispatchMessage, addr msg<br />            .ENDW<br /><br />            ;----- &#91;queue is empty and now I can process only hEdit message&#93; -----<br />            ;----- &#91;exit from loop only if ENTER or ESC are pressed&#93; -----<br /><br />            .WHILE TRUE<br />                  invoke      GetMessage, addr msg, NULL, 0, 0<br />                  mov         eax, msg.hwnd<br />                  .IF eax == hEdit<br />                        .IF msg.message == WM_KEYDOWN<br />                              .IF msg.wParam == VK_RETURN<br />                                    mov   eax, TRUE<br />                                    .BREAK<br />                              .ELSEIF msg.wParam==VK_ESCAPE<br />                                    mov   eax, FALSE<br />                                    .BREAK<br />                              .ENDIF<br />                        .ENDIF<br />                        invoke      TranslateMessage, addr msg<br />                        invoke      DispatchMessage, addr msg<br />                  .ENDIF<br />            .ENDW<br />            ;----- &#91;if&#40;eax&#41; set new text in button&#93; -----<br />            .IF eax == TRUE<br />                  invoke      GetWindowText, hEdit, addr _buffer, 255<br />                  mov         _buffer&#91;255&#93;, 0<br />                  .IF eax != 0<br />                        invoke      SetWindowText, hWnd, addr _buffer<br />                        ;here can go a routine to send hParent window that<br />                        ;the text was changed. EXAMPLE&#58;<br />                        ;invoke     GetWindowLong, hWnd, GWL_ID<br />                        ;mov        edx, 12345        ;text was changed msg<br />                        ;shl        edx, 16<br />                        ;or         edx, eax       <br />                        ;invoke     SendMessage, hParent, WM_COMMAND, eax, hWnd<br />                  .ENDIF<br />            .ENDIF</code></pre><br /><br />This code is only letting editbox messages be processed while in &quot;button-edit&quot; mode (at least on WinXP); was this planned, or something that needs to be fixed?  Also, if the program using your button was doing some special processing during their message loop, that processing wouldn't occur while button-editing.<br /><br />There must be some good way to get the WM_KEYDOWN message without overlaying the main message loop, but how?  Maybe a function called during the main loop?<br /><br />I played with it a little, here is what I got (apparently no attachments on the board at this time?):<br /><br /><pre><code><br />;Filename&#58; editbtn.asm<br />.486<br />.model flat, stdcall<br />option casemap&#58;none<br /><br />;_______________________________________________________________________________<br />;INCLUDE FILES<br /><br />      include \masm32\include\windows.inc<br />      include \masm32\include\kernel32.inc<br />      include \masm32\include\user32.inc<br />     <br />      includelib \masm32\lib\kernel32.lib<br />      includelib \masm32\lib\user32.lib<br /><br />;_______________________________________________________________________________<br />;MACROS<br /><br />      include \masm32\macros\macros.asm<br /><br />;_______________________________________________________________________________<br />;PROTOTYPES<br /><br />      WinMain proto &#58;dword,&#58;dword,&#58;dword,&#58;dword<br />      ProcessBtn proto &#58;dword<br />      <br />;_______________________________________________________________________________<br />;EQUATES<br /><br />      ; Flags a BlenderBtnEdit when &lt;ENTER&gt; or &lt;ESC&gt; is pressed in the editbox<br />      ; wParam&#58; &#40;not used&#41;        lParam&#58; TRUE - &lt;ENTER&gt;; FALSE - &lt;ESC&gt;<br />      UM_BTNEDITKEY     equ WM_USER<br />      <br />      ; Flags a BlenderButton when the edit box processes a quit msg<br />      ; wParam&#58; hEdit        lParam&#58; TRUE - &lt;ENTER&gt;; FALSE - &lt;ESC&gt;<br />      UM_BTNEDITEXIT    equ WM_USER+1<br /><br />;_______________________________________________________________________________<br />.data<br /><br />      szClassName       db &quot;win32asmblenderbutton&quot;,0<br />      szHowItWorks      db &quot;Start editing button&#58; &#91;SHIFT&#93;+&#91;LBUTTON&#93;&quot;,13,10<br />                        db &quot;End editing button&#58; &#91;ENTER&#93; or &#91;ESC&#93;&quot;,0<br /><br />;_______________________________________________________________________________<br />.data?<br /><br />      hInstance         HINSTANCE ?<br />      hwnd              HWND ?<br />      oldButtonProc     dword ?<br />      oldBtnEditProc    dword ?<br />      hBlenderButton1   dword ?<br />      hBlenderButton2   dword ?<br />      hBlenderButton3   dword ?<br />      hBlenderButton4   dword ?<br />      hBlenderButton5   dword ?<br />     <br />;_______________________________________________________________________________<br />.code<br /><br />;===============================================================================<br />;WinMain &#40;hInst, hPrevIns, CmdLine, CmdShow&#41;<br />;===============================================================================<br />WinMain proc hInst&#58;HINSTANCE, hPrevIns&#58;HINSTANCE, CmdLine&#58;LPSTR, CmdShow&#58;DWORD<br />      LOCAL wc&#58;WNDCLASSEX<br />      LOCAL msg&#58;MSG<br /><br />      ;----- &#91;register superclass button &#40;Blender style button&#41;&#93; -----<br />      mov         wc.cbSize,sizeof WNDCLASSEX<br />      invoke      GetClassInfoEx, NULL, CADD&#40;&quot;BUTTON&quot;&#41;,addr wc<br />      push        wc.lpfnWndProc<br />      pop         oldButtonProc<br />      mov         wc.lpfnWndProc, offset ButtonProc<br />      push        hInst<br />      pop         wc.hInstance<br />      mov         wc.lpszClassName, CTXT&#40;&quot;BLENDERBUTTON&quot;&#41;<br />      invoke      RegisterClassEx, addr wc<br />      <br />      ;----- &#91;register superclass button &#40;Blender style button&#41;&#93; -----<br />      invoke      GetClassInfoEx, NULL, CADD&#40;&quot;EDIT&quot;&#41;,addr wc<br />      push        wc.lpfnWndProc<br />      pop         oldBtnEditProc<br />      mov         wc.lpfnWndProc, offset BtnEditProc<br />      push        hInst<br />      pop         wc.hInstance<br />      mov         wc.lpszClassName, CTXT&#40;&quot;BLENDERBTNEDIT&quot;&#41;<br />      invoke      RegisterClassEx, addr wc<br /><br />      ;----- &#91;register our app&#93; -----<br />      mov         wc.style, CS_HREDRAW or CS_VREDRAW<br />      mov         wc.cbClsExtra, NULL<br />      mov         wc.cbWndExtra, NULL<br />      mov         wc.lpfnWndProc, offset WndProc<br />      push        hInst<br />      pop         wc.hInstance<br />      mov         wc.lpszClassName, offset szClassName<br />      mov         wc.lpszMenuName, NULL<br />      mov         wc.hbrBackground, COLOR_WINDOW<br />      invoke      LoadIcon, NULL, IDI_APPLICATION<br />      mov         wc.hIcon, eax<br />      mov         wc.hIconSm, NULL<br />      invoke      LoadCursor, NULL, IDC_ARROW<br />      mov         wc.hCursor, eax<br />      invoke      RegisterClassEx, addr wc<br />      invoke      CreateWindowEx, NULL, addr szClassName, CADD&#40;&quot;Testing an editable button &#40;by Kecol&#41;&quot;&#41;,\<br />                        WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT,\<br />                        CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInst, NULL<br />      mov         hwnd, eax<br />      invoke      ShowWindow, hwnd, CmdShow<br />      invoke      UpdateWindow, hwnd<br />      .WHILE TRUE<br />            invoke      GetMessage, addr msg, NULL, 0, 0<br />            .BREAK .IF &#40;!eax&#41;<br />            invoke      ProcessBtn,addr msg<br />            invoke      TranslateMessage, addr msg<br />            invoke      DispatchMessage, addr msg<br />      .ENDW<br />      mov         eax, msg.wParam<br />      ret<br />WinMain endp<br /><br />;===============================================================================<br />;WndProc &#40;hWnd, uMsg, wParam, lParam&#41;<br />;===============================================================================<br />WndProc proc hWnd&#58;HWND, uMsg&#58;UINT, wParam&#58;WPARAM, lParam;LPARAM<br />      LOCAL _buffer&#91;256&#93;&#58;byte<br />     <br />      .IF uMsg == WM_CREATE<br />            invoke      CreateWindowEx, NULL, CADD&#40;&quot;BLENDERBUTTON&quot;&#41;, CADD&#40;&quot;Click me with SHIFT key down&quot;&#41;,\<br />                              WS_CHILD or WS_VISIBLE, 10, 50, 400, 100, hWnd, 500, hInstance, NULL<br />            mov         hBlenderButton1, eax<br />           <br />            invoke      CreateWindowEx, NULL, CADD&#40;&quot;BLENDERBUTTON&quot;&#41;, CADD&#40;&quot;button 2&quot;&#41;,\<br />                              WS_CHILD or WS_VISIBLE, 500, 400, 120, 20, hWnd, 501, hInstance, NULL<br />            mov         hBlenderButton2, eax<br /><br />            invoke      CreateWindowEx, NULL, CADD&#40;&quot;BLENDERBUTTON&quot;&#41;, CADD&#40;&quot;button 3&quot;&#41;,\<br />                              WS_CHILD or WS_VISIBLE, 100, 300, 160, 30, hWnd, 502, hInstance, NULL<br />            mov         hBlenderButton3, eax<br /><br />            invoke      CreateWindowEx, NULL, CADD&#40;&quot;BLENDERBUTTON&quot;&#41;, CADD&#40;&quot;button 4&quot;&#41;,\<br />                              WS_CHILD or WS_VISIBLE, 600, 100, 100, 20, hWnd, 503, hInstance, NULL<br />            mov         hBlenderButton4, eax<br /><br />            invoke      CreateWindowEx, NULL, CADD&#40;&quot;BLENDERBUTTON&quot;&#41;, CADD&#40;&quot;button 5&quot;&#41;,\<br />                              WS_CHILD or WS_VISIBLE, 300, 270, 200, 30, hWnd, 504, hInstance, NULL<br />            mov         hBlenderButton5, eax<br /><br />            invoke      MessageBox, hWnd, addr szHowItWorks, CADD&#40;&quot;How it works&quot;&#41;, MB_OK<br /><br />      .ELSEIF uMsg == WM_COMMAND<br />            mov         eax, wParam<br />            .IF ax &gt;= 500 &amp;&amp; ax &lt;=504<br />                  invoke      GetWindowText, lParam, addr _buffer, 255<br />                  mov         _buffer&#91;255&#93;, 0<br />                  invoke      MessageBox, hWnd, addr _buffer, CADD&#40;&quot;Button is Talking!!!&quot;&#41;, MB_OK<br />            .ENDIF<br />      .ELSEIF uMsg == WM_CLOSE<br />            invoke      DestroyWindow, hBlenderButton1<br />            invoke      DestroyWindow, hBlenderButton2<br />            invoke      DestroyWindow, hBlenderButton3<br />            invoke      DestroyWindow, hBlenderButton4<br />            invoke      DestroyWindow, hBlenderButton5<br />            invoke      PostQuitMessage, NULL<br />            ret<br />      .ELSE<br />            invoke      DefWindowProc, hWnd, uMsg, wParam, lParam<br />            ret<br />      .ENDIF<br /><br />      xor         eax, eax<br />      ret<br />WndProc endp<br /><br />;===============================================================================<br />;ButtonProc&#40;hWnd, uMsg, wParam, lParam&#41;<br />;===============================================================================<br />ButtonProc proc hWnd&#58;HWND, uMsg&#58;UINT, wParam&#58;WPARAM, lParam&#58;LPARAM<br />      LOCAL _buffer&#91;256&#93;&#58;byte<br />      LOCAL point&#58;POINT<br />      LOCAL hParent&#58;HWND<br />      LOCAL hEdit&#58;HWND<br />      LOCAL msg&#58;MSG<br />      LOCAL rect&#58;RECT<br />      LOCAL _width&#58;dword<br />      LOCAL _height&#58;dword<br />     <br />      ;----- &#91;WM_LBUTTONUP is the only message that need be intercepted&#93; -----<br />      ;----- &#91;and it works only if SHIFT KEY IS DOWN&#93; -----<br /><br />      .IF uMsg==WM_LBUTTONUP &amp;&amp; wParam == MK_SHIFT<br /><br />            invoke      GetWindowText, hWnd, addr _buffer, 255    ;save the text to be<br />            mov         _buffer&#91;255&#93;, 0                           ;used in edit control.<br />            invoke      ShowWindow, hWnd, SW_HIDE                 ;hide button.<br />            mov         hParent, FUNC &#40;GetParent, hWnd&#41;           ;get button parent.<br />            invoke      GetWindowRect, hWnd, addr rect            ;get button screen pos<br />            mov         eax, rect.right                           ;and transform it<br />            sub         eax, rect.left          ;width            ;to client ones.<br />            mov         _width, eax<br />            mov         eax, rect.bottom<br />            sub         eax, rect.top           ;height<br />            mov         _height, eax<br />            invoke      ScreenToClient, hParent, addr rect<br /><br />            ;----- &#91;Create an EDIT control in button place with button text&#93; -----<br /><br />            invoke      CreateWindowEx,\<br />                              NULL, CADD&#40;&quot;BLENDERBTNEDIT&quot;&#41;, addr _buffer,\<br />                              WS_CHILD + WS_VISIBLE + WS_BORDER + ES_CENTER,\<br />                              rect.left, rect.top, _width, _height,\<br />                              hParent, NULL, hInstance, NULL<br />            mov         hEdit, eax<br />            invoke      SetWindowLong,hEdit,GWL_USERDATA,hWnd     ;remember button &quot;parent&quot;<br />            invoke      ShowWindow, hEdit, SW_NORMAL              ;show edit control<br />            invoke      SetFocus, hEdit                           ;set focus in it<br />            invoke      SendMessage, hEdit, EM_SETSEL, 0, -1<br />            <br />            ;----- &#91;if&#40;eax&#41; set new text in button&#93; -----<br />      .ELSEIF uMsg == UM_BTNEDITEXIT<br />            .IF lParam<br />                  invoke      GetWindowText, wParam, addr _buffer, 255<br />                  mov         _buffer&#91;255&#93;, 0<br />                  .IF eax != 0<br />                        invoke      SetWindowText, hWnd, addr _buffer<br />                        ;here can go a routine to send hParent window that<br />                        ;the text was changed. EXAMPLE&#58;<br />                        ;invoke     GetWindowLong, hWnd, GWL_ID<br />                        ;mov        edx, 12345        ;text was changed msg<br />                        ;shl        edx, 16<br />                        ;or         edx, eax       <br />                        ;invoke     SendMessage, hParent, WM_COMMAND, eax, hWnd<br />                  .ENDIF<br />            .ENDIF<br />            invoke      ShowWindow, hWnd, SW_NORMAL   ;show the button<br />            invoke      DestroyWindow, wParam          ;destroy edit control<br />      .ELSE<br />defproc&#58;    invoke      CallWindowProc, oldButtonProc, hWnd, uMsg, wParam, lParam<br />            ret<br />      .ENDIF<br />      xor         eax, eax<br />      ret<br />ButtonProc endp<br /><br />;===============================================================================<br />;BtnEditProc&#40;hWnd, uMsg, wParam, lParam&#41;<br />;===============================================================================<br />BtnEditProc proc hWnd&#58;HWND, uMsg&#58;UINT, wParam&#58;WPARAM, lParam&#58;LPARAM<br />      .IF uMsg==UM_BTNEDITKEY<br />            invoke GetWindowLong,hWnd,GWL_USERDATA<br />            invoke SendMessage,eax,UM_BTNEDITEXIT,hWnd,lParam<br />      .ELSE<br />            invoke      CallWindowProc, oldBtnEditProc, hWnd, uMsg, wParam, lParam<br />            ret<br />      .ENDIF<br />      xor eax,eax<br />      ret<br />BtnEditProc endp<br /><br />;===============================================================================<br />;ProcessBtn&#40;lpMsg&#41;<br />;===============================================================================<br />ProcessBtn proc lpMsg&#58;DWORD<br />      LOCAL msg&#58;MSG<br />      <br />      mov eax,lpMsg<br />      push &#40;MSG ptr &#91;eax&#93;&#41;.message<br />      pop msg.message<br />      .IF msg.message == WM_KEYDOWN<br />            push &#40;MSG ptr &#91;eax&#93;&#41;.wParam<br />            pop msg.wParam<br />            push &#40;MSG ptr &#91;eax&#93;&#41;.hwnd<br />            pop msg.hwnd<br />            .IF msg.wParam == VK_RETURN<br />                  invoke      SendMessage,msg.hwnd,UM_BTNEDITKEY,NULL,TRUE<br />            .ELSEIF msg.wParam ==VK_ESCAPE<br />                  invoke      SendMessage,msg.hwnd,UM_BTNEDITKEY,NULL,FALSE<br />            .ENDIF<br />      .ENDIF<br />	<br />	  xor eax,eax<br />      ret<br />ProcessBtn endp<br /><br />;===============================================================================<br />;PROGRAM START HERE<br />;===============================================================================<br />start&#58;<br />      invoke      GetModuleHandle, NULL<br />      mov         hInstance, eax<br />      invoke      WinMain, hInstance, NULL, NULL, SW_NORMAL<br />      invoke      ExitProcess, eax<br />end start <br /></code></pre></div>
    <div class="meta">Posted on 2004-12-16 11:22:40 by sirchess</div>
   </div>
   <div class="post" id="post-154253">
    <div class="subject"><a href="#post-154253">Editable button</a></div>
    <div class="body">Hey, much better now. The thing is that my code block the thread on propouse, just for fun, and because while I was playing with the original idea, came to my mind a question about how MessageBox blocks windows. I am sure this is not the way, but it works.<br />Now, it is much better than mine (how it works).<br />I'm working on another idea. But when I finish it, I will come to the button again to add a new intersting function (like Blender does).<br /><br />sirchess, thanks for your interest.<br /><br />Kecol.-<br /><br />PD: Blender interface is getting better day to day. How it splits windows, or how &quot;editable number buttons&quot; works, or zooming of panels are something to admire from the program. I think this kind of UI can be ported or re-written  in win32asm, making a better and faster UI.</div>
    <div class="meta">Posted on 2004-12-16 12:00:33 by Kecol</div>
   </div>
   <div class="post" id="post-154259">
    <div class="subject"><a href="#post-154259">Editable button</a></div>
    <div class="body"><div class="quote">sirchess, thanks for your interest. </div><br /><br />No problem :)<br /><br />Actually, your code will help me with a project of my own.  I was trying to get a subclassed editbox to process WM_KEYDOWN messages, but didn't realize that these messages are never even sent to the window proc because of TranslateMessage.  But now I know how to do it  :alright:</div>
    <div class="meta">Posted on 2004-12-16 13:35:30 by sirchess</div>
   </div>
  </div>
 </body>
</html>