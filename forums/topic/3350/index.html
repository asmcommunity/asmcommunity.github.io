<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>fast memcpy and memset - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=3350" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=3350">fast memcpy and memset</a></p>
   <div class="post" id="post-22199">
    <div class="subject"><a href="#post-22199">fast memcpy and memset</a></div>
    <div class="body">I apologize in advance if this is a cheap topic that has been covered millions of times, I just haven't found it on the boards...<br /><br />Could anyone point me to some code that does memcpy and memset fast? I'm using MSVC inline asm and I'm not an asm programmer at all. I just want a replacement with no error checking or anything. I don't think I can guarantee alignment though, so it should be fairly general. An mmx version or something would be good if it really helps (nothing newer though like prefetching or whatever, I can't really impose high requirements). It should also be efficient for short spans.<br /><br />Thanks.<br /><br />steel</div>
    <div class="meta">Posted on 2002-01-31 18:18:27 by steel</div>
   </div>
   <div class="post" id="post-22211">
    <div class="subject"><a href="#post-22211">fast memcpy and memset</a></div>
    <div class="body">This gem show you how you can use your FPU to copy data between memory<br />locations? The following loop can be used for block memory copying. I don't<br />know who was the original developer of this kind of loop, but it has been<br />presented in various documents. This version comes from Agner Fogs excelent<br />Pentium optimization manual<br /><br />;<br />; copying data using the fpu<br />;<br />; input:<br />;   esi = source<br />;   edi = destination<br />;   ecx = number of 16-byte chunks to move<br />;<br />; output:<br />;   none (data from esi is copied to edi)<br />;<br />; destorys:<br />;   esi, edi, ecx<br />;   flags, fp flags<br />;<br /><br />topofloop:<br />        fild    qword ptr <br />        fild    qword ptr <br />        fxch<br />        fistp   qword ptr <br />        fistp   qword ptr <br />        add     esi,16<br />        add     edi,16<br />        dec     ecx<br />        jnz     topofloop<br /><br />The loop is optimal on (a fast) Pentium when both the source and<br />destination are aligned on 64-bit boundaries and the destination is not in<br />the cache. (Additionally the loop can be optimal on PPro if the destination<br />does not permit write-combining.)<br />If the destination is in the cache (or the destination memory permits write<br />combining on PPro) then REP MOVSD will be faster.<br />The loop is faster than REP MOVSD, because it does half as many writes to<br />external memory (with the noted exceptions). External memory is usually<br />very slow compared to the execution time of the loop. Consequently after a<br />few iterations of the loop the write buffers of the CPU become filled and<br />subsequent iterations of the loop will execute at the speed of external<br />memory. For small memory blocks you should use a simple DWORD copy loop,<br />because the overhead of the FPU copy loop is much higher than that of most<br />other memory copy loops.<br />You might think that you should use FLD/FSTP instead of FILD/FISTP.<br />Unfortunately FLD/FSTP would not work very well, because all 64-bit values<br />are not normal floating point values. The handling of denormal floating<br />point numbers is very slow.<br />But it's eve worse. Denormals (see notes) make the FLD/FSTP copying slow,<br />but it will still be functionally correct. But, if the data represents an<br />SNAN (see notes), it will be quietly converted to a QNAN (see notes) if IE<br />is masked (CW.IM = 1), or you will get an exception if IE is unmasked<br />(CW.IM = 0).<br />Therefore one should really forget about trying to use FLD/FSTP for memory<br />copy loops.<br /><br />For related information see Agner Fog's Pentium optimization manual (you<br />can find it at <a target="_blank" href="http://announce.com/agner/assem">http://announce.com/agner/assem</a> and Intel's Pentium Pro<br />developer's manual volume 3 for information on write buffers, caches,<br />write-combining etc... (it can be found at Intel's developer WWW site).<br /><br />notes:<br />SNANs are all the numbers where bits &lt;62:52&gt; = 7FFh, and bit &lt;51&gt; = 0 and<br />bits &lt;50:0&gt; !=0. An SNAN is converted to a QNAN by setting bit&lt;51&gt;.<br /><br />Denormals are numbers when the exponent field has all bit set to 0 and the<br />mantissa is non-zero. Or in the copy process the bits 62-52 (exponent<br />field) of each aligned 64-bit entitiy is zero.<br /><br />                                               Gem writer: (code) Agner Fog</div>
    <div class="meta">Posted on 2002-01-31 18:53:57 by The Svin</div>
   </div>
   <div class="post" id="post-22240">
    <div class="subject"><a href="#post-22240">fast memcpy and memset</a></div>
    <div class="body">Without using prefetch# you are limited in the speed you can do either function. One of our moderators &quot;Bitrake&quot; posted a very fast memory copy routine some time ago but it required the prefetch# instructions and PIII or higher to work.<br /><br />There are a couple of appropriate routines in the MASM32 library that you could use directly in C/C++ if you wrote the prototypes for them and they are reasonable performers for non PIII code. MMX by itself does not seem to improve on MOVSD for memory copy as it is a well optimised instruction on later Intel machines.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-01-31 21:34:27 by hutch--</div>
   </div>
   <div class="post" id="post-22245">
    <div class="subject"><a href="#post-22245">fast memcpy and memset</a></div>
    <div class="body">First, a quesiton.<br />How much does all this *really* matter? Aren't we bound by<br />memory speed these days? If source and dest are dword aligned,<br />are any other methods &quot;much&quot; faster than a simple rep movsd?<br /><br />Next... I'm no optimization guru (not compare to Svin or BitRake<br />anyway ;), but it seems like <strong>some</strong> efford has been put into<br />memset/memcpy from the microsoft libc. To take care of alignment<br />and stuff. Supposedly this is good if you work with large blocks.<br />Comments by somebody who knows?<br /><br />Also, memcpy/memset are some of the so-called <strong>intrinsic</strong> functions,<br />which mean the compiler can inline &quot;better copy code&quot; instead of<br />calling the external functions - supposed to give better performance.<br />Again, not something I have really tested... my performance-requiring<br />code doesn't usually involve memcpy/memset.</div>
    <div class="meta">Posted on 2002-01-31 22:00:40 by f0dder</div>
   </div>
   <div class="post" id="post-22260">
    <div class="subject"><a href="#post-22260">fast memcpy and memset</a></div>
    <div class="body">Intel and AMD both have specially tuned memcpy for P3/P4 and Athlon/K6 respectively.  I don't mean to use them blindly - they are designed for general HLL use.  But you certainly can gleam the technique that best matches their respective chips internal structure from the algorithms.  Intel's can be found (<a target="_blank" href="http://developer.intel.com/software/idap/media/pdf/copy.pdf">HERE</a>).  AMD's can be found (<a target="_blank" href="ftp://ftp.amd.com/pub/devconn/vcc/memcpy_amd.zip">HERE</a>).<br /><br />From a design perspective the assembly language programmer wins big time.  We can plan to have almost everything DWORD aligned and not have to test for it - instant saving on the overhead of even a small size operation.<br /><br />Needless to say, this is a topic of much research!<br /><br /><strong>Other Threads</strong>:<br /><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=1229">http://www.asmcommunity.net/board/index.php?topic=1229</a><br /><br /><strong>Web Links</strong>:<br /><a target="_blank" href="http://www.geocities.com/~charlie_x/source.htm">http://www.geocities.com/~charlie_x/source.htm</a><br /><a target="_blank" href="http://www.azillionmonkeys.com/qed/blockcopy.html">http://www.azillionmonkeys.com/qed/blockcopy.html</a><br /><a target="_blank" href="http://www.bh.wakwak.com/~xelf/developer/MemoryCopy.html">http://www.bh.wakwak.com/~xelf/developer/MemoryCopy.html</a></div>
    <div class="meta">Posted on 2002-01-31 23:17:55 by bitRAKE</div>
   </div>
   <div class="post" id="post-22513">
    <div class="subject"><a href="#post-22513">fast memcpy and memset</a></div>
    <div class="body">Thanks for all the input guys, now we're going somewhere :-)<br /><br />Basically my dilemma was how smartly will the compiler inline memcpy() and how much overhead does it have for small spans (line on the order of tens of bytes).  I really have no idea.  Or how well something like a for loop copy would translate. Really nested for loops of smallish block copies, matrix/vector manipulation stuff.<br /><br />Basically I did assume that the the compiler memcpy is smarter than me so I used it, but I figured I could do a couple of tests if there was easily available code. Since I don't see msvc compatible code it would be a liiitle bit of work but I might still try a routine or two you guys suggested. <br /><br />Thanks again</div>
    <div class="meta">Posted on 2002-02-02 15:18:35 by steel</div>
   </div>
   <div class="post" id="post-22819">
    <div class="subject"><a href="#post-22819">fast memcpy and memset</a></div>
    <div class="body">Ok, to wrap up this subject more or less...<br /><br />Bitrake, thanks for the links, that last one <a target="_blank" href="http://www.bh.wakwak.com/~xelf/developer/MemoryCopy.html">http://www.bh.wakwak.com/~xelf/developer/MemoryCopy.html</a> was especially useful!<br /><br />I ran a bunch of benchmarks on different machines, added some of my stuff that I wanted to test, and basically came up with the conclusion that memcpy() and memset() are indeed the best overall solution, or at least good enough :-) Just thought I'd say this so hopefully other people don't waste time going down this path like I did. Although it was a great educational experience! :-)<br /><br />Here's my results, some of em are weird and surprising, you can draw your own conclusions. <br />Note: &quot;MMX unaligned&quot; is the routine from <br /><a target="_blank" href="http://www.azillionmonkeys.com/qed/blockcopy.html">http://www.azillionmonkeys.com/qed/blockcopy.html</a><br />It works quite good in fact, especially on misaligned pointers, but doesn't help on short spans. Of course it can be adapted to any one of these routines not just mmx.<br /><br />---------------------------------------------------------------------------------<br />//<br />// This section mostly weighs overhead for short spans<br />//<br /><br />// Athlon 700<br />memory copy code benchmark VER.2001-01-29 by (C)2001 XELF.<br />copy size: 64 <br /><br />copy repetitions: 5242880<br /><br />memcpy: 43.4 <br />rep movsd: 32.2 <br />FPU 8bytes: 15.7 <br />MMX movntq pre 16bytes: 13.6 <br />MMX movntq 16bytes: 14.2 <br />MMX movntq 8bytes: 16.5 <br />MMX 16bytes: 11.5 <br />MMX 8bytes: 21.0 <br />asm 8bytes: 20.2 <br />asm 4bytes: 50.2 <br />C++ 4bytes: 36.8 <br />MMX unaligned : 45.0 <br />C++ zeroing loop: 72.6 <br />C++ memset(): 71.4 <br />stosd memset: 125.0 <br />Press any key to continue<br /><br /><br />// P3 866<br />memory copy code benchmark VER.2001-01-29 by (C)2001 XELF.<br />copy size: 64 <br /><br />memcpy: 37.8 <br />rep movsd: 27.6 <br />FPU 8bytes: 22.0 <br />MMX movntq pre 16bytes: 14.0 <br />MMX movntq 16bytes: 15.3 <br />MMX movntq 8bytes: 31.2 <br />SSE movntps pre 32bytes: 40.1 <br />SSE movntps 16bytes: 11.3 <br />SSE 16bytes: 11.6 <br />MMX 16bytes: 11.6 <br />MMX 8bytes: 23.3 <br />asm 8bytes: 28.8 <br />asm 4bytes: 37.8 <br />C++ 4bytes: 38.5 <br />MMX unaligned : 57.4 <br />C++ zeroing loop: 76.5 <br />C++ memset(): 74.7 <br />stosd memset: 230.6 <br />Press any key to continue<br /><br />//<br />// The rest measures burst speed<br />//<br /><br />// Athlon 700<br />memory copy code benchmark VER.2001-01-29 by (C)2001 XELF.<br />copy size: 16777216 <br /><br />copy repetitions: 10<br /><br />memcpy: 105.1 <br />rep movsd: 110.6 <br />FPU 8bytes: 83.7 <br />MMX movntq pre 16bytes: 77.3 <br />MMX movntq 16bytes: 82.5 <br />MMX movntq 8bytes: 83.5 <br />MMX 16bytes: 83.7 <br />MMX 8bytes: 83.5 <br />asm 8bytes: 103.7 <br />asm 4bytes: 131.1 <br />C++ 4bytes: 106.0 <br />MMX unaligned : 83.8 <br />C++ zeroing loop: 111.8 <br />C++ memset(): 111.9 <br /><br /><br />// P3 866<br />memory copy code benchmark VER.2001-01-29 by (C)2001 XELF.<br />copy size: 16777216 <br /><br />copy repetitions: 10<br /><br />memcpy: 72.4 <br />rep movsd: 70.2 <br />FPU 8bytes: 82.0 <br />MMX movntq pre 16bytes: 48.5 <br />MMX movntq 16bytes: 49.8 <br />MMX movntq 8bytes: 49.1 <br />SSE movntps pre 32bytes: 53.0 <br />SSE movntps 16bytes: 50.2 <br />SSE 16bytes: 83.9 <br />MMX 16bytes: 84.2 <br />MMX 8bytes: 82.5 <br />asm 8bytes: 119.3 <br />asm 4bytes: 123.1 <br />C++ 4bytes: 121.6 <br />MMX unaligned : 83.2 <br />C++ zeroing loop: 73.7 <br />C++ memset(): 73.8 <br /><br />// P2 400<br />memory copy code benchmark VER.2001-01-29 by (C)2001 XELF.<br />copy size: 16777216 <br /><br />copy repetitions: 10<br /><br />memcpy: 114.9 <br />rep movsd: 114.7 <br />FPU 8bytes: 109.5 <br />MMX 16bytes: 110.3 <br />MMX 8bytes: 109.8 <br />asm 8bytes: 161.1 <br />asm 4bytes: 158.6 <br />C++ 4bytes: 159.6 <br />MMX unaligned : 109.8 <br />C++ zeroing loop: 176.3 <br />C++ memset(): 196.0 <br />stosd memset: 786.1 <br />completed.<br /><br /><br />//<br />// These tests check performance on unaligned pointers<br />// The pointer returned by new is incremented by one byte<br />// (Looks like new aligns the original pointer nicely, <br />// though I'm sure this is not always guaranteed)<br />//<br /><br />// Athlon 700<br />memory copy code benchmark VER.2001-01-29 by (C)2001 XELF.<br />copy size: 64 <br /><br />copy repetitions: 5242880<br /><br />memcpy: 51.8 <br />rep movsd: 40.4 <br />FPU 8bytes: 22.6 <br />MMX 16bytes: 23.2 <br />MMX 8bytes: 23.7 <br />asm 8bytes: 27.6 <br />asm 4bytes: 49.6 <br />C++ 4bytes: 38.2 <br />MMX unaligned : 55.3 <br />C++ zeroing loop: 73.3 <br />C++ memset(): 72.6 <br />stosd memset: 126.4 <br />completed.<br />Press any key to continue<br /><br /><br />// Athlon 700<br />memory copy code benchmark VER.2001-01-29 by (C)2001 XELF.<br />copy size: 16777216 <br /><br />copy repetitions: 10<br /><br />memcpy: 162.0 <br />rep movsd: 164.4 <br />FPU 8bytes: 148.9 <br />MMX 16bytes: 140.3 <br />MMX 8bytes: 149.0 <br />asm 8bytes: 154.2 <br />asm 4bytes: 158.7 <br />C++ 4bytes: 160.7 <br />MMX unaligned : 88.2 <br />C++ zeroing loop: 119.7 <br />C++ memset(): 119.4 <br />stosd memset: 485.4 <br />completed.<br />Press any key to continue<br /><br /><br />// P3 866<br />memory copy code benchmark VER.2001-01-29 by (C)2001 XELF.<br />copy size: 16777216 <br /><br />copy repetitions: 10<br /><br />memcpy: 146.7 <br />rep movsd: 146.4 <br />FPU 8bytes: 113.5 <br />MMX movntq pre 16bytes: 133.4 <br />MMX movntq 16bytes: 60.3 <br />MMX movntq 8bytes: 62.8 <br />MMX 16bytes: 110.1 <br />MMX 8bytes: 112.9 <br />asm 8bytes: 145.3 <br />asm 4bytes: 146.7 <br />C++ 4bytes: 145.6 <br />MMX unaligned : 110.8 <br />C++ zeroing loop: 140.5 <br />C++ memset(): 140.6 <br />stosd memset: 569.0 <br />completed.</div>
    <div class="meta">Posted on 2002-02-04 14:39:47 by steel</div>
   </div>
   <div class="post" id="post-23217">
    <div class="subject"><a href="#post-23217">fast memcpy and memset</a></div>
    <div class="body">really nice comparings!<br /><br />I found an extreme speed difference between copy loops from memory -&gt; memory compared with memory -&gt; video memory.<br /><br />The MMX version I had, was much more faster than the CPU variant.</div>
    <div class="meta">Posted on 2002-02-07 07:40:36 by beaster</div>
   </div>
   <div class="post" id="post-23299">
    <div class="subject"><a href="#post-23299">fast memcpy and memset</a></div>
    <div class="body">steel,<br /><br />If you are copying small blocks, one of the factors with memory copy speed is the setup time for the generically faster methods. REP MOVSD is a poor performer on blocks smaller than 64 bytes.<br /><br />If you are repeatedly copying blocks that are smaller than this, it may be worth writing some simple test pieces that use the old REP MOVSB or directly indexing the memory locations with a common counter. Either will have less setup time than the faster methods for larger blocks.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-02-07 21:18:35 by hutch--</div>
   </div>
   <div class="post" id="post-23303">
    <div class="subject"><a href="#post-23303">fast memcpy and memset</a></div>
    <div class="body"><div class="quote"><br />If you are copying small blocks, one of the factors with memory copy speed is the setup time for the generically faster methods. REP MOVSD is a poor performer on blocks smaller than 64 bytes.</div>If your programming in ASM, you can usually have the data aligned.  So, there would be no set-up for REP MOVSD beyond any other method.  Besides a string of MOVSD's.  ;)<br /><br />I've seen benchmarks for REP MOVSB on the P4 that rate the same as REP MOVSD - which makes me wonder if REP MOVSB is optimized the same as REP MOVSD on the P4.  I don't remember what the docs say - I just forgot since I have AMD gear now.</div>
    <div class="meta">Posted on 2002-02-07 22:13:08 by bitRAKE</div>
   </div>
   <div class="post" id="post-23356">
    <div class="subject"><a href="#post-23356">fast memcpy and memset</a></div>
    <div class="body">bitRAKE,<br /><br />The minimum size for an efficient use of REP MOVSD is documented in Agner Fog's manual and it matches the testing I have done on copying very large numbers of small blocks of memory. I have yet to do much benchmarking on the P4 as I use it as a backup box and still develop on my PIII.<br /><br />At PIII and under, REP MOVSB and direct pointer manipulation on the two buffers is usually faster that REP MOVSD on very small repeated memory blocks. On AMD I don't remember as the last testing I did was on a K6/2 550 which would be well off the pace of current AMD devices.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-02-08 08:15:06 by hutch--</div>
   </div>
   <div class="post" id="post-24417">
    <div class="subject"><a href="#post-24417">fast memcpy and memset</a></div>
    <div class="body">Good link with some code:<br /><a target="_blank" href="http://sourcefrog.net/mbp/memcpyspeed/">http://sourcefrog.net/mbp/memcpyspeed/</a></div>
    <div class="meta">Posted on 2002-02-15 17:09:42 by bitRAKE</div>
   </div>
  </div>
 </body>
</html>