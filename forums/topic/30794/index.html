<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Alphablend - VB6/ASM dll - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30794" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=30794">Alphablend - VB6/ASM dll</a></p>
   <div class="post" id="post-215545">
    <div class="subject"><a href="#post-215545">Alphablend - VB6/ASM dll</a></div>
    <div class="body">Hi,<br /><br />Im looking for some help putting together a DLL that can be used from Visual Basic 6. Ive googled and searched and cant find enough pieces of the puzzle to really get me on the right track.<br /><br />Im not sure if I need just a ASM compiler or a C++ compiler with inline ASM support to do this. I also believe that VB handles dll&#039;s (CDECL vs STDCALL) differently, and that needs consideration. Im not sure of the best compiler to use (considering speed of compiled code).<br /><br />Im wanting to write a few alphablend functions based on its callers needs, and would like to know what the fastest method&#039;s are. I&#039;ve googled and I hear MMX registers are good, and that for a 50% blend only (via bitshifting) achieves even faster results but with a constant blend rate.<br /><br />Passing the parameters to the dll concerns me, (push/pop vs speed), so I presume a way around this would be to pass a pointer to a structure with the paramters. I presume VB6&#039;s byref and safearray dont void this optimization.<br /><br />Im looking for speed, but want to develop within VB6.&nbsp; So Im guessing a DLL built from ASM is the best I can get to that goal.&nbsp; Im a complete novice outside of VB6, so any help with some direction or templates for getting me going on this would be amazing.</div>
    <div class="meta">Posted on 2011-12-08 18:31:31 by timfrombriz</div>
   </div>
   <div class="post" id="post-215554">
    <div class="subject"><a href="#post-215554">Re: Alphablend - VB6/ASM dll</a></div>
    <div class="body">Hi<br />The most experienced coder I know which can answere your questions is Obivan.<br />In general, it is not hard to interface a DLL with VB6. <br />A line like <br /><pre><code>Public Declare Sub MyProc Lib &quot;MyLib&quot; (ByVal DstPtr As Long, etc...)<br /></code></pre><br />does the trick to import the DLL procedure.<br />The rest is up to you.<br /><br />Regards, Biterider<br /><br /><br /></div>
    <div class="meta">Posted on 2011-12-09 06:54:23 by Biterider</div>
   </div>
   <div class="post" id="post-215555">
    <div class="subject"><a href="#post-215555">Re: Alphablend - VB6/ASM dll</a></div>
    <div class="body">&quot;ASM compiler&quot;? No, it&#039;s called an assembler. Assembling is not quite the same as compiling. Assembly language is one of the few languages you don&#039;t compile.<br /><br />Anyway...<br />Speedwise, it doesn&#039;t really matter whether you use ASM or C++ with inline ASM... That is, if you are writing the routine in 100% ASM anyway. With a __declspec(naked) function, the C++ compiler will not add any code to your function whatsoever, so if you write the function entirely in assembly, the result is the same as with an assembler.<br />You might want to choose an assembler anyway, since they will generally have a richer, more powerful assembly syntax, allowing you to use macros and such.<br /><br />MMX is good, but SSE2 is even better. MMX is pretty outdated these days (deprecated in Windows x64). SSE2 allows you to use MMX operations on SSE registers, which are twice as wide, and not shared with the FPU (so no FPU stack cleanup overhead through emms afterwards).<br /><br />As for calling overhead: the fastest way to call a function is not to call it.<br />What this means is: you should not try to make a function to blend a single pixel. No matter how fast you make the function itself, the calling overhead for every pixel will still have a significant impact.<br />You should make a single function that performs alphablending on an entire image at a time (or at least, part of an image, defined by a RECT or such, which you would probably want to pass by-ref, yes). That way, all the memory access, looping etc can be optimized along with the blend routine itself, in a single piece of code.<br />Since the time spent on blending images of any reasonable size is much larger than the calling overhead, this means you don&#039;t even have to worry about that, really.<br />I would personally choose STDCALL, since that is the same convention as used by the Windows API, and is therefore compatible with most languages. It is slightly more efficient than cdecl, since it doesn&#039;t require stack cleanup on the caller side (stack is cleaned up automatically with the ret).<br />Fastcall would theoretically be slightly faster, but it is less compatible with other languages (not sure if VB would support it). And in this case it is not worth the trouble, as the bulk of the time is spent in the alphablending routine (the good old 90/10 rule).<br /><br />Also, yes 50% alphablending is just taking the average of 2 pixels.<br />You could use bitshifting, but it is not entirely accurate. You have to shift first, to make room for the addition.<br />So you&#039;d do something like this:<br />result = (a &gt;&gt; 1) + (b &gt;&gt; 1);<br />The problem is easily demonstrated with the value 255:<br />result = (255 &gt;&gt; 1) + (255 &gt;&gt; 1) = 127 + 127 = 254.<br />You are off-by-one. Repeated alphablending will make your images darker and darker (some videocards actually suffered from an off-by-one error in alphablending btw).<br /><br />So what you are looking for is more like this:<br />result = (a + b) &gt;&gt; 1;<br />But that requires 9 bits per pixel, not 8.<br />But, this is basically just the average of 2 values.<br />And luckily there already is an instruction for that in SSE: pavgb:<br />http://www.rz.uni-karlsruhe.de/rz/docs/VTune/reference/vc230.htm<br />It actually does ((a + b) + 1) &gt;&gt; 1, which is even more correct.<br />Namely, if you were to take the average of 0 and 1, we&#039;d say that&#039;s 0.5, which we&#039;d generally round up to 1.<br />A shift will always round down, so you&#039;d get 0. By adding the 1 before the shift, it will round towards the nearest number.<br /><br />I hope this helps somewhat.</div>
    <div class="meta">Posted on 2011-12-09 07:13:16 by Scali</div>
   </div>
   <div class="post" id="post-215561">
    <div class="subject"><a href="#post-215561">Re: Alphablend - VB6/ASM dll</a></div>
    <div class="body">Hi BiteRider/Scali,<br /><br />Thanks for the feedback.<br /><br />So the best assembler to use, I looked thru and found MASM,FASM,TASM,YASM and HLA.&nbsp; Out of these I choose FASM; open source, compiles itself, said to be&nbsp; focused on speed and seems to be the most popular. Any feedback on this selection?<br /><br />I think sticking with a assembler and not a C++ with inline ASM would be best for me, Id need to pick up both C++/asm and Im thinking bloat from the C++ compiler will get thrown into the release dll.&nbsp; I did find some FASM code to build a dll callable from VB6 and it compiled to 5kb, which made me smile.<br /><br />I read for VB dll&#039;s, it needs;<br /><br />.MODEL STDCALL,FLAT for 32-bit ASM<br /><br />My game engine runs on Windows (VB6 of course) and uses DirectDraw.&nbsp; Ive found that speedwise its faster to lock the surfaces, pixel plot completely, unlock and flip the backbuffer to the screen, then to use DirectDraw&#039;s blitting functions. Im not sure why blting with native DirectDraw calls would be slower, perhaps my approach to pixel plotting is superior to hardware blitting (lol).&nbsp; I created an instruction list per sprite of skipping/copying blocks of pixels between the two surfaces, rather than checking for transparency on a per pixel basis.<br /><br />Its interesting you mention the SSE2 over MMX as more superior.&nbsp; In my pixel plotting code, I use the RtlMoveMemory api to copy between surfaces, and i found this article on how MMX ASM improved speed over RtlMoveMemory;<br /><br /><a target="_blank" href="http://www.persistentrealities.com/vbfibre/index.php?category=4&amp;item=1&amp;t=asm">http://www.persistentrealities.com/vbfibre/index.php?category=4&amp;item=1&amp;t=asm</a><br /><br />I presume that SSE2 could further the benefit here as well.<br /><br /><br /><br />Here is a DLL framework for FASM I found;<br /><br /><br /><pre><code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; DLL creation example<br /><br /><br />format PE GUI 4.0 DLL<br />entry DllEntryPoint<br /><br /><br />include &#039;win32a.inc&#039;<br /><br /><br />section &#039;.code&#039; code readable executable<br /><br /><br />proc DllEntryPoint hinstDLL,fdwReason,lpvReserved<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  eax,TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br />endp<br /><br /><br />; VOID ShowErrorMessage(HWND hWnd,DWORD dwError);<br /><br /><br />proc ShowErrorMessage hWnd,dwError<br />&nbsp; local lpBuffer:DWORD<br />&nbsp; &nbsp; &nbsp; &nbsp; lea&nbsp; &nbsp;  eax,<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke&nbsp; FormatMessage,FORMAT_MESSAGE_ALLOCATE_BUFFER+FORMAT_MESSAGE_FROM_SYSTEM,0,,LANG_NEUTRAL,eax,0,0<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke&nbsp; MessageBox,,,NULL,MB_ICONERROR+MB_OK<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke&nbsp; LocalFree,<br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br />endp<br /><br /><br />; VOID ShowLastError(HWND hWnd);<br /><br /><br />proc ShowLastError hWnd<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke&nbsp; GetLastError<br />&nbsp; &nbsp; &nbsp; &nbsp; stdcall ShowErrorMessage,,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br />endp<br /><br /><br />section &#039;.idata&#039; import data readable writeable<br /><br /><br />&nbsp; library kernel,&#039;KERNEL32.DLL&#039;,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user,&#039;USER32.DLL&#039;<br /><br /><br />&nbsp; import kernel,\<br />&nbsp; &nbsp; &nbsp; &nbsp;  GetLastError,&#039;GetLastError&#039;,\<br />&nbsp; &nbsp; &nbsp; &nbsp;  SetLastError,&#039;SetLastError&#039;,\<br />&nbsp; &nbsp; &nbsp; &nbsp;  FormatMessage,&#039;FormatMessageA&#039;,\<br />&nbsp; &nbsp; &nbsp; &nbsp;  LocalFree,&#039;LocalFree&#039;<br /><br /><br />&nbsp; import user,\<br />&nbsp; &nbsp; &nbsp; &nbsp;  MessageBox,&#039;MessageBoxA&#039;<br /><br /><br />section &#039;.edata&#039; export data readable<br /><br /><br />&nbsp; export &#039;ERRORMSG.DLL&#039;,\<br />&nbsp; &nbsp; &nbsp; &nbsp;  ShowErrorMessage,&#039;ShowErrorMessage&#039;,\<br />&nbsp; &nbsp; &nbsp; &nbsp;  ShowLastError,&#039;ShowLastError&#039;<br /><br /><br />section &#039;.reloc&#039; fixups data discardable<br /></code></pre>&nbsp; <br /><br /><br />I absolutely agree with you about not calling on a per-pixel basis, and rather work on a RECT section between a source/dest.&nbsp; To minimize the amount of parameters to pass, would it be beneficial to pass the struct pointer to the parameters or does this cause a slow down (ie. CPU Caching, having to fetch stuff from RAM, Im making this stuff up, Ive just been reading heaps and these things are some things I&#039;ve heard but may of interpreted wrongly).<br /><br /><br />Ie. My structure which Id fill for the function would be something like this;<br /><br /><br /><br />Source&nbsp; &nbsp; &nbsp; &nbsp; ; pointer to the memory location of (y*SourceScanline+x) for the source surface<br />Dest&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; pointer to the memory location of (y*DestScanline+x) for the dest surface<br />Width&nbsp; &nbsp; &nbsp; &nbsp; ; the width of the source/dest blit area<br />Height&nbsp; &nbsp; &nbsp; &nbsp; ; the height of the source/dest blit area<br />SourceScanline&nbsp; &nbsp;  ; how much to increment source to step each y axis of the source surface<br />DestScanline&nbsp; &nbsp; &nbsp;  ; how much to increment dest to step each y axis of the source surface<br />Alpha&nbsp; &nbsp; &nbsp; &nbsp; ; a Byte I guess? with 256 different shade posibilities<br /><br /><br />I think the hardest thing for me is going to get my head around converting code to fit my needs.&nbsp; My heads overloaded at the moment with information Ive been trying to absorb.<br /><br /><br />As a starting point, could maybe someone modify the code template for FASM above and fit it to rtlMovememory using SSE2 or MMX for speed, taking source,dest, len as parameters.&nbsp; It&#039;d be nice to have a real-world function to see what potential speed benefit I might get thru asm, and it seems (in my mind) a simple enough algorithm for me to look at and try and make sense of. <br /><br /><br />Thanks for your help and feedback this far.&nbsp; It really is appreciated.</div>
    <div class="meta">Posted on 2011-12-09 19:43:01 by timfrombriz</div>
   </div>
   <div class="post" id="post-215562">
    <div class="subject"><a href="#post-215562">Re: Alphablend - VB6/ASM dll</a></div>
    <div class="body"><div class="quote"><br />Im thinking bloat from the C++ compiler will get thrown into the release dll.</div><br /><br />As I said: it won&#039;t.<br /><br /><div class="quote">Ive found that speedwise its faster to lock the surfaces, pixel plot completely, unlock and flip the backbuffer to the screen, then to use DirectDraw&#039;s blitting functions. Im not sure why blting with native DirectDraw calls would be slower, perhaps my approach to pixel plotting is superior to hardware blitting (lol).</div><br /><br />Hardware blits are faster than CPU, but they only work if you blit from videomemory to videomemory.<br />So you&#039;d need to upload all your graphics to surfaces in videomemory first, and blit from there.<br />Then again, DirectDraw has been deprecated for years now, so perhaps the drivers just aren&#039;t very optimized these days. You want to either use Direct3D, or the new Direct2D (Windows Vista or higher) these days. There is no specific blitting/2D hardware anymore, these days. Videocards perform all operations with textured polygons. It&#039;s not that difficult to set up a framework in Direct3D for doing 2D rendering.<br />Again the idea is the same though: create textures in videomemory first, then use the GPU to &#039;blit&#039; them to screen (rendering 2 triangles to create a rectangular area with a texture).<br /><br /><div class="quote"><br />I absolutely agree with you about not calling on a per-pixel basis, and rather work on a RECT section between a source/dest.&nbsp; To minimize the amount of parameters to pass, would it be beneficial to pass the struct pointer to the parameters or does this cause a slow down (ie. CPU Caching, having to fetch stuff from RAM, Im making this stuff up, Ive just been reading heaps and these things are some things I&#039;ve heard but may of interpreted wrongly).</div><br /><br />Well, assuming you just put the parameters IN the struct, they are also cached.<br />So in general, things should be fine. There&#039;s just an extra indirection in that you have to read the pointer from the stackframe first, before you can access its members (could cost you an extra register).<br />But aside from that, regular parameters on the stack are just a struct as well, technically.</div>
    <div class="meta">Posted on 2011-12-10 04:35:12 by Scali</div>
   </div>
  </div>
 </body>
</html>