<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Call one DLL entry point from another DLL - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19272" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=19272">Call one DLL entry point from another DLL</a></p>
   <div class="post" id="post-148800">
    <div class="subject"><a href="#post-148800">Call one DLL entry point from another DLL</a></div>
    <div class="body">Looking for an ASM equivalent to calling (C++) LoadLibrary(), GetProcAddress(), and calling the returned proc address.  I have dissassembled a small program that does this, but the way that the address of these functions are being referenced is unclear to me. Perhaps if I understand how a statically stubbed reference to these functions worked, it would be clear as to how to call a function in an external DLL, removing the need for LoadLibrary() et al.</div>
    <div class="meta">Posted on 2004-08-30 23:12:57 by Randalism</div>
   </div>
   <div class="post" id="post-148802">
    <div class="subject"><a href="#post-148802">Call one DLL entry point from another DLL</a></div>
    <div class="body">&gt;&gt;how to call a function in an external DLL, removing the need for LoadLibrary() et al.<br /><br />good luck  :-D</div>
    <div class="meta">Posted on 2004-08-31 00:03:11 by JimmyClif</div>
   </div>
   <div class="post" id="post-148811">
    <div class="subject"><a href="#post-148811">Call one DLL entry point from another DLL</a></div>
    <div class="body">What do you mean? The functions are to be loaded dynamically (ie not using IAT) or using IAT?</div>
    <div class="meta">Posted on 2004-08-31 06:06:30 by roticv</div>
   </div>
   <div class="post" id="post-148831">
    <div class="subject"><a href="#post-148831">Call one DLL entry point from another DLL</a></div>
    <div class="body">i don't understand your question either. if you don't want to use loadlibrary you'll need the IAT (and the assembler/linker will do that job for you) or you have to obtain the module base in another way (but i have no idea why you to do want something like that)</div>
    <div class="meta">Posted on 2004-08-31 09:14:39 by lifewire</div>
   </div>
   <div class="post" id="post-148845">
    <div class="subject"><a href="#post-148845">Clarification</a></div>
    <div class="body">Sorry if my original post made it seem so, but I am not looking for a way to get around using LoadLibrary() et al, I was just wondering if a native, lower-level mechanism for this sort of operation exists.  <br />As far as accomplishing my goal (writing a peice of NASM code that calls a function in another DLL) is concerned, whatever works will suit me just fine.<br /><br />My problem now is finding out how to call Win32 API functions (like LoadLibrary, GetProcAddress and FreeLibrary) in NASM.  I have written a short C program: <br /><br /><pre><code><br />   typedef int &#40;*ABSPROC&#41;&#40; int &#41;;<br /><br />   ABSPROC pAbsFn = NULL;<br /> <br />   HMODULE hm = &#58;&#58;LoadLibrary&#40; &quot;ntdll.dll&quot; &#41;;<br /> <br />   if &#40; hm != NULL &#41;<br />   &#123;<br />      pAbsFn = &#40;ABSPROC&#41;&#58;&#58;GetProcAddress&#40; hm, &quot;abs&quot; &#41;;<br />      <br />      if &#40; pAbsFn != NULL &#41;<br />      &#123;<br />          long lInput = -1;<br />		  <br />		  long lOutput = pAbsFn&#40; lInput &#41;;<br />      &#125;<br />      <br />      &#58;&#58;FreeLibrary&#40; hm &#41;;<br />   &#125;<br /> </code></pre><br /><br />The disassembly (BDASM) of which is:<br /><br /><pre><code><br />.text&#58;10001000&#58; 55                  	push 	ebp<br />.text&#58;10001001&#58; 8BEC                	mov 	ebp, esp<br />.text&#58;10001003&#58; 83EC10              	sub 	esp, 10<br />.text&#58;10001006&#58; C745F800000000      	mov 	dword ptr &#91;ebp-08&#93;, 00000000<br />.text&#58;1000100D&#58; 6834600010          	push 	10006034                                   ; 'ntdll.dll' <br /><br />; Reference to import LoadLibraryA - Ord&#58; 01C2h<br /><br />.text&#58;10001012&#58; FF1508500010        	call  	&#91;10005008&#93;<br />.text&#58;10001018&#58; 8945FC              	mov 	&#91;ebp-04&#93;, eax<br />.text&#58;1000101B&#58; 837DFC00            	cmp 	dword ptr &#91;ebp-04&#93;, 00<br />.text&#58;1000101F&#58; 7436                	je 	10001057<br />.text&#58;10001021&#58; 6830600010          	push 	10006030                                   ; 'abs' <br />.text&#58;10001026&#58; 8B45FC              	mov 	eax, &#91;ebp-04&#93;<br />.text&#58;10001029&#58; 50                  	push 	eax<br /><br />; Reference to import GetProcAddress - Ord&#58; 013Eh<br /><br />.text&#58;1000102A&#58; FF1504500010        	call  	&#91;10005004&#93;  ; reference to segment '.rdata'<br />.text&#58;10001030&#58; 8945F8              	mov 	&#91;ebp-08&#93;, eax<br />.text&#58;10001033&#58; 837DF800            	cmp 	dword ptr &#91;ebp-08&#93;, 00<br />.text&#58;10001037&#58; 7414                	je 	1000104d<br />.text&#58;10001039&#58; C745F0FFFFFFFF      	mov 	dword ptr &#91;ebp-10&#93;, ffffffff<br />.text&#58;10001040&#58; 8B4DF0              	mov 	ecx, &#91;ebp-10&#93;<br />.text&#58;10001043&#58; 51                  	push 	ecx<br />.text&#58;10001044&#58; FF55F8              	call  	&#91;ebp-08&#93;<br />.text&#58;10001047&#58; 83C404              	add 	esp, 04<br />.text&#58;1000104A&#58; 8945F4              	mov 	&#91;ebp-0c&#93;, eax<br />.text&#58;1000104D&#58;loc_1000104D&#58;<br />.text&#58;1000104D&#58; 8B55FC              	mov 	edx, &#91;ebp-04&#93;<br />.text&#58;10001050&#58; 52                  	push 	edx<br /><br />; Reference to import FreeLibrary - Ord&#58; 00B4h<br /><br />.text&#58;10001051&#58; FF1500500010        	call  	&#91;10005000&#93;<br />.text&#58;10001057&#58;loc_10001057&#58;	; Referenced 1 time&#40;s&#41;<br />.text&#58;10001057&#58; B801000000          	mov 	eax, 00000001<br />.text&#58;1000105C&#58; 8BE5                	mov 	esp, ebp<br />.text&#58;1000105E&#58; 5D                  	pop 	ebp<br />.text&#58;1000105F&#58; C20C00              	ret 	000c<br />.text&#58;10001062&#58;loc_10001062&#58;<br />.text&#58;10001062&#58; 8B442408            	mov 	eax, &#91;esp+08&#93;<br />.text&#58;10001066&#58; 83F801              	cmp 	eax, 01<br />.text&#58;10001069&#58; 0F8588000000        	jnz 	100010f7<br /><br /></code></pre><br /><br />I have not yet found a way to get BDASM to show me the format of the data (in the .rdata segment) that holds the key to being able to ?call [.rdata_address]?.  I have been looking through hex dumps of the binary image to try and make sense of it all.  I am about to try looking at hex dumps of kernel32.lib (static library for the functions provided by kernel32.dll).<br /><br />As to why I am doing this, I am writing an event logging system for a DLL to which I do not have the source code.  I am attempting to call the logging DLL functions from the main DLL, and the only way to modify this DLL is through disassemble/reassemble with BDASM/NASM.  I am sure this will be a snap, once I figure out how to call the Win32 APIs for loading and calling functions in an external DLL.</div>
    <div class="meta">Posted on 2004-08-31 12:25:01 by Randalism</div>
   </div>
   <div class="post" id="post-148856">
    <div class="subject"><a href="#post-148856">Call one DLL entry point from another DLL</a></div>
    <div class="body">In NASM, you can use the IMPORT statement to make an import in an OMF file.<br />The format is:<br />IMPORT symbol filename <br />If the exported name is omitted, it is assumed to be the same as the symbol assigned to to the import.<br />You have to declare these symbols as extern, with:<br />EXTERN symbol<br /><br />You can not have imports in COFF files.</div>
    <div class="meta">Posted on 2004-08-31 14:39:25 by Sephiroth3</div>
   </div>
   <div class="post" id="post-148903">
    <div class="subject"><a href="#post-148903">Call one DLL entry point from another DLL</a></div>
    <div class="body">Randalism, if you want to call DLL functions, it's either through implicit dynamic linking (use of import libraries, PE import section) or through runtime dynamic linking (LoadLibrary + GetProcAddress).<br /><br />There's some &quot;lower level&quot; ways of doing this, but it's somewhat dirty and platform-specific, and in your case it doesn't sound like there's a need for it.<br /><br />If you're going to call the DLL in a program that is already running, LoadLibrary and GetProcAddress is probably the best method.<br /><br />Here's a VERY simple nasm example, raw and unsugared, assuming that you're using Microsoft-style import libraries and the MS linker:<br /><br />nasm -fwin32 test.asm<br />link /subsystem:windows /entry:entry test.obj kernel32.lib<br /><br /><pre><code><br />BITS 32<br />SECTION .data<br /><br />hLibrary	dd	0<br />pProc		dd	0<br />szDllName	db	&quot;ntdll.dll&quot;, 0<br />szFuncName	db	&quot;abs&quot;, 0<br /><br />EXTERN	_FreeLibrary@4<br />EXTERN	_LoadLibraryA@4<br />EXTERN	_GetProcAddress@8<br />EXTERN	_ExitProcess@4<br /><br />GLOBAL	_entry<br /><br />SECTION .text<br /><br />_entry&#58;<br />	push	szDllName<br />	call	_LoadLibraryA@4<br />	mov		&#91;hLibrary&#93;, eax<br /><br />	push	szFuncName<br />	push	eax			; DLL handle<br />	call	_GetProcAddress@8<br /><br />	mov		&#91;pProc&#93;, eax<br />	push	dword -10<br />	call	eax			; ntdll&#58;abs<br /><br />	push	dword -20<br />	call	dword &#91;pProc&#93;<br /><br />	push	dword &#91;hLibrary&#93;<br />	call	_FreeLibrary@4<br /><br />	push	dword 0<br />	call	_ExitProcess@4<br /></code></pre></div>
    <div class="meta">Posted on 2004-09-01 05:03:18 by f0dder</div>
   </div>
   <div class="post" id="post-148929">
    <div class="subject"><a href="#post-148929">dirt!</a></div>
    <div class="body">f0dder,<br />Thanks for the source.<br /><br />Since I am using BDASM/NASM to assemble-on-the-fly, I can not use ?EXTERN? or other pre-linker notation.  I will have to perform the linking manually by crafting an .rdata-like segment (the DLL I am modifying has no .rdata segment), pasting it into the binary and somehow referencing it with a virtual address like ?[10005000]?.  I am still not sure of how to go about this, or why virtual addressing is necessary at all.<br /><br />I would happily receive any ?dirty? lower-level methods you could share with me.  I am basically working at the opcode level at this point.<br /><br />I found this in the .rdata segment (IMPORT Hints/Names &amp; DLL Names) of one of my own disassembled C programs (text data shown as text): <br /><br /><pre><code><br />B4 00 FreeLibrary 00<br />3E 01 GetProcAddress 00<br />C2 01 LoadLibraryA 00 00<br />KERNEL32.dll 00 00<br />&#40;other kernel32.dll functions?&#41;<br /></code></pre><br /><br />I thought it was interesting that the 3 kernel32.dll functions my C code calls are listed (in reverse order of the actual calls), followed by a double terminator (?\0\0?), the DLL name (?KERNEL32.dll?), another double terminator (?\0\0?) and a list of what seems to be all of the other entry points exported by kernel32.dll.  The 2-byte prefix of each imported function name matches the ?hint? ordinal exposed by the dependency walker (depends.exe) with kernel32.dll opened.<br /><br />Questions:<br /><ul>If I were to construct a data field, like the one above, could I use it to ?link? to any function exposed by another DLL (or does this methodology only apply to Win32 APIs)?<br />Where should I place it?  <br />How should I reference it (via a ?call? operation)?<br />Must it reside in an .rdata segment?<br />Is there a way to attach an .rdata segment to a binary PE file that currently does not have one?</div>
    <div class="meta">Posted on 2004-09-01 09:52:32 by Randalism</div>
   </div>
  </div>
 </body>
</html>