<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>FREE S** AND SOURCECODE - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=28739" />
  <link rel="prev" href="../?id=28739&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=28739">FREE S** AND SOURCECODE</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=28739&amp;page=1" style="">&laquo;</a><a href="../?id=28739&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="28739" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-203147">
    <div class="subject"><a href="#post-203147">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">Hi Homer<br />Based on your posted implementation, I rearranged some instructions and replaced others and got a speed boost of about 30% on my CPU<br /><br /><pre><code>OPTION PROLOGUE:NONE<br />OPTION EPILOGUE:NONE<br /><br />bin2dword proc pBuffer:Pointer<br />&nbsp; &nbsp; push ebx<br />&nbsp; &nbsp; xor eax, eax<br />&nbsp; &nbsp; xor edx, edx<br />&nbsp; &nbsp; mov ecx, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;pBuffer<br />&nbsp; &nbsp; lea ebx,  <br />align @WordSize<br />@@:<br />&nbsp; &nbsp; mov dl, byte ptr <br />&nbsp; &nbsp; cmp edx, 0<br />&nbsp; &nbsp; jz @F<br />&nbsp; &nbsp; cmp edx, &quot;b&quot;<br />&nbsp; &nbsp; jz @F<br />&nbsp; &nbsp; cmp ecx, ebx<br />&nbsp; &nbsp; jz @F<br />&nbsp; &nbsp; and dl, 1<br />&nbsp; &nbsp; shl eax, 1<br />&nbsp; &nbsp; or eax, edx<br />&nbsp; &nbsp; inc ecx<br />&nbsp; &nbsp; jmp @B<br />@@:<br />&nbsp; &nbsp; pop ebx<br />&nbsp; &nbsp; ret 4&nbsp;  <br />bin2dword endp<br /><br />OPTION PROLOGUE:PrologueDef<br />OPTION EPILOGUE:EpilogueDef<br /></code></pre><br /><br />Regards,<br /><br />Biterider<br /><br /></div>
    <div class="meta">Posted on 2007-10-06 00:19:33 by Biterider</div>
   </div>
   <div class="post" id="post-203148">
    <div class="subject"><a href="#post-203148">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">And here&#039;s my version, that improves 47% over the previous on my Sempron:<br /><pre><code><br />OPTION PROLOGUE:NONE<br />OPTION EPILOGUE:NONE<br />align 16<br />db 10 dup (90h)<br /><br />bin2dword2 proc pBuffer<br />	mov ecx,<br />	xor eax,eax<br />	align 16<br />again:	<br />	movzx edx,byte ptr<br />	inc ecx<br />	sub edx,48<br />	cmp edx,1<br />	ja done<br />	shl eax,1<br />	add eax,edx<br />	jge again<br />	done:<br />	<br />	<br />	ret 4<br />bin2dword2 endp<br /><br /><br />OPTION PROLOGUE:PrologueDef<br />OPTION EPILOGUE:EpilogueDef<br /></code></pre><br />It&#039;s just that it stops reading when eax becomes a 32-bit number (thus many trailing zeroes are skipped). </div>
    <div class="meta">Posted on 2007-10-06 04:40:36 by Ultrano</div>
   </div>
   <div class="post" id="post-203149">
    <div class="subject"><a href="#post-203149">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">And the qword:<br /><pre><code><br />OPTION PROLOGUE:NONE<br />OPTION EPILOGUE:NONE<br />bin2qword proc pBuffer ; returns value in eax:edx<br />	mov ecx,<br />	push ebx<br />	xor eax,eax<br />	xor edx,edx<br />	align 16<br />again:	<br />	movzx ebx,byte ptr<br />	inc ecx<br />	sub ebx,48<br />	cmp ebx,1<br />	ja done<br />	add eax,eax<br />	adc edx,edx<br />	or eax,ebx<br />	test edx,edx<br />	jge again<br />	done:<br />	<br />	pop ebx<br />	<br />	ret 4<br />bin2qword endp<br /><br />OPTION PROLOGUE:PrologueDef<br />OPTION EPILOGUE:EpilogueDef<br /></code></pre></div>
    <div class="meta">Posted on 2007-10-06 05:23:36 by Ultrano</div>
   </div>
   <div class="post" id="post-203152">
    <div class="subject"><a href="#post-203152">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">Hi<br />Ultranos code shows some very clever optimizations. However, using his code, tricking with the carry flag and unrolling it gives you another speed gain of 30 %.<br /><br /><pre><code>OPTION PROLOGUE:NONE<br />OPTION EPILOGUE:NONE<br /><br />NextChar macro<br />&nbsp; &nbsp; movzx edx, byte ptr <br />&nbsp; &nbsp; inc ecx<br />&nbsp; &nbsp; sub edx, &quot;0&quot;<br />&nbsp; &nbsp; cmp edx, 1<br />&nbsp; &nbsp; ja @F<br />&nbsp; &nbsp; rcl eax, 1<br />endm<br /><br />bin2dword3 proc pBuffer:Pointer<br />&nbsp; &nbsp; xor eax, eax<br />&nbsp; &nbsp; mov ecx, <br />&nbsp; &nbsp; not eax<br />&nbsp; &nbsp; repeat 32<br />&nbsp; &nbsp; &nbsp; NextChar<br />&nbsp; &nbsp; endm&nbsp; &nbsp; <br />@@:<br />&nbsp; &nbsp; not eax<br />&nbsp; &nbsp; ret 4<br />bin2dword3 endp<br /><br />OPTION PROLOGUE:PrologueDef<br />OPTION EPILOGUE:EpilogueDef</code></pre><br /><br />Regards,<br /><br />Biterider</div>
    <div class="meta">Posted on 2007-10-06 09:52:03 by Biterider</div>
   </div>
   <div class="post" id="post-203165">
    <div class="subject"><a href="#post-203165">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">Ok guys now its my turn, I haven&#039;t timed the proc and compared it to your results. But I don&#039;t think its as fast as yours anyway.<br />It will take a bin string of any length, up to 64 bits and greater than 0 bits in length.<br />It does&#039;nt need a special terminator, ie - 0 or b.<br />It returns the values in EDX:EAX, while ECX returns a -1 if the string length is 0 or<br />&gt;64.<br />A bin value sting of 32 bits or less returns a 0 in edx, and the value in eax.<br />A bin value string of greater than 32 bits, returns the high dword in edx, and the low<br />dword in eax.<br /><br />Here is the code:<br /><pre><code><br />OPTION PROLOGUE:NONE<br />OPTION EPILOGUE:NONE<br /><br /><br />Bin2Quad proc pBinString:dword<br />&nbsp; &nbsp; push esi<br />&nbsp; &nbsp; mov esi, <br />&nbsp; &nbsp; xor ecx, ecx<br />&nbsp; &nbsp; xor edx, edx<br />ImFeelingLoopy:<br />&nbsp; &nbsp; cmp byte ptr , &#039;1&#039;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; count the number of 1 or 0&#039;s in string<br />&nbsp; &nbsp; je CountIt<br /><br />&nbsp; &nbsp; cmp byte ptr , &#039;0&#039;<br />&nbsp; &nbsp; jne IAmDoneCounting<br /><br />CountIt:<br />&nbsp; &nbsp; add ecx, 1<br />&nbsp; &nbsp; jmp ImFeelingLoopy<br /><br />IAmDoneCounting:<br />&nbsp; &nbsp; or ecx, ecx<br />&nbsp; &nbsp; jz NotValidBinStr<br /><br />&nbsp; &nbsp; cmp ecx, 64<br />&nbsp; &nbsp; ja NotValidBinStr<br />DbgDec ecx<br />&nbsp; &nbsp; cmp ecx, 32<br />&nbsp; &nbsp; jbe DoDWord<br />DbgDec ecx<br /><br />&nbsp; &nbsp; sub ecx, 32&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; get number of high dword bits to do<br /><br />CheckHighBits:<br />&nbsp; &nbsp; jecxz ImaDoneCheckingtheHighBits<br />&nbsp; &nbsp; cmp byte ptr , &#039;1&#039;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; set the carry and rotate it in if a one, else<br />&nbsp; &nbsp; jne @F&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; rotate in a zero<br /><br />&nbsp; &nbsp; stc<br />&nbsp; &nbsp; jmp SetTheBit<br /><br />@@:<br />&nbsp; &nbsp; clc<br />SetTheBit:<br />&nbsp; &nbsp; rcl edx, 1<br />&nbsp; &nbsp; sub ecx, 1<br />&nbsp; &nbsp; add esi, 1<br />&nbsp; &nbsp; jmp CheckHighBits<br /><br />ImaDoneCheckingtheHighBits:<br />&nbsp; &nbsp; mov ecx, 32&nbsp; &nbsp;  ; must be a full 32 bit lo-dword, since we had a high dword<br /><br />DoDWord:<br />&nbsp; &nbsp; xor eax, eax<br /><br />CheckLowBits:<br />&nbsp; &nbsp; jecxz ImaDoneCheckingtheLowBits<br /><br />&nbsp; &nbsp; cmp byte ptr , &#039;1&#039;&nbsp; &nbsp; &nbsp;  ; set the carry and rotate it in if a one, else<br />&nbsp; &nbsp; jne @F&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; rotate in a zero<br /><br />&nbsp; &nbsp; stc<br />&nbsp; &nbsp; jmp SetTheBit2<br /><br />@@:<br />&nbsp; &nbsp; clc<br />SetTheBit2:<br />&nbsp; &nbsp; rcl eax, 1<br />&nbsp; &nbsp; sub ecx, 1<br />&nbsp; &nbsp; add esi, 1<br />&nbsp; &nbsp; jmp CheckLowBits<br /><br /><br />NotValidBinStr:<br />&nbsp; &nbsp; mov ecx, -1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Bin string either too long or too short-<br />&nbsp; &nbsp; jmp @f&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; ie: 0 bit length or &gt;64 bit length<br />ImaDoneCheckingtheLowBits:<br />&nbsp; &nbsp; xor ecx, ecx<br />@@:<br />&nbsp; &nbsp; pop esi<br />&nbsp; &nbsp; ret 4<br /><br />Bin2Quad endp<br />OPTION PROLOGUE:PrologueDef<br />OPTION EPILOGUE:EpilogueDef</code></pre><br /><br />Comments welcome :)<br /><br />Rags</div>
    <div class="meta">Posted on 2007-10-06 19:19:03 by rags</div>
   </div>
   <div class="post" id="post-203185">
    <div class="subject"><a href="#post-203185">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">LOL I am glad we all had fun optimizing code that is called so rarely :)<br />Work continues on the grammar engine.<br />I am hardcoding the &#039;grammar used to describe grammars&#039; - ie, I am writing code which recognizes and responds to the very finite language (that being my grammar config file format, which is plaintext based) used to define the behaviour of the interpreter by describing desirable input patterns and appropriate responses.<br />The RuleLearner class object is derived from StatementParser.<br />Its job is to read a grammar descriptor file, and build from it a set of Grammar Rules.<br /><br />Grammar Rules are chains of Terminal and/or NonTerminal Nodes.<br />Each Node is a reference to either a plaintext Term (Terminal), or a reference to a Rule (NonTerminal). SELF-references are allowed!<br />For example, the following rule:<br /><br />&lt;args&gt; ::= &lt;arg&gt; &#039;,&#039; &lt;args&gt; | &lt;arg&gt;<br /><br />Look apon the Pipe character as being a delimiter of acceptable variants.<br />The example Rules says &quot;ARGS is a set of comma-delimited arguments, or, just one argument&quot;.<br />Can you see that this Rule contains a reference to itself?<br /><br />I am developing the code that performs a non-iterative walk to allow for this kind of pattern matching. For those who may not be aware, this self-referencing concept was developed by a mathematician called KLEENE.. its called a Kleene star (a reference to wildcard patternmatching), or a Kleene escape.<br /><br /><br /></div>
    <div class="meta">Posted on 2007-10-09 02:19:42 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=28739&amp;page=1" style="">&laquo;</a><a href="../?id=28739&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="28739" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>