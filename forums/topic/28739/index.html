<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>FREE S** AND SOURCECODE - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=28739" />
    <link rel="next" href="../?id=28739&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=28739">FREE S** AND SOURCECODE</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=28739&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=28739&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="28739" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=28739&amp;page=2">&gt;</a><a href="../?id=28739&amp;page=2">&raquo;</a></form>   <div class="post" id="post-203058">
    <div class="subject"><a href="#post-203058">FREE S** AND SOURCECODE</a></div>
    <div class="body">Now that I have your attention :P<br /><br />Attached is the sourcecode for a new OA32 Object.<br />It&#039;s a BaseClass, you&#039;re meant to derive specializations from it, which I have, and can demonstrate, but I digress.. this class is for PARSING INPUT FILES.<br />It does not give a hoot about structure, its a glorified byte fetcher.<br />Support for massive files is built in, and there&#039;s two modes of operation.<br />You can choose from &quot;PUSH&quot; and &quot;PULL&quot; modes.<br /><br />When you choose &quot;push&quot; (driving) mode, everything is automagical.<br />The main entry fuinction (ParseFile) won&#039;t return until the whole file is parsed.<br />All the input characters are presented to a dynamic &#039;onParseChar&#039; method, which you would redefine in your derived classes.. I degined this thing with &quot;push&quot; mode in mind as default, and added &quot;pull&quot; mode as an afterthought.<br /><br />In &quot;pull&quot; (driven) mode, ParseFile returns immediately, and you must make repeated calls to ParsenextChar until it returns NULL. In this case, &#039;onParseChar&#039; is NOT automatically called for you.. its up to you what to do with each character you parse.<br /><br />If you like this code, buy me a beer.<br />And if you have any bug reports, feature requests, or criticisms, let me know :)<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2421" target="_blank">Parser.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-09-25 06:00:12 by Homer</div>
   </div>
   <div class="post" id="post-203063">
    <div class="subject"><a href="#post-203063">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">Thanks for the new object Homer, I&#039;ll definitely have a use for it.<br />Next time I&#039;m in OZ, I&#039;ll buy you that beer. Last time I was there was in<br />1986, so you might have a little wait. :lol:<br /><br /><pre><code>bFeedMeSeymour</code></pre>&nbsp; :lol: Little shop of Horrors?<br /><br />Rags</div>
    <div class="meta">Posted on 2007-09-25 08:30:46 by rags</div>
   </div>
   <div class="post" id="post-203065">
    <div class="subject"><a href="#post-203065">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body"><br />no free sex ? i&#039;ve been fooled!<br /><br /></div>
    <div class="meta">Posted on 2007-09-25 10:02:04 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-203068">
    <div class="subject"><a href="#post-203068">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">Thanks to this post I now have a terrible rash!&nbsp; :shock:</div>
    <div class="meta">Posted on 2007-09-25 15:32:54 by madprgmr</div>
   </div>
   <div class="post" id="post-203071">
    <div class="subject"><a href="#post-203071">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body"><div class="quote">no free sex ?</div><br /><br />- What is love?<br />- Love was invented by russians to not pay money<br /><br /><em>a very old anecdote</em> :)</div>
    <div class="meta">Posted on 2007-09-26 03:54:44 by Shoo</div>
   </div>
   <div class="post" id="post-203072">
    <div class="subject"><a href="#post-203072">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">Since there&#039;s at least a passing interest in this code, I will offer to post a derived class for parsing of plaintext which utilizes the other dynamic handlers - it collects LINEFEED-delimited &quot;statements&quot;, supports the use of a &quot;multiline delimiter&quot; (like MASM), manages a database of unique &#039;Terms&#039; (where a Term is a WhiteSpace delimited &#039;word&#039; from a Statement), and where each Statement is represented by a collection of references to unique Terms, and strips extraneous whitespace, comments and empty lines from the input stream.<br /><br />I am playing with this code at the moment in regards to my quirky cross-assembler project, but I have generalized everything into useful, reusable modules because like anyone, I get sick of writing the same code again and again ...<br />So far I&#039;ve used the &quot;StatementParser&quot; class in a GUI demo which builds a &#039;Sentence Tree&#039;, whose structure is based on the Statements collected from a sourcecode input file.<br />I don&#039;t seriously intend to use this Tree in this form, but I thought it was interesting to see an entire sourcecode presented in a visual Tree form, while being &#039;compressed&#039; in regards to duplicate Terms.<br /><br />So I offer both - a Statement parser derived from the Parser baseclass, and an odd little demo that uses it.<br />Put up your hand if you like free stuff :)<br /><br />And yes Rags, you are correct about the reference to LSOH.<br />Some of my peers complain about having trouble inventing meaningful names for things.<br />I don&#039;t see the problem, just get your sense of humour out and use it :P<br /><br /></div>
    <div class="meta">Posted on 2007-09-26 08:46:01 by Homer</div>
   </div>
   <div class="post" id="post-203076">
    <div class="subject"><a href="#post-203076">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">My Hands are up. :D</div>
    <div class="meta">Posted on 2007-09-26 12:15:14 by rags</div>
   </div>
   <div class="post" id="post-203079">
    <div class="subject"><a href="#post-203079">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">Attached are two files.<br />StatementParser is an OA32 Object which derives from Parser, as described previously.<br />Its main job is to collect Statements and tag them with the File and LineNumber from which they were sourced, and get rid of WhiteSpace and Comments, but it does a fair bit more.<br /><br />NOTE !!&nbsp; the Dynamic Methods in Parser, such as onParseChar, are &#039;directly&#039; replaced with the new ones in this class, so that while Parser.ParseFile THINKS it is calling Parser.onParseChar, it is in fact now calling StatementParser.onParseChar instead :)<br />The Ancestor is driving its Descendant. Thats confusing at first, but you&#039;ll get over it ... <br /><br />Each Statement is represented by a collection of Terms, and the Terms themselves are represented by Tokens, where a Token is a container struct, similar to a Statement.<br />StatementParser will attempt tag each Token (each Term) with a value which loosely represents its Type.<br />The Types handled natively by StatementParser are : Decimal, Hex, Binary, Floating Point, Operator, and &quot;Other&quot;.<br />Operator includes anything that is made of one or more non alphanumeric characters, like &quot;!=&quot;<br />Other implies that we could not (yet) determine the Type of Term (implying that we might be able to do so at a later stage).<br />If we positively identify a Term as any kind of Immediate Value, we tag the Token with that Value, and if we can&#039;t identify the Term as being a Value, we store a pointer to the Term string (within the collection of unique Terms).<br /><br />The second attached file is called &#039;Helpers&#039;, and contains the functions required to identify the natively handled Term types and some other junk.<br /><br />I won&#039;t post the demo app just yet as I want to clean it up.. you probably don&#039;t NEED to see these objects implemented in order to use them?? .. at the moment it implements a third tier Parser object called RuleLearner that knows how to read my Grammar Rules from my custom text file, and I don&#039;t want to post that object at this point in time, as I am far from happy with it.<br /><br />In fact I&#039;m not happy with this one either - if anyone wants to rework it I ask that you repost it here, I&#039;ll be working on the RuleLearner class, and a new ancestor for the Parser class called something like &#039;FormatRecognizer&#039;.. its job is to discern between ascii and utf-8 at parse-time.<br />Currently, Parser only supports 8 bit ASCII.<br />I believe I can, with very few changes, support UTF-8 and ASCII in the same framework, noting that UTF-8 supports characters UP TO 32 bits wide, consuming all of the wide formats in its wake.<br />Having said that, handling input stream conversions from other wide formats to UTF-8 is a piece of cake, so all the formats can be supported by wrapping the front with yet another layer.<br /><br />Anyway, I&#039;m more interested in the top end of the machine at the moment, ie grammar analysis and response, I&#039;ll fiddle with the input stage more as I go, and post updates periodically.<br /><br /><br />I just realized that I didn&#039;t finish implementing all the Types, cuz I had yet to (re)write functions to convert eg StringToFloat, but easy enough to complete that</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2423" target="_blank">StatementParser.inc</a></li>
      <li><a href="../../attachments/?id=2424" target="_blank">Helpers.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-09-27 03:37:33 by Homer</div>
   </div>
   <div class="post" id="post-203080">
    <div class="subject"><a href="#post-203080">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">I found a few little bugs in StatementParser, but nothing that will prevent it from operating, bugs related to the identification of term types.<br /><br />Not happy with the scheme used for multi-line statements and the general assumption that a LineFeed marks the end of a Statement by default.<br />Might let the user set up optional delimiters which trigger calls to user callbacks or something.<br /><br />Not happy with the naiive collecting of non-alphanumerics into Terms.<br />Theres some exceptions that we&#039;d rather not have the parser join up theses characters.<br />Its ok to think of, say, &quot;!=&quot; or &quot;::&quot; that way, but stuff like Braces should always be single character, yes?<br />We don&#039;t wanna interpret &quot;((&quot; as a single Term, we wanna see it as two Braces.<br /><br />Thoughts?</div>
    <div class="meta">Posted on 2007-09-27 11:46:25 by Homer</div>
   </div>
   <div class="post" id="post-203081">
    <div class="subject"><a href="#post-203081">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body"><div class="quote"><br />I found a few little bugs in StatementParser, but nothing that will prevent it from operating, bugs related to the identification of term types.<br /><br />Not happy with the scheme used for multi-line statements and the general assumption that a LineFeed marks the end of a Statement by default.<br />Might let the user set up optional delimiters which trigger calls to user callbacks or something.<br /></div><br /><br />In what way are you collecting tokens? How I did it, is to take lines of text ending on Linefeed, turn them in to tokens, and any of those lines that have &quot;\&quot; as the last token forces the scanner to read the next line and append to the token list.<br /><br /><div class="quote"><br />Not happy with the naiive collecting of non-alphanumerics into Terms.<br />Theres some exceptions that we&#039;d rather not have the parser join up theses characters.<br />Its ok to think of, say, &quot;!=&quot; or &quot;::&quot; that way, but stuff like Braces should always be single character, yes?<br />We don&#039;t wanna interpret &quot;((&quot; as a single Term, we wanna see it as two Braces.<br /><br />Thoughts?<br /></div><br /><br />I&#039;d rather see &quot;((&quot; as two Parenthesis :P<br /><br />Depends on how you intend to use such tokens later on. For generic purposes, I would say to keep non-alphanumerics that have no distinction as separate entities.</div>
    <div class="meta">Posted on 2007-09-27 12:47:07 by SpooK</div>
   </div>
   <div class="post" id="post-203085">
    <div class="subject"><a href="#post-203085">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">Homer,<br /><br />I&#039;ve only really glanced over this thread a few times as, you know me I avoid OOP like the plague, but in the case of &#039;((&#039; and &#039;!=&#039; style parsing I believe we discussed this some time ago. To refresh you on my stance, and to catch the board up as well, I believe that it would be best not to catch such items as singular tokens as you are doing, rather have the user setup a sub parser for token handler &#039;!&#039; which sets flag for &#039;=&#039; as next token, this flag should be cleared by your primary parser if it reads a whitespace token before obtaining the &#039;=&#039; token. If the whitespace token is obtained a callback can be used to allow &#039;!&#039; (or whatever) to continue processing and return to the primary parser before handling the just read (or soon to be read) following token. This way you only have handlers for the ones you implement, the others get dealt with as normal singular tokens. I&#039;m not sure how you could do this modularly, but you&#039;re a smart guy, I&#039;m sure you could figure it out.<br /><br />Also, a small optimization on that method (as just a quick thought I&#039;m having atm) instead of using the normal procedure to change states, it might be worth just setting up a call table containing &#039;token&#039;, offset of single token handler, offset to special case token handler, and the flag. This could possibly be done as a class (I&#039;m trying to think modularly here, work with me :p). The table/child class/whatever could be used to preform a quick and dirty fast scan upon obtaining one of the single character tokens. If the token is present in the table, save it&#039;s index somewhere, update it&#039;s flag,&nbsp; then do the normal check for the next character. On space call the &#039;single token handler&#039; from the table, if not you call the &#039;special case token handler&#039;. In the instance of a child class (or child of Collections) the two handlers would be virtual methods that could be redefined by the user and a static method to set the token.. you&#039;d also need a list of it&#039;s &quot;special cases&quot; in there somewhere, can&#039;t forget about that.<br /><br />Sorry if all of that is kinda skatter brained.. I started out just refreshing on an old discussion and before I hit post I started actually thinking about it and just typed as I thought. Hope it still makes since after I post it. ;)<br /><br />Regards,<br />Bryant Keller</div>
    <div class="meta">Posted on 2007-09-27 16:54:13 by Synfire</div>
   </div>
   <div class="post" id="post-203091">
    <div class="subject"><a href="#post-203091">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">You said sub parser, I was avoiding that.<br /><br />Some other parsers are designed with subclasses for handling things as inane as one particular character, thats just dumb and wasteful and template-bloated.<br /><br />I believe we can handle specific cases in a dynamic way, without resorting to the &#039;urge to over-oop&#039; which is displayed by some highlevel programmers. There is a break-even point where the overheads of OOP outweigh its benefits, and that point can only be reached via clinically poor design premises and ignorant implementations. OOP is only bad to you if you abuse it, and over-engineering is the main problem there.<br /><br />So, we want to be able to describe and handle arbitrary conditions at any &#039;layer&#039; of the parsing machine? I suggest that the best solution would be to introduce a class whose purpose is to &#039;register&#039; conditions and their handlers, via one or more &#039;contracts&#039; (the obvious one being that the method param format must be vanilla, and flexible).<br /><br />I know Biterider has played around with the notion of registered functional callbacks in the past, in this case we&#039;re also registering a Condition which should trigger them, that Condition being described as a Grammar Rule.<br /><br />On another note:<br />I have decided that I absolutely do not need to detect LineFeeds.<br />The parser can produce , from the input ByteStream, a stream of Tokens.<br />We can deduce Statements from the Token Stream via grammar analysis, with no linefeeds, like some HLLs use, we can do that for ANY language.<br />We just need to watch the token stream for matching Grammar Rules.<br />If we don&#039;t find them, its a Syntax Error.<br />And if we do, we can create a &#039;rule-ified&#039; version of the input by substituting matching sequences for rule references, and at some point, that &#039;rule-ified&#039; version should perfectly match some complex Rule (complete statement parsed), or partially match one or more complex Rules (statement parse in progress), or otherwise again we have a Syntax Error.<br /><br />Some rules will have Semantic Actions associated with them, and they are carried out linearly.<br /><br />I took a closer look at YACC.<br />Man, it&#039;s a top-down recursive parser with infinite lookahead, just like I have been describing (&quot;sentence tree&quot;).<br />Not only are my ideas solid, but everything I have coded lately has been done before.<br />Version 1 of XASM turns out to be a &#039;PackRat Interpreter&#039;, despite my best efforts to remain detached from any specific implementation pathway.<br /><br />Well, I&#039;m now more determined to do stuff differently just to be different :|</div>
    <div class="meta">Posted on 2007-09-28 05:18:59 by Homer</div>
   </div>
   <div class="post" id="post-203094">
    <div class="subject"><a href="#post-203094">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body"><div class="quote">You said sub parser, I was avoiding that.</div><br /><br />I also said a small optimization on that would be to use whatever normal procedure you are using for tokenizing to preform the state changes and use a type of state call table. You are right, sub parsers are more the norm in the HL method of development and that&#039;s mostly because in HL design you want to try and seperate things so that it&#039;s &quot;easier to find&quot;. But in this case, you will gain much better preformance by using a table of known first tokens; &#039;!&#039;, &#039;=&#039;, &#039;&lt;&#039;, &#039;&gt;&#039;, &#039;+&#039;, &#039;^&#039;, etc. an associated flag and the required callback. For example:<br /><br /><pre><code>XASM_MSCT STRUCT<br />&nbsp; &nbsp; lpIdentifier DD&nbsp; &nbsp; ?&nbsp;  ; Pointer to a string for the token<br />&nbsp; &nbsp; dwCondition&nbsp; DD&nbsp; &nbsp; ?&nbsp;  ; State change flag, gets updated when you <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; see the token (set to 1) and if it&#039;s followed by a space (set to 0)<br />&nbsp; &nbsp; lpfnCallback DD&nbsp; &nbsp; ?&nbsp;  ; The callback handler for the identifiers.<br />XASM_MSCT ENDS</code></pre><br /><br />That&#039;s an overly simplified idea of it, changes can (and most likely should be) made to that structure to better suite your design. Anyways, basic idea is still the same, the procedure that finds the &#039;!&#039; characters puts it into XASM_MSCT.lpIdentifier then sets XASM_MSCT.dwCondition to a true state. The next character is read from the token stream. If that character is a whitespace (or any other kind of delimiter that isn&#039;t accepted to follow the first token) the XASM_MSCT.dwCondition is set to false and XASM_MSCT.lpfnCallback is called to handle the, until now, unhandled token. The XASM_MSCT.lpfnCallback routine uses an argument of it&#039;s index in the table to be able to look up the XASM_MSCT.dwCondition value (or that value can be passed directly, personal preference really) so it preforms the proper actions. When the procedure pointed to by XASM_MSCT.lpfnCallback completes it returns to the procedure that read the last token so it can either continue processing that token or start over by reading a new character (which it will need to if XASM_MSCT.dwCondition was set to true). Best way to do that would be to set EAX to XASM_MSCT.dwCondition before clearing the value of XASM_MSCT.dwCondition at the end of the XASM_MSCT.lpfnCallback procedure then returning to let the parser check the return value to know if it should start over based on EAX being true or false.<br /><br />As you can see, using that second method there is no need for OOP at all. I did suggest using a child class or collection but truth is there is no real reason to use OOP, that was more for your benefit since I figured you were already doing so much of the project in OOP you might decide to make that part more modular as well. Like for instance, if someone wanted to derive various parts of it to change the conditions to their liking. Say for example if they prefer the VB style &#039;&lt;&gt;&#039; instead of &#039;!=&#039; they could modify that. Personally though I wouldn&#039;t go through the trouble, I say let them mod the table if they want that stuff. Or possibly create a method within your current object which gives users the option to update the table (even at runtime if need be). Can&#039;t ask for more dynamic than that. Erm, if you are going to do that you might want to make it into a linked list instead of a normal table, just to be safe.. but for normal processing a table would be suitable.<br /><br /><div class="quote">Well, I&#039;m now more determined to do stuff differently just to be different</div><br /><br />Good, there is always a need for originality. While you are searching through different compiler construction tools, you might want to check out <a target="_blank" href="http://www.gnu.org/software/bison/">Bison</a> and <a target="_blank" href="http://www.hwaci.com/sw/lemon/">Lemon</a>. Those two are fairly popular as well.<br /></div>
    <div class="meta">Posted on 2007-09-28 13:47:17 by Synfire</div>
   </div>
   <div class="post" id="post-203102">
    <div class="subject"><a href="#post-203102">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">I think I should describe parser behavious within my Syntax File (where the Grammar Rules live).<br />I can introduce a few at the beginning to be used while parsing the Grammar Rules themselves, and then at the end describe the &#039;default&#039; parser behaviours to be used for parsing the given source language.<br />IE, the parser behaviours can be described as &#039;inline switches&#039; within the Syntax File.<br /><br />When my parser object parses a Syntax File, it can modify its own behaviour based on the &#039;Parser Switches&#039; it sees, and retain the state of those switches when it completes, leaving it in a fit state for parsing Language X files.<br /><br />Now I don&#039;t need to specialize my Parser for this or that task, I need to Train it at Parse time.<br />And if we wished to switch parser contexts WHILE parsing an input file, for example to parse INLINE ASM in C, we can create a Grammar Rule whose semantic action is &#039;directly mess with Parser switches&#039;, or alternatively, &#039;include a Syntax File which contains a set of Parser Switch statements&#039;<br /><br />What you think?<br /></div>
    <div class="meta">Posted on 2007-09-30 03:55:25 by Homer</div>
   </div>
   <div class="post" id="post-203109">
    <div class="subject"><a href="#post-203109">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">That sounds fine. Not sure it&#039;s the most optimal solution but it does give the most flexability. And in this case flexability is much more important I suppose. I think I&#039;m a little confused, is this part of XASM? In other words, are you going to be loading the grammar files at runtime to handle compile/script some managed code? Or is this just part of a distributable object? I&#039;m just wondering because the more we discuss it, the more &quot;selective&quot; (for lack of a better term) it&#039;s becoming. ;)</div>
    <div class="meta">Posted on 2007-09-30 16:06:14 by Synfire</div>
   </div>
   <div class="post" id="post-203110">
    <div class="subject"><a href="#post-203110">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">Obviously I intend to use it for XASM, but I have other things on my mind also.<br />In particular, I plan to implement a game console which allows the developer to view and edit the private fields of arbitrary objects at runtime, to script the behaviours of objects, etc.<br /></div>
    <div class="meta">Posted on 2007-09-30 17:49:58 by Homer</div>
   </div>
   <div class="post" id="post-203124">
    <div class="subject"><a href="#post-203124">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">Attached is a small update of the StatementParser object.<br /><br />Several small bugs squished.<br />Behavior has been changed slightly.. any &#039;Special&#039; (non-alphanumeric) symbol such as a Brace or Math Operator is now treated as a Term in its own right, with the exception of the &quot;.&quot; period character.<br />I allow this character to appear as part of a Term.<br />This is done by omitting it from the hardcoded szTermDelims string.<br />A future update may allow the user to elect a set of &#039;Special&#039; characters.<br />If the Period is not allowed to be part of a Term, we cannot identify Terms of FloatingPoint Type.<br />I retained the ability (from XASM v1) to detect various Types of Terms, and to do so &#039;loosely&#039;.<br />For example, Hex values can use a C Prefix (0x) or an Asm Suffix (h) (or both!), and FloatingPoint values can have a &quot;f&quot; suffix, or you can omit it, provided there is a Period.<br /><br />Example: &quot;.IF Axx!=30.0&quot; is delimited into Terms as follows:<br />.IF<br />Axx<br />!<br />=<br />30.0<br /><br />As Bryant pointed out, I was beginning to specialize this code a little too much, handling of special sequences such as &quot;!=&quot; should be performed at a later stage.<br /><br />XASM v1&#039;s parser was adept at picking out special sequences of non alphanumeric characters, but it was very much geared toward parsing ASM sourcecode, it was very specific and not at all generic.<br />I have moved this implementation away from XASM v1 and made it more flexible, at the cost of extra memory and processing overhead during the analysis phase.<br /><br />Statements are now being Tokenized as I had planned.<br />Each plaintext input term is represented by a Token struct, and tagged with a Type.<br />This struct contains a pointer to a Term string, stored as a unique Lexeme.<br />Each plaintext input statement is represented by a Statement struct, and tagged with a LineNumber and SourceFile.<br />This struct contains a collection of Tokens, as well as a copy of the entire plaintext input string.<br />When you call StatementParser.Init, it builds a collection of Statement structs representing the entire sourcecode, and then returns to its caller.<br /><br />The only other change I&#039;d like to make so far is to add an option to handle LineFeeds differently, because we might want to parse a &#039;block language&#039; like C, where statements are TYPICALLY multiline and delimited by &#039;bookend&#039; context decorations.<br />But that can be done by the User in their Derived object.<br />I would recommend redefining onParseLine and onParseTerm methods.<br />If you redefine onParseLine with a dummy method that does nuffin, the Current Statement will never be Collected into the pStatements collection.<br />And similarly, you can change the way Terms are handled by redefining onParseTerm.<br />None of this will alter the tracking of Line Numbers, which is done by onParseChar.<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2429" target="_blank">StatementParser.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-10-03 02:08:01 by Homer</div>
   </div>
   <div class="post" id="post-203125">
    <div class="subject"><a href="#post-203125">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">Another small update - the Token struct&#039;s Value union was extended to handle real8 (64bit) floating point values.<br />a2fp function header now properly protects kludged registers.<br />The only &#039;Term Type&#039; not being handled correctly now is &#039;Binary&#039;.<br />Would anyone care to supply functions to convert from BinaryString to dword (or better yet, qword) and back again? It&#039;s an easy and fun thing to code :)<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2430" target="_blank">a2fp.inc</a></li>
      <li><a href="../../attachments/?id=2431" target="_blank">fp2a.inc</a></li>
      <li><a href="../../attachments/?id=2432" target="_blank">StatementParser.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-10-03 03:58:27 by Homer</div>
   </div>
   <div class="post" id="post-203127">
    <div class="subject"><a href="#post-203127">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">Hi<br />for the last proc, look at dword2bin.asm in the OA32 code library.<br /><br />Regards<br /><br />Biterider</div>
    <div class="meta">Posted on 2007-10-03 15:24:40 by Biterider</div>
   </div>
   <div class="post" id="post-203130">
    <div class="subject"><a href="#post-203130">Re: FREE SEX AND SOURCECODE</a></div>
    <div class="body">Thats a nice implementation! But I really needed the counterpart (ascii string to dword / qword) at this time :P<br /><br />Since we don&#039;t know the string length, we have to bytescan :|<br />I am limiting the length to 32 bits here.<br />Arbitrarily longer conversions can be performed as batches of 32 bits.<br />This version ignores the ASM suffix &#039;b&#039; if it is found.<br />It assumes that the characters are only &#039;0&#039; and &#039;1&#039; (30h and 31h), and simply checks sign of bit zero.<br /><br /><pre><code><br />;Convert binary string (up to 32 chars) into binary value (up to 32 bits)<br />;Returns eax=binary value, ecx=#Bits<br />bin2dword proc uses ebx pBuffer<br />	xor eax,eax	<br />	xor ecx,ecx<br />	xor edx,edx<br />	mov ebx,pBuffer<br />	;First, find End of String<br />	.while byte ptr!=0 &amp;&amp; byte ptr!=&quot;b&quot;<br />		.break .if ecx==32	<br />		shl eax,1	;this does nothing the first time, since edx=0<br />		<br />		mov dl,byte ptr<br />		and dl,1<br />		jz @F<br />		or al,1<br />	@@:	<br />		inc ebx<br />		inc ecx<br />	.endw<br />	ret<br />bin2dword endp<br /></code></pre><br /><br /></div>
    <div class="meta">Posted on 2007-10-04 09:01:27 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=28739&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=28739&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="28739" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=28739&amp;page=2">&gt;</a><a href="../?id=28739&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>