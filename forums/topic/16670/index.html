<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>EAT Hack - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16670" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=16670">EAT Hack</a></p>
   <div class="post" id="post-129521">
    <div class="subject"><a href="#post-129521">EAT Hack</a></div>
    <div class="body">Heya all..<br />here's a source for a harmless little hack I'm trying to get working, I intend to use it as part of a security scheme for my game engine.. can anyone see what I'm doing wrong here?<br /><br /><pre><code>.586<br />.model flat,stdcall<br />option casemap&#58;none<br />include \masm32\include\windows.inc<br />include \masm32\include\user32.inc <br />includelib \masm32\lib\user32.lib            <br />include \masm32\include\kernel32.inc <br />includelib \masm32\lib\kernel32.lib<br /><br />return macro pp&#58;REQ<br />mov eax,pp<br />ret<br />endm<br />;==========================================================<br />.data<br />szFunc db &quot;MessageBoxA&quot;,0<br />LibName db &quot;USER32.DLL&quot;,0<br />szHeh  db &quot;Everybody was Kung-Fu Fighting&quot;, 0<br />IDTADDR        db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br /><br />;==========================================================<br />.data?<br />hInstance dd ?<br />HackLib dd ?<br />HackProc dd ?<br />AddressToHack dd ?<br />ValToWrite dd ?<br />nextsehptr dd ?<br />origsehptr dd ?<br />seherrhandler dd ?<br />exception dd ?<br />oldoffset dd ?<br />ValueToWrite dd ?<br />;==========================================================<br />.code<br />;This is our fake function code, the example given below will alter<br />;the title of a message box which has been called with MessageBoxA<br />FakeFunc&#58;<br />            push ebp                      ; procedure prelude&#58; save old base ptr<br />            mov ebp, esp               ; and create new stack frame<br />            push 0                          ; place a null byte onto stack<br />            lea eax, szHeh            ; eax = address of new title string<br />            push dword ptr&#91;ebp-20&#93;<br />            push eax                               ; push address of new title string<br />            push dword ptr&#91;ebp-12&#93;<br />            push dword ptr&#91;ebp-8&#93;            <br />            call MessageBoxA;     call MessageBoxA<br />            pop ebp                  ;   get old stack base<br />            ret 16                      ;  return to caller<br /><br />;==========================================================<br />;This proc allocates a wad of globally accessible memory and copies the hook code into it<br />PlantFakeFunc proc FakeFuncBase&#58;DWORD<br />LOCAL FakeFuncSize&#58;DWORD<br />        lea eax,szHeh             ;   Calculate the size of our fake function <br />        lea ebx, FakeFunc<br />        sub eax, ebx<br />        mov FakeFuncSize, eax<br />;   Allocate the required memory for it in shared memory so all processes can access it <br />;   Replace the real<br />        invoke VirtualAlloc, FakeFuncBase, FakeFuncSize, MEM_COMMIT or MEM_RESERVE, PAGE_EXECUTE_READWRITE<br />        mov FakeFuncBase,eax<br />         .if eax == NULL             <br />                return FALSE<br />        .endif<br />;   Copy the fake function into newly allocated shared memory <br />        invoke RtlMoveMemory,FakeFuncBase, addr FakeFunc, FakeFuncSize<br />        return TRUE<br />PlantFakeFunc ENDP<br />;===================================================================<br />;This procedure attempts to find the address of a function in the Export Table of a loaded DLL image.<br />;It returns the address of the function in memory.<br />FindRealProcAddy proc pTargetLib&#58;PTR BYTE,pTargetApi&#58;PTR BYTE<br /> LOCAL baseAddress&#58;DWORD<br /> LOCAL fred&#58;ptr DWORD<br /> LOCAL tom&#58;PTR DWORD<br /> LOCAL bob&#58;PTR WORD<br /> LOCAL pIED&#58;PTR IMAGE_EXPORT_DIRECTORY<br /><br />         mov fred,0<br />;Get the base address of our target library as it appears in virtual memory<br />        invoke GetModuleHandle, pTargetLib <br />        mov baseAddress ,eax<br />        .if baseAddress == NULL            <br />                jmp quit<br />        .endif<br />;Simply go through the PE header and get addr of Export Address Table...<br />      	mov eax, baseAddress	            ; move imagebase into eax<br />	 cmp word ptr&#91;eax&#93;, 'ZM'                     ; check if we have a exe image<br />	 jne quit		                        ; exit if we dont<br />	 add eax, 3Ch  		            ; eax = pointer to pe header offset<br />	 mov ebx, &#91;eax&#93;		            ; get the pointer<br />	 add ebx, baseAddress	            ; add to image base to align it<br />	 cmp word ptr&#91;ebx&#93;, 'EP'                      ; check if we have a pe image<br />	 jne quit		                        ; exit if we dont<br />	 add ebx, 78h		                        ; eax = pointer to virtual address of export dir address<br />	 mov ecx, &#91;ebx&#93;		            ; ecx = virtual address of export dir address<br />	 add ecx, baseAddress	            ; add imagebase to ecx to align<br />             mov pIED, ecx<br />        <br />;This code will scan through the export table and find the VirtualAddress<br />;of our targt func and then return its addr in mem<br />            xor ecx,ecx<br />            mov ebx,pIED<br />            .while ecx&lt;&#91;ebx&#93;.IMAGE_EXPORT_DIRECTORY.NumberOfFunctions            <br />                push ecx<br />                shl ecx,2<br />                add ecx,baseAddress<br />                mov ebx,pIED<br />                add ecx,&#91;ebx&#93;.IMAGE_EXPORT_DIRECTORY.AddressOfNames <br />                mov tom , ecx<br />                add ecx,baseAddress<br />                invoke lstrcmp,ecx, pTargetApi <br />                .if eax==0                    <br />                        pop ecx<br />                        push ecx<br />                        shl ecx,1   <br />                        add ecx,baseAddress<br />                        mov ebx,pIED<br />                        add ecx,&#91;ebx&#93;.IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals <br />                        mov bob,ecx<br />                        pop ecx<br />                        shl ecx,2<br />                        add ecx,baseAddress<br />                        add ecx,&#91;ebx&#93;.IMAGE_EXPORT_DIRECTORY.AddressOfFunctions <br />                        mov fred,ecx<br />                        jmp quit<br />                .endif<br />                pop ecx<br />                inc ecx<br />                mov ebx,pIED<br />            .endw<br />quit&#58;     return fred<br />FindRealProcAddy endp<br />;=========================================================================<br />start&#58;<br />invoke GetModuleHandle,NULL<br />mov hInstance,eax<br />invoke LoadLibrary,addr LibName<br />mov HackLib,eax                                                                                     ;Returns  the Base Address of the DLL<br />invoke GetProcAddress, HackLib,addr szFunc<br />mov HackProc,eax                                                                                   ;Returns the Virtual Address of the Function<br />invoke FindRealProcAddy,HackLib,HackProc<br />mov AddressToHack,eax                                                                     ;Returns the REAL Address of the Function<br />lea eax,FakeFunc                                                                                 ;Point to start of Hook<br />sub eax, hInstance                                                                                 ;Subtract THIS IMAGE Base Address<br />mov ValToWrite,eax                                                                               ;Remember the offset of the Hook code<br />invoke PlantFakeFunc,addr FakeFunc<br /><br />;Hacking Original SEH pointer... <br />assume fs&#58;nothing<br />;PUSH FS&#58;&#91;0&#93; <br /><br />mov eax, fs&#58;&#91;0&#93;<br />mov nextsehptr, eax; set in structure<br />mov origsehptr, eax             ; save it<br />lea eax, return_to_host                   ; change it to our code<br />mov seherrhandler, eax      ; ...<br />mov eax, nextsehptr                          ; ...<br />mov fs&#58;&#91;0&#93;,eax             ; replace the structure<br /><br />;Hacking Interupt Discriptor Table... <br />               sidt IDTADDR                                          ; get interrupt discriptor table addr<br />                lea esi,IDTADDR<br />                lea esi, dword ptr &#91;esi+2&#93;              ; first 2 bytes are the length<br />                add esi, 4*8                                            ; get the offset for our int 4<br />                mov exception,esi                                  ; save exception place<br />                mov bx, word ptr &#91;esi+6&#93;                        ; get the low word<br />                shl ebx, 10h                                             ; shift it left<br />                mov bx, word ptr &#91;esi&#93;                            ; and get the high word<br />                mov dword ptr &#91;oldoffset&#93;, ebx              ; save exception offset<br />                lea eax, Ring0                                   ; eax is our new software interupt func<br />                mov word ptr &#91;esi&#93;, ax                            ; store the high word<br />                shr eax, 10h                                            ; shift it right<br />                mov word ptr &#91;esi+6&#93;, ax                       ; and store the low word<br />            <br />;this means that when we do int 4 we will go to our code &#40;at ring0&#41; ;&#41;<br />;Going Into Ring0...           <br />                mov eax, AddressToHack  ; eax = the address which holds the va of the exported func<br />                mov ebx, ValueToWrite     ;ebx = the address we wish to change it to so it points to our FakeFunc<br />                int 4                                    ; generate the interupt so we drop to Ring0<br /><br />;Restoring Original IDT And SEH Pointer... ;&#41;                      <br />                mov esi, exception              ; restore the IDT address<br />                mov ebx, oldoffset              ; restore exception offset<br />                mov word ptr &#91;esi&#93;, bx                           ; restore the exception<br />                shr ebx, 10h                                          ; shift it left<br />                mov word ptr &#91;esi+6&#93;, bx                       ; put it back<br />return_to_host&#58;<br />                mov eax, origsehptr          ; eax = the old SEH pointer<br />                mov fs&#58;&#91;0&#93;,eax                   ; restore it            <br />die&#58;          invoke ExitProcess,0<br />                return 0<br />            <br />;==========================================================<br />Ring0&#58;                  ; THIS CODE EXECUTES AT RING0 <br />                            ; EAX = Address To Write To<br />                            ; EBX = Value To Write<br />   mov dword ptr&#91;eax&#93;, ebx                 ; change the export address<br />   iretd                                                 ; return to Ring3<br />            <br />;==========================================================<br />end start</code></pre></div>
    <div class="meta">Posted on 2004-01-01 11:17:20 by Homer</div>
   </div>
   <div class="post" id="post-129538">
    <div class="subject"><a href="#post-129538">EAT Hack</a></div>
    <div class="body">Hrm... haven't looked to much at your code, but there seems to be a couple of problems from reading the comments:<br /><br />&quot;Allocate the required memory for it in shared memory so all processes can access it&quot; - there's no such thing on win32. It's sorta available on 9x, but definitely not NT.<br /><br />Hacking the IDT is a bad bad bad idea - and you should only be able to get away with it under 9x. On NT, it will be considered a security break, and if you can get away with it, it will be fixed in a service pack.<br /><br />If you really need ring0 for some silly 'security', do it like the 'respectable' companies do it - VXD/KMD. And good luck finding a generic win32 method of allocating global shared memory ;)</div>
    <div class="meta">Posted on 2004-01-01 15:09:50 by f0dder</div>
   </div>
   <div class="post" id="post-129543">
    <div class="subject"><a href="#post-129543">EAT Hack</a></div>
    <div class="body"><div class="quote"><br />it will be fixed in a service pack.</div><br />Are you sure? (I think they'll just relocate it, you know it's probably a feature (a design choise, you know ActiveX can more more than java because it's not in a sandbox, right?))<br /><br />If you're up for playing with the IDT, why make your own OS ;)</div>
    <div class="meta">Posted on 2004-01-01 15:41:12 by scientica</div>
   </div>
   <div class="post" id="post-129544">
    <div class="subject"><a href="#post-129544">EAT Hack</a></div>
    <div class="body"><div class="quote"><br />If you're up for playing with the IDT, why make your own OS ;) </div>Hardware drivers come to mind - these companies are running a racket, scratching each others backs while sleeping in the same bed. :) <strong>EvilHomer2k</strong>, should just sit back and wait for DRM to take hold then use the API. :(</div>
    <div class="meta">Posted on 2004-01-01 15:50:33 by bitRAKE</div>
   </div>
   <div class="post" id="post-129573">
    <div class="subject"><a href="#post-129573">EAT Hack</a></div>
    <div class="body">I'll try implanting it in a DLL, that should make it globally accessible under NT as well, right? ;) All I'm trying to do is find a way to generically hook a known function in a DLL which is already loaded.. without using the hook api.</div>
    <div class="meta">Posted on 2004-01-01 23:20:50 by Homer</div>
   </div>
   <div class="post" id="post-129596">
    <div class="subject"><a href="#post-129596">EAT Hack</a></div>
    <div class="body">Homer,<br />Some errors I noticed<br /><pre><code><br />FakeFunc&#58;<br />            push ebp                      ; procedure prelude&#58; save old base ptr<br />            mov ebp, esp               ; and create new stack frame<br />            push 0                          ; place a null byte onto stack<br />            lea eax, szHeh            ; eax = address of new title string<br />            push dword ptr&#91;ebp-20&#93;<br />            push eax                               ; push address of new title string<br />            push dword ptr&#91;ebp-12&#93;<br />            push dword ptr&#91;ebp-8&#93;            <br />            call MessageBoxA;     call MessageBoxA<br />            pop ebp                  ;   get old stack base<br />            ret 16                      ;  return to caller<br /></code></pre><br />should be<br /><pre><code><br />FakeFunc&#58;<br />            push ebp                      ; procedure prelude&#58; save old base ptr<br />            mov ebp, esp               ; and create new stack frame<br />            push 0                          ; place a null byte onto stack<br />            lea eax, szHeh            ; eax = address of new title string<br />            push dword ptr&#91;ebp+20&#93;<br />            push eax                               ; push address of new title string<br />            push dword ptr&#91;ebp+12&#93;<br />            push dword ptr&#91;ebp+8&#93;            <br />            call MessageBoxA;     call MessageBoxA<br />            pop ebp                  ;   get old stack base<br />            ret 16                      ;  return to caller<br /></code></pre><br />Also your code will break at &quot;mov bx, word ptr &quot; with the error memory not accessible or something like on nt if I am not wrong... Since your main aim is to break into ring0 from ring3 by editing the interrupt table, I would suggest you take a look at the following: <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=15001">http://www.asmcommunity.net/board/index.php?topic=15001</a></div>
    <div class="meta">Posted on 2004-01-02 05:52:14 by roticv</div>
   </div>
   <div class="post" id="post-129618">
    <div class="subject"><a href="#post-129618">EAT Hack</a></div>
    <div class="body">Wow, I'm impressed you remember that thread :)<br />I just want to add some precisions. The method in that thread doesn't edit the IDT, but the GDT, though it could easily be modified to edit the IDT. And be careful with the source in that thread, it is full of bugs and very very unstable...</div>
    <div class="meta">Posted on 2004-01-02 14:03:28 by Chrishka</div>
   </div>
   <div class="post" id="post-129621">
    <div class="subject"><a href="#post-129621">EAT Hack</a></div>
    <div class="body"><div class="quote"><br />I'll try implanting it in a DLL, that should make it globally accessible under NT as well, right?<br /></div><br />Nope, DLLs are loaded per-process - as they should be.<br /><br /><div class="quote"><br />All I'm trying to do is find a way to generically hook a known function in a DLL which is already loaded.. without using the hook api.<br /></div><br />This takes quite some work - you're trying to do a global API hook, right? It's not too bad on 9x afaik, but on NT... argh. Take a look at the microsoft detours project, and read the docs - it outlines some of the problems etc.</div>
    <div class="meta">Posted on 2004-01-02 14:16:42 by f0dder</div>
   </div>
  </div>
 </body>
</html>