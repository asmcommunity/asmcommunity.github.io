<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>The MASM32 OOP model.. (Framework) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=1142" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=116">Windows</a> &raquo; <a href="../?id=1142">The MASM32 OOP model.. (Framework)</a></p>
   <div class="post" id="post-7464">
    <div class="subject"><a href="#post-7464">The MASM32 OOP model.. (Framework)</a></div>
    <div class="body">Okee, no need to blabber, so i will get to the point:<br /><br />Our model is solely based around using <strong>STRUCTURES</strong>.   Every class <strong>is</strong> a structure.. (so dont forget this!).  Our model uses some needed macro's (which i will explain l8r), in particulare, the MACRO called &quot;CLASS&quot;.<br /><pre><code>CLASS NewClass<br />  ...<br />  ..<br />ENDS</code></pre><br /><br />The class macro actually starts the begining of the structure, via its scripting.  So when you read &quot;CLASS&quot; as shown, just think, &quot;its a structure called 'NewClass' &quot;<br /><br /><br />If your ok at this point your doing great! :)<br /><br /><strong>Now the class structure has some specific points that need mentioning:</strong><br /><br />- 1 - Methods always come first in class definitions (make inheritance work smooth)<br /><br />- 2 - The first method entry MUST be a destructor method! (this is always true, even if you think it isnt, as inheritance provides a seemingly special case)<br /><br />- 3 - Methods are always 32 bit DWORDs in the structure. (They hold the FUNCTION POINTER to the method in question ~ 32 bit address).<br /><br />- 4 - All Variables follow the methods.  Just like any old variable your use to sticking in any other structure.  NOTHING NEW HERE.<br /><br /><br />With another macro, we easily define methods in the class structure with &quot;CMETHOD&quot; macro.  Here is an example Class:<br /><pre><code>CLASS MyClass<br />  CMETHOD destructor<br />  CMETHOD getNumber<br />  CMETHOD setNumber<br />  theNumber   dd   ?<br />ENDS<br /></code></pre><br /><br />This class will have three methods, and one variable.<br /><br /><br /><strong>What is a method?</strong><br /><br />Methods are quite simply PROC's.  They are defined in asm as PROC's!  We just call them &quot;methods&quot; because its a high level lingo.  <strong><em>METHODS == PROCS</em></strong>.<br /><br />The thing that makes OOP unique, is that the &quot;methods&quot; are written to act ONLY on the variables found within the class. You by no way are resticted to this, since we are ASM programmers, and could access some global value just like a PROC, but you would loose the re-usable simplicity of objects.  You would now have a condition to provide for, the global varible, in re-using this class in future projects. Bottom line, unless you feel advanced with Objects, i urge you to keep all needed variables spelled out in the class structure (such as the above &quot;theNumber&quot; dword variable).<br /><br />Another major asset to Objects is code re-use!  A method is writen to work on itself.  WHy? for created class instances.<br /><br />An instance of a class is the &quot;incantation&quot; if you will of actually creating a space in memory for your &quot;instance&quot; of the Class.   REMEMBER, a class is only a structure!! Stuctures are only templates! They dont take up memory!.  <strong>To instanciate a class into an object, memory is allocated dynamically off the heap, determined by the size of the class structure!.  These allocated bytes is the &quot;instance&quot;.</strong>  In this case, 3 methods = 3*4 bytes, and 1 variable dword = 1*4 bytes, makeing 16 bytes in total for every instance!<br /><br />Example time:<br /><br />Say i create 3 instances of the above class.  This means, at run time, i dynamically allocate 3 groups of bytes 16 bytes, off the heap. <br /><br />Say the method &quot;setNumber&quot; points to this proc:<br /><pre><code><br />setNumberFunction PROC lpTHIS&#58;DWORD, ANumber&#58;DWORD<br /> <br />  mov &#40;myClass PTR &#91;lpTHIS&#93;&#41;.theNumber, ANumber<br />  ret<br /><br />setNumberFunction ENDP</code></pre><br /><br />The above &quot;lpTHIS&quot; is the address of &quot;THIS INSTNACE's group of bytes&quot;.  So its written above to use the passed address of &quot;some&quot; instance (lpTHIS), and then use the class structure definition to offset to the &quot;theNumber&quot; variable, and set it with the value passed to the function (ANumber).<br /><br />This method function doesnt &quot;know&quot; really what its working on!! Its written to only know that it will work on ITSELF!, and uses the lpTHIS to help itself out.<br /><br />So when i have 3 instances, the above method code (actual proc) will service each instance individually.  And thus keep each instance UNIQUE.  This means i can set one instance to have the number 3,  the second to number 0Ah, and the third to 7!, and each will remember in their specific memeory group, the stored number.<br /><br /><strong>In practice, and adhearing to our model, the above conversation would become this:</strong><br /><pre><code><br />.data?<br />  hInstance1 dd ?<br />  hInstance2 dd ?<br />  hInstance3 dd ?<br /><br />.code<br />  ; allocate MyClass &#40;16 bytes&#41; from the heap, and save<br />  ; the address in &quot;hInstance1&quot;<br />  mov hInstance1, $NEW&#40; MyClass &#41;  <br /><br />  mov hInstance2, $NEW&#40; MyClass &#41;<br />  mov hInstance3, $NEW&#40; MyClass &#41;<br /><br />&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  HEAP MEMORY &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br /><br />hInstance1&#58; xx xx xx xx  ;  destructor pointer<br />            xx xx xx xx  ;  getNumber pointer<br />            xx xx xx xx  ;  setNumber pointer<br />            00 00 00 00 ;  theNumber variable<br /><br />hInstance2&#58; xx xx xx xx  ;  destructor pointer<br />            xx xx xx xx  ;  getNumber pointer<br />            xx xx xx xx  ;  setNumber pointer<br />            00 00 00 00 ;  theNumber variable<br /><br />hInstance3&#58; xx xx xx xx  ;  destructor pointer<br />            xx xx xx xx  ;  getNumber pointer<br />            xx xx xx xx  ;  setNumber pointer<br />            00 00 00 00 ;  theNumber variable<br /><br />&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  BACK TO CODE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br /><br />  ; METHOD is a macro that works like invoke.<br />  ; Param1 == InstanceHandle &#40;address, which is lpTHIS&#41;<br />  ; Param2 == Class Type of the Instance &#40;to use the struct&#41;<br />  ; Param3 == method to call<br />  ; Param+ == method parameters other than the lpTHIS<br /><br />  METHOD hInstance1, MyClass, setNumber, 3 <br />  METHOD hInstance2, MyClass, setNumber, 0Ah<br />  METHOD hInstance3, MYClass, setNumber, 7<br /><br />&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  HEAP MEMORY &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br /><br />hInstance1&#58; xx xx xx xx  ;  destructor pointer<br />            xx xx xx xx  ;  getNumber pointer<br />            xx xx xx xx  ;  setNumber pointer<br />            03 00 00 00 ;  theNumber variable &#40;little endian&#41;<br /><br />hInstance2&#58; xx xx xx xx  ;  destructor pointer<br />            xx xx xx xx  ;  getNumber pointer<br />            xx xx xx xx  ;  setNumber pointer<br />            0A 00 00 00 ;  theNumber variable &#40;little endian&#41;<br /><br />hInstance3&#58; xx xx xx xx  ;  destructor pointer<br />            xx xx xx xx  ;  getNumber pointer<br />            xx xx xx xx  ;  setNumber pointer<br />            07 00 00 00 ;  theNumber variable &#40;little endian&#41;<br /><br />&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  BACK TO CODE &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br /></code></pre><br /><br />While i can create 1000 instances, there will always be only ONE set of method functions.  No more, and they will work on every instance uniquely!  This saves exe code size in big projects!!! as only the method code is writen into the exe.  Everything else is dynamically alocated!, and dynamically processeded with FUNCTION pointers to these methods.<br /><br />Some of you may think this radically new, some may think this is how objects work..  Im sorry but i dont want to leave any assumptions.  <br /><br />Also, some may be wondering what the bytes 'xx' are set to.  They are set when the NEW$() macro gets called to point to the proper methods.  I will explain this tomorrow, as well as why the destructor comes first in all classes.  I will try to analyse an actually compiled class for you.  (the above was simplified somewhat, an will not compile as is).<br /><br />Please.. give feedback.. questions.. am i too fast/slow.. anything not making sense??<br /><br />NaN</div>
    <div class="meta">Posted on 2001-09-18 19:07:18 by NaN</div>
   </div>
   <div class="post" id="post-7467">
    <div class="subject"><a href="#post-7467">The MASM32 OOP model.. (Framework)</a></div>
    <div class="body">Now you have me interested. I especially like this part:<br /><br /><strong>- 1 - Methods always come first in class definitions (make inheritance work smooth) <br /><br />- 2 - The first method entry MUST be a destructor method! (this is always true, even if you think it isnt, as inheritance provides a seemingly special case) <br /><br />- 3 - Methods are always 32 bit DWORDs in the structure. (They hold the FUNCTION POINTER to the method in question ~ 32 bit address). <br /><br />- 4 - All Variables follow the methods. Just like any old variable your use to sticking in any other structure. NOTHING NEW HERE.</strong> <br /><br />I like the ridgid structure.  Probably easier to find bugs that way.<br /><br />C++ should have the same type of restrictions, IMO.  Encapsulate everything into classes so no one can see what a mess they are.</div>
    <div class="meta">Posted on 2001-09-18 19:37:22 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-7471">
    <div class="subject"><a href="#post-7471">The MASM32 OOP model.. (Framework)</a></div>
    <div class="body">Nice interface, but I have one query.<br /><br />Wouldn't it save you memory to place the function ptrs in a virtual table since you only need one set of function ptrs per class. The first entry in the class structure would be a vtable ptr and the first entry in the vtable would be the destructor.<br /><br />Inheritance would still work as the class would inherit from the base class and the vtable would inherit from the base class vtable.</div>
    <div class="meta">Posted on 2001-09-18 21:52:47 by Maelstrom</div>
   </div>
   <div class="post" id="post-7481">
    <div class="subject"><a href="#post-7481">The MASM32 OOP model.. (Framework)</a></div>
    <div class="body">This is something i am still thinking thru.  I realize the current model could be more optomal, but for r&amp;d purposes it keeps things more readable and contained.  <br /><br />I have a working &quot;vtable&quot; solution as well, but there is some quirks with superclassing, and polymorphism, however your right, inheritance in general is working.  As well, there needs to be two more structures defined for each class to make it all work, with proper inheritance, AND proto type checking all around.<br /><br />One structure is for heap allocation.   One structure for vtable offsets.  One structure for CMETHOD's (proto type pointing).<br /><br />The heap struc would then be just variables.<br /><br />The vtable offsets are just this, stored in .data.<br /><br />The proto struct is for using Invoke:<br /><br />invoke ( proto_struct.fucnt ptr ).funct, lpHeapData<br /><br />The vtable and the proto structs need to be parallels of each other.   As well, the vtable is real, written to exe.  But the proto struct is only compile level info.  Lots of wierd things going on, which *definitely* wouldn't be attractive to follow by manual editing, expecially if some people are learning this first time thu.  <br /><br /><br />BUT, if i can get the bumps out over the coming months, i will definitely move this way, to save the memory allocated.<br /><br /><br />(( Im surprised this was the second message :) ,  its the only loose end im still pondering over ))<br /><br />NaN</div>
    <div class="meta">Posted on 2001-09-19 02:35:51 by NaN</div>
   </div>
   <div class="post" id="post-7504">
    <div class="subject"><a href="#post-7504">The MASM32 OOP model.. (Framework)</a></div>
    <div class="body">NaN mentioned 'superclassing' can someone explain this please?</div>
    <div class="meta">Posted on 2001-09-19 06:07:28 by Maelstrom</div>
   </div>
   <div class="post" id="post-7528">
    <div class="subject"><a href="#post-7528">The MASM32 OOP model.. (Framework)</a></div>
    <div class="body">Im borrowing the term from java.<br /><br />When you inherit something, you take on their methods.  Polymorphism is where you alter an inherited method to do something different, when called from the class that inherited it.<br /><br />Superclassing is where you decided i want to actually call the SUPER (origionally unaltered method), from within a polymorphic method of the same name.<br /><br />Hard to explain, so i do it simply like this:<br /><pre><code><br />  Class A<br />     MEHTOD -&gt; giveMeANumber<br />  ENDS<br /><br />  GiveMeANumber_Function Proc ...<br />      return &#40; 5 &#41;<br />  endp<br /><br />&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br /><br />  Class B Inherits Class A<br />       A &lt;&gt;<br />  ENDS<br /> <br />  OVERRIDE giveMeANumber WITH offset NEW_GiveMe<br /><br />  NEW_GiveMe Proc ...<br />        return&#40;6&#41;<br />  ENDP<br /><br />&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br /><br />Now if you call&#58;<br />   &quot;A.giveMeANumber&quot; you will get a 5.<br />   &quot;B.giveMeANumber&quot; you will get a 6.<br /><br />This is polymorphism.<br /><br />What if i wanted to further my code re-use,<br />by using already copiled code from Class A&#58;<br /><br />  NEW_GiveMe Proc ...<br /><br />     ; calls the super class &#40;A&#41;<br />     SUPER&#40; giveMeANumber &#41;<br /><br />     add eax, 1      <br />     return &#40;eax&#41;   ; still returning a 6!<br /><br />  ENDP<br /></code></pre><br />This is what im calling &quot;superclassing&quot; by re-using inherited method code (A.getMeANumber), and still altering the final result for methods that are polymorphic (B.getMeANumber).<br /><br /><br />Hope this helps...<br /><br />NaN</div>
    <div class="meta">Posted on 2001-09-19 12:12:01 by NaN</div>
   </div>
   <div class="post" id="post-7538">
    <div class="subject"><a href="#post-7538">The MASM32 OOP model.. (Framework)</a></div>
    <div class="body">*keeps reading, because this is so interesting...*<br /><br />Now, I apologize ahead of time, for my lack of understanding, but I have a question: What if you were to have a class that performed in a different way, like this:<br /><br /><br />class myclass {<br />parent: //what this unit belonges to<br />(id, x, y, z) world // parent to world class<br />id dd ?<br />x real4 ?<br />y real4 ?<br />z real4 ?<br /><br />functions: // what units can do<br />createunit<br />(real4, real4) moveunit<br />(int) modifyunit<br />(real4, real4, real4, int) shootunit //unit shoots at a vector with what<br />clearunit //clear unit from memory, after he is blown up<br />unitpropflags dd ? //these are the flags to the unit telling what type it is.<br /><br />children:<br />wheels<br />turret<br />}<br /><br />So when I create the world, the world has its own properties, but then when I make a unit from my template above, the unit belongs to a world using the id, and sets its existance up. I then call createunit, and the unit not has a 3d mesh because I created a vertex buffer for it, and other things like that to render it.<br /><br />Once I've established the unit, I can tell the unit moveunit(204,304), and this unit will move from it's current location to the new location over time (not instantanous). I can also tell the unit to fire and give it a vector, this fire code will modify the child of turret as it's getting ready to fire, or fireing, just the same as a move command would modify the wheel child to spin depending where the unit is going.<br /><br />But, to further that, the functions are inhereted ALSO. My move command will require some AI, so now that function becomes a child the AI class, and AI now has one more thing to calculate when called.<br /><br />-------------------------------<br /><br />Ok, this was a horrible example, but do you kind of get what I'm getting at?</div>
    <div class="meta">Posted on 2001-09-19 13:04:59 by Kenny</div>
   </div>
   <div class="post" id="post-7550">
    <div class="subject"><a href="#post-7550">The MASM32 OOP model.. (Framework)</a></div>
    <div class="body">I know what your outlining, but Im not sure if i got your question.<br /><br />With our current model, you CAN inherit from only ONE parent class, per class.  But nothing is stopping you to USE any number of other classes.  <br /><br />As im reading it, i would have your base &quot;tank&quot; class as you discribe it, USE an IA class for moving, USE an DDRAW class to draw the tank moving, USE a WORLD class to manage global positions etc. <br /><br />Now if you wanted to build a BETTER tank, I would INHERIT from &quot;tank&quot; and get all the goodies that tank already has, and build more features into this new &quot;better_tank&quot; class.<br /><br />With polymorphism, you can also OVERRIDE the &quot;fire&quot; method inherited from tank, and provide code that would 'fire-better' than its parent's code.  All the while having the same method name for both. (fire).<br /><br />Am i helping here?<br /><br />NaN</div>
    <div class="meta">Posted on 2001-09-19 16:03:46 by NaN</div>
   </div>
   <div class="post" id="post-7551">
    <div class="subject"><a href="#post-7551">The MASM32 OOP model.. (Framework)</a></div>
    <div class="body">I mean: is it possible, or am I setting myself up for a LOT of work to be able to make a framework like that without bugs?<br /><br />What the final code would do is this:<br />Go through the topmost class and just work its way down the line to all the children, and as it does that, it updates everything in the game, and then renders it.<br /><br />Wait, I just confused myself. I DON'T KNOW WHAT I'M ASKING lol :)</div>
    <div class="meta">Posted on 2001-09-19 16:09:42 by Kenny</div>
   </div>
   <div class="post" id="post-7553">
    <div class="subject"><a href="#post-7553">The MASM32 OOP model.. (Framework)</a></div>
    <div class="body">Wait, ok just give me some thoughts on it then because I'm really scatter brained. Has something like this been done before, where a class modifies another class, where the class might be a parent to a certain class, but not to a different one.<br /><br />Wow, ok my brain hurts now. I'm still trying to figure out the whole point of this gay class thing. Is it for code reuse, or faster code write?<br /><br />You know what, lemme think on this one a little more. I'm pretty dense when it comes to this area, but I'm trying my HARDEST to understand :)</div>
    <div class="meta">Posted on 2001-09-19 16:17:17 by Kenny</div>
   </div>
   <div class="post" id="post-7561">
    <div class="subject"><a href="#post-7561">The MASM32 OOP model.. (Framework)</a></div>
    <div class="body">Kenny<br /><br />The main advantages of classes (IMO) are:<br /><br />1. Code reuse.<br />2. Inheritance - which allows you to extend the capabilities of a class while still making use of the existing code base.<br />3. Polymorphism - which gives you the ability to perform different actions using the same interface.<br />4. Code maintanence.<br /><br />So don't give up, I found classes confusing when I started.<br /><br />NaN<br /><br />How do you handle 'superclassing' with your model?<br /><br />Using the vtable version, you would have to call the base function by using the vtable of the base class, but that would require making the vtables global or storing the base vtable ptr with the class.<br /><br />:confused:</div>
    <div class="meta">Posted on 2001-09-19 17:44:24 by Maelstrom</div>
   </div>
   <div class="post" id="post-7568">
    <div class="subject"><a href="#post-7568">The MASM32 OOP model.. (Framework)</a></div>
    <div class="body">Ahhh, FINALLY I get to see it. <br />Dang, now all I need is the time to study it.<br /><br />A few minor points:<br /><br />MSVC and several other major C++ compilers all place the vtable inside the object. Thus, each instance of the class (or each object) carries the memory to hold another instance of the vtable, a vtable identical to every other instance of that class.<br /><br />The real reason why is not apparent, however, I'm sure lots of clever fellows found some reason for this, probably pertaining to instancing inherited classes. It seems an object is assembled by running the constructor of the most inherited class (the baseest one), and out to the outer inheriting class.<br /><br />Keep in mind C++ supports both single AND multiple inheritance on every level.<br /><br />(OK, a small voice in the back of my head keeps saying &quot;but they still only need ONE vtable!  That is true, but may not be worth the work effort to save a few bytes) (FEW bytes? Didn't you read appendix A of &quot;Essential COM&quot;?)<br /><br /><br />Other things:<br /><br />1. Code reuse<br /><br />Ugh... Fragile base classes. Not a good idea.<br /><br /><br /> <br />2. Inheritance - which allows you to extend the capabilities of a class while still making use of the existing code base. <br /><br />Actually, inheritance comes in two forms. Interface inheritance, and implimentation inheritance. Implimentation inheritance is what is usually meant, where the base class gives some of the methods, and in inheritor gives others. The problem here is since a class is a 'black box' of functionality, one never knows if the base class method shold also be invoked after (or before) the inherited method is run. (That's the classic 'fragile base class.')<br /><br /><br /><br />3. Polymorphism - which gives you the ability to perform different actions using the same interface. <br /><br />From my understanding, polymorphism means different classes can support similar methods, which may have different functions. So while a cDocument object and a cPicture object may both have a .Print method that causes the printer to waste more paper, it's doubtfull that a cElephant's object and the cAutomobile object's<br />.Move method have anything in common.<br /><br /><br /><br />4. Code maintanence. <br /><br />Actually, I don't think classes have anything to add to this. Code is tough to maintain period (although COM objects (which are C++ objects in fancy clothes) may help end the 'dll hell' problem).</div>
    <div class="meta">Posted on 2001-09-19 20:30:59 by Ernie</div>
   </div>
   <div class="post" id="post-7574">
    <div class="subject"><a href="#post-7574">The MASM32 OOP model.. (Framework)</a></div>
    <div class="body">Kenny... stick with it :) , your on the right track! (Basically, a Manager class to manage all things that are to be painted on the screen, each thing (object) will inherit from a comon interface (PaintMe), thus thu polymorphism, the manager wont need to know if its drawing a tank, or a person, when going thu its list of objects, and telling each of them 'paint!')<br /><br />Ernie,  thanx for the CPP news, as it sides a bit with our model.  To be honest, this entire project had ZERO research and all R&amp;D.  Im sure i re-invented the wheel somewhere, i wanted to see if i could do it based on grey matter alone (with Thomas' help of couse).  Currently every instance, gets a copy of the needed function pointers within themselves.<br /><br /><br />Maelstrom, its a bit complicated.. i planned on hitting this issue further down the road.. but here is an early attempt. <br /><br />You have to think, WHEN?  When do you need to SUPERCLASS a method?  A. when your within a polymorphic method!   If not you got access by inheritance.   <br /><br />There is no point in externally SUPERCLASSING... makes no sence.  You only superclass within a class method definition.  SOOO, as the class is being compiled, it already KNOWS what the inheriting class is (!KEY!).  Knowing where the method sits in the INHERITED class, i can determin an offset, from some base.  And since each class pointer table is labeled systematically, based on its class name, i can get the BASE from the .data segment, regardless if there is any instances.<br /><br />So this is how i find the offset, and where to 'base' from, once an instance has been overridded polymorphicly.<br /><br />NaN<br /><br />PS:  I got a shit load of work dumped on me this week, by my course supervisor :( . To quote him, &quot;<em>..oh, i forgot about you guys, i should have had you in last week. Hmm, oh well, heres last week's stuff and this week's stuff.. have it ready for next week</em>&quot;.   So long story short, i got alot of researching to do, and may have to make these conversations a bit more sparce.  I dont know Thomas' schedual, but he may add to the conversation, as he understands the model as well as I.  (oh.. and no new post tonight or tomorrow... will try for friday!!! Sorry.... )</div>
    <div class="meta">Posted on 2001-09-20 00:04:25 by NaN</div>
   </div>
   <div class="post" id="post-7602">
    <div class="subject"><a href="#post-7602">The MASM32 OOP model.. (Framework)</a></div>
    <div class="body">I haven't worked much with C++ and COM although I do know they use a vtable. I think the problem with the vtable will be the implementation in masm. I tried to follow Visual C's assembler ouput on some very simple classes I created to see what happens when a member of an inherited class is overwritten by a new class.<br />It seems that the vtable will still contain both addresses, one with the original function (for superclassing), and one for the new function. Problem here is that it's the C compiler that desides which one to use on a certain method call, and this is much harder in MASM because we have to do that with macros..<br />But I may be wrong, I haven't read that much about COM and C++..<br />I am thinking of writing a small tutor about using objects.inc.. I'll try but no promises yet.. <br />NaN explained the basics pretty good so far. :alright: <br /><br />Thomas</div>
    <div class="meta">Posted on 2001-09-20 08:57:07 by Thomas</div>
   </div>
   <div class="post" id="post-7636">
    <div class="subject"><a href="#post-7636">The MASM32 OOP model.. (Framework)</a></div>
    <div class="body">Unfortunately I don't have much time right now to do a full tutor but I managed two write two examples today..<br />I'll try to comment them some day and write something about them, but for those who can't wait, here they are.<br />The first example creates a CSprite class, which can display a sprite on some DC. It shows the general use of a class.<br />You don't have to look at all the files, the codeparts.asm file, CSprite.asm, and drawproc.asm file contain all important stuff, the rest is just standard window creation and setting up DCs.. <br />It shows a bunch of smilies on a window that all move randomly.<br />The second example demonstrates inheritance and superclassing. A new class is created, called CSmiley. This class inherits from CSprite so it has all the basic functions of a sprite, but in addition it can let the sprite leave footprints when enabled... Herefore it overrules the 'draw' method of the CSprite class, by first superclassing it's original method (i.e. it calls the original draw proc from CSprite), but then adding it's own code to put the footsteps on a footstepDC (another DC that is drawn as background on the backbuffer). Polymorphism is not illustrated but you can do that yourself, just try to replace 'CSmiley', into 'CSprite' (the original), but only in the drawing procedure. It will still work, as a CSmiley object is also a CSprite object (because it inherits from it), so you are able to treat it that way.<br />That's about it, sorry for the missing comments in the source code, but at least it's something :)<br /><br />Thomas</div>
    <div class="meta">Posted on 2001-09-20 13:52:12 by Thomas</div>
   </div>
   <div class="post" id="post-7647">
    <div class="subject"><a href="#post-7647">The MASM32 OOP model.. (Framework)</a></div>
    <div class="body">Thomas, you rock!.. Those are some neat examples...  I like the little devil dudes :)<br /><br />NaN</div>
    <div class="meta">Posted on 2001-09-20 16:12:33 by NaN</div>
   </div>
  </div>
 </body>
</html>