<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>get the list of all exported functions help! - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=10687" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=10687">get the list of all exported functions help!</a></p>
   <div class="post" id="post-80438">
    <div class="subject"><a href="#post-80438">get the list of all exported functions help!</a></div>
    <div class="body">i found an aplication in TASM that gets the list<br />of all exported functions in a DLL .<br /><br />i?m traing to translate it to NASM syntax and then<br />to make some alteration a make the list of function came on a edit box and add some stuff like this list:<br />..<br />import MapVirtualKey user32.dll MapVirtualKeyA<br />import MapVirtualKeyEx user32.dll MapVirtualKeyExA<br />import MapWindowPoints user32.dll<br />import MenuItemFromPoint user32.dll<br />import MessageBeep user32.dll<br />import MessageBox user32.dll MessageBoxA<br />..<br /><br />but for know i just want to translate the TASM example that gives the list of the function on a<br />listbox.<br /><br /><br />like this:<br />..<br />MapVirtualKey<br />MapVirtualKeyExA<br />MapWindowPoints<br />MenuItemFromPoint<br />MessageBeep<br />MessageBoxA<br />..<br /><br />in order to make this more clear i will post the TASM  down</div>
    <div class="meta">Posted on 2003-02-07 18:46:40 by ZobySound</div>
   </div>
   <div class="post" id="post-80439">
    <div class="subject"><a href="#post-80439">the TASM code of GET functions list in listbox</a></div>
    <div class="body">.386<br />locals<br />jumps<br />.model flat,STDCALL<br />include win32.inc              ; Some 32-bit constants and structures  (Borlands)<br />include MyWin32.inc            ; Additional Win32 defines<br />include ImageHlp_Imports.inc   ; Imported Win32 functions<br /><br /><br /><br /><br />;-- ---------------------------------<br />; Consts<br />;<br /><br />L equ &lt;LARGE&gt;<br /><br />ID_BTN_LOAD       equ   101<br />ID_LBOX_EXPORTS   equ   102<br /><br /><br /><br />;===========================================================================<br />;  Data<br />;===========================================================================<br />.data<br /><br />   <br />hInst            dd      0                        ;Application instance<br />wndDlg           dd      0                        ;Main dialog window<br />szAppName        db      'Res Info (Asm)', 0      ;Application name<br />wndLBox          dd      0<br />LoadedImage      LOADED_IMAGE &lt;0&gt;<br />ofn_szFile       db      300   dup( ? )           ;Currently open file<br />ofn              OPENFILENAME   &lt;0&gt;                 ;OpenFile struct,  global so that settings are not lost<br /><br /><br /><br />;===========================================================================<br /><br /><br /><br /><br /><br />;===========================================================================<br />;  Code<br />;===========================================================================<br /><br />.code<br />;-----------------------------------------------------------------------------<br />;<br />; This is where control is received from the loader.<br />;<br />start:<br /><br />      push   L 0<br />      call   GetModuleHandle      ; get hmod (in eax)<br />      mov    , eax         ; hInstance = HMODULE<br />                                        <br /><br />      call   InitCommonControls   ;Going to be using common control<br /><br /><br />      push   L 0<br />      push   offset DlgProc       ;Dialog proc<br />      push   0<br />      push   L 101<br />      push   <br />      call   DialogBoxParamA      ;Start the main dialog<br /><br /><br />end_loop:<br />      push    0<br />      call    ExitProcess<br /><br />        ; we never get to here<br /><br /><br />;-----------------------------------------------------------------------------<br />DlgProc          proc uses ebx edi esi, hDlg:DWORD, wMsg:DWORD, wParam:DWORD, lParam:DWORD<br /> ;<br /> ; WARNING: Win32 requires that EBX, EDI, and ESI be preserved!  We comply<br /> ; with this by listing those regs after the 'uses' statement in the 'proc'<br /> ; line.  This allows the Assembler to save them for us.<br /> ;<br /><br />      mov   eax,   <br />      mov   ,   eax<br />      mov   eax,   0<br /><br />      cmp   ,   WM_DESTROY<br />      je    wmdestroy<br />      cmp   ,   WM_CLOSE<br />      je    wmclose<br />      cmp   ,   WM_COMMAND<br />      je    wmcommand<br />      cmp   ,   WM_INITDIALOG<br />      je    wminitdialog<br />      jmp   finish<br /><br /><br />wminitdialog:<br />      push   lParam<br />      push   wParam<br />      push   wMsg<br />      push   hDlg<br />      call   OnWMInitDialog<br />      jmp    finish<br />   <br /><br />wmclose:<br />      push   lParam<br />      push   wParam<br />      push   wMsg<br />      push   hDlg<br />      call   OnWMClose<br />      jmp    finish<br /><br />wmdestroy:<br />      mov     eax,   1<br />      jmp     finish<br /><br />wmcommand:<br />      push   lParam<br />      push   wParam<br />      push   wMsg<br />      push   hDlg<br />      call   OnWMCommand<br />      jmp    finish<br /><br /><br />finish:<br />      ret<br />DlgProc          endp<br /><br /><br /><br />;---------------------------------------------------------------------------------<br />OnWMInitDialog   proc   hDlg:DWORD, wMsg:DWORD, wParam:DWORD, lParam:DWORD<br /><br /><br />       ;Get the listbox window handle<br />      push   ID_LBOX_EXPORTS<br />      push   wndDlg<br />      call   GetDlgItem<br />      mov    ,   eax<br /><br />OnDlgInit_exit:<br /><br />      mov    eax,   0<br />      ret<br />OnWMInitDialog   endp<br /><br /><br />;---------------------------------------------------------------------------------<br />OnWMClose   proc   hDlg:DWORD, wMsg:DWORD, wParam:DWORD, lParam:DWORD<br /><br />      push   0<br />      push   <br />      call   EndDialog<br />      mov    eax, 0<br /><br />      ret<br />OnWMClose   endp<br /><br /><br />;---------------------------------------------------------------------------------<br />OnWMCommand   proc   hDlg:DWORD, wMsg:DWORD, wParam:DWORD, lParam:DWORD<br /><br /><br />      mov   eax,  <br /><br />      cmp   ax,   IDOK<br />      je    Cmd_Ok<br /><br />      cmp   ax,   ID_BTN_LOAD<br />      je    Cmd_Load<br /><br /><br />      jmp   OnWMCommand_end<br /><br /><br /> Cmd_Ok:<br />      push   lParam<br />      push   wParam<br />      push   wMsg<br />      push   hDlg<br />      call   OnWMClose<br />      jmp    OnWMCommand_end<br /><br /> Cmd_Load:<br />      push   lParam<br />      push   wParam<br />      push   wMsg<br />      push   hDlg<br />      call   OnCmdLoad<br />      jmp    OnWMCommand_end<br /><br /><br /> OnWMCommand_end:<br />      ret<br />OnWMCommand   endp<br /><br /><br /><br />;---------------------------------------------------------------------------------<br />OnCmdLoad   proc   hDlg:DWORD, wMsg:DWORD, wParam:DWORD, lParam:DWORD<br /><br /><br />      push   0<br />      push   0<br />      push   LB_RESETCONTENT<br />      push   wndLBox<br />      call   SendMessage<br /><br />      call   DoOpenFileDialog<br /><br />      cmp    eax,   0<br />      je     CmdLoad_Exit<br /><br /><br />      call   DoGetExports<br /><br /><br /> CmdLoad_Exit:<br /><br />      ret<br />OnCmdLoad   endp<br /><br /><br /><br />;---------------------------------------------------------------------------------<br />DoGetExports   proc<br /><br /> LOCAL iSize:DWORD <br /> LOCAL iNumNames:DWORD<br /> LOCAL iNameLoop:DWORD<br /> LOCAL pNtHeaders:DWORD<br /> LOCAL pFunctionNames:DWORD<br /> LOCAL pExportDir:DWORD = LocalSize<br /><br />      push   ebp<br />      mov    ebp,   esp<br />      sub    esp,   LocalSize<br /><br /><br />      jmp   DoExports_OverData<br /><br /> szError   db   'MapAndLoad failed',0<br /><br /><br /> DoExports_OverData:<br /><br />      push   true<br />      push   true<br />      push   offset LoadedImage<br />      push   0<br />      push   offset ofn_szFile<br />      call   MapAndLoad<br /><br />      cmp    eax,   0<br />      je     DoExports_ErrorMapAndLoad<br /><br />     <br /><br />      lea    eax, iSize<br />      push   eax<br />      push   IMAGE_DIRECTORY_ENTRY_EXPORT<br />      push   false<br />      push   LoadedImage.li_MappedAddress<br />      call   ImageDirectoryEntryToData<br />      mov    ,  eax<br /><br /><br />       ;Get num of named functions<br />      mov    eax,   <br />      add    eax,   ied_NumberOfNames<br />      mov    eax,   <br />      mov    iNumNames,   eax<br /><br /><br />       ;Get the address of the names<br />      mov    eax,   <br />      add    eax,   ied_AddressOfNames<br />      mov    ebx,   <br /><br />       ;Get the IMAGE_NT_HEADER<br />      push   LoadedImage.li_MappedAddress<br />      call   ImageNtHeader<br />      mov    ,   eax<br /><br /><br /><br />       ;Get the VA of the function names<br />      push   0<br />      push   ebx<br />      push   LoadedImage.li_MappedAddress<br />      push   <br />      call   ImageRvaToVa<br />      mov    ,   eax<br /><br />      <br />      xor    eax,   eax<br />      mov    ,   eax<br />      <br />DoExports_top:<br />       ;Get offset into AddressOfNames array = (sizeof( DWORD ) * iNameLoop)<br />      mov   eax,   4<br />      mov   ebx,   <br />      mul   bx<br />      mov   edx,   eax<br /><br /><br />       ;Get the VA of this name<br />      push   0<br />      mov    eax,   <br />      add    eax,   edx<br />      mov    eax,   <br />      push   eax<br />      push   LoadedImage.li_MappedAddress<br />      push   <br />      call   ImageRvaToVa<br /><br />       ;Add the name to the list box<br />      push   eax<br />      call   AddStringToLBox<br />      <br /><br />       ;If there is another item goto top<br />      add    ,   1<br />      mov    eax,   <br />      cmp    eax,   iNumNames<br />      jb     DoExports_top<br /><br /><br />       ;UnMapAndLoad frees mem allocated by MapAndLoad<br />      push   offset LoadedImage<br />      call   UnMapAndLoad<br />      <br /><br />      jmp    DoExports_exit<br /><br /><br /><br /> DoExports_ErrorMapAndLoad:<br />       ;There was an error while trying to load the file<br />      push   MB_OK<br />      push   offset szAppName<br />      push   offset szError<br />      push   wndDlg<br />      call   MessageBox<br />      jmp    DoExports_exit<br /><br /><br /> DoExports_exit:<br /><br />      mov    esp,   ebp<br />      pop    ebp<br />      ret<br />DoGetExports   endp   <br /><br /><br /><br />;---------------------------------------------------------------------------------<br />AddStringToLBox   proc   szStr:DWORD<br /><br />      push   szStr<br />      push   0<br />      push   LB_ADDSTRING<br />      push   wndLBox<br />      call   SendMessage<br /><br />      ret<br />AddStringToLBox   endp   <br /><br /><br /><br />;---------------------------------------------------------------------------------<br />DoOpenFileDialog   proc  <br /><br />      jmp   Ofd_OverData<br /><br /> Ofd_szFilter   db   'DLLs (*.dll)', 0, '*.dll', 0, 0<br /><br /> Ofd_OverData:<br /><br />      mov   ,         size OPENFILENAME<br />      mov   eax,   <br />      mov   ,           eax<br />      mov   eax,   <br />      mov   ,           eax<br />      mov   ,         offset Ofd_szFilter<br />      mov   ,   0<br />      mov   ,      0<br />      mov   ,        0<br />      mov   ,           offset ofn_szFile<br />      mov   ,            299<br />      mov   ,      0<br />      mov   ,       0<br />      mov   ,     0<br />      mov   ,          0<br />      mov   ,               OFN_EXPLORER or OFN_FILEMUSTEXIST or OFN_LONGNAMES<br />      mov   ,         0<br />      mov   ,      0<br />      mov   ,         0<br />      mov   ,           0<br />      mov   ,            0<br />      mov   ,      0<br /><br />      push   offset ofn<br />      call   GetOpenFileName<br />   <br /><br />      ret<br />DoOpenFileDialog   endp<br /><br /><br /><br />public DlgProc<br /><br />ends<br />end start</div>
    <div class="meta">Posted on 2003-02-07 18:47:55 by ZobySound</div>
   </div>
   <div class="post" id="post-80440">
    <div class="subject"><a href="#post-80440">and now my NASM translation that has a BUG please help me!</a></div>
    <div class="body">%include '\lab\vasm\inc\nagoa.inc'<br /><br /><br /><br /><br />;--- here some dll functions that  this aplication use from imagehlp.dll that is not in nagoa.obj<br />   import ImageNtHeader imagehlp.dll<br />   import ImageRvaToVa imagehlp.dll<br />   import MapAndLoad imagehlp.dll<br />   import UnMapAndLoad imagehlp.dll<br />   import ImageDirectoryEntryToData imagehlp.dll<br /><br /><br />STRUC LOADED_IMAGE <br />    .ModuleName                   resd 1<br />    .hFile                              resd 1<br />    .MappedAddress               resd 1<br />    .FileHeader                      resd	1<br />    .LastRvaSection               resd 1<br />    .NumberOfSections           resd 1<br />    .Sections                        resd 1<br />    .Characteristics                resd 1<br />    .fSystemImage                 resw 1<br />    .fDOSImage                     resw 1<br />    .Links                             resd 1<br />    .SizeOfImage                   resd 1<br />ENDSTRUC<br />;------------------------------------------------------------<br /><br /><br /><br /><br /><br />..start:<br /><br />      call   GetModuleHandle,0<br />      CONST hInst, dd 0         <br />      mov    , eax         <br />                                        <br /><br />      call   InitCommonControls   ;Going to be using common control<br /><br /><br />      <br />      call   DialogBoxParamA,,101,0,DlgProc,0       ;Start the main dialog<br /><br /><br />end_loop:<br /><br />      call    ExitProcess,0<br /><br />     <br />;--------- DlgProc<br />proc DlgProc,hDlg,wMsg,wParam,lParam<br /><br />      cmp   dword ,   WM_DESTROY<br />      je    wmdestroy<br />      cmp  dword  ,   WM_CLOSE<br />      je    wmclose<br />      cmp dword   ,   WM_COMMAND<br />      je    wmcommand<br />      cmp dword  ,   WM_INITDIALOG<br />      je    wminitdialog<br />      jmp   finish<br /><br />finish:<br />endproc<br />;-------- DlgProc end<br /><br /><br />; initial data of our aplication is here<br /><br />wminitdialog:<br /><br />      ;--  Getting the listbox window handle<br />      CONST ID_LBOX_EXPORTS ,   equ   102<br />      push   ID_LBOX_EXPORTS<br />      push   dword <br />      call   GetDlgItem<br />      CONST wndLBox , dd      0<br />      mov    ,   eax<br />      jmp   finish<br /><br /><br />wmclose:<br />      push  byte  0<br />      push  dword  <br />      call   EndDialog<br />      mov    eax, 0<br />      jmp    finish<br /><br />wmdestroy:<br />      mov     eax,   1<br />      jmp     finish<br /><br /><br />;-------------------------------------------------------<br />wmcommand:<br />      <br />      mov   eax, dword  <br />      CONST ID_BTN_LOAD ,      equ   101<br />      cmp   ax,   ID_BTN_LOAD<br />      je    Cmd_Load<br />      jmp   finish<br /><br />;--------------------------------<br /> Cmd_Load:<br />  <br />      push   0<br />      push   0<br />      push   LB_RESETCONTENT<br />      push  dword <br />      call   SendMessage<br /><br />      ; DoOpenFileDialog <br />      CONST ofn , resb     OPENFILENAME_size     <br />      mov  dword  ,OPENFILENAME_size<br />      mov   eax,   <br />      mov  dword  ,           eax<br />      mov   eax,   <br />      mov  dword ,           eax<br />      CONST Ofd_szFilter,   db   'DLLs (*.dll)', 0, '*.dll', 0, 0<br />      mov   dword ,       Ofd_szFilter<br />      CONST ofn_szFile ,   times     300 db 0 <br />      mov  dword ,        ofn_szFile<br />      mov   dword ,          299<br />      mov   dword ,OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_LONGNAMES<br />      call   GetOpenFileName,ofn<br />   ;---------------------<br /><br />      cmp    eax,   0<br />      je     CmdLoad_Exit<br />      CALL  DoGetExports<br />      CmdLoad_Exit:<br />      jmp    finish<br /><br />;--------------------------------<br /><br />;--------------------------------<br />DoGetExports:<br /><br />      call   MapAndLoad,ofn_szFile,0,LoadedImage,1,1<br />      cmp    eax,   0<br />      je    near DoExports_ErrorMapAndLoad<br /><br />      CONST LoadedImage, resb LOADED_IMAGE_size<br />      CONST iSize, DD 0 <br />      push   iSize<br />      push   IMAGE_DIRECTORY_ENTRY_EXPORT<br />      push   byte 0<br />      push   dword <br />      call   ImageDirectoryEntryToData<br />      CONST pExportDir, dd  0 <br />      mov    ,  eax<br /><br /><br /> <br />       ;Get num of named functions<br />      mov    eax,   dword <br />      add    eax,  ;18h<br />      mov    eax,   <br />      CONST iNumNames, DD 0<br />      mov ,eax<br /><br /><br />       ;Get the address of the names<br />      mov    eax,   dword <br />      add    eax,   <br />      mov    ebx,   <br /><br />       ;Get the IMAGE_NT_HEADER<br />      push   dword <br />      call   ImageNtHeader<br />      CONST pNtHeaders, DD 0<br />      mov   ,   eax<br /><br /><br /><br />       ;Get the VA of the function names<br />      push   byte 0<br />      push   ebx<br />      push   dword <br />      push   dword <br />      call   ImageRvaToVa<br />      CONST pFunctionNames, DD 0<br />      mov    ,   eax<br />      xor    eax,   eax<br />      CONST iNameLoop, DD 0<br />      mov    ,   eax<br />      <br />DoExports_top:<br />       ;Get offset into AddressOfNames array = (sizeof( DWORD ) * iNameLoop)<br />      mov   eax,   4<br />      mov   ebx,   <br />      mul    bx<br />      mov   edx,   eax<br /><br /><br />       ;Get the VA of this name<br />      push   0<br />      mov    eax,   <br />      add    eax,   edx<br />      mov    eax,   <br />      push   eax<br />      push   dword <br />      push   dword <br />      call   ImageRvaToVa<br /><br />       ;Add the name to the list box<br />      <br />      <br />      ;---AddStringToLBox<br />    <br />      call   SendMessage,,LB_ADDSTRING,0,eax<br /><br />         <br /><br />       ;If there is another item goto top<br />      add    , byte   1<br />      mov    eax,   <br />      cmp    eax,   <br />      jb     DoExports_top<br /><br /><br />       ;UnMapAndLoad frees mem allocated by MapAndLoad<br />     <br />   <br />      call   UnMapAndLoad, LoadedImage<br />      <br /><br />      jmp    DoExports_exit<br /><br /><br /><br /> DoExports_ErrorMapAndLoad:<br />       ;There was an error while trying to load the file<br />      push   MB_OK<br />      CONST szAppName ,  db  'Res Info (Asm)', 0      <br />      push   szAppName<br />      CONST szError,   db   'MapAndLoad failed',0<br />      push   szError<br />      push  dword <br />      call   MessageBox<br />      jmp    DoExports_exit<br /><br /><br /> DoExports_exit:   jmp    finish<br /><br />; ------- DoGetExports   end</div>
    <div class="meta">Posted on 2003-02-07 18:49:34 by ZobySound</div>
   </div>
   <div class="post" id="post-80454">
    <div class="subject"><a href="#post-80454">get the list of all exported functions help!</a></div>
    <div class="body">It might be easier and more beneficial for you to read Iczelion's PE tutorials... specifically tutorial number 7 that does just what you're asking.</div>
    <div class="meta">Posted on 2003-02-07 23:18:07 by BubbaFate</div>
   </div>
   <div class="post" id="post-80978">
    <div class="subject"><a href="#post-80978">Try this:</a></div>
    <div class="body">greetings!</div>
    <div class="meta">Posted on 2003-02-10 21:22:10 by n u M I T_o r</div>
   </div>
   <div class="post" id="post-81168">
    <div class="subject"><a href="#post-81168">hard code :)</a></div>
    <div class="body">Hi nuMIT_or thats hard code ! i like it<br /><br />did not work in windows me :(</div>
    <div class="meta">Posted on 2003-02-11 20:35:16 by Nguga</div>
   </div>
   <div class="post" id="post-81180">
    <div class="subject"><a href="#post-81180">get the list of all exported functions help!</a></div>
    <div class="body">&gt; did not work in windows me <br /><br />umm! is strange. I don't have me.<br />can you say what is the error?<br />Does occur the error when the program intends load a DLL or when<br />reads the export directory info?</div>
    <div class="meta">Posted on 2003-02-11 22:30:59 by n u M I T_o r</div>
   </div>
   <div class="post" id="post-81268">
    <div class="subject"><a href="#post-81268">error</a></div>
    <div class="body">nuMIT_or , i tried some dll in windows system some dll  work well ,<br /><br />others say   &quot;Fail Load the module&quot;<br /><br />and others like fmod.dll  does not say any error and no exports are shown ...<br /><br /><br />any way thanks for all that macros :))</div>
    <div class="meta">Posted on 2003-02-12 09:52:46 by Nguga</div>
   </div>
   <div class="post" id="post-81433">
    <div class="subject"><a href="#post-81433">get the list of all exported functions help!</a></div>
    <div class="body">Right!<br /><br />There was some bugs in my code. I don't understand how could to run!<br /><br />But the problem is not WinME. Is there a bug in win32n.inc. In the line<br />9932:<br /><br />TRUC IMAGE_OPTIONAL_HEADER<br />...<br />...<br />.DataDirectory RESQ 1<br />ENDSTRUC<br /><br />That size is not correct. The Data Directory has 16 entries; each entry<br />has two DWORD members:<br /><br />STRUC IMAGE_DATA_DIRECTORY<br /> .VirtualAddress RESD 1<br /> .isize RESD 1<br />ENDSTRUC<br /><br />So, the best is delete that member or change it to:<br /><br />.DataDirectory resd IMAGE_DATA_DIRECTORY_size*16<br /><br />In my code I assume that IMAGE_OPTIONAL_HEADER does not include<br />the Data Directory.<br /><br />I have corrected some errors in my code. But yet there are some DLLs<br />that the programm won't load. That is a interesting problem! Of course,<br />the programm only load PE files.<br /><br />greetings</div>
    <div class="meta">Posted on 2003-02-12 21:09:37 by n u M I T_o r</div>
   </div>
   <div class="post" id="post-81612">
    <div class="subject"><a href="#post-81612">is working much more better !</a></div>
    <div class="body">hi i changed the <br /><br />STRUC IMAGE_OPTIONAL_HEADER<br />.<br />.<br />.<br /><br />.DataDirectory RESQ 1<br />ENDSTRUC<br /><br /><br />to<br /><br /><br /><br />STRUC IMAGE_OPTIONAL_HEADER<br />.<br />.<br />.<br />.DataDirectory RESD IMAGE_DATA_DIRECTORY<br />ENDSTRUC<br /><br /><br /><br />made the NaGoA  version that it is more litle only 5,27 KB<br /><br />and your 5,77 KB <br /><br /><br />i added some macros of your  to nagoa.inc<br /><br /><br /><br />this ones:<br /><br />;========= new macros added by nuMIT_or  ======================<br />; =====================================================<br />;     = MACROS =<br />; =====================================================<br /><br />%MACRO LOCALS 1-*<br />  %REP %0<br />   sub esp, %1_size<br />  %ENDREP<br /> %ENDMACRO<br /><br /> %MACRO pushd  1<br />  push DWORD %1<br /> %ENDMACRO<br /><br /> %MACRO popd 1<br />  pop DWORD %1<br /> %ENDMACRO<br /><br /> %MACRO movd 2<br />  mov DWORD %1, %2<br /> %ENDMACRO<br /><br /><br /><br /><br />; ------- PE Macros -------------------------------------<br /><br /> %MACRO NTSIGNATURE 1<br />   mov eax, %1<br />   movzx ebx, word  ; eax = offset de la signatura<br />   add eax,ebx<br />   movzx eax, word <br /> %ENDMACRO<br /><br /> %MACRO PEFHDROFFSET 1<br />   mov eax, %1<br />   add eax, dword  ; eax = offset de la signatura<br />   add eax, 4                    ; eax = offset del inicio del encabezado PE<br /> %ENDMACRO<br /><br /> %MACRO OPTHDROFFSET 1<br />          PEFHDROFFSET %1 ; devuelve eax = offset del inicio del encabezado PE<br />   add eax, IMAGE_FILE_HEADER_size <br /> %ENDMACRO<br /><br /> %MACRO SECHDROFFSET 1<br />          OPTHDROFFSET %1 ; devuelve eax = offset del inicio del encabezado op.<br />   add eax, IMAGE_OPTIONAL_HEADER_size <br /> %ENDMACRO<br /><br />; ==== nuMIT_or  end of macros========================</div>
    <div class="meta">Posted on 2003-02-13 16:13:56 by Nguga</div>
   </div>
   <div class="post" id="post-81676">
    <div class="subject"><a href="#post-81676">here the same version full HLL nagoa</a></div>
    <div class="body">this version has the same size of the hard coded of nuMIT_or<br /><br />just this in NAGOA.INC  is win32n.inc  and much more .<br /><br />&quot;CALL&quot;  is real CALL in assembly   <br /><br />&quot;call&quot; is a macro in and is the same of &quot;stdcall&quot;   calling via IAT<br /><br />&quot;invoke&quot;  is used for calling internal rotins with variavels <br /><br /><br />here is the code using some of NAGOA macros:<br /><br />****************************************************************<br /><br /><br /><br />%include '\lab\vasm\inc\nagoa.inc'<br /><br /><br /><br />IDD_MAINDLG 	equ 	110<br />IDC_EDIT 	equ     1000<br />IDM_OPEN        equ     40001<br />IDM_EXIT      	equ     40003<br />PAGE_READONLY	equ	2<br />LV_ITEM_SIZE equ 9*4<br />LV_COLUMN_SIZE equ 6*4<br />space		equ 20h<br />CR			equ 0Dh<br />LF			equ 0Ah<br />TAB			equ 7<br /><br />Col30  db  'RVA', 0<br />Col20  db  'Ord.', 0<br />Col10  db  'Name', 0<br /><br />CapStr  db  &quot;Export functions viewer&quot;, 0<br />NoExportTable db  &quot;There is not export functions&quot;, 0<br />NoPe	db	&quot;The loaded file has not PE format&quot;, 0<br />Msg100  db  &quot;The file can not be opened&quot;, 0<br />Msg101   db  &quot;Fail to load the module.&quot;, 10, 13<br />  db  &quot;It will intend to map it.&quot;, 0<br />Msg102   db  &quot;Fail to intend open and map the file.&quot;, 0<br /><br />Filter  db  &quot;Executable files (*.exe, *.dll, *.ocx)&quot;, 0<br />  db  &quot;*.exe; *.dll; *.ocx&quot;, 0<br />  db  &quot;All the files (*.*)&quot;, 0, &quot;*.*&quot;, 0, 0<br /><br />template1 db &quot;%u&quot;, 0<br />template2 db &quot;%lX&quot;, 0<br />template3 db &quot;Export functions viewer - %s&quot;, 0<br /><br />import_str	db	&quot;import&quot;, 9, 0<br />OutFile		db	&quot;import.txt&quot;, 0<br /><br />hMod   		resd 1<br />_pFl   		resd 1<br />_maped    	resd 1<br />buffer   	resb 256<br />FileName  	resb 256<br />ModuleName	resb 64<br />FunctionName	resb 64<br />ofn   		resb OPENFILENAME_size<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /> ..start:<br /><br /> xor	ebx, ebx<br /> push	ebx<br /> stdcall	GetModuleHandleA<br /> mov	, eax<br /><br /> push	ebx<br /> pushd	ExportDlgProc<br /> push	ebx <br /> pushd	IDD_MAINDLG<br /> push	eax<br /> stdcall	DialogBoxParamA<br /><br /> push	ebx<br /> stdcall	ExitProcess<br /> stdcall	InitCommonControls<br /><br />; :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::<br /><br /> proc ExportDlgProc,hDlg,uMsg,wParam,lParam<br /><br /><br /><br /> mov	eax, <br /> cmp	eax, WM_INITDIALOG<br /> jne	near .close<br />; ----------------------------------<br />; To fill OPENFILENAME struct<br />; ----------------------------------<br /> <br />  stdcall RtlZeroMemory,ofn,OPENFILENAME_size<br />  movd	, OPENFILENAME_size<br />  pushd      <br />  popd	<br />  pushd      <br />  popd	<br />  movd	, OFN_EXPLORER + OFN_LONGNAMES + OFN_HIDEREADONLY<br />  movd	, 0<br />  movd	, 256<br />  movd	, FileName<br />  movd	, Filter<br />  stdcall GetOpenFileNameA,ofn<br />  or	eax, eax<br />  je	near .exit<br /><br />  movd	[_maped], 0<br />  stdcall LoadLibraryA,FileName<br />  or	eax, eax<br />  jne	.loaded<br />  invoke	warning,,Msg102<br />   inc	DWORD [_maped]<br />   invoke OpenAndMapFile,FileName<br />  or	eax, eax<br />  jne	.loaded<br />  invoke	warning,,Msg102<br />  jmp	.if_maped<br /><br /> .loaded:<br />  mov	[_pFl], eax<br />  push	eax<br /><br />  CALL RefreshListview<br />  cmp	eax, -1<br />  jne   .f<br /><br />  pushd Msg102<br />  pushd <br />  CALL warning<br />  jmp	.if_maped<br /><br />.f<br />pushd 104<br />pushd <br />CALL ShowTheFunctionsName<br />  cmp	eax, -1<br />  jne   .return_true<br /><br />  pushd Msg102<br />  pushd <br />  CALL warning<br />  jmp	.if_maped<br /><br />.close:<br />  cmp	eax, WM_CLOSE<br />  jne	.command<br /> .if_maped:<br />  cmp	DWORD [_maped], 0<br />  jne	.else_quit<br />   pushd [_pFl]<br />   stdcall FreeLibrary<br /> .else_quit:<br />   pushd [_pFl]<br />   stdcall UnmapViewOfFile<br /><br /> .exit: <br />   stdcall EndDialog, DWORD , BYTE 0<br /><br />.command: <br />  cmp eax, WM_COMMAND<br />  jne .return_false<br />  mov eax, <br />  cmp eax, IDM_EXIT<br />  jne .return_true<br />  jmp .if_maped<br /><br />.return_false: <br />  xor  eax, eax<br />  jmp .return<br /><br />.return_true: <br />  xor  eax, eax<br />  inc  eax<br />.return : <br />endproc<br /><br /><br />; :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::<br /><br />RefreshListview:<br /><br />CONST lvc, dd 0<br /><br />mov edi,<br />xor	ebx, ebx<br />; -----------------------------<br />; Clean the list view control<br />; -----------------------------<br /> push	ebx<br /> push	ebx<br /> pushd	LVM_DELETEALLITEMS<br /> pushd	103<br /> push	edi<br /> stdcall	SendDlgItemMessageA<br />; --------------------------------<br />; Get the ListView control handle<br />; --------------------------------<br /> pushd	104<br /> push	edi<br /> stdcall	GetDlgItem<br /><br /> movd	, LVCF_FMT+LVCF_SUBITEM+LVCF_TEXT+LVCF_WIDTH<br /> movd	, LVCFMT_CENTER<br /><br /> lea	edx, <br /> mov	ebx, LVM_INSERTCOLUMN<br /> mov	esi, 2<br /> mov	ecx, 3<br /><br /> .b:<br /> push 	edx<br /> push 	esi<br /> push 	ebx<br /> push 	eax<br /> dec  	esi<br /> dec  	ecx<br /> jne  	.b<br /><br /> movd	, 128<br /> movd	, Col10<br /> stdcall	SendMessageA<br /> cmp	eax, -1<br /> je	.exit<br /><br /> movd	, 80<br /> movd	, Col20<br /> stdcall	SendMessageA<br /> cmp	eax, -1<br /> je	.exit<br /><br /> movd	, 100<br /> movd	, Col30<br /> stdcall	SendMessageA<br /><br /> .exit<br /> ret<br /><br />; :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::<br /><br /><br />ShowTheFunctionsName:<br /><br />enter 0,0<br />	push	ebx <br />	push	esi <br />	push	edi <br /><br />CONST pF , DD 0<br />CONST lvi, DD 0 <br />CONST hFile , DD 0 <br />CONST hListV , DD 0 <br />CONST Base , DD 0<br />CONST NumberOfNames , dd 0<br />CONST TempBuffer, dd 0<br /><br />; ------------------------<br /><br />pushd <br />popd <br /> <br />; ------------------------<br />; Create a file to output<br />; ------------------------<br /> mov   edi, OutFile<br /> cdq<br /> push  edx<br /> pushd FILE_ATTRIBUTE_NORMAL<br /> pushd CREATE_ALWAYS<br /> push  edx<br /> pushd FILE_SHARE_WRITE+FILE_SHARE_READ<br /> pushd GENERIC_WRITE+GENERIC_READ<br /> push  edi<br /> stdcall CreateFileA<br /> mov   , eax<br />; ------------------------<br />; Get the listview handle<br />; ------------------------<br /> .gethListv<br /> pushd       <br /> pushd 	<br /> stdcall 	GetDlgItem<br /> mov 	, eax<br />; --------------<br />; Is a PE file?<br />; --------------<br /><br /> mov 	eax, <br /> add 	eax, <br /> cmp	, word &quot;EP&quot;<br /> jne	.is_pe<br /> 	pushd 	MB_OK+MB_ICONERROR<br />	pushd 	CapStr<br />	pushd 	NoPe<br />	pushd 	<br />        stdcall 	MessageBoxA<br />	xor 	eax, eax<br />	jmp 	.exit<br />	<br /> .is_pe		<br />; ----------------------------<br />; Get RVA of Export Directory<br />; ----------------------------<br /> mov 	edi, <br /> or 	edi, edi			; RVA of Export Info in EDI<br /> jne 	.if_maped<br />	pushd 	MB_OK+MB_ICONERROR<br />	pushd 	CapStr<br />	pushd 	NoExportTable<br />	pushd 	<br />	stdcall 	MessageBoxA<br />	xor 	eax, eax<br />	jmp 	.exit<br /><br /> .if_maped<br /> cmp 	DWORD	[_maped], 1<br /> jne	.f<br />  	push	edi<br />  	pushd	  <br />  	CALL	RVA2Offset<br />  	or	eax, eax<br />  	jne	.@1<br /><br /> 	.ShowMsg<br />  	pushd	 MB_OK+MB_ICONERROR<br />  	pushd	 CapStr<br />  	pushd	 Msg102<br />  	pushd	 <br />  	stdcall	MessageBoxA<br />  	xor	eax, eax<br />	dec	eax<br />  	jmp 	.exit<br /> 	.@1<br /> 	mov	edi, eax <br /> .f<br /> add	edi, 	; Linear Address of Export Directory in EDI<br />; ------------------<br />; Get export values<br />; ------------------<br /> mov	eax, <br /> or		eax, eax<br /> je	.use_pathname<br />; --------------------------------------<br />; Use module name from export directory<br />; --------------------------------------<br /> add	eax,<br /> push	eax<br /> lea	esi, <br /> pushd	256<br /> push	esi<br /> stdcall	RtlZeroMemory<br /> push	esi<br /> stdcall	lstrcpy<br /> jmp	.formate<br />; -----------------<br />; Use path name<br />; -----------------<br /> .use_pathname<br />  push	edi<br />  mov	edi, FileName<br />  CALL	GetPathLastName<br />  mov	esi, eax<br />  pop	edi<br />; --------------------<br />; Formate module name<br />; --------------------<br /> .formate<br />  pushd	256<br />  pushd buffer<br />  stdcall	RtlZeroMemory<br />  push	esi<br />  pushd	template3<br />  pushd	buffer<br />  stdcall	wsprintfA<br />  add	esp, 12<br />  pushd  buffer<br />  pushd  <br />  stdcall  SetWindowTextA<br />; ------------------------<br />; Copy name to ModuleName<br />; ------------------------<br />  pushd	64<br />  pushd	ModuleName<br />  stdcall	RtlZeroMemory<br />  push	esi<br />  pushd	ModuleName<br />  stdcall	lstrcpy<br />  pushd  ModuleName<br />  stdcall  lstrlen<br />  add	eax, DWORD ModuleName<br />  mov    , BYTE 20h<br />; ---------------------------------------------------------------------<br />; NumberOfNames: number of functions/symbols that are exported by name<br />; ---------------------------------------------------------------------<br />  pushd	<br />  popd 	<br />; ----------------------------------------------------------------------<br />; Base: number to bias against the ordinals to get the indexes into the <br />; address-of-function array<br />; ----------------------------------------------------------------------<br />  pushd	 <br />  popd 	<br />; -------------------------------------------------------------------------------<br />; AddressOfNames: RVA of an array of RVAs of the functions/symbols in the module<br />; -------------------------------------------------------------------------------<br />  mov 	esi, 	; AddressOfNames RVA<br /><br />  cmp 	DWORD [_maped], 1<br />  jne 	.ff<br />   push   esi<br />   pushd  <br />   CALL   RVA2Offset<br />   or 	  eax, eax<br />   jne 	  .@2<br />   jmp	  .ShowMsg<br />   .@2:<br />   mov esi, eax<br /> .ff<br /><br />  add	esi,		; AddressOfNames Linear Address<br />; -----------------------------------------------------------------------------------<br />; AddressOfNameOrdinals: RVA of a 16-bit array that contains the ordinals associated<br />; with the function names in the AddressOfNames array.<br />; -----------------------------------------------------------------------------------<br />  mov 	ebx, 	; NameOrdinals RVA<br /><br />  cmp 	DWORD [_maped], 1<br />  jne 	.fx<br />    push  ebx<br />    pushd <br />    CALL  RVA2Offset<br />    or 	  eax, eax<br />    jne   .@3<br />    jmp   .ShowMsg<br />    .@3<br />    mov   ebx, eax<br /> .fx<br /> add 	 ebx, 		; AddressOfNameOrdinals Linear Address<br />; -----------------------------------------------------------------------------------<br />; AddressOfFunctions: RVA of an array of RVAs of the functions/symbols in the module<br />; -----------------------------------------------------------------------------------<br /> mov 	 edi, <br /> cmp 	 DWORD [_maped], 1<br /> jne 	 .fxx<br />     push  edi<br />     pushd <br />     CALL  RVA2Offset<br />     or    eax, eax<br />     jne   .@4<br />     jmp   .ShowMsg<br />     .@4<br />     mov edi, eax<br /> .fxx<br /> add 	edi, 		; AddressOfFunctions Linear Address<br /><br /> movd 	, LVIF_TEXT<br /> movd 	, 0<br />; -----------------------------<br />; Add items to listview control<br />; -----------------------------<br /> .while1<br />   cmp 	 DWORD , 0<br />   je 	 near .endw1<br /> ; --------------------------<br /> ; Write &quot;import&quot; to OutFile<br /> ; --------------------------<br />   push  byte 0<br />   lea   eax, <br />   push  eax<br />   pushd 7<br />   pushd import_str<br />   pushd <br />   stdcall WriteFile <br /> ; ---------------------------------<br /> ; Add the function name<br /> ; ---------------------------------<br />   movd	 , 0 <br />  ; ----------------------<br />  ; Get a pointer to name<br />  ; ----------------------<br />   mov 	 eax, 		; Name RVA<br />   cmp 	 DWORD [_maped], 1<br />   jne 	 .@5<br />     push  eax<br />     pushd <br />     CALL  RVA2Offset<br />     or    eax, eax<br />     jne   .@5<br />     jmp   .ShowMsg<br />   .@5<br />   add 	 eax,  <br />   mov 	 , eax	; Name Linear Address<br /><br />   push  esi<br />   push  edi<br />   push  eax<br />   ; --------------------------------<br />   ; Get the size of the name string<br />   ; --------------------------------<br />   push  eax<br />   stdcall lstrlen<br />   inc   eax<br />   mov   , eax<br />   ; ---------------------------------------<br />   ; Copy the function name to FunctionName<br />   ; ---------------------------------------<br />   pop   esi<br />   mov   edi, FunctionName<br />   push  eax<br /><br />   pushd 64<br />   push  edi<br />   stdcall RtlZeroMemory<br /><br />   pop   ecx<br />   push  ecx<br /><br />   rep movsb<br />   mov   , byte space<br />   ; ----------------------------------<br />   ; Copy the function name to OutFile<br />   ; ----------------------------------<br />   pop   eax<br />   push  eax<br /><br />   push  byte 0<br />   lea   edx, <br />   push  edx<br />   push  eax<br />   pushd FunctionName <br />   pushd <br />   stdcall WriteFile <br />   ; ----------------------------------<br />   ; Copy the module name to OutFile<br />   ; ----------------------------------<br />   pushd ModuleName   <br />   stdcall lstrlen<br />   push  byte 0<br />   lea   edx, <br />   push  edx<br />   push  eax<br />   pushd ModuleName   <br />   pushd <br />   stdcall WriteFile <br />   ; ----------------------------------<br />   ; Copy the function name to OutFile<br />   ; ----------------------------------<br />   pop   eax<br />   push  eax<br /><br />   add	 eax, FunctionName<br />   mov   , WORD 0A0Dh<br /><br />   pop	 eax<br /><br />   inc	 eax<br />   inc	 eax <br />   push  byte 0<br />   lea   edx, <br />   push  edx<br />   push  eax<br />   pushd FunctionName<br />   pushd <br />   stdcall WriteFile <br />   ; -----------------------------<br />   ; Display the name of function<br />   ; -----------------------------<br />   pop   edi<br />   pop   esi<br /><br />   lea   eax, <br />   push  eax<br />   push  byte 0<br />   pushd LVM_INSERTITEM<br />   pushd <br />   stdcall SendMessageA<br />   cmp	 eax, -1<br />   je	 near .exit<br /> ; ---------------------------------------------<br /> ; Add the ordinal of the functions to listview<br /> ; ---------------------------------------------<br />   cdq<br />   mov 	 dx, 				; AddressOfOrdinals<br />   mov 	 ecx, edx<br />   add 	 ecx, DWORD <br />   shl 	 edx, 2<br />   add 	 edx, edi				; AddressOfFunctions Linear Address<br /><br />   mov 	 eax, 				; AddressOfOrdinals<br />   push  eax<br /><br />   ;Here we push the parameters for the wsprintfA call<br />   push  ecx<br />   pushd template1<br />   lea 	 eax, <br />   push	 eax<br />   ;Here we clean the TempBuffer<br />   mov 	 , eax<br />   movd	 , 2<br />   inc 	 DWORD <br />   pushd 256<br />   push  eax<br />   stdcall RtlZeroMemory<br />   ;Now we call to wsprintfA<br />   stdcall wsprintfA<br />   add	 esp, 12<br /><br />   lea 	 eax, <br />   push  eax<br />   push  byte 0<br />   pushd LVM_SETITEM<br />   pushd <br />   stdcall SendMessageA<br />   pop 	 ecx<br />   cmp	 eax, -1<br />   je	 near .exit<br /><br />   ;Here we push the parameters for the wsprintfA call<br />   push  ecx<br />   pushd template2<br />   lea 	 eax, <br />   push  eax<br />   mov 	 , eax<br />   movd  , 9<br />   inc 	 DWORD <br />   ;Here we clean the TempBuffer<br />   pushd 256<br />   push  eax<br />   stdcall RtlZeroMemory<br />   ;Now we call to wsprintfA<br />   stdcall wsprintfA<br />   add	 esp, 12<br /><br />   lea 	 eax, <br />   push  eax<br />   push  byte 0<br />   pushd LVM_SETITEM<br />   pushd <br />   stdcall SendMessageA<br />   cmp	 eax, -1<br />   je	 .exit<br /><br />   dec 	DWORD <br />   add 	esi, 4<br />   add 	ebx, 2<br />   inc 	DWORD <br />   jmp	.while1<br />  .endw1<br /> xor	eax, eax<br /> inc	eax<br />.exit<br /><br />  pop	edi<br />  pop	esi<br />  pop	ebx<br />leave<br />ret 12<br /><br />; ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::<br /><br />; ------------------------------------------------------------------<br />; GetPathLastName procedure<br />; <br />; ? Get a pointer to last name in a path name string<br />;<br />;  edi = pointer to path string<br />;  edi = puntero a la cadena del camino<br />; ------------------------------------------------------------------<br /><br />GetPathLastName:<br /> push esi<br /> mov esi, edi<br /> lodsb<br /> cmp al, '\'<br /> je @p1_<br /> lodsb<br /> cmp al, ':'<br /> je @p0_<br /> pop esi<br /> mov eax, edi<br /> ret<br />@p0_: dec esi<br />@p1_: dec esi<br /> push esi<br /> stdcall lstrlen<br /> add esi, eax<br /> std<br />@p2_: lodsb<br /> cmp al, '\'<br /> jne @p2_<br /> inc esi<br />@p3_: inc esi<br />        mov eax, esi<br /> cld<br /> pop esi<br />ret<br /><br />; :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::<br /><br />OpenAndMapFile:<br />  mov eax, <br />  CALL OpenFileToRead<br />  inc eax<br />  je OpenAndMapFile_00<br />  dec eax<br />  push byte 0<br />  push eax<br />  CALL MapFile<br />OpenAndMapFile_00:<br />  ret 4<br /><br />; ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::  <br /><br />OpenFileToReadWrite:<br />  mov edx, GENERIC_READ + GENERIC_WRITE<br />  jmp Create<br />OpenFileToRead:<br />  mov edx, GENERIC_READ<br />  jmp Create<br />OpenFileToWrite:<br />  mov edx, GENERIC_WRITE<br />  Create<br />  xor ecx, ecx<br />        push ecx<br />        pushd FILE_ATTRIBUTE_NORMAL<br />        pushd OPEN_EXISTING<br />        push ecx<br />        push ecx<br />        push edx<br />        push eax<br />        stdcall CreateFileA<br />  ret<br /><br />; :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::<br /><br />MapFile: <br />  push esi<br />  mov esi, <br />  push ebx<br />  xor ebx, ebx<br />  push edi<br />  mov edi, <br />@MapFile_00:<br />    push ebx<br />    push edi<br />    push ebx<br />    push PAGE_READONLY<br />    push ebx<br />    push esi<br />    stdcall CreateFileMappingA<br />    or eax, eax<br />    je @MapFile_01<br /><br />  push eax<br />  push eax<br /><br />  push esi<br />  stdcall CloseHandle<br /><br />  pop eax<br /><br />  push edi<br />  push ebx<br />  push ebx<br />  push DWORD FILE_MAP_READ<br />  push eax<br />  stdcall MapViewOfFile<br />  mov esi, eax<br /><br />  stdcall CloseHandle<br />  mov eax, esi<br />@MapFile_01: pop edi<br />  pop ebx<br />  pop esi<br />  ret 8<br /><br />; ======================================================================<br />;                          RVA2Offset procedure<br />; ======================================================================<br /><br />RVA2Offset:   push ebp<br />              mov ebp, esp<br /><br />              push esi<br />; ---------------------------<br />; Get the number of sections<br />; ---------------------------<br />              PEFHDROFFSET          ; pFile<br />              movzx ecx, WORD <br />; --------------------------------<br />; Get a pointer to sections header<br />; --------------------------------<br />              SECHDROFFSET <br />              mov esi, eax<br />m00:          <br /> ; --------------------------------<br /> ; Is the address in this section?<br /> ; --------------------------------<br />              mov eax,  ; rva<br />              cmp , eax<br />              jl  m02<br />              add eax, DWORD   ; section_rva + sec_size<br />              cmp , eax<br />              jg  m01                      ; not: jump<br />; -----------------------------<br />; Get the correspondient offset<br />; -----------------------------<br />              mov eax,  ; rva<br />              sub eax, dword  ; rva - section_rva = .offset<br />              add eax, dword  ; .offset + raw_offset = offset<br />              jmp m03<br />; ------------------------<br />; Revise the next section<br />; ------------------------<br />m01:          add esi, 028h<br />              loop m00<br />; ----------------------------------------<br />; This address does not exist in this file<br />; ----------------------------------------<br />m02:          xor eax, eax<br />m03:          pop esi <br />              leave<br />              ret 8<br /><br />; :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::<br /><br />warning:<br />  pushd MB_ICONWARNING<br />  pushd CapStr<br />  pushd <br />  pushd <br />  stdcall MessageBoxA<br />  ret 8<br /><br />; ==========================================================================</div>
    <div class="meta">Posted on 2003-02-13 21:35:04 by Nguga</div>
   </div>
   <div class="post" id="post-81690">
    <div class="subject"><a href="#post-81690">more bugs!</a></div>
    <div class="body">Hi Nguga<br /><br />Sorry but I've got wrong again!<br /><br />I suggested change:<br /><br />.DataDirectory RESQ 1<br />ENDSTRUC<br /><br />by<br /><br />.DataDirectory resd IMAGE_DATA_DIRECTORY_size*16<br />ENDSTRUC<br /><br /><br />That is not correct. It would be:<br /><br />.DataDirectory resq 16<br />ENDSTRUC<br /><br />If you does not do that change, then the SECHDROFFSET macro <br />will fail, because will return the IMAGE_IMPORT_DESCRIPTOR<br />RVA :(<br /><br />The Data Directory has 16 IMAGE_DATA_DIRECTORY entries!<br />Each IMAGE_DATA_DIRECTORY has a lenght of 8bytes, or<br />2 DWORDS, or 1 qword.<br /><br />The problem is that if you want to get the RVA of the <br />IMAGE_IMPORT_DESCRIPTOR, you can do (using the pe macros<br />of Randy Katz) something as:<br /><br />	OPTHDROFFSET <br />	lea	eax, <br />	mov	eax, <br /><br />To get the IMAGE_RESOURCE_DIRECTORY:<br /><br />	OPTHDROFFSET <br />	lea	eax, <br />	mov	eax, <br /><br />Now we have other macros:<br /><br />	%MACRO DATADIROFFSET 1<br />	OPTHDROFFSET %1<br />	lea	eax, <br />	%ENDMACRO<br />	<br />	%MACRO DATAENTRYRVA 2<br />	DATADIROFFSET %1<br />	lea	eax, <br />	%ENDMACRO	<br /><br />The parameter %1 of DATADIROFFSET and DATAENTRYRVA is  and <br />the parameter %2 of DATAENTRYRVA is one of these:<br /><br />IMAGE_DIRECTORY_ENTRY_EXPORT EQU 0<br />IMAGE_DIRECTORY_ENTRY_IMPORT EQU 1<br />IMAGE_DIRECTORY_ENTRY_RESOURCE EQU 2<br />IMAGE_DIRECTORY_ENTRY_EXCEPTION EQU 3<br />IMAGE_DIRECTORY_ENTRY_SECURITY EQU 4<br />IMAGE_DIRECTORY_ENTRY_BASERELOC EQU 5<br />IMAGE_DIRECTORY_ENTRY_DEBUG EQU 6<br />IMAGE_DIRECTORY_ENTRY_COPYRIGHT EQU 7<br />IMAGE_DIRECTORY_ENTRY_GLOBALPTR EQU 8<br />IMAGE_DIRECTORY_ENTRY_TLS EQU 9<br />IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG EQU 10<br /><br />So, you can get the IMAGE_IMPORT_DESCRIPTOR RVA so:<br /><br /> DATAENTRYRVA, , IMAGE_DIRECTORY_ENTRY_IMPORT<br /> mov eax, <br /><br />or get the IMAGE_EXPORT_DIRECTORY RVA:<br /><br /> DATAENTRYRVA, , IMAGE_DIRECTORY_ENTRY_IMPORT<br /> mov eax, <br /><br />hehe, my inconscient does not like to program! sorry.<br />I found other bug...</div>
    <div class="meta">Posted on 2003-02-13 22:16:56 by n u M I T_o r</div>
   </div>
   <div class="post" id="post-81693">
    <div class="subject"><a href="#post-81693">get the list of all exported functions help!</a></div>
    <div class="body">Nguga,<br /><br />Posting source if fine.. just zip it up and attach it if its going to be 12 pages long... <br /><br />NaN</div>
    <div class="meta">Posted on 2003-02-13 22:35:04 by NaN</div>
   </div>
   <div class="post" id="post-81776">
    <div class="subject"><a href="#post-81776">for ZoobySound working plus new nagoa.inc to download !</a></div>
    <div class="body">here is the working version for ZobySound <br /><br />and the last nagoa.inc   added Imagehlp.h STRUCTURES and equates and some<br />PE nuMIT_or macros.<br /><br />( nagoa.inc is win32n.inc improved )<br /><br /><br />so every one using nasm for win32Nasm can download it</div>
    <div class="meta">Posted on 2003-02-14 09:33:30 by Nguga</div>
   </div>
   <div class="post" id="post-81779">
    <div class="subject"><a href="#post-81779">hi nuMIT_or</a></div>
    <div class="body">ola !<br /><br />I just read your post , i will see it later , becouse i have no time know...<br /><br />but please download de file i post with nagoa.inc and  make the changes and post <br />it here please , i will be back a night 2:00 in morning  i go work :(</div>
    <div class="meta">Posted on 2003-02-14 09:41:41 by Nguga</div>
   </div>
   <div class="post" id="post-81878">
    <div class="subject"><a href="#post-81878">get the list of all exported functions help!</a></div>
    <div class="body">hi Nguga:<br /><br />Your code has a important bug in the message dispatcher, lines 26-37.<br />If you not return FALSE (or zero) when your code does not handle a<br />Windows message, then your Window will not receive focus and will<br />be transparent in win2k. So , only add a line:<br /><br /><pre><code><br /><br />proc DlgProc,hDlg,wMsg,wParam,lParam<br /><br />      cmp   dword &#91;wMsg&#93;, WM_DESTROY<br />      je    wmdestroy<br />      cmp  	dword  &#91;wMsg&#93;, WM_CLOSE<br />      je    wmclose<br />      cmp 	dword &#91;wMsg&#93;, WM_COMMAND<br />      je    wmcommand<br />      cmp 	dword &#91;wMsg&#93;, WM_INITDIALOG<br />      je    wminitdialog<br />      xor	eax, eax                      ; &lt;--- new line *<br />      jmp   finish<br /><br />finish&#58;<br />endproc<br /><br /></code></pre><br /><br />hehe, you use the imagehelp.dll to handle the PE file. Good! I've never used it  :tongue: .<br /><br />greetings</div>
    <div class="meta">Posted on 2003-02-15 00:46:57 by n u M I T_o r</div>
   </div>
   <div class="post" id="post-82042">
    <div class="subject"><a href="#post-82042">new</a></div>
    <div class="body">hi nuMit_or<br /><br /><br />i change the <br /><br /><br />.DataDirectory resd IMAGE_DATA_DIRECTORY_size*16<br />ENDSTRUC<br /><br /><br /><br />to<br /><br /><br />.DataDirectory RESB IMAGE_DATA_DIRECTORY_size *16 <br /><br /><br />resb not resd !!!!<br /><br /><br /><br />see this new link i just made and see if there is some bug ... :)<br /><br />How to convert Masm struct to NASM and use them by Nguga<br /><a target="_blank" href="http://194.65.3.199/win32asm/MASMstruct2NASM.html">http://194.65.3.199/win32asm/MASMstruct2NASM.html</a><br /><br /><br />GET THE LAST NAGOA.INC   ver 17 fev 2003 <br /><a target="_blank" href="http://194.65.3.199/win32asm/nagoa.inc.zip">http://194.65.3.199/win32asm/nagoa.inc.zip</a><br /><br /><br />i added your macros.</div>
    <div class="meta">Posted on 2003-02-15 20:39:38 by Nguga</div>
   </div>
   <div class="post" id="post-82079">
    <div class="subject"><a href="#post-82079">get the list of all exported functions help!</a></div>
    <div class="body">that is exactly what I advise you before!<br /><br />There are 16 entries in the Data Directory. I know MASM, NASM and TASM!<br /><br />greetings</div>
    <div class="meta">Posted on 2003-02-16 03:46:18 by n u M I T_o r</div>
   </div>
   <div class="post" id="post-82098">
    <div class="subject"><a href="#post-82098">Thanks</a></div>
    <div class="body">Yes you know i learned a lot with you !<br /><br />Remember <br />drum sonic 42 :)</div>
    <div class="meta">Posted on 2003-02-16 07:13:31 by Nguga</div>
   </div>
  </div>
 </body>
</html>