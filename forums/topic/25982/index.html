<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Visual Basic - Object Virtual table, calling members from ASM. Hover Leave examp - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25982" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25982">Visual Basic - Object Virtual table, calling members from ASM. Hover Leave examp</a></p>
   <div class="post" id="post-189354">
    <div class="subject"><a href="#post-189354">Visual Basic - Object Virtual table, calling members from ASM. Hover Leave examp</a></div>
    <div class="body">Hi again. I search throught all the internet and all the methods to make an event Hover and Leave has wast quite nice to me. One of the main trhoubles was that only the message procesor of the window could get the events. so that means that if im making a form with a couple of buttons that make diferent things in the events i would have to create a lot of code. Also i dont find vb a good language to process message, cause that has to be fast as posible cause all message have to pass trhu the hook process, and every added reference is a lil more of time processing.<br />The search method in the list is not optimized, but im almost sure that is better than make it in vb.<br />well, i made a function that can redirect any message of any window to your own object function, this object require only implement an interface called IMessageCatcher, and thats all, cant be more simple. <br /><br /><br /><br />vb code<br />Implements IMessageCatcher<br />Const WM_MOUSEHOVER = &amp;H2A1&amp;<br />Const WM_MOUSELEAVE = &amp;H2A3&amp;<br />Const WM_LBUTTONDOWN = &amp;H201&amp;<br />Const WM_LBUTTONUP = &amp;H202&amp;<br /><br />Private WithEvents mouseeventsCommand2 As MessageCatcher<br />Private WithEvents mouseeventscommand3 As MessageCatcher<br />Private Declare Function EndWindowRedirection Lib &quot;..\msgredir\msgredir.dll&quot; (ByVal hWnd As Long) As Boolean<br />Private Declare Function RedirectMessage Lib &quot;..\msgredir\msgredir.dll&quot; (ByVal hWnd As Long, ByVal uMsg As Long, ByVal obj As IMessageCatcher) As Boolean<br /><br />Private Sub cmdCommand1_Click()<br />&nbsp; &nbsp; MsgBox &quot;This is the original event&quot;<br />End Sub<br /><br />Private Sub Form_Click()<br />&nbsp; &nbsp; MsgBox &quot;Original event&quot;<br />End Sub<br /><br />Private Sub Form_Load()<br />&nbsp; &nbsp; Set mouseeventsCommand2 = New MessageCatcher<br />&nbsp; &nbsp; Set mouseeventscommand3 = New MessageCatcher<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; Call RedirectMessage(Me.hWnd, WM_MOUSEHOVER, Me)<br />&nbsp; &nbsp; Call RedirectMessage(Me.hWnd, WM_MOUSELEAVE, Me)<br />&nbsp; &nbsp; Call RedirectMessage(Me.hWnd, WM_LBUTTONDOWN, Me)<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; Call RedirectMessage(Me.cmdCommand1.hWnd, WM_MOUSEHOVER, Me)<br />&nbsp; &nbsp; Call RedirectMessage(Me.cmdCommand1.hWnd, WM_MOUSELEAVE, Me)<br />&nbsp; &nbsp; Call RedirectMessage(Me.cmdCommand1.hWnd, WM_LBUTTONUP, Me)<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; &#39;now we r redirecting direfent messages of direfents windows on the same<br />&nbsp; &nbsp; &#39;message processor, you may need to separate without doing a if.elseif.endif<br />&nbsp; &nbsp; &#39;you could do this<br />&nbsp; &nbsp; Call mouseeventsCommand2.Redirect(Me.cmdCommand2.hWnd, WM_MOUSEHOVER)<br />&nbsp; &nbsp; Call mouseeventsCommand2.Redirect(Me.cmdCommand2.hWnd, WM_MOUSELEAVE)<br />&nbsp; &nbsp; Call mouseeventsCommand2.Redirect(Me.cmdCommand2.hWnd, WM_LBUTTONDOWN)<br />&nbsp; &nbsp; Call mouseeventsCommand2.Redirect(Me.cmdCommand2.hWnd, WM_LBUTTONUP)<br />&nbsp; &nbsp; Call mouseeventscommand3.Redirect(Me.cmdCommand3.hWnd, WM_MOUSEHOVER)<br />&nbsp; &nbsp; Call mouseeventscommand3.Redirect(Me.cmdCommand3.hWnd, WM_MOUSELEAVE)<br />&nbsp; &nbsp; <br />End Sub<br /><br />Private Function IMessageCatcher_OnMsg(ByVal hWnd As Long, ByVal uMsg As Long, ByVal wParam As Long, ByVal lParam As Long) As Long<br />&nbsp; &nbsp; Me.txtText1 = &quot;IMessageCatcher_OnMsg of the form&quot; &amp; vbCrLf<br />&nbsp; &nbsp; If hWnd = Me.hWnd Then<br />&nbsp; &nbsp; &nbsp; &nbsp; Me.txtText1 = Me.txtText1 &amp; &quot;Window: Form&quot; &amp; vbCrLf<br />&nbsp; &nbsp; ElseIf hWnd = Me.cmdCommand1.hWnd Then<br />&nbsp; &nbsp; &nbsp; &nbsp; Me.txtText1 = Me.txtText1 &amp; &quot;Window: Command1&quot; &amp; vbCrLf<br />&nbsp; &nbsp; End If<br />&nbsp; &nbsp; If uMsg = WM_LBUTTONUP Then<br />&nbsp; &nbsp; &nbsp; &nbsp; Me.txtText1 = Me.txtText1 &amp; &quot;Message: Click&quot;<br />&nbsp; &nbsp; ElseIf uMsg = WM_MOUSEHOVER Then<br />&nbsp; &nbsp; &nbsp; &nbsp; Me.txtText1 = Me.txtText1 &amp; &quot;message: Mouse Hover&quot;<br />&nbsp; &nbsp; ElseIf uMsg = WM_MOUSELEAVE Then<br />&nbsp; &nbsp; &nbsp; &nbsp; Me.txtText1 = Me.txtText1 &amp; &quot;message: Mouse Leave&quot;<br />&nbsp; &nbsp; End If<br />End Function<br /><br />Private Sub mouseeventsCommand2_OnMsg(ByVal hWnd As Long, ByVal uMsg As Long, ByVal wParam As Long, ByVal lParam As Long)<br />&nbsp; &nbsp; If uMsg = WM_MOUSEHOVER Then<br />&nbsp; &nbsp; &nbsp; &nbsp; Me.cmdCommand2.Caption = &quot;Hover&quot;<br />&nbsp; &nbsp; ElseIf uMsg = WM_LBUTTONDOWN Then<br />&nbsp; &nbsp; &nbsp; &nbsp; Me.cmdCommand2.Caption = &quot;Click..&quot;<br />&nbsp; &nbsp; ElseIf uMsg = WM_LBUTTONUP Then<br />&nbsp; &nbsp; &nbsp; &nbsp; Me.cmdCommand2.Caption = &quot;ClickOut&quot;<br />&nbsp; &nbsp; Else<br />&nbsp; &nbsp; &nbsp; &nbsp; Me.cmdCommand2.Caption = &quot;Leave&quot;<br />&nbsp; &nbsp; End If<br />End Sub<br /><br />Private Sub mouseeventscommand3_OnMsg(ByVal hWnd As Long, ByVal uMsg As Long, ByVal wParam As Long, ByVal lParam As Long)<br />&nbsp; &nbsp; If uMsg = WM_MOUSEHOVER Then<br />&nbsp; &nbsp; &nbsp; &nbsp; Me.cmdCommand3.Caption = &quot;Hover&quot;<br />&nbsp; &nbsp; Else<br />&nbsp; &nbsp; &nbsp; &nbsp; Me.cmdCommand3.Caption = &quot;Leave&quot;<br />&nbsp; &nbsp; End If<br />End Sub<br /><br />Private Sub Form_Unload(Cancel As Integer)<br />&nbsp; &nbsp; &#39;in this case you dont need to call EndWindowRedirection<br />&nbsp; &nbsp; &#39;cause is made it automatically when the windows get the wm_destroy<br />&nbsp; &nbsp; EndWindowRedirection Me.hWnd<br />&nbsp; &nbsp; EndWindowRedirection Me.cmdCommand1.hWnd<br />&nbsp; &nbsp; EndWindowRedirection Me.cmdCommand2.hWnd<br />&nbsp; &nbsp; EndWindowRedirection Me.cmdCommand3.hWnd<br />End Sub<br /><br />&#39;WARNING!! everytime u call redirectmessage the asm make a node in a list<br />&#39;this is destroyed when the hook process of the window WM_DESTROY<br />&#39;if u hook another windows that is not of yours remember to call EndWindowRedirection<br />&#39;else if the IMessageCatcher is destroyed before the window a message is catched by asm,<br />&#39;it will make an error trying to call the first public function of the interface of the<br />&#39;deleted object<br />&#39;Second WARNING: call twice RedirectMessage with same window and message dont work<br />&#39;the first one only gets it (ill improve this when i have time)<br />&#39;Third WARNING: if diferent objects whith IMessageCatcher are hooking diferent<br />&#39;message of same window if some object have to be deleted then it have to call<br />&#39;to EndWindowREdirect and in secondary efect makes the other object stop hooking<br />&#39;messages, this is cause i didnt have time, and i didnt need it to make a function<br />&#39;in the dll RemoveMessageRedirection, ill do it when i need it or have the time<br />&#39;i think thats all, cant remember now, im too sleepy<br /><br /><br /><br /><br /><br /><br /><br />asm code of the dll (only the important part)<br /><br />.386<br />.model flat,stdcall<br />option casemap:none<br /><br />include msgredir.inc<br /><br /><br /><br />this is the way you define any object interface:<br /><br />vbClass_VirtualTable struct<br />	unk1	dd ?<br />	unk2	dd ?<br />	unk3	dd ?<br />	unk4	dd ?<br />	unk5	dd ?<br />	unk6	dd ?<br />	unk7	dd ?<br />vbClass_VirtualTable ends<br />IMessageCatcher_VirtualTable struct<br />	unknown	vbClass_VirtualTable &lt;&gt;;no idea what this info is<br />	Func1	dd ?&nbsp; ;my function<br />IMessageCatcher_VirtualTable ends<br />vbObject struct<br />	pVirtualTable dd ?<br />vbObject ends<br /><br /><br /><br />.data<br />hInstance	dd 0<br />hWindowsList dd ?<br />hDllVbVm	dd 0<br /><br />.code<br />DllEntry proc hInst:HINSTANCE, reason:DWORD, reserver1:DWORD<br />LOCAL hList:DWORD<br /><br />	.if reason == DLL_PROCESS_ATTACH<br />		push hInst<br />		pop hInstance<br />		invoke CreateDataList<br />		mov hWindowsList,eax<br />	.elseif reason == DLL_PROCESS_DETACH<br />		invoke EndAllWindowsRedirection<br />		invoke DataList_Delete,hWindowsList<br />	.endif<br />	mov eax,TRUE<br />	ret<br /><br />DllEntry endp<br /><br /><br />MsgRedirectorProc proc hWnd:DWORD,uMsg:DWORD,wParam:DWORD,lParam:DWORD<br />LOCAL retv:DWORD<br />LOCAL tme:TRACKMOUSEEVENT<br /><br />	push esi<br /><br />	invoke DataList_Get,hWnd,hWindowsList<br />	;allways is going to return a list entry<br />	mov esi,eax;esi = ptr WindowNode<br />	invoke CallWindowProc,.WindowNode.pProc,hWnd,uMsg,wParam,lParam<br />	push eax<br />	.if uMsg== WM_DESTROY<br />		invoke EndWindowRedirection,hWnd<br />		ret<br />	.elseif uMsg==02a3h;leave<br />		mov .WindowNode.inside,0<br />		mov tme.cbSize,SIZEOF(TRACKMOUSEEVENT)<br />		mov tme.dwFlags,TME_HOVER<br />		mov eax,hWnd<br />		mov tme.hwndTrack,EAX<br />		mov tme.dwHoverTime,HOVER_DEFAULT<br />		INVOKE TrackMouseEvent,ADDR tme<br />		;^<br />		<br />	.ELSEIF uMsg==WM_MOUSEMOVE &amp;&amp; .WindowNode.inside==0;hover<br />		mov .WindowNode.inside,1<br />		;seems like windows dont generate hover message, so i do it for him<br />		invoke PostMessage,hWnd,WM_MOUSEHOVER,0,0<br />		<br />		mov tme.cbSize,SIZEOF(TRACKMOUSEEVENT)<br />		mov tme.dwFlags,TME_LEAVE<br />		mov eax,hWnd<br />		mov tme.hwndTrack,EAX<br />		mov tme.dwHoverTime,HOVER_DEFAULT<br />		INVOKE TrackMouseEvent,ADDR tme<br />	.endif<br />	invoke DataList_Get,uMsg,.WindowNode.hMsgs<br />	.if eax; if we have to redirect the message of this window<br />		;eax = ptr WindowMessageNode<br />		mov esi,eax;esi = ptr WindowMessageNode<br />		<br />		;call the function number 1 of the object interface<br />		mov eax,.WindowMessageNode.pObj <br />		mov edx,.vbObject.pVirtualTable<br />		lea ecx,retv<br />		push ecx		;push the address to the return value<br />		push lParam		;push parameters as u define in vb<br />		push wParam<br />		push uMsg<br />		push hWnd<br />		push eax		;push object reference<br />		call .IMessageCatcher_VirtualTable.Func1<br />	.endif<br />	<br />	pop eax<br />	pop esi<br />	ret<br /><br />MsgRedirectorProc endp<br />RedirectMessage proc hWnd:HWND,uMsg:DWORD,pObj:DWORD;As boolean(true = ok)<br />LOCAL et:TRACKMOUSEEVENT<br />	push esi<br />	invoke DataList_Get,hWnd,hWindowsList<br />	.if eax;the window already exist in the list<br />	<br />		mov esi,eax;esi = window node<br />		invoke WindowNode_addMessage,esi,uMsg,pObj<br />	.ELSE;the window dont exist in the list<br />		mov eax,hWindowsList<br />		invoke WindowNode_create,hWnd;put in the list<br />		mov esi,eax<br />		invoke DataList_Add,hWnd,esi,hWindowsList<br />		invoke WindowNode_addMessage,esi,uMsg,pObj<br />		invoke SetWindowLong,hWnd,GWL_WNDPROC,ADDR MsgRedirectorProc<br />		mov et.cbSize,SIZEOF(TRACKMOUSEEVENT)<br />		mov et.dwFlags,TME_HOVER+TME_LEAVE+TME_CANCEL<br />		mov eax,hWnd<br />		mov et.hwndTrack,EAX<br />		mov et.dwHoverTime,HOVER_DEFAULT<br />		INVOKE TrackMouseEvent,ADDR et<br />	.endif<br />	pop esi<br />	ret<br /><br />RedirectMessage endp<br /><br />EndWindowRedirection proc hWnd:DWORD;As long (success &lt;&gt; 0)<br /><br />	push esi	<br />	invoke DataList_Get,hWnd,hWindowsList<br />	mov esi,eax;esi = windownode<br />	invoke SetWindowLong,.WindowNode.hWnd,GWL_WNDPROC,.WindowNode.pProc;reestablezco el proceso original<br />	invoke DataList_Delete,.WindowNode.hMsgs;borro lista de mensajes<br />	invoke GlobalFree,esi<br />	invoke DataList_Remove,hWnd,hWindowsList;borro el nodo de la lista<br />	pop esi<br />	ret<br /><br />EndWindowRedirection endp<br /><br />EnumCancelRedirection proc pWindowNode:DWORD<br />	<br />	push esi<br />	mov esi,pWindowNode<br />	invoke EndWindowRedirection,.WindowNode.hWnd<br />	pop esi<br />	ret<br /><br />EnumCancelRedirection endp<br />EndAllWindowsRedirection proc<br />	<br />	lea ecx, EnumCancelRedirection<br />	invoke DataList_Enum,hWindowsList,ecx<br />	ret<br /><br />EndAllWindowsRedirection endp<br /><br />end DllEntry<br /><br /><br /><br /><br /><br /><br />i hope u find this usefull. <br />one last comment about virtual tables of vb objects<br />lets say that your class called MyClass is defined in vb like this:<br /><br /><br />vb code:<br /><br />public myLong as long<br />private myPrivateLong as long &#39;private members dont afect the virtual table of the object, cause dont have default get and set methods<br />property get myOtherLong as long<br />	myOtherLong = 5<br />end property<br /><br />public function myFunction() as long<br />	myFunction = myLong + 20<br />end function<br /><br /><br /><br />to can use methods of the class from ASM having a reference to the object<br />u have to define the virtual table like this<br /><br />MyClass_VirtualTable struct<br />	unknown	vbClass_VirtualTable &lt;&gt;<br />	Get_myLong dd ?<br />	Set_myLong dd ?<br />	Get_myOtherLong dd ?<br />	myFunction dd ?<br />MyClass_VirtualTable ends<br /><br /><br /><br />remember that the calling convention of vb passes the pointer to the ret value first<br />and the pointer to the object at after the parameters, and i guess u know <br />how to pass byval and byref parameters.<br />sorry my english, but is understandable enought, isnt it?<br />thats all</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2354" target="_blank">Mouse Hover Leave messageRedirection with asm.rar</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-05-24 07:30:23 by mauricioprado</div>
   </div>
   <div class="post" id="post-189356">
    <div class="subject"><a href="#post-189356">Re: Visual Basic - Object Virtual table, calling members from ASM. Hover Leave e</a></div>
    <div class="body">Anyone who reads this thread should know that none of this is new.<br />It might be a useful example for programmers interested in the lowlevel mechanisms that are used by object interfaces, but this is not an efficient way to write this kind of code, and it&#39;s not pretty to look at, either.<br /><br />Members of this board have created many helper macros for defining and calling object interfaces and their methods.<br />In order of least complexity: Ernie&#39;s COINVOKE/COM macros, Ultrano&#39;s ATC oopasm framework, Biterider&#39;s OA32 oopasm framework.<br />So much stuff to look at!<br /><br />These are just sets of helper macros that allow you to write what appears to be highlevel sourcecode, where in fact we&#39;re using macros that emit vanilla asm, so these frameworks only exist &#39;at buildtime&#39;, inside MASM.<br /><br />In particular, OA32 supports many highlevel concepts such as N-deep single inheritance, polymorphism, runtime overloading of interface methods etc. which would make your life much more painful if you insisted on handcrafting all your code...it can create Vanilla, COM and C++ styles of interfaces.<br /><br />Here&#39;s an incomplete example of some OA32-dependant code which shows what I mean:<br /><pre><code><br /><br />	mov ptemp, $OCall (pObj::MyObjectClass.EnumArgs,pPhrase,2)<br />	Switch eax<br />	Case NULL<br />		DbgWarning &quot;No Arguments were Enumerated&quot;<br />		Destroy ptemp<br />		mov ptemp,0<br /></code></pre><br /><br />I believe that ATC is now officially dead, however the other stuff is still being used regularly, and in particular OA32 is still being actively developed.</div>
    <div class="meta">Posted on 2007-05-24 08:30:24 by Homer</div>
   </div>
   <div class="post" id="post-189358">
    <div class="subject"><a href="#post-189358">Re: Visual Basic - Object Virtual table, calling members from ASM. Hover Leave e</a></div>
    <div class="body"><div class="quote"><br />Anyone who reads this thread should know that none of this is new.<br />It might be a useful example for programmers interested in the lowlevel mechanisms that are used by object interfaces, but this is not an efficient way to write this kind of code, and it&#39;s not pretty to look at, either.<br /></div><br />Sorry my ignorance, i didnt know that com clases whas the same that vb objects.<br />I just open my debug and start to c how vb makes the calls.<br />did u know where i can find the interface descriptors for the common objects in vb? like command buttons, forms, etc? thanks<br />i dont know what u mean by eficient, is it faster with the macros? maybe u mean a lil less of code and an added complexity. Anyway, i prefeer to write high level code with high level languages and use asm to write low level, even if is longer i found it easyer to read and mantain, when i start to use all those macros and stuff asm code start to be look kind of ugly to me.</div>
    <div class="meta">Posted on 2007-05-24 10:06:01 by mauricioprado</div>
   </div>
   <div class="post" id="post-189359">
    <div class="subject"><a href="#post-189359">Re: Visual Basic - Object Virtual table, calling members from ASM. Hover Leave e</a></div>
    <div class="body"><br />OOPASM allows you to write programs that look and feel like a HLL, but actually generate asm (that you will never see).<br /><br />It&#39;s efficient because it dramatically speeds up development times, especially when you are using, or deriving from, a set of standard objects.<br />The tired old arguments that have been used by HLL coders for years to put down ASM are no longer true.<br />We can write HLL code AND write asm at the SAME TIME.<br />We can write reusable code modules and port them easily between projects, etc.<br /><br />The source is more readable, faster to write, easier to debug (TRUE!), and the development times are similar to any other HLL, with the added benefits that the binary code is more efficient, faster, and smaller than that produced by a Compiler.<br /><br />You don&#39;t even need to study or understand the oopasm macros and the opcodes they generate in order to USE them, which is why I responded so quickly to your post.<br /><br />I am not suggesting that understanding the lowlevel output of the macros is a bad idea, I am simply stating that the User does not NEED to do so in order to benefit from using it.<br /></div>
    <div class="meta">Posted on 2007-05-24 11:13:04 by Homer</div>
   </div>
   <div class="post" id="post-189360">
    <div class="subject"><a href="#post-189360">Re: Visual Basic - Object Virtual table, calling members from ASM. Hover Leave e</a></div>
    <div class="body"><div class="quote"><br />Anyone who reads this thread should know that none of this is new.<br /></div><br />ive been reading the com librarys for asm. There is something new if i dont mistake, the com defines that every object interface have the iUnknown that have 6. This vb objects have 7 methods, i dont know if the 6 first belong to iunknown.<br />I dont know if write an app with asm even using HLL takes the same time, i would pay to c a vb programer next to a asm programer and c who ends first an entire project in just 1 languaje.<br />As i said before, i prefeer to use asm in things that the high level languaje that i use to write the application dont let me do it, or make it slow, or makes all confusing or make &quot;strange&quot; code, etc, etc<br />and all this discution just for 5 lines that could be replaced for a coinvoke call, i pass from low level to high leven in 5 lines. No matter how much macros i use, writting hll in asm depends more of the programer discipline than other thing, cause ull have allways at your hand to do low level code.<br />as i c this macros &quot;emulate&quot; oop, and that make trying to write Object Oriented code pretty much clumsy. Even with vb cant write acurate OO code, neither smalltalk, CLOS, Eiffel or c++ are completelly OO, so i doubt asm can be OO.<br />with those premises i could write fully OO with a electromagnetic pencil into a music cassette</div>
    <div class="meta">Posted on 2007-05-25 07:55:43 by mauricioprado</div>
   </div>
  </div>
 </body>
</html>