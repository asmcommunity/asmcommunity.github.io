<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>passing values to proc - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29331" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29331">passing values to proc</a></p>
   <div class="post" id="post-207149">
    <div class="subject"><a href="#post-207149">passing values to proc</a></div>
    <div class="body">Ok, I think I&#039;m just missing something obvious here.&nbsp; Here&#039;s a function and a call to it:<br /><br /><pre><code><br />FuncTest&nbsp; proc&nbsp; dwNumberIn:DWORD<br /><br />&nbsp; mov&nbsp; eax, dwNumberIn<br /><br />&nbsp; ret<br />FuncTest&nbsp; endp<br /><br />invoke&nbsp; FuncTest, 5491<br /></code></pre><br /><br />When I do this, the debugger doesn&#039;t show the value 5491 being moved into eax.&nbsp; It shows &quot;ntdll.7C910208&quot; being passed as if it&#039;s the value of dwNumberIn.&nbsp; I&#039;ve written hundreds of procs and never seen this behavior.&nbsp; What stupid thing am I overlooking?</div>
    <div class="meta">Posted on 2009-03-25 09:50:21 by rdaneel</div>
   </div>
   <div class="post" id="post-207151">
    <div class="subject"><a href="#post-207151">Re: passing values to proc</a></div>
    <div class="body">Ok, this makes no sense.&nbsp; If I put the call to the procedure above the procedure itself, it runs once correctly and again with the wierd values.&nbsp; It&#039;s like the function is getting called twice:<br /><br /><pre><code><br />invoke&nbsp; FuncTest, 5491<br /><br />FuncTest&nbsp; proc&nbsp; dwNumberIn:DWORD<br /><br />&nbsp; mov&nbsp; eax, dwNumberIn<br /><br />&nbsp; ret<br />FuncTest&nbsp; endp<br /></code></pre><br /><br />Why would this code run FuncTest twice?&nbsp; This is a console app so maybe I&#039;m not understanding right.&nbsp; This is my first console app.<br /></div>
    <div class="meta">Posted on 2009-03-25 11:30:48 by rdaneel</div>
   </div>
   <div class="post" id="post-207152">
    <div class="subject"><a href="#post-207152">Re: passing values to proc</a></div>
    <div class="body">Well, if this is how your code looks exactly then it&#039;s normal that it would get executed twice. First when you call it and then a swcond time when it returns as there is no ret after your invoke FuncTest, 5491 . Also, I assume the second time it would use some random on the stack value as there wasn&#039;t anything pushed.<br /><br />Easy fix:<br /><br />invoke&nbsp; FuncTest, 5491<br />ret<br /><br />FuncTest&nbsp; proc&nbsp; dwNumberIn:DWORD<br /><br />&nbsp; mov&nbsp; eax, dwNumberIn<br /><br />&nbsp; ret<br />FuncTest&nbsp; endp</div>
    <div class="meta">Posted on 2009-03-25 12:08:35 by JimmyClif</div>
   </div>
   <div class="post" id="post-207155">
    <div class="subject"><a href="#post-207155">Re: passing values to proc</a></div>
    <div class="body">Thanks for the response JC.&nbsp; How come I&#039;ve never had to use &quot;ret&quot; after an invoke before?&nbsp; This is new to me.&nbsp; For instance, the familiar:<br /><br /><pre><code><br />start:<br />&nbsp; invoke&nbsp; GetModuleHandle, NULL<br />&nbsp; mov&nbsp; &nbsp; hInstance, eax<br /><br />&nbsp; invoke&nbsp; GetCommandLine<br />&nbsp; mov&nbsp; &nbsp; pCommandLine, eax<br /><br />&nbsp; ...etc...<br /></code></pre><br /><br />These don&#039;t seem to require ret&#039;s after each invoke.&nbsp; Is it something that is specific to console apps?&nbsp; I don&#039;t think I had to do that in my DOS apps either.&nbsp; Thanks again.</div>
    <div class="meta">Posted on 2009-03-25 13:16:36 by rdaneel</div>
   </div>
   <div class="post" id="post-207156">
    <div class="subject"><a href="#post-207156">Re: passing values to proc</a></div>
    <div class="body">Now you&#039;ve got me all wishy washy :shock:<br /><br />Why not just post your source code so that I can have a look ;)</div>
    <div class="meta">Posted on 2009-03-25 13:39:16 by JimmyClif</div>
   </div>
   <div class="post" id="post-207157">
    <div class="subject"><a href="#post-207157">Re: passing values to proc</a></div>
    <div class="body">I think I see what&#039;s going on now. &nbsp;If I put my procedure after my ExitProcess call it works. &nbsp;So, I guess, basically you can&#039;t define procedures in-line with the normal code. &nbsp;I guess it&#039;s not an issue in event-based code for GUI apps given the way they are layed out. &nbsp;This, being linear, exposed it. &nbsp;I&#039;ve been doing too much scripting I guess. :) &nbsp;Here&#039;s the way the code was before I moved it:<br /><br /><pre><code><br />;+----------------------------------------------------------------------------+<br />;|&nbsp; Assembler Directives:<br />.386<br />.model&nbsp; flat,stdcall<br />option&nbsp; casemap:none<br />;|<br />;+----------------------------------------------------------------------------+<br /><br />;+----------------------------------------------------------------------------+<br />;|&nbsp; Function Prototypes:<br />NumberToString&nbsp; proto&nbsp; :DWORD<br /><br />;|<br />;+----------------------------------------------------------------------------+<br /><br />;+----------------------------------------------------------------------------+<br />;|&nbsp; Includes:<br />;|&nbsp; &nbsp; &nbsp; Headers:<br />include \masm32\include\windows.inc<br />include \masm32\include\user32.inc<br />include \masm32\include\userenv.inc<br />include \masm32\include\kernel32.inc<br />include confunc.inc<br /><br />;|<br />;|&nbsp; &nbsp; &nbsp; Libraries:<br />includelib \masm32\lib\user32.lib<br />includelib \masm32\lib\userenv.lib<br />includelib \masm32\lib\kernel32.lib<br /><br />;|<br />;|&nbsp; &nbsp; &nbsp; Project:<br /><br />;|<br />;+----------------------------------------------------------------------------+<br /><br />.const<br />;+----------------------------------------------------------------------------+<br />;|&nbsp; Constants:<br />WSOCK_VERSION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;EQU&nbsp; &nbsp; &nbsp;02h<br /><br />;|<br />;|&nbsp; Structs:<br /><br />;|<br />;|<br />;+----------------------------------------------------------------------------+<br /><br />.data&nbsp; &nbsp;;|Data section begins<br />;+----------------------------------------------------------------------------+<br />;|&nbsp; Globals:<br />;|&nbsp; &nbsp; &nbsp; Initialized:<br />AppTitle	&nbsp; &nbsp; db		&quot;TestBed&quot;,0<br />strCRLF		&nbsp; &nbsp; db		0dh,0ah,0<br />strPressAnyKey&nbsp; db&nbsp; &nbsp; &nbsp; &quot;Press any key to continue...&quot;,0&nbsp; <br /><br />;|<br />;+----------------------------------------------+<br /><br />.data?<br />;+----------------------------------------------+<br />;|&nbsp; &nbsp; &nbsp; Uninitialized:<br />hInstance	dd		?<br />hInput		dd		?<br />hOutput		dd		?<br />dwWritten	dd		?<br />strInput&nbsp; &nbsp; db 255&nbsp; dup(?)<br />bufInput&nbsp; &nbsp; dw 128&nbsp; dup(?)<br /><br />;|<br />;+----------------------------------------------------------------------------+<br /><br />.code&nbsp; &nbsp;;|Code section begins<br />;+----------------------------------------------------------------------------+<br />;|&nbsp; Startup:<br />start:<br /><br /><br />;## Create a console for io<br />invoke	GetModuleHandle, NULL<br />mov		hInstance, eax<br /><br />;## Set the console window&#039;s title<br />invoke	SetConsoleTitle, ADDR AppTitle<br /><br />;## Get a handle for input<br />invoke 	GetStdHandle,STD_INPUT_HANDLE<br />.IF (eax == INVALID_HANDLE_VALUE)<br />	invoke	MessageBox, NULL, ADDR AppTitle, ADDR AppTitle, MB_OK<br />	invoke	ExitProcess, 1<br />.ENDIF<br />mov 	hInput,eax<br /><br />;## Get a handle for output<br />invoke 	GetStdHandle,STD_OUTPUT_HANDLE<br />.IF (eax == INVALID_HANDLE_VALUE)<br />	invoke	MessageBox, NULL, ADDR AppTitle, ADDR AppTitle, MB_OK<br />	invoke	ExitProcess, 1<br />.ENDIF<br />mov 	hOutput,eax&nbsp; <br /><br />;## Write some text to the screen<br />invoke 	Print, hOutput, ADDR AppTitle<br />invoke&nbsp; Print, hOutput, NULL<br /><br /><br />;## ----------------------------------<br />;## -----Start main body of code------<br /><br />invoke&nbsp; NumberToString, 9328<br /><br />NumberToString&nbsp; &nbsp;proc&nbsp; &nbsp; dwNumberIn:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;dwRemainder:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;dwQuotient:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;strNumber[15]:BYTE<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;dwNumber:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;pCharPosition:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;dwDivCount:DWORD<br />&nbsp; &nbsp; LOCAL&nbsp; &nbsp;dwDivisor:DWORD<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; <br />&nbsp; &nbsp; <br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;## Maximum DWORD value is 4,294,967,295 (0xFFFFFFFF)<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;eax, dwNumberIn<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;dwNumber, eax<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;## Set the string buffer tracking variable<br />&nbsp; &nbsp; lea&nbsp; &nbsp; &nbsp;eax, strNumber<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;pCharPosition, eax<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;## Set the initial divisor to 1 billion and the div count to 9<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;dwDivisor, 1000000000&nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;dwDivCount, 9<br />&nbsp; &nbsp;<br />&nbsp; &nbsp; ;## Clear the output buffer with zeros<br />&nbsp; &nbsp; pushf<br />&nbsp; &nbsp; cld<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;al, 0<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;ecx, SIZEOF strNumber<br />&nbsp; &nbsp; lea&nbsp; &nbsp; &nbsp;edi, strNumber<br />&nbsp; &nbsp; rep&nbsp; &nbsp; &nbsp;stosb<br />&nbsp; &nbsp; popf<br />&nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; ;## Enter the loop to begin dividing down the number by 10&#039;s.&nbsp; The idea is to<br />&nbsp; &nbsp; ;## divide the number again and again by descending 10&#039;s position and use the<br />&nbsp; &nbsp; ;## quotient as the basis for what number goes at that position.&nbsp; Then we add<br />&nbsp; &nbsp; ;## 48 to that number to get to the corresponding ascii character.<br />&nbsp; &nbsp; .WHILE (dwDivCount &gt; 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; ;## See if this number is divisible by the divisor<br />&nbsp; &nbsp; &nbsp; &nbsp; nop<br />&nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp; &nbsp;eax, eax<br />&nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp; &nbsp;edx, edx <br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;eax, dwNumber<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;ebx, dwDivisor<br />&nbsp; &nbsp; &nbsp; &nbsp; div&nbsp; &nbsp; &nbsp;ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;dwRemainder, edx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;dwQuotient, eax<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; .IF (dwQuotient &gt; 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke&nbsp; MessageBox, NULL, ADDR strNumber, ADDR AppTitle, MB_OK&nbsp; &nbsp;;## Printf debugger<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## This number was larger than the divisor so the quotient<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## should tell us what the first character should be.&nbsp; We need<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## to add 48 to that number to get the equivelant ascii char.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## We then store the character in the first byte of the string.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp; &nbsp;eax, eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;eax, dwQuotient<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; add&nbsp; &nbsp; &nbsp;eax, 48<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;edi, pCharPosition<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stosb<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## Increment to the next byte in the string buffer.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc&nbsp; &nbsp; &nbsp;pCharPosition<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## Now subtract (quotient * divisor) from the original value<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;## to begin testing the next position.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .WHILE (dwQuotient &gt; 0)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;eax, dwNumber<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub&nbsp; &nbsp; &nbsp;eax, dwDivisor<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;dwNumber, eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dec&nbsp; &nbsp; &nbsp;dwQuotient<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .ENDW<br />&nbsp; &nbsp; &nbsp; &nbsp; .ENDIF<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ;## Decrement the div count and divide the divisor by 10 to get the<br />&nbsp; &nbsp; &nbsp; &nbsp; ;## next 10&#039;s position to test<br />&nbsp; &nbsp; &nbsp; &nbsp; dec&nbsp; &nbsp; &nbsp;dwDivCount<br />&nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp; &nbsp;eax, eax<br />&nbsp; &nbsp; &nbsp; &nbsp; xor&nbsp; &nbsp; &nbsp;edx, edx <br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;eax, dwDivisor<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;ebx, 10<br />&nbsp; &nbsp; &nbsp; &nbsp; div&nbsp; &nbsp; &nbsp;ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;dwDivisor, eax&nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; .ENDW<br />&nbsp; &nbsp;<br />&nbsp; &nbsp; ;## Put the final remainder in the last string position<br />&nbsp; &nbsp; xor&nbsp; &nbsp; &nbsp;eax, eax<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;eax, dwNumber<br />&nbsp; &nbsp; add&nbsp; &nbsp; &nbsp;eax, 30<br />&nbsp; &nbsp; mov&nbsp; &nbsp; &nbsp;edi, pCharPosition<br />&nbsp; &nbsp; stosb<br /><br /><br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;## Print the output<br />&nbsp; &nbsp; invoke&nbsp; Print, hOutput, ADDR strNumber<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; <br />&nbsp; &nbsp; xor&nbsp; &nbsp; &nbsp;eax, eax<br />&nbsp; &nbsp; ret<br />NumberToString&nbsp; &nbsp;endp<br /><br />;## -----End main body of code--------<br />;## ----------------------------------<br /><br /><br />;## Pause for keystroke<br />invoke&nbsp; Print, hOutput, ADDR strPressAnyKey<br />invoke&nbsp; PauseForKey, hInput<br /><br />;## Quit normally<br />invoke	ExitProcess, NULL<br /><br /><br />;+----------------------------------------------------------------------------+<br />;|	Extra asm sources libraries:<br />include	confunc.asm<br /><br />;|<br />;|<br />end start<br />;|	End of program.<br />;+----------------------------------------------------------------------------+<br /></code></pre></div>
    <div class="meta">Posted on 2009-03-25 13:52:39 by rdaneel</div>
   </div>
   <div class="post" id="post-207158">
    <div class="subject"><a href="#post-207158">Re: passing values to proc</a></div>
    <div class="body"><div class="quote">So, I guess, basically you can&#039;t define procedures in-line with the normal code.</div><br /><br />I guess you answered your own question. Try debugging your code starting at &quot;invoke NumberToString, 9328&quot; and check what happens after you return from that function. <br /><br />Plopp all your functions either after the final ExitProcess or before the start: and all should be well. </div>
    <div class="meta">Posted on 2009-03-25 14:06:16 by JimmyClif</div>
   </div>
   <div class="post" id="post-207159">
    <div class="subject"><a href="#post-207159">Re: passing values to proc</a></div>
    <div class="body">Thanks JC.&nbsp; Got it working.&nbsp; I knew I was missing the obvious.&nbsp; Just couldn&#039;t see it.&nbsp; ;)</div>
    <div class="meta">Posted on 2009-03-25 15:05:51 by rdaneel</div>
   </div>
  </div>
 </body>
</html>