<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>function GetCL - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=22332" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=22332">function GetCL</a></p>
   <div class="post" id="post-167717">
    <div class="subject"><a href="#post-167717">function GetCL</a></div>
    <div class="body">heloo.<br />how make function GetCL in fasm pleas help me<br /><br />soory fo my english</div>
    <div class="meta">Posted on 2005-11-10 02:16:01 by zames</div>
   </div>
   <div class="post" id="post-167745">
    <div class="subject"><a href="#post-167745">Re: function GetCL</a></div>
    <div class="body">zames,<br /><br />This is the best I can do for you. I disassembled the MASM32 GetCL function from witin an application and formated it as bare mnemonics. It is still in standard Intel notation so you wil need to modify the notation so it will build in FASM. The procedure has been very reliable but it probably needs a rewrite to modernise it. You can use the reference in the MASM32 help file for how the procedure works and what the return values are.<br /><br /><span class="mono"><br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br /><br />fn_00401030:<br /><br />&nbsp; &nbsp; push ebp<br />&nbsp; &nbsp; mov ebp, esp<br />&nbsp; &nbsp; add esp, 0FFFFFE7Ch<br />&nbsp; &nbsp; push esi<br />&nbsp; &nbsp; push edi<br />&nbsp; &nbsp; call GetCommandLineA<br />&nbsp; &nbsp; mov , eax<br />&nbsp; &nbsp; xor ecx, ecx<br />&nbsp; &nbsp; mov esi, <br /><br />&nbsp; lbl0:<br />&nbsp; &nbsp; lodsb<br />&nbsp; &nbsp; cmp al, 0<br />&nbsp; &nbsp; jz lbl1<br />&nbsp; &nbsp; cmp al, 22h<br />&nbsp; &nbsp; jnz lbl0<br />&nbsp; &nbsp; inc ecx<br />&nbsp; &nbsp; jmp lbl0<br /><br />&nbsp; lbl1:<br />&nbsp; &nbsp; push ecx<br />&nbsp; &nbsp; shr ecx, 1<br />&nbsp; &nbsp; shl ecx, 1<br />&nbsp; &nbsp; pop eax<br />&nbsp; &nbsp; cmp eax, ecx<br />&nbsp; &nbsp; jz lbl2<br />&nbsp; &nbsp; pop edi<br />&nbsp; &nbsp; pop esi<br />&nbsp; &nbsp; mov eax, 3<br />&nbsp; &nbsp; leave<br />&nbsp; &nbsp; ret 8<br /><br />&nbsp; lbl2:<br />&nbsp; &nbsp; mov esi, <br />&nbsp; &nbsp; lea edi, <br /><br />&nbsp; lbl3:<br />&nbsp; &nbsp; lodsb<br />&nbsp; &nbsp; cmp al, 0<br />&nbsp; &nbsp; jz lbl5<br />&nbsp; &nbsp; cmp al, 9<br />&nbsp; &nbsp; jnz lbl4<br />&nbsp; &nbsp; mov al, 20h<br /><br />&nbsp; lbl4:<br />&nbsp; &nbsp; stosb<br />&nbsp; &nbsp; jmp lbl3<br /><br />&nbsp; lbl5:<br />&nbsp; &nbsp; stosb<br />&nbsp; &nbsp; lea eax, <br />&nbsp; &nbsp; mov esi, eax<br />&nbsp; &nbsp; mov edi, eax<br /><br />&nbsp; lbl6:<br />&nbsp; &nbsp; lodsb<br />&nbsp; &nbsp; cmp al, 0<br />&nbsp; &nbsp; jnz lbl7<br />&nbsp; &nbsp; jmp lbl12<br /><br />&nbsp; lbl7:<br />&nbsp; &nbsp; cmp al, 22h<br />&nbsp; &nbsp; jnz lbl8<br />&nbsp; &nbsp; stosb<br />&nbsp; &nbsp; jmp lbl9<br /><br />&nbsp; lbl8:<br />&nbsp; &nbsp; stosb<br />&nbsp; &nbsp; jmp lbl6<br /><br />&nbsp; lbl9:<br />&nbsp; &nbsp; lodsb<br />&nbsp; &nbsp; cmp al, 20h<br />&nbsp; &nbsp; jnz lbl10<br />&nbsp; &nbsp; mov al, 0FEh<br /><br />&nbsp; lbl10:<br />&nbsp; &nbsp; cmp al, 22h<br />&nbsp; &nbsp; jnz lbl11<br />&nbsp; &nbsp; stosb<br />&nbsp; &nbsp; jmp lbl6<br /><br />&nbsp; lbl11:<br />&nbsp; &nbsp; stosb<br />&nbsp; &nbsp; jmp lbl9<br /><br />&nbsp; lbl12:<br />&nbsp; &nbsp; stosb<br />&nbsp; &nbsp; lea eax, <br />&nbsp; &nbsp; mov esi, eax<br />&nbsp; &nbsp; lea edi, <br />&nbsp; &nbsp; mov ecx, 0<br /><br />&nbsp; lbl13:<br />&nbsp; &nbsp; lodsb<br />&nbsp; &nbsp; cmp al, 20h<br />&nbsp; &nbsp; jz lbl13<br /><br />&nbsp; lbl14:<br />&nbsp; &nbsp; cmp ecx, <br />&nbsp; &nbsp; jz lbl17<br />&nbsp; &nbsp; lodsb<br />&nbsp; &nbsp; cmp al, 0<br />&nbsp; &nbsp; jz lbl19<br />&nbsp; &nbsp; cmp al, 20h<br />&nbsp; &nbsp; jnz lbl16<br /><br />&nbsp; lbl15:<br />&nbsp; &nbsp; lodsb<br />&nbsp; &nbsp; cmp al, 20h<br />&nbsp; &nbsp; jz lbl15<br />&nbsp; &nbsp; inc ecx<br />&nbsp; &nbsp; cmp al, 0<br />&nbsp; &nbsp; jz lbl19<br /><br />&nbsp; lbl16:<br />&nbsp; &nbsp; jmp lbl14<br /><br />&nbsp; lbl17:<br />&nbsp; &nbsp; stosb<br /><br />&nbsp; lbl18:<br />&nbsp; &nbsp; lodsb<br />&nbsp; &nbsp; cmp al, 20h<br />&nbsp; &nbsp; jz lbl19<br />&nbsp; &nbsp; cmp al, 0<br />&nbsp; &nbsp; jz lbl19<br />&nbsp; &nbsp; stosb<br />&nbsp; &nbsp; jmp lbl18<br /><br />&nbsp; lbl19:<br />&nbsp; &nbsp; mov al, 0<br />&nbsp; &nbsp; stosb<br />&nbsp; &nbsp; cmp ecx, <br />&nbsp; &nbsp; jnb lbl20<br />&nbsp; &nbsp; mov edi, <br />&nbsp; &nbsp; mov al, 0<br />&nbsp; &nbsp; stosb<br />&nbsp; &nbsp; mov eax, 2<br />&nbsp; &nbsp; pop edi<br />&nbsp; &nbsp; pop esi<br />&nbsp; &nbsp; leave<br />&nbsp; &nbsp; ret 8<br /><br />&nbsp; lbl20:<br />&nbsp; &nbsp; lea eax, <br />&nbsp; &nbsp; mov esi, eax<br />&nbsp; &nbsp; mov edi, <br /><br />&nbsp; lbl21:<br />&nbsp; &nbsp; lodsb<br />&nbsp; &nbsp; cmp al, 0<br />&nbsp; &nbsp; jz lbl23<br />&nbsp; &nbsp; cmp al, 22h<br />&nbsp; &nbsp; jz lbl21<br />&nbsp; &nbsp; cmp al, 0FEh<br />&nbsp; &nbsp; jnz lbl22<br />&nbsp; &nbsp; mov al, 20h<br /><br />&nbsp; lbl22:<br />&nbsp; &nbsp; stosb<br />&nbsp; &nbsp; jmp lbl21<br /><br />&nbsp; lbl23:<br />&nbsp; &nbsp; stosb<br />&nbsp; &nbsp; mov esi, <br />&nbsp; &nbsp; lodsb<br />&nbsp; &nbsp; cmp al, 0<br />&nbsp; &nbsp; jnz lbl24<br />&nbsp; &nbsp; pop edi<br />&nbsp; &nbsp; pop esi<br />&nbsp; &nbsp; mov eax, 4<br />&nbsp; &nbsp; leave<br />&nbsp; &nbsp; ret 8<br /><br />&nbsp; lbl24:<br />&nbsp; &nbsp; mov eax, 1<br />&nbsp; &nbsp; pop edi<br />&nbsp; &nbsp; pop esi<br />&nbsp; &nbsp; leave<br />&nbsp; &nbsp; ret 8<br /></span><br /><br />Regards,<br /><br />hutch at movsd dot com</div>
    <div class="meta">Posted on 2005-11-10 22:01:41 by hutch--</div>
   </div>
   <div class="post" id="post-167749">
    <div class="subject"><a href="#post-167749">Re: function GetCL</a></div>
    <div class="body">zames, unless the bug has been fixed, I would advice against using hutch&#39;s GetCL as it has/had known buffer overflow problems.<br /><br />http://www.masmforum.com/simple/index.php?topic=1443.0<br />http://www.masmforum.com/simple/index.php?topic=1534.0<br /></div>
    <div class="meta">Posted on 2005-11-11 02:46:36 by f0dder</div>
   </div>
   <div class="post" id="post-167772">
    <div class="subject"><a href="#post-167772">Re: function GetCL</a></div>
    <div class="body">It is a mistake to assume poor high level code design with assembler procedures. In terms of primitives a command line parsing algo performs a different task to testing a command line length and/or setting a buffer size and controlling the input length.<br /><br />The command line buffer is controlled by the OS and late versions of Windows have 32k so all you need to do if you application is being placed where it s subject to potential exploits is to check the LENGTH of the command line and reject it if it is too long for the application&#39;s use.<br /><br />This is how simple it is in MASM32 to test this condition.<br /><span class="mono"><br />main proc<br /><br />&nbsp; &nbsp; .if len(rv(GetCommandLine)) &gt; 128<br />&nbsp; &nbsp; &nbsp; print &quot;Warning, Some idiot is trying a stack overflow exploit.&quot;,13,10<br />&nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; print &quot;It appears the command line did not exceed the limit&quot;,13,10<br /><br />&nbsp; &nbsp; ret<br /><br />main endp<br /></span><br />You should have no problems doing the same test with FASM.<br /><br />The simplicity of assembler code when properly understood saves you from other people slow bloated badly designed C++ code. If and where you do have some serios security concern, it is ALWAYS safer to design the code to block the risk that accept someone elses crappy code design.</div>
    <div class="meta">Posted on 2005-11-11 17:49:35 by hutch--</div>
   </div>
   <div class="post" id="post-167787">
    <div class="subject"><a href="#post-167787">Re: function GetCL</a></div>
    <div class="body">Here&#39;s a cmdline argument parser that has no silly hardcoded assumptions on commandline buffer string length, nor amount of arguments the user wishes to pass. It doesn&#39;t modify the input buffer either; this adds a bit to the complexity of the algorith, but means it will NOT break if Microsoft decides to make the GetCommandLine() memory read-only in a future windows version.<br /><br />It eliminates whitespace, and supports the usual double-quoted strings. It does NOT perform any expansion of arguments, so _g_cmdline_args[0] is not necessarily the full path to your executable; if somebody types &quot;main blabla&quot; from a console, _g_cmdline_args[0] will be &quot;main&quot;, not even &quot;main.exe&quot;, thus the routine can easily be adapted to a generic string tokenizer.<br /><br />The parsing logic is a simple copy-paste of what I use in my C++ code, compiled with optimize-for-size - the assembly code can certainly be improved, but this was written for correct operation, not speed. When used for commandline parsing it&#39;s only called once anyway.<br /><br />The assembly code is written in FASM/NASM style assembly without any macros or highlevel statements, which means it&#39;s easy to convert to any assembler of choice. It might hurt readability a bit, so I&#39;ve included the C++ source it was based on.<br /><br />If you find any bugs or have suggestions for improvements, please let me know - there&#39;s <strong>NO excuses</strong> for buggy code or kludgy workarounds.<br /><br />See attached .zip for &quot;the whole package&quot; - I&#39;m posting the main FASM code here, too, for future reference even when attachments are pruned.<br /><br /><pre><code><br /><br />format ms coff<br /><br />; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />; DATA section<br />; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />section &#39;.data&#39; data<br />	_g_cmdline_block	dd 0<br />	_g_cmdline_args		dd 0<br />	_g_cmdline_argcount dd 0<br /><br />	PUBLIC _g_cmdline_block<br />	PUBLIC _g_cmdline_args<br />	PUBLIC _g_cmdline_argcount<br />	<br /><br />; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />; CODE section<br />; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br />section &#39;.code&#39; code<br /><br />EXTRN _GetProcessHeap@0<br />EXTRN _HeapAlloc@12<br /><br />EXTRN _malloc<br /><br />; internal_alloc: allocates memory, amount of bytes passed in EAX.<br />internal_alloc:<br />	push	eax					; dwBytes<br />	call	_GetProcessHeap@0<br />	push	dword 0				; dwFlags<br />	push	eax					; hHeap<br />	call	_HeapAlloc@12<br />	ret<br /><br /><br /><br />;<br />; void __stdcall cmdline_init(const char *input);<br />;&nbsp;  tokenizes `input&#39;, removing whitespace and handling double-quoted arguments.<br />;&nbsp;  Output: g_cmdline_block contains input in tokenized-and-terminated form,<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  g_cmdline_args is an array of pointers into g_cmdline_block,<br />;			g_cmdline_argcount is the number of pointers in g_cmdline_args.<br />;<br />PUBLIC _cmdline_init@4<br />_cmdline_init@4:<br />	_input$			equ 8<br />	_totalbytes$	equ (-16)<br />	_pushedstart$	equ (-24)<br /><br />	push	ebp<br />	mov		ebp, esp<br /><br />	push	ebx<br />	push	esi<br />	push	edi<br />	sub		esp, 4<br /><br />	xor		esi, esi<br />	mov		[_g_cmdline_argcount], esi<br />	mov		, esi<br /><br />	mov		ebx, <br />	cmp		byte , 0<br />	je		.doneparse<br /><br />	mov		eax, ebx<br /><br />.mainloop:<br />	; skip whitespace<br />	cmp		byte , &#39; &#39;<br />	jne		.notws1<br />.skipws1:<br />	inc		esi<br />	cmp		byte , &#39; &#39;<br />	je		.skipws1<br />.notws1:<br /><br />	; if we reached end of string, break<br />	mov		al, <br />	test	al, al<br />	je		.doneparse<br /><br />	; handle quote-delimited args<br />	cmp		al, &#39;&quot;&#39; <br />	jne		.notquote<br /><br />	; in quotes, consume until endquote<br />	inc		esi<br />	mov		edi, esi<br />	mov		al, <br />	test	al, al<br />	je		.next_iteration<br /><br />.find_endquote:<br />	cmp		al, &#39;&quot;&#39;<br />	je		.consume_done<br />	inc		edi<br />	mov		al, <br />	test	al, al<br />	jne		.find_endquote<br />	jmp		.consume_done<br /><br />.notquote:<br />	; not in quotes, consume until quote or whitespace<br />	lea	edi, <br /><br />	jmp		.consume_loop<br />.consume:<br />	cmp		al, &#39;&quot;&#39;<br />	je		.consume_done<br />	cmp		al, &#39; &#39;<br />	je		.consume_done<br />	inc		edi<br />.consume_loop:<br />	mov		al, <br />	test	al, al<br />	jne		.consume<br /><br />.consume_done:<br />	; at this point we have a string to add, or an empty string in cases like<br />	; two doublequotes right next to eachother.<br />	cmp		edi, esi<br />	jbe		.next_iteration<br /><br />	; push {start, end} pair to stack<br />	; !!! <br />	push	edi<br />	push	esi<br />	; !!!<br /><br />	; increase totalbytes... +1 because of NUL terminator<br />	mov		eax, edi<br />	sub		eax, esi<br />	inc		eax<br />	add		, eax<br /><br />	inc		dword [_g_cmdline_argcount]<br /><br />.next_iteration:<br />	lea		esi, <br />	lea		eax, <br />	cmp		byte , 0<br />	jne		.mainloop<br /><br />.doneparse:<br /><br />	; Allocate memory for the pointers-to-arguments buffer. Exit if no args<br />	; were detected.<br />	mov		eax, [_g_cmdline_argcount]<br />	test	eax, eax<br />	jz		.exit<br />	<br />	shl		eax, 2<br />	call	internal_alloc<br />	mov		[_g_cmdline_args], eax<br /><br />	; allocate memory for the tokenized commandline buffer<br />	mov		eax, <br />	call	internal_alloc<br />	mov		[_g_cmdline_block], eax<br /><br /><br />	; now comes the easy part - filling the g_cmdline_args with pointers, and<br />	; at the same time g_cmdline_block with tokenized and NUL-terminated strings;<br />	; copied from the input buffer.<br />	;<br />	mov		ecx, [_g_cmdline_argcount]<br />	mov		edi, [_g_cmdline_block]<br /><br />	lea		ebx, <br />	mov		edx, [_g_cmdline_args]<br />.fill_loop:<br />	; store arg pointer<br />	mov		, edi<br />	add		edx, 4<br /><br />	; copy string<br />	push	ecx<br />	mov		eax, 	; start-index<br />	mov		ecx, 	; end-index<br />	sub		ecx, eax<br /><br />	mov		esi, <br />	add		esi, eax<br />	rep		movsb<br />	xor		al, al<br />	stosb<br />	pop		ecx<br /><br />	; process next item<br />	sub		ebx, 8<br />	dec		ecx<br />	jnz		.fill_loop<br />	<br />.exit:<br />	pop		edi<br />	pop		esi<br />	pop		ebx<br /><br />	leave<br /><br />	retn	4<br /></code></pre><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1192" target="_blank">cmdline_parse.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2005-11-12 06:12:04 by f0dder</div>
   </div>
   <div class="post" id="post-167791">
    <div class="subject"><a href="#post-167791">Re: function GetCL</a></div>
    <div class="body">I suggest the member was looking for the simplicity of use when he asked about the GetCL procedure. It was written for win9x 128 byte command line limit in 1999 but its rarely exceeded. When I get around to it I will write one for a 32k limit but tere is no great demand at the moment.<br /><br />Here is the 2k bloated pig in MASM. Should be very easy to convert to FASM.<br /><br /><span class="mono"><br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br />&nbsp; &nbsp; include \masm32\include\masm32rt.inc<br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br /><br />comment * -----------------------------------------------------<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Build this&nbsp; template with<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &quot;CONSOLE ASSEMBLE AND LINK&quot;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  LEANER AND MEANER MASM<br />&nbsp; &nbsp; &nbsp; &nbsp; ----------------------------------------------------- *<br /><br />&nbsp; &nbsp; .code<br /><br />start:<br />&nbsp;  <br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br /><br />&nbsp; &nbsp; call main<br />&nbsp; &nbsp; exit<br /><br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br /><br />main proc<br /><br />&nbsp; &nbsp; LOCAL acnt&nbsp; :DWORD<br />&nbsp; &nbsp; LOCAL pbuf&nbsp; :DWORD<br />&nbsp; &nbsp; LOCAL buffer[128]:BYTE<br /><br />&nbsp; &nbsp; mov pbuf, ptr$(buffer)<br />&nbsp; &nbsp; cmp len(GetCommandLine),128&nbsp; &nbsp;  ; test command line length<br />&nbsp; &nbsp; jle @F<br /><br />&nbsp; &nbsp; ret&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; exit on exploit<br /><br />&nbsp; @@:<br />&nbsp; &nbsp; mov acnt, 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; set the argument counter<br /><br />&nbsp; @@:<br />&nbsp; &nbsp; cmp rv(GetCL,acnt,pbuf), 1&nbsp; &nbsp; &nbsp; ; read each arg into buffer<br />&nbsp; &nbsp; jne @F<br />&nbsp; &nbsp; print pbuf,13,10&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; display it at the console<br />&nbsp; &nbsp; add acnt, 1<br />&nbsp; &nbsp; jmp @B<br />&nbsp; @@:<br /><br />&nbsp; &nbsp; ret<br /><br />main endp<br /><br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br /><br />end start<br /></span></div>
    <div class="meta">Posted on 2005-11-12 08:25:55 by hutch--</div>
   </div>
   <div class="post" id="post-167792">
    <div class="subject"><a href="#post-167792">Re: function GetCL</a></div>
    <div class="body">Yay for workarounds to insecure code :)<br /><br />http://www.asmcommunity.net/board/index.php?topic=22332.msg167787#msg167787 - code works, and doesn&#39;t need to be &quot;updated to 32k limit&quot; since it has no assumptions. You could use it on a multi-megabyte string if you wanted to. It&#39;s dynamic and it works ^_^<br /></div>
    <div class="meta">Posted on 2005-11-12 08:35:28 by f0dder</div>
   </div>
   <div class="post" id="post-167818">
    <div class="subject"><a href="#post-167818">Re: function GetCL</a></div>
    <div class="body">hmmmm,<br /><br />&gt; Yay for workarounds to insecure code<br /><br />Knowing the difference between a command line parser and a test for a security issue is the difference between a minimal assembler method of achieving the task versus a far larger bloated C++ style of code. Would you use a sort algorithm to format a hard disk or a search algorithm to display an image on the screen ?<br /><br />Low level programming involves the use of primitives and in this instance it uses the measurement of the command line length and a command line parser to select each argument and puts the control directly in the hands of the programmer to select the functionaity they require, not what someone else wants to impliment on them complete with the bloat and unused functionality.<br /><br />It may be normal to treat C++ programmers like idiots but it is not a wise choice with assembler programmers who generally prefer to know what is going on with code instead of someone elses black box.<br /><br />Regards,<br /><br />hutch at movsd dot com</div>
    <div class="meta">Posted on 2005-11-12 17:19:40 by hutch--</div>
   </div>
   <div class="post" id="post-167824">
    <div class="subject"><a href="#post-167824">Re: function GetCL</a></div>
    <div class="body">Hello Hutch and f0dder,<br /><br />I am too lazy to argue with you guys. <br /><br />Hutch,<br />You are wrong to treat assembly programmers as knowing what they are doing because this is not true. Does all your users of the getcl function know about the potential bugs? All the bugs in the masm32lib that have been pointed out by f0dder were not really announced by you.<br /><br />f0dder, <br />let them suffer. Not your problem anyway, the world would not be more secured.</div>
    <div class="meta">Posted on 2005-11-12 20:22:00 by roticv</div>
   </div>
  </div>
 </body>
</html>