<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>C/C++ compiled to ASM not working - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=1096" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=1096">C/C++ compiled to ASM not working</a></p>
   <div class="post" id="post-7219">
    <div class="subject"><a href="#post-7219">C/C++ compiled to ASM not working</a></div>
    <div class="body">Can someone please enlighten my on a few things.  This is code for a function generated from the vc++6 c/c++ compiler.  I can't figure out why it crashes at: cmp BYTE PTR , 0 .  Wasn't the address of _address$ moved to edi??  Also, what does  mean when put after _address$ and why is it there? What are the esp and ebp registers for?  And just one more question (sorry).  Before the function is called in the main proc generated by the compiler I see that the addresses of the parameters are pushed onto the stack.  Why is this done and how are the addresses of the strings retrieved in the function 'cos it doesn't look like it pops them off the stack.  I've attached the original untouched generated file just incase.  Thanx in advance!<br /><br /><br /><br />searchstring proc _words$:dword, _address$:dword, _buffer$:dword, _until$:dword, _offfrom$:dword, _copyln$:dword<br />	push	ebx<br />	push	ebp<br /><br />	mov	ebp, DWORD PTR _words$<br />	push	esi<br />	xor	eax, eax<br />	xor	esi, esi<br />	push	edi<br />	mov	edi, DWORD PTR _address$<br />	test	ebp, ebp<br />	je	SHORT $nullpointer$42215<br /><br />	cmp	BYTE PTR , 0  ;&lt;---- crashes here!!<br />	je	SHORT $L42219<br /><br />	mov	cl, BYTE PTR <br />	mov	BYTE PTR 8+, cl<br />$L42218:<br />	mov	dl, BYTE PTR 8+<br />	mov	cl, BYTE PTR <br />	xor	ebx, ebx<br />	cmp	cl, dl<br />	jne	SHORT $L42226<br /><br />	mov	cl, BYTE PTR <br />	mov	esi, eax<br />	lea	edx, DWORD PTR <br />	lea	eax, DWORD PTR <br />	test	cl, cl<br />	mov	DWORD PTR 12+, edx<br />	je	SHORT $L42223<br /><br />	add	edx, edi<br />$L42222:<br /><br />	cmp	BYTE PTR , cl<br />	jne	SHORT $L42257<br />	mov	cl, BYTE PTR <br /><br />	inc	edx<br /><br />	inc	eax<br />	test	cl, cl<br />	jne	SHORT $L42222<br /><br />	jmp	SHORT $L42223<br />$L42257:<br /><br />	mov	ebx, 1<br />$L42223:<br /><br />	mov	ecx, DWORD PTR _copyln$<br />	mov	eax, esi<br />	test	ecx, ecx<br />	je	SHORT $L42258<br /><br />	test	ebx, ebx<br />	je	SHORT $nullpointer$42215<br />$L42226:<br /><br />	mov	cl, BYTE PTR <br /><br />	inc	eax<br />	test	cl, cl<br />	jne	SHORT $L42218<br />$L42219:<br />	pop	edi<br />	pop	esi<br />	pop	ebp<br /><br />	or	eax, -1<br />	pop	ebx<br /><br />	ret	0<br />$L42258:<br /><br />	mov	eax, esi<br />	pop	edi<br />	pop	esi<br />	pop	ebp<br />	pop	ebx<br /><br />	ret	0<br />$nullpointer$42215:<br /><br />	mov	ecx, DWORD PTR _copyln$<br />	mov	ebx, DWORD PTR _buffer$<br />	xor	edx, edx<br />	test	ecx, ecx<br />	jle	SHORT $L42259<br />	mov	ecx, DWORD PTR _offfrom$<br />	add	edi, esi<br />	mov	esi, DWORD PTR _until$<br />	add	edi, ecx<br />$L42230:<br /><br />	mov	cl, BYTE PTR <br />	cmp	cl, BYTE PTR <br />	je	SHORT $L42259<br />	cmp	cl, BYTE PTR <br />	je	SHORT $L42259<br />	cmp	cl, BYTE PTR <br />	je	SHORT $L42259<br />	cmp	cl, BYTE PTR <br />	je	SHORT $L42259<br />	cmp	cl, BYTE PTR <br />	je	SHORT $L42259<br /><br />	mov	BYTE PTR , cl<br />	mov	ecx, DWORD PTR _copyln$<br /><br />	inc	edx<br />	inc	edi<br />	cmp	edx, ecx<br />	jl	SHORT $L42230<br />$L42259:<br />	pop	edi<br />	pop	esi<br /><br />	mov	BYTE PTR , 0<br />	pop	ebp<br />	pop	ebx<br /><br />	ret	0<br />searchstring ENDP:o</div>
    <div class="meta">Posted on 2001-09-15 16:12:11 by nin</div>
   </div>
   <div class="post" id="post-7243">
    <div class="subject"><a href="#post-7243">C/C++ compiled to ASM not working</a></div>
    <div class="body">Nin,<br /><br />Try the following prototype and if this does not work, change the &quot;C&quot; to STDCALL&quot;.<br /><br />searchstring PROTO C :DWORD,:DWORD,:DWORD,:DWORD,:DWORD,:DWORD<br /><br />I gather you are trying to assembler this code as a module as it is a search function. To do that you need to specify the processor, memory model and make it case sensitive for 32 bit code.<br /><br />      .486                      ; create 32 bit code<br />      .model flat, stdcall      ; 32 bit memory model<br />      option casemap :none      ; case sensitive<br /><br />Then,<br /><br />.CODE<br /><br />The module,<br /><br />Then <br />END<br /><br />See if this helps you at all.<br /><br />Regards,<br /><br /><a href="mailto:hutch@pbq.com.au">hutch@pbq.com.au</a><br /><br />PS I should have added, use the command line,<br /><br />drv:\path\ML /c /coff yourmodule.asm</div>
    <div class="meta">Posted on 2001-09-16 01:23:34 by hutch--</div>
   </div>
   <div class="post" id="post-7276">
    <div class="subject"><a href="#post-7276">C/C++ compiled to ASM not working</a></div>
    <div class="body">I did everything you said including trying the &quot;C&quot; and &quot;STDCALL&quot; but when i try the &quot;C&quot; in the proto I get: error LNK2001: unresolved external symbol _searchstring and it still crashes when i use &quot;STDCALL&quot;.</div>
    <div class="meta">Posted on 2001-09-16 13:28:26 by nin</div>
   </div>
   <div class="post" id="post-7279">
    <div class="subject"><a href="#post-7279">C/C++ compiled to ASM not working</a></div>
    <div class="body">The above code doesn't setup a stack frame using EBP - instead all the passed parameters are accessed through ESP.  If your trying to assemble this with MASM, I think MASM is still trying to setup a stack frame with EBP.  I'm not certain as I haven't tried assembling code out of VC++, but I think this code requires quite a bit of editing.  If you don't understand what EBP/ESP are used for then you have a lot of reading in front of you. :)<br /><br />Does the C code crash?  Can you post the C code?</div>
    <div class="meta">Posted on 2001-09-16 14:22:03 by bitRAKE</div>
   </div>
   <div class="post" id="post-7280">
    <div class="subject"><a href="#post-7280">C/C++ compiled to ASM not working</a></div>
    <div class="body">Thanx for your help so far.  The C code is as follows and works fine:<br /><br /><br />int searchstring(char *words, char *address, char *buffer, char *until, int offfrom, int copyln)<br />{<br />	int x = 0, s = 0, a = 0, ok = 0;<br />	if(!words) goto nullpointer;<br /><br />	while(address != '\0')<br />	{<br />		ok = 0;<br /><br />		if(address == words[0])<br />		{<br />			s = x, a = 1;<br />			x ++;<br /><br />			while(words != '\0')<br />			{<br />				if(address != words){ ok = 1; break; }<br />				x ++;<br />				a ++;<br />			}<br /><br />			x = s;<br />			if(!copyln) return x;<br /><br />			if(!ok)<br />			{<br />				nullpointer:<br />				int p = s+offfrom, y = 0;<br />				<br />				while(y &lt; copyln)<br />				{<br />					if(address == until[0] ||<br />						address == until[1] ||<br />						address == until[2] ||<br />						address == until[3] ||<br />						address == until[4]) break;<br /><br />					buffer = address;<br />					p ++;<br />					y ++;<br />				}<br /><br />				buffer = '\0';<br />				return x;<br />			}<br /><br />		}<br /><br />		x ++;<br /><br />	}<br /><br />	return -1;<br /><br />}</div>
    <div class="meta">Posted on 2001-09-16 14:32:50 by nin</div>
   </div>
   <div class="post" id="post-7294">
    <div class="subject"><a href="#post-7294">C/C++ compiled to ASM not working</a></div>
    <div class="body">See how close MASM is to C.  A line for line translation. :)<pre><code>return MACRO val&#58;REQ<br />	mov eax,val<br />	ret<br />ENDM<br /><br />;int searchstring&#40;char *words, char *address, char *buffer, char *until, int offfrom, int copyln&#41; &#123;<br />searchstring PROC uses esi edi ebx,pWORDS&#58;DWORD,pADDRESS&#58;DWORD,pBUFFER&#58;DWORD,pUNTIL&#58;DWORD,offfrom&#58;DWORD,copyln&#58;DWORD<br />	LOCAL s&#58;DWORD<br />address EQU esi<br />words EQU edi<br />	mov address,pADDRESS<br />	mov words,pWORDS<br />x EQU ecx<br />a EQU edx<br />ok EQU ebx<br />;int x = 0, s = 0, a = 0, ok = 0;<br />	mov x,0<br />	mov s,0<br />	mov a,0<br />	mov ok,0<br />;if&#40;!words&#41; goto nullpointer;<br />	.if !pWORDS<br />		jmp nullpointer<br />	.endif<br />;while&#40;address&#91;x&#93; != '\0'&#41; &#123;<br />	.while &#40;BYTE PTR &#91;address + x&#93; != 0&#41;<br />;ok = 0;<br />		mov ok,0<br />;if&#40;address&#91;x&#93; == words&#91;0&#93;&#41; &#123;<br />		mov al,&#91;words&#93;<br />		.if BYTE PTR &#91;address + x&#93; == al<br />;s = x, a = 1;<br />			mov s,x<br />			mov a,1<br />;x ++;<br />			inc x<br />;while&#40;words&#91;a&#93; != '\0'&#41; &#123;<br />			.while BYTE PTR &#91;words + a&#93; != 0<br />;if&#40;address&#91;x&#93; != words&#91;a&#93;&#41;&#123; ok = 1; break; &#125;<br />				mov al,&#91;words + a&#93;<br />				.if &#91;address + x&#93; != al<br />					mov ok,1<br />					.break<br />				.endif<br />;x ++;<br />				inc x<br />;a ++;<br />				inc a<br />;&#125;<br />			.endw<br />;x = s;<br />			mov x,s<br />;if&#40;!copyln&#41; return x;<br />			.if !copyln<br />				return s ;s=x at this point!<br />			.endif<br />;if&#40;!ok&#41; &#123;<br />			.if !ok<br />nullpointer&#58;<br />p EQU ecx<br />y EQU edx<br />until EQU ebx<br />buffer EQU edi<br />				mov buffer,pBUFFER<br />				mov until,pUNTIL<br />;int p = s+offfrom, y = 0;<br />				mov p,offfrom<br />				add p,s<br />				mov y,0<br />;while&#40;y &lt; copyln&#41; &#123;<br />				.while y &lt; copyln<br />;if&#40;address&#91;p&#93; == until&#91;0&#93; || address&#91;p&#93; == until&#91;1&#93; || address&#91;p&#93; == until&#91;2&#93; || address&#91;p&#93; == until&#91;3&#93; || address&#91;p&#93; == until&#91;4&#93;&#41; break;<br />					mov al,&#91;address + p&#93;<br />					.if al == &#91;until&#93;<br />						.break<br />					.elseif al == &#91;until + 1&#93;<br />						.break<br />					.elseif al == &#91;until + 2&#93;<br />						.break<br />					.elseif al == &#91;until + 3&#93;<br />						.break<br />					.endif<br />;buffer&#91;y&#93; = address&#91;p&#93;;<br />					mov al,&#91;address + p&#93;<br />					mov &#91;buffer + y&#93;,al<br />;p ++;<br />					inc p<br />;y ++;<br />					inc y<br />;&#125;<br />				.endw<br />;buffer&#91;y&#93; = '\0';<br />				mov BYTE PTR &#91;buffer + y&#93;,0<br />;return x;<br />				return s ;s=x at this point!<br />;&#125;<br />			.endif<br />;&#125;<br />		.endif<br />;x ++;<br />		inc x<br />;&#125;<br />	.endw<br />;return -1;<br />	return -1<br />;&#125;<br />searchstring ENDP</code></pre></div>
    <div class="meta">Posted on 2001-09-16 17:26:32 by bitRAKE</div>
   </div>
   <div class="post" id="post-7295">
    <div class="subject"><a href="#post-7295">C/C++ compiled to ASM not working</a></div>
    <div class="body">nin, if you have a C algo you want to translate to asm, looking at<br />the compiler output is not a very good idea, at least not if you want<br />to try and understand what is happening - the same would be the<br />case when looking at highly optimized code written by somebody who's<br />good at optimizing asm code.<br /><br />If you want to mess with C/Asm linking, there's a lot of reading to<br />do. Calling conventions, name mangling, how the stack works, et<br />cetera.<br /><br />May I ask why you are messing with compiler-output asm source?<br />If you just want to link C with asm code, that's not hard to do. If you<br />want to optimize your code, there are better approaches.</div>
    <div class="meta">Posted on 2001-09-16 17:48:10 by f0dder</div>
   </div>
   <div class="post" id="post-7297">
    <div class="subject"><a href="#post-7297">C/C++ compiled to ASM not working</a></div>
    <div class="body">Well i had quite a good encryption algo not written by me in C and wanted to be able to turn it into an asm proc using the same params.  searchstring proc was just an example of what I was trying to do.  Basically, how can I convert it in this way from vc++??</div>
    <div class="meta">Posted on 2001-09-16 18:12:47 by nin</div>
   </div>
   <div class="post" id="post-7300">
    <div class="subject"><a href="#post-7300">C/C++ compiled to ASM not working</a></div>
    <div class="body">What <strong>f0dder</strong> was getting at was that you don't need to convert it - unless you find that kind of thing fun. :)  You could compile an object file and link it to your asm project, or you assemble your assembly stuff into an object file and link it into a C project.  There are many options that you can choose from.<br /><br />VC++ produces much better code than my conversion above.  It was just an example.</div>
    <div class="meta">Posted on 2001-09-16 20:04:30 by bitRAKE</div>
   </div>
   <div class="post" id="post-7317">
    <div class="subject"><a href="#post-7317">C/C++ compiled to ASM not working</a></div>
    <div class="body">Ahh nice!  But how do I create an object file for 1 function in vc++.  Or better still would it be better to create a .lib?  And don't I have to re-arrange things cos of the way the params are arranged in vc++??</div>
    <div class="meta">Posted on 2001-09-17 04:27:49 by nin</div>
   </div>
   <div class="post" id="post-7329">
    <div class="subject"><a href="#post-7329">C/C++ compiled to ASM not working</a></div>
    <div class="body">The &quot;Hardest&quot; thing about linking asm with C is the calling conventions<br />and name mangling. Make sure your C compiler uses the &quot;C&quot; calling<br />convention. If you're compiling in c++ mode, declare your functions<br />like:<br /><br /><pre><code><br />extern &quot;C&quot; int myFunc&#40;int parm1, int parm2&#41;;<br /></code></pre><br /><br />Or, even better<br /><br /><pre><code><br />#ifdef __cplusplus<br />extern &quot;C&quot; &#123;<br />#endif<br /><br />// function prototypes here<br /><br />#ifdef __cplusplus<br />&#125;<br />#endif<br /></code></pre><br /><br />In masm, you will then have to generate prototypes for your<br />functions, like...<br /><br /><pre><code><br />myFunc PROTO C &#58;DWORD, &#58;DWORD<br /></code></pre><br /><br />... and then you should be all set, and able to use invoke :).</div>
    <div class="meta">Posted on 2001-09-17 08:26:46 by f0dder</div>
   </div>
   <div class="post" id="post-7337">
    <div class="subject"><a href="#post-7337">C/C++ compiled to ASM not working</a></div>
    <div class="body">If you do want to use the code in MASM, then you can disable the prologue &amp; epilogue like so:<br /><br /><pre><code><br />OPTION PROLOGUE&#58;NONE<br />OPTION EPILOGUE&#58;NONE<br /></code></pre><br />This will stop the variable names being any use to you though, you also have to remember to &quot;ret&quot; the proper value (not a problem with the C calling convention as it is always 0)!<br /><br />Remember to re-enable the defaults afterwards though!<br /><pre><code><br />OPTION PROLOGUE&#58;PrologueDef<br />OPTION EPILOGUE&#58;EpilogueDef<br /></code></pre><br /><br />If you do just want to use the function as is, it would probably be better to just keep the C obj file though.<br /><br />Mirno</div>
    <div class="meta">Posted on 2001-09-17 09:13:21 by Mirno</div>
   </div>
  </div>
 </body>
</html>