<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>math formula parsing - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=5767" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=5767">math formula parsing</a></p>
   <div class="post" id="post-41241">
    <div class="subject"><a href="#post-41241">math formula parsing</a></div>
    <div class="body">hi,<br /><br />i am trying to parse string expressions like &quot;1234567h+var1&quot; and &quot;4h*(var1+(2345h*var2))&quot; to a hexadecimal value. in these samples, considering var1=1 and var=2, the routine should have returned eax=1234568h, and eax=11A2Ch<br /><br />i have coded a couple of ascii2value() and value2ascii() functions, and also routines to return the value of variables.<br /><br />my problem is parsing it in a mathematical correct way, taking in acount the ( and ), and the precedence of * and / over + and -<br /><br />somebody have a idea of how parse these math strings in a efficient way?<br /><br />ancev</div>
    <div class="meta">Posted on 2002-06-03 10:44:38 by ancev</div>
   </div>
   <div class="post" id="post-41258">
    <div class="subject"><a href="#post-41258">math formula parsing</a></div>
    <div class="body">I was writing a calcaltor once and I wanted similar functionality so I wrote some routine, see attached file. <br /><br />There are a couple of things however, first the equations aren't represented as text but rather by a form of byte code I suppose you'd call it. Secondly seeing as I was writing this for a calculator which would want percision over speed I used FPU TBYTEs for all numbers. Thirdly there's no support for variable in the current implementation, but I image they'd pretty simple to include.<br /><br />Fell free to use this code if you want, but the method isn't too bad if you want to code your own implementation.<br /><br />Basically you have to start with the most nested layer and move back towards the least nested solving as you go.<br /><br />The step for solving a layer involve solving each function first, then solve the operators in the following order: {*,/},{+,-}<br /><br />Step1<br />Finding the first equation to solve simply requires starting at the left of the equation and finding the first &quot;)&quot;, then take the code between that and the preceeding &quot;(&quot;.<br /><br />Step 2<br />You search for function backwarks, ie start at the right and scan left, each time you find a function apply it to the number following it.<br /><br />Moving onto the operators you search forward, ie left to right for * &amp; /, followed by + &amp; -. When you find one simply apply it to the number before and after it.<br /><br />Can I recommend you run the Calc program, simply left click on it and it will display an equation along with the steps it took to solve it. Once you look at it you'll find its pretty simple understand the method. As for the code, its a bit of a mess, too much debuging stuff still in there. :(</div>
    <div class="meta">Posted on 2002-06-03 12:07:19 by EÃ³in</div>
   </div>
   <div class="post" id="post-41261">
    <div class="subject"><a href="#post-41261">math formula parsing</a></div>
    <div class="body">Google: <a target="_blank" href="http://www.google.com/search?hl=en&amp;lr=&amp;q=parse+precedence+reduce">http://www.google.com/search?hl=en&amp;lr=&amp;q=parse+precedence+reduce</a><br /><br />Use shift/reduce table to process the arguments.</div>
    <div class="meta">Posted on 2002-06-03 12:19:03 by bitRAKE</div>
   </div>
   <div class="post" id="post-41298">
    <div class="subject"><a href="#post-41298">math formula parsing</a></div>
    <div class="body">E?in,<br /><br />thanks for the code and the tips. i will implement your algo, i think. my implementation is simpler: i only need handle 32b numbers, and 8 vars.<br /><br />i am doing, for a softice linux clone, a more advanced parser, to be able to do things like &quot;DISASM ecx+eax*4&quot; and so on :)<br /><br />thanks for the help<br /><br />ancev</div>
    <div class="meta">Posted on 2002-06-03 16:41:36 by ancev</div>
   </div>
  </div>
 </body>
</html>