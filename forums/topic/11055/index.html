<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Win2k Context Issue - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=11055" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=11055">Win2k Context Issue</a></p>
   <div class="post" id="post-83295">
    <div class="subject"><a href="#post-83295">Win2k Context Issue</a></div>
    <div class="body">I'm not the only one to ask this question so I thought I would report my findings. Using the program below which is by no means complete but only to the point of proving what is happening with Win2k. The program is a modification of ICZ's or Hutche's debug tut#30. The program originally counted instructions of a debugee. What happens in Win2K as far as I can see is that a NTDLL loads all programs for extra security monitoring. So consequenty when the &quot;break&quot; exception is executed the DLL resumes control. So what happens is the debuggee never runs and the debugger will count an outragious number of instructions. This will through the user of course thinking that he or she cannot modify the register context. This program has several message boxes that first illustrate that first the Flags are indeed modified and it also illustrates that the Eip did not get loaded after &quot;break exception&quot; as is normally the case. So this program jam loads the Eip so that the debuggee can be executed in single step mode. But what is interesting to note is that when the debuggee exits the program does not end but returns to the NTDLL. For now I inserted an instruction count register variable as an escaped from what would be alot of mouse clicking. Use the simple debuggee called movEbx.exe.<br /><br />&quot;Debuggee&quot;<br /><br />.386<br /><br />.model flat, stdcall<br />option casemap:none<br />include \masm32\include\windows.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\user32.inc<br />includelib \masm32\lib\user32.lib<br />includelib \masm32\lib\kernel32.lib<br /><br />.data<br /><br />.code<br /><br />start:<br />      mov ebx,001234abcdh<br />      mov ecx,ebx<br />      mov ebx,ecx<br />      mov edx,ecx<br />      mov ecx,ecx<br />	invoke ExitProcess,NULL<br />end start<br /><br /><br />&quot;The Debugger&quot;<br /><br />.386<br />.model flat,stdcall <br />option casemap:none <br />include \masm32\include\windows.inc <br />include \masm32\include\kernel32.inc <br />include \masm32\include\comdlg32.inc <br />include \masm32\include\user32.inc <br />includelib \masm32\lib\kernel32.lib <br />includelib \masm32\lib\comdlg32.lib <br />includelib \masm32\lib\user32.lib <br /><br />.data <br />AppName db &quot;Win32 Debug Example no.4&quot;,0 <br />ofn OPENFILENAME &lt;&gt; <br />FilterString db &quot;Executable Files&quot;,0,&quot;*.exe&quot;,0 <br />             db &quot;All Files&quot;,0,&quot;*.*&quot;,0,0 <br />ExitProc db &quot;The debuggee exits&quot;,0<br />         <br />dispregXXX db &quot;regXXX= : %1x&quot;,0<br /> <br />ProcessInfo db &quot;File Handle: %lx &quot;,0dh,0Ah <br />            db &quot;Process Handle: %lx&quot;,0Dh,0Ah <br />            db &quot;Thread Handle: %lx&quot;,0Dh,0Ah <br />            db &quot;Image Base: %lx&quot;,0Dh,0Ah <br />            db &quot;Start Address: %lx&quot;,0<br />            <br />            <br />regEAX dd 0<br />regEBX dd 0<br />regECX dd 0<br />regEDX dd 0<br />regXXX dd 0<br />thread dd 0<br />Identify db &quot;Event: %x&quot;,0<br />Display2 db &quot;ProcessThread: %08x&quot;,0<br />Display3 db &quot;DBEventThread: %08x&quot;,0<br /><br />membufdisp db &quot;Dump: %1x&quot;,20h<br />           db &quot; %1x&quot;,0Dh,0Ah<br />           db &quot; ........%1x&quot;,20H<br />           db &quot; %1x&quot;,0<br /><br />displayregs db &quot;Reg- CS: %08x&quot;,0Dh,0Ah<br />            db &quot;Reg- DS: %08x&quot;,0Dh,0Ah<br />            db &quot;Reg- ES: %08x&quot;,0Dh,0Ah<br />            db &quot;Reg- SS: %08x&quot;,0Dh,0Ah<br />            db &quot;Reg- EAX: %08x&quot;,0Dh,0Ah<br />            db &quot;Reg- EBX: %08x&quot;,0Dh,0Ah<br />            db &quot;Reg- ECX: %08x&quot;,0Dh,0Ah<br />            db &quot;Reg- EDX: %08x&quot;,0Dh,0Ah<br />            db &quot;Reg- EIP: %08x&quot;,0Dh,0Ah<br />            db &quot;Reg- ESP: %08x&quot;,0Dh,0Ah<br />            db &quot;Reg- EBP: %08x&quot;,0Dh,0Ah<br />            db &quot;Reg- ESI: %08x&quot;,0Dh,0Ah<br />            db &quot;Reg- EDI: %08x&quot;,0Dh,0Ah<br />            db &quot;Reg- FS: %08x&quot;,0Dh,0Ah<br />            db &quot;Reg- GS: %08x&quot;,0Dh,0Ah<br />            db &quot;Reg- EFLAGS: %08x&quot;,0<br />               <br />bytesread dd 0<br />readbuff dd 0<br />baseaddr dd 0<br />errorMessage db &quot;Error: %s&quot;,0	     <br />MsgSrc dd 0<br />errorMsgbuff dd 0<br />globlock dd 0<br />loclock dd 0<br />count1 dd 0<br /><br />.data? <br /> <br />buffer db 4096 dup(?) <br />startinfo STARTUPINFO &lt;&gt; <br />pi PROCESS_INFORMATION &lt;&gt; <br />DBEvent DEBUG_EVENT &lt;&gt;<br />align dword <br />context CONTEXT &lt;&gt;<br /> <br />.code <br />start: <br />mov ofn.lStructSize,SIZEOF ofn <br />mov ofn.lpstrFilter, OFFSET FilterString <br />mov ofn.lpstrFile, OFFSET buffer <br />mov ofn.nMaxFile,512 <br />mov ofn.Flags, OFN_FILEMUSTEXIST or OFN_PATHMUSTEXIST or OFN_LONGNAMES or OFN_EXPLORER or OFN_HIDEREADONLY <br />invoke GetOpenFileName, ADDR ofn <br />    .if eax==TRUE <br />    invoke GetStartupInfo,addr startinfo <br />    invoke CreateProcess, addr buffer,NULL,NULL,NULL, FALSE,<br />    DEBUG_PROCESS+ DEBUG_ONLY_THIS_PROCESS , NULL, NULL, addr startinfo, addr pi<br />    cmp eax,0<br />    jne go5<br />    call DisplayLastError    <br />    int 3<br />     <br />go5:<br />      <br />    invoke SetDebugErrorLevel,SLE_MINORERROR <br />    .while TRUE <br />        <br />    invoke WaitForDebugEvent, addr DBEvent, INFINITE ;*****     <br />    .if DBEvent.dwDebugEventCode==EXIT_PROCESS_DEBUG_EVENT    <br />    invoke wsprintf, addr buffer, addr ExitProc <br />    invoke MessageBox, 0, addr buffer, addr AppName, MB_OK+MB_ICONINFORMATION <br />    <br />    .break<br />    <br />    .elseif DBEvent.dwDebugEventCode==CREATE_PROCESS_DEBUG_EVENT <br />    invoke wsprintf, addr buffer, addr ProcessInfo, DBEvent.u.CreateProcessInfo.hFile, DBEvent.u.CreateProcessInfo.hProcess, DBEvent.u.CreateProcessInfo.hThread, DBEvent.u.CreateProcessInfo.lpBaseOfImage, DBEvent.u.CreateProcessInfo.lpStartAddress <br />    invoke MessageBox,0, addr buffer, addr AppName, MB_OK+MB_ICONINFORMATION <br /><br />    invoke GlobalAlloc ,GMEM_MOVEABLE or GMEM_ZEROINIT,1000h<br />    mov readbuff,eax<br />    invoke GlobalLock,eax   ;**read process memory**<br />    mov globlock,eax<br />    mov eax,0h<br />    mov bytesread,eax       ;**and display/Dump**<br />    mov eax,401000h<br />    mov baseaddr,eax<br />    invoke ReadProcessMemory,pi.hProcess,baseaddr,addr readbuff,100h,addr bytesread<br />    push eax<br />    mov eax,bytesread<br />    mov regXXX,eax<br />    call DisplayregXXX    ;** no. of bytes read**<br />    pop eax<br />    cmp eax,0<br />    jne go4<br />    call DisplayLastError    <br />    int 3<br />     <br />go4:<br />    mov eax,readbuff+0<br />    call Swap<br />    mov readbuff+0,eax<br />    mov eax,readbuff+04h<br />    call Swap<br />    mov readbuff+04h,eax<br />    mov eax,readbuff+08h<br />    call Swap<br />    mov readbuff+08h,eax<br />    mov eax,readbuff+0Ch<br />    call Swap<br />    mov readbuff+0Ch,eax<br /><br />    invoke wsprintf,addr buffer,addr membufdisp,readbuff+00h,readbuff+04h,readbuff+08h,readbuff+0Ch <br />    invoke MessageBox, 0, addr buffer, addr AppName, MB_OK+MB_ICONINFORMATION<br />    invoke GlobalUnlock,addr globlock <br />    invoke GlobalFree,addr readbuff<br />    cmp eax,0<br />    jne go   <br />    call DisplayLastError    <br />    .break     <br />go:<br />    mov eax,DBEvent.u.CreateProcessInfo.hFile<br />    mov regEAX,eax <br />    mov ebx,DBEvent.u.CreateProcessInfo.hProcess<br />    mov regEBX,ebx<br />    mov ecx,DBEvent.u.CreateProcessInfo.hThread<br />    mov regECX,ecx<br />    mov edx,DBEvent.u.CreateProcessInfo.lpBaseOfImage<br />    mov regEDX,edx   <br />    <br />    .elseif DBEvent.dwDebugEventCode==LOAD_DLL_DEBUG_EVENT        ;*<br />    <br />    call DisplayEvent<br />    call DisplayDBThread                                                                       ;*<br />    call DisplayProcessThread<br /><br />    .elseif DBEvent.dwDebugEventCode==EXCEPTION_DEBUG_INFO ;***A***<br />    .if DBEvent.u.Exception.pExceptionRecord.ExceptionCode==EXCEPTION_DATATYPE_MISALIGNMENT<br />    <br />    invoke ContinueDebugEvent, DBEvent.dwProcessId, DBEvent.dwThreadId, DBG_CONTINUE<br />    .endif<br />            <br />    .elseif DBEvent.dwDebugEventCode==EXCEPTION_DEBUG_EVENT     <br />    .if DBEvent.u.Exception.pExceptionRecord.ExceptionCode==EXCEPTION_BREAKPOINT <br /><br />    mov eax,010h<br />    mov count1,eax      ;**intitialize instructions to count**<br /><br />    mov context.ContextFlags, CONTEXT_FULL<br />   <br />    call DisplayProcessThread<br />         <br />    invoke SuspendThread,pi.hThread<br />    invoke GetThreadContext,pi.hThread, addr context<br />    cmp eax,0h<br />    jne go1<br />    call DisplayLastError<br />    int 3<br />go1:<br />    <br />    mov eax,context.regFlag  ;** Set trap flag and jam load EIP**<br />    call DisplayAllRegs<br />    or context.regFlag,0100h <br />    invoke SetThreadContext,pi.hThread, addr context<br />    mov eax,0401000h<br />    mov context.regEip,eax<br />    invoke SetThreadContext,pi.hThread, addr context<br />    call DisplayAllRegs<br />    invoke ResumeThread,pi.hThread<br />    <br />        <br />    invoke ContinueDebugEvent, DBEvent.dwProcessId, DBEvent.dwThreadId, DBG_CONTINUE ;INT 3<br />     <br />     cmp eax,0<br />     jne go2<br />     call DisplayregXXX<br />     call DisplayLastError<br />    .break<br />go2:     <br />    .continue<br /><br />    <br /><br />    .elseif DBEvent.u.Exception.pExceptionRecord.ExceptionCode==EXCEPTION_SINGLE_STEP<br /><br />    call DisplayAllRegs    <br />        <br />    invoke SuspendThread,pi.hThread<br />    invoke GetThreadContext,pi.hThread,addr context<br />    or context.regFlag,0100h <br />    invoke SetThreadContext,pi.hThread, addr context<br />    invoke ResumeThread,pi.hThread<br /><br />    dec count1            ;**decrement instruction counter**<br />    jnz Continue<br />    .break<br />    <br />DisplayEvent:<br />   <br />    invoke wsprintf, addr buffer, addr Identify,DBEvent.u.Exception.pExceptionRecord.ExceptionCode  <br />    invoke MessageBox, 0, addr buffer, addr AppName, MB_OK+MB_ICONINFORMATION ;*   <br />    ret<br />    <br />DisplayDBThread:<br /><br />    invoke wsprintf, addr buffer, addr Display3, DBEvent.u.CreateProcessInfo.hThread <br />    invoke MessageBox,0, addr buffer, addr AppName, MB_OK+MB_ICONINFORMATION<br />    ret<br /><br />DisplayProcessThread:<br /><br />    pushad<br />    invoke wsprintf, addr buffer, addr Display2, pi.hThread <br />    invoke MessageBox,0, addr buffer, addr AppName, MB_OK+MB_ICONINFORMATION<br />    popad <br />    ret<br /><br />DisplayregXXX:<br /><br />    pushad<br />    invoke wsprintf, addr buffer,addr dispregXXX,regXXX<br />    invoke MessageBox,0, addr buffer, addr AppName, MB_OK+MB_ICONINFORMATION<br />    popad<br />    ret<br /><br />DisplayLastError:<br /><br />      push eax<br />      invoke GetLastError<br />      mov regXXX,eax<br />      mov MsgSrc,eax<br />      call DisplayregXXX<br />	invoke LocalAlloc ,LMEM_MOVEABLE or LMEM_ZEROINIT,1000<br />      mov errorMsgbuff,eax<br />      mov loclock,eax<br />      invoke LocalLock,loclock<br />	invoke FormatMessage,FORMAT_MESSAGE_ALLOCATE_BUFFER or FORMAT_MESSAGE_FROM_SYSTEM,0,MsgSrc,0,addr errorMsgbuff,0,NULL 		<br />	invoke wsprintf, addr buffer, addr errorMessage,errorMsgbuff<br />	invoke MessageBox,0,addr buffer, addr AppName, MB_OK+MB_ICONINFORMATION<br />      invoke LocalUnlock,addr loclock<br />	invoke LocalFree,addr errorMsgbuff<br />      pop eax<br />	ret<br /><br />DisplayAllRegs:<br /><br />      pushad<br />      mov context.ContextFlags, CONTEXT_FULL<br />      invoke GetThreadContext,pi.hThread, addr context <br />      invoke wsprintf, addr buffer, addr displayregs,context.regCs,context.regDs,context.regEs,context.regSs,<br />      context.regEax,context.regEbx,context.regEcx,context.regEdx,context.regEip,context.regEsp,context.regEbp,<br />      context.regEsi,context.regEdi,context.regFs,context.regGs,context.regFlag<br />      invoke MessageBox,0, addr buffer, addr AppName, MB_OK+MB_ICONINFORMATION<br />      popad<br />      ret<br /><br />Swap:<br /><br />      xchg ah,al<br />      mov ecx,010h<br />      rol eax,cl<br />      xchg ah,al<br />      ret<br />  <br />Continue:<br /><br />    invoke ResumeThread,pi.hThread<br />    <br />    <br />    invoke ContinueDebugEvent, DBEvent.dwProcessId, DBEvent.dwThreadId,DBG_CONTINUE <br /><br />    <br />    .endif<br />    .endif <br />    invoke ContinueDebugEvent, DBEvent.dwProcessId, DBEvent.dwThreadId, DBG_EXCEPTION_NOT_HANDLED <br />    .endw <br />    .endif <br />    invoke CloseHandle,pi.hProcess <br />    invoke CloseHandle,pi.hThread <br />    invoke ExitProcess, 0 <br />end start</div>
    <div class="meta">Posted on 2003-02-23 11:24:24 by mrgone</div>
   </div>
   <div class="post" id="post-83370">
    <div class="subject"><a href="#post-83370">Answer my own question</a></div>
    <div class="body">Intel Quote<br /><br />Nested task (bit 14). Controls the chaining of interrupted and called tasks. The<br />processor sets this flag on calls to a task initiated with a CALL instruction, an interrupt,or an exception. It examines and modifies this flag on returns from a task initiated with the IRET instruction. The flag can be explicitly set or cleared with the POPF/POPFD instructions; however, changing to the state of this flag can generate unexpected exceptions in application programs. Refer to Section 6.4., ?Task Linking? in Chapter 6, Task Management for more information on nested tasks.</div>
    <div class="meta">Posted on 2003-02-23 20:15:38 by mrgone</div>
   </div>
   <div class="post" id="post-86548">
    <div class="subject"><a href="#post-86548">another piece of info</a></div>
    <div class="body">I have also found that Dr Watson virus protection software comes with Win2k and is used in this NT DLL to various checking for what it may consider illegal instructions. The way it gets control must be through NT flag generated exceptions.</div>
    <div class="meta">Posted on 2003-03-11 14:44:33 by mrgone</div>
   </div>
  </div>
 </body>
</html>