<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Regular Expressions - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=15779" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=15779">Regular Expressions</a></p>
   <div class="post" id="post-122269">
    <div class="subject"><a href="#post-122269">Regular Expressions</a></div>
    <div class="body">Hiya Folks,<br /><br />Is using regular expressions in asm possible?<br />if it is, then is it efficient and where can i find a library (if there is one) or how can i make one?<br /><br />Regards,<br />Art</div>
    <div class="meta">Posted on 2003-10-23 21:22:28 by art_sands</div>
   </div>
   <div class="post" id="post-122275">
    <div class="subject"><a href="#post-122275">Re: Regular Expressions</a></div>
    <div class="body"><div class="quote"><br />Hiya Folks,<br /><br />Is using regular expressions in asm possible?<br />if it is, then is it efficient and where can i find a library (if there is one) or how can i make one?<br /><br />Regards,<br />Art </div><br /><br />Of course it is! After all, if you can do it in any other language you can certainly do it in assembly language :-). Now if you asking &quot;is there a library routine to which I can pass a string containing a regular expression and that routine will match some other string...&quot; then the answer is &quot;probably, but I don't know where.&quot; Certainly such things exist, I just don't have a direct source.<br /><br />What I can turn you on to, however, is the &quot;UCR Standard Library for 80x86 Assembly Language Programmers&quot; (MASM/DOS/16-bits) and the HLA Standard Library (32-bit/Win32/Linux). Both contain pattern matching libraries that support regular *and* context free languages. The HLA Standard Library is quite a bit more powerful (and more efficient) than the UCR stdlib version, but it does use HLA (and, unfortunately, the pattern matching library is one of the few parts of the HLA stdlib that didn't translate to MASM well, because of the limited macro capabilities of MASM).<br /><br />I have attached a sample HLA program where I converted the &quot;regular expression parser&quot; example from &quot;The Great Computer Language Shootout&quot; into HLA (note that I've included the C example in a commented-out section of the program, look below the C code to see the  equivalent HLA code). This is an interesting example as it clearly demonstrates that assembly language requires *fewer* lines of code than the comparable C code (and that doesn't even consider the fact that the C code in this example calls a non-standard library routine that wasn't included in the C source module!).<br /><br />You can find HLA and the HLA Standard Library, as well as the UCR Standard Library, at <a target="_blank" href="http://webster.cs.ucr.edu.">http://webster.cs.ucr.edu.</a><br />Cheers,<br />Randy Hyde<br /><br /><br /><br /><pre><code><br />// regexpGCLS<br />//<br />//  This program demonstrates processing of regular expressions in<br />// assembly language. This is based on the &quot;regexp.gcc&quot; <br />// program that is part of &quot;The Great Computer<br />// Language Shoot-out&quot; found at<br />//<br />//      &#91;url&#93;http&#58;//www.bagley.org/~doug/shootout/&#91;/url&#93;<br />//<br />// The purpose of that web page is to demonstrate several<br />// applications written in various languages. Although one<br />// of the primary purposes of that web site is to demonstrate<br />// the different run-time efficiencies of various languages,<br />// this HLA implementation was not created to demonstrate<br />// that assembly code is faster or smaller &#40;everyone pretty<br />// much accepts the fact that the fastest and/or smallest<br />// example of a program will be written in assembly language&#41;.<br />// Instead, this example demonstrates that with the use of<br />// a high level assembler &#40;e.g., HLA&#41;, it's also possible to<br />// write code almost as easily as in a high level language<br />// like C. As such, this example freely sacrifices efficiency<br />// for readability.<br /><br />#if&#40; false &#41;<br /><br />    /* -*- mode&#58; c -*-<br />     * $Id&#58; regexmatch.gcc,v 1.4 2000/12/24 05&#58;43&#58;53 doug Exp $<br />     * &#91;url&#93;http&#58;//www.bagley.org/~doug/shootout/&#91;/url&#93;<br />     */<br /><br />    #include &lt;sys/types.h&gt;<br />    #include &lt;sys/stat.h&gt;<br />    #include &lt;fcntl.h&gt;<br />    #include &lt;stdio.h&gt;<br />    #include &lt;pcre.h&gt;<br />    #include &lt;string.h&gt;<br /><br />    #define MAXLINES   100<br />    #define MAXLINELEN 132<br /><br />    char *pattern = <br />    &quot;&#40;?&#58;^|&#91;^\\d\\&#40;&#93;&#41;&quot;       /* must be preceeded by non-digit */<br />    &quot;&#40;\\&#40;&#41;?&quot;            /* match 1&#58; possible initial left paren */<br />    &quot;&#40;\\d\\d\\d&#41;&quot;           /* match 2&#58; area code is 3 digits */<br />    &quot;&#40;?&#40;1&#41;\\&#41;&#41;&quot;         /* if match1 then match right paren */<br />    &quot;&#91; &#93;&quot;               /* area code followed by one space */<br />    &quot;&#40;\\d\\d\\d&#41;&quot;           /* match 3&#58; prefix of 3 digits */<br />    &quot;&#91; -&#93;&quot;              /* separator is either space or dash */<br />    &quot;&#40;\\d\\d\\d\\d&#41;&quot;        /* match 4&#58; last 4 digits */<br />    &quot;\\D&quot;               /* must be followed by a non-digit */<br />    ;<br /><br /><br />    int<br />    main&#40;int argc, char *argv&#91;&#93;&#41; &#123;<br />        int NUM = &#40;&#40;argc == 2&#41; ? atoi&#40;argv&#91;1&#93;&#41; &#58; 1&#41;;<br />        int count;<br />        char *cptr = &quot;&quot;;<br />        char **phones;<br />        pcre *re;<br />        int erroffset;<br />        const char *errptr;<br />        int n, lines = 0;<br />        char num&#91;256&#93;;<br />        int i, j, k, matchlen;<br />        char *matchoffset;<br />        int nmatches;<br />        int *ovec, ovecsize;<br />        pcre_extra *study;<br /><br />        phones = &#40;char **&#41;malloc&#40;MAXLINES * sizeof&#40;char *&#41;&#41;;<br />        if &#40;!phones&#41; &#123;<br />        fprintf&#40;stderr, &quot;malloc for phones array failed\n&quot;&#41;;<br />        exit&#40;1&#41;;<br />        &#125;<br />        lines = 0;<br />        while &#40;cptr&#41; &#123;<br />        phones&#91;lines&#93; = &#40;char *&#41;malloc&#40;MAXLINELEN&#41;;<br />        if &#40;!phones&#91;lines&#93;&#41; &#123;<br />            fprintf&#40;stderr, &quot;malloc to hold line #%d failed\n&quot;, lines&#41;;<br />            exit&#40;1&#41;;<br />        &#125;<br />        cptr = fgets&#40;phones&#91;lines&#93;, MAXLINELEN, stdin&#41;;<br />        lines++;<br />        if &#40;lines &gt; MAXLINES&#41; &#123;<br />            fprintf&#40;stderr, &quot;MAXLINES is too small\n&quot;&#41;;<br />            exit&#40;1&#41;;<br />        &#125;<br />        &#125;<br /><br />        re = pcre_compile&#40;pattern, 0, &amp;errptr, &amp;erroffset, NULL&#41;;<br />        if &#40;!re&#41; &#123;<br />        fprintf&#40;stderr, &quot;can't open compile regexp\n&quot;&#41;;<br />        exit&#40;1&#41;;<br />        &#125;<br /><br />        study = pcre_study&#40;re, 0, &amp;errptr&#41;;<br /><br />        if &#40;pcre_fullinfo&#40;re, NULL, PCRE_INFO_CAPTURECOUNT, &amp;nmatches&#41; != 0&#41; &#123;<br />        fprintf&#40;stderr, &quot;pcre_fullinfo failed\n&quot;&#41;;<br />        exit&#40;1&#41;;<br />        &#125;<br />        nmatches++;         /* add match of entire pattern */<br /><br />        ovecsize = sizeof&#40;int&#41; * nmatches * 3;<br />        ovec = &#40;int *&#41;malloc&#40;ovecsize&#41;;<br />        if &#40;!ovec&#41; &#123;<br />        fprintf&#40;stderr, &quot;malloc for ovec array failed\n&quot;&#41;;<br />        exit&#40;1&#41;;<br />        &#125;<br /><br />        count = 0;<br />        while &#40;NUM--&#41; &#123;<br />        for &#40;i=0; i&lt;lines; i++&#41; &#123;<br />            n = pcre_exec&#40;re, study,<br />                  phones&#91;i&#93;, strlen&#40;phones&#91;i&#93;&#41;, 0,<br />                  0, ovec, ovecsize&#41;;<br />            if &#40;n == nmatches&#41; &#123;<br />            /* stuff the match into the buffer &quot;num&quot; */<br />            k = 2*2;    /* initial offset into ovec */<br />            /* areacode */<br />            j = 0;<br />            num&#91;j++&#93; = '&#40;';<br />            matchoffset = phones&#91;i&#93; + ovec&#91;k&#93;;<br />            matchlen = ovec&#91;k+1&#93; - ovec&#91;k&#93;;<br />            strncpy&#40;num+j, matchoffset, matchlen&#41;;<br />            j += matchlen; k += 2;<br />            num&#91;j++&#93; = '&#41;';<br />            /* space separator */<br />            num&#91;j++&#93; = ' ';<br />            /* exchange */<br />            matchoffset = phones&#91;i&#93; + ovec&#91;k&#93;;<br />            matchlen = ovec&#91;k+1&#93; - ovec&#91;k&#93;;<br />            strncpy&#40;num+j, matchoffset, matchlen&#41;;<br />            j += matchlen; k += 2;<br />            /* dash */<br />            num&#91;j++&#93; = '-';<br />            /* last 4 digits */<br />            matchoffset = phones&#91;i&#93; + ovec&#91;k&#93;;<br />            matchlen = ovec&#91;k+1&#93; - ovec&#91;k&#93;;<br />            strncpy&#40;num+j, matchoffset, matchlen&#41;;<br />            j += matchlen; k += 2;<br />            /* with a cherry on top */<br />            num&#91;j&#93; = 0;<br />            if &#40;0 == NUM&#41; &#123;<br />                count++;<br />                printf&#40;&quot;%d&#58; %s\n&quot;, count, num&#41;;<br />            &#125;<br />            &#125;<br />        &#125;<br />        &#125;<br /><br />        for &#40;i=0; i&lt;MAXLINES; i++&#41; &#123;<br />        free&#40;phones&#91;i&#93;&#41;;<br />        &#125;<br />        free&#40;phones&#41;;<br />        free&#40;ovec&#41;;<br /><br />        return&#40;0&#41;;<br />    &#125;<br />#endif<br /><br /><br />program regexp;<br />#include&#40; &quot;stdlib.hhf&quot; &#41;<br />const<br />    MaxLines    &#58;= 100;<br /><br />static<br />    f           &#58;dword;<br />    i           &#58;uns32;<br />    filename    &#58;string;<br />    lineCnt     &#58;uns32;<br />    areaCode    &#58;str.strvar&#40;16&#41;;<br />    prefix      &#58;str.strvar&#40;16&#41;;<br />    suffix      &#58;str.strvar&#40;16&#41;;<br />    lines       &#58;string&#91; MaxLines &#93;;<br /><br />begin regexp;<br /><br />    if&#40; arg.c&#40;&#41; != 2 &#41; then<br /><br />        stdout.put&#40; &quot;Usage&#58; regexp &lt;filename&gt;&quot; nl &#41;;<br />        exit regexp;<br /><br />    endif;<br />    mov&#40; fileio.open&#40; arg.v&#40; 1 &#41;, fileio.r &#41;, f &#41;;<br />    mov&#40; 0, ebx &#41;;<br />    while&#40; !fileio.eof&#40; f &#41;&#41; do<br /><br />        fileio.a_gets&#40; f &#41;;<br />        mov&#40; eax, lines&#91; ebx*4 &#93; &#41;;<br />        inc&#40; ebx &#41;;<br />                <br />    endwhile;<br />    mov&#40; ebx, lineCnt &#41;;<br />    fileio.close&#40; f &#41;;<br />    for&#40; mov&#40; 0, i &#41;; mov&#40; i, edx &#41; &lt; lineCnt; inc&#40; i &#41;&#41; do<br /><br />        pat.match&#40; lines&#91; edx*4 &#93; &#41;;<br /><br />            pat.zeroOrMoreCset&#40; -&#123; '&#40;','0'..'9' &#125; &#41;;<br />            pat.zeroOrOneChar&#40; '&#40;' &#41;;<br />            pat.exactlyNCset&#40; &#123;'0'..'9'&#125;, 3 &#41;;<br />            pat.extract&#40; areaCode &#41;;<br />            pat.zeroOrOneChar&#40; '&#41;' &#41;;<br />            pat.zeroOrMoreWS&#40;&#41;;<br />            pat.exactlyNCset&#40; &#123;'0'..'9'&#125;, 3 &#41;;<br />            pat.extract&#40; prefix &#41;;<br />            pat.oneOrMoreCset&#40; &#123;'-', ' '&#125; &#41;;<br />            pat.exactlyNCset&#40; &#123;'0'..'9'&#125;, 4 &#41;;<br />            pat.extract&#40; suffix &#41;;<br /><br />            stdout.put&#40; i&#58;2,&quot;&#58; &#40;&quot;, areaCode, &quot;&#41; &quot;, prefix, '-', suffix, nl &#41;;<br /><br />            pat.if_failure;<br /><br />        pat.endmatch;<br /><br />    endfor;<br /><br />end regexp;<br /><br /></code></pre></div>
    <div class="meta">Posted on 2003-10-23 23:34:20 by rhyde</div>
   </div>
   <div class="post" id="post-122286">
    <div class="subject"><a href="#post-122286">Regular Expressions</a></div>
    <div class="body">Give a look at Perl Compatible Regular Expression library by Philip Hazel at <a target="_blank" href="http://www.pcre.org/">http://www.pcre.org/</a><br /><br />The library is free, even for commercial applications !!</div>
    <div class="meta">Posted on 2003-10-24 02:03:50 by pelaillo</div>
   </div>
   <div class="post" id="post-122309">
    <div class="subject"><a href="#post-122309">Regular Expressions</a></div>
    <div class="body">Thanks guys,<br /><br />Dear Randy,<br /><br />      i came to know about it later while reading your book. So was feeling a bit stupid. But anyway, seeing the above example, HLA looks to be one of the best assembly language flavor that i've ever come across. Also, it looks a lot easier to understand, so i guess i might be learning and using it after all. gr8 work. Thanks<br /><br />Dear pelaillo,<br />  <br />    Thanks for showing me that library. gr8 work u too.<br /><br />Regards,<br />Art</div>
    <div class="meta">Posted on 2003-10-24 06:22:59 by art_sands</div>
   </div>
  </div>
 </body>
</html>