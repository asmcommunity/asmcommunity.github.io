<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Graphics programming, oldskool style - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30761" />
  <link rel="prev" href="../?id=30761&amp;page=1" />  <link rel="next" href="../?id=30761&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=30761">Graphics programming, oldskool style</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=30761&amp;page=1" style="">&laquo;</a><a href="../?id=30761&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="30761" /><input type="number" name="page" min="1" max="5" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=30761&amp;page=3">&gt;</a><a href="../?id=30761&amp;page=5">&raquo;</a></form>   <div class="post" id="post-215647">
    <div class="subject"><a href="#post-215647">Re: Graphics programming, oldskool style</a></div>
    <div class="body">I now have a pretty decent implementation of subpixel-correct polygon rendering on Amiga: http://www.youtube.com/watch?v=f4a7rxGL7b0<br />I ended up with a hybrid approach, using blitter for lines where abs(dx) &lt; abs(dy), and CPU for the other cases, seems to work quite well.<br /> I&#039;ve given up on the other cases, the fact that the blitter renders them horizontally rather than vertically seems to be quite problematic. It might be possible to fix those quirks as well, but this will have to do for now.</div>
    <div class="meta">Posted on 2012-01-05 18:59:37 by Scali</div>
   </div>
   <div class="post" id="post-215648">
    <div class="subject"><a href="#post-215648">Re: Graphics programming, oldskool style</a></div>
    <div class="body">And a more detailed explanation in part 5.1 on my blog:<br />http://scalibq.wordpress.com/2012/01/06/just-keeping-it-real-part-5-1/<br />Also threw in some other goodies for good measure, like dithered polygons on Hercules, and the ever-funky PCjr/Tandy graphics mode.</div>
    <div class="meta">Posted on 2012-01-06 08:18:46 by Scali</div>
   </div>
   <div class="post" id="post-215682">
    <div class="subject"><a href="#post-215682">Re: Graphics programming, oldskool style</a></div>
    <div class="body">CRT displays historically rendered horizontally, with the vertical position describing one horizontal row. Later, interlacing was introduced as a way of disguising horizontal artefacts visible due to electronic latency when recording a previously recorded image. This became a standard in all CRT devices, which at the end of the day still had a single pixel beam deflected by two sets of energized plates.<br />I was particularly fond of the raster effects achieved on the c64.</div>
    <div class="meta">Posted on 2012-01-17 01:08:11 by Homer</div>
   </div>
   <div class="post" id="post-215684">
    <div class="subject"><a href="#post-215684">Re: Graphics programming, oldskool style</a></div>
    <div class="body">If you like raster effects, you&#039;ll like the Angels&#039; Copper Master demo:<br />http://www.youtube.com/watch?v=NMRUj5nDewI<br />The Amiga was built for raster effects.</div>
    <div class="meta">Posted on 2012-01-17 07:44:59 by Scali</div>
   </div>
   <div class="post" id="post-215866">
    <div class="subject"><a href="#post-215866">Re: Graphics programming, oldskool style</a></div>
    <div class="body">I&#039;m trying to add sound to my Amiga code now.<br />I&#039;ve been collecting the sources of various replayer routines:<br />http://bohemiq.scali.eu.org/AmigaTrackerReplayers.zip<br />This includes SoundTracker, NoiseTracker, ProTracker and StarTrekker replayers (especially StarTrekker is quite cool, allows AM/FM synthesis and 8-channel replay).<br /><br />I&#039;ve patched up the code of one of the ProTracker routines to work with my SAS compiler/assembler package. Hopefully I can get it to play a tune soon :)</div>
    <div class="meta">Posted on 2012-03-09 15:04:29 by Scali</div>
   </div>
   <div class="post" id="post-215869">
    <div class="subject"><a href="#post-215869">Re: Graphics programming, oldskool style</a></div>
    <div class="body">Yay, tune is playing!<br />Lovely... so now I have 3D graphics AND music on Amiga.<br /><br />I&#039;d need a nice oldskool MOD player for PC as well. But I guess the only way to get one is to write it myself. Stuff like minifmod is horribly slow.</div>
    <div class="meta">Posted on 2012-03-09 17:32:14 by Scali</div>
   </div>
   <div class="post" id="post-215899">
    <div class="subject"><a href="#post-215899">Re: Graphics programming, oldskool style</a></div>
    <div class="body">While I was doing the oldskool PC stuff, the demo Crystal Dream by Triton was one of my inspirations: http://pouet.net/prod.php?which=463<br />It&#039;s one of the first demos ever to have smooth polygons on PC, and great mod-based music.<br />It uses the same EGA trickery that I developed.<br /><br />However, when I tried to run it on my 486DX2-80, I couldn&#039;t get the Sound Blaster to work. I have an original Sound Blaster Pro 2.0, and neither SB nor SB Pro worked properly. Only internal speaker worked, which sounds horrible.<br />That&#039;s odd, because I recall the music well. But I had a 386SX-16 at the time (with the same SB Pro card). So I turned off the turbo on my 486, and found that the SB gets detected properly in that case. You just can&#039;t fully enjoy the demo, because the system is too slow that way.<br /><br />So I figured there must be some kind of timing bug or such in the SB code. So I put it on my todo-list to find and fix the bug.<br />I made a start with it a while ago, but it turned out to be more difficult than just putting a bigger value in a loop counter somewhere. And I did not know anything about programming the SB anyway. I didn&#039;t have the time, so I left it for now, but kept it on the todo-list for later.<br /><br />Yesterday and today, I had some more time to look into it, and I finally managed to pinpoint the issue, and patch up the actual code.<br />It now works flawlessly on my 486DX2-80 in both SB and SB Pro mode:<br />http://bohemiq.scali.eu.org/crystfix.zip<br />It still does not work properly in Dosbox though, but I think that is related to the way it uses DMA. It also won&#039;t run properly under Windows 95, only from pure DOS. It might be because it does not reset the PIC timer rate to the default value... But I don&#039;t know if and when I&#039;ll ever look into that.</div>
    <div class="meta">Posted on 2012-03-14 13:01:04 by Scali</div>
   </div>
   <div class="post" id="post-215911">
    <div class="subject"><a href="#post-215911">Re: Graphics programming, oldskool style</a></div>
    <div class="body">I&#039;ve made a video capture of my 486 running Crystal Dream with the fixed Sound Blaster Pro routines:<br />http://www.youtube.com/watch?v=Qhym3zCa7Os</div>
    <div class="meta">Posted on 2012-03-21 08:17:13 by Scali</div>
   </div>
   <div class="post" id="post-216035">
    <div class="subject"><a href="#post-216035">Re: Graphics programming, oldskool style</a></div>
    <div class="body">I&#039;ve been having a bit more of the oldskool fun.<br />The 486 donut was a proper bit of 486-optimized code, which meant that it did not use the FPU for any time-critical code. Instead, it uses fixedpoint integer mathematics (the 486 may come with an FPU, but its performance is very poor). For the Amiga and CGA/EGA/VGA code, I have not bothered to optimize the entire pipeline yet. They still relied on some (emulated) float code for the transforming of the polygons.<br /><br />Since the donut code was 32-bit, I could easily use 32-bit integer operations throughout, and use the 64-bit results of 32-bit multiplies.<br />That gave me plenty of precision, without having to worry much about fitting everything in. The CGA/EGA/VGA fillers as well as the Amiga are aimed at lower spec platforms. The PC side is all 16-bit code, and although the Amiga&#039;s 68000 has 32-bit registers, it is not a true 32-bit CPU. It is faster at most 16-bit operations.<br />So, I&#039;ve been trying to cut down the mathematics so that they would mostly fit inside 16-bit operations. Not that easy in general, but the fact that I want to squeeze a few bits for subpixel correction in there makes it even harder.<br />However, I have a reasonable proof-of-concept now. I have traded in virtually no visible precision, the textured donut still looks the same as it did, and it still has the same range of motion between near and far z-plane. The clipping also still works. Yet I need only 16-bit precision in most cases, and some 32-bits results of 16-bit multiplies.<br /><br />Now I need to transfer the code over to the other platforms, connect it up to the polygon renderers, and optimize in 8086 and 68000 assembly. And then things are going to get interesting. On the one hand, polygon throughput should improve considerably. On the other hand, I will have more control over the objects on screen, so more advanced scenes, animation and even interaction will be possible.</div>
    <div class="meta">Posted on 2012-06-13 05:22:47 by Scali</div>
   </div>
   <div class="post" id="post-216065">
    <div class="subject"><a href="#post-216065">Re: Graphics programming, oldskool style</a></div>
    <div class="body">The donut generation routine has been ported to 16-bit now.<br />I&#039;ve also done quite a bit of cleanup and refactoring, so that 16/32-bit code now is slightly closer together. I also need to do some refactoring so the different video standards (CGA/EGA/VGA/Tandy/Hercules) share as much code as possible.<br /><br />Next step is to optimize the math in the pipeline. Then I&#039;ll need to add a polygon sorter to the pipeline, since donuts cannot be rendered correctly with backface culling alone (which is why cubes and lowpoly spheres were such popular objects in early demos).</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3350" target="_blank">8088Torus2.png</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2012-06-24 18:13:33 by Scali</div>
   </div>
   <div class="post" id="post-216079">
    <div class="subject"><a href="#post-216079">Re: Graphics programming, oldskool style</a></div>
    <div class="body">Here is an early video: http://www.youtube.com/watch?v=X8f8sNTjgmM<br />The donut is now sorted and rendered correctly from every angle.<br />Math is now entirely integer-based, using 16-bit wherever possible.<br />The trigonometry is done via a lookup table, as is the perspective division.<br />Still managed to squeeze in 4 bit subpixel correction.<br />I&#039;m quite happy with the resulting accuracy.</div>
    <div class="meta">Posted on 2012-06-28 18:08:39 by Scali</div>
   </div>
   <div class="post" id="post-216122">
    <div class="subject"><a href="#post-216122">Re: Graphics programming, oldskool style</a></div>
    <div class="body">Some small updates on the oldskool-front...<br />Firstly I also made a version of the donut without subpixel correction, to demonstrate the improvements in rendering stability: http://www.youtube.com/watch?v=dTxt7qfC7o4<br />Secondly, I have added a 16-colour VGA palette, so that I could do some simple flatshading with reasonable results: http://www.youtube.com/watch?v=bpa-wZQBppI (the videomode is still EGA&#039;s mode 0x0D, 320x200 with 4 bitplanes)<br /><br />Lastly, while I was going through my collection of old boxes, to test my Direct3D code, I also found my old Pentium Pro 200, which had a VideoLogic Apocalypse 3Dx card in it. That is a very early 3d accelerator (around 1997), with a very early PowerVR PCX2 tile-based deferred rendering chip on it (PowerVR is still around, powering iPhones, iPads, and various other smartphones, tablets and other mobile equipment).<br /><br />I figured I could do a donut on that one as well. So I grabbed some old code of mine, and made a simple Direct3D renderer out of that (DirectX 2.0, the first version to include Direct3D): http://www.youtube.com/watch?v=1BWbuUg8yvA<br /><br />I also managed to obtain an SDK for PowerSGL, the native rendering API for this chip. I might port the donut from Direct3D to PowerSGL at some point.</div>
    <div class="meta">Posted on 2012-08-01 12:01:18 by Scali</div>
   </div>
   <div class="post" id="post-216123">
    <div class="subject"><a href="#post-216123">Re: Graphics programming, oldskool style</a></div>
    <div class="body">Just though I would mention that I use PowerVR lib to develop for GLES 1 and 2 using Windows 7 as the development platform, and mobile devices as the target.. Quite handy!<br /></div>
    <div class="meta">Posted on 2012-08-02 01:46:38 by Homer</div>
   </div>
   <div class="post" id="post-216124">
    <div class="subject"><a href="#post-216124">Re: Graphics programming, oldskool style</a></div>
    <div class="body">Yes, PowerVR has become quite the force in OpenGL ES, powering all those Apple devices.<br />Speaking of development libs... Microsoft stopped supporting anything lower than Direct3D 9 long ago in their SDK.<br />Since my PowerVR PCX2 only has DDI 5 drivers, the highest version of Direct3D that will work on it is Direct3D 7. I had to rummage through my old downloads on various old machines in order to find all the right headers and libraries.<br />I took the headers and libs from the DX 8.1 SDK, which has support for all versions of Direct3D. Then I found the docs for pretty much all versions of DirectX (1, 2, 3, 5, 6.1, 7 and 8 ), so I had the proper API reference. Newer SDKs generally only documented the latest interfaces.<br />But with this homemade &#039;legacy SDK&#039; I was able to build DirectDraw and Direct3D code for all different versions of the interfaces. I could also &#039;cheat&#039; a little, and use the D3DX libraries for versions of Direct3D that did not have it yet.<br /><br />If anyone wants this stuff, I could upload it somewhere. Realistically you should never have to go lower than Direct3D 7, because Microsoft still had full backward compatibility with older drivers up to then. So even on the most basic 3D card and drivers, Direct3D 7 should still work.<br />Direct3D 8 will work on DDI 6 drivers and higher, and Direct3D 9 needs DDI 7 or higher.<br />But if you want to write non-shader code, the difference between the different versions of D3D is not very large. So using D3D7 instead of D3D9 for fixed-function stuff should be simple. The only version of D3D that&#039;s very different is the first version (included with DX2 and DX3). It uses execute buffers instead of SetState() and DrawPrimitive() APIs.<br />Which is the main reason why I chose that particular API instead of just going with D3D7. I had never used that version of D3D before, and wondered how difficult it would be. Seeing as it had quite the reputation for being difficult to use. Carmack made some comments on that early on.<br />Turns out that it wasn&#039;t all that difficult really. I was also surprised at how much functionality that first version of D3D already supports.</div>
    <div class="meta">Posted on 2012-08-02 06:03:13 by Scali</div>
   </div>
   <div class="post" id="post-216167">
    <div class="subject"><a href="#post-216167">Re: Graphics programming, oldskool style</a></div>
    <div class="body">Oh, and here is a video recording of an actual 386SX-16 machine running my donut code: http://www.youtube.com/watch?v=I3JvgSrRG7Q<br /><br />As you can see, the lowpoly one is quite smooth.<br />The highpoly one still isn&#039;t super-slow, but the framerate may just be below the &#039;smooth/realtime&#039; threshold for most people. Then again, it&#039;s quite a high polycount for such a machine. I was aiming for a 20-25 MHz 286 with that one, which may just have enough grunt to pull it off.</div>
    <div class="meta">Posted on 2012-08-13 12:45:53 by Scali</div>
   </div>
   <div class="post" id="post-216168">
    <div class="subject"><a href="#post-216168">Re: Graphics programming, oldskool style</a></div>
    <div class="body">Sometimes you remind me of Bryant and his TI calculator obsession, however since I am now dabbling in the low end of the market, I see beauty in small things. You&#039;re doing interesting stuff, I&#039;m just dancing to the tune.</div>
    <div class="meta">Posted on 2012-08-14 05:09:39 by Homer</div>
   </div>
   <div class="post" id="post-216170">
    <div class="subject"><a href="#post-216170">Re: Graphics programming, oldskool style</a></div>
    <div class="body"><div class="quote"><br />Sometimes you remind me of Bryant and his TI calculator obsession, however since I am now dabbling in the low end of the market, I see beauty in small things. You&#039;re doing interesting stuff, I&#039;m just dancing to the tune.<br /></div><br /><br />Homer,<br />To be honest, I&#039;ve not touched the Z80/TI-83+ in a few months now. I&#039;ve actually been spending a lot of my time doing Verilog/HDL and arsing with some 4-bit systems. I still randomly make time to play around on the AVR paradox sent me, but the calculator has had to take it&#039;s place in my drawer for now.<br /></div>
    <div class="meta">Posted on 2012-08-14 15:23:46 by Synfire</div>
   </div>
   <div class="post" id="post-216171">
    <div class="subject"><a href="#post-216171">Re: Graphics programming, oldskool style</a></div>
    <div class="body"><div class="quote"><br />Sometimes you remind me of Bryant and his TI calculator obsession, however since I am now dabbling in the low end of the market, I see beauty in small things. You&#039;re doing interesting stuff, I&#039;m just dancing to the tune.<br /></div><br /><br />Thanks... and yea, there&#039;s low end, and then there&#039;s low end :P<br />A modern smartphone may be considerably slower than a PC, but still you have a GPU with programmable shaders and whatnot on there.<br />The above PowerVR PCX2 card is one of the first ever 3d accelerators, and doesn&#039;t have any programmability whatsoever. It can only use a single texture, and per-vertex lighting and alphablending with a texture.<br />And it&#039;s massively slower to boot. That donut only runs at about 45 fps (although that is partly because of the slow CPU, as a lower poly version can get up to 90 fps).<br /><br />But, you still have *some* level of acceleration. And the CPU still has a built-in FPU.<br />The 386SX-16 is oodles slower still (barely faster than a decent calculator :)), does not have an FPU, and the videocard is little more than a dumb framebuffer, so the CPU has to do all the rendering as well.<br />And my code is actually written for 8086, so I don&#039;t even make use of the 32-bit capabilities either, it is purely 16-bit.<br /><br />But, there are people who go even lower than that. Like this Commodore 64 stuff:<br />http://www.youtube.com/watch?v=a663UUGSJ6s<br />Only 64KB memory, 1 MHz, 8-bit, and it doesn&#039;t even have div or mul instructions.<br />Still they get smooth 3d out of it :)<br />(It&#039;s actually a conversion of a legendary Amiga demo, a much more powerful platform).</div>
    <div class="meta">Posted on 2012-08-14 15:32:40 by Scali</div>
   </div>
   <div class="post" id="post-216179">
    <div class="subject"><a href="#post-216179">Re: Graphics programming, oldskool style</a></div>
    <div class="body">I learned 3D programming basics on the apple 2c, with my glorious monochrome screen and one sound channel, although I was actively involved with the c64 demoscene, I did no 3D stuff on there, and it never really occurred to me at the time.</div>
    <div class="meta">Posted on 2012-08-23 01:19:06 by Homer</div>
   </div>
   <div class="post" id="post-216180">
    <div class="subject"><a href="#post-216180">Re: Graphics programming, oldskool style</a></div>
    <div class="body">Yea, 3d graphics on C64 is a bit of an anachronism. Just like various other &#039;newskool&#039; effects using plasmas, textures etc.<br />These effects were mostly pioneered on Amiga, and were later backported by C64 coders, but at a time when the C64 itself was already mostly &#039;obsolete&#039; (somewhere in the early to mid 90s I believe, I think this was one of the earlier C64 demos with 3D: http://www.pouet.net/prod.php?which=1586), as in, it was already out of production, and most users had moved on to other platforms already (mostly Amiga or PC).<br />Then again, in the demoscene it still remains an incredibly popular platform, I believe it is still by far the platform with the most releases, and people continue to release for it at a steady pace.<br /><br />I think the C64 coders might just be the most hardcore coders in the scene. The stuff they manage to cram out of that modest hardware is incredible. It is truly an art, refined over many years.</div>
    <div class="meta">Posted on 2012-08-23 04:54:57 by Scali</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=30761&amp;page=1" style="">&laquo;</a><a href="../?id=30761&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="30761" /><input type="number" name="page" min="1" max="5" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=30761&amp;page=3">&gt;</a><a href="../?id=30761&amp;page=5">&raquo;</a></form>  </div>
 </body>
</html>