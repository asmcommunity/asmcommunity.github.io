<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Useless optimization time.... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=8605" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=8605">Useless optimization time....</a></p>
   <div class="post" id="post-63220">
    <div class="subject"><a href="#post-63220">Useless optimization time....</a></div>
    <div class="body">Got my d2a working(stupid pointer messup).  I've choped it down as far as I can manage.  There is two versions, one requires some of the math be donre in the invoke.<br />V1:<br /><pre><code><br />_TEXT SEGMENT<br />MakeNumber PROC PUBLIC value&#58;PTR DWORD, return&#58;PTR DWORD<br />	 <br />	mov eax,&#91;esp+4&#93;				;get dword<br />	mov ebp,eax<br /><br />	test eax,-1					;test negative<br />	jns @F							;no?<br /><br />	cdq							;remove sign<br />	add eax, edx<br />	xor eax, edx<br />@@&#58;									;go here<br />	mov edi,&#91;esp+8&#93;				;get destination<br />	mov esi,11					;esi=last byte<br />	mov &#91;edi&#93;&#91;esi&#93;,BYTE PTR 0	;0 terminate in case buffer is corrupted<br />	mov ecx,10<br />@@&#58;<br />	xor edx, edx<br />	div ecx		<br /><br />	dec esi<br />	lea ebx,&#91;edx+48&#93;			;change to ASCII<br /><br />	mov &#91;edi&#93;&#91;esi&#93;,BYTE PTR bl	;put byte in buffer<br /><br />	test eax,eax<br />	jnz @B						;exit when eax = 0<br /><br />	test ebp,-1					;was original number negative?<br />	jns @F							;no?<br /><br />	mov ebx,'-'<br />	dec esi<br />	mov &#91;edi&#93;&#91;esi&#93;,BYTE PTR bl<br />@@&#58;									;go here<br />	lea eax,&#91;edi&#93;&#91;esi&#93;				;standard return in eax of addr of 1st byte<br /><br />	ret<br />MakeNumber endp	<br />_TEXT ENDS<br /></code></pre><br />V@ needs an invoke like this:<br /><pre><code><br />	invoke MakeNumber,-12345678,ADDR buffer&#91;B&#93;+11&#91;/B&#93;<br /></code></pre><br />Since I building the string from least to most significant digit, adding +11 gives my the last address in a 12 byte buffer(12 bytes is all that is needed to display any interger number from a dword)<br />V2:<br /><pre><code><br />_TEXT SEGMENT<br />MakeNumber PROC PUBLIC value&#58;PTR DWORD, return&#58;PTR DWORD<br />	 <br />	mov eax,&#91;esp+4&#93;<br />	mov ebp,eax<br />                &#91;COLOR=red&#93;mov esi,11&#91;/COLOR=red&#93; save 1 instruction<br />	test eax,-1<br />	jns @F<br /><br />    cdq<br />    add eax, edx<br />    xor eax, edx<br />@@&#58;<br />	mov edi,&#91;esp+8&#93;<br />	mov &#91;edi&#93;,BYTE PTR 0<br />	mov ecx,10<br />@@&#58;<br />	xor edx, edx<br />	div ecx<br /><br />	dec edi<br />	lea ebx,&#91;edx+48&#93;<br /><br />	mov &#91;edi&#93;,BYTE PTR bl<br /><br />	test eax,eax<br />	jnz @B<br /><br />	test ebp,-1<br />	jns @F<br /><br />	mov ebx,'-'<br />	dec edi<br />	mov &#91;edi&#93;,BYTE PTR bl<br />@@&#58;	<br />	lea eax,&#91;edi&#93;<br /><br />	ret 8<br />MakeNumber endp	<br />_TEXT ENDS<br /></code></pre><br />I could also save another two instruction, by requiering the parameter be in registers, but none of these saving are inner loop stuff.  Now if I could only do something about that div......</div>
    <div class="meta">Posted on 2002-10-24 06:01:05 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-63274">
    <div class="subject"><a href="#post-63274">Useless optimization time....</a></div>
    <div class="body">Made and odd curiosity.  This version builds the string on the stack above the stack pointer value before the invoke.  One less paramter, and the data is temporary.<br /><pre><code><br />_TEXT SEGMENT<br />MakeNumber PROC PUBLIC value&#58;PTR DWORD 	 <br />	mov eax,&#91;esp+4&#93;<br />	mov esi,eax<br /><br />	test eax,-1<br />	jns @F<br /><br />         cdq<br />         add eax, edx<br />         xor eax, edx<br />@@&#58;<br />	lea edi,&#91;esp+23&#93;  ;this is the correct value, esp has been modified with invoke<br />	mov &#91;edi&#93;,BYTE PTR 0<br />	mov ecx,10<br />@@&#58;<br />	xor edx, edx<br />	div ecx<br /><br />	dec edi<br />	lea ebx,&#91;edx+48&#93;<br />	<br />	mov &#91;edi&#93;,BYTE PTR bl<br /><br />	test eax,eax<br />	jnz @B<br /><br />	test esi,-1<br />	jns @F<br /><br />	mov ebx,'-'<br />	dec edi<br />	mov &#91;edi&#93;,BYTE PTR bl<br />@@&#58;	<br />	lea eax,&#91;edi&#93;<br /><br />	ret 4<br />MakeNumber endp	<br />_TEXT ENDS<br /></code></pre></div>
    <div class="meta">Posted on 2002-10-24 15:01:27 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-63327">
    <div class="subject"><a href="#post-63327">Routine to convert a dword to a string</a></div>
    <div class="body">Tests for signed values<br />uses AAM to eliminate every other div<br />stores it first to the textbuffer on the stack<br />then reverses the buffer to the destination string<br />and zero terminates it.<br /><br />return value is the pointer to the *end* of the string (I find<br />this particularly useful especially if you have to append strings<br />right after or when converting several numbers ex. 04-04-2002)<br /><br />Needs some optimization. I think the copy at the end could<br />be improved or avoided...<br /><br /><pre><code><br /><br />IntToStr        PROC uses ebx ecx edx esi edi value,lpDest&#58;DWORD<br />                LOCAL textbuffer&#91;12&#93;&#58;BYTE        ;Handy buffer<br />                mov esi,lpDest                   ;esi -&gt; destination string<br />                mov eax,value                    ;eax is value<br />                test eax,eax                     ;is the value negative?<br />                jns @F                           ;no? jump<br />                mov BYTE PTR &#91;esi&#93;,'-'           ;yes? prefix our string<br />                neg eax                          ;eax = abs &#40;value&#41;<br />                inc esi                          ;move up a byte<br />@@&#58;             lea ebx,textbuffer               ;get our handy buffer<br />                xor edi,edi                      ;clear out a reg<br />                mov ecx,100                      ;prepare for divide &#40;by 100&#41;<br />@@&#58;             xor edx,edx                      ;clear edx for the div<br />                div ecx                          ;do the div<br />                xchg edx,eax                     ;swap eax and edx<br />                aam                              ;let aam replace a div by 10<br />                add ax,3030h                     ;convert to ascii<br />                mov WORD PTR &#91;ebx+edi&#93;,ax        ;save it in textbuffer<br />                add edi,2                        ;walk along the buffer<br />                xchg eax,edx                     ;restore eax<br />                test eax,eax                     ;are we done?<br />                jnz @B                           ;no? go back and do some more<br />                xchg eax,esi                     ;yes? let eax-&gt;destination string<br />@@&#58;             dec edi                          ;do we have a one character string?<br />                jz @F                            ;yes? jump forward<br />                cmp BYTE PTR &#91;edi+ebx&#93;,30h       ;no? look for first byte that isn't '0'<br />                je @B                            ;haven't found it? try again...<br />@@&#58;             mov dl,BYTE PTR &#91;edi+ebx&#93;        ;found it. Load it up<br />                mov BYTE PTR &#91;eax&#93;,dl            ;save it to the string<br />                inc eax                          ;adjust destination pointer<br />                sub edi,1                        ;adjust source pointer<br />                jns @B                           ;are we done? no? go back<br />                mov BYTE PTR &#91;eax&#93;,0             ;yes. Store the null-terminator<br />                ret<br />IntToStr        endp <br /><br /></code></pre><br /><br /><br />--Chorus</div>
    <div class="meta">Posted on 2002-10-24 20:44:53 by chorus</div>
   </div>
   <div class="post" id="post-63347">
    <div class="subject"><a href="#post-63347">Useless optimization time....</a></div>
    <div class="body"><div class="quote"><br />return value is the pointer to the *end* of the string (I find<br />this particularly useful especially if you have to append strings<br />right after or when converting several numbers ex. 04-04-2002)<br /></div> <br />Hmmm good point.<br /><br />My second version where you invoke:<br /><pre><code><br />	invoke MakeNumber,-12345678,ADDR buffer+11<br /></code></pre><br />Takes care of that because you give it the end address, and returns the start address. So you have both.<br /><pre><code><br />                LOCAL textbuffer&#91;12&#93;&#58;BYTE        ;Handy buffer<br /></code></pre><br />I just learned something.  I might be doing similar in my stack version, but in my version the data persists after function exit.  They way i figure it, if you are converting to ASCII, the next operation will probly be to pass a pointer to another function(print,file,etc)&quot;&quot;In many cases&quot;&quot;.<br />So you dont really need a declared buffer to hold the data. In other words, if it is an immediate use case, I can do this:<br /><pre><code><br />	invoke MakeNumber,80000000h <br />;eax=startaddress , esp+12=endaddress<br />	invoke MessageBox,hwnd,eax,NULL,MB_OK<br /></code></pre><br />But for more persistant stuff version number 2 is better.<br /><br />I don't really understand why you build the string left-to-right.  If you build it right-to-left(backwards), you can take advantage of the fact that div will return the remainder for each iteration, from least to most significant.</div>
    <div class="meta">Posted on 2002-10-25 00:33:14 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-63421">
    <div class="subject"><a href="#post-63421">Useless optimization time....</a></div>
    <div class="body">A slightly different version:<br /><br />-builds strings right-to-left to simplify the copy at the end<br />-eliminates the need to use ebx<br />-because it's built backwards as opposed to before, you need to ror ax,8 to get ah and al in the right order before you save it to the buffer<br /><br />Note that you can easily modify it work like your second version i.e., passing a pointer to the end of the string where the number should be. This of course means your number is right justified, which may often be the case. In my previous version, the reason I build the string backwards is because I always pass where the string should start. In most cases it's to build a sentence out of a string ex., &quot;I have 101596 kilometers on my car&quot;. Since the string of the number can be variable length it makes sense for me to do it this way.<br /><br />--Chorus<br /><br /><br /><pre><code><br />IntToStr2       PROC uses ecx edx esi edi value,lpDest&#58;DWORD<br />                LOCAL TextBuffer&#91;12&#93;&#58;DWORD<br />                mov eax,value<br />                mov edi,lpDest<br />                test eax,eax<br />                jns @F<br />                mov BYTE PTR &#91;edi&#93;,'-'<br />                inc edi<br />                neg eax<br />@@&#58;             lea esi,&#91;TextBuffer&#93;&#91;12&#93;<br />                mov ecx,100<br />@@&#58;             xor edx,edx<br />                div ecx<br />                xchg edx,eax<br />                aam<br />                sub esi,2<br />                add ax,3030h<br />                ror ax,8<br />                mov &#91;esi&#93;,ax<br />                xchg eax,edx<br />                test eax,eax<br />                jnz @B<br />                lea ecx,&#91;TextBuffer&#93;&#91;12&#93;<br />                cmp BYTE PTR &#91;esi&#93;,'0'<br />                jne @F<br />                inc esi<br />@@&#58;             sub ecx,esi<br />                rep movsb<br />                mov BYTE PTR &#91;edi&#93;,0<br />                mov eax,edi<br />                ret<br />IntToStr2       ENDP<br /></code></pre></div>
    <div class="meta">Posted on 2002-10-25 11:55:05 by chorus</div>
   </div>
   <div class="post" id="post-63423">
    <div class="subject"><a href="#post-63423">Useless optimization time....</a></div>
    <div class="body">Couple of little optimizations:<br /><br />replace<br /><pre><code><br />                test eax,eax<br />                jns @F<br />                mov BYTE PTR &#91;edi&#93;,'-'<br />                inc edi<br />                neg eax<br /></code></pre><br />with<br /><pre><code><br />                cdq<br />                mov BYTE PTR &#91;edi&#93;,'-'<br />                sub edi,edx<br />                add eax,edx<br />                xor eax,edx<br /></code></pre><br />and replace<br /><pre><code><br />                xchg eax,edx<br />                test eax,eax<br />                jnz @B<br /></code></pre><br />with<br /><pre><code><br />                xor edx,eax<br />                xor eax,edx<br />                jnz @B<br /></code></pre><br />and also<br /><pre><code><br />                lea ecx,&#91;TextBuffer&#93;&#91;12&#93;<br />                cmp BYTE PTR &#91;esi&#93;,'0'<br />                jne @F<br />                inc esi<br /></code></pre><br />with<br /><pre><code><br />                lea ecx,&#91;TextBuffer&#93;&#91;12&#93;<br />                cmp BYTE PTR &#91;esi&#93;,'1'<br />                adc esi,0<br /></code></pre><br /><br />--Chorus</div>
    <div class="meta">Posted on 2002-10-25 12:08:39 by chorus</div>
   </div>
   <div class="post" id="post-63433">
    <div class="subject"><a href="#post-63433">Useless optimization time....</a></div>
    <div class="body">Interesting.  Regarding mine:<br /><br />Version1 is pass the start of the buffer to the function.<br /><br />Version2 is pass the end of the buffer to the function.<br /><br />Version3 is buffer is built in positive stack space.<br /><br /><br /><br /><br />I realized I have a horrible bug in Version 1.   If the function is call in a proc that uses a stack frame and locals, using ebp will trash the locals.  So I either need to save ebp, or find a way to remove usage.</div>
    <div class="meta">Posted on 2002-10-25 13:09:42 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-63435">
    <div class="subject"><a href="#post-63435">Useless optimization time....</a></div>
    <div class="body">If I'm not mistaken, you only use ebp to preserve  and then only do a test at the end for sign. So why not just do the test directly on ?<br /><br />BTW also in version 1 you can remove the <strong>test eax,-1/jns @F</strong>. The <strong>cdq/add eax,edx/xor eax,edx</strong> is meant to calculate absolute value without jumping. So having the jump anyways defeats the purpose. You might as well use neg eax it's shorter and will do the same thing. But the abs without jump is usually faster.<br /><br />Also you should be able to free ebx. Instead of <strong>lea ebx,/mov ,bl</strong> just do <strong>add edx,48/mov ,dl</strong> since you're only gonna trash edx when you loop back. Then at the end use <strong>mov BYTE PTR ,'-'</strong> instead of <strong>mov ,bl</strong><br /><br />--Chorus</div>
    <div class="meta">Posted on 2002-10-25 13:25:00 by chorus</div>
   </div>
   <div class="post" id="post-63436">
    <div class="subject"><a href="#post-63436">Useless optimization time....</a></div>
    <div class="body">ebp fix:<br /><pre><code><br />_TEXT SEGMENT<br />MakeNumber PROC PUBLIC value&#58;PTR DWORD, return&#58;PTR DWORD<br />	mov eax,&#91;esp+4&#93;				<br />	mov esi,eax<br /><br />	test eax,-1					<br />	jns @F							<br />	cdq							<br />	add eax, edx<br />	xor eax, edx<br />@@&#58;									<br />	mov edi,&#91;esp+8&#93;				<br />	&#91;B&#93;lea edi,&#91;edi+11&#93;&#91;/B&#93;    ;adjust the start ot the end in the proc, use esi for original value	<br />	mov &#91;edi&#93;,BYTE PTR 0		<br />	mov ecx,10<br />@@&#58;<br />	xor edx, edx<br />	div ecx		<br />	dec edi<br />	lea ebx,&#91;edx+48&#93;			<br />	mov &#91;edi&#93;,BYTE PTR bl		<br />	test eax,eax<br />	jnz @B						<br /><br />	test esi,-1					<br />	jns @F							<br /><br />	mov ebx,'-'<br />	dec edi<br />	mov &#91;edi&#93;,BYTE PTR bl<br />@@&#58;									<br />	lea eax,&#91;edi&#93;				<br />	ret<br />MakeNumber endp	<br />_TEXT ENDS<br /></code></pre><br />Between V1 and V2, and V2.2, V2 is still the most efficient because the adjustment of the pointer to the end is done at assemble time, not run time.</div>
    <div class="meta">Posted on 2002-10-25 13:35:56 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-66108">
    <div class="subject"><a href="#post-66108">Useless optimization time....</a></div>
    <div class="body">This post was in my &quot;to check&quot; queue.. long time though. :P<br /><br />Hi <strong>Chorus</strong>, you wrote:<br /><div class="quote">stores it first to the textbuffer on the stack<br />then reverses the buffer to the destination string</div><br />The following naive code may be faster (haven't tested it though), it's quite branch-prediction friendy anyway:<br /><pre><code><br />;find number of digits in advance &#40;i.e. find integer log10&#41;<br />        MOV     EBX,10<br />        CMP     EAX,1000000000<br />        JAE     .found<br />        DEC     EBX<br />        CMP     EAX,100000000<br />        JAE     .found<br />        DEC     EBX<br />        CMP     EAX,10000000<br />        JAE     .found<br />        DEC     EBX<br />        CMP     EAX,1000000<br />        JAE     .found<br />        DEC     EBX<br />        CMP     EAX,100000<br />        JAE     .found<br />        DEC     EBX<br />        CMP     EAX,10000<br />        JAE     .found<br />        DEC     EBX<br />        CMP     EAX,1000<br />        JAE     .found<br />        DEC     EBX<br />        CMP     EAX,100<br />        JAE     .found<br />        DEC     EBX<br />        CMP     EAX,10<br />        JAE     .found<br />        DEC     EBX<br />.found&#58;<br /></code></pre><br />Then (in EBX) you will know the number of digits, and thus you can advance the string pointer accordingly, and start from there to print the digits in reverse.<br />Alternatively you may try to store the digits in regs, then BSWAP and SHLD.. but it'd probably be slower.<br /><br />I agree++ with you that returning the updated string pointer (e.g. reg EDI) is the wisest choice, because that lets you easily concatenate strings.<br />I think that you shouldn't terminate the string, though, because of the &quot;concatenation bonus&quot; issue of above.<br /><br />When making/formatting strings, I like to use EDI as dest pt and ESI as source pt, and then perform several string operations cascaded. It's quite fast this way.</div>
    <div class="meta">Posted on 2002-11-17 06:19:13 by Maverick</div>
   </div>
   <div class="post" id="post-66127">
    <div class="subject"><a href="#post-66127">Useless optimization time....</a></div>
    <div class="body">Hello Maverick,<br />  Here's what the last version I made looks like. It only uses one conditional jump, but still builds the string on the stack.<br /><br />  I took a quick look at re-writing the code with your suggestion of pre-calculating the length, but I don't think it's suitable for my algorithm. The problem is with the AAM instruction, which I use to reduce the number of divs performed (I think AAM is about 25 clocks faster than DIV). I write 2 bytes at a time (to the stack) using this method, and so to write to the destination directly, I would need to watch for an odd digit length inside the loop. This additional logic in the inner loop plus a loop to pre-calculate the number length might be costly.<br /><br />  As for terminating the string my reasoning is this: if I want to concatenate the string afterwards, the return value points to the zero byte, so the string copy that follows will overwrite it. And if you don't concatenate, then it's already terminated for you (read: I keep forgetting to terminate my strings after I call IntToStr so this was easier :)) You can, of course, eliminate that line.<br /><br />Thanks<br />--Chorus<br />  <br /><br /><br /><pre><code><br />IntToStr        PROC uses ecx edx esi edi value,lpDest&#58;DWORD<br />                LOCAL TextBuffer&#91;12&#93;&#58;DWORD<br /><br />                mov eax,value                   ;Initialization<br />                mov edi,lpDest<br />                cdq<br />                mov BYTE PTR &#91;edi&#93;,'-'<br />                sub edi,edx<br />                mov ecx,100<br />                add eax,edx<br />                lea esi,&#91;TextBuffer&#93;&#91;12&#93;<br />                xor eax,edx<br /><br />@@&#58;             xor edx,edx                     ;Inner Loop<br />                div ecx<br />                xchg edx,eax<br />                aam<br />                sub esi,2<br />                add ax,3030h<br />                ror ax,8<br />                mov &#91;esi&#93;,ax<br />                xor edx,eax<br />                xor eax,edx<br />                jnz @B<br /><br />                lea ecx,&#91;TextBuffer&#93;&#91;12&#93;        ;String Copy<br />                cmp BYTE PTR &#91;esi&#93;,'1'<br />                adc esi,0<br />                sub ecx,esi<br />                rep movsb<br />                mov BYTE PTR &#91;edi&#93;,0<br />                mov eax,edi<br />                ret<br />IntToStr        ENDP<br /></code></pre></div>
    <div class="meta">Posted on 2002-11-17 09:50:03 by chorus</div>
   </div>
   <div class="post" id="post-66154">
    <div class="subject"><a href="#post-66154">Useless optimization time....</a></div>
    <div class="body">Hi <strong>Chorus</strong>,<br />Yup, and we risk to give too many attentions to the optimization of a routine that, after all, isn't the most &quot;time critical&quot; in typical programs. ;)<br /><br />About the termination thing you've made the wisest and most comfortable choice, it's the &quot;professional deformation&quot; of optimizing code that makes me prefer to explicitly add it at the end. ;)<br />But I guess that one should never exaggerate. :tongue:</div>
    <div class="meta">Posted on 2002-11-17 15:42:35 by Maverick</div>
   </div>
  </div>
 </body>
</html>