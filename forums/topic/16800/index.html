<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Signed division by 4 and x ^ (4/3) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16800" />
    <link rel="next" href="../?id=16800&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=16800">Signed division by 4 and x ^ (4/3)</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=16800&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=16800&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="16800" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=16800&amp;page=2">&gt;</a><a href="../?id=16800&amp;page=2">&raquo;</a></form>   <div class="post" id="post-130386">
    <div class="subject"><a href="#post-130386">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body">Without using look-up table, is there an efficient way to calculate the quotient and remainder of a signed division by 4 when the dividend is between -210 and 9 ? Is there also a fast way to calculate x^(4/3) for x between 0 and 8207 ?</div>
    <div class="meta">Posted on 2004-01-11 16:56:27 by Dr. Manhattan</div>
   </div>
   <div class="post" id="post-130403">
    <div class="subject"><a href="#post-130403">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body">For your 1st question,<pre><code>xor edx,edx<br />mov eax,dividend<br />mov ecx,4<br />idiv ecx      ;-&gt;eax = quotient, edx = remainder</code></pre><br />For your 2nd question, it all depends on your interpretation of &quot;fast&quot;. If it's the least typing possible with the fewer lines of code, you could use some of the functions in the Fpu.lib provided with the MASM32 package and also available from another thread on this forum. Possible code could be as simple as:<pre><code>invoke FpuDiv,4,3,0,SRC1_DIMM or SRC2_DIMM or DEST_FPU<br />invoke FpuXexpY,ADDR x,0,0,SRC1_DMEM or SRC2_FPU or DEST_FPU<br />invoke FpuFLtoA,0,10,ADDR xbuffer,SRC1_FPU or SRC2_DIMM</code></pre>In the above code, the 1st line computes the value of the 4/3 fraction. The 2nd line takes the &quot;x&quot; value from a dword memory variable labeled &quot;x&quot; and computes the x^(4/3). The 3rd line returns the result as a null-terminated string with 10 decimal digits in a memory string variable labeled &quot;xbuffer&quot;.<br /><br />Raymond</div>
    <div class="meta">Posted on 2004-01-11 21:57:39 by Raymond</div>
   </div>
   <div class="post" id="post-130404">
    <div class="subject"><a href="#post-130404">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body">Dr. Manhattan,<br />See <a target="_blank" href="http://www.df.lth.se/~john_e/gems/gem002c.html">http://www.df.lth.se/~john_e/gems/gem002c.html</a> to learn how to find the quick quotient.  The quick remainder can be found by subtracting the quotient left shifted by 2 from the dividend.  There is always the signed division instruction IDIV, but that is slow on most machines.  There will not be a quick cube root.  You will need the assistance of the FPU or you can use a iterative series scheme like you would do by hand.  General exponentiation routines have been written.  You can do a search of this site for &quot;exponentiation&quot; to find them.  Ratch</div>
    <div class="meta">Posted on 2004-01-11 22:19:56 by Ratch</div>
   </div>
   <div class="post" id="post-130434">
    <div class="subject"><a href="#post-130434">Re: Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body"><div class="quote"><br />Is there also a fast way to calculate x^(4/3) for x between 0 and 8207 ?</div>If your just doing this for integers then find a polynomial that approximates x^(4/3) sufficent for your needs, or try newtons method with X as an inital guess.  Here are some quotes from Google Groups on cube roots:<div class="quote">Newton's method is a quadratically converging algorithm, but there are higher-order techniques like, say, Halley's method.  The iteration<pre><code><br />         2x^3 + 4r<br />   x' = ----------- x<br />         4x^3 + 2r</code></pre>is cubically converging to the cube root of  r , for example (it's generalization to nth roots is due to Lambert in 1770).  And there's no end to higher-order iterative methods such as this (cf. I. Kiss.  A generalization of Newton's approximation procedure .  _Z. angew. Math. Mech._ 34, 68--69, 1954.) but of course the price you pay is more computation per iteration.</div>..or stated another way...<div class="quote">Applying Newton's method to f(y) = y^3 - x produces a quadratically-convergent iteration:<br /><br /> y(n+1) = y(n) - (y(n) - x/y(n)^2) / 3.0<br /><br />This method takes 2 adds, 2 multiplies, and 1 divide per iteration.<br /><br />Applying it to f(y) = y^2 - x/y produces a cubically-convergent iteration:<br /><br /> y(n+1) = 0.5 * (y(n) + 1.5*x / (y(n)^2 + 0.5*x/y(n)))<br /><br />If you form 0.5*x and 1.5*x = x + (0.5*x) outside the iteration loop, this method takes 2 adds, 2 multiplies, and 2 divides per iteration.</div>Then there is <strong>chorus</strong>' thread on <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=14769">cube root</a>.</div>
    <div class="meta">Posted on 2004-01-12 08:17:17 by bitRAKE</div>
   </div>
   <div class="post" id="post-130483">
    <div class="subject"><a href="#post-130483">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body">I thought it could be done with a magic number or something like that but it's more complicated than that. Thanks for your answers.</div>
    <div class="meta">Posted on 2004-01-12 23:50:57 by Dr. Manhattan</div>
   </div>
   <div class="post" id="post-130484">
    <div class="subject"><a href="#post-130484">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body">for the first one:<br /><pre><code><br />; assume dividend is in eax<br />mov edx,eax<br />and edx,3<br />.if eax &amp; 80000000h<br />    neg edx<br />.endif<br />sar eax,2 ;edx is the remainder<br /></code></pre><br />:)</div>
    <div class="meta">Posted on 2004-01-13 00:10:45 by Ultrano</div>
   </div>
   <div class="post" id="post-130504">
    <div class="subject"><a href="#post-130504">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body">Ultrano,<br /><pre><code><br />; assume dividend is in eax<br />mov edx,eax<br />and edx,3<br />.if eax &amp; 80000000h<br />    neg edx<br />.endif<br />sar eax,2 ;edx is the remainder<br /></code></pre><br />The above code won't work.  Try it with a -7 and see.  It returns the remainder as -1 instead of the correct -3. That is because your code masks out the bottom 2 bits of a negative number, and that is incorrect.   Also, doing a SAR on a negative number rounds it toward negative infinity instead of toward zero.  That's why the quotient computes as -2 instead of -1.  Most people prefer to round toward zero. Ratch</div>
    <div class="meta">Posted on 2004-01-13 07:37:53 by Ratch</div>
   </div>
   <div class="post" id="post-130584">
    <div class="subject"><a href="#post-130584">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body">haha!<br /><br />i said it earlier, two-complement sux badly :)<br /><br />it wouldnt be such a headache and there would be no problems if everyone used sign bit + amplitude notation for  relative numbers. i m sure there are thousands of examples where code would be simpler. And almost no case where it would in fact be harder.<br /><br />one of these days i think i will draw the schematics of the simple add/sub ALU again and post it.<br />imo its not more complicated, after all, currently, to do a sub you must do a neg. doh!<br /><br />bye</div>
    <div class="meta">Posted on 2004-01-14 06:13:30 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-130588">
    <div class="subject"><a href="#post-130588">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body"><pre><code><br />.if eax &amp; 80000000h<br />  mov edx,eax<br />  dec edx<br />  and edx,3 <br />  not edx<br />.else<br />  mov edx,eax<br />  and edx,3<br />.endif<br />sar eax,2  <br /><br />1111 -1 	0<br />1110 -2		1<br />1101 -3		2<br />1100 -4 	3<br />1011 -5		4<br />1010 -6		5<br />1001 -7		6<br />1000 -8		7<br />0111 -9		8<br />0110 -10	9<br /><br />-7 % 4 = -3   1001<br />-8 % 4 = 0    1010<br />-9 % 4 = -1<br />-10% 4 = -2</code></pre><br />neg is done by <br />ADD reg, 11111111 <br />NOT reg</div>
    <div class="meta">Posted on 2004-01-14 08:17:17 by Ultrano</div>
   </div>
   <div class="post" id="post-130594">
    <div class="subject"><a href="#post-130594">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body">simplest</div>
    <div class="meta">Posted on 2004-01-14 08:50:27 by Ultrano</div>
   </div>
   <div class="post" id="post-130619">
    <div class="subject"><a href="#post-130619">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body">Ultrano,<br /><pre><code><br />.if eax &amp; 80000000h<br />  mov edx,eax<br />  dec edx<br />  and edx,3 <br />  not edx<br />.else<br />  mov edx,eax<br />  and edx,3<br />.endif<br />sar eax,2  <br /></code></pre><br />The above code still rounds toward negative infinity and gives the wrong value for remainders of negative numbers.  The following code does everything correctly with no conditional checks or jumps.  How do I know that?  I tested it.  Ratch<br /><pre><code><br />        MOV EAX,NUM<br />        PUSH EAX<br />        CDQ<br />        AND EDX,3<br />        ADD EAX,EDX<br />        SAR EAX,2       ;EAX=NUM/4=quotient <br />        POP EDX<br />        LEA ECX,&#91;4*EAX&#93;<br />        SUB EDX,ECX     ;EDX=NUM%4=remainder<br /></code></pre></div>
    <div class="meta">Posted on 2004-01-14 10:49:43 by Ratch</div>
   </div>
   <div class="post" id="post-130621">
    <div class="subject"><a href="#post-130621">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body">HeLLoWorld,<br /><br /><div class="quote"><br />i said it earlier, two-complement sux badly <br /></div><br />I find your statement...er intriguing.  Where did you make such a statement earlier?  <br /><div class="quote"><br />it wouldnt be such a headache and there would be no problems if everyone used sign bit + amplitude notation for relative numbers. i m sure there are thousands of examples where code would be simpler. And almost no case where it would in fact be harder.<br /></div><br />Take a look at this. <a target="_blank" href="http://www.trotek.ec-lyon.fr/~muller/cours/numeration/abs.html.en">http://www.trotek.ec-lyon.fr/~muller/cours/numeration/abs.html.en</a>  .  Is that what you want to deal with?  It takes extra hardware and extra conditional testing to do Signed Magnitude Arithmetic (SMA). It might be easier for you to understand SMA, but it costs extra to build and is harder to code.  If it were such a good thing, everybody would be doing it.  Now, the same twos complement addition and subtraction instructions can be used for either signed or unsigned numbers.  The results are the same in both cases, one just interprets them differently.  The automatic rollover for twos complement is very useful too.  Ratch</div>
    <div class="meta">Posted on 2004-01-14 11:19:13 by Ratch</div>
   </div>
   <div class="post" id="post-130624">
    <div class="subject"><a href="#post-130624">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body">Ratch, thanks for correcting me. :alright:</div>
    <div class="meta">Posted on 2004-01-14 11:56:02 by Ultrano</div>
   </div>
   <div class="post" id="post-130675">
    <div class="subject"><a href="#post-130675">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body">yes ratch, i had never seen info on this, but its something i ve figured out myself someday.<br />conditional testing can be done without needing sequential machines if well done, there are not so many cases and a few logical gates do it. yes there is one adder and one subber, and the subber always subs a-b where a&gt;b. so what?<br /><br /><br />and no i dont think its more complicated.<br /><br />take a look at my previous posts here, you may find them interesting or foolish.<br /><a target="_blank" href="http://www.asmcommunity.net/board/showthread.php?threadid=16363&amp;perpage=15&amp;highlight=born%20earlier&amp;pagenumber=2">http://www.asmcommunity.net/board/showthread.php?threadid=16363&amp;perpage=15&amp;highlight=born%20earlier&amp;pagenumber=2</a><br /><br />if i draw the whole circuitry i ll post it someday (but pobably it already exists somewhere)<br /><br />anyhow i just CANT believe &quot;the simplest way to do it would be to convert to 2 complement before add and back to sign-ampl then&quot;<br /><br />and then code becomes so nice ... imho</div>
    <div class="meta">Posted on 2004-01-15 06:19:38 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-130681">
    <div class="subject"><a href="#post-130681">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body">HeLLoWorld,<br /><div class="quote">...conditional testing can be done without needing sequential machines if well done</div>I don't understand what you mean by that.  A computer is by nature a sequential machine.  In order to follow the right sequence, it needs to do sequential conditional testing.  Please explain what you mean.<div class="quote">there are not so many cases and a few logical gates do it</div> Are we talking about hardware or software?  Please elucidate.<div class="quote">yes there is one adder and one subber, and the subber always subs a-b where a&gt;b. so what? and no i dont think its more complicated.</div>So for SMA you need a comparision operation to direct the flow of the operation to either the adder or subtracter.  Plus possibly deal with two possible representations of zero.  With twos complement, addition is straight forward.  Subtraction likewise.  It is simply negating a number and adding it.  The same adder can be used for both addition and subtraction.  I can't help you if you can't see that it is easier with  twos complement.<div class="quote">take a look at my previous posts here, you may find them interesting or foolish.</div>I find them irrelevant.  You are talking about code alignment there, which is different than what number representation is best, which is what we are discussing here.<div class="quote">&quot;the simplest way to do it would be to convert to 2 complement before add and back to sign-ampl then&quot;</div> Who are you quoting? Not me.<br /><br />You are going over ground that has been thoroughly plowed by many people for a long time now.  As a matter of fact, since the dawn of the computer age.  As I said before, if SMA were such a good thing, everybody would be using it. Ratch</div>
    <div class="meta">Posted on 2004-01-15 10:33:51 by Ratch</div>
   </div>
   <div class="post" id="post-130686">
    <div class="subject"><a href="#post-130686">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body">first, please dont take any offence, i m often joking when i say things shouldnt be the way they are, but i like to think about how they could be, nonetheless.<br /><br /><div class="quote"><br />I don't understand what you mean by that. A computer is by nature a sequential machine. In order to follow the right sequence, it needs to do sequential conditional testing. Please explain what you mean.<br /></div><br />i m talking of the fact that it would, or  not, NECESSARLY, take momre than one clock to do an add/sub.<br />in other words, can your circuitry give the result just by putting the input on some wires and wait for the signal to propagate through the gates, or do you need a clock to do several ops sequentially.<br />difference between cominatory logic and sequential logic...<br />of course a compu is sequential, but an adder is not, and a multiplier is.<br />hope i made it clear, if not correct me?<br /><br /><div class="quote"><br /> Are we talking about hardware or software? Please elucidate.<br /></div><br />i m talking about how numbers could be represented in ALUs, and thus, in programs.<br />i imagine an alu that is designed to deal with numbers, stored in registeres, with the sign-amplitude comvention, then performs operations on them, and the result is ialso sign-amplitude conventionned, so your program, too, when it checks things or uses algos , uses this convention, which is for my little brain at leat, FAR more intuitive.<br />its just a matter of point of view.<br /><br /><div class="quote"><br />So for SMA you need a comparision operation to direct the flow of the operation to either the adder or subtracter. Plus possibly deal with two possible representations of zero. With twos complement, addition is straight forward. Subtraction likewise. It is simply negating a number and adding it. The same adder can be used for both addition and subtraction. I can't help you if you can't see that it is easier with twos complement.<br /><div class="quote"><br />i know all of this.<br />comparison can be done simultaneously, you just wait its over.<br />2 zeros... so what???no overhead at all.<br />yes with 2 complements you add everything the same so what?you still need a neg to do a sub , so...<br />the same adder can be used... so what? a few logical gates between some billions...<br /><br />i just think of something btw: with &quot;my&quot; system (what an arrogant jerk! :) , you can do a cmp without doing a sub+test. I find this wonderful! thanx for making me realize it!<br /><br /><br /><div class="quote"><br />I find them irrelevant. You are talking about code alignment there, which is different than what number representation is best, which is what we are discussing here.<br /></div><br />sorry to tell you that, but you stopped reading after the first post you saw.<br />this thread is long and full of junk, but later on that very page i was explaining what we re talking about.<br />you still can go and read it if you want. you may find it interesting or foolish. you will better understand what i say i hope.<br /><br /><br />to be clear, i m not blind, i think there wouldnt be much, if any, to gain by using this convention, 2 compl works, but i still think its a clumsy obfuscated way of seeing things.<br /><br />(there would be no gain to make segs descriptors in the gdt have all bits of the &quot;base&quot; field stored together, but still, it would be nicer, however, thousands of processors load them successfully in the segment descriptor cache evryday many times in a second at each task switch, you see...)<br /><br /><br />dont forget errors like those rounding-towards-zero problems that showed up in ultrano s code could one day make a space shuttle explose (useless provocation, okay, but you get the idea :)<br /><br />bye ratch</div>
    <div class="meta">Posted on 2004-01-15 11:28:35 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-130687">
    <div class="subject"><a href="#post-130687">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body">i failed to quote you properly, be sure to read what i wrote plz :)</div>
    <div class="meta">Posted on 2004-01-15 11:29:59 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-130689">
    <div class="subject"><a href="#post-130689">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body">i was quoting tenkey:<br /><br /><div class="quote"><br />HeLLoWorld, if you were born early enough, you could have gotten the machine you are looking for.<br /><br />IBM had a series of computers (704, 709, ...) that used signed-magnitude for fixed-point numbers, and the circuitry was definitely more complex. Interestingly, the simplest design was to convert negative numbers to two's complement form before addition. After addition, negative results had to be converted from two's complement form. It hasn't been totally abandoned, though. Look at floating point numbers, it uses sign + positive value representation.<br /></div><br /><br />btw:<br /><div class="quote"><br />You are going over ground that has been thoroughly plowed by many people for a long time now. As a matter of fact, since the dawn of the computer age<br /></div><br />what kind of... hummmm... proof is this? :grin:</div>
    <div class="meta">Posted on 2004-01-15 11:39:55 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-130690">
    <div class="subject"><a href="#post-130690">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body"><div class="quote">what kind of... hummmm... proof is this</div> <br />in fact the best one. This sometimes makes me regret I wasn't born earlier, but still there's hope :)</div>
    <div class="meta">Posted on 2004-01-15 11:51:14 by Ultrano</div>
   </div>
   <div class="post" id="post-130704">
    <div class="subject"><a href="#post-130704">Signed division by 4 and x ^ (4/3)</a></div>
    <div class="body">HeLLoWorld,<br /><div class="quote">first, please dont take any offence, ....</div> I'm not,  I just didn't remember saying what you quoted.<div class="quote">i m talking of the fact that it would, or not, NECESSARLY, take momre than one clock to do an add/sub.<br />in other words, can your circuitry give the result just by putting the input on some wires and wait for the signal to propagate through the gates, or do you need a clock to do several ops sequentially.</div>I am not a hardware designer.  I have no circuits.  However, a lot of people much smarter than either of us have collectively spent more time than both of us will ever live on makng a fast adder.  Unless you can show me you have the talents of Seymour Cray, I consider that aspect of this discussion closed.<div class="quote">i m talking about how numbers could be represented in ALUs, and thus, in programs.<br />i imagine an alu that is designed to deal with numbers, stored in registeres, with the sign-amplitude comvention, then performs operations on them, and the result is ialso sign-amplitude conventionned, so your program, too, when it checks things or uses algos , uses this convention, which is for my little brain at leat, FAR more intuitive.<br />its just a matter of point of view.</div>I read the words, but I cannot compute what you are talking about, or its relevance.  I don't worry about how my ALU represents numbers internally or whether it's wired up the best way possible. Nothing I can do about it. I program 'em. I don't fix 'em.<div class="quote">sorry to tell you that, but you stopped reading after the first post you saw.<br />this thread is long and full of junk, but later on that very page i was explaining what we re talking about.</div>You are right.  I didn't, you did.  You said then what you are saying now.  Same arguments now apply to those pronouncements back then.<div class="quote">to be clear, i m not blind, i think there wouldnt be much, if any, to gain by using this convention, 2 compl works, but i still think its a clumsy obfuscated way of seeing things.</div>Its more of a method.  The hardware has no trouble understanding it even though humans might.  In fact it was probably invented and used because it was easy to implement in hardware.<div class="quote">(there would be no gain to make segs descriptors in the gdt have all bits of the &quot;base&quot; field stored together, but still, it would be nicer, however, thousands of processors load them successfully in the segment descriptor cache evryday many times in a second at each task switch, you see...)</div>What has that to do with this discussion?<div class="quote">dont forget errors like those rounding-towards-zero problems that showed up in ultrano s code could one day make a space shuttle explose (useless provocation, okay, but you get the idea </div>The round off was not an error.  It was probably not the right selection he intended.  The FPU gives you 4 different rounding methods of which rounding toward minus infinity is included.  You can round anyway you want in twos complement if you program it that way, so the shuttle is safe.  Ratch</div>
    <div class="meta">Posted on 2004-01-15 15:16:41 by Ratch</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=16800&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=16800&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="16800" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=16800&amp;page=2">&gt;</a><a href="../?id=16800&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>