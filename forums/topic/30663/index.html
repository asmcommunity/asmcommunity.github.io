<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Code assembles and links but bash rejects it - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30663" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=117">Unix</a> &raquo; <a href="../?id=30663">Code assembles and links but bash rejects it</a></p>
   <div class="post" id="post-214993">
    <div class="subject"><a href="#post-214993">Code assembles and links but bash rejects it</a></div>
    <div class="body">I just wrote this code, it assembles fine. I used GAS and its x86_64.<br />I linked it like this:<br /><br />ld -o ./maximum /usr/lib64/crt1.o /usr/lib64/crti.o ./maximum.o -lc<br /><br />There&#039;s no errors. But then I run it and I get this:<br /><br />bash: ./maximum: No such file or directory<br /><br />Just to make sure, I ran it and gdb and got the same error.<br /><br />Here&#039;s the code:<br /><br /><pre><code><br /># PURPOSE:&nbsp; &nbsp; &nbsp; This program finds the maximum number of a<br />#&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  set of data items.<br />#<br /><br /><br />.section .data<br /><br />hello_msg:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .asciz &quot;Hello from GAS :)\\n&quot;<br /><br />current_data_item_msg:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .asciz &quot;Current data item #%d: %d\\n&quot;<br /><br />greatest_data_item:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .asciz &quot;Greatest data item: %d\\n&quot;<br /><br />exit_msg:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .asciz &quot;See ya!!\\n&quot;<br /><br />debug_1:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .asciz &quot;Args #: %d\\n&quot;<br /><br />debug_2:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .asciz &quot;Mem for args: %d + 8 bytes\\n&quot;<br /><br />.section .text<br /><br />.globl main<br /><br />main:<br /><br />leaq (%rsp), %rdx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # need old stack frame to get args<br /><br />pushq %rbp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Create a new stack frame<br />movq %rsp, %rbp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # following C runtime rules<br />pushq %rsi<br />pushq %rdi<br />pushq %rbx<br /><br />movq (%rdx), %rcx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Move argc to counter<br /><br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rdx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # START DEBUG: Print # args<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rcx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq $debug_1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call printf<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addq $16, %rsp<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rdx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # END DEBUG<br /><br /><br /><br /><br />cmpq $2, %rcx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # if no arguments, goto no_args<br />jl no_args<br /><br />decq %rcx<br />movq %rdx, %rsi<br />addq $8, %rsi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # skip the program name, store start of args in rsi<br /><br />movq %rcx, %rax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # add enough memory to the stack frame<br />movq $8, %rbx<br />mulq %rbx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # to hold all the args<br />movq %rax, %rbx<br />addq $8, %rbx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # add extra 8 bytes for terminating data item (0)<br /><br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rdx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # START DEBUG: Print mem needed for args on stack<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rbx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rcx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subq $8, %rbx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rbx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq $debug_2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call printf<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addq $16, %rsp<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rbx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rdx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # END DEBUG<br /><br /><br /><br />movq %rsp, %rdi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Make room on stack for args<br />subq %rbx, %rsp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # put starting address of args in %rdi<br /><br />movq $0, %rax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Going to store args source index in %rax<br /><br />#<br /># Go through argv[ i ] and put every argv on the stack<br />#<br /># Or if there are no argvs, then just use random numbers<br />#<br /><br /># rcx: decrementing counter on number of args left<br /># rdi: start of stack space for storing args<br /># rsi: start of pointers to arg strings<br /># rax: current arg number<br /><br />arg_loop_start:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; cmpq $0, %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; je arg_quit<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rcx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movq %rax, %r9<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %r9<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq 0(%rsi,%rax,8)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call atoi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addq $8, %rsp<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %r9<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movq %rax, 0(%rdi,%r9,8)&nbsp; &nbsp; &nbsp; &nbsp; # put current arg in stack <br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movq %r9, %rax<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rcx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; incq %rax<br />&nbsp; &nbsp; &nbsp; &nbsp; decq %rcx<br /><br />no_args:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq %rsp, %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; subq $40, %rsp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Make room for 5 random data items<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; pushq $0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Seed random number gen<br />&nbsp; &nbsp; &nbsp; &nbsp; call time<br />&nbsp; &nbsp; &nbsp; &nbsp; addq $8, %rsp<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rax<br />&nbsp; &nbsp; &nbsp; &nbsp; call srand<br />&nbsp; &nbsp; &nbsp; &nbsp; addq $8, %rsp<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq $5, %rcx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Use 5 random data items<br />&nbsp; &nbsp; &nbsp; &nbsp; movq $0, %rax<br /><br />no_args_loop_start:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; cmpq $0, %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; je arg_quit<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq %rax, %r9<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %r9<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; call rand<br />&nbsp; &nbsp; &nbsp; &nbsp; addq $1, %rax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Make sure its not 0<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; popq %r9<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq %rax, 0(%rdi, %r9, 8)<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq %r9, %rax<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; incq %rax<br />&nbsp; &nbsp; &nbsp; &nbsp; decq %rcx<br /><br />arg_quit:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq $0, 0(%rdi, %rax, 8)&nbsp; &nbsp; &nbsp;  # Add the terminating zero<br /><br /><br />pushq $hello_msg<br />call printf<br />addq $8, %rsp<br /><br /><br />movq $0, %rcx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Put 0 in the data item index<br />movq (%rdi), %rbx&nbsp; &nbsp; &nbsp;  # Put the first number in ebx as the largest item<br /><br />start_data_loop:<br />&nbsp; &nbsp; &nbsp; &nbsp; movq 0(%rdi, %rcx, 4), %rdx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rdx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rdx<br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; pushq $current_data_item_msg<br />&nbsp; &nbsp; &nbsp; &nbsp; call printf<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; addq $24, %rsp<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; popq %rdx<br />&nbsp; &nbsp; &nbsp; &nbsp; popq %rcx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; cmpq $0, %rdx<br />&nbsp; &nbsp; &nbsp; &nbsp; je data_loop_quit<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; cmpq %rdx, %rbx<br />&nbsp; &nbsp; &nbsp; &nbsp; jle not_larger<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq %rdx, %rbx<br /><br />not_larger:<br />&nbsp; &nbsp; &nbsp; &nbsp; incq %rcx<br /><br />data_loop_quit:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rdx<br />&nbsp; &nbsp; &nbsp; &nbsp; pushq $greatest_data_item<br />&nbsp; &nbsp; &nbsp; &nbsp; call printf<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; addq $16, %rsp<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; pushq $exit_msg<br />&nbsp; &nbsp; &nbsp; &nbsp; call printf<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; sub $8, %rsp<br /><br /><br />popq %rbx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Destroy the stack frame and exit<br />popq %rdi<br />popq %rsi<br />movq %rbp, %rsp<br />popq %rbp<br /><br />ret<br /></code></pre><br /><br />Btw, I&#039;m just starting to learn assembly so I&#039;m guessing this code doesn&#039;t look to good :P<br /><br />In fact, I&#039;m pretty sure I used mulq wrong here:<br /><br /><strong>movq %rcx, %rax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # add enough memory to the stack frame<br />movq $8, %rbx<br />mulq %rbx&nbsp; </strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # to hold all the args<br />movq %rax, %rbx<br />addq $8, %rbx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # add extra 8 bytes for terminating data item (0)<br /><br />Thanks,<br />mikfig</div>
    <div class="meta">Posted on 2011-09-14 06:36:06 by mikfig</div>
   </div>
   <div class="post" id="post-214994">
    <div class="subject"><a href="#post-214994">Re: Code assembles and links but bash rejects it</a></div>
    <div class="body">Have you tried &quot;chmod +x ./maximum&quot; before running the executable?</div>
    <div class="meta">Posted on 2011-09-14 10:51:14 by LocoDelAssembly</div>
   </div>
   <div class="post" id="post-214995">
    <div class="subject"><a href="#post-214995">Re: Code assembles and links but bash rejects it</a></div>
    <div class="body">Disclaimer: I am not familiar with 64-bit code. However... I have gotten the exact same error message when linking directly with ld in 32-bit code. The &quot;secret&quot; is this: ld (32-bit) asks, by default, for &quot;/lib/ld-linux.so.1&quot;, which does not exist on my system. This is the file that&#039;s not found. The workaround is to tell ld &quot;-I /lib/ld-linux.so.2&quot;. Problem solved.<br /><br />I suspect you&#039;re encountering a similar problem. I don&#039;t know what the &quot;correct&quot; name for the interpreter/dynamic linker is for 64-bit code. (maybe the same?) I would suggest using gcc to do your linking - it knows where to find stuff!<br /><br /><pre><code><br />gcc -o maximum maximum.o<br /></code></pre><br /><br />That may add a few bytes to your executable, compared to using ld directly, but &quot;no big deal&quot;.<br /><br />I can&#039;t speak to your use of &quot;mulq&quot;, but it looks to me as if, after manipulating %rbx, you don&#039;t subtract if from %rsp, so I don&#039;t think it&#039;s doing what you want.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2011-09-14 11:08:44 by fbkotler</div>
   </div>
   <div class="post" id="post-214996">
    <div class="subject"><a href="#post-214996">Re: Code assembles and links but bash rejects it</a></div>
    <div class="body"><div class="quote"><br />Disclaimer: I am not familiar with 64-bit code. However... I have gotten the exact same error message when linking directly with ld in 32-bit code. The &quot;secret&quot; is this: ld (32-bit) asks, by default, for &quot;/lib/ld-linux.so.1&quot;, which does not exist on my system. This is the file that&#039;s not found. The workaround is to tell ld &quot;-I /lib/ld-linux.so.2&quot;. Problem solved.<br /><br />I suspect you&#039;re encountering a similar problem. I don&#039;t know what the &quot;correct&quot; name for the interpreter/dynamic linker is for 64-bit code. (maybe the same?) I would suggest using gcc to do your linking - it knows where to find stuff!<br /><br /><pre><code><br />gcc -o maximum maximum.o<br /></code></pre><br /><br />That may add a few bytes to your executable, compared to using ld directly, but &quot;no big deal&quot;.<br /><br />I can&#039;t speak to your use of &quot;mulq&quot;, but it looks to me as if, after manipulating %rbx, you don&#039;t subtract if from %rsp, so I don&#039;t think it&#039;s doing what you want.<br /><br />Best,<br />Frank<br /></div><br /><br />Ok, I linked it with gcc. Now I got a segmentation fault, but at least I can debug that. As for mulq, I did subtract %rbx from %rsp, I just didn&#039;t show it in that little code snippet.<br /><br />Thanks,<br />mikfig</div>
    <div class="meta">Posted on 2011-09-14 14:52:44 by mikfig</div>
   </div>
   <div class="post" id="post-214997">
    <div class="subject"><a href="#post-214997">Re: Code assembles and links but bash rejects it</a></div>
    <div class="body">You may want to read &quot;System V AMD64 ABI convention&quot; because you seem to be invoking functions in a c-like fashion.<br /><br />%rdi, %rsi, %rdx, %rcx, %r8, %r9, stack (+ RAX for vararg functions like printf).<br />+stack&nbsp; must be aligned on 16 bytes.</div>
    <div class="meta">Posted on 2011-09-15 04:21:57 by drizz</div>
   </div>
   <div class="post" id="post-215002">
    <div class="subject"><a href="#post-215002">Re: Code assembles and links but bash rejects it</a></div>
    <div class="body"><div class="quote"><br />You may want to read &quot;System V AMD64 ABI convention&quot; because you seem to be invoking functions in a c-like fashion.<br /><br />%rdi, %rsi, %rdx, %rcx, %r8, %r9, stack (+ RAX for vararg functions like printf).<br />+stack&nbsp; must be aligned on 16 bytes.<br /></div><br /><br />Ok thanks, will do.</div>
    <div class="meta">Posted on 2011-09-15 15:15:43 by mikfig</div>
   </div>
   <div class="post" id="post-215006">
    <div class="subject"><a href="#post-215006">Re: Code assembles and links but bash rejects it</a></div>
    <div class="body"><br />Begin here: <a target="_blank" href="http://www.x86-64.org">http://www.x86-64.org</a><br /></div>
    <div class="meta">Posted on 2011-09-15 20:30:26 by p1ranha</div>
   </div>
   <div class="post" id="post-215007">
    <div class="subject"><a href="#post-215007">Re: Code assembles and links but bash rejects it</a></div>
    <div class="body">Short piece on Linux 64-bit with sys_calls here, too...<br /><br />http://callumscode.com/blog/3<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2011-09-15 22:59:32 by fbkotler</div>
   </div>
   <div class="post" id="post-215013">
    <div class="subject"><a href="#post-215013">Re: Code assembles and links but bash rejects it</a></div>
    <div class="body"><div class="quote"><br />Short piece on Linux 64-bit with sys_calls here, too...<br /><br />http://callumscode.com/blog/3<br /><br />Best,<br />Frank<br /><br /><br /></div><div class="quote"><br /><br />Begin here: <a target="_blank" href="http://www.x86-64.org">http://www.x86-64.org</a><br /></div><br /><br />Alright thanks guys, I&#039;ve read through some of the AMD64 ABI and figured out most of my problems through that. That&#039;s also a cool article fbkotler. Thanks :). So I updated my code, got it running for the most part. It runs just fine if you pass no arguments or if you pass less than 8 arguments. If you pass 8 or more, it will run and get to the final ret instruction; but it will exit with a segmentation fault error.<br />I&#039;m not sure what the cause is, because I debugged it with gdb and the stack is cleaned up. The registers that are supposed to be reset to the value they had before the function was called isn&#039;t being completely done right for some reason. But when it runs with less than 8 arguments that is still the case, just to a lesser extent. I.e. more of the registers supposed to be saved are set to their original value when less than 8 arguments are passed, but not all of them are. Also, when I break at the last instruction, ret, and reset the values to their originals there is still a segmentation fault. So I guess I&#039;m going to have to look more into this.<br /><br />Anyways, here&#039;s the better code:<br /><br /><pre><code># PURPOSE:&nbsp; &nbsp; &nbsp; This program finds the maximum number of a<br />#&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set of data items. The data items can be given as<br />#	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; command line arguments or 5 random data items will be generated.<br /><br />.section .data<br /><br />hello_msg:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .asciz &quot;Hello from GAS\n&quot;<br /><br />current_data_item_msg:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .asciz &quot;Current data item #%lld: %lld\n&quot;<br /><br />greatest_data_item:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .asciz &quot;Greatest data item: %lld\n&quot;<br /><br />exit_msg:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .asciz &quot;See ya!!\n&quot;<br /><br />debug_2:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .asciz &quot;Mem for args: %lld + 8 bytes\n&quot;<br /><br />.section .text<br /><br />.globl main<br /><br />main:<br /><br />pushq %rbp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Create a new stack frame<br />movq&nbsp; %rsp, %rbp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # following C runtime rules<br />pushq %rsi<br />pushq %rdi<br />pushq %rbx<br />pushq %r12<br />pushq %r13<br />pushq %r14<br />pushq %r15<br /><br /><br />decl %edi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # program name not an &quot;argument&quot;<br />addq $8, %rsi<br /><br />#<br />#<br />#&nbsp; &nbsp; &nbsp;  INPUTS<br />#<br />#&nbsp; &nbsp; &nbsp;  int argc&nbsp; &nbsp; &nbsp; &nbsp; :&nbsp; &nbsp; &nbsp;  ebx<br />#&nbsp; &nbsp; &nbsp;  char** argv&nbsp; &nbsp;  :&nbsp; &nbsp; &nbsp;  rsi<br />#&nbsp; &nbsp; &nbsp;  <br />#<br /><br />cmpl $1, %edi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # if no arguments, goto no_args<br />jl no_args<br /><br /># previous operation on %edi<br /># clears higher 32 bits<br /><br />movq&nbsp; %rdi, %rbx<br />imulq $8, %rbx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # add enough memory to the stack frame<br />addq&nbsp; $8, %rbx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # to hold all the args<br />	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # add extra 8 bytes for terminating zero<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rdi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # START DEBUG: Print mem needed for args on stack<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rbx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rsi<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subq $8, %rbx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movq %rbx, %rsi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movq $debug_2, %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movq $0, %rax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call printf<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rsi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rbx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rdi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # END DEBUG<br /><br /><br />movq %rdi, %rcx<br />movq %rsp, %rdi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Make room on stack for args<br />subq %rbx, %rsp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # put starting address of args in %rdi<br /><br />movq $0, %rax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Going to store args source index in %rax<br /><br />#<br /># Go through argv[ i ] and put every atoll(*argv<em>) on the stack<br />#<br /># Or if there are no argvs, then just use random numbers<br />#<br /><br /># rcx: decrementing counter on number of args left<br /># rdi: start of stack space for storing args<br /># rsi: start of pointers to arg strings<br /># rax: current arg number<br /><br />arg_loop_start:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpq $0, %rcx<br />	 je arg_quit<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rcx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movq %rax, %r9<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %r9<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rsi<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movq (%rsi,%rax,8), %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call atoll&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 64-bit version of atoi<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pop %rsi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pop %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pop %r9<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movq %rax, (%rdi,%r9,8)&nbsp; &nbsp; &nbsp; &nbsp;  # put current arg in stack <br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movq %r9, %rax<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rcx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; incq %rax<br />&nbsp; &nbsp; &nbsp; &nbsp; decq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; jmp arg_loop_start<br /><br />no_args:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movl $0, %edi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Seed random number gen<br />&nbsp; &nbsp; &nbsp; &nbsp; call time<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movl %eax, %edi<br />&nbsp; &nbsp; &nbsp; &nbsp; call srand<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq %rsp, %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; subq $40, %rsp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Make room for 5 random data items<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq $5, %rcx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Use 5 random data items<br />&nbsp; &nbsp; &nbsp; &nbsp; movq $0, %rax<br /><br /># rcx: decrementing counter on number of args left<br /># rdi: start of stack space for storing args<br /># rax: current arg number<br /><br />no_args_loop_start:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; cmpq $0, %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; je arg_quit<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq %rax, %r9<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %r9<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; call rand<br />&nbsp; &nbsp; &nbsp; &nbsp; addl $1, %eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Make sure its not 0<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; popq %r9<br />&nbsp; &nbsp; &nbsp; &nbsp; popq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; popq %rdi<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq %rax, (%rdi, %r9, 8)&nbsp; &nbsp; &nbsp;  # rand putting num in %eax should zero out top 32 bits<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq %r9, %rax<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; incq %rax<br />&nbsp; &nbsp; &nbsp; &nbsp; decq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; jmp no_args_loop_start<br /><br />arg_quit:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq $0, (%rdi, %rax, 8)&nbsp; &nbsp; &nbsp; &nbsp; # Add the terminating zero<br /><br />pushq %rdi<br /><br />movq $hello_msg, %rdi<br />movq $0, %rax<br />call printf<br /><br />popq %rdi<br /><br />movq $0, %rcx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Put 0 in the data item index<br />movq (%rdi), %rbx&nbsp; &nbsp; &nbsp;  # Put the first number in rbx as the largest item<br /><br />start_data_loop:<br />&nbsp; &nbsp; &nbsp; &nbsp; movq (%rdi, %rcx, 8), %rdx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rbx<br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rdx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; # 3rd argument already in rdx<br />&nbsp; &nbsp; &nbsp; &nbsp; movq %rcx, %rsi<br />&nbsp; &nbsp; &nbsp; &nbsp; movq $current_data_item_msg, %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; movq $0, %rax<br />&nbsp; &nbsp; &nbsp; &nbsp; call printf<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; popq %rdx<br />&nbsp; &nbsp; &nbsp; &nbsp; popq %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; popq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; popq %rbx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; cmpq $0, %rdx<br />&nbsp; &nbsp; &nbsp; &nbsp; je data_loop_quit<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; cmpq %rdx, %rbx<br />&nbsp; &nbsp; &nbsp; &nbsp; jge not_larger<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq %rdx, %rbx<br /><br />not_larger:<br />&nbsp; &nbsp; &nbsp; &nbsp; incq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; jmp start_data_loop<br /><br />data_loop_quit:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; incq %rcx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # need to pop off terminating zero too<br />&nbsp; &nbsp; &nbsp; &nbsp; imulq $8, %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; addq %rcx, %rsp&nbsp; &nbsp; &nbsp; &nbsp;  # clean up used stack space<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq %rbx, %rsi<br />&nbsp; &nbsp; &nbsp; &nbsp; movq $greatest_data_item, %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; movq $0, %rax<br />&nbsp; &nbsp; &nbsp; &nbsp; call printf<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq $exit_msg, %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; movq $0, %rax<br />&nbsp; &nbsp; &nbsp; &nbsp; call printf<br /><br />popq %r15&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Destroy the stack frame and exit<br />popq %r14<br />popq %r13<br />popq %r12<br />popq %rbx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # AMD64 ABI, have to preserve %rbp, %rbx, %r12-%r15<br />popq %rdi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Intel386 ABI, have to preserve %rbp, %rbx, %rdi, %rsi<br />popq %rsi<br />movq %rbp, %rsp<br />popq %rbp<br /><br />ret</code></pre><br /><br />Oh, and I&#039;m thinking that maybe the fact that I neglected to align my stack on 16 bytes may be causing the segfault but I&#039;m not sure.<br />It is 8 byte aligned at the least. I guess I&#039;ll have to think about it. But at least I got it working in most cases.<br /><br />And thanks a lot for the help guys :)</div>
    <div class="meta">Posted on 2011-09-17 02:27:42 by mikfig</div>
   </div>
   <div class="post" id="post-215014">
    <div class="subject"><a href="#post-215014">Re: Code assembles and links but bash rejects it</a></div>
    <div class="body">An easy way to keep stack aligned on 16 bytes is this:<br /><br />function/label &quot;main&quot; -&nbsp; you can depend on the fact that after entry stack is aligned on 8 bytes (&quot;call&quot; instruction makes the stack unaligned), hence you need ODD number of pushes(or subtract 8*ODD) after function entry<br /><pre><code><br />main:<br />&nbsp; push rbp<br />;-- stack aligned<br /><br />or<br />main:<br />&nbsp; sub rsp,3*8<br />;-- stack aligned<br /></code></pre><br /><br />Next, always have EVEN number of pushes(or subtract 8*EVEN) in the code<br /><pre><code>push rax<br />push rdx<br />call somefunc<br />pop rdx<br />pop rax<br /><br />or<br /><br />sub rsp,4*8<br />call somefunc<br />add rsp,4*8<br /></code></pre><br /><br /><br /><br /><br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2011-09-17 06:48:28 by drizz</div>
   </div>
   <div class="post" id="post-215015">
    <div class="subject"><a href="#post-215015">Re: Code assembles and links but bash rejects it</a></div>
    <div class="body">Stack alignment in x64 is critical.&nbsp; As drizz correctly points out the stack must be aligned to 16 bytes.&nbsp; One of the easiest things to do is to <strong>push rbp</strong> upon function entry which will realign the stack due to the call.&nbsp; Follow with a <strong>mov&nbsp; rbp, rsp</strong> and you can easily use RBP as the base pointer to the argument offsets ( ie: <strong>mov rax, </strong> ).&nbsp; There are also optimizations you can make using the x64 ABI but we&#039;ll save that&nbsp; topic for another day.<br /></div>
    <div class="meta">Posted on 2011-09-17 11:03:16 by p1ranha</div>
   </div>
   <div class="post" id="post-215016">
    <div class="subject"><a href="#post-215016">Re: Code assembles and links but bash rejects it</a></div>
    <div class="body"><div class="quote"><br />Stack alignment in x64 is critical.&nbsp; As drizz correctly points out the stack must be aligned to 16 bytes.&nbsp; One of the easiest things to do is to <strong>push rbp</strong> upon function entry which will realign the stack due to the call.&nbsp; Follow with a <strong>mov&nbsp; rbp, rsp</strong> and you can easily use RBP as the base pointer to the argument offsets ( ie: <strong>mov rax, </strong> ).&nbsp; There are also optimizations you can make using the x64 ABI but we&#039;ll save that&nbsp; topic for another day.<br /><br /></div><div class="quote"><br />An easy way to keep stack aligned on 16 bytes is this:<br /><br />function/label &quot;main&quot; -&nbsp; you can depend on the fact that after entry stack is aligned on 8 bytes (&quot;call&quot; instruction makes the stack unaligned), hence you need ODD number of pushes(or subtract 8*ODD) after function entry<br /><pre><code><br />main:<br />&nbsp; push rbp<br />;-- stack aligned<br /><br />or<br />main:<br />&nbsp; sub rsp,3*8<br />;-- stack aligned<br /></code></pre><br /><br />Next, always have EVEN number of pushes(or subtract 8*EVEN) in the code<br /><pre><code>push rax<br />push rdx<br />call somefunc<br />pop rdx<br />pop rax<br /><br />or<br /><br />sub rsp,4*8<br />call somefunc<br />add rsp,4*8<br /></code></pre><br /></div><br /><br />Ok, I&#039;ll go ahead and align my stack. I&#039;m curious though, why is it that the stack needs to be 16 byte aligned? What kind of problems are caused if its not, and why?<br /><br />Thanks,<br />mikfig</div>
    <div class="meta">Posted on 2011-09-17 11:57:01 by mikfig</div>
   </div>
   <div class="post" id="post-215017">
    <div class="subject"><a href="#post-215017">Re: Code assembles and links but bash rejects it</a></div>
    <div class="body">Ok I cleaned it up, make sure push/pops are even and made sure that the stack space I allocated is divisible by 16.<br />Now it doesn&#039;t get a segmentation fault until you use 9 or more arguments. But ya, the segfault is still there.<br /><br />Fixed code:<br /><pre><code># PURPOSE:&nbsp; &nbsp; &nbsp; This program finds the maximum number of a<br />#&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  set of data items.<br />#<br /><br />.section .data<br /><br />hello_msg:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .asciz &quot;Hello from GAS\n&quot;<br /><br />current_data_item_msg:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .asciz &quot;Current data item #%lld: %lld\n&quot;<br /><br />greatest_data_item:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .asciz &quot;Greatest data item: %lld\n&quot;<br /><br />exit_msg:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .asciz &quot;See ya!!\n&quot;<br /><br />debug_2:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .asciz &quot;Mem for args: %lld bytes\n&quot;<br /><br />.section .text<br /><br />.globl main<br /><br />main:<br /><br />pushq %rbp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Create a new stack frame<br />movq&nbsp; %rsp, %rbp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # following C runtime rules<br />pushq %rsi<br />pushq %rdi<br />pushq %rbx<br />pushq %r9<br />pushq %r12<br />pushq %r13<br />pushq %r14<br />pushq %r15<br /><br /><br />addq $8, %rsi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # program name not an &quot;argument&quot;<br /><br />#<br />#<br />#&nbsp; &nbsp; &nbsp;  INPUTS<br />#<br />#&nbsp; &nbsp; &nbsp;  int argc&nbsp; &nbsp; &nbsp; &nbsp; :&nbsp; &nbsp; &nbsp;  ebx<br />#&nbsp; &nbsp; &nbsp;  char** argv&nbsp; &nbsp;  :&nbsp; &nbsp; &nbsp;  rsi<br />#&nbsp; &nbsp; &nbsp;  <br />#<br />#&nbsp; &nbsp; &nbsp;  VARIABLES<br />#<br />#&nbsp; &nbsp; &nbsp;  stack space for arguments gone through atoll():&nbsp; &nbsp; &nbsp; &nbsp;  rsi<br />#&nbsp; &nbsp; &nbsp;  <br /><br />cmpl $2, %edi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # if no arguments, goto no_args<br />jl no_args<br /><br /># previous operation on %edi<br /># clears higher 32 bits<br /><br />movq&nbsp; %rdi, %rbx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # add enough memory to the stack frame<br />imulq $8, %rbx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # to hold all the args and the terminating zero, i.e. argc<br /><br />movq %rbx, %rax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # make sure stack reservation is 16-byte aligned<br />cqto<br />movq $16, %rcx<br />idivq %rcx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # %rbx = argc * 8<br />addq %rdx, %rbx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # %rbx = %rbx + (%rbx % 16) <br /><br />decq %rdi<br /><br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rdi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # START DEBUG: Print mem needed for args on stack<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rbx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rsi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rax<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movq %rbx, %rsi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movq $debug_2, %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movq $0, %rax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call printf<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rsi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rbx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rdi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # END DEBUG<br /><br /><br />movq %rdi, %rcx<br />movq %rsp, %rdi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Make room on stack for args<br />subq %rbx, %rsp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # put starting address of args in %rdi<br /><br />movq $0, %rax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Going to store args source index in %rax<br /><br />#<br /># Go through argv[ i ] and put every argv on the stack<br />#<br /># Or if there are no argvs, then just use random numbers<br />#<br /><br /><br /># rcx: decrementing counter on number of args left<br /># rdi: start of stack space for storing args<br /># rsi: start of pointers to arg strings<br /># rax: current arg number<br /><br />arg_loop_start:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; cmpq $0, %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; je arg_quit<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movq&nbsp; %rax, %r9<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %r9<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rsi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq %rbx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pushq $0&nbsp; &nbsp;  # have to push a dummy value to keep stack 16-byte aligned<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movq (%rsi,%rax,8), %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call atoll&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # 64-bit version of atoi<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rbx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rbx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rsi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %r9<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; popq %rcx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movq %rax, (%rdi,%r9,8)&nbsp; &nbsp; &nbsp; &nbsp;  # put current arg in stack <br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; movq %r9, %rax<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; incq %rax<br />&nbsp; &nbsp; &nbsp; &nbsp; decq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; jmp arg_loop_start<br /><br />no_args:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movl $0, %edi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Seed random number gen<br />&nbsp; &nbsp; &nbsp; &nbsp; call time<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movl %eax, %edi<br />&nbsp; &nbsp; &nbsp; &nbsp; call srand<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq %rsp, %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; subq $48, %rsp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # Make room for 5 random data items + terminating 0<br />&nbsp; &nbsp; &nbsp; &nbsp; movq $48, %rbx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq $5, %rcx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Use 5 random data items<br />&nbsp; &nbsp; &nbsp; &nbsp; movq $0, %rax<br /><br />no_args_loop_start:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; cmpq $0, %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; je arg_quit<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq %rax, %r9<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %r9<br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rbx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; call rand<br />&nbsp; &nbsp; &nbsp; &nbsp; addl $1, %eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Make sure its not 0<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; popq %rbx<br />&nbsp; &nbsp; &nbsp; &nbsp; popq %r9<br />&nbsp; &nbsp; &nbsp; &nbsp; popq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; popq %rdi<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq %rax, (%rdi, %r9, 8)&nbsp; &nbsp; &nbsp;  # rand putting num in %eax should zero out top 32 bits<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq %r9, %rax<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; incq %rax<br />&nbsp; &nbsp; &nbsp; &nbsp; decq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; jmp no_args_loop_start<br /><br />arg_quit:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq $0, (%rdi, %rax, 8)&nbsp; &nbsp; &nbsp; &nbsp; # Add the terminating zero<br /><br />pushq %rdi<br />pushq %rbx<br /><br />movq $hello_msg, %rdi<br />movq $0, %rax<br />call printf<br /><br />popq %rbx<br />popq %rdi<br /><br />movq %rbx, %rsi<br />movq $0, %rcx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Put 0 in the data item index<br />movq (%rdi), %rbx&nbsp; &nbsp; &nbsp;  # Put the first number in rbx as the largest item<br /><br />start_data_loop:<br />&nbsp; &nbsp; &nbsp; &nbsp; movq (%rdi, %rcx, 8), %rdx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rbx<br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rdx<br />&nbsp; &nbsp; &nbsp; &nbsp; pushq %rsi<br />&nbsp; &nbsp; &nbsp; &nbsp; pushq $0&nbsp; &nbsp; &nbsp; &nbsp; # 16-byte alignment, pushing junk<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; # 3rd argument already in rdx<br />&nbsp; &nbsp; &nbsp; &nbsp; movq %rcx, %rsi<br />&nbsp; &nbsp; &nbsp; &nbsp; movq $current_data_item_msg, %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; movq $0, %rax<br />&nbsp; &nbsp; &nbsp; &nbsp; call printf<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; popq %rsi<br />&nbsp; &nbsp; &nbsp; &nbsp; popq %rsi<br />&nbsp; &nbsp; &nbsp; &nbsp; popq %rdx<br />&nbsp; &nbsp; &nbsp; &nbsp; popq %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; popq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; popq %rbx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; cmpq $0, %rdx<br />&nbsp; &nbsp; &nbsp; &nbsp; je data_loop_quit<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; cmpq %rdx, %rbx<br />&nbsp; &nbsp; &nbsp; &nbsp; jge not_larger<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq %rdx, %rbx<br /><br />not_larger:<br />&nbsp; &nbsp; &nbsp; &nbsp; incq %rcx<br />&nbsp; &nbsp; &nbsp; &nbsp; jmp start_data_loop<br /><br />data_loop_quit:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; addq %rsi, %rsp&nbsp; &nbsp; &nbsp; &nbsp;  # clean up used stack space<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq %rbx, %rsi<br />&nbsp; &nbsp; &nbsp; &nbsp; movq $greatest_data_item, %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; movq $0, %rax<br />&nbsp; &nbsp; &nbsp; &nbsp; call printf<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; movq $exit_msg, %rdi<br />&nbsp; &nbsp; &nbsp; &nbsp; movq $0, %rax<br />&nbsp; &nbsp; &nbsp; &nbsp; call printf<br /><br />popq %r15&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Destroy the stack frame and exit<br />popq %r14<br />popq %r13<br />popq %r12<br />popq %rbx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # AMD64 ABI, have to preserve %rbp, %rbx, %r12-%r15<br />popq %r9<br />popq %rdi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Intel386 ABI, have to preserve %rbp, %rbx, %rdi, %rsi<br />popq %rsi<br />movq %rbp, %rsp<br />popq %rbp<br /><br />ret</code></pre></div>
    <div class="meta">Posted on 2011-09-17 15:13:16 by mikfig</div>
   </div>
   <div class="post" id="post-215018">
    <div class="subject"><a href="#post-215018">Re: Code assembles and links but bash rejects it</a></div>
    <div class="body"><div class="quote"><pre><code><br />movq %rsp, %rdi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Make room on stack for args<br />subq %rbx, %rsp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # put starting address of args in %rdi<br /></code></pre><br /></div>From a quick look it seems rdi points to &quot;[...&quot; area and not to allocated stack area. Exchange those two rows.</div>
    <div class="meta">Posted on 2011-09-17 15:26:50 by drizz</div>
   </div>
   <div class="post" id="post-215019">
    <div class="subject"><a href="#post-215019">Re: Code assembles and links but bash rejects it</a></div>
    <div class="body"><div class="quote">Ok, I&#039;ll go ahead and align my stack. I&#039;m curious though, why is it that the stack needs to be 16 byte aligned? What kind of problems are caused if its not, and why?</div>It&#039;s the standard&nbsp; ;) ( Win64 ABI requires it also ). IMO it is because floating point arguments are passed in xmm registers and the most efficient store/load instruction requires 16-byte memory alignment. And since SSE2 is implied in x64 and there are other sse2 instructions that require 16byte alignment it reduces the overhead of aligning the stack manually.</div>
    <div class="meta">Posted on 2011-09-17 16:02:54 by drizz</div>
   </div>
   <div class="post" id="post-215020">
    <div class="subject"><a href="#post-215020">Re: Code assembles and links but bash rejects it</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><pre><code><br />movq %rsp, %rdi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # Make room on stack for args<br />subq %rbx, %rsp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  # put starting address of args in %rdi<br /></code></pre><br /></div>From a quick look it seems rdi points to &quot;[...&quot; area and not to allocated stack area. Exchange those two rows.<br /></div><br /><br />Haha ya, I was looking over my code again and found the same mistake :P.<br />It&#039;s because later on when I put my data on the stack I was going towards increasing memory addresses.<br />I was thinking that movq %rax, (%rdi, %r9, 8 ) was subtracting %r9*8 from %rdi for some reason, <br />wanting to go from the first &quot;allocated address&quot; to the very top of the stack instead of from the top of the stack to the bottom.<br />So, silly mistake, and that was what was causing this whole segmentation fault.<br />Overwriting the return address and shooting everything to hell.<br /><br />Anyways I fixed all my issues and now it works perfectly. I noted the stack before the first instruction in main() is executed<br />and before the least ret instruction. I did a diff on 800 bytes on the stack and I kept it squeaky clean :).<br />And all my stack allocations are 16-byte aligned :).<br />So as far as I can see I guess I obeyed the ABI, but I have to finish reading through that.<br /><br />So here&#039;s the fixed code :):<br /><br /><pre><code># PURPOSE:	This program finds the maximum number of a<br />#		set of data items.<br />#<br /><br />.section .data<br /><br />hello_msg:<br /><br />	.asciz &quot;Hello from GAS\n&quot;<br /><br />current_data_item_msg:<br /><br />	.asciz &quot;Current data item #%lld: %lld\n&quot;<br /><br />greatest_data_item:<br /><br />	.asciz &quot;Greatest data item: %lld\n&quot;<br /><br />exit_msg:<br /><br />	.asciz &quot;See ya!!\n&quot;<br /><br />debug_2:<br />	<br />	.asciz &quot;Mem for args: %lld bytes\n&quot;<br /><br />.section .text<br /><br />.globl main<br /><br />main:<br /><br />pushq %rbp				# Create a new stack frame<br />movq&nbsp; %rsp, %rbp			# following C runtime rules<br />pushq %rsi<br />pushq %rdi<br />pushq %rbx<br />pushq %r9<br />pushq %r12<br />pushq %r13<br />pushq %r14<br />pushq %r15<br /><br /><br />addq $8, %rsi				# program name not an &quot;argument&quot;<br /><br />#<br />#<br />#	INPUTS<br />#<br />#	int argc	: 	edi<br />#	char** argv 	: 	rsi<br />#	<br />#<br />#	VARIABLES<br />#<br />#	stack space for arguments gone through atoll():		rsi<br />#	<br /><br />cmpl $2, %edi				# if no arguments, goto no_args<br />jl no_args<br /><br /># previous operation on %edi<br /># clears higher 32 bits<br /><br />movq&nbsp; %rdi, %rbx			# add enough memory to the stack frame<br />imulq $8, %rbx				# to hold all the args and the terminating zero, i.e. argc<br /><br />movq %rbx, %rax				# make sure stack reservation is 16-byte aligned<br />cqto				<br />movq $16, %rcx	<br />idivq %rcx				# %rbx = argc * 8<br />addq %rdx, %rbx				# %rbx = %rbx + (%rbx % 16) <br /><br />decq %rdi<br /><br />		<br />		pushq %rdi			# START DEBUG: Print mem needed for args on stack<br />		pushq %rbx<br />		pushq %rsi<br />		pushq %rax<br />	<br />		movq %rbx, %rsi<br />		movq $debug_2, %rdi<br />		movq $0, %rax<br />		call printf<br /><br />		popq %rax<br />		popq %rsi<br />		popq %rbx<br />		popq %rdi			# END DEBUG<br /><br /><br />movq %rdi, %rcx				# Make room on stack for args	<br />subq %rbx, %rsp				# put address of first arg in %rdi<br />movq %rsp, %rdi				<br /><br />movq $0, %rax				# Going to store args source index in %rax<br /><br />#<br /># Go through argv[ i ] and put every argv on the stack<br />#<br /># Or if there are no argvs, then just use random numbers<br />#<br /><br /># rcx: decrementing counter on number of args left<br /># rdi: start of stack space for storing args<br /># rsi: start of pointers to arg strings<br /># rax: current arg number<br /><br />arg_loop_start:<br /><br />	cmpq $0, %rcx<br />	je arg_quit<br /><br />		movq&nbsp; %rax, %r9<br /><br />		pushq %rcx<br />		pushq %r9<br />		pushq %rdi<br />		pushq %rsi<br />		pushq %rbx<br />		pushq $0&nbsp; &nbsp;  # have to push a dummy value to keep stack 16-byte aligned<br />	<br />		movq (%rsi,%rax,8), %rdi<br />		call atoll			# 64-bit version of atoi<br /><br />		popq %rbx<br />		popq %rbx<br />		popq %rsi<br />		popq %rdi<br />		popq %r9<br />		popq %rcx<br /><br />		movq %rax, (%rdi,%r9,8)		# put current arg in stack <br />		<br />		movq %r9, %rax<br /><br />	incq %rax<br />	decq %rcx<br />	jmp arg_loop_start<br /><br />no_args:<br /><br />	movl $0, %edi		# Seed random number gen<br />	call time<br /><br />	movl %eax, %edi<br />	call srand<br /><br />	call rand		# Generate a random number of data items<br />	cqto			# from 1 to 50<br />	movq $50, %rcx<br />	idivq&nbsp; &nbsp;  %rcx<br />	addq $1,&nbsp; %rdx<br /><br />	movq %rdx, %r9<br /><br />	addq $1, %rdx		# Need room for terminating zero<br /><br />	imulq $8, %rdx		# Make sure the stack allocation is 16-byte aligned<br />	movq %rdx, %rbx<br />	movq %rdx, %rax<br />	cqto<br />	movq $16, %rcx<br />	idivq %rcx<br />	addq %rdx, %rbx<br /><br />	subq %rbx, %rsp		# Make room for random data items + terminating 0<br />	movq %rsp, %rdi<br /><br />	movq %r9, %rcx		# %rcx: counter, %rax: index<br />	movq $0, %rax<br /><br />no_args_loop_start:<br /><br />	cmpq $0, %rcx<br />	je arg_quit<br /><br />	movq %rax, %r9<br /><br />	pushq %rdi<br />	pushq %rcx<br />	pushq %r9<br />	pushq %rbx<br /><br />	call rand<br />	addl $1, %eax			# Make sure its not 0<br /><br />	popq %rbx<br />	popq %r9<br />	popq %rcx<br />	popq %rdi<br /><br />	movq %rax, (%rdi, %r9, 8)	# rand putting num in %eax should zero out top 32 bits<br /><br />	movq %r9, %rax<br /><br />	incq %rax<br />	decq %rcx<br />	jmp no_args_loop_start<br /><br />arg_quit:<br /><br />	movq $0, (%rdi, %rax, 8)	# Add the terminating zero<br /><br />pushq %rdi<br />pushq %rbx<br /><br />movq $hello_msg, %rdi<br />movq $0, %rax<br />call printf<br /><br />popq %rbx<br />popq %rdi<br /><br />movq %rbx, %rsi<br />movq $0, %rcx		# Put 0 in the data item index<br />movq (%rdi), %rbx 	# Put the first number in rbx as the largest item<br /><br />start_data_loop:<br />	movq (%rdi, %rcx, 8), %rdx<br /><br />	pushq %rbx<br />	pushq %rcx<br />	pushq %rdi<br />	pushq %rdx<br />	pushq %rsi<br />	pushq $0	# 16-byte alignment, pushing junk<br /><br />	# 3rd argument already in rdx<br />	movq %rcx, %rsi<br />	movq $current_data_item_msg, %rdi<br />	movq $0, %rax<br />	call printf<br /><br />	popq %rsi<br />	popq %rsi<br />	popq %rdx<br />	popq %rdi<br />	popq %rcx<br />	popq %rbx<br /><br />	cmpq $0, %rdx<br />	je data_loop_quit<br /><br />	cmpq %rdx, %rbx<br />	jge not_larger<br /><br />	movq %rdx, %rbx<br /><br />not_larger:<br />	incq %rcx<br />	jmp start_data_loop<br /><br />data_loop_quit:<br />	<br />	addq %rsi, %rsp		# clean up used stack space<br /><br />	movq %rbx, %rsi<br />	movq $greatest_data_item, %rdi<br />	movq $0, %rax<br />	call printf<br /><br />	movq $exit_msg, %rdi<br />	movq $0, %rax<br />	call printf<br /><br />popq %r15		# Destroy the stack frame and exit<br />popq %r14<br />popq %r13<br />popq %r12<br />popq %r9		# AMD64 ABI, have to preserve %rbp, %rbx, %r12-%r15<br />popq %rbx<br />popq %rdi		# Intel386 ABI, have to preserve %rbp, %rbx, %rdi, %rsi<br />popq %rsi<br />movq %rbp, %rsp<br />popq %rbp<br /><br />ret<br /></code></pre></div>
    <div class="meta">Posted on 2011-09-17 17:35:57 by mikfig</div>
   </div>
  </div>
 </body>
</html>