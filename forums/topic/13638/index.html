<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>InString algo - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=13638" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=13638">InString algo</a></p>
   <div class="post" id="post-105671">
    <div class="subject"><a href="#post-105671">InString algo</a></div>
    <div class="body">I just continue the old Hutch's thread:<br /><a target="_blank" href="http://www.asmcommunity.net/board/showthread.php?threadid=6368&amp;highlight=instring">http://www.asmcommunity.net/board/showthread.php?threadid=6368&amp;highlight=instring</a><pre><code>    <br />; InString searches &#40;case sensitive&#41; for a substring <br />; in a larger string and if it is found, it returns its <br />; address in eax.   <br />; If the substring is not found, it returns zero in eax.<br />; Usage&#58; push offset Pattern<br />;        push offset Source<br />;        call InStringL <br />; &#91;B&#93;Caution&#58;&#91;/B&#93;This code is hard to read  <br />;    <br />OPTION PROLOGUE&#58;NONE                    ; turn it off<br />OPTION EPILOGUE&#58;NONE                    ;<br />Align 16                                ; Align 16 before the proc<br />InStringL proc lpSource&#58;DWORD, lpPattern&#58;DWORD <br />          db    3Eh                     ; ds&#58; prefix<br />          mov   eax, &#91;esp+8&#93;            ; ecx-&gt;lpPattern<br />          sub   esp, 2*4                ; room to save registers and lenght of substring<br />          db    3Eh                     ; <br />          mov   edx, &#91;esp+2*4&#93;          ; edx-&gt; return address<br />          db    3Eh                     ; <br />          mov   ecx, &#91;eax&#93;              ; get dword from substring<br />          db    3Eh                     ; <br />          mov   &#91;esp+2*4&#93;, ebx          ; save register ebx<br />          movzx ebx, cl                 ; ebx-&gt;the 1st byte of substring<br />          db    3Eh                     ; <br />          mov   &#91;esp+4*4&#93;, edx          ; save return address<br />          imul  ebx, 1010101h           ; ebx=77 77 77 77h  ; 77h -&gt; ASCII code of &quot;w&quot;<br />          db    3Eh                     ;   &#40;if the 1st byte of substring is &quot;w&quot;&#41;<br />          mov   &#91;esp&#93;, esi              ;           <br />          lea   esi, &#91;eax-1&#93;            ; esi-&gt; lpPattern-1<br />          mov   &#91;esp+1*4&#93;, edi          ; save register edi<br />          mov   edx, 80808080h          ;<br />          mov   edi, &#91;esp+3*4&#93;          ; edi-&gt; lpSource<br />          mov   &#91;esp+3*4&#93;, ebp          ; save register ebp<br />          mov   ebp, 0FEFEFEFFh         ; ebp=0FEFEFEFFh<br />LoopS1&#58;                                 ; my strlen with substring<br />          add   eax, 4                  ; ecx-&gt;lpPattern<br />          add   ecx, ebp                ; ebp=0FEFEFEFFh <br />          test  edx, ecx                ; <br />          mov   ecx, &#91;eax&#93;              ; get dword from substring<br />          je    LoopS1                  ; 2 clocks per 4 bytes<br />          cmp   byte ptr &#91;eax-4&#93;, 0     ;<br />          je    S1_minus4               ;<br />          cmp   byte ptr &#91;eax-4+1&#93;, 0   ;<br />          je    S1_minus3               ;<br />          cmp   byte ptr &#91;eax-4+2&#93;, 0   ;<br />          je    S1_minus2               ;<br />          cmp   byte ptr &#91;eax-4+3&#93;, 0   ;<br />          jne   LoopS1                  ; if not zeroes loop again<br />          sub   eax, 2                  ;<br />S1&#58;                                     ;<br />          mov   ebp, &#91;edi&#93;              ;<br />          sub   eax, esi                ; end my strlen with substring<br />          mov   ecx, -4                 ;<br />          push  eax                     ; save len of substring in variable<br />BytesScan&#58;                              ;<br />          db    3Eh                     ; ds&#58; prefix<br />          lea   edx, &#91;ebp-1010101h&#93;     ; searching the 1st byte of substring or/and zero<br />          xor   ebp, ebx                ; ebx=77 77 77 77h  ; 77h -&gt; ASCII code of &quot;w&quot;<br />          db    3Eh                     ;   &#40;if the 1st byte of substring is &quot;w&quot;&#41;<br />          add   edi, 4                  ;               <br />          sub   ebp, 1010101h           ;<br />          or    edx, ebp                ; testing the 1st byte of substring and 0<br />          db    3Eh                     ;   simultaneously in the larger string<br />          mov   ebp, &#91;edi&#93;              ;  <br />          and   edx, 80808080h          ; <br />          je    BytesScan               ; 4 clocks per 4 bytes<br />SrchNextByte&#58;                           ; <br />          cmp   &#91;edi+ecx&#93;, bl           ; bl = 77h -&gt; ASCII code of &quot;w<br />          je    StartCmp                ;   &#40;if the 1st byte of substring is &quot;w&quot;&#41;<br />          cmp   byte ptr &#91;edi+ecx&#93;, 0   ; is it the end of the larger string?<br />          je    ExitP                   ; exit<br />ToNext&#58;                                 ;<br />          inc   ecx                     ; ecx-&gt; -4 to 0<br />          jne   SrchNextByte            ;<br />          mov   ebp, &#91;edi&#93;              ; restoring ebp for ByteScan<br />          sub   ecx, 4                  ; ecx = -4<br />          jc    BytesScan               ; loop again<br />align 16                                ;<br />S1_minus4&#58;                              ;<br />          db    3Eh                     ; ds&#58; prefix<br />          sub   eax, 5                  ;<br />          jno   S1                      ;<br />S1_minus3&#58;                              ;<br />          sub   eax, 4                  ;<br />          jno   S1                      ;<br />S1_minus2&#58;                              ;<br />          sub   eax, 3                  ;<br />          jno   S1                      ;<br />StartCmp&#58;                               ; comparing next bytes from substring<br />          mov   edx,  &#91;esp&#93;             ; edx-&gt; len of substring<br />          lea   ebp, &#91;edi+ecx&#93;          ; ebp=edi+ecx -&gt; as a base register <br />          movzx eax, byte ptr &#91;esi+edx&#93; ; comparing rest bytes<br />          dec   edx                     ; <br />          je    ExitP                   ; exit <br />CmpNext&#58;                                ;<br />          cmp   &#91;ebp+edx&#93;, al           ; ebp-&gt;lp to current 1st byte in the larger string<br />          jne   ToNext                  ; <br />          movzx eax, byte ptr &#91;esi+edx&#93; ; get next byte<br />          dec   edx                     ; <br />          jne   CmpNext                 ; 2 clocks per byte<br />ExitP&#58;                                  ;<br />          mov   esi, &#91;esp+1*4&#93;          ; restoring register esi<br />          cmp   edx, 1                  ; if edx= 0 mask = 0FFFFFFFFh else mask=0<br />          sbb   eax, eax                ; eax-&gt;mask 0 or 0FFFFFFFFh<br />          mov   edi, &#91;esp+2*4&#93;          ; restoring register edi<br />          and   eax, ebp                ; eax-&gt;lp 1st occurrence in large string or zero<br />          mov   ebx, &#91;esp+3*4&#93;          ; restoring register ebx<br />          mov   ebp, &#91;esp+4*4&#93;          ; restoring register ebp<br />          add   esp, 5*4                ; restoring register esp<br />          ret                           ; faster return then ret  2*4<br />InStringL endp                          ;<br />OPTION PROLOGUE&#58;PROLOGUEDEF             ; turn back on the defaults<br />OPTION EPILOGUE&#58;EPILOGUEDEF             ;<br />&#91;B&#93;Note&#58;&#91;/B&#93;<br />  Seven instructions after imul &#40;4 clocks&#41; are executed &quot;for free&quot; because they are<br />  in the 4 clocks delay of imul ebx, 1010101h and don't depend on imul instruction.</code></pre><br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-06-01 17:37:37 by lingo12</div>
   </div>
   <div class="post" id="post-105713">
    <div class="subject"><a href="#post-105713">Re: InString algo</a></div>
    <div class="body"><div class="quote"><br />InStringL proc lpSource:DWORD, lpPattern:DWORD <br />          db    3Eh                     ; ds: prefix<br />          mov   eax,             ; ecx-&gt;lpPattern<br />          sub   esp, 2*4                ; room to save registers and lenght of substring<br />          db    3Eh                     ; <br />          mov   edx,           ; edx-&gt; return address<br />          db    3Eh                     ; <br />          mov   ecx,               ; get dword from substring<br />          db    3Eh                     ; <br />          mov   , ebx          ; save register ebx<br />          movzx ebx, cl                 ; ebx-&gt;the 1st byte of substring<br />          db    3Eh                     ; <br />          mov   , edx          ; save return address<br />          imul  ebx, 1010101h           ; ebx=77 77 77 77h  ; 77h -&gt; ASCII code of &quot;w&quot;<br />          db    3Eh                     ;   (if the 1st byte of substring is &quot;w&quot;)<br />          mov   , esi              ;</div><br />My God.. the code looks totally bloated and overkill just to find the position of a substring into e.g. a 10 characters long string. And why do you slow down everything with all those totally unnecessary 3E prefixes? Somebody oughta tell you that Win32 uses a flat memory system.. where DS already = ES that already = SS. No need for those silly prefixes.</div>
    <div class="meta">Posted on 2003-06-02 02:42:26 by Kyle Katarn</div>
   </div>
   <div class="post" id="post-105714">
    <div class="subject"><a href="#post-105714">InString algo</a></div>
    <div class="body">He is aligning to code so that the loop is in the code cache if I am not wrong.<br /><br />Coded for speed, not size I suppose.</div>
    <div class="meta">Posted on 2003-06-02 03:04:39 by roticv</div>
   </div>
   <div class="post" id="post-105726">
    <div class="subject"><a href="#post-105726">InString algo</a></div>
    <div class="body">Kyle,<br />&quot;.. just to find the position of a substring into e.g. a <strong>10 characters</strong> long string.&quot;<br />Emotional and wrong! The length of long string isn't limited<br /><br />&quot;And why do you <strong>slow down</strong> everything..&quot;<br />It is the fastest InString I ever seen<br />If you know faster pls don't hesitate to open my eyes <br /><br />&quot;No need for those silly prefixes&quot;<br /><a target="_blank" href="http://www.asmcommunity.net/board/showthread.php?threadid=13541">http://www.asmcommunity.net/board/showthread.php?threadid=13541</a><br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-06-02 05:26:33 by lingo12</div>
   </div>
   <div class="post" id="post-106626">
    <div class="subject"><a href="#post-106626">InString algo</a></div>
    <div class="body">Here is the shortest InString:<pre><code><br />OPTION PROLOGUE&#58;NONE         ; turn it off<br />OPTION EPILOGUE&#58;NONE         ;<br />InStringS proc lpSource&#58;DWORD, lpPattern&#58;DWORD <br />          pop  eax           ; ret address<br />          pop  ecx           ; ecx-&gt; lpSource<br />          pop  edx           ; edx-&gt; lpPattern<br />          push eax           ; ret address<br />          push edi           ; save edi<br />          push esi           ; save esi<br />          push edx           ; edx-&gt; lpPattern<br />          mov  edi, ecx      ; edi-&gt; lpSource<br />          mov  esi, edx      ; esi-&gt; lpPattern<br />          call StrLen <br />          push eax           ; save eax-&gt; len of lpPattern<br />          push eax           ; save eax-&gt; len of lpPattern <br />          push edi           ; edi-&gt; lpSource<br />          call StrLen<br />          pop  edx           ; edx-&gt; len of lpPattern<br />          inc  eax           ; eax-&gt; len of lpSource+1<br />          mov  ch, &#91;esi&#93;     ; ch = 1st byte of substring<br />          dec  esi           ; esi-&gt; lpPattern -1<br />          sub  eax, edx      ;<br />          add  edi, eax      ; edi-&gt; end of lpSource +1<br />          neg  eax           ;<br />SrchNextByteS&#58;   <br />          cmp  &#91;edi+eax&#93;, ch ; ch = 1st byte of substring<br />          jne  NextS<br />          pop  edx           ; edx-&gt; len of substring<br />          add  eax, edi      ; eax-&gt; base register<br />          push edx           ; edx-&gt; len of substring<br />CmpNextS&#58;   <br />          mov  cl, &#91;esi+edx&#93; ; comparing rest bytes<br />          dec  edx           ; edx-&gt; len of substring<br />          je   ExitS         ; exit        <br />          cmp  &#91;eax+edx&#93;, cl ; eax-&gt; current offset in lpSource<br />          je   CmpNextS      ;   at 1st byte of substring    	<br />          sub  eax, edi      ; eax-&gt; negative index register  <br />NextS&#58;<br />          inc  eax <br />          jl   SrchNextByteS <br />ExitS&#58;<br />          pop  ecx           ; ecx-&gt; len of substring<br />          pop  esi<br />          pop  edi<br />          ret                ; 64 bytes<br />InStringS ENDP<br />OPTION PROLOGUE&#58;PROLOGUEDEF  ; turn back on the defaults<br />OPTION EPILOGUE&#58;EPILOGUEDEF  ;</code></pre><br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-06-10 06:29:58 by lingo12</div>
   </div>
   <div class="post" id="post-106683">
    <div class="subject"><a href="#post-106683">InString algo</a></div>
    <div class="body">I'm just curious.<br />Why do you keep using DS prefix for ESP?  ESP is relative to SS.  If, by any chance, DS != SS, (for whatever the reason is) then your function will work on something different from what are passed.<br />And, it would be nice to see some speed test result other than just claiming &quot;It is the fastest InString I ever seen&quot;.</div>
    <div class="meta">Posted on 2003-06-10 16:09:50 by Starless</div>
   </div>
   <div class="post" id="post-106739">
    <div class="subject"><a href="#post-106739">InString algo</a></div>
    <div class="body">Starless,<br /><strong>&quot;Why do you keep using DS prefix for ESP?&quot;</strong><br /><br />Because the labels <strong>LoopS1, BytesScan, SrchNextByte and StartCmp</strong><br />should be aligned to addresses divisible by 16 <br /><br />&quot;Instructions with a memory operand can be made one byte longer with a SIB byte, <strong>but the easiest way of making an instruction one byte longer is to add a DS: segment prefix (DB 3Eh).</strong> The microprocessors generally accept redundant and <strong>meaningless</strong> prefixes (except LOCK) as long as the instruction length does not exceed 15 bytes. Even instructions without a memory operand can have a segment prefix. So if you want the DEC ECX instruction to be 2 bytes long, write:<br /><strong>DB 3Eh</strong><br />DEC ECX&quot; by A.Fog<br /><br /><br /><br /><strong>&quot;ESP is relative to SS. If, by any chance, DS != SS, (for whatever the reason is) then your function will work on something different from what are passed.&quot;</strong><br /><br />&quot;Somebody oughta tell you that Win32 uses a flat memory system.. where DS already = ES that already = SS.&quot; by Kyle Katarn<br /><br />&quot;...but I would consider it safe to use a segment prefix with any instruction.  &quot; by A.Fog<br /><br /><br /><br /><strong>&quot;And, it would be nice to see some speed test result...&quot;</strong><br />Just do it...<br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-06-11 04:57:23 by lingo12</div>
   </div>
   <div class="post" id="post-106780">
    <div class="subject"><a href="#post-106780">InString algo</a></div>
    <div class="body">cs = ds = ss, its a safe assumption for <em>most</em> versions of windows, but there are versions of windows which may not (datacenter 2K for example). In order to get past the 4GB limit on database machines Intel provides PAE to get around the 32bit address limit (effectivly providing a 36 bit address, as some of the bits of the segment selectors are used for other things).<br /><br />It'll work as is for us ordinary folk with ordinary versions of windows though...<br /><br />Mirno</div>
    <div class="meta">Posted on 2003-06-11 13:00:13 by Mirno</div>
   </div>
   <div class="post" id="post-120860">
    <div class="subject"><a href="#post-120860">InString algo</a></div>
    <div class="body">BTW alignment here can be done without prefixes or<br />additinal instruction.<br />Just using different coding in modrm and sib and zero displacements</div>
    <div class="meta">Posted on 2003-10-09 07:44:44 by The Svin</div>
   </div>
   <div class="post" id="post-120861">
    <div class="subject"><a href="#post-120861">InString algo</a></div>
    <div class="body"><div class="quote">cs = ds = ss</div> <br />I guess you meant base of the segments, not values (selectors). Values (selectors) of cs and ds/ss is different in<br />CPL 3, and all of them are different in CPL 0.</div>
    <div class="meta">Posted on 2003-10-09 07:47:15 by The Svin</div>
   </div>
   <div class="post" id="post-120884">
    <div class="subject"><a href="#post-120884">InString algo</a></div>
    <div class="body">I'll try to explain my point in <br />opcode demonstration.<br />For example in lingo proc there is mnemonic:<br /> mov   ecx,   <br />Actually the mnemonic can be encoded <br />different ways and wich is more important<br />in this topic context - with different resulting<br />size, without using prefixes of segement<br />redefinishing (wich can force to<br />reload shadow registers and thus loosing clocks)<br /><br />Compilers usually use optimum (in size hence)<br />of optional encoding.<br />in case mov ecx, it's 2 bytes:<br />8B 08<br />08 - is modr/m byte 00 001 000<br />00 - mod (memr = address pointer without displacement)<br />001 - ecx<br />000 - <br /><br />We can encode it one byte longer (3 bytes total) two ways:<br />1. Using SIB without index:<br />8Bh:00 001 100(sing of SIB):00 100 (no index) 000()<br />In hex it:<br />8B 0C 20<br />And it's also mov ecx,<br />2. Other way without SIB but with 1 byte displacement:<br />8Bh:01 (displacement 1 byte) 001 000y:00h<br />in HEX:<br />8B 48 00<br /><br /><br />We can encode it 2 bytes longer (4 bytes total) using SIB + displacement 1 byte:<br /><br />8B:01 001 100:00 100 000:00h<br />in hex<br />8B 4C 20 00<br /><br />We can encode it 4 bytes longer without SIB, and with displacement 4 bytes:<br /><br />8B:10 (displacement full size) 001 000:00000000h<br />in hex<br />8B 88 00 00 00 00<br /><br />And finally we can encode it 5 bytes longer with SIB and displacement 4 bytes:<br /><br />8B:10 001 100: 00 100 000: 00000000h<br /><br />in hex<br />8B 8C 20 00 00 00 00<br /><br />The same approach can be taken (different size of displacemt part and<br />redandent usage of SIB) with many other opcodes here.<br />For example lea esi, can be coded 3 bytes longer if mod set to 10 and<br />additinal 3 FFh placed in displacement part, and so on.</div>
    <div class="meta">Posted on 2003-10-09 13:29:48 by The Svin</div>
   </div>
   <div class="post" id="post-120900">
    <div class="subject"><a href="#post-120900">InString algo</a></div>
    <div class="body"><div class="quote"><br />Just using different coding in modrm and sib and zero displacements </div>True, but I think the choice of segment overrides is to stress a different part of the CPU than is done by other methods.  Additionally, it is what the optimization manual suggests.  Mainly for P3+/K7+.</div>
    <div class="meta">Posted on 2003-10-09 19:56:08 by bitRAKE</div>
   </div>
   <div class="post" id="post-120916">
    <div class="subject"><a href="#post-120916">InString algo</a></div>
    <div class="body"><strong>Lingo12</strong>,<br /><br /><div class="quote"><br />db    3Eh                     ; ds: prefix<br />mov   eax,             ; ecx-&gt;lpPattern<br /></div><br /><br />When you need the DS: only for stretch the instruction, use rather<br /><br /><div class="quote"><br />          mov   eax, ds:            ; ecx-&gt;lpPattern<br /></div><br /><br />, or better<br /><br /><div class="quote"><br />          mov   eax, ss:            ; ecx-&gt;lpPattern<br /></div><br /><br />. It's much better readable :)</div>
    <div class="meta">Posted on 2003-10-09 21:38:37 by MazeGen</div>
   </div>
   <div class="post" id="post-120920">
    <div class="subject"><a href="#post-120920">InString algo</a></div>
    <div class="body"><div class="quote"><br />True, but I think the choice of segment overrides is to stress a different part of the CPU than is done by other methods.  Additionally, it is what the optimization manual suggests.  Mainly for P3+/K7+. </div><br /><br />To make clear my point I would devide<br />Intel docs into two logical parts:<br />1. Description of architecture, inner parts and<br />algos placed in internal units.<br />2. Solutions and suggestions.<br /><br />The First part in subject of most close studing.<br />The Second is nothing but ones of possible and not always<br />optimal solutions. People of Intel has the only advantage<br />in solution searching against your own brain - they<br />know data of inners better, since you carefully read their<br />description of the data - you can find better solution<br />then Intel people can offer.<br /><br />I can remind you as an example the other thread when<br />I myself initially knew data a litlle bit better than<br />others yet my solutions weren't the best ones.<br /><br />In other thread we discussed Reg code to string optimal<br />size solution. Practically all encoding part descriptions<br />in details came from me, yet solutions of other including<br />you were better.<br />Especially in the case our freind Poimander was interesting to observe<br />in his development, - 'cause for the first several posts<br />he couldn't get quite well what was the problem about :)<br />And despite of the fact of being not &quot;au fait&quot; initially -<br />he finally offered lots of interesting ideas and one of<br />two versions of shortest code.<br />And me with all my deeper understanding - just appeared to<br />find myself as deep outsider :) Some of my ideas were accepted,<br />others - replaced with better ones.<br /><br />The same about Intel docs - description part is most valubale,<br />as to solution - .. well, it's just one of possible.<br />And not nesserilly the best.<br />At least about the Intel Software IMHO - it's one of the slowest :)<br />So IMHO, it's worthy to take Intel notes about cach lines and alignments,<br />but treat their solution as one of many possible.<br /><br />I guess they offered just easier to encode for HLL programmer way,<br />since for most people manual binary encoding is just too much.<br />And no tool available to offer different size encoding.<br />I guess, I could write one if needed.<br />Kindda - input mnemonic - output several optional ways to encode it<br />with different size. Might be more - encode with automatic <br />choosing sizes to align to given value.</div>
    <div class="meta">Posted on 2003-10-09 22:20:07 by The Svin</div>
   </div>
   <div class="post" id="post-120922">
    <div class="subject"><a href="#post-120922">InString algo</a></div>
    <div class="body"><div class="quote"><br />. It's much better readable  <br /></div><br />Might be it's better readable, but lingo gave sources<br />to be compiled, not just psuedo-asm-algo, AFAIK he USES<br />MASM, and MASM would leave out (ommit) those prefixes<br />optimizing for size. As the result label wouldn't be aligned<br />thus lingo placed prefixes explicitly as data byte to force<br />MASM include them.</div>
    <div class="meta">Posted on 2003-10-09 22:37:27 by The Svin</div>
   </div>
   <div class="post" id="post-120927">
    <div class="subject"><a href="#post-120927">InString algo</a></div>
    <div class="body"><div class="quote"><em>Originally posted by The Svin</em><br />The Second is nothing but ones of possible and not always<br />optimal solutions. People of Intel has the only advantage<br />in solution searching against your own brain - they<br />know data of inners better, since you carefully read their<br />description of the data - you can find better solution<br />then Intel people can offer.</div>IMHO, it is in Intel's best interest to produce clear documents about the function of their processors, but the problem lies in the level of detail in those documents.  To protect their intests we only get a rehashed interpretation of the fine detail within the chip.<br /><br /><div class="quote">Especially in the case our freind Poimander was interesting to observe<br />in his development, - 'cause for the first several posts<br />he couldn't get quite well what was the problem about :)</div>This was quite interesting to see and my respect for him developed as well.<br /><br /><div class="quote">At least about the Intel Software IMHO - it's one of the slowest :)<br />So IMHO, it's worthy to take Intel notes about cach lines and alignments,<br />but treat their solution as one of many possible.</div>Our understanding of the world is a constantly changing process and nothing be so rigid to not change in time.<br /><br /><div class="quote">I guess they offered just easier to encode for HLL programmer way,<br />since for most people manual binary encoding is just too much.</div>Dispite the desires of many the brain does not think in numbers.</div>
    <div class="meta">Posted on 2003-10-10 00:06:01 by bitRAKE</div>
   </div>
   <div class="post" id="post-121014">
    <div class="subject"><a href="#post-121014">InString algo</a></div>
    <div class="body"><div class="quote"><br />cs = ds = ss, its a safe assumption for <em>most</em> versions of windows, but there are versions of windows which may not (datacenter 2K for example) [...]</div><br /><br />It sounds really interesting, <strong>Mirno</strong>. Could you post more info or some reference about it? A man hears only about flat mode again and again...<br /><br /><div class="quote"><br /><br />Might be it's better readable, but lingo gave sources<br />to be compiled, not just psuedo-asm-algo, AFAIK he USES<br />MASM, and MASM would leave out (ommit) those prefixes<br />optimizing for size. As the result label wouldn't be aligned<br />thus lingo placed prefixes explicitly as data byte to force<br />MASM include them. </div><br /><br />Thanks, I didn't know it before...</div>
    <div class="meta">Posted on 2003-10-10 13:47:02 by MazeGen</div>
   </div>
   <div class="post" id="post-134462">
    <div class="subject"><a href="#post-134462">Re: InString algo</a></div>
    <div class="body">Hello,<br /><br /><div class="quote"><br />I just continue the old Hutch's thread:<br /><a target="_blank" href="http://www.asmcommunity.net/board/showthread.php?threadid=6368&amp;highlight=instring">http://www.asmcommunity.net/board/showthread.php?threadid=6368&amp;highlight=instring</a><pre><code>    <br />; InString searches &#40;case sensitive&#41; for a substring <br />; in a larger string and if it is found, it returns its <br />; address in eax.   <br />; If the substring is not found, it returns zero in eax.<br />; Usage&#58; push offset Pattern<br />;        push offset Source<br />;        call InStringL <br />; &#91;B&#93;Caution&#58;&#91;/B&#93;This code is hard to read  <br /></code></pre><br /></div><br /><br />Very nice work. It is very fast and i want ask you, if i can use it in my string lib.<br />There is a little difference between my ASMSTRING and a C-String, because my ASMSTRING contains the size of the string at OFFSET PTR -4 (grows dynamically).<br /><br />Until now is used the following source, because it seems faster then InStringx:<br /><br /><pre><code><br />PosLeft proc String&#58; ASMSTRING, Pattern&#58; ASMSTRING<br />	MOV EAX, Pattern<br />	MOV EDX, String<br /><br />    TEST    EAX, EAX<br />    JE      @@noWork                ;&#123; SubStr = nil &#125;<br /><br />    TEST    EDX, EDX<br />    JE      @@StrEmpty              ;&#123; S = nil &#125;<br /><br />    PUSH    EBX<br />    PUSH    EDI<br />    PUSH    ESI<br />    MOV     ESI, EAX              	;&#123; ESI = Pattern &#125;<br />    MOV     EDI, EDX				;&#123; EDI = String &#125;<br />    MOV     EAX, 1                  ;&#123; StartPosition &#125;<br /><br />@@SkipAdjust&#58;<br />    DEC     EAX                     ;&#123; first char should be compared &#125;<br />    MOV     ECX, &#91;EDI-4&#93;            ;&#123; ECX = Length&#40;S&#41; &#125;<br />    MOV     EDX, &#91;ESI-4&#93;            ; &#123; Length&#40;SubStr &#125;    <br />    SUB     ECX, EDX<br />    JS      @@fail                  ; &#123; Length&#40;SubStr&#41; &gt; &#40;Length&#40;S&#41; - StartPos&#41; &#125;<br />    INC		ECX    <br />    PUSH    EDI                     ; &#123; remember s position to calculate index &#125;<br />    LEA     EDI, &#91;EDI+EAX&#93;          ; &#123; I &#58;= StartPos &#125;<br />    MOV     AL, &#91;ESI&#93;               ; &#123; SubStr&#91;1&#93; &#125;   <br />    JMP     @@RepneScasb<br /><br />@@PrepareRepeCmpsb&#58;<br />    MOV     EBX, ECX<br />    MOV     ECX, EDX                ; &#123; Length&#40;SubStr&#41; &#125;<br /><br />@@RepeCmpsb&#58;<br />    DEC     ECX<br />    JZ      @@found                 ; &#123; Length&#40;SubStr&#41; = 0 &#125;<br /><br />    MOV     AH, &#91;ESI+ECX&#93;<br />    CMP     AH, &#91;EDI+ECX&#93;<br />    JZ      @@RepeCmpsb             ; &#123; S&#91;I&#93; &lt;&gt; SubStr&#91;A&#93; -&gt; next char and Inc&#40;I&#41;<br />                                    ;  until S&#91;I&#93; = SubStr&#91;1&#93; &#125;<br />    MOV     ECX, EBX<br />    INC     EDI<br />    DEC     ECX<br />    JZ      @@failWithPop           ; &#123; string cant be found -&gt; end of string reached<br />                                    ; &#123; and outer @@RepneScasb &#125;<br />@@RepneScasb&#58;<br />    CMP     AL, &#91;EDI&#93;<br />    JZ      @@PrepareRepeCmpsb      ; &#123; SubStr&#91;A&#93; = S&#91;I&#93; &#125;<br />    INC     EDI                     ; &#123; Inc&#40;I&#41; &#125;<br />    DEC     ECX            <br />    JNZ     @@RepneScasb            ; &#123; I &lt;&gt; Length&#40;S&#41; &#125;<br />    JMP     @@failWithPop           ; &#123; I = Length&#40;S&#41; and S&#91;I - 1&#93; &lt;&gt; SubStr&#91;1&#93; &#125;<br /><br />@@StrEmpty&#58;                         <br />    XOR     EAX, EAX<br />    JMP     @@noWork<br /><br />@@found&#58;<br />    POP     EDX<br />    MOV     EAX, EDI<br />    SUB     EAX, EDX<br />    INC		EAX<br />    JMP     @@exit<br /><br />@@failWithPop&#58;<br />    POP     EDX<br /><br />@@fail&#58;<br />    XOR     EAX, EAX<br /><br />@@exit&#58;<br />    POP     ESI<br />    POP     EDI<br />    POP     EBX<br /><br />@@noWork&#58;<br />	<br />	ret<br />PosLeft endp<br /></code></pre><br /><br />But your code was ca. 15%-20% faster then mine (on my PIV) :-).<br />Do you think, it could be faster through alignement ( i try to learn ASM )?<br /><br />Do your code have some limitations or there are situations, where it cannot be used?<br /><br /><br />MfG Manuel.</div>
    <div class="meta">Posted on 2004-02-22 10:22:16 by other</div>
   </div>
   <div class="post" id="post-134478">
    <div class="subject"><a href="#post-134478">InString algo</a></div>
    <div class="body"><strong>other,</strong><br /><br /><strong>&quot;It is very fast and i want ask you, if i can use it in my string lib.&quot;</strong><br /><strong>&quot;Do you think, it could be faster through alignement ( i try to learn ASM )? &quot;</strong><br /><br />Yes<br /><br /><strong>&quot;Do your code have some limitations or there are situations, where it cannot be used?&quot;</strong><br /><br />No<br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2004-02-22 12:26:47 by lingo12</div>
   </div>
   <div class="post" id="post-134482">
    <div class="subject"><a href="#post-134482">InString algo</a></div>
    <div class="body">Hello,<br /><br /><br /><div class="quote"><br /><strong>other,</strong><br /><br /><strong>&quot;It is very fast and i want ask you, if i can use it in my string lib.&quot;</strong><br /><strong>&quot;Do you think, it could be faster through alignement ( i try to learn ASM )? &quot;</strong><br /><br />Yes<br /><br /><strong>&quot;Do your code have some limitations or there are situations, where it cannot be used?&quot;</strong><br /><br />No<br /><br />Regards,<br />Lingo </div><br /><br />Thats great. Thank you <strong>very</strong> much :-).<br /><br /><br />MfG Manuel.</div>
    <div class="meta">Posted on 2004-02-22 13:23:39 by other</div>
   </div>
  </div>
 </body>
</html>