<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30109" />
  <link rel="prev" href="../?id=30109&amp;page=1" />  <link rel="next" href="../?id=30109&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=30109">Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=30109&amp;page=1" style="">&laquo;</a><a href="../?id=30109&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="30109" /><input type="number" name="page" min="1" max="4" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=30109&amp;page=3">&gt;</a><a href="../?id=30109&amp;page=4">&raquo;</a></form>   <div class="post" id="post-212572">
    <div class="subject"><a href="#post-212572">Re: Cutting The Cheese</a></div>
    <div class="body">Spatial partitioning structures are often used to accelerate rendering systems by determining what is visible, and what is not currently visible.<br />I&#039;m sure you&#039;ve heard of Binary Space Partitioning (BSP) trees, Quadtrees, Octrees, and perhaps you&#039;ve heard of others, there are many.<br />In the same way, we can take advantage of spatial partitioning to accelerate the broad phase of our collision detection, where we need to test every entity against every other entity for possible collisions. Spatial partitioning can be used to track smaller groups of proximate objects, which can speed up broadphase testing by several orders, depending on the number of objects being simulated, and the way they are clustered in space.<br /><br />Today we will be discussing a kind of Binary Tree known generically as a Bounding Volume Hierarchy (BVH), and the specific kind we&#039;ll examine is called a Sphere Tree. I will use the term &quot;binary space partitioning&quot;, however I am not referring to a BSP Tree.<br /><br />As you&#039;re probably already aware, binary space partitioning schemes work by dividing space into two subspaces, and then recursively subdividing each subspace into smaller subspaces until some HEURISTIC is satisfied. A spheretree works the same way. So how does one go about constructing a spheretree? And what is a heuristic?<br /><br />Heuristics are a qualitative or quantitative measure which guides an algorithm toward an optimal output.<br />Which heuristics we choose depends completely on what the phrase &quot;optimal output&quot; means to us - it is purely contextual, it depends what we&#039;re doing, and what we&#039;re trying to achieve. If we can define what we want our algorithm to produce, then we can determine one or more heuristics which will help us to get there. The most common synonym for the word &quot;heuristic&quot; is known as an &quot;ERROR METRIC&quot;... we measure the amount of error in our calculations, and use that error term to steer subsequent calculations toward perfection. Heuristics are what our algorithm evaluates when it has to make DECISIONS from multiple possible options.<br /><br />There are basically three methods of constructing a sphere tree... TOP-DOWN, BOTTOM-UP, and INSERTIVE.<br />I will briefly discuss each of these, but it&#039;s worth noting from the outset that only the last one is valuable for a dynamic system, where the tree needs to be rebuilt in realtime.<br /><br />I will break now, and continue this post a little later today.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2010-08-07 01:25:19 by Homer</div>
   </div>
   <div class="post" id="post-212573">
    <div class="subject"><a href="#post-212573">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body">Heuristics for tree construction are often &quot;MUTUALLY EXCLUSIVE&quot; - for example, to construct a BSP tree we need to find a Plane which divides the input entities into two subsets that are as equal in number as possible, while cutting through as few entities as possible. We will often need to &#039;balance&#039; our heuristics to find an outcome which best fits ALL of the heuristics.<br /><br />Any BVH construction algorithm should observe the following three heuristics:<br /><br />1. The actual volume enclosed by the bounding volumes should be as small as possible, at each level of the tree. <br />Note that this is true when a parent node groups together two bounding volumes that are close together.<br /><br />2. The child bounding volumes of any parent should overlap as little as possible. <br />Often this will be mutually exclusive to the first heuristic (above), and in general it is better to favor smaller volumes over minimal overlaps. In fact, if you choose a minimal overlap at some low level of the tree, it is likely to cause greater overlaps higher up the tree: so a tree with an overall low overlap is likely to fulfill both requirements.<br /><br />3. The tree should be as balanced as possible. <br />You should avoid having some branches of the tree that are very deep while others are very shallow. The worst-case scenario is a tree with one long branch. In this case the advantage of having a hierarchy is minimal. The biggest speed-up is gained when all branches are roughly at the same length.<br /><br />Let&#039;s look at top-down construction first, because it is the most intuitive.<br />We have a bunch of entities in 3D space, and we want to construct a spheretree according to our three heuristics.<br /><br />For a top-down approach, we can begin by creating a HUGE bounding sphere around all of the entities in our world.<br />Now we need to split the entities into two subsets which have the smallest possible boundingspheres while simultaneously holding as equal a number of entities as possible... mutually exclusive goals.<br />Once we&#039;ve done that, we repeat this procedure for each subset, until our subsets each only contain a single entity - since we can&#039;t continue, we will call this a &#039;leaf node&#039; - notice that the leaf nodes of our tree contain one entity each, and all the other nodes contain NO entities.<br /><br />The bottom-up approach is quite different... let&#039;s assume once more that we start with a bunch of entities.<br />We&#039;ll begin again by finding the boundingsphere of the entire set, and we&#039;ll determine where the origin of this &#039;world bounding sphere&#039; is located.<br />Now we&#039;ll figure out which entity&#039;s origin is closest to this big boundingsphere&#039;s origin, and that entity will be the starting point for our algorithm.. we can discard the big boundingsphere, we&#039;ve chosen the entity which is closest to the midpoint of the distribution.<br />Now we&#039;re looking for the next entity, and our heuristic will be that we want to find an entity which would cause the smallest possible increase in boundingsphere in order to include it. For each &#039;other entity&#039;, we&#039;ll determine the midpoint between their boundingspheres, calculate a new boundingsphere using that midpoint as the new origin, and find the sphere which includes these two entities and is the smallest.<br />This procedure is repeated until the entire input set of entities has been consumed.<br /><br />The insertive approach, which we will be using, assumes that a tree already exists, although it can be used to generate a tree from scratch.<br />In the next post, we&#039;ll cover the algorithm for maintaining a dynamic spheretree.<br /></div>
    <div class="meta">Posted on 2010-08-07 03:24:38 by Homer</div>
   </div>
   <div class="post" id="post-212575">
    <div class="subject"><a href="#post-212575">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body">The insertion approach is the only one suitable for use in realtime simulations such as 3D games... it can adjust the hierarchy without having to rebuild it completely. Typically, we already have a tree, it can be an empty tree if we are just beginning. <br />In order to add a new entity to the tree, we need to recursively descend down through the tree: at each node we follow the child (theres only two childs in a binary tree) that would best accommodate the new object. Eventually we&#039;ll land in a Leaf, which is then replaced by a new parent sphere which contains both the existing leaf and the new entity. <br /><br />In order to remove an entity from the tree, we need to replace its parent node with its sibling, then recalculate the boundingspheres in all nodes farther up the hierarchy, until we calculate that there was no change in bounding radius. Since this can (but does not normally) mean recalculating all the bounding spheres all the way back to and including the root node, it is potentially a lot more expensive to delete an entity than it is to add a new one.<br /><br />Some of the papers you will encounter will go further: instead of the tree stopping with whole entities in the leaf nodes, we could continue to describe spheres which contain FEATURES of the entity (its triangles, its faces, its.. whatever). There is an enormous amount of inter-sphere overlap at this level and so I declare that there is little if any benefit in pursuing this.<br /><br />Now we have covered spatial partitioning and its relevance to broadphase collision testing... what&#039;s next?<br /></div>
    <div class="meta">Posted on 2010-08-08 03:11:24 by Homer</div>
   </div>
   <div class="post" id="post-212579">
    <div class="subject"><a href="#post-212579">Re: Speed-Up on top of a Speed-Up</a></div>
    <div class="body">I don&#039;t think I really pointed out the requirements of maintaining a dynamic tree ... <br />The entities in our tree are represented by the Leaf Nodes.<br />We&#039;ve already said that it&#039;s ok for SIBLING spheres to overlap.<br />But if an entity moves in 3D space, eventually it will overlap with its immediate parent sphere, and then with higher parent spheres.<br />So whenever an entity has moved, we need to check if its sphere is still completely bounded by its immediate parent.<br />If it isn&#039;t, we&#039;ll need to delete the entity from the tree and re-insert it, causing at least part of the tree to be rebuilt.<br />This won&#039;t happen every single frame, but it will happen a lot.<br /><br />Now, let&#039;s talk about optimizing the spheretree algorithm(s) which have been outlined so far.<br />It is important to recognize what we&#039;re trying to achieve with this scheme - the spheretree is ONLY a tool for identifying spheres which are proximate in space (close together, and so potentially able to collide). Therefore we&#039;re not interested in EXACT bounds, and in fact, our &#039;hungry sphere tree&#039; is quite a lot of overkill.<br /><br />Once an entity has been added to the tree, it is acceptable that we consider only the position of its ORIGIN in subsequent checks - we can effectively ignore the radius of the sphere immediately surrounding each entity, and treat them as particles.<br />Since we&#039;ve accepted that overlap of sibling spheres is not relevant, then it follows that overlap with the IMMEDIATE PARENT sphere is also not relevant - this can lead to a substantial speedup of the functions used to maintain the tree, without having a severe impact on either the structure of the tree or its value to us as an acceleration tool.<br /><br />In fact, this same logic CAN be applied right from the very outset - that instead of being interested in spheres which totally enclose our entities, we are only interested in finding spheres which enclose their origins.<br /><br />I have seen this applied to create acceleration trees for &#039;point clouds&#039; and particle systems, but never for rapid sphere trees.<br />However I have implemented this modification in the past, and I did not encounter any problems.<br />The reason why this can work is best described by using the example of Visibilty Tests based on intersection with the VIEW FRUSTUM - we know that if an entity is PARTLY VISIBLE, we&#039;re interested in it - it doesn&#039;t need to be TOTALLY VISIBLE, right?<br />The same logic applies here.<br /><br /></div>
    <div class="meta">Posted on 2010-08-08 21:13:53 by Homer</div>
   </div>
   <div class="post" id="post-212583">
    <div class="subject"><a href="#post-212583">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body"><br />The main problem we have to solve in order to construct our spheretree is called the &quot;Non Weighted Euclidian Single Point Problem&quot;, and can be described as follows:<br /><br />Given two Spheres (or Circles) of known position and radius, find the smallest Sphere (or Circle) which encloses them both.<br /><br />I&#039;ve attached a sketch which shows three situations: spheres separated by distance, spheres intersecting, and spheres kissing.<br />According to my sketch, it appears that we can easily and quickly calculate the Radius of the new boundingsphere: Find the line between the origins of the two input spheres, add both the radii to its length, and we have the diameter of the smallest possible bounding sphere. Its position is a bit more difficult, since we need to extend the line at each end by the appropriate radius - but we&#039;ve found a fast way to determine the minimal bounding radius (half the extended line&#039;s length), and that&#039;s all we need MOST of the time.<br /><br />In order to determine which radius to apply as an extension of which end of our line, we will assume the origin of one input sphere is in fact the origin of our line.<br />Now we will extend the line in the direction of the other sphere&#039;s origin, by the other sphere&#039;s radius, and then we know we just have to extend it in the other direction by THIS sphere&#039;s radius. This is a naiive solution which works in any direction by taking advantage of our knowledge of the geometries at hand.<br />Having calculated the full extended line, we now find its midpoint, and that is the position of the origin of our boundingsphere - we can do this by scaling the already-calculated radius in the appropriate direction from either endpoint in order to avoid an unnecessary divide operation.<br /><br />Armed with this knowledge, we&#039;re ready to write our first implementation of the insertion method for a &quot;hungry&quot; spheretree.. let&#039;s do that, and then show the much-faster &#039;particle&#039; version, which I will call &quot;SpeedTree&quot; (no relation to the rendering middleware product).<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3237" target="_blank">NWE1PP.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-08-09 05:47:41 by Homer</div>
   </div>
   <div class="post" id="post-212593">
    <div class="subject"><a href="#post-212593">Re: Code for the dynamic/insertive building of a SphereTree</a></div>
    <div class="body">Today we&#039;re going to look at some actual sourcecode.<br />To begin with, we have this structure:<br /><pre><code><br />——————————————————————————————————————————————————————————————————————————————————————————————————<br />; This structure represents a SPHERICAL BOUNDING VOLUME.<br />; Every Node in our Tree has one of these.<br />; ——————————————————————————————————————————————————————————————————————————————————————————————————<br />BoundingSphere struct<br />	vPosition Vec3 &lt;&gt; &nbsp;;Position of Sphere&#039;s Origin, in WorldSpace<br />	fRadius real8 ? &nbsp; &nbsp; &nbsp; ;Sphere&#039;s radius<br />BoundingSphere ends<br /></code></pre><br /><br /><br />Every node in our SphereTree will have its own BoundingSphere.<br />Now let&#039;s look at the class which describes a Node in our Tree... please just ignore whatever is not relevant today:<br /><pre><code><br />Object BVHNode, 8767843, Primer<br /><br />; Holds the child nodes of this node.<br />	DefineVariable pChildA, Pointer, NULL<br />	DefineVariable pChildB, Pointer, NULL<br /><br />; Holds a single bounding volume encompassing all the descendents of this node.<br />	DefineVariable volume, BoundingSphere, {&lt;&gt;}<br /><br />; Holds the rigid body at this node of the hierarchy.<br />; Only leaf nodes contain a rigid body.<br />; Note that it is possible to rewrite the algorithms in this<br />; class to handle objects at all levels of the hierarchy,<br />; but the code provided ignores this vector unless ChildA = NULL<br />	DefineVariable body, Pointer , NULL	;-&gt; RigidBody ... only valid in LEAF NODES<br /><br /><br />	RedefineMethod	Init,	Pointer, ptr RigidBody, ptr BoundingSphere<br />	StaticMethod	Insert,			 ptr RigidBody, ptr BoundingSphere<br />	<br />	<br />; Checks the potential contacts from this node downward in<br />; the hierarchy, writing them to the given array (up to the<br />; given limit). Returns the number of potential contacts found.<br />	StaticMethod getPotentialContacts,					ptr PotentialContact,	dword<br />	StaticMethod getPotentialContactsWith,	ptr BVHNode,ptr PotentialContact,	dword<br />	StaticMethod getBounds,								ptr BoundingSphere<br />	StaticMethod isOverlapping,							ptr BoundingSphere<br />	StaticMethod makeVolume,							ptr BoundingSphere,		real8<br />ObjectEnd<br /></code></pre><br /><br />For those of you have trouble understanding that, each node will basically be described by a structure which is roughly equivalent to this:<br /><pre><code><br />BVHNode struct<br />pOwner dd ? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Pointer to parent node, or NULL=root node<br />pChildA dd ? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Pointer to &#039;left branch&#039; of tree<br />pChildB dd ? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Pointer to &#039;right branch&#039; of tree<br />volume BoundingSphere &lt;&gt; &nbsp; &nbsp;;Nested struct describing boundingsphere<br />pRigidBody dd ? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Pointer to physics entity, only valid in leaf nodes<br />BVHNode ends<br /></code></pre><br /><br />And finally, we have the code:<br /><pre><code><br />;Method:	BVHNode.Insert<br />;Purpose:	Insert a new RigidBody into the tree<br />Method BVHNode.Insert, uses esi, newBody:ptr RigidBody, newVolume:ptr BoundingSphere<br />LOCAL f1:real8, f2:real8<br />	SetObject esi<br />	; If we are a leaf, then the only option is to spawn two new children and place the new body in one of them (and the current node gets copied into the other, and then this node&#039;s sphere is recalculated)<br />	.if .body!=0<br />		; Set Child one = a copy of us.<br />		mov .pChildA,$New(BVHNode,Init,esi,.body,addr .volume)<br />		; Child two holds the new body<br />		mov .pChildB,$New(BVHNode,Init,esi,newBody, newVolume)<br />		; And we now forget the body (we’re no longer a leaf).<br />		mov .body , NULL<br />		; We need to recalculate our bounding volume.<br />		OCall esi.getBounds,newVolume		;calculate boundingsphere of this+newvolume<br />		fsqrt								;we want actual diameter, not dia^2<br />		fstp f1<br />		OCall esi.makeVolume,newVolume,f1	;<br />	<br />	; Otherwise we need to work out which child gets to keep the inserted body. <br />	; We give it to whoever would grow the least to incorporate it.<br />	.else<br />		OCall .pChildA::BVHNode.getBounds, newVolume<br />		fstp f1<br />		OCall .pChildB::BVHNode.getBounds, newVolume<br />		fstp f2<br />		.if $IsLess(f1,f2)	;comparing the sq. diameters of proposed boundingspheres<br />			OCall .pChildA::BVHNode.Insert,newBody,newVolume<br />		.else	<br />			OCall .pChildB::BVHNode.Insert,newBody,newVolume<br />		.endif<br />	.endif<br />MethodEnd<br /><br />;Method:	BVHNode.TwoSphereComparison<br />;Purpose:	Load important data onto FPU for sphere comparison stuff<br />;Returns:	ST(0) = SQUARED Sum of Radii<br />;			ST(1) = SQUARED Distance Between Origins<br />BVHNode_TwoSphereComparison macro other;ptr BoundingSphere<br /><br />	mov edx,other<br />	lea eax,.volume<br />	fld .BoundingSphere.vPosition.x		;Calculate the sq. length of the line between origins<br />	fsub .BoundingSphere.vPosition.x<br />	fmul st(0),st(0)<br />	fld .BoundingSphere.vPosition.y<br />	fsub .BoundingSphere.vPosition.y<br />	fmul st(0),st(0)<br />	fld .BoundingSphere.vPosition.z<br />	fsub .BoundingSphere.vPosition.z<br />	fmul st(0),st(0)<br />	fadd<br />	fadd<br /><br />	fld &nbsp;.BoundingSphere.fRadius			;Calculate the sq. sum of the radii (ie amount by which to extend our line)<br />	fadd .BoundingSphere.fRadius<br />	fmul st(0),st(0)<br />endm<br /><br /><br />;The following method is called while choosing the best (smallest) possible boundingsphere:<br /><br />;Method:	BVHNode.getBounds<br />;Purpose:	Calculate the SQUARED DIAMETER of a proposed new boundingsphere<br />;			which encloses both &#039;this&#039; sphere, and the given sphere (&#039;other&#039;)<br />;			Since we&#039;re only looking to find a &#039;best possible&#039; boundingsphere, <br />;			we can avoid a square root and just compare the sq. diameters.<br />;Args:		other -&gt; BoundingSphere representing the other sphere<br />;Returns:	ST(0) = SQUARED diameter of new sphere<br />Method BVHNode.getBounds, uses esi, other:ptr BoundingSphere<br />	SetObject esi		<br />	BVHNode_TwoSphereComparison other<br />	fadd										;ST0 = squared diameter of minimal bounding sphere	<br />MethodEnd<br /><br /><br />;Method:	BVHNode.makeVolume<br />;Purpose:	Recalculate BoundingSphere of minimal Volume which encloses both &#039;this&#039; and &#039;other&#039; sphere<br />;Args:		other -&gt; BVHNode representing &#039;other sphere&#039;<br />;			fnewDia = Diameter of the new BoundingSphere<br />;Returns:	EAX -&gt; BoundingSphere<br />Method BVHNode.makeVolume, uses esi, other:ptr BoundingSphere, fnewDia:real8<br />LOCAL diff:real8<br />	SetObject esi<br /><br />	fld fnewDia									;Precalculate: diff = new diameter - this radius<br />	fsub .volume.fRadius<br />	fstp diff<br /><br />	fld .BoundingSphere.vPosition.x		;Calculate Line between Origins, and its Length<br />	fsub .volume.vPosition.x<br />	fst .volume.vPosition.x<br />	fmul st(0),st(0)<br />	fld .BoundingSphere.vPosition.y<br />	fsub .volume.vPosition.y<br />	fst .volume.vPosition.y<br />	fmul st(0),st(0)<br />	fld .BoundingSphere.vPosition.z<br />	fsub .volume.vPosition.z<br />	fst .volume.vPosition.z<br />	fmul st(0),st(0)<br />	fadd<br />	fadd<br />	fsqrt<br />	<br />	fld .volume.vPosition.x									;Use Length to Normalize the Line into a Direction,<br />	fld .volume.vPosition.y									;Scale it by (newDiam - this Radius), and then add our Point A (&#039;this origin&#039;)<br />	fld .volume.vPosition.z									<br />	fdivr	<br />	fmul diff<br />	fadd .volume.vPosition.z<br />	fstp .volume.vPosition.z<br />	fdivr	<br />	fmul diff<br />	fadd .volume.vPosition.y<br />	fstp .volume.vPosition.y<br />	fdivr	<br />	fmul diff<br />	fadd .volume.vPosition.x<br />	fstp .volume.vPosition.x<br />	<br />	fld fnewDia<br />	fmul r4_half<br />	fstp .volume.fRadius<br />	<br />MethodEnd<br /><br /></code></pre><br /><br />It&#039;s not perfectly optimized, but it&#039;s not ABSOLUTELY horrible, and it will get the job done.<br />I haven&#039;t bothered providing sourcecode for all of the macros that have been used, that is an exercise for OA32 users if they choose to look them up. And please note this code has *NOT* been tested, so there MAY be mistakes - however rest assured that I am indeed implementing this, as this thread documents my ACTUAL coding adventures, not just what&#039;s rattling around in my head.<br /><br />Just looking over that sourcecode, we can see that most of the cost involves calculation of line lengths.<br />In the next post, I&#039;ll show you a slightly different version, which I call &quot;SpeedTree&quot;.<br />The difference is that we will no longer consider the radius of a sphere being inserted into the tree - we&#039;ll treat the input sphere as a single particle or point in 3D space. We&#039;ll still need to consider the spheres at each node of our tree, but by removing one sphere from the equation, we can reduce the math requirements by approximately half, and so effectively yield a speedup of 200 percent (or thereabouts). In practice it&#039;s of course less, but the speedup is nonetheless considerable, and it won&#039;t affect the tree&#039;s ability to group nearby entities, and so accelerate our broadphase collision testing.<br /><br />Any speedups here will be incredibly important to our simulation, because we need to do broadphase testing every frame, and because our dynamic tree will be constantly rebuilt as our entities move in worldspace... narrowphase collision testing is VERY expensive, and the whole point of broadphase testing is to try to avoid narrowphase testing !!! So although it may seem like we&#039;re optimizing the wrong end of the collision spectrum, if you consider that it is in fact a culling operation, it makes complete sense.<br /><br /><br /></div>
    <div class="meta">Posted on 2010-08-10 10:27:04 by Homer</div>
   </div>
   <div class="post" id="post-212663">
    <div class="subject"><a href="#post-212663">Re: SpeedTree : A Dynamic BSP Tree based on Moving Spheres</a></div>
    <div class="body"><br />Now I&#039;m going to try to describe my proposed SpeedTree, both the theory behind it, and develop the algorithms here, this is NOT implemented but in my mind&#039;s eye, and on graph paper, it&#039;s looking good.<br /><br />SpeedTree is a DYNAMIC Binary Space Partitioning tree... it is constructed from Planes, and we can find our entities in the Leaves.<br /><br />Each plane passes through the origin of an associated entity, with some initial Direction determined by our algorithm. The direction of the plane will then follow that of the linear velocity, if any. And the plane is defined literally by the worldspace position of the entity&#039;s center of mass - to define a Plane in 3D, we need a Point (on the Plane), and a Direction. Thus, as the entity moves, the plane moves, and as the entity changes direction of travel, the plane rotates.<br /><br />Now for the kicker.<br /><br />Whenever we want to do Point/Plane tests, we ALWAYS give the Plane some &quot;thickness&quot; - normally this is a Numerical Error Tolerance that we simply call &quot;Epsilon&quot;.<br />SpeedTree uses the Radius of the Entity&#039;s BoundingSphere as the plane thickness - thus, the plane is actually TWO planes, facing the same direction, and both tangent to the surface of the sphere, on either side of it, defining THREE SUBSPACES , which we usually call &quot;back&quot;, &quot;front&quot;, and &quot;coplanar&quot;.<br /><br />In fact, when we perform Sphere/Plane tests, it is normal to use this technique of giving the plane the thickness of the radius of the sphere we&#039;re testing against - in this case, we&#039;re giving it a default thickness of its construction sphere, and we can EXTEND that thickness by &quot;other sphere&quot; in our tests, thus we can effectively then treat the &quot;other sphere&quot; as a simple 3D point in space, so our per-node compare calculation becomes one of an addition followed by a dot product, sounds good!<br /><br />Our tree construction algorithm will always be &quot;top down insertive&quot; - if we know the positions of all the spheres up front, we can pick one near the middle of the distribution as the starting point.. but I don&#039;t think the choice of the root node matters too much, our construction algorithm will assume that NONE of the entities have any initial velocity, and will instead choose the direction from the previously inserted entity to the currently inserted entity. This will cause the space to become most partitioned where clustering is most intense.<br /><br />In the next post I&#039;ll try to develop these ideas further, hopefully providing sketches and pseudocode, and addressing the possible peculiarities of the proposed scheme.<br /><br /></div>
    <div class="meta">Posted on 2010-08-14 09:27:47 by Homer</div>
   </div>
   <div class="post" id="post-212679">
    <div class="subject"><a href="#post-212679">Re: Points, Planes, Spheres and the DotProduct</a></div>
    <div class="body">Bounding Volume Hierarchies don&#039;t map space - they map the relationship between the positions and sizes of a bunch of spheres.. therefore they are not a true spatial partitioning scheme.<br /><br />BSP trees map space into binary subspaces (two half-spaces), and normally these spaces are quite static and so the tree is static too.<br /><br />SPEEDTREE is a hybrid scheme which attempts to fuse elements of both, and is based on planes which can move and rotate - like a BVH the tree is dynamic, but typically requires less updating due to the nature of halfspaces, and uses cheaper tests. Like a BSP, it is based on PLANES, but they are not static.<br /><br />For the benefit of everyone reading this thread, I would like to go back to the nuts and bolts theory and math behind planar tests in 3D space. So I&#039;ll begin with a discussion of planes, point/plane distance test, sphere/plane intersection test, 4D swept test for intersection of a moving sphere and static plane, and finally, we&#039;ll derive a swept test for a sphere and a plane which are BOTH moving, and which is the cornerstone of SpeedTree.<br /><br />PLANE<br />Imagine that we had an infinitely large, infinitely thin, infinitely flat piece of paper that cuts through the entire universe. It has a front side, and it has a back.. we can rotate it to face into some 3D direction, and we could move it (translate it) so that the plane cuts through some point in WorldSpace (the point is ON the plane, rather than behind it or in front of it).<br /><br />We can define a Plane using the PLANE EQUATION: Ax + By + Cz + D = 0<br />where (x,y,z) represents a 3D point resting on our plane, and (A,B,C) represents the Direction which the plane is facing (ie, its NORMAL). So what then, is this unknown D?<br /><br />D is referred to as the &quot;Plane Distance&quot; (or simply &quot;PlaneD&quot;) - literally, it&#039;s the distance from the World Origin to our plane, and we can calculate it, given the other values. The full set of values of XYZ and ABCD defines a UNIQUE 3D PLANE.<br /><br />It is quite common to store a Plane as (N,D) where N=(A,B,C), our Normal, and D was precalculated from some point KNOWN to be on the plane, using the previous equation, which is more clearly rewritten as as: D = - (P . N)<br />where P = point on plane, and the &quot;dot&quot; represents the DOT PRODUCT EQUATION (Ax + By + Cz)<br /><br />Given a Plane stored in this form of a Normal vector and a D value, we can test any OTHER point in 3D space to see if it rests apon the plane, in front of the plane, or behind it. To measure the DISTANCE FROM ANY POINT TO A PLANE, we can use the following equation: d = (T - P) . N<br />where d = distance from testpoint to plane, in the direction of the Normal (shortest distance!!), and T is the point being tested.<br />We can again rewrite this as: d = N . T + D, allowing us to make use of a plane&#039;s precalculated D value.<br />If we feed values into that equation, let&#039;s look at the result: d will either be positive, negative, or zero.<br />If its zero (or very close - numerical tolerance please!) , then the test point coincides with the plane.<br />If its positive, then the point is in front of the plane, and otherwise it must be behind the plane, and by the distance of d, when measured along the direction of N.<br /><br />Now we have an equation that we can use to check whether an arbitrary 3D point is behind, before, or coincides with a given unique 3D plane. This will be the keystone of everything that is to follow, so be sure you can understand how to define a unique plane in 3D, and calculate its D value, and can now write your own DOTPRODUCT function, and your own DistancePointPlane function, and test them.<br /><br />Next we&#039;ll consider a Sphere and a Plane, and modify our existing function slightly to deal with the radius of a sphere.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2010-08-14 22:30:25 by Homer</div>
   </div>
   <div class="post" id="post-212680">
    <div class="subject"><a href="#post-212680">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body"><br />OK, what if we wanted to know the distance from a Sphere to a Plane?<br />If we treated the sphere as a simple Point, we know that:&nbsp; d = (T - P) . N where<br />d=distance from origin of sphere to plane, measured along plane normal<br />T=position of sphere origin in world space<br />P=any Point known to exist on the Plane, say, the one we used when we defined it<br />. =DotProduct operator<br />N=Normal of the Plane (Direction it faces)<br /><br />Given that the Sphere has a Radius (R), ie it is a Point that has some THICKNESS, we can rewrite the equations as: d = ((T - P) . N) - R<br />In other words, the distance from the surface of the sphere to the plane is that of its origin, minus its radius.... we have taken the radius into account.<br /><br />Because of the nature of computers, we have to contend with numerical accuracy.<br />So we will typically give our Plane some Thickness too, by introducing an &quot;Epsilon&quot; value.<br />The equation for a Point then becomes:&nbsp; &nbsp;  d = ((T - P) . N) - Epsilon<br />Compare this to that for a Sphere:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d = ((T - P) . N) - R<br />Note that we don&#039;t need an Epsilon value for the Sphere/Plane distance equation, because we can simply imagine our Sphere as a Point, and the Plane has having +/- the thickness of the Radius - we&#039;ve simply got a bigger Epsilon :)<br /><br />The next post will be cool, we&#039;ll look at our first 4D intersection test, a MOVING sphere and a Static Plane, over a given TimeStep.<br /><br /></div>
    <div class="meta">Posted on 2010-08-14 23:59:25 by Homer</div>
   </div>
   <div class="post" id="post-212681">
    <div class="subject"><a href="#post-212681">Re: Sphere/Plane 4D Sweep</a></div>
    <div class="body">Stare at this image for a while, we are looking at a 3D scene of a moving sphere and a fixed (static) plane, with the plane facing upwards, and looking at it from the side view.. the lower line represents the plane, and the thinner line above it has been shifted by the radius, in the direction of the plane normal. The sphere is shown at three moments in Time, starting at Time T0 and ending at Time T1... could be its current and next position, or its previous and current position, depending on how we think about it. But clearly in the example, it will definitely intersect the plane during its travel, and will first touch the plane at &quot;Unknown Time TU&quot;.<br />We expect that when the sphere first touches the plane, that its origin will coincide with the upper line that represents the plane &quot;shifted along its normal by the radius&quot;, and would LAST touch the plane when its origin coincided with a line (not shown) that represented the Plane shifted in the opposite direction by the same amount.<br />I have to break now, so start staring :D</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=3242" target="_blank">SpherePlaneSweep.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2010-08-15 00:21:06 by Homer</div>
   </div>
   <div class="post" id="post-212685">
    <div class="subject"><a href="#post-212685">Re: Sphere/Plane 4D Sweep</a></div>
    <div class="body">So, we have a moving Sphere, and a fixed Plane.<br />Let&#039;s write down everything we KNOW about this situation:<br />At Time=T0, the Sphere&#039;s Origin is at Position=P0, which is distance=D0 from the Plane.<br />At Time=T1, the Sphere&#039;s Origin is at Position=P1, which is distance=D1 from the Plane.<br /><br />Then there is U.<br />At Time=U, the Sphere&#039;s Origin is at a distance=R from the Plane.<br />If we can figure out what Time U equals, then we can interpolate to find the Position :)<br /><br />The trajectory from P0 to P1 &nbsp;can be parameterized with a variable U, which may be thought of as normalized time, since its value is 0 at T0, P0 and 1 at T1, P1.... that is to say, U is some FRACTION between 0.0 and 1.0 :)<br /><br />The normalized time at which the sphere first intersects the plane is given by: &nbsp; &nbsp;U=D0-R / (D0-D1)<br />The position of the sphere&#039;s origin at this TIME OF IMPACT (TOI) can then be interpolated with an affine combination of P0 and P1: &nbsp; PU = ((1-U) * P0) + (U * P1)<br /><br />We are now able to tell exactly what Time the Sphere will touch the Plane, and where it will be.<br />Note that since the Time is still Normalized, if we want actual time we&#039;ll need to interpolate beween the actual times at T0 and T1, with our U coefficient again used as the interpolation factor.<br /><br />In the next post, we&#039;ll look at some example sourcecode which addresses the &quot;singularities&quot; of this formula, ie, the special conditions under which it may fail.<br /><br /><br /> I should have mentioned that our solution is a linear one - it assumes that the trajectory is a simple linear motion for the duration of the timeframe.<br />It would be more accurate to instead apply this kind of solution to the Acceleration or even the input Forces of the sphere, thus it becomes a second-order or higher (curve) solver. The Runge-Kutta 2nd (midpoint acceleration) or 4th order (RK4) numerical integration techniques could be adopted for this purpose, if such a level of accuracy was demanded. But we&#039;re just trying to find the lower bound of the TOI for a BOUNDING sphere, which contains some arbitrary geometry - broadphase, not narrow.<br /><br /><br /></div>
    <div class="meta">Posted on 2010-08-15 03:52:16 by Homer</div>
   </div>
   <div class="post" id="post-212686">
    <div class="subject"><a href="#post-212686">Re: Implementation of 4D Sphere/Plane Sweep</a></div>
    <div class="body">The main problem is in our formula for U=D0-R / (D0-D1)<br />If D0=D1, ie the sphere didn&#039;t move at all (relative to the plane), then we will have a DIVIDE BY ZERO ERROR - but we can detect easily when D0=D1, and exit from our test function, since we know that intersection was not possible, because there was no relative velocity, ie displacement in position over time.<br /><br />Let&#039;s see some sourcecode for this function which does eliminate that condition &#039;for free&#039;..<br />Note that I&#039;ve used a mixture of opcodes and macros , your own code can look how you want it to.<br /><br /><pre><code><br />;A macro for distance Point Plane calculation<br />;P = Point, N = Normal, D = PlaneD<br />distanceToPoint macro P, N, D<br />DotProduct P, N<br />fadd D<br />endm<br /><br />;A function for calculating position and time of impact of sphere and plane<br />;Returns EAX = TRUE, ST(0) = TOI if there is a collision<br />;Otherwise returns EAX = FALSE<br />SpherePlaneSweep proc fRadius:real8, pvPos0, pvPos1, pvPlaneNormal, fPlaneD:real8, pvPosU<br />local fU:real8<br />local D0:real8<br />local D1:real8<br /><br />mov eax,pvPlaneNormal<br />mov edx, pvPos0<br />distanceToPoint .Vec3, .Vec3, fPlaneD<br />fstp D0<br /><br />mov edx, pvPos1<br />distanceToPoint .Vec3, .Vec3, fPlaneD<br />fstp D1<br /><br /><br />;check if it was touching on previous frame<br />fld D0<br />fabs<br />.if $IsLessOrEqual(ST(0), fRadius)<br /> &nbsp; &nbsp;mov eax,pvPos0<br /> &nbsp; &nbsp;mov edx,pvPosU<br /> &nbsp; &nbsp;Vec3Copy .Vec3, .Vec3<br /> &nbsp; &nbsp;fldz<br /> &nbsp; return TRUE <br />.endif<br /><br />;check if the sphere penetrated during this frame (and if indeed it moved at all)<br />.if ($IsGreater(D0,fRadius)) &amp;&amp; ($IsLess(D1,fRadius))<br /><br /> &nbsp; ; Pu = (1-u)*P0 + (u*P1) = point of first contact<br /> &nbsp; fld D0<br /> &nbsp; fsub fRadius<br /> &nbsp; fld D0<br /> &nbsp; fsub D1<br /> &nbsp; fdiv &nbsp; ;leave U on fpu stack<br /> &nbsp; fst fU<br /> &nbsp; <br /> &nbsp; mov eax,pvPosU<br /> &nbsp; mov edx,pvPos0<br /> &nbsp; fld .Vec3.x<br /> &nbsp; fld .Vec3.y<br /> &nbsp; fld .Vec3.z<br /> &nbsp; fld1<br /> &nbsp; fsub fU<br /> &nbsp; fmul st(3),st(0)<br /> &nbsp; fmul st(2),st(0)<br /> &nbsp; fmul<br /> &nbsp; fstp .Vec3.z<br /> &nbsp; fstp .Vec3.y<br /> &nbsp; fstp .Vec3.x<br /><br /> &nbsp; mov edx,pvPos1<br /> &nbsp; fld .Vec3.x<br /> &nbsp; fld .Vec3.y<br /> &nbsp; fld .Vec3.z<br /> &nbsp; fld fU<br /> &nbsp; fmul st(3),st(0)<br /> &nbsp; fmul st(2),st(0)<br /> &nbsp; fmul<br /><br /> &nbsp; fadd .Vec3.z<br /> &nbsp; fstp &nbsp;.Vec3.z<br /> &nbsp; fadd .Vec3.y<br /> &nbsp; fstp &nbsp;.Vec3.y<br /> &nbsp; fadd .Vec3.x<br /> &nbsp; fstp &nbsp;.Vec3.x<br /><br /> &nbsp; return TRUE<br />.endif<br /><br />return FALSE<br />SpherePlaneSweep endp<br /></code></pre><br /><br /><br />In the next post, we&#039;ll modify this test for a moving plane as well :)</div>
    <div class="meta">Posted on 2010-08-15 04:50:40 by Homer</div>
   </div>
   <div class="post" id="post-212688">
    <div class="subject"><a href="#post-212688">Re: Physics 2010 - 4D Sweep of Moving Plane and Moving Sphere</a></div>
    <div class="body">In this post, we will consider a moving sphere and a moving plane. For the purpose of this post, we will consider only that the Plane is moving, and moving along the axis defined by its Normal (either direction)... rotation is not considered, we&#039;ll get to that though!<br /><br />In order to calculate our U coefficient for a moving sphere and a moving plane, we need to, mathematically speaking, treat the plane as TWO planes, which we&#039;ll call Plane0 and Plane1.<br />As mentioned, they will both have the same Direction, ie, the Normal does not change.<br />But the position of the plane does, and this directly affects the PlaneD value.<br />Previously, we stated that &quot;PlaneD is the distance from the World Origin to the Plane&quot; (I forgot to mention that this is the distance measured in the direction of N, but that should be obvious by now).<br />Given that we know the Velocity of our moving plane, or that we can calculate it from P0, P1, and the timestep (T1-T0), we can determine DIRECTLY how much PlaneD has to be adjusted for Plane1.<br />And whether we add or subtract this amount can be determined by the Sign of Plane0.PlaneD, which tells us which side of the Plane we can find the world origin, and thus whether the Plane is moving toward or away from the world origin :)<br /><br />So, all we need to do in order to calculate U for a moving sphere and a moving plane is to determine the &quot;Plane1.PlaneD&quot; value, pass this as an extra parameterm and use that when we calculate D1:<br /><pre><code><br />mov eax,pvPlaneNormal<br />mov edx, pvPos0<br />distanceToPoint .Vec3, .Vec3, fPlaneD0<br />fstp D0<br /><br />mov edx, pvPos1<br />distanceToPoint .Vec3, .Vec3, fPlaneD1<br />fstp D1<br /></code></pre><br /><br />We&#039;re in business!<br />Now we can calculate the TOI and Position of first Contact of a moving sphere and a moving plane.<br />This can be very useful in narrowphase testing, but we&#039;re not yet interested in that.<br />What we care about is that this will allow us to construct and maintain a DYNAMIC BSP TREE.<br />But only as long as the Planes are not able to rotate... <br /><br />In the next post, we&#039;ll see how to introduce Rotation of the Plane in our Swept Sphere test.<br /><br /></div>
    <div class="meta">Posted on 2010-08-15 08:54:14 by Homer</div>
   </div>
   <div class="post" id="post-212699">
    <div class="subject"><a href="#post-212699">Re: This sounds complicated, but it isn't.</a></div>
    <div class="body">Now we wish to introduce angular velocity into the equation.<br /><br />Angular velocity is a 3D vector which can be decomposed into an axis and a rate of change of orientation about that axis, by convention in radians per second.<br /><br />If our plane has a known angular velocity about its &#039;construction point&#039;, then we can easily rotate the Direction vector to find out where it is facing at the end of the timestep.<br /><br />Simply put, we now have a situation where the two Planes (Plane0 and Plane1) change completely between T0 and T1. We can no longer calculate the value of Plane1.D as previously, because the Direction is no longer constant... we&#039;ll need to completely calculate the value of PlaneD at T1, as we did at T0.<br /><br />Plane1.PlaneD is now dynamic, we can track the PlaneD value for use in T0, but we&#039;ll be calculating a new value for T1, and also for TU if there is intersection, at each timestep. So we drop the extra PlaneD param that we added to our function in the previous post, since we&#039;ll only know Plane0.D on entry to the function.<br /><br />Once we&#039;ve calculated U, interpolating the rotation for TU is extremely simple, and there&#039;s two ways to do it.The first is simply to interpolate between Plane0.N and Plane1.N, by the U coefficient.<br />The second way is to interpolate the magnitude of the angular velocity.. since we&#039;re going to assume that the angular velocity remains constant for the duration of the timestep, we simply need to extract the rate of angular change from the angular velocity vector (ie its magnitude), and scale it by U, then rotate the Plane0.N vector by that amount about the rotation axis. I&#039;m not sure which is cheaper, I have a feeling they work out about the same. If I remember right, there&#039;s 12 multiplications and 9 additions in a trigonometric rotation formula, noting that we don&#039;t have a suitable transform matrix here. I guess interpolating the vector N is cheaper.<br />Finally, having calculated a &quot;PlaneU.N&quot;, we can calculate a &quot;PlaneU.D&quot; to match.<br /><br />So very little needs to change in our function.<br />But again we have a new singularity to deal with.<br />Our formula can fail if the angular velocity is allowed to exceed &quot;PI radians per timestep&quot; (180 degrees per timestep) ... this is , of course, incredibly fast rotation if our timesteps are sanely small, so it&#039;s fine that we place this upper limit on the angular velocity of all entities in the simulation.<br /><br />We now have a function that can determine the TOI and position of first contact for a moving sphere and a moving, rotating plane :)<br /><br />This is a VERY useful test, and it&#039;s not really costing a lot more than the previous one, especially since we&#039;ll remember the new PlaneD value at the end of each timestep for use in the next timestep (COHERENCE, remember?)<br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2010-08-15 10:52:55 by Homer</div>
   </div>
   <div class="post" id="post-212700">
    <div class="subject"><a href="#post-212700">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body"><br />Just wanted to add this:<br /><br />Given a typical physics timestep of 0.1 seconds, the maximum rate of rotation is then 10*PI radians per second, which is 5 complete rotations of the plane per second, as the upper limit of the angular velocity before our formula can begin to fail.<br /><br /></div>
    <div class="meta">Posted on 2010-08-15 10:59:29 by Homer</div>
   </div>
   <div class="post" id="post-212734">
    <div class="subject"><a href="#post-212734">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body"><br />Due to constraints apon my time, I am going to shelf the SpeedTree temporarily and instead implement a rather specialized Dynamic AABB Tree.<br /><br />It&#039;s specialized because we will work with the assumption that all of the entities that it contains are Spheres (every RigidBody will have, at least, a BoundingSphere). We will use our knowledge of these spheres when building and maintaining the tree.<br />Also, it will depart from the traditional AABB tree in several other ways - I&#039;ll describe the system in depth, but you&#039;re going to have to wait a few hours, I need sleep :)<br /></div>
    <div class="meta">Posted on 2010-08-16 10:48:55 by Homer</div>
   </div>
   <div class="post" id="post-212759">
    <div class="subject"><a href="#post-212759">Re: Dynamic Axially Aligned BoundingBox Tree optimized for Spheres.</a></div>
    <div class="body">The traditional AABB tree is a straightforward Leafy Binary Tree where each node in the tree represents an axis-aligned bounding box (AABB), with nonleaf nodes having two child nodes, and leaf nodes having at least one entity.<br />Each non-leaf node has the property that its AABB encloses all of its child nodes’ AABBs, and<br />the tree is built by successively splitting the &#039;root&#039; AABB in half (cutting through its PRINCIPAL AXIS), and then inserting the entities into one of the two child nodes based on which side of the split it is on (more on this later).<br /><br />For a dynamic tree, we&#039;ll relax some of those constraints.. As previously stated, we don’t limit the number of child nodes that a node can have, and we allow entities to be stored in nonleaf nodes. And rather than build the entire tree based on static data, we only build subtrees when they are actually being queried (again, more on this later).<br />And we&#039;re going to have to choose a nesting heuristic for the entire tree, which dictates how nodes are split and how objects are stored in the child nodes. We&#039;ll take a look at a few candidates.<br />Finally, our implementation will only ever deal with Sphere entities, so we can make a few optimizations based on that fact.<br /><br /><br />So let&#039;s get started by covering the most important three functions in a Dynamic Partitioning Tree: INSERTING, DELETING AND UPDATING OUR SPHERE ENTITIES :)<br /><br />Since this is about Dynamic trees, I am going to assume (as you should) that we already have a tree - if we don&#039;t, the first Insertion of an entity should generate a Root Node storing our entity.<br />I&#039;m just going to cover the theory first, this probably won&#039;t make complete sense until we see some of the structures and code examples, but you should be able to see a few similarities to the SphereTree - this is in fact just another kind of BVH.<br /><br />Inserting an entity into the tree is really easy... Starting at the root node, and using whatever nesting heuristic we have decided to use, choose the child which is the most appropriate container for the entity until either we land in a leaf node, or the nesting heuristic demands that the entity should be stored in the current nonleaf node. Associate the final tree node with the object, then expand the AABBs of all nodes from the current node, all the way up to and including the root node, as necessary.<br />Note that this can be done during the return from this recursion, with some care... that&#039;s a much more elegant way than walking back up through the tree via &quot;parent pointers&quot;, or worse, RECURSING BACK UP the tree, I&#039;ve seen both of those crap ideas implemented by people who are smarter than me.<br /><br />Deleting is also quite simple :)<br />First we will remove the entity from the node which contains it. <br />Next, starting with the current node, check to see if the object’s bounding volume was &#039;kissing&#039; against the edge of the AABB (ie, the AABB could potentially shrink as a result of this deletion).. if so, mark the AABB for recalculation, walk to the parent, and repeat this process until the object is no longer flush against the AABB. <br />Finally, we perform a simple garbage collection: if the node is empty of entities and has no children, we can delete the node, and delete its reference from its parent node. If the parent node now has no<br />children, then it should be UNSPLIT, and if it is ALSO devoid of entities, it can ALSO be deleted, and we simply repeat this all the way back to root, or until we hit a node that contains entities.<br /><br />Updating is again, pretty straightward.. Since our spheres are rotationally invariant, the only time we need to UPDATE is when an entity moves, causing its BoundingBox to change. <br />First, locate the Node containing the entity which has Moved, and walk back up the tree until we find a node whose AABB will completely contain the sphere&#039;s boundingbox, or Root node, whichever we reach first. Next, use our nesting heuristic to determine the child node which should now contain the sphere. Finally, if this destination node is different than the sphere’s current node, remove the sphere from the current node and insert it into the destination node. Either way, recalculate the container node’s AABB.<br />This technique exploits both spatial and temporal coherence: if an object does not move between queries, then we have no work to do... and if an object does move, we&#039;ve limited the search for its new container to the space within which it has actually moved. This will rarely require adjusting all the way back to root, that only happens when an entity steps outside the root node&#039;s box.<br /><br />In the next post, we&#039;ll get into some of the dirty details of implementation specifics and we&#039;ll talk about a few nesting heuristics that we might choose from. We&#039;ll also talk about Node Splitting - when and why, and how to avoid the possible &quot;Frgamentation&quot; that can result from doing so.<br /><br /></div>
    <div class="meta">Posted on 2010-08-17 10:48:09 by Homer</div>
   </div>
   <div class="post" id="post-212782">
    <div class="subject"><a href="#post-212782">Re: More tree management, Nesting Heuristics</a></div>
    <div class="body">Let&#039;s press forward.<br /><br />Since we&#039;re now dealing with Boxes, let&#039;s describe a naiive approach to (re)calculating the AABB of a given node. For this, we will typically begin at Leaf nodes.<br />First, determine the AABB which encloses all the Spheres in the current node. <br />Next, get each child node’s AABB, and grow the current node’s AABB to accommodate it. <br />Finally, mark the AABB as current, and signal an update to the parent node, which may then require an update. <br />Note that once we&#039;ve calculated a node&#039;s AABB, we only have to recalculate it when a sphere is deleted whose AABB was &#039;kissing&#039; against the node&#039;s AABB... if it wasn&#039;t, then deleting it has no effect on the AABB. This will become more clear with some descriptive pictures and sourcecode, be patient :)<br /><br />If we&#039;re prepared to add some more pointer variables to each node, we can greatly optimize this operation.<br />We&#039;ll do this by only considering the Origins of our spheres and child boxes (ie, treat everything as a Point in 3D space). For any given node directly containing one or more entities, we&#039;ll keep track which sphere&#039;s origin is furthest to the north, south, east, west, top and bottom of the node&#039;s box, taking into account the radius. This will allow us to more quickly recalculate a node&#039;s box based on knowledge of which contained elements have changed.<br />I&#039;ll definitely be posting a picture of that, because it&#039;s a fundamental optimization that I&#039;ll be implementing.<br /><br />Assuming that we&#039;re able to efficiently manage the growing and shrinking tree of boxes, let&#039;s introduce our first heuristic: we will place a cap on the number of entities that can be stored in a node.<br />If we detect that a node has reached capacity, it will need to be Split, which involves distributing the node&#039;s contents into child nodes. This brings us to our next topic, FRAGMENTATION.<br /><br />It&#039;s not only possible but LIKELY for entities to be added in such a way that it will “fragment” the tree, causing them to be inserted at much deeper levels of the tree than they would if the tree were built<br />containing them to begin with. This also causes the tree as a whole to become imbalanced, since we end up with one branch that is much deeper than the average case. To stop this from occurring, we will allow the AABBs of SIBLINGS (ie the immediate child nodes of a given node) to overlap in 3D space.<br />A good example of this is a situation where we have two spheres that are close to one another and offset diagonally, such that no Major Axis can be used to separate them without intersecting one or both.<br />In this case, we will place each child into the chld box which would grow least to accommodate it, and then grow the box accordingly, and finally alert the Parent node that the child box(es) grew (since the parent may also need to grow as it must CONTAIN all children).<br /><br />I&#039;ll cover the finer points of tree management as the sourcecode is rolled out.<br /><br />Let&#039;s take a look at some of the possible Nesting Heuristics. Although these are named after various kinds of Spatial Partitioning algorithm, we are ONLY using them to determine how and when to split up the nodes of our DAABB tree, so don&#039;t be confused by the names.<br /><br />KDTree<br />This is the one used for traditional AABB trees, it reminds me a lot of a BSPTree heuristic: Given a set of Points (ie our sphere origins), we&#039;ll determine where the midpoint of the Distribution is located, and which of the BoundingBox&#039;s major axes is the longest one... then we&#039;ll determine a theoretical plane whose Normal is that longest axis, and which passes through that midpoint, thus cutting the box into two child boxes.<br />We will then distribute our Spheres into whichever child box contains their origin. Points on the splitting plane can be placed into either child, and most implementations will just use a convention, for example the Front halfspace... we can and should place them with a view to keeping our tree well-balanced, so we&#039;ll make a choice at runtime on that basis.<br /><br />TernaryTree<br />This is just an extension of the previous heuristic: if a Sphere is intersected by (ie straddles) our axial cutting plane (and so rightfully belongs to BOTH halfspaces), we will place it into a THIRD subtree, or alternatively, we can just leave it in the current node. The latter is the technique I chose for previous work with BSP trees. I&#039;ve never personally implemented the &#039;third subtree techique&#039; before now, and it&#039;s still quite unintuitive to me as it makes spatial queries a lot more complex (requiring dual tree walk), whereas simply leaving those objects where they are makes perfect sense and can be walked linearly.<br /><br />Octree<br />This is also an extended KD heuristic: we find the KD midpoint, then we cut the box using all three axial planes passing thru that point, thus we don&#039;t care which axis is &#039;longest&#039; anymore.<br />This cuts the box into eight subspaces, we then distribute our Spheres as per KD.<br /><br />Icoseptree:<br />Wow, what a name, huh? It&#039;s the Octree heuristic, extended with the same logic as a Ternary heuristic.<br />There are now three subtrees for each major axis, and so each (nonleaf) node has a total of 27 subspaces available for distributing our spheres.<br /><br />It is my hope that I have been eloquent rather than simply brief in these descriptions.<br />If you really want to hurt yourself, go study each of these Static tree structures and tell me if I missed anything important.<br /><br />In the next post, I hope to provide some pictures to back up these ideas, and other than that we&#039;re ready to start putting some code together :)<br /><br /></div>
    <div class="meta">Posted on 2010-08-18 00:44:13 by Homer</div>
   </div>
   <div class="post" id="post-212791">
    <div class="subject"><a href="#post-212791">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body">Well I tried, and I&#039;m just a terrible artist so I will just keep moving and if you&#039;re really lucky some images will magically appear in these posts at a later date.<br /><br />I am a really BAD artist, but I can code.<br />So I will show you code instead, since that&#039;s why we&#039;re all here, isn&#039;t it?<br />We need to start somewhere, let&#039;s start with the spine and get this thread moving :)<br /><br /><pre><code><br /><br /><br /><br />; ——————————————————————————————————————————————————————————————————————————————————————————————————<br />;Some constants we&#039;ll reference in our &#039;nesting heuristic&#039;:<br />UNDEFINED	equ -1<br />X_AXIS		equ 0<br />Y_AXIS		equ 1<br />Z_AXIS		equ 2<br />; ——————————————————————————————————————————————————————————————————————————————————————————————————<br /><br /><br />; ——————————————————————————————————————————————————————————————————————————————————————————————————<br />;The BBNode class implements the nodes of a Dynamic Axially-Aligned BoundingBox (DAABB) Tree<br />;which has been optimized specifically to store Sphere entities for BroadPhase collision detection.<br /><br />Object BBNode, 345342, Primer<br />	RedefineMethod Init, Pointer<br />	RedefineMethod Done<br />	<br /><br />	DefineVariable vMin,	Vec3, {&lt;&gt;}			;Current extents of this node&#039;s AABB<br />	DefineVariable vMax,	Vec3, {&lt;&gt;}<br />	DefineVariable vSplit,	Vec3, {&lt;&gt;}			;Point at which the Node was &quot;split&quot; into subnodes<br /><br />	;<br />	Definevariable dAxis,	dword, UNDEFINED<br />	<br />	;We use these pointers to keep track of which spheres are pressing on the sides of the node&#039;s AABB<br />	;This in turn lets us keep track of the dynamic size of an AABB without having to evaluate all of its child spheres.<br />	;Since this optimization is not implemented yet, I will leave these commented out for the moment.<br />;	DefineVariable pFurthestEast,	Pointer<br />;	DefineVariable pFurthestWest,	Pointer<br />;	DefineVariable pFurthestNorth,	Pointer<br />;	DefineVariable pFurthestSouth,	Pointer<br />;	DefineVariable pFurthestDown,	Pointer<br />;	DefineVariable pFurthestUp,		Pointer<br />	<br />	Embed children, Collection		;holds array of child nodes (ie subtrees, branches, as you prefer)<br />	Embed bodies,	Collection		;holds array of RigidBody objects<br />ObjectEnd<br />LPBBNODE typedef ptr BBNode<br /><br />; ——————————————————————————————————————————————————————————————————————————————————————————————————<br />;The BBTree class is mostly just a container for the Root Node of our DAABB tree.<br />;It implements some &quot;entry-level&quot; methods for recursive functions.<br />Object BBTree, 234566, Primer<br />	DefineVariable pRootNode, LPBBNODE, NULL<br />ObjectEnd<br />; ——————————————————————————————————————————————————————————————————————————————————————————————————<br /><br /><br /><br />;Method:	BBNode.Init<br />;Purpose:	Initialize BBNode object<br />;Args:		pOwnerParent -&gt; BBNode which is the immediate parent of this node<br />;Returns:	nothing<br />Method BBNode.Init, uses esi, pOwnerParent<br />	SetObject esi<br />	ACall Init, pOwnerParent<br />	OCall .children::Collection.Init, esi, 16, 256, UNDEFINED<br />	OCall .bodies&nbsp; ::Collection.Init, esi, 16, 256, UNDEFINED<br />MethodEnd<br /><br />;Method:	BBNode.Done<br />;Purpose:	Destroy this node<br />Method BBNode.Done, uses esi<br />	SetObject esi<br />	;Release this node&#039;s resource objects<br />	OCall .children::Collection.Done	;subtrees will be destroyed recursively, this is automated by ObjAsm<br />	OCall .bodies&nbsp; ::Collection.Done<br />MethodEnd<br /><br /></code></pre><br /><br /></div>
    <div class="meta">Posted on 2010-08-18 08:49:14 by Homer</div>
   </div>
   <div class="post" id="post-212972">
    <div class="subject"><a href="#post-212972">Re: Core of DBVH - Choosing a Child during Insertions</a></div>
    <div class="body">I must apologize for the lack of recent posts, it&#039;s not because I&#039;ve lost interest, rather the opposite.<br />There&#039;s no point in blindly surging forward with this, I&#039;ve done mountains of research and studied everything I could lay my hands on related to this work... it&#039;s important stuff !!<br /><br />As mentioned previously, there are quite a number of possible heuristics that we might employ for the purpose of determing If, When and How a Node will be split up into child nodes (subtrees).<br />And there has been quite a LOT of research done into which ones are best under various conditions.<br /><br />The goal of our BVH is to cull pairs of entities which cannot possibly collide during the BroadPhase collision testing, and the benefits of having a broadphase are proportional to the number of entities.<br />IE, with low numbers of entities, there&#039;s almost no point having a BVH at all, this is PURELY about HIGH NUMBERS OF ENTITIES !!! I am determined to beat the Bullet Engine, which already is better and faster than the PhysX engine and others. Bullet implements only a Leafy, Binary Tree using the KD-Tree heuristic, which means that ALL entities end up in the Leaf Nodes, and that any non-leaf node has only TWO subspaces (child nodes) - this can create very deep trees so we end up wasting a LOT of time recursing and adjusting the tree.. think we can do better.<br /><br />Bearing all that in mind, the heuristic which scales best for LOTS of entities is ICOSEPTREE.<br />And so, this is the one that I will be implementing and talking about, I will simply ignore all the others.<br />The Icoseptree divides each Non-Leaf node into 27 subspaces.<br /><br />What follows is perhaps the most important function in our BVH code, the implementation of that heuristic: given a Sphere represented by a Point and Radius, this method must decide which of the 27 subspaces contains our Sphere. Note that this is a Recursive function, it will &quot;Walk the Tree&quot; - at each Node it will make the decision which Child Node (subspace) contains our Sphere entity, and it will then Recurse that node, until it reaches a Leaf Node, or until it reaches a Node whose BoundingBox is quite a lot smaller than the entity... we&#039;ve already said that we are willing to have entities in Non-Leaf nodes, that decision is not arbitrary - we don&#039;t want large entities to be shoved too far down the tree because there&#039;s a high chance that they will straddle multiple subspaces and we would rather they fall neatly into exactly one subspace - we&#039;re trying to avoid &#039;growing&#039; the child nodes to encompass them, because that would force the Parent nodes to expand such that their children don&#039;t violate their bounds.<br />The code provided mentions some Macros which are not provided here since they would only serve to confuse - the comments explain what&#039;s going on - any questions?<br /><br /><pre><code><br />;Method:	BBNode.WhichChild<br />;Purpose:	Determine which Icoseptree Child rightfully owns the given SPHERE (origin, radius)<br />Method BBNode.WhichChild,uses esi, pos, radius:real8<br />LOCAL _c,sv:real8,bv:real8<br />	SetObject esi<br />	<br />	;If this is a Leaf node, we HAVE to leave the sphere here in this node, theres no choice<br />	;We might decide to SPLIT this node, but we sure won&#039;t do it NOW - we&#039;ll defer that decision.<br />	.if !.bIsSplit<br />		return -1<br />	.endif<br />	and _c,0<br /><br />	; If the sphere’s volume is at least 1/8 of this node&#039;s AABB volume<br />	; then we&#039;ll just leave the sphere here in this node.<br /> &nbsp; &nbsp; &nbsp; &nbsp;; I think this should probably be 1/27 , what do you think?<br />	.if .bExtentsAreCorrect ;better only do this when the extents are good<br /><br />		fldpi			;volume of sphere<br />		fmul r4_4<br />		fdiv r4_3<br />		fmul radius<br />		fstp sv			;=4/3 pi r<br />		<br />		fld &nbsp;.vMax.x	;volume of box / 8<br />		fsub .vMin.x<br />		fld &nbsp;.vMax.y<br />		fsub .vMin.y		<br />		fld &nbsp;.vMax.z<br />		fsub .vMin.z<br />		fmul<br />		fmul<br />		fdiv r4_8<br />		fstp bv				;= (length*width*height) / 8<br />		<br />		.if $IsGreater(sv, bv)<br />			return -1		;&quot;leave it here&quot;<br />		.endif<br />	.endif<br /><br />	;ICOSEPTREE CHILD SELECTION:<br />	;The following three tests will yield a value from 0 to 26 inclusive (ie 27 possible values)<br />	;This indicates which Icoseptree Child owns the input sphere<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp;<br />	mov edx,pos<br /><br /> &nbsp; &nbsp; &nbsp; ;We&#039;ll perform tests for each Major Axis...<br /> &nbsp; &nbsp; &nbsp; ;Is the Sphere Origin plus the Radius less than this node&#039;s &#039;split point&#039;<br />	.if $IsAddLess(.Vec3.x, radius, .vSplit.x)<br />		add _c,1<br /> &nbsp; &nbsp; &nbsp; &nbsp;;Otherwise, is Origin minus Radius greater than split point?<br />	.elseif $IsSubGreater(.Vec3.x, radius, .vSplit.x)<br />		add _c,2<br />	.endif<br />	<br />	.if $IsAddLess(.Vec3.y, radius, .vSplit.y)<br />		add _c,3<br />	.elseif $IsSubGreater(.Vec3.y, radius, .vSplit.y)<br />		add _c,6<br />	.endif<br />	<br />	.if $IsAddLess(.Vec3.z, radius, .vSplit.z)<br />		add _c,9<br />	.elseif $IsSubGreater(.Vec3.z, radius, .vSplit.z)<br />		add _c,18<br />	.endif<br /><br />	;Assert that the indicated child index is valid in this node<br />	mov eax,_c<br />	.if eax &gt;= .children.dCount<br />		DbgWarning &quot;Error in BBNode.WhichChild - the indicated child node does not exist&quot;<br />		DbgDec _c,&quot;Icoseptree child index&quot;<br />		;We COULD take this opportunity to create the necessary Child Node,<br />		;but since its NOT a leaf, we expected it to already have been done?<br />		int 3<br />	.endif<br />	<br />MethodEnd<br /></code></pre><br /><br /></div>
    <div class="meta">Posted on 2010-08-27 00:39:33 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=30109&amp;page=1" style="">&laquo;</a><a href="../?id=30109&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="30109" /><input type="number" name="page" min="1" max="4" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=30109&amp;page=3">&gt;</a><a href="../?id=30109&amp;page=4">&raquo;</a></form>  </div>
 </body>
</html>