<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30109" />
  <link rel="prev" href="../?id=30109&amp;page=2" />  <link rel="next" href="../?id=30109&amp;page=4" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=30109">Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=30109&amp;page=1" style="">&laquo;</a><a href="../?id=30109&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="30109" /><input type="number" name="page" min="1" max="4" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=30109&amp;page=4">&gt;</a><a href="../?id=30109&amp;page=4">&raquo;</a></form>   <div class="post" id="post-212996">
    <div class="subject"><a href="#post-212996">Re: Dynamic Trees and Temporal Coherence</a></div>
    <div class="body"><br />The functions in our DAABBTree class can sorta be divided into two categories.<br />The first group are the methods involved with inserting and deleting spheres from the tree.<br />The second group are the methods involved with querying, updating, splitting and fusing the tree.<br /><br />The distinction is made clearer by noting that the tree is only &#039;refined&#039; during actual QUERIES - which means that the tree adapts most quickly in the subspaces which are actively being queried.<br />The assumption is that although the contents of the world may be moving around, the overall structure of the tree doesn&#039;t change a whole lot from one timestep to the next - we are taking advantage of &#039;temporal coherence&#039; :)<br /><br />So when we add spheres to the tree (or delete them), we won&#039;t actually modify the structure of the tree, we&#039;ll instead mark one or more nodes for recalculation / refinements, which will only occur when they are reached during actual queries of the tree :)<br /><br /></div>
    <div class="meta">Posted on 2010-08-28 22:47:54 by Homer</div>
   </div>
   <div class="post" id="post-212997">
    <div class="subject"><a href="#post-212997">Re: BBNode is serving two purposes</a></div>
    <div class="body">Also, we&#039;ll be using our BBNode object in two ways.. one is for the structure of the tree, and the other is purely as a container for a single RigidBody... that is to say, we are going to wrap each RigidBody in a BBNode which is not part of the tree structure itself... we have structural nodes (the children), and we have entity nodes (the bodies).<br /><br />When we add a RigidBody to the Simulator, we&#039;ll calculate its boundingsphere, create a BBNode representing that boundingsphere, and then use one of our BBTree entry-level methods to add that &#039;body node&#039; to the Simulator&#039;s DAABBTree.<br /><br />Any structural node can hold any number of bodies.<br />The &#039;body nodes&#039; can and will move around the tree dynamically when the tree is queried.<br />This in turn causes the tree to alter its structure - &nbsp;in the queried subtrees, when they are queried.<br /><br />Our BroadPhase Collision Test will be to walk our theoretical spheres down the tree, performing a sphere-sphere sweep test against any BodySphere nodes encountered during that traversal, and recording potential-collision records for any &quot;intersecting time-capsules&quot; (extruded sphere-pairs).<br /><br />Attached is the more-or-less final version of the headers for the BBTree and BBNode classes.<br />I&#039;ll be posting all the code over the following few posts :)<br /><br /><br /><pre><code><br />; ——————————————————————————————————————————————————————————————————————————————————————————————————<br />UNDEFINED			equ -1<br />WEIGHTED_BY_RADII	equ TRUE	;See DoSplit method<br />.data<br />SPLITVAL 			dd 50		;Best value for icoseptree according to some guys sphere-based research model<br />.code<br /><br />; ——————————————————————————————————————————————————————————————————————————————————————————————————<br />;The BBNode class implements the nodes of a Dynamic Axially-Aligned BoundingBox (DAABB) Tree<br />;which has been optimized specifically to store Sphere entities for BroadPhase collision detection.<br /><br />Object BBNode, 345342, Primer<br />	RedefineMethod	Init, 		Pointer<br />	RedefineMethod	Done<br />	StaticMethod	DoSplit									;Partition a Node<br />	StaticMethod	Contains,	Pointer, Pointer			;Test if a Node&#039;s AABB encloses a given Box<br />	StaticMethod	FindNode,	Pointer, real8				;Find the node who should parent a given Sphere<br />	StaticMethod	GetExtents, Pointer, Pointer, BOOL		;Get Node&#039;s AABB, recalculating it if necessary<br />	StaticMethod	GrowExtents,Pointer, Pointer			;Grow Node&#039;s AABB to enclose given Box <br />	StaticMethod	ShrinkExtents,Pointer,real8				;Shrink Node&#039;s AABB to discard given Sphere<br />	StaticMethod	InsertNode,	Pointer						;Attach a Body-bearing Node<br />	StaticMethod	RemoveChild, Pointer					;Remove given Child Node<br />	StaticMethod	RemoveNode,	Pointer, Pointer, real8		;Detach a Body-bearing Node<br />	StaticMethod	TestSuicide								;Check if node can be destroyed<br />	StaticMethod	WhichChild,	Pointer, real8				;Choose a subspace for given sphere<br />	StaticMethod	Unsplit									;Fuse node&#039;s subspaces<br />	StaticMethod	UpdateExtents							;Recalculate node&#039;s AABB<br />	StaticMethod	UpdateNode,	Pointer, real8				;Physics calls this when entity position changed<br /><br />	DefineVariable bIsSplit,BOOL, FALSE				;Indicates whether this node&#039;s AABB has been subdivided<br />	DefineVariable bExtentsAreCorrect,BOOL,FALSE	;Indicates whether this node&#039;s AABB size has changed<br />	DefineVariable vMin,	Vec3, {&lt;&gt;}				;Current extents of this node&#039;s AABB<br />	DefineVariable vMax,	Vec3, {&lt;&gt;}				;	&quot;		&quot;		&quot;		&quot;		&quot;<br />	DefineVariable vPos,	Vec3, {&lt;&gt;}				;Current Origin of this node&#039;s AABB (midpoint of its Extents)<br />	DefineVariable vSplit,	Vec3, {&lt;&gt;}				;&#039;Weighted MidPoint&#039; at which the Node&#039;s AABB was &quot;split&quot; into subspaces<br />	DefineVariable fRadius, real8, 1.0e-12				;Half-Width of this Node&#039;s AABB, or Radius of Entity BoundingSphere<br />	<br />	DefineVariable children,Pointer, 27 dup &lt;(NULL)&gt; &nbsp;;array of ptrs to child nodes (ie subtrees, branches, as you prefer)<br />	DefineVariable childcount, dword, 27<br />	DefineVariable pRigidBody,Pointer,NULL			;Special pointer to my entity class, not referenced by this class<br />	Embed bodies,	Collection		;holds array of BoundingSphere Nodes<br />	<br />ObjectEnd<br />LPBBNODE typedef ptr BBNode<br /><br />; ——————————————————————————————————————————————————————————————————————————————————————————————————<br />;The BBTree class is mostly just a container for the Root Node of our DAABB tree.<br />;It implements some &quot;entry-level&quot; methods for recursive functions.<br />Object BBTree, 234566, Primer<br />	RedefineMethod &nbsp;	Init, 		Pointer<br />	RedefineMethod		Done<br />	StaticMethod		AddNode,		Pointer<br />	StaticMethod		SubtractNode,	Pointer<br />	Private<br />		StaticMethod	FindNode,		Pointer<br />		Embed		RootNode, 		BBNode<br />	PrivateEnd<br />ObjectEnd<br /></code></pre><br /></div>
    <div class="meta">Posted on 2010-08-29 00:50:44 by Homer</div>
   </div>
   <div class="post" id="post-212998">
    <div class="subject"><a href="#post-212998">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body"><br />As you can see, each of these classes contains one embedded class object of another kind.<br /><br />BBTree contains an embedded BBNode as its Root Node - our tree will always contain at least one valid node, even if it contains no bodies. BBNode contains an embedded Collection used to store the &#039;body nodes&#039;.. remember that our tree can store those at any structural node! For non-structural nodes (where pRigidBody is not NULL) we simply don&#039;t initialize the &#039;bodies&#039; collection.<br /><br />ObjAsm requires that we initialize and finalize any Embedded objects ourselves.<br />You&#039;ll see how I do that in the following Constructor / Destructor methods:<br /><br /><pre><code><br />Method BBTree.Init, uses esi, pOwner<br />	SetObject esi<br />	ACall Init, pOwner<br />	OCall .RootNode::BBNode.Init, NULL<br />MethodEnd<br /><br />Method BBTree.Done<br />	SetObject EDX<br />	OCall .RootNode::BBNode.Done<br />MethodEnd<br /><br />; ——————————————————————————————————————————————————————————————————————————————————————————————————<br />;Method:	BBNode.Init<br />;Purpose:	Initialize BBNode object<br />;Args:		pOwnerParent -&gt; BBNode which is the immediate parent of this node<br />;Returns:	nothing<br />Method BBNode.Init, uses esi, pOwnerParent<br />	SetObject esi<br />	;Set the Parent (Owner) pointer, this is important for us to be able to &quot;walk up the tree&quot;<br />	ACall Init, pOwnerParent<br />	;We won&#039;t initialize Child storage yet ..<br />	;We will prepare the node for holding any amount of local entities<br />	.if .bodies.pItems==0 &amp;&amp; .pRigidBody==0<br />		OCall .bodies&nbsp; ::Collection.Init, esi, 16, 256, UNDEFINED<br />	.endif<br />	OCall esi.Unsplit<br />MethodEnd<br /><br />;Method:	BBNode.Done<br />;Purpose:	Destroy this node, its contents, its subtrees, etc<br />Method BBNode.Done, uses esi edi ebx<br />	SetObject esi<br />	;Release this node&#039;s resource objects<br />	xor ebx,ebx<br />	lea edi, .children<br />	.while ebx&lt;27<br />		mov eax,dword ptr<br />		mov dword ptr,0<br />		.if eax!=0<br />			Destroy eax	;subtrees will be destroyed recursively, this is automated by ObjAsm<br />		.endif<br />		inc ebx<br />	.endw<br />	OCall .bodies&nbsp; ::Collection.Done<br />MethodEnd<br /><br /></code></pre><br /></div>
    <div class="meta">Posted on 2010-08-29 01:13:10 by Homer</div>
   </div>
   <div class="post" id="post-212999">
    <div class="subject"><a href="#post-212999">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body">Attached are the handful of remaining BBTree methods.<br />We can think of these as our &#039;external interface methods&#039; - these are the ones that our application (or in our case, the Simulator) will be most likely to deal with.<br /><br />AddNode is used to add new &#039;body nodes&#039; to the Tree.<br />SubtractNode is used to remove them.<br />FindNode is the most interesting - unfortunately, we can see that it just calls into a BBNode method of the same name, and in the context of the Root Node.. we&#039;ll have to wait to see what&#039;s in there.<br /><br />The BBTree class can be seen not just as a container for the root node, but also as a kind of &#039;black box&#039; to hide the complexities of the BBNode class from the user.<br /><br /><pre><code><br />; ——————————————————————————————————————————————————————————————————————————————————————————————————<br /><br />;Method:	BBTree.AddNode<br />;Purpose:	TopLevel EntryPoint for inserting a new Sphere into the DAABB tree<br />;Args:		pNode -&gt; BBNode containing valid vPos and fRadius fields describing a BoundingSphere<br />;Remarks:	Only need to set up Radius and Position (and pRigidBody), everything else is done for you.<br />Method BBTree.AddNode,uses esi ebx,pNode <br />local posMax:Vec3<br />LOCAL posMin:Vec3<br /><br />	SetObject esi<br />	<br />	;Find the Node which rightfully should be the Parent of the given Node,<br />	;noting that the given Node typically contains only a single Sphere<br />	mov esi,$OCall(esi.FindNode,pNode)<br />	.if eax==0<br />		DbgWarning &quot;Error - failed to find Node&quot;<br />		DbgHex pNode<br />		int 3<br />	.endif<br />	;ReParent the Node<br />	mov edx,pNode<br />	mov .BBNode.pOwner,esi<br /><br />	;Attach the input Node to the appropriate Parent Node<br />	OCall esi::BBNode.InsertNode,pNode<br /><br />	;Calculate the axial minima and maxima which describe<br />	;the tightest fitting AABB that encloses the given sphere<br />	mov edx,pNode<br />	<br />	fld &nbsp;.BBNode.vPos.x<br />	fadd .BBNode.fRadius<br />	fstp .BBNode.vMax.x<br />	fld &nbsp;.BBNode.vPos.y<br />	fadd .BBNode.fRadius<br />	fstp .BBNode.vMax.y<br />	fld &nbsp;.BBNode.vPos.z<br />	fadd .BBNode.fRadius<br />	fstp .BBNode.vMax.z<br />	<br />	fld &nbsp;.BBNode.vPos.x<br />	fsub .BBNode.fRadius<br />	fstp .BBNode.vMin.x<br />	fld &nbsp;.BBNode.vPos.y<br />	fsub .BBNode.fRadius<br />	fstp .BBNode.vMin.y<br />	fld &nbsp;.BBNode.vPos.z<br />	fsub .BBNode.fRadius<br />	fstp .BBNode.vMin.z<br /><br />	;Make sure that the Parent node encloses this new AABB<br />	OCall esi::BBNode.GrowExtents,addr .BBNode.vMin,addr .BBNode.vMax<br />	<br />	;Return the Parent which received the input Node<br />	mov eax, esi<br />MethodEnd<br /><br />;Method:	BBTree.SubtractNode<br />;Purpose:	TopLevel EntryPoint for deleting a Sphere completely from the DAABB tree<br />;Args:		pNode -&gt; BBNode representing Sphere to be Destroyed<br />;Remarks:	This method eliminates a BoundingSphere (body) node from the Tree<br />Method BBTree.SubtractNode,uses esi , pNode<br />	;Determine the Parent which owns the given Node<br />	mov edx,pNode	<br />	.if .BBNode.pOwner!=0<br />		mov esi,.BBNode.pOwner<br />	.else<br />		SetObject esi<br />		mov esi,$OCall (esi.FindNode,pNode)<br />	.endif<br />	;Remove the given Node from its Parent<br />	OCall esi::BBNode.RemoveNode, pNode, addr .BBNode.vPos, .BBNode.fRadius<br />	;Trash the given node<br />	Destroy pNode<br />MethodEnd<br /><br />;Method:	BBTree.FindNode<br />;Purpose:	TopLevel Entrypoint to determine which node should receive the given node<br />;Args:		pNode -&gt; BBNode (which is a container for a single Sphere)<br />;Returns:	EAX -&gt; BBNode which rightfully contains pNode, or NULL = bad args<br />Method BBTree.FindNode, uses esi, pNode<br />	SetObject esi<br />	mov edx,pNode<br />	.if edx!=0<br />		OCall .RootNode::BBNode.FindNode,addr .BBNode.vPos, .BBNode.fRadius<br />	.else<br />		mov eax,edx<br />	.endif<br />MethodEnd<br /><br /></code></pre><br /></div>
    <div class="meta">Posted on 2010-08-29 01:56:34 by Homer</div>
   </div>
   <div class="post" id="post-213000">
    <div class="subject"><a href="#post-213000">Re: Heuristic-Guided Depth-Traversal of Tree</a></div>
    <div class="body">Now we can get to the good stuff in the BBNode class...<br /><br />The InsertNode method is used to attach an orphan &#039;body node&#039; to a parent &#039;structural node&#039;... pretty straightforward.<br /><br />The FindNode method is a very good example of LINEAR RECURSION aka &#039;TRAVERSAL&#039;.<br />We will perform a heuristic-guided search into the depths of the Tree, &#039;depth-walking&#039; the structural nodes, until we find a Node which represents the best-fitting Parent for the given Theoretical Sphere.<br />Note that our BoundingTree is thus formed according to our volume-based heuristic, implemented in the WhichChild method (the very first one I showed you).<br />However that was a lot of changes ago so I&#039;ll update that method in my next post.<br /><br /><pre><code><br />;Method:	BBNode.InsertNode<br />;Purpose:	Attach the input SphereNode to this Parent structural node<br />Method BBNode.InsertNode,uses esi,pNode<br />	SetObject esi<br />	OCall .bodies::Collection.Insert,pNode<br />	OCall pNode::BBNode.Init, esi	;Set the input Node&#039;s Parent<br />MethodEnd<br /><br />;Method:	BBNode.FindNode<br />;Purpose:	Recursive function to search for the structural node which rightfully should own the given Sphere<br />Method BBNode.FindNode,uses esi ebx, pos, r:real8<br />	SetObject esi<br />	mov ebx,$OCall(esi.WhichChild,pos, r)<br />	.while ebx &gt;= 0 &amp;&amp; .children!=0<br />		mov esi,.children<br />		mov ebx,$OCall(esi.WhichChild,pos, r)<br />	.endw<br />	mov eax,esi<br />MethodEnd<br /></code></pre></div>
    <div class="meta">Posted on 2010-08-29 02:24:31 by Homer</div>
   </div>
   <div class="post" id="post-213008">
    <div class="subject"><a href="#post-213008">Re: Icoseptree Heuristic</a></div>
    <div class="body">Attached is the revised BBNode.WhichChild method, and a bunch of math macros that I wrote as helpers for this and several other methods in this class. It implements the Icoseptree heuristic.<br /><br /><pre><code><br />;Is val1-valsub &lt;= val2 ???<br />$IsSubLessEq macro val1:req, valsub:req, val2:req<br /> &nbsp; &nbsp;local @@1, @@2<br /> &nbsp; &nbsp;fld val1<br /> &nbsp; &nbsp;fsub valsub<br /> &nbsp; &nbsp;fcomp val2<br /> &nbsp; &nbsp;fjg @@1<br /> &nbsp; &nbsp;mov eax, TRUE<br /> &nbsp; &nbsp;jmp @@2<br />@@1:<br /> &nbsp; &nbsp;xor eax, eax<br />@@2:<br /> &nbsp; &nbsp;exitm &lt;eax&gt;<br />endm<br /><br />;Is val1-valsub &lt; val2 ???<br />$IsSubLess macro val1:req, valsub:req, val2:req<br /> &nbsp; &nbsp;local @@1, @@2<br /> &nbsp; &nbsp;fld val1<br /> &nbsp; &nbsp;fsub valsub<br /> &nbsp; &nbsp;fcomp val2<br /> &nbsp; &nbsp;fjge @@1<br /> &nbsp; &nbsp;mov eax, TRUE<br /> &nbsp; &nbsp;jmp @@2<br />@@1:<br /> &nbsp; &nbsp;xor eax, eax<br />@@2:<br /> &nbsp; &nbsp;exitm &lt;eax&gt;<br />endm<br /><br />;Is val1+valsub &lt; val2 ???<br />$IsAddLess macro val1:req, valsub:req, val2:req<br /> &nbsp; &nbsp;local @@1, @@2<br /> &nbsp; &nbsp;fld val1<br /> &nbsp; &nbsp;fadd valsub<br /> &nbsp; &nbsp;fcomp val2<br /> &nbsp; &nbsp;fjge @@1<br /> &nbsp; &nbsp;mov eax, TRUE<br /> &nbsp; &nbsp;jmp @@2<br />@@1:<br /> &nbsp; &nbsp;xor eax, eax<br />@@2:<br /> &nbsp; &nbsp;exitm &lt;eax&gt;<br />endm<br /><br />;Is val1+valadd &gt;= val2 ???<br />$IsAddGreaterEq macro val1:req, valadd:req, val2:req<br /> &nbsp; &nbsp;local @@1, @@2<br /> &nbsp; &nbsp;fld val1<br /> &nbsp; &nbsp;fadd valadd<br /> &nbsp; &nbsp;fcomp val2<br /> &nbsp; &nbsp;fjl @@1<br /> &nbsp; &nbsp;mov eax, TRUE<br /> &nbsp; &nbsp;jmp @@2<br />@@1:<br /> &nbsp; &nbsp;xor eax, eax<br />@@2:<br /> &nbsp; &nbsp;exitm &lt;eax&gt;<br />endm<br /><br />;Is val1+valadd &gt; val2 ???<br />$IsAddGreater macro val1:req, valadd:req, val2:req<br /> &nbsp; &nbsp;local @@1, @@2<br /> &nbsp; &nbsp;fld val1<br /> &nbsp; &nbsp;fadd valadd<br /> &nbsp; &nbsp;fcomp val2<br /> &nbsp; &nbsp;fjle @@1<br /> &nbsp; &nbsp;mov eax,TRUE<br /> &nbsp; &nbsp;jmp @@2<br />@@1:<br /> &nbsp; &nbsp;xor eax, eax<br />@@2:<br /> &nbsp; &nbsp;exitm &lt;eax&gt;<br />endm<br /><br />;Is val1-valsub &gt; val2 ???<br />$IsSubGreater macro val1:req, valsub:req, val2:req<br /> &nbsp; &nbsp;local @@1, @@2<br /> &nbsp; &nbsp;fld val1<br /> &nbsp; &nbsp;fsub valsub<br /> &nbsp; &nbsp;fcomp val2<br /> &nbsp; &nbsp;fjle @@1<br /> &nbsp; &nbsp;mov eax,TRUE<br /> &nbsp; &nbsp;jmp @@2<br />@@1:<br /> &nbsp; &nbsp;xor eax, eax<br />@@2:<br /> &nbsp; &nbsp;exitm &lt;eax&gt;<br />endm<br /><br />MakeMin macro output,f1,f2<br />	fMin f1,f2<br />	fstp output<br />endm<br /><br />MakeMax macro output,f1,f2<br />	fMax f1,f2<br />	fstp output<br />endm<br />;——————————————————————————————————————————————————————————————————————————————————————————————————<br />;——————————————————————————————————————————————————————————————————————————————————————————————————<br />;Method:	BBNode.WhichChild<br />;Purpose:	Determine which Icoseptree Child rightfully owns the given SPHERE (origin, radius)<br />Method BBNode.WhichChild,uses esi, pos, radius:real8<br />LOCAL _c,sv:real8,bv:real8<br />	SetObject esi<br />	<br />	;If this is a Leaf node, we HAVE to leave the sphere here in this node, theres no choice<br />	;We might decide to SPLIT this node, but we sure won&#039;t do it NOW - we&#039;ll defer that decision.<br />	.if !.bIsSplit<br />		return -1<br />	.endif<br />	and _c,0<br /><br />	; If the sphere’s volume is at least 1/8 of this node&#039;s AABB volume<br />	; then we&#039;ll just leave the sphere here in this node<br />	.if .bExtentsAreCorrect ;better only do this when the extents are good<br /><br />		fldpi			;volume of sphere<br />		fmul r4_4<br />		fdiv r4_3<br />		fmul radius<br />		fstp sv			;=4/3 pi r<br />		<br />		fld&nbsp; .vMax.x	;volume of box / 8<br />		fsub .vMin.x<br />		fld&nbsp; .vMax.y<br />		fsub .vMin.y		<br />		fld&nbsp; .vMax.z<br />		fsub .vMin.z<br />		fmul<br />		fmul<br />		fdiv r4_8<br />		fstp bv				;= (length*width*height) / 8<br />		<br />		.if $IsGreater(sv, bv)<br />			return -1		;&quot;leave it here&quot;<br />		.endif<br />	.endif<br /><br />	;ICOSEPTREE CHILD SELECTION:<br />	;The following three tests will yield a value from 0 to 26 inclusive (ie 27 possible values)<br />	;This indicates which Icoseptree Child owns the input sphere<br />	mov edx,pos<br />	.if $IsAddLess(.Vec3.x, radius, .vSplit.x)<br />		add _c,1<br />	.else<br />		.if $IsSubGreater(.Vec3.x, radius, .vSplit.x)<br />			add _c,2<br />		.endif<br />	.endif<br />	<br />	.if $IsAddLess(.Vec3.y, radius, .vSplit.y)<br />		add _c,3<br />	.else<br />		.if $IsSubGreater(.Vec3.y, radius, .vSplit.y)<br />			add _c,6<br />		.endif<br />	.endif<br />	<br />	.if $IsAddLess(.Vec3.z, radius, .vSplit.z)<br />		add _c,9<br />	.else<br />		.if $IsSubGreater(.Vec3.z, radius, .vSplit.z)<br />			add _c,18<br />		.endif<br />	.endif<br /><br />	;Assert that the indicated child index is valid in this node<br />	mov eax,_c<br />	.if .children==0<br />		DbgWarning &quot;Error in BBNode.WhichChild - the indicated child node does not exist&quot;<br />		DbgDec _c,&quot;Icoseptree child index&quot;<br />		;We COULD take this opportunity to create the necessary Child Node,<br />		;but since its NOT a leaf, we expected it to already have been done?<br />		int 3<br />	.endif<br />	<br />MethodEnd<br /></code></pre></div>
    <div class="meta">Posted on 2010-08-30 03:52:52 by Homer</div>
   </div>
   <div class="post" id="post-213009">
    <div class="subject"><a href="#post-213009">Re: Detaching a BoundingSphere from a BBNode</a></div>
    <div class="body">The first thing we&#039;ll look at is detaching a BoundingSphere node from a structural node.<br />It may not seem intuitive that we&#039;re starting here, but it is the most simple function and can be understood without much context (I think). <br /><br />RemoveNode detaches a given BoundingSphere node from the Tree, but it does not destroy the object.<br />This method is used later to manage the dynamic tree. It makes a call to another method called ShrinkExtents. This method&#039;s name is deceiving - it doesn&#039;t really shrink anything - it checks whether the given sphere is violating the bounds of the current node&#039;s AABB (box), and if so, it simply marks the node for future recalculation, and then heads UP to its Parent node and repeats the process, until it runs out of Parent nodes, or finds a node which encloses the sphere.<br /><br />Note that we don&#039;t actually correct the extents of the nodes we visited here, any modifications to the tree are deferred until the tree is Queried, as we shall see.<br /><br /><pre><code><br />;Method:	BBNode.RemoveNode<br />;Purpose:	Detach (not destroy) given &#039;bodynode&#039; from THIS Parent node<br />;Args:	pNode -&gt; BoundingSphere Node <br />;Returns:	EAX = pNode<br />Method BBNode.RemoveNode,uses esi, pNode<br />	SetObject esi<br />	;Check if we can reduce the size of this node (and if so , also its parents)<br />	;Such nodes will be MARKED for resizing, but we won&#039;t do it now...<br />	mov edx,pNode<br />	OCall esi.ShrinkExtents,addr .BBNode.vPos, .BBNode.fRadius<br />	OCall .bodies::Collection.Delete,pNode<br />	;Check if we can destroy this node<br />	OCall esi.TestSuicide<br />	mov eax, pNode<br />MethodEnd<br /><br />;Check if the given Sphere violates this structural node&#039;s AABB.<br />;If so, mark the node for recalc, and check its parent node(s) as well.<br />;We will break as soon as we find a parent node that hasn&#039;t been violated, <br />;or we reached the Tree&#039;s root node (since it has no parent to check).<br />Method BBNode.ShrinkExtents,uses esi,pvPos, r:real8<br />	SetObject esi<br />	mov edx,pvPos<br />	.while esi!=0<br />		;Break if sphere is totally inside aabb<br />		.if $IsSubGreater(.Vec3.x,r,.vMin.x)<br />			.if $IsSubGreater(.Vec3.y,r,.vMin.y)<br />				 .if $IsSubGreater(.Vec3.z,r,.vMin.z)<br />					 .if $IsAddLess(.Vec3.x,r,.vMax.x)<br />						 .if $IsAddLess(.Vec3.y,r,.vMax.y)<br />							.break .if $IsAddLess(.Vec3.z,r,.vMax.z)<br />						 .endif<br />					 .endif<br />				 .endif<br />			.endif<br />		.endif<br />		;#sphere is violating aabb<br />		mov .bExtentsAreCorrect, FALSE<br />		mov esi,.pOwner	<br />	.endw<br />MethodEnd<br /></code></pre><br /></div>
    <div class="meta">Posted on 2010-08-30 06:02:49 by Homer</div>
   </div>
   <div class="post" id="post-213010">
    <div class="subject"><a href="#post-213010">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body">Here&#039;s the flip-side to the previous post: the GrowExtents method is called during Queries to grow the AABB of structural nodes which have been tagged for recalculation.<br />The AABB is grown such that it encloses a given Box specified by a pair of min/max Points.<br />Like previously, this method walks to its Parent and repeats this process until we reach a node whose AABB is valid (and needs no recalculating), or we reach the root node.<br /><br />Below it is the TestSuicide method.<br />This is a garbage-collection method which is called to check whether a structural node is devoid of content and so can be destroyed.<br /><br /><pre><code><br />;If the current node is marked for recalc, enlarge it<br />;to enclose the given box extents (lo, hi) and check Parents<br />;Note that we at NO POINT mark the node as having Corrected Extents -<br />;We leave it marked &#039;uncorrect&#039; until it is next Updated (ie, when Queried).<br />Method BBNode.GrowExtents,uses esi,lo,hi<br />	SetObject esi<br />	.while esi!=0 &amp;&amp; !.bExtentsAreCorrect<br />		mov edx,lo<br />		MakeMin .vMin.x, .vMin.x, .Vec3.x<br />		MakeMin .vMin.y, .vMin.y, .Vec3.y<br />		MakeMin .vMin.z, .vMin.z, .Vec3.z<br />		mov edx,hi<br />		MakeMax .vMax.x, .vMax.x, .Vec3.x<br />		MakeMax .vMax.y, .vMax.y, .Vec3.y<br />		MakeMax .vMax.z, .vMax.z, .Vec3.z<br />		mov esi,.pOwner	<br />	.endw<br />MethodEnd<br /><br /><br />;Method:	BBNode.TestSuicide<br />;Purpose:	Check if this node is ready to go byebye<br />Method BBNode.TestSuicide,uses esi ebx<br />	SetObject esi<br />	.if .pOwner!=0 &amp;&amp; .bodies.dCount==0 &amp;&amp; .childcount==0<br />		OCall .pOwner::BBNode.RemoveChild,esi	;Destroy this node from parent context<br />		Destroy esi<br />	.endif<br />MethodEnd<br /></code></pre><br /></div>
    <div class="meta">Posted on 2010-08-30 06:30:51 by Homer</div>
   </div>
   <div class="post" id="post-213012">
    <div class="subject"><a href="#post-213012">Re: Removing and Unsplitting Structural Nodes</a></div>
    <div class="body">Since the tree is dynamic, occasionally we&#039;ll want to destroy Structural nodes that have become redundant. The BBNode.RemoveChild method is responsible for deleting a structural node&#039;s reference from &#039;this&#039; parent node, and then actually destroying it.<br />If RemoveChild causes the number of Child Nodes falls to zero, it calls the Unsplit method, which will mark the node as being a Leaf, and attempt to redistribute any BoundingSpheres it contains. Finally it will perform a Suicide check.<br />We might say that these methods are responsible for dynamically collapsing the tree structure.<br /><br /><pre><code><br />;Method:	BBNode.RemoveChild<br />;Purpose:	Remove given Child Node from this Parent Node<br />Method BBNode.RemoveChild,uses esi ebx, foo<br />LOCAL unsplit:BOOL<br />	SetObject esi<br />	;If this Node contains the given Child, dispose of that child <br />	xor ebx,ebx<br />	mov edx,foo<br />	.while ebx&lt;27	<br />		.if .children==edx<br />			mov .children,0<br />			dec .childcount<br />			Destroy edx<br />			;If the count of children falls to zero, Unsplit this Node<br />			.if .childcount==0<br />				OCall esi.Unsplit<br />			.endif<br />			.break<br />		.endif<br />		inc ebx<br />	.endw<br />	<br />	;If this Node has become empty and useless, destroy it<br />	OCall esi.TestSuicide<br />MethodEnd<br /><br />;Method:	BBNode.Unsplit<br />;Purpose:	Make this node into a Leaf by trashing its subtrees and marking it as unsplit.<br />;			If the node contains any BoundingSpheres, throw them at the Parent Node<br />;			They could land back in here, that is legal.<br />Method BBNode.Unsplit,uses esi ebx<br />	SetObject esi<br />	;Mark this Node as &#039;UNSPLIT&#039;<br />	mov .bIsSplit,FALSE<br />	;If it is NOT the root node,<br />	.if .pOwner!=0<br />		;If this Node contains any &#039;bodies&#039;, detach them and throw them at this node&#039;s parent<br />		;They could very well fall back into this Node !!<br />		xor ebx,ebx<br />		.while ebx&lt;.bodies.dCount<br />			;Grab the first available element from the list<br />			mov edx,$OCall (.bodies::Collection.DeleteAt,0)<br />			;Detach it (preserve on stack momentarily)<br />			push $OCall (esi.RemoveNode, edx)<br />			;Find the Node which rightfully owns it<br />			mov edx,eax<br />			OCall .pOwner::BBNode.FindNode,addr .BBNode.vPos,.BBNode.fRadius<br />			;Reattach it to its rightful owner<br />			pop edx ;(restore from stack)<br />			OCall eax::BBNode.InsertNode,edx<br />			inc ebx<br />		.endw<br />	.endif<br />MethodEnd<br /><br /></code></pre><br /></div>
    <div class="meta">Posted on 2010-08-30 09:02:37 by Homer</div>
   </div>
   <div class="post" id="post-213019">
    <div class="subject"><a href="#post-213019">Re: Queries cause subtrees to be re-evaluated</a></div>
    <div class="body">We&#039;re now ready to look at methods which Query and Update the tree.<br />The BBNode.Contains method checks whether a given Box Extents are completely enclosed by the current node&#039;s AABB.<br />The BBNode.Intersects method is quite similar - it tests whether a given box is (partly or completely) overlapping the current node&#039;s AABB, or whether they are separated by some distance.<br />Both of these methods call the GetExtents method. Calling this method can trigger a cascading recalculation of the AABB&#039;s of nodes marked as &#039;invalid&#039; - we&#039;ll see that in the next post ;)<br /><br /><br /><pre><code><br />;Method:	BBNode.Contains<br />;Purpose:	Determine if the given &#039;Box Extents&#039; are within the bounds of the this Node&#039;s box<br />;Args:		minp -&gt; Vec3 minima <br />;			maxp -&gt; Vec3 maxima<br />;Returns:	TRUE / FALSE<br />Method BBNode.Contains,uses esi,minp, maxp<br />LOCAL min:Vec3, max:Vec3<br />	SetObject esi<br />	;Query the extents of this Node&#039;s AABB<br />	;This can trigger recalculation and splitting<br />	OCall esi.GetExtents,addr min, addr max, TRUE<br />	mov edx,minp<br />	.if $IsGreaterOrEqual(.Vec3.x, min.x)<br />	.if $IsGreaterOrEqual(.Vec3.y, min.y)<br />	.if $IsGreaterOrEqual(.Vec3.z, min.z)<br />		mov edx,maxp<br />		.if $IsLessOrEqual(.Vec3.x, max.x)<br />		.if $IsLessOrEqual(.Vec3.y, max.y)<br />		.if $IsLessOrEqual(.Vec3.z, max.z)<br />			return TRUE<br />		.endif<br />		.endif<br />		.endif<br />	.endif<br />	.endif<br />	.endif<br />	xor eax,eax		;FALSE<br />MethodEnd<br /><br />;Method:	BBNode.Intersects<br />;Purpose:	Determine if the given &#039;Box Extents&#039; intersects (ie overlaps or is inside) the bounds of the this Node&#039;s box<br />;Args:		minp -&gt; Vec3 minima <br />;			maxp -&gt; Vec3 maxima<br />;Returns:	TRUE / FALSE<br />Method BBNode.Intersects,uses esi,minp, maxp<br />LOCAL min:Vec3, max:Vec3<br />	SetObject esi<br />	;Query the extents of this Node&#039;s AABB<br />	;This can trigger recalculation and splitting<br />	OCall esi.GetExtents,addr min, addr max, TRUE<br />	mov edx,maxp<br />	.if $IsGreaterOrEqual(min.x,.Vec3.x)			;Is given box maxima &gt;= node AABB minima?<br />	.if $IsGreaterOrEqual(min.y,.Vec3.y)<br />	.if $IsGreaterOrEqual(min.z,.Vec3.z)<br />		mov edx,minp<br />		.if $IsLessOrEqual(.Vec3.x, max.x)			;Is given box minima &lt;= node AABB maxima?<br />		.if $IsLessOrEqual(.Vec3.y, max.y)<br />		.if $IsLessOrEqual(.Vec3.z, max.z)<br />			return TRUE									;Box is intersecting the AABB<br />		.endif<br />		.endif<br />		.endif<br />	.endif<br />	.endif<br />	.endif<br />	xor eax,eax		;FALSE<br />MethodEnd<br /><br />;Method:	BBNode.GetExtents<br />;Purpose:	Return the extents of this node&#039;s AABB,<br />;Args:		minp -&gt; Vec3 to store minima<br />;			maxp -&gt; Vec3 to store maxima<br />;			split : Boolean - Indicates whether or not to split nodes during the operation<br />;Remaarks:	This is a QUERY method, and triggers a cascading recalculation on demand.<br />Method BBNode.GetExtents,uses esi,minp, maxp,&nbsp; split:BOOL<br />	SetObject esi<br />	.if&nbsp; !.bExtentsAreCorrect<br />		OCall esi.UpdateExtents<br />	.endif<br />	mov edx,SPLITVAL<br />	.if split &amp;&amp; !.bIsSplit &amp;&amp; .bodies.dCount &gt;= edx<br />		OCall esi.DoSplit<br />	.endif<br />	mov edx,minp<br />	fld .vMin.x<br />	fld .vMin.y<br />	fld .vMin.z<br />	fstp .Vec3.z<br />	fstp .Vec3.y<br />	fstp .Vec3.x<br />	mov edx,maxp<br />	fld .vMax.x<br />	fld .vMax.y<br />	fld .vMax.z<br />	fstp .Vec3.z<br />	fstp .Vec3.y<br />	fstp .Vec3.x<br />MethodEnd<br /><br /></code></pre><br /></div>
    <div class="meta">Posted on 2010-08-31 01:44:15 by Homer</div>
   </div>
   <div class="post" id="post-213020">
    <div class="subject"><a href="#post-213020">Re: Splitting and Updating the DAABBTree</a></div>
    <div class="body">Here&#039;s the last few methods for the querying/updating of the DAABBTree - but I&#039;m not done.<br />The next post will add a few new methods which are specific to Collision Detection :)<br /><br /><br /><br /><br />The BBNode.UpdateExtents method is called by the GetExtents method to recalculate an &#039;invalidated&#039; Structural node&#039;s AABB, and set it&#039;s flag to signal &#039;extents are correct&#039;.<br /><br />The BBNode.DoSplit method is called by GetExtents to actually subdivide a Leaf node into 27 child nodes. This is the method responsible for the tree &#039;growing&#039; dynamically during Queries.<br /><br />The BBNode.UpdateNode method is called by external code once per timestep to update the position of a moving BoundingSphere node, and to adjust its position in the tree, potentially queuing tree restructuring but deferring it until Queried. Basically whenever one of our RigidBody instances has moved in 3D space, we&#039;ll call this Update method on its container node which will keep them synchronized and adjust the tree for us.<br /><br /><pre><code><br />;Method:	BBNode.UpdateExtents<br />;Purpose:	Re-Calculate this node&#039;s AABB and SplitPoint based on node&#039;s Child AABB&#039;s and Body AABB&#039;s<br />;Remarks:	SplitPoint Calculation is not the same as used initially, this bothers me<br />Method BBNode.UpdateExtents, uses esi ebx<br />LOCAL set:BOOL<br />LOCAL ct<br />LOCAL newsplit:Vec3<br />LOCAL lo:Vec3, hi:Vec3<br /><br />	SetObject esi<br />	<br />	;Preset the local variables<br />	mov set,FALSE<br />	and ct,0<br />	fldz<br />	fst &nbsp;newsplit.x<br />	fst &nbsp;newsplit.y<br />	fstp newsplit.z<br />	<br />	<br />	xor ebx,ebx<br />	.while ebx&lt;.bodies.dCount<br />		OCall .bodies::Collection.ItemAt, ebx<br />		<br />		fld .BBNode.vPos.x<br />		fld .BBNode.vPos.y<br />		fld .BBNode.vPos.z<br />		fld .BBNode.fRadius<br />		fsub st(3),st(0)<br />		fsub st(2),st(0)<br />		fsub;st(1),st(0)...fUnload<br />		fstp lo.z<br />		fstp lo.y<br />		fstp lo.x<br />		<br />		fld .BBNode.vPos.x<br />		fld .BBNode.vPos.y<br />		fld .BBNode.vPos.z<br />		fld .BBNode.fRadius<br />		fadd st(3),st(0)<br />		fadd st(2),st(0)<br />		fadd;st(1),st(0)...fUnload<br />		fstp hi.z<br />		fstp hi.y<br />		fstp hi.x<br />		<br />		.if !set<br />			fld lo.x<br />			fld lo.y<br />			fld lo.z<br />			fstp .vMin.z<br />			fstp .vMin.y<br />			fstp .vMin.x<br />			fld hi.x<br />			fld hi.y<br />			fld hi.z<br />			fstp .vMax.z<br />			fstp .vMax.y<br />			fstp .vMax.x<br />			mov set, TRUE<br />		.else<br />			MakeMin .vMin.x, .vMin.x, lo.x<br />			MakeMin .vMin.y, .vMin.y, lo.y<br />			MakeMin .vMin.z, .vMin.z, lo.z<br />			MakeMax .vMax.x, .vMax.x, hi.x<br />			MakeMax .vMax.y, .vMax.y, hi.y<br />			MakeMax .vMax.z, .vMax.z, hi.z<br />		.endif<br />		fld .vPos.x<br />		fld .vPos.y<br />		fld .vPos.z<br />		fadd newsplit.z<br />		fstp newsplit.z<br />		fadd newsplit.y<br />		fstp newsplit.y<br />		fadd newsplit.x<br />		fstp newsplit.x<br />		<br />		inc ct		<br />		inc ebx<br />	.endw<br /><br />	xor ebx,ebx<br />	.while ebx&lt;27<br />		push ebx<br />		mov ebx,.children<br />		.if ebx!=0 ;Recurse each valid Child for its extents<br />			OCall ebx::BBNode.GetExtents,addr lo, addr hi, FALSE<br />			<br />			;Recalculate this node&#039;s AABB to include all its Child AABB&#039;s<br />			.if !set<br />				fld lo.x<br />				fld lo.y<br />				fld lo.z<br />				fstp .vMin.z<br />				fstp .vMin.y<br />				fstp .vMin.x<br />				fld hi.x<br />				fld hi.y<br />				fld hi.z<br />				fstp .vMax.z<br />				fstp .vMax.y<br />				fstp .vMax.x<br />				mov set, TRUE<br />			.else<br />				MakeMin .vMin.x, .vMin.x, lo.x<br />				MakeMin .vMin.y, .vMin.y, lo.y<br />				MakeMin .vMin.z, .vMin.z, lo.z<br />				MakeMax .vMax.x, .vMax.x, hi.x<br />				MakeMax .vMax.y, .vMax.y, hi.y<br />				MakeMax .vMax.z, .vMax.z, hi.z<br />			.endif<br />			<br />			<br />			;We will sum the SplitPoints of the child nodes<br />			fld .BBNode.vSplit.x<br />			fld .BBNode.vSplit.y<br />			fld .BBNode.vSplit.z<br />			fild SPLITVAL<br />			fmul st(3),st(0)<br />			fmul st(2),st(0)<br />			fmul<br />			fadd newsplit.z<br />			fstp newsplit.z<br />			fadd newsplit.y<br />			fstp newsplit.y<br />			fadd newsplit.x<br />			fstp newsplit.x<br />			<br />			inc ct<br />		.endif<br />		pop ebx<br />		inc ebx<br />	.endw<br />	<br />	;This node&#039;s splitpoint = averaged midpoint of its child<br />	fld newsplit.x<br />	fld newsplit.y<br />	fld newsplit.z<br />	fild ct<br />	fdiv st(3),st(0)<br />	fdiv st(2),st(0)<br />	fdiv<br />	fstp .vSplit.z<br />	fstp .vSplit.y<br />	fstp .vSplit.x<br /><br />	<br />	mov .bExtentsAreCorrect,TRUE<br />MethodEnd<br /><br />;Method:	BBNode.DoSplit<br />;Purpose:	Split this node into 27 subspaces , remembering the splitpoint and childpointers<br />Method BBNode.DoSplit,uses esi edi ebx<br />LOCAL ttl:real8,rw:real8<br />LOCAL safe:BOOL,first:BOOL<br />LOCAL lc, _c<br /><br />	SetObject esi	<br />	.if .bIsSplit<br />		DbgWarning &quot;Error - Node already marked as being split&quot;<br />		int 3<br />	.endif<br /><br />	; Find the split point (preset to zero, and calculate weighted average)<br />	fldz<br />	fst &nbsp;.vSplit.x<br />	fst &nbsp;.vSplit.y<br />	fst &nbsp;.vSplit.z<br />	fstp &nbsp;ttl<br />	xor ebx,ebx<br />	.while ebx&lt;.bodies.dCount<br />		OCall .bodies::Collection.ItemAt,ebx<br />		<br />		if WEIGHTED_BY_RADII<br />			;Weighting factor = 1/Radius<br />			;rw = 1.0/(r + 1e-12) &nbsp;... where 1e-12 is basically &quot;radius cant be zero&quot; sanity thing<br />			fld1<br />			fdiv .BBNode.fRadius<br />		else<br />			;Weighting factor = 1<br />			fld1<br />		endif<br />		fst rw			<br />		fadd ttl<br />		fstp ttl<br />		<br />		;vSplit += (pos + radius)*rw		;Sum of Weighted Position and Radius<br />		fld &nbsp;.BBNode.vPos.x<br />		fadd .BBNode.fRadius<br />		fld &nbsp;.BBNode.vPos.y<br />		fadd .BBNode.fRadius<br />		fld &nbsp;.BBNode.vPos.z<br />		fadd .BBNode.fRadius<br />		fld rw<br />		fmul st(3),st(0)<br />		fmul st(2),st(0)<br />		fmul<br />		fadd .vSplit.z<br />		fstp .vSplit.z<br />		fadd .vSplit.y<br />		fstp .vSplit.y<br />		fadd .vSplit.x<br />		fstp .vSplit.x<br />	<br />		inc ebx<br />	.endw<br />	;vSplit /= ttl							;Average of (Sum of Weighted Position and Radius)<br />	fld .vSplit.x<br />	fld .vSplit.y<br />	fld .vSplit.z<br />	fld ttl<br />	fdiv st(3),st(0)<br />	fdiv st(2),st(0)<br />	fdiv<br />	fstp .vSplit.z<br />	fstp .vSplit.y<br />	fstp .vSplit.x<br />	<br />	;We JUST split it so init the children<br />	mov .bIsSplit,TRUE<br />	mov .childcount,27<br />	xor ebx,ebx<br />	.while ebx&lt;27<br />		mov .children,$New(BBNode,Init,esi)<br />		inc ebx<br />	.endw<br /><br /><br />	mov safe,FALSE <br />	mov first, TRUE<br />	mov lc,0<br />	<br />	xor ebx,ebx<br />	.while ebx&lt;.bodies.dCount<br />		push ebx<br />		mov ebx,$OCall (.bodies::Collection.DeleteAt,0)<br />		mov _c,$OCall (esi.WhichChild, addr .BBNode.vPos, .BBNode.fRadius)<br />		; Make sure at least one object doesn’t go into the same child as everyone else<br />		.if !safe<br />			.ifBitSet _c, BIT31 <br />				mov safe,TRUE<br />			.else<br />				.if first<br />					m2m lc, _c, edx<br />					mov first, FALSE<br />				.else<br />					mov edx,lc<br />					.if _c !=edx<br />						mov safe,TRUE			;bodies went into different children<br />					.else<br />						or safe,FALSE			;bodies went to same child<br />					.endif<br />				.endif<br />			.endif<br />		.endif<br />		.ifBitSet _c, BIT31<br />			;Put it back in this node<br />			OCall .bodies::Collection.Insert,ebx<br />		.else<br />			mov edx,_c<br />			OCall .children::BBNode.InsertNode, ebx<br />		.endif<br />		pop ebx<br />		inc ebx<br />	.endw<br /><br />	.if !safe<br />		; Oops, all objects went into the same child node! Take them back.<br />		mov edx,lc		<br />		mov edi,.children<br />		xor ebx,ebx<br />		.while ebx&lt;.BBNode.bodies.dCount<br />			mov edx,$OCall (.BBNode.bodies::Collection.ItemAt,ebx)				<br />			OCall edi::BBNode.RemoveNode,edx	;Detach from child<br />			OCall esi.InsertNode,eax	;Attach to self<br />			inc ebx<br />		.endw		<br />		; The last removal marked this node as unsplit, so<br />		; we’ll just have to do this all over again next time<br />		; this AABB is queried, UNLESS we simply keep this node split<br />		mov .bIsSplit,TRUE<br />	.endif<br /><br />	;Update the BoundingBox Extents of all Child nodes<br />	xor ebx,ebx<br />	.while ebx&lt;27<br />		.if .children!=0<br />			OCall .children::BBNode.UpdateExtents<br />		.endif<br />		inc ebx<br />	.endw<br />MethodEnd<br /><br />;Method:	BBTree.UpdateNode<br />;Purpose:	Update the Position of a BoundingSphere node, possibly queuing changes to the tree structure<br />;Args:		pNode = ptr to Node being processed<br />Method BBNode.UpdateNode,uses esi edi ebx<br />LOCAL minp:Vec3, maxp:Vec3<br />	SetObject esi<br />	mov ebx,esi<br />	mov edi,esi<br />	<br />	;Update the node&#039;s Position from the RigidBody<br />	mov edx,.pRigidBody<br />	fld .RigidBody.linPos0.x<br />	fld .RigidBody.linPos0.y<br />	fld .RigidBody.linPos0.z<br />	fstp .vPos.z<br />	fstp .vPos.y<br />	fstp .vPos.x<br />		<br />	; Calculate a theoretical Box at the origin of this Node, with size of +/- radius in each major axis<br />	; This is the smallest Box that contains this Node&#039;s BOUNDING SPHERE 	<br />	fld &nbsp;.vPos.x		;Calculate maxima<br />	fld &nbsp;.vPos.y<br />	fld &nbsp;.vPos.z<br />	fld &nbsp;.fRadius<br />	fadd st(3),st(0)<br />	fadd st(2),st(0)<br />	fadd<br />	fstp maxp.z<br />	fstp maxp.y<br />	fstp maxp.x<br />	<br />	fld &nbsp;.vPos.x		;Calculate minima<br />	fld &nbsp;.vPos.y<br />	fld &nbsp;.vPos.z	<br />	fld .fRadius<br />	fsub st(3),st(0)<br />	fsub st(2),st(0)<br />	fsub<br />	fstp minp.z<br />	fstp minp.y<br />	fstp minp.x<br />	<br />	;Backtrack up the tree to the root node until we find one that does *NOT* include our Box<br />	.while .BBNode.pOwner!=0 &amp;&amp; !$OCall (ebx::BBNode.Contains,addr minp, addr maxp)	<br />		mov ebx,.BBNode.pOwner<br />	.endw<br />	; Find its final reinsertion point<br />	OCall ebx::BBNode.FindNode,addr .BBNode.vPos,.BBNode.fRadius<br />	.if eax!=edi<br />		push .BBNode.pOwner	;preserve old parent<br />		mov ebx,eax<br />		OCall ebx::BBNode.InsertNode,esi					;Attach the node to new Parent<br />		OCall ebx::BBNode.GrowExtents,addr minp, addr maxp	;Verify bounds of new Parent<br />		pop edi		;restore old parent<br />		OCall edi::BBNode.RemoveNode,esi		;Detach from old parent, will shrink extents	<br />	.endif<br />MethodEnd<br /><br /></code></pre><br /></div>
    <div class="meta">Posted on 2010-08-31 03:01:05 by Homer</div>
   </div>
   <div class="post" id="post-213021">
    <div class="subject"><a href="#post-213021">Re: Back to the Future</a></div>
    <div class="body">Finally, we&#039;re back to BroadPhase Collision Detection :)<br /><br />The goal of our broadphase is to find pairs of BoundingSpheres which are currently intersecting, or which are heading toward imminent collision, while ignoring pairs of spheres which cannot possibly collide.<br /><br />We have created a Dynamic Tree whose nodes contain our BoundingSpheres, with larger spheres getting &#039;stuck&#039; at nonleaf nodes, and smaller nodes falling further toward the leaf nodes, which can hold a maximum of (51) entities before splitting can be attempted. We&#039;ll use this tree to accelerate our broadphase collision queries. <br /><br />We&#039;ll need to take each boundingsphere node, and send it down the tree from the root node.<br />At each node we visit, if the node contains local spheres, we&#039;ll perform a sphere-sweep test of our subject sphere and each local sphere, possibly generating &#039;CollisionPair Records&quot;. Then we&#039;ll choose a child to recurse, and walk to it. This will repeat until we reach a leaf node, or until the subject sphere doesn&#039;t intersect the AABB of the node.<br />All of this begins in the Physics Simulator, so my next post will be to begin showing the BroadPhase collision detection methods from their entrypoint there.<br /><br /><br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2010-08-31 04:01:30 by Homer</div>
   </div>
   <div class="post" id="post-213022">
    <div class="subject"><a href="#post-213022">Re: BroadPhase Entrypoint</a></div>
    <div class="body">The CollisionPair structure will store a record of a pair of potentially-colliding entities. The broadphase will emit these records. My implementation will collect up to 256 CollisionPair records at once.<br />Here&#039;s some stuff we&#039;ll use in our broadphase:<br /><br /><pre><code><br />;CollisionDetection Values:<br />MAX_COLLISION_PAIRS equ 256<br /><br />Clear equ 0<br />Penetrating equ -1<br />Colliding equ 1<br /><br />CollisionPair struct<br />	pBodyA Pointer ?<br />	pBodyB Pointer ?<br />	fLowerBound real8 ?<br />	fUpperBound real8 ?<br />CollisionPair ends<br /><br />CollisionPairArray struct<br />	Collectionpairs CollisionPair MAX_COLLISION_PAIRS dup (&lt;&gt;)<br />CollisionPairArray ends<br /></code></pre><br /><br />Before we begin, some notes about collision pairs.<br />We will start with the convention that the pBodyA and pBodyB fields are sorted by the order of their indices in the simulator&#039;s global list of bodies. What this implies is that BodyB can never have a lower index than BodyA - this is important because it can help us eliminate some unwanted testing.<br />We will reinforce this convention by declaring that BodyA is the &quot;Aggressor&quot; and BodyB is the &quot;Target&quot; of the potential collision event - this implies that BodyB may be At Rest (ie sleeping) but BodyA is most definitely Awake.<br /><br />Now having said that, if we were to perform a bruteforce pairwise test (which we will NOT do), we would need to process each BodyA against any bodies with a higher index than its own...Specifically, an outer loop where Body A&#039;s index counts from zero to #count-2, and an inner loop with BodyB = initial index is (BodyA&#039;s index)+1, and final index is #count-1... we&#039;ll bear in mind that we can use this logic to eliminate duplicate pairwise tests during our DAABB tree querying (code for this has not yet been presented).<br /><br />So here&#039;s our entrypoint to the broadphase collision testing.<br />The Physics.BroadPhase_Collisions method simply passes each simulated body&#039;s bounding-node to a BBTree method for further evaluation.<br />I&#039;ve also included the Physics.Add_Sphere method, whose purpose is to create a new RigidBody with a Spherical shape, and given physical attributes, create an associated BBNode, add the new node to the tree, and add the new RigidBody instance to the Simulator&#039;s master-list.<br />We&#039;ll be able to add any kind of shape wrapped in a sphere, but I&#039;m starting with actual spheres for testing purposes, and because &quot;if I can&#039;t do it with spheres, then I can&#039;t do it with anything more complex&quot; ;)<br /><br /><pre><code><br />;Method:	Physics.BroadPhase_Collisions<br />;Purpose:	Find pairs of entities whose BoundingSpheres are currently intersecting, <br />;			or whose swept projections will intersect during the current timestep.<br />Method Physics.BroadPhase_Collisions, uses esi ebx<br />	SetObject esi<br />	;The Physics Simulator keeps the master-list of RigidBody instances in its Ancestor Collection.<br />	;We must enumerate this list, passing each 	<br />	xor ebx,ebx<br />	.while ebx&lt;.dCount<br />		OCall esi.ItemAt,ebx						;-&gt; RigidBody<br />		mov edx,.RigidBody.pBoundingNode		;-&gt; BBNode<br />		OCall .DAABBTree::BBTree.FindCollisionPairs,edx, addr .CollisionPairs, .dMaxCollisionPairs<br />		inc ebx<br />	.endw<br />MethodEnd<br /><br />; Method:	Physics.Add_Sphere<br />; Purpose:	Add a new Sphere Entity to the Simulation<br />; Args:		pvPosition -&gt;				WorldSpace Position of Center of Mass<br />;			pvLinarVelocity	-&gt;			WorldSpace Velocity of Center of Mass<br />;			pOrientationQuaternion -&gt; 	Quaternion representing Orientation (0,0,0,1 = identity)<br />;			pvAngularVelocity -&gt;		Vector representing velocity about a given axis<br />;			fLinearKineticDamping =		Float scalar for removing kinetic energy<br />;			fAngularKineticDamping =	Float scalar for removing kinetic energy<br />;			fGravity =					Float Gravitational Constant (per Body !!)<br />Method Physics.Add_Sphere, uses esi ebx, pvPosition, pvLinearVelocity, pOrientationQuaternion, pvAngularVelocity, fLinearKineticDamping:real4, fAngularKineticDamping:real4, fGravity:real4,&nbsp; fRadius:real8, fDensity:real4<br />LOCAL body<br />LOCAL fMass:real4<br />	SetObject esi<br />	<br />	;Create a RigidBody from the input params<br />	mov body,&nbsp; $New(RigidBody,Init, esi, pvPosition, pvLinearVelocity, pOrientationQuaternion, pvAngularVelocity,fLinearKineticDamping, fAngularKineticDamping)<br />	;We need to calculate ehe Mass of the sphere<br />	;We know the Density and the Radius.<br />	;We know Mass = Density * Volume<br />	;Volume of a Sphere is 4/3 pi r ^3<br />	fldpi<br />	fld fRadius<br />	fmul st(0),st(0)<br />	fmul st(0),st(0)<br />	fmul<br />	fmul r8_4Over3<br />	fmul fDensity<br />	fstp fMass<br />	<br />	OCall body::RigidBody.setSphere, fRadius, fMass<br />	OCall body::RigidBody.setGravity, fGravity	<br /><br />	<br />	;Create a BBNode and set its Position and Radius<br />	mov ebx,$New(BBNode)<br />	mov eax,pvPosition<br />	m2m .BBNode.vPos.x, .Vec3.x,edx<br />	m2m .BBNode.vPos.y, .Vec3.y,edx<br />	m2m .BBNode.vPos.z, .Vec3.z,edx<br />	fld fRadius<br />	fstp .BBNode.fRadius	<br />	;Set a special Pointer to RigidBody in this node<br />	m2m .BBNode.pRigidBody,body,edx<br />	mov .RigidBody.pBoundingNode,ebx<br />	;Add the BBNode to the DAABB Tree<br />	OCall .DAABBTree::BBTree.AddNode,ebx<br /><br />	;Insert RigidBody into Simulator<br />	OCall esi.Insert,body<br />	<br />MethodEnd<br /></code></pre><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2010-08-31 04:45:58 by Homer</div>
   </div>
   <div class="post" id="post-213024">
    <div class="subject"><a href="#post-213024">Re: Physics 2010 - Querying the DIAABB Tree for collision of moving spheres</a></div>
    <div class="body">The broadphase method leads us to the BBTree.FindCollisionPairs method.<br />This is simply a stub which calls the BBNode method of the same name, and in the context of the Root node of the tree.<br /><br /><pre><code><br />Method BBTree.FindCollisionPairs,uses esi,pNode,pRecords,dMaxRecords<br />	SetObject esi<br />	OCall .RootNode::BBNode.FindCollisionPairs,pNode,pRecords,dMaxRecords<br />MethodEnd<br /></code></pre><br /><br />Finally we reach the BBNode.FindCollisionPairs method, which is another good example of a Linear Traversal (rather than a Nested Recursion). <br />The first thing this method does is check if the current node&#039;s AABB intersects the input sphere&#039;s AABB.<br />If it doesn&#039;t , the method will return.<br />Next it checks if the current node contains any BoundingSpheres, and if so, performs a Swept Test of the input sphere and each of the node&#039;s spheres.<br />Finally, it checks if there are any Child nodes, and if so, chooses one child node to traverse into, and the whole process repeats until we hit a leaf node, or can&#039;t find any child volumes which intersect the input sphere.<br />If we perform a sweep test and the result indicates a current or pending intersection of a pair of boundingspheres, we record this CollisionPair.<br /><pre><code><br />; ——————————————————————————————————————————————————————————————————————————————————————————————————<br />; ——————————————————————————————————————————————————————————————————————————————————————————————————<br />;Method:	BBNode.FindCollisionPairs<br />;Purpose:	Identify pairs of Spheres whose extruded capsules intersect during the current timeframe<br />;			Return CollisionPair records up to the prescribed limit<br />;Args:		pNode -&gt; BoundingSphere Node being Tested against this Structural Node<br />Method BBNode.FindCollisionPairs,uses esi ebx,pNode, pRecords, dMaxRecords<br />LOCAL pBody<br />	SetObject esi<br />	;We will stop recursing if we reach a node whose AABB does not intersect with the Sphere<br />@@:<br />	mov edx,pNode<br />	.if $OCall (esi.Intersects, addr .BBNode.vMin,addr .BBNode.vMax)== TRUE<br /><br />		;perform Swept Spheres test on any local spheres<br />		xor ebx,ebx<br />		.while ebx&lt;.bodies.dCount<br />			mov pBody,$OCall (.bodies::Collection.ItemAt, ebx)<br />			.if eax!=pNode<br />				OCall pBody::BBNode.Sweep_Node, pNode<br />				.if eax==TRUE<br />					.if edx==Colliding<br />						;Spheres will Collide at a Future Time T0, and will part ways at Future Time T1.<br />						mov edx,pRecords<br />						mov eax,pBody<br />						mov eax,.BBNode.pRigidBody<br />						mov .CollisionPair.pBodyA,eax<br />						mov eax,pNode<br />						mov eax,.BBNode.pRigidBody<br />						mov .CollisionPair.pBodyB,eax<br />						fstp .CollisionPair.fLowerBound<br />						fstp .CollisionPair.fUpperBound<br />						add pRecords,sizeof CollisionPair<br />						dec dMaxRecords<br />					.elseif edx==Penetrating<br />						;Spheres were already Penetrating at the start of the frame<br />						;We will use default lower and upper limit values (0.0 and 1.0)<br />						mov edx,pRecords<br />						mov eax,pBody<br />						mov eax,.BBNode.pRigidBody<br />						mov .CollisionPair.pBodyA,eax<br />						mov eax,pNode<br />						mov eax,.BBNode.pRigidBody<br />						mov .CollisionPair.pBodyB,eax<br />						fldz<br />						fstp &nbsp;.CollisionPair.fLowerBound<br />						fld1<br />						fstp .CollisionPair.fUpperBound<br />						add pRecords,sizeof CollisionPair<br />						dec dMaxRecords<br />					.endif<br />				.endif<br />			.endif<br />			inc ebx<br />		.endw<br />		<br />		;Traverse to the child suggested by the heuristic <br />		.if .childcount!=0<br />			mov edx,pNode<br />			mov ebx,$OCall (esi.WhichChild, addr .BBNode.vPos,.BBNode.fRadius)<br />			.if ebx &gt;= 0 &amp;&amp; .children!=0<br />				mov edx,pNode<br />				.if edx!=.children<br />					mov esi,.children			<br />					jmp @B<br />				.endif<br />			.endif<br />		.endif<br />		<br />	.endif<br />MethodEnd<br /><br /></code></pre><br /><br />What&#039;s currently missing from this function is our prior knowledge of legal pairings in CollisionPair records (remember I made a fuss about this?) : the index of pNode must be greater than the index of pBody or else the test is a waste of time (since this body pairing must already have been queried !!)<br /><br /></div>
    <div class="meta">Posted on 2010-08-31 06:28:32 by Homer</div>
   </div>
   <div class="post" id="post-213025">
    <div class="subject"><a href="#post-213025">Re: Broadphase accelerated by DIAABBTree Sweep</a></div>
    <div class="body"><br />That leaves us just a couple more methods to show.<br />Please note that the following methods are not a required part of the BBNode class, and specifically mention the RigidBody class (as our payload entities), I dislike this dependency and will likely change it.<br /><br />The BBNode.Sweep_Node method will first obtain the relative velocity of two Spheres and make sure that they are in fact approaching one another.. it then performs a swept intersection test apon the two BoundingSpheres.<br />By convention, Body A is &#039;this&#039; body (ie, the current node is a bounding-node) and Body B is &#039;other&#039; body , as dictated by the given &#039;pOtherBodyNode&#039; parameter (which is ALSO a bounding-node).<br /><br />The swept test can return Clear, Colliding, Penetrating or Error.<br />Clear = these two Spheres will certainly not collide... the CollisionPair was a False Alarm!<br />Colliding = these two Spheres will first touch at time T0, and become separated again at time t1.<br />We call these two times &#039;the upper and lower bounds of the Time Of Impact&quot;.<br />These times are &quot;Normalized&quot; - ie, represent a fraction of the current timestep, from 0.0 to 1.0<br />Penetrating = these two Spheres were already in Penetration at the beginning of the timestep, so a conventional swept test won&#039;t work - however, given that these spheres are in fact moving apart from each other toward Separation, I&#039;ve been thinking that we could perform a kind of &#039;reverse sweep&#039; from &#039;the future&#039; where they are separated, to determine our Upper and Lower bounds that way ???<br />Anyway, my current code simply sets the lower bound to 0.0, the upper bound to 1.0, and records a CollisionPair with these inaccurate bounds on the time of impact.<br />The final case of an Error I think can only happen when the two spheres are moving in parallel trajectories (thus our Quadratic Equation won&#039;t work)... think I can just return Clear for this one.<br /><br />This brings us to the end of the Broadphase Collision code, just note that our FindCollisionPairs method generated a bunch of Queries which caused our tree to be updated - but we still need to call the UpdateNode method apon each bounding-node whose payload entity (RigidBody) has moved in space.<br /><br /><br /><br /><br /><pre><code><br /><br />;** Returns values on FPU<br />;Calculate the Closing Velocity of two moving Bodies<br />;This is a floating point value whose Sign indicates whether the Bodies<br />;are moving toward each other (negative), or away from each other (positive)<br />;and whose scale indicates the magnitude of the relative velocity.<br />;Returns FOUR values on the FPU<br />;st(0) contains the Closing Velocity<br />;st(1-3) contains the DIRECTION of the Relative Velocity<br />Method BBNode.Get_Closing_And_Relative_Velocities,uses esi edi,pOtherBodyNode<br />LOCAL pOtherConfig<br />LOCAL vCollisionNormal_AB:Vec3<br />LOCAL vCollisionNormal_BA:Vec3<br />LOCAL dpa:Vec3, dpb:Vec3<br />LOCAL fMag:real8<br /><br />	SetObject esi<br /><br /><br />	; Calculate &#039;change in position&#039; of &#039;this&#039; body<br />	mov eax,.pRigidBody<br />	fld&nbsp; .RigidBody.linPos.x		;current - old position<br />	fsub .RigidBody.linPos0.x<br />	fld&nbsp; .RigidBody.linPos.y<br />	fsub .RigidBody.linPos0.y<br />	fld&nbsp; .RigidBody.linPos.z<br />	fsub .RigidBody.linPos0.z<br />	fstp dpa.z<br />	fstp dpa.y<br />	fstp dpa.x	<br />	<br /><br />	; Calculate &#039;change in position&#039; of &#039;other&#039; body<br />	mov edx,pOtherBodyNode<br />	mov eax,.BBNode.pRigidBody<br />	fld&nbsp; .RigidBody.linPos.x		;current - old position<br />	fsub .RigidBody.linPos0.x<br />	fld&nbsp; .RigidBody.linPos.y<br />	fsub .RigidBody.linPos0.y<br />	fld&nbsp; .RigidBody.linPos.z<br />	fsub .RigidBody.linPos0.z<br />	fstp dpb.z<br />	fstp dpb.y<br />	fstp dpb.x	<br />	<br />	; Calculate RELATIVE VELOCITY vector, leave it on the fpu<br />	lea eax,dpb<br />	lea edx,dpa<br />	fld&nbsp; .Vec3.x<br />	fsub .Vec3.x<br />	fld&nbsp; .Vec3.y<br />	fsub .Vec3.y<br />	fld&nbsp; .Vec3.z<br />	fsub .Vec3.x<br />	<br />	; Calculate Direction from A to B<br />	mov edx,pOtherBodyNode<br />	mov eax,.BBNode.pRigidBody<br />	mov edx,.pRigidBody<br />	fld&nbsp; .RigidBody.linPos.x		;current B - current A position<br />	fsub .RigidBody.linPos.x<br />	fld&nbsp; .RigidBody.linPos.y<br />	fsub .RigidBody.linPos.y<br />	fld&nbsp; .RigidBody.linPos.z<br />	fsub .RigidBody.linPos.z<br />	fstp vCollisionNormal_AB.z<br />	fstp vCollisionNormal_AB.y<br />	fstp vCollisionNormal_AB.x	<br />	<br />	<br />	;Calculate Magnitude for Normalizing the Direction<br />	fld vCollisionNormal_AB.x<br />	fmul st(0),st(0)<br />	fld vCollisionNormal_AB.y<br />	fmul st(0),st(0)	<br />	fld vCollisionNormal_AB.z<br />	fmul st(0),st(0)<br />	fadd<br />	fadd<br />	fsqrt<br />	fstp fMag<br />	<br />	;Normalize and Invert<br />	fld vCollisionNormal_AB.x<br />	fld vCollisionNormal_AB.y<br />	fld vCollisionNormal_AB.z<br />	fld1<br />	fdiv fMag<br />	fmul st(3),st(0)<br />	fmul st(2),st(0)<br />	fmul<br />	fst vCollisionNormal_AB.z<br />	fchs<br />	fstp vCollisionNormal_BA.z<br />	fst vCollisionNormal_AB.y<br />	fchs<br />	fstp vCollisionNormal_BA.y<br />	fst vCollisionNormal_AB.x<br />	fchs<br />	fstp vCollisionNormal_BA.x<br />	<br /><br />	; Closing Velocity of two Bodies = (dpa . vCollisionNormal_AB) + (dpb . vCollisionNormal_BA)<br />	invoke Vec3_Dot, addr dpa, addr vCollisionNormal_AB<br />	invoke Vec3_Dot, addr dpb, addr vCollisionNormal_BA<br />	fadd<br />MethodEnd<br /><br />;This macro implements a classic &quot;Quadratic Equation&quot;<br />QuadraticFormula macro<br />; q = b*b - 4*a*c<br />	fld _b<br />	fmul st(0),st(0)<br />	fld _a<br />	fmul _c<br />	fadd st(0),st(0)<br />	fadd st(0),st(0)<br />	fsub<br />	fstReg eax	<br />&nbsp; &nbsp; ;if q &gt;= 0 <br />	.ifBitSet eax, BIT31<br />		fUnload<br />&nbsp; &nbsp; 	mov eax, FALSE	;complex root<br />&nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; ; sq = sqrt(q)<br />&nbsp; &nbsp; &nbsp; &nbsp; fsqrt<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp sq&nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; ;d = 1 / (2*a)<br />&nbsp; &nbsp; &nbsp; &nbsp; fld1<br />&nbsp; &nbsp; &nbsp; &nbsp; fld _a<br />&nbsp; &nbsp; &nbsp; &nbsp; fadd st(0),st(0)<br />&nbsp; &nbsp; &nbsp; &nbsp; fdiv<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp _d<br />&nbsp; &nbsp; &nbsp; &nbsp; ;u0 = ( -b + sq ) * d<br />&nbsp; &nbsp; &nbsp; &nbsp; fld _b<br />&nbsp; ;&nbsp; &nbsp; &nbsp; fchs<br />&nbsp; &nbsp; &nbsp; &nbsp; fadd sq<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul _d<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp u0&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ;u1 = ( -b - sq ) * d<br />&nbsp; &nbsp; &nbsp; &nbsp; fld _b<br />&nbsp;  ;&nbsp; &nbsp;  fchs<br />&nbsp; &nbsp; &nbsp; &nbsp; fsub sq<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul _d<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp u1<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />	 	;load fpu with T = smaller of two impact times	<br />		fMin u0, u1<br />		<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,TRUE<br />	.endif<br />endm<br /><br />;Perform Broad-Phase collision testing of a pair of BoundingSpheres.<br />;Convention is that &#039;this body&#039; is the potential &#039;aggressor&#039;, colliding with &#039;other body(s)&#039;.<br />;Returns EAX = TRUE (success) or FALSE (failed)<br />;&nbsp; &nbsp; &nbsp; &nbsp; If eax=TRUE, EDX = Clear, Penetrating or Colliding<br />;&nbsp; &nbsp; &nbsp; &nbsp; If edx = Colliding, ST0 = start, ST1 = end time of interpenetration<br />;<br />Method BBNode.Sweep_Node,uses esi, pOtherBodyNode<br />LOCAL AB:Vec3		;vector between origins<br />LOCAL rab2:real8	;squared sum of radii<br />LOCAL _a, _b, _c, _d<br />LOCAL u0,u1			;normalized time of first and second collisions<br />LOCAL sq<br />LOCAL ClosingVelocity:real4<br />LOCAL RelativeVelocity:Vec3<br /><br />&nbsp; &nbsp; SetObject esi<br /><br />&nbsp; &nbsp; ;perform sphere/sphere sweep test...	<br />&nbsp; &nbsp; ;Get the Closing velocity of the Spheres, and also the Relative velocity vector<br />&nbsp; &nbsp; OCall esi.Get_Closing_And_Relative_Velocities, pOtherBodyNode<br />&nbsp; &nbsp; fstp ClosingVelocity	;= Signed Magnitude<br />&nbsp; &nbsp; fstp RelativeVelocity.z ;= Direction<br />&nbsp; &nbsp; fstp RelativeVelocity.y<br />&nbsp; &nbsp; fstp RelativeVelocity.x<br /><br />&nbsp; &nbsp; ;Make sure that the Spheres are actually approaching one another..<br />&nbsp; &nbsp; ;If we find that they are actually moving apart (we are assuming they were not already penetrating)<br />&nbsp; &nbsp; ;then collision isnt possible and we can quit early	<br />&nbsp; &nbsp; .ifBitClr ClosingVelocity,BIT31<br />&nbsp; &nbsp; &nbsp; &nbsp; DbgWarning &quot;Spheres are Separating&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; mov edx,Clear<br />&nbsp; &nbsp; &nbsp; &nbsp; ExitMethod<br />&nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; ;Calculate vector between starting points<br />&nbsp; &nbsp; ; AB = previous pos B&nbsp; - previous pos A<br />&nbsp; &nbsp; mov eax,pOtherBodyNode<br />&nbsp; &nbsp; mov eax,.BBNode.pRigidBody<br />&nbsp; &nbsp; mov edx,.pRigidBody<br />&nbsp; &nbsp; fld&nbsp; .RigidBody.linPos0.x&nbsp;  <br />&nbsp; &nbsp; fsub .RigidBody.linPos0.x<br />&nbsp; &nbsp; fld&nbsp; .RigidBody.linPos0.y&nbsp;  <br />&nbsp; &nbsp; fsub .RigidBody.linPos0.y<br />&nbsp; &nbsp; fld&nbsp; .RigidBody.linPos0.z&nbsp;  <br />&nbsp; &nbsp; fsub .RigidBody.linPos0.z<br />&nbsp; &nbsp; fstp AB.z<br />&nbsp; &nbsp; fstp AB.y<br />&nbsp; &nbsp; fstp AB.x<br /><br />&nbsp; &nbsp; ;Calculate sum of sphere radii, squared<br />&nbsp; &nbsp; ; rab = ra + rb<br />&nbsp; &nbsp; fld&nbsp; .RigidBody.fRadius<br />&nbsp; &nbsp; fadd .RigidBody.fRadius<br />&nbsp; &nbsp; fmul st(0),st(0)<br />&nbsp; &nbsp; fstp rab2			; = sum of sphere radii, squared	<br /><br />&nbsp; &nbsp; invoke Vec3_Dot, addr RelativeVelocity, addr RelativeVelocity<br />&nbsp; &nbsp; fstp _a				; = Relative Velocity, squared<br />&nbsp; &nbsp; invoke Vec3_Dot, addr RelativeVelocity, addr AB<br />&nbsp; &nbsp; fadd st(0),st(0)<br />&nbsp; &nbsp; fstp _b				; = Relative Velocity * Starting Distance * 2<br />&nbsp; &nbsp; invoke Vec3_Dot, addr AB, addr AB<br />&nbsp; &nbsp; fsub rab2<br />&nbsp; &nbsp; fstp _c				; = Starting Separation/Penetration Depth, squared<br /><br />&nbsp; &nbsp; ;check if spheres are (already) overlapping (at their starting positions)<br />&nbsp; &nbsp; .ifBitSet _c,BIT31<br />&nbsp; &nbsp; &nbsp; &nbsp; ;The spheres are ALREADY intersecting in their START POSITIONS<br />&nbsp; &nbsp; &nbsp; &nbsp; ;We&#039;re going to have to check the Bodies for Penetration.<br />&nbsp; &nbsp; &nbsp; &nbsp; DbgWarning &quot;Spheres were already intersecting in the Previous Frame&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax, TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; mov edx,Penetrating<br />&nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; ;check if spheres will collide anywhere along their travel paths<br />&nbsp; &nbsp; &nbsp; &nbsp; QuadraticFormula<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE 			;FPU contains ST0 = start, ST1 = end of sphere interpenetration<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx, Colliding&nbsp; ;Note: T is Normalized (its a time scalar)<br />&nbsp; &nbsp; &nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;They can&#039;t possibly collide ..<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov eax,TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,Clear<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; DbgWarning &quot;Sphere trajectories are parallel and so intersection is not possible&quot;<br /><br />&nbsp; &nbsp; mov eax,FALSE<br />MethodEnd<br /><br /><br /><br /></code></pre></div>
    <div class="meta">Posted on 2010-08-31 23:34:35 by Homer</div>
   </div>
   <div class="post" id="post-213026">
    <div class="subject"><a href="#post-213026">Re: Bringing RK4 into the CollisionDetection </a></div>
    <div class="body">We have two kinds of numerical integration available to us: RK4 and Euler.<br />The RK4 integration is four times more expensive (but four ORDERS more accurate!).<br /><br />Pseudocode for integrating using the RK4 integrator:<br /><pre><code><br />Call RKInit to backup current state and set up initial Forces (due to gravity and velocity)<br />Apply external forces due to Constraints and ForceGenerators<br />Call RKStep1<br />Apply external forces due to Constraints and ForceGenerators<br />Call RKStep2<br />Apply external forces due to Constraints and ForceGenerators<br />Call RKStep3<br />Apply external forces due to Constraints and ForceGenerators<br />Call RKStep4<br /></code></pre><br /><br />Our physics timestep begins by using RK4 to calculate the proposed state that each physical body will reach at the end of the current timestep, assuming no collisions occurred.<br />We then perform our broadphase test to create a (hopefully short) list of which pairs of BoundingSpheres will come into contact during the current timestep.<br />Then we perform semi-fine testing to determine which pairs of entites actually DO collide,and at what Future Time.<br /><br />If no collisions occurred, we can advance our simulation time by one whole timestep... we are done.<br />Assuming there was one or more collisions, we need to unwind the simulation to the beginning of the timestep.. but we don&#039;t need to unwind ALL the bodies, just the ones involved in the earliest collision event. Now we&#039;ll integrate forward again - this time using the Euler integrator, andby a PARTIAL timestep, to the earliest collision time. we&#039;ll now resolve this collision, and then we&#039;ll perform a refresher broadphase test on all of the CollisionPairs which mention these two bodies - this may generate some new CollisionPairs based on the two bodies whose collision was resolved, and it may also kill some CollisionPairs which are no longer valid.<br />We will repeat this process as long as there is at least one CollisionPair with a TOI that falls within the current timestep - for those occuring further in the future than this, we note them, but we don&#039;t resolve them. Eventually we will have reached time T1, and have integrated our bodies to the end of the current timestep - any bodies which were not involved in collisions were integrated just ONCE, but may have been involved in multiple Swept tests.<br /><br />What we DON&#039;T want to be doing is winding the ENTIRE simulation back and forth while handling collisions - anything that makes it to the end of the timestep in a single RK4 pass, and which is not harrassed by any objects as a consequence of their collision response, will not need further processing.<br /><br />Although we switch from using RK4 to using single-step Euler integration while resolving collisions, it should be noted that this will always involve something LESS than a full timestep.<br />To improve accuracy even further, we could determine which 25% of the timestep is involved, and use the physics state associated with the closest RK4 stage... in other words, we can consider the four stages of RK4 as being four euler substeps - four smaller linear integrations, with bounding times of 0-0.25, 0.25-0.5, 0.5,-0.75 and 0.75 to 1.0 (fractions of timestep). We&#039;ve already calculated them all, we may as well be using them to our advantage, as the preferred bounds for our TOI search.<br /><br />EG:<br /><br />Intersections in the 1st Quarter can use linPos0 as the &#039;start time&#039; during searches.<br />Intersections in the 2nd Quarter can use linPos1 as the &#039;start time&#039; during searches.<br />Intersections in the 3rd Quarter can use linPos2 as the &#039;start time&#039; during searches.<br />Intersections in the 4th Quarter can use linPos3 as the &#039;start time&#039; during searches.<br /><br />Intersections in the 1st Quarter can use linPos1 as the &#039;end time&#039; during searches.<br />Intersections in the 2nd Quarter can use linPos2 as the &#039;end time&#039; during searches.<br />Intersections in the 3rd Quarter can use linPos3 as the &#039;end time&#039; during searches.<br />Intersections in the 4th Quarter can use linPos as the &#039;end time&#039; during searches.<br /><br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2010-09-01 05:17:46 by Homer</div>
   </div>
   <div class="post" id="post-213031">
    <div class="subject"><a href="#post-213031">Re: RK4 and NarrowPhase - Why Not?</a></div>
    <div class="body"><br />I&#039;ve just double-checked, and none of the physics engines that I&#039;ve studied which use RK4 integration are taking advantage of the four substates they calculated when it comes to narrowphase collision detection.<br />Even the engines which implement a full Contact Manifold fail to do so, it&#039;s not just those which seek a single Deepest Penetration and then attempt correct for it.<br />In fact, most of them don&#039;t bother to cache the resulting states of all four RK substeps - I do.<br /><br />Can anyone explain to me why they&#039;re ignoring this valuable state data, or offer any reason why it&#039;s not a good idea to use these four substates when attempting to find the Time Of Impact?<br /><br /></div>
    <div class="meta">Posted on 2010-09-02 22:10:18 by Homer</div>
   </div>
   <div class="post" id="post-213048">
    <div class="subject"><a href="#post-213048">Re: Old BodySpace versus Diagonalized BodySpace - Chaney's Simulator</a></div>
    <div class="body">The reason that we can&#039;t use the (first three) RK States for collision detection is simply that they are being stored as &#039;Partial Derivatives&#039; - they need to be Weighted to make sense. This only occurs in the fourth and final step, as we shall soon see.<br /><br />I&#039;m going to walk through the code for integrating a single RigidBody forwards in Time.<br />First we&#039;ll examine the Euler first-order equations, then we&#039;ll examine RK4.<br />The reason we&#039;re bothering to go over this old ground is because this new physics engine operates in DSpace, unlike my previous engines, so we need to build up our understanding of DSpace and how to transform between various coordinate systems.<br /><br />I&#039;m pretty sure we all know what WorldSpace is, so I won&#039;t both with that.<br /><br />We will define BodySpace (or simply BSpace) as being the coordinate system in which a given RigidBody was declared. So for example, if we&#039;ve loaded a RigidBody from some MESH file on disk, then without moving or rotating anything, that Mesh is already in BSpace.<br />For such an arbitrary body, there is no guarantee that the Center Of Mass will coincide with the Origin of the body, or that its weight (mass) will be distributed equally along its Principle Axes.<br />If we calculate the Inertia Tensor of some arbitrary body, we will get a 3x3 matrix which describes its mass-distribution in BodySpace. <br /><br />Diagonalized BodySpace (or simply DSpace) is a coordinate system where the body&#039;s Center Of Mass DOES align with (0,0,0) ... and the body is oriented such that its weight is well-distributed. These are useful properties in dynamics equations as they allow us to use shorter forms of the math.<br />But the most outstanding property of DSpace is that the Inertia Tensor, once transformed into DSpace, contains all zeroes, except for the three &#039;diagonals&#039;, leaving us with effectively a Vec3.<br />That lets us perform cheap Vector math wherever we would normally need Matrix math... ie, any operations involving the Inertia Tensor can now be performed with a simple vector multiplication.<br /><br />For these reasons, we choose to perform our dynamics calculations in DSpace rather than BSpace.<br />I won&#039;t show you yet how to calculate the Inertia Tensor, or Diagonalize it, or anything like that... for now we&#039;ll just assume that yes, we calculated the BSpace tensor, and transformed it into DSpace where it is represented by a Vec3.<br /><br />Now we will simply begin looking at the core of our simulation, which is how we advance the simulation by integrating the physical state of each body over time.<br /><br />Somewhere out there, Richard Chaney is having a laugh at me following his ten-year-old work.<br />I&#039;m not laughing, his engine is being used in state-of-the-art commercial car racing sims, both by auto companies and by game developers. His work is illuminating and ahead of its time, unfortunately he didn&#039;t publish much in the way of educational material, just demos and source. There is one crappy PDF file about integrating single rigid bodies, and it doesn&#039;t even mention diagonalized space, which is the cornerstone of his work.<br /><br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2010-09-06 10:01:56 by Homer</div>
   </div>
   <div class="post" id="post-213049">
    <div class="subject"><a href="#post-213049">Re: Euler's Nut-Gone Flake</a></div>
    <div class="body">Whether we&#039;re using Euler, RK4 or some other integration technique, we will always have to set up the Forces for each Body before stepping the system forwards in time.<br /><br />There are two kinds of Forces that need to be accounted for.<br />Each body has some &quot;internal forces&quot; which are due to its Linear and Angular Momentum.<br />You may remember from school that Momentum is simply Mass * Velocity<br />In our math we will temporarily ignore Mass, and assume that Mass=1.0, ie, Unit Mass.<br />This allows us to directly use Velocity in place of Momentum in our equations (ie we can pretend we&#039;re doing Particle Dynamics with Unit Masses) - provided that we scale the result by the actual Mass involved, everything is peachy.<br />So, at the beginning of each TimeStep in our simulation, we will set our internal (linear and angular) Force to simply the (linear and angular) Velocity.<br /><br />The other kind of force we must account for is &quot;external forces&quot;.<br />The most obvious of these is Gravity - this is a force, it comes from outside of the body, and will affect its dynamics, so we need to add the Gravity force now. But external forces can also come from other sources - the most common will be the forces generated by Constraints such as Springs and other Joints.<br /><br />Once we&#039;ve calculated all the forces acting on a body, we&#039;re ready to integrate it forwards by some amount of Time, which will usually be our TimeStep, often it&#039;s 0.1 seconds per timestep, for a total of ten physics updates per second.<br /><br />Euler&#039;s integration performs the following:<br /><br />#1- Position is the first-order derivative of Velocity... that is to say, Velocity is the Rate Of Change Of Position Over Time. To update our Position, we need to calculate the Change Of Position due to Velocity and Time.<br />Position = Position + (Velocity * Time)<br /><br />#2- Velocity is the first-order derivative of Acceleration... that is to say, Acceleration is the Rate Of Change Of Velocity Over Time. To update our Velocity, we need to calculate the Change Of Velocity due to Acceleration. For the Euler method, we won&#039;t use Acceleration directly...we&#039;ll use a Force-based variation ... We may recall that Force = Mass * Acceleration (F = ma) ... so if we know the Linear Force, and we know the Mass, we could calculate the Acceleration as simply &quot;Acceleration = Force / Mass&quot;, and so then the Change Of Velocity would be &quot;deltaVelocity = Acceleration * Time&quot;<br />LinearVelocity = LinearVelocity + (LinearForce/Mass * Time)<br /><br />#3- The Angular Position (ie Orientation), like its linear counterpart, must advance based on Velocity.<br />If we were storing our orientation using a Matrix (as I have in previous engines) then we could calculate a &#039;star matrix&#039; representing a rotation of one Radian, scale it by the Angular Velocity, and then add the resulting matrix to the current orientation matrix. But this time we&#039;re using a Quaternion representation of orientation. We simply need to multiply our Quaternion by 0.5 * AngularVelocity * Time:<br /><pre><code><br /> &nbsp; &nbsp;;qRotPos0 = qRotPos<br /> &nbsp; &nbsp;;qRotPos.w -= RKh2 * (qRotPos0.x * rotVel.x + qRotPos0.y * rotVel.y + qRotPos0.z * rotVel.z)<br /> &nbsp; &nbsp;;qRotPos.x += RKh2 * (qRotPos0.w * rotVel.x - qRotPos0.z * rotVel.y + qRotPos0.y * rotVel.z)<br /> &nbsp; &nbsp;;qRotPos.y += RKh2 * (qRotPos0.z * rotVel.x + qRotPos0.w * rotVel.y - qRotPos0.x * rotVel.z)<br /> &nbsp; &nbsp;;qRotPos.z += RKh2 * (qRotPos0.x * rotVel.y - qRotPos0.y * rotVel.x + qRotPos0.w * rotVel.z)<br /></code></pre><br />where RKh2 = TimeStep/2 ... watch the Sign in those operations!<br />Having done that, we will make sure that the resulting Quaternion is (close to being) Normal length, and then we&#039;ll extract a 3x3 rotation matrix from it - straight away I see 16 multiplications - I really need to make sure that I&#039;m getting good value from using Quaternions for orientation , hmmz<br /><br />#4- Now we have a new Position, Linear Velocity, and Orientation... it&#039;s time to update our Angular Velocity - how to do that? We can extract a new Angular Velocity from the Angular Force (aka Torque) and Time. I&#039;ll just show the equation here:<br /><pre><code><br />	; calculate new angular velocity with Eulers equations<br />	; rotVel1.x = rotVel.x + (rotVel.y * rotVel.z * diagIyyMinusIzzOverIxx + rotForce.x * oneOverDiagIxx) * RKh<br />	; rotVel1.y = rotVel.y + (rotVel.z * rotVel.x * diagIzzMinusIxxOverIyy + rotForce.y * oneOverDiagIyy) * RKh<br />	; rotVel1.z = rotVel.z + (rotVel.x * rotVel.y * diagIxxMinusIyyOverIzz + rotForce.z * oneOverDiagIzz) * RKh<br />	; rotVel = rotVel1<br /></code></pre><br />where RKh = TimeStep, and the diagBlah values are speedups based on our DSpace Inertia Tensor (vector) components - this will make sense when we look at the RigidBody.Init method :)<br /><br />That&#039;s it - now we have a new Position, Orientation, Linear Velocity and Angular Velocity which our body will be in at the END OF THE TIMESTEP, ie, this is the new proposed physical state of our body at the end of the current timestep, assuming that there are no collisions we would accept this new state as our current state, and we&#039;re ready to make another timestep.<br /><br />The equations used in the RK4 integrator are extremely similar to these ones, and we&#039;ll look at them in the next post, before digging into the nuts and bolts of that DSpace stuff.<br />What I really wanted you to notice is the ORDER of the operations, and how each derivative feeds into the next...<br /><br />#1 - First we calculated Forces, both linear and angular, both internal and external.<br />#2 - LINEAR Then we updated Position according to Velocity and Time<br />#3 - LINEAR Then we updated Velocity according to Acceleration (via Force) and Time<br />#4 - ANGULAR Then we updated Orientation according to Angular Velocity and Time<br />#5 - ANGULAR Then we updated Angular Velocity according to Angular Acceleration (via Angular Force) and Time<br /><br />If you note that the internal forces are due to the velocities, then you should see a closed loop of these five steps - we could imagine step 6 is to recalculate the forces, which is the same as step 1.<br /><br /><br /></div>
    <div class="meta">Posted on 2010-09-06 11:14:02 by Homer</div>
   </div>
   <div class="post" id="post-213077">
    <div class="subject"><a href="#post-213077">Re: RK4</a></div>
    <div class="body">Here is a simplification of the steps involved in RK4 integration:<br /><div class="quote"><br />RKInit :<br />pos0 = pos;<br /><br />RKStep1 :<br />acc1 = force * (h / mass / 2.0);<br />vel1 = vel;<br />pos += vel1 * (h / 2.0);<br />vel += acc1;<br /><br />RKStep2 :<br />acc2 = force * (h / mass / 2.0);<br />vel2 = vel;<br />pos = pos0 + vel2 * (h / 2.0);<br />vel = vel1 + acc2;<br /><br />RKStep3 :<br />acc3 = force * (h / mass);<br />vel3 = vel;<br />pos = pos0 + vel3 * h;<br />vel = vel1 + acc3;<br /><br />RKStep4 :<br />acc4 = force * (h / mass / 2.0);<br />pos = pos0 + (vel1 + 2.0 * (vel2 + vel3) + vel) * (h / 6.0);<br /></div><br /><br />It&#039;s a bit more complicated because we have to deal with Angular stuff as well as this Linear stuff.<br />But essentially we can use the same logic.<br />Also, we must calculate the (combined internal and external) Forces just before each RK step.<br /><br /></div>
    <div class="meta">Posted on 2010-09-08 02:44:48 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=30109&amp;page=1" style="">&laquo;</a><a href="../?id=30109&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="30109" /><input type="number" name="page" min="1" max="4" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=30109&amp;page=4">&gt;</a><a href="../?id=30109&amp;page=4">&raquo;</a></form>  </div>
 </body>
</html>