<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30109" />
  <link rel="prev" href="../?id=30109&amp;page=3" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=30109">Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=30109&amp;page=1" style="">&laquo;</a><a href="../?id=30109&amp;page=3" style="">&lt;</a><input type="hidden" name="id" value="30109" /><input type="number" name="page" min="1" max="4" step="1" value="4" onchange="this.form.submit();" /></form>   <div class="post" id="post-213119">
    <div class="subject"><a href="#post-213119">Re: Super-Size Me</a></div>
    <div class="body">Spent a couple of hours over the weekend changing all my physics and related math support code, replacing all references to &#039;Vec3&#039; with a new structure called &#039;Vector&#039;, whose definition can be either single or double precision. Also, all references to &#039;real4&#039; and &#039;real8&#039; have been replaced with &#039;SCALAR&#039;:<br /><br /><pre><code><br />;We can use either single or double precision...<br />ifndef USE_DOUBLE_PRECISION<br />&nbsp; SCALAR typedef real4<br />else<br />&nbsp; SCALAR typedef real8<br />endif<br /><br />;The 3D Vector struct used for Physics depends on our chosen Precision <br />Vector struct<br />	x SCALAR ?<br />	y SCALAR ?<br />	z SCALAR ?<br />	w SCALAR ?		;This element is not normally used by 3D vectors, but acts as Alignment Padding<br />Vector ends<br /></code></pre><br /><br />This is probably overkill, but it does extend double-precision all the way through to the Matrix support code, which will be important for some parts of the new physics engine, especially for calculating the inertia tensor of an arbitrary mesh entity.<br />I also noted that the Bullet physics engine uses the tensor of a Box to approximate basically all of its shapes, even when the shape has a known tensor - why? The author claims that A) it doesn&#039;t make much difference to the simulation, and B) that due to his engine using a &#039;margin&#039; to expand shapes (used in the EPA fine collision algorithm, I believe) that it&#039;s difficult to calculate tensors for composite shapes (even for something as simple as a capsule), I don&#039;t accept either of these excuses (what the hell does an expanded collision hull have to do with the dynamics of the PHYSICAL BODY???)<br /><br /></div>
    <div class="meta">Posted on 2010-09-12 10:35:04 by Homer</div>
   </div>
   <div class="post" id="post-213191">
    <div class="subject"><a href="#post-213191">Re: Advancing the physics simulation for more efficient collision handling</a></div>
    <div class="body">It seems like &quot;most&quot; of the people who work with physics and who understand the math on a far deeper level than myself are not actually programmers.. let&#039;s see why.<br /><br />The typical algorithm for multibody physics with collision detection goes something like this:<br /><br /><div class="quote"><br />#1 - Integrate the entire system of bodies forward in Time by one whole TimeStep, thus calculating a &quot;proposed new state&quot; for the entire system.<br /><br />#2 - Check for Collisions, and assuming there are any, find the earliest time of impact between any two bodies.<br /><br />#3 - Integrate the entire system forwards again - but this time, to the earliest time of impact, which is somewhere within the current TimeStep.<br /><br />#4 - Resolve the Collision and terminate, returning the actual time we advanced by, ie, our zero-based time of impact..... or alternatively, repeat the sequence from Step #1 with whatever &quot;remaining time&quot; we have left in the current TimeStep, rather than a WHOLE TimeStep.<br /><br /></div><br /><br />This seems to be a safe, sane, rational algorithm, right?<br />Well it is, and for LOW NUMBERS OF BODIES, it works just fine.<br />But it&#039;s quite inefficient for higher numbers of bodies - we&#039;re integrating the entire system whenever a collision is detected, but did we really have to? I don&#039;t think so.<br /><br />In fact, we only needed to adjust the bodies involved in the collision, and then re-test those bodies for SUBSEQUENT collisions resulting from resolving of the initial collision... allowing the REST of the Bodies in the simulation to theoretically cruise to the end of the timestep, as they would have if no collisions had occurred.<br /><br /><div class="quote"><br /><br />#3 - Integrate the COLLIDING PAIR of Bodies forwards &nbsp;to their earliest time of impact.<br /><br />#4 - Resolve the Collision, then advance the offending pair of Bodies AGAIN forwards, this time to the END of the current TimeStep (thus calculating a new &quot;proposed state&quot; for these two Bodies) - and then test them for collisions against the entire system (preferably, via accelerated broadphase testing).<br /><br />#5 - If there is subsequent collision resulting from our impact being resolved, goto STEP #2<br />Otherwise, we are DONE - our system is safely integrated to the End of the current TimeStep !!!<br /><br /></div><br /><br /><br />Thank you for flying Homer Brainwaves !!<br /><br /></div>
    <div class="meta">Posted on 2010-09-20 08:33:24 by Homer</div>
   </div>
   <div class="post" id="post-213200">
    <div class="subject"><a href="#post-213200">Re: Post-collision broadphase testing using a MODIFIED SWEEP</a></div>
    <div class="body"><br />There&#039;s only one catch with this scheme, and it only relates to the &quot;swept tests&quot; that I use as part of my broadphase testing, they work on the assumption that both objects being tested for collision are moving in constant Time - let&#039;s see an example.<br /><br />We have two objects, A and B, and we consider their motion from Normalized time T0 thru T1.<br />Object A is involved in a collision at T=0.3, and we resolve that collision, thus object A has T=0.7 worth of time remaining to move AFTER the collision was resolved.<br />Object B was not going to collide with anything, but since object A has changed direction, we must now perform a test for collision between A from its collision point (T0.3 thru T1) versus B (T0 thru T1).<br /><br />If we perform a &quot;normal swept test&quot; using the conventional algorithm for that, we will in fact be testing A from T=0.3 thru T=1.3 ... versus B from T=0.0 thru T=1.0 <br /><br />There are several solutions that are immediately obvious (to me).<br />Firstly, we could (theoretically, not Actually) move A backwards along its new trajectory by T=0.3, which may well place it in a bad position versus other Bodies.<br />Secondly, we could Scale the derivatives of A by (1.0 - 0.3 = 0.7), for the purposes of the swept test.<br />This means we really need to INTEGRATE it again just for the test, which we would rather avoid.<br />Finally, we can attempt to modify the swept test such that the quanta of B remain &quot;normal&quot;, while the quanta of A are scaled down appropriately.<br /><br />I don&#039;t know of any example of anyone having tried to do this, but it sounds like a fairly common sort of problem in linear algebra - I am not a very good mathematician but tonight I will try to modify the formula for a swept test of two spheres, where one sphere has a Time Dilation, which is effectively a constrained motion, relative to the other.<br />I&#039;m not certain that time dilation is the correct term for this problem, I simply don&#039;t know a better / more appropriate way to describe the constrained time problem.<br /><br />Perhaps a visual aid is in order.<br /><br /> <br /></div>
    <div class="meta">Posted on 2010-09-21 02:35:00 by Homer</div>
   </div>
   <div class="post" id="post-213205">
    <div class="subject"><a href="#post-213205">Re: Modifying the Swept Test for Subsequent Collisions</a></div>
    <div class="body"><br />OK, at the most simple level, we have two swept tests which we&#039;re required to modify for this &#039;time bubble&#039; scheme to work.<br />#1 is the Sphere/Plane Sweep<br />#2 is the Sphere/Sphere Sweep<br /><br />For anyone who hasn&#039;t yet read this, see Page One and Two of this amazing article: http://www.gamasutra.com/view/feature/3383/simple_intersection_tests_for_games.php<br /><br />MODIFYING TEST #1: Swept Test for SUBSEQUENT collisions with Planes<br />Now, please bear in mind that we are working under the assumption that a collision has already occurred during the current timestep, we have adjusted the state of the offending Body to the time of impact (Ui)<br />The first test involves finding the distance from the Plane to the Sphere Origin at times T0 and T1.<br />In our special case, the time at T0 is NOT ZERO - but the time at T1 is still the end of the current timestep. And C0 represents the position of the body at the collision we already resolved, rather than its state at the START of the timestep... let&#039;s presume that d0 and d1 are the respective distances from the plane at the two moments in time that we care for, and r is obviously the sphere radius:<br /><br />Ui = d0-r / d0-d1<br />Ci = ((1-Ui) * C0) + (Ui * C1)<br /><br />The second equation here is a straightforward LINEAR INTERPOLATION of the trajectory.<br />We simply need to adjust the value &quot;1&quot; to account for the normalized time already spent (Ts):<br />X = 1-Ts<br />Ci = ((Ts-Ui) * C0) + (Ui * C1)<br /><br />That wasn&#039;t too hard, was it?<br /><br /><br />Next post we&#039;ll look at how to modify the sphere/sphere sweep to account for time dilation.<br />You should already see a clue given by Gomez in his article, where it states something like &quot;since Time is constant for both bodies, U will have the same value for both bodies&quot; - it should be clear already how we will proceed, but I don&#039;t want to work on the presumption that one of the two bodies has never been involved in a collision during this timestep - it&#039;s possible that BOTH bodies were already involved in collisions, and have different &quot;starting times&quot;... This will allow us to consider &quot;shock propagation&quot; examples which would otherwise be HUGELY expensive to resolve (using a typical iterative solver).<br />This stuff clearly relates to Stacking and MicroCollisions, topics which are avoided by other authors due to the notorious stability issues that can arise (friction can appear to be ignored, for example, if we don&#039;t properly handle subsequent collision within the same timestep).<br /><br /></div>
    <div class="meta">Posted on 2010-09-21 22:19:31 by Homer</div>
   </div>
   <div class="post" id="post-213231">
    <div class="subject"><a href="#post-213231">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body">Semi-related to this topic:<br />Bullet has released version 2.77, which includes some early OpenCL and DirectCompute PhysX effects:<br />http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?t=5681<br /><br />What I find especially interesting is how they tried to integrate the CPU and GPU routines into a single framework in a very seamless way. They can basically &#039;hot-plug&#039; CPU or GPU routines into any stage of the physics simulation.</div>
    <div class="meta">Posted on 2010-09-29 02:08:48 by Scali</div>
   </div>
   <div class="post" id="post-213232">
    <div class="subject"><a href="#post-213232">Re: Biting the Bullet</a></div>
    <div class="body"><br />That&#039;s interesting, since they deprecated the gpu stuff in Bullet 2.75.<br />Reading back from the gpu is prohibitively slow in a realtime 3D simulation, because the gpu needs to be completely idle, effectively stalling any pending rendering operations. And using the gpu to accelerate physics in a realtime 3D simulation is only viable when the gpu is not doing much - again, not suitable for Bullet&#039;s stated purpose as a game-oriented physics engine.<br /><br />I am sure that the gpu is valuable for heavy-duty number crunching, but Bullet is NOT a high-quality physics engine, its main aims are speed and &#039;believable&#039; results. So I don&#039;t see a lot of Bullet users opting to use the gpu for this purpose.<br /><br />In regards to Bullet&#039;s continued support of the Open Source community, I note that the sourcecode for the CUDA module is not Erwin&#039;s work - its copyright notice states that it belongs to Sony Corporation!!<br />We&#039;ve learned recently that &#039;Open-Sourced&#039; has a very rubbery meaning in the corporate sector.<br />As far as I know, it&#039;s the ONLY submission to come from a corporate entity.<br /><br />In v2.75, this module was located in the Extras folder - is it still in that folder?<br /><br /><br /><br />Today I&#039;m trying to make hard decisions about NarrowPhase collision detection and contact generation - Bullet typically uses a GJK variant to generate exactly ONE contact per frame, so it can take FOUR FRAMES to generate enough contacts for stable stacking, for example.<br />This is not so bad since Bullet uses variable timesteps (the next collision dictates thesize of the next timestep), however it&#039;s a poor approximation of a true Contact Manifold... it would be better if it attempted to detect ALL contacts during a frame, not just &quot;the deepest contact from the earliest collisionpair&quot;.<br />And when it&#039;s not using a GJK-based narrowphase, it&#039;s performing a bruteforce test of ALL VERTICES in a pair of Bodies, ignoring any chance to optimize the testing based on knowledge of the geometry and orientations.<br />Furthermore, as previously mentioned, Bullet uses the inertia tensor of a Box for ALL SHAPES !!!<br />This is just wrong, and leads to quite incorrect dynamics for things like Cones (or any shape which is not &quot;well-balanced&quot;).<br />The system I&#039;m working on supports COMBINING rigid bodies into aggregates with accurate tensors.<br />Bullet is simply not capable of this kind of thing... it&#039;s a &quot;BSpace-based&quot; simulator, which expects that&nbsp; its tensor is Diagonal in bodyspace (the center of mass of any Body coincides with its bodyspace origin, and the body is oriented such that its mass is equally distributed over its major axes).<br />Broadphase testing is accelerated via a dynamic aabb tree, but the heuristic used guarantees that the tree is a LEAFY, BINARY one, with no mechanism for maintaining any semblence of balance, it can and does lead to results that are WORSE than simply bruteforcing every possible pair!<br />I&#039;m using an Icoseptree heuristic, based on some exhaustive testing and comparison of various possible heuristics... any Node can contain bodies, so we don&#039;t end up with large bodies in the leaves along with smaller ones, and when traversing (querying) the tree, we encounter larger proximate bodies earlier in the testing.<br />And I&#039;m leaning toward using knowledge of the shapes to improve the narrow phase, with an EPA-based iterative solver used *only* on COMPLEX POLYTOPES such as PAIRS of Mesh entities.<br />For example, to intelligently test for collision of a Sphere and a Mesh, we can transform the Sphere into the BodySpace of the Mesh, use the GJK Support function to find the closest point on Mesh to the origin of the Sphere, then perform a cheap distance-based test of that point and the sphere.<br />In this case, we are transforming the more simple shape into the space of the more complex one, but other pairs can most efficiently be handled by other means.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2010-09-29 03:33:59 by Homer</div>
   </div>
   <div class="post" id="post-213233">
    <div class="subject"><a href="#post-213233">Re: Splitting Hairs</a></div>
    <div class="body">I&#039;m strongly considering moving all the hardcore physics stuff onto the Game Server, making the server authoritative over collision detection.<br />The client would only need to make eulerstep-based &#039;predictions&#039; about relative motions, and would rely totally on notifications from the Server for collision events, which seems fair since the server is already responsible for issuing &#039;physics state correction&#039; packets for the entities on a client&#039;s screen...<br /><br />This may mean writing SEPARATE PHYSICS ENGINES for the client and server, with the clientside engine being a stripped-down version whose major purpose is to generate nice interpolations of the renderables with respect to Time, noting that rendering framerate is always much higher than physics framerate. The server needs to ship with the game for the purposes of SinglePlayer and Hosted games, but when playing MultiPlayer (which is typical) we don&#039;t need this module to be loaded at all.<br />By offloading more work onto the Server, we reduce the opportunities for CHEATING, as well as freeing up valuable clientside cpu and gpu time for other stuff - like candy for the eyes and the ears ;)<br /><br />It&#039;s also HIGHLY NOTABLE that under this proposed scheme, the Server doesn&#039;t actually need to render ANYTHING AT ALL (it doesn&#039;t even need an application window, in theory), so we *CAN* take advantage of gpu-based acceleration in this case!<br /><br /><br /></div>
    <div class="meta">Posted on 2010-09-29 03:45:02 by Homer</div>
   </div>
   <div class="post" id="post-213234">
    <div class="subject"><a href="#post-213234">Re: Biting the Bullet</a></div>
    <div class="body"><div class="quote"><br />Reading back from the gpu is prohibitively slow in a realtime 3D simulation, because the gpu needs to be completely idle, effectively stalling any pending rendering operations.</div><br /><br />I&#039;m not sure if that is still the case anymore. nVidia did a lot of work on making concurrent kernels work more efficiently, and they also use a unified memory model now.<br />Aside from that, I think you can avoid reading back from the GPU by simply using the shared pool, letting the GPU output its data directly to system memory. Since physics doesn&#039;t require such high-bandwidth output, I guess that would be a very nice option.<br /><br /><div class="quote">And using the gpu to accelerate physics in a realtime 3D simulation is only viable when the gpu is not doing much - again, not suitable for Bullet&#039;s stated purpose as a game-oriented physics engine.</div><br /><br />Again, see above regarding concurrent kernels.<br />They key point here is that a GPU has about 10 times the processing power of a high-end CPU.<br />So that would more or less mean that if you sacrifice 10% of graphics performance, you already match the physics processing power of a high-end CPU (dedicated to physics that is, where in practice it also needs to drive other game logic as well as the graphics, audio etc hardware).<br /><br />Take that further, and go with 80% graphics and 20% physics, and you&#039;ve reached the point where your physics are better than possible on any CPU, while still having acceptable graphics performance... etc.<br /><br />At any rate, nVidia&#039;s PhysX work in games so far has already convinced me that GPU-accelerated physics work, and work better than a CPU-based solution (especially since I only have a dual-core... and the only thing it can&#039;t really handle is these physics in games).<br /><br /><div class="quote">In regards to Bullet&#039;s continued support of the Open Source community, I note that the sourcecode for the CUDA module is not Erwin&#039;s work - its copyright notice states that it belongs to Sony Corporation!!</div><br /><br />Erwin Coumans works for Sony Corporation. Bullet is also primarily being developed for the PS3, which is also its biggest market. It plays virtually no role in PC games.</div>
    <div class="meta">Posted on 2010-09-29 05:53:32 by Scali</div>
   </div>
   <div class="post" id="post-213236">
    <div class="subject"><a href="#post-213236">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body">Your post jogged my memory - I do now recall that Erwin works for Sony, I don&#039;t know why that small fact had slipped my mind, other than there being a complete lack of mention of Sony on the Bullet site.<br />And what you say about the gpu being 10x as powerful as the cpu bothers me - where did you pull that number from? Personal experience, or some benchmark?<br /><br />Regardless, as I stated in my smaller secondary post, the gpu IS VIABLE, and especially so for games which rely on the Server to provide the &#039;muscle&#039;. I&#039;ll remain dubious about using the GPU for single-player gaming until I can perform my own testing to prove or disprove that it&#039;s viable, but clearly it&#039;s ideal for a client/server topology.<br /><br />I&#039;m still inclined to use Spheres rather than Boxes as the broadphase primitive for collision detection, noting that I then adopt a dynamic aabb tree, where each BoundingSphere is wrapped in a box of fixed size... best of both worlds, methinks.<br /><br />And I still lean toward detecting as many contacts per frame as possible, and also, handling multiple simulataneous collisionpairs within a single frame.<br /><br />Bullet is used by a more impressive list of game developers than PhysX, for good reasons, but more notably, it is used by Disney Studios for movies !!! In fact, Disney wrote a Bullet plugin for MAYA, to allow Maya users to replace the physics engine when rendering dynamic animated scenes.<br />I think you&#039;ll find that there&#039;s no PS3 version of Maya for developers, so they&#039;re rendering cutscenes on a PC or MAC, and just using the PS3 to play the movie.. not leveraging the PS3 for physics in this case.<br /><br />For the record, I think that PhysX is absolute junk, there&#039;s no way I would consider using it for commercial stuff, nVidia certainly have not tried very hard there... even if the sourcecode WAS available, I doubt that there&#039;s anything in there I&#039;d be interested in.<br />For me, the main value of Bullet is not the engine, nor the fact that its sourcecode is open, but that it attracts the attention of so many likeminded programmers, and gets them talking to each other, trading ideas both on the Bullet forum and even more outside of it. I&#039;ve learned tonnes more from these simple exchanges of information than I have from any books, whitepapers or sourcecode.<br /></div>
    <div class="meta">Posted on 2010-09-30 01:41:40 by Homer</div>
   </div>
   <div class="post" id="post-213237">
    <div class="subject"><a href="#post-213237">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body"><div class="quote"><br />And what you say about the gpu being 10x as powerful as the cpu bothers me - where did you pull that number from? Personal experience, or some benchmark?</div><br /><br />Those are the theoretical FLOPS ratings.<br />A high-end 6-core Intel CPU will rate around 135 GFLOPS.<br />The GTX480 is rated at about 1.3 TFLOPS, and the Radeon 5870 is rated at 2.7 TFLOPS(!).<br /><br />Also, recently Intel made a study trying to debunk these claims of GPU manufacturers, and their conclusion was &quot;They&#039;re only 14x faster than a CPU in most practical situations&quot; (practical being cherry-picked by Intel obviously). After Intel realized what they&#039;d just said, they felt pretty stupid about publishing the study :)<br />So even Intel agrees, GPUs are much faster than CPUs :)<br />See here: http://www.tomshardware.com/news/GPU-CPU-Kernel-CUDA-App,10735.html<br /><br /><div class="quote">Regardless, as I stated in my smaller secondary post, the gpu IS VIABLE, and especially so for games which rely on the Server to provide the &#039;muscle&#039;. I&#039;ll remain dubious about using the GPU for single-player gaming until I can perform my own testing to prove or disprove that it&#039;s viable, but clearly it&#039;s ideal for a client/server topology.</div><br /><br />Why? When things like PhysX and now Bullet already show that you can easily combine graphics and physics workloads on the same GPU?<br /><br /><div class="quote">Bullet is used by a more impressive list of game developers than PhysX</div><br /><br />Is it? I can&#039;t name even ONE game on PC that uses Bullet.<br />I own a few games that use PhysX though.<br />I can&#039;t name any PS3 games either, because I&#039;m not into consoles anyway... but that&#039;s beside the point. On the PC platform, Bullet is used by pretty much nobody, where PhysX is used by quite a few development studios, including what is possibly the biggest game engine at the moment: UnrealEngine3.<br /><br /><div class="quote">For the record, I think that PhysX is absolute junk, there&#039;s no way I would consider using it for commercial stuff, nVidia certainly have not tried very hard there...</div><br /><br />Can we please drop the fanboy dribble? It&#039;s bad enough that I have to listen to this nonsense on enthusiast forums... I would think that assembly programmers were a bit more levelheaded than that... Especially ones that are working with physics themselves.</div>
    <div class="meta">Posted on 2010-09-30 02:19:40 by Scali</div>
   </div>
   <div class="post" id="post-213238">
    <div class="subject"><a href="#post-213238">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body">I have already qualified these statements, Scali, you can search and see, if you like.<br />There are valid reasons for the things I said, it&#039;s not just fanboy dribble, especially since I don&#039;t espouse any successor, or even contender, I said its not good enough and I outlined why, almost 2 years ago I think.<br /><br /></div>
    <div class="meta">Posted on 2010-09-30 06:52:18 by Homer</div>
   </div>
   <div class="post" id="post-213239">
    <div class="subject"><a href="#post-213239">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body">Erwin said he would address the tensor issue if anyone could prove it made a difference - I mentioned cone bodies, which is one of the shapes his engine supports...<br />If nVidia wanted to impress me, they lost their opportunity with the demos that ship with it.<br />I saw a couple of hundred spheres interacting and spheres disappearing from the system because it would cost frames to process them, and said that is not good enough, and it&#039;s not.<br /></div>
    <div class="meta">Posted on 2010-09-30 07:02:07 by Homer</div>
   </div>
   <div class="post" id="post-213240">
    <div class="subject"><a href="#post-213240">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body"><div class="quote"><br />I have already qualified these statements, Scali, you can search and see, if you like.<br />There are valid reasons for the things I said, it&#039;s not just fanboy dribble, especially since I don&#039;t espouse any successor, or even contender, I said its not good enough and I outlined why, almost 2 years ago I think.</div><br /><br />And where can I find that qualification?<br />I doubt it would change my opinion though. I mean, PhysX may not be perfect, but I really haven&#039;t noticed huge differences between the three major APIs, being PhysX, Bullet and Havok. I also really don&#039;t think that your hobby project will be significantly better than any of them, so I don&#039;t really think you&#039;re in a position to call any of them &#039;junk&#039;.<br />Aside from that, saying &quot;nVidia didn&#039;t really try hard&quot; simply shows me that you don&#039;t have a clue what PhysX is, and where it came from.<br />It started as a CPU-only library under the name of NovodeX. Ageia acquired it, added support for their PPU to it, and renamed it to PhysX. Then nVidia acquired it, and added support for their GPU to it. Neither nVidia nor Ageia gave the CPU code all that much attention, but the NovodeX code wasn&#039;t all that bad to start with (and at least you can&#039;t argue about the lack of SSE, because I haven&#039;t seen a single line of SSE code in anything you posted).<br />nVidia is actually actively trying to improve the CPU code. They&#039;ve made SSE the default now, with the 2.8.4 SDK, and for 3.0 they&#039;re planning automated multithreading of PhysX workloads (currently the library is completely thread-safe, but the thread-management itself has to be done by the developer).<br />But I would say that the fact that PhysX works well enough for major games, even without multithreading and SSE is a sign that the algorithms themselves are designed pretty well.</div>
    <div class="meta">Posted on 2010-09-30 12:04:29 by Scali</div>
   </div>
   <div class="post" id="post-213241">
    <div class="subject"><a href="#post-213241">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body">Regarding SSE: my engine *DOES* support SSE optimizations and multithreading, that is not open sourced.<br />I have stated my intentions to write a COMMERCIAL physics engine, I have clearly defined goals.<br />The open-source components of my engine will be posted to the ObjAsm library, but I&#039;m keeping a few things to myself, as I believe I&#039;ve got a few interesting algorithm variants of my own.<br />I&#039;ve invited a few of these people to discuss my ideas in public, but they have not yet chosen to do so, and that is not my problem.<br />I&#039;m quite keen to get some GPGPU based implementation working, but it&#039;s less important to me than the work of improving the algorithms themselves so far, and only in the past days has it occurred to me that I can move the entire workload (more or less) onto the server architecture and thus make it work for me (without it costing 20, 10 or any percentage of gpu time on the client).<br />The algorithms employed by PhysX are simply not good enough, anything more than 600 objects under my tests. Now you&#039;re going to say that a game usually doesn&#039;t need to track 600 physical objects, and that most games only integrate the onscreen entities, yes? Those days are over! That was the state of the art at the GDC 2001 conference (which I attended). That&#039;s a decade old! You are SO RIGHT about the gpu being a viable option, but I think *NOT* for singleplayer games, and I will not change my mind about PhysX, regardless of my high opinion of nVidia (despite the lack of competition, I actually do like this company and what they do, wish I had more hours per day to keep up with them).<br />I have been working with physics ever since that GDC in 2001 and I am still learning every day, and I will never stop looking for improvements to the accepted algos, I think we can always do better and every ten years or so someone proves this to be true. I&#039;m going for my PhD shortly, so you can expect to hear some crazy stuff coming from me over the next few months as I prepare my thesis. Some of my ideas are quite new, others are just variations on existing themes, but I do not see my physics stuff as being some hobbyist work, sorry, you are wrong, I take it seriously, and I aim to make money from it.<br /></div>
    <div class="meta">Posted on 2010-10-01 06:02:34 by Homer</div>
   </div>
   <div class="post" id="post-213242">
    <div class="subject"><a href="#post-213242">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body">I am a huge fan of Havok and Crysis engines, by the way.<br />Erwin worked on Havok before he joined Sony :)<br />Much respect for this man, despite his relaxed attitude toward accuracy in game-oriented physics engines.<br /><br />PS: I will make my SSE math function replacement code available too, just not my hard-won work on optimized collision detection and contact generation. I give away 99% of my code, because I believe in open source. But I need to eat too.<br /></div>
    <div class="meta">Posted on 2010-10-01 06:10:29 by Homer</div>
   </div>
   <div class="post" id="post-213243">
    <div class="subject"><a href="#post-213243">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body"><div class="quote"><br />I&#039;m quite keen to get some GPGPU based implementation working, but it&#039;s less important to me than the work of improving the algorithms themselves so far, and only in the past days has it occurred to me that I can move the entire workload (more or less) onto the server architecture and thus make it work for me (without it costing 20, 10 or any percentage of gpu time on the client).</div><br /><br />Well let me point out the obvious then: there&#039;s no such thing as a free lunch. Instead of taking up GPU time, you&#039;re going to be sending things over the network, having it calculated elsewhere, and then having the results sent back.<br />That is likely going to cause considerably more latency than any readbacks from videomemory. The end-result is the same: the CPU and GPU are waiting for some work to be completed, and cannot reach higher framerates.<br /><br /><div class="quote">The algorithms employed by PhysX are simply not good enough, anything more than 600 objects under my tests. Now you&#039;re going to say that a game usually doesn&#039;t need to track 600 physical objects, and that most games only integrate the onscreen entities, yes?</div><br /><br />Hahaha, you don&#039;t seem to understand me and my personality AT ALL.<br />I&#039;m the biggest technology enthusiast and boundary-pushing advocate you could possibly find (I&#039;m an assembly programmer, a REAL assembly programmer. Someone who doesn&#039;t stop pushing until he has scraped every last bit of performance from his machine in every way possible).<br />No, what I&#039;m going to say is that you&#039;re absolutely right, we need more detail in our physics.<br />I&#039;m also going to say that you are absolutely WRONG about PhysX.<br />On my machine it can manipulate hundreds of thousands objects in realtime. Which is why it can also accurately model things like soft bodies, cloth and fluids, by using very detailed particle simulations. Something that CPUs simply cannot do in realtime, no matter how optimized your routines are...<br />Sadly outside of PhysX, nobody seems to do anything other than simple rigidbody and ragdoll physics. That&#039;s so 2001.<br /><br />In fact, pushing boundaries is exactly why I like PhysX. I&#039;ve been a fan of it ever since they introduced the PPU.<br /><br /><div class="quote">(despite the lack of competition, I actually do like this company and what they do, wish I had more hours per day to keep up with them).</div><br /><br />Well, I think you should at least pay a LITTLE attention to nVidia&#039;s Cuda/PhysX work. Because they&#039;ve already shown some nice examples of what their GPUs can do in single-player games.<br /><br /><div class="quote"><br />I have been working with physics ever since that GDC in 2001 and I am still learning every day, and I will never stop looking for improvements to the accepted algos, I think we can always do better and every ten years or so someone proves this to be true.</div><br /><br />I agree, there&#039;s always something that can be done better, you should never stop searching, else you&#039;re not going to find it.<br /><br /><div class="quote">but I do not see my physics stuff as being some hobbyist work, sorry, you are wrong, I take it seriously, and I aim to make money from it.</div><br /><br />Fair enough, but at the very least, it&#039;s going to be difficult as a single developer to compete with a team of specialists at nVidia, Intel or Sony.</div>
    <div class="meta">Posted on 2010-10-01 06:19:30 by Scali</div>
   </div>
   <div class="post" id="post-213245">
    <div class="subject"><a href="#post-213245">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body">With respect to network latency in physics simulations, see the work of Glen Fiedler (Australian game programmer based in LA) who has written extensively on this very subject, and proved to me that network latency is not the huge bottleneck that it appears to be, since the client can predict physics and be sent periodic corrections in order to remain synchronized and to prevent cheating. In a game simulation where there is a server that is authoritative, there will always be &quot;heartbeat packets&quot; to keep the clients in synch, Glen suggested a prediction/correction paradigm, I am wiling to extend his ideas, with respect to Visibility on the Client, I suggest that A) euler-based predictions are good enough given that we&#039;ll receive at least three corrections per second, and B) the client only cares about what it can actually see, so the Server can perform visibility determination and send (delta-compressed) corrections for the onscreen entities only... I&#039;ve never heard of anyone else doing anything like this, and I think it warrants closer inspection. The idea came from a cheap and nasty physics simulator called Cyclone which only integrates the onscreen elements (obviously not suitable for most games).<br /><br /><br />I don&#039;t plan on competing directly with any of these companies because I don&#039;t intend to license the physics engine alone to third parties.. I&#039;m picking some of the brightest brains on the planet in respect to physics programming (Drasco, Van den Bergen, Mirtich, Shagam, Chaney, Ericson, Johnson and others).<br />These are the people that are breaking new ground over the past decade, and it is their algorithms that are being adopted by nVidia, Sony and others.<br />There has been an enormous paradigm shift in physics simulation over the past ten years at the algorithmic level, and it&#039;s great stuff, not all of it is completely original (example: EPA is just an extension to GJK, but solves a completely different problem) however there is a lot of great recent work which makes the work of people like Euler look like it is 300 years old (because it is).<br />There has not been much REASON to expand on theoretical physics in the past century or so, because existing models were &quot;good enough&quot;, and speed was never a consideration like it is today.<br />It is only since the advent of ROBOTICS that we divided physics into its component fields, for example, calling numerical integration a field of mathematics in its own right.<br />So &quot;modern physics&quot; can be dated back to around 1968, and I say again its just the past DECADE that we&#039;ve seen an explosion of interest and innovation in the fields of dynamics and &quot;computational geometry&quot; (another relatively new term!).<br />We are witnessing the greatest advance in physics for 300 years, its exciting times!<br />There is still MUCH work to be done, it&#039;s wide open for the discovery of new techniques and advancing existing ones. With respect to the paradox of the expert, there&#039;s more chance of ME finding such things than those names I mentioned! And it costs me nothing to try, and it&#039;s a lot more fun than playing Sudoku :P<br /></div>
    <div class="meta">Posted on 2010-10-01 08:27:23 by Homer</div>
   </div>
   <div class="post" id="post-214519">
    <div class="subject"><a href="#post-214519">Re: Physics 2010 - DSpace, RagDolls, IK/FK,  Advanced Physics</a></div>
    <div class="body">Just stumbled upon an idea while discussing WebGL with a friend of mine:<br />The problem with WebGL is that it&#039;s too difficult for the average web programmer to use. They may be able to write simple JavaScript, but they have no idea about 3D graphics, the underlying math etc.<br /><br />And there currently is little or no middleware available for WebGL. I think there may be a business opportunity in developing a physics library for WebGL. Perhaps something for you to consider?</div>
    <div class="meta">Posted on 2011-07-01 10:27:11 by Scali</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=30109&amp;page=1" style="">&laquo;</a><a href="../?id=30109&amp;page=3" style="">&lt;</a><input type="hidden" name="id" value="30109" /><input type="number" name="page" min="1" max="4" step="1" value="4" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>