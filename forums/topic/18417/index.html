<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>RGB rearrange - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=18417" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=18417">RGB rearrange</a></p>
   <div class="post" id="post-142670">
    <div class="subject"><a href="#post-142670">RGB rearrange</a></div>
    <div class="body">in some gaphcis code i am writing, i am writing functions to rearrange RGB (in a 32 bit ARGB where A doesn't matter at all)<br />i plan on writing 27 routies for each combination of RGB whether it is RRR, GBR etc.. so that each technique can be the fastest possible.. (if somebody can tell me of an elegant way that i wouldn't have to write so much code go ahead please :) )<br /><br />anyhow my first (non MMX attempt was doing a pixel was this) (this is 0RGB to 0RRR )<br /><br />mov eax, <br />mov ebx,eax  <br />shr ebx,16       ; ebx now = 0/0/A/R/<br />mov bh,bl         ;ebx now = 0/0/R/R<br />xor ax,ax          ; strip out the green and blue (any faster way?)<br />or  eax,ebx      ;combine to make /A/R/R/R<br />mov , eax<br /><br />i don't know if that is the most optomised, i'd be interested in peoples perspective.. also are single byte moves like mov bh,bl slow technique in modern processes or is that fine?<br /><br />any my first attempt at it in mmx is<br /><br />mov ecx, numpixels<br />			shr ecx, 1             ;//since we process 2 pixels at a time<br />			mov esi, pSource<br />			mov edi, pDest <br />			<br />			<br />			movd   mm0, redmask<br />			movq   mm2,mm0<br />			psllq  mm2, 32<br />			por    mm2,mm0    ; //double up the mask into 64 bits so it can be applied to 2 pixels at a time<br />							 //MM2 contains mask 00FF0000 00FF0000 (basically when added, it just retains the red<br />		loopperRRR:<br />			movq   mm0,  ; //grab the 2 pixels  ARGB ARGB<br />			pand   mm0,mm2    ; //now mm0 just contains 2 pixels with just the red channel so 0R00 0R00<br />			movq   mm1,mm0    ; //mm1 contains a copy of that<br />			psrld  mm1,8     ; //move the red in both pixels into the green so mm1 contains 00R0  00R0<br />			por    mm1,mm0   ; //combine with original so mm1 contains 0RR0 0RR0<br />			psrld  mm0,16      //take original and shift red into the blue position so mm0 is 000R 000R<br />			por    mm1,mm0     //combine for our result of 0RRR 0RRR<br />			<br />			//pxor mm1,mm1<br />			movq  ,mm1<br />			add edi, 8<br />			add esi, 8<br />			<br />			dec ecx<br />			jnz loopperRRR<br />			<br />			mov ecx, numpixels<br />			and ecx, 1               ;//since we process 2 pixels at a time. if its an odd number then we got to do the last pixel<br />									  //otherwise we skip it<br />			<br />						<br />			jz skipOddpixelRRR<br />			mov eax, <br />			mov ebx,eax<br />			shr ebx,16<br />			mov bh,bl<br />			xor ax,ax<br />			or  eax,ebx<br />			mov , eax<br />			emms<br /><br />		skipOddpixelRRR:<br />			}</div>
    <div class="meta">Posted on 2004-06-02 00:41:36 by klumsy</div>
   </div>
   <div class="post" id="post-142677">
    <div class="subject"><a href="#post-142677">RGB rearrange</a></div>
    <div class="body"><div class="quote">are single byte moves like mov bh,bl slow technique in modern processes or is that fine?</div><br /><br />Yes, if you write to a partial register, like bh here, the CPU will internally allocate a new register for it. Then if you access a larger version later, bx or ebx, then it has to combine that new register with the old register, which causes a pipeline flush, so a rather large penalty.</div>
    <div class="meta">Posted on 2004-06-02 01:47:11 by Scali</div>
   </div>
   <div class="post" id="post-142724">
    <div class="subject"><a href="#post-142724">RGB rearrange</a></div>
    <div class="body">so would it be quicker acutally to have more instructions, i.e to mov the whole ebx register to another, so a shift and then add them back together than to do the mov,bh,bl<br /><br />what about the MMX version<br /><br />movq mm0, ; //grab the 2 pixels ARGB ARGB<br />pand mm0,mm2 ; //now mm0 just contains 2 pixels with just the red channel so 0R00 0R00<br />movq mm1,mm0 ; //mm1 contains a copy of that<br />psrld mm1,8 ; //move the red in both pixels into the green so mm1 contains 00R0 00R0<br />por mm1,mm0 ; //combine with original so mm1 contains 0RR0 0RR0<br />psrld mm0,16 //take original and shift red into the blue position so mm0 is 000R 000R<br />por mm1,mm0 //combine for our result of 0RRR 0RRR<br />//pxor mm1,mm1<br />movq ,mm1<br /><br />do you think there would be a faster way, maybe with some of those funkcy pack and unpack routines? (they give me headaches) i can't see uses for them other than packing and unpacking 15,16 bit graphics which i don't care for , working fully in 32 bit</div>
    <div class="meta">Posted on 2004-06-02 17:31:13 by klumsy</div>
   </div>
   <div class="post" id="post-142736">
    <div class="subject"><a href="#post-142736">RGB rearrange</a></div>
    <div class="body">A couple of ideas:<br /><br />MMX<br /><pre><code><br />mask dq 00ff000000ff0000h<br /><br />movq mm0,&#91;esi&#93;	; mm0 &lt;- 00RRGGBB 00RRGGBB<br />pand mm0,mask	; mm0 &lt;- 00RR0000 00RR0000<br />movq mm1,mm0<br />psrld mm1,8	; mm1 &lt;- 0000RR00 0000RR00<br />por mm0,mm1	; mm0 &lt;- 00RRRR00 00RRRR00<br />psrld mm1,8	; mm1 &lt;- 000000RR 000000RR<br />por mm0,mm1	; mm0 &lt;- 00RRRRRR 00RRRRRR<br /></code></pre><br /><br />I don't think pack/unpack is any use here but maybe it can be done..<br /><br />SSE2 version:<br /><br /><pre><code><br /><br />align 16<br />mask dq 00ff000000ff0000h<br />     dq 00ff000000ff0000h<br /><br />movdqa xmm0,&#91;esi&#93;		; change to movdqu if data isn't aligned on 16-byte boundary<br />pshufhw xmm1,xmm0,11111111b	; xmm1 hi &lt;- 00RR00RR00RR00RR<br />pshuflw xmm1,xmm0,11111111b	; xmm1 lo &lt;- 00RR00RR00RR00RR<br />movdqa xmm0,xmm1<br />psllw xmm0,8<br />por xmm0,xmm1<br />pand xmm0,mask			; could be removed if you don't care about the top byte not being 0<br />movntdq &#91;edi&#93;,xmm0<br /></code></pre><br /><br />Neither has been tested but should be ok..</div>
    <div class="meta">Posted on 2004-06-02 19:41:36 by stormix</div>
   </div>
   <div class="post" id="post-142744">
    <div class="subject"><a href="#post-142744">RGB rearrange</a></div>
    <div class="body">thanks for the advice, do you know in msvc++ how to specify a variable to be dq? (like you do in your mask.. i had my code double it up because i couldn't work out how to do that.<br />if your first example, would it be any more efficent than my code? just curious.. i just see its just different with the shifting 8 both times rather than 16 on one..<br /><br />i've been reading uptoday about SSE, and SSE2 and have been thinking its the way to go..<br />also with those SSE commands i wouldn't have to write 27 different versions of optomised routines for the different RGB combinations but rather just mess with the shuffle masks, which is hugely advantaged.</div>
    <div class="meta">Posted on 2004-06-02 21:40:30 by klumsy</div>
   </div>
   <div class="post" id="post-142747">
    <div class="subject"><a href="#post-142747">RGB rearrange</a></div>
    <div class="body">for the MMX version, i have decided to give up on writing 27 different routines optomisd for each combination but rather try to write one routine that can rearange to any combination..<br /><br />my idea is that for each channel, i will have to shift the input left or right by so much, then apply a mask to filter out just that channel, then use or to combine the 3 channels.. the amount for shifting can be calculated outside the loop so that is no problem<br /><br />   so the RedMask would be 00FF000000FF0000<br />so the GreenMask would be 0000FF000000FF00<br />so the BlueMask would be    000000FF000000FF<br /><br />for working on the rightchannel.. i'd have to take the input<br />if it is Red, i would do a shift left by 0,<br />if blue, shifg left by 8<br />iif green , shift left, 16<br /><br />so those amounts would be precalculated outside of the loop called something like<br /><br />REDSHIFTLEFTAMOUNT = (above logic)<br /><br />for the green channel, sometimes it has to be shifted left and right so i think i might have to do both<br /><br />so if green is the destination then <br />GREENSHIFTLEFTAMOUNT = 0 ,GREENSHIFTRIGHTAMOUNT = 0<br />if red<br />GREENSHIFTRIGHTAMOUNT=0,GREENSHIFTRIGHTAMOUNT = 8<br />if blue<br />GREENSHIFTRIGHTAMOUNT = 8, GREENSHIFTRIGhTAMOUNT = 0<br /><br />and for blue position<br />if red<br />BLUESHIFTRIGHTAMOUNT = 16<br />if green<br />BLUESHIFTRIGHTAMOUNT = 8<br />if blue <br />BLUESHIFTRIGHTAMOUNT = 0<br /><br /><br />then inside the loop you would do something like<br /><br />redchannel     =   (original &lt;&lt; REDSHIFTLEFTAMOUNT) &amp; REDMASK<br />bluechannel   =   (original &gt;&gt; BLUESHIFTRIGHTAMOUNT) &amp; BLUEMASK<br />greenchannel =  ((original &lt;&lt; GREENSHIFTLEFTAMOUNT)&gt;&gt;GREENSHIFTRIGHTAMOUNT) &amp; BLUEMASK<br />endpixel = redchannel | bluechannel | greenchannel<br /><br />now i go and try to implement it in MMX... man i love the look of that SSE2 though</div>
    <div class="meta">Posted on 2004-06-02 22:53:38 by klumsy</div>
   </div>
   <div class="post" id="post-142762">
    <div class="subject"><a href="#post-142762">RGB rearrange</a></div>
    <div class="body">here is my first attempt at implementing the algorithm above<br /><br />		__int64 redleftshiftamount = (((int)m_fRedChannel)-1)* 8; // so red 0, green 8, blue 16<br />		__int64 bluerightshiftamount  = (3 -(int)m_fBlueChannel) * 8;<br />		__int64 greenleftshiftamount  = 0;<br />		__int64 greenrightshiftamount = 0;<br />		if (m_fGreenChannel == 1) greenrightshiftamount = 8;<br />		if (m_fGreenChannel == 3) greenleftshiftamount  = 8;<br />		__int64 redmask   = 0x00FF000000FF0000;<br />		__int64 greenmask = 0x0000FF000000FF00;<br />		__int64 bluemask  = 0x000000FF000000FF;<br />			<br />			pDest = (DWORD*)pOutput-&gt;GetBuffer();		<br /><br />			__asm {<br />			<br />			mov esi, pSource<br />			mov edi, pDest <br />			<br />			mov ecx, numpixels<br />			shr ecx, 1<br />		<br />			movq  mm5, redmask  ;// mm5 = redmask<br />			movq  mm6, greenmask ;// mm6 = greenmask;<br />			movq  mm7, bluemask;//mm7<br />			movq  mm3,greenleftshiftamount;//green left shift amount<br />			movq  mm4,greenrightshiftamount;//green right shift amount<br />			<br />		<br />	AllLooper:	<br /><br />			movq  mm0,     ;//original byte (RED Channel)	<br />			movq  mm1,mm0       ;//MM1 = green channel<br />			pslld mm0,redleftshiftamount;//move whatever channel should be into red channel position<br />			movq  mm2,mm1		;//mm2 = blue channel<br />			pslld mm1,mm3		; //half of the green channel move into positsion<br />			pand  mm0,mm5		;//mm0 is now complete red channel (redmask has been applied)<br />			psrld mm1,mm4		;//the other half of moving into the green channel<br />			psrld mm2,bluerightshiftamount		;//move blue channel into correct place<br />			pand  mm1,mm6		;//mm1 is now complete green channel<br />			pand  mm2,mm7       ;//blue is now complete<br />			por   mm0,mm1<br />			por   mm0,mm2<br />			movq ,mm0<br /><br />			add edi, 8<br />			add esi, 8<br />			<br />			dec ecx<br />			jnz AllLooper<br />			emms<br />			}<br /><br />i don't know where to start from optomising it here.. i tried putting the bluerightshiftamount into eax,  and doin the psrld mm2,eax but it didn't produce the<br />right results. i'm targing specically p2,p3 with this (cause i'll probably make a SSE/2 one for newer ones).. but for now it is also p4.. i tried to arrange the instruction the way i would in the olden days some.. but i think that may be pointless as newer pentiums will do that anyway?</div>
    <div class="meta">Posted on 2004-06-03 03:01:15 by klumsy</div>
   </div>
  </div>
 </body>
</html>