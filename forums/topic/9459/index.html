<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Suggestions on remove FileName - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=9459" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=9459">Suggestions on remove FileName</a></p>
   <div class="post" id="post-69973">
    <div class="subject"><a href="#post-69973">Suggestions on remove FileName</a></div>
    <div class="body">Hello everybody,<br /><br />Any help, opinions, suggestions on this much appreciated:<br /><br />I wrote a little program that deletes files and overwrites the file area (with cz's, what else?:)).   When I run a standard undelete program these files can all be recovered but of course their contents are just a string of cz's.  I'm happy with this but then I see that the file's name is sometimes suggestive making it easy to guess at what the contents were.  It wouldn't be difficult, for example, to guess at the original contents of a file called <em>How to be a better Chicken Thief.html</em>.<br /><br />I decided to get rid of the file name by renaming the file using <strong>MoveFile</strong> but after some trials I gave up on this idea.  It seems this api doesn't just move the file.  It first copies it then deletes it leaving the old file name available for undeletion.  <br /><br />The question:  does anybody know of any api, procedure or link to any info that might help.  Don't be deceived, I know very little about this part of the file system and <em>any</em> knowledge you have, no matter how trivial would be helpful.<br /><br />I searched google for things like 'Remove FAT enty' and remove file name.  The first search increased my knowledge of the file system and the second came up with variations of DeleteFile.<br /><br />Therefore even a suggestion of what to search for would be most helpful:)<br /><br />best regards,<br /><br />czDrillard</div>
    <div class="meta">Posted on 2002-12-09 01:54:42 by czDrillard</div>
   </div>
   <div class="post" id="post-70001">
    <div class="subject"><a href="#post-70001">Suggestions on remove FileName</a></div>
    <div class="body">this will be a really low-level hack, you shouldn't forget all the FAT32 (since Win98) and NTFS (since NT) guys.<br /><br />By the way... what happens if you delete a file, and immediately create a new one of the same size?<br />Maybe windows places it at the same location in the FAT?</div>
    <div class="meta">Posted on 2002-12-09 04:41:29 by beaster</div>
   </div>
   <div class="post" id="post-70028">
    <div class="subject"><a href="#post-70028">Suggestions on remove FileName</a></div>
    <div class="body"><pre><code><br />/*--begin wipe.c--*/<br /><br />/*Version 2.30*/<br /><br />#include &lt;stdio.h&gt;<br />#include &lt;dos.h&gt;<br />#include &lt;dir.h&gt;<br />#include &lt;time.h&gt;<br />#include &lt;io.h&gt;<br />#include &lt;fcntl.h&gt;<br />#include &lt;sys\stat.h&gt;<br /><br />#define RAND_MAX	223	/*Don't change this; used for generating rand. char*/<br /><br />/*Use the NUMPASSES define to change the number of<br />overwrites the program will perform.  Nine passes is<br />the DoD standard for sensitive data*/<br /><br />#define	NUMPASSES	9<br /><br />void flushcache &#40;FILE *fptr&#41;<br />&#123;<br />	union REGS regr;<br /><br />	fflush&#40;fptr&#41;;	/*Flush buffer*/<br /><br />	regr.h.ah = 0x0D;/*Perform disk reset to ensure that a write*/<br />	int86&#40;0x21, &amp;regr, &amp;regr&#41;;/*behind disk cache is flushed*/<br />&#125;<br /><br />char badfilechar &#40;unsigned char ch&#41;<br />&#123;<br />/*This function checks to see if a character<br />is valid as part of a DOS filename.  If it is<br />valid, the function returns 0.*/<br /><br />	if  &#40;ch &lt;= 0x20 ||<br />		 ch == 0x22 ||<br />		 ch &gt;= 0x2a &amp;&amp; ch &lt;= 0x2c ||<br />		 ch &gt;= 0x2e &amp;&amp; ch &lt;= 0x2f ||<br />		 ch &gt;= 0x3a &amp;&amp; ch &lt;= 0x3f ||<br />		 ch &gt;= 0x5b &amp;&amp; ch &lt;= 0x5d ||<br />		 ch == 0x7c&#41;<br />			return 1;<br /><br />	return 0;<br />&#125;<br /><br />long round &#40;float inpnum&#41;<br />&#123;<br />/*Rounds a floating point number to the nearest whole number*/<br />	float rnd;<br />	rnd = inpnum - &#40;long&#41;inpnum;<br />	if &#40;rnd &lt; .5&#41;<br />		return&#40;&#40;long&#41;inpnum&#41;;<br />	else<br />		return&#40;&#40;long&#41;inpnum + 1&#41;;<br />&#125;<br /><br />int main &#40;int argc, char *argv&#91;&#93;&#41;<br />&#123;<br />	FILE *fptr;<br />	int x;<br />	float percent;<br />	unsigned long rate, y;<br />	unsigned char c, randname&#91;MAXFILE&#93;=&#123;0&#125;, fname&#91;MAXPATH&#93;=&#123;0&#125;;<br />	unsigned char drive&#91;MAXDRIVE&#93;, newfn&#91;MAXPATH&#93;=&#123;0&#125;, dir&#91;MAXDIR&#93;=&#123;0&#125;;<br />	time_t seed;<br />	struct ffblk fb;<br />	struct ftime ft = &#123;0,0,0,1,1,0&#125;;/*time and date of 01-01-1980 00&#58;00&#58;00*/<br /><br />	if &#40;argc != 2&#41;<br />	&#123;<br />		printf&#40;&quot;\nSyntax&#58;\n\n\tWIPE filename.ext\n&quot;&#41;;<br />		return 1;<br />	&#125;<br /><br />	else if &#40;&#40;findfirst&#40;argv&#91;1&#93;, &amp;fb, FA_ARCH | FA_RDONLY<br />			| FA_HIDDEN | FA_SYSTEM&#41;&#41; == -1&#41;<br />	&#123;<br />		printf&#40;&quot;\nFile not found\n&quot;&#41;;<br />		return 1;<br />	&#125;<br /><br />	srand&#40;&#40;unsigned&#41;&#40;time&#40;&amp;seed&#41;&#41;&#41;;<br /><br />	fnsplit &#40;argv&#91;1&#93;, drive, dir, NULL, NULL&#41;;<br /><br />	do<br />	&#123;<br />		strcpy&#40;fname, drive&#41;;<br />		strcat&#40;fname, dir&#41;;	/*Create string with complete filename &amp; path*/<br />		strcpy&#40;newfn, fname&#41;;<br />		strcat&#40;fname, fb.ff_name&#41;;<br />		strupr&#40;fname&#41;;<br /><br />		chmod&#40;fname, S_IWRITE&#41;;	/*Make sure file can be written*/<br />								/*to by changing attribs*/<br />		fptr = fopen&#40;fname, &quot;w+&quot;&#41;;<br /><br />		percent=0;	x=1;<br /><br />		while &#40;x &lt;= NUMPASSES&#41;<br />		&#123;<br />			if &#40;fb.ff_fsize &gt;= 32768 &amp;&amp; x == 1&#41;<br />			&#123;<br />				printf&#40;&quot;\nWiping %s 00.0%\x8\x8\x8\x8\x8\x8&quot;, fname&#41;;<br />				rate = round&#40;&#40;&#40;float&#41;fb.ff_fsize*&#40;float&#41;NUMPASSES&#41;/1000.0&#41;;<br />				/*rate is approx. 0.1% of completion; for progress display*/<br />			&#125;<br /><br />			else if &#40;x == 1&#41;<br />				printf&#40;&quot;\nWiping %s&quot;, fname&#41;;<br /><br />			if &#40;x == NUMPASSES&#41;	/*If this is the last pass, use*/<br />				c = 0xF6;		/*character 0xF6 to overwrite the file*/<br /><br />			else if &#40;x%2 == 1&#41; /*If this is pass 1,3,5, or 7, use 0xFF*/<br />				c = 0xFF;      /*to overwrite the file*/<br /><br />			else			/*if pass 2,4,6, or 8, use 0x00 to overwrite*/<br />				c = 0x00;<br /><br />			if &#40;fb.ff_fsize &gt;= 32768&#41;<br />				for &#40;y = 0;y &lt; fb.ff_fsize;y++&#41;<br />				&#123;<br />					fputc&#40;c, fptr&#41;;<br />					if &#40;y % rate == 0 &amp;&amp; y != 0&#41;<br />					&#123;<br />						percent+=.1;<br />						if &#40;percent &lt; 100&#41;<br />							printf&#40;&quot; %04.1f\x8\x8\x8\x8\x8&quot;, percent&#41;;<br />					&#125;<br />				&#125;<br /><br />			else<br />				for &#40;y = 0;y &lt; fb.ff_fsize;y++&#41;<br />					fputc&#40;c, fptr&#41;;<br /><br />			flushcache&#40;fptr&#41;;<br /><br />			rewind&#40;fptr&#41;;/*Set file pointer back to beginning of file*/<br /><br />			x++;<br />		&#125;<br /><br />		fclose&#40;fptr&#41;;<br /><br />		for &#40;x = 0;x &lt; 8;x++&#41;<br />			do<br />				randname&#91;x&#93; = rand&#40;&#41;+33;/*Create a random char btwn 33-255*/<br />			while &#40;badfilechar&#40;randname&#91;x&#93;&#41; == 1&#41;;/*Make sure char is valid*/<br />												  /*for use in filename*/<br />		strcat&#40;newfn, randname&#41;;<br /><br />		rename&#40;fname, newfn&#41;;	/*Rename file to random filename*/<br /><br />		x = open&#40;newfn, O_TRUNC | O_WRONLY&#41;;/*reopen file and set size to 0*/<br /><br />		setftime&#40;x, &amp;ft&#41;;<br /><br />		close&#40;x&#41;;<br />		unlink&#40;newfn&#41;;	/*Delete file*/<br />		printf&#40;&quot;, done.&quot;&#41;;<br />	&#125;while &#40;findnext&#40;&amp;fb&#41; != -1&#41;;<br />	printf&#40;&quot;\n&quot;&#41;;<br />	return 0;<br />&#125;<br /><br />/*--end wipe.c--*/<br /></code></pre></div>
    <div class="meta">Posted on 2002-12-09 07:15:48 by bazik</div>
   </div>
   <div class="post" id="post-70029">
    <div class="subject"><a href="#post-70029">Suggestions on remove FileName</a></div>
    <div class="body">IIRC When a file is deleted from the disk, the clusters are only recoverable<br />until something overwrites the same clusters. I would search for things like<br />'file shredding' / 'secure delete' / etc. There is tons of ways todo such a thing.<br /><br />Well if I would create such a function I would probably do something like the<br />below. This should be done with different variations and passes.<br /><pre><code>&#91;color=sienna&#93;<br />...<br />...<br />inv CreateFileA,ADDR FileName,GENERIC_WRITE,0,0,<br />                OPEN_EXISTING, <br />                FILE_FLAG_SEQUENTIAL_SCAN or \<br />                FILE_FLAG_DELETE_ON_CLOSE or \<br />                FILE_ATTRIBUTE_TEMPORARY,0<br />	mov hFile,eax   &#91;color=green&#93;;&#91;/@-Save file-handle&#91;/color&#93;<br />	mov edi,5       &#91;color=green&#93;;&#91;/@-Number of passes&#91;/color&#93;<br />	inc eax         &#91;color=green&#93;;&#91;/@-Check if the file-handle is valid&#91;/color&#93;<br />@@&#58;	jz @F   &#91;color=green&#93;;&#91;/@-Invalid-filehandle Check / Loop JumpPoint&#91;/color&#93;<br />                &#91;color=green&#93;;&#91;/@-Write junk to file&#91;/color&#93;<br />	inv WriteFile,hFile,JunkBuffer,FileSize,bWritten,0<br />                &#91;color=green&#93;;&#91;/@-Reset position in file&#91;/color&#93;<br />	inv SetFilePointer,hFile,0,0,0<br />	dec edi &#91;color=green&#93;;&#91;/@-Decrease counter&#91;/color&#93;<br />	jnz @B+2&#91;color=green&#93;;&#91;/@-Loop until 0&#91;/color&#93;<br />        &#91;color=green&#93;;&#91;/@-Close/Delete file&#91;/color&#93;<br />	inv CloseHandle,hFile<br /><br />        &#91;color=green&#93;;&#91;/@-Create a file with same size but different filename.&#91;/color&#93;<br />	&#91;color=green&#93;;&#91;@/-This should delete the old file entry in the FAT.&#91;/color&#93;<br />	inv CreateFileA,ADDR NewFileName,GENERIC_WRITE,0,0,<br />    	                CREATE_ALWAYS, <br />        	        FILE_FLAG_DELETE_ON_CLOSE or \<br />            	        FILE_ATTRIBUTE_TEMPORARY,0<br />	mov hFile,eax &#91;color=green&#93;;&#91;/@-Save file handle&#91;/color&#93;<br />	inc eax       &#91;color=green&#93;;&#91;/@-Check if the file-handle is valid&#91;/color&#93;<br />	jz @F         &#91;color=green&#93;;&#91;/@-If handle is invalid then jump&#91;/color&#93;<br />	&#91;color=green&#93;;&#91;/@-Write junk to file&#91;/color&#93;<br />	inv WriteFile,hFile,JunkBuffer,FileSize,bWritten,0<br />	&#91;color=green&#93;;&#91;/@-Close/Delete file&#91;/color&#93;<br />        inv CloseHandle,hFile<br />@@&#58;<br />...<br />...<br />&#91;/color&#93;</code></pre> Thou you need to keep in mind that I havent tested this code. So<br />it may contain some errors. But this should provide a somehwat basis.<br /><br />[<strong>EDIT</strong>]: Bazik, managed to post C bashed code just a couple of minutes before i was done. Dont you just hate when that happens? ( :grin: )</div>
    <div class="meta">Posted on 2002-12-09 07:18:41 by natas</div>
   </div>
   <div class="post" id="post-70032">
    <div class="subject"><a href="#post-70032">Suggestions on remove FileName</a></div>
    <div class="body"><div class="quote"><br /><br />[<strong>EDIT</strong>]: Bazik, managed to post C bashed code just a couple of minutes before i was done. Dont you just hate when that happens? ( :grin: ) </div><br /><br />But I dont have syntax highlighting ;)</div>
    <div class="meta">Posted on 2002-12-09 07:39:51 by bazik</div>
   </div>
   <div class="post" id="post-70039">
    <div class="subject"><a href="#post-70039">Suggestions on remove FileName</a></div>
    <div class="body"><div class="quote"><br />But I dont have syntax highlighting ;) </div><br />Dont hate me because im <span style="font-size:12px><strong>col</strong></span><span style="font-size:18px>OR</span><span style="font-size:12px><em>full</em></span>! ( :grin: )</div>
    <div class="meta">Posted on 2002-12-09 09:02:37 by natas</div>
   </div>
   <div class="post" id="post-70070">
    <div class="subject"><a href="#post-70070">New Observation? OR old news?</a></div>
    <div class="body">Recently I was fooling around with local labels. And I wanted to expand<br />the usability for it. So I tested if there was possible to jump over/below <br />the default jump point. This is not mentioned in the masm help file.<br />Ofcourse for some people this might not be usable, but i think it was. <br />Therefore im posting it for you all to see and comment. If you look at the <br />code above, you'll see the whole picture. <br /><br />What I tried to create above was to use less labels. So therfore I choose <br />to put the compare instruction(jz) for 'invalid-filehandle' on one of the local labels.<br />If I had put the compare instruction above the first local label I would have<br />just jumped and executed the main code, instead of jumping to the end.<br /><br />However this didnt create any problems for the code at all. Except for one thing,<br />each time the loop is executed it will also execute that extra instruction. And this<br />allowed me to skip that instruction. In order to skip an instruction you need to add <br />the size of the instruction located there. Otherwise It will fuck up. ( :tongue: )<br /><pre><code>&#91;color=sienna&#93;<br />@@&#58; jz @F     &#91;color=green&#93;;&#91;/@-Instruction is 2 bytes&#91;/color&#93;<br />    inc edi &#91;color=green&#93;  ;&#91;/@-New jump point&#91;/color&#93;<br />    jnz @B+2  &#91;color=green&#93;;&#91;/@-Jump over the standard jump point @@&#58; by 2 bytes&#91;/color&#93;<br />@@&#58;<br />&#91;/color&#93;</code></pre><br />On a side note I could have just used the '$' and calculated number of bytes<br />to jump from the current location. However, when using local labels, masm<br />calculates the number of bytes from the current location to either the next or <br />last label. So it's easyer and more readable to use the local labels.</div>
    <div class="meta">Posted on 2002-12-09 13:24:30 by natas</div>
   </div>
   <div class="post" id="post-70159">
    <div class="subject"><a href="#post-70159">Suggestions on remove FileName</a></div>
    <div class="body">Thanks very much beaster, bazik and natas:)  Christmas came early.<br /><br />I think now because of your help I am on the right track.  Here is some code I've been playing with.  If I comment out the <em>invoke DeleteFile,ADDR szNewNameBuf</em> line at the end of the proc and call the proc twice the original file names are removed from the FAT and only the 'numbered' file names are displayed.  I don't know why this is so but I'll keep playing with it until it becomes clear.<br /><br />Btw, the following proc is called by a recursive findfirstfile/findnextfile proc which also passes it the file size.  The files for deletion are cut and pasted from the MyDocuments folder to the windows\temp folder.<br /><pre><code><br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />FileDeleteAll proc uses edi FilePath&#58;DWORD,FileName&#58;DWORD,cbFile&#58;DWORD<br /><br />     LOCAL  hFile         &#58;DWORD<br />     LOCAL  dwWrite       &#58;DWORD<br /><br /><br /><br /><br />      xor eax,eax<br />      mov eax,&#91;dwOverWrite&#93;<br />      <br />        .if eax==01h            <br />            invoke ZeroMem,FilePath,ADDR dwSterilize,ADDR dwDisable,ADDR dwNoMem<br />            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />            ;this proc is located in czMem.dll<br />            ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br /><br />        .endif<br /><br />      invoke DeleteFile,FilePath<br />        .if eax==00h<br />            jmp @f<br />  <br />        .endif<br /> <br />       inc dwNewName      ;first part of file name starts at 00000000<br />       invoke RtlZeroMemory,OFFSET szTempPath,256<br />       invoke RtlZeroMemory,OFFSET szNewNameBuf,256<br />       invoke lstrcpy,ADDR szNewNameBuf,FilePath<br />       <br />       mov edi,OFFSET szNewNameBuf<br />       cld<br />       or ecx,-1<br />       xor eax,eax<br />       repne scasb<br />       mov al,5ch                    ;remove filename of original file from path<br />       std<br />       repne scasb<br />       add edi,02h<br />       xor eax,eax<br />       stosd<br />       cld<br />    <br />       invoke dw2hex,dwNewName,ADDR szTempPath<br />       invoke lstrcat,ADDR szNewNameBuf,ADDR szTempPath<br />       invoke lstrcat,ADDR szNewNameBuf,ADDR szExtension<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />;after first iteration file name is 00000001.txt<br />;after second iteration 00000002.txt...etc<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br /><br />       invoke CreateFile,ADDR szNewNameBuf,GENERIC_READ or GENERIC_WRITE,\<br />                         NULL,NULL,CREATE_NEW,NULL,NULL<br />    <br />       mov hFile,eax<br />       cmp eax,-1<br />       jz @f<br /><br />       invoke GlobalAlloc,GMEM_ZEROINIT,cbFile    	<br />       mov hMemory,eax<br />       invoke GlobalLock,hMemory        ;I haven't bothered checking for<br />       mov pMemory,eax                       ;memory errors <br />  <br />       mov edi,pMemory      <br />       xor ecx,ecx<br />       mov ecx,cbFile                             ;size of file<br />       <br />          .if ecx==00h                             ;if size==0, quit<br />             invoke CloseHandle,hFile<br />             invoke GlobalUnlock,pMemory<br />             invoke GlobalFree,hMemory<br />             jmp @f<br />  <br />          .endif<br />          <br />       xor eax,eax<br />       mov ax,7a63h  <br />      @Begin&#58;<br />       stosw                              ;fill memory with cz<br />       sub ecx,02h<br />       cmp ecx,00h<br />       jle @End<br />       jmp @Begin<br />  <br />      @End&#58;<br />       invoke WriteFile,hFile,pMemory,cbFile,ADDR WriteSize,NULL     <br />       invoke FlushFileBuffers,hFile     <br />       invoke CloseHandle,hFile<br />       invoke GlobalUnlock,pMemory<br />       invoke GlobalFree,hMemory<br /><br />       invoke DeleteFile,ADDR szNewNameBuf<br />;**********************************<br />;the line above must be commented out, else the original file name is left<br />;in the FAT and the just created file vanishes without a trace from the system.<br />;**********************************     <br />      @@&#58;<br /><br />     ret <br /><br />FileDeleteAll endp<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br /></code></pre><br />thanks again for the help :alright: <br /><br />best regards,<br /><br />czDrillard<br /><br /><br /><br /><span style="font-size:9px><em>[ code ] tags added</em></span></div>
    <div class="meta">Posted on 2002-12-10 02:48:04 by czDrillard</div>
   </div>
  </div>
 </body>
</html>