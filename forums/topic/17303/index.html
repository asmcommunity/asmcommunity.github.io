<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>My BSP Loader! - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17303" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=17303">My BSP Loader!</a></p>
   <div class="post" id="post-134085">
    <div class="subject"><a href="#post-134085">My BSP Loader!</a></div>
    <div class="body">ProbnikGL<br /><br /><a target="_blank" href="http://www.letransit.ee/img/mg/probnikgl.rar">http://www.letransit.ee/img/mg/probnikgl.rar</a><br />Size: 1 762 kbytes<br /><a target="_blank" href="http://www.letransit.ee/img/mg/ui.pk3">http://www.letransit.ee/img/mg/ui.pk3</a> ; problems with unpacking this file<br />Size: 45 kbytes<br /><br /><br />Thats my bsp loader it loads map with light map<br />Archive has source<br />It has console: press ` tilde: ` ~<br />Look image if you dont know where it is :)<br /><a target="_blank" href="http://healthlinks.washington.edu/howto/navigating/tilde.gif">http://healthlinks.washington.edu/howto/navigating/tilde.gif</a><br /><br />/devmap  ; load a map<br />/devmap maps/level<br />/devmap maps/level1<br />/devmap maps/level2<br />/devmap maps/level3<br /><br />/vid_restart ; restart...<br /><br />All variables can be found in *.cfg file<br /><br />*.pk3 files are no &quot;magic packed file&quot; its just renamed ZIP! file<br /><br />Have phun<br /><br />Please feedback ;)</div>
    <div class="meta">Posted on 2004-02-18 14:39:53 by zabnik</div>
   </div>
   <div class="post" id="post-134248">
    <div class="subject"><a href="#post-134248">My BSP Loader!</a></div>
    <div class="body">Corrupt archive :( sorry man, the exe extracted ok but some of its dependancies didnt and I just see fullscreen black:(<br /><br />Congrats on completing that anyway :)<br /><br />I ended up deciding not to go with bsp in the end, I'm implementing a hybrid scenegraph and hierarchical arbitrary volumes (osp 2) engine ;)<br />I'm just hooked on the idea of osp2 not mapping empty space, and I love the idea of hierarchical culling .. then there's the ability to add/remove/alter surfaces dynamically in realtime, it's just too hard to make holes in geometry in a bsp..</div>
    <div class="meta">Posted on 2004-02-19 21:58:27 by Homer</div>
   </div>
   <div class="post" id="post-134297">
    <div class="subject"><a href="#post-134297">My BSP Loader!</a></div>
    <div class="body">Nice program :) I could manage to make it run despite of the corrupted archive (EvilHomer2k, the second link is for the missing file). However I had two problems:<br /><br />1) The tilde key is not there for non-english keyboards, in fact mine doesn't have a tilde key. :grin: It took me a while to figure out which key triggered the console.<br /><br />2) The console itself doesn't seem to work correctly... I just see all white. :(<br /><br />Hope you fix this soon! :alright:</div>
    <div class="meta">Posted on 2004-02-20 11:24:57 by QvasiModo</div>
   </div>
   <div class="post" id="post-134598">
    <div class="subject"><a href="#post-134598">Screenshots</a></div>
    <div class="body">OK then ill soon upload screenshots and it loads md3 now w/o animation<br /><br />Homer, what is osp2 ? 1st time I see that</div>
    <div class="meta">Posted on 2004-02-23 14:00:15 by zabnik</div>
   </div>
   <div class="post" id="post-153424">
    <div class="subject"><a href="#post-153424">ar!!</a></div>
    <div class="body">HI!<br /><br />Me again with my ProbnikGL!<br />With new eXtended problems :)<br /><br />I'm stuck at &quot;CheckBrush&quot;, the problem is that I'm getting stuck in mid-air.<br />Actually I converted that function from C++ sample. Currently I'm using it like this:<br /><br /><pre><code>m2m m_traceRatio,r4_1_0<br />mov m_traceType,TYPE_SPHERE<br />mov m_bCollided,FALSE<br />m2m m_traceRadius,cl_cameraRadius<br />mov esi,addrBrush<br />mov ecx,nBrush<br />.while ecx<br />	push esi<br />	push ecx<br />		<br />	mov eax,&#91;esi.BSP_BRUSH.textureID&#93;<br />	imul eax,sizeof BSP_TEXTURE<br />	add eax,offset addrTexture<br />	mov eax,&#91;eax.BSP_TEXTURE.textureType&#93;<br />	and eax,01h<br />	; Check if we have brush sides and the current brush is solid and collidable<br />	.if &#91;esi.BSP_BRUSH.numOfBrushSides&#93; &gt; 0 &amp;&amp; eax<br />		invoke CheckBrush,esi,old_xpos,old_ypos,old_zpos,xpos,ypos,zpos<br />	.endif<br /><br />	pop ecx<br />	pop esi<br />	add esi,sizeof BSP_BRUSH<br />	dec ecx<br />.endw</code></pre><br /><br />Question: Do I use it correctly or not? Well I'm just trying to make it work, so I skipped the &quot;CheckNode&quot;.<br /><br />The C++ sample: http://www.gametutorials.com/Tutorials/opengl/OpenGL_Pg5.htm</div>
    <div class="meta">Posted on 2004-11-28 12:53:33 by zabnik</div>
   </div>
   <div class="post" id="post-153425">
    <div class="subject"><a href="#post-153425">other collision</a></div>
    <div class="body">Well?<br /><br />Actually I managed to do simple collision detection in BSP Tree using the &quot;FindLeaf&quot; proc from C++ tutorial converted by to ASM!<br /><br />How: When &quot;CAMERA&quot; is outside the map then the LEAF, where the camera is, cluster number equals -1, sooo.... when I get cluster -1 I put camera to old positon. BUT It's still wrong, I can't do the sliding effect using this method, so sad ;(</div>
    <div class="meta">Posted on 2004-11-28 13:15:00 by zabnik</div>
   </div>
   <div class="post" id="post-153444">
    <div class="subject"><a href="#post-153444">My BSP Loader!</a></div>
    <div class="body">Do it properly then - find out what leaf the camera is in, extract the frustum from the current view matrix, now apply frustum culling to all the surfaces within that leaf. Use the PVS information to help cull surfaces in OTHER leaves.</div>
    <div class="meta">Posted on 2004-11-29 05:08:07 by Homer</div>
   </div>
   <div class="post" id="post-153463">
    <div class="subject"><a href="#post-153463">My BSP Loader!</a></div>
    <div class="body">I did the PVS thingy, now I'm trying to do collision detection with sliding effect.<br />The &quot;CheckBrush&quot; isn't working:<br /><br /><pre><code><br />; My check brush<br />CheckBrush proc uses esi edi ecx ebx pBrush&#58;DWORD,vStart_x&#58;REAL4,vStart_y&#58;REAL4,vStart_z&#58;REAL4,vEnd_x&#58;REAL4,vEnd_y&#58;REAL4,vEnd_z&#58;REAL4<br /><br />	LOCAL startRatio&#58;REAL4,endRatio&#58;REAL4,Ratio1&#58;REAL4,Ratio&#58;REAL4<br />	LOCAL startsOut&#58;BYTE<br />	LOCAL startDistance&#58;REAL4,endDistance&#58;REAL4<br />	; Let's store a variable for the offset &#40;like for sphere collision&#41;<br />	LOCAL _offset&#58;REAL4<br /><br />	m2m m_traceRatio,r4_1_0<br />	m2m endRatio,r4_1_0 ; = 1.0f ; Set the end ratio to 1<br />	m2m startRatio,r4_n1_0 ; = -1.0f ; Like in BrushCollision.htm, start a ratio at -1<br />	mov startsOut,FALSE ; This tells us if we starting outside the brush<br />	mov m_bCollided,FALSE<br /><br />	; This function actually does the collision detection between our movement<br />	; vector and the brushes in the world data.  We will go through all of the<br />	; brush sides and check our start and end ratio against the planes to see if<br />	; they pass each other.  We start the startRatio at -1 and the endRatio at<br />	; 1, but as we set the ratios to their intersection points &#40;ratios&#41;, then<br />	; they slowly move toward each other.  If they pass each other, then there<br />	; is definitely not a collision.<br /><br />	; Go through all of the brush sides and check collision against each plane<br />	mov edi,pBrush<br />	mov ecx,&#91;edi.BSP_BRUSH.numOfBrushSides&#93;<br />	.while ecx <br /><br />		push ecx<br /><br />		; Here we grab the current brush side and plane in this brush<br />		;tBSPBrushSide *pBrushSide = &amp;m_pBrushSides&#91;pBrush-&gt;brushSide + i&#93;;<br />		mov eax,&#91;edi.BSP_BRUSH.brushSide&#93;<br />		add eax,ecx<br />		imul eax,eax,sizeof BSP_BRUSHSIDE<br />		add eax,addrBrushside<br /><br />		comment ;<br />		mov ebx,&#91;eax.BSP_BRUSHSIDE.textureID&#93;<br />		imul ebx,ebx,sizeof BSP_TEXTURE<br />		add ebx,offset addrTexture<br />		mov ebx,&#91;ebx.BSP_TEXTURE.textureType&#93;<br />		and ebx,01h<br />		.if !ebx<br />			inc ecx<br />			.continue<br />		.endif;<br /><br />		;tBSPPlane *pPlane = &amp;m_pPlanes&#91;pBrushSide-&gt;plane&#93;;<br />		mov esi,&#91;eax.BSP_BRUSHSIDE.plane&#93;<br />		imul esi,esi,sizeof BSP_PLANE<br />		add esi,addrPlane<br /><br />		; If we are testing sphere collision we need to add the sphere radius<br />		.if m_traceType == TYPE_SPHERE<br />			m2m _offset,m_traceRadius<br />		.endif<br /><br />		; Test the start and end points against the current plane of the brush side.<br />		; Notice that we add an offset to the distance from the origin, which makes<br />		; our sphere collision work.<br />		;float startDistance = Dot&#40;vStart, pPlane-&gt;vNormal&#41; - &#40;pPlane-&gt;d + offset&#41;;<br />		fld &#91;esi.BSP_PLANE.vNormal.x&#93;<br />		fmul &#91;vStart_x&#93;<br />		fld &#91;esi.BSP_PLANE.vNormal.y&#93;<br />		fmul &#91;vStart_y&#93;<br />		fld &#91;esi.BSP_PLANE.vNormal.z&#93;<br />		fmul &#91;vStart_z&#93;<br />		faddp st&#40;1&#41;,st&#40;0&#41;<br />		faddp st&#40;1&#41;,st&#40;0&#41;<br />		fld &#91;esi.BSP_PLANE.d&#93;<br />		fadd _offset<br />		fsubp st&#40;1&#41;,st&#40;0&#41;<br />		fstp startDistance<br />		;float endDistance = Dot&#40;vEnd, pPlane-&gt;vNormal&#41; - &#40;pPlane-&gt;d + offset&#41;;<br />		fld &#91;esi.BSP_PLANE.vNormal.x&#93;<br />		fmul &#91;vEnd_x&#93;<br />		fld &#91;esi.BSP_PLANE.vNormal.y&#93;<br />		fmul &#91;vEnd_y&#93;<br />		fld &#91;esi.BSP_PLANE.vNormal.z&#93;<br />		fmul &#91;vEnd_z&#93;<br />		faddp st&#40;1&#41;,st&#40;0&#41;<br />		faddp st&#40;1&#41;,st&#40;0&#41;<br />		fld &#91;esi.BSP_PLANE.d&#93;<br />		fadd _offset<br />		fsubp st&#40;1&#41;,st&#40;0&#41;<br />		fstp endDistance<br /><br />		; Make sure we start outside of the brush's volume<br />		fcmp startDistance,r4_0_0<br />		.if !ZERO? &amp;&amp; !CARRY? ;&#40;startDistance &gt; 0&#41;<br />			mov startsOut,TRUE<br />		.endif<br /><br />		; Stop checking since both the start and end position are in front of the plane<br />		fcmp startDistance,r4_0_0<br />		.if !ZERO? &amp;&amp; !CARRY? ;&#40;startDistance &gt; 0&#41;<br />			fcmp endDistance,r4_0_0<br />			.if !ZERO? &amp;&amp; !CARRY? ;&#40;endDistance &gt; 0&#41;<br />				ret<br />			.endif<br />		.endif<br /><br />		; Continue on to the next brush side if both points are behind or on the plane<br />		fcmp startDistance,r4_0_0<br />		.if CARRY? || ZERO? ;&#40;startDistance &lt;= 0&#41;<br />			fcmp endDistance,r4_0_0<br />			.if CARRY? || ZERO? ;&#40;endDistance &lt;= 0&#41;<br />				pop ecx<br />				dec ecx<br />				.continue<br />			.endif<br />		.endif<br /><br />		; If the distance of the start point is greater than the end point, we have a collision!<br />		fcmp startDistance,endDistance<br />		.if !ZERO? &amp;&amp; !CARRY? ; &#40;startDistance &gt; endDistance&#41;<br />			; This gets a ratio from our starting point to the approximate collision spot<br />			;float Ratio1 = &#40;startDistance - kEpsilon&#41; / &#40;startDistance - endDistance&#41;;<br />			fld startDistance ; ST&#40;1&#41;<br />			fsub kEpsilon<br />			fld startDistance ; ST&#40;0&#41;<br />			fsub endDistance<br />			fdivp st&#40;1&#41;,st&#40;0&#41; ; ST&#40;0&#41; = ST&#40;1&#41; / ST&#40;0&#41;<br />			fstp Ratio1<br /><br />			; If this is the first time coming here, then this will always be true,<br />			; since startRatio starts at -1.0f.  We want to find the closest collision,<br />			; so we still continue to check all of the brushes before quitting.<br />			fcmp Ratio1,startRatio<br />			.if !ZERO? &amp;&amp; !CARRY? ;&#40;Ratio1 &gt; startRatio&#41;<br />				; Set the startRatio &#40;currently the closest collision distance from start&#41;<br />				m2m startRatio,Ratio1<br />				mov m_bCollided,TRUE ; Let us know we collided!<br />			.endif<br />		.else<br />			; Get the ratio of the current brush side for the endRatio<br />			;float Ratio = &#40;startDistance + kEpsilon&#41; / &#40;startDistance - endDistance&#41;;<br />			fld startDistance ; ST&#40;1&#41;<br />			fadd kEpsilon<br />			fld startDistance ; ST&#40;0&#41;<br />			fsub endDistance<br />			fdivp st&#40;1&#41;,st&#40;0&#41; ; ST&#40;0&#41; = ST&#40;1&#41; / ST&#40;0&#41;<br />			fstp Ratio<br /><br />			; If the ratio is less than the current endRatio, assign a new endRatio.<br />			; This will usually always be true when starting out.<br />			fcmp Ratio,endRatio<br />			.if CARRY? ;&#40;Ratio &lt; endRatio&#41;<br />				m2m endRatio,Ratio<br />			.endif<br />		.endif<br /><br />		pop ecx<br />		dec ecx<br /><br />	.endw<br /><br />	; If we didn't start outside of the brush we don't want to count this collision - return;<br />	.if startsOut == FALSE<br />		ret<br />	.endif<br />	<br />	; If our startRatio is less than the endRatio there was a collision!!!<br />	fcmp startRatio,endRatio<br />	.if CARRY? ;&#40;startRatio &lt; endRatio&#41;<br />		; Make sure the startRatio moved from the start and check if the collision<br />		; ratio we just got is less than the current ratio stored in m_traceRatio.<br />		; We want the closest collision to our original starting position.<br />		fcmp startRatio,r4_n1_0<br />		.if !ZERO? &amp;&amp; !CARRY? ;&#40;startRatio &gt; -1&#41;<br />			fcmp startRatio,m_traceRatio<br />			.if CARRY? ;&#40;startRatio &lt; m_traceRatio&#41;<br />				; If the startRatio is less than 0, just set it to 0<br />				fcmp startRatio,r4_0_0<br />				.if CARRY? ;&#40;startRatio &lt; 0&#41;<br />					m2m startRatio,r4_0_0<br />				.endif<br />			.endif<br />			; Store the new ratio in our member variable for later<br />			m2m m_traceRatio,startRatio<br />		.endif<br />	.endif<br /><br />	ret<br /><br />CheckBrush endp<br /><br />// GameTutorial's check brush<br />void CQuake3BSP&#58;&#58;CheckBrush&#40;tBSPBrush *pBrush, CVector3 vStart, CVector3 vEnd&#41;<br />&#123;<br />	float startRatio = -1.0f;		// Like in BrushCollision.htm, start a ratio at -1<br />    float endRatio = 1.0f;			// Set the end ratio to 1<br />    bool startsOut = false;			// This tells us if we starting outside the brush<br /><br />	// This function actually does the collision detection between our movement<br />	// vector and the brushes in the world data.  We will go through all of the<br />	// brush sides and check our start and end ratio against the planes to see if<br />	// they pass each other.  We start the startRatio at -1 and the endRatio at<br />	// 1, but as we set the ratios to their intersection points &#40;ratios&#41;, then<br />	// they slowly move toward each other.  If they pass each other, then there<br />	// is definitely not a collision.<br /><br />	// Go through all of the brush sides and check collision against each plane<br />	for&#40;int i = 0; i &lt; pBrush-&gt;numOfBrushSides; i++&#41;<br />	&#123;<br />		// Here we grab the current brush side and plane in this brush<br />		tBSPBrushSide *pBrushSide = &amp;m_pBrushSides&#91;pBrush-&gt;brushSide + i&#93;;<br />		tBSPPlane *pPlane = &amp;m_pPlanes&#91;pBrushSide-&gt;plane&#93;;<br /><br />		// Let's store a variable for the offset &#40;like for sphere collision&#41;<br />		float offset = 0.0f;<br /><br />		// If we are testing sphere collision we need to add the sphere radius<br />		if&#40;m_traceType == TYPE_SPHERE&#41;<br />			offset = m_traceRadius;<br /><br />		// Test the start and end points against the current plane of the brush side.<br />		// Notice that we add an offset to the distance from the origin, which makes<br />		// our sphere collision work.<br />		float startDistance = Dot&#40;vStart, pPlane-&gt;vNormal&#41; - &#40;pPlane-&gt;d + offset&#41;;<br />		float endDistance = Dot&#40;vEnd, pPlane-&gt;vNormal&#41; - &#40;pPlane-&gt;d + offset&#41;;<br /><br />		// Make sure we start outside of the brush's volume<br />		if&#40;startDistance &gt; 0&#41;	startsOut = true;<br /><br />		// Stop checking since both the start and end position are in front of the plane<br />		if&#40;startDistance &gt; 0 &amp;&amp; endDistance &gt; 0&#41;<br />			return;<br /><br />		// Continue on to the next brush side if both points are behind or on the plane<br />		if&#40;startDistance &lt;= 0 &amp;&amp; endDistance &lt;= 0&#41;<br />			continue;<br /><br />		// If the distance of the start point is greater than the end point, we have a collision!<br />		if&#40;startDistance &gt; endDistance&#41;<br />		&#123;<br />			// This gets a ratio from our starting point to the approximate collision spot<br />			float Ratio1 = &#40;startDistance - kEpsilon&#41; / &#40;startDistance - endDistance&#41;;<br /><br />			// If this is the first time coming here, then this will always be true,<br />			// since startRatio starts at -1.0f.  We want to find the closest collision,<br />			// so we still continue to check all of the brushes before quitting.<br />			if&#40;Ratio1 &gt; startRatio&#41;<br />			&#123;<br />				// Set the startRatio &#40;currently the closest collision distance from start&#41;<br />				startRatio = Ratio1;<br />				m_bCollided = true;		// Let us know we collided!<br />			&#125;<br />		&#125;<br />		else<br />		&#123;<br />			// Get the ratio of the current brush side for the endRatio<br />			float Ratio = &#40;startDistance + kEpsilon&#41; / &#40;startDistance - endDistance&#41;;<br /><br />			// If the ratio is less than the current endRatio, assign a new endRatio.<br />			// This will usually always be true when starting out.<br />			if&#40;Ratio &lt; endRatio&#41;<br />				endRatio = Ratio;<br />		&#125;<br />	&#125;<br /><br />	// If we didn't start outside of the brush we don't want to count this collision - return;<br />	if&#40;startsOut == false&#41;<br />	&#123;<br />		return;<br />	&#125;<br />	<br />	// If our startRatio is less than the endRatio there was a collision!!!<br />	if&#40;startRatio &lt; endRatio&#41;<br />	&#123;<br />		// Make sure the startRatio moved from the start and check if the collision<br />		// ratio we just got is less than the current ratio stored in m_traceRatio.<br />		// We want the closest collision to our original starting position.<br />		if&#40;startRatio &gt; -1 &amp;&amp; startRatio &lt; m_traceRatio&#41;<br />		&#123;<br />			// If the startRatio is less than 0, just set it to 0<br />			if&#40;startRatio &lt; 0&#41;<br />				startRatio = 0;<br /><br />			// Store the new ratio in our member variable for later<br />			m_traceRatio = startRatio;<br />		&#125;<br />	&#125;<br />&#125;</code></pre><br /><br /><pre><code>fcmp macro arg1,arg2<br />	fld arg1<br />	fcomp arg2<br />	fstsw ax<br />	fwait<br />	sahf	<br />endm</code></pre></div>
    <div class="meta">Posted on 2004-11-29 16:02:38 by zabnik</div>
   </div>
   <div class="post" id="post-153469">
    <div class="subject"><a href="#post-153469">My BSP Loader!</a></div>
    <div class="body">zabnik, won't this fcomp be a bit faster:<br /><pre><code><br />ufcomp macro var1,var2<br />   mov eax,var1<br />   mov ebx,var2<br />   mov ecx,eax<br />   and ecx,ebx<br />   sar ecx,31<br />   xor eax,ecx<br />   xor ebx,ecx<br />   cmp eax,ebx<br />endm<br /></code></pre><br />after the macro, you use jxx as if you compared two signed integers. Only exception is that -0.0 &lt; 0.0 ^^&quot;<br /><br /><br />edit: tested:<br /><br /><pre><code><br />invoke GetTickCount<br />	push eax<br />	mov ecx,1000000000<br />	push ecx<br />	@@&#58;<br />	;-----------------\<br />	; fcmp ke1,ke2 ; 4276 milliseconds<br />	;ufcomp ke1,ke2 ; 3765 milliseconds<br />	;-----------------/<br />	dec dword ptr&#91;esp&#93;<br />	jnz @B<br />	pop ecx<br />	<br />	invoke GetTickCount<br />	pop edx<br />	sub eax,edx<br />	print eax<br /></code></pre><br />with both lines commented (empty code in loop), it takes 3355 milliseconds, so actually to execute 1 bil times, fcmp takes 921ms, while ufcomp takes 410ms<br />124% speedup , taking 0.7 cycle ...<br />This is on an AthlonXP2000+ (DDR 400MHz)</div>
    <div class="meta">Posted on 2004-11-29 17:11:37 by Ultrano</div>
   </div>
   <div class="post" id="post-153503">
    <div class="subject"><a href="#post-153503">My BSP Loader!</a></div>
    <div class="body">Ofcourse it will be faster, but it will be useless if my &quot;CheckBrush&quot; isn't working.</div>
    <div class="meta">Posted on 2004-11-30 12:37:04 by zabnik</div>
   </div>
   <div class="post" id="post-153814">
    <div class="subject"><a href="#post-153814">My BSP Loader!</a></div>
    <div class="body">Hi!<br /><br />I uploaded the new ProbnikGL with simply collision detection, using Leaf's cluster number.<br />If its negative that mean's the camera is outside the map so I put old position in current.<br /><br />http://www.hot.ee/valk777/ProbnikGL_0_03.rar - binary<br />http://www.hot.ee/valk777/probnikgl_0_03.asm - source<br /><br />A nice screenshot with lightmap:<br /><img src="http://www.hot.ee/valk777/probnikgl_0_02.jpg" /></div>
    <div class="meta">Posted on 2004-12-06 16:02:22 by zabnik</div>
   </div>
   <div class="post" id="post-153821">
    <div class="subject"><a href="#post-153821">My BSP Loader!</a></div>
    <div class="body">So far, so good - can you instance the camera and/or switch it to third person view, and how does your camera collision operate in third person? :)</div>
    <div class="meta">Posted on 2004-12-06 22:18:10 by Homer</div>
   </div>
   <div class="post" id="post-153844">
    <div class="subject"><a href="#post-153844">My BSP Loader!</a></div>
    <div class="body">I will try when I do the sliding effect.</div>
    <div class="meta">Posted on 2004-12-07 08:03:06 by zabnik</div>
   </div>
   <div class="post" id="post-153848">
    <div class="subject"><a href="#post-153848">My BSP Loader!</a></div>
    <div class="body">By sliding effect, do you mean basic physics in terms of velocity and direction of travel, or do you ALSO mean friction coefficients for surfaces, possibly gravity thrown into the mix... ?</div>
    <div class="meta">Posted on 2004-12-07 08:42:22 by Homer</div>
   </div>
   <div class="post" id="post-153905">
    <div class="subject"><a href="#post-153905">My BSP Loader!</a></div>
    <div class="body">Yea, basic, not ALL at a same time ofcourse, I never did that before.<br /><br />I have fixed the CheckBrush, now im doing sliding, something is not okay now, because when I try to fly throught some wall I warp into unknownage, but some walls are okey, and It slides by them as I wanted.<br /><br />http://www.hot.ee/valk777/probnikgl.exe<br />You may look at it. It needs all *.pk3 from older package</div>
    <div class="meta">Posted on 2004-12-08 10:34:25 by zabnik</div>
   </div>
   <div class="post" id="post-153943">
    <div class="subject"><a href="#post-153943">My BSP Loader!</a></div>
    <div class="body">Make a BSP map that consists of nothing but a cube with 6 walls and nice simple surface normals - use it to check that your planar collision code is behaving itself :)</div>
    <div class="meta">Posted on 2004-12-09 02:08:59 by Homer</div>
   </div>
   <div class="post" id="post-153949">
    <div class="subject"><a href="#post-153949">My BSP Loader!</a></div>
    <div class="body">Great idea :idea: must try...</div>
    <div class="meta">Posted on 2004-12-09 08:53:52 by zabnik</div>
   </div>
   <div class="post" id="post-154015">
    <div class="subject"><a href="#post-154015">My BSP Loader!</a></div>
    <div class="body">Sorry to be so obvious:P Great idea? No, just simple prooftesting, I know, but it's important to eliminate the bleeding obvious when debugging, it saves time chasing red herrings :)</div>
    <div class="meta">Posted on 2004-12-11 09:03:46 by Homer</div>
   </div>
   <div class="post" id="post-154493">
    <div class="subject"><a href="#post-154493">My BSP Loader!</a></div>
    <div class="body">I created box map, but something strange is going on:<br /><pre><code>    |             |<br />    |             |<br />----+-------------+----<br />    |*************|<br />    |*** solid ***|<br />    |*************|<br />----+-------------+----<br />    |             |<br />    |             |</code></pre><br />Im colliding with each line</div>
    <div class="meta">Posted on 2004-12-20 16:04:02 by zabnik</div>
   </div>
   <div class="post" id="post-154509">
    <div class="subject"><a href="#post-154509">My BSP Loader!</a></div>
    <div class="body">My educated guess based on your reply:<br />You are colliding with the (infinite) plane defined by each surface.<br />Your point/plane collision test is working, but you need a second more refined test for point/polygon.<br /><br />You need to firstly test if the point is before, behind or on the plane, and if its behind or on the plane you should test if its within the bounds of the surface geometry itself.<br /><br />You seem to have forgotten that a flat plane defined by a flat surface extends beyond that surface (to infinity - and beyond !!)</div>
    <div class="meta">Posted on 2004-12-20 22:22:54 by Homer</div>
   </div>
  </div>
 </body>
</html>