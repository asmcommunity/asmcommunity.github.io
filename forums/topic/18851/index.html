<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>CArrayManager - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=18851" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=38">Object Oriented Programming</a> &raquo; <a href="../?id=18851">CArrayManager</a></p>
   <div class="post" id="post-145935">
    <div class="subject"><a href="#post-145935">CArrayManager</a></div>
    <div class="body">This is just CVector for arbitrary-sized array elements.<br />I know that we can store pointers to arbitrary things in the existing CVector array, but sometimes it's efficient to store arrays of structures.<br />This class will allow you to do so, although at the moment it uses RtlMoveMemory which may not be fastest.<br /><br />Feedback appreciated :)<br /><br /><pre><code><br />;Author - Homer<br />;Date - 13 July 2004<br />;Title - CArrayManager class<br />;Description - <br />;// This class manages an array of entries of arbitrary size.<br />;// By default it acts like CVector, with DWORD sized elements.<br />;// Use the SetElementSize method to set the elementsize to anything you choose.<br /><br />class CArrayManager, ,C++ compatible<br />void SetElementSize&#58;dwSize<br />void push_back&#58;pData      ;This method will store an entire struct to the array as a single element.<br />void pop_back&#58;pReturn    ;This method will return an entire data element to your receiving struct<br />void Find                     ;&lt;-- Find element in array, return -1 or address of element in array<br />void Delete&#58;dwIndex  ;&lt;-- Delete array element by index, array content is shifted back to fill gap<br />long pBase                 ;&lt;-- This points to the BaseAddress of the array memory<br />long dwNextPlace       ;&lt;-- This holds offset to next empty write location<br />long cbSize                 ;&lt;-- This holds the current size of the buffer in bytes<br />long dwElementSize<br />endclass<br /><br />CArrayManager_SetElementSize proc dwSize&#58;DWORD<br />m2m &#91;ecx&#93;.CArrayManager.dwElementSize, dwSize<br />ret<br />CArrayManager_SetElementSize endp<br /><br />CArrayManager_CArrayManager proc                      ;*** CONSTRUCTOR ***<br />mov eax,1024                             ;Initialize the array @ 1024 bytes &#40;256 dword entries&#41;<br />mov &#91;ecx&#93;.CArrayManager.cbSize,eax<br />mov &#91;ecx&#93;.CArrayManager.pBase, malloc &#40;eax&#41;<br />mov &#91;ecx&#93;.CArrayManager.dwElementSize,4     ;&lt;--dword sized by default<br />ret<br />CArrayManager_CArrayManager endp<br /><br />CArrayManager_$CArrayManager proc                    ;*** DESTRUCTOR ***<br />free &#91;ecx&#93;.CArrayManager.pBase              ;Release the array memory<br />ret<br />CArrayManager_$CArrayManager endp<br /><br />CArrayManager_push_back proc pData&#58;DWORD<br />mov ebx,&#91;ecx&#93;.CArrayManager.pBase              ;Calculate the address of the next empty place<br />mov eax,&#91;ecx&#93;.CArrayManager.dwNextPlace    ;in the array &#40;=pBase+dwNextPlace&#41;<br />add ebx,eax<br />pushad<br />invoke RtlMoveMemory,ebx,pData,&#91;ecx&#93;.CArrayManager.dwElementSize ;Store the data at the next place in array<br />popad<br />add eax,&#91;ecx&#93;.CArrayManager.dwElementSize<br />;mov &#91;ecx&#93;.CArrayManager.dwNextPlace,eax    ;Increment the NextPlace index<br />.if eax&gt;=&#91;ecx&#93;.CArrayManager.cbSize               ;If we are out of bounds<br />    add eax,&#91;ecx&#93;.CArrayManager.dwElementSize      ;Grow the array<br />    mov &#91;ecx&#93;.CArrayManager.cbSize,eax             ;noting the new size<br />    mov ebx,&#91;ecx&#93;.CArrayManager.pBase<br />    mov &#91;ecx&#93;.CArrayManager.pBase, remalloc &#40;&#91;ecx&#93;.CArrayManager.pBase, eax&#41;<br />.endif<br />mov eax,&#91;ecx&#93;.CArrayManager.dwElementSize<br />add &#91;ecx&#93;.CArrayManager.dwNextPlace,eax<br />ret<br />CArrayManager_push_back endp<br /><br />CArrayManager_pop_back proc pReturn&#58;DWORD<br />mov eax,&#91;ecx&#93;.CArrayManager.dwElementSize<br />sub &#91;ecx&#93;.CArrayManager.dwNextPlace,eax       ;Decrement the NextPlace index<br />mov ebx,&#91;ecx&#93;.CArrayManager.pBase            ;Calculate the address of the last element<br />add ebx,&#91;ecx&#93;.CArrayManager.dwNextPlace<br />pushad<br />invoke RtlMoveMemory,pReturn, ebx, &#91;ecx&#93;.CArrayManager.dwElementSize<br />popad<br />invoke RtlZeroMemory,ebx,&#91;ecx&#93;.CArrayManager.dwElementSize<br />ret  <br />CArrayManager_pop_back endp<br /><br />CArrayManager_Delete proc uses esi edi dwIndex&#58;DWORD<br />mov edi,&#91;ecx&#93;.CArrayManager.pBase <br />mov eax,dwIndex<br />mul &#91;ecx&#93;.CArrayManager.dwElementSize<br />add edi,eax<br />add eax,&#91;ecx&#93;.CArrayManager.dwElementSize<br />.while eax&lt;&#91;ecx&#93;.CArrayManager.cbSize<br />    mov ebx,&#91;ecx&#93;.CArrayManager.dwElementSize<br />    add ebx,edi<br />    pushad<br />    invoke RtlMoveMemory,edi,ebx,&#91;ecx&#93;.CArrayManager.dwElementSize<br />    popad<br />    add eax,&#91;ecx&#93;.CArrayManager.dwElementSize<br />    add edi,&#91;ecx&#93;.CArrayManager.dwElementSize<br />.endw<br />mov eax,&#91;ecx&#93;.CArrayManager.dwElementSize<br />sub &#91;ecx&#93;.CArrayManager.dwNextPlace,eax<br />ret<br />CArrayManager_Delete endp<br /><br />CArrayManager_Find proc pFind&#58;DWORD<br />mov esi,pFind<br />mov ebx,&#91;ecx&#93;.CArrayManager.pBase<br />.while ebx &lt; &#91;ecx&#93;.CArrayManager.dwNextPlace<br />    push ebx<br />    mov al,byte ptr&#91;ebx&#93;<br />    .if byte ptr&#91;esi&#93;==al<br />        mov ecx,&#91;ecx&#93;.CArrayManager.dwElementSize<br />        .while al==byte ptr&#91;ebx&#93; &amp;&amp; ecx!=0<br />            mov al,byte ptr&#91;ebx&#93;<br />            inc esi<br />            inc ebx<br />            dec ecx<br />        .endw<br />        .if ecx==0<br />            pop ebx<br />            return ebx<br />        .endif<br />    .endif<br />    pop ebx<br />    add ebx,&#91;ecx&#93;.CArrayManager.dwElementSize<br />    add esi,&#91;ecx&#93;.CArrayManager.dwElementSize<br />.endw<br />return -1<br />CArrayManager_Find endp<br /></code></pre></div>
    <div class="meta">Posted on 2004-07-12 17:24:15 by Homer</div>
   </div>
   <div class="post" id="post-145971">
    <div class="subject"><a href="#post-145971">CArrayManager</a></div>
    <div class="body">I've added a useful function to CArrayManager.<br />It returns a pointer to the start of the Nth element in the managed array, based on the instance's internal elementsize.<br />This looks very tidy when addressing arrays when addressing messy double-dereferenced arrays and/or several arrays of varying element size, and looks especially tidy when used with pcall.<br /><br />example:<br />pcall pBeer.GetPtrToNth, 11<br />will return in eax the address within the array memory where the 11th  (zero-based) element begins, or it will return -1 meaning that the 11th  (zero-based) element lays outside the currently used arrayspace.<br />Remember that since this class is derived from CVector that it has no theoretical array space limit - it grows on demand - also note that it does NOT shrink thereafter - only the &quot;occupied&quot; arrayspace shrinks.. the arrayspace is elastic, but it only stretches, it never contracts :)<br /><br />CArrayManager_GetPtrToNth proc dwIndex:DWORD<br />mov eax,.CArrayManager.dwElementSize<br />mov ebx,cbSize<br />sub ebx,eax<br />mul dwIndex<br />.if eax&gt;=ebx     ;BoundsChecking - are we trying to read beyond occupied arraymem?<br />    return -1<br />.endif                 <br />add eax,.CArrayManager.pBase<br />ret<br />CArrayManager_GetPtrToNth endp</div>
    <div class="meta">Posted on 2004-07-13 04:04:05 by Homer</div>
   </div>
  </div>
 </body>
</html>