<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>registers after jump to bootloader code. - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=21047" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=34">OS Development</a> &raquo; <a href="../?id=21047">registers after jump to bootloader code.</a></p>
   <div class="post" id="post-159489">
    <div class="subject"><a href="#post-159489">registers after jump to bootloader code.</a></div>
    <div class="body">I was watching about this values, then I find that there is not info about this????<br /><br />Anyway, I do this little thing, hope you like it :).<br /><br />By the way, <strong>ip</strong> and <strong>sp</strong> are not the values after the jump.... by the manipulation.<br /><br />What I have noted is that sp have a value of 0xffec and I have pushed 9 words, mean 0xffec+18 =&gt; 0xffec+ 0x12 =&gt; <em>0xfffe</em> I dont understand this, why not 0xffff.. by the way, I dont have a way to test it in real hardware.. :S.<br /><br /><br />Is only a bootsector.<br /><br /><pre><code><br />call PushAll16<br />jmp start<br /><br />retAddr_PushAll16 dw 0<br />PushAll16:<br />	pop word<br /><br />	push ss<br />	push gs<br />	push fs<br />	push es<br />	push ds<br />	push cs<br /><br />	call $+3 ; push ip<br />	push si<br />	push di<br />	push sp<br />	push bp<br /><br />	push dx<br />	push cx<br />	push bx<br />	push ax<br /><br />	push word<br />	ret<br /><br />retAddr_PrintStackRegs dd 0<br />PrintStackRegs:<br />	pop word<br />	.again<br />		mov ah, 0x4<br />		call PrintStr2CharVideo<br />		inc si<br />		call Space<br />		pop ax<br />		call Ax2Eax<br />		mov , eax<br />		push si<br />		mov si, hexBuffer<br />		mov ah, 0x09<br />		call PrintStr2CharVideo<br />		pop si<br />		call Space<br />		dec cx<br />		jnz .again<br />	push word<br />	ret<br /><br />InitCharVideo:<br />	mov ax, 0xb800<br />	mov es, ax<br />	xor di, di<br />	ret<br /><br />InitData:<br />	mov ax, 0x7c0<br />	mov ds, ax<br />	ret<br /><br />MoveToLine:<br />	push bx<br />	mov bx, 80*2<br />	mul bl<br />	mov di, ax<br />	pop bx<br />	ret<br /><br />Space:<br />	mov byte, &quot; &quot;<br />	inc di<br />	inc di<br />	ret<br /><br />PrintStr2CharVideo:<br />	mov al, <br />	or al, al<br />	jz .end<br />	cmp al, 13<br />	jnz .no13<br />		add di, 80*2<br />		inc si<br />		jmp PrintStr2CharVideo<br />	.no13<br />	cmp al, 10<br />	jnz .no10<br />		push ax<br />		push bx<br />		mov ax, di<br />		mov bx, 80*2<br />		div bl<br />		shr ax, 8<br />		sub di, ax<br />		inc si<br />		pop bx<br />		pop ax<br />		jmp PrintStr2CharVideo<br />	.no10<br />	mov , ax<br />	inc si<br />	add di, 2<br />	jmp PrintStr2CharVideo<br />	.end<br />	ret<br /><br />Ax2Eax:<br />	push bx<br />	mov bx, ax<br />	and ax, 0xf0f0<br />	and bx, 0x0f0f<br />	shr ax, 4<br />	bswap eax<br />	mov ax, bx<br />	mov bx, 4<br />	.again:<br />		cmp al,10<br />		sbb al,69h<br />		das<br />		rol eax, 8<br />		dec bx<br />		jnz .again<br />	rol eax, 8<br />	xchg ah, al<br />	bswap eax<br />	pop bx<br />	ret<br /><br />start:<br />	call InitCharVideo<br />	call InitData<br /><br />	mov si, r1<br />	mov ah, 0x05<br />	call PrintStr2CharVideo<br /><br />	mov cx, 4<br />	mov si, gr1<br />	call PrintStackRegs<br /><br />	mov si, r2<br />	mov ah, 0x05<br />	call PrintStr2CharVideo<br /><br />	mov cx, 5<br />	mov si, ir1<br />	call PrintStackRegs<br /><br />	mov si, r3<br />	mov ah, 0x05<br />	call PrintStr2CharVideo<br /><br />	mov cx, 6<br />	mov si, sr1<br />	call PrintStackRegs<br /><br />	jmp $<br /><br />hexBuffer times 4 db 0<br />	db 0<br /><br />r1 db &quot;General Registers&quot;, 13, 10, 0<br />r2 db 13, 10, &quot;Index and pointer Registers&quot;, 13, 10, 0<br />r3 db 13, 10, &quot;Segment registers&quot;, 13, 10, 0<br /><br />gr1 db &quot;ax&quot;, 0<br />gr2 db &quot;bx&quot;, 0<br />gr3 db &quot;cx&quot;, 0<br />gr4 db &quot;dx&quot;, 0<br /><br />ir1 db &quot;bp&quot;, 0<br />ir2 db &quot;sp&quot;, 0<br />ir3 db &quot;di&quot;, 0<br />ir4 db &quot;si&quot;, 0<br />ir5 db &quot;ip&quot;, 0<br /><br />sr1 db &quot;CS&quot;, 0<br />sr2 db &quot;DS&quot;, 0<br />sr3 db &quot;ES&quot;, 0<br />sr4 db &quot;FS&quot;, 0<br />sr5 db &quot;GS&quot;, 0<br />sr6 db &quot;SS&quot;, 0<br /><br /><br />%assign here $-$$<br />%error HERE here<br /><br /><br />times 510 - ($-$$) db 0xFE<br />dw 0xAA55<br />second_sector:<br />times 1474560 - ($-second_sector) nop<br /></code></pre><br /><br />Comments in those values?</div>
    <div class="meta">Posted on 2005-05-02 22:50:15 by rea</div>
   </div>
   <div class="post" id="post-159522">
    <div class="subject"><a href="#post-159522">Re: registers after jump to bootloader code.</a></div>
    <div class="body">The stack is top-down, so SP is incremented bytewise based on the size of the data being pushed, then the data is written. On a POP, the data is read and then SP is decremented in the same fashion. Pushing GS puts the stack at FFEE from FFEC, and each push does the same.<br /><br /><pre><code><br />	;Stack at 0000:FFEC<br />	push ss	;Stack at 0000:FFEC<br />	push gs	;Stack at 0000:FFEE<br />	push fs	;Stack at 0000:FFF0<br />	push es	;Stack at 0000:FFF2<br />	push ds	;Stack at 0000:FFF4<br />	push cs	;Stack at 0000:FFF6<br /><br />	call $+3	;push ip, Stack at 0000:FFF8<br />	push si	;Stack at 0000:FFFA<br />	push di	;Stack at 0000:FFFC<br />	push sp	;Stack at 0000:FFFE<br /></code></pre></div>
    <div class="meta">Posted on 2005-05-03 20:26:45 by SpooK</div>
   </div>
   <div class="post" id="post-159540">
    <div class="subject"><a href="#post-159540">Re: registers after jump to bootloader code.</a></div>
    <div class="body">Yes is top down, but SP is decremented by each push and incremented by each pop based on the size of data.<br /><br /><pre><code><br />	;Stack at 0000:FFFE<br />	push ss	;Stack at 0000:FFEC<br />	push gs	;Stack at 0000:FFFA<br />	push fs	;Stack at 0000:FFF8<br />	push es	;Stack at 0000:FFF6<br />	push ds	;Stack at 0000:FFF4<br />	push cs	;Stack at 0000:FFF2<br /><br />	call $+3	;push ip, Stack at 0000:FFF0<br />	push si	;Stack at 0000:FFEE<br />	push di	;Stack at 0000:FFEC &lt;--- This is the value pushed...<br />	push sp	;Stack at 0000:FFEA<br /></code></pre><br /><br />Now that you have write it, I see for what the stack top start (sp) is pointing at 0xFFFE is because is word aligned, if it was initialized to 0xFFFF it will be aligned to byte or other diferent than word or dword...<br /><br />Correcting the values (sp and ip), the output is like this:<br /><br />General Registers<br /> ax AA55 bx 0000 cx 0001 dx 0000<br />Index and pointer Registers<br /> bp 0000 sp FFFE di FFE4 si 009D ip 7C00<br />Segment registers<br /> CS 0000 DS 0000 ES 0000 FS 0000 GS 0000<br /><br />ax contain the signature of bootsector<br />cl the drive where boot<br />sp the stack top word aligned<br />di pointing somewhere in a &quot;free&quot; data area...???? no meaninfull value???? a result of a copy??.. si and di?<br />si point to a interrupt?? wich interrupt?<br />ip contain the next instruction to be executed and is where the bootsector is loaded CS:ip.<br />all the segments are initialized to zero or the start of memory.<br /><br /><br />Those values can be tacked like standar??</div>
    <div class="meta">Posted on 2005-05-04 10:23:32 by rea</div>
   </div>
   <div class="post" id="post-159552">
    <div class="subject"><a href="#post-159552">Re: registers after jump to bootloader code.</a></div>
    <div class="body">Yes, you are correct... that is what I get for posting when I am sleep deprived. What is worse is that I tried to solve a problem that wasn&#39;t even there :S<br /><br />I tested the code in Bochs and had the same results. My best guess is that the bochs BIOS sets the stack default to the top of conventional memory.<br /><br />On my computer, the BIOS defaults SP as 0000:03E4 (0x03D2 + 0x12), which is 4 bytes below the first 1000 bytes of memory.<br /><br />If you are asking if these values can be treated like the standard, the answer is no, it is all up to the BIOS software.</div>
    <div class="meta">Posted on 2005-05-04 14:27:36 by SpooK</div>
   </div>
   <div class="post" id="post-159553">
    <div class="subject"><a href="#post-159553">Re: registers after jump to bootloader code.</a></div>
    <div class="body">mmm I see.<br /><br />And the general registers, for example... a segment register for load 0. Perhaps not of much use... tought.<br /><br />I think that<br />ax, cx, bp and the segments are standar??</div>
    <div class="meta">Posted on 2005-05-04 15:17:15 by rea</div>
   </div>
   <div class="post" id="post-160147">
    <div class="subject"><a href="#post-160147">Re: registers after jump to bootloader code.</a></div>
    <div class="body">you can&#39;t even depend on CS:IP being standard values upon entering bootsector code - you&#39;re only guaranteed that the code loads at 0x7C00 physically.<br /></div>
    <div class="meta">Posted on 2005-05-17 08:18:21 by f0dder</div>
   </div>
  </div>
 </body>
</html>