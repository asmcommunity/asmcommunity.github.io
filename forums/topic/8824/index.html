<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>.NET style (superfast) mem allocation on heap - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=8824" />
    <link rel="next" href="../?id=8824&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=8824">.NET style (superfast) mem allocation on heap</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=8824&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=8824&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="8824" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=8824&amp;page=2">&gt;</a><a href="../?id=8824&amp;page=2">&raquo;</a></form>   <div class="post" id="post-64828">
    <div class="subject"><a href="#post-64828">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body">This article and its 2nd part talk about the garbage collector and the memory management in .NET<br /><a target="_blank" href="http://msdn.microsoft.com/msdnmag/issues/1100/GCI/default.aspx">Article</a> <br /><br />It is possible in <em>any way</em> to do such fast allocations on the heap without writing a full blown garbage collector.<br /><br />The article says that in the usual way of allocating memory on the heap, the program keeps a linked list which it has to traverse each time. Can anyone explain me why the program has to do this? Why does it have to traverse through the list each time?<br /><br />Also how is allocation on the stack so fast?</div>
    <div class="meta">Posted on 2002-11-06 11:55:21 by clippy</div>
   </div>
   <div class="post" id="post-64832">
    <div class="subject"><a href="#post-64832">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body">The reason the stack is fast is because it is simple.<br />The parameters under which the stack operates are tight, and predictable, and so can be heavily optimised. The processor is fairly certain that usage will be around the top of the stack, and the further you move down, the less likely the variable is to be accessed - it caches accordingly. Data on the stack is generally aligned by virtue of the fact it is pushed on to it in a set size (32 bits in 32 bit mode), this gives a general advantage (it is seen in all memory access, but by virtue of the self-maintaining aspect of it the stack sees it more).<br /><br />The reason for the linked list is because the ammout of allocated memory is not necessarily known at compile time, also the order in which chunks of memory will be de-allocated is also potentially random. Using an array puts an upper limit on the number of blocks of memory you can keep track of. This can be a very serious limitation.<br /><br />If you want to make something faster, and this applies as a general rule to every program you write, constrain it. The less it has to cope with, the quicker it will do it. Look at the scenario you intend to implement, and pick your algorithms accordingly. There are times when the &quot;slowest&quot; algorithm can be the most preferable.<br /><br />Mirno</div>
    <div class="meta">Posted on 2002-11-06 12:44:45 by Mirno</div>
   </div>
   <div class="post" id="post-64834">
    <div class="subject"><a href="#post-64834">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body">But what i still dont understand is why does the link list has to be traversed fully each time an object is created.<br /><br />One can point to the top of the list and when an object is created, it is just added to the top. Why does it have to go through the whole list again? <br /><br />Yes, When an object is deleted, <em>then</em> it <em>might</em> need to traverse the whole list to deallocate the object and delete its reference from the linked list.<br /><br />How is a large enough block of memory searched in the big 'pool' of memory which would allocate the object?</div>
    <div class="meta">Posted on 2002-11-06 13:09:12 by clippy</div>
   </div>
   <div class="post" id="post-64838">
    <div class="subject"><a href="#post-64838">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body"><div class="quote"><br />But what i still dont understand is why does the link list has to be traversed fully each time an object is created<br /></div><br /><br />As you noted, it does not need to depending on the algorithm.  There are many ways to manage a heap.<br /><br />NET does not move through it per the article.  If always allocates at the very end (until you run out of<br />memory).  At this point in time your application will stall or seem sluggish as it compacts the heap all<br />at once.<br /><br />C / C++ and some others which use the linked list approach move through the list each time look for<br />a large enough free slot to house the request.  Per iteration it is a slower than the above method,<br />however it does not suffer the consequences of having to compact the heap either.<br /><br />Take your pick at which you prefer.  Either 90% blazing fast with 10% occational stalls or 100% decently<br />fast and 0% stalls...</div>
    <div class="meta">Posted on 2002-11-06 14:19:59 by Graebel</div>
   </div>
   <div class="post" id="post-64840">
    <div class="subject"><a href="#post-64840">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body">&gt;But what i still dont understand is why does the link list has to be traversed fully <br />is not fully traversed, only up to the first free block of memory that is large enough<br />&gt;One can point to the top of the list and when an object is created, it is just &gt;added to the top. <br />&gt;why does it have to go through the whole list again? <br />Because free memory can be anywere, no just at the top, except for stack allocation.</div>
    <div class="meta">Posted on 2002-11-06 14:26:54 by octavio</div>
   </div>
   <div class="post" id="post-64907">
    <div class="subject"><a href="#post-64907">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body"><div class="quote">is not fully traversed, only up to the first free block of memory that is large enough</div> <br />I am confused. Doesnt the linked list hold the list of objects <em>allocated</em> on the memory and keeps removing items from itself once objects are deallocated. If so then how will iterating through the linked list help in finding free blocks of memory?</div>
    <div class="meta">Posted on 2002-11-07 06:59:05 by clippy</div>
   </div>
   <div class="post" id="post-64924">
    <div class="subject"><a href="#post-64924">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body">Yeah ok, I can see where you are confused.  Lets say (stupid example) that we<br />start with umm 5 objects allocated on the custom heap, each of which is 20 bytes long.<br /><br />&lt;item 5&gt; &lt;link null&gt; &lt;flag used&gt; 20 bytes<br />&lt;item 4&gt; &lt;link to 5&gt; &lt;flag used&gt; 20 bytes<br />&lt;item 3&gt; &lt;link to 4&gt; &lt;flag used&gt; 20 bytes<br />&lt;item 2&gt; &lt;link to 3&gt; &lt;flag used&gt; 20 bytes<br />&lt;item 1&gt; &lt;link to 2&gt; &lt;flag used&gt; 20 bytes<br /><br />At this time all is well and good.  Now we dont need item 2 anymore so we can mark it<br />as un-used so the garbage collector can do something with it.<br /><br />&lt;item 5&gt; &lt;link null&gt; &lt;flag used&gt; 20 bytes<br />&lt;item 4&gt; &lt;link to 5&gt; &lt;flag used&gt; 20 bytes<br />&lt;item 3&gt; &lt;link to 4&gt; &lt;flag used&gt; 20 bytes<br />&lt;item 2&gt; &lt;link to 3&gt; &lt;flag <strong>not</strong> used&gt; 20 bytes<br />&lt;item 1&gt; &lt;link to 2&gt; &lt;flag used&gt; 20 bytes<br /><br />If we now create a new object (for simplicity 20 bytes) what happens?  One of two<br />things.  1) If the garbage collector has compacted the heap already take directly<br />from the top of the stack or 2) iterate through the list and look for an open slot<br />thats big enough to house the request (which will be item 2).  After getting to item<br />two, no further work is required.  You can remark it as used and pass the pointer<br />back to the application requesting the storage...</div>
    <div class="meta">Posted on 2002-11-07 09:24:24 by Graebel</div>
   </div>
   <div class="post" id="post-64939">
    <div class="subject"><a href="#post-64939">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body">Another memory management strategy is <strong>arena</strong> allocation.  This is useful when dealing with <strong>temporary</strong> data structures.<br /><br />You allocate large memory <strong>pools</strong> or <strong>arenas</strong> and suballocate your items.  Like typical GC strategies, you suballocate at the end of the suballocated space for speed and you ignore items which are no longer used.  At the end of your processing, when you don't need the data structures any more, you deallocate arenas instead of each item.</div>
    <div class="meta">Posted on 2002-11-07 12:09:13 by tenkey</div>
   </div>
   <div class="post" id="post-65005">
    <div class="subject"><a href="#post-65005">An idea for superfast allocation</a></div>
    <div class="body">Hmm... Ok I think i am starting to get a clear picture now.<br /><br /><em>An idea</em>- Tell me whether its completly right or wrong or about its benefits or shortcomings.<br /><br />In languages like C++ which dont support garbage collection, one can speed up allocation the following way.<br /><br />Reserve one big block of memory, the way .NET does. On this block of memory you keep adding objects on top of each other and also store info about their size in a linked list. <br />When an object is deallocated just mark it so in the list.<br />After a certain period of time or when the big block of memory is full, compact the block by removing all the objects which are marked deallocated. <br />If there is enough memory on the top after compacting to allocate the requested object do so otherwise reserve another big block of memory.<br />Sure the program would slow down here but 90% of the time it will go super fast. <br /><br />One can add this fucntionality to an open source compiler like gcc and obtain the same super speed that microsoft is claiming for .NET.<br />Also for people which still prefer the old style of allocating memory there can be a switch in the compiler which will allow users to select which type of allocation to use.<br /><br />This method would require no change in existing code as this would be a feature of the compiler only. Also this would mean no fragmentation of memory, so faster access :-)<br /><br />So tell me what you think of the idea. :-)</div>
    <div class="meta">Posted on 2002-11-08 01:05:33 by clippy</div>
   </div>
   <div class="post" id="post-65012">
    <div class="subject"><a href="#post-65012">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body">If you are worried about allocation strategies in terms of speed, simply design your own. There is no problem in allocating a large block of memory and controlling access to it yourself. It means that the OS is not holding your hand but if you know what you are doing, a fixed block of memory that you control pointers to cannot be beaten in terms of speed.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-11-08 01:56:01 by hutch--</div>
   </div>
   <div class="post" id="post-65079">
    <div class="subject"><a href="#post-65079">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body">Why are you worry about speed ?<br />malloc + free routines only take 2-3 microseconds on my p133 , is not fatster enough?<br />about using fixed memory block size: the memory blocks are then limited in size<br />and you will waste a lot of memory, so virtual memory will be used....</div>
    <div class="meta">Posted on 2002-11-08 12:52:11 by octavio</div>
   </div>
   <div class="post" id="post-65110">
    <div class="subject"><a href="#post-65110">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body">If objects in a &quot;simulated&quot; heap have pointers to each other, <strong>compaction</strong> requires these pointers to be adjusted to point to new locations.  (A &quot;simulated&quot; heap is actually a real heap.)  It also means any pointers into the heap will need to be adjusted.</div>
    <div class="meta">Posted on 2002-11-08 17:59:26 by tenkey</div>
   </div>
   <div class="post" id="post-65134">
    <div class="subject"><a href="#post-65134">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body">Anyway, i just thought of another solution for optimizing the normal heap allocation method.<br /><br />Instead of keeping one linked list for the memory, we keep 2.<br />One for the allocated memory, and the other for the deallocated memory. The 2nd one in the form of a tree, according to the size of the memory.<br /><br />Once a block of memory is deleted, we remove its reference from the list of allocated memory and put it in the deallocated memory tree.<br /><br />We keep 2 variables, max and min for the maximum and minimum block sizes of the deallocated memory tree.<br /><br />Now once you want to allocate more memory of size say MemSize.<br />We first compare it to the max and min values to see if the amount has already been deallocated and is in the tree. If so, then we search through the tree for an appropriate size and allocate it <em>and</em> move that node to the list of allocated memory.<br /><br />If the size of the mem is not between the max and min values then we just allocate memory of top of the existing list. <br /><br />This way there would be no need to go through the entire list each time.<br />Also fragmentation would be MUCH less as each time <em>we would always find a &quot;best fit&quot; hole</em> , compared to the <em>first fit</em> hole which is usually searched for.<br />Also as everything is in a tree, searching for the hole would also be blazingly fast.<br /><br />So what do u think?<br /><br /><br />tenkey,<br /><div class="quote">If objects in a &quot;simulated&quot; heap have pointers to each other, compaction requires these pointers to be adjusted to point to new locations. (A &quot;simulated&quot; heap is actually a real heap.) It also means any pointers into the heap will need to be adjusted.</div><br />Yes, i thought about it much after i wrote my post, which is whyi thought of the above method to optimize the exising style of allocation. <br />But back to my previous method and what you said-<br />wont that mean, going through each and every object and checking its pointer and changing it?<br />.NET does this, but i read somewhere that the full garbage allocation of generation 0 objects in .NET takes only about 1 millisecond on a pentium-200 mhz machine.<br />How does it achieve so much speed? Because even a medium sized program can have LOTS of objects in memory. Wont going through each one to check for pointers take a LOT of time?</div>
    <div class="meta">Posted on 2002-11-09 01:01:47 by clippy</div>
   </div>
   <div class="post" id="post-65137">
    <div class="subject"><a href="#post-65137">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body"><strong>gladiator</strong>, in the 'deallocated memory tree' how would sorting be done on same size blocks?  How would the tree colapse when contigious blocks become availible? ...or would it?</div>
    <div class="meta">Posted on 2002-11-09 01:23:25 by bitRAKE</div>
   </div>
   <div class="post" id="post-65140">
    <div class="subject"><a href="#post-65140">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body">bitrake,<br />Probably i am getting what you mean, but i will try to answer what i understand. But pls remember that the solution i am posting now is just a quick solution and can probably be optimized much,much more while actually writing the code.<br /><br /><br /><br /><div class="quote">in the 'deallocated memory tree' how would sorting be done on same size blocks? </div> <br />A quick solution is to keep another list in the tree of deallocated memory of same sizes. So we have a structure like-<br /><pre><code>struct mem&#123;<br />int memsize;<br />int nBlocks;<br />&#125;;<br /></code></pre> <br />Lets say, a user deletes a linked list of 10 elements of size say 20 bytes each.<br />So the binary tree would have a node of mem which has,<br />memsize=20, nBlocks=10.<br />We keep a linked list of blocks of memory deleted.<br /><br />Now when we need a block of size 20 bytes, we take an element from the linked list of 20 bytes in the deallocated memory tree and put its reference in the 'allocated memory list'. <br />We decrement nBlocks by1. So nBlocks is now equal to 9. If ever nBlocks goes to 0, we remove the whole 'mem' reference from the tree, meaning 20bytes blocks are not available in the tree.<br /><br /><div class="quote">How would the tree colapse when contigious blocks become availible? ...or would it?</div> <br />I am probably not getting what you mean by this. I have just told you about the method of deleting references from the of blocks of the same size. If you want to completly remove a reference of 'mem' structure then it would be using the normal way of deleting nodes from a binary tree.<br /><br />P.S.- I dont think i need to mention this again but, the tree will be built according to the size of the blocks, ie, 'mem.memsize'.<br /><br />I hope i have manged to explain you properly what i mean to say. Hope i have not confused you more by overspecifying things. <br /><br />So again then, What do u think of the idea?</div>
    <div class="meta">Posted on 2002-11-09 02:46:27 by clippy</div>
   </div>
   <div class="post" id="post-65143">
    <div class="subject"><a href="#post-65143">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body"><strong>gladiator</strong>, I think the idea is good.  Yes, I did not understand the trees were size based. :)</div>
    <div class="meta">Posted on 2002-11-09 03:29:27 by bitRAKE</div>
   </div>
   <div class="post" id="post-65146">
    <div class="subject"><a href="#post-65146">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body">What is missing in this discussion is what the use will be as that will dictate what will be the most efficient way to allocate memory.<br /><br />garbage collection is originally from basic and it has to do with a particular style of dynamically allocated memory, usually string memory.<br /><br />What it sounds like is a lot of small allocations of different sizes that are changing on a regular basis. Now what needs to be worked out is if this is the most efficient way to manage memory in the particular instance.<br /><br />Choices would be,<br /><br />OLE string memory, it is designed for rapidly changing small allocations up to about 250 meg.<br /><br />Allocating a single block and managing the pointers yourself and this could be done with a preset maximum size if the app design allowed it.<br /><br />Once a single contiguous block of memory is allocated, the speed of access to an address is much the same with any function used to call it, about the only thing that is a bit slower is memory mapped files and this is only in the allocation.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-11-09 04:00:41 by hutch--</div>
   </div>
   <div class="post" id="post-65152">
    <div class="subject"><a href="#post-65152">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body">hutch,<br />about the single block of memory. I had edited my last to last post and had asked this question-<br />If you have a large block of memory and there are a lot of variables and then if you compact the memory making everything contiguos, wont it take a long, long time to scan through each pointer and correct what its pointing to?<br />But how does .NET manage to do it so fast? I read somewhere that it can complete full generation 0 garbage collection(including compacting the memory) within 1 millisecond on a p-200 mhz machine.<br /><br /><br />One more thing,<br />I have found a better algorithm for heap memory management but i still dont know where to implement it?<br />Should it be done in the malloc function or somewhere else? When i use &quot;new&quot; in C++ does it call malloc?<br />My knowledge of asm is <em>very</em> basic, so i want to know how do u allocate memory on the heap in asm, so that , that function can be optimized too?</div>
    <div class="meta">Posted on 2002-11-09 05:57:33 by clippy</div>
   </div>
   <div class="post" id="post-65194">
    <div class="subject"><a href="#post-65194">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body">It still has a lot to do with the task you have in mind. If you have a large number of variables that are being used and then discarded, what you need to do is work out what the maximum at any time will be and then what the average of memory usage will be and see if you can work out a viable block size to start with.<br /><br />If they are predictable size variables, you can simply reassign the memory locations and ypou have no compaction problems at all. Where it can become problematic is if you are using a large number of variable length strings at the same time.<br /><br />If this was the case, you could try and work out a strategy for the most used to the least used and allocate on that basis. The general idea is that if memory allocation time is a problem for you in performance terms, the more predictably you can allocate larger blocks to cut down the overhead time, the less the overhead will interfere with your programs performance. What it means is that you will have to manage the addressing within those blocks.<br /><br />What you are contrasting is the difference between allocating a large number of small blocks as against allocating a smaller number of large ones that you manage yourself.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-11-09 15:45:46 by hutch--</div>
   </div>
   <div class="post" id="post-65259">
    <div class="subject"><a href="#post-65259">.NET style (superfast) mem allocation on heap</a></div>
    <div class="body">providing your own malloc+calloc+free and &quot;operator new&quot; and &quot;operator delete&quot;<br />should handle &quot;most cases&quot; - but might not catch everything. You should try having<br />a look at Paul Nettles mmgr library; it's designed for finding memory leaks (and does<br />a good job at this), and shows how to override memory allocation routines. Nice thing<br />is that this can be done without any compiler changes, just library changes; you'll<br />probably need source code recompile though, and there's a few odd problems (any<br />standard/3rdparty library functions using memory allocation...)<br /><br />Thing is... do you need this? for me, it would make most sense to use standard<br />library functions most of the time, since memory allocation hasn't really been a<br />time-critical thing for me yet (no, I'm not into RealTime programming, at least not<br />yet ;)). There might  be cases where you have other requirements though, like<br />a zillion tiny allocations... so, write custom code for these occasions :).<br /><br />I don't know if there's any &quot;generic best way&quot; to allocate memory; there's<br />speed or size considerations. Like, you might construct tables for free-block<br />tracking that will allow you to quickly find an appropriately sized memory<br />block on alloc, but this requires more memory, and has some overhead in alloc<br />and free.<br /><br />When writing &quot;tiny application&quot;, I wrap most of the libc stuff I use directly<br />to win32 api functions (malloc-&gt;HeapAlloc, etc) and this works fine for these<br />type of apps. For 32bit dos coding, I had a simplistic linked-list heap scheme,<br />which worked fine for generic allocations. I can't remember how microsoft libc<br />handles memory, but I think it was somewhat more spiffy than a simple linked<br />list. One version of GNU LIBC I looked at years ago (djgpp coding) had something<br />fancy-looking with hash buckets and whatnot...<br /><br />nettles' mmgr, have a look here: <a target="_blank" href="http://www.fluidstudios.com/publications.html">http://www.fluidstudios.com/publications.html</a></div>
    <div class="meta">Posted on 2002-11-10 08:20:34 by f0dder</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=8824&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=8824&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="8824" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=8824&amp;page=2">&gt;</a><a href="../?id=8824&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>