<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Opcode #5 Prefixes - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=9063" />
    <link rel="next" href="../?id=9063&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=9063">Opcode #5 Prefixes</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=9063&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=9063&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="9063" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=9063&amp;page=2">&gt;</a><a href="../?id=9063&amp;page=2">&raquo;</a></form>   <div class="post" id="post-66562">
    <div class="subject"><a href="#post-66562">Opcode #5 Prefixes</a></div>
    <div class="body">In previous tutorial we learnt general things conserning<br />to all operration with prefixes.<br />1.All prefixes are 1 byte size.<br />2.One opcode may have several prefixes.<br />3.If prefix can not be used with following opcode, it is ignored<br /> by processor.<br />As example we study meaning and use of prefix 66h - change<br />default operand size.<br />Now we need just study other prefixes and see if there something<br />interesting about them that can affect performence of our apps.<br />There are 5 types of prefixes<br />1. Change default operand size (66h)<br />2. Change default address size (67h)<br />3. Rep. prefixes (F3,F2)<br />4. Segnment specifying (also called change DEFAULT segment)(2e,36,3e,26,64,65)<br />5. Bus lock (F0)<br />Prefix 66h<br />-----------<br />We learnt it in previous tutor.<br /><br />To test yourself answer a question:<br />wich one of the following instructions will have 66 prefix in 32bit app:<br />scasb<br />scasw<br />scasd<br />The check your answer typing those opcodes in debugger.<br /><br />Prefix 67h.<br />-----------<br />Change default ADDRESS size.<br /><br />Type MNEMONIC<br />	mov al,<br />you can see<br /> 8A00           MOV AL,<br />now insert the OPCODE with leading byte 67.<br /> 67:8A00        MOV AL,<br /><br />1. You can see that byte is now addressed by 16 bit registers <br />In 32bit addressing mode all things that can specify address<br />are 32bits 32bit base,32bit index,32bit offset.<br />All those things in 16bit mode are 16 bits.<br />2. You also can notice that address part not just changed to<br />	mov al,<br />the address components are also changed instead of  we can see<br />now .<br />Why not just ?<br />We'll learn it in depth when it comes to study blocks  and .<br />For now we can say that in 16 bit mode addressing we can not use all registers<br />as index and base that we can use in 32 bit addressing mode.<br />And fields of opcode that specify those addressing registers are differ<br />in 16bit to 32bit addressing modes.<br />I doubt if you often (if ever) will use 16bit addressing in 32bit apps.<br />Nevertherless we learn about it, 'cause the less black gaps about knowlege<br />of opcodes the better.<br />Using 32bit addressing mode in 16bit apps in opposite might be quite effective<br />as long as you control that summory address not grow over FFFFh offset.<br /><br />Rep. prefixes F3,F2.<br />---------------------<br /><br />If you know about chain operations (such as movs,scas,lods etc.)<br />you know when and how prefixes rep\repe\repne are used.<br /><br />You also know that some of chain instruction are supposed to be used with<br />only rep prefix (such as movsb, loadsb) and chain operation is terminated<br />when counter (e(cx)) = 0<br />and some of them are used with either repe or repne when execution can<br />be terminated to only when counter reaches 0 but also when flag ZF does not<br />meet condition specified in prefix.<br />In other words execution with repne is terminated when ZF = 1<br />and repe when ZF=0<br />And of course all of them will be terminated when ecx=0 indefferent from<br />if at the moment ZF=0 or 1.<br />It is the picture you can get when stading mnemonics only.<br />Reality is a little bit different.<br />1. You can see that there are 3 mnemonics for rep prefixes: rep,repe,repne.<br />But only 2 opcodes F2,F3.<br />2. Actually you can use any of the 3 rep mnemonics while working with command<br />that supposed to be used with only rep prefix.<br />In this case in all three cases instruction will work the same way.<br />That means that code:<br />	rep lodsb<br />	repe lodsb<br />	repne lodsb<br />works the same way: it will repeat instruction lodsb ecx times, no matter<br />whether prefix F2 or F3 specifyed.<br /><br />Check it out:<br />TYPE MNEMONICS right in debugger:<br />	xor eax,eax ;ensure ZF = 0<br />	mov esi,esp ;esi points to stack<br />	mov ecx,10<br />	repe lodsb  ;opcode with repe and rep indentical - F3<br />	mov esi,esp<br />	mov ecx,10 <br />	repne lodsb<br />Now run it using F7 not F8.<br />You can see that both repe and repne work the same way.<br /><br />Difference with rep(repe) , and repne  takes a place<br />only when chain instruction itself changes flags such as scasb instruction.<br />In this case LAST BIT of prefix compared against value of ZF.<br />If they are different - chain execution is terminated.<br />Right F3 and F2 in binary and you can see what I mean.<br /><br />Next time we will finish with prefixes and have more close look<br />on opcode that change EIP.<br /><br />If you need an extra exrsize: here is a very simple reference utility<br />on prefixes.<br />Text is displayed in Russian, but you can see Values of prefixes.<br />Find reference and replace in the source russian text with English.</div>
    <div class="meta">Posted on 2002-11-20 04:21:52 by The Svin</div>
   </div>
   <div class="post" id="post-66567">
    <div class="subject"><a href="#post-66567">Opcode #5 Prefixes</a></div>
    <div class="body">I forgot file for last exersize :)</div>
    <div class="meta">Posted on 2002-11-20 04:45:16 by The Svin</div>
   </div>
   <div class="post" id="post-66584">
    <div class="subject"><a href="#post-66584">Opcode #5 Prefixes</a></div>
    <div class="body">Hi <strong>The Svin</strong> :)<br />Nice tutorial :alright:<br /><br />Slightly off-topic.. I'm very curious about the 5 bytes version of:<br /><pre><code><br />Another test for fast and smart lowlevel coder&#58;<br />if PF=1<br />set all bits in eax to 1<br />else<br />set all bit in AX to 1 &#40;don't change upper 16 bits in eax if not PF&#41;<br /><br />5 byte solution.<br />Who will be the fastest now?<br /></code></pre><br />because I, like <strong>iblis</strong> and <strong>bitRAKE</strong> couldn't get it below 6 bytes, or 5 bytes assuming CF=1. I couldn't dedicate it too much time, but I was really defeated, and thought it was not possible.. so I'd really like to see if it's possible, and how. :)</div>
    <div class="meta">Posted on 2002-11-20 07:01:15 by Maverick</div>
   </div>
   <div class="post" id="post-66588">
    <div class="subject"><a href="#post-66588">Opcode #5 Prefixes</a></div>
    <div class="body">Was there 5 byte solution with CF =1 ?<br />I haven't seen it.<br />What solution?</div>
    <div class="meta">Posted on 2002-11-20 07:51:03 by The Svin</div>
   </div>
   <div class="post" id="post-66607">
    <div class="subject"><a href="#post-66607">Opcode #5 Prefixes</a></div>
    <div class="body">Well, my best one (not published, although I got interested to this thread, because it wasn't a valid solution) as well as <strong>iblis'</strong> one (but he showed the STC at the begin), was:<br /><br /><pre><code><br />00000000  7A01              jpe 0x3<br />00000002  6619C0            sbb ax,ax<br /></code></pre><br /><br />Can it be done smaller, and/or without previous CF assumptions? From my reasonings this is not possible.. but I'd like++ to be wrong. :)</div>
    <div class="meta">Posted on 2002-11-20 09:10:23 by Maverick</div>
   </div>
   <div class="post" id="post-66626">
    <div class="subject"><a href="#post-66626">Opcode #5 Prefixes</a></div>
    <div class="body">Good one :)</div>
    <div class="meta">Posted on 2002-11-20 11:55:56 by The Svin</div>
   </div>
   <div class="post" id="post-66632">
    <div class="subject"><a href="#post-66632">Opcode #5 Prefixes</a></div>
    <div class="body">Yup, but still terribly insufficient. :grin:<br /><br />:alright:</div>
    <div class="meta">Posted on 2002-11-20 12:46:38 by Maverick</div>
   </div>
   <div class="post" id="post-66714">
    <div class="subject"><a href="#post-66714">Opcode #5 Prefixes</a></div>
    <div class="body">I don't want the solution, I just want to know if there is any point in trying more :)</div>
    <div class="meta">Posted on 2002-11-21 02:02:55 by micmic</div>
   </div>
   <div class="post" id="post-66728">
    <div class="subject"><a href="#post-66728">Opcode #5 Prefixes</a></div>
    <div class="body">Why not?<br />Trying more Meveric discovered that there is 5 byte solution<br />with CF=1.</div>
    <div class="meta">Posted on 2002-11-21 04:49:36 by The Svin</div>
   </div>
   <div class="post" id="post-66730">
    <div class="subject"><a href="#post-66730">Opcode #5 Prefixes</a></div>
    <div class="body"><strong>iblis</strong> discovered it too, and posted it before me. ;)</div>
    <div class="meta">Posted on 2002-11-21 04:55:12 by Maverick</div>
   </div>
   <div class="post" id="post-66789">
    <div class="subject"><a href="#post-66789">Opcode #5 Prefixes</a></div>
    <div class="body">I had figured that challenge was just a simple segue into the prefix tutorials, but it got way out of hand.  :grin:</div>
    <div class="meta">Posted on 2002-11-21 15:19:53 by iblis</div>
   </div>
   <div class="post" id="post-85112">
    <div class="subject"><a href="#post-85112">...</a></div>
    <div class="body">...............<br />...............<br />...............<br /><br />Oke I got it.<br /><br /><pre><code><br />88C0 is used for moving 8 Bit reg.   &#40; Mov al,al&#41;<br />89C0 is used for moving 16 Bit reg. &#40;Mov ax,ax&#41;<br />6689C0 for moving 32 Bit reg.         &#40;Mov eax,eax&#41;<br />6789C0 for moving Memory.            &#40;Mov eax,&#91;eax&#93;&#41;<br />6688C0 ...... ??<br /></code></pre></div>
    <div class="meta">Posted on 2003-03-04 22:40:17 by realvampire</div>
   </div>
   <div class="post" id="post-85178">
    <div class="subject"><a href="#post-85178">Opcode #5 Prefixes</a></div>
    <div class="body">I know that scientica has carefully read opcodes tuts.<br />scientica,<br />Could you, please, answer realvampire question?</div>
    <div class="meta">Posted on 2003-03-05 07:09:58 by The Svin</div>
   </div>
   <div class="post" id="post-85198">
    <div class="subject"><a href="#post-85198">Opcode #5 Prefixes</a></div>
    <div class="body">Ok, I'll give it a try. :)<br /><br /><pre><code><br />Opcode&#58;      Assembly&#58;<br />   88 C0     mov al,al<br />   89 C0     mov &#40;e&#41;ax,&#40;e&#41;ax  ; See note1<br />66 89 C0     mov &#40;e&#41;ax,&#40;e&#41;ax  ; See note1<br />67 89 C0     mov &#40;e&#41;ax,&#40;e&#41;ax  ; See note2<br />66 88 C0     mov al,al        ; See note3<br /></code></pre><br /><br />Note1<br />If we're in a 16-bit segment then 89 C0 will use word sized registers (mov ax,ax) and 66 89 C0 will then use dword sized registers (mov eax,eax). The 66h is a prefix, that overrides the default operand size (dword or word). In a 16-bit segment 66h will tell the CPU to use dword sized register for then next operand if supported by the instruction (see note2).<br />But if we're in a 32-bit segment then 89 C0 will use a dword sized registers (mov eax, eax),  and then 66 89 C0 will use word sized registers (mov ax, ax).<br /><br />Summary on note 1: The 66h prefix overrides the defult operand size, in a 16-bit segment 66h will cause the prefixed instruction to use dword sized operands, and in a 32-bit segment  66h will cause the prefixed instruction to use word sized operands. In windows the default operand size if 32-bit for standard PE exes, I think .com files uses 16-bit.<br />(And the 66h prefix also adds/costs an extra clock cycle at execution, right Svin?)<br /><br />Note2<br />The 67h prefix is used just as the 66h prefix but 67h overrides memory size instead of operand size.<br />If you want to execute a {mov eax,} then you must change the mode part of the SIB and change the instuction byte to 8B, thus a dereference of eax will be encoded like this:<br />8B 00 ; (8B=1000 1011)   SIB = 00 000 000<br /><br />Note3<br />In this case the 66h prefix will be ignored, the only thing that will happen is that the instruction takes a clock cycle longer to execute and the code is one byte larger than needed. Since there is no word or dword sized operand, only byte size, there is nothing for 66h to do. Since 66h overrrides the default operand size, which is dword or word size.<br />So 66 88 C0 will do the same as 88 C0.<br /><br />:o I hit the post button to soon when writing my answer, so I've completed the post in &quot;edit mode&quot;. (Too used to using the tab key... :\ )</div>
    <div class="meta">Posted on 2003-03-05 08:30:06 by scientica</div>
   </div>
   <div class="post" id="post-85211">
    <div class="subject"><a href="#post-85211">Opcode #5 Prefixes</a></div>
    <div class="body">Oh, very good!<br />I'd just add some additinal explonation about<br />bit &quot;W&quot; in code field that chages operand size<br /> between byte size and &quot;full size&quot;.<br />And also a little bit more precise explonation when<br />&quot;default operand size&quot; is dword and when word.</div>
    <div class="meta">Posted on 2003-03-05 10:18:30 by The Svin</div>
   </div>
   <div class="post" id="post-85214">
    <div class="subject"><a href="#post-85214">....</a></div>
    <div class="body">:grin:  Thanks a lot to you both. Hope you're not feel boring answering my Question.<br /><br />I've done some experiment.<br /><br /><pre><code><br /> First&#58;<br /> xor ax,ax<br /> mov es,ax<br /> mov esi,eax<br /></code></pre><br /><br /> That one is crashes. And not working.<br /><pre><code><br /> SMSW AX<br /> xor al,1<br /> LMSW AX<br /> xor ax,ax<br /> mov es,ax<br /> mov esi,eax<br /></code></pre><br /><br /> This one is working But it Rebooting Windows. So I now understand that even we are use prefix, it wont work unless I set CPU mode  to Pmode.<br /><br />I saw all of your Opcode Tutorial. Good Job. <br /><div class="quote"><br />8B 00 ; (8B=1000 1011) SIB = 00 000 000<br /></div><br /><br />Scientica Explain to me each Bit. Especially the 8B. Does B have a Special mean ?<br /><br /><br />:eek:  0x90 are used for xchg ax,ax and both Nop :confused:  My head is hurt...,. Is Xchg ax,ax have any 2 Bytes Code ?</div>
    <div class="meta">Posted on 2003-03-05 10:32:33 by realvampire</div>
   </div>
   <div class="post" id="post-85265">
    <div class="subject"><a href="#post-85265">Re: ....</a></div>
    <div class="body"><div class="quote"><em>realvampire wrote something like this</em> :)<br />:grin:  Thanks a lot to you both. Hope you're not feel boring answering my Question.</div><br />You're welcome! :)<br />Boring? :confused: No not at all, it's quite satisfying to help others (or at least try). :)<br /><div class="quote">I've done some experiment.</div><br />Greate that's how we (or at least I) learn lot's of things. :)<br /><div class="quote"><pre><code><br /> First&#58;<br /> xor ax,ax<br /> mov es,ax<br /> mov esi,eax<br /></code></pre><br /> That one is crashes. And not working.</div><br />Well, it didn't crash for me (I just typed in the instrucitons in olly and ran it, no problems). Don't know why it crashes for you.<br /><div class="quote"><br /><pre><code><br /> SMSW AX<br /> xor al,1<br /> LMSW AX<br /> xor ax,ax<br /> mov es,ax<br /> mov esi,eax<br /></code></pre><br /> This one is working But it Rebooting Windows. So I now understand that even we are use prefix, it wont work unless I set CPU mode  to Pmode.</div><br />Well, LMSW is a privileged instruction. I didn't dare run it as I'm writing the post answer incase it reboots my computer too...<br />If you want to set the PE bit then I'd suggest you use the cr0 directly instead, since SMSW and LMSW exsist for compabillity with the Intel (80)286.<br /><br /><div class="quote">Scientica Explain to me each Bit. Especially the 8B. Does B have a Special mean ?<br /><br />:eek:  0x90 are used for xchg ax,ax and both Nop :confused:  My head is hurt...,. Is Xchg ax,ax have any 2 Bytes Code ?</div><br />Well, 8B is in binary 1000 1011, and the blue bit is the d(irection)-bit that is explained in tutorial number 7 (in this <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=10554&amp;perpage=1&amp;pagenumber=14">-&gt;Post&lt;-</a>)  and the red bit is the w-bit (also explained in the post above).<br /><br />Well,  basically does nothing it's a no-op (eax=eax, very complex instruction and computation ;)). Nop is 90h and does nothing except delaying execution one cycle and add an extra byte to the source.  As the Svin mentions in one of his tuts one opcode can have more then one mnenomic, so &quot;nop&quot; and &quot;xchg eax,eax&quot; does exactly the same because they're the same opcode, as we say in sweden &quot;k?rt barn har m?nga namn&quot; (~=loved child has many names), and we may say nop is a well used instruction, it can for instance be used when aligning code sections (if we would align a code section with zeroes we would have problems since 00 00 is &quot;add ,al&quot;, to make it easier to under stand I cut out this from an opcode ref: <em>00 /r  is ADD r/m8,r8</em> (&quot;/r&quot; means that SIB follows and that the &quot;r/m&quot; bits are a reg)).<br />A little note, as you might know, eax the acumelator register is somewhat special, it has some opcodes for it self, meaning that for instance  is 90 +r (the lower three bits of 90h is a 3-bit reg field), so if you want to  then you should type 91h. But if you want to do  then you would have to type 87 D1 (87 /r  is XCHG r32,r/m32).<br />The accumelator is as you see favorised in opcodes, of cource you can write 87 C0 if you like to  but that isn't very apealing (why use a two byte instrucion when you can use a one byte? well maybe if you want to do some SMC (slef modifying code) or write some protection scheme (which may use SMC) since C0 (&quot;start&quot; of some shifting opcodes). Not all instrucitons favor teh accumelator in this way but some do.<br /><br /><span style="font-size:9px>I'm tired, better get some sleep, I hope I haven't made any errors in the chunk of text above, I feel my eye lashes hitting the floor...</span></div>
    <div class="meta">Posted on 2003-03-05 14:53:08 by scientica</div>
   </div>
   <div class="post" id="post-85274">
    <div class="subject"><a href="#post-85274">Re: ....</a></div>
    <div class="body"><div class="quote"><pre><code><br /> First&#58;<br /> xor ax,ax<br /> mov es,ax<br /> mov esi,eax<br /></code></pre></div>Obviously, that's going to crash. GDT entry 0 is not usable.<div class="quote"><pre><code><br /> SMSW AX<br /> xor al,1<br /> LMSW AX<br /> xor ax,ax<br /> mov es,ax<br /> mov esi,eax<br /></code></pre><br /><br /> This one is working But it Rebooting Windows. So I now understand that even we are use prefix, it wont work unless I set CPU mode  to Pmode.<br /></div><br />But the processor is already running in protected mode. That would put it in real mode and of course it won't do any good since the patches made to MS-DOS are still there, and the code segment is still 32-bit. Besides, the PSP contains protected mode addresses and such. You should always exit Windows using the ExitWindowsEx function instead, so that all drivers will be unloaded correctly and MS-DOS returned to its normal state. But you can always use instruction prefixes, regardless of execution mode.</div>
    <div class="meta">Posted on 2003-03-05 15:43:53 by Sephiroth3</div>
   </div>
   <div class="post" id="post-85275">
    <div class="subject"><a href="#post-85275">Opcode #5 Prefixes</a></div>
    <div class="body"><div class="quote">0x90 are used for xchg ax,ax and both Nop</div> <br />You said you'd read all opcode tuts.<br />But the very first tuts your question is details.<br />There are discussion about relation of<br />opcode as &quot;real thing&quot; and mnemonics as &quot;names for real things&quot;.<br />And that one real thing <br />- May have different names.<br />- May have no name at all.<br />- And several different things may have the same name.<br />It is as in real life and human language that is trying to<br />describe it.<br />As an exmple there are words about &quot;nop&quot; and &quot;xchg eax,eax&quot;<br />as two names for the same thing.<br />For example I can write in my source<br />svin equ 90h<br />And now I can write svin instead of nop.<br />Does it make new thing?<br />It just create new NAME for old thing<br />Processor doesn't no names and doesn't care about them.<br />It understand only real thing - opcode wich in the case is 90h.<br />90h in binary =<br />10010 - exchage eax<br />000     - with reg # 000 (eax)<br /><br />There is educational programms in this thread in wich you can<br />see it all in bits hex and mnemonics and train your understanding with<br />test tabs dlgs.</div>
    <div class="meta">Posted on 2003-03-05 15:57:28 by The Svin</div>
   </div>
   <div class="post" id="post-85280">
    <div class="subject"><a href="#post-85280">Opcode #5 Prefixes</a></div>
    <div class="body"><div class="quote">8B 00 ; (8B=1000 1011) SIB = 00 000 000</div> <br />scientica, there is no SIB<br />00 000 000 - is byte moder/m<br />00 - mod = mem operand in m/r field specified by reg pointer only<br />000 - reg operand<br />000 - reg as memory pointer operand.<br /><br />Byte SIB is extention of m/r field, presence of<br />byte sib is specifyed if m/r field has value 100.<br />8B with sib present would look in binary like<br />1000 10dw :** *** 100 :ss iii bbb<br />where ** *** any bits except for 11 as the greates two.<br />and ss iii bbb - bits of sib.<br />Byte sib is present only when byte modr/m is present too.<br />Thus the least size of opcode with sib would be 3 bytes:<br />At least one byte for code block<br />One byte for modr/m<br />And one byte for sib.<br />BTW:<br />Your second post for realvampier looks even better than the first.<br />It's good to have you here :)</div>
    <div class="meta">Posted on 2003-03-05 16:31:18 by The Svin</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=9063&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=9063&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="9063" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=9063&amp;page=2">&gt;</a><a href="../?id=9063&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>