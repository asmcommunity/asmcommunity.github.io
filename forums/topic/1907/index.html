<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Micro_code - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=1907" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=1907">Micro_code</a></p>
   <div class="post" id="post-12257">
    <div class="subject"><a href="#post-12257">Micro_code</a></div>
    <div class="body">Hi all<br />I have just come across the term micro-code and after some research I'm still confused. Some says it is firmware, ie EPROM level stuff, others say that it is &quot;lower&quot; than Assembly laungage, ie between the machine code and the processesor.<br />Can somebody shed some light on the subject and how/where it fits in around the WIN32 platform.<br />Cheers<br />Kim</div>
    <div class="meta">Posted on 2001-11-16 11:00:17 by fiddler</div>
   </div>
   <div class="post" id="post-12266">
    <div class="subject"><a href="#post-12266">Micro_code</a></div>
    <div class="body">The original meaning (was it M. V. Wilkes?) of <strong>microcoding</strong> or <strong>microprogramming</strong> was a direct mapping from the opcode bit fields to sets of suboperations. I believe the PDP-8 took this further than other machines. I'm not familiar with the RISC architectures to know how far they've taken this idea.<br /><br />The more common form of <strong>microcoding</strong> is to build a fast processor and write an interpreter for it. Because this fast processor is internal, you can design it any way that seems simple and fast. This fast processor might even use the original ideas of microcoding. Most of the IBM (360/370) mainframes are microcoded.<br /><br />To take the idea further, I know of one series of projects that used a microcontroller as the &quot;microengine&quot;. Unlike p-code, the application RAM/ROM was not the same as the microcontroller RAM/ROM, so this qualifies as microcoding.<br /><br />Because of the <em>micro-</em> prefix, the term <strong>microprogramming</strong> has also been applied to the ordinary programming of microprocessors and microcontrollers. And that's why it's more confusing than it ought to be.</div>
    <div class="meta">Posted on 2001-11-16 14:09:21 by tank</div>
   </div>
   <div class="post" id="post-12286">
    <div class="subject"><a href="#post-12286">Micro_code</a></div>
    <div class="body">So you could have a processor that supports real-time C++ code?<br /><br />*me starts thinking*... Probably would be slow though...</div>
    <div class="meta">Posted on 2001-11-16 17:50:49 by Kenny</div>
   </div>
   <div class="post" id="post-12299">
    <div class="subject"><a href="#post-12299">Micro_code</a></div>
    <div class="body">Ugh. C++ was not designed for interpretation.<br /><br />However, there is the BASIC STAMP. It uses a very high speed PIC, but I don't know where it stores the (BASIC) program and data.</div>
    <div class="meta">Posted on 2001-11-16 21:25:58 by tank</div>
   </div>
   <div class="post" id="post-12302">
    <div class="subject"><a href="#post-12302">Micro_code</a></div>
    <div class="body">As far as mainframes, tank is correct, microcode is still the heart of the S/390 (and 360/370) mainframes. IBM uses it to adapt the standard instuction set to various hardware configurations. For example, the &quot;logical&quot; machine is based on 32 bit words. Back in the early days, small mainframe hardware (the 360/30) could only access memory 8 bits at a time. It was microcode's job to put 4 8 bit bytes into a logical 32 bit word, when needed. The next level mainframe (the 360/40) was a native 16 bit machine. So it's microcode only had to fetch 2 16-bit chunks to make the logical word.<br /><br />Actually, the &quot;native&quot; 360 hardware was the 360/65, a 64 bit machine. The other models really just emulated what the 65 did naturally. While things like registers and operands are only 32 bits in the architecture, other important stuff like the Program Status Word (PSW), and Channel Command Words (CCW) are 64 bits. This is why the 65 kicked ass in things like teleprocessing, that uses long CCW chains to poll all of the terminals attached to the computer. Bit I digress...<br /><br />Think of the hardware as being made up of various resources, like memory, registers and channels. Microcode analyzes the instruction, and does the actual work of fetching, operating on, and storing the result, among other things. The nice thing about microcode is that it's software, and can be changed, enhanced and improved over time. Today, microcode provides various &quot;assists&quot; to the mainframe. Common operating system functions that were software in the past, have been moved to microcode. Microcode can take advantage of the specific native hardware, and do the complex operation faster that the &quot;emulated&quot; instruction set can. You can also have different microcode do different things on the same machine. For example, most models have a different microprogram to run diagnostics on the hardware.<br /><br />Hope this helps   :grin:</div>
    <div class="meta">Posted on 2001-11-16 23:08:00 by S/390</div>
   </div>
   <div class="post" id="post-12306">
    <div class="subject"><a href="#post-12306">Micro_code</a></div>
    <div class="body">Great<br /><br />Where in the WIN32 architecture does the Microcode excist and how do you access it.<br />Presumming that microcode is used on the WIN32 platform.<br />Obviously from above it is proccessor specific. <br />An example wouldbe great possible.<br /><br />Cheers<br />Kim:grin:</div>
    <div class="meta">Posted on 2001-11-17 00:46:10 by fiddler</div>
   </div>
   <div class="post" id="post-12321">
    <div class="subject"><a href="#post-12321">Micro_code</a></div>
    <div class="body">Kim,<br /><br />On an x86 processor you cannot access the microcode at all. You need to remember that even though x86 processors have made many advances over time, they are not mainframes and simply don't have the facilities of a much larger processor.<br /><br />Basically the distinction on an x86 is based on the processor core, the x86 instruction set have been around for a long time and were originally hard wired into an 8088. Processor technology has changed very dramatically over 20 years and the internal structure is very different to an 8088 but because of demand, backwards compatibility and so on, the manufacturers still supply the x86 instruction set by constructing them in microcode. Microcode in this instance is a set of lower level processor capacities that can be combined at the manufacturing stage to produce the instruction set that they want.<br /><br />Now the problem would be if you could get at the microcode is that it is processor model specific so it absolutely would not run on an earlier or later model. You will find that you will not have performance problems by using the existing instruction set in code.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2001-11-17 05:07:36 by hutch--</div>
   </div>
   <div class="post" id="post-12347">
    <div class="subject"><a href="#post-12347">Micro_code</a></div>
    <div class="body">Hutch, it's not entirely true you can't get at the microcode. With<br />intels ppro core, and later models, you can apply microcode paches.<br />These patches must be applied early before too much initialization<br />goes on, which means BIOS. They are effective until the processor<br />is reset. This means the only way (that I know of, at least) to get<br />a microcode update, is to flash a newer bios. And of course the<br />microcode patch format is intel proprietary. *but it can be done*.<br />And intel even documents how to apply the patches...</div>
    <div class="meta">Posted on 2001-11-17 09:14:53 by f0dder</div>
   </div>
   <div class="post" id="post-12378">
    <div class="subject"><a href="#post-12378">Micro_code</a></div>
    <div class="body">Well the only thing I know about mainframes now is that you can apply microcode, ha.<br />So it's sort of like applying the status/mode word to a UART chip.<br />Easy. <br />Its always interresting when you see something you haven't heard of before.<br /><br />Thanks<br />Kim</div>
    <div class="meta">Posted on 2001-11-17 15:03:04 by fiddler</div>
   </div>
   <div class="post" id="post-12396">
    <div class="subject"><a href="#post-12396">Micro_code</a></div>
    <div class="body">f0dder,<br /><br />Patching a BIOS is one thing, writing microcode at an application level is another, basically FOR-GET-IT until Intel or AMD or whoever else makes a processor that has the access to this level of code.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2001-11-17 19:06:20 by hutch--</div>
   </div>
   <div class="post" id="post-12398">
    <div class="subject"><a href="#post-12398">Micro_code</a></div>
    <div class="body">If you get access to the core micro-code, surely it stops being an x86...<br />So writing micro-code for the x86 cannot be done!<br /><br />Mirno</div>
    <div class="meta">Posted on 2001-11-17 19:54:23 by Mirno</div>
   </div>
   <div class="post" id="post-12403">
    <div class="subject"><a href="#post-12403">Micro_code</a></div>
    <div class="body">Like f0dder said, it is theoretically possible to rewrite the micro-code for the x86 processor, therefor making your own instrction set. But, this would require a brand new OS, and a whole lot of time :) So, as hutch said, forget it :)</div>
    <div class="meta">Posted on 2001-11-18 00:57:27 by Kenny</div>
   </div>
   <div class="post" id="post-12429">
    <div class="subject"><a href="#post-12429">Micro_code</a></div>
    <div class="body">I agree hutch, forget it. I was just saying that it can be done. However,<br />not by *us*. Only intel knows the format of their patches, and even<br />if you made a patch yourself, getting it into the bios would not be<br />easy.<br /><br />And who knows what those patches can do? I know they have fixed<br />bugs in some instructions, and have done speedups as well... but<br />adding totally new instructions? Probably not, as that would require<br />rewriting the decoders and pipelines and whatnot... something I don't<br />think you can do in microcode on x86 processors =). Except perhaps<br />the crusoe...</div>
    <div class="meta">Posted on 2001-11-18 07:41:07 by f0dder</div>
   </div>
   <div class="post" id="post-12441">
    <div class="subject"><a href="#post-12441">Micro_code</a></div>
    <div class="body">Yes, in theory you could add new instructions by updating the microcode. This is exactly what IBM did with the decimal inscructions on the mainframe. Decimal instructions allow you to do math on variable length packed decimal numbers in memory. Since the source and destination are in memory, no additional hardware is needed (unlike floating point that needs hardware registers). The new microcode recognized the new op codes, and included the logic to do the math.<br /><br />:)</div>
    <div class="meta">Posted on 2001-11-18 09:25:30 by S/390</div>
   </div>
   <div class="post" id="post-12451">
    <div class="subject"><a href="#post-12451">Micro_code</a></div>
    <div class="body">Actually, getting new microcode into BIOS is not too hard, there's even tools for that, like this one: <br /><a target="_blank" href="ftp://ftp.heise.de/pub/ct/ctsi/ctmc10.zip">ftp://ftp.heise.de/pub/ct/ctsi/ctmc10.zip</a><br /><br />Also, I think that the BIOS is not the only program that can load microcode updates. At least Win2K seems to have its own microcode update loader, the question is, why?<br /><br />How the updates are actually loaded, is described in Intel Architecture Software Developers Manual vol 3. Anyway, the format of microcode update data is still Intel's secret.</div>
    <div class="meta">Posted on 2001-11-18 11:12:04 by Janne</div>
   </div>
   <div class="post" id="post-12453">
    <div class="subject"><a href="#post-12453">Micro_code</a></div>
    <div class="body">Aha, didn't know about that tool... so my idea of getting the microcode<br />into the BIOS sorta involved disassembly and crossing fingers, hoping<br />you I did it correctly ;).<br /><br />As for only the BIOS being able to load the update, this is what<br />the intel p3 docs have to say:<br /><div class="quote"><br />The microcode update must be loaded to the processor early on in the POST, and always<br />prior to the initialization of the P6 family processors L2 cache controller.<br /></div></div>
    <div class="meta">Posted on 2001-11-18 11:29:43 by f0dder</div>
   </div>
   <div class="post" id="post-12469">
    <div class="subject"><a href="#post-12469">Micro_code</a></div>
    <div class="body">Whast I suspect after having upgraded the bios on a new p4 is that reflashing the bios probably adds the microcode only to the bios and does not touch the processor at all.<br /><br />This is something like a program storing a pile of settings or adjustments in the registry as the form of binary cannot be accessed.<br /><br />Microcode as I understand it in current x86 processor design is hard wired at the hardware level and its an adjustment that can only be done in the fabrication stage. It does make sense to be able to tweak bits and pieces depending on usage.<br /><br />Where I see the problem is if the info becomes public so that the virus ratbag fringe find a way to access the flashable part of the bios. I am fortunate that the Intel board that came with the p4 has a jumper setting that reloads the bios with default settings so it can be restarted. A trashed bios is a pain but if you can fix it without having to remove it and send it away, the recovery is no big deal.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2001-11-18 15:48:52 by hutch--</div>
   </div>
   <div class="post" id="post-12474">
    <div class="subject"><a href="#post-12474">Micro_code</a></div>
    <div class="body">Yes hutch, the microcode updates are temporary (ie, until processor<br />reset).<br /><br />As for the microcode being hardwired... well, that would be a logical<br />assumption. But it seems the &quot;microcode patches&quot; can do quite<br />a bit... iirc, they managed to add some impressive speed improvements<br />to some instructions, enough that just &quot;tweaking a few values&quot;<br />sound improbable.<br /><br />It wouldn't hurt if the microcode patch format became public, as<br />it will be no worse than a mal-flashed BIOS. And information on how<br />to flash BIOSes has been public knowledge since CIH hit the streets,<br />which is quite a while ago.<br /><br />Knowing the format of the microcode patches probably isn't<br />terribly useful anyway... ok, we already know the basic &quot;file&quot; structure<br />of the patch (it's in the p3 docs), but the contents... oh well, I don't<br />care much :).</div>
    <div class="meta">Posted on 2001-11-18 16:12:04 by f0dder</div>
   </div>
  </div>
 </body>
</html>