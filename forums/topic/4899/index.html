<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Bag O'Questions II: The Bag Strikes Back - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4899" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=4899">Bag O'Questions II: The Bag Strikes Back</a></p>
   <div class="post" id="post-34356">
    <div class="subject"><a href="#post-34356">Bag O'Questions II: The Bag Strikes Back</a></div>
    <div class="body">Hi folks,<br /><br />Okay, I'm back from errands, on with the questions.  First, thanks again to everyone.<br /><br />1. I just peeked at some disassembly of my code, and saw this garble:<br /><br /><pre><code><br />77E36F56   movsx       edx,dl<br />77E36F59   lea         ecx,&#91;ecx+ecx*4&#93;<br />77E36F5C   inc         eax<br />77E36F5D   lea         ecx,&#91;edx+ecx*2-30h&#93;<br /></code></pre><br /><br />Two things strike me about the LEA's in there.  Firstoff, it's not entirely clear to me what's being done.  I saw a page somewhere a few days ago (but can't find it again, I'm still hoping someone will point out the link, it was a list of common assembly idioms, like saying &quot;xor eax, eax&quot; instead of &quot;mov eax, 0&quot;, etc.) that mentioned that lea is faster for some forms of addition, so that could make sense.  So that second line could be something like,<br /><br />&quot;multiply whatever's in ecx by 5, look into the contents of that address, now store the address of those contents in ecx.&quot;  Or, in other words, multiply ecx by 5, storing the value in ecx.<br /><br />1a. Is that what's really happening here?<br />1b. How the heck can the machine, at runtime, embed a *4 in an opcode?!?<br /><br />2. Is there a common idiom for allocating and freeing memory?  I know to use the heap functions; I'm just curious to know what the common idiom is--function allocates, caller frees, caller allocates and frees, etc.  I would like to write a function that returns a dynamically allocated array of string pointers, which in turn point to a dynamically allocated buffer containing the strings.  (It's my get_cl algorithm.  It munges the whitespace, quotes, etc, into a list of arguments each with null-terminated strings.)  If I allocate this memory on the heap, the caller must then figure out how to deallocate it, which is certain to be a pain.  Right now the best solution I've come up with is to write it as a <em>pair</em> of procedures, GetCommandLineArgsBuffer and ReleaseCommandLineArgsBuffer.  This type of memory problem reeks (to me, anyway) of &quot;trying to write C code in assembler&quot;.<br /><br />3. Consider the following code:<br /><pre><code><br />.data<br />    Msg         db &quot;Here is the command line&#58;&quot;, 0dh, 0ah, 0<br /><br />.data?<br />    CommandLine     LPSTR ?<br /><br />.code<br />start&#58;<br />    invoke GetCommandLine<br />    mov CommandLine, eax<br /><br />    invoke StdOut, addr Msg<br />    invoke StdOut, CommandLine<br />    invoke ExitProcess,0 <br />end start<br /></code></pre><br /><br />Specifically, consider the StdOut calls.  Msg needs the addr prefix, CommandLine does not.  Yet they are both addresses.  What's up with that?  (I'm getting really tired of debugging with nothing more than SWH* in my toolbox.)<br /><br />* SWH = &quot;See What Happens&quot;  <em>See also: DBS (Debugging By Superstition) and Programming With NFC (No Freaking Clue)</em><br /><br />Hmm, in reconsidering this, Msg *isn't* a pointer, is it?  If I pass Msg to that function, I'm passing the value 65726548h ('ereH'), right?  Ah-ha!  No wonder it's AVing on me.<br /><br />4. I can't remember question 4.<br /><br />Thanks all!<br /><br />-Chalain</div>
    <div class="meta">Posted on 2002-04-21 20:00:00 by Chalain</div>
   </div>
   <div class="post" id="post-34363">
    <div class="subject"><a href="#post-34363">Re: Bag O'Questions II: The Bag Strikes Back</a></div>
    <div class="body"><div class="quote">If I allocate this memory on the heap, the caller must then figure out how to deallocate it, which is certain to be a pain.  Right now the best solution I've come up with is to write it as a <em>pair</em> of procedures, GetCommandLineArgsBuffer and ReleaseCommandLineArgsBuffer.</div>When an API passes an array, it usually requires the caller to allocate the memory first, then pass a pointer to the buffer as a parameter, and also pass the length of the buffer as another parameter. The API then calculates how much space it needs, compares that to how much the caller gave it, if the caller did not allocate enough buffer then the API returns with an error, but it also fills a third 'out' parameter with the size required. This way Windoze avoids being responsible for memory leaks by making the caller allocate/deallocate the buffer. This is why sometimes you will see an API called twice: the first time with a zero length buffer, the API will error and calculate how much it needs, and then the caller will allocate a buffer of the correct size and call the API again.<br /><br /><br /><div class="quote">Msg needs the addr prefix, CommandLine does not.  Yet they are both addresses.</div>Nope. Msg is merely a label for a range of bytes, that is why you need to add the 'addr' during the call.<br /><br /><br /><div class="quote">4. I can't remember question 4.</div>And i can't remember the answer, so we are all square :grin:</div>
    <div class="meta">Posted on 2002-04-21 21:03:34 by sluggy</div>
   </div>
   <div class="post" id="post-34365">
    <div class="subject"><a href="#post-34365">Bag O'Questions II: The Bag Strikes Back</a></div>
    <div class="body">1a)<br /><br />lea         ecx,<br /><br />basically, it multiplies ecx by 5...  mov ecx,(ecx+(ecx*4))<br /><br />as for ecx,,<br />it moves into ecx the value of edx + ecx*2 - 30h...<br /><br />you can multiply by a power of 2 to scale a register, add a base, and add an immediate all in one cycle.  i saw a multiplication table for leas somewhere before (but i'm sure you can figure it out by yourself) up to like 100.<br /><br />so, yes, you are correct about its function.<br /><br />1b)  leave it to intel and their cool ALU :)<br /><br />2)  i'll leave that to someone else...  that seems right...  allocate, store pointer.  use it.  free pointer.<br /><br />or, using Global/LocalAllocs, allocate, get handle, cvt handle to pointer, store pointer. use it.  free handle.<br /><br />3)  you solved your own problem :)  also, don't forget about the OFFSET prefix (similar to ADDR).  most functions, i find, in Win32, return a pointer to null-terminated strings/a structure, or to a handle.  make sure you know what each API's expected return is.</div>
    <div class="meta">Posted on 2002-04-21 21:07:46 by jademtech</div>
   </div>
   <div class="post" id="post-34367">
    <div class="subject"><a href="#post-34367">Re: Bag O'Questions II: The Bag Strikes Back</a></div>
    <div class="body"><div class="quote"><br />1. I just peeked at some disassembly of my code, and saw this garble:<pre><code>77E36F56   movsx       edx,dl<br />77E36F59   lea         ecx,&#91;ecx+ecx*4&#93;<br />77E36F5C   inc         eax<br />77E36F5D   lea         ecx,&#91;edx+ecx*2-30h&#93;</code></pre>1a. Is that what's really happening here?<br />1b. How the heck can the machine, at runtime, embed a *4 in an opcode?!?</div>This looks like <strong>Svin</strong>'s code for converting an ASCII number.<br /><br />1a. ECX = ECX*10 + (DL - &quot;0&quot;); this is what is happening<br /><br />1b. The addressing modes of the x86 allow a constant multiplier of 1,2,4,8 - this is part of the effective address calculation.  Look at the Intel manuals for a greater explantion.</div>
    <div class="meta">Posted on 2002-04-21 21:11:05 by bitRAKE</div>
   </div>
   <div class="post" id="post-34368">
    <div class="subject"><a href="#post-34368">Bag O'Questions II: The Bag Strikes Back</a></div>
    <div class="body">Hi Chalain,<br /><br /><br />1a. No,  lea ecx,  says first add together edx and ecx, multiply the result by two, then subtract 48, and store the result in ecx.  It doesn't resolve any addresses, rather its used for indexing.<br /><br />1b. The machine isn't embedding the 4 at run time.  It was in there right after compile time.<br /><br /><br />2.  There's really no fancy way to allocate memory in Win32 aside from what functions you already have to use.  The OS manages memory.  If you want to implement your own memory manager in Win32, then I would advise building it on top of the API.<br /><br />3. There's 2 major differences between Commandline and Msg in your example.  Commandline is a variable that holds a pointer to a string, while MSG is a label that identifies the start of a string.<br /><br />A little example to help you visualize better:<br /><pre><code>.data<br />	Msg db &quot;Here is the command line&#58;&quot;, 0dh, 0ah, 0<br />	;  &#91;b&#93;0012FDEC&#91;/b&#93;&#58; 48 65 72 65 20 69 73 20 74 68 65 20<br />	;            63 6f 6d 6d 61 6e 64 20 6c 69 6e 65<br />	;            3a 0d 0a 00<br />	;<br />.data?<br />	CommandLine LPSTR ?<br />	;  &#91;b&#93;0012FE08&#91;/b&#93;&#58; 00 00 00 00<br />.code<br />	invoke GetCommandLine<br />	;  call GetCommandLine<br /><br />	mov CommandLine, eax<br />	;  mov dword ptr &#91;&#91;b&#93;0012FE08&#91;/b&#93;&#93;, eax<br />	;  &#40;put value of eax into memory at address 0012FE08&#41;<br /><br />	invoke StdOut, addr Msg<br />	;  push &#91;b&#93;0012FDEC&#91;/b&#93;<br />	;  &#40;push address of the first byte in the character array at 0012FDEC&#41;<br />	;  call StdOut<br /><br />	invoke StdOut, Commandline<br />	;  mov eax, dword ptr &#91;&#91;b&#93;0012FE08&#91;/b&#93;&#93;<br />	;  &#40;move the dword variable at address 0012FE08 into eax&#41;<br />	;  &#40;eax now contains the pointer to the command line string<br />	;  that was previously put in there by GetCommandLine&#41;<br />        ;  push eax<br />	;  call StdOut</code></pre>Hope that helps.  Good luck.</div>
    <div class="meta">Posted on 2002-04-21 21:14:20 by iblis</div>
   </div>
   <div class="post" id="post-34439">
    <div class="subject"><a href="#post-34439">Bag O'Questions II: The Bag Strikes Back</a></div>
    <div class="body">Well I am still confused as to exactly what Lea is used for . I think i understand the first sample.. just not sure exactly to why:?<br /><br />Is it just a nother mutliplication feature that is supposed to be faster or what?<br /><br />anyways if somebody could help post a few no brainer samples and explain how they work and what they do i would appreciate it</div>
    <div class="meta">Posted on 2002-04-22 10:08:08 by Volcano_88101</div>
   </div>
   <div class="post" id="post-34452">
    <div class="subject"><a href="#post-34452">Bag O'Questions II: The Bag Strikes Back</a></div>
    <div class="body">lea .... load effective address ...<br />it computes the effective address of the given memory location and stores it in to the given regiter ... since caculating the effective address inculdes addition and multiplication, this instruction is used also to compute the the sum of the content of the registers (and if you want you can also multiply them by 2, 4 or 8) in one single instruction ....</div>
    <div class="meta">Posted on 2002-04-22 10:52:28 by code1101</div>
   </div>
   <div class="post" id="post-34526">
    <div class="subject"><a href="#post-34526">Bag O'Questions II: The Bag Strikes Back</a></div>
    <div class="body">it performs the equivilent of shl, not mul.</div>
    <div class="meta">Posted on 2002-04-22 17:28:29 by jademtech</div>
   </div>
   <div class="post" id="post-34675">
    <div class="subject"><a href="#post-34675">Bag O'Questions II: The Bag Strikes Back</a></div>
    <div class="body">Hi all<br /><br />I decided to go back to your ASCII table program, and rewrote<br />it to show some uses for LEA.<br />It uses a line buffer that has all the drawing characters predefined and i fill in the info for each line and then output to console.<br /><br />Note that I use .686 that enables instructions for PII and forward because i am using the conditional move instruction that is not supported if i use .386.<br /><br /><br />;===========================================<br />;  File: ascii.asm<br />;  Desc: Prints the ASCII chart as a 16x16 grid with hex labels.  My<br />;   first (original) assembly program.  <br />;  Auth: Chalain<br />;  Date: 04/17/2002<br />;<br />;  Modified by Towers  Date 04/23/2002<br />;<br />;-----------------------------------------------------------------------<br />; Notes:<br />;       Win32 Assembly *console* project.  To compile and link with masm32,<br />;               use BLDALLC.BAT, or compile by hand like so:<br />;<br />;       ml /c /coff ascii.asm<br />;       link /SUBSYSTEM:CONSOLE ascii.obj<br />;<br />;=================================================<br /><br />;-----------------------------------------------------------------------<br />; DIRECTIVES<br />;-----------------------------------------------------------------------<br />.686<br />.model flat, stdcall<br />option casemap:none<br /><br />;-----------------------------------------------------------------------<br />; INCLUDES<br />;-----------------------------------------------------------------------<br />.nolist<br />include \masm32\include\Windows.inc<br />include \masm32\include\masm32.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\user32.inc<br /><br />includelib \masm32\lib\user32.lib<br />includelib \masm32\lib\masm32.lib<br />includelib \masm32\lib\kernel32.lib<br />.list<br />;-----------------------------------------------------------------------<br />; .DATA<br />;-----------------------------------------------------------------------<br />.data<br /><br />; ascii-art caption text<br />AsciiArtTopBars     db &quot;  &quot;,218, 33 dup(196),191,13,10<br />AsciiArtTopCaption  db &quot;  &quot;,179<br />		    db &quot; 0 1 2 3 4 5 6 7 8 9 A B C D E F &quot;<br />		    db 179, 13, 10<br />AsciiArtTopBar2     db 218,196,197, 33 dup(196),180,13,10,0<br /><br />AsciiArtBottomBar   db 192,196,193, 33 dup(196), 217, 13, 10, 0<br />linebuf             db 179,32,179,32, 32 dup (32),179,13,10,0<br /><br />;----------------------------------------------------------------------<br />; .DATA?<br />;----------------------------------------------------------------------<br />.data?<br />y                   dd ?<br /><br />;----------------------------------------------------------------------<br />; .CODE<br />;----------------------------------------------------------------------<br />.code<br />start:<br />    invoke StdOut, addr AsciiArtTopBars   ; first 3 header lines<br /><br />    mov y,0<br />    .WHILE y&lt;16<br />	 mov edx,0<br />	 mov ecx,y<br />	 shl ecx,4              ;  y*16 is a constant for 16 x<br />morex:   <br />	 lea eax,   ; x + y*16<br /><br />	  mov ebx,20h<br />	 <br />	  cmp eax,0<br />	  cmovz eax,ebx            ; if 0,7,8,9,10,13<br />	  cmp eax,7                ; load blank<br />	  cmovz eax,ebx<br />	  cmp eax,8<br />	  cmovz eax,ebx<br />	  cmp eax,9<br />	  cmovz eax,ebx<br />	  cmp eax,10<br />	  cmovz eax,ebx<br />	  cmp eax,13<br />	  cmovz eax,ebx<br /><br />				     ; first char place in line buffer<br />	  lea ebx,  ; and index by x*2<br />	  mov ,al             ; put the ascii char into buffer<br />	    <br />	 inc edx<br />	 cmp edx,16                ; loop until x (edx) =16<br />	jb morex<br />	<br />	 mov eax,y                  ; calculate ASCII value of y<br />	 add eax,030h               ; if number add 30h<br />	 cmp eax,03Ah<br />	 jb @F <br />	 add eax,07h                ; if A-F   add 30h+7<br />@@:        <br />	 mov ,al         ; put y into place in line buffer<br />	 invoke StdOut, addr linebuf  ; print the line<br />	inc y<br />    .ENDW<br /><br />    invoke StdOut, addr AsciiArtBottomBar<br />    invoke ExitProcess, 0<br />end start</div>
    <div class="meta">Posted on 2002-04-23 14:13:46 by towers</div>
   </div>
  </div>
 </body>
</html>