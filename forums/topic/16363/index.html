<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Optimization questions - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16363" />
    <link rel="next" href="../?id=16363&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=16363">Optimization questions</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=16363&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=16363&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="16363" /><input type="number" name="page" min="1" max="4" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=16363&amp;page=2">&gt;</a><a href="../?id=16363&amp;page=4">&raquo;</a></form>   <div class="post" id="post-127116">
    <div class="subject"><a href="#post-127116">Optimization questions</a></div>
    <div class="body">Hello everyone. I've been looking through the Pentium 4 optimization manual from Intel and I have a few questions about some things I've read. Alignment is mentioned a lot, and I understand what it is and why it helps, but how exactly do you go about aligning something? I also read about aligning code to x boundries. How exactly do you go about aligning code? It mentioned using nop's or something like mov eax,eax but how do you know how many of these to do to align it to any particular boundry? There is also a lot of talk about micro ops, throughput, and latency, but I can't seem to find a list for all the instructions on the P4. There is a list in the back of the book, but it's not complete and it doesn't tell the number of micro ops. Does pairing still matter on the P4, or is that just for the P6 type processors? From the way things looked in the book, it's not so much the uv pipes as it is issue ports and execution units. Are the 4 ports pretty much like the uv pipes except there are 4 instead of 2? I admit that I'm looking at things that are probably a step or two beyond where I'm at as an assembly programmer, but I'm still curious about these things.<br /><br />Also, I guess while I'm here... how can I actually do anything using the @FileName macro? I can't declare a string that's initialized to the filename because quotes make the string and &quot;@FileName&quot; is exactly that, @FileName, heh.<br /><br />Thanks for any help, comments, or links :grin:</div>
    <div class="meta">Posted on 2003-12-09 04:22:19 by AlexEiffel</div>
   </div>
   <div class="post" id="post-127118">
    <div class="subject"><a href="#post-127118">Optimization questions</a></div>
    <div class="body">Assemblers generally have alignment directives. MASM for example has &quot;ALIGN n&quot;, where n is the byte boundary to align on.<br />It will then automatically pad the code (or data) to get to the next boundary. When done in code, it will try to use the shortest possible sequence of 'nop' instructions (lea eax,  for example is a long one).<br />The P4-list may not be complete, but I think most stuff from the P3-list still applies, more or less. It should do well enough in practice, I'd say. Just pay extra attention to the P4's ability to executes some instructions in 0.5 clks.<br />As for pairing, that was never really an issue on P6-processors. They can reorder code dynamically, so the exact order doesn't really matter. The ports are important, as you said, but also the decoding. Some instructions are too long to be decoded by the second and third decoder, for example, and then they stall until they can be decoded by the first decoder in the next clk. If you reorder your code a bit, you can get a better decoder throughput. Then again, usually the decoder is faster than the execution units, so if it stalls every now and then, you won't notice it right away, since the decoder can catch up again before the execution units run out of micro-ops.<br />The Intel Optimization manual (at least the PIII one) explains the architecture in great detail... It will tell you that there are 5 ports, and each of those is unique in some way... I don't recall exactly at this moment, but it was something like 2 ports for ALU, 1 port for load, 1 port for store, and... the last was FPU/MMX/SSE? I'm not sure, anyay, they were all different, and they could all be used at the same time.<br />Anyway, check the manuals, they should be a good guide.</div>
    <div class="meta">Posted on 2003-12-09 06:05:38 by Bruce-li</div>
   </div>
   <div class="post" id="post-127127">
    <div class="subject"><a href="#post-127127">complete instruction set.</a></div>
    <div class="body"><a target="_blank" href="www.intel.com">www.intel.com</a>  go to developers section for download:<br /><br />NOTE: The Intel Architecture Software Developer?s Manual consists of<br />three volumes: Basic Architecture, Order Number 243190; Instruction Set<br />Reference, Order Number 243191; and the System Programming Guide,<br />Order Number 243192.<br />Please refer to all three volumes when evaluating your design needs.<br /><br />As far as FileNames, have you done any study into Iczelion's tutorials?<br /><br /><a target="_blank" href="http://spiff.tripnet.se/~iczelion/">http://spiff.tripnet.se/~iczelion/</a><br /><br />I usually find what I'm looking for there.</div>
    <div class="meta">Posted on 2003-12-09 07:48:17 by mrgone</div>
   </div>
   <div class="post" id="post-127330">
    <div class="subject"><a href="#post-127330">Optimization questions</a></div>
    <div class="body">Bruce: Thanks for clearing a few things up for me. I'll keep looking through the manuals.<br /><br />mrgone: Thanks for the reply, but I think maybe I wasn't clear on what I mean with FileNames. I wasn't talking about getting a filename from Windows, but using the Masm @FileName directive to get the name of the file that it is in. I just can't figure out how to get the result of the directive into a string to use in my programs. I actually have all of the manuals that you mentioned and they are definately good sources of information.</div>
    <div class="meta">Posted on 2003-12-10 19:30:03 by AlexEiffel</div>
   </div>
   <div class="post" id="post-127488">
    <div class="subject"><a href="#post-127488">Optimization questions</a></div>
    <div class="body">You need something like:<br /><br />the_filename db @catstr&lt;&quot;!&quot;&quot;, @Filename, &quot;!&quot;, 0&quot;&gt;<br /><br />I've got this working in the past, and it is something like this. I can't try it out at the moment though...<br /><br />Mirno</div>
    <div class="meta">Posted on 2003-12-12 04:59:06 by Mirno</div>
   </div>
   <div class="post" id="post-127502">
    <div class="subject"><a href="#post-127502">Optimization questions</a></div>
    <div class="body">Alex,<br /><br />Have a look at the optimisation manual for a PIV to get the general outline of instruction scheduling. It has a detailed section on preferred instruction usage. What you will find in practice is that you can get very bad stalls on a PIV if you don't get it right, different size register reads and writes like shifting from DWORD to WORD or BYTE on the same register will generate these stalls among other things.<br /><br />Data alignment is based on the hardware requirement that the processor needs to take 2 reads to get a DWORD that is not aligned to a 4 byte boundary. Some of the later XMM instructions require a higher alignment with data in memory.<br /><br />In practice, sometimes code alignment matters, some times it does not, when you can do it without interfering with instructions before it, you can align labels to some advantage at times.<br /><br />Instruction scheduling is not exactly the same thing as pairing was on the earlier Intel processors but it does work in much the same way. The preferred instruction set runs faster than they did on earlier Intel processors for a given clock frequency so any problems in instruction sequences generates large time differences.<br /><br />Instructions like shifts and rotates are slower relatively and LEA does not have the performance advantage it had on earlier processors from the 486 up.<br /><br />Just for example, If you wrote code to truncate a value to its next lowest boundary of 4, you used to write code like,<br /><pre><code><br />mov eax, oddnumber<br />shr eax, 2<br />shl eax, 2<br /></code></pre><br />On a PIV it is faster to use adds for the SHL operation so you would write,<br /><pre><code><br />mov eax, oddnumber<br />shr eax, 2<br />add eax, eax<br />add eax, eax<br /></code></pre><br />PIV code is faster if you get it right so its worth the effort to have a good read of the PIV manual set and especially the optimisation manual.<br /><br />Regards,<br /><br />http://www.asmcommunity.net/board/cryptmail.php?tauntspiders=in.your.face@nomail.for.you&amp;id=2f46ed9f24413347f14439b64bdc03fd</div>
    <div class="meta">Posted on 2003-12-12 08:01:43 by hutch--</div>
   </div>
   <div class="post" id="post-127504">
    <div class="subject"><a href="#post-127504">Optimization questions</a></div>
    <div class="body"><div class="quote">Just for example, If you wrote code to truncate a value to its next lowest boundary of 4, you used to write code like,</div><br /><br /><pre><code><br />mov eax, oddnumber<br />and eax, NOT 3<br /></code></pre></div>
    <div class="meta">Posted on 2003-12-12 08:05:46 by Bruce-li</div>
   </div>
   <div class="post" id="post-127508">
    <div class="subject"><a href="#post-127508">Optimization questions</a></div>
    <div class="body">Cute piece of optimisation but you have missed the point about using shifts. This is what Intel have to say about replacing SHL with adds.<br /><div class="quote"><br />The shift and rotate instructions have a longer latency on the Pentium 4 processor than on previous processor generations. The latency of a sequence of adds will be shorter for left shifts of three or less. Fixed and variable shifts have the same latency. Assembly/Compiler Coding Rule 42. (M impact, M generality) If a shift is on a critical path, replace it by a sequence of up to three adds. If its latency is not critical, use the shift instead because it produces fewer ?ops.<br /></div><br />Benchmarking shows that Intel actually know what they are talking about.<br /><br />Regards,<br />http://www.asmcommunity.net/board/cryptmail.php?tauntspiders=in.your.face@nomail.for.you&amp;id=2f46ed9f24413347f14439b64bdc03fd</div>
    <div class="meta">Posted on 2003-12-12 08:52:51 by hutch--</div>
   </div>
   <div class="post" id="post-127514">
    <div class="subject"><a href="#post-127514">Optimization questions</a></div>
    <div class="body">donkey,<br /><br />The example was to actually round down to the next 4 byte boundary,<br /><br />and eax, -4 works fine but it missed the point of replacing left shifts with adds.<br /><br />Regards,<br /><br />http://www.asmcommunity.net/board/cryptmail.php?tauntspiders=in.your.face@nomail.for.you&amp;id=2f46ed9f24413347f14439b64bdc03fd</div>
    <div class="meta">Posted on 2003-12-12 09:10:37 by hutch--</div>
   </div>
   <div class="post" id="post-127530">
    <div class="subject"><a href="#post-127530">Optimization questions</a></div>
    <div class="body">Here's the post Hutch is referring to above :)<br /><br />Isn't it supposed to be, you want to align to the next DWORD. Bruce-Li's code will just truncate the lower 2 bits.<br /><br /><pre><code>mov eax, oddnumber<br />&#91;b&#93;add eax,3&#91;/b&#93;<br />and eax, NOT 3</code></pre><br /><br />&lt;edit&gt;Sorry, I misread Hutch's post, couldn't see the point of aligning downward so didn't consider it&lt;/edit&gt;</div>
    <div class="meta">Posted on 2003-12-12 09:43:20 by donkey</div>
   </div>
   <div class="post" id="post-127554">
    <div class="subject"><a href="#post-127554">Optimization questions</a></div>
    <div class="body">hutch:<br /><div class="quote"><br /><br />Cute piece of optimisation but you have missed the point about using shifts. This is what Intel have to say about replacing SHL with adds.<br /><br />    quote:<br />    The shift and rotate instructions have a longer latency on the Pentium 4 processor than on previous processor generations. The latency of a sequence of adds will be shorter for left shifts of three or less. Fixed and variable shifts have the same latency. Assembly/Compiler Coding Rule 42. (M impact, M generality) If a shift is on a critical path, replace it by a sequence of up to three adds. If its latency is not critical, use the shift instead because it produces fewer ?ops.<br /><br /><br />Benchmarking shows that Intel actually know what they are talking about.<br /><br /></div><br /><br />lol!!<br />but the point here is why would you do a shift in the first place?<br />shift of more than 1 will require the value of the shift encoded in the instruction , one byte I think (shift of 1 place dont require it)<br /><br />BruceLi:<br /><div class="quote"><br /><br />code:<br />mov eax, oddnumber<br />and eax, NOT 3<br /><br /></div><br /><br />my little noobie self outperforms both solutions by the following masterpiece :grin:  :<br />and al,1111 1100<br /><br />coz with &quot;and eax,not 3&quot; you ll have to include a full &quot;not 3&quot;-dword in your opcode : doh! (to be said with homer 's voice)<br />with al you just have a one-byte &quot;not 3&quot;.<br /><br />or did I miss something?<br /><br />donkey:<br /><div class="quote"><br />Isn't it supposed to be, you want to align to the next DWORD. Bruce-Li's code will just truncate the lower 2 bits.<br /><br />code:mov eax, oddnumber<br />add eax,3<br />and eax, NOT 3<br /></div><br /><br />anyway hutch s code did the same...</div>
    <div class="meta">Posted on 2003-12-12 11:49:54 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-127555">
    <div class="subject"><a href="#post-127555">Optimization questions</a></div>
    <div class="body"><div class="quote"><br />donkey:<br /><br /><br />anyway hutch s code did the same... </div><br /><br />Ummmm, no it doesn't. At least not the same thing mine does (not really mine). Mine will always align up to the closest DWORD Hutch's and Bruce-Li's will just truncate the bottom 2 bits.</div>
    <div class="meta">Posted on 2003-12-12 11:52:22 by donkey</div>
   </div>
   <div class="post" id="post-127556">
    <div class="subject"><a href="#post-127556">Optimization questions</a></div>
    <div class="body"><div class="quote">my little noobie self outperforms both solutions by the following masterpiece  :<br />and al,1111 1100<br /><br />coz with &quot;and eax,not 3&quot; you ll have to include a full &quot;not 3&quot;-dword in your opcode : doh! (to be said with homer 's voice)<br />with al you just have a one-byte &quot;not 3&quot;.<br /><br />or did I miss something?</div><br /><br />That will work yes... the problem is that you are using a partial register, and when using eax again afterwards, you will get a stall...<br />And the other part is, and supports sign-extension if I'm not mistaken... So if you disassemble the code, and eax, NOT 3 will just store NOT 3 in 1 byte anyway (assuming you use an assembler that writes the shortest possible opcodes, MASM will do this for you automatically).<br /><br />So, it's a nice idea, good to see someone using their head :)<br />But I don't think it's an improvement in this case.</div>
    <div class="meta">Posted on 2003-12-12 11:54:13 by Bruce-li</div>
   </div>
   <div class="post" id="post-127557">
    <div class="subject"><a href="#post-127557">Optimization questions</a></div>
    <div class="body">IMHO, Hutch just wanted to make and example on replacing shifts with additions. So maybe he picked the wrong example, that doesn't invalidate his point, nor does it imply he's not a good programmer, you know ;)<br />People, let's not get this thread moved to the Crusades, ok? :(<br /><br />@HelloWorld:<br />Good thinking :) got to move to 32 bits registers though, the 16 and 8 bit ones don't give you size optimizations in most cases, and will slow you down due to stalls. The Intel optimization manual is a good reference material for this stuff:<br /><br /><a target="_blank" href="">http://www.asmcommunity.net/board/showthread.php?threadid=14740&amp;highlight=intel+free</a></div>
    <div class="meta">Posted on 2003-12-12 12:02:24 by QvasiModo</div>
   </div>
   <div class="post" id="post-127560">
    <div class="subject"><a href="#post-127560">Optimization questions</a></div>
    <div class="body">Nobody said that hutch--'s point about the shifts was invalid, hutch-- just felt attacked, as usual. So he felt he had to retaliate, as usual.<br />And it does imply he's not a good programmer... I mean, a good programmer would never even come up with this example, because he'd know to use an and for that, and shifts would never occur to him.<br />I'd probably use an example of a multiply replaced by shifts and adds instead, or something.</div>
    <div class="meta">Posted on 2003-12-12 12:07:01 by Bruce-li</div>
   </div>
   <div class="post" id="post-127561">
    <div class="subject"><a href="#post-127561">Optimization questions</a></div>
    <div class="body">donkey:<br /><div class="quote"><br />Ummmm, no it doesn't. At least not the same thing mine does (not really mine). Mine will always align up to the closest DWORD Hutch's and Bruce-Li's will just truncate the bottom 2 bits.<br /></div><br /><br />I meant &quot;hutch's code does the same as BruceLi's code&quot;, obviously...<br /><br /><br />BruceLi:<br /><div class="quote"><br />That will work yes... the problem is that you are using a partial register, and when using eax again afterwards, you will get a stall...<br /></div><br />i must apologise to you then... not for not knowing this and posting anyway, of course, but for thinking to myself &quot;heck! learn to code before you learn the slight differences between pIII and pIV!&quot; :grin: ... anyway, it DID matter in this case to know the pipeline internal, and I m not familiar with this at all and i was worng... So what is best of course is to know everything :)<br /><br /><div class="quote"><br />And the other part is, and supports sign-extension if I'm not mistaken..<br /></div><br />could you explain what this means to me?<br /><br /><div class="quote"><br />MASM will do this for you automatically<br /></div><br />ddddddoh!!!!!!<br />and if I f_ckin do WANT to produce it? :)  nasm rules (although nasm sux for not having ORG)</div>
    <div class="meta">Posted on 2003-12-12 12:08:29 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-127562">
    <div class="subject"><a href="#post-127562">Optimization questions</a></div>
    <div class="body"><div class="quote"><br />Nobody said that hutch--'s point about the shifts was invalid, hutch-- just felt attacked, as usual. So he felt he had to retaliate, as usual.<br />And it does imply he's not a good programmer... I mean, a good programmer would never even come up with this example, because he'd know to use an and for that, and shifts would never occur to him.<br />I'd probably use an example of a multiply replaced by shifts and adds instead, or something. </div><br />Then it would be more constructive if you post such an example. :)<br />Anyway you can't judge someone's programming ability on some quick sample from the top of his head. It's not even like Hutch's code was wrong, it just wasn't <em>the best possible</em>, right?</div>
    <div class="meta">Posted on 2003-12-12 12:10:43 by QvasiModo</div>
   </div>
   <div class="post" id="post-127563">
    <div class="subject"><a href="#post-127563">Optimization questions</a></div>
    <div class="body"><div class="quote"><br />ddddddoh!!!!!!<br />and if I f_ckin do WANT to produce it? :)  nasm rules (although nasm sux for not having ORG) </div><br />:grin: :grin: :grin: <br />Guess you're right... unless there's some command-line switch to disable that feature (there probably is, but I'm too lazy to check ;) ).<br /><br />EDIT: You can also hardcode the opcode using DB, but it's kinda chating you know :grin:</div>
    <div class="meta">Posted on 2003-12-12 12:12:53 by QvasiModo</div>
   </div>
   <div class="post" id="post-127565">
    <div class="subject"><a href="#post-127565">Optimization questions</a></div>
    <div class="body"><div class="quote">i must apologise to you then...</div><br /><br />No problem, I didn't take offence anyway.<br /><br /><div class="quote">could you explain what this means to me?</div><br /><br />Well it's an old trick... For example, if you want to load -1 into eax, I believe that or eax, -1 is the shortest possible way (this is what compilers have been doing lately anyway).<br />This is because there are multiple forms for encoding immediate operands.<br />Some instructions can store eg -1 as a byte (0xFF), and it is expanded to -1 as a dword (0xFFFFFFFF) by the CPU before it is fed to the execution unit. This means the code size in memory is still small.<br /><br /><div class="quote">ddddddoh!!!!!!<br />and if I f_ckin do WANT to produce it?  nasm rules (although nasm sux for not having ORG)</div><br /><br />Why would you ever want a non-optimal encoding of your instructions? :)<br />Anyway, you can still handcode the opcode in MASM that way, clumsy perhaps, but it's possible :)<br /><br /><div class="quote">Then it would be more constructive if you post such an example. <br />Anyway you can't judge someone's programming ability on some quick sample from the top of his head. It's not even like Hutch's code was wrong, it just wasn't the best possible, right?</div><br /><br />I think the point of the shifts/adds came across anyway, no need to spam more examples, it's trivial stuff anyway.<br />And in case you didn't know yet, hutch-- and I go back a long way, I got banned in the past for disagreeing with hutch--... But he can't ban me now, because he got stripped of his administrator rights (for obvious reasons).<br />So he can just flame me now, and I can handle him, he'll just make himself look like an idiot :)</div>
    <div class="meta">Posted on 2003-12-12 12:17:31 by Bruce-li</div>
   </div>
   <div class="post" id="post-127566">
    <div class="subject"><a href="#post-127566">Optimization questions</a></div>
    <div class="body"><div class="quote"><br />Why would you ever want a non-optimal encoding of your instructions? :)<br />Anyway, you can still handcode the opcode in MASM that way, clumsy perhaps, but it's possible :)<br /></div><br />Mutant code maybe? (It's the only use I could think of). You're right, it's not very useful... :)</div>
    <div class="meta">Posted on 2003-12-12 12:22:29 by QvasiModo</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=16363&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=16363&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="16363" /><input type="number" name="page" min="1" max="4" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=16363&amp;page=2">&gt;</a><a href="../?id=16363&amp;page=4">&raquo;</a></form>  </div>
 </body>
</html>