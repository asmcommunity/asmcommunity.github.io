<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Reverse addition (using aaa) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=12934" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=12934">Reverse addition (using aaa)</a></p>
   <div class="post" id="post-100515">
    <div class="subject"><a href="#post-100515">Reverse addition (using aaa)</a></div>
    <div class="body">Here is a program (written in HLA - sorry folks... ) which tests the speed of addition of two BCD numbers - actually reverse addition of a 1 megabyte BCD number to itself.<br /><br />The number is chosen to cause a carry after each addition.<br /><br />The addition is repeated several times and a clock cycle count per single digit addition calculated. (The total cycle count is shown in decimal if edx=0, else in hexadecimal)<br /><br />Executable and HLA source (and the MASM output of HLA) are enclosed in the zip file below.<br /><br />Feel free to post optimizations (incl. MMX, SSE, SSE2) and times.<br /><br /><pre><code><br />// **********************************<br />// Reverse Addition Test Program <br />//         Coded using HLA<br />// <br />// **********************************<br /><br />program RevaddCheck;<br />#include&#40; &quot;stdlib.hhf&quot; &#41;;<br /><br />const<br />     memtoalloc &#58;=$200000;  // &#91;2MB = 1048576 bytes&#93;<br />     upperalloc &#58;=$100000;  // &#91;1MB = 1048576 bytes&#93;<br />     numberadds &#58;=50;<br />static &#40;4&#41;<br /><br />     mem1addr&#58; pointer to byte;<br />     mem2addr&#58; pointer to byte;<br />     mem1lsb&#58; pointer to byte;<br />     mem2lsb&#58; pointer to byte;<br />     numadd&#58; int32&#58;=numberadds;<br /> <br />     t&#58;time.timerec;<br /><br />begin RevaddCheck;<br /><br />     console.cls&#40;&#41;;<br />     console.gotoxy&#40;4, 15&#41;;<br />     stdout.put &#40; &quot;Addition Test Program.&quot;, nl&#41;;<br />     console.gotoxy&#40;5, 15&#41;;<br />     stdout.put &#40; &quot;        Coded using HLA&quot;, nl, nl&#41;;<br />     stdout.put &#40; &quot;This program times the reverse addition &#40;using aaa&#41;&quot;, nl&#41;;<br />     stdout.put &#40; &quot;of a megabyte length BCD number to itself...&quot;, nl, nl, nl&#41;;<br /><br />     stdout.put &#40; &quot;Initializing memory. Initial Time&#58; &quot;&#41;;<br />     time.curTime&#40;t&#41;;<br />//     stdout.put&#40;t.hours&#58;2, '&#58;', t.mins&#58;2, '&#58;', t.secs&#58;2&#41;;<br />     stdout.puti16Size&#40;t.hours, 2, '0'&#41;;<br />     stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.mins, 2, '0'&#41;;<br />     stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.secs, 2, '0'&#41;;<br /><br /><br />// Allocate RAM; On return EAX contains address; <br />     malloc &#40;memtoalloc&#41;;<br /><br />// Store memory address<br />     mov &#40;eax, mem1addr&#41;;<br />     add &#40;upperalloc,eax&#41;;<br />     mov &#40;eax, mem2addr&#41;;<br />     dec &#40;eax&#41;;<br />     mov &#40;eax, mem1lsb&#41;;<br />     add &#40;upperalloc,eax&#41;;<br />     mov &#40;eax, mem2lsb&#41;;<br /><br />// Clear memory<br />     mov &#40;mem1addr, esi&#41;;<br />     mov &#40;mem2addr, edi&#41;;<br />     xor &#40;eax, eax&#41;;      // Fill m3m2 with BCD 0000<br />     mov &#40;$07060504,edx&#41;; // Fill mem1 with BCD 7654<br />     mov &#40;upperalloc, ecx&#41;;<br />     sub &#40;4, ecx&#41;;<br />clm1&#58;<br />     mov &#40;edx, &#91;esi+ecx&#93;&#41;;<br />     mov &#40;eax, &#91;edi+ecx&#93;&#41;;<br /><br />     sub &#40;4, ecx&#41;;<br />     jns clm1;<br /><br />// Commencing Message<br />     stdout.put &#40; nl, nl,&quot;Commencing addition.         Time&#58; &quot;&#41;;<br />     time.curTime&#40;t&#41;;<br />//     stdout.put&#40;t.hours&#58;2, '&#58;', t.mins&#58;2, '&#58;', t.secs&#58;2&#41;;<br />     stdout.puti16Size&#40;t.hours, 2, '0'&#41;;<br />     stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.mins, 2, '0'&#41;;<br />     stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.secs, 2, '0'&#41;;<br /><br />// ADD NUMBER at ds&#58;esi to its reverse at ds&#58;ebx; store at ds&#58;edi<br />// actually &#91;esi&#93;, &#91;ebx&#93; are the least, and most significant digit<br />// respectively of the source number and &#91;edi&#93; is the LSD of the target<br /><br />          rdtsc;                       // First measure of time<br />                                       // rdtsc takes 13 cycles on Pentium MMX,<br />          push &#40;edx&#41;;                  // I store the 64 bit cycle count on the stack. <br />          push &#40;eax&#41;;<br /><br />adding&#58;<br />          mov &#40;mem1lsb, esi&#41;;          // source<br />          mov &#40;mem1addr, ebx&#41;;         // source<br />          mov &#40;mem2lsb, edi&#41;;          // destination<br />          mov &#40;upperalloc, ecx&#41;;       // number of digits<br /><br /><br />// add byte pairs with aaa<br />#asm<br /><br />add1&#58;     mov al,&#91;esi&#93;<br />          adc al,&#91;ebx&#93;<br />          aaa<br />          mov &#91;edi&#93;,al<br />          dec esi<br />          inc ebx<br />          dec edi<br />          dec ecx<br />          jnz add1<br />#endasm<br />// Note the final carry from the final addition is not stored<br /><br />// repeat numadd times<br />          dec &#40;numadd&#41;;<br />          jne adding;<br /><br />// Check clocks<br />          rdtsc;                       // Second measure of time<br />          push &#40;edx&#41;;<br />          push &#40;eax&#41;;<br /><br />// Completion Message<br />     stdout.put &#40; nl, nl,&quot;Addition Completed.          Time&#58; &quot;&#41;;<br />     time.curTime&#40;t&#41;;<br />//     stdout.put&#40;t.hours&#58;2, '&#58;', t.mins&#58;2, '&#58;', t.secs&#58;2&#41;;<br />     stdout.puti16Size&#40;t.hours, 2, '0'&#41;;<br />     stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.mins, 2, '0'&#41;;<br />     stdout.put&#40;'&#58;'&#41;;<br />     stdout.puti8Size&#40;t.secs, 2, '0'&#41;;<br /><br />     mov &#40;upperalloc, ebx&#41;;<br /><br />     stdout.put&#40;nl,nl&#41;;<br />     stdout.putu32&#40;ebx&#41;;<br />     stdout.put &#40;&quot; single-digit additions performed &quot;&#41;;<br />     stdout.putu32&#40;numberadds&#41;;<br />     stdout.put &#40;&quot; times &quot;&#41;;<br /><br />// Retrieve 2nd rdtsc<br />          pop &#40;eax&#41;;<br />          pop &#40;edx&#41;;<br /><br />          sub &#40;&#91;esp&#93;, eax&#41;;             // subtract first from second<br />          sbb &#40;&#91;esp+4&#93;,edx&#41;;            // result in EDX&#58;EAX<br /><br />          add &#40;8, esp&#41;;                 // remove first edx, eax from stack<br /><br /><br />    if &#40;edx=0&#41; then <br />         stdout.put &#40;nl, &quot;in &quot;&#41;;<br />         stdout.putu32&#40;eax&#41;;<br />         stdout.put&#40;&quot; clock cycles = &quot;, nl&#41;;<br />    else<br />         stdout.put &#40;nl, &quot;in $&quot;,edx,&quot; &quot;,eax, &quot; clock cycles = &quot;, nl&#41;;<br />    endif;<br /><br />     mov &#40;upperalloc, ebx&#41;;<br />     div &#40;ebx, edx&#58;eax&#41;;<br />     stdout.putu32&#40;eax&#41;;<br />     push &#40;eax&#41;;<br />     stdout.put &#40;&quot; clock cycles for &quot;&#41;;<br />     stdout.putu32&#40;numberadds&#41;;<br />     stdout.put &#40;&quot; single digit additions =&quot;,nl&#41;;<br /><br />     pop &#40;eax&#41;;<br />     xor &#40;edx,edx&#41;;<br />     mov &#40;numberadds, ebx&#41;;<br />     div &#40;ebx, edx&#58;eax&#41;;<br /><br />     stdout.putu32&#40;eax&#41;;<br />     stdout.put &#40;&quot; clock cycles per single digit addition.&quot;,nl,nl&#41;;<br /><br />end RevaddCheck;<br /></code></pre><br /><br />I get variable timings (internet connected) of 16 cycles (and above) per addition on a Pentium MMX, and of 64 cycles (and above) on a K6-2.<br /><br />Why so slow? Alignment?</div>
    <div class="meta">Posted on 2003-05-01 06:31:10 by V Coder</div>
   </div>
   <div class="post" id="post-100519">
    <div class="subject"><a href="#post-100519">Reverse addition (using aaa)</a></div>
    <div class="body">Try changing dec xxx to sub xxx,1. That's the only speed optimisation I can find.  Anyway, Athlon is weird. xor eax,eax is slower on Athlon than on intel.</div>
    <div class="meta">Posted on 2003-05-01 06:48:41 by roticv</div>
   </div>
   <div class="post" id="post-100641">
    <div class="subject"><a href="#post-100641">Reverse addition (using aaa)</a></div>
    <div class="body">Thanks roticv, but.... as I was just about to do that ... I wondered if the rationale was that ADD &amp; SUB pair better than INC &amp; DEC? or would they take up less space?<br /><br />So, I went to the Integer Pairing Tables, and found that whereas ADC and SBB pair in the U pipe only, ADD, SUB, INC and DEC all pair in U or V... So there should be no theoretical improvement with using Sub instead of DEC...<br /><br />Then I noticed another thing: SUB breaks the main routine.<br /><br />The routine is a simple loop ADC (with carry) {after the addition, the carry will always be 0, since two nibbles are added in al from , . any overflow past 9 will be recognized by ...} AAA {if al &gt;9, al=al-10 and carry set; else carry remains cleared} INC &amp; DEC pointers, maintaining carry flag {INC &amp; DEC affect the Zero and Sign flags but not the carry flag}<br /><br /><pre><code><br />// add byte pairs with aaa<br />#asm<br /><br />add1&#58;     mov al,&#91;esi&#93;<br />          adc al,&#91;ebx&#93;<br />          aaa<br />          mov &#91;edi&#93;,al<br />          dec esi<br />          inc ebx<br />          dec edi<br />          dec ecx<br />          jnz add1<br />#endasm<br /></code></pre><br /><br />Once DEC ecx does not reach 0, the loop continues.<br /><br />Unfortunately, SUB would also zero the carry flag, so the carry from the last addition would be lost...<br /><br />I believe that this represents the most optimal routine for single digit addition. What would an MMX optimization or something for BCD addition look like?</div>
    <div class="meta">Posted on 2003-05-01 21:11:36 by V Coder</div>
   </div>
   <div class="post" id="post-101027">
    <div class="subject"><a href="#post-101027">Reverse addition (using aaa)</a></div>
    <div class="body">This 4 digit optimization, <a target="_blank" href="http://www.asmcommunity.net/board/showthread.php?threadid=12949">http://www.asmcommunity.net/board/showthread.php?threadid=12949</a> based on Jones' algorithm, <a target="_blank" href="http://www.cs.uiowa.edu/~jones/bcd/bcd.html">http://www.cs.uiowa.edu/~jones/bcd/bcd.html</a> takes 10 cycles...<br /><br /><pre><code><br />          sub edi,3<br />          sub esi,3<br />          sub esi, ecx<br />          sub edi, ecx<br /><br />          clc<br />          pushf<br />add1&#58;     popf<br />          mov eax,&#91;esi+ecx&#93;<br />          bswap eax<br />          adc eax,&#91;ebx&#93;<br />         <br />          add eax, 0f6f6f6f6h<br />          pushf<br />          mov edx, eax<br />          and edx, 30303030h<br />          shr edx, 3<br />          sub eax, edx<br />          and eax, 0f0f0f0fh<br /><br />          bswap eax<br />          mov &#91;edi+ecx&#93;,edx<br />          add ebx, 4<br />          sub ecx, 4<br />          jnz add1<br /><br />          popf1</code></pre><br /><br />Please see Jones webpage for an explanation of how it works.</div>
    <div class="meta">Posted on 2003-05-04 01:02:24 by V Coder</div>
   </div>
   <div class="post" id="post-101090">
    <div class="subject"><a href="#post-101090">Reverse addition (using aaa)</a></div>
    <div class="body">You most probably don't always have  a multiple of 4 bytes in the &quot;string&quot; you have to add. I assume you would follow up with single-byte additions to complete the overall addition.<br /><br />I can also only assume that it was a typo in your posted code. I would think that<br />mov ,edx should have been mov ,<strong>eax</strong>.<br /><br />Raymond</div>
    <div class="meta">Posted on 2003-05-04 11:04:17 by Raymond</div>
   </div>
   <div class="post" id="post-101102">
    <div class="subject"><a href="#post-101102">Reverse addition (using aaa)</a></div>
    <div class="body">Here's the joy of it...<br /><br />You don't have to follow up with single digit adds!!!!<br /><br />And thanks, about the _edx_ thing. Nope I'm not blind. Actually, its a test routine, and I was trying to avoid a pairing problem with writing to a register (mov edx, eax) and changing it right after (and edx...), so I changed to and eax..., but some of the final changes did not make it to the post.<br /><br />This is the corrected version. It reported 7 cycles immediately when I tested it. Thereafter it is reporting 9 cycles.  :grin:<br /><br /><pre><code><br />          sub edi,3<br />          sub esi,3<br />          sub esi, ecx<br />          sub edi, ecx<br /><br />          clc<br />          pushf<br />add1&#58;     popf<br />          mov eax,&#91;esi+ecx&#93;<br />          bswap eax<br />          adc eax,&#91;ebx&#93;<br />        <br />          add eax, 0f6f6f6f6h<br />          pushf<br />          mov edx, eax<br />          and eax, 30303030h ; use eax here instead of edx<br />          shr eax, 3<br />          sub edx, eax<br />          and edx, 0f0f0f0fh ; result in edx<br /><br />          bswap edx<br />          mov &#91;edi+ecx&#93;,edx<br />          add ebx, 4<br />          sub ecx, 4<br />          jnz add1<br /><br />          popf</code></pre></div>
    <div class="meta">Posted on 2003-05-04 12:14:34 by V Coder</div>
   </div>
  </div>
 </body>
</html>