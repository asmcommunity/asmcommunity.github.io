<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Random number - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=633" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=633">Random number</a></p>
   <div class="post" id="post-3771">
    <div class="subject"><a href="#post-3771">Random number</a></div>
    <div class="body">Any body got a method for generating a random number?<br />Like for shuffling a set of cards or rolling dice.<br />I believe i saw someone post something like that on the old board.<br /><br />thanx a gig:o</div>
    <div class="meta">Posted on 2001-08-14 16:50:49 by titan</div>
   </div>
   <div class="post" id="post-3772">
    <div class="subject"><a href="#post-3772">Linear congruent pseudorandom number generator</a></div>
    <div class="body">push the limit and call it, eax return a rnd between 0..limit-1<br /><br />somebody told me once its similar to the rnd routine used by psx videogame...<br /><br />ancev<br /><br /><pre><code><br /><br />rnd&#58;<br />       push ebp ecx edx<br />       mov eax, &#91;pseed&#93;<br />       mov ecx, 41c64e6dh<br />       mul ecx<br />       add eax, 3039h<br />       and eax, 7ffffffh<br />       mov &#91;pseed&#93;, eax<br />       mov ecx, &#91;esp+&#40;4*3&#41;+4&#93;<br />       sub edx, edx<br />       div ecx<br />       xchg eax, edx<br />       pop edx ecx ebp<br />       ret 4<br /><br /></code></pre></div>
    <div class="meta">Posted on 2001-08-14 17:20:55 by ancev</div>
   </div>
   <div class="post" id="post-3774">
    <div class="subject"><a href="#post-3774">here it is</a></div>
    <div class="body">Hi,<br /><br />This very good random number generator is written by Wiz Kid<br />I only suggest you to use it...go to his site etc<br /><br />It only looks a little complicated because its inside a DLL but the actual function is simple and very powefull ...<br /><br /><br /><pre><code><br /><br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />;;                                                                           ;;<br />;; Whiz Kid Technomagic Random Number Generator                              ;;<br />;;                                                                           ;;<br />;; Windows 95 DLL                                                            ;;<br />;;                                                                           ;;<br />;; Copyright 1998 G. Adam Stanislav                                          ;;<br />;; All rights reserved                                                       ;;<br />;;                                                                           ;;<br />;; Company name&#58; Whiz Kid Technomagic                                        ;;<br />;; Company e-mail&#58; &#91;email&#93;whizkid@bigfoot.com&#91;/email&#93;                                       ;;<br />;; Web site&#58; &#91;url&#93;www.bigfoot.com/~whizkid&#91;/url&#93;                                        ;;<br />;;                                                                           ;;<br />;; Started&#58; 10-Aug-1998                                                      ;;<br />;; Updated&#58; 11-Aug-1998                                                      ;;<br />;;                                                                           ;;<br />;; Permission is hereby granted to use this DLL with your software under the ;;<br />;; following conditions&#58;                                                     ;;<br />;;                                                                           ;;<br />;;    &#40;1&#41; You will not modify it in any way, including but not limited to    ;;<br />;;        preserving the copyright notice embeded in the DLL.                ;;<br />;;                                                                           ;;<br />;;    &#40;2&#41; You will install it in Windows system folder.                      ;;<br />;;                                                                           ;;<br />;;    &#40;3&#41; You will not install it over a later version of this DLL.          ;;<br />;;                                                                           ;;<br />;; That is quite simple...                                                   ;;<br />;;                                                                           ;;<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />TITLE Whiz Kid Technomagic Random Number Generator<br />.386<br />.model flat<br /><br />option dotname<br /><br />.data<br /><br />; Our seed number is 39 bits wide. Our random number is a 32-bit integer<br />; produced from the 39-bit seed number.<br />.seed	dd	0<br />		db	11101b	; At least one of the 39 bits must be non-zero!<br /><br />.code<br /><br />; Microsoft linker gets really cranky if the label of the DLL entry does not start<br />; with an underline. Other than that, it can be named anything. However, it should<br />; end with @12, otherwise the linker gives us a warning.<br />align dword<br />_dll@12	proc	public<br /><br />	mov	al, 1	; Windows is happy when EAX is not 0. To save bytes, we just use AL.<br />	ret	12<br /><br />_dll@12	endp<br /><br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />;;<br />;; To make the DLL useful for everyone, we need to supply two procedures for<br />;; for every function. One that is fast, one that is compatible with Windows 95<br />;; calling conventions.<br />;;<br />;; The fast ones receive their parameters in the CPU registers. These procedures<br />;; can be called directly only from assembly language programs.<br />;;<br />;; The compatible ones receive parameters on the stack. The also need to have<br />;; their names mangled in strange ways &#40;preceded by an underline, followed<br />;; by '@' and the number of bytes passed on stack&#41;. They also need to clean up<br />;; the stack. They can be called by programs written in presumably any language.<br />;;<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />;;<br />;; We need to allow the calling program to initialize the seed value. Otherwise,<br />;; the program would receive the same sequence of pseudo-random numbers every<br />;; time it runs.<br />;;<br />;; We shall name the &quot;compatible&quot; procedure _WktmrngSetSeed@4. In C, it would be<br />;; declared something like this&#58;<br />;;<br />;;    unsigned __stdcall WktmrngSetSeed&#40;unsigned&#41;;<br />;;<br />;; It could be int instead of unsigned. It could also be long or unsigned long<br />;; &#40;or might have to be, depending on the compiler&#41;.<br />;;<br />;; The function returns the new seed just set. Or it can be treated as &quot;void.&quot;<br />;;<br />;; The &quot;Wktmrng&quot; stands for &quot;Whiz Kid Technomagic Random Number Generator.&quot;<br />;; We use it since it is theoretically possible a program may be linked to<br />;; another DLL which also may contain a SetSeed&#40;&#41; function.<br />;;<br />;; Of course, we can also place the following in a header file&#58;<br />;;<br />;;    #define SetSeed   WktmrngSetSeed<br />;;<br />;; That makes coding simpler.<br />;;<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />;;<br />;; Now, as mentioned above, a &quot;compatible&quot; function must clean its stack.<br />;; So, the first instinct may be to do something like this&#58;<br />;;<br />;;    _WktmrngSetSeed@4 proc public<br />;;<br />;;        push    ebp<br />;;        mov     ebp, sp<br />;;        mov     eax, &#91;ebp+8&#93;<br />;;        call    wktmrngsetseed<br />;;        leave<br />;;        ret     4<br />;;<br />;;    _WktmrngSetSeed@4 endp<br />;;<br />;; Of course, that would work, but we can do it much faster. And we will&#58;<br />;;<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br /><br />; Note&#58; We do not use align dword here. The previous procedure is 5 bytes long,<br />; this one is 3 bytes long. So this procedure is all within one dword, and the<br />; next procedure &#40;to which we fall through&#41; is aligned at dword boundary.<br />_WktmrngSetSeed@4	proc	public<br /><br />	;; Input&#58;<br />	;;    &#91;ESP+4&#93; = bits 31-0 of new seed<br />	;; Output&#58;<br />	;;    EAX = bits 31-0 of new seed<br />	;; Registers changed&#58;<br />	;;    EAX, EDX<br /><br />	pop	edx		; Save return address in EDX<br />	pop	eax		; Get new seed in EAX<br />	push	edx	; Restore return address on top of the stack<br /><br />	; Notice, no ret here, we are falling through to wktmrngsetseed<br /><br />_WktmrngSetSeed@4	endp<br /><br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />;;<br />;; Next we create our &quot;fast&quot; procedure, one that is not concerned with stack<br />;; parameters and similar plague of high-level languages.<br />;;<br />;; We shall name it wktmrngsetseed. Again, we can use a &quot;define&quot; or actually<br />;; an equ in assembly language programs, like this&#58;<br />;;<br />;;    extrn __imp_wktmrngsetseed&#58;dword<br />;;    SetSeed   equ   __imp_wktmrngsetseed<br />;;<br />;; Then to call it, just do&#58;<br />;;<br />;;    mov    eax, newseed<br />;;    call   SetSeed<br />;;<br />;; The assembler will automatically interpret the call as&#58;<br />;;<br />;;    call   dword ptr&#58;__imp_wktmrngsetseed<br />;;<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br /><br />wktmrngsetseed	proc	public<br /><br />	;; Input&#58;<br />	;;    EAX = bits 31-0 of new seed<br />	;; Output&#58;<br />	;;    EAX = same<br />	;; Registers modified&#58;<br />	;;    None<br /><br />	mov	.seed, eax		; Initialize the lower 32 bits of seed<br />	; Also initialize the rest of it to some fixed number other than 0<br />	mov	byte ptr .seed&#91;4&#93;, 11101b<br />	ret<br /><br />wktmrngsetseed	endp<br /><br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />;;<br />;; OK, so how do we produce a random number? Well, we do not. It is not possible<br />;; to create a truly random number in software alone. What we can do, however,<br />;; is produce a sequence of pseudo-random numbers.<br />;;<br />;; Such a sequence is cyclical. That means that after we have come up with N<br />;; numbers, the sequence repeats. In other words, the &#40;N+1&#41;st result will be<br />;; the same as the 1st result, the &#40;N+2&#41;nd result the same as the 2nd result, etc.<br />;;<br />;; That does not sound too good, but it is not a problem if N is reasonably<br />;; large.<br />;;<br />;; Entire volumes have been written about producing a pseudo-random sequence<br />;; using software methods. They typically follow this algorithm&#58;<br />;;<br />;;    new seed      &#58;= old seed * A + B<br />;;    random number &#58;= new seed<br />;;<br />;; In this algorithm A and B are some constants.<br />;;<br />;; The volumes that have been written deal mostly with methods of choosing the<br />;; right values for A and B, so N is reasonably large.<br />;;<br />;; This is an OK method for random-number generators written in high-level<br />;; languages &#40;HLL&#41;. But we can do much better in assembly language.<br />;;<br />;; Since we are as close to accessing the hardware directly as we can using<br />;; software methods alone, we will code a method developed by hardware<br />;; engineers. They use what they call a feedback shift register &#40;FSR&#41;. You can<br />;; read about it in Chapter 9 &#40;pages 655-657&#41; of The Art of Electronics,<br />;; Second Edition, by Paul Horowitz and Winfield Hill, ISBN 0-521-37095-7.<br />;; This is a book anyone dealing with computers &#40;and electronics in general&#41;<br />;; should have anyway.<br />;;<br />;; A FSR shifts the seed value one bit to the right. It than XORs the bit<br />;; shifted out with one or more bits inside the old seed and stores the<br />;; result in the most significant bit of the new seed &#40;which is also the<br />;; new random number&#41;. The choice of which bit to XOR is beyond the scope<br />;; of this comment -- you can find it in the book mentioned above.<br />;;<br />;; In case of a 39-bit FSR, we must XOR the bit shifted out either with<br />;; bit 35 or bit 4 of the old seed.<br />;;<br />;; The FSR method has several advantages&#58; First, it is very easy to implement<br />;; in hardware &#40;which makes you wonder why the Intel processor family does not<br />;; have a built-in random register. More importantly, with the proper choice<br />;; of bits to XOR, the n of the sequence is very high. For a 39-bit sequence<br />;; which we are implementing in this DLL, N = 549,755,813,887. Yes, you call<br />;; the procedure below more than half a trillion times before the sequence starts<br />;; repeating. That is way bigger than any of the A,B choices in the HLL design<br />;; mentioned above.<br />;;<br />;; The method has one slight problem&#58; If the seed is initialized to 0, the<br />;; whole sequence degenerates. All remaining &quot;random numbers&quot; will be zeros.<br />;; By the same token, the sequence will never produce a zero in all bits<br />;; if initialized to any number but 0. We get around this problem by using<br />;; a larger than 32-bit sequence, and placing a 1 to some of the higher bits<br />;; whenever initializing the seed. And because we are only using the other<br />;; 32 bits for our result, we can also receive a zero as a random number.<br />;;<br />;; So, why is it not used in software much? Is it, perhaps, too hard to implement<br />;; using an HLL? Well, it is very simple with assembly language.<br />;;<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />;;<br />;; In this case, no parameter is passed to our procedure. That means that<br />;; our &quot;compatible&quot; function and fast funtion are one and the same.<br />;;<br />;; The assembler lets us assign any number of names to the same procedure,<br />;; so we will name it _WktmrngGetRandomNumber@0 for HLL programs and<br />;; wktmrnggetrandomnumber for assembly language program &#40;just to be<br />;; consistent with the nameing convention of the above procedures.<br />;;<br />;; In C, we can declare it as&#58;<br />;;<br />;;    unsigned WktmrngGetRandomNumber&#40;void&#41;;<br />;;    #define GetRandomNumber   WktmrngGetRandomNumber<br />;;<br />;; In assembly language&#58;<br />;;<br />;;    extrn __imp_wktmrnggetrandomnumber&#58;dword<br />;;    GetRandomNumber   equ   __imp_wktmrnggetrandomnumber<br />;;<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />align dword<br /><br />_WktmrngGetRandomNumber@0	proc	public<br />wktmrnggetrandomnumber	proc	public<br /><br />	;; Input&#58;<br />	;;    None<br />	;; Output&#58;<br />	;;    EAX = 32-bit pseudo-random number<br />	;; Registers modified&#58;<br />	;;    EAX<br /><br />	; Save registers used for anything but return value<br />	push	ecx<br />	push	edx<br /><br />	; Move bits 31-0 of old seed to EAX<br />	mov	eax, .seed<br />	; Move bits 38-32 of old seed to DL, set DH = 0<br />	movzx	edx, byte ptr .seed&#91;4&#93;<br />	; Shift bits 32-1 to bits 31-0<br />	shrd	eax, edx, 1<br />	; Save bits 31-0 of new seed<br />	mov	.seed, eax<br /><br />	; Store bit 0 of OLD seed in DH<br />	adc	dh, 0		; DH = bit shifted out of EAX<br />	; Shift bits 38-33 of old seed to bits 37-32<br />	shr	dl, 1<br />	; Get bit 35 of old seed to the lsb of CL<br />	mov	cl, dl<br />	shr	cl, 2<br />	and	cl, 1		; CL = bit 35 of old seed<br />	xor	dh, cl		; xor it with old bit 0<br />	shl	dh, 6<br />	or	dl, dh		; store it in bit 38 ...<br />	mov	byte ptr .seed&#91;4&#93;, dl	; ... of new seed<br /><br />	pop	edx<br />	pop	ecx<br />	ret<br /><br />	; That's all, folks!<br /><br />wktmrnggetrandomnumber	endp<br />_WktmrngGetRandomNumber@0	endp<br /><br />end	_dll@12<br /><br /></code></pre></div>
    <div class="meta">Posted on 2001-08-14 17:45:59 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-5911">
    <div class="subject"><a href="#post-5911">Random number</a></div>
    <div class="body">how about this ?<br /><br /><br /><br />&quot;rdtsc&quot;<br /><br /><br /><br />if u want get a random char, this is nice choice..<br /><br />al = return char</div>
    <div class="meta">Posted on 2001-09-03 00:44:53 by c][obo</div>
   </div>
   <div class="post" id="post-5916">
    <div class="subject"><a href="#post-5916">Random number</a></div>
    <div class="body">I wrote a faily decient random function a while ago (based on statical methods i learned in a university course...) It has a very long repeating pattern.. I tested it with &quot;random&quot; x, y pixel cordinates and a &quot;random&quot; color. I used direct X and painted the screen randomly to see its pattern... <br /><br />If it patterened anyway.. it sucked... <br />If a overall color developed (other than an off gray) it sucked... (since grey is a sum of equally likely average values in RGB..) <br /><br />The test was quite good and passed my above tests... <br /><br />Here is the macro i made out of it... <br /><br /><pre><code><br />RAND32 MACRO base&#58;REQ<br />  ; Random number generator based on the Real time clock<br />  ; and the Park, Miller random number algorithm<br />  ;<br />  ; Coded by NaN for WIN32ASM<br />  ; May 5, 2001<br />  ; rev 2.<br /><br /><br />  push ecx<br />  push edx<br /><br />  ifndef __RAND_BY_NAN__<br />  __RAND_BY_NAN__ equ 1<br />  <br />     .data? <br />     NaNRand dd ?<br />     .code<br /><br />  db 0fh,31h <br />  shr eax, 2<br />  add eax, 1<br />  mov NaNRand, eax<br />  endif<br />  <br />  mov eax, NaNRand    <br />  mov edx,0<br />  mov ecx, 127773 ;q<br />  div ecx      ; eax == floor&#40; seed / q&#41;<br />               ; edx == remainder<br />  SWAP eax, edx<br />  push edx<br />  mov ecx, 16807<br />  mul ecx      ; eax = mul of remainder * a<br />  pop edx      ; edx == floor of seed/q<br />  <br />  SWAP eax, edx<br />  push edx<br />  mov ecx, 2836<br />  mul ecx<br />  pop edx      ; edx == mull of rem * a<br />               ; eax == mull of seed/q * r<br />               <br />  sub edx, eax<br />  mov eax, edx    <br />  mov NaNRand, eax ; save next seed <br />  mov ecx, base<br />  mov edx, 0<br />  div ecx<br />  mov eax, edx<br />  pop edx<br />  pop ecx<br />  EXITM &lt;eax&gt;<br />ENDM</code></pre><br /><br />Basic use is like evey other, eax == rand # between 0-(base -1)<br /><br />  mov hRandNumber, RAND32( 16 )   ; eax == Rand in the set {0,..,15}<br /><br />I checked out Wiz Kid's version, and to me they *appear* identical in function (since his tests by the same methods), but never put the effort in to clock which is fastest (dont care really). Also, i wrote this while i was still a bit green in the world of MASM so im sure there is an optomization or two in there if you did care..)<br /><br /><br />Oh ya, here is the SWAP macro.. it exchanges register values... I dont know if its faster than xchang but i got a kick outa how neat it works...<br /><pre><code><br />      SWAP MACRO M1&#58;REQ, M2&#58;REQ<br />        xor M1, M2<br />        xor M2, M1<br />        xor M1, M2<br />      ENDM<br /></code></pre><br /><br />Hope it helps..<br />NaN</div>
    <div class="meta">Posted on 2001-09-03 01:13:24 by NaN</div>
   </div>
   <div class="post" id="post-7766">
    <div class="subject"><a href="#post-7766">Random number</a></div>
    <div class="body">This modification doesn't use ecx, or the SWAP macro:<pre><code>	mov eax, NaNRand    <br />	xor edx,edx<br />	push 127773	;q<br />	div DWORD PTR &#91;esp&#93;	; eax == floor&#40; seed / q&#41;<br />			; edx == remainder<br />	push eax<br />	mov eax, 16807<br />	mul edx      ; eax = mul of remainder * a<br />	pop edx      ; edx == floor of seed/q<br /><br />	push eax<br />	mov eax, 2836<br />	mul edx<br />	pop edx		; edx == mull of rem * a<br />			; eax == mull of seed/q * r<br />	sub edx, eax<br />	mov eax, edx    <br />	mov NaNRand, edx ; save next seed <br />	push base<br />	mov edx, 0<br />	div DWORD PTR &#91;esp&#93;<br />	add esp,8<br />	mov eax, edx</code></pre></div>
    <div class="meta">Posted on 2001-09-22 12:00:11 by bitRAKE</div>
   </div>
   <div class="post" id="post-7878">
    <div class="subject"><a href="#post-7878">Random number</a></div>
    <div class="body">Thanx BitRake....  I wrote that when i was still a bit green in MASM coding...  Never got around to cleaning it up (dont use it all to often :) ), but thanx again.<br /><br />NaN</div>
    <div class="meta">Posted on 2001-09-24 01:24:14 by NaN</div>
   </div>
   <div class="post" id="post-7882">
    <div class="subject"><a href="#post-7882">Random number</a></div>
    <div class="body">Another formula is :<br /><br />Random(j+1) = 16807 * Random(j) mod 2147483647<br /><br />It can be coded like this :<br /><br /><pre><code><br /><br />RANDOM MACRO<br /><br />IFNDEF _RANDOM<br />_RANDOM = 1<br /><br />.DATA<br />seed dword 1<br />.CODE<br /><br />ENDIF<br /><br />  ; next number<br />  <br />  mov  eax, seed<br />  mov  ebx, 16807<br />  mov  ecx, 2147483647<br />  mul   ebx<br />  div    ecx<br />  mov  seed, edx<br /><br />  ; result in edx and seed<br /><br />ENDM<br /><br /></code></pre></div>
    <div class="meta">Posted on 2001-09-24 02:15:16 by Dr. Manhattan</div>
   </div>
   <div class="post" id="post-30915">
    <div class="subject"><a href="#post-30915">Random number</a></div>
    <div class="body">BogdanOntanu, the only problem I have with Whiz Kid's rng is that it uses shift operations and each random number returned depends highly on the previous one.  It works great to fill up the screen with random pixels with good distribution but doesn't do too well on the chi square test (basic gist of it is the randomness of each successive # generated isn't very random wrt to the previously generated #.  See &quot;Inner Loops&quot; for a more in depth explanation).<br /><br />A really fast algo that is used a lot is the r250 rng which uses a table of 250 random starting values and then xors two of these values together to return a random #.  Of course it has to be seeded with another (simple) random # generator.  It runs at 10 clocks / random number and is a fairly decent pseudo rng.  Code follows.  Btw I think he just used the increment table to save some cycles.<br /><br /><pre><code><br /><br />        align   4<br />IL_R250RandomIndex1   dd          0<br />IL_R250RandomIndex2   dd        103<br />IL_R250Table          dd        250 dup &#40;0&#41;<br />IL_R250IncrementTable db          1,  2,  3,  4,  5,  6,  7,  8,  9, 10  <br />                      db         11, 12, 13, 14, 15, 16, 17, 18, 19, 20  <br />                      db         21, 22, 23, 24, 25, 26, 27, 28, 29, 30  <br />                      db         31, 32, 33, 34, 35, 36, 37, 38, 39, 40  <br />                      db         41, 42, 43, 44, 45, 46, 47, 48, 49, 50  <br />                      db         51, 52, 53, 54, 55, 56, 57, 58, 59, 60  <br />                      db         61, 62, 63, 64, 65, 66, 67, 68, 69, 70  <br />                      db         71, 72, 73, 74, 75, 76, 77, 78, 79, 80  <br />                      db         81, 82, 83, 84, 85, 86, 87, 88, 89, 90  <br />                      db         91, 92, 93, 94, 95, 96, 97, 98, 99,100  <br />                      db        101,102,103,104,105,106,107,108,109,110  <br />                      db        111,112,113,114,115,116,117,118,119,120  <br />                      db        121,122,123,124,125,126,127,128,129,130  <br />                      db        131,132,133,134,135,136,137,138,139,140  <br />                      db        141,142,143,144,145,146,147,148,149,150  <br />                      db        151,152,153,154,155,156,157,158,159,160  <br />                      db        161,162,163,164,165,166,167,168,169,170  <br />                      db        171,172,173,174,175,176,177,178,179,180  <br />                      db        181,182,183,184,185,186,187,188,189,190  <br />                      db        191,192,193,194,195,196,197,198,199,200  <br />                      db        201,202,203,204,205,206,207,208,209,210  <br />                      db        211,212,213,214,215,216,217,218,219,220  <br />                      db        221,222,223,224,225,226,227,228,229,230  <br />                      db        231,232,233,234,235,236,237,238,239,240<br />                      db        241,242,243,244,245,246,247,248,249,  0<br /><br />_IL_DATA ends<br /><br />_IL_TEXT segment<br /><br />;void IL_R250RandomSeed_A&#40;long &#40;*rand&#41;&#40;&#41;&#41;<br />;<br />;Seeds IL_R250Random&#40;&#41; using rand&#40;&#41; function.  Uses 250 32-bit values.<br />;<br />IL_R250RandomSeed_A proc near C public uses esi ebx, rand&#58;dword ;  ;<br />        mov     IL_R250RandomIndex1,0           ;  ;<br />        mov     IL_R250RandomIndex2,103         ;  ;<br />        mov     esi,&#40;250-1&#41;*4                   ;  ;<br />        .repeat                                 ;  ;<br />          call  rand                            ;  ;<br />          mov   IL_R250Table&#91;esi&#93;,eax           ;  ;<br />          sub   esi,4                           ;  ;<br />        .until SIGN?                            ;  ;<br />        mov     eax,0ffffffffH                  ;  ;<br />        mov     ecx,80000000H                   ;  ;<br />        lea     esi,IL_R250Table+3*4            ;  ;<br />        .repeat                                 ;  ;<br />          mov   edx,&#91;esi&#93;                       ;  ;<br />          and   edx,eax                         ;  ;<br />          or    edx,ecx                         ;  ;<br />          shr   eax,1                           ;  ;<br />          mov   &#91;esi&#93;,edx                       ;  ;<br />          add   esi,7*4                         ;  ;<br />          shr   ecx,1                           ;  ;<br />        .until ZERO?                            ;  ;<br />        ret                                     ;  ;<br />IL_R250RandomSeed_A endp                        ;  ;<br /><br />;long IL_R250Random_A&#40;&#41;<br />;<br />;Returns a pseudo-random 32-bit number.<br />;<br />IL_R250Random_A proc near C public uses ebx     ; 1;<br />        nop                                     ; 0;for alignment<br />        mov     edx,IL_R250RandomIndex1         ; 1;get index 1<br />        mov     ecx,IL_R250RandomIndex2         ; 0;get index 2<br />        mov     eax,IL_R250Table&#91;edx*4&#93;         ; 2;get @ index 1<br />        mov     ebx,IL_R250Table&#91;ecx*4&#93;         ; 0;get @ index 2<br />        xor     eax,ebx                         ; 1;xor result<br />        mov     cl,IL_R250IncrementTable&#91;ecx&#93;   ; 0;inc/loop ecx<br />        mov     IL_R250Table&#91;edx*4&#93;,eax         ; 1;save result<br />        mov     dl,IL_R250IncrementTable&#91;edx&#93;   ; 0;inc/loop edx<br />        mov     IL_R250RandomIndex1,edx         ; 1;new index 1<br />        mov     IL_R250RandomIndex2,ecx         ; 0;new index 2<br />        ret                                     ; 3;and return<br />IL_R250Random_A endp                            ;;;;10 cycles<br /><br /><br /></code></pre></div>
    <div class="meta">Posted on 2002-03-26 01:48:21 by grv575</div>
   </div>
   <div class="post" id="post-30962">
    <div class="subject"><a href="#post-30962">Random number</a></div>
    <div class="body">I just set up and tried vecna's algo and it works fine. Must get around to trying the rest at some time.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-03-26 06:05:29 by hutch--</div>
   </div>
   <div class="post" id="post-31032">
    <div class="subject"><a href="#post-31032">Random number</a></div>
    <div class="body">For anyone who's interested (and knows C) here's the chi-square test which is one test used to measure the &quot;randomness&quot; of a generator.  Just plug in a generator for (*rand)().<br /><br /><pre><code><br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;math.h&gt;<br /><br />#define IL_RMULT 1103515245<br />long IL_StandardRandom_seed = 1234567890;<br /><br />long IL_StandardRandom&#40;void&#41;<br />&#123;<br />    unsigned long lo, hi, ll, lh, hh, hl;<br /><br />    lo = IL_StandardRandom_seed &amp; 0xffff;<br />    hi = IL_StandardRandom_seed &gt;&gt; 16;<br />    IL_StandardRandom_seed = IL_StandardRandom_seed * IL_RMULT + 12345;<br />    ll = lo * &#40;IL_RMULT  &amp; 0xffff&#41;;<br />    lh = lo * &#40;IL_RMULT &gt;&gt; 16    &#41;;  <br />    hl = hi * &#40;IL_RMULT  &amp; 0xffff&#41;;<br />    hh = hi * &#40;IL_RMULT &gt;&gt; 16    &#41;;  <br />    return &#40;&#40;ll + 12345&#41; &gt;&gt; 16&#41; + lh + hl + &#40;hh &lt;&lt; 16&#41;;<br />&#125;<br /><br />double IL_RandomChiSquareTest&#40;long &#40;*rand&#41;&#40;&#41;&#41;<br />&#123;<br />    unsigned long *ar, n, l, lo, hi;<br />    unsigned char *p;<br />    double sqrsum, chisqr, dev, norm;<br /><br />    ar = calloc&#40;2 * 0x10000, 5&#41;;<br />    if &#40;!ar&#41;<br />        return 999999.0;                                // flags failure<br />    p  = &#40;unsigned char *&#41;&#40;ar + 2 * 0x10000&#41;;<br />    for &#40;n = 0; n &lt; 10 * 0x10000; n++&#41; &#123;<br />        l  = rand&#40;&#41;;<br />        lo = l &amp; 0xffff;<br />        hi = &#40;l &gt;&gt; 16&#41; | 0x10000;<br />        if &#40;!++p&#91;lo&#93;&#41;<br />            ar&#91;lo&#93; += 0x100;<br />        if &#40;!++p&#91;hi&#93;&#41;<br />            ar&#91;hi&#93; += 0x100;<br />    &#125;<br />    for &#40;n = 0; n &lt; 2 * 0x10000; n++&#41;<br />        ar&#91;n&#93; += p&#91;n&#93;;<br />    for &#40;n = 0, sqrsum = 0; n &lt; 2 * 0x10000; n++&#41;<br />        sqrsum += ar&#91;n&#93; * &#40;double&#41;ar&#91;n&#93;;<br />    free&#40;ar&#41;;<br />    chisqr = &#40;&#40;2 * 0x10000 * sqrsum&#41; / &#40;2 * 10 * 0x10000&#41;&#41; - 2 * 10 * 0x10000;<br />    dev    = chisqr - 2 * 0x10000;<br />    norm   = 2 * sqrt&#40;2 * 0x10000&#41;;<br />    return dev / norm;<br />&#125;<br /><br />void main&#40;void&#41;<br />&#123;<br />	double tests, off, d;<br />    long &#40;*rand&#41;&#40;&#41;;<br /><br />    *rand = IL_StandardRandom;<br />    tests = 0;<br />    off   = 0;<br />    while &#40;1&#41; &#123;<br />        d = IL_RandomChiSquareTest&#40;rand&#41;;<br />        tests += 1;<br />        if &#40;&#40;d &lt;= -1&#41; || &#40;d &gt;= 1&#41;&#41;<br />            off += 1;<br />        printf&#40;<br />           &quot;Chi square deviation percentage&#58; %3d  &quot;<br />           &quot;&#40;15 +/- a few is good; Enter quits&#41;\n&quot;,<br />           &#40;int&#41;&#40;100 * off / tests&#41;&#41;;<br />	&#125;<br />&#125;<br /><br /></code></pre></div>
    <div class="meta">Posted on 2002-03-26 13:24:09 by grv575</div>
   </div>
   <div class="post" id="post-31068">
    <div class="subject"><a href="#post-31068">Random number</a></div>
    <div class="body">I have a few misgivings about the assumption that random should end up as a uniform distribution over a large enough sample.<br /><br />Random is semantic in origin which does not make it a proper mathematical concept so producing uniform distributions over large samples is probably something from a different semantic origin.<br /><br />With seedable random sequence generators, I would be inclined to go after a system that produced different distributions with different seeds.<br /><br />I would be interested to hear if anyone else has chewed over this area.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-03-26 16:57:10 by hutch--</div>
   </div>
   <div class="post" id="post-31070">
    <div class="subject"><a href="#post-31070">Random number</a></div>
    <div class="body">from Main -&gt; Algos &amp; source with all this code floating inside :)</div>
    <div class="meta">Posted on 2002-03-26 17:00:27 by Hiroshimator</div>
   </div>
   <div class="post" id="post-31106">
    <div class="subject"><a href="#post-31106">Random number</a></div>
    <div class="body">In regard to Hutch's comments as to whether random numbers can be well defined in mathematical terms, I'd refer anyone to the work of Charles Pierce concerning logic and induction.  He argued pretty well that any event that appears to have a 50/50 chance of taking place can be safely assumed to be random in as far as no determinate factor can be infered from experience.  In other words, a coin toss is as random as anything can get.<br /><br />I haven't given much thought yet, but I think an interesting approach to a random number generator could make use of that neglected parity flag.</div>
    <div class="meta">Posted on 2002-03-27 01:21:54 by Canite</div>
   </div>
   <div class="post" id="post-31108">
    <div class="subject"><a href="#post-31108">Random number</a></div>
    <div class="body"><div class="quote"><br />I haven't given much thought yet, but I think an interesting approach to a random number generator could make use of that neglected parity flag.</div>Like RDTSC, this seems like a good idea at first, but taking into account that the execution of the code will have patterns the randomness of the number would be based on the execution path and how often the random numbers are needed.  Couple that with the fact that each examination of the parity flag only gives a single bit of data - this hardly seems like a good idea for many random numbers.</div>
    <div class="meta">Posted on 2002-03-27 01:32:03 by bitRAKE</div>
   </div>
   <div class="post" id="post-31137">
    <div class="subject"><a href="#post-31137">Random number</a></div>
    <div class="body">This is the form that I tested Vecna's version with.<br /><pre><code><br />; ##########################<br /><br />random proc range&#58;DWORD<br /><br />    mov eax, rseed<br />    mov ecx, 41c64e6dh<br />    mul ecx<br />    add eax, 3039h<br />    and eax, 7ffffffh<br />    mov rseed, eax<br />    mov ecx, range<br />    sub edx, edx<br />    div ecx<br />    xchg eax, edx<br /><br />    ret<br /><br />random endp<br /><br />; ##########################<br /><br />SetRandomSeed proc seed&#58;DWORD<br /><br />    .data<br />      rseed dd 0<br />    .code<br /><br />    mov eax, seed<br />    mov rseed, eax<br /><br />    ret<br /><br />SetRandomSeed endp<br /><br />; ##########################<br /></code></pre><br /><br />What I am looking for is a simple algorithm that delivers a preset range with selected start and finish range so it can be used for things like 500 to 1000. I need it in standard library form so its clean and easy to use for the MASM32 library.<br /><br />Setting up the range is easy enough, just calculate the specified range, run the algo and add the minimum number in the range to the result.<br /><br />Any other ideas are welcome.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-03-27 06:49:54 by hutch--</div>
   </div>
   <div class="post" id="post-31139">
    <div class="subject"><a href="#post-31139">Random number</a></div>
    <div class="body">Agner Fog has put together a libraty which does just that, its really simple to use.<br /><br /><a target="_blank" href="">http://www.asmcommunity.net/board/index.php?topic=2802</a></div>
    <div class="meta">Posted on 2002-03-27 07:16:45 by Eóin</div>
   </div>
   <div class="post" id="post-31191">
    <div class="subject"><a href="#post-31191">Random number</a></div>
    <div class="body">&lt;quote&gt;Like RDTSC, this seems like a good idea at first, but taking into account that the execution of the code will have patterns the randomness of the number would be based on the execution path and how often the random numbers are needed. Couple that with the fact that each examination of the parity flag only gives a single bit of data - this hardly seems like a good idea for many random numbers.<br /><br />I was considering something that might have a cumulative effect, which would produce an inverse power law distribution similar to the statistics on earth quake magnitudes or stock market bubbles.<br />Like I said, I haven't given a great deal of thought, but I'll work through it tonight and see if I can code something to clearify my point.</div>
    <div class="meta">Posted on 2002-03-27 13:02:36 by Canite</div>
   </div>
   <div class="post" id="post-31252">
    <div class="subject"><a href="#post-31252">Random number</a></div>
    <div class="body">See <a target="_blank" href="http://www.math.keio.ac.jp/~matumoto/emt.html">http://www.math.keio.ac.jp/~matumoto/emt.html</a>)</div>
    <div class="meta">Posted on 2002-03-27 21:27:29 by dig</div>
   </div>
  </div>
 </body>
</html>