<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Custom heap - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=5581" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=5581">Custom heap</a></p>
   <div class="post" id="post-39706">
    <div class="subject"><a href="#post-39706">Custom heap</a></div>
    <div class="body">The program I'm working on heavily uses the heap functions to allocate memory, but as most pieces of memory allocated are quite small I've been thinking about a custom heap on top of the windows heap.<br /><br />FYI, here's the frequency table of the allocated memory size and the weighted average (28.4 bytes).<br /><pre><code><br />size      freq  |   size     freq<br />32          59  |   71          2<br />28          56  |   55          2<br />16          50  |   49          2<br />68          40  |   43          2<br />36          21  |   39          2<br />5           19  |   30          2<br />11          17  |   24          2<br />10          10  |   2           2<br />6           9   |   19          2<br />12          8   |   83          1<br />7           7   |   80          1<br />17          6   |   69          1<br />13          6   |   65          1<br />9           5   |   61          1<br />56          5   |   59          1<br />20          5   |   53          1<br />18          5   |   52          1<br />15          5   |   44          1<br />14          5   |   40          1<br />8           4   |   37          1<br />50          4   |   31          1<br />48          4   |   27          1<br />2           4   |   25          1<br />41          3   |   22          1<br />23          3   |<br /><br />weighted average&#58;<br />~ 28 bytes<br /></code></pre><br /><br />Because of the small sizes, I want to have as little overhead as possibe. I was thinking about allocating a relatively large block (say 4/16/64 KB). Each block gets a small header, telling the size of the block (max, free/used), and some prev &amp; next pointers to the previous and next block. <br />When memory is allocated, the 8 bytes before the actual memory pointer will contain the size of the allocated piece and a pointer to the block header.<br />This is just one idea, I'm still thinking of improvements and other methods and I'd like to hear your suggestions or useful urls as well.<br /><br />Thomas<br /><br /><strong>edit:</strong> Found this url <a target="_blank" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dngenlib/html/heap3.asp,">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dngenlib/html/heap3.asp,</a> haven't fully read it yet but seems useful.</div>
    <div class="meta">Posted on 2002-05-24 11:02:34 by Thomas</div>
   </div>
   <div class="post" id="post-39721">
    <div class="subject"><a href="#post-39721">Custom heap</a></div>
    <div class="body">Ahh, I have been wondering along the same lines about the heap for awile now.  I am working out a program on paper and its requirements look much the same on the memory side of things.  However I have not decided on how to implement yet because of such considerations.<br /><br />Like if I have to constantly reallocate alot of portions to make it bigger or smaller will it eventually fragment the heap?  I dont even know if the heaps fragmentable :tongue:<br />Or if Windows will do garbage and packing sweeps...<br /><br />Hey Thomas, what about two lists?<br />I say two just for speed.  One for used and one for free.  This would also free up some of the space in the individual headers.<br /><br />I dont see a need to go through a whole list looking for free spots just to find out you need a new one hehe.</div>
    <div class="meta">Posted on 2002-05-24 12:21:56 by Graebel</div>
   </div>
   <div class="post" id="post-39729">
    <div class="subject"><a href="#post-39729">Custom heap</a></div>
    <div class="body"><div class="quote"><br />Like if I have to constantly reallocate alot of portions to make it bigger or smaller will it eventually fragment the heap? I dont even know if the heaps fragmentable  <br />Or if Windows will do garbage and packing sweeps... <br /></div><br /><br />Yes you need to consider these things. It all depends on the heap use characteristics of your program. If you've consistantly used a wrapper for all allocations/deallocations (like me) it's easy to create some statistics from them.<br /><br />Btw, windows can't defragment the heap as moving around allocated blocks would invalidate the pointers to them.</div><br /><br /><br /><div class="quote">Hey Thomas, what about two lists? <br />I say two just for speed. One for used and one for free. This would also free up some of the space in the individual headers. <br /><br />I dont see a need to go through a whole list looking for free spots just to find out you need a new one hehe.<br /></div><br /><br />Very good point! Maybe these lists could start at the end of one allocated block and grow down (like the stack)? This way the total size of the lists isn't fixed and thus produces less overhead.<br /><br />Another thing I thought about is how to make them thread-safe. We don't want two threads fiddling around with the lists at the same time. A simple mutex would suffice, I don't think it would influence the speed much either.<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-05-24 12:36:31 by Thomas</div>
   </div>
   <div class="post" id="post-39740">
    <div class="subject"><a href="#post-39740">Custom heap</a></div>
    <div class="body">Here's my proposal:<br /><br /><pre><code>Heap block&#58;<br /><br />&#91;start of heap block here&#93;<br />---------------------<br />HEAP_HEADER header<br />---------------------<br />      <br />HEAP_ITEM heapItems&#91;&#93; &#40;growing upwards&#41;<br /><br /><br />----------------------      &lt;--+<br />HEAP_LIST_ITEM usedMemory&#91;&#93;    | <br />----------------------         | &#40;growing downwards&#41;<br />HEAP_LIST_ITEM freeMemory&#91;&#93;    |<br />----------------------      &lt;--+<br />&#91;end of heap block here&#93;<br /><br />HEAP_HEADER<br />&#123;<br />    - DWORD&#58; pointer to next heap block<br />    - DWORD&#58; pointer to prev heap block<br />    - DWORD&#58; mutex handle for manipulating this heap block's header or lists<br />    - DWORD&#58; number of items in the freeMemory array<br />    - DWORD&#58; number of items in the usedMemory array<br />    - DWORD&#58; total size of memory block &#40;including header &amp; lists&#41;<br />    - DWORD&#58; pointer to the end of the usedMemory array<br />    - DWORD&#58; reserved<br />&#125;<br /><br />HEAP_ITEM<br />&#123;<br />    - DWORD&#58; pointer to HEAP_HEADER of this heap block &#40;=start of block&#41;<br />    - DWORD&#58; size of this heap item, not including the first two DWORDS.<br />             &#40;the actual size a HEAP_ITEM struct takes is aligned to the<br />              next 8 byte boundary, this size is the size of the bytes<br />              that are actually used&#41;<br />    - x bytes&#58; heap item data<br />    - padding to next 8 byte memory boundary<br />&#125;<br /><br />HEAP_LIST_ITEM<br />&#123;<br />    - DWORD&#58; pointer to start of used or free memory piece in this block<br />    - DWORD&#58; size of used or free memory block<br />&#125;<br /><br /><br />The usedMemory array is immediately followed by the freeMemory array. The <br />end of the freeMemory array is always the end of the heap block. When an item<br />to one of the arrays is added, the list grows downwards in memory, no data is<br />written after the end of the memory block. This does require a special way of<br />manipulating the arrays, namely&#58;<br /><br />- to add an item to the usedMemory list&#58;<br />    get the offset of the first item in the usedMemory array. Add the item<br />    *before* this item.<br />- to remove an item from the usedMemory list&#58;<br />    move the first item of the usedMemory list over the item to remove<br />- to add an item to the freeMemory list&#58;<br />    move the last item of the usedMemory array, before the first item in<br />    the usedMemory array, thereby freeing the last item. Into this item,<br />    copy the new item to be added to the freeMemoryList.<br />- to remove an item from the freeMemory list&#58;<br />    move the first item in the freeMemory array over the item to be deleted.<br />    Then move the first item of the usedMemory array over the first item in<br />    the freeMemory array.<br /><br />In all cases, the heap block header has to be updated to reflect the changes.<br /></code></pre><br /><br />There is some global data as well (protected by another mutex) which contains the first block pointer, number of blocks etc.<br /><br />What do you think?<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-05-24 13:17:14 by Thomas</div>
   </div>
   <div class="post" id="post-39747">
    <div class="subject"><a href="#post-39747">Custom heap</a></div>
    <div class="body">Sounds good.  There is not a whole lot of ways you can code something like this.<br /><br /><div class="quote"><br />- to add an item to the usedMemory list:<br />    get the offset of the first item in the usedMemory array. Add the item<br />    *before* this item.<br /></div><br /><br />The point of the free list is to reuse memory when you can right?  I would say it should be:<br /><br />- to add an item to the usedMemory list:<br />Check the freeMemory list for an item of usable length.  If found move this item to the usedMemory list and copy contents, amend freeMemory list.  If not, get the offset of the first item in the usedMemory array. Add the item *before* this item.<br /><br />Or something like that.  Maybe thats what you were thinking and just worded it differently...</div>
    <div class="meta">Posted on 2002-05-24 13:43:49 by Graebel</div>
   </div>
   <div class="post" id="post-39748">
    <div class="subject"><a href="#post-39748">Custom heap</a></div>
    <div class="body"><div class="quote"><br />Check the freeMemory list for an item of usable length. If found move this item to the usedMemory list and copy contents, amend freeMemory list. If not, get the offset of the first item in the usedMemory array. Add the item *before* this item. </div><br /><br />If no entry from the freeMemory list can be used, the wanted memory does not fit in the current block and you'll have to try in the next block. If none of the blocks provide the required memory, a new block has to be allocated.<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-05-24 13:47:32 by Thomas</div>
   </div>
   <div class="post" id="post-39759">
    <div class="subject"><a href="#post-39759">Custom heap</a></div>
    <div class="body">I think we can't use a mutex for each heap block but a global mutex is required. When one thread tries to add a heap block to the linked heap block list, another thread might be walking through list list and miss the new block.<br />Do you think HeapAlloc can be called by two threads at the same time (on the same heap handle), i.e. does one of the calls have to wait for the other to finish?<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-05-24 14:18:44 by Thomas</div>
   </div>
   <div class="post" id="post-39767">
    <div class="subject"><a href="#post-39767">Custom heap</a></div>
    <div class="body">Ahah... found this<br /><br /><div class="quote"><br />HeapWalk can fail in a multithreaded application if the heap is not locked during the heap enumeration. Use the HeapLock<br /> and HeapUnlock functions to control heap locking during heap enumeration.<br /></div><br /><br />While I do not think you need to enumerate the heap, HeapLock and HeapUnlock should help eliminate problems with multiple threads<br /><br />:alright:</div>
    <div class="meta">Posted on 2002-05-24 14:42:40 by Graebel</div>
   </div>
   <div class="post" id="post-39775">
    <div class="subject"><a href="#post-39775">Custom heap</a></div>
    <div class="body">Just quickly overlooking this thread, thought I might put in my two cents. I think the simplest approach to implement would be something like a FAT system:<br /><br />1) Grab 4kb of memory<br />2) break it into 128 blocks 32 bytes a piece<br />3) map these into a 16 byte bit mask<br /><br />Simple functions:<br /><br />1)To allocate a block check you 16 bytes for a free bit. This would be very easy if you compare against -1.<br />2) To free a blcok of memory, just set the bit to zero<br /><br />Should be easy enough to write an allocation function that grabs a couple of consecutive blocks. Also, defragging would be simple (if you need it). Finally, all data would be aligned to 32 bytes.<br />True, it's a bit wasteful, but I think it would be very fast for your purposes<br /><br />--Chorus</div>
    <div class="meta">Posted on 2002-05-24 15:23:20 by chorus</div>
   </div>
   <div class="post" id="post-39778">
    <div class="subject"><a href="#post-39778">Custom heap</a></div>
    <div class="body">chorus: That's a nice suggestion as well, not much overhead...<br /><br />Graebel: the problem is not with the heap functions. It's the heap blocks in my custom heap. These blocks are linked together. However when you are allocating memory these blocks have to be scanned until a block is found that has enough free memory. If not, a new block has to be allocated.<br /><br />Say thread 1 has to allocate a new block. This also means it is changing properties of existing blocks (prev or next pointer). Therefore, thread 2 cannot scan through the existing blocks when thread 1 is modifying them. In general, only one thread may modify block data (i.e. headers, lists, not the actual data of course) at a time. So I think a global mutex is the only solution. <br /><br />I asked about HeapAlloc because I wondered if the windows heap functions have the same limitation.<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-05-24 15:31:32 by Thomas</div>
   </div>
   <div class="post" id="post-39779">
    <div class="subject"><a href="#post-39779">Custom heap</a></div>
    <div class="body">Arrghh the answer was right in front of me :grin: <br />docs on HeapAlloc, second parameter:<br /><br /><div class="quote"><strong>HEAP_NO_SERIALIZE</strong> Specifies that mutual exclusion will not be used while the HeapAlloc function is accessing the heap. <br /><strong>This value should not be specified when accessing the process heap.</strong> The system may create additional threads within the application's process, such as a CTRL+C handler, that simultaneously access the process heap.</div><br /> <br />So the heap functions do have the same limitation :) Well at least for the default process heap.<br /><br />Thomas</div>
    <div class="meta">Posted on 2002-05-24 15:33:22 by Thomas</div>
   </div>
  </div>
 </body>
</html>