<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Sorting Algos, RadixSort - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=24563" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=24563">Sorting Algos, RadixSort</a></p>
   <div class="post" id="post-179356">
    <div class="subject"><a href="#post-179356">Sorting Algos, RadixSort</a></div>
    <div class="body">I&#39;m looking for the fastest unsigned integer array sorter.<br />If anyone has an implementation of QuickSort to test against this RadixSort I&#39;d be very interested in the results.<br /><br />It&#39;s not fully optimized yet, but the implementation is solid and still very fast.<br /><br />For those that don&#39;t know what radix sort is here&#39;s a high level representation of the algorithm. (in Java)<br /><pre><code><br />///////////////////////////////<br />//enhanced radix sort//////////<br />///////////////////////////////<br />&nbsp; &nbsp; private int&#91;] sourceArray;<br />&nbsp; &nbsp; private int&#91;] targetArray;<br />&nbsp; &nbsp; private int&#91;] counts;<br />&nbsp; &nbsp; private int keyLength=4;<br />&nbsp; &nbsp; private int&#91;] radix2LUT = {24,16,8,0};<br />&nbsp; &nbsp; private void radixSort2(int&#91;] arr)<br />&nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; counts = new int[256];<br />&nbsp; &nbsp; &nbsp; &nbsp; sourceArray = arr;<br />&nbsp; &nbsp; &nbsp; &nbsp; targetArray = new int;<br />&nbsp; &nbsp; &nbsp; &nbsp; int soFar,keyByte,to,temp,bitShift;&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; int&#91;] tempA;<br />&nbsp; &nbsp; &nbsp; &nbsp; //outer loop 4 times because 4words in a 32bit int<br />&nbsp; &nbsp; &nbsp; &nbsp; for ( int col=keyLength-1; col&gt;=0; col-- )<br />&nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; soFar = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitShift = radix2LUT;//either 0,8,16 or 24<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //zeroing out the count[0to255]=0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int x = 0; x&lt;256; x=x+8)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {//unrolled for loop speedup<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; counts = counts = counts = counts =<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; counts = counts = counts = counts = 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //counting how many of each key<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //this is what avoids using queues<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for ( int i=0; i&lt;sourceArray.length; i++ )<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; counts[((sourceArray<em> &gt;&gt; bitShift) &amp; 0xFF)]++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //manipulate the count&#39;s into indexes into a shadow array<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for ( int i=0; i&lt;counts.length; i=i+8 )<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {//unrolled for speed<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp = counts<em>;counts<em> = soFar;soFar += temp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp = counts<em>;counts<em> = soFar;soFar += temp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp = counts<em>;counts<em> = soFar;soFar += temp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp = counts<em>;counts<em> = soFar;soFar += temp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp = counts<em>;counts<em> = soFar;soFar += temp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp = counts<em>;counts<em> = soFar;soFar += temp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp = counts<em>;counts<em> = soFar;soFar += temp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp = counts<em>;counts<em> = soFar;soFar += temp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //copy and rearrange the array<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for ( int from=0; from&lt;sourceArray.length; from++ )<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyByte = ((sourceArray &gt;&gt; bitShift) &amp; 0xFF);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to = counts++;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetArray = sourceArray;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //flip the array pointers around<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tempA = sourceArray;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sourceArray = targetArray;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetArray = tempA;<br />&nbsp; &nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; &nbsp; &nbsp; //copy the sorted array into the array passed to the method<br />&nbsp; &nbsp; &nbsp; &nbsp; //System.arraycopy(sourceArray,0, arr,0, sourceArray.length);<br />&nbsp; &nbsp; }<br /></code></pre><br /><br />Here&#39;s the current fasm project I&#39;m using,<br />the DATA section is a little messy but the code is straight forward.<br /><br />I create a 10,000,000 DWORD long array<br />Fill it with Random 32bit integers<br />And have benchmarking loops setup to test the speed of RadixSort vs WHATEVER you guys come up with to help me out.<br /><br />If your going to test your quick sort implementation make sure you call it first in the benchmarking loops (WHY?) because optimized QuickSort algorithms have early stop checks, so if you let the radix sort sort the array first QuickSort will see that it&#39;s sorted already and stop early. Or you could just call the FillArray function before the loop starts for both of them.<br /><br />Without further babbling the code.<br /><pre><code><br />format PE console 4.0<br />entry start<br />include &#39;%fasminc%\win32a.inc&#39;<br /><br />section &#39;.data&#39; data readable writeable<br />result1 db &#39;Result 1: %d:&#39;,0<br />result2 db &#39;Result 2: %d:&#39;,0<br />buffer rb 255<br /><br />align 16<br />RandomSeed dd 1318699, 1015727, 1235239, 412943<br /><br />paramA dd 0<br />paramB dd 0<br />align 8<br />dVal dq 4294967295.0<br /><br />fmtr db &#39;test: %d&#39;,0<br />tmp dq 0<br />align 16<br />fixer dw 0fc01h,0,0,0,0,0,0,0<br /><br />fmtf db &#39;%d . %d&#39;,0<br />dbgt dq 0<br /><br />fmth db &#39;%x %x %x&#39;,0<br />str1 dd 0,0,0,0<br />fhex db &#39;%x&nbsp; &gt; %x&nbsp; &#39;,0<br /><br />ttest db &#39;%x : %x : %x&#39;,10,13,0<br /><br />align 16<br />sseseed dq 1111111111111111h<br />&nbsp; &nbsp; &nbsp; &nbsp; dq 12134567778abbf0h<br />&nbsp; &nbsp; &nbsp; &nbsp; dq 0ababcabababdabah<br />&nbsp; &nbsp; &nbsp; &nbsp; dq 7654321546174353h<br />_fmth db &#39; %X &#39;,0<br /><br />RandomArray dd 0<br />TestArray dd 1000BBBBh, 99AABBCCh, 1000BBB1h, 100h, 250h<br />section &#39;.code&#39; code readable executable<br />start:<br /><br />call MakeSeed<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; 40000000 ;;40million bytes 10million DWORDS<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; MakeArray<br />&nbsp; &nbsp; &nbsp; &nbsp; mov&nbsp; &nbsp;  , eax<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; 10000000 ;;DWORD size<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; eax ;;ARRAY MEM<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; FillArray<br /><br /><br /><br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp;  ;returns -1<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; 100h<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; eax<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; ;;returns -2<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; 15<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; eax<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; <br /><br />&nbsp; &nbsp; push 0<br />&nbsp; &nbsp; push 0<br />&nbsp; &nbsp; push 0<br />&nbsp; &nbsp; push 0<br />&nbsp; &nbsp; call <br />;---------------------------------------<br />&nbsp; &nbsp; mov esi,01h<br />&nbsp; &nbsp; call <br />&nbsp; &nbsp; mov edi,eax<br />&nbsp; &nbsp; jmp tst1<br />align 16<br />tst1:<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; 10000000<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; dword<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; RadixSortUint32<br />&nbsp; &nbsp; dec esi<br />&nbsp; &nbsp; jnz tst1<br />&nbsp; &nbsp; push eax<br />&nbsp; &nbsp; push _fmth<br />&nbsp; &nbsp; call <br />&nbsp; &nbsp; call <br />&nbsp; &nbsp; sub eax,edi<br />&nbsp; &nbsp; push eax<br />&nbsp; &nbsp; push result1<br />&nbsp; &nbsp; call <br /><br />&nbsp; &nbsp; mov esi,01h<br />&nbsp; &nbsp; call <br />&nbsp; &nbsp; mov edi,eax<br />&nbsp; &nbsp; jmp tst2<br />align 16<br />tst2:<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; 10000000<br />&nbsp; &nbsp; &nbsp; &nbsp; push&nbsp; &nbsp; dword<br />&nbsp; &nbsp; &nbsp; &nbsp; call&nbsp; &nbsp; RadixSortUint32<br />&nbsp; &nbsp; dec esi<br />&nbsp; &nbsp; jnz tst2<br />&nbsp; &nbsp; push eax<br />&nbsp; &nbsp; push _fmth<br />&nbsp; &nbsp; call <br />&nbsp; &nbsp; call <br />&nbsp; &nbsp; sub eax,edi<br />&nbsp; &nbsp; push eax<br />&nbsp; &nbsp; push result2<br />&nbsp; &nbsp; call <br />;+++++++++++++++++++++++++++++++++++++++++++++<br />&nbsp; &nbsp;  push 0<br />&nbsp; &nbsp;  push buffer<br />&nbsp; &nbsp;  push buffer<br />&nbsp; &nbsp;  push 0<br />&nbsp; &nbsp;  call <br />&nbsp; &nbsp;  push 0<br />&nbsp; &nbsp;  call <br /><br /><br />;;IN size<br />;;IN array addr<br />RadixSortUint32:<br />&nbsp; &nbsp;  mov ecx,;;size DWORDs<br />&nbsp; &nbsp;  push ebp<br />&nbsp; &nbsp;  push ebx<br />&nbsp; &nbsp;  push esi<br />&nbsp; &nbsp;  push edi<br />&nbsp; &nbsp;  mov esi,;;array<br />&nbsp; &nbsp;  mov ebp,ecx ;;copy sizeDWORDs<br />&nbsp; &nbsp;  shl ecx,2;;*4 sizeBYTEs<br />&nbsp; &nbsp;  push ecx ;;size<br />&nbsp; &nbsp;  call MakeArray<br />&nbsp; &nbsp;  mov edx,ebp ;;copy back dword size<br />&nbsp; &nbsp;  mov edi,eax ;;shadow array<br />&nbsp; &nbsp;  sub esp,256 * 4 ;;count array<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ITERATION 1<br />;;;;;;;;;;;;;;;;;;;;zero count array<br />&nbsp; &nbsp;  xor eax,eax<br />&nbsp; &nbsp;  mov ecx,255<br />&nbsp; .lpc1:<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  sub ecx,5<br />&nbsp; &nbsp;  jnz .lpc1<br />&nbsp; &nbsp;  mov dword,eax<br />;++++++++++++++++++++++++<br />;;;;;;;;;;;;;;;;;;;get counts<br />&nbsp; &nbsp;  mov ecx,edx ;;dword size -1<br />&nbsp; &nbsp;  dec ecx<br />&nbsp; .lpg1:<br />&nbsp; &nbsp;  movzx eax,byte ;;lowest byte first<br />&nbsp; &nbsp;  inc dword<br />&nbsp; &nbsp;  dec ecx<br />&nbsp; &nbsp;  jns .lpg1<br /><br />;++++++++++++++++++++++++++++<br />;;;;;change counts to indexes into shadow array<br />&nbsp; &nbsp;  xor ecx,ecx<br />&nbsp; &nbsp;  xor ebx,ebx<br />&nbsp; .lpm1:<br />&nbsp; &nbsp;  mov eax, dword<br />&nbsp; &nbsp;  mov dword, ebx<br />&nbsp; &nbsp;  add ebx, eax<br />&nbsp; &nbsp;  add ecx,1<br />&nbsp; &nbsp;  cmp ecx,256<br />&nbsp; &nbsp;  jne .lpm1<br />;++++++++++++++++++++++++++++++++++<br />;;;;;;;;;;;;;;;;;;;;;; first copy<br />&nbsp; &nbsp;  xor ecx,ecx<br />&nbsp; .lpr1:<br />&nbsp; &nbsp;  movzx eax, byte ;; first byte<br />&nbsp; &nbsp;  mov ebx, dword<br />&nbsp; &nbsp;  inc dword ;++<br />&nbsp; &nbsp;  mov eax, dword<br />&nbsp; &nbsp;  mov dword, eax<br />&nbsp; &nbsp;  add ecx,1<br />&nbsp; &nbsp;  cmp ecx,edx<br />&nbsp; &nbsp;  jne .lpr1<br />;+++++++++++++++++++++++++++++++++++<br />;;;;;;;;;;;;;;;; flip shadow and array ptrs<br />&nbsp; &nbsp;  push esi<br />&nbsp; &nbsp;  push edi<br />&nbsp; &nbsp;  pop esi<br />&nbsp; &nbsp;  pop edi<br />;++++++++++++++++++++++++++++++++++++<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ITERATION 2<br />;;;;;;;;;;;;;;;;;;;;zero count array<br />&nbsp; &nbsp;  xor eax,eax<br />&nbsp; &nbsp;  mov ecx,255<br />&nbsp; .lpc2:<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  sub ecx,5<br />&nbsp; &nbsp;  jnz .lpc2<br />&nbsp; &nbsp;  mov dword,eax<br />;++++++++++++++++++++++++<br />;;;;;;;;;;;;;;;;;;;get counts<br />&nbsp; &nbsp;  mov ecx,edx ;;dword size -1<br />&nbsp; &nbsp;  dec ecx<br />&nbsp; .lpg2:<br />&nbsp; &nbsp;  movzx eax,byte ;;2nd lowest byte<br />&nbsp; &nbsp;  inc dword<br />&nbsp; &nbsp;  sub ecx,1<br />&nbsp; &nbsp;  jns .lpg2<br />;++++++++++++++++++++++++++++<br />;;;;;change counts to indexes into shadow array<br />&nbsp; &nbsp;  xor ecx,ecx<br />&nbsp; &nbsp;  xor ebx,ebx<br />&nbsp; .lpm2:<br />&nbsp; &nbsp;  mov eax, dword<br />&nbsp; &nbsp;  mov dword, ebx<br />&nbsp; &nbsp;  add ebx, eax<br />&nbsp; &nbsp;  add ecx,1<br />&nbsp; &nbsp;  cmp ecx,256<br />&nbsp; &nbsp;  jne .lpm2<br />;++++++++++++++++++++++++++++++++++<br />;;;;;;;;;;;;;;;;;;;;;; second copy<br />&nbsp; &nbsp;  xor ecx,ecx<br />&nbsp; .lpr2:<br />&nbsp; &nbsp;  movzx eax, byte ;; second byte<br />&nbsp; &nbsp;  mov ebx, dword<br />&nbsp; &nbsp;  inc dword ;++<br />&nbsp; &nbsp;  mov eax, dword<br />&nbsp; &nbsp;  mov dword, eax<br />&nbsp; &nbsp;  add ecx,1<br />&nbsp; &nbsp;  cmp ecx,edx<br />&nbsp; &nbsp;  jne .lpr2<br />;+++++++++++++++++++++++++++++++++++<br />;;;;;;;;;;;;;;;; flip shadow and array ptrs<br />&nbsp; &nbsp;  push esi<br />&nbsp; &nbsp;  push edi<br />&nbsp; &nbsp;  pop esi<br />&nbsp; &nbsp;  pop edi<br />;++++++++++++++++++++++++++++++++++++<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ITERATION 3<br />;;;;;;;;;;;;;;;;;;;;zero count array<br />&nbsp; &nbsp;  xor eax,eax<br />&nbsp; &nbsp;  mov ecx,255<br />&nbsp; .lpc3:<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  sub ecx,5<br />&nbsp; &nbsp;  jnz .lpc3<br />&nbsp; &nbsp;  mov dword,eax<br />;++++++++++++++++++++++++<br />;;;;;;;;;;;;;;;;;;;get counts<br />&nbsp; &nbsp;  mov ecx,edx ;;dword size -1<br />&nbsp; &nbsp;  dec ecx<br />&nbsp; .lpg3:<br />&nbsp; &nbsp;  movzx eax,byte ;;third lowest byte<br />&nbsp; &nbsp;  inc dword<br />&nbsp; &nbsp;  sub ecx,1<br />&nbsp; &nbsp;  jns .lpg3<br />;++++++++++++++++++++++++++++<br />;;;;;change counts to indexes into shadow array<br />&nbsp; &nbsp;  xor ecx,ecx<br />&nbsp; &nbsp;  xor ebx,ebx<br />&nbsp; .lpm3:<br />&nbsp; &nbsp;  mov eax, dword<br />&nbsp; &nbsp;  mov dword, ebx<br />&nbsp; &nbsp;  add ebx, eax<br />&nbsp; &nbsp;  add ecx,1<br />&nbsp; &nbsp;  cmp ecx,256<br />&nbsp; &nbsp;  jne .lpm3<br />;++++++++++++++++++++++++++++++++++<br />;;;;;;;;;;;;;;;;;;;;;; third copy<br />&nbsp; &nbsp;  xor ecx,ecx<br />&nbsp; .lpr3:<br />&nbsp; &nbsp;  movzx eax, byte ;; third byte<br />&nbsp; &nbsp;  mov ebx, dword<br />&nbsp; &nbsp;  inc dword ;++<br />&nbsp; &nbsp;  mov eax, dword<br />&nbsp; &nbsp;  mov dword, eax<br />&nbsp; &nbsp;  add ecx,1<br />&nbsp; &nbsp;  cmp ecx,edx<br />&nbsp; &nbsp;  jne .lpr3<br />;+++++++++++++++++++++++++++++++++++<br />;;;;;;;;;;;;;;;; flip shadow and array ptrs<br />&nbsp; &nbsp;  push esi<br />&nbsp; &nbsp;  push edi<br />&nbsp; &nbsp;  pop esi<br />&nbsp; &nbsp;  pop edi<br />;++++++++++++++++++++++++++++++++++++<br />;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ITERATION 4<br />;;;;;;;;;;;;;;;;;;;;zero count array<br />&nbsp; &nbsp;  xor eax,eax<br />&nbsp; &nbsp;  mov ecx,255<br />&nbsp; .lpc4:<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  sub ecx,5<br />&nbsp; &nbsp;  jnz .lpc4<br />&nbsp; &nbsp;  mov dword,eax<br />;++++++++++++++++++++++++<br />;;;;;;;;;;;;;;;;;;;get counts<br />&nbsp; &nbsp;  mov ecx,edx ;;dword size -1<br />&nbsp; &nbsp;  dec ecx<br />&nbsp; .lpg4:<br />&nbsp; &nbsp;  movzx eax,byte ;;last byte<br />&nbsp; &nbsp;  inc dword<br />&nbsp; &nbsp;  sub ecx,1<br />&nbsp; &nbsp;  jns .lpg4<br />;++++++++++++++++++++++++++++<br />;;;;;change counts to indexes into shadow array<br />&nbsp; &nbsp;  xor ecx,ecx<br />&nbsp; &nbsp;  xor ebx,ebx<br />&nbsp; .lpm4:<br />&nbsp; &nbsp;  mov eax, dword<br />&nbsp; &nbsp;  mov dword, ebx<br />&nbsp; &nbsp;  add ebx, eax<br />&nbsp; &nbsp;  add ecx,1<br />&nbsp; &nbsp;  cmp ecx,256<br />&nbsp; &nbsp;  jne .lpm4<br />;++++++++++++++++++++++++++++++++++<br />;;;;;;;;;;;;;;;;;;;;;; fourth copy<br />&nbsp; &nbsp;  xor ecx,ecx<br />&nbsp; .lpr4:<br />&nbsp; &nbsp;  movzx eax, byte ;; fourth byte<br />&nbsp; &nbsp;  mov ebx, dword<br />&nbsp; &nbsp;  inc dword ;++<br />&nbsp; &nbsp;  mov eax, dword<br />&nbsp; &nbsp;  mov dword, eax<br />&nbsp; &nbsp;  add ecx,1<br />&nbsp; &nbsp;  cmp ecx,edx<br />&nbsp; &nbsp;  jne .lpr4<br />;+++++++++++++++++++++++++++++++++++<br />;;;;;;;;;;;;;;;; flip shadow and array ptrs<br />&nbsp; &nbsp;  push esi<br />&nbsp; &nbsp;  push edi<br />&nbsp; &nbsp;  pop esi<br />&nbsp; &nbsp;  pop edi<br />;++++++++++++++++++++++++++++++++++++<br />&nbsp; &nbsp;  push edi<br />&nbsp; &nbsp;  call DeleteArray<br />&nbsp; &nbsp;  add esp,256*4<br />&nbsp; &nbsp;  pop edi<br />&nbsp; &nbsp;  pop esi<br />&nbsp; &nbsp;  pop ebx<br />&nbsp; &nbsp;  pop ebp<br />&nbsp; &nbsp;  ret 8<br /><br /><br />FillArray:<br />&nbsp; &nbsp;  push ebx<br />&nbsp; &nbsp;  push esi<br />&nbsp; &nbsp;  mov ebx,dword ;; count<br />&nbsp; &nbsp;  mov esi,dword ;; addr<br />&nbsp; .lp:<br />&nbsp; &nbsp;  dec ebx<br />&nbsp; &nbsp;  js .end<br />&nbsp; &nbsp;  call Random32<br />&nbsp; &nbsp;  mov dword,eax<br />&nbsp; &nbsp;  jmp .lp<br /> .end:<br />&nbsp; &nbsp;  pop esi<br />&nbsp; &nbsp;  pop ebx<br />&nbsp; &nbsp;  ret 8<br /><br />MakeArray:<br />&nbsp; &nbsp;  mov eax,<br />&nbsp; &nbsp;  push 4 ;read/write<br />&nbsp; &nbsp;  push 1000h Or 2000h ;;commit | reserve<br />&nbsp; &nbsp;  push eax ;;size<br />&nbsp; &nbsp;  push 0&nbsp; ;;addr<br />&nbsp; &nbsp;  push -1 ;;current process<br />&nbsp; &nbsp;  call <br />&nbsp; &nbsp;  test eax,eax<br />&nbsp; &nbsp;  jnz .good<br />&nbsp; &nbsp;  push 0<br />&nbsp; &nbsp;  call <br /> .good:<br />&nbsp; &nbsp;  ret 4<br /><br />DeleteArray:<br />&nbsp; &nbsp;  mov eax, ;;array addr<br />&nbsp; &nbsp;  push 8000h ;;release<br />&nbsp; &nbsp;  push 0 ;;size<br />&nbsp; &nbsp;  push eax ;;addr<br />&nbsp; &nbsp;  push -1 ;;this process<br />&nbsp; &nbsp;  call <br />&nbsp; &nbsp;  ret 4<br /><br />Random32:<br />&nbsp; &nbsp;  push ebx<br />&nbsp; &nbsp;  mov eax,<br />&nbsp; &nbsp;  mov ebx,<br />&nbsp; &nbsp;  mov ecx,<br />&nbsp; &nbsp;  mov edx,<br />&nbsp; &nbsp;  shld ebx,eax,1<br />&nbsp; &nbsp;  adc eax,0<br />&nbsp; &nbsp;  ror eax,3<br />&nbsp; &nbsp;  bswap eax<br />&nbsp; &nbsp;  shld edx,ecx,1<br />&nbsp; &nbsp;  adc ecx,0<br />&nbsp; &nbsp;  bswap ecx<br />&nbsp; &nbsp;  ror ecx,7<br />&nbsp; &nbsp;  mov ,eax<br />&nbsp; &nbsp;  mov ,ebx<br />&nbsp; &nbsp;  mov ,ecx<br />&nbsp; &nbsp;  mov ,edx<br />&nbsp;  xor eax,ecx<br />&nbsp; &nbsp;  pop ebx<br />&nbsp; &nbsp;  ret 0<br /><br />SetSeed:<br />.seed equ esp+4 ;,+8,+12,+16<br />&nbsp; &nbsp;  movdqu xmm0,[.seed]<br />&nbsp; &nbsp;  movntdq dqword,xmm0<br />&nbsp; &nbsp;  ret 16<br /><br />MakeSeed:<br />&nbsp; &nbsp;  rdtsc<br />&nbsp; &nbsp;  mov edx,eax<br />&nbsp; &nbsp;  call <br />&nbsp; &nbsp;  mov ecx,eax<br />&nbsp; &nbsp;  mul edx<br />&nbsp; &nbsp;  mov ,eax<br />&nbsp; &nbsp;  xor edx,ecx<br />&nbsp; &nbsp;  mov ,edx<br />&nbsp; &nbsp;  bswap ecx<br />&nbsp; &nbsp;  xor eax,ecx<br />&nbsp; &nbsp;  mov ,eax<br />&nbsp; &nbsp;  not edx<br />&nbsp; &nbsp;  bswap edx<br />&nbsp; &nbsp;  mul edx<br />&nbsp; &nbsp;  mov ,eax<br />&nbsp; &nbsp;  ret 0<br /><br /><br /><br />section &#39;.idata&#39; import data readable writeable<br /><br />&nbsp; library kernel32,&#39;KERNEL32.DLL&#39;,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; user32,&#39;USER32.DLL&#39;,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wsock32,&#39;WS2_32.DLL&#39;,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntdll,&#39;NTDLL.DLL&#39;,\<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msvcrt,&#39;msvcrt.dll&#39;<br />&nbsp; &nbsp; &nbsp; include&nbsp; &quot;%fasminc%\apia\kernel32.inc&quot;<br />&nbsp; &nbsp; &nbsp; include&nbsp; &quot;%fasminc%\apia\user32.inc&quot;<br />&nbsp; &nbsp; &nbsp; include&nbsp; &quot;%fasminc%\apia\wsock32.inc&quot;<br />&nbsp; &nbsp; &nbsp; import ntdll,\<br />&nbsp; &nbsp; &nbsp; &nbsp; NtAllocateVirtualMemory,&#39;NtAllocateVirtualMemory&#39;,\<br />&nbsp; &nbsp; &nbsp; &nbsp; NtFreeVirtualMemory,&#39;NtFreeVirtualMemory&#39;,\<br />&nbsp; &nbsp; &nbsp; &nbsp; NtWriteVirtualMemory,&#39;NtWriteVirtualMemory&#39;,\<br />&nbsp; &nbsp; &nbsp; &nbsp; NtProtectVirtualMemory,&#39;NtProtectVirtualMemory&#39;,\<br />&nbsp; &nbsp; &nbsp; &nbsp; NtCreateThread,&#39;NtCreateThread&#39;,\<br />&nbsp; &nbsp; &nbsp; &nbsp; NtClose,&#39;NtClose&#39;,\<br />&nbsp; &nbsp; &nbsp; &nbsp; InitializeCS,&#39;RtlInitializeCriticalSection&#39;,\<br />&nbsp; &nbsp; &nbsp; &nbsp; EnterCS,&#39;RtlEnterCriticalSection&#39;,\<br />&nbsp; &nbsp; &nbsp; &nbsp; LeaveCS,&#39;RtlLeaveCriticalSection&#39;,\<br />&nbsp; &nbsp; &nbsp; &nbsp; DeleteCS,&#39;RtlDeleteCriticalSection&#39;<br />&nbsp; import msvcrt,\<br />&nbsp; &nbsp; &nbsp; &nbsp;  printf,&#39;printf&#39;<br /><br />section &#39;.reloc&#39; fixups data discardable<br /></code></pre></div>
    <div class="meta">Posted on 2006-04-09 19:03:15 by r22</div>
   </div>
   <div class="post" id="post-179372">
    <div class="subject"><a href="#post-179372">Re: Sorting Algos, RadixSort</a></div>
    <div class="body">r22, to make the test fair, you should refill the array between sorts - and make sure the same random sequence is used. Also, correctness testing is nice to have. I&#39;ve attached a little test framework I did a while ago, and added your RADIX as well as a vanilla C++ one.<br /><br />Here&#39;s the test results from my AMD64x2 4400+:<br /><br /><pre><code><br />D:\src\test\sort&gt;driver<br />sorting test - sorting 10485760 signed numbers, using seed 0xBEEFF00D<br /><br />*** testing for correctness<br />testing routine libc qsort()<br />testing routine hutch asm qsort()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  failed at index 7 (953 &gt; 479)<br />testing routine C trimedian qsort()<br />testing routine STL std::sort()<br />testing routine r22 FASM RADIX sort()<br />testing routine David Garcia C++ radix()<br /><br />*** testing for SPEED<br />libc qsort() took 1828 ticks<br />hutch asm qsort() took 1047 ticks<br />C trimedian qsort() took 875 ticks<br />STL std::sort() took 1032 ticks<br />r22 FASM RADIX sort() took 406 ticks<br />David Garcia C++ radix() took 656 ticks<br /></code></pre><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1546" target="_blank">sort_test_r22.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-04-10 04:39:20 by f0dder</div>
   </div>
   <div class="post" id="post-179636">
    <div class="subject"><a href="#post-179636">Re: Sorting Algos, RadixSort</a></div>
    <div class="body">If I used words instead of bytes it could probably be ~40% faster. Although the memory requirement would be a little on the high side.<br /><br />65535*4 + 4 * n bytes<br /><br />Any suggestions on the most efficient way to make a SIGNED dword version. I haven&#39;t really though about it but I guess subtracting 255 from the most significant byte (while sorting) would do it.</div>
    <div class="meta">Posted on 2006-04-15 21:14:08 by r22</div>
   </div>
   <div class="post" id="post-180669">
    <div class="subject"><a href="#post-180669">Re: Sorting Algos, RadixSort</a></div>
    <div class="body">Tested against my modified nrQsortA (original found in masm32), ....<br /><pre><code><br />libc qsort() took 10886 ticks<br />hutch asm qsort() took 2123 ticks<br />C trimedian qsort() took 2173 ticks<br />STL std::sort() took 1943 ticks<br />David Garcia C++ radix() took 1662 ticks<br />r22 FASM RADIX sort() took 1443 ticks<br />Ultrano nrQsortA() took 2253 ticks<br /></code></pre><br />AthlonXP 2000+, DDR400</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1623" target="_blank">asm_unrqsort.asm</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-05-15 05:19:09 by Ultrano</div>
   </div>
   <div class="post" id="post-180670">
    <div class="subject"><a href="#post-180670">Re: Sorting Algos, RadixSort</a></div>
    <div class="body">Ultrano, does the AthlonXP support ram running at DDR400, or are you using DDR400 at some lower rate?</div>
    <div class="meta">Posted on 2006-05-15 05:37:09 by f0dder</div>
   </div>
   <div class="post" id="post-180675">
    <div class="subject"><a href="#post-180675">Re: Sorting Algos, RadixSort</a></div>
    <div class="body">During my previous test, the memory was at 200MHz, &quot;normal&quot; timing, but FSB133<br /><br /><br />Now, tested with 200MHz, &quot;ultra&quot; timing, FSB200:<br /><br />driver.exe, your build (with vct2k3?)<br /><pre><code><br />libc qsort() took 3195 ticks<br />hutch asm qsort() took 2123 ticks<br />C trimedian qsort() took 1763 ticks<br />STL std::sort() took 1993 ticks<br />r22 FASM RADIX sort() took 1392 ticks<br />David Garcia C++ radix() took 1792 ticks<br /></code></pre><br /><br />udriver.exe, my build (vc6)<br /><pre><code><br />testing routine David Garcia C++ radix()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; failed at index 1 (20289<br /> &gt; 12264)<br />testing routine Ultrano unrQsortA()<br /><br />*** testing for SPEED<br />libc qsort() took 10906 ticks ; while in your build runs for 3195ms<br />hutch asm qsort() took 2093 ticks<br />C trimedian qsort() took 2153 ticks ;while in your build runs for 1763ms<br />STL std::sort() took 1943 ticks<br />r22 FASM RADIX sort() took 1412 ticks<br />David Garcia C++ radix() took 1642 ticks<br />Ultrano unrQsortA() took 2223 ticks<br /></code></pre><br /></div>
    <div class="meta">Posted on 2006-05-15 06:06:52 by Ultrano</div>
   </div>
   <div class="post" id="post-180676">
    <div class="subject"><a href="#post-180676">Re: Sorting Algos, RadixSort</a></div>
    <div class="body">Yep, my build is VC2003.<br /><br />Seems like (hardly surprising) VC2003 has better stdlib and better code generation - the few routines that are faster in VC6 can probably be attributed to multitasking fluctuations? (although driver.exe *does* boost priority, hmm).<br /><br />It&#39;s pretty weirdthat David Garcia&#39;s routine fails - I wonder if it&#39;s because of a code generation bug in VC6, or perhaps because your system isn&#39;t entirely stable at ultra timings?<br /></div>
    <div class="meta">Posted on 2006-05-15 06:14:24 by f0dder</div>
   </div>
   <div class="post" id="post-180697">
    <div class="subject"><a href="#post-180697">Re: Sorting Algos, RadixSort</a></div>
    <div class="body">Garcia&#39;s route fails because of VC6 code generation.<br />After my last post, I changed my system to a Sempron 2200+, labelled as FSB333 in my bill from a year or two (but actually works at 2x200MHz FSB)<br />My AthlonXP turned out to support only FSB133, any higher value and my PC wouldn&#39;t boot at all (had to take the mobo batteries out). <br /><br />Here&#39;re FSB values for some x86 amd cpus:<br />(K7) Duron - all : 64kB L2, 100MHz<br /><br />(K7/Thunderbird) Athlon: 256kB L2<br />700-1400: 100MHz FSB<br />1000-1400: 133MHz<br /><br />(Palomino/Thoroughbred) AthlonXP: 256kB L2<br />1500+ up to 2600+ :133MHz<br />2600+ and 2700+ : 166MHz FSB<br /><br />(Barton) AthlonXP: 512kB L2<br />2500+ up to 3000+ : 166MHz FSB<br /><br /><br />I&#39;ve been living in an ancient world XD<br />Your dualcore x64 must feel nice :D<br /><br /><strong>r22,</strong> instead of subtracting 255, I&#39;d add 128. </div>
    <div class="meta">Posted on 2006-05-15 19:39:29 by Ultrano</div>
   </div>
   <div class="post" id="post-180705">
    <div class="subject"><a href="#post-180705">Re: Sorting Algos, RadixSort</a></div>
    <div class="body"><div class="quote"><br />Your dualcore x64 must feel nice :D<br /></div><br />Indeed it does, took me a lot of hard work (which almost cost me a relationship) to purchase it, but in the end it&#39;s been worth it. I&#39;m a bit annoyed at AMD&#39;s decision to integrate the memory controller on the CPU, though - it doesn&#39;t buy them a lot, and many AMD64&#39;s have a bugged controller that will run unstable at DDR400 if you have all four memory slots loaded - mine does seem stable, though. But I can&#39;t run my ram at CAS2, have to run it CAS3.<br /></div>
    <div class="meta">Posted on 2006-05-16 04:33:44 by f0dder</div>
   </div>
  </div>
 </body>
</html>