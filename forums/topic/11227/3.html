<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Why ASM? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=11227" />
  <link rel="prev" href="../?id=11227&amp;page=2" />  <link rel="next" href="../?id=11227&amp;page=4" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=11227">Why ASM?</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=11227&amp;page=1" style="">&laquo;</a><a href="../?id=11227&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="11227" /><input type="number" name="page" min="1" max="6" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=11227&amp;page=4">&gt;</a><a href="../?id=11227&amp;page=6">&raquo;</a></form>   <div class="post" id="post-86977">
    <div class="subject"><a href="#post-86977">Why ASM?</a></div>
    <div class="body">I've gone back and forth on the ASM issue myself several times over the years.<br /><br />I've programmed in (and enjoyed) C, C++, Pascal, Prolog, LISP, Visual Basic, Forth, and several ASMs. Many people will say that the sensible thing to do is to stick with C or maybe C++, code mostly in that, and leave ASM for the little speed-ups you need here and there. Yet there's something about ASM that keeps drawing me in!<br /><br />I remember reading an article back around 1990 about assembly, and it mentioned a DOS program (maybe it was a linker) that was written in 100% assembly. It consistently beat the pants off of all its competitors, not because of any specific tweaks, but because the whole thing was written in ASM. The point the article made (and I've seen it reiterated a few times in other articles) was that using assembly to tweak the 2% of the slowest C code is all fine and well, but the <em>real</em> advantage of ASM programming comes in using it to write <strong>the whole thing</strong>. <em>Thinking</em> in assembler!<br /><br />I'm not sure how much that applies today because compilers are truly pretty decent on the whole. Still, it reminds me of owning and riding a motorcycle. It's more dangerous than a car, and it's not as practical as a car... if it's raining, you'll get wet... if it's hot, you'll be hot... if it's cold, you'll be freezing... BUT! -- it's a hundred times more fun!!!!!<br /><br />As I get older, the things I enjoy doing mean more to me than things I get done. I don't know if that makes much sense, but another way of putting it is: life's a journey, not a destination... enjoy the journey. Program in ASM and be proud! :alright:</div>
    <div class="meta">Posted on 2003-03-13 17:55:32 by MANT</div>
   </div>
   <div class="post" id="post-91004">
    <div class="subject"><a href="#post-91004">Why ASM?</a></div>
    <div class="body">Alrighty then, time to debunk a few myths:<br /><br />1. Java is slow.<br /><br />Once upon a time, that was true.  Sun's original Java environment was purely interpreted and had an inefficient garbage collector (memory manager).  However, I recently wrote a computational program in both C and Java 1.4.  The Java program was only 5% slower, and was much simpler to customize and expand.  Current Java implementations are on-demand compiled instead of interpreted (called Just-In-Time compiling usually) and have very efficient memory managers.<br /><br />When you see a slow Java program, usually what is dragging it down is the graphical user interface (AWT and Swing) which, as even the most fanatical Java zealot will tell you, sux rox.  But command-line and server-style (client is elsewhere) Java programs perform very well.<br /><br />2. Servers are all about performance.<br /><br />Wrong.<br /><br />The main two requirements of servers are stability and correctness.  I can build a home PC that will knock your socks off, but I would never use that PC in a production environment because it would not be stable enough.  For a server, I want error-correcting memory, redundant hard drives, processors that have had all of their &quot;errata&quot; fixed...  This extends to software.  It is far easier to prove that a program written in a high-level language is correct than it is to prove that the same program written in assembly language is correct.  Even if I could take the assembly route for a mission-critical business application, I wouldn't because it would be far too expensive (time-wise) to write it, test it, and maintain it.<br /><br />3. HLL's are hard.<br /><br />That would sort of defeat their purpose.  Donkey, forget about those wonderful languages you looked at.  Try Pascal.  It's simple and readable.  In fact, it was designed as a way to learn programming languages.  Once you wrap your head around Pascal, other languages become a whole lot easier.  Plus, most tutorials suck.<br /><br />4. MS Office XP is such a sluggish bunch of pig programs.<br /><br />Actually, that's true.<br /><br />5. I don't like ASM.<br /><br />Which you might think after I just finished championing high-level languages.  Quite the opposite.  I truly love assembler.  This is as close to the metal as you can get without taking off your pants and sitting on the motherboard.  It is a true pleasure to craft a program from scratch, like making a model railroad from individual rails and ties (and itty bitty spikes) rather than from preformed sections of track.  And there is nothing so fun as tripling or quadrupling the performance of an algorithm by translating it from a high-level language to optimized, clock-counted, parallelized, lovingly hand-crafted assembler.<br /><br />-- Craig Putnam</div>
    <div class="meta">Posted on 2003-03-27 19:48:23 by PopeInnocent</div>
   </div>
   <div class="post" id="post-91067">
    <div class="subject"><a href="#post-91067">Why ASM?</a></div>
    <div class="body"><div class="quote"><br />5. I don't like ASM.<br /><br />Which you might think after I just finished championing high-level languages.  Quite the opposite.  I truly love assembler.  This is as close to the metal as you can get without taking off your pants and sitting on the motherboard.  It is a true pleasure to craft a program from scratch, like making a model railroad from individual rails and ties (and itty bitty spikes) rather than from preformed sections of track.  And there is nothing so fun as tripling or quadrupling the performance of an algorithm by translating it from a high-level language to optimized, clock-counted, parallelized, lovingly hand-crafted assembler.</div><br /><br />2nd me on that!<br />btw, one just gotta ove the phrase &quot;This is as close to the metal as you can get without taking off your pants and sitting on the motherboard.&quot;</div>
    <div class="meta">Posted on 2003-03-27 23:38:07 by scientica</div>
   </div>
   <div class="post" id="post-91082">
    <div class="subject"><a href="#post-91082">Why ASM?</a></div>
    <div class="body"><div class="quote"><br />4. MS Office XP is such a sluggish bunch of pig programs.<br /><br />Actually, that's true.<br /></div><br /><br />The worse one is still Office 2000. ;-)<br />97 was a nice compromise : ~10 MB for Excel... more than 100 for 2000 and much slower. :(<br /><br />But I'm going off-topic...</div>
    <div class="meta">Posted on 2003-03-28 01:04:09 by JCP</div>
   </div>
   <div class="post" id="post-91111">
    <div class="subject"><a href="#post-91111">Why ASM?</a></div>
    <div class="body"><div class="quote">I recently wrote a computational program in both C and Java 1.4. The Java program was only 5% slower</div>Man, there must be something very wrong in your C code or compiler then!</div>
    <div class="meta">Posted on 2003-03-28 03:16:46 by Maverick</div>
   </div>
   <div class="post" id="post-91156">
    <div class="subject"><a href="#post-91156">Why ASM?</a></div>
    <div class="body"><div class="quote"><br />Man, there must be something very wrong in your C code or compiler then! </div><br />Nah, somebody just misstake the optimization switch for the extra-over-bloat switch. :) (&lt;-- where did that smiley come from?)</div>
    <div class="meta">Posted on 2003-03-28 08:15:04 by scientica</div>
   </div>
   <div class="post" id="post-91317">
    <div class="subject"><a href="#post-91317">Why ASM?</a></div>
    <div class="body"><div class="quote"><br /><em>Originally posted by PopeInnocent </em><br /><strong>Alrighty then, time to debunk a few myths:<br /><br />1. Java is slow.<br /><br />Once upon a time, that was true<br /></strong><br /></div><br />Its still true :grin:  You can strap a jet engine to a Volkswagen, but no matter how fast it goes, its still not a sports car...<br /><div class="quote"><br /><strong><br />2. Servers are all about performance.<br /><br />Wrong.<br /><br />The main two requirements of servers are stability and correctness.<br /></strong><br /></div><br />Yes... this is good...<br /><br /><div class="quote"><br /><strong><br />It is far easier to prove that a program written in a high-level language is correct than it is to prove that the same program written in assembly language is correct.<br /></strong><br /></div><br />No... this is bad (have you been reading &quot;Security Focus&quot; :tongue: ???).  Lately i've seen even the simplest problems turned into the most convoluted nightmares by these &quot;proveable&quot; HLLS.  It's in who wrote the code/who is looking at the code... that is all.<br /><br />-----<br />Domain</div>
    <div class="meta">Posted on 2003-03-28 19:45:48 by Domain</div>
   </div>
   <div class="post" id="post-91744">
    <div class="subject"><a href="#post-91744">Why ASM?</a></div>
    <div class="body">I guess it has some to do with the task at hand but it will also have a lot to do with how familiar you are with the language. If you have some crappy thing to throw together to just get the job done, its hard to justify doing it all the hard way when you can spit it together in an easy HLL in minutes.<br /><br />Its when you start doing more complex things or time critical things that you start looking hard at how to make it work better and its here where you have the wider range of options in assembler.<br />I routinely write using a PowerBASIC compiler as I actually enjoy bashing code together fast and tradditional basic has a nice feel about it if you have used it for a long time but when I need to do something that is outside the range of the basic language, it ends up being done in assembler as I think in it reasonably well.<br /><br />PowerBASIC is a nice toy for this cross language programming but when I need to do stuff that is specific to an assembler, MASM is the right tool as an assembler can routinely do things that are outside the design range of most compilers.<br /><br />It really has to do with how much code you already have written, if you have been at it for years, you usually have a mountain of code to play with that has been bashed to death many times and is very reliable. In this situation, you can construct a program in far less time than doing it cold turkey without the background to do it in the first palce.<br /><br />A lot or programming today uses the idea of &quot;engines&quot; to do the grunt work, databases, image work, VB style runtime DLLs etc .... so this area is not very fruitful in terms of coding originality but then, you would not waste you time here as there is nothing to gain.<br /><br />One of the comments in the thead interests me in that the idea of provable code and reliability in terms of server applications. This is one that does not immediately make sense to me why a HLL should be any better than an assembler if the code is written properly.<br /><br />I well understand that assembler is usually seen as harder to write for people who don't have a background there but that could be said about normal C as well so I don't get the grasp of that one. The shift here is that compiler design is more reliable than hand written code which I doubt is true.<br /><br />Certainly compiler code is easier and often faster to write but it does not have the flexibility or maintainance caacity that assembler code has. It is common to find you don't have the right tool to do the job in a HLL where in an assembler, you just write it if you need to, the difference is that you can in assembler where often a compiler gives you a finite capacity and no room to do something different.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2003-03-30 07:46:30 by hutch--</div>
   </div>
   <div class="post" id="post-91751">
    <div class="subject"><a href="#post-91751">Why ASM?</a></div>
    <div class="body">Another couple of things strike me as to why I like assembler programming. In many cases, it's cleaner. In C and C++ you can get into a lot of type casting, bending this way and that to make things fit. In assembler the code is often much easier. For instance, a simple example of setting the icon for a window. In C:<br /><br /><pre><code><br />mb.lpszIcon = MAKEINTRESOURCE&#40;1007&#41;;<br /></code></pre><br /><br />In MASM:<br /><br /><pre><code><br />mov mb.lpszIcon, 1007<br /></code></pre><br /><br />Okay, that was simple. But C/C++ is full of this kind of stuff. Of course, a C/C++ person would say that assembler is full of noise like having to move something to EAX before using it, or using a M2M macro to move memory to memory.<br /><br />Here's another one. I wanted to set the GWL_USERDATA dword in a window as soon as it's created, which requires trapping the WM_NCCREATE message. Here's the C++ code:<br /><br /><pre><code><br />if&#40;message == WM_NCCREATE&#41;<br />&#123;<br />    wnd = reinterpret_cast&lt;Window *&gt;&#40;&#40;LPCREATESTRUCT&#41;lparam&#41;-&gt;lpCreateParams;<br />    &#58;&#58;SetWindowLong&#40;hwnd, GWL_USERDATA, reinterpret_cast&lt;long&gt;&#40;wnd&#41;&#41;;<br />&#125;<br /></code></pre><br /><br />And here's the MASM code:<br /><br /><pre><code><br />.if msg == WM_NCCREATE<br />    mov eax, lParam<br />    mov eax, &#40;CREATESTRUCT PTR &#91;eax&#93;&#41;.lpCreateParams<br />    invoke SetWindowLong, hWnd, GWL_USERDATA, eax<br />.endif<br /></code></pre><br /><br />Maybe it's just me, but I can understand what the MASM code is doing right away. The C++ syntax seems terribly overburdened. I've found that the more I use assembler, the less daunting the Win32 API (or any API for that matter) becomes, because I can reduce the complexities to loading a register, then manipulating that somehow. When you break things down like that (which assembler forces you to do), they can suddenly become crystal clear.<br /><br />And I agree with Hutch completely about having a library of code already written. It makes writing new programs much easier. I have enough assembly code now, and a good enough core library, that a few weeks ago I was able to whip up a fully-functional dialog-based Windows app in MASM in under an hour. Not just a &quot;hello world&quot;, but something that takes four input fields, and then generates an HTML file from it, and calls up the default web browser to view the HTML file. I've done programs like that in the same amount of time in VB and C. Once you get to a certain point in experience in assembler, you can program in it just about as fast as in most HLLs. Plus, IMHO, it's more fun, and you get a deeper understanding of what's going on in general.<br /><br />On another topic, the issue of provability is a tough one, no matter what the language. I would say though that unless you're using a compiler like Ada, which is certified through a rigorous process, provability is probably easier with assembler, since the hardware instructions are well known and well documented. With a language like C, C++, C#, Pascal, VB, Java, etc., you may have bugs in the compiler/interpreter itself. Plus, we come back to the idea of basic operations in assembler. There are only so many. With a compiler, you can generate all sorts of convoluted expressions, which are often difficult to prove correct. Assembler forces you to break them down into simpler components.<br /><br />The best way to certify a program module is probably to step through it using a debugger like OllyDbg or SoftICE. Programming in assembler, your code is already very close to what you'll see in the disassembly, and therefore will be (a) easier to understand and step through, (b) easier to fix, and (c) easier to certify, especially since you're more likely to have kept your modules fairly small.</div>
    <div class="meta">Posted on 2003-03-30 08:59:18 by MANT</div>
   </div>
   <div class="post" id="post-91755">
    <div class="subject"><a href="#post-91755">Why ASM?</a></div>
    <div class="body"><div class="quote"><br />Once you get to a certain point in experience in assembler, you can program in it just about as fast as in most HLLs. Plus, IMHO, it's more fun, and you get a deeper understanding of what's going on in general.<br /></div><br /><br />I totally agree with that :)</div>
    <div class="meta">Posted on 2003-03-30 09:17:47 by bazik</div>
   </div>
   <div class="post" id="post-91756">
    <div class="subject"><a href="#post-91756">Why ASM?</a></div>
    <div class="body"><div class="quote"><br />Another couple of things strike me as to why I like assembler programming. In many cases, it's cleaner. In C and C++ you can get into a lot of type casting, bending this way and that to make things fit.</div><br />True, assembler is simple because its instructions are simple. But I'm sure I can read a binary tree search or quicksort implementation easier in C++ than in asm, especially when the asm is optimized (it should :)). <br /><br />C++ is strongly typed, which is good IMHO. In asm, if you accidentaly reverse two totally different typed parameters when calling a function you won't notice it until it executes and probably crashes, because all parameters are just dwords. C++ will tell you at compile time.<br />It's even worse if your program contains such a bug but it doesn't crash, you'll probably have a hard time finding it.<br /><br /><div class="quote"><br />In assembler the code is often much easier. For instance, a simple example of setting the icon for a window. In C:<br /><br /><pre><code><br />mb.lpszIcon = MAKEINTRESOURCE&#40;1007&#41;;<br /></code></pre><br /><br />In MASM:<br /><br /><pre><code><br />mov mb.lpszIcon, 1007<br /></code></pre><br /></div><br />That's because the windows API is dirty :). Using a char pointer as an integer *is* dirty. Probably not in the eyes of assembly programmers but an integer and a char* are totally different things. A cleaner method would be providing two members, or an union, and a flag which tells what to use, although that would take more space and code..<br /><br /><div class="quote"><br />Okay, that was simple. But C/C++ is full of this kind of stuff. Of course, a C/C++ person would say that assembler is full of noise like having to move something to EAX before using it, or using a M2M macro to move memory to memory.<br /><br />Here's another one. I wanted to set the GWL_USERDATA dword in a window as soon as it's created, which requires trapping the WM_NCCREATE message. Here's the C++ code:<br /><br /><pre><code><br />if&#40;message == WM_NCCREATE&#41;<br />&#123;<br />    wnd = reinterpret_cast&lt;Window *&gt;&#40;&#40;LPCREATESTRUCT&#41;lparam&#41;-&gt;lpCreateParams;<br />    &#58;&#58;SetWindowLong&#40;hwnd, GWL_USERDATA, reinterpret_cast&lt;long&gt;&#40;wnd&#41;&#41;;<br />&#125;<br /></code></pre><br /><br />And here's the MASM code:<br /><br /><pre><code><br />.if msg == WM_NCCREATE<br />    mov eax, lParam<br />    mov eax, &#40;CREATESTRUCT PTR &#91;eax&#93;&#41;.lpCreateParams<br />    invoke SetWindowLong, hWnd, GWL_USERDATA, eax<br />.endif<br /></code></pre><br /><br />Maybe it's just me, but I can understand what the MASM code is doing right away. The C++ syntax seems terribly overburdened. I've found that the more I use assembler, the less daunting the Win32 API (or any API for that matter) becomes, because I can reduce the complexities to loading a register, then manipulating that somehow. When you break things down like that (which assembler forces you to do), they can suddenly become crystal clear.<br /></div><br />C++ needs the types so you'll have to cast it. Again, passing a CREATESTRUCT pointer as a long (LPARAM) is dirty too, but necessary because of the way window procedures work. Don't blame C++ for how the windows API works. If you look at C++ without the windows API, you will nearly never see these reinterpret_casts. As long as everything is typed, code is clean and easy to follow. The windows API often lacks this typing. SetWindowLong for example, you can store anything in it, but you'll have to cast it to longs. That's where things get dirty. <br /><br /><div class="quote">Once you get to a certain point in experience in assembler, you can program in it just about as fast as in most HLLs.</div><br />Most API stuff, yes. Complex algorithms and optimized code, no. Especially if you want things to work as fast as possible, you might be optimizing a routine for an hour while the same thing could have been written in a HLL in 10 minutes. It's the price you pay for a fast routine.<br /><br /><div class="quote">Plus, IMHO, it's more fun, and you get a deeper understanding of what's going on in general.</div><br />True, its good to have an assembly background even when programming in a HLL.<br /><br />Thomas</div>
    <div class="meta">Posted on 2003-03-30 09:28:59 by Thomas</div>
   </div>
   <div class="post" id="post-91761">
    <div class="subject"><a href="#post-91761">Why ASM?</a></div>
    <div class="body"><div class="quote"><br />True, assembler is simple because its instructions are simple. But I'm sure I can read a binary tree search or quicksort implementation easier in C++ than in asm, especially when the asm is optimized (it should).<br /></div><br />I agree. However I did read somewhere about C code written for optimization being very difficult to read too. As I recall it was something about the Berkeley strings library(?), that that code is brutal because it's optimized. So I guess if you compare non-optimized HLL tree code to non-optimized ASM tree code, I do think the HLL would still be easier to understand, but probably only slightly. I have an expandable array library that I rewrote from C to MASM, and I find the MASM version is just as easy to understand, looking at it several months after writing it.<br /><div class="quote"><br />C++ is strongly typed, which is good IMHO. In asm, if you accidentaly reverse two totally different typed parameters when calling a function you won't notice it until it executes and probably crashes, because all parameters are just dwords. C++ will tell you at compile time.<br /></div><br />Those are easy to find and correct.<br /><div class="quote"><br />It's even worse if your program contains such a bug but it doesn't crash, you'll probably have a hard time finding it.<br /></div><br />Agreed! It's harder than a crash, but nothing that's ever turned my hair gray! :grin:<br /><br />Just as likely as swapping parameters is the possibility of sending a parameter that is simply logically wrong, in other words, you misunderstood the meaning of that parameter, or you're sending it in the wrong format -- and that can happen with ANY language. In assembler, however, you get used to dealing with crashes :) and you become much better at finding their sources. If you're making some Win32 API call from VB that crashes your app, and all you know is VB, good luck finding that bug!<br /><div class="quote"><br />Don't blame C++ for how the windows API works. If you look at C++ without the windows API, you will nearly never see these reinterpret_casts.<br /></div><br />That may be, but we program in the Win32 API. You're right, in theory, I shouldn't blame C++, but I don't use it in the perfect context where C++ is pristine and beautiful (is it ever? really???). In the Win32 world, things get pretty ugly, and I'm just saying that I prefer ASM for that world.<br /><br />To each their own though... these are just my personal opinions! :alright:</div>
    <div class="meta">Posted on 2003-03-30 10:21:17 by MANT</div>
   </div>
   <div class="post" id="post-91770">
    <div class="subject"><a href="#post-91770">Why ASM?</a></div>
    <div class="body"><div class="quote"><em>Originally posted by MANT </em><br />I agree. However I did read somewhere about C code written for optimization being very difficult to read too. As I recall it was something about the Berkeley strings library(?), that that code is brutal because it's optimized. </div><br />Optimized code is always harder to read, but usually you just put them in a library when they're finished and use them without looking at it. If you write dirty code, it looks dirty. However C++ makes it easier to write clean code than asm. Also note that C++ and C use a totally different programming paradigm, many 'C++ programmers' think they are C++ programmers but are actually C coders using a C++ compiler.<br /><br /><div class="quote">So I guess if you compare non-optimized HLL tree code to non-optimized ASM tree code, I do think the HLL would still be easier to understand, but probably only slightly. I have an expandable array library that I rewrote from C to MASM, and I find the MASM version is just as easy to understand, looking at it several months after writing it.</div><br />Also for people that have never seen it before? Of course it also depends on your coding style and the quality of your comments, you can make asm easier to understand by formatting your code well (indenting, meaningful labels, good comments).<br />But in general, I think HLLs are much easier to read. For example, the code I posted in another thread this day, compare:<br /><pre><code><br />    xor     eax, eax<br />    mov     ecx, &#91;esp+4&#93;<br />    cmp     ecx, 1<br />    je      _ret    <br />    mov     eax, 2<br />    jb      _ret    <br />    cmp     ecx, 16<br />    sbb     eax, 0<br />_ret&#58;<br />    ret</code></pre><br />with:<br /><pre><code><br />if &#40;val==1&#41;<br />    return 0;<br />else if&#40;val&gt;1 &amp;&amp; val&lt;16&#41;<br />    return 1;<br />else<br />    return 2;</code></pre><br />Which one did you understand faster? I guess the second. This isn't completely fair, since the assembler version doesn't have comments, but the C version hasn't either and is still easy to follow. If you comment it a bit:<br /><pre><code>    xor     eax, eax<br />    mov     ecx, &#91;esp+4&#93;<br />    cmp     ecx, 1<br />    je      _ret    ; ecx==1 -&gt; return 0<br />    mov     eax, 2 <br />    jb      _ret    <br />    cmp     ecx, 16 ; ecx&gt;1 &amp;&amp; ecx&lt;16 -&gt; return 1<br />    sbb     eax, 0  ; else return 2<br />_ret&#58;<br />    ret</code></pre><br />Now it's clear what the code does but it takes a lot more characters than in C.<br /><br /><div class="quote">Those are easy to find and correct.<br /><br />Agreed! It's harder than a crash, but nothing that's ever turned my hair gray! :grin:<br /><br />Just as likely as swapping parameters is the possibility of sending a parameter that is simply logically wrong, in other words, you misunderstood the meaning of that parameter, or you're sending it in the wrong format -- and that can happen with ANY language. In assembler, however, you get used to dealing with crashes :) and you become much better at finding their sources. If you're making some Win32 API call from VB that crashes your app, and all you know is VB, good luck finding that bug!</div><br />True, you'll have to learn by making mistakes :). Still, C++'s strong typing helps you find bugs in an early stage thus saving you the time of debugging.<br /><br /><div class="quote">That may be, but we program in the Win32 API. You're right, in theory, I shouldn't blame C++, but I don't use it in the perfect context where C++ is pristine and beautiful (is it ever? really???). In the Win32 world, things get pretty ugly, and I'm just saying that I prefer ASM for that world.</div><br />Lower languages are more flexible and powerful but that does mean you have to know what you're doing. In java, you get a 'nice' exception if you cast an object to a type it doesn't support. In C++, it does cast and likely ends up crashing. In asm, noone cares what you're doing :). This has its advantages and disadvantages. It allows you to optimize code but also to mess things up faster.<br /><br /><div class="quote">To each their own though... these are just my personal opinions! :alright: </div><br />Agreed :)</div>
    <div class="meta">Posted on 2003-03-30 10:56:38 by Thomas</div>
   </div>
   <div class="post" id="post-91777">
    <div class="subject"><a href="#post-91777">Why ASM?</a></div>
    <div class="body">I really don't want to make this a flame session, because I agree with some of your points. However, you're stacking the deck a bit with your ASM vs C code comparison, and that's not entirely fair. When I was talking about how I personally program, I use MASM, and my version of that code would have been:<br /><br /><pre><code><br />.if val == 1<br />    return 0<br />.elseif val &gt; 1 &amp;&amp; val &lt; 16<br />    return 1<br />.else<br />    return 2<br />.endif<br /></code></pre><br /><br />Just as easy to understand and write as the C version. A few more characters, no big deal. I defined a &quot;return&quot; macro a hundred years ago so I could write more readable code.<br /><br />Even if I didn't use MASM's structured programming goodies, there's no way I would have written the code your way, which, forgive me, seems deliberately hard to read. Here's how I might have written it:<br /><br /><pre><code><br />    cmp ecx, 1<br />    je R0<br />    jl R2<br /><br />    cmp ecx, 16<br />    jl R1<br /><br />R2&#58; mov eax, 2<br />    ret<br /><br />R1&#58; mov eax, 1<br />    ret<br /><br />R0&#58; xor eax, eax<br />    ret<br /></code></pre><br /><br />If you even have a passing knowledge of assembler, I don't see that as being hard to understand at all. (In your C code, it's not clear whether you're dealing with signed or unsigned, so I assumed signed.)<br /><br />I'm sure we can both find plenty of counterexamples to try and disprove the other's points, but that would really be missing my original point, which was that in dealing with the Win32 API, I find assember code &quot;feels&quot; cleaner to me, and I get a deeper understanding of what's going on.<br /><br />And again, for me personally it's more fun! ;)</div>
    <div class="meta">Posted on 2003-03-30 11:25:00 by MANT</div>
   </div>
   <div class="post" id="post-91789">
    <div class="subject"><a href="#post-91789">Why ASM?</a></div>
    <div class="body"><strong>MANT</strong>: NOFI, but if you write the code I posted like you did, there's no use in doing it in assembly. If you look at <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=11913.msg91731">the other thread</a> you can see that the C version will generate more efficient code than MASM's IF constructs. Why use assembler then?<br />This sounds a bit harsh but it's true. However many people have more reasons to program in assembly than just speed. Like you said, it's fun and I agree. I like hacking out a piece of code until it's fast as hell but I don't have the time to do this for complete programs.<br /><br />The 'problem' with code that isn't speed critical is that it doesn't matter in which language you write it. You won't notice the difference anyway. So it won't matter either whether you use .IF/.ELSEIF or an optimized version like I showed you. You might as well program the thing in C and never notice any difference. But some things I believe are true:<br /><br />- *well* written asm code is at least as good as what the compiler outputs<br />- 'normal' asm code (that is, not completely optimized, using IF constructs, WHILE loops, MASM's support for locals &amp; parameters) is worse than the compiler's output<br />- well written asm takes a lot longer than writing in a HLL<br />- normal written asm might be coded in the same time as in a HLL (like you said)<br /><br />For critical code this means: writing in assembly (highly optimizing) is best. compiler's are second best. writing non-optimal code in assembly for speed critical operations is stupid, you'd better use a compiler.<br /><br />For non-cricitcal code this means: it doesn't matter. You won't notice the difference anyway. When counting every clock cycle, it's probably just like critical code: handwritten is best, then compilers then non-optimized assembly.<br /><strong>But</strong>: if it doesn't matter for non-critical code, you must have other reasons for your choice, such as:<br />- assembly is fun :)<br />- HLLs are easier and faster to program<br />- I hate HLLs (bad reason :) but true for some people)<br />- etc. etc.<br />You can probably think of a lot more reasons but the bottom line is that it doesn't matter what you code in for non-critical code (well if you end up with javascript you might notice a difference :grin:). I code most non-critical code in C++ because I can code much faster and cleaner in it. If you prefer asm for what reason, that's your choice. My program won't be noticibly faster than yours.<br /><br />Only for speed critical code it matters, but then, you need to use any trick you've got to optimize the code to the fullest. That means no .IF constructs, your own stackframe, hard to read code etc. etc. Everything that makes it go faster (or smaller).<br /><br />Thomas</div>
    <div class="meta">Posted on 2003-03-30 12:09:11 by Thomas</div>
   </div>
   <div class="post" id="post-91798">
    <div class="subject"><a href="#post-91798">Why ASM?</a></div>
    <div class="body">Well, Thomas, I think the bottom line is, program in whatever you want. :tongue:<br /><br />I have personally found a lot of use coding 100% assembler, and it goes far beyond what we've been talking about. You're right that the if/elseif/else test you illustrated is not critical code, and it doesn't matter whether you use assembler or not. But there are so many things you get out of doing your project in 100% assembler, that I can't even begin to describe how annoying it is to hear someone say &quot;you might as well write that in C or Java&quot;. Although it's absolutely true, you end up missing a whole bunch of opportunities for letting assembler change the way you THINK about your coding.<br /><br />And, upon thinking further about that code example, in C and any language I use, I tend to not use elseif's when there's a return before it. So I would really have written it like this...<br /><br /><pre><code><br />if &#40;x == 1&#41;<br />    return 0;<br />if &#40;x &lt; 1 &amp;&amp; x &gt; 16&#41;<br />    return 1;<br />return 2;<br /></code></pre><br /><br />Coding something similar in MASM using .if/.endif would eliminate some of MASM's (and some C compilers') stupidity. If it's critical code, you're probably going to be optimizing it to the point of illegibility anyway, no matter what language you use. And in that case, I would say that if you did the rest of the app in assembler, you'll have an easier time optimizing, because that's what you're already thinking in. For instance, this comes to mind:<br /><br /><pre><code><br />    mov     eax, 1          ; return 1 by default<br />    cmp     ecx, 0<br />    cmove   eax, value_2    ; 0 --&gt; return 2<br />    cmp     ecx, 1<br />    cmove   eax, value_0    ; 1 --&gt; return 0<br />    cmp     ecx, 16<br />    cmovae  eax, value_2    ; 16+ --&gt; return 2<br />    ret<br /></code></pre><br /><br />No jumps at all. (I'm not sure it's totally correct, or even faster, but it's just an example.) I doubt a C compiler would do that, and this kind of thing is pretty natural to come up with when you're writing in assembler anyway. Further, the experimentation with different ways of doing it in assembler often gives you insights into changing the nature of the test or the module itself in such a way that you can get 2x or 10x the speed (or cut the size of the code). You would get a similar improvements in a HLL language too, but you only THOUGHT of it in the first place because you were programming in assembler, and dealing with the details.<br /><br />I don't know if that illustrates my point very well, but it's those kind of &quot;ah-ha!&quot; moments I really value about ASM programming. I get them in HLL's too, but not nearly as often.<br /><br />Anyway, I know I'm crazy to program in 100% assembler. I can't port my code, and most of the code I write using MASM's HLL constructs are slightly worse than what I'd get with C. But I know that I'm using them in non-critical areas, so it doesn't matter to me. What matters is the state of mind I enter when using assembler. YMMV! :grin:</div>
    <div class="meta">Posted on 2003-03-30 12:46:08 by MANT</div>
   </div>
   <div class="post" id="post-91812">
    <div class="subject"><a href="#post-91812">Why ASM?</a></div>
    <div class="body"><div class="quote"><em>Originally posted by MANT </em><br />I have personally found a lot of use coding 100% assembler, and it goes far beyond what we've been talking about. You're right that the if/elseif/else test you illustrated is not critical code, and it doesn't matter whether you use assembler or not. But there are so many things you get out of doing your project in 100% assembler, that I can't even begin to describe how annoying it is to hear someone say &quot;you might as well write that in C or Java&quot;. Although it's absolutely true, you end up missing a whole bunch of opportunities for letting assembler change the way you THINK about your coding.</div><br />Programming in assembly is a good learning experience, it can improve your optimizing and logic skills and gives you a new view on programming. I have written several programs in 100% assembly too, but after a while I shifted more to the HLL side. I still like to optimize code in assembly and often use it as parts of a program but I don't write big programs in assembly completely anymore.<br />While all this might be good for you, it isn't for the program itself. As long as you know this, its okay. But some so called assembly programmers think they are great but in reality write code that's worse than the worst compilers (that's not the case with you :)).<br /><br /><div class="quote">And, upon thinking further about that code example, in C and any language I use, I tend to not use elseif's when there's a return before it. So I would really have written it like this...<br /><br /><pre><code><br />if &#40;x == 1&#41;<br />    return 0;<br />if &#40;x &lt; 1 &amp;&amp; x &gt; 16&#41;<br />    return 1;<br />return 2;<br /></code></pre></div><br />It would have produced nearly the same code (just a swap of the conditions).<br /><br /><div class="quote">Coding something similar in MASM using .if/.endif would eliminate some of MASM's (and some C compilers') stupidity.</div><br />Well if you would translate it directly in MASM code it would still test x for 1 twice and add useless jumps to the next instruction that will never execute.<br /><br /><div class="quote">If it's critical code, you're probably going to be optimizing it to the point of illegibility anyway, no matter what language you use. And in that case, I would say that if you did the rest of the app in assembler, you'll have an easier time optimizing, because that's what you're already thinking in. </div><br />If I have a big program where 2% is speed critical I would write it in C++ and optimize the 2% in assembly rather than writing everything in assembly, taking twice as long and ending up with a program that's harder to read and maintain than the C++ version. But that's my choice..<br /><br /><br /><div class="quote">For instance, this comes to mind:</div><br /><pre><code><br />    mov     eax, 1          ; return 1 by default<br />    cmp     ecx, 0<br />    cmove   eax, value_2    ; 0 --&gt; return 2<br />    cmp     ecx, 1<br />    cmove   eax, value_0    ; 1 --&gt; return 0<br />    cmp     ecx, 16<br />    cmovae  eax, value_2    ; 16+ --&gt; return 2<br />    ret<br /></code></pre><br />No jumps at all. (I'm not sure it's totally correct, or even faster, but it's just an example.) I doubt a C compiler would do that, and this kind of thing is pretty natural to come up with when you're writing in assembler anyway. </div><br />That would probably be faster, I assumed the cmov instruction was not allowed (VC6 doesn't use it). Some other compilers may use it (they easily can). But like I said, you can always write better code than a compiler but the question is is it worth it?<br /><br /><div class="quote">Further, the experimentation with different ways of doing it in assembler often gives you insights into changing the nature of the test or the module itself in such a way that you can get 2x or 10x the speed (or cut the size of the code). You would get a similar improvements in a HLL language too, but you only THOUGHT of it in the first place because you were programming in assembler, and dealing with the details.</div><br />True, when programming in assembly you're more alert for optimizations.<br /><br /><div class="quote">I don't know if that illustrates my point very well, but it's those kind of &quot;ah-ha!&quot; moments I really value about ASM programming. I get them in HLL's too, but not nearly as often.<br />Anyway, I know I'm crazy to program in 100% assembler. I can't port my code, and most of the code I write using MASM's HLL constructs are slightly worse than what I'd get with C. But I know that I'm using them in non-critical areas, so it doesn't matter to me. What matters is the state of mind I enter when using assembler. YMMV! :grin: </div><br />In any case, you will get great knowledge from programming assembly. I just think that after some years of asm programming you get a bit tired of doing everything in assembly even when you don't optimize it to the fullest while you know a compiler could do better. At a certain point you won't learn much more from the usual program stuff that mostly involves calling API functions. That's when the combination of a compiler for the main work and an assembler for the speed critical work becomes a good alternative. You have the benefit of compiler optimized code while still hand optimizing some routines and learning the neat tricks involved with that. That's my choice, it's a personal thing. Just use what you're confortable with :)</div>
    <div class="meta">Posted on 2003-03-30 13:22:44 by Thomas</div>
   </div>
   <div class="post" id="post-91817">
    <div class="subject"><a href="#post-91817">Why ASM?</a></div>
    <div class="body">:tongue:</div>
    <div class="meta">Posted on 2003-03-30 13:43:44 by f0dder</div>
   </div>
   <div class="post" id="post-91819">
    <div class="subject"><a href="#post-91819">Why ASM?</a></div>
    <div class="body">Hey Thomas, never mind all that, just tell me how you get your ASM code to format so beautifully on your web site?!?!? :grin:</div>
    <div class="meta">Posted on 2003-03-30 13:48:47 by MANT</div>
   </div>
   <div class="post" id="post-91824">
    <div class="subject"><a href="#post-91824">Why ASM?</a></div>
    <div class="body"><div class="quote"><br />Hey Thomas, never mind all that, just tell me how you get your ASM code to format so beautifully on your web site?!?!? :grin: </div><br />:) I just wrote a simple highlighter for asm/C++ to html and a couple of batch files to generate php includes from the output.<br /><br />Thomas</div>
    <div class="meta">Posted on 2003-03-30 13:58:51 by Thomas</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=11227&amp;page=1" style="">&laquo;</a><a href="../?id=11227&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="11227" /><input type="number" name="page" min="1" max="6" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=11227&amp;page=4">&gt;</a><a href="../?id=11227&amp;page=6">&raquo;</a></form>  </div>
 </body>
</html>