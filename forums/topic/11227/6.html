<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Why ASM? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=11227" />
  <link rel="prev" href="../?id=11227&amp;page=5" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=11227">Why ASM?</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=11227&amp;page=1" style="">&laquo;</a><a href="../?id=11227&amp;page=5" style="">&lt;</a><input type="hidden" name="id" value="11227" /><input type="number" name="page" min="1" max="6" step="1" value="6" onchange="this.form.submit();" /></form>   <div class="post" id="post-150577">
    <div class="subject"><a href="#post-150577">Why ASM?</a></div>
    <div class="body">Yes, optimization is a great use for asm and can save a ton of time in operation.  <br /><br />The issue comes when you have to create this product for some end user and you have to add in all the icons and scrollbars, textfields, etc etc and make them all respond to inputs and what not.  Java is no contest for quickness in creating the app, although it will be a bit more sluggish.   <br /><br />Its all the balance of creating versus operating.<br /><br />No point in creating something thats going to be too old to use by the time its finished.  <br /><br /> :idea: <br />I hear Sun is working on some type of new addon to Java thats supposed to be within the scope of machine level, at least the speed anyway.  Could change some minds about straigt up asm someday.</div>
    <div class="meta">Posted on 2004-09-27 19:02:13 by timoioi</div>
   </div>
   <div class="post" id="post-150578">
    <div class="subject"><a href="#post-150578">Why ASM?</a></div>
    <div class="body">Last time I saw java apps was the last time I wanted to see any,haven't installed the vm for firefox and never will. The last app was a simple interface to send srccode via LAN , and consisted of several buttons and a listbox - hadn't seen so slow and ugly interface in my life. The listbox scroll was so slow that I thought I'm running cool Flash with many effects on a 33MHz cpu instead of on a 2GHz Athlon ... :)  still, a coder that no longer posts here has shown that some cool stuff can be made in java...<br />my point here is that instead of making possible for users to code lowlevel in java, sun have to get at least a bit good coders to make their UI better... and someone who isn't blind to determine UI default design  :roll:</div>
    <div class="meta">Posted on 2004-09-27 19:22:43 by Ultrano</div>
   </div>
   <div class="post" id="post-162694">
    <div class="subject"><a href="#post-162694">Re: Why ASM?</a></div>
    <div class="body">I like asm becase i can make a EXE without an icon or with lots icons , but VB can not do (or i can&#39;t do it in VB,:(&nbsp; ).<br />Now I can write lots of little programs using asm , i&#39;ll learn it everyday.<br />Thank u , Steve Hutchesson and&nbsp; Iczelion , very much.</div>
    <div class="meta">Posted on 2005-08-01 12:14:56 by shaojf2001</div>
   </div>
   <div class="post" id="post-168441">
    <div class="subject"><a href="#post-168441">Re: Why ASM?</a></div>
    <div class="body">let me say: &quot;when asm&quot;<br />the c language represents an assembly preprocessor.<br />the benefit: some portability. the tradeoff: constructs more tricky than assembly itself.<br />asm good = even too easy<br />asm bad = difficult to maintain/change hudge program, need rewrite.<br /><br />basic=interpreted script language (even if compiled)<br />dont&#39;t optimize (for code size) anymore.<br /></div>
    <div class="meta">Posted on 2005-12-01 07:13:36 by akidd86</div>
   </div>
   <div class="post" id="post-168515">
    <div class="subject"><a href="#post-168515">Re: Why ASM?</a></div>
    <div class="body">I&#39;m new to these forums, so..&nbsp; well, I think i can post some of answers &quot;why I like asm&quot;, since this topic is about that, isn&#39;t it?<br /><br />Well, I started with C++ (mainly C) and it seemed magically to me..&nbsp; this was until I first took a look at some assembly programs. After that, I started to dig deeper into the World of assembly, and read a few books (the best of all was &quot;The Art of Assembly Language Programmers&quot; by Randall Hyde (thanks Randy!))...&nbsp; since then, I prefer to use asm so I can control every instruction (I use C++ mostly for testing and debugging, &#39;cause that&#39;s where they are much more powerful than asm for me&nbsp; ;)).<br /><br /><br />Why Asm? Maybe because I don&#39;t want to be a lazy guy that thinks computers are simple (HLL tend to &#39;hide&#39; and make things abstract, so you think &#39;it&#39;s easy&#39;, when in fact, the CPU and instruction set is pretty complex), and I think the phrase <strong>&#39;making it work is what matters&#39;</strong> is not covering all the aspects (i.e. efficiency), so in my perspective, I need more than that (such as optimization). I am still trying to understand all the principles of hardware design, because I feel so wierd when I use C++ classes inheritance (mainly because it&#39;s so abstract, and because that has nothing to do with the CPU (how it reads instructions I mean&nbsp; ;)), and also because it&#39;s very bloated and inefficient).<br /><br />I also like Asm because I like to appreciate memory and CPU cycles...&nbsp; a byte is still a byte, no matter if the user has 1MB or 256MB of RAM... same goes for clock cycles. Most people find an <strong>excuse</strong> for their bloated and inefficient programs -&gt; the hardware will save me.&nbsp; I chose asm because, even though there are tons of RAM or Mhz, I still appreciate every byte or cycle, because I can&#39;t find an excuse in that (and I am not old-fashioned, trust me&nbsp; ;)). I usually ignore those people when they say that the hardware will save them.. after all, if hardware is better, why make software slower; a <strong>simple</strong> notepad typically requires very few memory and Mhz, but I&#39;ve seen some people making one which required 100Mhz.. why? because they are lazy, or because they are abstracted by very High-level HLLs (like Visual Basic; C is not so high-level) and they think programming on a computer is easy? when, in fact, it&#39;s very complicated...&nbsp;  and why such a bloated application just for a simple &quot;Hello World&quot; program?<br /><br />Thinking on that, I began to really understand every concept of the common PC.. and I&#39;m still learning, by the way...&nbsp; I really hate when HLLs abstract things from me, but sometimes I get to compile some C source code with my mind as I write.. heheh.. so I usually use C when I know it&#39;s not producing inefficient code..<br /><br />Another reason for choosing asm might be because I like asm and it&#39;s fun, but that&#39;s not the strong one, you know.<br /><br /><br />As far as I&#39;m concerned, compilers cannot optimize better than humans.. first, the human can simply look at the output of the compiler (i.e an .asm listing) and improve that code...&nbsp; and humans can optimize certain sections of code because they <strong>special-optimize</strong> the task at hand; a compiler has no way to know if this section of code was designed for special purpose. Let me give an example:<br /><br />Suppose you want to read some variable from memory, from a byte, into a 32-bit register... you know eax is right now smaller than 256, so in other words, it has the three high-bytes zeroed... the compiler will typically use a <strong>movzx</strong> instruction, or a <strong>xor</strong> and <strong>mov</strong> pair, because it simply cannot know this when statically compiling. This rule applies to all special-purposed sections of code..&nbsp; Only the programmer knows what this code is really used for (and what&#39;s it gonna do).&nbsp; Of course, you could add some special features to a compiler, like Visual C++&#39;s __assume directive, but once these things get powerful, they will complicate the code a lot, and that&#39;s not the point in HLLs.<br /><br />Of course, a beginning assembly language programmer will actualy do a lot worse than a compiler, but a professional assembly programmer will always beat a compiler. After all, the worst case scenario would be that the assembly programmer will simply look at what the compiler generated, and optimize that.&nbsp; ;)<br /><br /><br />So, here I am... from a C++ freak, into an assembly language fanatic (and I mean a really optimizing-freak). Asm is also my &#39;chosen&#39; language, because I prefer efficient code over easy code.<br /><br /><br /><br />PS: I hope I have followed the forum rules, if not please please forgive me.. I&#39;m new and I am still trying to, you know, get &#39;integrated&#39; into these forums&nbsp; ;).. again, I&#39;m sorry if I have not followed the rules. please tell me so I will not do it again. And I didn&#39;t try to offense anyone, I&#39;m just trying to explain &quot;why I chose asm&quot;.. and my english is not so good, so please forgive wrong expressions, and I hope you understand what I wanted to tell you.<br /><br /><br />BTW: Great community. Keep up the good work, guys&nbsp; :D<br /><br />The Grey Beast</div>
    <div class="meta">Posted on 2005-12-03 15:20:06 by The Grey Beast</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=11227&amp;page=1" style="">&laquo;</a><a href="../?id=11227&amp;page=5" style="">&lt;</a><input type="hidden" name="id" value="11227" /><input type="number" name="page" min="1" max="6" step="1" value="6" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>