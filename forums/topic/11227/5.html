<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Why ASM? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=11227" />
  <link rel="prev" href="../?id=11227&amp;page=4" />  <link rel="next" href="../?id=11227&amp;page=6" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=11227">Why ASM?</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=11227&amp;page=1" style="">&laquo;</a><a href="../?id=11227&amp;page=4" style="">&lt;</a><input type="hidden" name="id" value="11227" /><input type="number" name="page" min="1" max="6" step="1" value="5" onchange="this.form.submit();" /><a href="../?id=11227&amp;page=6">&gt;</a><a href="../?id=11227&amp;page=6">&raquo;</a></form>   <div class="post" id="post-99392">
    <div class="subject"><a href="#post-99392">Why ASM?</a></div>
    <div class="body">I didn't say you couldn't. I said it's easier to do something wrong in asm.<br /><br />Thomas</div>
    <div class="meta">Posted on 2003-04-25 13:32:15 by Thomas</div>
   </div>
   <div class="post" id="post-99394">
    <div class="subject"><a href="#post-99394">Why ASM?</a></div>
    <div class="body">right now is not the best time for me to be talking about this <br />I keep getting called away from the computer and have to <br />post unfinished thoughts please re read my posts I have edited <br />them to finish my thoughts</div>
    <div class="meta">Posted on 2003-04-25 14:10:07 by rob.rice</div>
   </div>
   <div class="post" id="post-99398">
    <div class="subject"><a href="#post-99398">Why ASM?</a></div>
    <div class="body"><div class="quote"><em>Originally posted by rob.rice </em><br />a human can pull back and look at the task at hand <br />a compiler can't do that <br />compillers have gotten a lot smarter BUT thay at there  <br />best look at one function at a time not the whole program <br />and no compiller will ever be smarter than a human<br />a compiller can't re strecuter the program the way a humen can <br />and useing an Hll the human cant see how restructureing<br />will help when it can help ( I'm not saying that it will always help)</div><br />That's a different level of optimizing, there's code level optimizing and algorithm/design level optimizing. Compilers don't come up with algorithms or designs, that's the part the programmer has to do (what else is programming for?). This is true for both assembly and HLLs.  The thing you're talking about is not a task of a compiler, you might as well say that asm programmers are better because humans can talk and compilers can't. No matter what language, the design and algorithms have to be figured out by the programmer.<br />The difference between HLLs and assembly is with HLLs, the programmer focusses on the design, while with asm, the programmer has to do both the design and the code level details (optimizing). In cases where the design matters more than the speed gained by optimizing the code level by hand, I pefer HLLs but that's my choice.<br />It's true that the structure of an asm programming is more 'low-level' than a HLL program structure, but this has both advantages and disadvantages. HLLs often have nice features for creating data structures and designing programs (classes, interfaces, design patterns). In assembly, none of these present by default. You all have to do this yourself. Often asm programs lack any good design, but this too depends on the programmer. It's just that HLLs provide the basic elements for good design so chances are higher one will have a working design in HLLs than without these basic elements. Sometimes asm programmers tend to think low-level all the time, while high-level design is just as important.<br /><br /><div class="quote">there is also the matter of uneeded overhead that always comes <br />with HLLs you can't turn off just the useless parts of this over <br />head but you can turn off all of it and rebuild the parts you need <br />the compiller can't see what is going to be done it just gets ready <br />for every thing that can be done to be done this is part of what <br />I mean about humans being smater than compillers</div><br />This is true for standard libraries that have standard functionality of which some things aren't used but still present. Personally I rather have some extra stuff I don't use than writing all those routines myself.<br />Btw the STL C++ classes are mostly templates with inline functions, the basic data structures (vectors, lists, queues, maps) have an overhead close to zero. <br /><br /><div class="quote">and there some things that can be done in assembly that HLLs are just can't easly do like bit manipulation</div><br />Most bit stuff is available in HLLs to (I've missed rol/ror a few times though), but it's true that these things are easier in assembly, because it's more low level. The use of (complex) bit manipulation is very limited in most programs though (the occasional flag check can be done just as fast in C).<br /><br /><div class="quote">I am not saying that HLLs are useless but thay are not always the best way to do things</div><br />Then we agree :) It's like saying the glass is half full or half empty: HLLs are not always the best thing but asm isn't always the best thing either.<br /><br /><div class="quote">a rotter assembly programmer will most likely be a rotten Hll programmer Hlls are not a fix for not knowing what you are doing</div><br />But a good C programmer has to know a lot less than a good asm programmer. To beat the compiler you really need to know the CPU details, instruction timings, pipelines, cache stuff etc.<br /><br /><div class="quote">and yes one needs to know a whole of a lot more to program to <br />program in assembly than HLLs but at the same time one gains <br />a better understanding of how computers work even if you never <br />programs in assembly this alone makes it worth learning</div><br />I totally agree but don't mix up educational use with practical use.<br /><br />Just like you're not saying 'asm rules', I'm not saying 'C++ rules', I enjoy programming in assembly and use it where I think it matters, I'm only explaining my view on the use of assembly and how it compares to HLLs.<br /><br />Thomas</div>
    <div class="meta">Posted on 2003-04-25 14:31:22 by Thomas</div>
   </div>
   <div class="post" id="post-99401">
    <div class="subject"><a href="#post-99401">Why ASM?</a></div>
    <div class="body">quote<br />But a good C programmer has to know a lot less than a good asm programmer. To beat the compiler you really need to know the CPU details, instruction timings, pipelines, cache stuff etc.<br /><br />so we agree that a good assembly programmer can beat a compiler</div>
    <div class="meta">Posted on 2003-04-25 14:47:13 by rob.rice</div>
   </div>
   <div class="post" id="post-99402">
    <div class="subject"><a href="#post-99402">Why ASM?</a></div>
    <div class="body"><div class="quote"><em>Originally posted by rob.rice </em><br />so we agree that a good assembly programmer can beat a compiler</div><br />Certainly, I've always said that. It was you who forgot the word 'good' each time ;)<br /><br />Thomas</div>
    <div class="meta">Posted on 2003-04-25 14:52:17 by Thomas</div>
   </div>
   <div class="post" id="post-99404">
    <div class="subject"><a href="#post-99404">Why ASM?</a></div>
    <div class="body">I have used BASIC for working out the algorithm <br />and recoded in assembly the style of BASIC is alot<br />closer to the style of assembly than any other <br />lanuage that I know of well fortran is close too<br /><br />so even for writing in assembly HLLs some times have a place</div>
    <div class="meta">Posted on 2003-04-25 14:58:55 by rob.rice</div>
   </div>
   <div class="post" id="post-101870">
    <div class="subject"><a href="#post-101870">Why ASM?</a></div>
    <div class="body">Why is ASM that is good Q &amp; A<br /><br /><br />Q:Why is ASM<br />A:Just is I Like....<br /><br /><br />hehe~<br />same is Why is C? not C++, Why is VB? not Dephi?<br />any thing just i like... if u like C++ just do it, not why....<br /><br />for asm member will anser ASM will to Build a Samll and Fast program or code...<br />that too old Anser.. now CPU speed will fast more and Save Drivce will large more...<br /><br />why is ASM ? my anser is very sample<br />that is &quot;ASM&quot; is my love...<br /><br />:grin: :grin: :grin:</div>
    <div class="meta">Posted on 2003-05-07 18:51:34 by swang</div>
   </div>
   <div class="post" id="post-103576">
    <div class="subject"><a href="#post-103576">Why ASM?</a></div>
    <div class="body">I use C++ when I need to simplify code and concentrate on the problem at hand.<br /><br />For example, I am writing a bottom-up parsing algorithm which has a lot of code, and is definitely not easy to come up with. In C++, I can more easily maintain and modify my code, and I don't have to worry about the tiniest details.<br /><br />Java, on the other hand, is an ugly language, both for the coder and the end-user.</div>
    <div class="meta">Posted on 2003-05-17 14:15:34 by Paulicles the Philosopher</div>
   </div>
   <div class="post" id="post-104676">
    <div class="subject"><a href="#post-104676">Why ASM?</a></div>
    <div class="body"><div class="quote">Microsoft build software to help an operating system not owned by them? Are you kidding? Even so, I'd hope developers and IT managers are smart enough to not be influenced soley by an ad on TV. Being a proven solution is what counts. J2EE has been proven many times. .NET has not.</div><br /><br />I haven't read the whole thread yet but once I got to the above quote I had to comment.<br /><br />I work in a pure MS shop building an ASP.NET application in VB.NET 90%, C# 10%.  The app is for the insurance industry and we have about 10,000 users or so.  That equates to about 50,000 requests per hour.  We minimize postbacks as much as possible.<br /><br />We have some very powerful datacenters and bandwidth is not an issue.  It's a proprietary app but licences/rented commercially.<br /><br />Scalability?  We are able to sustain roughly 20,000 - 50,000 requests per hour (using SQL Server 2k on the back-end) and our latency is less than 2 seconds and in many cases we are about .5 seconds and 2 seconds worse case (except the few rare instances where some intense crunching and transactions are taking place then we push it off to the Message Queue and it takes 5 - 45 seconds but that's not core functionality so it's not an issue to be concerned about.<br /><br />Stability?  .NET has it's stability issues.  In many cases I tend to be afraid a wee for some of our processes and code defensively moreso than I do in other languages that don't have stability isses but for the most part, it's very stable (our app always hasn't been and we did quite some work to make it stable).<br /><br />In all, concerning stability of ASP.NET (version 1.0) really takes some knowing the architecture, how things work, good patience, good exprerience, good design, and lots of junk food but it's workable.<br /><br />I am not a Java programmer so I can't comment on any of it's issues/merits but my experience with ASP.NET/C#/VB.NET has been very frustrating to get there but very rewarding when seeing it in action (our total database is about 100 TeraBytes or so) but partitiioned to clients that use about 1-10 TB).  I'm not a DBA so I don't know the details.<br /><br />Really, those who want to question .NET's scalability and performance are asking good questions and for the right reasons if they ask out of concern, but my experience thus far with it has enlightened me to the fact that it performs and scales quite well in the Enterprise.<br /><br />Not withstanding we've had MS come and hand tweak a few areas in the past, the .NET development in our shop (about 50,000 lines -- some well architected, some thrown together like spaghetti (depends on the developer) has been developed independantly and tweaked independantly based on our frustrating experiences with the capability limits or just qwerkiness of ASP.NET... not sure which...<br /><br />In all, I don't have too many concerns about ASP.NET now looking back on it... however I do realize it can be very frustrating to do seemingly simple things and getting high-performance results isn't a natural thing and really has to be worked out through trial-and-error but it's reasonably possible to get the end result but that requires developers with loads of experience (in development and computer science understanding) and isn't, in my opinion, going to be achieved by people with lesser experience and understanding.  Most of our developers are at a senior level and we don't have any beginners on our teams.  I don't think they'd be able to pull off the kind of results our business requires.  But that's not the point I'm trying to make.<br /><br />My point is that it handles itself quite well in the Enterprise and can easily handle 50,000 requests per hour (given the right hardware and bandwidth) given it was developed by experienced people that know how to come up with some creativity to get it there.  You won't get that kind of performance from beginners or people that don't understand a bit about web development, but in the end, once you know what to do/not do and how to drive the ASP.NET/CLR, you can make it scale as high as you want.<br /><br /><br />Thanks,<br />Shawn</div>
    <div class="meta">Posted on 2003-05-25 02:52:41 by _Shawn</div>
   </div>
   <div class="post" id="post-104745">
    <div class="subject"><a href="#post-104745">Why ASM?</a></div>
    <div class="body">Advantages of Assembly: It is there, it has been proven to work in programming computers... so use it when you need it.<br />Advantages of C/C++: It is there, it has been proven to work in programming computers... so use it when you need it.<br />Advantages of... I hope people get the pattern forming here :)</div>
    <div class="meta">Posted on 2003-05-25 13:21:51 by SpooK</div>
   </div>
   <div class="post" id="post-104778">
    <div class="subject"><a href="#post-104778">Why ASM?</a></div>
    <div class="body">Darwin can prove useful when talking about the merit of programming languages, but I still hate Visual Basic.</div>
    <div class="meta">Posted on 2003-05-25 22:42:59 by Paulicles the Philosopher</div>
   </div>
   <div class="post" id="post-104780">
    <div class="subject"><a href="#post-104780">Why ASM?</a></div>
    <div class="body"><div class="quote"><br />but I still hate Visual Basic. </div><br />I don't like VB either but, I don't hate it, I let them VB-programmers live their lives in sowrrow ;)</div>
    <div class="meta">Posted on 2003-05-25 23:19:02 by scientica</div>
   </div>
   <div class="post" id="post-104781">
    <div class="subject"><a href="#post-104781">Why ASM?</a></div>
    <div class="body">hehe, me and a friend of mine's been trying to convince each other to learn ASM/C++, he's a outstanding C++ coder, and i've decided i'm sticking to ASM, so there's been much dispute, etc. Our main topic was exe-sizes, but he had produced smaller exes than me (we worked on some project we had decided on, in ASM/C++), because i'm very inexperienced and tend to bloat code alot :(<br /><br />ASM is quite interesting actually, i don't see a single disadvantage compared to C++ besides a VERY standarized programming habits (although many different &quot;sects&quot; of such programming styles have already been formed :tongue: ), although many jobs might require C++, knowning ASM can be quite useful indeed. I've recently began to start and learn Borland Delphi, it's syntax i find to be alot more cleaner than that of VC++, and i can produce fast stuff, and save lots of time, when size isn't a problem.<br /><br />I also think VB is a piece of  :tongue: , it has the worst syntax i've seen, and it is incredibly unlike any other language in that it has terrible language structure, and aimed for store managers who don't have time to learn some complicated language. Although i'm not saying there aren't very talented VB coders out there, i personally wouldn't reccomend it for beginners either.<br /><br />If you learn one language quite well, be it C++/Pascal/ASM (the three most popular ones i know, at least for me and my friends), you can quite easily migrate to the other without too much problem!</div>
    <div class="meta">Posted on 2003-05-25 23:43:06 by Drocon</div>
   </div>
   <div class="post" id="post-105441">
    <div class="subject"><a href="#post-105441">Why ASM?</a></div>
    <div class="body"><div class="quote"><br />yes and you can do things wrong in Hlls to big things in HLLs<br />small things in assembly <br /><br />a human can pull back and look at the task at hand <br />a compiler can't do that <br />compillers have gotten a lot smarter BUT thay at there  <br />best look at one function at a time not the whole program <br />and no compiller will ever be smarter than a human<br />a compiller can't restrecuter the program the way a humen can <br />and useing an Hll the human cant see how restructureing<br />will help when it can help ( I'm not saying that it will always help)<br /><br /></div><br /><br />Take a look at GCC's output with -O3 enabled sometime.<br />It does some *very* impressive global optimizations.<br />Obviously, they are limited to the same source file, but I've seen it<br />replace a function call to some function (with nested function calls, too!)<br />with a single constant. Apparently, it computed the constant result that<br />the function would have computed and it did this at compile time.<br />It was very impressive, actually.<br /><br />The thing that makes this thread go on and on forever is that<br />humans and compilers are better at optimizing different things.<br />It's very easy to provide an example of where a compiler will (typically)<br />do better than a human coder and vice versa. The only constant in<br />this argument is that the human coder can always look at what the<br />compiler has done and mimic that, the compiler can't look at what the<br />human has done.  Then again, very few humans take the time to<br />write the code in some HLL *and* in assembly, so they rarely get<br />the opportunity to see how the compiler to do the same code they're<br />so proud of in assembly language.<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-05-30 15:21:03 by rhyde</div>
   </div>
   <div class="post" id="post-105444">
    <div class="subject"><a href="#post-105444">Why ASM?</a></div>
    <div class="body"><div class="quote"><br /><br /><br />One construct I like to use a lot (which I'm sure a lot of other MASM programmers use) is this:<br /><br /><pre><code><br />.repeat ; once<br />    . . .<br />    .break .if &#40;. . .&#41;<br />    .break .if &#40;. . .&#41;<br />    . . .<br />.until 1<br /></code></pre><br /><br />MASM generates <strong>no</strong> overhead for the .repeat loop, and the .break's are a great way of doing a structured downward goto. </div><br /><br />Wouldn't it be nice to have such a language construct built into the language so you don't have to deal with the confusion of misusing statements for purposes other than they are intended (e.g., using a repeat..until for something that is not a loop)?  This reminds of the C idiosyncrasy of using &quot;for(;;)&quot; to create an infinite loop.<br /><br />Wouldn't it be nicer to be able to say something like:<br /><br /><pre><code><br />begin block;<br />   .<br />   .<br />   .<br />   exitif&#40; --- &#41; block;<br />   .<br />   .<br />   .<br />end block;<br /></code></pre><br /><br />The reason for the labels, of course, is so that you can nest the blocks and branch out of any one of them. Still just as &quot;structured&quot; as your example and a little bit more readable and maintainable.<br /><br />HLA, of course, supports these kinds of structures. Now HLA's optimization is not as complete as MASM's (re: those phantom jumps), but it is improving. In return, however, HLA provides a whole set of additional control structures that advanced programmers would find useful, including an &quot;else&quot; attached to while loops and for loops (e.g., when the expression evaluates false, the else section executes; however, if you break out of the loop the else section does not execute, which is *very* useful for certain algorithms). HLA also provides true iterators and a foreach loop. Finally, HLA provides really cool macros that let you *easily* create your own nestable control structures when you decide to create your own control structure that HLA doesn't support (something MASM's macro facilities are not at all good for; the lack of this feature is why I wrote HLA in the first place).<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-05-30 15:33:56 by rhyde</div>
   </div>
   <div class="post" id="post-149679">
    <div class="subject"><a href="#post-149679">Why ASM?</a></div>
    <div class="body">:-D  I have 2 reasons :-D <br />1. <strong>I HATE CURVED BRACKETS !!!!!!!!!</strong><br />(it's very important to me :)<br />2. asm is WYSIWYG lang: if you place <strong>push</strong> in your source - you will see <strong>push</strong> also in the debugger instead of <strong>_call_PushSubInDllOfUnlnownAuther</strong><br />it is enought for me ;)<br /><br />edit:<br />oh, not enought!<br />3. i also hate to remember all synonims of dd  :-D</div>
    <div class="meta">Posted on 2004-09-13 08:52:42 by Shoo</div>
   </div>
   <div class="post" id="post-149681">
    <div class="subject"><a href="#post-149681">Why ASM?</a></div>
    <div class="body">lol  I thought I was the only one to <strong>hate</strong> those curly brackets :grin:</div>
    <div class="meta">Posted on 2004-09-13 09:12:36 by Ultrano</div>
   </div>
   <div class="post" id="post-150501">
    <div class="subject"><a href="#post-150501">Why ASM?</a></div>
    <div class="body">nope, I too must confess a personal distaste toward those hideous, grotesque, gnarled and twisted brackets - they are visually displeasing, and they remind me of math - ewww !!</div>
    <div class="meta">Posted on 2004-09-26 02:40:23 by Homer</div>
   </div>
   <div class="post" id="post-150535">
    <div class="subject"><a href="#post-150535">Why ASM?</a></div>
    <div class="body">I as well hate curly brackets, they get in the way of my spaghetti code. And as a fat guy, I must say I love my spaghetti! :-D <br /><br />Regards,<br />Bryant Keller</div>
    <div class="meta">Posted on 2004-09-26 17:09:49 by Synfire</div>
   </div>
   <div class="post" id="post-150541">
    <div class="subject"><a href="#post-150541">Why ASM?</a></div>
    <div class="body">I may suggest we start an anti-curly-brackets movement :)<br /><br />Someone mentioned here early that writing application in asm will take much more time than the same task in HLL. However people tend to exaggerate. Does it really worth it to avoid some more hours of coding just to get the thing completed faster (unless one have some short deadline).<br /><br />Let's say someone writes a bunch of utilities to help him with project compilation. Of course it's written in C. Who ever will bother to do that in asm, when those utilities are only used at compiler time and not included in final project. But what if project becomes pretty huge and those utils total execution time takes 5% of overall compilation time. (imagine how much time can be saved with asm optimizations when overall compilation takes about 1 hour and done five times a day) Is the low level language still should be avoided ?<br /><br /><br />p.s this post isn't supposed to be one of those 'the assembler is better than hll' flamestarters. But rather a though about how one can manage himself one more coffee break by optimizing some, at a first sight, optimization unnecessary code :)</div>
    <div class="meta">Posted on 2004-09-26 19:05:48 by arafel</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=11227&amp;page=1" style="">&laquo;</a><a href="../?id=11227&amp;page=4" style="">&lt;</a><input type="hidden" name="id" value="11227" /><input type="number" name="page" min="1" max="6" step="1" value="5" onchange="this.form.submit();" /><a href="../?id=11227&amp;page=6">&gt;</a><a href="../?id=11227&amp;page=6">&raquo;</a></form>  </div>
 </body>
</html>