<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Extension of the Boyer-Moore search algorithm - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19562" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=19562">Extension of the Boyer-Moore search algorithm</a></p>
   <div class="post" id="post-150668">
    <div class="subject"><a href="#post-150668">Extension of the Boyer-Moore search algorithm</a></div>
    <div class="body">Hello everyone - first time poster, long time lurker :) You guys started me off asm'ing and hopefully will help me here! <br />I love the Boyer-Moore search algorithm - and originally found it on Jeremy Collake's site - http://www.collakesoftware.com, but I was wondering if it were to be possible to write an extension of this algorithm that would be able to search the same file with many strings (that aren't necessarily the same length). Right now, my file searcher program (making a Windows file searcher - can search thru the whole system for strings in any kind of file) takes out all of the binary junk from files (non-ascii chars) and searches each file for hundreds of words (specified by the user). It seems incredibly pointless to have to keep generating the table (some of the files that it searches are 10 megs in size). I cant figure this out - but maybe someone could: How could you search thru the same file for hundreds of strings faster than having to re-call the proc each time?<br />Thanks for your time everyone! (and I won't say thanks in advance cause that really ticks me off when people say that to me :D)<br />-GNUru</div>
    <div class="meta">Posted on 2004-09-29 18:45:21 by GNUru</div>
   </div>
   <div class="post" id="post-150679">
    <div class="subject"><a href="#post-150679">Extension of the Boyer-Moore search algorithm</a></div>
    <div class="body">GNUru,<br /><br />The basic design of the BM family of pattern matching algorithms is setting up the tables for the word/phrase/byte sequence being searched for. There are other designs but with any reasonable length pattern, the BM algos will eat the rest alive.<br /><br />If the source being searched is over about 1k and the pattern is over 6 characters, the advantage starts to show. The longer the search pattern, the faster the search is. If you can set it up that way, always look for the longest pattern rather than a subset of it as it will increase the speed by a lot.<br /><br />There are 3 seperate BM search algos in the MASM32 library that were based directly off Bob Boyers original research work. One of the members here also published a BM algo in the APJ under the name of BuliaNaza.<br /><br />With Jeremy Collake's version, this gives you 5 to play with.</div>
    <div class="meta">Posted on 2004-09-29 23:43:17 by hutch--</div>
   </div>
   <div class="post" id="post-150683">
    <div class="subject"><a href="#post-150683">Extension of the Boyer-Moore search algorithm</a></div>
    <div class="body">While the Boyer-Moore algorithm (and it's many variants) is a very good choice for searching for a single string, it is not always the best choice for searching for any of a set of strings.<br /><br />If you have a moderately large set of search patterns, it's often worth the extra preprocessing of a more advanced data structure like e.g. in the Aho-Corasick algorithm :alright:.</div>
    <div class="meta">Posted on 2004-09-30 02:49:37 by Jibz</div>
   </div>
   <div class="post" id="post-150684">
    <div class="subject"><a href="#post-150684">Extension of the Boyer-Moore search algorithm</a></div>
    <div class="body">GNUru, as a first step it's reasonably straightforward to split an existing BM algorithm in two parts: table-gen and the actual search. This probably won't save you that much time though - if you have hundreds of search strings, consider Jibz' advice.</div>
    <div class="meta">Posted on 2004-09-30 03:20:23 by f0dder</div>
   </div>
   <div class="post" id="post-150689">
    <div class="subject"><a href="#post-150689">Extension of the Boyer-Moore search algorithm</a></div>
    <div class="body">Thanks for the responses! :)<br />I have been searching around on google for a while, and can only find a good implementation of the Aho-Corasick search algorithm in ClamAV Antivirus. (And that is in C++). Am I going to have to make a C++ dll and call it from asm or is there any asm code out there that I cant find?<br />See ya!<br />-GNUru</div>
    <div class="meta">Posted on 2004-09-30 06:24:33 by GNUru</div>
   </div>
   <div class="post" id="post-150741">
    <div class="subject"><a href="#post-150741">Extension of the Boyer-Moore search algorithm</a></div>
    <div class="body"><strong>GNUru,</strong> :-D <br />I agree with <strong> f0dder</strong> here:<strong><br />&quot;as a first step it's reasonably straightforward to split an existing BM algorithm in two parts: table-gen and the actual search.&quot;</strong><br /><br />and disagree with:<strong><br /><br />&quot;This probably won't save you that much time though - if you have hundreds of search strings, consider Jibz' advice.&quot;</strong><br /><br />Here is my idea: :wink: <br />- If we have 200 search strings, we need to initialize <strong>once</strong> 200 skip tables with 256 dwords each<br />- next we need to start <strong>once</strong> a program which will generate in memory another speed optimized program<br /> (search part of BM) as the followng example<br />- we will execute speed optimized program  (search part of BM) when we read every file in a the buffer  <br /><strong><br />Example:   (search part of BM)</strong><pre><code><br />;       403120  B87A563412      mov     eax,1234567Ah   ;eax-&gt;end of the buffer<br />;       403125  EB09            jmp     403130<br />;BeginOR1&#58;       ; Search 1st string = &quot;654321&quot; with length 6<br />;       403130  8B0B            mov     ecx,0EF123456h         ;ecx-&gt;current negative offset in the buffer<br />;       403140  0FB61408        movzx   edx,byte ptr &#91;eax+ecx&#93; ;edx-&gt;next byte from the buffer<br />;       403144  2B0C957C563412  sub     ecx,dword ptr &#91;edx*4+1234567Ch&#93; ;1234567Ch-&gt;SkipTable 1<br />;       40314B  72F3            jb      403140<br />;       40314D  83C101          add     ecx, 1	<br />;       403150  7F2E            jg      403180  ;Not found-&gt;Go to next string-&gt;BeginOR2&#58;	<br />;       403152  807C08FA36      cmp     byte ptr &#91;eax+ecx-6&#93;,36h ;1st byte of the 1st string<br />;       403157  75E7            jne     403140<br />;       403159  807C08FB35      cmp     byte ptr &#91;eax+ecx-5&#93;,35h ;2nd byte of the 1st string<br />;       40315E  75E0            jne     403140<br />;       403160  807C08FC34      cmp     byte ptr&#91;eax+ecx-4&#93;,34h ;3rd byte of the 1st string<br />;       403165  75D9            jne     403140<br />;       403167  807C08FD33      cmp     byte ptr &#91;eax+ecx-3&#93;,33h ;4th byte of the 1st string<br />;       40316C  75D2            jne     403140<br />;       40316E  807C08FE32      cmp     byte ptr &#91;eax+ecx-2&#93;,32h ;5th byte of the 1st string<br />;       403173  75CB            jne     403140	<br />;       403178  EB56            jmp     4031D0 ;Label Found<br />;BeginOR2&#58;      ;Search 2nd string=&quot;97821&quot; with length 5<br />;       403180  8B0B            mov     ecx,0EF453456h ;ecx-&gt;current negative offset in the buffer	<br />;       403190  0FB61408        movzx   edx,byte ptr&#91;eax+ecx&#93; ;edx-&gt;next byte from the buffer<br />;       403194  2B0C957D563412  sub     ecx,dword ptr&#91;edx*4+1234567Dh&#93; ;1234567Dh-&gt;Skip Table2<br />;       40319B  72F3            jb      403190<br />;       40319D  83C101          add     ecx,1<br />;       4031A0  7F1E            jg      4031C0 ;4031C0-&gt;Label NotFound<br />;       4031A2  807C08FB39      cmp     byte ptr &#91;eax+ecx-5&#93;,39h ;1st byte of the 2nd string<br />;       4031A7  75E7            jne     403190<br />;       4031A9  807C08FC37      cmp     byte ptr &#91;eax+ecx-4&#93;,37h ;2nd byte of the 2nd string<br />;       4031AE  75E0            jne     403190<br />;       4031B0  807C08FD38      cmp     byte ptr &#91;eax+ecx-3&#93;,38h ;3rd byte of the 2nd string<br />;       4031B5  75D9            jne     403190<br />;       4031B7  807C08FE32      cmp     byte ptr &#91;eax+ecx-2&#93;,32h ;4th byte of the 2nd string<br />;       4031BC  75D2            jne     403190<br />;       4031BE  EB10            jmp     4031D0 ;Label Found<br />;....<br />;....	; Search 200th string = &quot;.......&quot;<br />;BeginOR200&#58;</code></pre><br /><br /><strong>Note:</strong><br />	mov eax,1234567Ah	; eax-&gt;end of the buffer<br />	mov ecx, 0EF123456h ; ecx-&gt; current negative offset in the buffer<br /><br />	so when we start the search:<br /> <br />	(eax+ecx) = address of the buffer + 5 for the 1st string with length 6<br />	(eax+ecx) = address of the buffer + 4 for the 2nd string with length 5<br />	<br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2004-10-01 00:41:31 by lingo12</div>
   </div>
   <div class="post" id="post-150750">
    <div class="subject"><a href="#post-150750">Extension of the Boyer-Moore search algorithm</a></div>
    <div class="body">Lingo's idea is an interesting one although it is not a simple task to initialise so many character tables but it needs to be kept in mind that the cycle count of initialising a 256 member table is relatively low and the data is cache local once this is done so you have no other table loading overheads once it is initialised in a conventional BM implimentation.<br /><br />Now repeatedly scanning a file that is already in memory is far faster than the first time it is scanned and back when I worked on this algo design on a PIII long patterns (128 characters and up) were scanning at over 1 gig a second when testing on a large word or data count against the source.<br /><br />Its well known that no single search algo will do everything well so knowing something about the data being scanned is necessary. With short patterns (&lt; 6 characters) a linear scanner is probably very hard to beat as they still only branch test on a 1st character match and the rest is direct byte scan speed.<br /><br />If you do go in the direction of a BM algo, try for a design that has the full heuristics designed by Bob Boyer and not just a cut down version as the full design as it is a lot more flexible in the source data it can handle than either of the main variations.<br /><br />Here is the page I put up a few years ago to explain how the basics of a BM algo work.<br /><br />http://www.movsd.com/bm.htm<br /><br />I don't know much about the design that Jibz mentioned but the little I could find on it says it scans in linear time where a BM beats linear time in almost all instances except quadratic ones where the data and pattern size don't suit the design.</div>
    <div class="meta">Posted on 2004-10-01 05:42:28 by hutch--</div>
   </div>
   <div class="post" id="post-150753">
    <div class="subject"><a href="#post-150753">Extension of the Boyer-Moore search algorithm</a></div>
    <div class="body">Hm, I &quot;think&quot; I understand that example code. One (or more) question - <br />I just need to build the table for each string, and then replace edi with  (if I set up an array of DWORDS) (in the collake example - it is a 256 byte structure - a DWORD would be able to point to that correct?)<br /><br />Here is the original function if you do not know the original one I am working with. <br />If someone has a faster version - or a simpler one - :) - Pls send :D<br /><pre><code><br />BMTABLE STRUCT<br />    dd 256 dup&#40;0&#41;<br />BMTABLE ENDS<br />RevStrCmp MACRO<br />LOCAL RevStrCmpLoop,RevStrCmpEnd<br />        dec     ecx<br />        jz      RevStrCmpEnd<br />RevStrCmpLoop&#58;  <br />        dec     esi<br />        dec     ebx     <br />        mov     al,byte ptr &#91;esi&#93;<br />        cmp     al,byte ptr &#91;ebx&#93;<br />        jnz     RevStrCmpEnd    <br />        dec     ecx<br />        jnz     RevStrCmpLoop<br />RevStrCmpEnd&#58;           <br />ENDM<br />BMBinBin proc uses ebx edi esi pData1&#58;DWORD, Data1Len&#58;DWORD,<br />                               pData2&#58;DWORD, Data2Len&#58;DWORD<br />           <br />        LOCAL   EndOfData&#58;DWORD<br />        LOCAL	bm_table&#58;BMTABLE<br />        <br />        mov     eax,pData1<br />        add     eax,Data1Len<br />        mov     EndOfData,eax   <br />                                   <br />        lea     edi,bm_table            <br />        push    edi<br />        mov     eax,Data2Len<br />        mov     ecx,256<br />stosd_loop&#58;        <br />        mov     &#91;edi&#93;,eax        <br />        add     edi,4<br />        dec     ecx        <br />        jnz     stosd_loop                <br />        pop     edi     <br /><br />        mov     ecx,eax<br />        push    eax<br />        dec     ecx<br />        mov     esi,pData2<br />        push    edi<br />        xor     eax,eax<br />FillTableLoop&#58;  <br />        mov     al,byte ptr &#91;esi&#93;<br />        inc     esi<br />        mov     dword ptr &#91;edi+&#40;eax*4&#41;&#93;,ecx<br />        dec     ecx<br />        jns     FillTableLoop<br />        <br />        pop     edi     ; edi-&gt;bm_table<br />        pop     ecx     ; ecx=size of string<br />        mov     esi,pData1<br />        mov     ebx,pData2 <br />        dec     ecx<br />        add     ebx,ecx<br />        add     esi,ecx <br />        mov     edx,EndOfData<br /><br />        <br />MainSearchLoop&#58; <br />        xor     eax,eax<br />        mov     al,byte ptr &#91;esi&#93;<br />        mov     ecx,dword ptr &#91;edi+&#40;eax*4&#41;&#93;<br />        test    ecx,ecx<br />        jz      strcmp   <br />        add     esi,ecx<br />NextIteration&#58;<br />        cmp     esi,edx<br />        jbe     MainSearchLoop<br />        jmp     ReturnNotFound<br />        <br />strcmp&#58;                          <br />        push    ebx<br />        push    esi<br />        mov     ecx,Data2Len<br />        RevStrCmp<br />        jz      ReturnFound<br />        pop     esi<br />        pop     ebx<br />        inc     esi     <br />        jmp     NextIteration<br />        <br />ReturnFound&#58;        <br />        pop     ebx     <br />        mov     eax,esi        <br />        pop     esi     <br />        ret<br />        <br />ReturnNotFound&#58; <br />        xor     eax,eax<br />        ret<br />BMBinBin endp<br /></code></pre><br />-GNUru</div>
    <div class="meta">Posted on 2004-10-01 05:47:01 by GNUru</div>
   </div>
   <div class="post" id="post-150754">
    <div class="subject"><a href="#post-150754">Extension of the Boyer-Moore search algorithm</a></div>
    <div class="body">Didn't see your new post hutch :) Maybe I should load multiple files at a time - until I get up to, say, 20 megs, then I can search them all - and based on the position of the offset of the string, determine which file it is in. (Could speed it up...)<br />-GNUru</div>
    <div class="meta">Posted on 2004-10-01 05:49:21 by GNUru</div>
   </div>
   <div class="post" id="post-150755">
    <div class="subject"><a href="#post-150755">Extension of the Boyer-Moore search algorithm</a></div>
    <div class="body">Eh, scratch the multiple files idea - it seemed good on paper, but keeping track of 500 some strings per file would be nuts.<br />Was also wondering - am I going to have to GlobalAlloc memory for each string and save the return of GA to an array of dwords? I am reading all of these strings from an external file. <br />Or..<br />Do I save an array of the actual strings (they are all less than 100 chars long - not many words are more than 100 chars :D) into a large buffer (100*500 or something), and address the actual strings from the buffer? <br />This may be easier to manage.<br />Aho-Corsaik - from the example I found - is slower than Boyer Moore...  <br />-GNUru</div>
    <div class="meta">Posted on 2004-10-01 06:38:02 by GNUru</div>
   </div>
   <div class="post" id="post-150756">
    <div class="subject"><a href="#post-150756">Extension of the Boyer-Moore search algorithm</a></div>
    <div class="body"><div class="quote"><br />I don't know much about the design that Jibz mentioned but the little I could find on it says it scans in linear time where a BM beats linear time in almost all instances except quadratic ones where the data and pattern size don't suit the design.</div><br />Yes, the Aho-Corasick algorithm is linear, and BM is (potentially) sub-linear. However AC is linear no matter how many strings you fill into it, while BM is a sub-linear application for each string.<br /><br />Of course it requires a certain volume of search patterns before it's worth the extra complexity of building the more advanced data structure, so it depends on the problem at hand which is the best choice :).</div>
    <div class="meta">Posted on 2004-10-01 07:24:07 by Jibz</div>
   </div>
   <div class="post" id="post-150761">
    <div class="subject"><a href="#post-150761">Extension of the Boyer-Moore search algorithm</a></div>
    <div class="body">Jibz,<br /><br />It actually sounds like an interesting capacity in a search algo, I know basically how to do large word list searches using a hash table and you use the same technique for doing large count word relacements but it suffers the hash table build time and it must scan the source in a linear manner to recognise each word.<br /><br />With the BM implimentations, as long as the data is not ordered in a very unusual way, average case times on patterns long enough (&gt; 6 characters) become very sublinear with the increase in pattern length so in the majority of cases it is a lot faster than a linear search technique. Also the first scan is the slowest, repeat scans on a source already in memory are much faster for basically hardware reasons.<br /><br />Another factor I have learnt with search algos is how fast they are rather than the linearity theory as you can have sublinear algos that are just plain slow if the overhead to deliver the sublinearity is high. With a conventional byte scanner, the recovery time from mismatch effects the overall performance a lot so you try for low overhead comparison branches.<br /><br />A BM is a more complex algo in its operation but the jump from each mismatch is a lot faster than simply scanning the source and it picks up speed by the number of characters it does not scan.<br /><br />The new design sounds interesting but I have not seen enough technical data on it to know what it does yet.</div>
    <div class="meta">Posted on 2004-10-01 11:25:16 by hutch--</div>
   </div>
   <div class="post" id="post-150781">
    <div class="subject"><a href="#post-150781">Extension of the Boyer-Moore search algorithm</a></div>
    <div class="body">GAH - guys - can anyone help me with seperating the Boyer Moore function? Everything I try fails miserably :) Hutch - Im sure that this would be a good feature in the Masm32Lib; 'AddSearchString', and 'SearchBufferForStrings'.<br />-GNUru</div>
    <div class="meta">Posted on 2004-10-01 20:24:26 by GNUru</div>
   </div>
   <div class="post" id="post-153377">
    <div class="subject"><a href="#post-153377">Extension of the Boyer-Moore search algorithm</a></div>
    <div class="body">I realize this is an old thread, but I figured better late than never.  Here is my implementation of the simplified BM algorithm:<br /><pre><code><br />; The Boyer-Moore table generator<br />bmTable proc uses esi edi pBytes&#58;DWORD, byteLen&#58;DWORD, pTable&#58;DWORD<br /><br />  mov       eax, byteLen<br />  mov       ebx, pTable<br />  mov       ecx, 256<br />  LEN_FILL_LOOP&#58;<br />    mov     DWORD PTR &#91;ebx&#93;, eax<br />    add     ebx, 4<br />    sub     ecx, 1<br />  jnz       LEN_FILL_LOOP<br /><br />  mov       ecx, 0<br />  mov       edx, byteLen<br />  sub       edx, 1<br />  JMP_FILL_LOOP&#58;<br />    mov     ebx, byteLen<br />    sub     ebx, ecx<br />    sub     ebx, 1<br /><br />    mov     eax, pBytes<br />    add     eax, ecx<br />    movzx   eax, BYTE PTR &#91;eax&#93;<br />    shl     eax, 2<br />    add     eax, pTable<br />    mov     DWORD PTR &#91;eax&#93;, ebx<br /><br />    add     ecx, 1<br />    cmp     ecx, edx<br />  jl        JMP_FILL_LOOP<br /><br />  ret<br />bmTable endp<br /></code></pre><br /><pre><code><br />; The Boyer-Moore search algorithm<br />bmSearch proc uses esi edi pMemory&#58;DWORD, memLen&#58;DWORD, pBytes&#58;DWORD, byteLen&#58;DWORD, pTable&#58;DWORD<br />  LOCAL memEnd&#58;DWORD, byteEnd&#58;DWORD<br /><br />  mov           eax, pMemory<br />  add           eax, memLen<br />  sub           eax, 1<br />  mov           memEnd, eax<br />  mov           eax, pBytes<br />  add           eax, byteLen<br />  sub           eax, 1<br />  mov           byteEnd, eax<br /><br />  mov           esi, pMemory<br />  add           esi, byteLen<br /><br />  SEARCH_LOOP&#58;  <br />    push        esi<br />    mov         edi, byteEnd<br />    <br />    SEARCH_NEXT_BIT&#58;<br />      sub       esi, 1<br />      movzx     eax, BYTE PTR &#91;esi&#93;<br />      movzx     ebx, BYTE PTR &#91;edi&#93;<br /><br />      cmp       eax, ebx<br />      jne       SEARCH_DONE			; bytes don't match<br />      sub       edi, 1<br />      cmp       edi, pBytes<br />      jge       SEARCH_NEXT_BIT		; haven't reached the beginning of pBytes<br /><br />      sub       esi, pMemory<br />      mov       eax, esi<br />      pop       esi<br />      ret<br />      <br />    SEARCH_DONE&#58;<br />        <br />    shl         eax, 2<br />    add         eax, pTable<br />    mov         eax, DWORD PTR &#91;eax&#93;<br />    pop         esi<br />    add         esi, eax<br />    cmp         esi, memEnd<br />  jl            SEARCH_LOOP<br /><br />  or            eax, 0FFFFFFFFh<br />  ret<br />bmSearch endp<br /></code></pre><br /><br />These function assume that your alphabet is the ASCII alphabet [0,FFh] and that the length of the search string is &lt;= FFFFFFFFh bytes.  The search function returns the offset to the beginning of the search string from the beginning of the memory block to be searched or FFFFFFFFh if it is not found.<br /><br />My table is usualy declared as<br /><pre><code><br />searchTable DWORD 256 DUP&#40;?&#41;<br /></code></pre><br />but if you know you're only going to be searching for keyboard charcters then it can be quite a bit smaller and still work.<br /><br />I hope that helps someone.<br /><br />Spara</div>
    <div class="meta">Posted on 2004-11-22 17:19:46 by Sparafusile</div>
   </div>
   <div class="post" id="post-153560">
    <div class="subject"><a href="#post-153560">Thanks!</a></div>
    <div class="body">Thanks for the algo :)</div>
    <div class="meta">Posted on 2004-12-01 19:24:42 by GNUru</div>
   </div>
  </div>
 </body>
</html>