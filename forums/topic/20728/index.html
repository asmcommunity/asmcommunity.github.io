<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Mesh Loader/Optimizer OBJ format - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20728" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=20728">Mesh Loader/Optimizer OBJ format</a></p>
   <div class="post" id="post-157864">
    <div class="subject"><a href="#post-157864">Mesh Loader/Optimizer OBJ format</a></div>
    <div class="body">I&#39;ve completed an importer for OBJ files.<br />Since its an ascii file format, it&#39;s a glorified plaintext parser.<br /><br />During loading, I take the time to create an array of &quot;unique 3D values&quot;.<br />For vertex positions and vertex normals, I firstly add them to this &quot;global array of uniques&quot;, noting the returned index (new or existing), which I associate with the &quot;raw 3D value&quot; before stowing it as well.<br />eg I use a Vec4 to store a Vec3, with the W field containing the unique index of that Vec3 value.<br />After loading is completed, I go through the FACES, replacing existing &quot;raw&quot; indices with the &quot;unique indices&quot; I stored earlier. Finally, I throw away the &quot;raw&quot; arrays for positions and normals.<br />Thus I have eliminated duplication of Vec3 values through reindexing to an array free of duplicates, and have done so with the absolute minimum of effort.<br /><br />In my testbed example, I have a 3D textured cube with some 300 indexed faces, comprised of : 152 raw vertices and 216 raw normals. Seems already optimized? Guess again. Of these total 368 values, 158 are unique. After reindexing, my highest index is 157 (0-based).<br />We could, if we wanted to, save the optimized mesh at this point, and it would always be valid.<br /><br />We can load more models and achieve logarithmic savings, but care must be taken. <br />We must note that this optimisation is runtime only.<br />If we load several models in this fashion, any common values will show up and be optimized out of existance, but are only valid in the context of each other - we shouldn&#39;t save models if &gt;1 model is loaded. We can&#39;t rely on the uniques array in such conditions, as we can&#39;t be sure that the indices will always be sane... <br /><br />I&#39;ve uploaded a copy of the binary and OBJ files to http://homer.ultrano.com/Upload/BSPGenerator.zip<br />After running the executable, a textfile has been created to log runtime events.<br />Compare it to the OBJ file :)<br />I will provide full source on request.<br /><br /></div>
    <div class="meta">Posted on 2005-03-10 20:26:45 by Homer</div>
   </div>
   <div class="post" id="post-157920">
    <div class="subject"><a href="#post-157920">Re: Mesh Loader/Optimizer OBJ format</a></div>
    <div class="body">I&#39;ve added code to calculate SurfaceNormals from Triangle Vertices, as well as &quot;ClassifyPoint&quot; procedure and a loop to test each triangle&#39;s plane against an arbitrary 3d point.<br />ClassifyPoint compares a 3D point to a Plane (given as a PointOnPlane and SurfaceNormal).<br />It tells you whether the point is (behind, infront of, smack on) the Plane.<br />I&#39;ve written the driver procedures for my BSPTree Generator.<br />The Generator relies heavily on the ClassifyPoint procedure, so it was important to test it well.<br />Another procedure used heavily by the Generator is &quot;SplitPolygon&quot;.<br />It&#39;s name is misleading, it classifies a Triangle and a Plane, by calling ClassifyPoint for each Triangle Vertex.<br />It can do more, but I&#39;ll keep this simple.<br />The Generator uses a procedure called &quot;SelectPartitionFromList&quot; to choose the best Splitting Plane for each node of the BSP Tree. In essence this amounts to classifying (every triangle) against the Plane of (every other triangle), and deciding which triangle&#39;s plane creates the fewest splits while also dividing the geometry most evenly across the plane.<br />Having decided which is the best triangle&#39;s plane to use, the world is split across that plane into two subworlds (lists of triangles), and this is repeated until no triangles remain.<br /><br /></div>
    <div class="meta">Posted on 2005-03-14 09:31:58 by Homer</div>
   </div>
   <div class="post" id="post-157928">
    <div class="subject"><a href="#post-157928">Re: Mesh Loader/Optimizer OBJ format</a></div>
    <div class="body">Some time ago you asked in another thread what 3D formats we use for animation. I&#39;ve been researching on this a lot and came to some conclusions (which might not be correct, I am a newbie in 3D). And I might not be able to fully express myself. But hey, here&#39;s my 2 cents: <br /><br /><strong>.obj (WaveFront) : </strong><br />Pros:<br /><ul><br /><li>Easy to convert to your own binary format. Though, it&#39;s not very nice to have to make your own binary format </li><br /><li>Supports non-textured polys (a big pro for my software engine btw)</li><br /></ul><br />Cons:<br /><ul><br /><li>The syntax can become hell when lots of options are added to faces - vertex normals, texture coords, more than 3 vertices..... Expandability is not always a good thing. </li><br /><li>Not all 3D modelers make an .mtl file to define materials - and thus you have to make this manually. Actually I&#39;ve seen this file generated only by a non-modeler app (a 3D converter) !</li><br /><li>Animation is impossible. Unless you divide your model to different meshes, then in your converter bind them together with some bones.... I don&#39;t think many people would try this. </li><br /><li>Texture blending (additive/normal/subtractive...)- I have never seen it available here</li><br /></ul><br /><br /><strong>.md2 (Quake2) :</strong><br />Pros:<br /><ul><br /><li>Extremely easy to convert/import</li><br /><li>If you don&#39;t care to spend a few more kB RAM, and if you want lots of CPU - this is your choice. Textures take much more memory anyway.</li><br /><li>Normals are already computed (though you might need to convert them a bit on loadtime)</li><br /><li>Animation can be very fluid if you want. You might be able to interpolate between keyframes, I think. Unnormal stuff (usually morphing) is really easy to implement here - like a ball morphing into a cube, a ship exploding into tiny polys,...you name it</li><br /><li>Support for texture-blending commands (iirc, but have never seen it explicitly)</li><br /><li>Almost all modelers, converters and animators support this - either natively or via a plugin</li><br /></ul><br />Cons:<br /><ul><br /><li><span class="strike">RAM usage</span> - not a problem anymore, no gamer has less than 256MB anyway, and I doubt gamedevelopers will soon use thousands of different animated models to make this a difference</li><br /><li>Animation is not well-suited for organic or humanoid models. It&#39;ll be a feat to make fluid, reallistically-looking human actions</li><br /><li>No support for non-textured polys, though it is not so useful anyway these days. And you can do the trick via tricks with UVmapping</li><br /></ul><br /><br /><br /><strong>.mdl (halflife) :</strong><br />note: I am not sure, but I think .x files are really similar. I have to check this soon, I looked at .x files much earlier than I learnt what a mesh is lol<br />Pros:<br /><ul><br /><li>Fluid reallistic animation at your fingertips. This is the best what this format can give you, and this is the best format to give you this feature ^_^ </li><br /><li><span class="strike">less RAM</span> (not much of a difference though)</li><br /></ul><br />Cons:<br /><ul><br /><li>Lots of CPU needed for animation, compared to other methods. This is the drawback for getting such good animation</li><br /><li>Complexity of the animation part of your engine</li><br /><li>No freeware converter/modeler/animator that I know exports to this format. MilkShape3D is perfect for this job, but online shopping is not easily accessible to some people (like me), especially if the author(s) reject wire transfers</li><br /><li>uhm...has anyone here got the .mdl file format description?</li><br /></ul><br /><br /><br />It&#39;d be awesome to have a freeware/opensource animator that imports .obj/.md2, and saves to a file format that is a hybrid between md2 and mdl in the following way:<br />- assume we don&#39;t use face-normals.<br />- all is in one mesh <br />- each vertex is bound to one of the bones (not 0 or more than 1), forming mesh sub-groups. (like head, or chest). These sub-groups act like separate meshes, each as if imported from an .obj file. <br />- submeshes don&#39;t share vertices (just to make it clear from the start). Though, they can/will be connected with faces. (that&#39;s why I&#39;d like to put it all in one mesh)<br /><br />(basically, we skip the weight and bindings of vertices to many bones)<br /><br /><br />pros:<br />Faces that connect the sub-meshes can easily act as &quot;organic glue&quot;.<br />Engine is as easy as it can get, animating from the current state to a state we have to smoothly transform is also a piece of cake. <br />This animation format saves a lot of cpu, but some ugly distortions will arise in cases when rotation angle between two glued sub-meshes (their bones actually)&nbsp; is more than pi/6. For example, a human model&#39;s neck - if we rotate the submesh &quot;head&quot; too much, the faces that connect it to the chest will deform (imagine we turn his head 180 degrees to the right). The faces here will basically form a fan. To fix this, we&#39;ll add a bone whose parent is the &quot;head&quot; bone, and in the animator we&#39;ll rotate this bone _manually_ . We&#39;ll cut the neck polys in half horizontally, to get more vertices there, and twice the polys. Bind the new vertices to the new bone, and to the manual animation ^^&quot;. <br />cons:<br />Can distort the object in unusual cases unless we manually prevent this on the modeling stage of the model animation creation. <br />Not so fluid animation as in .mdl<br /><br />From Scorpie&#39;s last topic I think MilkShape has support for such a format , yet I don&#39;t know how this format is called - and my trial period for that app is over now ^^&quot;<br /><br />my conclusion - if you can get your hands on a mdl-exporting animation app, mdl is worth trying<br />for garage games on my PDA, I&#39;d use md2 (and .obj for static meshes). <br /><br />comments and heavy critics welcome :)</div>
    <div class="meta">Posted on 2005-03-14 14:55:07 by Ultrano</div>
   </div>
   <div class="post" id="post-157935">
    <div class="subject"><a href="#post-157935">Re: Mesh Loader/Optimizer OBJ format</a></div>
    <div class="body">I&#39;ve decided that I no longer need to be concerned that I can&#39;t export to my favorite (or the latest) file formats directly from my favorite 3D modeller/animator tool.<br />I only have to be able to load the simplest and most universal of file formats, then I can write my own exporters, and/or my own file formats, in my own code.<br /><br />I stole this idea from the Quake console&#39;s ability to import non-native geometry files at runtime.<br /><br />If I recall correctly, I posted a document describing the md2, md3 and mdl file formats in detail, contrasting the differences.<br />Basically, md2 is ok for static objects, but it doesnt do animation very well.<br />It creates &quot;seams at the joints&quot; of your animations. It does however allow for a fully-segmented body that is easily &quot;blown to bits&quot;.<br />Md3 goes some way to remedying this by using bone animation to animate 2 or 3 bodyparts, so now the seams between joints are reduced to the joins between bodyparts (legs, torso, head).<br />But we lost the ability to blow the body into lots of pieces.<br /><br />Mdl format was derived from the short-lived md4 (I describe in post, link below) by the guys who developed Half-Life (Valve based their engine on the original Quake engine).<br />http://www.asmcommunity.net/board/index.php?topic=20031.0<br /><br />Here&#39;s a detailed expose on mdl format, I assume it&#39;s the same one but didn&#39;t verify:<br />http://astronomy.swin.edu.au/~pbourke/geomformats/mdl/<br /><br />Glad to see you showing interest in this stuff at last :)<br /><br /><br /></div>
    <div class="meta">Posted on 2005-03-14 21:06:06 by Homer</div>
   </div>
   <div class="post" id="post-157936">
    <div class="subject"><a href="#post-157936">Re: Mesh Loader/Optimizer OBJ format</a></div>
    <div class="body">My OBJ importer code currently does not handle Quads.<br />It expects that:<br />1&gt; The model has been Triangulated (contains triangles only)<br />2&gt; The model has PerVertex Normals (for really nice lighting)<br /><br />That means face descriptions look like:<br />f 1/1/1 2/2/2 3/3/3 (position/uv/normal for each triangle vertex)<br />and of course these are 1-based Indices into the respective arrays.<br />My loader compresses the position and normal array by creating<br />a single array free of duplications and reindexing the faces (0-based)<br />to match the indices in the new array.<br /><br />I could easily add support for Quads in the Loader, I just wanted instant gratification.<br />f 1/1/1 2/2/2 3/3/3 4/4/4 really represents two triangles as follows:<br />f 1/1/1 2/2/2 3/3/3<br />f 1/1/1 3/3/3 4/4/4<br /><br />I don&#39;t actually use the PerVertex Normals for anything yet (no render code), but I load them anyway.<br />I calculate PerSurface Normals from the Triangle Edges, rather than Average the PerVertex Normals, because it&#39;s more accurate (divide by three is nasty).<br /><br />I&#39;d like to get the BSPGen stuff working, then incorporate it into my existing Console framework.<br />Basically I&#39;m worrying more about the static part of the World at this time, rather than the (animated or not) object models which will eventually populate it.<br /></div>
    <div class="meta">Posted on 2005-03-14 21:17:10 by Homer</div>
   </div>
  </div>
 </body>
</html>