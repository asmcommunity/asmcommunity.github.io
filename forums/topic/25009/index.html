<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Getting Started in GameDev - a tutorial - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25009" />
    <link rel="next" href="../?id=25009&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25009">Getting Started in GameDev - a tutorial</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=25009&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=25009&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="25009" /><input type="number" name="page" min="1" max="5" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=25009&amp;page=2">&gt;</a><a href="../?id=25009&amp;page=5">&raquo;</a></form>   <div class="post" id="post-183123">
    <div class="subject"><a href="#post-183123">Getting Started in GameDev - a tutorial</a></div>
    <div class="body">I&#39;ve been asked many times recently to provide a tutorial for masm programmers wishing to write their own games.<br />As this tutorial grows, it will be cleaned up and posted online, and a URL will be provided in due course.<br /><br />These days it seems like everyone has an interest in game development.<br />Many people daydream of working in this industry, but most have no idea where to begin. The simple answer is that you MUST produce a demo.<br />If you can&#39;t produce a demo, nobody is going to listen to you, much less employ you. Your demo is evidence of your ability.<br /><br />Most game developers today write their sourcecode in C++ or some other object-oriented programming language.. It&#39;s not a requirement of the industry that you code strictly in C++, but it IS required that the code objects you create are compatible through the implementation of standard interfaces.<br /><br />In case you&#39;ve never heard of it, let me introduce you to ObjAsm32.<br />OA32 is a set of buildtime macros for MASM whose main purpose is to give the humble MASM programmer the ability to create and implement various kinds of standard interfaces, and to interact with existing object interfaces (regardless of the language they were written in).<br /><br />Throughout this tutorial you will learn how to write and use &#39;oop classes&#39; with respect to Game Development.<br />I choose to use the RadAsm IDE, but that is optional.<br /><br />The attached zip file contains a &quot;win32 skeleton&quot; sourcecode which provides a basis for the rest of this tutorial.<br /><br />If you haven&#39;t installed ObjAsm32, you should do so now.<br />If you haven&#39;t installed DebugCenter, you should do so now.<br />If you require assistance, ask and you shall receive.<br /><br />Having installed both of these, you may attempt to build the provided sourcecode.<br />If you successfully build this sourcecode, run the executable you created and confirm that DebugCenter is working properly.<br />If you fail to build this sourcecode, or you see strange error messages,&nbsp; please let me know, as your valuable feedback will become part of a FAQ aimed at resolving any &#39;teething problems&#39;.<br /><br />If you have any questions at all regarding the provided sourcecode, feel free to ask them, as there&#39;s no such thing as a stupid question (however there&#39;s a lot of stupid people!)<br /><br />If you wish to critize at any stage, I welcome your perspective.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1807" target="_blank">GameClient060708.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-07-08 01:14:02 by Homer</div>
   </div>
   <div class="post" id="post-183124">
    <div class="subject"><a href="#post-183124">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body"><br />The astute programmers among you might notice something odd in the sourcecode provided so far.. did you see it?<br />The variable called hInstance is referenced, but does not appear to have been declared... also, the usual call to obtain its value (GetModuleHandle,NULL) appears to be missing.. what&#39;s going on?<br /><br />The answer is found in the SysInit macro, which you can see is being used at the Program EntryPoint.<br />Among other things, this macro declares the hInstance variable, performs the call to GetModuleHandle, and stores the result in hInstance for us.<br /><br />&quot;Ahhh.. I see !!&quot; said the blind man.<br /></div>
    <div class="meta">Posted on 2006-07-08 01:31:33 by Homer</div>
   </div>
   <div class="post" id="post-183126">
    <div class="subject"><a href="#post-183126">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body"><br />Now we&#39;ve got a working Win32 Skeleton, it&#39;s time to decide which Graphics API (if any) we want to support.<br />In the attached sourcecode, I&#39;ve added a simple &#39;buildtime switch&#39; which lets you choose whether to use OpenGL, DirectX, or neither.<br /><br />In the name of simplicity, this tutorial will be aimed at DirectX (and in particular Direct3D).. however I will endeavour to support OpenGL to some extent.<br /><br />OpenGL and DirectX are both decent rendering engines, however DirectX supports other useful stuff like audio and networking, so for the purposes of writing a demo game, it&#39;s clearly the winner.<br />OpenGL is easier for beginners to use, because all its functionality is accessed through calls to procedures exported from a DLL.<br />DirectX on the other hand is implemented as a handful of procedures and a crapload of &#39;COM Interfaces&#39;.<br />The words &#39;COM&#39; and &#39;Interface&#39; are enough to strike fear into the heart of the average MASM user, but as we shall see, thanks to OA32, there&#39;s nothing to be afraid of at all.<br /><br />In any event, whether we decide to use OpenGL, DirectX, or even if we decide to provide our own rendering engine, we&#39;re going to need a Main Application Window, and we need to create it before we can do much at all.<br /><br />OpenGL and DirectX BOTH have startup code that REQUIRES a handle to an existing window.<br /><br />The next topic I&#39;ll be covering is the startup code for both Direct3D and OpenGL :)<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1808" target="_blank">GameClient_2.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-07-08 02:27:03 by Homer</div>
   </div>
   <div class="post" id="post-183136">
    <div class="subject"><a href="#post-183136">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body"><br />As indicated, our next step is to add some code to get either OpenGL or Direct3D started up (since we want to code modern 3D games, not old-fashioned 2D ones).<br /><br />The attached zip contains code to do exactly that.<br />Don&#39;t worry about the fact that nothing is being rendered in the application window yet.. <br />Have a play with the buildtime switches, and read what DebugCenter has to say when you run the executable.<br /><br />Above all, don&#39;t be put off by the rather complex-looking code required to start up Direct3D, as it&#39;s perhaps the most difficult thing we&#39;ll ever do.. and since I&#39;ve done it for you, relax !!<br />(Note : my example D3D9 startup code can be considered as &quot;intermediate level&quot;, since its not as simple as it CAN be, yet its nowhere CLOSE to as complex as it CAN be).<br /><br />Our next mission will be to add a simple Render procedure so that we can actually see SOMETHING in our Application window.<br />I&#39;ll be rendering to the entire app window, however it&#39;s possible to render to one or more Child windows (for example, to show multiple views of a 3D object), and it&#39;s also possible to render in &#39;fullscreen mode&#39; (I assume most gamers are familiar with the difference between Windowed and FullScreen modes).<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1810" target="_blank">GameClient_3.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-07-08 04:23:13 by Homer</div>
   </div>
   <div class="post" id="post-183138">
    <div class="subject"><a href="#post-183138">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body"><br />The attached zip contains code which renders BLACKNESS to the Rendering window (which just happens to be the Main App Window).<br />It&#39;s just proof that our OpenGL / Direct3D9 startup code is actually doing something :)<br /><br />Well, I think that will be enough for one day.<br />Tomorrow we can begin with some very simple rendering of &#39;polygonal primitives&#39;, and after that, I&#39;ll begin to pick up the pace a little :)<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1811" target="_blank">GameClient_4.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-07-08 05:06:39 by Homer</div>
   </div>
   <div class="post" id="post-183178">
    <div class="subject"><a href="#post-183178">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body">I&#39;m trying to appeal to the widest possible audience.<br />Some of you will feel I am going too fast, some will feel I am moving too slowly.. I&#39;m not going to please everyone.<br />Things will speed up considerably once I&#39;ve covered the basics, so if you find that I am leaving you in the dust, feel free to ask questions, and/or do a little research yourself.<br /><br />The attached update covers a LOT of ground.. and all it does is draw a colorful triangle.<br /><br />In terms of Direct3D, this is not exactly exciting.. but in terms of OpenGL, it&#39;s a Big Deal - because everything we want to draw in OGL is built from triangles. Strictly speaking, that&#39;s true of D3D as well, but D3D does a lot more of the gruntwork for us when it comes to rendering more complex objects. We&#39;ll get to that fairly soon.<br /><br />Even though I have included code to render a triangle for both OpenGL and Direct3D, I&#39;m going to confine the discussion of the sourcecode to the D3D version, since its more complex. <br /><br />The example D3D code defines a CUSTOM VERTEX. You can think of a Vertex as a Point in 3D space. Obviously, to make a Triangle, we need three of these.. I went on to describe a Triangle built from three such Vertices. <br />The Custom Vertex struct I described (MyVertex) is created from three REAL4 floating point values (Position XYZ) and one DWORD (Color ARGB).<br />In order for D3D to understand our Vertex Format, we have to also describe it in terms of some special D3D values OR&#39;d together in a single DWORD called the &quot;Vertex Descriptor&quot; (D3DFVF_CUSTOMVERTEX).<br />So, we&#39;ve described our Vertex Format in two ways : as a Struct, and as a combination of Flags.<br />We could just go ahead and Render the Triangle from user memory like the OpenGL code does, but I went even further.<br />In order to benefit from hardware acceleration, its necessary to allocate a &quot;Vertex Buffer&quot; and copy our actual Vertex data into it.<br />I&#39;ve provided the CreateTriangle procedure for this purpose.<br />This might seem redundant since we already defined our vertex data as global data (TestTri), but we&#39;re not simply duplicating the vertex data in memory, we&#39;re uploading it to the video card.<br />In a &#39;real&#39; demo, we would not create a VB just for one triangle - we&#39;d create a VB for a few hundred or even a few thousand Triangles, and if that wasn&#39;t large enough for all the Triangles we wanted to draw, we&#39;d treat it as a Page.. fill the VB, draw its contents, rinse and repeat.<br /><br />Let&#39;s talk about some of the other new stuff :)<br /><br />There&#39;s a few more new procedures worth mentioning.<br />&#39;ResizeScene&#39; sets up the Camera Perspective.<br />It&#39;s called once at the moment, but should be called whenever the render window is resized.<br />&#39;Initialize&#39; sets up the &#39;default Render States&#39;.<br />We&#39;ll learn more about Render States as we go.<br />&#39;Keyboard&#39; checks for various keyboard keypresses.<br />It supports &#39;key combinations&#39; (more than one simultaneous key).<br />I&#39;ve supplied the macros &#39;CheckKey&#39; and &#39;CheckKeyCombo&#39; as helpers.<br />Note that I&#39;ve chosen NOT to use DirectX&#39;s DirectInput to check the keyboard, the way I chose works for both DX and OGL.<br /><br />The Render procedure was modified to include code to draw a Triangle. The D3D code draws one or more triangles in a VertexBuffer (as a TriangleList), while the OGL code draws one or more triangles from explicit values (as a TriangleList).<br /><br />The only other feature worth mentioning is the Translation being applied during the Render procedure.<br />Our triangle is designed in the XY plane, at Z=0<br />Problem: our Camera is located at &lt;0,0,0&gt;<br />In order to SEE the Triangle, we either have to move the Camera backwards, or move the Triangle forwards.<br />The D3D code creates a Translation Matrix which contains the values &lt;0,0,+5&gt;, which is used to position our Triangle in the World at &lt;0,0,-5&gt; (I&#39;ve explained in another thread how this works and why the sign appears to have flipped).<br />The OGL code achieves the same thing via a call to glTranslate, but takes the Camera-relative coordinates &lt;0,0,-5&gt; instead of the World-relative position &lt;0,0,+5).<br />In actuality, the D3D translation matrix function internally flips the signs and so the way OGL works is more algorithmically efficient.<br /><br />You might notice that the Main Loop is starting to take shape.<br />It&#39;s not just a MessagePump loop anymore.<br />Eventually the time will come when GetMessage doesn&#39;t cut it.<br />We&#39;ll either have to write a smarter MessagePump, or we can drive our Render proc from a separate thread.<br /><br />In the next exciting episode, we&#39;ll learn how to construct a Quad from two Triangles (OpenGL supports Quads as Primitives, D3D does not).<br />After that we&#39;ll learn how to load and apply Textures from image files, how to render a &#39;Billboard&#39;, etc.<br />At that stage we&#39;ll be ready to create a static &#39;Loading&#39; screen, add code to make our render function stateful (eg so we can render the Loading screen or the Menu screen or the actual Game etc), there&#39;s a lot of ground to cover, so I want to start introducing GameDev concepts as soon as possible.. lighting, mesh models and stuff can wait.<br /><br />I can already see some interest in this thread.<br />People are downloading the zips, but I see no feedback from you.<br />Does that mean nobody experienced problems yet?<br />(Note: I&#39;m using the D3D libs from the December 2005 SDK)</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1814" target="_blank">GameClient_5.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-07-08 21:39:28 by Homer</div>
   </div>
   <div class="post" id="post-183182">
    <div class="subject"><a href="#post-183182">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body">right now adding a .obj filereader that directly converts it to customvertexformat from ascii<br />and now a designquestion arises:cant I have a list of pointers to direct VB to different data instead of all copying data to VB?<br /></div>
    <div class="meta">Posted on 2006-07-08 22:23:45 by daydreamer</div>
   </div>
   <div class="post" id="post-183183">
    <div class="subject"><a href="#post-183183">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body">Yes, you can render geometry directly from User memory as I stated earlier.. however, it&#39;s extremely slow in comparison to using a VertexBuffer, because your geometry is not stored in video memory, which means it gets sent to the video card each time you draw it.<br />Creating a VB means that you send the geometry to the video card ONCE, where the video card can access it much more quickly for rendering.<br />On the other hand, READING from video memory is EXTREMELY slow.<br />If you need to READ your vertices, you might choose to either render the geometry from user memory (which is slow), or you might decide to keep TWO copies of your geometry - one in user memory, and one copied to a VB. If you Lock a VB with &quot;WRITE ACCESS ONLY&quot;, it&#39;s MUCH quicker than Locking it for &quot;READ/WRITE ACCESS&quot;, so we try to treat a VB as &quot;write only&quot; in order to obtain maximum benefit from our video hardware whilst avoiding performance penalities.<br /><br /></div>
    <div class="meta">Posted on 2006-07-08 22:34:21 by Homer</div>
   </div>
   <div class="post" id="post-183188">
    <div class="subject"><a href="#post-183188">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body"><br />With only some very minor modifications, the attached zip shows how to render a Quad using two Triangles using D3D.<br />The OGL version has not been updated yet.<br /><br />Note that I haven&#39;t changed the Vertex Format, but I HAVE changed from a &#39;TriangleList&#39; to a &#39;TriangleStrip&#39;.<br />In order to draw a Quad from a TriangleList, we would need to draw two separate Triangles, a total of six vertices.<br />By using a TriangleStrip, we can reduce that to four vertices.<br /><br />I&#39;ll try to describe briefly how TriangleStrips work.<br />In a TriangleStrip, the first Triangle is defined normally, ie as three Vertices.. When we want to draw subsequent Triangles, its assumed that the last two Vertices of the previous Triangle are shared by next Triangle - that is to say, the last Edge of the previous triangle is Shared by the next Triangle.. since we can say that two Vertices of the next Triangle are already defined, we only need one Vertex for each subsequent Triangle in a TriangleStrip, and therefore, to draw a Strip containing two Triangles we need FOUR Vertices.<br /><br />If we have multiple Triangles to draw which have shared Edges, then TriangleStrips are far more efficient (and faster) than TriangleLists.<br /><br />I&#39;ll go away and add code to render a Quad in OGL.<br />Under OGL we can use TriangleStrips too, or if we want to, we can render Quads as a primitive in their own right.. D3D can&#39;t do that.<br /><br />The next posting shall contain the updated OGL quad rendering code, as well as D3D code to Load a Texture from an Image File.<br /><br />Whaddyaknow, it&#39;s lunch time :)<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1815" target="_blank">GameClient_6.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-07-08 23:19:18 by Homer</div>
   </div>
   <div class="post" id="post-183208">
    <div class="subject"><a href="#post-183208">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body">Hi Homer. This be a great idea :) What I noticed is that you don&#39;t use a PURE DEVICE, which is 10-30 % faster. You can use PURE DEVICE if: <br />1) you use hardware vertex processing<br />2) the device supports rasterization, transform, lighting, and shading in hardware.<br />3) You don&#39;t plan to call any &quot;get*&quot; methods (getLight, getMaterial, etc.), which -in practice- are never called, because you always know what you set and/or you have it stored inside your own variables.<br /><br />It&#39;s as simple as checking a few flags and then adding D3DCREATE_PUREDEVICE flag to device&#39;s creation parameters. It&#39;s also smart to add D3DCREATE_DISABLE_DRIVER_MANAGEMENT. Direct3D9 has the ability to overcome some problems that stupid drivers have.</div>
    <div class="meta">Posted on 2006-07-09 02:51:05 by ti_mo_n</div>
   </div>
   <div class="post" id="post-183209">
    <div class="subject"><a href="#post-183209">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body">ti_mo_n - <br />Well spotted :)<br />The next incarnation of the Framework will begin to address such issues.<br /><br />Everyone - <br />Well, I did intend to forge ahead into the land of Textures and Solid Models... however, now might be a good time to &quot;harden&quot; our D3D Framework, and to begin talking about OOP.<br /><br />So far we&#39;ve only seen how to use COM Objects.<br />We&#39;ve learned how to use the ICall (InterfaceCall) macro to call the Methods of a COM interface, and if we&#39;ve been looking closely, we&#39;ve also learned that COM interfaces always have a Method called Release, which is used to Destroy them. We may have also noticed that we called some Procedure to Create them.<br /><br />It&#39;s time we learned about another kind of Object.<br />We&#39;re going to define our first OA32 standard object.<br />These objects are totally compatible with C++, and are quite similar to COM interface objects in many respects.<br /><br />Once we&#39;ve defined an OA32 Class Object, we can call its Methods using the OCall (ObjectCall) macro, whose syntax is exactly the same as for ICall.<br />We can create any number of Instances of the Object using the New macro (we&#39;ll see it soon enough), but there&#39;s no Release method.. we use the Destroy macro to destroy instances of OA32 objects.<br /><br />The typical use of an OA32 class is to allow us to create MANY instances of some kind of object.. for example, we might create a Class which represents a 3D Cube.. we could then create any number of Instances of the Cube, each having its own Position and Orientation in the World.<br /><br />However, our first OA32 class will instead describe something we actually only want one Instance of.<br />You see, making multiple instances of a class object isn&#39;t the only good reason for putting code in its own class.<br />Another very good reason to do this is to create a Code Module which is easily able to be reused in different projects without ANY modification.<br /><br />You might like to think of a Code Module as a Brick, and an Application as a House.. Bricks are useful, easy to recycle, and can be put together in many ways.<br /><br />With that in mind, our first OA32 Class will be called D3DApp.<br />Sorry OpenGL people, I&#39;m going to leave you now, although the OOP principles are equally applicable to OGL, I&#39;m just not interested in writing a cross-api engine for you.. you&#39;ve seen that it&#39;s not hard, and you&#39;ve seen that D3D and OGL are not all THAT different.<br /><br />This new D3DApp class will be the new home for 90 percent of the code I&#39;ve shared with you so far, and will build on that code to provide a robust and reusable code module.<br />This is very similar to the way that the DX SDK samples are presented - all this &#39;base framework&#39; code is wrapped into a reusable Class.<br />Another advantage of doing this is that we&#39;ve effectively swept all this code under the rug.. by removing it from the main sourcecode, we&#39;ve tidied up the main sourcecode, making it highly readable, and hiding away a lot of stuff that we&#39;ve already learned about.<br /><br />Our new D3DApp class will contain a bunch of bonus goodies :)<br />For example, it can enumerate all the possible Video Modes that your hardware can produce and allow you to select from them at runtime.<br />Also, it can remember the previously used settings in a datafile, and ask you whether you want to use the previous settings at startup.<br />It contains code to switch between fullscreen and windowed mode, and other stuff too, so what are we waiting for?<br /><br />I&#39;ve already written and tested this Class some time ago (here&#39;s one I prepared earlier lol) - however I&#39;ll walk you through the process of building the class from scratch, rather than just hand it over.<br /><br />In the next update, we&#39;ll begin to create our D3DApp class, and we&#39;ll be stripping the main sourcecode down to almost nothing.<br /> <br />I repeat, wrapping our existing code is NOT the &#39;most valid use&#39; for OOP.. but it&#39;s as good a place to begin as any.<br />We&#39;ll sure be using a lot more OOP as we make more progress !!<br /></div>
    <div class="meta">Posted on 2006-07-09 03:09:10 by Homer</div>
   </div>
   <div class="post" id="post-183228">
    <div class="subject"><a href="#post-183228">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body">Attached is Tutorial #7.<br />I&#39;ve taken the project skeleton from the original zip, and added skeleton code for our new D3DApp class.<br />I&#39;ve also added some debugging lines so that if you execute the program and examine the debug spew, you can compare it to the sourcecode and make sense of what&#39;s happening (although I don&#39;t think it&#39;s too difficult, this stuff will seem alien to a few people).<br /><br />Our D3DApp class has a method called Run.<br />This will be the equivalent of our old WinMain procedure, ie we won&#39;t return from there until its time to Die.<br />That means that the .ASM file as you see it in Tutorial #7 is pretty much 100% complete as it stands.. so what about all the old code?<br /><br />What happens from here is that we start shovelling all the code from the previous Tutorial #6 into this empty bag we named the D3Dapp class :P<br /><br />So ask me now - why didn&#39;t I damn well design it that way in the first place? For a very good reason.. Well actually, I DID, but I want you to see me moving the existing code into an oop framework, so you understand more about OA32 through practical example.<br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1817" target="_blank">GameClient060709.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-07-09 06:51:43 by Homer</div>
   </div>
   <div class="post" id="post-183320">
    <div class="subject"><a href="#post-183320">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body"><br />D3DApp is basically complete.<br />It has the following features:<br />-Window management code (Creation,MessagePump,Destruction)<br />-Video Settings Dialog<br />-User CallBacks for Rendering and/or critical events<br />-Lost Device recovery<br />-Windowing mode toggle<br />-ConfigFile for last known Working video settings<br />and other stuff.<br /><br />See attached zipfile.<br /><br />Please let me know which parts of this sourcecode require explanation.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1832" target="_blank">GameClient_8.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-07-10 06:22:43 by Homer</div>
   </div>
   <div class="post" id="post-183328">
    <div class="subject"><a href="#post-183328">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body">Now we&#39;ve got Rendering back again.<br />Here&#39;s the D3DApp version of the Triangle demo, with a twist.<br />A texture is loaded from a bmp file.<br />The vertex format specifies both color AND texturecoords.<br />The result is a multicolored triangle with a texture.<br />Visually, it looks like we&#39;re blending the texture.<br /><br />Note: You can use alt-enter to toggle fullscreen, and the Escape key to quit.<br /><br />Questions?</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1833" target="_blank">GameClient_9.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-07-10 09:09:48 by Homer</div>
   </div>
   <div class="post" id="post-183384">
    <div class="subject"><a href="#post-183384">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body"><br />For those of you who are new to OA32, I&#39;d like to explain about Collections.<br /><br />We&#39;ve already seen how to use MemAlloc/MemFree to allocate and release chunks of memory (aka &#39;heap objects&#39;).<br />We&#39;ve also seen how to use New/Destroy to create and destroy OA32 objects.<br /><br />Collection is one of the standard OA32 objects.<br />In essence, a Collection is an array of DWORD, plus some Methods that we can use to mess around with the contents of the array.<br />More specifically, Collection assumes that the dwords its array contains are in fact pointers to other OA32 objects.<br />If we destroy the Collection, it will automagically destroy all the objects it contains, which makes life easy for us (otherwise we&#39;d have to issue a Destroy for each and every object in the array).<br /><br />DataCollections are very similar to Collections - in fact DataCollection is implemented as an Ancestor of Collection with a few methods of Collection being overridden (replaced).<br />DataCollections are designed to store Heap Objects (MemAlloc&#39;d), and if you destroy a DataCollection, it behaves similarly to a Collection.<br />All the objects it contains are MemFree&#39;d for you.<br /><br />That&#39;s enough theory for now, let&#39;s see a practical example.<br /><br />D3D does not perform management of textures for you.<br />For example, if you load the same texture twice, D3D will assume that you intended this, and create two IDirect3DTexture9 objects.<br />What if we have textures which are shared by more than one entity in our 3D world? How can we make use of shared resources and eliminate the duplication of such resources in memory?<br /><br />The attached file contains two OA32 object definitions.<br />They are called Texture and TextureManager.<br />The former is a glorified struct - a container for an IDirect3DTexture9 object and the name of the file from which it was loaded.<br />The latter is a simple class which uses a Collection to keep a list of loaded Textures, which it searches whenever an attempt to load a texture is performed.<br />If we find that a given texture is already loaded, we just return its IDirect3DTexture9 object pointer.<br />However, if the texture is not yet loaded, we load it, then we create a Texture container object, fill its fields, and add it to the Collection.<br /><br />One really nice reason for doing this is that when we the User wants to quit the game (or other app), we just destroy our TextureManager, and it will automatically release all the textures for us (because the Texture.Done method contains code to release the IDirect3DTexture object that was stored in the Texture.pTexture field).<br /><br />I&#39;ll be adding TextureManager support to the D3DApp class.<br />If you have questions, ask them :)<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1838" target="_blank">D3DTextureManager.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-07-11 02:07:50 by Homer</div>
   </div>
   <div class="post" id="post-183395">
    <div class="subject"><a href="#post-183395">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body"><br /><br />As for a demo game, I think I&#39;d prefer to keep it simple, so this thread doesn&#39;t become excessive - after all, we want to make games, not learn the latest in special effects or whatever.<br /><br />We have a fairly functional application framework for writing our games in now (ok, its crap, but we have enough to begin with).<br />So let&#39;s decide on what game we&#39;re making, and how we&#39;re making it.<br /><br />I think a 3D &#39;breakout&#39;-style game is pretty easy and an OK place to start. We&#39;ll have a view from somewhere up in the air looking down.<br />The game will basically be a 2D game but drawn in 3D.<br />Let&#39;s say that the world as seen from above is a 2D chessboard of tiles.<br />What kind of Scale are we talking about?<br />Let&#39;s say the Tiles are 10 x 10 Units in size.<br /><br />Most games try to &#39;partition&#39; the gamespace in some way.<br />You can think of this as &#39;cutting up the world into subspaces&#39;.<br />Other common names for subspaces: cells, sectors, rooms<br />Typically, we define a Struct which describes the properties of and/or the contents of a subspace. The data for each subspace is stored in some structured way, usually as an array or tree. Thus the array or tree represents the entire World, and everything in it.<br />Basically we&#39;re working with a 2D array.<br /><br />WorldCell struct<br />	cbContents db ?<br />WorldCell ends<br /><br />Our WorldCell is nothing but a single byte.<br />We want to plan for the future, so we design it properly.<br /><br />OA32 has an excellent object we can use to manage our array.<br />Array is a Standard OA32 object which implements an n-dimensional array of structs of arbitrary fixed size.<br />You tell it how large the array elements are, and then you start adding Dimensions to it (telling it how large each Dimension is).<br /><br />I&#39;ve implemented an Array in the attached demo.<br />To be precise, I&#39;ve defined a new object called World which inherits from Array (and so has all its variables and methods in addition to its own).<br /><br />Next we must begin the most important part of the tutorial, and it has nothing to do with programming.. we have to discuss the nature of the game in order to determine the code requirements. In doing so, we&#39;ll be planning the remainder of this tutorial.</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1839" target="_blank">GameClient_10.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-07-11 05:23:59 by Homer</div>
   </div>
   <div class="post" id="post-183400">
    <div class="subject"><a href="#post-183400">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body">In between talking about the proposed demo game, I&#39;ll continue to advance the Framework and post updates.<br /><br />I&#39;ve added a DrawGrid method to D3DApp.<br />It draws a Grid in the XZ plane at Y=0, however you can specify the granularity of the grid (ie distance between the lines), and you can specify the color.<br /><br />The grid looks something like what you&#39;d see in a 3D modelling package, and basically just gives us a sense of Scale when our World is mostly empty space.<br /><br />The grid is implemented using LINE primitives and drawing from User-memory (no VB). This is very inefficient, but since the Grid is only for Developers and will not be rendered in Release versions, we can live with the performance hit.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1840" target="_blank">GameClient_11.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-07-11 10:43:36 by Homer</div>
   </div>
   <div class="post" id="post-183461">
    <div class="subject"><a href="#post-183461">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body"><br />I&#39;ve written a very simple Beginner&#39;s level Camera object, and added support for it to D3DApp.<br /><br />It&#39;s got four methods:<br />Position will set the Camera&#39;s Position in 3D space.<br />LookAt will make the Camera face a particular Direction.<br />Update will build and apply a ViewMatrix based on the above.<br />Move_Camera will move the Camera a given amount forwards or backwards in the direction the Camera is currently facing.<br /><br />I&#39;ve changed the size of the Grid to 10, and I&#39;ve created the camera up in the air at&lt;0,50,0&gt;, and facing our Triangle at &lt;0,0,5&gt;.<br />You can use the up and down cursors to move the camera, but you can&#39;t rotate or strafe yet.<br />Try moving backwards to see exactly what our 500x500 grid looks like when drawn at a granularity of 10 (ie 50 lines in X and Z)<br />That&#39;s a lot of little squares huh?<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1843" target="_blank">GameClient_12.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-07-12 10:55:28 by Homer</div>
   </div>
   <div class="post" id="post-183466">
    <div class="subject"><a href="#post-183466">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body"><br />I&#39;ve added a new method called Strafe_Camera to the D3DCamera class.<br />You can use the Left and Right cursors to strafe relative to the direction the Camera is facing.<br /><br />Basically I simply modified a copy of the existing Move_Camera method.. <br />Instead of moving forwards and backwards in &#39;Camera Z&#39;, we now move left and right in &#39;Camera X&#39; (I simply switched the X and Z axes in regards to the output, and effectively ignored the Y axis).<br />The conventional solution is often to calculate a &#39;Right&#39; vector from the View and Up vectors, which is imho over-engineering the solution to the problem at hand, at least for a Camera that never &#39;Rolls&#39;.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1844" target="_blank">GameClient_13.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-07-12 13:02:54 by Homer</div>
   </div>
   <div class="post" id="post-183477">
    <div class="subject"><a href="#post-183477">Re: Getting Started in GameDev - a tutorial</a></div>
    <div class="body">I mentioned previously that eventually our MessagePump would need to be improved (or the GameLoop moved into a separate thread).<br />For various reasons, I would prefer not to run the GameLoop in another thread.<br /><br />We need a way to desynchronize the Rendering from the processing of WMs, but without requiring a new thread.<br />In order to solve any problem, it usually helps to describe it in detail - once you&#39;ve done that, the solution is often very obvious.<br />So let&#39;s describe what&#39;s happening :)<br /><br />Some of you with low-end hardware may have noticed that the application&#39;s performance isn&#39;t really that great in Windowed mode.<br />The main reason is that we are driving the Render function from within the MessagePump, meaning that unless WM&#39;s are being processed, no rendering occurs (underdriving the Render function) - and conversely, when MANY WM&#39;s are being processed, we are OVERDRIVING the Render function.<br />Think of it this way: if you stop moving the Mouse around, and don&#39;t press any keys, there&#39;s very few WM&#39;s being processed and thus rendering effectively ceases altogether.. but if you wiggle the mouse and/or go crazy on the keyboard, we try to Render too often.<br /><br />I&#39;ve improved the Run method in two ways.<br />1 - Code to calculate the FrameRate (fps) was added, it&#39;s used to cap the FrameRate to a maximum of 30fps. If we find that we&#39;ve rendered 30 frames in less than a second, we don&#39;t render any more frames until one second has elapsed.. this is brutal, we can do better.<br />2 - The MessagePump loop&#39;s GetMessage call was replaced with PeekMessage, so that the MessagePump does not &#39;Hang&#39; when there&#39;s no WM&#39;s to process. This drives your cpu MUCH harder (somewhere near 100%). Note that this is NOT HARMFUL - your cpu ALWAYS operates at 100%, what&#39;s new is that our Application is trying to hog the entire 100% all for itself.<br />If my code was better, we could estimate how much time we can Sleep without affecting the framerate, and not consume quite so much cpu time.. although it is acceptable for fullscreen games to consume 100% cpu time, it&#39;s unreasonable for a Windowed application.<br />Perhaps I&#39;ll revise the &#39;framerate capping&#39; mechanism to use &#39;instantaneous values&#39; rather than counting samples over time.<br />Right now (at least as far as Windowed mode goes), we&#39;ve eliminated some problems and introduced new ones.<br /><br />In regards to &#39;instantaneous FPS&#39;:<br />We&#39;ve decided what our maximum fps should be.<br />We want 30 frames per second.<br />1/30 of a second is .033333 recurring.<br />In a perfect world,we know that each frame requires 1/30th of a second to render.<br />Any more and our framerate can&#39;t be achieved - our hardware isn&#39;t fast enough to meet our demands.<br />Any less and we have &#39;spare time&#39; inbetween each Frame.<br />If we find that the &#39;instantaneous&#39; time taken to render one frame is less than 1/30 of a second, we can Sleep for the remaining time.<br />For example, if we find that a frame took .013333 seconds to render, we know that we can Sleep for .02 seconds, ie until the end of the current &#39;timeslice&#39;.<br />This idea can be improved even further by keeping track of the Average of our per-frame timer values, and applying an Average Sleep for each Frame.<br />This way the Sleep times gracefully ramp up and down on demand instead of being &#39;jittery&#39;.<br /><br />Some of the advantages of using &#39;instantaneous fps&#39; are obvious (for example, we&#39;re distributing the rendering events over time, if our hardware was really fast we&#39;d detect the pause when we apply the cap once per second).<br />Other are less obvious (we can hand &#39;spare time per frame&#39; to another thread, for example an asynchronous loader thread that performs disk io without interfering with rendering, and only perform a Sleep if theres absolutely NOTHING that needs to be serviced).<br /><br />Your thoughts?</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=1846" target="_blank">GameClient_14.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2006-07-12 18:53:26 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=25009&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=25009&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="25009" /><input type="number" name="page" min="1" max="5" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=25009&amp;page=2">&gt;</a><a href="../?id=25009&amp;page=5">&raquo;</a></form>  </div>
 </body>
</html>