<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Next Boyer Moore Algorithm - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=42" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=42">Next Boyer Moore Algorithm</a></p>
   <div class="post" id="post-3326">
    <div class="subject"><a href="#post-3326">Next Boyer Moore Algorithm</a></div>
    <div class="body">You can remove one instruction here:<br /><br />    cmp subLngth, 1<br />    jg @F<br />    mov eax, -2                 ; string too short, must be &gt; 1<br />    jmp Cleanup<br />  @@:<br />==========<br />Change it to:<br /><br />  cmp subLnght,1<br />  mov eax,-2<br />  jle Cleanup<br /><br />Don't warry about putting mov eax,-2 might be for <br />nothing it pairs and avoids &quot;First Jump missprediction&quot; in<br /> jg @F<br /><br />in case of jle Cleanup - this (as I think) is least probable case -<br />and it means you in most cases want it mispredicted.<br />(In other words - predicted as &quot;not to be taken&quot;)<br />Cause it's also first jump it always to be predicted as not to be taken.<br />The Svin.</div>
    <div class="meta">Posted on 2001-08-09 09:14:59 by The Svin</div>
   </div>
   <div class="post" id="post-3329">
    <div class="subject"><a href="#post-3329">Next Boyer Moore Algorithm</a></div>
    <div class="body"><pre><code><br /><br />1.    mov esi, lpSource<br />    add esi, srcLngth<br />1.1    sub esi, subLngth<br />    mov ExitLen, esi            ; set Exit Length<br /><br />  ; ----------------------------------------<br />  ; load shift table with value in subLngth<br />  ; ----------------------------------------<br />    mov ecx, 256<br />2.    mov eax, subLngth<br />    lea edi, shift_table<br />    rep stosd<br /><br />  ; ----------------------------------------------<br />  ; load decending count values into shift table<br />  ; ----------------------------------------------<br />3.    mov ecx, subLngth           ; SubString length in ECX<br />    dec ecx                     ; correct for zero based index<br />    mov esi, lpSubStr           ; address of SubString in ESI<br />    lea edi, shift_table<br /><br />    xor eax, eax<br />================================================<br /><br />Let's look up above on quoted code and get some data wich can help us <br />to take right decision, not even nowing what the algo is abot &#58;&#41;<br /> - We can see &#40;1.&#41; that here are chain dependences which slow down CPU<br /> - We can see that the code use the same value stored in subLngth &#40;1.1;2.;3.&#41;<br /> - We can see that the code piece change the value of eax just once &#40;2.&#41; and doesn't<br />  change it until the end &#40;xor eax,eax&#41;<br />Now we are ready to make very obvious optimizations &#58;&#41;<br /><br />	mov esi,lpSource  ; first step in the road esi = lpSource+srcLngth-subLngth = ExitLen<br />	mov eax,subLngth ;eax = subLngth<br />	add esi, srcLngth  ;second step<br />	mov ecx,256	;for stosd we do it here to remove depen.<br />	sub  esi, eax	;third step<br />	lea edi,shift_table   ;for stosd<br />	mov ExitLen,esi	;finish culculations fot ExitLen<br />	rep stosd		;everything is ready for it&#58; eax=sunLength,ecx=256,edi=addr of shift_table<br /><br />=========<br />Now look again at the quoted code from 3. &#58;<br />3.    mov ecx, subLngth           ; SubString length in ECX<br />    dec ecx                     ; correct for zero based index<br />    mov esi, lpSubStr           ; address of SubString in ESI<br />    lea edi, shift_table<br />==============<br />we have subLength in eax so we can do instead of&#58;<br />	mov ecx,subLnght<br />	dec ecx<br />--------------------<br />just&#58;<br />	lea ecx,&#91;eax-1&#93;<br />=========<br />	and We DON'T NEED the&#58;<br />	mov edi,shift_table<br />cause addr of shift_table is already in edi &#40;was put there before stosd&#41;<br />so all this piece of code now can be not even faster but also smaller &#40;in bytes&#41;&#58;<br /><br />	mov esi,lpSource  ; first step in the road esi = lpSource+srcLngth-subLngth = ExitLen<br />	mov eax,subLngth ;eax = subLngth<br />	add esi, srcLngth  ;second step<br />	mov ecx,256	;for stosd we do it here to remove depen.<br />	sub  esi, eax	;third step<br />	lea edi,shift_table   ;for stosd<br />	mov ExitLen,esi	;finish culculations fot ExitLen<br />	rep stosd		;everything is ready for it&#58; eax=sunLength,ecx=256,edi=addr of shift_table<br /><br />	lea ecx,&#91;eax-1&#93;<br />    	mov esi, lpSubStr<br />	xor eax,eax<br /><br /></code></pre></div>
    <div class="meta">Posted on 2001-08-09 10:17:03 by The Svin</div>
   </div>
   <div class="post" id="post-3358">
    <div class="subject"><a href="#post-3358">Next Boyer Moore Algorithm</a></div>
    <div class="body">Alex,<br /><br />Thanks for the work, I agree that the prologue code is not optimal but in speed terms it does not matter, the real action is in the loop code and it is here that I see that gains can be made.<br /><br />The fundamental logic of this type of Boyer Moore that uses the 3 heuristics is that it must have a branch depending on what the value for the character is stored in the table and this means there is an unpredictable jump that is causing branch prediction buffer delays.<br /><br />From my testing, the triple heuristic version is faster on Intel based hardware than either of the simplifications I have running because the Intel processor performs better in the mispredicted jumps than the AMD I have to test with but a simplified version is slightly faster on an AMD.<br /><br />When I have done a bit more work on one of the simplified versions, I will post the code for anyone to have a play with.<br /><br />Regards,<br /><br /><a href="mailto:hutch@pbq.com.au">hutch@pbq.com.au</a></div>
    <div class="meta">Posted on 2001-08-09 20:38:20 by hutch--</div>
   </div>
   <div class="post" id="post-3374">
    <div class="subject"><a href="#post-3374">Next Boyer Moore Algorithm</a></div>
    <div class="body"><div class="quote">Thanks for the work</div> <br />You are most welcome<br /><br /><div class="quote">I agree that the prologue code is not optimal but in speed terms it does not matter, the real action is in the loop code and it is here that I see that gains can be made. </div> <br /><br />I share your concern about main loop optimization -<br />it's the main aim for optimization of any algo.<br />But, of course, minor optimizations don't do any harm.<br />Yes, they make things just a little bit faster or smaller<br />but at least they do it.<br />And one of goals I post some optimizations for of already well written<br />algos is to show some basic tecnigues and usual flows<br />to keep it in mind while designing any other algo.<br />(In this example reloading some values which are already ready<br />to use)<br /><br />An other thing why I always choose code of some fameous and<br />expirience programmers as you or Iczelion for optimizations is<br />that I want to encourage young promgrammers that there is<br />always room for optimizations, the way to do things better.<br />Even if code is written by some guru.<br /><br />That's why I'm also happy when somebody does code that beats<br />mine :)<br /><br />Or some code that is not faster or smaller but using some different logic or approach unknown to me.<br />'Cause some algos which are not perfect for some particular purpose may be the right ones in other case, and knowing them<br />made me be better in my proffession.<br /><br />Too many words :)<br />Sorry :)<br /><br />The Svin.</div>
    <div class="meta">Posted on 2001-08-10 01:21:30 by The Svin</div>
   </div>
   <div class="post" id="post-3377">
    <div class="subject"><a href="#post-3377">Next Boyer Moore Algorithm</a></div>
    <div class="body">I dont know what is wrong but, with Svin's optimizations, search algo crashes.<br /><br /><br />However,Huch's original one works.<br /><br />I have 1711h buffer to search and I search 20h bytes.Here is Svin's modified algo.Maybe I wrongly put it.<br /><br /><pre><code><br />BMBinSearch proc startpos&#58;DWORD,<br />                 lpSource&#58;DWORD,srcLngth&#58;DWORD,<br />                 lpSubStr&#58;DWORD,subLngth&#58;DWORD<br />    LOCAL shift_table&#91;256&#93;&#58;DWORD<br />    LOCAL cval   &#58;DWORD<br />    LOCAL ExitLen&#58;DWORD<br /><br />    push ebx<br />    push esi<br />    push edi<br />  cmp subLngth,1 <br />	mov eax,-2 <br />	jle Cleanup <br />	mov esi,lpSource  ; first step in the road esi = lpSource+srcLngth-subLngth = ExitLen<br />	mov eax,subLngth ;eax = subLngth<br />	add esi, srcLngth  ;second step<br />	mov ecx,256	;for stosd we do it here to remove depen.<br />	sub  esi, eax	;third step<br />	lea edi,shift_table   ;for stosd<br />	mov ExitLen,esi	;finish culculations fot ExitLen<br />	rep stosd		;everything is ready for it&#58; eax=sunLength,ecx=256,edi=addr of shift_table<br /><br />	lea ecx,&#91;eax-1&#93;<br />    	mov esi, lpSubStr<br />	xor eax,eax<br /><br />  Write_Shift_Chars&#58;<br />    mov al, &#91;esi&#93;               ; get the character<br />    inc esi<br />    mov &#91;edi+eax*4&#93;, ecx        ; write shift for each character<br />    dec ecx                     ; to ascii location in table<br />    jnz Write_Shift_Chars<br /><br />  ; -----------------------------<br />  ; set up for main compare loop<br />  ; -----------------------------<br />    mov ecx, subLngth<br />    dec ecx<br />    mov cval, ecx<br /><br />    mov esi, lpSource<br />    mov edi, lpSubStr<br />    add esi, startpos           ; add starting position<br /><br />    mov edx, ExitLen<br />    mov ebx, subLngth<br /><br />    jmp Cmp_Loop<br /><br />;  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<br /><br /><br />  Calc_Suffix_Shift&#58;<br />    add eax, ecx                ; add CMP count<br />    sub eax, cval               ; sub loop count<br />    cmp eax, 0                  ; test eax for zero<br />    jg  Add_Suffix_Shift<br />    mov eax, 1                  ; minimum shift is 1<br /><br />  Add_Suffix_Shift&#58;<br />    add esi, eax                ; add suffix shift<br /><br />  Pre_Loop&#58;<br />    cmp esi, edx ; ExitLen<br />    jg No_Match<br />    mov ecx, cval               ; reset counter in compare loop<br />    xor eax, eax                ; zero EAX<br /><br />  Cmp_Loop&#58;<br />    mov al, &#91;esi+ecx&#93;<br />    cmp al, &#91;edi+ecx&#93;           ; cmp characters in ESI / EDI<br />    jne Set_Shift               ; if not equal, get next shift<br />    dec ecx<br />    jns Cmp_Loop<br /><br />    jmp Match<br /><br />  Set_Shift&#58;<br />    mov eax, shift_table&#91;eax*4&#93; ; get char shift value<br />    cmp eax, ebx ; subLngth<br />    jne Calc_Suffix_Shift       ; if not, jump to Calc_Suffix_Shift<br />    lea esi, &#91;esi+ecx+1&#93;        ; add bad char shift<br />    jmp Pre_Loop<br /><br />;  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<br /><br /><br />  Match&#58;<br />    sub esi, lpSource           ; sub source from ESI<br />    mov eax, esi                ; put length in eax<br />    jmp Cleanup<br /><br />  No_Match&#58;<br />    mov eax, -1<br /><br />  Cleanup&#58;<br />    pop edi<br />    pop esi<br />    pop ebx<br /><br />    ret<br /><br />BMBinSearch endp<br /></code></pre></div>
    <div class="meta">Posted on 2001-08-10 07:26:15 by LaptoniC</div>
   </div>
   <div class="post" id="post-3610">
    <div class="subject"><a href="#post-3610">Next Boyer Moore Algorithm</a></div>
    <div class="body">The thing I can think of :<br />change: jle Cleanup<br />to:         jng Cleanup<br />For the rest both codes upto   Write_Shift_Chars:<br />are doomed to produce the same result.<br />If you're sure of what your wrote could you, please<br />show the whole code where your call both procedures<br />with the same conditions to prove that one of them<br />would work different way given the same parameters?<br /><br />The Svin.</div>
    <div class="meta">Posted on 2001-08-12 23:49:39 by The Svin</div>
   </div>
   <div class="post" id="post-3629">
    <div class="subject"><a href="#post-3629">Next Boyer Moore Algorithm</a></div>
    <div class="body">I call it like this<br />invoke BMBinSearch,0,addr Magic,Magiclen,addr msum,20h<br /><br />length of Magic is 1711h.<br />If you want I can send the source code.Also problem is not related with <br /><div class="quote">The thing I can think of : <br />change: jle Cleanup <br />to: jng Cleanup <br /></div> <br /><br />As you see sublength is 20h.</div>
    <div class="meta">Posted on 2001-08-13 05:03:10 by LaptoniC</div>
   </div>
   <div class="post" id="post-3630">
    <div class="subject"><a href="#post-3630">Next Boyer Moore Algorithm</a></div>
    <div class="body">Yes, I want the source code.<br />Everything is clear through debugging.</div>
    <div class="meta">Posted on 2001-08-13 05:08:17 by The Svin</div>
   </div>
   <div class="post" id="post-3635">
    <div class="subject"><a href="#post-3635">Next Boyer Moore Algorithm</a></div>
    <div class="body">Guys,<br /><br />Its worth understanding what the two loops do before the main loop code, the &quot;rep stosd&quot; loop loads each of the 256 item table with the length of the pattern being searched for, the following loop writes the descending shift value for each character in the pattern into the correct position in the 256 member ascii table.<br /><br />There are no speed optimisation that will make this code go faster, the real action is in the search loop code that starts with &quot;Calc_Suffix_Shift:&quot;.<br /><br />This version uses all 3 heuristics,<br /><br />1. Bad character shift<br />2. Good Suffix Shift<br />3. Decremented good suffix shift with repeat characters<br /><br />This is reasonably close to the design that Bob Boyer and L. Moore designed in 1977. I have 2 other variations that use only one of the two shifts, one is nearly as fast and the other is a lot slower.<br /><br />In relation to the other BM algorithms I have to test against, its search speed is OK, bit faster on Intel, bit slower on AMD but it is a lot faster in mismatch recovery. This is because it has short paths in both shift types.<br /><br />Where there is a problem is in the access to the table that holds the shift values. There appears to be a major stall after getting the value from the shift table and I have not found a way around it yet.<br /><br />I have coded many variations to try and fix this problem as it would improve the speed very dramatically but none of them have solved the problem.<br /><br />This is the code that is causing the stall as far as I can test.<br /><br />  Set_Shift:<br />    mov eax, shift_table ; get char shift value<br /><br />I am guessing that there is an L1 cache conflict between the data being scanned and the table that is built on the stack. I have tested it with a GLOBAL table in the .DATA section but it still has the same problem. I have variations that do not have the potential dependency chain problems but they do not test any faster.<br /><br />Regards,<br /><br /><a href="mailto:hutch@pbq.com.au">hutch@pbq.com.au</a></div>
    <div class="meta">Posted on 2001-08-13 05:17:25 by hutch--</div>
   </div>
   <div class="post" id="post-3704">
    <div class="subject"><a href="#post-3704">Next Boyer Moore Algorithm</a></div>
    <div class="body">LaptoniC ,<br /> <br /> You were right. The source helped me<br />I found the bug.<br />before xor eax,eax put<br />lea edi,shift_table<br />'cause rep stosd would override value of edi<br /><br />The Svin.</div>
    <div class="meta">Posted on 2001-08-13 23:19:34 by The Svin</div>
   </div>
  </div>
 </body>
</html>