<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Generic ASM Question - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29492" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29492">Generic ASM Question</a></p>
   <div class="post" id="post-208303">
    <div class="subject"><a href="#post-208303">Generic ASM Question</a></div>
    <div class="body">Heya everybody... nice to see you... :)<br /><br />so... its been a while now that i am coding ASM but i still cant have a clean idea of how to work... so...<br /><br />do 16bit and 32bit ASM have any differences on their codes besides the extended registers? for example... in 16bit you have to write &quot;main PROC.... END PROC&quot; but in 32bit you dont have to... right? anything else?<br /><br />there are many assemblers... which one to choose? every assembler has its own structure of the code and these structures are different in both Windows and Unix... right?<br /><br />can you also suggest any good papers, tutorials that can help me get a good idea of the game?<br /><br />thank you in advance fellas...<br />cee ya</div>
    <div class="meta">Posted on 2009-07-29 17:17:55 by stakisko</div>
   </div>
   <div class="post" id="post-208305">
    <div class="subject"><a href="#post-208305">Re: Generic ASM Question</a></div>
    <div class="body">Other than the extended registers, your primary differences in 32-bit assembly are the fact that you will be using a different memory model and instead of directly accessing system routines through the BIOS and operating system IDT you will be making use of the operating system&#039;s shared APIs.<br /><br />For 32-bit windows applications, the memory model you will need to become accustomed to is the FLAT memory model. The FLAT memory model provides you with linear addressing which allows you, the programmer, access to all memory within the processes scope. The operating system will allocate your process a section of linear memory in which all data, code, etc is written into. When addressing data you use either an address relative to your current location or an absolute address relative to 0 (the beginning of your process&#039; allocated memory). This makes things a lot easier because there is no need to deal with segmentation.<br /><br />32-bit operating systems make use of ringX levels, ie ring0 to ring3. Your process will be running in ring3 or &quot;user mode&quot; which means you don&#039;t have access to the underlying IDT anymore, everything you do needs to go through the operating system. Because of this, 32-bit operating systems export procedures which your ring3 process has access to. The &quot;user mode&quot; application calls these procedures, the procedures call system service routines which then execute in kernel mode (ring0) before returning the results back down the call stack to your application. Some APIs preform simple routines which don&#039;t require BIOS calls but simplify such things as converting ASCIIZ text to UNICODE wide format. When you begin programming under 32-bit operating systems it&#039;s a pretty good idea to get a copy of that operating systems API documentation for quick reference to these procedures as you will be using them ALOT. Windows 32-bit operating systems make use of the Win32API which is documented at msdn.microsoft.com, also a download to the HTML Help version is at the bottom of this reply. The GNU/Linux and BSD systems make use of the Standard C Library. These *nix systems are unique in that they DO allow you access to the IDT, allowing you to preform system calls through `INT 80H&#039;; where EAX=Syscall Function. Depending on your operating system you&#039;ll find it&#039;s best to try and conform to the shared objects supplied to you, at least until you find a good reason to be accessing the low level interrupts.<br /><br />Here are two examples to help you get a visual of 32-bit programming. I&#039;m not writing a tutorial here so it&#039;s on you to research and figure out what each API routine does.<br /><br /><pre><code>.386<br />.MODEL FLAT, STDCALL<br />OPTION CASEMAP: NONE<br /><br />	; --------------------------------------------------<br />	; Filename:	WinAsmDemo.asm<br />	; Developer:	Bryant Keller<br />	; Date:		July 29, 2009<br />	; Purpose:	This is a JWASM example of writing<br />	;		32-bit assembly on a Windows OS.<br />	;		jwasm -coff WinAsmDemo.asm<br />	;		golink WinAsmDemo.obj<br />	; --------------------------------------------------<br /><br />	MessageBoxA	PROTO	:DWORD, :DWORD, :DWORD, :DWORD<br />	ExitProcess	PROTO	:DWORD<br /><br />	NULL			Equ	0<br />	MB_OK			Equ	0<br />	MB_ICONINFORMATION	Equ	40h<br /><br />.DATA<br />	strTitle	BYTE	&#039;Win32ASM Demo&#039;, 0<br />	strMessage	BYTE	&#039;This is a simple example of programming &#039;<br />			BYTE	&#039;on Windows in JWASM&#039;, 0<br /><br />.CODE<br />MsgBox PROC lpstrMessage:DWORD, lpstrTitle:DWORD<br />	PUSH	MB_OK + MB_ICONINFORMATION<br />	PUSH	lpstrTitle<br />	PUSH	lpstrMessage<br />	PUSH	NULL<br />	CALL	MessageBoxA<br />	XOR	EAX, EAX<br />	RET<br />MsgBox ENDP<br /><br />Start PROC<br />	INVOKE	MsgBox, Addr strMessage, Addr strTitle<br />	INVOKE	ExitProcess, 0<br />Start ENDP<br /><br />END Start</code></pre><br /><br /><pre><code>.386<br />.MODEL FLAT, SYSCALL<br />OPTION CASEMAP: NONE<br /><br />	; --------------------------------------------------<br />	; Filename:	LinAsmDemo.asm<br />	; Developer:	Bryant Keller<br />	; Date:		July 29, 2009<br />	; Purpose:	This is a JWASM example of writing<br />	;		32-bit assembly on a *NIX OS.<br />	; Build:	jwasm -elf LinAsmDemo.asm<br />	;		gcc -s -nostartfiles -o LinAsmDemo LinAsmDemo.o<br />	; --------------------------------------------------<br /><br />	puts	PROTO	:DWORD<br />	exit	PROTO	:DWORD<br /><br />.DATA<br />	strMessage	BYTE	&#039;This is a simple example of programming &#039;<br />			BYTE	&#039;on GNU/Linux in JWASM&#039;, 0<br /><br />.CODE<br />_start PROC<br />	INVOKE	puts, Addr strMessage<br />	INVOKE	exit, 0<br />_start ENDP<br /><br />END _start</code></pre><br /><br /><strong>Related Links:</strong><br /><ul><br /><li>Win32 API Help Files - http://www.carabez.com/downloads/win32api_big.zip</li><br /><li>GNU/Linux Online Manual Pages (full api list included) - http://www.die.net</li><br /><li>GNU C Library Reference Manual - http://www.gnu.org/s/libc/manual/html_node/index.html</li><br /><li>Intel Manuals (explains the IA64/32-bit architecture) - http://www.intel.com/products/processor/manuals</li><br /><li>Microsoft Developer&#039;s Network - http://msdn.microsoft.com/en-us/default.aspx</li><br /></ul><br /><br />I hope this helps you get started. Also, for your mention of assemblers. Just try a few out and pick the one you like. Despite what fanatics will tell you, there is no &quot;best&quot; assembler. Each one has its own good points and bad points. I like the MASM/POASM/JWASM style assemblers for quickly drudging up demo code and testing out routines where I really don&#039;t care about optimizing the whole application and I&#039;m willing to let the assembler handle all the stuff that isn&#039;t important at that time. I like assemblers like NASM/GOASM for creating production code because they don&#039;t assume too much with your code and preform a lot of 1 to 1 translation. With me, it&#039;s more about what&#039;s supported where. When I&#039;m on Windows OS&#039;s I&#039;ll tend to use POASM and GoASM. PoASM supports the HL syntax I like for prototyping code and GoASM, although the macro engine isn&#039;t the greatest, has a lot of shortcuts that NASM just doesn&#039;t have (like D,W,B instead of DWORD, WORD, and BYTE and anonymous labels). On GNU/Linux I use JWASM for prototyping as it&#039;s the only one of the &quot;HL Assemblers&quot; which supports Linux and doesn&#039;t demolish the language. For any production code on Linux/BSD (or anything else that supports IA16/32/64, other than Windows) I use NASM due to it&#039;s powerful macro engine while still supporting 1 to 1 translation.<br /><br />You&#039;ll see a lot of &quot;Assembler Wars&quot; start up every now and then, but to be honest it&#039;s all a matter of preference and it doesn&#039;t really matter what you use as long as you are comfortable with using it. If you like the HL style assemblers by all means you should use it. It&#039;s better to write software using a tool you are comfortable with than to try and be &quot;cool&quot; and use one which confuses you. Truth is, unless you are comfortable using the 1 to 1 style assemblers then you aren&#039;t going to be able to write better optimizations than the HL ones can generate anyways, so what&#039;s the purpose of using it. But that&#039;s enough rambling out of me. :lol:<br /><br />Regards,<br />Bryant Keller<br /></div>
    <div class="meta">Posted on 2009-07-29 23:21:46 by Synfire</div>
   </div>
   <div class="post" id="post-208306">
    <div class="subject"><a href="#post-208306">Re: Generic ASM Question</a></div>
    <div class="body"><div class="quote">can you also suggest any good papers, tutorials that can help me get a good idea of the game?</div><br />First you should try to comprehend the examples provided by Synfire. As soon as you understand what is going on in these you&#039;ll start to get a hang of it.</div>
    <div class="meta">Posted on 2009-07-30 00:06:01 by ti_mo_n</div>
   </div>
   <div class="post" id="post-208307">
    <div class="subject"><a href="#post-208307">Re: Generic ASM Question</a></div>
    <div class="body">thanks a lot guys... bryant you where too helpfull...<br /><br />so... i personally like coding with nasm under both Windows and *nix systems.<br /><br />i will start right now with your links... also a win32 API documentation i have allready read was <a target="_blank" href="http://www.winprog.org/tutorial">www.winprog.org/tutorial</a>. its using C++ to access the API but its a good start...<br /><br />i hope this to be a good start for me...<br /><br />thanks again everyone... cee ya around felloas</div>
    <div class="meta">Posted on 2009-07-30 04:40:26 by stakisko</div>
   </div>
   <div class="post" id="post-208310">
    <div class="subject"><a href="#post-208310">Re: Generic ASM Question</a></div>
    <div class="body">What a great answer you gave, Synfire&nbsp; ;)</div>
    <div class="meta">Posted on 2009-07-30 11:54:14 by ChaperonNoir</div>
   </div>
   <div class="post" id="post-208313">
    <div class="subject"><a href="#post-208313">Re: Generic ASM Question</a></div>
    <div class="body">stakisko,<br /><br />Make sure you get the Win32 API help files I suggested. Just about everyone on the board probably already has these and I know when I first moved over from GNU/Linux to Win32 they practically saved my life. &nbsp;:lol:<br /><br />The API references I posted use C instead of C++ which is a good thing. I haven&#039;t checked out your link yet, but if it uses C++ there is the possibility of it listing MFC or ATL code which isn&#039;t part of the API per say, it&#039;s part of the PSDK. A lot of C++ documents also reference wrappers to API&#039;s instead of the API&#039;s themselves which is always a &quot;joy&quot; to spend hours trying to find out what DLL some procedure you referenced is in only to find out that it&#039;s a C++ wrapper for a procedure of a similar name only more arguments. :mad:<br /><br />For NASM, although I&#039;m a bit partial to this, I would suggest you try out NASMX. The INVOKE macro included in it supports on-call importing of API routines which means you don&#039;t have to worry with hunting down what procedure is in what DLL.<br /><br />Also, if you decide not to use NASMX, you&#039;ll need to do your own name mangling for imported procedures. As I&#039;m sure you know, NASM has two directives which can be used for imported routines; IMPORT and EXTERN. Depending on which one you use the naming convention will be different. Calling convention also plays a part in name mangling... I really suggest you use NASMX or at least check out the macros included with it. NASM does nothing to help us with name mangling since it&#039;s a cross platform assembler, and if you aren&#039;t familiar with the conventions it gets confusing sometimes (also a bit of a pain to have to write __imp_MessageBoxA@16 each time you do a call).<br /><br />I personally suggest you use the EXTERN directive over the IMPORT directive. IMPORT seems like the better choice as it was explicitly designed for importing API&#039;s but honestly it&#039;s not. I remember back when I did the early releases of NASM32 I had the backend importing routines through IMPORT and all my test builds were done with the `-fobj&#039; option due to the use of ALINK as my linker. Unfortunately, after release a bug reared it&#039;s ugly little head when people started trying to link their object code using MS-LINK and Jeremy&#039;s GoLINK. It turned out that IMPORT was, at that time at least, designed with OMF/OBJ in mind and when you tried to build using COFF, the `-fwin32&#039;, build option for linking with other linkers the whole system would fail because the imports would never be found. Since then I changed everything over to EXTERN and it started working with OMF/OBJ and MS/COFF without problem. It was a real big issue in the early releases that nearly killed off the project, but from the sound of it you are kinda like me and do the cross-platform code a lot so I would definitely suggest you stick with EXTERN.<br /><br />I didn&#039;t even notice you ask for tutorials/documents.. right off the top of my head I can&#039;t think of anything. If you give me some time, I&#039;ve currently got an essay to finish for my Humanities class and I have to place an order for a NIC and two printers before I leave for work in the morning, I&#039;ll look on my netbook&#039;s bookmarks for any NASM related links I can find.<br /><br />~Bryant</div>
    <div class="meta">Posted on 2009-07-31 02:01:58 by Synfire</div>
   </div>
   <div class="post" id="post-208316">
    <div class="subject"><a href="#post-208316">Re: Generic ASM Question</a></div>
    <div class="body">Hi everyone, I&#039;m new here.<br />&quot;PROC.... END PROC&quot; I believe these are assembler directives and<br />are used in both 16-bit and 32-bit assembly, am I right?<br />16-bit and 32-bit instructions differ in their instruction format.<br />Registers are 32-bit wide in 32-bit assembly, the segment registers FS and GS are new<br />but accessible in real mode, but in real mode FS and GS cannot be used<br />to index into a segment.<br />Real mode is the mode of the processor right after reset, in this mode<br />the processor is like a 8086.<br />In 16-bit assembly physical addresses are formed by bitshifting<br />the value held in a segment register to the left by four bits<br />to form a 20-bit physical address corresponding to twenty addressing pins,<br />limiting the amount of physical address space to 1MB, excluding<br />the possibility of the A20 line (21st addressing pin found in 80286+).<br />Since offsets are 16-bits in 16-bit assembly, segments are 64KB in length (max).<br />In 32-bit assembly segment registers hold selectors which act as an index into<br />a table of descriptors (in memory), these descriptors hold the linear address<br />for segments,<br />segmentation unit-&gt;linear address-&gt;paging unit-&gt;physical address<br />if I&#039;m right, I&#039;m still learning 32-bit assembly.<br />Offsets are 32-bits in 32-bit assembly hence segments are 4GB in length (max).<br />When a flat memory model is chosen one segment is used to map<br />the entire linear address space up to 4GB, segment registers still contain<br />a selector.<br />---------<br />Nice to see an assembly site with alot of activity, I mainly toy 8086/8088 assembler.<br /></div>
    <div class="meta">Posted on 2009-07-31 06:22:03 by 3y3ty</div>
   </div>
   <div class="post" id="post-208320">
    <div class="subject"><a href="#post-208320">Re: Generic ASM Question</a></div>
    <div class="body">stakisko, here are the links I was able to dig up...<br /><br />Paul Carter&#039;s Tutorial - http://www.drpaulcarter.com/pcasm<br />LinuxAssembly - http://www.linuxassembly.org<br />DeinMeister&#039;s Win32Asm Tutorial - http://www.deinmeister.de/wasmtute.htm<br />A Super Simple NASM Tutorial - http://www.cin.ufpe.br/~if817/arquivos/asmtut/index.html<br />AMD Developer&#039;s Guides - http://developer.amd.com/documentation/guides/Pages/default.aspx<br />Flat Assembler Documents - http://flatassembler.net/docs.php<br />Agner&#039;s Optimization Reference - http://www.agner.org/optimize<br />WizKid&#039;s BSD/NASM Tutorial - http://www.int80h.org<br />MIT&#039;s x86 Files - ftp://rtfm.mit.edu/pub/usenet/news.answers/assembly-language/x86/<br />Microsoft Macro Assembler Reference - http://msdn.microsoft.com/en-us/library/afzk3475(VS.71).aspx<br />SmallCode Tutorials - http://www.strchr.com<br />Jeremy Gordon&#039;s Tutorials - http://www.jorgon.freeserve.co.uk/#tutorials<br /><br />I&#039;ll look around for more later on man, but this should get you started.<br /><br /><div class="quote"><br />Hi everyone, I&#039;m new here.</div><br /><br />Welcome to the forum 3y3ty :)<br /><br /><div class="quote"><br />&quot;PROC.... END PROC&quot; I believe these are assembler directives and<br />are used in both 16-bit and 32-bit assembly, am I right?</div><br /><br />Depending on the assembler you use, correct. Many assemblers don&#039;t support PROC/ENDP. That is natively, many developers take it upon themselves to create PROC/ENDP macros which simulate the built-in directives of other assemblers to ease programming.<br /><br /><div class="quote"><br />16-bit and 32-bit instructions differ in their instruction format.<br />Registers are 32-bit wide in 32-bit assembly, the segment registers FS and GS are new<br />but accessible in real mode, but in real mode FS and GS cannot be used<br />to index into a segment.</div><br /><br />Actually FS and GS have been supported in 16-bit since the 80386, so they aren&#039;t very new and they are certainly not restricted to 32-bit assembly. His earlier post suggested that already understood about registers, and I negated going into any great detail on segment registers as they aren&#039;t used as much in 32-bit systems. Only one I can think of atm is the FS register for setting up exception handling and accessing those, oh so wonderful undocumented windows structures.<br /><br /><div class="quote"><br />In 16-bit assembly physical addresses are formed by bitshifting<br />the value held in a segment register to the left by four bits<br />to form a 20-bit physical address corresponding to twenty addressing pins,<br />limiting the amount of physical address space to 1MB, excluding<br />the possibility of the A20 line (21st addressing pin found in 80286+).</div><br /><br />Your half right, you shift the segment register by 4 bits then you also have to add the offset of memory you are addressing. Of course nobody really needs to deal with this since in 32-bit mode you are almost always running in the flat memory model which uses a contagious chunk rather than segmented areas of memory.<br /><br /><div class="quote"><br />Nice to see an assembly site with alot of activity, I mainly toy 8086/8088 assembler.</div><br /><br />And it&#039;s nice to have some new blood here. Your 8086/8088 roots are definitely showing as it&#039;s rare to see any discussion of segmented addressing or really any 16-bit stuff at all. I can&#039;t speak for everyone but I think many people moved on from 16-bit programming a long time ago and the memories of coding TSRs and fighting over upper memory is just too much to bare. :lol:<br /><br />~Bryant</div>
    <div class="meta">Posted on 2009-07-31 17:34:34 by Synfire</div>
   </div>
   <div class="post" id="post-208322">
    <div class="subject"><a href="#post-208322">Re: Generic ASM Question</a></div>
    <div class="body">Don&#039;t worry, I understand that a 16-bit offset<br />is added to the resulting 20-bit physical address<br />under the 8086.<br />How else would you index into a segment?<br />Hence if SegReg=1211h with an offset<br />of 0011h would form a physical address of:<br />12110h<br />+0011h<br />-------<br />12121h physical address.<br /><br />But I would like to get into the protected mode stuff.<br />I want to use win32 assembly to get familiar with<br />32-bit programming,<br />and study the 80386 programmer&#039;s reference manual<br />to get familiar with the systems programming part.<br /><br />I&#039;m sure this is the site to get help on this.<br /><br />Does anyone know where I can get a descriptive<br />introduction to protected mode descriptor format,<br />memory protection and paging???<br /></div>
    <div class="meta">Posted on 2009-07-31 18:47:37 by 3y3ty</div>
   </div>
   <div class="post" id="post-208323">
    <div class="subject"><a href="#post-208323">Re: Generic ASM Question</a></div>
    <div class="body"><div class="quote"><br />Does anyone know where I can get a descriptive<br />introduction to protected mode descriptor format,<br />memory protection and paging???<br /></div><br /><br /><a target="_blank" href="http://wiki.osdev.org/Protected_mode">http://wiki.osdev.org/Protected_mode</a></div>
    <div class="meta">Posted on 2009-07-31 18:54:31 by SpooK</div>
   </div>
   <div class="post" id="post-208326">
    <div class="subject"><a href="#post-208326">Re: Generic ASM Question</a></div>
    <div class="body"><div class="quote">where I can get a descriptive<br />introduction to protected mode descriptor format,<br />memory protection and paging???</div><br /><a target="_blank" href="http://www.intel.com/products/processor/manuals/">IntelÂ® 64 and IA-32 Architectures Software Developer&#039;s Manuals</a><br />They are VERY formal and VERY detailed, so I suggest you look at the link provided by Spook first.<br /><br />But know that you DON&#039;T need to know how protected mode works in order to code apps for Windows and other 32-bit proteced mode OSes. More than 99% of programmers don&#039;t really know what a protected mode really is ^^&#039;</div>
    <div class="meta">Posted on 2009-07-31 19:53:50 by ti_mo_n</div>
   </div>
   <div class="post" id="post-208327">
    <div class="subject"><a href="#post-208327">Re: Generic ASM Question</a></div>
    <div class="body">Thats right, we just code userland apps, under the PSDK and api !</div>
    <div class="meta">Posted on 2009-08-01 05:28:05 by Homer</div>
   </div>
   <div class="post" id="post-208328">
    <div class="subject"><a href="#post-208328">Re: Generic ASM Question</a></div>
    <div class="body"><div class="quote"><br /><br />Also, for your mention of assemblers. Just try a few out and pick the one you like. Despite what fanatics will tell you, there is no &quot;best&quot; assembler. Each one has its own good points and bad points. I like the MASM/POASM/JWASM style assemblers for quickly drudging up demo code and testing out routines where I really don&#039;t care about optimizing the whole application and I&#039;m willing to let the assembler handle all the stuff that isn&#039;t important at that time. I like assemblers like NASM/GOASM for creating production code because they don&#039;t assume too much with your code and preform a lot of 1 to 1 translation. With me, it&#039;s more about what&#039;s supported where. When I&#039;m on Windows OS&#039;s I&#039;ll tend to use POASM and GoASM. PoASM supports the HL syntax I like for prototyping code and GoASM, although the macro engine isn&#039;t the greatest, has a lot of shortcuts that NASM just doesn&#039;t have (like D,W,B instead of DWORD, WORD, and BYTE and anonymous labels). On GNU/Linux I use JWASM for prototyping as it&#039;s the only one of the &quot;HL Assemblers&quot; which supports Linux and doesn&#039;t demolish the language. For any production code on Linux/BSD (or anything else that supports IA16/32/64, other than Windows) I use NASM due to it&#039;s powerful macro engine while still supporting 1 to 1 translation.<br /><br />You&#039;ll see a lot of &quot;Assembler Wars&quot; start up every now and then, but to be honest it&#039;s all a matter of preference and it doesn&#039;t really matter what you use as long as you are comfortable with using it. If you like the HL style assemblers by all means you should use it. It&#039;s better to write software using a tool you are comfortable with than to try and be &quot;cool&quot; and use one which confuses you. Truth is, unless you are comfortable using the 1 to 1 style assemblers then you aren&#039;t going to be able to write better optimizations than the HL ones can generate anyways, so what&#039;s the purpose of using it. But that&#039;s enough rambling out of me. :lol:<br /><br /></div><br /><br />That is a nice summary of various assemblers when writing code directly in assembly. Are all the assemblers you mention above ones that have been around for a long time and will be around for a long time? Are they all used as mission critical pieces of some large projects that just cannot afford any of these particular assemblers to die?<br /><br />What about when writing a compiler with assembly as the target language? I&#039;d think the HL assemblers are not good targets for that and an assembler like NASM would be a better target choice, yes?<br /><br />Peter</div>
    <div class="meta">Posted on 2009-08-01 15:39:32 by petermichaux</div>
   </div>
   <div class="post" id="post-208329">
    <div class="subject"><a href="#post-208329">Re: Generic ASM Question</a></div>
    <div class="body">When you want your compiler to provide a perfect assembly listing that the user can assemble by hand, you need to target an assembler that lets you manipulate the object module very precisely. When I&#039;m talking about manipulating the object structure precisely, I&#039;m talking about special directives like SEGMENT and PUBLIC. If you take a look at any assembly listing , you&#039;ll see what I mean.<br /><br />A lot of assemblers are suitable for this but not all of them can do it (RosAsm is nice for learning assembly but you don&#039;t have this kind of control)<br /></div>
    <div class="meta">Posted on 2009-08-01 20:43:21 by ChaperonNoir</div>
   </div>
   <div class="post" id="post-208331">
    <div class="subject"><a href="#post-208331">Re: Generic ASM Question</a></div>
    <div class="body"><div class="quote"><br />That is a nice summary of various assemblers when writing code directly in assembly.</div><br />Thank you :)<br /><br /><div class="quote"><br />Are all the assemblers you mention above ones that have been around for a long time and will be around for a long time?</div><br /><br /><br />MASM and NASM have both been around a very long time, and PoASM is part of the PellesC toolkit which was based on the original LCC compiler so you could kinda say it&#039;s a restoration of an old assembler (although it far surpasses LCC&#039;s assembler and I&#039;ve never had issues with it generating code that I didn&#039;t expect). GoASM is relatively new, but it&#039;s VERY stable. JWASM is very new, I wouldn&#039;t really trust the HL directives except in certain cases, like the .IF/.ELSE/etc.. which simply creates CMP&#039;s.<br /><br /><div class="quote"><br />Are they all used as mission critical pieces of some large projects that just cannot afford any of these particular assemblers to die?</div><br /><br />Honestly, if you are doing mission critical or safety critical code you should be using the assembler which is suggested by the manufacturer of the device you are working with. MASM and NASM are both pretty decent for M/C and S/C development as they have had years of testing behind them and are recognized by industry leaders.<br /><br /><div class="quote"><br />What about when writing a compiler with assembly as the target language? I&#039;d think the HL assemblers are not good targets for that and an assembler like NASM would be a better target choice, yes?</div><br /><br />Not true at all. MASM is one of those such HL assemblers and it&#039;s been the backbone of Visual C/C++ since it&#039;s earliest releases. PoASM is also an assembler which was originally created as a backbone of a compiler. Yes, I&#039;m sure the LL ones are probably easier to work with as far as code generation goes (in fact I think PellesC actually uses a NASM style syntax which gets passed through an internal assembler now, leaving PoASM only for backwards compatibility). But to say that they aren&#039;t suited for it is definitely an overstatement. In fact, JWASM is an open source port of Open Watcomm which also has it&#039;s roots as a C compiler backend. ;)<br /><br />~Bryant</div>
    <div class="meta">Posted on 2009-08-02 02:19:23 by Synfire</div>
   </div>
   <div class="post" id="post-208334">
    <div class="subject"><a href="#post-208334">Re: Generic ASM Question</a></div>
    <div class="body">Hehe, I dunno about &quot;MASM and NASM have both been around a very long time&quot; :)<br />MASM is THE x86 assembler, it has been around since the early days of DOS. It was pretty much the first widely available assembler for x86.<br />NASM has only been around since the late 90s I believe.<br />So that&#039;s quite a difference there, to me MASM has always been around, but NASM still feels as a newcomer, because I can still recall when I first heard of it...<br />Not that it matters today though. Most of MASM&#039;s DOS heritage is irrelevant, as DOS has become obsolete years ago. NASM has become a very popular assembler in its own right, and being an opensource solution, it will likely be around for a long time (I believe the original developers have long abandoned it, and others have taken over. One of the original developers was Simon Tatham btw, of Putty fame).</div>
    <div class="meta">Posted on 2009-08-03 04:08:00 by Scali</div>
   </div>
   <div class="post" id="post-208339">
    <div class="subject"><a href="#post-208339">Re: Generic ASM Question</a></div>
    <div class="body">NASM had it&#039;s first widely available release in <span class="strike">&#039;91</span>, which is a pretty long time compared to assemblers like PoASM and GoASM. You are right though in the grand scheme of things, compared to assemblers like MASM and A86 it&#039;s just a baby.<br /><br />EDIT: Correction according to the revision documents it was 1996.. funny I could have swore it came out before then, apparently I was wrong.&nbsp; :lol:</div>
    <div class="meta">Posted on 2009-08-03 07:25:28 by Synfire</div>
   </div>
   <div class="post" id="post-208344">
    <div class="subject"><a href="#post-208344">Re: Generic ASM Question</a></div>
    <div class="body">Yea... I find that quite funny actually... I mean, in the 80s to early 90s, there were only a handful of x86 assemblers commonly used. Mainly MASM and TASM... And back then, assembly was actually still quite &#039;mainstream&#039;... By the mid-90s, most programmers no longer used assembly on a daily basis... in fact, by then you had the first generation of programmers who had never used assembly at all. Yet from then on you see new assemblers popping up left and right.<br />Bit ironic really... the less people use assembly, the more assemblers are being offered.</div>
    <div class="meta">Posted on 2009-08-04 10:13:10 by Scali</div>
   </div>
  </div>
 </body>
</html>