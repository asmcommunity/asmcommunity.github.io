<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Yes... Another Parsing/compare Question - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=3322" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=3322">Yes... Another Parsing/compare Question</a></p>
   <div class="post" id="post-21991">
    <div class="subject"><a href="#post-21991">Yes... Another Parsing/compare Question</a></div>
    <div class="body">Did a search of the site and found like a million resources for string parsing!<br /><br />The problem is I'd like to create a parser (much like one done with html or asm code sytax highlighting)...<br /><br />Basically I want to search a line for &quot;keywords&quot; and if found then execute code based on that keyword... (This is really for my winsock program, however, i'm sure it will come in handy in other examples)<br /><br />For example<br /><br />KeyWords2:      ADC ADD AND CALL CBW CLC CLD CLI CMC CMP<br /> CMPS CMPSB CMPSW CWD DAS DEC DIV DAA ESC HLT IDIV IMUL IN INC INT INTO IRET JA JAE JB JBE JC JCXZ JE JG JGE JL JLE<br />JMP JNA JNAE JNB JNBE JNC JNE JNG JNGE JNL JNLE JNO JNP JNS<br /> JNZ JO JP JPE JPO JS JZ LAHF LDS LEA LES LODS<br /><br />(using asm as an example)<br /><br />If the word was &quot;LEZ&quot; it would check the first char of all the keyword items and then hitting LEA would start to check the individual words finding that LEZ isn't a keyowrd would do nothing...<br /><br />I ask this question because I'm sure someone has done this before and I'm trying to learn how this is done...  I just want to apply it to individual lines...<br /><br />Sliver<br /><br /><br />-----EDIT-----<br />I should mention I don't know how to create an array of keywords in masm either, but I'm search for help on that right now... but if you get it first ... please point me in the right direction</div>
    <div class="meta">Posted on 2002-01-30 10:12:41 by Sliver</div>
   </div>
   <div class="post" id="post-22004">
    <div class="subject"><a href="#post-22004">Yes... Another Parsing/compare Question</a></div>
    <div class="body">There are a number of ways to approach this problem:<br /><br />You could use the immediate values test:<pre><code>  cmp &#91;esi&#93;,&quot;L&quot;<br />  jne @Next<br />  cmp &#91;esi+1&#93;,&quot;E&quot;<br />  jne @Next<br />  cmp &#91;esi+2&#93;,&quot;A&quot;<br />  jne @Next</code></pre>It's really bad that there is so much code, but macros could be wrote to simplify the process.  The good part is that there isn't any data to access besides the source buffer.  SpASM used this method for instruction matching the last time I looked.<br /><br />Another method would be to have a table of some type.  Could be strings in alphabetical order.  Or like in FASM, sort the strings by string length.  After a positive match the table usually has pointers to code to execute, and/or a value passed to the function that responds to that string.<br /><br />This thread shows how to build an array of strings:<br /><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=3290">http://www.asmcommunity.net/board/index.php?topic=3290</a><br /><br />Also look for the Jump Table Helper macro.<br /><br />There are so many ways to tackle this problem - it's best just to get some experience with different methods, so that you know their strengths and weaknesses.  I'd advise using macros and flexible coding techniques unless your absolutely sure your syntax isn't going to change. (It usually does ;))<br /><br />Links:<br /><a target="_blank" href="http://www.cs.vu.nl/~dick/PTAPG.html">http://www.cs.vu.nl/~dick/PTAPG.html</a></div>
    <div class="meta">Posted on 2002-01-30 12:22:24 by bitRAKE</div>
   </div>
   <div class="post" id="post-22019">
    <div class="subject"><a href="#post-22019">Yes... Another Parsing/compare Question</a></div>
    <div class="body">I think a hash table wold be helpfull on this.</div>
    <div class="meta">Posted on 2002-01-30 14:52:51 by dxantos</div>
   </div>
   <div class="post" id="post-22060">
    <div class="subject"><a href="#post-22060">Yes... Another Parsing/compare Question</a></div>
    <div class="body">Please forgive my naiveness... What's a hash table?<br /><br />I really would like to have a set-up like:<br /><pre><code><br />char Keywords&#91;&#93;&#91;80&#93;  = <br />&#123;<br />       &quot;ADD&quot;,<br />       &quot;ADC&quot;,<br />       &quot;AND&quot;,<br />       &quot;CALL&quot;,<br />       &quot;CBW&quot;,<br />       &quot;CLC&quot;<br />&#125;<br /></code></pre><br /><br />Sliver</div>
    <div class="meta">Posted on 2002-01-30 19:16:13 by Sliver</div>
   </div>
   <div class="post" id="post-22161">
    <div class="subject"><a href="#post-22161">COMPSCI 101</a></div>
    <div class="body">Hash table is a method of quickly looking up data based upon a key value.<br /><br />Pro:<br />It's really fast on random accesses when tuned correctly.<br /><br />Cons:<br />You have to know the general parameters of your data to tune it correctly.<br />Poor at sequential access.<br /><br />General idea:<br />You use a function that turns the key value into an array index. But note the &quot;pigeonhole priciple&quot; which is... if you got n beds &amp; n+1 people then someone is bunking with someone else... or if your array has n elements &amp; you have n+1 keys then you've got a slight problem. Solution: use a VERY SHORT linked list (or other method) to allow the same array index to hold multiple key values.<br /><br />I posted a VERY PRIMITIVE one a while back in asm that should get you started. It's not the best in the world but it's something.<br /><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=1344">Thread is here</a> <br /><br />Have a google for more info.<br /><br />rafe</div>
    <div class="meta">Posted on 2002-01-31 11:58:58 by rafe</div>
   </div>
   <div class="post" id="post-22167">
    <div class="subject"><a href="#post-22167">Yes... Another Parsing/compare Question</a></div>
    <div class="body">Do you havethe example you used?<br /><br />downloadables tend to be deleted from the serer after a few weeks<br /><br />Sliver</div>
    <div class="meta">Posted on 2002-01-31 12:47:49 by Sliver</div>
   </div>
   <div class="post" id="post-22169">
    <div class="subject"><a href="#post-22169">Yes... Another Parsing/compare Question</a></div>
    <div class="body">Oops! I'll repost what I still have when I get home.<br /><br />:stupid:</div>
    <div class="meta">Posted on 2002-01-31 12:57:23 by rafe</div>
   </div>
   <div class="post" id="post-22171">
    <div class="subject"><a href="#post-22171">Yes... Another Parsing/compare Question</a></div>
    <div class="body">A sorted array can be searched in log N time without a hash,<br />but it's not very programmer friendly. ;)</div>
    <div class="meta">Posted on 2002-01-31 13:10:16 by bitRAKE</div>
   </div>
   <div class="post" id="post-22174">
    <div class="subject"><a href="#post-22174">Yes... Another Parsing/compare Question</a></div>
    <div class="body">actually, i've found binary search to be easier to work with.<br /><br />&amp; given that O(log n) is only a bit bigger than O(n) in this case (log(n) ~ 8-10 or so).  a properly coded binary search has a low mulplicative constant &amp; both have similar setup times (additive constants)<br /><br />sooo.... binary search may be a viable option in this case. I'd recommend presorting the data &amp; then putting the literals presorted into your table if you go this route.<br /><br />Unless you're thinking of storing all the variables too. then the log(n) gets into the ~15-16 range (look at the big includes). The variable names can get large to so keeping the array orthogonal would reqire an array of pointers. still doable (&amp; may be preferable) but you're getting into the range where hashing can help or could be considered. <br /><br />i've done this math before. ;)<br /><br />rafe</div>
    <div class="meta">Posted on 2002-01-31 13:35:43 by rafe</div>
   </div>
   <div class="post" id="post-22185">
    <div class="subject"><a href="#post-22185">Yes... Another Parsing/compare Question</a></div>
    <div class="body">This is an intersting thread.  (I dont see much talk of &quot;order&quot;s ie. O(n) outside of class :) ).  Im surprised you remember to use such stuff (not to say i think its wrong, just i couldnt never find the interest to remember it all :)  )<br /><br />Anywho, my two cents was to use a double linked list.  But reading Rafe's thoughts on a binary tree, the need for the &quot;double&quot; is not all that important since there is only 26 odd entries (A-Z).<br /><br />Then it came to mind that perhaps you can take the first letter,  subtract off 0x41 (hex), and use this as an index offset into a table of individual linked lists.  Where the list will be all the different &quot;commands&quot; that start with that letter.<br /><br />So this would be a pseudo-double-linked list, as there is not an initial list storing other list pointers, but rather a table of 26 pointers to the lists.<br /><br />Hmmm... Sliver, If your still looking for help next week, bring this topic up again, and i'll wip together a double linked list and a binary tree (Alrready have a double linked list written).  But its coded with our object model tho..  Objects are the best way to implement these things.<br /><br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-01-31 16:47:19 by NaN</div>
   </div>
   <div class="post" id="post-22190">
    <div class="subject"><a href="#post-22190">Yes... Another Parsing/compare Question</a></div>
    <div class="body">My current assembler finds the instruction in eight compares, with support for 208 instruction mnemonics.  It's all pretty nasty code.  There is separate handling for labels using hashing.</div>
    <div class="meta">Posted on 2002-01-31 17:17:05 by bitRAKE</div>
   </div>
   <div class="post" id="post-22222">
    <div class="subject"><a href="#post-22222">Yes... Another Parsing/compare Question</a></div>
    <div class="body"><div class="quote">Then it came to mind that perhaps you can take the first letter, subtract off 0x41 (hex), and use this as an index offset into a table of individual linked lists. Where the list will be all the different &quot;commands&quot; that start with that letter<br /></div>This is definitely a hashing algorithm, where the hash function returns as a result -- the first character less 0x41.<br /><br />There are at least three ways to organize a hash table. The above is exactly what <strong>rafe</strong> initially described. Another way is to make the full table the same as the hash table -- this requires a way to handle <strong>collisions</strong>, the situation where an array entry is already occupied by a valid value. And there is a variation on the linked list version, where each node on the list contains not one, but several values held in a <strong>bucket</strong>. The last version can reduce the delays caused by cache misses. (Big if the cache is a disk cache.)</div>
    <div class="meta">Posted on 2002-01-31 19:59:42 by tank</div>
   </div>
   <div class="post" id="post-22230">
    <div class="subject"><a href="#post-22230">Yes... Another Parsing/compare Question</a></div>
    <div class="body">I'm trying to implement a keyword/parser...<br /><br />How it works (based on icz's tut35)<br /><br />have a keyword list file...<br /><br />parse the file and store words into a structure (the word/the size of word/the color (not used)/and pointer to next structure)<br /><br />The problem is... I can't seem to find the pointer to the first structure...<br /><br />I can find the first structure (compared the first word in the list with with an exact match)...<br /><br />I've gotten like 180 GPF errors in trying to solve this... So I'd appreciate a point in the right direction... I've included the source, but I'll quote some source here too<br /><br /><pre><code><br />ParseBuffer proc uses edi esi hHeap&#58;DWORD,pBuffer&#58;DWORD, nSize&#58;DWORD, ArrayOffset&#58;DWORD,pArray&#58;DWORD<br />	LOCAL buffer&#91;128&#93;&#58;BYTE<br />	LOCAL InProgress&#58;DWORD<br />	mov InProgress,FALSE<br />	lea esi,buffer<br />	mov edi,pBuffer<br />	invoke CharLower,edi<br />	mov ecx,nSize<br />SearchLoop&#58;<br />	or ecx,ecx<br />	jz Finished<br />	cmp byte ptr &#91;edi&#93;,&quot; &quot;<br />	je EndOfWord<br />	cmp byte ptr &#91;edi&#93;,9 	; tab<br />	je EndOfWord<br />	mov InProgress,TRUE<br />	mov al,byte ptr &#91;edi&#93;<br />	mov byte ptr &#91;esi&#93;,al<br />	inc esi<br />SkipIt&#58;<br />	inc edi<br />	dec ecx<br />	jmp SearchLoop<br />EndOfWord&#58;<br />	cmp InProgress,TRUE<br />	je WordFound<br />	jmp SkipIt<br />WordFound&#58;<br />	mov byte ptr &#91;esi&#93;,0<br />	push ecx<br />	;========================================================<br />	; store the word in a WORDINFO structure<br />	;========================================================<br />	invoke HeapAlloc,hHeap,HEAP_ZERO_MEMORY,sizeof WORDINFO<br />        mov RootNode, eax<br />	push esi<br />	mov esi,eax<br />        assume esi&#58;ptr WORDINFO<br />	invoke lstrlen,addr buffer<br />	mov &#91;esi&#93;.WordLen,eax<br />	push ArrayOffset<br />	pop &#91;esi&#93;.pColor<br />	inc eax<br />	invoke HeapAlloc,hHeap,HEAP_ZERO_MEMORY,eax<br />	mov &#91;esi&#93;.pszWord,eax<br />	mov edx,eax<br />	invoke lstrcpy,edx,addr buffer<br />	mov eax,pArray<br />	movzx edx,byte ptr &#91;buffer&#93;<br />	shl edx,2		; multiply by 4<br />	add eax,edx<br />	.if dword ptr &#91;eax&#93;==0<br />		mov dword ptr &#91;eax&#93;,esi<br />	.else<br />		push dword ptr &#91;eax&#93;<br />		pop &#91;esi&#93;.NextLink<br />		mov dword ptr &#91;eax&#93;,esi<br />	.endif<br /><br />        invoke lstrcmpi,ADDR buffer ,ADDR test2<br />        or eax,eax<br />        .if &#40;eax == 0&#41;<br /><br /><br />                invoke wsprintf,addr tempBuffer,offset _str,&#91;esi&#93;.pszWord                <br />                invoke MessageBox,0,addr tempBuffer,addr tempBuffer,MB_OK<br />        .endif<br />        <br />	pop esi<br />	pop ecx<br />	lea esi,buffer<br />	mov InProgress,FALSE<br />	jmp SkipIt<br />Finished&#58;<br />	.if InProgress==TRUE<br />		;========================================================<br />		; store the word in a WORDINFO structure<br />		;========================================================<br />		invoke HeapAlloc,hHeap,HEAP_ZERO_MEMORY,sizeof WORDINFO<br />		push esi<br />		mov esi,eax<br />		assume esi&#58;ptr WORDINFO<br />		invoke lstrlen,addr buffer<br />		mov &#91;esi&#93;.WordLen,eax<br />		push ArrayOffset<br />		pop &#91;esi&#93;.pColor<br />		inc eax<br />		invoke HeapAlloc,hHeap,HEAP_ZERO_MEMORY,eax<br />		mov &#91;esi&#93;.pszWord,eax<br />		mov edx,eax<br />		invoke lstrcpy,edx,addr buffer<br />		mov eax,pArray<br />		movzx edx,byte ptr &#91;buffer&#93;<br />		shl edx,2		; multiply by 4<br />		add eax,edx<br />		.if dword ptr &#91;eax&#93;==0<br />			mov dword ptr &#91;eax&#93;,esi<br />		.else<br />			push dword ptr &#91;eax&#93;<br />			pop &#91;esi&#93;.NextLink<br />			mov dword ptr &#91;eax&#93;,esi<br />		.endif<br />		pop esi<br />	.endif<br /><br />        mov edx, RootNode<br />        assume eax&#58;ptr WORDINFO<br />        push &#40;WORDINFO ptr &#91;edx&#93;&#41;.NextLink<br />        pop eax<br />        invoke MessageBox, 0, &#91;eax&#93;.pszWord, &#91;eax&#93;.pszWord, MB_OK<br />                <br />        assume eax&#58;nothing<br />	ret<br />ParseBuffer endp<br /><br />FillHiliteInfo proc uses edi<br />	LOCAL buffer&#91;1024&#93;&#58;BYTE<br />	LOCAL pTemp&#58;DWORD<br />	LOCAL BlockSize&#58;DWORD<br />	;===================================================================<br />	; Zero out the array<br />	;===================================================================<br />	invoke RtlZeroMemory,addr ASMSyntaxArray,sizeof ASMSyntaxArray<br />	;===================================================================<br />	; obtaining the path of this program instance<br />	;===================================================================<br />	invoke GetModuleFileName,hInstance,addr buffer,sizeof buffer<br />	invoke lstrlen,addr buffer<br />	mov ecx,eax<br />	dec ecx<br />	lea edi,buffer<br />	add edi,ecx<br />	std<br />	mov al,&quot;\&quot;<br />	repne scasb<br />	cld<br />	inc edi<br />	mov byte ptr &#91;edi&#93;,0<br />	invoke lstrcat,addr buffer,addr WordFileName<br />	;==================================================================<br />	; Check whether the file exists<br />	;==================================================================<br />	invoke GetFileAttributes,addr buffer<br />	.if eax!=-1<br />		;===================================================================<br />		; allocate a block of memory from the heap for the strings<br />		;===================================================================<br />		mov BlockSize,1024*10<br />		invoke HeapAlloc,hMainHeap,0,BlockSize<br />		mov pTemp,eax<br />@@&#58;		<br />		invoke GetPrivateProfileString,addr ASMSection,addr C1Key,addr ZeroString,pTemp,BlockSize,addr buffer<br />		.if eax!=0<br />			inc eax<br />			.if eax==BlockSize	; the buffer is too small<br />				add BlockSize,1024*10<br />				invoke HeapReAlloc,hMainHeap,0,pTemp,BlockSize<br />				mov pTemp,eax<br />				jmp @B<br />			.endif<br />			mov edx,offset ASMColorArray<br />			invoke ParseBuffer,hMainHeap,pTemp,eax,edx,addr ASMSyntaxArray<br />		.endif<br />		invoke HeapFree,hMainHeap,0,pTemp<br />	.endif<br />	ret<br />FillHiliteInfo endp<br /></code></pre></div>
    <div class="meta">Posted on 2002-01-31 20:27:27 by Sliver</div>
   </div>
   <div class="post" id="post-22326">
    <div class="subject"><a href="#post-22326">Yes... Another Parsing/compare Question</a></div>
    <div class="body">Here's the hash table dll skeleton. It's not god's gift to hash tables, testing was light, but it should give you the general layout.<br /><br />This implementation is for a static hash table. that is, one where you set up your data up front &amp; then don't change it. which should suit your needs well enuf.<br /><br />I've also worked on a dynamic hash table, one more like Perl's hashes, but it's not done (tested at all)... short attention span (-:</div>
    <div class="meta">Posted on 2002-02-01 08:06:01 by rafe</div>
   </div>
   <div class="post" id="post-22410">
    <div class="subject"><a href="#post-22410">Yes... Another Parsing/compare Question</a></div>
    <div class="body">Do you have an example to go with the dll application?<br /><br />I'm still not sure how you can use a hash table for parsing information and such...<br /><br />Thanks in advance<br />Sliver</div>
    <div class="meta">Posted on 2002-02-01 19:45:22 by Sliver</div>
   </div>
   <div class="post" id="post-22418">
    <div class="subject"><a href="#post-22418">Yes... Another Parsing/compare Question</a></div>
    <div class="body">The hashing is used to speed up the the search within an array of items - it doesn't do the parsing.  You need to code the parsing algorithm manually (yuck!), or build the parser from a definition in another language with another tool (ie lex).</div>
    <div class="meta">Posted on 2002-02-01 20:53:26 by bitRAKE</div>
   </div>
   <div class="post" id="post-22429">
    <div class="subject"><a href="#post-22429">Yes... Another Parsing/compare Question</a></div>
    <div class="body">Then how does this relate to my initial question?<br />:(<br /><br />Can someone answer my other question about my keyword parser then?<br /><br />Hash tables seems a little too much to tackle if I haven't got the parser working yet...<br /><br />Sliver</div>
    <div class="meta">Posted on 2002-02-02 00:11:45 by Sliver</div>
   </div>
  </div>
 </body>
</html>