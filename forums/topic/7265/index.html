<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Fast a2dw - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=7265" />
    <link rel="next" href="../?id=7265&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=7265">Fast a2dw</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=7265&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=7265&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="7265" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=7265&amp;page=2">&gt;</a><a href="../?id=7265&amp;page=2">&raquo;</a></form>   <div class="post" id="post-52553">
    <div class="subject"><a href="#post-52553">Fast a2dw</a></div>
    <div class="body">Hi all<br /><br />Any faster?<br /><pre><code><br />AsciiToDw proc uses edx esi,lpAscii&#58;DWORD<br /><br />	mov		esi,lpAscii<br />	xor		eax,eax<br />	xor		edx,edx<br />  @@&#58;<br />	mov		dl,&#91;esi&#93;<br />	sub		dl,'0'<br />	jb		@f<br />	cmp		dl,10<br />	jnb		@f<br />	lea		eax,&#91;eax*4+eax&#93;		;Multiply by 5<br />	lea		eax,&#91;eax*2+edx&#93;		;Multiply by 2 and add digit in edx<br />	inc		esi<br />	jmp		@b<br />  @@&#58;<br />	ret<br /><br />AsciiToDw endp<br /></code></pre><br />KetilO</div>
    <div class="meta">Posted on 2002-08-10 17:56:27 by KetilO</div>
   </div>
   <div class="post" id="post-52560">
    <div class="subject"><a href="#post-52560">Fast a2dw</a></div>
    <div class="body">Did you look at xlat/xlatb?<br /><br />Did you look at cwd/cwde?</div>
    <div class="meta">Posted on 2002-08-10 18:59:08 by Roy Cline</div>
   </div>
   <div class="post" id="post-52561">
    <div class="subject"><a href="#post-52561">Fast a2dw</a></div>
    <div class="body">Please tell more.<br /><br />KetilO</div>
    <div class="meta">Posted on 2002-08-10 19:13:06 by KetilO</div>
   </div>
   <div class="post" id="post-52569">
    <div class="subject"><a href="#post-52569">Fast a2dw</a></div>
    <div class="body">ignore it :)<br />xlat does no help for decimals.<br />I am not giving you another algo, I'll help you improve your own for better understanding.<br />First rule for fast algo - remove anithing that can be removed from main loop<br />1. Do sub &quot;0&quot; at the and of loop and change unconditinal jump to conditional<br /> sub dl,&quot;0&quot;<br /> jns @B<br /><br />Do adds (leas) at the begining.<br />That will help you remove 1 instruction.<br />advantage = x -1 , where x is number of iterations.<br />Why -1? Cause you need to do jump to the<br /> mov dl,<br /> inc esi<br /> sub dl,&quot;0&quot;<br /> jns @B<br />at the begining<br />2. I don't understand the<br /> cmp dl,10<br />If it is ASCIIZ then sub dl,&quot;0&quot; would be enough to determin if it is the end of the string (0)<br />So you can remove those 2 instructions too.<br />Or you expect some letter to be at the end of symbolic number?<br />If not your algo can look like:<br /><pre><code><br /><br /><br /><br /><br />AsciiToDw proc uses edx esi,lpAscii&#58;DWORD<br /><br />mov esi,lpAscii<br />xor eax,eax<br />xor edx,edx<br />jmp @1<br />  @@&#58;<br />lea eax,&#91;eax*4+eax&#93;;Multiply by 5<br />lea eax,&#91;eax*2+edx&#93;;Multiply by 2 and add digit in edx<br />@1&#58;<br />mov dl,&#91;esi&#93;<br />inc esi<br />sub dl,&quot;0&quot;<br />jns @B ;or jnc<br />ret<br /><br />AsciiToDw endp<br /><br /></code></pre></div>
    <div class="meta">Posted on 2002-08-10 20:05:12 by The Svin</div>
   </div>
   <div class="post" id="post-52575">
    <div class="subject"><a href="#post-52575">Fast a2dw</a></div>
    <div class="body">hi ! :)<br /><br />The Svin,<br /><br />	mov	dl,<br />	sub	dl,'0'<br />	jb	@f<br />	cmp	dl,10<br />	jnb	@f<br /><br />is equal to : if(dl&gt;=0 &amp;&amp; dl&lt;10) ....<br /><br />Ketilo test if it's a vailable number and stop convertion if it's not a number.<br />and for better optimization use 'add' and not 'inc', better pairing is more powerfull :grin: <br /><br />Bye ! :)</div>
    <div class="meta">Posted on 2002-08-10 20:56:57 by kylekiller</div>
   </div>
   <div class="post" id="post-52576">
    <div class="subject"><a href="#post-52576">Fast a2dw</a></div>
    <div class="body">Looks like error testing done outside PROC?<br />Then: is it safe to assume one digit?<pre><code>AsciiToDw proc uses edx ecx, lpAscii&#58;DWORD<br />	mov	ecx, lpAscii<br />	xor	eax, eax<br />; use this line if not assume one digit and move INC ECX<br />;	mov	edx, '0'<br />	movzx	edx, BYTE PTR &#91;ecx&#93;<br />@@&#58;<br />	lea	eax, &#91;eax*4+eax&#93;<br />	inc	ecx<br />	lea	eax, &#91;eax*2+edx-'0'&#93;<br />	movzx	edx, BYTE PTR &#91;ecx&#93;<br />	cmp	edx, '9'+1<br />	jnb	@F<br />	cmp	edx, '0'<br />	jnb	@B<br />@@&#58;<br />	ret<br />AsciiToDw endp</code></pre> I have 7 fast versions of atodw posted to this board. :)</div>
    <div class="meta">Posted on 2002-08-10 21:12:49 by bitRAKE</div>
   </div>
   <div class="post" id="post-52583">
    <div class="subject"><a href="#post-52583">Fast a2dw</a></div>
    <div class="body">With a little twist from <strong>The Svin</strong>'s code, this will now support signed values.<pre><code>&#91;size=9&#93;s_atodw&#58;<br /><br />    mov     edx, &#91;esp+4&#93;<br />    cmp     BYTE PTR &#91;edx&#93;, &quot;-&quot;<br />    je      __negative<br /><br />    __convert&#58;<br /><br />        xor     eax,eax<br />        xor     ecx,ecx<br />        jmp     @1<br />        @@&#58;<br />        lea     eax, &#91;eax*4+eax&#93;    ;Multiply by 5<br />        lea     eax, &#91;eax*2+ecx&#93;    ;Multiply by 2 and add digit in edx<br />        @1&#58;<br />        mov     cl, &#91;edx&#93;<br />        inc     edx<br />        sub     cl, &quot;0&quot;<br />        jns     @B                  ;or jnc<br />        retn    4<br /><br />    __negative&#58;<br /><br />        inc     edx<br />        push    edx<br />        call    __convert<br />        neg     eax<br />        retn    4&#91;/size&#93;</code></pre>or from <strong>Ketilo</strong>'s<pre><code>&#91;size=9&#93;s_atodw&#58;<br /><br />    mov     edx, &#91;esp+4&#93;<br />    cmp     BYTE PTR &#91;edx&#93;, &quot;-&quot;<br />    je      __negative<br /><br />    __convert&#58;<br /><br />        xor     eax,eax<br />        xor     ecx,ecx<br />        <br />        @@&#58;<br />        mov     cl, &#91;edx&#93;<br />        sub     cl, '0'<br />        jb      @f<br />        cmp     cl, 10<br />        jnb     @f<br />        lea     eax, &#91;eax*4+eax&#93;    ;Multiply by 5<br />        lea     eax, &#91;eax*2+ecx&#93;    ;Multiply by 2 and add digit in edx<br />        inc     edx<br />        jmp     @b<br />        @@&#58;<br />        <br />        retn    4<br /><br />    __negative&#58;<br /><br />        inc     edx<br />        push    edx<br />        call    __convert<br />        neg     eax<br />        retn    4&#91;/size&#93;</code></pre>or from <strong>bitRAKE</strong>'s<pre><code>&#91;size=9&#93;s_atodw&#58;<br /><br />    mov     edx, &#91;esp+4&#93;<br />    cmp     BYTE PTR &#91;edx&#93;, &quot;-&quot;<br />    je      __negative<br /><br />    __convert&#58;<br /><br />        xor     eax,eax<br />               <br />        movzx   ecx, BYTE PTR &#91;edx&#93;<br />        @@&#58;<br />        lea     eax, &#91;eax*4+eax&#93;<br />        inc     edx<br />        lea     eax, &#91;eax*2+ecx-'0'&#93;<br />        movzx   ecx, BYTE PTR &#91;edx&#93;<br />        cmp     ecx, '9'+1<br />        jnb     @F<br />        cmp     ecx, '0'<br />        jnb     @B<br />        @@&#58;<br />        <br />        retn    4<br /><br />    __negative&#58;<br /><br />        inc     edx<br />        push    edx<br />        call    __convert<br />        neg     eax<br />        retn    4&#91;/size&#93;</code></pre>Sorry for the code bloat, but more functionality is good. :)</div>
    <div class="meta">Posted on 2002-08-10 22:58:59 by stryker</div>
   </div>
   <div class="post" id="post-52596">
    <div class="subject"><a href="#post-52596">Fast a2dw</a></div>
    <div class="body">This one lets you specify base.   (base 2 up to base 36)<br />It is case insensitive.  You can use &quot;c1a5eb&quot; or &quot;C1A5EB&quot;.  It won't matter.<br /><br /><pre><code>atodw proc uses ecx edx esi, lpszAscii&#58;DWORD, dwBase&#58;DWORD<br /><br />		mov esi,	lpszAscii<br />		xor eax,	eax<br />		jmp 		_GetChar<br />_Alpha&#58;		add cl,		0Ah<br />_Numeric&#58;	cmp ecx,	dwBase<br />		jnc 		_Exit<br />		mul		dwBase<br />		add eax,	ecx<br />		inc 		esi<br />_GetChar&#58;	movzx ecx,	byte ptr &#91;esi&#93;<br />		sub cl,		30h<br />		cmp cl,		0Ah<br />		jc 		_Numeric<br />		sub cl,		11h<br />		and cl,		0DFh<br />		cmp cl,		1Ah<br />		jc 		_Alpha<br />_Exit&#58;		ret<br /><br />atodw endp</code></pre></div>
    <div class="meta">Posted on 2002-08-11 01:25:28 by iblis</div>
   </div>
   <div class="post" id="post-52602">
    <div class="subject"><a href="#post-52602">Fast a2dw</a></div>
    <div class="body">Signed values conversion. Speed optimized.<br /><pre><code><br />; esi-string<br />	cmp &#91;byte esi+0&#93;,'-'+1<br />	sbb ebx,ebx<br />	adc esi,1<br />	movzx eax,&#91;byte esi-1&#93;<br />	sub eax,'0'<br />@@&#58;	movzx ecx,&#91;byte esi+0&#93;<br />	movzx edx,&#91;byte esi+1&#93;<br />	sub ecx,'0'<br />	sub edx,'0'<br />	cmp ecx,9<br />	ja @W<br />	cmp edx,9<br />	ja @F<br />	lea ecx,&#91;ecx+4*ecx&#93;<br />	imul eax,100<br />	lea edx,&#91;edx+2*ecx&#93;<br />	add eax,edx<br />	add esi,2<br />	jmp @B<br />@@&#58;	lea eax,&#91;eax+4*eax&#93;<br />	lea eax,&#91;ecx+2*eax&#93;<br />@W&#58;	add eax,ebx<br />	xor eax,ebx<br />; eax-number<br /></code></pre><br /><br />*Edit*: I find Athlon optimized version</div>
    <div class="meta">Posted on 2002-08-11 02:15:29 by Nexo</div>
   </div>
   <div class="post" id="post-52605">
    <div class="subject"><a href="#post-52605">Fast a2dw</a></div>
    <div class="body">Hi all<br /><br />Assuming PROFILE can be trusted, the results are a bit odd.<br /><br />KetilO</div>
    <div class="meta">Posted on 2002-08-11 03:49:45 by KetilO</div>
   </div>
   <div class="post" id="post-52619">
    <div class="subject"><a href="#post-52619">Fast a2dw</a></div>
    <div class="body">hi ! :)<br /><br />i have optimize just a little bit the proc of bitRake :<br /><br /><br />	mov	ecx, lpAscii<br />	xor	eax, eax<br />	xor	edx,edx<br />                ; use this line if not assume one digit and move INC ECX<br />                ;mov	edx, '0'<br />                ;this instruction decrease speed only here<br />	;movzx	edx, BYTE PTR <br />	mov	dl,BYTE PTR <br />@@:<br />	lea	eax, <br />	inc	ecx<br />	lea	eax, <br />	movzx	edx, BYTE PTR <br />	xor edx, '0'<br />	cmp edx, 10<br />	jb  @B<br />@@:<br /><br /><br /><br />xor edx, '0'<br />cmp edx, 10<br />jb  @B<br /><br />is equivalent to <br /><br />cmp	edx, '9'+1<br />jnb	@F<br />cmp	edx, '0'<br />jnb	@B<br /><br />xor '0' with a number will always give a number &lt;10 ;) :grin: <br /><br />Bye alls ! :alright:</div>
    <div class="meta">Posted on 2002-08-11 06:33:22 by kylekiller</div>
   </div>
   <div class="post" id="post-52647">
    <div class="subject"><a href="#post-52647">Fast a2dw</a></div>
    <div class="body"><div class="quote"><br />Hi all<br /><br />Assuming PROFILE can be trusted, the results are a bit odd.<br /><br />KetilO </div><br /><br />Hi <strong>KetilO</strong>,<br /><br />PROFILE never gave me any problem. If one pretends to use it with MASM, however, this has some (MASM) limitations. Quoting some lines of the MASM translation of PROFILE.INC (it wasn't translated by me, by the way, and I never tested it):<br /><br /><pre><code><br />                                ALIGN            4                              ; align to a cache entry on all CPU's<br />PROFILEROUTINE                  DWORD            ?<br />PROFILECYCLES                   DWORD            ?<br />&#91;...&#93;<br />                                ALIGN           16                              ; align to a cache entry on all CPU's<br />&#91;...&#93;<br />                                ALIGN           16                              ; align to a cache entry on all CPU's<br />@empty&#58;                         RET<br /></code></pre><br /><br />Clearly the <strong>explicitly</strong> required <strong>&quot;align to a cache entry on all CPU's&quot;</strong> and that 4 or 16 after ALIGN are <strong>not</strong> compatible.<br /><br />My advice: use a real assembler. My definition of &quot;real assembler&quot; is a 1:1 assembler that lets you do anything required by low level programming. Unfortunately, the Microsoft Macro Assembler doesn't always fit the definition.<br /><br />Also (it's not your case, though), as I stated many times, care must be spent on understanding that PROFILE calls the routine to be tested 5 times, and although it preserves the EAX..ESP and EFL registers across these 5 internal calls, it cannot save/restore variables held in memory, for example, thus (as you did, anyway, but unlike others) one has to PROFILE a routine which <em>also</em> initializes all memory variables and memory buffers that it will modify (i.e. write <strong>and</strong> read).<br /><br />Last but not least (again, as stated in the documentation not without a reason) &lt;&lt; [..] <em>For such comparative tests, remember to align the same way all the routines to be tested (use ALIGN 64 to align to a cache line on all modern x86 CPUs). </em>&gt;&gt;<br /><br />PS: official FAsm version (previously I released only a NASM version):<br /><br /><pre><code><br />; ---------------------------------------------------------------------------<br />; ***************************************************************************<br />; ---------------------------------------------------------------------------<br />;<br />;<br />; PROFILING MACROs.<br />;<br />;<br />; Original NASM and FASM code &#40;c&#41; 2002 Fabio Bizzetti &#40;a.k.a. Maverick&#41;.<br />; MASM translation by grv575 and improved by others &#40;please claim credits&#41;.<br />;<br />; You can freely use and spread this source code as long as you do not modify<br />; any part of it, including the copyright notice.<br />;<br />; ---------------------------------------------------------------------------<br />;<br />; These MACROs and code are useful to count the exact number of cycles that<br />; it takes to a piece of code to execute. Although not particularly tuned to<br />; the hardware of a certain CPU, PROFILE is designed to work well on all the<br />; past, present and future x86 CPU's, so far with no exceptions known to me.<br />; Please report any exceptions to &#91;email&#93;maverock@libero.it&#91;/email&#93;<br />;<br />; ---------------------------------------------------------------------------<br />;<br />; Use it as follows&#58;<br />;<br />; ... set up your CPU registers as you wish ...<br />; PROFILE yoursubroutine<br />; ... check the results of yoursubroutine, if you wish ...<br />;<br />; i.e. just use &quot;PROFILE&quot; exactly like you would use the CALL instruction,<br />; since registers/CPU flags aren't affected by the profiler.<br />; On return you will get in the 64 bit unsigned integer &#91;PROFILE.CYCLES&#93; the<br />; exact number of cycles it took to yoursubroutine to be executed. Of course,<br />; if you're certain that it took less than 2^32 cycles to execute, you can<br />; access &#91;PROFILE.CYCLES&#93; as a 32bit variable.<br />; Note that the routine self-adapts itself to any past, present and future<br />; CPU's &#40;so you don't have to subtract x cycles depending on your CPU&#41;, it<br />; automatically removes the cost of the last RET in the subroutine it tests<br />; &#40;simulating the test of inlined code, which is usually more useful&#41;, and<br />; it calls it several times to ensure that the caches are setup &#40;you can<br />; also test it uncached, though, but only in ring0.. e.g. in protected mode<br />; Dos, where I used this PROFILE routine most&#41;, and to do it correctly it<br />; saves and restores the CPU registers at each call.. so the only limitation<br />; here is that &#40;being the routine to be tested called more than once&#41;<br />; external pointers or counters must be initialized in your own routine..<br />; about the EAX..ESP and EFL registers instead it's transparent, and behaves<br />; like if yoursubroutine to be tested was called only once.<br />;<br />; The advantages of this routine? It's 100% precise, consistent and stable,<br />; this is my first goal and I've never seen one that behaved better &#40;that's<br />; why I wrote this&#41;. It self adapts to any CPU.. saving you from this major<br />; hassle. It can be used to profile whole subroutines by just using PROFILE<br />; instead of CALL, and giving a 64bit result, it can be used to profile<br />; long-executing routines as well. I still use it much for comparing<br />; different versions of a subroutine on the same dataset, to choose the<br />; fastest one. Also, it's precise down to ~0 cycles &#40;something extremely<br />; troublesome on modern CPU's&#41;.. so that's the most interesting thing IMO..<br />; since it's reliable and can be used to test any routine in a extremely<br />; precise way.<br />;<br />; For such comparative tests, remember to align the same way all the routines<br />; to be tested &#40;use ALIGN 64 to align to a cache line on all modern x86 CPUs&#41;.<br />;<br />; NOTE about all the ALIGN directives in the source&#58;<br />; *YOU* *have* *to* provide and ensure alignment. This *IS* a requirement.<br />;<br />; ---------------------------------------------------------------------------<br />; ***************************************************************************<br />; ---------------------------------------------------------------------------<br /><br />MACRO                           PROFILE         Address &#123;<br />                                MOV             DWORD &#91;_PROFILE.ROUTINE&#93;,Address<br />                                CALL            _PROFILE<br />&#125;<br /><br />; -------------------------------------<br /><br />                                ALIGN           64                              ; align to a cache entry on all CPU's<br /><br />PROFILE.CYCLES&#58;                 DD              0<br />                                DD              0<br />_PROFILE.EMPTY&#58;                 DD              0                               ; how many cycles it takes for a simple RET to be executed on the host CPU<br />                                DD              0<br />_PROFILE.ROUTINE&#58;               DD              0<br />_PROFILE.RETURN&#58;                DD              0<br />_PROFILE.IN.EAX&#58;                DD              0<br />_PROFILE.IN.EBX&#58;                DD              0<br />_PROFILE.IN.ECX&#58;                DD              0<br />_PROFILE.IN.EDX&#58;                DD              0<br />_PROFILE.IN.ESI&#58;                DD              0<br />_PROFILE.IN.EDI&#58;                DD              0<br />_PROFILE.IN.EBP&#58;                DD              0<br />_PROFILE.IN.EFL&#58;                DD              0<br />_PROFILE.OUT.EAX&#58;               DD              0<br />_PROFILE.OUT.EBX&#58;               DD              0<br />_PROFILE.OUT.ECX&#58;               DD              0<br />_PROFILE.OUT.EDX&#58;               DD              0<br />_PROFILE.OUT.EFL&#58;               DD              0<br />_PROFILE.RETADDR&#58;               DD              0<br /><br />; the following is to make sure that data and code are on a different page.<br />                                ALIGN           4096                            ; note&#58; *YOU* have to provide alignment<br /><br />; -------------------------------------<br /><br />                                ALIGN           64                              ; align to a cache entry on all CPU's<br />_PROFILE&#58;<br />                                MOV             DWORD &#91;_PROFILE.IN.EAX&#93;,EAX     ; saves INPUT EAX &#40;will be trashed by CPUID&#41;<br />                                MOV             DWORD &#91;_PROFILE.IN.EBX&#93;,EBX     ; saves INPUT EBX &#40;will be trashed by CPUID&#41;<br />                                MOV             DWORD &#91;_PROFILE.IN.ECX&#93;,ECX     ; saves INPUT ECX &#40;will be trashed by CPUID&#41;<br />                                MOV             DWORD &#91;_PROFILE.IN.EDX&#93;,EDX     ; saves INPUT EDX &#40;will be trashed by CPUID&#41;<br />                                MOV             DWORD &#91;_PROFILE.IN.ESI&#93;,ESI     ; saves INPUT EAX &#40;will be trashed by the routine to be tested, which will be called multiple times&#41;<br />                                MOV             DWORD &#91;_PROFILE.IN.EDI&#93;,EDI     ; saves INPUT EBX &#40;will be trashed by the routine to be tested, which will be called multiple times&#41;<br />                                MOV             DWORD &#91;_PROFILE.IN.EBP&#93;,EBP     ; saves INPUT ECX &#40;will be trashed by the routine to be tested, which will be called multiple times&#41;<br />                                PUSHFD<br />                                POP             DWORD &#91;_PROFILE.IN.EFL&#93;         ; saves INPUT CPU EFLAGS<br />                                POP             DWORD &#91;_PROFILE.RETURN&#93;         ; saves return address<br />                                PUSH            DWORD &#91;_PROFILE.ROUTINE&#93;        ; saves requested _PROFILE.ROUTINE<br />                                MOV             DWORD &#91;_PROFILE.ROUTINE&#93;,.empty ; first we'll profile a simple RET<br />                                MOV             DWORD &#91;_PROFILE.RETADDR&#93;,.ret1<br />                                JMP DWORD       .profile                        ; make sure it gets cached<br />.ret1&#58;                          MOV             DWORD &#91;_PROFILE.RETADDR&#93;,.ret2<br />                                JMP DWORD       .profile                        ; profile for real &#40;well, let it set up&#41;<br />.ret2&#58;                          MOV             DWORD &#91;_PROFILE.RETADDR&#93;,.ret3<br />                                JMP DWORD       .profile                        ; profile for real &#40;well, let it set up again&#41;<br />.ret3&#58;                          MOV             DWORD &#91;_PROFILE.RETADDR&#93;,.ret4<br />                                JMP DWORD       .profile                        ; profile for real &#40;well, let it set up one final time&#41;<br />.ret4&#58;                          MOV             DWORD &#91;_PROFILE.RETADDR&#93;,.ret5<br />                                JMP DWORD       .profile                        ; profile for real<br />.ret5&#58;                          MOV             EAX,DWORD &#91;PROFILE.CYCLES+0&#93;<br />                                MOV             EDX,DWORD &#91;PROFILE.CYCLES+4&#93;<br />                                MOV             DWORD &#91;_PROFILE.EMPTY+0&#93;,EAX    ; saves RET cycles count<br />                                MOV             DWORD &#91;_PROFILE.EMPTY+4&#93;,EDX<br />                                ;<br />                                POP             DWORD &#91;_PROFILE.ROUTINE&#93;        ; restores requested _PROFILE.ROUTINE<br />                                MOV             DWORD &#91;_PROFILE.RETADDR&#93;,.ret6<br />                                JMP BYTE        .profile                        ; make sure it gets cached<br />.ret6&#58;                          MOV             DWORD &#91;_PROFILE.RETADDR&#93;,.ret7<br />                                JMP BYTE        .profile                        ; profile for real<br />.ret7&#58;                          MOV             DWORD &#91;_PROFILE.RETADDR&#93;,.ret8<br />                                JMP BYTE        .profile                        ; make sure it gets cached<br />.ret8&#58;                          MOV             DWORD &#91;_PROFILE.RETADDR&#93;,.ret9<br />                                JMP BYTE        .profile                        ; profile for real<br />.ret9&#58;                          MOV             DWORD &#91;_PROFILE.RETADDR&#93;,.ret10<br />                                JMP BYTE        .profile                        ; make sure it gets cached<br />.ret10&#58;                         MOV             EAX,DWORD &#91;_PROFILE.EMPTY+0&#93;    ; subtracts simple RET overhead<br />                                MOV             EDX,DWORD &#91;_PROFILE.EMPTY+4&#93;<br />                                SUB             DWORD &#91;PROFILE.CYCLES+0&#93;,EAX    ; saves cycles, low 32bit<br />                                SBB             DWORD &#91;PROFILE.CYCLES+4&#93;,EDX    ; saves cycles, high 32bit<br />                                MOV             EAX,DWORD &#91;_PROFILE.OUT.EAX&#93;    ; gives OUTPUT EAX<br />                                MOV             EBX,DWORD &#91;_PROFILE.OUT.EBX&#93;    ; gives OUTPUT EBX<br />                                MOV             ECX,DWORD &#91;_PROFILE.OUT.ECX&#93;    ; gives OUTPUT ECX<br />                                MOV             EDX,DWORD &#91;_PROFILE.OUT.EDX&#93;    ; gives OUTPUT EDX<br />                                PUSH            DWORD &#91;_PROFILE.OUT.EFL&#93;<br />                                POPFD                                           ; gives CPU EFLAGS<br />                                JMP             DWORD &#91;_PROFILE.RETURN&#93;         ; returns to caller<br />.profile&#58;<br />                               ;WBINVD &#40;if you want to test uncached data/code&#41; ; beware, WBINVD is only for ring0<br />                                MOV             EAX,DWORD &#91;PROFILE.CYCLES+0&#93;    ; touches caches<br />                                MOV             EDX,DWORD &#91;PROFILE.CYCLES+4&#93;<br />                                MOV             EAX,DWORD &#91;_PROFILE.IN.EAX&#93;<br />                                MOV             EBX,DWORD &#91;_PROFILE.IN.EBX&#93;<br />                                MOV             ECX,DWORD &#91;_PROFILE.IN.ECX&#93;<br />                                MOV             EDX,DWORD &#91;_PROFILE.IN.EDX&#93;<br />                                MOV             ESI,DWORD &#91;_PROFILE.IN.ESI&#93;<br />                                MOV             EDI,DWORD &#91;_PROFILE.IN.EDI&#93;<br />                                MOV             EBP,DWORD &#91;_PROFILE.IN.EBP&#93;<br />                                MOV             EAX,DWORD &#91;_PROFILE.IN.EFL&#93;<br />                                MOV             EAX,DWORD &#91;_PROFILE.OUT.EAX&#93;<br />                                MOV             EBX,DWORD &#91;_PROFILE.OUT.EBX&#93;<br />                                MOV             ECX,DWORD &#91;_PROFILE.OUT.ECX&#93;<br />                                MOV             EDX,DWORD &#91;_PROFILE.OUT.EDX&#93;<br />                                MOV             EAX,DWORD &#91;_PROFILE.OUT.EFL&#93;<br />                                MOV             EAX,DWORD &#91;_PROFILE.ROUTINE&#93;<br />                                MOV             ECX,32<br />.stack&#58;                         PUSH            EAX                             ; touches stack<br />                                LOOP            .stack<br />                                ADD             esp,128<br />                                XOR             EAX,EAX<br />                                CPUID                                           ; flush pipelines<br />                                RDTSC<br />                                MOV             DWORD &#91;PROFILE.CYCLES+0&#93;,EAX    ; saves TSC, low 32bit<br />                                MOV             DWORD &#91;PROFILE.CYCLES+4&#93;,EDX    ; saves TSC, high 32bit<br />                                XOR             EAX,EAX<br />                                CPUID                                           ; flush pipelines<br />                                MOV             EAX,DWORD &#91;_PROFILE.IN.EAX&#93;     ; restores INPUT EAX<br />                                MOV             EBX,DWORD &#91;_PROFILE.IN.EBX&#93;     ; restores INPUT EBX<br />                                MOV             ECX,DWORD &#91;_PROFILE.IN.ECX&#93;     ; restores INPUT ECX<br />                                MOV             EDX,DWORD &#91;_PROFILE.IN.EDX&#93;     ; restores INPUT EDX<br />                                MOV             ESI,DWORD &#91;_PROFILE.IN.ESI&#93;<br />                                MOV             EDI,DWORD &#91;_PROFILE.IN.EDI&#93;<br />                                MOV             EBP,DWORD &#91;_PROFILE.IN.EBP&#93;<br />                                PUSH            DWORD &#91;_PROFILE.IN.EFL&#93;<br />                                POPFD                                           ; restores CPU EFLAGS<br />                                CALL            DWORD &#91;_PROFILE.ROUTINE&#93;        ; calls the routine to be tested<br />                                MOV             DWORD &#91;_PROFILE.OUT.EAX&#93;,EAX    ; saves OUTPUT EAX<br />                                MOV             DWORD &#91;_PROFILE.OUT.EBX&#93;,EBX    ; saves OUTPUT EBX<br />                                MOV             DWORD &#91;_PROFILE.OUT.ECX&#93;,ECX    ; saves OUTPUT ECX<br />                                MOV             DWORD &#91;_PROFILE.OUT.EDX&#93;,EDX    ; saves OUTPUT EDX<br />                                PUSHFD<br />                                POP             DWORD &#91;_PROFILE.OUT.EFL&#93;        ; saves OUTPUT CPU EFLAGS<br />                                XOR             EAX,EAX<br />                                CPUID                                           ; flush pipelines<br />                                RDTSC<br />                                XCHG            DWORD &#91;PROFILE.CYCLES+0&#93;,EAX<br />                                XCHG            DWORD &#91;PROFILE.CYCLES+4&#93;,EDX<br />                                SUB             DWORD &#91;PROFILE.CYCLES+0&#93;,EAX    ; saves TSC, low 32bit<br />                                SBB             DWORD &#91;PROFILE.CYCLES+4&#93;,EDX    ; saves TSC, high 32bit<br />                                JMP             DWORD &#91;_PROFILE.RETADDR&#93;<br /><br />                                ALIGN           64                              ; align to a cache entry on all CPU's<br />.empty&#58;                         RET<br /><br />; ---------------------------------------------------------------------------<br />; ***************************************************************************<br />; ---------------------------------------------------------------------------<br /></code></pre></div>
    <div class="meta">Posted on 2002-08-11 08:29:23 by Maverick</div>
   </div>
   <div class="post" id="post-52652">
    <div class="subject"><a href="#post-52652">Fast a2dw</a></div>
    <div class="body">Hi  Maverick<br /><br />Thanks for a very useful tool. The results simply shows that optimalisation is too complex to be done on paper alone. It must be tested.<br /><br />KetilO</div>
    <div class="meta">Posted on 2002-08-11 08:49:06 by KetilO</div>
   </div>
   <div class="post" id="post-52665">
    <div class="subject"><a href="#post-52665">Fast a2dw</a></div>
    <div class="body">Hei <strong>KetilO</strong>,<br /><br />Yes, I strongly believe that too. Expecially when one deals with cache-critical routines (i.e. look up tables).<br /><br />Hadet,<br />Maverick</div>
    <div class="meta">Posted on 2002-08-11 10:26:00 by Maverick</div>
   </div>
   <div class="post" id="post-52667">
    <div class="subject"><a href="#post-52667">Fast a2dw</a></div>
    <div class="body">On my AMD I ran your a2dw test program.  These are my results in order from fastest to slowest.<br /><br /><strong>When strlen( lpAscii ) == 0:</strong><br />KetilO<br />The Svin<br />BitRake<br />Nexo<br /><br /><strong>When strlen( lpAscii ) == 1 :</strong><br />BitRake<br />The Svin<br />KetilO<br />Nexo<br /><br /><strong>When strlen( lpAscii ) == 2 :</strong><br />The Svin<br />BitRake<br />KetilO<br />Nexo<br /><br /><strong>When strlen( lpAscii ) == 3 and &gt;= 7:</strong><br />BitRake<br />The Svin<br />KetilO<br />Nexo<br /><br /><strong>When strlen( lpAscii ) &gt;= 4 and &lt;= 6:</strong><br />The Svin<br />BitRake<br />KetilO<br />Nexo<br /><br /><br /><br />Very confusing results.  Nexo's algo performs the worst, but as strlen() gets higher he begins to catch up.  Unfortunately I can only input 8 chars.<br /><br />BitRake and The Svin's algos, the two best performers, seem to be neck and neck most of the time, but The Svin's numbers appear to fluctuate where BitRake's numbers are more steady.</div>
    <div class="meta">Posted on 2002-08-11 10:44:45 by iblis</div>
   </div>
   <div class="post" id="post-52671">
    <div class="subject"><a href="#post-52671">Fast a2dw</a></div>
    <div class="body">On my PIII<br /><br />Fastest first.<br /><br />0 K,S,B,N<br />1 K=S,B,N<br />2 K,B,S,N<br />3 K,B,S,N<br />4 S,K,B,N<br />5 B,S,K,N<br />6 B,S,N,K<br />7 B,S,N,K<br />8 B,N,S,K<br />9 B,S,N,K<br />10 B,S=N,K<br /><br />Very confusing.<br />It should be said that Nexo's has sign and register preservation. So the comparition is not fair.<br /><br />KetilO</div>
    <div class="meta">Posted on 2002-08-11 11:10:36 by KetilO</div>
   </div>
   <div class="post" id="post-52690">
    <div class="subject"><a href="#post-52690">Fast a2dw</a></div>
    <div class="body">I modificate test.<br />Now all proc executed in same address space.<br />It is very significan moment.<br />Also remove sign checking from my proc.<br />Very intresting as was changed results.</div>
    <div class="meta">Posted on 2002-08-11 12:46:05 by Nexo</div>
   </div>
   <div class="post" id="post-52697">
    <div class="subject"><a href="#post-52697">Fast a2dw</a></div>
    <div class="body">here is my try<br /><br /><pre><code><br /><br />AsciiToDw proc uses edx esi,lpAscii&#58;DWORD<br /><br />	mov		esi,lpAscii<br />	xor 		edx,edx	<br />	xor		eax,eax<br />	mov 		bl,&#91;esi&#93;<br />	jmp @checkdigit<br />@@&#58;<br /><br />	lea		eax,&#91;eax*4+eax&#93;		;Multiply by 5<br />	inc		esi<br />	<br />	lea		eax,&#91;eax*2+edx&#93;		;Multiply by 2 and add digit in edx<br /><br />@checkdigit&#58;<br />	mov		dl,&#91;esi&#93;<br />	xor		dl,48<br />	js @F<br />	cmp 		dl,10<br />	jb @B<br /><br />@@&#58;	<br /><br />	ret<br />AsciiToDw endp<br /></code></pre><br /><br />EDIT:<br />update the algo</div>
    <div class="meta">Posted on 2002-08-11 13:11:11 by eko</div>
   </div>
   <div class="post" id="post-52715">
    <div class="subject"><a href="#post-52715">Fast a2dw</a></div>
    <div class="body">Hi !<br /><br />This is my result from my PII 350 :grin: <br /><br /><strong>0 Car</strong><br />Ketilo, The Svin<br />bitRAKE<br />Nexo<br /><br /><strong>1 Car</strong><br />The Svin, bitRAKE<br />Ketilo<br />Nexo<br /><br /><strong>2 Car</strong><br />bitRAKE<br />The Svin<br />Ketilo<br />Nexo<br /><br /><strong>3,4 Car</strong><br />bitRAKE<br />Ketilo<br />The Svin<br />Nexo<br /><br /><strong>5 Car</strong><br />bitRAKE<br />The Svin<br />Nexo<br />Ketilo<br /><br /><strong>6 Car</strong><br />bitRAKE<br />Ketilo, Nexo<br />The Svin<br /><br /><strong>7 Car</strong><br />bitRAKE<br />Nexo<br />The Svin<br />Ketilo<br /><br /><strong>8 Car</strong><br />bitRAKE<br />The Svin<br />Nexo<br />Ketilo<br /><br /><br /><br />So, on My PII bitRake is the Best.<br />Result are very different from AMD and intel :rolleyes: :grin: <br /><br />Bye ! ;)</div>
    <div class="meta">Posted on 2002-08-11 13:51:43 by kylekiller</div>
   </div>
   <div class="post" id="post-52737">
    <div class="subject"><a href="#post-52737">Fast a2dw</a></div>
    <div class="body">Note that only lower end case of PROC exit is tested and IMHO, <strong>Nexo</strong> has &quot;cheated&quot; by eliminating upper end test from his PROC while leaving it in all the others.<br /><br /> Oh, after review of the thread, it appears <strong>Nexo</strong> never tested upper exit case. :grin:<br /><br />Picture (&gt;9k) is worth some words...</div>
    <div class="meta">Posted on 2002-08-11 16:18:22 by bitRAKE</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=7265&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=7265&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="7265" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=7265&amp;page=2">&gt;</a><a href="../?id=7265&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>