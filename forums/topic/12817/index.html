<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Optimization &quot;challenge&quot; + benchmarking - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=12817" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=12817">Optimization &quot;challenge&quot; + benchmarking</a></p>
   <div class="post" id="post-99341">
    <div class="subject"><a href="#post-99341">Optimization &quot;challenge&quot; + benchmarking</a></div>
    <div class="body">A friendly technical discussion on the win32asm board got quite out of hand<br />(<a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=12764">http://www.asmcommunity.net/board/index.php?topic=12764</a>), so<br />here we go.<br /><br />The purpose of the algorithm is the following: multiply the values of an<br />array of 16bit unsigned words with a constant. The array size is 2048 items<br />(one x86 4096 byte page), and the constant chosen is 92. Algorithms that<br />can easily be modifiable to use other constants are cool, but focus should<br />be put on optimizing for the constant 92. Why? Because that was the original<br />constant.<br /><br />The release of this is somewhat rushed, but I'll be gone for the weekend<br />and really want to have some feedback when I get home. Please read through<br />all this, and all the stuff in readme.txt in the zip file, before you run<br />any of the binary code. Benchmark results for built-in functions are not<br />desired; I already have plenty. The benchmarks are just there for your<br />amusement. You _WILL_ want to edit yodel.ini for non-gigahertz machines!<br /><br />Any instructionsets are allowed - algorithms should be classified as<br />&quot;good generic&quot;, &quot;good for pentium or older&quot;, &quot;MMX&quot;, &quot;Athlon&quot;, &quot;Pentium4&quot;.<br />Of course athlon and P4 optimized routines may use MMX as well, as may<br />they use simple instruction sets.<br /><br />This test isn't to be seen as a &quot;P4 vs. Athlon&quot; or a &quot;C/Whatever vs. Assembly&quot;,<br />it's just for fun - with a side purpose of developing a good test/benchmarking<br />base. Of course it's fun to see how we can get Athlons and P4's to perform,<br />especially when effectively taking fractional clocks per multiply :-).<br /><br />The benchmarking/testing suite. I've found myself writing variations of<br />the same code too many times, so now is probably a good time to write something<br />reusable. I call this &quot;yodel&quot;, simply because that was the first word that<br />poppen into my mind when I named the source file. At the time of this writing,<br />it does its job fairly well, but isn't the most flexible nor accurate. Things<br />will change, I hope.<br /><br />If you wish to write your own test function: make a &quot;timedll.dll&quot; that has<br />the export &quot;_func&quot;. This is a STDCALL calling convention function that take<br />a single parameter: a pointer to an array of 2048 16bit unsigned words.<br />The function must return either 1 (success) or 0 (failure) in EAX. In other<br />words, &quot;bool __stdcall func(unsigned short *parm);&quot;  -- for most languages,<br />you will need to write the equivalent of a .def file to get the export name<br />right, or use a hex editor to hack up the binary :-)<br /><br />The idea is to get something that does fairly accurate benchmarks (the timing<br />code should be souped up, perhaps using Maverick's stuff), as well as being<br />&quot;somewhat portable&quot; (by this I mean sane win32 and linux environments. Main<br />reason for linux support is that is I have a P3 class machine running linux,<br />which would be nice to be able to run benchmarks on). In the more distant<br />feature, even nicer things could be added, like a nice GUI, generating test<br />overviews, etc. Scali is working on some code to get system (OS and CPU)<br />information, this will also be used to make the benchmark not try to test<br />routines the current test rig can't handle (SSE2 on a Pentium3, MMX on a pplain,<br />et cetera).<br /><br />There might be other suites around that does this already, but I feel like<br />spending some time writing &quot;my own&quot; - it's something you can learn from.<br />Would also be nice to get some feedback from people and such.<br /><br />--<br />I'd really like people to try this stuff out. If you're going to try your<br />hand at optimizing the algorithm, please use yodel to test it - that way<br />results are comparable. Also, suggestions, bug reports, et cetera. Furthermore,<br />I hope we can maintain a friendly atmosphere. Competitive is a-okay, that's<br />part of the fun anyway, but the keyword here is *FRIENDLY* (and accurate;<br />guesses and mistakes are okay, as long as people are willing to accept their<br />mistakes being corrected. I am.)</div>
    <div class="meta">Posted on 2003-04-25 08:25:37 by f0dder</div>
   </div>
   <div class="post" id="post-99691">
    <div class="subject"><a href="#post-99691">Optimization &quot;challenge&quot; + benchmarking</a></div>
    <div class="body">bump</div>
    <div class="meta">Posted on 2003-04-27 13:22:52 by Hiroshimator</div>
   </div>
   <div class="post" id="post-99699">
    <div class="subject"><a href="#post-99699">Optimization &quot;challenge&quot; + benchmarking</a></div>
    <div class="body">thanks, Hiro.<br />Hope to see some posts soon :)</div>
    <div class="meta">Posted on 2003-04-27 14:05:02 by f0dder</div>
   </div>
   <div class="post" id="post-99823">
    <div class="subject"><a href="#post-99823">Optimization &quot;challenge&quot; + benchmarking</a></div>
    <div class="body">Weird the program still attempt to call the functions through it does not conform<br /><div class="quote">/] running performance tests<br />test01-simple C code          ...021719 ticks (effective 6.342 clk/mul)<br />test02-Ekted 1                ...030359 ticks (effective 8.865 clk/mul)<br />test03-Roticv 1               ...012312 ticks (effective 3.595 clk/mul)<br />test04-Hutch 1                ...017593 ticks (effective 5.137 clk/mul)<br />test05-f0dder imul            ...017594 ticks (effective 5.137 clk/mul)<br />test06-scali MMX              ...003547 ticks (effective 1.036 clk/mul)<br />test07-scali SSE2             ...doesn't conform(!)...002219 ticks (effective -1<br />.#IO clk/mul)<br />test09-Jibz' C++ code         ...026625 ticks (effective 7.774 clk/mul)<br />test10-hutch fmul 1           ...doesn't conform(!)...038704 ticks (effective 11<br />.301 clk/mul)<br />test11-scali athlon1          ...017578 ticks (effective 5.133 clk/mul)</div><br />Just a question, what is wrong with my dll? <br /><pre><code><br />.586<br />.MMX<br />.model flat, stdcall<br />option casemap&#58;none<br /><br />include /masm32/include/windows.inc<br />.code<br />DllEntry proc hInstDLL&#58;DWORD, reason&#58;DWORD, reserved1&#58;DWORD  <br />        ret <br />DllEntry endp <br /><br />_func proc<br />	push	esi<br />	push	edi<br /><br />	mov		esi, &#91;esp+12&#93;<br />	mov		edi, 2048<br />	sub		esi, 2<br /><br />_loop&#58;<br />	movzx	eax, word ptr&#91;esi + edi*2&#93;<br /><br />	; roticv code begin<br />	lea		ecx, &#91;eax*8+eax&#93;	; n * 9<br />	shl		eax, 7				; n * 128<br />	shl		ecx, 2				; n * 36<br />	sub		eax, ecx			; n * 128 - n*36<br />	; roticv code end<br /><br />	mov		&#91;esi + edi*2&#93;, ax<br />	sub		edi, 1<br />	jnz		_loop<br /><br />	pop		edi<br />	pop		esi<br />	mov		eax, 1<br />	ret 4<br />_func endp<br /><br />end DllEntry<br /></code></pre><br />Just testing code, but it seems to fail. Yes I did name it timedll.dll and the function _func.</div>
    <div class="meta">Posted on 2003-04-28 09:30:55 by roticv</div>
   </div>
   <div class="post" id="post-99824">
    <div class="subject"><a href="#post-99824">Optimization &quot;challenge&quot; + benchmarking</a></div>
    <div class="body">roticv, edit the ini file - it lets you change whether to run a function if it doesn't conform (conform=true). Furtheremore, you should set &quot;plain = true&quot; since you don't have MMX.<br /><br />One problem with your DLL is DllMain - it should return 1. Quoting PlatformSDK:<br /><div class="quote"><br />When the system calls the DllMain function with the DLL_PROCESS_ATTACH value, the function returns TRUE if it succeeds or FALSE if initialization fails. If the return value is FALSE when DllMain is called because the process uses the LoadLibrary function, LoadLibrary returns NULL. (The system immediately calls your entry-point function with DLL_PROCESS_DETACH and unloads the DLL.) If the return value is FALSE when DllMain is called during process initialization, the process terminates with an error.<br /></div><br /><br />Next, are you sure &quot;_func&quot; ends up as &quot;_func&quot; in the executable? I can't remember how STDCALL does it when there's on parameters, I'd have though &quot;_func@0&quot;. I should whip up a small DLL template for masm, but there's a lot of stuff on my todo list currently :)</div>
    <div class="meta">Posted on 2003-04-28 09:36:30 by f0dder</div>
   </div>
   <div class="post" id="post-99896">
    <div class="subject"><a href="#post-99896">Optimization &quot;challenge&quot; + benchmarking</a></div>
    <div class="body">f0dder,<br /><br />Instead of measuring ticks, elapsed time is more accurately measured on all Pentium + machines with the processor?s time stamp counter - # of clock cycles since last system reset: Before executing each routine use RDTSC to read the 64 bit counter into EDX:EAX, and save these; after executing the routine use RDTSC to read the new counter into EDX:EAX, and subtract the old values from the new?<br /><br />Here is sample code taken from an example program for Randall Hyde?s HLA. prevTime and qw are 32bit variables (double actually).<br /><br />        rdtsc();<br />        mov( eax, prevTime );<br />        mov( edx, prevTime[4] );<br /><br />?? routine to be timed<br /><br />        rdtsc();<br />        sub( prevTime, eax );<br />        sbb( prevTime[4], edx );<br />        mov( eax, (type dword qw));<br />        mov( edx, (type dword qw[4]));<br /><br />Remember the brackets and semicolon are not used in NASM, MASM code, and src, dest order is reversed in the HLA instructions compared to NASM, MASM. In MASM code, that would be (I think ?)<br /><br />        rdtsc<br />        mov prevTime, eax<br />        mov prevTime[4], edx<br /><br />?? routine to be timed<br /><br />        rdtsc<br />        sub eax, prevTime<br />        sbb edx, prevTime[4]<br />        mov qw, eax<br />        mov qw[4], edx<br /><br />Using the sensitive clock counter (less than 1 nanosecond per clock on a 1GHz + machine) instead of ticks (milliseconds), you can time 2048 multiplications and the clock count would be a 32 bit number (in EAX only ? 32 bit # clocks is 1.4 seconds on a 3GHz processor). To get # of clocks (including decimal places) per iteration divide by 2048 (or right shift 11 bits to get integer clock count). Each test would therefore take less than 1 millsecond on any processor including a 166MHz Pentium MMX machine.<br /><br />If an insensitive measure like ticks are counted, you need to do a long test ---1 million iterations of 2048 multiplications just for each test to take a few seconds 2.53GHz Pentium 4 (enough to be able to divide and get a reasonable average), however, on a 166MHz Pentium MMX machine, for example, each test now takes minutes. And by 2004, 10 GHz Pentium 6 machines would be too fast for your code again anyway.<br /><br />Now IF YOU NEED TO use ticks, since you are measuring the clock speed at the start of the program, you should probably use different numbers of iterations for different speeds: a simple way of doing it would be to divide the clock speed in MHz by 100 and use that as an index into a table of # of iterations to use:<br /><br />0 (0-99 MHz) ? 50,000 ; the first figure is increased by necessity<br />1 (100-199) ? 50,000<br />2 (200-299) ? 100,000<br />3 (300-399) ? 150,000<br />4 (400-499) ? 200,000<br />?..<br />20 (2000-2100) ? 1,000,000<br /><br />[2 GHz and above use 1,000,000? for simplicity, and so as not to have an infinite table] Or simply multiply clock speed in MHz by 500 (as above).<br /><br /><br />Easiest solution: Measure clock cycles with RDTSC. If you do that you may not even NEED to bump the process priority up?. </div>
    <div class="meta">Posted on 2003-04-28 22:08:58 by V Coder</div>
   </div>
   <div class="post" id="post-99921">
    <div class="subject"><a href="#post-99921">Optimization &quot;challenge&quot; + benchmarking</a></div>
    <div class="body"><strong>f0dder</strong>, nice work.  I tried to do a similar thing with macros for a timing test framework.  How about a general program that would work for any test routines?  I litte more involved but your half way there.  The expected input and parameters would have to be defined, then each routine would have an information block stating it's requirements (MMX,K3D,SSE).  There could be a whole bank of test to run on new chips like x86-64, Crusoe, emulators -- to get a feel for their strengths or weaknesses.</div>
    <div class="meta">Posted on 2003-04-28 23:52:12 by bitRAKE</div>
   </div>
   <div class="post" id="post-99944">
    <div class="subject"><a href="#post-99944">Optimization &quot;challenge&quot; + benchmarking</a></div>
    <div class="body">VCoder, thanks but I already know :)<br />I was planning to use RDTSC in the timing later on (I'm already using that approach in in CPU speed detection.) - I still want to run through a few iterations, but you're definitely right about not having to run through as much to get stable results. I'll want to use the full 64bit range of RDTSC too.<br /><br />I think it's fair to assume at least pentium/rdtsc in the benchmarking. I wouldn't like developing on/for anything less. As for process priority bumping... well, it's already a togglable option in the INI file. I like it, because it gives more accurate results (very very few ms off by each iteration). Of course if your code doesn't even run for a full timeslice, it might not be necessary... but I'll leave in the option (and time with in on myself).<br /><br />bitRAKE, that's exactly what I want to do :). scali has made up a nice piece of code that detects a helluvalot CPU information (and converts intel cache descriptor format to AMD - ie, same interface). Functions like hasFPU, hasMMX, hasSSE (etc) will be used to only run the supported tests. Linux version on the way, too.<br /><br />One of the very important parts of this benchmark thingy is the conformance tests. Ok, you don't necessarily spot errors by just feeding in random numbers, but it works most of the time. And conformance testing _is_ pretty important imo.<br /><br />Well, I think I'll get some more work done on yodel today. Perhaps the linux port, perhaps rdtsc timing. Probably adding in scalis CPU feature detection code.</div>
    <div class="meta">Posted on 2003-04-29 01:56:55 by f0dder</div>
   </div>
   <div class="post" id="post-100042">
    <div class="subject"><a href="#post-100042">Optimization &quot;challenge&quot; + benchmarking</a></div>
    <div class="body">f0dder.<br /><br />I notice that SSE2 (3 instructions operate on 8 words) is twice as fast as MMX (3 instructions operate on 4 words). Yet, only Pentium 4 processors (and Opeteron) have SSE2 capability, whilst all Pentium MMX or later processors have MMX capability. It is not just AMD users at risk. Intel still sells Pentium III processors for notebooks. Therecore compatibility is a primary concern across the board. SSE2 coders must test for compatibility and include an MMX optimized version of their code anyway...<br /><br />I am interested in the timings for a partially unrolled loop of scali's MMX. I'm wondering how much of a penalty the sub and jnz are, and therefore if one unroll will speed up measureably.<br /><br />Can you include this test in the next release please. In addition to the standard MMX Test,<br /><br /><pre><code><br />	mov	edi, &#40;2048&#41; / 4 ; we can do 4 words at a time with MMX<br />	sub	esi, 8<br /><br />.loop&#58;<br />	; scali code begin<br />	movq	mm0, &#91;esi + &#40;edi*8&#41;&#93;<br />	pmullw	mm0, &#91;UBER_CONSTANT&#93;<br />	movq	&#91;esi + &#40;edi*8&#41;&#93;, mm0<br />	; scali code end<br /><br />	sub	edi, 1<br />	jnz	.loop<br /></code></pre><br /><br />Please have scali MMX partial unroll...<br /><br /><pre><code><br />	mov	edi, &#40;2048&#41; / 8 ; we can do 4 words &#40;twice&#41; at a time with MMX<br />	sub	esi, 16<br /><br />.loop&#58;<br />	; scali code &#40;twice&#41; begin<br />	movq	mm0, &#91;esi + &#40;edi*8&#41;&#93;<br />	pmullw	mm0, &#91;UBER_CONSTANT&#93;<br />	movq	&#91;esi + &#40;edi*8&#41;&#93;, mm0<br /><br />	movq	mm0, &#91;esi + &#40;edi*8&#41;+8&#93;<br />	pmullw	mm0, &#91;UBER_CONSTANT&#93;<br />	movq	&#91;esi + &#40;edi*8&#41;+8&#93;, mm0	; scali code end<br /><br />	sub	edi, 2<br />	jnz	.loop<br /></code></pre><br /><br />Thanks much.</div>
    <div class="meta">Posted on 2003-04-29 08:10:48 by V Coder</div>
   </div>
   <div class="post" id="post-100048">
    <div class="subject"><a href="#post-100048">Optimization &quot;challenge&quot; + benchmarking</a></div>
    <div class="body"><div class="quote"><br />SSE2 coders must test for compatibility and include an MMX optimized version of their code anyway...<br /></div><br />Sure, just like you shouldn't provide solely 3dnow. I think it's safe+okay to require a minimum of pentium+mmx, unless you're specifically targetting lesser CPUs.<br /><br />When doing routines optimized for the more funky instruction sets, you should choose either the optimized or the &quot;plain&quot; version runtime, depending on CPU capabilities. This can be done in a number of ways. The easiest is probably a function pointer, but you could do code overwriting too.<br /><br />I'll have a look at your unrolled routine when I get home.</div>
    <div class="meta">Posted on 2003-04-29 08:39:53 by f0dder</div>
   </div>
   <div class="post" id="post-100095">
    <div class="subject"><a href="#post-100095">Optimization &quot;challenge&quot; + benchmarking</a></div>
    <div class="body"><strong>V Coder</strong>, don't forget the latency of the multiple instruction - you will have to unroll further and use more mmx registers to get that jump in speed your looking for!</div>
    <div class="meta">Posted on 2003-04-29 10:21:43 by bitRAKE</div>
   </div>
   <div class="post" id="post-100109">
    <div class="subject"><a href="#post-100109">Optimization &quot;challenge&quot; + benchmarking</a></div>
    <div class="body">On my P4, the MMX unrolling had about no effects. On my kid brothers' athlon700, it improved stuff nicely. The unrolling is probably somewhat naive :).<br />MMX*1: 002263 ticks (effective 0.773 clk/mul)<br />MMX*4: 001162 ticks (effective 0.397 clk/mul)<br /><br />Original routine:<br /><pre><code><br />_time6@4&#58;<br />	mov		eax, &#91;esp+4&#93;<br />	mov		ecx, &#40;2048&#41; / 4 ; we can do 4 words at a time with MMX<br />	sub		eax, 8<br /><br />align 16<br />.loop&#58;<br />	; scali code begin<br />	movq	mm0, &#91;eax + &#40;ecx*8&#41;&#93;<br />	pmullw	mm0, &#91;UBER_CONSTANT&#93;<br />	movq	&#91;eax + &#40;ecx*8&#41;&#93;, mm0<br />	; scali code end<br /><br />	sub		ecx, 1<br />	jnz		.loop<br /><br />	mov		eax, 1<br />	emms ; yeah, required for MMX<br />	ret 4<br /></code></pre><br /><br />4x unrolled:<br /><pre><code><br />_time12@4&#58;<br />	; we can do 4 words at a time with MMX, and loop is 2x unrolled - but x16<br />	; isn't possible in effective address calculation, so we do it the old way.<br />	mov		eax, &#91;esp+4&#93;<br />	mov		ecx, &#40;2048*2&#41;<br />	movq	mm0, &#91;UBER_CONSTANT&#93;<br /><br />align 16<br />.loop&#58;<br />	movq	mm1, &#91;eax + 0&#93;<br />	movq	mm2, &#91;eax + 8&#93;<br />	movq	mm3, &#91;eax + 16&#93;<br />	movq	mm4, &#91;eax + 24&#93;<br /><br />	pmullw	mm1, mm0<br />	pmullw	mm2, mm0<br />	pmullw	mm3, mm0<br />	pmullw	mm4, mm0<br /><br />	movq	&#91;eax + 0&#93;, mm1<br />	movq	&#91;eax + 8&#93;, mm2<br />	movq	&#91;eax + 16&#93;, mm3<br />	movq	&#91;eax + 24&#93;, mm4<br /><br />	add		eax, &#40;4*2*4&#41;<br />	sub		ecx, &#40;4*2*4&#41;<br />	jnz		.loop<br /><br />	mov		eax, 1<br />	emms<br />	ret		4<br /></code></pre><br /><br />You will notice that the 4x unroll loads the constant in a register, while the single version constantly uses it from memory. On the P4, there wasn't a difference between the two. Also, the 4x unroll has a &quot;plain&quot; loop structure (no &quot;complex&quot; effective addresses, add+sub), where the 1x version has &quot;eax + (ecx*8)&quot; - on my P4, changing the 1x version to &quot;plain&quot; caused a major slowdown.</div>
    <div class="meta">Posted on 2003-04-29 11:06:18 by f0dder</div>
   </div>
   <div class="post" id="post-100138">
    <div class="subject"><a href="#post-100138">Optimization &quot;challenge&quot; + benchmarking</a></div>
    <div class="body"><strong>f0dder</strong>, 0.375 clk/mul is maximum possible on Athlon MMX - that's close enough. :)</div>
    <div class="meta">Posted on 2003-04-29 12:44:06 by bitRAKE</div>
   </div>
   <div class="post" id="post-100294">
    <div class="subject"><a href="#post-100294">Optimization &quot;challenge&quot; + benchmarking</a></div>
    <div class="body">Well, that's fast. I like the code rearrangement too...<br /><br /><strong>edit</strong><br />How soon can we download yodel_06 or later? Thanks.</div>
    <div class="meta">Posted on 2003-04-30 07:09:34 by V Coder</div>
   </div>
   <div class="post" id="post-100296">
    <div class="subject"><a href="#post-100296">Optimization &quot;challenge&quot; + benchmarking</a></div>
    <div class="body">I have a preliminary linux version of yodel running now; if I'm not too trashed after work, I might work on rdtsc timing in the evening.</div>
    <div class="meta">Posted on 2003-04-30 07:17:39 by f0dder</div>
   </div>
  </div>
 </body>
</html>