<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>From Rigid Body Dynamics To RagDoll Physics - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17249" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=17249">From Rigid Body Dynamics To RagDoll Physics</a></p>
   <div class="post" id="post-133680">
    <div class="subject"><a href="#post-133680">From Rigid Body Dynamics To RagDoll Physics</a></div>
    <div class="body">Anyone had any involvement in implementing rigid body dynamics under Direct3D?</div>
    <div class="meta">Posted on 2004-02-16 06:07:07 by Homer</div>
   </div>
   <div class="post" id="post-134511">
    <div class="subject"><a href="#post-134511">From Rigid Body Dynamics To RagDoll Physics</a></div>
    <div class="body">Wow, none of you have EVER simulated physics as far as dynamics is concerned? jeez.. thats kinda slack.<br />I've not played with physics in years myself, and my most recent physics related code would have been the Particles demo I posted some time ago.<br /><br />Can you imagine a modern 3D game without a realistic physics engine?<br />No? Me either.<br /><br />It's not difficult to impart concepts such as velocity, mass and angular velocity to objects in 3D, the difficulties lay in &quot;collision response&quot;.<br />This problem can be broken down to a series of intersection tests between points and planes - if a collision occurs between two objects, or between an object and a static surface (like the terrain or a wall), we are really talking about one of two major cases: a point on Object A intersects a surface in the world (whether its another object is irrelevant at this point), or, a surface of Object A is intersected by a point in the world (could belong to another object, could belong to terrain etc).<br />Obviously there's special cases, for example the concurrent intersection of N points (think of a cube at rest on a flat surface - theres 4 points in contact)<br />This lends itself to my existing intersection codebase, which can be used to test all points of A against all planes of B and vice versa, or perform more specific tests against given points/planes.<br /><br />I'm thinking of implementing RagDoll Physics as a demo by loading the model from an xfile (skinnedmesh) and then just ripping its bone information into a scenegraph and applying my own rotation limit constraints at the joints, then applying simplistic &quot;rubberbanding&quot; physics as seen in the classic &quot;Thrust&quot; game from the BBC era (elasticity=0).<br /><br />Have I woken anyone up yet? :)</div>
    <div class="meta">Posted on 2004-02-22 22:30:55 by Homer</div>
   </div>
   <div class="post" id="post-134512">
    <div class="subject"><a href="#post-134512">From Rigid Body Dynamics To RagDoll Physics</a></div>
    <div class="body">YEAH I GUESS WE DID NOT</div>
    <div class="meta">Posted on 2004-02-22 22:37:00 by comrade</div>
   </div>
   <div class="post" id="post-134515">
    <div class="subject"><a href="#post-134515">From Rigid Body Dynamics To RagDoll Physics</a></div>
    <div class="body">Guess the 2D shooter with a lookup table doesn't count?<br /><br />Okay, didn't think so. :)</div>
    <div class="meta">Posted on 2004-02-22 22:46:17 by bitRAKE</div>
   </div>
   <div class="post" id="post-134555">
    <div class="subject"><a href="#post-134555">From Rigid Body Dynamics To RagDoll Physics</a></div>
    <div class="body">2D shooters ALWAYS count - they can't help it :)<br /><br />The original 'Thrust' was certainly 2D, but that didn't stop it modelling rigid body dynamics :)</div>
    <div class="meta">Posted on 2004-02-23 07:28:36 by Homer</div>
   </div>
   <div class="post" id="post-134610">
    <div class="subject"><a href="#post-134610">From Rigid Body Dynamics To RagDoll Physics</a></div>
    <div class="body">I have a .dxf file containing about 3260 meshes exported from poser (a bald woman), I have made a class in java(which easily could be translated to asm) that both loads from .dxf and rotates it, havent had the time to find out that for example meshes 1-300 is left arm, 301-500 is head etc and animate it<br />no texture, and no idea how to wrap in dx the textures right<br />actually had a idea to add lots of curved lines with collisiondetection against head/shoulders+apply forces on it (wind/gravity)<br />so theoretically, shall I think of a single hair=many many lines, gravitymodel=chain, with each part having its downward force+areaversuswind=windforce<br /><br /><br />sorry my rambling<br /><br />can you please be more specific what you ask?<br />you maybe should add a &quot;material class&quot; that contains:<br />mass<br />frictioncoffecient<br />elasticity modul<br />density<br />weight(not the same as mass)<br />etc<br /><br />simple bouncing when it only comes to 90degree is change xspeed sign if I bounce into one wall in that direction, change yspeed if bounce on &quot;roof&quot;,&quot;floor&quot; etc<br />bounce according to normals, like lights?<br />I for example stand on a metal floor that is tilted 30 degrees, I need to use trigometric to get downwards/forward force<br />I need to multiply gravity with frictioncoffecient for floor, to get frictionforce, to know if I slide or not<br />density for right material*volume of object to get a realistic mass, weight for different gravity constants<br /><br />I also have an idea I tried out in dx, C++, about world model:<br />I am standing on a disc (sealevel sea) and everything outside this disc is changed with Y, according to (Z-discradius),(curve not linear), creating a worldmodel with horizon=edge of disc, below this disc is clipped out and far behind the &quot;horizon&quot; disc I might see tops of himalaya, but the base of himalaya is hidden below the horizon</div>
    <div class="meta">Posted on 2004-02-23 16:46:03 by daydreamer</div>
   </div>
   <div class="post" id="post-134646">
    <div class="subject"><a href="#post-134646">From Rigid Body Dynamics To RagDoll Physics</a></div>
    <div class="body">My animated skinmesh support requires only a single weighted mesh, along with keyframed animation data. Try exporting to .x instead of .dxf<br /><br />I have built the inheriting classes for physical objects up as follows:<br /><br />CTexture - Base class (does not inherit), provides loading, saving, editing and referencing functionality for Textures. <br /><br />CMesh - Base class (does not inherit), provides loading, rendering and referencing functionality for Meshes.<br /><br />CCullableThing - Inherits from CMesh, thus provides all CMesh functionality, as well as providing boundinggeom-based Culling functions, and a Render function which &quot;thunks down&quot; to call the CMesh Render if the object is not culled. Less obviously, it also provides per-object rotation and position fields.<br /><br />CBullet - Inherits from CCullableThing, providing all the above support, as well as physics-related fields like velocity, angular velocity, etc.<br /><br />Thus, we can create more &quot;top level classes&quot; like CBullet, which each have their own unique physics handlers. It would be the CBullet class which should be generalized to provide a generic physics class, maybe call it something like CRigidBody and make CBullet inherit from that instead would be an example.<br /><br />As for the mathematics of planar deflections, rather than simply &quot;Reversing the signs&quot; of the velocity of a particle/object, we should examine the Normal of the surface that was hit, and use its Normal as the &quot;vector of restitution&quot;, which should be a &quot;normalized normal&quot;, ie of Unit length.<br />This means that a flat floor surface has a &quot;vector of restitution&quot; which points directly up, and that the &quot;coefficient of restitution&quot; is 1, which means NO energy is lost when the collision occurs. We can think of this value as being the &quot;bounciness&quot; of the floor, for a swamp we'd have a very low coefficient. We should never have &gt;1 since the object would gain speed from each collision lol.</div>
    <div class="meta">Posted on 2004-02-23 23:34:40 by Homer</div>
   </div>
   <div class="post" id="post-135066">
    <div class="subject"><a href="#post-135066">From Rigid Body Dynamics To RagDoll Physics</a></div>
    <div class="body">What I've decided to do is the following:<br />We keep velocity and orientation for each Object.<br />Let's call this object A. Velocity is something which applies to the entire body, therefore, the velocity of all &quot;Particles&quot; of A all = the velocity of A, and we can keep just one common Velocity value per Object (note - we can think of Velocity as being applied to ParticleSystem A). Similarly, Orientation is something which affects the entire group of Particles which form an object, and so we keep per-object Orientation values, whichever rotation system we may be using being irrelevant.<br /><br />The orientation is a set of rotations about A's origin and nominal axes. Rather than apply this orientation to all the vertices of object A when we want to perform per-vertex intersection testing for collisions, we instead apply the inverse of object A's rotation to the CENTER of object B. Thus we are examining for intersections of A with B in object A's local context (ie we are in model space of A). Once we have rotated the CENTER of object B around the center of object A, we can then determine which vertices of object A are closest to the center of object B.<br />At this point, we're ready to apply the first intersection test, which is just boundingsphere (radius check). If we find an intersection of the spheres, we should now apply the inverse rotation matrix of A (from earlier) to all the vertices of B, and then we can begin point-to-face intersection tests.<br />Should we find intersection occurs, we calculate the reactive forces PER VERTEX based on the weighted mass of each vertex, which is precalculated based on the mass of the object, number of vertices, and distance of each vertex from its origin.<br />Now we can calculate the forces applied to all vertices, and add them to calculate the total change to the object.<br /><br />Think of it this way : imagine that an alien space fiend hurls a crate at you (since alien space fiends and crates are ubiquitously associated), now imagine that the floor is (gasp) uneven - and worse - that the alien space fiend has put some nasty backspin on the crate, and it's rotating out of control as it sails across the room ... (at the moment, all the vertices of the object have equal forces acting on them) - one corner of the crate catches on the uneven floor (an impulse is applied to one vertex of the object), and the crate's behaviour changes, as the result of the collision exerts torque (force=resistance to change in orientation over time) and  reflective displacement of velocity apon that vertex. Seeing as how this vertex truly is a good neighbour, he immediately shares the resultant forces with the other vertices in that object. The net result of that can be obtained by simply adding the per-vertex forces of the object, and using the resulting values as change in object rotation and position.<br />Did I mention that the object has a given Mass, and that the per-vertex Mass is calculated based on the object Mass , number of vertices , and distance of each vertex to the object center of gravity? :)</div>
    <div class="meta">Posted on 2004-02-29 02:21:42 by Homer</div>
   </div>
  </div>
 </body>
</html>