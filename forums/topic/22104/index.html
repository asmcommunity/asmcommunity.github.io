<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>MEMORY MOVQ QUESTION / RGB565 to RGB88 using MMX - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=22104" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=22104">MEMORY MOVQ QUESTION / RGB565 to RGB88 using MMX</a></p>
   <div class="post" id="post-166384">
    <div class="subject"><a href="#post-166384">MEMORY MOVQ QUESTION / RGB565 to RGB88 using MMX</a></div>
    <div class="body">I wrote the following ASM/MMX code to convert 16bit RGB565 into 24big RGB888.&nbsp; After running this code I have realized there is something about the MOVQ command that I don&#39;t fully understand.&nbsp; The original implementation of this routine was missing the &quot;psrlq&nbsp; &nbsp; &nbsp;  mm0,16&quot; line of code, and some of my color channels were getting obliterated.&nbsp; When I include the &quot;psrlq&nbsp; &nbsp; &nbsp;  mm0,16&quot; line my color channel integrity in maintained, but my images gets slid to the left a pixel or two (hard to tell which just by visual inspection).&nbsp; Before the &quot;psrlq&nbsp; &nbsp; &nbsp;  mm0,16&quot; the image always came out looking rather red.&nbsp; I guess what I really need to know is what is happening (absolutely) when I &quot;movq		,mm0&quot;.<br /><br />For instance.&nbsp; If edi = 100 and edx = 0, where, exactly, do the 64 bits from mm0 end up in memory?&nbsp; I was assuming that the mm0 register would fill memory slots 100-108, but now I&#39;m starting to guess that it&#39;s actually more like 92-100 (or something).<br /><br />Any insight you can provide will be appreciated.<br /><br />-Dave/Esotic<br /><br /><pre><code><br />			//dz| code in question<br />			CQWORD mask_r= 0xf800f800f800f800;<br />			CQWORD mask_g= 0x07e007e007e007e0;<br />			CQWORD mask_b= 0x001f001f001f001f;<br />			CQWORD mask_1= 0x00ff000000000000;<br />			CQWORD mask_2= 0x000000ff00000000;<br />			CQWORD mask_3= 0xffffffffffff0000;<br />			CQWORD mask_4= 0xffffffffffffffff;<br /><br />			int XLOOP = XRES / 2;<br /><br />			_asm{<br />				mov			esi,pCurrentSource			//esi &lt;- Pointer to RGB565 Memory<br />				mov			edi,pCurrentOutput			//edi &lt; -Pointer to RGB88 Memory<br />				xor			ebx,ebx						//ebx &lt;- 0 (ebx ^ ebx)<br />				xor&nbsp; &nbsp; &nbsp; &nbsp;  edx,edx<br />				mov			ecx,XLOOP					//ecx &lt;- X resolution / 2, as we&#39;re doing 2 24bit pixels at a time<br />RGB565TO888_X:<br />				movq		mm0,				//mm0 &lt;- source<br />				movq		mm3,<br />				movq&nbsp; &nbsp; &nbsp; &nbsp; mm1,mm0<br />				movq&nbsp; &nbsp; &nbsp; &nbsp; mm4,mm3<br />				movq&nbsp; &nbsp; &nbsp; &nbsp; mm2,mm0<br />				movq&nbsp; &nbsp; &nbsp; &nbsp; mm5,mm3<br />				<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm0,mask_r //r<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm3,mask_r //r<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm1,mask_g //g<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm4,mask_g //g<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm2,mask_b //b<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm5,mask_b //b<br /><br />				psrlw&nbsp; &nbsp; &nbsp;  mm0,8&nbsp; &nbsp; &nbsp; //r<br />				psrlw&nbsp; &nbsp; &nbsp;  mm3,13	&nbsp;  //r		<br />				psrlw&nbsp; &nbsp; &nbsp;  mm1,3&nbsp; &nbsp; &nbsp; //g<br />				psrlw&nbsp; &nbsp; &nbsp;  mm4,9&nbsp; &nbsp; &nbsp; //g<br />				psllw&nbsp; &nbsp; &nbsp;  mm2,3&nbsp; &nbsp; &nbsp; //b<br />				psrlw&nbsp; &nbsp; &nbsp;  mm5,2&nbsp; &nbsp; &nbsp; //b<br /><br />				por&nbsp; &nbsp; &nbsp; &nbsp;  mm0,mm3 //r<br />				por&nbsp; &nbsp; &nbsp; &nbsp;  mm1,mm4 //g<br />				por&nbsp; &nbsp; &nbsp; &nbsp;  mm2,mm5 //b<br />				<br />				movq&nbsp; &nbsp; &nbsp; &nbsp; mm3,mm0 //r<br />				movq&nbsp; &nbsp; &nbsp; &nbsp; mm4,mm1 //g<br />				movq&nbsp; &nbsp; &nbsp; &nbsp; mm5,mm2 //b<br /><br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm0,mask_1<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm1,mask_1<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm2,mask_1<br /><br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm3,mask_2<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm4,mask_2<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm5,mask_2<br /><br />				psllq&nbsp; &nbsp; &nbsp;  mm0,8<br />				psrlq&nbsp; &nbsp; &nbsp;  mm2,8<br />				<br />				psrlq&nbsp; &nbsp; &nbsp;  mm4,8<br />				psrlq&nbsp; &nbsp; &nbsp;  mm5,16<br />				<br />				por&nbsp; &nbsp; &nbsp; &nbsp;  mm0,mm1<br />				por&nbsp; &nbsp; &nbsp; &nbsp;  mm0,mm2<br />				por&nbsp; &nbsp; &nbsp; &nbsp;  mm0,mm3<br />				por&nbsp; &nbsp; &nbsp; &nbsp;  mm0,mm4<br />				por&nbsp; &nbsp; &nbsp; &nbsp;  mm0,mm5<br />				<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm0,mask_3<br />				psrlq&nbsp; &nbsp; &nbsp;  mm0,16 // &lt;- Line Needed to Maintain Color Channel Integrity<br /><br />				//--------------------<br />				movq		,mm0	//??š &lt;- mm0 ??<br /><br />				//movq&nbsp; &nbsp; &nbsp; &nbsp; ,mm7<br /><br />				//movq&nbsp; &nbsp; &nbsp; &nbsp; mm7,mask_3<br />				//psrlq&nbsp; &nbsp; &nbsp;  mm7,16<br /><br />				//movq		,mm7<br /><br />				add			ebx,4			// ebx &lt;- 2 16bit Pixels<br />				add&nbsp; &nbsp; &nbsp; &nbsp;  edx,6&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  //move 2x24BPP<br />				//--------------------<br />				// X•ûŒü‚Ìƒ‹??[ƒv??ˆ—??<br />				dec			ecx				// ecx &lt;- ecx-1<br />				jnz		RGB565TO888_X<br />				emms<br />			}<br /><br />		}<br /></code></pre></div>
    <div class="meta">Posted on 2005-09-28 08:48:00 by Esotic</div>
   </div>
   <div class="post" id="post-166388">
    <div class="subject"><a href="#post-166388">Re: MEMORY MOVQ QUESTION / RGB565 to RGB88 using MMX</a></div>
    <div class="body">If you are using movq, you are moving 64bit. If you are using movd, you are moving 32bit. So all 64 bit is copied to your memory since you are using movq.<br /><br />Can you give me more information on 16bit RGB 565 and 24bit RGB888? Maybe I could be of some help.</div>
    <div class="meta">Posted on 2005-09-28 09:30:08 by roticv</div>
   </div>
   <div class="post" id="post-166391">
    <div class="subject"><a href="#post-166391">Re: MEMORY MOVQ QUESTION / RGB565 to RGB88 using MMX</a></div>
    <div class="body"><br />I understand the difference between moving a Quadword and a Word, but what I&#39;m wondering is where EXACTLY do those bits go into memory?<br /><br />RGB565 is 16Bit color where there are 5 red bits, 6 green bits, and 5 blue bits RRRRRGGG GGGBBBBB, so 0xFFFF = white RGB565 Pixel<br /><br />RGB888 is 24Bit color where there are 8 red bits, 8 green bits, and 8 blue bits RRRRRRRR GGGGGGGG BBBBBBBB, so 0xFFFFFF = white RGB888 Pixel<br /><br />I was under the assumption that I could expand the two RGB565 pixels residing in the 4 high order bytes of the MM register into two RGB888 pixels that would take up the 6 highest order bytes, then write those bytes out to  which would get incremented by 6 each loop as I only really wanted the 6 high order bytes.&nbsp; But color channels kept getting obliterated and as a test I started shifting the 6 bytes of RGB888 into the lowest order BYTES of the MM register and now my color channels are ok, but the image gets shifted to the left by a pixel or two.&nbsp; I know there is something about how the MOVQ command is writing to memory that I don&#39;t understand, I&#39;m just not sure what it is.&nbsp; :-\<br /><br />Thank,<br /><br />-Dave/Esotic</div>
    <div class="meta">Posted on 2005-09-28 09:43:57 by Esotic</div>
   </div>
   <div class="post" id="post-166396">
    <div class="subject"><a href="#post-166396">Re: MEMORY MOVQ QUESTION / RGB565 to RGB88 using MMX</a></div>
    <div class="body">Not that I fully understand why this works, but I was to &quot;fix&quot; the code so that it works withour error (or so it would appear).&nbsp; The trick is to start edx at 6 (just got lucky trying any dumb thing).&nbsp; &quot;mov&nbsp; &nbsp; &nbsp; &nbsp;  edx,0x06&quot;&nbsp; <br /><br />Just in case anyone out there needs to convert 565to888.<br /><br /><pre><code><br />			//dz| do nothing for now<br />			CQWORD mask_r= 0xf800f800f800f800;<br />			CQWORD mask_g= 0x07e007e007e007e0;<br />			CQWORD mask_b= 0x001f001f001f001f;<br />			CQWORD mask_1= 0x00ff000000000000;<br />			CQWORD mask_2= 0x000000ff00000000;<br />			CQWORD mask_3= 0xffffffffffff0000;<br />			CQWORD mask_4= 0xffffffffffffffff;<br />			//CQWORD six = 0xffffffffffffffff;<br /><br />			int XLOOP = XRES / 2;<br /><br />			_asm{<br />				mov			esi,pCurrentSource			//esi &lt;- s_ptr<br />				mov			edi,pCurrentOutput			//edi &lt; -d_ptr<br />				xor			ebx,ebx						//ebx &lt;- 0 (ebx ^ ebx)<br />				xor&nbsp; &nbsp; &nbsp; &nbsp;  edx,edx<br />				mov&nbsp; &nbsp; &nbsp; &nbsp;  edx,0x06<br />				mov			ecx,XLOOP					//ecx &lt;- 80<br />RGB565TO888_X:<br />				movq		mm0,				//mm0 &lt;- source<br />				movq		mm3,<br />				movq&nbsp; &nbsp; &nbsp; &nbsp; mm1,mm0<br />				movq&nbsp; &nbsp; &nbsp; &nbsp; mm4,mm3<br />				movq&nbsp; &nbsp; &nbsp; &nbsp; mm2,mm0<br />				movq&nbsp; &nbsp; &nbsp; &nbsp; mm5,mm3<br />				<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm0,mask_r //r<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm3,mask_r //r<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm1,mask_g //g<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm4,mask_g //g<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm2,mask_b //b<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm5,mask_b //b<br /><br />				psrlw&nbsp; &nbsp; &nbsp;  mm0,8&nbsp; &nbsp; &nbsp; //r<br />				psrlw&nbsp; &nbsp; &nbsp;  mm3,13	&nbsp;  //r		<br />				psrlw&nbsp; &nbsp; &nbsp;  mm1,3&nbsp; &nbsp; &nbsp; //g<br />				psrlw&nbsp; &nbsp; &nbsp;  mm4,9&nbsp; &nbsp; &nbsp; //g<br />				psllw&nbsp; &nbsp; &nbsp;  mm2,3&nbsp; &nbsp; &nbsp; //b<br />				psrlw&nbsp; &nbsp; &nbsp;  mm5,2&nbsp; &nbsp; &nbsp; //b<br /><br />				por&nbsp; &nbsp; &nbsp; &nbsp;  mm0,mm3 //r<br />				por&nbsp; &nbsp; &nbsp; &nbsp;  mm1,mm4 //g<br />				por&nbsp; &nbsp; &nbsp; &nbsp;  mm2,mm5 //b<br />				<br />				movq&nbsp; &nbsp; &nbsp; &nbsp; mm3,mm0 //r<br />				movq&nbsp; &nbsp; &nbsp; &nbsp; mm4,mm1 //g<br />				movq&nbsp; &nbsp; &nbsp; &nbsp; mm5,mm2 //b<br /><br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm0,mask_1<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm1,mask_1<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm2,mask_1<br /><br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm3,mask_2<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm4,mask_2<br />				pand&nbsp; &nbsp; &nbsp; &nbsp; mm5,mask_2<br /><br />				psllq&nbsp; &nbsp; &nbsp;  mm0,8<br />				psrlq&nbsp; &nbsp; &nbsp;  mm2,8<br />				<br />				psrlq&nbsp; &nbsp; &nbsp;  mm4,8<br />				psrlq&nbsp; &nbsp; &nbsp;  mm5,16<br />				<br />				por&nbsp; &nbsp; &nbsp; &nbsp;  mm0,mm1<br />				por&nbsp; &nbsp; &nbsp; &nbsp;  mm0,mm2<br />				por&nbsp; &nbsp; &nbsp; &nbsp;  mm0,mm3<br />				por&nbsp; &nbsp; &nbsp; &nbsp;  mm0,mm4<br />				por&nbsp; &nbsp; &nbsp; &nbsp;  mm0,mm5<br />				<br />				//pand&nbsp; &nbsp; &nbsp; &nbsp; mm0,mask_3<br />				psrlq&nbsp; &nbsp; &nbsp;  mm0,16 // &lt;- Line Needed to Maintain Color Channel Integrity<br /><br />				//--------------------<br />				movq		,mm0	//??š &lt;- mm0 ??o—??ƒf??[ƒ^‚ð??‘‚«??ž‚Þ??š<br /><br />				//movq&nbsp; &nbsp; &nbsp; &nbsp; ,mm7<br /><br />				//movq&nbsp; &nbsp; &nbsp; &nbsp; mm7,mask_3<br />				//psrlq&nbsp; &nbsp; &nbsp;  mm7,16<br /><br />				//movq		,mm7<br /><br />				add			ebx,4			// ebx &lt;- ebx+8<br />				add&nbsp; &nbsp; &nbsp; &nbsp;  edx,6&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  //move 2x24BPP<br />				//--------------------<br />				// X•ûŒü‚Ìƒ‹??[ƒv??ˆ—??<br />				dec			ecx				// ecx &lt;- ecx-1<br />				jnz		RGB565TO888_X<br />				emms<br />			}<br /><br />		}<br /></code></pre></div>
    <div class="meta">Posted on 2005-09-28 11:32:38 by Esotic</div>
   </div>
   <div class="post" id="post-166397">
    <div class="subject"><a href="#post-166397">Re: MEMORY MOVQ QUESTION / RGB565 to RGB88 using MMX</a></div>
    <div class="body">I&#39;ve also tried converting 565 to 888 with mmx, and the result is that mmx is useless here. It&#39;s possible to make an mmx converter, but it&#39;s ten times slower than using normal instructions.<br /><pre><code><br />;---[16-&gt;24]--------\<br />	mov dx,<br />	mov al,dl<br />	shl al,3<br />	mov ,al<br />	shr dx,5<br />	mov al,dl<br />	shl al,2<br />	mov ,al<br />	shr dx,6<br />	shl dl,3<br />	mov ,dl<br />;-------------------/<br /></code></pre><br />Using ebx and ecx, you can convert a second pixel, in parallel (on newer AMD cpus). <br />Also, you could do a trick or two to increase write-bandwidth (because now writing a byte requires reading of 8bytes, internally to the cpu). That is, if the cpu&#39;s write-queue buffer isn&#39;t advanced. <br />1) use a stack-based array to write one scanline, then in the end do aligned-copy to the output frame<br />2) combine two pixels, then write 6 bytes<br />3) use mmx registers as temporary vars to hold 8 converted pixels, and then write 8-byte aligned data to framebuffer. </div>
    <div class="meta">Posted on 2005-09-28 11:44:53 by Ultrano</div>
   </div>
   <div class="post" id="post-166401">
    <div class="subject"><a href="#post-166401">Re: MEMORY MOVQ QUESTION / RGB565 to RGB88 using MMX</a></div>
    <div class="body">Thanks you, Ultrano, for the ASM lesson.<br /><br />The code you posted is faster, but not by a factor of 10.&nbsp; Your code gets 3 more FPS under heavy load, but I think that counts for something.<br /><br />After removing some of the superflous shifting in my MMX version (low order bits) I was hitting 18FPS, while your code was hitting 19FPS.&nbsp; What I am wondering now is how to use mm6 and mm7 to store the other 2 pixels worth of data that is generated at the beginning of my loop and then discarded.&nbsp; I&#39;ll be sure to post my findings.<br /><br />You wouldn&#39;t happen to have a library of graphics related ASM code you&#39;d like to share, would you?&nbsp; :)<br /><br />I would kinda expect that to be online somewhere.<br /><br />Thanks,<br /><br />-Dave/Esotic</div>
    <div class="meta">Posted on 2005-09-28 12:31:13 by Esotic</div>
   </div>
   <div class="post" id="post-166402">
    <div class="subject"><a href="#post-166402">Re: MEMORY MOVQ QUESTION / RGB565 to RGB88 using MMX</a></div>
    <div class="body"><br />ok, i officially give up trying to make that MMX any faster.&nbsp; you win.<br /><br />:)<br /><br />-Dave/Esotic</div>
    <div class="meta">Posted on 2005-09-28 12:50:40 by Esotic</div>
   </div>
   <div class="post" id="post-166405">
    <div class="subject"><a href="#post-166405">Re: MEMORY MOVQ QUESTION / RGB565 to RGB88 using MMX</a></div>
    <div class="body">Hmmm... now I&#39;m trying to convert in the other direction and am having trouble<br /><br /><pre><code><br />				mov			esi,pCurrentSource			//esi &lt;- s_ptr<br />				mov			edi,pCurrentOutput			//edi &lt; -d_ptr<br />				mov			ecx,XRES					//ecx &lt;- 720<br />RGB888TO565_X2:<br />				mov dx,<br />				mov ah,dh<br />				and ah,0xF8<br />				and dx,0x00FF<br />				shl dx,5<br />				or&nbsp; ax,dx<br />				mov dx,<br />				and dx,0xFF00<br />				shr dx,11<br />				or&nbsp; ax,dx<br />				mov ,ax<br />				add esi,3<br />				add edi,2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />				dec ecx	<br />				jnz		RGB888TO565_X2<br /><br /><br /></code></pre></div>
    <div class="meta">Posted on 2005-09-28 13:19:07 by Esotic</div>
   </div>
   <div class="post" id="post-166406">
    <div class="subject"><a href="#post-166406">Re: MEMORY MOVQ QUESTION / RGB565 to RGB88 using MMX</a></div>
    <div class="body"><br />Here&#39;s the finalized working code<br /><br /><pre><code><br /><br />			_asm{<br />				mov			esi,pCurrentSource			//esi &lt;- s_ptr<br />				mov			edi,pCurrentOutput			//edi &lt; -d_ptr<br />				mov			ecx,XRES					//ecx &lt;- 80<br />RGB888TO565_X2:<br />				mov al, //r<br />				//mov al,dl<br />				and al,0xF8<br />				shl ax,8<br />				mov dl, //g<br />				and dx,0x00FC<br />				shl dx,3<br />				or&nbsp; ax,dx<br />				mov dl, //b<br />				//and dl,0xF8<br />				shr dl,3<br />				or&nbsp; ax,dx<br />				mov ,ax<br />				//shl al,3<br />				//mov ,al<br />				//shr dx,5<br />				//mov al,dl<br />				//shl al,2<br />				//mov ,al<br />				//shr dx,6<br />				//shl dl,3<br />				//mov ,dl<br />				add			esi,3			// ebx &lt;- ebx+8<br />				add&nbsp; &nbsp; &nbsp; &nbsp;  edi,2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  //move 2x24BPP<br />				//--------------------<br />				// X•ûŒü‚Ìƒ‹??[ƒv??ˆ—??<br />				dec			ecx				// ecx &lt;- ecx-1<br />				jnz		RGB888TO565_X2<br />				//emms<br />			}<br />		}<br /><br /></code></pre><br /><br />I gotta learn to start using the debugger before posting my bug-ridden code.&nbsp; :)</div>
    <div class="meta">Posted on 2005-09-28 14:38:13 by Esotic</div>
   </div>
   <div class="post" id="post-166417">
    <div class="subject"><a href="#post-166417">Re: MEMORY MOVQ QUESTION / RGB565 to RGB88 using MMX</a></div>
    <div class="body">The third optimization trick I came up (converting in blocks of 8 pixels, using mmx for write) got only a 10% speedup, doing one pixel in 12 cycles on my PC (AthlonXP 2000+, 400MHz DDR):<br /><pre><code><br />Hihi proc uses eax ebx ecx edx esi edi pDest,pSrc,numPix<br />	mov esi,pSrc<br />	mov edi,pDest<br />	<br />	.data<br />		mask0 dq&nbsp; 0FCF8F8FCF8F8FCF8h<br />		mask1 dq&nbsp; 0F8F8FCF8F8FCF8F8h<br />		mask2 dq&nbsp; 0F8FCF8F8FCF8F8FCh<br />		<br />	.code<br />	<br />	<br />	.while numPix&gt;=8<br />		mov edx,<br />		mov eax,<br />		mov ebx,<br />		mov ecx,<br />		;------[ 2 pixels ]--------\<br />		mov ecx,edx<br />		<br />		movzx eax,dx<br />		shl dx,5<br />		shl eax,8<br />		shr ax,5<br />		mov ah,dh<br />		<br />		mov ebx,ecx<br />		shl cx,5<br />		shr ebx,8<br />		shr bx,5<br />		mov bh,ch<br />		<br />		movd mm0,eax<br />		movd mm1,ebx<br />		;--------------------------/<br />		<br />		;------[ 2 pixels ]--------\<br />		mov edx,dword ptr<br />		mov ecx,edx<br />		<br />		movzx eax,dx<br />		shl dx,5<br />		shl eax,8<br />		shr ax,5<br />		mov ah,dh<br />		<br />		mov ebx,ecx<br />		shl cx,5<br />		shr ebx,8<br />		shr bx,5<br />		mov bh,ch<br />		<br />		movd mm2,eax<br />		movd mm3,ebx<br />		;--------------------------/<br />		<br />		;------[ 2 pixels ]--------\<br />		mov edx,dword ptr<br />		mov ecx,edx<br />		<br />		movzx eax,dx<br />		shl dx,5<br />		shl eax,8<br />		shr ax,5<br />		mov ah,dh<br />		<br />		mov ebx,ecx<br />		shl cx,5<br />		shr ebx,8<br />		shr bx,5<br />		mov bh,ch<br />		<br />		movd mm4,eax<br />		movd mm5,ebx<br />		;--------------------------/<br />		<br />		;------[ 2 pixels ]--------\<br />		mov edx,dword ptr<br />		mov ecx,edx<br />		<br />		movzx eax,dx<br />		shl dx,5<br />		shl eax,8<br />		shr ax,5<br />		mov ah,dh<br />		<br />		mov ebx,ecx<br />		shl cx,5<br />		shr ebx,8<br />		shr bx,5<br />		mov bh,ch<br />		<br />		movd mm6,eax<br />		movd mm7,ebx<br />		;--------------------------/<br />			<br />		; data is<br />		;3(mm0)+3(mm1)+2(mm2)<br />		;1(mm2)+3(mm3)+3(mm4)+1(mm5)<br />		;2(mm5)+3(mm6)+3(mm7)<br />		<br />		psllq mm1,24<br />		por mm0,mm1<br />		movq mm1,mm2<br />		psllq mm1,48<br />		por mm0,mm1<br />		<br />		psrlq mm2,16<br />		psllq mm3,8<br />		psllq mm4,32<br />		por mm2,mm3<br />		por mm2,mm4<br />		movq mm1,mm5<br />		psllq mm1,56<br />		por mm2,mm1<br />		<br />		psrlq mm5,8<br />		psllq mm6,16<br />		psllq mm7,40<br />		por mm5,mm6<br />		por mm5,mm7<br />		<br />		<br />		pand mm0,mask0&nbsp;  ; you can remove these, for 1 cycle speedup<br />		pand mm2,mask1	 ; tradeoff is that red+=green/32 (max error=7/256)<br />		pand mm5,mask2<br />		<br />		movq qword ptr,mm0<br />		movq qword ptr,mm2<br />		movq qword ptr,mm5<br />		<br />	<br />		<br />		<br />		add esi,16<br />		add edi,24<br />		sub numPix,8<br />	.endw<br />	<br />	.while numPix<br />		;---[16-&gt;24]--------\<br />		mov dx,<br />		mov al,dl<br />		shl al,3<br />		mov ,al<br />		shr dx,5<br />		mov al,dl<br />		shl al,2<br />		mov ,al<br />		shr dx,6<br />		shl dl,3<br />		mov ,dl<br />		add esi,2<br />		add edi,3<br />		;-------------------/<br />		dec numPix<br />	.endw<br />	<br />	<br />	<br />	<br />	ret<br />Hihi endp<br /></code></pre><br /><br />If we remove the mask, we save another cycle per pixel, but the red channel will have 2.7% extra brigtness, depending on green channel. Try improving the mmx instructions&#39; overlapping to save 1-2 cycles per 8-pix block on Intel cpus. <br />I tried pipelining the regular instructions, but it didn&#39;t give any extra speed, so I reverted to the readable sequence of the code (2-pixel blocks&#39; conversion)</div>
    <div class="meta">Posted on 2005-09-28 19:05:57 by Ultrano</div>
   </div>
   <div class="post" id="post-166419">
    <div class="subject"><a href="#post-166419">Re: MEMORY MOVQ QUESTION / RGB565 to RGB88 using MMX</a></div>
    <div class="body">On x86, I have almost no code for graphics. But for my PalmOS games, I&#39;ve made an arsenal of procs - in C and ARM9 asm. Not procedural, just texture/sprite-based. <br /><br /><br />edit: :shock: I&#39;ve made a mistake in the benchmark results - it turned out the optimization is actually 26%, instead of 10% , and each pixel takes 9 cycles to convert&nbsp; ^^&#39; . </div>
    <div class="meta">Posted on 2005-09-28 19:12:29 by Ultrano</div>
   </div>
  </div>
 </body>
</html>