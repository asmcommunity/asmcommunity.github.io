<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Some help to start. - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29746" />
    <link rel="next" href="../?id=29746&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29746">Some help to start.</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29746&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29746&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29746" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29746&amp;page=2">&gt;</a><a href="../?id=29746&amp;page=2">&raquo;</a></form>   <div class="post" id="post-210100">
    <div class="subject"><a href="#post-210100">Some help to start.</a></div>
    <div class="body"><br />Hi,<br /><br />First of all, I&#039;m sorry for my bad english, I&#039;m from Brazil and I don&#039;t know english ._.<br /><br />Anyway, I&#039;m new to assembly programming, and I have some doubts about assembly.<br /><br />1ยบ Wich is the difference about assembly 16bits and assembly 32bits?<br />2ยบ I&#039;ve read here, that &quot;Art of assembly language&quot; book has own syntax, is this true?<br />3ยบ I want to learn the basis of assembly language, not only windows api like some programs I&#039;ve saw.<br />4ยบ Wich is the best book of assembly?<br /><br />I&#039;m sorry about the english guys ._.<br />I&#039;m also trying to lean english ._.<br /><br />Someone can help me? Thanks.<br /><br />See you soon!</div>
    <div class="meta">Posted on 2009-12-28 14:22:41 by Defcon</div>
   </div>
   <div class="post" id="post-210108">
    <div class="subject"><a href="#post-210108">Re: Some help to start.</a></div>
    <div class="body">Well, I&#039;m pretty new to assembly myself, but here are some of my thoughts (I&#039;m mostly just regurgitating some of what I have learned recently):<br /><br />1. &nbsp;This is quite a general question, but there are a couple of main differences:<br />-16 bits will pretty much be DOS development, otherwise you are looking at 32 bits: &nbsp;i.e Windows, Linux, plus many other smaller players.<br />-16 bits is, for most people&#039;s intents and purposes, dead for PC development (unless you are looking to develop for embedded systems), although there is still some activity.<br />-the available instructions, for the most part, will be the same for 16 and 32 bits: &nbsp;the difference will be that the assembler will generate a prefix byte on the assembled instructions; in 16 bit mode, the prefix byte will be on 32 bit instructions and vice versa in 32 bit mode. &nbsp;The idea being in 16 bit mode you try to use mostly 16 bit instructions: &nbsp;i.e. deal mostly with the 16 bit registers (ax, bx, cx, dx, di, si, bp, sp) and in 32 bit mode use eax, ebx, ecx, edx, edi, esi, ebp, and esp.<br />-16 bit mode also forces you to use the segment registers to address any significant amount of memory &gt; 64 KB whereas 32 bit mode allows you to address 4 GB directly.<br />In conclusion, although there is a lot of old 16 bit tutorials and books out there, you probably want to start in 32 bit mode: &nbsp;it is going to be a lot easier to learn in and there is starting to be quite a bit of available information/tutorials.<br /><br />2. &nbsp;Yes, the latest version of Art of Assembly is written for use with HLA, which is designed to be a beginner&#039;s learning guide. &nbsp;However, you can find older versions through search engines (this is what I am using to teach myself).<br /><br />3. &nbsp;It doesn&#039;t really matter what OS you use: &nbsp;you are really going to have to learn an API, whether it be Windows API, Linux API, DOS API, or a hobby OS API. &nbsp;However you may want to look into FASMLIB which allows you to skip some of the API learning (in exchange for learning FASMLIB). &nbsp;I haven&#039;t tried it myself, but I think you can use it with most common assemblers.<br /><br />4. &nbsp;Art of Assembly is certainly a great start. &nbsp;You may just want to google &quot;NASM Assembly tutorial&quot; and start from there. &nbsp;There are lots of good sites/forums out there: &nbsp;for example <a target="_blank" href="http://www.drpaulcarter.com/pcasm/index.php">http://www.drpaulcarter.com/pcasm/index.php</a> (from the google search above) although it has a few languages, unfortunately Portuguese doesn&#039;t seem to be one of them.<br /><br />This forum has a good resource:&nbsp; <a target="_blank" href="http://www.asmcommunity.net/book/">http://www.asmcommunity.net/book/</a>.&nbsp; Also try the FAQs at <a target="_blank" href="http://board.flatassembler.net/">http://board.flatassembler.net/</a>.<br /><br />It doesn&#039;t really make a difference which assembler you use (it is relatively easy to learn another once you have learned one): &nbsp;I started with NASM, but am finding that I like FASM better and am starting to port my code (what little I have written) to it.<br />MASM probably has the most examples out there, but there is plenty of NASM info as well. &nbsp;Depending on how much programming you have done (I&#039;m thinking especially with linkers), you may get your first program up and running faster with MASM, but I would recommend starting with FASM (the initial learning curve isn&#039;t too bad - if you can get the example programs, particularly &#039;hello world&#039; to assemble and run, you are well on your way) - you won&#039;t have to deal with linking. &nbsp;Most NASM tutorials are also quite applicable to FASM as the syntax is very similar.<br /><br />Hopefully this helps you get started: good luck!<br /><br /></div>
    <div class="meta">Posted on 2009-12-29 18:43:32 by sysfce2</div>
   </div>
   <div class="post" id="post-210114">
    <div class="subject"><a href="#post-210114">Re: Some help to start.</a></div>
    <div class="body">When your projects start to grow larger (think Little Shop Of Horrors), they become unbearably slow to build.<br />That&#039;s where generating OBJ files and using a Linker really comes into its own.<br />I never really understood why Linking obj files was useful until I started coding OOPASM under MASM/ObjAsm32.<br />Rather than simply assembling *everything*, we can assemble *COMPONENT OBJECTS*.<br />Now when we build our &quot;main project&quot;, we can link these prebuilt OBJ files, which &quot;vastly&quot; improves build times.<br />As an example, a project which normally takes 45 seconds to assemble from scratch might take 5 seconds when linking to prebuilt component objects.<br />For a developer, this can translate into a massive saving in development time, since you&#039;re no longer wandering off to make a coffee every time you fix a bug/rebuild your project.<br />And if these component objects contain code that is generally useful, you&#039;ll find yourself linking them into various projects, magnifying the benefits, and saving you from reinventing the wheel / debugging yet another implementation of the same old code you wrote for that previous project some months ago.<br /><br /></div>
    <div class="meta">Posted on 2009-12-29 21:24:50 by Homer</div>
   </div>
   <div class="post" id="post-210119">
    <div class="subject"><a href="#post-210119">Re: Some help to start.</a></div>
    <div class="body"><div class="quote">When your projects start to grow larger (think Little Shop Of Horrors), they become unbearably slow to build.<br />That&#039;s where generating OBJ files and using a Linker really comes into its own.</div><br /><br />Yeah, but for a starting point, FASM bypasses the problems that linkers can pose to beginners. &nbsp;Although listing imports might be just as hard (I actually haven&#039;t tried building a program directly with FASM yet as I was focusing on getting my project to build - all my source is broken up into fairly small modules, for the reasons you state, and also because NASM seems to run slow on my machine with even moderate sized sources - part of the reason I am trying out FASM) but it doesn&#039;t look that bad though - the initial learning curve would likely be (slightly) higher than MASM, but I think in the long run leads to a better understanding of how assembly works.<br />But if using a linker, <a target="_blank" href="http://www.jorgon.freeserve.co.uk/">GoLink</a> is an easy to use tool.<br /><br />NASM (with NASMX for windows) is probably easier to use when starting out if generating .OBJ files and linking as I had to tweak the FASM macros to work with .OBJ files. &nbsp;Also, if the OP doesn&#039;t mind using windows, GoAsm looks like a good tool. &nbsp;I just don&#039;t particularly like the syntax as it is not what I am familiar with.<br /><br />I had to google what Little Shop of Horrors was - but it looks like a good analogy.</div>
    <div class="meta">Posted on 2009-12-29 23:38:11 by sysfce2</div>
   </div>
   <div class="post" id="post-216322">
    <div class="subject"><a href="#post-216322">Re: Some help to start.</a></div>
    <div class="body">All I meant to convey to the new user is that code can be reused and that you can start to make your own code base from nothing. You are free to be you.<br /></div>
    <div class="meta">Posted on 2012-10-06 08:31:49 by Homer</div>
   </div>
   <div class="post" id="post-216327">
    <div class="subject"><a href="#post-216327">Re: Some help to start.</a></div>
    <div class="body">Hello defcon,<br />I will attempt to explain a little further:<br /><br /><div class="quote"><br />...I have some doubts about assembly.<br /></div><br />Perhaps you mean <em>questions about assembly</em>.<br /><br /><div class="quote"><br />1ยบ Wich is the difference about assembly 16bits and assembly 32bits?<br /></div><br />Initially, the difference is based upon the architecture of the microprocessor that the program is going to be run on. <br />Microprocessors have typically been 8-bit, 16-bit, 32-bit, 64-bit, etc. <br />The number of bits used in a microprocessor has to do with several factors dealing with the CPU design and architecture. <br />The width of the data bus is one factor, the number of bits used to form memory addresses is another and the number of bits used to form the CPU registers is another factor.<br />Nearly everything a CPU does (execute instructions) is done with the CPU registers. <br />Some CPU instructions bypass the registers and manipulate memory directly.<br />Some early 8-bit CPUs used simple registers and they were named: A,B,C,D, etc.<br /><br />Later, when it was determined that CPUs needed more bits, to perform more complex instructions, the number of bits was increased to 16. <br />The register names were modified to reflect that they were eXtended from what they had been previously and renamed: AX,BX,CX,DX, etc.<br />For the benefit of programmers, the original 8-bits could still be accessed by referring to them as either: AH/AL, (for: A-High/A-Low), BH/BL, CH/CL, etc.<br />A 16-bit assembler is designed to create programs that generally run on a 16-bit microprocessor.<br />MS-DOS and Windows 3.x are 16-bit operating systems that runs on 16-bit CPUs.<br /><br />A 32-bit assembler is designed to create programs that generally run on a 32-bit microprocessor. <br />An exception would be that, (depending on the operating system), in some cases, 16-bit instructions can be assembled and executed on a 32-bit CPU.<br />32-bit registers are named: EAX,EBX,ECX,EDX, etc.<br />Many modern CPUs have a backward compatibility, so to speak.<br />Windows 98 and upwards are 32-bit (and/or 64-bit) operating systems.<br /><br /><div class="quote"><br />2ยบ I&#039;ve read here, that &quot;Art of assembly language&quot; book has own syntax, is this true?<br /></div><br /><br />Well, no..., not really.<br /><br />The book: &quot;ART OF Assembly Language Programming&quot; by: Randall L. Hyde ((c) Copyright 1995), is perhaps one of the best for the Assembly Language beginner.<br />This book is fully illustrated and teaches beginner to advanced Assembly Language concepts.<br /><br />Randy Hyde is also the author of <span class="strike">Assembly High Level Language</span> (or rather) *&quot;High Level Assembly&quot;, which is something entirely different. <br />High Level Assembly Language is an effort to create a programming dialect which uses high level syntax, (found in all modern programming languages) to facilitate writing programs in a pseudo-Assembly Language.<br /><br />Assembly Language and HLA are very different things and not at all the same.<br /><br /><div class="quote"><br />3ยบ I want to learn the basis of assembly language, not only windows api like some programs I&#039;ve saw.<br /></div><br /><br />The Windows API (Application Programming Interface) is perhaps the most widely known. <br />Apple&#039;s OS also has an API, (I have not used it). <br />Linux has what some call an API, but, I hesitate to call it that, (that is only an opinion). <br />In fact, Linux does have an API, it&#039;s just a mess.<br /><br />MS-DOS didn&#039;t really have an API, (...perse).<br />DOS, instead, used interrupts to make system calls to make things happen.<br />Nearly everything you did in DOS was through calling interrupts.<br />When writing DOS programs, if you want keyboard input, you call an interrupt to perform that function.<br />If you want to display to the console screen, you call an interrupt to display to the console screen.<br />(Personally), I find programming in DOS to be a rather fun thing to do, but, I rarely do it any more, nor does anyone else, other than students of Assembly Language programming.<br /><br /><div class="quote"><br />4ยบ Wich is the best book of assembly?<br /></div><br /><br />Well, that really depends on what you want to program.<br />What Assembler will you be using ?<br />What type of computer or device will you be programming on ?<br />What operating system will you be using ?<br /><br />I recommend for beginners to learn to program DOS.<br />Modern programming begins when you start using the API.<br /><br />Search Amazon.com for cheap, used, MS-DOS Assembly Language books.<br />Also, look for used, Windows programming books.<br /><br />BTW,<br />I must add, that there is no <em>ONE</em> Assembly Language.<br />Dialects of Assembly Language will vary between CPUs and again between Assemblers of the same CPU.<br />In other words, first you decide which CPU you will be working with. That will narrow the field to certain assemblers.<br />Then you decide which assembler you wish to use. <br />That will determine the dialect you will be learning.<br />Most books published on the subject of Assembly Language are based on MASM, the Microsoft Macro Assembler.<br /><br />edit:<br />I stand corrected, edited for corrections.<br />*I have been a member of Randy&#039;s AOA group for many years, &#039;tho I have never quite grasped the point of an HLL for Assembly Language.<br />I always thought C was a suitable HLL for Assembly Language.<br />In my opinion, HLA was a misnomer, a sort of oxymoron.<br /></div>
    <div class="meta">Posted on 2012-10-09 14:41:51 by blakguypeez</div>
   </div>
   <div class="post" id="post-216334">
    <div class="subject"><a href="#post-216334">Re: Some help to start.</a></div>
    <div class="body"><div class="quote"> Windows 98 and upwards are 32-bit operating systems.</div><br /><br />And since Windows Server 2003/XP, there is also support for 64-bit x86 processors (called x64 by Microsoft).<br /><br /><div class="quote"> Windows 98 <br /><div class="quote"><br />2ยบ I&#039;ve read here, that &quot;Art of assembly language&quot; book has own syntax, is this true?<br /></div><br /><br />Well, no..., not really.<br /><br />The book: &quot;ART OF Assembly Language Programming&quot; by: Randall L. Hyde ((c) Copyright 1995), is perhaps one of the best for the Assembly Language beginner.<br />This book is fully illustrated and teaches beginner to advanced Assembly Language concepts.<br /><br />Randy Hyde is also the author of &quot;Assembly High Level Language&quot;, which is something entirely different. <br />Assembly High Level Language is an effort to create a programming dialect which uses high level syntax, (found in all modern programming languages) to facilitate writing programs in a pseudo-Assembly Language.<br /><br />Assembly Language and A-HLL are very different things and not at all the same.</div><br /><br />I think the confusion here is that there are multiple editions of Art of Assembly Language.<br />The original book was aimed at 16-bit DOS, and used MASM as the assembler.<br />The second edition was aimed at 32-bit, and came in linux and Windows versions, and for this, Randall Hyde introduced his own assembler (which I think is called HLA: High-Level Assembly, not A-HLL).<br /><br />You can find all editions here: http://www.plantation-productions.com/Webster/www.artofasm.com/index.html</div>
    <div class="meta">Posted on 2012-10-17 05:38:14 by Scali</div>
   </div>
   <div class="post" id="post-216335">
    <div class="subject"><a href="#post-216335">Re: Some help to start.</a></div>
    <div class="body">Pretty good book here:<br />http://www.abreojosensamblador.net/Productos/AOE/html/Pags_en/Preamble.html<br />Originally written in Spanish, most of the chapters have been translated to English. Examples are mostly available for Masm, Fasm, and Nasm - which gives it a big advantage, IMO. Worth a look!<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2012-10-17 10:26:39 by fbkotler</div>
   </div>
   <div class="post" id="post-216336">
    <div class="subject"><a href="#post-216336">Re: Some help to start.</a></div>
    <div class="body"><div class="quote"><br />Randall Hyde introduced his own assembler (which I think is called HLA: High-Level Assembly, not A-HLL).<br /></div><br /><br />Thanks, Scali.<br />I stand corrected.&nbsp; ;)<br /></div>
    <div class="meta">Posted on 2012-10-18 13:08:51 by blakguypeez</div>
   </div>
   <div class="post" id="post-216337">
    <div class="subject"><a href="#post-216337">Re: Some help to start.</a></div>
    <div class="body"><div class="quote"><br />The Windows API (Application Programming Interface) is perhaps the most widely known. <br />Apple&#039;s OS also has an API, (I have not used it). <br />Linux has what some call an API, but, I hesitate to call it that, (that is only an opinion). <br />In fact, Linux does have an API, it&#039;s just a mess.<br /><br />MS-DOS didn&#039;t really have an API, (...perse).<br />DOS, instead, used interrupts to make system calls to make things happen.<br />Nearly everything you did in DOS was through calling interrupts.<br />When writing DOS programs, if you want keyboard input, you call an interrupt to perform that function.<br />If you want to display to the console screen, you call an interrupt to display to the console screen.<br />(Personally), I find programming in DOS to be a rather fun thing to do, but, I rarely do it any more, nor does anyone else, other than students of Assembly Language programming.<br /></div><br /><br />You find programming INT calls in DOS fun but call Linux a mess?&nbsp; :shock:<br />Making SysCalls in Linux is almost identical in concept - just different register usage.<br />Have you even written a single assembly program for Linux?<br />My guess is you haven&#039;t because if you had then you wouldn&#039;t be spreading these fallacies.<br /></div>
    <div class="meta">Posted on 2012-10-18 16:33:48 by p1ranha</div>
   </div>
   <div class="post" id="post-216338">
    <div class="subject"><a href="#post-216338">Re: Some help to start.</a></div>
    <div class="body"><div class="quote">You find programming INT calls in DOS fun but call Linux a mess?&nbsp; :shock:<br />Making SysCalls in Linux is almost identical in concept - just different register usage.<br />Have you even written a single assembly program for Linux?<br />My guess is you haven&#039;t because if you had then you wouldn&#039;t be spreading these fallacies.<br /></div><br /><br />I suppose interrupts are still an API. The MS-DOS interrupt API is based on the x86 version of CP/M by the way.<br />Anyway, the way I interpreted his remark is that the linux &#039;API&#039; is a &#039;mess&#039; because he referred to linux as in a linux distribution. And where the Win32API covers all aspects of the OS, a linux distribution is built up from various projects, where especially GUI environments can get messy... You have Xorg, then something like Qt on top of that, and the actual desktop environment (KDE, Gnome, etc) on top of that... and generally you&#039;ll have several of such libraries side-by-side, because every application just uses whichever libraries its author prefers.<br />So I found myself installing KDE, Gnome, lesstif and other common UI-libraries side-by-side.<br />There&#039;s various other areas of the system where there are multiple common libraries for a single area of functionality.<br />There are examples of such competing libraries/APIs on Windows as well (especially considering audio), but on the whole I suppose the Windows environment is somewhat more consistent.</div>
    <div class="meta">Posted on 2012-10-18 17:30:13 by Scali</div>
   </div>
   <div class="post" id="post-216339">
    <div class="subject"><a href="#post-216339">Re: Some help to start.</a></div>
    <div class="body"><div class="quote"><br />You find programming INT calls in DOS fun but call Linux a mess?&nbsp; :shock:<br />Making SysCalls in Linux is almost identical in concept - just different register usage.<br /></div><br />I wasn&#039;t referring to making system calls, I was referring to the API.&nbsp;  :thumbsup:<br /><br /><div class="quote"><br />Have you even written a single assembly program for Linux?<br />My guess is you haven&#039;t because if you had then you wouldn&#039;t be spreading these fallacies.<br /></div><br />I wasn&#039;t spreading a <em>fallacy</em>, rather I was voicing an opinion.&nbsp;  ;)<br />In fact, I&#039;m speaking from experience in this matter, ...yes, I &#039;m working on an assembly program in Linux at this moment. <br /><br />I think Scali got my meaning and <em>hit the nail on the head</em>: <br /><div class="quote"><br />...that the linux &#039;API&#039; is a &#039;mess&#039; because he referred to linux as in a linux distribution. And where the Win32API covers all aspects of the OS, a linux distribution is built up from various projects, where especially GUI environments can get messy... <br /><br />...but on the whole I suppose the Windows environment is somewhat more consistent.<br /></div><br /><br />I can only assume you are an avid Linux user and programmer.<br />I assure you, no offense was intended. <br />I&#039;m one who finds the sheer number of Linux distros to be a bit overwhelming.<br />Too many distros, too many flavors, too many projects, too many APIs, ...<br />I prefer consistancy in an API,&nbsp; ...just my opinion...&nbsp; :)<br /></div>
    <div class="meta">Posted on 2012-10-18 21:16:01 by blakguypeez</div>
   </div>
   <div class="post" id="post-216340">
    <div class="subject"><a href="#post-216340">Re: Some help to start.</a></div>
    <div class="body">I&#039;m a fairly &quot;avid&quot; Linux user, and I think you&#039;ve got a point. Depends on what you consider &quot;the API&quot;. System calls could be considered &quot;the API&quot;, but &quot;the C interface IS the Unix interface&quot; in another sense, so maybe that&#039;s &quot;the API&quot;. You&#039;re interacting with a dynamic library - just like the Windows API. When it comes to graphics, it&#039;s a wildly different situation. The &quot;X server&quot; is an independent program - completely separate from the kernel. It is possible to communicate with X via &quot;pure system calls&quot; - socket, connect, write, read... much like communicating with the internet. Virtually nobody does it that way. Xlib wraps this connection, but it&#039;s considered &quot;too low level&quot; by most programmers. Most people use &quot;helper libraries&quot; of various flavors and &quot;levels&quot;. At this point you could reasonably call it &quot;a mess&quot;. Or... you could say that we have choices not available in Windows.<br /><br />In terms of &quot;some help to start&quot; (are we still talking about &quot;some help to start&quot;?), you aren&#039;t likely to find much information based on assembly language. If you know how to interface with any library - the Windows API, C libraries, Xlib... the idea is generally the same. The &quot;assembly language part&quot; isn&#039;t too difficult - &quot;push&quot; and &quot;call&quot; mostly...<br /><br />If it isn&#039;t too far off topic, what sort of a Linux program are you working on, blakguypeez?<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2012-10-18 23:17:20 by fbkotler</div>
   </div>
   <div class="post" id="post-216342">
    <div class="subject"><a href="#post-216342">Re: Some help to start.</a></div>
    <div class="body"><div class="quote"><br />At this point you could reasonably call it &quot;a mess&quot;. Or... you could say that we have choices not available in Windows.</div><br /><br />Technically that&#039;s not even true.<br />There are various X-Window implementations available for Windows. And various popular GUI libraries used on linux are actually cross-platform and also have a Windows port.<br />It&#039;s just that hardly anyone makes that choice. X-Window applications on Windows are generally just lazy ports of *nix applications (you see the same on OS X for example). Instead of trying to write platform-agnostic code, they&#039;ll just use something like Cygwin to simulate a *nix environment on Windows.<br /><br />And a lot of applications are written as native Windows applications, where most people prefer to use the standard Win32/MFC/WinForms/WPF/etc toolkits from Microsoft, rather than opting for a cross-platform solution such as Qt.</div>
    <div class="meta">Posted on 2012-10-19 03:44:43 by Scali</div>
   </div>
   <div class="post" id="post-216343">
    <div class="subject"><a href="#post-216343">Re: Some help to start.</a></div>
    <div class="body"><div class="quote"><br />Depends on what you consider &quot;the API&quot;. <br />System calls could be considered &quot;the API&quot;, but &quot;the C interface IS the Unix interface&quot; in another sense, so maybe that&#039;s &quot;the API&quot;. <br /></div><br /><br />When I was doing DOS programming, I never considered DOS system calls as being the API. In fact, not until MS first introduced Windows did I ever hear the term API. I recall that being a major discussion among programmers at the time, that you no longer made system calls, but, instead used this new &#039;API&#039;.<br />http://en.wikipedia.org/wiki/API<br /><br /><div class="quote"><br />In terms of &quot;some help to start&quot; (are we still talking about &quot;some help to start&quot;?), <br /></div><br />I thought we were. <br />Sorry Defcon, I didn&#039;t mean to derail the thread....<br /><br />OT:<br /><div class="quote"><br />If it isn&#039;t too far off topic, what sort of a Linux program are you working on, blakguypeez?<br /></div><br />It&#039;s way OT, but,...<br />My personal interest is in programming language compilers, translators and assemblers.<br />Currently, I&#039;m working on a little project that translates the libc headers to &#039;inc&#039; type files for usage with assemblers. Yet another attempt at producing a workable <em>h2inc</em> like program. This is not a new idea. It&#039;s been attempted a number of times by others, but, never quite finished or succeeded in getting very far, as I&#039;m sure you know.<br />A problem encountered, with regard to Linux, is that <em>there appears to be too many cooks in the kitchen</em>. <br /></div>
    <div class="meta">Posted on 2012-10-19 09:45:27 by blakguypeez</div>
   </div>
   <div class="post" id="post-216344">
    <div class="subject"><a href="#post-216344">Re: Some help to start.</a></div>
    <div class="body"><div class="quote"><br />When I was doing DOS programming, I never considered DOS system calls as being the API. In fact, not until MS first introduced Windows did I ever hear the term API. I recall that being a major discussion among programmers at the time, that you no longer made system calls, but, instead used this new &#039;API&#039;.<br />http://en.wikipedia.org/wiki/API</div><br /><br />I think the problem might be that &#039;API&#039; is a relatively new term. I don&#039;t recall anyone using that term in the 80s either, regardless of what OS and language they used.<br />But these days there&#039;s even a wiki entry for MS-DOS API: http://en.wikipedia.org/wiki/MS-DOS_API<br />I guess it&#039;s similar to people not referring to x86 as a CISC architecture until the advent of RISC: the term CISC simply did not exist yet. The technology did, obviously.<br />I&#039;d like to know where the term &#039;API&#039; actually came from, and when it first came into use.<br />The first time I heard it, was with Win32API, so I wonder if it&#039;s a term that came from Microsoft/IBM, or perhaps the VMS world.</div>
    <div class="meta">Posted on 2012-10-19 10:29:35 by Scali</div>
   </div>
   <div class="post" id="post-216345">
    <div class="subject"><a href="#post-216345">Re: Some help to start.</a></div>
    <div class="body"><div class="quote"><br />I think the problem might be that &#039;API&#039; is a relatively new term. I don&#039;t recall anyone using that term in the 80s either, regardless of what OS and language they used.<br /></div><br /><br />FYI: You can find references to the term API as far back as the 70&#039;s - coincidentally with the appearance of the C language.&nbsp; Early IETF RFC&#039;s also contain this term.</div>
    <div class="meta">Posted on 2012-10-19 11:02:54 by p1ranha</div>
   </div>
   <div class="post" id="post-216347">
    <div class="subject"><a href="#post-216347">Re: Some help to start.</a></div>
    <div class="body"><div class="quote"><br />But these days there&#039;s even a wiki entry for MS-DOS API: http://en.wikipedia.org/wiki/MS-DOS_API<br /></div><br /><br />In hind site, I guess you would/could consider DOS interrupts as a library of system function calls and in that respect it would be a valid reference to an API. It&#039;s just that most of us never thought of it as nor called it that.<br /><br /><div class="quote"><br />I&#039;d like to know where the term &#039;API&#039; actually came from, and when it first came into use.<br />The first time I heard it, was with Win32API, so I wonder if it&#039;s a term that came from Microsoft/IBM, or perhaps the VMS world.<br /></div><br /><br />I don&#039;t know. When I first heard it, it was simply &#039;Windows API&#039;.<br />Since I&#039;d never heard that term before, I guessed it was perhaps a MS invented term.<br /><br />I never heard of the CRT (C Runtime Library) being referred to as <em>the C API</em>, so I just assumed that the CRT was an integral component of the Win API, despite the fact that the CRT is a library all to its self.<br /></div>
    <div class="meta">Posted on 2012-10-19 11:54:57 by blakguypeez</div>
   </div>
   <div class="post" id="post-216348">
    <div class="subject"><a href="#post-216348">Re: Some help to start.</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br />I think the problem might be that &#039;API&#039; is a relatively new term. I don&#039;t recall anyone using that term in the 80s either, regardless of what OS and language they used.<br /></div><br /><br />FYI: You can find references to the term API as far back as the 70&#039;s - coincidentally with the appearance of the C language.&nbsp; Early IETF RFC&#039;s also contain this term.<br /></div><br /><br />Perhaps (in such cases it would be nice to cite sources), but that doesn&#039;t mean that the term was common outside that particular community.<br />I think at the very least the term was popularized in &#039;my community&#039; of home/personal computing because Microsoft started using the term API in their Windows documentation. I don&#039;t recall seeing that term back in my Turbo C++ days in DOS, let alone on Amiga or C64. I just checked the Turbo C++ 3.1 help files, and they don&#039;t seem to make any mention of API at all.<br /><br />Again I can draw a parallel with the term &#039;CISC&#039;: The term RISC comes from the Berkeley RISC project started in 1980: http://en.wikipedia.org/wiki/Berkeley_RISC<br />(All the more interesting with two of the most famous CISC architectures, 68k and x86, being introduced only just before that in 1978-1979)<br />But outside the research world, most people probably had never heard of RISC (and therefore CISC) until RISC processors actually became available in relatively mainstream devices in the early 90s.</div>
    <div class="meta">Posted on 2012-10-19 15:32:10 by Scali</div>
   </div>
   <div class="post" id="post-216349">
    <div class="subject"><a href="#post-216349">Re: Some help to start.</a></div>
    <div class="body"><div class="quote"><br />Perhaps (in such cases it would be nice to cite sources), but that doesn&#039;t mean that the term was common outside that particular community.<br /></div><br /><br />Irrelevant. Your original question was with regard to timeline of introduction - not common usage.<br />Allow me to quote you:<br /><div class="quote"><br />I think the problem might be that &#039;API&#039; is a relatively new term. I don&#039;t recall anyone using that term in the 80s either, regardless of what OS and language they used.<br /></div><br /><br />FYI: For sources you can start with this RFC ( dated Aug, 1989 and authored by Vincent Cerf ) and work backwards to find the first usage.&nbsp; I don&#039;t have time, nor inclination, to research further.<br /><a target="_blank" href="http://tools.ietf.org/html/rfc1109">http://tools.ietf.org/html/rfc1109</a><br /><br /><div class="quote"><br />I don&#039;t know. When I first heard it, it was simply &#039;Windows API&#039;.<br />Since I&#039;d never heard that term before, I guessed it was perhaps a MS invented term.<br /></div><br /><br />And this is exactly the problem with most people who have no experience outside of Microsoft.&nbsp; They commonly think everything was &quot;invented&quot; by Microsoft when in fact a lot of the terminology and technology existed long before Windows was even a glint in Bill G&#039;s eye.&nbsp; I&#039;m not debating that Windows doesn&#039;t have any original ideas - just that Microsoft isn&#039;t the source of all technology innovation.<br /><br /></div>
    <div class="meta">Posted on 2012-10-19 16:53:56 by p1ranha</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29746&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29746&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29746" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29746&amp;page=2">&gt;</a><a href="../?id=29746&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>