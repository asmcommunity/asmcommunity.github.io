<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Getting Started - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=13384" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=13384">Getting Started</a></p>
   <div class="post" id="post-103701">
    <div class="subject"><a href="#post-103701">Getting Started</a></div>
    <div class="body">Hello:<br /><br />I want to thank all that reply.<br /><br />I am very new to assembly, so please forgive my stupid questions.<br /><br />I have downloaded MASM32 and have been trying to compile some of the examples that I have also download from the internet. But, it seems that no matter what .ASM file I try to compile it does not work. Here is an example of a .ASM file that I would like to get working so that I may study, I get several error's.<br /><br />Can someone please help me to get started. I can't to get anything going.<br /><pre><code><br />; rawread.asm<br />;<br />; this program reads a DOS cluster using only BIOS disk calls.  All<br />; of the tasks usually done by DOS, e.g. FAT lookup, cluster to<br />; logical sector translation, logical to physical translation, are<br />; all done by this program instead.  The idea is to be able to create<br />; a program that can access DOS disks from a bootable floppy without<br />; having to have DOS.<br />;<br />; written on Fri  05-27-1994  by Ed Beroset<br />;<br />; well, that's what it used to do.  Now it's supposed to do something<br />; completely different.  Its job is to scan the entire surface of the<br />; hard drive, looking for the specified string.  If that string is<br />; found, it is to print the full path and directory entry, including<br />; the file date and time.<br />;<br />; written on Sun  12-11-1994  by Ed Beroset<br />;<br />; but wait!  There's more.  Now what we have is a number of raw<br />; routines which could prove useful for manipulating a DOS file<br />; structure outside of the DOS environment.  The main routine still<br />; should be kept &#40;if renamed&#41;, since the order in which these things<br />; are done is important &#40;e.g. later calls depend on data set up by<br />; earlier calls&#41;.<br />;<br />; get filename<br />; parse filename into subdirs<br />; locate root dir and cluster size<br />; follow subdir routing to filename<br />; report file size, date &amp; time<br />;<br />        .MODEL small<br />        .STACK 0200h<br />        .586P<br /><br />        .DATA<br />PartEntry STRUC<br />        Bootable        db ?    ;80h = bootable, 00h = nonbootable<br />        BeginHead       db ?    ;beginning head<br />        BeginSector     db ?    ;beginning sector<br />        BeginCylinder   db ?    ;beginning cylinder<br />        FileSystem      db ?    ;name of file system<br />        EndHead         db ?    ;ending head<br />        EndSector       db ?    ;ending sector<br />        EndCylinder     db ?    ;ending cylinder<br />        StartSector     dd ?    ;starting sector &#40;relative to beg. of disk&#41;<br />        PartSectors     dd ?    ;number of sectors in partition<br />PartEntry ENDS<br /><br />BootSector STRUC<br />        Jump            db ?            ;E9 xx xx or EB xx 90<br />        JumpTarget      dw ?            ;E9 xx xx or EB xx 90<br />        OemName         db '????????'   ;OEM name &amp; version<br />                                        ;Start of BIOS parameter block<br />        BytesPerSec     dw ?            ;bytes per sector<br />        SecPerClust     db ?            ;sectors per cluster<br />        ResSectors      dw ?            ;number of reserved sectors<br />        FATs            db ?            ;number of file allocation tables<br />        RootDirEnts     dw ?            ;number of root-dir entries<br />        Sectors         dw ?            ;total number of sectors<br />        Media           db ?            ;media descriptor byte<br />        FATsecs         dw ?            ;number of sectors per FAT<br />        SecPerTrack     dw ?            ;sectors per track<br />        Heads           dw ?            ;number of heads<br />        HiddenSecs      dd ?            ;number of hidden sectors<br />        HugeSectors     dd ?            ;num sectors if Sectors==0<br />                                        ;End of BIOS parameter block<br />BootSector ENDS<br /><br />DirEntry STRUC<br />        FileName        db '????????'   ;name<br />        Extension       db '???'        ;extension<br />        Attributes      db ?            ;attributes<br />        Reserved        db 10 dup &#40;?&#41;   ;reserved<br />        Time            dw ?            ;time stamp<br />        Date            dw ?            ;date stamp<br />        StartCluster    dw ?            ;starting cluster<br />        FileSize        dd ?            ;file size<br />DirEntry ENDS<br /><br />BootFileName  db  &quot;CONFIG  SYS&quot;         ;the boot loader for this OS<br />MBR     DB      0200h DUP &#40;?&#41;<br />buff    DB      0200h * 40h DUP &#40;?&#41;<br />ClustOffs       dd      ?<br /><br />CR      EQU     0DH<br />LF      EQU     0AH<br /><br /><br />        .CODE<br />main PROC<br />        STARTUPCODE                     ;initialize stuff<br />        call    FetchMBR C              ;fetch the master boot record<br />        jc      @@exit<br />        mov     cx,4                    ;search up to four partitions<br />        add     bx,01aeh                ;point to partition table &#40;-10h&#41;<br />@@FindBootable&#58;<br />        add     bx,10h                  ;point to next entry<br />        cmp     BYTE ptr &#91;bx&#93;,80h       ;is it a bootable partition?<br />        loopnz  @@FindBootable<br />        call    FetchSector C,                                \<br />                WORD ptr &#91;&#40;PartEntry PTR bx&#41;.BeginHead&#93;,      \<br />                WORD ptr &#91;&#40;PartEntry PTR bx&#41;.BeginSector&#93;,    \<br />                WORD ptr &#91;&#40;PartEntry PTR bx&#41;.BeginCylinder&#93;,  \<br />                OFFSET MBR, ds ;SEG MBR<br />;<br />; here's the point at which our OS loader would begin, with the<br />; BootSector structure in memory.<br />;<br />        mov     bx, OFFSET MBR<br />        call    CalcClustOff C, \<br />                WORD ptr &#91;&#40;BootSector PTR bx&#41;.ResSectors&#93;,    \<br />                WORD ptr &#91;&#40;BootSector PTR bx&#41;.FATsecs&#93;,       \<br />                WORD ptr &#91;&#40;BootSector PTR bx&#41;.FATs&#93;,          \<br />                WORD ptr &#91;&#40;BootSector PTR bx&#41;.RootDirEnts&#93;,   \<br />                WORD ptr &#91;&#40;BootSector PTR bx&#41;.BytesPerSec&#93;,   \<br />                WORD ptr &#91;&#40;BootSector PTR bx&#41;.SecPerClust&#93;<br />        mov     WORD ptr &#91;ClustOffs&#93;,ax<br />        mov     WORD ptr &#91;ClustOffs+2&#93;,dx<br />        call    CalcClust2 C,                                 \<br />                WORD ptr &#91;&#40;BootSector PTR bx&#41;.ResSectors&#93;,    \<br />                WORD ptr &#91;&#40;BootSector PTR bx&#41;.FATsecs&#93;,       \<br />                WORD ptr &#91;&#40;BootSector PTR bx&#41;.FATs&#93;<br />        ; now dx&#58;ax contains the logical sector for cluster 2<br />        call    LsectToGeom C,                                \<br />                ax, dx,                                       \<br />                WORD ptr &#91;&#40;BootSector PTR bx&#41;.HiddenSecs&#93;  ,  \<br />                WORD ptr &#91;&#40;&#40;BootSector PTR bx&#41;.HiddenSecs&#41;+2&#93;,\<br />                &#91;&#40;BootSector PTR bx&#41;.Heads&#93;,                  \<br />                &#91;&#40;BootSector PTR bx&#41;.SecPerTrack&#93;<br /><br />        mov     dl,80h<br />        mov     bx,offset buff<br />        mov     al,&#91;&#40;BootSector PTR MBR&#41;.SecPerClust&#93;<br />        mov     ah,2h                   ; get ready to read<br />        int     13h<br />        ; now find our desired filename within buffer &#40;which has the root dir&#41;<br /><br />        call    FindFile C, \<br />                bx, 200h * 40h, offset BootFileName<br />        xor     dh,dh<br />        mov     dl,&#91;&#40;BootSector PTR MBR&#41;.SecPerClust&#93;<br />        mov     si,ax<br />        mov     ax,&#91;&#40;DirEntry PTR si&#41;.StartCluster&#93;<br />        mul     dx<br />        add     ax,WORD ptr &#91;ClustOffs&#93;<br />        adc     dx,WORD ptr &#91;ClustOffs+2&#93;<br />        ; now dx&#58;ax contains logical sector number for start of file<br /><br />        call    LsectToGeom C, \<br />                ax, dx, \<br />                WORD ptr &#91;&#40;BootSector PTR MBR&#41;.HiddenSecs&#93;  ,  \<br />                WORD ptr &#91;&#40;&#40;BootSector PTR MBR&#41;.HiddenSecs&#41;+2&#93;,\<br />                &#91;&#40;BootSector PTR MBR&#41;.Heads&#93;,                  \<br />                &#91;&#40;BootSector PTR MBR&#41;.SecPerTrack&#93;<br />        mov     dl,80h<br />        mov     ax,204h                 ; read in 2k worth of data<br />        int     13h<br /><br />@@exit&#58;<br />        EXITCODE                        ;exit to DOS<br />ENDP    main<br /><br />;<br />; FetchMBR -    fetches the Master Boot Record from the first physical<br />;               hard disk and stores it in the location MBR.<br />;<br />; INPUT&#58;     none<br />; OUTPUT&#58;    AX is error code if CY set, ES&#58;BX ==&gt; MBR<br />; DESTROYED&#58; none<br />;<br />FetchMBR PROC    C<br />        USES    cx, dx                  ;save registers we'll use<br />        mov     dx,80h                  ;first physical disk<br />        mov     cx,1                    ;head 1, sector 0<br />        mov     bx,ds                   ;<br />        mov     es,bx                   ;point to boot record buffer<br />        mov     bx,OFFSET MBR           ;read into boot record<br />        mov     ax,0201h                ;read one sector<br />        int     13h                     ;BIOS read<br />        ret                             ;return to main<br />FetchMBR ENDP<br /><br />;<br />; FetchSector - fetches the physical sector described by the passed<br />;               parameters and stores it in the named buffer<br />;<br />; INPUT&#58;     head, sector, cylinder, buffer<br />; OUTPUT&#58;    AX is error code if CY set, ES&#58;BX ==&gt; Boot<br />; DESTROYED&#58; none<br />;<br />FetchSector PROC C  head&#58;BYTE, sector&#58;BYTE, cylinder&#58;BYTE, buffer&#58;DWORD<br />        USES    cx, dx                  ;save registers we'll use<br />        mov     ch, &#91;cylinder&#93;          ;<br />        mov     cl, &#91;sector&#93;            ;<br />        mov     dh, &#91;head&#93;              ;<br />        mov     dl, 80h                 ;first physical hard drive<br />        les     bx, &#91;buffer&#93;            ;<br />        mov     ax,0201h                ;read one sector<br />        int     13h                     ;BIOS read<br />        ret                             ;return to main<br />FetchSector ENDP<br /><br />;<br />; GeomToLsect - converts to logical sector number from the physical<br />;               geometry &#40;head, cylinder, track&#41;.  See LsectToGeom.<br />;<br />; INPUT&#58;     cx, dx are set with cylinder/track, and head respectively<br />;            HiddenSecs, Heads, SecPerTrack<br />; OUTPUT&#58;    lsect<br />; DESTROYED&#58; none<br />;<br />GeomToLsect PROC    C lsect&#58;DWORD, dHiddenSecs&#58;DWORD,    \<br />                      dHeads&#58;WORD, dSecPerTrack&#58;WORD, buffer&#58;DWORD<br />        USES    ax                      ;save registers we'll use<br />        mov     ax, WORD ptr &#91;lsect&#93;    ;load lsect into DX&#58;AX<br />        mov     dx, WORD ptr &#91;lsect+2&#93;  ;<br />        stc                             ;add one additional<br />        adc     ax, WORD ptr &#91;dHiddenSecs&#93;   ;add starting sector<br />        adc     dx, WORD ptr &#91;dHiddenSecs+2&#93; ;<br />        div     &#91;dSecPerTrack&#93;          ;<br />        mov     cl,dl                   ;store sector in cl<br />        xor     dx,dx                   ;<br />        div     &#91;dHeads&#93;                ;<br />        mov     dh,dl                   ;store head in dh<br />        mov     ch,al                   ;store low 8 bits of cylinder in ch<br />        shr     ax,1                    ;<br />        shr     ax,1                    ;<br />        and     al,0c0h                 ;pass through two hi bits only<br />        or      cl,ah                   ;mov bits into location<br />        ret                             ;<br />GeomToLsect ENDP<br /><br />;<br />; LsectToGeom - converts from logical sector number to the physical<br />;               geometry &#40;head, cylinder, track&#41; in the form required<br />;               by the BIOS &#40;Int 13h&#41; disk read and write calls.<br />;<br />; INPUT&#58;     lsect, HiddenSecs, Heads, SecPerTrack<br />; OUTPUT&#58;    cx, dx are set with cylinder/track, and head respectively<br />; DESTROYED&#58; none<br />;<br />LsectToGeom PROC    C lsect&#58;DWORD, lHiddenSecs&#58;DWORD,    \<br />                      lHeads&#58;WORD, lSecPerTrack&#58;WORD, buffer&#58;DWORD<br />        USES    ax                      ;save registers we'll use<br />        mov     ax, WORD ptr &#91;lsect&#93;    ;load lsect into DX&#58;AX<br />        mov     dx, WORD ptr &#91;lsect+2&#93;  ;<br />        stc                             ;add one additional<br />        adc     ax, WORD ptr &#91;lHiddenSecs&#93;   ;add starting sector<br />        adc     dx, WORD ptr &#91;lHiddenSecs+2&#93; ;<br />        div     &#91;lSecPerTrack&#93;          ;<br />        mov     cl,dl                   ;store sector in cl<br />        xor     dx,dx                   ;<br />        div     &#91;lHeads&#93;                ;<br />        mov     dh,dl                   ;store head in dh<br />        mov     ch,al                   ;store low 8 bits of cylinder in ch<br />        shr     ax,1                    ;<br />        shr     ax,1                    ;<br />        and     al,0c0h                 ;pass through two hi bits only<br />        or      cl,ah                   ;mov bits into location<br />        ret                             ;<br />LsectToGeom ENDP<br /><br />;<br />; CalcClust2  - calculates the starting logical sector number of<br />;               cluster 2, &#40;the beginning of data space for<br />;               partitions&#41;.<br />;<br />; INPUT&#58;     ResSectors, FATsecs, FATs<br />; OUTPUT&#58;    dx&#58;ax contains the starting logical sector number<br />; DESTROYED&#58; none<br />;<br />CalcClust2 PROC    C cResSectors&#58;WORD, cFATsecs&#58;WORD, cFATs&#58;BYTE<br />        xor     dx,dx                   ;<br />        mov     ax,&#91;cFATsecs&#93;           ;<br />        mul     &#91;cFATs&#93;                 ;<br />        add     ax,&#91;cResSectors&#93;        ;<br />        adc     dx,0                    ;<br />        ret<br />CalcClust2 ENDP<br /><br />;<br />; CalcClustOff - calculates the starting logical sector number of<br />;               cluster 0, which isn't really a cluster, but the<br />;               number returned is useful for calculations converting<br />;               cluster number to logical sector<br />;<br />; INPUT&#58;     ResSectors, FATsecs, FATs<br />; OUTPUT&#58;    dx&#58;ax contains the starting logical sector number<br />; DESTROYED&#58; none<br />;<br />CalcClustOff PROC    C dResSectors&#58;WORD, dFATsecs&#58;WORD, dFATs&#58;BYTE, \<br />        dRootDirEnts&#58;WORD, dBytesPerSec&#58;WORD, dSecPerClust&#58;BYTE<br />        LOCAL clustLo&#58;WORD, clustHi&#58;WORD<br />        xor     dh,dh<br />        mov     ax,&#91;dFatSecs&#93;<br />        mov     dl,&#91;dFATs&#93;<br />        mul     dx<br />        add     ax,&#91;dResSectors&#93;<br />        adc     dx,0<br />;        call    CalcClust2 C, &#91;dResSectors&#93;, &#91;dFATsecs&#93;, &#91;dFATs&#93;<br />        ; now dx&#58;ax = FATs * FATsecs + ResSectors<br />        mov     &#91;clustLo&#93;,ax<br />        mov     &#91;clustHi&#93;,dx<br />        mov     dx,20h                  ; bytes per dir entry<br />        mov     ax,&#91;dRootDirEnts&#93;       ;<br />        mul     dx                      ; multiply 'em out<br />        div     &#91;dBytesPerSec&#93;          ; and divide by bytes/sec<br />        add     &#91;clustLo&#93;,ax            ;<br />        adc     &#91;clustHi&#93;,dx            ; create the aggregate<br />        mov     al,&#91;dSecPerClust&#93;       ;<br />        xor     ah,ah                   ;<br />        shl     ax,1                    ; AX = SecPerClust * 2<br />        sub     &#91;clustLo&#93;,ax            ;<br />        sbb     &#91;clustHi&#93;,0             ; propagate carry flag<br />        mov     ax,&#91;clustLo&#93;            ;<br />        mov     dx,&#91;clustHi&#93;            ;<br />        ret<br />CalcClustOff ENDP<br /><br />;<br />; FindFile -    given a memory buffer containing the directory data<br />;               and a static file name for which to search, this routine<br />;               finds the file and returns a pointer to its directory<br />;               entry in ds&#58;si<br />;<br />; INPUT&#58;        dirbuffer, filespec<br />; OUTPUT&#58;       ax    contains pointer to directory entry &#40;or NULL&#41;<br />; DESTROYED&#58;    none<br />;<br />FindFile PROC C dirbuffer&#58;WORD, limit&#58;WORD, filespec&#58;WORD<br />        USES    cx, dx, di, si, es<br />        mov     cx,ds                   ;<br />        mov     es,cx                   ; es and ds point to same segment<br />        cld                             ; always count forward<br />        mov     ax,&#91;dirbuffer&#93;          ; load 'em up<br />        add     &#91;limit&#93;,ax<br />        mov     dx,&#91;filespec&#93;           ;<br />keepsearching&#58;<br />        mov     cx,11                   ; size of dos filename &#40;8.3&#41;<br />        mov     si,dx                   ;<br />        mov     di,ax                   ;<br />        repe    cmpsb                   ; compare 'em<br />        jz      foundit                 ;<br />        add     ax,20h                  ; size of directory entry<br />        cmp     ax,&#91;limit&#93;<br />        jb      keepsearching<br />        xor     ax,ax<br /><br />foundit&#58;<br />        ret<br />FindFile ENDP<br />        END</code></pre></div>
    <div class="meta">Posted on 2003-05-18 08:47:49 by damica</div>
   </div>
   <div class="post" id="post-103707">
    <div class="subject"><a href="#post-103707">Getting Started</a></div>
    <div class="body">This is DOS code. You will need to use the older DOS linker.<br />The linker included in MASM32 is for Windows code. I just<br />did a quick search for the older linker but didn't find it. I'm<br />sure someone else here knows where to get it.</div>
    <div class="meta">Posted on 2003-05-18 09:19:23 by anon</div>
   </div>
   <div class="post" id="post-103751">
    <div class="subject"><a href="#post-103751">Getting Started</a></div>
    <div class="body">Iczelion has it on his page. Here's a direct link: <a target="_blank" href="http://spiff.tripnet.se/~iczelion/files/Lnk563.exe">http://spiff.tripnet.se/~iczelion/files/Lnk563.exe</a><br /><br />If you want to learn how to use assembly in Windows, check out the tutorials on this forum.</div>
    <div class="meta">Posted on 2003-05-18 12:29:42 by Qweerdy</div>
   </div>
  </div>
 </body>
</html>