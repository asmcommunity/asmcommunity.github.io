<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Data at Code Section - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16068" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=16068">Data at Code Section</a></p>
   <div class="post" id="post-124594">
    <div class="subject"><a href="#post-124594">Data at Code Section</a></div>
    <div class="body">Hi,<br />i am looking for a quick and nice solution to scan the code section for any data in it.<br />sometimes when i debug (ollydbg) / disasm a file i can see from time to time data insde the disassembled code section which is displayed as byte: DB XX.<br />any ideas?</div>
    <div class="meta">Posted on 2003-11-17 10:50:13 by wizzra</div>
   </div>
   <div class="post" id="post-124595">
    <div class="subject"><a href="#post-124595">DB XX</a></div>
    <div class="body">Sometimes when a debugger doesn't understand an instruction for instance (if it started dissasembling in the middle of an instruction) then you will see that. It is actually code. Maybe it's a protected mode instruction not interpreted by Olly.</div>
    <div class="meta">Posted on 2003-11-17 11:00:23 by mrgone</div>
   </div>
   <div class="post" id="post-124600">
    <div class="subject"><a href="#post-124600">Data at Code Section</a></div>
    <div class="body">the problem is:<br /><br /><div class="quote"><br />The assembler fills in these gaps by some random (or irrelevant) value since these locations are never executed. The problem is that there is no way to distinguish data from gaps within instructions. If the normal process of disassembly is allowed to take its own course by treating these gaps as genuine code, the opcode alignment may be destroyed. Once misaligned, there is no way to recover and we may get unreliable disassembly. Thus it is absolutely essential to prevent the processing of such gaps. We do this by identifying the basic blocks in the code section. Each basic block constitutes a valid address range in the .text section. This is achieved by making one extra pass of code analysis on the .text section. Thus our disassembler is a two pass disassembler.<br /></div><br /><br />mrgone,<br />every byte sequence can produce assembly, even if it doesn't make sense for use in our proggy.<br />problem is to loacte that 'data' and skip it to the next code segment.<br />i am in need to find a good way to do it.<br /><br />normal assembly instructions (add,inc..etc) are easy to pass using disasm engine, but i guess when we get at conditional or unconditional jumps, we should store the address and 'virtually' trace if next code is references whitin the program.<br />any ideas for algorithm?</div>
    <div class="meta">Posted on 2003-11-17 11:33:55 by wizzra</div>
   </div>
   <div class="post" id="post-124605">
    <div class="subject"><a href="#post-124605">Data at Code Section</a></div>
    <div class="body">Hi, wizzra. :)<br /><br />I think Olly uses an heuristic algorithm to figure out where each function begins and ends, and wich parts of the code never get to be executed. I don't think there's an easy way to do that, and in any case it's not bulletproof. :(<br /><br />Probably the simplest way is to &quot;mark&quot; target addresses of jumps as valid code addresses. That way if you're decoding an instruction and you find it &quot;overlaps&quot; an address known to be a jump target, then most likely the dissassembler misaligned somewhere. That should work fine for most programs anyway, the only problem would be anti-dissassembly tricks.</div>
    <div class="meta">Posted on 2003-11-17 11:46:58 by QvasiModo</div>
   </div>
   <div class="post" id="post-124615">
    <div class="subject"><a href="#post-124615">Data at Code Section</a></div>
    <div class="body">start from entrypoint and disassemble from there, following Jcc and CALLs. That's the only way to really do it, and it can be fooled by false conditional jumps etc.</div>
    <div class="meta">Posted on 2003-11-17 13:36:55 by f0dder</div>
   </div>
   <div class="post" id="post-124618">
    <div class="subject"><a href="#post-124618">Data at Code Section</a></div>
    <div class="body">That's what I thought, but you said it better. ;) <br />Anyway, is that really the only way to do it? :(</div>
    <div class="meta">Posted on 2003-11-17 13:55:20 by QvasiModo</div>
   </div>
   <div class="post" id="post-124622">
    <div class="subject"><a href="#post-124622">Data at Code Section</a></div>
    <div class="body">such task require a smart recursive procedure than...<br />hm..<br /><br /><pre><code><br />here is some useless code with no meaning what so ever,<br />trying to find a way to determine data location.<br />analysis using jxx tracing &#91;recursive&#40;?&#41;&#93;<br /><br />0&#58;  mov eax,ebx<br />1&#58;  xor ecx,edx<br />2&#58;  jmp 5<br />3&#58;  jmp 11<br />4&#58;  cmp eax,ecx<br />5&#58;  jz 3<br />6&#58;  cmp eax,edx<br />7&#58;  jb 16<br />8&#58;  db 'h'<br />9&#58;  db 'i'<br />10&#58; db  0<br />  -  entry point-<br />11&#58; inc eax<br />12&#58; add ecx,eax<br />13&#58; cmp edx,ecx<br />14&#58; jg 16 <br />15&#58; dec eax<br />16&#58; xor eax,eax<br /><br />analyze from offset 0&#58;<br /><br />start&#58;<br />offset&#40;2&#41;-&gt;offset&#40;5&#41;<br />                 /\<br />       offset&#40;3&#41;    offset&#40;7&#41;<br />          |               /\ <br />     offset&#40;14&#41;       &#40;16&#41;  &#91; data offset&#58; 8 &#93;<br />          /\                   | <br />       &#40;16&#41; &#40;15&#41;           offset&#40;14&#41;           <br />                               /\<br />                            &#40;16&#41; &#40;15&#41;                       <br /><br />jxx accurds at&#58; 2,5,3,7,14<br /></code></pre><br /><br />need to find a good algorithm to create code blocks (start-&gt;end offsets) or data block(start-&gt;end offsets)</div>
    <div class="meta">Posted on 2003-11-17 14:40:35 by wizzra</div>
   </div>
   <div class="post" id="post-124623">
    <div class="subject"><a href="#post-124623">Data at Code Section</a></div>
    <div class="body">I think recursive is a bad idea... for a decent-sized app, you risk using very large amounts of stack space. Probably smarter to make it linear, and add &quot;entrypoints&quot; to some list - everytime you reach a branch, add the branch location to the &quot;entrypoint list&quot; (if not there already). Once you reach a section boundary (or invalid instruction / ret with no matching call / etc), and there's no more non-visited &quot;entrypoints&quot;, you're done.</div>
    <div class="meta">Posted on 2003-11-17 14:46:06 by f0dder</div>
   </div>
   <div class="post" id="post-125213">
    <div class="subject"><a href="#post-125213">Data at Code Section</a></div>
    <div class="body">hi Fodder,<br />when doing linearyou mean by:<br /><br />0: ...<br />1: ...<br />2. jmp x ; save x position<br />3. ...<br />4. ...<br />5. call y ; save y position<br />6. ...<br /><br />and trace just down, without following any branch address,<br />and for each address to ask if it's already in my 'entry point' list ?<br />thus, to locate subroutines (with signaure: push ebp, mov ebp, esp..) i can mark only call x location.<br />but than if that is the way you was reffering, what happens to all of the 'code' before EP how would you reach it than?<br />cuz i know that with recursive you can follow all flows, but stack could explode :(<br />i guess i need a visual example, would be nice to see example.<br />thnx<br />-wizzra</div>
    <div class="meta">Posted on 2003-11-23 13:03:15 by wizzra</div>
   </div>
   <div class="post" id="post-125216">
    <div class="subject"><a href="#post-125216">Data at Code Section</a></div>
    <div class="body">Once you reach the &quot;end&quot; of an &quot;entrypoint&quot;, you start disassembling the next &quot;entrypoint&quot; in your list, and thus, eventually, you should have covered all code in the program. Of course this will not disassemble &quot;dead code&quot;, but that's not too important anyway, in my opinion.</div>
    <div class="meta">Posted on 2003-11-23 13:10:34 by f0dder</div>
   </div>
   <div class="post" id="post-125407">
    <div class="subject"><a href="#post-125407">Data at Code Section</a></div>
    <div class="body">The following is why is generally impossible to distinguish data between instructions: <br /><pre><code><br />1.	cmp	eax,&#91;404000&#93;<br />2.	jnge	label1		; jump is ALWAYS taken<br />3.	BYTE	&quot;HI&quot;		; 48H dec eax, 49H dec ecx<br />4.	jmp	fakelabel1<br />5.label1&#58;<br />6.	...<br />7.	jmp	label2<br />8.fakelabel1&#58;<br />9.	BYTE	&quot;THERE&quot;		; 54H push esp, 48H dec eax, 45H inc ebp, 52H push edx, 45H inc ebp<br />10.	jmp	fakelabel2<br />11.label2&#58;<br />12.	...<br />13.	jmp	label3<br />14.fakelabel2&#58;<br />15.	; fake-text-or-code<br /></code></pre><br />Line 2. This code is anti-disasm - this jump is always taken, but from disassembler's point of view is impossible to get it, because it doesn't know what value will be at [404000] at run-time.<br /><br />Line 3. Text &quot;HI&quot; seems to be valid instructions, so it can't be recognized as text.<br /><br />Line 4. Offset fakelabel1 is authenticated by this jump, which is never taken.<br /><br />Line 9. Text &quot;THERE&quot; will be recognized also as instructions.<br /><br />Line 10. Offset fakelabel2 is authenticated by this jump, which is never taken.<br /><br />Line 15. Again the same...</div>
    <div class="meta">Posted on 2003-11-25 03:36:01 by MazeGen</div>
   </div>
   <div class="post" id="post-125472">
    <div class="subject"><a href="#post-125472">Data at Code Section</a></div>
    <div class="body">Wow, good examply of anti-disasm, MazeGen. :)<br />But I wonder if softs like WDASM and IDA can deal with it anyway... IMHO Wizzra should use the simple algo described by F0dder, since ot'll work for most cases and disassembling code that was <em>meant</em> not to be disassembled it a fairly complicated task, likely to involve either heuristics or simulation of execution. Since he's working in a debugger/disassembler, perhaps it's just better to let the user handle this special cases, making the disasm engine more configurable.</div>
    <div class="meta">Posted on 2003-11-25 18:06:20 by QvasiModo</div>
   </div>
   <div class="post" id="post-125474">
    <div class="subject"><a href="#post-125474">Data at Code Section</a></div>
    <div class="body">That actually wasn't a good example of anti-disasm, as (assuming the comments are correct, I didn't bother to check) the generated opcodes don't affect the flow of the code - having multi-byte garbage that messes up valid instructions later is a better example of anti-disasm.<br /><br />But it's true that it takes some work to handle anti-disasm code, and IMO it is a better idea to focus on making a dynamic and interactive disassembler, so the user can correct these problems himself. Work on heuristics can be done later on, or the user can run deobfuscation tools of his own.</div>
    <div class="meta">Posted on 2003-11-25 18:17:16 by f0dder</div>
   </div>
   <div class="post" id="post-125621">
    <div class="subject"><a href="#post-125621">Data at Code Section</a></div>
    <div class="body"><div class="quote"><br />But I wonder if softs like WDASM and IDA can deal with it anyway...</div><br />Try it ;)<br /><div class="quote"><br />IMHO Wizzra should use the simple algo described by F0dder, since ot'll work for most cases and disassembling code that was <em>meant</em> not to be disassembled it a fairly complicated task, likely to involve either heuristics or simulation of execution.</div><br />Yeah, but wizzra posted a question similar to my answer on another board, so that I answered it here.<br /><div class="quote"><br />Since he's working in a debugger/disassembler, perhaps it's just better to let the user handle this special cases, making the disasm engine more configurable. </div><br />Yeah, this is, of course, the best solution.<br /><div class="quote"><br />That actually wasn't a good example of anti-disasm, as (assuming the comments are correct, I didn't bother to check) the generated opcodes don't affect the flow of the code - having multi-byte garbage that messes up valid instructions later is a better example of anti-disasm.</div><br />Well, it was an anti-disasm model example in sense of difficulty in recognizing data between code. IMHO it's one of the most difficult tasks while coding disasm or debug engine.<br /><div class="quote"><br />But it's true that it takes some work to handle anti-disasm code, and IMO it is a better idea to focus on making a dynamic and interactive disassembler, so the user can correct these problems himself. Work on heuristics can be done later on, or the user can run deobfuscation tools of his own. </div><br />Do you think there is any way how to get, with 100% assurance, the value at [404000] at run-time, when we disassemble at disasm-time, even using heuristics? I'm asking because I'm just exploring it.<br /><br />Thanks for comments, guys.</div>
    <div class="meta">Posted on 2003-11-26 14:48:56 by MazeGen</div>
   </div>
   <div class="post" id="post-125632">
    <div class="subject"><a href="#post-125632">Data at Code Section</a></div>
    <div class="body"><div class="quote"><br /><br />Try it ;)<br /></div><br />Ok, I will. (I'm curious) :)<br /><div class="quote"><strong>Do you think there is any way how to get, with 100% assurance, the value at [404000] at run-time, when we disassemble at disasm-time, even using heuristics? I'm asking because I'm just exploring it.</div><br />F0dder probably know better than me, but IMHO it's possible by simulation of code execution. But just as long as the value in [4040000] does not depend on other factors that can't be simulated (like timers, I/O or user input, etc).</div>
    <div class="meta">Posted on 2003-11-26 16:24:16 by QvasiModo</div>
   </div>
   <div class="post" id="post-125685">
    <div class="subject"><a href="#post-125685">Data at Code Section</a></div>
    <div class="body">hi all,<br />thnx guys for the ideas.<br />so walking branches &amp; marking adresss as valid is a 'quick' sulotion, so i guess it somehow reduces few 'data' parts.<br />simulating code without knowing the register's values and on the fly data isn't much of a good sulotion is it ? ;)<br />i guess when it comes to heruistic it looks for 'bad' commands, 'weird' opcodes which usually doesn't fit or will not be created by 'normal' compiler.<br /><br />let's not forget Zen when checking if code is data ;D</div>
    <div class="meta">Posted on 2003-11-27 00:30:00 by wizzra</div>
   </div>
   <div class="post" id="post-125698">
    <div class="subject"><a href="#post-125698">Data at Code Section</a></div>
    <div class="body">well, i'v done some hand analyse, with a 'stack' based idea for return addersses.<br />do you think its too much for basic analyse or you would suggest a simplier algo?<br />below analyse is fully  analysed ..just a snippet.<br /><br /><pre><code><br />=================================<br />assume entry point&#58; &#40; i know its a function ;P&#41;<br />=================================<br />0040116C   . 55             PUSH EBP v<br />0040116D   . 8BEC           MOV EBP,ESP v<br />0040116F   . 817D 0C 840000&gt;CMP DWORD PTR SS&#58;&#91;EBP+C&#93;,84 v<br />00401176   . 75 05          JNZ SHORT DESPATCH.0040117D *<br />00401178   . E9 A3000000    JMP DESPATCH.00401220<br />0040117D   &gt; 837D 0C 01     CMP DWORD PTR SS&#58;&#91;EBP+C&#93;,1 v<br />00401181   . 75 16          JNZ SHORT DESPATCH.00401199 * <br />00401183   . FF75 14        PUSH DWORD PTR SS&#58;&#91;EBP+14&#93;<br />00401186   . FF75 10        PUSH DWORD PTR SS&#58;&#91;EBP+10&#93;<br />00401189   . FF75 0C        PUSH DWORD PTR SS&#58;&#91;EBP+C&#93;<br />0040118C   . FF75 08        PUSH DWORD PTR SS&#58;&#91;EBP+8&#93;<br />0040118F   . E8 B7000000    CALL DESPATCH.0040124B<br />00401194   . E9 87000000    JMP DESPATCH.00401220<br />00401199   &gt; 817D 0C 110100&gt;CMP DWORD PTR SS&#58;&#91;EBP+C&#93;,111 v <br />004011A0   . 75 13          JNZ SHORT DESPATCH.004011B5 *<br />004011A2   . FF75 14        PUSH DWORD PTR SS&#58;&#91;EBP+14&#93; v<br />004011A5   . FF75 10        PUSH DWORD PTR SS&#58;&#91;EBP+10&#93; v <br />004011A8   . FF75 0C        PUSH DWORD PTR SS&#58;&#91;EBP+C&#93; v<br />004011AB   . FF75 08        PUSH DWORD PTR SS&#58;&#91;EBP+8&#93; v<br />004011AE   . E8 CA000000    CALL DESPATCH.0040127D <br />004011B3   . EB 6B          JMP SHORT DESPATCH.00401220<br />004011B5   &gt; 837D 0C 0F     CMP DWORD PTR SS&#58;&#91;EBP+C&#93;,0F v <br />004011B9   . 75 1C          JNZ SHORT DESPATCH.004011D7 *<br />004011BB   . FF75 14        PUSH DWORD PTR SS&#58;&#91;EBP+14&#93; v               <br />004011BE   . FF75 10        PUSH DWORD PTR SS&#58;&#91;EBP+10&#93;  v             <br />004011C1   . FF75 0C        PUSH DWORD PTR SS&#58;&#91;EBP+C&#93; v               <br />004011C4   . FF75 08        PUSH DWORD PTR SS&#58;&#91;EBP+8&#93;  v              <br />004011C7   . E8 F8000000    CALL DESPATCH.004012C4 *                  <br />004011CC   . B8 00000000    MOV EAX,0 v <br />004011D1   . C9             LEAVE v<br />004011D2   . C2 1000        RETN 10 v<br />004011D7   &gt; 837D 0C 10     CMP DWORD PTR SS&#58;&#91;EBP+C&#93;,10 v<br />004011DB   . 75 1B          JNZ SHORT DESPATCH.004011F8 * <br />004011DD   . FF75 14        PUSH DWORD PTR SS&#58;&#91;EBP+14&#93; v<br />004011E0   . FF75 10        PUSH DWORD PTR SS&#58;&#91;EBP+10&#93; v <br />004011E3   . FF75 0C        PUSH DWORD PTR SS&#58;&#91;EBP+C&#93; v<br />004011E6   . FF75 08        PUSH DWORD PTR SS&#58;&#91;EBP+8&#93; v<br />004011E9   . E8 14010000    CALL DESPATCH.00401302 *<br />004011EE   . 0BC0           OR EAX,EAX v <br />004011F0   . 75 2E          JNZ SHORT DESPATCH.00401220 *<br />004011F2   . C9             LEAVE v<br />004011F3   . C2 1000        RETN 10 v<br />004011F8   &gt; 837D 0C 02     CMP DWORD PTR SS&#58;&#91;EBP+C&#93;,2 v<br />004011FC   . 75 1C          JNZ SHORT DESPATCH.0040121A *<br />004011FE   . FF75 14        PUSH DWORD PTR SS&#58;&#91;EBP+14&#93; v<br />00401201   . FF75 10        PUSH DWORD PTR SS&#58;&#91;EBP+10&#93; v<br />00401204   . FF75 0C        PUSH DWORD PTR SS&#58;&#91;EBP+C&#93; v<br />00401207   . FF75 08        PUSH DWORD PTR SS&#58;&#91;EBP+8&#93; v<br />0040120A   . E8 32010000    CALL DESPATCH.00401341 *<br />0040120F   . B8 00000000    MOV EAX,0 v<br />00401214   . C9             LEAVE v <br />00401215   . C2 1000        RETN 10 v <br />00401218   . EB 06          JMP SHORT DESPATCH.00401220<br />0040121A   &gt; 837D 0C 05     CMP DWORD PTR SS&#58;&#91;EBP+C&#93;,5 v <br />0040121E   . 75 00          JNZ SHORT DESPATCH.00401220 * <br />00401220   &gt; FF75 14        PUSH DWORD PTR SS&#58;&#91;EBP+14&#93;   v             <br />00401223   . FF75 10        PUSH DWORD PTR SS&#58;&#91;EBP+10&#93;  v             <br />00401226   . FF75 0C        PUSH DWORD PTR SS&#58;&#91;EBP+C&#93;   v             <br />00401229   . FF75 08        PUSH DWORD PTR SS&#58;&#91;EBP+8&#93;   v             <br />0040122C   . E8 69010000    CALL &lt;JMP.&amp;USER32.DefWindowProcA&gt;  *-api      <br />00401231   . C9             LEAVE v <br />00401232   . C2 1000        RETN 10 v <br />00401341  /$ 55             PUSH EBP   v<br />00401342  |. 8BEC           MOV EBP,ESP v<br />00401344  |. 6A 00          PUSH 0    v                               <br />00401346  |. E8 85000000    CALL &lt;JMP.&amp;USER32.PostQuitMessage&gt;       <br />0040134B  |. C9             LEAVE v<br />0040134C  \. C2 1000        RETN 10 v<br />00401302  /$ 55             PUSH EBP v <br />00401303  |. 8BEC           MOV EBP,ESP v <br />00401305  |. EB 14          JMP SHORT DESPATCH.0040131B * <br />00401307  |. 50 6C 65 61 73&gt;ASCII &quot;Please Confirm E&quot;<br />00401317  |. 78 69 74 00    ASCII &quot;xit&quot;,0<br />0040131B  |&gt; 6A 04          PUSH 4   v                                <br />0040131D  |. 68 00304000    PUSH DESPATCH.00403000  v                 <br />00401322  |. 68 07134000    PUSH DESPATCH.00401307 v                  <br />00401327  |. FF75 08        PUSH DWORD PTR SS&#58;&#91;EBP+8&#93; v               <br />0040132A  |. E8 9B000000    CALL &lt;JMP.&amp;USER32.MessageBoxA&gt;  *-api     <br />0040132F  |. 83F8 07        CMP EAX,7 v<br />00401332  |. 75 09          JNZ SHORT DESPATCH.0040133D *<br />00401334  |. B8 00000000    MOV EAX,0 v<br />00401339  |. C9             LEAVE v<br />0040133A  |. C2 1000        RETN 10 v<br />0040133D  |&gt; C9             LEAVE v<br />0040133E  \. C2 1000        RETN 10 v <br /><br /><br />///////////////////////////////////////////////////////////////<br /> 			Analysis<br />///////////////////////////////////////////////////////////////<br />walked Addr |    ret adderss     | removed | counter of removed<br />///////////////////////////////////////////////////////////////<br /><br />;v - marked address as Code<br />;* - jmp/call<br /><br />0040116C<br />0040116D<br />0040116F<br />00401176 - 00401176 + opcodeSize<br />0040117D<br />00401181 - 00401181 + opcodeSize<br />00401199<br />004011A0 - 004011A0 + opcodeSize<br />004011B5<br />004011B9 - 004011B9 + opcodeSize &#91;x&#93; 9<br />004011D7 <br />004011DB - 004011DB + opcodeSize &#91;x&#93; 4<br />004011F8<br />004011FC - 004011FC + opcodeSize &#91;x&#93; 2<br />0040121A<br />0040121E - 0040121E + opcodeSize &#91;x&#93; 1 <br />00401220<br />00401223<br />00401226<br />00401229<br />0040122C<br />00401231<br />00401232 - ret<br />if&#40;ret&#41;<br />&#123; <br />if&#40;.Size&#40;&#41;&#41;<br />   pop_back&#40;&#41;<br />&#125;<br />for&#40;..&#41;<br />&#123;<br />if&#40;.size&#40;&#41;&#41;<br /> if &#40;addr==foundAddr&#41;<br />   &#123;<br />    pop_back&#40;&#41;;<br />    break;<br />   &#125;<br />&#125;<br />004011FE<br />00401201<br />00401204<br />00401207   <br />0040120A - 0040120A + opcodeSize &#91;x&#93; 3<br />00401341<br />00401342<br />00401344<br />00401346<br />0040134B<br />0040134C - ret<br />if&#40;ret&#41;<br />&#123; <br />if&#40;.Size&#40;&#41;&#41;<br />   pop_back&#40;&#41;<br />&#125;<br />for&#40;..&#41;<br /> ...<br />&#125;<br />0040120F<br />00401214<br />00401215 - ret<br />if&#40;ret&#41;<br />&#123; <br />if&#40;.Size&#40;&#41;&#41;<br />   pop_back&#40;&#41;<br />&#125;<br />for&#40;..&#41;<br />...<br />&#125;<br />004011DD<br />004011E0<br />004011E3<br />004011E6<br />004011E9 - 004011E9 + opcodeSize &#91;x&#93; 6<br />00401302<br />00401303<br />00401305<br />0040131B<br />0040131D<br />00401322<br />00401327<br />0040132A<br />0040132F<br />00401332 - 00401332 + opcodeSize &#91;x&#93; 5<br />0040133D<br />0040133E<br />if&#40;ret&#41;<br />&#123; <br />if&#40;.Size&#40;&#41;&#41;<br />   pop_back&#40;&#41;<br />&#125;<br />for&#40;..&#41;<br />...<br />&#125;<br />00401334<br />00401339<br />0040133A<br />if&#40;ret&#41;<br />&#123; <br />if&#40;.Size&#40;&#41;&#41;<br />   pop_back&#40;&#41;<br />&#125;<br />for&#40;..&#41;<br />...<br />&#125;<br />004011EE<br />004011F0 - 004011F0 + opcodeSize &#91;x&#93; 7<br />004011F2<br />004011F3 - ret<br />if&#40;ret&#41;<br />&#123; <br />if&#40;.Size&#40;&#41;&#41;<br />   pop_back&#40;&#41;<br />&#125;<br />for&#40;..&#41;<br />...<br />&#125;<br />004011BB<br />004011BE<br />004011C1<br />004011C4<br />004011C7 - 004011C7 + opcodeSize &#91;x&#93; 8<br />004011CC<br />004011D1<br />004011D2 - ret<br />if&#40;ret&#41;<br />&#123; <br />if&#40;.Size&#40;&#41;&#41;<br />   pop_back&#40;&#41;<br />&#125;<br />for&#40;..&#41;<br />...<br />&#125;<br />004011A2<br />004011A5<br />004011A8<br />004011AB<br />004011AE - 004011AE + opcodeSize<br />....<br />....<br />....<br />....<br /></code></pre></div>
    <div class="meta">Posted on 2003-11-27 02:15:50 by wizzra</div>
   </div>
   <div class="post" id="post-126274">
    <div class="subject"><a href="#post-126274">Data at Code Section</a></div>
    <div class="body">Hi Wizzra,<br />I didn't fully understand, how your analysis works.<br /><br />Anyway, in such case is not difficult to recognize text between code (listed according to importance):<br /><br />1. There is no entry point at [00401307]<br />2. Last byte of these no-entry-point-bytes is zero (ASCIIZ string)<br /><br />Using heuristic, there could be recognized the following points:<br /><br />3. At [00401307] should be ASCIIZ string for MessageBox<br />4. All bypassed bytes are within ASCIIZ range<br />5. Bypassed bytes, interpretted as code, seems to be quite strange:<br /><pre><code><br />00401307 50           push    eax			; 'P'<br />00401308 6C           insb				; 'l'		; strange&#58; I/O operation at user-level code<br />00401309 6561         popad gs&#58;			; 'ea'		; strange&#58; 1.with segment prefix 2.after push eax<br />0040130B 7365         jnb     00401372		; 'se'		; strange&#58; probably inside instruction<br />0040130D 20436F       and     &#91;ebx+6F&#93;,al		; ' Co'<br />00401310 6E           outsb				; 'n'		; strange&#58; I/O operation at user-level code<br />00401311 6669726D2045 imul    si,&#91;edx+6D&#93;,4520	; 'firm E'	; strange&#58; 16bit operands<br />00401317 7869         js      00401382		; 'xi'		; strange&#58; probably inside instruction<br />00401319 7400         je      0040131B		; 't',0<br /></code></pre></div>
    <div class="meta">Posted on 2003-12-02 08:18:32 by MazeGen</div>
   </div>
   <div class="post" id="post-126292">
    <div class="subject"><a href="#post-126292">Data at Code Section</a></div>
    <div class="body">hi,<br /><br />yes, heruistic is a good way indeed, and there could be lotsa ways to check for 'strange' code, this however makes the disasm engine too much slow.<br />i came the idea that even if u create an algorithm, it wont be perfect, so i also added the possibility for the user to create his own data segments in code beside an automated algo which will suggest data locations (user can delete/modify them).<br /><br />the algo above, will scan code untill reaches a branch (jxx / call) and will push (stack based algo) the next instruction's address (same as the cpu does), once upon a ret we pop the address last in the stack and continue from there (LIFO algo), when tracing the braches, you mark all the addresses considers valid, the ones which are suppose to be data will not be marked.<br />thus an anti-disasm will kick it, also a heuristic should be added indeed.<br />there is no perfect way, thats why user define - control brings the best of it.<br /><br />-Wizzta</div>
    <div class="meta">Posted on 2003-12-02 11:10:54 by wizzra</div>
   </div>
  </div>
 </body>
</html>