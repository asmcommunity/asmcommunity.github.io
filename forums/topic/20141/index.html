<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>OpenGL Engine DLL - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20141" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=20141">OpenGL Engine DLL</a></p>
   <div class="post" id="post-154275">
    <div class="subject"><a href="#post-154275">OpenGL Engine DLL</a></div>
    <div class="body">I'd like to discuss a problem with my implementation of a Joint Hierarchy.<br />But let me digress and describe the engine's entities in some detail, and in the order in which they were implemented.<br /><br />So far I have two instanceable entities which I am perfectly happy with.<br />They are a textured cube and a textured sphere.<br /><br />The textured cube instances are very simple - they are constructed in world space (the vertices are explicit), so no transformation is required in order to position them in world space.<br /><br />The sphere instances are not much more complex - each instance has position (x,y,z) values , I am using glTranslatef to position them, bounded by glPushMatrix and glPopMatrix:<br /><br />invoke glPushMatrix<br />invoke glTranslatef, x,y,z<br />invoke RenderSphere<br />invoke glPopMatrix<br /><br />Finally we have the &quot;joint hierarchy&quot; entity. It's a hierarchy of nodes (a linkedlist) in which each node contains a transform matrix.<br />These matrices describe the transformation required to position and orient each joint with respect to its &quot;parent&quot;. For the case of the first node, the parent matrix is Identity matrix.<br />The logic looks something like this:<br /><br />localMat = thisMat * parentMat<br />invoke glLoadMatrix, addr localMat<br />invoke RenderSphere<br />iterate for Children, handing them localMat<br />iterate for Siblings, handing them parentMat<br /><br />Basically, the transforms are succeeding.<br />If I set the translation of each joint node by hand, I can see this is so.<br />The problem I have is that they are &quot;stuck to the camera&quot;, which I find bizarre in light of the fact that I am FORCING the modelview matrix.<br />Note that I am NOT using the matrix stack for this stuff.<br /><br />If anyone is willing to help me with this issue, I'd surely love to hear from you, I want to know what the heck is going wrong. I am willing to post everything.<br /><br />TIA, Homer.</div>
    <div class="meta">Posted on 2004-12-17 00:15:56 by Homer</div>
   </div>
   <div class="post" id="post-154394">
    <div class="subject"><a href="#post-154394">OpenGL Engine DLL</a></div>
    <div class="body">Since I'm not drawing any responses, I'm going to post my camera class code so that you can see I am not screwing the matrix stack in there.<br />Note that it incorporates some frustum culling methods so that objects can be culled against the frustum of the active camera :)<br /><br /><pre><code><br />.data<br />    kSpeed REAL4 12.0f      ;This controls camera travel speed<br />.code<br /><br />;Camera Class by Homer<br />;based on CCamera by DigiBen &#40;gametutorials.com&#41;<br /><br />Vec3 struct<br />    X REAL4 ?<br />    Y  REAL4 ?<br />    Z  REAL4 ?<br />Vec3 ends<br /><br />class Camera, ,C++ compatible<br />    void PositionCamera&#58;pPos, pView, pUp  ;This changes the position, view, and up vector of the camera, primarily used for initialization<br />    void RotateView&#58;fAngle, fX, fY, fZ ;This rotates the camera's view around the position depending on the values passed in.<br />    void SetViewByMouse                  ;This moves the camera's view by the mouse movements &#40;First person view&#41;<br />    void RotateAroundPoint&#58;pCenter, fX, fY, fZ ;This rotates the camera around a point &#40;I.E. your character&#41;.<br />    void StrafeCamera&#58;fspeed            ;This strafes the camera left or right depending on the speed &#40;+/-&#41; <br />    void MoveCamera&#58;fspeed             ;This will move the camera forward or backward depending on the speed<br />    void CheckForMovement              ;This checks for keyboard movement<br />    void Update                                   ;This updates the camera's view and other data &#40;Should be called each frame&#41;<br />    void Look                                      ;This uses gluLookAt&#40;&#41; to tell OpenGL where to look<br />;===<br />    void CullPoint&#58;pPoint                       ;These methods are used to perform frustum cull testing<br />    void CullCube&#58;pOrigin, fRadius       <br />    void CullSphere&#58;pOrigin, fRadius <br />;===<br />    des vPosition Vec3<br />    des vView Vec3<br />    des vUpVector Vec3<br />    des vStrafe Vec3<br />    float currentRotX                           ;This tracks the up/down rotation &#40;around X&#41; used to limit rotation &#40;anti-gimbal&#41;<br />    long pFrustum<br />endclass<br /><br />;*** NOTE ***<br />;For those of you who are not familiar with ATC oop programming, please know<br />;that the above &quot;class definition&quot; defines the Camera struct as follows&#58;<br />;Camera struct<br />;  vPosition  Vec3 &lt;?&gt;<br />;  vView        Vec3 &lt;?&gt;<br />;  vUpVector Vec3 &lt;?&gt;<br />;  vStrafe      Vec3 &lt;?&gt;<br />; currentRotX REAL4 ?<br />; pFrustum DWORD ?<br />;Camera ends<br />;<br />;The only other thing you should be aware of is that on entry to any<br />;of these &quot;class method&quot; procedures, ecx contains a pointer to the above struct.<br />;Armed with that knowledge, any &quot;non oop asmcoder&quot; should be able to make sense of this &#58;&#41;<br /><br />Camera_Camera proc                          ;The Cam Constructor is called when a Cam is created<br />    mov &#91;ecx&#93;.Camera.pFrustum, new &#40;CFrustum&#41;   ;&lt;-- Create a Frustum instance owned by this Camera instance<br />    fld1<br />    fst   &#91;ecx&#93;.Camera.vUpVector.Y        ;Init a standard up vector &#40;Rarely ever changes&#41;<br />    fstp &#91;ecx&#93;.Camera.vView.Z               ;Init a starting view vector &#40;looking up and out the screen&#41; <br />    fld r4_0_5<br />    fstp  &#91;ecx&#93;.Camera.vView.Y<br />    mov ebx, dwWindowWidth              ;Put the mouse in the middle of the screen so that we<br />    shr ebx,1                                          ;don't rotate the cam unintentionally when we start up<br />    mov eax, dwWindowHeight <br />    shr eax,1<br />    invoke SetCursorPos,ebx, eax  <br />    ret<br />Camera_Camera endp<br /><br />Camera_$Camera proc                     ;The Cam Destructor has little work to do<br />    delete &#91;ecx&#93;.Camera.pFrustum<br />    ret<br />Camera_$Camera endp<br /><br />;This proc used to setup initial view params<br />Camera_PositionCamera proc uses esi pPos,pView,pUp<br />    mov esi,pPos<br />    fld &#91;esi&#93;.Vec3.X<br />    fstp &#91;ecx&#93;.Camera.vPosition.X<br />    fld &#91;esi&#93;.Vec3.Y<br />    fstp &#91;ecx&#93;.Camera.vPosition.Y<br />    fld &#91;esi&#93;.Vec3.Z<br />    fstp &#91;ecx&#93;.Camera.vPosition.Z<br /><br />    mov esi,pView<br />    fld &#91;esi&#93;.Vec3.X<br />    fstp &#91;ecx&#93;.Camera.vView.X<br />    fld &#91;esi&#93;.Vec3.Y<br />    fstp &#91;ecx&#93;.Camera.vView.Y<br />    fld &#91;esi&#93;.Vec3.Z<br />    fstp &#91;ecx&#93;.Camera.vView.Z<br /><br />    mov esi,pUp<br />    fld &#91;esi&#93;.Vec3.X<br />    fld &#91;esi&#93;.Vec3.Y<br />    fld &#91;esi&#93;.Vec3.Z<br />    fstp &#91;ecx&#93;.Camera.vUpVector.Z<br />    fstp &#91;ecx&#93;.Camera.vUpVector.Y<br />    fstp &#91;ecx&#93;.Camera.vUpVector.X<br />    ret<br />Camera_PositionCamera endp<br /><br />Camera_Update proc<br />local vLook&#58;Vec3         ;&lt;-- The current view vector &#40;the direction we are looking&#41;<br />local me<br />    mov me,ecx<br />    fld &#91;ecx&#93;.Camera.vView.X            ;Calculate our &quot;LOOK&quot; vector<br />    fsub &#91;ecx&#93;.Camera.vPosition.X   ;This is simply &#40;View - Position&#41;<br />    fstp vLook.X<br />    fld &#91;ecx&#93;.Camera.vView.Y<br />    fsub &#91;ecx&#93;.Camera.vPosition.Y<br />    fstp vLook.Y<br />    fld &#91;ecx&#93;.Camera.vView.Z<br />    fsub &#91;ecx&#93;.Camera.vPosition.Z<br />    fstp vLook.Z                             ;Good.. now get CrossProduct of Look and Up vectors &#40;the Strafe vector&#41;<br />    invoke Vec3Cross, addr vLook, addr &#91;ecx&#93;.Camera.vUpVector, addr &#91;ecx&#93;.Camera.vStrafe<br />    invoke Vec3Normalize, addr &#91;ecx&#93;.Camera.vStrafe           ; Normalize the strafe vector<br />    icall me, Camera, SetViewByMouse                                  ; Move the camera's view by the mouse<br />    icall me, Camera, CheckForMovement                              ; This checks to see if the keyboard was pressed<br />    mov ecx,me<br />    icall &#91;ecx&#93;.Camera.pFrustum, CFrustum, CalculateFrustum ;Do this whenever the Camera has moved<br />    ret<br />Camera_Update endp<br /><br />Camera_StrafeCamera proc fspeed<br />    fld &#91;ecx&#93;.Camera.vStrafe.X                  ; Add the strafe vector to our position<br />    fmul fspeed<br />    fadd &#91;ecx&#93;.Camera.vPosition.X<br />    fstp &#91;ecx&#93;.Camera.vPosition.X<br />;    fld &#91;ecx&#93;.Camera.vStrafe.Y                 ;&#40;don't strafe in Y&#41;<br />;    fmul fspeed<br />;    fadd &#91;ecx&#93;.Camera.vPosition.Y<br />;    fstp &#91;ecx&#93;.Camera.vPosition.Y<br />    fld &#91;ecx&#93;.Camera.vStrafe.Z<br />    fmul fspeed<br />    fadd &#91;ecx&#93;.Camera.vPosition.Z<br />    fstp &#91;ecx&#93;.Camera.vPosition.Z<br /><br />;// Add the strafe vector to our view vector<br />    fld &#91;ecx&#93;.Camera.vStrafe.X                  ; Add the strafe vector to our view vector<br />    fmul fspeed<br />    fadd &#91;ecx&#93;.Camera.vView.X<br />    fstp &#91;ecx&#93;.Camera.vView.X<br />;    fld &#91;ecx&#93;.Camera.vStrafe.Y                                  ;&#40;don't strafe in Y&#41;<br />;    fmul fspeed<br />;    fadd &#91;ecx&#93;.Camera.vView.Y<br />;    fstp &#91;ecx&#93;.Camera.vView.Y<br />    fld &#91;ecx&#93;.Camera.vStrafe.Z<br />    fmul fspeed<br />    fadd &#91;ecx&#93;.Camera.vView.Z<br />    fstp &#91;ecx&#93;.Camera.vView.Z<br />    ret<br />Camera_StrafeCamera endp<br /><br />;Move the camera according to speed and direction of travel<br />Camera_MoveCamera proc fspeed<br />local vLook&#58;Vec3<br />local vAccel&#58;Vec3<br />local me<br />; Get the current LOOK vector &#40;the direction we are looking&#41;<br />    mov me,ecx<br />    fld &#91;ecx&#93;.Camera.vView.X<br />    fsub &#91;ecx&#93;.Camera.vPosition.X<br />    fstp vLook.X<br />    fld &#91;ecx&#93;.Camera.vView.Y<br />    fsub &#91;ecx&#93;.Camera.vPosition.Y<br />    fstp vLook.Y<br />    fld &#91;ecx&#93;.Camera.vView.Z<br />    fsub &#91;ecx&#93;.Camera.vPosition.Z<br />    fstp vLook.Z<br />    invoke Vec3Normalize, addr vLook<br /><br />    mov ecx,me<br /><br />    fld vLook.X                                          ;&lt;--Calculate Acceleration vector<br />    fmul fspeed                                       <br />    fst vAccel.X<br />    fadd &#91;ecx&#93;.Camera.vPosition.X           ;&lt;-- and add it to our Position vector<br />    fstp  &#91;ecx&#93;.Camera.vPosition.X<br /><br />    fld vLook.Y<br />    fmul fspeed<br />    fst vAccel.Y<br />    fadd &#91;ecx&#93;.Camera.vPosition.Y<br />    fstp  &#91;ecx&#93;.Camera.vPosition.Y<br /><br />    fld vLook.Z<br />    fmul fspeed<br />    fst vAccel.Z<br />    fadd &#91;ecx&#93;.Camera.vPosition.Z<br />    fstp  &#91;ecx&#93;.Camera.vPosition.Z<br /><br />    fld vAccel.X                                ;&lt;-- Add our acceleration vector to our view vector<br />    fadd &#91;ecx&#93;.Camera.vView.X<br />    fstp &#91;ecx&#93;.Camera.vView.X<br />    fld vAccel.X<br />    fadd &#91;ecx&#93;.Camera.vView.X<br />    fstp &#91;ecx&#93;.Camera.vView.X<br />    fld vAccel.X<br />    fadd &#91;ecx&#93;.Camera.vView.X<br />    fstp &#91;ecx&#93;.Camera.vView.X<br />    ret<br />Camera_MoveCamera endp<br /><br />Camera_RotateView proc fAngle, fx, fy, fz<br />local vLook&#58;Vec3<br />local sinTheta<br />local cosTheta, OneMinusCosTheta<br />local me<br />; Get the Look vector &#40;The direction we are facing&#41;<br />    mov me,ecx<br />    fld &#91;ecx&#93;.Camera.vView.X<br />    fsub &#91;ecx&#93;.Camera.vPosition.X<br />    fstp vLook.X<br />    fld &#91;ecx&#93;.Camera.vView.Y<br />    fsub &#91;ecx&#93;.Camera.vPosition.Y<br />    fstp vLook.Y<br />    fld &#91;ecx&#93;.Camera.vView.Z<br />    fsub &#91;ecx&#93;.Camera.vPosition.Z<br />    fstp vLook.Z<br /><br />; Calculate the sine and cosine of the angle once<br />    fld fAngle<br />    fsincos<br />    fstp cosTheta <br />    fstp sinTheta<br /><br />; Find the new x position for the new rotated point<br />;vNewView.x  = &#40;cosTheta + &#40;1 - cosTheta&#41; * x * x&#41;		* vView.x;<br />    fld1<br />    fsub cosTheta<br />    fst OneMinusCosTheta<br />    fmul fx<br />    fmul fx<br />    fadd cosTheta    <br />    fmul vLook.X<br />;vNewView.x += &#40;&#40;1 - cosTheta&#41; * x * y - z * sinTheta&#41;	* vView.y;<br />    fld OneMinusCosTheta<br />    fmul fx<br />    fmul fy<br />    fld fz<br />    fmul sinTheta<br />    fadd<br />    fmul vLook.Y<br />    fadd<br />;vNewView.x += &#40;&#40;1 - cosTheta&#41; * x * z + y * sinTheta&#41;	* vView.z;<br />    fld OneMinusCosTheta<br />    fmul fx<br />    fmul fz<br />    fld fy<br />    fmul sinTheta<br />    fadd<br />    fmul vLook.Z<br />    fadd<br />    fadd &#91;ecx&#93;.Camera.vPosition.X    <br />    fstp &#91;ecx&#93;.Camera.vView.X<br /><br />;--------<br />; Find the new y position for the new rotated point<br />;vNewView.y  = &#40;&#40;1 - cosTheta&#41; * x * y + z * sinTheta&#41;	* vView.x;<br />    fld OneMinusCosTheta<br />    fmul fx<br />    fmul fy<br />    fld fz<br />    fmul sinTheta<br />    fadd<br />    fmul vLook.X<br />;vNewView.y += &#40;cosTheta + &#40;1 - cosTheta&#41; * y * y&#41;		* vView.y;<br />    fld OneMinusCosTheta<br />    fmul fy<br />    fmul fy<br />    fadd cosTheta<br />    fmul vLook.Y<br />    fadd<br />;vNewView.y += &#40;&#40;1 - cosTheta&#41; * y * z - x * sinTheta&#41;	* vView.z;<br />    fld OneMinusCosTheta<br />    fmul fy<br />    fmul fz<br />    fld fx<br />    fmul sinTheta<br />    fsub<br />    fmul vLook.Z<br />    fadd<br />    fadd &#91;ecx&#93;.Camera.vPosition.Y<br />    fstp &#91;ecx&#93;.Camera.vView.Y<br /><br />;--------<br />; Find the new z position for the new rotated point<br />;NewView.z  = &#40;&#40;1 - cosTheta&#41; * x * z - y * sinTheta&#41;	* vView.x;<br />    fld OneMinusCosTheta<br />    fmul fx<br />    fmul fz<br />    fld fy<br />    fmul sinTheta<br />    fsub<br />    fmul vLook.X<br />;NewView.z += &#40;&#40;1 - cosTheta&#41; * y * z + x * sinTheta&#41;	* vView.y;<br />    fld OneMinusCosTheta<br />    fmul fy<br />    fmul fz<br />    fld fx<br />    fmul sinTheta<br />    fadd<br />    fmul vLook.Y<br />    fadd<br />;NewView.z += &#40;cosTheta + &#40;1 - cosTheta&#41; * z * z&#41;		* vView.z;<br />    fld OneMinusCosTheta<br />    fmul fz<br />    fmul fz<br />    fadd cosTheta<br />    fmul vLook.Z<br />    fadd<br />    fadd &#91;ecx&#93;.Camera.vPosition.Z <br />    fstp &#91;ecx&#93;.Camera.vView.Z<br />    ret<br />Camera_RotateView endp<br /><br />Camera_SetViewByMouse proc<br />local me<br />local middleX, middleY<br />local angleY, angleZ<br />local vLook&#58;Vec3<br />local vRight&#58;Vec3<br />local mousePos&#58;POINT    ;                                            // This is a window structure that holds an X and Y<br />	<br />    mov me,ecx<br /><br />    mov eax, dwWindowWidth  <br />    shr eax,1<br />    mov middleX,eax<br />    mov eax, dwWindowHeight <br />    shr eax,1<br />    mov middleY,eax<br />    invoke GetCursorPos,addr mousePos   ; Get the mouse's current X,Y position<br />	<br />; If our cursor is still in the middle, we never moved... so don't update the screen<br />    mov eax,middleX<br />    mov ebx,middleY<br />    .if mousePos.x == eax &amp;&amp; mousePos.y == ebx<br />         ret<br />     .endif<br /><br />; Set the mouse position to the middle of our window<br />    invoke SetCursorPos,middleX, middleY<br />    mov ecx,me<br /><br />; Get the direction the mouse moved in, but bring the number down to a reasonable amount<br />     fild middleX<br />     fisub mousePos.x<br />     fdiv r4_500_0<br />     fstp angleY<br />     fild middleY<br />     fisub mousePos.y<br />     fdiv r4_500_0<br />     fstp angleZ<br /><br />; Calculate the Look vector<br />    fld &#91;ecx&#93;.Camera.vView.X<br />    fsub &#91;ecx&#93;.Camera.vPosition.X<br />    fstp vLook.X<br />    fld &#91;ecx&#93;.Camera.vView.Y<br />    fsub &#91;ecx&#93;.Camera.vPosition.Y<br />    fstp vLook.Y<br />    fld &#91;ecx&#93;.Camera.vView.Z<br />    fsub &#91;ecx&#93;.Camera.vPosition.Z<br />    fstp vLook.Z<br /><br />; Here we keep track of the current rotation &#40;for up and down&#41; so that<br />; we can restrict the camera from doing a full 360 loop.<br />;currentRotX -= angleZ;  <br />      mov ecx,me<br />      fld &#91;ecx&#93;.Camera.currentRotX <br />      fsub angleZ<br />      fstp &#91;ecx&#93;.Camera.currentRotX <br /><br />; If the current rotation &#40;in radians&#41; is greater than 1.0, we want to cap it.<br />    fld  &#91;ecx&#93;.Camera.currentRotX <br />    fcomp r4_1_0<br />    __FJLE @F            ;if&#40;currentRotX &gt; 1.0f&#41;<br />    fld1<br />    fstp  &#91;ecx&#93;.Camera.currentRotX ;currentRotX = 1.0f;<br />    jmp NoProbs<br /><br />@@&#58;<br />; Check if the rotation is below -1.0, if so we want to make sure it doesn't continue<br />    fld  &#91;ecx&#93;.Camera.currentRotX <br />    fcomp r4_m1_0	;else if&#40;currentRotX &lt; -1.0f&#41;<br />    __FJGE @F<br />    fld1<br />    fchs<br />    fstp  &#91;ecx&#93;.Camera.currentRotX          ;currentRotX = -1.0f;<br />    jmp NoProbs<br /><br />; Otherwise, we can rotate the view around our position<br />@@&#58; 	;else<br /><br />;THIS CODE IS REDUNDANT BECAUSE WE ALREADY CALCULATED<br />;THIS VECTOR IN THE CAMERA_UPDATE METHOD<br />; To find the axis we need to rotate around for up and down<br />; movements, we need to get a perpendicular vector from the<br />; camera's view vector and up vector.  This will be the axis.<br />  ;  invoke Vec3Cross, addr vLook, addr &#91;ecx&#93;.Camera.vUpVector,addr vRight<br />  ;  invoke Vec3Normalize, addr vRight<br /><br />;Rotate around our perpendicular axis and along the y-axis<br />    mov ecx,me<br />    icall me, Camera, RotateView, angleZ, &#91;ecx&#93;.Camera.vStrafe.X, &#91;ecx&#93;.Camera.vStrafe.Y, &#91;ecx&#93;.Camera.vStrafe.Z<br /><br />NoProbs&#58;<br />;Rotate around the y axis no matter what the currentRotX is<br />    icall me, Camera, RotateView, angleY,0, r4_1_0, 0<br />    ret<br />Camera_SetViewByMouse endp<br /><br />Camera_CheckForMovement proc<br />local fspeed, fmspeed<br /><br />    fld kSpeed<br />    fmul fTimeElapsed<br />    fst fspeed    <br />    fchs<br />    fstp fmspeed<br /><br />    .if bMoveForwards         ; Move our camera forward by a positive SPEED<br />         icall ecx, Camera, MoveCamera, fspeed<br />    .endif<br /><br />    .if bMoveBackwards            ; Move our camera forward by a positive SPEED<br />         icall ecx, Camera, MoveCamera, fmspeed<br />    .endif<br /><br />    .if bMoveLeft<br />         icall ecx, Camera, StrafeCamera, fmspeed<br />    .endif<br /><br />    .if bMoveRight<br />         icall ecx, Camera, StrafeCamera, fspeed<br />    .endif<br />    ret<br />Camera_CheckForMovement endp<br /><br />;This procedure just calls gluLookAt, and it's messy...<br />Camera_Look proc<br />local eyeX&#58;REAL8<br />local eyeY&#58;REAL8<br />local eyeZ&#58;REAL8<br />local camX&#58;REAL8<br />local camY&#58;REAL8<br />local camZ&#58;REAL8<br />local upX&#58;REAL8<br />local upY&#58;REAL8<br />local upZ&#58;REAL8<br /><br />;Convert Camera vectors to glDoubles for call to gluLookAt<br />    fld &#91;ecx&#93;.Camera.vUpVector.X<br />    fld &#91;ecx&#93;.Camera.vUpVector.Y<br />    fld &#91;ecx&#93;.Camera.vUpVector.Z<br />    fstp upZ<br />    fstp upY<br />    fstp upX<br />    fld &#91;ecx&#93;.Camera.vView.X<br />    fld &#91;ecx&#93;.Camera.vView.Y <br />    fld &#91;ecx&#93;.Camera.vView.Z<br />    fld &#91;ecx&#93;.Camera.vPosition.X<br />    fld &#91;ecx&#93;.Camera.vPosition.Y<br />    fld &#91;ecx&#93;.Camera.vPosition.Z<br />    fstp eyeZ<br />    fstp eyeY<br />    fstp eyeX<br />    fstp camZ<br />    fstp camY<br />    fstp camX<br /><br /><br />; Give openGL our camera position, camera view, and camera up vector<br />push dword ptr upZ&#91;4&#93;<br />push dword ptr upZ&#91;0&#93;<br />push dword ptr upY&#91;4&#93;<br />push dword ptr upY&#91;0&#93;<br />push dword ptr upX&#91;4&#93;<br />push dword ptr upX&#91;0&#93;<br />push dword ptr camZ&#91;4&#93;<br />push dword ptr camZ&#91;0&#93; <br />push dword ptr camY&#91;4&#93;<br />push dword ptr camY&#91;0&#93;<br />push dword ptr camX&#91;4&#93;<br />push dword ptr camX&#91;0&#93;<br />push dword ptr eyeZ&#91;4&#93;<br />push dword ptr eyeZ&#91;0&#93;<br />push dword ptr eyeY&#91;4&#93;<br />push dword ptr eyeY&#91;0&#93;<br />push  dword ptr eyeX&#91;4&#93;<br />push dword ptr eyeX&#91;0&#93;<br />call gluLookAt<br />ret<br />Camera_Look endp<br /><br />;====================================================================<br />; THE FOLLOWING METHODS RELATE ONLY TO FRUSTUM CULLING<br />;====================================================================<br />;This procedure performs frustum culling of a Vec3 coordinate &#40;a 3d point&#41;<br />;Returns TRUE if the point is not visible and thus should be culled<br />;Returns FALSE if the point is onscreen &#40;inside the frustum&#41;.<br />Camera_CullPoint proc pPoint&#58;ptr Vec3<br />    mov ebx, pPoint<br />    icall &#91;ecx&#93;.Camera.pFrustum, CFrustum, PointInFrustum, &#91;ebx&#93;, &#91;ebx+4&#93;,&#91;ebx+8&#93;<br />    ret<br />Camera_CullPoint endp<br /><br />;This procedure performs frustum culling of a 3D Cube given as 3D origin and fRadius<br />;Returns TRUE if the Cube is not visible and thus should be culled<br />;Returns FALSE if the Cube is onscreen &#40;inside the frustum&#41;.<br />Camera_CullCube proc pOrigin, fRadius<br />    mov ebx,pOrigin<br />    icall &#91;ecx&#93;.Camera.pFrustum, CFrustum, CubeInFrustum, &#91;ebx&#93;, &#91;ebx+4&#93;,&#91;ebx+8&#93;, fRadius<br />    ret<br />Camera_CullCube endp<br /><br />;This procedure performs frustum culling of a 3D Sphere given as 3D origin and fRadius<br />;Returns TRUE if the Sphere is not visible and thus should be culled<br />;Returns FALSE if the Sphere is onscreen &#40;inside the frustum&#41;.<br />Camera_CullSphere proc pOrigin, fRadius<br />    mov ebx,pOrigin<br />    icall &#91;ecx&#93;.Camera.pFrustum, CFrustum, SphereInFrustum, &#91;ebx&#93;, &#91;ebx+4&#93;,&#91;ebx+8&#93;, fRadius<br />    ret<br />Camera_CullSphere endp    <br /><br /></code></pre></div>
    <div class="meta">Posted on 2004-12-19 01:17:44 by Homer</div>
   </div>
  </div>
 </body>
</html>