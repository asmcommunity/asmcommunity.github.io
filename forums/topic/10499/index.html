<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Stack order problem - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=10499" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=10499">Stack order problem</a></p>
   <div class="post" id="post-78837">
    <div class="subject"><a href="#post-78837">Stack order problem</a></div>
    <div class="body">I can't keep the stack in order. How do I do?<br /><br />My problem is as follows. When the execution reaches the code below the stack contains 6 dwords from top. I want to copy the third and the fifth dword from top in the Gprmc process.<br /><br />The &quot;call REF_2&quot; pushes one dword on the stack and the &quot;pop eax&quot; restore the stack order. Then the reference point is pushed on the stack. Now i have 7 dwords on the stack.<br /><br />The &quot;call dword ptr&quot; pushes the return address on the stack. Now there are 8 dwords on the stack.<br /><br />In the Gprmc process ebp is pushed on the stack i.e. 9 dwords on the stack.<br /><br />Now I want to copy the original fifth dword (which now should be the eighth) and the third (which now should be the sixth).<br /><br />When returning from the process the stack must be as it was on the line after REF_2: so the reference point can be poped to eax again.<br /><br />Well, it doesn't work. Is my reasoning wrong. Are there any short cuts to keep the stack in order or how do one do. Can sombody help.<br /><br />This is the code.<br /><br /><pre><code><br />	call REF_2<br />REF_2&#58;<br />	pop eax<br />	sub eax,REF_2 ;Reference point<br />	push eax ;Store reference point<br />	call dword ptr&#91;eax+_GPRMC&#93; ;call Gprmc process<br />	pop eax <br />	jmp dword ptr &#91;eax+_NMEA&#93;<br />	ret<br /><br /><br /><br />Gprmc proc <br />	<br />	mov ecx,&#91;esp+&#40;7*4&#41;&#93;<br />	mov esi,&#91;esp+&#40;5*4&#41;&#93;<br />	<br /><br />	ret		<br />Gprmc endp<br /></code></pre></div>
    <div class="meta">Posted on 2003-01-28 16:42:01 by minor28</div>
   </div>
   <div class="post" id="post-78852">
    <div class="subject"><a href="#post-78852">Stack order problem</a></div>
    <div class="body">minor28,<br /><br />two things are somewhat confusing. First, you write:<br /><div class="quote">In the Gprmc process ebp is pushed on the stack</div><br />I don't think so. The Gprmc procedure has no parameters and no locals, so MASM won't set up a stack frame, and EBP won't be pushed.<br /><br />Then, you write:<br /><div class="quote">Now I want to copy the original fifth dword (which now should be the eighth) and the third (which now should be the sixth).</div><br />At the start of your post, you counted the DWORDs from top to bottom. Whatever number of DWORDs are being pushed after entering the procedure, the &quot;original fifth dword&quot; from the top will remain the fifth dword from the top, and can not suddenly become the eigth dword (from the top). Or did you mean something else?<br /><br />Anyway, here is my attempt at finding the correct figures for the Gprmc procedure. I hope it is not too weird  :-)<br /><br />Regards, Frank<br /><br /><br /><pre><code><br />&#91;COLOR=blue&#93;; x = 0&#91;/COLOR&#93;<br />; Stack&#58;<br />;   First  DWORD from top    ; &#91;esp + &#40;5+x&#41;*4&#93;<br />;   Second DWORD from top    ; &#91;esp + &#40;4+x&#41;*4&#93;<br />;   Third  DWORD from top    ; &#91;esp + &#40;3+x&#41;*4&#93; ; to be accessed later<br />;   Fourth DWORD from top    ; &#91;esp + &#40;2+x&#41;*4&#93;<br />;   Fifth  DWORD from top    ; &#91;esp + &#40;1+x&#41;*4&#93; ; to be accessed later<br />;   Sixth  DWORD from top    ; &#91;esp + &#40;0+x&#41;*4&#93;<br /><br /><br />	call    REF_2              ; push address of REF_2, then jump to REF_2<br />&#91;COLOR=blue&#93;; x = 1 because of the CALL&#91;/COLOR&#93;<br />REF_2&#58;<br />	pop     eax                ; pop address of REF_2<br />&#91;COLOR=blue&#93;; x = 0 because of the POP&#91;/COLOR&#93;<br />	sub     eax,REF_2          ; EAX = &#40;address of REF_2&#41; - &#40;address of REF_2&#41; = 0<br />	push    eax                ; push 0 onto stack<br />&#91;COLOR=blue&#93;; x = 1 because of the PUSH&#91;/COLOR&#93;<br />	call    dword ptr&#91;eax+_GPRMC&#93;; push return address, jump to procedure<br />&#91;COLOR=blue&#93;; x = 1 because of CALL followed by RET&#91;/COLOR&#93;<br />	pop     eax                ; pop 0 from stack<br />&#91;COLOR=blue&#93;; x = 0 because of the POP&#91;/COLOR&#93;<br />	jmp     dword ptr &#91;eax+_NMEA&#93;; jump to procedure<br />	ret                        ; this line will never be executed<br /><br />Gprmc proc <br />&#91;COLOR=blue&#93;; x = x + 1 because we arrive here by a CALL&#91;/COLOR&#93;<br />&#91;COLOR=blue&#93;; the procedure has neither parameters nor local variables<br />; therefore no stack frame will be created &#40;i.e., EBP isn't PUSHed&#41;&#91;/COLOR&#93;<br />&#91;COLOR=green&#93;<br />; the original third DWORD from top would be &#91;esp + &#40;3+x&#41;*4&#93; = &#91;esp + &#40;3+2&#41;*4&#93;<br />; the original fifth DWORD from top would be &#91;esp + &#40;1+x&#41;*4&#93; = &#91;esp + &#40;1+2&#41;*4&#93;<br />&#91;/COLOR&#93;<br />	mov     ecx,&#91;esp+&#40;7*4&#41;&#93;<br />	mov     esi,&#91;esp+&#40;5*4&#41;&#93;<br />	ret<br /><br />Gprmc endp<br /></code></pre></div>
    <div class="meta">Posted on 2003-01-28 18:35:11 by Frank</div>
   </div>
   <div class="post" id="post-79061">
    <div class="subject"><a href="#post-79061">Stack order problem</a></div>
    <div class="body"><div class="quote"><br />By default, PROC will generate a standard stack frame (pushing EBP onto the stack). I don't know how to nullify that in MASM.  So your ESP offsets are off by one DWORD. </div><br />tenkey, that's a strong assertion with important implications -- did you actually test it? My MASM32 installation behaves, and has always behaved, differently. The following code:<br /><pre><code><br />.486<br />.model flat,stdcall<br />option casemap&#58;none<br />include     \masm32\include\windows.inc<br />include     \masm32\include\kernel32.inc<br />includelib  \masm32\lib\kernel32.lib<br /><br />.CODE<br /><br />dummy proc<br />    ret<br />dummy endp<br /><br />start&#58;<br />    call    dummy<br />    invoke  ExitProcess, 0<br />end start<br /></code></pre><br />results in an executable that disassembles into:<br /><pre><code><br />Disassembly<br /><br />00401000                    fn_00401000&#58;<br />00401000 C3                     ret<br />00401001                    start&#58;<br />00401001 E8FAFFFFFF             call    fn_00401000<br />00401006 6A00                   push    0<br />00401008 FF1500204000           call    dword ptr &#91;ExitProcess&#93;<br /></code></pre><br />Because the dummy proc has neither parameters nor locals, MASM generates no stack frame, EBP doesn't get pushed, and ESP offsets are not off by one.<br /><br />Regards, Frank</div>
    <div class="meta">Posted on 2003-01-29 17:28:13 by Frank</div>
   </div>
   <div class="post" id="post-79072">
    <div class="subject"><a href="#post-79072">Stack order problem</a></div>
    <div class="body">I stand corrected.</div>
    <div class="meta">Posted on 2003-01-29 19:03:21 by tenkey</div>
   </div>
   <div class="post" id="post-79093">
    <div class="subject"><a href="#post-79093">Stack order problem</a></div>
    <div class="body">Thanks for your answer<br /><br />Actually there is one local so ebp is pushed and esp is decreased by 4. I found the right positions by testing. Nevertheless my main purpose with the thread was to inquire if there are som tricks or helptool to keep the stack in order though I understand that you do the same reasoning as I do.</div>
    <div class="meta">Posted on 2003-01-30 00:51:31 by minor28</div>
   </div>
   <div class="post" id="post-79191">
    <div class="subject"><a href="#post-79191">Stack order problem</a></div>
    <div class="body">There are two tricks that I am aware of. One trick is to use MASM's automatic stack frames which do an excellent job without any effort on the programmer's side.<br /><br />The other trick is to split the offset from ESP into its components. A procedure could look like this:<br /><pre><code><br />option prologue&#58;none<br />option epilogue&#58;none<br /><br />myproc proc param1&#58;DWORD, param2&#58;DWORD, param3&#58;DWORD<br /><br />; Stack&#58;<br />; 3rd procedure parameter = &#91;esp + &#40;3+0&#41;*4&#93;<br />; 2nd procedure parameter = &#91;esp + &#40;2+0&#41;*4&#93;<br />; 1st procedure parameter = &#91;esp + &#40;1+0&#41;*4&#93;<br />; return address          = &#91;esp + &#40;0+0&#41;*4&#93;<br /><br />    mov      eax,    &#91;esp + &#40;2+0&#41;*4&#93;  ; load the 2nd parameter into EAX<br />    push     ecx                      ; push something, just to change ESP<br />    mov      eax,    &#91;esp + &#40;2+1&#41;*4&#93;  ; load the 2nd parameter into EAX<br />    pop      ecx                      ; change ESP once more<br />    mov      eax,    &#91;esp + &#40;2+0&#41;*4&#93;  ; load the 2nd parameter into EAX<br /><br />    ret     3*4      ; clear 3 DWORD parameters from the stack on return<br /><br />myproc endp<br /></code></pre><br />The source code reveals immediately that we are doing the same thing in each of three lines: we are loading the second (&quot;2&quot;) parameter into EAX, taking changes to ESP into account (&quot;+0&quot; or &quot;+1&quot;). The notation is much clearer and less error-prone than switching from &quot;mov eax, &quot; to &quot;mov eax, &quot; and back.<br /><br />I noticed the method for the first time in code by buliaNaza (see, e.g., <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=5702">here</a> ), but I'm sure others have used it before. It is straightforward, self-documenting, and does not require extra tools like macros or equates. Most importantly, however, mental acrobatics becomes a thing of the past (&quot;if I push ECX now, then my former third DWORD above the initial stack pointer will become the fourth DWORD above the current stack pointer&quot; -- what???).<br /><br />You see, it is the little things that make me happy  :-)<br /><br />Regards, Frank</div>
    <div class="meta">Posted on 2003-01-30 10:29:34 by Frank</div>
   </div>
  </div>
 </body>
</html>