<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Small challenge - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29696" />
  <link rel="prev" href="../?id=29696&amp;page=1" />  <link rel="next" href="../?id=29696&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29696">Small challenge</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29696&amp;page=1" style="">&laquo;</a><a href="../?id=29696&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29696" /><input type="number" name="page" min="1" max="4" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=29696&amp;page=3">&gt;</a><a href="../?id=29696&amp;page=4">&raquo;</a></form>   <div class="post" id="post-209685">
    <div class="subject"><a href="#post-209685">Re: Small challenge</a></div>
    <div class="body">I was wondering why that CWDE is there - extended the sign bit does not contribute to the solution - especially given that we&#039;ve already masked out that bit specifically, and given that we then go on to overwrite it !!!<br />And I&#039;d be willing to bet that opcode is precisely what slows down that solution, too.<br />Wonder what the speed is like with that opcode omitted.<br /><br /></div>
    <div class="meta">Posted on 2009-11-22 22:52:13 by Homer</div>
   </div>
   <div class="post" id="post-209686">
    <div class="subject"><a href="#post-209686">Re: Small challenge</a></div>
    <div class="body">Scali, what is your c2d? Such different results from mine. <br /><br />I.e ANSI C 1&nbsp; is 6.56 cycles here, and ratios are all inconsistent with your bench-results. </div>
    <div class="meta">Posted on 2009-11-23 00:59:31 by Ultrano</div>
   </div>
   <div class="post" id="post-209687">
    <div class="subject"><a href="#post-209687">Re: Small challenge</a></div>
    <div class="body">The CWDE is only there to clear the high order bit. &nbsp;I used it as the instruction is only one byte long and I wasn&#039;t sure if we were going for size or speed. &nbsp;It can easily be replaced with an and:<br />EDIT: &nbsp;I had assumed that the high order nibble had to be cleared (for future ORing, etc.) - if not important, it can be omitted. &nbsp;My crude benchmarking (i.e. repeated execution between two GetTickCounts) points toward about a 10% time penalty.<br /><br /><pre><code>	movzx edx,ax<br />	shr eax,15<br />	shl dx,1<br />	shr ah,1<br />	shr dh,1<br />	shr ax,1<br />	shr dx,1<br />	shl eax,14<br />;	and eax,0x0FFFFFFF<br />	add eax,edx<br />	retn</code></pre><br /><br />I find it hard to believe that code would be even competitive with all the dependancies it has - I figured it might be size competitive though as I tried to avoid dword ands.<br /><br />Here&#039;s another bit manipulation version with some ands:<br /><pre><code>	shld edx,eax,31<br />	shld esi,eax,30<br />	shld edi,eax,29<br />	and eax,0x0000007F<br />	and edx,0x00003F80<br />	and esi,0x001FC000<br />	and edi,0x0FE00000<br />	or eax,edx<br />	or esi,edi<br />	or eax,esi</code></pre><br /><br />I think though, that shld might be kind of slow - it does appear to be faster than my first one, although slower than the rest of the competion ;-). - I can&#039;t really test it for speed as I don&#039;t have a good benchmarking routine. &nbsp;I might try porting Ultrano&#039;s to NASM though.<br />I&#039;m also an asm newbie, so I&#039;m learning a bunch just reading (and comparing to mine) all you guy&#039;s solutions - it&#039;s quite impressive the completely different/elegant solutions.</div>
    <div class="meta">Posted on 2009-11-23 01:02:42 by sysfce2</div>
   </div>
   <div class="post" id="post-209688">
    <div class="subject"><a href="#post-209688">Re: Small challenge</a></div>
    <div class="body"><div class="quote"><br />Scali, what is your c2d? Such different results from mine. <br /><br />I.e ANSI C 1 &nbsp;is 6.56 cycles here, and ratios are all inconsistent with your bench-results. <br /></div><br /><br />I have a Core2Duo E6600 running at 3 GHz.<br />The testing framework tests the routines as function calls, so there&#039;s calling overhead aswell. That&#039;s probably why all results are about ~2 clks more than your results.<br /><br />I&#039;ll attach the framework as it is now, still messy, but if you run src/yodel.exe, you get the exact same stuff I was testing with.<br /><br />Edit: removed attachment, get the latest file elsewhere in the thread.</div>
    <div class="meta">Posted on 2009-11-23 05:23:42 by Scali</div>
   </div>
   <div class="post" id="post-209690">
    <div class="subject"><a href="#post-209690">Re: Small challenge</a></div>
    <div class="body">Results from my 1.5 GHz Core2 Duo laptop:<br />test01-Scali1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...000609 ticks (effective 9.111 clk/iteration)<br />test02-Scali2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...000562 ticks (effective 8.408 clk/iteration)<br />test03-Scali3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...000702 ticks (effective 10.502 clk/iteration)<br />test04-sysfce2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...001060 ticks (effective 15.858 clk/iteration)<br />test05-Ultrano&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000702 ticks (effective 10.502 clk/iteration)<br />test06-ANSI C 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...000608 ticks (effective 9.096 clk/iteration)<br />test07-ANSI C 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...000655 ticks (effective 9.799 clk/iteration)<br /><br />And my 1.6 GHz Celeron (Northwood) laptop:<br />test01-Scali1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...001141 ticks (effective 18.188 clk/iteration)<br />test02-Scali2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...001141 ticks (effective 18.188 clk/iteration)<br />test03-Scali3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...001432 ticks (effective 22.826 clk/iteration)<br />test04-sysfce2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...001142 ticks (effective 18.203 clk/iteration)<br />test05-Ultrano&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...001432 ticks (effective 22.826 clk/iteration)<br />test06-ANSI C 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...001142 ticks (effective 18.203 clk/iteration)<br />test07-ANSI C 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...001141 ticks (effective 18.188 clk/iteration)</div>
    <div class="meta">Posted on 2009-11-23 08:45:35 by Scali</div>
   </div>
   <div class="post" id="post-209692">
    <div class="subject"><a href="#post-209692">Re: Small challenge</a></div>
    <div class="body">What strikes me most is that VS (and generally modern compilers) can very often produce code so good that it&#039;s actually hard to beat it. &quot;Optimized by hand in assembly&quot; no longer means what it used to mean.</div>
    <div class="meta">Posted on 2009-11-23 10:25:01 by ti_mo_n</div>
   </div>
   <div class="post" id="post-209693">
    <div class="subject"><a href="#post-209693">Re: Small challenge</a></div>
    <div class="body">This is only when the C++ coder knows how a cpu works, and how to optimize in asm :P . </div>
    <div class="meta">Posted on 2009-11-23 10:27:35 by Ultrano</div>
   </div>
   <div class="post" id="post-209695">
    <div class="subject"><a href="#post-209695">Re: Small challenge</a></div>
    <div class="body"><div class="quote"><br />What strikes me most is that VS (and generally modern compilers) can very often produce code so good that it&#039;s actually hard to beat it. &quot;Optimized by hand in assembly&quot; no longer means what it used to mean.<br /></div><br /><br />Well, that&#039;s partly because of CPU design itself.<br />Since most programmers don&#039;t know how to code in asm anymore, most code is written in compiled languages. Ever since the Pentium, Intel has been working on optimizing only the &#039;common subset&#039; of instructions that compilers use, rather than the more esoteric instructions that are mainly for hand-optimized assembly.<br />As a result, basic operations like add/sub/or/xor and all that have become faster, while &#039;weird&#039; instructions like inc/dec/movsd/aaa and all that have been replaced with &#039;software&#039;... they are basically being &#039;emulated&#039; in microcode by generating a sequence of basic operations.<br /><br />As a result, the code that compilers generate is always reasonably optimal. And the &#039;weird&#039; instructions that assembly programmers once used to cut corners and optimize their code, have now often become slower than doing it the &#039;naive&#039; way.<br /><br />The &#039;trick&#039; that I pulled here... whether that&#039;s an assembly trick is debatable. As you can see, I could easily implement the same trick in C. It doesn&#039;t take advantage of things like carry flags and such, which would only work in assembly, and not in C. You need to know how basic adding and carrying works, but technically you wouldn&#039;t have to know how to write asm, it&#039;s more of a &#039;mathematical&#039; thing, number theory or something like that.<br /><br />Edit:<br />In fact, it was already like that about 6 years ago, when f0dder originally developed the yodel package for some other code. Here are the old threads if anyone is interested:<br />http://www.asmcommunity.net/board/index.php?topic=12764.0<br />http://www.asmcommunity.net/board/index.php?topic=12817.0<br />The short version: even back then, most assembly versions got beaten by the C compiler.</div>
    <div class="meta">Posted on 2009-11-23 11:02:36 by Scali</div>
   </div>
   <div class="post" id="post-209697">
    <div class="subject"><a href="#post-209697">Re: Small challenge</a></div>
    <div class="body">When I looked at the second algo that the compiler generated, I noticed that if you swapped the usage of eax, ecx and edx around a bit, you could remove one instruction...<br />So I got to this:<br /><pre><code>	mov&nbsp; &nbsp;  eax, <br />	mov&nbsp; &nbsp;  ecx, eax<br />	and&nbsp; &nbsp;  eax, 7F7F7F7Fh<br />	and&nbsp; &nbsp;  ecx, 7F7F7Fh<br />	add&nbsp; &nbsp;  eax, ecx<br />	add&nbsp; &nbsp;  ecx, ecx<br />	and&nbsp; &nbsp;  ecx, 0FEFEh<br />	add&nbsp; &nbsp;  eax, ecx<br />	add&nbsp; &nbsp;  ecx, ecx<br />	and&nbsp; &nbsp;  ecx, 1FCh<br />	add&nbsp; &nbsp;  eax, ecx<br />	shr&nbsp; &nbsp;  eax, 3</code></pre><br /><br />Which is indeed faster. Same speed as my first implementation.<br /><br />However, since I had the VS2010 beta installed aswell, I figured I&#039;d try that one.<br />It came up with this:<br /><pre><code>_text:00000000&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  mov&nbsp; &nbsp;  eax, <br />_text:00000004&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  mov&nbsp; &nbsp;  ecx, eax<br />_text:00000006&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  and&nbsp; &nbsp;  eax, 7F7F7F7Fh<br />_text:0000000B&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  and&nbsp; &nbsp;  ecx, 7F7F7Fh<br />_text:00000011&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  lea&nbsp; &nbsp;  edx, <br />_text:00000014&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  lea&nbsp; &nbsp;  eax, <br />_text:00000017&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  and&nbsp; &nbsp;  eax, 0FEFEh<br />_text:0000001C&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  add&nbsp; &nbsp;  edx, eax<br />_text:0000001E&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  add&nbsp; &nbsp;  eax, eax<br />_text:00000020&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  and&nbsp; &nbsp;  eax, 1FCh<br />_text:00000025&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  add&nbsp; &nbsp;  eax, edx<br />_text:00000027&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  shr&nbsp; &nbsp;  eax, 3</code></pre><br /><br />This code is just as fast as the fine-tuned version I came up with (the first ANSI C routine resulted in the exact same code as VS2008):<br />test01-Scali1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...000296 ticks (effective 8.880 clk/iteration)<br />test02-Scali2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...000281 ticks (effective 8.430 clk/iteration)<br />test03-Scali3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...000343 ticks (effective 10.290 clk/iteration)<br />test04-sysfce2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000530 ticks (effective 15.900 clk/iteration)<br />test05-Ultrano&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000343 ticks (effective 10.290 clk/iteration)<br />test06-ANSI C 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...000296 ticks (effective 8.880 clk/iteration)<br />test07-ANSI C 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...000296 ticks (effective 8.880 clk/iteration)<br />test08-ANSI C 2 handoptimized ...000296 ticks (effective 8.880 clk/iteration)</div>
    <div class="meta">Posted on 2009-11-23 13:23:11 by Scali</div>
   </div>
   <div class="post" id="post-209698">
    <div class="subject"><a href="#post-209698">Re: Small challenge</a></div>
    <div class="body">Has the Look Up Table method been tried?<br /><pre><code><br />MOVZX ecx, word<br />MOVZX eax, word<br />MOV cx, word<br />MOV ax, word<br />SHL ecx, 14<br />OR eax, ecx<br /></code></pre><br />The 131 KB look up table is definitely a space hog, but once the LUT is in the processor cache it would likely be the fastest method.<br /><br />Generating the LUT would be some preprocessor/macro annoyance. But you wouldn&#039;t need to actually fill the LUT to preform the benchmark.<br />LUT: <br />REPEAT 65536<br /> &nbsp; &nbsp;dw ((% &amp; 0x7F00) &gt;&gt; 1) | (% &amp; 0x7F)<br />END REPEAT</div>
    <div class="meta">Posted on 2009-11-23 14:18:33 by r22</div>
   </div>
   <div class="post" id="post-209699">
    <div class="subject"><a href="#post-209699">Re: Small challenge</a></div>
    <div class="body">I&#039;ve converted your code to MASM and added it, here are the results:<br />test01-Scali1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000312 ticks (effective 9.360 clk/iteration)<br />test02-Scali2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000296 ticks (effective 8.880 clk/iteration)<br />test03-Scali3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000359 ticks (effective 10.770 clk/iteration)<br />test04-sysfce2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...000530 ticks (effective 15.900 clk/iteration)<br />test05-Ultrano &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...000343 ticks (effective 10.290 clk/iteration)<br />test06-ANSI C 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000297 ticks (effective 8.910 clk/iteration)<br />test07-ANSI C 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000297 ticks (effective 8.910 clk/iteration)<br />test08-ANSI C 2 handoptimized ...000281 ticks (effective 8.430 clk/iteration)<br />test09-r22 LUT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...000624 ticks (effective 18.720 clk/iteration)<br /><br />It seems the cache just isn&#039;t fast enough. I&#039;ve also tried with 5 times as many iterations, but still it was considerably slower.<br /><br />I&#039;ve attached the latest yodel, with the extra tests.<br /><br />Edit: removed attachment, get the latest file elsewhere in the thread.</div>
    <div class="meta">Posted on 2009-11-23 14:48:10 by Scali</div>
   </div>
   <div class="post" id="post-209701">
    <div class="subject"><a href="#post-209701">Re: Small challenge</a></div>
    <div class="body">Impressively slow :)<br />I guess the underlying algorithm is already too compact to benefit from the &#039;brute force&#039; solution.<br /><br />I was also thinking of a MUL by magic number approach, but I don&#039;t see it being an improvement.<br /><br /></div>
    <div class="meta">Posted on 2009-11-23 15:56:42 by r22</div>
   </div>
   <div class="post" id="post-209702">
    <div class="subject"><a href="#post-209702">Re: Small challenge</a></div>
    <div class="body">I think the main problem is that the LUT is too large. You need to go to L2 a lot of the time.<br />If you could stay within L1, you&#039;d have a lookup delay of about 3-4 cycles, depending on the exact CPU.<br />But L2 is more like 15 cycles or more.</div>
    <div class="meta">Posted on 2009-11-23 16:01:56 by Scali</div>
   </div>
   <div class="post" id="post-209703">
    <div class="subject"><a href="#post-209703">Re: Small challenge</a></div>
    <div class="body">here&#039;s my try:<br /><pre><code>	mov edx,00000000000000000000000001111111b<br />	mov ecx,00000000000000000111111100000000b<br />	mov ebx,00000000011111110000000000000000b<br />	and edx,eax<br />	and ecx,eax<br />	and ebx,eax<br />	and eax,01111111000000000000000000000000b<br />	lea eax,<br />	lea eax,<br />	lea eax,<br />	shr eax,3</code></pre></div>
    <div class="meta">Posted on 2009-11-23 16:36:52 by drizz</div>
   </div>
   <div class="post" id="post-209704">
    <div class="subject"><a href="#post-209704">Re: Small challenge</a></div>
    <div class="body">Very good one, drizz:<br />test01-Scali1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...000297 ticks (effective 8.910 clk/iteration)<br />test02-Scali2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...000265 ticks (effective 7.950 clk/iteration)<br />test03-Scali3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...000265 ticks (effective 7.950 clk/iteration)<br />test04-sysfce2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000515 ticks (effective 15.450 clk/iteration)<br />test05-Ultrano&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000359 ticks (effective 10.770 clk/iteration)<br />test06-ANSI C 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...000328 ticks (effective 9.840 clk/iteration)<br />test07-ANSI C 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ...000296 ticks (effective 8.880 clk/iteration)<br />test08-ANSI C 2 handoptimized ...000265 ticks (effective 7.950 clk/iteration)<br />test09-r22 LUT&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000671 ticks (effective 20.130 clk/iteration)<br />test10-drizz&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000266 ticks (effective 7.980 clk/iteration)<br /><br />I&#039;ve modified my third routine to use some of your ideas.<br />I think yours is the fastest routine technically, since I had to add push/pop ebx to make it run from the yodel framework, and still it&#039;s as fast as the Scali2 routine. Without the push/pop it would be faster.</div>
    <div class="meta">Posted on 2009-11-23 17:16:02 by Scali</div>
   </div>
   <div class="post" id="post-209707">
    <div class="subject"><a href="#post-209707">Re: Small challenge</a></div>
    <div class="body">Here&#039;s a slight variation on drizz&#039;s code:<br /><br /><pre><code>	lea edx,<br />	lea esi,<br />	lea edi,<br />	and edx,00000000111111100000000000000000b<br />	and esi,00000000000000011111110000000000b<br />	and edi,00000000000000000000001111111000b<br />	and eax,01111111000000000000000000000000b<br />	or edx,esi<br />	or eax,edi<br />	or eax,edx<br />	shr eax,3</code></pre><br /><br />I haven&#039;t yet got the Yodel routine to compile - I&#039;m using Pelle&#039;s C. &nbsp;What compiler are you using so I can try to tweak the settings?</div>
    <div class="meta">Posted on 2009-11-24 00:02:49 by sysfce2</div>
   </div>
   <div class="post" id="post-209708">
    <div class="subject"><a href="#post-209708">Re: Small challenge</a></div>
    <div class="body">And just for fun, here&#039;s another one using rotate instructions (really slow):<br /><br /><pre><code>	mov edx,eax<br />	rcr eax,8<br />	mov esi,0xFE00007F<br />	rcl edx,9<br />	and eax,esi<br />	and edx,esi<br />	rol eax,7<br />	ror edx,11<br />	or eax,edx</code></pre></div>
    <div class="meta">Posted on 2009-11-24 00:06:31 by sysfce2</div>
   </div>
   <div class="post" id="post-209709">
    <div class="subject"><a href="#post-209709">Re: Small challenge</a></div>
    <div class="body">My first solution was quite similar to this, it also used a rotational approach.<br />And yes, it was slowww.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2009-11-24 00:30:15 by Homer</div>
   </div>
   <div class="post" id="post-209712">
    <div class="subject"><a href="#post-209712">Re: Small challenge</a></div>
    <div class="body">I&#039;ve added the two routines from sysfce2:<br />test01-Scali1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000297 ticks (effective 8.910 clk/iteration)<br />test02-Scali2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000280 ticks (effective 8.400 clk/iteration)<br />test03-Scali3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000281 ticks (effective 8.430 clk/iteration)<br />test04-sysfce2-1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...000531 ticks (effective 15.930 clk/iteration)<br />test05-Ultrano &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...000358 ticks (effective 10.740 clk/iteration)<br />test06-ANSI C 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000312 ticks (effective 9.360 clk/iteration)<br />test07-ANSI C 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000280 ticks (effective 8.400 clk/iteration)<br />test08-ANSI C 2 handoptimized ...000265 ticks (effective 7.950 clk/iteration)<br />test09-r22 LUT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...000671 ticks (effective 20.130 clk/iteration)<br />test10-drizz &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...000265 ticks (effective 7.950 clk/iteration)<br />test11-sysfce2-2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...000281 ticks (effective 8.430 clk/iteration)<br />test12-sysfce2-3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...000921 ticks (effective 27.630 clk/iteration)<br /><br />And I&#039;ll attach the updated yodel routine... I&#039;ve also made the conformance test actually WORK this time, which meant I also fixed some minor bugs in some code, but no impact on performance.<br /><br />By the way, the yodel framework uses Microsoft&#039;s cl.exe and ml.exe. You can use the mk.bat file. Should be reasonably easy to modify it for other compilers (there&#039;s also some stuff in there for Intel&#039;s icl.exe, and we used nasm instead of masm last time round. I just moved back to masm because I don&#039;t have nasm installed now).<br /><br />Edit: removed attachment, get the latest file elsewhere in the thread.</div>
    <div class="meta">Posted on 2009-11-24 04:05:35 by Scali</div>
   </div>
   <div class="post" id="post-209714">
    <div class="subject"><a href="#post-209714">Re: Small challenge</a></div>
    <div class="body">I&#039;ve added ti_mo_n&#039;s mmx routine:<br />test01-Scali1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000327 ticks (effective 9.810 clk/iteration)<br />test02-Scali2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000281 ticks (effective 8.430 clk/iteration)<br />test03-Scali3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000297 ticks (effective 8.910 clk/iteration)<br />test04-sysfce2-1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...000577 ticks (effective 17.310 clk/iteration)<br />test05-Ultrano &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...000390 ticks (effective 11.700 clk/iteration)<br />test06-ANSI C 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000359 ticks (effective 10.770 clk/iteration)<br />test07-ANSI C 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...000343 ticks (effective 10.290 clk/iteration)<br />test08-ANSI C 2 handoptimized ...000312 ticks (effective 9.360 clk/iteration)<br />test09-r22 LUT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...000749 ticks (effective 22.470 clk/iteration)<br />test10-drizz &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...000296 ticks (effective 8.880 clk/iteration)<br />test11-sysfce2-2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...000327 ticks (effective 9.810 clk/iteration)<br />test12-sysfce2-3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...001030 ticks (effective 30.900 clk/iteration)<br />test13-ti_mo_n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...000796 ticks (effective 23.880 clk/iteration)<br /><br />I had to modify it slightly to make it fit the format of the test-suite (input on stack, output in eax).<br />In this version it&#039;s not very fast, not even if you consider that it actually does two numbers instead of one. Even if you take half the measurement, it&#039;s still not with the fastest routines.<br /><br />Edit: removed attachment, get the latest file elsewhere in the thread.</div>
    <div class="meta">Posted on 2009-11-24 06:21:47 by Scali</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29696&amp;page=1" style="">&laquo;</a><a href="../?id=29696&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29696" /><input type="number" name="page" min="1" max="4" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=29696&amp;page=3">&gt;</a><a href="../?id=29696&amp;page=4">&raquo;</a></form>  </div>
 </body>
</html>