<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>FILE ACCESS ERROR when file opened - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17169" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=17169">FILE ACCESS ERROR when file opened</a></p>
   <div class="post" id="post-133118">
    <div class="subject"><a href="#post-133118">FILE ACCESS ERROR when file opened</a></div>
    <div class="body">; cshred.asm   Not working correctly yet<br />;              COMMAND LINE VERSION    <br />;              email:http://www.asmcommunity.net/board/cryptmail.php?tauntspiders=in.your.face@nomail.for.you&amp;id=2c4c23c18218165825da5354af8828e8 (Remove LOG)<br />;              Tasm code (c) Andrew Kennedy  Jan 2004<br />;<br />;        Overwrite a file with random bytes,<br />;        truncates it to zero bytes,<br />;<br />;        Set file time and date to 12:59:58 pm  1/1/80,<br />;        renames it and then deletes it.<br />;        Single files only. (For Safety)<br />;        Long File Name support<br />;<br />; Use SHORT path when not in current directory  Ex. C:\PROGRA~1\VERYLO~1.ASM<br />;<br />; Works across drives, handles periods in the path names<br />;<br />;         Help from Stealth, Raymond, Bitrake, Rudy Weiser, Frank Kotler,<br />;         Fauzan Mirza, Robert Redelmeier,<br />;       Win 98 +  Long File Name support<br />;      |------------------------------------------|<br />;      |   Feel free to use sections of the code  |<br />;      |   but please credit me somewhere.        |<br />;      |------------------------------------------|<br />;<br />; Works across drives, handles periods in the path names<br />;<br />;      USE SHORT NAME path if not in current directory<br />;<br /><br />MODEL TINY<br />.386<br /><br />DATASEG<br /><br /><br />NO_PARMS      db      13,10,9,'No File Specified.',13,10<br />              db      13,10,9,'Usage: CSHRED &lt;filename&gt;          (c) Andrew Kennedy',13,10<br />              db      13,10,9,'Use SHORT path if not in current directory!!',13,10<br />              db      13,10,9,'Ex. C:\PROGRA~1\VERYLO~1.ASM',13,10<br />              db      13,10,9,'This file will be UNRECOVERABLY erased !!',13,10,'$'<br /><br />file_name    db       129   dup(0)<br />storage      db       150   dup(0)<br />handle       dw       ?<br />file_size    dd       ?<br />name_size    dw       ?<br /><br />not_there    db       13,10,13,10,'File not present.',13,10,'$'<br />emsg2        db       13,10,13,10,'Error moving file pointer.',13,10,'$'<br />emsg3        db       13,10,13,10,'Error writing to file.',13,10,'$'<br />done_msg     db       13,10,13,10,'File has been shredded.',13,10,'$'<br />eraser_name  db       '_.',0<br />e_name_length equ      $ - eraser_name <br /><br />UDATASEG  ;&lt;&lt;Any uninitialized data is defined here&gt;&gt;<br /><br />random       db       64000 dup(?)  ; whatever is in memory at the time<br /><br /><br />CODESEG  <br /><br />   STARTUPCODE<br /><br />        mov          ah,15     ; clear the screen<br />        int          10h<br />        mov          ah,0<br />        int          10h<br /><br />        mov     si,80h<br />                                <br />        mov     cl,         ; Move byte count to CL<br />        xor     ch,ch           ; Zero CH<br />        mov     ,cx  ; store command line length, this<br />                                ; includes the 0dh<br />        lea     di,file_name<br />        cld<br />        lodsb                   ; any command line present?<br />        or      al,al           ; return error status if not.<br />        jz     noparms<br /><br />infile1:                      ; scan over leading blanks<br />        lodsb                 ; to file name<br />        cmp     al,0dh        ; if we hit carriage return<br />        jz      noparms       ; filename is missing.<br /><br />        cmp     al,20h        ; is this a blank?<br />        jz      infile1       ; if so keep scanning.<br /><br />infile24:<br />        stosb                 ; move last char. to output<br />                              ; file name buffer.<br />        lodsb                 ; check next character, found<br />        cmp     al,0dh        ; carriage return yet?<br />        je      short change  ; yes,exit with success code<br /><br />infile26:<br />        cmp     al,20h      ; is this a blank?<br />        jne     infile24    ; if not keep moving chars.<br />        jmp     short change<br />        <br />noparms:<br />        lea     dx, NO_PARMS<br />        mov     ah,9<br />        int     21h<br />        mov     ax,4c01h<br />        int     21h<br />        <br />zero_out:   ; Set memory to zero<br />        mov           ,00h<br />        inc           bx<br />        cmp           bx,64000<br />        jnz           zero_out<br /><br />change:       ; remove all file attributes<br />        ;int 3<br />        lea          dx,file_name<br />        mov          ax,7143h<br />        mov          bl,01h<br />        mov          cx,0   ; remove any read-only attributes<br />        ;int 3<br />        int          21h<br />        ;int 3<br />;INT 21 - Windows95 - LONG FILENAME - CREATE OR OPEN FILE<br />;	AX = 716Ch<br />;	BX = access mode and sharing flags (see #01782,also AX=6C00h);<br />;	CX = attributes<br />;	DX = action (see #01781)<br />;	DS:SI -&gt; ASCIZ filename<br /><br />	mov	ax,716Ch	; create file<br />	xor	cx,cx		; file attributes<br /><br />; file access modes (bits)<br />;     000 read-only<br />;     001 write-only<br />;     010 read-write<br />;     100 read-only, do not modify file's last-access time<br /><br />        mov          bx,00000001b             ; access mode <br />        mov          dx,00000001b             ; open file<br />        lea          si,file_name     ; sets the file name<br />        int          21h<br />        mov          ,ax        ; Save file handle<br />        int 3        ; GETTING AN ACCESS DENIED ERROR HERE<br />        jnc          short get_size     ; No errors, go on<br /><br />no_file:<br />        lea          dx,not_there       ; Get error message<br />        jmp          error              ; and go display/exit<br /><br />get_size:<br />        mov          ax,4202h           ; Set file pointer<br />        mov          bx,        ; for this file<br />        xor          cx,cx              ; relative to end of file<br />        xor          dx,dx              ; offset 0 bytes<br />        int          21h<br />        jnc          save_size<br />err2:<br />        lea          dx,emsg2           ; Get error message<br />        jmp          error              ; and go display/exit<br /><br />save_size:<br />        mov          word ptr ,ax     ; Save low word of file size<br />        mov          word ptr ,dx ; Save high word<br /><br />        mov          ax,4200h           ; Move file pointer<br />        mov          bx,        ; for this file<br />        xor          cx,cx              ; relative to beginning of file<br />        xor          dx,dx              ; offset 0 bytes<br />        int          21h<br />        jc           err2               ; Errors: go handle<br /><br />next_bunch:<br />        mov          cx,64000           ; Assume 64,000 bytes or more<br />                                        ; left to do<br /><br />        sub          word ptr ,cx   ; Is there ? - subtract it<br />        sbb          word ptr ,0 ; from saved file size<br /><br />        jae          wipe                ; There were 64,000 bytes or<br />                                         ; more left<br /><br />        mov          cx,word ptr  ; Get number of bytes left<br />        add          cx,64000                ; back CX (undo subtraction)<br /><br />wipe:<br />        mov          ah,40h             ; Write file<br />        mov          bx,        ; Handle<br />        lea          dx, random         ; Write the random bytes,<br />        int          21h                ; whatever was in memory<br /><br />        jnc          check_size         ; No errors, go on<br /><br />err3:<br />        lea          dx,emsg3    ; Get appropriate error message<br />        jmp          error       ; and go display/exit<br /><br />check_size:<br />        cmp          ax,cx<br />        jnz          err3<br />        cmp          ax,64000           ; Full 64,000 bytes written,<br />        je           next_bunch         ; yes, go check for more<br /><br />        mov          bx,        ; close file<br />        mov          ah,3eh<br />        int          21h<br />        int	3<br />; Store the path<br /><br />scan:<br />        lea      si,<br />        xor      cx,cx<br />        mov      di,si<br />        mov      cx,<br /><br />        mov      al,'\'              ;<br />        add      di,cx<br />        std                          ; scan from right to left<br />        dec      di<br />        repne    scasb<br />        jnz      short no_path       ;  No slash is present<br />        add      cx,1                ;<br /><br />no_path:<br />        lea      di,storage<br />        cld                          ; change directions and scan<br />        rep      movsb               ; from left to right<br />        mov      al,00<br />        stosb                        ; make path ASCIZ<br /><br />; Add on eraser_name to end of storage<br /><br />add_eraser:<br /><br />        mov      cx,<br />        mov      si,cx<br />        lea      di,storage<br />        mov      al,00             ; stops at the byte after the &quot;00&quot;<br />        repnz    scasb<br />        dec      di                ; backup one<br /><br />        xor      cx,cx<br />        lea      si, eraser_name<br />        mov      cx,e_name_length  ; # of characters in eraser name<br /><br />        rep      movsb<br /><br />; Rename and delete file   (LFN)<br /><br />rename:<br />        lea          dx,file_name   ; old file name<br />        lea          di,storage     ; new file name<br />        mov          ax,7156h       ; LFN support<br />        int          21h<br /><br />; Change file date and time<br /><br />        mov     ax,716Ch        ; open file<br />        xor     cx,cx           ; file attributes<br /><br />        mov     bx,100000000000010b  ; access mode (R/W) and commit<br />                                     ; file after every write<br /><br />        mov     dx,1            ; open file<br />        lea     si,storage      ; sets the file name<br />        int     21h<br />        mov     bx,ax           ; save file handle<br /><br />        push    bx<br /><br />        mov     ax,5701h ; change file date<br />                         ; BITS 5-10 are minutes,<br />                         ; 11-15 are hours, 0-4 seconds/2<br /><br />        mov     cx,677dh ; 12:59:58 pm  110011101111101b<br />                         ;<br />                         ; BITS 0-4 are day, 5-8 are month,<br />                         ; 9-15 (year - 1980)<br />        mov     dx,021h  ; 1/1/80    0000000000100001b<br />        int     21h<br /><br />        pop     bx<br />        mov     ah,6ah   ; DOS 4.0+ - COMMIT FILE<br />        int     21h<br /><br />        mov     ah,3eh   ; close file<br />        int     21h<br /><br />; INT 21 - Windows95 - LONG FILENAME - DELETE FILE<br />;           AX = 7141h<br />;           DS:DX -&gt; ASCIZ long name of file to delete<br /><br />        lea          dx,storage    ; delete file<br />        mov          ax,7141h<br />        xor          si,si<br />        int          21h<br /><br />finito:<br />        mov          ah,9<br />        lea          dx,done_msg<br />        int          21h<br />        mov          ax,4c00h           ; Set errorlevel to 0<br />        int          21h<br />error:<br />        mov          ah,9                <br />        int          21h<br />        mov          ax,4c01h           ; Set errorlevel to 1<br />        int          21h<br /><br />END</div>
    <div class="meta">Posted on 2004-02-10 15:43:02 by skywalker</div>
   </div>
   <div class="post" id="post-133130">
    <div class="subject"><a href="#post-133130">FILE ACCESS ERROR when file opened</a></div>
    <div class="body">Hi.<br />A suggestion: if you use quotes at your command line parsing routine you can support long pathnames.<br />I'll try debugging it when I get back home, if I find out anything I'll post it :)</div>
    <div class="meta">Posted on 2004-02-10 17:03:06 by QvasiModo</div>
   </div>
   <div class="post" id="post-133158">
    <div class="subject"><a href="#post-133158">FILE ACCESS ERROR when file opened</a></div>
    <div class="body"><div class="quote"><br />Hi.<br />A suggestion: if you use quotes at your command line parsing routine you can support long pathnames.<br />I'll try debugging it when I get back home, if I find out anything I'll post it :) </div><br /><br />The code is working. Sometimes I'll make changes in one file and assemble another with the same name except for a 1 in the name. <br /><br />A poster at Programmer' Heaven verified that the code works in a DOS window and uses short or long<br />filenames in Win XP. That was nice to know.<br /><br />Thanks.</div>
    <div class="meta">Posted on 2004-02-10 21:18:07 by skywalker</div>
   </div>
   <div class="post" id="post-133225">
    <div class="subject"><a href="#post-133225">FILE ACCESS ERROR when file opened</a></div>
    <div class="body">Yes, it worked on my computer too. Glad to know the problem's solved. :)<br /><br />Since I didn't have TASM I had to adapt it for A86, I'm posting it in case you're interested.<br /><br />BTW, I noticed that the code at the label &quot;zero_out&quot; never seems to get executed. And it would be safer to fill &quot;random&quot; with actual random data, rather than relying on the previous contents of the RAM. :)</div>
    <div class="meta">Posted on 2004-02-11 11:19:03 by QvasiModo</div>
   </div>
   <div class="post" id="post-133243">
    <div class="subject"><a href="#post-133243">FILE ACCESS ERROR when file opened</a></div>
    <div class="body"><div class="quote"><br />Yes, it worked on my computer too. Glad to know the problem's solved. :)<br /><br />Since I didn't have TASM I had to adapt it for A86, I'm posting it in case you're interested.<br /><br />BTW, I noticed that the code at the label &quot;zero_out&quot; never seems to get executed. And it would be safer to fill &quot;random&quot; with actual random data, rather than relying on the previous contents of the RAM. :) </div><br /><br />Thanks for writing it for A86. I'll post it on one of the assembly newsgroups.<br /><br />I'll have to check out the zero_out. I know it works with my shred program that actually prompts for the file<br />name. I put on a single 1.68 MB file on a floopy that contained x's and used a disk editor to see that only<br />zeros were on the disk.<br /><br />I also added a jmp $ + 2 after the file overwrite section because of what someone called Windows lazy-ness<br />in writing files. Sometimes the file would be overwritten correctly but the renamimg part would fail.<br /><br />Thanks.</div>
    <div class="meta">Posted on 2004-02-11 17:33:41 by skywalker</div>
   </div>
  </div>
 </body>
</html>