<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Signed and unsigned saturation with general-purpose instruct - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=11789" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=11789">Signed and unsigned saturation with general-purpose instruct</a></p>
   <div class="post" id="post-90003">
    <div class="subject"><a href="#post-90003">Signed and unsigned saturation with general-purpose instruct</a></div>
    <div class="body">So I was looking at the MMX and SSE opcodes the other day and thinking, wouldn't it be nice if I could use some of those nifty features with general-purpose registers?  I'm sure someone has done this before, but I have an urge to show off how clever I am :-)<br /><br />Saturation of unsigned values, it turns out, is easy, since the carry flag gets set whenever overflow or underflow occurs during an add or sub operation.<br /><pre><code><br />; Unsigned increment with saturation<br />macro IncUS regmem<br />     add   regmem,1<br />     sbb   regmem,0<br />endm<br /><br />;Unsigned decrement with saturation<br />macro DecUS regmem<br />     sub   regmem,1<br />     adc   regmem,0<br />endm<br /></code></pre><br />That's so basic it's hardly worth posting.  What about signed saturation?  The overflow flag gets set on signed overflow (go figure), but to be perfectly honest that flag is pretty useless.<br /><pre><code><br />; Signed increment with saturation<br />macro IncSSWord regmem<br />     add   regmem,8000h<br />     add   regmem,1<br />     sbb   regmem,0<br />     sub   regmem,8000h<br />endm<br /></code></pre><br />Not bad.  Translate the number to an unsigned value.  Turns out this should work for saturation at any arbitrary value, as long as the number being incremented does not exceed the specified value.<br /><pre><code><br />; Increment with saturation at specified value<br />macro IncSaturate regmem,limit<br />     add   regmem, - &#40;limit + 1&#41;<br />     add   regmem,1<br />     sbb   regmem,0<br />     sub   regmem, - &#40;limit + 1&#41;<br />endm<br /><br />macro IncSSWord regmem<br />     IncSaturate regmem,7fffh<br />endm<br /></code></pre><br />The rest of the code here hasn't been tested, but it ought to work. ;-)  It's pasted from a source file, so it might look a little ugly.<br /><br /><pre><code>; Add unsigned saturated, needs a temp register<br />macro add_uss reg,val,temp<br />     add   reg,val<br />     sbb   temp,temp<br />     or    reg,temp<br />endm<br /><br />; Add signed saturated byte, needs a temp register<br />macro add_ssb reg,val,temp<br />		add	reg,80h<br />		add	reg,val<br />		sbb	temp,temp<br />		or		reg,val<br />		sub	reg,80h<br />endm<br /><br />macro	add_ssw reg,val,temp<br />		add	reg,8000h<br />		add	reg,val<br />		sbb	temp,temp<br />		or		reg,val<br />		sub	reg,8000h<br />endm<br /><br />macro add_ssd reg,val,temp<br />		add	reg,80000000h<br />		add	reg,val<br />		sbb	temp,temp<br />		or		reg,val<br />		sub	reg,80000000h<br />endm<br /><br />; Subtract unsigned saturated<br />macro sub_uss reg,val,temp<br />		sub	reg,val<br />		sbb	temp,temp<br />		not	temp<br />		and	reg,temp<br />endm<br /><br />; Subtract signed saturated byte<br />macro sub_ssb reg,val,temp<br />		sub	reg,80h<br />		sub	reg,val<br />		sbb	temp,temp<br />		not	temp<br />		and	reg,temp<br />		add	reg,80h<br />endm<br /><br />macro sub_ssw reg,val,temp<br />		sub	reg,8000h<br />		sub	reg,val<br />		sbb	temp,temp<br />		not	temp<br />		and	reg,temp<br />		add	reg,8000h<br />endm<br /><br />macro sub_ssd reg,val,temp<br />		sub	reg,80000000h<br />		sub	reg,val<br />		sbb	temp,temp<br />		not	temp<br />		and	reg,temp<br />		add	reg,80000000h<br />endm<br /><br />; Multiply unsigned saturated byte, stores result or 0ffh in AL, sets AH to 0ffh if overflow, 0 if not<br />macro mul_ussb reg<br />		mul	reg<br />		sbb	ah,ah<br />		or		al,ah<br />endm<br /><br />; Multiply unsigned saturated word, stores result or 0ffffh in AX, sets DX too 0ffffh if overflow, 0 if not<br />macro mul_ussw reg<br />		mul	reg<br />		sbb	dx,dx<br />		or		ax,dx<br />endm<br /><br />; Multiply unsigned saturated dword, stores result or 0ffffffffh in EAX, sets EDX to 0ffffffffh if overflow, 0 if not<br />macro mul_ussd reg<br />		mul	reg<br />		sbb	edx,edx<br />		or		eax,edx<br />endm<br /><br />; Multiply signed saturated byte, needs two temp registers, trashes AH<br />macro mul_ssb reg,tempc,tempnc<br />		imul	reg<br />		sbb	tempc<br />		mov	tempnc,tempc<br />		not	tempnc<br />		shl	ah,1<br />		mov	ah,7fh<br />		adc	ah,0<br />		and	ah,tempc<br />		and	al,tempnc<br />		or		al,ah<br />endm<br /><br />macro mul_ssw reg,tempc,tempnc<br />		imul	reg<br />		sbb	tempc<br />		mov	tempnc,tempc<br />		not	tempnc<br />		shl	dx,1<br />		mov	dx,7fffh<br />		adc	dx,0<br />		and	dx,tempc<br />		and	ax,tempnc<br />		or		ax,dx<br />endm<br /><br />macro mul_ssd reg,tempc,tempnc<br />		imul	reg<br />		sbb	tempc<br />		mov	tempnc,tempc<br />		not	tempnc<br />		shl	edx,1<br />		mov	edx,7fffffffh<br />		adc	edx,0<br />		and	edx,tempc<br />		and	eax,tempnc<br />		or		eax,edx<br />endm</code></pre><br /><br />...And from the preview it looks like I might want to enable formatting codes...</div>
    <div class="meta">Posted on 2003-03-24 20:44:25 by PopeInnocent</div>
   </div>
  </div>
 </body>
</html>