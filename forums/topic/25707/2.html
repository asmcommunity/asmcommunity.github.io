<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>First foray into asm - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25707" />
  <link rel="prev" href="../?id=25707&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25707">First foray into asm</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=25707&amp;page=1" style="">&laquo;</a><a href="../?id=25707&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="25707" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-187587">
    <div class="subject"><a href="#post-187587">Re: First foray into asm</a></div>
    <div class="body">Keep in min that VC6 is approaching 10 years of age (was released sometime during 1998, according to wikipedia). So no wonder improvements have been made since that :). VC2005 can even do full program analysis, with code generation at link-time - that&#39;s pretty neat.<br /><br />You can still do assembly output with VC2005 that&#39;s easy enough to read. Drop to the commandline, and do &quot;cl /O1 /FAs module.cpp&quot; - or drop the /O1 and turn off optimizations entirely. (O1 = optimize for size, O2 = optimize for speed, Ox = max optimizations).<br /><br /><div class="quote"><br />So there might stil be hope of writing an entire asm function that improves on the compiler.<br /></div><br />Very likely :)<br /><br />Even though compilers (MSVC, Intel, and GCC all do, iirc) have &quot;intrinsics&quot; for MMX/SSE, they&#39;re pretty far from generating optimal code - so if you get your head around those instruction sets, well... :)<br /><br /><div class="quote"><br />However its somewhat of a mute point as the function i&#39;ve been testing on isn&#39;t actually going to be used, it was just a simple test.<br /></div><br />It&#39;s not a moot point as long as there&#39;s a learning experience involved!<br /><br /><div class="quote"><br />I&#39;m not entirely sure it can, there are some obvious changes that could be made, but as such i can&#39;t see them making a huge difference, but how knows perhaps i&#39;ll learn something new.<br /></div><br />Rewriting the innerloop to only do full 32-bit reads: read 3 dwords/4x24bpp pixels, do the necessary transformations, and write out the three dwords. That should give a performance increase. Of course you&#39;ll need a little extra code outside the innerloop for taking care of bitmaps that arent a multiple of 4 wide.<br /><br /><div class="quote"><br />So for sake of completeness i&#39;ll post the function, but we are rapidly moving away from talking about asm.<br /></div><br />Yes and no - when optimizing something, you start by doing higher-level/algorithmic optimizations (sometimes data organization, when you have control of it, can matter a lot too), and see how far that gets you. Then you can do do an assembly implementation, use MMX/SSE et cetera.<br /><br />Sometimes assembly allows you to express algorithms in ways that would be hard to do in a HLL - that can also lead to some pretty interesting optimizations.<br /></div>
    <div class="meta">Posted on 2007-01-17 09:28:58 by f0dder</div>
   </div>
   <div class="post" id="post-187589">
    <div class="subject"><a href="#post-187589">Re: First foray into asm</a></div>
    <div class="body">Sorry for killing your fun, guys, but DirectX can flip images both horizontally and vertically in hardware (using virtually no time), so what&#39;s the point? :P</div>
    <div class="meta">Posted on 2007-01-17 09:58:18 by ti_mo_n</div>
   </div>
   <div class="post" id="post-187590">
    <div class="subject"><a href="#post-187590">Re: First foray into asm</a></div>
    <div class="body"><div class="quote"><br />Sorry for killing your fun, guys, but DirectX can flip images both horizontally and vertically in hardware (using virtually no time), so what&#39;s the point? :P<br /></div><br />The learning experience - it <strong>can</strong> be beneficial to re-invent the wheel every now and then. Also:<br /><div class="quote"><br />There&#39;s probably some hardware-accelerated way to do your flipping with DirectX, which you should look into if you really want maximal speed, but let&#39;s focus on optimizing the algorithm instead - that&#39;s a bit more fun.<br /></div><br /></div>
    <div class="meta">Posted on 2007-01-17 10:05:08 by f0dder</div>
   </div>
   <div class="post" id="post-187592">
    <div class="subject"><a href="#post-187592">Re: First foray into asm</a></div>
    <div class="body"><div class="quote"><br />Sorry for killing your fun, guys, but DirectX can flip images both horizontally and vertically in hardware (using virtually no time), so what&#39;s the point? :P<br /></div><br /><br />... and then you missed one of the biggest points of using ASM... to cut down on unnecessary bloat ;)</div>
    <div class="meta">Posted on 2007-01-17 11:54:13 by SpooK</div>
   </div>
   <div class="post" id="post-187596">
    <div class="subject"><a href="#post-187596">Re: First foray into asm</a></div>
    <div class="body"><div class="quote"><br />It&#39;s not a moot point as long as there&#39;s a learning experience involved!<br /></div><br />Oh I completely agree, thats why i don&#39;t believe this has been a waste of my time and there is still plenty more to learn, not only about asm, but as you and others have said writing C++ code in a way that accounts for the underlying architecture and structure of how the cpu and memory works. I&#39;m still reading the AOA, Agner reources and several other pdf&#39;s/websites i&#39;ve come across the last few days.<br /><br />Its just a shame its not going to be as straightforward as it looked like it might have been at the beginning. I actually had a look at the output for my gamma ramp algoirthm, yikes, moving into floating point calculations in asm is a whole new scary place to be ;) I wonder if its worth doing it as fixed point math&nbsp; :lol:<br /><br /><div class="quote"><br />Rewriting the innerloop to only do full 32-bit reads:<br /></div><br /><br />Yep this looks like a good oppertunity to gain some performance, definately something i&#39;ll look into. Maybe I&#39;ll do it in C++ first and see what happens. However i&#39;m not sure how well i&#39;ll get on trying to insert asm into vc2005 as it is far less clear in its use of registers. Heck I can&#39;t even follow most of the asm it produces now. Going to have to read up on how values are passed to functions and the like to get to grips with it. <br /><br />One big disappointed with vc2005 though is that its literally doubling the size of my dll&#39;s compared to vc6 and I can&#39;t work out the reason. I assumed the initial size increase i saw was due to some essential parts of dll just being bigger, as someone suggested the &#39;vc2005 runtime&#39;. That I could live with, a small one time hit per dll, but it doesn&#39;t appear to be the case. I transfered over another project and that doubled in size from 64k to 116k, so it looks like everything is being doubled in size, which for downloadable components isn&#39;t good. I will have to investigate this further.<br /> <br /><div class="quote"><br />Sorry for killing your fun, guys, but DirectX can flip images both horizontally and vertically in hardware (using virtually no time), so what&#39;s the point? <br /></div><br /><br />Well wheres the fun, challenge and achievement in doing that. If it wasn&#39;t for the fact that i started off using a 10 year old compiler, i&#39;d be an asm guru getting a four times the performance just by converting a few lines of c++ 8) Thats a whole lot of fun and achievement, somewhat lessened now by the fun spoiling vc2005 compiler.&nbsp; :sad:<br /><br />It also doesn&#39;t account for several of the requirements I needed to meet in the first place, such as R &amp; B swaping and applying different gamma ramp algorithms, although I wouldn&#39;t be surpirsed if that could also be done in DirectX. Not sure I really want to learn DirectX just for that, although ironically at some point in the future the resultant image will be dumped into an opengl texture, via hooking and other voodoo since Director has never had a SDK of the 3D engine released.<br /><br /><br />thanks<br /></div>
    <div class="meta">Posted on 2007-01-17 13:57:17 by noisecrime</div>
   </div>
   <div class="post" id="post-187598">
    <div class="subject"><a href="#post-187598">Re: First foray into asm</a></div>
    <div class="body"><div class="quote"><br />moving into floating point calculations in asm is a whole new scary place to be ;)<br /></div><br />Yeah - I hate it. Stack-based and all, eek. You could use SSE for floating-point stuff, which is register based... but then you set a minimum CPU, and there are other things to consider as well.<br /><br /><div class="quote"><br />However i&#39;m not sure how well i&#39;ll get on trying to insert asm into vc2005 as it is far less clear in its use of registers.<br /></div><br />EAX,ECX,EDX are freely trashable, EBX,ESI,EDI,EBP need to be preserved (as in &quot;if you change them, push/pop&quot; <strong>not</strong> &quot;always push and pop them&quot; (duh)). Generally I stay away from inline asm though, more bother than it&#39;s worth, can conflict with the compiler optimization, etc.<br /><br /><div class="quote"><br />I transfered over another project and that doubled in size from 64k to 116k, so it looks like everything is being doubled in size, which for downloadable components isn&#39;t good. I will have to investigate this further.<br /></div><br />Nah, it&#39;s not because of a doubling in size, but the additional runtime overhead <strong>is</strong> larger - I think it&#39;s around 50kb or so, which seems coherent with your results. If you&#39;re going to use a lot of DLLs in a project, you can move to the dynamic-link version of the runtime.<br /><br />A size increase of this order should hardly be seen as a problem, though - even back in the 486 times, 50kb wasn&#39;t much (except if you still did realmode programming). It&#39;s data that&#39;s the killer these days.<br /><br />Generated code itself might be a bit larger, though. Usually optimizing for speed means more code (loop unrolling, anyone?).<br /><br /><div class="quote"><br />It also doesn&#39;t account for several of the requirements I needed to meet in the first place, such as R &amp; B swaping and applying different gamma ramp algorithms, although I wouldn&#39;t be surpirsed if that could also be done in DirectX.<br /></div><br />It&#39;s been a fair amount of years since I&#39;ve used DirectX, but I wouldn&#39;t be surprised if the conversion is a simple as setting the right bitmap formats and doing a blit - which is likely to be hardware accelerated. Iirc there&#39;s also gamma stuff in the more recent versions, although if you need it to be precise it might be a good idea to do it by hand (both ATi and NVidia have been known to cut some corners precision-wise, to achieve better benchmark results, at least in the past.)<br /><br /><div class="quote"><br />Not sure I really want to learn DirectX just for that, although ironically at some point in the future the resultant image will be dumped into an opengl texture<br /></div><br />OpenGL should be able to do all this as well, also hardware accelerated :)<br /></div>
    <div class="meta">Posted on 2007-01-17 15:23:57 by f0dder</div>
   </div>
   <div class="post" id="post-187601">
    <div class="subject"><a href="#post-187601">Re: First foray into asm</a></div>
    <div class="body"><div class="quote">The learning experience - it <strong>can</strong> be beneficial to re-invent the wheel every now and then. Also:</div><br /><div class="quote">... and then you missed one of the biggest points of using ASM... to cut down on unnecessary bloat ;)</div><br />I know, I know :)<br /><br /><div class="quote">It also doesn&#39;t account for several of the requirements I needed to meet in the first place, such as R &amp; B swaping and applying different gamma ramp algorithms, although I wouldn&#39;t be surpirsed if that could also be done in DirectX. Not sure I really want to learn DirectX just for that, although ironically at some point in the future the resultant image will be dumped into an opengl texture, via hooking and other voodoo since Director has never had a SDK of the 3D engine released.</div><br />Yes, as f0dder already said, Both DX and Opengl can swap B &amp; R components, flip (horizontally and vertically), and perform gamma-stuff. Everithing hardware accelerated, or MMX/SSE if emulated (at least on DX. I&#39;ve never seen opengl emulating anything, but I have never had a chance to see though).</div>
    <div class="meta">Posted on 2007-01-17 18:14:12 by ti_mo_n</div>
   </div>
   <div class="post" id="post-187602">
    <div class="subject"><a href="#post-187602">Re: First foray into asm</a></div>
    <div class="body">After looking a bit at your code, it seems like the input format is RGBA and you want 0BGR? (or BGRA-&gt;0RGB, same deal really). For vs2005, try this on for size:<br /><pre><code><br />#include &lt;intrin.h&gt;<br /><br />typedef unsigned int uint;<br />typedef unsigned char uchar;<br /><br />void FlipVertical(uchar* tSrcImagePtr, uchar* tDstImagePtr, uint iWidth, uint iHeight)<br />{<br />	const uint		iRowBytes&nbsp; &nbsp; = iWidth*4;<br />	const uint		iImageBytes&nbsp; = iWidth*iHeight*4;<br /><br />	uint			i,x;	<br />	uchar			bRed, bGreen, bBlue;<br />	uint			*src;<br />	uint			*dst;<br /><br />	dst = (uint *) tDstImagePtr;<br />	src = (uint *) tSrcImagePtr;<br />	src = src + iImageBytes - iRowBytes;<br /><br />	// Loop through each line<br />	for (i=0; i&lt;iHeight; i++)<br />	{	<br />		for (x=0; x&lt;iWidth; x++)<br />		{<br />			// Extract the current RGB values - eventualy this will be on a24 bit RGB values no alpha<br />			// RGBA - orig<br />			// ABGR - after BSWAP<br />			// 0BGR - after AND<br />			*dst++ = _byteswap_ulong(*src++) &amp; 0x00FFFFFF;<br />		}<br /><br />		// Decrement src pointer by a line<br />		src = src - iRowBytes - iRowBytes;<br />	}<br />}<br /></code></pre><br /><br />...pure 24bpp input would be more interesting (or annoying) :)<br /></div>
    <div class="meta">Posted on 2007-01-17 22:09:22 by f0dder</div>
   </div>
   <div class="post" id="post-187603">
    <div class="subject"><a href="#post-187603">Re: First foray into asm</a></div>
    <div class="body">Okay, couldn&#39;t sleep (yay for imsomnia), whipped up some code for 24bpp RGB -&gt; 32bpp 0BGR. Pretty bad code, doesn&#39;t handle images that aren&#39;t a multiple of 4 pixels wide, etc etc. I just wanted to show how big difference it does processing dwords rather than bytes does, even with lame code. On my AMD64, I get ~1.6x speedup:<br /><pre><code><br />5000 iterations of f1: 2328 ticks<br />5000 iterations of f1: 2594 ticks<br />5000 iterations of nc1: 3781 ticks<br /></code></pre><br /><br />Would be fun seeing what some of the skilled programmers around here could come up with - even without MMX or SSE, a dedicated assembly implementation should bring some nice improvement :)<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2228" target="_blank">imgflip.cpp.txt</a></li>
      <li><a href="../../attachments/?id=2229" target="_blank">imgflip.asm</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-01-17 23:28:13 by f0dder</div>
   </div>
   <div class="post" id="post-187607">
    <div class="subject"><a href="#post-187607">Re: First foray into asm</a></div>
    <div class="body">thanks for your efforts f0dder, i&#39;ll have a look through the code when i get a chance. <br /><br />At the moment i&#39;m trying to improve the gamma, well brightness really function i might need to use, as for a 1280x960 image it takes a whopping 82ms, including the vertical flip and R/B swap&nbsp; :shock:<br /><br />I noticed a few aspects of the C++ code you provided that i&#39;d like to determine the reasoning behind, If as I suspect they help the compile then i&#39;l defiantely incorporate them into my code.<br /><br />1. *src and *SrcRow - two pointers to the source<br />I can see why this was done, it allows src to iterate through the bytes of a pixel for a line, whilst srcRow allows for jumping through the lines of the image. What are the benifits of this method? I can see it removes the need to deduct 2*iRowBytes at the end of each line, but then you have to reset src to scrRow afterwards. Perhaps there is a small gain (i&#39;ve not looked at the asm), but perhaps there are other better reasons for doing this?<br /><br />2. Temp variables<br />I noticed inside the inner loop you declare the byte variables for holding r,g,b again what are the benifits in doing this. I was under the impression that in a good c++ implementation that these would get deleted once outside the scoop of the inner for loop, but would have to be recreated for the next line.<br /><br />3. Byteswap<br />Took a while to register what was going on with this function, until i looked properly at the little table comment you provided. Very nice. Going to have to take a good look through this code. <br /><br />It didn&#39;t occur to me that you could byteswap with a shift to go from 0RGB to BGR0 - have to remember that. Although I don&#39;t think i&#39;ll need to do the btyeswap as i&#39;m pretty sure Director image objects are BGRA ( image objects in Director (the destination)&nbsp; don&#39;t support 24 bits, they are stored as 32bits with a flag to indicate if alpha is used or not. I guess for performance, memory layout reasons). <br /><br />Now i&#39;ll just have to see if all the camera output modes support line widths that are divisable by 4.<br /><br />Ok, i&#39;m going to look if i can incorporate some of the code into my test functions. However whilst i&#39;m very grateful for the effort you&#39;ve put into this, I must draw your attention that this specific function was only for testing and getting to grips with asm. For the real project other code considerations might make aspects of it less suitable. I&#39;ll post more details about that in a bit, but I didn&#39;t want you to get too carried away, investing your time into something that I may not use directly. Conversely though, its all still great learning stuff for myself and hopefully anyone else who stumbles into this thread. So thanks again</div>
    <div class="meta">Posted on 2007-01-18 08:23:53 by noisecrime</div>
   </div>
   <div class="post" id="post-187613">
    <div class="subject"><a href="#post-187613">Re: First foray into asm</a></div>
    <div class="body"><div class="quote">At the moment i&#39;m trying to improve the gamma, well brightness really function i might need to use</div><br />Please know that integer image manipulation is best done using MMX, so you should go for it if you want some incredible speed improvements. As for brightness: PADDUSB instruction is your friend here ;)</div>
    <div class="meta">Posted on 2007-01-18 14:52:12 by ti_mo_n</div>
   </div>
   <div class="post" id="post-187614">
    <div class="subject"><a href="#post-187614">Re: First foray into asm</a></div>
    <div class="body">Thanks for the information ti_mo_n, had no iea that MMX would be useful for interger manipulation, then again having never looked at it, I guess I really don&#39;t know what MMX is for anyway.<br /><br />PADDUSB - wow what a great little instruction, looks like i&#39;m going to have to start reading up on MMX along with everything else i&#39;ve got on my to dolist - or perhaps I should just finish the project and play later, I never expected to spend a week on it ;)<br /><br />Somewhat frustrating to learn about the function now though, having spent all day optomising the algorithm and getting pretty decent results in the end. </div>
    <div class="meta">Posted on 2007-01-18 18:42:30 by noisecrime</div>
   </div>
   <div class="post" id="post-187615">
    <div class="subject"><a href="#post-187615">Re: First foray into asm</a></div>
    <div class="body"><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=22458.0">This topic</a> describes MMX and SSE a bit.</div>
    <div class="meta">Posted on 2007-01-18 20:32:32 by ti_mo_n</div>
   </div>
   <div class="post" id="post-187641">
    <div class="subject"><a href="#post-187641">Re: First foray into asm</a></div>
    <div class="body">about compilers being good these days...<br /><br />yesterday i looked at what vc2k5 would generate for a simple dst<em>=src<em> loop..<br /><br />and it really blew my head off!<br /><br />dont have the exact code but it had only ONE pointer increase!<br /><br />there was something like<br /><br />mov eax, ,<br />mov , eax<br />add esi,4<br /><br /><br />so i suppose the compiler has calculated the difference between the highest and the lowest address of source and dest pointer... and put it into ebx.<br /><br />I FOUND THIS AMAZING!<br /><br />well, let me explain ; for someone else maybe its very simple , and INDEED ITS IS!<br />especially when you first had sthg like<br />add esi,4<br />add edi,4<br />but the reason it blew my head off is that its something i&#39;ve thought of quite a lot (well not really but you get the idea) and it never appeared to me! and now i think msvc is an outstanding piece of software.. (the ability to debug and see assembly in a window etc, btw once i couldnt debug properly, it told me the breakpoint would not be hit and i didnt understand, i think maybe it was because the lib(tinyptc) was using loadlibrary? anyway its not the matter)<br /><br />so.. the benefit is that you save the second ADD... but you still need TWO regs, even if its not two pointer to src and dst...so you&#39;re not saving one reg.<br /><br />but i thought:<br />you could save this reg by using an uimmediate: mov , eax<br />the reason you cannot do this is that src and dst are variables... not known at compile time...<br />so: with synamic code generation, it would work! in fact youjust have to patch the DWORD difference... would this work? (ofcourse thats four bytes to embed in the instruction but i hope its not a big hit ...)<br />then youve got one more reg available in your loop...<br /><br />btw this leads us to another thing that impressed me:<br />i had coded image manipulation routines in C that made AHellOfALot of src<em>+src[(i-1)i*3+2] <br />etc... accessing 24bpixels and near pixel you know... and the compiler optimized the whole thing like i would have done, i mean NOT A MUL in the loop! it had figured out it could use a pointer and do ptr+=3 each loop. thats great! (in fact i&#39;ve seen this at school, it differntiates the expression you put in the loop, but i wouldnt have thought it could really get it right!)<br /><br /></div>
    <div class="meta">Posted on 2007-01-19 12:21:28 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-187644">
    <div class="subject"><a href="#post-187644">Re: First foray into asm</a></div>
    <div class="body"><div class="quote"><br />with synamic code generation, it would work! in fact youjust have to patch the DWORD difference... would this work? (ofcourse thats four bytes to embed in the instruction but i hope its not a big hit ...)<br /></div><br />it would work, but SMC code can end up slow - unless it&#39;s &quot;generate once, use many&quot;. And you have to either make your code section writable (not necessarily a good idea), or generate function in writable+executable memory.<br /></div>
    <div class="meta">Posted on 2007-01-19 16:36:37 by f0dder</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=25707&amp;page=1" style="">&laquo;</a><a href="../?id=25707&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="25707" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>