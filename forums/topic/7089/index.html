<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>GlobalAlloc: fixed or movable - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=7089" />
    <link rel="next" href="../?id=7089&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=7089">GlobalAlloc: fixed or movable</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=7089&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=7089&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="7089" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=7089&amp;page=2">&gt;</a><a href="../?id=7089&amp;page=2">&raquo;</a></form>   <div class="post" id="post-51247">
    <div class="subject"><a href="#post-51247">GlobalAlloc: fixed or movable</a></div>
    <div class="body">Hi,<br /><br />I wonder, why most programmers use this technique to alloc memory:<br /><br />...<br />invoke GlobalAlloc, GMEM_MOVEABLE, dwFileSize <br />invoke GlobalLock, eax<br />...<br /><br />Isn't it better to use this technique ? Fixed memory don't need to lock (I think) ? <br /><br />...<br />invoke GlobalAlloc,GMEM_FIXED,dwFileSize<br />...<br /><br />Greetings,<br />Nordwind64</div>
    <div class="meta">Posted on 2002-08-01 14:35:12 by Nordwind64</div>
   </div>
   <div class="post" id="post-51249">
    <div class="subject"><a href="#post-51249">GlobalAlloc: fixed or movable</a></div>
    <div class="body">use HeapAlloc or VirtualAlloc :)</div>
    <div class="meta">Posted on 2002-08-01 14:46:04 by stryker</div>
   </div>
   <div class="post" id="post-51250">
    <div class="subject"><a href="#post-51250">GlobalAlloc: fixed or movable</a></div>
    <div class="body">...and why, please ? Is this faster ?<br />I have read in this Forum, that GlobalAlloc and HeapAlloc uses the same code... <br /><br />Nordwind64</div>
    <div class="meta">Posted on 2002-08-01 15:14:11 by Nordwind64</div>
   </div>
   <div class="post" id="post-51251">
    <div class="subject"><a href="#post-51251">GlobalAlloc: fixed or movable</a></div>
    <div class="body">Ask f0dder, he seems to explain every bit in detail. :tongue: Try searching, there seems to be a lot of discussions about this in the past about GlobalAlloc vs. HeapAlloc vs. VirtualAlloc ... Oh and BTW, there's a lot of &quot;Flame Wars&quot; about this. :grin:<br /><br />I think there's a test program benchmarking each memory allocation functions. Can't seem to find it...</div>
    <div class="meta">Posted on 2002-08-01 15:18:32 by stryker</div>
   </div>
   <div class="post" id="post-51259">
    <div class="subject"><a href="#post-51259">GlobalAlloc: fixed or movable</a></div>
    <div class="body">Use moveable, as fixed seems to fail on NT.</div>
    <div class="meta">Posted on 2002-08-01 16:50:28 by comrade</div>
   </div>
   <div class="post" id="post-51267">
    <div class="subject"><a href="#post-51267">GlobalAlloc: fixed or movable</a></div>
    <div class="body">Yep you're right FIXED doesn't need Lock, I never seen any problems with it, but then I haven't used NT.<br /><br />Stryker's probably right though, f0dder does a good job of explaining why.</div>
    <div class="meta">Posted on 2002-08-01 17:18:50 by EÃ³in</div>
   </div>
   <div class="post" id="post-51276">
    <div class="subject"><a href="#post-51276">GlobalAlloc: fixed or movable</a></div>
    <div class="body">I've had no trouble with GlobalAlloc + fixed under NT. Using &quot;movable&quot; is sorta silly as this isn't necessary under win32, as we have page-based memory management rather than the segment-based stuff of win16. Return value *does* change after GlobalLock()ing a GMEM_MOVEABLE pointer, but GlobalAlloc (and LocalAlloc) for that matter end up calling HeapAlloc on NT - 9x is somewhat muddier, I didn't bother digging in too deep. Could be that it works differently under 9x, considering the amount of crappy 16bit code that is still present in that dos extender (or OS, if you prefer...)<br /><br />VirtualAlloc is not good for 'generic' allocations. It has a fair amount of overhead, and all requests are padded to nearest 4k size. Use it if you need to allocate large (&gt;64k) buffers and want the alignment and/or page-level protection flags VirtualAlloc offers. It's good for eg framebuffers. You could also implement your own memory management scheme using VirtualAlloc, I believe the Visual C++ runtimes do this rather than using HeapAlloc... I haven't timed these against HeapAlloc, but I would assume it's faster. With VirtualAlloc you can also commit/decommit pages as you see fit. But I repeat, don't think VirtualAlloc is a replacement for HeapAlloc - it's not.<br /><br />I advise people to use HeapAlloc for generic memory allocations. It's the preferred method under win32, and the legacy local/globalalloc are deprecated. You get more control with the heap functions; you can create your own heaps, and you can specify whether heap access should be synchronized or not (haven't timed the speed difference, but I assume it's extremely small).<br /><br />I wrote some lengthy posts on the various allocation methods, and the conclusion is that the speed of the 'regular' allocation functions are nearly identical, and since HeapAlloc doesn't depend on COM or other stuff, you might as well use it and have as little memory bloat in your app as you can.</div>
    <div class="meta">Posted on 2002-08-01 19:08:33 by f0dder</div>
   </div>
   <div class="post" id="post-51286">
    <div class="subject"><a href="#post-51286">GlobalAlloc: fixed or movable</a></div>
    <div class="body">Using GMEM_FIXED/LMEM_FIXED can be a problem if you want to use GlobalRealloc/LocalRealloc later. AFAIK this doesn't work in Win9x.</div>
    <div class="meta">Posted on 2002-08-01 21:31:31 by japheth</div>
   </div>
   <div class="post" id="post-51290">
    <div class="subject"><a href="#post-51290">GlobalAlloc: fixed or movable</a></div>
    <div class="body">I use GlobalAlloc,GPTR,xxx in several of my programs (GPTR = GMEM_FIXED+GMEM_ZEROINIT) and have no problems relocating it using GlobalReAlloc,ptr,bytes,GMEM_MOVEABLE. I've tested this on 98 and NT. In one particular piece of code I grow the allocated memory in 512k blocks as the size of the data grows and I have not experienced any problems even after multiple calls.<br /><br />--Chorus</div>
    <div class="meta">Posted on 2002-08-01 21:44:14 by chorus</div>
   </div>
   <div class="post" id="post-51321">
    <div class="subject"><a href="#post-51321">GlobalAlloc: fixed or movable</a></div>
    <div class="body">I have never made a call to Heap/Global/Local-XXX(), I use VirtualXXX() with my own memory manager, but intuitively I'm sure++ it all goes down to the Win32 internal garbage collection system, which can work only when you UNLOCK or RESIZE (in both cases your memory pointer will have a chance to change, so Windows can move the memory blocks as it wishes to compact them together and thus remove &quot;holes&quot;, i.e. fragmentation. That's the whole point). If you use MEM_FIXED, you will make all those pointers &quot;unmovable&quot;, and any fragmentation will remain there.<br /><br />Sure, as <strong>f0dder</strong> points, the paged system of Win32 will <em>anyway</em> be able to remove the fragmented 4KB pages, but since the whole point of using Heap/Global/Local-XXX() is to make small allocations, then fragmentation will really be a problem (of course proportional to how much total memory you use, vs how much is there in the system).<br /><br />In general, having my own memory management routines and having dealt with it and the problems and side effects for years, it's my strong own belief that one should avoid to keep pointers if it doesn't give benefits. From time to time, e.g. when you wait for user input (PeekMessage + sleep loop, not GetMessage .. if you base your input on that, that is) you should UNLOCK as many heap blocks as possible, thus letting Windows <em>reorganize</em> and compact the HEAP (or asking it explicitly to do it, if there's such a function - I hope there is), and generally making a wiser use of the system memory, avoiding wastes and fragmentation holes.<br /><br />I believe that this Heap/Global/Local-XXX() system is a heritage of Win16 <strong>cooperative</strong> multitasking.. i.e. if Win32 was there from the start they wouldn't have even bothered to implement it, maybe. But IMHO this system is good.. or at least it's something similar to what I came up myself for my own &quot;OS&quot;, and for garbage collection.. let away that cooperative systems generally perform sensibly better than preemptive-and-the-like ones, bugs excluded.<br /><br />Also, I like of my &quot;OS&quot; that all code/data modules are relocatable in real-time, this means that I can access my allocated heap block with <strong>direct</strong> pointers, and if they change, I'll just relocate (after allocation the first time, and again every time the pointer changes) all the locations that point to it. So I don't have the overhead of loading a buffer pointer before accessing to the buffer. Because of cache considerations this gives a very important speedup. I just love this system.. e.g. I can at run-time plug or unplug &quot;file system devices&quot; or &quot;gfx load modules&quot; and all will work without indirect pointers. The goal is having a OS which never needs to be rebooted, and is always clean (i.e. fragmentation is kept under control), and can be expanded, replaced or anything while running (providing you put care in knowing if there are copies of pointers floating around, etc..).. never rebooting during its whole lifetime.<br /><br />To return to the topic.. Why bother.. always allocate your memory as MOVEABLE, and then you can keep it always LOCKED if you really need so. From time to time, if you want to make some &quot;garbage collection&quot;, you will have a chance to do it. The best of both worlds, as Van Halen says.</div>
    <div class="meta">Posted on 2002-08-02 02:39:11 by Maverick</div>
   </div>
   <div class="post" id="post-51328">
    <div class="subject"><a href="#post-51328">GlobalAlloc: fixed or movable</a></div>
    <div class="body">Thats from MSDN<br /><br /><div class="quote"><br />Memory Management<br />In Windows 95/98/Me, fixed memory blocks cannot be reallocated to be movable. The GMEM_MODIFY and GMEM_MOVEABLE combination of values has no effect when a memory block is reallocated by using the GlobalReAlloc function. Similarly, the LMEM_MODIFY and LMEM_MOVEABLE combination has no effect when a memory block is reallocated by using the LocalReAlloc function.<br /><br /></div><br /><br />I had some problems with the realloc versions and avoid using it. Maybe it fails in win9x only if the memory block will change its address.</div>
    <div class="meta">Posted on 2002-08-02 03:21:12 by japheth</div>
   </div>
   <div class="post" id="post-51343">
    <div class="subject"><a href="#post-51343">GlobalAlloc: fixed or movable</a></div>
    <div class="body">Hi,<br /><br />thank you for your opinions !<br />But is there a temporal difference between the functions ? Wich function creates fastest read/write access to memory ?<br /><br />Nordwind64</div>
    <div class="meta">Posted on 2002-08-02 07:31:04 by Nordwind64</div>
   </div>
   <div class="post" id="post-51359">
    <div class="subject"><a href="#post-51359">GlobalAlloc: fixed or movable</a></div>
    <div class="body">Maverick, while win16 would definitely move memory blocks<br />around (it was about the only way to do memory management<br />without paging features), I doubt this happens under win32.<br />It *might* happen on win9x (I doubt it though), but it definitely<br />wont happen on NT, as NT uses HeapAlloc inside local/globalalloc.<br />HeapAlloc is *not* allowed to change pointer values.<br /><br />Imo, fragmentation is not that much of a problem, unless you<br />are &quot;out of control&quot;. If so, you could always try creating an<br />extra heap, as all memory allocations can the be freed at once,<br />or you could implement your own memory management system.<br /><br />Also, you say &quot;PeekMessage + sleep loop, not GetMessage&quot; - why?<br />With GetMessage, your thread will not be scheduled until there's<br />a message in your queue... should give better utilization of the<br />CPU then the &quot;polling&quot; loop of PeekMessage+Sleep.<br /><br />You say that in your &quot;OS&quot; everything is &quot;relocatable in real-time&quot;.<br />How? Delta-pointers? Or actual relocation of the code? Actual<br />relocation (if it has to be done more than 'seldomly') seems like<br />an awful waste of time to me (plus, if implemented &quot;ontop&quot; of a<br />regular OS, or if your OS is a 'real' OS :) with paging and COW,<br />you'll get dirty pages). If it's via delta pointers, aren't you<br />wasting a precious register that could be used for something else?<br />The idea sounds interesting, but I'd like to hear a bit about how<br />it's done.<br /><br />Japheth, that MSDN blob only seems to indicate that you cannot<br />change the 'allocation type' of a memory block allocated with<br />GMEM_FIXED? It doesn't say anything about not being able to<br />just adjust the allocation size?<br /><br />NordWind, all the 'normal' memory allocation functions have same<br />access speed to the memory. Memory Mapped Files are a little slower<br />in access, for some weird reason. As for allocation/deallocation<br />speed, Memory Mapped Files are the slowest, followed by VirtualAlloc.<br />The rest of the functions are about the same speed... there's difference<br />between &quot;zeropage&quot; memory and &quot;uninitialized&quot; memory (0page is, ie,<br />HeapAlloc with the HEAP_ZERO_MEMORY memory flag, or any Global/LocalAlloc).<br />The COM IMalloc interface (and thus CoTastMemAlloc), HeapAlloc without<br />the zeromem flag, SysAllocStringByteLen all return uninitialized memory,<br />and is a bit more than double as fast as the 0page allocations. I wrote<br />some lengthy posts about this earlier :).</div>
    <div class="meta">Posted on 2002-08-02 08:59:26 by f0dder</div>
   </div>
   <div class="post" id="post-51370">
    <div class="subject"><a href="#post-51370">GlobalAlloc: fixed or movable</a></div>
    <div class="body">From GlobalReAlloc in my WinAPI Guide (not MSDN):<br /><br /><div class="quote"><br /><em>uFlags</em><br /><br />If this parameter does not specify GMEM_MODIFY, it can be any combination of the following flags: <br /><br />GMEM_MOVEABLE	If dwBytes is zero, discards a previously movable and discardable memory block. If the lock count of the object is not zero or if the block is not movable and discardable, the function fails. If dwBytes is nonzero, enables the system to move the reallocated block to a new location <strong>without changing the movable or fixed attribute</strong> of the memory object. <strong>If the object is fixed, the handle returned may be different from the handle specified by the hMem parameter</strong><br /></div><br /><br />It seems to me that you can realloc fixed blocks with no problem. Just don't expect the pointer returned to be any good. As I mentioned above, I use this technique plenty and it always works if I track the new pointer (if I don't the system crashes which to me would suggest that the ptr is invalidated from the call)<br /><br />--Chorus</div>
    <div class="meta">Posted on 2002-08-02 10:29:24 by chorus</div>
   </div>
   <div class="post" id="post-51372">
    <div class="subject"><a href="#post-51372">GlobalAlloc: fixed or movable</a></div>
    <div class="body">Well, globalrealloc *does* return a new pointer/handle, so of course<br />you cannot depend on the old pointer ;). For GMEM_FIXED allocations,<br />the returnvalue is a pointer, for the others it's a handle.<br /><br />Why do people keep on using global/localalloc? Is there some reason<br />behind this, or just old preferences?</div>
    <div class="meta">Posted on 2002-08-02 10:37:03 by f0dder</div>
   </div>
   <div class="post" id="post-51381">
    <div class="subject"><a href="#post-51381">GlobalAlloc: fixed or movable</a></div>
    <div class="body">Personally, the GlobalAlloc function is easy to implement. And I've never needed it to be &quot;time critical&quot; so why not? I should probably get into the habit of HeapAlloc. For the most part, though, I'm busy working on the data *in* the memory and making sure that's working, rather than implementing the memory itself.<br /><br />--Chorus</div>
    <div class="meta">Posted on 2002-08-02 11:55:14 by chorus</div>
   </div>
   <div class="post" id="post-51382">
    <div class="subject"><a href="#post-51382">GlobalAlloc: fixed or movable</a></div>
    <div class="body">Hi <strong>f0dder</strong>, you wrote: <em>You say that in your &quot;OS&quot; everything is &quot;relocatable in real-time&quot;.<br />How? Delta-pointers? Or actual relocation of the code? Actual<br />relocation (if it has to be done more than 'seldomly') seems like<br />an awful waste of time to me (plus, if implemented &quot;ontop&quot; of a<br />regular OS, or if your OS is a 'real' OS with paging and COW,<br />you'll get dirty pages). If it's via delta pointers, aren't you<br />wasting a precious register that could be used for something else?<br />The idea sounds interesting, but I'd like to hear a bit about how<br />it's done.</em><br /><br /><br />Simply, I've my own object file format. The structure is (square brackets mean &quot;optional&quot;):<br /><br />signature<br /><br /><br /><br />module<br /><br /><br /><br />...<br /><br /><br />---<br /><br />The source of course can be stripped away, and is used only by the compiler anyway.<br />Exported types can be stripped away too, and make the module usable by the compiler even if the source is missing.<br /><br />Now, there are 1 or more modules. Only one will be chosen, basing on some host's environment variables. These variables can be X86 rather than 68000; WIN32 rather than DOS32 or AMIGAOS; WIN9X rather than WINNT, and so on. Each of these modules has a logical expression of the kind &quot;X86&amp;(WIN32|DOS32)&quot;. As I wrote above, only one MODULE (per file) will be chosen.<br /><br />The module has then this structure:<br /><br />header<br />loadedif section (explained above)<br />code or data section<br />relocation table<br />exported objects<br />   (points to the source, quickinfo and docs areas.. all are in the &quot;source&quot; area)<br />imported objects<br /><br />A module can be mapped but not yet loaded, and it can be unloaded at any time.<br />When, by request, loaded, a module is allocated in memory and its raw data loaded there. Then it gets relocated. Then all its exported objects are noted by the OS, and made available to all other modules which will be installed in the future. Then its imports list is walked, and all the requested objects' addresses, sizeof or other info are inserted into the module.. and if those objects weren't yet available, their respective module gets loaded (recursion takes place here). Then the optional module constructor routine gets executed. There's more than just this, though.<br /><br />In practice it's a dynamic, run-time linker. There's a list of objects, etc.. which (if I need that little memory) I can discard with no problems, but losing future relocability, etc..<br /><br />The modules are built by my programming language compiler, but I've written some utilities to help FASM produce them as well (a bit less comfortably, though).<br /><br />With this complete info I can move an object elsewhere in memory, and know all the locations that <strong>referenced</strong> it, and thus make them point to the new object's address (or other characteristics, which are very specific to my programming language). The objects can be accessed through a bias, with no overhead.<br /><br />It's rare that I need to move objects around.. it's a matter of initialization or SMC-like techniques.. but it's extremely handy in certain situations, and is part of the reasons why my programming language's OO nature has no overhead. And it anyway lets me use direct pointers anywhere I wish, add plug-in modules for my file system, or for e.g. the gfx file load system, etc.. unplug them, all with total freedom.<br /><br />The compiler compiles itself, the OS has everything necessary to be a standalone system or, thanks to the &quot;loadedif&quot; sections I described earlier, to stay on top of any OS, being also extremely multiplatform by design. It's so modular that only the code/data (or part of) that is really needed is in RAM, although on disk there may be also the Amiga version, etc.. (Amiga version not done, but someday, who knows..).<br /><br />It's modular and object oriented till the nause. Also, a collection of IMHO very clever ideas make it better than it may seem from the above description. I can't imagine a better system for code/data re-utilization, so to reduce development as much as possible, and being more and more productive program after program (much more than LIBs or DLLs or messy source code allow, and with no overhead).</div>
    <div class="meta">Posted on 2002-08-02 12:06:37 by Maverick</div>
   </div>
   <div class="post" id="post-51384">
    <div class="subject"><a href="#post-51384">GlobalAlloc: fixed or movable</a></div>
    <div class="body">Hello. Found this article on MSDN knowledge base, you might find it interesting:<br /><br /><a target="_blank" href="http://support.microsoft.com/default.aspx?scid=KB;EN-US;Q198959&amp;">http://support.microsoft.com/default.aspx?scid=KB;EN-US;Q198959&amp;</a><br /><br />among other things it confirms that GlobalAlloc/LocalAlloc call HeapAlloc on 9x platforms (I think, f0dder, you had said earlier that this was for sure true on NT but you weren't sure on 9x).<br /><br />--Chorus</div>
    <div class="meta">Posted on 2002-08-02 12:46:03 by chorus</div>
   </div>
   <div class="post" id="post-51386">
    <div class="subject"><a href="#post-51386">GlobalAlloc: fixed or movable</a></div>
    <div class="body">Thanks chorus. I didn't bother tracing much around in 9x stuff, as there's a lot of unnamed stuff etc. Btw on NT, the local/globalalloc symbols do NOT point to the same address as I've previously said - dunno why I thought so. Oh well, perhaps they have done so on a different service pack :).<br /><br />The functions are largely identical, though. There's some parameter conversion done (like GMEM_ZEROINIT to HEAP_ZERO_MEMORY). Furthermore, there's some seems-to-be undocumented values added to the HeapAlloc flags: 0x100000 for GlobalAlloc, 0x140000 for LocalAlloc.<br /><br />Calls to GetProcessHeap() are not being done by Local/GlobalAlloc, they use a preinitialized dword, which seems to be initialized from &quot;somewhere in the TIB&quot;... study of GetProcessHeap shows it uses the same fields of the TIB.<br /><br />So, on NT, Global/LocalAlloc are HeapAlloc + some_undocumented_flags :).<br /><br />I usually do a &quot;ghHeap = GetProcessHeap();&quot; at the start of my program, and later on I have halloc, hrealloc and hfree like this:<br /><br /><pre><code><br />void *halloc&#40;u32 size&#41;<br />&#123;<br />	return HeapAlloc&#40;ghHeap, HEAP_ZERO_MEMORY, size&#41;;<br />&#125;<br /><br />void *hrealloc&#40;void *block, u32 size&#41;<br />&#123;<br />	return HeapReAlloc&#40;ghHeap, HEAP_ZERO_MEMORY, block, size&#41;;<br />&#125;<br /><br />void hfree&#40;void *block&#41;<br />&#123;<br />	HeapFree&#40;ghHeap, 0, block&#41;;<br />&#125;<br /></code></pre><br /><br />I'm considering adding a bool to halloc and hrealloc to specify whether HEAP_ZERO_MEMORY should be used or not, but I like the simplicity of these routines, need zero-initialized memory most of the time, and for code where the performance matters, I'd probably do it differently.</div>
    <div class="meta">Posted on 2002-08-02 13:37:29 by f0dder</div>
   </div>
   <div class="post" id="post-51388">
    <div class="subject"><a href="#post-51388">GlobalAlloc: fixed or movable</a></div>
    <div class="body">I thought to implement such wrapping functions, altough the fact of having a global variable was still haunting me... (I know there is not much impact to have some global variables especially in win32... but...) but it still is without a doubt a better solution than calling GetProcessHeap(); everytime anyway. ;)<br /><br />I was wondering if there were a reason to implement these wrappers as functions rather than &quot;#define&quot;s...<br /><br />I know the calling impact will not be an important overhead, and that functions are more elegant, but with inline... won't the compiler inline such a function? Some of your past posts says that the compiler often ignore the keyword... even with such a simplistic function?<br />I have been using VC6 __inline (trough an inline redefined by the C preprocessor... it allows me to compile c99 code made for gcc easily without errors and warning) and my (simple) test functions always were inlined...<br /><br />Thanks.</div>
    <div class="meta">Posted on 2002-08-02 13:53:07 by JCP</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=7089&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=7089&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="7089" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=7089&amp;page=2">&gt;</a><a href="../?id=7089&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>