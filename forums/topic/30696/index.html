<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>16-bit calculator - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30696" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=30696">16-bit calculator</a></p>
   <div class="post" id="post-215148">
    <div class="subject"><a href="#post-215148">16-bit calculator</a></div>
    <div class="body">hi everyone!<br />i need help on may code it is a calculator that asked the user to input an expression (eg. 56+2) in one line and output the answer..it suppose to manipulate mdas.<br /><br />please help me fix this code..<br />(i mean this is not really my code but i did tried to fix it.)<br /><br /><pre><code>.model small<br />.stack 64<br />.data<br />	error_alpha db &quot;Invalid input. Expression contains letter/s. &quot;,13,10,&quot;$&quot;<br />	error_range db &quot;Invalid input. Operand/s may be out of range. &quot;,13,10,&quot;$&quot;<br />	error_overflow db &quot;An overflow has occurred. &quot;,13,10,&quot;$&quot;<br />	error_invalidinput db &quot;Invalid Input. &quot;,13,10, &quot;$&quot;<br />	redo db &quot;Please enter a valid one.&quot;,13,10,&quot;$&quot;<br />	newline db 13,10,&quot;$&quot;<br />	inputlen dw 2<br />	op1len dw 1<br />	op2len dw 2<br />	prompt db &quot;Enter an expression: &quot;,&quot;$&quot;<br />	inputLabel label byte<br />	inputmaxLen db 50<br />	inputcurLen db ?<br />	inputData db 50 dup (?)<br />	str_operand1 db 10 dup (?)<br />	str_operand2 db 10 dup (?)<br />	str_operator db 2 dup (?)<br /><br />	operand_sign1 db 2 dup (?)<br />	operand_sign2 db 2 dup (?)<br /><br />	sign_counter db 0h<br />	multbyTen db 10<br />	op_temp1 dw ?<br />	op_temp2 dw ?<br /><br />	op_fin1 dw ?<br />	op_fin2 dw ?<br />	tempAnswer dw ?<br />	finalAnswer dw ?<br />	divAnswer dw 0h<br />	remainder db ?<br />	finalRem dw ?<br />	outputDecimal db &quot;DECIMAL: $&quot;<br />	outputBinary db &quot;BINARY: $&quot;<br />	outputOctal db &quot;OCTAL: $&quot;<br />	outputHex db &quot;HEXADECIMAL: $&quot;<br /><br />	rev_ascii_decimal db ?<br />	rev_ascii_binary db ?<br />	rev_ascii_octal db ?<br />	rev_ascii_hexadecimal db ?<br />	outputSign db ?<br /><br />	dec_len dw 0h<br />	bin_len dw 0h<br />	oct_len dw 0h<br />	hex_len dw 0h<br /><br /><br />	find_operand1 dw 0h<br />	find_operand2 dw 0h<br /><br />	temp dw 0h<br /><br />	sum dw 0h<br />	multiplier dw 0h<br />	product dw 0h<br />	<br />.code<br />	;asks the user for input<br />	prompt_for_input proc<br />		mov dx, offset prompt<br />		mov ah, 9h<br />		int 21h<br />		mov dx, offset inputLabel<br />		mov ah, 0ah<br />		int 21h<br />		mov bx, 0h<br />		mov bl, inputcurLen<br />		mov inputData, &quot;$&quot;<br />		mov bx, 0<br />		mov bl, inputcurLen<br />		mov inputlen, bx<br />		ret<br />	prompt_for_input endp<br />	<br />	; gets the operands and the operator from the one line of input<br />	get_operators_and_operands proc<br />		mov ax, 0<br />		mov bx, 0<br />		mov dx, 0<br />		mov cx, 0<br />		mov si, 0<br />		mov bp, 0<br />		mov op1len, 0h<br />		mov op2len, 0h<br /><br />		pre_conv1:<br />			mov al, inputData<br />			call check_if_digit<br />			jz pre_start_operand1<br /><br />		check_sign1:<br />			cmp al, &quot;-&quot;<br />			je negative_op1<br />			cmp al, &quot;+&quot;<br />			je positive_op1<br /><br />		call invalid_input<br /><br />		negative_op1:<br />			mov operand_sign1[0], &quot;-&quot;<br />			mov operand_sign1[1], &quot;$&quot;<br />			inc bx<br />			jmp start_operand1<br /><br />		positive_op1:<br />			mov operand_sign1[0], &quot;+&quot;<br />			mov operand_sign1[1], &quot;$&quot;<br />			inc bx<br />			jmp start_operand1<br /><br />		pre_start_operand1:<br />			mov operand_sign1[0], &quot;+&quot;<br />			mov operand_sign1[1], &quot;$&quot;<br />			jmp start_operand1<br /><br />		start_operand1:<br />			mov al, inputData<br />			cmp al, &quot; &quot;<br />			je end_operand1<br />			push bx<br />			mov bx, 0<br />			mov bx, cx<br />			mov str_operand1,al<br />			pop bx<br />			inc op1len<br />			inc cx<br />			inc bx<br />			jmp start_operand1<br /><br />		end_operand1:<br />			push bx<br />			mov bx, 0<br />			mov bx, cx<br />			mov str_operand1, &quot;$&quot;<br />			pop bx<br />			jmp get_operator<br /><br />		get_operator:<br />			inc bx<br />			mov al, inputData<br />			mov str_operator[0], al<br />			mov str_operator[1], &quot;$&quot;<br />			inc bx<br />			inc bx<br />			mov ax, 0<br />			mov cx, 0<br />			jmp pre_conv2<br /><br />		pre_conv2:<br />			mov al, inputData<br />			call check_if_digit<br />			jz pre_start_operand2<br />			jnz check_sign2<br /><br />		check_sign2:<br />			cmp al, &quot;-&quot;<br />			je negative_op2<br />			cmp al, &quot;+&quot;<br />			je positive_op2<br /><br />		call invalid_input<br /><br />		pre_start_operand2:<br />			mov operand_sign2[0], &quot;+&quot;<br />			mov operand_sign2[1], &quot;$&quot;<br />			jmp start_operand2<br /><br />		start_operand2:<br />			mov al, inputData<br />			cmp al, &quot;$&quot;<br />			je end_operand2<br />			push bx<br />			mov bx, 0<br />			mov bx, cx<br />			mov str_operand2,al<br />			pop bx<br />			inc op2len<br />			inc cx<br />			inc bx<br />			jmp start_operand2<br /><br />		end_operand2:<br />			push bx<br />			mov bx, 0<br />			mov bx, cx<br />			mov str_operand2, &quot;$&quot;<br />			pop bx<br /><br />			ret<br /><br />		negative_op2:<br />			mov operand_sign2[0], &quot;-&quot;<br />			mov operand_sign2[1], &quot;$&quot;<br />			inc bx<br />			jmp start_operand2<br /><br />		positive_op2:<br />			mov operand_sign2[0], &quot;+&quot;<br />			mov operand_sign2[1], &quot;$&quot;<br />			inc bx<br />			jmp start_operand2<br />			get_operators_and_operands endp<br />	<br />	;checks what operator was used and performs the indicated operation<br />	check_operator proc<br />		mov bx, 0<br />		mov bl, str_operator[0]<br />		cmp bl, &quot;+&quot;<br />		jne check_sub<br />		call add_nos<br />		ret<br />		check_sub:<br />		cmp bl, &quot;-&quot;<br />		jne check_mul<br />		call sub_nos<br />		ret<br />		check_mul:<br />		cmp bl, &quot;*&quot;<br />		jne check_div<br />		call mul_nos<br />		ret<br />		check_div:<br />		cmp bl, &quot;/&quot;<br />		jne call_invalid_input<br />		call div_nos<br />		ret<br />		call_invalid_input:<br />		call invalid_input<br />	check_operator endp<br /><br />	;jumps to the procedure input_out_of_range<br />	to_input_out_of_range proc<br />		jmp input_out_of_range<br />	to_input_out_of_range endp<br /><br />	;converts the operands to decimal to be used in the arithmetic operations<br />	convert_operands_to_decimal proc<br />		mov bx, 0h<br />		find_eostring1:<br />		mov ax, 0<br />		mov al, str_operand1<br />		cmp al, &quot;$&quot;<br />		je two<br />		sub al, 30h<br />		mov str_operand1, al<br />		inc bx<br />		jmp find_eostring1<br />		two:<br />		mov bx, 0h<br />		find_eostring2:<br />		mov ax, 0<br />		mov al, str_operand2<br />		cmp al, &quot;$&quot;<br />		je exit_cotd<br />		sub al, 30h<br />		mov str_operand2, al<br />		inc bx<br />		jmp find_eostring2<br /><br />		exit_cotd:<br />		cmp op1len, 6<br />		jg to_input_out_of_range2<br />		cmp op2len, 6<br />		jg to_input_out_of_range2<br /><br />		ret<br />	convert_operands_to_decimal endp<br /><br />	;performs addition if the operator is the &#039;+&#039; sign<br />	add_nos proc<br />		mov cl, operand_sign1[0]<br />		mov bl, operand_sign2[0]<br />		cmp cl, bl<br />		jne subit<br />		mov al, str_operand1<br />		mov dl, str_operand2<br />		add al, dl<br />		add al, 30h<br />		mov dl, al<br />		mov ah, 9h<br />		int 21h<br />		ret<br />		subit:<br />		mov bx, op1len<br />		mov cx, op2len<br />		cmp bx, cx<br />		jl subop2<br />		subop1:<br />		mov cl, operand_sign1[0]<br />		mov outputSign[0],cl<br />		mov outputSign[1],&quot;$&quot;<br />		sub al, dl<br />		ret<br />		subop2:<br />		mov dl, operand_sign2[0]<br />		mov outputSign[0],dl<br />		mov outputSign[1],&quot;$&quot;<br />		sub dl, al<br />		ret<br />	add_nos endp<br /><br />	;performs subtraction if the operator is the &#039;-&#039; sign<br />	sub_nos proc<br />		ret<br />	sub_nos endp<br />	<br />	;jumps to the procedure input_out_of_range<br />	to_input_out_of_range2 proc<br />		jmp input_out_of_range<br />	to_input_out_of_range2 endp<br />	<br />	;performs multiplication if the operator is the &#039;*&#039; sign<br />	mul_nos proc<br />		mov al, str_operand1<br />		mov dl, str_operand2<br />		mul dl<br />		mov finalAnswer,ax<br /><br />		mov cl, operand_sign1[0]<br />		mov bl, operand_sign2[0]<br />		cmp cl, bl<br />		je outputSign_is_pos<br />		mov outputSign[0],&quot;-&quot;<br />		jmp endsignmul<br />		outputSign_is_pos:<br />		mov outputSign[0],&quot; &quot;<br />		endsignmul:<br />		mov outputSign[1],&quot;$&quot;<br />		ret<br />	mul_nos endp<br /><br />	;performs division if the operator is the &#039;/&#039; sign<br />	div_nos proc<br />		mov dx, 0<br />		mov al, str_operand1<br />		mov bl, str_operand2<br />		div bl<br />		mov remainder, ah<br />		mov ah, 0<br />		mov divAnswer, ax<br /><br />		mov cl, operand_sign1[0]<br />		mov bl, operand_sign2[0]<br />		cmp cl, bl<br />		je outputSign_is_pos2<br />		mov outputSign[0],&quot;-&quot;<br />		jmp endsigndiv<br />		outputSign_is_pos2:<br />		mov outputSign[0],&quot; &quot;<br />		endsigndiv:<br />		mov outputSign[1],&quot;$&quot;<br />		ret<br />	div_nos endp<br /><br />	;prints the error message indicating that an operand&#039;s value is greater that 65536<br />	input_out_of_range proc<br />		call print_new_line<br />		mov dx, offset error_range<br />		mov ah, 09h<br />		int 21h<br />		call print_new_line<br />		mov dx, offset redo<br />		mov ah, 09h<br />		int 21h<br />		call print_new_line<br />		jmp start_program<br />	input_out_of_range endp<br /><br />	;prints the error message indicating that an overflow has occured<br />	overflow proc<br />		call print_new_line<br />		mov dx, offset error_overflow<br />		mov ah, 09h<br />		int 21h<br />		call print_new_line<br />		mov dx, offset redo<br />		mov ah, 09h<br />		int 21h<br />		call print_new_line<br />		jmp start_program<br />	overflow endp<br /><br />	;checks if there is a letter in the input<br />	isalpha proc<br />		mov cx , inputlen<br />		mov si, 0<br />		start:<br />		mov ax, 0<br />		mov al, inputData<br />		call check_if_alpha<br />		jz input_is_alpha<br />		inc si<br />		loop start<br />		ret<br />	isalpha endp<br /><br />	;prints the error message indicating that there are letter/s or symbol/s in the input<br />	input_is_alpha proc<br />		call print_new_line<br />		mov dx, offset error_alpha<br />		mov ah, 09h<br />		int 21h<br />		call print_new_line<br />		mov dx, offset redo<br />		mov ah, 09h<br />		int 21h<br />		call print_new_line<br />		call start_program<br />	input_is_alpha endp<br /><br />	;prints the error message indicating that the syntax of the input is wrong<br />	invalid_input proc<br />		call print_new_line<br />		mov dx, offset error_invalidinput<br />		mov ah, 09h<br />		int 21h<br />		call print_new_line<br />		mov dx, offset redo<br />		mov ah, 09h<br />		int 21h<br />		call print_new_line<br />		call start_program<br />		;ret<br />	invalid_input endp<br /><br />	;prints the decimal equivalent of the answer<br />	print_decimal_output proc<br />		mov dx, offset outputDecimal<br />		mov ah, 9h<br />		int 21h<br /><br />		mov ax, finalAnswer<br />		mov bl, 0ah<br />		div bl<br />		mov ah, 0<br />		mov rev_ascii_decimal,al<br /><br />		mov bx, 0<br />		mov cx, dec_len<br />		convertdecloop:<br />		mov al, rev_ascii_decimal<br />		add al, 30h<br />		mov rev_ascii_decimal, al<br />		inc bx<br />		loop convertdecloop<br /><br />		mov ax, 0<br />		mov bx, 0<br />		mov cx, dec_len<br />		;mov bx, dec_len<br />		decimalloop:<br />		mov ah, 02h<br />		mov dl, rev_ascii_decimal<br />		int 21h<br />		inc bx<br />		loop decimalloop<br /><br />		call print_new_line<br />		call print_binary_output<br />	print_decimal_output endp<br /><br />	;prints the binary equivalent of the number<br />	print_binary_output proc<br />		mov dx, offset outputBinary<br />		mov ah, 9h<br />		int 21h<br /><br />		mov dx, offset outputSign<br />		mov ah, 02h<br />		int 21h<br /><br />		mov bx, 0<br />		mov ax, finalAnswer<br />		convertbinloop:<br />		mov cl, 2<br />		div cl<br />		cmp ah, 0<br />		je zerobin<br />		mov rev_ascii_binary,&quot;1&quot;<br />		zerobin:<br />		mov rev_ascii_binary,&quot;0&quot;<br />		nextbin:<br />		inc bx<br />		cmp bx, bin_len<br />		je endbinary<br />		jmp convertbinloop<br /><br />		endbinary:<br />		;mov bx, bin_len<br />		;mov bx, 4<br />		mov rev_ascii_binary,&quot;$&quot;<br />		;mov ax, 0<br />		mov bx, 4<br />		;mov cx, bin_len<br />		mov cx, 4<br />		;mov bx, bin_len<br /><br />		binaryloop:<br />		mov ah, 02h<br />		mov dl, rev_ascii_binary<br />		int 21h<br />		dec bx<br />		loop binaryloop<br /><br />		call print_new_line<br />		ret<br />		;call print_octal_output<br />	print_binary_output endp<br /><br />	;prints the octal equivalent of the answer<br />	print_octal_output proc<br />		mov dx, offset outputOctal<br />		mov ah, 9h<br />		int 21h<br /><br />		mov ax, finalAnswer<br />		convertoctloop:<br />		mov cl, 16<br />		div cl<br />		cmp ah, 0<br />		je zerooct<br />		mov rev_ascii_octal, &quot;1&quot;<br />		jmp nextoct<br />		zerooct:<br />		mov rev_ascii_octal, &quot;0&quot;<br />		nextoct:<br />		inc bx<br />		cmp bx, oct_len<br />		je endoct<br />		jmp convertoctloop<br />		endoct:<br />		mov rev_ascii_octal,&quot;$&quot;<br /><br />		mov ax, 0<br />		mov bx, 0<br />		mov cx, oct_len<br />		mov bx, oct_len<br />		octalloop:<br />		mov ah, 02h<br />		mov dl, rev_ascii_octal<br />		int 21h<br />		inc bx<br />		loop octalloop<br /><br />		call print_new_line<br />		call print_hex_output<br />	print_octal_output endp<br /><br />	;prints the hexidecimal equivalent of the number<br />	print_hex_output proc<br />		mov dx, offset outputHex<br />		mov ah, 9h<br />		int 21h<br />		mov ax, finalAnswer<br />		mov bx, 0<br />		converthexloop:<br />		mov cl, 16<br />		div cl<br />		cmp ah, 0<br />		je zerohex<br />		mov rev_ascii_hexadecimal, &quot;1&quot;<br />		jmp nexthex<br />		zerohex:<br />		mov rev_ascii_hexadecimal, &quot;0&quot;<br />		nexthex:<br />		inc bx<br />		cmp bx, hex_len<br />		je endhex<br />		jmp converthexloop<br />		endhex:<br />		mov rev_ascii_hexadecimal,&quot;$&quot;<br /><br />		mov ax, 0<br />		mov cx, hex_len<br />		mov bx, hex_len<br />		hexadecimalloop:<br />		mov ah, 02h<br />		mov dl, rev_ascii_hexadecimal<br />		int 21h<br />		inc bx<br />		loop hexadecimalloop<br /><br />		call end_program<br />	print_hex_output endp<br /><br />	;prints a new line<br />	print_new_line proc<br />		mov dx, offset newline<br />		mov ah, 09h<br />		int 21h<br />		ret<br />	print_new_line endp<br /><br />	check_if_alpha proc<br />		push ax<br />		and al, 11011111b<br />		cmp al, &#039;A&#039;<br />		jb B1<br />		cmp al, &#039;Z&#039;<br />		ja B1<br />		test ax, 0<br />		B1: pop ax<br />		ret<br />	check_if_alpha endp<br /><br />	check_if_digit proc<br />		cmp al, &#039;0&#039;<br />		jb A1<br />		cmp al, &#039;9&#039;<br />		ja A1<br />		test ax, 0<br />		A1: ret<br />	check_if_digit endp<br /><br />	;terminates the program<br />	end_program proc<br />		mov ah, 4ch<br />		int 21h<br />	end_program endp<br />	<br />	main proc<br />		mov ax, @data<br />		mov ds, ax<br /><br />		call setcolors<br /><br />		start_program:<br />		call prompt_for_input<br />		call print_new_line<br /><br />		mov dx, offset inputData<br />		mov ah, 09h<br />		int 21h<br /><br />		call isalpha<br /><br />		call print_new_line<br /><br />		call get_operators_and_operands<br /><br />		call convert_operands_to_decimal<br /><br />		call check_operator<br /><br />		call print_decimal_output<br />		call end_program<br />		<br />	main endp<br /><br />end main </code></pre> </div>
    <div class="meta">Posted on 2011-10-07 07:53:43 by 77nevaeh</div>
   </div>
   <div class="post" id="post-215151">
    <div class="subject"><a href="#post-215151">Re: 16-bit calculator</a></div>
    <div class="body">What&#039;s it do? Or not do?<br /><br />As a general rule, when you&#039;re asking for help with code, it&#039;s a good idea to mention what OS (obvious, in this case), what assembler (also obvious, I guess), what command line you gave the assembler (and the linker, if applicable), what you &quot;expect&quot; it to do (obvious, I guess), and what happened instead. Narrow it down, so we know where to look...<br /><br />This looks like &quot;homework&quot;. We&#039;ll &quot;help&quot; with homework, but we don&#039;t want to &quot;cheat&quot; you by allowing you to &quot;not learn assembly language&quot;! Expect &quot;hints&quot;, rather than a finished solution...<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2011-10-07 10:11:22 by fbkotler</div>
   </div>
   <div class="post" id="post-215152">
    <div class="subject"><a href="#post-215152">Re: 16-bit calculator</a></div>
    <div class="body">i doesn&#039;t convert the ascii to decimal and when i input 32+1<br />the output is &quot;32+1 invalid input, please enter a valid one.&quot;<br /><br />we use TASM as the compliler.<br /><br />the input suppose to be a string (expression) and can do the mdas.<br />ex..<br />input: 32+1<br />output: 33</div>
    <div class="meta">Posted on 2011-10-07 10:19:14 by 77nevaeh</div>
   </div>
   <div class="post" id="post-215154">
    <div class="subject"><a href="#post-215154">Re: 16-bit calculator</a></div>
    <div class="body">Something that looks a little &quot;suspicious&quot; to me is your &quot;start_operand1:&quot;... It looks for a space to indicate the end of the first operand. If it doesn&#039;t find a space, it keeps going. The first space it finds may be in &quot;DECIMAL: $&quot;... Try entering a space between &quot;32&quot; and &quot;+&quot;, and see if that helps... If it does, you might need to prompt &quot;always enter a space...&quot;, or you might want to modify &quot;start_operand1&quot; to catch this situation.<br /><br />I&#039;m not conveniently able to actually test your code at the moment, so I&#039;m trying to read through it and &quot;think like a CPU&quot;. No guarantee I&#039;m right, but that&#039;s the first thing that &quot;looks funny&quot;.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2011-10-07 12:11:02 by fbkotler</div>
   </div>
  </div>
 </body>
</html>