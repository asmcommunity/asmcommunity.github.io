<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Quickk reference to MMX/SSE/SSE2 ... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=3708" />
    <link rel="next" href="../?id=3708&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=3708">Quickk reference to MMX/SSE/SSE2 ...</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=3708&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=3708&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="3708" /><input type="number" name="page" min="1" max="5" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=3708&amp;page=2">&gt;</a><a href="../?id=3708&amp;page=5">&raquo;</a></form>   <div class="post" id="post-24875">
    <div class="subject"><a href="#post-24875">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body">Hello, a pure assembly contirb.<br /><br /><a target="_blank" href="http://docs.tommesani.com/">http://docs.tommesani.com/</a><br /><br />Very cool reference to the MMX/SSE/SSE2<br />instructions set and some performace<br />compares between AMD/PIII/PIV</div>
    <div class="meta">Posted on 2002-02-18 13:05:25 by marsface</div>
   </div>
   <div class="post" id="post-24889">
    <div class="subject"><a href="#post-24889">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body">Has anybody some hands on experience with MMX-Code on P4 (in comparison to MMX-code on PMMX,P2,P3)?<br /><br />Does the increased latency on P4 slow down mmx-code considerably?<br /><br />Is it true, that (2x) 64bit mmx on P3 ist faster than 128bit mmx on P4?<br /><br /><br />VShader</div>
    <div class="meta">Posted on 2002-02-18 14:18:48 by VShader</div>
   </div>
   <div class="post" id="post-24948">
    <div class="subject"><a href="#post-24948">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body">Great Reference!<br />I learnt more from this site than from any other source!:alright: <br /><br />Dig</div>
    <div class="meta">Posted on 2002-02-18 22:34:50 by dig</div>
   </div>
   <div class="post" id="post-24952">
    <div class="subject"><a href="#post-24952">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body"><strong>VShader</strong>, I haven't coded on a P4, but you have to understand the whole pipeline - latency is just one factor.  MMX code is usually used in a loop to process much data - even with high latency the instructions will execute in parallel if there are execution units.  The Athlon can execute 2 MMX instructions in parallel (it would be three, but only eight bytes can be decoded at once and MMX instructions are too long).  I'm assuming the P4 has similar technology behind it.</div>
    <div class="meta">Posted on 2002-02-18 23:05:37 by bitRAKE</div>
   </div>
   <div class="post" id="post-25017">
    <div class="subject"><a href="#post-25017">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body">I asked because of this 3 passages in  the link above:<br /><br /><br />1) ?Assuming that we should have P4s running at 2 GHz and more pretty soon, I would not worry about the doubling in latency of most MMX instructions. But the multiply instructions' latency (PMADDWD / PMULHW / PMULLW) jumped from 3 cycles in the P6 core to 8 cycles in the Pentium 4! This will affect all convolutional kernel codes that are widely used, for example, in audio applications. Another troublesome latency is MOVQ's 6 cycles versus only 1 cycle on the P6 core, given that is widely used to move memory blocks and copy results. ?<br /><br />2) ?But troubles do not stop here. The image above outlines how instructions are addressed to specific ports in the P4 execution engine. All MMX instructions are queued in Port 1! This is major drawback compared to the P6 Core, in which most MMX instructions could be issued to Port 0 or Port 1. ?<br /><br />3) ?Summing up, the P4 can issue only one MMX instruction per cycle, and the latency is at best twice that on the older Pentium III processor. In pathological conditions, this adds up to bring P4's SIMD performance down to about one third P-III's. Until the P4 ramps up into the 2+ GHz frequency range, its integer SIMD execution speed will simply lag behind the venerable P6 core.<br />&quot;<br /><br />Because I want to compare some realworlddata I did a test on my P200mmx.<br /><br />It would be nice if we can get the numbers for P2,P3,P4 and AMD.<br />Don?t forget to put in &quot;YourMachine_Hz&quot; the Hz of your machine.<br /><br />Here is the loop:<br /><br /><br /><br /><span style="font-size:9px><br /><br />;TSC_MyTest    dq 0<br />;----------------<br /><br />TSC_ReadOut_NegStore_Makro MACRO TSCounter_mem  ;64 bit Counter x (-1) und speichern<br />            rdtsc<br />            not eax<br />            not edx<br />            add eax,1<br />            adc edx,0<br />            mov dword ptr TSCounter_mem,   eax<br />            mov dword ptr TSCounter_mem+4, edx<br />ENDM<br /><br />TSC_ReadOut_AddStore_Makro MACRO TSCounter_mem  ;64 bit Counter auf vorher negiert<br />            rdtsc                               ;abgelegten Counter addieren -&gt;<br />            add dword ptr TSCounter_mem,   eax  ;Ergibt die positive Differenz<br />            adc dword ptr TSCounter_mem+4, edx<br />ENDM<br /><br /><br /><br /><br />TSCReadOut_NegStore_Makro TSC_MyTest<br />pushad<br /><br />;get pointers to parameters<br />  ;mov eax,+ 4		;eax = ptr to matrix<br />  ;mov	ebx,+ 8		;ebx = ptr to vector<br />mov ecx, 5000000 ;original: mov	ecx,+12 ;ecx = numvec<br />                 ;3D-transform 5.000.000 16bit-points<br />  ;mov	edx,+16		;edx = ptr to result<br /><br />;Load entire 3x4 matrix<br />  ;original: movq	mm0, 0		;Matrix row 0 (4 16-bit elements)<br />  ;original: movq	mm1, 8		;Matrix row 1 (4 16-bit elements)<br />  ;original: movq	mm2,16		;Matrix row 2 (4 16-bit elements)<br /><br />mov eax, 012345678h<br />movd mm0, eax<br />add eax, eax<br />movd mm1, eax<br />add eax, eax<br />movd mm2, eax<br /><br />add eax, eax<br />movd mm7, eax  ;mm7: get all sourcevectors from this register<br /><br /><br />NextVect:<br />    movq	mm3, mm7  ;original: movq	mm3, <br />    movq	mm4, mm3<br />    pmaddwd	mm3, mm0<br />    movq	mm5, mm4<br />    pmaddwd	mm4, mm1<br />    pmaddwd	mm5, mm2<br />    add	ebx, 8<br />    movq	mm6, mm3<br />    psrlq	mm3, 32<br />    paddd	mm3, mm6<br />    movq	mm6, mm4<br />    psrlq	mm4, 32<br />    add	edx, 8<br />    psrad	mm3, 13<br />    paddd	mm4, mm6<br />    psrad	mm4, 13<br />    movq	mm6, mm5<br />    psrlq	mm5, 32<br />    punpcklwd mm3, mm4<br />    paddd	mm5, mm6<br />    psrad	mm5, 13<br />    movd eax, mm3 ;original: movd	, mm3<br />    movd eax, mm5 ;original: movd	, mm5<br />    dec	ecx<br />    jnz	NextVect<br /><br />	;Total Cycles: 		15<br /><br /><br />TSCReadOut_AddStore_Makro TSC_MyTest<br /><br /><br /><br />YourMachine_Hz = 200000000 ; Hz of your machine<br />mov eax, YourMachine_Hz<br />mov ebx, 1000<br />sub edx,edx<br />div ebx<br />mov ecx, eax<br />sub edx,edx<br />mov eax, dword ptr TSC_MyTest<br /><br />mov ebx, eax ; In ebx are now the number of cycles taken<br />             ;   for 3D-transforming 5.000.000 16bit vectors<br />div ecx<br />mov ecx, eax ; In ecx are now the milliseconds<br />             ;   for 3D-transforming 5.000.000 16bit vectors<br /><br />sub edx,edx<br />mov eax, ebx<br />push 5000000<br />div dword ptr  ; In eax are now number of cycles per transformed mmx-vector<br />pop edx<br /><br /><br /><br />emms<br />popad<br /><br /><br />;----------------<br /> <br /></span> <br /><br />My numbers are (Pentium MMX 200 MHz):<br /><br />eax: 15 <br />ebx: 75.420.591 <br />ecx: 377 <br /><br /><br /><br />VShader</div>
    <div class="meta">Posted on 2002-02-19 10:39:26 by VShader</div>
   </div>
   <div class="post" id="post-25026">
    <div class="subject"><a href="#post-25026">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body">Yes, it does sound like the case to P4 isn't that good.  My Athlon has a latency of 4 cycles for PMULx.  I will test when I get home later.  I would like to state again that if the dependancy for the results of these operations are pushed back far enough, then the latency doesn't effect the code.  My alpha blend code is fastest on the Athlon, two cycles more on the P3, and untested on P4.  Another thing is that the Athlon/P4 will execute instructions out-of-order, but that doesn't mean it couldn't use some help from the programmer.  ;)<br /><br /><span style="font-size:9px>(P4 would benefit from an SSE2 version of the above.)</span></div>
    <div class="meta">Posted on 2002-02-19 11:21:18 by bitRAKE</div>
   </div>
   <div class="post" id="post-25115">
    <div class="subject"><a href="#post-25115">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body"><u>My numbers are (Athlon 1334 MHz)</u>:<br />eax: <strong>13</strong> <br />ebx: <strong>65.522.762</strong> <br />ecx: <strong>49</strong> :grin: <br /><br />Now it would be interesting to see if we can optimize this, both for the general case and for processor specific case.  If you can find a way around using MOVD - load/store using only MOVQ - then you'll get better performance in actual use.  Also, if you can find a way to process the vectors in batches that remain in the cache during all operations on the vectors, then you should see a boost in speed on faster processors.<br /><br />To give you an idea of how memory bound 2Ghz processors are:  The AMD optimized memcpy is able to move 1.63 GBytes with a 1GHz processor &amp; DDR2100 memory, and there is no speed increase with a 1.6GHz processor - the faster processor spends over half the time waiting on memory.  This is a best case, where the data move to/from memory has been optimized.  In the majority of code things will be much worse if data isn't handled in batches that fit within the cache.<br /><br /><strong>Note</strong>: I did notice that the algo above is exactly the same as the Intel MMX code.  Their code is often not the best possible - even on their own processors.  I think a couple clocks could be saved within the loop? (haven't spent much time with it.)<br /><br /><u>Here are papers reguarding the algo</u>:<br /><a target="_blank" href="http://www.cs.umbc.edu/~rrhudy2/611paper.htm">http://www.cs.umbc.edu/~rrhudy2/611paper.htm</a><br /><a target="_blank" href="http://library.cs.tuiasi.ro/hardware/mmx/appnotes/ap541.htm">http://library.cs.tuiasi.ro/hardware/mmx/appnotes/ap541.htm</a></div>
    <div class="meta">Posted on 2002-02-19 21:03:11 by bitRAKE</div>
   </div>
   <div class="post" id="post-25134">
    <div class="subject"><a href="#post-25134">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body">Hasn't been tested, but I think that this code:<pre><code>movq	mm6,mm3		;add row0 high and low order 32-bit results<br />psrlq	mm3,32		;<br />paddd	mm3,mm6		;<br />movq	mm6,mm4		;add row1 high and low order 32-bit results<br />psrlq	mm4,32		;<br />psrad	mm3,15-2	;Shift 32 to 16; also app. specific &lt;&lt;2<br />paddd	mm4,mm6		;<br />psrad	mm4,15-2	;Shift 32 to 16; also app. specific &lt;&lt;2<br />punpcklwd mm3,mm4	;Copy word0 of mm4 into word0 of mm3<br />movd	&#91;eax&#93;-8+0,mm3	;Store 1st and 2nd elements, one 32-bit write</code></pre>Should be replaced by this code!:<pre><code>; mm3 = A1 A2<br />; mm4 = B1 B2<br />movq mm6,mm3 ; A1 A2<br />punpckldq mm3,mm4	; B2 A2<br />punpckhdq mm6,mm4	; B1 A1<br />paddd mm3,mm6		; B1+B2 A1+A2<br />psrad mm3,15-2		; scale dwords back to signed fixed point<br />packssdw mm3,mm3	; pack dwords into words<br />movd	&#91;eax&#93;-8+0,mm3	;Store 1st and 2nd elements, one 32-bit write</code></pre>If someone from Intel is browsing the forum:<br />I wouldn't mind doing this for a living!  ;)</div>
    <div class="meta">Posted on 2002-02-20 00:31:01 by bitRAKE</div>
   </div>
   <div class="post" id="post-25144">
    <div class="subject"><a href="#post-25144">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body">When you test CPUs relative performances, make sure you're not using memory, or at least that all is in the cache.. otherwise a Pentium60 will look faster than a Athlon1400.. cycles-wise.<br /><br />I recall once a guy who was extremely pissed off because the OUT instruction took 20 times more to execute on the latter than on the former. I leave to you the comments. ;)<br /><br />Greets,<br />Maverick</div>
    <div class="meta">Posted on 2002-02-20 05:00:06 by Maverick</div>
   </div>
   <div class="post" id="post-25188">
    <div class="subject"><a href="#post-25188">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body">bitRAKE,<br />your code is correct, I put it in my 3D-engine.<br /><br />There are 3 instructions less than in the original mmx-transform-loop from intel, but I spend halve a hour of reordering the instructions but could not get it really faster (imperfect pairing?, mmx-shift instructions can not pair ?!)<br /><br />Perhaps on a other machine than my old PMMX it looks better. How is it on your Athlon?<br /><br /><br />VShader<br /><br /><br />btw: Nobody with a P4 and MASM here?</div>
    <div class="meta">Posted on 2002-02-20 13:35:47 by VShader</div>
   </div>
   <div class="post" id="post-25193">
    <div class="subject"><a href="#post-25193">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body">I will test and follow-up later, but I wanted to inquire if you had tested it again in the above method? ...and your results?  There most likely will be no perceived speed increase in actual use without prefetch of data into cache.  Also you will be able to save another two instructions by combining the pack/store. ;)  You should notice a speed increase by eliminating one of the stores: see note about MOVD above.</div>
    <div class="meta">Posted on 2002-02-20 14:12:27 by bitRAKE</div>
   </div>
   <div class="post" id="post-25214">
    <div class="subject"><a href="#post-25214">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body">Yes, I benched with real data in my engine.<br /><br />With reading from mm7 instead from memory:<br />Here are the cycles per loop for intel-code and your modification on my P200mmx:<br /><br /><br /><span style="font-size:9px><br /><br />IF 0 ;intel<br /><br />NextVect:<br />    movq        mm3, mm7  ;original: movq       mm3,   ;<br /><br />    movq        mm4, mm3<br />    pmaddwd     mm3, mm0  ;<br /><br />    movq        mm5, mm4<br />    pmaddwd     mm4, mm1  ;<br /><br />    pmaddwd     mm5, mm2<br />    add ebx, 8            ;<br /><br />    movq        mm6, mm3<br />    psrlq       mm3, 32   ;<br /><br />    paddd       mm3, mm6<br />    movq        mm6, mm4  ;<br /><br />    psrlq       mm4, 32<br />    add edx, 8            ;<br /><br />    psrad       mm3, 13<br />    paddd       mm4, mm6  ;<br /><br />    psrad       mm4, 13<br />    movq        mm6, mm5  ;<br /><br />    psrlq       mm5, 32   ;<br /><br />    punpcklwd mm3, mm4<br />    paddd       mm5, mm6  ;<br /><br />    psrad       mm5, 13   ;<br /><br />    movd eax, mm3 ;original: movd , mm3  ;<br /><br />    movd eax, mm5 ;original: movd , mm5  ;<br /><br /><br />    dec ecx<br />    jnz NextVect  ;<br /><br /><br />ELSE ;bitRAKE modification (the right one...)<br /><br /><br />    NextVect:<br />    movq mm3, mm7 ;original movq mm3,   ;<br /><br />    movq        mm4, mm3  ;<br />    pmaddwd     mm3, mm0  ;<br /><br />    movq        mm5, mm4  ;<br />    pmaddwd     mm4, mm1  ;<br /><br />    pmaddwd     mm5, mm2  ;<br />    add ebx, 8            ;<br /><br />    movq mm6,mm3          ;<br />    add edx, 8            ;<br /><br />    punpckhdq mm6,mm4     ;<br /><br />    punpckldq mm3,mm4     ;<br /><br />    paddd mm3,mm6         ;<br />    movq mm6, mm5         ;<br /><br />    psrad mm3,AnzNKomma   ;<br /><br />    packssdw mm3,mm3      ;<br /><br />    psrlq mm5, 32         ;<br /><br />    paddd mm5, mm6        ;<br /><br />    psrad mm5, AnzNKomma  ;<br /><br />    punpckldq mm3,mm5<br />    dec ecx               ;<br /><br />    movq mm4, mm3         ;original: movq , mm3<br />    jnz NextVect          ;<br /><br />ENDIF<br /><br /><br /></span> <br /><br /><br /><br /><br />Can you give me a hint how to prefetch the points efficient to 1LevelCahe on my machine (EDO-Ram)?<br /><br /><br /><br />VShader<br /><br />Edit: Put in the right piece of code. I just don't understand the concept of COPY and PASTE!</div>
    <div class="meta">Posted on 2002-02-20 17:51:37 by VShader</div>
   </div>
   <div class="post" id="post-25245">
    <div class="subject"><a href="#post-25245">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body"><strong>VShader</strong>, both those sections of code are the same.<br />I would expect similar results from them on same CPU. :)</div>
    <div class="meta">Posted on 2002-02-20 22:34:33 by bitRAKE</div>
   </div>
   <div class="post" id="post-25256">
    <div class="subject"><a href="#post-25256">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body">Here is the pretty looking loop I came up with, but I can't get<br />it faster than 19 cycles!  And I don't know why?  I replaced the<br />moves like in your test code above.  I'll go sit in the corner<br />until I figure this out. :)<pre><code>NextVect&#58;<br />	; Load vector &#40;4 16-bit elements&#41; into reg<br />	movq	mm3,&#91;edx + ecx*8&#93;<br />;-<br /><br />	movq	mm4,mm3		;copy to other regs for use by 3 pmadds<br />	pmaddwd	mm3,mm0		;multiply row0 X vector<br /><br />	movq	mm5,mm4<br />	pmaddwd	mm4,mm1		;multiply row1 X vector<br /><br />	movq	mm6,mm3		; A1 A2<br />	pmaddwd	mm5,mm2		;multiply row2 X vector<br /><br />	punpckldq mm3,mm4	; B2 A2<br />	punpckhdq mm6,mm4	; B1 A1<br /><br />	movq	mm4,mm5		;add row2 high and low order 32-bit results<br />	psrlq	mm5,32<br /><br />	paddd	mm3,mm6		; B1+B2 A1+A2<br />	paddd	mm5,mm4<br /><br />	psrad	mm3,NUMBER_SCALE-2<br />	psrad	mm5,NUMBER_SCALE-2<br /><br />	packssdw mm3,mm5	; pack dwords into words<br />	dec	ecx<br /><br />	movq	&#91;eax + ecx*8&#93;,mm3 ; store resulting vector<br />	jnz	NextVect	;then loop back to do the next one.</code></pre><strong>Edit</strong>: I figured it out - these dummy test runs don't work on out-of-order processors.  The dummy moves to MM7 were working against the internal optimizers within the core of the processor, and costing 6 cycles!  I've got the execution down to 12 cycles, but I need to make a better test app - it should be lower, IMO.  The Athlon can execute almost all MMX instructions in parallel:<div class="quote">The AMD Athlon processor floating-point logic is a<br />high-performance, fully-pipelined, superscalar, out-of-order<br />execution unit. It is capable of accepting three MacroOPs of any<br />mixture of x87 floating-point, 3DNow! or MMX operations per<br />cycle.</div>To execute three MMX instructions in parallel one would have to be a load/store, and only one could be a multiply - any combination that follows those guidelines should work if there aren't any forward dependencies.</div>
    <div class="meta">Posted on 2002-02-21 00:47:46 by bitRAKE</div>
   </div>
   <div class="post" id="post-25266">
    <div class="subject"><a href="#post-25266">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body">Here is a RadASM Project that outputs to a debug window (<strong>vkim</strong>'s).  This show's &lt;11.5 cycles per vector for 1024 vectors (src/dest in the cache).  Please try this on your machine if you can, else let me know what your working with and I'll see what I can do.  These figures fall inline with what I expect.<br /><br />As to prefeching on your CPU:  that just consists of 'touching' (load) of memory in the next cache line.  I don't think it's going to matter with 200Mhz.  The above algo should be faster none the less. :)<br /><br /><strong>Edit</strong>:  I have it at 10 cycles for Athlon!  I'm guessing your CPU will weigh in at 11 concidering I got rid of all but two shifts! :)  Let me know if I broke the algo? :eek:<br /><br /><strong>Edit Again</strong>: I think the: <strong>punpckldq mm5,mm5</strong> should be <strong>punpckhdq mm5,mm5</strong>?  And you might have to mask off the high word of the MM3 before it is stored, if you need that value zero?  Okay, my final guess is 12 cycles on your CPU.  I'll test on a P3 tomorrow at work.</div>
    <div class="meta">Posted on 2002-02-21 02:25:58 by bitRAKE</div>
   </div>
   <div class="post" id="post-25272">
    <div class="subject"><a href="#post-25272">instruction sets</a></div>
    <div class="body">Hi all, <br />           I have sent before a link for the microsoft reference for processors at the thread:<a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=2587">Instruction set</a> <br />you will find a link for microsoft website where you can download the help file for the processor instruction set. It contain MMX/SSE/SSE2 instructions and there reference and compares between AMD and INTEL processors. It contains also the 3Dnow instruction set try it and tell me your opinion. <br />Thanks</div>
    <div class="meta">Posted on 2002-02-21 03:11:50 by amr</div>
   </div>
   <div class="post" id="post-25294">
    <div class="subject"><a href="#post-25294">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body"><strong>amr</strong>, there is no documentation at that link:<div class="quote">The Visual C++ 6.0 Processor Pack provides intrinsic support for enhanced instruction sets supported by Intel and Advanced Micro Devices (AMD) processors. The instructions sets supported are Intel's Pentium III new instruction sets (Streaming SIMD Extensions ) and Intel's Pentium 4 new instruction sets (Streaming SIMD Extensions 2 ) as well as AMD's 3DNow! Instruction sets.</div>This is an add-on for VC++ that allows you to use the additional instructions of newer processors.  The version of ML.EXE I'm using has this support. Your statements are false, <strong>amr</strong>.  No help file, no reference for processors?  Or is there something I mis-understand?</div>
    <div class="meta">Posted on 2002-02-21 08:06:56 by bitRAKE</div>
   </div>
   <div class="post" id="post-25322">
    <div class="subject"><a href="#post-25322">Neat, isn't it..</a></div>
    <div class="body">VectorC *online* compiler:<br /><br /><a target="_blank" href="http://www.codeplay.com/vectorc/demo-compiler.html">http://www.codeplay.com/vectorc/demo-compiler.html</a> <br /><br />Greets,<br />Maverick</div>
    <div class="meta">Posted on 2002-02-21 10:22:34 by Maverick</div>
   </div>
   <div class="post" id="post-25323">
    <div class="subject"><a href="#post-25323">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body"><strong>Maverick</strong>, that's cool, but don't you have to learn the compiler switches and stuff to produce really good code?  Guess I'll have to try it out...<br /><br />The algo above is ~12 cycles on P3.</div>
    <div class="meta">Posted on 2002-02-21 10:35:49 by bitRAKE</div>
   </div>
   <div class="post" id="post-25324">
    <div class="subject"><a href="#post-25324">Quickk reference to MMX/SSE/SSE2 ...</a></div>
    <div class="body">Hi pal:)<br /><br />Well, I would have expecially adviced to download the stand-alone executable demo.. but it's not available anymore (hopefully will be again).. so all that remains to play with is the online compiler. Dunno about the switches.. sure the real product has an *interactive* optimizer, which on the online compiler is not present.. I guess this says all though. ;)<br /><br />Greets,<br />Mav</div>
    <div class="meta">Posted on 2002-02-21 10:42:35 by Maverick</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=3708&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=3708&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="3708" /><input type="number" name="page" min="1" max="5" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=3708&amp;page=2">&gt;</a><a href="../?id=3708&amp;page=5">&raquo;</a></form>  </div>
 </body>
</html>