<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>fsin/fcos deg or rad? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=15978" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=15978">fsin/fcos deg or rad?</a></p>
   <div class="post" id="post-123825">
    <div class="subject"><a href="#post-123825">fsin/fcos deg or rad?</a></div>
    <div class="body">I'm finding better results working on various projects for my 2D engine, citing necessity is the mother of invention (or re-invention) - rather than lay out specific functions and try to test them.. anyway my question is:<br /><br />I'm working on a simple 'cannon-ball physics' type game, and I can never keep this straight:<br /><br />Do my angles need to be expressed in degrees or radians?<br /><br />An observation from an FPU tutorial from Raymond Filiatreault's site.. It makes sense but I didn't know you could do:<br />add esp,4   instead of pop  to keep from trashing it the current register.. that is too kewlll... <br />then if I sub esp,4 do I mov esp,value?<br />   <br />Thnx.</div>
    <div class="meta">Posted on 2003-11-08 13:18:31 by drarem</div>
   </div>
   <div class="post" id="post-123829">
    <div class="subject"><a href="#post-123829">fsin/fcos deg or rad?</a></div>
    <div class="body">Angles should be in radians. You know you could just have tried both and see which worked.</div>
    <div class="meta">Posted on 2003-11-08 14:46:31 by EÃ³in</div>
   </div>
   <div class="post" id="post-123830">
    <div class="subject"><a href="#post-123830">fsin/fcos deg or rad?</a></div>
    <div class="body">ty - well I am already working with one unknown and I try to keep those to a minimum.<br /><br />rewrite the first unknown 10 times ten different ways only to find out I had the second unknown wrong, at that would have been an easy fix...</div>
    <div class="meta">Posted on 2003-11-08 14:55:57 by drarem</div>
   </div>
   <div class="post" id="post-123847">
    <div class="subject"><a href="#post-123847">fsin/fcos deg or rad?</a></div>
    <div class="body"><div class="quote">?The angle must be expressed in radians</div>is clearly specified in the first paragraph of the description for each of the fsin, fcos, fsincos and ftptan instructions in the quoted tutorial.<br /><br />You can keep track of your angles in degrees (which I personally do most of the time) but you then have to convert them to radians before using them with the above trig instructions. The conversion is also explained in the tutorial.<br /><br />As for the <strong>add esp,4</strong>, POPing the stack effectively adds 4 to the ESP register after retrieving the value at  into a register or a memory variable. If that value is useless, modifying directly the ESP avoids the trashing of a commodity.<br /><br />The <strong>sub esp,4</strong> would only reserve space on the stack without modifying the content of that space. You would often see a similar instruction generated by an assembler for LOCAL variables in a procedure.<br /><br />Raymond</div>
    <div class="meta">Posted on 2003-11-08 22:34:59 by Raymond</div>
   </div>
   <div class="post" id="post-123887">
    <div class="subject"><a href="#post-123887">fsin/fcos deg or rad?</a></div>
    <div class="body">alright, I've tried several times to get it right, I am close but still no cigar...<br /><br /><br />in pseudocode, this is what I need:<br /><br />.for ex = 0 to 120<br />vx=vo*cos(a*pi/180)<br />vy=vo*sin(a*pi/180)<br />vy=vy + (-0.0000981*ex*ex)      ;ex is the current time increment, for gravity's sake<br /><br />x=x+vx<br />y=y-vy<br />plot x,y<br /><br />next ex<br /><br /><br /><br />definitions:<br /><br /><pre><code><br />.data<br />blax  REAL4 0.0<br />blay  REAL4 0.0  ;coords x/y for flight of ball<br /><br />PIdiv180 REAL4 0.0174533<br />angl  REAL4 15.0 ;angle of descent<br />cspd  REAL4 1.2<br />gravity REAL4 -0.0000981<br />VX     REAL4 0.0 ;horizontal velocity = CSPD * cos&#40;angl&#41;<br />VY     REAL4 0.0 ;vertical velocity = CSPD * sin&#40;angl&#41;<br />ex	   REAL4 0.0<br /></code></pre><br /><br /><br />... and code:<br /><pre><code><br />		finit<br />		fild angl<br />		fimul PIdiv180<br />		fcos<br />		fmul cspd<br />		fistp VX<br />		<br />		fild angl<br />		fimul PIdiv180<br />		fsin<br />		fmul cspd<br />		fistp VY<br /><br />		fild ex<br />		fimul ex<br />		fmul gravity     <br />		fistp vy<br /><br />   ;gravity seems to be working ok, the angle don't fly.. 15 shoots it at 45<br />   ; and 45 shoots it straight up in the air   <br /><br />		<br />		mov eax,vy<br />		add VY,eax<br /><br />		add ex,1<br />		<br />		mov eax,VX<br />		add eax,1<br />		add blax,eax<br /><br />		mov eax,VY<br />		sub blay,eax<br /><br />                                 invoke PlotPixel, blax, blay<br /><br /></code></pre></div>
    <div class="meta">Posted on 2003-11-09 16:06:30 by drarem</div>
   </div>
   <div class="post" id="post-123902">
    <div class="subject"><a href="#post-123902">fsin/fcos deg or rad?</a></div>
    <div class="body"><pre><code><br />		finit<br />		&#91;COLOR=red&#93;fild angl&#91;/COLOR&#93;<br />		&#91;COLOR=red&#93;fimul PIdiv180&#91;/COLOR&#93;<br />		fcos<br />		fmul cspd<br />		&#91;COLOR=red&#93;fistp VX&#91;/COLOR&#93;<br />		<br />		&#91;COLOR=red&#93;fild angl&#91;/COLOR&#93;<br />		&#91;COLOR=red&#93;fimul PIdiv180&#91;/COLOR&#93;<br />		fsin<br />		fmul cspd<br />		&#91;COLOR=red&#93;fistp VY&#91;/COLOR&#93;<br /><br />		&#91;COLOR=red&#93;fild ex<br />		fimul ex&#91;/COLOR&#93;<br />		fmul gravity     <br />		&#91;COLOR=red&#93;fistp vy&#91;/COLOR&#93;<br /><br />   ;gravity seems to be working ok, the angle don't fly.. 15 shoots it at 45<br />   ; and 45 shoots it straight up in the air   <br /><br />		<br />		mov eax,vy<br />		add VY,eax<br /><br />		add ex,1<br />		<br />		mov eax,VX<br />		add eax,1<br />		add blax,eax<br /><br />		mov eax,VY<br />		sub blay,eax<br /><br />                                 invoke PlotPixel, blax, blay</code></pre><br /><br />There is a bunch of stuff going wrong here.  All your memory is defined as IEEE floating point however your intructing your FPU to treat the memory as registered memory (integers).  This can not be good!...<br /><br />I would try this for your PSEUDO code (i didnt test this):<pre><code><br /><br />.data<br />   PI_by_180   REAL4    0.0174533<br />   Gravity     REAL4    -0.0000981<br />   <br />.data?<br />   Angle       REAL4    ?<br />   Vo          REAL4    ?<br />   Vx          REAL4    ?<br />   Vy          REAL4    ?<br /><br /><br />PlotFunct PROC uses ebx esi edi integer_Vo&#58;DWORD, integer_degrees&#58;DWORD, integer_X&#58;DWORD, interger_Y&#58;DWORD<br />   LOCAL ex          &#58;DWORD<br />   LOCAL int_X       &#58;DWORD<br />   LOCAL int_Y       &#58;DWORD<br />   LOCAL TempAngle   &#58;REAL4<br />   <br />   ; Set initial values<br />   finit<br />   <br />   ; Init Pixel positions<br />   ;_____________________<br />   mov eax, integer_X<br />   mov int_X, eax<br /><br />   mov eax, integer_Y<br />   mov int_Y, eax<br />   <br />   ; Vo = &#40;REAL4&#41; interger_Vo<br />   ;_________________________<br />   lea edx, Vo   <br />   fild  integer_Vo<br />   fstp  REAL4 PTR &#91;edx&#93;<br />   <br />   ; Angle = &#40;REAL4&#41; integer_Angle<br />   ;______________________________<br />   lea edx, Angle<br />   fild  integer_degrees<br />   fld   st&#40;0&#41;<br />   fstp  REAL4 PTR &#91;edx&#93;<br />   <br />   ; TempAngle = Degrees * &#40;Pi/180&#41;<br />   ; Note&#58; Angle already on stack at ST&#40;0&#41;<br />   ;______________________________________<br />   lea edx, PI_by_180<br />   lea ecx, TempAngle<br />   fld    REAL4 PTR &#91;edx&#93;<br />   fmul<br />   fstp   REAL4 PTR &#91;ecx&#93;<br />   <br />   ; Stack is now empty, begin loop<br />   ;_______________________________<br />   <br />   xor ebx, ebx<br />   .while ebx &lt;= 120<br />    <br />    ; Loop Begins Here<br />      <br />      ;vx=vo*cos&#40;a*pi/180&#41;<br />      ;vy=vo*sin&#40;a*pi/180&#41;<br />      ;___________________<br />      <br />      lea  esi, Vx<br />      lea  edi, Vy<br />      lea  edx, Vo<br />      lea  ecx, TempAngle<br />      <br />      fld  REAL4 PTR &#91;ecx&#93;    ; St0 = TempAngle<br />      fld  st&#40;0&#41;              ; st1 = st0<br />      fcos<br />      fld  REAL4 PTR &#91;edx&#93;    ; St0 = Vo &amp; St1 = Cos&#40;@&#41; &amp; st2 = TempAngle<br />      fmul<br />      fstp REAL4 PTR &#91;esi&#93;    ; St0 = TempAngle<br />      <br />      fsin<br />      fld  REAL4 PTR &#91;edx&#93;    ; St0 = Vo &amp; St1 = Sin&#40;@&#41;<br />      fmul                    ; St0 = Vo*sin&#40;@&#41;<br /><br />      ; vy=vy + &#40;-0.0000981*ex*ex&#41; <br />      ;___________________________<br />      lea   edx, ex<br />      mov   &#91;edx&#93;, ebx<br />      fild  DWORD PTR &#91;edx&#93;<br />      fld   st&#40;0&#41;<br />      fmul                    ; St0 = Ex*Ex &amp; St1 = Vy<br />      <br />      lea   edx, Gravity<br />      fld   REAL4 PTR &#91;edx&#93;<br />      fmul                    ; Sto = -Gravity*&#40;Ex^2&#41; &amp; St1 = Vy<br /><br />      fadd                    ; St0 = Vy + &#40;-Gravity*&#40;Ex^2&#41;&#41;<br />      fstp  REAL4 PTR &#91;edi&#93;   ; Stack is emtpy<br />      <br />      ; x=x+vx<br />      ;_______<br />      <br />      lea   edx, ex<br />      fld   REAL4 PTR &#91;esi&#93;   ; st0 = vx<br />      fistp DWORD PTR &#91;edx&#93;   ; ex = &#40;integer&#41;Vx<br />      mov   eax, &#91;edx&#93;<br />      add   int_X, eax<br />      <br />      ; y=y-vy<br />      ;_______<br />      fld   REAL4 PTR &#91;edi&#93;   ; st0 = Vy<br />      fispt DWORD PTR &#91;edx&#93;   ; ex = &#40;integer&#41;Vy<br />      mov   eax, &#91;edx&#93;<br />      sub   int_y, eax<br />      <br />      ; Plot the new pixels<br />      ;____________________<br />      invoke PlotMyPixels, int_X, int_Y<br />      <br /><br />    ; Loop ends here<br />      <br />    inc ebx<br />   .endw<br />   <br />   ret<br />PlotFunct ENDP</code></pre><br /><br />Its not opimized or anything, but hopefully it should help you see thru it... I kept it simple deliberately.  The first half is initialization stuff (guess work on my behalf), and the loop is your Pseudo code translated...<br />Hope it helps..<br />:NaN:</div>
    <div class="meta">Posted on 2003-11-09 20:42:39 by NaN</div>
   </div>
   <div class="post" id="post-123903">
    <div class="subject"><a href="#post-123903">fsin/fcos deg or rad?</a></div>
    <div class="body">I noticed that only Vy is changing due to gravity and Ex.  So i pulled the reduntant stuff out of the inner loop as it can be pre-calculated and stored for speed in the loop.  Vx is calculated once and converted to integer from in &quot;x_const&quot;.   As well Vx and Vy is calculated only once initially, but in the loop Vy is modified from each itteration.  Lastly the intergers X &amp; Y are updated and the plot call is made.<br /><br />Here is a more lean &amp; mean version of your above Pseudo code, Hope you like:<pre><code><br />.data<br />   PI_by_180   REAL4    0.0174533<br />   Gravity     REAL4    -0.0000981<br />   <br />.data?<br />   Vo          REAL4    ?<br />   Vx          REAL4    ?<br />   Vy          REAL4    ?<br /><br /><br />PlotFunct PROC uses ebx esi edi integer_Vo&#58;DWORD, integer_degrees&#58;DWORD, integer_X&#58;DWORD, interger_Y&#58;DWORD<br />   LOCAL ex          &#58;DWORD<br />   LOCAL x_const     &#58;DWORD<br />   <br />   ; Set initial values<br />   finit<br />   <br />   ; Vo = &#40;REAL4&#41; interger_Vo<br />   ;_________________________<br />   lea   edx, Vo   <br />   fild  integer_Vo<br />   fstp  REAL4 PTR &#91;edx&#93;<br />   <br />   ; TempAngle = Degrees * &#40;Pi/180&#41;<br />   ; Note&#58; Angle already on stack at ST&#40;0&#41;<br />   ;______________________________________<br />   lea   edx, PI_by_180<br />   fild  integer_degrees<br />   fld   REAL4 PTR &#91;edx&#93;<br />   fmul                    ; St0 = TempAngle<br /><br />   ;vx=vo*cos&#40;a*pi/180&#41;<br />   ;vy=vo*sin&#40;a*pi/180&#41;<br />   ;___________________<br />   <br />   lea  edi, Vy<br />   lea  edx, Vo<br />   lea  ecx, x_const        <br />   <br />   fld  st&#40;0&#41;              ; st1 = st0 = TempAgnle<br />   fcos<br />   fld  REAL4 PTR &#91;edx&#93;    ; St0 = Vo &amp; St1 = Cos&#40;@&#41; &amp; st2 = TempAngle<br />   fmul                    ' St0 = Vx   <br />   fistp DWORD PTR &#91;ecx&#93;   ; St0 = TempAngle<br />   <br />   fsin<br />   fld  REAL4 PTR &#91;edx&#93;    ; St0 = Vo &amp; St1 = Sin&#40;@&#41;<br />   fmul                    ; St0 = Vo*sin&#40;@&#41;<br />   fstp REAL4 PTR &#91;edi&#93;    ; St0 = emtpy<br /><br />   <br />   ; Stack is now empty, begin loop &#40;ESI &amp; EBX must be preserved&#41;<br />   ;_______________________________<br />   <br />   xor ebx, ebx<br />   .while ebx &lt;= 120<br />    <br />    ; Loop Begins Here<br /><br />      lea edx, ex<br />      lea ecx, Gravity<br /><br />      ; vy=vy + &#40;-0.0000981*ex*ex&#41; <br />      ;___________________________<br />      fld   REAL4 PTR &#91;edi&#93;   ; st0 = Vy<br />      mov   &#91;edx&#93;, ebx        ; Ex = ebx<br />      fild  DWORD PTR &#91;edx&#93;<br />      fld   st&#40;0&#41;<br />      fmul                    ; St0 = Ex*Ex &amp; St1 = Vy      <br />      fld   REAL4 PTR &#91;ecx&#93;<br />      fmul                    ; Sto = -Gravity*&#40;Ex^2&#41; &amp; St1 = Vy<br />      fadd                    ; St0 = Vy + &#40;-Gravity*&#40;Ex^2&#41;&#41;<br />      fst   REAL4 PTR &#91;edi&#93;   ; St0 = Vy + &#40;-Gravity*&#40;Ex^2&#41;&#41;<br />      <br />      ; y=y-vy<br />      ;_______<br />      fispt DWORD PTR &#91;edx&#93;   ; ex = &#40;integer&#41;Vy<br />      mov   eax, &#91;edx&#93;<br />      sub   integer_y, eax<br /><br />      ; x=x+vx<br />      ;_______<br />      mov   eax, x_const<br />      add   integer_X, eax<br />      <br />      ; Plot the new pixels<br />      ;____________________<br />      invoke PlotMyPixels integer_X, integer_Y<br />      <br /><br />    ; Loop ends here<br />      <br />    inc ebx<br />   .endw<br />   <br />   ret<br />PlotFunct ENDP<br /></code></pre></div>
    <div class="meta">Posted on 2003-11-09 21:14:12 by NaN</div>
   </div>
   <div class="post" id="post-123909">
    <div class="subject"><a href="#post-123909">fsin/fcos deg or rad?</a></div>
    <div class="body">1st:<br />I don't know if your source is case sensitive, but I don't see any variable labeled &quot;vy&quot; in the .data section.<br /><br />2nd:<br />In addition to NaN's remarks about directing the FPU to load the wrong data types, your balistics seem to be totally wrong.<br /><br />You need to compute the horizontal and vertical velocities of the projectile based on the initial angle, but those remain constant throughout the trajectory; only the negative velocity due to gravity will change.<br /><br />Technically, you should be plotting the distances travelled; but, by plotting at every unit of time, you can accumulate the calculated velocities as if they were distances.<br /><br />This would be my version (not tested) assuming your PlotPixel function used integers as parameters.<pre><code>.data<br />ex      dd  0<br />coordx  dd  0     ;the integers used for plotting<br />coordy  dd  0     ;      id<br />angle0  dw  15    ;assuming only integer values to be used<br />w180    dw  180   ;WORDS can also be used with the FPU<br />cspd    REAL4 1.2<br />gravity REAL4 -0.0000981<br />VX      REAL4 0.0 ;horizontal distance per unit time<br />VY      REAL4 0.0 ;vertical distance per unit time<br />distX   REAL4 0.0 ;total horizontal distance travelled<br />distY   REAL4 0.0 ;total vertical distance travelled<br /><br />.code<br />finit<br />fldpi<br />fidiv w180<br />fimul angle0     ;start angle now in radians<br />fsincos          ;st=cos, st1=sin<br />fmul  cspd       ;st=cspd*cos, st1=sin<br />fstp  VX         ;st=sin<br />fmul  cspd       ;st=cspd*sin<br />fstp  VY<br /><br />invoke PlotPixel, coordx,coordy ;plot starting point<br /><br />loop_here&#58;<br /><br />inc   ex<br />fild  ex<br />fmul  st,st     ;st=ex*ex<br />fmul  gravity   ;st=ex*ex*gravity<br />fadd  VY        ;st=ex*ex*gravity+VY<br />fadd  distY     ;st=ex*ex*gravity+VY+distY<br />fst   distY     ;keep as REAL4<br />fistp coordy    ;store as rounded integer<br /><br />fld   distX     ;st=distX<br />fadd  VX        ;st=distX+VX<br />fst   distX     ;keep as REAL4<br />fistp coordx    ;store as rounded integer<br /><br />invoke PlotPixel, coordx,coordy<br />cmp   ex,120<br />jbe   loop_here</code></pre><br />Raymond</div>
    <div class="meta">Posted on 2003-11-09 22:02:51 by Raymond</div>
   </div>
   <div class="post" id="post-123931">
    <div class="subject"><a href="#post-123931">fsin/fcos deg or rad?</a></div>
    <div class="body">Sorry for error. My head must have gone a little balistic late at night.<br /><br />The a*(t^2) calculates the cumulative distance travelled due to an accelaration <strong>a</strong> over a period of time <strong>t</strong> (technically it should read 0.5a*t^2).<br />It must not be accumulated in each iteration. The computation of the &quot;coordy&quot; in my previous post should thus be altered as follows:<pre><code>fld   VY        ;st=VY<br />fadd  distY     ;st=VY+distY<br />fst   distY     ;cumulative distance due to velocity<br />inc   ex<br />fild  ex        ;st=ex, st1=VY+distY<br />fmul  st,st     ;st=ex*ex, st1=VY+distY<br />fmul  gravity   ;st=ex*ex*gravity, st1=VY+distY<br />fadd            ;st=ex*ex*gravity+VY+distY<br />fistp coordy    ;store as rounded integer</code></pre>Raymond</div>
    <div class="meta">Posted on 2003-11-10 08:15:53 by Raymond</div>
   </div>
   <div class="post" id="post-123938">
    <div class="subject"><a href="#post-123938">fsin/fcos deg or rad?</a></div>
    <div class="body">thank you Nan and Raymond, for your help..  I think I will try Nan's way first, it seems like I will learn more from it..  as for your way Raymond, I tried plugging it in and the ball goes down and then back up. I think it has to do with:<br /><br /> vy=vy+(gravity*t*t)<br /> Y=Y-vy   ;&lt;=== this needs to be separate, (VY+distY) - (gravity*t^2) working on parenthesis before subtraction<br /> X=X+vx<br /><br />why can't I do  fmul ST  (or fmul ex) - it wont multiply the value by its stored value?<br /><br />when does the value stored in the ST(n) shift..  when you specify the P , or can it do it on an add? Is there a general rule of thumb to know when that happens?  I think that is the most confusing for me.<br /><br />I take it I can't use FADD to add integers or FIADD for floating point??<br /><br />I've come to realize also, fild works with integers and fld with floating point numbers (as it says in your docs) - I take it dwords, real4's, etc.. can be signed or unsigned and I don't have to worry bout that as I do with the decimals.</div>
    <div class="meta">Posted on 2003-11-10 09:47:00 by drarem</div>
   </div>
   <div class="post" id="post-123949">
    <div class="subject"><a href="#post-123949">fsin/fcos deg or rad?</a></div>
    <div class="body"><div class="quote"><br />thank you Nan and Raymond, for your help..  I think I will try Nan's way first, it seems like I will learn more from it..  as for your way Raymond, I tried plugging it in and the ball goes down and then back up. I think it has to do with:<br /><br /> vy=vy+(gravity*t*t)<br /> Y=Y-vy   ;&lt;=== this needs to be separate, (VY+distY) - (gravity*t^2) working on parenthesis before subtraction<br /> X=X+vx<br /><br />why can't I do  fmul ST  (or fmul ex) - it wont multiply the value by its stored value?<br /><br />when does the value stored in the ST(n) shift..  when you specify the P , or can it do it on an add? Is there a general rule of thumb to know when that happens?  I think that is the most confusing for me.<br /><br />I take it I can't use FADD to add integers or FIADD for floating point??<br /><br />I've come to realize also, fild works with integers and fld with floating point numbers (as it says in your docs) - I take it dwords, real4's, etc.. can be signed or unsigned and I don't have to worry bout that as I do with the decimals. </div><br /><br />(1) FMUL if i remember correctlly will only work on ST(0) and ST(1), or ST(0) and Memory.<br /><br />(2) Yes, the stack drops when &quot;popped&quot;, just like the normal ESP stack, except the FPU stack has only 8 positions.  When FLD is like Push, and FSTP is like POP.  However, FST is only a memory write, the stack is unaffected.<br /><br />(3) The &quot;I&quot; commands are only for bringing data into or out of the FPU stack.  Then stack is *ALWAYS* a 10 byte IEEE floating point.  So your REAL4's or REAL8's, or DWORDS are all converted to a &quot;REAL10 or TWORD&quot; on the stack.  This is why you specificy the data size to the command.  So no, the FIADD is not needed even if 4.0 is on the stack.  FADD will surfice, since its already converted to floating point.<br /><br />(4) As for signed dwords, im not too sure.  I would check the doc's.<br /><br />Regards,<br />:NaN:</div>
    <div class="meta">Posted on 2003-11-10 11:48:45 by NaN</div>
   </div>
   <div class="post" id="post-123963">
    <div class="subject"><a href="#post-123963">fsin/fcos deg or rad?</a></div>
    <div class="body">My suggestion would be that you reread Chap.1 and Chap.2 of the tutorial a few times. It may take some time for all that info to sink in.<br /><br />Then make sure you read the description of each instruction you intend to use. Some of the instructions may shift register numbers back or forth.<br /><br />For example, you would read that the fsincos instruction replaces the angle in st(0) with its &quot;sin&quot; value and then pushes all the registers to load the &quot;cos&quot; value into the new top register. But only if the angle is within the acceptable range. If it is &quot;out-of-range&quot;, the angle value would then stay unaltered in the top register and no register is &quot;pushed&quot;!!!<br /><br />Raymond</div>
    <div class="meta">Posted on 2003-11-10 14:20:50 by Raymond</div>
   </div>
  </div>
 </body>
</html>