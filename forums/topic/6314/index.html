<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Global Memory is slow! - use Heap functions... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=6314" />
    <link rel="next" href="../?id=6314&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=6314">Global Memory is slow! - use Heap functions...</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=6314&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=6314&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="6314" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=6314&amp;page=2">&gt;</a><a href="../?id=6314&amp;page=2">&raquo;</a></form>   <div class="post" id="post-45361">
    <div class="subject"><a href="#post-45361">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">Exerpt from SDK docs suggests using Heap instead of Global memory functions:<br /><br />From GlobalRealloc:<br />...<br />Note  The global functions are slower than other memory management functions and do not provide as many features. Therefore, new applications should use the heap functions. However, the global functions are still used with DDE and the clipboard functions. <br />...<br /><br /><br />From IStream:<br />...<br />Note  If you are creating a stream object that is larger than the heap in your machine's memory and you are using an HGLOBAL handle to a global memory object, the stream object calls the GlobalRealloc method internally whenever it needs more memory. Because GlobalRealloc always copies data from the source to the destination, increasing a stream object from 20 megabytes (MB) to 25 MB, for example, consumes immense amounts of time. This is due to the size of the increments copied and is worsened if there is less than 45 MB of memory on the machine because of disk swapping.<br /><br />The preferred solution is to implement an IStream method that uses memory allocated by VirtualAlloc instead of GlobalAlloc. This can reserve a large chunk of virtual address space and then commit memory within that address space as required. No data copying occurs and memory is committed only as it is needed.<br />...</div>
    <div class="meta">Posted on 2002-06-27 06:05:36 by gfalen</div>
   </div>
   <div class="post" id="post-45370">
    <div class="subject"><a href="#post-45370">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">Nothing new, sorry :rolleyes: <br /><br />Ask f0dder, he swears on HeapAlloc :tongue:</div>
    <div class="meta">Posted on 2002-06-27 06:26:46 by bazik</div>
   </div>
   <div class="post" id="post-45379">
    <div class="subject"><a href="#post-45379">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">Yep,<br /><br />There are numerous solutions to memory access depending on what you want to do with it, if you really have to mave large amounts around, one viable method is to use a memory mapped file and handle your own paging.<br /><br />OLE string memory is fast, the CoTask## memory functions work well, VirtualAlloc if you don't mind using virtual memory mixed with physical memory but note that the older GlobalAlloc family of memory functions have finer granularity and once it is allocated, it has no speed problems at all.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-06-27 06:47:33 by hutch--</div>
   </div>
   <div class="post" id="post-45440">
    <div class="subject"><a href="#post-45440">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">On NT, Local/GlobalAlloc symbols refer to the exact same address. Ie, they<br />are 100% identical. It :) calls HeapAlloc internally, after some parameter<br />conversions. Dunno really why this should be much slower than HeapAlloc<br />directly, but sure there's a bit extra code. Might be a different matter on<br />9x, there's so much suckiness there.<br /><br />Using memory mapped files for memory allocation is not a good idea; firstly<br />you'll get exceptions 'every now and then'. Probably not on 4k boundaries,<br />the pagefault handler ought to be a bit smarter than that - but you *will*<br />get pagefaults, which slows down stuff. Furthermore mmaps that aren't backed<br />by a file handle are always backed by the pagefile. I assume this means that<br />writes to the memory *will* go to the pagefile, whether your app needs to<br />be swapped out or not - not tested though.<br /><br /><div class="quote"><br />OLE string memory is fast, the CoTask## memory functions work well, VirtualAlloc<br />if you don't mind using virtual memory mixed with physical memory but note that<br />the older GlobalAlloc family of memory functions have finer granularity and once<br />it is allocated, it has no speed problems at all.<br /></div><br />All win32 memory allocation functions (which means ring3 - but I dunno of any<br />ring0 win32 api memory allocations ;)) are using virtual memory. This doesn't<br />mean you stuff will necessarily go to the pagefile, except of course if your<br />app needs to be paged out - but you can't avoid that by using CoTask## or<br />whatever. The closest you can get to unswappable memory in ring3 (that I know<br />of) is by using VirtualLock, but be careful and only use this if you know<br />EXACTLY what you are doing and the implications on the system.<br /><br />I recommend people to generally use HeapAlloc, as it is 'the preferred win32<br />way'. It's flexible, can be reallocated, etc. If you need large (multiples<br />of 4k) buffers that aren't going to be resized (like a system-memory video<br />backbuffer), go for VirtualAlloc - it's closer to the lowlevel memory allocation<br />primitives, offers control of page-level protection, and guarantees 4k alignment.<br />(Well, page alignment anyway, which shouldn't be anything but 4k on x86 win32 -<br />you can get system page size with a call to GetSystemInfo if you're paranoid).</div>
    <div class="meta">Posted on 2002-06-27 13:10:28 by f0dder</div>
   </div>
   <div class="post" id="post-45552">
    <div class="subject"><a href="#post-45552">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">One point to add to f0dder's reply: VirtualLock doesn't work in Win9x (is documented somewhere).</div>
    <div class="meta">Posted on 2002-06-28 03:52:38 by japheth</div>
   </div>
   <div class="post" id="post-45606">
    <div class="subject"><a href="#post-45606">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">All versions of 32 bit windows are identical in GlobalAlloc/LocalAlloc as the LOCAL distinction is no longer relevant in 32 bit flat memory model.<br /><br />VirtualAlloc is OK for large block but very inefficient in large numbers of small blocks, in terms of average size/speed and flexibility, OLE string is fast, has fine granularity and is preallocated so it is also fast in startup terms. Limit under win95b is about 260 meg so it can handle most things with no problems.<br /><br />I am surprised that you have had problems with memory mapped files, I have tested them on a half a gig and they are reliable and fast to use when you need a large block of aligned memory. I did my testing on win95b so I guess you must have done something unusual in how you used it.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-06-28 11:41:54 by hutch--</div>
   </div>
   <div class="post" id="post-45611">
    <div class="subject"><a href="#post-45611">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body"><div class="quote"><br />VirtualAlloc is OK for large block but very inefficient in large numbers<br />of small blocks, in terms of average size/speed and flexibility<br /></div><br />Large number of small blocks would be stupid with VirtualAlloc, as all<br />alignments are done in 4k chunks - as I said, it's good for large blocks<br />that aren't resized. Slow speed? I doubt that very much ;).<br /><br /><div class="quote"><br />OLE string is fast, has fine granularity and is preallocated<br />so it is also fast in startup terms.<br /></div><br />&quot;preallocated&quot;? Do you mean the memory is touched-to-zero after<br />allocation, or that windows has a large preallocated pool it<br />gives memory from? I doubt the latter very much... when you<br />VirtualAlloc, you can specify whether the pages should be<br />committed right away, or you can commit pages as you want to.<br />Whatever flexibility you need.<br /><br /><div class="quote"><br />I am surprised that you have had problems with memory mapped files,<br />I have tested them on a half a gig and they are reliable and fast<br />to use when you need a large block of aligned memory.<br /></div><br />Then I doubt you have done very much testing. Memory mapped files<br />generate pagefaults, and that's a fact.</div>
    <div class="meta">Posted on 2002-06-28 12:04:26 by f0dder</div>
   </div>
   <div class="post" id="post-45616">
    <div class="subject"><a href="#post-45616">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">Actually I've been doing work with memory-mapped files and I was told it would be the most efficient way to handle large files. The application turned out to use large amounts of memory and become slow, so I changed the code to handle files in 4MB blocks and it became much better. :)<br />Just my two cents...</div>
    <div class="meta">Posted on 2002-06-28 14:12:55 by comrade</div>
   </div>
   <div class="post" id="post-45636">
    <div class="subject"><a href="#post-45636">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">My 2 cents<br /><br />From the WIN32.hlp this seems to imply that HeapAlloc should be used when portability is an issue but HeapAlloc also has an Achillies Heal.<br /><br />Memory allocated by HeapAlloc is not movable. Because the system cannot compact a private heap, the heap can become fragmented. <br />A possible use for the heap functions is to create a private heap when a process starts up, specifying an initial size sufficient to satisfy the memory requirements of the process. If the call to the HeapCreate function fails, the process can terminate or notify the user of the memory shortage; if it succeeds, however, the process is assured of having the memory it needs. <br /><br />:alright:</div>
    <div class="meta">Posted on 2002-06-28 16:59:29 by IwasTitan</div>
   </div>
   <div class="post" id="post-45652">
    <div class="subject"><a href="#post-45652">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">Any memory allocation in win32 can become fragmented. Since<br />local/globalalloc are the same, and the local/global *lock/*unlock<br />functions aren't used, these are as hurt by fragmentation as HeapAlloc<br />(and since Local/GlobalAlloc uses HeapAlloc internally, this is rather<br />obvious ;)). Yeah, VirtuaAlloc can also get fragmented, but since there's<br />no &quot;floating&quot; allocations in win32 as there was in win16, there ins't<br />really any problems... unless you have very bad memory handling, this<br />will not be a problem. Only virtual per-process memory space fragmentation<br />matters anyway, physical fragmentation is more or less nonexistant because<br />of the wonders of paging. Or rather, problems with fragmentation is nonexistant.<br /><br />If you don't *need* a private heap, don't allocate one. Cases where a<br />private heap can be necessary? Lotsa memory allocations where you need<br />to free all at once; this could for instance be be a view of a file in<br />an editor. But it all depends on your program etc - just that in most programs<br />there's no need for anything except the default heap, unless you're a slopcoder ;).</div>
    <div class="meta">Posted on 2002-06-28 21:14:07 by f0dder</div>
   </div>
   <div class="post" id="post-45656">
    <div class="subject"><a href="#post-45656">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">f0dder<br /><br />Thanx for enlightening me on the limitations of WIN32 <br /><br />(somethiong usually not obviouse to a newbie in any help file)<br /><br />The salient point:<br /><br />Since<br />local/globalalloc are the same, and the local/global *lock/*unlock<br />functions aren't used, these are as hurt by fragmentation as HeapAlloc<br />(and since Local/GlobalAlloc uses HeapAlloc internally, this is rather<br />obvious )<br /><br />Wasn't obvious to me<br /><br />thanx<br />:alright:</div>
    <div class="meta">Posted on 2002-06-28 21:42:31 by IwasTitan</div>
   </div>
   <div class="post" id="post-45660">
    <div class="subject"><a href="#post-45660">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">I?ve done some benchmarking tests on memory (read, write and move) using API memory allocation and also using static data allocation <br />.data?<br />Buffer db 1024*1024*x dup (?)<br />But according to tests, memory allocated by API seems very slow<br />compared to static allocation (about 60% of static allocation). I?ve<br />done these using all possible kinds of ways (rep, MMX, Jmp, ect?).<br />My questions are<br /> 1. Why is the memory allocated by API running slow?<br /> 2. Is there a way improve the assembling time when using static<br />	allocation. Because anything over 500k MASM takes very long time<br />	to assemble.<br /><br />Pradeepan.</div>
    <div class="meta">Posted on 2002-06-28 22:14:55 by Pradeepan</div>
   </div>
   <div class="post" id="post-45672">
    <div class="subject"><a href="#post-45672">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">I would think that any great giant such as Wintel would engineer their interface to suit their needs.<br /><br />But according to tests, memory allocated by API seems very slow<br />compared to static allocation <br /><br /><br />Hey ..welcome to the high level language of wintel<br /><br />I'm all for debug these days.<br /><br />:alright:</div>
    <div class="meta">Posted on 2002-06-28 23:42:00 by IwasTitan</div>
   </div>
   <div class="post" id="post-45673">
    <div class="subject"><a href="#post-45673">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">hmmmm,<br /><br />====<br />Then I doubt you have done very much testing. Memory mapped files generate pagefaults, and that's a fact.<br />====<br /><br />This seems a strange thing to say, ANY memory can generate page faults depending on how you use it. I seriously doubt that the memory mapped file capacity in 32 bit windows was designed to &quot;page fault&quot; so unless there is an unknown bug in the OS code to provide it, the fault lies in the application code.<br /><br />===<br />&quot;preallocated&quot;<br />===<br /><br />Take it up with Microsoft, they use it for string support for UNICODE in later OS versions and it has been there since win95oem. For you reference the,<br /><br />&quot;SysAlloc.....&quot;<br />&quot;SysReAlloc....&quot;<br />&quot;SysFree....&quot;<br /><br />family of functions that are in the OLE capacity for all versions of 32 bit Windows.<br /><br />Now it finally does not matter how each version supplies the memory to OLE, it is a published interface that does the job.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-06-28 23:44:17 by hutch--</div>
   </div>
   <div class="post" id="post-45680">
    <div class="subject"><a href="#post-45680">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body"><div class="quote"><br />This seems a strange thing to say, ANY memory can generate page<br />faults depending on how you use it. I seriously doubt that the<br />memory mapped file capacity in 32 bit windows was designed to<br />&quot;page fault&quot; so unless there is an unknown bug in the OS code<br />to provide it, the fault lies in the application code.<br /></div><br />This shows you do not understand how memory mapped files are implemented :).<br />Obviously the pagefaults aren't &quot;the app has performed an illegal operation<br />and will be terminated&quot; type PFs, but stuff that is handled internally<br />by windows.<br /><br />Let's the the example where an existing file is mapped for read, as this<br />is the most simple case. You end up getting a pointer that gives access<br />to the file. This might seem lige magic, but it is implemented through the<br />use of pagefaults. When you access a page that hasn't been accessed yet,<br />a pagefault is generated, and this is handled by the internal windows #PF<br />handler. This has a lot of checking to do. Is it an unhandled PF? Is it<br />a PF caused by writing to read-only memory? Is the memory area a MMF?<br />In the case of MMF, pages are yanked in from the file, marked as present,<br />and the read operation is restarted. Luckily it seems that you don't get<br />a fault per page, but rather &quot;regions&quot; of the file are brought in - otherwise<br />the performance of MMF would have been disastrous, rather than just &quot;somewhat<br />slower than normal file access&quot;.<br /><br />Write access is more complicated, and I haven't studied this in great<br />detail yet, so I'll be careful not to speak too much of it. But as far<br />as I've heard/seen/read, it seems that there's some &quot;idle time writeback<br />thread&quot; that handles updating the physical files.<br /><br /><div class="quote"><br />Now it finally does not matter how each version supplies the memory to OLE,<br />it is a published interface that does the job.<br /></div><br />You were using words &quot;fast&quot; and &quot;preallocated&quot;, and I questioned the &quot;preallocated&quot;<br />part. If you don't know what you mean by this word, don't use it, and avoid<br />confusing people.</div>
    <div class="meta">Posted on 2002-06-29 03:56:32 by f0dder</div>
   </div>
   <div class="post" id="post-45694">
    <div class="subject"><a href="#post-45694">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">You seem to be confusing the MMF mechanism available and making mistakes using it, after having tested about a half a gig MMF, I had no problems reading or writing to it at all.<br /><br />Now it seems that you are making reference to how it is USED and ALLOCATED in terms of access. Access the wrong address in the wrong way and it will not work but that is a USER fault, not a fault with MMFs.<br /><br />Preallocated.<br /><br />This means JUST what it says, in another terminology, its what you call a &quot;STRING POOL&quot;, something that anyone who codes in BASIC well understands and uses to advantage. &quot;Garbage collection&quot; is another original BASIC concept long before Windows and it just keeps going.<br /><br />When you use OLE string, you are using the STRING POOL that is already allocated by the operating system. Without it UNICODE would not work at all.<br /><br />It is a mistake to assume that what you don't understand does not exist, this stuff has been around for years so taking the ostrich approach to what you are not familiar with does not make sense.<br /><br />Now your argument has been to date,<br /><br />1. You get errors with MMFs so there is something wrong with MMFs.<br /><br />2. You do not know how OLE string works so it does not work.<br /><br />Surely you can do better than that.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-06-29 05:47:30 by hutch--</div>
   </div>
   <div class="post" id="post-45696">
    <div class="subject"><a href="#post-45696">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body"><div class="quote"><br />You seem to be confusing the MMF mechanism available and making mistakes<br />using it, after having tested about a half a gig MMF, I had no problems<br />reading or writing to it at all.<br /></div><br />No, I am talking about how MMF is implemented internally. As I think I<br />stated previously, the PF's that occur with MMF is part of the design,<br />not program bugs. The PFs are totally transparent, handled by the kernel,<br />ie not the type that crashes your app. But there *are* pagefaults going<br />on when using MMFs.<br /><br />1) you get me wrong, and you do not understand how MMF works.<br />2) I have not messed with OLE string memory allocation, but I do not<br />   doubt it works. I doubt, however, that it is any more &quot;preallocated&quot;<br />   than heap/virtualalloc/whatever memory, as that would be a waste of<br />   precious system memory.<br /><br />I'm in the process of doing &quot;a good deal&quot; of testing and better explanations<br />of the various methods, results should be coming up within long, when I've<br />finished writing the text and cleaned the program source code.<br /><br />By the way, note the VirtualLock doesn't mean your pages are 100% immune from<br />being discard or swapped out - refer to &quot;inside microsoft windows 2000&quot; for<br />more details.</div>
    <div class="meta">Posted on 2002-06-29 05:54:57 by f0dder</div>
   </div>
   <div class="post" id="post-45698">
    <div class="subject"><a href="#post-45698">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">Here you go.</div>
    <div class="meta">Posted on 2002-06-29 06:11:17 by f0dder</div>
   </div>
   <div class="post" id="post-45702">
    <div class="subject"><a href="#post-45702">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">Some other disadvantages of MMF compared to normal virtual memory are:<br /><br />- MapViewOfFile will enlarge Paging File by the number of bytes to map, regardless how much free physical memory is in system<br />- it will reduce shared memory area in Win9x systems (which is &quot;only&quot; 1 GB)<br /><br />So Hutch, I would suggest to bel?eve what f0dder teaches. As always he knows what he is talking about.<br /><br />japheth</div>
    <div class="meta">Posted on 2002-06-29 07:06:48 by japheth</div>
   </div>
   <div class="post" id="post-45783">
    <div class="subject"><a href="#post-45783">just the question?</a></div>
    <div class="body">i just have the question.<br /><br />if i want to access the data in a large file that can not load the whole data into memory.<br /><br />whichone is better in term of speed between using the MMF and implement the page file by myself?<br /><br />thanks,<br />doby.</div>
    <div class="meta">Posted on 2002-06-29 21:28:25 by doby</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=6314&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=6314&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="6314" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=6314&amp;page=2">&gt;</a><a href="../?id=6314&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>