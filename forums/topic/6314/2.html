<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Global Memory is slow! - use Heap functions... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=6314" />
  <link rel="prev" href="../?id=6314&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=6314">Global Memory is slow! - use Heap functions...</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=6314&amp;page=1" style="">&laquo;</a><a href="../?id=6314&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="6314" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-45791">
    <div class="subject"><a href="#post-45791">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">doby,<br /><br />It very much depends on how big the file you want to load is. If its something you can safely fit into available memory, then you can load it into a memory buffer and process it whatever way you wish.<br /><br />If it is much larger with somethiong like a database file which can be gigabytes in size, you will need to have some paging mechanism to manipulate the data.<br /><br />If you work out what is the safest buffer size you can run, then you can load the file in bits using the normal file IO APIs and handle it that way.<br /><br />Japheth,<br />===========<br />- MapViewOfFile will enlarge Paging File by the number of bytes to map, regardless how much free physical memory is in system - it will reduce shared memory area in Win9x systems (which is &quot;only&quot; 1 GB)<br />===========<br /><br />Sure, it must come from somewhere but the documentation says that MMFs are backed up by the system paging mechanism. I have yet to see a memory allocation method that happends by magic, it must always come from physical memory or disk somewhere.<br /><br />==============<br />- it will reduce shared memory area in Win9x systems (which is &quot;only&quot; 1 GB)<br />==============<br /><br />As win95/98 can only use under 1 gig of physical memory (Tested on 2 of my boxes as per the documentation) such a restriction is vacuous of content. I run 768 meg on both win9x machines.<br /><br />f0dder,<br />==============<br />refer to &quot;inside microsoft windows 2000&quot; for more details.<br />==============<br /><br />The problem with this approach among others is that a published interface for a function is not and does not have to be implimented in the same way in each OS version. GlobalAlloc() was available in win 3.0 in 1990 but I can promise you that it does not work the same way in later 32 bit versions so your detailed analysis of win2k is trivial.<br /><br />Just to drop you a little hint about OLE memory as a system resource, call a function GlobalMemoryStatus() both before and after you allocate 100 meg from the OLE string pool and on win95/98 you will see no difference. The system uses OLE string to do many things, being trapped in a world of zero terminated buffers is like being trapped in a time zone that ended a long time ago.<br /><br />Like it or lump it, there are many ways of accessing memory in 32 bit windows and each method has its advantages and vices, a predisposition to one method without comprehending the differences is a mistake.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-06-29 23:51:23 by hutch--</div>
   </div>
   <div class="post" id="post-45797">
    <div class="subject"><a href="#post-45797">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">hi hutch,<br /><br />the file size too large, can not load the whole file into memory.<br /><br />in my case, the speed is very critical, i really need the speed as high as possible.<br /><br />so, my question is that in the following two way which one is better.<br />1) using MMF (i understand that MMF implement page files for me)<br />2) load some part in to mem. as a page file, if the program has the cache miss, then go to get the new one from the real file and replace it to the part in mem. by some algorithm. (doing page file by myself)<br /><br />because the I/O access is very slow, i need to reduce the I/O access as much as possible to increase the speed.<br /><br />if there is the other way better please give me some suggestion.<br /><br />or if i misunderstand something, please correct me.<br /><br />thanks,<br />doby.</div>
    <div class="meta">Posted on 2002-06-30 01:19:06 by doby</div>
   </div>
   <div class="post" id="post-45809">
    <div class="subject"><a href="#post-45809">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">doby,<br /><br />============<br />the file size too large, can not load the whole file into memory.<br />============<br /><br />I guess you have no other choice than to allocate a buffer that you think is a safe size for the machine that you wish to run and process the file a section at a time. You could try and use virtual memory but you are then at the mercy of the operating system in how its is paged.<br /><br />If the file is for example, 100 meg and you can only safely allocate 10 meg in a buffer, then you would proces it at 10 meg at a time. A buffer size this big would solve any problems of slowing down disk IO.<br /><br />I would have a look at the file APIs to see about either buffering the read or the write to disk but not both. The logic here is to buffer read and direct write or direct read and buffered write.<br /><br />You may have to flush the file buffer after each write so that you don't overload the file buffer.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-06-30 04:14:33 by hutch--</div>
   </div>
   <div class="post" id="post-45817">
    <div class="subject"><a href="#post-45817">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">Just played around with some of the alloc functions mentioned here. Seems there isn't much difference between LocalAlloc (+ GlobalAlloc, HeapAlloc), CoTaskMemAlloc and SysAllocString. They all alloc committed memory in private address space and are shown with Heap32Next function (so they are normal heap items)<br /><br />Thats my little test proc (cant be compiled without changes Im afraid because I used some CRT functions)<br /><br /><pre><code><br />        .386<br />        .Model flat,stdcall<br />        option casemap&#58;none<br /><br />        include \masm32\include\windows.inc<br />        include \masm32\include\kernel32.inc<br />        include \masm32\include\user32.inc<br />        include \masm32\include\ole32.inc<br />        include \masm32\include\oleaut32.inc<br />        include debugout.inc<br />        include crt.mac<br /><br />MEMSIZE equ 7000000h     ;112 MB<br /><br />?SYSALLOC equ 0<br />?COTASK   equ 0<br />?NORMAL   equ 1<br /><br />        .code<br /><br />main    proc c <br /><br />        invoke CoInitialize, NULL<br /><br />        invoke  printf,CStr&#40;&lt;&quot;press any key to start...&quot;,13,10&gt;&#41;<br />        invoke  _getch<br /><br />if ?SYSALLOC<br />        invoke SysAllocStringByteLen, NULL, MEMSIZE<br />        mov esi,eax<br />        invoke printf, CStr&#40;&lt;&quot;SysAllocStringByteLen returned %X&quot;,13,10&gt;&#41;,eax<br />endif<br />if ?COTASK<br />        invoke CoTaskMemAlloc, MEMSIZE<br />        mov esi,eax<br />        invoke printf, CStr&#40;&lt;&quot;CoTaskMemAlloc returned %X&quot;,13,10&gt;&#41;,eax<br />endif<br />if ?NORMAL<br />        invoke LocalAlloc, LMEM_FIXED, MEMSIZE<br />        mov esi,eax<br />        invoke printf, CStr&#40;&lt;&quot;LocalAlloc returned %X&quot;,13,10&gt;&#41;,eax<br />endif<br /><br />        invoke  printf,CStr&#40;&lt;&quot;press any key to stop...&quot;,13,10&gt;&#41;<br />        invoke  _getch<br /><br />        invoke CoUninitialize<br />        ret<br /><br />main    endp<br /><br />        end<br /></code></pre><br /><br />Tested with Win98 and WinXP<br /><br />Since memory is just allocated but not touched by this app, only &quot;committed memory&quot; is increased. &quot;Free physical memory&quot; dont change and even &quot;Paging file in use&quot; sometimes remains unchanged. Seem that Windows just checks that &quot;total size of committed memory&quot; doesn't exceed &quot;total size of physical memory&quot; + &quot;max paging file size&quot;.<br /><br />As a consequence: you can't be sure that you can alloc 100 MB if &quot;free physical memory&quot; indicated 128 MB.<br /><br />japheth</div>
    <div class="meta">Posted on 2002-06-30 05:53:29 by japheth</div>
   </div>
   <div class="post" id="post-45841">
    <div class="subject"><a href="#post-45841">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body"><div class="quote"><br />Sure, it must come from somewhere but the documentation says that MMFs<br />are backed up by the system paging mechanism. I have yet to see a memory<br />allocation method that happends by magic, it must always come from physical<br />memory or disk somewhere.<br /></div><br />Of course you don't get anything for free - but expanding the pagefile all<br />at once when an allocation is done... isn't really necessary. And yes, this<br />*does* happen on 9x, I just verified it on my kid brothers' 98se box. Right<br />after the MMF allocation is done, the paging file increases to ~512 megabyte.<br />On NT, the pagefile isn't increased until necessary. So, I would suggest that<br />using memory mapped files for large allocations isn't a good idea on 9x.<br /><br /><div class="quote"><br />As win95/98 can only use under 1 gig of physical memory (Tested on 2 of my<br />boxes as per the documentation) such a restriction is vacuous of content.<br />I run 768 meg on both win9x machines.<br /></div><br />It actually *is* quite a limitation. Why? Well, you can't map two 600meg<br />files at once, for instance. You will have to map a smaller view of the<br />files, meaning more code et cetera.<br /><br /><div class="quote"><br />The problem with this approach among others is that a published interface for a<br />function is not and does not have to be implimented in the same way in each OS<br />version. GlobalAlloc() was available in win 3.0 in 1990 but I can promise you<br />that it does not work the same way in later 32 bit versions so your detailed<br />analysis of win2k is trivial.<br /></div><br />Of course the implementation can change... but there are fundamental things<br />about memory mapped files that just don't change, at least not unless the<br />CPU changes as well. In case you don't believe me, you should read up on<br />paging in the intel system programmers manual.<br /><br /><div class="quote"><br />Like it or lump it, there are many ways of accessing memory in 32 bit windows<br />and each method has its advantages and vices, a predisposition to one method<br />without comprehending the differences is a mistake.<br /></div><br />Ahem. I am merely pointing out why you shouldn't use memory mapped files for<br />generic memory allocations. It's about using the right tool for the right job,<br />and memory mapped files just isn't the right tool for generic memory allocations.<br />I believe I have given enough reasons why.<br /><br />Doby, if speed is very critical, do not use memory mapping to handle your file<br />(the exception could be if you have an algorithm that works on one big buffer<br />and would lose a lot of speed being converted to 'chunked' code). In almost all<br />situations, ReadFile on blocks of code will be faster than memory mapped files,<br />as you avoid the numerous pagefaults of MMF. While the bottleneck in file I/O<br />is usually the harddrive speed, you *will* be able to feel the impact of MMF.<br /><br /><div class="quote"><br />You could try and use virtual memory but you are then at the mercy of the<br />operating system in how its is paged.<br /></div><br />All ring3 memory management (ie, the stuff you can do with the WIN32 API) is<br />'virtual memory'. Any memory can be discarded or paged out. Like it or not,<br />but that's how it is. It's a good reason to think about your memory allocation<br />strategies to avoid discarding/paging.<br /><br /><div class="quote"><br />I would have a look at the file APIs to see about either buffering the read or<br />the write to disk but not both. The logic here is to buffer read and direct write<br />or direct read and buffered write.<br />You may have to flush the file buffer after each write so that you don't overload<br />the file buffer.<br /></div><br />Unless you do this *very* carefully, you'll probably end up with worse speed than<br />normal Read/WriteFile (without any &quot;special flags&quot; or calls to flush). I don't say<br />you can't get it better with 'special code', but you'd better check the speed with<br />and without, and on a multitude of systems. And of course everything depends on<br />what exactly you're doing...<br /><br />By the way japheth, perhaps you can answer this... even when committed, pages aren't<br />actually taken from the physical pool and zeroed out before first use, are they?<br />Zeroing out a 512meg allocation would take at least *some* time, but VirtualAlloc<br />seems to return immediately - and VirtualAlloc *does* guarantee you that the pages<br />will be zeroed... obviously the &quot;just in time&quot; zeroing (and physical allocation?)<br />is not done per-page or you'd have even worse speed than memory mapped files, but<br />do you have any idea how it's done? Pages marked not present or read-only? Allocating<br />in 64k regions, or more, or less, or with some other heuristic? Guess I should look<br />in 'inside windows 2000' and see if I can find the answers - I seem to remember something<br />about only VADs being reserved until actual use...</div>
    <div class="meta">Posted on 2002-06-30 10:17:59 by f0dder</div>
   </div>
   <div class="post" id="post-45843">
    <div class="subject"><a href="#post-45843">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">f0dder, my little tests have prooved (at least for me :) ): All the standard memory allocation functions (except VirtualAlloc which I havent tested) in Win9x do enlarge the pageing file too. Whereas the free page pool remains more or less unchanged until the memory is touched (havent used XXX_ZEROINIT in my tests). In consequence that means that physical memory will be assigned thru page faults too like with MMF. So the one main difference compared to MMF may be that it is in the shared region. May be enlarging the pageing file isn't a costly operation so this strategy makes sense. (And in this point NT and Win9x really differ because paging file size in Win9x is dynamic).</div>
    <div class="meta">Posted on 2002-06-30 11:07:59 by japheth</div>
   </div>
   <div class="post" id="post-45845">
    <div class="subject"><a href="#post-45845">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body"><div class="quote"><br />In consequence that means that physical memory will be assigned thru<br />page faults too like with MMF.<br /></div><br />Yes... it seems that memory allocations generate &quot;demand-zero&quot; paging,<br />ie the pages will not be actually allocated and zero-filled until they<br />need using. inside win2k says this is done in batches, which makes sense.<br />The thing that puzzles me a bit is why MMF allocated memory is so much<br />slower than 'normal' memory allocation, since both of them depend on<br />pagefaults... perhaps there's more checks involved with mapped memory?<br />Or perhaps the 'batch' size is smaller for MMF, causing more PFs?<br /><br /><div class="quote"><br />May be enlarging the pageing file isn't a costly operation<br /></div><br />It is :). There was &quot;some&quot; disk I/O activity involved on 9x when<br />allocating a large buffer, and I got the popup about &quot;drive is<br />running low on space&quot;.<br /><br /><div class="quote"><br />(And in this point NT and Win9x really differ because paging file<br />size in Win9x is dynamic).<br /></div><br />Hmm, it's dynamic on NT as well - I have min/max sizes for my pagefile.<br />Or perhaps you mean it's dynamic in some other way?</div>
    <div class="meta">Posted on 2002-06-30 11:18:27 by f0dder</div>
   </div>
   <div class="post" id="post-45904">
    <div class="subject"><a href="#post-45904">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">hmmmm,<br /><br />============<br />Ahem. I am merely pointing out why you shouldn't use memory mapped files for generic memory allocations. It's about using the right tool for the right job, and memory mapped files just isn't the right tool for generic memory allocations. I believe I have given enough reasons why.<br />============<br /><br />You seem to have missed the point here, your notion of the right tool for the job may vary considerably from someone elses.<br /><br />The person who needs a single large block of memory to read and write to that is sharable if necessary has MMFs at their disposal.<br /><br />If memory granularity is what you are worried about, use memory allocation functions that have a fine enough granularity to start with, GlobalAlloc() and OLE string both handle large numbers of small allocations better than functions like VirtualAlloc().<br /><br />Having noted that the tests presented here by Japheth support the standard documentation on memory allocation, I am yet to see the big deal about preferring VirtualAlloc() over all other memory allocation functions when it is a bad choice in many normal applications, particularly when a large number of smaller allocations are needed.<br /><br />For large single blocks, MMFs work well and I guess thats why the inteface has been made available. It finally does not matter if you understand how to use them or not, it is an interface that was published about 7 years ago with the introduction of win95oem and it has been widely used by countless numbers of programmers since.<br /><br />Fortunately the world at large does not have to conform to the world according to f0dder and it just gets on with writing successful applications/drivers/dlls/operating systems etc .... :tongue: <br /><br />regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-06-30 21:44:17 by hutch--</div>
   </div>
   <div class="post" id="post-45907">
    <div class="subject"><a href="#post-45907">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">Once again you have chosen to misinterpret what I have written. If you<br />want to reply to this, please read through the following post carefully.<br />I have tried to state my views very clearly this time, to avoid<br />misunderstandings along the lines of &quot;...preferring VirtualAlloc() over<br />all other memory allocation functions...&quot;.<br /><br />I don't say you shouldn't use MMF for shared memory, as that is one of<br />the main points of using MMF - and one of the few ways (if not the only<br />way?) of allocating shared memory with the WIN32 API. I am, however,<br />stating that it's not good for *generic* allocations, as the memory<br />access is slower, and you use (on 9x) address space from the shared<br />memory region. I hope you aren't saying that memory access to MMF isn't<br />slower than 'ordinary' access, because it is. I have empirical and<br />theoretical data to back up this claim.<br /><br />Furthermore I don't say you should use VirtualAlloc instead of HeapAlloc,<br />OLE memory, or whatever... I say that VirtualAlloc is good for large<br />allocations where page alignment can be a nice thing, and that it is a<br />nice way to allocate memory when you need certain page protection. I think<br />I even stated that it would be foolish to use VirtualAlloc for lots of small<br />allocations - if not, I have done so now. I've never claimed that<br />VirtualAlloc is the holy grail, it has characteristics that makes it less<br />generic-purpose than eg HeapAlloc, namely the 4k granularity of allocations,<br />and the inability to reallocate the memory blocks. It is, however, more<br />generic purpose than MMF - valloc has alignment and granularity equal to<br />MMF, but will allocate from private pools even on 9x, and offers a bit<br />more page-level protection flexibility than MMF.<br /><br />I still believe you shouldn't use the SysAllocString for generic memory<br />allocation. Why? Because that function family is designed for working<br />with BSTRs (length-prefixed unicode strings to those who wonder). Sure,<br />you can use SysAllocStringByteLen with the string argument set to NULL<br />to get a chunk of memory... but I'd advice anybody thinking about doing<br />this to take a look at the code path of this function.<br />Furthermore, when you can use HeapAlloc (which, after all, was designed<br />with versatile memory allocation in mind), why &quot;hack&quot; around with string<br />allocation functions to emulate &quot;normal&quot; memory allocation? I fail to see<br />any clear advantage in doing this, unless it turns out that allocation and<br />deallocation speeds are faster than the Heap* family. SysAllocString*<br />requires you to map in oleaut32.dll (and thus ole32.dll and a bunch of<br />other DLLs), and while this isn't too bad (the DLLs ought to be already<br />loaded by other processes), it does mean a little extra memory is wasted<br />on the additional page table entries. Furthermore, SysAllocString* has<br />long code paths, and internally depend on Co* functions (Co* == COM, right?).<br /><br />I think I'm going to do testing of allocation/deallocation speed of the<br />various memory allocation methods within the next few days, as these ought<br />to vary a lot more than the actual data access speed of the memory.<br />As I already mentioned, the code path for SysAllocStringByteLen is *long*,<br />and I doubt it will be faster than HeapAlloc. I believe hutch talked about<br />SysAllocString* being 'preallocated' from 'string pools' (correct me if I'm<br />wrong, but that's how I read your post). However, the address returned by<br />this function lies in the same range as that returned by VirtualAlloc,<br />HeapAlloc (and all the other ordinary private memory functions),<br />so the idea that this memory is 'preallocated' doesn't seem very likely to me.<br />The addresses my 256meg allocations gave were the following (note that the<br />addresses are the same each time the program is run, at least as long as<br />there haven't been any major memory-related changes in the system):<br /><pre><code><br />VirtualAlloc&#58; 0AC70000<br />HeapAlloc&#58; 0AC70020<br />SysAllocStringByteLen&#58; 0AC70024<br /></code></pre><br />Of course 'preallocated' could mean the system keeps a separate pool of<br />zero-inited pages (ie pages that can be give directly to a usermode memory<br />allocation request because the kernel knows the state of these pages to be<br />clean and zeroed), but I doubt this.<br /><br />Please note that I don't discourage people from using the SysAllocString*<br />API family, it does seem to be fine and dandy when you're working with BSTRs.<br />I just discourage the use of it for 'generic' memory allocation. Also I believe<br />it could be advantagous to code your own BSTR handling routines - there seems to<br />be an awful lot of code in the SysAllocString* family for what it does.<br /><br />Btw, SysAllocStringByteLen has the same access speed as the HeapAlloc and<br />friends, so it seems to me like it's just ordinary demand-zero memory allocation.<br />Matters would of course be different if you use a non-NULL string argument, as<br />the memory is then initialized... but then you have longer setup time, and you<br />can't specify that you want a memory allocation larger than your source string.<br /><br />Obviously the internals of the various functions can be changed by microsoft as<br />long as the interface keeps the same, and the functions keep on doing what<br />PlatformSDK says they do. Also there are probably some differences between the<br />way 9x and NT handles things - which is why I plan to do testing on both, and<br />advice people to do their own tests as well. But even though you should treat<br />the win32 API as a &quot;black box&quot;, I do believe it's advantagous to examine the<br />implementation... if this leads to the discovery that two seemingly identical<br />functions have different performance, well, then you can use this knowledge<br />to choose the fastest of the two and be happy.<br />While the implementations might change in the next version of windows, or even<br />in the next service pack, there are certain characteristics that are bound to<br />stay the same... VirtualAlloc and MMF will have higher granularity and better<br />alignment than Heap*, VirtualAlloc will allow more pagelevel protection flags<br />than the other routines, MMF is very likely to remain slower than the rest,<br />and so on.<br /><br />Let's try and be technical instead of playing with words politician-style.<br />This is the win32asmboard, and I believe the idea is to have good performance,<br />know what you are talking about, and choosing the right tool for the job... no?</div>
    <div class="meta">Posted on 2002-06-30 22:44:55 by f0dder</div>
   </div>
   <div class="post" id="post-45909">
    <div class="subject"><a href="#post-45909">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">Hutch and f0dder....you guys are certainly keeping me entertained. I understand perhaps 20% of what you are saying because i'm a newbie but i find myself always checking email when i log on just to see if there is anything new in this thread.<br /><br />You both have my applaud.<br /><br />:alright:</div>
    <div class="meta">Posted on 2002-06-30 22:47:03 by IwasTitan</div>
   </div>
   <div class="post" id="post-45910">
    <div class="subject"><a href="#post-45910">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">Titan: I just hope you will choose to do your own experimentation<br />rather than trust any of us blindly. And that you will take more heed<br />of well-founded technical material than simple word twisting.</div>
    <div class="meta">Posted on 2002-06-30 22:49:11 by f0dder</div>
   </div>
   <div class="post" id="post-45928">
    <div class="subject"><a href="#post-45928">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">Since this is such an interesting thing I have extended my little test prog to measure time (very simple though). The results for Win98 are a bit surprizing:<br /><br />- VirtualAlloc and MapViewOfFile are almost equally fast<br />- LocalAlloc, CoTaskMemAlloc have a 10% performance penalty<br />- SysAlloc... has a 15 % performance penalty<br /><br />This is only true if no disk activity results from the request. But increasing the paging file size doesn't definitely mean there is disk activity.<br /><br />Thats my test prog (changed to GUI now to avoid instance faults from VM switching in console apps):<br /><br /><pre><code><br />;/*  dont delete, needed to make RC ignore the ASM lines<br /><br />;--- Win32 alloc test<br /><br />        .586<br />        .Model flat,stdcall<br />        option casemap&#58;none<br /><br />        include \masm32\include\windows.inc<br />        include \masm32\include\kernel32.inc<br />        include \masm32\include\user32.inc<br />        include \masm32\include\ole32.inc<br />        include \masm32\include\oleaut32.inc<br /><br />IDD_DIALOG1     equ 101<br />IDC_LIST1       equ 1000<br />IDC_NORMAL      equ 1001<br />IDC_COALLOC     equ 1002<br />IDC_SYSALLOC    equ 1003<br />IDC_VIRTALLOC   equ 1004<br />IDC_ZEROFILL    equ 1005<br />IDC_MAPVIEW     equ 1006<br /><br />MEMSIZE equ 7000000h     ;112 MB<br /><br />ListBox_AddString macro x,y<br />    invoke SendMessage, x, LB_ADDSTRING, 0, y<br />    endm<br /><br />CStr macro y&#58;req<br />local sym<br />    .const<br />    ifidni &lt;y&gt;,&lt;&quot;&quot;&gt;<br />sym db 0<br />    else<br />sym db y,0<br />    endif<br />    .code<br />    exitm &lt;offset sym&gt;<br />    endm<br /><br />        .data<br /><br />g_handle    DWORD 0<br /><br />        .code<br /><br />DoAlloc proc uses esi hWnd&#58;HWND, iMode&#58;DWORD<br /><br />local hWndLB&#58;HWND<br />local pszFormat&#58;LPSTR<br />local tsc&#58;QWORD<br />local szText&#91;128&#93;&#58;byte<br /><br />        invoke GetDlgItem, hWnd, IDC_LIST1<br />        mov hWndLB,eax<br /><br />        rdtsc<br />        mov dword ptr tsc+0,eax<br />        mov dword ptr tsc+4,edx<br /><br />        mov eax, iMode<br />        .if &#40;eax == IDC_SYSALLOC&#41;<br />            invoke SysAllocStringByteLen, NULL, MEMSIZE<br />            mov pszFormat,CStr&#40;&quot;SysAllocStringByteLen returned %X&quot;&#41;<br />        .elseif &#40;eax == IDC_COALLOC&#41;<br />            invoke CoTaskMemAlloc, MEMSIZE<br />            mov pszFormat,CStr&#40;&quot;CoTaskMemAlloc returned %X&quot;&#41;<br />        .elseif &#40;eax == IDC_VIRTALLOC&#41;<br />            invoke VirtualAlloc, NULL, MEMSIZE, MEM_COMMIT, PAGE_READWRITE<br />            mov pszFormat,CStr&#40;&quot;VirtualAlloc returned %X&quot;&#41;<br />        .elseif &#40;eax == IDC_MAPVIEW&#41;<br />            invoke CreateFileMapping, -1, NULL, PAGE_READWRITE, 0, MEMSIZE, NULL<br />            .if &#40;eax != NULL&#41;<br />                invoke MapViewOfFile, eax, FILE_MAP_WRITE, 0, 0, MEMSIZE<br />                mov pszFormat,CStr&#40;&quot;MapViewOfFile returned %X&quot;&#41;<br />            .else<br />                mov pszFormat,CStr&#40;&quot;CreateFileMapping returned %X&quot;&#41;<br />            .endif<br />        .else<br />            invoke LocalAlloc, LMEM_FIXED, MEMSIZE<br />            mov pszFormat,CStr&#40;&quot;LocalAlloc returned %X&quot;&#41;<br />        .endif<br />        mov g_handle,eax<br /><br />        rdtsc<br />        sub eax,dword ptr tsc+0<br />        sbb edx,dword ptr tsc+4<br />        push eax<br />        push edx<br /><br />        invoke wsprintf, addr szText, pszFormat, g_handle<br />        ListBox_AddString hWndLB, addr szText<br /><br />        pop edx<br />        pop eax<br /><br />        .if &#40;edx&#41;<br />            invoke wsprintf, addr szText, CStr&#40;&quot;Time was %X%08X&quot;&#41;,edx,eax<br />        .else<br />            invoke wsprintf, addr szText, CStr&#40;&quot;Time was %X&quot;&#41;,eax<br />        .endif<br />        ListBox_AddString hWndLB, addr szText<br /><br />        ret<br />DoAlloc endp<br /><br />dlgproc proc hWnd&#58;HWND, message&#58;DWORD, wParam&#58;WPARAM, lParam&#58;LPARAM<br /><br />        mov eax,message<br />        .if &#40;eax == WM_INITDIALOG&#41;<br />            mov eax,1<br />        .elseif &#40;eax == WM_CLOSE&#41;<br />            invoke EndDialog, hWnd, 0<br />        .elseif &#40;eax == WM_COMMAND&#41;<br />            movzx eax,word ptr wParam+0<br />            .if &#40;eax == IDCANCEL&#41;<br />                invoke EndDialog, hWnd, 0<br />            .elseif &#40;eax == IDC_LIST1&#41;<br /><br />            .elseif &#40;eax == IDC_ZEROFILL&#41;<br />                .if &#40;g_handle&#41;<br />                    push edi<br />                    mov edi,g_handle<br />                    mov ecx,MEMSIZE/4<br />                    xor eax,eax<br />                    rep stosd<br />                    pop edi<br />                .endif<br /><br />            .else<br />                invoke DoAlloc, hWnd, eax<br />            .endif<br />            xor eax,eax<br />        .else<br />            xor eax,eax<br />        .endif<br />        ret<br />dlgproc endp<br /><br />WinMain proc hInstance&#58;HINSTANCE, hPrevInst&#58;HINSTANCE, lpszCmdLine&#58;LPSTR,iCmdShow&#58;sdword <br /><br />        invoke CoInitialize, NULL<br />        invoke DialogBoxParam, hInstance, IDD_DIALOG1, 0, dlgproc, 0<br />        invoke CoUninitialize<br />        ret<br /><br />WinMain endp<br /><br />WinMainCRTStartup proc public<br />        invoke GetModuleHandle, NULL<br />        invoke WinMain, eax, 0, 0, 0<br />        invoke ExitProcess, eax<br />WinMainCRTStartup endp<br /><br />        end<br />;*/<br /><br />#include &quot;\masm32\include\resource.h&quot;<br /><br />#define IDD_DIALOG1                     101<br />#define IDC_LIST1                       1000<br />#define IDC_NORMAL                      1001<br />#define IDC_COALLOC                     1002<br />#define IDC_SYSALLOC                    1003<br />#define IDC_VIRTALLOC                   1004<br />#define IDC_ZEROFILL                    1005<br />#define IDC_MAPVIEW                     1006<br /><br /><br />/////////////////////////////////////////////////////////////////////////////<br />// Dialog<br /><br />IDD_DIALOG1 DIALOG DISCARDABLE  0, 0, 188, 216<br />STYLE DS_MODALFRAME | DS_CENTER | WS_POPUP | WS_CAPTION | WS_SYSMENU<br />CAPTION &quot;Alloc Test&quot;<br />FONT 8, &quot;MS Sans Serif&quot;<br />BEGIN<br />    PUSHBUTTON      &quot;VirtualAlloc&quot;,IDC_VIRTALLOC,7,172,50,14<br />    PUSHBUTTON      &quot;LocalAlloc&quot;,IDC_NORMAL,64,173,50,14<br />    PUSHBUTTON      &quot;CoTaskMemAlloc&quot;,IDC_COALLOC,121,174,60,14<br />    PUSHBUTTON      &quot;SysAllocString&quot;,IDC_SYSALLOC,7,195,50,14<br />    PUSHBUTTON      &quot;ZeroFill&quot;,IDC_ZEROFILL,121,195,60,14<br />    LISTBOX         IDC_LIST1,7,7,174,159,LBS_NOINTEGRALHEIGHT | WS_VSCROLL | <br />                    WS_TABSTOP<br />    PUSHBUTTON      &quot;MapViewOfFile&quot;,IDC_MAPVIEW,64,195,50,14<br />END<br /><br />/* extract following lines to file TEST.MAK.<br /><br />NAME=test<br /><br />ASM=\masm32\bin\ml -c -coff<br />LINK=\masm32\bin\link<br />RC=\masm32\bin\rc<br />LOPTS= /LIBPATH&#58;\masm32\lib /SUBSYSTEM&#58;WINDOWS<br />LIBS=kernel32.lib user32.lib ole32.lib oleaut32.lib<br /><br />$&#40;NAME&#41;.exe&#58; $*.obj $*.mak $*.res<br />    $&#40;LINK&#41; $*.obj $*.res $&#40;LOPTS&#41; $&#40;LIBS&#41;<br /><br />$&#40;NAME&#41;.obj&#58; $*.asm $*.mak<br />    $&#40;ASM&#41; $*.asm<br /><br />$&#40;NAME&#41;.res&#58; $*.asm $*.mak<br />    $&#40;RC&#41; $*.asm<br />*/<br /></code></pre><br /><br />And for checking of page faults and pageing file size I have used <br /><br /><a target="_blank" href="http://www.japheth.de/Download/memstat.zip">Click to download</a> which works regretably for Win9x only.</div>
    <div class="meta">Posted on 2002-07-01 04:05:36 by japheth</div>
   </div>
   <div class="post" id="post-45931">
    <div class="subject"><a href="#post-45931">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">I have just posted a tool in the MASM32 forum for testing different types of memory that are documented in the Windows API calls.<br /><br />The test was to determine half the available physical memory up to a limit of 100 meg.<br /><br />Selection of the memory allocation type runs a test of allocating the amount of memory, filling it with zeros and displaying the results in milliseconds. It deallocates the memory on exit from the test procedure.<br /><br />Each test procedure has the same setup and overhead and is clocked locally to ensure that other factors in the code do not effect the time.<br /><br />On my win95b, they all go past the post at very close to the same times, so close that the times overlap, the &quot;MapViewOfFile&quot; method uses about 1 megabyte more memory which is accounted for by its overhead and usage.<br /><br />Not tested on NT/2k/XP. (shrug) Could not be bothered turning the NT box on.<br /><br />LATER: Tested on NT4 sp6a on my old AMD. Results much the same, the display of Percentage Used fails but the tests run OK.<br /><br />Do the numbers speak falsely ? I doubt it.<br /><br />f0dder,<br /><br />Perhaps if you concentrated more on mammary than memory you would do better. :tongue: <br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-07-01 04:47:02 by hutch--</div>
   </div>
   <div class="post" id="post-45957">
    <div class="subject"><a href="#post-45957">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">I modified my benchmark to have the ability to do a full<br />memory fill instead of just per-page touching, as that<br />*is* usually a more realistic usage pattern of the memory.<br />It is clear that the overhead of MMF and static allocation<br />becomes smaller this way, for obvious reasons: there will<br />be the same amount of pagefaults, but more time is spent<br />per page, so it doesn't feel as bad. It is however clear<br />that MMF and static memory still is slower to access than<br />the other memory allocation methods. 40ms might not seem<br />too bad for a 256meg fill, but the speed difference is<br />there nonetheless.<br /><br />I am still timing the memory access separately from the<br />time taken for allocating/deallocating the memory; testing<br />will be done on alloc/dealloc speed later, and with other<br />parameters (lots of small blocks instead of one large).<br /><br />Note that I realized my &quot;bigmem.nas&quot; had a flaw, namely<br />two 0x5000000 instead of two 0x8000000 - fixed now.<br /><br />The tests were run 5 times, and the mean value was chosen.<br />There weren't big fluctuations between the various values<br />(max ~10ms), and usually only one or two runs were off.<br /><br />athlon700, 512megs of ram, win2k-sp2 - buffersize set at 256 megs<br /><pre><code><br />VirtualAlloc		1032ms<br />HeapAlloc		1032ms<br />MMF			1072ms<br />static			1072ms<br />CoTaskMemAlloc		1032ms<br />GlobalAlloc		1032ms<br />SysAllocStringByteLen	1032ms<br /></code></pre><br /><br />Now, the results on the 98 box were rather interesting :)<br />All routines clocked around the same average. So, either the<br />memory allocations were too small to show deviations, or<br />the memory access speed on 9x is the same for all types.<br />It is wellknown that 9x and NT are rather different in how<br />they handle stuff, so the latter is probably the cause.<br /><br />k6-2 333mhz, 64megs of ram, win98SE - buffersize set at 64 megs<br /><pre><code><br />VirtualAlloc		1650ms<br />HeapAlloc		1650ms<br />MMF			1650ms<br />static			1650ms<br />CoTaskMemAlloc		1650ms<br />GlobalAlloc		1650ms<br />SysAllocStringByteLen	1650ms<br /></code></pre><br /><br />However, I still do discourage people from using MMF as<br />a generic memory allocation method when shared memory is not<br />needed... on 9x, the memory is allocated from the shared<br />region (limited resource), which also meansa buffer overrun<br />can be a lot more severe than from a private pool. And the<br />memory access *is* slower on NT. Sure, the speed hit should<br />only be there on first access (or if the pages need to be<br />swapped out later), but it's there nonetheless.<br /><br />More information will be posted when I have tested the<br />allocation/deallocation speed of the various routines.<br />I expect it will be hard seeing too much speed difference<br />between allocation/deallocation speed of the various routines<br />(except that MMF will probably have somewhat higher overhead),<br />but we'll see.</div>
    <div class="meta">Posted on 2002-07-01 08:54:51 by f0dder</div>
   </div>
   <div class="post" id="post-45975">
    <div class="subject"><a href="#post-45975">Allocating a bunch of smaller blocks</a></div>
    <div class="body">To be able to compare these methods fairly, they will have to be<br />put into two categories. The first category gives so-called &quot;0page&quot;<br />memory - this means the memory blocks are guaranteed to be zero-filled<br />(demand-0, not &quot;zero when allocated&quot;). The second group is uninitialized<br />and can contain arbitrary data. Taking this into account, it's not too<br />strange that CoTaskMemAlloc and SysAllocStringByteLen are faster than<br />the other routines.<br /><br />Test parameters:<br />NUMBLOCKS	equ	&lt;1024*16&gt;<br />BLOCKSIZE	equ	&lt;4096&gt;<br />Athlon700, 512meg ram, win2k-sp2<br />Results:<br />;##### 0page ################<br />VirtualAlloc:		800<br />HeapAlloc:		340<br />GlobalAlloc:		340<br />MMF:			1161<br />;##### Uninit ###############<br />HeapAlloc w/o ZERO_MEM:	150<br />CoTaskMemAlloc:		150<br />SysAllocStringByteLen:	130<br />f0dderCoMalloc:		150<br /><br />There's a couple of things, however, that does surprise me. First,<br />the rather slow speed of VirtualAlloc - since it's a rather 'primitive'<br />function I had assumed it would be fast. Ok, I was wrong - so I guess<br />you should only use VirtualAlloc if you need the alignment or page<br />protection flags (or address space reservation) it provides, not just<br />for any &quot;huge buffer&quot; allocations. I will still be using it myself for<br />eg framebuffer allocation.<br /><br />It initially surprised me that SysAllocStringByteLen is faster than<br />CoTaskMemAlloc, as both use COM memory allocation routines (the<br />IMalloc interface, retrieved by CoGetMalloc). I discovered the cause<br />while writing &quot;f0dderCoMalloc&quot; (a small piece of code that uses the<br />IMalloc interface (calls CoGetMalloc once at program startup,<br />and uses this object later)). It is identical in functionality to<br />CoTaskMemAlloc, and was included so those without disassembling or<br />tracing capabilities can see how CoTaskMemAlloc works.<br /><br />SysAllocStringByteLen has quite some code. As far as I can see, it<br />allocates a IMalloc object per thread. It calls TlsGetValue to get<br />the ppmalloc pointer; it returnvalue is zero it calls a routine to<br />allocate a IMalloc interface (and do a bunch of other stuff), and<br />will save this value with TlsSetValue.<br /><br />The memory allocation size is adjusted ((allocsize + 0x15) &amp; 0x0FFFFFFF0),<br />and this is what causes the speed difference - if I adjust the memory<br />size like this for CoTaskMemAlloc or f0dderCoMalloc, I get identical<br />speeds.<br /><br />When SysAllocStringByteLen is done allocating memory, it checks if the<br />'len' parameter is zero - if not, it copies the source string. Finally<br />it zero-terminates the string. It also stores the string length in the<br />memory block (four bytes before the returned pointer).<br /><br />It seems that SysAllocStringByteLen keeps 3 pools with 6 entries each,<br />for blocks of &lt;=0x20, &lt;=0x40 and &lt;=0x100 for faster string allocations.<br />The pools are initially empty, but when you SysFreeString they will be<br />filled rather than freeing the string right away.<br /><br />Sure, this will make later allocations faster, but if you aren't dealing<br />with strings, I'd say it's advantagous to code your own similar scheme,<br />which can skip all the Tls stuff, various string-related checks, string<br />copying et cetera. And furthermore you can set the pool sizes to get<br />optimal performance for the task at hand.<br /><br />So, what should one use? HeapAlloc seems a good choice for generic<br />allocations, as it can provide both uninitialized and demand-zero memory.<br />It has same speed as similar functions, on NT it maps directly to<br />NTDLL.RtlAllocateHeap (without parameter conversion stages of Global/LocalAlloc).<br /><br />The SysAllocString* family seems nice if you work with BSTRs, as they<br />handle a lot of stuff for you - but it might be beneficial to code your<br />own BSTR handling routines as you can probably do the string copying<br />etc faster.<br /><br />Don't see much reason to use CoTaskMemAlloc or the IMalloc interface<br />instead of HeapAlloc, but there might be some reason I have missed -<br />I should probably do further testing with different block sizes...<br />I don't think there will be much difference, but time will tell.<br /><br />Time to go do some testing on 9x :).</div>
    <div class="meta">Posted on 2002-07-01 12:27:25 by f0dder</div>
   </div>
   <div class="post" id="post-45981">
    <div class="subject"><a href="#post-45981">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">Compliments f0dder, you have done some good research work here.<br /><br />Still, there ain't nothing wrong with mammary. :tongue: <br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-07-01 13:03:14 by hutch--</div>
   </div>
   <div class="post" id="post-45982">
    <div class="subject"><a href="#post-45982">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">Here's the tests from my kid brothers' 98SE box. 64 megs of ram,<br />k6-2 333mhz. Note that VirtualAlloc is by far the fastest function<br />here - I assume results would be different if I had allocated only<br />about half of available system memory.<br /><br /><pre><code><br />virtualalloc&#58;	515<br />HeapAlloc&#58;	2880<br />HeapAlloc zero&#58;	3350<br />MMF&#58;		didn't complete... too slow.<br />CoTaskMemAlloc&#58;	2880<br />GlobalAlloc&#58;	3400<br />SysAlloc##&#58;	3025<br />f0dderCoMalloc&#58;	2880<br /></code></pre><br /><br />No, nothing wrong with mammary, but that is hardly related to<br />this subject in any way.</div>
    <div class="meta">Posted on 2002-07-01 13:12:02 by f0dder</div>
   </div>
   <div class="post" id="post-45983">
    <div class="subject"><a href="#post-45983">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">Guess I ought to post the updated test program as well.<br />I am in the process of preparing an essay about this whole memory<br />allocation thing and some technical explanations as to what is<br />going on - will hopefully be done in a couple of days; I ain't doing<br />much else before thursday where me and a couple of mates are<br />going sailing (if the weather permits).</div>
    <div class="meta">Posted on 2002-07-01 13:14:06 by f0dder</div>
   </div>
   <div class="post" id="post-45986">
    <div class="subject"><a href="#post-45986">Global Memory is slow! - use Heap functions...</a></div>
    <div class="body">Grin,<br /><br />==============<br />No, nothing wrong with mammary, but that is hardly related to this subject in any way.<br />==============<br /><br />The secret is in the pronunciation, if you get it right, you could sound like a MAC user. :grin: <br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-07-01 13:18:43 by hutch--</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=6314&amp;page=1" style="">&laquo;</a><a href="../?id=6314&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="6314" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>