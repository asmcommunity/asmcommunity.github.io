<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Switching between protected and real mode. - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25209" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25209">Switching between protected and real mode.</a></p>
   <div class="post" id="post-184497">
    <div class="subject"><a href="#post-184497">Switching between protected and real mode.</a></div>
    <div class="body">Hello.<br /><br />Im trying to write my own kernel. I loaded it with GRUB. Everything was going good until i tried to switch back to real mode. After several hours i managed to do that. Then i tryed to jump back to protected mode. I setuped Gtd, updated cr0 and while far jump emulators just hanged. What i should do to go back to pmode?<br /><br /><pre><code><br />format elf executable at 1024*1024<br />entry _kernel<br /><br />MB_4KBPAGE_ALIGN = 1 shl 0<br />MB_MEMORY_INFO&nbsp;  = 1 shl 1<br /><br />MB_HEADER_MAGIC&nbsp; = 0x1BADB002<br />MB_HEADER_FLAGS&nbsp; = MB_4KBPAGE_ALIGN or MB_MEMORY_INFO<br />MB_CHECKSUM&nbsp; &nbsp; &nbsp; = -MB_HEADER_MAGIC-MB_HEADER_FLAGS<br /><br />SEGMENT_RING0&nbsp; &nbsp; = 10010000b<br /><br />SEGMENT_RW&nbsp; &nbsp; &nbsp;  = 0010b<br />SEGMENT_RE&nbsp; &nbsp; &nbsp;  = 1010b<br /><br />SEGMENT_4KB&nbsp; &nbsp; &nbsp; = 1000b<br />SEGMENT_USE32&nbsp; &nbsp; = 0100b<br /><br />macro GDT_ITEM limit,base,access,granularity<br />{<br />	dw limit and 0xFFFF<br />	dw base and 0xFFFF<br />	db (base shr 16) and 0xFF<br />	db access<br />	db ((limit shr 16) and 0x0F) or ((granularity) shl 4)<br />	db (base shr 24) and 0xFF<br />}<br /><br />segment<br />multiboot_header:<br />	.magic dd MB_HEADER_MAGIC<br />	.flags dd MB_HEADER_FLAGS<br />	.checksum dd MB_CHECKSUM<br /><br />_kernel:<br />	mov esp, kStack<br /><br />	; Load new GDT and set segment registers.<br />	<br />	lgdt <br />	<br />	mov ax, GDT_RING0_DATA<br />	mov ds, ax<br />	mov es, ax<br />	mov fs, ax<br />	mov gs, ax<br />	mov ss, ax<br /><br />	; Flush CS.<br />	<br />	jmp GDT_RING0_CODE : .pmode_flush<br /><br />.pmode_flush:<br /><br />	; Load real mode IDT.<br /><br />	lidt <br /><br />	; Copying real mode code to under 1MB.<br />	mov edi, 0x7C000<br />	mov esi, RealModeCode<br />	mov ecx, length.RealModeCode<br /><br />	rep movsb<br />	<br />	; Jumping to segment with 64kb limit. Base is set to .rmode_flush.<br />	<br />	jmp GDT_RMODE_CODE : 0<br /><br />.rmode_flush:<br />org 0<br />use16<br />	mov ax, GDT_RMODE_DATA<br />	mov ds, ax<br />	mov es, ax<br />	mov fs, ax<br />	mov gs, ax<br />	mov ss, ax<br /><br />	; Cleaning PE bit in cr0.<br />	<br />	mov eax, cr0<br />	and al, not 1<br />	mov cr0, eax<br />	<br />	; Jumping to 0x7C000.<br />	jmp 0x7C00 : 0<br /><br />org $ + _kernel.rmode_flush<br />use32<br /><br />; Code is copied to 0x7c000, so execution will follow from here.<br /><br />RealModeCode:<br />org 0x7C00<br />use16<br />	; Setting segment registers.<br />	mov ax, cs<br />	<br />	mov ds, ax<br />	mov es, ax<br />	mov fs, ax<br />	mov gs, ax<br />	mov ss, ax<br /><br />	sti<br />	<br />	mov ax,0x4F02<br />	mov bx,0x4112<br />	int 10h<br />	<br />	cli<br />	<br />	; To that part everyting is good.<br /><br />	lgdt <br />	<br />	mov eax, cr0<br />	or al, 1<br />	mov cr0, eax<br />	<br />	; And error occurs here...<br />	<br />	jmp RMGDT_RING0_CODE : .back_to_pmode<br />.back_to_pmode:<br /><br />	hlt<br /><br />rmGdtr:<br />	.size dw rmGdt_size<br />	.addr dd rmGdt<br />	<br />rmGdt:<br />	GDT_ITEM 0, 0, 0, 0<br />	RMGDT_RING0_CODE = $ - rmGdt<br />	<br />	GDT_ITEM 0xFFFFF, 0, (SEGMENT_RING0 + SEGMENT_RE), (SEGMENT_4KB + SEGMENT_USE32)<br />	<br />	rmGdt_size = $ - rmGdt - 1<br />	<br />length.RealModeCode = $ - 0x7C00<br /><br />org $ + RealModeCode - 0x7c00<br />use32<br />	<br />rmIdtr:<br />	.size dw 1023<br />	.addr dd 0<br /><br />Gdt:<br />	.size dw Gdt_size<br />	.addr dd Gdt_array<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />Gdt_array:<br />	GDT_ITEM 0, 0, 0, 0<br />	GDT_RING0_CODE = $ - Gdt_array<br />	GDT_ITEM 0xFFFFF, 0, SEGMENT_RING0 or SEGMENT_RE, SEGMENT_4KB or SEGMENT_USE32<br />	GDT_RING0_DATA = $ - Gdt_array<br />	GDT_ITEM 0xFFFFF, 0, SEGMENT_RING0 or SEGMENT_RW, SEGMENT_4KB or SEGMENT_USE32<br /><br />	GDT_RMODE_CODE = $ - Gdt_array<br />	GDT_ITEM 0xFFFF, _kernel.rmode_flush, SEGMENT_RING0 or SEGMENT_RE, 0<br />	GDT_RMODE_DATA = $ - Gdt_array<br />	GDT_ITEM 0xFFFF, _kernel.rmode_flush, SEGMENT_RING0 or SEGMENT_RW, 0<br />Gdt_size = $ - Gdt_array - 1<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />segment<br />	rb 1024<br />	kStack:<br /></code></pre></div>
    <div class="meta">Posted on 2006-08-15 16:11:10 by Trolek</div>
   </div>
   <div class="post" id="post-184500">
    <div class="subject"><a href="#post-184500">Re: Switching between protected and real mode.</a></div>
    <div class="body">Off-hand, you do not need a &quot;Real Mode IDT&quot;, as Interrupts default to the IVT@0000:0000 in Real Mode, so this part of the code is useless.<br /><br />Part of the problem may be the fact that you did not put &quot;use32&quot; before the &quot;.back_to_pmode&quot; label, which might exclude the needed far jump. At any rate, open-up your loader binary in a hex editor/disassembler and check that area for the far jmp opcode (0xEA).<br /><br />For more info, read <a target="_blank" href="http://www.nondot.org/sabre/os/files/ProtectedMode/voodoo.asm"><u>THIS DOC</u></a> involving Unreal/Voodoo/Flat mode, it incorporates similar concepts as what you are trying to achieve.</div>
    <div class="meta">Posted on 2006-08-15 23:03:55 by SpooK</div>
   </div>
   <div class="post" id="post-184501">
    <div class="subject"><a href="#post-184501">Re: Switching between protected and real mode.</a></div>
    <div class="body">I noticed that the main reason that you&#39;re going back to real mode is to set the video mode.<br /><br />If it was just to update the GDT and CR0, you could do that from protected mode, but setting the video mode is one of those excessively painful things to do from protected mode.&nbsp; If you had infinite time on your hands, an awesome thing to write would be some code that reverse-engineers the real mode code for int 10h,4F02h so that you could dynamically create the driver for it, but sadly, that&#39;s probably not going to happen.<br /><br />Debugging code surrounding mode switches is a pain in the butt; I&#39;ve definitely been there.&nbsp; A feasible alternative, though is to not rely on GRUB, and simply write your own bootloader or modify an existing one.&nbsp; You can check out my Master Boot Record in <a target="_blank" href="http://pwnos.googlecode.com/svn/trunk/Boot/Boot.asm">http://pwnos.googlecode.com/svn/trunk/Boot/Boot.asm</a>&nbsp; It starts from real mode, disables interrupts, loads the following 62 sectors (31KB), clears gate A20 (though it seems to always be clear already), selects a video mode of the desired resolution and switches to it, loads a GDT and IDT, and switches to protected mode, all in under 512 bytes, with enough room left over for the partition table.&nbsp; Using a custom bootloader does mean that you&#39;d probably want alternative media to boot from, like a USB key or floppy disk, but it looks like it might actually save you some trouble in this case.&nbsp; After all, you&#39;re writing almost all of your own bootloader anyway, since GRUB doesn&#39;t do much for you.<br /><br />In the near future, I&#39;ll be getting the rest of my bootloader working again, and at one point it was reading from NTFS partitions, (which could be swapped out for any other filesystem), and booting dual processors, (it just seems not to work at all on a single processor, which is what my laptop has).<br /><br />Best of luck to ya!</div>
    <div class="meta">Posted on 2006-08-15 23:57:48 by hackulous</div>
   </div>
   <div class="post" id="post-184503">
    <div class="subject"><a href="#post-184503">Re: Switching between protected and real mode.</a></div>
    <div class="body">Instead of switching back and forth between pm/rm, what about setting up a v86 task for BIOS-calling?<br /></div>
    <div class="meta">Posted on 2006-08-16 02:54:25 by f0dder</div>
   </div>
   <div class="post" id="post-184507">
    <div class="subject"><a href="#post-184507">Re: Switching between protected and real mode.</a></div>
    <div class="body">Im too lazy to write my own video driver and Im tired of trying to switch from one mode to another. As f0dder said, I should setup a V86 task and give myself a break. Thanks for that. :)</div>
    <div class="meta">Posted on 2006-08-16 08:13:18 by Trolek</div>
   </div>
  </div>
 </body>
</html>