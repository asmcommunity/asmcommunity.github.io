<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>WSAAsyncSelect query - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29708" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29708">WSAAsyncSelect query</a></p>
   <div class="post" id="post-209786">
    <div class="subject"><a href="#post-209786">WSAAsyncSelect query</a></div>
    <div class="body">Hi Guys<br /><br />Am trying to use WSAAsyncSelect on my socket like below. I&#039;ve asked WSAAsyncSelect to listen for - FD_ACCEPT + FD_READ. I believe it works... But will FD_READ event occur when we put a socket in listen mode? When the FD_READ event triggers am trying to read from the socket, will it work?<br /><br /><pre><code>.386 <br />.model flat,stdcall <br />option casemap:none <br />include &nbsp; &nbsp; &nbsp; &nbsp; \masm32\include\winmm.inc<br />include &nbsp; &nbsp; &nbsp; &nbsp; \masm32\include\windows.inc<br />include &nbsp; &nbsp; &nbsp; &nbsp; \masm32\include\masm32.inc<br />include &nbsp; &nbsp; &nbsp; &nbsp; \masm32\include\wsock32.inc<br />include &nbsp; &nbsp; &nbsp; &nbsp; \masm32\include\user32.inc<br />include &nbsp; &nbsp; &nbsp; &nbsp; \masm32\include\kernel32.inc<br />include &nbsp; &nbsp; &nbsp; &nbsp; \masm32\include\advapi32.inc<br />include &nbsp; &nbsp; &nbsp; &nbsp; \masm32\include\shell32.inc<br /><br />includelib &nbsp; &nbsp; &nbsp;\masm32\lib\shell32.lib<br />includelib &nbsp; &nbsp; &nbsp;\masm32\lib\user32.lib<br />includelib &nbsp; &nbsp; &nbsp;\masm32\lib\kernel32.lib<br />includelib &nbsp; &nbsp; &nbsp;\masm32\lib\wsock32.lib<br />includelib &nbsp; &nbsp; &nbsp;\masm32\lib\masm32.lib<br />includelib &nbsp; &nbsp; &nbsp;\masm32\lib\advapi32.lib<br />includelib &nbsp; &nbsp; &nbsp;\masm32\lib\winmm.lib<br /><br />CTEXT MACRO y:VARARG<br />	LOCAL sym<br /><br />	CONST segment<br />		IFIDNI &lt;y&gt;,&lt;&gt;<br />			sym db 0<br />		ELSE<br />			sym db y,0<br />		ENDIF<br />	CONST ends<br /><br />	EXITM &lt;OFFSET sym&gt;<br />ENDM<br /> <br />WinMain proto :DWORD,:DWORD,:DWORD,:DWORD <br /><br />.DATA &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; initialized data <br />ClassName db &quot;SimpleWinClass&quot;,0 &nbsp; &nbsp; &nbsp; <br />AppName db &quot;Our First Window&quot;,0 &nbsp; &nbsp; &nbsp; &nbsp;<br />Port dd 80<br />WM_SOCKET equ WM_USER + 100<br /><br />.DATA? &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Uninitialized data <br />hInstance HINSTANCE ? &nbsp; &nbsp; &nbsp; &nbsp;; Instance handle of our program <br />CommandLine LPSTR ? <br />wsadata WSADATA &lt;&gt;<br />sin sockaddr_in &lt;&gt;<br />sock DWORD ?<br />buf db 200 DUP(?)<br /><br />.CODE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; Here begins our code <br />start: <br />invoke GetModuleHandle, NULL &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />mov hInstance,eax <br />invoke GetCommandLine &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />mov CommandLine,eax <br />invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT &nbsp; &nbsp; &nbsp; &nbsp;<br />invoke ExitProcess, eax &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br /><br />WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD <br /> &nbsp; &nbsp;LOCAL wc:WNDCLASSEX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br /> &nbsp; &nbsp;LOCAL msg:MSG <br /> &nbsp; &nbsp;LOCAL hwnd:HWND <br /><br /> &nbsp; &nbsp;mov &nbsp; wc.cbSize,SIZEOF WNDCLASSEX &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br /> &nbsp; &nbsp;mov &nbsp; wc.style, CS_HREDRAW or CS_VREDRAW <br /> &nbsp; &nbsp;mov &nbsp; wc.lpfnWndProc, OFFSET WndProc <br /> &nbsp; &nbsp;mov &nbsp; wc.cbClsExtra,NULL <br /> &nbsp; &nbsp;mov &nbsp; wc.cbWndExtra,NULL <br /> &nbsp; &nbsp;push &nbsp;hInstance <br /> &nbsp; &nbsp;pop &nbsp; wc.hInstance <br /> &nbsp; &nbsp;mov &nbsp; wc.hbrBackground,COLOR_WINDOW+1 <br /> &nbsp; &nbsp;mov &nbsp; wc.lpszMenuName,NULL <br /> &nbsp; &nbsp;mov &nbsp; wc.lpszClassName,OFFSET ClassName <br /> &nbsp; &nbsp;invoke LoadIcon,NULL,IDI_APPLICATION <br /> &nbsp; &nbsp;mov &nbsp; wc.hIcon,eax <br /> &nbsp; &nbsp;mov &nbsp; wc.hIconSm,eax <br /> &nbsp; &nbsp;invoke LoadCursor,NULL,IDC_ARROW <br /> &nbsp; &nbsp;mov &nbsp; wc.hCursor,eax <br /> &nbsp; &nbsp;invoke RegisterClassEx, addr wc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br /> &nbsp; &nbsp;invoke CreateWindowEx,NULL,\ <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ADDR ClassName,\ <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ADDR AppName,\ <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WS_OVERLAPPEDWINDOW,\ <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CW_USEDEFAULT,\ <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CW_USEDEFAULT,\ <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CW_USEDEFAULT,\ <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CW_USEDEFAULT,\ <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NULL,\ <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NULL,\ <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hInst,\ <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NULL <br /> &nbsp; &nbsp;mov &nbsp; hwnd,eax <br /> &nbsp; &nbsp;<br /> &nbsp; &nbsp;;invoke ShowWindow, hwnd,CmdShow &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp;;invoke UpdateWindow, hwnd &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br /><br /> &nbsp; &nbsp;invoke WSAStartup, 101h, ADDR wsadata<br /><br /> &nbsp; &nbsp;invoke socket, AF_INET, SOCK_STREAM, 0<br /> &nbsp; &nbsp;mov sock, eax<br /><br /> &nbsp; &nbsp;invoke WSAAsyncSelect, sock, hwnd, WM_SOCKET, FD_ACCEPT+FD_READ<br /> &nbsp; &nbsp;mov sin.sin_family, AF_INET<br /><br /> &nbsp; &nbsp;invoke htons, Port<br /> &nbsp; &nbsp;mov sin.sin_port, ax<br /> &nbsp; &nbsp;mov sin.sin_addr, INADDR_ANY<br /><br /> &nbsp; &nbsp;invoke bind, sock, addr sin, SIZEOF sin<br /><br /> &nbsp; &nbsp;invoke listen, sock, 15<br /> &nbsp;<br /> &nbsp; &nbsp;.WHILE TRUE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp;invoke GetMessage, ADDR msg,NULL,0,0 <br /> &nbsp; &nbsp;.BREAK .IF (!eax) <br /> &nbsp; &nbsp; &nbsp; &nbsp;invoke TranslateMessage, ADDR msg <br /> &nbsp; &nbsp; &nbsp; &nbsp;invoke DispatchMessage, ADDR msg <br /> &nbsp; .ENDW <br /><br /> &nbsp; &nbsp;mov &nbsp; &nbsp; eax,msg.wParam &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp;ret <br /> &nbsp; &nbsp;<br />WinMain endp <br /><br />WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM <br /><br /> &nbsp; &nbsp; .IF uMsg==WM_DESTROY &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br /> &nbsp; &nbsp; &nbsp; &nbsp;invoke closesocket, sock<br /> &nbsp; &nbsp; &nbsp; &nbsp;invoke WSACleanup &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp;invoke PostQuitMessage,NULL &nbsp; <br /><br /> &nbsp; &nbsp;.ELSEIF uMsg == WM_SOCKET<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov eax, lParam<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.IF ax == FD_ACCEPT &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invoke MessageBox, NULL, CTEXT(&quot;ACCEPTED&quot;), CTEXT(&quot;ACCEPTED&quot;), MB_OK<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.ENDIF<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.IF ax == FD_READ<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invoke MessageBox, NULL, CTEXT(&quot;READ&quot;), CTEXT(&quot;READ&quot;), MB_OK<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invoke recv, sock, ADDR buf, SIZEOF buf, 0 <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invoke MessageBox, NULL, ADDR buf, ADDR buf, MB_OK<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.ENDIF &nbsp; &nbsp; &nbsp;<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.IF ax == FD_CLOSE<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invoke MessageBox, NULL, CTEXT(&quot;CLOSE&quot;), CTEXT(&quot;CLOSE&quot;), MB_OK<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.ENDIF<br /> &nbsp; &nbsp; &nbsp; &nbsp; <br /> &nbsp; &nbsp;.ELSE <br /> &nbsp; &nbsp; &nbsp; &nbsp;invoke DefWindowProc,hWnd,uMsg,wParam,lParam &nbsp; &nbsp; <br /> &nbsp; &nbsp; &nbsp; &nbsp;ret <br /> &nbsp; &nbsp;.ENDIF <br /><br /> &nbsp; &nbsp;xor eax,eax <br /> &nbsp; &nbsp;ret <br /><br />WndProc endp <br /><br />end start </code></pre><br /><br />Edit: Am trying to connect to the socket using telnet.<strong> Telnet localhost 80</strong>.</div>
    <div class="meta">Posted on 2009-12-01 04:17:42 by karthikeyanck</div>
   </div>
   <div class="post" id="post-209788">
    <div class="subject"><a href="#post-209788">Re: WSAAsyncSelect query</a></div>
    <div class="body">I just realized that I had to accept the connection as well, but still searching answers for other questions &nbsp; :sad:<br /><br />Edit, I just figured out that when I use recv function I still get the same old data which was already received + the new data as well.. mind that I have cleared the buffers as well, but still the old data is there added to the new one&#039;s.<br /><br /><pre><code>WinMain proto :DWORD,:DWORD,:DWORD,:DWORD <br /><br />.DATA&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; initialized data <br />ClassName db &quot;SimpleWinClass&quot;,0&nbsp; &nbsp; &nbsp;  <br />AppName db &quot;Our First Window&quot;,0&nbsp; &nbsp; &nbsp; &nbsp; <br />Port dd 80<br />WM_SOCKET equ WM_USER + 100<br />argpVal dd 0<br />lpFileName db &quot;C:\sample.txt&quot;,0<br /><br />.DATA?&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Uninitialized data <br />hInstance HINSTANCE ?&nbsp; &nbsp; &nbsp; &nbsp; ; Instance handle of our program <br />CommandLine LPSTR ? <br />wsadata WSADATA &lt;&gt;<br />sin sockaddr_in &lt;&gt;<br />sock DWORD ?<br />buf db 1024 DUP(?)<br />addrLen dd ?<br />sock1 DWORD ?<br />hwnd_file dd ?<br />lpNumberOfBytesWritten dd ?<br /><br /><br />.CODE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Here begins our code <br />start: <br /><br />invoke CreateFile, ADDR lpFileName, GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL<br />mov hwnd_file, eax<br /><br />invoke GetModuleHandle, NULL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />mov hInstance,eax <br />invoke GetCommandLine&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />mov CommandLine,eax <br />invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT&nbsp; &nbsp; &nbsp; &nbsp; <br />invoke ExitProcess, eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br /><br />WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD <br />&nbsp; &nbsp; LOCAL wc:WNDCLASSEX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; LOCAL msg:MSG <br />&nbsp; &nbsp; LOCAL hwnd:HWND <br /><br />&nbsp; &nbsp; mov&nbsp;  wc.cbSize,SIZEOF WNDCLASSEX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; mov&nbsp;  wc.style, CS_HREDRAW or CS_VREDRAW <br />&nbsp; &nbsp; mov&nbsp;  wc.lpfnWndProc, OFFSET WndProc <br />&nbsp; &nbsp; mov&nbsp;  wc.cbClsExtra,NULL <br />&nbsp; &nbsp; mov&nbsp;  wc.cbWndExtra,NULL <br />&nbsp; &nbsp; push&nbsp; hInstance <br />&nbsp; &nbsp; pop&nbsp;  wc.hInstance <br />&nbsp; &nbsp; mov&nbsp;  wc.hbrBackground,COLOR_WINDOW+1 <br />&nbsp; &nbsp; mov&nbsp;  wc.lpszMenuName,NULL <br />&nbsp; &nbsp; mov&nbsp;  wc.lpszClassName,OFFSET ClassName <br />&nbsp; &nbsp; invoke LoadIcon,NULL,IDI_APPLICATION <br />&nbsp; &nbsp; mov&nbsp;  wc.hIcon,eax <br />&nbsp; &nbsp; mov&nbsp;  wc.hIconSm,eax <br />&nbsp; &nbsp; invoke LoadCursor,NULL,IDC_ARROW <br />&nbsp; &nbsp; mov&nbsp;  wc.hCursor,eax <br />&nbsp; &nbsp; invoke RegisterClassEx, addr wc&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; invoke CreateWindowEx,NULL,\ <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ADDR ClassName,\ <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ADDR AppName,\ <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WS_OVERLAPPEDWINDOW,\ <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CW_USEDEFAULT,\ <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CW_USEDEFAULT,\ <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CW_USEDEFAULT,\ <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CW_USEDEFAULT,\ <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NULL,\ <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NULL,\ <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hInst,\ <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NULL <br />&nbsp; &nbsp; mov&nbsp;  hwnd,eax <br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;invoke ShowWindow, hwnd,CmdShow&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; ;invoke UpdateWindow, hwnd&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br /><br />&nbsp; &nbsp; invoke WSAStartup, 101h, ADDR wsadata<br /><br />&nbsp; &nbsp; invoke socket, AF_INET, SOCK_STREAM, 0<br />&nbsp; &nbsp; mov sock, eax<br /><br />&nbsp; &nbsp; invoke WSAAsyncSelect, sock, hwnd, WM_SOCKET, FD_ACCEPT + FD_READ<br />&nbsp; &nbsp; mov sin.sin_family, AF_INET<br /><br />&nbsp; &nbsp; invoke htons, Port<br />&nbsp; &nbsp; mov sin.sin_port, ax<br />&nbsp; &nbsp; mov sin.sin_addr, INADDR_ANY<br /><br />&nbsp; &nbsp; invoke bind, sock, addr sin, SIZEOF sin<br /><br />&nbsp; &nbsp; mov addrLen, SIZEOF sin<br /><br />&nbsp; &nbsp; invoke listen, sock, 15<br /><br />&nbsp; &nbsp; .WHILE TRUE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke GetMessage, ADDR msg,NULL,0,0 <br />&nbsp; &nbsp; .BREAK .IF (!eax) <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke TranslateMessage, ADDR msg <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke DispatchMessage, ADDR msg <br />&nbsp;  .ENDW <br /><br />&nbsp; &nbsp; mov&nbsp; &nbsp;  eax,msg.wParam&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; ret <br />&nbsp; &nbsp; <br />WinMain endp <br /><br />WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM <br /><br />&nbsp; &nbsp;  .IF uMsg==WM_DESTROY&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke closesocket, sock<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke closesocket, sock1<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke WSACleanup&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PostQuitMessage,NULL&nbsp;  <br /><br />&nbsp; &nbsp; .ELSEIF uMsg == WM_SOCKET<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax, lParam<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .IF ax == FD_ACCEPT&nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke accept, sock, ADDR sin, ADDR addrLen<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov sock1, eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke MessageBox, NULL, CTEXT(&quot;ACCEPTED&quot;), CTEXT(&quot;ACCEPTED&quot;), MB_OK<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .ENDIF<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .IF ax == FD_READ<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke ioctlsocket, sock1, FIONREAD, ADDR argpVal<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .IF argpVal &gt; 0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke recv, sock1, ADDR buf, SIZEOF buf, MSG_PEEK<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke WriteFile, hwnd_file, ADDR buf, eax, ADDR lpNumberOfBytesWritten, NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke MessageBox, NULL, ADDR buf, ADDR buf, MB_OK<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov buf, 0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov argpVal, 0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .ENDIF<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .ENDIF<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; .ELSE <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke DefWindowProc,hWnd,uMsg,wParam,lParam&nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; ret <br />&nbsp; &nbsp; .ENDIF <br /><br />&nbsp; &nbsp; xor eax,eax <br />&nbsp; &nbsp; ret <br /><br />WndProc endp <br /><br />end start <br /><br /></code></pre></div>
    <div class="meta">Posted on 2009-12-01 07:06:22 by karthikeyanck</div>
   </div>
   <div class="post" id="post-209791">
    <div class="subject"><a href="#post-209791">Re: WSAAsyncSelect query</a></div>
    <div class="body">Your &quot;invoke ioctlsocket, sock1, FIONREAD, ADDR argpVal&quot; isn&#039;t used, and is generally something you shouldn&#039;t be doing. Also, you specify MSG_PEEK for your recv() call, no wonder that the old data is still there, then :)<br /><br />And finally, apart perhaps for learning, stay away from WSAAsyncSelect() - it&#039;s OK for a small amount of connections and limited transfer rate, but it&#039;s performance scales abysmally.</div>
    <div class="meta">Posted on 2009-12-01 18:07:33 by f0dder</div>
   </div>
   <div class="post" id="post-209795">
    <div class="subject"><a href="#post-209795">Re: WSAAsyncSelect query</a></div>
    <div class="body">Expect multiple FD messages at once, and handle it.<br />For example, FD_READ+FD_CLOSE<br /><br />Soon as you are ready, move away from this networking model, it sucks, because under load, your window message pump will drown under the weight, and your application GUI will HANG.. there are other ways.<br />Come to the dark side...we have cookies!!</div>
    <div class="meta">Posted on 2009-12-02 01:35:53 by Homer</div>
   </div>
   <div class="post" id="post-209796">
    <div class="subject"><a href="#post-209796">Re: WSAAsyncSelect query</a></div>
    <div class="body"><div class="quote">there are other ways.<br />Come to the dark side...we have cookies!!</div>:D<br /><br />WSAEventSelect or I/O Completion Ports, basically. Or, if you know you won&#039;t have loads of concurrent connections, even a thread+blockingsocket per connection :)</div>
    <div class="meta">Posted on 2009-12-02 01:55:08 by f0dder</div>
   </div>
   <div class="post" id="post-209797">
    <div class="subject"><a href="#post-209797">Re: WSAAsyncSelect query</a></div>
    <div class="body"><div class="quote"><br />Your &quot;invoke ioctlsocket, sock1, FIONREAD, ADDR argpVal&quot; isn&#039;t used, and is generally something you shouldn&#039;t be doing. Also, you specify MSG_PEEK for your recv() call, no wonder that the old data is still there, then :)<br /><br />And finally, apart perhaps for learning, stay away from WSAAsyncSelect() - it&#039;s OK for a small amount of connections and limited transfer rate, but it&#039;s performance scales abysmally.<br /></div><br /><br />Thanks guys for the replies,<br /><br />f0dder, I didn&#039;t understand - Your &quot;invoke ioctlsocket, sock1, FIONREAD, ADDR argpVal&quot; isn&#039;t used, and is generally something you shouldn&#039;t be doing.<br /><br />I degbugged this with Olly and found that ioctlsocket returns 0 and also returns the number of bytes available to be read in argpVal. Also what should I do to ignore the previously read data. Am a bit confused.</div>
    <div class="meta">Posted on 2009-12-02 02:08:35 by karthikeyanck</div>
   </div>
   <div class="post" id="post-209798">
    <div class="subject"><a href="#post-209798">Re: WSAAsyncSelect query</a></div>
    <div class="body">Oh sorry, you *are* using the return value from the FIONREAD (.IF argpVal &gt; 0) - my bad, I blame these tired old eyes ;). Thing is, it still shouldn&#039;t be necessary to do when you&#039;re acting on a FD_READ.<br /><br />As for &quot;ignore previous data&quot;, remove the MSG_PEEK from your recv() call, since this specifies &quot;grab data from socket, but don&#039;t remove it from the socket buffer&quot;.</div>
    <div class="meta">Posted on 2009-12-02 02:31:59 by f0dder</div>
   </div>
   <div class="post" id="post-209799">
    <div class="subject"><a href="#post-209799">Re: WSAAsyncSelect query</a></div>
    <div class="body">ah, thanks again f0dder.... I changed MSG_PEEK to 0, works like charm... but another question here, I wonder how would I receive data from the socket buffer after it is filled with certain amount of data say 50 bytes.... I thought ioctlsocket is the only way, is there another way?<br /><br />There lies another challenge. What happens if the last chunk of data received is less than 50 bytes, will I miss it? I think I should add another check as well for that too.</div>
    <div class="meta">Posted on 2009-12-02 04:40:14 by karthikeyanck</div>
   </div>
   <div class="post" id="post-209800">
    <div class="subject"><a href="#post-209800">Re: WSAAsyncSelect query</a></div>
    <div class="body">You should avoid coding with those kind of assumptions - TCP is stream-based, you can basically get <strong>any</strong> amount of bytes in your recv() call... so you much check the recv() amount-of-bytes-read return value. Remember that even if FIONREAD says there&#039;s 1000 bytes available, recv() might return less.<br /><br />Basically, don&#039;t enforce a &quot;packet mindset&quot; on top of a &quot;stream connection&quot; :)</div>
    <div class="meta">Posted on 2009-12-02 04:51:36 by f0dder</div>
   </div>
   <div class="post" id="post-209801">
    <div class="subject"><a href="#post-209801">Re: WSAAsyncSelect query</a></div>
    <div class="body">Great, thanks for the tip...<br /><br />So should be using ioctlsocket to check the amount of data received and then do a receive based upon the it (but again receive may return data less that what ioctlsocket returned)... so basically do a check cmp icotlsocket_returned, recv_returned... and based upon that receive the data again? /:)</div>
    <div class="meta">Posted on 2009-12-02 05:28:11 by karthikeyanck</div>
   </div>
   <div class="post" id="post-209802">
    <div class="subject"><a href="#post-209802">Re: WSAAsyncSelect query</a></div>
    <div class="body">Nope - simply drop the ioctlsocket() and do a recv() with &quot;max data you can handle&quot;. Then process the amount of data recv() indicates it returned. <strong>How</strong> you process the data depends on the protocol you&#039;re implementing... often you&#039;ll need to buffer data before you can process fully.<br /><br />In your case, simply writing received data to file, you don&#039;t need to bother with all that - just grab whatever data is available and write that :)<br /><br />And finally, remember to check return values for errors. Even though you get FD_READ, you can theoretically still get&nbsp; WSAEWOULDBLOCK on your recv() call. And please, do the proper error-handling code rather then setting the socket to blocking mode :)<br /><br /><div class="quote"><br />Expect multiple FD messages at once, and handle it.<br />For example, FD_READ+FD_CLOSE</div>Hmm?<div class="quote">Although WSAAsyncSelect can be called with interest in multiple events, the application window will receive a single message for each network event.</div></div>
    <div class="meta">Posted on 2009-12-02 05:58:44 by f0dder</div>
   </div>
   <div class="post" id="post-209803">
    <div class="subject"><a href="#post-209803">Re: WSAAsyncSelect query</a></div>
    <div class="body">With absolute respect to microsoft, I have found that it is quite normal to receive multiple FD messages at once, at the eventing level its just a set of bit masks.<br />You need to be a little careful in your handling of WM_SOCKET user messages.<br />This is not true in any other windows networking schemes that I know of.<br /><br />The example I gave is a common one - data was received, and the socket was closed - it was the last data in the stream.</div>
    <div class="meta">Posted on 2009-12-02 07:15:00 by Homer</div>
   </div>
   <div class="post" id="post-209804">
    <div class="subject"><a href="#post-209804">Re: WSAAsyncSelect query</a></div>
    <div class="body">Oops, I&#039;d to take off that MessageBox when I&#039;m checking for the FD_ACCEPT event. Clicking in OK in the MessageBox sets the AX and it&#039;s affecting the next routine of checking FD_READ (who&#039;s value is also 1)... as a result on every first instant of accepting a connection, the code falls into the receive function and returns WSAEWOULDBLOCK.. </div>
    <div class="meta">Posted on 2009-12-02 07:57:28 by karthikeyanck</div>
   </div>
   <div class="post" id="post-209805">
    <div class="subject"><a href="#post-209805">Re: WSAAsyncSelect query</a></div>
    <div class="body"><strong>Homer</strong>: report documentation bug to MS? :) - funny thing if this happens when they clearly state you should only receive a single message at a time. Does mirror how WSAEventSelect works, though.<br /><br /><strong>karthikeyanck</strong>: push/pop :)</div>
    <div class="meta">Posted on 2009-12-02 11:18:15 by f0dder</div>
   </div>
  </div>
 </body>
</html>