<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>My first MMX function - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19704" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=19704">My first MMX function</a></p>
   <div class="post" id="post-151552">
    <div class="subject"><a href="#post-151552">My first MMX function</a></div>
    <div class="body">Hi all.  I was just hoping to get some hints/critiques/criticism about my first MMX function (which converts a 32-bit image into grayscale).  I am a complete newby when it comes to MMX so please be gentle, but all comments are appreciated.<br /><br /><pre><code><br />void toGrayscaleMMX&#40; void *color32, DWORD pixelCount, void *gray &#41;<br />&#123;<br />  // Y = 0.299 * R + 0.587 * G + 0.114 * B<br />  // Y = &#40; 0x4D * R + 0x96 * G + 0x1D * B &#41; &gt;&gt; 8 <br />  static __int64 MULTIPLIERS = 0x0000004D0096001D;<br /><br />  __asm<br />  &#123;<br />    mov         ecx, pixelCount<br />    mov         esi, color32<br />    mov         edi, gray<br />    pxor        mm2, mm2<br />    movq        mm1, MULTIPLIERS<br />    NEXT_PIXEL&#58;<br />      movd      mm0, &#91;esi&#93;    // mm0 = 0x0000000000RRGGBB<br />      punpcklbw mm0, mm2      // mm0 = 0x000000RR00GG00BB<br />      pmaddwd   mm0, mm1      // 0 + R * MULT | G * MULT + B * MULT<br />      movd      ebx, mm0      // ebx = G * MULT + B * MULT<br />      psrlq     mm0, 32       // mm0 = 0x000000 | R * MULT<br />      movd      eax, mm0      // eax = 0 + R * MULT<br />      <br />      add       eax, ebx      // eax == R * MULT + G * MULT + B * MULT<br />      shr       eax, 8<br />      mov       &#91;edi&#93;, al<br /><br />      add       esi, 4<br />      add       edi, 1<br />    loop        NEXT_PIXEL<br />    emms<br />  &#125;<br />&#125;<br /></code></pre><br /><br />Spara</div>
    <div class="meta">Posted on 2004-10-19 18:39:15 by Sparafusile</div>
   </div>
   <div class="post" id="post-151553">
    <div class="subject"><a href="#post-151553">My first MMX function</a></div>
    <div class="body">That is a good start, but it would be much faster if unroll to process two pixels at once.  MOVD is slow compared to MOVQ.  Then unroll further and process eight pixels - using MOVQ/MOVNTQ to store eight destination pixels at once.</div>
    <div class="meta">Posted on 2004-10-19 18:54:35 by bitRAKE</div>
   </div>
   <div class="post" id="post-151554">
    <div class="subject"><a href="#post-151554">My first MMX function</a></div>
    <div class="body">I thought of that, but then I realized that I might go out of bounds of my color data if the pixel length of the image isn't divisible by 2 or 8 respectively.  Is there any easy way to get around this problem or do I just have to make that a constraint of calling the function?<br /><br />Spara</div>
    <div class="meta">Posted on 2004-10-19 18:57:09 by Sparafusile</div>
   </div>
   <div class="post" id="post-151558">
    <div class="subject"><a href="#post-151558">My first MMX function</a></div>
    <div class="body">process the portion the ones that is divisible, and use a simpler single pixel processing routine for the remainder</div>
    <div class="meta">Posted on 2004-10-19 19:50:42 by comrade</div>
   </div>
   <div class="post" id="post-151563">
    <div class="subject"><a href="#post-151563">My first MMX function</a></div>
    <div class="body">Here's the second version of my function (I even managed to find some optimizations myself, go me).<br /><br /><pre><code><br />void toGrayscaleMMX_Ex&#40; void *color32, DWORD pixelCount, void *gray &#41;<br />&#123;<br />  // Y = 0.299 * R + 0.587 * G + 0.114 * B<br />  // Y = &#40; 0x4D * R + 0x96 * G + 0x1D * B &#41; &gt;&gt; 8 <br />  static __int64 MULTIPLIERS = 0x0000004D0096001D;<br /><br />  __asm<br />  &#123;<br />    mov           esi, color32<br />    mov           edi, gray<br />    movq          mm7, MULTIPLIERS<br />    pxor          mm6, mm6<br /><br />    // Unrolled 2x loop<br />    mov         ecx, pixelCount<br />    shr         ecx, 1<br />    jz          CONTINUE_1<br />LOOP_2X&#58;<br />      movq      mm0, &#91;esi&#93;    // mm0 = 0x00R2G2B200R1G1B1<br />      movq      mm1, mm0      // mm1 = mm0<br />      punpckhbw mm1, mm6      // mm1 = 0x000000R200G200B2<br />      pmaddwd   mm1, mm7      // mm1 = 0 + R2 * MULT | G2 * MULT + B2 * MULT<br />      punpcklbw mm0, mm6      // mm0 = 0x000000R100G100B1<br />      pmaddwd   mm0, mm7      // mm0 = 0 + R1 * MULT | G1 * MULT + B1 * MULT<br />      movq      mm2, mm0      // mm2 = mm0<br />      punpckhdq mm0, mm1      // mm0 =         0 + R2 * MULT |         0 + R1 * MULT<br />      punpckldq mm2, mm1      // mm2 = G2 * MULT + B2 * MULT | G1 * MULT + B1 * MULT<br />      paddd     mm0, mm2      // mm0 = Y2 &lt;&lt; 8 | Y1 &lt;&lt; 8<br />      movd      eax, mm0      // eax = Y1 &lt;&lt; 8<br />      mov       &#91;edi&#93;, ah     // &quot;shr eax, 8&quot;, &quot;mov &#91;edi&#93;, al&quot;<br />      psrl      mm0, 32       // mm0 = 0x00000000 | Y2 &lt;&lt; 8<br />      movd      eax, mm0      // eax = Y2 &lt;&lt; 8<br />      mov       &#91;edi+1&#93;, ah   // &quot;shr eax, 8&quot;, &quot;mov &#91;edi+1&#93;, al&quot;<br />      add       esi, 8<br />      add       edi, 2<br />    loop        LOOP_2X<br /><br />CONTINUE_1&#58;<br />    test      pixelCount, 1<br />    jz        EXIT_PROC<br /><br />    // Single pixel &#40;only the last one&#41;<br />    movd      mm0, &#91;esi&#93;    // mm0 = 0x0000000000RRGGBB<br />    punpcklbw mm0, mm2      // mm0 = 0x000000RR00GG00BB<br />    pmaddwd   mm0, mm1      // 0 + R * MULT | G * MULT + B * MULT<br />    movd      ebx, mm0      // ebx = G * MULT + B * MULT<br />    psrlq     mm0, 32       // mm0 = 0x000000 | R * MULT<br />    movd      eax, mm0      // eax = 0 + R * MULT<br />    <br />    add       eax, ebx      // eax = R * MULT + G * MULT + B * MULT = Y &lt;&lt; 8<br />    mov       &#91;edi&#93;, ah     // &quot;shr eax, 8&quot;, &quot;mov &#91;edi&#93;, al&quot;<br />EXIT_PROC&#58;<br /><br />    emms<br />  &#125;<br />&#125;<br /></code></pre><br /><br />I'll work on a 8x unrolled loop next.  I see how that could really speed things up.  Thanks for all the tips!<br /><br />Spara</div>
    <div class="meta">Posted on 2004-10-19 20:51:43 by Sparafusile</div>
   </div>
   <div class="post" id="post-151567">
    <div class="subject"><a href="#post-151567">My first MMX function</a></div>
    <div class="body"><pre><code>movq mm0, &#91;esi&#93;<br />movq mm1, mm0<br /><br />psrlw mm0, 8<br />pand mm1, mm5 ; 00FF<br /><br />pmaddwd mm0, mm7 ; 0000 00GG<br />pmaddwd mm1, mm6 ; 00RR 00BB<br /><br />paddd mm0, mm1</code></pre>-3 instructions :)</div>
    <div class="meta">Posted on 2004-10-19 21:19:39 by bitRAKE</div>
   </div>
   <div class="post" id="post-151570">
    <div class="subject"><a href="#post-151570">My first MMX function</a></div>
    <div class="body">Took a few minutes of head scratching, but I figure out what you were doing:<br /><br /><pre><code><br />void toGrayscaleMMX_Ex&#40; void *color32, DWORD pixelCount, void *gray &#41;<br />&#123;<br />  // Y = 0.299 * R + 0.587 * G + 0.114 * B<br />  // Y = &#40; 0x4D * R + 0x96 * G + 0x1D * B &#41; &gt;&gt; 8 <br />  static __int64 G_MULTS      = 0x0000009600000096;<br />  static __int64 RB_MULTS     = 0x004D001D004D001D;<br />  static __int64 LOWBYTE_MASK = 0x00FF00FF00FF00FF;<br /><br />  __asm<br />  &#123;<br />    mov           esi, color32<br />    mov           edi, gray<br />    movq          mm7, G_MULTS<br />    movq          mm6, RB_MULTS<br />    movq          mm5, LOWBYTE_MASK<br /><br />    // Unrolled 2x loop<br />    mov         ecx, pixelCount<br />    shr         ecx, 1<br />    jz          LOOP_1X<br />LOOP_2X&#58;<br />      movq      mm0, &#91;esi&#93;    // mm0 = 0x00R2G2B200R1G1B1<br />      movq      mm1, mm0      // mm1 = mm0<br />      psrlw     mm0, 8        // mm0 = 0x000000G2000000G1<br />      pand      mm1, mm5      // mm1 = 0x00R200B200R100B1<br />      pmaddwd   mm0, mm7      // mm0 =         0 + G2 * MULT |         0 + G1 * MULT<br />      pmaddwd   mm1, mm6      // mm1 = R2 * MULT + B2 * MULT | R1 * MULT + B1 * MULT<br />      paddd     mm0, mm1      // mm0 = Y2 &lt;&lt; 8 | Y1 &lt;&lt; 8<br />      movd      eax, mm0      // eax = Y1 &lt;&lt; 8<br />      mov       &#91;edi&#93;, ah     // &quot;shr eax, 8&quot;, &quot;mov &#91;edi&#93;, al&quot;<br />      psrl      mm0, 32       // mm0 = 0x00000000 | Y2 &lt;&lt; 8<br />      movd      eax, mm0      // eax = Y2 &lt;&lt; 8<br />      mov       &#91;edi+1&#93;, ah   // &quot;shr eax, 8&quot;, &quot;mov &#91;edi+1&#93;, al&quot;<br />      add       esi, 8<br />      add       edi, 2<br />    loop        LOOP_2X<br /><br />LOOP_1X&#58;<br />    test      pixelCount, 1<br />    jz        EXIT_PROC<br /><br />    // Single pixel &#40;only the last one&#41;<br />    movd      mm0, &#91;esi&#93;    // mm0 = 0x0000000000RRGGBB<br />    punpcklbw mm0, mm2      // mm0 = 0x000000RR00GG00BB<br />    pmaddwd   mm0, mm1      // 0 + R * MULT | G * MULT + B * MULT<br />    movd      ebx, mm0      // ebx = G * MULT + B * MULT<br />    psrlq     mm0, 32       // mm0 = 0x000000 | R * MULT<br />    movd      eax, mm0      // eax = 0 + R * MULT    <br />    add       eax, ebx      // eax = R * MULT + G * MULT + B * MULT = Y &lt;&lt; 8<br />    mov       &#91;edi&#93;, ah     // &quot;shr eax, 8&quot;, &quot;mov &#91;edi&#93;, al&quot;<br />EXIT_PROC&#58;<br /><br />    emms<br />  &#125;<br />&#125;<br /></code></pre><br /><br />That might make unrolling the loop 6 more times kinda hard with 3 registers tied up, but I'll keep trying.  Thanks for your help, I appreciate it.<br /><br />Spara</div>
    <div class="meta">Posted on 2004-10-19 22:50:18 by Sparafusile</div>
   </div>
   <div class="post" id="post-151571">
    <div class="subject"><a href="#post-151571">My first MMX function</a></div>
    <div class="body">Another thing that needs to be mentioned is memory speed.  To not talk about it kind of implies it takes no time, but we know in reality that is not true.  Additionally, a routine like this plows through memory by design and 24 bit pictures are mostly larger than the cache.<br /><br />The conclusion is the routine will be memory bound for real life size pictures.  Only when testing on data in the cache will we see the speed we are gaining - or testing on a slow computer.<br /><br />For these reasons I have suggested the use of MOVNTQ above.  Even though the destination buffer is only 1/5th of the data accessed, the writes can happen almost for free when bypassing the cache.  This results in a ~20% gain on a memory bound routine!  We will see this increase for anything larger than cache.<br /><br />The downside is that MOVNTQ will be slower on small data already in the cache and timing it requires care.  When it is known the dataset is larger than cache always test larger than cache, and ignore the small dataset tests.  MOVNTQ will be slower when the data is needed in the cache afterward as well.<br /><br />Imagine we are creating an image processing tool to process 1 TB of data - SOHO satelite data from the sun or whatever your flavor.  If we are just doing this one function then MOVNTQ is the best the x86 has to offer.  But two or more functions can be done in the same amount of time on a fast CPU by keeping the data in the cache until no longer needed! The data would be broke into cache size chunks with the final function storing with MOVNTQ (or other cache passing instructions).<br /><br />Can you see the metaphor here to parallel/serial circuits?  We require both types of processing to work efficiently.  This is a scalable concept that permeates computer architectures.</div>
    <div class="meta">Posted on 2004-10-20 00:27:46 by bitRAKE</div>
   </div>
   <div class="post" id="post-151596">
    <div class="subject"><a href="#post-151596">My first MMX function</a></div>
    <div class="body">As a general rule of thumb I use MOVNTQ and it's variants  to write to memory when I get into the 100's of KB of data.</div>
    <div class="meta">Posted on 2004-10-20 10:18:19 by mark_larson</div>
   </div>
   <div class="post" id="post-151602">
    <div class="subject"><a href="#post-151602">My first MMX function</a></div>
    <div class="body">I've been working on my 8x unrolled loop, but have run into a small problem.  Here's the code:<br /><pre><code><br />mov         ecx, pixelCount<br />shr         ecx, 3<br />jz          SKIP_8X<br />LOOP_8X&#58;<br />  movq      mm0, &#91;esi&#93;    // mm0 = 0x00R2G2B200R1G1B1<br />  movq      mm1, mm0      // mm1 = mm0<br />  psrlw     mm0, 8        // mm0 = 0x000000G2000000G1<br />  pand      mm1, mm5      // mm1 = 0x00R200B200R100B1<br />  pmaddwd   mm0, mm7      // mm0 =         0 + G2 * MULT |         0 + G1 * MULT<br />  pmaddwd   mm1, mm6      // mm1 = R2 * MULT + B2 * MULT | R1 * MULT + B1 * MULT<br />  paddd     mm0, mm1      // mm0 = Y2 &lt;&lt; 8 | Y1 &lt;&lt; 8<br /><br />  movq      mm1, &#91;esi+8&#93;  // mm1 = 0x00R4G4B400R3G3B3<br />  movq      mm2, mm1      // mm2 = mm1<br />  psrlw     mm1, 8        // mm1 = 0x000000G4000000G3<br />  pand      mm2, mm5      // mm2 = 0x00R400B400R300B3<br />  pmaddwd   mm1, mm7      // mm1 =         0 + G4 * MULT |         0 + G3 * MULT<br />  pmaddwd   mm2, mm6      // mm2 = R4 * MULT + B4 * MULT | R3 * MULT + B3 * MULT<br />  paddd     mm1, mm2      // mm1 = Y4 &lt;&lt; 8 | Y3 &lt;&lt; 8<br /><br />  packssdw  mm0, mm1      // mm0 = Y4 | Y3 | Y2 | Y1<br /><br />  movq      mm1, &#91;esi+16&#93; // mm1 = 0x00R6G6B600R5G5B5<br />  movq      mm2, mm1      // mm2 = mm1<br />  psrlw     mm1, 8        // mm1 = 0x000000G6000000G5<br />  pand      mm2, mm5      // mm2 = 0x00R600B600R500B5<br />  pmaddwd   mm1, mm7      // mm1 =         0 + G6 * MULT |         0 + G5 * MULT<br />  pmaddwd   mm2, mm6      // mm2 = R6 * MULT + B6 * MULT | R5 * MULT + B5 * MULT<br />  paddd     mm1, mm2      // mm1 = Y6 &lt;&lt; 8 | Y5 &lt;&lt; 8<br /><br />  movq      mm2, &#91;esi+24&#93; // mm2 = 0x00R8G8B800R7G7B7<br />  movq      mm3, mm2      // mm3 = mm2<br />  psrlw     mm2, 8        // mm2 = 0x000000G8000000G7<br />  pand      mm3, mm5      // mm3 = 0x00R800B800R700B7<br />  pmaddwd   mm2, mm7      // mm2 =         0 + G8 * MULT |         0 + G7 * MULT<br />  pmaddwd   mm3, mm6      // mm3 = R8 * MULT + B8 * MULT | R7 * MULT + B7 * MULT<br />  paddd     mm2, mm3      // mm2 = Y8 &lt;&lt; 8 | Y7 &lt;&lt; 8<br /><br />  packssdw  mm1, mm2      // mm1 = Y8 | Y7 | Y6 | Y5<br /><br />  psrlw     mm0, 8<br />  psrlw     mm1, 8<br />  packuswb  mm0, mm1      // mm0 = 0xY8Y7Y6Y5Y4Y3Y2Y1<br />  movntq    &#91;edi&#93;, mm0<br /><br />  add       esi, 32<br />  add       edi, 8<br />loop        LOOP_8X<br /><br />SKIP_8X&#58;<br /></code></pre><br />The problem, I belive, lies in the <br /><pre><code><br />packssdw  mm0, mm1      // mm0 = Y4 | Y3 | Y2 | Y1<br />packssdw  mm1, mm2      // mm1 = Y8 | Y7 | Y6 | Y5<br /></code></pre><br />lines.  When the function returns all the values in my grayscale image are set to 127 (0x7F) which is what the packssdw opcode saturates large numbers to.  Is there such a thing as packusdw?  Or is there some way to get around this problem?<br /><br />I tried shifting the DWORD oriented registers when they only contain two Y values before packing them together, but then all my grayscale values were set to 255 (0xFF).<br /><br />Spara</div>
    <div class="meta">Posted on 2004-10-20 14:14:08 by Sparafusile</div>
   </div>
   <div class="post" id="post-151664">
    <div class="subject"><a href="#post-151664">My first MMX function</a></div>
    <div class="body">I haven't tested any code in this thread.<pre><code>	movq mm0, &#91;esi&#93;&#91;8*0&#93;	; ..r1g1b1..r0g0b0<br />	movq mm1, mm0<br />	psrlw mm0, 8		; ......g1......g0<br />	pand mm1, mm5		; ..r1..b1..r0..b0<br />	pmaddwd mm0, mm7<br />	pmaddwd mm1, mm6<br />	paddd mm0, mm1		; ....y1xx....y0xx<br /><br />	movq mm2, &#91;esi&#93;&#91;8*1&#93;	; ..r3g3b3..r2g2b2<br />	movq mm3, mm2<br />	psrlw mm2, 8		; ......g3......g2<br />	pand mm3, mm5		; ..r3..b3..r2..b2<br />	pmaddwd mm2, mm7<br />	pmaddwd mm3, mm6<br />	paddd mm2, mm3		; ....y3xx....y2xx<br /><br />	psrlw mm0, 8		; ......y1......y0<br />	psrlw mm2, 8		; ......y3......y2<br />	packuswb mm0, mm2	; ..y3..y2..y1..y0<br /><br /><br />	movq mm4, &#91;esi&#93;&#91;8*2&#93;	; ..r5g5b5..r4g4b4<br />	movq mm1, mm4<br />	psrlw mm4, 8		; ......g5......g4<br />	pand mm1, mm5		; ..r5..b5..r4..b4<br />	pmaddwd mm4, mm7<br />	pmaddwd mm1, mm6<br />	paddd mm4, mm1		; ....y5xx....y4xx<br /><br />	movq mm2, &#91;esi&#93;&#91;8*3&#93;	; ..r7g7b7..r6g6b6<br />	movq mm3, mm2<br />	psrlw mm2, 8		; ......g7......g6<br />	pand mm3, mm5		; ..r7..b7..r6..b6<br />	pmaddwd mm2, mm7<br />	pmaddwd mm3, mm6<br />	paddd mm2, mm3		; ....y7xx....y6xx<br /><br />	psrlw mm4, 8		; ......y5......y4<br />	psrlw mm2, 8		; ......y7......y6<br />	packuswb mm4, mm2	; ..y7..y6..y5..y4<br /><br />	packuswb mm0, mm4	; y7y6y5y4y3y2y1y0<br /><br />	movntq &#91;edi&#93;, mm0</code></pre>I think it would be nice to tweak the constants used for the conversion and use DWORD shifts prior to satuaration to allow greater flexiblity - code would execute the same speed, of course.<br /><br />If we are lucky maybe it runs at ~3 cycles per pixel on data in L1 cache. :)</div>
    <div class="meta">Posted on 2004-10-21 23:34:44 by bitRAKE</div>
   </div>
   <div class="post" id="post-151666">
    <div class="subject"><a href="#post-151666">My first MMX function</a></div>
    <div class="body">That's what I got too.  I realized my problem was typing the wrong number for one the mmx registers.  All my timing functions say it runs at about 4.5 cycles per pixel, but I don't know how to tell if the original color data is in the cache or not.<br /><br />I noticed that you paired the psrlw statements together.  Did you do this on purpose?  It seems it would be faster if you seperated them since they're using the same resources on the processor.<br /><br />Spara</div>
    <div class="meta">Posted on 2004-10-22 00:17:05 by Sparafusile</div>
   </div>
   <div class="post" id="post-151680">
    <div class="subject"><a href="#post-151680">My first MMX function</a></div>
    <div class="body"><div class="quote">I noticed that you paired the psrlw statements together.  Did you do this on purpose?  It seems it would be faster if you seperated them since they're using the same resources on the processor.</div>I assume you are using an Intel CPU - sometimes AMD's can execute three MMX instructions in one cycle.  It is just for readablity.  As with <strong>mark_larson</strong>'s suggestion, the instruction order is CPU dependant.  Intel will be releasing CPU's with very large caches for the general PC audience next year.<br /><br />By 'touching' a cacheline it is loaded into L1 cache, prefetch instructions are not required to do anything - newer chips will auto-fetch and re-arrange instructions to some degree. :)</div>
    <div class="meta">Posted on 2004-10-22 11:03:46 by bitRAKE</div>
   </div>
   <div class="post" id="post-151746">
    <div class="subject"><a href="#post-151746">My first MMX function</a></div>
    <div class="body"><div class="quote"><div class="quote">I noticed that you paired the psrlw statements together.  Did you do this on purpose?  It seems it would be faster if you seperated them since they're using the same resources on the processor.</div>I assume you are using an Intel CPU - sometimes AMD's can execute three MMX instructions in one cycle.  It is just for readablity.  As with <strong>mark_larson</strong>'s suggestion, the instruction order is CPU dependant.<br /></div><br />On Intel you can't pair MMX ( there are a few exceptions).  Generally you can you use different execution units to get a speed up.  If you download the P4 optimization manual it will list all the execution units different instructions use.<br /><br /><br /><br /><div class="quote">  Intel will be releasing CPU's with very large caches for the general PC audience next year.<br /><br />By 'touching' a cacheline it is loaded into L1 cache, prefetch instructions are not required to do anything - newer chips will auto-fetch and re-arrange instructions to some degree. :)</div><br /><br />Yep, the P4 has a hardware prefetcher that prefetches 512 bytes ahead automatically without program intervention.  In your code if you carefully code &quot;prefetch&quot; instructions you can get a 10%-30% increase in speed even with the hardware prefetcher.</div>
    <div class="meta">Posted on 2004-10-23 18:01:54 by mark_larson</div>
   </div>
  </div>
 </body>
</html>