<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>oop framework - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4187" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=4187">oop framework</a></p>
   <div class="post" id="post-28814">
    <div class="subject"><a href="#post-28814">oop framework</a></div>
    <div class="body">&lt;pre&gt;<br />This text deals with a possible implementation of a oop framework in masm.<br />I assume you are familiar with oop and its terminology. The framework is not yet<br />completed, these are the first results of this implementation.<br /><br />The whole idea is based on the power of masm macros and dlls (dynamic link libraries).<br />We will use a dll to represent our class. Dlls are used for our class<br />members initialisation and other class scope related data. Thus you may imagine<br />the pros and cons of using dlls<br />(if you are not familiar with dlls refer to the win programmers guide).<br /><br />The description of how a dll must be coded in order to get it being initialised,<br />will be given at the end of the sample code.<br /><br /><br /><br />To start, a sample code is demonstrated below (the explanation follows):<br /><br />;---Frame.inc-------------------------------------------------<br />use Window	;we need to include class &quot;Window&quot;<br /><br />class Frame extends Window	;multiple inheritance possible, seperate params by commas<br />	;public data<br />	make setTitle, dword, dword	;class methods<br />	make getTitle, dword<br />	positionX	dword ?		;class member variables<br />	positionY	dword ?<br />	;... other class members<br />Frame ends<br /><br />;---test.asm----------------------------------------------------<br />.386<br />.model flat, stdcall<br />.stack 0ffh<br />option casemap	:none<br /><br />include ..\include\Global.inc	;contains global macros<br /><br />use Frame<br /><br />.data<br />	title_frame		byte &quot;MyFrame&quot;, 0	;title of our frame<br />	<br />.data?<br />	frame			dword ?<br /><br />.code<br />start:<br />	mov		frame, new( Frame )	;create new instance by calling macro &quot;new&quot;<br />	<br />	eval		Frame::frame.setTile, addr title_frame<br />	eval		Frame::frame.setSize, 100, 100<br />	eval		Frame::frame.setVisible, TRUE<br />	<br />	;... some code<br />	destruct	String::string	;destroy our String instance<br />	eval		ExitProcess, 0<br />end start<br />;---------------------------------------------------------------<br /><br />The &quot;use&quot; macro<br />~~~~~~~~~~~~~~~~<br />  This macro simply includes data from another file, if suffix is omitted,<br />  then it will append &quot;.inc&quot; to it.<br />  In our case, &quot;Window&quot; just contains another class declaration declared by<br />  the &quot;class&quot; macro discussed in the next section.<br /><br />The &quot;class&quot; macro<br />~~~~~~~~~~~~~~~~~~<br />  This macro declares a new masm structure named after the first parameter given to it.<br />  If the 'key' &quot;extends&quot; is found in parameter, a nested unnamed structure of the type<br />  following the key is placed in this class.<br />  Considering our class, the following structure is generated:<br /><br />  Frame struct<br />  	Window { }<br />  	;...<br />  Frame ends<br /><br />  If there is more than one class to be inherited, it will generate as many<br />  nested structures, e.g.:<br /><br />  class Foo extends Bar, Baz<br />  	;...<br />  Foo ends<br /><br />  will become:<br /><br />  Foo struct<br />  	Bar { }<br />  	Baz { }<br />  	;...<br />  Foo ends<br /><br />The &quot;make&quot; macro<br />~~~~~~~~~~~~~~~~~<br />  &quot;make&quot; is used to declare a class method. Depending on its params, it will generate<br />  the masm prototypes, so &quot;invoke&quot; can handle the invokation, i.e. it will be able to<br />  do type checking.<br /><br />  Example:<br />  make testFunct, dword, dword<br /><br />  will become:<br /><br />  ??0001 typedef proto :dword, :dword<br />  ??0002 typedef ptr ??0001<br />  testFunct ??0002 ?<br /><br />  Since &quot;make&quot; is a macro, we can use local vars, so they are named &quot;??nnnn&quot; (i think),<br />  this guarantees that there will be unique prototypes created, and thus avoid name<br />  collisions.<br /><br />The &quot;new&quot; macro<br />~~~~~~~~~~~~~~~~<br />  This macro might be the most important one. You call it when you want to have<br />  a new instance being created.<br />  The parameter must be a class name, optionally, you can give it some other params,<br />  but they are ignored in the first version of this framework.<br /><br />  &quot;new&quot; will call the class constructor. If the class is a subtype, i.e.<br />  it inherits some other classes, the constructors of that classes are called first<br />  (the order of the class names passed to the &quot;class&quot; macro is essential).<br /><br />  Example:<br />  mov		frame, new( Frame )<br /><br />  will first call constructor of Window, then the constructor of Frame.<br />  If Window is a subtype, too, the constructors of the inherited classes are called<br />  recursively. So, there might be no problems of data initialisation.<br /><br />The &quot;eval&quot; macro<br />~~~~~~~~~~~~~~~~~<br />  Once you have created a new instance, you are able to call its methods<br />  directly.<br />  - &quot;eval&quot; is an extended &quot;invoke&quot;, so you may call static procedures, i.e. procedures<br />  defined in any .code segment.<br /><br />  Examples:<br />  - eval Frame::frame.setTitle, addr buf<br /><br />  This will call the method &quot;setTitle&quot; of the instance &quot;frame&quot; as a type of class &quot;Frame&quot;.<br /><br />  - eval Frame::getCurrentFrames<br /><br />  If the class Frame has static functions, you may call it in this way.<br /><br />  - eval ExitProcess, 0<br /><br />  If no class name given, a local procedure, e.g. a procedure placed in .code<br />  segment, will be called.<br /><br />The &quot;destroy&quot; macro<br />~~~~~~~~~~~~~~~~~~~~<br />  That's obvious, isn't it? -- Will free any resources, in this case,<br />  it will call the class destructor, then freeing memory.<br /><br /><br /><br />How a class must be coded<br />~~~~~~~~~~~~~~~~~~~~~~~~~~<br />As already said, we use dlls to wrap some objects. A dll (for our uses) must contain<br />certain procedures. These procedures must be called &quot;construct&quot; and &quot;destruct&quot;, you<br />may define static class procedures as well.<br /><br />Now, a sample:<br /><br />;---Frame.asm---------------------------------<br />.386<br />.model flat, stdcall<br />.stack 0ffh<br />option casemap	:none<br />option nokeyword	:&lt;this&gt;	;we need keyword &quot;this&quot; for our purposes<br /><br />__CLASS		equ &lt;Frame&gt;<br /><br />include		..\include\Global.asm<br /><br />.code<br />	FrameEntry proc hInst:dword, reason:dword, reserved:dword<br />		mov		eax, TRUE<br />		ret<br />	FrameEntry<br /><br />	construct proc this:dword<br />		setObj eax, this, Frame ;same as &quot;assume eax:ptr Frame&quot;<br />		setMem setTitle, offset _setTitle ;will do &quot;mov .setTitle, offset _setTitle&quot;<br />		setMem getTitle, offset _getTitle<br />		;some other inits<br />		ret<br />	construct endp<br /><br />	destrucct proc this:dword<br />		ret<br />	destruct endp<br />	;---------------------------<br />	;static function<br />	getCurrentFrames proc<br />		; our code<br />		ret<br />	getCurrentFrames endp<br />	;---------------------------<br /><br />	_setTitle proc this:dword, title_frame:dword<br />		;... our code<br />		ret<br />	_setTitle endp<br /><br />	_getTitle proc this:dword<br />		;... our code<br />		ret<br />	_getTitle endp<br />end FrameEntry<br />;---------------------------------<br /><br />You have to generate a dll, thus you need the exported label names.<br />In this case, we must generate a file consisting of<br /><br />;---Frame.def----------<br />LIBRARY Frame<br />EXPORTS	construct<br />		destruct<br />		getCurrentFrames<br />;----------------------<br /><br /><br />That's all, i think. Now, there are some problems.<br />The framework is not finished yet, so it will take some more time to finish.<br /><br />Already implemented:<br />- multiple inheritence<br />- polymorphism (not tested yet)<br />- some other stuff i cannot mention right now ;)<br /><br />There is still to be done:<br />- constructor parameter support<br />- proper super class constructor calls (does not work properly)<br />- and some other things i have forgotten<br /><br />So, if you think this might be a good idea, i will try to develop it and maybe<br />it will be finished as early as possible.<br />You may even want to help?<br /><br />&lt;/pre&gt;</div>
    <div class="meta">Posted on 2002-03-13 13:20:17 by exzito</div>
   </div>
   <div class="post" id="post-28842">
    <div class="subject"><a href="#post-28842">oop framework</a></div>
    <div class="body">I thought about something similar but it requires and conversion stage where it converts the non MASMs into MASM.  At which point, it's easier to create a new assembler all together.  Point 2 is that most asm programmers want absoulute control and don't want to bloat up source or binaries.<br /><br />I would certainly use it but I don't know how much support you'll get from most of the community...<br /><br /><br />Thanks,<br />_Shawn</div>
    <div class="meta">Posted on 2002-03-13 15:50:07 by _Shawn</div>
   </div>
   <div class="post" id="post-28852">
    <div class="subject"><a href="#post-28852">oop framework</a></div>
    <div class="body"><a target="_blank" href="http://www27.brinkster.com/nan32asm/">Nan's OOP website (download page)</a> <br /><br />This is the site for downloading the OOP macros and examples associated with this type of programming... Credit goes to Thomas and Nan for their work in the area :)<br /><br />Unless I'm mistaken this is what you were planning on doing...<br /><br />As for support :)<br />The more tools the better... Never limit yourself...<br /><br />Sliver<br /><br />---EDIT---<br />To Nan or Thomas (if you read this)<br />Is there an update in the works?</div>
    <div class="meta">Posted on 2002-03-13 16:13:54 by Sliver</div>
   </div>
   <div class="post" id="post-28913">
    <div class="subject"><a href="#post-28913">oop framework</a></div>
    <div class="body">If you're going to go DLLs for your class code, might as well make them COM classes so they can be reused most anywhere by most any language.<br /><br /><a target="_blank" href="http://ourworld.compuserve.com/homepages/ernies_world/a.htm">COM in ASM</a> <br /><br />And to those doubting Thomases, OOP is a concept, it's not bloat. (MFC is bloat, you can do bloated OOP and you can do minimal OOP, your choice). OOP doesn't mean bloat, but I'm tired of making that argument over again and again.</div>
    <div class="meta">Posted on 2002-03-14 00:53:10 by Ernie</div>
   </div>
   <div class="post" id="post-28919">
    <div class="subject"><a href="#post-28919">oop framework</a></div>
    <div class="body">I'm glad I caught it this time around :)<br /><br />Do you give an good examples of some oop bloat vs non-bloat?<br />You can just point me to a thread (searching &quot;oop&quot; doesn't really work)<br /><br />Sliver</div>
    <div class="meta">Posted on 2002-03-14 01:22:36 by Sliver</div>
   </div>
  </div>
 </body>
</html>