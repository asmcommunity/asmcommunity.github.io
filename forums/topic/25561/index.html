<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>signed/unsigned numbers, DIV/SHR, and 2-complement - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25561" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=25561">signed/unsigned numbers, DIV/SHR, and 2-complement</a></p>
   <div class="post" id="post-186685">
    <div class="subject"><a href="#post-186685">signed/unsigned numbers, DIV/SHR, and 2-complement</a></div>
    <div class="body">maybe this actually belongs somewhere in this forum :D , but i&#39;m more seasoned to the heap nowadays :D ... and since homer asked for some post, i&#39;ll relate something i&#39;ve learned while programming in java (!) and post some rantings...<br /><br />i was making a small demo with a ball bouncing in a little space with something i had called &quot;physics&quot; :D , in fact a simulated fluid slowdown that was achieved by multiplying the speed vector of the ball by for example 9/10 at etach timeframe. i was coding in j2ME for mobilephones (i&#39;m telling my life here :) ) and there was no FPU guaranteed and i was doing everything fixed point by assigning bit lengs to things, and i loved it. on a side note ints are 32b on the jvm but if you design a fixed point program you cant use all 32 because when you&#39;ll multiply by something (in order to then divide by 65536 for ex)&nbsp; the result has to fit in 32b... not like x86 where you can have EDX:EAX. (or maybe theres something i dont know bout fixed point) .<br /><br />to be fair, there are LONG ints in the jvm (64b), but i wasnt willing to use them because i supposed (maybe wrongly) that the damn mobilephone was 32b and that anything else would be emulated by the JVM. on another side note, i find it very good that the bit size of number is well defined in java, not like some other language definition i wont name :)<br /><br />well. now i&#39;m there, bouncing my ball in some directions, and it slows down gracefully. no, wait, in the other direction it begins to slow down, then it steadily slides at a constant speed towards minus infinity.<br /><br />so. it took me some time to work this one out. in fact i was soing the &quot;mul by 9/10 each timeframe&quot; thing by doing MUL 9*65536/10, SHR 16, or something. problem is, SHR is not exacly like DIV. the damn negative numbers are rounded towards minus infinity. and so, if the number is positive, with many iterations of (*9/10) it becomes zero. if the number is negative it never gets &quot;smaller&quot; (abssolute value) than something like -10 (i think, didnt really investigate). and my ball never gets still!&nbsp; whose fault? <br /><br />the fault of the clever guys who decided that 2-complement was a good, natural, simple, and elegant way of representing negative numbers. and this leads us back to a thread i posted ages (..) ago ! :) argh! i told you it was bad! :)<br /><br />okay, so with my system (sign bit + absolute value) it would take some special hardware to work. so what? its not that complicated! (someday i&#39;ll take a piece of paper and write the logic that performs this :) ). now we make weird things to get the absolute value of a number, we must take the absolute value in hardware to do a multiplication... i&#39;m sure there are more.&nbsp; but now lazy people use the fpu for doing everything, relying on the precision to hide their lack of mastering the precision errors... but they only postpone the judgment day :) , cause fpu, be it 32, 64, 80 or 2^128 bits, also generates roundup errors! haha! :) and even the hardware guys, the pure amongst the pure, are selling their souls :) to the devil by spending every bit of their energy to develop FP units that will seem to perform as fast as integer logic! so then software morons can come laughing and say &quot;you see, its no use doing integer, nowadays FPU is faster, plus you&#39;re a moron etc&quot; :) but the truth is, with the same technology its obvious that an ALU can always be faster than an FPU, cause for an FP op there are several AL ops involved. dont you see that, sinners ? :) then the problem of it being faster _today_ is only a matter of CPU design politics. if FADD is 1 clock and ADD 1 clock, well it doesnt mean that if you were running 10 times faster you&#39;d not see the difference. (hmm of course to know wether my fixed point &quot;software emulation&quot; of high-range number operations would be better than a hardware FPU is another question :) . i&#39;m just saying ppl take the FPU for granted as being not penalizing and that teh bad thing).<br /><br />hmm, where was i again? :) , yeah, thats pretty much all for now. good night, kids! i&#39;ve witnessed so many bugs in my first internship (school s over now! i&#39;m grown up!) working on mobilephones (well actually no wonder cause the company was just porting games and my job was debug) that i cant be surprised by anything now. some bug froze the device to the point you had to remove the battery.<br /><br />comment! people! otherwise i&#39;ll have been typing this crap for nothing! :)<br /><br /><br /></div>
    <div class="meta">Posted on 2006-11-23 21:22:02 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-186686">
    <div class="subject"><a href="#post-186686">Re: signed/unsigned numbers, DIV/SHR, and 2-complement</a></div>
    <div class="body">Your method of slowing down &#39;velocity&#39; would require a simple test of the high bit (negative flag bit) to check for &#39;underflow&#39; , and clamp the velocity to zero at that point.<br />The main thing to remember when programming physics simulations is that we&#39;re not attempting to EMULATE reality, we&#39;re SIMULATING it.. therefore such cheap tricks are perfectly valid !<br />Nice to see someone else is interested in this topic :)</div>
    <div class="meta">Posted on 2006-11-24 00:18:10 by Homer</div>
   </div>
   <div class="post" id="post-186688">
    <div class="subject"><a href="#post-186688">Re: signed/unsigned numbers, DIV/SHR, and 2-complement</a></div>
    <div class="body"><div class="quote">Some bug froze the device to the point you had to remove the battery.</div><br />Lucky you, when my Palm devices froze to such an extent, I had to wait for the damn battery to drain all day :)<br /><br />As for 16:16 mul in Java:<br /><pre><code><br />public static int mul(int a,int b){<br />		int c,d;<br />		boolean neg=false;<br />		if(a&lt;0){a=-a;neg=true;}<br />		if(b&lt;0){b=-b;neg=!neg;}<br />		c=a&amp;65535;<br />		d=b&amp;65535;<br />		a=a&gt;&gt;16;<br />		b=b&gt;&gt;16;<br />		if(neg){<br />			// is negative<br />			return -(a*b+((a*d+c*b)&gt;&gt;16));<br />		}<br />		return a*b+((a*d+c*b)&gt;&gt;16);<br />		<br />	}<br /></code></pre><br />System.out.println(mul(65536*(-10)/4,(65536*9))); // prints -22 ^_^<br /><br />When I look at the code... ouch there went the speedup ^^&quot;. So, using &quot;long&quot; could be better (in the BlackBerry docs, it&#39;s stated it&#39;s 2-4 times slower than int). Still, I have no java-enabled phone to benchmark.. <br /><br />So, see the 2-complement code is not at fault, since the one&#39;s complement Java code to do this would be as fast :). Like I had said in my response to your previous post about 2-complement, you shouldn&#39;t spend time on getting angry at things that you can never change - instead, you should invest time and effort to beat the problems in the given environment/tools. Like you, I kinda hate it that not even one cpu has instructions to handle 565 bitmap-data... Even though for 10years PCs needed it, and now mobile devices need it a lot. <br /><br />But that&#39;s all problems of mobile devices now (sucks to be a mobiledev developer like us :) ). <br /><br />I envy you about the school... my uni is taking way too much time and money, and thus I&#39;m at zero with both &gt;_&lt; . It&#39;s kinda my reason to not post any new topics here now, save for just short&#39;n&#39;quick solutions to problems users have. </div>
    <div class="meta">Posted on 2006-11-24 00:31:15 by Ultrano</div>
   </div>
   <div class="post" id="post-186703">
    <div class="subject"><a href="#post-186703">Re: signed/unsigned numbers, DIV/SHR, and 2-complement</a></div>
    <div class="body">HeLLoWorld<br /><br /><div class="quote">...SHR is not exacly like DIV. the damn negative numbers are rounded towards minus infinity. ...</div><br /><br />&nbsp; &nbsp;  Yes, that cannot be helped.&nbsp; By the way, you MUST use SAR for negative numbers instead of SHR, or you will convert it to a positive number right away, which is obviously wrong.&nbsp; If you want to round a negative number toward zero, negatate it first (NEG), then SHR, and finally NEG again.&nbsp; Ratch</div>
    <div class="meta">Posted on 2006-11-24 14:32:43 by Ratch</div>
   </div>
   <div class="post" id="post-186705">
    <div class="subject"><a href="#post-186705">Re: signed/unsigned numbers, DIV/SHR, and 2-complement</a></div>
    <div class="body">Why won&#39;t you simply multiply by 10 and then divide by 9 using those funny magic numbers?<br /><br />// division of a 32-bit &#39;number&#39; by 9<br />int number = 7, result;<br />long tmp = number;<br /><br />result = ( ( 3817748708 * tmp) &gt;&gt;&gt; 35 );<br /><br />or something like that, I&#39;m too sleepy atm. it&#39;s probably possible to avoid using <strong>long</strong>s.</div>
    <div class="meta">Posted on 2006-11-24 19:15:50 by ti_mo_n</div>
   </div>
   <div class="post" id="post-186735">
    <div class="subject"><a href="#post-186735">Re: signed/unsigned numbers, DIV/SHR, and 2-complement</a></div>
    <div class="body">homer:<br />i think you misunderstand. problem was not the number is becoming negative too fast and going under zero. problem is negative numbers never reach zero.<br /><br />ultrano:<br /><div class="quote">Lucky you, when my Palm devices froze to such an extent, I had to wait for the damn battery to drain all day</div><br />ouch! :)<br />i dont fully understand your code since it strips one bit so is it one-complement...<br />goog luck with studies.<br /><br />ratch:<br />YES, sar is needed. i didnt think of test/neg/sar/neg to avoid div.<br />funny thing is, in JAVA, &gt;&gt; operator does sar and &gt;&gt;&gt; does SHR. at first i thought it was a mistake in the docs.(or ?)<br /><br />ti_mo_n:<br />i dont really understand how those magic numbers work... however its still a MUL, so its still better to use shifts if possible. but now you make me think...maybe with some similar way i can multiply by 9/10 with one single MUL...<br /><br /><br /></div>
    <div class="meta">Posted on 2006-11-26 06:51:08 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-186736">
    <div class="subject"><a href="#post-186736">Re: signed/unsigned numbers, DIV/SHR, and 2-complement</a></div>
    <div class="body">Well, magic numbers are used when you want to divide using multiplication. Teh above example divides (assuming that I didn&#39;t make any mistakes :P ) &#39;number&#39; by 9 and stores the result in &#39;result&#39;. Try it and see for yourself. The idea behind this has been explained thoroughly on this forum. Try searching for &#39;magic numbers&#39;. Additionally, not so long ago, SpooK put somewhere here a link to one of the MSDN blogs where this method has been explained.<br /><br />As for the JAVA:<br />&gt;&gt;&nbsp; &nbsp;-&nbsp; SAR (arithmetic shift right)<br />&gt;&gt;&gt; -&nbsp; SHR (logical shift right)<br /><br /><br />/edit:<br />The code from my previous post works. I&#39;ve tested it.<br /><br />Example:<br />Let&#39;s try to divide 81 by 9.<br />we calculate ( ( 81 * 3817748708 ) &gt;&gt;&gt; 35 )<br />64 bit: (81 * 3817748708) = 309237645348<br />(309237645348 &gt;&gt;&gt; 35 ) = 9,0000000010477378964424133300781<br />And this is, of course, 9 because the result gets truntacted into a 32-bit integer.</div>
    <div class="meta">Posted on 2006-11-26 09:14:22 by ti_mo_n</div>
   </div>
  </div>
 </body>
</html>