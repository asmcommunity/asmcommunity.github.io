<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Can GUI be done in 16 bit model - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30844" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=30844">Can GUI be done in 16 bit model</a></p>
   <div class="post" id="post-215719">
    <div class="subject"><a href="#post-215719">Can GUI be done in 16 bit model</a></div>
    <div class="body">I would like to know if GUI interfaces can be created for 16 bit memory model and what are the major advantages of 32 bit memory model that better allows support for GUI interfaces?</div>
    <div class="meta">Posted on 2012-01-25 08:17:20 by Snake4eva</div>
   </div>
   <div class="post" id="post-215720">
    <div class="subject"><a href="#post-215720">Re: Can GUI be done in 16 bit model</a></div>
    <div class="body">Sounds like a homework question?<br />Let me ask you this: Did 16-bit Windows applications have GUIs?</div>
    <div class="meta">Posted on 2012-01-25 08:42:28 by Scali</div>
   </div>
   <div class="post" id="post-215727">
    <div class="subject"><a href="#post-215727">Re: Can GUI be done in 16 bit model</a></div>
    <div class="body">GUI Can be created on any memory models as long as you can access the Video Card. I did created my own GUI for syslinux.</div>
    <div class="meta">Posted on 2012-01-31 17:10:41 by Farabi</div>
   </div>
   <div class="post" id="post-215729">
    <div class="subject"><a href="#post-215729">Re: Can GUI be done in 16 bit model</a></div>
    <div class="body">How&#039;d you do that, Farabi? Frame buffer device? Svga library? Diddle the ports? Can we see?<br /><br />For Snake4eva, the main problem I see is the 64k segment limits. Anything &quot;nicer&quot; than mode 13h wants more than 64k, and involves bank-switching and multiple buffers in multiple segments. It can be done, but it&#039;s a heck of a lot easier with 4G segments and a linear frame buffer!<br /><br />The other thing is that you&#039;d need to manage the mouse yourself. In Windows (or Xwindows in Linux), the OS (or X server) watches the mouse for you and sends a &quot;message&quot; if anything interesting happens. (doesn&#039;t have to do with the memory model)<br /><br />You can do it, but I doubt if you want to. <br /><br />Do you actually remember 16-bit Windows, Scali? Fondly? :)<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2012-02-01 01:01:10 by fbkotler</div>
   </div>
   <div class="post" id="post-215731">
    <div class="subject"><a href="#post-215731">Re: Can GUI be done in 16 bit model</a></div>
    <div class="body"><div class="quote">For Snake4eva, the main problem I see is the 64k segment limits. Anything &quot;nicer&quot; than mode 13h wants more than 64k, and involves bank-switching and multiple buffers in multiple segments. It can be done, but it&#039;s a heck of a lot easier with 4G segments and a linear frame buffer!</div><br /><br />Then again, hardware with linear framebuffer support did not exist until 32-bit OSes were reasonably common, in the early 90s.<br />In the 16-bit days, we were happy with just 640x480 or 800x600 in 16 colours, which would fit just fine in 64k... Or well, one bitplane would, and it was all planar anyway.<br /><br /><div class="quote">Do you actually remember 16-bit Windows, Scali? Fondly? :)</div><br />Yes. No.</div>
    <div class="meta">Posted on 2012-02-01 01:49:50 by Scali</div>
   </div>
   <div class="post" id="post-215746">
    <div class="subject"><a href="#post-215746">Re: Can GUI be done in 16 bit model</a></div>
    <div class="body"><div class="quote"><br />How&#039;d you do that, Farabi? Frame buffer device? Svga library? Diddle the ports? Can we see?<br /><br />For Snake4eva, the main problem I see is the 64k segment limits. Anything &quot;nicer&quot; than mode 13h wants more than 64k, and involves bank-switching and multiple buffers in multiple segments. It can be done, but it&#039;s a heck of a lot easier with 4G segments and a linear frame buffer!<br /><br />The other thing is that you&#039;d need to manage the mouse yourself. In Windows (or Xwindows in Linux), the OS (or X server) watches the mouse for you and sends a &quot;message&quot; if anything interesting happens. (doesn&#039;t have to do with the memory model)<br /><br />You can do it, but I doubt if you want to. <br /><br />Do you actually remember 16-bit Windows, Scali? Fondly? :)<br /><br />Best,<br />Frank<br /></div><br /><br />Sure, you can see it, give me time a weeks, I&#039;ll rearrange the code so it was usable. I used int x10 to access the linier frame buffers. You also can use OpenGL for it.<br /><br />And for the mouse, you need to know the &quot;magic&quot; byte in order to use it. </div>
    <div class="meta">Posted on 2012-02-07 02:52:36 by Farabi</div>
   </div>
   <div class="post" id="post-215747">
    <div class="subject"><a href="#post-215747">Re: Can GUI be done in 16 bit model</a></div>
    <div class="body">It should be easy to convert it to your need, this code is based on syslinux system framework, so you will need to adjust it. <br /><br /><pre><code><br /><br />TRUE equ 1<br /><br />vesa_msg db &quot;Komputer ini tidak mendukung Vesa&quot;,0dh,0ah,0<br />vesa_msg2 db &quot;Komputer ini mendukung VESA&quot;,0dh,0ah,0<br />vesa_msg3 db &quot;Komputer ini tidak mendukung Resolusi yang anda inginkan&quot;,0dh,0ah,0<br />vesa_msg4 db &quot; Komputer ini mendukung Resolusi yang anda inginkan&quot;,0dh,0ah,0<br />vesa_msg5 db &quot; Tidak Didukung&quot;,0dh,0ah,0<br />vesa_msg6 db &quot;Maaf persiapan VESA dikomputer ini gagal. Coba lagi untuk mencari mode yang sesuai&quot;,0dh,0ah,0<br />buffer db &quot;XXXXXXXXXXX&quot;,0<br />lfb dd 0<br />vmode dd 0<br /><br />resx dd 0<br />resy dd 0<br />phys_addr dd 0<br />offs_mem dd 0<br />vmem dd 0<br />vbpp dd 0<br /><br />segPerLine dd 0<br />acc_mode dd 0<br /><br />VgaInfoBlock&nbsp; &nbsp; STRUC<br />&nbsp; &nbsp; VbeSignature&nbsp; &nbsp; &nbsp; &nbsp;  db 4 dup (?)&nbsp; &nbsp;  ; VBE Signature <br />&nbsp; &nbsp; VbeVersion&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dw 0200h&nbsp; &nbsp; &nbsp; &nbsp;  ; VBE Version <br />&nbsp; &nbsp; OemStringPtr&nbsp; &nbsp; &nbsp; &nbsp;  dd ?&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Pointer to OEM String <br />&nbsp; &nbsp; Capabilities&nbsp; &nbsp; &nbsp; &nbsp;  db 4 dup (?)&nbsp; &nbsp;  ; Capabilities of graphics controller <br />&nbsp; &nbsp; VideoModePtr&nbsp; &nbsp; &nbsp; &nbsp;  dd ?&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Pointer to VideoModeList <br />&nbsp; &nbsp; TotalMemory&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dw ?&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Number of 64kb memory blocks <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Added for VBE 2.0 <br />&nbsp; &nbsp; OemSoftwareRev&nbsp; &nbsp; &nbsp;  dw ?&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; VBE implementation Software revision <br />&nbsp; &nbsp; OemVendorNamePtr&nbsp; &nbsp;  dd ?&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Pointer to Vendor Name String <br />&nbsp; &nbsp; OemProductNamePtr&nbsp; &nbsp; dd ?&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Pointer to Product Name String <br />&nbsp; &nbsp; OemProductRevPtr&nbsp; &nbsp;  dd ?&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Pointer to Product Revision String <br />&nbsp; &nbsp; Reserved db 222&nbsp; &nbsp; &nbsp; dup (?)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Reserved for VBE implementation scratch <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;&nbsp;  area <br />&nbsp; &nbsp; OemData db 256&nbsp; &nbsp; &nbsp;  dup (?)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Data Area for OEM Strings<br />VgaInfoBlock&nbsp; &nbsp; ENDS<br /><br />ModeInfoBlock&nbsp;  STRUC<br /><br />; Mandatory information for all VBE revisions&nbsp; <br /><br />&nbsp; &nbsp; ModeAttributes&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dw ?&nbsp; &nbsp; &nbsp; &nbsp;  ; mode attributes <br />&nbsp; &nbsp; WinAAttributes&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; window A attributes <br />&nbsp; &nbsp; WinBAttributes&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; window B attributes <br />&nbsp; &nbsp; WinGranularity&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dw ?&nbsp; &nbsp; &nbsp; &nbsp;  ; window granularity <br />&nbsp; &nbsp; WinSize&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dw ?&nbsp; &nbsp; &nbsp; &nbsp;  ; window size <br />&nbsp; &nbsp; WinASegment&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dw ?&nbsp; &nbsp; &nbsp; &nbsp;  ; window A start segment <br />&nbsp; &nbsp; WinBSegment&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dw ?&nbsp; &nbsp; &nbsp; &nbsp;  ; window B start segment <br />&nbsp; &nbsp; WinFuncPtr&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dd ?&nbsp; &nbsp; &nbsp; &nbsp;  ; pointer to window function <br />&nbsp; &nbsp; BytesPerScanLine&nbsp; &nbsp; &nbsp; &nbsp; dw ?&nbsp; &nbsp; &nbsp; &nbsp;  ; bytes per scan line <br />&nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Mandatory information for VBE 1.2 and above&nbsp; <br />&nbsp; &nbsp; XResolution&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dw ?&nbsp; &nbsp; &nbsp; &nbsp;  ; horizontal resolution in pixels or characters3 <br />&nbsp; &nbsp; YResolution&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dw ?&nbsp; &nbsp; &nbsp; &nbsp;  ; vertical resolution in pixels or characters <br />&nbsp; &nbsp; XCharSize&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; character cell width in pixels <br />&nbsp; &nbsp; YCharSize&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; character cell height in pixels <br />&nbsp; &nbsp; NumberOfPlanes&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; number of memory planes&nbsp; <br />&nbsp; &nbsp; BitsPerPixel&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; bits per pixel <br />&nbsp; &nbsp; NumberOfBanks&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; number of banks <br />&nbsp; &nbsp; MemoryModel&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; memory model type <br />&nbsp; &nbsp; BankSize&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; bank size in KB <br />&nbsp; &nbsp; NumberOfImagePages&nbsp; &nbsp; &nbsp; db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; number of images <br />&nbsp; &nbsp; Reserved&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db 1&nbsp; &nbsp; &nbsp; &nbsp;  ; reserved for page function <br />&nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Direct Color fields (required for direct/6 and YUV/7 memory models)&nbsp; <br />&nbsp; &nbsp; RedMaskSize&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; size of direct color red mask in bits <br />&nbsp; &nbsp; RedFieldPosition&nbsp; &nbsp; &nbsp; &nbsp; db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; bit position of lsb of red mask <br />&nbsp; &nbsp; GreenMaskSize&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; size of direct color green mask in bits <br />&nbsp; &nbsp; GreenFieldPosition&nbsp; &nbsp; &nbsp; db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; bit position of lsb of green mask <br />&nbsp; &nbsp; BlueMaskSize&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; size of direct color blue mask in bits <br />&nbsp; &nbsp; BlueFieldPosition&nbsp; &nbsp; &nbsp;  db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; bit position of lsb of blue mask <br />&nbsp; &nbsp; RsvdMaskSize&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; size of direct color reserved mask in bits <br />&nbsp; &nbsp; RsvdFieldPosition&nbsp; &nbsp; &nbsp;  db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; bit position of lsb of reserved mask <br />&nbsp; &nbsp; DirectColorModeInfo&nbsp; &nbsp;  db ?&nbsp; &nbsp; &nbsp; &nbsp;  ; direct color mode attributes <br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Mandatory information for VBE 2.0 and above&nbsp; <br />&nbsp; &nbsp; PhysBasePtr&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dd ?&nbsp; &nbsp; &nbsp; &nbsp;  ; physical address for flat memory frame buffer <br />&nbsp; &nbsp; OffScreenMemOffset&nbsp; &nbsp; &nbsp; dd ?&nbsp; &nbsp; &nbsp; &nbsp;  ; pointer to start of off screen memory <br />&nbsp; &nbsp; OffScreenMemSize&nbsp; &nbsp; &nbsp; &nbsp; dw ?&nbsp; &nbsp; &nbsp; &nbsp;  ; amount of off screen memory in 1k units <br />&nbsp; &nbsp; _Reserved&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db 206 dup (?)&nbsp; ; remainder of ModeInfoBlock<br />ModeInfoBlock&nbsp;  ENDS<br /><br />vga_info0		equ memory_layout 	+ 1024<br />vga_info1	 	equ vga_info0 		+ 512<br /><br />.code<br /><br />VesaInit proc<br />	LOCAL reg:com32sys_t<br />	<br />	mov eax,vga_info0<br />	mov byte ptr,&quot;V&quot;<br />	mov byte ptr,&quot;B&quot;<br />	mov byte ptr,&quot;E&quot;<br />	mov byte ptr,&quot;2&quot;<br />	mov ecx,eax<br />	and ecx,0Fh<br />	shr eax,4<br />	<br />	mov reg.eax_,4f00h<br />	mov reg.es_,ax<br />	mov reg.edi_,ecx<br />	invoke CallInterupt,addr reg,10h,addr reg<br />	<br />	mov eax,reg.eax_<br />	.if al!=4fh<br />		invoke PrintRel,addr vesa_msg<br />		xor eax,eax<br />		ret<br />	.else<br />		push eax<br />		invoke PrintRel,CADD(&quot;Komputer ini mendukung Vesa Status:&quot;)<br />		pop eax<br />		.if ah==00<br />			invoke PrintRel,CADD(&quot;Sukses. Lanjutkan.&quot;)<br />			invoke PrintRel,addr crg<br />		.elseif ah==01<br />			invoke PrintRel,CADD(&quot;Gagal menyetel Vesa&quot;)<br />			invoke PrintRel,addr crg<br />			xor eax,eax<br />			ret<br />		.elseif ah==2<br />			invoke PrintRel,CADD(&quot;Tidak mendukung karena salah setel hardware&quot;)<br />			invoke PrintRel,addr crg<br />			xor eax,eax<br />			ret<br />		.elseif ah==3<br />			invoke PrintRel,CADD(&quot;Fungsi tidak di video mode saat ini&quot;)<br />			invoke PrintRel,addr crg<br />			xor eax,eax<br />			ret<br />		.endif<br />	.endif<br />	<br />	mov ecx,vga_info0<br />	invoke Println,ecx,4<br />	mov ecx,vga_info0<br />	movzx ecx,.VgaInfoBlock.VbeVersion<br />	invoke dw2hex,ecx,base_buffer<br />	invoke Print,base_buffer<br />	<br />	invoke PrintRel,CADD(&quot; OEM String: &quot;)<br />	mov ecx,vga_info0<br />	mov ecx,.VgaInfoBlock.OemStringPtr<br />	movzx edx,cx<br />	shr ecx,12<br />	add ecx,edx<br />	invoke Print,ecx<br />	<br />	mov ecx,vga_info0<br />	mov ecx,.VgaInfoBlock.OemVendorNamePtr<br />	.if ecx!=0	<br />		invoke PrintRel,CADD(&quot; Vendor Name: &quot;)<br />		mov ecx,vga_info0<br />		mov ecx,.VgaInfoBlock.OemVendorNamePtr<br />		movzx edx,cx<br />		shr ecx,12<br />		add ecx,edx<br />		invoke Print,ecx<br />	.endif<br /><br />	mov ecx,vga_info0<br />	mov ecx,.VgaInfoBlock.OemProductNamePtr<br />	.if ecx!=0		<br />		invoke PrintRel,CADD(&quot; OemProductNamePtr: &quot;)<br />		mov ecx,vga_info0<br />		mov ecx,.VgaInfoBlock.OemProductNamePtr<br />		movzx edx,cx<br />		shr ecx,12<br />		add ecx,edx<br />		invoke Print,ecx<br />	.endif<br /><br />	mov ecx,vga_info0<br />	mov ecx,.VgaInfoBlock.OemProductRevPtr<br />	.if ecx!=0	<br />		invoke PrintRel,CADD(&quot; OemProductRevPtr: &quot;)<br />		mov ecx,vga_info0<br />		mov ecx,.VgaInfoBlock.OemProductRevPtr<br />		movzx edx,cx<br />		shr ecx,12<br />		add ecx,edx<br />		invoke Print,ecx<br />	.endif<br />	<br />	invoke PrintRel,addr crg<br />	mov ecx,vga_info0<br />	mov eax,dword ptr.VgaInfoBlock.Capabilities<br />	pushad<br />		invoke PrintRel,CADD(&quot;Kemampuan:&quot;)<br />		invoke PrintRel,addr crg<br />	popad<br />	pushad<br />		bt eax,0<br />		.if CARRY?<br />			invoke PrintRel,CADD(&quot;DAC Bisa untuk di nyalakan kedalam 8-bit mode.&quot;)<br />			invoke PrintRel,addr crg<br />		.endif<br />	popad<br />	pushad<br />		bt eax,1<br />		.if CARRY?<br />			invoke PrintRel,CADD(&quot;Tanpa VGA Controller.&quot;)<br />			invoke PrintRel,addr crg<br />		.endif<br />	popad<br />	pushad<br />		bt eax,2<br />		.if CARRY?<br />			invoke PrintRel,CADD(&quot;programmed DAC with blank bit (i.e. only during blanking interval)&quot;)<br />			invoke PrintRel,addr crg<br />		.endif<br />	popad<br />	pushad<br />		bt eax,3<br />		.if CARRY?<br />			bt eax,4<br />			.if CARRY?<br />				invoke PrintRel,CADD(&quot;(VBE v3.0)stereo signalling via external VESA stereo connector&quot;)<br />				invoke PrintRel,addr crg<br />			.else<br />				invoke PrintRel,CADD(&quot;(VBE v3.0)stereo signalling via VESA EVC connector&quot;)<br />				invoke PrintRel,addr crg<br />			.endif<br />		.else<br />			bt eax,4<br />			.if CARRY?<br />				invoke PrintRel,CADD(&quot;4&nbsp; (VBE/AF v1.0P) must call EnableDirectAccess to access framebuff&quot;)<br />				invoke PrintRel,addr crg<br />			.endif<br />		<br />		.endif<br />	popad<br />	pushad<br />		bt eax,5<br />		.if CARRY?<br />			invoke PrintRel,CADD(&quot;programmed DAC with blank bit (i.e. only during blanking interval)&quot;)<br />			invoke PrintRel,addr crg<br />		.endif<br />	popad<br />	pushad<br />		movzx eax,.VgaInfoBlock.TotalMemory<br />		mov ecx,64*1024<br />		mul ecx<br />		push eax<br />			invoke PrintRel,CADD(&quot;Jumlah total Memory Video: &quot;)<br />		pop eax<br />		invoke dw2a,eax,base_buffer<br />		invoke Print,base_buffer<br />		invoke PrintRel,addr crg<br />	popad<br />	<br />	mov ecx,vga_info0<br />	mov ecx,.VgaInfoBlock.VideoModePtr<br />	.if ecx!=0<br />		movzx edx,cx<br />		shr ecx,12<br />		add ecx,edx<br />		invoke LoadMem,addr acc_mode,ecx	<br />	.else<br />		invoke PrintRel,CADD(&quot;Maaf, Komputer ini tidak mempunya pointer ke alamat mode yang didukung&quot;)<br />	.endif<br /><br />	<br />	<br />	invOke fLEA,addr crg<br />	invoke Print,eax<br />	<br />	mov eax,1<br />	<br />	<br />	ret<br />VesaInit endp<br /><br />VesaFindMode proc xRes:dword,yRes:dword,bpp:dword,lfbs:dword<br />	LOCAL reg:com32sys_t<br />	LOCAL mode:dword<br />	LOCAL vlfb:dword<br />	LOCAL flbs:dword<br />	LOCAL closest:dword<br />	<br />	invoke Println,vga_info0,4<br />	invoke PrintRel,CADD(&quot;Version &quot;)<br />	mov ecx,vga_info0<br />	movzx eax,.VgaInfoBlock.VbeVersion<br />	invoke dw2hex,eax,base_buffer<br />	invoke Print,base_buffer<br />	invoke PrintRel,addr crg<br />	<br />	invoke StoreMem,addr acc_mode<br />	.if eax!=0<br />		xor ecx,ecx<br />		loop_support:<br />		movzx edx,word ptr<br />		mov mode,edx<br />		inc ecx<br />		cmp dx,-1<br />		jz done<br />		pushad<br />			mov eax,vga_info1<br />			mov ecx,eax<br />			and ecx,0Fh<br />			shr eax,4<br />			mov reg.eax_,4f01h<br />			mov reg.es_,ax<br />			mov reg.edi_,ecx<br />			mov ecx,mode<br />			mov reg.ecx_,ecx<br />			invoke CallInterupt,addr reg,10h,addr reg		<br />		popad<br />		pushad<br />			mov ecx,vga_info1<br />			movzx eax,.ModeInfoBlock.ModeAttributes<br />			bt AX, 7&nbsp; &nbsp; &nbsp; ; Does this mode support a linear frame buffer?<br />			.if !CARRY?<br />			&nbsp; &nbsp; .if lfbs==TRUE<br />			&nbsp; &nbsp; 	popad<br />				&nbsp; &nbsp; jmp loop_support&nbsp; &nbsp; <br />			&nbsp; &nbsp; .endif<br />		&nbsp; &nbsp; .else<br />			&nbsp;  push mode<br />			&nbsp;  pop closest<br />		&nbsp; &nbsp; .endif<br />		&nbsp; &nbsp; <br />		&nbsp; &nbsp; mov ecx,vga_info1<br />			movzx eax,.ModeInfoBlock.ModeAttributes<br />			bt AX, 4&nbsp; &nbsp; &nbsp; ; Does this mode a graphic mode?<br />			.if !CARRY?<br />			&nbsp; &nbsp; popad<br />				jmp loop_support&nbsp; &nbsp; <br />		&nbsp; &nbsp; .else<br />			&nbsp;  push mode<br />			&nbsp;  pop closest<br />		&nbsp; &nbsp; .endif<br />		&nbsp; &nbsp; <br />		&nbsp; &nbsp; mov ecx,vga_info1<br />			movzx eax,.ModeInfoBlock.BitsPerPixel<br />			cmp bpp,eax<br />			popad<br />			jnz loop_support<br />			pushad<br />			<br />			push mode<br />			pop closest<br />		&nbsp; &nbsp; <br />		&nbsp; &nbsp; mov ecx,vga_info1<br />			movzx eax,.ModeInfoBlock.XResolution<br />			cmp xRes,eax<br />			popad<br />			jnz loop_support<br />			pushad<br />			<br />			push mode<br />			pop closest<br />			<br />			mov ecx,vga_info1<br />			movzx eax,.ModeInfoBlock.YResolution<br />			cmp yRes,eax<br />			popad<br />			jnz loop_support<br />			<br />			push mode<br />			pop closest<br />		&nbsp; &nbsp; <br />		&nbsp; &nbsp; .if flbs==TRUE<br />			&nbsp; &nbsp; or closest,4000h<br />		&nbsp; &nbsp; .endif<br />		&nbsp; &nbsp; invoke LoadMem,addr vmode,closest<br />		&nbsp; &nbsp; <br />		&nbsp; &nbsp; mov eax,vga_info1<br />			mov ecx,eax<br />			and ecx,0Fh<br />			shr eax,4<br />			mov reg.eax_,4f01h<br />			mov reg.es_,ax<br />			mov reg.edi_,ecx<br />			mov ecx,closest<br />			mov reg.ecx_,ecx<br />			invoke CallInterupt,addr reg,10h,addr reg	<br />			<br />		&nbsp;  	 mov eax,closest<br />		&nbsp; 	 ret<br />		done:<br />		<br />		mov eax,closest<br />		.if eax!=0FFFFh<br />			.if flbs==TRUE<br />			&nbsp; &nbsp; or closest,4000h<br />		&nbsp; &nbsp; .endif<br />		&nbsp; &nbsp; invoke LoadMem,addr vmode,closest<br />		&nbsp; &nbsp; pushad<br />				mov eax,vga_info1<br />				mov ecx,eax<br />				and ecx,0Fh<br />				shr eax,4<br />				mov reg.eax_,4f01h<br />				mov reg.es_,ax<br />				mov reg.edi_,ecx<br />				mov ecx,closest<br />				mov reg.ecx_,ecx<br />				invoke CallInterupt,addr reg,10h,addr reg		<br />			popad<br />		&nbsp; &nbsp; mov eax,closest<br />		.endif<br />	.endif<br />	<br />	ret<br />VesaFindMode endp<br /><br />VesaSetMode proc <br />	LOCAL reg:com32sys_t<br />	<br />	invoke StoreMem,addr vmode<br />	<br />	.if eax!=0<br />		mov reg.eax_,4f02h<br />		invoke StoreMem,addr vmode<br />		mov reg.ebx_,eax<br />		invoke CallInterupt,addr reg,10h,addr reg<br />	.else<br />		invoke fLEA,addr vesa_msg6<br />		invoke Print,eax<br />	.endif<br /><br />	<br />	<br />	ret<br />VesaSetMode endp<br /><br />VesaFormatPixel proc uses esi edi r:dword,g:dword,b:dword<br />	LOCAL bpp:dword<br />			<br />	mov eax,vga_info1<br />	mov ecx,8<br />	sub cl,.ModeInfoBlock.RedMaskSize<br />	shr r,cl<br />	mov ecx,8<br />	sub cl,.ModeInfoBlock.GreenMaskSize<br />	shr g,cl<br />	mov ecx,8<br />	sub cl,.ModeInfoBlock.BlueMaskSize<br />	shr b,cl<br />	<br />	mov cl,.ModeInfoBlock.RedFieldPosition<br />	shl r,cl<br />	mov cl,.ModeInfoBlock.GreenFieldPosition<br />	shl g,cl<br />	mov cl,.ModeInfoBlock.BlueFieldPosition<br />	shl b,cl<br />	xor eax,eax<br />	or eax,r<br />	or eax,g<br />	or eax,b<br />	<br />	<br />	ret<br />VesaFormatPixel endp<br /><br />VesaCalculateOffset proc uses esi edi x:dword,y:dword<br />	LOCAL b:dword<br />	LOCAL offs:dword<br />	<br />	mov ecx,vga_info1<br />	xor edx,edx<br />	movzx eax,.ModeInfoBlock.XResolution<br />	mul y<br />	add eax,x<br />	xor edx,edx<br />	movzx ecx,.ModeInfoBlock.BitsPerPixel<br />	shr ecx,3<br />	mul ecx<br />	mov ecx,vga_info1<br />	add eax,.ModeInfoBlock.PhysBasePtr<br />	<br />	ret<br />VesaCalculateOffset endp<br /><br />VesaPlotPixel&nbsp; proc uses esi edi x:dword,y:dword,r:dword,g:dword,b:dword<br />	LOCAL vlfb:dword<br />	LOCAL reg:com32sys_t<br />	LOCAL bpp,offs,pixel:dword<br />	<br />	invoke VesaFormatPixel,r,g,b<br />	mov pixel,eax<br />	<br />	invoke VesaCalculateOffset,x,y<br />	mov edi,eax<br />	<br />	mov ecx,vga_info1<br />	movzx ecx,.ModeInfoBlock.BitsPerPixel<br />	shr ecx,3<br />	mov eax,pixel<br />	loop_store_byte:<br />		cld<br />		stosb<br />		shr eax,8<br />	dec ecx<br />	jnz loop_store_byte<br />	<br />	ret<br />VesaPlotPixel endp<br /><br />VesaSwapBuffer proc uses esi edi lpSrc:dword,lpDest:dword<br />	<br />	mov ecx,1024*768<br />	mov esi,lpSrc<br />	mov edi,lpDest<br />	loop_swp:<br />	cld<br />	lodsd<br />	stosd<br />	dec ecx<br />	jnz loop_swp<br />	<br />	ret<br />VesaSwapBuffer endp<br /><br />VesaClearScreen proc uses esi edi r:dword,g:dword,b:dword<br />	LOCAL pixel:dword<br />	LOCAL x,y:dword<br />	LOCAL xres,yres:dword<br />	<br />	invoke VesaFormatPixel,r,g,b<br />	mov pixel,eax<br />	<br />	mov ecx,vga_info1<br />	movzx eax,.ModeInfoBlock.XResolution<br />	movzx ecx,.ModeInfoBlock.YResolution<br />	mul ecx<br />	mov ecx,eax<br />	xor edx,edx<br />	loop_fill:<br />	push ecx<br />		push edx<br />			mov eax,vga_info1<br />			movzx ecx,.ModeInfoBlock.BitsPerPixel<br />			shr ecx,3<br />			add edx,.ModeInfoBlock.PhysBasePtr<br />			push ecx<br />				mov edi,edx<br />				mov eax,pixel<br />				loop_store_byte:<br />					cld<br />					stosb<br />					shr eax,8<br />				dec ecx<br />				jnz loop_store_byte<br />			pop ecx<br />		pop edx<br />		add edx,ecx<br />	pop ecx<br />	dec ecx<br />	jnz loop_fill<br />	<br />	invoke VesaFormatPixel,0,255,0<br />	mov pixel,eax<br />	mov ecx,vga_info1<br />	movzx ecx,.ModeInfoBlock.XResolution<br />	loop_test_plot:<br />	push ecx<br />		invoke VesaPlotPixel,ecx,100,r,g,b<br />	pop ecx<br />	dec ecx<br />	jnz loop_test_plot<br />	<br />	<br />	<br />	<br />	ret<br />VesaClearScreen endp<br /></code></pre><br /><br />And here is for the mouse driver<br /><br /><pre><code><br /><br /><br />PortWait proc a_type:dword<br />	<br />;A read from port 64H gives the following status byte:<br />;<br />;&nbsp;  Bit&nbsp; &nbsp;  Function<br />;&nbsp; &nbsp; 7&nbsp; &nbsp; &nbsp; 1 = Parity error<br />;&nbsp; &nbsp; 6&nbsp; &nbsp; &nbsp; 1 = General Time Out<br />;&nbsp; &nbsp; 5&nbsp; &nbsp; &nbsp; 1 = Auxiliary output buffer full<br />;&nbsp; &nbsp; 4&nbsp; &nbsp; &nbsp; 1 = Inhibit switch<br />;&nbsp; &nbsp; 3&nbsp; &nbsp; &nbsp; 1 = Command/data<br />;&nbsp; &nbsp; 2&nbsp; &nbsp; &nbsp; 1 = System flag<br />;&nbsp; &nbsp; 1&nbsp; &nbsp; &nbsp; 1 = Input buffer full<br />;&nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 1 = Output buffer full	<br />	cli<br />	.if a_type==WAIT_READ<br />		wait_type_0:<br />		in al,64h<br />		bt ax,6<br />		jc error<br />		bt ax,7<br />		jc error<br />		bt ax,WAIT_READ			; if bit 3 set data is available at 64h<br />		jnc wait_type_0<br />		xor eax,eax<br />	.elseif a_type==WAIT_WRITE<br />		wait_type_1:			; Bit 1 should be zero before we able to send command<br />		in al,64h<br />		bt ax,6<br />		jc error<br />		bt ax,7<br />		jc error<br />		bt ax,WAIT_WRITE<br />		jc wait_type_1<br />		xor eax,eax<br />	.elseif a_type==WAIT_COMMAND<br />		wait_type_2:			; Bit 0 and 1 should be zero before we able to send command<br />		in al,64h<br />		bt ax,6<br />		jc error<br />		bt ax,7<br />		jc error<br />		bt ax,WAIT_COMMAND<br />		jc wait_type_2<br />		xor eax,eax<br />	.elseif a_type==WAIT_READ60<br />		wait_type_4:<br />		in al,64h<br />		bt ax,6<br />		jc error<br />		bt ax,7<br />		jc error<br />		bt ax,WAIT_READ			; if bit 3 not set data is available at 60h<br />		jc wait_type_4<br />		xor eax,eax<br />	.elseif a_type==WAIT_OUTPUT<br />		wait_type_5:<br />		in al,64h<br />		bt ax,6<br />		jc error<br />		bt ax,7<br />		jc error<br />		bt ax,WAIT_OUTPUT			; if bit 3 set data is available at 64h<br />		jnc wait_type_5<br />		xor eax,eax<br />	.endif<br />	<br />	error:<br />	sti<br />	ret<br />PortWait endp<br /><br />PortRead proc<br />	<br />	invoke PortWait,WAIT_READ<br />	in al,60h<br />	<br />	ret<br />PortRead endp<br /><br />PortWrite proc a_cmd:byte<br />	<br />	invoke PortWait,WAIT_WRITE<br />	mov al,a_cmd<br />	out 64h,al<br />	<br />	ret<br />PortWrite endp<br /><br />KeyBoardRead proc<br />	LOCAL key:byte<br />	<br />	invoke PortWrite,0AEh<br />	invoke PortWrite,0D2h<br />	in al,60h<br />;	invoke PortRead<br />;	mov key,al<br />;	invoke PortWrite,0AEh<br />;	mov al,key<br />;	push eax<br />;		push eax<br />;		invoke dw2bin,eax,base_buffer<br />;		invoke Print,base_buffer<br />;		pop eax<br />;		invoke dw2hex,eax,base_buffer<br />;		invoke Print,base_buffer<br />;		invoke PrintRel,addr crg<br />;	pop eax<br />;	invoke PortWrite,0A7h<br />	ret<br />KeyBoardRead endp<br /><br />MouseWaitACK proc<br />	<br />	_wait:<br />	in al,60h<br />	cmp al,0FAh<br />	jnz _wait<br />	<br />	ret<br />MouseWaitACK endp<br /><br />MouseSendCommand proc cmd:byte<br />	<br />	invoke PortWrite,0D4h<br />	mov al,cmd<br />	out 60h,al<br />	invoke MouseWaitACK<br />	<br />	ret<br />MouseSendCommand endp<br /><br />MouseInit proc<br />	LOCAL mID:byte<br />	LOCAL packet[4]:byte<br />	;Get Mouse ID<br />	; Reset<br />	invoke StoreMem,addr mouse<br />	mov esi,eax<br />	invoke memfill,eax,sizeof mouse,0<br />	<br />	invoke PortWrite,0A8h<br />	invoke MouseSendCommand,0FFh<br />	invoke MouseSendCommand,0F6h<br />	invoke MouseSendCommand,0F4h<br />	invoke MouseSendCommand,0F0h<br />	<br />	invoke MouseSendCommand,0F2h<br />	in al,60h<br />	mov mID,al<br /><br />	invoke MouseSendCommand,0F3h<br />	invoke MouseSendCommand,0Ah<br />	invoke MouseSendCommand,0F2h<br />	in al,60h<br />	.if al!=0<br />		mov mID,al		; Had Track Ball<br />	.endif<br />	<br />	;	Activate Wheel<br />	invoke MouseSendCommand,0F3h<br />	invoke MouseSendCommand,0C8h<br />	invoke MouseSendCommand,0F3h<br />	invoke MouseSendCommand,064h<br />	invoke MouseSendCommand,0F3h<br />	invoke MouseSendCommand,050h<br />	in al,60h<br />	.if al==3<br />		mov mID,al<br />	.endif<br />	<br />	mov al,mID<br />	ret<br />MouseInit endp<br /><br />MouseRead proc uses esi<br />	LOCAL packet[4]:byte<br />	LOCAL status[4]:byte<br />	LOCAL fnt:dword<br />	<br />	invoke StoreMem,addr lpfnt2<br />	mov fnt,eax<br />	<br />	cli<br />	invoke MouseSendCommand,0F4h<br />	invoke MouseSendCommand,0E9h<br />	in al,60h<br />	mov status[0],al<br />	in al,60h<br />	mov status[1],al<br />	in al,60h<br />	mov status[2],al<br />	in al,60h<br />	mov status[3],al<br />	<br />	invoke MouseSendCommand,0EBh<br />	in al,60h<br />	mov packet[0],al<br />	in al,60h<br />	mov packet[1],al<br />	in al,60h<br />	mov packet[2],al<br />	in al,60h<br />	mov packet[3],al<br />	<br />	lea ecx,status<br />	mov ecx,<br />	bswap ecx<br />	lea edx,packet<br />	mov edx,<br />	bswap edx<br />	<br />	invoke StoreMem,addr mouse<br />	mov esi,eax<br />	<br />	<br />	movzx eax,packet[2]<br />	bt ax,7<br />	jc y_minus<br />	add .fMouse.y,eax<br />	mov eax,vga_info1<br />	movzx eax,.ModeInfoBlock.YResolution<br />	.if .fMouse.y&gt;eax<br />		mov eax,vga_info1<br />		movzx eax,.ModeInfoBlock.YResolution<br />		mov .fMouse.y,eax<br />	.endif<br />	jmp done_y<br />	y_minus:<br />		not al<br />		inc eax<br />		sub .fMouse.y,eax<br />		.if SIGN?<br />			mov .fMouse.y,0<br />		.endif<br />	done_y:<br />	<br />	<br />	movzx eax,packet[1]<br />	bt ax,7<br />	jc x_minus<br />	add .fMouse.x,eax<br />	mov eax,vga_info1<br />	movzx eax,.ModeInfoBlock.XResolution<br />	.if .fMouse.x&gt;eax<br />		mov eax,vga_info1<br />		movzx eax,.ModeInfoBlock.XResolution<br />		mov .fMouse.x,eax<br />	.endif<br />	jmp done_x<br />	x_minus:<br />		not al<br />		inc eax<br />		sub .fMouse.x,eax<br />		.if SIGN?<br />			mov .fMouse.x,0<br />		.endif<br />	done_x:<br />	<br />	mov al,packet[0]<br />	mov .fMouse.mb,eax<br />	<br />;	invoke MouseSendCommand,0F5h<br />	sti<br />	<br />	lea eax,packet<br />	mov eax,<br />	bswap eax<br />;	movzx eax,packet[1]<br />	push eax<br />		push eax<br />		invoke StoreMem,addr mouse<br />		mov esi,eax<br />		invoke dw2a,.fMouse.x,base_buffer<br />	;	invoke Print,base_buffer<br />		invoke fBitTextOutEx,fnt,VRAMB,400,10,base_buffer<br />	;	invoke PrintRel,CADD(&quot; &quot;)<br />		pop eax<br />		invoke StoreMem,addr mouse<br />		mov esi,eax<br />		invoke dw2a,.fMouse.y,base_buffer<br />		invoke fBitTextOutEx,fnt,VRAMB,400,20,base_buffer<br />	;	invoke Print,base_buffer<br />	;	invoke PrintRel,addr crg<br />	pop eax<br />	<br />	<br />	ret<br />MouseRead endp<br /><br /></code></pre></div>
    <div class="meta">Posted on 2012-02-07 02:56:18 by Farabi</div>
   </div>
   <div class="post" id="post-215748">
    <div class="subject"><a href="#post-215748">Re: Can GUI be done in 16 bit model</a></div>
    <div class="body">Cool! Thanks! I&#039;ll study that.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2012-02-07 05:13:54 by fbkotler</div>
   </div>
   <div class="post" id="post-215749">
    <div class="subject"><a href="#post-215749">Re: Can GUI be done in 16 bit model</a></div>
    <div class="body">You&#039;ll need this<br />http://mobalivecd.mobatek.net/en/<br /><br />Attached is my full project using RadAsm and JWASM. No MASM Include or code taken. Used only free code mostly created by Me (Onan Farabi).<br />http://ompldr.org/vY296Mg/FOSGUI.rar</div>
    <div class="meta">Posted on 2012-02-08 01:20:34 by Farabi</div>
   </div>
   <div class="post" id="post-215750">
    <div class="subject"><a href="#post-215750">Re: Can GUI be done in 16 bit model</a></div>
    <div class="body">I don&#039;t think MobaLiveCD will help me much - I&#039;m not running Windows. I wasn&#039;t interested in SysLinux, particularly, just how you got graphics in Linux. CallInterrupt on int 10h was the answer I was looking for, mostly. The mouse stuff is interesting, too. I&#039;ll look at the full project if I get a chance. Thanks!<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2012-02-08 04:00:30 by fbkotler</div>
   </div>
  </div>
 </body>
</html>