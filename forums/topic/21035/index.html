<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Assembly in general.... Program size smaller than HLL, why? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=21035" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=12">The Heap</a> &raquo; <a href="../?id=21035">Assembly in general.... Program size smaller than HLL, why?</a></p>
   <div class="post" id="post-159414">
    <div class="subject"><a href="#post-159414">Assembly in general.... Program size smaller than HLL, why?</a></div>
    <div class="body">For a few days now, I have been pondering this(these) question(s) and I cannot put my finger on the answer(s). <br /><br />Here are some of the questions I have:<br /><br /><ul><br /><li>Why are most assembly coded programs smaller in size than HL languages?</li><br /><br /><li>What do higher level languages have that make them produce bulky programs?</li><br /><br /><li>Is it all based on the coding style / technique?</li><br /><br /><li>And, finally, would it be possible to have a HLL with the size and speed of assembly?</li><br /></ul><br /><br />Thanks for your time.<br /><br />~ Steve ~<br /><br />(Edit: <em>Sorry if this belongs in another forum, I wasn&#39;t sure.</em> )</div>
    <div class="meta">Posted on 2005-04-30 16:30:45 by ~Steve~</div>
   </div>
   <div class="post" id="post-159415">
    <div class="subject"><a href="#post-159415">Re: Assembly in general.... Program size smaller than HLL, why?</a></div>
    <div class="body">No, it most definitely belongs here since it isn&#39;t a &quot;specific issue&quot;, good looking out ;)<br /><br />Now to answer your questions from my viewpoint.<br /><br /><div class="quote"><br /><li>Why are most assembly coded programs smaller in size than HL languages?</li><br /></div><br /><br />Assembly coded programs are smaller due to less overhead.<br /><br /><div class="quote"><br /><li>What do higher level languages have that make them produce bulky programs?</li><br /></div><br /><br />Compilers convert logic and data using generic/generalized algorithms. Compilers also do branch optimizations, which usually requires putting more code in for jump predictibility.<br /><br /><div class="quote"><br /><li>Is it all based on the coding style / technique?</li><br /></div><br /><br />To an extent, the most popular HLL is C/C++. When it comes down to it, C/C++ is nothing more than a higher logic extrapolation of basic CPU instructions. IF, FOR and WHILE are prime exmaples of things that get turned into Assembly language blocks with CMP, TEST, JMP, CALL and other common instructions. It is easier to see the logic in an IF statement since all the logic is there in spot &quot;if (this=that)&quot;. In assembly, you have to understand the code block you are looking at to figure out the intention of the code, beyond comments. In the end, assembly naturally requires more commenting because it is less intuitive to humans than assembly language.<br /><br /><div class="quote"><br /><li>And, finally, would it be possible to have a HLL with the size and speed of assembly?</li><br /></div><br /><br />I will defer you to a generalization of NASA&#39;s generic quote adapted to amateur programming community. &quot;Time, size, speed... pick any two ;)&quot;</div>
    <div class="meta">Posted on 2005-04-30 16:55:34 by SpooK</div>
   </div>
   <div class="post" id="post-159416">
    <div class="subject"><a href="#post-159416">Re: Assembly in general.... Program size smaller than HLL, why?</a></div>
    <div class="body">Hmm, I see.. But, would it not be possible to create an extremely complex compiler that will try to create the most efficient code possible? <br /><br />(I hope I put that correctly.)<br /><br />As much as I would like to accept NASA&#39;s quote... I can&#39;t :sad:</div>
    <div class="meta">Posted on 2005-04-30 17:19:09 by ~Steve~</div>
   </div>
   <div class="post" id="post-159417">
    <div class="subject"><a href="#post-159417">Re: Assembly in general.... Program size smaller than HLL, why?</a></div>
    <div class="body">Code efficiency and size are not necessarily the same conceptual goal. Current compilers strive to make efficient code by using complex algorithmic based trees and patterns (i.e. Lex and Yacc). The idea of having a compiler making the &quot;most efficient code possible&quot; on current architecture is impossible in the context of human intervention. Humans know exactly what they want out of the code, compilers can only give a finite amount of results for a given set of instructions.<br /><br />Now to a realist&#39;s point of view, most compilers do a sufficent job. Going into the code and tweaking it to get a performance boost is specific to the task. For an Operating System project, I would say it is required... for a common Windows application, I would say it is a futile task.<br /><br />The last thing you need to understand is not how well compilers compile or assemblers assemble, but how well you can use and understand the language. Naturally, I can understand C code and PHP by looking at it because it is simple logic and data manipulation; but, I personally have taken the time to become well versed in assembly language and I can understand and write that equivalent code just as well as I can in C... it will just take a few more lines on occasion :)</div>
    <div class="meta">Posted on 2005-04-30 18:34:57 by SpooK</div>
   </div>
   <div class="post" id="post-159423">
    <div class="subject"><a href="#post-159423">Re: Assembly in general.... Program size smaller than HLL, why?</a></div>
    <div class="body">Hi ~Steve~,<br /><br />Combining the power of asm and the efficiency of C ,&nbsp; you can get smaller executables. The trick is to avoid the standard C run-time startup modules.<br /><br />Here are two versions of my tiny C startup modules, one for console applications, the other one for GUI apps.<br />Both op the modules has the capacity of handling command line parameters.<br /><br />Reducing the size of C executables, these modules are designed to use with Visual C and Pelle&#39;s C compilers.<br /><br />Builded with these tiny modules, a simple application displaying a blank window is only 2 / 2.5 Kb</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=575" target="_blank">Parsecmd3.zip</a></li>
      <li><a href="../../attachments/?id=576" target="_blank">Wcrt0_4.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2005-05-01 03:53:26 by Vortex</div>
   </div>
   <div class="post" id="post-159435">
    <div class="subject"><a href="#post-159435">Re: Assembly in general.... Program size smaller than HLL, why?</a></div>
    <div class="body">Wow, that&#39;s exactly what I was looking for, Vortex! Thank you, too, SpooK. I was just leaning more in that direction. :D<br /><br /><div class="quote"><br />avoid the standard C run-time startup modules<br /></div><br /><br />Now I can utilize both to do some great things.<br /><br />Thanks!<br /><br />~ Steve ~</div>
    <div class="meta">Posted on 2005-05-01 10:42:25 by ~Steve~</div>
   </div>
   <div class="post" id="post-159436">
    <div class="subject"><a href="#post-159436">Re: Assembly in general.... Program size smaller than HLL, why?</a></div>
    <div class="body">Hi ~Steve~ ,<br /><br />You are welcome. Here are more two examples : one&nbsp; for creating small C DLLs, the other one is a demo for creating an EXE of 1024 bytes, the minimum sized executable running on all 32-bit Windows versions.</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=578" target="_blank">SmallDLL.zip</a></li>
      <li><a href="../../attachments/?id=579" target="_blank">SmallExe.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2005-05-01 10:57:03 by Vortex</div>
   </div>
   <div class="post" id="post-159441">
    <div class="subject"><a href="#post-159441">Re: Assembly in general.... Program size smaller than HLL, why?</a></div>
    <div class="body">http://www.ibsensoftware.com - get WCRT. Small overhead, good quality code - as with all Jibz&#39; stuff.<br /></div>
    <div class="meta">Posted on 2005-05-01 13:39:35 by f0dder</div>
   </div>
   <div class="post" id="post-159443">
    <div class="subject"><a href="#post-159443">Re: Assembly in general.... Program size smaller than HLL, why?</a></div>
    <div class="body"><div class="quote"><br />But, would it not be possible to create an extremely complex compiler that will try to create the most efficient code possible? <br /></div><br /><br />What&#39;s often said in compiler optimization books is -- you can never hope to create the most efficient code, you can only make <strong>better</strong> code.<br /><br />That said, you can sometimes create the most efficient code for only short self-contained segments of code. As soon as you add externally linked names, the compiler is hampered by lack of knowledge of external components. The important missing information is state changes (data, and external resources such as files), and when they happen or if they happen. To some extent, this can be eased by &quot;whole program&quot; optimization. Up till now, this has not been a common practice because most development systems were rather small systems by modern standards. It still is not a common practice because the linking function is a fundamental part of the process. Common linkers don&#39;t optimize, as that is considered a task of the compiler.<br /><br />If the self-contained code is complex enough, then decisions have to be made on splitting the use of cheap (or slow) and expensive (or fast) resources. Some of this tradeoff is affected by the code you write. But when the resulting target code is still too complex, the compiler might make choices that assembly language programmers won&#39;t make, affecting efficiency.</div>
    <div class="meta">Posted on 2005-05-01 14:29:52 by tenkey</div>
   </div>
  </div>
 </body>
</html>