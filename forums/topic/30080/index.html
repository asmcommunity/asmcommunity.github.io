<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>to get the opengl driver addresses - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30080" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=30080">to get the opengl driver addresses</a></p>
   <div class="post" id="post-212228">
    <div class="subject"><a href="#post-212228">to get the opengl driver addresses</a></div>
    <div class="body">hello}<br />im trying to get the addresses of the opengl driver, either nvidia or ati, or other.... i tried a method called tib hooking or whatever, it seems it uses some member in the TEB structure of a determined thread in a process, so you have to be in the thread context. &nbsp;im not sure anyways but it is not working for me at the moment. i looked in a debugger to see how it gets to the driver address of <strong>glbegin </strong>for example<br /><br />from opengl32.dll --&gt;<br />5F1228F0 &gt; &nbsp;64:A1 18000000 &nbsp;MOV EAX,DWORD PTR FS:[18] //EAX=0x7FFDE000<br />5F1228F6 &nbsp;- FFA0 CC070000 &nbsp; JMP DWORD PTR DS: ; nvoglnt.6981C250 // EDX=69E00002 nvoglnt.69E00002<br /><br />--&gt; to stack<br />6981C250 &nbsp; &nbsp;64:A1 880E0000 &nbsp;MOV EAX,DWORD PTR FS:<br />6981C256 &nbsp; &nbsp;FF20 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;JMP DWORD PTR DS: //EAX=013800BC<br /><br />--&gt; to nvoglnt.dll<br />6962D940 &nbsp; &nbsp;---&gt; glbegin&#039;s driver address<br /><br /><br />well but at the moment i couldnt get them by a coding method so i am just hardcoding them. but well i want to get them automatically, i appreciate your help &nbsp;:D<br /><br /><br /><pre><code><br />typedef struct _TEB<br />{<br /> &nbsp; &nbsp;NT_TIB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Tib;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EnvironmentPointer;<br /> &nbsp; &nbsp;CLIENT_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Cid;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ActiveRpcInfo;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ThreadLocalStoragePointer;<br /> &nbsp; &nbsp;PPEB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Peb;<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LastErrorValue;<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CountOfOwnedCriticalSections;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CsrClientThread;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Win32ThreadInfo;<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Win32ClientInfo[0x1F];<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WOW32Reserved;<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CurrentLocale;<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FpSoftwareStatusRegister;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SystemReserved1[0x36];<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Spare1;<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExceptionCode;<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpareBytes1[0x28];<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SystemReserved2[0xA];<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GdiRgn;<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GdiPen;<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GdiBrush;<br /> &nbsp; &nbsp;CLIENT_ID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RealClientId;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GdiCachedProcessHandle;<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GdiClientPID;<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GdiClientTID;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GdiThreadLocaleInfo;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UserReserved[5];<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GlDispatchTable[0x118];<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GlReserved1[0x1A];<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GlReserved2;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GlSectionInfo;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GlSection;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GlTable;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GlCurrentRC;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GlContext;<br /> &nbsp; &nbsp;NTSTATUS &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LastStatusValue;<br /> &nbsp; &nbsp;UNICODE_STRING &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;StaticUnicodeString;<br /> &nbsp; &nbsp;WCHAR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StaticUnicodeBuffer[0x105];<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DeallocationStack;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TlsSlots[0x40];<br /> &nbsp; &nbsp;LIST_ENTRY &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;TlsLinks;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vdm;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReservedForNtRpc;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DbgSsReserved[0x2];<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HardErrorDisabled;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Instrumentation[0x10];<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WinSockData;<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GdiBatchCount;<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Spare2;<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Spare3;<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Spare4;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReservedForOle;<br /> &nbsp; &nbsp;ULONG &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WaitingOnLoaderLock;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StackCommit;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StackCommitMax;<br /> &nbsp; &nbsp;PVOID &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StackReserved;<br />} TEB, *PTEB;<br /><br />PTEB myTEB;<br />__asm<br />{<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov eax, fs:[0x18]<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov myTEB, eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop eax<br />}<br /></code></pre><br /><br />thank you !! :-D<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2010-07-06 14:02:06 by corso</div>
   </div>
   <div class="post" id="post-212230">
    <div class="subject"><a href="#post-212230">Re: to get the opengl driver addresses</a></div>
    <div class="body">What&#039;s your reason for trying to do it this way, which will crash and burn eventually, instead of linking to an import library?</div>
    <div class="meta">Posted on 2010-07-06 15:41:49 by f0dder</div>
   </div>
   <div class="post" id="post-212232">
    <div class="subject"><a href="#post-212232">Re: to get the opengl driver addresses</a></div>
    <div class="body">well, in first place i didnt know a way to do this. i was just grabbing the addresses from the debugger.<br />but now i want to make this automatically, what is the simpler way to make this?<br />or explain that of the linking to an import library... i didnt get the idea<br /></div>
    <div class="meta">Posted on 2010-07-06 16:32:12 by corso</div>
   </div>
   <div class="post" id="post-212233">
    <div class="subject"><a href="#post-212233">Re: to get the opengl driver addresses</a></div>
    <div class="body">Seems like you don&#039;t understand the concept of import binding, in which case I&#039;d like to inform you that you are attempting to perform a somewhat advanced technique. I strongly suggest that you start with the basics first. In its current state, even if you manage to make these hard-coded addresses work on windows XP, ASLR will make sure it won&#039;t work on Visa/7.<br /><br />And what is the ultimate goal of all this? What are you trying to accomplish? To me, it looks like it&#039;s going to be either malicious or educational. If it&#039;s educational, you really need to learn the basics first.<br /><br />...Or maybe I completely misunderstand what you are trying to do? ^^&#039; Please explain.</div>
    <div class="meta">Posted on 2010-07-06 17:49:11 by ti_mo_n</div>
   </div>
   <div class="post" id="post-212234">
    <div class="subject"><a href="#post-212234">Re: to get the opengl driver addresses</a></div>
    <div class="body">hi this is the code for my logger, I need to get opengl addresses from driver, such as glbegin, glenable, etc<br />I am not getting them as is visible in the code. I was told to use this method of the tib hooking that is supposed to work,<br />so the question is how to get the addresses using tib, do you know or you DO NOT know how to make it? <br />but probably i could get help with my code below, what is missing, etc .. since i didnt work with this structure (tib)<br />if you know another method, simpler perhaps, I am expectant. but I will have still the doubt on this one.. &nbsp;:sad:<br />(not that of the hardcoding the addresses &nbsp;:D)<br /><br /><pre><code><br />DWORD thread_OGL(LPVOID parms)<br />{<br /> &nbsp; _CONTEXT Cxt;<br /> &nbsp; Cxt.ContextFlags=CONTEXT_FULL|CONTEXT_DEBUG_REGISTERS;<br /><br /> &nbsp; LDT_ENTRY SelEntry;<br /><br /> &nbsp; HWND hApp; //use findwindow<br /> &nbsp; DWORD ProcId;<br /> &nbsp; DWORD ThId=GetWindowThreadProcessId(hApp,&amp;ProcId);<br /> <br /> &nbsp; HANDLE hProc=OpenProcess(PROCESS_ALL_ACCESS,FALSE,ProcId);<br /> &nbsp; <br /> &nbsp; HANDLE hTh=OpenThread(THREAD_ALL_ACCESS,FALSE,ThId);<br /><br /> &nbsp; SuspendThread(hTh);<br /> &nbsp;<br /> &nbsp; GetThreadContext(hTh, &amp;Cxt);<br /> &nbsp; GetThreadSelectorEntry(hTh, Cxt.SegFs, &amp;SelEntry);<br /><br /> &nbsp; ResumeThread(hTh);<br /><br /> &nbsp; DWORD* dwFSBase = (DWORD*)((SelEntry.HighWord.Bits.BaseHi&lt;&lt;24)|(SelEntry.HighWord.Bits.BaseMid&lt;&lt;16)|SelEntry.BaseLow);<br /> &nbsp; DPrint(&quot;dwFSBase 0x%X&quot;,dwFSBase);<br /><br /> &nbsp; //mov	eax, fs:[18h]	; // *TIB<br /> &nbsp; //mov	eax, 	; // CurrentThreadId<br /> &nbsp; PTEB myTEB;<br /><br /> &nbsp; __asm{<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov eax, dwFSBase<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//mov eax, fs:[18h]<br />	 &nbsp;mov myTEB, eax<br /> &nbsp; }<br /><br /> &nbsp; DWORD addr1 = (DWORD)myTEB-&gt;GlDispatchTable[0x01];<br /> &nbsp; DPrint(&quot;addr1 0x%X&quot;,addr1);<br /><br /> &nbsp; CloseHandle(hTh);<br /> &nbsp; CloseHandle(hProc);<br /> &nbsp; return 0;<br />}<br /><br /></code></pre><br /><br /></div>
    <div class="meta">Posted on 2010-07-06 20:08:13 by corso</div>
   </div>
   <div class="post" id="post-212235">
    <div class="subject"><a href="#post-212235">Re: to get the opengl driver addresses</a></div>
    <div class="body">As the others I&#039;d also like to know the ultimate goal so we can know if this forced methodology of using the undocumented TIB fields is really needed. In your code it seems you are getting the dispatch table of a thread from a foreign process, and because of that you of course CANNOT read it straight as you&#039;re doing. To read the TIB you should follow the remarks section of GetThreadSelectorEntry documentation:<div class="quote">Remarks<br /><br />GetThreadSelectorEntry is only functional on x86-based systems. For systems that are not x86-based, the function returns FALSE.<br /><br /><strong>Debuggers use this function to convert segment-relative addresses to linear virtual addresses. The ReadProcessMemory and WriteProcessMemory functions use linear virtual addresses.</strong></div>http://msdn.microsoft.com/en-us/library/ms679363%28VS.85%29.aspx</div>
    <div class="meta">Posted on 2010-07-06 20:20:17 by LocoDelAssembly</div>
   </div>
   <div class="post" id="post-212236">
    <div class="subject"><a href="#post-212236">Re: to get the opengl driver addresses</a></div>
    <div class="body"> &nbsp;I didnt consider necessary to mention that this code is to start a thread in some process. it belongs to a dll project so, the way<br />this logger works is like loading the logger.dll using some loader/injector, into the application you want and then you can get the addresses<br />from your opengl driver (nvidia, ati, etc). that&#039;s why I need to enter in the context of the process, so then i can read the thread&#039;s tib, it is ok?<br /><br />that gldispatchtable I dont even know what it is, since it is undocumented as you say, or at least I didnt find information..<br /><br />when I log the TIB&#039;s address for that thread it is non-static value, something like 0x7fffe000 but can change.. I need to know how to get<br />to the opengl functions, I know I can access them from tib,,,I supposed that GLdispatchtable was to access them. how can I access them so &nbsp;:D ?<br /> <br /><br /><br /><br /></div>
    <div class="meta">Posted on 2010-07-06 22:04:44 by corso</div>
   </div>
   <div class="post" id="post-212238">
    <div class="subject"><a href="#post-212238">Re: to get the opengl driver addresses</a></div>
    <div class="body">If you can inject the DLL then use LoadLibrary(&quot;Opengl32.dll&quot;) (call once) + GetProcAddress (call many) to get pointers to them. These will be pointers to Opengl32.dll though, not the video card-specific DLL (but note that it is very unlikely that an application skips Opengl32.dll to call, say, glBegin).<br /><br />If you still want the TIB way, once your DLL is running inside the target process you can read just in the same way you saw in Opengl32.dll assembly listing (or getting a pointer to the FS selector of the thread that created the window first and then do the  part in case that using your injected thread&#039;s TIB doesn&#039;t produce expected results). Then you would use some inter process communication method to pass the pointers to your logger* (but remember that those addresses are invalid in the memory space of the logger process, any access through them should be with Read/WriteProcessMemory). Note that the DLL is not really necessary for this, your code seems to be OK except for the part where the TIB is read, as you should use ReadProcessMemory for that instead.<br /><br />*I&#039;ve assumed you want the logging to be made outside the target application process, if you can actually make everything from your injected DLL and thread then forget about inter process communication and Read/WriteProcessMemory, you&#039;re already in the context of the target process.</div>
    <div class="meta">Posted on 2010-07-06 22:50:16 by LocoDelAssembly</div>
   </div>
   <div class="post" id="post-212245">
    <div class="subject"><a href="#post-212245">Re: to get the opengl driver addresses</a></div>
    <div class="body">well i tried to do the same as in opengl32, that is it:<br /><br />5F1228F0 &gt; &nbsp;64:A1 18000000 &nbsp;MOV EAX,DWORD PTR FS:[18] //EAX=0x7FFDE000<br />5F1228F6 &nbsp;- FFA0 CC070000 &nbsp; JMP DWORD PTR DS: ; nvoglnt.6981C250 // EDX=69E00002 nvoglnt.69E00002<br /><br />then jumps to here<br />6981C250 &nbsp; &nbsp;64:A1 880E0000 &nbsp;MOV EAX,DWORD PTR FS:<br />6981C256 &nbsp; &nbsp;FF20 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;JMP DWORD PTR DS: //EAX=013800BC<br /><br />and then jumps to here<br />6962D940 &nbsp; &nbsp;53 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PUSH EBX<br /><br />that 0x7cc is the index for glbegin, but as you see in the dump, it loads an address from other index after.<br />if I log the first one it is null result<br />the correct TIB I get it using the fs selector for the thread.. I checked the addresss in debugger and in my log and it is the same<br />address, so I assume that is not the problem<br />till now i couldn&#039;t log at least one function &nbsp; :sad:<br /><br /><pre><code><br />DWORD thread_OGL(LPVOID parms)<br />{<br /> &nbsp; _CONTEXT Cxt;<br /> &nbsp; Cxt.ContextFlags=CONTEXT_FULL|CONTEXT_DEBUG_REGISTERS;<br /><br /> &nbsp; LDT_ENTRY SelEntry;<br /><br /> &nbsp; HWND hApp; // USE FINDWINDOW<br /> &nbsp; DWORD ProcId;<br /> &nbsp; DWORD ThId=GetWindowThreadProcessId(hApp,&amp;ProcId);<br /> <br /> &nbsp; HANDLE hProc=OpenProcess(PROCESS_ALL_ACCESS,FALSE,ProcId);<br /> &nbsp; <br /> &nbsp; HANDLE hTh=OpenThread(THREAD_ALL_ACCESS,FALSE,ThId);<br /><br /> &nbsp; SuspendThread(hTh);<br /> &nbsp;<br /> &nbsp; GetThreadContext(hTh, &amp;Cxt);<br /> &nbsp; GetThreadSelectorEntry(hTh, Cxt.SegFs, &amp;SelEntry);<br /><br /> &nbsp; ResumeThread(hTh);<br /><br /> &nbsp; DWORD* dwFSBase = (DWORD*)((SelEntry.HighWord.Bits.BaseHi&lt;&lt;24)|(SelEntry.HighWord.Bits.BaseMid&lt;&lt;16)|SelEntry.BaseLow);<br /> &nbsp; DPrint(&quot;dwFSBase 0x%X&quot;,dwFSBase);<br /><br /> &nbsp; DWORD dwglBegin;<br /> &nbsp; PTEB myTEB;<br />&nbsp;  WORD fsSel;<br /><br /> &nbsp; __asm{<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov eax, dwFSBase<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov , eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov , fs<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov ebx, <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov dwglBegin, ebx<br /> &nbsp; }<br /><br /> &nbsp; DPrint(&quot;dwglBegin 0x%X&quot;,dwglBegin);<br /><br /> &nbsp; CloseHandle(hTh);<br /> &nbsp; CloseHandle(hProc);<br /> &nbsp; return 0;<br />}<br /></code></pre></div>
    <div class="meta">Posted on 2010-07-07 09:54:18 by corso</div>
   </div>
   <div class="post" id="post-212258">
    <div class="subject"><a href="#post-212258">Re: to get the opengl driver addresses</a></div>
    <div class="body">I didnt try in a pc with another card than nvidiaS, for that, I think the second jump happens only with nvidia drivers, im not sure<br />no ideas? I will ask in other forums.<br /><br /></div>
    <div class="meta">Posted on 2010-07-09 17:47:52 by corso</div>
   </div>
  </div>
 </body>
</html>