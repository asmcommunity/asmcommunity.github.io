<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>graphics modes? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25743" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25743">graphics modes?</a></p>
   <div class="post" id="post-187836">
    <div class="subject"><a href="#post-187836">graphics modes?</a></div>
    <div class="body">I&#39;m new to assembler and have chosen to cut my teeth with fasm. I have gotten the hang of mode 13h. Thats cool, but I want access to a larger colour pallet and different screen resolutions. How can I go about this? Am I asking the right question or is there more to this than simply entering a different graphics mode?</div>
    <div class="meta">Posted on 2007-01-28 19:41:38 by rain_storm</div>
   </div>
   <div class="post" id="post-187837">
    <div class="subject"><a href="#post-187837">Re: graphics modes?</a></div>
    <div class="body">I suggest you to trash DOS and play with win32asm :) DirectX is way better than INT13h ;)<br /><br />But if you really wish: int10 is used to play with the video adapter.</div>
    <div class="meta">Posted on 2007-01-28 20:35:06 by ti_mo_n</div>
   </div>
   <div class="post" id="post-187838">
    <div class="subject"><a href="#post-187838">Re: graphics modes?</a></div>
    <div class="body">Thanks for the advice I think I will scrap DOS no point in going any further trying to learn a language when there are better alternatives. I knew there had to be a better way</div>
    <div class="meta">Posted on 2007-01-28 20:49:16 by rain_storm</div>
   </div>
   <div class="post" id="post-187840">
    <div class="subject"><a href="#post-187840">Re: graphics modes?</a></div>
    <div class="body">Read about SuperVGA specifications in Ralph Brown&#39;s Interrupt List, INT 0x10. Below is the code that I have written for the new version of my library which enumerates the available modes supported by your SuperVGA driver:<br /><br /><pre><span style="font-size:2>; ------------------------------<br />SVGAEnumModes PROC<br />&nbsp; COMMENT *<br />&nbsp; &nbsp; Description : Retrieves as many as AX modes that the SVGA Driver supports<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and puts the result as Mode Numbers in the buffer at .<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The number of enumerated modes will then be put into the AX register.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; See note(s).<br /><br />&nbsp; &nbsp; Calling Convention : Push from left to right.<br /><br />&nbsp; &nbsp; Parameter(s) :<br />&nbsp; &nbsp; &nbsp; WORD Param1 = Offset of the buffer with AX WORDs of space. See note(s).<br /><br />&nbsp; &nbsp; Stack Usage : 524 Bytes.<br /><br />&nbsp; &nbsp; Note : 1) The AX register should be set to the number of modes that you<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wish to enumerate. Note that each mode&#39;s code is 2 bytes long (WORD),<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; therefore, the buffer in the data segment pointed out by the <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parameter should have as many as AX WORDs of space, not bytes. Each WORD<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is 2 bytes therefore, the  buffer should have AX MUL 2 bytes<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of space.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  2) The AX register, after the invocation of this procedure, will be set<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to the number of modes enumerated.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  3) If an error occurs, the AX register will be set to 0x0000 after the<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invocation of this procedure.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  4) You can count the number of modes supported by your SVGA Driver<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using the  procedure.<br /><br />&nbsp; &nbsp; Example : Retrieve the number of supported SVGA Modes into a buffer which<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is only 10 bytes long.<br /><br />&nbsp; &nbsp; .DATA<br />&nbsp; &nbsp; &nbsp; String1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  DB&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 000Ah DUP(?)<br />&nbsp; &nbsp; .CODE<br />&nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp;  AX , 0005h&nbsp; &nbsp; &nbsp; ; 10 Bytes of space = 5 WORD modes (10/2=5)<br />&nbsp; &nbsp; &nbsp; PUSH&nbsp; &nbsp; OFFSET Buffer&nbsp;  ; The output buffer<br />&nbsp; &nbsp; &nbsp; CALL&nbsp; &nbsp; SVGAEnumModes&nbsp;  ; Enumerate the top 5 available modes<br />&nbsp; &nbsp; &nbsp; ADD&nbsp; &nbsp;  SP , 0002h&nbsp; &nbsp; &nbsp; ; Remove the buffer&#39;s offset<br />&nbsp; &nbsp; &nbsp; TEST&nbsp; &nbsp; AX , AX&nbsp; &nbsp; &nbsp; &nbsp;  ; See if AX == 0 (Failure?)<br />&nbsp; &nbsp; &nbsp; JE&nbsp; &nbsp; &nbsp; @@__Error&nbsp; &nbsp; &nbsp;  ; Jump to ... if yes<br />&nbsp; &nbsp; &nbsp; &nbsp; ; AX = Number of enumerated modes, Buffer = List of the modex<br />&nbsp; &nbsp; &nbsp; @@__Error:<br />&nbsp; &nbsp; &nbsp; &nbsp; ; An error has occurred<br />&nbsp; *<br />&nbsp; PUSH&nbsp; &nbsp; CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Push the count register onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Push the data register onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; SI&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Push the source index onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; DI&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Push the destination index onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; ES&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Push the extra segment<br />&nbsp; PUSH&nbsp; &nbsp; BP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Push the base pointer<br />&nbsp; XOR&nbsp; &nbsp;  CX , CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Set the temporary result to zero<br />&nbsp; TEST&nbsp; &nbsp; AX , AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; See if the number of requested modes is zero<br />&nbsp; JE&nbsp; &nbsp; &nbsp; @@__SVGAEnumModesEP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Jump to ... if yes<br />&nbsp; MOV&nbsp; &nbsp;  BP , SP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Move the stack pointer to the base pointer<br />&nbsp; SUB&nbsp; &nbsp;  SP , 0200h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Allocate 512 bytes of the stack space<br />&nbsp; MOV&nbsp; &nbsp;  SI , WORD PTR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; SI now points to , our output buffer<br />&nbsp; MOV&nbsp; &nbsp;  DX , AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; DX holds the number of modes to enum<br />&nbsp; MOV&nbsp; &nbsp;  AX , SS&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; AX points to the stack segment now<br />&nbsp; MOV&nbsp; &nbsp;  ES , AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; ES is now the same as the stack segment<br />&nbsp; MOV&nbsp; &nbsp;  DI , SP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; ES: = Pointer to the buffer in the stack<br />&nbsp; MOV&nbsp; &nbsp;  AX , 04F00h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; AX = Get SuperVGA Information<br />&nbsp; DW&nbsp; &nbsp; &nbsp; 10CDh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Issue the interrupt<br />&nbsp; CMP&nbsp; &nbsp;  AX , 004Fh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; AH = 00h and AL = 04F = Success?<br />&nbsp; JNE&nbsp; &nbsp;  @@__SVGAEnumModesEP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Jump to ... if not<br />&nbsp; ADD&nbsp; &nbsp;  DI , 000Eh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Navigate DI to the Modes List<br />&nbsp; MOV&nbsp; &nbsp;  AX , WORD PTR ES:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; AX holds the offset of this pointer<br />&nbsp; MOV&nbsp; &nbsp;  ES , WORD PTR ES:&nbsp; &nbsp;  ; ES points to the segment of this list<br />&nbsp; MOV&nbsp; &nbsp;  DI , AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; ES: = Pointer to the Modes List<br />&nbsp; @@__SVGAEnumModesL:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; The main loop of the procedure<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  AX , WORD PTR ES:&nbsp; &nbsp; &nbsp; &nbsp;  ; Read one SVGA Mode at a time<br />&nbsp; &nbsp; CMP&nbsp; &nbsp;  AX , 0FFFFh&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; See if we have reached the end of the list<br />&nbsp; &nbsp; JE&nbsp; &nbsp; &nbsp; @@__SVGAEnumModesEP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Jump to ... if yes<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  WORD PTR  , AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Put the Mode in the  buffer<br />&nbsp; &nbsp; ADD&nbsp; &nbsp;  DI , 0002h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Move tot he next mode in the list<br />&nbsp; &nbsp; ADD&nbsp; &nbsp;  SI , 0002h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Move to the next two bytes of the buffer<br />&nbsp; &nbsp; INC&nbsp; &nbsp;  CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; We have enumerated one more mode<br />&nbsp; &nbsp; DEC&nbsp; &nbsp;  DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Decrement the buffer length in WORD<br />&nbsp; &nbsp; JNE&nbsp; &nbsp;  @@__SVGAEnumModesL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Keep enumerating if we have space<br />&nbsp; @@__SVGAEnumModesEP:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; End of the procedure routine<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  AX , CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; AX holds the number of enumerated modes<br />&nbsp; &nbsp; ADD&nbsp; &nbsp;  SP , 0200h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Deallocate 512 bytes of the stack space<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  BP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Restore the base pointer<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  ES&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Restore the extra segment<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  DI&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Restore the destination index<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  SI&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Restore the source index<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Restore the data register<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Restore the count register<br />&nbsp; RET&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Return to the calling procedure<br />SVGAEnumModes ENDP</span></pre><br /><br />I hope that it gives you the idea.</div>
    <div class="meta">Posted on 2007-01-28 21:53:39 by XCHG</div>
   </div>
   <div class="post" id="post-187842">
    <div class="subject"><a href="#post-187842">Re: graphics modes?</a></div>
    <div class="body">For DOS, you should look into VESA2/VESA3. Dunno how good card support is these days, I have the impression there&#39;s only support for the basics since dos is dead.<br /><br />The sane thing is do move to DirectX or OpenGL. These days, even 2D stuff tends to be done with 3D, to take full advantage of hardware acceleration... But you can program for, say, DX7/DirectDraw, and that will still work with most recent DX9.whatever since it&#39;s mostly backwards compatible.<br /></div>
    <div class="meta">Posted on 2007-01-29 00:33:47 by f0dder</div>
   </div>
   <div class="post" id="post-187849">
    <div class="subject"><a href="#post-187849">Re: graphics modes?</a></div>
    <div class="body">Thanks for the replies. Anybody got a link to good tutorials for DirectX?</div>
    <div class="meta">Posted on 2007-01-29 10:29:20 by rain_storm</div>
   </div>
   <div class="post" id="post-187851">
    <div class="subject"><a href="#post-187851">Re: graphics modes?</a></div>
    <div class="body">First, start by learning win32asm in general, then add some OOP to your ASM, then learn DX. Going to DX directly will only discourage you.</div>
    <div class="meta">Posted on 2007-01-29 16:17:27 by ti_mo_n</div>
   </div>
   <div class="post" id="post-188122">
    <div class="subject"><a href="#post-188122">Re: graphics modes?</a></div>
    <div class="body">I was informed that the demoscene put restrictions on the files and you are not always allowed to use include when entering a competition. a fellow demoscener explained to me that direct x would limit the compos I could enter. he also showed how to manipulate the pallet this is more what I was talking about <br /><br />org 100h<br /><br />mov al, 13h&nbsp; &nbsp; &nbsp;  ; enter graphics mode<br />int 10h<br />mov ax, 0A000h&nbsp; &nbsp; ; get screen buffer offset<br />mov ds, ax&nbsp; &nbsp; &nbsp; &nbsp; ; and put it in ds<br /><br />mov dx,03C8h&nbsp; &nbsp; &nbsp; ; get colour pallet offset<br />xor al,al&nbsp; &nbsp; &nbsp; &nbsp;  ; clear al<br />out dx,al&nbsp; &nbsp; &nbsp; &nbsp;  ; send zero to vga card<br />inc dx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; now dx points to pallet<br /><br />; really bad pallet generator<br />reds:<br />&nbsp;  mov al, bl&nbsp; &nbsp;  ; get brightness<br />&nbsp;  out dx, al&nbsp; &nbsp;  ; red<br />&nbsp;  xor al, al&nbsp; &nbsp;  ; only red<br />&nbsp;  out dx, al&nbsp; &nbsp;  ; green<br />&nbsp;  out dx, al&nbsp; &nbsp;  ; blue<br /><br />&nbsp;  mov al, bl&nbsp; &nbsp;  ; get brightness<br />&nbsp;  out dx, al&nbsp; &nbsp;  ; red<br />&nbsp;  xor al, al&nbsp; &nbsp;  ; only red<br />&nbsp;  out dx, al&nbsp; &nbsp;  ; green<br />&nbsp;  out dx, al&nbsp; &nbsp;  ; blue<br /><br />&nbsp;  mov al, bl&nbsp; &nbsp;  ; get brightness<br />&nbsp;  out dx, al&nbsp; &nbsp;  ; red<br />&nbsp;  xor al, al&nbsp; &nbsp;  ; only red<br />&nbsp;  out dx, al&nbsp; &nbsp;  ; green<br />&nbsp;  out dx, al&nbsp; &nbsp;  ; blue<br /><br />&nbsp;  mov al, bl&nbsp; &nbsp;  ; get brightness<br />&nbsp;  out dx, al&nbsp; &nbsp;  ; red<br />&nbsp;  xor al, al&nbsp; &nbsp;  ; only red<br />&nbsp;  out dx, al&nbsp; &nbsp;  ; green<br />&nbsp;  out dx, al&nbsp; &nbsp;  ; blue<br /><br />&nbsp;  inc bl&nbsp; &nbsp; &nbsp; &nbsp;  ; make it a bit brighter<br />&nbsp;  cmp bl, 64&nbsp; &nbsp;  ; check for max brightness<br />&nbsp;  jb&nbsp; reds&nbsp; &nbsp; &nbsp;  ; loop if not max brightness<br /><br />draw:<br />&nbsp;  mov , dl&nbsp;  ; put colour on screen<br />&nbsp;  add dx, 04h&nbsp; &nbsp; ; next colour<br />&nbsp;  inc si&nbsp; &nbsp; &nbsp; &nbsp;  ; next pixel<br />&nbsp;  cmp si, 0FFFFh ; compare against screen buffer limit<br />&nbsp;  jb&nbsp; draw&nbsp; &nbsp; &nbsp;  ; loop<br />&nbsp;  add dx, 01h&nbsp; &nbsp; ; scroll one colour for next frame<br /><br />&nbsp;  mov ah, 01h&nbsp; &nbsp; ; check for key press<br />&nbsp;  int 16h<br />&nbsp;  jz&nbsp; draw&nbsp; &nbsp; &nbsp;  ; loop<br /><br />&nbsp;  mov ax, 0003h&nbsp; ; enter text mode<br />&nbsp;  int 10h<br />&nbsp;  mov ah, 4Ch&nbsp; &nbsp; ; exit to o/s<br />&nbsp;  int 21h<br /><br />he was saying that it was mode x that I should be looking into first then go for direct x. Not perfect but at least its something.</div>
    <div class="meta">Posted on 2007-02-14 18:18:40 by rain_storm</div>
   </div>
  </div>
 </body>
</html>