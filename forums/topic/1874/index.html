<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>anyncronous send/recv - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=1874" />
    <link rel="next" href="../?id=1874&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=8">Networking</a> &raquo; <a href="../?id=1874">anyncronous send/recv</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=1874&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=1874&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="1874" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=1874&amp;page=2">&gt;</a><a href="../?id=1874&amp;page=2">&raquo;</a></form>   <div class="post" id="post-11962">
    <div class="subject"><a href="#post-11962">anyncronous send/recv</a></div>
    <div class="body">hi,<br />can someone roughly explain to me how i can send and receive a large file in non-blocking mode? i know for example that in blocking mode you would say something like invoke recv, blah and the program is waiting for the download to complete. but what if u r in non - blocking mode and you want to process the window messages?<br />i have noticed random's question. A lot of things iam note sure about. for example,  if i want to receve a file, under WN_SOCKET-&gt;FD_READ what shall i do!? ive noticed its better to receive part by part the file. how do we do that? and also, i would like to add a progress bar to show the remaining download bytes. How, and where shall i update the progressbar?!<br /><br />thanks to all.</div>
    <div class="meta">Posted on 2001-11-14 07:01:36 by Unregistered</div>
   </div>
   <div class="post" id="post-11965">
    <div class="subject"><a href="#post-11965">anyncronous send/recv</a></div>
    <div class="body">When a socket is set in asynchronous mode (with WSAAsyncSelect for example), you receive serveral notification messages like FD_READ, FD_WRITE, FD_ACCEPT, FD_CLOSE etc, depending on which you selected with WSAAsyncSelect.<br /><br />These messages notify you of a specific event that needs to be handled. The description of FD_READ is:<br /><strong>FD_READ</strong>: is sent whenever data is waiting on the socket. At this point, receive the data with recv. You'll have to pass the max nr of bytes you want to receive, and this can be more or less than the real size of the data waiting. <br /><br />Winsock does not send another FD_READ until it's re-enabled. This re-enabling happens when you call recv (or other functions of the same kind). Even when recv failes, or you do not get all the bytes waiting at the socket, the message is re-enabled anyway. So it doesn't matter how many bytes you receive, as winsock will send you a message whenever there's still data left. But remember that it won't send anything until you re-enable it with recv.<br /><br />For more detailed help, take a look at the winsock programming reference (sock2.hlp, available for download at my site), especially WSAAsyncSelect (lots of info about FD_* here)<br /><br />So you'll just have to wait for a FD_READ msg, read some bytes, add the received data to your output buffer, update the progress bar (also in the FD_READ handler), and quit the handler so you can wait for the next msg.<br /><br />Thomas</div>
    <div class="meta">Posted on 2001-11-14 07:31:59 by Thomas</div>
   </div>
   <div class="post" id="post-11982">
    <div class="subject"><a href="#post-11982">anyncronous send/recv</a></div>
    <div class="body">Greetings Thomas,<br /><br />so, lets say i am receiving a 4mb file !<br />on FD_READ I invoke recv, sock , pMem, 4mb (size),0 !<br /><br />now, this download will take a while. What happens to the other window messages? Will they get processed or will my window look like frozen?!<br />Also if this is the case, where shall i place my progressbar update call?<br /><br />thanks.<br /><br />P.s. Have you got the chance to write that winsock tutorial yet?<br /><br />p.s2. sorry for the unregister thing..<br />:alright:</div>
    <div class="meta">Posted on 2001-11-14 10:34:02 by Ray</div>
   </div>
   <div class="post" id="post-11986">
    <div class="subject"><a href="#post-11986">anyncronous send/recv</a></div>
    <div class="body">You don't want to call recv with a 4mb buffer, but with a smaller buffer ... say 8kb then return ... the window will then receive another FD_READ. <br />On very big file it's quite inefficient ... as I found out. You better do this:<br /><br />DISABLE FD_READ with WSAAsyncSelect<br />loop the recv until you get a SOCKET_ERROR (or a zero = EOF)<br />RE-ENABLE FD_READ<br /><br />If you loop the recv without disabling FD_READ, you'll get a lot of &quot;trash&quot; FD_READ messages <br /><br /><br />Hold on ... here is the M$ words on it, which is better than my crap above ;)<br /><br />For FD_READ, FD_OOB, and FD_ACCEPT events, message posting is &quot;level-triggerred.&quot;<br />Consider the following sequence:<br /><br /><br />(i)	Windows Sockets DLL receives 100 bytes of data on socket s and posts an FD_READ message.<br />(ii)	The application issues recv( s, buffptr, 50, 0) to read 50 bytes.<br />(iii)	The Windows Sockets DLL posts another FD_READ message since there is still data to be read.<br /><br /><br />With these semantics, an application need not read all available data in response to an FD_READ message--a single recv() in response to each FD_READ message is appropriate.  If an application issues multiple recv() calls in response to a single FD_READ, it may receive multiple FD_READ messages.  Such an application may wish to disable FD_READ messages before starting the recv() calls by calling WSAAsyncSelect() with the FD_READ event not set.<br /><br />Let me know if it makes any sense<br /><br />Random</div>
    <div class="meta">Posted on 2001-11-14 10:46:40 by random</div>
   </div>
   <div class="post" id="post-11989">
    <div class="subject"><a href="#post-11989">anyncronous send/recv</a></div>
    <div class="body"><div class="quote">Greetings Thomas, <br /><br />so, lets say i am receiving a 4mb file ! <br />on FD_READ I invoke recv, sock , pMem, 4mb (size),0 ! <br /><br />now, this download will take a while. What happens to the other window messages? Will they get processed or will my window look like frozen?! <br /></div><br />It's not a good idea and also useless to set the size param to 4MB, as recv will only put as much as is available at that point into the buffer. Then it will just return and not wait for more.. So unless you have a 1gbit connection, recv will just store as much bytes as it can in the buffer (say 4kb for example), and then return. When the next data part is available, FD_READ will be called again. This is exactly the difference between blocked &amp; non-blocked. A blocked socket would hang on the recv until it has received 4MB, and that would cause a frozen window... But this is non-blocking mode.. <br />Your code would probably cause corrupted data as you assume everything is downloaded in one call, but it isn't.<br /><br />You should have three variables: pMem for the pointer to the allocated mem (make sure it has the correct size), 4mb in your case, one that holds the nr of bytes already received (nBytesReceived), and one that holds the total number of bytes to be received (nBytesToDo)<br /><pre><code><br />before downloading, set pMem and initialize nBytesReceived to zero.<br />...<br />on FD_READ&#58;<br /><br />mov     eax, nBytesReceived     ;bytes received so far<br />mov     ecx, nBytesToDo         ;TOTAL number of bytes to read<br />sub     ecx, eax                ; = nr of bytes yet to do<br />.IF     ecx&gt;4096<br />    mov     ecx, 4096           ;don't do more than 4KB at a time<br />.ENDIF<br />add     eax, pMem               ;add base pointer<br />invoke  recv, hSock, eax, ecx   ;read pending data<br />.IF     eax==0<br />    ;connection is closed<br />.ELSEIF eax==SOCKET_ERROR <br />    ;error occurred<br />.ELSE<br />    add     nBytesReceived, eax ;update byte counter<br />.ENDIF<br /><br />mov     eax, nBytesReceived<br />.IF eax==nBytesToDo<br />    ;download finished<br />.ENDIF<br />...<br /></code></pre><br /><br />This will add whatever data is pending to the buffer. It will do 4KB at most each time. Note that unlike in blocking mode, this value is just the maximum amount of data you want recv to return. It has no other relation to the amount of data pending or actually returned.. You can remove the IF with the 4096 too, then it would download as much data as possible, but because this is unlikely to happen I use a maximum amount most of the time.<br /><br /><div class="quote">Also if this is the case, where shall i place my progressbar update call? </div><br /><br />At the end of the FD_READ message will do.<br /><br /><div class="quote"><br />thanks. <br /><br />P.s. Have you got the chance to write that winsock tutorial yet? <br /></div><br />I started with it and I've written a few chapters on blocking mode winsock and was about to start with non-blocking stuff, but I'm working on two projects now (the oop tool and httpft) and haven't had much time (as usual :( ), but maybe later..<br /><br /><div class="quote"><br />p.s2. sorry for the unregister thing <br /></div><br /><br />Well I know who you are now :) <br /><br />Thomas</div>
    <div class="meta">Posted on 2001-11-14 10:55:38 by Thomas</div>
   </div>
   <div class="post" id="post-11990">
    <div class="subject"><a href="#post-11990">anyncronous send/recv</a></div>
    <div class="body">Random: I have used the method with calling recv multiple times a long time because I thought that was the right way to do it.. And of course it's perfectly correct but as the doc says...<br />&quot;With these semantics, an application need not read all available data in response to an FD_READ message--a single recv() in response to each FD_READ message is appropriate. &quot;<br />... a single will do too and it's a bit easier to implement. So it's more a matter of style if you choose for the multiple recvs or just one.<br /><br />Thomas</div>
    <div class="meta">Posted on 2001-11-14 10:58:48 by Thomas</div>
   </div>
   <div class="post" id="post-11991">
    <div class="subject"><a href="#post-11991">anyncronous send/recv</a></div>
    <div class="body">Random:<br /><div class="quote">On very big file it's quite inefficient ... as I found out</div><br />I overlooked this in your post the first time I read it .. This may be true.. Instead of the multiple recvs you can use ioctlsocket to determine the amount of data waiting on the socket too. Then one recv would get as much data as possible.. Which is the same as calling recv until it fails.. Maybe that's more efficient..<br /><br />Thomas</div>
    <div class="meta">Posted on 2001-11-14 11:03:22 by Thomas</div>
   </div>
   <div class="post" id="post-12003">
    <div class="subject"><a href="#post-12003">anyncronous send/recv</a></div>
    <div class="body">I tried ioctlsocket but doesn't work when you have a very fast stream of data coming in (I tested with various files up to 1Gb on Ethernet 10 and 100Mbit)<br /><br />ioctlsocket will return a value up to the maximum TCP window anyway (or whatever it's called, can't remember) ... by the time you recv that amount and wait for the (very slow) window message, you have already filled the buffer .. and blocked the sending peer, thus reducing the transfer performance<br /><br />I think there are 2 ways to saturate the bandwidth and have an efficient transfer of huge files:<br /><br />1) blocking sockets and threads (it's what I'm using now, after dropping the async sockets ... I'm writing a laplink kind of program and I really just need 1 connection between the server and the client): again .. it's important not to call recv with a big buffer, otherwise you &quot;saturate&quot; the buffer and interrupt the smooth flow of traffic. The right size of the buffer depends on various factors: the speed of the PC, the speed of the network, the NIC on-board memory and the OS settings = a fu**ing nightmare to achieve the maximum performance on all machines<br /><br />2) Overallapped I/O and completion ports (for a truly scalable server ... say a web or ftp server); haven't tried it yet but will do as soon as I have time to spare, looks very complicated to code correctly though<br /><br />Remember ... I'm talking about pure transfer speed of big files here.<br />For normal data traffic, async works great<br />I've been working around this issue for more than a month, but at least I start getting the performance I expect.<br /><br />Random</div>
    <div class="meta">Posted on 2001-11-14 12:37:46 by random</div>
   </div>
   <div class="post" id="post-12010">
    <div class="subject"><a href="#post-12010">anyncronous send/recv</a></div>
    <div class="body"><pre><code><br />Overallapped I/O and completion ports &#40;for a truly scalable server ... say a web or ftp server&#41;; <br /></code></pre><br />Actually I am writing a webserver :).. well I'm not trying to rewrite apache or something but nonetheless a full blown web server (with an AHP module :) ) for my httpft program.. Although I don't have much bandwidth on my internet connection I'm interested in the method that delivers the highest performance.. But I don't think I want to be messing with overlapped I/O... The first version of the server (which actually worked) used a combination of threads and asynchronous sockets (with windows messages). I think I'll switch to event sockets now.. there's a function called WSAEventSelect (or SelectEvent, can't remember) which is almost the same as WSAAsyncSelect, but triggers an event object instead of sending a window message. That should be faster than windows messages<br />I don't like blocking sockets because...well... they block :grin: <br />I want to have full control all the time and the thread should receive messages from the webserver too, which is already done via a message queue (my own) and a wake-up event.<br />I didn't know ioctlsocket returned only the maximum tcp window size... I think I switch to multiple recvs back again as well.<br />When everythings working again I'll try it out on the local 100Mbit network (using WSAEventSelect and multiple recvs until failure) to see how it performs.<br /><br />Thanks for the information, :alright: <br /><br />Thomas</div>
    <div class="meta">Posted on 2001-11-14 13:08:28 by Thomas</div>
   </div>
   <div class="post" id="post-12011">
    <div class="subject"><a href="#post-12011">anyncronous send/recv</a></div>
    <div class="body">Sounds good :)<br /><br />Only problem of WSAAsyncEvent is that's a new function on winsock 2.0 and will not work on machine with the ver1.1 of the stack (very little of them around anyway)<br />Actually that's the same problem of overlapped I/O !! eheh<br /><br />I'm looking forward to see your program in action<br /><br /><br />Random</div>
    <div class="meta">Posted on 2001-11-14 13:16:32 by random</div>
   </div>
   <div class="post" id="post-12013">
    <div class="subject"><a href="#post-12013">anyncronous send/recv</a></div>
    <div class="body">I've dumped 1.1 already when I started with the program.. I always import ws2_32.lib instead of wsock32.lib... Iirc, only old win95 versions do not support winsock 2, and for those version a patch is around somewhere... And the docs of wsock2 looked so much better than 1.1 :).<br />btw I've made a little test program that just keeps outputting bytes (in blocked mode, very simple).. Now I'll try a few client methods to see which performs best.. You can remove the comments above the Crap variable to make a browser get the data (<a target="_blank" href="http://yourserver:4444/blah.dat">http://yourserver:4444/blah.dat</a>).. but that's not really a good performance test as it also has to be written to disk then..<br />I'll post the clients as soon as I finished them.</div>
    <div class="meta">Posted on 2001-11-14 13:45:01 by Thomas</div>
   </div>
   <div class="post" id="post-12014">
    <div class="subject"><a href="#post-12014">anyncronous send/recv</a></div>
    <div class="body">Well, WSAAsyncEvent might only work on winsock2 (which is default<br />since win98, and can be applied to win95 as a patch)... but overlapped<br />I/O and completion ports... aren't they nt/2k/xp only?</div>
    <div class="meta">Posted on 2001-11-14 13:45:19 by f0dder</div>
   </div>
   <div class="post" id="post-12023">
    <div class="subject"><a href="#post-12023">anyncronous send/recv</a></div>
    <div class="body">f0dder: I never used it but all functions that deal with overlapped I/O seem to be supported in both windows &amp; windows NT, according to the docs.<br /><br />random: The attachments contains the server &amp; 6 clients using different methods.. I didn't have the chance to test it on the local network yet, so I just used localhost for now (but of couse the local network is more interesting..) In client.inc are some general setting you can play with like the IP of the server to connect to, the packet size and the amount of data to be received.. My results with localhost are showed below, but maybe it's totally different with a real network.. I'll try as soon as I can.<br /><pre><code><br />1&#58; WSAAsyncSelect <br />1A&#58; WSAsyncSelect with multiple recvs<br />2&#58; Blocking mode in thread<br />3&#58; WSAEventSelect in thrad<br />4&#58; WSAEventSelect in thread with multiple recvs<br />5&#58; WSAEventSelect in thread with ioctlsocket<br /><br />localhost&#58;<br />1&#41; 256 MB in 4.316 s &#40; 59.3 MB/s&#41;<br />1A&#41;256 MB in 5.228 s &#40; 50.0 MB/s&#41;<br />2&#41; 256 MB in 2.764 s &#40; 92.6 MB/s&#41;<br />3&#41; 256 MB in 1.562 s &#40;163.9 MB/s&#41;<br />4&#41; 256 MB in 2.784 s &#40; 92.0 MB/s&#41;<br />5&#41; 256 MB in 1.813 s &#40;141.2 MB/s&#41;<br /></code></pre><br /><br />Thomas<br />P.S. Don't look at the style of the programs, they are awfully written, just to write them as fast as possible.. the winsock code is correct though. :)</div>
    <div class="meta">Posted on 2001-11-14 14:46:33 by Thomas</div>
   </div>
   <div class="post" id="post-12083">
    <div class="subject"><a href="#post-12083">anyncronous send/recv</a></div>
    <div class="body">Random, Thomas,<br /><br />thanks a lot. i'll give it a try and see what happens. And if i mess up again, hey, you will se me again :rolleyes: <br /><br /><br />:alright:</div>
    <div class="meta">Posted on 2001-11-15 01:13:42 by Ray</div>
   </div>
   <div class="post" id="post-12088">
    <div class="subject"><a href="#post-12088">anyncronous send/recv</a></div>
    <div class="body">Here are the time for my local network:<br /><pre><code><br />1&#58; WSAAsyncSelect <br />1A&#58; WSAsyncSelect with multiple recvs<br />2&#58; Blocking mode in thread<br />3&#58; WSAEventSelect in thrad<br />4&#58; WSAEventSelect in thread with multiple recvs<br />5&#58; WSAEventSelect in thread with ioctlsocket<br /><br />local network &#40;100 Mbit&#41;&#58;<br />1&#41; 256 MB in 60.173 s &#40;4.25 MB/s&#41;<br />1A&#41;*<br />2&#41; 256 MB in 49.072 s &#40;5.22 MB/s&#41;<br />3&#41; 256 MB in 49.334 s &#40;5.19 MB/s&#41;<br />4&#41; 256 MB in 49.154 s &#40;5.21 MB/s&#41;<br />5&#41; 256 MB in 50.319 s &#40;5.09 MB/s&#41;<br /><br />*1A&#58; Program ran out of resources &#40;bug?&#41;<br /></code></pre><br /><br />It's clear than WSAAsyncSelect is the slowest, and also important to note here is that 1 is too busy with handling the wsock message that it's window becomes totally frozen... <br />The others didn't have this problem but they react a bit slow though... The differences for 2-5 are not so big, the localhost test gave some bigger differences. Somehow the 1A test crashed and window told that it was out of resources so there may be a bug there.<br />Do you know if you can use the full 100Mbit bandwith? That would be 12.5 MB/s but it reaches 5.22 at most... Maybe the tcp/ip overhead is to big.<br /><br />Thomas</div>
    <div class="meta">Posted on 2001-11-15 02:16:53 by Thomas</div>
   </div>
   <div class="post" id="post-12117">
    <div class="subject"><a href="#post-12117">anyncronous send/recv</a></div>
    <div class="body">Hm, is megabit meaured in 1000^2 or 1024^2? I think I saw it measured<br />in 1000^2 a few couple of places?<br /><br />Anyway, TCP overhead is one thing (try with UDP), the fact that<br />most network adapters don't reach their full speed is another.<br />If you have el-cheapo cards like realtek8139 (like me :D), 5MB/s<br />is sorta OK. I can reach 6-7MB/s at max (my box #2 is a sorta old<br />machine, so it might get a bit swamped, and the NICs might be able<br />to go a bit higher).</div>
    <div class="meta">Posted on 2001-11-15 06:23:51 by f0dder</div>
   </div>
   <div class="post" id="post-12131">
    <div class="subject"><a href="#post-12131">anyncronous send/recv</a></div>
    <div class="body"><div class="quote">Hm, is megabit meaured in 1000^2 or 1024^2? I think I saw it measured in 1000^2 a few couple of places? </div> <br /><br />I did use 1024^2, where did you see 1000?</div>
    <div class="meta">Posted on 2001-11-15 09:13:22 by Thomas</div>
   </div>
   <div class="post" id="post-12132">
    <div class="subject"><a href="#post-12132">anyncronous send/recv</a></div>
    <div class="body">I can't remember where, but the person seemed to know what he<br />was talking about, and he wrote that you measure bps (bit per second)<br />in the traditional 1000-way, instead of the byte-way of 1024...<br />which confused me a bit, as computer guys are usually very fond of<br />1024, and the only (other?) place I've seen 1000-measurement is<br />in harddrive sizes (by the manufacturers), which is clearly a marketing<br />trick to make their drives appear larger than they are :/</div>
    <div class="meta">Posted on 2001-11-15 09:23:08 by f0dder</div>
   </div>
   <div class="post" id="post-12247">
    <div class="subject"><a href="#post-12247">anyncronous send/recv</a></div>
    <div class="body">I tested it on my office LAN (should be 100Mbit but god knows how they rigged the servers up) and got around 4Mb/s<br />Anyway, you can't really expect to reach the full 100Mbits ... I think  they normally reach around 70Mbit of actual throughpuy anyway, plus consider that things like quality of hub/switches, NIC, HD etc etc impact the performance ... plus the size of the protocol overhead are important.<br />Try and test it sending 8kb packets (that's the ethernet size anyway) instead of 4kb ... you should be able to get better results (in my case I improved it by only by 0.5Mb ... but that's because as I said my network sucks :( )<br /><br />cheers<br />Random</div>
    <div class="meta">Posted on 2001-11-16 09:03:18 by random</div>
   </div>
   <div class="post" id="post-12250">
    <div class="subject"><a href="#post-12250">anyncronous send/recv</a></div>
    <div class="body">Protocol overhead isn't all that bad, though it does swallow some.<br />If you have a direct cross cable between to machines, or a network<br />with only two machines generating network traffic (and not total<br />crap equipment), you should be able to reach decent speeds.<br /><br />And btw, the ethernet packet size is 1500 bytes.</div>
    <div class="meta">Posted on 2001-11-16 09:12:40 by f0dder</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=1874&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=1874&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="1874" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=1874&amp;page=2">&gt;</a><a href="../?id=1874&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>