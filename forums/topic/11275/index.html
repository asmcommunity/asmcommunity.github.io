<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>code efficiency question - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=11275" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=11275">code efficiency question</a></p>
   <div class="post" id="post-84988">
    <div class="subject"><a href="#post-84988">code efficiency question</a></div>
    <div class="body">howdy, what a nice place this board seems to be, anyway, I haven't programmed x86 assembly for *quite* some time, so I'll probably ask a lot of dumb questions while getting back into the game. First off, when I just started programming again now I have some questions about register preservation across api calls, basically which method is more faster/effective, say if I need to preserve a register between api calls, is it faster to push/pop or do a mov &lt;reg&gt;, <br /><br />pseudo example:<br /><br /><br />mov ebx, (important data to preserve)<br />push ebx<br />invoke API_CALL_THAT_TRASHES_EBX<br />pop ebx<br />inc ebx<br />push ebx<br />invoke API_CALL_THAT_THRASHES_EBX<br />pop ebx<br /><br /><br />or is this faster/better/smarter?<br /><br /><br />mov ebx, (important data to preserve)<br />push ebx<br />invoke API_CALL_THAT_TRASHES_EBX<br />mov ebx, <br />inc ebx<br />invoke API_CALL_THAT_THRASHES_EBX<br />pop ebx<br /><br /><br />in this short example the pushing and poping of the first code won't do any difference, but while preserving a reg during a LONG line of API calls I wondered if it's not more efficient to just use mov &lt;reg&gt;,  instead of pop/push between each api call.<br /><br />sorry if this is really a dumb question, as I said I haven't programmed x86 for QUITE a while, in fact last time I programmed x86 was using the pmode dos extender (ahh those were the days!)<br /><br />kind regards, BinarySoup</div>
    <div class="meta">Posted on 2003-03-04 10:41:03 by BinarySoup</div>
   </div>
   <div class="post" id="post-85004">
    <div class="subject"><a href="#post-85004">code efficiency question</a></div>
    <div class="body">There's been a LOT said on register preservation. here's the summary:<br /><br />1) All api functions will preserve <strong>ebx,edi,esi</strong>.  In your example above you don't need to push/pop ebx on every function call.<br />2) If you alter <strong>ebx,edi,esi</strong> in your function then you must preserve them.<br />3) the other registers <strong>eax,ecx,edx</strong> are expendable.<br /><br /><strong>mov &lt;reg&gt;, </strong>would be faster.  I wouldn't get too smart if i were you. with each push/pop esp will change and you could very easily end up sitting in the corner with a pointy hat...;)</div>
    <div class="meta">Posted on 2003-03-04 12:14:55 by MArtial_Code</div>
   </div>
   <div class="post" id="post-85008">
    <div class="subject"><a href="#post-85008">code efficiency question</a></div>
    <div class="body"><div class="quote"><strong>mov &lt;reg&gt;, </strong>would be faster.  I wouldn't get too smart if i were you. with each push/pop esp will change and you could very easily end up sitting in the corner with a pointy hat...;) </div><br />Not only that, the API may change parameters on the stack so the value is not guaranteed to be the same as before after the call.<br /><br />Thomas</div>
    <div class="meta">Posted on 2003-03-04 12:29:38 by Thomas</div>
   </div>
   <div class="post" id="post-85009">
    <div class="subject"><a href="#post-85009">code efficiency question</a></div>
    <div class="body">thankyou very much for the responce, as a reward here's more stupid questions ;)<br /><br />MArtial_Code wrote:<br /><div class="quote">If you alter ebx,edi,esi in your function then you must preserve them.</div> <br />why? does the system need them preserved?? in the small programs I've written now I'm not preserving any regs between my own function calls (unless I need them preserved myself), and they seem to work, does the proc automatically preserve regs unless stated?<br /><br />MArtial_Code wrote:<br /><div class="quote">mov &lt;reg&gt;, would be faster. I wouldn't get too smart if i were you. with each push/pop esp will change and you could very easily end up sitting in the corner with a pointy hat...</div> <br />that's what I wanted to know, big thanks, well back in the old days when one didn't have fancy things like INVOKE ;) I usually retrieved parameters from the stack using the basic , hopefully I remember the pitfalls, if not, I always<br />had a thing for pointy hats ;)</div>
    <div class="meta">Posted on 2003-03-04 12:30:38 by BinarySoup</div>
   </div>
   <div class="post" id="post-85010">
    <div class="subject"><a href="#post-85010">code efficiency question</a></div>
    <div class="body">Thomas wrote:<br /><div class="quote">Not only that, the API may change parameters on the stack so the value is not guaranteed to be the same as before after the call.</div><br /><br />ehh, am I missing something here? you're saying that what I put at the top of the stack before a call may not be on the top of the stack after a API call??</div>
    <div class="meta">Posted on 2003-03-04 12:34:54 by BinarySoup</div>
   </div>
   <div class="post" id="post-85012">
    <div class="subject"><a href="#post-85012">code efficiency question</a></div>
    <div class="body">I'm not sure what Thomas is saying...?  I've not heard that before...<br /><br /><strong>If you alter ebx,edi,esi in your function then you must preserve them.</strong><br /><br />Specifically when your callback function returns windows expects the above mentioned registers to be unaltered.   Across your own functions the regiters which you preserve are at your discretion but in the world of windows programming, preserving ebx,edi,esi has been conventionalised.<br /><br />wndproc proc .... ;called by windows<br /> <br />   call FUNCTION_which_uses_ebx_edi_esi<br />   ret<br />wndproc endp<br /><br />FUNCTION_which_uses_ebx_edi_esi proc ...<br />   push edi<br />   push esi<br />   push ebx<br /><br />   change edi,esi,ebx here<br /> <br />   pop ebx<br />   pop esi<br />   pop edi<br />  ret<br />FUNCTION_which_uses_ebx_edi_esi endp</div>
    <div class="meta">Posted on 2003-03-04 12:55:36 by MArtial_Code</div>
   </div>
   <div class="post" id="post-85015">
    <div class="subject"><a href="#post-85015">code efficiency question</a></div>
    <div class="body">mov ,ebx<br />call function<br />mov ebx,<br />...<br /><br />function:<br />push eax<br />...<br />pop eax<br />ret<br /><br />This way you wouldn't get the same result in ebx after the function call, because eax is put at the same point in the stack as ebx. Alter esp as well if you want to use mov instead of push.</div>
    <div class="meta">Posted on 2003-03-04 13:02:59 by _js_</div>
   </div>
   <div class="post" id="post-85019">
    <div class="subject"><a href="#post-85019">code efficiency question</a></div>
    <div class="body">MArtial_Code wrote:<br /><div class="quote">If you alter ebx,edi,esi in your function then you must preserve them.</div> <br />ok, then I have to ask, when defining a standard proc, not adding USES :, does it preserve these registers by default or? because I am changing ebx in basically every function I call and haven't manually preserved it, and yet everything works fine.<br /><br /><br />_js_ wrote:<br /><div class="quote">This way you wouldn't get the same result in ebx after the function call, because eax is put at the same point in the stack as ebx. Alter esp as well if you want to use mov instead of push.</div><br /><br />yes, but I start with a push ebx, your example starts with a mov , ebx, which simply overwrites first stack value.<br /><br />push ebx<br />call function<br />mov ebx, <br />...<br /><br />function:<br />   push eax<br />   ...<br />   pop eax<br />   ret<br /><br />would work right?<br /><br />if pushing multiple values in a routine it gets a little more tricky<br /><br />push ebx<br />call function<br />mov ebx, <br />push eax<br />call function<br />mov ebx, <br />mov eax, <br />...<br />...<br /><br />but it's fully workable, or? I was more concerned wheter or not it was faster than doing a:<br /><br />push ebx<br />call function<br />pop ebx<br />push ebx<br />call function<br />...<br /><br />i'm sorry if I come off as a total dumbass, I installed hutch masm package last night and am trying to grasp the extended masm syntax as we speak, slowly, slowly my memory concerning assembly programming is surfacing, my brain is like a very slow tape backup.</div>
    <div class="meta">Posted on 2003-03-04 13:24:34 by BinarySoup</div>
   </div>
   <div class="post" id="post-85066">
    <div class="subject"><a href="#post-85066">code efficiency question</a></div>
    <div class="body">masm won't generate any code to save registers if you don't use the <strong>uses</strong> directive.<br /><br />If you've been altering ebx..etc without preserving them then consider yourself very lucky not to have run into problems with windows.<br /><br />There have been many post on this board requesting help in solving random crashes.  The solution to many of them turned out to be register preservation.<br /><br />If you post a function for people to use then I'm fairly certain everyone here will expect that function to preserve <strong>ebx...</strong>ect if it uses them.<br /><br />The code you've posted is worlable but why not create the space on the stack at the start of the routine.  Then you won't have to keep altering the index to get to the same variable.<br /><br />btw if you're going to access variables directly thru esp then you may as well turn off masm's automatic stack frame setup.<br /><strong><br />option PROLOGUE:NONE<br />option EPILOGUE:NONE<br /></strong><em><br />functions defined here will not have a stack frame<br />you're responsible for accessing function paramemters and <br />other local variables.</em><br /><strong><br />option PROLOGUE:PROLOGUEDEF<br />option EPILOGUE:EPILOGUEDEF<br /></strong></div>
    <div class="meta">Posted on 2003-03-04 16:44:07 by MArtial_Code</div>
   </div>
   <div class="post" id="post-85074">
    <div class="subject"><a href="#post-85074">code efficiency question</a></div>
    <div class="body"><div class="quote"><em>Originally posted by BinarySoup </em><br />ehh, am I missing something here? you're saying that what I put at the top of the stack before a call may not be on the top of the stack after a API call??</div><br />Yup :):<br /><br /><pre><code><br />foo proc param1&#58;dword<br />  add &#91;param1&#93;, 100<br />  mov eax, &#91;param1&#93;<br />ret<br />foo endp</code></pre><br />This is a useless example but it shows that you can change parameters inside a function. You can't be sure a windows API function won't do this so don't assume anything pushed on the stack as parameters to an API is preserved after the API call.<br /><br />Thomas</div>
    <div class="meta">Posted on 2003-03-04 17:06:36 by Thomas</div>
   </div>
   <div class="post" id="post-85080">
    <div class="subject"><a href="#post-85080">code efficiency question</a></div>
    <div class="body">Quick side note:  Why ebx, esi, edi?<br /><br />The answer is simple.  That is because Win32 APIs are built using MS C (not entirely, but most part of APIs), which has its own internal rule of register usage.  Remember int 21h?  Just think of APIs as C version of int 21h.  There are differences, but the analogy will help you catch up quickly regarding register usage.</div>
    <div class="meta">Posted on 2003-03-04 18:06:08 by Starless</div>
   </div>
   <div class="post" id="post-85105">
    <div class="subject"><a href="#post-85105">code efficiency question</a></div>
    <div class="body">you are great guys, like living encyclopedias of assembly, wish I'd found this place sooner.<br /><br />anyway, <br /><br />Tomas wrote:<br /><br /><div class="quote"> You can't be sure a windows API function won't do this so don't assume anything pushed on the stack as parameters to an API is preserved after the API call.</div> <br /><br />sure, I know the stack parameters for the actual API call is not preserved, INVOKE is unless i'm mistaken nothing but a macro that pushes the parameters onto the stack for you, the actual API function will then pop them. However, if you push something onto the stack before a API call (using invoke), the API function must return with the stack pointer set at the position it was pre-invoke, else all is crazy, right?<br /><br />push foo (is now on top of stack, )<br />invoke foofunction (pushes 3 dword parameters, foo is now at )<br />...<br /><br />foofunction (pops 3 dwords, foo is back at ) <br />ret <br />....<br />mov foo, <br /><br />you probably thought I was wondering about reusing API parameters from stack after a API call, that's not what I meant, it was simply if it was faster to do:<br /><br />push eax<br />invoke API_BLABLA (trashes eax)<br />mov eax, <br />... use eax for something<br />invoke API_BLABLA (trashes eax)<br />mov eax, <br />... use eax for something<br />invoke API_BLABLA (trashes eax)<br />...<br />pop eax<br /><br />than:<br /><br />push eax<br />invoke API_BLABLA (trashes eax)<br />pop eax<br />... use eax for something<br />push eax<br />invoke API_BLABLA (trashes eax)<br />pop eax<br />... use eax for something<br />push eax<br />invoke API_BLABLA (trashes eax)<br />...<br />pop eax<br /><br />basically, is it faster to do a mov reg,  than doing a pop reg + push reg.<br /><br /><br />also, while I have you supercoders attention, I just wrote a little test program with a linked list, and I wondered if something constitutes as possible bug.<br /><br />here goes, it's dirty I know, just trying to remember asm and understand windows api structure.<br /><br />this routine de allocates all items in list (struct command in MASM, I LOVE IT!).<br /><br />assume eax: ptr testdata<br />mov eax, list<br />.while true<br />  .break .if eax == NULL<br />  push eax<br />  invoke GlobalUnlock, .MemoryHandle<br />  mov eax, <br />  invoke GlobalFree, .MemoryBlock      ;Now block is free for use in win?<br />  pop eax<br />  mov eax, .Next ; But I use a value from the deallocated block here, is it<br />                                   ; dangerous? not very likely that another program<br />                                   ; can allocate this block and fill it during this short<br />                                   ; time right? or is it bad practice?<br /> .endw<br />  <br />thanks for all your help guys, you rock!! must be a pain with people like me asking tons about the basics...</div>
    <div class="meta">Posted on 2003-03-04 21:59:44 by BinarySoup</div>
   </div>
   <div class="post" id="post-85108">
    <div class="subject"><a href="#post-85108">code efficiency question</a></div>
    <div class="body"><div class="quote"><em>Originally posted by BinarySoup </em><br /><br />basically, is it faster to do a mov reg,  than doing a pop reg + push reg.<br /></div><br />True, at the cost of one byte.<br /><div class="quote"><br />assume eax: ptr testdata<br />mov eax, list<br />.while true<br />  .break .if eax == NULL<br />  push eax<br />  invoke GlobalUnlock, .MemoryHandle<br />  mov eax, <br />  invoke GlobalFree, .MemoryBlock      ;Now block is free for use in win?<br />  pop eax<br />  mov eax, .Next ; But I use a value from the deallocated block here, is it<br />                                   ; dangerous? not very likely that another program<br />                                   ; can allocate this block and fill it during this short<br />                                   ; time right? or is it bad practice?<br /> .endw<br /></div><br />Why would that be dangerous?  .MemoryBlock was freed, not eax.  You know it from a rudimentary linked list class (or, an article if you taught yourself).  But, if you also allocated the list element (not the list data you freed in your code), this code suffers memory leak.</div>
    <div class="meta">Posted on 2003-03-04 22:15:05 by Starless</div>
   </div>
   <div class="post" id="post-85113">
    <div class="subject"><a href="#post-85113">code efficiency question</a></div>
    <div class="body">Starless wrote:<br /><div class="quote">.MemoryBlock was freed, not eax</div><br /><br />yes I know that, what could be dangerous was if between the:<br /><br />invoke GlobalFree, .MemoryBlock <br /><br />and the:<br /><br />mov eax, .Next <br /><br />another program could possibly allocate the memory and corrupt it so that .Next which is a pointer to next element in list would now have been filled with something else, however, I find it unlikely that another program would actually be able to allocate the memory and fill it in this short time no matter how multitasking windows is.<br /><br />Starless wrote:<br /><div class="quote">But, if you also allocated the list element (not the list data you freed in your code), this code suffers memory leak.</div><br /><br />ehh, don't follow you here, each item in the list is an allocated block, the pointers to the next item are contained in that block, then of course there is a dword defined in the .data section that holds a pointer to the first item in the list.<br /><br />simple example:<br /><br />.data?<br />ItemList dd ?     ; pointer to first item in list, null if none.<br /><br />Item struct<br />  MemoryHandle dd ?  <br />  MemoryBlock dd ?<br />  NextItem dd ? ; next item in list, null if end<br />Item ends<br /><br />basic oneway linked list...<br /><br />allocation of a item would be something like:<br /><br />invoke GlobalAlloc, GMEM_MOVEABLE, SIZEOF Item<br />push eax<br />invoke GlobalLock, eax<br />assume eax : ptr Item<br />mov .MemoryBlock, eax<br />pop ecx<br />mov .MemoryHandle, ecx<br />mov .NextItem, null<br /><br />then we'd traverse the list until we find an item with NextItem = null and attach pointer to this Item.<br /><br />please don't tell me I screwed up basic stuff like this :(</div>
    <div class="meta">Posted on 2003-03-04 23:04:14 by BinarySoup</div>
   </div>
   <div class="post" id="post-85116">
    <div class="subject"><a href="#post-85116">code efficiency question</a></div>
    <div class="body">(Scratching on my head...)  Your code is quite different than what I would do.  You might have some specific needs which I fail to understand.<br /><br />So, here is what I would do (unless you consider yourself clueless, you can ignore the rest).<br /><br />1.  Search the forum about linked list.<br />There is a library posted by a member written for MASM.  Unless you are testing your skill, having a library as a reference is helpful.<br /><br />2.  Search the forum about HeapAlloc(), GlobalAlloc(), LocalAlloc() and VirtualAlloc().<br />Not long ago there was a long thread debating the differences between those memory management APIs.  OTOH, SDK document strongly discourages the use of LocalAlloc() and GlobalAlloc() unless required by some APIs (carried-over from Windows 3.1).  Esp., GMEM_MOVEABLE flag is marked as obsolete.<br /><br />3.  If I write a linked-list routine, I would do:<br /><pre><code><br />LISTSTRUCT STRUCT<br />next       dd ?<br />somedata  dd 10 dup&#40;?&#41;<br />LISTSTRUCT ENDS<br /><br />.data<br />list_head   dd  0<br /><br />; either from HeapCreate&#40;&#41;<br />; or from GetProcessHeap&#40;&#41;<br />hHeap       dd   ?<br /><br />.code<br />...<br />; new node which happens to be the head.<br />    invoke HeapAlloc,hHeap,0,sizeof LISTSTRUCT<br />    mov list_head,eax<br />    mov &#91;eax&#93;.next,0<br />; and data copy here<br /><br />...<br /><br />; new node<br />    invoke HeapAlloc,hHeap,0,sizeof LISTSTRUCT<br />    mov edx,list_head<br />@@&#58;<br />    mov ecx,&#91;edx&#93;.next<br />    test ecx,ecx<br />    jz @F<br />    mov edx,ecx<br />    jmp @B<br />@@&#58;<br />    mov &#91;edx&#93;.next,eax<br />    mov &#91;eax&#93;.next,0<br />; data copy here<br /><br />...<br /><br />; destruction<br />    push ebx<br />    mov eax,list_head<br />@@&#58;<br />    mov ebx,&#91;eax&#93;.next<br />    ; assuming a node does not<br />    ; have any other allocated mem.<br />    invoke HeapFree,hHeap,0,eax<br />    mov eax,ebx<br />    test eax,eax<br />    jnz @B<br />    pop ebx<br /></code></pre><br />Then, again, this kind of code was written to suit my need.  So this may not be what you want.</div>
    <div class="meta">Posted on 2003-03-05 00:01:18 by Starless</div>
   </div>
   <div class="post" id="post-85120">
    <div class="subject"><a href="#post-85120">code efficiency question</a></div>
    <div class="body">thanks for all the input!<br /><br />well, the linked list stuff I wrote was just for testing structs and some memory allocation de-allocation, it was the simplest possible.<br /><br />I haven't written anything &quot;serious&quot; as of yet, just trying to get back into x86 assembly, was about 5 years since I did anything in it, and then it was graphics/demo stuff in DOS pmode using VBE, a couple of cpu emulators etc, so the biggest hurdle will most likely be adjusting to the windows API.  <br /><br />as for the different memory allocation schemes that is definately something I need to read up on, as I am totally lost there and memory allocation is a &quot;kinda important&quot; part of programming, thanks for the tip!<br /><br />I must say I really like the .IF .ELSE .BREAK etc constructs, takes away the need of all those pesky local labels, also the struct is great!<br /><br />well back to writing ugly pointless code and hopefully learn/remember something!<br /><br />this forum is GREAT!</div>
    <div class="meta">Posted on 2003-03-05 00:33:42 by BinarySoup</div>
   </div>
   <div class="post" id="post-85123">
    <div class="subject"><a href="#post-85123">code efficiency question</a></div>
    <div class="body"><div class="quote">you probably thought I was wondering about reusing API parameters from stack after a API call, that's not what I meant, it was simply if it was faster to do:</div><br />Yes you are right, I should have read your code better :rolleyes:. In that case you can just use mov eax,  instead of pop+push.<br /><br />Thomas</div>
    <div class="meta">Posted on 2003-03-05 01:35:41 by Thomas</div>
   </div>
   <div class="post" id="post-85129">
    <div class="subject"><a href="#post-85129">code efficiency question</a></div>
    <div class="body">Thomas that example is deceptive:<br /><br />foo proc param1:dword<br />  add , 100<br />  mov eax, <br />ret<br />foo endp<br /><br />There's really no confusion since it would make more sense if you renamed the parameter:<br />foo proc pParam1:dword<br />...<br />foo endp<br /><br />since to call that function you would write either<br />invoke foo, addr changethisvariable<br />or <br />invoke foo, thisvariablesvalue<br />which wouldn't change anything but the local parameter param1.<br /><br />Also the convention with register preservation is really very simple:<br />eax, ecx, edx are never guaranteed to be preserved accross function calls<br />esi, edi, ebx are<br />So really all you have to keep in mind is to preserve esi, edi, ebx in windows callback functions (EnumWindowsProc proc uses ebx, esi ...)<br />And it is stupid not to follow the same approach and preserve esi, edi, ebx in your own exported functions.<br /><br />Shouldn't it be a FAQ too?</div>
    <div class="meta">Posted on 2003-03-05 02:21:22 by grv575</div>
   </div>
  </div>
 </body>
</html>