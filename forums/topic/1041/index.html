<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Winsock reading too fast? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=1041" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=8">Networking</a> &raquo; <a href="../?id=1041">Winsock reading too fast?</a></p>
   <div class="post" id="post-6789">
    <div class="subject"><a href="#post-6789">Winsock reading too fast?</a></div>
    <div class="body">I'm having some trouble with InString, although it may be the globallock thing.<br /><br />Basically, I have winsock app acting as an IRC client and in the FD_READ message it calls WS_ReadData:<br /><br /><pre><code><br />; ============= Read Data from the socket ============= <br />WS_ReadData PROC<br />	invoke ioctlsocket, sock, FIONREAD, addr sizetoread		; Check the number of bytes available to read from the socket<br />	invoke GlobalAlloc, GHND, sizetoread    				; allocate memory enough for the data to read from the socket<br />	mov mHandle, eax<br />	invoke GlobalLock, eax<br />	mov recvAddr, eax<br />    invoke recv, sock, recvAddr, sizetoread, 0<br />	.if eax==SOCKET_ERROR<br />		invoke WSAGetLastError<br />		invoke wsprintfA, offset buff, offset txtError2, eax<br />		invoke MessageBox, NULL, addr buff, addr MsgBoxCaption, MB_OK<br />	.else<br />		invoke IRC_ProcessData<br />		;invoke MessageBox, NULL, addr txtError2, addr MsgBoxCaption, MB_OK<br />	.endif<br />	invoke GlobalUnlock, recvAddr<br />	invoke GlobalFree, mHandle	<br />	ret<br />WS_ReadData ENDP<br /></code></pre><br /><br />As you can see, this calles IRC_ProcessData, which is this:<br /><br /><pre><code><br />IRC_ProcessData PROC<br />	invoke SetDlgItemText, hwnd, IDC_EDIT, recvAddr<br />	;invoke MessageBox, NULL, recvAddr, addr MsgBoxCaption, MB_OK<br />	<br />	mov eax, 0<br />	invoke InString, 1, &#91;recvAddr&#93;, addr srchCmdPing				; Test for PING<br />	.if eax == 1													; If it IS a ping, it will be start at position 1, so safe to assume &#58;&#41;<br />		invoke lnstr, recvAddr									; Get the full length of the string from the IRC Server<br />		mov ebx, eax											; put the length of it into strlen<br />		sub ebx, 8												;<br />		invoke szMid, recvAddr, addr tmpBuff, 6, ebx<br /><br />		invoke wsprintfA, offset buff, offset sndCmdPong, addr tmpBuff<br />		;invoke MessageBox, NULL, addr buff, addr MsgBoxCaption, MB_OK<br /><br />		invoke lnstr, addr buff<br />		invoke send, sock, addr buff, eax, 0<br /><br />		; Now if the connection state is 1 &#40;still connecting&#41; it means this is the first Ping we've received so we need to send<br />		; the command to join the channel<br />		.if connectionState == 1<br />			invoke lnstr, addr sndCmdJoin<br />			invoke send, sock, addr sndCmdJoin, eax, 0<br />		.endif<br />		mov eax, 1<br />		ret<br />	.endif<br /><br />	invoke InString, 1, &#91;recvAddr&#93;, addr srchCmdJoin			; Test for a result of the Join command<br />	.if eax &gt; 0													; If it IS, the return value will be &gt; 0<br />		mov connectionState, 2									; As we've now got a reply from join, the connection state progresses<br />		invoke MessageBox, NULL, addr sndCmdJoin, addr MsgBoxCaption, MB_OK<br />		ret<br />	.endif<br /><br />	ret<br />IRC_ProcessData ENDP<br /></code></pre><br /><br />This comes up with an Application error indicating it referenced memory at 0xc0000000. <br /><br />But, when I add a messagebox somewhere in there it runs fine. I assume it's a problem with data being received too quickly, or it's just dodgy coding :) .<br /><br /><br />...akenny</div>
    <div class="meta">Posted on 2001-09-10 18:55:56 by akenny</div>
   </div>
   <div class="post" id="post-6841">
    <div class="subject"><a href="#post-6841">Winsock reading too fast?</a></div>
    <div class="body">IIRC, there was a bug in InString... Hutch solved the problem but I don't know if that was before or after MASM SP2... <br />The fixed version is <a target="_blank" href="http://www.hiroshimator.com/asmcommunity/messageboard/ShowMsg.asp?PDays=30&amp;ThreadID=2267&amp;ForumID=6">here</a>, although not fully tested.<br />Maybe that will fix your problem.<br /><br />Thomas</div>
    <div class="meta">Posted on 2001-09-11 01:36:23 by Thomas</div>
   </div>
   <div class="post" id="post-6848">
    <div class="subject"><a href="#post-6848">Winsock reading too fast?</a></div>
    <div class="body">That was exactly the problem! It has also helped clear a few other string searching peculiarities.<br /><br />Thanks for your help (again) Thomas :alright: <br /><br />...akenny</div>
    <div class="meta">Posted on 2001-09-11 04:57:31 by akenny</div>
   </div>
   <div class="post" id="post-6979">
    <div class="subject"><a href="#post-6979">Winsock reading too fast?</a></div>
    <div class="body">Can someone tell me what they think of this string search algo!  I posted it a while back.  How can I optimise this?<br /><br />Description: String search function for finding 'wrdf' in 'sentc', copying from 'sentc' + 'fromoffs' to 'copyto'. This function copies only 'copylen' amount of chars into 'copyto' or until it finds one of 5 chars from 'until' in 'sentc' whilst copying. It will then put a 0 byte at the end to terminate the string and the value of how many byte offsets from the beginning of 'sentc' it found the matching word is returned in eax.  Otherwise it will return -1.<br /><br />;==========<br /><br />substrext proc STDCALL wrdf:dword, sentc:dword, copyto:dword, until:dword, fromoffs:dword, copylen:dword<br />mov	ebx, sentc<br />cmp	wrdf, NULL<br />je	@@gofound<br />invoke	lstrlen, wrdf<br />mov	, eax<br />mov	esi, wrdf<br />mov	ebx, sentc<br />mov	cl, 		; wrdf[0] to cx<br />mov	edi, 0<br />mov	eax, 0<br />jmp	@@lop<br /><br />@@gofound:<br />mov	, 0<br />mov	, ebx<br />jmp	@@foundmatch<br /><br />@@lop:<br />mov	dl, 		; sentc to dx<br />cmp	cl, dl		; compare wrdf[0] to sentc<br />je 	@@found<br />inc 	ebx<br />inc	eax<br />cmp	dl, 0		; if at end of string<br />je	@@done2<br />jmp	@@lop<br /><br />@@found:<br />mov	, ebx<br />mov	, eax<br />mov	eax, <br />inc 	ebx<br />inc	esi<br /><br />@@lop2:<br />mov	cl, byte ptr <br />mov	dl, byte ptr <br />cmp	cl, 0<br />je	@@foundmatch<br />cmp	cl, dl<br />jne	@@nomatch<br />inc	ebx<br />inc	esi<br />jmp	@@lop2<br /><br />@@nomatch:<br />mov	esi, wrdf<br />mov	ebx, <br />mov	eax, <br />inc	ebx<br />inc	eax<br />mov	edi, 0<br />mov	cl, 		; move wrdf[0] back into cx<br />jmp	@@lop<br /><br />@@foundmatch:<br />mov	ebx, <br />mov	esi, 0<br />mov	edi, <br />mov	ecx, <br />mov	edx, <br />cmp	ecx, 0<br />je	@@done<br />cmp	edx, 0<br />je	@@done<br /><br />@@copychars:<br />inc 	esi<br />cmp	esi, ecx<br />je	@@appo<br />dec	esi<br />mov	al, byte ptr 	; sentc to ax<br /><br />@@compare:<br />push 	ebx<br />mov	ebx, until<br />cmp	al, byte ptr <br />je	@@appo2<br />cmp	al, byte ptr <br />je	@@appo2<br />cmp	al, byte ptr <br />je	@@appo2<br />cmp	al, byte ptr <br />je	@@appo2<br />cmp	al, byte ptr <br />je	@@appo2<br /><br />@@cont:<br />mov	ebx, edx<br />mov	, al		; copy from sentc[?] to copyto[?]<br />cmp	al, 0<br />je	@@done<br /><br />pop	ebx<br />inc	edi<br />inc	esi<br />jmp	@@copychars<br /><br />@@appo:<br />pop	ebx<br />mov	al, 0<br />dec	esi<br />mov	, al<br />jmp	@@done<br /><br />@@appo2:<br />pop	ebx<br />mov	ebx, edx<br />mov	al, 0<br />mov	, al<br /><br />@@done:<br />pop	ebx<br />mov	eax, <br />ret<br /><br />@@done2:<br />mov	eax, -1<br />ret<br /><br />substrext endp</div>
    <div class="meta">Posted on 2001-09-12 19:50:50 by nin</div>
   </div>
  </div>
 </body>
</html>