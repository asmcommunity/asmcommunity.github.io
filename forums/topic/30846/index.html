<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>ML64 ommitting ret instruction - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30846" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=116">Windows</a> &raquo; <a href="../?id=30846">ML64 ommitting ret instruction</a></p>
   <div class="post" id="post-215723">
    <div class="subject"><a href="#post-215723">ML64 ommitting ret instruction</a></div>
    <div class="body">Hey all, was doing some asm inside a C++ project. Setup: VS2010, custom build for .asm file using ml64.<br /><br />ml64 args:<br />ml64 -c -Zi &quot;-Fl$(IntDir)%(FileName).lst&quot; &quot;-Fo$(IntDir)%(FileName).obj&quot; &quot;%(FullPath)&quot;<br /><br />The function where I&#039;m having an issue is a member function, operator*. ml64 doesn&#039;t emit the ret instruction at the end of the code, so it screws up everything ofc.<br /><br />Here&#039;s the entire asm file:<br /><br /><pre><code><br />.code<br /><br /><br /><br /><br />; const UBigInt&amp; UBigInt::operator+(UBigInt const &amp;) const<br /><br />;??GUBigInt@@QEBAAEBV0@AEBV0@@Z PROC thisptr:DQ, bigint:DQ<br /><br />;mov rax, rcx<br /><br />;??GUBigInt@@QEBAAEBV0@AEBV0@@Z ENDP<br /><br /><br /><br /><br />; const UBigInt&amp; UBigInt::operator-(UBigInt const &amp;) const<br /><br />;??HUBigInt@@QEBAAEBV0@AEBV0@@Z PROC thisptr:DQ, bigint:DQ<br /><br />;mov rax, rcx<br /><br />;??HUBigInt@@QEBAAEBV0@AEBV0@@Z ENDP<br /><br /><br /><br /><br />; const UBigInt UBigInt::operator*(const UBigInt&amp; a_int) const<br /><br />??DUBigInt@@QEBA?BV0@AEBV0@@Z PROC FRAME thisptr:PTR QWORD, bigint:PTR QWORD<br /><br />??0UBigInt@@QEAA@AEBV?$vector@_JV?$allocator@_J@std@@@std@@@Z PROTO<br />UBigInt_UBigInt EQU ??0UBigInt@@QEAA@AEBV?$vector@_JV?$allocator@_J@std@@@std@@@Z<br /><br />??0?$vector@_JV?$allocator@_J@std@@@std@@QEAA@_K@Z PROTO<br />??A?$vector@_JV?$allocator@_J@std@@@std@@QEAAAEA_J_K@Z PROTO<br />?size@?$vector@_JV?$allocator@_J@std@@@std@@QEBA_KXZ PROTO<br />?push_back@?$vector@_JV?$allocator@_J@std@@@std@@QEAAX$$QEA_J@Z PROTO<br />??1?$vector@_JV?$allocator@_J@std@@@std@@QEAA@XZ PROTO<br /><br />vector_vector EQU ??0?$vector@_JV?$allocator@_J@std@@@std@@QEAA@_K@Z<br />vector_index EQU ??A?$vector@_JV?$allocator@_J@std@@@std@@QEAAAEA_J_K@Z<br />vector_size EQU ?size@?$vector@_JV?$allocator@_J@std@@@std@@QEBA_KXZ<br />vector_push_back EQU ?push_back@?$vector@_JV?$allocator@_J@std@@@std@@QEAAX$$QEA_J@Z<br />vector_decvector EQU ??1?$vector@_JV?$allocator@_J@std@@@std@@QEAA@XZ<br /><br />; stack layout<br />;<br />;	0xA8	--------------------- &lt; end of 32 bytes shadow space<br />;			rbx<br />;	0xA0	---------------------<br />;			rdi<br />;	0x98	---------------------<br />;			rsi<br />;	0x90	---------------------<br />;			r12<br />;	0x88	--------------------- &lt; start of 32 bytes shadow space<br />;			return address<br />;	0x80	---------------------<br />;			rbp, automatically pushed with autogenerated code<br />;	0x78	--------------------- &lt; old rsp<br />;			r13<br />;	0x70	---------------------<br />;			r14<br />;	0x68	---------------------<br />;			r15<br />;	0x60	---------------------<br />;			rcx<br />;	0x58	---------------------<br />;			r8<br />;	0x50	---------------------<br />;			rdx<br />;	0x48	--------------------- <br />;			vector for outputted UBigInt<br />;<br />;			40 bytes<br />;	0x20	--------------------- <br />;			32 bytes shadow space for called functions<br />;	0x00	--------------------- &lt; rsp<br /><br />mov			qword ptr , rbx<br />.pushreg rbx<br />mov			qword ptr , rdi<br />.pushreg rdi<br />mov			qword ptr , rsi<br />.pushreg rsi<br />mov			qword ptr ,&nbsp; r12<br />.pushreg r12<br />sub			rsp, 78h<br />mov			qword ptr , r13<br />.pushreg r13<br />mov			qword ptr , r14<br />.pushreg r14<br />mov			qword ptr , r15<br />.pushreg r15<br /><br />.endprolog<br /><br />mov			qword ptr , rcx<br />mov			qword ptr , r8<br />mov			qword ptr , rdx<br /><br />mov r14, r8<br /><br />; this ptr already in rcx<br />call vector_size<br />mov esi, eax<br /><br />mov rcx, r14<br />call vector_size<br />mov edi, eax<br /><br />; construct vector for outputted UBigInt<br />; with size: b.size() + a.size() - 1<br />; also fill vector with all 0s<br /><br />mov edx, edi<br />add edx, esi<br />sub edx, 1<br /><br />lea rcx, <br />call vector_vector<br /><br />;<br />; rbx: last overflow<br />; r14: a, a*b<br />; r15: overflow<br />; edi: b.size()<br />; esi: a.size()<br />; r12d: x<br />; r13d: y<br />;<br />; for (int x = 0; x &lt; b.size (); ++x)<br />; {<br />;	for (int y = 0; y &lt; a.size (); ++y)<br />;	{<br />;		c += a*b + overflow; <br />;&nbsp;  }<br />; }<br /><br />mov rbx, 0<br />mov r12d, 0<br /><br />XLoopStart:<br />	cmp r12d, edi<br />	jge XLoopEnd<br /><br />	mov r13d, 0<br /><br />	YLoopStart:<br />		cmp r13d, esi<br />		jge YLoopEnd<br /><br />		mov edx, r13d<br />		mov rcx, qword ptr <br />		call vector_index<br />		mov r14, qword ptr <br /><br />		mov edx, r12d<br />		mov rcx, qword ptr <br />		call vector_index<br />		mov rax, qword ptr <br /><br />		mul r14<br />		mov r14, rax<br />		mov r15, rdx<br /><br />		mov edx, r12d<br />		add edx, r13d<br />		lea rcx, <br />		call vector_index<br /><br />		add qword ptr , r14<br />		add qword ptr , rbx<br /><br />		adc r15, 0<br />		mov rbx, r15<br /><br />		inc r13d<br />		jmp YLoopStart<br />	YLoopEnd:<br /><br />	inc r12d<br />	jmp XLoopStart<br />XLoopEnd:<br /><br />jnc NoOverflow<br /><br />mov edx, r12d<br />add edx, r13d<br />lea rcx, <br />call vector_push_back<br /><br />NoOverflow:<br /><br />; construct returned UBigInt<br /><br />lea rdx, <br />mov rcx, qword ptr <br />call UBigInt_UBigInt<br /><br /><br />; deconstruct vector for returned UBigInt<br /><br />lea rcx, <br />call vector_decvector<br /><br />mov rax, qword ptr <br /><br />mov			rbx, qword ptr <br />mov			rdi, qword ptr <br />mov			rsi, qword ptr <br />mov			r12, qword ptr <br />mov			r13, qword ptr <br />mov			r14, qword ptr <br />mov			r15, qword ptr <br /><br />add			rsp, 78h<br /><br />ret<br /><br />??DUBigInt@@QEBA?BV0@AEBV0@@Z ENDP<br /><br /><br /><br /><br />; const UBigInt&amp; UBigInt::operator/(UBigInt const &amp;) const<br /><br />;??KUBigInt@@QEBAAEBV0@AEBV0@@Z PROC thisptr:DQ, bigint:DQ<br /><br />;mov rax, rcx<br /><br />;??KUBigInt@@QEBAAEBV0@AEBV0@@Z ENDP<br /><br />end<br /></code></pre><br /><br />Here&#039;s what the assembler&#039;s listing shows:<br /><br /><pre><code><br />Microsoft (R) Macro Assembler (x64) Version 10.00.30319.01&nbsp; 01/31/12 01:21:13<br />C:\Users\mikfig\documents\visual studio 2010\Projects\projectEuler\problem 20\biguint_mul.asm&nbsp; Page 1 - 1<br /><br /><br /> 00000000			.code<br /><br /><br /><br /><br />				; const UBigInt&amp; UBigInt::operator+(UBigInt const &amp;) const<br /><br />				;??GUBigInt@@QEBAAEBV0@AEBV0@@Z PROC thisptr:DQ, bigint:DQ<br /><br />				;mov rax, rcx<br /><br />				;??GUBigInt@@QEBAAEBV0@AEBV0@@Z ENDP<br /><br /><br /><br /><br />				; const UBigInt&amp; UBigInt::operator-(UBigInt const &amp;) const<br /><br />				;??HUBigInt@@QEBAAEBV0@AEBV0@@Z PROC thisptr:DQ, bigint:DQ<br /><br />				;mov rax, rcx<br /><br />				;??HUBigInt@@QEBAAEBV0@AEBV0@@Z ENDP<br /><br /><br /><br /><br />				; const UBigInt UBigInt::operator*(const UBigInt&amp; a_int) const<br /><br /> 00000000			??DUBigInt@@QEBA?BV0@AEBV0@@Z PROC FRAME thisptr:PTR QWORD, bigint:PTR QWORD<br /><br />				??0UBigInt@@QEAA@AEBV?$vector@_JV?$allocator@_J@std@@@std@@@Z PROTO<br /> = ??0UBigInt@@QEAA@AEBV?$v	UBigInt_UBigInt EQU ??0UBigInt@@QEAA@AEBV?$vector@_JV?$allocator@_J@std@@@std@@@Z<br />&nbsp;  ector@_JV?$allocator@_J@<br />&nbsp;  std@@@std@@@Z<br /><br />				??0?$vector@_JV?$allocator@_J@std@@@std@@QEAA@_K@Z PROTO<br />				??A?$vector@_JV?$allocator@_J@std@@@std@@QEAAAEA_J_K@Z PROTO<br />				?size@?$vector@_JV?$allocator@_J@std@@@std@@QEBA_KXZ PROTO<br />				?push_back@?$vector@_JV?$allocator@_J@std@@@std@@QEAAX$$QEA_J@Z PROTO<br />				??1?$vector@_JV?$allocator@_J@std@@@std@@QEAA@XZ PROTO<br /><br /> = ??0?$vector@_JV?$allocat	vector_vector EQU ??0?$vector@_JV?$allocator@_J@std@@@std@@QEAA@_K@Z<br />&nbsp;  or@_J@std@@@std@@QEAA@_K<br />&nbsp;  @Z<br /> = ??A?$vector@_JV?$allocat	vector_index EQU ??A?$vector@_JV?$allocator@_J@std@@@std@@QEAAAEA_J_K@Z<br />&nbsp;  or@_J@std@@@std@@QEAAAEA<br />&nbsp;  _J_K@Z<br /> = ?size@?$vector@_JV?$allo	vector_size EQU ?size@?$vector@_JV?$allocator@_J@std@@@std@@QEBA_KXZ<br />&nbsp;  cator@_J@std@@@std@@QEBA<br />&nbsp;  _KXZ<br /> = ?push_back@?$vector@_JV?	vector_push_back EQU ?push_back@?$vector@_JV?$allocator@_J@std@@@std@@QEAAX$$QEA_J@Z<br />&nbsp;  $allocator@_J@std@@@std@<br />&nbsp;  @QEAAX$$QEA_J@Z<br /> = ??1?$vector@_JV?$allocat	vector_decvector EQU ??1?$vector@_JV?$allocator@_J@std@@@std@@QEAA@XZ<br />&nbsp;  or@_J@std@@@std@@QEAA@XZ<br /><br />				; stack layout<br />				;<br />				;	0xA8	--------------------- &lt; end of 32 bytes shadow space<br />				;			rbx<br />				;	0xA0	---------------------<br />				;			rdi<br />				;	0x98	---------------------<br />				;			rsi<br />				;	0x90	---------------------<br />				;			r12<br />				;	0x88	--------------------- &lt; start of 32 bytes shadow space<br />				;			return address<br />				;	0x80	---------------------<br />				;			rbp, automatically pushed with autogenerated code<br />				;	0x78	--------------------- &lt; old rsp<br />				;			r13<br />				;	0x70	---------------------<br />				;			r14<br />				;	0x68	---------------------<br />				;			r15<br />				;	0x60	---------------------<br />				;			rcx<br />				;	0x58	---------------------<br />				;			r8<br />				;	0x50	---------------------<br />				;			rdx<br />				;	0x48	--------------------- <br />				;			vector for outputted UBigInt<br />				;<br />				;			40 bytes<br />				;	0x20	--------------------- <br />				;			32 bytes shadow space for called functions<br />				;	0x00	--------------------- &lt; rsp<br /><br /> 00000000&nbsp; 48/ 89 5C 24		mov			qword ptr , rbx<br />	&nbsp;  20<br />				.pushreg rbx<br /> 00000005&nbsp; 48/ 89 7C 24		mov			qword ptr , rdi<br />	&nbsp;  18<br />				.pushreg rdi<br /> 0000000A&nbsp; 48/ 89 74 24		mov			qword ptr , rsi<br />	&nbsp;  10<br />				.pushreg rsi<br /> 0000000F&nbsp; 4C/ 89 64 24		mov			qword ptr ,&nbsp; r12<br />	&nbsp;  08<br />				.pushreg r12<br /> 00000014&nbsp; 48/ 83 EC 78		sub			rsp, 78h<br /> 00000018&nbsp; 4C/ 89 6C 24		mov			qword ptr , r13<br />	&nbsp;  70<br />				.pushreg r13<br /> 0000001D&nbsp; 4C/ 89 74 24		mov			qword ptr , r14<br />	&nbsp;  68<br />				.pushreg r14<br /> 00000022&nbsp; 4C/ 89 7C 24		mov			qword ptr , r15<br />	&nbsp;  60<br />				.pushreg r15<br /><br />				.endprolog<br /><br /> 00000027&nbsp; 48/ 89 4C 24		mov			qword ptr , rcx<br />	&nbsp;  58<br /> 0000002C&nbsp; 4C/ 89 44 24		mov			qword ptr , r8<br />	&nbsp;  50<br /> 00000031&nbsp; 48/ 89 54 24		mov			qword ptr , rdx<br />	&nbsp;  48<br /><br /> 00000036&nbsp; 4D/ 8B F0		mov r14, r8<br /><br />				; this ptr already in rcx<br /> 00000039&nbsp; E8 00000000 E	call vector_size<br /> 0000003E&nbsp; 8B F0		mov esi, eax<br /><br /> 00000040&nbsp; 49/ 8B CE		mov rcx, r14<br /> 00000043&nbsp; E8 00000000 E	call vector_size<br /> 00000048&nbsp; 8B F8		mov edi, eax<br /><br />				; construct vector for outputted UBigInt<br />				; with size: b.size() + a.size() - 1<br />				; also fill vector with all 0s<br /><br /> 0000004A&nbsp; 8B D7		mov edx, edi<br /> 0000004C&nbsp; 03 D6		add edx, esi<br /> 0000004E&nbsp; 83 EA 01		sub edx, 1<br /><br /> 00000051&nbsp; 48/ 8D 4C 24		lea rcx, <br />	&nbsp;  20<br /> 00000056&nbsp; E8 00000000 E	call vector_vector<br /><br />				;<br />				; rbx: last overflow<br />				; r14: a, a*b<br />				; r15: overflow<br />				; edi: b.size()<br />				; esi: a.size()<br />				; r12d: x<br />				; r13d: y<br />				;<br />				; for (int x = 0; x &lt; b.size (); ++x)<br />				; {<br />				;	for (int y = 0; y &lt; a.size (); ++y)<br />				;	{<br />				;		c += a*b + overflow; <br />				;&nbsp;  }<br />				; }<br /><br /> 0000005B&nbsp; 48/ C7 C3		mov rbx, 0<br />	&nbsp;  00000000<br /> 00000062&nbsp; 41/ BC		mov r12d, 0<br />	&nbsp;  00000000<br /><br /> 00000068			XLoopStart:<br /> 00000068&nbsp; 44/ 3B E7			cmp r12d, edi<br /> 0000006B&nbsp; 7D 5B			jge XLoopEnd<br /><br /> 0000006D&nbsp; 41/ BD			mov r13d, 0<br />	&nbsp;  00000000<br /><br /> 00000073				YLoopStart:<br /> 00000073&nbsp; 44/ 3B EE				cmp r13d, esi<br /> 00000076&nbsp; 7D 4B				jge YLoopEnd<br /><br /> 00000078&nbsp; 41/ 8B D5				mov edx, r13d<br /> 0000007B&nbsp; 48/ 8B 4C 24				mov rcx, qword ptr <br />	&nbsp;  58<br /> 00000080&nbsp; E8 00000000 E			call vector_index<br /> 00000085&nbsp; 4C/ 8B 30				mov r14, qword ptr <br /><br /> 00000088&nbsp; 41/ 8B D4				mov edx, r12d<br /> 0000008B&nbsp; 48/ 8B 4C 24				mov rcx, qword ptr <br />	&nbsp;  50<br /> 00000090&nbsp; E8 00000000 E			call vector_index<br /> 00000095&nbsp; 48/ 8B 00				mov rax, qword ptr <br /><br /> 00000098&nbsp; 49/ F7 E6				mul r14<br /> 0000009B&nbsp; 4C/ 8B F0				mov r14, rax<br /> 0000009E&nbsp; 4C/ 8B FA				mov r15, rdx<br /><br /> 000000A1&nbsp; 41/ 8B D4				mov edx, r12d<br /> 000000A4&nbsp; 41/ 03 D5				add edx, r13d<br /> 000000A7&nbsp; 48/ 8D 4C 24				lea rcx, <br />	&nbsp;  20<br /> 000000AC&nbsp; E8 00000000 E			call vector_index<br /><br /> 000000B1&nbsp; 4C/ 01 30				add qword ptr , r14<br /> 000000B4&nbsp; 48/ 01 18				add qword ptr , rbx<br /><br /> 000000B7&nbsp; 49/ 83 D7 00				adc r15, 0<br /> 000000BB&nbsp; 49/ 8B DF				mov rbx, r15<br /><br /> 000000BE&nbsp; 41/ FF C5				inc r13d<br /> 000000C1&nbsp; EB B0				jmp YLoopStart<br /> 000000C3				YLoopEnd:<br /><br /> 000000C3&nbsp; 41/ FF C4			inc r12d<br /> 000000C6&nbsp; EB A0			jmp XLoopStart<br /> 000000C8			XLoopEnd:<br /><br /> 000000C8&nbsp; 73 10		jnc NoOverflow<br /><br /> 000000CA&nbsp; 41/ 8B D4		mov edx, r12d<br /> 000000CD&nbsp; 41/ 03 D5		add edx, r13d<br /> 000000D0&nbsp; 48/ 8D 4C 24		lea rcx, <br />	&nbsp;  20<br /> 000000D5&nbsp; E8 00000000 E	call vector_push_back<br /><br /> 000000DA			NoOverflow:<br /><br />				; construct returned UBigInt<br /><br /> 000000DA&nbsp; 48/ 8D 54 24		lea rdx, <br />	&nbsp;  20<br /> 000000DF&nbsp; 48/ 8B 4C 24		mov rcx, qword ptr <br />	&nbsp;  48<br /> 000000E4&nbsp; E8 00000000 E	call UBigInt_UBigInt<br /><br /><br />				; deconstruct vector for returned UBigInt<br /><br /> 000000E9&nbsp; 48/ 8D 4C 24		lea rcx, <br />	&nbsp;  20<br /> 000000EE&nbsp; E8 00000000 E	call vector_decvector<br /><br /> 000000F3&nbsp; 48/ 8B 44 24		mov rax, qword ptr <br />	&nbsp;  48<br /><br /> 000000F8&nbsp; 48/ 8B 9C 24		mov			rbx, qword ptr <br />	&nbsp;  00000098<br /> 00000100&nbsp; 48/ 8B BC 24		mov			rdi, qword ptr <br />	&nbsp;  00000090<br /> 00000108&nbsp; 48/ 8B B4 24		mov			rsi, qword ptr <br />	&nbsp;  00000088<br /> 00000110&nbsp; 4C/ 8B A4 24		mov			r12, qword ptr <br />	&nbsp;  00000080<br /> 00000118&nbsp; 4C/ 8B 6C 24		mov			r13, qword ptr <br />	&nbsp;  70<br /> 0000011D&nbsp; 4C/ 8B 74 24		mov			r14, qword ptr <br />	&nbsp;  68<br /> 00000122&nbsp; 4C/ 8B 7C 24		mov			r15, qword ptr <br />	&nbsp;  60<br /><br /> 00000127&nbsp; 48/ 83 C4 78		add			rsp, 78h<br /><br />				ret<br /><br /> 0000012B			??DUBigInt@@QEBA?BV0@AEBV0@@Z ENDP<br /><br /><br /><br /><br />				; const UBigInt&amp; UBigInt::operator/(UBigInt const &amp;) const<br /><br />				;??KUBigInt@@QEBAAEBV0@AEBV0@@Z PROC thisptr:DQ, bigint:DQ<br /><br />				;mov rax, rcx<br /><br />				;??KUBigInt@@QEBAAEBV0@AEBV0@@Z ENDP<br /><br />				end<br />Microsoft (R) Macro Assembler (x64) Version 10.00.30319.01&nbsp; 01/31/12 01:21:13<br />C:\Users\mikfig\documents\visual studio 2010\Projects\projectEuler\problem 20\biguint_mul.asm&nbsp; Symbols 2 - 1<br /><br /><br /><br /><br />Procedures, parameters, and locals:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N a m e&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Type&nbsp; &nbsp;  Value&nbsp; &nbsp; Attr<br /><br />??0?$vector@_JV?$allocator@_J@std@@@std@@QEAA@_K@Z . P 	&nbsp; &nbsp; &nbsp; 00000000 Length= 00000000 External<br />??0UBigInt@@QEAA@AEBV?$vector@_JV?$allocator@_J@std@@@std@@@Z&nbsp; P&nbsp; &nbsp; &nbsp; &nbsp; 00000000 Length= 00000000 External<br />??1?$vector@_JV?$allocator@_J@std@@@std@@QEAA@XZ . P 	&nbsp; &nbsp; 00000000 Length= 00000000 External<br />??A?$vector@_JV?$allocator@_J@std@@@std@@QEAAAEA_J_K@Z . P 	&nbsp; 00000000 Length= 00000000 External<br />??DUBigInt@@QEBA?BV0@AEBV0@@Z&nbsp; .	P 	 00000000 _TEXT	Length= 0000012B Public<br />&nbsp; thisptr&nbsp; . . . . . . . . . . .	QWord	 rbp + 00000010<br />&nbsp; bigint . . . . . . . . . . . .	QWord	 rbp + 00000018<br />&nbsp; XLoopStart . . . . . . . . . .	L 	 00000068 _TEXT	<br />&nbsp; YLoopStart . . . . . . . . . .	L 	 00000073 _TEXT	<br />&nbsp; YLoopEnd . . . . . . . . . . .	L 	 000000C3 _TEXT	<br />&nbsp; XLoopEnd . . . . . . . . . . .	L 	 000000C8 _TEXT	<br />&nbsp; NoOverflow . . . . . . . . . .	L 	 000000DA _TEXT	<br />?push_back@?$vector@_JV?$allocator@_J@std@@@std@@QEAAX$$QEA_J@Z&nbsp; P 	&nbsp; 00000000 Length= 00000000 External<br />?size@?$vector@_JV?$allocator@_J@std@@@std@@QEBA_KXZ . P&nbsp; &nbsp; &nbsp; &nbsp; 00000000 Length= 00000000 External<br /><br /><br />Symbols:<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; N a m e&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Type&nbsp; &nbsp;  Value&nbsp; &nbsp; Attr<br /><br />$xdatasym&nbsp; . . . . . . . . . . .	Byte	 00000000 _XDATA	<br />UBigInt_UBigInt&nbsp; . . . . . . . .	Text&nbsp;  	 ??0UBigInt@@QEAA@AEBV?$vector@_JV?$allocator@_J@std@@@std@@@Z<br />vector_decvector . . . . . . . .	Text&nbsp;  	 ??1?$vector@_JV?$allocator@_J@std@@@std@@QEAA@XZ<br />vector_index . . . . . . . . . .	Text&nbsp;  	 ??A?$vector@_JV?$allocator@_J@std@@@std@@QEAAAEA_J_K@Z<br />vector_push_back . . . . . . . .	Text&nbsp;  	 ?push_back@?$vector@_JV?$allocator@_J@std@@@std@@QEAAX$$QEA_J@Z<br />vector_size&nbsp; . . . . . . . . . .	Text&nbsp;  	 ?size@?$vector@_JV?$allocator@_J@std@@@std@@QEBA_KXZ<br />vector_vector&nbsp; . . . . . . . . .	Text&nbsp;  	 ??0?$vector@_JV?$allocator@_J@std@@@std@@QEAA@_K@Z<br /><br />	&nbsp;  0 Warnings<br />	&nbsp;  0 Errors<br /></code></pre><br /><br />Oh and the function I&#039;m referring to is the only real function here: ??DUBigInt@@QEBA?BV0@AEBV0@@Z<br />Heh, and don&#039;t ask why im doing C++ stuff in asm.<br /><br />Anybody got any ideas as to why the assembler doesn&#039;t emit &#039;ret&#039;?<br /><br />Thanks :),<br />mikfig</div>
    <div class="meta">Posted on 2012-01-31 04:12:50 by mikfig</div>
   </div>
   <div class="post" id="post-215724">
    <div class="subject"><a href="#post-215724">Re: ML64 ommitting ret instruction</a></div>
    <div class="body">I don&#039;t see a ret in the source, so why would ML64 emit an instruction that isn&#039;t there?</div>
    <div class="meta">Posted on 2012-01-31 07:37:16 by Scali</div>
   </div>
   <div class="post" id="post-215725">
    <div class="subject"><a href="#post-215725">Re: ML64 ommitting ret instruction</a></div>
    <div class="body">It&#039;s at the very bottom:<br /><br /><pre><code><br />.code<br />...<br />??DUBigInt@@QEBA?BV0@AEBV0@@Z PROC FRAME thisptr:PTR QWORD, bigint:PTR QWORD<br />...<br />mov			rbx, qword ptr <br />mov			rdi, qword ptr <br />mov			rsi, qword ptr <br />mov			r12, qword ptr <br />mov			r13, qword ptr <br />mov			r14, qword ptr <br />mov			r15, qword ptr <br /><br />add			rsp, 78h<br /><br />ret<br /><br />??DUBigInt@@QEBA?BV0@AEBV0@@Z ENDP<br /><br /><br /><br /><br />; const UBigInt&amp; UBigInt::operator/(UBigInt const &amp;) const<br /><br />;??KUBigInt@@QEBAAEBV0@AEBV0@@Z PROC thisptr:DQ, bigint:DQ<br /><br />;mov rax, rcx<br /><br />;??KUBigInt@@QEBAAEBV0@AEBV0@@Z ENDP<br /><br />end<br /></code></pre></div>
    <div class="meta">Posted on 2012-01-31 13:39:14 by mikfig</div>
   </div>
  </div>
 </body>
</html>