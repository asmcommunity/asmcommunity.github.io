<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>StrTok function v0.1 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=16923" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=16923">StrTok function v0.1</a></p>
   <div class="post" id="post-131295">
    <div class="subject"><a href="#post-131295">StrTok function v0.1</a></div>
    <div class="body">Here is a function I have been working on, almost proud of, and it hopefully mimics the CRTDLL function, let me know what you think, crits, or alterations.. it takes care of any extra tokens within the string as well.  It manipulates 5 registers.<br /><br /><br /><br /><pre><code><br />StrTok PROC bStr&#58;DWORD, pStr&#58;DWORD<br />;uses the four 32-bit registers eax,ebx,ecx,edx  - and as an added bonus, edi!!!<br />;bStr = input string -null terminated and/or CRLF terminated<br />;pStr = tokens - null terminated - including CRLF should token that out too<br />;   bRet is a static buffer to contain the returned text<br />;   see second section of code posted for variables and types<br />;   use EDX register to continue stripping the string, see sample code below<br /><br />	mov edx, bStr<br />	mov edi, OFFSET bRet<br />	xor eax,eax<br />	xor ecx,ecx<br />	<br />sloop1&#58;<br />	mov al, &#91;edx&#93;<br />	cmp al,0<br />	je sloop1e    ;jump if end of input string<br />	cmp al,13<br />	je sloop1n	  ;jump if end of line<br />	cmp al,10<br />	je sloop1n	  ;jump just to be safe if only 0A is present so first set ret value to 0<br />	jmp sloop1a<br />	<br />sloop1n&#58;<br />	xor eax,eax               ;now is tested, so to put StrTok&#40;&#41; into a loop<br />	jmp exitloop	  ;return with eax==0 when end of the line &lt;&lt;&lt;&lt; TESTED, works<br /><br />sloop1a&#58;<br />	;xor ecx,ecx		;to strip everything out except the strings, makes one long concatenation<br />	mov ebx, pStr		;move token to ebx<br /><br />sloop1b&#58;                        ;the token loop  =&#41;<br />	mov cl,&#91;ebx&#93;   <br />	cmp al,cl<br />	je sloop1c   ;found a matching token, so we need to keep moving in our string<br />	cmp cl,0<br />	je sloop1d   ;you have reached the end of the token string and found no match, add to bRet&#91;&#93;<br />	inc ebx<br />	jmp sloop1b  ;found no match or end, keep looking for a match until found or end<br /><br />sloop1c&#58;<br />;heh here is where we find the first+other non-token strings<br />;now set a 'flag' to indicate we found the starting position so we can get an ending position<br />;to return the field found<br />	cmp ch,1<br />	je sloop1e<br />	inc edx<br />	jmp sloop1<br /><br />sloop1d&#58;            ;only call this if no matches above<br />	mov ch,1		;simple flag for checking if found the first token<br />	inc edx			;added just now<br />	mov BYTE PTR &#91;edi&#93;, al<br />	inc edi<br />	jmp sloop1<br /><br />sloop1e&#58;<br />	mov BYTE PTR &#91;edi&#93;, 0<br />	mov eax,edi   ;move count to eax return value<br />exitloop&#58;<br />	ret<br />	<br />StrTok endp<br /></code></pre><br /><br />Using intialization:<br /><br /><pre><code><br />.data<br /> fmtTxt db 40 DUP&#40;?&#41;<br /> alf2 db &quot;%s&quot;,0<br /> bRet db 80 DUP&#40;0&#41;<br /> fspc db 'f /',0    ;The tokens to separate the text out with<br /> FOO db 'f 256//16 15//231 34//151',13,10,0<br /></code></pre><br /><br />To test:<br /><br /><pre><code><br />	mov edx, OFFSET FOO  ;notice that to continue parsing the string, need to preserve edx pointer<br /><br />	invoke StrTok, edx, ADDR fspc<br /><br />	pushad<br />                invoke wsprintf, ADDR fmtTxt, ADDR alf2, ADDR bRet<br />	invoke MessageBox,NULL,ADDR fmtTxt, ADDR fmtTxt, MB_OK<br />	popad<br /><br />	invoke StrTok, edx, ADDR fspc<br /><br />	pushad<br />	invoke wsprintf, ADDR fmtTxt, ADDR alf2, ADDR bRet<br />	invoke MessageBox,NULL,ADDR fmtTxt, ADDR fmtTxt, MB_OK<br />	popad<br /></code></pre><br /><br /><br />I did go through an entire string loaded into memory, course I had to find the start of the string on each line to parse through it otherwise would be inefficient loop.</div>
    <div class="meta">Posted on 2004-01-21 16:39:23 by drarem</div>
   </div>
   <div class="post" id="post-131845">
    <div class="subject"><a href="#post-131845">StrTok function v0.1</a></div>
    <div class="body"><strong>StrTok v0.2</strong> <br /><br /><br />- cleans up the global 'return' string, eg the Back: loop<br />- returns '1' if successful in finding a token and returning a string<br /><br /><pre><code><br />StrTok PROC bStr&#58;DWORD, pStr&#58;DWORD<br />;bStr = string to be parsed, such as&#58; db,&quot;C&#58;\current_directory\filename1.mph&quot;,0<br />;pStr = tokens, such as&#58; db,&quot;\.&quot;,0<br />;bRet = your string to define, such as&#58;  &#40;.data&#41; bRet db 80 dup&#40;0&#41;<br />;uses the four 32-bit registers eax,ebx,ecx, and edx, and the edi/esi<br />;preserve edx pointer between calls to this function<br />;to continue stripping of the same line<br />;a '0' should be returned<br />;when done with line, untested as of yet..<br /><br />	mov edx, bStr<br />	mov edi, OFFSET bRet<br />	lea esi, bRet<br />	xor ecx,ecx<br />Back&#58;<br />	mov BYTE PTR &#91;esi&#93;, 0<br />	inc esi<br />	inc ecx<br />	cmp ecx,80            ;size of bRet, in this case 80 bytes<br />	jle Back                 ;this clean-up loop can definitely be optimized<br /><br />	xor eax,eax<br />	xor ecx,ecx<br />	<br />sloop1&#58;<br />	mov al, &#91;edx&#93;<br />	cmp al,0<br />	je sloop1e    ;jump if end of input string<br />	cmp al,13<br />	je sloop1n	  ;jump if end of line - make eax==0 to know end of line for looping<br />	cmp al,10<br />	je sloop1n	  ;jump just to be safe if only 0A is present so first set ret value to 0<br />	jmp sloop1a<br /><br />sloop1n&#58;<br />	xor eax,eax   ;this is untested, so to put StrTok&#40;&#41; into a loop<br />	jmp exitloop	  ;return with eax==0 when end of the line<br /><br />sloop1a&#58;<br />	;xor ecx,ecx		;to strip everything out except the strings, makes one long concatenation<br />	mov ebx, pStr		;move token to ebx<br /><br />sloop1b&#58;         ;token loop<br />	mov cl,&#91;ebx&#93;<br />	cmp al,cl<br />	je sloop1c   ;found a matching token, so we need to keep moving in our string<br />	cmp cl,0<br />	je sloop1d   ;you have reached the end of the token string and found no match, add to bRet&#91;&#93;<br />	inc ebx<br />	jmp sloop1b  ;found no match or end, keep looking for a match until found or end<br /><br />sloop1c&#58;<br />	cmp ch,1     ;set 'flag' here to indicate starting position in string<br />	je sloop1e<br />	inc edx<br />	jmp sloop1<br /><br />sloop1d&#58;            ;only call this if no matches above<br />	mov ch,1		;simple flag for checking if found the first token<br />	inc edx			;added just now<br />	mov BYTE PTR &#91;edi&#93;, al<br />	inc edi<br />	jmp sloop1<br /><br />sloop1e&#58;<br />	mov BYTE PTR &#91;edi&#93;, 0       ;null-terminate the string<br />	mov eax,1   ;move success to eax<br />exitloop&#58;<br />	ret<br />	<br />StrTok endp<br /></code></pre></div>
    <div class="meta">Posted on 2004-01-27 08:00:21 by drarem</div>
   </div>
   <div class="post" id="post-131875">
    <div class="subject"><a href="#post-131875">StrTok function v0.1</a></div>
    <div class="body">haven't really looked at or tested your code (I probably wouldn't use strtok if I need high-speed string parsing anyway), but one thing that comes to mind: you should really preserve ebx,esi,edi , or you might end up in trouble.</div>
    <div class="meta">Posted on 2004-01-27 10:52:32 by f0dder</div>
   </div>
   <div class="post" id="post-132334">
    <div class="subject"><a href="#post-132334">StrTok function v0.1</a></div>
    <div class="body">Wow,<br /><br />That looks like a pretty nice routine. I have my own StrToken routine that I use that is much simpler but then it only does 1 byte tokens. I find single byte tokens is all I need as mostly I am searching for \ or , . This works exactly like the MSVCRT strtok function. The first time you call it you give it an address to the string then each subsequent call you use NULL instead of the string address. It will replace the token with NULL so it destroys the string but I have never had a situation where I needed to keep the string after parsing anyway...<br /><br /><pre><code>; Note in GoAsm the &quot;,&quot; will generate an OFFSET to a string<br />; containing &quot;,&quot;,0. It is equiv to CTEXT&#40;&#41; or whatever it is in MASM<br /><br />invoke StrToken,OFFSET TestStr,&quot;,&quot;<br />PrintStringByAddr&#40;eax&#41;<br />invoke StrToken,NULL,&quot;,&quot;<br />PrintStringByAddr&#40;eax&#41;<br />invoke StrToken,NULL,&quot;,&quot;<br />PrintStringByAddr&#40;eax&#41;</code></pre><br /><pre><code>.data<br />NextToken DD ?<br />LenToken DD ?<br />.code<br />StrToken FRAME pString,pToken<br />	uses edi,ebx,ecx<br /><br />	mov eax,&#91;pToken&#93;<br />	movzx ebx,B&#91;eax&#93;<br /><br />	mov edi,&#91;pString&#93;<br />	or edi,edi<br />	jz &gt;<br />		mov &#91;NextToken&#93;,edi<br />		invoke StrLen,edi<br />		mov &#91;LenToken&#93;,eax<br />		jmp &gt;L1<br />	&#58;<br />		mov edi,&#91;NextToken&#93;<br />	L1&#58;<br />	mov ecx,&#91;LenToken&#93;<br />	mov al,bl<br />	repne scasb<br /><br />	cmp B&#91;edi-1&#93;,al<br />	jne &gt;<br />		mov B&#91;edi-1&#93;,0<br />	&#58;<br />	mov eax,&#91;NextToken&#93;<br />	mov &#91;NextToken&#93;,edi<br />	mov &#91;LenToken&#93;,ecx<br />	RET<br />ENDF</code></pre></div>
    <div class="meta">Posted on 2004-02-02 15:08:25 by donkey</div>
   </div>
  </div>
 </body>
</html>