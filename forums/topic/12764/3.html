<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Trying to understand some instruction timing - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=12764" />
  <link rel="prev" href="../?id=12764&amp;page=2" />  <link rel="next" href="../?id=12764&amp;page=4" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=12764">Trying to understand some instruction timing</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=12764&amp;page=1" style="">&laquo;</a><a href="../?id=12764&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="12764" /><input type="number" name="page" min="1" max="4" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=12764&amp;page=4">&gt;</a><a href="../?id=12764&amp;page=4">&raquo;</a></form>   <div class="post" id="post-98938">
    <div class="subject"><a href="#post-98938">Trying to understand some instruction timing</a></div>
    <div class="body">It looks from the test result that LEA is very poor on a P4 when the comparison from PIII to PIV is so large.<br /><br />Most of the technical data indicated that older instructions like INC DEC SHL SHR and it seems now LEA are best avoided on a P4 if you are writing processor specific code.<br /><br />This is unfortunate as Intel processors from early Pentiums to PIII were reliable on this type of code so it makes producing general purpose code a fair bit harder.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2003-04-23 20:34:14 by hutch--</div>
   </div>
   <div class="post" id="post-98991">
    <div class="subject"><a href="#post-98991">Trying to understand some instruction timing</a></div>
    <div class="body">It's a bit annoying indeed - means P4s will run relatively poor on a lot of old optimized code. Didn't really come as a big surprise, though. But it also shows that you can get quite decent performance when you code for the P4. Which doesn't even appear to be that hard to do.<br /><br />From what I can see, you're best off doing the C-style code if you're targetting p3/p4 and want the code to run on all boxes. The C-style code runs well on the P4 (beating all the &quot;plain op&quot; asm variants), competes well on P3, and isn't all that bad (though somewhat slower) on Athlons. If you're targetting P4, of course go SSE2 - the result speaks for itself :). If you're targetting pmmx/higher, go MMX - very good results on all platforms.<br /><br />Of course vectorized (cpu runtime detection + function pointers) can be used to use optimal routines at runtime.<br /><br /><br />Both C variants and the asm MMX/SSE2 have other large benefits: it's *very* easy to change the constant used, without having to recalc a whole bunch of code. Furthermore, MMX and SSE2 can easily be adapted to work with variable multipliers instead of constants. Also, Other (larger) constants than 92 might prove harder to construct good plain-instruction add/lea/whatever algorithms for - might turn up that IMUL would be the best plain instructionset way of doing it then, even on P4.</div>
    <div class="meta">Posted on 2003-04-24 01:33:09 by f0dder</div>
   </div>
   <div class="post" id="post-98992">
    <div class="subject"><a href="#post-98992">Trying to understand some instruction timing</a></div>
    <div class="body">Of course it should be added that the current tests are very simple, and more routines should be written, especially by athlon owners :). Also, conformance tests should be written - MMX/SSE2 works on signed where the rest is unsigned, this might prove funny ;).<br /><br />Furthermore, I'm considering making the test suite &quot;somewhat portable&quot;, so it can be run natively on linux - that way I can also test on a P3-cel-tualatin-1300. Test results for my P4-cel-1.7ghz will be included in next update.<br /><br />Hm. I think it's funny the P4 does so well with the ?ber-simple mmx/sse2 versions. clk/op gets better than the best performing routine on athlon. Somebody write something that runs better clk/op on the athlon, please :)</div>
    <div class="meta">Posted on 2003-04-24 01:49:12 by f0dder</div>
   </div>
   <div class="post" id="post-98996">
    <div class="subject"><a href="#post-98996">Trying to understand some instruction timing</a></div>
    <div class="body">As again MMX and SSE codes impress me<br />:)<br /><br />C:\&gt;&quot;C:\Documents and Settings\Administrator\Desktop\yodel_sse2.exe&quot;<br />--- Yodel version 0.3, 2003/04/23, 22:34<br />## Test parameters: 1000000 iterations of 2048 muls, total 2048000000 muls<br />## TIMECRITICAL: your computer will appear frozen. Don't panic.<br />## Retrieving (NT) or calculating (9x) clockspeed...598 MHz<br />## running performance tests<br />test01-simple C++ code        ...021813 ticks (effective 6.369 clk/mul)<br />test02-Ekted 1                ...029844 ticks (effective 8.714 clk/mul)<br />test03-Roticv 1               ...020609 ticks (effective 6.018 clk/mul)<br />test04-Hutch 1                ...020594 ticks (effective 6.013 clk/mul)<br />test05-f0dder imul            ...017172 ticks (effective 5.014 clk/mul)<br />test06-scali MMX              ...003469 ticks (effective 1.013 clk/mul)<br />test07-scali SSE2             ...002172 ticks (effective -1.#IO clk/mul)<br />test08-DLL                    ...fail<br /></div>
    <div class="meta">Posted on 2003-04-24 02:13:39 by roticv</div>
   </div>
   <div class="post" id="post-98997">
    <div class="subject"><a href="#post-98997">Trying to understand some instruction timing</a></div>
    <div class="body">roticv, did you read the readme? And aren't you on a P3 system, why are you trying to run SSE2 then? Also, you should email me the results instead of posting here - and CPU type + OS wouldn't hurt, either.<br /><br />I'm a bit surprised SSE2 gives the floatinpoint error instead of an invalid opcode exception :confused:</div>
    <div class="meta">Posted on 2003-04-24 02:17:16 by f0dder</div>
   </div>
   <div class="post" id="post-99006">
    <div class="subject"><a href="#post-99006">Trying to understand some instruction timing</a></div>
    <div class="body">I've tested on a couple machine more now, including pmmx-200 and k6-2 350mhz. It seems that if you're only going to do simplistic add/lea stuff, you're probably better of using imul to get the most &quot;stable&quot; performer. If you don't care about pplain, go mmx.<br /><br />I guess I do have to add the dislcaimer that &quot;more algorithms should be written&quot;, to avoid flames by know-better persons :grin:</div>
    <div class="meta">Posted on 2003-04-24 03:40:23 by f0dder</div>
   </div>
   <div class="post" id="post-99024">
    <div class="subject"><a href="#post-99024">Trying to understand some instruction timing</a></div>
    <div class="body">I did have a play on my P4 and ended up with some unusual results.<br /><br />On the two versions I tested, the line of code,<br /><pre><code><br />mov    &#91;edi&#93;,ax<br /></code></pre><br />produced a very bad stall that slowed both my second LEA version and the inline version that EkTed posted by 4 to 5 times. The LEA version was more severely effected by the stall.<br /><br />You can drop the stall to some extent by adding the lines,<br /><pre><code><br />    xor eax, eax<br />    xor ecx, ecx<br />    xor edx, edx<br /></code></pre><br />within the testing loop code and this makes both versions I tested about 20% faster with the line of code that prduces the stall. This may not matter in normal aplication though as I don't have any info on how the data is presented to the algo.<br /><br />On my internat nachine, an old K6-2 550, the lea version is about 40% faster with the line that creates the stall. If that line is removed, the inline version drops in its time by 75%, the LEA version drops by about 80% so in direct comparison, the inline vesion is about 12% faster on the P4  that the LEA version.<br /><br />Below is a simple floating point algo that does the multiplication by 92. It may be worth a try.<br /><br /><pre><code><br />; ?????????????????????????????????????????????????????????????????????????<br /><br />mul92a proc<br /><br />    LOCAL number&#58;DWORD<br />    LOCAL multiplier&#58;DWORD<br /><br />    mov number, 10<br />    mov multiplier, 92<br /><br />    push edi<br /><br />    lea edi, number<br /><br />    fild WORD PTR &#91;edi&#93;         ; load source<br />    fild multiplier             ; load multiplier<br />    fmul                        ; multiply source by multiplier<br />    fistp WORD PTR &#91;edi&#93;        ; store result in variable<br /><br />    ShowReturn hWnd, &#91;edi&#93;<br /><br />    pop edi<br /><br />    ret<br /><br />mul92a endp<br /><br />; ?????????????????????????????????????????????????????????????????????????<br /></code></pre><br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a><br /><br />PS: f0dder, your nose is running again.</div>
    <div class="meta">Posted on 2003-04-24 06:11:02 by hutch--</div>
   </div>
   <div class="post" id="post-99027">
    <div class="subject"><a href="#post-99027">Trying to understand some instruction timing</a></div>
    <div class="body">Nose running, what? I think I clearly stated that the results were based on the current tests, and that more tests should be written. And also that a lot of the test aren't exactly fair since they're not unrolled etc. I should think that I'm rather objective?<br /><br />There's a few things the benchmark currently does show, though. <br />*) SSE2/MMX is great, and there's good reason to believe it will eat anything else. After all, this was what those instruction sets were written for.<br /><br />*) It's easy to get manually built &quot;simple instruction&quot; stuff wrong, so that it will perform poorly on some machines. Hutch original code on P4, Ekted on non-P4. Furthermore, if the constant changes, you have to retime it by hand.<br /><br />*) The intel C++ compiler _does_ do a good job of creating &quot;simple instruction&quot; versions, and it's definitely a bit easier changing a single line of CONSTANT than re-writing &quot;simple-instruction&quot; stuff with stalls and all in mind. Sure, the compiler generated code is not the best, but it performs reasonably, and avoids &quot;really bad&quot; situations on all processors.<br /><br />This is NOT meant to be a C++ vs. asm debate, we're looking at a pretty isolated case. In _this isolated case_, the C++ compiler does a faily reasonable job, while some of the hand-written versions perform very poorly on some platforms (and pretty well on others, of course).<br /><br />Let's try and focus on writing some good algorithms and get them timed reliably (I'd say yodel with TIMECRITICAL and this amount of iterations is &quot;reliable enough&quot;). I'm working on making a nice and easy to use timing environment which also does conformance tests (yes, the yodel stuff) - the current version is very early yet, but I plan on spending some time on it today which should add conformance test, and the option to run only the DLL part. That way, everybody should be able to easily time their own code, in a way that is directly comparable with the other results posted.<br /><br />I'll have a look at your floatingpoint routine later, I had planned to do one myself.</div>
    <div class="meta">Posted on 2003-04-24 06:34:12 by f0dder</div>
   </div>
   <div class="post" id="post-99029">
    <div class="subject"><a href="#post-99029">Trying to understand some instruction timing</a></div>
    <div class="body">f0dder,<br /><br />there is actually a little bit more to optimisation that dumping a C compiler and making noises about it. You do get a win sometimes but often you don't.<br /><br />I have done very little optimisation work on a PIV so I don't claim to know the range but its different to a PIII and earlier so as usual, some tuning would have to be done if the code was pointed specifically at a P4 and nothing else.<br /><br />Testing directly on the P4 showed the big time loss was the stall on the end write and it was severe enough to make both algos run 4 times slower so that is really where the action is, not in trying to interpret the C compiler dump.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a><br /><br />PS: Your nose is still running.</div>
    <div class="meta">Posted on 2003-04-24 06:42:15 by hutch--</div>
   </div>
   <div class="post" id="post-99030">
    <div class="subject"><a href="#post-99030">Trying to understand some instruction timing</a></div>
    <div class="body"><div class="quote"><br />there is actually a little bit more to optimisation that dumping a C compiler and making noises about it. You do get a win sometimes but often you don't.<br /></div><br />Please re-read my post. It's not about C vs. Asm. It's about writing a bunch of algorithms and see how they perform - finding one that works well on all architectures, and some optimized special cases for certain models. I noticed the C code does well on all machines tested on, while some of the asm versions vary much. <br /><br /><div class="quote"><br />I have done very little optimisation work on a PIV so I don't claim to know the range but its different to a PIII and earlier so as usual, some tuning would have to be done if the code was pointed specifically at a P4 and nothing else.<br /></div><br />Yep, it's quite different, and I'm not trying to flame you because your code performs poorly on P4 - it performs well (good end of middle range) on all other machines, pmmx, k6-2, etc. Scali immediately said &quot;hutches code sucks&quot;, I didn't. Please try to show me the same level of objectivity, and refrain from silly remarks such as &quot;your nose is running&quot;.<br /><br />What I can see with the current results is that it's possible to write some generic code that runs fairly well on all architectures (around middle end), code that works really well on either P4 or Athlon, but performs poorly on certain other architectures. And that MMX/SSE2 currently seems to be the way to go.<br /><br /><div class="quote"><br />Testing directly on the P4 showed the big time loss was the stall on the end write and it was severe enough to make both algos run 4 times slower so that is really where the action is, not in trying to interpret the C compiler dump.<br /></div><br />Forget about the &quot;trying to interpret the C compiler dump&quot; part. Again, it's not about C vs. Asm, and I hope you will be mature enough not to try converting this discussion into such. C version is provided since:<br /><br />*) the test-bed is written in C<br />*) it's very easy to verify the validness of the C code, and it can thus be used for conformance tests. Might as well have used a simple asm routine for this, but I wrote it in C. Big deal.<br /><br />However, I don't see any reason not to include the C version in the benchmarks. It's &quot;just another implementation&quot;. It performs reasonably well, benchmarks show that. Does that mean I'm saying &quot;C 0wnz Asm suxx no more algoz have to be written&quot;? NO.<br /><br />I wish to find good routines, both generic and optimized for special architectures, and see how they perform across the different architectures. I am trying to set up a benchmarking framework that is easy to use, and everybody (who knows how to write a DLL) can plug stuff into, regardless of language, so that we have common grounds for comparing benchmarks.</div>
    <div class="meta">Posted on 2003-04-24 06:58:07 by f0dder</div>
   </div>
   <div class="post" id="post-99031">
    <div class="subject"><a href="#post-99031">Trying to understand some instruction timing</a></div>
    <div class="body">Oh, and let's try to _cooperate_ this time, shall we not?</div>
    <div class="meta">Posted on 2003-04-24 07:00:15 by f0dder</div>
   </div>
   <div class="post" id="post-99033">
    <div class="subject"><a href="#post-99033">Trying to understand some instruction timing</a></div>
    <div class="body">Waddya mean &quot;we&quot; paleface ? :tongue: <br /><br />When you spare me the infantile lectures, I will show you how to use a tissue to blow your nose.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2003-04-24 07:03:54 by hutch--</div>
   </div>
   <div class="post" id="post-99035">
    <div class="subject"><a href="#post-99035">Trying to understand some instruction timing</a></div>
    <div class="body">...</div>
    <div class="meta">Posted on 2003-04-24 07:11:54 by JCP</div>
   </div>
   <div class="post" id="post-99046">
    <div class="subject"><a href="#post-99046">Trying to understand some instruction timing</a></div>
    <div class="body"><div class="quote">Scali immediately said &quot;hutches code sucks&quot;, I didn't. </div> <br />I suppose Scali meant that hutch's code does not work well on P4, but it seems that lea works pretty alright on P3, as far as what the tests told me. It seems that on P4, shifts and adds work as good as imul does, but on P3 the shifts and lea are on par. Weird I would say. But seriously the MMX code impressed me. Multiplication on MMX is so fast :grin:<br /><br /><div class="quote">there is actually a little bit more to optimisation that dumping a C compiler and making noises about it. You do get a win sometimes but often you don't.</div> <br />Ah, spare me the flames about C compilers and such (Leave it for another thread or whatsoever). Better to go test other opcodes than blickering about HLL and Low level language.</div>
    <div class="meta">Posted on 2003-04-24 08:24:31 by roticv</div>
   </div>
   <div class="post" id="post-99047">
    <div class="subject"><a href="#post-99047">Trying to understand some instruction timing</a></div>
    <div class="body"><div class="quote"><br />I suppose Scali meant that hutch's code does not work well on P4, but it seems that lea works pretty alright on P3, as far as what the tests told me.<br /></div><br />Actually, I think scali just saw the P4 results, and then classified hutches code as &quot;suck&quot;, especially since it's from hutch. I noticed the code was bad on P4, and decided to test on a bunch of other platforms instead of just saying &quot;it sucks&quot;.<br /><br /><div class="quote"><br />It seems that on P4, shifts and adds work as good as imul does, but on P3 the shifts and lea are on par. Weird I would say. But seriously the MMX code impressed me. Multiplication on MMX is so fast :D<br /></div><br />P4 is a bit weird compared to older processors - a lot of previously written code runs bad. However, it would seem that with properly written code, it should be able to perform _rather_ decently (MMX and SSE2 shows this!) - whether athlons or P4 can reach the highest performance for this task is not yet concluded - more code needs to be written.<br /><br /><div class="quote"><br />Ah, spare me the flames about C compilers and such (Leave it for another thread or whatsoever). Better to go test other opcodes than blickering about HLL and Low level language.<br /></div><br />Thanks, I really appreciate that comment. Wish hutch was as mature.</div>
    <div class="meta">Posted on 2003-04-24 08:32:10 by f0dder</div>
   </div>
   <div class="post" id="post-99066">
    <div class="subject"><a href="#post-99066">Trying to understand some instruction timing</a></div>
    <div class="body">Ok, modified hutches fmul example a bit (see below), these were the timings.<br />P4-2.53ghz: test10-hutch fmul 1 ...008873 ticks (effective 3.033 clk/mul)<br />Athlon700:  test10-hutch fmul 1 ...006469 ticks (effective 8.029 clk/mul)<br /><br />Not surprisingly, fmul sucks on P4 and runs fine on athlon. This is<br />in default FPU setup - I should probably set precision to single,<br />and perhaps rounding to chop? Might improve the situation, worth a try.<br />Perhaps there's also better ways to do it with pure FPU? Too bad pure<br />x87 FPU is bad on P4 (still need to fiddle with control flags though).<br />Also, FPU timings will have to be made on more platforms (if FMUL is<br />to be considered a generic instructionsset version, it has to run<br />reasonably on pmmx and k6 machines).<br /><br />code, somewhat modified from hutches initial idea:<br /><pre><code><br />CONSTANT	dd 92<br />_time10@4&#58;<br />	push	esi<br />	push	edi<br /><br />	mov		esi, &#91;esp+12&#93;<br />	mov		edi, 2048 - 1<br />	fild	DWORD &#91;CONSTANT&#93;		; load multiplier - outside loop, of course.<br />.loop&#58;<br />	; code somewhat modified from hutch begin<br />	fild	WORD  &#91;esi + &#40;edi*2&#41;&#93;	; load source<br />	fmul	st0						; multiply source by multiplier<br />	fistp	WORD  &#91;esi + &#40;edi*2&#41;&#93;	; store result in variable<br />	; code end<br /><br />	sub		edi, 1<br />	jnz		.loop<br /><br />	fstp	st0						; clean up FP stack<br /><br />	pop		edi<br />	pop		esi<br />	mov		eax, 1<br />	ret 4<br /></code></pre></div>
    <div class="meta">Posted on 2003-04-24 10:42:20 by f0dder</div>
   </div>
   <div class="post" id="post-99068">
    <div class="subject"><a href="#post-99068">Trying to understand some instruction timing</a></div>
    <div class="body">Scali's first attempt at Athlon optimizing. Beats the other<br />&quot;simple instruction&quot; versions, doesn't beat imul, and (of course :P)<br />is totaly owned by the MMX version. Please join the fray if<br />you like pondering with code optimization and can do a better<br />job at athlon optimizing!<br /><br />P4-2.53:  test11 ...005359 ticks (effective 6.652 clk/mul)<br />Athlon700:test11 ...013399 ticks (effective 4.580 clk/mul)<br />XP1800:   test11 ...006069 ticks (effective 4.525 clk/mul)<br /><br /><pre><code><br />_time11@4&#58;<br />	push	esi<br />	push	edi<br /><br />	mov		esi, &#91;esp+12&#93;<br />	mov		edi, 2048 - 1<br /><br /><br />.loop&#58;<br />	movzx	eax, word &#91;esi + &#40;edi*2&#41;&#93;<br /><br />	; scali code begin<br />	lea		edx, &#91;eax*4&#93;	; *4<br />	shl		eax, 7			; *128<br />	sub		eax, edx<br />	lea		edx, &#91;edx*8&#93;	; *32<br />	sub		eax, edx<br />	; scali code end<br /><br />	mov		&#91;esi + &#40;edi*2&#41;&#93;, ax<br /><br />	sub		edi, 1<br />	jnz		.loop<br /><br />	pop		edi<br />	pop		esi<br />	mov		eax, 1<br />	ret 4<br /></code></pre></div>
    <div class="meta">Posted on 2003-04-24 10:54:06 by f0dder</div>
   </div>
   <div class="post" id="post-99072">
    <div class="subject"><a href="#post-99072">Trying to understand some instruction timing</a></div>
    <div class="body">there's a bug in the FP code I posted, &quot;fmul st0&quot; should of course be &quot;fmul st1&quot;.<br />I've implemented some conformance tests, and as I expected all the routines failed, because I did wrong array indexing - silly me. Fixed, performance changes a (very) little, but it shouldn't change the overall view at all.<br /><br />A thing to note: all the routines (even mmx and sse2) handle multiplication overflows in the same way as the C version - except for the FPU version. I assume this is because it stores a signed word value? By zero-extending the word value, storing to a temp dword, FMUL, storing to dword, loading eax, storing word, it yields correct results for overflows too - but goes from 8clk/op to 13.7 clk/op on my P4. There's probably a more efficient way of doing this, and perhaps fiddling with rounding modes can fix it.</div>
    <div class="meta">Posted on 2003-04-24 11:42:37 by f0dder</div>
   </div>
   <div class="post" id="post-99075">
    <div class="subject"><a href="#post-99075">Trying to understand some instruction timing</a></div>
    <div class="body">further tweaks:<br /> Changing &quot;complex effective address&quot; to &quot;simple effective address&quot;<br /> (with additional add esi, 2) made the code go from 5.140 clk/op to 5.120 clk/op<br /> on my P4-2.53 ghz, but 4.073 clk/op to 4.077 clk/op on my athlon700.<br /><br />- I guess all of this should be summed up and put in the readme or summat :)</div>
    <div class="meta">Posted on 2003-04-24 12:05:07 by f0dder</div>
   </div>
   <div class="post" id="post-99078">
    <div class="subject"><a href="#post-99078">Trying to understand some instruction timing</a></div>
    <div class="body">Wow, all this from a simple question of a test case I was playing with. :) Thanks for all the effort you guys took to help me out! I don't think it's worth making a master's thesis over though. :)</div>
    <div class="meta">Posted on 2003-04-24 12:09:34 by Ekted</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=12764&amp;page=1" style="">&laquo;</a><a href="../?id=12764&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="12764" /><input type="number" name="page" min="1" max="4" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=12764&amp;page=4">&gt;</a><a href="../?id=12764&amp;page=4">&raquo;</a></form>  </div>
 </body>
</html>