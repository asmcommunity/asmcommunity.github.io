<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Problem with converting a byte to ASCII decimal string - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29202" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29202">Problem with converting a byte to ASCII decimal string</a></p>
   <div class="post" id="post-206226">
    <div class="subject"><a href="#post-206226">Problem with converting a byte to ASCII decimal string</a></div>
    <div class="body">Hi guys, this is my first post here. I&#039;ve been programming in assembly for about six months now as a hobby and enjoying it. <br />I&#039;ve got a problem: I have made a routine called <strong>ConvertByte2Decimal</strong> that converts a byte in memory to an ASCII decimal string at a specified address. It works fine until it reaches the number 160 and above. It seems to go back to 001. I think if someone with fresh eyes may spot the problem.<br />Here&#039;s the code:<br /><pre><code><br /><br /><br />Start:<br />	MOV AL, <br />	MOV SI, string<br />	CALL ConvertByte2Decimal<br />	MOV DX, string<br />	MOV CX, length<br />	CALL Write<br />	JMP Exit<br /><br />;DX: String Address<br />;CX: Length<br />Write:<br />	MOV BX, 1<br />	MOV AH, 40H<br />	INT 21H<br />	RET<br /><br />;----------------------------------------------------------------------------<br />;&nbsp;  	Routine Name 	:&nbsp; &nbsp; 	ConvertByte2Decimal<br />;&nbsp;  	Version&nbsp; &nbsp; &nbsp; &nbsp; 	:&nbsp; &nbsp; 	1.0<br />;&nbsp;  	Created&nbsp; &nbsp; &nbsp; &nbsp; 	:&nbsp; &nbsp; 	24/10/2008<br />;&nbsp;  	Last Update&nbsp;  	:&nbsp; &nbsp; 	2/11/2008<br />;&nbsp;  	Author&nbsp; &nbsp; &nbsp; &nbsp;  	:&nbsp; &nbsp; 	Grich<br />;&nbsp;  	Description&nbsp; &nbsp; 	:&nbsp; &nbsp; 	Converts a byte in memory to a decimal string<br />;&nbsp;  	Prerequisites&nbsp; 	:&nbsp; &nbsp; 	AL: Byte to be converted<br />;					DS: Segment of destination string<br />;					SI: Offset of destination string<br />;---------------------------------------------------------------------------<br /><br />ConvertByte2Decimal:<br />&nbsp; &nbsp; &nbsp; &nbsp; MOV BL, 0AH<br />	MOV AH, 0H			;Clears out Higher Bytes in AX for the Divide<br />	DIV BL				;Divide AX by 0AH (10D)<br />	CMP AL, 0AH			;COMPARE AL to 0AH (10D)<br />	JNAE smallNumber	;IF AL !&gt;= 0AH GOTO smallNumber<br />	MOV DX, AX			;Saves the answer to DX<br />	AND AX, 0FH			;Mask out Higher level Byte in AX<br />	DIV BL				;Divide AX by 0AH (10D)<br />	ADD AL, 30H			;Convert AL to ASCII equivelent<br />	ADD AH, 30H			;Convert AH to ASCII equivelent<br />	MOV , AL		;Move Quotent to postion 0<br />	MOV , AH	;Move Remainder to position 1<br />	MOV AX, DX			;Move DX back to AX<br />	JMP continueConvert	;Continue on to put character three down in the string<br />smallNumber:<br />	MOV BYTE , 20H		;Move a space character to position 0<br />	ADD AL, 30H			;Convert AL toto ASCII equivelent<br />	MOV , AL	;Move Quotent to postion 1<br />continueConvert:<br />	ADD AH, 30H			;Convert AH toto ASCII equivelent<br />	MOV , AH	;Move Remainder to position 2<br />	RET					;Return to Caller<br />	<br />Exit:<br />	MOV AH, 4CH<br />	MOV AL, 0<br />	INT 21H<br />	<br /><br />string	DB	&quot;&nbsp;  &quot;<br />length	EQU	$-string<br />number	DB&nbsp; &nbsp; 190</code></pre><br />This has caused me many sleepless nights.&nbsp; :sad: Any help will be geatly appreciated.<br /><strong>NOTE:</strong> It&#039;s coded in 16 BIT NASM assembly.</div>
    <div class="meta">Posted on 2008-11-05 04:18:41 by Grich</div>
   </div>
   <div class="post" id="post-206227">
    <div class="subject"><a href="#post-206227">Re: Problem with converting a byte to ASCII decimal string</a></div>
    <div class="body">Addon: I&#039;ve been testing it by putting different byte values into <pre><code>number	DB&nbsp; &nbsp; 190</code></pre>.</div>
    <div class="meta">Posted on 2008-11-05 04:20:30 by Grich</div>
   </div>
   <div class="post" id="post-206231">
    <div class="subject"><a href="#post-206231">Re: Problem with converting a byte to ASCII decimal string</a></div>
    <div class="body">You can use my 16-bit  function:<br /><br /><pre><code>; ------------------------------<br />IntToStr PROC<br />&nbsp; COMMENT *<br />&nbsp; &nbsp; Description : Converts an unsigned integer value in the AX register<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to its equivalent text format.<br /><br />&nbsp; &nbsp; Calling Convention : Push from left to right.<br /><br />&nbsp; &nbsp; Parameter(s):<br />&nbsp; &nbsp; &nbsp; WORD Param1 = The Buffer&#039;s Offset.<br /><br />&nbsp; &nbsp; Stack Usage : Up to 22 Bytes.<br /><br />&nbsp; &nbsp; Note : 1) The caller must clean up the pushed parameter(s)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; from the stack.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  2) The buffer should be equal to the length of the number + 1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for the null-terminating character.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  3) The value of the AX register will remain unchanged after<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the execution of the procedure.<br /><br />&nbsp; &nbsp; Example: Converts the number 65535 in the AX register to a<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  null-terminating string buffer.<br /><br />&nbsp; &nbsp; .DATA?<br />&nbsp; &nbsp; &nbsp; String1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  DB&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 10 DUP(?)<br />&nbsp; &nbsp; .CODE<br />&nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp;  AX , 0FFFFh&nbsp; &nbsp; ; The number<br />&nbsp; &nbsp; &nbsp; PUSH&nbsp; &nbsp; OFFSET String1 ; Push the buffer&#039;s offset<br />&nbsp; &nbsp; &nbsp; CALL&nbsp; &nbsp; IntToStr&nbsp; &nbsp; &nbsp;  ; Call the proc<br />&nbsp; &nbsp; &nbsp; ADD&nbsp; &nbsp;  SP , 0002h&nbsp; &nbsp;  ; Remove the parameter from the stack<br />&nbsp; &nbsp; &nbsp; ; String1 = &#039;65535&#039;, 0<br />&nbsp; *<br />&nbsp; PUSH&nbsp; &nbsp; AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Push the AX register onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Push the BX Register onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Push the CX Register onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Push the DX Register onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; BP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Push the BP Register onto the stack<br />&nbsp; PUSH&nbsp; &nbsp; OFFSET @@__IntToStrEP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Offset of the end of the procedure<br />&nbsp; MOV&nbsp; &nbsp;  BP , SP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Move the content of the SP to BP<br />&nbsp; MOV&nbsp; &nbsp;  BX , WORD PTR &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; BX = Buffer OFFSET<br />&nbsp; MOV&nbsp; &nbsp;  CX , 0Ah&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Divide by 10 each time<br />&nbsp; @@__InnerIntToStrLoop:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Inner loop<br />&nbsp; &nbsp; XOR&nbsp; &nbsp;  DX , DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Clear out the remainder<br />&nbsp; &nbsp; DIV&nbsp; &nbsp;  CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Divide by 10<br />&nbsp; &nbsp; PUSH&nbsp; &nbsp; DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Push the remainder onto the stack<br />&nbsp; &nbsp; TEST&nbsp; &nbsp; AX , AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; See if the number is zero<br />&nbsp; &nbsp; JE&nbsp; &nbsp; &nbsp; @@__EOInnerIntToStrLoop&nbsp; &nbsp; &nbsp;  ; Jump to ... if zero<br />&nbsp; &nbsp; CALL&nbsp; &nbsp; @@__InnerIntToStrLoop&nbsp; &nbsp; &nbsp; &nbsp;  ; Keep dividing if the number&#039;s not zero yet<br />&nbsp; @@__EOInnerIntToStrLoop:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; End of the loop<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Pop the last pushed number from the stack<br />&nbsp; &nbsp; OR&nbsp; &nbsp; &nbsp; DL , 30h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Add 48d to the number to make it a character<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  BYTE PTR  , DL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Put the character into the buffer<br />&nbsp; &nbsp; INC&nbsp; &nbsp;  BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Move the buffer to the next position<br />&nbsp; &nbsp; RET&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Do it again until we pop all the digits<br />&nbsp; @@__IntToStrEP:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; End of the procedure routine<br />&nbsp; &nbsp; MOV&nbsp; &nbsp;  BYTE PTR  , 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Null-terminating string<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  BP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Pop the BP register<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  DX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Pop the DX register<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  CX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Pop the CX register<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  BX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Pop the BX register<br />&nbsp; &nbsp; POP&nbsp; &nbsp;  AX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Pop the AX register<br />&nbsp; RET&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ; Return to the calling procedure<br />IntToStr ENDP<br />; ------------------------------</code></pre><br /><br />This is coded in TASM.</div>
    <div class="meta">Posted on 2008-11-05 06:00:46 by XCHG</div>
   </div>
   <div class="post" id="post-206233">
    <div class="subject"><a href="#post-206233">Re: Problem with converting a byte to ASCII decimal string</a></div>
    <div class="body">Thanks XCHG, i&#039;ll convert it over to NASM.</div>
    <div class="meta">Posted on 2008-11-05 16:30:01 by Grich</div>
   </div>
   <div class="post" id="post-206235">
    <div class="subject"><a href="#post-206235">Re: Problem with converting a byte to ASCII decimal string</a></div>
    <div class="body">Grich, I lost you in your code when you compared al with 0ah (which is 10 in decimal). al is the quotient, why would you want to compare with 10? Should it be that you check the original number in ax and see if it is less than 10 and handle it as one case, else the rest assume that it be 2 digits long?</div>
    <div class="meta">Posted on 2008-11-05 18:43:30 by roticv</div>
   </div>
   <div class="post" id="post-206242">
    <div class="subject"><a href="#post-206242">Re: Problem with converting a byte to ASCII decimal string</a></div>
    <div class="body"><div class="quote"><br />Should it be that you check the original number in ax and see if it is less than 10 and handle it as one case, else the rest assume that it be 2 digits long?<br /></div><br />Mmmm ... I&#039;ll try it and report back. Thanks <strong>roticv</strong>.:)</div>
    <div class="meta">Posted on 2008-11-06 06:02:48 by Grich</div>
   </div>
   <div class="post" id="post-206265">
    <div class="subject"><a href="#post-206265">Re: Problem with converting a byte to ASCII decimal string</a></div>
    <div class="body">I found the problem! Something simple and silly. At <span class="mono">AND AX, 0FH</span>, if you change it to <span class="mono">MOV AH, 0H</span>, it works!<br />I think I was being a bit too ambitious using the AND instruction to mask out bytes!&nbsp;  :lol:<br />Anyway, here is the routine that works:<br /><pre><code>;----------------------------------------------------------------------------<br />;&nbsp;  	Routine Name 	:&nbsp; &nbsp; 	ConvertByte2Decimal<br />;&nbsp;  	Version&nbsp; &nbsp; &nbsp; &nbsp; 	:&nbsp; &nbsp; 	1.0<br />;&nbsp;  	Created&nbsp; &nbsp; &nbsp; &nbsp; 	:&nbsp; &nbsp; 	24/10/2008<br />;&nbsp;  	Last Update&nbsp;  	:&nbsp; &nbsp; 	2/11/2008<br />;&nbsp;  	Author&nbsp; &nbsp; &nbsp; &nbsp;  	:&nbsp; &nbsp; 	Grich<br />;&nbsp;  	Description&nbsp; &nbsp; 	:&nbsp; &nbsp; 	Converts a byte in memory to a decimal string<br />;&nbsp;  	Prerequisites&nbsp; 	:&nbsp; &nbsp; 	AL: Byte to be converted<br />;					DS: Segment of destination string<br />;					SI: Offset of destination string<br />;---------------------------------------------------------------------------<br /><br />ConvertByte2Decimal:<br />&nbsp; &nbsp; &nbsp; &nbsp; MOV BL, 0AH<br />	MOV AH, 0H			;Clears out Higher Bytes in AX for the Divide<br />	DIV BL				;Divide AX by 0AH (10D)<br />	CMP AL, 0AH			;COMPARE AL to 0AH (10D)<br />	JNAE smallNumber	;IF AL !&gt;= 0AH GOTO smallNumber<br />	MOV DX, AX			;Saves the answer to DX<br />	MOV AH, 0H			;Mask out Higher level Byte in AX<br />	DIV BL				;Divide AX by 0AH (10D)<br />	ADD AL, 30H			;Convert AL to ASCII equivelent<br />	ADD AH, 30H			;Convert AH to ASCII equivelent<br />	MOV , AL		;Move Quotent to postion 0<br />	MOV , AH	;Move Remainder to position 1<br />	MOV AX, DX			;Move DX back to AX<br />	JMP continueConvert	;Continue on to put character three down in the string<br />smallNumber:<br />	MOV BYTE , 20H		;Move a space character to position 0<br />	ADD AL, 30H			;Convert AL toto ASCII equivelent<br />	MOV , AL	;Move Quotent to postion 1<br />continueConvert:<br />	ADD AH, 30H			;Convert AH toto ASCII equivelent<br />	MOV , AH	;Move Remainder to position 2<br />	RET					;Return to Caller</code></pre></div>
    <div class="meta">Posted on 2008-11-09 00:23:35 by Grich</div>
   </div>
   <div class="post" id="post-206268">
    <div class="subject"><a href="#post-206268">Re: Problem with converting a byte to ASCII decimal string</a></div>
    <div class="body">It&#039;s the law of inverse proportion - the smallest flaw will bring down a mountain, no matter how stable the mountain seems to be.<br /></div>
    <div class="meta">Posted on 2008-11-09 01:56:57 by Homer</div>
   </div>
   <div class="post" id="post-206269">
    <div class="subject"><a href="#post-206269">Re: Problem with converting a byte to ASCII decimal string</a></div>
    <div class="body"><div class="quote"><br />It&#039;s the law of inverse proportion - the smallest flaw will bring down a mountain, no matter how stable the mountain seems to be.<br /><br /></div><br /><br />Wise words. Really relevant to Assembly! Thanks guys, I really appreciate the effort you put into this problem. I&#039;ll be back for some more questions later. :)</div>
    <div class="meta">Posted on 2008-11-09 03:07:20 by Grich</div>
   </div>
   <div class="post" id="post-206272">
    <div class="subject"><a href="#post-206272">Re: Problem with converting a byte to ASCII decimal string</a></div>
    <div class="body">Grich, I don&#039;t know what you are doing in the code but consider rewriting it. It might work but looking at the instructions, I would say it is not the best way of implementing that algorithm especially with the CMP instruction in there. <br /><br />I would do it like this:<br /><br />1) Put the byte in a WORD register. For example, if AL is the byte value to be converted, do this:<br /><br /><pre><code>AND&nbsp; &nbsp; &nbsp; AX , 0x00FF</code></pre><br /><br />So that AH will be zero. Now AX is the value that you want to convert to string.<br /><br />2) Then create two labels namely @Divide and @EndLoop.<br /><br />3) Then Push the OFFSET of @EndLoop into the stack.<br /><br />4) Now in the @Divide loop, start by dividing your AX value by 10. For this, you have to XOR DX , DX because we are going to perform a DIV with a 16-bit divisor which takes in a 32-bit DX:AX register. So clear DX in order to have DX:AX equal to your value:<br /><br /><pre><code>MOV&nbsp; &nbsp; &nbsp; CX , 0x000A<br />@Divide:<br />XOR&nbsp; &nbsp; &nbsp; DX , DX<br />DIV&nbsp; &nbsp; &nbsp; CX</code></pre><br /><br />5) Then push the remainder into the stack (Remainder will be in DX):<br /><br /><pre><code>PUSH&nbsp; &nbsp; &nbsp; DX</code></pre><br /><br />6) Now see if the quotient is zero.<br />7) If not, use the CALL isntruction to CALL the @Divide label again. This way, the 16-bit Instruction Pointer of the next line of the code which will be our @EndLoop label will be pushed onto the stack.<br /><br />8) If yes, then do nothing and let the code roll to the @EndLoop label.<br /><br />So basically what we are doing is that we are taking a number (say 120) and dividing it by 10 constantly until the result is 0.<br /><br />1) Take 120.<br />2) Divide it by 10. Quotient will be 12 and remainder will be 0. Push the remainder (0) into the stack.<br />3) See if the quotient is 0 (12 is not zero). So now take 12 and divide it by 10. The quotient will be 1 and the remainder will be 2. Push the remainder (2) into the stack.<br />4) Now take the quotient of the previous step (1) and try to divide it by 10. The quotient will be 0 and the remainder will be 1. Push the remainder (1) into the stack.<br />5) Now check if the quotient of the previous step (0) is 0. Yes it is. Exit your loop.<br /><br />Now look at the values you have pushed onto the stack from top to bottom: 021. That is the reverse order of 120 which was your original value. Now start a loop and POP the values you had pushed onto the stack. So you will pop 1, 2 and 0 which is 120. You got the value. Do something with it now.<br /><br />There is one catch though that you will find out for yourself later.<br /></div>
    <div class="meta">Posted on 2008-11-09 08:02:27 by XCHG</div>
   </div>
   <div class="post" id="post-206275">
    <div class="subject"><a href="#post-206275">Re: Problem with converting a byte to ASCII decimal string</a></div>
    <div class="body">Just a few questions:<br /><ul><br /><li>Why is using the CMP instruction not the best way to implement the algorithm?</li><br /><li>Why would using the stack help? (I haven&#039;t used a stack yet in my assembly projects yet)</li><br /><li>Why use the CALL instruction to go to labels, I would think that the JMP instruction would be easier.</li><br /></ul><br />Sorry if the questions sound Noob, but I&#039;m still learning :D</div>
    <div class="meta">Posted on 2008-11-10 01:45:44 by Grich</div>
   </div>
   <div class="post" id="post-206276">
    <div class="subject"><a href="#post-206276">Re: Problem with converting a byte to ASCII decimal string</a></div>
    <div class="body">Q: Why is using the CMP instruction not the best way to implement the algorithm?<br />A: It is just not required while you can use the TEST instruction. And also I remember CMP instruction used on 8-bit registers is an expensive operation.<br /><br />Q: Why would using the stack help?<br />Because the results you will get from the algorithm will be in reverse so if you push something into the stack in reverse, you can pop them in the correct way. For example, we push 1, 2, 3 into the stack. Then when you POP, you get 3 first because the rule of stack is last in, first out or (LIFO). You can look that up in Wikipedia I believe.<br /><br />Q: Why use the CALL instruction to go to labels, I would think that the JMP instruction would be easier.<br />A: You can use both CALL and JMP but the difference is that CALL will PUSH the IP of the next instruction, into the stack so the next RET will return to that instruction.<br /><br />So let&#039;s say you have:<br /><br /><pre><code>do this<br />do that<br />CALL something<br />do other thing</code></pre><br /><br />That CALL instruction will push the IP of &quot;do other thing&quot; into the stack so when you are in the &quot;something&quot; procedure and you say RET, the program will go back to &quot;do other thing&quot;. The next instruction after CALL.<br /><br />I hope this helps.</div>
    <div class="meta">Posted on 2008-11-10 04:02:30 by XCHG</div>
   </div>
   <div class="post" id="post-206277">
    <div class="subject"><a href="#post-206277">Re: Problem with converting a byte to ASCII decimal string</a></div>
    <div class="body"><div class="quote"><br />It is just not required while you can use the TEST instruction. And also I remember CMP instruction used on 8-bit registers is an expensive operation.<br /></div><br />I heard about that as well, I&#039;ll use that.<br /><div class="quote"><br />Because the results you will get from the algorithm will be in reverse so if you push something into the stack in reverse, you can pop them in the correct way. For example, we push 1, 2, 3 into the stack. Then when you POP, you get 3 first because the rule of stack is last in, first out or (LIFO). You can look that up in Wikipedia I believe.<br /></div><br />I&#039;m very familiar with stacks, but haven&#039;t had any use for them yet (I&#039;m an applications programmer generally).<br /><div class="quote"><br />A: You can use both CALL and JMP but the difference is that CALL will PUSH the IP of the next instruction, into the stack so the next RET will return to that instruction.<br /></div><br />I understand CALL and RET pretty well for making procedures but if you keep calling up procedures within procedures wouldn&#039;t your program crash when it runs out of stack space? Wouldn&#039;t JMP be sufficient for jumping around in procedures?</div>
    <div class="meta">Posted on 2008-11-10 04:38:43 by Grich</div>
   </div>
   <div class="post" id="post-206279">
    <div class="subject"><a href="#post-206279">Re: Problem with converting a byte to ASCII decimal string</a></div>
    <div class="body">Well suppose you are converting a 16-bit integral value to its equivalent ASCII representation. You can have values in the range of 0-(2^16)-1 which is 0...65535. Your biggest value has 5 digits in it. So you will use CALL the maximum number of 5 times. You will be pushing 16-bit IP values in each CALL which will be 5*16 = 80 bits. I think your stack can handle that 8)<br /><br />Apart from that, using CALL is the recommended method for the algorithm I proposed. It is not necessarily the best method in other algorithms.</div>
    <div class="meta">Posted on 2008-11-10 06:43:14 by XCHG</div>
   </div>
   <div class="post" id="post-206282">
    <div class="subject"><a href="#post-206282">Re: Problem with converting a byte to ASCII decimal string</a></div>
    <div class="body"><div class="quote"><br />I think your stack can handle that 8)</div><br />lol :) I think it could as well.<br /><div class="quote"><br />Apart from that, using CALL is the recommended method for the algorithm I proposed. It is not necessarily the best method in other algorithms.<br /></div><br />So, using CALL or JMP would depend on the algorithm. Well, my thoughts on Assembly has been turned ccompletely upside down!</div>
    <div class="meta">Posted on 2008-11-10 17:25:09 by Grich</div>
   </div>
   <div class="post" id="post-206286">
    <div class="subject"><a href="#post-206286">Re: Problem with converting a byte to ASCII decimal string</a></div>
    <div class="body"><div class="quote"><br />So, using CALL or JMP would depend on the algorithm. Well, my thoughts on Assembly has been turned ccompletely upside down!<br /></div><br /><br />Well, I think XCHG&#039;s point is that if you can eliminate any branches in code execution, do so.<br /><br />While newer CPU&#039;s are becoming faster with more adaptive branch predictions, CALL/JMP can still be considerably more expensive than other logic approaches.</div>
    <div class="meta">Posted on 2008-11-10 23:00:32 by SpooK</div>
   </div>
   <div class="post" id="post-206326">
    <div class="subject"><a href="#post-206326">Re: Problem with converting a byte to ASCII decimal string</a></div>
    <div class="body">i wrote a function like yours X years ago, this function convers a bin value(unsigned) in EAX to a string of dec in address of &quot;fixed&quot;.<br />and i also wrote a function with signed value, that first convers &quot;complemental code&quot; to &quot;true code&quot;, and have a little trick as dealing with <br />value -(2^(x-1)).(because it can&#039;t represent the value of -(2^(x-1)) by &quot;true code&quot;.<br /><br />following is unsigend function.<br /><pre><code><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .MODEL&nbsp; &nbsp; SMALL<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .386<br /><br />PUBLIC&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CONVER10<br /><br />;************************************* DG *****************************************<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .DATA<br /><br />NUM10&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DB 12&nbsp; &nbsp; &nbsp; &nbsp; DUP(?);<br /><br />;************************************* CG *****************************************<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .CODE<br /><br />;convers bin value in eax to string of dec<br />;import argument: EAX = bin value<br />;export: DX = address of dec string<br /><br />CONVER10&nbsp; &nbsp; &nbsp; &nbsp; PROC&nbsp; &nbsp; NEAR<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSHF;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSH&nbsp; &nbsp; EAX;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSH&nbsp; &nbsp; EBX;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSH&nbsp; &nbsp; ECX;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSH&nbsp; &nbsp; ESI;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LEA&nbsp; &nbsp; SI, NUM10<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CMP&nbsp; &nbsp; EAX, 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JNZ&nbsp; &nbsp; EAX_NOT_0;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp; DL, &#039;0&#039;&nbsp; &nbsp; &nbsp; &nbsp; ;whether eax == 0,?<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp; , DL;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INC&nbsp; &nbsp; SI;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JMP&nbsp; &nbsp; CONVER_END_10;&nbsp; &nbsp; <br /><br />EAX_NOT_0:&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp;  EBX, 10D;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XOR&nbsp; &nbsp; CL, CL;<br /><br />DIV10:&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CMP&nbsp; &nbsp; EAX, 0;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JZ&nbsp; &nbsp; &nbsp; &nbsp; zCONVER_END_10;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XOR&nbsp; &nbsp;  EDX, EDX;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DIV&nbsp; &nbsp;  EBX;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ADD&nbsp; &nbsp; DL, 30H;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp;  , DL;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INC&nbsp; &nbsp;  SI;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INC&nbsp; &nbsp; CL;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JMP&nbsp; &nbsp;  DIV10;<br /><br />CONVER_END_10:&nbsp; &nbsp; &nbsp; &nbsp; <br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp; , &#039;$&#039;;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CMP&nbsp; &nbsp; CL, 1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JBE&nbsp; &nbsp; END10;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SHR&nbsp; &nbsp; CL, 1;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XOR&nbsp; &nbsp; CH, CH;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEC&nbsp; &nbsp; SI;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LEA&nbsp; &nbsp; BX, NUM10;<br /><br />REVER10:&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp; AL,&nbsp; ;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XCHG&nbsp; &nbsp; , AL;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MOV&nbsp; &nbsp; , AL;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INC&nbsp; &nbsp; BX;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEC&nbsp; &nbsp; SI;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOOP&nbsp; &nbsp; REVER10;<br /><br />END10:&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LEA&nbsp; &nbsp; DX, NUM10;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp; ESI;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp; ECX;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp; EBX;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; POP&nbsp; &nbsp; EAX;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; POPF;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RET;<br /><br />CONVER10&nbsp; &nbsp; &nbsp; &nbsp; ENDP<br /><br />;************************************** end *********************************************<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; END<br /></code></pre></div>
    <div class="meta">Posted on 2008-11-16 00:21:38 by BtryKit</div>
   </div>
  </div>
 </body>
</html>