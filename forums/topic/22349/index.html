<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>HLA Standard Template Library - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=22349" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=22349">HLA Standard Template Library</a></p>
   <div class="post" id="post-167797">
    <div class="subject"><a href="#post-167797">HLA Standard Template Library</a></div>
    <div class="body">Hi All,<br />I&#39;m currently working on a set of library modules that mimic the capabilities of the C++ Standard Template Library (STL). I&#39;ve currently got vectors working and I&#39;m implementing Deques at this point. I&#39;ll probably post something to webster when I get vectors, deques, and lists functioning.<br /><br />For those who are unfamiliar with the C++ STL, what the STL does is provide a set of &quot;templates&quot; (macros) that expand to class types and their associated methods based on some parameters you supply. For example, the vector template lets you create dynamic arrays of data (which automatically adjust their size at run-time) of any type. For example, you can create a vector of bytes with a declaration like the following:<br /><br />type<br />&nbsp;  byteVector: stl.vector( byte );<br /><br />and you can also create a vector of int32 objects thusly<br /><br />type<br />&nbsp;  int32Vector: std.vector( int32 );<br /><br />or even a vector of some user-defined type:<br /><br />type<br />&nbsp; myTypesVector: std.vector( myType );<br /><br />The vector template not only creates a type you can use to allocate vector objects of the specified type, it also creates all the methods you can use to manipulate objects of that type. For example, with vector objects you can insert, delete, and access elements of the vector. Here&#39;s the list of the methods that the vector template supports:<br /><br />//////////////////////////////////////////////////////////////////////////////<br />//<br />// The vector type.<br />//<br />// This is a dynamic array (single dimension) whose size can change<br />// as needed at runtime.<br />//<br />// Arguments:<br />//<br />//&nbsp; vectorType-<br />//&nbsp;  data type for each element in the vector<br />//<br />//&nbsp; specificCapabilities-<br />//&nbsp;  Enabled/disabled capabilities for this vector (used to alter<br />//&nbsp;  the default settings for a vector).<br />//<br />//<br />// Produces:<br />//<br />//&nbsp; Three different types:<br />//<br />//&nbsp;  vectorType-<br />//&nbsp; &nbsp; a class for the specified vector type.<br />//<br />//&nbsp;  vectorType_cursor-<br />//&nbsp; &nbsp; a type for cursors that point into the vectorType class.<br />//<br />//&nbsp;  p_vectorType-<br />//&nbsp; &nbsp; a pointer to the vectorType class.<br />//<br />//&nbsp; (Note: substitute the actual parameter name for &quot;vectorType&quot;<br />//&nbsp;  in each of the above)<br />//<br />// Publically accessible fields in the class created by this macro<br />// (these fields should be treated as read-only):<br />// <br />//&nbsp; isSTL_c-<br />//&nbsp;  a constant, set to true, that you can use @define on to<br />//&nbsp;  determine that this type is an STL type.<br />//<br />//&nbsp; capabilities_c (compile-time)<br />//&nbsp; capabilities (run-time)<br />//&nbsp;  a bit-mapped array of booleans that specify the capabilities of<br />//&nbsp;  a vector object. Test for the presence of a capability by ANDing<br />//&nbsp;  with one of the *_c constants.<br />//<br />//&nbsp; &nbsp; &nbsp; typeName-<br />//&nbsp;  a string holding the vectorType type name.<br />//<br />//&nbsp; &nbsp; &nbsp; containerName-<br />//&nbsp;  the string &quot;vector&quot;.<br />//<br />//<br />// procedures, methods, and iterators:<br />//<br />//&nbsp; &nbsp; &nbsp; procedure create( numElements:uns32 );<br />//&nbsp;  Constructor for the vector class. If called with the class<br />//&nbsp;  name (e.g., symbol.create(n)) then it will create the object<br />//&nbsp;  on the heap and return a pointer to the new &quot;symbol&quot; object<br />//&nbsp;  in the ESI register. If called with an actual &quot;symbol&quot; variable,<br />//&nbsp;  this constructor initializes that variable.<br />//<br />//&nbsp;  Note: if the underlying vector type is a class type, this<br />//&nbsp;  constructor does *not* call the create procedure for each<br />//&nbsp;  of the underlying elements in the vector. That is the caller&#39;s<br />//&nbsp;  responsibility.<br />//<br />//&nbsp; &nbsp; &nbsp; method destroy;<br />//&nbsp;  Destructor for the vector template class. Deallocates the storage<br />//&nbsp;  associated with the object. Note that if the underlying elements<br />//&nbsp;  are a class type, this destructor does not call the destructor<br />//&nbsp;  for each of those elements. You must explicitly destroy them<br />//&nbsp;  prior to calling this destructor.<br />//<br />//&nbsp; method getSize;<br />//&nbsp;  returns the number of vector elements in EAX. Operates in O(1) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method getAllocSize; @returns( &quot;eax&quot; );<br />//&nbsp;  Returns the number of bytes allocated for the data in the<br />//&nbsp;  vector (in EAX). Operates in O(1) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method getDataSize; @returns( &quot;eax&quot; );<br />//&nbsp;  Returns the number of bytes allocated for the data in actual<br />//&nbsp;  use in the vector. Operates in O(1) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method clear;<br />//&nbsp;  Removes all elements from the vector. Operates in O(1) time.<br />//<br />//&nbsp; &nbsp; &nbsp; iterator forEachElement;<br />//&nbsp;  Iterates through the vector from beginning to end and on each<br />//&nbsp;  iteration returns a pointer to the current vector element in<br />//&nbsp;  the EAX register.<br />//<br />//&nbsp; &nbsp; &nbsp; iterator rForEachElement;<br />//&nbsp;  As above, except it iterates through the vector from the end<br />//&nbsp;  back to the beginning.<br />//<br />//&nbsp; &nbsp; &nbsp; method appendRef( var toAppend:vectorType );<br />//&nbsp;  Appends the object &quot;toAppend&quot; (passed by reference) to the end<br />//&nbsp;  of the vector. Operates in O(1) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method appendVal( toAppend:vectorType );<br />//&nbsp;  Appends the object &quot;toAppend&quot; (passed by value) to the end<br />//&nbsp;  of the vector. Operates in O(1) time.<br />//<br />//&nbsp; method prependRef( var toPrepend:vectorType );<br />//&nbsp;  Inserts the object &quot;toPrepend&quot; at the beginning of the list.<br />//&nbsp;  toPrepend is passed by reference (great for large vectorType<br />//&nbsp;  objects). Operates in O(n) time.<br />//<br />//&nbsp; method prependVal( toPrepend:vectorType );<br />//&nbsp;  Inserts the object &quot;toPrepend&quot; at the beginning of the list.<br />//&nbsp;  toPrepend is passed by value (great for smaller vectorType<br />//&nbsp;  objects). Operates in O(n) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method insertRef( var toInsert:vectorType; posn:uns32 );<br />//&nbsp;  Inserts the object &quot;toInsert&quot; in front the the posnTH object.<br />//&nbsp;  toInsert is passed by reference (great for large vectorType<br />//&nbsp;  objects). Operates in O(n) time.&nbsp; Note that items are indexed<br />//&nbsp;  starting with position zero. If posn is greater than the<br />//&nbsp;  number of vector elements, this method appends the object<br />//&nbsp;  to the end of the vector.<br />//<br />//&nbsp; &nbsp; &nbsp; method insertVal( toInsert:vectorType; posn:uns32 );<br />//&nbsp;  Inserts the object &quot;toInsert&quot; in front the the posnTH object.<br />//&nbsp;  toInsert is passed by value (great for small vectorType<br />//&nbsp;  objects). Operates in O(n) time.&nbsp; Note that items are indexed<br />//&nbsp;  starting with position zero. If posn is greater than the<br />//&nbsp;  number of vector elements, this method appends the object<br />//&nbsp;  to the end of the vector.<br />//<br />//&nbsp; &nbsp; &nbsp; method remove( n:uns32 );<br />//&nbsp;  Removes the object at posn &quot;n&quot; from the vector. If n is greater<br />//&nbsp;  than the number of vector elements, this method has no effect.<br />//&nbsp;  Operates in O(n) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method remove_first;<br />//&nbsp;  Removes the first element from the vector. <br />//&nbsp;  Operates in O(n) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method remove_last;<br />//&nbsp;  Removes the last element from the vector. <br />//&nbsp;  Operates in O(1) time.<br />//<br />//&nbsp; Cursor methods:<br />//&nbsp;  Note: you should not assume that there is a correspondance<br />//&nbsp;  between cursors and pointers to vector elements. Though this<br />//&nbsp;  may be the actual implementation, subclassed vector types<br />//&nbsp;  may not guarantee this same implementation. Treat cursors as<br />//&nbsp;  opaque (private) types that are used internally by vector methods.<br />//<br />//&nbsp; &nbsp; &nbsp; method nextCursor( var cursor:cursorType );<br />//&nbsp;  Modifies the cursor object passed by reference so that it<br />//&nbsp;  points at the next element of the vector (relative to where<br />//&nbsp;  it currently points). If this would advance the cursor beyond<br />//&nbsp;  the end of the vector, this method sets &quot;cursor&quot; to point at<br />//&nbsp;  just beyond the end of the vector (i.e., endCursor). Operates<br />//&nbsp;  in O(1) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method prevCursor( var cursor:cursorType );<br />//&nbsp;  Modifies the cursor object passed by reference so that it<br />//&nbsp;  points at the previous element of the vector (relative to where<br />//&nbsp;  it currently points). If this would advance the cursor before<br />//&nbsp;  the beginning of the vector, this method sets &quot;cursor&quot; to point at<br />//&nbsp;  the start of the vector (i.e., beginCursor). Operates in O(1)<br />//&nbsp;  time.<br />//<br />//&nbsp; &nbsp; &nbsp; method beginCursor( var cursor:cursorType );<br />//&nbsp;  Points the cursor object passed by reference at the start of<br />//&nbsp;  the vector. Operates in O(1) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method endCursor( var cursor:cursorType );<br />//&nbsp;  Points the cursor object passed by reference to the point<br />//&nbsp;  just beyond the end of the vector. Operates in O(1) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method front; @returns( &quot;eax&quot; );<br />//&nbsp;  Returns a cursor value in EAX that corresponds to the start<br />//&nbsp;  of the vector. Operates in O(1) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method back; @returns( &quot;eax&quot; );<br />//&nbsp;  Returns a cursor value in EAX that corresponds to the end<br />//&nbsp;  of the vector (points beyond the end of the vector). Operates<br />//&nbsp;  in O(1) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method atBack( cursor:cursorType ); @returns( &quot;@z&quot; );<br />//&nbsp;  Compares the cursor passed by reference against the end of<br />//&nbsp;  the vector and sets the Z flag if the cursor is at the end<br />//&nbsp;  of the vector. Operates in O(1) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method atFront( cursor:cursorType ); @returns( &quot;@z&quot; );<br />//&nbsp;  Compares the cursor passed by reference against the beginning<br />//&nbsp;  of the vector and sets the Z flag if the cursor as at the<br />//&nbsp;  start of the vector. Operates in O(1) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method at( cursor:cursorType in eax ); @returns( &quot;eax&quot; );<br />//&nbsp;  Returns a pointer (in EAX) to the vector element data referenced by<br />//&nbsp;  the cursor passed by reference. You should use this method to<br />//&nbsp;  convert a cursor to a data element pointer and not assume that<br />//&nbsp;  cursors and data element pointers are equivalent. Operates in<br />//&nbsp;  O(1) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method getAt( cursor:cursorType; var dest:vectorType );<br />//&nbsp;  Copies the data at the vector element referenced by the cursor<br />//&nbsp;  you pass as the first argument to the location specified by<br />//&nbsp;  the second argument. Operates in O(1) time relative to n (the<br />//&nbsp;  number of vector elements).<br />//<br />//&nbsp; &nbsp; &nbsp; method insertAtVal( toInsert:vectorType; cursor:cursorType );<br />//&nbsp;  Inserts the value &quot;toInsert&quot; before the item referenced by<br />//&nbsp;  the cursor passed as the second argument. Value (toInsert) is<br />//&nbsp;  passed by value, making this routine good for small vectorType<br />//&nbsp;  objects. Operates in O(n) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method insertAtRef( var toInsert:vectorType; cursor:cursorType );<br />//&nbsp;  Inserts the value &quot;toInsert&quot; before the item referenced by<br />//&nbsp;  the cursor passed as the second argument. Value (toInsert) is<br />//&nbsp;  passed by reference, making this routine good for large vectorType<br />//&nbsp;  objects. Operates in O(n) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method removeAt( cursor:cursorType );<br />//&nbsp;  Removes the vector entry referenced by the cursor passed<br />//&nbsp;  as the argument. Operates in O(n) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method getRef( n:uns32 in eax ); @returns( &quot;eax&quot; );<br />//&nbsp;  Computes and returns the address (in EAX) of the nTH element<br />//&nbsp;  in the vector. Operates in O(1) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method getVal( n:uns32; var dest:vectorType );<br />//&nbsp;  Copies the value in the nTH vector element to the location<br />//&nbsp;  specified by the second parameter.<br />//<br />//&nbsp; method swapObj( var obj:symbol );<br />//&nbsp;  Swaps the current vector object (THIS) with the one specified<br />//&nbsp;  by the parameter. This routine operates in O(1) time and is<br />//&nbsp;  very fast.<br />//<br />//&nbsp; method swapElements( var first:vectorType; second:vectorType );<br />//&nbsp;  Swaps two vector elements (not necessarily in the same vector).<br />//&nbsp;  Operates in O(1) time.<br />//<br />//&nbsp; &nbsp; &nbsp; method isEqual<br />//&nbsp; &nbsp; &nbsp; ( <br />//&nbsp; &nbsp; &nbsp;  var left:vectorType; <br />//&nbsp; &nbsp; &nbsp;  var right:vectorType <br />//&nbsp; &nbsp; &nbsp; );&nbsp; @returns( &quot;al&quot; );<br />//<br />//&nbsp;  Compares two vectorType objects that are passed by reference<br />//&nbsp;  and returns AL=1 (and clears the Z flag) if they are equal.<br />//&nbsp; &nbsp; &nbsp; <br />//&nbsp; &nbsp; &nbsp; method isLess<br />//&nbsp; &nbsp; &nbsp; ( <br />//&nbsp; &nbsp; &nbsp;  var left:vectorType; <br />//&nbsp; &nbsp; &nbsp;  var right:vectorType <br />//&nbsp; &nbsp; &nbsp; );&nbsp; @returns( &quot;al&quot; );<br />//<br />//&nbsp;  Compares two vectorType objects that are passed by reference<br />//&nbsp;  and returns AL=1 (and clears the Z flag) if left &lt; right.<br />//&nbsp; &nbsp; &nbsp; <br />//&nbsp; &nbsp; &nbsp; <br />//&nbsp; &nbsp; &nbsp; method isLessEqual<br />//&nbsp; &nbsp; &nbsp; ( <br />//&nbsp; &nbsp; &nbsp;  var left:vectorType; <br />//&nbsp; &nbsp; &nbsp;  var right:vectorType <br />//&nbsp; &nbsp; &nbsp; );&nbsp; @returns( &quot;al&quot; );<br />//<br />//&nbsp;  Compares two vectorType objects that are passed by reference<br />//&nbsp;  and returns AL=1 (and clears the Z flag) if left &lt;= right.<br />// <br />//&nbsp; Note: you can simulate &lt;&gt;, &gt;, and &gt;= by inverting the value in AL<br />//&nbsp; upon return from the above three routines.&nbsp; &nbsp;  <br />//&nbsp; &nbsp; &nbsp; <br />//&nbsp; &nbsp; &nbsp; method toString; @external( outputFunc[0] );<br />//&nbsp;  (Optional implementation) Converts an object of type &quot;symbol&quot;<br />//&nbsp;  to a string for use by output routines like stdout.put.<br />//<br /><br /><br />Note that the vector template provides complete control over which methods you want to implement on a type by type basis. That is, you can create a vector type that does not support comparisons (isEqual, isLess, isLessEqual) if you don&#39;t need this functionality.<br /><br />Oh well, back to work.<br />Cheers,<br />Randy Hyde<br /></div>
    <div class="meta">Posted on 2005-11-12 11:33:31 by rhyde</div>
   </div>
   <div class="post" id="post-167808">
    <div class="subject"><a href="#post-167808">Re: HLA Standard Template Library</a></div>
    <div class="body">Heh, pretty wicked... I think this is a somewhat weird thing to do in assembly, but it does say something about the power of HLA - cheers :)<br /></div>
    <div class="meta">Posted on 2005-11-12 14:23:04 by f0dder</div>
   </div>
  </div>
 </body>
</html>