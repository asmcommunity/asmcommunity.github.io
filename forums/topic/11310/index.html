<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Dump of c_dfDIMouse2 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=11310" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=11310">Dump of c_dfDIMouse2</a></p>
   <div class="post" id="post-85380">
    <div class="subject"><a href="#post-85380">Dump of c_dfDIMouse2</a></div>
    <div class="body"><strong></strong><br />Please, can anybody produce a dump of the c_dfDIMouse2 and c_rgodfDIMouse2 structures present into DInput.LIB?</div>
    <div class="meta">Posted on 2003-03-06 08:12:56 by Maverick</div>
   </div>
   <div class="post" id="post-85395">
    <div class="subject"><a href="#post-85395">Dump of c_dfDIMouse2</a></div>
    <div class="body"><pre><code><br />_DIOBJECTDATAFORMAT	STRUC<br />pguid			DWORD		?<br />dwOfs			DWORD		?<br />dwType			DWORD		?<br />dwFlags03		DWORD		?<br />ENDS<br /><br />DIOBJECTDATAFORMAT		TYPEDEF		_DIOBJECTDATAFORMAT<br />LPDIOBJECTDATAFORMAT		TYPEDEF		PTR _DIOBJECTDATAFORMAT<br /><br /><br /><br />;=======================================<br />; Data Format Structure<br />;=======================================<br />_DIDATAFORMAT	STRUC<br />	dwSize		DWORD		?<br />	dwObjSize	DWORD		?<br />	dwFlags02	DWORD		?<br />	dwDataSize	DWORD		?<br />	dwNumObjs	DWORD		?<br />	rgodf		LPDIOBJECTDATAFORMAT		?	;LPDIOBJECTDATAFORMAT<br />ENDS<br /><br />DIDATAFORMAT		TYPEDEF		_DIDATAFORMAT<br /><br />EXTERNDEF	C c_dfDIMouse&#58;_DIDATAFORMAT<br />EXTERNDEF	C c_dfDIKeyboard&#58;_DIDATAFORMAT<br /></code></pre></div>
    <div class="meta">Posted on 2003-03-06 09:33:54 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-85419">
    <div class="subject"><a href="#post-85419">Dump of c_dfDIMouse2</a></div>
    <div class="body"><strong></strong><br />Hi <strong>Bogdan</strong>,<br />I know the structures.. I need the actual values contained in DInput.LIB.. e.g. c_dfDIMouse and c_rgodfDIMouse are:<br /><pre><code><br />DIOBJECTDATAFORMAT c_rgodfDIMouse&#91;7&#93; =<br />&#123;<br />	&#123; &amp;GUID_XAxis, 0, 0xFFFF03, 0 &#125;,<br />	&#123; &amp;GUID_YAxis, 4, 0xFFFF03, 0 &#125;,<br />	&#123; &amp;GUID_ZAxis, 8, 0x80FFFF03, 0 &#125;,<br />	&#123; NULL, 12, 0xFFFF0C, 0 &#125;,<br />	&#123; NULL, 13, 0xFFFF0C, 0 &#125;,<br />	&#123; NULL, 14, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 15, 0x80FFFF0C, 0 &#125;<br />&#125;;<br />const DIDATAFORMAT c_dfDIMouse = &#123; 24, 16, 0x2, 16, 7, c_rgodfDIMouse &#125;;<br /></code></pre><br />Anyway.. neverminds, soon I'll be back home and extract them myself.. it was not a wasted afternoon though, fortunately I found some other stuff to use my development time on. :)<br /><br />Thx anyway. :)</div>
    <div class="meta">Posted on 2003-03-06 11:29:20 by Maverick</div>
   </div>
   <div class="post" id="post-86549">
    <div class="subject"><a href="#post-86549">Dump of c_dfDIMouse2</a></div>
    <div class="body"><strong></strong><br />oooops.. forgot to post the &quot;solution&quot;:<br /><br />The following structures are useful for anybody who wants to use buffered input with DirectInput.<br />The c_dfDIMouse2 (that I was looking for) allows you to read the buttons of those mice with more than 4 buttons.<br /><br />You can easily convert the structures in any assembler syntax you require.<br /><br /><pre><code><br />DIOBJECTDATAFORMAT c_rgodfDIMouse&#91;7&#93; = &#123;<br />	&#123; &amp;GUID_XAxis, 0, 0x00FFFF03, 0 &#125;,<br />	&#123; &amp;GUID_YAxis, 4, 0x00FFFF03, 0 &#125;,<br />	&#123; &amp;GUID_ZAxis, 8, 0x80FFFF03, 0 &#125;,<br />	&#123; NULL,       12, 0x00FFFF0C, 0 &#125;,<br />	&#123; NULL,       13, 0x00FFFF0C, 0 &#125;,<br />	&#123; NULL,       14, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL,       15, 0x80FFFF0C, 0 &#125;<br />&#125;;<br />const DIDATAFORMAT c_dfDIMouse = &#123; 24, 16, 0x2, 16, 7, c_rgodfDIMouse &#125;;<br /></code></pre><br /><br /><pre><code><br />DIOBJECTDATAFORMAT c_rgodfDIMouse2&#91;11&#93; = &#123;<br />	&#123; &amp;GUID_XAxis, 0, 0x00FFFF03, 0 &#125;,<br />	&#123; &amp;GUID_YAxis, 4, 0x00FFFF03, 0 &#125;,<br />	&#123; &amp;GUID_ZAxis, 8, 0x80FFFF03, 0 &#125;,<br />	&#123; NULL,       12, 0x00FFFF0C, 0 &#125;,<br />	&#123; NULL,       13, 0x00FFFF0C, 0 &#125;,<br />	&#123; NULL,       14, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL,       15, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL,       16, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL,       17, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL,       18, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL,       19, 0x80FFFF0C, 0 &#125;<br />&#125;;<br />const DIDATAFORMAT c_dfDIMouse2 = &#123; 24, 16, 0x2, 20, 11, c_rgodfDIMouse2 &#125;;<br /></code></pre><br /><br /><pre><code><br />DIOBJECTDATAFORMAT c_rgodfDIKeyboard&#91;256&#93; = &#123;<br />	&#123; &amp;GUID_Key, 0, 0x8000000C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 1, 0x8000010C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 2, 0x8000020C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 3, 0x8000030C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 4, 0x8000040C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 5, 0x8000050C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 6, 0x8000060C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 7, 0x8000070C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 8, 0x8000080C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 9, 0x8000090C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 10, 0x80000A0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 11, 0x80000B0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 12, 0x80000C0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 13, 0x80000D0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 14, 0x80000E0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 15, 0x80000F0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 16, 0x8000100C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 17, 0x8000110C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 18, 0x8000120C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 19, 0x8000130C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 20, 0x8000140C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 21, 0x8000150C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 22, 0x8000160C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 23, 0x8000170C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 24, 0x8000180C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 25, 0x8000190C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 26, 0x80001A0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 27, 0x80001B0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 28, 0x80001C0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 29, 0x80001D0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 30, 0x80001E0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 31, 0x80001F0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 32, 0x8000200C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 33, 0x8000210C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 34, 0x8000220C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 35, 0x8000230C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 36, 0x8000240C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 37, 0x8000250C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 38, 0x8000260C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 39, 0x8000270C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 40, 0x8000280C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 41, 0x8000290C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 42, 0x80002A0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 43, 0x80002B0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 44, 0x80002C0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 45, 0x80002D0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 46, 0x80002E0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 47, 0x80002F0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 48, 0x8000300C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 49, 0x8000310C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 50, 0x8000320C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 51, 0x8000330C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 52, 0x8000340C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 53, 0x8000350C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 54, 0x8000360C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 55, 0x8000370C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 56, 0x8000380C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 57, 0x8000390C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 58, 0x80003A0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 59, 0x80003B0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 60, 0x80003C0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 61, 0x80003D0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 62, 0x80003E0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 63, 0x80003F0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 64, 0x8000400C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 65, 0x8000410C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 66, 0x8000420C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 67, 0x8000430C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 68, 0x8000440C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 69, 0x8000450C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 70, 0x8000460C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 71, 0x8000470C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 72, 0x8000480C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 73, 0x8000490C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 74, 0x80004A0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 75, 0x80004B0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 76, 0x80004C0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 77, 0x80004D0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 78, 0x80004E0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 79, 0x80004F0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 80, 0x8000500C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 81, 0x8000510C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 82, 0x8000520C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 83, 0x8000530C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 84, 0x8000540C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 85, 0x8000550C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 86, 0x8000560C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 87, 0x8000570C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 88, 0x8000580C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 89, 0x8000590C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 90, 0x80005A0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 91, 0x80005B0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 92, 0x80005C0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 93, 0x80005D0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 94, 0x80005E0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 95, 0x80005F0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 96, 0x8000600C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 97, 0x8000610C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 98, 0x8000620C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 99, 0x8000630C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 100, 0x8000640C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 101, 0x8000650C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 102, 0x8000660C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 103, 0x8000670C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 104, 0x8000680C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 105, 0x8000690C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 106, 0x80006A0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 107, 0x80006B0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 108, 0x80006C0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 109, 0x80006D0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 110, 0x80006E0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 111, 0x80006F0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 112, 0x8000700C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 113, 0x8000710C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 114, 0x8000720C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 115, 0x8000730C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 116, 0x8000740C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 117, 0x8000750C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 118, 0x8000760C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 119, 0x8000770C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 120, 0x8000780C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 121, 0x8000790C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 122, 0x80007A0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 123, 0x80007B0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 124, 0x80007C0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 125, 0x80007D0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 126, 0x80007E0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 127, 0x80007F0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 128, 0x8000800C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 129, 0x8000810C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 130, 0x8000820C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 131, 0x8000830C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 132, 0x8000840C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 133, 0x8000850C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 134, 0x8000860C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 135, 0x8000870C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 136, 0x8000880C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 137, 0x8000890C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 138, 0x80008A0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 139, 0x80008B0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 140, 0x80008C0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 141, 0x80008D0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 142, 0x80008E0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 143, 0x80008F0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 144, 0x8000900C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 145, 0x8000910C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 146, 0x8000920C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 147, 0x8000930C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 148, 0x8000940C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 149, 0x8000950C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 150, 0x8000960C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 151, 0x8000970C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 152, 0x8000980C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 153, 0x8000990C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 154, 0x80009A0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 155, 0x80009B0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 156, 0x80009C0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 157, 0x80009D0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 158, 0x80009E0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 159, 0x80009F0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 160, 0x8000A00C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 161, 0x8000A10C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 162, 0x8000A20C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 163, 0x8000A30C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 164, 0x8000A40C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 165, 0x8000A50C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 166, 0x8000A60C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 167, 0x8000A70C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 168, 0x8000A80C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 169, 0x8000A90C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 170, 0x8000AA0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 171, 0x8000AB0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 172, 0x8000AC0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 173, 0x8000AD0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 174, 0x8000AE0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 175, 0x8000AF0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 176, 0x8000B00C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 177, 0x8000B10C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 178, 0x8000B20C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 179, 0x8000B30C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 180, 0x8000B40C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 181, 0x8000B50C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 182, 0x8000B60C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 183, 0x8000B70C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 184, 0x8000B80C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 185, 0x8000B90C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 186, 0x8000BA0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 187, 0x8000BB0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 188, 0x8000BC0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 189, 0x8000BD0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 190, 0x8000BE0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 191, 0x8000BF0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 192, 0x8000C00C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 193, 0x8000C10C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 194, 0x8000C20C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 195, 0x8000C30C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 196, 0x8000C40C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 197, 0x8000C50C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 198, 0x8000C60C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 199, 0x8000C70C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 200, 0x8000C80C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 201, 0x8000C90C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 202, 0x8000CA0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 203, 0x8000CB0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 204, 0x8000CC0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 205, 0x8000CD0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 206, 0x8000CE0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 207, 0x8000CF0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 208, 0x8000D00C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 209, 0x8000D10C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 210, 0x8000D20C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 211, 0x8000D30C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 212, 0x8000D40C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 213, 0x8000D50C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 214, 0x8000D60C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 215, 0x8000D70C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 216, 0x8000D80C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 217, 0x8000D90C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 218, 0x8000DA0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 219, 0x8000DB0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 220, 0x8000DC0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 221, 0x8000DD0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 222, 0x8000DE0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 223, 0x8000DF0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 224, 0x8000E00C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 225, 0x8000E10C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 226, 0x8000E20C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 227, 0x8000E30C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 228, 0x8000E40C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 229, 0x8000E50C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 230, 0x8000E60C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 231, 0x8000E70C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 232, 0x8000E80C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 233, 0x8000E90C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 234, 0x8000EA0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 235, 0x8000EB0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 236, 0x8000EC0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 237, 0x8000ED0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 238, 0x8000EE0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 239, 0x8000EF0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 240, 0x8000F00C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 241, 0x8000F10C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 242, 0x8000F20C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 243, 0x8000F30C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 244, 0x8000F40C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 245, 0x8000F50C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 246, 0x8000F60C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 247, 0x8000F70C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 248, 0x8000F80C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 249, 0x8000F90C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 250, 0x8000FA0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 251, 0x8000FB0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 252, 0x8000FC0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 253, 0x8000FD0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 254, 0x8000FE0C, 0 &#125;,<br />	&#123; &amp;GUID_Key, 255, 0x8000FF0C, 0 &#125;<br />&#125;;<br />const DIDATAFORMAT c_dfDIKeyboard = &#123; 24, 16, 0x2, 256, 256, c_rgodfDIKeyboard &#125;;<br /></code></pre><br /><br /><pre><code><br />DIOBJECTDATAFORMAT c_rgodfDIJoystick&#91;44&#93; = &#123;<br />	&#123; &amp;GUID_XAxis, 0, 0x80FFFF03, 256 &#125;,<br />	&#123; &amp;GUID_YAxis, 4, 0x80FFFF03, 256 &#125;,<br />	&#123; &amp;GUID_ZAxis, 8, 0x80FFFF03, 256 &#125;,<br />	&#123; &amp;GUID_RxAxis, 12, 0x80FFFF03, 256 &#125;,<br />	&#123; &amp;GUID_RyAxis, 16, 0x80FFFF03, 256 &#125;,<br />	&#123; &amp;GUID_RzAxis, 20, 0x80FFFF03, 256 &#125;,<br />	&#123; &amp;GUID_Slider, 24, 0x80FFFF03, 256 &#125;,<br />	&#123; &amp;GUID_Slider, 28, 0x80FFFF03, 256 &#125;,<br />	&#123; &amp;GUID_POV, 32, 0x80FFFF10, 0 &#125;,<br />	&#123; &amp;GUID_POV, 36, 0x80FFFF10, 0 &#125;,<br />	&#123; &amp;GUID_POV, 40, 0x80FFFF10, 0 &#125;,<br />	&#123; &amp;GUID_POV, 44, 0x80FFFF10, 0 &#125;,<br />	&#123; NULL, 48, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 49, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 50, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 51, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 52, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 53, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 54, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 55, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 56, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 57, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 58, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 59, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 60, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 61, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 62, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 63, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 64, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 65, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 66, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 67, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 68, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 69, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 70, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 71, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 72, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 73, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 74, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 75, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 76, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 77, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 78, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 79, 0x80FFFF0C, 0 &#125;<br />&#125;;<br />const DIDATAFORMAT c_dfDIJoystick = &#123; 24, 16, 0x1, 80, 44, c_rgodfDIJoystick &#125;;<br /></code></pre><br /><br /><pre><code><br />DIOBJECTDATAFORMAT c_rgodfDIJoystick2&#91;164&#93; = &#123;<br />	&#123; &amp;GUID_XAxis, 0, 0x80FFFF03, 256 &#125;,<br />	&#123; &amp;GUID_YAxis, 4, 0x80FFFF03, 256 &#125;,<br />	&#123; &amp;GUID_ZAxis, 8, 0x80FFFF03, 256 &#125;,<br />	&#123; &amp;GUID_RxAxis, 12, 0x80FFFF03, 256 &#125;,<br />	&#123; &amp;GUID_RyAxis, 16, 0x80FFFF03, 256 &#125;,<br />	&#123; &amp;GUID_RzAxis, 20, 0x80FFFF03, 256 &#125;,<br />	&#123; &amp;GUID_Slider, 24, 0x80FFFF03, 256 &#125;,<br />	&#123; &amp;GUID_Slider, 28, 0x80FFFF03, 256 &#125;,<br />	&#123; &amp;GUID_POV, 32, 0x80FFFF10, 0 &#125;,<br />	&#123; &amp;GUID_POV, 36, 0x80FFFF10, 0 &#125;,<br />	&#123; &amp;GUID_POV, 40, 0x80FFFF10, 0 &#125;,<br />	&#123; &amp;GUID_POV, 44, 0x80FFFF10, 0 &#125;,<br />	&#123; &amp;GUID_XAxis, 48, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_YAxis, 49, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_ZAxis, 50, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_RxAxis, 51, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_RyAxis, 52, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_RzAxis, 53, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_Slider, 54, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_Slider, 55, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_XAxis, 56, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_YAxis, 57, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_ZAxis, 58, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_RxAxis, 59, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_RyAxis, 60, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_RzAxis, 61, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_Slider, 62, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_Slider, 63, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_XAxis, 64, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_YAxis, 65, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_ZAxis, 66, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_RxAxis, 67, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_RyAxis, 68, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_RzAxis, 69, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_Slider, 70, 0x80FFFF0C, 0 &#125;,<br />	&#123; &amp;GUID_Slider, 71, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 72, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 73, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 74, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 75, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 76, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 77, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 78, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 79, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 80, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 81, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 82, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 83, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 84, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 85, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 86, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 87, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 88, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 89, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 90, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 91, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 92, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 93, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 94, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 95, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 96, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 97, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 98, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 99, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 100, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 101, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 102, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 103, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 104, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 105, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 106, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 107, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 108, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 109, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 110, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 111, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 112, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 113, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 114, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 115, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 116, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 117, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 118, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 119, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 120, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 121, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 122, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 123, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 124, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 125, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 126, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 127, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 128, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 129, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 130, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 131, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 132, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 133, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 134, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 135, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 136, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 137, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 138, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 139, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 140, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 141, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 142, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 143, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 144, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 145, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 146, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 147, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 148, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 149, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 150, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 151, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 152, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 153, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 154, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 155, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 156, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 157, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 158, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 159, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 160, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 161, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 162, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 163, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 164, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 165, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 166, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 167, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 168, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 169, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 170, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 171, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 172, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 173, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 174, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 175, 0x80FFFF0C, 0 &#125;,<br />	&#123; NULL, 176, 0x80FFFF03, 512 &#125;,<br />	&#123; NULL, 180, 0x80FFFF03, 512 &#125;,<br />	&#123; NULL, 184, 0x80FFFF03, 512 &#125;,<br />	&#123; NULL, 188, 0x80FFFF03, 512 &#125;,<br />	&#123; NULL, 192, 0x80FFFF03, 512 &#125;,<br />	&#123; NULL, 196, 0x80FFFF03, 512 &#125;,<br />	&#123; NULL, 24, 0x80FFFF03, 512 &#125;,<br />	&#123; NULL, 28, 0x80FFFF03, 512 &#125;,<br />	&#123; NULL, 208, 0x80FFFF03, 768 &#125;,<br />	&#123; NULL, 212, 0x80FFFF03, 768 &#125;,<br />	&#123; NULL, 216, 0x80FFFF03, 768 &#125;,<br />	&#123; NULL, 220, 0x80FFFF03, 768 &#125;,<br />	&#123; NULL, 224, 0x80FFFF03, 768 &#125;,<br />	&#123; NULL, 228, 0x80FFFF03, 768 &#125;,<br />	&#123; NULL, 24, 0x80FFFF03, 768 &#125;,<br />	&#123; NULL, 28, 0x80FFFF03, 768 &#125;,<br />	&#123; NULL, 240, 0x80FFFF03, 1024 &#125;,<br />	&#123; NULL, 244, 0x80FFFF03, 1024 &#125;,<br />	&#123; NULL, 248, 0x80FFFF03, 1024 &#125;,<br />	&#123; NULL, 252, 0x80FFFF03, 1024 &#125;,<br />	&#123; NULL, 256, 0x80FFFF03, 1024 &#125;,<br />	&#123; NULL, 260, 0x80FFFF03, 1024 &#125;,<br />	&#123; NULL, 24, 0x80FFFF03, 1024 &#125;,<br />	&#123; NULL, 28, 0x80FFFF03, 1024 &#125;<br />&#125;;<br />const DIDATAFORMAT c_dfDIJoystick2 = &#123; 24, 16, 0x1, 272, 164, c_rgodfDIJoystick2 &#125;;<br /></code></pre><br /><br />and some GUIDs:<br /><br /><pre><code><br />const U8 System_Host_PC_Win32_Device_DirectInput_GUID_XAxis&#91;16&#93;=&#123;<br />   0xE0,0x02,0x6D,0xA3,<br />   0xF3,0xC9,<br />   0xCF,0x11,<br />   0xBF,<br />   0xC7,<br />   0x44,<br />   0x45,<br />   0x53,<br />   0x54,<br />   0x00,<br />   0x00<br />&#125;;<br /><br />const U8 System_Host_PC_Win32_Device_DirectInput_GUID_YAxis&#91;16&#93;=&#123;<br />   0xE1,0x02,0x6D,0xA3,<br />   0xF3,0xC9,<br />   0xCF,0x11,<br />   0xBF,<br />   0xC7,<br />   0x44,<br />   0x45,<br />   0x53,<br />   0x54,<br />   0x00,<br />   0x00<br />&#125;;<br /><br />const U8 System_Host_PC_Win32_Device_DirectInput_GUID_ZAxis&#91;16&#93;=&#123;<br />   0xE2,0x02,0x6D,0xA3,<br />   0xF3,0xC9,<br />   0xCF,0x11,<br />   0xBF,<br />   0xC7,<br />   0x44,<br />   0x45,<br />   0x53,<br />   0x54,<br />   0x00,<br />   0x00<br />&#125;;<br /><br />const U8 System_Host_PC_Win32_Device_DirectInput_GUID_Key&#91;16&#93;=&#123;<br />   0x20,0x82,0x72,0x55,<br />   0x3C,0xD3,<br />   0xCF,0x11,<br />   0xBF,<br />   0xC7,<br />   0x44,<br />   0x45,<br />   0x53,<br />   0x54,<br />   0x00,<br />   0x00<br />&#125;;<br /></code></pre><br /><br />Having understood the mechanism behind it, you can extract all the other necessary information from dinput.h<br /><br />A final note.. I suggest you NOT to use DInput notification functions.. they suffer from the same defects of DSound ones.<br />Instead use a multimedia timer (e.g. set to 10 ms) to check for buffered input via GetDeviceData()</div>
    <div class="meta">Posted on 2003-03-11 14:46:16 by Maverick</div>
   </div>
   <div class="post" id="post-86592">
    <div class="subject"><a href="#post-86592">Dump of c_dfDIMouse2</a></div>
    <div class="body">Thank you man...<br /><br />Ooops ... <br /><br />What are the defects that affect  DirectInput Notification functions and DirectSound Ones?</div>
    <div class="meta">Posted on 2003-03-11 19:09:14 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-86657">
    <div class="subject"><a href="#post-86657">Dump of c_dfDIMouse2</a></div>
    <div class="body"><strong></strong><br />Hi <strong>Bogdan</strong>,<br /><div class="quote">Thank you man...</div>You're always welcome. :)<br /><br /><div class="quote">Ooops ... <br /><br />What are the defects that affect DirectInput Notification functions and DirectSound Ones?</div>Latency.. either directly or indirectly. If you want a quick response, then Win32 threading is not the right answer. Time slices are just too long (I measured in real conditions up to 30ms.. although I've read about slightly smaller figures). With Multimedia Timers you can get as low as 1 ms (not that you must do it, if unnecessary.. because it will load a bit the system on slow PCs. But 2 ms begins to be ok also in those).<br /><br />How much latency can be considered acceptable in a program is subjective.. but only till a certain extent.<br />For example, in serious audio application 30 ms may be the very maximum your hear may find acceptable.<br />If you use DirectSound, then the normal, standard way (meaning double buffering) already mean half of the buffer's length, as latency. Then you add notification, which is done via threading, and you must add another 30 ms at least. Then Win2000/XP KMixer adds another 30 ms on top of that.<br />It clear that for any serious application you've to remove every one of those sources of latency. Assuming that you can (and you can), then imagine you were writing a realtime synth application (e.g. a &quot;keyboard&quot;) and already fixed all the sound latency problems. With DInput notification, after pressing a key it may take 30 ms or more that your other thread gets notified.. vanishing all the efforts you already made to reduce (or eliminate) sound latency. Things are even worse if you want to use MIDI input, which is quite time-critical per definition.<br /><br />The threading model of Win32 is just insufficient for anything too real-time oriented.. Multimedia Timers are a partial solution, though and can, in many cases, give overall decent results.</div>
    <div class="meta">Posted on 2003-03-12 03:25:27 by Maverick</div>
   </div>
   <div class="post" id="post-86734">
    <div class="subject"><a href="#post-86734">Dump of c_dfDIMouse2</a></div>
    <div class="body">Huh there are DInput notfication functions?! I just used the GetDeviceState for the Keyb and Mouse. I feel that its better for the main app to sample the inputs when its ready for it. But in DOS I would use shared memory for keyboard input. <br /><br />Are Multimedia Timers good? I hear they are the way to go and I may use them in game code. So how do they do with precision and timing? And what piece of hardware do they use for the high resolution timer if there are not using the PIT (I think its Intel 8255)?</div>
    <div class="meta">Posted on 2003-03-12 14:00:04 by x86asm</div>
   </div>
   <div class="post" id="post-86746">
    <div class="subject"><a href="#post-86746">Dump of c_dfDIMouse2</a></div>
    <div class="body"><div class="quote"><br />Huh there are DInput notfication functions?! I just used the GetDeviceState for the Keyb and Mouse. I feel that its better for the main app to sample the inputs when its ready for it. But in DOS I would use shared memory for keyboard input. <br /><br />Are Multimedia Timers good? I hear they are the way to go and I may use them in game code. So how do they do with precision and timing? And what piece of hardware do they use for the high resolution timer if there are not using the PIT (I think its Intel 8255)? </div>Sampling is bad.. you can miss events. You should really use buffered input, even better making use of the TimeStamp.<br /><br />Multimedia Timers good? Well, all is relative. They're the best-implemented single feature of Windows anyway, IMHO.<br />My tests (on a variety of Windows 9x and NT-based versions, and on CPU's ranging from old Pentiums to Athlon XP) showed that they behave quite well. If you set them to 1 ms and request the maximum possible precision, they will have a consistency like:<br /><pre><code><br />Athlon TB 800 MHz, Windows 2000 SP3&#58;<br /><br /><br />Delta = 789957<br />Delta = 816345<br />Delta = 772644<br />Delta = 818523<br />Delta = 803886<br />Delta = 801462<br />Delta = 778261<br />Delta = 830031<br />Delta = 775027<br />Delta = 803091<br />Delta = 808146<br />Delta = 802869<br />Delta = 788345<br />Delta = 820706<br />Delta = 774172<br />Delta = 817295<br />Delta = 801040<br />Delta = 796529<br />Delta = 786203<br />Delta = 815364<br />Delta = 775333<br />Delta = 816221<br />Delta = 801073<br />Delta = 803132<br />Delta = 788180<br />Delta = 830504<br />Delta = 770105<br />Delta = 812855<br />Delta = 796475<br />Delta = 796275<br />Delta = 795520<br />Delta = 823848<br />Delta = 767937<br />Delta = 810919<br />Delta = 820927<br />Delta = 786863<br />Delta = 784874<br />Delta = 824898<br />Delta = 768016<br />Delta = 817845<br />Delta = 796183<br />Delta = 799324<br />Delta = 796337<br />Delta = 825582<br />Delta = 769386<br />Delta = 814176<br />Delta = 797899<br />Delta = 796364<br />Delta = 798186<br />Delta = 822413<br />Delta = 766333<br />Delta = 811513<br />Delta = 810138<br />Delta = 795513<br />Delta = 784932<br />Delta = 823569<br />Delta = 784229<br />Delta = 810540<br />Delta = 792810<br />Delta = 798574<br />Delta = 795401<br />Delta = 829344<br />Delta = 780628<br />Delta = 805551<br />Delta = 792373<br />Delta = 810875<br />Delta = 775952<br />Delta = 830198<br />Delta = 774972<br />Delta = 814927<br />Delta = 788034<br />Delta = 801492<br />Delta = 789148<br />Delta = 833332<br />Delta = 763076<br />Delta = 823539<br />Delta = 790462<br />Delta = 805923<br />Delta = 789953<br />Delta = 818276<br />Delta = 772596<br />Delta = 820049<br />Delta = 802470<br />Delta = 791231<br />Delta = 796188<br />Delta = 1274821<br />Delta = 774023<br />Delta = 813281<br />Delta = 799821<br />Delta = 808721<br />Delta = 779167<br />Delta = 824606<br />Delta = 775087<br />Delta = 812974<br />Delta = 800356<br />Delta = 800463<br />Delta = 787115<br />Delta = 825073<br /></code></pre><br />the values shown are the delta of the TSC and the last TSC.<br /><pre><code><br />Pentium 166 MHz, Windows 98&#58;<br /><br /><br />Delta = 216062<br />Delta = 129783<br />Delta = 157720<br />Delta = 189192<br />Delta = 146803<br />Delta = 151882<br />Delta = 171483<br />Delta = 171932<br />Delta = 171283<br />Delta = 151062<br />Delta = 174528<br />Delta = 166227<br />Delta = 171623<br />Delta = 171080<br />Delta = 157715<br />Delta = 166087<br />Delta = 174848<br />Delta = 151197<br />Delta = 185753<br />Delta = 157132<br />Delta = 171833<br />Delta = 165497<br />Delta = 174803<br />Delta = 152107<br />Delta = 171863<br />Delta = 171090<br />Delta = 171415<br />Delta = 150857<br />Delta = 174823<br />Delta = 166407<br />Delta = 171928<br />Delta = 172147<br />Delta = 157473<br />Delta = 165722<br />Delta = 175823<br />Delta = 151417<br />Delta = 186613<br />Delta = 156717<br />Delta = 171823<br />Delta = 166212<br />Delta = 175178<br />Delta = 152082<br />Delta = 171728<br />Delta = 171312<br />Delta = 161858<br />Delta = 165477<br />Delta = 175638<br />Delta = 151907<br />Delta = 171248<br />Delta = 172012<br />Delta = 173248<br />Delta = 161642<br />Delta = 175413<br />Delta = 151367<br />Delta = 172458<br />Delta = 171242<br />Delta = 156908<br />Delta = 166397<br />Delta = 184503<br />Delta = 152042<br />Delta = 172358<br />Delta = 172387<br />Delta = 304258<br />Delta = 373<br />Delta = 202714<br />Delta = 155978<br />Delta = 169655<br />Delta = 166717<br />Delta = 160258<br />Delta = 168477<br />Delta = 178553<br />Delta = 154282<br />Delta = 173308<br />Delta = 159602<br />Delta = 174678<br />Delta = 154302<br />Delta = 178228<br />Delta = 154572<br />Delta = 174293<br />Delta = 173750<br />Delta = 159640<br />Delta = 168607<br />Delta = 177758<br />Delta = 154357<br />Delta = 174693<br />Delta = 160372<br />Delta = 173908<br />Delta = 153912<br />Delta = 177688<br />Delta = 154482<br />Delta = 175358<br />Delta = 175135<br />Delta = 159880<br />Delta = 168822<br />Delta = 179013<br />Delta = 154452<br />Delta = 174968<br />Delta = 159867<br /></code></pre><br />As you can see, they are very acceptable, if we consider how Windows behaves for all the rest, real-time wise.<br /><br />To answer to your last question, I think they use the CMOS IRQ (set to 1024 Hz).</div>
    <div class="meta">Posted on 2003-03-12 15:15:44 by Maverick</div>
   </div>
   <div class="post" id="post-86785">
    <div class="subject"><a href="#post-86785">Dump of c_dfDIMouse2</a></div>
    <div class="body">Hey Maverick how would I enable buffered input in DI? I'm using VC++ but you can pass ASM code and I'll figure it out. But if a CPU can progress through the main game loop quickly enough I don't see how it would be a problem, but I would like to reduce the amount of problems I face.</div>
    <div class="meta">Posted on 2003-03-12 19:46:44 by x86asm</div>
   </div>
   <div class="post" id="post-86814">
    <div class="subject"><a href="#post-86814">Dump of c_dfDIMouse2</a></div>
    <div class="body"><strong></strong><br />The differences are subtle, and depend on how smooth is your main loop, of course.<br /><br />It's just that 1) I'm a perfectionist and 2) sometimes I really needed (for top results of no jerkiness) this perfection, and once I wrote a module, I like to reuse it.. even if in another case the difference may not even be noticeable.<br /><br />If in a slow PC your framerate suddenly drops, you may miss a quick event (e.g. a quick press/release of a button). I like to use TimeStamps because if something &quot;freezes&quot; I can reconstruct also the timing of the events.. it's complicate/advanced stuff though, or so it seems at least, I know, you don't have to bother if you don't meet yet the needs to do so. I have a certain real-multimedia background that has made me more sensitive on these issues than most PC users/developers.<br /><br />That was about the keyboard.. the one that gives less problems.<br /><br />For the mouse there are further limitations imposed by the PC hardware.<br /><br />But I'm afraid I'm talking to the wrong audience, since the PC has never been good in this regard. Those of you that ever used an Amiga may have noticed how smooth it was to move screens around (a kind of hardware windows) with the mouse.. because the sampling of mouse coordinates was syncronized with the vertical blanking interrupt (and anything else you wished).<br />On the PC, serial mice (and most PS/2 as well) are sampled 40 times per second, and only when they move. This means that the sampling has nothing to do with the vertical blanking period, and when you move a window, it'll use mouse coordinates that don't reflect the reality of that <em>instant</em>, but of the past plus an unconstant error (because the two systems are completely separed and out of synch). This results in jerky movements (heavy aliasing and heavy time distortion, to talk in DSP terms).<br /><br />The real, true mouse coordinates should be readable at any instant ideally (the Amiga had the counters inside the custom chips, so it was no problem.. it was not like on the PC that the counters are inside the mouse itself). Given the hardware limitations of the PC mice, the coordinates should at least be polled in a regular way, hopefully in syncro with the vbl. I successfully managed to do it in my OS, where (on PS/2 mice) I command the mouse to transfer the new coordinates, and at the same time read the input buffer. This causes one vbl period delay, but at least results in all being perfectly in synch and smooth. On serial mice or anyway in Windoze (where I've to use the standard, lame driver) I will (when I'll have the time, that is) write an interpolation routine to reduce as much as possible the aliasing and time distortion. It will result in more delay, but smooth movement as well. Some games are already providing such a &quot;mouse filter&quot;, but I'm not sure it's anything state-of-the-art, for what I've seen/verifyed.<br /><br />Regarding your other question: you use SetBufferSize to set the size of the DInput buffer (by default it's 0, so you must do it), and GetDeviceData to actually get the buffered data. It's all well explained in the SDK tutorial.<br /><br />Sorry, gotta run now, my free time for today has almost totally expired. :(</div>
    <div class="meta">Posted on 2003-03-13 02:06:55 by Maverick</div>
   </div>
   <div class="post" id="post-87775">
    <div class="subject"><a href="#post-87775">Dump of c_dfDIMouse2</a></div>
    <div class="body"><div class="quote"><em>Originally posted by Maverick </em><br /><br />To answer to your last question, I think they use the CMOS IRQ (set to 1024 Hz).<br /> </div><br /><br />You know, I kept getting problems when I was trying to work with CMOS clock back in the days of DOS.  I wonder how in HECK they really ARE supposed to work.</div>
    <div class="meta">Posted on 2003-03-18 00:37:04 by AmkG</div>
   </div>
   <div class="post" id="post-87980">
    <div class="subject"><a href="#post-87980">Dump of c_dfDIMouse2</a></div>
    <div class="body"><div class="quote"><br /><br /><br />You know, I kept getting problems when I was trying to work with CMOS clock back in the days of DOS.  I wonder how in HECK they really ARE supposed to work. </div><br /><br />I also was trying to mess around with them, but I just redesigned my dumb DOS game to use the VSync as timing (yes I know pretty stupid)</div>
    <div class="meta">Posted on 2003-03-18 16:32:59 by x86asm</div>
   </div>
   <div class="post" id="post-87994">
    <div class="subject"><a href="#post-87994">Dump of c_dfDIMouse2</a></div>
    <div class="body"><strong></strong><br />What is stupid? Use VSync as time base for a game? Not at all.. actually it's <strong>the smartest thing one can do</strong>.</div>
    <div class="meta">Posted on 2003-03-18 18:35:36 by Maverick</div>
   </div>
   <div class="post" id="post-88001">
    <div class="subject"><a href="#post-88001">Dump of c_dfDIMouse2</a></div>
    <div class="body"><div class="quote"><br /><strong></strong><br />What is stupid? Use VSync as time base for a game? Not at all.. actually it's <strong>the smartest thing one can do</strong>. </div><br /><br />REALLY?!</div>
    <div class="meta">Posted on 2003-03-18 19:15:11 by x86asm</div>
   </div>
   <div class="post" id="post-88053">
    <div class="subject"><a href="#post-88053">Dump of c_dfDIMouse2</a></div>
    <div class="body"><strong></strong><br />Yes, I wish more PC coders understood that, and that we had a reliable VBlank &quot;callback&quot; (behaving with the usefulness and precision of a true IRQ) under Win32.<br /><br />Under Dos you can program a PIT timer to be syncronized with the VBL period.. but Win32 is the most anti-realtime mainstream OS out there.</div>
    <div class="meta">Posted on 2003-03-19 03:17:21 by Maverick</div>
   </div>
   <div class="post" id="post-88237">
    <div class="subject"><a href="#post-88237">Dump of c_dfDIMouse2</a></div>
    <div class="body">Hey Maverick you seem to know alot of this timing stuff, I need to ask you another question. Its a bout frame rate counters, I see alot of people doing it differently can you poiunt out whats wrong with my method? PLEASE?! :D<br /><br />What I would do is this:<br /><br />-Every time the program has finished drawing a frame, increment a frame counter<br />-Have a timer going in the background, and every second, take the counter and clear it out<br />-Display that as the frames per second (it won't have a decimal point of course :) )<br /><br /><br />Anyway I see a lot of people using the TSC under Windows I forgot how they would access it.<br /><br />Is there anything wrong with it?</div>
    <div class="meta">Posted on 2003-03-19 18:48:52 by x86asm</div>
   </div>
   <div class="post" id="post-88358">
    <div class="subject"><a href="#post-88358">Dump of c_dfDIMouse2</a></div>
    <div class="body"><div class="quote">Hey Maverick you seem to know alot of this timing stuff, I need to ask you another question. Its a bout frame rate counters, I see alot of people doing it differently can you poiunt out whats wrong with my method? PLEASE?! :D<br /><br />What I would do is this:<br /><br />-Every time the program has finished drawing a frame, increment a frame counter<br />-Have a timer going in the background, and every second, take the counter and clear it out<br />-Display that as the frames per second (it won't have a decimal point of course  )</div>That is a possible way.<br /><br /><div class="quote">Anyway I see a lot of people using the TSC under Windows I forgot how they would access it.</div>Use the RDTSC x86 instruction.<br /><br /><div class="quote">Is there anything wrong with it?</div>No, but you can do it better.<br />With your method, you'll get a FPS value only each second. Maybe it would be preferable to show an estimate in a continuos way. For that you may buffer the data.. or calculate the FPS each frame (as the inverse of the time it took since last frame), and then apply a &quot;low-pass&quot; filter to smooth the results.</div>
    <div class="meta">Posted on 2003-03-20 04:07:07 by Maverick</div>
   </div>
   <div class="post" id="post-88566">
    <div class="subject"><a href="#post-88566">Dump of c_dfDIMouse2</a></div>
    <div class="body"><div class="quote"><br />What is stupid? Use VSync as time base for a game? Not at all.. actually it's the smartest thing one can do.<br /></div><br /><br />In the even older days of the Atari, Apple, Commodore, etc. the Vsync (or VBlank) was THE thing you should do.  It was the best timer you could have, except perhaps for the HSync or HBlank, but those clocks were WAY too fast anyway.<br /><br />And really IIRC in the old days of DOS most video cards were pretty consistent in their VBlank/VSync (60/sec).  Nowadays, however, using the frame rate is less consistent: large deviations in the frame rate exist.  On a computer with 100 frames/sec, for instance, Hostile Encounter runs pretty fast, and on a computer with just 60 frames/sec, Hostile Encounter runs slower.</div>
    <div class="meta">Posted on 2003-03-20 18:11:39 by AmkG</div>
   </div>
   <div class="post" id="post-88640">
    <div class="subject"><a href="#post-88640">Dump of c_dfDIMouse2</a></div>
    <div class="body"><div class="quote"><br />And really IIRC in the old days of DOS most video cards were pretty consistent in their VBlank/VSync (60/sec).  Nowadays, however, using the frame rate is less consistent: large deviations in the frame rate exist.  On a computer with 100 frames/sec, for instance, Hostile Encounter runs pretty fast, and on a computer with just 60 frames/sec, Hostile Encounter runs slower. </div>Depending on the type of game you should:<br /><br />1) syncronize the game simulation with the VBL (so to compensate for the problem above)<br /><br />or (worse case IMHO)<br /><br />2) run a fixed speed timer (e.g. a Multimedia Timer) for the game simulation. But this results in aliasing (jerking scrolling, etc..)<br /><br />a better general solution is to:<br /><br />run one game simulation each frame, but using buffered mouse/keyboard data to reconstruct when in time the events occurred, and thus execute more than one game simulation step per frame, when necessary, but &quot;retro execute&quot; it in the correct way, as if it was executed in the right, past time.<br />This removes some of the problem of 1) when you don't have a IRQ, but keeps some of the problem of 2) (time distortion aliasing), unless you use a filter (to guess where the objects will be during that frame).<br /><br />IMO it's always better to design a game where you can sync it with a non-fixed VBL period.. scrolling games are good for this (expecially on subpixel scrolling capable hardware, such as the Amiga 1200/4000 and modern PC with 3D cards).</div>
    <div class="meta">Posted on 2003-03-21 02:42:50 by Maverick</div>
   </div>
   <div class="post" id="post-88653">
    <div class="subject"><a href="#post-88653">Dump of c_dfDIMouse2</a></div>
    <div class="body">Afternoon, All.<br /><br />I must have lost the plot on what's actually being discussed in this thread:tongue: .<br /><br />It *seems* to have turned into a discussion on the best way to have keyboard input plus how to do the timing / display fps.<br /><br />I always have the rendering done during the idle part of the message pump. This means that the updating of position/movement data and the rendering is done as fast as possible.<br /><br />For input, I use a buffer to store whether a key is currently up or down. The buffer is updated during any WM_KEYUP/WM_KEYDWON messages.<br /><br />Elapsed time is updated before repositioning/rendering. All movement is calculated based upon elapsed time.<br /><br />If you lock the framerate at monitor refresh rate, then the game will seem less responsive. This would be fine in games like RTS games, howver it is plainly not acceptable for FPS/Arcade type games.<br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2003-03-21 04:22:12 by Scronty</div>
   </div>
  </div>
 </body>
</html>