<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Boyer moore with masks help - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25634" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25634">Boyer moore with masks help</a></p>
   <div class="post" id="post-187083">
    <div class="subject"><a href="#post-187083">Boyer moore with masks help</a></div>
    <div class="body">Hi guys, i?m trying to work with BM algo making it use masks to search for the strings. but i?m having some troubles.<br /><br />1st - I used the bmh.asm file and fixed a small error (It was not searching a string when it is located on the initial position).<br /><br />2nd - i added a mask &quot;?&quot; to bypass the wanted char, but it only finds the string when the &quot;?&quot; char is located at the position 0, 1 or in the last byte of the string.<br /><br />The algo is:<br /><br /><br /><pre><code>BMHBinsearch proc startpos:DWORD,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpSource:DWORD,srcLngth:DWORD,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpSubStr:DWORD,subLngth:DWORD<br /><br />&nbsp; ; ------------------------------------------------------------------<br />&nbsp; ; This algorithm is related to a Horspool variation of a Boyer<br />&nbsp; ; Moore exact pattern matching algorithm. It only uses the bad char<br />&nbsp; ; shift and increments the source if the character is in the table<br />&nbsp; ; ------------------------------------------------------------------<br /><br />&nbsp; &nbsp; LOCAL cval:DWORD<br />&nbsp; &nbsp; LOCAL shift_table[256]:DWORD<br /><br />&nbsp; &nbsp; push ebx<br />&nbsp; &nbsp; push esi<br />&nbsp; &nbsp; push edi<br /><br />&nbsp; &nbsp; mov ebx, subLngth<br /><br />&nbsp; &nbsp; cmp ebx, 1<br />&nbsp; &nbsp; jg @F<br />&nbsp; &nbsp; mov eax, -2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; string too short, must be &gt; 1<br />&nbsp; &nbsp; jmp BMHout<br />&nbsp; @@:<br /><br />&nbsp; &nbsp; mov esi, lpSource<br />&nbsp; &nbsp; add esi, srcLngth<br />&nbsp; &nbsp; sub esi, ebx<br />&nbsp; &nbsp; mov edx, esi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; set Exit Length<br /><br />&nbsp; ; ----------------------------------------<br />&nbsp; ; load shift table with value in subLngth<br />&nbsp; ; ----------------------------------------<br />&nbsp; &nbsp; mov ecx, 256<br />&nbsp; &nbsp; mov eax, ebx<br />&nbsp; &nbsp; lea edi, shift_table<br />&nbsp; &nbsp; rep stosd<br /><br />&nbsp; ; ----------------------------------------------<br />&nbsp; ; load decending count values into shift table<br />&nbsp; ; ----------------------------------------------<br />&nbsp; &nbsp; mov ecx, ebx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; SubString length in ECX<br />&nbsp; &nbsp; dec ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; correct for zero based index<br />&nbsp; &nbsp; mov esi, lpSubStr&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; address of SubString in ESI<br />&nbsp; &nbsp; lea edi, shift_table<br /><br />&nbsp; &nbsp; xor eax, eax<br /><br />&nbsp; Write_Chars:<br />&nbsp; &nbsp; mov al, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; get the character<br />&nbsp; &nbsp; inc esi<br />&nbsp; &nbsp; mov , ecx&nbsp; &nbsp; &nbsp; &nbsp; ; write shift for each character<br />&nbsp; &nbsp; dec ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; to ascii location in table<br />&nbsp; &nbsp; jnz Write_Chars<br /><br />&nbsp; ; -----------------------------<br />&nbsp; ; set up for main compare loop<br />&nbsp; ; -----------------------------<br />&nbsp; &nbsp; mov ecx, ebx<br />&nbsp; &nbsp; dec ecx<br />&nbsp; &nbsp; mov cval, ecx<br /><br />&nbsp; &nbsp; mov esi, lpSource<br />&nbsp; &nbsp; mov edi, lpSubStr<br />&nbsp; &nbsp; add esi, startpos&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; add starting position<br /><br />; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<br /><br />&nbsp; Main_Loop:<br />&nbsp; &nbsp; xor eax, eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; zero EAX before partial write - xor is faster<br />&nbsp; &nbsp; mov al, <br /><br />&nbsp; &nbsp; cmp byte ptr, &#39;?&#39;<br />&nbsp; &nbsp; je goodmask ; 1st mask. if any char, equal jmp<br /><br />&nbsp; &nbsp; cmp al, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; cmp characters in ESI / EDI<br />&nbsp; &nbsp; jne Get_Shift&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; if not equal, get next shift<br /><br />goodmask:<br />&nbsp; &nbsp; dec ecx<br />&nbsp; &nbsp; jns Main_Loop<br /><br />&nbsp; &nbsp; jmp Matchx<br /><br />&nbsp; Get_Shift:<br />&nbsp; &nbsp; inc esi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; inc esi for minimum shift<br />&nbsp; &nbsp; cmp ebx, shift_table ; cmp subLngth to char shift<br />&nbsp; &nbsp; jne Exit_Test<br />&nbsp; &nbsp; add esi, ecx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; add bad char shift<br />&nbsp; Exit_Test:<br />&nbsp; &nbsp; mov ecx, cval&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; reset counter in compare loop<br />&nbsp; &nbsp; cmp esi, edx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; test for exit condition<br />&nbsp; &nbsp; jle Main_Loop&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; fixed here !!!<br /><br />&nbsp; &nbsp; jmp MisMatch<br /><br />; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<br /><br />&nbsp; Matchx:<br />&nbsp; &nbsp; sub esi, lpSource&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; sub source from ESI<br />&nbsp; &nbsp; mov eax, esi&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; put length in eax<br />&nbsp; &nbsp; jmp BMHout<br /><br />&nbsp; MisMatch:<br />&nbsp; &nbsp; mov eax, -1<br /><br />&nbsp; BMHout:<br />&nbsp; &nbsp; pop edi<br />&nbsp; &nbsp; pop esi<br />&nbsp; &nbsp; pop ebx<br /><br />&nbsp; &nbsp; ret<br /><br />BMHBinsearch endp</code></pre><br /><br /><br />The error in the examples are:<br /><br /><br />call BMHBinsearch 0, gugasource, D@SrcLen, gugateste, D@tmplen<br /><br /> ; ok matched<br />; ; ok matched<br />; ; ok matched<br />; ; no<br />; ; no<br />; ; no<br />; ; no<br />; ;ok matched<br /><br /><br /><br /><br /><br />i have no idea why it is not finding the correct string when the &quot;?&quot; byte is located anywhere outside the 0,1 or the end of the string pos.<br /><br />Also, if someone have an faster and secure algo that works with maks, can pls post here ?<br /><br />and.. the bm.asm is faster then this one ? I didn?t used it, because i found the same problems of finding the initial postiion string and i was unable to fix that.<br /><br />Best Regards,<br /><br />Guga</div>
    <div class="meta">Posted on 2006-12-24 08:17:15 by Beyond2000!</div>
   </div>
  </div>
 </body>
</html>