<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Passing parameter to dlgproc - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=13501" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=13501">Passing parameter to dlgproc</a></p>
   <div class="post" id="post-104570">
    <div class="subject"><a href="#post-104570">Passing parameter to dlgproc</a></div>
    <div class="body">Hi all,<br />I have a problem of having to access 3 dwords in dlgproc (everytime it is called). I do not want a .data section to store a data as it would mean alot more work for me. Anyway here's my code<br /><pre><code><br />.386<br />.model flat,stdcall<br />option casemap&#58;none<br /><br />include /masm32/include/kernel32.inc<br />include /masm32/include/windows.inc<br />includelib /masm32/lib/kernel32.lib<br /><br />dlgproc proto &#58;DWORD,&#58;DWORD,&#58;DWORD,&#58;DWORD<br /><br />.code<br />start&#58;<br />EP&#58;<br />	call	delta<br />delta&#58;<br />	pop		eax<br />	sub		eax,5<br />	push	eax<br />	jmp		@F<br />checksum dd 0A33DBF46h,0CE0C8F2Ah<br />entrypt dd 0h		;entrypt - 13371338h<br />data		dd 04F3A5C5h,0B2AA3D2Dh<br />caption_	dw &quot;I&quot;,&quot;n&quot;,&quot;p&quot;,&quot;u&quot;,&quot;t&quot;,&quot; &quot;,&quot;P&quot;,&quot;a&quot;,&quot;s&quot;,&quot;s&quot;,&quot;w&quot;,&quot;o&quot;,&quot;r&quot;,&quot;d&quot;,0<br />font_ 		dw &quot;M&quot;,&quot;S&quot;,&quot; &quot;,&quot;S&quot;,&quot;a&quot;,&quot;n&quot;,&quot;s&quot;,&quot; &quot;,&quot;S&quot;,&quot;e&quot;,&quot;r&quot;,&quot;i&quot;,&quot;f&quot;,0<br />password_	dw &quot;P&quot;,&quot;a&quot;,&quot;s&quot;,&quot;s&quot;,&quot;w&quot;,&quot;o&quot;,&quot;r&quot;,&quot;d&quot;,&quot;&#58;&quot;,0<br />ok_			dw	&quot;O&quot;,&quot;k&quot;,0<br />userdll		db &quot;user32.dll&quot;,0<br />loadlib		db &quot;LoadLibraryA&quot;,0<br />freelib		db &quot;FreeLibrary&quot;,0<br />exitproc	db &quot;ExitProcess&quot;,0<br />glballoc	db &quot;GlobalAlloc&quot;,0<br />glbfree		db &quot;GlobalFree&quot;,0<br />createdlg	db &quot;DialogBoxIndirectParamA&quot;,0<br />enddlg		db &quot;EndDialog&quot;,0<br />getdlgtxt	db &quot;GetDlgItemTextA&quot;,0<br />@@&#58;<br />	assume	fs&#58;nothing<br />	mov		eax,fs&#58;&#91;30h&#93;<br />	mov		edx,0B8h<br />	mov		ecx,&#91;eax+30h&#93;<br />	test	eax,eax<br />	jns		KI_1<br />	mov		ebx,&#91;eax+34h&#93;<br />	or		ecx,ecx<br />	jnz		KI_2<br />KI_1&#58;<br />	mov		eax,&#91;eax+0Ch&#93;<br />	sub		edx,0B0h<br />	mov		eax,&#91;eax+1Ch&#93;<br />	mov		ebx,&#91;eax&#93;<br />KI_2&#58;<br />	mov		eax,&#91;ebx+edx&#93;	;;ebp = kernel base<br />	mov		ebp,eax<br />	add		eax,&#91;eax+03Ch&#93;<br />	mov		edi,&#91;eax+IMAGE_NT_HEADERS.OptionalHeader.DataDirectory&#93;<br />	add		edi,ebp<br />	mov		ecx,&#91;edi+IMAGE_EXPORT_DIRECTORY.NumberOfNames&#93;<br />	mov		esi,&#91;edi+IMAGE_EXPORT_DIRECTORY.AddressOfNames&#93;<br />	add		esi,ebp<br />nextname_&#58;<br />	mov		eax,&#91;esi&#93;<br />	add		eax,ebp<br />	cmp		dword ptr &#91;eax+00h&#93;, &quot;PteG&quot;	; GetP<br />	jnz		V1_<br />	cmp		dword ptr &#91;eax+04h&#93;, &quot;Acor&quot;	; rocA<br />	jnz		V1_<br />	cmp		dword ptr &#91;eax+08h&#93;, &quot;erdd&quot;	; ddre<br />	jnz		V1_<br />	cmp		word ptr &#91;eax+0Ch&#93;, &quot;ss&quot;	; ss<br />	jnz		V1_<br />	mov		eax,&#91;edi+IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals&#93;<br />	add		eax,ebp<br />	mov		edx,&#91;edi+IMAGE_EXPORT_DIRECTORY.NumberOfNames&#93;<br />	sub		edx,ecx<br />	movzx	ebx,word ptr &#91;edx*2+eax&#93;<br />	mov		eax,&#91;edi+IMAGE_EXPORT_DIRECTORY.AddressOfFunctions&#93;<br />	add		eax,ebp<br />	mov		ebx,&#91;ebx*4+eax&#93;<br />	add		ebx,ebp<br />	jmp		endnameloop_<br />V1_&#58;<br />	add		esi,4<br />	dec		ecx<br />	jnz		nextname_<br />endnameloop_&#58;<br />	pop		edx					;EP<br />	push	edx<br />	add		edx,glballoc - EP<br />	push	edx<br />;	push	offset glballoc<br />	push	ebp<br />	call	ebx<br />	push	400h<br />	push	40h<br />	call	eax<br />	pop		edx<br />	push	eax<br />	mov 	edi,eax<br />	mov		DWORD PTR&#91;edi&#93;,  DS_SETFONT or WS_OVERLAPPED or WS_SYSMENU or DS_CENTER or WS_VISIBLE or WS_POPUP  or WS_CAPTION or WS_MINIMIZEBOX<br />	mov		WORD PTR&#91;edi+8&#93;, 3 		;Number of controls<br />	mov		WORD PTR&#91;edi+10&#93;, 50 	;x<br />	mov		WORD PTR&#91;edi+12&#93;, 50 	;y<br />	mov		WORD PTR&#91;edi+14&#93;, 150	;width<br />	mov		WORD PTR&#91;edi+16&#93;, 70 	;height<br />	add		edi,22<br />	mov		ecx,15<br />	mov		esi,edx<br />	add		esi,caption_ - EP<br />;	lea		esi,caption_<br />	rep		movsw<br />	mov		WORD PTR&#91;edi&#93;, 9<br />	add		edi,2<br />	mov		ecx,14<br />	mov		esi,edx<br />	add		esi,font_ - EP<br />;	lea		esi,font_<br />	rep		movsw<br />	add		edi,3		;align to DWORD<br />	and		edi,-4<br />	mov		DWORD PTR &#91;edi&#93;,WS_VISIBLE or WS_CHILD<br />	mov		WORD PTR &#91;edi+8&#93;,15		;x<br />	mov		WORD PTR &#91;edi+10&#93;,20 	;y<br />	mov		WORD PTR &#91;edi+12&#93;,100	;width<br />	mov		WORD PTR &#91;edi+14&#93;,10	;height<br />	mov		WORD PTR &#91;edi+16&#93;,1001	;ID<br />	mov		WORD PTR &#91;edi+18&#93;,0FFFFh<br />	mov		WORD PTR &#91;edi+20&#93;, 082h	;static<br />	add		edi,22<br />	mov		esi,edx<br />	add		esi,password_ - EP<br />;	lea		esi,password_<br />	mov		ecx, 10<br />	rep		movsw<br />	inc		edi<br />	and		edi,-2		;align to WORD<br />	add		edi,5<br />	and		edi,-4		;align to DWORD<br />	mov		DWORD PTR &#91;edi&#93;,WS_VISIBLE or WS_CHILD or WS_BORDER or ES_PASSWORD or WS_TABSTOP<br />	mov		WORD PTR &#91;edi+8&#93;,55		;x<br />	mov		WORD PTR &#91;edi+10&#93;,19 	;y<br />	mov		WORD PTR &#91;edi+12&#93;,75	;width<br />	mov		WORD PTR &#91;edi+14&#93;,12	;height<br />	mov		WORD PTR &#91;edi+16&#93;,1002	;ID<br />	mov		WORD PTR &#91;edi+18&#93;,0FFFFh<br />	mov		WORD PTR &#91;edi+20&#93;, 081h	;edit<br />	add		edi,29	;26+3<br />	and		edi,-4	;align DWORD<br />	mov		DWORD PTR &#91;edi&#93;,WS_VISIBLE or WS_CHILD<br />	mov		WORD PTR &#91;edi+8&#93;,50		;x<br />	mov		WORD PTR &#91;edi+10&#93;,45 	;y<br />	mov		WORD PTR &#91;edi+12&#93;,50	;width<br />	mov		WORD PTR &#91;edi+14&#93;,15	;height<br />	mov		WORD PTR &#91;edi+16&#93;,1003	;ID<br />	mov		WORD PTR &#91;edi+18&#93;,0FFFFh<br />	mov		WORD PTR &#91;edi+20&#93;, 080h	;button<br />	add		edi,22<br />	mov		esi,edx<br />	add		esi,ok_ - EP<br />;	lea		esi,ok_<br />	mov		ecx,3<br />	rep		movsw<br />	inc		edi<br />	and		edi,-2<br />	add		edi,2<br /> 	pop		esi<br /> 	push	edx<br /> 	add		edx,loadlib - EP<br /> 	push	edx<br />; 	push	offset loadlib<br /> 	push	ebp<br /> 	call	ebx<br /> 	pop		edx<br /> 	push	edx<br /> 	add		edx,userdll - EP<br /> 	push	edx<br />; 	push	offset userdll		;invoke loadlibrary, offset userdll<br /> 	call	eax<br /> 	pop		edx<br /> 	push 	eax					;preserve for later call<br /> 	mov		ecx, 12f000h<br /> 	xchg	esp,ecx<br /> 	mov		&#91;esp&#93;,eax<br /> 	mov		&#91;esp+4&#93;,ebx<br /> 	mov		&#91;esp+8&#93;,edx<br /> 	xchg	ecx,esp<br /> 	mov		edi,edx<br /> 	add		edx,createdlg - EP<br />	push	edx<br />; 	push	offset createdlg<br /> 	push	eax<br /> 	call	ebx<br /> 	push	0<br /> 	mov		ecx,edi<br /> 	add		ecx,dlgproc1 - EP<br />;	lea		ecx,dlgproc1<br /> 	push	ecx<br /> 	push	0<br /> 	push	esi<br /> 	push	400000h<br /> 	call	eax<br />;	invoke	DialogBoxIndirectParam,400000h,esi,0,ADDR dlgproc,0<br />	push	eax<br />	mov		ecx,edi<br />	add		ecx,glbfree - EP<br />	push	ecx<br />;	push	offset glbfree<br />	push	ebp<br />	call	ebx<br />	push	esi<br />	call	eax<br />;	invoke	GlobalFree,esi<br />	pop		eax<br />	cmp		eax,0DEADC0DEh<br />	jnz		@F<br />	mov		ecx,edi<br />	add		ecx,entrypt - EP<br />	add		eax,&#91;ecx&#93;<br />	call	eax<br />@@&#58;<br />	mov		eax,edi<br />	add		eax,freelib - EP<br />;	push	offset freelib<br />	push	ebp<br />	call	ebx<br />	call	eax<br />	mov		ecx,edi<br />	add		ecx,exitproc - EP<br />	push	ecx<br />;	push	offset exitproc<br />	push	ebp<br />	call	ebx<br />	push	0<br />	call	eax<br />	invoke	ExitProcess,0<br />	<br />dlgproc1 proc uses edi ebx hdlg&#58;DWORD,msg,wparam,lparam<br />	xor		edi,edi<br />	mov		eax,msg<br />	cmp		eax,WM_COMMAND<br />	je		wmcommand<br />	cmp		eax,WM_CLOSE<br />	je		wmclose<br />return_&#58;<br />	xor		eax,eax<br />	ret<br />wmcommand&#58;<br />	mov		eax,wparam<br />	and		eax,0ffffh<br />	cmp		eax,1003<br />	jnz		return_<br />	sub 	esp,4*4<br />	mov		edi,esp<br />	mov		edx,12f000h		;data on fixed location on the stack<br />	xchg	edx,esp<br />	mov		eax,&#91;esp&#93;;user32.dll<br />	mov		ecx,&#91;esp+4&#93;;getprocaddress<br />	mov		ebx,&#91;esp+8&#93;<br />	xchg	esp,edx<br />	add		ebx, getdlgtxt - EP<br />	push	ebx<br />	sub		ebx,getdlgtxt - EP<br />;	push	offset getdlgtxt<br />	push	eax<br />	call	ecx<br />	push	16<br />	push	edi<br />	push 	1002<br />	push	&#91;ebp+8&#93;;hdlg<br />	call	eax<br />;	invoke	GetDlgItemText,hdlg,1002,edi,16<br />	push 	edi<br />	add		ebx,data - EP<br />	push	ebx<br />;	push	offset data<br />	call	teandecode1<br />	xor		eax,eax<br />	sete	al<br />	add		ecx,eax		;inc edx<br />	stc<br />	sbb		ecx,13371337h<br />	jnz		@F<br />	sbb		edx,0DEADC0DEh<br />	jnz		@F<br />	;.... some decrpyting code here<br />	mov		edi,0DEADC0DEh<br />	add		esp,4*4<br />	jmp		wmclose<br />@@&#58;<br />	add		esp,4*4<br />	jmp		return_<br />wmclose&#58;<br />	mov		edx,12f000h		;data on fixed location on the stack<br />	xchg	edx,esp<br />	mov		eax,&#91;esp&#93;;user32.dll<br />	mov		ebx,&#91;esp+4&#93;;getprocaddress<br />	mov		ecx,&#91;esp+8&#93;;Entrypoint<br />	xchg	esp,edx<br />	add		ecx,enddlg - EP<br />	push	ecx<br />;	push	offset enddlg<br />	push	eax<br />	call	ebx<br />	push	edi<br />	push	&#91;ebp+8&#93;;hdlg<br />	call 	eax<br />;	invoke	EndDialog,hdlg,ecx<br />	jmp		return_<br />dlgproc1 endp<br /><br />teandecode1&#58;<br />	push	ebx<br />	push	esi<br />	push	edi<br />	mov		eax,0E6D5C622h;lower 32bit of 32*delta<br />	mov		ecx,&#91;esp+4+3*4&#93;<br />	mov		esi,&#91;esp+8+3*4&#93;<br />	mov		edx,&#91;ecx+4&#93;;z<br />	mov		ecx,&#91;ecx&#93;;y<br />@@&#58;<br />	mov		ebx,ecx<br />	shl		ebx,4;z-=&#40;y&lt;&lt;4 ^ y&gt;&gt;5&#41; + y^sum + key&#91;sum&gt;&gt;11 &amp; 3&#93;<br />	mov		edi,ecx<br />	shr		edi,5<br />	xor		ebx,edi<br />	add		ebx,ecx<br />	xor		ebx,eax<br />	mov		edi,eax<br />	shr		edi,11<br />	and		edi,3<br />	add		ebx,&#91;esi+edi*4&#93;<br />	sub		edx,ebx<br />	sub		eax,09E3779B9h;sum -= delta<br />	mov		ebx,edx<br />	shl		ebx,4<br />	mov		edi,edx<br />	shr		edi,5<br />	xor		ebx,edi	;y-=&#40;z&lt;&lt;4 ^ z&gt;&gt;5&#41; + z^sum + key&#91;sum &amp; 3&#93;<br />	add		ebx,edx<br />	xor		ebx,eax<br />	mov		edi,eax<br />	and		edi,3<br />	add		ebx,&#91;esi+edi*4&#93;<br />	sub		ecx,ebx<br />	test	eax,eax<br />	jnz		@B<br />;	mov		edi,&#91;esp+4+3*4&#93;<br />;	mov		&#91;edi&#93;,ecx<br />;	mov		&#91;edi+4&#93;,edx<br />	pop		edi<br />	pop		esi<br />	pop		ebx<br />	ret 8<br />EPEND&#58;<br />end start<br /></code></pre><br />The code I have been using is for the passing of the values are<br /><pre><code><br /> 	mov		ecx, 12f000h<br /> 	xchg	esp,ecx<br /> 	mov		&#91;esp&#93;,eax<br /> 	mov		&#91;esp+4&#93;,ebx<br /> 	mov		&#91;esp+8&#93;,edx<br /> 	xchg	ecx,esp<br /></code></pre><br />I know this code is yucky (as what hutch has said), thus I need some suggestion to solve my problem. Thank you and have a nice day.</div>
    <div class="meta">Posted on 2003-05-24 04:51:07 by roticv</div>
   </div>
   <div class="post" id="post-104572">
    <div class="subject"><a href="#post-104572">Passing parameter to dlgproc</a></div>
    <div class="body">roticv,<br />I don't really have a handle on asm yet, but, if you just want to pass extra params to the proc,<br />can't you just let windows manage it, by using SetWindowLongPtr()... <br /><br />from sdk:<br /><br />SetWindowLongPtr<br />The SetWindowLongPtr function changes an attribute of the specified window. The function also sets a value at the specified offset in the extra window memory. <br /><br />This function supersedes the SetWindowLong function. To write code that is compatible with both 32-bit and 64-bit versions of Windows, use SetWindowLongPtr. <br /><br />LONG_PTR SetWindowLongPtr(<br />  HWND hWnd,           // handle to window<br />  int nIndex,          // offset of value to set<br />  LONG_PTR dwNewLong   // new value<br />);<br /><br />???<br />Brad</div>
    <div class="meta">Posted on 2003-05-24 05:33:48 by Brad</div>
   </div>
   <div class="post" id="post-104574">
    <div class="subject"><a href="#post-104574">Passing parameter to dlgproc</a></div>
    <div class="body">The problem with that api is that I need to get pointer to the function to use it. And the only way to load the functions is through the 3 dwords, one contains user32.dll base code, one contains entrypoint and the last contains the Getprocaddress.</div>
    <div class="meta">Posted on 2003-05-24 06:34:38 by roticv</div>
   </div>
   <div class="post" id="post-104581">
    <div class="subject"><a href="#post-104581">Passing parameter to dlgproc</a></div>
    <div class="body">roticv,<br />You can use global &quot;local&quot; stack variables...<br />Somewhere in the begining<br /><strong>sub esp, 3*4</strong>  ; esp is your  &quot;12f000h&quot;<br />and then work with unbalanced stack to the end<br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-05-24 08:23:29 by lingo12</div>
   </div>
   <div class="post" id="post-104583">
    <div class="subject"><a href="#post-104583">Passing parameter to dlgproc</a></div>
    <div class="body">Nice idea lingo,<br />Why I did not think of it?<br />Thanks :alright:</div>
    <div class="meta">Posted on 2003-05-24 08:53:32 by roticv</div>
   </div>
   <div class="post" id="post-104591">
    <div class="subject"><a href="#post-104591">Passing parameter to dlgproc</a></div>
    <div class="body">roticv,<br />a few notes:<br />- you can substitute here slow LoadLibraryA / FreeLibrary<br /> with GetModuleHandle / user32.dll because it is always loaded<br />- you don't need GlobalAlloc/GlobalFree here because you can<br />use the stack too...with sub esp,100h*4<br />- next code is slow:<strong><br /> 	cmp	dword ptr , &quot;PteG&quot;<br />	jnz	V1_<br />	cmp	dword ptr , &quot;Acor&quot;<br />	jnz	V1_<br />	cmp	dword ptr , &quot;erdd&quot;<br />	....</strong><br />because <strong>dword ptr </strong> address isn't dword aligned<br />- you don't need <strong>call delta</strong> trick because you have <strong>offset EP</strong><br />- I hate slow xchg instruction and use it rarely (for instance in multithreading<br />programs)<br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-05-24 10:14:58 by lingo12</div>
   </div>
   <div class="post" id="post-104683">
    <div class="subject"><a href="#post-104683">Passing parameter to dlgproc</a></div>
    <div class="body">Anyway what is the size of the stack? I seem to get the error &quot;ERROR_NOT_ENOUGH_MEMORY (00000008)&quot;.</div>
    <div class="meta">Posted on 2003-05-25 03:42:57 by roticv</div>
   </div>
   <div class="post" id="post-104717">
    <div class="subject"><a href="#post-104717">Passing parameter to dlgproc</a></div>
    <div class="body">The default stack size is 1 MB. The linker rounds up the specified value to the nearest 4 bytes.</div>
    <div class="meta">Posted on 2003-05-25 10:17:34 by lingo12</div>
   </div>
   <div class="post" id="post-104718">
    <div class="subject"><a href="#post-104718">Passing parameter to dlgproc</a></div>
    <div class="body">Why not allocate enough memory using VirtualAlloc and pass the data in a structure, no need for a data section at all. You simple pass the pointer to memory that you have allocated and use the structure to access the individual elements. That way there is alos expandibility later,just add another element to the structure if you need it.</div>
    <div class="meta">Posted on 2003-05-25 10:23:21 by donkey</div>
   </div>
   <div class="post" id="post-104719">
    <div class="subject"><a href="#post-104719">Passing parameter to dlgproc</a></div>
    <div class="body"><div class="quote"><br />- I hate slow xchg instruction and use it rarely (for instance in multithreading programs)</div>Only the memory version of the instruction is slow.</div>
    <div class="meta">Posted on 2003-05-25 10:25:58 by bitRAKE</div>
   </div>
   <div class="post" id="post-104720">
    <div class="subject"><a href="#post-104720">Passing parameter to dlgproc</a></div>
    <div class="body">Ah donkey,<br />The problem is how you are going to pass the pointer to the dlgproc. I think the only way out is using a fixed location on the stack. Thus i did something like  (thanks to lingo for the idea)<br /><br /><pre><code><br /> 	mov		ecx, 12ffa0h<br /> 	xchg	esp,ecx<br /> 	mov		&#91;esp&#93;,eax<br /> 	mov		&#91;esp+4&#93;,ebx<br /> 	mov		&#91;esp+8&#93;,edx<br /> 	mov		&#91;esp+12&#93;,ecx<br /></code></pre><br /><br />And access the values by<br /><pre><code><br />	mov		edx,12ffa0h		;data on fixed location on the stack<br />	xchg	edx,esp<br />	mov		eax,&#91;esp&#93;;user32.dll<br />	mov		ebx,&#91;esp+4&#93;;getprocaddress<br />	mov		ecx,&#91;esp+8&#93;;Entrypoint<br />	xchg	esp,edx<br /></code></pre><br /><br />And restore the esp by<br /><pre><code>	mov		ecx,12ffa0h<br />	xchg	esp,ecx<br />	mov		ecx,&#91;esp+12&#93;<br />	mov		esp,ecx</code></pre><br /><br />Anyway lingo, the user32.dll is not loaded into the memory. Using GetModuleHandleA return the error ERROR_MOD_NOT_FOUND.</div>
    <div class="meta">Posted on 2003-05-25 10:32:00 by roticv</div>
   </div>
   <div class="post" id="post-104726">
    <div class="subject"><a href="#post-104726">Passing parameter to dlgproc</a></div>
    <div class="body">I dont have alot of time to study your source above.  So forgive me if im overlooking something here.  But i agree with Donkey.  Your making this very complicated (as im seing it).<br /><br /><ul>[*]Allocate memory for your three dwords your looking for (probably off the heap)<br />[*]Call you dialog window (CreateDialogIndirectParam, CreateDialogParam, DialogBoxIndirectParam, or DialogBoxParam), and pass in the last paramenter the pointer to the allocated memory.  The last parameter is user specific setup to your dialog when created. <em>&quot;Before displaying the dialog box, the function passes an application-defined value to the dialog box procedure as the lParam parameter of the WM_INITDIALOG message. An application can use this value to initialize dialog box controls. </em><br />[*]In the dialog proc, under WM_INITDIALOG, get the lParam, which is your passed address pointer.  Allocate heap memory for the dialog box (with a structure of some type) and store the pointer into this newly allocated memory.  Store this new memory pointer into the dialog window using SetWindowLong.<br />[*]Add dialog code to free the heap memory for when the dialog is destroyed.<br />[*]Add a global line in the dialog box to GetWindowLong on every entrance, to retrieve the local private memory to the dialog instance, and store this pointer and say EBX.  Now you can access the private memory easily in your dialog proc.<br />[*]When doing &quot;stuff&quot; in your dialog box, store the updated DWORD data both privately, and mirror it to the external heap as well, by using the stored pointer that was saved on the Init.  <br />[*]Now your dialog box is privately incapsulted, yet it also outputs externally any required 'dynamic' data to the shared memory that superceeds any dialog box.<br /><br /><br />Its alot to write out.  But its rather easy to implement.  I do a similar approach to custom controls.  If you look at my tutorial on this you will see actual sample code that stores init data into private memory that is local to each instance of the control (or in you case, dialog box).<br /><br />Mirroring your data out, instead of simply running from this external memory source is prefered, since the external routines can freely change the data without affecting the operation of your dialog box.  This keeps things &quot;safe&quot; since the system variables are read from only the internal private heap memory, and only reflects there values externally.  From here, the dialog box shouldnt care what happens to this data, before its re-updated by the dialog box.<br /><br /><br />Hope this helps..<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2003-05-25 11:20:41 by NaN</div>
   </div>
  </div>
 </body>
</html>