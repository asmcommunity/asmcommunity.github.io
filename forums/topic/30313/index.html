<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Register Arithmetic - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30313" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=117">Unix</a> &raquo; <a href="../?id=30313">Register Arithmetic</a></p>
   <div class="post" id="post-213493">
    <div class="subject"><a href="#post-213493">Register Arithmetic</a></div>
    <div class="body">This is the C Program<br /><pre><code><br />#include &lt;stdio.h&gt;<br />9<br />10 int main(void)<br />11 {<br />12 int w, x, y, z;<br />13<br />14 printf(&quot;Enter two integers: &quot;);<br />15 scanf(&quot;%i %i&quot;, &amp;w, &amp;x);<br />16 y = w + x;<br />17 z = w - x;<br />18 printf(&quot;sum = %i, difference = %i\n&quot;, y, z);<br />19<br />20 return 0;<br />21 }<br /></code></pre><br /><br />This is assembly written by Bob (text book author).<br /><br /><pre><code><br /><br />38 movl w(%rbp), %esi # y = w<br /><br />39 addl x(%rbp), %esi # y += x<br /><br />45 movl w(%rbp), %edx # z = w<br /><br />46 subl x(%rbp), %edx # z -= x<br /><br /></code></pre><br /> <br />And this is the ASM generated by GCC from the C program.<br /> <br /><pre><code><br />24 movl -4(%rbp), %edx # load w<br /><br />25 movl -8(%rbp), %eax # load x<br /><br />26 leal (%rdx,%rax), %eax # eax &lt;- w + x<br />27 movl %eax, -12(%rbp) # y = w + x;<br /><br />28 movl -4(%rbp), %edx # load w<br /><br />29 movl -8(%rbp), %eax # load x<br /><br />30 movl %edx, %ecx # ecx &lt;- w<br /><br />31 subl %eax, %ecx # eax &lt;- w - x<br /><br /></code></pre><br /><br />Its obvious the code generated by Bob is efficient more so than the GCC compiler. However, I don&#039;t understand why the calculations are different.<br />Does it have to do with the order of operations of the two different programs? Is it because on line 26 gcc performs addition on 64-bit registers then places the result in a 32-bit register? And how on earth is line 27 addition?</div>
    <div class="meta">Posted on 2010-11-19 15:10:39 by bray</div>
   </div>
   <div class="post" id="post-213496">
    <div class="subject"><a href="#post-213496">Re: Register Arithmetic</a></div>
    <div class="body">gcc abuses lea as an add with 3 operands. Lea is meant to calculate addresses, so it can use 64-bit registers only.<br />Line 27 is not an addition, it just copies the previously calculated w + x in eax to the y variable.<br /><br />gcc is apparently having some problems working around the limitation that you only have 3 volatile registers, namely eax, ecx and edx. All others need to be preserved. So it loads the variables from memory more than once.<br />I think it could be slightly smarter with the lea for example, by not re-using eax for the result, but using ecx (which would be the point of using lea instead of a normal add anyway, not overwriting one of your source operands). Then the second mov on line 29 could be skipped. Likewise the mov on line 30 makes no sense at all, it could have done subl %eax, %edx right away.<br />I would think that the latest gcc with the maximum optimization settings should produce something better than this.</div>
    <div class="meta">Posted on 2010-11-20 04:33:10 by Scali</div>
   </div>
   <div class="post" id="post-213505">
    <div class="subject"><a href="#post-213505">Re: Register Arithmetic</a></div>
    <div class="body">Hi Scali;<br /><br />So the results of the calculations differ than the text book source<br />because lea is required to use 64-bit registers? I may understand...<br />I&#039;ll try to elaborate.<br />On lines 24 and 25, w and x are loaded into edx and eax. Then leal takes<br />the entire 64-bit register and adds them together. Bob mixes his addl <br />mnemonic with both 64-bit and 32-bit registers. So is the result of the addition<br />different because of my premise that the addition of two 64-bit registers is <br />different than adding a 64-bit register to a 32-bit register?</div>
    <div class="meta">Posted on 2010-11-22 13:49:16 by bray</div>
   </div>
   <div class="post" id="post-213507">
    <div class="subject"><a href="#post-213507">Re: Register Arithmetic</a></div>
    <div class="body">I&#039;m not sure what you mean by &quot;the result of the calculations differ&quot;?<br /><br />I mean, the source code says this:<br />y = w + x;<br />z = w - x;<br /><br />The author&#039;s code does this:<br />y = w<br />y += x<br /><br />z = w<br />z -= x<br /><br />That is the same, is it not?<br /><br />And the gcc code does this:<br />y = w + x;<br />eax &lt;- w - x<br /><br />Now, there may be a line missing there, so we don&#039;t actually see eax being stored to z... but both pieces of code perform w + x and w - x, right?<br />They perform it in a different way, but I don&#039;t see how they would get different results?<br /><br /><div class="quote">Bob mixes his addl mnemonic with both 64-bit and 32-bit registers.</div><br /><br />In Bob&#039;s case, they are only used to address the variables on stack. It&#039;s indexed memory addressing. You always use 64-bit addresses in 64-bit mode.<br />In gcc&#039;s case, they use lea to perform an add, as stated before. The extra 32-bits can just be discarded, as they won&#039;t affect the result.</div>
    <div class="meta">Posted on 2010-11-22 15:16:38 by Scali</div>
   </div>
   <div class="post" id="post-213508">
    <div class="subject"><a href="#post-213508">Re: Register Arithmetic</a></div>
    <div class="body">Pardon me, the C program or its resultant assembly code, give different results in the case of an overflow.</div>
    <div class="meta">Posted on 2010-11-22 15:49:19 by bray</div>
   </div>
   <div class="post" id="post-213517">
    <div class="subject"><a href="#post-213517">Re: Register Arithmetic</a></div>
    <div class="body">I read up on the instruction and found that LEA does not check for overflow. Herp a derp. </div>
    <div class="meta">Posted on 2010-11-24 12:43:33 by bray</div>
   </div>
   <div class="post" id="post-216528">
    <div class="subject"><a href="#post-216528">Re: Register Arithmetic</a></div>
    <div class="body">None of this code checks for overflow...<br />There should be no difference...</div>
    <div class="meta">Posted on 2013-03-27 11:58:27 by Scali</div>
   </div>
  </div>
 </body>
</html>