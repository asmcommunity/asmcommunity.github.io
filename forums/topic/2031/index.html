<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>file compression - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=2031" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=2031">file compression</a></p>
   <div class="post" id="post-12968">
    <div class="subject"><a href="#post-12968">file compression</a></div>
    <div class="body">how do i write a program that compresses files like winzip</div>
    <div class="meta">Posted on 2001-11-25 05:12:44 by qwerty</div>
   </div>
   <div class="post" id="post-12969">
    <div class="subject"><a href="#post-12969">file compression</a></div>
    <div class="body">qwerty,<br /><br />The only code for compression I have seen in assembler is Jeremy Collake's code. Do a google search on PECOMPACT and you should find his site.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2001-11-25 05:16:06 by hutch--</div>
   </div>
   <div class="post" id="post-12979">
    <div class="subject"><a href="#post-12979">file compression</a></div>
    <div class="body"><pre><code><br />;###########################################################################<br />;###########################################################################<br />; ABOUT QC&#58;<br />;   Quick Compress is a program designed to be of use to programmers. It's<br />;   sole objective is to compress files for use as resources. The <br />;   progammer first compresses the file with QC then compiles it into the<br />;   resource script.<br />;<br />;   Then, at run time, the programmer uses the ExpandResource funtion to<br />;   de-compress the compressed file.  Expand file requires the actual file<br />;   size, the DEST name, and a resource's locked memory handle to operate.<br />;<br />;###########################################################################<br />; Program Info&#58;<br />;   The programmer must make sure the file size specified is correct <br />;   otherwise the file will be corrupted. The reason that this will<br />;   occurr is inproperly allocated memory.<br />;<br />;   This new version uses a LZ compression algorithm.<br />;<br />;###########################################################################<br />;###########################################################################<br /><br /><br />;###########################################################################<br />;###########################################################################<br />; THE COMPILER OPTIONS<br />;###########################################################################<br />;###########################################################################<br /><br />    .386<br />    .model flat, stdcall<br />    option casemap &#58;none   ; case sensitive<br /><br />;###########################################################################<br />;###########################################################################<br />; THE INCLUDES SECTION<br />;###########################################################################<br />;###########################################################################<br /><br />    include \masm32\include\windows.inc<br />    include \masm32\include\comctl32.inc<br />    include \masm32\include\comdlg32.inc<br />    include \masm32\include\shell32.inc<br />    include \masm32\include\user32.inc<br />    include \masm32\include\kernel32.inc<br />    include \masm32\include\gdi32.inc<br />    <br />    includelib \masm32\lib\comctl32.lib<br />    includelib \masm32\lib\comdlg32.lib<br />    includelib \masm32\lib\shell32.lib<br />    includelib \masm32\lib\gdi32.lib<br />    includelib \masm32\lib\user32.lib<br />    includelib \masm32\lib\kernel32.lib<br /><br />;###########################################################################<br />;###########################################################################<br />; LOCAL MACROS<br />;###########################################################################<br />;###########################################################################<br /><br />    szText MACRO Name, Text&#58;VARARG<br />        LOCAL lbl<br />        jmp lbl<br />        Name db Text,0<br />        lbl&#58;<br />    ENDM<br /><br />    m2m MACRO M1, M2<br />        push        M2<br />        pop     M1<br />      ENDM<br /><br />      return MACRO arg<br />        mov eax, arg<br />            ret<br />      ENDM<br /><br />    RGB MACRO red, green, blue<br />        xor eax,eax<br />        mov ah,blue<br />        shl eax,8<br />        mov ah,green<br />        mov al,red<br />    ENDM<br /><br />    hWrite MACRO handle, buffer, size<br />        mov edi, handle<br />        add edi, Dest_index<br />        mov ecx, 0<br />        mov cx, size<br />        add Dest_index, ecx<br />        mov esi, buffer<br />        movsb<br />    ENDM<br /><br />    hRead MACRO handle, buffer, size<br />        mov edi, handle<br />        add edi, Spot<br />        mov ecx, 0<br />        mov cx, size<br />        add Spot, ecx<br />        mov esi, buffer<br />        movsb<br />    ENDM<br /><br />;#################################################################################<br />;#################################################################################<br />; LOCAL PROTOTYPES<br />;#################################################################################<br />;#################################################################################<br /><br />    ;==================================<br />    ; Main Program Procedures<br />    ;==================================<br />    WinMain PROTO       &#58;DWORD,&#58;DWORD,&#58;DWORD,&#58;DWORD<br />    WndProc PROTO       &#58;DWORD,&#58;DWORD,&#58;DWORD,&#58;DWORD<br />    Open PROTO<br />    CompressFile PROTO<br />    ExpandFile PROTO<br />    Output PROTO        <br />    AboutProc PROTO         &#58;DWORD,&#58;DWORD,&#58;DWORD,&#58;DWORD<br />    MiscCenterWnd PROTO &#58;DWORD,&#58;DWORD<br />        <br />;#################################################################################<br />;#################################################################################<br />; BEGIN INITIALIZED DATA<br />;#################################################################################<br />;#################################################################################<br /><br />    .data<br />    <br />    ;================================================================<br />    ; HERE ARE THE STRUCTURES THAT WE WILL USE<br />    ;================================================================<br />        <br />        ;========================<br />        ; The HASH RECORD<br />        ;========================<br />    HASH_REC    STRUC<br />        next        dw  0   ;Prefix code<br />        char        db  0   ;Suffix char<br />    HASH_REC    ENDS<br /><br />    ;==============================<br />    ;Text for the Window Title<br />    ;==============================<br />        szDisplayName   db &quot;Quick Compress&quot;,0<br />      <br />    ;==============================<br />    ;Windows handles and Misc<br />    ;==============================<br />      CommandLine       dd 0    ; for the commandline params<br />      hRGN          dd 0    ; Handle to a region<br />      hOBJ          dd 0    ; Handle to an object<br />      hBRUSH        dd 0    ; Handle to the Brush<br />      hDC               dd 0    ; Handle to device context<br />        hMainWnd        dd 0  ; Handle to the main window<br />        hMenu           dd 0    ; Handle to the menu<br />      hWnd              dd 0    ; Handle to a second window<br />      hInst             dd 0    ; Handle to an Instance<br />      hIcon         dd 0    ; Handle to the icon<br />      hFile         dd 0    ; Handle to the file that we open<br />    Dest_index      dd 0    ; Holds the index into Dest mem<br />    Spot            dd 0    ; Holds offset into source for expand<br />    written     dd 0    ; Holds our output bytes<br />    hComp           dd 0    ; Holds icon's handle<br /><br />    ;========================================================<br />    ; For the Source &amp; Destination files used in Compression<br />    ;========================================================<br />      hSrc_Memory       dd 0    ; Handle to the source file's memory<br />      hDest_Memory  dd 0    ; Handle to the dest. file's memory<br />      Dest_Size     dd 0    ; Holds the true size of the dest file<br />    Src_Size        dd 0    ; Handle to the size of the source file<br />    Amount_Read     dd 0    ; Pointer to the amount read<br />    <br />    ;===============================<br />    ; Strings for the application<br />    ;===============================<br />    szClassName     db &quot;QC_Class&quot;,0<br />    NoHomePage      db &quot;Unable to open &#91;url&#93;www.fastsoftware.com&#91;/url&#93; homepage!&quot;,0<br />    Homepage        db &quot;Http&#58;//www.fastsoftware.com/&quot;,0<br />    OpenErr     db &quot;Unable to Open file!&quot;,0<br />    OutputErr       db &quot;Error Writing Compressed File!&quot;,0<br />    CompressErr     db &quot;Error Compressing File!&quot;,0<br />    szCompress      db &quot;Select a file to compress or expand!&quot;,0<br /><br />    HowUse      db &quot;Quick Compress is a compression program for programmers.&quot;,13,10<br />                db &quot;Simply compress any file of your choice.Then compile that&quot;,13,10<br />                db &quot;file into your resource file as RC_DATA.The next step is to&quot;,13,10<br />                db &quot;download the decompression routine from my web-site.Include&quot;,13,10<br />                db &quot;that file in your program, follow the directions for calling&quot;,13,10<br />                db &quot;and WOW! You have your own run-time decompression and a smaller&quot;,13,10<br />                db &quot;application than you probably deserve! Have fun. -Chris Hobbs&quot;,0<br /><br />    ;=======================================================<br />    ; To open a file<br />    ;=======================================================<br />    szFile      db 800 dup&#40;0&#41;<br />    szFileTitle     db 800 dup&#40;0&#41;<br />    ofn OPENFILENAME &lt;SIZEOF&#40;OPENFILENAME&#41;, NULL, NULL,\<br />                OFFSET szOpenFilter, NULL, NULL, 1h, OFFSET szFile,\<br />                800, OFFSET szFileTitle, 800, NULL, NULL,\<br />                OFN_PATHMUSTEXIST,0, 0, 0, 0, 0, 0&gt;<br /><br />    ;=====================================================<br />    ;Initialize the Font structure for generic app then<br />    ; change what is necessary before calls<br />    ;=====================================================<br />    Font    LOGFONT &lt;14,0,0,0,FW_NORMAL,\<br />                0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\<br />                CLIP_STROKE_PRECIS,DEFAULT_QUALITY,\<br />                DEFAULT_PITCH or FF_SWISS,&quot;MS Sans Serif&quot;&gt;<br /><br />;#################################################################################<br />;#################################################################################<br />; BEGIN CONSTANTS<br />;#################################################################################<br />;#################################################################################<br /><br />szOpenFilter    SBYTE   &quot;All Files &#40;*.*&#41;&quot;,0,&quot;*.*&quot;,0,0<br />szSaveFilter    SBYTE   &quot;QC Files &#40;*.qck&#41;&quot;,0,&quot;*.qck&quot;,0,0<br />szDefExt        SBYTE &quot;qck&quot;,0<br /><br />;#################################################################################<br />;#################################################################################<br />; BEGIN EQUATES<br />;#################################################################################<br />;#################################################################################<br /><br />    ;=================<br />    ;Utility Equates<br />    ;=================<br />FALSE       equ 0<br />TRUE        equ 1<br /><br />    ;================<br />    ; resource IDs<br />    ;================<br />IDI_COMP    equ 400<br />IDI_ICON    equ 500<br />IDM_MENU    equ 600<br />IDD_ABOUT   equ 700<br /><br />    ;================<br />    ; Menu ID's<br />    ;================<br />IDM_COMPRESS    equ 1000<br />IDM_EXPAND      equ 1100<br />IDM_EXIT        equ 1500<br />IDM_HOW     equ 3400<br />IDM_ABOUT       equ 3500<br /><br />    ;======================<br />    ; Compression equates<br />    ;======================<br />CLEAR           equ 256<br />EOF         equ 257<br />FIRST_FREE      equ 258<br />MAX_MAX     equ 4096<br /><br />;#################################################################################<br />;#################################################################################<br />; BEGIN THE CODE SECTION<br />;#################################################################################<br />;#################################################################################<br /><br />  .code<br /><br />start&#58;<br />    invoke GetModuleHandle, NULL<br />    mov hInst, eax<br /><br />    invoke GetCommandLine<br />    mov CommandLine, eax<br /><br />    invoke WinMain,hInst,NULL,CommandLine,SW_SHOWDEFAULT<br />    invoke ExitProcess,eax<br /><br />;#########################################################################<br /><br />WinMain proc hInstance  &#58;DWORD,<br />        hPrevInst   &#58;DWORD,<br />        CmdLine &#58;DWORD,<br />        CmdShow &#58;DWORD<br /><br />    ;====================<br />    ; Put LOCALs on stack<br />    ;====================<br /><br />    LOCAL wc   &#58;WNDCLASSEX<br />    LOCAL msg  &#58;MSG<br />    <br />    LOCAL B_RECT    &#58;RECT      ; a rectangle struct<br />    LOCAL hFONT     &#58;DWORD   ; handle to the font<br />    LOCAL Wwd       &#58;DWORD<br />    LOCAL Wht       &#58;DWORD<br />    LOCAL Wtx       &#58;DWORD<br />    LOCAL Wty       &#58;DWORD<br /><br />    ;==================================================<br />    ; Fill WNDCLASSEX structure with required variables<br />    ;==================================================<br /><br />    mov wc.cbSize,sizeof WNDCLASSEX<br />    mov wc.style,CS_HREDRAW or CS_VREDRAW \<br />                or CS_BYTEALIGNWINDOW<br />    mov wc.lpfnWndProc,offset WndProc<br />    mov wc.cbClsExtra,NULL<br />    mov wc.cbWndExtra,NULL<br />    m2m wc.hInstance,hInst   ;&lt;&lt; NOTE&#58; macro not mnemonic<br />    mov wc.hbrBackground,COLOR_BACKGROUND<br />    mov wc.lpszMenuName,NULL<br />    mov wc.lpszClassName,offset szClassName<br />    invoke LoadIcon,hInst,IDI_ICON    ; icon ID<br />    mov hIcon,eax<br />    mov wc.hIcon,eax<br />    invoke LoadCursor,NULL,IDC_ARROW<br />    mov wc.hCursor,eax<br />    mov wc.hIconSm,0<br /><br />    invoke RegisterClassEx, ADDR wc<br /><br />    ;================================<br />    ; Create window at following size<br />    ;================================<br />      mov   Wwd, 250<br />      mov   Wht, 200<br />    <br />    ;===========================================<br />    ; Create the main screen<br />    ;===========================================<br />    invoke CreateWindowEx,NULL,<br />                    ADDR szClassName,<br />                              ADDR szDisplayName,<br />                              WS_POPUP or WS_SYSMENU or\<br />                              WS_MINIMIZEBOX or WS_CAPTION,<br />                              Wtx,Wty,Wwd,Wht,<br />                              NULL,NULL,<br />                              hInst,NULL<br />        <br />    ;===========================================<br />    ; Put the window handle in for future uses <br />    ;===========================================<br />    mov hMainWnd,eax<br /><br />    ;============================================<br />    ;Load the menu<br />    ;============================================<br />    invoke LoadMenu,hInst,IDM_MENU  ; menu ID<br />    mov hMenu, eax<br />    invoke SetMenu,hMainWnd,hMenu<br /><br />    ;================================<br />    ; Load the icon<br />    ;================================<br />    ;=================================<br />    ; Load all of the icons<br />    ;=================================<br />    invoke LoadIcon,hInst,IDI_COMP      ; icon ID<br />    mov hComp,eax<br /><br />    ;================================<br />    ; Show the window<br />    ;================================<br />      invoke ShowWindow,hMainWnd,SW_SHOWNORMAL<br />      invoke UpdateWindow,hMainWnd<br /><br />    ;================================<br />    ; Center window at following size<br />    ;================================<br />    invoke GetDesktopWindow<br />    invoke MiscCenterWnd, hMainWnd, eax <br /><br />    ;===================================<br />    ; Loop until PostQuitMessage is sent<br />    ;===================================<br />  <br />    StartLoop&#58;<br />        invoke GetMessage,ADDR msg,NULL,0,0<br />          cmp eax, 0<br />        je ExitLoop<br />        invoke TranslateMessage, ADDR msg<br />        invoke DispatchMessage,  ADDR msg<br />        jmp StartLoop<br />    ExitLoop&#58;<br /><br />    return msg.wParam<br /><br />WinMain endp<br /><br />;#########################################################################<br /><br />WndProc proc hWin   &#58;DWORD,<br />         uMsg   &#58;DWORD,<br />             wParam &#58;DWORD,<br />             lParam &#58;DWORD<br /><br />;========================================<br />; LOCAL VARIABLES<br />;=========================================<br /><br />.if uMsg == WM_COMMAND<br />  ;======== menu commands ========<br />    .if wParam == IDM_COMPRESS<br />        ;==The open and compress code===<br /><br />            ;========================<br />        ; Get the open file name<br />        ;========================<br />        mov eax, offset szOpenFilter<br />        mov ofn.lpstrFilter, eax<br />        mov ofn.lpstrDefExt, NULL<br />        invoke GetOpenFileName, ADDR ofn<br /><br />        ;========================<br />        ; Test for file<br />        ;========================<br />        .if &#40;eax&#41;<br />            ;========================<br />            ; jump to open code<br />            ;========================<br />            invoke Open<br />                <br />            ;========================<br />            ; Test for an error<br />            ;========================<br />            .if eax == 0<br />        <br />                ;==================<br />                ; Give error msg<br />                ;==================<br />                invoke MessageBox, hWin, ADDR OpenErr,\<br />                    NULL,MB_OK          <br />                    <br />                return 0<br /><br />            .endif<br /><br />            ;============================<br />            ; We were good so compress<br />            ;============================<br />            invoke CompressFile<br /><br />            ;===========================<br />            ; Test for an error<br />            ;===========================<br />            .if eax == 0<br />                ;===================<br />                ; Give Message<br />                ;===================<br />                invoke MessageBox, hWin, ADDR CompressErr,\<br />                    NULL,MB_OK          <br /><br />                return 0<br /><br />            .endif<br /><br />            ;==========================<br />            ; Now write the file out<br />            ;==========================<br />            mov eax, offset szSaveFilter<br />            mov ofn.lpstrFilter, eax<br />            mov eax, offset szDefExt<br />            mov ofn.lpstrDefExt, eax<br />            invoke Output<br />    <br />            ;===========================<br />            ; Test for an error<br />            ;===========================<br />            .if eax == 0<br />                ;===================<br />                ; Give Message<br />                ;===================<br />                invoke MessageBox, hWin, ADDR OutputErr,\<br />                    NULL,MB_OK          <br /><br />            .endif<br /><br />            ;===============================<br />            ; Release the allocated memory<br />            ;===============================<br />            invoke GlobalFree, hSrc_Memory<br />            invoke GlobalFree, hDest_Memory<br /><br />        .endif<br /><br />    .elseif wParam == IDM_EXPAND<br />        ;==The open and compress code===<br /><br />            ;========================<br />        ; Get the open file name<br />        ;========================<br />        mov eax, offset szOpenFilter<br />        mov ofn.lpstrFilter, eax<br />        mov ofn.lpstrDefExt, NULL<br />        invoke GetOpenFileName, ADDR ofn<br /><br />        ;========================<br />        ; Test for file<br />        ;========================<br />        .if &#40;eax&#41;<br />            ;========================<br />            ; jump to open code<br />            ;========================<br />            invoke Open<br />                <br />            ;========================<br />            ; Test for an error<br />            ;========================<br />            .if eax == 0<br />        <br />                ;==================<br />                ; Give error msg<br />                ;==================<br />                invoke MessageBox, hWin, ADDR OpenErr,\<br />                    NULL,MB_OK          <br />                    <br />                return 0<br /><br />            .endif<br /><br /><br />            ;============================<br />            ; We were good so expand<br />            ;============================<br />            invoke ExpandFile<br /><br />            ;===========================<br />            ; Test for an error<br />            ;===========================<br />            .if eax == 0<br />                ;===================<br />                ; Give Message<br />                ;===================<br />                invoke MessageBox, hWin, ADDR CompressErr,\<br />                    NULL,MB_OK          <br /><br />                return 0<br />            .endif<br /><br />            ;==========================<br />            ; Now write the file out<br />            ;==========================<br />            mov ofn.lpstrFilter, NULL<br />            mov ofn.lpstrDefExt, NULL<br />            invoke Output<br /><br />            ;===========================<br />            ; Test for an error<br />            ;===========================<br />            .if eax == 0<br />                ;===================<br />                ; Give Message<br />                ;===================<br />                invoke MessageBox, hWin, ADDR OutputErr,\<br />                    NULL,MB_OK          <br /><br />            .endif<br /><br />            ;===============================<br />            ; Release the allocated memory<br />            ;===============================<br />            invoke GlobalFree, hSrc_Memory<br />            invoke GlobalFree, hDest_Memory<br /><br />        .endif<br /><br />      .elseif wParam == IDM_EXIT<br />        ;===========================<br />        ; THIS IS THE FILE-EXIT<br />        ;===========================<br />            invoke SendMessage,hWin,WM_SYSCOMMAND,SC_CLOSE,NULL<br />    <br />    .elseif wParam == IDM_HOW<br />        ;============================<br />        ; This will tell the user <br />        ; how to use it<br />        ;============================<br />        invoke MessageBox, hMainWnd, ADDR HowUse,ADDR szDisplayName,MB_OK           <br />            <br />      .elseif wParam == IDM_ABOUT<br />        ;===========================<br />        ;THIS IS THE HELP-ABOUT<br />        ;===========================<br />        invoke DialogBoxParam, hInst, IDD_ABOUT, hMainWnd, ADDR AboutProc, NULL<br /> <br />      .endif<br />  ;====== end menu commands ======<br />.elseif uMsg == WM_PAINT<br />    ;============================<br />    ; get the DC<br />    ;============================<br />    invoke GetDC, hMainWnd<br />    mov hDC, eax<br />    <br />    ;============================<br />    ; Set text and bkgnd mode<br />    ;============================<br />    invoke SetTextColor, hDC, 00000000h<br />    invoke SetBkMode, hDC, TRANSPARENT<br /><br />    ;============================<br />    ; Output the text<br />    ;============================<br />    invoke TextOut,hDC,5,30,ADDR szCompress,SIZEOF szCompress - 1<br />    <br />    ;======================================================<br />    ; Draw the Icon as an image at the specified location<br />    ;======================================================<br />    invoke DrawIconEx,hDC,85,60,hComp,64,64,NULL,\<br />            NULL,DI_NORMAL<br /><br />    ;================================<br />    ; release the device context<br />    ;================================<br />    invoke ReleaseDC, hMainWnd, hDC<br />  <br />.elseif uMsg == WM_DESTROY<br />    ;===========================<br />    ; Kill the application<br />    ;===========================<br />    invoke PostQuitMessage,NULL<br />    return 0 <br /> <br />.endif<br /><br />invoke DefWindowProc,hWin,uMsg,wParam,lParam<br /><br />ret<br /><br />WndProc endp<br />;########################################################################<br />; End of Main Windows Callback Procedure<br />;########################################################################<br /><br />;########################################################################<br />;########################################################################<br />; MY FUNCTIONS<br />;########################################################################<br />;########################################################################<br /><br />;########################################################################<br />; Open Function<br />;########################################################################<br />Open proc<br />    <br />    ;================================================<br />    ; Code to open the document and read into mem<br />    ;================================================<br /><br />    ;=================================<br />    ; Create the file<br />    ;=================================<br />    invoke CreateFile, offset szFile, GENERIC_READ or GENERIC_WRITE, \<br />        FILE_SHARE_READ, NULL,OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,NULL<br />    mov hFile, eax<br /><br />    ;===============================<br />    ; Test for an error<br />    ;===============================<br />    .if eax == INVALID_HANDLE_VALUE<br />        jmp err<br />    .endif<br /><br />    ;===============================<br />    ; Get the file size<br />    ;===============================<br />    invoke GetFileSize, hFile, NULL<br />    mov Src_Size, eax<br /><br />    ;================================<br />    ; test for an error<br />    ;================================<br />    .if eax == -1<br />        jmp err<br />    .endif<br /><br />    ;==============================================<br />    ; Allocate enough memeory to hold the file<br />    ;==============================================<br />    invoke GlobalAlloc, GMEM_FIXED, Src_Size<br />    mov hSrc_Memory, eax<br />    mov Spot, 0<br /><br />    ;===================================<br />    ; test for an error<br />    ;===================================<br />    .if eax == 0<br />        jmp err<br />    .endif<br /><br />    ;==============================================<br />    ; Allocate worst case scenario memory<br />    ; for compression program<br />    ;==============================================<br />    mov eax, Src_Size<br />    shl eax, 4<br />    invoke GlobalAlloc, GMEM_FIXED, eax<br />    mov hDest_Memory, eax<br />    mov Dest_index, 0<br /><br />    ;===============================<br />    ; test for an error<br />    ;===============================<br />    .if eax == 0<br />        jmp err<br />    .endif<br /><br />    ;===================================<br />    ; Put the file into memory<br />    ;===================================<br />    invoke ReadFile, hFile, hSrc_Memory, Src_Size, offset Amount_Read, NULL<br /><br />    ;===============================<br />    ; test for an error<br />    ;===============================<br />    .if eax == 0<br />        jmp err<br />    .endif<br /><br />    ;============================<br />    ; Close the handle<br />    ;============================<br />    invoke CloseHandle,hFile<br /><br />done&#58;<br />    return 1<br /><br />err&#58;<br />    ;============================<br />    ; Close the handle<br />    ;============================<br />    invoke CloseHandle,hFile<br /><br />    return 0    <br />         <br />Open endp<br />;########################################################################<br />; END of Open                   <br />;########################################################################<br /><br />;########################################################################<br />; CompressFile Function<br />;########################################################################<br />CompressFile proc<br />    <br />    ;=====================================<br />    ; Code to compress the chosen file<br />    ;=====================================<br /><br />    ;=====================================<br />    ; define all of the local variables<br />    ;=====================================<br />    LOCAL   Buf_Count&#58;BYTE<br />    LOCAL   Char&#58;BYTE<br />    LOCAL index&#58;BYTE<br />    LOCAL Prev_Char1&#58;BYTE<br />    LOCAL Prev_Char2&#58;BYTE<br />    LOCAL Bit_Mask&#58;BYTE<br />    LOCAL pcTable&#58;DWORD<br />    LOCAL Num_In_Mask&#58;BYTE<br /><br />    ;======================================<br />    ; Allocate memory for our table<br />    ;======================================<br />    invoke GlobalAlloc, GMEM_FIXED, 32768<br />    mov pcTable, eax<br /><br />    ;========================================<br />    ; Set to ascii 32 because it's most used<br />    ;=========================================<br />    invoke RtlFillMemory, pcTable, 32768, 20h<br /><br />    ;=====================================<br />    ; Initialize file vars just in case<br />    ;=====================================<br />    mov Dest_index, 0<br />    mov Spot, 0<br />    mov Bit_Mask, 0<br />    mov Prev_Char1, 0<br />    mov Prev_Char2, 0<br />    mov Num_In_Mask, 0<br />    mov Buf_Count, 0<br />    <br />    ;======================================<br />    ; get the byte from file<br />    ;======================================<br />    jmp tstEOF<br />top&#58;    mov ebx, hSrc_Memory<br />    add ebx, Spot<br />    mov al, BYTE PTR &#91;ebx&#93;<br />    mov Char, al<br />    inc Spot<br /><br />    ;================================<br />    ; Aren't done so try and predict<br />    ; the character<br />    ;================================<br />    mov bl, Prev_Char1<br />    mov bh, 0<br />    mov dl, Prev_Char2<br />    mov dh, 0<br />    shl bx, 7<br />    xor bx, dx<br />    push    bx<br />    xor ebx, ebx<br />    pop bx<br />    mov eax, pcTable<br />    add eax, ebx<br />    mov cl, BYTE PTR &#91;eax&#93;<br />    mov al, Char<br /><br />    ;==============================<br />    ; Was the prediction correct    <br />    ;==============================<br />    .if al == cl<br />        ;===================<br />        ; Yes, we did it so<br />        ; adjust mask<br />        ;===================<br />        mov al,1<br />        mov cl, Num_In_Mask<br />        shl al, cl<br />        xor al, Bit_Mask<br />        mov Bit_Mask, al<br />        <br />    .else<br />        ;==========================<br />        ; We were wrong this time<br />        ; so update the table<br />        ;==========================<br />        mov bl, Prev_Char1<br />        mov bh, 0<br />        mov dl, Prev_Char2<br />        mov dh, 0<br />        shl bx, 7<br />        xor bx, dx<br />        push    bx<br />        xor ebx, ebx<br />        pop bx<br />        mov eax, pcTable<br />        add eax, ebx<br />        mov dx, 0<br />        mov dl, Char<br />        mov cl, BYTE PTR &#91;eax&#93;<br />        mov BYTE PTR &#91;eax&#93;, dl<br /><br />        ;=============================<br />        ; Put character in buffer<br />        ;=============================<br />        push    dx<br />        inc Buf_Count<br /><br />    .endif<br />            <br />    ;===========================================<br />    ; Inc Num in mask and test for full status<br />    ;===========================================<br />    inc Num_In_Mask<br />    <br />    .if Num_In_Mask == 8<br />        ;========================<br />        ; Write out the mask<br />        ;========================<br />        mov ebx, hDest_Memory<br />        add ebx, Dest_index<br />        mov cl, Bit_Mask<br />        mov BYTE PTR &#91;ebx&#93;, cl<br />        inc Dest_index<br /><br />        ;=============================<br />        ; Setup to write what we kept<br />        ;=============================<br />        mov index, 0<br />        xor ecx, ecx<br />        mov cl, Buf_Count<br />        mov edx, Dest_index<br />        add Dest_index, ecx<br />    write&#58;<br />        .if cl &gt; 0<br />            ;=========================<br />            ; Actual write<br />            ;=========================<br />            mov ebx, hDest_Memory<br />            add ebx, edx<br />            add ebx, ecx<br />            dec ebx<br />            pop ax<br />            mov BYTE PTR &#91;ebx&#93;, al<br />            dec cl<br />            jmp write<br /><br />        .endif<br /><br />        ;============================<br />        ; Reset the variables we used<br />        ;============================<br />        mov Num_In_Mask, 0<br />        mov Buf_Count, 0<br />        mov Bit_Mask, 0<br />    <br />    .endif<br /><br />    ;==============================<br />    ; Shift the characters<br />    ;==============================<br />    mov al, Prev_Char2<br />    mov bl, Char<br />    mov Prev_Char2, bl<br />    mov Prev_Char1, al<br /><br />tstEOF&#58;<br />    ;============================<br />    ; test for over file<br />    ;============================<br />    mov eax, Spot<br />    .if eax &gt; Src_Size<br />        jmp check<br />    .endif<br /><br />    ;=============================<br />    ; Jump up and do it again<br />    ;=============================<br />    jmp top<br /><br />check&#58;<br />    ;=============================<br />    ; We hit eof but stuff could<br />    ; be in the buffer still<br />    ;=============================<br />    .if Num_In_Mask !=0<br />        ;========================<br />        ; Write out the mask<br />        ;========================<br />        mov ebx, hDest_Memory<br />        add ebx, Dest_index<br />        mov cl, Bit_Mask<br />        mov BYTE PTR &#91;ebx&#93;, cl<br />        inc Dest_index<br />    <br />        ;=============================<br />        ; Setup to write what we kept<br />        ;=============================<br />        mov index, 0<br />        xor ecx, ecx<br />        mov cl, Buf_Count<br />        mov edx, Dest_index<br />        add Dest_index, ecx<br />        dec Dest_index<br />        dec Dest_index<br />    write2&#58;<br />        .if cl &gt; 0<br />            ;=========================<br />            ; Actual write<br />            ;=========================<br />            mov ebx, hDest_Memory<br />            add ebx, edx<br />            add ebx, ecx<br />            dec ebx<br />            pop ax<br />            mov BYTE PTR &#91;ebx&#93;, al<br />            dec cl<br />            jmp write2<br />    <br />        .endif<br />    <br />    <br />    .endif<br /><br />done&#58;<br />    ;===============================<br />    ; Free the memory we used<br />    ;===============================<br />    invoke GlobalFree, pcTable<br /><br />    return 1<br />err&#58;<br />    return 0    <br />         <br />CompressFile endp<br />;########################################################################<br />; END of CompressFile                   <br />;########################################################################<br /><br />;########################################################################<br />; ExpandFile Function<br />;########################################################################<br />ExpandFile proc<br />    <br />    ;=====================================<br />    ; Code to decompress the chosen file<br />    ;=====================================<br /><br />    ;=====================================<br />    ; define all of the local variables<br />    ;=====================================<br />    LOCAL   Char_In&#58;BYTE<br />    LOCAL Char_Out&#58;BYTE<br />    LOCAL Prev_Char1&#58;BYTE<br />    LOCAL Prev_Char2&#58;BYTE<br />    LOCAL Bit_Mask&#58;BYTE<br />    LOCAL pcTable&#58;DWORD<br />    LOCAL Num_In_Mask&#58;BYTE<br /><br />    ;======================================<br />    ; Allocate memory for our table<br />    ;======================================<br />    invoke GlobalAlloc, GMEM_FIXED,  32768<br />    mov pcTable, eax<br /><br />    ;========================================<br />    ; Set to ascii 32 because it's most used<br />    ;=========================================<br />    invoke RtlFillMemory, pcTable, 32768, 20h<br /><br />    ;=====================================<br />    ; Initialize file vars just in case<br />    ;=====================================<br />    mov Dest_index, 0<br />    mov Spot, 0<br />    mov Bit_Mask, 0<br />    mov Prev_Char1, 0<br />    mov Prev_Char2, 0<br />    mov Num_In_Mask, 0<br /><br />    ;======================================<br />    ; get the byte from file<br />    ;======================================<br />    jmp tstEOF<br />top&#58;    mov eax, Spot<br />    .if eax &lt;= Src_Size<br />        mov ebx, hSrc_Memory<br />        add ebx, Spot<br />        mov al, BYTE PTR &#91;ebx&#93;<br />        mov Char_In, al<br />        inc Spot<br />        <br />    .endif<br /><br />    ;==================================<br />    ; Put it into the mask for the loop<br />    ;===================================<br />    mov Bit_Mask, al<br /><br />    ;====================================<br />    ; Loop for every bit in the mask<br />    ;====================================<br />    mov Num_In_Mask, 0<br />msk&#58;<br />    cmp Num_In_Mask, 8<br />    je  StopFor<br /><br />    ;====================================<br />    ; Find out if we predicted this char<br />    ;====================================<br />    mov al, Bit_Mask<br />    mov dx, 1<br />    mov cl, Num_In_Mask<br />    mov ah, 0<br />    shl dx, cl<br />    test    ax,dx<br />    je  notpred<br /><br />    ;===================================<br />    ; Yes, we predicted it, so process<br />    ;===================================<br />    mov bl, Prev_Char1<br />    mov bh, 0<br />    mov dl, Prev_Char2<br />    mov dh, 0<br />    shl bx, 7<br />    xor bx, dx<br />    push    bx<br />    xor ebx, ebx<br />    pop bx<br />    mov eax, pcTable<br />    add eax, ebx<br />    mov cl, BYTE PTR &#91;eax&#93;<br />    mov Char_Out, cl<br /><br />    ;=============================<br />    ; Jump over not pred<br />    ;=============================<br />    jmp donepred        <br /><br /><br />    ;===============================<br />    ; We didn't predict this one<br />    ;===============================<br />notpred&#58;<br />    ;=============================<br />    ; Read in the character we<br />    ; will write out<br />    ;=============================<br />    mov eax, Spot<br />    .if eax &lt;= Src_Size<br />        mov ebx, hSrc_Memory<br />        add ebx, Spot<br />        mov cl, BYTE PTR &#91;ebx&#93;<br />        mov Char_Out, cl<br />        inc Spot<br /><br />    .endif<br />        <br />    ;============================<br />    ; Update the table<br />    ;============================   <br />    mov bl, Prev_Char1<br />    mov bh, 0<br />    mov dl, Prev_Char2<br />    mov dh, 0<br />    shl bx, 7<br />    xor bx, dx<br />    push    bx<br />    xor ebx, ebx<br />    pop bx<br />    mov eax, pcTable<br />    add eax, ebx<br />    mov cl, Char_Out<br />    mov BYTE PTR &#91;eax&#93;, cl<br />    <br />donepred&#58;<br />    ;=============================<br />    ; Write the character out to<br />    ; our destination memory<br />    ;=============================<br />    mov ebx, hDest_Memory<br />    add ebx, Dest_index<br />    mov cl, Char_Out<br />    mov BYTE PTR &#91;ebx&#93;, cl<br />    inc Dest_index<br /><br />    ;=============================<br />    ; Shift the characters over<br />    ;=============================<br />    mov al, Prev_Char2<br />    mov bl, Char_Out<br />    mov Prev_Char2, bl<br />    mov Prev_Char1, al<br /><br />    ;==========================<br />    ; Inc and go back to mask<br />    ; processing<br />    ;==========================<br />    inc Num_In_Mask<br />    jmp msk <br /><br />    ;===========================<br />    ; Get another byte and do <br />    ; it again<br />    ;===========================<br />StopFor&#58;<br /><br />    ;=============================<br />    ; Test to see if we are over<br />    ; limit for source<br />    ;=============================<br />tstEOF&#58;<br />    mov eax, Spot<br />    .if eax &gt;= Src_Size<br />        jmp done<br />    .endif<br /><br /><br />    jmp top<br /><br />done&#58;<br />    ;===============================<br />    ; Free the memory we used<br />    ;===============================<br />    invoke GlobalFree, pcTable<br /><br />    return 1<br /><br />err&#58;<br />    return 0    <br />         <br />ExpandFile endp<br />;########################################################################<br />; END of ExpandFile                 <br />;########################################################################<br /><br />;########################################################################<br />; Output Function<br />;########################################################################<br />Output proc<br />    <br />    ;=====================================<br />    ; Code to save file out<br />    ;=====================================<br /><br />    ;======================================<br />    ; Setup the filename to write out to<br />    ;======================================<br />    invoke GetSaveFileName, ADDR ofn<br />    <br />    ;==========================<br />    ; End if they cancel<br />    ;==========================<br />    .if eax == 0<br />        jmp done<br />    .endif<br /><br />    ;======================================<br />    ; Create the file to write to<br />    ;======================================<br />    invoke CreateFile, offset szFile, GENERIC_READ or GENERIC_WRITE, \<br />        FILE_SHARE_READ, NULL,OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL,NULL<br />    mov hFile, eax<br /><br />    ;===============================<br />    ; Test for an error<br />    ;===============================<br />    .if eax == INVALID_HANDLE_VALUE<br />        jmp err<br />    .endif<br /><br />    ;======================================<br />    ; Write to the file<br />    ;======================================<br />    invoke WriteFile, hFile, hDest_Memory, Dest_index, offset written, NULL<br /><br />    ;======================================<br />    ; Test for an error<br />    ;======================================<br />    .if eax == 0<br />        ;=========================<br />        ; Jump to error<br />        ;=========================<br />        jmp err<br /><br />    .endif<br /><br />    ;======================================<br />    ; Close the handle to the file<br />    ;======================================<br />    invoke CloseHandle, hFile<br /><br />done&#58;<br />    return 1<br /><br />err&#58;<br />    return 0    <br />         <br />Output endp<br />;########################################################################<br />; END of Output                 <br />;########################################################################<br /><br />;########################################################################<br />; Handle the about box<br />;########################################################################<br />AboutProc proc hDlg   &#58;DWORD,<br />           uMsg   &#58;DWORD,<br />               wParam &#58;DWORD,<br />               lParam &#58;DWORD<br />    <br />    ;=================================<br />    ; The equate for the homepage code<br />    ;=================================<br />    IDHOME  equ 2<br /><br />    ;=========================<br />    ; Get the message into eax<br />    ;=========================<br />    mov eax, uMsg<br />    .IF &#40;eax == WM_INITDIALOG&#41;<br />        invoke MiscCenterWnd, hDlg, hMainWnd<br /><br />    .ELSEIF &#40;eax == WM_COMMAND&#41; &amp;&amp; &#40;wParam == IDOK&#41; <br />        invoke EndDialog, hDlg, TRUE<br /><br />    .ELSEIF &#40;eax == WM_COMMAND&#41; &amp;&amp; &#40;wParam == IDHOME&#41;<br />        invoke EndDialog, hDlg, TRUE<br /><br />        ;===================================<br />        ; Execute our homepage<br />        ;===================================<br />        invoke ShellExecute,0,0,ADDR Homepage,0,0,0<br /><br />        .if eax &lt;= 32<br />            ;======================<br />            ; Tell them we can't <br />            ; open the homepage<br />            ;======================<br />            invoke MessageBox, hMainWnd, offset NoHomePage, NULL, MB_OK<br /><br />        .endif<br /><br />    .ELSE<br />        mov eax, FALSE  ; show message not processed<br />        jmp Return<br />    .ENDIF<br />    mov eax, TRUE       ; show message was processed<br />    <br />    Return&#58; ret<br /><br />AboutProc endp<br />;########################################################################<br />; END ABOUTPROC<br />;########################################################################<br /><br />;########################################################################<br />; Misc Center Window from SIB by Steve Gibson. Thanks Steve!                    <br />;########################################################################<br />MiscCenterWnd proc hChild&#58;DWORD,<br />             hParent&#58;DWORD<br /><br />        ; Define the local variables<br />        LOCAL   rcP&#58;RECT, rcC&#58;RECT, xNew&#58;DWORD, yNew&#58;DWORD<br /><br />invoke  GetWindowRect, hParent, ADDR rcP<br /><br />.IF &#40;eax&#41;<br />    invoke  GetWindowRect, hChild, ADDR rcC<br />    .IF &#40;eax&#41;<br />        mov eax, rcP.right  ;center horizontally<br />        sub eax, rcP.left   ;x=Px+&#40;Pdx-Cdx&#41;/2<br />        sub eax, rcC.right<br />        add eax, rcC.left<br />        sar eax, 1<br />        add eax, rcP.left<br />    <br />        ; check if off screen at left<br />        .IF &#40;sign?&#41;<br />            mov eax, 0<br />        .ENDIF<br />        mov xNew, eax<br /><br />        invoke  GetSystemMetrics, SM_CXFULLSCREEN<br />        sub eax, rcC.right<br />        add eax, rcC.left<br />        <br />        ; check if off screen at right<br />        .IF &#40;eax &lt; xNew&#41;    <br />            mov xNew, eax<br />        .ENDIF<br /><br />        mov eax, rcP.bottom ; center vertically<br />        sub eax, rcP.top    ; y=Py+&#40;Pdy-Cdy&#41;/2<br />        sub eax, rcC.bottom<br />        add eax, rcC.top<br />        sar eax, 1<br />        add eax, rcP.top<br /><br />        ; check if off screen at top<br />        .IF &#40;sign?&#41;     <br />            mov eax, 0<br />        .ENDIF<br />        mov yNew,eax<br /><br />        invoke  GetSystemMetrics, SM_CYFULLSCREEN<br />        sub eax, rcC.bottom<br />        add eax, rcC.top<br />        .IF &#40;eax &lt; yNew&#41;<br />            mov yNew, eax<br />        .ENDIF<br /><br />        invoke  SetWindowPos, hChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE + SWP_NOZORDER<br /><br />    .ENDIF<br />.ENDIF<br /><br />Return&#58; ret<br /><br />MiscCenterWnd   ENDP<br />;########################################################################<br />; END MISC CENTER WINDOW<br />;########################################################################<br /><br />;######################################<br />; THIS IS THE END OF THE PROGRAM CODE #<br />;######################################<br />end start<br /></code></pre></div>
    <div class="meta">Posted on 2001-11-25 09:49:12 by bazik</div>
   </div>
  </div>
 </body>
</html>