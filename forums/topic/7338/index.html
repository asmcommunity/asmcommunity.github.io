<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>New idea for InString - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=7338" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=7338">New idea for InString</a></p>
   <div class="post" id="post-53179">
    <div class="subject"><a href="#post-53179">New idea for InString</a></div>
    <div class="body">I had an idea for a way to search strings that *might* be faster.   I don't know for sure.   I would like to know what you all think of this checksum method.   I have tested the algo and it works as expected, but I haven't profiled it.   I want to hear more ideas first.<br /><br />Thanks.  ;)<br /><br /><pre><code>&#91;size=12&#93;InString2 proc uses ebx edi esi, lpSource&#58;DWORD, lpPattern&#58;DWORD&#91;/size&#93;<br />&#91;size=9&#93;<br />  ;-------------------------------------------------------------<br />  ; by Iblis<br />  ;<br />  ; InString2 searches for the first occurance of the string<br />  ; pointed to by lpPattern in the string pointed to by lpSource<br />  ; and returns the &#40;1&#41; based index into the character array.<br />  ;<br />  ; This version of InString does not use a starting position,<br />  ; so calculating the position is the responsibility of the<br />  ; user, although adding this functionality wouldn't be too<br />  ; difficult.  The main purpose of this is to play with an idea<br />  ; I had about string searching.  Instead of doing a straight<br />  ; byte scan, the routine creates a simple checksum for the<br />  ; pattern string and compares it with the source string.  If<br />  ; the checksums match, one last check is made to see if the<br />  ; strings match byte for byte.  The idea is that perhaps this<br />  ; might speed the search up a bit.<br />  ;<br />  ; Return value&#58;<br />  ; On success, the &#40;1&#41; based index of the search string is<br />  ; returned.  If there is no match, the routine returns &#40;0&#41;.<br />  ; Returns -1 on error.  Possible causes for error include&#58;<br />  ; -If the pattern string is longer than the source.<br />  ; -If the pattern string has zero length.<br />  ;-------------------------------------------------------------&#91;/size&#93;<br />&#91;size=12&#93;<br />	mov esi, 	lpSource<br />	mov edi, 	lpPattern<br />	xor eax, 	eax<br />	xor edx, 	edx<br />@chksm&#58; movzx 		ebx, byte ptr &#91;esi&#93;<br />	inc 		esi<br />	movzx 		ecx, byte ptr &#91;edi&#93;<br />	inc 		edi<br />	lea 		eax, &#91;eax + ecx&#93;<br />	lea 		edx, &#91;edx + ebx&#93;<br />	dec 		bl<br />	sub 		bl, 0FFh<br />	not 		ecx<br />	inc 		ecx<br />	ja 		 @error<br />	jnz		 @chksm<br />	sub 		edx, ebx<br />	lea 		ecx, &#91;edi - 1&#93;<br />	sub 		ecx, lpPattern<br />	jz 		 @error<br />	sub 		esi, ecx<br />	dec 		esi<br />@findm&#58;	cmp 		eax, edx<br />	je 		 @match<br />@findn&#58;	movzx 		ebx, byte ptr &#91;esi&#93;<br />	sub 		edx, ebx<br />	movzx 		ebx, byte ptr &#91;esi + ecx&#93;<br />	lea 		edx, &#91;edx + ebx&#93;<br />	inc 		esi<br />	or 		ebx, ebx<br />	jnz 		 @findm<br />	xor 		eax, eax<br />	jmp 		 @done<br />@match&#58;	mov 		edi, lpPattern<br />	mov 		ebx, ecx<br />	repe 		cmpsb<br />	sub 		esi, ebx<br />	add 		esi, ecx<br />	or 		ecx, ecx<br />	mov 		ecx, ebx<br />	jnz 		 @findn<br />	lea 		eax, &#91;esi + 1&#93;<br />	sub 		eax, lpSource<br />	jmp 		 @done<br />@error&#58;	mov 		eax, -1<br />@done&#58;	ret<br /><br />InString2 endp&#91;/size&#93;</code></pre></div>
    <div class="meta">Posted on 2002-08-13 13:22:51 by iblis</div>
   </div>
   <div class="post" id="post-53195">
    <div class="subject"><a href="#post-53195">New idea for InString</a></div>
    <div class="body">Here is test.<br />But I used a little bit different InString then in m32lib.<br />Yet it still just modification of Steve's original proc.</div>
    <div class="meta">Posted on 2002-08-13 15:13:26 by The Svin</div>
   </div>
   <div class="post" id="post-53198">
    <div class="subject"><a href="#post-53198">New idea for InString</a></div>
    <div class="body">Svin, thanks!  :)<br /><br />I see that my algo is horribly slow.  :(<br />I am not much of an optimizer.<br /><br />My point in posting that was to get a discussion going about the method  used.  It doesn't behave like normal byte scanners.   Basically I want to know if the checksum method has the <em>potential</em> to be fast.<br /><br /><br />Ahh well,  I try.  ;)</div>
    <div class="meta">Posted on 2002-08-13 15:34:25 by iblis</div>
   </div>
   <div class="post" id="post-53203">
    <div class="subject"><a href="#post-53203">New idea for InString</a></div>
    <div class="body">the svin . <br />can your version vs my version?<br /><br />but notice it uses strlen . <br />so maybe add to parameters to both algo . and remove the strlen for the test ?<br /><br /><br />bye<br /><br />thanks<br /><br />eko<br /><br />EDIT:<br />iblis . how does your method work ? <br />i mean you created checksum for the pattern. but what about the all string ?</div>
    <div class="meta">Posted on 2002-08-13 17:33:11 by eko</div>
   </div>
   <div class="post" id="post-53210">
    <div class="subject"><a href="#post-53210">New idea for InString</a></div>
    <div class="body">eko,<br />Yours in most cases ~ 0,5% faster.<br />Good work!<br />iblis, it's very good that you got ideas and try it.<br />It's much harder to create ideas and check them then<br />critisize others.<br /><br />Some people recently tought me that critisize others ideas is more profitable - you gave nothing exept for OTHER people code and almost always win, 'cause it's not so easy to improve some hardly inspected algos and creators mostly lost in their attempts (to win at the end if they are tough enogh).<br /><br />So try your ideas, give them to other - they beat them most of the time :)<br />But at the end you may get lucky and find something better then exist to give it out for free :)<br />Good luck to you.<br /><br />I stopped doing it.</div>
    <div class="meta">Posted on 2002-08-13 18:42:28 by The Svin</div>
   </div>
   <div class="post" id="post-53211">
    <div class="subject"><a href="#post-53211">New idea for InString</a></div>
    <div class="body">I forgot testing prog :)</div>
    <div class="meta">Posted on 2002-08-13 18:44:00 by The Svin</div>
   </div>
   <div class="post" id="post-53215">
    <div class="subject"><a href="#post-53215">New idea for InString</a></div>
    <div class="body">iblis your idea can be good . maybe we can optimize the code alittle <br /><br /><pre><code><br />chksm&#58; movzx 		ebx, byte ptr &#91;esi&#93;<br />	inc 		esi<br />	movzx 		ecx, byte ptr &#91;edi&#93;<br />	inc 		edi<br />	lea 		eax, &#91;eax + ecx&#93;<br />                lea 		edx, &#91;edx + ebx&#93; <br /><br />	dec 		bl<br />	sub 		bl, 0FFh<br />	not 		ecx<br />	inc 		ecx<br />	ja 		 @error<br />	jnz		 @chksm<br /></code></pre><br />few questions<br />1.why do you do lea edx, and not add edx,ebx?<br />2. doesnt sub bl,-1 is the same as inc bl , so dec bl sub bl,0ffh cancel each other<br /><br />i think the order of the command make a diffrent <br />like you can do <br />dec bl<br />not ecx<br />sub bl,-1<br />inc ecx ; should be faster than the orginal order because there is no dependantcy(spelling! ...how to write this word ) this way <br /><br />bye<br /><br />eko<br /><br />EDIT:<br />the svin . - can you post your version of instring<br />and why did you &quot;stop doing it &quot;?</div>
    <div class="meta">Posted on 2002-08-13 19:14:11 by eko</div>
   </div>
   <div class="post" id="post-53221">
    <div class="subject"><a href="#post-53221">New idea for InString</a></div>
    <div class="body"><strong>Svin</strong>,<br />Don't give up!  Most people here appreciate what you have to offer to the community.   I for one enjoy reading your informational posts.  ;)<br /><br /><br /><strong>Eko</strong>, thanks for your interest.  ;)<br /><br /><br /><strong><span style="font-size:12px><div class="quote">1.why do you do lea edx, and not add edx,ebx?</div></span></strong><br /><br />I don't know...  like I said before, I'm not a very experienced optimizer.   For some reason I thought that LEA is generally faster than ADD.   Feel free to let me know the truth on this.<br /><br /><br /><strong><span style="font-size:12px><div class="quote">2. doesnt sub bl,-1 is the same as inc bl , so dec bl sub bl,0ffh cancel each other</div></span></strong><br /><br />Yes, but my reasons for this was to set the flags for my two branches.  (Sorry if it seems convoluted)  I will comment the code here so it makes more sense:<br /><br /><strong><span style="font-size:12px><pre><code>	; At this point EBX = char within the source string<br />	;               ECX = char within the pattern string<br />	;<br />	; If EBX == 0 &amp; ECX != 0,<br />	;   then strlen&#40;lpPattern&#41; &gt; strlen&#40;lpSource&#41;<br />	;   This is an error condition I need to test for.<br />	;<br />	; If ECX == 0<br />	;   then we are at the null-terminated end of lpPattern<br />	;   This is for the loop.<br />	;<br />	dec 		bl       ; if ebx = 0, dec bl will be FF<br />	sub 		bl, 0FFh ; sub bl, FF will set CF for all<br />				 ; values except FF.  This way<br />				 ; I clear the carry flag if char<br />				 ; is 0.  &#40;It took me forever to<br />				 ; figure this out.&#41;<br /><br />	not 		ecx      ; not/inc/dec do not affect CF<br />	inc 		ecx      ; not takes 0 and makes -1<br />				 ; inc -1 makes 0 and sets ZF<br />				 ; For error, ZF must not be set<br /><br />	ja 		 @error  ; ja = jump if CF=0 and ZF=0<br />				 ; next conditional jump needs no<br />				 ; test. ;&#41;<br /><br />	jnz		 @chksm  ; if ZF is not set, then loop.<br />				 ; otherwise, end of lpPattern<br />				 ; found.<br /><br />	sub 		edx, ebx        ; readjust checksum<br />	lea 		ecx, &#91;edi - 1&#93;<br />	sub 		ecx, lpPattern  ; ECX = strlen&#40;lpPattern&#41;<br />	jz 		 @error         ; if strlen = 0, error!<br />					; pattern len cannot be 0</code></pre></span></strong><br /><br /><br /><br /><strong><span style="font-size:12px><div class="quote">i think the order of the command make a diffrent [...] should be faster</div></span></strong><br /><br />Interesting...  why is this?<br /><br /><strong><span style="font-size:12px><div class="quote">dependantcy(spelling! ...how to write this word )</div></span></strong><br /><br />&quot;Dependency&quot;<br /><br /><br /><br />Thanks!<br />-ib</div>
    <div class="meta">Posted on 2002-08-13 19:53:41 by iblis</div>
   </div>
   <div class="post" id="post-53225">
    <div class="subject"><a href="#post-53225">New idea for InString</a></div>
    <div class="body"><pre><code><br /><br />chksm&#58; movzx 		ebx, byte ptr &#91;esi&#93;<br />	inc 		esi<br />	movzx 		ecx, byte ptr &#91;edi&#93;<br />	inc 		edi<br />	lea 		eax, &#91;eax + ecx&#93;<br />                lea 		edx, &#91;edx + ebx&#93; <br /><br />	dec 		bl<br />	sub 		bl, 0FFh<br />	not 		ecx<br />	inc 		ecx<br />	ja 		 @error<br />	jnz		 @chksm<br /></code></pre><br /><br /><br />if its the end of the pattern . ecx=0 . but it still add ebx to edx <br />shouldnt the check be before that?<br /><br />what about this one <br /><br /><pre><code><br />                xor ebx,ebx<br />                xor ecx,ecx<br />@chksm&#58;  mov 		bl, byte ptr &#91;esi&#93;<br />	inc 		esi<br />	cmp		bl,0 ;ebx ; or test bl,bl<br />	mov		cl, byte ptr &#91;edi&#93;<br />	jz 		@error ; we can let the user do this checking &#40; the pattern smaller than the source&#41;<br />	inc 		edi<br />	add 		eax,ecx<br />	add		edx,ebx<br />	or 		cl,cl ;ecx<br />	jnz @chksm<br /></code></pre><br /><br />maybe we can do the chksum instead of adding byte every time . do it with dwords. <br /><br /> i have few ideas for optimize the all code.. but i must have some sleep .<br />bye<br /><br />eko<br /><br />p.s<br /><br />now . when i understand the algo completly . it looks like good idea<br />the algo will be fast if most of the source be diffrent bytes . (i think)</div>
    <div class="meta">Posted on 2002-08-13 20:58:51 by eko</div>
   </div>
   <div class="post" id="post-53227">
    <div class="subject"><a href="#post-53227">New idea for InString</a></div>
    <div class="body">If anyone has the time, the last version of InString that I posted in the MASM32 forum seems to have got past the odd problems it had while maintaining the very short instruction count in its loop code.<br /><br />What I was after with the design was a 4 instruction length main loop and a fast exit for the subloop that does the matching. It contains the modification that EKO designed which performs the matching loop in reverse which in turn reduced the overhead to set up the matching loop by a number of instructions.<br /><br />Alex has a modification on the prologue and epilogue code that reduced the instruction count to set up the original loop code that I have not had time to integrate into the design and there is a good chance that if it is done properly that it will produce a cleaner cache which will in turn make the loop code run faster.<br /><br />Now not withstanding the value of getting a byte scanner of this type faster, its worth keeping in mind that in many instances where the search pattern is over about 6 characters and the data being searched is more than a few K in length, a Boyer Moore algo will literally rip the titz of a byte scanner because they have a superior logic that does far fewer tests for matches than a byte scanner.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-08-13 22:14:31 by hutch--</div>
   </div>
   <div class="post" id="post-53256">
    <div class="subject"><a href="#post-53256">New idea for InString</a></div>
    <div class="body">Hi ;)<br /><br /><strong>Hutch,</strong><br />By no means do I want to compete with nor replace masm.lib's InString().  I was simply offering up this alternative method for discussion.  All the InString stuff that was posted months ago is more than satisfactory.<br /><br /><br /><strong>Eko</strong> and whomever else cares,<br /><br />Here's the gist of how the algorithm works:<br /><br /><br /><br />The idea behind this method is to use a checksum value for string comparison.  To help visualize, pretend we start with two strings:<br /><br />  lpSource =  'All your base are belong to us'<br />  lpPattrn =  'belong'<br /><br /><br />The first task is calculating the checksum for lpPattern, which is just a simple additive method.  Anything more complex might slow things down too much.  We want to take each char in the pattern and add it up.<br /><br /><pre><code>&#91;b&#93;&#91;size=12&#93;  lpPattrn = |'b' + 'e' + 'l' + 'o' + 'n' + 'g'|<br />	   |                                 |<br />  chk_pat  = \&#91;color=blue&#93;62h + 65h + 6ch + 6fh + 6eh + 67h&#91;/color&#93;/ =  &#91;color=green&#93;277h&#91;/color&#93;&#91;/size&#93;&#91;/b&#93;</code></pre><br /><br /><br />Now that we have the checksum, we save it for later to do comparison matches with.<br />Since there is no sense in wasting loop cycles, we can use this to also get the checksum for the first <em>n</em> characters in lpSource.<br /><br /><pre><code>&#91;b&#93;&#91;size=12&#93;  lpSource = |'A' + 'l' + 'l' + ' ' + 'y' + 'o'|+ 'u' + 'r' + ' ' + 'b' + ' '...<br />             |                                 |<br />  chk_src  = \&#91;color=blue&#93;41h + 6ch + 6ch + 20h + 79h + 6fh&#91;/color&#93;/ =  &#91;color=red&#93;221h&#91;/color&#93;&#91;/size&#93;&#91;/b&#93;</code></pre><br /><br /><br /><br />Now for the main loop.  In the loop we compare the checksum for each section of lpSource with constant chk_pat.  If the values are equal, that means there's a fairly good chance that we've got a match.  Afterwards we send it to a short <em>repe cmpsb</em>-type routine for the final verdict.<br /><br /><pre><code>&#91;b&#93;&#91;size=12&#93;  1. lpSource = A l l   y o &#91;color=grey&#93;u r   b a s e   a r e   b...&#91;/color&#93;<br />     chk_src  =|    &#91;color=red&#93;221h&#91;/color&#93;   |<br />     chk_pat  =     &#91;color=green&#93;277h&#91;/color&#93;<br /><br />  2. No match.  So now adjust lpSource + 1, and create the new checksum by<br />     subtracting the first byte, and adding the new byte.<br /><br />  3. lpSource = &#91;color=grey&#93;A&#91;/color&#93; l l   y o u &#91;color=grey&#93;r   b a s e   a r e   b...&#91;/color&#93;<br />     chk_src  =  |   &#91;color=red&#93;255h&#91;/color&#93;    |   = &#40; 221h - 'A' + 'u' &#41;<br />     chk_pat  =      &#91;color=green&#93;277h&#91;/color&#93;&#91;/size&#93;&#91;/b&#93;</code></pre><br /><br /><br />We keep going until either  chk_src = chk_pat,  or we reach the end of lpSource (get a null char).   If a checksum match is made,  one last attempt to verify the match is made by a small repe cmpsb loop.<br /><br /><br /><br />This is basically what my algorithm does.  If you want I can better comment the code, but I think it's pretty easy to figure out from here.   What I am interested in is not exactly optimization, but rather to discuss applying such a method to string searching and other such algorithms.<br /><br />Thanks!  :)</div>
    <div class="meta">Posted on 2002-08-14 03:33:16 by iblis</div>
   </div>
   <div class="post" id="post-53313">
    <div class="subject"><a href="#post-53313">New idea for InString</a></div>
    <div class="body">i understood how the algo works; ]<br /> .. <br /><br />lets compare this method to byte check string ( like instring)<br /><br />after you have calculated checksum of the pattern <br />you compare every <br /><br />add next char . remove the first  and do compare <br /><br />in byte check . you need to compare every byte in the pattern .<br /><br />so your method . in my opinion can be alot faster for big patterns.<br /><br />maybe better checksum , not add , <br />maybe xor , and then when we  have match on the chechsum , the probability that we  have found the correct place gets bigger ( i think)<br /><br />bye<br /><br />eko</div>
    <div class="meta">Posted on 2002-08-14 09:34:55 by eko</div>
   </div>
   <div class="post" id="post-53315">
    <div class="subject"><a href="#post-53315">New idea for InString</a></div>
    <div class="body">Yes,  I know using add  is not the best way to get a string signature.  It's possible for the algo to think &quot;string&quot; = &quot;grints&quot;  which is why it needs to verify the matches.<br /><br />I played with different ideas on this, and in the end I went with a simple add because doing more complex checksum generation might take too much time.   I tried xor instead of add, but all the checksums generated are 8 bit... not unique enough, imo.</div>
    <div class="meta">Posted on 2002-08-14 09:45:23 by iblis</div>
   </div>
   <div class="post" id="post-53320">
    <div class="subject"><a href="#post-53320">New idea for InString</a></div>
    <div class="body">iblis,<br /><br />No problems, I am more than glad to see you working on original ideas. I simply pointed out that the version of InString had been fixed and tweaked by both EKO and myself to try and get its speed up a bit.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-08-14 10:04:47 by hutch--</div>
   </div>
   <div class="post" id="post-53321">
    <div class="subject"><a href="#post-53321">New idea for InString</a></div>
    <div class="body">Maybe doing add and sub together <br /><br />add edx,1st byte<br />sub edx,2nd byte<br />add edx,3rd byte<br />.<br />.<br />.<br />.<br />and so on</div>
    <div class="meta">Posted on 2002-08-14 10:08:33 by eko</div>
   </div>
  </div>
 </body>
</html>