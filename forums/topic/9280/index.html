<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>HSP HexTree Space Partitioning - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=9280" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=9280">HSP HexTree Space Partitioning</a></p>
   <div class="post" id="post-68432">
    <div class="subject"><a href="#post-68432">HSP HexTree Space Partitioning</a></div>
    <div class="body">An idea I thought I'd put up for grabs, something I thought of many moons ago.<br />A LinkedList structure with six possible branches from each node, representing positive and negative XYZ.<br /><br />This mapping system would be applied to objects in the world. These nodes would represent a system of lines forming shortest routes, in turn these could be applied to AI for pathfinding, or simply to find the nearest objects for weighted need calculus.<br /><br />The original idea from my youth was to keep three axial binary trees,but a hextree puts it all in one neat neural network.<br /><br />Any thoughts?</div>
    <div class="meta">Posted on 2002-12-01 09:23:32 by Homer</div>
   </div>
   <div class="post" id="post-68621">
    <div class="subject"><a href="#post-68621">HSP HexTree Space Partitioning</a></div>
    <div class="body">No feedback? Perhaps I should elucidate...<br /><br />For any object in the 3d world, we can decide which is the next object in the X+,X-,Y+,Y-,Z+ and Z- directions.<br />That means, on its right,left,above,below,in front and behind.<br />Only one object can exist in one place, so is anyone interested in coding a solution to a sorting algorithm? It's not very difficult !!</div>
    <div class="meta">Posted on 2002-12-02 09:37:37 by Homer</div>
   </div>
   <div class="post" id="post-68932">
    <div class="subject"><a href="#post-68932">HSP HexTree Space Partitioning</a></div>
    <div class="body">yes, it's a good idea but time constrains me to do something about it :) - but I'll code something if time permits.<br /><br />Anyway, how would you like the sorting algo works on x? y? z? or make an algo for all directions?<br /><br />A sideview of a world, since we are so cheap on creating a 3d one ;) :<pre><code><br />xxxxxxxxx&#91; 2&#93;xxxxxxxxxxxxx<br />xxxxxxxxx&#91; 1&#93;xxxxxxxxxxxxx<br />xxxxxxxxx&#91; 0&#93;xxxxxxxxxxxxx<br />&#91;color=blue&#93;xxxxxxxxx&#91;-1&#93;xxxxxxxxxxxxx&#91;/color&#93;<br />xxxxxxxxx&#91;-2&#93;xxxxxxxxxxxxx</code></pre><em>[ 0] is on (x = 0, y = 0,  z = 0)</em><br /><br />assuming 2, 1, 0, -1, -2, shows a direction on y and everything on the horizontal on z. If we are going to sort a node, let's say:<br /><br />-1(x = 0, y = -1, z = 0) and we want to sort all nodes on the z direction, then we are only going to sort all nodes on that level(the colored blue ones.)<br /><br />This is how you want the sorting to behave? :)</div>
    <div class="meta">Posted on 2002-12-03 23:13:27 by stryker</div>
   </div>
   <div class="post" id="post-69267">
    <div class="subject"><a href="#post-69267">HSP HexTree Space Partitioning</a></div>
    <div class="body">This is the first version. What it does are:<br /><br />1. Add nodes to any direction at any node. (x+, x-, y+, y-, z+, z-)<br /><br />2. Deallocate all nodes.<br /><br />I've never tested extensively the deallocation routine but it seems to be working. I'm sure there will be bugs depending on the model of the hex tree but I have no time to test it fully. :)<br /><br />So here it is...<br /><br />I'll add sorting later. :)<pre><code>&#91;size=9&#93;.686<br />.MODEL FLAT, STDCALL<br />OPTION SCOPED<br />OPTION CASEMAP&#58;NONE<br /><br />INCLUDE C&#58;\dev\masm32\include\windows.inc<br />INCLUDE C&#58;\dev\masm32\include\kernel32.inc<br />INCLUDELIB C&#58;\dev\masm32\lib\kernel32.lib<br />INCLUDE C&#58;\dev\masm32\include\user32.inc<br />INCLUDELIB C&#58;\dev\masm32\lib\user32.lib<br />INCLUDE C&#58;\dev\masm32\include\masm32.inc<br />INCLUDELIB C&#58;\dev\masm32\lib\masm32.lib<br /><br />@str MACRO _str&#58;VARARG<br />    LOCAL @@1<br />    IF @InStr&#40;1, &lt;_str&gt;, &lt;!&quot;&gt;&#41;<br />        .DATA<br />            @@1 DB _str, 0<br />        .CODE<br />        EXITM &lt;OFFSET @@1&gt;<br />    ELSE<br />        EXITM &lt;_str&gt;<br />    ENDIF<br />ENDM<br /><br />;by stryker<br /><br />xcall MACRO function&#58;REQ, parameters&#58;VARARG<br />    LOCAL psize, paddr, plen<br />    IFNB &lt;parameters&gt;<br />        psize = 0<br />        FOR param, &lt;parameters&gt;<br />            psize = psize + 4<br />        ENDM<br />        IF psize EQ 4<br />            push parameters<br />        ELSE<br />            sub esp, psize<br />            psize = 0<br />            FOR param, &lt;parameters&gt;<br />                IF @SizeStr&#40;&lt;param&gt; &#41; GT 4<br />                    paddr SUBSTR &lt;param&gt;, 1, 5<br />                    IFIDNI paddr, &lt;ADDR &gt;<br />                        paddr SUBSTR &lt;param&gt;, 6, @SizeStr&#40;&lt;param&gt;&#41; - 5<br />                        lea eax, paddr<br />                        mov DWORD PTR &#91;esp+psize*4&#93;, eax<br />                    ELSE<br />                        mov DWORD PTR &#91;esp+psize*4&#93;, @str&#40;&lt;param&gt;&#41;<br />                    ENDIF<br />                ELSE<br />                    mov DWORD PTR &#91;esp+psize*4&#93;, @str&#40;&lt;param&gt;&#41;<br />                ENDIF<br />                psize = psize + 1<br />            ENDM<br />        ENDIF<br />    ENDIF<br />    call function<br />ENDM<br /><br />hext struct<br />    object  DD ?<br />    visited DD ?<br />    xp      DD ?<br />    xm      DD ?<br />    yp      DD ?<br />    ym      DD ?<br />    zp      DD ?<br />    zm      DD ?<br />hext ends<br /><br />.CONST<br /><br />    ;Direction Constants<br />    ;<br />    ;Postfix&#58;<br />    ;   P - Positive&#40;+&#41;<br />    ;   M - Negative&#40;-&#41;<br /><br />    DXP EQU 0<br />    DXM EQU 1<br />    DYP EQU 2<br />    DYM EQU 3<br />    DZP EQU 4<br />    DZM EQU 5<br /><br />    ;Object Constants<br /><br />    NO_OBJECT           EQU 0<br />    SILVER_COIN         EQU 1<br />    ANKH                EQU 2<br />    SUN_STONE           EQU 3<br />    PRISMATIC_NECKLACE  EQU 4<br />    TWIG                EQU 5<br /><br />.DATA<br /><br />    addtable    DD __from_xp, __from_xm, __from_yp, __from_ym, __from_zp, __from_zm<br /><br />.DATA?<br /><br />    hHeap       DD ?<br />    basenode    DD ?<br />    buffer      DB 8 DUP&#40;?&#41;<br /><br />.CODE<br /><br />;Procedure&#58; addnode<br />;Requires&#58; hHeap, the handle to the heap<br />;        &#58; a tree must have at least 1 node existing<br />;Parameters&#58; node<br />;          &#58; object<br />;          &#58; direction, where the object is to be placed based on the position of the node parameter<br /><br />addnode&#58;<br /><br />    invoke  HeapAlloc, hHeap, HEAP_ZERO_MEMORY, SIZEOF hext<br /><br />    ;Place the object on the new node<br /><br />    mov     edx, &#91;esp+8&#93;<br />    mov     &#40;hext ptr &#91;eax&#93;&#41;.object, edx<br /><br />    ;Connect the 2 nodes by determining the given direction<br /><br />    mov     ecx, &#91;esp+12&#93;<br />    mov     edx, &#91;esp+4&#93;<br />    jmp     DWORD PTR &#91;addtable+ecx*4&#93;<br /><br />    __from_xp&#58;<br /><br />        mov     &#40;hext ptr &#91;edx&#93;&#41;.xp, eax<br />        mov     &#40;hext ptr &#91;eax&#93;&#41;.xm, edx<br />        jmp     __finished_adding_node<br /><br />    __from_xm&#58;<br /><br />        mov     &#40;hext ptr &#91;edx&#93;&#41;.xm, eax<br />        mov     &#40;hext ptr &#91;eax&#93;&#41;.xp, edx<br />        jmp     __finished_adding_node<br /><br />    __from_yp&#58;<br /><br />        mov     &#40;hext ptr &#91;edx&#93;&#41;.yp, eax<br />        mov     &#40;hext ptr &#91;eax&#93;&#41;.ym, edx<br />        jmp     __finished_adding_node<br /><br />    __from_ym&#58;<br /><br />        mov     &#40;hext ptr &#91;edx&#93;&#41;.ym, eax<br />        mov     &#40;hext ptr &#91;eax&#93;&#41;.yp, edx<br />        jmp     __finished_adding_node<br /><br />    __from_zp&#58;<br /><br />        mov     &#40;hext ptr &#91;edx&#93;&#41;.zp, eax<br />        mov     &#40;hext ptr &#91;eax&#93;&#41;.zm, edx<br />        jmp     __finished_adding_node<br /><br />    __from_zm&#58;<br /><br />        mov     &#40;hext ptr &#91;edx&#93;&#41;.zm, eax<br />        mov     &#40;hext ptr &#91;eax&#93;&#41;.zp, edx<br /><br />    __finished_adding_node&#58;<br /><br />    retn    12<br /><br />;Procedure&#58; delallnode<br />;Requires&#58; hHeap, the handle to the heap<br />;Parameters&#58; node, pointer to a node - preferably the base node<br /><br />delallnode&#58;<br /><br />    mov     eax, &#91;esp+4&#93;<br />    test    eax, eax<br />    jz      __exit_deallocation<br />    cmp     &#40;hext ptr &#91;eax&#93;&#41;.visited, 0<br />    jne     __exit_deallocation<br />    mov     &#40;hext ptr &#91;eax&#93;&#41;.visited, 1<br /><br />    ;Traverse x+<br /><br />    push    eax<br />    mov     eax, &#40;hext ptr &#91;eax&#93;&#41;.xp<br />    push    eax<br />    call    delallnode<br />    pop     eax<br /><br />    ;Traverse y+<br /><br />    push    eax<br />    mov     eax, &#40;hext ptr &#91;eax&#93;&#41;.yp<br />    push    eax<br />    call    delallnode<br />    pop     eax<br /><br />    ;Traverse z+<br /><br />    push    eax<br />    mov     eax, &#40;hext ptr &#91;eax&#93;&#41;.zp<br />    push    eax<br />    call    delallnode<br />    pop     eax<br /><br />    ;Traverse x-<br /><br />    push    eax<br />    mov     eax, &#40;hext ptr &#91;eax&#93;&#41;.xm<br />    push    eax<br />    call    delallnode<br />    pop     eax<br /><br />    ;Traverse y-<br /><br />    push    eax<br />    mov     eax, &#40;hext ptr &#91;eax&#93;&#41;.ym<br />    push    eax<br />    call    delallnode<br />    pop     eax<br /><br />    ;Traverse z-<br /><br />    push    eax<br />    mov     eax, &#40;hext ptr &#91;eax&#93;&#41;.zm<br />    push    eax<br />    call    delallnode<br />    pop     eax<br /><br />    ;NULLify all nodes that are pointing on a node specified by EAX<br /><br />    mov     edx, &#40;hext ptr &#91;eax&#93;&#41;.xp<br />    test    edx, edx<br />    jz      @f<br />    mov     &#40;hext ptr &#91;edx&#93;&#41;.xm, NULL<br />    @@&#58;<br />    mov     edx, &#40;hext ptr &#91;eax&#93;&#41;.xm<br />    test    edx, edx<br />    jz      @f<br />    mov     &#40;hext ptr &#91;edx&#93;&#41;.xp, NULL<br />    @@&#58;<br />    mov     edx, &#40;hext ptr &#91;eax&#93;&#41;.yp<br />    test    edx, edx<br />    jz      @f<br />    mov     &#40;hext ptr &#91;edx&#93;&#41;.ym, NULL<br />    @@&#58;<br />    mov     edx, &#40;hext ptr &#91;eax&#93;&#41;.ym<br />    test    edx, edx<br />    jz      @f<br />    mov     &#40;hext ptr &#91;edx&#93;&#41;.yp, NULL<br />    @@&#58;<br />    mov     edx, &#40;hext ptr &#91;eax&#93;&#41;.zp<br />    test    edx, edx<br />    jz      @f<br />    mov     &#40;hext ptr &#91;edx&#93;&#41;.zm, NULL<br />    @@&#58;<br />    mov     edx, &#40;hext ptr &#91;eax&#93;&#41;.zm<br />    test    edx, edx<br />    jz      @f<br />    mov     &#40;hext ptr &#91;edx&#93;&#41;.zp, NULL<br />    @@&#58;<br /><br />    pushad<br />    invoke  MessageBox, 0, 0, 0, 0<br />    popad<br /><br />    invoke  HeapFree, hHeap, NULL, eax<br /><br />    __exit_deallocation&#58;<br /><br />    retn    4<br /><br />start&#58;<br /><br />    ;Create scene<br /><br />    invoke  GetProcessHeap<br />    mov     hHeap, eax<br /><br />    ;Create base node/root node<br /><br />    invoke  HeapAlloc, eax, HEAP_ZERO_MEMORY, SIZEOF hext<br />    mov     basenode, eax<br /><br />    xcall   addnode, eax, NO_OBJECT, DZM<br />    mov     eax, basenode<br />    xcall   addnode, eax, SUN_STONE, DYP<br /><br />    ;mov     eax, basenode<br />    ;mov     eax, &#40;hext ptr &#91;eax&#93;&#41;.zm<br />    ;mov     eax, &#40;hext ptr &#91;eax&#93;&#41;.object<br />    ;invoke  dwtoa, eax, OFFSET buffer<br />    ;invoke  MessageBox, 0, OFFSET buffer, 0, 0<br /><br />    ;mov     eax, basenode<br />    ;mov     eax, &#40;hext ptr &#91;eax&#93;&#41;.yp<br />    ;mov     eax, &#40;hext ptr &#91;eax&#93;&#41;.object<br />    ;invoke  dwtoa, eax, OFFSET buffer<br />    ;invoke  MessageBox, 0, OFFSET buffer, 0, 0<br /><br />    xcall   delallnode, basenode<br /><br />    invoke  ExitProcess, 0<br /><br />end start&#91;/size&#93;</code></pre>as you can see here the scene looks like this.<br /><br />from the base node(0, 0, 0) going (0, 0, -1) - this node has no object in it.<br /><br />again from the base node going (0, 1, 0) we place a SUN_STONE object. :)<br /><br />I'll add more explanations later.<br /><br />If you see this code<pre><code>pushad<br />invoke  MessageBox, 0, 0, 0, 0<br />popad</code></pre>I use this snippet to test how many nodes we deallocated. Based on this example it's 3...<br /><br />BTW, I use this kind of coordinate. :)</div>
    <div class="meta">Posted on 2002-12-05 13:57:14 by stryker</div>
   </div>
   <div class="post" id="post-69269">
    <div class="subject"><a href="#post-69269">HSP HexTree Space Partitioning</a></div>
    <div class="body">there are still a lot to be done and I still haven't finished connecting all nodes... Hex Tree is so complex to implement because you have to think of all adjacent nodes.<br /><br />at the addnode procedure, there are still some codes missing but I didn't add it, because it will be too complex to understand the whole idea of a hextree.<br /><br />the .visited field of our structure is very important during deallocation.<br /><br />Anywho, it's a start. :)</div>
    <div class="meta">Posted on 2002-12-05 14:10:41 by stryker</div>
   </div>
   <div class="post" id="post-69831">
    <div class="subject"><a href="#post-69831">HSP HexTree Space Partitioning</a></div>
    <div class="body">nice stuff ! good start :)<br /><br />What I would like to point out is that your nodes are not equipped to hold more than one object - you are treating the nodes as representative of space !!<br />This means you can have empty nodes contianing no object...<br /><br /><br />What I was suggesting initially was not a nodemap of the world space per se, simply a network between the actual objects within the world.<br />I was planning on keeping a second nodemap of world space.<br />I prefer your system !!<br />This can be better used for pathfinding, although it's less suitable for weighted need calculus, it's still admirable.<br /><br />Have you seen my work on LinkedLists?<br />Under that system, we already have 4x links, meaning we have to supply 2 more.<br />A Node might look like this:<br /><br />MyNode STRUCT<br />LO LinkedObject &lt;&gt;  ;contains support for node name, x and y links<br />LOType DWORD WORLDNODE ;Tag the structure type (see below)<br />zPrev LPLINKEDOBJECT ?  ;pointers for the missing axis<br />zNext LPLINKEDOBJECT ?<br />vPos D3DVECTOR3 &lt;&gt; ;3D position of this node exactly<br />fRadius FLOAT ? ;Radius of this node can be used for ambient sound fx<br />pSound LPCACHEDOBJECT ?;pointer to a loaded and cached object...ambientsfx<br />pObjectList LPLINKEDOBJECT ? ;pointer to first of a linkedlist of close objects<br />MyNode ENDS<br /><br />This type of Spatial Node is more advanced.<br />It can be named, supports a centre and radius in 3d space which can be used to create overlapping regional ambient sound effects, and contains a member representing the Head of a LinkedList of proximate objects in this worldspace.<br />These are the objects &quot;owned&quot; by this Node. <br />Furthermore, among the LinkedList of world objects in this spherical region of space, may exist one or more Nested Nodes !!! (That's why I have begun tagging my LO structures - so you can mix different LinkedObjects in a single LinkedList).<br />This means that a larger region can house smaller regions of space - for example, we might wish to have one ambient sound for when we enter the house and another sound to be heard in the bedroom (radio) or in the cellar (weird creaking) but without losing the ambient house sound...<br />It also fixes the poor support for multiple proximate objects in a NodeSpace.<br />This I think might prove to be a better blend for use in terms of both AI pathfinding through tighter networks, and also in terms of faster identification of grouped static objects for weighted need calculus.<br />Keep up the good work !!</div>
    <div class="meta">Posted on 2002-12-08 07:54:28 by Homer</div>
   </div>
   <div class="post" id="post-69944">
    <div class="subject"><a href="#post-69944">HSP HexTree Space Partitioning</a></div>
    <div class="body">I haven't seen the code on your LL but I'll take a look at it. I'm just skimming some parts of your post up here. I'll reread them some other time, if I get to continue on working on this. :)<br /><br />I'll also consider what you meant above.<br /><br />:alright:</div>
    <div class="meta">Posted on 2002-12-08 23:16:49 by stryker</div>
   </div>
   <div class="post" id="post-69946">
    <div class="subject"><a href="#post-69946">HSP HexTree Space Partitioning</a></div>
    <div class="body">The actual Sorting algo doesn't need to be complex...<br />consider this:<br /><br />how many nodes do we need for starters? one per object...<br />we create N nodes.<br />Now we begin to &quot;sort&quot; them.<br />No actual sorting is done, we are about to create the seemingly complex links between the nodes...<br /><br />Loop for all objects:<br />For each object: which OTHER object has the next highest value in X?<br />                           which has the next lowest value in X?<br />                            in Y?<br />                            in Z?<br /><br />We begin to create links between the nodes.<br />They can loop, thats ok !! They can be nets.<br />This network of nodes does not yet take spatial nodes into account.<br />They will be inserted in a separate phase.<br />(my LL code provides for easy insertion)<br /><br />That seems fairly simple! It relies on us having a well-defined node structure...</div>
    <div class="meta">Posted on 2002-12-08 23:43:54 by Homer</div>
   </div>
   <div class="post" id="post-69947">
    <div class="subject"><a href="#post-69947">HSP HexTree Space Partitioning</a></div>
    <div class="body">If anyone is interested, I'll share a method of pathfinding for AI using networked spacenodes which uses a static lookup table for extremely fast pathfinding.<br />It requires N^2 dwords where N=#nodes...</div>
    <div class="meta">Posted on 2002-12-08 23:48:34 by Homer</div>
   </div>
   <div class="post" id="post-70677">
    <div class="subject"><a href="#post-70677">HSP HexTree Space Partitioning</a></div>
    <div class="body">Sounds nice :)  I'd like to have a look...<br /><br />Sliver</div>
    <div class="meta">Posted on 2002-12-12 19:10:52 by Sliver</div>
   </div>
   <div class="post" id="post-70681">
    <div class="subject"><a href="#post-70681">HSP HexTree Space Partitioning</a></div>
    <div class="body">Yep, I'm interested</div>
    <div class="meta">Posted on 2002-12-12 19:36:12 by Maelstrom</div>
   </div>
   <div class="post" id="post-70740">
    <div class="subject"><a href="#post-70740">HSP HexTree Space Partitioning</a></div>
    <div class="body">ok this guy here has the right idea <a target="_blank" href="http://gamedev.net/reference/articles/article1841.asp">Check This Out</a> <br /><br />He is describing the pathfinding table in simplistic spatial terms.<br />The system I'd like to implement is much enhanced but that document gives a good indication of what the hell I'm talking about.<br />It needs to have nodes for static world objects incorprated into it.<br />This would allow our AI NPC to locate nearby goodies which will bear weight on the outcome of the NPC's goal-oriented motion.<br />Note that much of the table is empty.<br /><br />It's occurred to me that there's a much better way to do this, and in some ways it's similar to a portal engine and in others similar to John Carmack's &quot;bsp2 - PVS&quot; (potentially-visible sets)...I'll try to describe it.<br /> <br />For starters imagine we have built a 3d world. We will place imaginary markers at key locations throughout the world, which are stored as an array of vertices. Added to this array are the locations of any desirable objects as more vertices.<br />I'm not going into &quot;Need-weighting&quot;, I'll keep this simple.<br />These important locations are marker nodes which the AI will use...<br />what we will do is build a network of links between the nodes. This won't be cheap, but can be done in a pre-game processing phase as follows:<br />(assuming that the 3d world is loaded into memory)<br />Beginning with any arbitrary node (the first vertex in the array), we will perform a line-of-sight test against every other node (the rest of the array). If the line of sight is not obstructed, we create a link from the current node to the next node.<br />Importantly, we also note the ray length (difference between vertex values) which is considered THE WEIGHTING FOR THAT LINK. This saves us from  calculating distances in realtime (everything counts).<br />If the line of sight between any two nodes is obstructed, we mark this link as ILLEGAL which saves the comparison being made betwen these two vertices for the remainder of the processing phase (see below). <br />When the vertex array has been completely processed with respect to the initial vertex comparisons loop, we repeat the process, performing line of sight tests for each of the nodemarker vertices against all the others EXCEPT any marked as &quot;illegal&quot;. <br />We now have a weighted neural network !!<br /><br />Importantly, we would not be using LinkedList-style linking of nodes, rather we would use the above algorithm to generate a lookup-table which works just like the ones described in the document <a target="_blank" href="http://gamedev.net/reference/articles/article1841.asp">Here</a> <br />This LookupTable could be a dynamic array, we don't need the dead wood.<br />Any thoughts?</div>
    <div class="meta">Posted on 2002-12-13 02:33:47 by Homer</div>
   </div>
  </div>
 </body>
</html>