<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>How to split one string to multy strings - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17447" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=17447">How to split one string to multy strings</a></p>
   <div class="post" id="post-135113">
    <div class="subject"><a href="#post-135113">How to split one string to multy strings</a></div>
    <div class="body">Hi somebody help me <br />How to split one string to multy strings in Masm, i need the function like Split in Visual Basic.:stupid:</div>
    <div class="meta">Posted on 2004-03-01 01:46:25 by neverending</div>
   </div>
   <div class="post" id="post-135116">
    <div class="subject"><a href="#post-135116">How to split one string to multy strings</a></div>
    <div class="body">A quick (1minute) made example in TASM,<br />but i am sure you can convert it with ease :tongue:<br /><br /><pre><code><br />;------------------------------<br />;Warn&#58;<br />;-action in place<br />;-result array must have space<br />;-------------------------------<br />Str_Split PROC STDCALL<br />	uses	ecx,esi,edi<br />	ARG	@@lpsz_string&#58;dword<br />	ARG	@@lplp_results&#58;dword<br /><br />	mov	edi,&#91;@@lplp_results&#93;<br />	mov	esi,&#91;@@lpsz_string&#93;<br />	mov	ecx,esi<br />	<br />@@loop_string&#58;<br />	mov	al,&#91;esi&#93;<br />	test	al,al<br />	jz	@@finish<br />	<br />	; check for space as separator<br />	.IF al==32 <br /> 		;found end of one sub-string<br /> 		;terminate it in place<br /> 		mov	byte ptr &#91;esi&#93;,0<br /> 		;store start into result array<br /> 		mov	&#91;edi&#93;,ecx<br /> 		add	edi,4<br /> 		mov	ecx,esi<br /> 		inc	ecx<br />	.ENDIF<br />	<br /> 	inc	esi<br /> 	jmp	@@loop_string<br /> 	<br />@@finish&#58;<br />	ret<br />ENDP<br /></code></pre></div>
    <div class="meta">Posted on 2004-03-01 04:46:15 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-135120">
    <div class="subject"><a href="#post-135120">How to split one string to multy strings</a></div>
    <div class="body">Here's mine, in MASM<br />Let's assume you will be splitting by only one character, &quot;,&quot; for example<br />We'll want a function to look like<br />Split proc StrIn,Delimiter<br />Now, the next problem is how will we give back the array. Initially, we'll make the function overwrite the input string, and return the number of times we encountered &quot;,&quot; :<br /><pre><code><br />Split proc uses ebx ecx StrIn,Delimiter<br />	mov ebx,StrIn<br />	mov ecx,1 ; number of strings encountered<br />	xor eax,eax<br /> _again&#58;<br />	mov al,&#91;ebx&#93;<br />	.if eax==Delimiter<br />		mov byte ptr&#91;ebx&#93;,0<br />		inc ecx<br />	.endif<br />	inc ebx<br />	or al,al<br />	jnz _again<br />	mov eax,ecx<br />	ret<br />Split endp<br /></code></pre><br />Now we'll have eax strings one after another. But accessing each of the strings won't be easy. So, we'll make another function - that gives us indexes of strings apart from number of strings. We'll still be modifying the input string. pArray is the address of a DWORD array, big enough to show the addresses of each of the substrings<br /><pre><code><br />Split proc uses ebx ecx edx StrIn,pArray,Delimiter <br />	xor eax,eax<br />	mov ebx,StrIn<br />	mov edx,pArray<br />	mov &#91;edx&#93;,ebx<br />	mov ecx,1 ; number of strings encountered<br /> _again&#58;<br />	mov al,&#91;ebx&#93;<br />	inc ebx<br />	.if eax==Delimiter<br />		mov byte ptr&#91;ebx-1&#93;,0<br />		mov &#91;edx+ecx*4&#93;,ebx<br />		inc ecx<br />	.endif<br />	or al,al<br />	jnz _again<br />	mov eax,ecx<br />	ret<br />Split endp<br /></code></pre><br />Ok, we may want to put a limit to the number of string we get:<br /><pre><code><br />Split proc uses ebx ecx edx StrIn,pArray,MaxStrings,Delimiter<br />	mov ebx,StrIn<br />	mov edx,pArray<br />	mov &#91;edx&#93;,ebx<br />	mov ecx,1 ; number of strings encountered<br />	xor eax,eax<br /> _again&#58;<br />	mov al,&#91;ebx&#93;<br />	inc ebx<br />	.if eax==Delimiter&#91;color=green&#93; &amp;&amp; ecx&lt;MaxStrings&#91;/color&#93;<br />		mov byte ptr&#91;ebx-1&#93;,0<br />		mov &#91;edx+ecx*4&#93;,ebx<br />		inc ecx<br />	.endif<br />	or al,al<br />	jnz _again<br />	mov eax,ecx<br />	ret<br />Split endp<br /></code></pre><br /><br />Ok, we want to keep the original string, so we'll have to return a new array with the stuff inside:<br /><pre><code><br />Split proc uses ecx edx StrIn,Delimiter <br />	local ReturnedArray,StringsNum,StrInLen<br />	mov ebx,StrIn<br />	xor eax,eax<br />	mov ecx,1<br />	@@&#58;<br />	mov al,&#91;ebx&#93;<br />	inc ebx<br />	.if eax==Delimiter<br />		inc ecx<br />	.endif<br />	or al,al<br />	jnz @B<br />	sub ebx,StrIn<br />	mov StrInLen,ebx<br />	mov StringsNum,ecx<br />	lea ebx,&#91;ebx+ecx*4+4&#93;<br />	invoke HeapAlloc,HEAP1,0,ebx  ; assuming HEAP1 is a heap you've already created <br />	; invoke malloc,ebx  &lt;-- this is what the above stuff needs to do<br />	mov ReturnedArray,eax<br />	<br />	mov ecx,StringsNum<br />	lea ebx,&#91;eax+ecx*4+4&#93;<br />	mov edx,eax<br />	<br />	mov &#91;edx&#93;,ebx<br />	mov ecx,1<br />	xor eax,eax<br /> _again&#58;<br />	mov al,&#91;ebx&#93;<br />	inc ebx<br />	.if al==Delimiter<br />		mov byte ptr&#91;ebx-1&#93;,0<br />		mov &#91;edx+ecx*4&#93;,ebx<br />		inc ecx<br />	.endif<br />	or al,al<br />	jnz _again<br />	mov dword ptr&#91;edx+ecx*4&#93;,0<br />	mov eax,ecx  ; EAX holds the number of strings found<br />	mov ebx,ReturnedArray ; this is the actual array pointer.  <br />	; The first EAX+1 DWORDs contain pointers to the strings, the last DWORD of which is 0 <br />	; &#40;in case we forgot how many the strings in the array are&#41;<br />	; use HeapFree  or &quot;free&quot; to free this memory when you've finished using it <br />	ret<br />Split endp<br /></code></pre></div>
    <div class="meta">Posted on 2004-03-01 06:52:03 by Ultrano</div>
   </div>
   <div class="post" id="post-135136">
    <div class="subject"><a href="#post-135136">How to split one string to multy strings</a></div>
    <div class="body">this works for my needs :)<br /><br /><pre><code><br />SplitString proc lpString&#58;DWORD, lpArray&#58;DWORD<br /><br />	xor		eax, eax<br />	mov		edx, lpString<br />	mov		ecx, lpArray<br />		<br />	mov		&#91;ecx+eax*4&#93;, edx<br />	inc		eax<br />  <br />  Next&#58;	<br />	cmp		BYTE PTR &#91;edx&#93;, 0<br />	jz		Salir<br />	cmp		BYTE PTR &#91;edx&#93;, ' '<br />	jz		Patch<br />	inc		edx<br />	jmp		Next	<br />	<br />  Patch&#58;<br />  	mov		BYTE PTR &#91;edx&#93;, 0<br />  	inc		edx<br />  	mov		&#91;ecx+eax*4&#93;, edx<br />  	inc		eax<br />  	jmp		Next	<br />	<br />  Salir&#58;<br />	ret<br /><br />SplitString endp<br /></code></pre></div>
    <div class="meta">Posted on 2004-03-01 20:11:24 by Jnrz</div>
   </div>
   <div class="post" id="post-135158">
    <div class="subject"><a href="#post-135158">How to split one string to multy strings</a></div>
    <div class="body">I forgot some code in the last function - to actually copy the old string to the new place... here's the fixed code:<br /><pre><code><br /><br />Split proc uses ecx edx StrIn,Delimiter <br />	local ReturnedArray,StringsNum,StrInLen<br />	mov ebx,StrIn<br />	xor eax,eax<br />	mov ecx,1<br />	@@&#58;<br />	mov al,&#91;ebx&#93;<br />	inc ebx<br />	.if eax==Delimiter<br />		inc ecx<br />	.endif<br />	or al,al<br />	jnz @B<br />	sub ebx,StrIn<br />	mov StrInLen,ebx<br />	mov StringsNum,ecx<br />	lea ebx,&#91;ebx+ecx*4+4&#93;<br />	invoke HeapAlloc,HEAP1,0,ebx  ; assuming HEAP1 is a heap you've already created <br />	; invoke malloc,ebx  &lt;-- this is what the above stuff needs to do<br />	mov ReturnedArray,eax<br />	mov ecx,StringsNum<br />	lea ebx,&#91;eax+ecx*4+4&#93;<br />&#91;color=blue&#93;<br />	push ebx<br />	mov eax,StrIn<br />	@@&#58;<br />	mov cl,&#91;eax&#93;<br />	mov &#91;ebx&#93;,cl<br />	inc eax<br />	inc ebx<br />	or cl,cl<br />	jnz @B<br />	pop ebx<br />&#91;/color&#93;<br />	mov eax,ReturnedArra<br />	mov edx,eax<br />	<br />	mov &#91;edx&#93;,ebx<br />	mov ecx,1<br />	xor eax,eax<br /> _again&#58;<br />	mov al,&#91;ebx&#93;<br />	inc ebx<br />	.if al==Delimiter<br />		mov byte ptr&#91;ebx-1&#93;,0<br />		mov &#91;edx+ecx*4&#93;,ebx<br />		inc ecx<br />	.endif<br />	or al,al<br />	jnz _again<br />	mov dword ptr&#91;edx+ecx*4&#93;,0<br />	mov eax,ecx  ; EAX holds the number of strings found<br />	mov ebx,ReturnedArray ; this is the actual array pointer.  <br />	; The first EAX+1 DWORDs contain pointers to the strings, the last DWORD of which is 0 <br />	; &#40;in case we forgot how many the strings in the array are&#41;<br />	; use HeapFree  or &quot;free&quot; to free this memory when you've finished using it <br />	ret<br />Split endp<br /></code></pre></div>
    <div class="meta">Posted on 2004-03-02 12:57:46 by Ultrano</div>
   </div>
  </div>
 </body>
</html>