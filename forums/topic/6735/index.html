<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Small bag-o-questions - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=6735" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=6735">Small bag-o-questions</a></p>
   <div class="post" id="post-48685">
    <div class="subject"><a href="#post-48685">Small bag-o-questions</a></div>
    <div class="body">Well I am learning!  (slowly bet hey, bettern nothing :grin:).<br />I think they are all fairly quick ones.<br /><br />1&gt;<br />Can the stack frame be modified on the fly to support multiple calls?<br /><br />I am just curious to see if my intuition on this is way off or not.  I can imagine a fairly good<br />speed savings on multiple API calls if you could.  Say I was loading up two images...<br /><br />(I have yet to start messing around with the frames yet, so maybe it should be subtraction)<br /><br /><pre><code><br />WndProc proc uses ebx hWnd&#58;dword, uMsg&#58;dword, wParam&#58;dword, lParam&#58;dword<br />	; save stack position<br />	mov ebx, ebp<br /><br />	; initial API call<br />	invoke LoadImage, hInstance, id1, IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR<br />	<br />	; fix stack back to before last API call<br />	add ebp, 12<br />	<br />	; replace id1 with id2 and call again<br />	mov &#91;ebx+4&#93;, id2<br />	call LoadImage<br /><br />	.<br />	.<br />	.<br /></code></pre><br /><br />2&gt;<br />I have an array of 22 button structures defined like so:<br />ToolInfo TBBUTTON 22 dup(&lt;&gt;)<br /><br />I am having a little trouble coming up with a good way (efficient) to access an<br />individual elements of this.  Right now I have this (which works good).  Just looking<br />for a faster, better algo.<br /><br />Note: hCurrToolInfo = index into TBBUTTON structure<br /><br /><pre><code><br />; make ecx point to our structure in memory &#40;22 TBBUTTON's&#41;<br />mov eax, hCurrToolInfo<br />mov ecx, SIZEOF TBBUTTON<br />mul ecx<br />lea ecx, &#91;ToolInfo&#93;<br />add ecx, eax<br /><br />; make eax point to the structure passed to us &#40;TBNOTIFY&#41;<br />mov eax, lParam<br />add eax, SIZEOF NMHDR<br />add eax, 4<br /><br />; copy ours to thiers					<br />invoke RtlMoveMemory, eax, ecx, SIZEOF TBBUTTON<br />mov eax, lParam<br />mov &#91;TBNOTIFY ptr &#91;eax&#93;&#93;.pszText, 0<br /><br />xor eax, eax<br />inc eax<br />ret<br /></code></pre><br /><br />Thanks for all replies.  I would try and do more with the second question, but I cant at the moment...</div>
    <div class="meta">Posted on 2002-07-18 18:22:31 by Graebel</div>
   </div>
   <div class="post" id="post-48688">
    <div class="subject"><a href="#post-48688">Small bag-o-questions</a></div>
    <div class="body">1) I don't see any problems with modifying the stack on the fly, but there are some things to be wary of. Namely, make sure your proc doesn't modify any of the values on the stack (I don't think any of the APIs do this) and make sure you have the same number of parameters on both calls.<br /><br />I haven't done this myself, but these two things pop into my mind.<br /><br />2)<br /><br /><pre><code><br />mov eax,hCurrToolInfo<br />imul eax,sizeof TBBUTTON<br />lea ecx,&#91;eax+ToolInfo&#93;<br /><br />or<br /><br />mov eax,hCurrToolInfo<br />lea eax,&#91;4*eax+eax&#93;<br />lea ecx,&#91;4*eax+ToolInfo&#93;<br /><br /></code></pre><br /><br />Since TBBUTTON is 14h == 20 decimal you can use the latter version (it's bound to be faster). Also, you don't wipe out edx this way (if that matters to you). In fact, you don't really need to use eax at all, you can do it all with ecx.<br /><br /><pre><code><br />mov eax,lParam<br />add eax,4+sizeof NMHDR<br /></code></pre><br /><br />Not much of an optimation to be sure, but since sizeof NMHDR is a constant, it'll work just fine (the assembler will just add it up for you)<br /><br />--Chorus</div>
    <div class="meta">Posted on 2002-07-18 18:45:24 by chorus</div>
   </div>
   <div class="post" id="post-48696">
    <div class="subject"><a href="#post-48696">Small bag-o-questions</a></div>
    <div class="body">Hrm, you're messing with EBP while the stack is ESP...<br />Parameter reuse is possible with C calling convention,<br />but STDCALL has the proc clean the stack. While you can<br />&quot;sub esp, xx&quot; to &quot;get the parameters back&quot;, something could<br />(theoretically) have interrupted your thread and trashed<br />the stack parms in the meanwhile. Not too likely though,<br />I only think this would happen if your program is running<br />through a (ring3) debugger - and not even necessarily then.<br />I don't seee the big deal about a few pushes, though... when<br />you're dealing with API calls, the overhead of a few pushes<br />is miniscule compared to the time executing the API (most<br />of the time anyway). It's been said before but I'll say it<br />again - optimize where it matters :).<br /><br />Now, with your code, you will have a standard stack frame<br />constructed, the usual<br /><br /><pre><code><br />; auto-generated by masm<br />push	ebp<br />mov	ebp, esp<br />; your code starts here<br />mov	ebx, ebp ; now ebx=ebp=esp = pointer-to-pushed-ebp<br /></code></pre><br />Later in your code, you do &quot;mov , id2&quot;. Isn't this<br />going to trash your return-eip ?</div>
    <div class="meta">Posted on 2002-07-18 20:18:44 by f0dder</div>
   </div>
   <div class="post" id="post-48701">
    <div class="subject"><a href="#post-48701">Small bag-o-questions</a></div>
    <div class="body"><div class="quote"><br />Hrm, you're messing with EBP while the stack is ESP...<br />...<br />Later in your code, you do &quot;mov , id2&quot;. Isn't this<br />going to trash your return-eip ?<br /></div><br /><br />Ahh, ESP is the stack... well like I said I havnt really looked<br />into it all that closely yet.  I remember those two mentioned<br />from other posts.<br /><br />Anywho I completely trashed that first example.  I shouldnt<br />have been using EBP and I was saving the wrong stack<br />position to boot.  If I understand everything correctly, then<br />the below code should be very close to what I was originally<br />thinking of.<br /><br /><pre><code><br />WndProc proc uses ebx hWnd&#58;dword, uMsg&#58;dword, wParam&#58;dword, lParam&#58;dword<br />	; initial api call<br />	push LR_DEFAULTCOLOR<br />	push 0<br />	push 0<br />	push IMAGE_BITMAP<br />	push id1<br />	push hInstance<br />	; &lt;-- save ESP here<br />	mov ebx, esp<br />	call LoadImage<br /><br />	; fix stack back to before last API call<br />	mov esp, ebx<br />	<br />	; replace id1 with id2 and call again<br />	mov &#91;ebx+4&#93;, id2<br />	call LoadImage<br />	.<br />	.<br />	.<br /></code></pre><br /><br />And yeah, its just a few pushes, but if I dont mess around enough<br />with this kind of code I wont have a clue as to how to really optimize<br />the code that really needs it.  In my book the more tricks you can<br />pull from your hat, the better off you will be in the long run :alright:.<br /><br /><div class="quote"><br />...something could (theoretically) have interrupted your thread and<br />trashed the stack parms in the meanwhile<br /></div><br /><br />Hmm, actuall I dont understand this point.  If something interrupts my<br />thread, how does that affect my stack?  Would not the same<br />argument apply for regular based calls?  Like take the 1st example and<br />dont mess with the stack, but force an interrupt:<br /><br />push LR_DEFAULTCOLOR<br />push 0<br />push 0<br />push IMAGE_BITMAP<br />push id1<br />push hInstance<br />; &lt;-- interrupt<br />call LoadImage<br /><br />Could not the same thing happen here as well?  If not whats the<br />difference between this and the one that modifies the stack?  Looks<br />to me like they both do...</div>
    <div class="meta">Posted on 2002-07-18 21:44:49 by Graebel</div>
   </div>
   <div class="post" id="post-48707">
    <div class="subject"><a href="#post-48707">Small bag-o-questions</a></div>
    <div class="body">Well... it wouldn't happen with a &quot;normal&quot; program, because there you only have<br />data at &quot;esp+xx&quot; - while your method of stackfiddling has a (very small) timeframe<br />where you have data at &quot;esp-xx&quot; (&quot;unallocated&quot; stack space). Now I don't really<br />think that windows will mess with your stack, interrupts should have their own<br />ring0 stacks and such, and I don't think debuggers these days have a need to<br />store stuff temporarily in the user stack - but one never knows :).</div>
    <div class="meta">Posted on 2002-07-18 22:24:11 by f0dder</div>
   </div>
   <div class="post" id="post-48712">
    <div class="subject"><a href="#post-48712">Small bag-o-questions</a></div>
    <div class="body">Well I can kindof understand what your saying.  However I guess I dont yet<br />see where the problem might be.  Consider:<br /><br /><pre><code><br />WndProc proc uses ebx hWnd&#58;dword, uMsg&#58;dword, wParam&#58;dword, lParam&#58;dword<br />	; initial api call<br />	push LR_DEFAULTCOLOR<br />	push 0<br />	push 0<br />	push IMAGE_BITMAP<br />	push id1<br />	push hInstance<br />	&lt;POINT1&gt;<br />	; &lt;-- save ESP here<br />	mov ebx, esp<br />	call LoadImage<br /><br />	; fix stack back to before last API call<br />	; &lt;POINT2&gt;<br />	mov esp, ebx<br />	; &lt;POINT3&gt;<br />	<br />	; replace id1 with id2 and call again<br />	mov &#91;ebx+4&#93;, id2<br />	call LoadImage<br /></code></pre><br /><br />If I get interrupted right before I modify the stack &lt;POINT2&gt; then it would be the<br />same as if it was interrupted in any normal program and nothing should happen<br />because the stack is balanced.<br /><br />If I get interrupted right after at &lt;POINT3&gt; then to the other program it would look<br />the same as if I had been interupted at &lt;POINT1&gt; right?  To me this looks like it<br />could happen even if I was not modifying the stack at all.<br /><br />To me, either way, this type of code looks the same as any other normal series<br />of events a program goes through so if it works in one dont see a reason why it<br />wouldnt in the other...<br />:confused:</div>
    <div class="meta">Posted on 2002-07-18 22:41:01 by Graebel</div>
   </div>
   <div class="post" id="post-48715">
    <div class="subject"><a href="#post-48715">Small bag-o-questions</a></div>
    <div class="body">If you get interrupted at POINT1, no harm done, as all the<br />values on your stack are above the stack pointer. Other code<br />pushing values will not interfere with your stack contents.<br />If you get interrupted at POINT2, you have data on the stack<br />that are below the stack pointer - other code doing push would<br />trash your values on the stack. Perhaps this isn't very likely<br />to happen (was in the DOS days though), but I'm not taking any<br />chances in *my* code :). Also, what if the proc you're calling<br />has modified the parms on the stack? It's quite legal to do so,<br />and I do it often in my code to avoid temporary local variables<br />etc. And just because API calls don't do it now, nobody says<br />they can't do it in the future - save a few clocks but risk<br />your app breaking on a different windows build, is it worth it?<br />Of course it can be done when calling your own procs where you<br />know time is critical, but imho if time is so critical, you ought<br />to not be calling a proc, but rather using a macro, or restructure<br />your program.</div>
    <div class="meta">Posted on 2002-07-18 22:50:26 by f0dder</div>
   </div>
   <div class="post" id="post-48716">
    <div class="subject"><a href="#post-48716">Small bag-o-questions</a></div>
    <div class="body">Ahh, I had not considered the case where the API (or other) might<br />modify the stack variables itself.  I can see where this would be<br />both practical and useful.<br /><br />Thanks f0dder, learned a good deal on the inner workings of things<br />and I did end up with a new trick :grin:<br /><br />Oh yes, and thank you also chorus.  I have not had alot of luck in<br />understanding lea.  I knew the bare basics on it but was never able<br />to use it to its full potential.  And whats even better, after a couple<br />of minutes of running those variables around in my head, I actually<br />understood both of those.  I like the second example better myself.</div>
    <div class="meta">Posted on 2002-07-18 23:12:52 by Graebel</div>
   </div>
  </div>
 </body>
</html>