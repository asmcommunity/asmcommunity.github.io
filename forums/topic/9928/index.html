<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>compare register for value question - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=9928" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=9928">compare register for value question</a></p>
   <div class="post" id="post-74101">
    <div class="subject"><a href="#post-74101">compare register for value question</a></div>
    <div class="body">Ok, in my code I have been using:<br /><br /><pre><code><br />cmp    eax, 0<br />je       DoSometing<br /><br />or <br /><br />cmp    eax, 1<br />je       DoSomething<br /><br />reading the MASM docs I read that using or produces smaller and faster code<br />or       eax, eax<br />jz        DoSomething<br /><br />or<br /><br />or       eax, eax<br />jnz      DoSomething<br /></code></pre> <br /><br />Well, I changed my code to or and shaved off quite a bit of bytes, is this the best way to test for something?  Gonna read Agner's help file now to see what else I can learn....</div>
    <div class="meta">Posted on 2003-01-02 21:25:45 by Gunner</div>
   </div>
   <div class="post" id="post-74105">
    <div class="subject"><a href="#post-74105">compare register for value question</a></div>
    <div class="body">test eax, eax<br />jz EAX_equals_zero<br /><br /><br />or<br /><br /><br />dec eax<br />jz EAX_equals_one<br />inc eax</div>
    <div class="meta">Posted on 2003-01-02 21:53:09 by bitRAKE</div>
   </div>
   <div class="post" id="post-74113">
    <div class="subject"><a href="#post-74113">Re: compare register for value question</a></div>
    <div class="body"><div class="quote"><br /><br />Well, I changed my code to or and shaved off quite a bit of bytes, is this the best way to test for something?  Gonna read Agner's help file now to see what else I can learn.... </div><br /><br />Hi<br /><br />I use a little routine for measuring execution speed and paring off those bloated bytes that I put together from a few code examples from others on this board, so credit goes to those I scammed the information and syntax from ;).  I don't know if a fully optimized RDTSC routine might be more precise, but this is at least more accurate than GetTickCount.  The first time you run your code it won't be representative because of the cacheing effects Agner describes.  I recently hardcoded my own lstrcpy/len/cat routines and found a big difference over the API versions. Hope this can help, maybe something like this could be put into the FAQ section?<br /><br />Regards,<br />Kayaker<br /><pre><code><br />; =======================================<br />; Routine for measuring the execution speed of a proc<br />; =======================================<br /><br />; include TickRoutine.asm<br />; INVOKE StartTick<br />; code to be measured<br />; INVOKE EndTick<br /><br />include \masm32\include\masm32.inc	; for FloatToStr routine	<br />includelib \masm32\lib\masm32.lib<br /><br />StartTick	proto<br />EndTick		proto<br /><br />;----------------------------------------------------<br /><br />msgCaptionTicks		db &quot;Execution Speed in ms&quot;,0<br /><br />lpPerformanceFrequency	QWORD ?<br />CountsPerSec		QWORD ?<br />lpPerformanceCount	QWORD ?<br />StartCount		QWORD ?<br />EndCount		QWORD ?<br />ExecutionTime		QWORD ?<br />msec			DWORD ?<br /><br />bufferTicks		db 32 dup&#40;?&#41;<br /><br />;===============StartTick Proc===================<br />StartTick proc<br /><br />pushad<br />finit					; initialize FPU<br /><br />; -------------------------------------------------------------<br />; Get the frequency of the high-resolution performance counter<br />; -------------------------------------------------------------<br />	<br />invoke QueryPerformanceFrequency, offset lpPerformanceFrequency<br /><br />fld qword ptr &#91;lpPerformanceFrequency&#93;<br />	; push result onto top of FPU stack st&#40;0&#41;<br />fstp qword ptr &#91;CountsPerSec&#93;<br />	; store value in st&#40;0&#41; into variable<br /><br />; -------------------------------------------------------------<br />; Get the starting tick value<br />; -------------------------------------------------------------<br /><br />invoke QueryPerformanceCounter, offset lpPerformanceCount<br /><br />fld qword ptr &#91;lpPerformanceCount&#93;<br />fstp qword ptr &#91;StartCount&#93;<br /><br />popad		<br />ret<br />StartTick endp	<br />;===============End StartTick Proc===============<br /><br /><br />;===============EndTick Proc===================<br />EndTick proc<br /><br />pushad<br />; -------------------------------------------------------------<br />; Get the ending tick value<br />; -------------------------------------------------------------<br /><br />invoke QueryPerformanceCounter, offset lpPerformanceCount<br /><br />fld qword ptr &#91;lpPerformanceCount&#93;<br />fstp qword ptr &#91;EndCount&#93;<br /><br />; -------------------------------------------------------------<br />; The time in seconds between the two <br />; QueryPerformanceCounter calls is<br />; &#40;EndCount - StartCount&#41; / CountsPerSec<br />; -------------------------------------------------------------<br /><br />fld qword ptr &#91;EndCount&#93;	; load EndCount to st&#40;0&#41;<br />fsub qword ptr &#91;StartCount&#93;	; sub StartCount from st&#40;0&#41;<br />fdiv qword ptr &#91;CountsPerSec&#93;	; divide result by CountsPerSec<br />mov msec, 1000		; shift decimal place to milliseconds<br />fimul msec			; multiply result in st&#40;0&#41; by 1000<br />fstp qword ptr &#91;ExecutionTime&#93; ; store result in st&#40;0&#41; to variable<br /><br />; -----------------------------------------------------------<br />; Convert floating point result to a string using<br />; masm32lib function FloatToStr<br />; -----------------------------------------------------------<br /><br />invoke FloatToStr, qword ptr &#91;ExecutionTime&#93;, offset bufferTicks<br /><br />; --------------------------------------<br />; Display it<br />; --------------------------------------<br /><br />invoke MessageBox, NULL, offset bufferTicks, offset msgCaptionTicks,\<br />MB_OK+MB_ICONINFORMATION+MB_TASKMODAL+MB_TOPMOST<br />	<br />finit					; reinitialize FPU<br />		<br />popad<br />ret<br />EndTick endp	<br />;===============End EndTick Proc================<br /></code></pre></div>
    <div class="meta">Posted on 2003-01-03 01:15:53 by Kayaker</div>
   </div>
  </div>
 </body>
</html>