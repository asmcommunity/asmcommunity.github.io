<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>MX Octree demo - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25702" />
    <link rel="next" href="../?id=25702&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25702">MX Octree demo</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=25702&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=25702&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="25702" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=25702&amp;page=2">&gt;</a><a href="../?id=25702&amp;page=2">&raquo;</a></form>   <div class="post" id="post-187531">
    <div class="subject"><a href="#post-187531">MX Octree demo</a></div>
    <div class="body">The attached demo code imports geometry from an XFile (collapses mesh hierarchy but preserves materials and FVF etc), and generates an MX Octree from it.. blisteringly fast.. fast enough for realtime, and&nbsp; typically generates FAR fewer &#39;splits&#39; than bsp does.<br /><br />All the democode I had seen for MX octrees involved distributing POINTS in space, not FACES - I reworked a bit of my bsptree code to cut faces against planes where necessary.<br /><br />Right now you are probably thinking &quot;I know what an octree is - but what&#39;s an MX Octree, and how does it differ from a conventional one?&quot;<br /><br />Conventional octrees define a boundingbox around the entire set of input faces, and then chop that BBox into 8 child nodes (known as &#39;octants&#39;).. the input set of faces is then inserted into the 8 octants by testing the faces against the (smaller) octant boxes.<br /><br />MX octrees define the implicit origin of the BBox, rather than its explicit corners - imagine a 3D crosshair in the middle of the input set of faces, now test each face against that crosshair - we&#39;re performing &quot;point-point tests&quot; instead of &quot;box-poly tests&quot;, and consequently its MUCH faster.<br /><br />MX octrees are more suited to situations where the faces are not evenly distributed in worldspace, ie there are large regions containing relatively few polygons, and smaller regions which are more densely populated.. They are just great for outdoor scenes.<br /><br />The result is almost IDENTICAL to the output of a conventional octree generator, it&#39;s just a LOT faster to produce.<br /><br />This demo has the input xfile&#39;s name hardcoded into it, that&#39;s because this code is brand spanking new .. I&#39;ll spend a couple of days importing my &#39;Frustum Culling&#39; code into it, and then we&#39;ll be able to begin taking advantage of the octree&#39;s structure, which is in essence a hierarchy of boundingboxes .. if a given node&#39;s BBox intersects the camera frustum, then it and its children are potentially visible .. but if a given node&#39;s BBox does NOT intersect the frustum, then that node, and any children, are not visible, and don&#39;t need to be rendered :)<br /><br />I have already identified a couple of ways to speed up this code even more, but please feel free to comment, make suggestions, criticisms, etc.<br />Also note that as usual, this code is unlicensed, feel free to steal my source and use it in any way you see fit.<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2226" target="_blank">Octree070115.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-01-14 23:54:17 by Homer</div>
   </div>
   <div class="post" id="post-187542">
    <div class="subject"><a href="#post-187542">Re: MX Octree demo</a></div>
    <div class="body">The reason that I used tiger.x in this demo is that this model is rather small - the values of its vertices are very small numbers.<br />When we start chopping the model up into octants, those numbers very quickly become very much smaller - and here lies the greatest danger for any spatial subdivision implementation - when numbers are very large or very small, they are highly sensitive to numerical drift.<br />When I tried reducing the maximum allowable number of faces per node to a value below 100, things start to go wrong.<br />The major problem I identified today involves the code which handles those faces found to be coplanar with a splitting plane - when the numbers get too small, the reclassification fails.<br />I replaced that code with the following (at line 47 in SplitTriangleWithPlane)<br /><br /><pre><code><br />;Compare Face Normal to Plane Normal<br />;How different are the angles?<br />lea eax,vtemp<br />Vec3Dot eax,pFace<br />fstp vtemp.x<br />fMin vtemp.x,fEpsilon	;if less than epsilon, we&#39;ll consider it zero<br />fstpReg eax<br />.if eax==vtemp.x		;if its zero (or close enough), return Front<br />&nbsp; return FRONT<br />.endif<br />return BACK<br /></code></pre><br /><br />Also, I added a couple of lines of code to the BuildOctreeNode function so that we stop recursing when fHalfRadius is less than fEpsilon. Without that, all hell breaks loose since our octants are actually smaller than the tolerance (thickness) of our planes.<br /><br />This kind of logic must also be applied to faces themselves.<br />When a face is split, I should check if the output fragments are &#39;legal&#39; either by checking their Area against some minimum value, or by checking their edge lengths against fEpsilon.<br />If we find that a split has produced triangles which fail such a safety check, we should discard our split triangles in favour of their parent face (which we split), and place the entire parent on BOTH sides of the plane.<br /><br />These actions will prevent the creation of triangles which would be problematic in regards to collision detection and any other tests that are prone to numerical error, and since we put offending faces in BOTH neighbour octants, they&#39;re available for testing with respect to both the nodes they share.<br /><br />Do you agree that the above statements seem sound?<br />What do you think?<br /></div>
    <div class="meta">Posted on 2007-01-15 08:00:33 by Homer</div>
   </div>
   <div class="post" id="post-187548">
    <div class="subject"><a href="#post-187548">Re: MX Octree demo</a></div>
    <div class="body">I&#39;m considering adding a little more code that would effectively allow this MX octree to be &#39;adaptive&#39;. We allow the node origins (those imaginary crosshairs) to be repositioned slightly for the purpose of avoiding splitting of faces.<br />In order to achieve this feat, my solution would involve creating three lists of &#39;axial span values&#39; which represent the axial ranges covered by the input faces (kinda like a spanbuffer).<br />These three lists would require sorting, and then from the sorted list we can determine where along that axis we ought to place our axial splitting plane.. do this for all three major axes, and we have our new origin. The cost might seem high - the input faces are sorted a total of 9 times per output node - but with a little effort these lists can be sorted just once and maintained throughout the treegen process.<br />Regardless, they&#39;re still cheaper than the popular method used to choose a splittingplane in a bsptree gen (comparing every face against the plane of every other face).<br /><br />Your thoughts?</div>
    <div class="meta">Posted on 2007-01-15 17:24:31 by Homer</div>
   </div>
   <div class="post" id="post-187618">
    <div class="subject"><a href="#post-187618">Re: MX Octree demo</a></div>
    <div class="body">Fixed a small bug in the coplanar handling code I posted the other day..still haven&#39;t implemented any proposed changes (such as split avoidance).<br /><br />I created a small demo &#39;terrain&#39; mesh, roughly 3300 vertices.<br />When I generate an octree from this, with a faces-per-node limit of around 100, I end up with around 20k faces (didn&#39;t check how deep the tree was, but it&#39;s quite shallow, something like 4).<br /><br />Does this seem like a reasonable result?<br /><br />What is a reasonable max. number of faces per node?<br />I think 100 is probably a bit overzealous for a &#39;real game level&#39; where we might have something like 100k faces BEFORE treating them to the treebuilding/facesplitting algorithm..<br />Anything less than 50 creates quite a deep tree, and MANY more split faces, which makes sense to me, and is quite unreasonable.<br /><br />I can&#39;t find anything on google to benchmark against :(<br /><br /><br />I just tried increasing the test model&#39;s resolution to 8192 faces, and again used a limit of max. 100 faces per node, this time I generated 29k faces at about the same tree depth.. looks like the EXISTING algorithm scales well to larger inputs :) <br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2232" target="_blank">test.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-01-18 23:24:13 by Homer</div>
   </div>
   <div class="post" id="post-187620">
    <div class="subject"><a href="#post-187620">Re: MX Octree demo</a></div>
    <div class="body">What&#39;s really sad, for me, is, not too many years ago, you and I could have had a down and dirty mixture of good discussion and code swapping cause I was so into this stuff.&nbsp; You just came around maybe 10 years too late for me, Homer.</div>
    <div class="meta">Posted on 2007-01-19 00:17:46 by drhowarddrfine</div>
   </div>
   <div class="post" id="post-187621">
    <div class="subject"><a href="#post-187621">Re: MX Octree demo</a></div>
    <div class="body">I&#39;ve just been reading a paper which talks about using a &#39;covariance matrix&#39; to calculate the best ARBITRARY splitter plane by analyzing the distribution of the input data.<br />This, in combination with a KDTree algorithm, would beat the hell out of adaptive mx octree, yet still retain all the benefits of a BSP.<br />However I have not found any actual implementation of it, so it&#39;s probably pie in the sky.<br /></div>
    <div class="meta">Posted on 2007-01-19 00:29:18 by Homer</div>
   </div>
   <div class="post" id="post-187624">
    <div class="subject"><a href="#post-187624">Re: MX Octree demo</a></div>
    <div class="body">Just added a new function called &quot;IsLegalFace&quot;..<br />Whenever we create &#39;fragment&#39; faces (by splitting a input face), we check the lengths of the three edges of those fragments to make sure that the length is larger than fEpsilon.<br />Triangles with edges smaller than fEpsilon are considered &#39;illegal&#39;.<br /><br />I have found that yes, I am generating illegal geometry.<br />Since I haven&#39;t applied this check to the input set of faces themselves, I can&#39;t yet tell if I&#39;m actually IMPORTING some illgal faces, but it sure would seem to be the case, because I&#39;m seeing fragments with one edge of ZERO LENGTH (two vertices are exactly the same values).<br />That would not suprise me at all since I used MAYA to generate the test model, and it probably contains &#39;dummy triangles&#39; to facilitate &#39;stripification&#39; for accelerated rendering purposes.<br /><br />Later today I&#39;ll be adding code to check for illegal faces within the Xfile Importer function, and simply throwing away any faces deemed to be illegal during that phase.<br />Having done that, if I STILL see illegal faces being generated, then I&#39;ll be re-evaluating my proposed &#39;split avoidance&#39; mechanism in order to deal with these nasty little buggers.<br /><br /></div>
    <div class="meta">Posted on 2007-01-19 01:34:58 by Homer</div>
   </div>
   <div class="post" id="post-187630">
    <div class="subject"><a href="#post-187630">Re: MX Octree demo</a></div>
    <div class="body">I&#39;ve attached an update.<br />The hardcoded name of file being tested is &#39;test.x&quot;<br />If this version sees an illegal face being imported from the demo xfile, it will issue a debug warning, then crap out and die unceremoniously.<br />If no illegal faces are imported, it will try to generate mx octree from imported data as usual.<br />If any illegal faces are created during octree generation, it similarly complains and terminates.. no apologies, no excuses.<br />I&#39;m determined to find the best way to deal with these &#39;chips&#39;, and a little worried that maybe somewhere my tri-splitter functions are broken and are causing them, I need to add more debugging I guess.<br /><br /><br />I believe I can &#39;predict&#39; chips before they are generated.<br />In fact I&#39;ve got two different algo variants in mind.<br />Gotta think them both out.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2236" target="_blank">Octree070119.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-01-19 04:29:24 by Homer</div>
   </div>
   <div class="post" id="post-187634">
    <div class="subject"><a href="#post-187634">Re: MX Octree demo</a></div>
    <div class="body">I haven&#39;t implemented &#39;illegal chip prediction&quot; yet..<br />Instead, I have implemented &quot;illegal chip handling&quot; via a new case of &quot;SPLIT_NOT_POSSIBLE&quot;..<br />When I detect a that triangle is unable to be split against a plane (because it would generate illegal chips),&nbsp; I simply leave it hanging around in the input collection, so that it&#39;s &#39;been stored in the first node that it totally fits within&quot;.<br />Now, when the tree generation is completed, faces may be found at ANY depth, not just in the leaves... <br />-Faces in non-leaf nodes are the ones that we decided it was a bad idea to split since doing so would generate illegal chips.. <br />-Faces in leafnodes have been clipped to the node&#39; splittingplanes.<br /><br />The result is a bit slower, but look on the bright side.. all the faces we did generate are guaranteed to not be &quot;mutants&quot;, and the number of new faces and new vertices are a good deal lower :)<br /><br />I&#39;m being quite overzealous about my error detection now I think :P<br />I&#39;ll post an update tomorrow when I&#39;ve had time to test properly.<br /><br /></div>
    <div class="meta">Posted on 2007-01-19 09:37:22 by Homer</div>
   </div>
   <div class="post" id="post-187646">
    <div class="subject"><a href="#post-187646">Re: MX Octree demo</a></div>
    <div class="body">The attached update contains the changes for identifying and eliminating &#39;illegal chips&#39; by leaving offending faces in the parent nodes.<br />Recursion terminates when all octants (child nodes) contain fewer than 100 polygons, or when the nodesize falls below fEpsilon (our planar tolerance or &#39;thickness&#39;).<br /><br />My personal benchmarks are as follows:<br /><br />Without IllegalChip Handling<br />2k input faces = 20k sorted faces<br />8k input faces = 29k sorted faces<br /><br />With IllegalChip Handling<br />2k input faces = 16k sorted faces<br />8k input faces = 22k sorted faces<br /><br /><br />Cleaned up the code a little - removed unnecessary face validations.<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2239" target="_blank">Octree070120.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-01-19 17:59:27 by Homer</div>
   </div>
   <div class="post" id="post-187649">
    <div class="subject"><a href="#post-187649">Re: MX Octree demo</a></div>
    <div class="body">I&#39;ve updated the previous attachment - there was a rather serious memory leak which has been fixed.<br />Since my face-splitting code is itself recursive in nature, I must release any fragments which are &#39;subsequently split&#39;. I was releasing input faces that got split, but not the intermediate fragments that got re-split.<br />&nbsp; </div>
    <div class="meta">Posted on 2007-01-19 22:38:34 by Homer</div>
   </div>
   <div class="post" id="post-187654">
    <div class="subject"><a href="#post-187654">Re: MX Octree demo</a></div>
    <div class="body">I&#39;ve written some code to save the generated octree to a custom datafile, and some code to recreate the tree from a datafile.<br />The file format is fairly compact (for example, the 8 octant pointers for a node are encoded as a single byte) but could certainly be a lot smaller than it is.. not really critical at the moment.<br /><br />I should be able to get some simple render code added next, which renders the reloaded octree data (probably using sluggish DrawPrimitiveUP). We&#39;ll worry about render optimizing soon enough.<br /><br />Update coming soon !!</div>
    <div class="meta">Posted on 2007-01-20 02:09:02 by Homer</div>
   </div>
   <div class="post" id="post-187804">
    <div class="subject"><a href="#post-187804">Re: MX Octree demo</a></div>
    <div class="body">Found some time this afternoon to add code for &#39;fast frustum extraction via matrix deformation of a unit cube&#39;.<br /><br />The attached update calculates the frustum, and has been set up to recalculate it whenever the camera view changes (via a boolean flag)..&nbsp; since this example currently contains no code for &#39;moving&#39; or &#39;rotating&#39; the camera view, the frustum never requires recalculation, and so it doesn&#39;t occur.<br /><br />The next update will probably contain some crude camera controls and &#39;something&#39; being rendered (so we can test the camera controls).<br />After that I&#39;ll implement frustum culling apon our &#39;something&#39;.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2245" target="_blank">Octree070128.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-01-27 10:00:43 by Homer</div>
   </div>
   <div class="post" id="post-187917">
    <div class="subject"><a href="#post-187917">Re: MX Octree demo</a></div>
    <div class="body">Sorry about the delay..two small bugs, much pain later..<br /><br />I discovered a small problem in the function used for extracting the View Frustum&#39;s 6 planes from the current camera view/proj matrices.<br />The problem was that the fDistance values in those Planes were actually negative (ie -fDistance).<br /><br />My test rendering code didn&#39;t seem to work, so I decided to split the project : the code previously posted (&#39;Project A&#39;) is now considered to be the &#39;octree generator tool&#39; - it takes an input XFile, and spits out an Octree saved in a custom file format.<br />The attachment (&#39;Project B&#39;) contains some VERY crude camera code, the &#39;bugfixed&#39; Frustum code, some code for loading the custom file (not yet being used), some proven working demo render code, and enough code to test arbitrary points against the frustum (ie, is point P inside or outside the current view frustum).<br />I&#39;ve rigorously tested the Frustum code, and I&#39;m satisfied that its fine, so long as your &#39;near plane distance&#39; is greater than zero.<br />If you use zero for the near plane, then the Frustum isn&#39;t really a deformed cube anymore, its a pointy pyramid, with the near four vertices collapsed into a singularity at the Eye Position... d&#39;oh.<br /><br />Next I&#39;ll add code to test whether arbitrary Nodes of the Octree are inside or outside the frustum, and we&#39;ll begin thinking about rendering of node content.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2247" target="_blank">D3D_Demo070202.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-02-02 01:35:03 by Homer</div>
   </div>
   <div class="post" id="post-187922">
    <div class="subject"><a href="#post-187922">Re: MX Octree demo</a></div>
    <div class="body"><br />Got your thinking hat on?<br /><br />The next task is to devise the fastest possible test(s) for Octree visibility. First, let&#39;s talk about the &#39;mathematical tools&#39; we have in our arsenal which are potentially useful in regards to this problem.<br /><br />A) Point/Octant testing via ClassifyPointOctant<br />This function currently resides in &#39;Project A&#39;.. it&#39;s really fast :)<br /><br />B) Sphere/Octant testing via modified ClassifyPointOctant<br />With a little work, ClassifyPointOctant could be modified to return the &#39;shortest Axial Distance to CuttingPlane&#39;, which can then be compared to a sphere radius value.. that&#39;ll make more sense shortly.<br />The modified version would also be quite fast.<br /><br />C) Point/Plane testing via ClassifyPointPlane<br />This is a little expensive as it needs a DotProduct operation.<br /><br />D) Sphere/Plane testing via modified ClassifyPointPlane<br />The ClassifyPointPlane function can not only tell us which &#39;side&#39; or &#39;halfspace&#39; of a Plane contains a given Point, it also calculates the actual distance from the Point to the Plane along the Normal of that plane (which is always the SHORTEST DISTANCE). The version I&#39;ve provided so far can EASILY be modified to return that distance value.<br />We merely need to check that Distance is &gt;= fSphereRadius... if the distance is less than the Radius, then the Sphere intersects the Plane.<br /><br />Now we have a realistic looking set of utility functions, we can begin to devise our algorithm. Since point-based tests are cheap, I&#39;m going to suggest immediately that we wrap every Octant in a theoretical BoundingSphere, ignoring the fact that they overlap.<br />We can perform a quick test for frustum visibility of each Octant by testing its BoundingSphere against the Frustum planes.<br />This should be considered a &#39;potential visibility&#39; test, because it&#39;s not accurate - however, it errs on the side of caution.. it will sometimes return &#39;false positives&#39;.<br />For each Node that appears to intersect the Frustum, we perform more accurate tests.. We can QUICKLY test the 8 vertices of the Frustum to discover which Octants they live in.. less quickly, we can test the 8 BoundingBox vertices of a Node against the Frustum planes. Note that I&#39;ve listed the slowest stuff last.<br />Without actually spelling it out, can you see how this algorithm is beginning to take shape?<br /></div>
    <div class="meta">Posted on 2007-02-02 06:59:12 by Homer</div>
   </div>
   <div class="post" id="post-187950">
    <div class="subject"><a href="#post-187950">Re: MX Octree demo</a></div>
    <div class="body">It&#39;s important that we make the first visibility test (recursively applied to each octree node until failure) as quick and as brutal as possible.<br />I mentioned that I was considering wrapping each Node with a theoretical boundingsphere. This leads us to investigate and understand the nature of &#39;SphereTrees&#39;, and we learn that we can easily convert an Octree into a SphereTree.<br /><br />I&#39;ve modified the Octree generator code.. specifically, the recursive function called BuildOctreeNode.<br />As we know, this function is handed a set of input Faces which it then attempts to distribute into up to 8 subnodes.<br />What I&#39;ve done is add a new function call .. we calculate the BoundingSphere (radius and origin) for the input set of faces BEFORE we distribute them.<br />This boundingsphere may be larger than the node&#39;s theoretical Box (and thus overlap sibling nodes), or it may be smaller, that&#39;s totally dependant on the ACTUAL GEOMETRY of the input faces.<br />I&#39;ve added fields to the OctNode structure to store the boundingsphere radius and origin information.<br />The result of these changes is that we are in fact building a SphereTree WITHIN our Octree, at very little cost, and with the tightest possible fit over the geometry.<br />Every node including the root node has a sphere.<br /><br />I have yet to modify the customfile save/load code to match.<br /><br />Our first visibility test will be as follows:<br />(Walking the Tree from Root down as usual,)<br />If the current node&#39;s boundingsphere radius is larger than the frustum&nbsp; view depth (ie fFar - fNear), then this node could possibly contain the ENTIRE frustum, so we perform a special test to see if any of the frustum VERTICES are inside the Sphere.. if not, we return from recursion.. otherwise, we need to check each active child node.<br />If the current node&#39;s sphere radius is NOT larger than the frustum view depth, then the frustum could possibly contain the ENTIRE sphere, so we test the sphere against the frustum planes using a modified point test. We only continue recursion if the sphere is partially or totally inside the frustum, which is the whole point of the exercise.<br />By performing two kinds of testing, we can efficiently handle massive worlds and small dense regions with the same code.. I do assume that the world is a big place, after all, why else would we be performing visibility-based culling of volume hierarchies? :)<br /><br />I&#39;ve written all the testing functions I&#39;ve previously described, expect an update soon :)<br /><br />If you have questions or ideas you wish to share, please do so!<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2007-02-03 09:48:51 by Homer</div>
   </div>
   <div class="post" id="post-187973">
    <div class="subject"><a href="#post-187973">Re: MX Octree demo</a></div>
    <div class="body">I&#39;ve changed my mind, and my code.<br />The following solution offers the tightest possible fit of spheres over the geometry.<br /><br />The call to generate each node&#39;s boundingsphere is now being made AFTER the faces have been sorted into childnodes, and not before.<br />This means that only nodes which STILL contain faces after the sorting process are the nodes which have a sphere.<br />Nodes which don&#39;t contain geometry don&#39;t have a sphere.<br />These nodes are actually redundant to us !!!<br />We can trim them out of the Tree :D<br />I&#39;m not doing that yet, but I MAY do so.<br /><br />Walking the spheretree for Rendering is done as follows:<br /><br />-Render any &#39;remnant faces&#39; in the current Node<br />-For each active Child of the current Node,<br />--Test for intersection of Child&#39;s VisibilitySphere and the Frustum<br />--Recurse any child whose Sphere intersects Frustum<br />-EndFor<br />-Return from Recursion<br /><br /><br />Thus, we use the Octree links for Walking, but we use the PolygonSpheres for Visibility Testing.<br />Almost time to post updated source :)<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2007-02-04 06:34:53 by Homer</div>
   </div>
   <div class="post" id="post-187975">
    <div class="subject"><a href="#post-187975">Re: MX Octree demo</a></div>
    <div class="body">Did you notice I used the term &#39;HyperBox&#39; to describe the &#39;inverted boundingbox&#39; of a Node in our Tree?<br /><br />I say it&#39;s inverted because we defined it as a central point with three axial cutting planes passing through it - essentially, each and every one of our Boxes is &quot;infinitely big&quot; - it doesn&#39;t have any &#39;outside&#39;.<br /><br />The only sense of size is given by the &#39;stepover&#39; aka the &#39;halfwidth&#39; value which is passed down the Tree during its creation in order to guide the placement of any Child nodes.<br /><br />We&#39;re using the HyperBoxes to uniformly cut non-empty space into subspaces which may or may not be empty.<br />Our octree nodes represent a hierarchy of non-empty subspaces, and a map of empty subspaces.<br />The tight-fitting Spheres (that only exist in nodes that contain &#39;Renderables&#39;) will in most cases more accurately describe the &#39;Potentially Renderable Volume&#39; owned by a given Node.<br />Not only does this allow for more &#39;hungry&#39; culling of our tree, it means&nbsp; we use a single Sphere/Frustum test rather than an expensive Box/Frustum test (8 * point/frustum tests) to test the visibility at each Node.<br /><br />Hmmz, more accurate, more efficient AND faster?<br />I believe I&#39;ve earned myself a beer :)<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2250" target="_blank">Octree070205.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-02-04 07:07:01 by Homer</div>
   </div>
   <div class="post" id="post-187976">
    <div class="subject"><a href="#post-187976">Re: MX Octree demo</a></div>
    <div class="body">The next task:<br /><br />I must walk the generated but unsaved tree.<br />At each non-empty node, I must create a list of the vertices referenced by its faces, and then edit those faces to use the new vertices.<br />Remember that I switched from 16bit indices to 32bit indices/pointers some time ago, in order to break the 64k vertex limit?<br />We&#39;re splitting up our one (possibly huge) input vertexbuffer into lots of small vertexbuffers. This will create some duplicate vertices, but the benefit is huge:<br />it allows us to use 16 bit indices for our vertices even when we have more vertices in total than would fit in 16 bits.<br />That means a saving both in diskspace and in memory of almost 50%.<br /><br />It will require additional changes to the &#39;load&#39; and &#39;save&#39; functions.<br />Vertices will now be in a form suitable for loading (on a per-Node basis) DIRECTLY into D3D vertexbuffers for Rendering (rather than heapmem etc).. all we need is an indexbuffer constructed from the face indices at load-time.. perhaps if we saved per-node faces in a different format than we do currently.. so we could load all those indices in a chunk directly into a D3D indexbuffer also.. heh.<br /><br />Lots of pros, no obvious cons, lets do it :)<br /><br /></div>
    <div class="meta">Posted on 2007-02-04 07:22:49 by Homer</div>
   </div>
   <div class="post" id="post-187990">
    <div class="subject"><a href="#post-187990">Re: MX Octree demo</a></div>
    <div class="body">I&#39;ve completed all the proposed changes in Project A.<br /><br />When BuildOctreeNode finishes processing a Node, and that Node contains 1 or more Faces, I build a list of the vertices referenced by that faceset and store it in that Node.. while doing so, I replace the vertexpointers in those faces with indices into the new vertexlist.<br />The code for Saving the tree has been modified to suit.<br />Nodes which contain Faces have their vertices saved as a contiguous chunk of data, and their face indices are similarly saved as a contiguous block of 16-bit indices local to that node.<br />That&#39;ll make life easier in Project B, since we can load each node&#39;s renderables directly into D3D buffers as previously mentioned.<br /><br />I am disappointed to see that since the gamedev threads were merged into the Main category that my posts are receiving almost zero views.. I believe this is because nobody can find them :(<br /><br />I&#39;ll post an update in the next day or two for ProjectA, and then turn my attention back to Project B, where we&#39;ll be making changes to the Loader code im preparation for our new &#39;octospherical frustum culling&#39;.<br /><br />Gee, that sounds awful, any suggestions for a better name?<br /></div>
    <div class="meta">Posted on 2007-02-04 23:30:33 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=25702&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=25702&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="25702" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=25702&amp;page=2">&gt;</a><a href="../?id=25702&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>