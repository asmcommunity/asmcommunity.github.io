<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>switch-case implementation - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=10080" />
  <link rel="prev" href="../?id=10080&amp;page=1" />  <link rel="next" href="../?id=10080&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=10080">switch-case implementation</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=10080&amp;page=1" style="">&laquo;</a><a href="../?id=10080&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="10080" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=10080&amp;page=3">&gt;</a><a href="../?id=10080&amp;page=3">&raquo;</a></form>   <div class="post" id="post-75551">
    <div class="subject"><a href="#post-75551">switch-case implementation</a></div>
    <div class="body">Hi Everyone,<br />I finished and tried my timing program which I am sharing in the attachment to this message.  It does a timing on a search and jump of up to 100 items using my SCASD scheme, followed by the the same using the classic CMP-JE method.  Look over the code and see if I was unfair to either method.  I found that running on my box, the SCASD uses half the ticks of the RTDSC instruction than the CMP-JE method.  The program has commented jumps that can be activated to reverse the order of testing, or to test only one method.  I look forward to hearing from all of you on what you get for results.  Ratch<br /><br />Hutch,<br />I will look over the code you posted.  Ratch</div>
    <div class="meta">Posted on 2003-01-10 19:49:43 by Ratch</div>
   </div>
   <div class="post" id="post-75563">
    <div class="subject"><a href="#post-75563">switch-case implementation</a></div>
    <div class="body"><strong>Ratch</strong>, I think it would be valuable to see the time response curve for all input values.  This way we can see were the cross over point is for different processors and cache effects.<br /><br />My results:<br /><br />JumpTable: 1000 loops, 258533 cycles<br />CompareList: 1000 loops, 84819 cycles<br /><br />...and this is with the table in the cache! :confused:<br /><br />This might be biased as I threw it together really quickly.</div>
    <div class="meta">Posted on 2003-01-10 21:12:00 by bitRAKE</div>
   </div>
   <div class="post" id="post-75570">
    <div class="subject"><a href="#post-75570">switch-case implementation</a></div>
    <div class="body">Hutch,<br />I looked through the code you sent.  The code you posted sure enough implements high level SWITCH code.  But sometimes SWITCH generates unnecessary dead code. In the code you sent, I extracted the following snippet.  Notice that Case WM_CLOSE causes a superfluous JMP instruction where none is needed, because return 0 suffices to exit the WM_PAINT processing. It also appears that SCASD is faster in timing tests, at least on my box.  See my other post about this. Ratch<br /><br /><pre><code><br />      Case WM_PAINT<br />        invoke Paint_Proc,hWin<br />        return 0<br /><br />      Case WM_CLOSE<br /></code></pre></div>
    <div class="meta">Posted on 2003-01-10 21:45:59 by Ratch</div>
   </div>
   <div class="post" id="post-75574">
    <div class="subject"><a href="#post-75574">switch-case implementation</a></div>
    <div class="body">bitRake,<br />Did you use the RDTSC instruction according to <a target="_blank" href="http://cedar.intel.com/software/idap/media/pdf/rdtscpm1.pdf"> ?  How many search items did you test with?  Have you looked at my attempt at timing, and did you see anything wrong about it?  Ratch</div>
    <div class="meta">Posted on 2003-01-10 21:54:55 by Ratch</div>
   </div>
   <div class="post" id="post-75578">
    <div class="subject"><a href="#post-75578">switch-case implementation</a></div>
    <div class="body"><strong>Ratch</strong>, I've used this code to time individual instructions with very high accuracy.  It is attached below - sorry for the mess.  As I said - I just threw it together.  Ignore all the other routines in there (labeling somewhat self documenting ;) ).  You'll need VKDEBUG to view the program output.  Maybe, you can find errors in my test?  I looked at your's and you don't save EDI - which you'd have to in a WndProc.  Also, my tests are cache aligned to reduce memory effects.<br /><br />Output is now very steady at:<br /><br /><u>100 values</u><br />JumpTable:   1000 loops, 240060 cycles<br />CompareList: 1000 loops, 74012 cycles<br /><br /> I've included all to build and test yourself.<br />If you have RadASM just double-click the .RAP file :)<br /><br /> Values are hard to nail down when the data isn't cached.  I feel these numbers are mostly memory timings, but I'll post them anyway. :) These are a single uncached (code &amp; data) execution:<br /><br />100 values<br />JumpTable: 2666 cycles<br />CompareList: 2644 cycles<br /><br />1000 values<br />JumpTable: 17084 cycles<br />CompareList: 16710 cycles<br /><br />10000 values<br />JumpTable: 21931 cycles<br />CompareList: 19254 cycles<br /><br /><strong> Different story now...</strong><br /><br />JumpTable: 100 loops, 13176 cycles<br />CompareList: 100 loops, 12001 cycles<br /><br />...here each value is tested starting at 100 going to 1.<br />All data &amp; code is in the cache.  Very interesting.<br /><br />...and here with 10 to 1:<br /><br />JumpTable: 10 loops, 332 cycles<br />CompareList: 10 loops, 565 cycles<br /><br />Wow!?</div>
    <div class="meta">Posted on 2003-01-10 22:08:05 by bitRAKE</div>
   </div>
   <div class="post" id="post-75587">
    <div class="subject"><a href="#post-75587">switch-case implementation</a></div>
    <div class="body">bitRake,<br />I am having a hard time understanding your code.  Too many MACROS to sift through.  I cannot find the structure nm defined anywhere.  Another problem is the syntax nm&amp;.ldword.  I think it belongs with a call to a PROC, which I don't use and am not familiar with.  One code snippet I don't understand. <br /><pre><code><br />stopTime MACRO nm&#58;REQ<br />	pushad<br />	xor eax,eax                                                                          ;WHY ZERO OUT EAX?<br />	CPUID<br />	RDTSC<br />	IFDIF &lt;&amp;nm&gt;,&lt;OverHead&gt;                                                  ;WHAT IS THIS DOING?<br />	;; delete the overhead for startTime/stopTime<br />		sub eax,OverHead.ldword<br />		sbb edx,OverHead.hdword<br />	ENDIF<br />	add nm.ldword,eax                                                             ;SHOULDN'T THIS BE A MOV nm.ldword,eax  ?<br />	adc nm.hdword,edx<br />	popad<br />ENDM<br /></code></pre><br /><br />It would be nice if you could simplify things a bit.  I will look at it some more tomorrow.<br /><br />To answer your question about EDI. Yes I do save it, along with EBX,EBP, and ESI in my WndProc.  That is all done before and outside of the code in question.  Ratch</div>
    <div class="meta">Posted on 2003-01-11 00:07:44 by Ratch</div>
   </div>
   <div class="post" id="post-75597">
    <div class="subject"><a href="#post-75597">switch-case implementation</a></div>
    <div class="body"><strong>Ratch</strong>, the structure is at the top of the include file, <em>nm</em> is the macro parameter (a string that names the structure being used).  'xor eax,eax' seemed to fix a timing error on P3's? <em>OverHead</em> is the name of the 'do nothing' structure used to find the overhead of the timing code - which is substracted from each execution of each timed proc.  'IFDIF &lt;&amp;nm&gt;,&lt;OverHead&gt;' if the OverHead is subtracted from itself then it would be zero - not a good thing.  Add because it accumulates timing from multiple runs.  Sorry, I doubt this will ever be simplified for public consumption - it does the job for me.  You might like <strong>Maverick</strong>'s profiling code?</div>
    <div class="meta">Posted on 2003-01-11 01:12:29 by bitRAKE</div>
   </div>
   <div class="post" id="post-75598">
    <div class="subject"><a href="#post-75598">switch-case implementation</a></div>
    <div class="body">Ratch,<br /><br />You are right, it is the return macro that adds the extra code, not Greg's macro but I have no problems with an extra dead jump as it does not slow the code down any, it just makes it slightly larger and where you have a high level style of code, it is no great loss.<br /><br />For branching speed where it matters, have a look at the source I posted in this thread.<br /><br /><a target="_blank" href="http://www.asmcommunity.net/board/showthread.php?threadid=9258">http://www.asmcommunity.net/board/showthread.php?threadid=9258</a><br /><br />There will be little difference when there are only a few branches but as the count gets large, this method will show its speed advantage as it as the same branching overhead from 1 to as many as you like.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2003-01-11 01:13:10 by hutch--</div>
   </div>
   <div class="post" id="post-75608">
    <div class="subject"><a href="#post-75608">switch-case implementation</a></div>
    <div class="body"><strong></strong><br />Pals.. whatever test on a SWITCH construct must be made inputting the test sequence in a realistic manner. Surely random is more representative than a linear iteration. This is of key importance, expecially in consideration of branch prediction mechanisms.</div>
    <div class="meta">Posted on 2003-01-11 03:03:30 by Maverick</div>
   </div>
   <div class="post" id="post-75634">
    <div class="subject"><a href="#post-75634">switch-case implementation</a></div>
    <div class="body">Ratch: latency basically means &quot;how long 'til the result is ready?&quot;. Also, the decoder can only handle 1 vectorpath instruction per clock (as opposed to 3 directpath ops).<br />Try replacing repne scasd with a simple loop (possible unrolled) - it will most likely be faster.<br />Then again, as Maverick points out, if you don't have tons of equally probable cases, a series of cmp/jcc is the way to go.<br /><br />BTW: that optimization guide is well worth the read :)</div>
    <div class="meta">Posted on 2003-01-11 05:47:34 by Jan Wassenberg</div>
   </div>
   <div class="post" id="post-75680">
    <div class="subject"><a href="#post-75680">switch-case implementation</a></div>
    <div class="body">bitRAKE,<br />Your code is starting to make more sense now.  How do you get ALIGN 64 to work with MASM?  It appears your code is MASM.  I get an error when I do anything greater than ALIGN 16.  Why are you aligning everything on 64?  Is it a cache thing?  I notice that you jump to only one address in the jump table test, but you vary the jump address in the compare test.  I don't know if that makes any difference.  Also you PUSH and POP EDI, which is unnecessary for WndProc, because it has been saved already along with EBP,ESI, and EBX.  I will need some more time to trace your code out.  Right now I have some other things to do.  Ratch<br /><br />Jan,<br />I will do some timing tests on a loop vs SCASD when I get some time. Ratch<br /><br />hutch,<br />I will look at the code when I get time.  Ratch</div>
    <div class="meta">Posted on 2003-01-11 13:23:32 by Ratch</div>
   </div>
   <div class="post" id="post-75699">
    <div class="subject"><a href="#post-75699">switch-case implementation</a></div>
    <div class="body"><strong>Ratch</strong>, in my thinking EDI does not need to be saved in the CMP/JE code, but does for REP SCASD - it changes very little in the timing though (the stack is in the cache).  ALIGN 64 requires the segments to be PAGE aligned (look at Time-It.Inc : at the top - I don't use the .MODEL directive).  Yes, the cacheline size is 64 bytes.  The code is designed to test instruction execution speed.  So, it only gives a very narrow view of this code speed, imho.</div>
    <div class="meta">Posted on 2003-01-11 16:21:17 by bitRAKE</div>
   </div>
   <div class="post" id="post-75752">
    <div class="subject"><a href="#post-75752">switch-case implementation</a></div>
    <div class="body">Ratch,<br />I can't compile your example, (no file<br /><strong>INCLUDE \MASM32\INCLUDE\MYSTUFF.INC</strong>)<br />So, pls add my algo in your example and repost it.<br /><pre><code>.data<br />MyTabEntry   dd	1, CASE1<br />dd  2,CASE2<br />dd  3,CASE3<br />dd  4,CASE4<br />dd  5,CASE5<br />dd  6,CASE6<br />dd  7,CASE7<br />dd  8,CASE8<br />dd  9,CASE9<br />dd  10,CASE10<br />dd  11,CASE11<br />dd  12,CASE12<br />dd  13,CASE13<br />dd  14,CASE14<br />dd  15,CASE15<br />dd  16,CASE16<br />dd  17,CASE17<br />dd  18,CASE18<br />dd  19,CASE19<br />dd  20,CASE20<br />dd  21,CASE21<br />dd  22,CASE22<br />dd  23,CASE23<br />dd  24,CASE24<br />dd  25,CASE25<br />dd  26,CASE26<br />dd  27,CASE27<br />dd  28,CASE28<br />dd  29,CASE29<br />dd  30,CASE30<br />dd  31,CASE31<br />dd  32,CASE32<br />dd  33,CASE33<br />dd  34,CASE34<br />dd  35,CASE35<br />dd  36,CASE36<br />dd  37,CASE37<br />dd  38,CASE38<br />dd  39,CASE39<br />dd  40,CASE40<br />dd  41,CASE41<br />dd  42,CASE42<br />dd  43,CASE43<br />dd  44,CASE44<br />dd  45,CASE45<br />dd  46,CASE46<br />dd  47,CASE47<br />dd  48,CASE48<br />dd  49,CASE49<br />dd  50,CASE50<br />dd  51,CASE51<br />dd  52,CASE52<br />dd  53,CASE53<br />dd  54,CASE54<br />dd  55,CASE55<br />dd  56,CASE56<br />dd  57,CASE57<br />dd  58,CASE58<br />dd  59,CASE59<br />dd  60,CASE60<br />dd  61,CASE61<br />dd  62,CASE62<br />dd  63,CASE63<br />dd  64,CASE64<br />dd  65,CASE65<br />dd  66,CASE66<br />dd  67,CASE67<br />dd  68,CASE68<br />dd  69,CASE69<br />dd  70,CASE70<br />dd  71,CASE71<br />dd  72,CASE72<br />dd  73,CASE73<br />dd  74,CASE74<br />dd  75,CASE75<br />dd  76,CASE76<br />dd  77,CASE77<br />dd  78,CASE78<br />dd  79,CASE79<br />dd  80,CASE80<br />dd  81,CASE81<br />dd  82,CASE82<br />dd  83,CASE83<br />dd  84,CASE84<br />dd  85,CASE85<br />dd  86,CASE86<br />dd  87,CASE87<br />dd  88,CASE88<br />dd  89,CASE89<br />dd  90,CASE90<br />dd  91,CASE91<br />dd  92,CASE92<br />dd  93,CASE93<br />dd  94,CASE94<br />dd  95,CASE95<br />dd  96,CASE96<br />dd  97,CASE97<br />dd  98,CASE98<br />dd  99,CASE99<br />dd 100,CASE100<br />dd   0,DEFAULT<br /><br />.code<br />;  MOV EAX,NUMBER<br />; MOV ECX,CTENT1<br />; MOV EDI,OFFSET CNTAB1<br />; REPNE SCASD<br />; CALL DWORD PTR &#91;CATAB1-CNTAB1-4+EDI&#93;<br /><br /> 	mov	edx, NUMBER	        ; edx=NUMBER =101<br />	mov	eax, 100		; eax-&gt;bottom limit=100<br />	xor 	ecx, ecx		; ecx-&gt;top limit = 0<br />lowM&#58;<br />	mov 	ebx, eax		; ebx=&gt;bottom<br />	add  	eax, ecx		; ecx=&gt;top<br />checkM&#58;<br />	shr 	eax, 1		        ; divide by 2<br />	cmp 	ecx, ebx		; done if top == bottom<br />	je 	DEFAULT	                ; not found =&gt; jmp to Default		<br />	cmp 	edx, &#91;MyTabEntry+8*eax&#93; ; edx=101=NUMBER<br />	jc  	lowM		        ;	 <br />	lea   	ecx, &#91;eax+1&#93;	        ; ecx =&gt; top<br />	lea   	eax, &#91;ebx+eax+1&#93; 	; ebx=&gt; bottom<br />	jne   	checkM		        ; if not equal loop again		<br /> 	call	dword ptr &#91;MyTabEntry+ecx*8-8+4&#93; ; call proc</code></pre><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-01-11 23:58:57 by lingo12</div>
   </div>
   <div class="post" id="post-75818">
    <div class="subject"><a href="#post-75818">switch-case implementation</a></div>
    <div class="body">lingo12,<br />     Sorry I did not include everything you needed to assemble the example I posted.  Instead of debugging your code, I am correcting that oversight by posting all the macros you need to build my example.  The code you submitted appears to be a binary search scheme.  I don't know if that will be faster, but the search list needs to be sorted for that to work.  The SCASD and TEST-JE methods can arrange the most probable numbers at the beginning of the list to insure a quicker find.  And for a short list, the overhead of computing the next search area might overwhelm the savings of a directed search.  Anyway, let the best also win.  Ratch</div>
    <div class="meta">Posted on 2003-01-12 09:45:26 by Ratch</div>
   </div>
   <div class="post" id="post-75877">
    <div class="subject"><a href="#post-75877">switch-case implementation</a></div>
    <div class="body">Ratch,<br /><br />&quot;..but the search list needs to be sorted for that to work.&quot; <br />It is the price of speed<br /><br />&quot;I don't know if that will be faster,..&quot;<br />Just start  scasd.exe<br /><br />&quot;The SCASD and TEST-JE methods can arrange the <strong>most probable numbers</strong> at the beginning of the list to insure a quicker find.&quot;<br />It is sorting too<br /><br />&quot;The code you submitted appears to be a binary search scheme&quot;<br />&quot;And for a short list, the overhead of computing the next search area might overwhelm the savings of a directed search&quot;<br />That's right<br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-01-12 13:23:37 by lingo12</div>
   </div>
   <div class="post" id="post-75894">
    <div class="subject"><a href="#post-75894">switch-case implementation</a></div>
    <div class="body">lingo12,<br />I think you are on to something here.  The binary method usually was significantly faster than either SCASD or TEST-JE.  Even when the number was at the beginning of the table, which favors the SCASD and TEST-JE methods, the binary method consistently posted a shorter or equal timing than the other two methods.  I am going to run some more tests, and if it performs as well, I will probably go binary for my WndProc.  It will be a while though.  Ratch</div>
    <div class="meta">Posted on 2003-01-12 14:46:35 by Ratch</div>
   </div>
   <div class="post" id="post-75912">
    <div class="subject"><a href="#post-75912">switch-case implementation</a></div>
    <div class="body">The number of &quot;case&quot; statements affects the choice (of the best &quot;switch&quot; algorithm) a lot.<br />So I can advice you to test for 100 case values *only* if in your real application you will use 100 case values.<br />It they will only be 10, for example, the test will be pretty useless.<br />But you probably++ already knew that anyway.</div>
    <div class="meta">Posted on 2003-01-12 15:59:58 by Maverick</div>
   </div>
   <div class="post" id="post-75951">
    <div class="subject"><a href="#post-75951">switch-case implementation</a></div>
    <div class="body">I wrote up a test piece to test .IF block branching against the array of addresses technique I posted recently and found the results to be an improvement over .IF blocks but not by all that much.<br /><br />The test piece uses a test string that has 26 different characters, (lower case alphabet) looped 500000 times.<br /><br />On this PIV the .IF block is about 20% slower so even though the array of addresses technique has a lower instruction count for each branch, it appears that the branch prediction problems inherant in any wide range of branching is the overriding factor in branching speed.<br /><br />I got the .IF block to go a bit faster but putting the return jump in the block for each option, even though it leaves a dead jump after it in each instance. A range of 26 is enough to show that an array of addresses is faster, with a range that is a lot larger, I imagine that the speed difference would be a lot larger.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a><br /><br />LATER: Now the plot thickens, I increased the number of different characters to 52, (upper &amp; lower case) and the array methods became a lot faster while the .IF block became slower by about the increase in size. On my PIV the array method is about 4 times faster and on my old PIII it is nearly 3 times faster. Just to make sure I did not mess anything up, I added a counter on both so it seems to be working properly.<br /><br />I have changed the file to the new version with the extra characters in it.</div>
    <div class="meta">Posted on 2003-01-12 20:20:03 by hutch--</div>
   </div>
   <div class="post" id="post-76761">
    <div class="subject"><a href="#post-76761">switch-case implementation</a></div>
    <div class="body">Hi Everyone,<br />I tested the three methods some more, and here is what I found.  First of all, after completing and displaying the results, my test program writes zeros in the code and data areas of itself before termination, so as to force a complete reload of the cache when the program starts again.  Thus I am assured that each run starts from the same handicap.  Maybe it is not necessary to do that, but who knows?<br /><br />I always tested each method by a separate execution of the test program.  No mixing methods within a test run.   I found that the SCASD method was the fastest when the program executed cold code, no cache warming applied.  Next fastest was BINARY, which was almost as fast when SCASD had to search to the end of the table.  CMP-JE did abysmally on cold code, especially on long table searches.<br /><br />Next I tested  the methods using 2 or more passes through the code before the times were measured.  WOWIE, what a difference one or more passes to establish a cache presence makes.  The BINARY was fastest, unless the other two methods found the number early in their search.  It appears that SCASD was last in speed and benefited the least from cache presence. <br /><br />So to summarize.  If you are going to do a one shot search of a table, use SCASD.  If you think your code and table are going to be in cache for another go around, use the BINARY or CMP-JE method.  The BINARY method appears to be the best all around method for sorted tables.  Its power of two search algo is difficult to match for long tables.  Ratch</div>
    <div class="meta">Posted on 2003-01-16 20:11:58 by Ratch</div>
   </div>
   <div class="post" id="post-76768">
    <div class="subject"><a href="#post-76768">switch-case implementation</a></div>
    <div class="body">Ratch,<br /><br />&quot;...for my WndProc..&quot;<br />I'm curious what happens with your WndProc code<br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-01-16 20:26:27 by lingo12</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=10080&amp;page=1" style="">&laquo;</a><a href="../?id=10080&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="10080" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=10080&amp;page=3">&gt;</a><a href="../?id=10080&amp;page=3">&raquo;</a></form>  </div>
 </body>
</html>