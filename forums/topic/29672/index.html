<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Awkward 32-bit problem - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29672" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=34">OS Development</a> &raquo; <a href="../?id=29672">Awkward 32-bit problem</a></p>
   <div class="post" id="post-209496">
    <div class="subject"><a href="#post-209496">Awkward 32-bit problem</a></div>
    <div class="body">Hello community, I am working on my &#039;2nd stage&#039; bootloader, after having setup my MBR.&nbsp; The MBR boots just fine, and then starts into the Bootloader.&nbsp; Nothing fancy happens until the GDT setting up phase.&nbsp; I then setup Protected Mode, and attempt to load the kernel.<br /><br />Unfortunately, my code seems to be dysfunctional, but with the most odd thing... I have tried debugging by splitting the code into segments separated with a unrecoverable halt, and if a message was printed, that piece was deemed good to go.&nbsp; None of that worked.&nbsp; So far, I have determined, that the CPU will successfully reach the jump instruction before the  perameter, but will then&nbsp; triple-fault.&nbsp; I have wracked my brain in an attempt to figure out what this issue is, been at it about 3.5 hours, and need the Gods of Assembly to intervene.<br /><br />Attached is my code for the bootloader.<br /><br />Thanks to all who appear and help, in advanced.<br /><br /><pre><code>;XIX System 19 Bootloader - Version pre-Alpha<br />;Copyright (C) 2009 Brian D. Knopp<br />;<br />;This program is free software: you can redistribute it and/or modify<br />;it under the terms of the GNU General Public License as published by<br />;the Free Software Foundation, using version 3 of the License.<br />;<br />;This program is distributed in the hope that it will be useful,<br />;but WITHOUT ANY WARRANTY; without even the implied warranty of<br />;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp; See the<br />;GNU General Public License for more details.<br />;<br />;You should have received a copy of the GNU General Public License<br />;along with this program.&nbsp; If not, see &lt;http://www.gnu.org/licenses/&gt;.<br />;<br />;<br />;This version of the XIX System 19 Bootloader is used<br />;specifically to setup a suitable environment to load<br />;the XIX Kernel and execute it.&nbsp; Future fleatures<br />;include the ability to detect the best route to perform<br />;its appointed duty by BIOS ID, error handling/reporting<br />;and multi-boot features.<br />;<br />;For full documentation, read the source-enclosed<br />;bootloader.ldr.doc file<br /><br />	;Assembler Directive denoting this as 16-bet Real Mode<br />	;Assembler Directive denoting this as existing at offset 0x0000<br /><br />begin:		;function to jump over the data section and into the main boot sequence<br />	jmp boot<br /><br /><br />;Section for Functions<br />prntstr:	;function to print a string loaded into AL<br />	mov ah, 0x0E		;load 0x0E (teletype) into AH<br /><br />	mov bh, 0x00		;set page number to 0 (page 1)<br />	mov bl, 0x000E		;set attribute to Green Text, Black Background, non-flashing<br /><br />	.nxtchar		;label to repeat int 0x10<br />	lodsb			;load string in SI, into AL<br />	or al, al		;check to see if AL = null char (set zero if true)<br /><br />	jz .ret			;jump over int 0x10 and exit function<br /><br />	int 0x10		;call int 0x10 to print the string<br />	jmp .nxtchar		;repeat the routine if null character is not yet present<br /><br />	.ret			;label to jump to, to get out of the loop<br />ret<br /><br />a20en:		;function to enable the A20 Gate<br />	cli			;clear interrupts to disallow interuption of procedure<br /><br />	in al, 0x92		;open AL to 0x92<br />	or al, 0x02		;send value 0x02 to AL register<br />	out 0x92, al		;close AL 0x92<br /><br />	sti			;re-enable interupts<br /><br />	lea si,  	;load the A20 Message into SI register<br />	call prntstr		;print the string<br />ret<br /><br />krnlod:		;function to load the kernel into memory<br />	jmp .rddsk		;jump over error function to read the disk<br /><br />	.rderr			;label to jump to if error occurs<br />	lea si, 	;load the error sting into SI<br />	call prntstr		;print the string<br />	cli			;clear interupts<br />	hlt			;enter unrecoverable halt<br /><br />	.rddsk<br />	mov ax, 0x8112		;load 0x8112 into AX register (can&#039;t directly manipulate ES)<br />	mov es, ax		;set ES to contents of AX (location of memory to read to)<br />	xor bx, bx		;set offset to 0x0000<br /><br />	mov ah, 0x02		;place 0x02 (read function) into AH<br />	mov al, 0x10		;read 16 sectors<br />	mov ch, 0x00		;read from cylinder 1<br />	mov cl, 0x03		;read from sector 3<br />	mov dh, 0x00		;read from head 0<br />	mov dl, 	;read from drive<br /><br />	int 0x13		;call int 0x13 to read from disk<br />	jc .rderr		;if carry flag is set (read unsuccessfull) go to error routine<br /><br />	lea si, 	;load the address of the Kernel Load Message into SI<br />	call prntstr		;print the string	<br />ret<br /><br />gdtset:		;function to setup and load the Global Descriptor Table<br />	mov ax, 0x7000<br />	mov ds, ax		;setup segment registers<br />	mov es, ax<br />	mov si, gdt		;start of GDT table into SI register<br />	mov di, 		;locate GDT at 0x500 im memory<br />	mov cx, 	;size of the GDT (defined my fancy footwork)<br /><br />	cld			;clear the direction flag<br />	rep movsb		;move byte from DS:SI to ES:DI<br /><br />	lgdt		;load the Global Descriptor Table<br /><br />	lea si, 	;load the address of the GDT Setup Message into SI<br />	call prntstr		;print the string<br />ret<br /><br />pmoden:		;function to enable Protected Mode<br />	cli			;permanently clear interrupts<br />	mov eax, cr0		;move contents of ControlRegister0 into ExtendedAX register<br />	or al, 0x01		;compare AL to value 1<br />	mov cr0, eax		;move CR0 into EAX register<br />ret<br /><br /><br />;Section for Strings<br />sysmess db &#039;XIX System 19 Bootloader - Version pre-Alpha&#039;,13,10,10,0	;System Information String<br />									;13 = char return<br />									;10 = new line<br />									;0 = null character (terminate)<br /><br />a20mess db &#039;A20 Gate Successfully Enabled&#039;,13,10,10,0<br /><br />krnmess db &#039;Kernel Loading Successful&#039;,13,10,10,0<br /><br />krnloderr db &#039;ERROR - Kernel Loading Unsuccessfull - ABORT&#039;,13,10,0<br /><br />gdtmess db &#039;Global Descriptor Table Successfully Setup&#039;,13,10,10,0<br /><br />pmodmess db &#039;Will now enable Protected Mode, and boot the Kernel&#039;,13,10,10,0<br /><br /><br />;Section for Variables<br />bootdrv db 0		;variable to hold boot drive number<br /><br />;Section for Descriptor Tables<br />gdtr:<br />gdtsze dw gdtend-gdt-1	;size of GDT is from gdtend subtract gdt minus 1 (for null descriptor?)<br />gdtbse dd 0x500		;where GDT is located at (0x500)<br /><br />gdt:<br />null	equ $-gdt	;this is the null descriptor<br />	dd 0x0		;fill the null selector with 0x00 properties<br />	dd 0x0<br /><br />code	equ $-gdt&nbsp; 	;code segment with 64KB flat memory model<br />	dw 0x1000	;first word of limit field (use with second to denote 64kb size)<br />	dw 0x0		;first word of the base field (Descriptor begins at 0x00)<br />	db 0x0		;third byte of the base field<br />	db 0x9A		;first byte of attribute flags: (present,ring0,predef,nonconforming,read/execute,accessed)<br />	db 0x40		;second word of the limit/attribute field: (0x0000 limit2, byte granularity,32bit,predef*2)<br />	db 0x00		;third byte of the base field<br /><br />data	equ $-gdt	;data segment with 64KB flat memory model<br />	dw 0x1000	;first word of limit field (use with second to denote 64KB size)<br />	dw 0x0		;first word of the base field (Descriptor begins at 0x00)<br />	db 0x0		;third byte of the base field<br />	db 0x93		;first byte of attribute flags: (present,ring0,predef,nonexpdown,read/write,accessed)<br />	db 0x40		;second word of the limit/attribute field: (0x0000 limit2, byte granularity,32but,predef*2)<br />	db 0x0		;third byte of the base field<br />gdtend:		;empty function to denote end of GDT in memory<br /><br /><br />;Main Program<br />boot:<br />	mov , dl	;save starting drive into variable <br /><br />	mov ax, 0x7000		;setup the stack<br />&nbsp; &nbsp; 	mov ds, ax<br />&nbsp; &nbsp; 	mov es, ax<br />&nbsp; &nbsp; 	mov ss, ax<br />&nbsp; &nbsp; 	mov sp, 0x2000		;stack size is 0x200 bytes <br />&nbsp; &nbsp; 	cld			;clear the direction flag<br /><br />	lea si, 	;load effective address of sting sysmess into SI<br />	call prntstr		;call function to print the string<br /><br />	call a20en		;call the function to enable the A20 Gate<br /><br />	call krnlod		;call the function to load the kernel<br /><br />	call gdtset		;call the function to setup the Global Descripter Table<br /><br />	lea si, 	;load the PMode enabling message<br />	call prntstr		;print the string<br />	call pmoden		;call the function to enable Protected Mode<br /><br />	jmp code:.bootkrnl	;jump to 32 bit code to straighten out EIP<br /><br />	<br />	.bootkrnl<br />		;refrest segment registers based upon GDT<br />		mov eax, data<br />		mov ds, eax<br />		mov es, eax<br />		mov gs, eax<br />		mov fs, eax<br />		mov ss, eax	;stack at location of data register (flat)<br /><br />		mov esp, 0x1000	;stack size is 64KB<br /><br />		jmp code:0x8112	;jump to residence of Kernel<br />		cli		;REMOVE AFTER DEBUG<br />		hlt		;halt processor from executing this binary<br /><br />;set bootloader to 512 bytes (1 segment) long<br />times 512-($-$$) db 0		;fill unused space upto 512 bytes with 0</code></pre></div>
    <div class="meta">Posted on 2009-11-05 14:42:07 by XeonX369</div>
   </div>
   <div class="post" id="post-209497">
    <div class="subject"><a href="#post-209497">Re: Awkward 32-bit problem</a></div>
    <div class="body"><br />;Section for Descriptor Tables<br />gdtr:<br />gdtsze dw gdtend-gdt-1	;size of GDT is from gdtend subtract gdt minus 1 (for null descriptor?)<br />gdtbse dd 0x500		;where GDT is located at (0x500)<br /><br />Of all the addresses we work with, this is the only(?) one that isn&#039;t segment:offset - it needs to be a linear address. If this code was loaded at 0:someoffset, &quot;gdt&quot; would be right. Otherwise add loadseg&lt;&lt;4 to &quot;gdt&quot;. An even 0x500 seems &quot;unlikely&quot;(?).<br /><br />I haven&#039;t tested this (a &quot;problem&quot; with Linux is that I hate to reboot), or looked it over thoroughly, but this jumps out at me as a possible problem.<br /><br />(that&#039;s why they call it the &quot;triple fault club&quot; :)<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2009-11-05 15:57:29 by fbkotler</div>
   </div>
   <div class="post" id="post-209504">
    <div class="subject"><a href="#post-209504">Re: Awkward 32-bit problem</a></div>
    <div class="body"><div class="quote"><br />Of all the addresses we work with, this is the only(?) one that isn&#039;t segment:offset - it needs to be a linear address. If this code was loaded at 0:someoffset, &quot;gdt&quot; would be right. Otherwise add loadseg&lt;&lt;4 to &quot;gdt&quot;. An even 0x500 seems &quot;unlikely&quot;(?).<br /></div><br /><br />Take another look at his <em>gdtset</em> subroutine.</div>
    <div class="meta">Posted on 2009-11-06 01:06:51 by SpooK</div>
   </div>
   <div class="post" id="post-209505">
    <div class="subject"><a href="#post-209505">Re: Awkward 32-bit problem</a></div>
    <div class="body"><div class="quote"><br />Unfortunately, my code seems to be dysfunctional, but with the most odd thing... I have tried debugging by splitting the code into segments separated with a unrecoverable halt, and if a message was printed, that piece was deemed good to go.&nbsp; None of that worked.&nbsp; So far, I have determined, that the CPU will successfully reach the jump instruction before the  perameter, but will then&nbsp; triple-fault.&nbsp; I have wracked my brain in an attempt to figure out what this issue is, been at it about 3.5 hours, and need the Gods of Assembly to intervene.<br /></div><br /><br />Where exactly in RAM are you loading your LBR to?<br /><br />While thinking about the answer for the above question, take a good hard look at the base and limit of your GDT code segment entry.<br /><br />Also, when changing SS or (E)SP, it is recommended to disable interrupts while doing so.</div>
    <div class="meta">Posted on 2009-11-06 01:53:07 by SpooK</div>
   </div>
   <div class="post" id="post-209507">
    <div class="subject"><a href="#post-209507">Re: Awkward 32-bit problem</a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br />Of all the addresses we work with, this is the only(?) one that isn&#039;t segment:offset - it needs to be a linear address. If this code was loaded at 0:someoffset, &quot;gdt&quot; would be right. Otherwise add loadseg&lt;&lt;4 to &quot;gdt&quot;. An even 0x500 seems &quot;unlikely&quot;(?).<br /></div><br /><br />Take another look at his <em>gdtset</em> subroutine.<br /></div><br /><br />Okay... so the gdt is being moved to 7000h:500h, or linear 0x70500, right? Or am I still missing something? That&#039;s not what we&#039;re telling lgdt.<br /><br />Let me clarify(?)... &quot;gdtr&quot;, as in &quot;lgdt &quot; is a segment:offset address, as usual. The address within that needs to be linear.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2009-11-06 02:13:22 by fbkotler</div>
   </div>
   <div class="post" id="post-209511">
    <div class="subject"><a href="#post-209511">Re: Awkward 32-bit problem</a></div>
    <div class="body"><div class="quote"><br />Let me clarify(?)... &quot;gdtr&quot;, as in &quot;lgdt &quot; is a segment:offset address, as usual. The address within that needs to be linear.<br /></div><br /><br />LGDT is a memory operation, it will load 48-bits (16-bit limit, 32-bit base address) from the specified memory location, <em>gdtr</em> in this case, and store it in the GDT Register... hence GDTR.<br /><br />Assuming he is loading his LBR to 0x7000:0000 (0x00070000), then there are still two obvious problems.<br /><br />1.) The GDT is specified to be at 0x00000500, but in <em>gdtset</em> he is setting ES to 0x7000, in which will cause <em>rep movsb</em> to copy the GDT to 0x00070500.<br />2.) The base address and limit of the GDT code segment is essentially covering the first 64KB, in which will cause a triple-fault as soon as the 32-bit far jump to <em>.bootkrnl</em> (still located at 0x00070000+) is attempted.<br /><br />So either the GDTR base address needs to change to 0x00070500 or ES in <em>gdtset</em> needs to change to 0x0000, and the base address and limit of the GDT code segment needs to be corrected.<br /><br />Also note that in 16-bit Real Mode, GDTR will mask the upper 8-bits of the 32-bit base address, thus making it a 24-bit base address. So, make sure your GDT is located below the 16MB mark in such a case.</div>
    <div class="meta">Posted on 2009-11-06 11:20:09 by SpooK</div>
   </div>
   <div class="post" id="post-209512">
    <div class="subject"><a href="#post-209512">Re: Awkward 32-bit problem</a></div>
    <div class="body">I realize that this problem has arisen out of a slight misunderstanding of the way a GDT works.&nbsp; Due to the guidance of the Gurus here on this forum, I feel like my knowledge on this topic has been amended.&nbsp; However, I still feel in error with the regard to the Base and Limit values in the code segment.&nbsp; I therefore sincerely beg a minor assistance yet more.<br /><br />If I wanted to have a 64 KB segment size (Don&#039;t I already have that?), what values would I set these bytes and words to?&nbsp; I still believe that I misunderstand about correcting the base and limit values.&nbsp; I wish to know why, and what would the best values be?<br /><br />I give many thanks to all you.</div>
    <div class="meta">Posted on 2009-11-06 12:35:42 by XeonX369</div>
   </div>
   <div class="post" id="post-209513">
    <div class="subject"><a href="#post-209513">Re: Awkward 32-bit problem</a></div>
    <div class="body"><div class="quote"><br />If I wanted to have a 64 KB segment size (Don&#039;t I already have that?), what values would I set these bytes and words to?&nbsp; I still believe that I misunderstand about correcting the base and limit values.&nbsp; I wish to know why, and what would the best values be?<br /></div><br /><br />The best response would be to first ask why you would want a 64KB segment size.<br /><br />So, why would you want a 64KB segment size... especially in 32-bit Protected Mode?</div>
    <div class="meta">Posted on 2009-11-06 13:06:01 by SpooK</div>
   </div>
   <div class="post" id="post-209514">
    <div class="subject"><a href="#post-209514">Re: Awkward 32-bit problem</a></div>
    <div class="body">The reasoning why I wanted a 64KB segment is that I felt like restricting myself somewhat while my kernel was relatively small, and then expand latter.<br /><br />Yes, I do realize, that I could just setup full ~4GB segment size right now, but I would rather do that sort of improvement in the future.&nbsp; I do realize that this seems quite stupid right now, but this is the OS that I plan to write.&nbsp; I think what the problem I am having is that I am a bit confused with Intel&#039;s fragmented GDT design.<br /><br />Therefore, that is the answer to your question.&nbsp; I would truly appreciate help with this issue, and will accept any suggestions.</div>
    <div class="meta">Posted on 2009-11-06 14:27:20 by XeonX369</div>
   </div>
   <div class="post" id="post-209515">
    <div class="subject"><a href="#post-209515">Re: Awkward 32-bit problem</a></div>
    <div class="body"><div class="quote"><br />Yes, I do realize, that I could just setup full ~4GB segment size right now, but I would rather do that sort of improvement in the future.&nbsp; I do realize that this seems quite stupid right now, but this is the OS that I plan to write.&nbsp; I think what the problem I am having is that I am a bit confused with Intel&#039;s fragmented GDT design.<br /></div><br /><br />Well, no &quot;improvement&quot; is required. It is very typical to set up GDT entries to their max limits so that the entire memory space can operate in a flat manner.<br /><br />Your GDT can be as small as 24 bytes (NULL, CODE and DATA entries) and doesn&#039;t have to change at all after initial GDTR load. The GDT just needs to be consistently accessible.<br /><br />I&#039;ve seen this many times where people think they&#039;ll implement segmentation in a unique or useful way, as to make less work or a more secure system, but end up making things slower, more complex and generally worse than even the simplest of page-based scenarios.<br /><br />By trying to enforce segmentation, you will be spending more time changing the GDT and troubleshooting resultant problems. It is a mechanism that was designed to solve an old problem and doesn&#039;t really belong outside of 16-bit Real Mode.<br /><br />If you plan on moving beyond 16-bit Real Mode, setup the GDT to max limits and don&#039;t look back.<br /><br />However, if you really want to go down this road, then you need to adjust your GDT code entry to have a base of 0x00070000.</div>
    <div class="meta">Posted on 2009-11-06 16:34:54 by SpooK</div>
   </div>
   <div class="post" id="post-209516">
    <div class="subject"><a href="#post-209516">Re: Awkward 32-bit problem</a></div>
    <div class="body">True. Paging is simply an improved version of segmentation and segmentation is kept just for compatibility.<br /><br />Load GDTR and forget about it. Instead focus on efficient paging implementation.</div>
    <div class="meta">Posted on 2009-11-06 17:02:54 by ti_mo_n</div>
   </div>
   <div class="post" id="post-209523">
    <div class="subject"><a href="#post-209523">Re: Awkward 32-bit problem</a></div>
    <div class="body">Or if you want to limit segments, set limits to 0FFFFFFFFh to get it working, first. Then fiddle with base and limits until you&#039;ve got what you want.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2009-11-07 05:10:45 by fbkotler</div>
   </div>
   <div class="post" id="post-209643">
    <div class="subject"><a href="#post-209643">Re: Awkward 32-bit problem</a></div>
    <div class="body">Sorry for the delayed response, my network was down and I didn&#039;t have access to my data.&nbsp; :shock:<br /><br />I have decided to go with Paging, so I have set the granularity to be appropriate.&nbsp; The error that I have is with the base values.&nbsp; I want a full 4GB space with paging, so I set the limit value to FFFF in the first limit word, and in the second byte-size section (with the attributes), I set to F.&nbsp; The trouble here is that no matter what value I set &#039;base&#039; as, whether it is 0x00070000, or a flat out 0, nothing seems to work.&nbsp; I suppose this comes out of my own stupidity, but I do indeed need advice.<br /><br />Thanks.<br /><br />EDIT:&nbsp; Forgot to say that I want to setup Paging in my Kernel Routine, so pretty much my problem lies with the Base value not accepting anything that I throw at it.</div>
    <div class="meta">Posted on 2009-11-17 14:06:17 by XeonX369</div>
   </div>
  </div>
 </body>
</html>