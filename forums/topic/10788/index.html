<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>question about unaligned stack operations - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=10788" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=10788">question about unaligned stack operations</a></p>
   <div class="post" id="post-81190">
    <div class="subject"><a href="#post-81190">question about unaligned stack operations</a></div>
    <div class="body">mmmmm... i am thinking.. for what you.. clean all my post?? i can think by 2 mins aprox?? (have a specific time for write a post??) :S :( <br /><br /><br /><br />i dont gonna rewrite all the post...<br /><br />ok... ok.. i write all i remember.. (this is.... crazy)<br /><br />ok, the question is for what a unaligned operation in the stack can cause some like the vars , directions or str passed to a msgbox dont display correctly???<br /><br />unaligned data.. only take more clock cycles, but what whit the stack.. the stack can take unaligned operations.. but for what win can not??? is a bug is a feature?? is a wath?? is E.T. in my comp????? :)<br /><br />yep yep.... ok.. i short a little my post.. i think for time.. this think make some like reaload by self and erase.. my original post :S<br /><br />ok here is the correct exe... in the next post the &quot;no&quot; correct exe.. i ee equal only unaligned stak ... but i think this cause only more cycles????.. what you think???<br /><br />have a nice day ... :)<br /><br />correct exe</div>
    <div class="meta">Posted on 2003-02-12 01:42:53 by rea</div>
   </div>
   <div class="post" id="post-81191">
    <div class="subject"><a href="#post-81191">the &quot;bad&quot; exe</a></div>
    <div class="body">you read..  the only difernce is unaligned stak ...<br /><br />i say have a nice day??? lol, then have nice thoughts, ideas.. you dont have the word ideas in your lang??.. you have idea :) i think ;)<br /><br />c ya, bytes.<br /><br />a yep, this &quot;supuestamente&quot; incorrect</div>
    <div class="meta">Posted on 2003-02-12 01:45:40 by rea</div>
   </div>
   <div class="post" id="post-81780">
    <div class="subject"><a href="#post-81780">hi hgb</a></div>
    <div class="body">it is very dificult to meet with you :)<br /><br />try to see the post <br /><br /><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=10687">http://www.asmcommunity.net/board/index.php?topic=10687</a><br /><br /><br />i will be at 2:00 night at irc PTnet</div>
    <div class="meta">Posted on 2003-02-14 09:48:02 by Nguga</div>
   </div>
   <div class="post" id="post-126094">
    <div class="subject"><a href="#post-126094">question about unaligned stack operations</a></div>
    <div class="body">okay.. I debugged your code hgb it was very compact.. I think because you didn't register any classes.  I was pretty impressed by the enter command but.. I haven't used that before.  Anyway I did a debug comparison on the .break .if statement compared to the cmp eax,0 jle .nogo syntaxes and I found that there really isn't a great deal of extra code run.. as far as it needing to jump to a near address, well I can't see that taking up too much extra time either.  Perhaps it does.. I'll have to look at both of you're examples first.  There is one thing though, when I used the .break in debug it used or eax,eax.  I have heard before that this isn't as efficient as cmp because of the architecture of the intel cpu.  From what I remember the cmp instruction is stored almost on top of the conditional jumps.  Are there any tools that you can use to do a time comparison.  I wouldn't mind finding out if or is a better option than cmp before a conditional jump.<br /><br />cheers<br /><br />oh and also what did you use to code those examples.<br /><br /><br />the code that was output by the debugger came out like this<br /><br /><br />This is the basic program which uses .break syntax<br />notice on line 004010F9 it uses a or instruction. I don't know why.<br /><br />004010EA  |&gt; 6A 00          /PUSH 0                                           ; /MsgFilterMax = 0<br />004010EC  |. 6A 00          |PUSH 0                                           ; |MsgFilterMin = 0<br />004010EE  |. 6A 00          |PUSH 0                                           ; |hWnd = NULL<br />004010F0  |. 8D45 B4        |LEA EAX,DWORD PTR SS:                    ; |<br />004010F3  |. 50             |PUSH EAX                                         ; |pMsg<br />004010F4  |. E8 5F000000    |CALL &lt;JMP.&amp;USER32.GetMessageA&gt;                   ; \GetMessageA<br />004010F9  |. 0BC0           |OR EAX,EAX<br />004010FB  |. 74 14          |JE SHORT basic.00401111<br />004010FD  |. 8D45 B4        |LEA EAX,DWORD PTR SS:<br />00401100  |. 50             |PUSH EAX                                         ; /pMsg<br />00401101  |. E8 76000000    |CALL &lt;JMP.&amp;USER32.TranslateMessage&gt;              ; \TranslateMessage<br />00401106  |. 8D45 B4        |LEA EAX,DWORD PTR SS:<br />00401109  |. 50             |PUSH EAX                                         ; /pMsg<br />0040110A  |. E8 43000000    |CALL &lt;JMP.&amp;USER32.DispatchMessageA&gt;              ; \DispatchMessageA<br />0040110F  |.^EB D9          \JMP SHORT basic.004010EA<br /><br />This is the code for the practise examp. I did with the cmp instruction.  Notice on line 004010F9 it uses the cmp<br />instruction.  There is also another jmp short at 00401110.  This could be where the code may be slower. i.e. if a short jump takes extra clock cycles.  As far as I can see, the cost of error correcting is to take this short jmp. Seeing as how it is a loop but, it does add a lot of extra time to the program as it runs.<br /><br />004010EA  |&gt; 6A 00          /PUSH 0                                           ; /MsgFilterMax = 0<br />004010EC  |. 6A 00          |PUSH 0                                           ; |MsgFilterMin = 0<br />004010EE  |. 6A 00          |PUSH 0                                           ; |hWnd = NULL<br />004010F0  |. 8D45 B4        |LEA EAX,DWORD PTR SS:                    ; |<br />004010F3  |. 50             |PUSH EAX                                         ; |pMsg<br />004010F4  |. E8 8B000000    |CALL &lt;JMP.&amp;USER32.GetMessageA&gt;                   ; \GetMessageA<br />004010F9  |. 83F8 00        |CMP EAX,0<br />004010FC  |. 7E 14          |JLE SHORT a_practi.00401112<br />004010FE  |. 8D45 B4        |LEA EAX,DWORD PTR SS:<br />00401101  |. 50             |PUSH EAX                                         ; /pMsg<br />00401102  |. E8 A7000000    |CALL &lt;JMP.&amp;USER32.TranslateMessage&gt;              ; \TranslateMessage<br />00401107  |. 8D45 B4        |LEA EAX,DWORD PTR SS:<br />0040110A  |. 50             |PUSH EAX                                         ; /pMsg<br />0040110B  |. E8 6E000000    |CALL &lt;JMP.&amp;USER32.DispatchMessageA&gt;              ; \DispatchMessageA<br />00401110  |. EB 17          |JMP SHORT a_practi.00401129<br />00401112  |&gt; 74 13          |JE SHORT a_practi.00401127<br />00401114  |. 6A 00          |PUSH 0                                           ; /Style = MB_OK|MB_APPLMODAL<br />00401116  |. 68 34304000    |PUSH a_practi.00403034                           ; |Title = &quot;No Window Handle&quot;<br />0040111B  |. 68 1C304000    |PUSH a_practi.0040301C                           ; |Text = &quot;Incorrect Parent Handle&quot;<br />00401120  |. 6A 00          |PUSH 0                                           ; |hOwner = NULL<br />00401122  |. E8 6F000000    |CALL &lt;JMP.&amp;USER32.MessageBoxA&gt;                   ; \MessageBoxA<br />00401127  |&gt; EB 05          |JMP SHORT a_practi.0040112E<br />00401129  |&gt; 8B45 BC        |MOV EAX,DWORD PTR SS:<br />0040112C  |.^EB BC          \JMP SHORT a_practi.004010EA</div>
    <div class="meta">Posted on 2003-12-01 03:56:48 by Phase Verocity</div>
   </div>
   <div class="post" id="post-126095">
    <div class="subject"><a href="#post-126095">question about unaligned stack operations</a></div>
    <div class="body">From what I remember all that a jmp instruction does is put an address into the ip register.  When the instructions are run they always go to the next command at the address of the ip register.  Because of this I cannot see that it would take more clock cycles than the actual jmp instruction itself.  So I guess what it comes down to then is finding out how many cycles the jmp instruction uses.. I can't imagine too many, seeing as how it is one of the most commonly used instructions.</div>
    <div class="meta">Posted on 2003-12-01 04:08:11 by Phase Verocity</div>
   </div>
   <div class="post" id="post-126307">
    <div class="subject"><a href="#post-126307">question about unaligned stack operations</a></div>
    <div class="body">About the what is fast, dunno, but what is short, is: or eax, eax than cmp eax, 0.<br />For take a little about timming you can search for profiler in this board.<br /><br />I use <a target="_blank" href="http://sourceforge.net/projects/nasm">nasm</a>  and for the linker <a target="_blank" href="http://alink.sourceforge.net/">alink</a>  for others see at<a target="_blank" href="http://nasm.sourceforge.net/doc/html/nasmdoc7.html#section-7.1.1">alink and others</a> .<br /><br /><br />Yes I not register any class, i only call the procedure inside my app, that make in the first example a aligned substraction (this is some like store space for locals vars) is a multiple of 4, in the second example I dont the same, but with a substraction that the &quot;minuendo&quot; is not multiple of 4, if you run the examples, the two examples are in fact equal.<br /><br />The only real diference is in the number that i substracted to the esp in the second is 2E or 46 46/4 = 11.5, that missalign will cause some that I consider extrange.<br /><br /><br />Nice day or night.</div>
    <div class="meta">Posted on 2003-12-02 14:01:01 by rea</div>
   </div>
   <div class="post" id="post-126344">
    <div class="subject"><a href="#post-126344">question about unaligned stack operations</a></div>
    <div class="body">hgb,<br /><div class="quote">About the what is fast, dunno, but what is short, is: or eax, eax than cmp eax, 0.</div> <br />OR EAX,EAX is a two byte instruction, but it has to write the result back into EAX.  That will probably make it take longer.  CMP EAX,0 is a three byte instruction with no write back.  CMP EAX,EBP where EBP=0 is a two byter with no write back.  TEST EAX,EAX is a two byter with no write back.  You make the judgement.  Ratch</div>
    <div class="meta">Posted on 2003-12-02 21:21:39 by Ratch</div>
   </div>
   <div class="post" id="post-126372">
    <div class="subject"><a href="#post-126372">question about unaligned stack operations</a></div>
    <div class="body"><div class="quote"><br />unaligned data.. only take more clock cycles, but what whit the stack.. the stack can take unaligned operations.. but for what win can not??? is a bug is a feature?? is a wath?? is E.T. in my comp????? <br /></div><br />There's probably some code that, for some reason (probably efficiency?), depend on the stack being 4-byte aligned. I'd say it's a reasonable assumption to make under a 32bit os :)</div>
    <div class="meta">Posted on 2003-12-03 03:59:17 by f0dder</div>
   </div>
  </div>
 </body>
</html>