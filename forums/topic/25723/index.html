<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Converting ColourMatrix to use MMX - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25723" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25723">Converting ColourMatrix to use MMX</a></p>
   <div class="post" id="post-187723">
    <div class="subject"><a href="#post-187723">Converting ColourMatrix to use MMX</a></div>
    <div class="body">Hi,<br /><br />As I?ve continued to develop my project (see First Foray into ASM) I?ve got a bit side tracked into looking at colour Matrices. I?ve written and optimised the C++ version and whilst I?m pretty happy with the results I?d like to look at implementing a MMX version. Sadly I know very little MMX and have not really found many good sources online. I?ve got the basic idea, but the wealth of instructions, packing, unpacking etc has left me a little dizzy.<br /><br />Colour Matrix is simply the application of matrices to manipulate each pixel in a given image. The original source code for this used floating point (I know I can look into SEE/SSE2 but I?d like to work my way up to these) and as such was pretty slow, though very accurate. I then converted this to an integer version (using the methodology of fixed point, but not caring where the point is ;) - well the code worked that?s all that was important at the time), this was about 40% faster. I then converted this to a lookup table version which gave almost 60% performance on the original FP version.<br /><br />I?ve posted the fixed point version here to act as a basis for the MMX version, since I believe it?s the most appropriate.<br /><br /><pre><code>void TStdXtra_IMoaMmXScript::ncp_ColourMatrixImage_FixedPoint(unsigned long* src, unsigned long* dst, MoaUlong uiWidth, MoaUlong uiHeight, MoaDouble * mMat)<br />{<br />	MoaLong		iRed, iGreen, iBlue;<br />	MoaLong		ir, ig, ib;<br />	MoaLong		newMat[16];<br />	MoaUlong	ui1, i;<br />	MoaUlong	iImageSize&nbsp; &nbsp;= uiWidth*uiHeight;<br />	<br />	// Convert Matrix to fixedpoint using *256<br />	for (i=0; i&lt;16; i++)<br />		newMat<em> = (MoaLong)(mMat<em>*256.0f);<br /><br /><br />	for(i=0;i&lt;iImageSize;i++)<br />	{	<br />		// This appears to be fastest emthod of grabing the components<br />		ui1	= *src++;<br />		ir	= (MoaLong)((ui1 &gt;&gt; 16)&amp;0xFF); <br />		ig	= (MoaLong)((ui1 &gt;&gt; 8) &amp;0xFF); <br />		ib	= (MoaLong)((ui1)&nbsp; &nbsp; &nbsp; &amp;0xFF);	<br /><br />		// Use fixed point matrix values - have to divide through at end<br />		iRed	= (ir*newMat[0] + ig*newMat[4] + ib*newMat[8]&nbsp; + newMat[12]) / 256;<br />		iGreen	= (ir*newMat[1] + ig*newMat[5] + ib*newMat[9]&nbsp; + newMat[13]) / 256;<br />		iBlue	= (ir*newMat[2] + ig*newMat[6] + ib*newMat[10] + newMat[14]) / 256;<br />	<br />		// bound checks - yuk!&nbsp; C &lt; 0 = 0&nbsp; &nbsp; C &gt; 255 = 255<br />		// &lt; snipped for shorter code and it should be removed by using MMX &gt;<br />		<br />		*dst++ = (unsigned long)( (byte)(iBlue) | ((byte)(iGreen) &lt;&lt; 8) | ((byte)(iRed) &lt;&lt; 16));<br />	}	<br />}</code></pre><br /><br />So from my understanding of MMX so far, I can set up the maths as such<br /><br /><pre><code><br />// MMX&nbsp; &nbsp;Words&nbsp; &nbsp; &nbsp; &nbsp;a&nbsp; &nbsp; &nbsp; c&nbsp; &nbsp; &nbsp; e&nbsp; &nbsp; &nbsp; g<br />//&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*&nbsp; &nbsp; &nbsp; *&nbsp; &nbsp; &nbsp; *&nbsp; &nbsp; &nbsp; *<br />//&nbsp; &nbsp; &nbsp; &nbsp;Words&nbsp; &nbsp; &nbsp; &nbsp;b&nbsp; &nbsp; &nbsp; d&nbsp; &nbsp; &nbsp; f&nbsp; &nbsp; &nbsp; h<br />// Result dWord&nbsp; &nbsp; &nbsp; a*b+c*d&nbsp; &nbsp; &nbsp; &nbsp;e*f+g*h<br /></code></pre><br /><br />Which in the case of the red componet resolves to<br /><br /><pre><code><br />// Load mm1 with matrix&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m[0]&nbsp; m[4]&nbsp; &nbsp; m[8]&nbsp; m[12]<br />// Load mm2 with Components&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ir&nbsp; &nbsp; ig&nbsp; &nbsp; &nbsp; ib&nbsp; &nbsp; &nbsp;1<br />// Multiply mm1 with mm2<br />// Results&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m[0]*ir+m[4]*ig&nbsp; &nbsp; m[8]*ib + m[12]*1<br /></code></pre><br /><br />For the moment I?m ignoring alpha and so m[12]*1 represents the translation of the colour component. At some stage I?ll introduce alpha and do the component translation later.<br /><br />So the question how to go about this with real MMX code? <br />Ideally using VC2005 intrinsic file for defines to use MMX without going to full asm, I can move to pure asm afterwards.<br /><br />I?m guessing I need to use shorts for matrix and colour component values&nbsp; and then pack those into MMX registers. Use MMX to do the multiply and ADD although should that include saturation at this point? Since I need to add the two dword results together to get the final new component colour?<br /><br />I need to then extract the result and place it into a byte in the destination.<br /><br />Just looking for some pointers on how to start this, thanks.<br /><br />Oh any benifit do you think in re-arranging the matrix from Row to Column order? That way for each component the Matrix access will be sequential, as in red = m[0] m[1] m[2] m[3] instead of m[0] m[4] m[8] m[12]. I don&#39;t think it will afffect the ASM as Vc2005 uses offsets via , but perhaps its better for the cahce ?</div>
    <div class="meta">Posted on 2007-01-22 20:35:37 by noisecrime</div>
   </div>
  </div>
 </body>
</html>