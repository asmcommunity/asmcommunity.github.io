<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Software 3D engines - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=18907" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=18907">Software 3D engines</a></p>
   <div class="post" id="post-146323">
    <div class="subject"><a href="#post-146323">Software 3D engines</a></div>
    <div class="body">Hello everyone. I've recently been debating weather or not to start working on a completely software 3D engine. I'd appreciate some opinions on where to start and what approaches to take. For instance, I was thinking about doing rasterization first so that I can actually see what the geometry processing ends up with. I'd like to be able to implement antialiasing/multisampling/ansiotropic filtering and all of that other good (slow, heh) stuff. I'd be really interested to hear about your experiences designing a 3D software engine. If you're wondering, the reason I want it done in software is so that I can learn how things are being done. I'm not trying to write Unreal for cell phones or anything, I just want to be able to understand (code) all of that crazy and hard stuff like perspective correct texturing... even if at only 5 fps :alright:</div>
    <div class="meta">Posted on 2004-07-18 12:07:06 by AlexEiffel</div>
   </div>
   <div class="post" id="post-146359">
    <div class="subject"><a href="#post-146359">Software 3D engines</a></div>
    <div class="body">You're crazy man, but I like your style :)</div>
    <div class="meta">Posted on 2004-07-18 19:23:12 by Homer</div>
   </div>
   <div class="post" id="post-146382">
    <div class="subject"><a href="#post-146382">Software 3D engines</a></div>
    <div class="body">Well, bessides being crazy, I think you'ld learn a CRAP load of things, if you ever finish! To begin, I'd suggest Mesa, it's software based OpenGL, and it's open source (C/C++ with a bit of assembler, mainly for MMX &amp; SSE!)! Also, look at Crystal Space for the 3D engine part, particle systems, collision detection etc.<br /><br />Good luck!</div>
    <div class="meta">Posted on 2004-07-19 02:24:54 by SubEvil</div>
   </div>
   <div class="post" id="post-146391">
    <div class="subject"><a href="#post-146391">Software 3D engines</a></div>
    <div class="body">That's why people like Scronty and myself have been posting examples showing off various MODULES of a game engine.<br />With the right impetus, a team of us could write a game engine which both takes advantage of the available hardware and is of a modular design with (un)loadable code modules to suit anything in the field.</div>
    <div class="meta">Posted on 2004-07-19 05:56:37 by Homer</div>
   </div>
   <div class="post" id="post-146426">
    <div class="subject"><a href="#post-146426">Software 3D engines</a></div>
    <div class="body">EvilHomer2k - I've noticed the demos, but I haven't *really* looked at them. The biggest reason is that I'm trying to decide what to do first before I start implementing anything. But now that you've mentioned it, I could probably look at them and see how things are being broken up and use that to help me decide where to start. From all of your posts, I thought you had already done all of this stuff, heh.<br /><br />SubEvil - Finishing is actually one of my biggest concerns, heh. I'll take a look at Mesa as soon as I get the chance.<br /><br />I've actually been thinking about writing up tutorials as I go. I was thinking about doing one for each big problem. Starting with Line drawing, going to line clipping, to triangle filling, to triangle clipping....etc. Gah, now I'll *really* never finish, hehe.</div>
    <div class="meta">Posted on 2004-07-19 11:41:18 by AlexEiffel</div>
   </div>
   <div class="post" id="post-146473">
    <div class="subject"><a href="#post-146473">Software 3D engines</a></div>
    <div class="body">well, if i were you i wouldn't code it in win32asm. or at least, not in 100% win32asm</div>
    <div class="meta">Posted on 2004-07-20 05:26:20 by Mbee</div>
   </div>
   <div class="post" id="post-146491">
    <div class="subject"><a href="#post-146491">Software 3D engines</a></div>
    <div class="body">I think The Svin has a software render on his webpage.  Maybe 16-bit however.</div>
    <div class="meta">Posted on 2004-07-20 10:51:59 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-146507">
    <div class="subject"><a href="#post-146507">Software 3D engines</a></div>
    <div class="body">xlifewirex - I've thought about that as well, and I agree with you. I would like to do a lot of it in asm though, for the fpu/SSE practice if nothing else.<br /><br />ThoughtCriminal - Thanks for the info. I'll check it out and hopefully it's 32-bit asm.</div>
    <div class="meta">Posted on 2004-07-20 15:54:52 by AlexEiffel</div>
   </div>
   <div class="post" id="post-146522">
    <div class="subject"><a href="#post-146522">Software 3D engines</a></div>
    <div class="body">yes, but i can recommend to write it first in 100% c(++), and later optimize it. coding it in asm will divert you much from the actual algorithm, and it will save you really much time while developing it. for example, if you forgot a divide by z or something, it will be 2 key hits in c++, but it asm you should maybe have to re-order your fpu stack and other things that take much work.</div>
    <div class="meta">Posted on 2004-07-21 03:59:09 by Mbee</div>
   </div>
   <div class="post" id="post-147740">
    <div class="subject"><a href="#post-147740">Software 3D engines</a></div>
    <div class="body">I've actually thought about the same thing.  However, I do recommend that you at least get DirectX up and running.  You can still do software rendering/rasterization/texturing, etc., but you will gain the support of being able to be used under Windows.<br /><br />All you need to do is get access to the back buffer and you are essentially in a DOS32 environment.  From there you can write all your functions in assembly.<br /><br />Also with MMX support it is very possible to write extremely fast software rendering with filtering support.  I've attempted this in DJGPP but fell short because I didn't know how to get NASM to work inside of RHIDE (has since been remedied).<br /><br />If you need help in getting a bare bone's DirectX up and running let me know.  From there....it's all software, save for the page flipping.  And I complement you for wanting to learn what's going on in modern 3D engines.  Believe it or not my software experience has significantly shortened my learning curve in Direct3D.  Direct3D uses some of the same techniques the DOS gurus used to use in those days.  In fact, we wouldn't be where we are today without those gurus.<br />Now it's all hard-coded in hardware....but it's the same algos.</div>
    <div class="meta">Posted on 2004-08-09 10:52:35 by </div>
   </div>
   <div class="post" id="post-147742">
    <div class="subject"><a href="#post-147742">Software 3D engines</a></div>
    <div class="body">ASMBubba, thanks for your input. I was actually just doing the DX stuff yesterday. I first set things up in DDraw7. I wanted to get an idea of where I was starting, so I locked the backbuffer and wrote every pixel to the same color just to test the  frame rate. For some reason, when I run in FS mode, there is a flicker. I switched to D3D and had the same problem. I was able to fix it by setting the swap effect from D3DSWAPEFFECT_DISCARD to D3DSWAPEFFECT_COPY.<br /><br />Although I admit it was a quick test in C++ and I didn't optimize it at all, I'm a bit disappointed at the frame rate. 16 bit color at 640 x 480 was running at about 100 fps. I don't want to think what will happen once I start doing some math to calculate lighting, texturing, hidden surface removal, etc..<br /><br />On a related topic, I've been considering doing a ray tracer with photon mapping instead of a rasterizer. My reasoning is that with the programable GPUs, I think in the next 5 years or so, real time ray tracing will start to become the standard. If I can learn it now, then I'll be ahead of the curve when the PS4 and X-Box3 come out. Anyone have any comments about that?</div>
    <div class="meta">Posted on 2004-08-09 11:13:32 by AlexEiffel</div>
   </div>
   <div class="post" id="post-147766">
    <div class="subject"><a href="#post-147766">Software 3D engines</a></div>
    <div class="body">programming a software 3d engine isn't too hard, i mean thats all we did in the olden days :) the good olden demoscene days<br />as for realtime raytracer, they rock..<br />here's a link by some fellow demosceners realtime raytracing engine that i really respect<br /><a target="_blank" href="http://www.realstorm.com/">http://www.realstorm.com/</a></div>
    <div class="meta">Posted on 2004-08-09 17:41:56 by klumsy</div>
   </div>
   <div class="post" id="post-147783">
    <div class="subject"><a href="#post-147783">Software 3D engines</a></div>
    <div class="body">Yep, I got the same flicker.  In order to use it like we want to you must set your flags to D3DSWAPEFFECT_COPY.  <br /><br />D3DSWAPEFFECT_DISCARD and D3DSWAPEFFECT_FLIP do not work as intended.<br /><br />That will get rid of the flicker.<br /><br /><pre><code><br />_sPresentParams.BackBufferWidth            = width;<br />	_sPresentParams.BackBufferHeight           = height;<br />	_sPresentParams.BackBufferFormat           = D3DFMT_A8R8G8B8;<br />	_sPresentParams.BackBufferCount            = 1;<br />	_sPresentParams.MultiSampleType            = D3DMULTISAMPLE_NONE;<br />	_sPresentParams.MultiSampleQuality         = 0;<br />	_sPresentParams.SwapEffect                 = D3DSWAPEFFECT_COPY; <br />	_sPresentParams.hDeviceWindow              = hwnd;<br />	_sPresentParams.Windowed                   = windowed;<br />	_sPresentParams.EnableAutoDepthStencil     = true; <br />	_sPresentParams.AutoDepthStencilFormat     = D3DFMT_D24S8;<br />	<br />  //This must be set to lock back buffer<br />  _sPresentParams.Flags                      = D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;<br />	<br />  _sPresentParams.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;<br />	_sPresentParams.PresentationInterval       = D3DPRESENT_INTERVAL_DEFAULT;<br /></code></pre><br /><br />That should do the trick.</div>
    <div class="meta">Posted on 2004-08-09 21:27:59 by </div>
   </div>
  </div>
 </body>
</html>