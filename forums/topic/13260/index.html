<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Regular expressions - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=13260" />
    <link rel="next" href="../?id=13260&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=13260">Regular expressions</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=13260&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=13260&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="13260" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=13260&amp;page=2">&gt;</a><a href="../?id=13260&amp;page=2">&raquo;</a></form>   <div class="post" id="post-102824">
    <div class="subject"><a href="#post-102824">Regular expressions</a></div>
    <div class="body">Hi All,<br /><br />Are there any APIs that can build regular expressions?<br /><br />Regards, GJ</div>
    <div class="meta">Posted on 2003-05-13 11:19:32 by Green Joe</div>
   </div>
   <div class="post" id="post-102837">
    <div class="subject"><a href="#post-102837">Regular expressions</a></div>
    <div class="body">You might give a try to GNU regex source, if you translate the C header file you can use it with your assembler program.<br /><br />the source is<br />http://ftp.gnu.org/pub/gnu/regex/regex-0.12.tar.gz</div>
    <div class="meta">Posted on 2003-05-13 12:57:02 by _Servil_</div>
   </div>
   <div class="post" id="post-102887">
    <div class="subject"><a href="#post-102887">Re: Regular expressions</a></div>
    <div class="body"><div class="quote"><em>Are there any APIs that can build regular expressions?</em></div>No. But there will be libraries out there for that, but not necessarily free.</div>
    <div class="meta">Posted on 2003-05-13 17:10:01 by sluggy</div>
   </div>
   <div class="post" id="post-102912">
    <div class="subject"><a href="#post-102912">Regular expressions</a></div>
    <div class="body"><a target="_blank" href="http://www.pcre.org">http://www.pcre.org</a></div>
    <div class="meta">Posted on 2003-05-13 19:47:06 by iblis</div>
   </div>
   <div class="post" id="post-102916">
    <div class="subject"><a href="#post-102916">Regular expressions</a></div>
    <div class="body">neat, thx iblis :)</div>
    <div class="meta">Posted on 2003-05-13 20:01:47 by Hiroshimator</div>
   </div>
   <div class="post" id="post-103033">
    <div class="subject"><a href="#post-103033">Regular expressions</a></div>
    <div class="body">I had a look at the gnu source I  mentioned above and after some adjustments it should work fine with MASM, I hope the compiled library won't violate any rules as it's source is freeware.</div>
    <div class="meta">Posted on 2003-05-14 11:36:16 by _Servil_</div>
   </div>
   <div class="post" id="post-103042">
    <div class="subject"><a href="#post-103042">Re: Regular Exressions</a></div>
    <div class="body">Thanx a lot to everybody,<br /><br />Actually <a target="_blank" href="http://gnuwin32.sourceforge.net/packages.html">GNUWin32 site</a> lists as many as 4 different regular expression libraries to download.<br /><br /><ul><br />[*]PCRE (Perl Compatible Regular Expressins)<br />[*]RegEx-GNU<br />[*]RegEx-Spencer<br />[*]Rx<br /> <br /><br />A lot of work ahead to figure out which library for which purpose is the best. It should be really nice to get some short insights from people who already used one of this libraries in their applications.<br /><br />Regards, GJ</div>
    <div class="meta">Posted on 2003-05-14 12:30:06 by Green Joe</div>
   </div>
   <div class="post" id="post-103067">
    <div class="subject"><a href="#post-103067">Regular expressions</a></div>
    <div class="body">I've only used PCRE thus far.<br /><br />It's very easy to use, and the API is small so translating the .h to .inc shouldn't be very time consuming.  It also lets you specify your own malloc() and free() routines for it to call.<br /><br />I never tested for speed, but the project I used it in had no problems speedwise.  Parsing 20mb worth of HTML documents _multiple times took about 2 minutes.  And that's including all of the other non-regex related operations performed on it.</div>
    <div class="meta">Posted on 2003-05-14 14:40:41 by iblis</div>
   </div>
   <div class="post" id="post-124736">
    <div class="subject"><a href="#post-124736">Regular expressions</a></div>
    <div class="body">Here's an article on building a custom RegEx parser:<br /><br /><a target="_blank" href="http://www.codeguru.com/cpp_mfc/RegEx.html">http://www.codeguru.com/cpp_mfc/RegEx.html</a><br /><br /><br />Thanks,<br />_Shawn</div>
    <div class="meta">Posted on 2003-11-18 21:23:59 by _Shawn</div>
   </div>
   <div class="post" id="post-124746">
    <div class="subject"><a href="#post-124746">Regular expressions</a></div>
    <div class="body">The HLA Standard Library (<a target="_blank" href="http://webster.cs.ucr.edu">http://webster.cs.ucr.edu</a>) contains a &quot;pattern matching library&quot; module that lets you do generalized pattern matching in assembly language (context-free patterns as well as regular expressions). Alas, this is *one* of the few modules that doesn't translate to MASM real well because it takes advantage of HLA's powerful macro facilities. Nevertheless, you might want to take a look at it. I've posted a &quot;regular expression&quot; example from the &quot;Great Computer Language Shootout&quot; to this end of this post (note, btw, that this post includes the original C code as comments, followed by the HLA code). The cool thing here is that the assembly version is actually *shorter* (in terms of lines of code) than the C version.<br />Cheers,<br />Randy Hyde<br /><br /><pre><code><br />// regexpGCLS<br />//<br />//  This program demonstrates processing of regular expressions in<br />// assembly language. This is based on the &quot;regexp.gcc&quot; <br />// program that is part of &quot;The Great Computer<br />// Language Shoot-out&quot; found at<br />//<br />//      &#91;url&#93;http&#58;//www.bagley.org/~doug/shootout/&#91;/url&#93;<br />//<br />// The purpose of that web page is to demonstrate several<br />// applications written in various languages. Although one<br />// of the primary purposes of that web site is to demonstrate<br />// the different run-time efficiencies of various languages,<br />// this HLA implementation was not created to demonstrate<br />// that assembly code is faster or smaller &#40;everyone pretty<br />// much accepts the fact that the fastest and/or smallest<br />// example of a program will be written in assembly language&#41;.<br />// Instead, this example demonstrates that with the use of<br />// a high level assembler &#40;e.g., HLA&#41;, it's also possible to<br />// write code almost as easily as in a high level language<br />// like C. As such, this example freely sacrifices efficiency<br />// for readability.<br /><br />#if&#40; false &#41;<br /><br />    /* -*- mode&#58; c -*-<br />     * $Id&#58; regexmatch.gcc,v 1.4 2000/12/24 05&#58;43&#58;53 doug Exp $<br />     * &#91;url&#93;http&#58;//www.bagley.org/~doug/shootout/&#91;/url&#93;<br />     */<br /><br />    #include &lt;sys/types.h&gt;<br />    #include &lt;sys/stat.h&gt;<br />    #include &lt;fcntl.h&gt;<br />    #include &lt;stdio.h&gt;<br />    #include &lt;pcre.h&gt;<br />    #include &lt;string.h&gt;<br /><br />    #define MAXLINES   100<br />    #define MAXLINELEN 132<br /><br />    char *pattern = <br />    &quot;&#40;?&#58;^|&#91;^\\d\\&#40;&#93;&#41;&quot;       /* must be preceeded by non-digit */<br />    &quot;&#40;\\&#40;&#41;?&quot;            /* match 1&#58; possible initial left paren */<br />    &quot;&#40;\\d\\d\\d&#41;&quot;           /* match 2&#58; area code is 3 digits */<br />    &quot;&#40;?&#40;1&#41;\\&#41;&#41;&quot;         /* if match1 then match right paren */<br />    &quot;&#91; &#93;&quot;               /* area code followed by one space */<br />    &quot;&#40;\\d\\d\\d&#41;&quot;           /* match 3&#58; prefix of 3 digits */<br />    &quot;&#91; -&#93;&quot;              /* separator is either space or dash */<br />    &quot;&#40;\\d\\d\\d\\d&#41;&quot;        /* match 4&#58; last 4 digits */<br />    &quot;\\D&quot;               /* must be followed by a non-digit */<br />    ;<br /><br /><br />    int<br />    main&#40;int argc, char *argv&#91;&#93;&#41; &#123;<br />        int NUM = &#40;&#40;argc == 2&#41; ? atoi&#40;argv&#91;1&#93;&#41; &#58; 1&#41;;<br />        int count;<br />        char *cptr = &quot;&quot;;<br />        char **phones;<br />        pcre *re;<br />        int erroffset;<br />        const char *errptr;<br />        int n, lines = 0;<br />        char num&#91;256&#93;;<br />        int i, j, k, matchlen;<br />        char *matchoffset;<br />        int nmatches;<br />        int *ovec, ovecsize;<br />        pcre_extra *study;<br /><br />        phones = &#40;char **&#41;malloc&#40;MAXLINES * sizeof&#40;char *&#41;&#41;;<br />        if &#40;!phones&#41; &#123;<br />        fprintf&#40;stderr, &quot;malloc for phones array failed\n&quot;&#41;;<br />        exit&#40;1&#41;;<br />        &#125;<br />        lines = 0;<br />        while &#40;cptr&#41; &#123;<br />        phones&#91;lines&#93; = &#40;char *&#41;malloc&#40;MAXLINELEN&#41;;<br />        if &#40;!phones&#91;lines&#93;&#41; &#123;<br />            fprintf&#40;stderr, &quot;malloc to hold line #%d failed\n&quot;, lines&#41;;<br />            exit&#40;1&#41;;<br />        &#125;<br />        cptr = fgets&#40;phones&#91;lines&#93;, MAXLINELEN, stdin&#41;;<br />        lines++;<br />        if &#40;lines &gt; MAXLINES&#41; &#123;<br />            fprintf&#40;stderr, &quot;MAXLINES is too small\n&quot;&#41;;<br />            exit&#40;1&#41;;<br />        &#125;<br />        &#125;<br /><br />        re = pcre_compile&#40;pattern, 0, &amp;errptr, &amp;erroffset, NULL&#41;;<br />        if &#40;!re&#41; &#123;<br />        fprintf&#40;stderr, &quot;can't open compile regexp\n&quot;&#41;;<br />        exit&#40;1&#41;;<br />        &#125;<br /><br />        study = pcre_study&#40;re, 0, &amp;errptr&#41;;<br /><br />        if &#40;pcre_fullinfo&#40;re, NULL, PCRE_INFO_CAPTURECOUNT, &amp;nmatches&#41; != 0&#41; &#123;<br />        fprintf&#40;stderr, &quot;pcre_fullinfo failed\n&quot;&#41;;<br />        exit&#40;1&#41;;<br />        &#125;<br />        nmatches++;         /* add match of entire pattern */<br /><br />        ovecsize = sizeof&#40;int&#41; * nmatches * 3;<br />        ovec = &#40;int *&#41;malloc&#40;ovecsize&#41;;<br />        if &#40;!ovec&#41; &#123;<br />        fprintf&#40;stderr, &quot;malloc for ovec array failed\n&quot;&#41;;<br />        exit&#40;1&#41;;<br />        &#125;<br /><br />        count = 0;<br />        while &#40;NUM--&#41; &#123;<br />        for &#40;i=0; i&lt;lines; i++&#41; &#123;<br />            n = pcre_exec&#40;re, study,<br />                  phones&#91;i&#93;, strlen&#40;phones&#91;i&#93;&#41;, 0,<br />                  0, ovec, ovecsize&#41;;<br />            if &#40;n == nmatches&#41; &#123;<br />            /* stuff the match into the buffer &quot;num&quot; */<br />            k = 2*2;    /* initial offset into ovec */<br />            /* areacode */<br />            j = 0;<br />            num&#91;j++&#93; = '&#40;';<br />            matchoffset = phones&#91;i&#93; + ovec&#91;k&#93;;<br />            matchlen = ovec&#91;k+1&#93; - ovec&#91;k&#93;;<br />            strncpy&#40;num+j, matchoffset, matchlen&#41;;<br />            j += matchlen; k += 2;<br />            num&#91;j++&#93; = '&#41;';<br />            /* space separator */<br />            num&#91;j++&#93; = ' ';<br />            /* exchange */<br />            matchoffset = phones&#91;i&#93; + ovec&#91;k&#93;;<br />            matchlen = ovec&#91;k+1&#93; - ovec&#91;k&#93;;<br />            strncpy&#40;num+j, matchoffset, matchlen&#41;;<br />            j += matchlen; k += 2;<br />            /* dash */<br />            num&#91;j++&#93; = '-';<br />            /* last 4 digits */<br />            matchoffset = phones&#91;i&#93; + ovec&#91;k&#93;;<br />            matchlen = ovec&#91;k+1&#93; - ovec&#91;k&#93;;<br />            strncpy&#40;num+j, matchoffset, matchlen&#41;;<br />            j += matchlen; k += 2;<br />            /* with a cherry on top */<br />            num&#91;j&#93; = 0;<br />            if &#40;0 == NUM&#41; &#123;<br />                count++;<br />                printf&#40;&quot;%d&#58; %s\n&quot;, count, num&#41;;<br />            &#125;<br />            &#125;<br />        &#125;<br />        &#125;<br /><br />        for &#40;i=0; i&lt;MAXLINES; i++&#41; &#123;<br />        free&#40;phones&#91;i&#93;&#41;;<br />        &#125;<br />        free&#40;phones&#41;;<br />        free&#40;ovec&#41;;<br /><br />        return&#40;0&#41;;<br />    &#125;<br />#endif<br /><br /><br />program regexp;<br />#include&#40; &quot;stdlib.hhf&quot; &#41;<br />const<br />    MaxLines    &#58;= 100;<br /><br />static<br />    f           &#58;dword;<br />    i           &#58;uns32;<br />    filename    &#58;string;<br />    lineCnt     &#58;uns32;<br />    areaCode    &#58;str.strvar&#40;16&#41;;<br />    prefix      &#58;str.strvar&#40;16&#41;;<br />    suffix      &#58;str.strvar&#40;16&#41;;<br />    lines       &#58;string&#91; MaxLines &#93;;<br /><br />begin regexp;<br /><br />    if&#40; arg.c&#40;&#41; != 2 &#41; then<br /><br />        stdout.put&#40; &quot;Usage&#58; regexp &lt;filename&gt;&quot; nl &#41;;<br />        exit regexp;<br /><br />    endif;<br />    mov&#40; fileio.open&#40; arg.v&#40; 1 &#41;, fileio.r &#41;, f &#41;;<br />    mov&#40; 0, ebx &#41;;<br />    while&#40; !fileio.eof&#40; f &#41;&#41; do<br /><br />        fileio.a_gets&#40; f &#41;;<br />        mov&#40; eax, lines&#91; ebx*4 &#93; &#41;;<br />        inc&#40; ebx &#41;;<br />                <br />    endwhile;<br />    mov&#40; ebx, lineCnt &#41;;<br />    fileio.close&#40; f &#41;;<br />    for&#40; mov&#40; 0, i &#41;; mov&#40; i, edx &#41; &lt; lineCnt; inc&#40; i &#41;&#41; do<br /><br />        pat.match&#40; lines&#91; edx*4 &#93; &#41;;<br /><br />            pat.zeroOrMoreCset&#40; -&#123; '&#40;','0'..'9' &#125; &#41;;<br />            pat.zeroOrOneChar&#40; '&#40;' &#41;;<br />            pat.exactlyNCset&#40; &#123;'0'..'9'&#125;, 3 &#41;;<br />            pat.extract&#40; areaCode &#41;;<br />            pat.zeroOrOneChar&#40; '&#41;' &#41;;<br />            pat.zeroOrMoreWS&#40;&#41;;<br />            pat.exactlyNCset&#40; &#123;'0'..'9'&#125;, 3 &#41;;<br />            pat.extract&#40; prefix &#41;;<br />            pat.oneOrMoreCset&#40; &#123;'-', ' '&#125; &#41;;<br />            pat.exactlyNCset&#40; &#123;'0'..'9'&#125;, 4 &#41;;<br />            pat.extract&#40; suffix &#41;;<br /><br />            stdout.put&#40; i&#58;2,&quot;&#58; &#40;&quot;, areaCode, &quot;&#41; &quot;, prefix, '-', suffix, nl &#41;;<br /><br />            pat.if_failure;<br /><br />        pat.endmatch;<br /><br />    endfor;<br /><br />end regexp;<br /></code></pre></div>
    <div class="meta">Posted on 2003-11-18 22:38:12 by rhyde</div>
   </div>
   <div class="post" id="post-124774">
    <div class="subject"><a href="#post-124774">Regular expressions</a></div>
    <div class="body"><div class="quote"><br />The cool thing here is that the assembly version is actually *shorter* (in terms of lines of code) than the C version.</div><br /><br />HLA is a nice tool and I empathize with your zeal for promoting your brainchild.  However, comparing it for source size on a one to one basis with C, especially in this particular instance, is a little unfair I feel.<br /><br />The C version is larger for several reasons, for starters it rightly uses up its line count for things like error checking and comments, elements which seem to be missing from the HLA source.  You also get to see all the gory details of initializing and setting up the PCRE structures, using the returned data pointers to extract the substrings etc, whereas the gory details of HLA's regexp initialization and such seem to be almost completely hidden.  The level of abstraction is deeper certainly, but do realize that the same level of abstraction and simplification is also possible in C/C++ (especially C++), even if this particular author of the C source opted not to make us of it.<br /><br />But at the risk of damning this thread to the Crusades forum, I will stop there.  ;)</div>
    <div class="meta">Posted on 2003-11-19 04:44:01 by iblis</div>
   </div>
   <div class="post" id="post-124806">
    <div class="subject"><a href="#post-124806">Regular expressions</a></div>
    <div class="body"><div class="quote"><br /><br /><br />HLA is a nice tool and I empathize with your zeal for promoting your brainchild.  However, comparing it for source size on a one to one basis with C, especially in this particular instance, is a little unfair I feel.<br /></div><br /><br />Why?<br />C programmers get to take advantage of C features to reduce line counts, why cannot assembly programmers take advantage of their tools to do the same thing?<br /><br /><div class="quote"><br />The C version is larger for several reasons, for starters it rightly uses up its line count for things like error checking and comments, elements which seem to be missing from the HLA source.  <br /></div><br /><br />HLA uses exceptions to report errors. There is not need, for example, to check memory allocation failures. HLA will raise an exception and report that error should it occur. Ditto for conversion errors. Go ahead and subtract the comments from the C code, it still has more lines of code.<br /><br /><br /><div class="quote"><br />You also get to see all the gory details of initializing and setting up the PCRE structures, using the returned data pointers to extract the substrings etc, whereas the gory details of HLA's regexp initialization and such seem to be almost completely hidden.  <br /><div class="quote"><br />What HLA regexp initialization? Granted, you probably don't know much about HLA pattern matching library, but there is no extraneous initialization going on. As for extracting the substrings, that's exactly what statements like:<br /><pre><code><br />pat.extract&#40; areaCode &#41;;<br /></code></pre><br />are doing. All you're really complaining about is that it *does* take a small amount of study to understand HLA's pattern matching facilities. That's going to be true of any library routine you call (regular expression or otherwise). <br /><br /><div class="quote"><br />The level of abstraction is deeper certainly, but do realize that the same level of abstraction and simplification is also possible in C/C++ (especially C++), even if this particular author of the C source opted not to make us of it.<br /></div><br />Actually, having written the HLA Pattern Matching Library module, I can pretty much assure you that it would be quite difficult to do the same thing in C with anywhere near the performance level. One that that this example does not demonstrate is that HLA's pattern matching facilities fully support back-tracking when processing patterns (like the SNOBOL4 and Icon programming languages). Supporting *that* efficiently in C is quite a bit of work; in HLA it's automatic.<br /><br /><div class="quote"><br />But at the risk of damning this thread to the Crusades forum, I will stop there.  ;) <br /></div><br /><br />Yes, the OP asked for regexp library routines for assembly code. I provided the resource. An interesting artifact of the example is that it allows assembly programmers to write code that is shorter than a similar C program. Any further comments on that do belong in the colleseum and I would ask the moderator to move these two posts there if any additional replies appear.<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-11-19 10:14:50 by rhyde</div>
   </div>
   <div class="post" id="post-124830">
    <div class="subject"><a href="#post-124830">Regular expressions</a></div>
    <div class="body">My point is that the source line count or the amount of typing that must be done by the user is not necessarily a result of the language used, but relies heavily on how much work is already done for said user.<br /><br />I could pull all of that C code out of main() and put it in a library with a single exported function call called &quot;DoRandallsRegexpThingy()&quot; and then the user would only be required to write one line in main().  That is not to say that it would in any way be good programming practice to do so, but it illustrates my point.  How fair would it be to compare that 1 line (excluding the necessary lines of course) program to the HLA program you posted?  Not very.   Those programs, both the C and the HLA examples, may produce the same output, but they use completely different methods and different levels of abstraction to get the job done.  This is why you cannot justify the comparison you made.<br /><br />A true &quot;line count contest&quot; as it were, between C and HLA would be to write this program, or any other program for that matter, without using <strong>any</strong> library calls except perhaps, those procedures which may be needed to communicate with the operating system to perform very basic IO operations.</div>
    <div class="meta">Posted on 2003-11-19 14:58:23 by iblis</div>
   </div>
   <div class="post" id="post-124833">
    <div class="subject"><a href="#post-124833">Regular expressions</a></div>
    <div class="body"><div class="quote"><em>Originally posted by iblis </em><br />My point is that the source line count or the amount of typing that must be done by the user is not necessarily a result of the language used, but relies heavily on how much work is already done for said user.<br /><div class="quote"><br />Yes, that is an advantage of using HLA for pattern matching (e.g., regular expressions). Much has already been done for the user. And as it's a part of the HLA Standard Library, it's available for all (HLA) users any time they want it.<br /><br /><div class="quote"><br />I could pull all of that C code out of main() and put it in a library with a single exported function call called &quot;DoRandallsRegexpThingy()&quot; and then the user would only be required to write one line in main().  <br /></div><br /><br />If it were part of the C standard library, I'd buy that argument. But it's not. So it's not generally available to C programmers. Nor can C programmers call the HLA Standard Library pattern<br />matching routines because they mess with the stack like you wouldn't believe. The fact that these routines *do* appear in a standard assembly language library means that it is fair for assembly programmers to call them.<br /><br />The bottom line is &quot;how much effort does it take to solve this problem in a given language&quot;.<br />Obviously, if the solution already exists (i.e., pulling the code out of main and turning it into a function call) then there is trivial effort involved. OTOH, such a trivial solution also has a limited domain of applicability (who else would be able to use that library routine you've created?). The HLA solution is general. I can match regular expressions, context-free grammars, and all sorts of patterns using the pattern matching library. <br /><br />Line counts *don't* really matter. What matters is effort involved. And there's clearly less effort involved in writing the HLA code than in writing the C code for this particular application. And that's true even though the C code calls a non-standard library routine (i.e., you go out and find a regexp library on the net somewhere and decide to use that).<br /><br /><br /><div class="quote"><br />That is not to say that it would in any way be good programming practice to do so, but it illustrates my point.  How fair would it be to compare that 1 line (excluding the necessary lines of course) program to the HLA program you posted?  Not very.   Those programs, both the C and the HLA examples, may produce the same output, but they use completely different methods and different levels of abstraction to get the job done.  This is why you cannot justify the comparison you made.<br /></div><br />While we're arguing on the side of &quot;not fair&quot;, how about that regular expression library that the C code is *already* calling that's not part of the C standard library? Did you miss that? Already they've done what you claim can be done and it's still more work than the corresponding assembly code.<br /><br /><div class="quote"><br />A true &quot;line count contest&quot; as it were, between C and HLA would be to write this program, or any other program for that matter, without using <strong>any</strong> library calls except perhaps, those procedures which may be needed to communicate with the operating system to perform very basic IO operations. </div><br /><br />What makes that a true line count test? That's obviously skewed in favor of C as C supports arithmetic expressions and assembly does not. If you're going to eliminate the things that give HLA an advantage in certain application areas, it's quite clear that C will always win.<br /><br />The bottom line is that C generally requires less effort than assembly (HLA or otherwise). But sometimes, assembly wins. The amusing thing about this discourse is that the argument is usually the other way around (people arguing that counting lines does not prove assembly is worse than C). Pattern matching is not an area where C/C++ is a particularly good fit. It's not surprising that other languages (including assembly) can beat it at this task. OTOH, take a language like SNOBOL4 and it'll blow both HLA and C right out of the water (in terms of line count). The cool thing about assembly is that with the appropriate library routines and macros, assembly can be coerced to behave well in just about *any* problem domain. <br /><br />And, once again, I must point out that the OP asked for an assembly regexp parser. I provided one. They didn't ask for C code.  Though the HLA Standard Library Pattern matching routines are not a &quot;regular expression interpreter&quot;, it's very easy to specify any pattern using calls to these routines.<br />And if the programmer *really* wants to use a different assembler than HLA, they can always take your advice and code that pattern matching code in a simple HLA procedure and link that code into their other assembler (although you can call the HLA Pattern matching routines from any assembler, pushing the appropriate parameters for many of the routines is a bit of a bear because most assemblers don't provide a character set data type and other facilities that HLA has built-in).<br /><br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-11-19 15:28:38 by rhyde</div>
   </div>
   <div class="post" id="post-124838">
    <div class="subject"><a href="#post-124838">Regular expressions</a></div>
    <div class="body"><div class="quote"><em>Originally posted by randall.hyde </em><br />If it were part of the C standard library, I'd buy that argument. But it's not.</div><br />Well then the whole argument is invalid because PCRE is not a standard library.  But, a library, standard or otherwise, does not a language make.<br /><br /><div class="quote"><em>Originally posted by randall.hyde </em><br />So it's not generally available to C programmers. Nor can C programmers call the HLA Standard Library pattern<br />matching routines because they mess with the stack like you wouldn't believe.</div><br />I'm sure that I or most anybody could write a C library to wrap the HLA pattern matching routines.  As long as the calling stack is in the same state, and not overwritten, when the routine returns, then it would be a fairly easy task.<br /><br /><div class="quote"><em>Originally posted by randall.hyde </em><br />The fact that these routines *do* appear in a standard assembly language library means that it is fair for assembly programmers to call them.</div><br />Standardized by what committee?  I don't recall Microsoft releasing any such libraries with MASM, nor Borland with TASM.  You might have deemed it an HLA Standard Library but let's please not call it a &quot;standard assembly language library.&quot;<br />Does it matter if it's standard anyway?   Having a standard library handy might save you a little time searching for the appropriate 3rd party library but, standard or otherwise - it all gets the job done.<br /><br /><div class="quote"><em>Originally posted by randall.hyde </em><br />The HLA solution is general. I can match regular expressions, context-free grammars, and all sorts of patterns using the pattern matching library.</div><br />Right, and I can use any number of pattern matching libraries to do the same thing.  With the right string class library, for example, pattern matching could be as easy as &quot;string a = b.match(mypattern);&quot;  Of course that's C++ and not C, but an only slightly more obfuscated C version could be thrown together.<br /><br /><div class="quote"><em>Originally posted by randall.hyde </em><br />Line counts *don't* really matter. What matters is effort involved. And there's clearly less effort involved in writing the HLA code than in writing the C code for this particular application.</div><br />Are we not taking into account the proficiency of the individual programmer?  Certainly that also has a lot to do with the effort involved.  What would you have to say about the proficiency of the author of that C code?<br />And at the risk of sounding repetitive, I will reiterate that the effort involved relies heavily on the amount of effort that has already been done for the programmer.  I'm sure you spent many long hard hours putting together HLA's pattern matching library, wrapping it up all nice and tight so that it would be very easy to use and require almost no effort for the user.  The authors of PCRE might not have gone quite that far but that doesn't mean it's not possible to do.<br /><br /><div class="quote"><em>Originally posted by randall.hyde </em><br />While we're arguing on the side of &quot;not fair&quot;, how about that regular expression library that the C code is *already* calling that's not part of the C standard library? Did you miss that? Already they've done what you claim can be done and it's still more work than the corresponding assembly code.</div><br />See above replies.<br /><br /><div class="quote"><em>Originally posted by randall.hyde </em><br />What makes that a true line count test? That's obviously skewed in favor of C as C supports arithmetic expressions and assembly does not.</div><br />How is that skewed in favor of C?   Without anything but the most basic IO calls, each language will have a perfectly &quot;clean slate&quot; with which to start.  If you want to compare libraries, then do so.  But if you're going to compare two languages, then compare the languages, not the libraries.<br /><br /><div class="quote"><em>Originally posted by randall.hyde </em><br />If you're going to eliminate the things that give HLA an advantage in certain application areas, it's quite clear that C will always win.</div><br />I'm not here to slam or bash or even belittle HLA.  I don't know enough about it to do so, even if that was my intent.  I only wanted you to recognize the error in making general comparisons about the effort involved in HLA and C.</div>
    <div class="meta">Posted on 2003-11-19 16:38:35 by iblis</div>
   </div>
   <div class="post" id="post-124841">
    <div class="subject"><a href="#post-124841">Regular expressions</a></div>
    <div class="body">randall,<br /><div class="quote"><br />HLA uses exceptions to report errors.<br /></div><br />Do you mean use of SEH? Can you report the exact error back to the calling routine and let it handle it, or do you just do a generic 'error' kind of thing?</div>
    <div class="meta">Posted on 2003-11-19 17:07:28 by f0dder</div>
   </div>
   <div class="post" id="post-124851">
    <div class="subject"><a href="#post-124851">Regular expressions</a></div>
    <div class="body"><div class="quote"><br />randall,<br /><br />Do you mean use of SEH? Can you report the exact error back to the calling routine and let it handle it, or do you just do a generic 'error' kind of thing? </div><br /><br />Yes, SEH.<br />And yes, the calling routine can handle the exception or it can just pass it through.<br />In the case of simply aborting the program (as the original C code did), it's easiest just to let the run-time system deal with the exception.  OTOH, if you want to deal with in yourself, that's quite easy, e.g.,<br /><br /><pre><code><br />try<br />     &lt;&lt;protected statements&gt;&gt;<br /><br />  exception&#40; exceptionID &#41;<br />     &lt;&lt; code to handle specified exception &gt;&gt;<br /><br />  exception&#40; anotherExceptionID &#41;<br />     &lt;&lt; more code &gt;&gt;<br />  etc.<br /><br />endtry;<br /></code></pre><br /><br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-11-19 17:56:19 by rhyde</div>
   </div>
   <div class="post" id="post-124852">
    <div class="subject"><a href="#post-124852">Regular expressions</a></div>
    <div class="body">hm, seems a bit inflexible to me? Or am I wrong when I assume you handle memalloc-returning-null by trapping the resulting pagefault when null memory is dereferenced? Unless I'm missing something, it seems like it will be somewhat hard for the application to figure out exactly what the error is - after all, pagefaults can be caused by a number of things :)</div>
    <div class="meta">Posted on 2003-11-19 18:02:13 by f0dder</div>
   </div>
   <div class="post" id="post-124857">
    <div class="subject"><a href="#post-124857">Regular expressions</a></div>
    <div class="body"><div class="quote"><em>Originally posted by f0dder </em><br />hm, seems a bit inflexible to me? Or am I wrong when I assume you handle memalloc-returning-null by trapping the resulting pagefault when null memory is dereferenced? Unless I'm missing something, it seems like it will be somewhat hard for the application to figure out exactly what the error is - after all, pagefaults can be caused by a number of things :) </div><br /><br />When the malloc function cannot allocate the requested storage, it raises an exception. It does not return NULL or any other value like that. As such exceptions rarely occur, it's far more efficient to raise an exception in those rare cases when an allocation failure does occur versus forcing the caller to test a return result on every call.<br /><br />HLA, of course, supports all the normal hardware/OS exceptions, but it also gives applications the ability to raise their own exceptions. The malloc routine, for example, raises an ex.memoryAllocationFailure exception when it cannot allocate storage for a request.  Of course, if you don't put any try..endtry statements in your code, then *any* malloc call can raise this exception and you won't have a clue who caused it. OTOH, you can place a try..endtry call around each and every malloc call (if you so choose) to narrow the location down. Then again, a better solution is just to run the code through OllyDbg when you're getting the failure and you can pinpoint the source of the problem real quick. Exceptions are better used for taking corrective action in the code rather than as an expensive form of an assert statement.<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-11-19 22:09:04 by rhyde</div>
   </div>
   <div class="post" id="post-124860">
    <div class="subject"><a href="#post-124860">Regular expressions</a></div>
    <div class="body"><div class="quote"><em>Originally posted by iblis </em><br />Well then the whole argument is invalid because PCRE is not a standard library.  But, a library, standard or otherwise, does not a language make.<br /></div><br />Though I agree with the sentiment of your statement, the modern view is that the *standard* library is a part of the language.  Regardless of what academic language designers preach, however, the HLA Standard Library is an integral part of the HLA *system* (if you don't like the word *language*) and it's very rare to see any HLA code written that doesn't use the HLA stdlib (just like it's rare to find any C code that doesn't make C stdlib calls). In that sense, comparing the capabilities of the languages with their standard libraries is not too outrageous. Definitely not much beyond that, though. Otherwise we run into your complaint about burying the entire application into a &quot;library&quot; somewhere. <br /><br /><div class="quote"><br />I'm sure that I or most anybody could write a C library to wrap the HLA pattern matching routines.  As long as the calling stack is in the same state, and not overwritten, when the routine returns, then it would be a fairly easy task.<br /></div><br /><br />You could, conceivably, write an assembly functions that makes all the pattern matching calls to parse a particular pattern and return match/no match back to C, but it is not possible to call the pattern matching routines directly from C. In order to support backtracking, the individual routines leave lots of stuff on the stack and this would mess up the C compiler considerably.<br /><br /><br /><div class="quote"><br />Standardized by what committee?  I don't recall Microsoft releasing any such libraries with MASM, nor Borland with TASM.  You might have deemed it an HLA Standard Library but let's please not call it a &quot;standard assembly language library.&quot;<br /></div><br />The &quot;UCR Standard Library for 80x86 Assembly Programmers&quot; was around long enough (and pushed by the 16-bit edition of AoA) that you could consider it a &quot;standard assembly library.&quot; It was used by thousands of assembly programmers over the years. No, not an official standard, but the closest thing to a defacto standard that you're going to find.<br /><br />And as the creator of the HLA language, I have every right to define what belongs in the HLA Standard Library. Just like Microsoft could define what belongs in a MASM standard library or Borland could have defined what was in a TASM standard library.<br /><br />Now that HLA's Standard Library is available for MASM and FASM (probably with NASM coming along before too much longer), you're going to see a few more people using it. The fact that AoA/32-bits pushes the HLA Standard Library means that, in time, it's going to be just as accepted and used as the UCR stdlib package.<br /><br /><div class="quote"><br />Does it matter if it's standard anyway?   Having a standard library handy might save you a little time searching for the appropriate 3rd party library but, standard or otherwise - it all gets the job done.<br /></div><br />In the case of comparing langauges, of course it matters. Otherwise, the arguments always degenerate to &quot;well, I've published that application as a library module so it only takes one line of code to do it in language XYZ.&quot;<br />It is fair to include standard library modules defined for a language as you can reasonably expect those routines to be available wherever there is an implementation of that language. The same is not true for 3rd party libraries.<br /><br /><br /><div class="quote"><br />Right, and I can use any number of pattern matching libraries to do the same thing.  With the right string class library, for example, pattern matching could be as easy as &quot;string a = b.match(mypattern);&quot;  Of course that's C++ and not C, but an only slightly more obfuscated C version could be thrown together.<br /></div><br /><br />But that's the &quot;I could write that library module...&quot; attitude. If it doesn't already exist and you have to write it, you have to consider the cost of writing that module as part of the project's development effort (and, you have to tack on those lines of code in your KLOC count). The difference with HLA is that those routines are already written, documented, and tested. You can call them as-is. <br /><br /><div class="quote"><br />Are we not taking into account the proficiency of the individual programmer?  Certainly that also has a lot to do with the effort involved.  What would you have to say about the proficiency of the author of that C code?<br />And at the risk of sounding repetitive, I will reiterate that the effort involved relies heavily on the amount of effort that has already been done for the programmer.  I'm sure you spent many long hard hours putting together HLA's pattern matching library, wrapping it up all nice and tight so that it would be very easy to use and require almost no effort for the user.  The authors of PCRE might not have gone quite that far but that doesn't mean it's not possible to do.<br /></div><br /><br />No, it's quite possible to do the same things as the HLA pattern matching code in C (though probably not as efficiently). OTOH, the fact that it's not in the C/C++ standard library means that such code will not be known to most people who might want to use it. Rather than bother searching for a decent library routine to do this stuff (then figure out if it satisfies their needs), they just use Perl, Awk, or some similar string based language :-)<br /><br /><br /><div class="quote"><br />How is that skewed in favor of C?   Without anything but the most basic IO calls, each language will have a perfectly &quot;clean slate&quot; with which to start.  If you want to compare libraries, then do so.  But if you're going to compare two languages, then compare the languages, not the libraries.<br /></div><br /><br />Easy, HLA includes lots of library routines to handle things that are built into languages like C. For example, consider accessing elements of multi-dimensional arrays. Trivial in a language like C; hairy in &quot;pure&quot; assembly language. OTOH, if you use the HLA array.index macro, accessing elements of an n-dimensional static or dynamically allocated array is a piece of cake. Is it fair to force the assembly user to manually emit this code by hand while the C programmer can simply write &quot;A&quot;?  Again, as most HLA users make heavy use of the HLA Standard Library, I argue that it's prefectly fair to consider invocations of the array.index macro as this macro is available in every implementation of HLA.<br /><br /><div class="quote"><br />I'm not here to slam or bash or even belittle HLA.  I don't know enough about it to do so, even if that was my intent.  I only wanted you to recognize the error in making general comparisons about the effort involved in HLA and C. </div><br /><br />Who was making general comparisons? I was simply pointing out that in this one special case (pattern matching), it takes fewer lines of code to implement the solution in HLA than in C. Clearly, the reverse situation is the more common case.<br /><br />Here are some additional areas where HLA does a better job than C/C++:<br /><br />iterators: HLA has true iterators and a foreach loop. Those things that C++ programmers like to call iterators aren't even close. I can write a program containing a &quot;foreach&quot; loop that traverses a binary tree using pre-order, in-order, or post-order algorithms with fewer lines of code than I've ever seen in C or C++.<br /><br />delayed parameter evaluation: not even possible in C/C++. HLA fully supports call by name and call by evaluation parameters. It also supports thunks. Very important for many AI types of projects. <br /><br />value/reference parameters: HLA fully supports value and reference parameters of *all* types. C/C++ does not.<br /><br />macro processing: hey, the C/C++ preprocessor is the most pitiful example of a macro processor that could be written and still be called a macro processor.  It is no wonder that C programmers tend to shy away from using macros when they begin learning assembly language - they've been heavily prejudiced by the problems with the C preprocessor (it *can* be done right in a HLL, check out Dylan sometime).<br /><br />And, of course, all the normal things where assembly excels over C (such as complete control over the order of evaluation of arithmetic expressions, multiprecision operations, etc.).<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-11-19 22:36:50 by rhyde</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=13260&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=13260&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="13260" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=13260&amp;page=2">&gt;</a><a href="../?id=13260&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>