<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Regular expressions - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=13260" />
  <link rel="prev" href="../?id=13260&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=13260">Regular expressions</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=13260&amp;page=1" style="">&laquo;</a><a href="../?id=13260&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="13260" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-124872">
    <div class="subject"><a href="#post-124872">Regular expressions</a></div>
    <div class="body"><div class="quote"><em>Originally posted by Randall Hyde </em><br />Though I agree with the sentiment of your statement, the modern view is that the *standard* library is a part of the language.</div>The standard library is part of the language... okay.<br />So then pattern matching and other such things are a part of 80x86 assembly language itself?  Or is HLA not an assembler, but rather a separate language?  It seems that no matter what context I choose, be it HLA != assembler or HLA == assembler, contradictions seem to spring up.  Is HLA a completely different language or just an extension to ASM?  Because you seem to want to group it right along with ASM.<br /><br /><div class="quote"><em>Originally posted by Randall Hyde </em><br />The &quot;UCR Standard Library for 80x86 Assembly Programmers&quot; was around long enough (and pushed by the 16-bit edition of AoA) that you could consider it a &quot;standard assembly library.&quot; It was used by thousands of assembly programmers over the years. No, not an official standard, but the closest thing to a defacto standard that you're going to find.</div>More confusion.  Maybe you can clear things up for me a bit.<br />This University of California Riverside Standard Library for 80x86 Assembly Programmers.  This defines a set of standardized routines for all 80x86 assemblers, or just HLA?  The title would suggest it does for all of 80x86 programming everywhere.  Does Intel know about this?  Why don't they have any say in what goes in the ASM standard library?  Or do they?<br /><br /><div class="quote"><em>Originally posted by Randall Hyde </em><br />And as the creator of the HLA language, I have every right to define what belongs in the HLA Standard Library. Just like Microsoft could define what belongs in a MASM standard library or Borland could have defined what was in a TASM standard library.</div>There's a fuzzy area here.  Are we talking about language-wide standard libraries or compiler specific standard libraries?  Because I was under the assumption (see top quote) that we were talking about language libraries here.  And keep in mind the original argument and your refutation which started all of this because I will eventually revisit it.<br /><br /><div class="quote"><em>Originally posted by Randall Hyde </em><br />Now that HLA's Standard Library is available for MASM and FASM (probably with NASM coming along before too much longer), you're going to see a few more people using it. The fact that AoA/32-bits pushes the HLA Standard Library means that, in time, it's going to be just as accepted and used as the UCR stdlib package.</div>What level of acceptance are we talking about here?  This is the first time I've heard of the UCR stdlib believe it or not, and a search here on this ASM forum for &quot;UCR&quot; results in only a few links, most of which are in the HLA forum.  What guarantee do I and other users have that these libraries are in our best interests?  What level of thought and planning was put into them?<br /><br />This point is irrelevant and opinionated but I feel I should make it anyway:  I think that a &quot;standard library&quot; goes against the very nature of ASM programmers, who enjoy ASM for the freedom which it gives.  Not being bound to any standard.  The freedom to reinvent the wheel if we so choose, and also the freedom to let somebody else worry about the details if that too is what we want.  In my own ASM programming endeavors I've found myself making regular use of the C standard libraries via DLL.  And of course the library bundled with Hutch--'s MASM32 package comes in handy too.  But many times I like to forego these things and fiddle on my own.  If somebody came to me and said, &quot;Here, use this standard ASM library&quot;, I probably would not be able to hold back my amusement.<br /><br /><br /><div class="quote"><em>Originally posted by Randall Hyde </em><br />It is fair to include standard library modules defined for a language as you can reasonably expect those routines to be available wherever there is an implementation of that language. The same is not true for 3rd party libraries.</div>More contradiction.  Here, clearly you're not talking about compiler-specific libraries, rather, language-specific libraries.  But since when is the HLA library a &quot;standard&quot; for assembly language?  Is it?  isn't it?  Is it trying to be?<br />Remember your original argument -- that it's fair to compare the C (language-specific) stdlib to HLA's (compiler-specific) stdlib.   This argument falls apart here unless HLA is an entirely different language, in which case it would be no more of an assembler than MSVC is, with it's __asm keyword and whatnot.  It seems to me that the underlying classification of HLA which moves your arguments changes to suit your presented point.  I hope that you will establish some definitive answers to these questions for future arguments.<br /><br /><div class="quote"><em>Originally posted by Randall Hyde </em><br />But that's the &quot;I could write that library module...&quot; attitude. If it doesn't already exist and you have to write it, you have to consider the cost of writing that module as part of the project's development effort.</div>Yes, I could write that, and once I did, I could share it with others.  And do so easily.  Welcome to the internet.<br />And other than a few minutes, what's the cost of surfing the internet looking for a free ready-made 3rd party library that does what you need?<br /><br /><div class="quote"><em>Originally posted by Randall Hyde </em><br />Rather than bother searching for a decent library routine to do this stuff (then figure out if it satisfies their needs)</div>And what guarantees does the HLA stdlib have that it will satisfy one's needs?  Is this an argument or an infomercial?<br /><br /><div class="quote"><em>Originally posted by Randall Hyde </em><br />, they just use Perl, Awk, or some similar string based language :-)</div><br />Or include a string class library, of which there are many out there and freely available.<br /><br /><div class="quote"><em>Originally posted by Randall Hyde </em><br />Who was making general comparisons? I was simply pointing out that in this one special case (pattern matching), it takes fewer lines of code to implement the solution in HLA than in C.</div>You just answered your own question.  &quot;it takes fewer lines of code to implement the solution in HLA than in C&quot;<br />That right there, you just made one - a general comparison.  The correct way of stating that would be &quot;This HLA <em>example</em> takes fewer lines of code than is used in the C <em>example</em>.&quot;  Your way states something about both languages in a general manner, when the real objects to compare here are not the languages, but the <em>examples</em> -- the efficiency of the code itself, which is the responsibility of the coder, and the level of abstraction that each had to work with.  Any veteran C/C++ coder will tell you that that example up there is not exactly the best written one, and could be done a lot more compact, cleaner and easier, even if that means using a different pattern matching and string manipulation library.<br /><br /><br /><br /><div class="quote"><em>Originally posted by Randall Hyde </em><br />Here are some additional areas where HLA does a better job than C/C++:</div><br /><br /><div class="quote"><em>Originally posted by Randall Hyde </em><br />iterators: HLA has true iterators and a foreach loop. Those things that C++ programmers like to call iterators aren't even close.</div><a target="_blank" href="http://dictionary.reference.com/search?q=iterator">http://dictionary.reference.com/search?q=iterator</a><br /><em>An object or routine for accessing items from a list, array or stream one at a time.</em><br /><br />Are we redefining iterator here?  Last time I checked, C++ iterators did just that.<br /><br /><div class="quote"><em>Originally posted by Randall Hyde </em><br />delayed paraeter evaluation: not even possible in C/C++. HLA fully supports call by name and call by evaluation parameters.  It also supports thunks.  Very important for many AI types of projects.<br />value/reference parameters: HLA fully supports value and reference parameters of *all* types. C/C++ does not.<br />macro processing: hey, the C/C++ preprocessor is the most pitiful example of a macro processor that could be written and still be called a macro processor.  It is no wonder that C programmers tend to shy away from using macros when they begin learning assembly language - they've been heavily prejudiced by the problems with the C preprocessor (it *can* be done right in a HLL, check out Dylan sometime).</div>And that's wonderful.   I'm happy for you.   The right tool for the right job I always say.  I'm not a C zealot.<br /><br /><div class="quote"><em>Originally posted by Randall Hyde </em><br />such as complete control over the order of evaluation of arithmetic expressions.</div>Last time I checked, parantheses were used for this.<br /><br /><div class="quote"><em>Originally posted by Randall Hyde </em><br />In order to support backtracking, the individual routines leave lots of stuff on the stack and this would mess up the C compiler considerably.</div>Leaving data on the stack seems a little hackish and dangerous to me.  I hope that in the HLA Stdlib Manual there is a warning to the users about that somewhere.  How does this pattern matching library handle itself when the user overwrites the data it left on the stack?</div>
    <div class="meta">Posted on 2003-11-20 01:19:53 by iblis</div>
   </div>
   <div class="post" id="post-124918">
    <div class="subject"><a href="#post-124918">Regular expressions</a></div>
    <div class="body"><div class="quote"><br />The standard library is part of the language... okay.<br />So then pattern matching and other such things are a part of 80x86 assembly language itself?  Or is HLA not an assembler, but rather a separate language?  It seems that no matter what context I choose, be it HLA != assembler or HLA == assembler, contradictions seem to spring up.  Is HLA a completely different language or just an extension to ASM?  Because you seem to want to group it right along with ASM.<br /></div><br /><br />Just like IF, WHILE, RECORD, and CLASS are part of 80x86 assembly language :-)<br />Yes, I consider these library routines to be part of the HLA assembly language. HLA is a superset of 80x86 assembly language, just like MASM is a superset of 80x86 assembly language.<br /><br /><br /><div class="quote"><br />More confusion.  Maybe you can clear things up for me a bit.<br />This University of California Riverside Standard Library for 80x86 Assembly Programmers.  This defines a set of standardized routines for all 80x86 assemblers, or just HLA?  <br /></div><br />UCR stdlib is for MASM users writing 16-bit code for DOS. It's been around since approximately 1988. It is not at all compatible with HLA as HLA is a 32-bit flat model assembler.  I mentioned the UCR stdlib to simply point out that &quot;standardized&quot; assembly languages have predated HLA by many years.<br /><br /><br /><div class="quote"><br />The title would suggest it does for all of 80x86 programming everywhere.  Does Intel know about this?  Why don't they have any say in what goes in the ASM standard library?  Or do they?<br /></div><br />They don't even care about what goes into an assembler, apparently. According to what I've heard, Intel no longer supports the notion of an &quot;Intel Syntax&quot; for 80x86 assembly. They're happy as long as the assembler processes all the machine instructions they create.<br /><br /><div class="quote"><br />There's a fuzzy area here.  Are we talking about language-wide standard libraries or compiler specific standard libraries?  Because I was under the assumption (see top quote) that we were talking about language libraries here.  And keep in mind the original argument and your refutation which started all of this because I will eventually revisit it.<br /></div><br />In the case of HLA, we're talking about language-wide standard library. Of course, as there is only one implementation of HLA, we could also say that it's a compiler specific library, too. Then again, the library routines are callable from most other assemblers (with header files already existing for MASM and FASM), so who's to say it's even language specific. You do realize, of course, that MASM implements a different language than NASM, which implements a different language than FASM, which implements a different language than HLA, etc., right? <br />Nevertheless, though you can call HLA Standard Library routines from MASM, they're still &quot;HLA Standard Library routines&quot;. Just like you can call MASM32 lib routines from HLA. Those are still the MASM32 lib routines.<br /><br /><br /><div class="quote"><br />What level of acceptance are we talking about here?  This is the first time I've heard of the UCR stdlib believe it or not, and a search here on this ASM forum for &quot;UCR&quot; results in only a few links, most of which are in the HLA forum.  What guarantee do I and other users have that these libraries are in our best interests?  What level of thought and planning was put into them?<br /></div><br />If you write DOS code, go check 'em out.<br />FWIW, my scan for &quot;UCR Standard Library for 80x86 Assembly Language Programmers&quot; in Google turned up Webster (where you can find the library), several articles (including one that appeared in Dr. Dobb's Journal back in 1992, references to the library in the 16-bit edition of The Art of Assembly Language, lots of links from other web pages, and so on. If you really care, you might try the search over again with Google and check it out. Then again, the UCR stdlib is for 16-bit DOS programs and is a bit obsolete these days. That's why I created the HLA Standard Library -- to provide a 32-bit successor to the UCR stdlib.<br /><br /><div class="quote"><br />This point is irrelevant and opinionated but I feel I should make it anyway:  I think that a &quot;standard library&quot; goes against the very nature of ASM programmers, who enjoy ASM for the freedom which it gives.  Not being bound to any standard.  The freedom to reinvent the wheel if we so choose, and also the freedom to let somebody else worry about the details if that too is what we want.  In my own ASM programming endeavors I've found myself making regular use of the C standard libraries via DLL.  And of course the library bundled with Hutch--'s MASM32 package comes in handy too.  But many times I like to forego these things and fiddle on my own.  If somebody came to me and said, &quot;Here, use this standard ASM library&quot;, I probably would not be able to hold back my amusement.<br /></div><br /><br />Sure. Lots of asm programmers insist on reinventing the wheel every chance they get. How incredibly stupid! How many times do people have to write an &quot;integer to string&quot; conversion routine? But the presence of a &quot;standard assembly library&quot; in no way prevents someone from rewriting the functions to their heart's content (God knows that I've rewritten enough C standard library routines over the years). No one is taking away your freedom with a standardized library. What they're doing is saving you the grunt work of writing code that has been written thousands of times already and shouldn't be rewritten so you can concentrate on the real work at hand.<br /><br />Ever wonder why there are any &quot;real&quot; applications written in assembly? It's largely because most assembly programmers spend so much time reinventing library routines that they are bored with their project by the time they get around to the real application-specific work.<br /><br /><br /><div class="quote"><br />More contradiction.  Here, clearly you're not talking about compiler-specific libraries, rather, language-specific libraries.  But since when is the HLA library a &quot;standard&quot; for assembly language?  Is it?  isn't it?  Is it trying to be?<br /></div><br />Not at all. The HLA Standard Library is a set of library routines intended for use by HLA programmers. Porting it to other assemblers serves two purposes: (1) many of the routines are nice and they can save other assembly users some time, (2) the availability of the HLA stdlib for other assemblers means that someone can learn HLA and then switch to another assembler at some point in the future without having to give up the investment they've made in learning the HLA stdlib.<br /><br />Do I really expect MASM/FASM users to jump on the HLA stdlib bandwagon? Do I really care? What I do care about is ensuring that students learning assembly language programming don't have to write all these crazy routines themselves (which prevents them from learning a lot of assembly over the quarter) and I do want to assure them that if they learn the HLA stdlib routines can be called by code written with other assemblers should they need to switch at some point or another. If you really think that I care one way or another whether *you* adopt the HLA stdlib, you're mistaken. I stopped trying to tell &quot;expert&quot; assembly programmers how they should write their code *many* years ago. <br /><br /><div class="quote"><br />Remember your original argument -- that it's fair to compare the C (language-specific) stdlib to HLA's (compiler-specific) stdlib.   This argument falls apart here unless HLA is an entirely different language, in which case it would be no more of an assembler than MSVC is, with it's __asm keyword and whatnot.  It seems to me that the underlying classification of HLA which moves your arguments changes to suit your presented point.  I hope that you will establish some definitive answers to these questions for future arguments.<br /></div><br />__asm is not a &quot;C&quot; keyword. If you doubt what I'm say, make your argument over in comp.lang.c sometime. Your whole point about language-specific vs. compiler-specific is a complete red herring. The HLA Standard Library *is* a language specific library. It is specific to the HLA language. Period.<br /><br />Is HLA an entirely different language? Of course it is (anyone who knows the least amount of formal language theory realizes this is trivially true). This is a true statement for the language accepted by just about every assembler available for the x86 (i.e., when was the last time you saw MASM assembling NASM source code?).  Calling HLA Standard Library routines from MASM is about like calling C Standard Library routines from MASM.  Doing so doesn't make the C standard library a &quot;MASM Standard Library&quot;, nor does it make the &quot;HLA Standard Library&quot; a &quot;MASM Standard Library&quot; when you call HLA stdlib routines from MASM. The HLA stdlib is specific to the HLA language.<br /><br /><br /><div class="quote"><br />And what guarantees does the HLA stdlib have that it will satisfy one's needs?  Is this an argument or an infomercial?<br /></div><br />And what reason do you have to believe that it doesn't satisfy one's needs. What makes you think that the code you've written is any better than what's in the HLA stdlib. What makes you think the code you can find on the internet is any better than what's in the HLA stdlib?  Boy, do you like to argue for the sake of arguing, or what?<br /><br /><div class="quote"><br />You just answered your own question.  &quot;it takes fewer lines of code to implement the solution in HLA than in C&quot;<br />That right there, you just made one - a general comparison.  The correct way of stating that would be &quot;This HLA <em>example</em> takes fewer lines of code than is used in the C <em>example</em>.&quot;  Your way states something about both languages in a general manner, when the real objects to compare here are not the languages, but the <em>examples</em> -- the efficiency of the code itself, which is the responsibility of the coder, and the level of abstraction that each had to work with.  Any veteran C/C++ coder will tell you that that example up there is not exactly the best written one, and could be done a lot more compact, cleaner and easier, even if that means using a different pattern matching and string manipulation library.<br /></div><br /><br />Okay, put your money where you're mouth is.<br />Write a pattern matching library for me in C that is as powerful as the HLA Pattern Matching library module. You're the one claiming you've done this in the past and can do it in a few minutes. You've got *my* source code to look at. So now write a pattern matching package in C that is as easy to use, as efficient, and is as powerful as the HLA library module. Then you'll have made your point. Until then, you're arguments are a bit weak.<br /><br /><br /><br /><br /><br /><div class="quote"><br /><a target="_blank" href="http://dictionary.reference.com/search?q=iterator">http://dictionary.reference.com/search?q=iterator</a><br /><em>An object or routine for accessing items from a list, array or stream one at a time.</em><br /><br />Are we redefining iterator here?  Last time I checked, C++ iterators did just that.<br /></div><br />Try looking up iterators, as defined by the CLU language back in the late 60's/early 70's.  Any decent programming language design textbook will probably discuss this. If not, I'm sure the internet will provide lots of information if you look hard enough.  BTW, some languages (e.g., Icon) use the term &quot;generators&quot; here, too (a generator is a combination of an iterator and a coroutine).<br /><br />The things C++ programmers call &quot;iterators&quot; are more properly called &quot;cursors.&quot; C++ does not have the ability to implement true iterators. C# is getting close with its FOREACH loop, but it still has a ways to go.<br /><br /><div class="quote"><br />And that's wonderful.   I'm happy for you.   The right tool for the right job I always say.  I'm not a C zealot.<br /><br />Last time I checked, parantheses were used for this.<br /></div><br />You didn't check very closely. While searching for information about iterators, you might also look into sequence points and evaluation order. You'll discover that C and C++ don't guarantee evaluation order in  expressions.  E.g., &quot;F( a+b, c+d );&quot; The compiler can choose to evaluate &quot;c+d&quot; or &quot;a+b&quot; first, their choice. In the presence of side effects, this can make a big difference in the calculation. Sequence points define where C will assure you that all side effects have taken place, but they don't guarantee order of evaluation. Assembly is one of the *few* languages where you have absolute control over the order of evaluation. For some expressions (particularly those involving floating point), this can make a difference in the calculation. The really scary thing is that a lot of programmers out there seem to think that they can solve such problems using parentheses; they are, unfortunately, incorrect.<br /><br /><div class="quote"><br />Leaving data on the stack seems a little hackish and dangerous to me.  I hope that in the HLA Stdlib Manual there is a warning to the users about that somewhere.  How does this pattern matching library handle itself when the user overwrites the data it left on the stack? </div><br /><br />Exceptions leave stuff on the stack. Heck, procedure activation records put stuff on the stack. What happens when the user overwrites that data on the stack? Welcome to assembly language.<br /><br />Oh, yes, the HLA Stdlib manual *does* tell the reader about this.<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-11-20 15:09:10 by rhyde</div>
   </div>
   <div class="post" id="post-125059">
    <div class="subject"><a href="#post-125059">Regular expressions</a></div>
    <div class="body"><div class="quote"><em>Originally posted by randall.hyde </em><br />Ever wonder why there are any &quot;real&quot; applications written in assembly?</div><br />Hmmm, and what attributes must an application have before it can meet all of your criteria for a &quot;real&quot; application?<br /><br /><div class="quote"><em>Originally posted by randall.hyde </em><br />It's largely because most assembly programmers spend so much time reinventing library routines that they are bored with their project by the time they get around to the real application-specific work.</div><br />I disagree.  I think the reason you don't see many assembly-only programs is because it is not cost or time effective to write one, nor is it an industry standard except in very specific areas where it's necessary such as driver design and whatnot.<br /><br />I would never write an entire application in ASM, except for giggles.  If I am reinventing a library routine such as the integer conversion to string, which you seem to behold as so laughably trivial, then I am doing it because I am unhappy with its speed or implementation, and I need it optimized because it's one of the many bottlenecks in a time critical application.  You can try to devalue this all you want but the fact is that there is always room for improvement and it is irresponsible to ignore it if you don't have to.<br /><br />And sure, there are those stubborn crazy people that take pride in writing programs from scratch without relying on anybody else's code.  A lot of ASM programmers are like this, and while I or you might not think it's the best way to do things, who are we to condemn it or call it &quot;incredibly stupid&quot;?  Seems to me that's rather taking the Art <em>out</em> of Assembly Language.<br /><br /><div class="quote"><em>Originally posted by randall.hyde </em><br />If you really think that I care one way or another whether *you* adopt the HLA stdlib, you're mistaken. I stopped trying to tell &quot;expert&quot; assembly programmers how they should write their code *many* years ago.</div><br />I'm sorry, I seem to have forgotten where or when I proclaimed myself to be an expert assembly programmer, or even so much as implied it.  Please help me locate this instance and I will promptly edit it.<br /><br /><div class="quote"><em>Originally posted by randall.hyde </em><br />__asm is not a &quot;C&quot; keyword.</div><br />Didn't say it was.<br /><br /><div class="quote"><em>Originally posted by randall.hyde </em><br />And what reason do you have to believe that it doesn't satisfy one's needs. What makes you think that the code you've written is any better than what's in the HLA stdlib. What makes you think the code you can find on the internet is any better than what's in the HLA stdlib?</div><br />My comment was made under the assumption that you were trying to impose HLA's standard library as the worldwide standard 80x86 assembler library.  Apologies for the misunderstanding.<br /><br /><div class="quote"><em>Originally posted by randall.hyde </em><br />Try looking up iterators, as defined by the CLU language back in the late 60's/early 70's.  Any decent programming language design textbook will probably discuss this. If not, I'm sure the internet will provide lots of information if you look hard enough.</div><br />You will have to excuse me for having no formal training in computer language creation and design, as that was not my life's path.  But the C++ STL implementation of iterators does what I need it to do and it has yet to fail me.  It might not be language native iterators, but it's still performs its function, which is all that matters.<br /><br /><div class="quote"><em>Originally posted by randall.hyde </em><br />Okay, put your money where you're mouth is.<br />Write a pattern matching library for me in C that is as powerful as the HLA Pattern Matching library module.<br />You're the one claiming you've done this in the past and can do it in a few minutes.</div><br />Let's not cloud the issue with testosterone.<br />Please help me to locate where I said that I've written an entire pattern matching library.  I'm not able to find it.<br />What I did do is write a string class that included pattern matching functionality by wrapping PCRE, abstracting it to make string operations easier.  It very closely resembles Javascript's String object.  It also has additional mechanisms for matching nested patterns which is important for such things as XML parsing which is becoming increasingly more useful lately.  With it one could write something like &quot;myString.loadfile(&quot;foo.txt&quot;).match(&quot;g/bar/i&quot;).dump(stdout);&quot; and be done with it.  I realize that it can never quite compare with your life accomplishment so I won't bore you with further details.<br /><br /><div class="quote"><em>Originally posted by randall.hyde </em><br />You've got *my* source code to look at. So now write a pattern matching package in C that is as easy to use, as efficient, and is as powerful as the HLA library module. Then you'll have made your point. Until then, you're arguments are a bit weak.</div><br />You can zip up your pants and put the measuring tape away.   I think at this point you've quite made up your mind about how useless C is, and how the world of programming *should* be, and as I am not a programmer by trade there is clearly nothing I could do to persuade you otherwise.<br /><br />You simply made a generalization about C that was incorrect, and if you cannot see the fallacy in the statement then there's really no reason to continue arguing in circles.  But I will if you want.</div>
    <div class="meta">Posted on 2003-11-21 19:14:04 by iblis</div>
   </div>
   <div class="post" id="post-125078">
    <div class="subject"><a href="#post-125078">Regular expressions</a></div>
    <div class="body">Come on guys,<br /><br />Chill. HLA is something really extraordinary, and the use of a standard library can considerably cut down development time, as Randy puts it. Although, it doesn't stop you from developing your own replacements, it does help YOU. You can call HLA whatever you want: an assembler, a compiler, a preprocessor, a whole new language, or whatever. But it is for assembly language programmers and it surely has made its point -- learning asm easily. Period.<br /><br />It's evolution, so let it be.<br /><br />Regards,<br />Art</div>
    <div class="meta">Posted on 2003-11-21 23:41:43 by art_sands</div>
   </div>
   <div class="post" id="post-125084">
    <div class="subject"><a href="#post-125084">Regular expressions</a></div>
    <div class="body"><div class="quote"><br />You simply made a generalization about C that was incorrect, and if you cannot see the fallacy in the statement then there's really no reason to continue arguing in circles.  But I will if you want. </div><br /><br />You know, I went back and reread my original post. I cannot for the life of me see where I made any generalization at all. Here's what I said:<br /><br /><div class="quote"><br />The cool thing here is that the assembly version is actually *shorter* (in terms of lines of code) than the C version.<br /></div><br /><br />Later on, I did make the following generalization:<br /><br /><div class="quote"><br />The bottom line is that C generally requires less effort than assembly (HLA or otherwise). But sometimes, assembly wins. <br /></div><br /><br />You came back with:<br /><br /><div class="quote"><br />You just answered your own question. &quot;it takes fewer lines of code to implement the solution in HLA than in C&quot;<br />That right there, you just made one - a general comparison. <br /></div><br /><br />Which, quite frankly, is reading too much into the statement. IOW, you're nit-picking just to be argumentative.<br /><br />You also accuse me of having made up my mind that C is no good and assembly is a better language. Yet nowhere in this thread have I ever made such a *general* claim. I've claimed that for this particular regular expression problem, the HLA solution is shorter. I've also pointed out a few areas where HLA is better suited for the application domain than C. I have *not* made any inferences from which you could draw a conclusion like<br /><br /><div class="quote"><br />I think at this point you've quite made up your mind about how useless C is, and how the world of programming *should* be<br /></div><br /><br />As a matter of fact, I work in C and C++ every day. The fact that they are not the perfect language for every application (with or without in-line assembly) doesn't mean they're useless. Then again, it's important to realize that they are *not* perfect for every application and sometimes assembly *is* the better solution, even for &quot;real&quot; (i.e., large, non-demo) applications.<br /><br />But you're right. Once the level of the debate falls to the point where someone is making comments like<br /><br /><div class="quote"><br />Let's not cloud the issue with testosterone.<br />...<br />You can zip up your pants and put the measuring tape away. <br /></div><br />the debate is over.<br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-11-22 01:58:43 by rhyde</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=13260&amp;page=1" style="">&laquo;</a><a href="../?id=13260&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="13260" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>