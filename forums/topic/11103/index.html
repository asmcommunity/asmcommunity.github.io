<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Cheap Way to Speed up HLA Compiles of w.hhf - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=11103" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=11103">Cheap Way to Speed up HLA Compiles of w.hhf</a></p>
   <div class="post" id="post-83695">
    <div class="subject"><a href="#post-83695">Cheap Way to Speed up HLA Compiles of w.hhf</a></div>
    <div class="body">I have been profiling the HLA compilation of the following source file:<br /><br />program t;<br />#include( &quot;w.hhf&quot; )<br />begin t;<br />end t;<br /><br />(w.hhf, for those who don't know, is the include file that<br />includes the Windows' system constants, types, and API<br />declarations).<br /><br />When I first started seeing if I could speed this up, it took<br />about 25 seconds to compile on a 300MHz PII and about<br />17 seconds to compile on a 2GHz PIV (obviously, memory<br />access times are the bottleneck here; and processing the<br />w.hhf file touches so much memory that the cache gets<br />blown away).<br /><br />Almost 90% of the time was spent in the symbol table lookup<br />routine, even with the hash table algorithms (prior to adding<br />the hash table, compilation of this file took over 40 seconds<br />on the PII machine).  After hacking up the symbol table search<br />routine in assembly language, and a few other minor improvements,<br />I got the compile time down to 20 seconds on the PII and about<br />14.5 seconds on the PIV machine.  Not a tremendous improvement.<br /><br />After further research and profiling, I discovered that the record<br />declarations wind up doing a linear search for their data types, even<br />if they are part of a namespace.  I'm looking into fixing this right now,<br />but in the meantime, it suggests a quick optimization you can make<br />to speed up the compilation of programs that include w.hhf.<br /><br />The trick is to reorganize all the declarations in &quot;windows.hhf&quot;.<br />This file consists of a bunch of constants followed by a bunch of<br />type declarations.  Many of the type declarations are records, and<br />they're the ones that wind up doing a linear search.  To help speed<br />things up a little bit, move all the type declarations from the end of the<br />&quot;windows.hhf&quot; header file to the beginning of the file.  You'll have to<br />compile a sample program like my &quot;t.hla&quot; program above to discover<br />which constants need to be moved before certain type declarations<br />(i.e., there are several constants used as array bounds in the type<br />declarations, obviously those constant must be declared before their<br />first use).  This took me about 15 minutes to do.  Compilations of the<br />t.hla header file went from about 20 seconds down to 14 seconds.<br />I would expect a like increase in performance on the PIV machine<br />(though I'm not at that machine right now, so I can't run the test).<br /><br />Once again, I looked at the feasibility of doing &quot;pre-compiled header&quot;<br />files. With the HLA v1.x design, this just isn't practical.  <br />However, after profiling the compilation of t.hla, and discovering that<br />86% of the time is being spent in the linear search routines, processing<br />about 9000 lookups, while about 2% of the time is being spent in the<br />hash table routines, doing about 13,000 lookups, it's pretty clear that<br />I need to spend some time moving certain searches from the linear<br />lookups to the hash table lookups (already sped up the linear search<br />about as much as I can - faster code isn't so much the issue here as<br />avoiding a linear search altogether).<br /><br />I'll try and have something better by HLA v1.42.  My goal is to get the<br />compilation time for t.hla below 10 seconds on my 300MHz PII.<br />The fact that there are so many record field declarations in windows.hhf<br />and these wind up running a linear search is probably the main reason<br />for the slow compile times of this file.  So hopefully, I'll be able to kludge<br />something together so avoid the linear search once the search moves<br />beyond the record fields.<br /><br />Cheers,<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-02-25 14:25:32 by rhyde</div>
   </div>
   <div class="post" id="post-83869">
    <div class="subject"><a href="#post-83869">HLA v1.42 will compile w.hhf FAST!</a></div>
    <div class="body">Okay,<br />I've spent two days reworking the symbol table search routines<br />for HLA v1.42.  HLA now compiles the w.hhf header file much more rapidly.<br /><br />To recap HLA's symbol table history:<br /><br />HLA started out as a prototype design sometime around 1996.<br />Expecting to quickly design the assembler and then rewrite it<br />in itself, I never really paid much attention to the performance of the<br />assembler itself.  As I usually do, when first writing a compiler, I used<br />a simple (easy to verify) linear search for the symbol table lookup routines.<br /><br />Over the years, HLA's performance was never that bad.  The big performance<br />loss in the past has always been macro expansion (which is incredibly<br />disgusting in the current implementation).  For &quot;normal&quot; applications<br />(those that don't consist of thousands and thousands of lines of macro<br />invocations), HLA has always produced an executable in just a few seconds.<br />No big deal.<br /><br />The I ported Hutch's MASM32 windows.inc file from MASM to HLA.<br />An HLA program that includes &quot;w.hhf&quot; (which includes windows.hhf,<br />kernel32.hhf, gdi32.hhf, and user32.hhf) has something like 30,000<br />lines of code, and it's all very dense (averages just under a declaration<br />per line).  Attempting to compile this makes the linear search rear<br />its ugly head.<br /><br />The first time I attempted to compile the windows header file (sometime<br />back around HLA v1.38) the performance was absolutely dismal.<br />It took better than 40 seconds to compile just these header files into<br />an empty HLA program (on a 300MHz PII).<br /><br />Unfortunately, HLA had grown over the years and the symbol table data<br />structure had come to rely upon the linear search algorithm used to <br />search (and build) the symbol table.  A wholesale switch to a new<br />algorithm was out of the question.<br /><br />After careful consideration, I figured out that while a generic algorithm<br />change was not possible, I could use a specialized algorithm when<br />searching through namespaces (because namespaces don't support<br />arbitrarily deep nested lex levels like the symbol tables outside a<br />namespace).  So I devised a hash table algorithm for searching through<br />namespaces.  The idea was, I could put the windows declarations into<br />the &quot;w&quot; namespace and speed up searching through the symbol table<br />by a massive amount (the hash table has 256 entries for each namespace,<br />and my hash function does a fairly good job of distributing the symbols<br />through the hash space, so a speed up of approximately 100x seemed<br />doable and a speed up of 10x seemed imminently achievable).<br /><br />So I coded the Hash Table lookup algorithm for namespaces into HLA v1.39.<br />Compiles of the empty program that included w.hhf dropped from 40 seconds<br />to 25 seconds.  Far less improvement than I was expecting.<br /><br />So I did what any self-respecting assembly programmer would do, I recoded<br />the search routines (including the string compare) in assembly language.<br />This dropped compile times from 25 seconds down to about 21 seconds.<br />Not a real big improvement.<br /><br />The next step I made was really cheating.  I profiled the code and discovered<br />that my problem was that a lot of the time (even within the namespaces) the<br />linear search was still being used.  It turns out that record fields and parameter<br />lists couldn't use the hash table algorithm, they reverted to a linear search,<br />even when searching through the symbols found in the namespace (e.g.,<br />if a record field or a parameter had a user-defined type appearing in the<br />namespace, HLA would still do a linear search through the namespace for<br />that symbol).  As a result, my linear search function was still consuming 86%<br />of the compilation time (according to the Microsoft VC++ function profiler).<br />So, as I said, I cheated.  Recognizing that a linear search *can* be fast if the<br />symbol you're searching for occurs early in the list, I rearranged a lot of the<br />type and constant declarations in windows.hhf to speed up the linear search.<br />With no changes to HLA, I was able to reduce the compile time from about<br />21 seconds down to around 13-14 seconds.  Still, about 80% of the compilation<br />time was being spent in the linear search routines.<br /><br />The big problem was that HLA always looks up each identifier in the symbol<br />table once the scanner (lexical analyzer) discovers it has an ID. Generally,<br />fields of a record and parameter declarations are always undefined symbols.<br />Undefined symbols, of course, require a complete scan of the linear symbol<br />table list to determine that they are truly undefined.  This gets ugly since<br />we know (for a correct program, anyway), that the symbol is undefined to<br />begin with.  So I kludged up HLA *big-time* and added a new attribute,<br />&quot;@fast&quot; that you can attach to a namespace, e.g.,<br /><br />namespace w; @fast;<br /><br />    &lt;&lt; declarations &gt;&gt;<br /><br />end w;<br /><br />The &quot;@fast&quot; attribute tells HLA not to bother checking record/union field<br />declarations and parameter declarations to see if the symbol is undefined.<br />The scanner skips the symbol lookup and immediately returns &quot;undefined symbol&quot;.<br /><br />This is a big kludge because you cannot just arbitrarily put &quot;@fast&quot; on<br />a namespace.  Doing so may create some problems, consider the following:<br /><br />namespace error; @fast;<br /><br />const<br />   somesym := 5;<br />   somesym := 6;<br /><br />end error;<br /><br />Under normal circumstances, HLA should return a &quot;duplicate symbol error&quot;<br />when it hits the second occurrence of &quot;somesym&quot; in the const declaration<br />section.  However, with the &quot;@fast&quot; option, HLA always returns &quot;undefined symbol&quot;<br />for the symbols you are declaring in the const section (as well as other sections),<br />so HLA will not properly report the error.<br /><br />Therefore, you should *never* use the @fast attribute when developing<br />the declarations for a namespace.  However, once the namespace declarations<br />become stable (e.g., for a set of library routines), then you can attach the<br />@fast attribute to the namespace to speed up compilation when building<br />an application that includes the namespace.  Of course, you should take care to<br />delete the @fast attribute when making modifications to the namespace.<br />Indeed, I suggest doing something like this:<br /><br />namespace ns; #if( @defined( fastNamespaces )) @fast; #endif<br /><br />  &lt;&lt;declarations&gt;&gt;<br /><br />end ns;<br /><br />Then if you run HLA (presumably from a makefile) using a statement<br />like the following you will get a fast compile:<br /><br />hla -DfastNamespaces fileContainingNS.hla<br /><br />Adding the @fast option sped up HLA a little bit, but when compiling<br />the w.hhf header file (and all that it includes), there was still a tremendous<br />amount of linear searching taking place.  Although the @fast attribute<br />spares HLA from looking up X and Y in the following example, HLA still<br />had to do a linear search on A and B:<br /><br />namespace w; @fast;<br />type<br />      A:int32;<br />      B:qword;<br /><br />      r:record;<br />           X:A;<br />           i:int32;<br />      endrecord;<br /><br />      p:procedure( X:B );<br /><br />end w;<br /><br />So, just for the w.hhf file, I added another couple of *big* kludges<br />to HLA's symbol table lookup routines to do only a linear search<br />within the parameter list or record field list and then switch back to<br />a hash table search algorithm once outside the parameter list or<br />field list.  There are still a few weird cases where HLA has to resort<br />to a linear search, but they rarely occur (certainly they are rare in<br />the w.hhf header file), so such uses of the linear search do not have<br />a big impact on compile time.<br /><br />The end result?<br />Well, after adding @fast and modifying (i.e., kludging) HLA to<br />handle record/union field lists and parameter lists specially, the<br />compile time for the empty program that includes w.hhf fell from<br />about 13-14 seconds to under two seconds (still on a 300MHz PII).<br /><br />Now, it is practical to simply include the entire w.hhf header file<br />whenever compiling an arbitrary Win32 application (e.g., a small<br />app like &quot;Hello World&quot;).<br /><br />In comparison to other assemblers, HLA is still several times slower.<br />For example, SpAsm, which the author claims is &quot;blazing fast&quot;<br />compiles a 1MB source file producing a 300K PE file in 3.16 seconds<br />on K6/200/Win95 (I compile on a PII/300/W2K).  Now, the empty<br />program I'm compiling produces no object code, so this is far from<br />a direct comparison (OTOH, I have no idea what's contained in that<br />300K PE file, either, so a direct comparison isn't that easy).<br />Nevertheless, you can see that HLA compile times now compare<br />reasonably well on fast machines against assemblers that are<br />written in pure assembly language (note that my compile times<br />include running HLA.EXE, HLAPARSE.EXE, ML.EXE, and LINK.EXE,<br />whereas SpAsm's times are measured running the assembler<br />from within an IDE, which is going to be faster).<br /><br />Now I'm not going to sit here and claim that HLA is as fast as<br />a well-written assembler that has been coded in assembly language.<br />Even with the changes I've made to HLA, I can still make it run<br />really slow (just create a file with thousands of user-written macro<br />invocations, you'll slow HLA down).  Nonetheless, it is interesting<br />to see that a program written in a VHLL (FLEX/Bison) doesn't<br />do such a bad job.<br /><br />BTW, for those who are interested, HLA now spends most of its<br />time in the parser (about 36% of the time) and the lexer (about<br />25% of the time) and the linear symbol table search routine<br />only consumes about 2% of the total execution time;  this<br />is about as it should be (note that there are no macro invocations<br />when compiling the w.hhf file by itself;  I'm sure the lexer and<br />the macro expansion-related functions would consume the vast<br />majority of the time if there were a lot of macro invocations).<br /><br />This new, faster version of HLA will appear in the HLA v1.42 release.<br />That's still a few weeks off: I need to test the FASM code generator<br />quite a bit more, and furthermore, a big change like I've made to the<br />symbol table routines is bound to break something, I've done very<br />little testing at this point so I don't really know that my changes are<br />working properly yet (compiling the w.hhf header file without error<br />is one thing, using those definitions is something else entirely).<br />In any case, just thought I'd keep you up to date on what's going on here.<br />Randy Hyde</div>
    <div class="meta">Posted on 2003-02-26 12:18:33 by rhyde</div>
   </div>
  </div>
 </body>
</html>