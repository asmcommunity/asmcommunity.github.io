<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Fast and small Multiplicative Random number generator - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30801" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=30801">Fast and small Multiplicative Random number generator</a></p>
   <div class="post" id="post-215591">
    <div class="subject"><a href="#post-215591">Fast and small Multiplicative Random number generator</a></div>
    <div class="body">Hi everybody,<br /><br />some days ago i started thinking upon a<br />fast and simple random number generator of few<br />lines of codes, wondering about the use of<br />MUL and RDTSC. after some &quot;deviations&quot; from the theory&nbsp; :D<br />i stumbled upon this following idea of mine:<br /><br /><pre><code>.randomB:<br />&nbsp;  rdtsc<br />&nbsp;  mov rcx,866AA7&#039;3F0B&#039;7F&#039;0B&#039;03h<br />&nbsp;  movd mm0,eax<br />&nbsp;  movq mm1,rcx<br />&nbsp;  pshufw mm0,mm0,00&#039;10&#039;01&#039;00b<br />&nbsp;  pmaddwd mm1,mm0<br />&nbsp;  pshufb mm1,mm0<br />&nbsp;  pmullw mm1,mm0<br />&nbsp;  movq rax,mm0<br />&nbsp;  movq rcx,mm1<br />&nbsp;  mul rdx<br />&nbsp;  sub rax,rcx<br />&nbsp;  ret</code></pre><br /><br />then using ENT to test some of its features<br />here what i have found:&nbsp; :O<br /><br />ent result.bin<br /><strong>Entropy = 7.841899 bits per byte.</strong><br /><br />Optimum compression would reduce the size<br />of this 130800 byte file by <strong>1 percent</strong>.<br /><br />Chi square distribution for 130800 samples is 29972.95, and randomly<br />would exceed this value less than 0.01 percent of the times.<br /><br />Arithmetic mean value of data bytes is <strong>129.7706</strong> (127.5 = random).<br />Monte Carlo value for Pi is <strong>3.139266055</strong> (error 0.07 percent).<br />Serial correlation coefficient is<strong> -0.001012</strong><br />(totally uncorrelated =0.0).<br /><br />i dont know how to read it to evaluate my algo.<br />could you please help me ?<br /><br />ent link is at<br />http://www.fourmilab.ch/random/<br /><br />and the following 2 screenshots using gnuplot<br /><br />total distribution of 65536 items with value ANDed to 65535<br />http://sites.google.com/site/x64lab/randomB_ganz.gif?attredirects=0<br /><br />and a detail of it<br />http://sites.google.com/site/x64lab/randomB_detail.gif?attredirects=0<br /><br />i have drawn some <strong>blu lines</strong> to denote visible<br />constant &quot;holes&quot; inside it.<br /><br />Hints, general guidelines about the subject,<br />improvements, your opinion on the results well appreciated<br /><br />Thanx in advance,<br />Cheers,<br /></div>
    <div class="meta">Posted on 2011-12-19 07:15:58 by hopcode</div>
   </div>
   <div class="post" id="post-215592">
    <div class="subject"><a href="#post-215592">Re: Fast and small Multiplicative Random number generator</a></div>
    <div class="body">hopcode, heres a rand i coded a long time ago for testing sorting algos.<br /><br /><pre><code><br />mov esi, offset buffer&nbsp; &nbsp; &nbsp; &nbsp; ;buffer for rand output<br />mov edi, 500000d&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;size in bytes<br />mov ebx, 49282048h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;seed<br />add edi, esi<br />xor ecx, ecx<br /><br />@@:<br />rdtsc<br />rol eax, 5<br />lea eax,<br />shr eax, 3<br />ror edx, 3<br />lea edx,<br />rol edx, 7<br />or eax, edx<br />add eax, esi<br />add cl, al<br />ror cl, 3<br />rol eax, cl<br />xor cl, al<br />add cl, ah<br />rol eax, cl<br />lea eax, <br />xor eax, ebx<br />mov cl, bh<br />mov ch, bl<br />ror cx, cl<br />rol ax, cl<br />ror eax, 15<br />lea eax, <br />and ecx, ebx<br />ror eax, cl<br />mov , eax<br />rdtsc<br />mov ebx, eax<br />lea ebx, <br />lea ecx, <br />rol ebx, cl<br />lea ebx, <br />ror cx, cl<br />ror ebx, cl<br />add esi, 4<br />cmp edi, esi<br />jl @B<br /></code></pre><br /><br />1gb of data generated by this rand, tested with ent:<br /><br />Entropy = 8.000000 bits per byte.<br /><br />Optimum compression would reduce the size<br />of this 1073741824 byte file by 0 percent.<br /><br />Chi square distribution for 1073741824 samples is 268.19, and randomly<br />would exceed this value 50.00 percent of the times.<br /><br />Arithmetic mean value of data bytes is 127.4989 (127.5 = random).<br />Monte Carlo value for Pi is 3.141590272 (error 0.00 percent).<br />Serial correlation coefficient is 0.000092 (totally uncorrelated = 0.0).<br /><br />its fairly late but ill chime in on this some more tomorrow.<br /><br /><br /></div>
    <div class="meta">Posted on 2011-12-20 01:25:43 by paradox</div>
   </div>
   <div class="post" id="post-215593">
    <div class="subject"><a href="#post-215593">Re: Fast and small Multiplicative Random number generator</a></div>
    <div class="body">Hi paradox,<br /><div class="quote"><br />1gb of data generated by this rand, tested with ent:<br />Entropy = 8.000000 bits per byte.<br />Optimum compression would reduce the size<br />of this 1073741824 byte file by 0 percent.<br />Chi square distribution for 1073741824 samples is 268.19, and randomly<br />would exceed this value 50.00 percent of the times.<br />Arithmetic mean value of data bytes is 127.4989 (127.5 = random).<br />Monte Carlo value for Pi is 3.141590272 (error 0.00 percent).<br />Serial correlation coefficient is 0.000092 (totally uncorrelated = 0.0).<br />its fairly late but ill chime in on this some more tomorrow.<br /></div><br />that&#039;s very <strong>very</strong> nice. with those values it deserves more than <br />simple attention. i must say that i thought soemthing like a delta from 2 or more<br />RDTSC instructions, just because it is a non-serialized instruction...<br />i need some times for a diehard battery test on it, and porting it<br />to SSE 64bit eventually. stay tuned and<br />Thanks a lot,<br /><br />Cheers<br /></div>
    <div class="meta">Posted on 2011-12-20 02:01:07 by hopcode</div>
   </div>
   <div class="post" id="post-215594">
    <div class="subject"><a href="#post-215594">Re: Fast and small Multiplicative Random number generator</a></div>
    <div class="body">well, after diehard testing, i must say that the algo performs very well.<br />all values are like expected , or in the average.<br />i can share results if someone needs it. that is very simple and straightforward.<br />now, calling ECX the &quot;state&quot; and EBX the seed, it is very interesting the part 2<br />after the second RDTSC, where the seed will be elaborated. <br />i find the following line funny,<br /><pre><code><br />add eax, esi<br /></code></pre><br />because the fact that offset in memory is being added <br />to the final random number let me guess that, with some little modifications<br />this algo may be totally reversible i.e., given a state and a seed<br />one should be able to rebuild the offset in memory from the random number.<br /><br />Bravo!, paradox.&nbsp; :)<br /><br />ok,now a little modification of my algo and some explanation<br /><pre><code><br />	rdtsc<br />	rol dx,4<br />	rol ax,3<br />	mov rcx,866AA7&#039;3F0B&#039;7F&#039;0B&#039;03h<br />	movd mm0,eax<br />	movq mm1,rcx<br />	pshufw mm0,mm0,01&#039;00&#039;01&#039;00b<br />	pmaddwd mm1,mm0<br />	pshufb mm1,mm0<br />	movq rax,mm0<br />	movq rcx,mm1<br />	mul rdx<br />	ret 0<br /></code></pre><br />with following unstable results yet on the x<sup>2</sup>.<br />they are yet around 30% and 70%<br /><span class="mono">Entropy = <strong>7.999309 bits per byte.</strong><br />Optimum compression would reduce the size<br />of this 262144 byte file by <strong>0 percent.</strong><br /><br />Chi square distribution for 262144 samples is 250.54, and randomly<br />would exceed this value <strong>56.72 percent</strong> of the times.<br /><br />Arithmetic mean value of data bytes is <strong>127.7175</strong> (127.5 = random).<br />Monte Carlo value for Pi is <strong>3.140306706</strong> (error 0.04 percent).<br />Serial correlation coefficient is <strong>-0.000857</strong> (totally uncorrelated = 0.0).<br /></span><br />cut away the <strong>pmullw</strong>, because too much aggressive<br />the <strong>pshufb</strong> is aggressive too, but i dont know how to resolve it at the moment.<br /><br />i know it&#039;s quite mpossible to have a good rng without using a seed+state.<br />but that is the challenge, or ?<br /><br />Cheers,<br /></div>
    <div class="meta">Posted on 2011-12-20 07:54:30 by hopcode</div>
   </div>
   <div class="post" id="post-215595">
    <div class="subject"><a href="#post-215595">Re: Fast and small Multiplicative Random number generator</a></div>
    <div class="body">Don&#039;t forget to execute emms after using MMX, else the next FPU instruction will cause an exception because the FPU stack is in a bad state.<br />(Not required for SSE, one of the best reasons to always use SSE registers for MMX operations).</div>
    <div class="meta">Posted on 2011-12-20 09:25:59 by Scali</div>
   </div>
   <div class="post" id="post-215598">
    <div class="subject"><a href="#post-215598">Re: Fast and small Multiplicative Random number generator</a></div>
    <div class="body">sorry for the late reply work has been crazy lately.<br /><br />anyways random is hard to define with statistical testing, what we can do is check for glaring errors and repetitive data.&nbsp; like you have already found images are a great way to look at data.<br /><br />example php rand under windows:<br /><img src="http://imageshack.us/photo/my-images/843/randombogorand.png" /><br />http://imageshack.us/photo/my-images/843/randombogorand.png<br /><br />if i remember correctly diehard has been unsupported for quite some time, most people now a days are using NISTs random testing suite<br />http://csrc.nist.gov/groups/ST/toolkit/rng/documentation_software.html<br /><br />if i have some time this weekend ill run my code though the new nist tests and see how it pans out.<br /></div>
    <div class="meta">Posted on 2011-12-22 01:20:57 by paradox</div>
   </div>
   <div class="post" id="post-215600">
    <div class="subject"><a href="#post-215600">Re: Fast and small Multiplicative Random number generator</a></div>
    <div class="body"><div class="quote"><br />if i remember correctly diehard has been unsupported for quite some time, most people now a days are using NISTs random testing suite<br />http://csrc.nist.gov/groups/ST/toolkit/rng/documentation_software.html<br /></div><br />yes, diehard is somewhat old,verbose but good. i have given a look to the NIST package and<br />the code inside is clean and effective. i think it deserves a porting to assembly,<br />because almost 100% optimizable. as i have some time i will start<br />to do it as coding exercise on the contained functions.<br />thanks for sharing.<br /><br />i have managed to let my algo behave in a more stable way,<br />when outputting the chi-square, at the moment <u>+</u>20% the normal,<br />considering other values are ok;<br />the whole is acceptable, but in some way not fully satisfying.<br /><br />ok, thank You again for the precious link,<br />All the best,<br /><br />Cheers,<br /><br /><br /><br /><br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2011-12-22 15:07:12 by hopcode</div>
   </div>
   <div class="post" id="post-215606">
    <div class="subject"><a href="#post-215606">Re: Fast and small Multiplicative Random number generator</a></div>
    <div class="body">I once fused Park-Miller with Mersenne Twister (B), and it&#039;s never let me down.<br />See SuperRandom.<br /></div>
    <div class="meta">Posted on 2011-12-23 02:22:29 by Homer</div>
   </div>
   <div class="post" id="post-215630">
    <div class="subject"><a href="#post-215630">Re: Fast and small Multiplicative Random number generator</a></div>
    <div class="body">Hi, sorry for late answering.<br />Merry Xmas and Happy New coming 2012&nbsp; :)<br /><div class="quote"><br />I once fused Park-Miller with Mersenne Twister (B), and it&#039;s never let me down.<br />See SuperRandom.<br /></div><br />nuclear cold-fusion eh ? :) <br />just kidding...<br />but i cannot find SuperRandom code. could You provide it (in assembly) ?<br /><br />here a link to my Park-Miller-Carta implementation, getting rid of Whittle&#039;s<br />final if-correction.<br />It is branchless now and satisfies Park&#039;s minimum standard requirements.<br /><a target="_blank" href="http://sites.google.com/site/x64lab/home/reloaded-algorithms/park-miller-carta-random-lcg">http://sites.google.com/site/x64lab/home/reloaded-algorithms/park-miller-carta-random-lcg</a><br /><br />btw: my curiosity, what&#039;s the goal in mixing Park-Miller with Mersenne ?<br />i.e. on what purpouse did You mix them ?<br /><br />Cheers,<br /><br /></div>
    <div class="meta">Posted on 2011-12-27 07:31:13 by hopcode</div>
   </div>
   <div class="post" id="post-215671">
    <div class="subject"><a href="#post-215671">Re: Fast and small Multiplicative Random number generator</a></div>
    <div class="body">Yeah I can provide the code, but essentially it works as follows:<br /><br />For each step (ie request for a random number), <br />1. Generate a Park Miller random, and set it as Seed for Mersenne.<br />2. Generate a mersenne random, and set it as Seed for Park Miller. This is your random number for your request.<br />3. At some count of iterations, periodically regenerate Mersenne&#039;s internal table of values using values generated from the above scheme.<br /><br />If you still want the source, I&#039;d be happy to dig it up.<br /></div>
    <div class="meta">Posted on 2012-01-16 11:36:06 by Homer</div>
   </div>
   <div class="post" id="post-215672">
    <div class="subject"><a href="#post-215672">Re: Fast and small Multiplicative Random number generator</a></div>
    <div class="body">In order to properly evaluate the efficacy of a RNG, I analyze the numerical distribution of the output values in N dimensions, which basically is asking the question: for the numerical bounded domain of N bits, what is the distribution like? Are there dense clusters or is it well distributed?<br />Park Miller is not very well distributed, and MTB has ribbon-like distribution properties, mixing them created a better distribution than either could accomplish alone,&nbsp; with very little execution overhead we get a better result in terms of numerical distribution across the numerical keyspace.</div>
    <div class="meta">Posted on 2012-01-16 11:37:49 by Homer</div>
   </div>
   <div class="post" id="post-215673">
    <div class="subject"><a href="#post-215673">Re: Fast and small Multiplicative Random number generator</a></div>
    <div class="body">Actually, I found it using the search on this site.<br />http://www.asmcommunity.net/board/index.php?topic=29222.msg206384#msg206384<br /><br />Have fun :)</div>
    <div class="meta">Posted on 2012-01-16 11:45:25 by Homer</div>
   </div>
  </div>
 </body>
</html>