<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>troubleshoot MPU? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=12962" />
  <link rel="prev" href="../?id=12962&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=32">Electronics</a> &raquo; <a href="../?id=12962">troubleshoot MPU?</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=12962&amp;page=1" style="">&laquo;</a><a href="../?id=12962&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="12962" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-104363">
    <div class="subject"><a href="#post-104363">troubleshoot MPU?</a></div>
    <div class="body"><div class="quote"><br />Hi, guys,<br /><br />I just want to make comment here on watchdogs, resets and battery backed-up RAM. I sense some confusion.<br /><br />A watchdog is actually a timer. When it overflows it resets the microprocessor (or microcontroller; in modern micros, it can also just generate an interrupt).<br />If the microprocessor operates correctly, then <u>under program control</u> it will periodically clear the timer, not allowing it to overflow and generate a reset. <br />If there is something wrong with the program, if the micro gets stuck (because it read some bad data, or... something weird happened ), it cannot clear the timer, the timer overflows and resets the microprocessor.  Kind of like your resetting the computer when it's &quot;frozen&quot;.<br /><br />A battery backed-up RAM is used to store data and retain it even when power is lost. To do that it needs a circuit that senses the power is about to be lost and switches over to a battery. That is a battery switchover circuit.<br /><br />A reset generator is a circuit which senses the supply voltage and as soon as it goes below a certain level, it resets the micro and it keeps it in reset until the voltage reaches normal operating value. That prevents the micro fom operating with a low supply voltage, which could cause malfunction. The reset circuit also includes some sort of delay or timing circuit, which ensures that once a reset is generated, it lasts long enough, typically 100~200msec. That ensures the micro gets a good reset, not just a thin spike, even if the supply voltage recovers very quickly. This delay is necessary for the micro's oscillator to start-up and stabilize before any instructions are executed.  This circuit inherently works at power-up. When you switch on the power, the voltage increases rather slowly, but the reset circuit keeps the processor in reset until the supply voltage reaches the correct value. It's really a comparator with hysteresis, followed by a timer.<br /><br />The confusion I think arises from the fact that some manufacturers packed the watchdog timer, the reset generator and the battery switchover circuit in a single package. (An example is Linear Technology's LTC694). This makes a lot of sense, because once the power is about to be lost, two things have to happen: reset the micro and back-up the RAM. So the sense circuit can be shared. Also, whether the reset is generated by the watchdog or by the undervoltage, it makes no difference, a 100~200ms signal has to be generated, so again some circuitry is shared, including the reset output pin.<br /><br />I hope my little dissertation here helps clear up some things. </div><br /><br />hey VVV, nice I learned a lot from ur desc but isnt a reset generator sort of like a Brown out Detector or Power On Reset circuit? (are they synonyms?). Also I read somewhere what hysteresis was can u give a simple explanation please? Thanks V^3 :tongue:</div>
    <div class="meta">Posted on 2003-05-22 17:52:40 by x86asm</div>
   </div>
   <div class="post" id="post-104555">
    <div class="subject"><a href="#post-104555">troubleshoot MPU?</a></div>
    <div class="body">Hi, x86asm,<br /><br />Yes, they are very similar. Many people use the terms interchangeably. But there are subtle differences, at least the way I understand them.<br /><br />A power-on reset can be constructed with just a few components and it will generate a reset pulse whenever power is applied, <u>whether the supply voltage has the correct value or not</u> . <br />It works as long as the supply voltage rises fast enough. It can use simple capacitors that charge up slowly when the supply voltage is applied.<br /><br />A brown-out detector actually <u>senses when the supply voltage drops below a certain level</u> . So it incorporates a reference and a comparator to detect an analog level and generates a reset signal. <br />However, this signal is only present as long as the supply voltage is below the threshold.<br />The term brown-out implies that the voltage decreases slowly, but does not necessarily disappear completely. (Think of a power outage: that is a blackout, but if power goes out slowly, your bulbs kind of go reddish, hence the name brown-out).<br /><br />Some circuits combine these features, so the distinction is no longer very clear.<br /><br />As for hysteresis, it is a phenomenon that occurs in many situations. Sometimes it is not desirable.<br />Loosely defined, it means the output behaves differently for an increasing input, than it does for a decreasing input.<br /><br />In the case of a Schmitt trigger invertor gate, for example, if the input voltage <u>increases</u>  slowly from 0 volts to 5 volts, the output is HIGH until the input voltage reaches a turn-on threshold (about 2V), at which point it switches to LOW.<br />If the input now decreases slowly from 5V to 0 volts, the output switches from HIGH back to LOW when the input voltage reaches the turn-off threshold (about 1V).<br />As you can see, the output behaves differently, depending on HOW the input changes. There is a &quot;gap&quot; of about 1V, where the output now keeps its previous state.<br />This can be used to advantage in many situations. Consider the input voltage has some noise on it, say 0.5V.<br />Without hysteresis, this would cause the output to be noisy, too. (The gate would switch back and forth when the input is around a threshold.)<br />With hysteresis, the output switches LOW when the input is high enough, but to make it switch back LOW you would need to decrease the voltage by 1 volt. Hence, your 0.5V of noise is not enough to do that, so the output is clean.  This is just one poor example, but virtually any comparator has a little bit of hysteresis, for exacly this reason: to keep the output &quot;clean&quot;.<br /><br />Hope this helps.</div>
    <div class="meta">Posted on 2003-05-23 20:02:48 by VVV</div>
   </div>
   <div class="post" id="post-104560">
    <div class="subject"><a href="#post-104560">hysteresis? I know this term but...</a></div>
    <div class="body">Are we talking the TPLH (Time to Propagate Low to High)? Schmitt triggers can me made into sweet simple square wave oscillators. I found that the higher the freq. only one resistor is needed from in to out of first gate and the out of first gate shorted to second gate with no resistor will follow but may need some capacitance to ground on second gate output to filter out the harmonics which may present themselves as sort of a damped wave. Many of your freq. multipliers are made from high speed switching diodes like shotkey barrier diode which generate alot of energy at the harmonic freq. By the way I was working on a methode of PLL that I beleive can equal DDS but my work didn't pay so I had to do something else. But Pll being so cheap and simple I think it deserves more effort. It is a software technique I devised but the only thing I haven't had a chance to test is the phase noise levels. This software technique will turn a 10KHz cheap motorola PLL chip into a high res. sythesizer with only one loop and no odd divisions.</div>
    <div class="meta">Posted on 2003-05-23 21:14:37 by mrgone</div>
   </div>
   <div class="post" id="post-104562">
    <div class="subject"><a href="#post-104562">troubleshoot MPU?</a></div>
    <div class="body">No, those are other parameters.<br /><br />I am attaching a picture which should help clear some things up.<br /><br />The first graph show a typical hysteresis characteristic of a non-inverting device. Note that it is a plot of output <u>vs. input, not time.</u> <br />Now notice the arrows. They show how the input is varied. When the input  <u>increases</u> and reaches the threshold to the right the output switches to HIGH. To make it switch back to LOW you have to <u>decrease</u>  the input further to the left (lower) than when the output went HIGH. The difference between the two thresholds is the hysteresis.<br /><br />The second plot shows the input to a device with hysteresis <u>vs. time</u>. Note the two thresholds. The difference is, of course, the hysteresis. The noise is smaller than the hysteresis.<br />The third plot shows how the output should change in theory, if there was no propagation delay. And finally you see the propagation delays in the fourth graph. These are very short delays, so the picture is not really to scale.<br /><br />Note that nothing happens at the output until the input reaches the upper threshold. Even if it crosses the lower one back and forth (first 2 dotted lines).<br />Once it crosses the upper threshold <u>while increasing</u> , the output switches to HIGH and it stays there, even if the input goes below the upper threshold and above it. (look at first graph to see why).<br />For the output to switch back to LOW, the input must now cross the lower threshold, <u>while decreasing</u>.<br />And once that happens, the only way the output could go HIGH again, would be to make the input cross the upper threshold, which is why nothing happens when it only crosses the lower one. <br /><br />Of course, the output will change in the opposite directions for an inverting circuit. <br /><br />I hope this helps.</div>
    <div class="meta">Posted on 2003-05-23 23:30:48 by VVV</div>
   </div>
   <div class="post" id="post-104563">
    <div class="subject"><a href="#post-104563">Wow!</a></div>
    <div class="body">Very sharp! You obviously are a real engineer. Do you do DSP? I have a pertainent question. Analogue processors are so so much faster than digital. What is the major draw back? Are they all learned programs? They have to be stripped of program everytime there is a mistake? Is it weight code programming or probably just incompatibility?</div>
    <div class="meta">Posted on 2003-05-24 00:07:16 by mrgone</div>
   </div>
   <div class="post" id="post-104597">
    <div class="subject"><a href="#post-104597">troubleshoot MPU?</a></div>
    <div class="body"><div class="quote"><br />No, those are other parameters.<br /><br />I am attaching a picture which should help clear some things up.<br /><br />The first graph show a typical hysteresis characteristic of a non-inverting device. Note that it is a plot of output <u>vs. input, not time.</u> <br />Now notice the arrows. They show how the input is varied. When the input  <u>increases</u> and reaches the threshold to the right the output switches to HIGH. To make it switch back to LOW you have to <u>decrease</u>  the input further to the left (lower) than when the output went HIGH. The difference between the two thresholds is the hysteresis.<br /><br />The second plot shows the input to a device with hysteresis <u>vs. time</u>. Note the two thresholds. The difference is, of course, the hysteresis. The noise is smaller than the hysteresis.<br />The third plot shows how the output should change in theory, if there was no propagation delay. And finally you see the propagation delays in the fourth graph. These are very short delays, so the picture is not really to scale.<br /><br />Note that nothing happens at the output until the input reaches the upper threshold. Even if it crosses the lower one back and forth (first 2 dotted lines).<br />Once it crosses the upper threshold <u>while increasing</u> , the output switches to HIGH and it stays there, even if the input goes below the upper threshold and above it. (look at first graph to see why).<br />For the output to switch back to LOW, the input must now cross the lower threshold, <u>while decreasing</u>.<br />And once that happens, the only way the output could go HIGH again, would be to make the input cross the upper threshold, which is why nothing happens when it only crosses the lower one. <br /><br />Of course, the output will change in the opposite directions for an inverting circuit. <br /><br />I hope this helps. </div><br /><br />Now I get it thanks VVV. :D</div>
    <div class="meta">Posted on 2003-05-24 11:05:02 by x86asm</div>
   </div>
   <div class="post" id="post-104874">
    <div class="subject"><a href="#post-104874">troubleshoot MPU?</a></div>
    <div class="body">Hi, mrgone,<br /><br />Thank you for your appreciation.<br />No, I do not do DSP's.<br />I am not sure what you mean by analogue processors.  I am assuming analog math blocks or filters, vs. DSP? In that case, you got the answers right yourself.<br /><br />Let me say that speed, while important, is not everything. The ease of use, stability, handling of data, the ability to easily store data, are also things to consider. That is where the true power of digital circuits lies. You also have to take into account tolerances. Analog circuits always assume &quot;perfect&quot; components. Since those are not available, you have to have provisions for adjustments. And that complicates things further.<br /><br />I will give you a couple of examples:<br />1.  Your portable CD player has a 10-40sec memory that allows it to play correctly even if it experiences a shock that would make it otherwise &quot;skip&quot;. Can you imagine storing 40sec. of analog info?<br />Secondly, the same CD player uses encoding that allows it to recover the original data even if the recorded data is corrupted, such as due to a scratched CD. Do you recall the old record players, and what happened when the record was damaged?<br />So the ability to store as well as recover data are key elements. Also, unlike analog signals, digital signals are relatively immune to noise. If the input signals to a gate are noisy, but still within limits, that will not affect the quality of the output signal. Moreover, the gate output signal is &quot;better&quot; than the input, the can restore the correct LOW and HIGH levels.<br /><br />2.  The second example I will give you can be turned into a little week-end project.<br />Consider you want to build an electronic thermometer, -25 to 70deg C, using a thermistor. As you probably know, the thermistor is a non-linear device, whose resistance varies with temperature, according to this equation Rth=Ro*e^(B*(1/T-1/To)), where Ro is the resistance at 25C, B is a constant, generally between 1000 and 4000, T is the absolute temperature and To is 25C on the absolute scale (298K). <br />Imagine the thermistor forms a divider with another resistor, powered from a reference voltage. To display the temperature, use a simple voltmeter with a 20V max scale reading. Assume your circuit has to produce 100mV/ deg C, linear output.<br />As you can see, the formula for the thermistor's resistance is relatively complicated, but the formula for the output voltage is even more complicated, since you have a divider: Vout=Vref*(Rth/(Rth+R)) and substitute Rth.<br />It would be very complicated to build a circuit that does the opposite in order to linearize the characteristic. So you approximate it by straight lines.<br />To make a <u>linear</u> scale out of this, you need a non-linear circuit, using opamps and diodes or transistors to shape its response and linearize the output, which is displayed on the voltmeter. I guess you would need about 4-5 break points to do that with reasonable accuracy over the entire scale. That means you calibrate the circuit at 4-5 points only, the rest will be approximated.<br />And to compensate for the inherent tolerances, all these gains and the zero have to be adjusted (both Ro and B have tolerances).<br />Now assume you got it working and want to make it display the temperature in deg F !  Another set of constants, pots, adjustments!<br /><br />And now imagine the same project using a microcontroller with its internal A/D, displaying the data on a digital display that the uC can drive.<br />All you have to do is use a jump table for each value you read from the A/D. The value you get in the table is displayed on the display. Done! (If you really want to, you can also use the correct formula and some math to go with it).<br />Want deg F? Load two tables in memory and with the flip of a switch, tell the uC you now want deg F displayed and &quot;presto&quot;! Want to see the history of how the temperature changed? Store the readings and display them upon request. Also, note that for an 8-bit A/D you will have up to 256 breakpoints, that is you calibrate your circuit at 256 points and nothing needs to be approximated now, every value is the correct one for the given resolution.<br /><br />For you week-end project:<br />If you don't have an A/D, consider using the thermistor as the timing resistor in a 555 timer, measure the frequency (or duration) with the uC, use a jump table and again you have accurate temperature measurements, if you calibrate it properly. And calibration only means entering the right data in the jump table.<br /><br />These examples may not be the greatest, but you can see that the great ability to handle and store the data in digital format without losing information really makes all the effort worthwile.<br /><br />Don't get me wrong, everything has its own use. If  I think in an application a simple R-C filter will do the job, I use it. You have to choose the right circuit for the job. Even in the second example I gave you, some analog circuitry could still be required, such as a voltage follower from the divider to the A/D input.</div>
    <div class="meta">Posted on 2003-05-26 12:06:31 by VVV</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=12962&amp;page=1" style="">&laquo;</a><a href="../?id=12962&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="12962" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>