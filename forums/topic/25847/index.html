<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Simple Window - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25847" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25847">Simple Window</a></p>
   <div class="post" id="post-188504">
    <div class="subject"><a href="#post-188504">Simple Window</a></div>
    <div class="body">Hey everyone,<br /><br />I am trying to do a simple window program in assembly. Essentially I am following the winprog.net tutorial (http://winprog.net/tutorial/simple_window.html) but writing assembly instead of C. I am also using the NASM32 package.<br /><br />Here is the code I have:<br /><br /><pre><code><br />%include &#39;\nasm32\inc\win32\windows.inc&#39;<br />%include &#39;\nasm32\inc\win32\kernel32.inc&#39;<br />%include &#39;\nasm32\inc\win32\user32.inc&#39;<br />%include &#39;\nasm32\inc\nasm32.inc&#39;<br /><br />segment .data<br />szClassName	db	&quot;window_class&quot;,0<br /><br />wc:<br />&nbsp; &nbsp; 	istruc WNDCLASSEX<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at WNDCLASSEX.cbSize,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dd&nbsp; &nbsp; WNDCLASSEX_size<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at WNDCLASSEX.style,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dd&nbsp; &nbsp; NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at WNDCLASSEX.lpfnWndProc,&nbsp; &nbsp;  dd&nbsp; &nbsp; NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at WNDCLASSEX.cbClsExtra,&nbsp; &nbsp; &nbsp; dd&nbsp; &nbsp; NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at WNDCLASSEX.cbWndExtra,&nbsp; &nbsp; &nbsp; dd&nbsp; &nbsp; NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at WNDCLASSEX.hInstance,&nbsp; &nbsp; &nbsp;  dd&nbsp; &nbsp; NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at WNDCLASSEX.hIcon,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dd&nbsp; &nbsp; NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at WNDCLASSEX.hCursor,&nbsp; &nbsp; &nbsp; &nbsp;  dd&nbsp; &nbsp; NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at WNDCLASSEX.hbrBackground,&nbsp;  dd&nbsp; &nbsp; COLOR_WINDOW+1<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at WNDCLASSEX.lpszMenuName,&nbsp; &nbsp; dd&nbsp; &nbsp; NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at WNDCLASSEX.lpszClassName,&nbsp;  dd&nbsp; &nbsp; NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at WNDCLASSEX.hIconSm,&nbsp; &nbsp; &nbsp; &nbsp;  dd&nbsp; &nbsp; NULL<br />&nbsp; &nbsp; 	iend<br /><br />message:<br />&nbsp; &nbsp; 	istruc MSG<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at MSG.hwnd,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dd&nbsp; &nbsp; NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at MSG.message,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dd&nbsp; &nbsp; NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at MSG.wParam,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dd&nbsp; &nbsp; NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at MSG.lParam,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dd&nbsp; &nbsp; NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at MSG.time,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dd&nbsp; &nbsp; NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; 	at MSG.pt,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dd&nbsp; &nbsp; NULL<br />&nbsp; &nbsp; 	iend<br /><br />regFailCaption	db	&quot;Registration Error!&quot;,0<br />regFailText	db	&quot;Registration of Window Class failed!&quot;,0<br /><br />createFailCap	db	&quot;Window Error!&quot;,0<br />createFailTxt	db	&quot;Creation of Window Failed!&quot;,0<br /><br />windowTitle	db	&quot;Window Title&quot;,0<br /><br /><br />segment .bss<br />hWnd		resd	1<br />hInstance	resd	1<br /><br />%define	GetModuleHandleA _GetModuleHandleA@4<br />%define	ExitProcess _ExitProcess@4<br />%define	LoadIconA _LoadIconA@8<br />%define LoadCursorA _LoadCursorA@8<br />%define RegisterClassExA _RegisterClassExA@4<br />%define CreateWindowExA _CreateWindowExA@48<br />%define ShowWindow _ShowWindow@8<br />%define UpdateWindow _UpdateWindow@4<br />%define GetMessageA _GetMessageA@16<br />%define TranslateMessage _TranslateMessage@4<br />%define DispatchMessageA _DispatchMessageA@4<br />%define MessageBoxA _MessageBoxA@16<br />%define DefWindowProcA _DefWindowProcA@16<br />%define DestroyWindow _DestroyWindow@4<br />%define PostQuitMessage _PostQuitMessage@4<br /><br />segment	.text<br />	extern	GetModuleHandleA<br />	extern	ExitProcess<br />	extern&nbsp; LoadIconA<br />	extern	LoadCursorA<br />	extern	RegisterClassExA<br />	extern	CreateWindowExA<br />	extern	ShowWindow<br />	extern	UpdateWindow<br />	extern&nbsp; GetMessageA<br />	extern	TranslateMessage<br />	extern&nbsp; DispatchMessageA<br />	extern&nbsp; MessageBoxA<br />	extern&nbsp; DefWindowProcA<br />	extern	DestroyWindow<br />	extern&nbsp; PostQuitMessage<br /><br />	global	WinMainCRTStartup<br />	<br /><br />WinMainCRTStartup:<br />	push	NULL<br />	call	GetModuleHandleA<br />	mov	, eax<br /><br />	push	SW_SHOWNORMAL<br />	push	NULL<br />	push	NULL<br />	push	dword <br />	call	WinMain<br /><br />	push	NULL<br />	call	ExitProcess<br /><br />	ret<br /><br /><br />%define hinst	<br />%define hpinst&nbsp; <br />%define cmdl	<br />%define	cmds	<br />WinMain:<br />	push	ebp<br />	mov	ebp, esp<br /><br />	mov	dword , WndProc<br /><br />	mov	eax, hinst<br />	mov	, eax<br /><br />	push	IDI_APPLICATION<br />	push	NULL<br />	call	LoadIconA<br />	<br />	mov	dword , eax<br />	mov	dword , eax<br /><br />	push	IDC_ARROW<br />	push	NULL<br />	call	LoadCursorA<br />	<br />	mov	dword , eax<br />	mov	dword , szClassName<br /><br />	push	wc<br />	call	RegisterClassExA<br />	cmp	eax, 0<br />	jz	near regfail<br /><br />	push	NULL<br />	push	dword <br />	push	NULL<br />	push	NULL<br />	push	120<br />	push	240<br />	push	CW_USEDEFAULT<br />	push	CW_USEDEFAULT<br />	push	WS_OVERLAPPEDWINDOW<br />	push	windowTitle<br />	push	szClassName<br />	push	WS_EX_CLIENTEDGE<br />	call	CreateWindowExA<br /><br />	cmp	eax, 0<br />	jz	near winfail<br />	<br />	mov	, eax<br /><br />	push	dword cmds<br />	push	dword <br />	call	ShowWindow<br /><br />	push	dword <br />	call	UpdateWindow<br /><br />msgLoop:<br />	push	0<br />	push	0<br />	push	NULL<br />	push	message<br />	call	GetMessageA<br /><br />	cmp	eax, 0<br />	jle	near end_WinMain<br /><br />	push	message<br />	call	TranslateMessage<br /><br />	push	message<br />	call	DispatchMessageA<br /><br />	jmp	msgLoop<br /><br />	jmp	end_WinMain<br /><br />regfail:<br />	mov	eax, MB_OK<br />	or	eax, MB_ICONEXCLAMATION<br /><br />	push	eax<br />	push	regFailCaption<br />	push	regFailText<br />	push	NULL<br />	call	MessageBoxA<br /><br />	jmp	end_WinMain<br /><br />winfail:<br />	mov	eax, MB_OK<br />	or	eax, MB_ICONEXCLAMATION<br />	<br />	push	eax<br />	push	createFailCap<br />	push	createFailTxt<br />	push	NULL<br />	call	MessageBoxA<br /><br />	jmp	end_WinMain<br /><br />end_WinMain:<br />	mov	dword eax, <br /><br />	mov	esp, ebp<br />	pop	ebp<br />	ret<br /><br />%define	hwnd	<br />%define	msg	<br />%define	wparam	<br />%define lparam	<br />WndProc:<br />	push	ebp<br />	mov	ebp, esp<br /><br />	cmp	dword msg, WM_CLOSE<br />	jz	wm_close<br />	cmp	dword msg, WM_DESTROY<br />	jz	wm_destroy<br /><br />	push	dword lparam<br />	push	dword wparam<br />	push	dword msg<br />	push	dword hwnd<br />	call	DefWindowProcA<br /><br />	ret<br /><br />wm_close:<br />	push	dword hwnd<br />	call	DestroyWindow<br />	jmp	end_WndProc<br /><br />wm_destroy:<br />	push	0<br />	call	PostQuitMessage<br /><br />end_WndProc:<br />	xor	eax, eax<br />	mov	esp, ebp<br />	pop	ebp<br />	ret<br /></code></pre><br /><br />Compile with:<br /><br /><pre><code><br />nasm -f win32 window.asm -o window.obj<br />link.exe /subsystem:windows /LIBPATH:\nasm\lib\win32 window.obj kernel32.lib user32.lib<br /></code></pre><br /><br />My problem is that the code does not work. Running it will give a &quot;window.exe has encountered an error and needs to close&quot; error message. If I run the program in OllyDBG I can see that CreateWindowExA is producing an exception. I don&#39;t see why this is happening or how I can fix it.<br /><br />Also, is there a way I can avoid having to do all those %define&#39;s and extern&#39;s WITHOUT USING invoke. I don&#39;t like invoke.<br /><br />Thanks in advance.</div>
    <div class="meta">Posted on 2007-03-19 23:38:55 by lithium</div>
   </div>
   <div class="post" id="post-188505">
    <div class="subject"><a href="#post-188505">Re: Simple Window</a></div>
    <div class="body"><div class="quote"><br />Compile with:<br /></div><br /><br />It&#39;s an *<strong>assembler</strong>*, not a &quot;compiler&quot; ;)<br /><br /><div class="quote"><br /><pre><code><br />nasm -f win32 window.asm -o window.obj<br />link.exe /subsystem:windows /LIBPATH:\nasm\lib\win32 window.obj kernel32.lib user32.lib<br /></code></pre><br /></div><br /><br />Well, I have the latest <a target="_blank" href="http://www.asmcommunity.net/projects/nasm32/"><u>NASM32</u></a> package, so I&#39;d be impressed if this would assemble at all.<br /><br /><div class="quote"><br />My problem is that the code does not work. Running it will give a &quot;window.exe has encountered an error and needs to close&quot; error message. If I run the program in OllyDBG I can see that CreateWindowExA is producing an exception. I don&#39;t see why this is happening or how I can fix it.<br /><br />Also, is there a way I can avoid having to do all those %define&#39;s and extern&#39;s WITHOUT USING invoke. I don&#39;t like invoke.<br /><br />Thanks in advance.<br /></div><br /><br />First, NASM32 expects an &quot;entry&quot; identifier pointing to a procedure, like so...<br /><br /><pre><code><br />entry WinMainCRTStartup<br /><br />proc WinMainCRTStartup<br />;code...<br />endproc<br /></code></pre><br /><br />NASM32 removes dependency on the linker to resolve the &quot;default entry symbol&quot; by creating a uniform method. &quot;entry XXX&quot; maps the target procedure as the global procedure &quot;main&quot; so that the linker knows which procedure is the entry-point every single time.<br /><br />I&#39;ve thought about overloading CALL a long time ago, but that would create too much confusion and incompatibility. Hence the use of the INVOKE macro, as it knows how to deal with all the include files. CALL is reserved for legacy use, that which requires thorough design by the user.<br /><br />Also, INVOKE knows what kind of CALL is being made between STDCALL and CDECL and automatically fills in the rest and cleans things up so the user doesn&#39;t have to.<br /><br />To summarize, you are not using NASM32 as it was intended to be used. It seems like you want to use strictly NASM, and in this respect, the NASM32 include files will not serve any purpose for you. I would suggest utilizing Google to find out how to do what you are trying to do, as that process has been documented enough times.<br /><br />However, if you do wish to use NASM32 as it was intended to be used, there are enough DEMO examples of how to create a basic Window application. See the README.TXT file in the &quot;nasm32\demos\win32\&quot; directory for more information.<br /><br />NOW, to add a little philosophy. I can almost guarantee that with enough time, lithium, that you will grow tired of writing endless API calls, line after line of PUSH with a final CALL. The beauty of INVOKE is that it eases the &quot;pain&quot; of the constant calling of *uniform* APIs without sacrificing efficiency. INVOKE also protects you from overlooking if you need to clean-up the stack or not. INVOKE is not only limited to API calls, however, is it knows how to traverse PROC/ENDPROC procedures.<br /><br />So, in either case, I hope you now have the information you need to move forward. Good luck :)</div>
    <div class="meta">Posted on 2007-03-20 00:19:46 by SpooK</div>
   </div>
   <div class="post" id="post-188506">
    <div class="subject"><a href="#post-188506">Re: Simple Window</a></div>
    <div class="body">Thanks for the reply SpooK.<br /><br />I realize that I am not using NASM32 (I also have the latest version) the way it was intended to be used. However, I did try to use it this way. I took a look at all the example code (DEMO2 is very similar to what I am trying to do) and I tried doing some code this way. The fact is, I didn&#39;t like it very much. It feels more more like a HLL than assembly code to me. What I like about coding in assembly is that I can write very many short statements that the processor executes. I know this probably sounds idiotic but using INVOKE just doesn&#39;t feel good for me. I am more bothered by the fact that I have a 120 character wide line for a long function call (such as a call to CreateWindowExA) than I am by having to &quot;push&quot; 12 times or that I may have to look up whether a function uses cdecl or stdcall. Again, I know that this probably sounds stupid but I&#39;m not saying that INVOKE is not &quot;real&quot; assembly, I&#39;m just saying that I don&#39;t like how this stuff looks.<br /><br />What I really want from NASM32 are the constants. I would really rather not have to look up what WM_CLOSE, MB_OK, etc... really are. The same goes for all the structures (such as WNDCLASSEX and MSG). Essentially, the stuff found in windows.inc is what I want. I would also like a giant file full of lines like &quot;%define _function@X function&quot; so that I could just call function instead of _function@X. And if there was a way to not have to write all of those externs, that would be wonderful. But that&#39;s all that I want. <br /><br />Having said all that, I don&#39;t think that is the problem. I compiled the code using NASM (not NASM32) and it still crashes after CreateWindowExA. Any ideas about this?<br /><br />Thanks again.<br /><br /></div>
    <div class="meta">Posted on 2007-03-20 01:30:51 by lithium</div>
   </div>
   <div class="post" id="post-188507">
    <div class="subject"><a href="#post-188507">Re: Simple Window</a></div>
    <div class="body"><div class="quote"><br />Thanks for the reply SpooK.<br /><br />I realize that I am not using NASM32 (I also have the latest version) the way it was intended to be used. However, I did try to use it this way. I took a look at all the example code (DEMO2 is very similar to what I am trying to do) and I tried doing some code this way. The fact is, I didn&#39;t like it very much. It feels more more like a HLL than assembly code to me.<br /></div><br /><br />Yes... and Windows is an OS with an API that is designed around an HLL. When in Rome...<br /><br /><div class="quote"><br />Having said all that, I don&#39;t think that is the problem. I compiled the code using NASM (not NASM32) and it still crashes after CreateWindowExA. Any ideas about this?<br /><br />Thanks again.<br /></div><br /><br />Yes, the same thing that INVOKE is supposed to help prevent... you are not cleaning up the stack after each STDCALL... so I wouldn&#39;t be surprised if your program is crashing from stack corruption.<br /><br />I will give you a fix for one of your calls, LoadIconA, that doesn&#39;t require POPs and can apply to the rest of your source.<br /><br /><pre><code><br />	push	IDI_APPLICATION<br />	push	NULL<br />	call	LoadIconA<br />	add	esp,8&nbsp; ;Compensate for two DWORD pushes onto the stack instead of 2 useless POPs<br /></code></pre><br /><br />For every DWORD push prior to a STDCALL, simply add 4 to ESP. Good luck ;)</div>
    <div class="meta">Posted on 2007-03-20 01:53:16 by SpooK</div>
   </div>
   <div class="post" id="post-188511">
    <div class="subject"><a href="#post-188511">Re: Simple Window</a></div>
    <div class="body">Here are your fixes:<br /><br />1. in WinMain and WndProc change ret to ret 16<br />2. after DefWindowProcA do not &quot;ret&quot;, but jump to end_WndProc after xor eax,eax.<br /><br />Have a look on other programmng style (nasm too):</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2308" target="_blank">SimpleWindow.zip</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-03-20 04:42:12 by sapero</div>
   </div>
   <div class="post" id="post-188522">
    <div class="subject"><a href="#post-188522">Re: Simple Window</a></div>
    <div class="body"><div class="quote"><br />I will give you a fix for one of your calls, LoadIconA, that doesn&#39;t require POPs and can apply to the rest of your source.<br /><br /><pre><code><br />	push	IDI_APPLICATION<br />	push	NULL<br />	call	LoadIconA<br />	add	esp,8&nbsp; ;Compensate for two DWORD pushes onto the stack instead of 2 useless POPs<br /></code></pre><br /><br />For every DWORD push prior to a STDCALL, simply add 4 to ESP. Good luck ;)<br /></div><br /><br />Umm....you&#39;re not supposed to do that with stdcall. With stdcall, the callee pops the arguments from the stack. I think you&#39;re thinking of cdecl. Or am I thoroughly confused here?<br /><br />Anyway, I did what sapero suggested and now it works. What doesn&#39;t make sense to me is why CreateWindowEx would fail if WinMain and WndProc return incorrectly. Both of those return AFTER CreateWindowEx is called.<br /><br />I&#39;ve attached my code. Anyway, I PERSONALLY think that my code is much cleaner than, for example, DEMO2. I realize that most people probably disagree and that my method has an obvious disadvantage of not using INVOKE but if I were to write DEMO2 like it is provided in NASM32, I would feel better just doing it in C. And my whole purpose in doing this was to try Win32 with assembly. Again, I&#39;m not saying you&#39;re wrong, SpooK. In fact, you&#39;re almost certainly right. I&#39;m just saying that if I were programming something in assembly, I would like how my code looks a lot more (lack of comments aside...)<br /><br />Thanks again for all the help everyone.</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2309" target="_blank">window.asm</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2007-03-20 15:20:43 by lithium</div>
   </div>
   <div class="post" id="post-188524">
    <div class="subject"><a href="#post-188524">Re: Simple Window</a></div>
    <div class="body"><div class="quote"><br />Umm....you&#39;re not supposed to do that with stdcall. With stdcall, the callee pops the arguments from the stack. I think you&#39;re thinking of cdecl. Or am I thoroughly confused here?<br /></div><br /><br />Yeah... sorry... you&#39;re correct... otherwise C vararg wouldn&#39;t work :shock:<br /><br />No more posts when I&#39;m tired :|<br /><br />Anyhow, you are taking the right route if you really want to learn how things work &quot;behind the scenes&quot; ;)</div>
    <div class="meta">Posted on 2007-03-20 15:53:37 by SpooK</div>
   </div>
   <div class="post" id="post-188527">
    <div class="subject"><a href="#post-188527">Re: Simple Window</a></div>
    <div class="body">Btw, In regards to this post. If you wanted to use &#39;CALL&#39; with the procedure includes you could subclass the&nbsp; CALL opcode with a macro like we did with leave and ret.<br /><br /><pre><code>%imacro CALL 1<br />%push invoke<br /><br />%ifdef __stdcall_defined_%1<br />	%define %1 __stdcall_defined_%1<br />	extern __stdcall_defined_%1<br />%endif<br /><br />%ifdef __cdecl_defined_%1<br />	declare_cdecl %1<br />	%define %1 __cdecl_defined_%1<br />	extern __cdecl_defined_%1<br />	declare_cdecl %1<br />%endif<br /><br />%ifdef _UNDERSCORE_<br />	%define _proc _%1<br />%else<br />	%define _proc %1<br />%endif<br /><br />	call	_proc<br />%pop<br />%endmacro</code></pre><br /><br />This would allow you to use CALL just like you normally would, except you can use the Kernel32.inc, User32.inc, etc from the Nasm32 project without having to define the procedures yourself. I personally use the &quot;low level&quot; syntax myself, but I exclusively use Nasm32 when working with the Netwide Assembler (although I am a bit partial). The downside to doing this is that you have to cleanup the stack yourself, I don&#39;t mind and I&#39;m sure you don&#39;t either. Another thing I commonly do to save some typing is to create type shortcuts:<br /><br /><pre><code>%define T tword<br />%define Q qword<br />%define D dword<br />%define W word<br />%define B byte</code></pre><br /><br />Using these two will allow you to cut down your code, with use of the NASM32 project, to look more like:<br /><br /><pre><code>push D MB_YESNO<br />push D szTitle<br />push D szMessage<br />push D NULL<br />call MessageBoxA<br />mov B , al</code></pre><br /><br />Just these few macros added to the NASM32 project can save your fingers a whole lot, while still allowing you to work in the low level style you are comfortable with. Sorry that I didn&#39;t get to this topic sooner, I&#39;ve been a little busy lately on other things. I hope this has been of some help to ya.<br /><br />Regards,<br />Bryant Keller<br /><br /></div>
    <div class="meta">Posted on 2007-03-20 19:14:03 by Synfire</div>
   </div>
   <div class="post" id="post-188529">
    <div class="subject"><a href="#post-188529">Re: Simple Window</a></div>
    <div class="body">I was saving this for the next release... but...<br /><br /><div class="quote"><br />Btw, In regards to this post. If you wanted to use &#39;CALL&#39; with the procedure includes you could subclass the&nbsp; CALL opcode with a macro like we did with leave and ret.<br /><br /><pre><code>%imacro CALL 1<br />%push invoke<br /><br />%ifdef __stdcall_defined_%1<br />	%define %1 __stdcall_defined_%1<br />	extern __stdcall_defined_%1<br />%endif<br /><br />%ifdef __cdecl_defined_%1<br />	declare_cdecl %1<br />	%define %1 __cdecl_defined_%1<br />	extern __cdecl_defined_%1<br />	declare_cdecl %1<br />%endif<br /><br />%ifdef _UNDERSCORE_<br />	%define _proc _%1<br />%else<br />	%define _proc %1<br />%endif<br /><br />	call	_proc<br />%pop<br />%endmacro</code></pre><br /><br />This would allow you to use CALL just like you normally would, except you can use the Kernel32.inc, User32.inc, etc from the Nasm32 project without having to define the procedures yourself. I personally use the &quot;low level&quot; syntax myself, but I exclusively use Nasm32 when working with the Netwide Assembler (although I am a bit partial). The downside to doing this is that you have to cleanup the stack yourself, I don&#39;t mind and I&#39;m sure you don&#39;t either. Another thing I commonly do to save some typing is to create type shortcuts:<br /></div><br /><br />The latest version of NASM32 will be the last version available with a NASM32.INC file such as described above. I&#39;ve changed the entire process and explicit defines for external function imports have been removed. Instead, the NASM32.INC file appropriately parses the include files with an overloaded EXPORT macro.<br /><br /><pre><code><br />;STDCALL<br />EXPORT CreateDirectoryExA, 12 ; _CreateDirectoryExA@12<br /><br />;CDECL<br />EXPORT printf ; _printf<br /></code></pre><br /><br />The previously established use of INVOKE will not be affected by this change.<br /><br />Also, based upon an earlier idea that has been recently re-suggested, I will decorate default API calls. For example, <em>CreateDirectoryEx</em> would resolve as <em>CreateDirectoryEx<strong>A</strong></em> OR <em>CreateDirectoryEx<strong>W</strong></em> depending on user selection of an ASCII/Wide(Unicode) switch. The switch (a simple %define) will need to be one or the other, otherwise NASM32 defaults strictly to what each EXPORT defines.<br /><br />However, I am currently busy with NASM itself, as I am doing some heavy rework to support x64 output. So I will release more information when it is available (i.e. I work on it again.) ;)</div>
    <div class="meta">Posted on 2007-03-20 21:56:47 by SpooK</div>
   </div>
   <div class="post" id="post-188530">
    <div class="subject"><a href="#post-188530">Re: Simple Window</a></div>
    <div class="body">Bryant,<br /><br />That is perfect. Exactly what I was looking for. Thank you.</div>
    <div class="meta">Posted on 2007-03-20 22:14:16 by lithium</div>
   </div>
   <div class="post" id="post-188534">
    <div class="subject"><a href="#post-188534">Re: Simple Window</a></div>
    <div class="body"><div class="quote">I was saving this for the next release... but...<br /><br /><div class="quote">...redundant quote...</div><br /><br />The latest version of NASM32 will be the last version available with a NASM32.INC file such as described above. I&#39;ve changed the entire process and explicit defines for external function imports have been removed. Instead, the NASM32.INC file appropriately parses the include files with an overloaded EXPORT macro.<br /><br /><pre><code><br />;STDCALL<br />EXPORT CreateDirectoryExA, 12 ; _CreateDirectoryExA@12<br /><br />;CDECL<br />EXPORT printf ; _printf<br /></code></pre></div><br /><br />This merely for within the scope of the procedure includes, correct. I&#39;ve not tested this at all, but theoretically I&#39;m not sure if this would work. EXPORT is a p-op, those are parsed before macros, unless nested within one, in NASM so they can&#39;t be overloaded. I&#39;m not 100% sure on this, I might be wrong as I don&#39;t have a copy of NASM here to test it and I&#39;m just kinda passing through. But iirc when I tried to overload %include to support variables in the path name such as $windir$ and $progfiles$ I kept getting shot down by precedence. It&#39;ll be something to keep an eye out for.<br /><br /><div class="quote">The previously established use of INVOKE will not be affected by this change.</div><br /><br />True, but it would make the procedural include files much cleaner to look at. Btw, you might want to give Vortex a yell when you implement this, he will probably want to update his <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=24983.0">Nasm32 scanner tool thing</a>.<br /><br /><div class="quote">Also, based upon an earlier idea that has been recently re-suggested, I will decorate default API calls. For example, <em>CreateDirectoryEx</em> would resolve as <em>CreateDirectoryEx<strong>A</strong></em> OR <em>CreateDirectoryEx<strong>W</strong></em> depending on user selection of an ASCII/Wide(Unicode) switch. The switch (a simple %define) will need to be one or the other, otherwise NASM32 defaults strictly to what each EXPORT defines.<br /><br />However, I am currently busy with NASM itself, as I am doing some heavy rework to support x64 output. So I will release more information when it is available (i.e. I work on it again.) ;)<br /></div><br /><br />Honestly, with the latest 03/08/2007 update of NASM32, there is no real need to stress it right now. I would much rather see a new version of NASM released. But then again that&#39;s just my opinion. :p<br /><br /><div class="quote"><br />Bryant,<br /><br />That is perfect. Exactly what I was looking for. Thank you.<br /></div><br /><br />No worries mate. Just glad I could help.<br /></div>
    <div class="meta">Posted on 2007-03-21 18:47:40 by Synfire</div>
   </div>
   <div class="post" id="post-188535">
    <div class="subject"><a href="#post-188535">Re: Simple Window</a></div>
    <div class="body"><div class="quote"><br />This merely for within the scope of the procedure includes, correct. I&#39;ve not tested this at all, but theoretically I&#39;m not sure if this would work. EXPORT is a p-op...<br /></div><br /><br />I suppose there are other options...<br /><br />API_CALL<br />API_EXPORT<br />LIB_EXPORT<br />etc...<br /><br />Let me know what you think ;)</div>
    <div class="meta">Posted on 2007-03-21 19:55:10 by SpooK</div>
   </div>
  </div>
 </body>
</html>