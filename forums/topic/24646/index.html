<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>asm and different assemblers? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=24646" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=24646">asm and different assemblers?</a></p>
   <div class="post" id="post-180073">
    <div class="subject"><a href="#post-180073">asm and different assemblers?</a></div>
    <div class="body">hello :), <br />i am interested in learning asm; i&#39;ve realised that there are many assemblers out there such as masm, nasm, etc. i am wondering, would i have to learn a different style of coding for each assembler, because the sources that compile with each assembler seem to be different from each other.&nbsp; As well, how would i be able to tell each source apart from which assembler they use?</div>
    <div class="meta">Posted on 2006-04-22 18:43:45 by Macleon</div>
   </div>
   <div class="post" id="post-180077">
    <div class="subject"><a href="#post-180077">Re: asm and different assemblers?</a></div>
    <div class="body">Well, the instruction set remains the same no matter what assembler you use. However the availability of high level constructs, support for libraries, obj modules, structures, and the like will change. Many assemblers with &quot;weak&quot; symbol table algorithms require that you prefix operators such as constants (ie %WM_USER) while those with stronger symbol table algorithms can handle them without prefix. The best supported and fastest assembler today is probably either MASM or FASM, they are both exceedingly powerful and already support whatever you find you might need in the future. MASM easily has the most advanced macro system and the largest user base, probably multiples larger than all the others combined. For myself I prefer the lower level assemblers, particularly GoAsm which meets my needs quite nicely, library support, symbolic debugger, separate linker and 32/64 bit ready, not to mention it&#39;s free.<br /><br />Another road to take is RosAsm which is a powerful assembler in it&#39;s own right and a completely integrated package. One of the major draw backs for me is that it is not possible to swap out a module that you are not satisfied with such as the editor, you are in all or nothing no substitutions. Also it does not have library support (last I heard) but has some very powerful tools that are supposed to adequately replace this deficiency. RosAsm has some very talented people who support it and though there is not a plethora of example code the list is growing daily. Lastly it is GPL, which may or may not be something you support, I will not comment on that.<br /><br />For syntax, FASM is pretty much on it&#39;s own as is RosAsm, MASM and GoAsm are very close. Stay away from AT&amp;T syntax, most of the GNU stuff uses that, it is difficult to decypher Intel manuals when you have to transpose half the things you read. You will quickly learn to jump from one to the other Intel syntax assemblers or at least translate between them.<br /><br />Donkey</div>
    <div class="meta">Posted on 2006-04-22 20:03:54 by donkey</div>
   </div>
   <div class="post" id="post-180106">
    <div class="subject"><a href="#post-180106">Re: asm and different assemblers?</a></div>
    <div class="body">oh ic that&#39;s interesting; if i were to use masm and come upon a source in tasm would it be challenging to change the format to masm because of the different libraries and libs? I am wondering how can i tell each source apart from which assembler they use?</div>
    <div class="meta">Posted on 2006-04-23 20:21:05 by Macleon</div>
   </div>
   <div class="post" id="post-180109">
    <div class="subject"><a href="#post-180109">Re: asm and different assemblers?</a></div>
    <div class="body">GoAsm...<br /><br /><pre><code>DlgProc FRAME hwnd,uMsg,wParam,lParam<br /><br />	MOV EAX,<br />	.WMINITDIALOG<br />		CMP EAX,WM_INITDIALOG<br />		JNE &gt;.WMGETDLGCODE<br />		invoke GetDlgItem,,1001<br />		invoke SetWindowLong,eax,GWL_WNDPROC,offset BtnSubClass<br />		mov ,eax<br />		JMP &gt;.EXIT<br /><br />	.WMGETDLGCODE<br />		CMP EAX,WM_GETDLGCODE<br />		JNE &gt;.WMCOMMAND<br />		mov eax,DLGC_BUTTON<br />		JMP &gt;.EXIT<br /></code></pre><br /><br />MASM<br /><br /><pre><code>DlgProc proc hWin:HWND,uMsg:UINT,wParam:WPARAM,lParam:LPARAM<br />	mov eax,uMsg<br />	.if eax==WM_COMMAND<br />		mov		eax,wParam<br />		mov		edx,eax<br />		and		eax,0FFFFh<br />		shr		edx,16<br />		.if edx==BN_CLICKED<br />			.if eax==IDCANCEL<br />				invoke SendMessage,hWin,WM_CLOSE,0,0<br />			.elseif eax==IDOK<br />				invoke SendMessage,hWin,WM_CLOSE,0,0<br />			.endif<br />		.endif</code></pre><br /><br />TASM<br /><br /><pre><code>PUBLIC DlgProcedure<br />DlgProcedure PROC STDCALL,hwnd_:DWORD,wmsg:DWORD,wparam_:DWORD,lparam_:DWORD<br />	USES ebx, edi, esi<br /><br />	cmp	&nbsp; &nbsp; wmsg, WM_DESTROY<br />	je	&nbsp; &nbsp; wmdestroy<br />	cmp	&nbsp; &nbsp; wmsg, WM_CLOSE<br />	je	&nbsp; &nbsp; wmdestroy<br />	cmp	&nbsp; &nbsp; wmsg, WM_COMMAND	<br />	je	&nbsp; &nbsp; wmcommand<br />	cmp	&nbsp; &nbsp; wmsg, WM_INITDIALOG	<br />	je	&nbsp; &nbsp; dlginit<br />	xor	&nbsp; &nbsp; eax, eax<br />	RET<br />	<br />wmdestroy:<br />	call	EndDialog, hwnd_, 0<br />	call	ExitProcess,0</code></pre><br /><br />FASM<br /><br /><pre><code>proc DialogProc,hwnddlg,msg,wparam,lparam<br />	enter<br />	push	ebx esi edi<br />	cmp	,WM_INITDIALOG<br />	je	wminitdialog<br />	cmp	,WM_COMMAND<br />	je	wmcommand<br />	cmp	,WM_CLOSE<br />	je	wmclose<br />	xor	eax,eax<br />	jmp	finish<br />&nbsp; wminitdialog:<br />	jmp	processed</code></pre><br /><br />NASM<br /><br /><pre><code>@Dialog1Proc:&nbsp;  ;change to your name to this Dialog... or keep if you like the name.. :)<br /><br />%define hdlg1		ebp+8	;hwnd ... like this name better :)<br />%define dlg1msg		ebp+12	;wmsg ... like this name better :)<br />%define wparam		ebp+16<br />%define lparam		ebp+20<br /><br />	enter	0,0<br />	cmp		dword ,WM_INITDIALOG<br />	je		wminitdialog<br />	cmp		dword ,WM_COMMAND<br />	je		near wmcommand<br />	;cmp	dword ,WM_PAINT<br />	;je		near Paint<br />	cmp		dword ,WM_CLOSE<br />	je		near wmclose<br />	jmp		unhandled</code></pre></div>
    <div class="meta">Posted on 2006-04-23 21:00:36 by donkey</div>
   </div>
   <div class="post" id="post-180116">
    <div class="subject"><a href="#post-180116">Re: asm and different assemblers?</a></div>
    <div class="body">Just to make things fair here is a sample from NASM32. Note that the ButtonCtl macro is not a part of the Windows API rather one of the many CreateWindowEx wrappers I&#39;ve put together into STDWIN.INC.<br /><br /><pre><code><br />proc DlgProc, hwnd, umsg, wparam, lparam<br /><br />	switch dword argv(umsg)<br />	case dword WM_CREATE<br />		; ButtonCtl is a part of STDWIN.INC<br />		ButtonCtl szString, 500, 0, 0, 100, 40, argv(hwnd), <br /><br />	case dword WM_COMMAND<br />		if argv(wparam), EQUALS, dword 500<br />			invoke	MessageBoxA, dword NULL, dword szContent, dword szTitle, dword MB_OK<br />		else<br />			break<br />		endif<br /><br />	case dword WM_DESTROY<br />		invoke	PostQuitMessage, dword NULL<br /><br />	default<br />		invoke	DefWindowProcA, dword argv(hwnd), dword argv(umsg), dword argv(wparam), dword argv(lparam)<br /><br />	endswitch<br />	ret<br /><br />endproc<br /></code></pre></div>
    <div class="meta">Posted on 2006-04-23 23:45:01 by Synfire</div>
   </div>
   <div class="post" id="post-180117">
    <div class="subject"><a href="#post-180117">Re: asm and different assemblers?</a></div>
    <div class="body">Sorry Synfire,<br /><br />I have never used or installed NASM, the only example code I have is the small app that comes with RadASM.</div>
    <div class="meta">Posted on 2006-04-24 00:33:30 by donkey</div>
   </div>
   <div class="post" id="post-180122">
    <div class="subject"><a href="#post-180122">Re: asm and different assemblers?</a></div>
    <div class="body">donkey,<br />Yea, I understand. Truthfully, although I&#39;ve designed the NASM32 macro&#39;s to extend HL features to look like the code in the previous post, I generally don&#39;t use such constructs very often.. my code usually looks more like:<br /><br /><pre><code><br />PROC DlgProc<br />hwnd	ARGD<br />umsg	ARGD<br />wparam	ARGD<br />lparam	ARGD<br />	mov EAX, dword argv(umsg)<br />	cmp EAX, WM_CREATE<br />	jz .wm_create<br />	cmp EAX, WM_COMMAND<br />	jz .wm_command<br />	cmp EAX, WM_DESTROY<br />	jz .wm_destroy<br /><br />.default:<br />	push dword argv(lparam)<br />	push dword argv(wparam)<br />	push dword argv(umsg)<br />	push dword argv(hwnd)<br />	INVOKE DefWindowProcA<br />...<br /></code></pre><br /><br />I use PROC/ENDPROC so that I can use the argument features ARGD/ARGV. ARGD allows an optional argument which specifies byte, word, or dword (defaults to dword) unlike the style I showed below which forces all to dword. The INVOKE macro is a fairly complex one as it adds import entries for the procedure to the associated DLL when it&#39;s first called, so you don&#39;t have to have any .LIB files and you just need to include the required .INC files used.<br /><br />Macleon,<br />Truth is, once you learn the instruction set, moving between assemblers is rather easy. The biggest difference is the preprocessors capabilities, and more often than not you can take what you know from one assembler and switch between assemblers within about a day or two of playing around with the preprocessor. I&#39;ve personally used NASM for years, then a friend talked me into giving MASM a try. It took about 4 hours before I was comfortable with MASM&#39;s preprocessor and I really find it better for newcommers. NASM gets a bad wrap due to the complexity of it&#39;s preprocessor and that it&#39;s a weaker assembler in that it doesn&#39;t make any assumptions about sizes of arguments and makes you specify a lot of things yourself. Bottom line is, if you come up with your own way of using assembly that works with one assembler, you can be pretty sure that with a few small modifications that you will be able to port it to another. Only exception to that, is the difference between AT&amp;T syntax and the &quot;Intel&quot; syntax that MASM, NASM, FASM, etc uses.. I quoted Intel because there really isn&#39;t an official Intel syntax and a few people on this board get touchy about that ;) But Assemblers like GAS, AS, and others which use the AT&amp;T synax have a very different style and usually porting assembly code from one of those to something like MASM, NASM, etc usually calls for a complete rewrite. But as for MASM, NASM, FASM, GoASM, and others, there really isn&#39;t that big of a difference between them. Each have their ups and downs but they all more or less follow the same structure.<br /><br />Regards,<br />Bryant Keller</div>
    <div class="meta">Posted on 2006-04-24 03:46:15 by Synfire</div>
   </div>
   <div class="post" id="post-180124">
    <div class="subject"><a href="#post-180124">Re: asm and different assemblers?</a></div>
    <div class="body">Fortunately GAS supports .intel_syntax now, so even using that dinosaur should be relatively painless :)<br /><br />Btw, FASM remembers the type/size of variables - so the following code snippet works without any overrides. BIG advantage over NASM, imo... <br /><br /><pre><code><br />variable dd 10<br />mov , 100<br /></code></pre><br /><br />also, <strong>mov , al</strong> will fail unless you use a &quot;byte&quot; override. Again, IMHO this is an advantage... you limit size overrides to where they&#39;re necessary (or give some safety), and remove the need to litter them all over.<br /><br />That&#39;s just my personal opinion, of course.<br /></div>
    <div class="meta">Posted on 2006-04-24 04:05:19 by f0dder</div>
   </div>
   <div class="post" id="post-180137">
    <div class="subject"><a href="#post-180137">Re: asm and different assemblers?</a></div>
    <div class="body">f0dder,<br /><br />I&#39;m very suprised about GAS supporting .intel_syntax, mostly because the primary response from the developers when asking for features always something around the lines of, it&#39;s just for a compiler. I used GAS a long time ago while NASM was unavailable to me, so this is really amazing news to me :)<br /><br /><strong>EDIT:</strong><br />As for the &quot;type casting&quot; I agree, it is at times a pain in the rear (and more or less uncalled for), but once your used to it, there really isn&#39;t much of a problem. I actually thought of overriding mnemonics a for NASM32 but then figured it would be a lot of un-needed code. I feel if I was going to do that much work to change the language I would just start working on my own assembler (which I haven&#39;t completely thrown that idea out the window ;) )</div>
    <div class="meta">Posted on 2006-04-24 20:23:46 by Synfire</div>
   </div>
  </div>
 </body>
</html>