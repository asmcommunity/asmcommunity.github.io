<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Need help optimizing a binary search in inline ASM - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=11196" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=11196">Need help optimizing a binary search in inline ASM</a></p>
   <div class="post" id="post-84423">
    <div class="subject"><a href="#post-84423">Need help optimizing a binary search in inline ASM</a></div>
    <div class="body">Sorry if this isn't the right board for inline asm in C++ =) If there isn't a right board, then oh shucks =/<br /><br />Anyway, I'm a pretty newbie assembly coder and I was trying to write a binary search in assembly. I don't know any groovy tricks for optimizing code. Anyway, here's one version of the function:<br /><br /><pre><code><br />int binary_search_asm <br />	&#40;int *Array, unsigned int first, unsigned int last, int key&#41;<br />&#123;<br />	int retval;<br />	__asm<br />	&#123;<br />	mov edx, first		; edx == first<br />	mov ebx, last		; ebx == last<br /><br />BeginL&#58;<br />	cmp edx, ebx		; cmp edx and ebx<br />	ja EndBad<br /><br />	mov eax, edx		; eax == first<br />	add eax, ebx		; eax == first + last<br />	shr eax, 1			; eax == &#40;first + last&#41; &gt;&gt; 1<br /><br />	mov esi, &#91;Array + eax * 4&#93;; esi == sortedArray&#91;mid&#93;<br />	cmp key, esi					; cmp key and esi<br /><br />	je Equal						; _if &#40;key == edx&#41; jmpto Equal<br />	jl LessThan						; _if &#40;key &lt; edx&#41; jmpto LessThan<br /><br />	mov edx, eax					; first = mid<br />	inc edx							; first = mid + 1<br />	jmp BeginL						; loop<br /><br />LessThan&#58;<br />	mov ebx, eax					; last = mid<br />	dec ebx							; last = mid - 1<br />	jmp BeginL						; loop<br /><br />EndBad&#58;<br />	mov retval, -1					; value not found<br />	jmp EndL<br /><br />Equal&#58;<br />	mov retval, eax					; value found, retval = eax, end<br /><br />EndL&#58;<br />	&#125;<br /><br />	return retval;<br />&#125;<br /></code></pre><br /><br />This is quicker on my comp than the C++ version<br /><br /><pre><code><br />int binary_search_ &#40;int *Array, int first, int last, int key&#41; <br />&#123;<br />	while &#40;first &lt;= last&#41; <br />	&#123;<br />		int mid = &#40;first + last&#41; &gt;&gt; 1;<br />		if &#40;key &gt; Array&#91;mid&#93;&#41;<br />			first = ++mid;<br />		else if &#40;key &lt; Array&#91;mid&#93;&#41;<br />			last = --mid;<br />		else<br />			return mid; <br />	&#125;<br /><br />	return -1;<br />&#125;<br /></code></pre><br /><br />There's a specific thing I want to do to the inline asm version, and that is make it naked so I don't have to use the retval integer. I changed it to the following:<br /><br /><pre><code><br />__declspec &#40;naked&#41; int binary_search_asm <br />	&#40;int *Array, unsigned int first, unsigned int last, int key&#41;<br />&#123;<br />	__asm<br />	&#123;<br />	mov edx, first		; edx == first<br />	mov ebx, last		; ebx == last<br /><br />BeginL&#58;<br />	cmp edx, ebx		; cmp edx and ebx<br />	ja EndBad<br /><br />	mov eax, edx		; eax == first<br />	add eax, ebx		; eax == first + last<br />	shr eax, 1			; eax == &#40;first + last&#41; &gt;&gt; 1<br /><br />	mov esi, &#91;Array + eax * 4&#93;; esi == sortedArray&#91;mid&#93;<br />	cmp key, esi					; cmp key and esi<br /><br />	je Equal						; _if &#40;key == edx&#41; jmpto Equal<br />	jl LessThan						; _if &#40;key &lt; edx&#41; jmpto LessThan<br /><br />	mov edx, eax					; first = mid<br />	inc edx							; first = mid + 1<br />	jmp BeginL						; loop<br /><br />LessThan&#58;<br />	mov ebx, eax					; last = mid<br />	dec ebx							; last = mid - 1<br />	jmp BeginL						; loop<br /><br />EndBad&#58;<br />	mov eax, -1<br />	<br />Equal&#58;<br />	ret<br />	&#125;<br />&#125;<br /></code></pre><br /><br />adding the __declspec (naked) and removing the retval ordeal. I'm assuming that ret returns the contents of eax. <br /><br />The problem is that the first version works fine, but the __declspec (naked) version always seems to return -1, even though it shouldn't... I'm probably missing something. Can someone help me? Is there a different way to do this?<br /><br />Also, if anyone can tell me any optimizations I could make, please tell me. I want to get this code as fast as can be, while still writing it myself, so I can learn.<br /><br />Thanks! (and once again, sorry if it's in the wrong place)</div>
    <div class="meta">Posted on 2003-03-02 01:16:09 by rmullen3</div>
   </div>
   <div class="post" id="post-84424">
    <div class="subject"><a href="#post-84424">Re: Need help optimizing a binary search in inline ASM</a></div>
    <div class="body"><div class="quote"><br />The problem is that the first version works fine, but the __declspec (naked) version always seems to return -1, even though it shouldn't... I'm probably missing something. Can someone help me? Is there a different way to do this?</div>If you look in a debugger, maybe you will see that the params passed on the stack are not being moved into the registers correctly - due to no stack frame being set-up.  Then again, maybe I am wrong - compilers do so many things different than what I expect.<br /><br />This isn't the fastest, but it might give you some ideas:<pre><code>; divide and conquer approach to finding&#58;<br />	mov	esi, first<br />	mov	edi, last<br />	mov	edx, Array<br />	mov	eax, key<br />	jmp	_2<br /><br />_0&#58;	dec	edi<br />_1&#58;	inc	esi<br />_2&#58;	cmp	esi, edi<br />	lea	ecx, &#91;esi + edi&#93;<br />	jge	notfound<br />	shr	ecx, 1			; &#40;a+b&#41;/2<br />	cmp	&#91;edx + ecx*4&#93;, eax<br />	xchg	ecx, esi		; top half<br />	jc	_1<br />	lea	ecx, &#91;ecx - 1&#93;<br />	mov	edi, esi		; bottom half<br />	mov	esi, ecx<br />	jne	_0<br />found&#58;<br />	mov	eax, edi		; key number of found<br />	jmp	EndL<br />notfound&#58;<br />	cmp	eax, &#91;edx + esi*4&#93;<br />	mov	eax, -1<br />	jne	EndL<br />	mov	eax, esi		; key number of found<br />EndL&#58;</code></pre>(hope I didn't break it with all my edits from the original)<br />Notice there are only 2 or 3 branches per loop.<br /><br />Is this code really a bottleneck in your application?</div>
    <div class="meta">Posted on 2003-03-02 01:45:53 by bitRAKE</div>
   </div>
   <div class="post" id="post-84518">
    <div class="subject"><a href="#post-84518">~</a></div>
    <div class="body">I really like your example. Unforunatly, it was slower than my orig. code. But I think the way you did it could possibly be a lot faster than mine, cutting down on branches.<br /><br />I liked this line the most:<br /><pre><code><br />lea ecx, &#91;esi + edi&#93;<br /></code></pre><br /><br />I didn't think to use load eff. address, that was a little boost in speed. <br /><br />Also, looking through the Quake 1 source I found out what I was doing wrong. I needed to get things from the stack differently. Here's my new (much much faster) code:<br /><br /><pre><code><br />__inline __declspec &#40;naked&#41; int binary_search_asm <br />	&#40;unsigned int first, unsigned int last, int key, int *Array&#41;<br />&#123;<br />	__asm &#123;<br />		mov ecx, dword ptr &#91;esp + 4&#93;	; ecx = first<br />		mov ebx, dword ptr &#91;esp + 8&#93;	; ebx = last<br />		mov edi, dword ptr &#91;esp + 12&#93;	; edi = key<br />		mov edx, dword ptr &#91;esp + 16&#93;	; edx = Array<br />BeginL&#58;<br />		cmp ecx, ebx		; cmp ecx and ebx<br />		ja EndBad<br /><br />		lea eax, &#91;ecx + ebx&#93;<br />		shr eax, 1			; eax == &#40;first + last&#41; &gt;&gt; 1<br /><br />		cmp edi, &#91;edx + eax * 4&#93;<br /><br />		je Equal		; _if &#40;key == ecx&#41; jmpto Equal<br />		jl LessThan		; _if &#40;key &lt; ecx&#41; jmpto LessThan<br /><br />		mov ecx, eax	; first = mid<br />		inc ecx			; first = mid + 1<br />		jmp BeginL		; loop<br />LessThan&#58;<br />		mov ebx, eax	; last = mid<br />		dec ebx			; last = mid - 1<br />		jmp BeginL		; loop<br />EndBad&#58; <br />		mov eax, -1		; not found<br />Equal&#58;  <br />		ret<br />	&#125;<br />&#125;<br /></code></pre><br /><br />bitrake, if you could perhaps break down the structure of your code for me a bit? Assembly coded by others is still cryptic to me. Also, any other optimization tips would be great. Like, is there a better register for doing certain things in this code that I'm missing?<br /><br />So far I've gotten 10000000 searches on a 6-element array down from 1.60 to 0.85 seconds which is a nice increase. As for being a bottleneck, no it isn't. I'm not even using this code. I'm just trying to write a really fast binary search =)<br /><br />Thanks for your help!!</div>
    <div class="meta">Posted on 2003-03-02 13:28:30 by rmullen3</div>
   </div>
   <div class="post" id="post-84523">
    <div class="subject"><a href="#post-84523">Need help optimizing a binary search in inline ASM</a></div>
    <div class="body"><pre><code>__inline __declspec &#40;naked&#41; int binary_search_asm <br />	&#40;unsigned int first, unsigned int last, int key, int *Array&#41;<br />&#123;<br />	__asm &#123;<br />		mov ecx, dword ptr &#91;esp + 4&#93;	; ecx = first<br />		mov ebx, dword ptr &#91;esp + 8&#93;	; ebx = last<br />		mov edi, dword ptr &#91;esp + 12&#93;	; edi = key<br />		mov edx, dword ptr &#91;esp + 16&#93;	; edx = Array<br />BeginL&#58;<br />		cmp ecx, ebx		; cmp ecx and ebx<br />		lea eax, &#91;ecx + ebx&#93;<br />		ja EndBad<br />		shr eax, 1			; eax == &#40;first + last&#41; &gt;&gt; 1<br /><br />		cmp edi, &#91;edx + eax * 4&#93;<br /><br />		jl LessThan		; _if &#40;key &lt; ecx&#41; jmpto LessThan<br /><br />		lea ecx, &#91;eax + 1&#93;	; first = mid + 1<br />		jne BeginL		; loop<br />		ret<br />LessThan&#58;<br />		lea ebx, &#91;eax - 1&#93;	; last = mid - 1<br />		jmp BeginL		; loop<br />EndBad&#58; <br />		mov eax, -1		; not found<br />		ret<br />	&#125;<br />&#125;</code></pre>IMHO, there is little speed to gain in this code.  Another point is to remove the &quot;JE Equal&quot; because this branch is only taken on the end.  I've also used two more LEA's.  I haven't tested the above code, but it would be nice to know if it does a little better.<br /><br />Next we move some code around:<pre><code>__inline __declspec &#40;naked&#41; int binary_search_asm <br />	&#40;unsigned int first, unsigned int last, int key, int *Array&#41;<br />&#123;<br />	__asm &#123;<br />		mov ecx, dword ptr &#91;esp + 4&#93;	; ecx = first<br />		mov ebx, dword ptr &#91;esp + 8&#93;	; ebx = last<br />		mov edi, dword ptr &#91;esp + 12&#93;	; edi = key<br />		mov edx, dword ptr &#91;esp + 16&#93;	; edx = Array<br />		jmp BeginL<br /><br />EndBad&#58; <br />		mov eax, -1		; not found<br />		ret<br /><br />	ALIGN 16 ; Does this work?<br /><br />LessThan&#58;<br />		lea ebx, &#91;eax - 1&#93;	; last = mid - 1<br />BeginL&#58;<br />		cmp ecx, ebx		; cmp ecx and ebx<br />		lea eax, &#91;ecx + ebx&#93;<br />		ja EndBad<br />		shr eax, 1			; eax == &#40;first + last&#41; &gt;&gt; 1<br /><br />		cmp edi, &#91;edx + eax * 4&#93;<br /><br />		jl LessThan		; _if &#40;key &lt; ecx&#41; jmpto LessThan<br /><br />		lea ecx, &#91;eax + 1&#93;	; first = mid + 1<br />		jne BeginL		; loop<br />		ret<br />	&#125;<br />&#125;</code></pre>See how we are getting close to the code I posted first (above) - not that it is any better. :)</div>
    <div class="meta">Posted on 2003-03-02 13:51:52 by bitRAKE</div>
   </div>
   <div class="post" id="post-84545">
    <div class="subject"><a href="#post-84545">Need help optimizing a binary search in inline ASM</a></div>
    <div class="body">A 6 element array may not be very representative for real uses of the binary search. I did some tests with your code, bitRAKE's and my own (which is bitRAKE's code but slightly modified) and your code seems to be slower than the C version.<br />Test results on an athlonTB 1400:<br /><pre><code>Array size 10 with 80,000,000 iterations&#58;<br /><br />C version&#58;               5088 ms<br />rmullen3's asm version&#58;  5247 ms<br />bitRAKE's asm version&#58;   2243 ms<br />Thomas's asm version&#58;    2013 ms<br /><br />Array size 1,000 with 80,000,000 iterations&#58;<br /><br />C version&#58;               8453 ms<br />rmullen3's asm version&#58;  8722 ms<br />bitRAKE's asm version&#58;   3896 ms<br />Thomas's asm version&#58;    3485 ms<br /><br />Array size 1,000,000 with 80,000,000 iterations&#58;<br /><br />C version&#58;               12808 ms<br />rmullen3's asm version&#58;  12959 ms<br />bitRAKE's asm version&#58;    7691 ms<br />Thomas's asm version&#58;     6549 ms<br /></code></pre><br /><br />And my own version:<br /><pre><code><br />__inline __declspec &#40;naked&#41; int bs_asm2 <br />	&#40;unsigned int first, unsigned int last, int key, int *Array&#41;<br />&#123;<br />	__asm &#123;<br />		push esi<br />		push edi<br />		push ebx<br /><br />		mov ecx, dword ptr &#91;esp + 4 + 3*4&#93;	; ecx = first<br />		mov ebx, dword ptr &#91;esp + 8 + 3*4&#93;	; ebx = last<br />		mov edi, dword ptr &#91;esp + 12+ 3*4&#93;	; edi = key<br />		mov edx, dword ptr &#91;esp + 16+ 3*4&#93;	; edx = Array<br /><br />		lea eax, &#91;ecx + ebx&#93;<br />		jmp BeginL<br /><br />EndBad&#58; <br />		pop ebx<br />		pop edi<br />		pop esi<br />		mov eax, -1		; not found<br />		ret<br /><br />	ALIGN 16 ; Does this work?<br /><br />LessThan&#58;<br />		lea ebx, &#91;eax - 1&#93;<br />		lea eax, &#91;ecx + eax - 1&#93;<br />BeginL&#58;<br />		cmp ecx, ebx<br />		ja EndBad<br />		shr eax, 1<br /><br />		cmp edi, &#91;edx + eax * 4&#93;<br /><br />		jl LessThan<br />		lea ecx, &#91;eax + 1&#93;<br />		lea eax, &#91;ebx + ecx + 1&#93;<br /><br />		jne BeginL<br />		<br />		lea eax, &#91;ecx - 1&#93;<br /><br />		pop ebx<br />		pop edi<br />		pop esi<br />		ret<br />	&#125;<br />&#125;</code></pre><br /><br />Don't forget to push/pop registers when you use __declspec(naked). C++ won't do this for you.<br /><br />Thomas<br /><br /><strong>edit: moved the post to algorithms &amp; source code.</strong></div>
    <div class="meta">Posted on 2003-03-02 15:42:55 by Thomas</div>
   </div>
   <div class="post" id="post-84550">
    <div class="subject"><a href="#post-84550">Need help optimizing a binary search in inline ASM</a></div>
    <div class="body">Nice change, <strong>Thomas</strong>. :) Does the &quot;__inline&quot; do anything? Can the complier inline this code with it having multiple exit points? Isn't there an error in the second part of the loop?<pre><code>		jl LessThan<br />		lea ecx, &#91;eax + 1&#93;<br />		lea eax, &#91;ebx + &#91;COLOR=darkred&#93;EAX&#91;/COLOR&#93; + 1&#93;</code></pre></div>
    <div class="meta">Posted on 2003-03-02 16:06:14 by bitRAKE</div>
   </div>
   <div class="post" id="post-84556">
    <div class="subject"><a href="#post-84556">~</a></div>
    <div class="body">You are right, I don't think that small of array is a good test. Still, testing on a large array, with all optimizations turned off, I tested all versions. (However!! I may not be testing right. The code I use to time code is at the bottom of my post. I don't think it's very good, it's certainly not precise. If anyone could provide me with a better version please do!)<br /><br /><pre><code><br />Array size 1000, searched over 8,000,000 iterations&#58;<br /><br />Orig. C++ version&#58; 3.9 seconds<br />Last version I wrote&#58; 1.65 seconds<br />bitrake's version&#58; 1.98 seconds<br />Thomas's version&#58; 1.43 seconds<br /><br /></code></pre><br /><br />Bear in mind, I have all optimizations turned off. My computer is an AMD-K6-2 at 450 mhz, using VC++, and my timing code as I said may not be very good. <br /><br />However, the main thing: I'm learning a lot here! I'll spend the next hour studying both both of you guy's versions. <br /><br />Also, thomas, by not pushing and popping can some serious errors occur? And why do you have to add 3*4 all those times?<br /><br />Thanks for your help both bitrake and thomas!<br /><br />Anyway, here's the timer code:<br /><br /><pre><code><br />#include &lt;sys\types.h&gt;<br />#include &lt;sys\timeb.h&gt;<br /><br />class stopwatch <br />&#123;<br />	public&#58;<br />		__inline stopwatch &#40;&#41;<br />		&#123;<br />			_ftime&#40;&amp;t1&#41;;<br />		&#125;<br /><br />		__inline void Reset &#40;void&#41; <br />		&#123;<br />			_ftime&#40;&amp;t1&#41;;<br />		&#125;<br /><br />		__inline double Reading &#40;void&#41;<br />		&#123;<br />			_ftime&#40;&amp;t2&#41;;<br />			return &#40;&#40;t2.time - t1.time&#41; +<br />				&#40;t2.millitm - t1.millitm&#41;*0.001&#41;;<br />		&#125;<br /><br />	private&#58;<br />		struct _timeb t1;<br />		struct _timeb t2;<br />&#125;;<br /></code></pre></div>
    <div class="meta">Posted on 2003-03-02 16:35:17 by rmullen3</div>
   </div>
   <div class="post" id="post-84561">
    <div class="subject"><a href="#post-84561">Need help optimizing a binary search in inline ASM</a></div>
    <div class="body">bitRAKE: Yes that's a bug. Should work fine if you change that one. And I don't think inline does anything if you use declspec(naked). You wouldn't be able to get the parameters from esp+offset then because they might be registers (the compiler knows what's where when it inlines C functions). Inlining in C is much more complicated than for example expanding macros in asm. In C++ you can inline any function you like (no matter how many returns you have) and the compiler will still figure out the best way to inline (although there usually is a restriction on the amount of nesting). The compiler can never figure out how to inline your asm code so it probably will ignore the inline.<br /><br /><div class="quote">Bear in mind, I have all optimizations turned off. My computer is an AMD-K6-2 at 450 mhz, using VC++, and my timing code as I said may not be very good. </div><br />I had all optimizations on, to give the C version a fair chance. It also makes the loop more efficient so the timing can be more accurate, although the overhead isn't that big.<br /><br /><div class="quote">Also, thomas, by not pushing and popping can some serious errors occur?</div><br />Yes definitely. I believe if you use just _asm (not declspec(naked)) or something VC detects which registers you use and save them but if you write the whole function yourself (naked) then you need to save esi/edi/ebx/ebp. VC assumes you do so your code will probably crash (or worse: produce wrong results without crashing) if you don't. At least I couldn't run your code without saving the registers.<br /><br /><div class="quote">And why do you have to add 3*4 all those times?</div><br />At the start of the function, the parameter is at . However if you use the push opcode the stack pointer changes. 4 is substracted from esp everytime you push something. So after three pushes, esp is 12 less than it was before. That's why a correction of number_of_pushes * 4 is needed to still get the right offset.<br /><br />Here's the full test code I used:<br /><pre><code><br />&#91;size=9&#93;<br />#include &lt;iostream&gt;<br />#include &lt;string&gt;<br />using namespace std;<br /><br />#define WIN32_MEAN_AND_LEAN<br />#include &lt;windows.h&gt;<br /><br />const int ARRAY_SIZE = 1*1000*1000;<br />const int TEST_COUNT = 80*1000*1000;<br /><br />int bs_c &#40;int *Array, unsigned int first, int last, int key&#41; <br />&#123;<br />	while &#40;first &lt;= last&#41; <br />	&#123;<br />		int mid = &#40;first + last&#41; &gt;&gt; 1;<br />		if &#40;key &gt; Array&#91;mid&#93;&#41;<br />			first = ++mid;<br />		else if &#40;key &lt; Array&#91;mid&#93;&#41;<br />			last = --mid;<br />		else<br />			return mid; <br />	&#125;<br /><br />	return -1;<br />&#125;<br /><br />__inline __declspec &#40;naked&#41; int binary_search_asm <br />	&#40;unsigned int first, unsigned int last, int key, int *Array&#41;<br />&#123;<br />	__asm &#123;<br />		push esi<br />		push edi<br />		push ebx<br />		mov ecx, dword ptr &#91;esp + 4+ 3*4&#93;	; ecx = first<br />		mov ebx, dword ptr &#91;esp + 8+ 3*4&#93;	; ebx = last<br />		mov edi, dword ptr &#91;esp + 12+ 3*4&#93;	; edi = key<br />		mov edx, dword ptr &#91;esp + 16+ 3*4&#93;	; edx = Array<br />BeginL&#58;<br />		cmp ecx, ebx		; cmp ecx and ebx<br />		ja EndBad<br /><br />		lea eax, &#91;ecx + ebx&#93;<br />		shr eax, 1			; eax == &#40;first + last&#41; &gt;&gt; 1<br /><br />		cmp edi, &#91;edx + eax * 4&#93;<br /><br />		je Equal		; _if &#40;key == ecx&#41; jmpto Equal<br />		jl LessThan		; _if &#40;key &lt; ecx&#41; jmpto LessThan<br /><br />		mov ecx, eax	; first = mid<br />		inc ecx			; first = mid + 1<br />		jmp BeginL		; loop<br />LessThan&#58;<br />		mov ebx, eax	; last = mid<br />		dec ebx			; last = mid - 1<br />		jmp BeginL		; loop<br />EndBad&#58; <br />		mov eax, -1		; not found<br />Equal&#58;  <br />		pop ebx<br />		pop edi<br />		pop esi<br />		<br />		ret<br />	&#125;<br />&#125;<br />__inline __declspec &#40;naked&#41; int bs_br <br />	&#40;unsigned int first, unsigned int last, int key, int *Array&#41;<br />&#123;<br />	__asm &#123;<br />		push esi<br />		push edi<br />		push ebx<br /><br />		mov ecx, dword ptr &#91;esp + 4 + 3*4&#93;	; ecx = first<br />		mov ebx, dword ptr &#91;esp + 8+ 3*4&#93;	; ebx = last<br />		mov edi, dword ptr &#91;esp + 12+ 3*4&#93;	; edi = key<br />		mov edx, dword ptr &#91;esp + 16+ 3*4&#93;	; edx = Array<br />		jmp BeginL<br /><br />EndBad&#58; <br />		pop ebx<br />		pop edi<br />		pop esi<br />		mov eax, -1		; not found<br />		ret<br /><br />	ALIGN 16 ; Does this work?<br /><br />LessThan&#58;<br />		lea ebx, &#91;eax - 1&#93;	; last = mid - 1<br />BeginL&#58;<br />		cmp ecx, ebx		; cmp ecx and ebx<br />		lea eax, &#91;ecx + ebx&#93;<br />		ja EndBad<br />		shr eax, 1			; eax == &#40;first + last&#41; &gt;&gt; 1<br /><br />		cmp edi, &#91;edx + eax * 4&#93;<br /><br />		jl LessThan		; _if &#40;key &lt; ecx&#41; jmpto LessThan<br /><br />		lea ecx, &#91;eax + 1&#93;	; first = mid + 1<br />		jne BeginL		; loop<br />		<br />		pop ebx<br />		pop edi<br />		pop esi<br />		ret<br />	&#125;<br />&#125;<br /><br />__inline __declspec &#40;naked&#41; int bs_asm2 <br />	&#40;unsigned int first, unsigned int last, int key, int *Array&#41;<br />&#123;<br />	__asm &#123;<br />		push esi<br />		push edi<br />		push ebx<br /><br />		mov ecx, dword ptr &#91;esp + 4 + 3*4&#93;	; ecx = first<br />		mov ebx, dword ptr &#91;esp + 8 + 3*4&#93;	; ebx = last<br />		mov edi, dword ptr &#91;esp + 12+ 3*4&#93;	; edi = key<br />		mov edx, dword ptr &#91;esp + 16+ 3*4&#93;	; edx = Array<br /><br />		lea eax, &#91;ecx + ebx&#93;<br />		jmp BeginL<br /><br />EndBad&#58; <br />		pop ebx<br />		pop edi<br />		pop esi<br />		mov eax, -1		; not found<br />		ret<br /><br />	ALIGN 16 ; Does this work?<br /><br />LessThan&#58;<br />		lea ebx, &#91;eax - 1&#93;<br />		lea	eax, &#91;ecx + eax - 1&#93;<br />BeginL&#58;<br />		cmp ecx, ebx<br />		ja EndBad<br />		shr eax, 1<br /><br />		cmp edi, &#91;edx + eax * 4&#93;<br /><br />		jl LessThan<br />		lea ecx, &#91;eax + 1&#93;<br />		lea	eax, &#91;ebx + eax + 1&#93;<br /><br />		jne BeginL<br />		<br />		lea	eax, &#91;ecx - 1&#93;<br /><br />		pop ebx<br />		pop edi<br />		pop esi<br />		ret<br />	&#125;<br />&#125;<br /><br />int main&#40;int argc, char* argv&#91;&#93;&#41;<br />&#123;<br />	int *arr = new int&#91;ARRAY_SIZE&#93;;<br />	int i;<br /><br />	for &#40;i=0;i&lt;ARRAY_SIZE;i++&#41;<br />		arr&#91;i&#93; = i;<br /><br />	DWORD t;<br /><br />	t = GetTickCount&#40;&#41;;<br />	for &#40;i=0;i&lt;TEST_COUNT;i++&#41;<br />		bs_c&#40;arr, 0, ARRAY_SIZE-1, 3&#41;;<br />	t = GetTickCount&#40;&#41; - t;<br />	cout &lt;&lt; &quot;C version&#58;               &quot; &lt;&lt; t &lt;&lt; &quot; ms\n&quot;;<br /><br /><br />	t = GetTickCount&#40;&#41;;<br />	for &#40;i=0;i&lt;TEST_COUNT;i++&#41;<br />		binary_search_asm&#40;0, ARRAY_SIZE-1, 3, arr&#41;;<br />	t = GetTickCount&#40;&#41; - t;<br />	cout &lt;&lt; &quot;rmullen3's asm version&#58;  &quot; &lt;&lt; t &lt;&lt; &quot; ms\n&quot;;<br /><br />	t = GetTickCount&#40;&#41;;<br />	for &#40;i=0;i&lt;TEST_COUNT;i++&#41;<br />		bs_br&#40;0, ARRAY_SIZE-1, 3, arr&#41;;<br />	t = GetTickCount&#40;&#41; - t;<br />	cout &lt;&lt; &quot;bitRAKE's asm version&#58;   &quot; &lt;&lt; t &lt;&lt; &quot; ms\n&quot;;<br /><br /><br />	t = GetTickCount&#40;&#41;;<br />	for &#40;i=0;i&lt;TEST_COUNT;i++&#41;<br />		bs_asm2&#40;0, ARRAY_SIZE-1, 3, arr&#41;;<br />	t = GetTickCount&#40;&#41; - t;<br />	cout &lt;&lt; &quot;Thomas's asm version&#58;    &quot; &lt;&lt; t &lt;&lt; &quot; ms\n&quot;;<br /><br />	delete&#91;&#93; arr;<br />	return 0;<br />&#125;<br />&#91;/SIZE&#93;</code></pre><br /><br />Thomas</div>
    <div class="meta">Posted on 2003-03-02 17:05:00 by Thomas</div>
   </div>
   <div class="post" id="post-84588">
    <div class="subject"><a href="#post-84588">Need help optimizing a binary search in inline ASM</a></div>
    <div class="body">rmullen3,<br />Some time ago I used similar code with my WndProc:<pre><code><br /><br />.data<br />ALIGN 4							        ;		<br />MainMessages      DD	WM_LBUTTONDOWN, OnMouseMove_1	        ; WM_LBUTTONDOWN=201h<br />	          DD	WM_MOUSEMOVE, OnMouseMove		; WM_MOUSEMOVE=200h <br />	          DD	WM_TIMER, OnTimer			; WM_TIMER = 113h<br />	          DD	WM_COMMAND, OnCommand		        ; WM_COMMAND=111h<br />	          DD	WM_NCLBUTTONDOWN, OnNclbuttondown	; 0A1h <br />	          DD	WM_DISPLAYCHANGE, OnDisplayChange	; WM_DISPLAYCHANGE= 7Eh<br /> 	          DD	WM_GETMINMAXINFO, OnGetminmaxinfo  	; 24h<br />	          DD	WM_PAINT, OnPaint			; WM_PAINT=0Fh<br />	          DD	WM_SIZE, OnSize				; WM_SIZE=05h<br />	          DD	WM_DESTROY, OnDestroy			; WM_DESTROY=02h<br />	          DD	WM_CREATE, OnCreate			; WM_CREATE=01h <br />nMessages         DD	&#40;$-MainMessages&#41;/8			;<br />;...............................................................;	<br /><br />.code<br /><br />;...............................................;<br />;Align 16					;<br />WndProc&#58;					; above 10  sorted messages only!! <br />	cmp	dword ptr &#91;esp+8&#93;, 201h 	; &#91;esp+8&#93;-&gt; uMsg max message<br />	ja	DefWindowProc		        ; out of range?<br />&#91;B&#93;;Binary dword search in sorted array &#91;/B&#93;...........;<br />	mov	edx, &#91;esp+8&#93;  		        ; edx=uMsg <br />	xor 	ecx, ecx			; top &lt;= 0	<br />	push	ebx			        ; save register as required by Windows<br />	mov 	eax, nMessages		        ; eax=number of messages to do<br />&#91;B&#93;;Align 16&#91;/B&#93;					; !!! Loop must be 16 aligned !!!<br />lowM&#58;					        ;<br />	mov 	ebx, eax			; ebx=&gt;last<br />	add  	eax, ecx			; ecx=&gt;first<br />checkM&#58;					        ;<br />	shr 	eax, 1			        ; divide by 2<br />	cmp 	ecx, ebx			; done if first == last<br />	jnc 	WndProc_1		        ; not found =&gt; jmp to DefWindowProc<br />	cmp 	&#91;MainMessages+8*eax&#93;, edx   	; messages are in descending order<br />	;cmp 	edx, &#91;MainMessages+8*eax&#93;   	; messages are in ascending order<br />	jc  	lowM			        ;<br />	db	3Eh			        ; prefix ds&#58;	 <br />	lea   	ecx, &#91;eax+1&#93;		        ; ecx =&gt; first<br />	lea   	eax, &#91;ebx+eax+1&#93; 		; ebx=&gt; last<br />	jne   	checkM			        ; if not equal loop again<br />&#91;B&#93;;End Binary dword search in sorted array &#91;/B&#93;.......;		<br />	push	esp			        ; save registers as required by Windows<br />	push	ebp			        ;<br />	push	esi			        ; call correct procedure for the message<br />	push	edi			        ;<br />	call	dword ptr &#91;MainMessages+ecx*8-8+4&#93; ; <br />	pop	edi			        ;<br />	pop	esi			        ; &#91;esp+4+24&#93;=hwnd,&#91;esp+8+24&#93;=umsg,<br />	pop	ebp			        ; &#91;esp+12+24&#93;=wparam,&#91;esp+16+24&#93;=lparam<br />	pop	esp			        ;<br />WndProc_1&#58;				        ;    <br />	pop	ebx			        ; restore registers<br />	jnc	DefWindowProc    		; if carry set=don?t call DefWinProc  eax=exit ode<br />	ret	16			        ; ret 16 -&gt; clears the stack  from 4 parameters<br /><br />Loop In memory&#58;<br />004011D0 8B D8                		mov	ebx, eax				; D0<br />004011D2 03 C1                		add	eax, ecx				; D1<br />004011D4 D1 E8                		shr	eax, 1; D0<br />004011D6 3B CB                		cmp	ecx, ebx				; D1<br />004011D8 73 13           		jae	004011ED				; D0<br />004011DA 39 14 C5 18 26 40 00 	cmp	dword ptr &#91;eax*8+402618h&#93;, edx	; D0<br />004011E1 72 ED                		jb	004011D0				; D1<br />004011E3 3E 8D 48 01		lea	ecx, ds&#58;&#91;eax+1&#93;			; D0<br />004011E7 8D 44 18 01		lea	eax, &#91;eax+ebx+1&#93;		; D0	<br />004011EB 75 E7			         jne	004011D4				; D1<br />004011ED <br />;...............................................;</code></pre><br /><br />As you see it is very close to Thomas's decision but MUST be faster<br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-03-02 20:45:49 by lingo12</div>
   </div>
   <div class="post" id="post-84593">
    <div class="subject"><a href="#post-84593">~</a></div>
    <div class="body">Your code is confusing to me, lingo. Sorry, I'm not skilled enough to seperate the general search part of it from the other Window like things =) But it looks really interesting! I'll spend some time with it. If it's faster, awesome, I must get max speed =D<br /><br />I have one more question for now, concerning these lines of code:<br /><br /><pre><code><br />shr eax, 1<br /><br />cmp edi, &#91;edx + eax * 4&#93;<br /></code></pre><br /><br />Why doesn't either of following work:<br /><br /><pre><code><br />shr eax, 1<br />shl eax, 2<br /><br />cmp edi, &#91;edx + eax&#93;<br /></code></pre><br /><br /><pre><code><br />cmp edi, &#91;edx + eax * 2&#93;<br /></code></pre><br /><br />Because if you're first dividing eax by 2 (shr eax, 1) then multiplying it by 4, aren't you just multiplying by 2? <br /><br />Thanks!</div>
    <div class="meta">Posted on 2003-03-02 21:12:01 by rmullen3</div>
   </div>
   <div class="post" id="post-84600">
    <div class="subject"><a href="#post-84600">Need help optimizing a binary search in inline ASM</a></div>
    <div class="body">&quot;Why doesn't either of following work:&quot;<br />Easy! Just substitute eax with: 0,1, 2, 3, 4, 5....and compute it.<br />Lets edx=1000=const<br /><br />&quot;Why must it be faster?&quot; <br />Easy! Just count D0 in both loops ; D0 =&gt; CPU clock (expected)<br /><br />For PPro, PII and PIII here is Thomas's code in memory:<pre><code><br />Align 16<br />LessThan&#58;<br />&#91;B&#93;004030D0&#91;/B&#93; 8D 58 FF               lea     ebx, &#91;eax-1&#93;  		; D0<br />004030D3 8D 44 08 FF		lea	eax, &#91;eax+ecx-1&#93;   	; D0	<br />BeginL&#58;<br />&#91;B&#93;004030D7&#91;/B&#93; 3B CB                  cmp	ecx, ebx		; D1 D0<br />004030D9 77 10			ja	EndBad &#40;4030EBh&#41;	; D0 D1 <br />004030DB D1 E8			shr	eax, 1 	     		; D0 	<br />004030DD 3B 3C 82		cmp	edi, dword ptr &#91;edx+eax*4&#93;;D0<br />&#91;B&#93;004030E0&#91;/B&#93; 7C EE	         	jl	LessThan &#40;4030D0h&#41;	; D0 <br />004030E2 8D 48 01		lea     ecx, &#91;eax+1&#93;  		; D0<br />&#91;B&#93;004030E5&#91;/B&#93; 8D 44 19 01        	lea     eax, &#91;ecx+ebx+1&#93;  	; D0<br />004030E9 75 EC              	jne	BeginL &#40;4030D7h&#41; 	; D1<br />EndBad&#58;</code></pre><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-03-02 22:06:09 by lingo12</div>
   </div>
   <div class="post" id="post-84608">
    <div class="subject"><a href="#post-84608">Need help optimizing a binary search in inline ASM</a></div>
    <div class="body">rmullen3,<br />I have question about your code, too:<pre><code><br />LessThan&#58;<br />	mov ebx, &#91;B&#93;eax&#91;/B&#93;	; last = mid<br />	dec ebx		; last = mid - 1<br />	jmp BeginL</code></pre><br />What will be happen if we are at LessThan label and <strong>eax</strong> = 0?<br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2003-03-02 23:19:26 by lingo12</div>
   </div>
   <div class="post" id="post-84623">
    <div class="subject"><a href="#post-84623">Need help optimizing a binary search in inline ASM</a></div>
    <div class="body"><pre><code>;MACRO based on &#91;b&#93;lingo12&#91;/b&#93;'s code&#58;<br /><br />bs12 MACRO  item&#58;REQ, key&#58;REQ, Array&#58;REQ, first&#58;REQ, last&#58;REQ, EndBad&#58;REQ<br />	LOCAL _low, _check<br /><br />	; item	&#58; register to receive result index to key item<br />	; key	&#58; register of value of key to find<br />	; Array	&#58; OFFSET or register pointer to array in memory<br />	; first &#58; register index of first Array item<br />	; last	&#58; register index of last Array item<br />	; EndBad&#58; if key is not found jump to this label<br /><br />	mov	item, last<br /><br />	ALIGN 16<br /><br />_low&#58;	mov	last, item<br />	add	item, first<br />_check&#58;	shr	item, 1<br />	cmp	first, last			; done if first == last<br />	jnc	EndBad<br />	cmp	&#91;Array + 4*item&#93;, key		; descending order<br />	;cmp	key, &#91;Array + 4*item&#93;   	; ascending order<br />	jc	_low<br />	lea	first, &#91;item + 1&#93;<br />	lea	item, &#91;last + item + 1&#93;<br />	jne	_check<br /><br />	lea	item, &#91;first - 1&#93; ; found key index<br />ENDM<br /><br /><br />	bs12 edi, esi, ebx, eax, edx, Not_Found<br />	; EDI is the key, &#91;ebx+edi*4&#93; = esi<br /></code></pre></div>
    <div class="meta">Posted on 2003-03-03 00:48:36 by bitRAKE</div>
   </div>
  </div>
 </body>
</html>