<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Questions regarding IO Completion Ports and WinSock - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=9508" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=9508">Questions regarding IO Completion Ports and WinSock</a></p>
   <div class="post" id="post-70364">
    <div class="subject"><a href="#post-70364">Questions regarding IO Completion Ports and WinSock</a></div>
    <div class="body">Calling all those with knowledge of IO Completion ports and it's use with WinSock!<br /><br />I have downloaded and studied about 10 examples of this type of server implemented in various ways in C/C++ code ... Basically, my server is almost complete, except for one small problemo :(<br /><br />I can successfully create the IO Completion port using CreateIoCompletionPort() (still waiting patiently for Hutch to add this API to the Kernel32.Lib and Kernel32.Inc files so I don't have to add it at runtime :( ), I can successfully add listening or connected sockets to the IO Completion Port I created as well! But the problem basically is that WinSock doesn't seem to signal the Port when network events such as FD_ACCEPT, FD_WRITE, FD_READ and FD_CLOSE occur!<br /><br />So my calls in the working threads to the GetQueuedCompletionStatus() API never release! If I use PostQueuedCompletionStatus() API to send the Completion Port a message however, it releases and returns with my message! So everything is as it should be ... I think :confused:<br /><br />My calls to CreateIoCompletionPort(), GetQueuedCompletionStatus() and PostQueuedCompletionStatus() don't return any errors ... everything seems normal and as it should be ... just that WinSock isn't sending network event messages to the port ... can someone maybe explain to me how WinSock is supposed to know that it must send messages there (To the Completion Port) ? It just doesn't seem to know that the sockets are using a Completion Port for communication !<br /><br />I can fix up my code leaving only the necessary stuff and post it to you for analysis if it helps?<br /><br />Thanx!<br /><br />PS: I posted it here for 2 reasons :) The mods will probably move it to the NetWorking section so I get both sections and Completion Ports are used by other areas such as ReadFileEx and WriteFileEx API's .... not just WinSock :)</div>
    <div class="meta">Posted on 2002-12-11 00:46:59 by SubEvil</div>
   </div>
   <div class="post" id="post-70412">
    <div class="subject"><a href="#post-70412">Questions regarding IO Completion Ports and WinSock</a></div>
    <div class="body">You should probably familiarize yourself intimately with the other socket IO models before you begin tackling IOCPs.<br /><br />Anyways, the reason you aren't getting FD_xxxxx notifications is because that's not how it's done with the IOCP model.  You have to set your own event aliases and pass them as an appendage to the lpOverlapped structure when you queue an event on the port.</div>
    <div class="meta">Posted on 2002-12-11 05:35:52 by iblis</div>
   </div>
   <div class="post" id="post-70444">
    <div class="subject"><a href="#post-70444">Questions regarding IO Completion Ports and WinSock</a></div>
    <div class="body">Hi Iblis,<br /><br />I'm intimately familiar with the other methods ... well the WSAAsyncSelect/WSAEventSelect methods ... I can do them in my sleep! I just used the FD_xxx thing to try and relate where my problems lay! I have made many successful multi-threading servers with the other two methods, I even use my other servers to try and connect to my new IOCP server ... to no avail :( I even made a sorta WSAEventSelect (For the Listening Socket) IOCP Hybrid (For the Connected Sockets) ...<br /><br />Anyway ... so back to this setting an event alias ... I have seen something similar being done in some examples ... but didn't quite get it !<br />How exactly do you tell WinSock to use these events? I mean ... how does WinSock know to post a message in the IOCP queue? You said &quot;when you queue an event on the port&quot;??? That's scarry ... I though WinSock would be queing events ... not me!<br /><br />Question: What if you only want &quot;FD_READ&quot; events posted on a particular socket? In WSAAsyncSelect you &quot;or&quot; the FD_xxx values together ... so how do you tell the IOCP just to notify you when data has arrived on a socket ?<br />Question: Does WinSock change the OVERLAPPED structure?<br />Question: What is the use of the OVERLAPPED structure ? You don't actually need it do you ? I will know which OVERLAPPED structure is used by which socket from the Completion Key generally! But is there anything in the OVERLAPPED structure of use ?<br />Question: How does WinSock know what messages to post to the IOCP for a particular socket? Just by adding the socket to the IOCP ??? Is that enough? Because I successfully do that but WinSock isn't sending any messages to my IOCP!<br /><br />You see the issue is I can make an IOCP, I can connect Sockets to it ... but WinSock doesn't seem to Post any messages to it! So when I call GetQueuedCompletionStatus() to wait for messages, it never releases when a client sends me data! It just sits there waiting ... but I can post it manual messages and it works fine :(<br /><br />Perhaps you could briefly explain how the messaging system works in the IOCP model in comparison to the others?<br /><br />I would really appreciate your help! There doesn't seem to be many here that know about IOCP's. If you have some ASM source code I could look at I'd love that ... otherwise just a little help understanding!</div>
    <div class="meta">Posted on 2002-12-11 07:50:47 by SubEvil</div>
   </div>
   <div class="post" id="post-70648">
    <div class="subject"><a href="#post-70648">Questions regarding IO Completion Ports and WinSock</a></div>
    <div class="body">SubEvil,<br />The third parameter of CreateIoCompletionPort allows a completion key to be specified along with the<br />socket handle to be associated. U can use this to pass context information that is associated with the<br />socket. It is a pointer to your own <strong>EXTENDED</strong> OVERLAPPED structure.<br />GetQueuedCompletionStatus will return the same pointer when the operation completes, i.e.<br />GetQueuedCompletionStatus will return the same pointer to your own <strong>EXTENDED</strong> OVERLAPPED<br />structure when the operation completes. That's all.<br />No FD_ACCEPT, FD_WRITE, FD_READ, FD_CLOSE and other bla, bla, blab..<br /><br />What about accept API u use?<br />If you post a code I can help more<br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2002-12-12 16:14:00 by lingo12</div>
   </div>
   <div class="post" id="post-70835">
    <div class="subject"><a href="#post-70835">Questions regarding IO Completion Ports and WinSock</a></div>
    <div class="body">Question: Can a listening socket be added to an IOCP? Or only connected &quot;normal&quot; client sockets?<br /><br />Question: Is the overlapped/extened overlapped structure absolutely necessary in IOCP? And why?<br /><br />Question: How does WINSOCK know the socket is communicating through IOCP ???<br />eg. We added the socket to the IOCP via CreateIoCompletionPort() API ... so does WinSock now automatically send network status messages to the IOCP just by using this API? WinSock and this API don't seem to be related!<br /><br /><br />Anyway,<br />I've included a sample of my Server, took me long to simplify this code but I'm desperate to understand IOCP now!<br />You will see, the IOCP is created, no problems, the worker thread is created, no problem, WinSock is initialized, no problem, a listening socket is created and added to the IOCP, no problem!<br /><br />BUT<br /><br />When a client connects, WinSock doesn't notify the IOCP of the new client! So before I can issue an AcceptEx/Accept call on the new socket, the message is lost!<br /><br />I added 3 dummy message posts to the IOCP to see if it's OK (you will see 3 messageboxes pop up when it starts, they are from the Worker Thread) ... no problems ... I can send custom messages to the IOCP but WinSock never does, it doesn't let the listening socket on the IOCP know we have a new connection!<br /><br />You will notice the Worker Thread posts a simple message whenever it get's something, but WinSock has NEVER sent my Worker Thread ANY messages! Not on connect, not on data send or when data is received on a socket NEVER :( That's my only problem! WinSock doesn't seem to communicate through the IOCP! Even if I successfully add the socket to the IOCP :(<br /><br /><div class="quote"> GetQueuedCompletionStatus will return the same pointer to your own EXTENDED OVERLAPPED<br />structure when the operation completes.</div><br />GetQueuedCompletionStatus has NEVER returned when a WinSock operation completes! = My problem</div>
    <div class="meta">Posted on 2002-12-13 12:47:48 by SubEvil</div>
   </div>
   <div class="post" id="post-70848">
    <div class="subject"><a href="#post-70848">Questions regarding IO Completion Ports and WinSock</a></div>
    <div class="body">I just briefly glanced over your code and noticed a few things right off the bat.  Among them is that you apparently have no idea what you're doing.  You should probably go get a book on Winsock 2 or something and save yourself the frustration.<br /><br />Anyways, here are the biggies:<br /><br /><br />1) You create the IOCP, but never add any handles to it.  If you want it to process socket events then you'll have to do that.  An example of what you should do:<br /><br /><pre><code>&#91;size=12&#93;;First create the port.<br />    invoke CreateIoCompletionPort, INVALID_HANDLE_VALUE, NULL, 0, 0<br />    or eax, eax<br />    jz error<br />    mov hIOCP, eax<br /><br />...<br /><br />;Add socket handle to the port.<br />;&#40;later on, once you have a socket&#41;<br />    invoke CreateIoCompletionPort, hsocket, hIOCP, addr SocketContext, 0<br />    or eax, eax<br />    jz error&#91;/size&#93;</code></pre><br /><br /><br />Secondly, you never receive or send anything on those sockets.  I.E.:<br /><br /><pre><code>&#91;size=12&#93;    invoke WSASend, hsocket, addr wsabuf, 1, addr nBytes, 0, addr extOverlapped, NULL<br />    cmp eax, SOCKET_ERROR<br />    jne noerror<br />    invoke WSAGetLastError<br />    cmp eax, WSA_IO_PENDING<br />    jne error<br />noerror&#58;<br />    ...&#91;/size&#93;</code></pre><br /><br /><br />There are of course more issues you missed, but you should probably grasp these concepts (and the extended overlapped structure Lingo and I were talking about) before continuing.</div>
    <div class="meta">Posted on 2002-12-13 13:35:51 by iblis</div>
   </div>
   <div class="post" id="post-70867">
    <div class="subject"><a href="#post-70867">Questions regarding IO Completion Ports and WinSock</a></div>
    <div class="body">SubEvil,<br />I saw your code and unfortunately iblis is right<br />I didn't see how you manage the clients,<br />accept the connections, send and receive data<br /><strong>ASYNCHRONOUSLY</strong>, close the connections, etc.<br />You need to learn the differences between  listen<br />and accepted  sockets too..<br />I suppose you can read C because your 286 assembly<br />is similar and here is an example about IOCP. <br />If your next code has all the attributes from it<br />I will continue to help you, else I'm not sure <pre><code><br />#include &quot;stdafx.h&quot;<br />#define WIN32_LEAN_AND_MEAN<br />#include &lt;winsock2.h&gt;<br /><br />#include &quot;iocpserver.h&quot;<br /><br />unsigned short  g_Port          = 5001;<br />BOOL                g_bEndServer    = FALSE;     // set to TRUE on CTRL-C<br />DWORD           g_dwThreadCount = 0;            //worker thread count<br />HANDLE          g_hIOCP         = NULL;<br />SOCKET          g_sdListen      = INVALID_SOCKET;<br />HANDLE          g_hThreads&#91;MAX_WORKER_THREAD&#93;;<br />CPtrList            g_CtxtList; <br />CRITICAL_SECTION    g_CriticalSection;      // guard access to the global context list<br /><br />#ifdef _DEBUG<br />#define new DEBUG_NEW<br />#undef THIS_FILE<br />static char THIS_FILE&#91;&#93; = __FILE__;<br />#endif<br /><br />// The one and only application object<br />CWinApp theApp;<br />using namespace std;<br /><br />int _tmain&#40;int argc, TCHAR* argv&#91;&#93;, TCHAR* envp&#91;&#93;&#41;<br />&#123;<br />    int nRetCode = 0;<br /><br />	// initialize MFC and print and error on failure<br />	if &#40;!AfxWinInit&#40;&#58;&#58;GetModuleHandle&#40;NULL&#41;, NULL, &#58;&#58;GetCommandLine&#40;&#41;, 0&#41;&#41;<br />    &#123;<br />	  cerr &lt;&lt; _T&#40;&quot;Fatal Error&#58; MFC initialization failed&quot;&#41; &lt;&lt; endl;<br />	  return &#40;nRetCode = 1&#41;;<br />    &#125;<br />    SYSTEM_INFO      systemInfo;<br />    WSADATA             wsaData;<br />    SOCKET                sdAccept = INVALID_SOCKET;<br />    PPER_SOCKET_CONTEXT lpPerSocketContext = NULL;<br />    DWORD                 dwRecvNumBytes = 0;     <br />    DWORD                 dwFlags = 0;<br />    DWORD                  numClients = 0;<br />    int   nRet;<br /><br />    g_bEndServer = FALSE;<br />    GetSystemInfo&#40;&amp;systemInfo&#41;;<br />    g_dwThreadCount = systemInfo.dwNumberOfProcessors * 2;<br />    if &#40;&#40;nRet = WSAStartup&#40;MAKEWORD&#40;2,2&#41;, &amp;wsaData&#41;&#41; != 0&#41;<br />    &#123;<br />        printf&#40;&quot;WSAStartup failed&#58; %d\n&quot;,nRet&#41;;<br />        return 1;<br />    &#125;<br />    InitializeCriticalSection&#40;&amp;g_CriticalSection&#41;;<br />    g_hIOCP = CreateIoCompletionPort&#40;INVALID_HANDLE_VALUE, NULL, 0, 0&#41;;<br />    if &#40;NULL == g_hIOCP&#41; <br />    &#123;<br />        printf&#40;&quot;CreateIoCompletionPort failed&#58; %d\n&quot;, GetLastError&#40;&#41;&#41;;<br />        CleanUp&#40;&#41;;<br />        return 1;<br />    &#125;<br />    for &#40;DWORD dwCPU=0; dwCPU &lt; g_dwThreadCount; dwCPU++&#41; <br />    &#123;<br />        HANDLE  hThread;<br />        DWORD   dwThreadId;<br /><br />        hThread = CreateThread&#40;NULL, 0, EchoThread, g_hIOCP, 0, &amp;dwThreadId&#41;;<br />        if &#40;hThread == NULL&#41; <br />        &#123;<br />            printf&#40;&quot;CreateThread failed&#58; %d\n&quot;, GetLastError&#40;&#41;&#41;;<br />            CleanUp&#40;&#41;;<br />            return 1;<br />        &#125;<br />        g_hThreads&#91;dwCPU&#93; = hThread;<br />    &#125;<br />    if &#40;!CreateListenSocket&#40;&#41;&#41;<br />    &#123;<br />        CleanUp&#40;&#41;;<br />        return 1;<br />    &#125;<br /><br /><br />//&#91;B&#93;; WHERE IS NEXT PART IN YOUR ASM CODE&#91;/B&#93;<br /><br /><br />    while &#40;g_bEndServer == FALSE&#41; <br />    &#123;<br />        sdAccept = WSAAccept&#40;g_sdListen, NULL, NULL, NULL, 0&#41;;<br />        if &#40;SOCKET_ERROR == sdAccept&#41; <br />        &#123;<br />            printf&#40;&quot;WSAAccept&#58; %d\n&quot;, WSAGetLastError&#40;&#41;&#41;;<br />            CleanUp&#40;&#41;;<br />            return 1;<br />        &#125;<br />	printf&#40;&quot;Accept Listen socket&#58; %d\n&quot;, numClients++ &#41;;<br />        lpPerSocketContext = UpdateCompletionPort&#40;sdAccept, ClientIoRead&#41;;<br />        if &#40;NULL == lpPerSocketContext&#41; <br />        &#123;<br />            CleanUp&#40;&#41;;<br />            return 1;<br />        &#125;<br />        // post initial receive on this socket<br />        nRet = WSARecv&#40;sdAccept, &amp;&#40;lpPerSocketContext-&gt;pIOContext-&gt;wsabuf&#41;, 1, <br />                    &amp;dwRecvNumBytes, &amp;dwFlags,<br />                    &amp;&#40;lpPerSocketContext-&gt;pIOContext-&gt;Overlapped&#41;, NULL&#41;;<br />        if &#40;nRet == SOCKET_ERROR &amp;&amp; &#40;ERROR_IO_PENDING != WSAGetLastError&#40;&#41;&#41;&#41; <br />        &#123;<br />            printf&#40;&quot;WSARecv Failed&#58; %d\n&quot;, WSAGetLastError&#40;&#41;&#41;;<br />            CloseClient&#40;lpPerSocketContext&#41;;<br />        &#125;<br />    &#125; //while<br />    CleanUp&#40;&#41;;<br />    return 1;<br />&#125; //main<br />//  Create a listening socket.<br />BOOL CreateListenSocket&#40;void&#41;<br />&#123;<br />    SOCKADDR_IN si_addrlocal;<br />    int         nRet;<br />    int         nZero = 0;<br />    g_sdListen = WSASocket&#40;AF_INET, SOCK_STREAM, IPPROTO_IP, NULL, 0, 			WSA_FLAG_OVERLAPPED&#41;; <br />    if &#40;INVALID_SOCKET == g_sdListen&#41;<br />    &#123;<br />        printf&#40;&quot;WSASocket&#40;g_sdListen&#41;&#58; %d\n&quot;, WSAGetLastError&#40;&#41;&#41;;<br />        return&#40;FALSE&#41;;<br />    &#125;<br />    si_addrlocal.sin_family = AF_INET;<br />    si_addrlocal.sin_port = htons&#40;g_Port&#41;;<br />    si_addrlocal.sin_addr.s_addr = htonl&#40;INADDR_ANY&#41;;       <br />    nRet = bind&#40;g_sdListen, &#40;struct sockaddr *&#41;&amp;si_addrlocal, sizeof&#40;si_addrlocal&#41;&#41;;<br />    if &#40;SOCKET_ERROR == nRet&#41; <br />    &#123;<br />        printf&#40;&quot;bind&#58; %d\n&quot;, WSAGetLastError&#40;&#41;&#41;;<br />        return&#40;FALSE&#41;;<br />    &#125;<br />    nRet = listen&#40;g_sdListen, 5&#41;;<br />    if &#40;SOCKET_ERROR == nRet&#41; <br />    &#123;<br />        printf&#40;&quot;listen&#58; %d\n&quot;, WSAGetLastError&#40;&#41;&#41;;<br />        return&#40;FALSE&#41;;<br />    &#125;<br />    return&#40;TRUE&#41;;<br />&#125;<br />// Worker thread that handles all I/O requests on any socket handle added to the IOCP.<br />//<br />DWORD WINAPI EchoThread &#40;LPVOID WorkThreadContext&#41;<br />&#123;<br />    HANDLE       hIOCP = &#40;HANDLE&#41;WorkThreadContext;<br />    BOOL            bSuccess = FALSE;<br />    int                   nRet;<br />    LPOVERLAPPED    lpOverlapped = NULL;<br />    PPER_SOCKET_CONTEXT lpPerSocketContext = NULL;<br />    PPER_IO_CONTEXT     lpIOContext = NULL; <br />    WSABUF          buffRecv;<br />    WSABUF          buffSend;<br />    DWORD           dwRecvNumBytes = 0;<br />    DWORD           dwSendNumBytes = 0;<br />    DWORD           dwFlags = 0;<br />    DWORD           dwIoSize;<br />    while &#40;TRUE&#41; <br />    &#123;<br />        // continually loop to service io completion packets<br />        bSuccess = GetQueuedCompletionStatus&#40;hIOCP,<br />                     &amp;dwIoSize, &#40;LPDWORD&#41;&amp;lpPerSocketContext,<br />                     &amp;lpOverlapped,INFINITE&#41;;<br />        if &#40;!bSuccess&#41; <br />            printf&#40;&quot;GetQueuedCompletionStatus&#58; %d\n&quot;, GetLastError&#40;&#41;&#41;;<br /><br />        if &#40;lpPerSocketContext == NULL&#41;<br />        &#123;<br />            return&#40;0&#41;;<br />        &#125;<br /><br />        if &#40;g_bEndServer&#41; <br />        &#123;<br />            return 0;<br />        &#125;<br />        if &#40;!bSuccess || &#40;bSuccess &amp;&amp; &#40;0 == dwIoSize&#41;&#41;&#41; <br />        &#123;<br />            // client connection dropped, continue to service remaining &#40;and possibly <br />            // new&#41; client connections<br />            CloseClient&#40;lpPerSocketContext&#41;; <br />            continue;<br />        &#125;<br />        // determine what type of IO packet has completed by checking the PER_IO_CONTEXT <br />        // associated with this socket.  This will determine what action to take.<br />        lpIOContext = &#40;PPER_IO_CONTEXT&#41;lpOverlapped;<br />        switch &#40;lpIOContext-&gt;IOOperation&#41;<br />        &#123;<br />            case ClientIoRead&#58;<br />                // a read operation has completed, post a write operation to echo the<br />                // data back to the client using the same data buffer.<br />                lpIOContext-&gt;IOOperation = ClientIoWrite;<br />                lpIOContext-&gt;nTotalBytes = dwIoSize;<br />                lpIOContext-&gt;nSentBytes  = 0;<br />                lpIOContext-&gt;wsabuf.len  = dwIoSize;<br />                dwFlags = 0;<br />                nRet = WSASend&#40;lpPerSocketContext-&gt;Socket,<br />                    &amp;lpIOContext-&gt;wsabuf, 1, &amp;dwSendNumBytes,<br />                    dwFlags, &amp;&#40;lpIOContext-&gt;Overlapped&#41;, NULL&#41;;<br />                if &#40;SOCKET_ERROR == nRet &amp;&amp; &#40;ERROR_IO_PENDING != WSAGetLastError&#40;&#41;&#41;&#41; <br />                &#123;<br />                    printf&#40;&quot;WSASend&#58; %d\n&quot;, WSAGetLastError&#40;&#41;&#41;;<br />                    CloseClient&#40;lpPerSocketContext&#41;;<br />                &#125;<br />                break;<br />            case ClientIoWrite&#58;<br />                // a write operation has completed, determine if all the data intended to be<br />                // sent actually was sent.<br />                lpIOContext-&gt;IOOperation = ClientIoWrite;<br />                lpIOContext-&gt;nSentBytes  += dwIoSize;<br />                dwFlags = 0;<br />                if &#40;lpIOContext-&gt;nSentBytes &lt; lpIOContext-&gt;nTotalBytes&#41; <br />                &#123;<br />                    // the previous write operation didn't send all the data,<br />                    // post another send to complete the operation<br />                    buffSend.buf = lpIOContext-&gt;Buffer + lpIOContext-&gt;nSentBytes;<br />                    buffSend.len = lpIOContext-&gt;nTotalBytes - lpIOContext-&gt;nSentBytes;<br />                    nRet = WSASend &#40;<br />                        lpPerSocketContext-&gt;Socket,<br />                        &amp;buffSend, 1, &amp;dwSendNumBytes,<br />                        dwFlags,<br />                        &amp;&#40;lpIOContext-&gt;Overlapped&#41;, NULL&#41;;<br />                    if &#40;SOCKET_ERROR == nRet &amp;&amp; &#40;ERROR_IO_PENDING != WSAGetLastError&#40;&#41;&#41;&#41; <br />                    &#123;<br />                        printf &#40;&quot;WSASend&#58; %d\n&quot;, WSAGetLastError&#40;&#41;&#41;;<br />                        CloseClient&#40;lpPerSocketContext&#41;;<br />                    &#125;<br />                &#125;<br />                else<br />                &#123;<br />                    // previous write operation completed for this socket, post another recv<br />                    lpIOContext-&gt;IOOperation = ClientIoRead; <br />                    dwRecvNumBytes = 0;<br />                    dwFlags = 0;<br />                    buffRecv.buf = lpIOContext-&gt;Buffer,<br />                    buffRecv.len = MAX_BUFF_SIZE;<br />                    nRet = WSARecv&#40;<br />                        lpPerSocketContext-&gt;Socket,<br />                        &amp;buffRecv, 1, &amp;dwRecvNumBytes,<br />                        &amp;dwFlags,<br />                        &amp;lpIOContext-&gt;Overlapped, NULL&#41;;<br />                    if &#40;SOCKET_ERROR == nRet &amp;&amp; &#40;ERROR_IO_PENDING != WSAGetLastError&#40;&#41;&#41;&#41; <br />                    &#123;<br />                        printf &#40;&quot;WSARecv&#58; %d\n&quot;, WSAGetLastError&#40;&#41;&#41;;<br />                        CloseClient&#40;lpPerSocketContext&#41;;<br />                    &#125;<br />                &#125;<br />                break;<br />        &#125; //switch<br />    &#125; //while<br />    return&#40;0&#41;;<br />&#125; <br />PPER_SOCKET_CONTEXT UpdateCompletionPort&#40;SOCKET sd, IO_OPERATION ClientIo&#41;<br />&#123;<br />  PPER_SOCKET_CONTEXT lpPerSocketContext;<br /><br />  // PER_SOCKET_CONTEXT<br />  lpPerSocketContext = CtxtAllocate&#40;sd, ClientIo&#41;;<br />	if &#40;lpPerSocketContext == NULL&#41; <br />	return NULL;<br /><br />  g_hIOCP = CreateIoCompletionPort&#40;&#40;HANDLE&#41;sd, g_hIOCP, <br />         &#40;DWORD&#41;lpPerSocketContext, 0&#41;;<br />  if &#40;NULL == g_hIOCP&#41; <br />  &#123;<br />    printf&#40;&quot;CreateIoCompletionPort&#58; %d\n&quot;, GetLastError&#40;&#41;&#41;;<br />    if &#40;lpPerSocketContext-&gt;pIOContext&#41;<br />	free&#40;lpPerSocketContext-&gt;pIOContext&#41;;<br />	free&#40;lpPerSocketContext&#41;;<br />    return&#40;NULL&#41;;<br />  &#125;<br />  CtxtListAddTo&#40;lpPerSocketContext&#41;;<br /><br />  return&#40;lpPerSocketContext&#41;;<br />&#125;<br />VOID CloseClient &#40;PPER_SOCKET_CONTEXT lpPerSocketContext&#41;<br />&#123;<br />    EnterCriticalSection&#40;&amp;g_CriticalSection&#41;;<br />  	if &#40;lpPerSocketContext&#41;<br />	&#123;<br />	    	closesocket&#40;lpPerSocketContext-&gt;Socket&#41;;<br />		CtxtListDeleteFrom&#40;lpPerSocketContext&#41;;<br />		lpPerSocketContext = NULL;<br />	&#125;<br />    else <br />    &#123;<br />        printf&#40;&quot;CloseClient&#58; lpPerSocketContext is NULL\n&quot;&#41;;<br />    &#125;<br />    LeaveCriticalSection&#40;&amp;g_CriticalSection&#41;;<br />    return;    <br />&#125; <br />PPER_SOCKET_CONTEXT CtxtAllocate&#40;SOCKET sd, IO_OPERATION ClientIO&#41;<br />&#123;<br />    PPER_SOCKET_CONTEXT lpPerSocCon;<br /><br />    lpPerSocCon = &#40;PPER_SOCKET_CONTEXT&#41;malloc&#40;sizeof&#40;PER_SOCKET_CONTEXT&#41;&#41;;<br />  	if &#40;lpPerSocCon&#41;<br />	&#123;<br />	   	lpPerSocCon-&gt;pIOContext = &#40;PPER_IO_CONTEXT&#41;malloc&#40;sizeof&#40;PER_IO_CONTEXT&#41;&#41;;<br />        if &#40;lpPerSocCon-&gt;pIOContext&#41; <br />		&#123;<br />		lpPerSocCon-&gt;Socket = sd;<br />            memset&#40;&amp;lpPerSocCon-&gt;pIOContext-&gt;Overlapped, 0, sizeof&#40;OVERLAPPED&#41;&#41;;<br />		lpPerSocCon-&gt;pIOContext-&gt;IOOperation = ClientIO;<br />		lpPerSocCon-&gt;pIOContext-&gt;nTotalBytes = 0;<br />		lpPerSocCon-&gt;pIOContext-&gt;nSentBytes  = 0;<br />		lpPerSocCon-&gt;pIOContext-&gt;wsabuf.buf  = lpPerSocCon-&gt;pIOContext-&gt;Buffer;<br />		lpPerSocCon-&gt;pIOContext-&gt;wsabuf.len  = MAX_BUFF_SIZE;<br />		&#125;<br />		else <br />		&#123;<br />		free&#40;lpPerSocCon&#41;;<br />		lpPerSocCon = NULL;<br />		&#125;<br />	&#125;<br />    return&#40;lpPerSocCon&#41;;<br />&#125;<br />VOID CtxtListAddTo &#40;PPER_SOCKET_CONTEXT lpPerSocketContext&#41;<br />&#123;<br />    EnterCriticalSection&#40;&amp;g_CriticalSection&#41;;<br />    g_CtxtList.AddTail&#40;lpPerSocketContext&#41;; <br />    LeaveCriticalSection&#40;&amp;g_CriticalSection&#41;;<br />    return;<br />&#125;<br />VOID CtxtListDeleteFrom&#40;PPER_SOCKET_CONTEXT lpPerSocketContext&#41;<br />&#123;<br />    EnterCriticalSection&#40;&amp;g_CriticalSection&#41;;<br />   	if &#40;lpPerSocketContext&#41;<br />	&#123;<br />      POSITION pos = g_CtxtList.Find&#40;lpPerSocketContext&#41;;<br />      if &#40;pos&#41;<br />      &#123;<br />        g_CtxtList.RemoveAt&#40;pos&#41;;<br />        if &#40;lpPerSocketContext-&gt;pIOContext&#41;<br />          free&#40;lpPerSocketContext-&gt;pIOContext&#41;;<br />        free&#40;lpPerSocketContext&#41;;<br />      &#125;<br />    &#125;<br />    LeaveCriticalSection&#40;&amp;g_CriticalSection&#41;;<br />    return;<br />&#125;<br />VOID CtxtListFree&#40;&#41;<br />&#123;<br />    EnterCriticalSection&#40;&amp;g_CriticalSection&#41;;<br />    while &#40;!g_CtxtList.IsEmpty&#40;&#41;&#41;<br />    &#123;<br />      PPER_SOCKET_CONTEXT lpPerSocketContext;<br /><br />      lpPerSocketContext = &#40;PPER_SOCKET_CONTEXT&#41;g_CtxtList.RemoveHead&#40;&#41;;<br />      if &#40;lpPerSocketContext-&gt;pIOContext&#41;<br />          free&#40;lpPerSocketContext-&gt;pIOContext&#41;;<br />      free&#40;lpPerSocketContext&#41;;<br />    &#125;<br />    LeaveCriticalSection&#40;&amp;g_CriticalSection&#41;;<br />    return;<br />&#125;<br />void CleanUp&#40;&#41;<br />&#123;<br />    // Cause worker threads to exit<br />    if &#40;g_hIOCP&#41;        <br />    &#123;<br />        for &#40;DWORD i = 0; i &lt; g_dwThreadCount; i++&#41;<br />            PostQueuedCompletionStatus&#40;g_hIOCP, 0, 0, NULL&#41;;<br />    &#125;<br />    //Make sure worker threads exits.<br />    if &#40;WAIT_OBJECT_0 != WaitForMultipleObjects&#40; g_dwThreadCount,  g_hThreads, TRUE, 1000&#41;&#41;<br />        printf&#40;&quot;WaitForMultipleObjects failed&#58; %d\n&quot;, GetLastError&#40;&#41;&#41;;<br />    else<br />        for &#40;DWORD i = 0; i &lt; g_dwThreadCount; i++&#41;<br />        &#123;<br />            if &#40;g_hThreads&#91;i&#93; != INVALID_HANDLE_VALUE&#41; CloseHandle&#40;g_hThreads&#91;i&#93;&#41;;<br />                g_hThreads&#91;i&#93; = INVALID_HANDLE_VALUE;<br />        &#125;<br />    CtxtListFree&#40;&#41;;<br />    if &#40;g_hIOCP&#41;    <br />    &#123;<br />        CloseHandle&#40;g_hIOCP&#41;;<br />        g_hIOCP = NULL;<br />    &#125;<br />    if &#40;g_sdListen != INVALID_SOCKET&#41; <br />    &#123;<br />        closesocket&#40;g_sdListen&#41;; <br />        g_sdListen = INVALID_SOCKET;<br />    &#125;<br />    DeleteCriticalSection&#40;&amp;g_CriticalSection&#41;;<br />    WSACleanup&#40;&#41;;<br />&#125;</code></pre><br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2002-12-13 15:29:54 by lingo12</div>
   </div>
   <div class="post" id="post-71317">
    <div class="subject"><a href="#post-71317">You guys are clueless!</a></div>
    <div class="body">Quite frankly, I don't think I need help from the two of you because I believe I already know more about IOCP and how it works than both of you put together! I asked very simple and clear questions and neither of you answered them! As for my 286 assembly, nither of you understand that the code I posted was a simplified version of a massive server I'm converting from WSAAsyncSelect &amp; WSAEventSelect and took me a few hours to put together for you because someone said they could help if I posted code here! My current server is too big and you would be lost if I posted it here! You don't understand that I just demonstrator one thing in this code, it just listens for incomming connections, DOESN'T accept them, DOESN'T send or receive either, just sets a listening socket, adds it to the IOCP and waits, when a connection comes, I'm supposed to get a MessageBox popup where I will add code to accept the connection etc. It is a simple server and if you guys knew anything about IOCP you would know what was happening, I made it clear in code and added titles to each section to make it more clear!<br /><br />Iblis<br /><br />If you actually read the code you would find I have your &quot;create the port&quot; code almost word for word in my tiny project! You would also see I add the listening socket to the IOCP with VERY similar code to yours, obviously just changing variable name etc. And you obviously don't undertand what my code is supposed to achieve (only listens), to demonstrate my problem, but you obviously have no clue what that problem is!<br /><br />lingo12<br /><br />I know the code you posted backwards, you have just made minor modifications to it but I have studied the origional complete echo server code in depth! If you think &quot;Iblis is right&quot;, then you are just as clueless as he is about my problems! My code doesn't need &quot;all the attributes from it&quot; because I have a very specific problem which is demonstrated in my &quot;286 assembly code&quot;! I don't need to &quot;manage my clients&quot; to demonstrate my problem! If you think I have to write a whole complete IOCP server app to demonstrate my problem then you've missed it already!<br /><br />For crying out load guys, I have a specific problem, I am 100000% knowledgable on WinSock and how it works, I don't have a WinSock specific problem, I have a WinSock interfacing with IOCP problem, I don't need to manage the clients, send and receive etc. to demonstrate my problem! Just assemble the code, it sits and waits for a connection, then use another WinSock app and connect, the client connects to it, you will see, but in my server's IOCP worker thread, I'm supposed to get a messagebox saying something like &quot;IOCP have received a message from outerspace!&quot;, that just symbolises that IOCP has received a message, any message, it doesn't matter, but WinSock never sends a message to IOCP with the PostQueuedCompletionStatus() API. I send 3 test messages to the IOCP in the beginning of the code to test that the IOCP is setup ...</div>
    <div class="meta">Posted on 2002-12-17 00:12:20 by SubEvil</div>
   </div>
   <div class="post" id="post-71336">
    <div class="subject"><a href="#post-71336">Questions regarding IO Completion Ports and WinSock</a></div>
    <div class="body">SubEvil,<br /><br />I didn't want to offend you, and your emotions are surprise for me<br />I just expected translation of working example from C to ASM<br /><br />&quot;I have studied the origional complete echo server code in depth! &quot;<br /><br />Would you be so kind to explain how your problem is solved<br />by the example?<br />Which sockets are associated with an IOCP, listen or accepted?<br />What about notification you looking for if you didn't initialize any events?<br />What means &quot;overlapped I/O completion&quot;?<br />What about the contents of your overlapped structures of notification packets for every socket?<br />What about the data in the linked list?<br /><br />I can continue..<br /><br />When an overlapped call is made, a pointer to an overlapped structure is passed as a parameter. GetQueuedCompletionStatus will return the same pointer when the operation completes succesfuly.<br />Where is your <strong>overlapped</strong> call? <br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2002-12-17 02:36:00 by lingo12</div>
   </div>
   <div class="post" id="post-71348">
    <div class="subject"><a href="#post-71348">Questions regarding IO Completion Ports and WinSock</a></div>
    <div class="body">My appologies Lingo12 ... I know you're trying to help and thanx! I must appologize for my emotions too, I'm not very good at taking criticism ... sorry ...<br /><br />From the questions you are asking me ... I can tell I've still got some things to understand about IOCP and perhaps I'm asking the wrong questions myself! I will try to answer your questions as best I can ... then you can comment on my answers and explain things to me! You see I've only read example code ... I haven't found any good tutorials on WinSock IOCP ... not even from MSDN ... mostly they are just general IOCP tutorials!<br /><br /><div class="quote">Would you be so kind to explain how your problem is solved by the example?</div> <br />The example doesn't add the Listening socket to the IOCP. This is a question I have already asked you ... Does the function of a listening socket get performed by the IOCP?<br /><br /><div class="quote">Which sockets are associated with an IOCP, listen or accepted?</div><br />Again, something I have asked you guys to answer, my answer would be ... accepted sockets get added by your example (Not mine, is that wrong?) I have tried this method already without success!<br /><br /><div class="quote">What about notification you looking for if you didn't initialize any events?</div><br />What exactly do you mean by this? This could be what is missing in my understanding of IOCP! Why do I need to initialize events? Do you mean with the CreateEvent() calls? What type of events are you talking about?<br /><br /><div class="quote">What means &quot;overlapped I/O completion&quot;?</div><br />Basically, multiple IO calls get processed together and the app is notified when they have completed!<br /><br /><div class="quote">What about the contents of your overlapped structures of notification packets for every socket?</div><br />I will solve this by having a dynamic array of connected sockets, I will use the same methods I've used before with my other server types.<br /><br /><div class="quote">What about the data in the linked list?</div> <br />What data? The socket specific data will be stored in my dynamic arrays, eg. Mutexes, Sockets States, client specific data etc. Don't worry about this, this is the least of my problems!<br /><br /><div class="quote">Where is your overlapped call? </div><br />Now this could be the key to my IOCP understanding!<br />Let me ask YOU what calls perform overlapped operations? Only WSASend() &amp; WSARecv()? What about AcceptEx()? Or just Accept()?<br />Maybe I have IOCP calls in my code! That would mean I never get any IOCP messages! Perhaps my understanding of what IOCP is used for with WinSock is flawed?<br /><br />Do you have a good WinSock IOCP TUTORIAL ... not C example code for me ??? I have plenty of example code!<br /><br />Thanx</div>
    <div class="meta">Posted on 2002-12-17 04:33:54 by SubEvil</div>
   </div>
   <div class="post" id="post-71362">
    <div class="subject"><a href="#post-71362">Questions regarding IO Completion Ports and WinSock</a></div>
    <div class="body">SubEvil, if I was not trying to help you then I would not have even bothered posting here.    Teaching you the basics of completion ports is not my job nor do I owe you anything, so if you want to get angry at those trying to help you then I'll be happy to stop.<br /><br /><br />Anyways, regarding the listening socket,  You *can* have it send connects down the port but you don't have to, and  since you are new to this, to keep things simple you should just use listen() and accept() and then update the IOCP with the connected socket.  If performance is what you're after, you won't lose any by doing this.  Just do all your listening in another thread.<br /><br />The extended OVERLAPPED structure contains &quot;per socket data&quot; meaning that anything you wish to associate with your socket, i.e. buffers, data size, etc. you need to 'extend' the overlapped structure by adding this data to the end of it.  This includes IO operation type.<br /><br /><div class="quote"><strong>I have downloaded and studied about 10 examples of this type of server implemented in various ways in C/C++ code</div><br /><br />I don't think you studied them very well.  You should go back and look at them.  Everything we are describing is most probably in there.  Take your time and read them carefully.  Look how the examples make use of the overlapped structure.   I think things will seem clearer to you once you do this.<br /><br /><br />As a side note, I don't know what sort of miraculous server you hope to have with this.  Just because the IOCP model claims the capability of handling many connections doesn't mean it necessarily will, and I think that if you ever finish this program you will be disappointed to find out that it doesn't do what you expect.  There are a lot more issues to address than just what socket IO model to use.  You really need to buy a book on this.  It will help you immensely.</div>
    <div class="meta">Posted on 2002-12-17 05:27:22 by iblis</div>
   </div>
   <div class="post" id="post-71532">
    <div class="subject"><a href="#post-71532">Questions regarding IO Completion Ports and WinSock</a></div>
    <div class="body">SubEvil,<br /><br />Here is the main thread and the working thread usage<br /><br />Role of the main thread (human resources):<br /><br />1. Create empty IOCP(the system) and  working thread(supervisor)<br />   Why?<br />   Because if we have  workers, someone must supervise them (see later)<br /><br />2. Create new workers (accepted sockets) with WSAAccept() or AcceptEx()<br />   with qualifications inherited from their father(listen socket)<br /><br />   Why workers?<br />   Because they do the job(receive and send data from/to clients)<br />   How?<br />   Asynchronously-&gt;hence, we must use overlapped structure because of that<br /><br />   Where to keep overlapped structure and other info about every worker?<br />   In his personal info file (his personal extended  overlapped structure).<br /><br />   Why extended  overlapped structure?<br />   Because it contents a lot of bureaucracy:<br />    - his overlapped structure<br />    - his name (accepted socket handle)<br />    - his current job (status flag);  for instance:<br />      1 - means I'm reading data now, 2 - means I'm writing now, etc.<br />    - how many bytes must be read/write<br />    - how many bytes are read<br />    - etc.<br />   You (the programmer) can extend the bureaucracy (extended overlapped structure)<br />   with additional records if you or the supervisor (working thread) will need it later!<br /><br />   Who changes the status flag? For the first time after creation,<br />   the main thread (human resources), next,<br />   after every particularly finished job the supervisor(working thread)<br /><br />   Who needs  a  bureaucracy? Mainly the supervisor(working thread), see later<br /> <br />3. Associate them (new workers = accepted sockets) with IOCP (the system)<br /><br />   How? <br />   - Create and fill new personal info file about  new worker (his personal<br />     extended overlapped structure).<br />   - update his current job (status flag) to 1 (for instance: 1 - means I'm reading data now)<br />     and post initial asynchronous receive on this worker  (accepted socket) with WSARecv()<br />   - Save the pointer of his file anywhere in memory for easy retrieving later (linked list),<br />     and send this pointer to the IOCP (the system) with his name (accepted socket handle) as<br />     parameters, via CreateIoCompletionPort() API <br /><br />4. Jmp again to 2<br /><br /><br />Role of working thread (supervisor):<br /><br />     Worker thread  (supervisor) handles all I/O requests on any socket handle added to the IOCP<br />     by main thread, i.e. here we have one supervisor(working thread) and one or more<br />     workers (accepted sockets)<br /><br />A.   Ask the system (IOCP) is there any particularly finished job via <br />     GetQueuedCompletionStatus() API<br />     If there is no completion packet (particularly finished job info) queued, the function waits<br />     for a pending I/O operation associated with the completion port to complete.<br /><br />B.   The system (IOCP) returns the pointer of any worker's file<br />     (i.e. pointer to his personal extended  overlapped structure)  with particularly finished job,<br />     and number of bytes transferred during an I/O operation that has completed.<br /><br />C.   Determines what next action to take (WSARecv,WSASend or/and other server routine),<br />     delegates it to this worker (accepted socket) and updates  his personal info file<br />     (i.e. his extended  overlapped structure) accordingly.<br /><br />D.   Jmp again to A<br /><br /><br />Regards,<br />Lingo</div>
    <div class="meta">Posted on 2002-12-17 22:50:59 by lingo12</div>
   </div>
   <div class="post" id="post-146526">
    <div class="subject"><a href="#post-146526">Questions regarding IO Completion Ports and WinSock</a></div>
    <div class="body">lingo12, I have just tried to implement your code...<br />I get 10045 on WSARecv - odd?</div>
    <div class="meta">Posted on 2004-07-21 06:51:58 by Homer</div>
   </div>
  </div>
 </body>
</html>