<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Structures 101 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=9569" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=9569">Structures 101</a></p>
   <div class="post" id="post-70904">
    <div class="subject"><a href="#post-70904">Structures 101</a></div>
    <div class="body">Here is an ancient converstation i had in the year 2000...  However, it is full of good detail to get your head on straight when wondering how to use things like structures, and memory pointers in MASM.<br /><br /><pre><code>Dont get hung up on structures.. they are not a hassle at all...<br /><br />The point of structures is yes, to localize alot of data under one premise<br />&#40;or tag name&#41;. However, they are still a bit abstract from ASM programming,<br />which is why i suspect you have been having problems in the past. They are<br />simply a template to help organize data, but they are NOT data in <br />themselves. I better go to examples at this point&#58;<br /><br />I could say.. <br /><br />Point1_x  dd 0<br />Point1_y  dd 0<br />Point2_x  dd 0<br />Point2_y  dd 0 etc. etc.<br /><br /><br />And in using them i would have to reference each member directly&#58;<br /><br />mov eax, Point2_y<br /><br />or<br /><br />lea ebx, Point1_x<br />mov eax, &#91;ebx + 12&#93;  ; 12'th byte after the first as defined above<br /><br /><br />This is ok, but it would be easier to use data if they are grouped together as <br />one type of data&#58;<br /><br />My_Point struc<br />   x   dd  ?<br />   y   dd  ?<br />My_Point ends<br /><br />and in .data<br />  <br />  Point1  My_Point  &lt;0,0&gt;  ; initialize x,y to 0,0<br />  Point2  My_Point  &lt;2,0&gt;  ; initialize x,y to 2,0<br /><br />or in .data?<br />   <br />  Point3  My_Point &lt;&gt;  ; uninitialized data <br />  Point4  My_Point &lt;&gt;<br /><br /><br />The in the data segments, the stucture is used as a template to allocate the <br />amount of memory &#40;dd's&#41; in the order they appear in the template. This<br />is why i say stucts are NOT data in themselves. Now, if i were to <br />disassemble the data segment of this one or the pervious above, they <br />data would be in the same order &#40;point1's x data, point1's y data, <br />point2's x data, point2's y data&#41;. The difference is by simply telling <br />MASM this will by a structured define, you can skip the redundancy of <br />typing it all out in order.<br /><br />The code to use these are now&#58;<br /><br />  mov eax, Point2.y  <br /><br />  ; y is the structure member that masm used to determin the offset<br />  ; this is the same as<br />  ;    lea ebx, Point2<br />  ;    mov eax, &#91;ebx + 4&#93;  ; 4 bytes after the first &#40;y data&#41;<br /><br /><br />One of the benifits is the fact the data HAS to be grouped together as prescibed <br />in the structure template.. my origional example of separated data IS <br />grouped together, but doesnt has to be. It could be a random like such&#58;<br /><br />  Point1_x dd 0<br />  MyFlag   dd 0<br />  Point1_y dd 0<br />  Point2_x dd 0<br />  IsOn     dd 0<br />  Point2_y dd 0<br /><br />If i were asked to have the address to a point in this setup, you couldnt do it, <br />because MyFlag is inbetween Point1_x and Point1_y&#58;<br /><br />  invoke SomeFunct, addr Point1_x<br /><br />will be used as&#58;<br /><br />  mov ebx, Point1_x  ; base address of a point<br />  mov eax, &#91;ebx&#93;     ; get the x data<br />  mov eax, &#91;ebx + 4&#93; ; get the y data &#40;assumed 4 bytes after the base&#41;<br /><br />The problem here is, 4 bytes after the first is MyFlag!!!! Using structures <br />insures this problem is always taken care of &#40;assuming the structure is <br />defined in the correct order&#41;.<br /><br />Taking this a step further, you can also NEST structures to build more <br />complex bounded data&#58;<br /><br />My_Circle sturct<br />  Center  My_Point &lt;&gt;<br />  Radius  dd       ?<br />My_Circle ends<br /><br />Colored_Circle struct<br />  Circle  My_Circle &lt;&gt;<br />  Color   dd        ?<br />Colored_Circle ends<br /><br />By simple defining in .data? <br /><br />  RGB_Circle  Colored_Circle  &lt;&gt;<br /><br />i have allocated memory in the data segment in this order&#58;<br /><br />RGB_Circle&#58;  4 bytes, Referenced as &#40;this&#41;.Circle.Center.x<br />            +4 bytes, Referenced as &#40;this&#41;.Circle.Center.y<br />            +4 bytes, Referenced as &#40;this&#41;.Circle.Raduis<br />            +4 bytes, Referenced as &#40;this&#41;.Color<br /><br />NOTE&#58; &#40;this&#41; refers to the name of the defined data for 'this' structure type,<br />in this case it would be RGB_Circle.Circle.Center.x<br /><br />ALSO NOTE&#58; the 'SIZEOF Colored_Circle' command would return the above<br />evaluation = 16 bytes.<br /><br /><br />As a final thought, the use of stuctures are also advantageous when dealin with <br />them as pointer, by simply passing a simple 4 byte pointer, it can be <br />used to directly reference &#40;in the above case&#41; 16 bytes of data. &#40;this <br />speeds up your function calling, because less is being pushed on the <br />stack&#41;.<br /><br />; my fuction used a colored circle...<br />My_Fuction proc lpColoredCirlce&#58;DWORD<br /> ...<br /> mov ebx, lpColoredCircle<br /> mov eax, &#40;Colored_Circle PTR &#91;ebx&#93;&#41;.Circle.Center.x   ;get x<br /> mov edx, &#40;Colored_Circle PTR &#91;ebx&#93;&#41;.Circle.Center.y   ;get y<br /> mov esi, &#40;Colored_Circle PTR &#91;ebx&#93;&#41;.Radius            ;get Rad<br /> mov edi, &#40;Colored_Circle PTR &#91;ebx&#93;&#41;.Color             ;get Color<br /><br /> add edi, 20h<br /> mov &#40;Colored_Circle PTR &#91;ebx&#93;&#41;.Color, edi             ;set Color<br /> ...<br /><br />ret<br />My_Function endp<br /><br /><br />If your thinking there is still alot of keystrokes <br />involved here a simpler trick is to use the ASSUME directive on a <br />register as follows&#58;<br /><br />; my fuction used a colored circle...<br />My_Fuction proc lpColoredCirlce&#58;DWORD<br /> ...<br /> mov ebx, lpColoredCircle<br /> ASSUME ebx&#58;PTR Colored_Circle  ; saves redundant typing<br /> mov eax, &#91;ebx&#93;.Circle.Center.x   ;get x<br /> mov edx, &#91;ebx&#93;.Circle.Center.y   ;get y<br /> mov esi, &#91;ebx&#93;.Radius            ;get Rad<br /> mov edi, &#91;ebx&#93;.Color             ;get Color<br /><br /> add edi, 20h<br /> mov &#91;ebx&#93;.Color, edi             ;set Color<br /> ...<br /> ASSUME EBX&#58;NOTHING  ; unassume ebx<br />ret<br />My_Function endp<br /><br /><br />Well there is my crash-course tutorial on Structures , im only a modest <br />programmer my self, so with the volume of info i tossed at you its <br />possible i overlooked some minor detail, but in essence this is it.. <br />Hope it helps you out...<br /><br />NaN<br /><br />&#40;&#40; REPLY BY ERNIE &#41;&#41;<br /><br />Everything Nan said he said well and true. However, a few thoughts <br />on using assume.<br /><br />We all know, when you ASSUME something, you make an ASS of U and ME.<br />Trite, but still true.<br /><br />If you assume a register, then forget to unassume it, you can get <br />strange results. Or, the assume could be so far from the line that <br />needs it the meaning is left unclear &#40;to the human reading the code&#41;. <br />I'm not a big fan of weird &quot;action at a distance&quot; operators like this.<br /><br />I am a devoted user of structures, they are just so handy. I used to <br />use the syntax Nan stated, until I found a slightly more compace &#40;but <br />just as readable&#41; form MASM accepts&#58;<br /><br /> mov ebx, lpColoredCircle<br /> mov eax, &#40;Colored_Circle PTR &#91;ebx&#93;&#41;.Circle.Center.x   ;get x<br /> mov edx, &#40;Colored_Circle PTR &#91;ebx&#93;&#41;.Circle.Center.y   ;get y<br /> mov esi, &#40;Colored_Circle PTR &#91;ebx&#93;&#41;.Radius            ;get Rad<br /> mov edi, &#40;Colored_Circle PTR &#91;ebx&#93;&#41;.Color             ;get Color<br /><br />may also be stated as&#58;<br /><br /> mov ebx, lpColoredCircle<br /> mov eax, &#91;ebx&#93;.Colored_Circle.Circle.Center.x   ;get x<br /> mov edx, &#91;ebx&#93;.Colored_Circle.Circle.Center.y   ;get y<br /> mov esi, &#91;ebx&#93;.Colored_Circle.Radius            ;get Rad<br /> mov edi, &#91;ebx&#93;.Colored_Circle.Color             ;get Color<br /><br />Ernie<br /><br />&#40;&#40; REPLY BY MIRNO &#41;&#41;<br /><br />The idea of a structure is purely for us the programmer.<br />All the computer sees is data, for example&#58;<br /><br />MyStruct STRUCT<br />  a DWORD ?<br />  b BYTE  ?<br />  c WORD  ?<br />  d BYTE 3 DUP &#40;?&#41;<br />MyStruct ENDS<br /><br />As far as memory allocation is concerned this is 10 bytes, nothing else. To the <br />assembler, it is also a method of formating accesses to that data, and <br />it is possible to apply that formating to any piece of memory.<br /><br />This allows the following code&#58;<br /><br />FourLetterWord STRUCT<br />  FirstLetter    BYTE ?<br />  SecondLetter   BYTE ?<br />  ThirdLetter    BYTE ?<br />  FourthLetter   BYTE ?<br />  NullTerminator BYTE ?<br />FourLetterWord ENDS<br /><br />.data<br /> Word1 db &quot;spam&quot;,0<br /> Word2 db &quot;clam&quot;,0<br /><br />.code<br />start&#58;<br />  mov edx, ADDR Word1<br />  mov &#40;FourLetterWord PTR &#91;edx&#93;&#41;.FirstLetter, 'c'<br /><br />  invoke ExitProcess, 0<br />end start<br /><br />Although we declared Word1 as a string of bytes, we can apply the formating of <br />the FourLetterWord structure to it.<br /><br />So in the case of GlobalAlloc, you need to do something like&#58;<br /><br />  invoke GlobalAlloc, ACCESS_TYPE, SIZEOF MyStruct * number_needed<br /><br /><br />This will create enough data to apply the format of MyStruct without causing <br />errors.<br /><br />Mirno<br /><br />&#40;&#40; REPLY BY NaN &#41;&#41;<br /><br />Exactly, your simply allocating a bunch of bytes.. but if you keep <br />control of all your allocated bytes of data &#40;ie, add proper offsets to <br />your global data pointer&#41;, then you can use the above methods with <br />pointers as Ernie outlined.<br /><br />Structures are simply masks or templates to make your memory 'look' <br />organized... as Mirno demonstrates &#40;good example BTW&#41;.<br /><br />I could still allocate 5 bytes of heap memory, and use my above <br />structure &#40;size 16 bytes templated&#41; to reference it! The catch is, i <br />would only be able to access&#58;<br /><br />  mov ebx, GlobalDataPointer<br />  mov eax, &#40;Colored_Circle PTR &#91;ebx&#93;&#41;.Cricle.Center.x <br /><br />Because this is the first 4 bytes templated by my structure. To try to go to 'y' <br />would violate the heap space alocated, since in my example i have only <br />allocated 5 bytes in all. This is why Mirno suggests 'N * sizeof <br />Colored_Circle' where N is Integers &gt; 1. That way you will always have <br />just enough data, to imply an array of N Colored_Cirlce structures, <br />and know you have enough data set asside for each memeber!<br /><br />NaN</code></pre><br /><br />As well, something not mentioned is that stuctures CAN inherit other structures as well as include other structures... as follows:<br /><br /><pre><code>Struct_A  STRUC<br />  Var1  DD ?<br />  Var2  DD ?<br />Struct_A ENDS<br /><br />Struct_B  STRUC<br />  Struct_A &lt;&gt;<br />  Var_A DW ?<br />Struct_B ENDS<br /><br />Struct_C STRUC<br />  My_B_Lable   Struct_B &lt;&gt;<br />  Var_B db ?<br />Struct_C ENDS</code></pre><br /><br />Structure A is nothing new.  Structure B INHERITS A and adds a third Var_A WORD as well.  This means Stuct B has 10 bytes! (Var1, Var2, Var_A :: 4, 4, 2)<br /><br />Structure C includes Structure B as you are probably use to.  However since A is inherited into B, there is no 'inbetween' label to access Var1 and Var2:<br /><br />lea edx, Stuct_A_in_Memory<br />mov eax, .Struct_A.Var1<br />mov eax, .Struct_A.Var2<br /><br />lea edx, Stuct_B_in_Memory<br /><strong>mov eax, .Struct_B.Var1<br />mov eax, .Struct_B.Var2</strong><br />mov ax, .Struct_B.Var_A<br /><br />lea edx, Stuct_C_in_Memory<br />mov eax, .<strong>My_B_Lable.Struct_C.Var1<br />mov eax, .My_B_Lable.Struct_C.Var2<br />mov ax, .My_B_Lable.Struct_C.Var_A</strong><br />mov al, .Struc_C.Var_B<br /><br />Hope this helps!!<br />:alright:<br />NaN</div>
    <div class="meta">Posted on 2002-12-13 19:11:26 by NaN</div>
   </div>
   <div class="post" id="post-71094">
    <div class="subject"><a href="#post-71094">Documentation::Structures 101</a></div>
    <div class="body">Another Reciently learned action you can take with STRUCTURES is by not useing a memory pointer at all.  Its a rare case that you need to do this, however i found one such example working with COM objects:<br /><pre><code><br />MyStruct  STRUC<br />   Field_a   dd   ?<br />   Field_b   db   ?<br />   Field_c   dw   ?<br />MyStruct   ENDS<br /><br />.const<br />.data<br />.data?<br />.code<br /><br />mov eax, MyStruct.Field_a<br />&lt;&lt; With no memory at all, eax == 0&gt;&gt;<br /><br />mov eax, MyStruct.Field_b<br />&lt;&lt; With no memory at all, eax == 4&gt;&gt;<br /><br />mov eax, MyStruct.Field_C<br />&lt;&lt; With no memory at all, eax == 5&gt;&gt;<br /></code></pre><br />:alright:<br />:enjoy:<br />:nAn:</div>
    <div class="meta">Posted on 2002-12-15 10:37:37 by NaN</div>
   </div>
  </div>
 </body>
</html>