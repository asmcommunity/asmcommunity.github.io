<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>BreakApart Strings - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=5475" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=5475">BreakApart Strings</a></p>
   <div class="post" id="post-38870">
    <div class="subject"><a href="#post-38870">BreakApart Strings</a></div>
    <div class="body">Hello Everybody<br /><br />Do anyone know the code for separating this string.  I got it in Buffer0, I don't want the * , * in the new buffers but the * , * is the key to doing the separating...<br /><br />Buffer0 got ....... Smith,2207<br />Buffer1 to be ... Smith<br />Buffer2 to be ... 2207<br /><br />I got the code for it somewhere and have done it before but it will take a month to find it and i don't remember how to do it... Believe me i founded a lot of other little things while working today but i can't find or remember this for the life of me.....I would be very grateful for the help.<br /><br />Thanks in advance<br /><br />.............................................................................<br />PS: Could someone tell me what Recursive mean. My guest is not realizing fully on the API to compete it mission.  I been looking into <strong>Qweerdy</strong>  *Enum File* and it is very educational, not to hard to follow but not that easy either if you don't know all the meanings.</div>
    <div class="meta">Posted on 2002-05-19 01:39:24 by cmax</div>
   </div>
   <div class="post" id="post-38896">
    <div class="subject"><a href="#post-38896">BreakApart Strings</a></div>
    <div class="body">'Recursive' is when a function calls itself. When you do this, you have to be very careful about how the data is passed, and at exactly what point you call the function. I won't explain too much more than that right now, i might not explain it very simply, i might confuse you more :)</div>
    <div class="meta">Posted on 2002-05-19 07:33:44 by sluggy</div>
   </div>
   <div class="post" id="post-38899">
    <div class="subject"><a href="#post-38899">BreakApart Strings</a></div>
    <div class="body">cmax,<br /><br />Without knowing exactly what you are doing with the seperated components of the string, the simplest way would be to allocate a number of buffers big enough for each string, then loop through the source string and jump to the next loop when you find the seperator.<br /><br />This is a static approach to the problem. If you need a more dynamic approach you would need to allocate enough memory for an array and loop through the array one DWORD at a time.<br /><br />Recursion means when a procedure calls itself one or more times. It can be a dangerous style of coding unless you undersatand what you are doing but the basics are you must have some method of differentiating what is passed to the same procedure so that you don't get an infinite recursion. This will cause a stack fault when the stack limit is exhausted.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-05-19 08:29:49 by hutch--</div>
   </div>
   <div class="post" id="post-38905">
    <div class="subject"><a href="#post-38905">BreakApart Strings</a></div>
    <div class="body">Thank sluggy, that a perfect explantion.  Now i know.<br />Thanks Hutch, I got the full ideal of what to do, I don't need to find my old file now. Old Qweerdy, took on the challenge and seem to really have it together with his EMUM File, I did all kinds of stuff with-it just to see if it would miss and it did not, Great Work.  It's the perfect example.<br /><br />Hutch, I know i must be getting preety good at it now because i get board that because i can remember things by hard or can't think of a solution with in a hour or two.... it use to take weeks...Now some time i just run through things just by remembering what was said on posts or the M32.lib , and it usually comes out perfect.</div>
    <div class="meta">Posted on 2002-05-19 10:52:18 by cmax</div>
   </div>
   <div class="post" id="post-38906">
    <div class="subject"><a href="#post-38906">BreakApart Strings</a></div>
    <div class="body">cmax:<br /><br />Nice to know someone benefitted from my code! I must say the original code has been updated quite a bit since I posted it, but I don't think it became any easier to read.<br /><br />About your other question, things would be a lot easier if it is OK to change the data in buffer0. Also, I'm assuming you want NULL-terminated strings. In that case this would work:<br /><br /><pre><code><br />mov esi,offset Buffer0<br />StartLoop&#58;<br />mov edx,esi<br />@@&#58;<br />mov al,&#91;esi&#93;<br />inc esi<br />cmp al,0<br />je EndLoop<br />cmp al,&quot;,&quot;<br />jne @B<br />mov &#91;esi-1&#93;,0<br />; -----------<br />; Here edx holds a pointer to one of the strings<br />; -----------<br />cmp byte ptr &#91;esi&#93;,0<br />jne StartLoop<br />EndLoop&#58;<br />; Make sure to process the last item here! Pointer in edx.<br />; You don't have to worry about this if your string has a &quot;,&quot; at the end.<br /><br /></code></pre></div>
    <div class="meta">Posted on 2002-05-19 11:09:49 by Qweerdy</div>
   </div>
   <div class="post" id="post-38910">
    <div class="subject"><a href="#post-38910">BreakApart Strings</a></div>
    <div class="body">I ripped your EnumFiles apart, i think i took out call myself... and i call pat *BUST-IT-ALL-UP*<br /><br />I like it because when it do shelloperation and plain delete file that Window window thing comes in sometimes and show to the users what is being deleted...You know that progress bar or something...With your file i put in 200 or more files that i want to delete and GUEST WHAT...It delete it with no window flags as i go to do other things on the computer with no Progress Bar and no  other visual affect on the system as it dose its job....I Love That.  I got it do all that i want to get rid of but the cookies, but that seems to be hell as it is....<br /><br />Temporary Internet Files i have to figure out a better way.  Thsoe sub folders change if just founded that out...<br /><br />I think i will end up going with the your full versions, with your permit latter,but by nature i always break things down, that how i learned to read and understand ASM I do this always...Here what i did so far....<br /><br /><br />; (c) 2002 by Qweerdy. Beta release.<br />;<br />.386<br />.model flat,stdcall<br />option casemap:none<br /><br /><br />   include \masm32\include\windows.inc<br />    include \masm32\include\user32.inc<br />    include \masm32\include\kernel32.inc<br />    include \masm32\include\masm32.inc<br /><br />    includelib \masm32\lib\user32.lib<br />    includelib \masm32\lib\kernel32.lib<br />    includelib \masm32\lib\masm32.lib<br /><br /><br /><br />WinMain     proto :DWORD,:DWORD,:DWORD,:DWORD<br />Callback    proto :DWORD,:DWORD,:DWORD<br />EnumFiles   proto :DWORD,:DWORD,:DWORD,:DWORD<br /><br />.const<br />PatternBufferSize equ 2 * MAX_PATH          ; Size of buffer for full filenames. Must be large enough.<br /><br />.const<br />fRecursive 		equ 1<br />fDirBefore 		equ 2<br />fDirAfter 		equ 4<br />fParamIsLength               equ 8<br /><br /><br /><br />.data<br />   sBustIEw db &quot;C:\WINDOWS\Temporary Internet Files\Content.IE5\wtctktw7\&quot;,0<br />   sBustIEu db &quot;C:\WINDOWS\Temporary Internet Files\Content.IE5\us04oty5\&quot;,0<br />   sBustIEg db &quot;C:\WINDOWS\Temporary Internet Files\Content.IE5\gdef8dwf\&quot;,0<br />   sBustIE0 db &quot;C:\WINDOWS\Temporary Internet Files\Content.IE5\0x6zc5ar\&quot;,0<br /><br />   sBustIEALL db &quot;C:\WINDOWS\Temporary Internet Files\&quot;,0<br /><br />   sBustHISTORY1 db &quot;C:\WINDOWS\History\History.ie5\&quot;,0<br /><br /><br />   sBustRECENT db &quot;C:\WINDOWS\Recent\&quot;,0<br />   sBustTEMP db   &quot;C:\WINDOWS\Temp\&quot;,0<br /><br /><br />   hFile dd ?<br />   fn db &quot;C:\Windows\Desktop\dirtest.txt&quot;,0<br />   szError db &quot;Oops, an error occured!&quot;,0<br />   crlf db 13,10<br />   tmp dd ?<br />   <br />.code<br /><br />; ---------------------------------------------------------------------------<br /><br />start:<br />	<br />	invoke EnumFiles,addr sBustIEw,fRecursive+fDirBefore+fParamIsLength,Callback,0<br />	invoke EnumFiles,addr sBustIEu,fRecursive+fDirBefore+fParamIsLength,Callback,0<br />	invoke EnumFiles,addr sBustIEg,fRecursive+fDirBefore+fParamIsLength,Callback,0<br />	invoke EnumFiles,addr sBustIE0,fRecursive+fDirBefore+fParamIsLength,Callback,0<br /><br />	invoke EnumFiles,addr sBustRECENT,fRecursive+fDirBefore+fParamIsLength,Callback,0<br />	invoke EnumFiles,addr sBustTEMP,fRecursive+fDirBefore+fParamIsLength,Callback,0<br /><br /><br />	invoke ExitProcess,0<br /><br /><br /><br />; ..............................................  <br />; ..............................................  <br />; ..............................................  <br />; ..............................................  <br />; ..............................................  <br />; ..............................................  <br />; ..............................................  <br />; ..............................................  <br /><br />Callback proc pPattern:dword,pfd:dword,Param:dword<br /><br />local bw:dword<br /><br />	invoke StrLen,pPattern	; This code returns the complete path<br />	mov ebx,eax<br />	mov esi,pPattern<br /><br /><br /> PUSH   pPattern<br /> CALL   DeleteFileA<br /><br /><br />	;;invoke MessageBox,0,pPattern,0,0<br /><br />;	invoke WriteFile,hFile,esi,ebx,addr bw,0<br />;	invoke WriteFile,hFile,addr crlf,2,addr bw,0<br />	ret<br /><br />Callback endp<br />; ..............................................  <br />; ..............................................  <br />; ..............................................  <br />; ..............................................  <br />; ..............................................  <br />; ..............................................  <br />; ..............................................  <br />; ..............................................  <br /><br /><br /><br /><br /><br /><br /><br /><br />EnumFiles proc pFileSpec:dword,Flags:dword,pCallback:dword,Param:dword<br /><br />local pPattern:dword<br />local pPatternFn:dword<br />local NoPath:byte<br />local hff:dword<br />local fd:WIN32_FIND_DATA<br />local pLocalFn:dword<br />local lLocalFn:dword<br /><br />; ..............................................  Allocate room for the search pattern<br /><br />PUSH PatternBufferSize<br />PUSH GMEM_FIXED<br />CALL GlobalAlloc<br /><br />	.if eax==0<br />		ret<br />	.endif<br />	mov pPattern,eax<br />	<br />; ..............................................  Get the path portion of the search pattern<br />	mov esi,pFileSpec<br />@@:<br />	mov al,<br />	inc esi<br />	cmp al,&quot;\&quot;<br />	je HasPath<br />	cmp al,&quot;/&quot;<br />	je HasPath<br />	cmp al,0<br />	jne @B<br />; ..............................................<br />HasNoPath:<br />	mov NoPath,1<br />	invoke GetCurrentDirectory,PatternBufferSize,pPattern<br />	or eax,eax<br />	jz Error<br />	cmp eax,PatternBufferSize-1<br />	jg Error<br />	jmp CompletePath<br />; ..............................................<br />; ..............................................<br />; ..............................................<br />HasPath:<br />	mov NoPath,0<br />    push esi<br />    push edi<br /><br />    xor ecx, ecx    ; zero counter<br />    mov esi, pFileSpec<br />    mov edi, pPattern<br /><br />  @@:<br />    mov al,    ; read byte from address in esi<br />    inc esi<br />    inc ecx         ; increment counter<br />    cmp al, 0       ; test for zero<br />    je gfpOut       ; exit loop on zero<br />    cmp al, &quot;\&quot;     ; test for &quot;\&quot;<br />    jne nxt1        ; jump over if not<br />    mov edx, ecx    ; store counter in ecx = last &quot;\&quot; offset in ecx<br />  nxt1:<br />    mov , al   ; write byte to address in edi<br />    inc edi<br />    jmp @B<br />    <br />  gfpOut:<br />    add edx, pPattern    ; add destination address to offset of last &quot;\&quot;<br />    mov , al               ; write terminator to destination<br /><br />    pop edi<br />    pop esi<br />; ..............................................<br />; ..............................................<br />; ..............................................<br />CompletePath:<br /><br />	invoke StrLen,pPattern<br />	test Flags,fParamIsLength<br />	jz @F<br />		mov Param,eax<br />		and Flags,(not fParamIsLength)<br />	@@:<br />	push eax ; Length of Path is pushed here &lt;----<br />	add eax,pPattern<br />	cmp byte ptr ,&quot;\&quot;<br />	je PathDone<br />	cmp byte ptr ,&quot;/&quot;<br />	je PathDone<br />	mov word ptr ,005ch ; db &quot;\&quot;,0<br />	inc eax<br />PathDone:<br />	mov pPatternFn,eax<br />	<br />; ..............................................  Get the filename portion of the pattern<br />	invoke StrLen,pFileSpec<br />	pop ebx ; And popped here &lt;----<br />	mov edi,pPatternFn<br />	.if NoPath<br />		mov esi,pFileSpec<br />		.if byte ptr ==0<br />			mov dword ptr ,002a2e2ah ; db &quot;*.*&quot;,0<br />		.else<br />			mov esi,pFileSpec<br />			mov ecx,eax<br />			inc ecx<br />			rep movsb<br />		.endif<br />	.else<br />		.if eax==ebx ; If there was no filename<br />			mov dword ptr ,002a2e2ah ; db &quot;*.*&quot;,0<br />		.endif<br />	.endif<br />	<br />; ..............................................  Find the first file<br /><br />	invoke FindFirstFile,pPattern,addr fd<br />	cmp eax,INVALID_HANDLE_VALUE<br />	je Error<br />	mov hff,eax<br />	<br />	cmp pCallback,0<br />	je Error<br />	<br />; ..............................................  Start of the file loop!<br />FileLoop:<br />; ..............................................  If it's a directory and we're doing recursion<br />; ..............................................  ignore it for now.<br /><br />	test fd.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY<br />	jz @F<br />	test Flags,fRecursive<br />	jnz SkipCallback<br />	@@:<br />; ..............................................  Append the filename to the path<br />	lea esi,fd.cFileName<br />	mov edi,pPatternFn<br />@@:<br />	mov al,<br />	inc esi<br />	mov ,al<br />	inc edi<br />	cmp al,0<br />	jne @B<br />; ..............................................  Do the callback<br />	mov eax,pCallback<br />		push Param<br />	lea esi,fd<br />		push esi<br />		push pPattern<br />	call eax<br />SkipCallback:<br /><br />; ..............................................  Find the next file<br />	invoke FindNextFile,hff,addr fd<br />	or eax,eax<br />	jnz FileLoop<br />	invoke CloseHandle,hff                 ; End of the file loop!<br />; ..............................................  If we don't need to do recursion, skip to the end.<br />	test Flags,fRecursive<br />	jz Done<br />; ..............................................  We want to find ALL dirs, not just those matching<br />; ..............................................  the original pattern.<br />	mov edi,pPatternFn<br />	mov dword ptr ,002a2e2ah ; = &quot;*.*&quot;, 0<br />	pop edi<br /><br />Done:<br />	invoke GlobalFree,pPattern<br />	invoke GlobalFree,pLocalFn<br />	mov eax,-1	<br />	ret<br />; ..............................................  <br />Error:<br />	invoke GlobalFree,pPattern<br />	invoke GlobalFree,pLocalFn<br />	xor eax,eax<br />	ret<br /><br />EnumFiles endp<br /><br /><br /><br /><br /><br /><br />end start</div>
    <div class="meta">Posted on 2002-05-19 11:50:02 by cmax</div>
   </div>
  </div>
 </body>
</html>