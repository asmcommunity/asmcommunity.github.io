<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>TypeDef Enum, GUIDS.LIB problem - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=8777" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=8777">TypeDef Enum, GUIDS.LIB problem</a></p>
   <div class="post" id="post-64497">
    <div class="subject"><a href="#post-64497">TypeDef Enum, GUIDS.LIB problem</a></div>
    <div class="body">Hello guys,<br /><br /><br />How masm handle the typedef enums ?<br /><br />I'm trying to figure it out how it handles things like<br /><br />typedef enum _D3DRMMATERIALMODE{<br />D3DRMMATERIAL_FROMMESH,<br />D3DRMMATERIAL_FROMPARENT,<br />D3DRMMATERIAL_FROMFRAME<br />} D3DRMMATERIALMODE;<br /><br />The enumerations works like the TypeDef Structures ? I mean <br />D3DRMMATERIAL_FROMMESH = 01 ; D3DRMMATERIAL_FROMPARENT =02 ?<br /><br />I saw that on the file GUIDS.lib on masm folder, it contains the D3DRMMATERIALMODE, bbut how to use this library to analyse the result ? I mean how to fully insert this .lib file on a .asm file on a way that the executable (or the object file) contains all the information ?<br /><br />Other thing...On win32.hlp we have things like:<br /><br />  IClientSecurity::QueryBlanket<br />Retrieves authentication information.<br /><br />HRESULT QueryBlanket(<br /><br />      void* pProxy ,  //Location for the proxy to query<br /><br />      DWORD* pAuthnSvc ,  //Location for the current authentication service<br /><br />      DWORD* pAuthzSvc , //Location for the current authorization service<br /><br />      OLECHAR ** pServerPrincName ,  //Location for the current principal name<br /><br />      DWORD * pAuthnLevel ,   //Location for the current authentication level<br /><br />      DWORD * pImpLevel ,   //Location for the current impersonation level<br /><br />      RPC_AUTH_IDENTITY_HANDLE ** ppAuthInfo ,   //Location for the value passed to IClientSecurity::SetBlanket<br /><br />      DWORD ** pCapabilities   //Location for flags indicating further capabilities of the proxy<br /><br />      );<br /><br />And <br /><br />IDirectDrawSurface::BltBatch <br /><br />Performs a sequence of IDirectDrawSurface::Blt operations from several<br />sources to a single destination. At present this method is only a stub; it<br />has not yet been implemented.<br /><br />HRESULT BltBatch(<br />LPDDBLTBATCH lpDDBltBatch,<br />DWORD dwCount,<br />DWORD dwFlags<br />)<br /><br /><br />What are those things ? They are functions ? If they are, how to use them on masm ? I mean we have to rename them ?<br />From IDirectDrawSurface::BltBatch to IDirectDrawSurface_BltBatch ?<br /><br /><br />Last thing:<br />There is a way to convert that lib file to an obj file ?<br /><br /><br />Best Regards,<br /><br />Beyond2000!</div>
    <div class="meta">Posted on 2002-11-03 13:17:04 by Beyond2000!</div>
   </div>
   <div class="post" id="post-64515">
    <div class="subject"><a href="#post-64515">TypeDef Enum, GUIDS.LIB problem</a></div>
    <div class="body">Regarding your questions about IClientSecurity::QueryBlanket and IDirectDrawSurface::BltBatch: they are functions which are accessed via an interface,  IClientSecurity and IDirectDrawSurface are the interfaces. Probably the simplest (but not the most technically accurate) explanation i can come up with to describe an interface is this: think of it as each interface is a separate dll, but you don't handle it in the normal way. To find out how to handle them, check out the COM section of the forum.<br /><br />As for your enums, i personally would declare them all individually. There may be a way to do enums in MASM, but i don't know it, although if the enums are in a lib file then you should be able to just link to it. If they are in a typelib then there may be a way to use them, but i don't know how :)</div>
    <div class="meta">Posted on 2002-11-03 15:11:42 by sluggy</div>
   </div>
   <div class="post" id="post-64534">
    <div class="subject"><a href="#post-64534">TypeDef Enum, GUIDS.LIB problem</a></div>
    <div class="body">I read them.<br /><br /><br />But one thing it was not clear.<br /><br />These functions are called on a differenmt way. That means that they can't be retrieved with an API importer ?<br /><br />I mean, if they belongs to a specifc dll., we can't retrieve their names on the import section ?<br /><br />If not, they are inside functions, like _malloc etc....?<br /><br /><br />Regards,<br /><br />beyond2000!</div>
    <div class="meta">Posted on 2002-11-03 19:07:36 by Beyond2000!</div>
   </div>
   <div class="post" id="post-64551">
    <div class="subject"><a href="#post-64551">TypeDef Enum, GUIDS.LIB problem</a></div>
    <div class="body"><div class="quote">These functions are called on a differenmt way. That means that they can't be retrieved with an API importer ?</div> <br /><br />Thats right. Any dll that acts as a COM object server will export a CoCreateInstance API. You can try your importer on that, but its well documented so that you don't have to bother.<br /><br /><div class="quote">I mean, if they belongs to a specifc dll., we can't retrieve their names on the import section ?</div> <br /><br />COM dll's 'publish' what they export in a type library, a resource usually attatched to the dll (occasionally seperate in older dll's). This may seem very strange, but these exports are actually closer to C++ objects then simple dll exports. <br /><br />COM is a whole subject unto itself, its use in ASM is fairly well documented.<br /><br /><div class="quote">How masm handle the typedef enums ?</div> <br /><br />Unfirtunately, MASM doesn't handle typed enumerations. One work-around is to use the type name -underscore- the enum name as a constant definition:<br /><br /><br />D3DRMMATERIAL_FROMMESH,         EQU  1<br />D3DRMMATERIAL_FROMPARENT,         EQU  2<br />D3DRMMATERIAL_FROMFRAME         EQU  3</div>
    <div class="meta">Posted on 2002-11-03 23:18:30 by Ernie</div>
   </div>
   <div class="post" id="post-64556">
    <div class="subject"><a href="#post-64556">TypeDef Enum, GUIDS.LIB problem</a></div>
    <div class="body">Hi Ernie, tks.<br /><br />I found some examples on the COM section (DX8withMacro.asm), that displayed exactly those kind of things.<br /><br />Like:<br /><br /><br />;   Get the current desktop display mode<br />    g_pD3D GetAdapterDisplayMode, D3DADAPTER_DEFAULT, ADDR d3ddm<br /><br />That is<br /><br />IDirect3D8::GetAdapterDisplayMode<br /><br />After some analysis, i saw that this code is nothing but a call inside the address 416230 on d3d8.dll, that is exactly an &quot;inside&quot;functin called GetAdapterDisplayMode.<br /><br />On masm example the way to go to that adress is:<br /><br />lea     eax,  ; Coding for<br />push    eax                       ; ADDR d3ddm<br />push    0                    ; here means D3DADAPTER_DEFAULT<br /><br />mov     edx, edx ; -----here we calculate to go inside the dll<br />mov     eax, _g_pD3D ----&gt; similar to the object stuff (interface)<br />push    eax<br />mov     eax, <br />call    dword ptr  ; call to 416230 that is GetAdapterDisplayMode<br /><br /><br />In other hands, since these functions are not exported, masm need to calculate where the call need to go inside the dll.<br /><br /><br />That is really weird, because if the dll had the function GetAdapterDisplayMode as an export, all we have to do should be:<br /><br />invoke GetAdapterDisplayMode, D3DADAPTER_DEFAULT, ADDR d3ddm<br /><br />Instead using all that coding routines.<br /><br /><br />The masm way to calculate the offset inside the dll, is the same as VC or in Borland C or other compilers ?<br /><br />Best Regards,<br /><br />Beyond2000!</div>
    <div class="meta">Posted on 2002-11-04 01:38:01 by Beyond2000!</div>
   </div>
   <div class="post" id="post-64870">
    <div class="subject"><a href="#post-64870">TypeDef Enum, GUIDS.LIB problem</a></div>
    <div class="body">Assessing COM Methods <br />--------------------------------------------------------------------------------------------------------------------<br />To use COM methods you need to know before hand what the interface looks like. Even if you &quot;late bind&quot; through an IDispatch interface, you still need to know what IDispatch looks like. A COM interface is just table of pointers to functions. Let's start with the IUnknown interface. If you were to create a component that simply exports the IUnknown interface, you have a fully functional COM object (albeit on the level of &quot;Hello World&quot;). IUnknown has the 3 basic methods of every interface, since all interfaces inherit from IUnknown. Keep in mind all an interface consists of is a structure of function pointers. For IUnknown, it looks like this: <br /><br /><pre><code><br />IUnknown STRUCT DWORD <br />; IUnknown methods <br />IUnknown_QueryInterface 	QueryInterface_Pointer ? <br />IUnknown_AddRef 		AddRef_Pointer ? <br />IUnknown_Release 		Release_Pointer ?<br />IUnknown ENDS<br /></code></pre><br /><br />That's it, just 12 bytes long. It holds 3 DWORD pointers to the procedures that actually implement the methods. It is the infamous &quot;vtable&quot; you may have heard of. The pointers are defined as such so we can have MASM do some type checking for us when compiling our calls. Since the vtable holds the addresses of functions, or pointers, these pointers are typedefed in our interface definition as such: <br /><br /><pre><code><br />QueryInterface_Pointer 	typedef ptr QueryInterface_Proto<br />AddRef_Pointer 		typedef ptr AddRef_Proto <br />Release_Pointer 		typedef ptr Release_Proto<br /></code></pre><br /><br />Finally, we define the function prototypes as follows: <br /><br /><pre><code><br />QueryInterface_Proto 	typedef PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD <br />AddRef_Pointer 		typedef PROTO &#58;DWORD <br />Release_Pointer 		typedef PROTO &#58;DWORD <br /></code></pre><br /><br />In keeping with the MASM32 practice of &quot;loose&quot; type checking, function parameters are just defined as DWORDs. Lots of work to set things up, but it does keeps lots of errors confined to compile time, not run time. In practice, we will wrap up these interface definitions in include files and keep them from cluttering up the source code. <br /><br />One rather big compilation on defining an interface: MASM cannot resolve forward references like this, so we have to define them backwards, by defining the function prototype typedefs first, and the interface table last. The include files for the example program later on defines the interfaces this way. <br /><br />To actually use an interface, you need a pointer to it. <br /><br />The CoCreateInstance API can be used to return us this indirect pointer to an interface structure. It is one level removed from the vtable itself, and actually points to the &quot;object&quot; that holds the interface.  The final structure looks like this:<br /><br /><br /><img src="http://ourworld.compuserve.com/homepages/ernies_world/vtable.bmp" /> <br /><br />There is a lot of indirection using this structure, it can drive you batty trying to write code to properly reference and de-reference these elements. Macros to simplify this task will be defined.<br /><br />When the client makes a call to the COM library to create a COM object, it passes in the address where it wants the object pointer to be placed.  This initial pointer is generically referred to as &quot;ppv,&quot; from the C++ speak &quot;pointer to pointer to (void),&quot; where (void) means an unspecified type. It holds the address of another pointer (&quot;pv&quot;), and this pointer refers to a whole table of pointers, one table entry for each function of the interface.<br /><br />For example, say we used CoCreateInstance and successfully got an interface pointer ppv, and wanted to see if it supports some other interface. We can call its QueryInterface method and request a new ppv (ppv2, pointer to an Interface) to the other interface (pIID, pointer to a Interface Identifying GUID) we are interested in. In C, QueryInterface has a prototype that would look like so:<br /><br /><pre><code><br />&#40;HRESULT&#41; SomeObject&#58;&#58;QueryInterface &#40;this&#58;pObject, IID&#58;pGUID, ppv2&#58;pInterface&#41;<br /></code></pre><br /><br />Such a call would look like this: <br /><br /><pre><code><br />; get pointer to the object <br />mov eax, ppv <br />; and use it to find the interface structure<br />mov edx, &#91;eax&#93; <br /><br />; push the function parameters onto the stack<br />push OFFSET ppv2<br />push OFFSET IID_ISomeOtherInterface<br />push dword ppv<br /><br />; and then call that method <br />call dword ptr &#91;edx + 0&#93;<br /></code></pre><br /><br />Note we must pass in the pointer we used, this lets the interface know which object (literally &quot;this&quot; object) we are using. <br /><br />Note the register must be type cast (IUnknown PTR ). This lets the compiler know what structure to use to get the correct offset in the vtable for the .QueryInterface function (in this case it means an offset of zero from ). Actually, the information contained by the interface name and function name called disappear at compile time, all that is left is a numeric offset from an as of yet value unspecified pointer.</div>
    <div class="meta">Posted on 2002-11-06 20:47:07 by Ernie</div>
   </div>
  </div>
 </body>
</html>