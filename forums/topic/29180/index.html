<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>NetEngine - an IOCP server/client framework for ObjAsm32 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29180" />
    <link rel="next" href="../?id=29180&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=8">Networking</a> &raquo; <a href="../?id=29180">NetEngine - an IOCP server/client framework for ObjAsm32</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29180&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29180&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29180" /><input type="number" name="page" min="1" max="3" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29180&amp;page=2">&gt;</a><a href="../?id=29180&amp;page=3">&raquo;</a></form>   <div class="post" id="post-206098">
    <div class="subject"><a href="#post-206098">NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">Hey :)<br /><br />I&#039;ll be using this thread to describe and to discuss aspects of the NetEngine component which will go public with the next official release of ObjAsm32 - the object oriented programming environment for x86 assembly programmers.<br /><br />I guess the best place to start is to talk a little about what IOCP actually is, and how IOCP networking differs from regular socket programming.<br /><br />IOCP stands for IO Completion Port - essentially its a message queue which tells us when an attempted IO operation has completed, and whether it succeeded or failed.<br />You might wish to think of the IOCP as being a lot like our old friend the Windows Message queue - the key difference is that IO jobs can complete &#039;out of order&#039; - ie, asynchronously.<br />You can use an IOCP for anything that supports &quot;overlapped io&quot;, including file io - and you can invent other kinds of IO jobs , eg to signal that a chunk of data has finished being decompressed by some other thread... but I will restrict my discussion to network programming :P<br /><br />So what is an IO job?<br />There are four main types of IO job (or io operation if you prefer) which network programmers will use.<br />The are Connect (to a remote host), Accept (an incoming client connection), Read (recv) and Write (send).<br /><br />When we initiate a socket operation using appropriate api, we will typically get an error &quot;IO PENDING&quot;, meaning that the operation could not complete immediately, and that we can expect a message via our IOCP when that operation completes.<br /><br />In order to service these IOCP messages, we create one of more &quot;worker threads&quot; which essentially sleep until something happens.<br /><br />This introduces a small problem - although the IOCP messages are serviced in order of completion, the actual SERVICING of IO jobs may complete out of order due to the nature of multithreaded operations!<br />For example, say we have two Worker threads, and two READ operations complete in order #1, then #2.<br />Our IOCP alerts the threads &quot;in order&quot; that these receives just completed, but who can say which thread will be serviced first by the thread subsystem? Introducing any kind of mutex here would completely wipe out any benefits gained by using asynchronous multithreaded code in the first place, so that&#039;s not a solution - but I digress. The way you handle this will depend a lot apon the kind of work you&#039;re trying to do.<br /><br />In terms of writing a network Server, the major difference is how the Accept api works.<br />Normally, we would expect that when Accept completes successfully, it returns a Socket for the newly-accepted incoming connection. IOCP does this very differently.<br />Its very expensive to make a Socket, so to avoid this cost, we create a whole bunch of sockets at the start, which are waiting for Accept to complete.. we can add more &quot;pending accepts&quot; later if we run out, but we&#039;ll start to incur that cost I was talking about.<br /><br />Otherwise, the networking code is very much like any other asynchronous networking code you&#039;ve seen, with the fundamental difference being that we don&#039;t have to pay a cost to receive a notification that an event has occurred.<br />IOCP is tied closely to the Windows event subsystem, and for this reason, is far more efficient than any other networking scheme on this platform.<br /><br />IOCP is designed to handle tens of thousands of connections asynchronously, using just a handful of worker threads.. But you can use it for regular networking and still benefit from the low latency.<br /><br />In my next post, I&#039;ll begin to desribe some features of my NetEngine implementation, which I have already used to implement various kinds of servers and clients.<br /></div>
    <div class="meta">Posted on 2008-10-12 23:00:56 by Homer</div>
   </div>
   <div class="post" id="post-206099">
    <div class="subject"><a href="#post-206099">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">In the beginning, I designed my implementation to be a network server, so I called the main interface &quot;Server&quot; - I have since extended it to handle both Server and Client connections, but since it also acts as a home for the IOCP Worker threads, I left the name as it stands - it is at heart, a network message notification server.<br /><br />Most of the actual networking code was pushed out to a class called Client.<br />A Client object represents a potential network connection, and these are stored in the Server in three &quot;pools&quot; of recyclable objects - it can be outbound, inbound, or &quot;listening&quot;.<br /><br />The Client class represents a socket and a socket address, and implements the functionality we would expect of a network socket - it handles initiation and completion events for connections, accepts, sends and receives.<br /><br />Some of these are handed on to a so-called &quot;Protocol handler&quot;, something I&#039;ll speak more of later.<br />When messages are passed on in this manner, we call it &quot;marshalling&quot;... the events are &quot;marshalled&quot; so that the appropriate &quot;handler&quot; is notified and can react to them.<br /><br />My implementation of NetEngine allows each and every Client object, whether it represents an inbound or outbound connection, to marshall such events to a particular Protocol handler who is responsible for determining that the session is following the rules of the given protocol.<br /><br />That means you can have any number of inbound and outbound sessions, each with their own protocol, and all driven by the same IOCP message system!<br /><br />In my next post, I&#039;ll begin to describe the objects involved in my implementation, their relationships, and how they interact. We need to put on our oop teeshirt and get ready to deal with complex object relationships!<br /><br /><br /></div>
    <div class="meta">Posted on 2008-10-13 06:23:33 by Homer</div>
   </div>
   <div class="post" id="post-206101">
    <div class="subject"><a href="#post-206101">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">Warning: The following post contains a lot of OOP concepts, I hope you are wearing your oop teeshirt!<br /><br />Note: You don&#039;t need to understand the internals of NetEngine to use it, with the exception of the Network Protocol handler, which is briefly described here. You only need to make a few calls to the main Server class, almost all the interesting stuff happens in your protocol handler.<br /><br />As mentioned, the major component of the NetEngine is a class called Server.<br />For most users, the most important two methods of the Server class are called ConnectTo and Listen.<br />These two methods both require the caller to provide a pointer to a network protocol handling class.<br />I have provided a class called, strangely enough, NetworkProtocol.<br />It is a BASE CLASS, you should write your own class which overrides the methods of this class.<br />In fact, you can handle as many protocols as you like, on a per-session basis.<br />You simply hand the protocol object you want when making ConnectTo and Listen calls, and NetEngine will use them as &#039;event sinks&#039;.<br /><br />NetEngine calls the methods of NetworkProtocol (and your derivatives) in order to inform you of the completion of the various IO jobs that you have issued, or that were issued on your behalf.<br />You can handle them silently, and/or hand them on to your application - this is the other reason that you need to derive network protocol handler classes for yourself.<br />You can imagine that they sit inbetween NetEngine and your app.<br />The Init method of NetworkProtocol is not declared, I suggest you use it to set the Owner of the protocol object to your app window or dialog window so that you can then send your app Window Messages directly from the protocol handler.<br /><br />As mentioned previously, network sessions (and Listening ports) are represented by a class called Client.<br />Each client is the Owner of any number of pending io jobs, ie, each io job knows which Client issued it.<br />But a Client does not STORE io jobs, those are stored in the Server class.<br /><br />So the Server class is managing all the resources, and the Ownership variable of various objects is just used to make associations between all the objects.<br /><br />These associations are useful, as they give objects access to methods of related objects.<br />For example, when an io job completes, it will inform its owner Client, which will inform its protocol handler, which can then inform the application.<br /><br />The owner of the Client class, in the current implementation, is the handle of the IOCP itself.<br />This allows a newly-accepted inbound client to bind its socket to the iocp.<br />I may decide to change this, but since the Client class cannot (and never needs to) make calls to the Server class, I saw no point in making the Server class the owner of arbitrary Clients.<br /><br />The Client and IOJob classes are managed through classes called ClientPool and IOJObPool.<br />These two classes derive from a baseclass called Pool, which implements a pool of recyclable objects.<br />Allocating memory for objects is expensive, why throw away perfectly good objects just because we don&#039;t currently need them? Pooling is a way to avoid this, we keep redundant objects in memory, and reinitialize them when we need them again. This is much faster.<br />However we don&#039;t wish to keep an infinite number of dead objects floating in our pools.<br />The Init method of the Server class allows us to set some sane limits on the minimum and maximum number of pooled resources that we wish to retain at all times, anything outside this range will be going to landfill.<br />For example, for a Server application, we might wish to have at least 5 pending Accepts, no more than 10 thousand concurrent sessions, and no more than fifty thousand pending io jobs.<br />For most users, these values can be set to something reasonably small, but if we are coding a MMORPG or other intensive server, we&#039;ll want more.<br />NetEngine will attempt to scale its memory use to suit the demand, but we still need some absolute limits, yes?<br /><br />For the record, I&#039;ve tested NetEngine on a 333Mhz machine with 16 meg of ram and a 4 gig hard drive (most of which is consumed by XP), with twenty thousand concurrent connections, it consumed 25 percent of the cpu bandwidth, and packets pinged at no more than 250 ms for each and every client, given that they were talking to localhost.<br />And a friend of mine tested it on linux under Wine, with very similar results.<br /><br />In fact, one of the early goals of NetEngine was to implement a massively multi user server that could run on low-end hardware without consuming vast amounts of memory and cpu resources.<br /><br />I do hope you will support and use NetEngine, help me to identify any remaining bugs and implementation nuances, make suggestions, etc.. its FREE, and its better than anything I&#039;ve seen on sourceforge or codeguru etc, do the right thing, don&#039;t be a packet monkey.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-10-14 07:08:28 by Homer</div>
   </div>
   <div class="post" id="post-206108">
    <div class="subject"><a href="#post-206108">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">NetEngine embeds an object called ClientGroup, which represents a Named group of Clients, and gives you a way to organize Clients (think of a Lobby server, for example).<br />As well as being able to Name groups, you can provide a description string.<br /><br />You can think of a ClientGroup as a communication channel, chatroom, etc... it can be used to broadcast messages to all of the member Clients of a Group.<br /><br />ClientGroup supports SUBGROUPS ...<br />The Server class implements a Root ClientGroup - you can add subgroups to it, and to them, and so create a Tree - a hierarchy of Groups.<br />Clients can be members of as many Groups as you wish.<br /><br />Your Protocol class, or your application, can add newly-connected Clients to one or more Groups, but when a Client &#039;dies&#039;, the Server class will automatically remove them from the entire tree.<br /><br />The ClientGroup.Broadcast method will send data to all member Clients of a given Group and all of its SubGroups, with the exception of the client who is doing the Sending.<br /><br />The ClientGroup.Send method will send data only to the members of a specific Group, and not its SubGroups (again, with the exception of the Sender).<br /><br />Although (as mentioned) the Server class will prune dead clients from the ClientGroup tree, its fair to say that ClientGroup is NOT closely tied to the Server class, it was my intention that it work closely with your Protocol class and/or your application, because NetEngine does not care what purpose you use ClientGroups for.<br /></div>
    <div class="meta">Posted on 2008-10-15 22:09:35 by Homer</div>
   </div>
   <div class="post" id="post-206110">
    <div class="subject"><a href="#post-206110">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">Homer, I love the work you do! I have thrown together a couple versions of my own &quot;oop&quot; version of winsock in masm without it really being &quot;oop&quot; Maybe I should look into the ObjAsm32 project, however the nagoa++ project for nasm had plenty of errors(in the windows inc file) for me to not want to work in nasm as well as be leery of any other &quot;user-based&quot; projects for an assembler which is why I stuck with working in masm32 without too many changes. Every version of my winsock projects seemed to work, but was so dirty that the code seemed like it didn&#039;t simplify anything like I wanted it to.<br /><br />I figure I&#039;ll check into the objasm project, however is there a chance you could make a dll version of this framework? Obviously it wouldn&#039;t be quite the &quot;Client[56].SendData(lpData,lLength)&quot; but maybe a &quot;invoke SendData,hClient,addr Data, DataLength&quot; I hope you get what I mean.<br /><br />(I keep explaining things then erasing them because it only makes it more complicated which confuses me more.... gah it&#039;s early in the morning I need some sleep. &lt;-- Maybe I should erase this rambling too.. &lt;-- this too... &lt;-- this......................)</div>
    <div class="meta">Posted on 2008-10-16 05:00:36 by jakor</div>
   </div>
   <div class="post" id="post-206111">
    <div class="subject"><a href="#post-206111">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">The earliest version of NetEngine was a DLL core.<br />I removed that wrapper, because I felt that the framework was immature, perhaps I can change my mind later? Or you can take my code and DLL-wrap it yourself.<br /><br />You are welcome to do what you like, you are free to, the code is free, there is no license.<br />If you do that, it would be nice to include some kind of reference to OA32 and myself in the description.<br /><br />I appreciate your expression of interest, and I will post some actual code real soon, I am currently walking over the code with the originator of OA32 (Biterider), asking him to review my work before it goes public :)<br /></div>
    <div class="meta">Posted on 2008-10-16 08:26:47 by Homer</div>
   </div>
   <div class="post" id="post-206113">
    <div class="subject"><a href="#post-206113">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">Well I will await your release!</div>
    <div class="meta">Posted on 2008-10-16 14:23:10 by jakor</div>
   </div>
   <div class="post" id="post-206119">
    <div class="subject"><a href="#post-206119">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">I&#039;m contemplating adding one final class to NetEngine : an application-layer interface.<br />This would be a second abstracted class which means you need to write not only at least one Protocol class derivation but also your own Application class derivation, adding complexity and some call cost in return for a lot of flexibility and making it a lot easier to use, obviating the need to understand anything about the internals.<br /><br />Its a difficult decision, to trade off speed for functionality, especially where that functionality is just something else that the User (programmer) must provide.<br /><br />Perhaps I should make it optional.<br /></div>
    <div class="meta">Posted on 2008-10-18 05:38:02 by Homer</div>
   </div>
   <div class="post" id="post-206121">
    <div class="subject"><a href="#post-206121">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">Hi<br />Since the Messenger service is not running today, i decided to post the logical processor detection code. It is easier than the Intel proposed code since we don&#039;t need all that functionality provided by the original code. If the affinity masks are needed to make sure that each thread will run on a different logical processor then we need to return an affinity mask array (max 32 dwords) and use these masks in combination with the SetThreadAffinityMask api.<br /><br /><pre><code>GetLogProcCount proc uses ebx edi esi, pMaskTable:Pointer<br />&nbsp; &nbsp; local dProcessAffinity:dword, dSystemAffinity:dword, hCurrentProcessHandle:Handle<br /><br />&nbsp; &nbsp; mov hCurrentProcessHandle, $invoke(GetCurrentProcess)<br />&nbsp; &nbsp; invoke GetProcessAffinityMask, hCurrentProcessHandle, addr dProcessAffinity, addr dSystemAffinity<br />&nbsp; &nbsp; .if eax != FALSE<br />&nbsp; &nbsp; &nbsp; xor edi, edi<br />&nbsp; &nbsp; &nbsp; xor ebx, ebx<br />&nbsp; &nbsp; &nbsp; inc edi<br />&nbsp; &nbsp; &nbsp; mov esi, pMaskTable<br />@@:<br />&nbsp; &nbsp; &nbsp; test edi, dSystemAffinity<br />&nbsp; &nbsp; &nbsp; .if !Zero?<br />&nbsp; &nbsp; &nbsp; &nbsp; ;Check if this logical processor is available to this process<br />&nbsp; &nbsp; &nbsp; &nbsp; .if $invoke(SetProcessAffinityMask, hCurrentProcessHandle, edi)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if esi != NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov dword ptr , edi<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke Sleep, 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Give OS time to switch CPU<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; shl edi, 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Prepare mask for the next logical processor<br />&nbsp; &nbsp; &nbsp; jz @F&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Exit if the mask is above 32<br />&nbsp; &nbsp; &nbsp; cmp edi, dSystemAffinity<br />&nbsp; &nbsp; &nbsp; jbe @B<br />@@:<br />&nbsp; &nbsp; &nbsp; ;Set previous processor affinity<br />&nbsp; &nbsp; &nbsp; invoke SetProcessAffinityMask, hCurrentProcessHandle, dProcessAffinity<br /><br />&nbsp; &nbsp; &nbsp; mov eax, ebx<br />&nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; ret<br />GetLogProcCount endp<br /></code></pre> <br /><br />Regards,<br /><br />Biterider</div>
    <div class="meta">Posted on 2008-10-18 06:12:25 by Biterider</div>
   </div>
   <div class="post" id="post-206122">
    <div class="subject"><a href="#post-206122">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">Thanks, that lets me remove one parameter from server init method, since we want one Worker thread per available logical cpu... although it might not seem like a big deal, I think its a really nice addition, its one thing less that the user (programmer) has to think about.<br /><br />I think this deserves&nbsp; :thumbsup: Two Thumbs Up :thumbsup: !!<br /></div>
    <div class="meta">Posted on 2008-10-18 06:52:36 by Homer</div>
   </div>
   <div class="post" id="post-206135">
    <div class="subject"><a href="#post-206135">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">Thanks Biterider, I implemented that code immediately - NetEngine now automatically creates the optimal number of Worker Threads for the hardware it is running on.<br /><br />I need to mention something about the Client class.<br />As mentioned previously, this class is mostly a wrapper for a socket, and can operate in one of three possible ways - it can represent an inbound connection to your server, an outbound connection to a remote host, or it can represent a &#039;Listening&#039; socket, whose job is to accept inbound connections.<br /><br />Client class contains a field called pListener.<br />If this field is set to a non-zero value, it means that this Client represents an inbound connection that your server has accepted, and pListener is a pointer to the Client that represents the Listener.<br /><br />This is quite a confusing concept - a client field that is pointing to another client object.<br />Its purpose is to allow newly-accepted clients to be associated with their host &quot;listener&quot; client who accepted them, which in turn allows the newly accepted client to inherit the listener&#039;s Protocol.<br /><br />This lets NetEngine use a common pool of clients for any number of listening ports and protocols.<br /><br />I may decide to alter this scheme in a future version of NetEngine, but since this is really a deeply internal mechanism, it will only be of interest to those who choose to study the implementation.</div>
    <div class="meta">Posted on 2008-10-19 00:33:30 by Homer</div>
   </div>
   <div class="post" id="post-206136">
    <div class="subject"><a href="#post-206136">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">I am making some last-minute additions to NetEngine in order to support different session behaviours that might be implemented under various protocols, including those defined by the user.<br /><br />I think the best place to start is to define those behaviours:<br /><br />PACKET ORIENTED:<br />NetEngine&#039;s current code only allows for packet-oriented protocols, where each packet of data in the stream contains a PacketLength field or other useful means of delimiting the packets... this is important, because we might receive for example two and a half packets, meaning that some data must remain in the buffer while we wait for more.<br /><br />STREAM ORIENTED:<br />What if we wish to transfer a file? There will be no way of knowing when the transfer is complete, other than that the session has expired - that is to say, there is no delimiter, session expiry IS the delimiter.<br /><br />HYBRID:<br />It is reasonable to suggest a packet-negotiated streaming protocol, where we send a few handshaking packets which are followed by the main body of data being transferred. In this case, the protocol handler would &quot;switch itself&quot; from packet-oriented to stream-oriented at the appropriate moment.<br /><br />And then there are protocols such as http, where there may be a lot of data transferred, and yet we can still expect a sane delimiter - should we just ignore that fact and wait for session expiry? No, because http 1.1 supports &quot;keep-alive&quot;, where the session is NOT terminated when the transfer completes.<br /><br />Whatever I decide to do, NetEngine is going to need to be able to aggregate received data and retain it at least until we determine that we have a complete protocol packet - which may span several IOJobs.<br /><br />I will try to implement the necessary changes as quickly as possible.<br /></div>
    <div class="meta">Posted on 2008-10-19 05:06:57 by Homer</div>
   </div>
   <div class="post" id="post-206138">
    <div class="subject"><a href="#post-206138">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">Most of the changes have been put into place.<br /><br />The Server object used to pass recv completion notifications directly to a Client&#039;s Protocol handler, bypassing the Client.<br />Now they are passed to the Client, who can deal with them in its own context, while making calls to its Protocol handler to make decisions on its behalf.<br />The logic dealing with recv completion has been moved from NetworkProtocol to Client, while the logic dealing with analysing received data to find its protocol-specific delimiters remains in NetworkProtocol.<br />This makes a lot of sense.<br /><br />The Client object now inherits from DwordCollection.<br />This allows Client to store a list of IOJobs which are completely full of data until a delimiter has been found.<br />It also means that Client REPRESENTS a collection of iojobs that are pending receipt of that delimiter, and can be passed AS a collection to NetworkProtocol (who doesn&#039;t actually know what a Client is).<br />Once a delimiter is found, the last IOJob is also tossed onto the Client&#039;s collection, then the Client is passed to NetworkProtocol where the set of IOJob buffers can be processed.<br />When that call returns, Client can clean up all the consumed IOJobs, possibly leaving some unconsumed data in the last IOJob, which is not part of this protocol-specific receive operation (it&#039;s the start of the next one).<br /><br />This is a rather elaborate use of object inheritance, and shows the true power and flexibility of ObjAsm32, and why OOP can be a Good Thing when used appropriately.<br /><br />I think the changes I&#039;ve made cover all possible situations except one.<br /><br />What about protocols which are only delimited by session expiry?<br />If a session expires, and we have received data that is pending a delimiter, how can we tell whether the session expiry was the delimiter we sought, or whether the connection was lost prematurely?<br /><br />It may be necessary to add a flag to NetworkProtocol to alter the behaviour for these &quot;no protocol&quot; transmissions of data (such as raw file transfers or other delimiterless streaming).<br /><br />In these cases, there is no way we can know that the data sent is complete without sending some kind of preamble that includes the expected size of the complete transfer.. if we don&#039;t wish to do that, we&#039;ll just have to assume that the data is complete and intact, as there is no protocol in place.<br /><br /></div>
    <div class="meta">Posted on 2008-10-19 22:59:34 by Homer</div>
   </div>
   <div class="post" id="post-206185">
    <div class="subject"><a href="#post-206185">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">I&#039;ve written some simple demonstration code consisting of two small applications.<br />One is a client, one is a server, and they implement an &quot;echo&quot; protocol.<br />You can use one or more instances of the client to send data to the server.<br />The server responds by simply sending the data back to the client who sent it.<br />Not very complex, and not a &#039;true&#039; network protocol implementation, but enough to prove that NetEngine has no huge bugs, which is nice because there&#039;s been a lot of small changes recently.<br />I guess NetEngine goes public very soon :)<br /></div>
    <div class="meta">Posted on 2008-10-29 00:14:48 by Homer</div>
   </div>
   <div class="post" id="post-206192">
    <div class="subject"><a href="#post-206192">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">Now I&#039;m working on integrating &quot;transparent&quot; support of automatic port-forwarding using UPNP to control NAT devices. This also means implementing and testing of Clients that use UDP, and protocols which are &quot;connectionless&quot;. But for the average user, it will mean they can &quot;run a server&quot;, even if they are a LAN client that is behind a router or using ICS or other NAT device that would normally prevent them from being able to accept incoming connections, and it will be handled internally, so there&#039;s no extra load placed on the programmer.<br /><br />Server class was renamed to NetEngine (this avoids confusion when writing client oriented apps).<br />UDP_Announce was added to the NetEngine class - this method creates a UDP client of given protocol, queues a receive, and sends some initial data - the rest is up to the protocol class.<br /></div>
    <div class="meta">Posted on 2008-10-30 00:27:42 by Homer</div>
   </div>
   <div class="post" id="post-206225">
    <div class="subject"><a href="#post-206225">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">I&#039;m still working on the &#039;upnpnat&#039; support code.<br />UPNPNATProtocol is an interesting derived class, because it requires the use of a UDP broadcast followed by TCP stuff, and I&#039;ve handled it all with a single protocol handler (well, its all part of the same network protocol, but it requires more than one session using more than one carrier protocol).<br />So far I can find the gateway device (using udp), and query it for more information (using tcp).<br />I am stuck there because now I need to deal with XML parsing, but since I&#039;m not interested in enumerating the port forwardings or querying them specifically but ONLY in attempting to create a &#039;new&#039; port forwarding, the job becomes somewhat easier.<br /><br />I expect to alter NetEngine to use this code to detect the external ip address (that of the gateway machine), and set an internal flag, so that if we try to create a Listening Port (ie a server application), and the local machine is NOT directly connected to the internet, then a suitable port forwarding will be automatically created at that moment - and it would be nice if the port forwarding was automatically removed too, but one step at a time :P<br /><br />For the average Joe, it means that (assuming that upnp is enabled, the upnp ports allowed past the firewall, and the NAT device is upnp-compatible), anyone can run a Server (accept incoming connections), even if they are sitting in a net cafe with 30 other lan users all sharing a single external ip address.<br /><br />Obviously this won&#039;t always be possible... but in many (most?) cases it will be a blessing, since we don&#039;t always have access to the cpanel of the router (or other nat device) but we may have access to upnp (and who would want to manually configure their router if it can be done in code?)<br /><br /></div>
    <div class="meta">Posted on 2008-11-05 03:29:43 by Homer</div>
   </div>
   <div class="post" id="post-206236">
    <div class="subject"><a href="#post-206236">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">Hehe now your server/client framework sounds more interesting...&nbsp; ;)</div>
    <div class="meta">Posted on 2008-11-05 18:44:43 by roticv</div>
   </div>
   <div class="post" id="post-206240">
    <div class="subject"><a href="#post-206240">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">I&#039;ve decided to start posting code today.<br />This code will be subject to change without notice, so consider it as a &#039;sneak preview&#039; - in future, the latest version of OA32 will always contain the most recent PUBLIC version of the code.<br /><br />Today we&#039;ll take a walk around inside the main object, whose name is NetEngine.<br />This component is the hub of the engine - it acts as a &#039;front end&#039; for creating new networking connections, and it is the heart of the resource management.<br /><br />Let&#039;s see that code, then talk about it.<br /><br />(code attached due to character limit)<br /><br />It&#039;s a lot to take in, so take your time.<br />NetEngine implements several &#039;object pools&#039;, where Pool is a subclass that supports fast recycling of previously created objects - rather than simply release an object when we are done with it, we toss it into a recycling pool, and when we need a new one, we check if theres any languishing in the pool, preferring to reinitialize a dead object than allocate a new one... this is much quicker, and reduces fragmentation of heap memory (where these guys all live).<br /><br />Disregarding the structures and equates for the time being, the obvious place to start is the Constructor method, whose name is &#039;Init&#039;.<br />This method takes three parameters, which are mainly aimed at server applications.<br />They are MinClients, MaxClients, and MaxIOJobs.<br />The Init method creates a half dozen objects which are used to manage various resources, such as pooling objects for IOJobs, inbound clients, outbound clients, and listening clients.<br />Its also responsible for kickstarting WinSock.<br /><br />MinClients declares the minimum number of &#039;pending accepts&#039; for server apps.<br />MaxClients sets the upper limit of the ClientPools.<br />MaxIOJobs sets the upper limit of the IOJobPool.<br />The Init method will check how many &#039;logical cpu devices&#039; your hardware supports, and create one Worker Thread for each logical cpu device.<br />I&#039;ll be talking more about the Worker Threads later - they&#039;re the grunt.<br /><br />The Init method also creates an object called ClientGroup.<br />This object gives us a way to organize clients into named groups, which exist in a tree structure.<br />You can think of a ClientGroup as being a &#039;communication channel&#039;, or if you like, a &#039;chatroom&#039;.<br />NetEngine does not care how you use client groups, or what they are for - its just a way to issue data to a bunch of clients at once.<br /><br />The Destructor method, whose name is &#039;Done&#039;, simply cleans up all these internal resources and shuts down WinSock.<br /><br />In order to use NetEngine, whether as a client, a server, or both, you must first initialize it via the Init method.<br />Having done that, you have three major functions that you can call.<br />Their names are ConnectTo, Listen, and UDP_Broadcast.<br />All three of these methods take a pointer to a user-supplied &#039;Protocol Handler&#039;.<br />This is an object YOU write, which implements the rules of your network protocol, and is derived from the vanilla protocol handler &#039;NetworkProtocol&#039;.<br />Each of these three methods, assuming it succeeded, returns a pointer to a Client object.Your application can manage these, and/or add them to a new or existing ClientGroup.<br />Its important to realize that the Client object is mostly a wrapper for a socket handle, and typically represents a udp or tcp session... however, it can also represent a &#039;listener&#039;, which is a socket that listens for inbound connections.<br /><br />If you call the Listen method, NetEngine will create a new listening socket bound to a given port, and it will then issue a number of &#039;pending accepts&#039;.<br />We use this to make a Server listen on a given port, using a given protocol handler - we can have as many listening ports as we like, but each is associated with just one protocol handler (not necessarily unique - handlers can be shared).<br /><br />If you call the ConnectTo method, NetEngine will issue a connect attempt to a given remote host ip and port, using a given protocol handler.<br /><br />And if you call UDP_Broadcast, a udp client is created, and given data is sent to the given broadcast ip / port.<br /><br />When a network event completes (whether successful or not), one of our Worker Threads will wake up and forward that notification , via a specific Client object, to that Client&#039;s protocol handler.<br />It&#039;s up to you what to do with that notification, probably you will want to inform the Application, perhaps via a Windows Message, that something just happened.<br /><br />The base NetworkProtocol class is fairly well commented, and I&#039;ll be posting examples as I build them.<br />So far we have a working &#039;echo server&#039; and &#039;echo client&#039; protocol handlers, and test applications that use them.<br /><br />Please note that I have previously used this framework to implement a full chatserver with lots of bells and whistles, so I&#039;m not working with code that &#039;might&#039; work - it works well.<br /><br />So from the programmer&#039;s perspective, in order to support a new protocol, you need only to write a new protocol handler class, which derives from NetworkProtocol.<br /><br />In the next post, we&#039;ll start looking at some of the resource classes, and how they all fit together.<br />And in particular, we&#039;ll be looking at IOJob and the Pooling system.</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2643" target="_blank">NetEngine.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2008-11-05 22:18:49 by Homer</div>
   </div>
   <div class="post" id="post-206249">
    <div class="subject"><a href="#post-206249">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">Before I go ahead and post more code, I just wanted make a brief progress report regarding the implementation of &#039;port forwarding / nat traversal via upnp&#039;.<br /><br />I just spent some days trying to translate an obscure XML parser.<br />Then it occurred to me that I don&#039;t need to &#039;correctly&#039; parse the xml, just be able to parse the stuff I really need.<br />So I fired up my packetsniffer, and captured all the packets involved, and analyzed them to determine what the heck was actually happening in there.<br />Then I wrote cheesy parsing code to rip out the stuff that interests me.<br /><br />I am now able to:<br />1 - obtain the ip and port for the upnp device controller (this is udp, the rest is tcp)<br />2 - query the upnp controller for more information, including the url for requesting the EXTERNAL ip address<br />3 - query that url to obtain the external ip address<br /><br />Now I think I have everything I need to actually create new port-forwardings (port mappings).<br /><br />Yes, there are other ways to obtain the external ip address, but those won&#039;t help us get the values we need to send commands to the upnp controller, so I followed the upnp way of doing everything.<br /><br />I&#039;m a few steps closer to implementing transparent forwarding of listening ports :)<br /><br />The questions on my mind now : should NetEngine.Listen take as params both the internal AND external ports, or should they always be the same? What happens if an external port is already mapped, and we try to map it to &#039;another&#039; internal port? Does this cause packet duplication? etc.<br /><br /></div>
    <div class="meta">Posted on 2008-11-07 01:23:15 by Homer</div>
   </div>
   <div class="post" id="post-206250">
    <div class="subject"><a href="#post-206250">Re: An organic allegory of the object relationships</a></div>
    <div class="body">I consider NetEngine to be the &#039;heart&#039; of the engine, which implies that there is stuff &#039;below&#039; it, and &#039;above&#039; it (ie, if NetEngine is the Heart, then there&#039;s probably a Brain above it, and perhaps some Legs and some Feet below it). I&#039;ll now go on to describe the engine from the bottom up - we can&#039;t understand the highest level objects without knowing something about the lowest level objects... suffice to say that low level objects represents resources and resource managers, and high level objects implement the logic that drives everything. <br />You&#039;ve seen the NetEngine object, and I&#039;ve stated that one of its main functions is to manage resources via some lower-level resource management objects.<br />The other main function of NetEngine is to marshal event notifications to the highest level of the engine (protocol handlers), along with pointers to the resource objects associated with these events.<br /><br />As mentioned previously, NetEngine uses several &#039;pools&#039; to recycle objects.<br />Attached is the Pool class.<br />This is a baseclass for managing objects that we wish to recycle.<br />It does not know what kind of objects, and it does not care.<br />The Pool class simply provides methods to create new recyclable objects, cache &#039;redundant&#039; objects, and recycle these objects when possible.<br /><br />Deriving from (built on top of) the Pool class are two classes called IOJobPool and ClientPool.<br />These are a little more specialized in that they DO know what kind of objects they are managing, and know how to initialize them.<br />I&#039;ve attached them as well.<br /><br />Take a look over these objects, and look at what is going on in there, since they&#039;re mentioned a lot in the NetEngine object.<br />I won&#039;t say anything further about these three objects unless you guys ask me to.<br />They&#039;re just resource management.<br /><br />The really interesting stuff happens in the remaining classes.<br />Next time I post, we&#039;ll be looking closely at the IOJob object.<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2645" target="_blank">Pool.inc</a></li>
      <li><a href="../../attachments/?id=2646" target="_blank">ClientPool.inc</a></li>
      <li><a href="../../attachments/?id=2647" target="_blank">IOJobPool.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2008-11-07 01:54:21 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29180&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29180&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29180" /><input type="number" name="page" min="1" max="3" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29180&amp;page=2">&gt;</a><a href="../?id=29180&amp;page=3">&raquo;</a></form>  </div>
 </body>
</html>