<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>NetEngine - an IOCP server/client framework for ObjAsm32 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29180" />
  <link rel="prev" href="../?id=29180&amp;page=1" />  <link rel="next" href="../?id=29180&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=8">Networking</a> &raquo; <a href="../?id=29180">NetEngine - an IOCP server/client framework for ObjAsm32</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29180&amp;page=1" style="">&laquo;</a><a href="../?id=29180&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29180" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=29180&amp;page=3">&gt;</a><a href="../?id=29180&amp;page=3">&raquo;</a></form>   <div class="post" id="post-206255">
    <div class="subject"><a href="#post-206255">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">In order to perform asynchronous networking operations with an IOCP, we need to use &#039;overlapped io&#039;.<br />And in order to use overlapped socket io, we need to use a structure called WSAOVERLAPPED.<br />This structure is a wrapper for another structure called WSABUF, which is a container for a relatively small IO buffer used to send and receive data.<br />Most of the asynchronous socket api require that we supply these &#039;overlapped&#039; structs rather than simply handing a pointer to a buffer.<br />It is standard practice to extend the WSAOVERLAPPED structure in order to keep more information about the contents of the buffer... I called mine XOVL - &#039;extended overlapped&#039;.<br />But I didn&#039;t want to be working with mere structures... I wanted to make the XOVL into an OA32 class object, so that I could associate code methods with this data structure. Thus IOJob was born.<br /><br />IOJob is a wrapper for XOVL which is a wrapper for WSAOVERLAPPED which is a wrapper for WSABUF which is a wrapper for our data buffer... phew!<br /><br />Each IOJob contains a pointer to the Client which issued it, so when an io operation completes, NetEngine can marshal the completion notification to the very Client who &#039;owns&#039; it. This is quite logical to me, and means that a Client can have any number of concurrent jobs pending completion.<br />Furthermore, IOJob is tagged with an &#039;operation code&#039; which tells us whether the IOJob represents a recv, send, accept or some other kind of operation.<br /><br />There&#039;s not a whole lot to see in this class as its mainly a container for data - next post will show the Client object, which is vastly more interesting.<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2648" target="_blank">IOJob.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2008-11-07 20:08:31 by Homer</div>
   </div>
   <div class="post" id="post-206258">
    <div class="subject"><a href="#post-206258">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">The real action happens in the Client class.<br /><br />Here we can find methods for performing network operations (&#039;queueing iojobs&#039;), which we can think of as &#039;event sourcing&#039;.<br />There are also methods for responding to &#039;completion notifications&#039;, which we can think of as &#039;event sinking&#039;.<br /><br />If we call a Client method such as &#039;QueueRead&#039; or &#039;QueueWrite&#039;, an IOJob is allocated and an asynchronous socket api is called.<br />NetEngine has one &#039;Worker Thread&#039; per logical cpu, these threads are essentially sleeping, waiting for an IOJob to complete.<br />When the IOJob completes, one of these &#039;Worker Threads&#039; will wake up, and it will determine which Client issued that job, and notify that Client via one of the &#039;OnXXXCompleted&#039; methods, passing the Client a pointer to the completed IOJob.<br />The Client will then pass that notification on to its Protocol Handler, which has a similar set of &#039;event sink&#039; (OnXXXCompleted) methods.<br />What we do in response to this notification depends a lot apon the protocol we are implementing.<br />For example, let&#039;s say we received some data (a Read job completed).<br />The Client who issued that Read job will notify the Protocol handler, who can then examine the data - we might want to send some data back in response by issueing a Write job. Protocol handler might also communicate with the Application, so that the user can see something on the application&#039;s window.<br /><br />So now we have a fairly complete picture of what is happening in regards to NetEngine&#039;s notification marshaling scheme, and we can see that the Protocol handler class is where the actual logic is implemented.<br /><br />I&#039;ve provided an abstract class called NetworkProtocol which allows NetEngine to communicate with classes that you, the programmer, derived from NetworkProtocol... ie, its a Base class,h your own protocol handling class or classes should inherit from NetworkProtocol, overriding its methods as you see fit. Of course you can add extra methods in your derived protocol handlers, that&#039;s completely up to you.<br /><br />Attached are the classes called Client and NetworkProtocol.<br /><br />Just because I am a nice guy, I have attached two more classes called EchoClientProtocol and EchoServerProtocol.<br />These example classes can be used to implement example applications which implement a simple echo client and echo server.<br />If the client sends some data to the server, the server sends it back to that client.<br />The client protocol handler just communicates with an application in order to fetch data (perhaps from an EDIT control) to send, and to display data that has been echoed by the server.<br />This is not really a network protocol - just the most simple example of what a derived protocol handler class might look like.<br /><br />With these files you should be able to put together a working application.<br />If you&#039;d like to see an example application project that uses these files, I can provide that too, the echo client and server projects will certainly be bundled with NetEngine in future releases of ObjAsm32 :)<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2649" target="_blank">NetworkProtocol.inc</a></li>
      <li><a href="../../attachments/?id=2650" target="_blank">Client.inc</a></li>
      <li><a href="../../attachments/?id=2651" target="_blank">EchoClientProtocol.inc</a></li>
      <li><a href="../../attachments/?id=2652" target="_blank">EchoServerProtocol.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2008-11-08 01:34:08 by Homer</div>
   </div>
   <div class="post" id="post-206278">
    <div class="subject"><a href="#post-206278">Re: stronger and better than ever</a></div>
    <div class="body">Several small issues in NetEngine have been addressed over the past couple of days, including some &#039;potential&#039; memory leaks, and some protection against untimely thread switching screwing up critical operations (the thread scheduler can be a real pain, but we don&#039;t want completely synchronous behaviour or we may as well not be using IOCP at all).<br /><br />Some code in the Client class has been moved into a new method called IOJob.Cut, this method can trim a given number of bytes from the start of that job&#039;s buffer, or if we try to cut all the buffered data, or more than that, then IOJob.Reset will be called, which quickly resets the IOJob to default state.<br /><br />More interestingly, I&#039;ve made some serious progress with the upnp nat traversal protocol, and embedded it directly into NetEngine.<br />Now when we initialize NetEngine, a udp broadcast is sent (discovery of upnp device controller), which will then either trigger a tcp query of the upnp device controller for the external ip address (needed when we want to create port mappings aka port-forwarding) and NetEngine.Init will return pThis=success, or the udp broadcast will time-out, and NetEngine.Init will return zero=failed.<br /><br />I&#039;ll probably make this a little more friendly, perhaps inform the user about the failure through a messagebox, including possible reasons why upnp is not working and how to fix it - because really this only affects applications which want to accept incoming connections (servers and server-clients, not simple outbound client apps).<br /><br />Now I just need to implement code to automatically create port-mappings (port forwarding) whenever the NetEngine.Listen method is called (and if I&#039;m nice, to remove them when the listening port is closed).<br />This is what I really wanted!<br /><br />Better still, I&#039;ve made major improvements to the way that NATUPNPProtocol parses http packets.<br />And this forms a good foundation for a robust general-purpose HTTPProtocol class, which is something I&#039;d like to do in a future project.<br /><br />I will post an update of all files as soon as I&#039;ve added the code I mentioned, and tested it thoroughly.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-11-10 05:44:43 by Homer</div>
   </div>
   <div class="post" id="post-206307">
    <div class="subject"><a href="#post-206307">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">I&#039;ve finished implementing automatic forwarding of Listening ports via upnp.<br /><br />It works great, however I did a little more work than was necessary.<br />You don&#039;t actually need to discover the external IP address !!!<br />You only need to discover the upnp controller&#039;s ip and port via the udp broadcast packet, and then you&#039;re ready to create port mappings.<br /><br />Furthermore, there&#039;s no harm in &#039;recreating&#039; (or editing) an existing port mapping - the response is identical to that returned when creating a &#039;new&#039; one.<br /><br />Now I just have to get in touch with my beta testers, ensure it all works for them too, and then I can post this stuff.<br /><br /></div>
    <div class="meta">Posted on 2008-11-13 18:01:09 by Homer</div>
   </div>
   <div class="post" id="post-206314">
    <div class="subject"><a href="#post-206314">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">An important addition was made to NetEngine today.<br />Remember me saying that IOCP can be used for more than just socket io?<br />It is now possible for a user to define their own io job types.<br /><br />NetEngine&#039;s defined job types are now:<br /><br />OPERATION_ENDED 	equ 0<br />OPERATION_DOACCEPT&nbsp; equ 1<br />OPERATION_DOWRITE	equ 2<br />OPERATION_READ		equ 3<br />OPERATION_CONNECT	equ 4<br /><br />Any positive value outside of this range is available for any purpose you see fit.<br />New methods Client.OnUserIOCompleted and NetworkProtocol.OnUserIOCompleted have been added.<br />Therefore your user-defined job types will be passed to your protocol handler apon completion.<br /><br />In order to trigger such a completion event, do the following:<br />-Call Client.AllocateJob to obtain an IOJob<br />-Set the IOJob.xovl.operation field to your user-defined operation value<br />-call PostQueuedCompletionStatus api function.<br /><br />Your completion event will be serviced asynchronously as soon as possible, generally by another thread.<br />Example uses for user-defined completion notifications are playing sound effects, and reacting to collisions.<br />This allows you to write eventing methods with names like MyGameProtocol.OnPlayerDied which won&#039;t block the thread that issued the event!<br /><br /></div>
    <div class="meta">Posted on 2008-11-13 23:23:23 by Homer</div>
   </div>
   <div class="post" id="post-206318">
    <div class="subject"><a href="#post-206318">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">The new OnUserIOCompleted method has allowed me to better control the sequencing of operations under a network protocol - in fact, it will become a critical tool for the user to develop their own network protocol handlers to be immune to the bad effects of the thread scheduler.<br /><br />Furthermore, I&#039;ve added a final fallback test to NetEngine.Init method - if the user requests &#039;automatic port forwarding&#039;, and upnp discovery fails, NetEngine will check if the local machine&#039;s ip address falls within one of the three IANA-assigned private ip blocks.<br />If it does, NetEngine will alert the user via a YES/NO messagebox, telling them that their server can only work on their LAN, and cannot accept clients from the internet.<br /><br />Everything is falling into place :)<br /><br />Now I await feedback from my betatesters, then I&#039;ll post updates of all the files.<br /><br />Biterider has been putting together his own works based strongly on mine, thats fine as long as this beast is available to OA32 programmers in some form, heh.<br /><br />Honestly I can&#039;t wait until this project is complete.. With the new &#039;user-defined operations&#039; methods in place, it is looking like the heart and soul of a game engine, which is my goal !!<br /><br />I think OA32 is very suited to game development, and that&#039;s what I wanna do next.<br /><br /></div>
    <div class="meta">Posted on 2008-11-15 03:03:55 by Homer</div>
   </div>
   <div class="post" id="post-206332">
    <div class="subject"><a href="#post-206332">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">So far I have reports back from half of my beta testers, and so far no problems!<br />I&#039;ve just added some basic protection against &#039;zombie denial of service&#039; attacks which likely I will make a bit smarter in the near future... currently the tolerance to pain is hardcoded, it would be nice if the server side of the engine was able to detect these attacks, and scale down its tolerance to pain accordingly, for as long as the attack persists... then start to relax when the attack ceases.<br /><br /><br /></div>
    <div class="meta">Posted on 2008-11-18 09:10:02 by Homer</div>
   </div>
   <div class="post" id="post-206337">
    <div class="subject"><a href="#post-206337">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">Here is a current update of all the NetEngine components, with the exception of the EchoServer and EchoClient demos and related protocol plugins.<br />For those of you who are truly interested, this will present hardly any problem.<br />The rest of you will have to wait for the official release in the next ObjAsm32 update.<br /><br />This project is still in a state of growth, so I will not yet say this is the final state of the code, but it is certainly the current state, and I can&#039;t give more than I am giving now. This is two years of my spare time, and counting.<br /><br />Have fun!<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2660" target="_blank">NetEngine.inc</a></li>
      <li><a href="../../attachments/?id=2661" target="_blank">Pool.inc</a></li>
      <li><a href="../../attachments/?id=2662" target="_blank">ClientPool.inc</a></li>
      <li><a href="../../attachments/?id=2663" target="_blank">Client.inc</a></li>
      <li><a href="../../attachments/?id=2664" target="_blank">IOJob.inc</a></li>
      <li><a href="../../attachments/?id=2665" target="_blank">NetworkProtocol.inc</a></li>
      <li><a href="../../attachments/?id=2666" target="_blank">UPNPNATProtocol.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2008-11-19 01:44:53 by Homer</div>
   </div>
   <div class="post" id="post-206338">
    <div class="subject"><a href="#post-206338">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">I noticed that I missed IOJObPool.<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2667" target="_blank">IOJobPool.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2008-11-19 23:49:43 by Homer</div>
   </div>
   <div class="post" id="post-206339">
    <div class="subject"><a href="#post-206339">RE : MMOG for the masses</a></div>
    <div class="body">My next task will be to write LobbyServer and LobbyClient demos.<br />A LobbyServer is a server whose purpose is to track GameServers and statistics of players, and perform Authentication (aka Logins) - it is the root server of a multihomed gaming network.<br />People who wish to run a GameServer will connect to the LobbyServer to advertise their presence.<br />GameClients will connect to the LobbyServer in order to receive a list of available GameServers.<br />This means that individual GameServers are not the ultimate authority, and if we detect that people are running &#039;hacked servers&#039;, they can be pruned from the network efficiently.<br /><br />The GameClient would contain both LobbyServer and LobbyClient components, allowing players to Host a game, and simultaneously allow them to Join a game, on their own GameServer, or on another GameServer.<br />Given appropriate bandwidth, it would be ok to run multiple GameServers, and multiple GameClients from a single ip.<br /><br />GameServers interact via the LobbyServer, which makes it possible to create a huge virtual world, where players are passed from one GameServer to another when they pass a border of the game environment (Massively Multiplayer Online Games).<br /><br />The abbreviated terms MMOG and MMORPG are heavily abused by marketing monkeys, and it&#039;s easy to forget what they mean... take WolfTeam for example, a dozen or so players per game is NOT massively multiplayer, no matter what they say - it&#039;s not relevant how many individual games are running, it&#039;s about how many players can fit into the same virtual space - and multihomed networks are the key to implementing truly massive worlds which are inhabited by massive numbers of players.<br /><br /></div>
    <div class="meta">Posted on 2008-11-21 03:26:27 by Homer</div>
   </div>
   <div class="post" id="post-206344">
    <div class="subject"><a href="#post-206344">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">A small change made to the Client cleanup code.. the Done and Goodbye methods are slightly altered to prevent the (Client)Pool from attempting to release object resources more than once when the application is closed.<br /><br />Also, I&#039;ve added some comments regarding the use of SO_LINGER with respect to nonblocking sockets and a nonzero linger time (see Client.Goodbye)... this seems to be a very much misunderstood aspect of socket programming (msdn recommends not doing it, but doesn&#039;t do a good job of explaining the implications).<br /><br />Please note that Client.Goodbye should not be called directly by the user - instead, you should be calling NetEngine.GoodbyeClient, which will ensure that the object is recycled correctly.<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2669" target="_blank">Client.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2008-11-21 23:25:45 by Homer</div>
   </div>
   <div class="post" id="post-206355">
    <div class="subject"><a href="#post-206355">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">I&#039;ve made a few more small bugfixes and improvements.<br /><br />While playing around with client http sessions using the KEEP-ALIVE semantic, I found that webservers will sometimes terminate your session, and completely ignore the fact that we requested the session to remain open.<br />This can be a problem if we were not expecting it / were not finished talking to that server.<br /><br />There&#039;s a new method in the Client and NetworkProtocol classes, its name is OnDisconnected.<br />If we detect that a connection has been lost, this method sinks that event, which gives us a way to recover from unexpected session termination.<br />For example, if we determine that the session terminated prematurely, we might want to try to reconnect to the server in order to finish what we were doing.<br /><br />I won&#039;t post it just yet because I want to test the recovery mechanism a little more.<br /><br /></div>
    <div class="meta">Posted on 2008-11-26 17:36:14 by Homer</div>
   </div>
   <div class="post" id="post-206356">
    <div class="subject"><a href="#post-206356">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">The server side can terminate the connection at <strong>any</strong> time. Some do it because of security reasons, some do it because they&#039;re bugged, some do it because of network problems. Please take that into consideration if you want to &quot;shutdown gracefully&quot; in response to abnormal situations.</div>
    <div class="meta">Posted on 2008-11-26 21:21:35 by ti_mo_n</div>
   </div>
   <div class="post" id="post-206363">
    <div class="subject"><a href="#post-206363">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">Yep, I&#039;m quite aware of that (now)... although strictly speaking what I was describing is a violation of the http 1.1 protocol, the fact remains that it CAN happen, and the Client needs to be stateful enough to at least attempt to resume a session that was terminated unexpectedly.<br />In fact, one of the new features of NetEngine is automatic pruning of Zombie Clients to avoid DoS attacks... a Client must send one complete and valid &#039;protocol packet&#039; to the Server within 5 seconds of connecting, or it gets booted, regardless of the Protocol being used... a &#039;supervisor&#039; thread enforces this asynchronously. This means that an attacker would need to be aware of the details of the mechanism in order to perform a successful DoS attack, and if I see that ever happen I will immediately add a second layer of protection and make an update available.<br /><br />Today I moved a number of the object definitions from their individual class files into NetEngine.inc, which allows all these classes to act as &#039;friends&#039;, to know each other more intimately. The reason was to allow Client.Done to check whether NetEngine is closing down before attempting to release client-specific resources, and avoid a potential GPF there... on the upside, it is now possible for all the affected classes to call methods and to read and write the class variables in all the &#039;friend&#039; classes.... I may even extend this to make ALL the classes in this project friendly to each other.<br /><br />I know that Biterider has been using such a scheme in his version of this project for some time now, for the very same reason... but I had avoided it because I don&#039;t like seeing all the object definitions in one file, and code separate from them in other files - I&#039;ve requested that he modify the MakeObjects macro to check for &quot;.h&quot; files and defer the inclusion of .inc files until ALL the headers have been collected, but I also know that he has not got a lot of free time, and I know that it would probably require a new macro to &#039;finalize&#039; the build process.<br /><br />Perhaps MakeHeaders and MakeObjects would be suitable to avoid this situation?<br /><br />Anyway, since all the objects in NetEngine are exclusive to this project, I am willing to pull those headers out into NetEngine.inc as I have described... but it&#039;s not a solution for more generic objects.<br /></div>
    <div class="meta">Posted on 2008-11-29 23:21:26 by Homer</div>
   </div>
   <div class="post" id="post-206366">
    <div class="subject"><a href="#post-206366">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">Last night I made an important and interesting change to the NetworkProtocol class.<br />I&#039;ve moved all the &#039;event sinking&#039; methods into a new ancestor class:<br /><br /><pre><code><br />;NetEventSink decribes the &#039;event sinking&#039; methods of NetworkProtocol,<br />;it&#039;s been defined separately in case you wish to implement<br />;an eventsink in the APPLICATION, that your derived protocol handler<br />;can forward event notifications to.. which can be a handy thing.<br />NAES equ 346766<br />Object NetEventSink,NAES,Primer<br />&nbsp; DynamicAbstract	OnReadCompleted,			Pointer,Pointer,dword,dword	 ;pClient, pXOVL, dwBytes, dErrorCode<br />&nbsp; DynamicAbstract OnWriteCompleted,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Pointer,Pointer,dword&nbsp; &nbsp; &nbsp; &nbsp; ;pClient, pXOVL, dwBytes<br />&nbsp; DynamicAbstract	OnConnectCompleted,			Pointer,dword	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;-&gt; Client, dErrorCode<br />&nbsp; DynamicAbstract OnDisconnected,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Pointer,dword&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;-&gt; Client, dErrorCode<br />&nbsp; DynamicAbstract OnAcceptCompleted,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pointer,dword	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;-&gt; Client, dErrorCode<br />&nbsp; DynamicAbstract OnUserIOCompleted,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pointer,Pointer,dword&nbsp; &nbsp; &nbsp; &nbsp; ;pClient, pJob, dError<br />&nbsp; DynamicAbstract	OnClientQuit,				Pointer			&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;-&gt; Client<br />ObjectEnd<br /><br />NetworkProtocolID equ 23543<br />Object NetworkProtocol,NetworkProtocolID,NetEventSink<br />&nbsp; RedefineMethod&nbsp; &nbsp; Init,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Pointer, Pointer&nbsp; &nbsp; ;pOwner, lpAppEventSink<br /><br />&nbsp; DynamicMethod	&nbsp; FindDelimiter,	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pointer,Pointer 		 ;pClient,pxovl<br />&nbsp; DynamicMethod	&nbsp; ProcessReceivedData,		Pointer&nbsp; &nbsp;  			 ;pClient<br /><br /><br />&nbsp; RedefineMethod&nbsp; &nbsp; OnReadCompleted,			Pointer,Pointer,dword,dword	 ;pClient, pXOVL, dwBytes, dErrorCode<br />&nbsp; RedefineMethod&nbsp; &nbsp; OnWriteCompleted,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Pointer,Pointer,dword&nbsp; &nbsp; &nbsp; &nbsp; ;pClient, pXOVL, dwBytes<br />&nbsp; RedefineMethod	OnConnectCompleted,			Pointer,dword	&nbsp; &nbsp;  ;-&gt; Client, dErrorCode<br />&nbsp; RedefineMethod&nbsp; &nbsp; OnDisconnected,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Pointer,dword&nbsp; &nbsp; &nbsp; &nbsp; ;-&gt; Client, dErrorCode<br />&nbsp; RedefineMethod&nbsp; &nbsp; OnAcceptCompleted,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pointer,dword	&nbsp; &nbsp;  ;-&gt; Client, dErrorCode<br />&nbsp; RedefineMethod&nbsp; &nbsp; OnUserIOCompleted,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pointer,Pointer,dword&nbsp;  ;pClient, pJob, dError<br />&nbsp; RedefineMethod	OnClientQuit,				Pointer			&nbsp; &nbsp;  ;-&gt; Client<br /><br />&nbsp; DefineVariable&nbsp; &nbsp; lpAppEventSink,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Pointer, NULL<br />ObjectEnd<br /></code></pre><br /><br />The idea is that you can add a derived NetEventSink in your application, and inform NetworkProtocol via the Init method... If you do this,&nbsp; NetworkProtocol will notify the Application&#039;s event sink after the Protocol methods have executed and before NetEngine sees the result.<br />This arrangement has two benefits.<br />1: We have a general-purpose mechanism for passing notifications to the Application.<br />2: We have a means to override some of the default behaviour of the protocol handler, even if the protocol handler is enshrined in the form of a pluggable object such as a DLL, without screwing around with the code in there.<br /><br /></div>
    <div class="meta">Posted on 2008-11-30 17:58:27 by Homer</div>
   </div>
   <div class="post" id="post-206368">
    <div class="subject"><a href="#post-206368">Re: LobbyServer - Find your friends, find a host server, advertise as a host</a></div>
    <div class="body">As mentioned, I&#039;ve been working on a demo &#039;Lobby Server&#039; and client.<br />I&#039;m interested in developing online games, but this could be used for a multihomed chat system such as Yahoo or IRC, it could be used for a centralized filesharing network, or dozens of other purposes.<br /><br />A database of user accounts has been implemented, and Authentication of account via user/pass is also implemented.<br /><br />User Account records contain username, password, and optionally, email address.<br />If you attempt to authenticate a username which does not exist, the account will be created automatically for you, and your client will be notified of this.<br /><br />You don&#039;t have to supply an email address, but if you don&#039;t (or its not actually valid), and you forget your password, there will be no way for you to reclaim your account !!!<br /><br />I haven&#039;t implemented password recovery yet, because I don&#039;t have any email protocol handler written at this stage.<br /><br />If a client fails authentication (due to wrong password, the only possible reason), the session is terminated.<br />But if auth succeeds, the session remains open so that the client can make further requests, such as obtaining a list of potential hosts, advertising as a host, or enquiring as to the current location of a specific user.<br /><br />Again, nothing beyond account authentication / creation has been implemented yet, however it won&#039;t take long to add the code to handle all these tasks.<br /><br />Also, I am thinking about replacing the EMAIL record with an &#039;answer to secret question&#039; as some other existing servers already do.<br />This would allow the user to recover (or at least reset) their password *without* requiring an email address, or me having to write a protocol handler for email.<br />Finally, I am thinking about replacing the plaintext password with a hash - you wouldn&#039;t be able to recover your password, because the server would not keep the password, only the hash... it also means that bad guys can&#039;t capture your password with a packet sniffer - they could still perform &#039;replay attacks&#039;, I guess no system is perfect but sending plaintext is a bad idea - maybe encrypting the entire session with a random session key would be the way to fly, that would certainly prevent replay attacks, and make it difficult to reverse engineer the protocol.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-11-30 22:15:34 by Homer</div>
   </div>
   <div class="post" id="post-206369">
    <div class="subject"><a href="#post-206369">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">Having moved past the authentication stuff (I&#039;m sure I&#039;ll revisit that), the next step was to implement the code for clients to advertise as a host server, for the lobbyserver to add host servers, for the clients to fetch a list of host servers, and for the lobbyserver to build and send that list.<br />All of this has been done, however there&#039;s some simple design flaws that need to be taken care of.<br />I&#039;ve noticed that the Server is not setting the socket address of the remote clients it accepts.... their ip address appears to be 0.0.0.0, which is obviously wrong.<br />That&#039;s cool, I&#039;ll call getpeeraddress after accept completes (in NetEngine) and that will take care of it.<br />It&#039;s good to find this out, it&#039;s obviously slipped under the radar.<br />By tomorrow, I&#039;ll basically have the LobbyServer and LobbyClient stuff completed, except for the security aspects, which I have already mentioned.<br /><br />That will mean I can temporarily shut the book on the Lobby stuff, and move on to the more interesting (for me) GameServer/GameClient, which is my goal !!!<br />Multihomed massively multiplayer online gaming, here I come !!!</div>
    <div class="meta">Posted on 2008-12-01 23:26:15 by Homer</div>
   </div>
   <div class="post" id="post-206370">
    <div class="subject"><a href="#post-206370">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">Homer,<br /><br />I do not like the concept of the server storing the passwords. I think it is much better for the server to store the hash of the password. As to resetting password, why not regenerate a random password and send to the email? Allow the user to change only after he logs in with the new generated password.</div>
    <div class="meta">Posted on 2008-12-01 23:53:43 by roticv</div>
   </div>
   <div class="post" id="post-206371">
    <div class="subject"><a href="#post-206371">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">These are all ideas I have already mentioned, and I completely agree.<br />I also mentioned replay attacks, where a hash is not good enough by itself - there needs to be a session-key which encrypts the data, then it doesn&#039;t really matter if its a hash or a password, except in terms of the size of the data.<br /><br />Since the session key (which forms the basis of the encryption key) is only valid within the context of a single session, a replay attack simply won&#039;t work - the Server will attempt to use a new session key to decrypt the client&#039;s data (which has been encrypted with an OLD session key) - resulting in garbage, which will be rejected by the protocol handler and result in the client being disconnected.<br /><br /></div>
    <div class="meta">Posted on 2008-12-02 00:00:17 by Homer</div>
   </div>
   <div class="post" id="post-206375">
    <div class="subject"><a href="#post-206375">Re: NetEngine - an IOCP server/client framework for ObjAsm32</a></div>
    <div class="body">An important change was made to the Client.OnAcceptCompleted method - I&#039;m now using the GetAcceptExSockaddrs api to grab both the local and remote socket address structures and copying them into the newly-accepted Client. This is very important since we can&#039;t know what the remote ip address of a client is until accept has completed, and we cannot use the getpeername api on unbound sockets.<br />Now that I can obtain the ip of the remote client, I can do things like comparing it against a black/white list if I decide I want to ban people for some reason.<br /><br /><br /></div>
    <div class="meta">Posted on 2008-12-02 08:01:34 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29180&amp;page=1" style="">&laquo;</a><a href="../?id=29180&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29180" /><input type="number" name="page" min="1" max="3" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=29180&amp;page=3">&gt;</a><a href="../?id=29180&amp;page=3">&raquo;</a></form>  </div>
 </body>
</html>