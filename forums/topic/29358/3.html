<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Homer's GameDev Blog - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29358" />
  <link rel="prev" href="../?id=29358&amp;page=2" />  <link rel="next" href="../?id=29358&amp;page=4" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29358">Homer's GameDev Blog</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29358&amp;page=1" style="">&laquo;</a><a href="../?id=29358&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="29358" /><input type="number" name="page" min="1" max="15" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=29358&amp;page=4">&gt;</a><a href="../?id=29358&amp;page=15">&raquo;</a></form>   <div class="post" id="post-207793">
    <div class="subject"><a href="#post-207793">Re: Homer's GameDev Blog</a></div>
    <div class="body">Success tracking down that bug!<br />Here&#039;s a screen shot that shows a discovered portal.<br />The &#039;clip to faces&#039; code is still missing.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2790" target="_blank">PortalDiscovery.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-06-02 03:33:19 by Homer</div>
   </div>
   <div class="post" id="post-207802">
    <div class="subject"><a href="#post-207802">Re: Homer's GameDev Blog</a></div>
    <div class="body">Having a few problems with the &#039;clip to faces&#039; code.<br />My Portal Discovery algorithm is generally superior to the whitepapers set forth by Nathan Whitaker and Alan Baylis because each Portal is initially created to fit the dimensions of the boundingbox of the set of faces that was input to that BSPNode during tree generation.<br />This means that I don&#039;t need to clip portals to ALL the faces in the two leaves that they connect, I only need to worry about clipping portals which happen to be coplanar with those faces. Essentially its a 2D clipping problem, expressed apon a 3D plane.<br />Since the Planes (apon which our Portals are constructed) were sourced from one of the faces input to each BSPNode, we can be SURE that for any Portal, there MUST be AT LEAST ONE such coplanar face that we&#039;ll need to clip the Portal against.<br />In actual fact, many Portals have been constructed apon world surfaces that DONT HAVE ANY HOLES, so these are actually FAKE portals, and the Coplanar Clipping code should completely destroy them.<br />That&#039;s logical if you think about it - a Portal is a hole in the world geometry that connects two places... if theres no hole, there can&#039;t really be a portal, can there?<br />Anyway, I&#039;m having trouble clearly defining the &#039;edge planes&#039; which pass through the edges of a triangle, are orthogonal to its surfacenormal, and point outwards, away from the triangle&#039;s interior.<br />The technique which &#039;back-crosses&#039; the surfacenormal against each &#039;edge vector&#039; contains a singularity.<br />I am developing an alternative solution using trig-based rotation of the surfacenormal about an arbitrary axis (defined by each edge vector) in order to construct these plane normals while avoiding the singularity.<br /><br /></div>
    <div class="meta">Posted on 2009-06-04 00:44:55 by Homer</div>
   </div>
   <div class="post" id="post-207828">
    <div class="subject"><a href="#post-207828">Re: Homer's GameDev Blog</a></div>
    <div class="body">I just spent hours going through the verbose debug spew to determine whats going wrong.<br />Turns out that the BSP Generator produces some triangle faces which are precariously close to being &#039;illegal&#039; in that they are so long and thin that they are getting close to collapsing into a single Edge - and these kind of triangles dont produce very good cross products, leading to numerical errors.<br /><br />I&#039;m thinking about scrapping my triangle splitting code, replacing the Face structure with my new Polygon class (currently being used by the Portal class). This will require extensive changes to the BSPGenerator code, but will result in the BSPGen producing fewer and nicer shapes. This leads to the observation that the face geometry stored in the BSP leaves doesnt need to be used for Rendering, so it doesnt need real vertices.<br />If I mark my face polygons with the id of the IMPORT triangle from which they were formed, then I can easily generate a list of unique import triangles which are partially visible at runtime from the IDs of the faces in the visible leaves. This will lend itself to batching too.<br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2009-06-07 13:04:27 by Homer</div>
   </div>
   <div class="post" id="post-207838">
    <div class="subject"><a href="#post-207838">Re: Homer's GameDev Blog</a></div>
    <div class="body">Making good progress.<br />Have replaced all the BSPGen stuff with Polygon class, and so far its good.<br />I import Polygons from the input Mesh instead of Faces, and I mark them with the index of the Import Triangle from which they were sourced. Then as the BSPGen splits that polygon, each resulting fragment knows which original input triangle it came from. <br />This allowed me to get rid of the D3D_VertexBuffer entirely, since I no longer intend to render the geometry I collect in the BSPTree leafnodes, I&#039;ll instead use them to build a list of which original Import triangles need to be drawn.<br /><br />The geometry we&#039;re collecting in the leaves has three purposes:<br />We use this geometry to determine what triangles to draw, for collision detection (physics etc), and we use (the coplanar) geometry to clip our Portals into shape.<br />THEREFORE WE DONT NEED REAL VERTICES FOR THIS GEOMETRY, SINCE WE DONT DRAW FROM IT DIRECTLY.<br /><br />Yet to implement the &#039;coplanar polygon clipper&#039; method, shouldnt be painful since I&#039;ve just been playing with that stuff.<br />Moving the splitting and clipping methods into the Polygon class makes more sense than ever.<br />The Portal class is starting to look a bit redundant, but I&#039;ll keep it for now as its good to have a logical container for a related set of portal polygons.<br /></div>
    <div class="meta">Posted on 2009-06-08 02:32:38 by Homer</div>
   </div>
   <div class="post" id="post-207870">
    <div class="subject"><a href="#post-207870">Re: Homer's GameDev Blog</a></div>
    <div class="body">Well, one thing I did is to define two types of geometry.<br />One is a D3D-optimized geometry format, aimed at maximum efficiency for the hardware.<br />The other is a more generic format, useful for importing/exporting with modeling software, or for your own toolset.<br /><br />In my generic format, I store all vertex elements in separate arrays, which are indexed in parallel. This way you can add and remove elements very easily. I also use 32-bit indices, so I don&#039;t run into any size problems/restrictions with things that I want to consider as a single mesh. I can also store additional topological info, such as convex polygon shapes rather than just triangle strips or lists etc. Or in the case of shadowvolumes and such, you&#039;d want edge/adjacency lists...<br />I also don&#039;t have to worry about texture/material/shader issues if I don&#039;t want to. In D3D you&#039;ll want a single mesh to have a single set of textures, materials and shaders, because you can&#039;t switch in the middle of a Draw() call. But with most geometry processing, I&#039;m not interested in that at all, I just want to process everything in a generic way.<br /><br />With this intermediary format I do all preparations, and then I &#039;compile&#039; it to D3D form. Mostly I&#039;ll use 16-bit indices to save memory. Most objects will fit into a single mesh with 16-bit indices. If not, they can be split up into multiple indexbuffers automatically. The vertices can also be sorted on index for maximum vertexcache efficiency, and that sort of thing.<br />But I don&#039;t want these restrictions during the earlier stages of processing.<br /><br />You&#039;ll shoot yourself in the foot sooner or later if you want to do everything directly with D3D-structured data.<br />An additional bonus of having your own format is that you can recycle your tools more easily when you want to move to a different type of renderer or a different vertexformat etc.</div>
    <div class="meta">Posted on 2009-06-16 08:33:46 by Scali</div>
   </div>
   <div class="post" id="post-207872">
    <div class="subject"><a href="#post-207872">Re: Homer's GameDev Blog</a></div>
    <div class="body">Scali - Yeah I have been using my own representations for some time, but nothing as clever or stream-friendly as you have decribed.<br />In this case, I&#039;ve determined that I don&#039;t need to render the geometry stored in the leaf nodes of a BSP tree - those are fragments of the import geometry, to which I can refer.<br /><br />Everyone - I&#039;ve been moving code out of the BSPGen.inc class into the Portal and Polygon classes.<br />This caused a number of small headaches, which I am happy to say have been resolved.<br />However, I am STILL yet to complete the implementation of &#039;coplanar polygon clipping&#039; required in the final stages of Portal Discovery... but I am much happier with the model overall, and believe it was worth it.<br />The &#039;utility&#039; classes became more powerful, and the &#039;driving&#039; class became more simple.<br />Also, I determined that the Direct3D intersection tests are inaccurate... far too inaccurate for me.<br />They use MMX code which is very fast, at the expense of accuracy.<br />In the end I have implemented my own Edge/Plane intersection test with a fair balance between speed and accuracy.<br />I think that&#039;s a positive outcome.<br /><br />Back to that last lingering issue !<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2009-06-17 07:28:16 by Homer</div>
   </div>
   <div class="post" id="post-207873">
    <div class="subject"><a href="#post-207873">Re: Homer's GameDev Blog</a></div>
    <div class="body">Ideas on intermediate formats:<br />http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&amp;Number=256293#Post256293</div>
    <div class="meta">Posted on 2009-06-17 07:34:55 by Ultrano</div>
   </div>
   <div class="post" id="post-207874">
    <div class="subject"><a href="#post-207874">Re: Homer's GameDev Blog</a></div>
    <div class="body">Maybe I should write a small blog of my own... Last night I decided to try and port my D3D10 code to D3D11. It only took a few hours to get it up and running. So I&#039;m ready whenever Bill decides to release the final :)<br />I&#039;m currently thinking of actually porting my current shader-based engine back to D3D9. Some of the modifications I did for going from D3D10 to D3D11 could also be done to incorporate D3D9 back into the codebase. The old D3D9 engine wasn&#039;t fully shader-based, becasue it was built on a D3D7/8 base, back in the early days. If I remove that legacy, the remaining functionality can mostly be wrapped with a few functions and ifdefs, I think. At least I&#039;d still have something that people on XP could run then :)</div>
    <div class="meta">Posted on 2009-06-18 02:22:40 by Scali</div>
   </div>
   <div class="post" id="post-207875">
    <div class="subject"><a href="#post-207875">Re: Homer's GameDev Blog</a></div>
    <div class="body">Here&#039;s a screenshot showing how much nicer things are when using the new Polygon class.<br />My code built one big rectangular portal on the plane where the &#039;shelf&#039; is (that the tigers are standing on), and then the portal was sliced with the (planes of the) left and right walls.<br /><br />It&#039;s worth noting that the triangles I&#039;m drawing for you do not exist - these are three polygons, each with 4 points, I am triangulating them for your benefit. Furthermore, I am storing all three polygons in one Portal object... all these triangles you see belong to just one portal that connects two leaf nodes !!! If I processed a real game level, I&#039;d get lots of portals, and more complex polygons. My test model is deliberately simple and deliberately orthogonal.<br /><br />Next, I need to remove any parts of the portal which are obscured by coplanar world triangles.<br />This will knock out the left and right ones, and trim the middle one so that only the shape of the &#039;hole&#039; in the foreground should remain.<br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2793" target="_blank">betterer.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-06-18 04:32:46 by Homer</div>
   </div>
   <div class="post" id="post-207883">
    <div class="subject"><a href="#post-207883">Re: Homer's GameDev Blog</a></div>
    <div class="body">Think I&#039;ve been working too hard.<br /><br />Here&#039;s the problem: we have two polygons which are coplanar (irrespective of whether they face the same way or not)... polygon A is permanent, it must remain untouched... we wish to clip away any parts of polygon B which are obscured by (are inside) polygon A.<br /><br />My solution was to construct planes which pass through each edge of polygon A (and are orthogonal to its surfacenormal and point away from the polygon), and use those planes to ATTEMPT to slice polygon B.<br /><br />Since I had other problems in my code, results at this stage were not what I expected, and so I went away to develop an intersection test for coplanar polygons to determine if slicing was actually worth doing... no intersection, no need for the clipping.<br /><br />Well, after much fuss, the best way to do the intersection test turns out to be SAT.<br />And the best implementation, in this case, would be to transform the problem into 2D.<br />Then perform a bunch of edge/edge intersection tests.<br />I was considering using a Change of Basis (3x3 Matrix) solution, where we transform the problem into a coordinate system where X=1 and represents the surfacenormal, and Y and Z are our 2D axes for our polygon points.<br /><br />I think I thought too much.<br /><br />I could just TRY to perform the clipping function using those planes I mentioned, since if these polygons do not intersect, they will not be sliced. It&#039;s just a 3D version of the SAT test, a little more expensive.<br /><br />Do you think the Basis Transform - based intersection test is worth doing?<br />Remember, the polygons are convex, but of arbitrary complexity.<br /><br /></div>
    <div class="meta">Posted on 2009-06-19 23:59:08 by Homer</div>
   </div>
   <div class="post" id="post-207884">
    <div class="subject"><a href="#post-207884">Re: Homer's GameDev Blog</a></div>
    <div class="body">I&#039;m of the opinion that even though it may sound expensive to perform the preliminary intersection check using the Mat33 ChangeOfBasis transform, but...<br />A) its still cheaper than the planar slicing, given we process the same number of edges<br />B) most of the time, the polygons wont actually intersect, so an early-out is warranted<br /><br />So yes, the case of actual intersection just became more expensive, but its also the least likely / least common case.<br /><br />Agree?<br /><br />Oh - and we dont strictly NEED to use a 3x3 Matrix solution - it can be implemented using a bunch of vec3 crossproducts and such, however noone benefits from convoluted and complex looking sourcecode, especially when it generates exactly the same binary code as a single macro invocation (a single line of sourcecode).<br />I just think that this is a good example of a problem that we can clearly define and solve using matrices, rather than simply using them because they are there.<br />The other really cool use I&#039;ve found for obscure matrices in recent years is to use the Skew-Symmetric matrix to create a new orientation matrix (from an existing one) representing a rotation about a given axis.<br /><br /></div>
    <div class="meta">Posted on 2009-06-21 00:26:19 by Homer</div>
   </div>
   <div class="post" id="post-207888">
    <div class="subject"><a href="#post-207888">Re: Homer's a happy camper</a></div>
    <div class="body">Got my problem code working, so no weird intersection tests were required.<br />It uses the &#039;edge-planes&#039; (binormals) method I mentioned to solve the problem of clipping coplanar polygons in 3D space. The bug was that I needed to flip my Binormal and PlaneD values for my edge-planes.<br /><br />Attached are a couple of images showing my results.<br />The BSP tree has two Leaf nodes, connected by a single Portal.<br />Interestingly, we can see that TWO HOLES were discovered - the Portal contains two Polygons, each containing 4 points. This is legal - these holes both connect the same subspaces, so they ARE parts of the same Portal.<br /><br />This is great, I&#039;m very happy indeed.<br />We have extracted portal geometry and connectivity information from a BSP Tree.<br />This connectivity information can be &#039;walked&#039; such as an acyclic graph, and can be used with A-* pathfinding techniques to guide our AI around the world.<br />I was tempted to construct a &#039;nav-mesh&#039; to further that end, however it might be nice if my AI can walk on the walls and ceilings etc, so I&#039;ll leave that alone for now.<br /><br />Next I will be considering carefully how to represent and implement a Constructive Solid Geometry object.<br />These are simple objects represented by small (preprocessed) BSP trees that we can &#039;add&#039; together to create more complex geometries which we might instance in our game.<br /><br />When you &#039;add&#039; two CSG objects, their BSP Trees are merged.<br />During this process, the shapes are clipped against each other, such that any &#039;hidden faces&#039; are removed, and we end up with the &#039;union&#039; of the two shapes.<br />It&#039;s a very fast and natural way to model 3D geometry, as opposed to so-called &#039;edge modellers&#039;, I am hoping that eventually it will help to accelerate development / level editing.<br />Speaking of which, I&#039;ll have to start implementing the networked editor soon.<br /><br /><br /><br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2795" target="_blank">working_A.JPG</a></li>
      <li><a href="../../attachments/?id=2797" target="_blank">working_B.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-06-22 08:39:55 by Homer</div>
   </div>
   <div class="post" id="post-207892">
    <div class="subject"><a href="#post-207892">Re: Homer's GameDev Blog</a></div>
    <div class="body">I&#039;ve written a method to perform CSG addition, allowing the importing of static geometry from other models directly into our BSP Tree. However, it&#039;s NOT a BSP Merge function.<br /><br />Given an input set of polygons, it feeds them through our existing tree, splitting them as required, until they land in the leaf nodes.<br />Then for each Leaf node, it clips the imported polygons against the faces already in that Leaf.<br /><br />The result is that our imported geometry is constrained to the interior of our leaf nodes.... the imported model is clipped so that none of it lays outside our bsp tree, and its polygons fall neatly into our leafnodes. And thats where they end up - at the end of this function, the imported geometry has been merged into the leafnode.pFaces collections.<br /><br />I see an obvious problem in that I need to deal with the Materials.<br />I&#039;ll probably tag my polygons with a ptr to the Mesh from which they were sourced, that way I avoid having to import Materials and rewrite the imported polygon material ids.<br /><br />Anyway, I like this implementation because (unlike true bsp merge) it does not increase the complexity of the tree.<br />Instead, the imported geometry is forced to conform to the tree.<br />So its ideal for interactively adding smaller features to a greater world model :)<br /><br />Next, I&#039;d like to plug my physics code back in, and have a physical entity interacting with the portal system.<br />Physical entities can move, so they can collide with walls and portals.<br />If they collide with portals, we set a variable indicating which Leaf they have moved into, and let them continue on their merry way. The physics engine will need to be updated to incorporate my new Polygon scheme.<br /><br />In fact, since it appears that they&#039;ll be sort of, well, not partners but maybe co-workers, I think its time for me to wrap the BSP and Physics classes (and some of the other components I&#039;ve already written) under a GameEngine class :)<br /><br /><br /></div>
    <div class="meta">Posted on 2009-06-23 04:21:59 by Homer</div>
   </div>
   <div class="post" id="post-207895">
    <div class="subject"><a href="#post-207895">Re: Homer's GameDev Blog</a></div>
    <div class="body">I&#039;ve added code to render the World more efficiently, leveraging the Portal information to collect a list of references to renderable polygons, and then rendering them by material. It&#039;s a recursive process which is based apon Portal visibility, it&#039;s faster than walking the BSP tree and sends less triangles to the videocard... a kind of realtime PVS. This technique is based on democode by Alan Baylis.<br /><br /><br /></div>
    <div class="meta">Posted on 2009-06-23 12:06:51 by Homer</div>
   </div>
   <div class="post" id="post-207902">
    <div class="subject"><a href="#post-207902">Re: Homer's GameDev Blog</a></div>
    <div class="body">You mean you actually go down to the polygon level when compiling a list of visible items for a given frame?<br />That&#039;s generally not a very smart thing to do, because it&#039;s very hard to generate efficient batches of polygons for the hardware. They don&#039;t like small batches, and they don&#039;t like the CPU poking in their vertex buffers all the time.<br /><br />I just use simple bounding volumes, and test for visibility on a per-mesh basis (it&#039;s hierarchical though, if at any level it sees the volume is completely &#039;inside&#039;, it stops checking). In my engine, a mesh essentially means a single object that can be fired off by a DrawPrimitive() call in D3D. Essentially a batch of polygons in a static vertexbuffer, with a material (shaders, texures etc) attached to it. So that is the most &#039;primitive&#039; thing D3D can render in one go.<br />Under about 1000 triangles it&#039;s actually more overhead to send the draw call to the hardware than it is for the hardware to draw the actual triangles.<br />In other words, if I had 1000 batches of 1 triangle, it&#039;d take about 1000 times as long as rendering 1 batch of 1000 triangles. I get the other 999 &#039;for free&#039;, so I don&#039;t really need to worry about each single triangle being visible or not. It&#039;s faster, WAY faster to just let the hardware figure that out.</div>
    <div class="meta">Posted on 2009-06-24 19:02:17 by Scali</div>
   </div>
   <div class="post" id="post-207903">
    <div class="subject"><a href="#post-207903">Re: Homer's GameDev Blog</a></div>
    <div class="body">I wont be touching the vertex buffer - I will be rewriting the index buffer - filling it, issuing a DrawIndexedPrimitive call, and repeating if necessary. This way I am making as few Draw calls as possible, with the largest batch possible.<br />I&#039;ve done this before with my DLOD terrain engine, it performed admirably.<br /><br />Your world is obviously constructed from a large number of small meshes.<br />I have to pay for lock and unlock calls, but you have to make more Draw calls and touch more pages of memory than I do..<br /><br />I won&#039;t be using meshes for ANY static features in my world - I&#039;ll only be using them for things that can move, like swinging doors and animated skinmeshes.<br /><br />As for visibility culling, well in the past I have done exactly as you suggest - and I still use sphere tests for various things, in fact our mesh instancing class does support boundingsphere visibility testing specifically for this reason.<br />But I&#039;m using a partitioning scheme and a portal system to reduce the need to perform visibility testing much beyond the immediate area around you (realtime PVS culling) - so I expect to be drawing very few polygons indeed, unless the camera is in a subspace that contains LOTS of visible portals, such as outdoor areas.<br />I can switch the culling scheme based on that premise I think.<br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2009-06-25 01:41:34 by Homer</div>
   </div>
   <div class="post" id="post-207904">
    <div class="subject"><a href="#post-207904">Re: Homer's GameDev Blog</a></div>
    <div class="body">Well, as you say, even touching indexbuffers has its toll.<br />And no, my world is not constructed from a large set of small meshes. The 1000 poly thing was just an example. I make my meshes as large as they can be. I try to keep the number of meshes as small as necessary. This way I can maximize the throughput, which means I can have very high polycount while maintaining high framerates. Most of the polys are &quot;free&quot; in the sense that making the meshes smaller doesn&#039;t really make them faster anyway, because of the draw call overhead.<br /><br />I&#039;m just saying that it&#039;s faster to not try and cull them on a polygon level, since the hardware is much faster at drawing and rejecting at polygon or even pixel level than whatever you can think of on a CPU.<br />BSP has been a performance problem ever since the introduction of hardware T&amp;L.<br />For terrain it might work, because terrain is not THAT highpoly. But if you start doing it on entire worlds with animated characters and objects and things, you&#039;re probably going to get relatively poor efficiency from the hardware, because you&#039;ll be holding the hardware up by constantly modifying its memory. It takes you far longer to sort out the polys and fill a new indexbuffer than it would take the hardware to just draw the polys.<br /><br />A portal system optimized for hardware should just create a viewing volume based on a portal and test it against objects/meshes with bounding volumes, if you ask me. Not individual polygons. Just reject any object or mesh that is completely out. When it&#039;s partially or completely in, just draw it, let the hardware handle the per-poly and per-pixel cases. It&#039;s better at it.<br /><br />Not sure what you mean by &quot;I won&#039;t be using any meshes&quot;... To me, a collection of polygons is a mesh by definition. You&#039;re always using meshes.</div>
    <div class="meta">Posted on 2009-06-25 03:01:43 by Scali</div>
   </div>
   <div class="post" id="post-207905">
    <div class="subject"><a href="#post-207905">Re: Homer's GameDev Blog</a></div>
    <div class="body">I wont be making any Mesh interface calls with respect to rendering the static world.<br />The realtime PVS algorithm is based on work by Alan Baylis, and works like this:<br /><br />I have a world which has been partitioned (via BSP) into convex subspaces, each of which contains a minimal number of polygons, and a minimal number of portals leading to other subspaces.<br /><br />I (the camera) am standing in a subspace...<br />I check the Portals in this subspace for visibility (a sphere test COULD be used here!) .<br />If they are visible (to the camera), I recurse them, using a flag to ensure I don&#039;t visit the same subspace twice.<br />The function ends by drawing all the polygons in the current subspace, returning through recursion to the subspace which contains the camera, where it does the same thing.<br /><br />The recursion depth depends on the view frustum and the style of world geometry (ie, indoors or outdoors makes a big difference here), but generally won&#039;t be more than five or six levels deep.<br /><br />So I&#039;m drawing all the faces in five or six nodes (times #visible portals, worst case) - but it gets better... Some of those are repeats, since a polygon can lay across two leaves under my model (I do break polygons, but I keep track of what original imported triangle they came from)... so I end up with a short list of triangles that need drawing, and those are tagged with their material id... so I then collect the indices of the visible triangles in per-material sets and render them as mentioned.<br /><br /></div>
    <div class="meta">Posted on 2009-06-25 05:17:15 by Homer</div>
   </div>
   <div class="post" id="post-207910">
    <div class="subject"><a href="#post-207910">Re: Homer's GameDev Blog</a></div>
    <div class="body">Well, you see my problem.. You need to do all kinds of sorting and rewriting of indexbuffers. That&#039;s going to scale very poorly with polycount. It sounds like the algorithm you picked has become obsolete because of modern T&amp;L hardware.</div>
    <div class="meta">Posted on 2009-06-25 09:33:35 by Scali</div>
   </div>
   <div class="post" id="post-207911">
    <div class="subject"><a href="#post-207911">Re: Homer's GameDev Blog</a></div>
    <div class="body">Portal schemes are most useful where visibility is impeded.<br />Could be a boring old orthogonal tunnel system, or it could be a forest.<br />The only time it doesn&#039;t work is when the far Z is massive, and the view is not obscured.<br />A well designed level easily overcomes this limitation.<br />In this case, the polygon count has realistic bounds.<br /></div>
    <div class="meta">Posted on 2009-06-25 09:39:54 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29358&amp;page=1" style="">&laquo;</a><a href="../?id=29358&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="29358" /><input type="number" name="page" min="1" max="15" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=29358&amp;page=4">&gt;</a><a href="../?id=29358&amp;page=15">&raquo;</a></form>  </div>
 </body>
</html>