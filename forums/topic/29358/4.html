<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Homer's GameDev Blog - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29358" />
  <link rel="prev" href="../?id=29358&amp;page=3" />  <link rel="next" href="../?id=29358&amp;page=5" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29358">Homer's GameDev Blog</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29358&amp;page=1" style="">&laquo;</a><a href="../?id=29358&amp;page=3" style="">&lt;</a><input type="hidden" name="id" value="29358" /><input type="number" name="page" min="1" max="15" step="1" value="4" onchange="this.form.submit();" /><a href="../?id=29358&amp;page=5">&gt;</a><a href="../?id=29358&amp;page=15">&raquo;</a></form>   <div class="post" id="post-207914">
    <div class="subject"><a href="#post-207914">Re: Homer's GameDev Blog</a></div>
    <div class="body">Well, I&#039;m just saying you&#039;ll never be able to build something with Crysis-like levels of detail when you go for an outdated scheme like this.<br />Modern hardware can easily handle millions of polys per frame. There&#039;s just no way your CPU can process them. So you have to stay out of the way of the GPU.<br /><br />This algorithm by Alan Baylis that you mention, would that be this one from 2002?<br />http://www.alsprogrammingresource.com/portals_tutorial.html<br /><br />Clearly an algorithm aimed at 2002 polycount and GPU capabilities is no longer up to date for 2009.</div>
    <div class="meta">Posted on 2009-06-25 10:18:43 by Scali</div>
   </div>
   <div class="post" id="post-207917">
    <div class="subject"><a href="#post-207917">Re: Homer's GameDev Blog</a></div>
    <div class="body">Thats an unfair appraisal, I&#039;m not sure what you base that on.<br />Alan&#039;s technique was never used in mainstream products.<br />If I may draw an analogy, the algorithm for BSP was published DECADES before Carmack wrote Doom.<br />That being the case, it should never have seen the light of day!<br />I&#039;ll be reserving my gpu muscle for eyecandy, concentrating on realtime radiosity.<br /><br />I do agree with the spirit of your comment, as a generalization.<br /></div>
    <div class="meta">Posted on 2009-06-25 17:46:17 by Homer</div>
   </div>
   <div class="post" id="post-207922">
    <div class="subject"><a href="#post-207922">Re: Homer's GameDev Blog</a></div>
    <div class="body">I base it on the fact that game developers have been struggling with BSP and portal approaches ever since the launch of early T&amp;L hardware. The Quake engine actually got criticism because the BSP approach severely limited polygon throughput. Later versions of Quake/Doom engines used &#039;leafy&#039; approaches where he worked with larger groups of polygons instead.<br />Other developers dropped BSP altogether and went for other approaches, such as octtrees.<br /><br />I&#039;m not saying old algorithms are necessarily bad. But in this case the hardware caught up with BSP and made it obsolete in its original form.<br /><br />The idea of portal rendering in itself is fine. You construct a viewing volume and test which objects fall into the viewing volume. If one or more of these objects is a portal, recurse into there aswell.<br /><br />The thing is just, if you take a game like Crysis... The average screen has over 3 million polys. Now, let&#039;s say you have a 3 GHz processor... This means that best case you have about 1000 cycles to spend per polygon, if you are going to process things on a per-polygon basis. That&#039;s not a whole lot. Clearly there will be lots of other overhead in the game engine aswell, so the actual amount of processing time will be far lower. It simply won&#039;t be enough to do anything on a per-poly basis. You don&#039;t have the CPU cycles, period. A GPU does, however, so let the GPU figure out things on a per-poly level.<br /><br />I&#039;d like to direct you to the legendary Batch Batch Batch presentation by nVidia: http://developer.nvidia.com/docs/IO/8230/BatchBatchBatch.pdf</div>
    <div class="meta">Posted on 2009-06-26 03:18:12 by Scali</div>
   </div>
   <div class="post" id="post-207931">
    <div class="subject"><a href="#post-207931">Re: Homer's GameDev Blog</a></div>
    <div class="body">That&#039;s a good read, although I&#039;ve read it before.<br />If you walk back over my comments in the past few posts, you&#039;ll see that I have done exactly what they suggest - few, large batches rather than many, small ones.<br />I don&#039;t have access to geometry shaders under D3D9/XP (although they&#039;re available to opengl, which is annoying).. and I don&#039;t see myself jumping onto any other Windows OS for the time being.<br />So I&#039;m stuck with throwing triangles at the videocard manually, which is why I&#039;m using a partitioning scheme to help reduce the number of polygons I am throwing around (alleviate bus congestion bottleneck).<br />Whether I used octree, kd-tree, or any other kind of partitioning scheme is not relevant - I&#039;m NOT using the classic BSP rendering techniques (tree walk required, despite the fact that the polygons are only in the leaf nodes)... I&#039;m only taking advantage of the fact that BSP leaf nodes are convex subspaces, so there is a guaranteed zero occlusion when rendering a given convex cluster of faces (containing the camera), and I am using the Portal stuff to extend the previous premise further into Z space - minimal overdraw, WITHOUT the drawbacks associated with the classic BSP rendering techniques (front/back or back/front walk).<br /><br />Believe me, if I could send a skeletal representation of my mesh to the gpu and generate my polygons from there, of COURSE I could produce reliably millions of triangles per second. I&#039;d love to, and I&#039;m not a bad shader programmer, I just don&#039;t have access to DX10 and above at this time. Besides, I want my stuff to run on &#039;anything out there&#039;, I expect my software to scale to the hardware, not the other way around.. which I believe is something you&#039;re looking to try to squeeze out of your DX10 engine?<br /><br /><br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2009-06-27 23:27:54 by Homer</div>
   </div>
   <div class="post" id="post-207932">
    <div class="subject"><a href="#post-207932">Re: Homer's GameDev Blog</a></div>
    <div class="body">My next step will be to create storage lists of entities in each subspace - clearly, each subspace owns the set of entities which are completely within that subspace.<br /><br />This begs an interesting question - if an entity is intersecting a portal surface, which subspace is the entity now within?<br /><br />My answer to this question is - both (or all) of them.<br />Either I record a reference to the entity in each subspace which it partly or wholly intersects, OR, each entity contains a reference-list of which Portals it is intersecting.<br /><br />It actually makes more sense to me that an entity should track its portal intersections, since we can set a flag within that entity to tell it to check for portal intersection until intersection ceases - at which point, it can remove the redundant reference.<br /><br />The alternative requires processing of each subspace (cell) in the world, which is exactly the kind of exhaustive approach I am trying to avoid (generally).<br /><br />Anyway, as soon as that&#039;s done, I&#039;ll be ready to reintegrate (lol) my Physics Engine component, with the ambition being to extend the partitioning scheme to the physical simulation.<br /><br />For the moment, I added code to my per-frame RenderText method that determines and displays which Leaf (aka subspace aka cell) contains the Point at the Origin of the Camera... its crude, involves a full tree walk, its just more debug and feel-good code for me to prove to me that I actually understand everything I am talking about, and understand it intimately.<br /><br />That brings me almost to the end of Alan&#039;s walk in this park - as soon as I&#039;ve extended on both Nathan and Alan&#039;s previous work, and will full credit given, I intend to crow from the nearest rooftop :)<br /></div>
    <div class="meta">Posted on 2009-06-28 01:02:41 by Homer</div>
   </div>
   <div class="post" id="post-207935">
    <div class="subject"><a href="#post-207935">Re: Homer's GameDev Blog</a></div>
    <div class="body"><div class="quote"><br />That&#039;s a good read, although I&#039;ve read it before.<br />If you walk back over my comments in the past few posts, you&#039;ll see that I have done exactly what they suggest - few, large batches rather than many, small ones.<br />I don&#039;t have access to geometry shaders under D3D9/XP (although they&#039;re available to opengl, which is annoying).. and I don&#039;t see myself jumping onto any other Windows OS for the time being.</div><br /><br />Well, none of what I said required D3D10 or geometry shaders.<br />I&#039;m just saying that you should try to keep your vertexbuffers and indexbuffers static wherever possible. Don&#039;t think in terms of single polygons, but think in terms of &#039;primitives&#039; as the DrawPrimitive API does.<br />Even back in the GeForce2 days, GPUs were massively faster at culling invisible polys than a CPU was. So if I had say an object of 5000 polys... I would simply test if the object as a whole is visible or not (visible meaining: not completely outside the viewing volume... I don&#039;t even need to make the distinction between intersecting or fully inside). If it is, I just fire it off with a single call. The buffers are already stored in videomemory, and already optimized by the driver, so I get maximum performance. Even if only a handful of polys are actually visible, the GPU is faster at culling the remaining polys than my CPU could ever be, especially if I don&#039;t get in its way by modifying the buffers all the time (if you rewrite indexbuffers, you will leave &#039;gaps&#039; between your vertexbuffers, which means that vertex caching will be far less efficient, it assumes linear transversal of the buffer, and can only cache a handful of vertices).<br /><br /><div class="quote"><br />So I&#039;m stuck with throwing triangles at the videocard manually, which is why I&#039;m using a partitioning scheme to help reduce the number of polygons I am throwing around (alleviate bus congestion bottleneck).</div><br /><br />Well, that&#039;s what I&#039;m saying... If you just store the geometry statically on the videocard, it may be faster NOT to reduce the number of polygons, because you have eliminated the bus transfer from your algorithm altogether.<br />Again, a modern GPU can handle thousands polygons in the same time your CPU can handle one. That is the thing here... At first hand it may seem smart to reduce the number of polygons drawn... But if you dig deeper... if it takes more time to remove a polygon from the drawing set than it takes the GPU to just render it, you&#039;ve just been fooled.<br />The same goes for a zbuffer for example. In the old days we used to just z-sort polygons (painters algorithm), because you didn&#039;t check the depth at every pixel, but just at every polygon. So you saved a lot of checks and a lot of bandwidth.<br />However, as geometry got more complex, the difference in number of pixels and number of polygons diminished. And as shading got more complex, the ability of the zbuffer to skip the shading for a pixel actually started saving time.<br />So even with software solutions, zbuffer was sometimes faster than zsorting. And on hardware it never even was an issue.<br /><br /><br /><div class="quote"><br />Besides, I want my stuff to run on &#039;anything out there&#039;, I expect my software to scale to the hardware, not the other way around.. which I believe is something you&#039;re looking to try to squeeze out of your DX10 engine?</div><br /><br />My DX10 engine evolved from my earlier engines. Although I&#039;ve long removed support for DX8 and lower, I kept DX9 support because of XP.<br />So my engine can still run on ancient hardware like a GF2, if I so choose. The old fixedfunction routines are still in there somewhere, including some CPU-based T&amp;L, because although GF2 could do per-pixel lighting with dot3, it couldn&#039;t perform the setup for interpolating normals and light vectors in hardware.<br />So yes, my software can scale to the hardware very well. It&#039;s just that I draw the line somewhere. The problems with culling geometry even existed back on the GF2. Especially the more high-end ones, like the GTS/Pro/Ultra, had REALLY fast T&amp;L engines, so polygons were really cheap to eliminate. I don&#039;t think it&#039;s useful to support hardware all the way back to GF2 in this day and age. I think if you just support DX9 SM3.0 cards, virtually everyone will be able to run it. And you can treat those very similarly to DX10 hardware. They are both massively faster with static geometry than they are with dynamic geometry. And in both cases their maximum polygon throughput is orders of magnitude larger than the throughput of a high-end CPU.<br /><br />A simple example is this old piece of code: http://bohemiq.scali.eu.org/forum/viewtopic.php?t=35<br />It contains an optimized CPU path to generate the shadowvolumes, and a bruteforce vertexshader-based approach.<br />While the CPU algorithm is far more elegant, my 3 GHz Core2 Duo can only coax 1500 fps out of it... Running the vertexshader on the 9800GTX+ card that I have here, gives me 3200 fps, so more than twice as fast, despite the shaders having to do three times the work.<br />That&#039;s just how it is. My CPU is holding up my GPU because it can&#039;t process the polygons quickly enough. And this is just a test scene with a few thousand animated polygons (I believe it has about 2500 polygons).<br />It&#039;s a much better tradeoff to let the GPU do the bruteforce approach. Not only do I get a higher framerate, it also frees up the CPU for other tasks.<br />And as you can see from the few statistics posted in the thread itself, this is not a new phenomenon. It was the same back in the days of Pentium 4&#039;s and GeForce 6800s. I think if you support back to the level of GeForce 6-series today, you&#039;re being generous enough. That was 5 years ago.<br />That&#039;s actually the biggest of my gripes in this discussion... What I&#039;m saying is not something new, it&#039;s a problem that has existed for years.<br />I&#039;m not sure what you&#039;re targeting exactly, when you say &quot;anything out there&quot;?</div>
    <div class="meta">Posted on 2009-06-29 04:34:42 by Scali</div>
   </div>
   <div class="post" id="post-207939">
    <div class="subject"><a href="#post-207939">Re: Homer's GameDev Blog</a></div>
    <div class="body"><br />Finished implementing the new rendering code for &#039;World&#039; geometry.<br />It uses the portal-based visibility culling scheme I outlined previously.<br />Since my World model is currently so simple, I can&#039;t appreciate a change in FPS over bruteforce rendering via DrawSubset.<br /><br /><br /></div>
    <div class="meta">Posted on 2009-06-30 10:52:44 by Homer</div>
   </div>
   <div class="post" id="post-207942">
    <div class="subject"><a href="#post-207942">Re: Homer's GameDev Blog</a></div>
    <div class="body"><div class="quote"><br />Since my World model is currently so simple, I can&#039;t appreciate a change in FPS over bruteforce rendering via DrawSubset.</div><br /><br />Ah, I see... to you a mesh actually means a D3DX mesh? That would explain some of the questions I had.<br />But that was one of the points in the Batch, Batch, Batch presentation: if you are CPU-limited, you can add extra triangles for free.</div>
    <div class="meta">Posted on 2009-06-30 11:41:16 by Scali</div>
   </div>
   <div class="post" id="post-207952">
    <div class="subject"><a href="#post-207952">Re: Homer's GameDev Blog</a></div>
    <div class="body">Yes, I make this distinction because any buffer full of vertices could be considered a Mesh, even if there is no topological information (such as edge connectivity)... I do use the term &#039;mesh&#039; to describe a D3D mesh, since its not merely a point-cloud or even a triangle soup - which is what I import from a D3D Mesh, I do not import topological data, so I don&#039;t consider my imported data to be a mesh. I&#039;m not exactly sure what the accepted definition of a mesh is, but I would strongly suspect it mentions topology, or at least implies connectivity between its elements.<br /><br />Tonight I will begin to introduce chunks of my physics engine, starting with just the &#039;time core&#039; and collision detection components. I&#039;ll leave collision response until later, simply because a game engine requires collision tests, but physical simulation of collision RESPONSES is not always a requirement.<br /></div>
    <div class="meta">Posted on 2009-07-01 01:35:54 by Homer</div>
   </div>
   <div class="post" id="post-207954">
    <div class="subject"><a href="#post-207954">Re: Homer's GameDev Blog</a></div>
    <div class="body"><div class="quote"><br />Yes, I make this distinction because any buffer full of vertices could be considered a Mesh, even if there is no topological information (such as edge connectivity)... I do use the term &#039;mesh&#039; to describe a D3D mesh, since its not merely a point-cloud or even a triangle soup - which is what I import from a D3D Mesh, I do not import topological data, so I don&#039;t consider my imported data to be a mesh. I&#039;m not exactly sure what the accepted definition of a mesh is, but I would strongly suspect it mentions topology, or at least implies connectivity between its elements.</div><br /><br />Well, the concept of a mesh is far older than the D3D mesh class itself, and the D3D mesh class is just one specific interpretation of what a mesh is. So I don&#039;t automatically link the word mesh to the D3D object.<br />The definition for &#039;polygon mesh&#039; on Wiki is huge:<br />http://en.wikipedia.org/wiki/Polygon_mesh<br /><br />But they don&#039;t explicitly state that you need topological info. Besides, in D3D topology is implicit anyway, because your vertices are always ordered by triangle. You just specify whether you have a triangle list or strip or such, and your topology is implicitly defined. Not in the most useful format for some occassions perhaps, but you can always rebuild the topology from the list of vertices.<br /><br />To me, a mesh is just a list of polygons that are in some way related to eachother. They are connected, so to say. Either physically, or because they share common properties like materials, or belonging to a single object etc.<br />That is, in the strictest sense I consider a mesh to be physically connected polygons... However, in practice you can just as easily &#039;abuse&#039; the same datastructures for polygons that aren&#039;t necessarily connected. In D3D (or most triangle rasterizers at that), whether polygons are connected or not doesn&#039;t really have any significance.<br />In my implementation of a mesh, it&#039;s just a set of vertexbuffers, an indexbuffer and their primitive descriptions, combined with a single material description. So a &#039;mesh&#039; is just something that can be drawn with a single material setup and then one or more DrawPrimitive() calls.<br />An object then is a list of meshes which may or may not share the same material. Objects also handle local coordinate spaces and animation and such.<br /><br />So far that approach has been valid throughout various iterations of my engines, since the late 90s I think... but perhaps at some point that will change :)</div>
    <div class="meta">Posted on 2009-07-01 02:23:31 by Scali</div>
   </div>
   <div class="post" id="post-207962">
    <div class="subject"><a href="#post-207962">Re: Homer's Going Mad, Mad, Mad !!</a></div>
    <div class="body">I&#039;m making some hefty changes to the physics engine as I drag it headlong into the new GameEngine framework.<br />For starters, I&#039;ve stripped it back for a staged implementation.<br />I&#039;ve also decided to make some critical changes to the architecture of the physics engine.<br />Notably, I&#039;ve decided to change my support for mesh collisions to use a reference mesh representing the (assumedly convex) hull, rather than the piecemeal pseudo-primitive approach I&#039;d been using.<br />This will clean up the code immensely, and give me a groundwork for animated hulls.<br />I&#039;ve already experimented in that arena with a demo that calculated boundingboxes for the influenced vertices of each bone in a SkinMesh in &#039;bone space&#039;, then animated these box-shaped collision hulls by simply driving them with the animated bone matrices. That looked promising, but adapting that to an arbitrary hull sounds more promising (better fit, more control over number and position of hull vertices, etc).<br /><br /></div>
    <div class="meta">Posted on 2009-07-01 10:27:02 by Homer</div>
   </div>
   <div class="post" id="post-207963">
    <div class="subject"><a href="#post-207963">Re: Homer's GameDev Blog</a></div>
    <div class="body">I&#039;d still like to know though... you say you want to target &quot;anything out there&quot;. So what would be your minimum spec system, in terms of OS support, memory, CPU, videocard etc?<br /><br />Edit: By the way, I can&#039;t really seem to get a grip on you and what you&#039;re doing. We seem to be talking on different wavelengths at times, I guess.<br />Perhaps you think I&#039;m asking too many &#039;difficult&#039; questions, and I get the feeling you&#039;re being a bit evasive at times.<br />I&#039;m just genuinely interested in what it is you&#039;re doing. I&#039;ve written my share of graphics routines over the years, and it&#039;s interesting to revisit some topics. I may discover things I haven&#039;t thought of yet, or things that can perhaps be done in better ways now than back when I did them. And conversely I may be able to give you some new inspiration aswell.</div>
    <div class="meta">Posted on 2009-07-01 12:22:14 by Scali</div>
   </div>
   <div class="post" id="post-207971">
    <div class="subject"><a href="#post-207971">Re: Homer's GameDev Blog</a></div>
    <div class="body">By &#039;anything out there&#039;, I mean any Windows NT system and upwards.<br />We&#039;ve made some early steps toward porting ObjAsm32 to Linux (under JWASM), but for now we&#039;re pretty much tied to 32 bit Windows systems. I&#039;ll begin to support 64bit as soon as I can justify buying a new machine given that I openly refuse to upgrade from XP SP3 RC4 to any other Windows OS.... time to jump ship, not go down with it.<br /><br />Now that I&#039;ve reached a reasonable milestone with the game engine, I&#039;d be willing to post both binary and source for the portal rendering code, since I don&#039;t own any intellectual property in there.<br />I don&#039;t intend to be evasive, far from it... I&#039;m willing to explain my ideas and concepts in great detail, but not many people want to know every little detail, they&#039;re just curious onlookers who like the occasional screenshot.<br />The comments in my sourcecode probably say a whole lot more than I do.<br /><br />A little about me:<br />I tend to have a hacker mentality when it comes to programming in general - I sincerely believe that not only CAN the majority be wrong, but they USUALLY are... so I never accept anything on faith, no matter who says it, or how many times, or how loudly. This makes it possible for me to innovate, to discover new things, and to break new ground simply because I don&#039;t tell myself &quot;it can&#039;t be done&quot;, or &quot;its slow, and theres no way to speed that up&quot;... whereas those who naiively assume that the assertions of others are correct (no matter how godlike they may be) are dooming themselves to relative obscurity, or at least banality, because they have tunnel vision they will never do anything that is not already being done, and they&#039;ll tend to just reinvent the wheel, and will never stand out from the crowd. This began for me when I learned to machinecode on the C64, and discovered that it was possible to use software to make the hardware do things well outside its design specs without breaking anything. I&#039;ve been pulling things apart all my life to see how they work, and whether its code, electronics or machinery, I will invariably see IMMEDIATELY some things that can be improved, or are completely redundant. I will never &quot;leave it alone, its not broken&quot;. <br />Also, I like to do things for myself - I could have just plugged in an existing physics engine, hey I could have just used an existing GAME engine, but what satisfaction (or potential for anything else) is there in that?<br />I need to be constantly challenged, and as a result, I tend to throw myself into waters that are just a little (sometimes a lot) over my head, I believe that the less you know about a given field, the faster you will learn about it, and the more likely you are to discover something new (see Paradox of the Expert).<br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2009-07-02 01:34:32 by Homer</div>
   </div>
   <div class="post" id="post-207972">
    <div class="subject"><a href="#post-207972">Re: Homer's GameDev Blog</a></div>
    <div class="body"><div class="quote"><br />By &#039;anything out there&#039;, I mean any Windows NT system and upwards.</div><br /><br />Yea, but from what I understood, you are using Direct3D 9, so that would already limit you to Windows 2000 and higher, and also a limited subset of CPUs and GPUs. So it&#039;s never REALLY &#039;anything out there&#039;.<br />And although D3D9 goes back quite far in terms of hardware support, it&#039;s very difficult to make things work everywhere, especially when you get into fixedfunction shading. Some hardware only supports 2 textures per pass, others don&#039;t have this-and-that texture op, etc.<br />So where exactly do you draw the line?<br />Back in the day I would just make sure my code ran on GeForce2 and Radeon 7000-series. Those were the most common fixedfunction cards. Anything else I considered either too slow (Intel IGP) or too rare to even spend time on.<br />With shaders it became a bit easier, because a certain shadermodel defines a certain set of features.<br />So currently I think I draw the line at SM3.0. Good enough for nearly anything, and common enough that it will run nearly everywhere.<br /><br /><div class="quote"><br />I don&#039;t intend to be evasive, far from it... I&#039;m willing to explain my ideas and concepts in great detail, but not many people want to know every little detail, they&#039;re just curious onlookers who like the occasional screenshot.</div><br /><br />I like the details. Sometimes minor details can be very valuable in optimizing an algorithm...<br />For example, 9 out of 10 GIF unpackers use a relatively naive decoding scheme. Because of the way the LZW compression works, you always decode data &#039;backwards&#039;. So if I pack &quot;backwards&quot;, the unpacker will get &quot;sdwradkcab&quot; from its table, which it will then have to reverse byte-by-byte. Usually this is done via a stack of some sort.<br />1 out of 10 GIF unpacker coders will have the realization that if you know how long the string is, you can reverse it in-place, and greatly speed up the unpacking. They will then see that you DO know how long the string is... since it&#039;s built up recursively (which is why it&#039;s backwards, you get 1 symbol and a reference to a previous string). So you start with strings of length 1, and everytime you encounter a new string, it is based on an existing string, but 1 symbol longer.<br /><br />Similarly with huffman decoding, you often see people traversing a symbol tree bit for bit... while by definition if a huffman code has N bits, then any other with more than N bits cannot start with those same bits. In other words, that N-bit pattern is unique.<br />So, a much faster way is to precalc a table where you take the unique N-bit pattern for each symbol, and fill it out to a certain number of bits, say 8 bits, by bruteforcing all possibilities. In the table you store the symbol belonging to the N-bit pattern, and the actual length of the code (N bits).<br />Then you can decode by just grabbing 8 bits from the stream, doing a lookup, then advancing the stream by N bits. An incredible deal faster than walking down a tree for every symbol.<br /><br />Some details are just little hints at how you can get your code much faster.<br /><br /><div class="quote"><br />I tend to have a hacker mentality when it comes to programming in general - I sincerely believe that not only CAN the majority be wrong, but they USUALLY are... so I never accept anything on faith, no matter who says it, or how many times, or how loudly.</div><br /><br />I can fully relate to that (I guess the above example also illustrates it). I suppose the majority of assembly programmers do, else they wouldn&#039;t be programming assembly in the first place.<br /><br /><div class="quote"><br />This makes it possible for me to innovate, to discover new things, and to break new ground simply because I don&#039;t tell myself &quot;it can&#039;t be done&quot;, or &quot;its slow, and theres no way to speed that up&quot;... whereas those who naiively assume that the assertions of others are correct (no matter how godlike they may be) are dooming themselves to relative obscurity, or at least banality, because they have tunnel vision they will never do anything that is not already being done, and they&#039;ll tend to just reinvent the wheel, and will never stand out from the crowd.</div><br /><br />Yea, I can relate to that aswell. I wrote a software 3d engine in Java, complete with crazy things like multitexturing, texture filtering, bumpmapping, shadowmapping, skinning and everything.<br /><br /><div class="quote"><br />Also, I like to do things for myself - I could have just plugged in an existing physics engine, hey I could have just used an existing GAME engine, but what satisfaction (or potential for anything else) is there in that?</div><br /><br />Yea, in many cases I just prefer to &#039;roll my own&#039;. The main reasons are that firstly I know EXACTLY what I want, so I want to tweak the code to meet my performance requirements, rather than some generic solution which may be far from optimal in my case. And secondly, I may be doing things that very few others before me have done, so there is no clear-cut solution available yet.<br /><br />But over the years I&#039;ve become a bit more &#039;mellow&#039; in that regard. Partly because now that I work fulltime, things have changed. At work you just need to get the job done quickly, at times... and often the things are quite trivial anyway, so there isn&#039;t really much room for creativity or anything. Also, it leaves me less time to do hobby projects, and I may not always be in the mood for coding when I&#039;m at home.<br /><br />Another thing is that work (and experience) changes your outlook on some things. You get a better feel for what you should or shouldn&#039;t rewrite/optimize. Sometimes &quot;good enough&quot; is just good enough. For example, I rarely used MFC myself. People always complain about how bloated it is and all that... But at work, we pretty much use MFC on everything. Some of the stuff is actually quite good. If you want to make a nice window or dialog, MFC just makes it a lot easier for you. And performance isn&#039;t really an issue anyway... Aside from the fact that this part of MFC is actually just a very thin wrapper around the Win32 API anyway. It&#039;s mainly things like the CString, CArray etc that I&#039;m still not that happy with.<br />I actually converted my main app and window for the D3D engine to MFC a while ago. Makes the code a lot cleaner and simpler, and in the end it&#039;s just a window to attach your D3DDevice to, so it doesn&#039;t affect performance at all.<br />So in about 10 years I&#039;ve gone from using assembly everywhere (like the DirectDraw plasma) to using &#039;notorious bloatware&#039; like MFC... Except I never made any compromises to the actual performance of my applications. I just learnt what to use where.<br /><br />It also helps that I developed a nice library of standard code. For example, I implemented a state caching system in my D3D10/11 engine a few weeks ago... It still uses a hashtable class that I wrote about 10 years ago. It was aimed at maximum lookup speed, and it still is a great tool for that. It still surprises me how often I see code at work where I think &quot;This could have been SO much faster and/or simpler if they just used a hashtable&quot;. People just like to loop through lists or have tons of if/else clauses stacked together. Perhaps they don&#039;t know any better.</div>
    <div class="meta">Posted on 2009-07-02 03:27:16 by Scali</div>
   </div>
   <div class="post" id="post-207974">
    <div class="subject"><a href="#post-207974">Re: Homer's GameDev Blog</a></div>
    <div class="body">Yeah, we began supporting a state table in OA32 about two years ago.<br />Really helps in an object oriented environment where everything has its own set of states.</div>
    <div class="meta">Posted on 2009-07-02 09:10:04 by Homer</div>
   </div>
   <div class="post" id="post-207978">
    <div class="subject"><a href="#post-207978">Re: Homer's GameDev Blog</a></div>
    <div class="body">But you still avoided the question of what hardware you&#039;re actually targeting :)</div>
    <div class="meta">Posted on 2009-07-03 03:30:23 by Scali</div>
   </div>
   <div class="post" id="post-207981">
    <div class="subject"><a href="#post-207981">Re: Homer's GameDev Blog</a></div>
    <div class="body">anything that complies with pixelshader3.0, under dx9.0c or above, since i wont be doing (much/any) vertex shading on the gpu</div>
    <div class="meta">Posted on 2009-07-03 04:42:40 by Homer</div>
   </div>
   <div class="post" id="post-207983">
    <div class="subject"><a href="#post-207983">Re: Homer's GameDev Blog</a></div>
    <div class="body"><div class="quote"><br />anything that complies with pixelshader3.0, under dx9.0c or above, since i wont be doing (much/any) vertex shading on the gpu<br /></div><br /><br />Okay, so basically we&#039;re both targeting SM3.0 and higher...<br />Why aren&#039;t you doing vertex shading on the GPU though?</div>
    <div class="meta">Posted on 2009-07-03 04:48:24 by Scali</div>
   </div>
   <div class="post" id="post-207987">
    <div class="subject"><a href="#post-207987">Re: Homer's GameDev Blog</a></div>
    <div class="body">The only place I&#039;d ever need it is skinmesh, and of the four popular styles of skinmesh animation, I found virtually no benefit in using GPU over CPU - in fact the CPU palette version produces the highest fps on my 8600 and 8800 cards... that being the case, I&#039;m not inclined to waste gpu time on matrix palettes, I can think of better ways to flex the gpu muscle than this. I&#039;m a shader fan, but I accept that some things are just not shader-oriented, regardless that they are &#039;doable&#039;.<br /><br /><br /></div>
    <div class="meta">Posted on 2009-07-03 08:30:37 by Homer</div>
   </div>
   <div class="post" id="post-207988">
    <div class="subject"><a href="#post-207988">Re: Homer's GameDev Blog</a></div>
    <div class="body"><div class="quote"><br />The only place I&#039;d ever need it is skinmesh, and of the four popular styles of skinmesh animation, I found virtually no benefit in using GPU over CPU - in fact the CPU palette version produces the highest fps on my 8600 and 8800 cards... that being the case, I&#039;m not inclined to waste gpu time on matrix palettes, I can think of better ways to flex the gpu muscle than this. I&#039;m a shader fan, but I accept that some things are just not shader-oriented, regardless that they are &#039;doable&#039;.</div><br /><br />What about that old skinned shadowvolume I linked to earlier?<br />Not only does it skin the shadowvolumes AND the object itself, it also does it in a relatively inefficient way, because for each vertex you need to calculate the entire triangle. So you skin each vertex 3 times, where the CPU can do it only once.<br />And STILL the GPU is about twice as fast. So technically that makes the GPU 6 times as fast as a CPU at skinning operations.<br /><br />Vertexshaders are THE place for flexing GPU muscle. Pixelshaders are nice and all, but if you&#039;re going to use your CPU for T&amp;L, you&#039;ll be bottlenecking the triangle throughput anyway, so you CAN&#039;T flex the GPU muscle on pixelshaders (unless you want to use REALLY lowpoly scenes at REALLY high resolutions and AA, and LOTS of overdraw... but why do that when you can use vertexshaders to get highpoly for free?)<br /><br />So what exactly are you doing that makes it so slow? You can just look at the shader code I use in my example. I believe I had a palette with 4 matrices there, but it could scale up to more matrices easily, up to about 20 I guess. The difference between CPU and GPU would only get larger.<br />How is your approach different from mine?<br />And considering the artificial limits you&#039;re putting in with your CPU, what exactly DO you plan to use the GPU muscle on?<br />Heck, even back in the GF2 days, I would limit my CPU-code to only update the parts of the vertexbuffer that hardware T&amp;L couldn&#039;t handle... Eg calcing per-vertex light vectors for dot3 lighting. I&#039;d still let the GPU handle all other T&amp;L, because it did it way faster than the CPU could. Matrix/vector calculations, dotproducts, crossproducts, sqrts, pow... GPUs demolish CPUs in those categories.<br /><br />Wanting to re-invent the wheel is one thing.... but you have to be careful... Sometimes you arrive at a square wheel... then you establish that the flat sides are the problem, so you decide to eliminate one of the flat sides and arrive at a triangular wheel... If you know what I mean :)</div>
    <div class="meta">Posted on 2009-07-03 08:43:30 by Scali</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29358&amp;page=1" style="">&laquo;</a><a href="../?id=29358&amp;page=3" style="">&lt;</a><input type="hidden" name="id" value="29358" /><input type="number" name="page" min="1" max="15" step="1" value="4" onchange="this.form.submit();" /><a href="../?id=29358&amp;page=5">&gt;</a><a href="../?id=29358&amp;page=15">&raquo;</a></form>  </div>
 </body>
</html>