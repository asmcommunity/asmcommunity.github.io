<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Homer's GameDev Blog - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29358" />
  <link rel="prev" href="../?id=29358&amp;page=13" />  <link rel="next" href="../?id=29358&amp;page=15" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29358">Homer's GameDev Blog</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29358&amp;page=1" style="">&laquo;</a><a href="../?id=29358&amp;page=13" style="">&lt;</a><input type="hidden" name="id" value="29358" /><input type="number" name="page" min="1" max="15" step="1" value="14" onchange="this.form.submit();" /><a href="../?id=29358&amp;page=15">&gt;</a><a href="../?id=29358&amp;page=15">&raquo;</a></form>   <div class="post" id="post-210132">
    <div class="subject"><a href="#post-210132">Re: Homer's GameDev Blog</a></div>
    <div class="body"><div class="quote">I know it&#039;s just vista with a facelift and a workover, but that&#039;s exactly what attracts me.</div><br /><br />That&#039;s what I&#039;m saying: it&#039;s not a workover. Vista already had the workover.<br />Windows 7 has a few new things that Vista didn&#039;t have, but those are not things that solve Vista&#039;s original problems. Those problems were already solved.<br />I already wrote about it in a blog in May of this year:<br /><a target="_blank" href="http://scalibq.spaces.live.com/blog/cns!663AD9A4F9CB0661!173.entry">http://scalibq.spaces.live.com/blog/cns!663AD9A4F9CB0661!173.entry</a></div>
    <div class="meta">Posted on 2009-12-31 04:42:20 by Scali</div>
   </div>
   <div class="post" id="post-210133">
    <div class="subject"><a href="#post-210133">Re: Homer's GameDev Blog</a></div>
    <div class="body">On the May blog-post: Yeah, let&#039;s ignore the return of GDI acceleration. Win7 costs 3 Euro more than Vista, and for WinXP users like me it looks like a better deal. Many people like me have been itching to get their mittens on the updated Vista, and here comes Win7 at the same price :) . </div>
    <div class="meta">Posted on 2009-12-31 05:37:20 by Ultrano</div>
   </div>
   <div class="post" id="post-210134">
    <div class="subject"><a href="#post-210134">Re: Homer's GameDev Blog</a></div>
    <div class="body"><div class="quote">On the May blog-post: Yeah, let&#039;s ignore the return of GDI acceleration.</div><br /><br />Yes I think we can ignore it. It&#039;s nice that it&#039;s there, but I haven&#039;t actually noticed it (to be more exact: I didn&#039;t even know it was gone in Vista, until I read about it after I had already been using Vista for a while. And I didn&#039;t notice that it was back when I switched from Vista to Win7).<br />It&#039;s not a big deal.<br />Same with the better memory management with regard to backbuffers and all. It saves video memory, but it&#039;s not really an issue anymore either, when 512 mb of videomemory is standard on low-end cards, and 1 GB on mainstream.<br />The problem has already solved itself, so to speak. I noticed a slight improvement with my 320 mb 8800GTS, but with my 1 GB 5770, it doesn&#039;t matter.<br /><br />Those really aren&#039;t things that the average user will even notice, let alone that it will be a reason for them to move to Windows 7.<br />Most of them will move to Windows 7 to get the Vista features.</div>
    <div class="meta">Posted on 2009-12-31 05:50:42 by Scali</div>
   </div>
   <div class="post" id="post-210135">
    <div class="subject"><a href="#post-210135">Re: Homer's GameDev Blog</a></div>
    <div class="body">Those ignorable features are ignorable on our high-end PCs, fortunately :D. <br /></div>
    <div class="meta">Posted on 2009-12-31 06:07:30 by Ultrano</div>
   </div>
   <div class="post" id="post-210136">
    <div class="subject"><a href="#post-210136">Re: Homer's GameDev Blog</a></div>
    <div class="body"><div class="quote"><br />Those ignorable features are ignorable on our high-end PCs, fortunately :D.</div><br /><br />High end? My PC was mainstream when I bought it 3 years ago. It&#039;s low-end now.<br />I think the irony is that the only PCs that would benefit from GDI acceleration are the same PCs that won&#039;t meet the minimum requirements for Windows 7 in the first place.</div>
    <div class="meta">Posted on 2009-12-31 06:18:01 by Scali</div>
   </div>
   <div class="post" id="post-210137">
    <div class="subject"><a href="#post-210137">Re: Homer's GameDev Blog</a></div>
    <div class="body">Win7 also saves system memory, since it (tries to?) keeps graphic elements solely in video memory, unlike Vista which had everything both in system and video memory.<br /><br />Iirc there were some benchmarks that showed that while most stuff ran faster (though probably not user-noticable :P) with Win7&#039;s WDDM 1.1 drivers, a few corner cases ran slower than Vista&#039;s non-accelerated... let me guess: locking bitmaps and manipulating their contents?<br /><br />Microsoft&#039;s ZoomIn (v3.20.01 from 1992 :P) runs like <strong>s***</strong> - anybody knows of a zoom-in-window tool that runs properly? SysInternals&#039; ZoomIt tool runs nicely, but that works by zooming the entire desktop (panning a screenshot, I suppose).<br /><br /><strong>Scali</strong>: your PC might be &quot;low end&quot; from a gamer perspective, but I think it&#039;s skewed to call it low-end generally...</div>
    <div class="meta">Posted on 2009-12-31 06:21:06 by f0dder</div>
   </div>
   <div class="post" id="post-210138">
    <div class="subject"><a href="#post-210138">Re: Homer's GameDev Blog</a></div>
    <div class="body"><div class="quote">Iirc there were some benchmarks that showed that while most stuff ran faster (though probably not user-noticable :P) with Win7&#039;s WDDM 1.1 drivers, a few corner cases ran slower than Vista&#039;s non-accelerated... let me guess: locking bitmaps and manipulating their contents?</div><br /><br />Thing is, just because you can measure it, doesn&#039;t mean you can notice it in daily use.<br />You&#039;d need a VERY GDI-heavy application. Otherwise even without acceleration it will update its entire screen in a few ms, faster than the user can notice.<br /><br /><div class="quote"><strong>Scali</strong>: your PC might be &quot;low end&quot; from a gamer perspective, but I think it&#039;s skewed to call it low-end generally...</div><br /><br />I don&#039;t. I have an E6600 2.4 GHz processor... Recently I bought a Pentium DualCore E5200 2.5 GHz processor. This was one of the cheapest Intel processors on the market, and definitely qualifies as &#039;low end&#039;, costing only about 50 euros. The E5200 is about the same speed as my E6600. Hence it&#039;s low-end.<br />Besides, my laptop is even slower, with its 1.5 GHz Core2 Duo and its onboard Intel graphics... But even there I never noticed GDI being slow. I couldn&#039;t even tell the difference with my 8800GTS in daily use.</div>
    <div class="meta">Posted on 2009-12-31 06:28:04 by Scali</div>
   </div>
   <div class="post" id="post-210139">
    <div class="subject"><a href="#post-210139">Re: Homer's GameDev Blog</a></div>
    <div class="body"><div class="quote"><br />Thing is, just because you can measure it, doesn&#039;t mean you can notice it in daily use.<br />You&#039;d need a VERY GDI-heavy application. Otherwise even without acceleration it will update its entire screen in a few ms, faster than the user can notice.</div>I agree - but you ignored a real-world example of something where it&#039;s extremely noticable.<br /><br /><div class="quote"><br /><div class="quote"><strong>Scali</strong>: your PC might be &quot;low end&quot; from a gamer perspective, but I think it&#039;s skewed to call it low-end generally...</div><br />I don&#039;t. I have an E6600 2.4 GHz processor... Recently I bought a Pentium DualCore E5200 2.5 GHz processor. This was one of the cheapest Intel processors on the market, and definitely qualifies as &#039;low end&#039;, costing only about 50 euros. The E5200 is about the same speed as my E6600. Hence it&#039;s low-end.</div>Low-end for a gamer, or us &quot;Rich Kids&quot;. But there&#039;s a lot of people still stuck with much lower hardware, and not just in the lesser fortunate countries.<br /><br /><div class="quote">Besides, my laptop is even slower, with its 1.5 GHz Core2 Duo and its onboard Intel graphics... But even there I never noticed GDI being slow. I couldn&#039;t even tell the difference with my 8800GTS in daily use.</div>That&#039;s something I&#039;d call sorta low-end, at least around here :)<br /><br />I wonder where GDI acceleration makes much of a difference (positive as well as negative), except for pathological cases like ZoomIt. Theoretically you could free some CPU power for other processing, but even on your 1.5GHz system it probably makes just about no difference - and on the other hand, the additional usage of the GPU could prevent it from entering lower-power state and thus draining laptop battery life.<br /><br />I guess Win7&#039;s GDI acceleration is more about conserving system memory by not duplicating bitmap elements...<br /></div>
    <div class="meta">Posted on 2009-12-31 06:34:06 by f0dder</div>
   </div>
   <div class="post" id="post-210140">
    <div class="subject"><a href="#post-210140">Re: Homer's GameDev Blog</a></div>
    <div class="body"><div class="quote">I agree - but you ignored a real-world example of something where it&#039;s extremely noticable.</div><br /><br />Ofcourse, case of rules and exceptions, you know.<br />I never denied that it&#039;s slower, so I&#039;m not surprised that there are cases where the difference can be noticed.<br />It may be a &#039;real-world&#039; example, but does it also fit into &#039;daily use&#039; for the average user?<br />I mean, if your webbrowser (pretty GDI-heavy anyway, compared to most other stuff) would ran noticeably slower, yes, that would be something an average user would worry about. But that seems to go fine.<br /><br /><div class="quote">Low-end for a gamer, or us &quot;Rich Kids&quot;. But there&#039;s a lot of people still stuck with much lower hardware, and not just in the lesser fortunate countries.</div><br /><br />That&#039;s not the point though. My E6600 certainly doesn&#039;t represent the &#039;bottom line&#039; as far as Vista/Win7 performance is concerned.<br />Thing is, if you were to buy a new PC today, even some of the cheapest stuff, like the Pentium E5200 I mentioned, isn&#039;t going to be slower than what I have. And those systems handle Vista/Win7 like a charm.<br />That&#039;s my point, GDI performance may be &#039;fixed&#039; with Windows 7, but was it really a problem in the first place?<br />I&#039;ve heard people complain about many things with Vista, but I can&#039;t recall any one of them ever mentioning anything related to GDI rendering speed.<br /><br />As for the &#039;really poor&#039;, tough luck for them, but they&#039;re not the type of people who would be playing DX9+ games or using Vista/Win7 anyway. I don&#039;t think they belong within the scope of this discussion.<br /><br /><div class="quote">That&#039;s something I&#039;d call sorta low-end, at least around here :)<br /><br />I wonder where GDI acceleration makes much of a difference (positive as well as negative), except for pathological cases like ZoomIt. Theoretically you could free some CPU power for other processing, but even on your 1.5GHz system it probably makes just about no difference - and on the other hand, the additional usage of the GPU could prevent it from entering lower-power state and thus draining laptop battery life.<br /><br />I guess Win7&#039;s GDI acceleration is more about conserving system memory by not duplicating bitmap elements...</div><br /><br />Well, there&#039;s two sides to the story.<br />1) There&#039;s the move to GPU-based rendering, eliminating the need for extra backbuffers...<br />2) GDI has received more granular locking, so that less time is spent waiting on GDI calls, and more parallelism is possible.<br /><br />I&#039;m not sure why they did it.<br />I don&#039;t think GPU acceleration is an issue for power saving though. GPUs are permanently in low power state in desktop mode, they don&#039;t need all the horsepower to render a desktop. I don&#039;t think CPU or GPU drawing will make a difference for the power mode the GPU needs to be in.<br />However, I do think that a difference will be that the GPU requires a lot less time and also power to do the same drawing operations as the CPU. Another thing is that the CPU can now do other tasks in parallel, while if you were to do eg a fillrect on CPU, you&#039;d max out your memory controller for a considerable time, stalling other applications.<br /><br />Who knows... perhaps MS did it &#039;because they could&#039;... Perhaps it really does help power consumption... or perhaps it&#039;s a different angle altogether... Eg, it may help Windows run better from a virtual environment, or with remote desktop, because it&#039;s easier to translate the drawing calls at the acceleration level.<br />At any rate, for regular desktop users it&#039;s something they&#039;ll probably never notice.</div>
    <div class="meta">Posted on 2009-12-31 07:32:08 by Scali</div>
   </div>
   <div class="post" id="post-210141">
    <div class="subject"><a href="#post-210141">Re: Homer's GameDev Blog</a></div>
    <div class="body">I was reading in my Video Demystified book (handbook for video repair guys) about MPEG streams.<br />They can contain a series of JPEG images, which suffer no artefacts - that is to say, all frames come from the stream.<br />Or they can be &quot;true mpeg&quot;, where theres two kinds of frames.<br />One is a pure data frame, as before.<br />The other is a guesstimation - the encoder generates an inbetween frame based apon the two nearest frames.<br />It&#039;s not just an interpolation, chrominance and luminance and stuff is all taken into account, but the result is an array of &quot;error values&quot;, which describe the difference between Frame A and the ideal intermediate frame.<br /><br />So MPEGs (typically) produce frames, most of which come from the datastream, but some of which are generated based on delta error expressions and previous frame. These intermediate frames are visually incorrect (there is always artefacts) but they are good enough to serve for one frame between some real ones, and fool the eye. This lets the decoder be slower and still acceptable, and I guess that was originally the point of that.<br /><br />That book also contains some interesting stuff about JPEG artefacts that would probably interest you.<br /></div>
    <div class="meta">Posted on 2009-12-31 08:56:41 by Homer</div>
   </div>
   <div class="post" id="post-210142">
    <div class="subject"><a href="#post-210142">Re: Homer's GameDev Blog</a></div>
    <div class="body"><div class="quote"><br />I was reading in my Video Demystified book (handbook for video repair guys) about MPEG streams.<br />They can contain a series of JPEG images, which suffer no artefacts - that is to say, all frames come from the stream.</div><br /><br />I think you are referring to a format known as Motion-JPEG, or MJPEG.<br />Yes, it&#039;s basically just a stream of JPEGs. Only the images are encoded.<br />With &#039;full&#039; MPEG, you don&#039;t encode all images. You take &#039;keyframes&#039; at a certain interval, and then encode the difference between those two keyframes with a few heuristics. This gives you frames with information known as motion vectors. The keyframes are basically stored as JPEG images (with a few minor changes... one of them is that JPG contains its own optimized Huffman and quantization tables in the image... MPEG has fixed tables for faster decoding, they can be pre-optimized in software or hardware. My JPG decoder builds an optimized huffman decoder everytime you open a file).<br /><br />This gives you a lot more compression, but it isn&#039;t suitable for realtime purposes.<br />Firstly, you need to store the entire sequence of frames, which is a delay in itself. Secondly, you need to analyze this sequence of frames to determine all the motion. This is a rather bruteforce process (the main reason why video encoding is still relatively slow on high-end PCs).<br /><br />That&#039;s why digital camera&#039;s or TV capture cards and such will generally record in MJPEG format rather than real MPEG.<br />If you take these files and recode them into MPEG you can often get much better compression with little or no quality loss.<br /><br />DVDs and digital broadcasts such as satellite or cable TV will always use &#039;real&#039; MPEG.<br />This gives some side-effects that you&#039;ve probably witnessed already:<br />1) &#039;live&#039; broadcasts lag 1-2 seconds behind the same broadcast on analog TV. Funny with football matches... You hear the analog watching neighbours cheering over a goal that hasn&#039;t been scored yet on your screen.<br />2) Switching channels and/or recovering from loss of signal always takes a while... the decoder cannot continue decoding until it has received a complete frame, usually takes 1-1.5 seconds until one comes along.<br />3) When the image gets corrupted, you can clearly see the effect of the motion vector data... The garbled data can be seen moving across the screen in very linear fashion.<br /><br />For that reason it&#039;s also not really possible to play a DVD backwards frame by frame. The data can only be decoded forward, and most players don&#039;t have a buffer to hold all the frames, and then play backwards through them... Instead they will just skip from keyframe to keyframe in backward mode.</div>
    <div class="meta">Posted on 2009-12-31 09:40:52 by Scali</div>
   </div>
   <div class="post" id="post-210143">
    <div class="subject"><a href="#post-210143">Re: Homer's GameDev Blog</a></div>
    <div class="body">&quot;most of&quot;? I thought most frames in MPEGs (and other formats) are delta frames, with a few keyframes in &quot;optimal&quot; resolution. I think I once came upon a video player that showed &quot;direction vectors&quot; for mpegs - was quite interesting to see, whatever it was :)</div>
    <div class="meta">Posted on 2009-12-31 13:08:45 by f0dder</div>
   </div>
   <div class="post" id="post-210144">
    <div class="subject"><a href="#post-210144">Re: Homer's GameDev Blog</a></div>
    <div class="body"><div class="quote"><br />&quot;most of&quot;? I thought most frames in MPEGs (and other formats) are delta frames, with a few keyframes in &quot;optimal&quot; resolution. I think I once came upon a video player that showed &quot;direction vectors&quot; for mpegs - was quite interesting to see, whatever it was :)<br /></div><br /><br />That is correct. As I mentioned earlier, keyframes are emitted every 1-1.5 seconds on average... depending on quality settings ofcourse, higher quality will have more keyframes, lower quality will have fewer keyframes... especially early DivX encodings used very few keyframes to get good compression rates... But you would notice accumulation of error.<br />It&#039;s funny with certain things such as a football pitch... The grass will lose its detail over time, and the detail will &#039;snap&#039; back everytime a keyframe is received.<br /><br />But if we were to take 1 second intervals as an example... Say you have 24 fps (standard movie rate), that means that you have one keyframe for every 24 frames, so only about 4% of the frames is stored as a whole, the rest is all reconstructed from the motion info.</div>
    <div class="meta">Posted on 2009-12-31 14:30:53 by Scali</div>
   </div>
   <div class="post" id="post-210145">
    <div class="subject"><a href="#post-210145">Re: Homer's GameDev Blog</a></div>
    <div class="body">Here&#039;s the main two players involved in the new IOCP asynch file io stuff:<br /><pre><code><br />Object NetComFile, NetComFileID, DiskStream<br /> &nbsp;;RedefineMethod &nbsp;Done<br /> &nbsp;RedefineMethod &nbsp;Init, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Pointer, Pointer, dword, dword, Pointer<br /> &nbsp;RedefineMethod &nbsp;Done<br /> &nbsp;StaticMethod &nbsp; &nbsp;OnRead, &nbsp; &nbsp; &nbsp; &nbsp;PIOJOB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Some file data is ready<br /> &nbsp;StaticMethod &nbsp; &nbsp;OnWrite, &nbsp; &nbsp; &nbsp; PIOJOB<br /> &nbsp;StaticMethod &nbsp; &nbsp;DoRead, &nbsp; &nbsp; &nbsp; &nbsp;PIOJOB<br /> &nbsp;StaticMethod &nbsp; &nbsp;DoWrite, &nbsp; &nbsp; &nbsp; PIOJOB<br /> &nbsp;StaticMethod &nbsp; &nbsp; SetFilePointer,dword,dword<br /> &nbsp;StaticMethod &nbsp; &nbsp; Get_Progress_Percent<br /> &nbsp;StaticMethod &nbsp; &nbsp;ReadFile &nbsp; &nbsp; <br /> &nbsp;RedefineMethod &nbsp; BinRead, &nbsp; &nbsp; &nbsp; dword &nbsp; &nbsp; &nbsp; &nbsp; ;Initiate asynch Read(s)<br /> &nbsp;RedefineMethod &nbsp; BinWrite, &nbsp; &nbsp; &nbsp;Pointer,dword ;Initiate asynch Write(s)<br /> &nbsp;DefineVariable &nbsp;qOffset, &nbsp; QuadWord,{&lt;&gt;} &nbsp; &nbsp; ;FilePointer for the next Job we queue<br /> &nbsp;DefineVariable &nbsp;qFileSize, QuadWord,{&lt;&gt;} &nbsp; &nbsp; &nbsp;;Size of the file<br /> &nbsp;DefineVariable &nbsp;qProgress, QuadWord,{&lt;&gt;} &nbsp; &nbsp; &nbsp;;Total Amount of data transferred<br /> &nbsp;DefineVariable &nbsp;pEventSink,Pointer,NULL &nbsp; &nbsp; &nbsp;;-&gt; NetComFileEvent object<br />ObjectEnd<br /><br />;FileEvents callback <br />Object NetComFileEvents,3245345,Primer<br /> &nbsp; &nbsp;DynamicAbstract OnRead,Pointer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;-&gt; IOJob<br /> &nbsp; &nbsp;DynamicAbstract OnWrite,Pointer &nbsp; &nbsp; &nbsp; &nbsp; ;-&gt; IOJob<br /> &nbsp; &nbsp;DynamicAbstract OnEOF,Pointer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;-&gt; NetComFile<br /> &nbsp; &nbsp;DynamicAbstract OnClose,Pointer &nbsp; &nbsp; &nbsp; &nbsp; ;-&gt; NetComFile<br />ObjectEnd<br /></code></pre><br /><br />To get started, you call NetComEngine.OpenFile, passing it your pathname, desired access mode (R/W and sharing), and a pointer to an eventsink class you derived from &quot;NetComFileEvents&quot;.<br />This will return to you a new NetComFile object, which you use to issue file operations.<br />These will be broken up into small &quot;iojob requests&quot; (1500 bytes or less).<br />As each io request completes, calls are made to the eventsink you supplied.<br />Each io request is marked with a 64bit offset, so out-of-order processing is not too problematic.<br /><br />So, assuming you managed to get yourself a pointer to a NetComFile object, you might call the NetComFile.ReadFile method. <br />This generates a bunch of IOJobs and returns without waiting for the data to be received - as chunks of data are read, we will receive asynch notifications via our callback object, where Your Code decides what to do with it.<br />When the data has been exhausted, our eventsink will receive an &quot;OnEOF&quot; notification.. end of file.<br />When we receive that,we can choose to destroy the NetComFile object if we want... its not done for us.<br />When the NetComFile object is Destroyed (by You), our eventsink will receive one final notification, alerting the Application that this pointer is about to become invalid.<br /><br /><br /></div>
    <div class="meta">Posted on 2010-01-01 00:59:57 by Homer</div>
   </div>
   <div class="post" id="post-210149">
    <div class="subject"><a href="#post-210149">Re: Asynch (Overlapped) File IO via IOCP Thread Pooling</a></div>
    <div class="body">NetComEngine/NetComFile allow you to perform disk operations &quot;in the background&quot;, alerting you when IO operations have completed.<br /><br />The NetComFile class represents an Asynchronous Communication Channel for a File supporting full read/write capability, it can act as a FileStream, and it supports random access, although it is not 100% optimized for that.<br />Aynchronous IO is managed by (some additions to) the NetComEngine IOCP framework, and file events are received via a user-defined eventsink derived from an abstract class - this means you control what happens when a chunk of data is ready, and you control it on a per-file basis. <br /><br />Here&#039;s the code for NetComFile.<br />I&#039;ll consider this beta until it&#039;s been hardness-tested, but all seems well.<br />Oh - and expect this code to change!! I am quite likely to make changes in fact.<br />Consider this a sneak preview or something, but I&#039;ll post a bunch of working code anyway.<br />Next posts will contain the updates for NetComEngine.<br /><br /><pre><code><br />; ==================================================================================================<br />; Title: &nbsp; NetComFile.inc<br />; Author: &nbsp;Homer / G. Friedrich<br />; Version: 1.0.0<br />; Purpose: Asynchronous File IO via NetCom&#039;s IOCP Engine<br />; Notes: &nbsp; Version 1.0.0, January 2010<br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- First release.<br />;	 &nbsp; &nbsp; &nbsp; &nbsp;- Read/Write Completion Methods are Mutexed (ObjLock) within NetComEngine.WorkerThread<br />;	 &nbsp; &nbsp; &nbsp; &nbsp;- This protects internal Counters from being corrupted by simultaneous Completions.<br />;	 &nbsp; &nbsp; &nbsp; &nbsp;- IT DOES NOT GUARANTEE ORDER OF COMPLETION<br />;	 &nbsp; &nbsp; &nbsp; &nbsp;- However, we tagged each IOJob with a 64-bit Offset (&quot;FilePosition&quot;) :)<br />;	 &nbsp; &nbsp; &nbsp; &nbsp;- <br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - GUARANTEEING ORDER OF COMPLETION<br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Your NetComFileEvents eventsink object must implement its own FilePosition counter,<br />;	 &nbsp; &nbsp; &nbsp; - and Collect any IOJobs whose 64-bit Offset doesn&#039;t match the current FilePosition :)<br />;	 &nbsp; &nbsp; &nbsp; - Collected Jobs will have to be dealt with in a Delayed way.<br />;	 &nbsp; &nbsp; &nbsp; - NOTE that EventSink Notification calls are already within an ObjectLock !!<br />;	 &nbsp; &nbsp; &nbsp; - Your EventSink methods (and their Counters and other data) are effectively threadsafe !! Good stuff huh <br />; ==================================================================================================<br />PIOJOB typedef ptr IOJOB<br />.code<br /><br />if IMPLEMENT<br /><br />;Method: &nbsp; &nbsp;NetComFile.Init<br />;Purpose: &nbsp; Attempt to Open a File for Asynch IO<br />;Arguments: pOwner -&gt; Owner Object<br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstrPathName -&gt; full pathname of file<br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dShareMode = any combo of FILE_SHARE_READ, FILE_SHARE_WRITE<br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dAccessMode = any combo of GENERIC_READ, GENERIC_WRITE<br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pEventSink -&gt; EventSink interface derived from NetComFileEvent<br />;Returns: &nbsp; NULL = SUCCESS<br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ErrorCode = Failed to open file (need WRITE access?) <br />;Remarks: &nbsp; Failure can be due to bad SHARE access ,etc<br />Method NetComFile.Init,uses esi,pOwner,pstrPathName,dShareMode,dAccessMode,pEventSink<br /> &nbsp; &nbsp;SetObject esi<br /> &nbsp; &nbsp;m2m .pEventSink,pEventSink,edx<br /> &nbsp; &nbsp;DbgHex pEventSink<br /> &nbsp; &nbsp;;If the user requests Write access, we will use OPEN_ALWAYS<br /> &nbsp; &nbsp;;This allows new files to be created.<br /> &nbsp; &nbsp;mov edx,dAccessMode<br /> &nbsp; &nbsp;and edx,GENERIC_WRITE<br /> &nbsp; &nbsp;.if edx!=0<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov edx,OPEN_ALWAYS &nbsp; &nbsp;<br /> &nbsp; &nbsp;.else<br /> &nbsp; &nbsp; &nbsp; &nbsp;;If user only wants READ access, the file should exist!<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov edx,OPEN_EXISTING<br /> &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp;ACall Init,pOwner,pstrPathName,dShareMode,dAccessMode,edx,FILE_FLAG_OVERLAPPED<br /> &nbsp; &nbsp;.if eax!=STM_OPENERROR &nbsp;;then eax=hFile, i think..<br /> &nbsp; &nbsp; &nbsp; &nbsp;invoke GetLastError <br /> &nbsp; &nbsp; &nbsp; &nbsp;.if eax== ERROR_ALREADY_EXISTS<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;This isnt really an error<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DbgText &quot;opened EXISTING file&quot;<br /> &nbsp; &nbsp; &nbsp; &nbsp;.elseif eax!=0<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Return unhandled error <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DbgDec eax,&quot;returning error code&quot;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ExitMethod<br /> &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp;;Bind the FileHandle to the IOCP<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov edx,pOwner<br /> &nbsp; &nbsp; &nbsp; &nbsp;invoke CreateIoCompletionPort,.hFile,.NetComEngine.hIOCP,0,0<br /> &nbsp; &nbsp; &nbsp; &nbsp;.if eax==0<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Possibly not an error if a given filehandle is already associated<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DbgWarning &quot;NetComFile.Init Error - failed to bind FileHandle to IOCP&quot;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invoke GetLastError<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DbgDec eax,&quot;Reason&quot;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.if eax==ERROR_INVALID_HANDLE<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DbgDec .hFile,&quot;is an invalid handle, apparently..&quot; &nbsp; &nbsp; &nbsp; &nbsp; <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int 3<br /> &nbsp; &nbsp; &nbsp; &nbsp;.else<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Initialize FileSize<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invoke GetFileSize, .hFile, addr .qFileSize.HiDWord <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov .qFileSize.LoDWord,eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall esi.SetFilePointer,0,0<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Return success<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xor eax,eax<br /> &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp;.endif<br />MethodEnd<br /><br />;Method: &nbsp; &nbsp;NetComFile.Done<br />;Purpose: &nbsp; Destructor method<br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Notify application that the object is redundant<br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Release resources<br />Method NetComFile.Done,uses esi<br /> &nbsp; &nbsp;SetObject esi<br /> &nbsp; &nbsp;DbgWarning &quot;NetComFile.Done&quot;<br /> &nbsp; &nbsp;mov edx,.pEventSink<br /> &nbsp; &nbsp;.if edx!=0<br /> &nbsp; &nbsp; &nbsp; &nbsp;;Warn the application that this NetComFile is about to be Destroyed<br /> &nbsp; &nbsp; &nbsp; &nbsp;OCall edx::NetComFileEvents.OnClose,esi<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov .pEventSink,0<br /> &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp;ACall Done<br />MethodEnd<br /><br />;Method: &nbsp; &nbsp;NetComFile.OnRead<br />;Purpose: &nbsp; Sinks &#039;READ io completion&#039; events<br />Method NetComFile.OnRead, uses esi, pIOJob:PIOJOB<br />LOCAL q:QuadWord<br /> &nbsp; &nbsp;SetObject esi<br /> &nbsp; &nbsp;;A FileRead request has completed.<br /><br /><br /> &nbsp; &nbsp;;Increment the progress counter<br /> &nbsp; &nbsp;mov eax,pIOJob<br /> &nbsp; &nbsp;DbgDec .qProgress.LoDWord<br /> &nbsp; &nbsp;DbgDec .IOJOB.dBytesUsed<br /> &nbsp; &nbsp;qdadd .qProgress,.IOJOB.dBytesUsed &nbsp;<br /><br /> &nbsp; &nbsp;;Send Progress Notification<br /> &nbsp; &nbsp;.if .pEventSink!=0<br /> &nbsp; &nbsp; &nbsp; &nbsp;OCall .pEventSink::NetComFileEvents.OnRead,pIOJob<br /> &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp;;Check for EOF<br /> &nbsp; &nbsp;qmov q,.qProgress<br /> &nbsp; &nbsp;qqsub q,.qFileSize<br /> &nbsp; &nbsp;.if q.LoDWord==0 &amp;&amp; q.HiDWord==0<br /> &nbsp; &nbsp; &nbsp; &nbsp;OCall .pEventSink::NetComFileEvents.OnEOF,esi<br /> &nbsp; &nbsp;.endif<br /><br /><br />MethodEnd<br /><br />;Method: &nbsp; &nbsp;NetComFile.OnWrite<br />;Purpose: &nbsp; Sinks &#039;WRITE io completion&#039; events<br />Method NetComFile.OnWrite,uses esi, pIOJob:PIOJOB<br /> &nbsp; &nbsp;SetObject esi<br /><br /> &nbsp; &nbsp;;Update FileSize - in case of access mid-file<br /> &nbsp; &nbsp;invoke GetFileSize, .hFile, addr .qFileSize.HiDWord <br /> &nbsp; &nbsp;mov .qFileSize.LoDWord,eax &nbsp;<br /> &nbsp; &nbsp;<br /> &nbsp; &nbsp;;Increment the progress counter<br /> &nbsp; &nbsp;qdadd .qProgress,.IOJOB.dBytesUsed &nbsp; <br /> &nbsp; &nbsp;<br /> &nbsp; &nbsp;;Send Progress Notification<br /> &nbsp; &nbsp;.if .pEventSink!=0<br /> &nbsp; &nbsp; &nbsp; &nbsp;OCall .pEventSink::NetComFileEvents.OnWrite,pIOJob<br /> &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp;<br />MethodEnd<br /><br />;Method: &nbsp; &nbsp;NetComFile.DoRead<br />;Purpose: &nbsp; Perform call to initiate Overlapped FileRead request<br />;Returns: &nbsp; TRUE/FALSE<br />;Remarks: &nbsp; Assumes the IOJob has been initialized with valid values.<br />Method NetComFile.DoRead, uses esi, pIOJob:PIOJOB<br />LOCAL q:QuadWord<br /> &nbsp; &nbsp;;Set the File Offset for this FileRead request<br /> &nbsp; &nbsp;SetObject esi<br /> &nbsp; &nbsp;mov edx,pIOJob &nbsp; &nbsp; <br /> &nbsp; &nbsp;.if .IOJOB.dBytesUsed!=0<br /> &nbsp; &nbsp; &nbsp; &nbsp;DbgDec .IOJOB.dBytesUsed,&quot;requesting read&quot;<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp;;Queue the Read request<br /> &nbsp; &nbsp; &nbsp; &nbsp;invoke ReadFile,.hFile,.IOJOB.WSABuf.pBuffer,.IOJOB.dBytesUsed,addr .IOJOB.dBytesUsed,edx<br /> &nbsp; &nbsp; &nbsp; &nbsp;.if eax != TRUE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Did read IO complete synchronously?<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invoke GetLastError &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;No, check if it is a pending state<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.if eax != ERROR_IO_PENDING<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;OCall esi.OnError, pIOJob<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DbgDec eax,&quot;Unhandled Error in NetComFile.DoRead&quot;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int 3<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return FALSE<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp;.else<br /> &nbsp; &nbsp; &nbsp; &nbsp;;FileStream is exhausted - End Of File<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov edx,.pEventSink<br /> &nbsp; &nbsp; &nbsp; &nbsp;.if edx!=0<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall edx::NetComFileEvents.OnEOF,esi<br /> &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov eax,FALSE<br /> &nbsp; &nbsp;.endif<br />MethodEnd<br /><br />;Method: &nbsp; &nbsp;NetComFile.Write<br />;Purpose: &nbsp; Perform call to initiate Overlapped FileWrite request<br />;Returns: &nbsp; TRUE/FALSE<br />;Remarks: &nbsp; Assumes the IOJob has been initialized with valid values.<br />Method NetComFile.DoWrite, uses esi, pIOJob:PIOJOB<br /> &nbsp; &nbsp;SetObject esi<br /> &nbsp; &nbsp;SetObject esi<br /> &nbsp; &nbsp;mov edx,pIOJob &nbsp; &nbsp; <br /> &nbsp; &nbsp;.if .IOJOB.dBytesUsed!=0<br /> &nbsp; &nbsp; &nbsp; &nbsp;invoke WriteFile,.hFile,.IOJOB.WSABuf.pBuffer,.IOJOB.dBytesUsed,addr .IOJOB.dBytesUsed,edx<br /> &nbsp; &nbsp; &nbsp; &nbsp;.if eax != TRUE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Did IO complete synchronously?<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invoke GetLastError &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;No, check if it is a pending state<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.if eax != ERROR_IO_PENDING<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;OCall esi.OnError, pIOJob<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DbgDec eax,&quot;Unhandled error in NetComFile.DoWrite&quot;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;int 3<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return FALSE<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp;.else<br /> &nbsp; &nbsp; &nbsp; &nbsp;DbgWarning &quot;NetComFile.DoWrite: dBytesUsed=0&quot;<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov eax,FALSE<br /> &nbsp; &nbsp;.endif<br />MethodEnd<br /><br />;Method: &nbsp; &nbsp;NetComFile.BinWrite<br />;Purpose: &nbsp; Write some data to the file<br />;Args: &nbsp; &nbsp; &nbsp;pData = ptr to user&#039;s data to be Written<br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dLength = #bytes to Write<br />;Remarks: &nbsp; Be sure to call SetFilePointer at least once prior to this call!<br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Its safe to destroy the input buffer as soon as your call completes.<br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; The data will be written to the file in the background.<br />Method NetComFile.BinWrite, uses esi,pData,dLength<br /> &nbsp; &nbsp;SetObject esi<br /> &nbsp; &nbsp;.while dLength!=0<br /> &nbsp; &nbsp; &nbsp; &nbsp;;Allocate an IOJob<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov edx,.pOwner<br /> &nbsp; &nbsp; &nbsp; &nbsp;xOCall .NetComEngine.IOJobs::NetComIOJobPool.NewItem, esi, FILE_WRITE<br /> &nbsp; &nbsp; &nbsp; &nbsp;.if eax != NULL<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Determine how much data to put into this IOJob<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov ecx,eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov eax,.IOJOB.WSABuf.dLength<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.if eax&gt;dLength<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov eax,dLength<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov .IOJOB.dBytesUsed,eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sub dLength,eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Copy the IO Offset into the Job<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m2m .IOJOB.Ovl.OffsetHigh,.qOffset.HiDWord,eax &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m2m .IOJOB.Ovl.an_Offset, .qOffset.LoDWord,eax <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Copy (one buffer or less) bytes of data into the Job<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push ecx<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invoke RtlMoveMemory,.IOJOB.WSABuf.pBuffer,pData,eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop ecx<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;add pData,eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Queue the Write request<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall esi.DoWrite, ecx<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop ecx<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Update the IO Offset<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;qdadd .qOffset,ecx<br /> &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp;.endw<br />MethodEnd<br /><br />;Method: &nbsp; &nbsp;NetComFile.BinRead<br />;Purpose: &nbsp; Read some data from the file<br />;Args: &nbsp; &nbsp; &nbsp;dLength = #bytes to read<br />;Remarks: &nbsp; Be sure to call SetFilePointer at least once prior to this call!<br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Notifications will be received the usual way<br />Method NetComFile.BinRead, uses esi,dLength<br /> &nbsp; &nbsp;SetObject esi<br /> &nbsp; &nbsp;.while dLength!=0<br /> &nbsp; &nbsp; &nbsp; &nbsp;;Allocate an IOJob<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov edx,.pOwner<br /> &nbsp; &nbsp; &nbsp; &nbsp;OCall .NetComEngine.IOJobs::NetComIOJobPool.NewItem, esi, FILE_READ<br /> &nbsp; &nbsp; &nbsp; &nbsp;.if eax != NULL<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Determine how much data to put into this IOJob<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov ecx,eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov eax,.IOJOB.WSABuf.dLength<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.if eax&gt;dLength<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov eax,dLength<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov .IOJOB.dBytesUsed,eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sub dLength,eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Copy the IO Offset into the Job<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m2m .IOJOB.Ovl.OffsetHigh,.qOffset.HiDWord,eax &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;m2m .IOJOB.Ovl.an_Offset, .qOffset.LoDWord,eax <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Queue the Read request<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall esi.DoRead, ecx<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Update the IO Offset<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;qdadd .qOffset,eax<br /> &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp;.endw<br />MethodEnd<br /><br />;Method: &nbsp; &nbsp;NetComFile.ReadFile<br />;Purpose: &nbsp; Read the entire contents of the file<br />;Remarks: &nbsp; This method queues asynchronous requests for chunks of file,<br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; then returns immediately... Event notifications will be sent <br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to the User&#039;s EventSink (NetComFileEvent-derived interface)<br />Method NetComFile.ReadFile, uses esi<br />LOCAL pIOJob:PIOJOB<br />LOCAL q:QuadWord<br /> &nbsp; &nbsp;SetObject esi<br /> &nbsp; &nbsp;qmov q,.qFileSize<br /> &nbsp; &nbsp;.repeat<br /> &nbsp; &nbsp; &nbsp; &nbsp;.if q.HiDWord!=0<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;The filesize is larger than 32 bits !!!<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Make the biggest READ call we possibly can with 32 bits<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall esi.BinRead ,-1<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;qdsub q,-1<br /> &nbsp; &nbsp; &nbsp; &nbsp;.else<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.break .if q.LoDWord==0<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;The filesize is 32 bits<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Make a READ call for that amount<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall esi.BinRead, &nbsp;.qFileSize.LoDWord &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;qdsub q,.qFileSize.LoDWord <br /> &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp;.until 0<br />MethodEnd<br /><br /><br />;Method: &nbsp; &nbsp;NetComFile.SetFilePointer<br />;Purpose: &nbsp; Sets the internal FilePointer offset (used when queuing IO requests)<br />;Args: &nbsp; &nbsp; &nbsp;dHigh,dLow = 64-bit file offset<br />;Remarks: &nbsp; With care, you can use this to random-access a file.<br />Method NetComFile.SetFilePointer,uses esi,dHigh:dword,dLow:dword<br /> &nbsp; &nbsp;SetObject esi<br /> &nbsp; &nbsp;m2m .qOffset.HiDWord,dHigh,edx<br /> &nbsp; &nbsp;m2m .qOffset.LoDWord,dLow,edx<br />MethodEnd<br /><br />;Method:	NetComFile.Get_Progress_Percentage<br />;Purpose:	Convert Progress QuadWord into Percentage Dword<br />;Returns: &nbsp; File Progress, integer Percentage<br />Method NetComFile.Get_Progress_Percent,uses esi ebx ecx<br />LOCAL q:QuadWord<br /> &nbsp; &nbsp;SetObject esi<br /> &nbsp; &nbsp;mov eax,.qProgress.LoDWord<br /> &nbsp; &nbsp;mov edx,.qProgress.HiDWord<br /> &nbsp; &nbsp;mov ebx,100<br /> &nbsp; &nbsp;qdmul<br /> &nbsp; &nbsp;mov ebx,.qFileSize.LoDWord<br /> &nbsp; &nbsp;mov ecx,.qFileSize.HiDWord<br /> &nbsp; &nbsp;qqdiv<br />MethodEnd<br /><br />endif<br /></code></pre><br /><br /><br />About random access, theres two catches.<br />One is that you need to call NetComFile.SetFilePointer whever the IO offset has moved (unless the next offset is linear).<br />And the other is that I haven&#039;t used the appropriate flag in my CreateFile call, so the filesystem isn&#039;t expecting it.<br />But it&#039;ll work :)<br /><br />A future update might use a switch for linear/random access modes.</div>
    <div class="meta">Posted on 2010-01-01 22:02:37 by Homer</div>
   </div>
   <div class="post" id="post-210150">
    <div class="subject"><a href="#post-210150">Re: Homer's GameDev Blog</a></div>
    <div class="body">The changes to NetComEngine are mostly inside the Worker Thread:<br /><br /><pre><code><br />; ——————————————————————————————————————————————————————————————————————————————————————————————————<br />; Method: &nbsp; &nbsp;NetComEngine.Worker<br />; Purpose: &nbsp; Here is the HEART AND SOUL of the NetEngine.<br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;This thread is responsible for waiting on IOCP completion notifications and passing<br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;them to the appropriate handler.<br />; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;There can be several of these Worker threads operating asynchronously.<br />; Arguments: None.<br />; Return: &nbsp; &nbsp;Nothing.<br /><br />Method NetComEngine.Worker, uses ebx edi esi<br /> &nbsp; &nbsp;local pIOMsg:PIOMSG, dCompletionKey:dword, dBytes:dword, dFlags:dword<br /><br /> &nbsp; &nbsp;SetObject esi<br /><br /><br /> &nbsp; &nbsp;.repeat<br /> &nbsp; &nbsp; &nbsp;;The GetQueuedCompletionStatus api call will (if successful) return two useful pieces of<br /> &nbsp; &nbsp; &nbsp;;information to us. One is the &quot;completion key&quot; of the completed io, the other is a ptr<br /> &nbsp; &nbsp; &nbsp;;to the IOJob which represents the io operation which (we hope) is completed.<br /> &nbsp; &nbsp; &nbsp;invoke GetQueuedCompletionStatus, .hIOCP, addr dBytes,<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr dCompletionKey,<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr pIOMsg, 500<br /> &nbsp; &nbsp; &nbsp;mov ebx, pIOMsg<br /> &nbsp; &nbsp; &nbsp;.if ebx != NULL<br /> &nbsp; &nbsp; &nbsp; &nbsp;;Something got Dequeued from the IOCP...<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov edi, .IOMSG.pConnection<br /> &nbsp; &nbsp; &nbsp; &nbsp;.if .IOMSG.sdOperation &gt; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Job or message?<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;IO Job<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Determine whether the operation completed successfully or not &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.if .IOMSG.sdOperation&lt;5<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;socket io<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invoke WSAGetOverlappedResult, .NetComConnection.hSocket, ebx, \<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addr .IOJOB.dBytesUsed, \<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FALSE, addr dFlags<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.if eax != FALSE<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.switch .IOJOB.sdOperation<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.case SOCKET_READ<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov eax, dBytes<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lock add .dBytesIn, eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall edi::NetComConnection.OnRead, ebx<br /> &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.case SOCKET_WRITE<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov eax, dBytes<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lock add .dBytesOut, eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall edi::NetComConnection.OnWrite, ebx<br /> &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.case SOCKET_ACCEPT<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov eax, dBytes<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lock add .dBytesIn, eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall edi::NetComConnection.OnAccept, ebx<br /> &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.case SOCKET_CONNECT<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov eax, dBytes<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lock add .dBytesOut, eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall edi::NetComConnection.OnConnect, ebx <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.default<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DbgWarning &quot;UNKNOWN IOJOB OPERATION IDENTIFIER&quot;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall edi::NetComConnection.QueueClose<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endsw<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.else<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DbgDec $invoke(GetLastError),&quot;WSAGetOverlappedResult failed&quot;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.ifBitSet .NetComConnection.dFlags, NCC_ABORT<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.if .IOJOB.sdOperation == SOCKET_READ<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;If we have a read operation, we have to remove it from the read SDLL<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;LockObjectAccess .NetComConnection<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lea eax, .IOJOB.pNextItem<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SDLL_Remove eax, ecx, edx<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;UnlockObjectAccess .NetComConnection<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xOCall .IOJobs::NetComIOJobPool.FreeItem, ebx<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.else<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invoke WSAGetLastError &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;This error is thread specific<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.continue .if eax == ERROR_IO_INCOMPLETE<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall edi::NetComConnection.OnError, ebx, eax<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.else<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;file io<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;invoke GetOverlappedResult,.NetComFile.hFile,ebx,addr .IOJOB.dBytesUsed,FALSE<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.if eax != FALSE<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.switch .IOJOB.sdOperation<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.case FILE_READ<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xOCall edi::NetComFile.OnRead, ebx<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xOCall .IOJobs::NetComIOJobPool.FreeItem, ebx<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.continue ;&lt;-- important - skip all remaining code to end of loop<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.case FILE_WRITE<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xOCall edi::NetComFile.OnWrite, ebx<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xOCall .IOJobs::NetComIOJobPool.FreeItem, ebx<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.continue ;&lt;-- important - skip all remaining code to end of loop<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.default<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DbgWarning &quot;UNKNOWN FILE IOJOB OPERATION IDENTIFIER&quot;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xOCall .IOJobs::NetComIOJobPool.FreeItem, ebx<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endsw<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.else<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DbgDec $invoke(GetLastError),&quot;GetOverlappedResult failed&quot;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xOCall .IOJobs::NetComIOJobPool.FreeItem, ebx<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp;.else<br /> &nbsp; &nbsp; &nbsp; &nbsp;int 3<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;IO Message<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.switch .IOMSG.sdOperation<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.case MESSAGE_DISCONNECT<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall edi::NetComConnection.OnDisconnect, ebx<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.case MESSAGE_CLOSE<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall edi::NetComConnection.OnClose, ebx<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.case MESSAGE_TIMEOUT<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall edi::NetComConnection.OnTimeout, ebx<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall edi::NetComConnection.QueueClose<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.default<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DbgWarning &quot;UNKNOWN IOMSG OPERATION IDENTIFIER&quot;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall edi::NetComConnection.QueueClose<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endsw<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp; &nbsp; &nbsp;lock dec .NetComConnection.dPendingIORequests<br /><br />; &nbsp; &nbsp; &nbsp; &nbsp;DbgDec .NetComConnection.dPendingIORequests<br /> &nbsp; &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp;;Check if the NetComConnection that is marked to close has no pending IOJobs.<br /> &nbsp; &nbsp; &nbsp; &nbsp;.ifBitSet .NetComConnection.dFlags, NCC_CLOSE<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.if .NetComConnection.dPendingIORequests == 0<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DbgWarning &quot;Closing NetComConnection&quot;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;In this case dispose and recycle the NetComConnection.<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push .NetComConnection.pOwner<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall edi::NetComConnection.Done<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop ecx<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;xOCall ecx::NetComConnectionPool.FreeItem, edi<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /><br /> &nbsp; &nbsp; &nbsp;.endif<br /><br /> &nbsp; &nbsp;.until (.dShuttingDown == SDN_CLOSE_WORKERS &amp;&amp; .IOJobs.dCount == 0) || \<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.dShuttingDown == SDN_QUIT_WORKERS &nbsp; &nbsp; ;Abortive close<br /><br /> &nbsp; &nbsp;DbgText &quot;NetComEngine worker death&quot;<br />MethodEnd<br /></code></pre><br /><br />NetComFile uses NetComEngine&#039;s internal IOJob Pool, which was designed for Socket IO... In many ways, NetComFile resembles NetComConnection. One has a file handle, the other has a socket handle.<br />But they are not the same.<br />Unlike NetComConnections, NetComEngine does not manage instances of NetComFile, or their associated NetComFileEvents-derived classes. Other than the IOJobs you&#039;ll be working with, Your Application is in total control of the File stuff.<br /><br />Previously, NetComEngine supported two kinds of message containers - IOJOB and IOMSG.<br />And it still does.<br />There&#039;s a couple of new IOJOB operation codes for FileRead and FileWrite.<br />The Worker thread examines the completed message container.<br />If its an IOJOB, it looks further to see if its a File Operation, or a Socket Operation.<br />Then it handles these separately, using either GetOverlappedResult or WSAGetOverlappedResult, but essentially using the same logic otherwise.<br /><br />I decided to separate these cleanly, instead of doing some kind of dirty asm jump into a common handler, because the error handler needs to call either GetLastError, or WSAGetLastError :P<br /><br />NetComEngine has one new Method, which is used to get our hands on a NetComFile object:<br /><pre><code><br />; ——————————————————————————————————————————————————————————————————————————————————————————————————<br />; Method:&nbsp; &nbsp; NetComEngine.OpenFile<br />; Purpose:&nbsp;  Attempt to open new/existing file for asynch io<br />; Arguments: pstrPathName -&gt; Pathname of file <br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dShareMode&nbsp; = any combo of FILE_SHARE_READ, FILE_SHARE_WRITE<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dAccessMode = any combo of GENERIC_READ, GENERIC_WRITE<br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pEventSink -&gt; EventSink derived from NetComFileEvents<br />; Return:&nbsp; &nbsp; NULL (failed) or pNetComFile<br />Method NetComEngine.OpenFile,uses esi,pstrPathName,dShareMode,dAccessMode,pEventSink<br />LOCAL file<br />&nbsp; &nbsp; SetObject esi<br />&nbsp; &nbsp; mov file,$New(NetComFile)<br />&nbsp; &nbsp; ;Initialize the NetComFile object, setting Parent = this (NetComEngine)<br />&nbsp; &nbsp; OCall eax::NetComFile.Init,esi,pstrPathName,dShareMode,dAccessMode,pEventSink<br />&nbsp; &nbsp; DbgDec eax<br />&nbsp; &nbsp; .if eax==0<br />&nbsp; &nbsp; &nbsp; &nbsp; DbgText &quot;Opened file&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; return file<br />&nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; ;Failed to initialize NetComFile object<br />&nbsp; &nbsp; &nbsp; &nbsp; DbgWarning &quot;Failed to open file&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; DbgDec eax,&quot;Error code&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; Destroy file<br />&nbsp; &nbsp; &nbsp; &nbsp; xor eax,eax&nbsp; &nbsp;  <br />&nbsp; &nbsp; .endif<br />MethodEnd<br /></code></pre><br /><br />Next post will contain the update for NetCom&#039;s object definitions.<br /></div>
    <div class="meta">Posted on 2010-01-01 22:33:47 by Homer</div>
   </div>
   <div class="post" id="post-210152">
    <div class="subject"><a href="#post-210152">Re: Homer's GameDev Blog</a></div>
    <div class="body">Here&#039;s the changes to NetCom&#039;s objects:<br /><br /><pre><code><br />; ==================================================================================================<br />; File stuff<br />Object NetComFile, NetComFileID, DiskStream<br /> &nbsp;RedefineMethod &nbsp;Init, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Pointer, Pointer, dword, dword, Pointer<br /> &nbsp;RedefineMethod &nbsp;Done<br /> &nbsp;StaticMethod &nbsp; &nbsp;OnRead, &nbsp; &nbsp; &nbsp; &nbsp;PIOJOB &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Some file data is ready<br /> &nbsp;StaticMethod &nbsp; &nbsp;OnWrite, &nbsp; &nbsp; &nbsp; PIOJOB<br /> &nbsp;StaticMethod &nbsp; &nbsp;DoRead, &nbsp; &nbsp; &nbsp; &nbsp;PIOJOB<br /> &nbsp;StaticMethod &nbsp; &nbsp;DoWrite, &nbsp; &nbsp; &nbsp; PIOJOB<br /> &nbsp;StaticMethod &nbsp; &nbsp; SetFilePointer,dword,dword<br /> &nbsp;StaticMethod &nbsp; &nbsp; Get_Progress_Percent<br /> &nbsp;StaticMethod &nbsp; &nbsp;ReadFile &nbsp; &nbsp; <br /> &nbsp;RedefineMethod &nbsp; BinRead, &nbsp; &nbsp; &nbsp; dword &nbsp; &nbsp; &nbsp; &nbsp; ;Initiate asynch Read(s)<br /> &nbsp;RedefineMethod &nbsp; BinWrite, &nbsp; &nbsp; &nbsp;Pointer,dword ;Initiate asynch Write(s)<br /> &nbsp;DefineVariable &nbsp;ObjLock, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ObjectLock, &nbsp; &nbsp; &nbsp; {} &nbsp; &nbsp;;Don&#039;t move this member<br /> &nbsp;DefineVariable &nbsp;qOffset, &nbsp; QuadWord,{&lt;&gt;} &nbsp; &nbsp; ;FilePointer for the next Job we queue<br /> &nbsp;DefineVariable &nbsp;qFileSize, QuadWord,{&lt;&gt;} &nbsp; &nbsp; &nbsp;;Size of the file<br /> &nbsp;DefineVariable &nbsp;qProgress, QuadWord,{&lt;&gt;} &nbsp; &nbsp; &nbsp;;Total Amount of data transferred<br /> &nbsp;DefineVariable &nbsp;pEventSink,Pointer,NULL &nbsp; &nbsp; &nbsp;;-&gt; NetComFileEvent object<br />ObjectEnd<br /><br />;FileEvents callback <br />Object NetComFileEvents,3245345,Primer<br /> &nbsp; &nbsp;DynamicAbstract OnRead,Pointer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;-&gt; IOJob<br /> &nbsp; &nbsp;DynamicAbstract OnWrite,Pointer &nbsp; &nbsp; &nbsp; &nbsp; ;-&gt; IOJob<br /> &nbsp; &nbsp;DynamicAbstract OnEOF,Pointer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;-&gt; NetComFile<br /> &nbsp; &nbsp;DynamicAbstract OnClose,Pointer &nbsp; &nbsp; &nbsp; &nbsp; ;-&gt; NetComFile<br />ObjectEnd<br />; ==================================================================================================<br /><br />;Note: Connections are tracked in a linked list, since they may come from an attack! The supervisor<br />; &nbsp; &nbsp; &nbsp;thread should analyse them and eventually close the connections and add the IP addresses to<br />; &nbsp; &nbsp; &nbsp;the black list.<br /><br />Object NetComEngine, NetComEngineID, Primer<br /> &nbsp;VirtualMethod &nbsp; CloseConnections<br /> &nbsp;VirtualMethod &nbsp; ConnectTo, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Pointer, dword, dword<br /> &nbsp;RedefineMethod &nbsp;Done<br /> &nbsp;VirtualMethod &nbsp; GetLogicalCpuCount<br /> &nbsp;RedefineMethod &nbsp;Init, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pointer, dword, dword, dword, dword<br /> &nbsp;VirtualMethod &nbsp; Listen, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pointer, dword &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;pProtocol, dListenPort<br /> &nbsp;VirtualMethod &nbsp; QueueAcceptor, &nbsp; &nbsp; &nbsp;PLISTENER<br /> &nbsp;VirtualMethod &nbsp; RawConnection, &nbsp; &nbsp; &nbsp;Pointer, dword &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;pProtocol, dSocketType<br /> &nbsp;VirtualMethod &nbsp; OpenFile, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pointer,dword,dword,Pointer<br /><br /> &nbsp;DefineVariable &nbsp;hIOCP, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Handle, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0<br /> &nbsp;DefineVariable &nbsp;dShuttingDown, &nbsp; &nbsp; &nbsp;dword, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0<br /> &nbsp;DefineVariable &nbsp;dAcceptors, &nbsp; &nbsp; &nbsp; &nbsp; dword, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0<br /> &nbsp;DefineVariable &nbsp;hSupervisor, &nbsp; &nbsp; &nbsp; &nbsp;Handle, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0<br /> &nbsp;DefineVariable &nbsp;LocalHost, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sockaddr_in, &nbsp; &nbsp; &nbsp;{}<br /> &nbsp;DefineVariable &nbsp;ConnectionChain, &nbsp; &nbsp;SDLL_SENTINEL, &nbsp; &nbsp;{NULL, NULL}<br /> &nbsp;DefineVariable &nbsp;dBytesIn, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dword, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0<br /> &nbsp;DefineVariable &nbsp;dBytesOut, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dword, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0<br /> &nbsp;DefineVariable &nbsp;dRateIn, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dword, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0<br /> &nbsp;DefineVariable &nbsp;dRateOut, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dword, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0<br /><br /> &nbsp;Embed Connections, &nbsp; &nbsp;NetComConnectionPool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Pool of NetComConnections<br /> &nbsp;Embed Listeners, &nbsp; &nbsp; &nbsp;DataCollection &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;DataCollection of listening sockets<br /> &nbsp;Embed IOJobs, &nbsp; &nbsp; &nbsp; &nbsp; NetComIOJobPool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;IOJob Pool<br /> &nbsp;Embed IOMessages, &nbsp; &nbsp; NetComIOMsgPool &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;IOMsg Pool<br /> &nbsp;Embed Workers, &nbsp; &nbsp; &nbsp; &nbsp;DwordCollection &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Collection of Worker thread handles<br />ObjectEnd<br /><br /></code></pre><br /><br />Now, you&#039;ll need to include the QuadWord.inc macros, but otherwise, you should be able to still build and use the existing NetComEngine demos with these updates in place.<br /><br />And you can start to experiment with NetComFile !!<br /></div>
    <div class="meta">Posted on 2010-01-01 22:56:26 by Homer</div>
   </div>
   <div class="post" id="post-210153">
    <div class="subject"><a href="#post-210153">Re: Homer's GameDev Blog</a></div>
    <div class="body">It&#039;s a pity we don&#039;t define some symbol in our macro files, so I could:<br /><br />ifndef __QuadWord__Macros<br /> &nbsp; %include ...<br /><br />I can do it with any Object Class by name, but not with a set of macros. Hum.<br />Eg<br /><br />;Late-Load this Object if necessary<br />ifndef DiskStream<br /> &nbsp;LoadObjects DiskStream<br />endif<br /><br />is perfectly legal.<br /></div>
    <div class="meta">Posted on 2010-01-01 23:00:32 by Homer</div>
   </div>
   <div class="post" id="post-210538">
    <div class="subject"><a href="#post-210538">Re: Homer's GameDev Blog</a></div>
    <div class="body">Another month has passed, let&#039;s assess the damage: http://store.steampowered.com/hwsurvey<br />Windows XP 32-bit down to 42.15% now, with only 0.63% being x64.<br />Windows 7 is at 28.53%, 19.50% of which is x64(!).<br />Vista is still going down aswell, roughly 28% now, 9% of which is x64.<br /><br />In other words, about 57% of all Windows users uses a DirectX 10/11-capable OS. About 30% of all Windows users use an x64 OS.</div>
    <div class="meta">Posted on 2010-02-01 11:15:57 by Scali</div>
   </div>
   <div class="post" id="post-210539">
    <div class="subject"><a href="#post-210539">Re: Homer's GameDev Blog</a></div>
    <div class="body"><div class="quote"><br />In other words, about 57% of all Windows users uses a DirectX 10/11-capable OS. About 30% of all Windows users use an x64 OS.<br /></div><br /><br />Let&#039;s put a positive and predictable spin on this, 100% of Windows users are using Windows :P</div>
    <div class="meta">Posted on 2010-02-01 12:13:48 by SpooK</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29358&amp;page=1" style="">&laquo;</a><a href="../?id=29358&amp;page=13" style="">&lt;</a><input type="hidden" name="id" value="29358" /><input type="number" name="page" min="1" max="15" step="1" value="14" onchange="this.form.submit();" /><a href="../?id=29358&amp;page=15">&gt;</a><a href="../?id=29358&amp;page=15">&raquo;</a></form>  </div>
 </body>
</html>