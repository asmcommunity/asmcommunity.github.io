<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Homer's GameDev Blog - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29358" />
    <link rel="next" href="../?id=29358&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29358">Homer's GameDev Blog</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29358&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29358&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29358" /><input type="number" name="page" min="1" max="15" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29358&amp;page=2">&gt;</a><a href="../?id=29358&amp;page=15">&raquo;</a></form>   <div class="post" id="post-207301">
    <div class="subject"><a href="#post-207301">Homer's GameDev Blog</a></div>
    <div class="body">Hey, feel free to express your opinions / questions etc anytime :)<br /><br />This thread will log changes I make to GameDev-related OA32 objects, and it will detail my progress as I work toward building a 3D game engine, interspersed with random gamedev-related musings, and some occasional code.<br /><br />If this thread receives enough attention, I will Pin it to the top of the list (like I did for the Physics thread).<br />However, I will be suprised if that is the case, because I&#039;m not catering to any particular audience here.<br /><br />A while ago I wrote the beginnings of a 2D/3D Audio Engine, and subsequently let it gather dust.<br />It&#039;s a shame because it supports static WAV, streamed WAV and streamed MP3 to be played back to either a 2D or a 3D Listener, as well as supporting &#039;3D Audio Environments&#039;.<br /><br />Today I dusted off my 2D/3D Audio Support code, gave it a polish, and built OPTIONAL support into the D3D_Camera class... if you don&#039;t include my Audio Support *before* D3D_Camera, you get regular D3D_Camera... but if you DO include Audio Support before D3D_Camera, you get a D3D_Camera which contains a new Init_Audio method that creates a &#039;3D Listener&#039; which is automatically updated whenever the Camera View changes.. essentially, we&#039;re giving the camera &#039;ears&#039; so that our speakers will play whatever 3D sounds the Camera hears.<br />Unfortunately, there is a default D3D_Camera object embedded deeply within OA32&#039;s D3D App framework, so the Audio support code might need to become non-optional, and a little care taken to not break compatibility...<br /><br />Audio support was also extended to the D3D_SkinMesh class, which is now able to set up callback events within animation tracks, so we can do things like play footstep sounds that are synchronized to the animation, or make a swooshing noise when a model swings a weapon.<br />In order to insert callback event keys into an animation track (as opposed to into a channel of the animationcontroller / mixer), we need to modify the animation track.. I take this opportunity to Compress the animation track, and to convert it to use Quaternion Keys.<br /><br />I&#039;m yet to extend Audio support to my Physics objects, but that&#039;s a natural step to take next.<br />Also, I plan to implement an object to manage Sequences of Animations for SkinMesh.<br />This would be in the form of an ordered Queue of instructions for the AnimationController (mixer).<br />During development, it would be very nice to use Biterider&#039;s new ScriptingHost to allow for external runtime manipulation of animation sequences.<br /><br /><br /><br />I&#039;ve been spending a lot of time looking at various Game AI implementations (especially Monolith&#039;s F.E.A.R), as well as experimenting with my Neural Network code.<br /><br />Also, I&#039;ve been thinking a lot about how the World will be represented within the Game engine.<br />In the end, there will be a network of Cell nodes with Portals linking them together... ie, a &quot;Cell and Portal&quot; engine ... but not necessarily using Portal Rendering as it is commonly known.<br />So far, I am leaning toward doing the following:<br />-import World as triangle soup<br />-generate BSP Tree (Quake style: empty nodes, convex clusters of triangles at the leaves)<br />-generate Portals between Leaf nodes<br />-generate Cell Network from Leafs and Portals<br />-write Cell Network out to a custom file<br /><br />We don&#039;t need the BSP tree anymore... we can keep it, or not.<br />We&#039;re perfectly able to calculate PVS , either at runtime or as a preprocess, using only our Cell Network.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2009-04-12 10:21:27 by Homer</div>
   </div>
   <div class="post" id="post-207303">
    <div class="subject"><a href="#post-207303">Re: Homer's GameDev Blog</a></div>
    <div class="body">How about a NavMesh? <br />http://www.ultranos.com/OpenIL/src/ILX/ILXNavMesh.cpp<br />http://www.ultranos.com/OpenIL/ILX.h<br />The A* search and other AI-supporting funcs are not implemented or defined there yet, but it&#039;s usable for character navigation so far. I&#039;m still a noob at these things, and am implementing only stuff I currently need, so I may be off-base with this NavMesh ^^&#039;. <br />Fortunately, I&#039;ve confirmed it&#039;s extremely easy to draw, use, expand. I.e even if it&#039;s squashed in 2D, it can describe a 50-floor skyscraper&#039;s paths and pass on a rough Z value for further refinement to the bumpy detailed meshes of the level. And an artist can make the geometry for that skyscraper in under 5 minutes. Controlled input is better than manually filtering heaps of procedurally-generated output. <br />With a flag on edges, we can specify if they are see-through or walls - to compute visibility input for the AI. All simplified to 2D, with possibly only a few side-effects. Though, I don&#039;t like thinking in terms of first-person-shooters. </div>
    <div class="meta">Posted on 2009-04-12 17:01:42 by Ultrano</div>
   </div>
   <div class="post" id="post-207309">
    <div class="subject"><a href="#post-207309">Re: Homer's GameDev Blog</a></div>
    <div class="body">Well, theres nothing wrong with using a NavMesh, but someone has to generate it, and it represents a whole bunch of extra geometry.... for essentially 2D maps like heightmapped terrains, using influence maps is a better option.<br />If we choose NavMeshes, it would be better to automate the generating process, and take the responsibility away from the 3D artists, leaving them to concentrate on what they do best.<br />I&#039;ve noticed that some games had begun to implement &quot;NavMesh Generators&quot; which work by identifying chunks of &quot;walkable&quot; triangles and attempting to string them together, and using a heuristic to discard &#039;unwanted islands&#039;.<br /><br />Anyhow, I was more referring to the &#039;macro&#039; level of World representation.<br /><br />One common scheme for AI pathfinding is the use of &quot;waypoints&quot;...<br />I drew a parallel to Nathan Whitaker&#039;s &quot;Extracting Connectivity Information from a BSP Tree&quot;.<br />Nathan understands that the leafnodes in a BSP tree represent convex subsets of triangles defining convex subspaces (Cells), and his algorithm can be used to discover the shape of the Portals which connect these subspaces... these are the &#039;holes&#039; through which entities may travel between Cells.<br />Having extracted a list of Cells and their connecting Portals, it&#039;s easy to see how this information can be built into a NODE NETWORK - a closed tree - at this point, the BSP tree can be discarded, since hardware occlusion culling is faster than walking the (possibly huge) bsp tree these days... and we can rely on portal based culling if we&#039;re that concerned.<br />My concept is to grant each Node a &#039;score&#039; based on its contents, and apply A* (maybe Coordinated A*) pathfinding to this Network in order to direct NEEDS based AI to appropriate GOAL CELLS.<br /><br />It&#039;s important to recognize that not all the Cells we generate will actually be reachable for ground-dwelling AI.<br />I don&#039;t believe I would have any difficulty in QUICKLY extracting a NavMesh for each Cell based on the limited set of Triangles within each Cell, and which Edges touch which Portals at the floor level.<br /><br />But I don&#039;t expect my AI to always be confined to the floor.<br /><br /></div>
    <div class="meta">Posted on 2009-04-13 02:09:38 by Homer</div>
   </div>
   <div class="post" id="post-207310">
    <div class="subject"><a href="#post-207310">Re: Homer's GameDev Blog</a></div>
    <div class="body">I feel that auto-generated navigation is bad, as the published implementations I&#039;ve seen are horrifying. I.e in HL2/CSS:<br />http://developer.valvesoftware.com/wiki/Bot_Navigation_for_Counter-Strike:Source<br />Ingame, viewing and editing of these &quot;nav-meshes&quot; can be enabled, to see how awfully unoptimal results become. At least in HL2/CSS, that is. Tiny arbitrarily-rotated and scaled quads with 0-256 adjacent nodes and a bunch of controlling flags. A small map: 2MB+ of compressed navigation data, while I think it could be done with several orders less nodes. The thing is, that thanks to this imperfect autogeneration, the graph fed to A* is too loaded probably and effectively one can&#039;t put many smart bots even on a gamer&#039;s highest-end PC. </div>
    <div class="meta">Posted on 2009-04-13 03:32:49 by Ultrano</div>
   </div>
   <div class="post" id="post-207311">
    <div class="subject"><a href="#post-207311">Re: Homer's GameDev Blog</a></div>
    <div class="body">When I think of a NavMesh, I am reminded of the Neighbouring Triangles data available in a .X model ....<br />I believe that I can build the NavMesh directly into the World mesh, by simply discovering and tagging the walkable triangles, thus forming a finite Tree of triangles and their edge connections.<br /></div>
    <div class="meta">Posted on 2009-04-13 07:20:16 by Homer</div>
   </div>
   <div class="post" id="post-207320">
    <div class="subject"><a href="#post-207320">Re: Homer's GameDev Blog</a></div>
    <div class="body">Fixed a bug in StreamingMP3Sound class.<br />Released my Audio.inc file to Biterider for inclusion in the next OA32 update.<br />Implemented a simple Console for taking text input at runtime.<br />Annoyed with a bug that causes rendering to cease when app window is resized.<br />Studying for implementing game AI with classic multilayered feedforward back-propagating Neural Networks.<br /></div>
    <div class="meta">Posted on 2009-04-14 21:43:09 by Homer</div>
   </div>
   <div class="post" id="post-207322">
    <div class="subject"><a href="#post-207322">Neuro-Evolution for unsupervised machine learning</a></div>
    <div class="body">I&#039;ve been studying something called &#039;Neuro-Evolution&#039;.<br /><br />You create a population of NeuralNetwork-driven AI critters.<br />Learning is achieved, however it is not achieved through the usual Training (back-propagation) method.<br />After some time, you cull the herd, crossing and mutating the &#039;genes&#039; of the fittest survivors.<br />These &#039;genes&#039; are in fact the Weights arrays inside the Neural Network of each critter.<br /><br />This scheme allows us to implement &#039;negative reinforcement&#039; since we have total control over the definition of &#039;fittest survivors&#039;.<br /><br />It&#039;s certainly food for thought :P<br /><br /></div>
    <div class="meta">Posted on 2009-04-15 07:43:52 by Homer</div>
   </div>
   <div class="post" id="post-207323">
    <div class="subject"><a href="#post-207323">Re: Homer's GameDev Blog</a></div>
    <div class="body">A friend of mine recently played with a solution like that for the Traveling Salesman Problem.<br />The idea was that a more efficient path could evolve from previous paths. So you start by randomly generating a set of paths.<br />Then for each path you randomly change part of the path, this is the evolutionary step. You then take the shortest X paths (the &#039;fittest survivors&#039;), and do more evolution. This should eventually converge/evolve into a reasonbly optimal solution.<br />An interesting aspect is that evolution is a parallel process.</div>
    <div class="meta">Posted on 2009-04-15 09:23:04 by Scali</div>
   </div>
   <div class="post" id="post-207347">
    <div class="subject"><a href="#post-207347">Re: Homer's GameDev Blog</a></div>
    <div class="body">I thought a few people might be interested to see example code for a simple neural AI, so I&#039;ve attached some files.<br />This example implements a population of AI critters which evolve the behavior &quot;seek food&quot;.<br /><br />NNet.inc contains the code for a Neural Network class.<br />RNG.inc contains the code for my Random Number Generator.<br />Genetic AI Controller.inc contains the example code, which is comprised of several classes:<br /><br />-AIBaseObject (simply describes a Vec3 position)<br />-Plant (derived from AIBaseObject, represents food for our critters)<br />-AICreature (derived from AIBaseObject, represents an instance of an AI critter)<br />-GAIController (drives the simulation)<br /><br />The AICreature class embeds a NNet object (its &quot;brain&quot;). Inside the NNet is an array of weights. The GAIController class drives a population of AI critters for one lifespan, then applies a genetic algorithm to produce a new (hopefully improved) generation by screwing with the weights of the current population.<br /><br />If we look closely at the GAIController.Epoch method, we can see that the algorithm works as follows...<br />ELITISM : create some new critters whose weights are directly cloned from the NNets of the N fittest members of the current population.<br />CROSSOVER : create some pairs of new critters whose weights are substrings cloned from the NNets of pairs of reasonably fit members of the current population.<br />MUTATION : deform the weights of the new critters that result from crossover.<br /><br />Each AICreature has a very simple neural network, with four REAL8 inputs (as 2 x Vec2), and two REAL8 outputs.<br />We apply two inputs to the NNet: a vector from the critter to its closest food, and a vector representing the direction it is currently looking. Then we run the NNet and grab its two outputs.<br />The two outputs are used to imply left and right turning forces.<br />We use these to calculate change in the critter&#039;s rotation, speed and position.<br />GAIController drives the critters, and watches for collisions between critters and food.<br /><br />It&#039;s important to note that we don&#039;t tell the critter which way to turn, or that food is good !!!<br />If a critter hits some food, we increment its &#039;fitness&#039; score.<br />The genetic algorithm breeds new generations which tend strongly toward the traits of the fittest critters of the previous generations, thus the system favors critters which turn in the direction of the food, rather than away from it... critters whose behaviors don&#039;t result in them running into some food will soon find their &#039;genes&#039; culled from the gene pool.<br /><br />It takes quite a few generations to evolve &#039;apparently intelligent&#039; behavior.... no less than 200.<br />After some 2000 generations, these guys will become incredibly efficient food gatherers, aiming and moving with apparent purpose.<br /><br /><br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2756" target="_blank">NNet.inc</a></li>
      <li><a href="../../attachments/?id=2757" target="_blank">Genetic AI Controller.inc</a></li>
      <li><a href="../../attachments/?id=2758" target="_blank">RNG.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-04-18 23:50:00 by Homer</div>
   </div>
   <div class="post" id="post-207348">
    <div class="subject"><a href="#post-207348">Re: Homer's GameDev Blog</a></div>
    <div class="body">It occurs to me that, at least in this example case, we can help these guys learn even faster, by using classic back-propagation at the appropriate moment...<br /><br />We can find the signed angle between two vectors using a dot product.<br />In our case, we want to turn left if the sign is positive, and right if the sign is negative.<br /><br />When we check the outputs of the neural net, we can determine whether the nnet is telling the critter to turn in the correct direction or not, and if not, we can call the AICreature.Brain.train method to tell it exactly what its outputs SHOULD have been, in a loop, until it produces ACCEPTABLE output, then continue.<br /><br /></div>
    <div class="meta">Posted on 2009-04-19 00:20:46 by Homer</div>
   </div>
   <div class="post" id="post-207363">
    <div class="subject"><a href="#post-207363">Re: Homer's GameDev Blog</a></div>
    <div class="body">I think its FAIR to apply classic back-propagation (training) to help evolve ai expert systems that are receiving environmental input and being genetically evolved on their response to it.<br />After all, it&#039;s quite natural for an inexperienced human to overshoot their goal and perform corrections, particularly when synchronizing some action with their vision system.<br /></div>
    <div class="meta">Posted on 2009-04-21 02:58:56 by Homer</div>
   </div>
   <div class="post" id="post-207367">
    <div class="subject"><a href="#post-207367">Re: Homer's GameDev Blog</a></div>
    <div class="body">Added new method: D3D_Camera.GetPickRay calculates a ray extending from cameraspace (the screen) into the 3D world. The ray can be returned either in WorldSpace or in some BodySpace, which allows us to deal with arbitrarily oriented entities.<br />Example uses for this method are Selecting of 3D entites via the mouse cursor, and testing whether a player is aiming his line-of-sight weapon at an appropriate target.<br />In one demo, I used it to allow the user to &#039;paint&#039; a blended texture onto a 3D terrain, by performing triangle/ray intersection tests, calculating the exact point of intersection on a triangle, and thus finding the Texel Coordinates at that point on the triangle.<br /></div>
    <div class="meta">Posted on 2009-04-21 11:32:06 by Homer</div>
   </div>
   <div class="post" id="post-207373">
    <div class="subject"><a href="#post-207373">Re: Homer's GameDev Blog</a></div>
    <div class="body">The physics framework has been a great exploration into computational geometry.<br />I am beginning to put together a &quot;Geometry Toolkit&quot; includefile containing all kinds of geometry-related functions such as intersection, geometric clipping, splitting and merging functions, eventually supporting all combinations of the typical geometric primitives.<br />This file will be donated to the ObjAsm32 package at some near point in the future, but you&#039;ll find a preview available here in this Thread within the next week or so.<br /><br /></div>
    <div class="meta">Posted on 2009-04-23 01:20:16 by Homer</div>
   </div>
   <div class="post" id="post-207390">
    <div class="subject"><a href="#post-207390">Re: Homer's GameDev Blog</a></div>
    <div class="body"><br />Implemented &#039;mouse pick ray&#039; selection of mesh instances (D3D_MeshManaged objects).<br />Extended D3D_Mesh baseclass to support transparent materials. Also tried (without success) to have D3D_Mesh.LoadFromXFile detect when a mesh has no Vertex Normals and clone a mesh that does (for lighting purposes).<br /><br />Biterider has taken a scalpel to the D3D_Window ancestor class in order to remove the embedded D3D_Camera object, and moved the camera audio code into a derived camera class.<br /><br />My immediate goals will be to implement some runtime tools for manipulating selected mesh instances, and to re-implement my xfile-to-bsp code with a view to extracting cell-and-portal connectivity information from the compiled bsp tree.<br /><br /></div>
    <div class="meta">Posted on 2009-04-25 22:51:29 by Homer</div>
   </div>
   <div class="post" id="post-207404">
    <div class="subject"><a href="#post-207404">D3D_SpriteManager</a></div>
    <div class="body">Wrote a manager class to draw rectangular portions of textures to the screen (via ID3DXSprite). It supports alphablending, of course, and should be a big help for creating HUDs and other &#039;flat&#039; onscreen displays, you know, the &#039;game stuff&#039; that is drawn &#039;on top&#039; of the Scene.<br />If you wanted to create a fancy-looking control, you simply need to add (and thus draw) its components in the appropriate order: first a &#039;mask&#039;, then the control border, then the control content.... all these can be sourced from a single texture :)<br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2009-04-28 04:39:40 by Homer</div>
   </div>
   <div class="post" id="post-207425">
    <div class="subject"><a href="#post-207425">Re: Homer's GameDev Blog</a></div>
    <div class="body">Extended D3D_TextureManager to properly support color key transparency - especially the &#039;Restore&#039; method. This is a very minor work but does affect the D3D_Mesh class.<br /><br />Implemented the &#039;Screen Sprites&#039; class I mentioned in the previous post - works like a charm, really good with 24bit colorkey images, if you use 32nit (w/alpha) images then the colorkey is ignored and you get per-pixel alpha instead. Very nice for making onscreen display.<br /></div>
    <div class="meta">Posted on 2009-04-30 18:52:36 by Homer</div>
   </div>
   <div class="post" id="post-207439">
    <div class="subject"><a href="#post-207439">Re: Homer's GameDev Blog</a></div>
    <div class="body">I&#039;ve asked my girlfriend to try to put together a nice artistic gamedisplay texture for me to toss at the new SpriteManager. She&#039;s talented, I&#039;m not.... at least not where art is involved.<br /><br />Starting rewriting BSPGen, started extending console for grammar, I&#039;d like to be able to issue runtime commands to create and manipulate entities via console, instead of hardcoding everything.<br />Immediate goal is to hook up enough console commands to load,save and very basically edit a &quot;game level&quot; (3d worldscape), I&#039;ll probably end up going console crazy and extending advanced features to the console. Being able to load, save and edit a &quot;world&quot; will be a milestone in itself.<br /><br />Funny, this is all code I implemented years ago.<br />But I wasn&#039;t working in an object-oriented source environment.<br /><br />Looking forward to making quick progress so I can play more with AI.<br /><br /><br /></div>
    <div class="meta">Posted on 2009-05-01 08:28:24 by Homer</div>
   </div>
   <div class="post" id="post-207444">
    <div class="subject"><a href="#post-207444">Re: Homer's GameDev Blog</a></div>
    <div class="body">Consider using the new ScriptHost. It is much more flexible than a simple command line. You can loop, take logical decisions, load, save, position your meshes, etc, etc.<br /><br />Biterider<br /></div>
    <div class="meta">Posted on 2009-05-01 14:43:41 by Biterider</div>
   </div>
   <div class="post" id="post-207447">
    <div class="subject"><a href="#post-207447">Re: Homer's GameDev Blog</a></div>
    <div class="body">I sure plan on playing with ScriptHost very soon in that regard, thanks.<br />I&#039;ve stopped working on the console - at least I can use it to issue named scripts :P<br /><br />Working on a revised BSPGen.<br />Having a few problems that seem to be caused by/in the DbgVec3 macro!<br /></div>
    <div class="meta">Posted on 2009-05-02 02:50:21 by Homer</div>
   </div>
   <div class="post" id="post-207500">
    <div class="subject"><a href="#post-207500">Re: Homer's GameDev Blog</a></div>
    <div class="body">Wrote dedicated code to generate a &#039;Quake-Style&#039; BSP Tree from an input 3D model (splitting-planes at the Nodes, triangles at the Leaves).<br /><br />Portals are the &#039;holes&#039; in the world which join one place to another, doorways are a good example.<br />The BSP Tree generator has discovered all the &#039;rooms&#039; in the 3D model, now I am trying to discover the Portals which connect those &#039;rooms&#039; together.<br /><br />Wrote code to generate a large number of &#039;portal fragments&#039; from the splitting-planes of the Tree, walk them through the tree until each arrives at a leaf node, and to filter the resulting lists of fragments for obvious fakes (portal fragments must exist in two Leaf nodes, otherwise they are junk).<br />All that remains of Portal Discovery is to trim the remaining fragments against the faces in the two Leaf nodes which are connected by a given portal (... a portal touches two leaves, clip it against their geometry).<br /><br />Once I&#039;ve built a list of Portals and mapped which Leaf nodes they connect, I can theoretically discard all of the nodes in the Tree except for the Leaves... I can build a Cell and Portal Network from the Portal/Leaf mappings.<br /><br />(I don&#039;t intend to use the BSP tree for visibility or rendering, just to construct my Cell &#039;n&#039; Portal graph).<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2009-05-06 07:52:16 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29358&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29358&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29358" /><input type="number" name="page" min="1" max="15" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29358&amp;page=2">&gt;</a><a href="../?id=29358&amp;page=15">&raquo;</a></form>  </div>
 </body>
</html>