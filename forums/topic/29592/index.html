<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>AT&amp;T Syntax Problem - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29592" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29592">AT&amp;T Syntax Problem</a></p>
   <div class="post" id="post-208996">
    <div class="subject"><a href="#post-208996">AT&amp;T Syntax Problem</a></div>
    <div class="body">Hello gurus:<br /><br />I have been playing with AT&amp;T syntax for a bit, trying to make a bootloader. The only problem is that when I test it out, it doesn&#039;t appear to be bootable.&nbsp; I figured that it was the syntax, but when I checked it again, GAS didn&#039;t complain, and the syntax looked alright.&nbsp; The problem is, the file output file is HUGE.&nbsp; I don&#039;t know what is causing this (probably a n00b mistake), but here is the code:<br /><br /><br />/*XIX System 19 Bootsector - Version 1.00*/<br />/**/<br />/*The Purpose of this bootsector is to load the second stage of the XIX Bootloader*/<br />/*into memory.*/<br />/**/<br />/*This is the case, in order to circumvent the now-restricting 512 (actuall ~440)*/<br />/*byte limit of the MBR, and to allow future implementations of error handling,*/<br />/*error logging, hardware diagnostics/portability, and multi-boot support.*/<br />/**/<br />/*For ful documentation, read the source-enclosed bootsector.img.doc file*/<br /><br />.code16		#tell the assembler that this code is in 16-bit real mode<br />.org 0x7C00	#tell the assembler that this code will be in 0x7C00 in memory<br /><br />begin:<br />	jmp boot	#jump over the data section into the code<br /><br /><br />/*Section for Functions*/<br />prntstr:<br />	movb $0x0E, %ah		#tell int 0x10 that we want to print a character<br /><br />	movb $0x00, %bh		#tell int 0x10 to print on first page<br />	movb $0x000A, %bl	#tell int 0x10 to print in Green Text, Black Background, non-flashing<br /><br />	prntstr.nxtchar:	#label to jump to in AL is not equal to &#039;null&#039;<br />	lodsb			#will load string in SI into AL for printing<br /><br />	or %al, %al		#will check for &#039;null&#039; character<br />	jz prntstr.rtrn		#if zero flag is set, will jump to .return<br /><br />	int $0x10		#call int 0x10 to print the string on-screen<br />	jmp prntstr.nxtchar	#jump to .nxtchar if job not done<br /><br />	prntstr.rtrn:		#label to jump to if &#039;null&#039; character detected<br />ret				#return to main program<br /><br />readsk:<br />	readsk.rst:		#label for the reset portion of the function, to reset the floppy drive<br />	movb $0x00, %ah		#indicate that the drive is to be reset<br />	movb $0x00, %dl		#the drive to be reset is a floppy<br /><br />	int $0x13		#call int 0x13 to reset floppy<br />	jc readks.rst		#jump if carry flag is reset (if the reset failed)<br /><br />	movw $0x7E00, %ax	#the position that the second-stage will be loaded into memory at<br />	movw %ax, %es		#load memory position into ES<br />	xor %bx, %bx		#clear BX (which indicates offset to int 0x13 (we don&#039;t want any))<br /><br />	readsk.read:		#label for the reading portion of the function<br />	movb $0x02, %ah		#indicate that the drive is to be read<br />	movb $0x01, %al		#read 1 sector<br />	movb $0x01, %ch		#track 1<br />	movb $0x02, %cl		#sector 2<br />	movb $0x00, %dh		#head 0 (first head)<br />	movb $0x00, %dl		#the drive to be read from is a floppy<br /><br />	int $0x13		#call int 0x13 to read from floppy<br />	jc readks.read		#try to read again if error occurs (if carry flag is 1)<br />ret<br /><br /><br />/*Section for Strings*/<br />sysmess: .asciz &quot;XIX System 19 Bootsector - Version 1.00 \n \n Will Now load the Bootloader&quot;	#system information string (\n is newline)<br /><br /><br />/*Main Programm*/<br />boot:<br />	movw $sysmess, %ax		#load the string to be printed into AX register and then load into SI<br />	movw %ax, %si			#we need to do this because it cannot be done directly<br />	call prntstr			#call the printing function<br /><br />	#call readsk			#call the disk reading function<br /><br />	#jmp $0x7C00:$0x0200		#jump to instruction residing in 0x7E00<br /><br />	cli				#REMOVE AFTER TEST<br />	hlt				#REMOVE AFTER TEST<br /><br /><br />/*Bootloader Code*/<br />.org 0x7DFE			#move to 0x7C00:0x1FE<br />.word 0xAA55			#append the bootsector signature<br /><br /><br />I am in need of this simple code, and would really appreciate help.</div>
    <div class="meta">Posted on 2009-10-01 21:22:06 by XeonX369</div>
   </div>
   <div class="post" id="post-208999">
    <div class="subject"><a href="#post-208999">Re: AT&amp;T Syntax Problem</a></div>
    <div class="body">bump</div>
    <div class="meta">Posted on 2009-10-02 09:23:58 by XeonX369</div>
   </div>
   <div class="post" id="post-209002">
    <div class="subject"><a href="#post-209002">Re: AT&amp;T Syntax Problem</a></div>
    <div class="body">how did you assemble this?</div>
    <div class="meta">Posted on 2009-10-02 12:43:28 by lone_samurai5</div>
   </div>
   <div class="post" id="post-209020">
    <div class="subject"><a href="#post-209020">Re: AT&amp;T Syntax Problem</a></div>
    <div class="body">I assembled this like so:<br /><br />as  -o <br /><br />just as simple as that, with the braces being replaced with filenames, ofcourse</div>
    <div class="meta">Posted on 2009-10-05 09:22:41 by XeonX369</div>
   </div>
   <div class="post" id="post-209022">
    <div class="subject"><a href="#post-209022">Re: AT&amp;T Syntax Problem</a></div>
    <div class="body">its probably outputting to elf format.. try making a flat binary..</div>
    <div class="meta">Posted on 2009-10-05 21:47:45 by lone_samurai5</div>
   </div>
   <div class="post" id="post-210190">
    <div class="subject"><a href="#post-210190">Re: AT&amp;T Syntax Problem</a></div>
    <div class="body">Sorry for the extended absence, I had temporarily &#039;given-up&#039; this small portion of my project.&nbsp; I feel need to revisit it, as I am re-writing my bootsector.&nbsp; Truth be told,&nbsp; I cannot find any information on the web or in the GNU AS manual about outputting to Flat Binary format.</div>
    <div class="meta">Posted on 2010-01-07 09:30:14 by XeonX369</div>
   </div>
   <div class="post" id="post-210195">
    <div class="subject"><a href="#post-210195">Re: AT&amp;T Syntax Problem</a></div>
    <div class="body">I thought the trick was &quot;as -o myboot.o myboot.S&quot;/&quot;ld -o myboot.bin --oformat binary myboot.o&quot;. However (after fixing some typos in your code that prevented it from assembling at all), I get a message from ld about &quot;relocation truncated to 16-bit&quot; - as it should be (I think) - and no output at all! No idea what the problem is.<br /><br />I wouldn&#039;t want to influence your choice of assembler (much), but this is a whole lot easier with Nasm. :)<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-01-07 22:35:16 by fbkotler</div>
   </div>
   <div class="post" id="post-210200">
    <div class="subject"><a href="#post-210200">Re: AT&amp;T Syntax Problem</a></div>
    <div class="body">Yes, I am beginning to believe that NASM is indeed better than GAS AT&amp;T syntax.&nbsp; To me, this whole GAS idea was a product of me wanting to &#039;code in a distinct syntax,&#039; an opinion which I now rebuke as I see indeed than NASM is close to (if not THE) Intel Syntax defined in the Intel Manuals.&nbsp; I would rather code in Intel Syntax for an Intel processor, and have access to the wide variety of documents and tutorials utilizing Intel Syntax, instead of having to &#039;translate&#039; to GAS AT&amp;T.<br /><br />Thank you for your detail about what commands you used;&nbsp; I too cannot get this to work.&nbsp; In short, I am sticking with NASM.<br /><br />Thank&#039;s once again for your opinion and all help.&nbsp; Happy Coding.</div>
    <div class="meta">Posted on 2010-01-08 09:36:57 by XeonX369</div>
   </div>
   <div class="post" id="post-210201">
    <div class="subject"><a href="#post-210201">Re: AT&amp;T Syntax Problem</a></div>
    <div class="body"><div class="quote"><br />To me, this whole GAS idea was a product of me wanting to &#039;code in a distinct syntax,&#039; an opinion which I now rebuke as I see indeed than NASM is close to (if not THE) Intel Syntax defined in the Intel Manuals.<br /></div><br /><br />The problem is that GAS is meant to be a back-end to GCC and wasn&#039;t really designed to be used outside of that toolchain. You can attempt to use it in unintended ways, and it may work at times, but don&#039;t be surprised when it fails to produce expected or desirable results.<br /><br />NASM was developed to resemble more like MASM/TASM (Intel) than GAS (AT&amp;T), obviously, but more with instruction unambiguity in mind. Short of defines/macros, you should be able to take a line of NASM compatible code and tell precisely what it going on.<br /><br />If you still want to use AT&amp;T syntax, but perhaps use an assembler that is more like NASM, then take a look at YASM. I can&#039;t vouch for how well YASM supports AT&amp;T syntax, but it might fit your needs.</div>
    <div class="meta">Posted on 2010-01-08 11:06:01 by SpooK</div>
   </div>
   <div class="post" id="post-210204">
    <div class="subject"><a href="#post-210204">Re: AT&amp;T Syntax Problem</a></div>
    <div class="body">Yeah, Gas was originally 32-bit only. Early versions of Linux used &quot;as86&quot; and &quot;ld86&quot; for the bootsector (and other 16-bit? if any?). The 16-bit capability of Gas is an &quot;extension&quot;. Gas also got the &quot;.intel_syntax&quot; directive - which wasn&#039;t for gcc&#039;s convenience, so the binutils guys are thinking at least a little about human users.<br /><br />But this isn&#039;t really a &quot;syntax&quot; issue, it&#039;s a &quot;command line&quot; issue. We just don&#039;t know how to do it in Gas. Nasm was designed to output multiple formats, including flat binary - we even do as86-style objects for ld86! Rod Pemberton posted this link the other day:<br /><br />http://www.ludd.luth.se/~ams/gnu_dos_com/<br /><br />It&#039;s about .com files, but might be useful. Speaks about &quot;linker script&quot; files needed to make it work. Perhaps that&#039;s the answer...<br /><br />I observed, by disassembling the large .o file that (G)as produces, that it has exactly the code we want, needing no further work from ld. There&#039;s just a lot of stuff before and after. Unix utilities &quot;head&quot; and &quot;tail&quot; to the rescue!<br /><br /><pre><code><br /><br /><br />/*XIX System 19 Bootsector - Version 1.00*/<br />/**/<br />/*The Purpose of this bootsector is to load the second stage of the XIX Bootloader*/<br />/*into memory.*/<br />/**/<br />/*This is the case, in order to circumvent the now-restricting 512 (actuall ~440)*/<br />/*byte limit of the MBR, and to allow future implementations of error handling,*/<br />/*error logging, hardware diagnostics/portability, and multi-boot support.*/<br />/**/<br />/*For ful documentation, read the source-enclosed bootsector.img.doc file*/<br /><br /><br /># as -o myboot.o myboot.S<br /># tail --bytes=1208 myboot.o&gt;myboot.t1<br /># head --bytes=512 myboot.t1&gt;myboot.bin<br /># dd if=myboot.bin of=/dev/fd0<br /><br /><br />.section .text<br />.code16&nbsp; &nbsp; &nbsp; #tell the assembler that this code is in 16-bit real mode<br />.org 0x7C00&nbsp;  #tell the assembler that this code will be in 0x7C00 in memory<br /><br />.globl _start<br /><br />_start:<br />begin:<br />&nbsp;  jmp boot&nbsp;  #jump over the data section into the code<br /><br /><br />/*Section for Functions*/<br />prntstr:<br />&nbsp;  movb $0x0E, %ah&nbsp; &nbsp; &nbsp; #tell int 0x10 that we want to print a character<br /><br />&nbsp;  movb $0x00, %bh&nbsp; &nbsp; &nbsp; #tell int 0x10 to print on first page<br />&nbsp;  movb $0x000A, %bl&nbsp;  #tell int 0x10 to print in Green Text, Black Background, non-flashing<br /><br />&nbsp;  prntstr.nxtchar:&nbsp;  #label to jump to in AL is not equal to &#039;null&#039;<br />&nbsp;  lodsb&nbsp; &nbsp; &nbsp; &nbsp;  #will load string in SI into AL for printing<br /><br />&nbsp;  or %al, %al&nbsp; &nbsp; &nbsp; #will check for &#039;null&#039; character<br />&nbsp;  jz prntstr.rtrn&nbsp; &nbsp; &nbsp; #if zero flag is set, will jump to .return<br /><br />&nbsp;  int $0x10&nbsp; &nbsp; &nbsp; #call int 0x10 to print the string on-screen<br />&nbsp;  jmp prntstr.nxtchar&nbsp;  #jump to .nxtchar if job not done<br /><br />&nbsp;  prntstr.rtrn:&nbsp; &nbsp; &nbsp; #label to jump to if &#039;null&#039; character detected<br />ret&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #return to main program<br /><br />readsk:<br />&nbsp;  readsk.rst:&nbsp; &nbsp; &nbsp; #label for the reset portion of the function, to reset the floppy drive<br />&nbsp;  movb $0x00, %ah&nbsp; &nbsp; &nbsp; #indicate that the drive is to be reset<br />&nbsp;  movb $0x00, %dl&nbsp; &nbsp; &nbsp; #the drive to be reset is a floppy<br /><br />&nbsp;  int $0x13&nbsp; &nbsp; &nbsp; #call int 0x13 to reset floppy<br />&nbsp;  jc readsk.rst&nbsp; &nbsp; &nbsp; #jump if carry flag is reset (if the reset failed)<br /><br />&nbsp;  movw $0x7E00, %ax&nbsp;  #the position that the second-stage will be loaded into memory at<br />&nbsp;  movw %ax, %es&nbsp; &nbsp; &nbsp; #load memory position into ES<br />&nbsp;  xor %bx, %bx&nbsp; &nbsp; &nbsp; #clear BX (which indicates offset to int 0x13 (we don&#039;t want any))<br /><br />&nbsp;  readsk.read:&nbsp; &nbsp; &nbsp; #label for the reading portion of the function<br />&nbsp;  movb $0x02, %ah&nbsp; &nbsp; &nbsp; #indicate that the drive is to be read<br />&nbsp;  movb $0x01, %al&nbsp; &nbsp; &nbsp; #read 1 sector<br />&nbsp;  movb $0x01, %ch&nbsp; &nbsp; &nbsp; #track 1<br />&nbsp;  movb $0x02, %cl&nbsp; &nbsp; &nbsp; #sector 2<br />&nbsp;  movb $0x00, %dh&nbsp; &nbsp; &nbsp; #head 0 (first head)<br />&nbsp;  movb $0x00, %dl&nbsp; &nbsp; &nbsp; #the drive to be read from is a floppy<br /><br />&nbsp;  int $0x13&nbsp; &nbsp; &nbsp; #call int 0x13 to read from floppy<br />&nbsp;  jc readsk.read&nbsp; &nbsp; &nbsp; #try to read again if error occurs (if carry flag is 1)<br />ret<br /><br /><br />/*Section for Strings*/<br />sysmess: .asciz &quot;XIX System 19 Bootsector - Version 1.00 \n \n Will Now load the Bootloader&quot;&nbsp;  #system information string (\n is newline)<br /><br /><br />/*Main Programm*/<br />boot:<br /># set %ds to where we are - bios may not have done this!<br />&nbsp;  movw $0, %ax<br />&nbsp;  movw %ax, %ds<br /><br />#&nbsp;  movw $sysmess, %ax&nbsp; &nbsp; &nbsp; #load the string to be printed into AX register and then load into SI<br />#&nbsp;  movw %ax, %si&nbsp; &nbsp; &nbsp; &nbsp;  #we need to do this because it cannot be done directly<br /># yes, it can...<br />&nbsp;  movw $sysmess, %si<br /><br />&nbsp;  call prntstr&nbsp; &nbsp; &nbsp; &nbsp;  #call the printing function<br /><br />&nbsp;  #call readsk&nbsp; &nbsp; &nbsp; &nbsp;  #call the disk reading function<br /><br />&nbsp;  #jmp $0x7C00:$0x0200&nbsp; &nbsp; &nbsp; #jump to instruction residing in 0x7E00<br />#wrong! $0x07C0:$0x0200 (or 0x0:0x7E00)<br /><br />&nbsp;  cli&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #REMOVE AFTER TEST<br />&nbsp;  hlt&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #REMOVE AFTER TEST<br /><br /><br />/*Bootloader Code*/<br />.org 0x7DFE&nbsp; &nbsp; &nbsp; &nbsp;  #move to 0x7C00:0x1FE<br /># comment is wrong.<br /><br />.word 0xAA55&nbsp; &nbsp; &nbsp; &nbsp;  #append the bootsector signature<br /><br /></code></pre><br /><br />This &quot;works for me&quot;. The only &quot;important&quot; change I made was to explicitly load ds with zero. Without that, it&#039;ll work on some machines - if the bios leaves zero in ds, which is fairly common... but not on other machines, which is not *that* uncommon.<br /><br />There&#039;s gotta be a better way than &quot;head&quot; and &quot;tail&quot;, but... it works...<br /><br />If you want help translating this to Nasmese, just ask. The command &quot;nasm myfile.asm&quot; will produce just &quot;myfile&quot;. You might want &quot;nasm -f bin myboot.asm -o myboot.bin&quot;... or &quot;.img&quot;, whatever...<br /><br />Happy bootin&#039;<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-01-09 05:18:11 by fbkotler</div>
   </div>
   <div class="post" id="post-210205">
    <div class="subject"><a href="#post-210205">Re: AT&amp;T Syntax Problem</a></div>
    <div class="body"><div class="quote"><br />Speaks about &quot;linker script&quot; files needed to make it work. Perhaps that&#039;s the answer...<br /></div><br /><br />Yeah, the general trick in getting GCC/GAS to output a binary lies with the link stage... although that should not be all too surprising. <br /><br />A linker script can be useful for multiple sections, e.g. for a kernel, but when a simple MBR is involved the following should suffice: <br /><br /><pre><code><br />as -o boot.o boot.s <br />ld --oformat binary -static -Ttext 0x7C00 -o boot.bin boot.o <br /></code></pre></div>
    <div class="meta">Posted on 2010-01-09 12:17:55 by SpooK</div>
   </div>
  </div>
 </body>
</html>