<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>aborting a loop - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=936" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=936">aborting a loop</a></p>
   <div class="post" id="post-6078">
    <div class="subject"><a href="#post-6078">aborting a loop</a></div>
    <div class="body">How can I abort a loop just through pressing a button? I'm searching for something like Delphi's &quot;application.processmessages&quot;<br /><br /><br />/Delight</div>
    <div class="meta">Posted on 2001-09-04 07:41:55 by Delight</div>
   </div>
   <div class="post" id="post-6080">
    <div class="subject"><a href="#post-6080">aborting a loop</a></div>
    <div class="body">im not sure what you're trying to do here...<br /><br />1. exit a loop<br />2. break a project (ctrl+break in visual basic)<br />3. &quot;unfreeze&quot; a loop (doevents in visual basic)<br /><br />any of those?</div>
    <div class="meta">Posted on 2001-09-04 08:11:09 by vcv</div>
   </div>
   <div class="post" id="post-6081">
    <div class="subject"><a href="#post-6081">aborting a loop</a></div>
    <div class="body">just check msg.message, and then if it is true, .break<br /><br /><pre><code><br />.while 1<br /> .if msg.message == WM_KEYUP<br />  .break<br /> .endif<br />.endw<br /></code></pre></div>
    <div class="meta">Posted on 2001-09-04 08:12:53 by Kenny</div>
   </div>
   <div class="post" id="post-6085">
    <div class="subject"><a href="#post-6085">aborting a loop</a></div>
    <div class="body">I'm sorry if wasn't clear enough. I'm have a procedure that is drawing some stuff on the screen, and when I click on a button, I would like to abort the loop in the proc. I can't do this now because the whole app is freezed while processing the loop.<br /><br /><br />/Delight</div>
    <div class="meta">Posted on 2001-09-04 08:24:39 by Delight</div>
   </div>
   <div class="post" id="post-6088">
    <div class="subject"><a href="#post-6088">aborting a loop</a></div>
    <div class="body">Delight,<br /><br />To do what you need, you will have to put either the drawing operation or the button to stop it into a seperate thread. What is happening at the moment is that you are using the thread to draw with and it will not respond until its finished.<br /><br />Regards,<br /><br /><a href="mailto:hutch@pbq.com.au">hutch@pbq.com.au</a></div>
    <div class="meta">Posted on 2001-09-04 08:32:14 by hutch--</div>
   </div>
   <div class="post" id="post-6089">
    <div class="subject"><a href="#post-6089">aborting a loop</a></div>
    <div class="body">I hate to say this, but I think your only option is to create a seperate thread for drawing on the screen, this will prevent the whole program from freezing I believe.  As far as stopping when a button is clicked, well.  Create a global variable, when the button is clicked, set it to a certain value, in the loop for drawing on the screen, .BREAK .IF variable==value    something like that (assuming you're using masm).<br /><br /><strong>edit</strong>: hutch beat me to it &gt;:|</div>
    <div class="meta">Posted on 2001-09-04 08:35:29 by vcv</div>
   </div>
   <div class="post" id="post-6092">
    <div class="subject"><a href="#post-6092">aborting a loop</a></div>
    <div class="body">OK. I'll try that.<br /><br />Thanks!<br /><br /><br />/Delight</div>
    <div class="meta">Posted on 2001-09-04 08:40:32 by Delight</div>
   </div>
   <div class="post" id="post-6138">
    <div class="subject"><a href="#post-6138">Well you also can</a></div>
    <div class="body">You can also use PeekMessage and a modifyied message loop to do a background draw operation.<br /><br />this has the advantage that your messages are still processed while you draw and you can stop the draw based on a global flag variable<br /><br />And its easyer to do then Threads ;)<br /><br />Threads can be tricky and slow sometimes ...</div>
    <div class="meta">Posted on 2001-09-04 14:10:58 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-6155">
    <div class="subject"><a href="#post-6155">aborting a loop</a></div>
    <div class="body">Bogdan, redesigning your message loop this way is not always possible,<br />eg if you have some *very* lengty operations you need to perform.<br />Sure, threads can be tricky, but better get a firm grip of them, as<br />they are a very useful tool. And the only way to put multi-processor<br />systems to good use :).<br /><br />Now, it sounds like the problem in question could be solved via<br />modifying the message loop, and it wouldn't be a too bad way to<br />handle it. For longer operations, however, run the &quot;lengthy&quot; task<br />in a separate thread. You can use TerminateThread to abort a thread,<br />but beware that this is pretty brutal, and a &quot;check global variable&quot;<br />approach is desirable, so you can perform any necessary cleanup.</div>
    <div class="meta">Posted on 2001-09-04 15:02:30 by f0dder</div>
   </div>
   <div class="post" id="post-6159">
    <div class="subject"><a href="#post-6159">Well</a></div>
    <div class="body">Modifying a message loop using PeekMessage  can be used for ANY kind of background operations for any length...We used it a lot for our GDI and first 2 DirectX versions of HE with no problem whatsoever... we changed that for reasons of Game Programming and Design and not for technical reasons<br /><br />the only problem is that code is not totally separated from the main thread like in threads, because of this code separation threads look easyer to use for lazy programmers...but they are not...tere is a common missconception betwwen &quot;advanced programmers&quot; that one should use threads with ease...<br /><br />1.Any Thread make your App go 1/2 speed from what it had before unless you put it to sleep<br /><br />2.Threads can generate very nasty and very hard to debug errors<br />Errors that will appear ONLY on some systems and only every 10 days or so<br /><br />3.Threads are fast to need the use of CriticalSections and Mutex and Spemaphores...that logically complicates and bloats your code <br /><br />4. Threads are notoriouse hard to start stop without bugs..<br />(mostly stop)<br /><br />All that and many more just to stop a background operation...get real ;)<br /><br />Bottom line:<br />Use Threads ONLY if you are SURE you NEED THEM BADLY<br /><br />PS. We use threads in HE but ONLY because we need them ;)</div>
    <div class="meta">Posted on 2001-09-04 15:40:37 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-6171">
    <div class="subject"><a href="#post-6171">aborting a loop</a></div>
    <div class="body">Bogdan, let's say you need to load a 200 meg file. How would you<br />do this in the MessageLoop and still be able to process the UI messages?<br />The only way I can think of would end up very very messy.<br /><br />It's not true that creating an extra thread will make your application<br />go half speed. Sure, there's a little extra overhead in the thread/task<br />scheduling, but it's so little you can hardly feel it (you're not doing<br />realtime tasks under windows, are you?). If you have, say, two<br />math intensive threads running at the same time, they might run<br />at &quot;half speed&quot; - but you'd be finished in about the same time as<br />if you run them sequentially. When creating a thread for &quot;heavy-duty<br />processing&quot; and have the MessageLoop in the main thread, the<br />main thread will be asleep most of the time in the GetMessage call.<br />Which is a good reason to use GetMessage instead of PeekMessage -<br />the system can sleep a thread on GetMessage, and thus spare CPU<br />cycles, but it can't do this on PeekMessage.<br /><br />Threads can generate very nasty and hard to debug bugs... but this<br />is not due to the threads, it's due to bad programming. Admitted,<br />it can be very hard to get threads working right when doing more<br />complicated stuff, but the only way around this is experience. So<br />don't try to crawl away from threads :). Use them if they make life<br />easier or can speed up your app. Not for the heck of it. But don't<br />invent &quot;weird schemes&quot; to get away from threads.<br /><br />Yes, threads will very often need various synchronization objects,<br />which can take away any benefit the multi-threading would give.<br />Because of that, one should always do some pre-planning and<br />analyzis before implementing a threaded scheme.<br /><br />Threads can be hard to stop... well, this depends on how you use<br />them :).</div>
    <div class="meta">Posted on 2001-09-04 17:07:07 by f0dder</div>
   </div>
   <div class="post" id="post-6185">
    <div class="subject"><a href="#post-6185">Hmmm</a></div>
    <div class="body">As allways i get into Crusades with fodder :(<br /><br />The only reason i answer is because i hope beginners can learn from it <br /><br />As i stated before we use Threads in HE and i am not against Threads &quot;pro domo&quot;<br /><br /><div class="quote"><br />Bogdan, let's say you need to load a 200 meg file. How would you<br />do this in the MessageLoop and still be able to process the UI messages?<br />The only way I can think of would end up very very messy.<br /></div><br /><br />I think this is very easy:<br /><br /><pre><code><br /><br />;************************************<br />; WinMain MESSAGE LOOP STARTS HERE<br />;************************************<br /><br />msg_loop&#58;<br /><br />;============================================<br />; we use PeekMessage in order to detect idle &#40;no messages&#41;<br />; time we can use to do background tasks<br />; standard method i you dont want to use threads<br />;============================================<br />	push    PM_NOREMOVE<br />	push    0<br />	push    0<br />	push    0<br />	push    offset msg<br />	call    PeekMessageA<br /><br />;===============================<br />; test&#58; do we have messages?<br />;==============================<br />	cmp	eax, 0<br />	je	nu_sunt_msg		<br />;happy jump if we dont<br /><br />; ===============================<br />; but no so happy.. <br />; if we have to handle them<br />; ===============================<br />	push	0<br />	push	0<br />	push	0<br />	push	offset msg<br />	call	GetMessageA<br /><br />;===================================<br />; test&#58; is this message  WM_QUIT ?<br />; =================================<br />	cmp	eax,0			<br />; GetMessageA will return zero if it is...?<br />	je	end_loop			<br />; EXIT PROGRAM IF TRUE!!!!<br /><br />;=========================================<br />; default action &#40;let windows do it's dirty job&#41;<br />; for all other messages<br />;======================================<br />	push	offset msg<br />	call	TranslateMessage<br /><br />	push	offset msg<br />	call	DispatchMessageA<br /><br />;======================================<br />; and jump back to do it all over again<br />;======================================<br />	jmp	msg_loop<br /><br />;=================================<br />; Here ENDS Our Program &#40;normaly&#41;<br />;==================================<br />end_loop&#58;<br />	push	&#91;msg.msWPARAM&#93;<br />	call	ExitProcess		<br />;exit to windows<br /><br />;===================================<br />; we should never reach this point<br />;===================================<br />	ret<br /><br /><br />;=========================================<br />; so...there are no win messages....<br />; HERE we do our GAME MAIN LOOP <br />; OR load a 200 mega file here ;&#41; fodder<br />;=========================================<br /><br />nu_sunt_msg&#58;<br />	push         eax<br />	push	ebx<br />	push	ecx<br />	push	edx<br /><br />	push	esi<br />	push	edi<br /><br />;===================================<br />;  test if we must do it<br />; the procedure should read 1Mega at a time?<br />;=====================================<br /> .IF &#91;we_must_load_file&#93;==1<br />    Call Our_Mighty_File_Loader_by_small_pieces<br /> .ELSE<br /><br />;==================================<br />; just return to WIN message loop<br />; this push /pop is just for safety<br />; and usually not required<br />;=================================<br />	pop	edi<br />	pop	esi<br />	pop	edx<br />	pop	ecx<br />	pop	ebx<br />	pop	eax			<br />;====================================<br />; return to main Message Loop<br />;====================================<br />	jmp	msg_loop<br /><br /></code></pre><br /><br /><br /><strong><div class="quote"><br />It's not true that creating an extra thread will make your application<br />go half speed. Sure, there's a little extra overhead in the thread/task<br />scheduling, but it's so little you can hardly feel it (you're not doing<br />realtime tasks under windows, are you?). If you have, say, two<br />math intensive threads running at the same time, they might run<br />at &quot;half speed&quot; - but you'd be finished in about the same time as<br />if you run them sequentially. When creating a thread for &quot;heavy-duty<br />processing&quot; and have the MessageLoop in the main thread, the<br />main thread will be asleep most of the time in the GetMessage call.<br />Which is a good reason to use GetMessage instead of PeekMessage -<br />the system can sleep a thread on GetMessage, and thus spare CPU<br />cycles, but it can't do this on PeekMessage.<br /></div><br /><br />IF 2 threads will not sleep and  will both have the same priority the programm will get EXACTLY 1/2 speed....or even less<br /><br />Anything can be done on PeekMessage<br /><br />And of course a sleeping thread dosent take CPU cycles (it takes a few) so we cant compare. <br /><br />GetMessage is for Cooperative Multitasking. <br /><br />It is well known (but forgotten a lot) that Cooperative multitasking is MUCH Faster then Preemptive Multitasking...but more complicated for the programmer....<br /><br />well only a little as you see above i have never seen anybody cry for the existence of windows message loop...<br /><br />Preemptive Multitasking is sometimes good for games and looks easyer to program ....<br /><br />but it takes a LOT of CPU power to do the context switch every time ... also because programs do not know when they are switched out ... it is very EXPENSIVE and INEFICIENT... <br /><br />modern Microprocessors TRY to compensate for this...but only with limited succes...as still they can never know WHEN is the RIGHT moment to SWITCH an Application<br /><br /><br /><strong><div class="quote"><br />Threads can generate very nasty and hard to debug bugs... but this<br />is not due to the threads, it's due to bad programming. Admitted,<br />it can be very hard to get threads working right when doing more<br />complicated stuff, but the only way around this is experience. So<br />don't try to crawl away from threads. Use them if they make life<br />easier or can speed up your app. Not for the heck of it. But don't<br />invent &quot;weird schemes&quot; to get away from threads.<br /></div><br /><br />No &quot;wierd schemes&quot; here, its right from Petzold's Book<br />(something about programming windows for dummies)<br /><br />Sure, on windows we can not get away from threads ... even if we want ...<br /><br /><strong> i only want you to learn to use them WISELY </strong><br /><br />Threads NEVER Speed UP Application they ONLY SLOW Them DOWN...sometimes a LOT sometimes acceptable (like HE  )<br /><br />Thread generate BUGS just by themselfves because they are PARALLEL programming and this makes new bugs available  to the user ... <br /><br />errors will allways exist no matter how hard we try to avoid then... but threads makes them allmost IMPOSIBLE to DEBUG and find them. A thread error can show after 1 year of perfect running app, and after that show at every 10 second or after a new hardware upgrade make the system unstable ...<br /><br />the same program but without THREADS will NEVER have those BUGS!<br /><br />Most of today unstable windows systems are because of Threads usage<br /><br /><strong><div class="quote"><br />Yes, threads will very often need various synchronization objects,<br />which can take away any benefit the multi-threading would give.<br />Because of that, one should always do some pre-planning and<br />analyzis before implementing a threaded scheme.<br /></div><br /><br />They will take more away <br />and all this mambo jambo thread for what? <br /><br />if its COMPLICATED AND SLOWER...then WHAT FOR my friend? ONLY because it can be done...and we want to be 133t?<br /><br />Cooperative Multitasking using PeekMessage was the first implemented because it is more efective, faster, and less bugs ...and i have to say that MacOSs crashes al lot  LESS then Windows and UNIXes<br /><br />However UNIXes show that a good Preemptive Multitasking system will eventually work ;)  but hellas we are not on Unixes here <br /><br /><br /><strong><div class="quote"><br />Threads can be hard to stop... well, this depends on how you use<br />them :). </div><br /><br />Yup<br /><br />Dont get me Wrong....i use threads and i cry and i use threads and i cry....</div>
    <div class="meta">Posted on 2001-09-04 18:41:52 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-6189">
    <div class="subject"><a href="#post-6189">aborting a loop</a></div>
    <div class="body"><div class="quote"><br />As allways i get into Crusades with fodder  :(<br /></div><br /><br />Hey, that's not necessarily a bad thing :). Either of us might learn<br />a thing or two. As for your solution to load the file (or whatever<br />intensive action), yes, this is how I was thinking it would be done.<br />However, loading the file (or whatever other action) in &quot;small pieces&quot;<br />might not be very eays. It might be so complicated that the multi-threaded<br />approach is justifyable. Handling a single &quot;game frame&quot;, with redraws,<br />AI logic, etc, will usually fit well into this approach, though. Number<br />crunching, file loading/saving, etc, often won't (well, that's just my experience).<br /><br /><div class="quote"><br />IF 2 threads will not sleep and will both have the same priority the programm will get EXACTLY 1/2 speed....or even less <br /></div><br /><br />Well okay, yes. What I meant (but didn't explain well enough :^))<br />is that your program will get both threads done the same time when<br />doing them parallel and if you did the serial (well, a very little bit<br />slower because of the extra overhead of threads, but this should<br />not be anything you can even feel). Obviously this can be unacceptable<br />in a game or other situations where you need to react quickly to<br />user input. In an editor, or &quot;similar&quot; application, it won't hurt.<br /><br />Cooperative multitasking may be a bit &quot;faster&quot; if implemented correctly,<br />but it's too easy to have a system where a single bad app can take<br />down the whole system. And if your apps don't have enough calls<br />to functions that yield (peekmessage, yield, probably more), the<br />multitasking will NOT feel very smooth. And really, preemptive<br />multitasking doesn't take that much CPU power. Considering how<br />useful it is, I think those cpu cycles are well spent :). Processors<br />can't know when it's a good time to switch the process/thread, so<br />it's pretty lucky that it's the OS deciding this ;) (apart from the<br />hardware interrupts, of course). Win9x has a reasonable algorithm,<br />win2k seems to be somewhat smarter (subjective, feeling, not tested).<br /><br />Well, you're not 100% correct that threads will never speed up<br />applications. Sure, there's overhead in threading, and in a uniprocessor<br />system, I can't see how threads can speed up an app. But in a multi-processor<br />system (these are slowly beginning to become common, even home<br />users are starting to get them), threads can make a radical speedup<br />if done correctly, as the threads can be distributed between processors.<br />You will probably not get a 2x improvement with  two processors<br />because of the sync that needs to be done... but without threads,<br />you can only distribute processes on the CPUs, which is less efficient.<br /><br /><div class="quote"><br />i only want you to learn to use them WISELY<br /></div><br />And this is indeed very good advice! Don't use threads just because<br />you can, use them where they make sense :).<br /><br />And well... threads will NEVER create bugs just out of the blue sky.<br />It's true that you can have weird situations that can appear after<br />10 seconds or 10 years, but it's *always* the fault of the programmer.<br />And yes, this is almost impossible to debug. Deadlocks, race conditions :(.<br />That's why any &quot;serious&quot; thread usage requires even more careful<br />planning than normal application design.<br /><br /><div class="quote"><br />Most of today unstable windows systems are because of Threads usage<br /></div><br />It's more generic than that. Most of today unstable windows systems<br />are because of sloppy prorgammers. Too bad win9x sucks so much<br />that a bad app can take the entire system down. I've yet to see an<br />app that can take win2k down (well, a &quot;casual&quot; app. If you write<br />something with the sole purpose of taking win2k down, it can probably<br />be done).<br /><br /><div class="quote"><br />Cooperative Multitasking using PeekMessage was the first implemented because it is more efective, faster, and less bugs ...and i have to say that MacOSs crashes al lot LESS then Windows and UNIXes <br /></div><br />You've been pretty lucky, then. I remember windows 3.x crashing<br />a lot because of badly behaving apps. I remember mac os crashing<br />a lot lot lot lot, either hanging, or just giving a stupid dialog with<br />a bomb and a reboot button. From something as simple as running<br />netscape navigator, hah.<br /><br />My linux box never crashed. I had to reboot it once because I typed<br />a binary file to screen, which made the terminal all weird. If I had<br />known about the &quot;reset&quot; command (get terminal back into sane state),<br />I would not have needed the reboot. Last time my BSD box &quot;crashed&quot;<br />was because I accidentally flipped the reset switch. It had an uptime<br />of 9 days... which was as long as there had been BSD on the box.<br />Now it's up to 3 days again, and it just keeps working and working<br />and working. So don't diss unix. It serves it's purpose very well.</div>
    <div class="meta">Posted on 2001-09-04 19:25:44 by f0dder</div>
   </div>
   <div class="post" id="post-6215">
    <div class="subject"><a href="#post-6215">aborting a loop</a></div>
    <div class="body">I thought I just would throw this in... PeekMessage to me is much easier to use. I hate threads! I'd rather code brain numbing code than to use threads :)</div>
    <div class="meta">Posted on 2001-09-05 00:02:10 by Kenny</div>
   </div>
   <div class="post" id="post-6216">
    <div class="subject"><a href="#post-6216">aborting a loop</a></div>
    <div class="body"><div class="quote"><br />I thought I just would throw this in... PeekMessage to me is much easier to use. I hate threads! I'd rather code brain numbing code than to use threads :)<br /></div><br /><br />That can be more or less the same, kenny :D. Overcome your hatred<br />for threads, and understand them. Learn their powers and weaknesses.<br />Then in each case decide whether you want to use them or not<br />(which will hopefully most often be not). That is the way of the programmer *g*.</div>
    <div class="meta">Posted on 2001-09-05 00:36:26 by f0dder</div>
   </div>
   <div class="post" id="post-6217">
    <div class="subject"><a href="#post-6217">aborting a loop</a></div>
    <div class="body">no need to use them yet, so I have no reason to learn anything :)<br /><br />I'd rather figure out this BLASTED COM CRAP!</div>
    <div class="meta">Posted on 2001-09-05 00:38:12 by Kenny</div>
   </div>
   <div class="post" id="post-6218">
    <div class="subject"><a href="#post-6218">aborting a loop</a></div>
    <div class="body">Take your time, and learn things in your own pace. But if I may give<br />you a piece of advice... learn things BEFORE you need to use them.<br />Only recently have i learned how much easier this will make your life ;).</div>
    <div class="meta">Posted on 2001-09-05 00:46:31 by f0dder</div>
   </div>
   <div class="post" id="post-6219">
    <div class="subject"><a href="#post-6219">aborting a loop</a></div>
    <div class="body">If I listened to you, I wouldn't be talking to you right now. I have a ton of other things to do instead of trying to figure out this com stuff.<br /><br />I have to animate some stuff for FJM before the 28th. I have to program about 60 hours of PHP stuff for a website launch in a week or so. I have 15 pages of papers to write before Friday. I have Finals in a week. I need to catch up on sleep. I can only go for so long on 3-4 hours a night :)</div>
    <div class="meta">Posted on 2001-09-05 00:50:28 by Kenny</div>
   </div>
   <div class="post" id="post-6221">
    <div class="subject"><a href="#post-6221">aborting a loop</a></div>
    <div class="body">I know what it's like :). Do the best you can! I'm currently struggling<br />to get an asm build environment up and running for nt/2k kernel<br />mode drivers.  There's a lot of work to do, but it's also a pretty<br />interesting field. The documentation is better than the win98ddk,<br />but still... it IS microsoft :)</div>
    <div class="meta">Posted on 2001-09-05 01:05:15 by f0dder</div>
   </div>
  </div>
 </body>
</html>