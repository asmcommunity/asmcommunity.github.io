<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>SSE2 check? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30178" />
    <link rel="next" href="../?id=30178&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=116">Windows</a> &raquo; <a href="../?id=30178">SSE2 check?</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=30178&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=30178&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="30178" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=30178&amp;page=2">&gt;</a><a href="../?id=30178&amp;page=2">&raquo;</a></form>   <div class="post" id="post-212830">
    <div class="subject"><a href="#post-212830">SSE2 check?</a></div>
    <div class="body">Hello!<br /><strong>I&#039;d like a way to automatedly check certain windows .dll-s and .exe-s whether or not the use SSE2 and other instruction sets.</strong><br /><br />If they do, a list of instructions they use, would also help.<br />I also would like help with a good debugger, because I have hard time with ollydbg 2 if it&#039;s SSE2,SSE3, etc...<br /><br />Thank you</div>
    <div class="meta">Posted on 2010-08-19 16:14:06 by amocsy</div>
   </div>
   <div class="post" id="post-212833">
    <div class="subject"><a href="#post-212833">Re: SSE2 check?</a></div>
    <div class="body">Almost all of 64-bit Windows DLLs use SSE2. Almost none of 32-bit Windows DLLs use any SSE.</div>
    <div class="meta">Posted on 2010-08-19 17:54:26 by ti_mo_n</div>
   </div>
   <div class="post" id="post-212840">
    <div class="subject"><a href="#post-212840">Re: SSE2 check?</a></div>
    <div class="body">Yes, and there are two reasons why SSE2 is used a lot in 64-bit:<br />1) The 64-bit extensions were introduced after SSE2, so technically SSE2 are not extensions in 64-bit. All 64-bit processors have SSE2 by default.<br />2) x87 is deprecated in 64-bit mode. All floating point operations should be done with SSE2.<br /><br />Anyway, if you want to find out if some code uses SSE2, you&#039;d have to at least partially disassemble the binary, in order to find out where the code is (trace through the jumps and calls and such).<br />And there are also various binaries that contain SSE2 code, but also a fallback path for older CPUs... so even if you detect SSE2, it doesn&#039;t necessarily mean that it uses that code.</div>
    <div class="meta">Posted on 2010-08-20 02:12:27 by Scali</div>
   </div>
   <div class="post" id="post-212870">
    <div class="subject"><a href="#post-212870">Re: SSE2 check?</a></div>
    <div class="body">It is of no matter if it has alternative path or not, so let me rephrase it: I&#039;d like to check whether or not a binary support sse2.<br /><br />1. But I don&#039;t think it&#039;s necessary to disassemble the binary, wouldn&#039;t knowing (numeric)opcodes be enought?<br />2. Also sse2 uses own registers, wouldn&#039;t it be enought to check if a binary use such registers or not?<br /><br />This is two possible ways it could work, maybe someone can come up with something better.<br /><br />Are there no established techniques to just let me know? It&#039;s not necessarily be a programmatic one.<br />More like I&#039;d be happy with a virus scanner like approach, which would instead of telling me I have a new variant of some malicious code, it would tell me I have sse2 code (like an infection :D ).<br /><br />I would like to make detailed statistics abort sse2,3, adoption in my environment.</div>
    <div class="meta">Posted on 2010-08-21 15:01:26 by amocsy</div>
   </div>
   <div class="post" id="post-212876">
    <div class="subject"><a href="#post-212876">Re: SSE2 check?</a></div>
    <div class="body">Your reply shows this topic is beyond your current knowledge. I suggest you should read first about binary encoding of CPU instructions and assembly in general.<br /><br />And &quot;a virus scanner like approach&quot; is pretty much what Scali said. It&#039;s called <a target="_blank" href="http://en.wikipedia.org/wiki/Disassembler">Disassembly</a>. Other approaches virus scanners use (pattern matching, heuristic analysis, etc) are not applicable in this scenario.</div>
    <div class="meta">Posted on 2010-08-21 19:10:34 by ti_mo_n</div>
   </div>
   <div class="post" id="post-212907">
    <div class="subject"><a href="#post-212907">Re: SSE2 check?</a></div>
    <div class="body"><div class="quote">2) x87 is deprecated in 64-bit mode.</div><br /><br />No, that&#039;s not right. For user threads the state of legacy floating point is preserved at context switch. But it is not true for kernel threads. Therefore only kernel mode drivers can not use legacy floating point instructions. Please check the following link, provided by MS:<br /><br /><a target="_blank" href="http://msdn.microsoft.com/en-us/library/a32tsf7t(VS.80).aspx">http://msdn.microsoft.com/en-us/library/a32tsf7t(VS.80).aspx</a><br /><br /><div class="quote">All floating point operations should be done with SSE2.</div><br /><br />That depends. If one need a better numerical accuracy, one should use FPU instructions, because the calculation is done internally with 80 bit, while SSE operates with 64 bits.<br /><br />Gunther<br /></div>
    <div class="meta">Posted on 2010-08-23 12:25:15 by Gunther</div>
   </div>
   <div class="post" id="post-212908">
    <div class="subject"><a href="#post-212908">Re: SSE2 check?</a></div>
    <div class="body"><div class="quote"><br /><div class="quote">2) x87 is deprecated in 64-bit mode.</div><br /><br />No, that&#039;s not right. For user threads the state of legacy floating point is preserved at context switch. But it is not true for kernel threads. Therefore only kernel mode drivers can not use legacy floating point instructions. Please check the following link, provided by MS:<br /><br /><a target="_blank" href="http://msdn.microsoft.com/en-us/library/a32tsf7t(VS.80).aspx">http://msdn.microsoft.com/en-us/library/a32tsf7t(VS.80).aspx</a><br /><br /><div class="quote">All floating point operations should be done with SSE2.</div><br /><br />That depends. If one need a better numerical accuracy, one should use FPU instructions, because the calculation is done internally with 80 bit, while SSE operates with 64 bits.<br /><br />Gunther<br /><br /></div><br /><br />I think you just misunderstand the meaning of the term &#039;deprecated&#039;.<br />Basically it means &quot;Yea, it still works, but we don&#039;t guarantee that it will still work in the future. We suggest you no longer make use of it.&quot;<br />I pasted the MSDN link and a quote a while ago on this forum... can&#039;t be arsed to look for it now.<br /><br />Edit: for some reason I recalled that I used the phrase &quot;MSDN to the rescue&quot;... and searching for that gave me the right post immediately:<br />http://www.asmcommunity.net/board/index.php?topic=29617.msg210597#msg210597<br /><br />As for more than 64-bit precision... All CPU manufacturers have decided LONG ago that it&#039;s useless (Microsoft&#039;s compiler has never supported a datatype for it either, like long double or such).<br />x86 and 68k are pretty much the only architectures that offered more than 64-bit precision in hardware. If you need more than 64-bit, you&#039;re doing it wrong.</div>
    <div class="meta">Posted on 2010-08-23 12:31:43 by Scali</div>
   </div>
   <div class="post" id="post-212910">
    <div class="subject"><a href="#post-212910">Re: SSE2 check?</a></div>
    <div class="body"><div class="quote">If you need more than 64-bit, you&#039;re doing it wrong.</div>Or rather, if you need more than 64bit precision... you need something that isn&#039;t floating-point.</div>
    <div class="meta">Posted on 2010-08-23 13:21:14 by f0dder</div>
   </div>
   <div class="post" id="post-212912">
    <div class="subject"><a href="#post-212912">Re: SSE2 check?</a></div>
    <div class="body"><div class="quote"><br />Or rather, if you need more than 64bit precision... you need something that isn&#039;t floating-point.<br /></div><br /><br />Exactly.</div>
    <div class="meta">Posted on 2010-08-23 13:34:42 by Scali</div>
   </div>
   <div class="post" id="post-212914">
    <div class="subject"><a href="#post-212914">Re: SSE2 check?</a></div>
    <div class="body"><div class="quote">I think you just misunderstand the meaning of the term &#039;deprecated&#039;.</div><br /><br />No.<br /><br /><div class="quote">Basically it means &quot;Yea, it still works, but we don&#039;t guarantee that it will still work in the future. We suggest you no longer make use of it.&quot;</div><br /><br />There has been widespread confusion about whether 64-bit Windows allows the use of the floating point registers. But that question was cleared some years ago inside the PlanetAMD64 forum: <a target="_blank" href="http://www.planetamd64.com/index.php?showtopic=3458&amp;st=100">http://www.planetamd64.com/index.php?showtopic=3458&amp;st=100</a> Here is the central quotation from that thread:<br /><br /><div class="quote"><br />I did more than that, I emailed one of M$ kernel guys:<br /><br />Sent: Wednesday, May 25, 2005 8:41 PM<br />Subject: FPU and MMX in x64?<br /><br />I have read somewhere in MSDN (perhaps it was in DDK part) that Windows x64 will not preserve state of FPU and MMX registers across context switch and that the code written to take advantage of FPU and MMX will not work. Does that still apply and if it does what is the scope? 64-bit apps, drivers, 32-bit apps or all of them?<br /><br />And here is the response I got:<br /><br />From: Program Manager in Visual C++ Group<br />Sent: Thursday, May 26, 2005 10:38 AM<br /><br />It does preserve the state. It&#039;s the DDK page that has stale information, which I&#039;ve requested it to be changed. Let them know that the OS does preserve state of x87 and MMX registers on context switches.<br /><br />From: Software Engineer in Windows Kernel Group<br />Sent: Thursday, May 26, 2005 11:06 AM<br /><br />For user threads the state of legacy floating point is preserved at context switch. But it is not true for kernel threads. Kernel mode drivers can not use legacy floating point instructions.<br /></div><br /><br />The next point:<br /><br /><div class="quote">Microsoft&#039;s compiler has never supported a datatype for it either, like long double or such</div><br /><br />That has to do with the idleness of the compiler designers. So far as I know, there are also a lot of C/C++ compilers, which don&#039;t support BCD values. I know at least 2 compilers with BCD and extended float support.<br /><br />On the other hand, it makes a great difference, if you&#039;re operating internally with 80 or with 64 bits (rounding errors). If in doubt, read the following text by William Kahan &quot;The Father of Floating Point&quot;: <a target="_blank" href="http://www.cs.berkeley.edu/~wkahan/LOG10HAF.TXT">http://www.cs.berkeley.edu/~wkahan/LOG10HAF.TXT</a><br /><br />By the way, with an assembly language application, you could support BCD, float, double, long double and a lot of other funny formats.<br /><br />Gunther<br /> <br /><br /></div>
    <div class="meta">Posted on 2010-08-23 14:19:35 by Gunther</div>
   </div>
   <div class="post" id="post-212915">
    <div class="subject"><a href="#post-212915">Re: SSE2 check?</a></div>
    <div class="body"><div class="quote"><div class="quote">I think you just misunderstand the meaning of the term &#039;deprecated&#039;.</div><br />No.</div><br />No offense intended, but, seriously, that&#039;s exactly what &quot;deprecated&quot; means.</div>
    <div class="meta">Posted on 2010-08-23 15:06:30 by ti_mo_n</div>
   </div>
   <div class="post" id="post-212916">
    <div class="subject"><a href="#post-212916">Re: SSE2 check?</a></div>
    <div class="body">As ti_mo_n points out, you still don&#039;t seem to understand what &#039;deprecated&#039; means.<br />Yes it works, but no, you shouldn&#039;t be using the functionality.<br />The confusion is because originally Microsoft didn&#039;t want to support x87/MMX/3DNow! at all (as per AMD&#039;s and Intel&#039;s recommendations, see their x64 documentation), but they later decided against it... for now.<br /><br />Oh god, BCD... another thing that CPU designers have LONG given up because there really is no point to it. This guy sounds like he&#039;s just timewarped here from the 70s.</div>
    <div class="meta">Posted on 2010-08-23 15:25:09 by Scali</div>
   </div>
   <div class="post" id="post-212917">
    <div class="subject"><a href="#post-212917">Re: SSE2 check?</a></div>
    <div class="body">Okay, okay the community guru has spoken. I don&#039;t know what deprecated means. But I can read the official statements from MS kernel programmers. And that says: The FPU state is preserved during task switches. Period.<br /><br />And of course, that old fashioned BCD format (seems like timewarped from the 70s). So try to write a few lines of reasonable code for, let me say, book-keeping or bank software without BCD. Furthermore, try to convert 0.1 (decimal) into the appropriate binary format and you will know why BCD is a point. But never mind.<br /><br />Gunther<br /></div>
    <div class="meta">Posted on 2010-08-23 16:16:11 by Gunther</div>
   </div>
   <div class="post" id="post-212918">
    <div class="subject"><a href="#post-212918">Re: SSE2 check?</a></div>
    <div class="body"><div class="quote"><br />Okay, okay the community guru has spoken. I don&#039;t know what deprecated means. But I can read the official statements from MS kernel programmers. And that says: The FPU state is preserved during task switches. Period.</div><br /><br />Yes, and that behaviour is marked as &#039;deprecated&#039;.<br /><br /><div class="quote">And of course, that old fashioned BCD format (seems like timewarped from the 70s). So try to write a few lines of reasonable code for, let me say, book-keeping or bank software without BCD. Furthermore, try to convert 0.1 (decimal) into the appropriate binary format and you will know why BCD is a point. But never mind.</div><br /><br />Just because it seemed a good idea to do that in hardware in the 70s doesn&#039;t mean that this assumption is still valid today.<br />Like with FPU precision beyond 64 bits, no modern CPU architecture supports BCD. Intel/AMD still support it, but only through slow microcode emulation.<br />All modern software is written in high-level languages, which provide various optimized libraries to convert from/to decimal, optimized for performance, without the need for BCD hardware support.<br />THAT&#039;s why you are talking like you timewarped from the 70s.<br />Common problem with x86 assembly programmers... they see all these weird x86 instructions and think they actually are useful.<br />Nope, they&#039;re just legacy from the 70s, when x86 was designed. Most of it isn&#039;t even implemented in hardware directly, and in most cases doing it &#039;the compiler way&#039; (as in not using the esoteric instructions, but just using the regular modern CPU subset of optimized instructions) is the fastest way.<br />Here&#039;s another one for ya: rep movsd? Rubbish, total rubbish!<br />Here&#039;s what AMD suggests for a memcpy instead:<br /><pre><code>/******************************************************************************<br /><br /> Copyright (c) 2001 Advanced Micro Devices, Inc.<br /><br /> LIMITATION OF LIABILITY:&nbsp; THE MATERIALS ARE PROVIDED *AS IS* WITHOUT ANY<br /> EXPRESS OR IMPLIED WARRANTY OF ANY KIND INCLUDING WARRANTIES OF MERCHANTABILITY,<br /> NONINFRINGEMENT OF THIRD-PARTY INTELLECTUAL PROPERTY, OR FITNESS FOR ANY<br /> PARTICULAR PURPOSE.&nbsp; IN NO EVENT SHALL AMD OR ITS SUPPLIERS BE LIABLE FOR ANY<br /> DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF PROFITS,<br /> BUSINESS INTERRUPTION, LOSS OF INFORMATION) ARISING OUT OF THE USE OF OR<br /> INABILITY TO USE THE MATERIALS, EVEN IF AMD HAS BEEN ADVISED OF THE POSSIBILITY<br /> OF SUCH DAMAGES.&nbsp; BECAUSE SOME JURISDICTIONS PROHIBIT THE EXCLUSION OR LIMITATION<br /> OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES, THE ABOVE LIMITATION MAY<br /> NOT APPLY TO YOU.<br /><br /> AMD does not assume any responsibility for any errors which may appear in the<br /> Materials nor any responsibility to support or update the Materials.&nbsp; AMD retains<br /> the right to make changes to its test specifications at any time, without notice.<br /><br /> NO SUPPORT OBLIGATION: AMD is not obligated to furnish, support, or make any<br /> further information, software, technical information, know-how, or show-how<br /> available to you.<br /><br /> So that all may benefit from your experience, please report&nbsp; any&nbsp; problems<br /> or&nbsp; suggestions about this software to 3dsdk.support@amd.com<br /><br /> AMD Developer Technologies, M/S 585<br /> Advanced Micro Devices, Inc.<br /> 5900 E. Ben White Blvd.<br /> Austin, TX 78741<br /> 3dsdk.support@amd.com<br />******************************************************************************/<br /><br />/*****************************************************************************<br />MEMCPY_AMD.CPP<br />******************************************************************************/<br /><br />// Very optimized memcpy() routine for all AMD Athlon and Duron family.<br />// This code uses any of FOUR different basic copy methods, depending<br />// on the transfer size.<br />// NOTE:&nbsp; Since this code uses MOVNTQ (also known as &quot;Non-Temporal MOV&quot; or<br />// &quot;Streaming Store&quot;), and also uses the software prefetchnta instructions,<br />// be sure youre running on Athlon/Duron or other recent CPU before calling!<br /><br />#define TINY_BLOCK_COPY 64&nbsp; &nbsp; &nbsp;  // upper limit for movsd type copy<br />// The smallest copy uses the X86 &quot;movsd&quot; instruction, in an optimized<br />// form which is an &quot;unrolled loop&quot;.<br /><br />#define IN_CACHE_COPY 64 * 1024&nbsp; // upper limit for movq/movq copy w/SW prefetch<br />// Next is a copy that uses the MMX registers to copy 8 bytes at a time,<br />// also using the &quot;unrolled loop&quot; optimization.&nbsp;  This code uses<br />// the software prefetch instruction to get the data into the cache.<br /><br />#define UNCACHED_COPY 197 * 1024 // upper limit for movq/movntq w/SW prefetch<br />// For larger blocks, which will spill beyond the cache, its faster to<br />// use the Streaming Store instruction MOVNTQ.&nbsp;  This write instruction<br />// bypasses the cache and writes straight to main memory.&nbsp; This code also<br />// uses the software prefetch instruction to pre-read the data.<br />// USE 64 * 1024 FOR THIS VALUE IF YOURE ALWAYS FILLING A &quot;CLEAN CACHE&quot;<br /><br />#define BLOCK_PREFETCH_COPY&nbsp; infinity // no limit for movq/movntq w/block prefetch <br />#define CACHEBLOCK 80h // number of 64-byte blocks (cache lines) for block prefetch<br />// For the largest size blocks, a special technique called Block Prefetch<br />// can be used to accelerate the read operations.&nbsp;  Block Prefetch reads<br />// one address per cache line, for a series of cache lines, in a short loop.<br />// This is faster than using software prefetch.&nbsp; The technique is great for<br />// getting maximum read bandwidth, especially in DDR memory systems.<br /><br />// Inline assembly syntax for use with Visual C++<br /><br />void * memcpy_amd(void *dest, const void *src, size_t n)<br />{<br />&nbsp; __asm {<br /><br />	mov		ecx, 		; number of bytes to copy<br />	mov		edi, 		; destination<br />	mov		esi, 		; source<br />	mov		ebx, ecx		; keep a copy of count<br /><br />	cld<br />	cmp		ecx, TINY_BLOCK_COPY<br />	jb		$memcpy_ic_3	; tiny? skip mmx copy<br /><br />	cmp		ecx, 32*1024		; dont align between 32k-64k because<br />	jbe		$memcpy_do_align	;&nbsp; it appears to be slower<br />	cmp		ecx, 64*1024<br />	jbe		$memcpy_align_done<br />$memcpy_do_align:<br />	mov		ecx, 8			; a trick thats faster than rep movsb...<br />	sub		ecx, edi		; align destination to qword<br />	and		ecx, 111b		; get the low bits<br />	sub		ebx, ecx		; update copy count<br />	neg		ecx				; set up to jump into the array<br />	add		ecx, offset $memcpy_align_done<br />	jmp		ecx				; jump to array of movsbs<br /><br />align 4<br />	movsb<br />	movsb<br />	movsb<br />	movsb<br />	movsb<br />	movsb<br />	movsb<br />	movsb<br /><br />$memcpy_align_done:			; destination is dword aligned<br />	mov		ecx, ebx		; number of bytes left to copy<br />	shr		ecx, 6			; get 64-byte block count<br />	jz		$memcpy_ic_2	; finish the last few bytes<br /><br />	cmp		ecx, IN_CACHE_COPY/64	; too big 4 cache? use uncached copy<br />	jae		$memcpy_uc_test<br /><br />// This is small block copy that uses the MMX registers to copy 8 bytes<br />// at a time.&nbsp; It uses the &quot;unrolled loop&quot; optimization, and also uses<br />// the software prefetch instruction to get the data into the cache.<br />align 16<br />$memcpy_ic_1:			; 64-byte block copies, in-cache copy<br /><br />	prefetchnta 		; start reading ahead<br /><br />	movq	mm0, 	; read 64 bits<br />	movq	mm1, <br />	movq	, mm0	; write 64 bits<br />	movq	, mm1	;&nbsp; &nbsp; note:&nbsp; the normal movq writes the<br />	movq	mm2, 	;&nbsp; &nbsp; data to cache; a cache line will be<br />	movq	mm3, 	;&nbsp; &nbsp; allocated as needed, to store the data<br />	movq	, mm2<br />	movq	, mm3<br />	movq	mm0, <br />	movq	mm1, <br />	movq	, mm0<br />	movq	, mm1<br />	movq	mm2, <br />	movq	mm3, <br />	movq	, mm2<br />	movq	, mm3<br /><br />	add		esi, 64			; update source pointer<br />	add		edi, 64			; update destination pointer<br />	dec		ecx				; count down<br />	jnz		$memcpy_ic_1	; last 64-byte block?<br /><br />$memcpy_ic_2:<br />	mov		ecx, ebx		; has valid low 6 bits of the byte count<br />$memcpy_ic_3:<br />	shr		ecx, 2			; dword count<br />	and		ecx, 1111b		; only look at the &quot;remainder&quot; bits<br />	neg		ecx				; set up to jump into the array<br />	add		ecx, offset $memcpy_last_few<br />	jmp		ecx				; jump to array of movsds<br /><br />$memcpy_uc_test:<br />	cmp		ecx, UNCACHED_COPY/64	; big enough? use block prefetch copy<br />	jae		$memcpy_bp_1<br /><br />$memcpy_64_test:<br />	or		ecx, ecx		; tail end of block prefetch will jump here<br />	jz		$memcpy_ic_2	; no more 64-byte blocks left<br /><br />// For larger blocks, which will spill beyond the cache, its faster to<br />// use the Streaming Store instruction MOVNTQ.&nbsp;  This write instruction<br />// bypasses the cache and writes straight to main memory.&nbsp; This code also<br />// uses the software prefetch instruction to pre-read the data.<br />align 16<br />$memcpy_uc_1:				; 64-byte blocks, uncached copy<br /><br />	prefetchnta 		; start reading ahead<br /><br />	movq	mm0,		; read 64 bits<br />	add		edi,64			; update destination pointer<br />	movq	mm1,<br />	add		esi,64			; update source pointer<br />	movq	mm2,<br />	movntq	, mm0	; write 64 bits, bypassing the cache<br />	movq	mm0,	;&nbsp; &nbsp; note: movntq also prevents the CPU<br />	movntq	, mm1	;&nbsp; &nbsp; from READING the destination address<br />	movq	mm1,	;&nbsp; &nbsp; into the cache, only to be over-written<br />	movntq	, mm2	;&nbsp; &nbsp; so that also helps performance<br />	movq	mm2,<br />	movntq	, mm0<br />	movq	mm0,<br />	movntq	, mm1<br />	movq	mm1,<br />	movntq	, mm2<br />	movntq	, mm0<br />	dec		ecx<br />	movntq	, mm1<br />	jnz		$memcpy_uc_1	; last 64-byte block?<br /><br />	jmp		$memcpy_ic_2		; almost done<br /><br />// For the largest size blocks, a special technique called Block Prefetch<br />// can be used to accelerate the read operations.&nbsp;  Block Prefetch reads<br />// one address per cache line, for a series of cache lines, in a short loop.<br />// This is faster than using software prefetch, in this case.<br />// The technique is great for getting maximum read bandwidth,<br />// especially in DDR memory systems.<br />$memcpy_bp_1:			; large blocks, block prefetch copy<br /><br />	cmp		ecx, CACHEBLOCK			; big enough to run another prefetch loop?<br />	jl		$memcpy_64_test			; no, back to regular uncached copy<br /><br />	mov		eax, CACHEBLOCK / 2		; block prefetch loop, unrolled 2X<br />	add		esi, CACHEBLOCK * 64	; move to the top of the block<br />align 16<br />$memcpy_bp_2:<br />	mov		edx, 		; grab one address per cache line<br />	mov		edx, 		; grab one address per cache line<br />	sub		esi, 128			; go reverse order<br />	dec		eax					; count down the cache lines<br />	jnz		$memcpy_bp_2		; keep grabbing more lines into cache<br /><br />	mov		eax, CACHEBLOCK		; now that its in cache, do the copy<br />align 16<br />$memcpy_bp_3:<br />	movq	mm0, 		; read 64 bits<br />	movq	mm1, <br />	movq	mm2, <br />	movq	mm3, <br />	movq	mm4, <br />	movq	mm5, <br />	movq	mm6, <br />	movq	mm7, <br />	add		esi, 64				; update source pointer<br />	movntq	, mm0		; write 64 bits, bypassing cache<br />	movntq	, mm1		;&nbsp; &nbsp; note: movntq also prevents the CPU<br />	movntq	, mm2		;&nbsp; &nbsp; from READING the destination address <br />	movntq	, mm3		;&nbsp; &nbsp; into the cache, only to be over-written,<br />	movntq	, mm4		;&nbsp; &nbsp; so that also helps performance<br />	movntq	, mm5<br />	movntq	, mm6<br />	movntq	, mm7<br />	add		edi, 64				; update dest pointer<br /><br />	dec		eax					; count down<br /><br />	jnz		$memcpy_bp_3		; keep copying<br />	sub		ecx, CACHEBLOCK		; update the 64-byte block count<br />	jmp		$memcpy_bp_1		; keep processing chunks<br /><br />// The smallest copy uses the X86 &quot;movsd&quot; instruction, in an optimized<br />// form which is an &quot;unrolled loop&quot;.&nbsp;  Then it handles the last few bytes.<br />align 4<br />	movsd<br />	movsd			; perform last 1-15 dword copies<br />	movsd<br />	movsd<br />	movsd<br />	movsd<br />	movsd<br />	movsd<br />	movsd<br />	movsd			; perform last 1-7 dword copies<br />	movsd<br />	movsd<br />	movsd<br />	movsd<br />	movsd<br />	movsd<br /><br />$memcpy_last_few:		; dword aligned from before movsds<br />	mov		ecx, ebx	; has valid low 2 bits of the byte count<br />	and		ecx, 11b	; the last few cows must come home<br />	jz		$memcpy_final	; no more, lets leave<br />	rep		movsb		; the last 1, 2, or 3 bytes<br /><br />$memcpy_final: <br />	emms				; clean up the MMX state<br />	sfence				; flush the write buffer<br />	mov		eax, 	; ret value = destination pointer<br /><br />&nbsp; &nbsp; }<br />}</code></pre></div>
    <div class="meta">Posted on 2010-08-23 16:34:49 by Scali</div>
   </div>
   <div class="post" id="post-212919">
    <div class="subject"><a href="#post-212919">Re: SSE2 check?</a></div>
    <div class="body"><div class="quote">Here&#039;s what AMD suggests for a memcpy instead:</div><br /><br />First of all, we&#039;re not talking about various memcpy routines here. Everyone can read about that, for example, in the AMD Software Optimization Guide and other related documents. There&#039;s no secret about that. <br /><br /><div class="quote">Yes, and that behaviour is marked as &#039;deprecated&#039;.</div><br /><br />So. Have you really checked the links, I&#039;ve provided? Here is the MS statement again: <a target="_blank" href="http://msdn.microsoft.com/en-us/library/a32tsf7t(VS.80).aspx">http://msdn.microsoft.com/en-us/library/a32tsf7t(VS.80).aspx</a> It&#039;s not only true for Visual Studio 2005, but also for Visual Studio 2008 and of course Visual Studio 2010. Is there any better version of VS? Nothing in that statement is marked as &#039;deprecated&#039;, really nothing.<br /><br /><div class="quote">All modern software is written in high-level languages, which provide various optimized libraries to convert from/to decimal, optimized for performance, without the need for BCD hardware support.</div><br /><br />It&#039;s not a question of speed, it&#039;s a question of accuracy. Have you tried to convert 0.1 (decimal) into the binary equivalent before your answer? I&#039;ll do that for you: 0.1 dec = 0.0 0011 0011 0011 0011 ... It&#039;s periodical, just like 1/3 in the decimal system. The trick is: you&#039;ve 32 or 64 or 128 or whatever bits to store the binary value, and that stored value is not exactly 1/10 = 0.1 decimal. That effect occurs by 0.1 and it&#039;s multiples. Those common numbers are infinite periodic binary fractions. By summing up such numbers, a large amount of errors can occur. With floating point arithmetic, we&#039;ve to live with those conversion errors. Therefore, approximately 85 - 90% of the worldwide running bank software is written in COBOL and uses BCD arithmetic to avoid these errors.<br /><br /><div class="quote">Just because it seemed a good idea to do that in hardware...</div><br /><br />Sure, would that be a better way. But do you have such hardware between your CPU and the compiler?<br /><br />Gunther<br /></div>
    <div class="meta">Posted on 2010-08-23 17:26:51 by Gunther</div>
   </div>
   <div class="post" id="post-212922">
    <div class="subject"><a href="#post-212922">Re: SSE2 check?</a></div>
    <div class="body"><div class="quote"><br />First of all, we&#039;re not talking about various memcpy routines here. Everyone can read about that, for example, in the AMD Software Optimization Guide and other related documents. There&#039;s no secret about that.</div><br /><br />I&#039;m just pointing out that although in the 70s it seemed smart to add rep movs to the hardware, today this is no longer the preferred way to perform a memcpy.<br />Same thing as BCD and 80-bit floating point.<br /><br /><div class="quote">So. Have you really checked the links, I&#039;ve provided? Here is the MS statement again: <a target="_blank" href="http://msdn.microsoft.com/en-us/library/a32tsf7t(VS.80).aspx">http://msdn.microsoft.com/en-us/library/a32tsf7t(VS.80).aspx</a> It&#039;s not only true for Visual Studio 2005, but also for Visual Studio 2008 and of course Visual Studio 2010. Is there any better version of VS? Nothing in that statement is marked as &#039;deprecated&#039;, really nothing.</div><br /><br />The more important question here is: Have you checked the links that *I* have provided?<br />I hate to repeat myself, but apparently there is no way to get through to you... so here it is again:<br />http://msdn.microsoft.com/en-us/library/ee418798(VS.85).aspx<br /><div class="quote">The x87, MMX, and 3DNow! instruction sets are <strong>deprecated</strong> in 64-bit modes. The instructions sets are still present for backward compatibility for 32-bit mode; however, to avoid compatibility issues in the future, <strong>their use in current and future projects is discouraged.</strong></div><br /><br />Happy now?<br /><br /><div class="quote">It&#039;s not a question of speed, it&#039;s a question of accuracy. Have you tried to convert 0.1 (decimal) into the binary equivalent before your answer? I&#039;ll do that for you: 0.1 dec = 0.0 0011 0011 0011 0011 ... It&#039;s periodical, just like 1/3 in the decimal system. The trick is: you&#039;ve 32 or 64 or 128 or whatever bits to store the binary value, and that stored value is not exactly 1/10 = 0.1 decimal. That effect occurs by 0.1 and it&#039;s multiples. Those common numbers are infinite periodic binary fractions. By summing up such numbers, a large amount of errors can occur. With floating point arithmetic, we&#039;ve to live with those conversion errors. Therefore, approximately 85 - 90% of the worldwide running bank software is written in COBOL and uses BCD arithmetic to avoid these errors.</div><br /><br />Not sure what your point is here... Nobody said you should use floating point instead of BCD.<br />And if we&#039;re still on the subject of 80-bit precision... as you said it yourself, the problem exists with floating point, no matter how many bits you have.<br />You can implement BCD just fine without specific hardware support.<br />For example, .NET offers some fine libraries for exactly this sort of thing, as I said. Things like the Decimal datatype, or the BigInteger.</div>
    <div class="meta">Posted on 2010-08-24 01:54:05 by Scali</div>
   </div>
   <div class="post" id="post-212925">
    <div class="subject"><a href="#post-212925">Re: SSE2 check?</a></div>
    <div class="body"><div class="quote">I&#039;m just pointing out that although in the 70s it seemed smart to add rep movs to the hardware, today this is no longer the preferred way to perform a memcpy.</div><br /><br />Of course. And it seems obvious that I&#039;m using rep movsb in my memcpy routines. Right?<br /><br /><div class="quote">The more important question here is: Have you checked the links that *I* have provided?</div><br /><br />Yes, I did. What can I say? The informations at the Microsoft website are inconsistent. Are you absolutely sure, that your entry is the right one? By the way, The Intel C++ compiler for x64 Windows supports long double precision and __m64 in version 9.0 and later.<br /><br /><div class="quote">Not sure what your point is here</div><br /><br />That&#039;s surprising. Integers are not the problem. But by converting fractionals from the decimal system into the binary system you&#039;ve to deal with that conversion errors. It&#039;s a simple mathematical question.&nbsp; <br /><br /><div class="quote">And if we&#039;re still on the subject of 80-bit precision... as you said it yourself, the problem exists with floating point, no matter how many bits you have.</div><br /><br />Yes, that was my point. You may use float or double; both are expanded inside the FPU into the 80 bit format for doing your computation. If your calculation is finished - not before - the result is rounded back to the appropriate format. And that makes a great difference in comparison to the floating point operations with SSE registers, which can only use 64 bits. I wrote about that point above. The internal 80 bit calculation inside the FPU leads to error reducing. Do you agree?<br /><br />I&#039;ve to ask that, because you&#039;re jumping from point to point. This trick is simple, but obvious. For example, I wrote about C compilers (software!), which don&#039;t support the BCD data type and you came up with memcpy routines. Moreover, you wrote now:<br /><br /><div class="quote">You can implement BCD just fine without specific hardware support. For example, .NET offers some fine libraries for exactly this sort of thing,</div><br /><br />Fine. The underlying hardware isn&#039;t my problem. But why must we use a seperate .NET library (just another black box) for such calculations? Why is that feature not supported by native C/C++ compilers? Life would be easyer, because BCD math is necessary sometimes. But that&#039;s only my personal point of view; it must not be true. You know, I&#039;m timewarped from the 70s.<br /><br />All together. I&#039;m here to discuss questions and I don&#039;t want a fruitless quarreling that just splitting hairs. I think it&#039;s enough now. I&#039;m not such a guru and your and my time isn&#039;t endless. So, please excuse my marginalia. I won&#039;t do that again with you. ;)<br /><br />Gunther&nbsp; <br /></div>
    <div class="meta">Posted on 2010-08-24 05:29:13 by Gunther</div>
   </div>
   <div class="post" id="post-212926">
    <div class="subject"><a href="#post-212926">Re: SSE2 check?</a></div>
    <div class="body"><div class="quote"><br />Yes, that was my point. You may use float or double; both are expanded inside the FPU into the 80 bit format for doing your computation. If your calculation is finished - not before - the result is rounded back to the appropriate format. And that makes a great difference in comparison to the floating point operations with SSE registers, which can only use 64 bits. I wrote about that point above. The internal 80 bit calculation inside the FPU leads to error reducing. Do you agree?</div><br /><br />That depends on whether or not you have the control word set up that way.<br />By default it is set to double precision, so you are not using the full 80 bit FPU precision:<br />http://msdn.microsoft.com/en-us/library/y0ybw9fy.aspx<br /><div class="quote">By default, _controlfp&#039;s precision control is set to 53 bits (_PC_53).</div><br /><br />So unless you specifically changed the control word, I don&#039;t agree. There is no extra precision when using x87 over SSE2 by default, in a Windows application.<br /><br /><div class="quote">I&#039;ve to ask that, because you&#039;re jumping from point to point. This trick is simple, but obvious. For example, I wrote about C compilers (software!), which don&#039;t support the BCD data type and you came up with memcpy routines.</div><br /><br />I already said that you can use libraries (or implement your own). But apparently you didn&#039;t understand what I meant by &quot;You don&#039;t need BCD support in hardware&quot;. I can add to that: &quot;You don&#039;t need BCD support in your compiler&quot;. You can build your own library, and in most cases someone has done that for you already.<br /><br /><div class="quote">Fine. The underlying hardware isn&#039;t my problem. But why must we use a seperate .NET library (just another black box) for such calculations? Why is that feature not supported by native C/C++ compilers? Life would be easyer, because BCD math is necessary sometimes. But that&#039;s only my personal point of view; it must not be true. You know, I&#039;m timewarped from the 70s.</div><br /><br />You don&#039;t *have* to use the .NET library...It&#039;s just one of many examples.<br />You said: &quot;By the way, with an assembly language application, you could support BCD, float, double, long double and a lot of other funny formats&quot;.<br />My point was simply that you don&#039;t need assembly for most of these (BCD should NOT be implemented with specific instructions, not even if you are using assembly, just do it the HLL-way), and other &#039;funny formats&#039; are best avoided altogether (such as 80-bit floats).<br /><br /><div class="quote">All together. I&#039;m here to discuss questions and I don&#039;t want a fruitless quarreling that just splitting hairs. I think it&#039;s enough now. I&#039;m not such a guru and your and my time isn&#039;t endless. So, please excuse my marginalia. I won&#039;t do that again with you. ;)</div><br /><br />It&#039;s not my fault that you dive in head-first. You seemed to think you knew everything better. You were pretty arrogant in trying to &#039;correct&#039; others and defending yourself. Look before you leap next time.<br /><br />Oh, and before I forget... Microsoft&#039;s lack of long double support is not laziness, but it is for portability reasons (just like defaulting to double precision with the FPU, for example). 80-bit floats aren&#039;t going to work on non-x86 platforms like Itanium, MIPS, PowerPC , Alpha and ARM... to name but a few platforms on which Windows is or was available.</div>
    <div class="meta">Posted on 2010-08-24 06:09:53 by Scali</div>
   </div>
   <div class="post" id="post-212932">
    <div class="subject"><a href="#post-212932">Re: SSE2 check?</a></div>
    <div class="body"><div class="quote">Yes, I did. What can I say? The informations at the Microsoft website are inconsistent. Are you absolutely sure, that your entry is the right one?</div>Deprecated doesn&#039;t mean &quot;it doesn&#039;t work&quot;, so I see no inconsistency in the documentation (but information *is* scattered somewhat across pages). Deprecated simply means &quot;you shouldn&#039;t be using this&quot; - whether it&#039;s because it will eventually be removed, or because performance is worse than alternatives.<br /><br /><div class="quote">Fine. The underlying hardware isn&#039;t my problem. But why must we use a seperate .NET library (just another black box) for such calculations? Why is that feature not supported by native C/C++ compilers?</div>Because C++ (and especially C) has traditionally come with a very small runtime, so it could easily be ported to other platforms... stuff like threading is only being added to C++ in the upcoming C++0x... but nothing stops you from writing/using a portable or platform-optimized bignum library. And an optimized library definitely wouldn&#039;t use BCD instructions on x86 :)</div>
    <div class="meta">Posted on 2010-08-24 14:06:52 by f0dder</div>
   </div>
   <div class="post" id="post-212934">
    <div class="subject"><a href="#post-212934">Re: SSE2 check?</a></div>
    <div class="body">Scali, Intel Itanium actually supports double-extended precision.</div>
    <div class="meta">Posted on 2010-08-24 17:22:04 by LocoDelAssembly</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=30178&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=30178&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="30178" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=30178&amp;page=2">&gt;</a><a href="../?id=30178&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>