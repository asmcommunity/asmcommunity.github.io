<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>LOCAL variables cause a memory leak ? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=10225" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=10225">LOCAL variables cause a memory leak ?</a></p>
   <div class="post" id="post-76710">
    <div class="subject"><a href="#post-76710">LOCAL variables cause a memory leak ?</a></div>
    <div class="body">(yes,my english is terrible,but i hope,you understand it)<br />hm,i played around with win2k's task-manager and see,that  there is a memory leak in my program (a german-english dictionary *g*) - if i searched for some words,the memory size grows up until 23000 KB  ... i tested my code with memproof, but there were any leaks. Then, i look into my extract_code_part (to extract and filter the words) an there i have had two LOCAL variables<br /><div class="quote"><br />Extr_und_add  proc uses ebx eax edx esi edi ecx lpSource:DWORD, lpPos:DWORD<br />;Gr??en usw<br />MAX_BUFF equ 1024 <br />LEER_ZEICHEN equ 20<br /> <br />LOCAL deutsch_buff<br />LOCAL englisch_buff<br /><br />    mov esi,lpSource<br />    add esi,lpPos<br />...<br /></div> <br /><br />i replaced them to:<br /><div class="quote"><br />Extr_und_add  proc uses ebx eax edx esi edi ecx lpSource:DWORD, lpPos:DWORD<br />;Gr??en usw<br />MAX_BUFF equ 1024 <br />LEER_ZEICHEN equ 20<br /> <br />.data<br /> deutsch_buff   db(MAX_BUFF) dup(0)<br /> englisch_buff  db(MAX_BUFF) dup(0)<br />    <br />.code<br />    mov esi,lpSource<br />    add esi,lpPos<br /><br /></div> <br />and tested with task-manager again<br />now is the memory size about 6500 KB (when i search for something ,else about 400KB).<br />Is it Win2k or a compiler bug?</div>
    <div class="meta">Posted on 2003-01-16 14:20:27 by CDW</div>
   </div>
   <div class="post" id="post-76714">
    <div class="subject"><a href="#post-76714">LOCAL variables cause a memory leak ?</a></div>
    <div class="body">dunno exactly what the problem is, but there's a lot of things to consider.<br />First, the second proc will not be re-entrant/multi-threadable, as it only<br />has one pair of buffers. second, does the program leak more and more<br />when you run the proc multiple times, or is a fixed &quot;leak&quot;?</div>
    <div class="meta">Posted on 2003-01-16 14:37:12 by f0dder</div>
   </div>
   <div class="post" id="post-76717">
    <div class="subject"><a href="#post-76717">LOCAL variables cause a memory leak ?</a></div>
    <div class="body">2. the proc leaks more and more... <br /><br />1. Ok: the searchProc calls the Extr_und_add...<br />SearchProc is a thread, but its a single thread, if the user push the search button again, i first kill this thread :)<br />so it is not multithreadable <br /><pre><code><br /><br /><br />Extr_und_add  proc uses ebx eax edx esi edi ecx lpSource&#58;DWORD, lpPos&#58;DWORD<br />;Gr??en usw<br />MAX_BUFF equ 1024 <br />LEER_ZEICHEN equ 20<br /> <br />.data<br /> deutsch_buff   db&#40;MAX_BUFF&#41; dup&#40;0&#41; ;now i have this<br /> englisch_buff  db&#40;MAX_BUFF&#41; dup&#40;0&#41;<br />  ;old version &#40;with leak in memory&#41;  had  LOCAL<br />    <br />.code<br />    mov esi,lpSource<br />    add esi,lpPos<br />    mov edx,esi ;die momentane position festhalten<br />    mov ah,0Ah  <br />    <br />    ;FILTERN<br />    .if filter.begriff_am_anfang!=0<br />      dec esi<br />    <br />	  .if BYTE PTR&#91;esi&#93;!=0Ah &amp;&amp; BYTE PTR&#91;esi&#93;!=20h<br />	       <br />	      ret<br />	  .endif <br />	  inc esi<br />    .endif    <br />    ;FILTERNENDE<br />     mov ecx,lpSource<br />       SUCHE_ANFANG_LOOP&#58;<br />         cmp ecx,esi<br />         je OUT1	;f?r den unwahrscheinlichen Fall,dass unser Begriff in der<br />         dec esi        ;ersten Zeile steht - damit es keine Speicherverletzung gibt<br />         mov al,BYTE PTR&#91;esi&#93;<br />         cmp al,ah<br />         jne SUCHE_ANFANG_LOOP<br />         sub edx,esi ;wieviele Zeichen unteschied zwischen Wortpos und Anfang?<br />      OUT1&#58;<br />   .if vorherige_zeile==esi<br />   	  ret<br />   .endif<br />   <br />   mov vorherige_zeile,esi<br />   <br />   <br />   <br />   <br />   .if filter.english!=0<br />      lea edi,deutsch_buff<br />      <br />        mov ecx,LEER_ZEICHEN+1<br />        mov al,20h<br />        FILL_LOOP&#58;<br />          dec ecx<br />          mov BYTE PTR&#91;edi+ecx&#93;,al<br />          <br />          jnz FILL_LOOP<br />          add edi,LEER_ZEICHEN<br />          <br />   .else<br />   		  lea edi,deutsch_buff<br />   		  dec edi<br />   .endif<br />   xor ecx,ecx<br />   mov ah,3Ah<br />   <br /><br />   KOPIERE_DEUTSCH_LOOP&#58;<br />      inc ecx<br />      mov al, BYTE PTR&#91;esi+ecx&#93;<br />      cmp ah,al<br />      je VORCHECK<br />      END_CHECK&#58;<br />      mov BYTE PTR&#91;edi+ecx&#93;,al<br />      jmp KOPIERE_DEUTSCH_LOOP<br />  <br />      VORCHECK&#58;<br />       cmp ah,BYTE PTR&#91;esi+ecx+1&#93;<br />       jne END_CHECK<br />        <br />   <br />   <br />   WEITER1&#58;<br />   .if &#40;filter.nur_eine_sprache!=0&#41; <br />   	  .if &#40;filter.english!=0&#41;<br />   	     .if ecx&gt;edx<br />   	        ret  <br />         .endif<br />      .else<br />         .if ecx&lt;edx<br />   	        ret  <br />         .endif<br />      .endif      	   <br />   .endif  <br />   <br />  <br /><br />   <br />    mov BYTE PTR&#91;edi+ecx&#93;,0 ;abschlie?en<br />   inc ecx<br />   add esi,ecx<br />   mov ebx,ecx ;stringl?ngemitz?hlen<br /><br />   .if ebx&gt;zeilen_laenge<br />       mov zeilen_laenge,ebx   <br />    .endif<br /><br />   <br />    .if filter.english==0<br />      lea edi,englisch_buff<br />      <br />        mov ecx,LEER_ZEICHEN+1<br />        mov al,20h<br />        FILL_LOOP2&#58;<br />          dec ecx<br />          mov BYTE PTR&#91;edi+ecx&#93;,al<br />          <br />          jnz FILL_LOOP2<br />          add edi,LEER_ZEICHEN<br />          <br />   .else<br />   		  lea edi,englisch_buff<br />   		  dec edi<br />   .endif<br />   xor ecx,ecx<br />   mov ah,0Ah<br />  <br />   <br />   KOPIERE_ENGLISCH_LOOP&#58;<br />      inc ecx<br />      mov al, BYTE PTR&#91;esi+ecx&#93;<br />      cmp ah,al<br />      je WEITER2<br />      mov BYTE PTR&#91;edi+ecx&#93;,al<br />      jmp KOPIERE_ENGLISCH_LOOP<br />      jmp WEITER2<br />      <br />  <br /><br />      <br />    <br />   WEITER2&#58;<br />     <br /><br />   dec ecx ;&#40;davor ist meits ein 0dh&#41;<br />   mov BYTE PTR&#91;edi+ecx&#93;,0<br /><br />      add ebx,ecx<br />      .if ebx&gt;zeilen_laenge<br />        mov zeilen_laenge,ebx     	<br />      .endif<br />      lea edi, deutsch_buff<br />      lea esi, englisch_buff<br />      .if filter.english!=0<br />      	xchg edi,esi    	<br /><br />      .endif<br />             invoke SendDlgM,ID_AUSGABE_LIST,LB_ADDSTRING,0,edi<br />             invoke SendDlgM,ID_AUSGABE_LIST,LB_ADDSTRING,0,esi        <br />     <br />         inc ergebnisse <br /> <br />	ret<br /><br />Extr_und_add endp<br /><br /><br />SearchProc proc ;its a thread<br />	<br />	mov vorherige_zeile,0<br />	xor ebx,ebx<br />	mov zeilen_laenge,0<br />		SUCH_LOOP&#58;	   	 <br />		invoke BMBinSearch,ebx,pMemory,FileSize,addr ein_buffer,eingabe_laenge<br />	     ;auszug vorbereiten&#40;und auf g?ltigkeit checken!&#41;<br />	    mov ebx,eax<br />	    cmp eax,-1<br />		je EXIT<br />		  <br />		invoke Extr_und_add,pMemory,ebx <br />	    inc ebx<br />	      	   <br />        ;invoke SendDlgM,hWin,ID_AUSGABE_LIST,LB_ADDSTRING,0,ebx 	   <br />        jmp SUCH_LOOP<br />    EXIT&#58;<br />    mov search_flag,0<br />   <br />    xor edx,edx<br />    mov eax,zeilen_laenge<br />    mov ebx,3<br />    mul ebx<br />    add eax,zeilen_laenge<br />          <br />    invoke SendDlgM,ID_AUSGABE_LIST,LB_SETHORIZONTALEXTENT,eax,0 <br />    <br />    invoke SetIcon,search_flag<br />    <br />    invoke wsprintf,addr erg_buffer,addr template_ergebnisse,ergebnisse<br />    invoke SendDlgM,ID_ERGEBNISSE,WM_SETTEXT,0,addr erg_buffer<br />    <br />    invoke ExitThread,0<br />    invoke CloseHandle,hThread<br />   <br />ret<br /><br />SearchProc endp<br /><br /></code></pre> <br /><br /><br />PS: It does not leake now (with this code)</div>
    <div class="meta">Posted on 2003-01-16 14:58:10 by CDW</div>
   </div>
   <div class="post" id="post-76720">
    <div class="subject"><a href="#post-76720">LOCAL variables cause a memory leak ?</a></div>
    <div class="body">CDW,<br /><br />your memory leak does not seem to stem from the use of local or global variables. Instead, it seems to stem from the way you terminate your thread:<br /><pre><code><br />    invoke ExitThread,0<br />    invoke CloseHandle,hThread<br /><br />ret<br /><br />SearchProc endp<br /></code></pre><br />Apparently you try to close the thread handle from within the thread, <strong>after</strong> you have already exited the thread, which is of course impossible. So the handle never gets closed. See the Win32 API help, section &quot;ExitThread&quot;, for the consequences of not closing that handle:<br /><div class="quote">Terminating a thread does not necessarily remove the thread object from the operating system. A thread object is deleted when the last handle to the thread is closed. </div><br />Reversing the order of the calls to ExitThread and CloseHandle should help.<br /><br />Regards, Frank</div>
    <div class="meta">Posted on 2003-01-16 15:28:50 by Frank</div>
   </div>
   <div class="post" id="post-76722">
    <div class="subject"><a href="#post-76722">LOCAL variables cause a memory leak ?</a></div>
    <div class="body">if you exit your thread at the end of the threadproc, just &quot;ret&quot; instead of calling exitthread. also, let the spawning thread do the closehandle.</div>
    <div class="meta">Posted on 2003-01-16 15:34:46 by f0dder</div>
   </div>
   <div class="post" id="post-76858">
    <div class="subject"><a href="#post-76858">LOCAL variables cause a memory leak ?</a></div>
    <div class="body">@fl0dder: you say,i don't need to call &quot;ExitThread&quot;, i should use &quot;ret&quot; ?<br />Frank: it sounds logical - if i don't exit my Thread in a right way, my stack cause this mem leack<br />thx @all...</div>
    <div class="meta">Posted on 2003-01-17 09:51:52 by CDW</div>
   </div>
   <div class="post" id="post-77042">
    <div class="subject"><a href="#post-77042">LOCAL variables cause a memory leak ?</a></div>
    <div class="body">ok, i fixed it - it was not the Thread (a very small leak because of  &quot;ExitThread&quot; and then &quot;CloseHandle&quot;). It was the listbox - i take it out and the runsize is only 5600 KB now (its ok,because i map a 4,76 MB file). thx a lot @all (hm,but what should i use instead of listbox)</div>
    <div class="meta">Posted on 2003-01-18 12:31:28 by CDW</div>
   </div>
  </div>
 </body>
</html>