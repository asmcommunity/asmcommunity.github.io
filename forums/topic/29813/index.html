<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Debugging Old DOS - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29813" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=29813">Debugging Old DOS</a></p>
   <div class="post" id="post-210665">
    <div class="subject"><a href="#post-210665">Debugging Old DOS</a></div>
    <div class="body">To the Ineffable All,<br /><br />I have a old, old DOS 2.0 exe file that I am debugging.&nbsp; Everything goes fine with my DOS debugger (D86), until the it encounters an INT 10, AH=0, AL=10H, <strong>Set Video Mode</strong>.&nbsp; That instruction clears the screen, and leaves the debugger brain dead, with barely enough smarts to process its quit command.&nbsp; In other words, the program while&nbsp; running through the debugger, shoots itself.&nbsp; I suppose I could rig up some kind of dual monitor setup, but that would be a hassle.&nbsp; Anyone know how to make the program run in one window, and the debugger in another?&nbsp; Both the debugger and program have to run in a DOS window on XP.&nbsp; Thanks,&nbsp; Ratch</div>
    <div class="meta">Posted on 2010-02-07 16:21:17 by Ratch</div>
   </div>
   <div class="post" id="post-210667">
    <div class="subject"><a href="#post-210667">Re: Debugging Old DOS</a></div>
    <div class="body">32-bit windows XP <strong>emulates</strong> DOS, including the Set Video Mode function. The exact method of emulation most probably interferes with the debugger. If you want <u>REAL</u> emulation, get the original DOS disks and run boot in Bochs. Only then will you be able to see EXACTLY what is going on.</div>
    <div class="meta">Posted on 2010-02-07 17:27:42 by ti_mo_n</div>
   </div>
   <div class="post" id="post-210686">
    <div class="subject"><a href="#post-210686">Re: Debugging Old DOS</a></div>
    <div class="body">ti-mo-n,<br /><br />&nbsp; &nbsp; Sorry I did not get back to you earlier.&nbsp; I think I know EXACTLY what is going on.&nbsp; The program is wiping the debugger out because they are using the same DOS window, same monitor, and the same video card.&nbsp; So running on a true blue DOS O/S will not help me too much.&nbsp; What I really need is a debugger that keeps its DOS window and the user window separate as far as software and hardware are concerned.&nbsp; I don&#039;t know if that is possible when both the debugger and the program use the same video card, and the user program issues a&nbsp; INT 10, AH=0, AL=10H, <strong>Set Video Mode</strong> that reinitializes the whole display.&nbsp; How do programmers debug programs that utilize video display BIOS interrupts anyway?&nbsp; At least one inquiring mind would like to know.&nbsp; Ratch</div>
    <div class="meta">Posted on 2010-02-08 21:58:35 by Ratch</div>
   </div>
   <div class="post" id="post-210687">
    <div class="subject"><a href="#post-210687">Re: Debugging Old DOS</a></div>
    <div class="body"><strong>Ratch</strong>,<br /><br />Most debuggers use some kind of video mode/buffer swapping to save user screen when debuggee stops and restore it when you choose to run debuggee again. At least AFD and Turbo Debugger do it even in NTVDM. I&#039;ve just checked it for simple mode 10h (640*350*4bpp) &quot;Hello, world!&quot; .Com program.</div>
    <div class="meta">Posted on 2010-02-08 22:54:45 by baldr</div>
   </div>
   <div class="post" id="post-210688">
    <div class="subject"><a href="#post-210688">Re: Debugging Old DOS</a></div>
    <div class="body">baldr,<br /><br />Thanks for your reply.&nbsp; What does AFD and NTVDM mean?&nbsp; Anyway, I tried Borland&#039;s Turbo Debugger.&nbsp; Although it did not crash, it lost its IP value, cleared the user screen, and could not be used for further debugging after a INT 10H, AH=0, AL=10H Set Video Mode instruction.&nbsp; Ratch</div>
    <div class="meta">Posted on 2010-02-09 00:33:03 by Ratch</div>
   </div>
   <div class="post" id="post-210697">
    <div class="subject"><a href="#post-210697">Re: Debugging Old DOS</a></div>
    <div class="body"><strong>Ratch</strong>,<br /><br />AFD stands for Advanced Fullscreen Debug (1987), NTVDM is Windows NT subsystem that runs 16-bit (DOS and Windows) applications.<br /><br />Which version of TD did you use? Mine (3.1) works fine (though I&#039;ve tested only simple program that set video mode 10h, printed &quot;Hello, world!&quot; using 0Eh and set mode back to CO80).</div>
    <div class="meta">Posted on 2010-02-09 02:35:42 by baldr</div>
   </div>
   <div class="post" id="post-210700">
    <div class="subject"><a href="#post-210700">Re: Debugging Old DOS</a></div>
    <div class="body">Considering using an x86 emulator like QEMU or Bochs, and taking advantage of the built-in debugger of those? Since you&#039;ll be doing emulation (rather than NTVDM&#039;s &quot;encapsulation&quot;) you can get a &quot;more true DOS experience&quot;, and the debugging QEMU or Bochs offers is less invasive than running a debugger in the host system.</div>
    <div class="meta">Posted on 2010-02-09 05:01:24 by f0dder</div>
   </div>
   <div class="post" id="post-210704">
    <div class="subject"><a href="#post-210704">Re: Debugging Old DOS</a></div>
    <div class="body">baldr,<br /><br />Thanks for defining the acronyms.&nbsp; I used TD Version 5.0 . So far, all I tried is a DOS box in a cmd DOS window.&nbsp; Perhaps a full DOS machine will produce better results.&nbsp; Ratch</div>
    <div class="meta">Posted on 2010-02-09 10:33:05 by Ratch</div>
   </div>
   <div class="post" id="post-210705">
    <div class="subject"><a href="#post-210705">Re: Debugging Old DOS</a></div>
    <div class="body">f0dder,<br /><br />&nbsp; &nbsp;  Sounds like good advice.&nbsp; I will try to get up to speed on one or both methods.&nbsp; Ratch</div>
    <div class="meta">Posted on 2010-02-09 10:36:32 by Ratch</div>
   </div>
   <div class="post" id="post-210707">
    <div class="subject"><a href="#post-210707">Re: Debugging Old DOS</a></div>
    <div class="body">Fifteen years ago I employeed remote debugging in MS-DOS using Borland TD.EXE and TDREMOTE.EXE for video driver developement. <br />It was fascinating, I could step into INT10h BIOS with F7, watch the CRTC registers being updated step by step and its impact on screen of the second monitor. <br /><br />I&#039;m not sure if this will work with NTVDM, you will need null-modem cable and two DOS computers with serial port.</div>
    <div class="meta">Posted on 2010-02-09 17:40:33 by vit$oft</div>
   </div>
   <div class="post" id="post-210710">
    <div class="subject"><a href="#post-210710">Re: Debugging Old DOS</a></div>
    <div class="body"><strong>vit$oft</strong>,<br /><br />TD employs smart screen swapping scheme, it almost survived mode-X (320*240*8bpp). Borland was one great SW company once upon a time.</div>
    <div class="meta">Posted on 2010-02-09 18:30:13 by baldr</div>
   </div>
   <div class="post" id="post-210717">
    <div class="subject"><a href="#post-210717">Re: Debugging Old DOS</a></div>
    <div class="body"><strong>Ratch</strong>: one thing, though - last time I used the built-in debuggers for Bochs and QEMU, they were at about the level of user-friendliness as GDB... apparently there&#039;s a &quot;new and friendly debugger GUI&quot; (or several ones, looking at osdev.org threads), but I dunno if any have been merged into the mainline bochs distribution... the default version compiled for win32 is <strong>very</strong> basic, not eving having SMP or VMX enabled.<br /><br /><strong>EDIT:</strong> my bad, a graphical debugger <strong>is</strong> included with the default win32 distribution, you just have to enable it by copying <strong>bochsrc-sample.txt</strong> to <strong>bochsrc</strong> and &quot;set stuff up&quot; :)</div>
    <div class="meta">Posted on 2010-02-09 21:46:44 by f0dder</div>
   </div>
  </div>
 </body>
</html>