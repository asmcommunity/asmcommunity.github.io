<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>ForEachFileIn &quot;D:\folder1&quot;, ... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=14759" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=14759">ForEachFileIn &quot;D:\folder1&quot;, ...</a></p>
   <div class="post" id="post-114421">
    <div class="subject"><a href="#post-114421">ForEachFileIn &quot;D:\folder1&quot;, ...</a></div>
    <div class="body">It is not too rare for me to have to do some action on all files in a folder (and in all subfolders). Usually it's to set or remove the archive attribute. This is what I created:<br /><pre><code><br />memmove proc uses ecx esi edi Desty,Source,ln<br />     cld<br />    mov esi, Source<br />    mov edi, Desty<br />    mov ecx, ln<br /><br />    shr ecx, 2<br />    rep movsd<br /><br />    mov ecx, ln<br />    and ecx, 3<br />    rep movsb<br />   ret<br />memmove endp	<br />	<br />EnumerateSubfiles proc uses eax ebx ecx edx RootDir<br />	local strSize,hFind<br />	local DaString&#91;256&#93;&#58;BYTE<br />	local fd&#58;WIN32_FIND_DATA<br />	<br />	invoke lstrlen,RootDir<br />	.if !eax<br />	 jmp _ret<br />	.endif<br />	.if eax&gt;255<br />	mov eax,255<br />	.endif<br />	mov strSize,eax<br />	inc eax<br />	invoke memmove,addr DaString,RootDir,eax<br />	invoke lstrcat,addr DaString,CTEXT&#40;&quot;\*.*&quot;&#41;<br />	invoke FindFirstFile,addr DaString,addr fd<br />	mov hFind,eax<br />	.if eax==INVALID_HANDLE_VALUE<br />	 jmp _ret<br />	.endif<br />_morer&#58;<br />	<br />	invoke lstrcpy,addr DaString,RootDir<br />	invoke lstrcat,addr DaString,CTEXT&#40;&quot;\&quot;&#41;<br />	invoke lstrcat,addr DaString,addr fd.cFileName<br />	lea eax,fd.cFileName<br />	mov ax,&#91;eax&#93;<br />	.if ax!=02Eh &amp;&amp; ax !=02e2eh<br />	mov eax,fd.dwFileAttributes<br />	.if eax &amp; FILE_ATTRIBUTE_DIRECTORY<br />	invoke EnumerateSubfiles,addr DaString<br />	.else<br />	<br />	;----&#91; Do action with that file &#93;-------------------------------\<br />	<br />	invoke SetFileAttributes,addr DaString,FILE_ATTRIBUTE_NORMAL<br />	<br />	;---------------------------------------------------------------/<br />	.endif<br />	.endif<br />	<br />	invoke FindNextFile,hFind,addr fd<br />	.if eax<br />	jmp _morer<br />	.endif<br />	invoke FindClose,hFind<br />	<br /> _ret&#58;	ret<br />	ret<br />EnumerateSubfiles endp<br /></code></pre><br /><br />Usage: <br />invoke EnumerateSubfiles,CTEXT(&quot;D:\folder1&quot;)<br /><br />I created this function for the refill packer for my proggie 'Dreamer' :grin: .<br />I thought about making it as a macro, that will do this:<br />ForEachFileIn &quot;D:\folder1&quot;, invoke SetFileAttributes,addr DaString,FILE_ATTRIBUTE_NORMAL<br /><br />but I'll have to study the @strcat for macros and find a way to make unique procs or global labels. <br />I'll try to do that later</div>
    <div class="meta">Posted on 2003-08-19 10:51:04 by Ultrano</div>
   </div>
   <div class="post" id="post-114614">
    <div class="subject"><a href="#post-114614">ForEachFileIn &quot;D:\folder1&quot;, ...</a></div>
    <div class="body">attrib -a *.* /s :grin:</div>
    <div class="meta">Posted on 2003-08-20 15:15:00 by Nebob</div>
   </div>
   <div class="post" id="post-115963">
    <div class="subject"><a href="#post-115963">Re: ForEachFileIn &quot;D:\folder1&quot;, ...</a></div>
    <div class="body"><div class="quote"><br />Usage: <br />invoke EnumerateSubfiles,CTEXT(&quot;D:\folder1&quot;)<br /><br />I created this function for the refill packer for my proggie 'Dreamer' :grin: .<br />I thought about making it as a macro, that will do this:<br />ForEachFileIn &quot;D:\folder1&quot;, invoke SetFileAttributes,addr DaString,FILE_ATTRIBUTE_NORMAL<br /><br />but I'll have to study the @strcat for macros and find a way to make unique procs or global labels. <br />I'll try to do that later</div><br /><br />You might want to take a look at &quot;iterators&quot; in HLA (the High Level Assembler) and their implementation in MASM (IIRC, I've got a discussion of iterators in the 16-bit edition of &quot;The Art of Assembly Language Programming&quot;). Iterators and the corresponding &quot;foreach&quot; loop are exactly what you're looking for.<br /><br />Here's what a &quot;foreach&quot; loop would look like in a typical HLA program that processes all the files in a directory, given a regular expression:<br /><br /><pre><code><br />    foreach FileInList&#40; &quot;*.*&quot; &#41; do<br />    <br />        stdout.put&#40; &quot;file&#58; &quot;, &#40;type string eax&#41;, nl &#41;;<br />        <br />    endfor; <br /></code></pre><br /><br />It's easy enough to write macros in MASM to simulate the FOREACH and ENDFOR statements, assuming you don't need to have nested FOREACH loops (if you do, it's still possible in MASM, just a lot more work).<br /><br />I've attached a sample HLA application that provides a &quot;FileInList&quot; iterator along with a short main program that demonstrates calls to this iterator (via a &quot;FOREACH&quot; loop). Again, &quot;The Art of Assembly Language Programming&quot; (16-bit edition) on Webster (<a target="_blank" href="http://webster.cs.ucr.edu">http://webster.cs.ucr.edu</a>) will tell you how to implement iterators, the foreach loop, and the &quot;yield&quot; statement in MASM.<br />Cheers,<br />Randy Hyde<br /><br /><br /><br /><br /><pre><code><br />// HLA Demonstration program.<br />//<br />// This short program demonstrates two things&#58;<br />//<br />//  &#40;1&#41; How to call the Windows &quot;FindFirstFile&quot;,<br />//      &quot;FindNextFile&quot;, and &quot;FindClose&quot; routines<br />//      to process filenames, possibly containing<br />//      wildcard characters.<br />//<br />//  &#40;2&#41; The use of HLA iterators to process<br />//      iterative objects &#40;e.g., a file name list&#41;.<br />//<br />//  Randall Hyde<br />//  10/7/99<br /><br /><br />program FindFirstDemo;<br />#include&#40; &quot;stdlib.hhf&quot; &#41;<br />#include&#40; &quot;w.hhf&quot; &#41;<br /><br />type<br />        FileTime&#58;<br />            record<br />            <br />                LowDateTime&#58; dword;<br />                HighDateTime&#58;dword;<br />                <br />            endrecord;<br /><br />    Win32FindData&#58;<br />        record<br /><br />            FileAttributes&#58; dword; <br />            CreationTime&#58;   FileTime; <br />            LastAccessTime&#58; FileTime; <br />            LastWriteTime&#58;  FileTime; <br />            FileSizeHigh&#58;   dword; <br />            FileSizeLow&#58;    dword; <br />            Reserved0&#58;      dword; <br />            dwReserved1&#58;    dword; <br />            FileName&#58;       char&#91; 260 &#93;; <br />            AlternateFileName&#58; char&#91; 14 &#93;; <br />            <br />        endrecord;<br /><br /><br /><br /><br />    // External declarations for Windows API calls&#58;<br /><br />    procedure FindFirstFile&#40; var WFD&#58;Win32FindData; FileName&#58;string &#41;;<br />        returns&#40; &quot;eax&quot; &#41;; // File Handle.<br />        external&#40; &quot;_FindFirstFileA@8&quot; &#41;;<br />    <br />    procedure FindNextFile&#40; var WFD&#58;Win32FindData; handle&#58;dword &#41;;<br />        returns&#40; &quot;al&quot; &#41;; // Boolean result, true=got a file.<br />        external&#40; &quot;_FindNextFileA@8&quot; &#41;;<br />        <br />    procedure FindClose&#40; handle&#58;dword &#41;;<br />        external&#40; &quot;_FindClose@4&quot; &#41;;<br />        <br /><br />    // These macros preserve registers that might get tweaked<br />    // by Windows API calls.<br />    <br />    #macro pusha2;<br />        push&#40; ebx &#41;;<br />        push&#40; ecx &#41;;<br />        push&#40; edx &#41;;<br />        push&#40; esi &#41;;<br />        push&#40; edi &#41;;<br />    #endmacro;<br />    <br />    #macro popa2;<br />        pop&#40; edi &#41;;<br />        pop&#40; esi &#41;;<br />        pop&#40; edx &#41;;<br />        pop&#40; ecx &#41;;<br />        pop&#40; ebx &#41;;<br />    #endmacro;<br /><br /><br />    // The following iterator returns a string &#40;in EAX&#41; that corresponds<br />    // to a filename.  The parameter passed to this iterator is a filename,<br />    // one that typically contains wildcard characters &#40;i.e., &quot;*&quot; and &quot;?&quot; &#41;.<br />    // This iterator returns a list of filenames that match the, possibly<br />    // ambiguous, filename passed as a parameter.  This iterator fails<br />    // when there are no more matching filenames.<br />    <br />    iterator FileInList&#40; FileList&#58;string &#41;; @nodisplay;<br />    var<br />        handle&#58;     dword;<br />        FileData&#58;   Win32FindData;<br />        <br />    begin FileInList;<br />    <br />        // Find the first matching file &#40;if one exists&#41;.<br />        // Save the handle for use by FindNextFile.<br />        <br />        pusha2;<br />        FindFirstFile&#40; FileData, FileList &#41;;<br />        popa2;<br />        mov&#40; eax, handle &#41;;<br />        <br />        // If we matched at least one filename, return<br />        // the corresponding string and call the<br />        // FindNextFile routine to match any additional<br />        // filenames.<br />        <br />        if&#40; eax &lt;&gt; w.INVALID_HANDLE_VALUE &#41; then<br />        <br />            repeat<br />            <br />                // FindFirstFile &amp; FindNextFile return<br />                // zero-terminated strings.  Convert these<br />                // to HLA compatible strings and return<br />                // the converted string&#58;<br />                <br />                conv.a_cStrToStr&#40; FileData.FileName &#41;;<br />                <br />                // Return the converted string to the FOREACH<br />                // loop and then free the storage associated<br />                // with the string.<br />                <br />                push&#40; eax &#41;;    // Save, so we can free string on return<br />                yield&#40;&#41;;        // Return string to FOREACH loop.<br />                pop&#40; eax &#41;;     // Free the storage used by the string.<br />                strfree&#40; eax &#41;;<br />            <br />                // Get the next filename in the list&#58;<br />                <br />                pusha2; <br />                FindNextFile&#40; FileData, handle &#41;;<br />                popa2;<br />                <br />            until&#40; al = false &#41;;<br />            <br />            // When we've processed all the filenames in the list,<br />            // call FindClose to free the handle and other resources.<br />            <br />            pusha2;<br />            FindClose&#40; handle &#41;;<br />            popa2;<br />            <br />        endif;<br />    <br />    end FileInList;<br />    <br />    <br />    <br />    <br />    <br />var<br />    FindData&#58; Win32FindData; <br />    <br />begin FindFirstDemo;<br /><br />    // Simple foreach loop that demonstrates the FileInList iterator<br />    // by printing out all the filenames in the current directory.<br />    <br />    stdout.put&#40; &quot;FindFirst Demo&#58;&quot;, nl, nl &#41;;<br />    foreach FileInList&#40; &quot;*.*&quot; &#41; do<br />    <br />        stdout.put&#40; &quot;file&#58; &quot;, &#40;type string eax&#41;, nl &#41;;<br />        <br />    endfor; <br />    <br />end FindFirstDemo;<br /></code></pre></div>
    <div class="meta">Posted on 2003-08-28 10:08:03 by rhyde</div>
   </div>
  </div>
 </body>
</html>