<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Coinvoke vs mcall - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=2860" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=116">Windows</a> &raquo; <a href="../?id=2860">Coinvoke vs mcall</a></p>
   <div class="post" id="post-18378">
    <div class="subject"><a href="#post-18378">Coinvoke vs mcall</a></div>
    <div class="body">So I've been wondering this for a while -- What is the difference between coinvoke and mcall... and why have 2 different macros to do the same thing (how many different ways are their to call a virtual function)?  And since directx and example of COM how come I still don't understand this any better? ERNIE!!!! :) :)<br /><br />And since Caleb uses coinvoke and Scronty uses mcall I was wondering how hard is it to convert one from the other?<br /><br />using coinvoke (Caleb)<br /><pre><code><br />                mov	g_pD3D, eax<br />                mov	edi, eax<br /><br />                ; *** Get infos about the default adapter ***<br /><br />                lea	ecx, d3ddm &#91;esp&#93;<br />                coinvoke edi, IDirect3D8, GetAdapterDisplayMode, \<br />D3DADAPTER_DEFAULT, ecx<br /><br /></code></pre><br /><br />or mcall (Scronty)<br /><br /><pre><code><br />    mov g_pD3D, eax<br /><br />;   Get the current desktop display mode<br />    mcall &#91;g_pD3D&#93;,IDirect3D8_GetAdapterDisplayMode, \<br />D3DADAPTER_DEFAULT,ADDR d3ddm<br /><br /></code></pre></div>
    <div class="meta">Posted on 2002-01-09 14:59:22 by Sliver</div>
   </div>
   <div class="post" id="post-18388">
    <div class="subject"><a href="#post-18388">Coinvoke vs mcall</a></div>
    <div class="body">Hi sliver !<br /><br />I had begun with the includes from Sergey Chaban and he uses mcall. After I had released my first attempts of DirectX8-Includes =CC=Ambush asked me if I could make it coincoke-compatibilty. At this time I never have known something about coinvoke (I'm not a COM-specialist at all). At first I thought it would be easy to make both compatible but after studing the way interfaces are defined by coinvoke, I gave that up. But I like the way methods are defined by the coinvoke-compatible macros and to me seems the way mcall is hacked suspecious (for example the org $-2 directive) so I decide to  support coinvoke only. <br /><br />This is how interfaces are declared for coinvoke-usage:<br /><pre><code><br /><br />comethod1Proto  typedef       proto &#58; DWORD<br />comethod1           typedef ptr comethod1Proto<br />    .<br />    &#58;<br /><br />_vtIUnknown MACRO CastName&#58;REQ<br />    ; IUnknown methods<br />    &amp;CastName&amp;_QueryInterface comethod3 ?<br />    &amp;CastName&amp;_AddRef comethod1 ?<br />    &amp;CastName&amp;_Release comethod1 ?<br />ENDM<br /><br />IUnknown                        STRUCT<br />    _vtIUnknown IUnknown<br />IUnknown                        ENDS<br /></code></pre><br /><br />And this is the mcall version:<br /><br /><pre><code><br />DECLARE_INTERFACE MACRO ifacename<br /> ifacename typedef DWORD<br /> CurrInterfaceName TEXTEQU &lt;ifacename&gt;<br /> ifaceMethodVirtualOffset=0<br />ENDM<br /><br /><br />STDMETHOD MACRO MethodName&#58;REQ,Args&#58;VARARG<br /> CurrMethodName CATSTR  CurrInterfaceName,&lt;MethodName&gt;<br /> CurrMethodProto CATSTR CurrMethodName,&lt;Proto&gt;<br /> CurrMethodProto typedef PROTO Args<br /> CurrMethodName = ifaceMethodVirtualOffset<br /> ;* Advance to the next position in vtable<br /> ifaceMethodVirtualOffset=ifaceMethodVirtualOffset<br />    +sizeof&#40;LPVOID&#41;<br /> ;;%ECHO &amp;CurrMethodName<br />ENDM<br /><br />; Define IUnknown interface, which is common for all objects<br />DECLARE_INTERFACE &lt;IUnknown_&gt;<br />;  /*** IUnknown methods ***/<br />    STDMETHOD &lt;QueryInterface&gt;,&#58;PTR,&#58;PTR PTR<br />    STDMETHOD &lt;AddRef&gt;<br />    STDMETHOD &lt;Release&gt;<br /><br /></code></pre><br /><br />So with the first version it's easier to make extended instances (I hope this is the right word !) of existing interfaces because they are fully implemented as macros<br /><br />The way methods are called by coinvoke is <br /><br /><pre><code><br />coinvoke MACRO pInterface&#58;REQ, Interface&#58;REQ, Function&#58;REQ, args&#58;VARARG<br />    .<br />    &#58;<br />    istatement CATSTR &lt;invoke &#40;Interface PTR&#91;edx&#93;&#41;.<br />        &amp;Interface&gt;,&lt;_&gt;, &lt;&amp;Function, pInterface&gt;<br />    IFNB &lt;args&gt;     ;; add the list of parameter if any<br />        istatement CATSTR istatement, &lt;, &gt;, &lt;&amp;args&gt; <br />    ENDIF <br />    mov edx, pInterface<br />    mov edx, &#91;edx&#93;<br />    istatement<br /></code></pre><br /><br />and the one called by mcall is<br /><br /><pre><code><br />mcall MACRO ObjPtr&#58;REQ,MethodName&#58;REQ,Args&#58;VARARG<br />CurrMethodProto CATSTR &lt;MethodName&gt;,&lt;Proto&gt;<br />    .<br />    &#58;<br />  invoke CurrMethodProto ptr &#91;eax&#93;,Args<br />   ORG $-2<br />   nop<br />   nop<br />   mov eax,ObjPtr<br />   push eax       ; this<br />   mov eax,&#91;eax&#93;  ; vtable*<br />   call dword ptr &#91;eax+MethodName&#93;<br /></code></pre><br /><br />The last lines are really a damned hack and not fine at all. Coinvoke instead is well declared which makes my decision easier.<br /><br />The disadvantage of COINVOKE is the usage of the edx-register so you can't store local data in while calling a method. You can't change it to EAX because if you use byte or word parameters then they will be stored in AL / AX first and then pushed onto the stack. (Personally I prefer to load the object-ptr into EDI and then to call the interface-methods direct ...)<br /><br />I don't know if this helps you answering your question ... but I hope for most people my decision is in friendly terms with.<br /><br />Greetings, CALEB</div>
    <div class="meta">Posted on 2002-01-09 16:15:28 by Caleb</div>
   </div>
   <div class="post" id="post-18396">
    <div class="subject"><a href="#post-18396">Coinvoke vs mcall</a></div>
    <div class="body">Afternoon, Sliver.<br /><br />Even though you're talking about DX examples, this is actually a COM related issue. heh - or even a Crusades topic.:grin: <br /><br />heh. NaN's already queried about this:<br /><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=1282&amp;highlight=mcall">http://www.asmcommunity.net/board/index.php?topic=1282&amp;highlight=mcall</a> <br /><br />Except for the macros themselves, the main difference (for me) is that the mcall macro from Bizzare Creations is free - no licence necessary for building a commercial app.<br />Otherwise, Ernie's COM stuff is well documented, and used by more people here.<br /><br />The *only* reason I use mcall, is because I started mucking about with win32asm DX from the Bizzare Creations' example.<br />At the time, there were about a dozen DX examples in assembly out there on the web(at least - ones that I knew about), and *each* one had their own way of implementing the calls.<br /><br />Since I was just starting out with the win32asm stuff, I chose to use the code which was easiest(for me) to read. That ended up being the DX example of Sergeys'.<br /><br />Now, as to converting from one to another:<br />heh. Are you talking about the calls, themselves,... or the include files?<br />As you can see from the code you posted, it'd be *very* easy to change from one call-type to the other. Just make sure you use the correct include files - they're slightly different.<br /><br />Then, again. I'm sure the COM fellas will have something to say about that.:tongue: <br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2002-01-09 16:50:49 by Scronty</div>
   </div>
   <div class="post" id="post-18525">
    <div class="subject"><a href="#post-18525">Re: moved</a></div>
    <div class="body">Afternoon, All.<br /><br />This topic was originally posted in the Game Programming forum. <br /><br />I've shifted it here so that the COM lurkers would be able to supply a more accurate picture of the pros/cons between the two calling methods.<br /><br />I've also kept a link to this topic in the Game Programming forum - as any answers would be directly related to anyone interested in programming with DX.<br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2002-01-10 08:10:49 by Scronty</div>
   </div>
   <div class="post" id="post-18602">
    <div class="subject"><a href="#post-18602">Coinvoke vs mcall</a></div>
    <div class="body">Wow, a lot has gone on here today I see.<br /><br />Well, which is better? The one you prefer. It's like Coke or Pepsi.<br /><br />coinvoke has the advantage of a kind of &quot;interface inheritance&quot; (that's the term Caleb was searching for), allowing interfaces to build on each other, for those who don't like typing &quot;QueryInterface, AddRef, Release&quot; over an over. <br /><br />There are also some other subtle things going on with coinvoke, such as it decorates member method names (the procs) in a simple repeatable way (i.e., interface name, underscore, method name) so polymorphic methods (i.e., those with same names) will not conflict with each other. <br /><br />A parameter count is also declared in the proto, so when ultimately the invoke macro is used the compiler does some checking for you to make sure you're not going to cause a stack crash.<br /><br />coinvoke did not spring from some well of knowledge by itself. Bill T's original work in COM started the inspiration. Then I started WORKING in COM, both using COM to so some simple things, and the building CoLib itself. <br /><br />The mcall came from roots I can only guess at, and my guess would be a developer needing an asm call to a COM interface, but not someone who cared for COM itself. So once he got something that worked, he kept it. It may not be pretty (my esthetic sense rebels at &quot;ORG $-2&quot;) but when you get down to it, it works, it works well, and for some may even be more efficient then coinvoke, as it preserves more of the registers for other uses.<br /><br />Additionally, the STDMETHOD macro in the interface definitions will allow a symbolic debugger to take your symbol list and actually keep on tracing code to the COM method. (At least I think so, people have bitched to me coinvoke/CoLib does not do this, and since I've never used a symbolic debugger I'm forced to agree).<br /><br />So WHY will they both work? Let's begin with objects 101:<br /><br />An object is a run-time allocated section of memory. When you get an object, you get the address of some portion of it. In most OOP methodologies, this address holds another address, that being the starting address of a table of methods.<br /><br />Again, slowly, from the other direction. You define several procedures, then make a table to point to them. The table may look like so (for a COM thing):<br /><br /><pre><code><br />FunctionPointers          DWORD       OFFSET   QueryInterface<br />                          DWORD       OFFSET   AddRef<br />                          DWORD       OFFSET   Release<br />                          DWORD       OFFSET   MyFirstMethod<br />                          DWORD       OFFSET   MyOtherMethod<br /></code></pre><br /><br />Then I'll declare this is the INTERFACE to my object. Someplace else in my code I'll call some object creation method. This method will so several things, first being to alloc some memory. The next thing it will do is place the address FunctionPointers into this alloced blob. Finally, the create method hands me back the address (call it pObject) of the alloced memory.<br /><br />Knowing this should make clearer how and why COM (or OOP in general) methods are called. We have our object address, or pointer. If we Get the contents of this pointer (deference it), we get another pointer, that of the function table. So if we add the number of the function we wish to call (times 4 for dwords, of course), then get the contents (deference once more), we finally arrive at the address of the method we originally wanted to perform.<br /><br />In code, these steps are simple:<br /><br /><pre><code><br />    mov eax, pObject    ; get the address of the alloced object<br />                        ;  this pointer to the pointer to the function table<br />    mov eax, &#91;eax&#93;      ; now we have a pointer to the function table itself<br />    call &#91;eax, method_offset&#93;   ; do that method!<br /></code></pre><br /><br />You add method_offset to eax to call each method, ie, add zero for QueryInterface, add 4 for AddRef, add 12 for MyFirstMethod, and so on.<br /><br />They code lines may even look familiar, as both coinvoke and mcall do these three steps as a finally. OK, these macros are a bit more complex because they also allow PARAMETERS to be sent, but hopefully you see the point.<br /><br />I must also note something else here, and that is the address of the object (or pObject here) is always passed to the method. It needs to be there so the object code knows WHICH object it is working with. Inside the object code, pObject is known as &quot;this,&quot; as in &quot;we are working with this object.&quot;<br /><br /><br />If you wish to write your own OOP implementation, you have a blank sheet of paper to use, and may arrange items more to your liking, such as always passing this in a register.<br /><br />However, the rules are much stricter with COM, all parameters must be passed on the stack, because in COM you can't assume the object you are calling is residing in the calling process. It may even be on another machine. So to perform this &quot;magic&quot; transformation, COM asks you put your parameters in memory (on the stack) so it knows where to find them easily.<br /><br /><br />Thus endth the lesson.</div>
    <div class="meta">Posted on 2002-01-10 22:28:04 by Ernie</div>
   </div>
   <div class="post" id="post-18604">
    <div class="subject"><a href="#post-18604">Coinvoke vs mcall</a></div>
    <div class="body">If your not going to use the COM stuff, I would think it'd be best to strip the whole interface down to a single equate for each object and a macro.  The equate would be a two dimentional array: each function would have a name and a count for the number of parameters passed to it.  Could program in error checking and such into the macro.  Of course, this defeats the whole purpose of COM, but the macro could host all sorts of warts and knobs that some programers seem to run screeming from.  <strong>mcall</strong> lands somewhere in between and that is why I don't like it.</div>
    <div class="meta">Posted on 2002-01-10 23:37:04 by bitRAKE</div>
   </div>
  </div>
 </body>
</html>