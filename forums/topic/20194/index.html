<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>[Screenshot, capture] Number 2 : in a loop. - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20194" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=20194">[Screenshot, capture] Number 2 : in a loop.</a></p>
   <div class="post" id="post-154660">
    <div class="subject"><a href="#post-154660">[Screenshot, capture] Number 2 : in a loop.</a></div>
    <div class="body">Hi all, that's me again... :) <br /><br />So I looked at the 2 codes that you gave me in this topic : http://www.asmcommunity.net/board/viewtopic.php?p=154602#154602<br /><br />Finally I chose the code wih CapScreen because it allows me to don't use the clipboard. But I have a problem with this code, that's when I put it in a loop :<br /><br />Here the code I would like to run :<br /><pre><code>.386<br />.model flat, stdcall<br />option casemap &#58;none<br /><br />; INCLUDES ET BIBLIOTHEQUES &#40;LIBRAIRIES&#41;<br />include \masm32\include\windows.inc<br />include \masm32\include\user32.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\shell32.inc<br />include \masm32\include\advapi32.inc<br />include \masm32\include\gdi32.inc<br />include \masm32\include\comctl32.inc<br />include \masm32\include\comdlg32.inc<br />include \masm32\include\masm32.inc<br /><br />includelib \masm32\lib\user32.lib<br />includelib \masm32\lib\kernel32.lib<br />includelib \masm32\lib\shell32.lib<br />includelib \masm32\lib\advapi32.lib<br />includelib \masm32\lib\gdi32.lib<br />includelib \masm32\lib\comctl32.lib<br />includelib \masm32\lib\comdlg32.lib<br />includelib \masm32\lib\masm32.lib<br /><br />include \masm32\macros\macros.asm<br /><br />CapScreen PROTO &#58;DWORD<br /><br />.data<br />	NomBMP		DB &quot;CaptureBitmap.bmp&quot;,0<br />szDisplay     db &quot;DISPLAY&quot;,0<br />szNoDC        db &quot;Couldn''t create DC.&quot;,0<br />szNoMemDC     db &quot;Couldn''t create compatible DC.&quot;,0<br />szNoBMP       db &quot;Couldn''t create compatible bitmap.&quot;,0<br />szNoObj       db &quot;Couldn''t select bitmap.&quot;,0<br />szNoCopy      db &quot;Couldn''t copy bitmap.&quot;,0<br />szNoFile      db &quot;Couldn''t write file to disk.&quot;,0<br />szDone        db &quot;Bitmap created.&quot;,0<br /><br />.code<br />start&#58;<br />@Timer&#58;<br /><br />	invoke CapScreen, addr NomBMP<br />	<br />    CapScreen Proc lpFileName&#58;DWORD<br />	LOCAL hdc&#58;HDC<br />	LOCAL memdc&#58;HDC<br />	LOCAL dwBytes&#58;DWORD<br />	LOCAL bitmapfileheader&#58;BITMAPFILEHEADER<br />	LOCAL bitmapinfoheader&#58;BITMAPINFOHEADER<br />	LOCAL hFile&#58;HANDLE<br />	LOCAL colors&#91;256&#93;&#58;RGBQUAD<br />	LOCAL bmpinfo&#58;BITMAPINFO<br />	LOCAL hBitmap&#58;HBITMAP<br />	LOCAL pBits&#58;DWORD<br />	LOCAL dwWidth&#58;DWORD<br />	LOCAL dwHeight&#58;DWORD<br />	LOCAL dwNumColors&#58;DWORD<br />	LOCAL dwBPP&#58;DWORD<br />	LOCAL ColorSize&#58;DWORD<br /><br />		invoke CreateDC, addr szDisplay, NULL, NULL, NULL		; On cr?e le DC<br />		mov hdc,eax							; On met le handle du DC dans hdc<br />		.IF &#40;eax==NULL&#41;							; Si le handle du DC = 0<br />			invoke MessageBox, 0, addr szNoDC, NULL, 0		; alors &#58; &quot;Couldn''t create DC&quot;<br />			jmp ExitFunc						; On quitte Capscreen.<br />		.ENDIF<br /><br />		invoke GetDeviceCaps, hdc, HORZRES		; On met la largeur du DC<br />		mov dwWidth,eax					; dans dwwidth<br />		invoke GetDeviceCaps, hdc, VERTRES		; et la hauteur du DC<br />		mov dwHeight,eax				; dans dwheight.<br /><br />		invoke GetDeviceCaps, hdc, BITSPIXEL<br />		mov dwBPP,24		;24 Bit for LWF/JPEG/JPEG2000 output, else doesnt work<br />		.IF &#40;eax&lt;=8&#41;<br />			invoke GetDeviceCaps, hdc, NUMCOLORS<br />			mov dwNumColors,eax<br />			mov dwNumColors,256	;this one looks bad<br />		.ELSE<br />			mov dwNumColors,0<br />		.ENDIF<br /><br />            invoke CreateCompatibleDC, hdc				; On cr?e un DC compatible depuis le handle du DC<br />            mov memdc,eax						; On met le handle du DC compatible dans memdc<br />            .IF &#40;eax==NULL&#41;						; Si le handle du DC compatible = 0<br />                invoke DeleteDC, hdc					; alors on detruit le DC,<br />                invoke MessageBox, 0, addr szNoMemDC, NULL, 0		; Et on affiche &#58; &quot;Couldn''t create compatible DC.&quot;<br />                jmp ExitFunc						; On quitte CapScreen.<br />            .ENDIF<br /><br />            mov bmpinfo.bmiHeader.biSize,sizeof BITMAPINFOHEADER<br />            mov eax,dwWidth<br />            mov bmpinfo.bmiHeader.biWidth,eax<br />            mov eax,dwHeight<br />            mov bmpinfo.bmiHeader.biHeight,eax<br />            mov bmpinfo.bmiHeader.biPlanes,1<br />            mov ax,word ptr &#91;dwBPP&#93;<br />            mov bmpinfo.bmiHeader.biBitCount,ax<br />            mov bmpinfo.bmiHeader.biCompression,BI_RGB	;BI_RGB<br />            mov bmpinfo.bmiHeader.biSizeImage,0<br />            mov bmpinfo.bmiHeader.biXPelsPerMeter,0<br />            mov bmpinfo.bmiHeader.biYPelsPerMeter,0<br />            mov eax,dwNumColors<br />            mov bmpinfo.bmiHeader.biClrUsed,eax<br />            mov bmpinfo.bmiHeader.biClrImportant,eax<br />            invoke CreateDIBSection,hdc,addr bmpinfo, DIB_PAL_COLORS,addr pBits, NULL, 0<br />            mov hBitmap,eax<br /><br />            .IF &#40;eax==NULL&#41;<br />                invoke DeleteDC, hdc<br />                invoke DeleteDC, memdc<br />                invoke MessageBox, 0, addr szNoBMP, NULL, 0<br />                jmp ExitFunc<br />            .ENDIF<br /><br />            invoke SelectObject, memdc, hBitmap<br />            .IF &#40;eax==NULL&#41; || &#40;eax==GDI_ERROR&#41;<br />                invoke DeleteDC, hdc<br />                invoke DeleteDC, memdc<br />                invoke MessageBox, 0, addr szNoObj, NULL, 0<br />                jmp ExitFunc<br />            .ENDIF<br /><br />            invoke BitBlt, memdc, 0,0, dwWidth, dwHeight, hdc, 0,0, SRCCOPY	;SRCCOPY<br />            .IF &#40;!eax&#41;<br />                invoke DeleteDC, hdc<br />                invoke DeleteDC, memdc<br />                invoke MessageBox, 0, addr szNoCopy, NULL, 0<br />                jmp ExitFunc<br />            .ENDIF<br /><br />            mov eax,dwNumColors<br />            .IF &#40;eax!=0&#41;<br />                invoke GetDIBColorTable, memdc, 0, dwNumColors, addr colors<br />                mov dwNumColors,eax<br />            .ENDIF<br /><br />            mov bitmapfileheader.bfType,4D42h	;BM<br />            mov eax,dwNumColors<br />            xor edx,edx<br />            mov ecx,sizeof RGBQUAD<br />            mul ecx<br />            mov ColorSize,eax<br />            mov eax,dwWidth<br />            xor edx,edx<br />            mov ecx,dwHeight<br />            mul ecx<br />            xor edx,edx<br />            mov ecx,dwBPP<br />            mul ecx<br />            shr eax,3<br />            add eax,ColorSize<br />            add eax,sizeof BITMAPFILEHEADER<br />            add eax,sizeof BITMAPINFOHEADER<br />            mov bitmapfileheader.bfSize,eax<br />            mov bitmapfileheader.bfReserved1,0<br />            mov bitmapfileheader.bfReserved2,0<br />            mov eax,ColorSize<br />            add eax,sizeof BITMAPFILEHEADER<br />            add eax,sizeof BITMAPINFOHEADER<br />            mov bitmapfileheader.bfOffBits,eax<br />            mov bitmapinfoheader.biSize,sizeof BITMAPINFOHEADER<br />            mov eax,dwWidth<br />            mov bitmapinfoheader.biWidth,eax<br />            mov eax,dwHeight<br />            mov bitmapinfoheader.biHeight,eax<br />            mov bitmapinfoheader.biPlanes,1<br />            mov ax,word ptr &#91;dwBPP&#93;<br />            mov bitmapinfoheader.biBitCount,ax		;ax<br />            mov bitmapinfoheader.biCompression,BI_RGB		;BI_RGB<br />            mov bitmapinfoheader.biSizeImage,0<br />            mov bitmapinfoheader.biXPelsPerMeter,0<br />            mov bitmapinfoheader.biYPelsPerMeter,0<br />            mov eax,dwNumColors<br />            mov bitmapinfoheader.biClrUsed,eax<br />            mov bitmapinfoheader.biClrImportant,0<br /><br />            invoke CreateFile, lpFileName,GENERIC_WRITE,0,\<br />                    NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL<br />            mov hFile,eax<br /><br />	    .IF &#40;eax==INVALID_HANDLE_VALUE&#41;<br />                invoke DeleteObject, hBitmap<br />                invoke DeleteDC, memdc<br />                invoke DeleteDC, hdc<br />                invoke MessageBox, 0, addr szNoFile, NULL, 0<br />                jmp ExitFunc<br />            .ENDIF<br /><br />            invoke WriteFile, hFile, addr bitmapfileheader, sizeof BITMAPFILEHEADER,addr dwBytes, NULL<br />            invoke WriteFile, hFile, addr bitmapinfoheader, sizeof BITMAPINFOHEADER,addr dwBytes, NULL<br />            mov eax,dwNumColors<br />            .IF &#40;eax!=0&#41;<br />                invoke WriteFile, hFile, addr colors, ColorSize, addr dwBytes,NULL<br />            .ENDIF<br />            mov eax,dwWidth<br />            xor edx,edx<br />            mov ecx,dwHeight<br />            mul ecx<br />            xor edx,edx<br />            mov ecx,dwBPP<br />            mul ecx<br />            shr eax,3<br />            mov ColorSize,eax<br />            invoke WriteFile, hFile, pBits, ColorSize, addr dwBytes,NULL<br />            invoke CloseHandle, hFile<br />            invoke MessageBox, 0, addr szDone, NULL, 0<br />            invoke DeleteObject ,hBitmap<br />            invoke DeleteDC, memdc<br />            invoke DeleteDC, hdc<br />	ExitFunc&#58;<br />		ret<br />     CapScreen endp<br /><br />	Push 5000<br />	Call Sleep			; fait une pause de 5 secondes<br /><br />	JMP @Timer<br /><br /><br />end start</code></pre><br /><br />In first, when I run this program, it says me : Application error... The memory can't be &quot;read&quot;. etc etc...<br />And I don't know why...<br /><br />But I put this code (above) in another program and it works there. But there is another problem...<br />My second problem is that I would like to capture the screen and stock it into a bitmap (that's OK lol) but I would like to do it a lot of times (that's why I use the loop)...<br /><br />Also, as you can see the program displays error msgbox when API functions fail. Also it displays &quot;bitmap created&quot; when it created the bitmap.<br /><br />So when I start the program, it run the CapScreen procedure : it capture the screen and stock it into a bmp. Ok, then it jumps to @LOOP and it start the second lap of the loop : it capture the screen and it must ecrase (or erase I don't know, I'm french for those that who don't know it :] ) the old bmp creating the new bmp. But instead of that it displays me &quot;Couldn''t write file to disk.&quot;.<br /><br />So my question is : Why ? ^^' And how can I resolve this problem ?<br /><br />(I think it's a problem with the handle of the created bitmap, but I'm not sure and I didn't find the solution...)<br /><br />Thanks in advance for your help... :wink:</div>
    <div class="meta">Posted on 2004-12-23 16:45:19 by azerty1000</div>
   </div>
  </div>
 </body>
</html>