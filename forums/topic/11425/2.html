<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Using LOCAL without stack frames..... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=11425" />
  <link rel="prev" href="../?id=11425&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=11425">Using LOCAL without stack frames.....</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=11425&amp;page=1" style="">&laquo;</a><a href="../?id=11425&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="11425" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-86683">
    <div class="subject"><a href="#post-86683">:D</a></div>
    <div class="body">ok, that is right :), lol, and the other thing?? with the lea, and a new form of call using only mov's instead of pushes??<br /><br />call will get me the return addres and the jmp i want :)<br /><br />a yep, only a thing, then the call have some specific circuit that executes like a push eip and the jump, but have (oops.. i am not in my computer :S )have... like two instructions expanded with only one .</div>
    <div class="meta">Posted on 2003-03-12 07:46:38 by rea</div>
   </div>
   <div class="post" id="post-86685">
    <div class="subject"><a href="#post-86685">Using LOCAL without stack frames.....</a></div>
    <div class="body">INVOKE can be used with the macros listed above:<pre><code>	invoke SetWindowLong, WndProc_hWnd&#91;4*2&#93;, GWL_USERDATA, ebx</code></pre>...but it would be better if MASM gave us access to the INVOKE mechanism through macros - like with EPILOGUE/PROLOGUE.  In the above line of code <em>WndProc_hWnd</em> is on the stack and defined by an EQU.  We add to the offset by the number of pushed parameters times four.<br /><br />Now the last remaining bits seem to be dynamic code: branches or dynamic allocations on the stack.  For dynamic allocations I use a register to hold the size of the dynamic buffer and then add this to the _push/_pop/invoke items:<pre><code>	invoke GetClientRect, WndProc_hWnd&#91;4 + esi&#93;, ADDR &#91;ebx&#93;.rek</code></pre>For branching...I try not to. :)  Actually, the code is done manually and looks very ugly presently.</div>
    <div class="meta">Posted on 2003-03-12 08:15:45 by bitRAKE</div>
   </div>
   <div class="post" id="post-86695">
    <div class="subject"><a href="#post-86695">Using LOCAL without stack frames.....</a></div>
    <div class="body">Done some more experimenting. Is there any way to get code between the proc declaration and the LOCAL macro?<br /><pre><code><br />_TEXT SEGMENT<br />LclHeapAlloc PROC PUBLIC heapstruc$&#58;PTR DWORD,allocsize$&#58;PTR DWORD<br />&#91;COLOR=red&#93;***here***&#91;/COLOR&#93;<br />local foo&#58;DWORD<br />align 4	<br />	nop<br /></code></pre><br />I'd likie to redirect ebp before the local directive, but inside the proc to point to my own structure in memory.  Then I can leverage the fact that using locals will automatically calculate the offset from ebp.  <br /><br />I did manage to get it to work us db and opcodes(MASM wont let me use code, but opcodes are okay :rolleyes:  )<br />There error code I get when using real code:<br /><br />A2012:PROC, MACRO, or macro repeat directive must precede LOCAL<br /><br />I guess a macro would work?  Dont know anything about how to use macros.  Never seen a macro writing tutorial.<br />Is a macro a text processor, or code processor? Do I need to write opcodes?<br /><br />I'm trying to get a line like:<br /><br />	lea ebp,<br /><br />Between the proc definition and LOCAL directive.<br /><br />Thanks.</div>
    <div class="meta">Posted on 2003-03-12 09:14:25 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-86698">
    <div class="subject"><a href="#post-86698">hiya</a></div>
    <div class="body">also is a text preprocesor almost in nasm, but is lie the preprocesor of C/c++ or any other preprocessor the only that do is some operations and insert code, for example a pushn<br /><br /><br />(a macro isn't a text preprocesor, the text preprocesor have its how directives (one of this is for define macros, include files, etc), the macro is interpreted or expanded by the text preprocesor, also i know a idea about postprocesor.<br /><br /><br />%macro pushn 1-* ;say to the preprocesor we want define a mutiline macro<br />%rep %0<br />push %1<br />%rotate 1<br />%endrep<br />%endmacro ;terminate<br /><br />use:<br /><br />pushn eax, ebp, ecx ;this is now definied by the preprocesor, and then it know where are the implementation, is like a inline procedure or function<br /><br />will expanded to<br /><br />push eax <br />push ebp<br />push ecx<br /><br />also, i need to say, the problem regarding to the first write all the LOCAL vars and then write the code  like in the old C, that you need put all the locals vars ath the start of the function that are writting, also the version that modificates nguga have this problem, i say in the other post, the problem i wil try explain<br /><br />i dont know how to explain in words.. then a example<br /><br />in the nguga modificated version is like this:<br /><br />(1)<br />funct holaMundo, uno, dos, tres<br />;no code here<br />local hwnd, 4, wnd, WNDCLASSEX, msg, MSG<br />;code here<br />endfunct<br /><br />that is similar to code in masm<br /><br />(2)<br />holaMundo proc uno:DWORD, dos:DWORD, tres:DWORD<br />;no code here<br />local hwnd:HWND<br />local wnd:WNDCLASSEX<br />local msg:MSG<br />;code here<br />endp<br /><br /><br />in (1) and (2)the problem is when you know how many to substract to the ESP first think this, in the process of assignate to each name (hwnd, wnd, msg) the respective ebp-4, ebp-42, ebp-60 i dont remember the correct sizes, this definitions are like constants you cant change, but what append if you make some like this:<br /><br />LOCAL hwnd:HWND ;hwnd is ebp-4<br />push ebx ;you now modificate esp, then <br />LOCAL some:HWND ;some is definied by ebp-8 (see, the LOCAL dont know that you make a push and define like ebp-12 instead ebp-8)<br /><br />example in the stack:<br /><br />;this is where the normal pushes and pop take place<br />;&lt;-----this place is where esp are<br /><br />;------------------------------------------------------------------<br />;the space here are allocated by sub esp, some<br /><br /><br /><br /> ;&lt;&lt;---------- this is the base or the ebp<br /><br /><br /><br /><br /><br />this dont make sense, if you add or not pushes, but the problem is that the definitions for LOCAL are in only one direction, or follow only one direction, never know that you make some pushes or other instructions, then for dont take the posible error while coding some like in the above, in masm you need put all the LOCAL directives or declarations at the start and after any instruction... you understand  hwnd always gona be ebp-4, hwnd --&gt;  ebp-36, and msg --&gt;  ebp-58, for this masm needs that you put your locals at the start :) (if you add a push, you modificate this constant values, and this cant append)<br /><br />as you can see in the little representation of the stack, if the definitions for the names are secuentially.. that is the correct word, then if you try add a instruction between the LOCALS,  the posibility for get a incorrect direction for a name is high (refering to the saved value of ebp, instead the local value of some var), then, this is why masm need all the locals in the start.<br /><br />Also i can aviod this in the macro i code, but is with the use of sizef, and in the version of nguga modificates for work like in masm, and tasm (all the locals in the start), also the little tip for i can use a local declaration in my own macro elsewhere is count how many space need the locals at the end of the funct, and then substractit with a message, you dont need calculate :D and then i can code some like:<br /><br />funct WndProc, hWnd, uMsg, wParam, lParam<br />sizef 58<br />local wnd, WNDCLASSEX<br />;...<br />mov dword[.wnd+WNDCLASSEX.lpszMenuName], 0<br />;....... more code<br />local hwnd, 4<br />mov dword[.hwnd], eax<br />;....... more code<br />endfunct<br /><br />the trick is with endfunct, i not only terminate the function, also, i have now the count of all the local vars that i add :), and this is correct<br /><br />have a nice day.</div>
    <div class="meta">Posted on 2003-03-12 10:39:00 by rea</div>
   </div>
   <div class="post" id="post-86797">
    <div class="subject"><a href="#post-86797">Using LOCAL without stack frames.....</a></div>
    <div class="body">Interresting in hgb.<br /><br />If anyone knows a website with MASM macro tutorials, please direct me to it :grin: <br /><br />I tried writing a macro but only go errors :( <br /><br />But it seems I did not need a macro at all :) <br /><br /><pre><code><br />_TEXT SEGMENT	<br />HeapInit PROC PUBLIC initsize$&#58;PTR DWD<br />LOCAL LPHEAP&#91;5&#93;&#58;DWD<br />	lea ebp,&#91;HeapDesc+&#40;5*4&#41;&#93;<br /></code></pre><br />Apparently putting it after is the same as putting it above(with db and opcodes).<br />I guess LOCAL is link-time resolved?<br /><br />If anyone wonders what crazy stuff I'm up to...  <br />Since I dont use ebp for a stack frame, I thought I'd modify ebp to point to structures used in a proc.<br />Then I can leverage LOCALs behavior to get my variavle as an offset from ebp:<br /><pre><code><br />	mov &#91;LPHEAP+.HeapTop&#93;,edx		<br />00401616 89 55 F0         mov         dword ptr &#91;ebp-10h&#93;,edx <br />	mov &#91;LPHEAP+.HeapPtrCur&#93;, eax<br />00401619 89 45 F8         mov         dword ptr &#91;ebp-8&#93;,eax<br /></code></pre><br />Are memory moves any faster when with reg+offset compared to just an address?<br />Hmmm reg+offset is 3 byte, but and address is 6 bytes:<br /><pre><code><br />	mov &#91;HeapDesc+.HeapTop&#93;,edx		<br />00401616 89 15 24 61 40 00 mov         dword ptr &#91;_HeapTop &#40;406124h&#41;&#93;,edx <br />	mov &#91;LPHEAP+.HeapPtrCur&#93;, eax<br />0040161C 89 45 F8         mov         dword ptr &#91;ebp-8&#93;,eax<br /></code></pre><br />There is a size benefit.<br /><br />Thanks.</div>
    <div class="meta">Posted on 2003-03-12 21:53:13 by ThoughtCriminal</div>
   </div>
   <div class="post" id="post-87010">
    <div class="subject"><a href="#post-87010">Using LOCAL without stack frames.....</a></div>
    <div class="body">nope, the are not resolved in the link-time <br /><br />the locals are definied in the assemble-time, also in the preprocessor (i think if local is most like a macro), the size that the vars will use is know after start assembly, and the real addres of the locals are definied at run-time, for example, now you know that for example:<br /><br />winProc proc ... , lParam:LPARAM<br />local hwnd:HWND ;the size is 4 or dowuble word. hwnd isw definied like ebp-4<br />local hdc:HDC ;the size is 4. hdc is definied like ebp-8 or ebp-(4+4) see the anterior size of the local var<br />;internally added enter 0,0 and sub esp,8<br />endp<br /><br />the total size of the locals are 8 (4+4) --&gt; sub esp,8 or add esp,-8 this is for &quot;preserve space&quot; first, then all the normal pushes and pops (in pairs) dont take effect over the space of the locals, also remember hwnd is definied like ebp-4 and hdc is definied like ebp-8<br /><br />also you can see <a target="_blank" href="http://usuarios.lycos.es/oldbreakpoint/ASM/Stack/index.php">stack</a> where is a try to explain how it work in the run-time (only see the 2 figures, the other things.. are my first try).<br /><br />resume:<br /><br />-- The locals are definied in time of assembly and with the added sub esp, some reserve the space, for the next pushes and pops dont corrupt the data in the locals vars.<br /><br />-- The space is reserved in runtime, and the addres of the locals are definied in time of assembly (also remember they are ebp-some) is not a effective addres, is a relative addres from ebp, and maybe ebp not always have the same addres, this is way are relative to ebp and why locals vars cant preserve they value between calls.<br /><br />Have a nice day.</div>
    <div class="meta">Posted on 2003-03-14 00:17:24 by rea</div>
   </div>
   <div class="post" id="post-87111">
    <div class="subject"><a href="#post-87111">clarification :D</a></div>
    <div class="body">also i need a little more help, tell me if my concepts are worg, respect to the use with ESP instead EBP<br /><br />when ypu call, the esp modificates is value , and some call like ths:<br /><br /><br />(1)<br /><br />call hola, arg1, arg2, arg3, arg4,...,argN will cause this:<br /><br /><br /><br />------------------------------- &lt;--here is where point esp<br /> ;4<br /> ; 4<br /><br /><br />[...]<br /><br />[.....]   &lt;--more values<br /> &lt;--- where the ebp point, it dosent matter (dont alterate by the call) <br /><br />the the values for arg1 is 4 plus 4 of the return addres, then args can be definied some like this:<br /><br />arg1 esp+8<br />arg2 esp+12<br />....<br />argN esp+(4*N) where N is is the number of args<br /><br />(2) <br /><br />if you gona use local vars, i think is not good in time<br /><div class="quote"><br />_push	eax, _D ; give it a name, too <br />	_push	eax, _E<br />	_push	eax, _F<br />	_push	eax, _G<br />	_push	eax, _H<br /></div> <br />if i understand right this, you are saying push eaxh value to the stack, and by this way reserve the space in the stack, is right this?? push the locals values for reserve space for they??, if this is, i think is best know how many space need the locals and do the reservation of the space by a sub esp, (spaceForLocals) like in the use with EBP and the sub, spaceForLocals Will Cause some like this:<br /><br />------------------------------- &lt;--here is where point esp<br /><br />.....<br />.....<br /><br />------------------------------- &lt;--- the anterior place of ESP<br /> ;4<br /> ; 4<br /><br /><br />[...]<br /><br />[.....]   &lt;--more values<br /> &lt;--- where the ebp point, it dosent matter (dont alterate by the call)<br /><br />(3)<br /><br />if you push some,  you need be carrefull and add to the &quot;offset&quot; or &quot;displacement&quot; to the &quot;anterior&quot; names, like in calls inside your procedure the corresponding pop are valanced in the other procedure and maybe see some like this:<br /><br />------------------------------- &lt;---here is where point esp<br /><br /><br />[...]<br /><br /><br />------------------------------- &lt;--the anterior place where point ESP<br /><br />.....<br />.....<br /><br />------------------------------- &lt;--- the anterior place of ESP<br /> ;4<br /> ; 4<br /><br /><br />[...]<br /><br />[.....]   &lt;--more values<br /> &lt;--- where the ebp point, it dosent matter (dont alterate by the call)<br /><br />if you join (1), (2), (3) <br /><br />you will see that are stackDept (referring to normal pushes in a function, like calls, or save of values or registers)<br />and localsDept(refering to the space that we reserve for the locals)<br /><br />then the last graph can be showed some like this:<br /><pre><code><br />------------------------------- &lt;---here is where point esp               _____<br />&#91;OtherPushes&#93;                                                                    |<br />&#91;moreParamsForCalls&#93;                                                       |---&gt; this is stack depth &#40;see *&#41;<br />&#91;...&#93;                                                                                 |<br />&#91;someargForACall&#93;                                                               |<br />&#91;otherPushForSaveARegister&#93;                                                   --------<br />------------------------------- &lt;--the anterior place where point ESP  ____<br />&#91;more garbage&#93;                                                                             |<br />.....                                                                                                 | ---&gt;this is local Depth &#40;see **&#41;<br />.....                                                                                                 |<br />&#91;garbage&#93;                                                                                      -------<br />------------------------------- &lt;--- the anterior place of ESP              ________________________<br />&#91;return address&#93; ;4                                                                                                      |<br />&#91;arg1&#93; ; 4                                                                                                                       |<br />&#91;arg2&#93;                                                                                                                           |<br />&#91;arg3&#93;                                                                                                                            | --&gt;the args<br />&#91;...&#93;                                                                                                                               |<br />&#91;argN&#93;                                                                                                                           |<br />&#91;.....&#93;   &lt;--more values                                                                                                  |<br />&#91;some value&#93; &lt;--- where the ebp point, it dosent matter &#40;dont alterate by the call&#41;--------------&#91;EDITED dont create a stack frame&#93;<br /></code></pre><br /><br />then you now know how is organized this thing.. <br /><br />then you can say the argument in (1) will be definied some like this<br /><br />arg1 ebp +8<br />arg2 ebp +12<br />etc<br /><br />but in (2) the argumensta are definied some like<br /><br />arg1 ebp+8+localDept<br />arg1 ebp+12+localDept<br /><br />where localDept we know (we substract the right space for our locals)<br /><br />the locals are definied if local1 is WNDCLASS and local2 is MSG some like this<br /><br />local1 esp+32 ;i dont remember the number<br />local2 esp+32+28<br /><br />also in (3) the args are definied some like:<br /><br />arg1 ebp+8+localDept+stackDept<br />arg2 ebp+12+localDept+stackDept<br /><br />and the locals are definied if local1 is WNDCLASS and local2 is MSG some like this<br /><br />local1 esp+32+stackDept<br />local2 esp+60+stackDept<br /><br />*The localDept can be knowed and is constant<br />**The stackDept is not constant, and is modificated by pushes or pops, also the pushes of a call need be balanced in the same call or after, for no alterate the stackdept of the function, for example<br /><br />;stackDept is 50<br />call MessageBoxA, NULL, &quot;Hola&quot;, &quot;Que pasa&quot;, MB_OK ;in this moment, stackdept is 66<br />;now stackdept is 50, dont get alterations by calls<br />push eax<br />;now stackDept is 54<br />;a finall thing, when we return, the esp need be in the start in (1), the we need make some like add esp, stackDept+localDept and now esp is pointing to the return address and the args passed in (1)<br /><br /><br />i think that is all, i have the macro near from be usable, also i need see how i am implementing.... remember is in nasm, but i think when done, you can see and maybe if you find some usage you can traslate to your macro language of your assembler<br /><br /><br />:)<br /><br />Have any other sugestions??<br /><br />Have a nice day:alright:</div>
    <div class="meta">Posted on 2003-03-14 16:03:23 by rea</div>
   </div>
   <div class="post" id="post-87205">
    <div class="subject"><a href="#post-87205">hiya dudes!!!!</a></div>
    <div class="body">a yea, i see that the above is right, now i terminate the macro and can be used so easely, only put optionUseESP or optionUseEBP the default is EBP and without any modification you can obtain the two methods ;D directly, like a feature, you can join boot , put the above instructions and you can combine this methods.<br /><br /><br />Also the only problem to show you is that i am now incomunicated, my comp dont have disk 3,1/2 or Internet, my bro apparently sold or rendered the red cable, also no have CDR lol, but i will take the floppy of this computer and save the macro, also i do some little test, and work like a charm, also i have some observations now, and are:<br /><br />-- Is easy to use, and change directly without modification to code for use UESP or EBP.<br /><br />-- Windows dont like the option for use ESP:<br /><br />for example, i debug the translated icztut5(in nasm) with the ollyDbg, and for example when i use the default option that is with EBP and the stack frame, i can Register the class With RegisterClassEx, get a right value, then CreateTheWindow and get a right value, in fact the programm work good. The values passed to CreateWindowEx are:<br /><br /><pre><code>  <br />ExStyle = &quot;0&quot;<br />Class = &quot;ClasName&quot;<br />WindowName =&quot;Usando EBP&quot;  ; &lt;------- this string is definied with %if useEBP &quot;EBP&quot; %elif %useESP &quot;ESP&quot; %endif, get the idea???<br />STYLE = WS_OVERLAPPEDWINDOW | ...<br />X=800000000<br />Y=800000000<br />WIDT=800000000<br />HEIGHT=800000000<br />hParent = NULL<br />hMenu = NULL<br />hInst = 0012FFB4<br />lParam = NULL<br /></code></pre> <br />the return value in EAX = 003D0282<br /><br />But when i use the optionUseESP, also i can call RegisterClasEx and the return value in EAX is the same that when i use EBP, also the values passed to CreateWindowEx, are nearly the same escept for the WindowName, that i make a choice with help of the preproscesor and get &quot;Using EBP&quot; or &quot;Using ESP&quot;, the values with ESP passed to CreateWindowEx are:<br /><br /><pre><code><br />ExStyle = &quot;0&quot;                               ;equal<br />Class = &quot;ClasName&quot;                    ;equal<br />WindowName =&quot;Usando ESP&quot;  ; &lt;------- ESP<br />STYLE = WS_OVERLAPPEDWINDOW | ...   ;equal<br />X=800000000          ;equal<br />Y=800000000         ;equal<br />WIDT=800000000       ;equal<br />HEIGHT=800000000     ;equal<br />hParent = NULL            ;equal<br />hMenu = NULL             ;equal<br />hInst = 0012FFB4       ;equal<br />lParam = NULL            ;equal<br /></code></pre><br />and the value reurned in EAX = 00000000<br /><br />now i think that some functions in the WinAPI need the use of the stack frame, i dunno for what, but like you see, the values are right and i check, and the proof case is that i First Use RegisterClassEx and return to me the correct result, also CreateWindowEx isn't do this, the values are almost equals and give for result a EAX=0<br /><br />The value by RegisterClassExA retornated in bot cases (with ESP and EBP) are<br /><br />EAX = 0000C144<br /><br />But no is a problem for the macro, i say you i test with others more simple functions, also the proof is RegisterClassExA.<br /><br />For terminate, the displacements or the correct values are generated by the macro inbot cases with use of EBP and ESP:<br /><br />NOTE IN THE NEXT: the values for the locals are saved from start to the end, also you can say for example:<br /><br />[.hwnd] EBP-80 ;the addres here is 1000-80 = 920 i think<br />####<br />[.msg] EBP-76<br />####<br />####<br />####<br />####<br />####<br />####<br />####<br />[.wndC] EBP-48<br />####<br />####<br />.....<br />#### member 13<br />####<br /> ;For example address in decimal 1000<br /><br /><br /><br /><br /><br /><br />****For EBP (Stack Frame) values Generated are:<br /><br />------------------------- &lt;---ESP point here<br />[.hwnd]             is definied by EBP-80<br />[.msg]               is definied by EBP-(48+28) or EBP-76<br />[.wndC]             is definied by EBP-48<br />------------------------- &lt;--- EBP point here<br />   ;This is the stack frame<br />  THE ret addr at EBP+4<br />[.hInstancia]       is definied by EBP+8<br />[.hPrevInst]     --&gt;EBP+12<br />[.lpCmdLine]   ---&gt;EBP+16<br />[.nCmdShow]   ----&gt;EBP+20<br /><br /><br /><br /><br /><br />****For ESP values Generated are:<br /><br />[....] posible stackDept here (a modificate ESP), is handle with stackDept<br />------------------------------- &lt;----ESP point here<br />[.hwnd]     is definied like ESP (remember the order that the values are saved in memory)<br />[.msg]       is definied like ESP+4<br />[.wndC]    is definied like ESP+32<br /> EBP+80 (See no stack frame)<br />[.hInstance] EBP+84<br />[.hPrevInstance] EBP+88<br />[.lpCmdLine] EBP+92<br />[.nCmdShow] EBP+96<br /><br />also i be carefull with the stackDept when use ESP.<br /><br />Now i Think this is done :D, the question is what functions dont need stackFrame like RegisterClassExA, and what other need like CreateWindowEx ????<br /><br />I will upload this macro to my little site, and send to naguga, also i see a little bug :D in the past (when i get floppy, internet or the cable for connect the LAN)<br /><br />Have a nice day.</div>
    <div class="meta">Posted on 2003-03-15 09:23:09 by rea</div>
   </div>
   <div class="post" id="post-87332">
    <div class="subject"><a href="#post-87332">Using LOCAL without stack frames.....</a></div>
    <div class="body">CreateWindowEx will call your window proc routine, so check that EBP is preserved there. There's at least one C routine being used in the call chain. I'm guessing your EBP option also affects the window proc routine.  If you use EBP for some other purpose than as a stack frame, it must be restored before you return.</div>
    <div class="meta">Posted on 2003-03-16 03:34:20 by tenkey</div>
   </div>
   <div class="post" id="post-87601">
    <div class="subject"><a href="#post-87601">ok</a></div>
    <div class="body">i thing is restored ok, now i will put my macro here (in nasm) i say you, i think work ok, also i put a little example and the output<br /><br />hi, here is the macro whit a little example of how to use, like you see, can combine the &quot;technic&quot; or use one and latter use other<br /><br /><pre><code><br />&#91;COLOR=blue&#93;<br />%include '\lab\vasm\inc\nagoa.inc'<br />%include '\lab\vasm\inc\f.inc'<br />&#91;/color&#93;<br /><br />&#91;COLOR=teal&#93;;our functions, if not define, get a error&#91;/color&#93;<br /><br />&#91;COLOR=royalblue&#93;<br />def unoWhitESP<br />def unoWhitEBP<br />def dosWhitESP<br />def dosWhitEBP<br />def dummyEBP<br />def dummyESP<br />&#91;/color&#93;<br /><br />segment code class=code use32<br /><br />&#91;COLOR=red&#93;..start&#58;&#91;/color&#93;<br />	call GetModuleHandle, NULL<br />	var Instancia, 4<br />	mov dword&#91;Instancia&#93;, eax<br />	call dummyESP,4,4,2,2<br />	call dummyEBP, 3,3,6,6<br />	call unoWhitESP,1,2,3,4<br />	call unoWhitEBP,5,6,7,8<br />	call dosWhitESP, 9,8,7,6<br />	call dosWhitEBP,5,4,3,2<br />	call ExitProcess, eax<br /><br />&#91;COLOR=teal&#93;;dummy functions only show you the manage without locals<br />;here we use the default is with stack frames &#40;EBP&#41;&#91;/color&#93;<br />funct dummyEBP, darg1, darg2, darg3, darg4<br />	mov eax, &#91;.darg1&#93;<br />	mov eax, &#91;.darg4&#93;<br />endfunct<br /><br />&#91;COLOR=blue&#93;optionUseESP&#91;/COLOR&#93;<br />funct dummyESP, darg1, darg2, darg3, darg4<br />	mov eax, &#91;.darg1&#93;<br />	mov eax, &#91;.darg4&#93;<br />endfunct<br /><br />&#91;COLOR=teal&#93;;unoWhitE.P show you how handle functions without locals and having pushes&#91;/color&#93;<br />funct unoWhitESP, arg1, arg2, arg3, arg4<br />	mov eax, &#91;.arg1&#93;<br />	mov edx, &#91;.arg4&#93;<br />	push eax<br />	mov eax, &#91;.arg1&#93;<br />	push eax<br />	mov eax, &#91;.arg1&#93;<br />endfunct<br /><br />&#91;COLOR=blue&#93;optionUseEBP&#91;/COLOR&#93;<br />funct unoWhitEBP, arg1, arg2, arg3, arg4<br />	mov eax, &#91;.arg1&#93;<br />	mov edx, &#91;.arg4&#93;<br />	push eax<br />	mov eax, &#91;.arg1&#93;<br />	push eax<br />	mov eax, &#91;.arg1&#93;<br />endfunct<br /><br />&#91;COLOR=teal&#93;;dosWhitE.P show you how handle some with locals and above you use pushes&#91;/color&#93;<br />funct dosWhitEBP, arg1, arg2, arg3, arg4<br />	sizef 48<br />	mov eax, &#91;.arg1&#93;<br />	mov edx, &#91;.arg4&#93;<br />	local wndC, WNDCLASSEX<br />	mov eax, &#91;.arg1&#93;<br />	mov edx, &#91;.arg4&#93;<br />endfunct<br /><br />&#91;COLOR=blue&#93;optionUseESP&#91;/COLOR&#93;<br />funct dosWhitESP, arg1, arg2, arg3, arg4<br />	sizef 48<br />	mov eax, &#91;.arg1&#93;<br />	mov edx, &#91;.arg4&#93;<br />	local wndC, WNDCLASSEX<br />	mov eax, &#91;.arg1&#93;<br />	mov edx, &#91;.arg4&#93;<br />endfunct<br /></code></pre><br /><br />The olly says :D<br /><pre><code><br />&#91;COLOR=red&#93;;..start&#58;&#91;/color&#93;<br />00401000 &gt;6A 00             PUSH 0<br />00401002  FF15 44304000     CALL DWORD PTR DS&#58;&#91;&lt;&amp;kernel32.GetModuleH&gt;; kernel32.GetModuleHandleA<br />00401008  A3 00204000       MOV DWORD PTR DS&#58;&#91;402000&#93;,EAX<br />0040100D  6A 02             PUSH 2<br />0040100F  6A 02             PUSH 2<br />00401011  6A 04             PUSH 4<br />00401013  6A 04             PUSH 4<br />00401015  E8 56000000       CALL TESTLO~1.00401070   &#91;COLOR=teal&#93;;dummyESP&#91;/color&#93;<br />0040101A  6A 06             PUSH 6<br />0040101C  6A 06             PUSH 6<br />0040101E  6A 03             PUSH 3<br />00401020  6A 03             PUSH 3<br />00401022  E8 3B000000       CALL TESTLO~1.00401062   &#91;COLOR=teal&#93;;dummyEBP&#91;/color&#93;<br />00401027  6A 04             PUSH 4<br />00401029  6A 03             PUSH 3<br />0040102B  6A 02             PUSH 2<br />0040102D  6A 01             PUSH 1<br />0040102F  E8 47000000       CALL TESTLO~1.0040107B   &#91;COLOR=teal&#93;;unoWithESP&#91;/color&#93;<br />00401034  6A 08             PUSH 8<br />00401036  6A 07             PUSH 7<br />00401038  6A 06             PUSH 6<br />0040103A  6A 05             PUSH 5<br />0040103C  E8 55000000       CALL TESTLO~1.00401096   &#91;COLOR=teal&#93;;unoWithEBP&#91;/color&#93;<br />00401041  6A 06             PUSH 6<br />00401043  6A 07             PUSH 7<br />00401045  6A 08             PUSH 8<br />00401047  6A 09             PUSH 9<br />00401049  E8 78000000       CALL TESTLO~1.004010C6   &#91;COLOR=teal&#93;;dosWhitESP&#91;/color&#93;<br />0040104E  6A 02             PUSH 2<br />00401050  6A 03             PUSH 3<br />00401052  6A 04             PUSH 4<br />00401054  6A 05             PUSH 5<br />00401056  E8 51000000       CALL TESTLO~1.004010AC   &#91;COLOR=teal&#93;;dosWhitEBP&#91;/color&#93;<br />0040105B  50                PUSH EAX<br />0040105C  FF15 48304000     CALL DWORD PTR DS&#58;&#91;&lt;&amp;kernel32.ExitProces&gt;; kernel32.ExitProcess<br />&#91;COLOR=teal&#93;;dummyEBP&#91;/color&#93;<br />00401062  C8 000000         ENTER 0,0<br />00401066  8B45 08           MOV EAX,DWORD PTR SS&#58;&#91;EBP+8&#93;<br />00401069  8B45 14           MOV EAX,DWORD PTR SS&#58;&#91;EBP+14&#93;<br />0040106C  C9                LEAVE<br />0040106D  C2 1000           RETN 10<br />&#91;COLOR=teal&#93;;dummyESP&#91;/color&#93;  &#91;COLOR=blue&#93;optionUseESP&#91;/COLOR&#93;<br />00401070  8B4424 04         MOV EAX,DWORD PTR SS&#58;&#91;ESP+4&#93;<br />00401074  8B4424 10         MOV EAX,DWORD PTR SS&#58;&#91;ESP+10&#93;<br />00401078  C2 1000           RETN 10<br />&#91;COLOR=teal&#93;;unoWithESP&#91;/color&#93;<br />0040107B  8B4424 04         MOV EAX,DWORD PTR SS&#58;&#91;ESP+4&#93;<br />0040107F  8B5424 10         MOV EDX,DWORD PTR SS&#58;&#91;ESP+10&#93;<br />00401083  50                PUSH EAX<br />00401084  8B4424 08         MOV EAX,DWORD PTR SS&#58;&#91;ESP+8&#93;<br />00401088  50                PUSH EAX<br />00401089  8B4424 0C         MOV EAX,DWORD PTR SS&#58;&#91;ESP+C&#93;<br />0040108D  81C4 08000000     ADD ESP,8<br />00401093  C2 1000           RETN 10<br />&#91;COLOR=teal&#93;;unoWithEBP&#91;/color&#93; &#91;COLOR=blue&#93;optionUseEBP&#91;/COLOR&#93;<br />00401096  C8 000000         ENTER 0,0<br />0040109A  8B45 08           MOV EAX,DWORD PTR SS&#58;&#91;EBP+8&#93;<br />0040109D  8B55 14           MOV EDX,DWORD PTR SS&#58;&#91;EBP+14&#93;<br />004010A0  50                PUSH EAX<br />004010A1  8B45 08           MOV EAX,DWORD PTR SS&#58;&#91;EBP+8&#93;<br />004010A4  50                PUSH EAX<br />004010A5  8B45 08           MOV EAX,DWORD PTR SS&#58;&#91;EBP+8&#93;<br />004010A8  C9                LEAVE<br />004010A9  C2 1000           RETN 10<br />&#91;COLOR=teal&#93;;dosWhitEBP&#91;/color&#93;<br />004010AC  C8 000000         ENTER 0,0<br />004010B0  81EC 30000000     SUB ESP,30<br />004010B6  8B45 08           MOV EAX,DWORD PTR SS&#58;&#91;EBP+8&#93;<br />004010B9  8B55 14           MOV EDX,DWORD PTR SS&#58;&#91;EBP+14&#93;<br />004010BC  8B45 08           MOV EAX,DWORD PTR SS&#58;&#91;EBP+8&#93;<br />004010BF  8B55 14           MOV EDX,DWORD PTR SS&#58;&#91;EBP+14&#93;<br />004010C2  C9                LEAVE<br />004010C3  C2 1000           RETN 10<br />&#91;COLOR=teal&#93;;dosWhitESP&#91;/color&#93; &#91;COLOR=blue&#93;optionUseESP&#91;/COLOR&#93;<br />004010C6  81EC 30000000     SUB ESP,30<br />004010CC  8B4424 34         MOV EAX,DWORD PTR SS&#58;&#91;ESP+34&#93;<br />004010D0  8B5424 40         MOV EDX,DWORD PTR SS&#58;&#91;ESP+40&#93;<br />004010D4  8B4424 34         MOV EAX,DWORD PTR SS&#58;&#91;ESP+34&#93;<br />004010D8  8B5424 40         MOV EDX,DWORD PTR SS&#58;&#91;ESP+40&#93;<br />004010DC  81C4 30000000     ADD ESP,30<br />004010E2  C2 1000           RETN 10<br /></code></pre><br /><br /><br />Like you see in the code above. is fine and nice ;), also you see now what is the output, and see that you can mix both.<br /><br /><br />now i see the debug and all stack frames are restored, also you can combine then, like you say, the technique is ok, but have some problem if with some routines in win32api (the use of ESP), also i think not only CreateWindowEx need you use  stack frames in you functions.<br /><br />you can watch the macro, i think no have errors, but if you can translate to your macro preprocesor that maybe are good, see the code and the output, i think is that, and i say you, can change from one to the other without modify in any way your code :D.<br /><br />Have a nice day.<br /><br /><br />*edited<br />a suck.. i forget put the attachment :S lol...mmm i cant edit the attachment.. ops.... in the next :D</div>
    <div class="meta">Posted on 2003-03-17 10:42:45 by rea</div>
   </div>
   <div class="post" id="post-87603">
    <div class="subject"><a href="#post-87603">f macro (NASM) mix techniques :D</a></div>
    <div class="body">easy of use and good use :D.<br /><br />what you think??, you can translate tou your macro language ... if you want?? <br />(edit) also if you dont understand some in the macro f.inc, you can ask to me.(/edit)<br /><br />ok, have a nice day.<br /><br />(sorry for the double post, but i cant edit the above.. i forget put the attachment.. lol.. )</div>
    <div class="meta">Posted on 2003-03-17 10:47:52 by rea</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=11425&amp;page=1" style="">&laquo;</a><a href="../?id=11425&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="11425" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>