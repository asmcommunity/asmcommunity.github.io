<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>CPU Speed - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30551" />
    <link rel="next" href="../?id=30551&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=30551">CPU Speed</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=30551&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=30551&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="30551" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=30551&amp;page=2">&gt;</a><a href="../?id=30551&amp;page=2">&raquo;</a></form>   <div class="post" id="post-214346">
    <div class="subject"><a href="#post-214346">CPU Speed</a></div>
    <div class="body">Hi, i&#039;ve been investigating with no luck how to get CPU Speed. I have seen many implementations, but they all use in some way a library (using sleep or QueryPerformanceCounter). I am currently working with a kernel provided by a professor, which provides me with no function at all.<br />For what i have analyzed, the correct way to go would be with RDTSC, but i have no idea of how to measure a fixed time interval.<br /><br />Any ideas or suggestions?<br /><br />EDIT: I&#039;m coding in C and assembler btw :D</div>
    <div class="meta">Posted on 2011-05-05 23:35:52 by cronos89</div>
   </div>
   <div class="post" id="post-214347">
    <div class="subject"><a href="#post-214347">Re: CPU Speed</a></div>
    <div class="body">Well, your kernel will need to provide some sort of timing function, else you have no reference for RDTSC.<br />An alternative is to use the CPUID instruction.<br />You can get the CPU model identifier from that, which includes the clockspeed in most cases.</div>
    <div class="meta">Posted on 2011-05-06 02:20:53 by Scali</div>
   </div>
   <div class="post" id="post-214348">
    <div class="subject"><a href="#post-214348">Re: CPU Speed</a></div>
    <div class="body"><a target="_blank" href="http://wiki.osdev.org/Detecting_CPU_Speed">Detecting CPU Speed @ OSDev Wiki</a></div>
    <div class="meta">Posted on 2011-05-06 10:17:32 by SpooK</div>
   </div>
   <div class="post" id="post-214352">
    <div class="subject"><a href="#post-214352">Re: CPU Speed</a></div>
    <div class="body">Some information about CPU program may get from register&nbsp; &quot;HKEY_LOCAL_MACHINE\HARDWARE\DESCRIPTION\System\CentralProcessor\0:<br /></div>
    <div class="meta">Posted on 2011-05-07 18:22:31 by MikDay</div>
   </div>
   <div class="post" id="post-214353">
    <div class="subject"><a href="#post-214353">Re: CPU Speed</a></div>
    <div class="body">http://www.codeproject.com/KB/system/Processor_Speed.aspx<br /><br />Straight forward code. I would not go with the registry way though. </div>
    <div class="meta">Posted on 2011-05-07 21:17:23 by JimmyClif</div>
   </div>
   <div class="post" id="post-214355">
    <div class="subject"><a href="#post-214355">Re: CPU Speed</a></div>
    <div class="body"><pre><code><br /> include \masm32\include\masm32rt.inc<br />&nbsp; &nbsp; .586<br />&nbsp; &nbsp; .data<br />&nbsp; &nbsp; .code<br />start:<br /><br />&nbsp; &nbsp; call CpuClockSpeed<br />&nbsp; &nbsp; .IF eax<br />&nbsp; &nbsp; &nbsp; push&nbsp; eax<br />&nbsp; &nbsp; &nbsp; push&nbsp; eax<br />&nbsp; &nbsp; &nbsp; fstp&nbsp; QWORD PTR<br />&nbsp; &nbsp; &nbsp; pop&nbsp;  eax<br />&nbsp; &nbsp; &nbsp; pop&nbsp;  edx<br />&nbsp; &nbsp; &nbsp; invoke crt_printf,chr$(&quot;%.2f MHz%c&quot;),edx::eax,10<br />&nbsp; &nbsp; .ENDIF&nbsp; <br /><br />&nbsp; &nbsp; inkey &quot;Press any key to exit...&quot;<br />&nbsp; &nbsp; exit<br /><br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br />; This proc determines the CPU clock speed in MHz by counting TSC<br />; cycles over a one-second interval timed with the high-resolution<br />; performance counter. If the processor supports CPUID and RDTSC<br />; and the system supports a high-resolution performance counter,<br />; the clock speed is left on the FPU stack in ST(0) and the return<br />; value is non-zero. Otherwise, the return value is zero.<br />; «««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««««<br /><br />CpuClockSpeed proc uses edi esi<br /><br />&nbsp; &nbsp; LOCAL pcFreq&nbsp; :QWORD<br />&nbsp; &nbsp; LOCAL pcCount :QWORD<br /><br />&nbsp; &nbsp; ;-----------------------------------------------------------<br />&nbsp; &nbsp; ; CPUID supported if can set/clear ID flag (EFLAGS bit 21).<br />&nbsp; &nbsp; ;-----------------------------------------------------------<br /><br />&nbsp; &nbsp; pushfd<br />&nbsp; &nbsp; pop&nbsp;  edx<br />&nbsp; &nbsp; pushfd<br />&nbsp; &nbsp; pop&nbsp;  eax<br />&nbsp; &nbsp; xor&nbsp;  eax, 200000h&nbsp; ; flip ID flag<br />&nbsp; &nbsp; push&nbsp; eax<br />&nbsp; &nbsp; popfd<br />&nbsp; &nbsp; pushfd<br />&nbsp; &nbsp; pop&nbsp;  eax<br />&nbsp; &nbsp; xor&nbsp;  eax, edx<br />&nbsp; &nbsp; jz&nbsp; &nbsp; fail<br /><br />&nbsp; &nbsp; ;------------------------------------------------<br />&nbsp; &nbsp; ; TSC supported if CPUID function 1 returns with<br />&nbsp; &nbsp; ; bit 4 of EDX set.<br />&nbsp; &nbsp; ;------------------------------------------------<br /><br />&nbsp; &nbsp; mov&nbsp;  eax, 1<br />&nbsp; &nbsp; cpuid<br />&nbsp; &nbsp; and&nbsp;  edx, 10h<br />&nbsp; &nbsp; jz&nbsp; &nbsp; fail<br /><br />&nbsp; &nbsp; invoke QueryPerformanceFrequency, ADDR pcFreq<br />&nbsp; &nbsp; or&nbsp; &nbsp; eax, eax<br />&nbsp; &nbsp; jz&nbsp; &nbsp; fail<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; invoke GetCurrentProcess<br />&nbsp; &nbsp; invoke SetPriorityClass, eax, HIGH_PRIORITY_CLASS<br /><br />&nbsp; &nbsp; ;----------------------------------------------------<br />&nbsp; &nbsp; ; Sync with performance counter and get start count.<br />&nbsp; &nbsp; ;----------------------------------------------------<br /><br />&nbsp; &nbsp; invoke QueryPerformanceCounter, ADDR pcCount<br />&nbsp; &nbsp; mov&nbsp;  edi, DWORD PTR pcCount<br />&nbsp; @@:<br />&nbsp; &nbsp; invoke QueryPerformanceCounter, ADDR pcCount<br />&nbsp; &nbsp; cmp&nbsp;  edi, DWORD PTR pcCount<br />&nbsp; &nbsp; je&nbsp; &nbsp; @B<br /><br />&nbsp; &nbsp; rdtsc<br />&nbsp; &nbsp; push&nbsp; edx<br />&nbsp; &nbsp; push&nbsp; eax<br /><br />&nbsp; &nbsp; ;-----------------------------------------<br />&nbsp; &nbsp; ; Calc terminal count for 1 second delay.<br />&nbsp; &nbsp; ;-----------------------------------------<br /><br />&nbsp; &nbsp; mov&nbsp;  edi, DWORD PTR pcCount<br />&nbsp; &nbsp; mov&nbsp;  esi, DWORD PTR pcCount + 4<br />&nbsp; &nbsp; add&nbsp;  edi, DWORD PTR pcFreq&nbsp; &nbsp; <br />&nbsp; &nbsp; adc&nbsp;  esi, DWORD PTR pcFreq + 4<br /><br />&nbsp; &nbsp; ;---------------------------------------------<br />&nbsp; &nbsp; ; Loop until PC count exceeds terminal count.<br />&nbsp; &nbsp; ;<br />&nbsp; &nbsp; ; Cannot check low-order dword for equality<br />&nbsp; &nbsp; ; because PC cannot be depended on to always<br />&nbsp; &nbsp; ; increment count by one.<br />&nbsp; &nbsp; ;---------------------------------------------<br />&nbsp; @@:&nbsp; <br />&nbsp; &nbsp; invoke QueryPerformanceCounter, ADDR pcCount<br />&nbsp; &nbsp; cmp&nbsp;  DWORD PTR pcCount+4, esi<br />&nbsp; &nbsp; jne&nbsp;  @B<br />&nbsp; &nbsp; cmp&nbsp;  DWORD PTR pcCount, edi<br />&nbsp; &nbsp; jb&nbsp; &nbsp; @B&nbsp; &nbsp; <br /><br />&nbsp; &nbsp; rdtsc<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; pop&nbsp;  ecx<br />&nbsp; &nbsp; sub&nbsp;  eax, ecx<br />&nbsp; &nbsp; pop&nbsp;  ecx<br />&nbsp; &nbsp; sbb&nbsp;  edx, ecx<br /><br />&nbsp; &nbsp; push&nbsp; edx<br />&nbsp; &nbsp; push&nbsp; eax<br />&nbsp; &nbsp; finit<br />&nbsp; &nbsp; fild&nbsp; QWORD PTR<br />&nbsp; &nbsp; fld8&nbsp; 1000000.0<br />&nbsp; &nbsp; fdiv<br /><br />&nbsp; &nbsp; invoke GetCurrentProcess<br />&nbsp; &nbsp; invoke SetPriorityClass, eax, NORMAL_PRIORITY_CLASS<br /><br />&nbsp; &nbsp; return 1<br /><br />&nbsp; fail:<br /><br />&nbsp; &nbsp; return 0<br /><br />CpuClockSpeed endp<br /><br />end start<br /><br /><br /></code></pre></div>
    <div class="meta">Posted on 2011-05-08 08:49:37 by skywalker</div>
   </div>
   <div class="post" id="post-214356">
    <div class="subject"><a href="#post-214356">Re: CPU Speed</a></div>
    <div class="body">The problem is that i don&#039;t have any function, such as QueryPerformanceCounter. Plus, the kernel is a VERY simple kernel. So its me that has to implement the <strong>wait</strong> or <strong>sleep</strong> function. I was thinking in using the fact that <strong>timer tick</strong> ticks 18.2 times a second... but my readings will be imprecise, because i can&#039;t measure 1 second for example.<br /><br />After i have implemented a wait (or sleep) function, the rest is easy (or sort of).<br /><br />Any ideas?<br /><br />Thanx!<br /><br />P.D. I have already read carefuly the wiki page of osdev but still the problem persists (mainly because of the wait/sleep function).</div>
    <div class="meta">Posted on 2011-05-08 23:27:44 by cronos89</div>
   </div>
   <div class="post" id="post-214357">
    <div class="subject"><a href="#post-214357">Re: CPU Speed</a></div>
    <div class="body">Why would your readings be imprecise?<br />If you know the timer tick is 18.2 Hz, that&#039;s all you need to know, right?<br />You can just do RDTSC, then wait for X ticks, and call RDTSC again. The difference between RDTSCs is Y clock cycles.<br />Which means you have Y cycles per X/18.2 seconds.<br />From there it&#039;s trivial to work out how many cycles you have per second.<br /></div>
    <div class="meta">Posted on 2011-05-09 04:11:36 by Scali</div>
   </div>
   <div class="post" id="post-214369">
    <div class="subject"><a href="#post-214369">Re: CPU Speed</a></div>
    <div class="body">@cronos89<br />QueryPerformanceCounter is not always a good performance indicator specially for modern CPUs. CPUs that come with TurboBoost technology, their frequency changes depending on how busy the CPU determines to be. Another thing is with hyper-thread and multi-core CPUs doing out of order execution so multiple instructions may be executed at the same time.<br /><br />Actually, in Windows itself is hard to do really accurate and precise benchmarking. The reason is due to all the background services and you don&#039;t know when the kernel will take on and context switch from your benchmarking process to another background process Windows decide to run.<br /><br />Of course, there are ways to compensate to get a little more accurate and precise results. Techniques include setting your process to the highest possible priority (real-time) &nbsp;so that context switch happens as little as possible. Another is to use serializing instructions like CPUID so that your CPU would not do out-of order execution.<br /><br />You can try and modify Agner Fog&#039;s benchmarking code. The author has both x86 and x64, C/C++ and assembly code there; as well as for for multi-threaded programs. You can get it from this link: <a target="_blank" href="http://www.agner.org/optimize/testp.zip">http://www.agner.org/optimize/testp.zip</a> Or you can check his site for more: <a target="_blank" href="http://www.agner.org/optimize/">http://www.agner.org/optimize/</a><br /><br />Although your results will not always be the same for every run, you can try to get an average or some more complex statistic filtering to leave out some error due to the Windows kernel context switch or whatever other factor. And benchmarking on Windows is only useful when you are comparing results between two programs that are trying to do the same thing with different algorithms. So even you don&#039;t get the exact numbers, you still can tell which program is doing better.</div>
    <div class="meta">Posted on 2011-05-16 13:02:21 by banzemanga</div>
   </div>
   <div class="post" id="post-214370">
    <div class="subject"><a href="#post-214370">Re: CPU Speed</a></div>
    <div class="body">QueryPerformanceCounter queries the performance counter, which is a high-precision counter that has been integrated in chipsets since the Pentium era. It&#039;s not the clockspeed, nor does it depend on clockspeed/powersaving.<br /><br />Anyway, it doesn&#039;t apply to him, since he doesn&#039;t use Windows.</div>
    <div class="meta">Posted on 2011-05-16 18:58:18 by Scali</div>
   </div>
   <div class="post" id="post-214372">
    <div class="subject"><a href="#post-214372">Re: CPU Speed</a></div>
    <div class="body">Yes, you are right Scali.<br /><br />QueryPerformanceFrequency is the one that tells us the CPU frequency. Since cronos89 mentioned QueryPerformanceCounter, i was assuming he was doing benchmarking to check on algorithm bottlenecks.<br /><br />Last time i used QueryPerformanceCounter, it gave me way too inconsistent results every run. So that is why i went looking around for assembly solutions for benchmarking and that is how i found Agner Fog&#039;s site; which game me results with little error compared to QueryPerformanceCounter.<br /><br />Edit: Let me see if i get it right. What cronos89 is really trying to do is to check CPU&#039;s busy time.<br /><br />Edit2: Sorry. I keep babbling unrelated stuff. So, the task is that assuming that we don&#039;t know the CPU speed, we are writing a piece of code for our own OS to determine the CPU speed.</div>
    <div class="meta">Posted on 2011-05-17 12:48:42 by banzemanga</div>
   </div>
   <div class="post" id="post-214374">
    <div class="subject"><a href="#post-214374">Re: CPU Speed</a></div>
    <div class="body"><div class="quote">QueryPerformanceFrequency is the one that tells us the CPU frequency.</div><br /><br />No it doesn&#039;t. Have you ever tried calling it?<br />QPF gives you the frequency of the performance counter, not of the CPU.<br />On my PC it reports something like 135 MHz (my CPU is 3 GHz). The frequency may vary from one chipset to the next, but it is NOT the CPU frequency. The performance counter is a special counter in the chipset, as I said (the CPU has its own cycle counter, known as the TimeStamp Counter, which you can read with RDTSC. Together with another timer, you can work out how many cycles there are in a second. QPC/QPF can help you there).<br /><br />QPC/QPF can have very poor results if you don&#039;t have the proper chipset drivers installed. As it is a chipset function, the &#039;legacy&#039; chipset drivers that come with Windows will not use the hardware properly, and go into some kind of emulation. With the proper drivers for your chipset installed, the counter should have much better stability (although there can still be glitches for various reasons).</div>
    <div class="meta">Posted on 2011-05-17 13:46:06 by Scali</div>
   </div>
   <div class="post" id="post-214376">
    <div class="subject"><a href="#post-214376">Re: CPU Speed</a></div>
    <div class="body">@Scali<br />Hmmm... I just tested it right now and it works just like i described.<br />QPF reports me 1688Mhz which is close enough to my CPU actual speed of 1.7Ghz.<br /><br />I always have my drivers updated to the latest so i believe that should have never been the problem.<br />You can actually check around and you find that what i described is true.<br />QPC indeed does give me crazy results in every run in many modern processors.<br /><br />I remember it started when i tried my first code on my Core 2 Duo laptop and the results were different in every run.<br />Until to ran the program on my old custom AMD (single core) processor tower and the results were always the same.<br />And then started googling the reason for it and that is why i went after the assembly implementation of it.<br />I never had a multi-core AMD processor so i can&#039;t say about that though.<br /><br />Edit: Tried the same program on my Core 2 Duo laptop and QPF reports me 1.46Ghz of the marketed speed 1.5Ghz.<br />This means that either the value gotten from QPF has some errors or the marketed value is being rounded off.<br />Can&#039;t try the program on the old tower yet since i need to fix it first.</div>
    <div class="meta">Posted on 2011-05-17 19:15:18 by banzemanga</div>
   </div>
   <div class="post" id="post-214377">
    <div class="subject"><a href="#post-214377">Re: CPU Speed</a></div>
    <div class="body">banzemanga: It is not true.<br />Read MSDN: http://msdn.microsoft.com/en-us/library/ms644905(v=vs.85).aspx<br />Nowhere does it say that it is the CPU clockspeed.<br />It also specifically says &quot;The frequency cannot change while the system is running.&quot;<br />In fact, read this bit: http://msdn.microsoft.com/en-us/library/ee417693%28VS.85%29.aspx<br /><div class="quote">1.Use QueryPerformanceCounter and QueryPerformanceFrequency instead of RDTSC. These APIs may make use of RDTSC, but might instead make use of a timing devices on the motherboard or some other system services that provide high-quality high-resolution timing information.</div><br /><br />Bottom line is: QPF is NOT the correct way to check for CPU frequency. You may not assume that the performance counter is the TSC. It could be, but then again it could not be.</div>
    <div class="meta">Posted on 2011-05-18 04:44:38 by Scali</div>
   </div>
   <div class="post" id="post-214378">
    <div class="subject"><a href="#post-214378">Re: CPU Speed</a></div>
    <div class="body">@Scali<br />The article was made back in 2005. I have to say that it needs some updating.<br /><br />First, write a small program using QPF and try it on different machines.<br />You will see that it does indeed get the frequency in its own way.<br /><br />I have checked msdn&#039; site too before writing my QPF code.<br />To tell you the truth, the msdn article just reminds me how lousy their documentation can be at times.<br />There have been many times where i had to check from an outside source to get an answer about Windows API.<br /><br />Here is the line right after your quote.<br /><div class="quote">While RDTSC is much faster than QueryPerformanceCounter, since the latter is an API call, it is an API that can be called several hundred times per frame without any noticeable impact.</div><br />But as your benchmarking code gets large, the accuracy gets thrown out of the window.<br /><br />All of the sources i could get you about how inaccurate QPC is, are outside microsoft.<br />Since you won&#039;t believe anything but what Microsoft says i would like to stop but here are some sources.<br />http://www.virtualdub.org/blog/pivot/entry.php?id=106<br />http://www.red-gate.com/supportcenter/Content?p=ANTS%20Performance%20Profiler&amp;c=ANTS_Performance_Profiler%5Cknowledgebase%5Capp_speedstep.htm<br /><br />QPF is indeed the CPU frequency. How do i prove it? How do you get the time elapsed by your program using QPF and QPC?<br />By this formula:<br />TimeElapsed = QPC/QPF = Ticks/TicksPerSecond= constant/frequency = constant/(1/second) = constant*second<br /><br />Of course, QPF/QPC is still better than Windows&#039; TSC. I never said they are the same thing.<br />However, just like QPF/QPC is better than TSC, RDTSC is still better than QPF/QPC.<br />I remember doing that comparison between QPF/QPC and RDTSC when i modified Agner Fog&#039;s code for my own use.<br /><br />Of course, QPF/QPC are not everything to blame. Like i said from my first post, Windows itself is part of the problem.<br />Even RDTSC give me inconsistencies which Agner Fog tone them down by serializing instructions and setting the process priority to the highest.<br />However, if you do two benchmarking code; one QPF/QPC and another using RDTSC, you find that one is more accurate than the other.<br /><br /><div class="quote">QPF is NOT the correct way to check for CPU frequency.</div><br />I agree with you. But it is not bad when you need a quick way to do it right?</div>
    <div class="meta">Posted on 2011-05-18 15:44:49 by banzemanga</div>
   </div>
   <div class="post" id="post-214382">
    <div class="subject"><a href="#post-214382">Re: CPU Speed</a></div>
    <div class="body">Scali is correct that QPF isn&#039;t (not even close!) the correct way to check CPU frequency.<br /><br />On <strong>some systems</strong>, the &quot;performance counter&quot; will basically up being RDTSC, and (assuming no throttling/boost) then yeah - on <strong>that</strong> system, you get the CPU frequency.<br /><br />On other systems, it&#039;s totally separate timers (APIC timer? Been a while since I checked up on it). I&#039;ve seen systems reporting 1000Hz frequency, and obviously not on a 1KHz CPU ;)</div>
    <div class="meta">Posted on 2011-05-18 17:25:09 by f0dder</div>
   </div>
   <div class="post" id="post-214383">
    <div class="subject"><a href="#post-214383">Re: CPU Speed</a></div>
    <div class="body"><div class="quote"><br />@Scali<br />The article was made back in 2005. I have to say that it needs some updating.</div><br /><br />It doesn&#039;t need updating, the QPC/QPF API hasn&#039;t changed.<br /><br /><div class="quote"><br />First, write a small program using QPF and try it on different machines.<br />You will see that it does indeed get the frequency in its own way.</div><br /><br />As I said, sometimes it does, sometimes it doesn&#039;t.<br />This is a logical fallacy. You assume that QPF gives you the clockspeed, because you see that its result gives you the clockspeed.<br />The API spec says something different. You should take the API spec as the truth, and apply logic to that, rather than taking your interpretation of what the API does, based on your limited observations, and making generalizations which are partly in conflict with what the API specs say.<br /><br /><div class="quote"><br />To tell you the truth, the msdn article just reminds me how lousy their documentation can be at times.<br />There have been many times where i had to check from an outside source to get an answer about Windows API.</div><br /><br />The Windows API is arguably the best-documented API on the planet. I see nothing wrong with the QPC/QPF documentation either. They are very clear about what it does, how it differs from RDTSC and when you should or should not use it.<br /><br /><br /><div class="quote"><br />But as your benchmarking code gets large, the accuracy gets thrown out of the window.</div><br /><br />It&#039;s meant to be used as a timer, not as a cycle counter. RDTSC is meant to count cycles (although Intel more or less threw that out of the window when they decoupled the TSC from the actual clockspeed).<br /><br />Just give it up, I am not impresed by Microsoft-bashing.<br /><br /><div class="quote"><br />I agree with you. But it is not bad when you need a quick way to do it right?</div><br /><br />Yes it is. You cannot assume that QPF returns the clockspeed. As MSDN says, it might use another hardware timer instead, located on the motherboard (as I said, one of my machines always returns 135 MHz, that&#039;s a chipset timer, not the clockspeed, it&#039;s nowhere near the clockspeed). NEVER USE QPF TO GET THE CLOCKSPEED.<br />In Windows, a better quick-and-dirty way is to read it from the registry: HKLM\HARDWARE\DESCRIPTION\System\CentralProcessor\~MHz<br />This key is updated at every boot.<br /><br />The accuracy (or lack thereof) of QPC when performing timing is another matter altogether, and doesn&#039;t relate directly to obtaining the clockspeed.</div>
    <div class="meta">Posted on 2011-05-18 17:27:49 by Scali</div>
   </div>
   <div class="post" id="post-214390">
    <div class="subject"><a href="#post-214390">Re: CPU Speed</a></div>
    <div class="body">Ok... I see where my fallacy is. Thanks.<br /><br />You are saying that QPF might or might not use CPU&#039;s frequency.<br />Whereas, i was assuming will always use CPU&#039;s frequency as the timer when it might use another&#039;s device at certain times.<br /><br />Then here is a question, why QPF/QPC should be used as a timer for algorithm bottlenecks when it doesn&#039;t directly relate to the CPU performance?</div>
    <div class="meta">Posted on 2011-05-18 19:07:24 by banzemanga</div>
   </div>
   <div class="post" id="post-214393">
    <div class="subject"><a href="#post-214393">Re: CPU Speed</a></div>
    <div class="body"><br />Oh my, this again :)<br /><br />Short answer : before throttling/multicore, yes, one could argue rdtsc was the ultimate timer as well as cycle counter, if you do it yoursef correctly.<br />Before this you could program the 8053 or cmos rtc to generate a handgul of irqs per sec, then maybe the pentium apic internal timers. Then rdtsc was the silver bullet.<br /><br />Then again:<br />Multicore made rdtsc potentially buggy when the process is robbed from one core to the other. Then frequency throttling made it fuzzy and questionably trustful. Then now there may be even more advanced execution sophistication that interfere.<br /><br />Thats why QPC&#039;s goal is to provide a standardized way of having a decent timer. On modern systems it&#039;s arguably the most robust way. May not be enough to count cycles. I thought it was ok to assume it was at least dozens of MHz but given the above contributions it seems not.<br /></div>
    <div class="meta">Posted on 2011-05-18 22:45:44 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-214394">
    <div class="subject"><a href="#post-214394">Re: CPU Speed</a></div>
    <div class="body">I&#039;m not sure you understand that QPC/QPF has one and only one use:<br /><br />Getting to know how much realworld time has passed between one point in your code and another.<br /><br />All use cases derive from this one.<br /><br />Frequency of QPF is only relevant for knowing what best precision you *might* get from QPC.<br /></div>
    <div class="meta">Posted on 2011-05-18 22:50:24 by HeLLoWorld</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=30551&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=30551&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="30551" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=30551&amp;page=2">&gt;</a><a href="../?id=30551&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>