<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Comments on my call2opcd macro appreciated - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20144" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=20144">Comments on my call2opcd macro appreciated</a></p>
   <div class="post" id="post-154284">
    <div class="subject"><a href="#post-154284">Comments on my call2opcd macro appreciated</a></div>
    <div class="body">Hi,<br />I already posted this macro to the masm32forum, but haven't got any reply. Aditionally I know that these both sites visit different members, so I post it here too.<br /><br />For some specific reason I need to assemble the CALL instruction myself using the following MASM macro &quot;call2opcd&quot;.<br />I've tested this macro (with examples given in the code section) and it seems to be working well, but I appreciate your comments :)<br />There's a bunch of macros used by this macro, so if you want to compile this sample, download the package here: http://www.webpark.cz/mazegen/call2opcd_res.zip (4.5 KB), please (it seems that it is impossible to open this link directly from this site, so use cut&amp;paste in new panel/window, it should work). It also contains the following asm source code file.<br /><pre><code><br />; assumptions&#58;<br />;   o memory-access size is always 32 bits &#40;i.e. CALL AX returns compile-time error&#41;<br />;     - if the operand size is 32-bit, it is therefore near call<br />;   o if the argument references undefined symbol, it is either an user error or<br />;     a forward-referenced label&#58; macro always assumes it is the label<br /><br />call2opcd	MACRO	arg&#58;VARARG<br />local arg<br />local curreip		;; current EIP to fix relative offset<br />local start, end<br />local pos, tmp<br /><br /> IF @InStr &#40;, &lt;arg&gt;, &lt;,&gt;&#41;<br />   ErrorEcho &lt;&quot;call &amp;arg&quot; instruction, call2opcd macro&gt;, &lt;too many arguments to call&#58; arg&gt;<br />   EXITM<br /> ENDIF<br /><br /> IF @InStr &#40;, arg, &lt;$&gt;&#41;		;; label relative to EIP? &#40;e.g. CALL $+5&#41;<br />   BYTE 0E8H			;; relative direct call<br />   DWORD arg - 1 - curreip	;; minus 1 byte<br /><br /> ELSE<br /><br />   IFE $IsNoError &#40;arg&#41;		;; is it an user error or a forward-referenced label?<br />     BYTE 0E8H			;; always assume it is forward-referenced label<br />     DWORD arg - curreip<br /><br />   ELSE<br /><br />     IF $IsCodeLabel &#40;arg&#41;	;; is it backward-referenced label?<br />       BYTE 0E8H		;; relative direct call<br />       DWORD arg - curreip<br /><br />     ELSE			;; it is indirect call<br /><br />       IF $IsReg &#40;arg&#41;<br />         IFE &#40;$IsGeneralReg &#40;arg&#41;&#41; AND &#40;$GetSizeOf &#40;arg&#41; GT TYPE BYTE&#41;<br />           ErrorEcho &lt;&quot;call &amp;arg&quot; instruction, call2opcd macro&gt;, &lt;invalid operand &#58; arg&gt;<br />           EXITM<br />         ENDIF<br />         IF TYPE &#40;arg&#41; NE TYPE DWORD<br />           ErrorEcho &lt;&quot;call &amp;arg&quot; instruction, call2opcd macro&gt;, &lt;only DWORD operand supported &#58; arg&gt;<br />           EXITM<br />         ENDIF<br /><br />         start&#58;<br />         not arg		;; assemble needed opcode extension 010<br />         end&#58;<br /><br />         ORG start<br />         BYTE 0FFH		;; make call near<br />         ORG end<br /><br />       ELSE			;; it is indirect call, address given in memory<br />         IF TYPE &#40;arg&#41; EQ TYPE BYTE<br />           ErrorEcho &lt;&quot;call &amp;arg&quot; instruction, call2opcd macro&gt;, &lt;invalid operand &#58; arg&gt;<br />           EXITM<br />         ENDIF<br />         IFE &#40;TYPE &#40;arg&#41; EQ TYPE DWORD&#41; OR &#40;TYPE &#40;arg&#41; EQ TYPE FWORD&#41;<br />           ErrorEcho &lt;&quot;call &amp;arg&quot; instruction, call2opcd macro&gt;, \<br />                     &lt;only DWORD or FWORD operand supported &#58; arg&gt;<br />           EXITM<br />         ENDIF<br /><br />         start&#58;<br />         IF TYPE &#40;arg&#41; EQ TYPE DWORD<br />           ;; if 32-bit operand, always assume it is near call<br />           not arg		;; assemble needed opcode extension 010<br />         ELSE<br /><br />           ;; else it is far call&#58; always add &quot;dword ptr&quot; because of NEG instr<br /><br />           pos INSTR $lcase &#40;arg&#41;, &lt;ptr&gt;	;; is there any &quot;ptr&quot; already?<br />           IF pos				;; yea, replace this whole string<br />             tmp CATSTR &lt;dword ptr&gt;, @SubStr &#40;arg, pos + @SizeStr &#40;&lt;ptr&gt;&#41;&#41;<br />           ELSE<br />             tmp CATSTR &lt;dword ptr&gt;, &lt;arg&gt;<br />           ENDIF<br /><br />           neg tmp		;; assemble needed opcode extension 011<br />         ENDIF<br />         end&#58;<br /><br />         ORG start<br />         BYTE 0FFH		;; make call<br />         ORG end<br />       ENDIF<br /><br />     ENDIF<br />   ENDIF<br /> ENDIF<br /><br /> curreip = $<br /><br />ENDM<br /><br />.DATA<br /><br />neartarget DWORD ?<br />fartarget FWORD ?<br /><br />.CODE<br />Start&#58;<br /><br />; tests&#58;<br /><br /> call $+5<br /> call2opcd $+5			; explicit EIP-relative call to next instruction<br /> nop<br /><br /> call somelabel<br /> call2opcd somelabel		; forward-referenced label, relative call<br /> nop<br /><br /> call Start<br /> call2opcd Start		; backward-referenced label, relative call<br /> nop<br /><br /> call edi<br /> call2opcd edi			; absolute indirect near call, address given in register<br /> nop<br /><br /> call &#91;neartarget&#93;<br /> call2opcd &#91;neartarget&#93;		; absolute indirect near call, address given in memory<br /> nop<br /><br /> call &#91;fartarget&#93;<br /> call2opcd &#91;fartarget&#93;		; absolute indirect far call, address given in memory<br /> nop<br /><br /> call dword ptr &#91;edi&#93;<br /> call2opcd dword ptr &#91;edi&#93;	; absolute indirect near call, address given in memory<br /> nop<br /><br /> call fword ptr &#91;edi&#93;<br /> call2opcd fword ptr &#91;edi&#93;	; absolute indirect far call, address given in memory<br /><br />somelabel&#58;<br /><br />; error-trapping tests&#58;<br /><br />; call2opcd Start, somelabel<br />; call2opcd al<br />; call2opcd cs<br />; call2opcd byte ptr &#91;eax&#93;<br />; call2opcd word ptr &#91;eax&#93;<br /><br />END Start<br /></code></pre></div>
    <div class="meta">Posted on 2004-12-17 07:30:06 by MazeGen</div>
   </div>
  </div>
 </body>
</html>