<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>TASM and MASM - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=26340" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=26340">TASM and MASM</a></p>
   <div class="post" id="post-191172">
    <div class="subject"><a href="#post-191172">TASM and MASM</a></div>
    <div class="body">Can anybody tell me what's the difference betwen this 2 compilers, why sometimes Source codes that I downloaded from Internet can only be compiled in TASM and not MASM ? I have TASM 5.0 and MASM 6.2

Thank you</div>
    <div class="meta">Posted on 2000-12-16 23:56:00 by Kris Nguyen </div>
   </div>
   <div class="post" id="post-191173">
    <div class="subject"><a href="#post-191173">TASM and MASM</a></div>
    <div class="body">Some instructions and directives (or their syntax) are intended to be used in IDEAL mode in TASM.  These can only be processed with TASM.

Some extensions were done differently.  E.g., TASM extends the CALL syntax for listing arguments passed using C/C++ calling conventions.  MASM introduced the INVOKE instruction for the same purpose, leaving the CALL instruction untouched.

Complex macros work differently in subtle ways.

TASM 5 may still be compatible with older versions of MASM and TASM...

In TASM 4, the operators LARGE and SMALL were needed to force 32- or 16-bit constants for some machine instructions. MASM doesn't know about them.

MASM 6 changed the names of some directives--e.g., STRUC must now be STRUCT, EXTRN must now be EXTERN.  There is a way to make MASM 6 use the older forms by specifying MASM 5 mode.</div>
    <div class="meta">Posted on 2000-12-18 23:33:00 by tasm </div>
   </div>
   <div class="post" id="post-191174">
    <div class="subject"><a href="#post-191174">TASM and MASM</a></div>
    <div class="body">What he said.</div>
    <div class="meta">Posted on 2000-12-22 04:49:00 by TrUeMYth_ </div>
   </div>
   <div class="post" id="post-191175">
    <div class="subject"><a href="#post-191175">TASM and MASM</a></div>
    <div class="body">I don't think "tasm" is exactly right for instance when he says EXTRN *must* now be EXTERN; both variants are accepted.
But he does point out some differences.

In general, tasm is a better assembler in my opinion.  It's more flexible and more likely to do what you tell it to without trying to outsmart you.  For example, it's much better than masm at assembling and linking virus code (see Giant Black Book of Computer Viruses by Mark Ludwig).  By the way, I'm not into writing viruses but have studied Ludwig's book because it's the best way to get a good working knowledge of the PE file format.

Also, if you use the IDA disassembler you'll find that tasm5 will assemble the IDA asm listings with must less work than is required to get them to assemble with masm.  IDA uses a "generic" assembly listing which is ideal in terms of understanding what's really going on, and it's also closer to what tasm does and understands.  tasm also comes with a great tool implib.exe for making lib files from Windows system dll's.

But there are some disadvantages to using Borland products.  For instance, Borland uses the OMF (Intel Object Module Format) rather than coff, which is what Microsoft uses and which is a better and simpler format.

I use both masm and tasm, but find masm to be the more frustrating of the two.</div>
    <div class="meta">Posted on 2000-12-22 17:33:00 by A Mason </div>
   </div>
   <div class="post" id="post-191176">
    <div class="subject"><a href="#post-191176">TASM and MASM</a></div>
    <div class="body">Not to mention that TASM assembles very fast...much faster then MASM

you cant feel it into small projects...but into huge ones ...speed does matter...</div>
    <div class="meta">Posted on 2000-12-22 18:11:00 by BogdanOntanu</div>
   </div>
   <div class="post" id="post-191177">
    <div class="subject"><a href="#post-191177">TASM and MASM</a></div>
    <div class="body">By the way , WHAT is TASM's extended call syntax for that purpose ? 
" Some extensions were done differently. E.g., TASM extends the  CALL syntax for listing arguments passed using C/C++ calling conventions. MASM introduced the INVOKE instruction ..... "</div>
    <div class="meta">Posted on 2001-01-02 09:00:00 by NimbUs </div>
   </div>
   <div class="post" id="post-191178">
    <div class="subject"><a href="#post-191178">TASM and MASM</a></div>
    <div class="body">Originally, the CALL mnemonic was used for creating a single x86 instruction.  There is no single instruction for calling a subroutine with parameters.  If the parameters need to go on the stack (a la Win32), you needed to use PUSH instructions or simulate them.

TASM allows you to list the call parameters in the same line as the CALL instruction:

CALL GetMessage,offset msgbuf,NULL,0,0

but it will generate the necessary extra instructions depending on the specified calling convention.  In the case of STDCALL, the Win32 convention, it will generate PUSH instructions as well as the CALL instruction.

I'm not too sure of the syntax because I haven't used this CALL convention, as I needed MASM compatibility.  (I know, a simple search and replace converts it easily.)

It looks very much like the INVOKE instruction used in Iczelion's tutorials.

Incidentally, I believe the early versions of MASM 6 rejected the old mnemonics STRUC and EXTRN, unless a compatibility option was enabled.</div>
    <div class="meta">Posted on 2001-01-05 23:05:00 by tasm </div>
   </div>
  </div>
 </body>
</html>