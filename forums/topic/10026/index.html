<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Standart Input &amp; Standart Output - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=10026" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=47">Assemblers</a> &raquo; <a href="../?id=10026">Standart Input &amp; Standart Output</a></p>
   <div class="post" id="post-74933">
    <div class="subject"><a href="#post-74933">Standart Input &amp; Standart Output</a></div>
    <div class="body">is there are stdio include file for FASM out there ? i found one for NASM ... it allows me to use function like high level language (printing text, read strings or integers ...etc.)<br /><br /><pre><code><br /><br />%define NL 10<br />%define CF_MASK 00000001h<br />%define PF_MASK 00000004h<br />%define AF_MASK 00000010h<br />%define ZF_MASK 00000040h<br />%define SF_MASK 00000080h<br />%define DF_MASK 00000400h<br />%define OF_MASK 00000800h<br /><br /><br />;<br />; Linux C doesn't put underscores on labels<br />;<br />%ifdef ELF_TYPE<br />  %define _scanf   scanf<br />  %define _printf  printf<br />  %define _getchar getchar<br />  %define _putchar putchar<br />  %define _fputs   fputs<br />%endif<br /><br />%ifdef OBJ_TYPE<br />segment .data public align=4 class=data use32<br />%else<br />segment .data<br />%endif<br /><br />int_format	    db  &quot;%i&quot;, 0<br />string_format       db  &quot;%s&quot;, 0<br />reg_format	    db  &quot;Register Dump # %d&quot;, NL<br />		    db  &quot;EAX = %.8X EBX = %.8X ECX = %.8X EDX = %.8X&quot;, NL<br />                    db  &quot;ESI = %.8X EDI = %.8X EBP = %.8X ESP = %.8X&quot;, NL<br />                    db  &quot;EIP = %.8X FLAGS = %.4X %s %s %s %s %s %s %s&quot;, NL<br />	            db  0<br />carry_flag	    db  &quot;CF&quot;, 0<br />zero_flag	    db  &quot;ZF&quot;, 0<br />sign_flag	    db  &quot;SF&quot;, 0<br />parity_flag	    db	&quot;PF&quot;, 0<br />overflow_flag	    db	&quot;OF&quot;, 0<br />dir_flag	    db	&quot;DF&quot;, 0<br />aux_carry_flag	    db	&quot;AF&quot;, 0<br />unset_flag	    db	&quot;  &quot;, 0<br />mem_format1         db  &quot;Memory Dump # %d Address = %.8X&quot;, NL, 0<br />mem_format2         db  &quot;%.8X &quot;, 0<br />mem_format3         db  &quot;%.2X &quot;, 0<br />stack_format        db  &quot;Stack Dump # %d&quot;, NL<br />	            db  &quot;EBP = %.8X ESP = %.8X&quot;, NL, 0<br />stack_line_format   db  &quot;%+4d  %.8X  %.8X&quot;, NL, 0<br />math_format1        db  &quot;Math Coprocessor Dump # %d Control Word = %.4X&quot;<br />                    db  &quot; Status Word = %.4X&quot;, NL, 0<br />valid_st_format     db  &quot;ST%d&#58; %.10g&quot;, NL, 0<br />invalid_st_format   db  &quot;ST%d&#58; Invalid ST&quot;, NL, 0<br />empty_st_format     db  &quot;ST%d&#58; Empty&quot;, NL, 0<br /><br />;<br />; code is put in the _TEXT segment<br />;<br />%ifdef OBJ_TYPE<br />segment text public align=1 class=code use32<br />%else<br />segment .text<br />%endif<br />	global	read_int, print_int, print_string, read_char<br />	global  print_char, print_nl, sub_dump_regs, sub_dump_mem<br />        global  sub_dump_math, sub_dump_stack<br />        extern  _scanf, _printf, _getchar, _putchar, _fputs<br /><br />read_int&#58;<br />	enter	4,0<br />	pusha<br />	pushf<br /><br />	lea	eax, &#91;ebp-4&#93;<br />	push	eax<br />	push	dword int_format<br />	call	_scanf<br />	pop	ecx<br />	pop	ecx<br />	<br />	popf<br />	popa<br />	mov	eax, &#91;ebp-4&#93;<br />	leave<br />	ret<br /><br />print_int&#58;<br />	enter	0,0<br />	pusha<br />	pushf<br /><br />	push	eax<br />	push	dword int_format<br />	call	_printf<br />	pop	ecx<br />	pop	ecx<br /><br />	popf<br />	popa<br />	leave<br />	ret<br /><br />print_string&#58;<br />	enter	0,0<br />	pusha<br />	pushf<br /><br />	push	eax<br />	push    dword string_format<br />	call	_printf<br />	pop	ecx<br />	pop	ecx<br /><br />	popf<br />	popa<br />	leave<br />	ret<br /><br />read_char&#58;<br />	enter	4,0<br />	pusha<br />	pushf<br /><br />	call	_getchar<br />	mov	&#91;ebp-4&#93;, eax<br /><br />	popf<br />	popa<br />	mov	eax, &#91;ebp-4&#93;<br />	leave<br />	ret<br /><br />print_char&#58;<br />	enter	0,0<br />	pusha<br />	pushf<br /><br />	push	eax<br />	call	_putchar<br />	pop	ecx<br /><br />	popf<br />	popa<br />	leave<br />	ret<br /><br /><br />print_nl&#58;<br />	enter	0,0<br />	pusha<br />	pushf<br /><br />	push	dword 10	; 10 == ASCII code for \n<br />	call	_putchar<br />	pop	ecx<br /><br />	popf<br />	popa<br />	leave<br />	ret<br /><br /><br />sub_dump_regs&#58;<br />	enter   4,0<br />	pusha<br />	pushf<br />	mov     eax, &#91;esp&#93;      ; read FLAGS back off stack<br />	mov	&#91;ebp-4&#93;, eax    ; save flags<br /><br />;<br />; show which FLAGS are set<br />;<br />	test	eax, CF_MASK<br />	jz	cf_off<br />	mov	eax, carry_flag<br />	jmp	short push_cf<br />cf_off&#58;<br />	mov	eax, unset_flag<br />push_cf&#58;<br />	push	eax<br /><br />	test	dword &#91;ebp-4&#93;, PF_MASK<br />	jz	pf_off<br />	mov	eax, parity_flag<br />	jmp	short push_pf<br />pf_off&#58;<br />	mov	eax, unset_flag<br />push_pf&#58;<br />	push	eax<br /><br />	test	dword &#91;ebp-4&#93;, AF_MASK<br />	jz	af_off<br />	mov	eax, aux_carry_flag<br />	jmp	short push_af<br />af_off&#58;<br />	mov	eax, unset_flag<br />push_af&#58;<br />	push	eax<br /><br />	test	dword &#91;ebp-4&#93;, ZF_MASK<br />	jz	zf_off<br />	mov	eax, zero_flag<br />	jmp	short push_zf<br />zf_off&#58;<br />	mov	eax, unset_flag<br />push_zf&#58;<br />	push	eax<br /><br />	test	dword &#91;ebp-4&#93;, SF_MASK<br />	jz	sf_off<br />	mov	eax, sign_flag<br />	jmp	short push_sf<br />sf_off&#58;<br />	mov	eax, unset_flag<br />push_sf&#58;<br />	push	eax<br /><br />	test	dword &#91;ebp-4&#93;, DF_MASK<br />	jz	df_off<br />	mov	eax, dir_flag<br />	jmp	short push_df<br />df_off&#58;<br />	mov	eax, unset_flag<br />push_df&#58;<br />	push	eax<br /><br />	test	dword &#91;ebp-4&#93;, OF_MASK<br />	jz	of_off<br />	mov	eax, overflow_flag<br />	jmp	short push_of<br />of_off&#58;<br />	mov	eax, unset_flag<br />push_of&#58;<br />	push	eax<br /><br />	push    dword &#91;ebp-4&#93;   ; FLAGS<br />	mov	eax, &#91;ebp+4&#93;<br />	sub	eax, 10         ; EIP on stack is 10 bytes ahead of orig<br />	push	eax             ; EIP<br />	lea     eax, &#91;ebp+12&#93;<br />	push    eax             ; original ESP<br />	push    dword &#91;ebp&#93;     ; original EBP<br />        push    edi<br />        push    esi<br />	push    edx<br />	push	ecx<br />	push	ebx<br />	push	dword &#91;ebp-8&#93;   ; original EAX<br />	push	dword &#91;ebp+8&#93;   ; # of dump<br />	push	dword reg_format<br />	call	_printf<br />	add	esp, 76<br />	popf<br />	popa<br />	leave<br />	ret     4<br /><br />sub_dump_stack&#58;<br />	enter   0,0<br />	pusha<br />	pushf<br /><br />	lea     eax, &#91;ebp+20&#93;<br />	push    eax             ; original ESP<br />	push    dword &#91;ebp&#93;     ; original EBP<br />	push	dword &#91;ebp+8&#93;   ; # of dump<br />	push	dword stack_format<br />	call	_printf<br />	add	esp, 16<br /><br />	mov	ebx, &#91;ebp&#93;	; ebx = original ebp<br />	mov	eax, &#91;ebp+16&#93;   ; eax = # dwords above ebp<br />	shl	eax, 2          ; eax *= 4<br />	add	ebx, eax	; ebx = &amp; highest dword in stack to display<br />	mov	edx, &#91;ebp+16&#93;<br />	mov	ecx, edx<br />	add	ecx, &#91;ebp+12&#93;<br />	inc	ecx		; ecx = # of dwords to display<br /><br />stack_line_loop&#58;<br />	push	edx<br />	push	ecx		; save ecx &amp; edx<br /><br />	push	dword &#91;ebx&#93;	; value on stack<br />	push	ebx		; address of value on stack<br />	mov	eax, edx<br />	sal	eax, 2		; eax = 4*edx<br />	push	eax		; offset from ebp<br />	push	dword stack_line_format<br />	call	_printf<br />	add	esp, 16<br /><br />	pop	ecx<br />	pop	edx<br /><br />	sub	ebx, 4<br />	dec	edx<br />	loop	stack_line_loop<br /><br />	popf<br />	popa<br />	leave<br />	ret     12<br /><br /><br />sub_dump_mem&#58;<br />	enter	0,0<br />	pusha<br />	pushf<br /><br />	push	dword &#91;ebp+12&#93;<br />	push	dword &#91;ebp+16&#93;<br />	push	dword mem_format1<br />	call	_printf<br />	add	esp, 12		<br />	mov	esi, &#91;ebp+12&#93;      ; address<br />	and	esi, 0FFFFFFF0h    ; move to start of paragraph<br />	mov	ecx, &#91;ebp+8&#93;<br />	inc	ecx<br />mem_outer_loop&#58;<br />	push	ecx<br />	push	esi<br />	push	dword mem_format2<br />	call	_printf<br />	add	esp, 8<br /><br />	xor	ebx, ebx<br />mem_hex_loop&#58;<br />	xor	eax, eax<br />	mov	al, &#91;esi + ebx&#93;<br />	push	eax<br />	push	dword mem_format3<br />	call	_printf<br />	add	esp, 8<br />	inc	ebx<br />	cmp	ebx, 16<br />	jl	mem_hex_loop<br />	<br />	mov	eax, '&quot;'<br />	call	print_char<br />	xor	ebx, ebx<br />mem_char_loop&#58;<br />	xor	eax, eax<br />	mov	al, &#91;esi+ebx&#93;<br />	cmp	al, 32<br />	jl	non_printable<br />	cmp	al, 126<br />	jg	non_printable<br />	jmp	short mem_char_loop_continue<br />non_printable&#58;<br />	mov	eax, '?'<br />mem_char_loop_continue&#58;<br />	call	print_char<br /><br />	inc	ebx<br />	cmp	ebx, 16<br />	jl	mem_char_loop<br /><br />	mov	eax, '&quot;'<br />	call	print_char<br />	call	print_nl<br /><br />	add	esi, 16<br />	pop	ecx<br />	loop	mem_outer_loop<br /><br />	popf<br />	popa<br />	leave<br />	ret	12<br /><br />; function sub_dump_math<br />;   prints out state of math coprocessor without modifying the coprocessor<br />;   or regular processor state<br />; Parameters&#58;<br />;  dump number - dword at &#91;ebp+8&#93;<br />; Local variables&#58;<br />;   ebp-108 start of fsave buffer<br />;   ebp-116 temp double<br />; Notes&#58; This procedure uses the Pascal convention.<br />;   fsave buffer structure&#58;<br />;   ebp-108   control word<br />;   ebp-104   status word<br />;   ebp-100   tag word<br />;   ebp-80    ST0<br />;   ebp-70    ST1<br />;   ebp-60    ST2 ...<br />;   ebp-10    ST7<br />;<br />sub_dump_math&#58;<br />	enter	116,0<br />	pusha<br />	pushf<br /><br />	fsave	&#91;ebp-108&#93;	; save coprocessor state to memory<br />	mov	eax, &#91;ebp-104&#93;  ; status word<br />	and	eax, 0FFFFh<br />	push	eax<br />	mov	eax, &#91;ebp-108&#93;  ; control word<br />	and	eax, 0FFFFh<br />	push	eax<br />	push	dword &#91;ebp+8&#93;<br />	push	dword math_format1<br />	call	_printf<br />	add	esp, 16<br />;<br />; rotate tag word so that tags in same order as numbers are<br />; in the stack<br />;<br />	mov	cx, &#91;ebp-104&#93;	; ax = status word<br />	shr	cx, 11<br />	and	cx, 7           ; cl = physical state of number on stack top<br />	mov	bx, &#91;ebp-100&#93;   ; bx = tag word<br />	shl     cl,1		; cl *= 2<br />	ror	bx, cl		; move top of stack tag to lowest bits<br /><br />	mov	edi, 0		; edi = stack number of number<br />	lea	esi, &#91;ebp-80&#93;   ; esi = address of ST0<br />	mov	ecx, 8          ; ecx = loop counter<br />tag_loop&#58;<br />	push	ecx<br />	mov	ax, 3<br />	and	ax, bx		; ax = current tag<br />	or	ax, ax		; 00 -&gt; valid number<br />	je	valid_st<br />	cmp	ax, 1		; 01 -&gt; zero<br />	je	zero_st<br />	cmp	ax, 2		; 10 -&gt; invalid number<br />	je	invalid_st<br />	push	edi		; 11 -&gt; empty<br />	push	dword empty_st_format<br />	call	_printf<br />	add	esp, 8<br />	jmp	short cont_tag_loop<br />zero_st&#58;<br />	fldz<br />	jmp	short print_real<br />valid_st&#58;<br />	fld	tword &#91;esi&#93;<br />print_real&#58;<br />	fstp	qword &#91;ebp-116&#93;<br />	push	dword &#91;ebp-112&#93;<br />	push	dword &#91;ebp-116&#93;<br />	push	edi<br />	push	dword valid_st_format<br />	call	_printf<br />	add	esp, 16<br />	jmp	short cont_tag_loop<br />invalid_st&#58;<br />	push	edi<br />	push	dword invalid_st_format<br />	call	_printf<br />	add	esp, 8<br />cont_tag_loop&#58;<br />	ror	bx, 2		; mov next tag into lowest bits<br />	inc	edi<br />	add	esi, 10         ; mov to next number on stack<br />	pop	ecx<br />	loop    tag_loop<br /><br />	frstor	&#91;ebp-108&#93;       ; restore coprocessor state<br />	popf<br />	popa<br />	leave<br />	ret	4<br /><br /></code></pre></div>
    <div class="meta">Posted on 2003-01-07 18:45:22 by AstroCoder</div>
   </div>
   <div class="post" id="post-75032">
    <div class="subject"><a href="#post-75032">Standart Input &amp; Standart Output</a></div>
    <div class="body">is there are &quot;stdio&quot; include file for FASM out there ? :(</div>
    <div class="meta">Posted on 2003-01-08 05:09:01 by AstroCoder</div>
   </div>
   <div class="post" id="post-75045">
    <div class="subject"><a href="#post-75045">Standart Input &amp; Standart Output</a></div>
    <div class="body">AstroCoder,<br /><br />You can also use the functions from C run-time dlls,just have a look at the attachments:<br /><br /><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=9531&amp;highlight=cdecl+macros">http://www.asmcommunity.net/board/index.php?topic=9531&amp;highlight=cdecl+macros</a><br /><br />I am afraid there is no &quot;stdio.inc&quot; file for the FASM package.<br /><br />Regards,<br /><br />Vortex</div>
    <div class="meta">Posted on 2003-01-08 06:19:38 by Vortex</div>
   </div>
   <div class="post" id="post-75057">
    <div class="subject"><a href="#post-75057">Standart Input &amp; Standart Output</a></div>
    <div class="body">:alright:  thank you Vortex !</div>
    <div class="meta">Posted on 2003-01-08 08:17:57 by AstroCoder</div>
   </div>
  </div>
 </body>
</html>