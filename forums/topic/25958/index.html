<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Making a .dll to interface with VB - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=25958" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=25958">Making a .dll to interface with VB</a></p>
   <div class="post" id="post-189185">
    <div class="subject"><a href="#post-189185">Making a .dll to interface with VB</a></div>
    <div class="body">I posted this in recruiting forum as well.&nbsp; I am new to this board and just getting back into ASM (I used it back in the win 3.1 days)<br />Basically here is where I am stuck:&nbsp; I am doing a very simple encryption routine, read source file and key file, XOR and write to output file.&nbsp; Simple, right?&nbsp; the problem is I would like to make this as a .dll and call the procedure from high level languages, in this case VB.&nbsp; I would like to call it as such:<br />Proc_Name (input_file_path, key_file_path, output_file_path all as strings and then Offset being a long number which signifies where in the key to start reading)<br /><br />I have my code below (any input would be great, too) but my problem is how to set it up to be able to be called from VB.&nbsp; Any advice?&nbsp; Thanks!<br /><br /><br />.Data<br /><br />SourceBuffer&nbsp; &nbsp; DB 256 Dup (0)<br />KeyBuffer&nbsp; &nbsp; &nbsp; DB 256 Dup (0)<br />OutBuffer&nbsp; &nbsp; &nbsp; DB 256 Dup (0)<br />InFileName&nbsp; &nbsp; &nbsp; DB 512 Dup (0)<br />KeyFileName&nbsp; &nbsp; &nbsp; DB 512 Dup (0)<br />OutFileName&nbsp; &nbsp; &nbsp; DB 512 Dup (0)<br /><br />hInFile&nbsp; &nbsp; &nbsp; &nbsp;  DW<br />hKeyFile&nbsp; &nbsp; &nbsp; DW<br />hOutFile&nbsp; &nbsp; &nbsp; DW<br />BytesRead&nbsp; &nbsp; &nbsp; DB<br /><br />CryptFile Proc Public<br />;// Open Source file to be crypted<br />&nbsp;  Mov Ah, 3DH&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Open function<br />&nbsp;  Mov Al, 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;as Read<br />&nbsp;  Lea Dx, InFileName&nbsp; &nbsp; &nbsp; ;Specify which file to open<br />&nbsp;  Int 21H&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Open<br />&nbsp;  Jc _Error_Occured&nbsp; &nbsp; &nbsp; ;if no error occured then<br />&nbsp;  Mov hInFile, Ax&nbsp; &nbsp; &nbsp; &nbsp;  ;store handle<br /><br />;// Open Key file to be used<br />&nbsp;  Mov Ah, 3DH&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Open function<br />&nbsp;  Mov Al, 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;as Random access (since I need to jump to offset of encryption start)<br />&nbsp;  Lea Dx, InFileName&nbsp; &nbsp; &nbsp; ;Specify which file to open<br />&nbsp;  Int 21H&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Open<br />&nbsp;  Jc _Error_Occured&nbsp; &nbsp; &nbsp; ;if no error occured then<br />&nbsp;  Mov hKeyFile, Ax&nbsp; &nbsp; &nbsp; ;store handle<br /><br />;// Create output file to be written<br />&nbsp;  Mov Ah, 3CH&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Create function<br />&nbsp;  Xor Cx, Cx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;blank out cx (for file attributes)<br />&nbsp;  Lea Dx, InFileName&nbsp; &nbsp; &nbsp; ;Specify which file to open<br />&nbsp;  Int 21H&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Create<br />&nbsp;  Jc _Error_Occured&nbsp; &nbsp; &nbsp; ;if no error occured then<br />&nbsp;  Mov hOutFile, Ax&nbsp; &nbsp; &nbsp; ;store handle<br /><br />;// Move key file&#39;s pointer to the offset required<br />&nbsp;  Mov Ah, 42H&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Seek function<br />&nbsp;  Mov Al, 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;set as offset is specified from the start of key file<br />&nbsp;  Mov Bx, hKeyFile&nbsp; &nbsp; &nbsp; ;load key file&#39;s handle to bx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Here Load CX:DX with offset needed in key file<br />&nbsp;  Int 21H<br />&nbsp;  Jc _Error_Occured&nbsp; &nbsp; &nbsp; ;End if error occured (file size vs offset size checked in VB)<br /><br />;// Begin read and encrypt loop<br />_ReadAndXOR:<br />;// Read 512 bytes from Source file<br />&nbsp;  Mov Ah, 3FH&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Read file function<br />&nbsp;  Lea Dx, SourceBuffer&nbsp;  ;With 512 byte source buffer as storage location<br />&nbsp;  Mov Cx, 256&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;set length to 256<br />&nbsp;  Mov Bx, hInFile&nbsp; &nbsp; &nbsp; &nbsp;  ;set input file&#39;s handel to bx<br />&nbsp;  Int 21H&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;call int<br />&nbsp;  Jc _Error_Occured&nbsp; &nbsp; &nbsp; ;End if error occured<br />&nbsp;  Cmp Ax, 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;AX now holds actual bytes read, make sure data was read (in case file was an even multiple of 256)<br />&nbsp;  Je _Finished_Reading_Source_File<br /><br />;// Read from key, same number of btyes<br />;// Read 512 bytes from Source file<br />&nbsp;  Mov Cx, Ax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;move the actual bytes read from AX, to CX<br />&nbsp;  Mov BytesRead, Cx&nbsp; &nbsp; &nbsp; ;Store how many bytes were actually read to memory<br />&nbsp;  Mov Ah, 3FH&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Read file function<br />&nbsp;  Lea Dx, KeyBuffer&nbsp; &nbsp; &nbsp; ;With 512 byte source buffer as storage location<br />&nbsp;  Mov Bx, hKeyFile&nbsp; &nbsp; &nbsp; ;set input file&#39;s handel to bx<br />&nbsp;  Int 21H&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;call int<br />&nbsp;  Jc _Error_Occured&nbsp; &nbsp; &nbsp; ;End if error occured<br /><br />;//XOR loop<br />_XORloop:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;CX should still hold actual bytes read from source<br />&nbsp;  Mov Si, 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;zero out SI<br />&nbsp;  Mov Al, SourceBuffer ;Get first byte from source file to al<br />&nbsp;  Mov Ah, KeyBuffer&nbsp; &nbsp; ;Get first byte from key file to ah<br />&nbsp;  Xor Ah, Al&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;xor and store result in ah<br />&nbsp;  Mov OutBuffer, Ah&nbsp;  ;move XOR&#39;d value to output string<br />&nbsp;  Inc Si&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;increase SI by 1<br />&nbsp;  Loop _XORloop&nbsp; &nbsp; &nbsp; &nbsp;  ;Loop for length of string read<br /><br />;// When all bytes are read<br />&nbsp;  Mov Cx, BytesRead&nbsp; &nbsp; &nbsp; ;Store how many bytes were actually read from memory to CX for writing length to crypted file<br />&nbsp;  Mov Ah, 40H&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Set ah=write function<br />&nbsp;  Mov Bx, hOutFile&nbsp; &nbsp; &nbsp; ;BX = output file&#39;s handle<br />&nbsp;  Lea Dx, OutBuffer&nbsp; &nbsp; &nbsp; ;point dx to location of output string<br />&nbsp;  Int 21H&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;and write<br />&nbsp;  Jc _Error_Occured&nbsp; &nbsp; &nbsp; ;<br />&nbsp;  Cmp Ax, 256&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Does # of bytes written=256?<br />&nbsp;  Je _ReadAndXOR&nbsp; &nbsp; &nbsp; &nbsp;  ;If not then EOF was reached, so jump to exit.&nbsp; if yes then do another iteration of read and XORing<br /><br /><br />_Finished_Reading_Source_File:<br />_Error_Occured:<br />&nbsp;  Mov Ah, 3EH&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;close file function<br />&nbsp;  Mov Bx, hInFile&nbsp; &nbsp; &nbsp; &nbsp;  ;BX= source file handle<br />&nbsp;  Int 21H&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;close<br /><br />&nbsp;  Mov Ah, 3EH&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;close file function<br />&nbsp;  Mov Bx, hKeyFile&nbsp; &nbsp; &nbsp; ;BX= key file handle<br />&nbsp;  Int 21H&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;clsoe<br /><br />&nbsp;  Mov Ah, 3EH&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;close file function<br />&nbsp;  Mov Bx, hOutFile&nbsp; &nbsp; &nbsp; ;BX= output file handle<br />&nbsp;  Int 21H&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;close<br /><br />&nbsp;  Ret<br />CryptFile EndP</div>
    <div class="meta">Posted on 2007-05-11 15:40:34 by Command_Prompt</div>
   </div>
   <div class="post" id="post-189186">
    <div class="subject"><a href="#post-189186">Re: Making a .dll to interface with VB</a></div>
    <div class="body">It depends on what assembler/linker you use. Each has its own parameters. What you want to do is to make this proc &#39;public&#39; and &#39;export&#39; it. But know that you can&#39;t make a Windows DLL with DOS interrupts (at least not on any modern Windows). You have to use WinAPI calls and make a fully 32-bit/64-bit DLL.</div>
    <div class="meta">Posted on 2007-05-11 18:13:39 by ti_mo_n</div>
   </div>
   <div class="post" id="post-189190">
    <div class="subject"><a href="#post-189190">Re: Making a .dll to interface with VB</a></div>
    <div class="body">Shoot.&nbsp; Well thanks for the hasty reply Ti.&nbsp; Is there a place on this forum that would have a list of the calls?&nbsp; I really would like to get this done fast although it looks like it will take more catching up&nbsp; :sad:.&nbsp; The program I have written already is all in VB and is quite functional but slow in terms of larger files.&nbsp; This was a hope to upgrade the slow part.&nbsp; I noticed that the wiki asm book has a lot of links that don&#39;t seem to be working yet.&nbsp; Any other place where I can find info on the new commands?<br /><br />SOB, my old school asm learning wasted!&nbsp; ;)</div>
    <div class="meta">Posted on 2007-05-11 19:24:42 by Command_Prompt</div>
   </div>
   <div class="post" id="post-189195">
    <div class="subject"><a href="#post-189195">Re: Making a .dll to interface with VB</a></div>
    <div class="body">Well, the code is still asm, so you code the same way you used to (with only minor changes ). The real difference lies in the communication with the Operating System: In DOS you use &quot;int xx&quot;, while in Windows you &#39;call&#39; a procedure *<sup>1)</sup>. PE-EXE loader patches these calls with proper addresses when it starts up your exe/dll, so you just &#39;tell it&#39; which function you want to use at a particular place in your code. Please read &quot;Iczelion&#39;s tutorials&quot;. If you&#39;ve ever coded in asm, then you should be able to catch the differences between DOS and Windows very quickly ;) And there is a tutorial on making a DLL, IIRC.<br /><br /><br />*1) Also, in DOS you store every parameter in registers, while in Windows you &#39;push&#39; parameters onto the stack before calling a Win32API function.</div>
    <div class="meta">Posted on 2007-05-11 23:02:19 by ti_mo_n</div>
   </div>
   <div class="post" id="post-189201">
    <div class="subject"><a href="#post-189201">Re: Making a .dll to interface with VB</a></div>
    <div class="body">Cool, thanks for the info.&nbsp; I am getting started on ICZ&#39;s tutorial as we speak.&nbsp; Seems fairly simply enough.&nbsp; Hopefully I can get some help when I get the new .dll put together in the newer asm...(DARN YOU BILL GATES!).</div>
    <div class="meta">Posted on 2007-05-12 06:54:34 by Command_Prompt</div>
   </div>
  </div>
 </body>
</html>