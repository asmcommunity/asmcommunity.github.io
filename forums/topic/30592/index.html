<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Word size? - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30592" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=30592">Word size?</a></p>
   <div class="post" id="post-214573">
    <div class="subject"><a href="#post-214573">Word size?</a></div>
    <div class="body">when i write a program in assembly and i define a variable of &quot;word&quot; size.....is it truly the natural word size of my processor? for example on an i7 64bit processor will it be the size of 64bits.....or will it be defined as how microsoft defines the size of a words &quot;A WORD is a 16-bit unsigned integer&quot; ?<br /></div>
    <div class="meta">Posted on 2011-07-11 11:25:31 by dougfunny</div>
   </div>
   <div class="post" id="post-214574">
    <div class="subject"><a href="#post-214574">Re: Word size?</a></div>
    <div class="body">As you already demonstrated, it entirely depends on the context... and the x86 makes it even more complex because of the co-existence of different operating modes.<br /><br />Even for an x86-64 processor, some definitions for a <em>word</em> may mean 16-bit, 32-bit or 64-bit.<br /><br />x86 assembly language, as a general/de-facto notation, defines a WORD to be 16-bits.<br /><br />So no, a word-sized data type in x86 assembly language generally will not be the natural word size of your processor, but it may be the natural word size of the operating mode (e.g. 16-bit Real Mode) that your processor is currently in.</div>
    <div class="meta">Posted on 2011-07-11 11:57:49 by SpooK</div>
   </div>
   <div class="post" id="post-214575">
    <div class="subject"><a href="#post-214575">Re: Word size?</a></div>
    <div class="body">For more info, see <a target="_blank" href="http://en.wikipedia.org/wiki/Word_%28computer_architecture%29#Size_families">Word (computer architecture) @ Wikipedia</a>.</div>
    <div class="meta">Posted on 2011-07-11 12:02:42 by SpooK</div>
   </div>
   <div class="post" id="post-214576">
    <div class="subject"><a href="#post-214576">Re: Word size?</a></div>
    <div class="body">I think the short version is just this:<br />On the original 8086, a word was 16-bit, the natural word size of the processor.<br /><br />Since all x86 processors since have remained backward-compatible, the definition of &#039;word&#039; remained the same, to avoid ambiguities.</div>
    <div class="meta">Posted on 2011-07-11 15:59:00 by Scali</div>
   </div>
   <div class="post" id="post-214600">
    <div class="subject"><a href="#post-214600">Re: Word size?</a></div>
    <div class="body">As SpooK already said, it depends on context; when speaking assembly with x86 (assembly) programmers, &#039;word&#039; will <em>usually</em> mean a 16-bit quantity (but there&#039;s probably some of the gnu guys who&#039;ll insist otherwise).<br /><br />When reading compiler theory and whatnot, a term like &#039;machine word&#039; will usually mean the native size... and to confuse matters even further, on x86, &#039;native size&#039; depends on the mode you&#039;re running in, not just your CPU. An x64 CPU can run in 16-bit real and protected modes, 32bit protected mode, and 64bit (long) protected mode.<br /></div>
    <div class="meta">Posted on 2011-07-13 17:06:11 by f0dder</div>
   </div>
   <div class="post" id="post-214620">
    <div class="subject"><a href="#post-214620">Re: Word size?</a></div>
    <div class="body">or 32 bit real mode!<br /><br />okay, okay, i&#039;m leaving :)<br /><br />btw, never looked much into x86-64.<br />I wonder if there exists the possibility of unreal style full 64 bit mode, i mean, no paging, no protection, no tasks, 64b data seg and 64b code and stack segs.<br /></div>
    <div class="meta">Posted on 2011-07-16 16:05:39 by HeLLoWorld</div>
   </div>
   <div class="post" id="post-214621">
    <div class="subject"><a href="#post-214621">Re: Word size?</a></div>
    <div class="body"><div class="quote"><br />When reading compiler theory and whatnot, a term like &#039;machine word&#039; will usually mean the native size... and to confuse matters even further, on x86, &#039;native size&#039; depends on the mode you&#039;re running in, not just your CPU. An x64 CPU can run in 16-bit real and protected modes, 32bit protected mode, and 64bit (long) protected mode.<br /></div><br /><br />I guess that depends on your meaning of the word &#039;native&#039;.<br />I&#039;d say that for a 64-bit capable CPU, the &#039;native&#039; mode is 64-bit, because I believe that the original meaning of the term &#039;word&#039; is to refer to hardware capabilities, so you need to look at ALU and register levels, not the actual execution environments that the CPU may offer.</div>
    <div class="meta">Posted on 2011-07-16 16:56:43 by Scali</div>
   </div>
   <div class="post" id="post-214622">
    <div class="subject"><a href="#post-214622">Re: Word size?</a></div>
    <div class="body"><div class="quote"><br />I wonder if there exists the possibility of unreal style full 64 bit mode, i mean, no paging, no protection, no tasks, 64b data seg and 64b code and stack segs.<br /></div><br /><br />Paging is a prerequisite to enter 64-bit Long Mode, my best guess is due to the 52-bit physical address space limitation of the architecture (perhaps to save on design complexity?) and the variable/canonical virtual address space (scalable upgrade path) that may approach full 64-bit some day.<br /><br />None-the-less, it would be interesting to know if a true flat/physical 64-bit mode is feasible within the x86-64 architecture... even if the address space was truncated to 52-bit. My guess is no, as the chances are great that we would have seen it in action by now if it were possible.<br /><br />The closest way to achieve this is via identity mapping, which should be more than feasible with 2MB and 1GB pages, but speaks nothing about the caches and whatnot.</div>
    <div class="meta">Posted on 2011-07-16 18:13:29 by SpooK</div>
   </div>
  </div>
 </body>
</html>