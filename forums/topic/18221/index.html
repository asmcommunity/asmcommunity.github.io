<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Fail to enum system processes... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=18221" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=18221">Fail to enum system processes...</a></p>
   <div class="post" id="post-140932">
    <div class="subject"><a href="#post-140932">Fail to enum system processes...</a></div>
    <div class="body">I want to enum system processes and display therir filename..<br /><br />When I use GetModuleFileNameEx() via Psapi lib of MASM32, It works normally,<br />but it terminates exceptionally when I used  the GetModuleFileNameEx() address got by call GetProcAddress().<br /><br />Here is my code.<br /><br /><pre><code><br />.386<br />.model flat, stdcall<br />option casemap&#58;none<br /><br />include \masm32\include\windows.inc<br />include \masm32\include\user32.inc<br />include \masm32\include\kernel32.inc<br /><br />includelib \masm32\lib\user32.lib<br />includelib \masm32\lib\kernel32.lib<br /><br />a_UsePsapiLib EQU 0<br /><br />if a_UsePsapiLib eq 1<br />    include \masm32\include\Psapi.inc<br />    includelib \masm32\lib\Psapi.lib<br />endif<br /><br /><br />EnumProcess PROTO<br />GetModuleFileSpec PROTO &#58;DWORD, &#58;DWORD<br /><br />a_ShowGetModuleErr EQU 1<br /><br />.data<br />g_szWinTitle    db &quot;MouduleName&quot;, 0<br /><br />g_szFailLoadPsapi db &quot;Fail to load&quot;<br />g_szPsapiDLL db &quot;psapi&quot;, 0<br />g_szFailGetEnumProcMods db &quot;Fail to get&quot;<br />g_szEnumProcMods db &quot;EnumProcessModules&quot;, 0<br />g_szFailGetModuleFileNameExA db &quot;Fail to get&quot;<br />g_szGetModFileNameExA db &quot;GetModuleFileNameExA&quot;, 0<br /><br />if a_ShowGetModuleErr eq 1<br />    g_szFailGetProcHandle db &quot;Fail to get the handle of process!&quot;, 0<br />    g_szFailEnumModule db &quot;Fail to enum module!&quot;, 0<br />    g_szFailGetModName db &quot;Fail to get the filename of module!&quot;, 0<br />endif<br /><br />.data?<br />g_hInstance HINSTANCE ?<br /><br />g_hProcess HANDLE ?<br /><br />g_lpfnEnumProcMods dword ?<br />g_lpfnGetModFNameExA dword ?<br /><br /><br />.code<br />start&#58;<br />    invoke GetModuleHandle,  NULL<br />    mov    g_hInstance,  eax<br /><br />    invoke LoadLibrary, OFFSET g_szPsapiDLL<br />    .IF &#40;eax == NULL&#41;<br />        invoke MessageBox, NULL, OFFSET g_szFailLoadPsapi, OFFSET g_szWinTitle, MB_ICONERROR<br />        jmp @Exit<br />    .ENDIF<br /><br />    mov g_hProcess, eax<br />    invoke GetProcAddress, g_hProcess, OFFSET g_szEnumProcMods<br />    .if &#40;eax == NULL&#41;<br />        invoke MessageBox, NULL, OFFSET g_szFailGetEnumProcMods, OFFSET g_szWinTitle, MB_ICONERROR<br />        invoke FreeLibrary, g_hProcess<br />        jmp @Exit<br />    .endif<br /><br />    mov g_lpfnEnumProcMods, eax<br />    invoke GetProcAddress, g_hProcess, OFFSET g_szGetModFileNameExA<br />    mov g_lpfnGetModFNameExA, eax<br />    invoke  FreeLibrary, g_hProcess<br />    .if &#40;g_lpfnGetModFNameExA == NULL&#41;<br />        invoke MessageBox, NULL, OFFSET g_szFailGetModuleFileNameExA, OFFSET g_szWinTitle, MB_ICONERROR<br />        jmp @Exit<br />    .endif<br /><br />    invoke EnumProcess<br />@Exit&#58;<br />    invoke ExitProcess, eax<br /><br /><br />EnumProcess proc<br />      LOCAL Buff &#91;255&#93;&#58; BYTE<br />      LOCAL Handle4EnumProc&#58;  HANDLE<br />      LOCAL ProcEntry&#58; PROCESSENTRY32<br /><br />    ;---------------------------------------------------<br />    ;1 Get the handle needed to enum process<br />    ;---------------------------------------------------<br />    invoke CreateToolhelp32Snapshot, TH32CS_SNAPPROCESS, 0<br />    mov Handle4EnumProc, eax<br /><br />    ;---------------------------------------------------<br />    ;2 Initilizes the struct to store process infomation<br />    ;---------------------------------------------------<br />    mov ProcEntry.dwSize, sizeof PROCESSENTRY32<br /><br />    ;---------------------------------------------------<br />    ;3 Enum the first process<br />    ;---------------------------------------------------<br />    invoke Process32First, Handle4EnumProc, ADDR ProcEntry<br />    .WHILE &#40;eax != NULL&#41;<br />        invoke GetModuleFileSpec, ProcEntry.th32ProcessID, ADDR Buff<br />        .if &#40;eax == 0&#41;<br />            lea eax, Buff<br />            .IF &#40;byte ptr &#91;eax&#93; == '\'&#41; ;The path can have the prefix &quot;\\?\&quot;, skip it<br />                add eax, 4<br />            .ENDIF<br />        .else<br />            lea eax, ProcEntry.szExeFile<br />        .endif<br /><br />        ;---------------------------------------------------<br />        ;4 Display the file name of process<br />        ;---------------------------------------------------<br />        invoke MessageBox, NULL, eax, OFFSET g_szWinTitle, NULL<br /><br />        ;---------------------------------------------------<br />        ;4 Enum next process<br />        ;---------------------------------------------------<br />        invoke Process32Next, Handle4EnumProc, ADDR ProcEntry<br />    .ENDW<br /><br />    ;---------------------------------------------------<br />    ; Close the handle<br />    ;---------------------------------------------------<br />    invoke CloseHandle, Handle4EnumProc<br />    ret<br />EnumProcess endp<br /><br /><br /><br />;#####################################################################<br />; Get the Module File specify specified by proc ID<br />;  Input&#58; procID --- the ID of proc we want to get its file specify<br />;         lpszFileSpec --- the pointer to buffer to store file specify<br />; Output&#58; eax == 0 succeed<br />;         eax == 1 Fail to get proc handle<br />;         eax == 2 Fail to enum module<br />;         eax == 3 Fail to get module file name<br />;=====================================================================<br />GetModuleFileSpec PROC uses edi procID&#58; DWORD, lpszFileSpec&#58; DWORD<br />    LOCAL  hMods&#91;100&#93;; HMODULE<br />    LOCAL  dw_cbNeeded; DWORD<br />    LOCAL  buf &#91;255&#93;&#58; BYTE<br /><br />    invoke OpenProcess, PROCESS_QUERY_INFORMATION or PROCESS_VM_READ, FALSE, procID<br />    mov g_hProcess, eax<br />    .IF &#40;eax == NULL&#41;<br /><br />if a_ShowGetModuleErr eq 1  ;????????????????????????<br />        invoke MessageBox, NULL, OFFSET g_szFailGetProcHandle, OFFSET g_szWinTitle, MB_ICONERROR<br />endif                       ;????????????????????????<br /><br />        mov eax, 1<br />        ret<br />    .ENDIF<br /><br />    ;invoke EnumProcessModules, g_hProcess, ADDR hMods, SIZEOF hMods, ADDR dw_cbNeeded<br />    lea eax, dw_cbNeeded<br />    push eax<br />    push SIZEOF hMods<br />    lea eax, hMods<br />    push eax<br />    push g_hProcess<br />    call g_lpfnEnumProcMods<br />    .if&#40;eax == 0&#41;<br />        invoke CloseHandle, g_hProcess<br /><br />if a_ShowGetModuleErr eq 1  ;????????????????????????<br />            invoke MessageBox, NULL, OFFSET g_szFailEnumModule, OFFSET g_szWinTitle, MB_ICONERROR<br />endif                       ;????????????????????????<br /><br />        mov eax, 2<br />        ret<br />    .endif<br /><br />    lea edi, hMods<br /><br />if a_UsePsapiLib eq 1       ;??????????????????????????<br />    invoke GetModuleFileNameEx, g_hProcess, &#91;edi&#93;, lpszFileSpec, MAX_PATH<br />else<br />    push MAX_PATH<br />    push lpszFileSpec<br />    push &#91;edi&#93;<br />    push g_hProcess<br />    call g_lpfnGetModFNameExA<br />endif                       ;??????????????????????????<br /><br />    .IF &#40;eax == 0&#41;<br />        push 3<br />    .ELSE<br />        push 0<br />    .ENDIF<br />    invoke CloseHandle, g_hProcess<br />    pop eax<br /><br />    ret<br />GetModuleFileSpec ENDP<br /><br />end start<br /></code></pre></div>
    <div class="meta">Posted on 2004-05-12 10:38:17 by purpleendurer</div>
   </div>
   <div class="post" id="post-140995">
    <div class="subject"><a href="#post-140995">Fail to enum system processes...</a></div>
    <div class="body"><strong>purpleendurer</strong><br />You free psapi.dll but uses function from it.<br />Move<pre><code>invoke  FreeLibrary, g_hProcess</code></pre>to<pre><code>...<br />@Exit&#58;<br />    invoke  FreeLibrary, g_hProcess<br />    invoke ExitProcess, eax<br />...</code></pre></div>
    <div class="meta">Posted on 2004-05-12 22:15:57 by P2M</div>
   </div>
   <div class="post" id="post-141004">
    <div class="subject"><a href="#post-141004">Fail to enum system processes...</a></div>
    <div class="body">Thanks P2M.<br /><br />You are right:alright:</div>
    <div class="meta">Posted on 2004-05-13 01:51:23 by purpleendurer</div>
   </div>
  </div>
 </body>
</html>