<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>How does DIV work (inner mechanics) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=3073" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=3073">How does DIV work (inner mechanics)</a></p>
   <div class="post" id="post-20112">
    <div class="subject"><a href="#post-20112">How does DIV work (inner mechanics)</a></div>
    <div class="body">How does the div opcode work <br /><br />I mean how does it do division?  I've been curious about this...<br /><br />I decided one day I'd try to &quot;fake&quot; division -- but I'm still in the dark (I was trying to do it for floating point, but I'm just curious about integer divion right now)... <br /><br />I know you can divide by bit shifting... Is there a more complete ways?<br /><br />I guess I'm asking because &quot;div&quot; on a .486 takes about 40 clocks to complete so how does it use them?<br /><br />Sliver</div>
    <div class="meta">Posted on 2002-01-20 15:25:48 by Sliver</div>
   </div>
   <div class="post" id="post-20120">
    <div class="subject"><a href="#post-20120">How does DIV work</a></div>
    <div class="body">mov eax, 12<br />mov ecx, 3<br />div ecx<br /><br />eax is the quotient<br />ecx is the divisor<br /><br />the answer will be in eax, if there is a remainder it will be in edx</div>
    <div class="meta">Posted on 2002-01-20 15:50:45 by stryker</div>
   </div>
   <div class="post" id="post-20123">
    <div class="subject"><a href="#post-20123">How does DIV work</a></div>
    <div class="body">ok you failed to read the original post <br /><br />this isn't a &quot;help me I don't no how to divide&quot; :)<br /><br />I want to know HOW DIV works! <br /><br />ie.<br /><br />how does it divivde 123 / 45, etc<br /><br />Sliver</div>
    <div class="meta">Posted on 2002-01-20 16:03:19 by Sliver</div>
   </div>
   <div class="post" id="post-20125">
    <div class="subject"><a href="#post-20125">How does DIV work</a></div>
    <div class="body">If I remember well, it is explained in the Intel docs... (with a shema... you know... where they always use those &quot;&lt;-&quot; characters everywhere ^^)<br /><br />Maybe the best explaination is in a math book, though... :rolleyes:</div>
    <div class="meta">Posted on 2002-01-20 16:19:00 by JCP</div>
   </div>
   <div class="post" id="post-20126">
    <div class="subject"><a href="#post-20126">How does DIV work</a></div>
    <div class="body">Oops!!! he! he! he! :) I don't know but my guess is it does more than using DIV, probably it does an ADD and SUB instruction...using MUL is adding itself how many times(in short MUL is just plain ADD).<br /><br />E.G.<br /><br />(1 x 3 = 3) == (1 + 1 + 1 == 3)<br /><br />So DIV might be a combination of that.</div>
    <div class="meta">Posted on 2002-01-20 16:23:09 by stryker</div>
   </div>
   <div class="post" id="post-20128">
    <div class="subject"><a href="#post-20128">How does DIV work</a></div>
    <div class="body">Oh I know...Just a guess<br /><br />12/4 == 3 remainder 0<br /><br />is the same as 12 - 3 - 3 - 3 - 3, maybe it counts how many times it subtracted by 3 then if it is less than 3 then the remaining value is the remainder.<br /><br />15/2 == 7.5(using a calculator)<br /><br />15 - 2 = 13<br />13 - 2 = 11<br />11 - 2 = 9<br />9 - 2 = 7<br />7 - 2 = 5<br />5 - 2 = 3<br />3 - 2 = 1<br /><br />since 1 &lt; 2. Counting how many times we subtracted:: 7 times<br />remainder 1... there you go...<br /><br />eax == 7<br />edx == 1<br /><br />which is correct. when using it this way:<br /><br />mov eax, 15<br />mov ecx, 2<br />div ecx<br /><br />of course, it will not output 7.5 because DIV isn't a reliable instruction :)<br /><br />to correct that, save eax(7) then mov eax, edx<br /><br />StartOfLoop:<br /><br />eax now contains 1<br />multiply by 10 == 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1<br />which makes eax == 10<br /><br />10 - 2 = 8<br />5 - 2 = 6<br />6 - 2 = 4<br />4 - 2 = 2<br />2 - 2 = 0<br /><br />counting how many times we subtracted:: 5 times<br />check if it last values is == 0. if it's not save the value of eax then do the loop again until the last value is 0.<br /><br />pop those values.<br /><br />concatenating both makes it 7.5<br /><br />check out DivToAscii procedure(Just Asking:: part 2 thread)<br /><a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=3039">http://www.asmcommunity.net/board/index.php?topic=3039</a></div>
    <div class="meta">Posted on 2002-01-20 16:32:06 by stryker</div>
   </div>
   <div class="post" id="post-20146">
    <div class="subject"><a href="#post-20146">How does DIV work</a></div>
    <div class="body">umberg6007 that's very interesting... now I just have t figure out how they do it for floating point<br /><br />Readiosys do you know where in the docs it can be found?  It'd help me out alot in my learning this<br /><br />Sliver<br /><br />any otherr ideas on integer or floating point division would be appreciated</div>
    <div class="meta">Posted on 2002-01-20 17:21:26 by Sliver</div>
   </div>
   <div class="post" id="post-20150">
    <div class="subject"><a href="#post-20150">How does DIV work</a></div>
    <div class="body">Oops!!! i forgot to answer 123/45<br /><br />using this code:<br />mov eax, 123<br />mov ecx, 45<br />div ecx<br /><br />I'm sure eax == 2 and edx == 33<br /><br />123 - 45 == 78 ... count == 1<br /><br />is the last value &lt; ecx(45) if it is, count will be our quotient(eax) and the last remaining value will be 78(edx). if its not. continue...<br /><br />78 - 45 == 33 ... count == 2 <br /><br />is the last value &lt; ecx(45) if it is, count will be our quotient(eax) and the last remaining value will be 33(edx). if its not. continue...<br /><br />since 33 &lt; 45. eax == 2, edx == 33, which is correct in the sense of using the code above. But its isn't the correct answer, which is<br />2.7333333333333333333...<br /><br />...same step as above but treat this part as your remainder<br /><br />to correct that save the value of eax which is 2<br />mov eax, edx  ;eax == 33<br />multiply eax by 10 == 33 + 33 + 33 + 33 + 33 + 33 + 33 + 33 + 33 + 33<br />which makes eax == 330<br /><br />330 - 45 == 285<br />...<br /><br />In the long run you'll eventually get 7 and a non terminating 3.<br /><br />:)</div>
    <div class="meta">Posted on 2002-01-20 17:28:08 by stryker</div>
   </div>
   <div class="post" id="post-20153">
    <div class="subject"><a href="#post-20153">How does DIV work</a></div>
    <div class="body">Here's a code snippet to do it. In the old days, for certain values,<br />a software approach could be faster than using div... probably there<br />exists methods that are a lot better than my little five-minute hack ;)<br /><br /><pre><code><br />; divide EAX by EBX. Result in EAX, modulus in EDX.<br />xor  edx, edx<br />dec  edx<br />@@divloop&#58;<br />  inc  edx<br />  sub  eax, ebx<br />  jns  @@divloop<br />  add  eax, ebx<br />  xchg  eax, edx ; yeah yeah this is slow<br /></code></pre></div>
    <div class="meta">Posted on 2002-01-20 17:32:30 by f0dder</div>
   </div>
   <div class="post" id="post-20154">
    <div class="subject"><a href="#post-20154">How does DIV work</a></div>
    <div class="body">As for floating-point, things get pretty messy. I think NASM has a<br />complete set of IEEE (or whatever) compliant software floating-point<br />routines... check it out.</div>
    <div class="meta">Posted on 2002-01-20 17:33:11 by f0dder</div>
   </div>
   <div class="post" id="post-20157">
    <div class="subject"><a href="#post-20157">How does DIV work</a></div>
    <div class="body">This is the file that'll solve the problem you can control how many digits for the floating point...please read the disclaimer at the end of the text file. I'm still working on a new one that will output correctly... So basically DIV is just SUB and MUL is just ADD. Hey you can still use fdiv...fdivp :)<br /><br />This one has still some bugs.</div>
    <div class="meta">Posted on 2002-01-20 17:38:01 by stryker</div>
   </div>
   <div class="post" id="post-20168">
    <div class="subject"><a href="#post-20168">How does DIV work</a></div>
    <div class="body">This is an efficient method when in optimized asm:<pre><code>static int try_sub&#40;int * a, int * b&#41; &#123;<br />	char ok;<br /><br />	__asm__ __volatile__&#40;&quot;movl &#40;%1&#41;,%%eax ; subl %%eax,&#40;%2&#41;\n\t&quot;<br />		&quot;movl 4&#40;%1&#41;,%%eax ; sbbl %%eax,4&#40;%2&#41;\n\t&quot;<br />		&quot;movl 8&#40;%1&#41;,%%eax ; sbbl %%eax,8&#40;%2&#41;\n\t&quot;<br />		&quot;movl 12&#40;%1&#41;,%%eax ; sbbl %%eax,12&#40;%2&#41;\n\t&quot;<br />		&quot;setae %%al&quot;&#58;&quot;=a&quot; &#40;ok&#41;&#58;&quot;c&quot; &#40;a&#41;,&quot;d&quot; &#40;b&#41;&#41;;<br />	return ok;<br />&#125;<br /><br />static void div64&#40;int * a, int * b, int * c&#41; &#123;<br />	int tmp&#91;4&#93;;<br />	int i;<br />	unsigned int mask = 0;<br /><br />	c += 4;<br />	for &#40;i = 0 ; i&lt;64 ; i++&#41; &#123;<br />		if &#40;!&#40;mask &gt;&gt;= 1&#41;&#41; &#123;<br />			c--;<br />			mask = 0x80000000UL;<br />		&#125;<br />		tmp&#91;0&#93; = a&#91;0&#93;; tmp&#91;1&#93; = a&#91;1&#93;;<br />		tmp&#91;2&#93; = a&#91;2&#93;; tmp&#91;3&#93; = a&#91;3&#93;;<br />		if &#40;try_sub&#40;b,tmp&#41;&#41; &#123;<br />			*c |= mask;<br />			a&#91;0&#93; = tmp&#91;0&#93;; a&#91;1&#93; = tmp&#91;1&#93;;<br />			a&#91;2&#93; = tmp&#91;2&#93;; a&#91;3&#93; = tmp&#91;3&#93;;<br />		&#125;<br />		shift_right&#40;b&#41;;<br />	&#125;<br />&#125;</code></pre>...and here is a detailed example:<pre><code>; div64&#58; Divide two int64_ts, returning either the quotient or the remainder<br /><br />; This is the only complicated routine. The basic strategy is to do long<br />;  division. I take the most significant bit of the dividend &#40;the &quot;partial<br />;  dividend&quot;&#41; and compare it to the divisor. If it's greater, the most<br />;  significant bit in the quotient is 1 and the divisor is subtracted from the<br />;  partial dividend. If not, the bit is 0. The partial dividend is shifted left<br />;  1 bit, joined by the next most significant bit from the dividend. The process<br />;  is repeated until I run out of dividend bits. Whatever's left is the remainder.<br /><br />; This process is optimized a bit in the following ways. I can't possibly get<br />;  any 1 bits in the quotient until I've shifted in enough of the dividend so<br />;  that it most significant bit is in the same bit position as the most<br />;  significant bit of the divisor. The number of bits this will take is easily<br />;  determined using the bsr opcode. While I'm doing this, it's easy to check if<br />;  the divisor is zero &#40;I return 0&#41; or 1 &#40;I return the dividend as the quotient<br />;  or 0 as the remainder&#41; or if the dividend is 0 &#40;I return 0&#41; or if the divisor<br />;  is bigger than the dividend &#40;I return 0 for the quotient or the dividend as<br />;  the remainder&#41;. Once I've shifted the dividend the number of bits I<br />;  determined, I can proceed to loop through the rest.<br /><br />; This algorithm loops a maximum of 63 times. This is expensive if the dividend is<br />;  less than 64 times the divisor, but quite efficient otherwise. Since the point<br />;  of this is to deal with extremely large numbers, it should be worth it.<br /><br />; This routine returns the quotient or remainder, depending on the value of the<br />;  first parameter when it's called. It assumes that it was called like this&#58;<br />;<br />;                         push  WANT_QUOTIENT or WANT_REMAINDER<br />;                         call  div64<br />;<br />;  Therefore, the dividend and divisor and the place to return the result must<br />;  already be on the stack &#40;from the call by the C program.&#41; This means that the<br />;  original caller's return address and the immediate caller's ebp are still on<br />;  the stack and should be ignored.<br /><br />div64   proc    syscall private result&#58;dword, ignore&#58;qword, outint&#58;pint64, in1&#58;int64_t, in2&#58;int64_t<br /><br />; MASM 6.0 adds the following due to the PROC statement<br />;       push    ebp<br />;       mov     ebp, esp<br /><br />; To divide two 64-bit numbers, any negative operands must be made<br />;  postive first. If an odd number are made postive, the result must<br />;  be made negative<br />        lea     eax, in1                    ; get address of first int64_t<br />        push    eax<br />        call    pre<br />        add     esp, 4<br />        push    esi<br /><br />; Initialize the quotient to 0 and the remainder to 0<br />        mov     quot.lowint, 0<br />        mov     quot.highint, 0<br /><br /><br />; Determine how many bits to shift initially<br />        bsr     eax, in2.highint            ; find the most sig 1 bit in divisor<br />        jz      checklow                    ; if none, check the low word<br />        add     eax, 32                     ; if found, it's in the high word<br />        jmp     dividend                    ; continue<br />checklow&#58;<br />        bsr     eax, in2.lowint             ; find the most sig 1 bit in divisor<br />        jz      div_done                    ; if none then we're dividing by 0<br />        cmp     eax, 0                      ; is the divisor 1?<br />        jne     dividend                    ; if not, continue<br />        mov     ebx, in1.highint            ; if yes, we're dividing by 1 so<br />        mov     quot.highint, ebx           ; ... the quotient ...<br />        mov     ebx, in1.lowint             ; ....... is ...<br />        mov     quot.lowint, ebx            ; ........ the dividend<br />        jmp     div_done<br />dividend&#58;<br />        bsr     ebx, in1.highint            ; find the most sig 1 bit in dividend<br />        jz      checklow2                   ; if none, check the low word<br />        add     ebx, 32                     ; if found, it's in the high word<br />        jmp     divide                      ; continue<br />checklow2&#58;<br />        bsr     ebx, in1.lowint             ; find the most sig 1 bit in dividend<br />        jz      div_done                    ; if none then we're dividing 0<br /><br />; We know know where the first 1 bit is in the divisor &#40;eax&#41; and the dividend<br />;  &#40;ebx&#41;. eax is at least 1 &#40;if it's 0 then the divisor is 1&#41;. If eax is greater<br />;  than ebx then the divisor is greater than the dividend. If they're equal then<br />;  the most significant bits are already lined up. Otherwise, the number of<br />;  bits we can shift initially is 64 - ebx &#40;to get to the first 1 bit in the<br />;  dividend&#41; + eax &#40;to get that bit over to where the first 1 bit is in the<br />;  divisor&#41;. The first bit of the quotient will be ebx - eax. This is also the<br />;  number of times to go thru the subtraction loop - 1.<br />divide&#58;<br />        sub     ebx, eax                    ; is the divisor greater than the dividend?<br />                                            ;  also the first quotient bit<br />        mov     eax, in1.lowint             ; &#91; get dividend ...<br />        mov     edx, in1.highint            ; ... in eax, edx&#93;<br />        jae     shift                       ; if not, continue<br />        mov     esi, eax                    ; if yes, the remainder ...<br />        mov     edi, edx                    ; ... is the dividend<br />        jmp     div_done<br /><br />; We now need to shift the 64-bit dividend into a 64-bit partial dividend.  Use<br />;  eax and edx for the dividend and esi and edi for the partial dividend.<br />;  Calculate the number of bits to shift in ecx. Decrement since one bit will be<br />;  shifted at the beginning of the suntract loop. I may need to shift more than<br />;  31 bits, which shld won't do. So if ecx &gt; 31, subtract 32 and manually shift<br />;  32 bits. At the end, esi and edi will have the remainder.<br />shift&#58;<br />        mov     esi, 0                      ; to hold the current ...<br />        mov     edi, 0                      ; ... partial dividend<br />        mov     ecx, 63                     ; get the number of bits ...<br />        sub     ecx, ebx                    ; ... to shift<br />        cmp     ecx, 31                     ; too many for shld?<br />        jbe     shift2                      ; if not, continue<br />        sub     ecx, 32                     ; 32 bits ...<br />        mov     esi, edx                    ; ... will be ...<br />        mov     edx, eax                    ; ...... shifted<br />        mov     eax, 0                      ; ...........manually<br />shift2&#58;<br />        shld    edi, esi, cl                ; shift ...<br />        shld    esi, edx, cl                ; ...... the ...<br />        shld    edx, eax, cl                ; .......... dividend<br />        shl     eax, cl<br /><br />; Now loop ebx times,<br />subtract&#58;<br />        mov     ecx, ebx                    ; get number of times to loop<br />        inc     ecx                         ; turn a bit number into a number of bits<br />shift_bit&#58;<br />        shld    edi, esi, 1                 ; shift ...<br />        shld    esi, edx, 1                 ; ...... the ...<br />        shld    edx, eax, 1                 ; .......... dividend<br />        shl     eax, 1<br />        cmp     edi, in2.highint            ; is the partial dividend &gt;= divisor?<br />        ja      subtract2                   ; if yes, continue<br />        jb      next_bit                    ; if not, quotient bit is 0<br />        cmp     esi, in2.lowint             ; is the partial dividend &gt;= divisor?<br />        jb      next_bit                    ; if not, quotient bit is 0<br />subtract2&#58;<br />        sub     edi, in2.highint            ; if yes, ...<br />        sbb     esi, in2.lowint             ; ... subtract the divisor<br />        push    ecx                         ; remember the count<br />        dec     ecx                         ; back to bit position<br />        cmp     ecx, 31                     ; bit position greater than 31?<br />        jbe     quotient                    ; if no, continue<br />        sub     ecx, 32                     ; can only shift up to 31 bits<br />quotient&#58;<br />        mov     ebx, 1                      ; bit position 0<br />        shl     ebx, cl                     ; rotate the bit into the right<br />                                            ;  position for the quotient<br />        pop     ecx                         ; get count<br />        cmp     ecx, 32                     ; bit position greater than 31?<br />        ja      quotient_high               ; if yes, use high word<br />        or      quot.lowint, ebx            ; add bit to quotient low word<br />        jmp     next_bit                    ; continue<br />quotient_high&#58;<br />        or      quot.highint, ebx           ; add bit to quotient high word<br />next_bit&#58;<br />        loop    shift_bit<br /><br />; VisualAge C++ wants returned structures to be placed in memory pointed<br />;  to by the implicit first parameter<br />div_done&#58;<br />        cmp     result, WANT_REMAINDER      ; caller wants remainder?<br />        je      put_result                  ; if yes, continue<br />        mov     esi, quot.lowint            ; get ...<br />        mov     edi, quot.highint           ; ... quotient<br />        jmp     put_result<br />put_result&#58;<br />        mov     ebx, outint<br />        mov     &#40;int64_t ptr &#91;ebx&#93;&#41;.lowint, esi<br />        mov     &#40;int64_t ptr &#91;ebx&#93;&#41;.highint, edi<br /><br />; I have to change the sign of the quotient if only one of the operands was<br />;  negative. I have to change the sign of the remainder if the dividend was<br />;  negative.<br />        pop     esi                         ; get the saved number of neg inputs<br />        push    ebx                         ; parameter for post<br />        cmp     result, WANT_REMAINDER      ; caller wants remainder?<br />        je      remainder                   ; if yes, check dividend's sign<br />        test    esi, 1                      ; need to change quotient's sign?<br />        jz      div_ret                     ; if not, all done<br />        call    post                        ; change the sign<br />        jmp     div_ret                     ; all done<br />remainder&#58;<br />        test    esi, 02h                    ; dividend negative?<br />        jz      div_ret                     ; if not, all done<br />        or      esi, 1                      ; indicate to change the sign<br />        call    post                        ; change the sign<br />div_ret&#58;<br />        add     esp, 2                      ; correct for post parameter<br />        ret<br /><br />; MASM 6.0 replaces RET statement with the following<br />;       leave<br />;       ret    00000h<br />div64   endp</code></pre>Credit goes to:<pre><code>Bob Pesner<br />PC Dialogs Inc.<br />305 w. 98 St., #5BN<br />New York, NY 10025<br />212-663-3459<br />&#91;email&#93;bpesner@panix.com&#91;/email&#93;</code></pre><a target="_blank" href="http://www.3cat.com/java_os2/newarc/msg00007.html">( Full Post )</a><br />Division is slow - has always been slow.  Multiply when you can!</div>
    <div class="meta">Posted on 2002-01-20 18:28:08 by bitRAKE</div>
   </div>
  </div>
 </body>
</html>