<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Analyze of InString from MASM32 7 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=6725" />
  <link rel="prev" href="../?id=6725&amp;page=1" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=6725">Analyze of InString from MASM32 7</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=6725&amp;page=1" style="">&laquo;</a><a href="../?id=6725&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="6725" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>   <div class="post" id="post-48609">
    <div class="subject"><a href="#post-48609">Analyze of InString from MASM32 7</a></div>
    <div class="body"><div class="quote"><br />Alex,<br /><br />I had some time today to have a further play with the InString algo and one mod I tried was to start the comparison on the next byte but every version I tried fails under the condition of searching for a single byte that is at the end of the string.<br /><br />    src db &quot;This is a test of a string algorithm&quot;,0<br />    pat db &quot;m&quot;,0<br /><br />It is basically a good idea but this algo was designed particularly to handle anything that could be typed in and searching for a single byte is not uncommon with things like text search in zero terminated strings.<br /><br /></div><br /><br />I tried my version with your test src and pat it correctly returned<br />24h<br />here is what I tried your test with:<br /><pre><code><br />    .386<br />    .model flat, stdcall  ; 32 bit memory model<br />    option casemap &#58;none  ; case sensitive<br /><br />    StrLen PROTO &#58;DWORD<br /><br />    .code<br /><br />InString proc startpos&#58;DWORD,lpSource&#58;DWORD,lpPattern&#58;DWORD<br />  ; ------------------------------------------------------------------<br />  ; InString searches for a substring in a larger string and if it is<br />  ; found, it returns its position in eax.   ;<br />  ; It uses a one &#40;1&#41; based character index &#40;1st character is 1,<br />  ; 2nd is 2 etc...&#41; for both the &quot;StartPos&quot; parameter and the returned<br />  ; character position.  ;  ; Return Values.<br />  ; If the function succeeds, it returns the 1 based index of the start<br />  ; of the substring.  ;  0 = no match found<br />  ; -1 = substring same length or longer than main string<br />  ; -2 = &quot;StartPos&quot; parameter out of range &#40;less than 1 or longer than<br />  ; main string&#41;<br />  ; ------------------------------------------------------------------<br />    LOCAL pLen&#58;DWORD<br />    push ebx<br />    push esi<br />    push edi<br /><br />    mov esi, lpSource<br />    mov edi, lpPattern<br /><br />    invoke StrLen,esi<br />    mov ebx, eax           ; ebx = source length<br />    invoke StrLen,edi<br />    mov ecx,startpos       ;ecx = startpos<br />    add edi,eax            ;edi=end of pattern<br />    neg eax                ;edi+eax = start of pattern<br />    mov pLen, eax           ; - &#40;pattern length&#41;<br />    dec ecx	       ;ecx = startpos -1<br />    js @errm2                  ;startpos &lt;= 0? yes - goto error -2<br />    add ebx,eax	       ;ebx= sLen - pLen<br />    js @errm1	       ; if sLen &lt; pLen goto error -1<br />    lea esi,&#91;esi&#93;&#91;ebx&#93;&#91;1&#93;    ; esi= address of part wich is &lt; pLen<br />    not ebx	       ;ebx = -&#40;ebx+1&#41;= - &#40;&#40;sLen - pLen&#41;+1&#41;<br />    add ecx,ebx	       ; ecx = startpos -1 ebx = - &#40;&#40;sLen - pLen&#41;+1&#41;		       ;if ecx &gt;=  &#40;sLen - pLen&#41;+1 then<br />    jns @errm2	       ;ecx - &#40;&#40;sLen-pLen&#41;+1&#41; &gt;= 0 and SF =0<br />    mov al,&#91;edi&#93;&#91;eax&#93;  ;first byte<br />    jmp Loop_Start<br />;@@@@@@@@@<br /><br />Pre_Loop&#58;<br />   pop ecx		;restore ECX<br />   inc  ecx		;start on next byte<br />Loop_Start&#58;<br />   cmp al,&#91;esi+ecx&#93;<br />   je Pre_Sub<br />   inc ecx<br />   jnz Loop_Start<br />   xor eax,eax<br />   jmp isOut<br />Pre_Sub&#58;<br />   push ecx	;preserve ECX<br />   mov edx,pLen<br />Sub_Loop&#58;<br />   inc ecx<br />   inc edx ;don't check fist byte<br />   mov ah,&#91;esi+ecx&#93;<br />   je found ;edi+0 = pattern end<br />   cmp ah,&#91;edi&#93;&#91;edx&#93;<br />   je Sub_Loop<br />   jmp Pre_Loop   <br />   <br />; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br />found&#58;<br />    pop eax                 <br />    sub eax, ebx ;sub neg value = add positive<br />    inc eax<br />   <br />  isOut&#58;<br />    pop edi<br />    pop esi<br />    pop ebx<br />    ret<br />@errm2&#58;<br />   mov eax,-2<br />   jmp isOut<br />@errm1&#58;<br />   mov eax,-1<br />   jmp isOut<br />InString endp<br />   end<br /></code></pre></div>
    <div class="meta">Posted on 2002-04-14 01:20:36 by The Svin</div>
   </div>
   <div class="post" id="post-48587">
    <div class="subject"><a href="#post-48587">Analyze of InString from MASM32 7</a></div>
    <div class="body">OK,<br /><br />I have digested eko's optimisation suggestion witjh the loop code and I have it testing reliably. I did not use the short circuit after the match loop as it involved an additional jump where the INC ECX fall through was more efficient.<br /><br />I think this is near optimum loop code and it now needs Alex's conditional testing code to get the algorithm size down and a shorter path for the conditional code.<br /><br />What I am tempted to do is write an auxilary scan loop that handles single characters and modify the following one so that it starts on the next byte when more than one character is being searched for.<br /><br />Here is the current version below.<br /><br /><pre><code><br />; #########################################################################<br /><br />InStringx proc startpos&#58;DWORD,lpSource&#58;DWORD,lpPattern&#58;DWORD<br /><br />  ; ------------------------------------------------------------------<br />  ; InString searches for a substring in a larger string and if it is<br />  ; found, it returns its position in eax. <br />  ;<br />  ; It uses a one &#40;1&#41; based character index &#40;1st character is 1,<br />  ; 2nd is 2 etc...&#41; for both the &quot;StartPos&quot; parameter and the returned<br />  ; character position.<br />  ;<br />  ; Return Values.<br />  ; If the function succeeds, it returns the 1 based index of the start<br />  ; of the substring.<br />  ;  0 = no match found<br />  ; -1 = substring same length or longer than main string<br />  ; -2 = &quot;StartPos&quot; parameter out of range &#40;less than 1 or longer than<br />  ; main string&#41;<br />  ; ------------------------------------------------------------------<br /><br />    LOCAL sLen&#58;DWORD<br />    LOCAL pLen&#58;DWORD<br /><br />    push ebx<br />    push esi<br />    push edi<br /><br />    invoke StrLen,lpSource<br />    mov sLen, eax           ; source length<br />    invoke StrLen,lpPattern<br />    mov pLen, eax           ; pattern length<br /><br />    cmp startpos, 1<br />    jge @F<br />    mov eax, -2<br />    jmp isOut               ; exit if startpos not 1 or greater<br />  @@&#58;<br /><br />    dec startpos            ; correct from 1 to 0 based index<br /><br />    cmp  eax, sLen<br />    jl @F<br />    mov eax, -1<br />    jmp isOut               ; exit if pattern longer than source<br />  @@&#58;<br /><br />    sub sLen, eax           ; don't read past string end<br />    inc sLen<br /><br />    mov ecx, sLen<br />    cmp ecx, startpos<br />    jg @F<br />    mov eax, -2<br />    jmp isOut               ; exit if startpos is past end<br />  @@&#58;<br />  ; ----------------<br />  ; setup loop code<br />  ; ----------------<br />    mov esi, lpSource<br />    mov edi, lpPattern<br />    mov al, &#91;edi&#93;           ; get 1st char in pattern<br />    add edi, pLen           ; set EDI to value for match loop<br /><br />    add esi, ecx<br />    neg ecx                 ; invert sign<br />    add ecx, startpos       ; add starting offset<br /><br />    jmp Scan_Loop<br /><br />  ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br /><br />  Pre_Scan&#58;<br />    inc ecx                 ; start on next byte<br /><br />  Scan_Loop&#58;<br />    cmp al, &#91;esi+ecx&#93;<br />    je Pre_Match<br />    inc ecx<br />    jnz Scan_Loop<br /><br />    jmp No_Match<br /><br />  Pre_Match&#58;<br />    lea ebx, &#91;esi+ecx&#93;<br />    mov edx, pLen           ; put pattern length into EDX<br />    add ebx, edx            ; add pattern length to scan location<br />    neg edx                 ; invert sign for index<br /><br />  Test_Match&#58;<br />    mov ah, &#91;ebx+edx&#93;<br />    cmp ah, &#91;edi+edx&#93;<br />    jne Pre_Scan            ; jump back on mismatch<br />    inc edx<br />    jnz Test_Match<br /><br />  ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br /><br />    add ecx, sLen<br />    mov eax, ecx            ; match<br />    inc eax<br />    jmp isOut<br />    <br />  No_Match&#58;<br />    xor eax, eax<br /><br />  isOut&#58;<br /><br />    pop edi<br />    pop esi<br />    pop ebx<br /><br />    ret<br /><br />InStringx endp<br /><br />; ########################################################################<br /></code></pre><br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-04-14 02:52:21 by hutch--</div>
   </div>
   <div class="post" id="post-48594">
    <div class="subject"><a href="#post-48594">Analyze of InString from MASM32 7</a></div>
    <div class="body">ok .. here is a working version ( i had some stupid mistakes in the first)<br /><br /><pre><code><br />InString1  proc startpos&#58;DWORD,lpSource&#58;DWORD,lpPattern&#58;DWORD <br /><br />    push esi<br />    push edi<br />    <br />    cmp startpos, 1<br />   <br />    jge @F<br />    mov eax, -2<br />    jmp isOut               ; exit if startpos not 1 or greater<br />    @@&#58;<br /><br />    dec startpos            ; correct from 1 to 0 based index<br />   <br />     invoke StrLen,lpPattern<br />     push eax         ; pattern length ;because of strlen <br />     <br />    invoke StrLen,lpSource<br />  ;  mov sLen, eax           ; source length<br />  <br />    pop edx<br /><br />  <br /><br />    cmp  edx, eax<br />    jl @F<br />    mov eax, -1<br />    jmp isOut               ; exit if pattern longer than source<br />  @@&#58;<br /><br /><br />   <br />     sub eax,edx<br />     inc eax<br /><br />    cmp eax, startpos<br />    jg @F<br />    mov eax, -2<br />    jmp isOut               ; exit if startpos is past end<br />  @@&#58;<br />     <br />   mov sLen, eax<br />  ; ----------------<br />  ; setup loop code<br />  ; ----------------<br />    mov esi, lpSource<br />    mov edi, lpPattern<br />    mov cl, &#91;edi&#93;           ; get 1st char in pattern<br /><br /><br /> ;  add edi, edx            ; set EDI to value for match loop<br /><br />    add esi, eax<br />    neg eax                 ; invert sign<br />    add eax, startpos       ; add starting offset<br />   <br />;jmp Scan_Loop<br />;instead of the jump do <br /><br />   push edx<br />   <br /> ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br /><br /><br /> Scan_Loop&#58;<br />    cmp cl, &#91;esi+eax&#93;<br />    je Pre_Match<br />Pre_Scan&#58;<br />    inc eax<br />    jnz Scan_Loop<br />    ; the loop set eax to set if not found <br /><br />    jmp @loopout<br /><br /><br /> Pre_Match&#58;<br />    <br />     mov edx,&#91;esp&#93; ; get edx back instead pop and push    <br />     lea ebx,&#91;esi+eax&#93;<br />  Test_Match&#58;<br />    mov ch, &#91;edi+edx-1&#93;	<br />    cmp ch, &#91;ebx+edx-1&#93;<br />    jne Pre_Scan            ; jump back on mismatch<br />    dec edx<br />    jnz Test_Match<br /> <br />add eax,sLen<br />inc eax<br /><br />  <br />@loopout&#58;<br />    add esp,4 ; instead of this . make local var and save edx there<br />    isOut&#58;<br />    pop edi<br />    pop esi<br />    pop ebx<br /><br /><br />  <br />ret<br />InString endp<br /><br /></code></pre><br /><br />bye<br /><br />eko<br /><br /><br />EDIT: <br /><br /><br />another idea <br />because in the test_match the algo scan from the end to the begining . in every non match i can add to eax the len of the pattern<br /><br /><br /><br />sub eax,edx ; you can do jmp Scan_Loop , but i personly, dont like to jump <br />push edx ;put push edx here , you wont get stall from the add<br /><br />add_len: ;in the test_match change the jmp from pre_scan to add_len<br /><br />add eax, <br /><br />Scan_Loop:<br />    cmp cl, <br />    je Pre_Match<br />    inc eax<br />    jnz Scan_Loop<br /></code></pre></div>
    <div class="meta">Posted on 2002-04-16 06:07:52 by eko</div>
   </div>
   <div class="post" id="post-48612">
    <div class="subject"><a href="#post-48612">strlen</a></div>
    <div class="body">ypu must also take care of the strlen function called I have coded a very fast one:<br /></code></pre><br />;###########################################################################<br />; This procedure find the string length without the null termenator<br />;		On Entry: address of the string you want to find its length(must be null terminated)<br />;		On Return: returns the length of the string in eax<br />;###########################################################################<br />strlen PROC uses ecx srcStr:DWORD<br /><br />    xor     eax,eax<br />    mov     ecx, srcStr<br />loopit:<br />	or     BYTE PTR ,0<br />	jz	endit<br />	inc	eax<br />	inc	ecx<br />	jmp	loopit<br />endit:	ret<br />strlen ENDP<br /></code></pre><br />try it</div>
    <div class="meta">Posted on 2002-04-16 08:24:41 by amr</div>
   </div>
   <div class="post" id="post-48597">
    <div class="subject"><a href="#post-48597">Analyze of InString from MASM32 7</a></div>
    <div class="body">I don't want to start another strlen topic (very popular one :grin: ) but yours is a byte scanner which can be slow on large strings...<br />Advanced algos has been explained on some topics of this board section, but I propose my own &quot;strlen byte scan&quot; version which is for most applications fast enough since many others have an overhead before they go at their optimal speed (on &quot;little&quot; strings, a byte scan can be faster).<br /><br />It has been quickly coded (for size), there's few seconds :-)<br /><br /><pre><code><br />RDS_strlen proc<br />mov eax, offset &#91;Hello -1&#93;<br />@@&#58;<br />inc eax<br />cmp byte ptr &#91;eax&#93;, 0<br />jne @B<br />sub eax, offset Hello<br />ret<br />RDS_strlen endp<br /></code></pre><br /><br />Its main advantage is to only destroy eax, and it doesn't matter because it is the value returning register.<br /><br />Yours is 136 cycles long on my Athlon Thunderbird 1200 MHz on a 39 characters long string.<br />Mine is 89 cycles on the same machine and string.</div>
    <div class="meta">Posted on 2002-04-16 12:15:53 by JCP</div>
   </div>
   <div class="post" id="post-48588">
    <div class="subject"><a href="#post-48588">Analyze of InString from MASM32 7</a></div>
    <div class="body">I have played with the later version that Eko posted and again the loop code design is very good. It is a different algo to the earlier versions posted in that it does the match loop in reverse but my own testing over time shows that a forward or reverse match loop does not effect the times on normal text data to any significant degree.<br /><br />The snippet I have posted below is the basic loop code design that Eko has optimised with a few suggestions. The DEC EDX is done before the loop code to reduce the complexity of the effective address calculation in the match loop. This allows the following,<br />mov ch, <br />against<br />mov ch, <br /><br />Effective address calculations take time and the less complex they are, the faster they are under some circumstances.<br /><br />The other mod is to place,<br />  Pre_Scan1:<br />    inc eax<br />before the scan loop so that a simple fall through occurs rather than execute the extra jump.<br /><br />As before, Compliments to Eko on some good optimisation technique that should show in the recovery speed of a mismatch when scanning longer strings that have a large number of partial matches.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a><br /><br /><pre><code><br />; --- snip ----<br /><br />    dec edx<br />    push edx<br />    jmp Scan_Loop1<br />     <br /> ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br /><br />  Pre_Scan1&#58;<br />    inc eax<br /><br />  Scan_Loop1&#58;<br />    cmp cl, &#91;esi+eax&#93;<br />    je Pre_Match1<br />    inc eax<br />    jnz Scan_Loop1<br /><br />    jmp @loopout<br /><br />  Pre_Match1&#58;<br />    mov edx,&#91;esp&#93;           ; get edx back instead pop and push    <br />    lea ebx,&#91;esi+eax&#93;<br /><br />  Test_Match1&#58;<br />    mov ch, &#91;edi+edx&#93;<br />    cmp ch, &#91;ebx+edx&#93;<br />    jne Pre_Scan1            ; jump back on mismatch<br />    dec edx<br />    jnz Test_Match1<br /><br /> ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br />; --- snip ----<br /></code></pre><br /><br />PS : I just learnt something useful about this algorithm and ones with similar sized loop code, they are sensitive to alignment. I tested both the version here with Eko's optimisation and a similar one using his optimisations and if you use ALIGN 8 or 16 before the label &quot;Pre_Scan1&quot;, the speed increases about 15%.</div>
    <div class="meta">Posted on 2002-04-16 21:34:36 by hutch--</div>
   </div>
   <div class="post" id="post-48591">
    <div class="subject"><a href="#post-48591">Analyze of InString from MASM32 7</a></div>
    <div class="body"><em>&quot;aligned code does not matter on anything recent&quot;</em><br />Oh well. You live, you learn ;)</div>
    <div class="meta">Posted on 2002-04-17 06:41:16 by f0dder</div>
   </div>
   <div class="post" id="post-48613">
    <div class="subject"><a href="#post-48613">Analyze of InString from MASM32 7</a></div>
    <div class="body">Not only it matters a lot.. but I suggest to who wrote &quot;aligned code does not matter on anything recent&quot;  to test the speed of a very &quot;self-optimizing&quot; CPU like Athlon on a innerloop when it's aligned on a even address or on a odd one.</div>
    <div class="meta">Posted on 2002-04-17 06:52:40 by Maverick</div>
   </div>
   <div class="post" id="post-48589">
    <div class="subject"><a href="#post-48589">Analyze of InString from MASM32 7</a></div>
    <div class="body">I have learnt a long time ago to trust the clock more than dogma, I have written code that I have deliberately misaligned and the timings were no different, other code I have found that the timings were variable depending on the code added in the proc before it.<br /><br />With the two algos, Eko's original and my own version using part of his optimisation and some more of my own that both byte intensive loops could be efected by code placed before them. ALIGN 4 did not help, ALIGN 8 partially helped and ALIGN 16 fixed it with both at the same time.<br /><br />Does the clock tell lies ?<br /><br />Ho Hum.<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a><br /><br />PS : Optimisation testing on a PIII, could not be bothered turning on the PIV.</div>
    <div class="meta">Posted on 2002-04-17 08:31:18 by hutch--</div>
   </div>
   <div class="post" id="post-48595">
    <div class="subject"><a href="#post-48595">Analyze of InString from MASM32 7</a></div>
    <div class="body">hii<br />hutch:i'm  honoured to be  complimented by you  :) <br /><br />in my last design. i'm scaning backwards . and thought if i scan backwards . and i dont find a match . i can add to the counter the len of the pattern instead increment it by one .<br /><br />i want to add eax,,<br />so think that i shouldnt dec edx before the push <br /><br />i have another version, but i'm not at my home right now , i'll post it as soon as i get home .<br /><br /><br />bye<br /><br />eko</div>
    <div class="meta">Posted on 2002-04-17 11:52:41 by eko</div>
   </div>
   <div class="post" id="post-48610">
    <div class="subject"><a href="#post-48610">Analyze of InString from MASM32 7</a></div>
    <div class="body">Steve and eko,<br />I'm humbly telling you for the 3d time -<br />you checking for the first byte in pattern though it is already checked and passed OK.<br />I showed in my code how to avoid it, you may create your own way to do it, but, please just look more carefully - you do one needless iteration comparing pattern with source.</div>
    <div class="meta">Posted on 2002-04-17 18:37:37 by The Svin</div>
   </div>
   <div class="post" id="post-48590">
    <div class="subject"><a href="#post-48590">Analyze of InString from MASM32 7</a></div>
    <div class="body">Alex,<br /><br />You are probably right but its the loop code that I want to get right at the moment and I am very pleased with the optimisation suggestions that Eko has made as it has benchmarked faster.<br /><br />When the loop code is finalised, chasing code size efficiency in the prologue and epilogue code will then make sense. i will certainly make use of your code design then as it reduces the size of the code.<br /><br />The only problem with the suggestion is that with the exit from the scan loop being dependent on the zero flag, a search for a single byte causes it to go past zero. The suggestion you have made is a good one as it allows a much faster early out with a mismatch on the next character and this improves partial match recovery but the algo is not fully optimised yet.<br /><br />Regards and thanks for your contribution,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-04-17 23:38:03 by hutch--</div>
   </div>
   <div class="post" id="post-48596">
    <div class="subject"><a href="#post-48596">Analyze of InString from MASM32 7</a></div>
    <div class="body">hiii ., i have two versions .<br /><br /><pre><code> <br />InString1  proc startpos&#58;DWORD,lpSource&#58;DWORD,lpPattern&#58;DWORD <br />    push ebx<br />    push esi<br />    push edi<br />    <br />   <br />   invoke StrLen,lpPattern ; pattern length<br />   push eax          ;because of strlen <br />   invoke StrLen,lpSource ;  mov sLen, eax           ; source length<br /><br />   mov ebx,startpos<br />   pop edx<br />  <br />cmp ebx,1<br />   jb @ER <br />   cmp eax,ebx<br />   jg @F<br />@ER&#58;<br />     	 mov eax, -2<br />     	 jmp isOut               ; exit if startpos is past end OR exit if startpos not 1 or greater<br />@@&#58;<br />   sub eax,edx<br />   jg @F<br />    	mov eax, -1<br />    	jmp isOut               ; exit if pattern longer than source<br />  @@&#58;<br /> <br /><br /><br /> mov sLen, eax    <br />;  sub eax,ebx ; add the start offset<br />  ; ----------------<br />  ; setup loop code<br />  ; ----------------<br />   mov edi, lpPattern<br />   mov esi, lpSource<br /> ; <br /> <br />   add esi,eax<br />   <br />   <br />   neg eax                ; invert sign<br />   push edx  <br />   add eax,ebx<br /><br />   mov cl,&#91;edi&#93;            ; get 1st char in pattern   <br />   sub eax,edx	<br />  </code></pre><br />the begining of the code is the same for the two version ^<br /><br />version one :(only the loops)<br /><pre><code><br /><br /><br />add_len&#58;<br />mov ebx,&#91;esp&#93;<br />add eax,ebx<br />Scan_Loop&#58;<br />    cmp cl, &#91;esi+eax&#93;<br />    je Pre_Match<br />;Pre_Scan&#58; no need for this <br />    inc eax<br />    jnz Scan_Loop ; the loop set eax to set if not found <br />    <br /><br />    jmp @loopout<br /><br /><br /> Pre_Match&#58;<br />    lea edx,&#91;ebx-1&#93; ; get edx back instead pop and push  <br />    lea ebx,&#91;esi+eax&#93;<br />  Test_Match&#58;<br />    mov ch, &#91;edi+edx&#93;<br />    cmp ch, &#91;ebx+edx&#93;<br />    jne add_len            ; jump back on mismatch<br />    dec edx<br />    jnz Test_Match<br /> <br />    add eax,sLen<br />    inc eax<br /><br /></code></pre><br /><br />version two (only the loops)<br /><pre><code> <br />add_len&#58;<br />mov ebx,&#91;esp&#93;<br />add eax,ebx ; still have problem in here . &#40;stall - big one i think&#41;<br />Scan_Loop&#58;<br />    cmp cl, &#91;esi+eax&#93;<br />    je Pre_Match<br />;Pre_Scan&#58; no need for this <br />    inc eax<br />    jnz Scan_Loop ; the loop set eax to set if not found <br />    <br /><br />    jmp @loopout<br /><br /><br /> Pre_Match&#58;<br />    lea edx,&#91;ebx-1&#93; ; get edx back instead pop and push  <br />    mov ch, &#91;edi+ebx-1&#93; ; dont put edx. no     stall<br />    lea ebx,&#91;esi+eax&#93;<br />  Test_Match&#58;<br />    cmp ch, &#91;ebx+edx&#93;<br />    jne add_len            ; jump back on mismatch<br />    dec edx<br />    mov ch, &#91;edi+edx&#93;<br />    jnz Test_Match<br /> <br />    add eax,sLen<br />    inc eax<br /></code></pre><br /><br />bye<br /><br />eko</div>
    <div class="meta">Posted on 2002-04-18 11:51:27 by eko</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=6725&amp;page=1" style="">&laquo;</a><a href="../?id=6725&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="6725" /><input type="number" name="page" min="1" max="2" step="1" value="2" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>