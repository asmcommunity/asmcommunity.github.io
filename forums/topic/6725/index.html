<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Analyze of InString from MASM32 7 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=6725" />
    <link rel="next" href="../?id=6725&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=6725">Analyze of InString from MASM32 7</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=6725&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=6725&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="6725" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=6725&amp;page=2">&gt;</a><a href="../?id=6725&amp;page=2">&raquo;</a></form>   <div class="post" id="post-48598">
    <div class="subject"><a href="#post-48598">Analyze of InString from MASM32 7</a></div>
    <div class="body">I had a look today at InString from MASM32 7.<br />And thought that it might be used as example for those<br />beginners, who just start write their own procs, of how to do very basic <br />things right way.<br />The following is code of InString from MASM32 7, with enumurated lines<br />for easier refering in discussion, and a little bit changed by me version<br />of it. It will be changed further when I explain how and why it was changed. <br />The reason I post it is not aim to offer different proc - I didn't change algo<br />at all and even left register assingmentss, the only reason is to use it as <br />example to discuss basic and general things wich have place in many<br />parts of other code. How to implement things in asm when you already know algo.<br />All changes that I don't discuss in this post you can compare yourself<br />until I have it done. With next posts I'll cover them all in bytes and ticks<br />and post new changes.<br />Changes give advantages of size and speed and yet there are nothing<br />special, I used very basic things anybody could learn and use easily.<br /><br />InString - original proc<br />InString2 - proc where some part of InString changed without changing<br />                  algo and logic.<br /><br /><pre><code><br />InString proc startpos&#58;DWORD,lpSource&#58;DWORD,lpPattern&#58;DWORD<br /><br />  ; ------------------------------------------------------------------<br />  ; InString searches for a substring in a larger string and if it is<br />  ; found, it returns its position in eax. <br />  ;<br />  ; It uses a one &#40;1&#41; based character index &#40;1st character is 1,<br />  ; 2nd is 2 etc...&#41; for both the &quot;StartPos&quot; parameter and the returned<br />  ; character position.<br />  ;<br />  ; Return Values.<br />  ; If the function succeeds, it returns the 1 based index of the start<br />  ; of the substring.<br />  ;  0 = no match found<br />  ; -1 = substring same length or longer than main string<br />  ; -2 = &quot;StartPos&quot; parameter out of range &#40;less than 1 or longer than<br />  ; main string&#41;<br />  ; ------------------------------------------------------------------<br /><br />    LOCAL sLen&#58;DWORD<br />    LOCAL pLen&#58;DWORD<br />1    push ebx<br />2    push esi<br />3    push edi<br />4    invoke StrLen,lpSource<br />5    mov sLen, eax           ; source length<br />6    invoke StrLen,lpPattern<br />7    mov pLen, eax           ; pattern length<br />8    cmp startpos, 1<br />9    jge @F<br />10    mov eax, -2<br />11    jmp isOut               ; exit if startpos not 1 or greater<br />  @@&#58;<br />12    dec startpos            ; correct from 1 to 0 based index<br />13    cmp  eax, sLen<br />14    jl @F<br />15    mov eax, -1<br />16    jmp isOut               ; exit if pattern longer than source<br />  @@&#58;<br />17    sub sLen, eax           ; don't read past string end<br />18    inc sLen<br />19    mov ebx, sLen<br />20    cmp ebx, startpos<br />21    jg @F<br />22    mov eax, -2<br />23    jmp isOut               ; exit if startpos is past end<br />  @@&#58;<br />24    mov esi, lpSource<br />25    mov edi, lpPattern<br />26    mov al, &#91;edi&#93;           ; get 1st char in pattern<br />27    xor ecx, ecx<br />28    add ecx, startpos       ; add starting offset<br />29    jmp Loop_Start<br />  ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br />  Pre_Loop&#58;<br />30    pop ecx                 ; restore ECX<br />31    inc ecx                 ; start on next byte<br />  Loop_Start&#58;<br />32    cmp al, &#91;esi+ecx&#93;<br />33    je Pre_Sub<br />34    inc ecx<br />35    cmp ecx, ebx<br />36    jne Loop_Start<br />37    jmp No_Match<br />  Pre_Sub&#58;<br />38    push ecx                ; preserve ECX<br />39    mov edx, pLen<br />40    mov edi, lpPattern<br />  Sub_Loop&#58;<br />41    mov ah, &#91;esi+ecx&#93;<br />42    cmp ah, &#91;edi&#93;<br />43    jne Pre_Loop            ; jump back on mismatch<br />44    inc ecx<br />45    inc edi<br />46    dec edx<br />47    jnz Sub_Loop            ; fall through if match<br />48    pop ecx                 ; restore ECX<br />49    mov eax, ecx            ; match<br />50    inc eax<br />51    jmp isOut    <br />  ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br />  No_Match&#58;<br />52    mov eax, 0<br />  isOut&#58;<br />53    pop edi<br />54    pop esi<br />55    pop ebx<br />56    ret<br />InString endp<br /><br />;========================================<br />InString2 proc startpos&#58;DWORD,lpSource&#58;DWORD,lpPattern&#58;DWORD<br />LOCAL pLen&#58;DWORD<br /><br />1	push ebx<br />2	push esi<br />3	push edi<br />4	mov esi, lpSource  ;edi = lpSource<br />5	mov edi, lpPattern  ;esi = lpPattern	<br />6	invoke StrLen,esi<br />7	mov ebx,eax	;ebx = sLen<br />8	invoke StrLen,edi<br />9	mov pLen, eax<br />10	mov ecx, startpos<br />11	dec ecx<br />12	js @errm2<br />13	sub ebx,eax ;eax=pLen ebx=sLen if pLen &gt; sLen then CF=1<br />14	inc ebx<br />15	jc @errm1<br />16	cmp ebx,ecx	;cmp startof last part +1 with start pos<br />17	jbe @errm2	;lenth from start pos of source is less then pattern lenth<br />18	mov al,&#91;edi&#93;<br />19	jmp Loop_Start<br />;@@@@@@@@@@@@@<br />	Pre_Loop&#58;<br />20	pop ecx<br />21	inc ecx<br />Loop_Start&#58;<br />22	cmp al,&#91;esi+ecx&#93;<br />23	je Pre_Sub<br />24	inc ecx<br />25	cmp ecx,ebx<br />26	jne Loop_Start<br />27	xor eax,eax<br />28	jmp isOut<br />Pre_Sub&#58;<br />29	push ecx<br />30	mov edx,pLen<br />31	mov edi,lpPattern<br />Sub_Loop&#58;<br />32	mov ah,&#91;esi+ecx&#93;<br />33	cmp ah,&#91;edi&#93;<br />34	jne Pre_Loop<br />35	inc ecx<br />36	inc edi<br />37	dec edx<br />38	jnz Sub_Loop<br /><br />39	pop eax<br />40	inc eax<br />isOut&#58;<br />41	pop edi<br />42	pop esi<br />43	pop ebx<br /><br />44	ret<br />@errm2&#58;<br />45    	mov eax,-2<br />46    	jmp isOut<br />@errm1&#58;<br />47    	sbb eax,eax<br />48    	jmp isOut<br /><br />InString2 endp<br /></code></pre><br /><br />Note1:<br />About error codes and return value.<br />I didn't change it, but anyway want to say a couple things.<br />Error codes choosen in the proc are 0,-1,-2.<br />And if function succeded return value is based1(!) index.<br /><br />Think of if all error codes were negative (-1,-2,-3)<br />And return value were zerobased.<br />Advantages:<br />1. The original proc wouldn't need the two lines:<br />12    dec startpos            ; correct from 1 to 0 based index<br />50    inc eax<br /><br />2. If prog needs just check : &quot;if any error&quot; it could be done at ones<br />	test eax,eax<br />	js error<br /><br />3.ZeroBased value is much easier and shorter to use <br />for exaple if you passed pointer in edi to main string then after<br />return<br />      <br />is pointer to found string.<br />with 1based indexing you have to address to it as<br />       wich is one byte longer for nothing.<br />the same with addition, loading etc. you either need longer<br />instruction with based1 or even additional instruction.<br /><br />Note2: Strange code.<br /><br />1.<br />52    mov eax, 0 ;5 bytes instruction<br />----------<br />can be replaced with wellknown<br />xor eax,eax        ;2 bytes<br />----------<br />2.<br />27    xor ecx, ecx<br />28    add ecx, startpos       ; add starting offset<br />------------<br />why not just<br />mov ecx,startpos ?!<br />3.<br />48    pop ecx                 ; restore ECX<br />49    mov eax, ecx            ; match<br />50    inc eax<br />51    jmp isOut    <br />-----------------<br />isOut - is exit of proc and ecx doesn't need anything anymore<br />for sure it can be replaced with<br />       pop eax<br />       inc eax<br />       jmp isOut.<br />;-----------------------<br />to be continued...</div>
    <div class="meta">Posted on 2002-04-02 16:49:04 by The Svin</div>
   </div>
   <div class="post" id="post-48599">
    <div class="subject"><a href="#post-48599">Analyze of InString from MASM32 7</a></div>
    <div class="body">Note3: Memory and register usage.<br />In prologue of the InString there are several places where<br />some values are being manipulated in memory and after that<br />are loaded in registers.<br />A very simple question is:<br />If we load those values in the registers anyway why don't<br />we first thing load it to registers and only after that use it.<br />Look for example at the code in original proc:<br /><pre><code><br /><br />4    invoke StrLen,lpSource<br />5    mov sLen, eax           ; source length<br />6    invoke StrLen,lpPattern<br />7    mov pLen, eax           ; pattern length<br /><br />.....<br /><br />24    mov esi, lpSource<br />25    mov edi, lpPattern<br /><br /></code></pre><br />Just put lines 24 25 before 4 5 6 7 and you get<br /><pre><code><br /><br />    mov esi, lpSource<br />    mov edi, lpPattern<br />    invoke StrLen,esi<br />    mov sLen, eax           ; source length<br />    invoke StrLen,edi<br /></code></pre><br />   push esi is 1 byte and 1 clock instruction<br />   push dword ptr  (push lpSource) is 3 bytes and 2 clocks<br />so with simple cut and paste we get 4 bytes shorter and 2 clocks faster code.<br /><br />the same you can see here in the original code:<br /><pre><code><br /><br />...<br />8    cmp startpos, 1<br />...<br />12    dec startpos            ; correct from 1 to 0 based index<br />...<br />20    cmp ebx, startpos<br />... and finally<br />27    xor ecx, ecx<br />28    add ecx, startpos       ; add starting offset<br /></code></pre><br />why don't just mov ecx,startpos and do everything with ecx<br />each instruction using ecx instead of memory will be faster and shorter.<br /><br />the same with sLen (variable we have no needs at all):<br /><pre><code><br />5    mov sLen, eax           ; source length<br />....<br />13    cmp  eax, sLen<br />...<br />17    sub sLen, eax           ; don't read past string end<br />18    inc sLen<br />...     and finally &#58;&#41;<br />19    mov ebx, sLen<br /></code></pre><br />why don't just make line in line 5 mov ebx,eax<br />and all operations do with ebx<br />each such use of ebx instead of sLen will be shorter<br />and faster not saying that one insruction is removed<br />complitly (#19)<br /><br />to be continued....</div>
    <div class="meta">Posted on 2002-04-02 17:20:31 by The Svin</div>
   </div>
   <div class="post" id="post-48600">
    <div class="subject"><a href="#post-48600">Analyze of InString from MASM32 7</a></div>
    <div class="body">Note 4: Control blocks.<br />It is a little bit more complex though more interesting and more<br />usefull.<br />For a starter let's discuss a simple thing:<br />size and number of instruction<br />Have a look on code wich handles checking for errors:<br /><pre><code><br />8    cmp startpos, 1<br />9    jge @F<br />10    mov eax, -2<br />11    jmp isOut               ; exit if startpos not 1 or greater<br />  @@&#58;<br />......<br />13    cmp  eax, sLen<br />14    jl @F<br />15    mov eax, -1<br />16    jmp isOut               ; exit if pattern longer than source<br />  @@&#58;<br />........<br />20    cmp ebx, startpos<br />21    jg @F<br />22    mov eax, -2<br />23    jmp isOut               ; exit if startpos is past end<br />  @@&#58;<br /></code></pre><br />Logic is <br />if OK jump over &quot;code for error&quot;<br />in &quot;code for error&quot; - put error code in eax and jmp out<br />To do it (apart from comparing itself) code need<br />3 jcc for OK condition<br />3 movs for error code<br />3 jmps out.<br />Note, please, in to cases we put the same error code -2<br />What if we change logic to:<br />If NOT OK jmp to place where we put error code and go out<br />Then we need just 2 such places for -1 and - 2 <br />thus we can remove 1 jmp and 1 mov,-2.<br />Which is 7 bytes and 2 clocks.<br />But there is more important advantage:<br />We expect more probably normal execution,<br />so all these jcc in original proc more probably would be<br />taken. But they all are &quot;first time&quot; (and also only one time)<br />jccs. That means that dispite of they will be more probably<br />taken none of them will be predicted and each time (!)<br />they are taken all pipes will be flashed.<br />In opposite - if jcc will be taken only in error conditions<br />with normal execution all of them will be right predicted<br />(as not taken) and will not cost anything.<br /><br />the other example of wrong organized contol block here:<br /><pre><code><br />35    cmp ecx, ebx<br />36    jne Loop_Start<br />37    jmp No_Match<br />......<br />50    inc eax<br />51    jmp isOut    <br />  ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br />  No_Match&#58;<br />52    mov eax, 0<br />  isOut&#58;<br /></code></pre><br />There is no need for No_Match lbl and jumping over it.<br />it's obvious that 0 error code could be placed after line 36 before<br />unconditional jmp, and cause it would in such scenario already in eax<br />jmp may just be done out:<br /><pre><code><br />	jne Loop_Start<br />	xor eax,eax	;put it here also change to xor - 2 bytes instead of 5<br />	jmp isOut<br />.....<br />	inc eax            <br />		;no need jmp over - we can leave out that jmp<br />isOut&#58;<br /></code></pre><br /><br />to be continued...</div>
    <div class="meta">Posted on 2002-04-02 18:08:22 by The Svin</div>
   </div>
   <div class="post" id="post-48581">
    <div class="subject"><a href="#post-48581">Analyze of InString from MASM32 7</a></div>
    <div class="body">This is good analysis Alex, I confess to only being interested in the loop code where the speed matters but the proc can probably be made slightly shorter by improving the entry and exit code.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-04-03 01:36:03 by hutch--</div>
   </div>
   <div class="post" id="post-48611">
    <div class="subject"><a href="#post-48611">Analyze of InString from MASM32 7</a></div>
    <div class="body"><div class="quote"><br />2. <br />27 xor ecx, ecx <br />28 add ecx, startpos ; add starting offset<br /></div> <br /><br />Please forgive me if I'm wrong, but if you just change it to<br /><br /><div class="quote"> <br />add ecx, startpos<br /></div> <br /><br />Won't you get all the junk values in ecx plus the startpos?  I didn't see where ecx was xor'd or set to zero anywhere else (so doesn't it have junk values?)<br /><br />Sliver<br /><br />ps. I'm very intrested in this... So thanks for posting it</div>
    <div class="meta">Posted on 2002-04-03 03:28:59 by Sliver</div>
   </div>
   <div class="post" id="post-48601">
    <div class="subject"><a href="#post-48601">Analyze of InString from MASM32 7</a></div>
    <div class="body">Sliver,<br />why not just <br />   mov ecx,startpos<br />without xor ecx,ecx ;)<br />look at InString2</div>
    <div class="meta">Posted on 2002-04-03 03:46:23 by The Svin</div>
   </div>
   <div class="post" id="post-48602">
    <div class="subject"><a href="#post-48602">Analyze of InString from MASM32 7</a></div>
    <div class="body">Thanks, Steve,<br />I'm sure you understand that mainly I took your proc just<br />as an excuse to talk of some general questions of algo<br />imlemenatations in asm. I could have taken different proc,<br />but I saw some auxilary advantages to take one from MASM32.<br />- Many beginners have MASM32 and may after this thread<br />some of them will be encoraged to take their own analizis of<br />m32lib and even if don't improve it they at least would understand<br />it better and it for sure will lead to better results in their coding.<br />- Anyway finally (in addition to education perpose) we make this<br />very proc shorter in size and slitely faster so it has also parctical use<br />multiplyed (in size and speed improvement) by number of projects<br />wich use InString.<br /><br />;========================<br />Note5:<br />Very offten we have ability to generate some values in register<br />without using mov reg,constant<br />mov reg,constant is 5 bytes instruction so<br />xor eax, eax <br />instead of <br />mov eax,0 <br />will save 3 bytes each time it used.<br />You can very fast look at size of any instruction without any<br />reference - just type it in debugger and you'll see<br />(if debugger opened it it would take 1-2 secs)<br />Almost all debuggers when you start typing in CPU window<br />take it as if you want to insert instruction, and time to know<br />opcode of any instruction with any operands = time to type<br />the instruction and operands.<br /><br />in InString2 exit with error code -1 condition changed to jc.<br />so it gives ability to generate -1 by <br />sbb eax,eax ;eax-eax - CF CF=1 so eax-eax-1= -1<br />replacing mov eax,-1 by sbb eax,eax gives us 3 bytes saving<br />on just one instruction.<br /><br />Note6:<br />Using results of operations instead of cmp for<br />jcc.<br />In InString-2 2 of 3 jcc for error checking done without cmp<br />Actually there are very often case when you don't need cmp<br />to know  something about value or to compare to values:<br /><pre><code><br />from InString&#58;<br />	mov ecx, startpos<br />	dec ecx<br />	js @errm2 ;if ecx was 0 then SF=1<br /><br />	sub ebx,eax ;eax=pLen ebx=sLen if pLen &gt; sLen then CF=1<br />	inc ebx        <br />	jc @errm1     ;if ebx was &lt; eax then CF=1<br /><br />	cmp ebx,ecx	;cmp startof last part +1 with start pos<br />	jbe @errm2	;lenth from start pos of source is less then pattern lenth<br /><br /></code></pre><br />For the same things in InString is using cmp, the code above <br />elemenate a need for 2 of three those cmp decreasing size and<br />increasing speed.<br /><br />Note 7: Not correct condition for jcc<br />have a look(InString2):<br /><pre><code><br /><br />    cmp  eax, sLen<br />    jl @F<br />    mov eax, -1<br />    jmp isOut               ; exit if pattern longer than source<br />  @@&#58;<br /></code></pre><br />eax = lenth of pattern here, and sLen = len of source<br />the comment states &quot;exit if pattern longer than source&quot;<br />but condition for OK code is JL <br />that means though the author wished to exit with error code<br />on condition &quot;exit if pattern longer than source&quot; he puts condition<br />on wich code will exits also when pattern=source<br />cause <br />cmp eax,sLen<br />JL @F <br />means - go @F if sLen bigger (and not equal) pLen</div>
    <div class="meta">Posted on 2002-04-03 05:00:20 by The Svin</div>
   </div>
   <div class="post" id="post-48603">
    <div class="subject"><a href="#post-48603">Analyze of InString from MASM32 7</a></div>
    <div class="body">The first stage of changing and explonation <br />is done so now we can &quot;collect our coins&quot;.<br />Old procedure is 146 bytes size.<br />New one is just  106 bytes.<br />I kept wy word, the algo wasn't changed, all steps<br />remain, the only difference they are done another way.<br />To refresh our memory of methods to do so let's revise<br />what each one of them gives us.<br />1. We put <br /><pre><code><br />	mov esi, lpSource  ;edi = lpSource<br />	mov edi, lpPattern  ;esi = lpPattern<br /></code></pre><br />and change parameters to StrLen to:<br /><pre><code>	<br />	invoke StrLen,esi<br />	mov ebx,eax	;ebx = sLen<br />	invoke StrLen,edi<br />	mov pLen, eax<br /></code></pre><br />it gives us saving 4 bytes and 2 clocks<br />2. We put startpos in ecx in begining <br />so that we don't have need for the two instructions:<br /><pre><code><br />    xor ecx, ecx<br />    add ecx, startpos       ; add starting offset<br /></code></pre><br />that saves us 5 bytes and 3 clocks<br />3. We reorganize exit for error code<br />and remove 1 jmp isOut, 1 mov,-2<br />that saves us 7 bytes and 2 clocks.<br />We also change mov eax,-1 to sbb eax,eax <br />that gives us 3 bytes.<br />Rearranging jcc for errors also gives us<br />saving from 27 to 48 clocks for three predicted jcc<br /> in case of normal execution.<br /><br />No don't be lazy, for your sake - look what else was done<br />and what advantage it gives.<br /><br />Here are a lot of good programmers.<br />I'm sure that if some of them not just give improved code<br />but also give some analysis of what and why can be improved<br />a lot of beginners would be happy to learn.<br />There are still just few docs that learn such things in step by step<br />details.<br />I know many of you can do it better than me -<br />SO DO IT :)<br /><br />Take any proc from M32lib - a lot of them has room for optimizations</div>
    <div class="meta">Posted on 2002-04-03 06:19:32 by The Svin</div>
   </div>
   <div class="post" id="post-48604">
    <div class="subject"><a href="#post-48604">Analyze of InString from MASM32 7</a></div>
    <div class="body">The next step I planned to do was not to show some improvement now in main loop, but before it explain how the algo<br />works, what all the values in the main loop is about.<br />After having started writing the explonations, I had a simple idea but nobody could describe better how the algo works than the<br />author.<br />Steve, could you write a few words, please, the way you did about  BM algo, now about how InString works?<br />Algo itself is always more important than implemetation, and<br />no core improvement can be done without deep understanding.<br />If you show to readers sceme of your algo it would be great help.</div>
    <div class="meta">Posted on 2002-04-03 09:57:59 by The Svin</div>
   </div>
   <div class="post" id="post-48582">
    <div class="subject"><a href="#post-48582">Analyze of InString from MASM32 7</a></div>
    <div class="body">Alex,<br /><br />The design of this algo is a simple one, it is a clasic byte scanner that searches for the first character in the pattern being searched for and when it finds that character, it branches to a seperate comparison to see if the rest of the pattern matches the location in the source.<br /><br />Its non-error results are either the 1 based index of the pattern being searched for or zero if the pattern is not found. It produces minus values as error indicators.<br /><br />The loop code uses ESI as the pointer to the address of the source data and ECX as the incremented index. The area where there is a speed increase is in the following code,<br /><pre><code><br />  Loop_Start&#58;<br />    cmp al, &#91;esi+ecx&#93;<br />    je Pre_Sub<br />    inc ecx<br />    cmp ecx, ebx<br />    jne Loop_Start<br /></code></pre><br />If the length is added to ESI and the final value of ECX before the loop is sign inverted, the extra comparison CMP ECX, EBX can be avoided which brings the loop length down to 4 instructions.<br /><pre><code><br />  Loop_Start&#58;<br />    cmp al, &#91;esi+ecx&#93;<br />    je Pre_Sub<br />    inc ecx<br />    jnz Loop_Start<br /></code></pre><br />An unrolled version of this shorter loop would see a speed increase as well. Currently it does 1 comparison for 4 instructions, unrolling the loop would give 2 comparisons for 7 instructions with an alternative design using ADD ECX, 2 yielding 2 comparisons for 6 instructions. It would mean that there would have to be extra code for each jump to get the index right but it can be done. Unfortunately any gain here would probably be lost with extra penalties for branch prediction misses.<br /><br />The branch code that does the seperate comparison could be improved with a similar approach to the address in EDI of the pattern being searched for but it probably would not yield any noticable improvement in the benchmark.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-04-03 16:07:38 by hutch--</div>
   </div>
   <div class="post" id="post-48605">
    <div class="subject"><a href="#post-48605">Analyze of InString from MASM32 7</a></div>
    <div class="body">Thanks, Steve. I remember time when you posted after<br />BM many very good quality routines, and style of them<br />was clear proof that you apply the same quality to InString.<br />It just somehow missed your attention.<br /><br />To All,<br />I wish to offer you to have a more detailed look on one of interesting moment,<br />what is in ebx and why cmp ecx,ebx for exit condition.<br />Because understaning will lead us to one more obvious<br />improvement - removing one instruction.<br />for example we have string X as string and Y as pattern.<br />x = 0123456789<br />y = 0123<br />Steve uses sizeofX  - sizeofY<br />to find one magic value<br />This value is index of element in x string so that<br />size of part of X from this element to end of X = size of Y.<br />Lets call the index a, element X and a = sizeofX-sizeofY<br />This element is in last position were it has sence to cmp Y pattern<br />with X part from. Next part (from X to X end) will be shorter<br />than pattern and for only that can not be equal.<br />in our example <br />sizeof x = 10<br />sizeof y = 4<br />10-4=6 <br />so a = 6 x[6] is last element we have sence to cmp from<br />!!!!!!! this f*cking editor drives me mad!<br />how can position 0 of y string under 6 of x string?!<br /><br /><br />x 0123456789<br />y             0123<br /><br /><br />Steve uses value a+1 as chek for exit condition<br />when index pointer in ecx reach value that out of the limit X<br />we does in code operations<br /><pre><code><br /><br />    sub sLen, eax           ; don't read past string end &#91;a&#93;<br />    inc sLen                    ;&#91;a+1&#93;<br />    mov ebx, sLen          ;&#91;a+1&#93; in ebx<br />    ...<br />  Loop_Start&#58;<br />    cmp al, &#91;esi+ecx&#93;<br />    je Pre_Sub<br />    inc ecx<br />    cmp ecx, ebx<br />    jne Loop_Start<br /><br />    jmp No_Match<br />...<br /></code></pre><br />May be you think why I talking to much of such an obvious<br />thing? :)<br />May be 'cause nobody yet said that there is no need for<br /> inc sLen operation as no need to know a+1 value<br /> 'cause if ecx &lt;= a  it is OK or in other words<br />if ebx not &lt; ecx it is OK :)<br />or <br /><pre><code><br />;    inc sLen                    ;&#91;a+1&#93; remove this instruction<br />and just&#58;<br /><br />     cmp ebx,ecx ;in ebx a<br />     jnc Loop_Start<br /></code></pre><br /><br />Now our optimized code has 105 bytes instead of 106 of previous and 146 of original<br />and speed it up a little:<br /><pre><code><br />InString proc startpos&#58;DWORD,lpSource&#58;DWORD,lpPattern&#58;DWORD<br />LOCAL pLen&#58;DWORD<br /><br />	push ebx<br />	push esi<br />	push edi<br />	mov esi, lpSource<br />	mov edi, lpPattern<br /><br />	invoke StrLen,esi<br />	mov ebx,eax	;ebx = sLen<br />	invoke StrLen,edi<br />	mov pLen, eax<br /><br />	mov ecx,startpos<br />	dec ecx<br />	js @errm2<br /><br />	sub ebx,eax ;eax=pLen ebx=sLen if pLen &gt; sLen then CF=1<br />;	inc ebx ; we don't need it anymore<br />	jc @errm1<br /><br />	cmp ebx,ecx	;cmp startof last part +1 with start pos<br />	jc @errm2	;lenth from start pos of source is less then pattern lenth<br /><br />	mov al,&#91;edi&#93;<br /><br />	jmp Loop_Start<br />;@@@@@@@@@@@@@<br /><br />	Pre_Loop&#58;<br />	pop ecx<br />	inc ecx<br />Loop_Start&#58;<br />	cmp al,&#91;esi+ecx&#93;<br />	je Pre_Sub<br />	inc ecx<br />	cmp ebx,ecx<br />	jnc Loop_Start<br />	xor eax,eax<br />	jmp isOut<br />Pre_Sub&#58;<br />	push ecx<br />	mov edx,pLen<br />	mov edi,lpPattern<br />Sub_Loop&#58;<br />	mov ah,&#91;esi+ecx&#93;<br />	cmp ah,&#91;edi&#93;<br />	jne Pre_Loop<br />	inc ecx<br />	inc edi<br />	dec edx<br />	jnz Sub_Loop<br /><br />	pop eax<br />	inc eax<br />isOut&#58;<br />	pop edi<br />	pop esi<br />	pop ebx<br /><br />	ret<br />@errm2&#58;<br />    	mov eax,-2<br />    	jmp isOut<br />@errm1&#58;<br />    	sbb eax,eax<br />    	jmp isOut<br /><br />InString endp<br /></code></pre></div>
    <div class="meta">Posted on 2002-04-03 17:58:00 by The Svin</div>
   </div>
   <div class="post" id="post-48583">
    <div class="subject"><a href="#post-48583">Analyze of InString from MASM32 7</a></div>
    <div class="body">Alex,<br /><br />I took the original algorithm and put it into a test piece to play with and did a couple of the things I had in mind, the main one was to make a 4 instruction scan loop which should make the algo a bit faster.<br /><br />I have not bothered much with the conditional code at the beginning but tidied up a few places where it was obvious.<br /><br />This version should be a bit beter.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a><br /><pre><code><br />; #########################################################################<br /><br />InStringx proc startpos&#58;DWORD,lpSource&#58;DWORD,lpPattern&#58;DWORD<br /><br />  ; ------------------------------------------------------------------<br />  ; InString searches for a substring in a larger string and if it is<br />  ; found, it returns its position in eax. <br />  ;<br />  ; It uses a one &#40;1&#41; based character index &#40;1st character is 1,<br />  ; 2nd is 2 etc...&#41; for both the &quot;StartPos&quot; parameter and the returned<br />  ; character position.<br />  ;<br />  ; Return Values.<br />  ; If the function succeeds, it returns the 1 based index of the start<br />  ; of the substring.<br />  ;  0 = no match found<br />  ; -1 = substring same length or longer than main string<br />  ; -2 = &quot;StartPos&quot; parameter out of range &#40;less than 1 or longer than<br />  ; main string&#41;<br />  ; ------------------------------------------------------------------<br /><br />    LOCAL sLen&#58;DWORD<br />    LOCAL pLen&#58;DWORD<br /><br />    push ebx<br />    push esi<br />    push edi<br /><br />    invoke StrLen,lpSource<br />    mov sLen, eax           ; source length<br />    invoke StrLen,lpPattern<br />    mov pLen, eax           ; pattern length<br /><br />    cmp startpos, 1<br />    jge @F<br />    mov eax, -2<br />    jmp isOut               ; exit if startpos not 1 or greater<br />  @@&#58;<br /><br />    dec startpos            ; correct from 1 to 0 based index<br /><br />    cmp  eax, sLen<br />    jl @F<br />    mov eax, -1<br />    jmp isOut               ; exit if pattern longer than source<br />  @@&#58;<br /><br />    sub sLen, eax           ; don't read past string end<br />    inc sLen<br /><br />    mov ecx, sLen<br />    cmp ecx, startpos<br />    jg @F<br />    mov eax, -2<br />    jmp isOut               ; exit if startpos is past end<br />  @@&#58;<br />  ; ----------------<br />  ; setup loop code<br />  ; ----------------<br />    mov esi, lpSource<br />    mov edi, lpPattern<br />    mov al, &#91;edi&#93;           ; get 1st char in pattern<br /><br />    add esi, ecx<br />    neg ecx                 ; invert sign<br />    add ecx, startpos       ; add starting offset<br /><br />    jmp Loop_Start<br /><br />  ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br /><br />  Pre_Loop&#58;<br />    pop ecx                 ; restore ECX<br />    inc ecx                 ; start on next byte<br /><br />  Loop_Start&#58;<br />    cmp al, &#91;esi+ecx&#93;<br />    je Pre_Sub<br />    inc ecx<br />    jnz Loop_Start<br /><br />    jmp No_Match<br /><br />  Pre_Sub&#58;<br />    push ecx                ; preserve ECX<br />    mov edx, pLen<br />    mov edi, lpPattern<br /><br />  Sub_Loop&#58;<br />    mov ah, &#91;esi+ecx&#93;<br />    cmp ah, &#91;edi&#93;<br />    jne Pre_Loop            ; jump back on mismatch<br />    inc edi<br />    inc ecx<br />    dec edx<br />    jnz Sub_Loop            ; fall through if match<br /><br />  ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br /><br />    pop ecx                 ; restore ECX<br />    add ecx, sLen<br />    mov eax, ecx            ; match<br />    inc eax<br />    jmp isOut<br />    <br />  No_Match&#58;<br />    xor eax, eax<br /><br />  isOut&#58;<br /><br />    pop edi<br />    pop esi<br />    pop ebx<br /><br />    ret<br /><br />InStringx endp<br /><br />; ########################################################################<br /></code></pre><br /><br />Alex,<br /><br />One concession, PLEASE format you code with the &quot;[&quot;code&quot;]&quot;----&quot;[&quot;/code&quot;]&quot; so I can read it in the forum. :grin:</div>
    <div class="meta">Posted on 2002-04-04 03:44:32 by hutch--</div>
   </div>
   <div class="post" id="post-48606">
    <div class="subject"><a href="#post-48606">Analyze of InString from MASM32 7</a></div>
    <div class="body"><div class="quote">One concession, PLEASE format you code </div> <br />:)<br />I am trying, sorry I missed last one somehow.<br /><br /><br />You seem haven't got time yet to study the posts above.<br />You proc again 40% bigger and a some slower than it supposed to be with<br />proper imlementation (e.i. algo unchanged but implemented right way)<br />I again try to keep it as pure optimization topic and don't change any<br />step of your new algo, I change only the way how those steps can be<br />done.<br />As to algo itself - there are also too weak part:<br /><br />1.on start of Sub_Loop for the first iteration you check byte wich<br />is already cheked, it can be improved by putting inc registers in start of<br />loop with inc edx je - done as conditions.<br />2. you can apply using edx as both counter and pointer in Sub_Loop too.<br />As you did in first loop with ecx.<br />it eleminates need of mov edi,lpPattern each time and inc of edi.<br /><br />If anyone is insterested I can show how to do it.<br />But I don't show it in this version for simple reason - I keep it as pure<br />implementation topic: &quot;how to improve code without changing algo&quot;<br />So that your last code and the following one can be taken as <br />to codes that were generated from the same HLL source but by<br />different compilers:<br /><br />(Compare size and number and speed of instructions used to<br />replace your code)<br /><pre><code><br />InString proc startpos&#58;DWORD,lpSource&#58;DWORD,lpPattern&#58;DWORD<br />  ; -- ----------------------------------------------------------------<br />  ; InString searches for a substring in a larger string and if it is<br />  ; found, it returns its position in eax.   ;<br />  ; It uses a one &#40;1&#41; based character index &#40;1st character is 1,<br />  ; 2nd is 2 etc...&#41; for both the &quot;StartPos&quot; parameter and the returned<br />  ; character position.  ;  ; Return Values.<br />  ; If the function succeeds, it returns the 1 based index of the start<br />  ; of the substring.  ;  0 = no match found<br />  ; -1 = substring same length or longer than main string<br />  ; -2 = &quot;StartPos&quot; parameter out of range &#40;less than 1 or longer than<br />  ; main string&#41;<br />  ; ------------------------------------------------------------------<br />    LOCAL pLen&#58;DWORD<br />    push ebx<br />    push esi<br />    push edi<br /><br />    mov esi, lpSource<br />    mov edi, lpPattern<br /><br />    invoke StrLen,esi<br />    mov ebx, eax           ; ebx = source length<br />    invoke StrLen,edi<br />    mov ecx,startpos       ;ecx = startpos<br />    mov pLen, eax           ; pattern length<br />    dec ecx	       ;ecx = startpos -1<br />    js @errm2                  ;startpos &lt;= 0? yes - goto error -2<br />    sub ebx,eax	       ;ebx= sLen - pLen<br />    jc @errm1	       ; if sLen &lt; pLen goto error -1<br />    lea esi,&#91;esi&#93;&#91;ebx&#93;&#91;1&#93;    ; esi= address of part wich is &lt; pLen<br />    not ebx	       ;ebx = -&#40;ebx+1&#41;= - &#40;&#40;sLen - pLen&#41;+1&#41;<br />    add ecx,ebx	       ; ecx = startpos -1 ebx = - &#40;&#40;sLen - pLen&#41;+1&#41;<br />		       ;if ecx &gt;=  &#40;sLen - pLen&#41;+1 then<br />    jns @errm2	       ;ecx - &#40;&#40;sLen-pLen&#41;+1&#41; &gt;= 0 and SF =0<br />    mov al,&#91;edi&#93;<br />    jmp Loop_Start<br />;@@@@@@@@@<br /><br />Pre_Loop&#58;<br />   pop ecx		;restore ECX<br />   inc  ecx		;start on next byte<br />Loop_Start&#58;<br />   cmp al,&#91;esi+ecx&#93;<br />   je Pre_Sub<br />   inc ecx<br />   jnz Loop_Start<br />   xor eax,eax<br />   jmp isOut<br />Pre_Sub&#58;<br />   push ecx	;preserve ECX<br />   mov edx,pLen<br />   mov edi,lpPattern<br />Sub_Loop&#58;<br />   mov ah,&#91;esi+ecx&#93;<br />   cmp ah,&#91;edi&#93;<br />   jne Pre_Loop<br />   inc edi<br />   inc ecx<br />   dec edx<br />   jnz Sub_Loop            ; fall through if match<br />; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br /><br />    pop eax                 <br />    sub eax, ebx ;sub neg value = add positive<br />    inc eax<br />   <br />  isOut&#58;<br />    pop edi<br />    pop esi<br />    pop ebx<br />    ret<br />@errm2&#58;<br />   mov eax,-2<br />   jmp isOut<br />@errm1&#58;<br />   sbb eax,eax<br />   jmp isOut<br />InString endp<br /></code></pre></div>
    <div class="meta">Posted on 2002-04-04 09:32:27 by The Svin</div>
   </div>
   <div class="post" id="post-48607">
    <div class="subject"><a href="#post-48607">Analyze of InString from MASM32 7</a></div>
    <div class="body">Here is how to change algo itself to avoid duble checking first byte<br />wich is already checked.<br />Also no need for loading in edi each time and increasing edi.<br /><pre><code><br />InString proc startpos&#58;DWORD,lpSource&#58;DWORD,lpPattern&#58;DWORD<br />  ; ------------------------------------------------------------------<br />  ; InString searches for a substring in a larger string and if it is<br />  ; found, it returns its position in eax.   ;<br />  ; It uses a one &#40;1&#41; based character index &#40;1st character is 1,<br />  ; 2nd is 2 etc...&#41; for both the &quot;StartPos&quot; parameter and the returned<br />  ; character position.  ;  ; Return Values.<br />  ; If the function succeeds, it returns the 1 based index of the start<br />  ; of the substring.  ;  0 = no match found<br />  ; -1 = substring same length or longer than main string<br />  ; -2 = &quot;StartPos&quot; parameter out of range &#40;less than 1 or longer than<br />  ; main string&#41;<br />  ; ------------------------------------------------------------------<br />    LOCAL pLen&#58;DWORD<br />    push ebx<br />    push esi<br />    push edi<br /><br />    mov esi, lpSource<br />    mov edi, lpPattern<br /><br />    invoke StrLen,esi<br />    mov ebx, eax           ; ebx = source length<br />    invoke StrLen,edi<br />    mov ecx,startpos       ;ecx = startpos<br />    add edi,eax            ;edi=end of pattern<br />    neg eax                ;edi+eax = start of pattern<br />    mov pLen, eax           ; - &#40;pattern length&#41;<br />    dec ecx	       ;ecx = startpos -1<br />    js @errm2                  ;startpos &lt;= 0? yes - goto error -2<br />    add ebx,eax	       ;ebx= sLen - pLen<br />    js @errm1	       ; if sLen &lt; pLen goto error -1<br />    lea esi,&#91;esi&#93;&#91;ebx&#93;&#91;1&#93;    ; esi= address of part wich is &lt; pLen<br />    not ebx	       ;ebx = -&#40;ebx+1&#41;= - &#40;&#40;sLen - pLen&#41;+1&#41;<br />    add ecx,ebx	       ; ecx = startpos -1 ebx = - &#40;&#40;sLen - pLen&#41;+1&#41;<br />		       ;if ecx &gt;=  &#40;sLen - pLen&#41;+1 then<br />    jns @errm2	       ;ecx - &#40;&#40;sLen-pLen&#41;+1&#41; &gt;= 0 and SF =0<br />    mov al,&#91;edi&#93;&#91;eax&#93;  ;first byte<br />    jmp Loop_Start<br />;@@@@@@@@@<br /><br />Pre_Loop&#58;<br />   pop ecx		;restore ECX<br />   inc  ecx		;start on next byte<br />Loop_Start&#58;<br />   cmp al,&#91;esi+ecx&#93;<br />   je Pre_Sub<br />   inc ecx<br />   jnz Loop_Start<br />   xor eax,eax<br />   jmp isOut<br />Pre_Sub&#58;<br />   push ecx	;preserve ECX<br />   mov edx,pLen<br />Sub_Loop&#58;<br />   inc ecx<br />   inc edx ;don't check fist byte<br />   mov ah,&#91;esi+ecx&#93;<br />   je found ;edi+0 = pattern end<br />   cmp ah,&#91;edi&#93;&#91;edx&#93;<br />   je Sub_Loop<br />   jmp Pre_Loop   <br />   <br />; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br />found&#58;<br />    pop eax                 <br />    sub eax, ebx ;sub neg value = add positive<br />    inc eax<br />   <br />  isOut&#58;<br />    pop edi<br />    pop esi<br />    pop ebx<br />    ret<br />@errm2&#58;<br />   mov eax,-2<br />   jmp isOut<br />@errm1&#58;<br />   mov eax,-1<br />   jmp isOut<br />InString endp<br />   end<br /></code></pre></div>
    <div class="meta">Posted on 2002-04-04 10:45:03 by The Svin</div>
   </div>
   <div class="post" id="post-48608">
    <div class="subject"><a href="#post-48608">Analyze of InString from MASM32 7</a></div>
    <div class="body">I've just figured out that in last two version just 1 &quot;-2 error&quot; checking is needed for both error-2 condition :)<br />I wander if anybody esle can see why so and how to check it at once. ;)</div>
    <div class="meta">Posted on 2002-04-04 13:15:33 by The Svin</div>
   </div>
   <div class="post" id="post-48584">
    <div class="subject"><a href="#post-48584">Analyze of InString from MASM32 7</a></div>
    <div class="body">Alex,<br /><br />I had some time today to have a further play with the InString algo and one mod I tried was to start the comparison on the next byte but every version I tried fails under the condition of searching for a single byte that is at the end of the string.<br /><br />    src db &quot;This is a test of a string algorithm&quot;,0<br />    pat db &quot;m&quot;,0<br /><br />It is basically a good idea but this algo was designed particularly to handle anything that could be typed in and searching for a single byte is not uncommon with things like text search in zero terminated strings.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-04-10 22:57:31 by hutch--</div>
   </div>
   <div class="post" id="post-48585">
    <div class="subject"><a href="#post-48585">Analyze of InString from MASM32 7</a></div>
    <div class="body">Alex,<br /><br />I have done some work on the InString algo which has made the match loop shorter. You will note that  have not intergrated your suggestions yet as I have been concentrating on the loop code. I wanted a shorter matching loop so I placed the curent scan address in EBX and used ECX as an index so that the exit could be done with JNZ to save the extra compare.<br /><br />The matching loop must match the first character as it is not uncommon with an algo of this type for a user to search for a single byte which may be at the end of the string being searched.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a><br /><br /><pre><code><br />; #########################################################################<br /><br />InStringx proc startpos&#58;DWORD,lpSource&#58;DWORD,lpPattern&#58;DWORD<br /><br />  ; ------------------------------------------------------------------<br />  ; InString searches for a substring in a larger string and if it is<br />  ; found, it returns its position in eax. <br />  ;<br />  ; It uses a one &#40;1&#41; based character index &#40;1st character is 1,<br />  ; 2nd is 2 etc...&#41; for both the &quot;StartPos&quot; parameter and the returned<br />  ; character position.<br />  ;<br />  ; Return Values.<br />  ; If the function succeeds, it returns the 1 based index of the start<br />  ; of the substring.<br />  ;  0 = no match found<br />  ; -1 = substring same length or longer than main string<br />  ; -2 = &quot;StartPos&quot; parameter out of range &#40;less than 1 or longer than<br />  ; main string&#41;<br />  ; ------------------------------------------------------------------<br /><br />    LOCAL sLen&#58;DWORD<br />    LOCAL pLen&#58;DWORD<br /><br />    push ebx<br />    push esi<br />    push edi<br /><br />    invoke StrLen,lpSource<br />    mov sLen, eax           ; source length<br />    invoke StrLen,lpPattern<br />    mov edx, eax           ; pattern length<br /><br />    cmp startpos, 1<br />    jge @F<br />    mov eax, -2<br />    jmp isOut               ; exit if startpos not 1 or greater<br />  @@&#58;<br /><br />    dec startpos            ; correct from 1 to 0 based index<br /><br />    cmp  eax, sLen<br />    jl @F<br />    mov eax, -1<br />    jmp isOut               ; exit if pattern longer than source<br />  @@&#58;<br /><br />    sub sLen, eax           ; don't read past string end<br />    inc sLen<br /><br />    mov ecx, sLen<br />    cmp ecx, startpos<br />    jg @F<br />    mov eax, -2<br />    jmp isOut               ; exit if startpos is past end<br />  @@&#58;<br />  ; ----------------<br />  ; setup loop code<br />  ; ----------------<br />    mov esi, lpSource<br />    mov edi, lpPattern<br />    mov al, &#91;edi&#93;           ; get 1st char in pattern<br />    add edi, edx            ; set EDI to value for match loop<br /><br />    add esi, ecx<br />    neg ecx                 ; invert sign<br />    add ecx, startpos       ; add starting offset<br /><br />    jmp Scan_Loop<br /><br />  ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br /><br />  Pre_Scan&#58;<br />    pop ecx                 ; restore ECX<br />    inc ecx                 ; start on next byte<br /><br />  Scan_Loop&#58;<br />    cmp al, &#91;esi+ecx&#93;<br />    je Pre_Match<br />    inc ecx<br />    jnz Scan_Loop<br /><br />    jmp No_Match<br /><br />  Pre_Match&#58;<br />    push ecx                ; preserve ECX<br />    mov ebx, esi            ; put current scan<br />    add ebx, ecx            ; location in EBX<br />    mov ecx, edx            ; put pattern length into ECX<br />    add ebx, ecx            ; add it to scan location<br />    neg ecx                 ; invert sign for index<br /><br />  Test_Match&#58;<br />    mov ah, &#91;ebx+ecx&#93;<br />    cmp ah, &#91;edi+ecx&#93;<br />    jne Pre_Scan            ; jump back on mismatch<br />    inc ecx<br />    jnz Test_Match<br /><br />  ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br /><br />    pop ecx                 ; restore ECX<br />    add ecx, sLen<br />    mov eax, ecx            ; match<br />    inc eax<br />    jmp isOut<br />    <br />  No_Match&#58;<br />    xor eax, eax<br /><br />  isOut&#58;<br /><br />    pop edi<br />    pop esi<br />    pop ebx<br /><br />    ret<br /><br />InStringx endp<br /><br />; ########################################################################<br /></code></pre></div>
    <div class="meta">Posted on 2002-04-11 06:30:39 by hutch--</div>
   </div>
   <div class="post" id="post-48592">
    <div class="subject"><a href="#post-48592">Analyze of InString from MASM32 7</a></div>
    <div class="body">looking at the code <br />i have few suggestions<br /><br /><pre><code><br />    push ebx<br />    push esi<br />    push edi<br />    <br /> cmp startpos, 1<br />   <br />     jge @F<br />    mov eax, -2<br />    jmp isOut               ; exit if startpos not 1 or greater<br />    @@&#58;<br /><br />    dec startpos            ; correct from 1 to 0 based index<br />   <br />     invoke StrLen,lpPattern<br />    mov edx, eax           ; pattern length<br />    invoke StrLen,lpSource<br />  ;  mov sLen, eax           ; source length<br /><br /><br />  <br /><br />    cmp  edx, eax<br />    jl @F<br />    mov eax, -1<br />    jmp isOut               ; exit if pattern longer than source<br />  @@&#58;<br /><br /><br />   mov sLen, eax           ; source length<br /><br />     sub eax,edx<br />     inc eax<br /><br />    cmp eax, startpos<br />    jg @F<br />    mov eax, -2<br />    jmp isOut               ; exit if startpos is past end<br />  @@&#58;<br />  ; ----------------<br />  ; setup loop code<br />  ; ----------------<br />    mov esi, lpSource<br />    mov edi, lpPattern<br />    mov cl, &#91;edi&#93;           ; get 1st char in pattern<br />    add edi, edx            ; set EDI to value for match loop<br /><br />    add esi, eax<br />    neg eax                 ; invert sign<br />    add eax, startpos       ; add starting offset<br />   <br />;jmp Scan_Loop<br />;instead of the jump do <br /><br />   push edx<br />   <br /> ; @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br /><br /><br /> Scan_Loop&#58;<br />    cmp cl, &#91;esi+eax&#93;<br />    je Pre_Match<br />Pre_Scan&#58;<br />    inc eax<br />    jnz Scan_Loop<br />    ; the loop set eax to set if not found <br /><br />    jmp @loopout<br /><br />  Pre_Match&#58;<br />     lea ebx,&#91;esi+eax&#93;<br />     mov edx,&#91;esp&#93; ; get edx back instead pop and push<br />     add ebx,edx <br />     neg edx <br />  Test_Match&#58;<br />    mov ch, &#91;ebx+edx&#93;<br />    cmp ch, &#91;edi+edx&#93;<br />    jne Pre_Scan            ; jump back on mismatch<br />    inc edx<br />    jnz Test_Match<br /><br />add eax,sLen<br />inc eax<br /><br />  <br />@loopout&#58;<br />    add esp,4 ; instead of this . make local var and save edx there<br />    isOut&#58;<br />    pop edi<br />    pop esi<br />    pop ebx<br /><br /> </code></pre><br /><br />bye<br />eko</div>
    <div class="meta">Posted on 2002-04-13 13:18:46 by eko</div>
   </div>
   <div class="post" id="post-48593">
    <div class="subject"><a href="#post-48593">Analyze of InString from MASM32 7</a></div>
    <div class="body">another thinking :<br /><br /><pre><code><br /> Pre_Match&#58;<br />    <br />     mov edx,&#91;esp&#93; ; get edx back instead pop and push<br />     lea ebx,&#91;esi+eax&#93;<br />  Test_Match&#58;<br />    mov ch, &#91;edi+edx&#93;	<br />    cmp ch, &#91;ebx+edx&#93;<br />    jne Pre_Scan            ; jump back on mismatch<br />    dec edx<br />    jnz Test_Match<br /></code></pre></div>
    <div class="meta">Posted on 2002-04-13 15:17:13 by eko</div>
   </div>
   <div class="post" id="post-48586">
    <div class="subject"><a href="#post-48586">Analyze of InString from MASM32 7</a></div>
    <div class="body">eko,<br /><br />Compliments on your suggestion, you have some good coding techniques in it. I will have a play with it in this algo.<br /><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a><br /><br />Later : The only problem is that the algo does not work in this form, it just returns -1</div>
    <div class="meta">Posted on 2002-04-13 17:01:08 by hutch--</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=6725&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=6725&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="6725" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=6725&amp;page=2">&gt;</a><a href="../?id=6725&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>