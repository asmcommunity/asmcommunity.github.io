<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>NASM ON LINUX program - help needed - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29842" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=29842">NASM ON LINUX program - help needed</a></p>
   <div class="post" id="post-210852">
    <div class="subject"><a href="#post-210852">NASM ON LINUX program - help needed</a></div>
    <div class="body">this program call a function and uses printf to display the results.<br /><br />PLease help me with this code. THe program in returning a big number instead of the 10. its returing a=134520852. it should be a=10.<br /><br /><br />this is the c++<br /><br /><pre><code><br />int sum(int x)<br />{<br />int t;<br />t = x;<br />return t;<br />}<br /><br />int main()<br />{<br />int num = 3;<br /><br />printf(&quot;%d&quot;, sum(num));<br />return 0;<br /><br />}<br /></code></pre><br />this is the assembly<br /><pre><code><br /> &nbsp; &nbsp; &nbsp; &nbsp;extern printf &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; the C function to be called<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp;SECTION .data &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Data section<br /> var1 dd 40<br /><br />a:	dd	5		; int a=5;<br />fmt: db &quot;a=%d&quot;, 10, 0<br /><br />	SECTION .bss<br />		<br />flttmp:	resq 1			 &nbsp; &nbsp; &nbsp; &nbsp;; 64-bit temporary for printing flt1<br />	<br /> &nbsp; &nbsp; &nbsp; &nbsp;SECTION .text &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ; Code section.<br /><br /> &nbsp; &nbsp; &nbsp; &nbsp;global	main<br /><br />myfunction:<br />push ebp<br />mov ebp, esp<br />sub esp, 10<br />mov eax, <br />mov , eax<br /><br />mov eax, <br /><br />mov esp, ebp<br />pop ebp<br /><br /><br />ret		 &nbsp; &nbsp; &nbsp; <br />main:				 &nbsp; &nbsp; &nbsp;<br />	 <br /><br />push &nbsp; &nbsp;ebp		; set up stack frame<br /> &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; ebp,esp<br /> &nbsp; &nbsp;xor ebx, ebx<br /> &nbsp; &nbsp;push 10<br /> &nbsp; &nbsp;call myfunction<br /> &nbsp; &nbsp;push ebx<br /> &nbsp; &nbsp;pop ebx<br /> &nbsp; &nbsp;mov , ebx<br /> &nbsp; <br /> &nbsp; push dword var1<br /> &nbsp; push dword fmt<br /> &nbsp; call printf<br /> &nbsp; &nbsp;<br /> &nbsp; &nbsp;add esp, 8<br /> &nbsp; &nbsp;<br /> &nbsp; &nbsp; <br /> &nbsp; &nbsp; <br /> &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp; <br /> &nbsp; &nbsp; &nbsp; &nbsp; <br /> &nbsp;<br /> &nbsp; &nbsp; &nbsp;<br /><br /><br /><br /><br /><br /> <br /> &nbsp;<br /><br /><br /> &nbsp; &nbsp; &nbsp; &nbsp;mov &nbsp; &nbsp; esp, ebp	; takedown stack frame<br /> &nbsp; &nbsp; &nbsp; &nbsp;pop &nbsp; &nbsp; ebp		; same as &quot;leave&quot; op<br />		<br />mov eax, 0<br />ret<br /></code></pre><br /><br /></div>
    <div class="meta">Posted on 2010-02-20 12:00:04 by snoopyromeo</div>
   </div>
   <div class="post" id="post-210854">
    <div class="subject"><a href="#post-210854">Re: NASM ON LINUX program - help needed</a></div>
    <div class="body">I know people make a big deal about learning the stack layout, and YES it is important (which is honestly where you made your error). But I&#039;ve found it to be a good idea to represent the stack with structures and create @ARG and @VAR defines at the beginning of my code to specify the starting point of arguments and locals. Reason being is that this can change depending on if you are using 16-bit, 32-bit, or 64-bit mode (and can be easily made portable using %if and __BITS__ constructs in NASM). Also, for example, if you decide to change the size of a variable or argument in a procedure, updating your procedure is much easier (just modifying the structure rather than a full update of the procedure). Check out the following code:<br /><br /><pre><code>	;; Build with:<br />	;;&nbsp; nasm -f elf -o test.o test.asm<br />	;;&nbsp; gcc -o test test.o<br />	;; Execution:<br />	;;&nbsp; $ ./test<br />	;;&nbsp; a=10<br />	;;&nbsp; $<br />	BITS 32<br /><br />	%define @ARG Ebp + 8<br />	%define @VAR Ebp - 8<br />	%define SizeOf(_x_) _x_ %+ _size<br /><br />	EXTERN printf<br />	GLOBAL main<br /><br />	%macro CCall 1-*<br />	%push<br />		%define %%proc %1<br />		%assign %$ii 0<br />		%rep %0-1<br />			%rotate -1<br />			Push DWORD %1<br />			%assign %$ii %$ii + 1<br />		%endrep<br />		Call %%proc<br />		Add Esp, ( 4 * %$ii )<br />	%pop<br />	%endm<br /><br />	%macro StdCall 1-*<br />	%push<br />		%define %%proc %1<br />		%rep %0-1<br />			%rotate -1<br />			Push DWORD %1<br />		%endrep<br />		Call %%proc<br />	%pop<br />	%endm<br /><br />SECTION .data<br /><br />strFormat	DB &quot;a=%d&quot;, 10, 0<br /><br />SECTION .text<br /><br />MyFunction:<br />STRUC MFA<br />.x	RESD 1<br />ENDSTRUC<br />STRUC MFL<br />.t	RESD 1<br />ENDSTRUC<br />	Push Ebp<br />	Mov Ebp, Esp<br />	Sub Esp, SizeOf( MFL )<br /><br />		;; --[ Store Argument in Eax ]--<br />		; Mov Eax, <br />		;; --<br />		Mov Eax, [@ARG + MFA.x]<br /><br />		;; --[ Store Eax in Local ]--<br />		; Mov , Eax<br />		;; --<br />		Mov [@VAR - MFL.t], Eax<br /><br />		;; --[ Store Local in Eax ]--<br />		; Mov Eax, <br />		;; --<br />		Mov Eax, [@VAR - MFL.t]<br /><br />	Leave<br />	Ret SizeOf( MFA )<br /><br />main:<br />STRUC ENV<br />.argc	RESD 1<br />.argv	RESD 1<br />.envp	RESD 1<br />ENDSTRUC<br />	Push Ebp<br />	Mov Ebp, Esp<br /><br />		StdCall MyFunction, 10<br />		CCall printf, strFormat, Eax<br />	Leave<br />	Ret</code></pre><br /><br />Also take note that MyFunction is written using StdCall calling convention whereas main is CDECL calling convention. StdCall has the procedure clean up the stack and is generally a much more optimal strategy when you know how many arguments are being used. This difference of calling convention explains why the prologue for these procedures are different.<br /><br />I am by no means telling you to forget learning about the stack layout. You NEED to learn the stack layout. But using the old  style of accessing values just obfuscates your code, not so much in yours but when working with a bunch of local variables (some which could be structures like WNDCLASSEX which has bunch of elements) paired with the fact that people who do this rarely comment those lines do make updating it more difficult later on and horrible on 3rd party readers of your code.<br /><br />Regards,<br />Bryant Keller<br /></div>
    <div class="meta">Posted on 2010-02-20 12:56:20 by Synfire</div>
   </div>
   <div class="post" id="post-210855">
    <div class="subject"><a href="#post-210855">Re: NASM ON LINUX program - help needed</a></div>
    <div class="body">That may all be true, but the main problem is &quot;push dword var1&quot;. That&#039;s the address of your variable - the big number you&#039;re seeing. You want &quot;push dword &quot;, the &quot;&quot; of the variable. That would show zero. You&#039;ve zeroed ebx, pushed it and popped it, and put it in &quot;&quot;. Still zero. The result of &quot;myfunction&quot; (in eax) never gets used.<br /><br />Since C expects ebx to be preserved across a function call, altering it may cause your program to crash after the &quot;ret&quot;.<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-02-20 22:55:06 by fbkotler</div>
   </div>
  </div>
 </body>
</html>