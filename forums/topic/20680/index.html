<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Simulated Physics - Dynamic and Static Forces - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=20680" />
    <link rel="next" href="../?id=20680&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=20680">Simulated Physics - Dynamic and Static Forces</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=20680&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=20680&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="20680" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=20680&amp;page=2">&gt;</a><a href="../?id=20680&amp;page=2">&raquo;</a></form>   <div class="post" id="post-157583">
    <div class="subject"><a href="#post-157583">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">I'm hoping this thread will create a discussion regarding some of the various integration methods out there.<br /><br />I'll get the ball rolling with Euler Integration.<br />I'm going to keep it pretty simple (yeah, right) by deliberately ignoring ROTATION and by only mentioning DYNAMICS equations (at least for now).<br /><br />For those of you who managed to pick up some physics during your school days, you may recall the following formulae:<br /><br /><pre><code>f=ma &#40;FORCE = MASS * ACCELERATION&#41;</code></pre><br /><pre><code>a=dV/dT &#40;ACCELERATION = deltaVELOCITY / deltaTIME&#41;</code></pre><br /><pre><code>v=dD/dT &#40;VELOCITY = deltaDISTANCE / deltaTIME&#41;</code></pre><br /><br />CALCULATE ACCELERATION<br />It should be clear enough that if we presume to KNOW the values for &quot;f&quot; and &quot;m&quot;, then we can substitute the formula and calculate a=f/m , yes?<br /><br />CALCULATE VELOCITY - A TASTE OF INTEGRATION<br />It follows that having calculated a=f/m, and presuming we KNOW deltaTIME, we can substitute again and calculate dV=a*dT.<br />We might choose at this moment to INTEGRATE the above two formulae, such that we can find dV=(f/m)*dT in a single step.<br />Also, we can integrate once more to find V<br />If I=initial velocity , to find new velocity V:<br /><pre><code>V = I + &#40;&#40;f/m&#41;*dT&#41;</code></pre><br /><br />CALCULATE DISTANCE - INTEGRATE AGAIN?<br />Again following this logic, since we calculated dV=a*dT, and since we already know the value of dT, we can once more substitute to calculate dD=V*dT.<br /><br />Let's take it to the next level.<br />By substitution, dD = (I + ((f/m)*dT)) * dT<br />We could if we wanted to integrate yet again..<br />If P = initial position, to find new position Q:<br /><pre><code>Q = P + &#40; I + &#40;&#40;f/m&#41;*dT&#41;&#41; * dT &#41;</code></pre><br />As long as we remember to grab the new Velocity out of the formula, theres no reason why we can't integrate all these calculations into one, and write a procedure which calculates new Velocity and Position at once, and call it UpdateObject or something like that.<br /><br />We now have a basic set of formulae for calculating the new position and velocity of an object based on its old position, velocity, and summed input Force (includes Gravity), after some amount of Time has passed (known as the TimeStep).<br /><br />What may not be so obvious is that we may use what we have learned to calculate the position and velocity of the object at any future (or past!) moment in Time.<br /><br />This becomes critical when we begin attempting to implement a Collision Response. What we will be doing is calculating the exact moment when a collision occurs, then from that, calculating the position of the object at the moment of collision, then modifying the object velocity (reflecting the collision ray), and then repositioning the object to where it SHOULD have been, had it not passed through the wall it was meant to bounce off, ie move the object along the new r&quot;reflected&quot; ray by the same distance it had passed through the wall when it collided.<br /><br />All we are really doing is throwing our current object values and various Time values at the formulae above.<br /><br />One thing I note immediately with regard to gamecoding is that the value deltaTime is quite simply the elapsed time between frames.<br />Most of the sourcecode I've looked at uses &quot;fixed timesteps&quot; which create a flawed physical model simulation that is prone to &quot;jerkyness&quot;, especially where the actual timestep fluctuates greatly.<br /><br />Is this just another example of cut and paste coding, or is there some reason why a hardcoded timestep is a Good Thing? (I am led to believe that Runge-Kutta Integration performs poorly with fluctuating timesteps, but I really don't understand the benefits of RK either).<br /><br />Who wants to shed some light on Runge-Kutta and Verlette integration, and who can describe something else, maybe something new?</div>
    <div class="meta">Posted on 2005-03-01 07:33:19 by Homer</div>
   </div>
   <div class="post" id="post-157586">
    <div class="subject"><a href="#post-157586">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">Hello Homer,<br /><br />Just some comments from me.<br /><br />You mentioned Euler integration but I have not seen anything on it here. If I am not wrong Euler integration is a numerial method right?<br /><br />I would like to point out that your definitions are wrong<br /><br />a=dV/dT (ACCELERATION = deltaVELOCITY / deltaTIME)<br />should be<br />a=dV/dT (ACCELERATION = deeVELOCITY / deeTIME)<br /><br />Your usage of delta is wrong. deltavelocity is completely different from deevelocity (deeVee). delta means a small increment or decrement while deeVee on the other hand means limits as delta approaches 0.<br /><br />Anyway your integration does not look like integration at all.  :) <br /><br />PS: I just went through a series of lectures on mechanics (including particle under variable force) , so I guess now is the right time to dicuss :)<br /><br />Regards,<br />Victor</div>
    <div class="meta">Posted on 2005-03-01 10:02:22 by roticv</div>
   </div>
   <div class="post" id="post-157606">
    <div class="subject"><a href="#post-157606">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">a=dV/dT<br />I was taught many years ago that dV = change in velocity.<br /><br />a=(d2-d1) / (t2-t1) is not correct?<br /><br />You mention deeVelocity and also that it should be limited as it approaches zero. Limited in what way? Are you simply inferring that due to numerical inaccuracy that small values near zero should be replaced with zero, for example -.0001 = 0 = +.0001 ?<br />I wasn't aware this was being implied by the formulae, although I've seen such mechanisms in source, I was under the impression they were to prevent numerical drift.<br /><br />As for Euler integration, <br /><br />1. Set Time to its initial value.<br />2. Initialize the levels.<br />3. Compute the rates of change of the Levels at the current value of Time.<br />4. Use the rates of change to compute the Levels at Time + TIME STEP according to the formula:<br /> LEVELTime+TIME STEP = LEVELTime + TIME STEP * RATETime <br />5. Add TIME STEP to Time.<br />6. Repeat steps 3-5 until Time is equal to FINAL TIME.<br /><br />It's basically using the formulae I gave with incremental value of Time.<br />Correct?<br />AFAIK Euler Integration is a method of APPROXIMATING the &quot;levels&quot; of a closed system at any moment in time, but it assumes that the &quot;rates of change&quot; are CONSTANT for a given TimeStep. For example, that Acceleration at T1 is the same as Acceleration at T2, is the same as Acceleration at any moment between T1 and T2. This is simply incorrect and is the cause of the inaccuracy of Euler's method. The inaccuracy can be minimized by using very small TimeSteps, but this is simply not a viable solution in a time-critical application. For example, one source I saw divided each &quot;elapsed frame&quot; worth of Time into 150 TimeSteps, then applied 150 iterations of physics equations to each and every object, including 150 intersection tests between each object and everything else in the world... this is WAY too expensive.<br /><br /><br />I'm NOT a physics guru, and CERTAINLY NOT a grand master of simulation, which is why I chose to post this thread here in this forum.<br />I know a lot of you are currently studying this stuff, some of you are studying physics and CS at once, and more than likely have your own ideas to bring to the table. <br />By all means, do so :)<br /><br />Thanks to Roticv for the feedback, much appreciated.</div>
    <div class="meta">Posted on 2005-03-01 23:03:05 by Homer</div>
   </div>
   <div class="post" id="post-157607">
    <div class="subject"><a href="#post-157607">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">For the sake of discussion of Particle Physics, I'd like to use the example of a Sphere object. Let's describe a Sphere using the following structure:<br /><br /><pre><code><br />Sphere struct<br /> vPosition Vec3 &lt;&gt;        ;Sphere Position in 3D space &#40;CURRENT&#41;<br /> vOldPos   Vec3 &lt;&gt;       ;Sphere Position in 3D space &#40;OLD&#41;<br /> vVelocity Vec3  &lt;&gt;      ;Sphere Velocity<br />  fRadius REAL8 ?<br />  fMass REAL4 ?<br />Sphere ends<br /></code></pre><br /><br />Let's assume that the Sphere begins life at some position (X,Y,Z) in space, with zero velocity, and Time=0. Let's further assume that the only external force acting on the Sphere is Gravity. Finally, let's assume that the Mass of the Sphere is 2.0<br /><br />Now let's assume that some Time has passed, such that Time=0.500 (half a second has elapsed).<br />Let's start calculating :)<br />First, we wanna know the Acceleration in order to obtain Velocity.<br />The formula f=ma (or rather, a=f/m) is what we need to use.<br />Since we know the Mass in this case is 1, its quite simple:<br />a=f/2<br />Let's assume the Gravity force has a value of 0.86, represented as a Vector:<br />G=&lt;0.0f, -0.86f, 0.0f&gt;<br />We can now calculate the Acceleration a due to Gravity G:<br />a=&lt;0.0f, -0.43f, 0.0f&gt;<br /><br />Having done this we can now calculate the change in velocity due to acceleration over Time:<br />a=dV/dT, or rather, dV=a*dT<br />Since we know that dT=0.500 seconds, it follows that<br />dV=&lt;0.0f, -0.215f, 0.0f&gt;<br />and thus we can calculate the New Velocity=OldVelocity+dV<br />(not shown).<br />Having done that, we can calculate the change in Position due to Velocity over Time, and then we have a new Position and Velocity.<br /><br />Should we wish to impart further external forces on the object, we should simply sum their vectors into the &quot;f&quot; vector.<br /><br />Now we have our Sphere object accelerating under Gravity.<br />Let's suppose that we have a flat Plane on the &quot;floor&quot; which we want our Sphere to collide with, and then deflect from (bounce off).<br />We will assume that the Surface has a Normal vector already calculated.<br />We will also assume we are capable of calculating the Distance from a given Plane to a given Point In Space.<br />We should measure the Distance from the Plane to the Sphere Center.<br />If the distance is greater than the Radius of the Sphere, then the Sphere is NOT intersecting the Plane, and everything is cool.<br />If the distance is &lt;= the Sphere Radius, then the Sphere has intersected the Plane, and we need to &quot;fix&quot; the situation.<br /><br />I need to make a diagram or something to illustrate this further, before I describe the formulae for resolving the collision. The beautiful part of the formulae I will be documenting is that the plane doesn't have to be on the &quot;floor&quot;, it could be a ceiling, a wall, or part of a slope, the collision will still be resolved correctly no matter what is going on.<br />For the purposes of discussion I choose to describe a sphere falling onto a flat floor plane with its Normal facing UP, simply because its easy to visualize.<br />Now I'm off to make some crap art :)</div>
    <div class="meta">Posted on 2005-03-02 00:16:46 by Homer</div>
   </div>
   <div class="post" id="post-157608">
    <div class="subject"><a href="#post-157608">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">Note that the Sphere has a field for &quot;Old Position&quot;.<br /><br />The order of operations might look something like this:<br />-Calculate new velocity, and thus new position<br />-Check for intersection(s)...<br />-If Intersection detected, <br />--Calculate T=Time Of Intersection<br />--Calculate Position and Velocity at T<br />--Set OLD POSITION to Collision Point<br />--Calculate Reflection as Force<br />--Apply Reflection as input Force<br />--Calculate Position and Velocity at end of current TimeStep<br />--Set CURRENT POSITION to the above values<br />-Else<br />--Set OLD POSITION = CURRENT POSITION<br />-EndIf<br /><br />How does that sound?</div>
    <div class="meta">Posted on 2005-03-02 00:58:41 by Homer</div>
   </div>
   <div class="post" id="post-157618">
    <div class="subject"><a href="#post-157618">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">Hello Homer,<br /><br />You are correct that a = dv/dt. <br />However dv/dt is defined as lim ?t -&gt; 0 (v+?v)/(t+?t) where ?t = deltatime and ?v = deltavelocity (Just some elementary calculus).<br /><br />a = (v1 - v2)/(t1 - t2)<br />Provided v is constant. If not you would have to solve using real integration.<br /><br />I am not very sure about Euler's integration, I would read up more on it before commenting on that. <br /><br />By the way collisions somehow reminds me of principle of conservation of momentum and resitutition. The kind of mechanics crap that I have to put up with for the rest of the year.<br /><br />PS: I like to think of g as 9.81ms^-1.  :-D <br />PSS: Off to do some mechanics homework  :)<br /><br />Sorry if I am not really helping you, I am just looking more at the mechanical perpective rather than how to code it etc etc.</div>
    <div class="meta">Posted on 2005-03-02 08:21:32 by roticv</div>
   </div>
   <div class="post" id="post-157623">
    <div class="subject"><a href="#post-157623">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">is euler integrating the same as just calculating the riemann sum? (which is part of the definition of integrating).</div>
    <div class="meta">Posted on 2005-03-02 12:44:59 by lifewire</div>
   </div>
   <div class="post" id="post-157641">
    <div class="subject"><a href="#post-157641">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">I have no idea what the Riemann Sum is about.<br />Euler integration assumes that rates of change are constant between the start and end times, and therefore that various values can be extrapolated at any moment BETWEEN the start and end times.<br />Since things like Acceleration are exceedingly unlikely to be linear (let alone constant), Euler's method only produces reasonably accurate results when the time intervals applied are very small, and is only perfectly accurate when the time intervals are infinitely small.<br />Therefore its really not much good for this particular application.<br /><br />The resolving of a collision is indeed about conservation of energy (read momentum). In the example of a moving object colliding with a static planar surface, we see the linear and angular momentum of an object as both inputs to the collision and as outputs resulting from it. That is to say, depending on the angles involved in the collision, energy is transformed from one to the other - an object that is moving slowly but rotating quickly before it collides may be moving quickly but rotating slowly after the collision. The surface itself plays a small part in this because it has at the very least a &quot;coefficient of restitution&quot; which indicates how much energy is ABSORBED by the surface (is LOST to the object), and may well have other properties such as a friction coefficient.</div>
    <div class="meta">Posted on 2005-03-02 22:41:59 by Homer</div>
   </div>
   <div class="post" id="post-157642">
    <div class="subject"><a href="#post-157642">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">Ok heres that crap art I mentioned earlier.. <br /><br />Image #1 shows our Sphere at various Times.<br />Beginning at Time 0, our sphere is born into existance.<br />Time passes, and it begins to fall under the force of Gravity.<br />By Time 1 we can see it descending toward the Surface Plane.<br />However, at Time 2, the Sphere has penetrated the Surface considerably.<br /><img src=" http://homer.ultrano.com/Upload/Image1.bmp " /><br /><br />There must have been a collision at some moment between Time 1 and Time 2. <br />Image#2 shows our Sphere at Time 0 (same as before), at Time 1 (same as before) and also shows a new Time X (moment of impact) and Time 2 (where the bloody thing SHOULD be if everything is working).<br />This image also shows the sphere's Direction of Travel at each TimeStep  using some arrows.<br /><img src=" http://homer.ultrano.com/Upload/Image2.bmp " /><br /><br />Having determined that an impact occured between T1 and T2 (as in Image#1) is obviously not enough information for accurate simulation.<br />What we really need is a way to determine the actual moment of impact (Time X), and the position, direction and speed of the Sphere at that moment.<br />I'm going to give you a procedure which is capable of A) determining if a collision has occured in the current TimeStep and B) returning the deltaTime (from T1) to the moment of impact, the position of the sphere at that moment, the direction, and the speed.<br />After that we'll take a look at how to resolve the collision.</div>
    <div class="meta">Posted on 2005-03-02 22:49:36 by Homer</div>
   </div>
   <div class="post" id="post-157645">
    <div class="subject"><a href="#post-157645">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">As promised, here is a procedure which can not only determine whether a collision occurred during the current Frame, but also return the relative time when impact occurred, and the object position at the moment of impact. This allows us to &quot;correct&quot; the position of the object and then to &quot;project&quot; the position for (TimeStep-deltaTime) in order to put the bugger where it ought to be (at &quot;T2&quot;, post-collision).<br />We can even determine if the object was ALREADY intersecting (&quot;touching&quot;) the Surface, which will be important later when we want to apply STATIC FORCES to the object (ie make it slide/roll around on the ground).<br />Of course, an object should never be &quot;already intersecting&quot; for the example at hand. Our objects always begin life in mid-air.<br /><br />This procedure is obviously FAR MORE USEFUL than one which simply returns TRUE or FALSE for a collision test, as it sets us well on track toward RESOLVING the collision.<br /><br /><pre><code><br />;===============================================<br />;This procedure tests for intersection of a given Plane and Sphere.<br /><br />;If no collision is found, it returns FALSE.<br />;If a collision is found, it returns TRUE, and also returns<br />;the exact Time of the collision and Position of the Sphere at that moment.<br /><br />;IN pNormal = The Plane given as Surface Normal, which we assume has been precalculated from the &quot;first triangle&quot; in the Quad.<br />;IN pSphere = ptr to Sphere struct<br />;OUT pFirstTouched = position of sphere&#40;'s origin&#41; at moment of impact<br />;OUT pTouchTime = deltaTime to the moment of impact<br />;===============================================<br />SpherePlaneSweep proc pNormal&#58;ptr Vec3, pSphere&#58;ptr Sphere, pFirstTouched&#58;ptr Vec3, pTouchTime&#58;DWORD<br />local fd0&#58;REAL8 ;&lt;== distance from Plane to &#40;previous position of sphere&#41;<br />local fd1&#58;REAL8 ;&lt;== distance from Plane to &#40;current position of sphere&#41;<br /><br />;Calculate distance from Plane to OLD POSITION of Sphere<br />mov ecx,pSphere<br />invoke PlaneDistance,pNormal, addr &#91;ecx&#93;.Sphere.vOldPos<br />fstp fd0<br /><br />;check if it was touching on previous &quot;TimeStep&quot;<br />;&#40;ie is distance from Plane to OLD POSITION less than the Sphere's Radius?&#41;<br />fld fd0<br />fabs<br />mov ecx,pSphere<br />fld &#91;ecx&#93;.Sphere.fRadius<br />fcomp &#91;ecx&#93;.Sphere.fRadius<br />__FJLE @F                ;if&#40; fabs&#40;d0&#41; &lt;= r &#41;<br /><br />mov ebx,pFirstTouched           ;Ci = C0<br />mov ecx,pSphere<br />fld &#91;ecx&#93;.Sphere.vOldPos.X<br />fld &#91;ecx&#93;.Sphere.vOldPos.Y<br />fld &#91;ecx&#93;.Sphere.vOldPos.Z<br />fstp &#91;ebx&#93;.Vec3.Z<br />fstp &#91;ebx&#93;.Vec3.Y<br />fstp &#91;ebx&#93;.Vec3.X<br />mov ebx,pTouchTime<br />fld r4_0_0                                  ;u = 0;<br />fstp REAL4 ptr&#91;ebx&#93;<br />return TRUE<br /><br />@@&#58;<br />mov ecx,pSphere<br />invoke PlaneDistance, pNormal, addr &#91;ecx&#93;.Sphere.vPosition<br />fstp fd1<br /><br />;//check if the sphere penetrated during this &quot;TimeStep&quot;<br />;if&#40; d0&gt;r &amp;&amp; d1&lt;r &#41;<br />fld fd0                                                 ;if&#40; d0&gt;r<br />fcomp &#91;ecx&#93;.Sphere.fRadius<br />__FJG @F<br />fld fd1                                                 ;&amp;&amp; d1&lt;r&#41;<br />fcomp &#91;ecx&#93;.Sphere.fRadius<br />__FJL @F<br /><br />;Message &quot;Penetrated This TimeStep&quot;<br />;u = &#40;d0-r&#41;/&#40;d0-d1&#41;; //normalized time<br />mov ebx,pTouchTime<br />fld fd0<br />fsub &#91;ecx&#93;.Sphere.fRadius<br />fld fd0<br />fsub fd1<br />fdiv<br />fstp dword ptr&#91;ebx&#93;<br /><br />;Ci = &#40;1-u&#41;*C0 + u*C1; //point of first contact<br />mov ebx,pTouchTime<br />fld1<br />fsub REAL4 ptr&#91;ebx&#93;<br />fmul &#91;ecx&#93;.Sphere.vOldPos.X<br />fld REAL4 ptr&#91;ebx&#93;<br />fmul &#91;ecx&#93;.Sphere.vPosition.X<br />fadd<br />mov ebx,pFirstTouched<br />fstp &#91;ebx&#93;.Vec3.X<br /><br />mov ebx,pTouchTime<br />fld1<br />fsub REAL4 ptr&#91;ebx&#93;<br />fmul &#91;ecx&#93;.Sphere.vOldPos.Y<br />fld REAL4 ptr&#91;ebx&#93;<br />fmul &#91;ecx&#93;.Sphere.vPosition.Y<br />fadd<br />mov ebx,pFirstTouched<br />fstp &#91;ebx&#93;.Vec3.Y<br /><br />mov ebx,pTouchTime<br />fld1<br />fsub REAL4 ptr&#91;ebx&#93;<br />fmul &#91;ecx&#93;.Sphere.vOldPos.Z<br />fld REAL4 ptr&#91;ebx&#93;<br />fmul &#91;ecx&#93;.Sphere.vPosition.Z<br />fadd<br />mov ebx,pFirstTouched<br />fstp &#91;ebx&#93;.Vec3.Z<br />return TRUE<br /><br />@@&#58;<br />;No penetration occured during this &quot;TimeStep&quot;<br />return FALSE<br />SpherePlaneSweep endp<br /><br /></code></pre></div>
    <div class="meta">Posted on 2005-03-02 23:59:30 by Homer</div>
   </div>
   <div class="post" id="post-157646">
    <div class="subject"><a href="#post-157646">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">There's just one problem with that procedure which I have noticed so far.<br />The returned &quot;touchpoint&quot; is the point of intersection ON THE PLANE.<br />It is NOT the &quot;corrected position of the Sphere Origin&quot;.<br />We need to move the Sphere by an amount equal to its Radius and in the direction which is NEGATIVE to the pre-collision direction, ie, back the way it came from.<br />Since our Velocity contains both Speed and Direction, we must Normalize the Velocity in order to get the Direction, then negate it so we have &quot;minus vDirection&quot;, then multiply it by the Sphere Radius to obtain a &quot;positional offset&quot;, then add the Position , and store as Position.<br /><br />I note a rather obvious optimisation here.<br />Rather than negating the xyz of the Direction vector, we can simply negate the Radius value instead and obtain the same result.<br />Not much of an optimisation, but every bit helps.</div>
    <div class="meta">Posted on 2005-03-03 01:12:00 by Homer</div>
   </div>
   <div class="post" id="post-157647">
    <div class="subject"><a href="#post-157647">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">I know this code looks rather complex for a sphere that falls down onto a surface that faces up, so let me exclaim loudly, just one more time, &quot;THIS STUFF WORKS FOR ALL CASES&quot;. The orientation of the surface and the direction of travel of the sphere are totally irrelevant.  If we build a rectangular room with six surfaces, the sphere will bounce around inside the room as it should. If we tilt the room on 45 degrees, the sphere will STILL behave itself. Happy Day :)</div>
    <div class="meta">Posted on 2005-03-03 01:19:36 by Homer</div>
   </div>
   <div class="post" id="post-157665">
    <div class="subject"><a href="#post-157665">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">It is more fun if you consider drag force (laminar) due to air acting on the sphere when undergoing free fall.<br /><br />ma = W + kv<br />ma = mg + kv<br />a = g + kv/m<br />dv/dt = (mg + kv)/m<br />m/(mg+kv) dv/dt = 1<br />m/k ln  = t if t=0,v=0<br /><br />Then you would have a more interesting equation, one which can be solved by solving Differential equations.<br /><br />Maybe I am spourting rubbish here. Please forgive me  :-D</div>
    <div class="meta">Posted on 2005-03-03 10:53:46 by roticv</div>
   </div>
   <div class="post" id="post-157668">
    <div class="subject"><a href="#post-157668">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">but wouldnt airfriction be unnesserary computional, below a certain speed?<br />for example a car, when hitting 70km/h, start calc airfriction?</div>
    <div class="meta">Posted on 2005-03-03 13:01:18 by daydreamer</div>
   </div>
   <div class="post" id="post-157677">
    <div class="subject"><a href="#post-157677">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">Ultrano - <br />Resistance in the direction of travel due to Drag is easier to implement than that - all you do is multiply the current Velocity by a coefficient between 0 and 1, which is how I slow my Camera down.<br />However, should the density of the medium change (for example, an object collides with the surface of a lake) then things get more interesting.<br />We have to start treating objects as collections of particles and apply perparticle physics to obtain correct results in such conditions, although there's shortcuts for specific geometries, general cases require more math than specific cases.<br /><br />Daydreamer - <br />Using the method I just described, the drag is dependant on the velocity - the faster you travel, the more drag you experience. Simple is good.</div>
    <div class="meta">Posted on 2005-03-03 21:12:39 by Homer</div>
   </div>
   <div class="post" id="post-157678">
    <div class="subject"><a href="#post-157678">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">I'm getting some strange results from my existing code, and I'd appreciate some help.<br /><br />Probably the single most important procedure I am calling is called PointAndPlane. It's a lot like &quot;PlaneDistance&quot; in that it compares a 3D point in space to a Plane and returns the distance between the point and the plane (positive = in front, negative = behind, 0 = on plane), but uses different formula to calculate it. <br /><br />The formula is (X ? P) . N<br />where X is the point being tested, P is some point on the plane, and N is the surface normal of the plane.<br /><br />This seems pretty straightforward, and I doubt there is any bug here.<br />Here is my code:<br /><pre><code><br />PointAndPlane proc pPointOnPlane, pNormalOfPlane, pPointToCheck<br />local lvec&#58;Vec3<br />mov ebx, pPointOnPlane<br />mov ecx, pPointToCheck<br />fld &#91;ecx&#93;.Vec3.X<br />fsub &#91;ebx&#93;.Vec3.X<br />fstp lvec.X<br />fld &#91;ecx&#93;.Vec3.Y<br />fsub &#91;ebx&#93;.Vec3.Y<br />fstp lvec.Y<br />fld &#91;ecx&#93;.Vec3.Z<br />fsub &#91;ebx&#93;.Vec3.Z<br />fstp lvec.Z<br />invoke Vec3Dot,addr lvec,pNormalOfPlane<br />ret<br />PointAndPlane endp<br /></code></pre><br /><br />The Vec3Dot procedure leaves its result on the fpu, and thus the PointAndPlane procedure does as well.<br />I better post the code for Vec3Dot now.<br /><pre><code><br />;This computes the dot product of 2 vectors<br />; ** WARNING ** The return value is on the FPU STACK<br />Vec3Dot proc uses esi edi pVector1, pVector2<br />; The dot product is this equation&#58; V1.V2 = &#40;V1.x * V2.x  +  V1.y * V2.y  +  V1.z * V2.z&#41;<br />; In math terms, it looks like this&#58;  V1.V2 = ||V1|| ||V2|| cos&#40;theta&#41;.<br />; It returns the distance of the projected vector, vVector2, from the start of vVector1.<br />        mov esi,pVector1<br />        mov edi,pVector2<br />        fld &#91;esi&#93;.Vec3.X<br />        fmul &#91;edi&#93;.Vec3.X<br />        fld &#91;esi&#93;.Vec3.Y<br />        fmul &#91;edi&#93;.Vec3.Y<br />        fld &#91;esi&#93;.Vec3.Z<br />        fmul &#91;edi&#93;.Vec3.Z<br />        fadd<br />        fadd<br />        ret<br />Vec3Dot endp<br /></code></pre><br /><br />Why am I posting this stuff?<br />Simple - I am getting obviously incorrect Distances from the above code.<br />This is screwing everything up. Look at this line taken from my debug logfile:<br /><br />Frame: 294  Time = 4.8443883230969296 Seconds FPS = 60.68878<br />SphereCenter Distance to Plane = 1061.819 : Y=1.611078<br /><br />I have a flat rectangular surface in XZ, at Y=0 height.<br />From the first of the two triangles I extract my SurfaceNormal.<br />When I test against this plane I give the first vertex of the first triangle as the &quot;poiint on plane&quot;.<br />If my test point is roughly Y=1.6, how the hell can I be roughly 1062 units away from the plane? That's crazy.<br />I have another procedure for calculating planedistance as I mentioned, but its only valid in &quot;world space&quot;, whereas this one is able to be applied in &quot;object space&quot; (not that I am doing this right now, it's just nice to have options, right?) so I'd really like to see this one working.<br /><br />I can provide more information for example the calculation of SurfaceNormal and the vertices of the quad surface, but tell me, is there any obvious problem in what I have presented today?</div>
    <div class="meta">Posted on 2005-03-03 21:49:26 by Homer</div>
   </div>
   <div class="post" id="post-157683">
    <div class="subject"><a href="#post-157683">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">Well, I can confirm that my code for calculating SurfaceNormals from Triangles is working fine. I suspected this already, because I have lighting enabled, and the surface is being lit appropriately.<br />Anyhow, here's another line from my LogFile:<br /><br />SurfaceNormal: X-0.000000e+647 Y1 Z0<br /><br />It really should be 0,1,0 <br />but I think we can call -0.000000e+647 close enough to 0, yes?<br /><br />So, the Floor surface is definitely pointing &quot;upwards&quot;...<br /><br />For those who might be interested, here is the source for calculating SurfaceNormal from Triangle, along with all relevant math functions, all apparently working 100% :)<br /><pre><code><br />SurfaceNormalFromTriangle proc pTriangle, pDest<br />local vVector1&#91;3&#93;&#58;FLOAT<br />local vVector2&#91;3&#93;&#58;FLOAT<br />local vNormal&#91;3&#93;&#58;FLOAT<br />; Get 2 vectors from the polygon &#40;2 sides&#41;, Remember the order!<br />; &#40;Triangles are 3 floats, ie, 12 bytes each&#41;<br />            mov ebx,pTriangle<br />            add ebx,&#40;sizeof Vec3*2&#41;<br />            invoke VectorFrom2Points, ebx, pTriangle, addr vVector1http&#58;//www.asmcommunity.net/board/posting.php?mode=editpost&amp;p=157683<br />            mov ebx,pTriangle<br />            add ebx,&#40;sizeof Vec3&#41;<br />            invoke VectorFrom2Points, ebx,pTriangle, addr vVector2<br />; Take the cross product of our 2 vectors to get a perpendicular vector<br />            invoke Vec3Cross, addr vVector2, addr vVector1, pDest<br />; Now we have a normal, but it's at a strange length, so let's make it length 1.<br />            invoke Vec3Normalize, pDest<br /> ret<br />SurfaceNormalFromTriangle endp<br /><br />; This proc calculates the vector between 2 points<br />VectorFrom2Points proc uses ecx esi edi pPoint1, pPoint2, pDest<br />            mov esi, pPoint1<br />            mov edi,pPoint2<br /><br />            xor eax,eax<br />            mov ecx,pDest<br />            mov &#91;ecx&#93;.Vec3.X,eax<br />            mov &#91;ecx&#93;.Vec3.Y,eax<br />            mov &#91;ecx&#93;.Vec3.Z,eax<br /><br />; In order to get a vector from 2 points &#40;a direction&#41; we need to<br />; subtract the second point from the first point.<br />            fld &#91;esi&#93;.Vec3.X<br />            fsub &#91;edi&#93;.Vec3.X<br />            fstp &#91;ecx&#93;.Vec3.X<br />            fld &#91;esi&#93;.Vec3.Y<br />            fsub &#91;edi&#93;.Vec3.Y<br />            fstp &#91;ecx&#93;.Vec3.Y<br />            fld &#91;esi&#93;.Vec3.Z<br />            fsub &#91;edi&#93;.Vec3.Z<br />            fstp &#91;ecx&#93;.Vec3.Z<br /> ret<br />VectorFrom2Points endp<br /><br />;This proc calculates a perpendicular vector from 2 given vectors by taking the cross product.<br />;Returns in given buffer the cross product &#40;Direction the polygon is facing - Normal&#41;           <br />Vec3Cross proc uses ecx esi edi pVector1, pVector2 , pDest<br /><br />; If we are given 2 vectors &#40;directions of 2 sides of a polygon&#41;<br />; then we have a plane define.  The cross product finds a vector that is perpendicular<br />; to that plane, which means it's point straight out of the plane at a 90 degree angle.<br /> <br />            mov esi,pVector1<br />            mov edi,pVector2<br />            mov ecx,pDest<br /><br />; The X value for the vector is&#58;  &#40;V1.y * V2.z&#41; - &#40;V1.z * V2.y&#41; <br />; vNormal.x = &#40;&#40;vVector1.y * vVector2.z&#41; - &#40;vVector1.z * vVector2.y&#41;&#41;;<br />            fld &#91;esi&#93;.Vec3.Y<br />            fmul &#91;edi&#93;.Vec3.Z<br />            fld &#91;esi&#93;.Vec3.Z<br />            fmul &#91;edi&#93;.Vec3.Y<br />            fsub<br />            fstp &#91;ecx&#93;.Vec3.X<br />              <br />; The Y value for the vector is&#58;  &#40;V1.z * V2.x&#41; - &#40;V1.x * V2.z&#41;<br />; vNormal.y = &#40;&#40;vVector1.z * vVector2.x&#41; - &#40;vVector1.x * vVector2.z&#41;&#41;;<br />            fld &#91;esi&#93;.Vec3.Z<br />            fmul &#91;edi&#93;.Vec3.X<br />            fld &#91;esi&#93;.Vec3.X<br />            fmul &#91;edi&#93;.Vec3.Z<br />            fsub<br />            fstp &#91;ecx&#93;.Vec3.Y<br />              <br />; The Z value for the vector is&#58;  &#40;V1.x * V2.y&#41; - &#40;V1.y * V2.x&#41;<br />; vNormal.z = &#40;&#40;vVector1.x * vVector2.y&#41; - &#40;vVector1.y * vVector2.x&#41;&#41;;<br />            fld &#91;esi&#93;.Vec3.X<br />            fmul &#91;edi&#93;.Vec3.Y<br />            fld &#91;esi&#93;.Vec3.Y<br />            fmul &#91;edi&#93;.Vec3.X<br />            fsub<br />            fstp &#91;ecx&#93;.Vec3.Z<br /> ret <br />Vec3Cross endp<br /><br />; This returns a normalize vector &#40;A vector exactly of length 1&#41;<br />Vec3Normalize proc uses esi pNormal<br />local fmag<br />        invoke Vec3Magnitude,pNormal            ; Get the magnitude of our normal<br />        fstp fmag<br /><br />; Now that we have the magnitude, we can divide our normal by that magnitude.<br />; That will make our normal a total length of 1.  This makes it easier to work with too.<br />        mov esi,pNormal<br />        fld &#91;esi&#93;.Vec3.X<br />        fdiv fmag<br />        fstp &#91;esi&#93;.Vec3.X<br />        fld &#91;esi&#93;.Vec3.Y<br />        fdiv fmag<br />        fstp &#91;esi&#93;.Vec3.Y<br />        fld &#91;esi&#93;.Vec3.Z<br />        fdiv fmag<br />        fstp &#91;esi&#93;.Vec3.Z<br />        ret<br />Vec3Normalize endp<br /><br /></code></pre></div>
    <div class="meta">Posted on 2005-03-03 23:53:31 by Homer</div>
   </div>
   <div class="post" id="post-157686">
    <div class="subject"><a href="#post-157686">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body"><div class="quote">Daydreamer - <br />Using the method I just described, the drag is dependant on the velocity - the faster you travel, the more drag you experience. Simple is good.</div><br />in cameraexample which is emulating drag in your eyemuscles and slow speeds<br />in example above with gravity speed=9.82^2 you can reach highspeeds vs as you describe it as linear drag increase approximation, while realworld air drag balances this falling with exponential increase<br />meaning parachutes wont work correctly, you get big craters from low altitudes of falling objects<br />and your ferrari is suddenly capable of 400mph instead of 200mph<br />planes get ridicoulous speeds</div>
    <div class="meta">Posted on 2005-03-04 04:07:20 by daydreamer</div>
   </div>
   <div class="post" id="post-157688">
    <div class="subject"><a href="#post-157688">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">You probably missed the point - the drag coefficient has nothing to do with how velocity is attained - it just slows things down.<br />It's just a value somewhat less than 1 ( ie 0.8 ) which we use to reduce the speed of stuff (we multiply velocity by coefficient).<br />So if coefficient is 1.0, speed is unchanged.<br />If coefficient is 0, speed is zero.<br />If coefficient is something less than 1 and greater than 0, speed is reduced.<br />The faster something is travelling, the faster its speed will be reduced, simply because the numbers are bigger. This is a ratio thing.<br />I never desribed linearity.<br />Velocity is altered at each timestep by acceleration (summed forces).<br />Therefore velocity is not linear.<br /><br />Actually, later, we'll apply two more such coefficients, called KR and KF.<br />KR is the &quot;coefficient of restitution&quot; which determines how &quot;bouncy&quot; a surface is. 1.0 means very bouncy (no loss), and 0.0 makes things get stuck on contact (vertical).<br />KF is the &quot;coefficient of friction&quot; and in all the examples I've seen, for some reason or other, it works in reverse, such that 1.0 makes things stick, and 0.0 lets things slide freely (horizontal).</div>
    <div class="meta">Posted on 2005-03-04 05:54:01 by Homer</div>
   </div>
   <div class="post" id="post-157690">
    <div class="subject"><a href="#post-157690">Simulated Physics - Dynamic and Static Forces</a></div>
    <div class="body">Rethinking the problem of finding the intersection of a sphere and a plane, I think it might end up faster all said and done to use a slightly different algorithm anyway.<br />I'm still miffed that I haven't got a reasonable answer as to why the code shown isn't right, but nonetheless:<br /><br />There's an algorithm for finding the intersection of a plane and a ray.<br />A ray is two points in 3D space.<br />All the fancy algorithms I've looked at are ways of splitting time up imho.<br />All said and done, they test two points and a plane.<br />If theres an intersection, they go on to find the intersection point.<br />This algorithm finds the intersection point immediately:<br /><br />From NeHe:<br /><div class="quote"><br />t= (Xn dot (PointOnPLANE - Raystart)) / (Xn dot Raydirection) <br /><br />t represents the distance from the start until the intersection point along the direction of the ray. Therefore substituting t into the ray equation we can get the collision point. There are a few special cases though. If Xn dot Raydirection = 0 then these two vectors are perpendicular (ray runs parallel to plane) and there will be no collision. If t is negative the collision takes place behind the starting point of the ray along the opposite direction and again there is no intersection. <br /></div><br /><br />( don't sue please, we're learning stuff :) )<br />and the following C code:<br /><br /><div class="quote"><br />int TestIntersionPlane(const Plane&amp; plane,const TVector&amp; position,const TVector&amp; direction, double&amp; lamda, TVector&amp; pNormal)<br />{<br />	double DotProduct=direction.dot(plane._Normal);			// Dot Product Between Plane Normal And Ray Direction<br />	double l2;<br /><br />	// Determine If Ray Parallel To Plane<br />	if ((DotProduct&lt;ZERO)&amp;&amp;(DotProduct&gt;-ZERO))<br />		return 0;<br /><br />	l2=(plane._Normal.dot(plane._Position-position))/DotProduct;	// Find Distance To Collision Point<br /><br />	if (l2&lt;-ZERO)							// Test If Collision Behind Start<br />		return 0;<br /><br />	pNormal=plane._Normal;<br />	lamda=l2;<br />	return 1;<br />}<br /></div><br /><br />We have to forgive the error due to our linear solution of a nonlinear problem, but here goes:<br /><br />Our ray consists of the position of the sphere object's origin (extended by radius after time, see below), and the origin as it would be in the next timestep (ie, if influenced by summed forces, gravity, velocity, etc, in the next frame), and then extended by the length of the radius. This is so we are testing the point Tangent on the sphere at two moments, not its origin, which saves us some conditional logic work later, and prevents &quot;cross frame error&quot;.<br /><br />If the ray between those points intersects the plane, we have more work.<br />If not, we have nothing to worry about in the current frame.<br /><br />More Work:<br />We have found an intersection point.<br />It indicates the point Tangent to the Sphere, ie, on its Boundary, due to we bothered to add the Radius into consideration already.<br />We now need to subtract the Radius back out.<br />I know this seems messy, but it beats all the conditional logic and cross-frame errors that can otherwise occur if we do it the traditional way.<br />So we have this tangent point, we know the vector that the sphere was moving in, all we need to do is reverse that vector, then scale it by enough (move the sphere back along the ray enough) to bring the sphere origin to &quot;its radius&quot; distance from the plane.<br />That all sounds a bit complex too, but it's really not.<br /><br />I'll see if I can make some more crap art.</div>
    <div class="meta">Posted on 2005-03-04 07:05:06 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=20680&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=20680&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="20680" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=20680&amp;page=2">&gt;</a><a href="../?id=20680&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>