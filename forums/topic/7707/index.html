<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>FramedAnimatedSkinnedMeshes - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=7707" />
    <link rel="next" href="../?id=7707&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=7707">FramedAnimatedSkinnedMeshes</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=7707&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=7707&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="7707" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=7707&amp;page=2">&gt;</a><a href="../?id=7707&amp;page=2">&raquo;</a></form>   <div class="post" id="post-55991">
    <div class="subject"><a href="#post-55991">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">Heya all.<br />Thought I'd start a new thread to post my current work in progress,<br />which involves translating parts of the m$ SkinnedMeshes example.<br />It should marry neatly with Scronty's work on the FrameHierarchy loader and our joint work with the LinkedList (LL) include.<br />My work involves translating the structures and support-code for Framed  skinned animated mesh objects. <br /><br />I am going to post the structures in logical order, not the order they should be defined in (the reverse order), beginning with the highest order structure that I have encountered in this translation at this moment, which is<br />the AnimatedMesh object.<br /><br />;top layer, encapsulates everything to know about loading and drawing a mesh<br />AnimatedMesh STRUCT<br />    LO		         LINKEDOBJECT &lt;&gt;<br />    m_pmcSelectedMesh LPMESHCONTAINER ?<br />    m_pframeSelected        LPMESHFRAME ?<br />    m_pdeSelected             LPDRAWELEMENT ?<br />    m_pdeHead                  LPDRAWELEMENT ?<br />    m_ptcTextureCacheHead LPTEXTURECACHE ?  ;Root of TextureCache (shared)<br />    m_method                    DWORD ?<br />    m_dwFVF                      DWORD ?<br />    m_fRadius                     FLOAT ?<br />    m_Center                      D3DXVECTOR3 &lt;&gt;<br />    m_pEnvironmentMap    LPDIRECT3DCUBETEXTURE8 ?<br />    m_pfxEffect                   LPD3DXEFFECT ?<br />AnimatedMesh ENDS<br /><br />LO is our LinkedObject Header. It represents support for LL and naming of objects. Expect to see a lot more of it :)<br />You can compare this to the manim.h file from the SkinnedMeshes example.<br />I've translated all the required structs and supprt code already, but I think they could still be cleaned up, and I'm open to suggestions.<br />I will spread out the postings however.<br />Next will be the MeshFrame structure, ex SFrame.<br /><br />cya.</div>
    <div class="meta">Posted on 2002-09-04 03:44:30 by Homer</div>
   </div>
   <div class="post" id="post-56201">
    <div class="subject"><a href="#post-56201">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">The next instalment, as promised :)<br />This is the container structure for an animated skinned mesh object or list, MeshContainer, as used by the previous MeshFrame, which was the structure for a Frame containing an animated skinned mesh object or list.<br />There's also some functions supporting the MeshContainer object.<br />The support code is a quick rip and needs correction based on implementation.<br /><br />Next time we'll do the DrawElement structure, and we'll follow up with the support structs for animated skinned mesh objects.<br />Finally, we'll put it all together with cleaned up support code.<br />cya.<br /><br /><br />;Helper macro (Should be added to LinkedList include)<br />      LLRELEASE MACRO mStruct<br />          invoke KillEntryPlusChildren,mStruct<br />      ENDM<br /><br />;METHODS<br />NONE                         equ 0<br />D3DNONINDEXED equ 1<br />D3DINDEXED          equ 2<br />SOFTWARE              equ 4<br />D3DINDEXEDVS     equ 8<br /><br />;---------------------------------------------------------------------------------------------------<br />;skinned mesh container, used by MeshFrame for animatedmesh :)<br />MeshContainer STRUCT<br />    LO                         LINKEDOBJECT &lt;&gt;<br />    pMesh                  LPD3DXMESH ?<br />    pMeshHW           LPD3DXMESH ?<br />    pMeshSW           LPD3DXMESH ?<br />    rgMaterials         LPD3DMATERIAL8 ?<br />    pTextures           LPDIRECT3DTEXTURE8 ?<br />    pEnvironments LPDIRECT3DCUBETEXTURE8 ?<br />    cpattr                   DWORD ?<br />    cMaterials           DWORD ?<br />    iAttrSplit              DWORD ?<br />;    pmcNext             LPMESHCONTAINER ? ;Redundant - use LO header field<br />;    char *szName                                   ; Redundant - use LO header field  <br />    rgdwAdjacency            DWORD ?<br />    rgdwAdjacencyTemp DWORD ?<br /><br />;    // Skin info<br />    m_pSkinMesh LPD3DXSKINMESH ?<br />    m_pAttrTable  LPD3DXATTRIBUTERANGE ?<br />    m_pBoneMatrix ptr LPD3DXMATRIX<br />    m_pBoneNamesBuf LPD3DXBUFFER ?<br />    m_pBoneOffsetBuf LPD3DXBUFFER ?<br />    m_pBoneOffsetMat LPD3DXMATRIX ?<br />    m_numBoneComb DWORD ?<br />    m_maxFaceInfl DWORD ?<br />    m_pBoneCombinationBuf LPD3DXBUFFER ?<br />    m_Method DWORD ?<br />MeshContainer ENDS<br />;------------------------------------------------------------------------------------<br /><br />InitMeshContainer PROC lpThis:DWORD<br />    push esi<br />    mov esi,lpThis<br />    mov .MeshContainter.pMesh,NULL<br />    mov .MeshContainter. pMeshHW,NULL<br />    mov .MeshContainter.pMeshSW,NULL<br />    mov .MeshContainter.rgMaterials,NULL<br />    mov .MeshContainter.pTextures,NULL<br />    mov .MeshContainter.cpattr,0<br />    mov .MeshContainter.iAttrSplit,0<br />    mov .MeshContainter.cMaterials,0<br />    mov .MeshContainter.pmcNext,NULL<br />    mov .MeshContainter.m_pSkinMesh,NULL<br />    mov .MeshContainter.m_pAttrTable,NULL<br />    mov .MeshContainter.m_pBoneMatrix,NULL<br />    mov .MeshContainter.m_pBoneNamesBuf,NULL<br />    mov .MeshContainter.m_pBoneOffsetBuf,NULL<br />    mov .MeshContainter.m_pBoneOffsetMat,NULL<br />    mov .MeshContainter.rgdwAdjacency,NULL<br />    mov .MeshContainter.rgdwAdjacencyTemp,NULL<br />    mov .MeshContainter.m_numBoneComb,0<br />    mov .MeshContainter.m_maxFaceInfl,0<br />    mov .MeshContainter.m_pBoneCombinationBuf,NULL<br />    mov .MeshContainter.m_Method,NONE<br />    mov eax,esi<br />    pop esi<br />    ret<br />InitMeshContainer ENDP	<br /><br />NewMeshContainer PROC lpParent:DWORD<br />            push esi<br />            mov esi,lpParent<br />            invoke AddChildEntry,esi,sizeof MeshContainer<br />            push eax<br />            .if eax!=NULL<br />                invoke InitMeshContainer,eax<br />            .endif<br />            pop eax<br />            pop esi<br />            ret<br />NewMeshContainer ENDP<br /><br />    DestroyMeshContainer PROC lpThis:DWORD <br />        push esi<br />        mov esi,lpThis<br />        LLRELEASE .MeshContainer.rgMaterials<br />        mov  .MeshContainer.rgMaterials,0<br /><br />        .if  .MeshContainer.pTextures != NULL        <br />;            for (DWORD i = 0; i &lt; cMaterials; ++i)     <br />             xor ecx,ecx<br />             .while ecx &lt; .MeshContainer.cMaterials<br />                push ecx<br />                shl ecx,2       ;x4 for dword sized array elements<br />                LLRELEASE  .MeshContainer.pTextures<br />                LLRELEASE  .MeshContainer.pEnvironments<br />                pop ecx<br />                inc ecx<br />            .endw<br />            LLRELEASE  .MeshContainer.pTextures<br />        .endif<br /><br />        .if  .MeshContainer.pMesh != NULL        <br />            mcall ,IDirect3D8_Release<br />            .if eax != NULL<br />                int 3<br />            .endif<br />        .endif<br /><br />        LLRELEASE .MeshContainer.pMeshHW<br />        LLRELEASE .MeshContainer.pMeshSW<br />        LLRELEASE .MeshContainer.m_pSkinMesh<br />        LLRELEASE .MeshContainer.m_pBoneNamesBuf<br />        LLRELEASE .MeshContainer.m_pBoneOffsetBuf<br />        LLRELEASE .MeshContainer.m_pBoneCombinationBuf<br />        LLRELEASE .MeshContainer.m_pBoneMatrix;<br />        LLRELEASE .MeshContainer.m_pAttrTable<br />        LLRELEASE .MeshContainer.rgdwAdjacency<br />        LLRELEASE .MeshContainer.rgdwAdjacencyTemp<br />        LLRELEASE .MeshContainer.pmcNext<br />        mov eax,esi<br />        pop esi<br />        ret        <br />   DestroyMeshContainer ENDP</div>
    <div class="meta">Posted on 2002-09-05 07:19:38 by Homer</div>
   </div>
   <div class="post" id="post-56206">
    <div class="subject"><a href="#post-56206">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">Weird, the MeshFrame post went astray.<br />Nevermind, here it is.<br />The MeshFrame object is a special type of container object. This object is a Frame of Reference container for an animated skinned mesh object.<br />It's &quot;a Frame !!&quot; YAY :)<br />You'll get support for it soon k :)<br /><br />;SkinnedAnimatedMeshFrameLL container-object modified from m$ example SFrame object :D<br />MeshFrame STRUCT<br />    LO LINKEDOBJECT &lt;&gt;                          ;Standard LL object header - contains nameptr,linkptrs etc<br />    pmcMesh LPMESHCONTAINER ?<br />    matRot            D3DXMATRIX &lt;&gt;<br />    matTrans        D3DXMATRIX &lt;&gt;<br />    matRotOrig     D3DXMATRIX &lt;&gt;<br />    matCombined D3DXMATRIX &lt;&gt;<br />    m_iLastKey     DWORD          ?<br />;    // animation information<br />    m_pPositionKeys LPPOSITIONKEY ?<br />    m_cPositionKeys DWORD ?<br />    m_pRotateKeys    LPROTATEKEY ?<br /><br />    m_cRotateKeys    DWORD ?<br />    m_pScaleKeys      LPSCALEKEY ?<br />    m_cScaleKeys      DWORD ?<br />    m_pMatrixKeys     LPMATRIXKEY ?<br />    m_cMatrixKeys     DWORD ?<br />    pframeAnimNext   DWORD ?         ;LPMFRAME<br />    pframeToAnimate DWORD ?         ;LPMFRAME<br />;    pframeSibling      DWORD ?    ;Redundant - use LinkedObject header field<br /><br />    pframeFirstChild   DWORD ?      ;Object keeps pointer to its Oldest Child<br />    bAnimationFrame DWORD ?             ;Boolean flag<br />;  szText                                                       ;Redundant - use LO header field<br />MeshFrame ENDS<br />typedef LPMESHFRAME:ptr MeshFrame</div>
    <div class="meta">Posted on 2002-09-05 07:30:13 by Homer</div>
   </div>
   <div class="post" id="post-56329">
    <div class="subject"><a href="#post-56329">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">Heya All.<br />Here's the next exciting episode, the DrawElement structure.<br />Included are the quick-rip support functions.<br />Wonder if anyone really cares about this stuff.<br />Back soon with the support structures and then we can look at some code.<br />cya.<br /><br />;skinned draw element<br />DrawElementLL STRUCT<br />    LO LINKEDOBJECT &lt;&gt;<br />    pframeRoot LPMESHFRAME ?<br />    vCenter D3DXVECTOR3 ?<br />    fRadius FLOAT ?<br />;   animation list<br />    pframeAnimHead LPMESHFRAME ?<br />    fCurTime FLOAT ?<br />    fMaxTime FLOAT ?<br />DrawElementLL ENDS<br />typedef LPDRAWELEMENT:ptr DrawElementLL<br /><br />CreateDrawElementLL PROC lpParent:DWORD<br />      push esi<br />      invoke AddChildEntry,lpParent,sizeof DrawElementLL<br />      mov esi,eax<br />      .if esi!=NULL<br />          mov .DrawElementLL.vCenter.x,NULL<br />          mov .DrawElementLL.vCenter.y,NULL<br />          mov .DrawElementLL.vCenter.z,NULL<br />          fld1<br />          fstp  .DrawElementLL.fRadius<br />          mov .DrawElementLL.pframeRoot,NULL<br />          mov .DrawElementLL. pframeAnimHead,NULL<br />          mov eax,esi<br />      .endif<br />      pop esi<br />      ret<br />CreateDrawElementLL ENDP<br /><br />DestroyDrawElementLL	lpThis:DWORD<br />        LLRELEASE lpThis<br />        ret<br />DestroyDrawElementLL ENDP</div>
    <div class="meta">Posted on 2002-09-06 04:09:39 by Homer</div>
   </div>
   <div class="post" id="post-56464">
    <div class="subject"><a href="#post-56464">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">Messy Is as Messy Does :tongue: <br /><br />Attatched is my Animated Mesh incomplete rip as it stands.<br />I'll post updates on this as I go.<br /><br />What it covers:<br />-Loading and parsing of animated skinned meshes within a Frames hierarchy into a single LL structure.<br />-Loading Textures, Meshes, Bone data, Animation data and more.<br />-Dynamic FVF through a dynamic file (anti fvf-cracker whatever that may be ;))<br />-Lots of support functions and structures like a container object for animated mesh objects, the Frame container for framing amesh containers, support code for killing of parts of the LL database selectively, lots of goodies.<br />-Code for Rending, code for Animating, Blah Blah and Blah. Just TOO much.<br /><br />Current issues: <br />-incorrect encapsulation of some lower functions.<br />-I need to see some fpcomp conditional example code.<br /><br />This already represents over 20 hours of work. It's actually beginning to look useful. I know that a lot of people would like to see this completed.<br />Now, lets have some feedback, pretty please?</div>
    <div class="meta">Posted on 2002-09-07 02:44:42 by Homer</div>
   </div>
   <div class="post" id="post-56695">
    <div class="subject"><a href="#post-56695">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">Wow, I thought I'd have some kind of response to this thread.<br />Keeping my chin up :)</div>
    <div class="meta">Posted on 2002-09-08 17:59:52 by Homer</div>
   </div>
   <div class="post" id="post-56716">
    <div class="subject"><a href="#post-56716">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">Afternoon, EvilHomer2k.<br /><br />Thought I'd let ya know that you're not alone:grin: .<br /><br />I've been (and still am) busy finishing off the Tsunami demo, so I've only had a quick look at the files you're producing.<br /><br />Might be wise to produce a .chm file to help us get an idea of how everything is glued together. It could also evolve into a tut on how to use the linkedlist and skinnedmeshes. I'll start on one in a few days when I have time again:grin: .<br /><br />Cheers,<br />Scronty</div>
    <div class="meta">Posted on 2002-09-09 00:51:16 by Scronty</div>
   </div>
   <div class="post" id="post-56728">
    <div class="subject"><a href="#post-56728">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">I agree, a tute is definitely in need for this one.<br />My structs aren't as god awful as they appear.<br />I've ripped m$'s demo objects almost faithfully, with the inclusion of a LinkedObject Header at every level of the object structure...<br />Almost all of the code is a pure rip of the Shader Wokshop and SkinnedMesh example. The update attatched should help clear things up a lot.<br />I've been commenting the code and altering the implementation for N animated meshes.<br /><br />One of the nicest things I gained from this already was confirmation that D3D does not treat texture objects as COM objects, ie, does not reference them.<br />It simply instances duplicates which is just tragic.<br />Included is m$'s variation on texture cache, ripped and modified to use a LinkedList also.<br />I've gone to town with the LinkedObject header, but in practise its very simple to use, lots more application-specific code has been translated now.<br />The source will be full of bugs I'm sure, however its progressing nicely, in fact it's almost there now.</div>
    <div class="meta">Posted on 2002-09-09 03:44:35 by Homer</div>
   </div>
   <div class="post" id="post-56819">
    <div class="subject"><a href="#post-56819">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">Heya ..<br />Another day, another update :)<br /><br />This is really looking good now, really coming together nicely.<br />The best part is that I have totally removed the COM encapsulation, without losing the hierarchicality of the support functions.<br />Ugly Ugly OOP - yuk - HLA all the way :)<br />We'll look after our own indirection, tyvm - we're asmcoders !!<br />(has a machinecode background - does it show?:p)</div>
    <div class="meta">Posted on 2002-09-09 12:49:39 by Homer</div>
   </div>
   <div class="post" id="post-57459">
    <div class="subject"><a href="#post-57459">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">Yet Another Update.<br />Been busy keeping myself up to date in other areas..so this update is not much, just better organized (preparing to put a Loader together), and have begun a CHM helpfile which I've included<br />.<br />Corrected encapsulation of some lower functions etc.<br />Corrected spurious Interface identifiers.<br />Added more comments.<br /><br />ToDo:<br />- repair the evironmental texture function that m$ left broken in there.<br />- begin adding info to the chm regarding AMeshes, AFrames etc etc</div>
    <div class="meta">Posted on 2002-09-13 00:34:26 by Homer</div>
   </div>
   <div class="post" id="post-57640">
    <div class="subject"><a href="#post-57640">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">A more complete Helper CHM File.<br />Still just a beginning, but that's where you start, right? :alright:</div>
    <div class="meta">Posted on 2002-09-13 22:58:50 by Homer</div>
   </div>
   <div class="post" id="post-57793">
    <div class="subject"><a href="#post-57793">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">La de da :)<br /><br />This update we begin the Loader.<br />Much debugging has been done.<br />Currently having fun fixing compiler errors , so yes, it's getting close :alright:</div>
    <div class="meta">Posted on 2002-09-14 13:34:43 by Homer</div>
   </div>
   <div class="post" id="post-57993">
    <div class="subject"><a href="#post-57993">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">I'd like to begin describing the structures and their use.<br />In order for those who do not fully grasp the concept of hierarchical framework or the power it affords us, I will begin simply, with the global shared texture cache.<br /><br />The cache is comprised of a LinkedList of &quot;TextureCache&quot; objects.We keep a pointer to the root object in an application variable.<br />You can think of the TextureCache LinkedList as a line of boxes joined end to end, if that helps.<br /><br />The TextureCache object looks like this:<br />;-------------------------------------------------<br />;LinkedList TextureCache object<br />;-------------------------------------------------<br />TextureCache STRUCT<br />LO LinkedObject &lt;&gt;<br />pTexture LPDIRECT3DBASETEXTURE8 ?<br />Count DWORD ?<br />TextureCache ENDS<br />;-------------------------------------------------<br />LPTEXTURECACHE typedef ptr TextureCache<br />;-------------------------------------------------<br /><br />The TextureCache LinkedList represents an array of loaded textures.The LinkedObject header is used to store the texture filename.The Parent/Child links are employed by the TextureCache, the sibling links are not used.<br /><br />When something needs to load a texture, we first query the TextureCache.<br />If the texture is already loaded, we just return pTexture.<br />If the texture is not loaded, we create a new TextureCache object and chain it.<br />Either way. we increment Count.<br />When textures are unloaded by redundant objects, we decrement Count. Should a TextureCache object's Count reach zero, that texture is no longer required and the object can be Killed (links will be patched for us).<br /><br />Now here is the entry-level code for a LoadTexture procedure which does this.<br /><br />LoadTexture PROC lpszFilename:DWORD, ppTexture:LPDIRECT3DTEXTURE8,lpDevice:LPDIRECT3DDEVICE8 <br />    LOCAL hr:DWORD<br />    LOCAL ptcCur:LPTEXTURECACHE<br />    LOCAL pLast:LPTEXTURECACHE<br />    LOCAL cchFilename:DWORD<br />;-----------------Filename is required-------------------<br />    .if lpszName==NULL<br />        return S_OK<br />    .endif<br />;-----------------first search the loaded textures--------------------<br />    m2m ptcCur , ptcTextureCacheHead                ;Fetch Root of TextureCache<br />    .while ptcCur != NULL<br />        .if .LinkedObject.pName !=NULL    <br />            invoke lstrcmp,.LinkedObject.pName, lpszFilename<br />            .if eax == 0                                                            ;!! found !! just return that texture<br />                lea eax, .TextureCache.pTexture         ;Fetch object pointer<br />                mov  , eax                                       ;Shove value in holder provided<br />                .if eax != NULL                                                  ;Ensuring we have a pTexture<br />                    inc .TextureCache.Count                  ;Increment its reference counter<br />                    jmp e_Exit                                                    ;yay we done!!<br />                .endif<br />            .endif                                                                    ;else if texturename did not match<br />        .endif <br />        m2m pLast,ptcCur                                                    ;Keep last known objectpointer<br />        m2m ptcCur , .LinkedObject.pChild             ;Search children<br />    .endw<br /><br />;---------------if not found, load the texture and add an entry to the cache----------------<br />            invoke CreateTextureCache,pLast,lpszFilename<br />            mov ptcCur,eax	;ptcCur = new TextureCache<br />	.if eax == NULL	<br />		mov hr , E_OUTOFMEMORY<br />		jmp  e_Exit<br />	.endif<br />;---------------------------------------------Load the Texture object------------------------------------------<br />	invoke D3DXCreateTextureFromFile,lpDevice, lpszFilename, addr .TextureCache.pTexture<br />            mov hr,eax<br />	.if eax==FAILED    <br />                 mov hr , FAILED<br />	     mov .TextureCache.pTexture , NULL<br />                 jmp e_Exit<br />            .endif    <br /><br />;---------------------------------------Return interface object pointer and add Reference---------------------------------<br />            mov eax, .TextureCache.pTexture<br />	mov ,eax<br />            .if eax != NULL<br />	       inc .TextureCache.Count<br />            .endif<br /><br />e_Exit:<br />	return hr<br />LoadTexture ENDP<br /><br /><br /><br />Also here's a  CreateTextureCache procedure as used by the above code to create a new TextureCache linked to the last object in the cache linkedlist.<br />;----------------------------<br />;The following function creates a new TextureCache for an animatedmesh,<br />;and sets the filename in the new object.<br />;This code does not actually load the texture.<br />;Input params: lpParent is NULL or pointer to parent.<br />;lpszFileName is a pointer to texture filename.<br />;Returns pointer to new TextureCache object or else NULL means failure.<br /><br />CreateTextureCache PROC lpParent:DWORD,lpszFilename:DWORD<br />      push esi<br />      invoke AddChildEntry,lpParent,sizeof TextureCache<br />      mov esi,eax<br />      .if esi!=NULL &amp;&amp; lpszFilename!=NULL<br />          mov .TextureCache.pTexture,NULL<br />          invoke NewName,esi,lpszFilename<br />          mov eax,esi<br />      .endif<br />      pop esi<br />      ret<br />CreateTextureCache  ENDP<br /><br /><br />And just to tidy up this package here's a procedure to destroy a redundant TC from the cache without creating pandemonium.<br /><br />;Simply  hand this function the address of a redundant texturecache.<br />DestroyTextureCache PROC lpThis:LPTEXTURECACHE                    <br />		invoke KillEntry, lpThis<br />	            ret<br />DestroyTextureCache ENDP<br /><br />That's plenty of code to implement a solid shared texture array.<br />Until next time :alright:</div>
    <div class="meta">Posted on 2002-09-15 17:54:36 by Homer</div>
   </div>
   <div class="post" id="post-58038">
    <div class="subject"><a href="#post-58038">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">Thought for the day:<br /><br />The Animated Skinned Mesh object is a type of hierarchy similar to a scene hierarchy. Loading one from an xfile is also similar to loading a scene hierarchy.<br />In order to do that we'll be doing the following:<br /><br />We'll be using functions from the IDirectXFile interface. First we'll use IDirectXFile_CreateEnumObject to access a specific xfile. This returns a &quot;IDirectXFileEnumObject&quot; interface pointer.  Using the  IDirectXFileEnumObject_GetNextDataObject function we scan all the &quot;toplevel templates&quot; in the xfile scene hierarchy. This returns a &quot;IDirectXFileData&quot; interface pointer. Using functions like IDirectXFileData_GetID and IDirectXFileData_GetName we can query the hierarchy of a toplevel template object further.<br /><br />Thus the premise of loading a skinned mesh object is no different to loading any other scene hierarchy.</div>
    <div class="meta">Posted on 2002-09-16 00:38:45 by Homer</div>
   </div>
   <div class="post" id="post-59057">
    <div class="subject"><a href="#post-59057">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">Hi EvilHomer2k<br /><br />I've just been looking at your linked list code and was wondering why you call GlobalLock when<br />allocating memory as GlobalAlloc returns a ptr when using GPTR.<br /><br />The SDK docs also recommend using the HeapAlloc/Free functions, but you already know that. ;)<br /><br />Please correct me if I'm wrong and keep up the great work!<br /><br />EDIT: I've just read your homerhelp file and the more? link on the Animated Skinned Meshes ( structure ) page doesn't work - no donuts for you :eek:<br /><br />:alright:<br />Maestrom</div>
    <div class="meta">Posted on 2002-09-21 19:15:30 by Maelstrom</div>
   </div>
   <div class="post" id="post-59649">
    <div class="subject"><a href="#post-59649">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">ok here it is, I used to think the way you do as well :)<br /><br />GlobalAlloc calls HeapAlloc internally, so that's irrelevant. the important thing is that it returns not a memory pointer but a memory object handle, which we are meant to hand to GlobalLock so that we can get our hands on the actual memory pointer itself.<br />GlobalLock marks the memory chunk within the os memory manager in such a way that it is to be considered part of the application's virtual memory space, and any attempt to write to this memory made from a thread not associated with the application process will result in a particular memory access violation which is trappable by the application itself.<br /><br />Simply calling HeapAlloc will allocate memory within the application's Heap memory space, which although virtual, is finite and is defined in the PE Header of the executable. This memory is guaranteed to be Owned by the application process and its children, but its finite, and this means that theres just so much to go around.<br /><br />I assume that GlobalAlloc uses HeapAlloc internally because it stores information pertaining to the memory object it allocated on the Heap, and the handle reurned by GlobalAlloc is probably a pointer to that data on the Heap, but I don't know that for sure. What I do know is that HeapAlloc is dandy for light duties, but not up to the task of massive databasing on its own.</div>
    <div class="meta">Posted on 2002-09-26 08:47:08 by Homer</div>
   </div>
   <div class="post" id="post-59653">
    <div class="subject"><a href="#post-59653">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">ahh I better qualify those remarks ..<br />GPTR simply combines the GMEM_FIXED and GMEM_ZEROINIT flags.<br /><br />The win32 api says this...&quot;The GlobalAlloc function allocates the specified number of bytes from the heap. In the linear Win32 API environment, there is no difference between the local heap and the global heap.&quot;<br /><br />But it also says &quot;The HeapAlloc function allocates a block of memory from a heap. The allocated memory is not movable.&quot;<br /><br />And yet we know that we CAN request movable memory using GlobalAlloc.<br />How can this be if it is calling HeapAlloc?<br />The answer I believe is that when we allocate memory using GlobalAlloc, tha it allocates it not within the heap's memory space, but outside it, and stores a pointer to it on the heap, thus growing the heap.<br />To be honest I have never traced the api functions to find out, but that would explain the need for ever Locking memory owned by the process, and also why GlobalAlloc doesn't actually ever return a flat memory address.</div>
    <div class="meta">Posted on 2002-09-26 09:05:18 by Homer</div>
   </div>
   <div class="post" id="post-59706">
    <div class="subject"><a href="#post-59706">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">:confused:<br /><br />Win32 api GlobalLock ( under remarks )<br /><br /><em>Memory objects allocated with GMEM_FIXED always have a lock count of zero. For these objects, the value of the returned pointer is equal to the value of the specified handle.</em><br /><br />Wouldn't that mean the value returned by GlobalLock would be the same as the value returned by GlobalAlloc when using GMEM_FIXED or GPTR?<br />Sorry for the continued pestering but I feel memory management is an important area to understand properly, but if you're correct, the Win32 api is more than a little misleading.<br /><br />Also I noticed you generally move memory into EAX before moving it into another register, any particlar reason for this?<br /><br />:grin:<br />Maelstrom</div>
    <div class="meta">Posted on 2002-09-26 20:00:09 by Maelstrom</div>
   </div>
   <div class="post" id="post-60705">
    <div class="subject"><a href="#post-60705">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">You are correct about the returned values from GlobalAlloc and GlobalLock when using FIXED memory request. Do not assume from this that GlobalLock performs no function !! <br />We do use EAX extensively in the LinkedList sourcecode as an intermediate. There is no reason for this, the code has been deliberately written to be clear to the reader. It is not optimized. The compiler does a fairly good job of cleaning up this code, but really it should be hand-optimized. I will hand-optimize and release a more complete version of this source in the near future.<br />I have spent the last couple of weeks teaching myself CGI animation and learning the fine aspects of modelling/animating under Maya 4, having learned that the Tiny.x model used by m$ in their AniMesh example was actually made in Maya.<br />I wasn't prepared to finish writing the AniMesh Loader until I had seen a lot more realworld examples, and it's a good thing I did, because in GameDev we've advanced from the simple AniMesh to something called &quot;weight-blended nonlinear keyframed sequences&quot; in which more than one range of nonlinear keyframes is blended, for example blending a walk animation with a scratching of the head (left arm) and pointing toward a target (right arm). The three animations here are three sections of the one set of keyframes, blended together with one of them being bound to Time (the walk animation) and the extra animations being bound to it (thus Timing of animations 2 and 3 is blended from the start and end frame information). I guess I'll be reworking the AniMesh object just a little to incorporate the weighting factor(s), although they already support multiple animated sequences, I wasn't figuring on Blending them at that level.</div>
    <div class="meta">Posted on 2002-10-06 05:55:04 by Homer</div>
   </div>
   <div class="post" id="post-60765">
    <div class="subject"><a href="#post-60765">FramedAnimatedSkinnedMeshes</a></div>
    <div class="body">Damn I love the crystal clear documentation MS provides :rolleyes:<br /><br />Anyway, the animation stuff sounds very cool.<br /><br />I don't know much about this so I apologise in advance if any questions are stupid ;)<br /><br />1. When you say keyframed, do you mean statically defined meshes, or dynamically generated meshes using a skeleton and weighted vertex blending?<br />2. Wouldn't a skeletal solution scale better to the users CPU?<br />3. Will you be using vertex shaders to accomplish the interpolation between animations?<br />4. How do you intend to support full body meshes, one piece, or built from multiple pieces?<br /><br />:alright:<br />Maelstrom</div>
    <div class="meta">Posted on 2002-10-06 20:53:32 by Maelstrom</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=7707&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=7707&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="7707" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=7707&amp;page=2">&gt;</a><a href="../?id=7707&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>