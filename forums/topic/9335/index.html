<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>please help using GetDiskFreeSpaceEx api - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=9335" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=9335">please help using GetDiskFreeSpaceEx api</a></p>
   <div class="post" id="post-68912">
    <div class="subject"><a href="#post-68912">please help using GetDiskFreeSpaceEx api</a></div>
    <div class="body">ok i've got strange result using GetDiskFreeSpaceExA func<br />as it use some qwords as data to be filled<br />i use the proc qwordto2dwords to split qwords into 2 dword (high and low)<br />and use DwordValToAscii to convert them into 2 string (numeric)<br />then cat them into a string that should display a full 64bit number in ascii<br /><br />but it works fine for freeuserbytes (the caller) freebytes but not for totalbytes<br /> i've got a partition of 7,98Go (8570400768 bytes)<br /><br /><br /><br />DwordValToAscii proc,dwValue:DWORD,lpBuffer:dword<br />pusha<br />	<br />    ; -------------------------------------------------------------<br />    ; convert DWORD to ascii string<br />    ; dwValue is value to be converted<br />    ; lpBuffer is the address of the receiving buffer<br />    ; EXAMPLE:<br />    ; invoke dwtoa,edx,ADDR buffer<br />    ;<br />    ; Uses: eax, ecx, edx.<br />    ; -------------------------------------------------------------<br /><br />    mov	eax, dwValue<br />    mov edi, lpbuffer<br /><br />  .if (eax != 0)<br /><br />    ; Is the value negative?<br /><br />    .if	(sdword ptr eax &lt; 0)<br />      mov byte ptr , '-'	; store a minus sign<br />      inc edi<br />      neg eax			; and invert the value<br />    .endif<br /><br />    mov esi, edi		; save pointer to first digit<br /><br />    mov ecx, 10<br />    .while (eax &gt; 0)		; while there is more to convert...<br />      xor edx, edx<br />      div ecx			; put next digit in edx<br />      add dl, '0'		; convert to ASCII<br />      mov , dl		; store it<br />      inc edi<br />    .endw<br /><br />    mov byte ptr , 0	; terminate the string<br /><br />    ; We now have all the digits, but in reverse order.<br /><br />    .while (esi &lt; edi)<br />      dec edi<br />      mov al, <br />      mov ah, <br />      mov , al<br />      mov , ah<br />      inc esi<br />    .endw<br /><br />  .else<br />    mov word ptr , 0030H     ; string &quot;0&quot;, 0 in little endian<br />  .endif<br />popa<br /><br />    ret<br /><br />DwordValToAscii endp<br /><br />QwordTo2Dwords PROC num1:QWORD<br />.data<br />QwordTo2DwordsDD1 dd 0<br />QwordTo2DwordsDD2 dd 0<br />.code<br />pushad<br />pushfd<br />	movq		mm0, num1<br />	movd		eax, mm0<br />	mov QwordTo2DwordsDD1,eax<br />	punpckhdq	mm0, mm0<br />	movd		edx, mm0<br />	mov QwordTo2DwordsDD2,edx<br />popfd<br />popad<br />mov eax,QwordTo2DwordsDD1<br />mov ebx,QwordTo2DwordsDD2<br />ret<br />QwordTo2Dwords ENDP<br /><br />QwordValToAscii proc,val1:qword,dest:dword<br />.data<br />QwordValToAscciDD1 dd 0<br />QwordValToAscciDD2 dd 0<br />QwordValToAscciTempString db 1024 dup(0)<br />QwordValToAsccival1string db 512 dup(0)<br />QwordValToAsccival2string db 512 dup(0)<br />.code<br />pusha<br />call QwordTo2Dwords,val1 <br />mov QwordValToAscciDD1,eax<br />mov QwordValToAscciDD2,ebx<br />call DwordValToAscii,QwordValToAscciDD1,offset QwordValToAsccival1string<br />call DwordValToAscii,QwordValToAscciDD2,offset QwordValToAsccival2string<br />call Scopy,offset QwordValToAsccitempstring,offset QwordValToAsccival1string ;Scopy if equivalent to lstrcopy<br />call scat,offset QwordValToAsccitempstring,offset QwordValToAsccival2string ; scat to lstrcat<br />call scopy,dest,offset QwordValToAsccitempstring<br />popa<br />ret<br />QwordValToAscii endp<br /><br />GetFreeBytesHDD proc,src:dword,freeuserbytes:dword,totalbytes:dword,freebytes:dword<br />pusha<br />call GetDiskFreeSpaceExA,src,freeuserbytes,totalbytes,freebytes<br />popa<br />ret<br />GetFreeBytesHDD endp<br /><br /><br />now my sample code<br />call GetFreeBytesHDD,offset DirName,offset freeuserdq,offset totaldq,offset freebytesdq<br />call QwordValToAscii,freeuserdq,offset freeusertxt<br />call QwordValToAscii,freebytesdq,offset freebytestxt<br />call QwordValToAscii,totaldq,offset totalbytestxt<br />call MessageBoxA,0,offset freeusertxt,offset messtxt,0 ;displayed:48961694561  it is not correct bytes free (no quota)<br />call MessageBoxA,0,offset freebytestxt,offset messtxt,0 ;displayed:48961694561 it is not correct bytes free<br />call MessageBoxA,0,offset totalbytestxt,offset messtxt,0 ;displayed:-195338241 it is not correct<br /><br /><br />so can anyone show me how to implement a correct funtion that get and convert this values into ascii strings<br /><br />thanks</div>
    <div class="meta">Posted on 2002-12-03 21:15:21 by Thor0Asgard</div>
   </div>
  </div>
 </body>
</html>