<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>limit of param number using invoke - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=4275" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=4275">limit of param number using invoke</a></p>
   <div class="post" id="post-29561">
    <div class="subject"><a href="#post-29561">limit of param number using invoke</a></div>
    <div class="body">Subj as it appiears is 32 params.<br />If more - you get message:<br />&quot;Statement is too complex&quot; :)<br />:(<br />Not good for many C like functions.</div>
    <div class="meta">Posted on 2002-03-17 09:23:10 by The Svin</div>
   </div>
   <div class="post" id="post-29564">
    <div class="subject"><a href="#post-29564">limit of param number using invoke</a></div>
    <div class="body">An easy workaround would be, to create a STRUCTure with alle the &gt;32 parameters and just pass the address of the structure to the function. <br /><br />Hope this helps! :alright: <br /><br />bAZiK</div>
    <div class="meta">Posted on 2002-03-17 09:53:54 by bazik</div>
   </div>
   <div class="post" id="post-29565">
    <div class="subject"><a href="#post-29565">PUSH</a></div>
    <div class="body">Hi!<br /><br />Use &quot;PUSH&quot; for all the other params!<br /><br />Push 37<br />Push 36<br />Push 35<br />Push 34<br />Push 33<br />Invoke YeahBabyYeahA,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32<br /><br />Be sure that your stack wont overflow :)</div>
    <div class="meta">Posted on 2002-03-17 10:02:51 by Rennsemmel</div>
   </div>
   <div class="post" id="post-29566">
    <div class="subject"><a href="#post-29566">limit of param number using invoke</a></div>
    <div class="body">Thanx guys for your creative ideas ;)<br />They are quite obvious, you know :)<br />But all sence of invoke in C like procs is to culculate stack<br />correction after all, not just ability to write params in line<br />with comma delimiter.<br />to bAZiK:<br />so what? you passed address of the struct to szMultiCat for example, and what will happened?<br />the function will think that there are for example 42 adresses of strings pushed in the stack while actually there are just one.<br />Forget it :)<br />There are lots of usefull C like function with variable number of<br />params, and 32 is nothing but too little for possible serious task.<br />Invoke inner macros is just not done well.</div>
    <div class="meta">Posted on 2002-03-17 10:17:56 by The Svin</div>
   </div>
   <div class="post" id="post-29571">
    <div class="subject"><a href="#post-29571">limit of param number using invoke</a></div>
    <div class="body"><strong>Svin</strong>, obviously another limitation of MASM - I wasn't aware of this one.  :(   Might want to try rewriting the PROLOGUE/EPILOGUE macros yourself before writing your own assembler. :)</div>
    <div class="meta">Posted on 2002-03-17 11:35:39 by bitRAKE</div>
   </div>
   <div class="post" id="post-29575">
    <div class="subject"><a href="#post-29575">limit of param number using invoke</a></div>
    <div class="body">That's actually quite smart, as a proc that needs you to push &gt; 32 params wouldn't be very practical.  You're better off passing it as a reference to a param structure.</div>
    <div class="meta">Posted on 2002-03-17 11:53:00 by iblis</div>
   </div>
   <div class="post" id="post-29576">
    <div class="subject"><a href="#post-29576">limit of param number using invoke</a></div>
    <div class="body"><strong>iblis</strong>, that doesn't aply to the C calling method - you can write some good code that leaves the parameters on the stack for multiple processing by several PROCs with the same (or less) parameters - this would be efficent in many situations.  I never really liked STDCALL. :)</div>
    <div class="meta">Posted on 2002-03-17 12:02:58 by bitRAKE</div>
   </div>
   <div class="post" id="post-29591">
    <div class="subject"><a href="#post-29591">Re: limit of param number using invoke</a></div>
    <div class="body">To adjust for STDCALL all you'd need to do is readjust the stack pointer when the proc returned, no?  (assuming the called proc didn't destroy the params)<br /><br />BTW I've never seen a program that needed to push &gt; 32 arguments on the stack.  I'd be interested to see one where it is more beneficial to push all 32 args then to just pass it as a struct reference.  Any examples out there?</div>
    <div class="meta">Posted on 2002-03-17 13:26:05 by iblis</div>
   </div>
   <div class="post" id="post-29593">
    <div class="subject"><a href="#post-29593">limit of param number using invoke</a></div>
    <div class="body"><div class="quote"><br />That's actually quite smart, as a proc that needs you to push &gt; 32 params wouldn't be very practical.  You're better off passing it as a reference to a param structure. </div><br /><br />In opposite it is quite stupit and limited.<br />Do you care carefully read post before answering?<br />We are talking of C like functions e.i. functions with variable number of params. <br />What structure you're talking about?<br />For example you need in one line cat 52 strings in one and in another 37. <br />What would you do? Write &quot;personal&quot; structure for every line?<br />You need validate 27 fields in one form and do in another form it with 44 fields, what you do? Write personal proc for each form?<br /><br />People you need start to write some big apps with huge data input output processing. We just talking different languages.</div>
    <div class="meta">Posted on 2002-03-17 13:42:54 by The Svin</div>
   </div>
   <div class="post" id="post-29599">
    <div class="subject"><a href="#post-29599">limit of param number using invoke</a></div>
    <div class="body"><div class="quote"><em>Originally posted by The Svin </em><strong>In opposite it is quite stupit and limited.  Do you care carefully read post before answering?<br />We are talking of C like functions e.i. functions with variable number of params.</div><br /><br />I didn't realize you were speaking of varargs.   &quot;C like functions&quot; is kind of vague and I missed your 2nd post.<br /> <br /><div class="quote"><em>Originally posted by The Svin </em><strong>What structure you're talking about?<br />For example you need in one line cat 52 strings in one and in another 37. <br />What would you do? Write &quot;personal&quot; structure for every line?<br />You need validate 27 fields in one form and do in another form it with 44 fields, what you do? Write personal proc for each form?</div><br /><br /><br />No I'd probably just loop through each field in the form, validating each one as I go.  When I reach an invalid field, or # of iterations = myForm-&gt;numberOfFields, I stop validating.<br /><br />Pseudo-code:<br /><pre><code>bool FORM&#58;&#58;IsValid&#40; void &#41;<br />&#123;<br />	for&#40; int i = 0; i &lt; this-&gt;numberOfFields; i++ &#41;<br />	&#123;<br />		switch&#40; this-&gt;field&#91;i&#93;.type &#41;<br />		&#123;<br />			case EMAIL&#58;<br />				break;<br /><br />			case ALPHAONLY&#58;<br />				break;<br /><br />			case NUMERICONLY&#58;<br />				break;<br /><br />			etc.. etc..<br />		&#125;<br />	&#125;<br />&#125;</code></pre></div>
    <div class="meta">Posted on 2002-03-17 15:42:31 by iblis</div>
   </div>
   <div class="post" id="post-29650">
    <div class="subject"><a href="#post-29650">limit of param number using invoke</a></div>
    <div class="body"><div class="quote"><br /><br /><br />In opposite it is quite stupit and limited.<br />Do you care carefully read post before answering?<br />We are talking of C like functions e.i. functions with variable number of params. <br />What structure you're talking about?<br />For example you need in one line cat 52 strings in one and in another 37. <br />What would you do? Write &quot;personal&quot; structure for every line?<br />You need validate 27 fields in one form and do in another form it with 44 fields, what you do? Write personal proc for each form?<br /><br />People you need start to write some big apps with huge data input output processing. We just talking different languages. </div><br /><br />linked lists? I agree that it's better to push a 'dynamic structure' such as an array, instead of pushing multiple single parameters if the number of parameters required exceeds a certain limit.</div>
    <div class="meta">Posted on 2002-03-17 18:08:09 by Hiroshimator</div>
   </div>
   <div class="post" id="post-29651">
    <div class="subject"><a href="#post-29651">limit of param number using invoke</a></div>
    <div class="body">What do you want? Singly - Singly Circular - Doubly - Doubly Circular? we all have 'em <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=3179&amp;highlight=linked+lists">here</a> :)</div>
    <div class="meta">Posted on 2002-03-17 18:10:48 by stryker</div>
   </div>
   <div class="post" id="post-29656">
    <div class="subject"><a href="#post-29656">limit of param number using invoke</a></div>
    <div class="body">A method also used in WinAPI, is to create a structure where its first member will be the number of valid members. For example, you create a structure of 100 dwords: If you need to pass the addresses of 68 strings, you put 68 in the first member and the called function reads the next 68 pointers. There is no difference in vararg functions, they always get the number of pushed parameters someway.</div>
    <div class="meta">Posted on 2002-03-17 18:34:43 by micmic</div>
   </div>
   <div class="post" id="post-29705">
    <div class="subject"><a href="#post-29705">limit of param number using invoke</a></div>
    <div class="body">to micmic:<br />It's OK when you know num of params in desing time and yet<br />it is not better way, creating additional stack like memory locations when you already have the stack and can do it all there.<br />to all:<br />Everything you preposed is a slappy way out<br />from a problem wich was created not by natural<br />cause but by bad realisation of inner macro in MASM.<br />I'd rather calculate manually stack adjustment than<br />waste a lot more time to create a bigger and slower<br />code using dynamically allocated strucs where it<br />is not appropiate.<br /><br />And don't give me here in asm board C code - it kinda<br />hurts my eyes for numerous reasons:<br />1. C compilers don't have the same problem with<br />stack adjusments and number of params. You can call<br />wsprintf there and don't bother if number of params bigger<br />the 32.<br />2. I use C like convention when it<br />- create faster code<br />- lead to smaller code in project<br />- save my time for typing.<br />All it's clear when you consider LOW LEVEL anvantages<br />and from C code you can not see this LOW LEVEL things<br />3. From the C code the above I can see only preposition to<br />write 10s time a day similar code instead of writing it once<br />and forever.<br /><br />Cause I see that most of people here unfamiliar with huge<br />data prosessing along with writing database enjeens I give<br />some more understandable:<br /><br />Imagine that by nature of your work you need several times<br />a day write code wich cat rapidly located strings in one for<br />output, each time number of those strings is different.<br />Speed is matter. I've been hired as asm programmer to<br />write <br />1. Fast code - so you can not go away with just a solution -<br />you need fast solutions (to make code for example wich<br />currently run 15 secs run 2 secs)<br />2. You need write a lot of code every day and solve a lot<br />of problems so time spent to write code is matter for you too.<br /><br />You'd eventually end up with some proc like szMultiCat or<br />more optimized version of it.<br />It doesn't need any structs, it uses universal place as temp<br />buffer - stack, it frees you from annoing job creating loops<br />each time you need cat strings, and in addition - you need<br />just call it passing params so it saves place for you don't<br />need write code loops each time you need cat some more<br />strings again.<br />Now show me how you do it with struct approach so that<br />it would be easier than that, faster, less code writing consuming,<br />and results in smaller code and easier for programmer to handle<br />code.<br /><br />People, I know I might sound rude, but sometimes especially<br />when it comes to discussion of speed advantages writing<br />in asm the discussion is going to nowhere for simple reason:<br />there are very few progs written in asm that carries huge tasks<br />that needed speed.<br />Except  for games and graphic programmers of course, you don't<br />need to talk them in importance of optimised code, they know it<br />well themselves.<br />But there are 1000s tasks that waits for fast progs.<br />Most of them still made better in command processors then in<br />3d party programms.<br />I can name a lot of those problems (small and big) that or don't solved at all or<br />in current realisations work slow even on current machines.<br />Actually I don't see any noticebale speeding up from user point of view brought with huge advance of hardware. While hardware enjeneers did there work very impressive software developers constantly killing possibility given by hardware with there slappy programming. 99% software developers take this advance of hardware not as appeal to take part in making the world better but as excuse to write worse than even in the past code justifying iit that &quot;hardware is so fast now so there is no need to write carefull code&quot;. From logical point of view it means that in hardware we can see progress and in software - regress and result of those<br />to processes is ZERO. Faster run is only with OLD apps. New ones just spoiled hardware results equally to improvement of it done by hardware developers.<br /><br /><br />Start write usefull progs that carries tasks needed speed.<br />Then we start talking the same language.<br />I saw a little example of such task in algo section - regscan,<br />make it faster and make a way to put output to some more<br />convinient place for user than console.<br />A lot of people will use it and you'd fill taste of problems that<br />need speed.</div>
    <div class="meta">Posted on 2002-03-18 03:39:56 by The Svin</div>
   </div>
   <div class="post" id="post-29708">
    <div class="subject"><a href="#post-29708">limit of param number using invoke</a></div>
    <div class="body">Alex,<br /><br />I don't know if there are limitations on the way you write macros but it may be a way to defeat this limitation. This macro from MASM32 may do the job if there are no other macro limitations. All that you need to do with it is increase the number of parameters it will handle.<br /><pre><code><br />; ------------------------------------------------------------------<br />; macro for making STDCALL procedure and API calls.<br />; ------------------------------------------------------------------<br /><br />Scall MACRO name&#58;REQ,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12, \<br />                     p13,p14,p15,p16,p17,p18,p19,p20,p21,p22<br /><br />    ;; ---------------------------------------<br />    ;; loop through arguments backwards, push<br />    ;; NON blank ones and call the function.<br />    ;; ---------------------------------------<br /><br />    FOR arg,&lt;p22,p21,p20,p19,p18,p17,p16,p15,p14,p13,\<br />             p12,p11,p10,p9,p8,p7,p6,p5,p4,p3,p2,p1&gt;<br />      IFNB &lt;arg&gt;    ;; If not blank<br />        push arg    ;; push parameter<br />      ENDIF<br />    ENDM<br /><br />    call name       ;; call the procedure<br /><br />ENDM<br /></code></pre><br />Regards,<br /><br /><a href="mailto:hutch@movsd.com">hutch@movsd.com</a></div>
    <div class="meta">Posted on 2002-03-18 03:46:54 by hutch--</div>
   </div>
   <div class="post" id="post-29729">
    <div class="subject"><a href="#post-29729">limit of param number using invoke</a></div>
    <div class="body">Thanks, Steve, but in C convention the macro also needs to adjust stack after all.<br />To all:<br />Actually when I wrote my first post I got solution by macro,<br />my intention of the post was just warn those who might be interested about the limitation in invoke.<br />After that I a little bit overreacted reflecting on proposition to<br />use structs in such cases :)<br />I hope you'll forgive my reflection ;)<br />In asm there are 16 ways to call procs and pass params,<br />and stdcall way is not always the best one.<br />It's good just cause became universal, but ...<br />This is my point of previous posts.<br />Thanks for your attention.</div>
    <div class="meta">Posted on 2002-03-18 06:35:51 by The Svin</div>
   </div>
   <div class="post" id="post-29732">
    <div class="subject"><a href="#post-29732">limit of param number using invoke</a></div>
    <div class="body">just tried it out. with fixed parameters the limit is 32, with VARARG in proto the limit is 48 params (MASM 6.15)</div>
    <div class="meta">Posted on 2002-03-18 06:49:01 by japheth</div>
   </div>
   <div class="post" id="post-29807">
    <div class="subject"><a href="#post-29807">limit of param number using invoke</a></div>
    <div class="body">Yes, if there is ONLY VARARG.<br />Try to put before VARARG couple DWORDs and result will be<br />the same 32 params limit.</div>
    <div class="meta">Posted on 2002-03-18 14:11:57 by The Svin</div>
   </div>
   <div class="post" id="post-29825">
    <div class="subject"><a href="#post-29825">limit of param number using invoke</a></div>
    <div class="body">Okay, i have a question.... Svin, feel free to pass on <br />your wisdom....<br /><br />For a function that takes a variable number of arguments<br />(wsprintf, for example), how does the function know how <br />many arguments it is receiving? I know that this does not <br />apply to actually cleaning up the stack, as the calling function <br />does that. Instead this concerns the function popping values <br />off the stack, how many should it pop before it stops?<br /><br />With Svin's strcat problem, this is how i see it working:<br /><pre><code><br />- call custom strcat function with an arbitrary number of arguments<br />- empty large buffer we maintain for this function<br />- enter loop<br />-     pop string pointer off the stack<br />-     copy string to our large buffer<br />-     check if we have any pointers left on stack<br />-     if we have more pointers, do loop again<br />-     &#40;note&#58; how do we know it is a string pointer, and not part of<br />        the stack frame from the calling function?&#41;<br />- exit loop<br />- pass pointer to buffer back to user<br /></code></pre><br /><br />I know that there is a flaw or two with my passing back of the <br />pointer to the finalised string, but i am keeping it simple :) <br />Unless i have totally misunderstood what Svin is wanting to <br />do, how could there be a quicker  method than this?</div>
    <div class="meta">Posted on 2002-03-18 17:27:45 by sluggy</div>
   </div>
   <div class="post" id="post-29878">
    <div class="subject"><a href="#post-29878">limit of param number using invoke</a></div>
    <div class="body">There are numerous way for called function<br />to know number of params.<br />It maybe passed as one of predefined arguments<br />though the function does not know at the begining<br />nor address of last arg niether number of them it knows<br />address of predefined arg (for example after<br />creating frame it might suppoused to be )<br />Another way - push special (ending) value as last argument,<br />and before processing next arg from the stack function<br />suppose to check if it is ending value - if so - it's done.<br />wsprintf know if there is any more values processing<br />template for &quot;%i&quot; ,&quot;%s&quot; .etc strings.<br />There are a lot more ways to syncronize working<br />between caller and callee, usually callee doesn't pop<br />anything - args remains in callculated place as memory<br />vars. Predefined args (required) go first so their place<br />could be calculated, varargs - after them.<br />Simple example of the first described method:<br /><pre><code>IfFieldsEmpty proc C uses ebx edi pcount&#58;DWORD,hndls&#58;VARARG<br />LOCAL buffer&#91;4&#93;&#58;BYTE<br />	mov edi,pcount<br />	dec edi<br />@@&#58;	invoke GetWindowText,dword ptr hndls&#91;edi*4&#93;,addr buffer,4<br />	test eax,eax<br />	je @r<br />	dec edi<br />	jns @B<br />@r&#58;	ret<br />IfFieldsEmpty endp</code></pre>Of course there is no problem to write such code each time you need it<br />- except that it would be just waste of your time and bigger release.<br />Macros in the case could save your typing time but generate additional<br />code while using the proc above needs to write it once and forever and<br />code itself doesn't take additional amount of space. You just use space<br />to pass params and call it each time you need it, not for code itself.<br />You can arrange, of course, such task to pass params from struct, but<br />question is what for? You need additional memory var for it, while you<br />already have stack, and you doomed to warry if those strucs are large<br />enough to handle all params. I understand using structs (and I use them<br />havily) when it is appropriate, so that it might save size or speed up things.<br />For example if several times pass the same struc addr as place for args,<br />but fully fill it just for the first time, for next calls you may replace just<br />few of args in the struct and it will save time cause you don't need <br />pass(or fill) all params each time. But it is different thing.<br />In that case there is NATURAL need (reflecting of result - speed) to<br />do it so your going for struct approach is senceble and reasonable,<br />not in the case when you force to do it 'cause you main tool fails to<br />do what you need.<br />We are the masters - tools are slaves.<br />Probably almost all here are able looking at ready progs written in HLL IDE<br />figure out whether it was written on VB, Delphy of VC++.<br />That is thing I fear most - when your tool reflect on your result, then<br />the tools became masters.<br />One of reason I use asm - to have more control.<br />Of course, my work is still affected by tools, but at least I'm<br />trying to ask myself - why did I do it - cause it was right way to do or<br />just cause it was easy to do with the tool I'm currently using?<br />They SHALL OBEY OUR WISH AND COMMANDS! :)<br />Otherwise we become kinda slaves :)</div>
    <div class="meta">Posted on 2002-03-19 01:55:15 by The Svin</div>
   </div>
  </div>
 </body>
</html>