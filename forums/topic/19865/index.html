<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>OpenGL Engine DLL - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=19865" />
    <link rel="next" href="../?id=19865&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=19865">OpenGL Engine DLL</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=19865&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=19865&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="19865" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=19865&amp;page=2">&gt;</a><a href="../?id=19865&amp;page=2">&raquo;</a></form>   <div class="post" id="post-152578">
    <div class="subject"><a href="#post-152578">OpenGL Engine DLL</a></div>
    <div class="body">I've recently started a fresh DLL based OpenGL engine project with a friend of mine. He's a 2D artist so I've begun by concentrating on orthographic tile-animated sprites for a start.<br />The current code is heavily based on NeHe tutorial#17 (the masm source for that is not correct but it works) - a DisplayList of orthographic rectangles is created and used as a &quot;charactermap&quot;, like a font.<br />Anyone interested, a small demo was posted at http://homer.ultrano.com/dllStuff.rar<br /><br />Have a nice day :)</div>
    <div class="meta">Posted on 2004-11-08 21:07:07 by Homer</div>
   </div>
   <div class="post" id="post-152587">
    <div class="subject"><a href="#post-152587">OpenGL Engine DLL</a></div>
    <div class="body">The 2D part of the engine now sports the following components:<br /><br />-Sprite class instances are managed using one or more instances of &quot;SpriteManager&quot; class (a collection container of sorts)<br /><br />-SpriteAnimation class instances are stored in a global SpriteAnimationManager class instance, and shared by all instances of Sprite class<br /><br />SpriteAnimations support the following &quot;FinalAction&quot; values:<br />_DIE_  - sprite will mark itself for destruction when animation finishes<br />_PAUSE_  - sprite will use last animation frame when animation finishes<br />_LOOP_  - Animation will loop<br />pUserFunction - CallBack to UserFunction when animation finishes<br /><br />Animation speed is floating point in fps, and negative speed is ok.<br />At the moment, only 16x16 cells per image are allowed (256 animation framecells per bmp) and this will be the next restriction to be addressed.<br /><br />I will soon post another demo showing some of this further work.<br />Any feedback would be appreciated, especially error reports :)</div>
    <div class="meta">Posted on 2004-11-09 04:20:35 by Homer</div>
   </div>
   <div class="post" id="post-152631">
    <div class="subject"><a href="#post-152631">OpenGL Engine DLL</a></div>
    <div class="body">I've added a SuperBmp class which encapsulates a 2d scrolling tilemap stored as an array of bytes which represent Tiles from a font-bmp (If you've done your homework, you understand what a font-bmp is)<br /><br />The Engine provides a scrollable &quot;foreground&quot; as well as methods to get and set the scroll position.<br /><br />I've also implemented the following CallBacks, as well as procs to set them from your user code:<br /><br />CALLBACK_PREINIT ()<br />CALLBACK_POSTINIT ()<br />CALLBACK_RENDER ()<br />CALLBACK_UPDATE (fElapsed)<br />CALLBACK_KEYBOARD (pKeys)<br /><br />The full list of functions exported by the DLL (without param info):<br />WinMain<br />SetPreInitCallBack<br />SetPostInitCallBack<br />SetRenderCallBack<br />SetUpdateCallBack<br />SetKeyboardCallBack<br />GetTileAddress<br />GetScrollX<br />SetScrollX<br />GetScrollY<br />GetSizeX<br />GetSizeY<br />glPrint<br /><br />You will appreciate this is a work in progress, but already here is my test exe source so you can see what this project offers you:<br /><br /><pre><code><br />;----------------------------------------------------------------------------------------------------------------------------------------<br />.486<br />.model flat, stdcall<br />option casemap&#58;none<br />;----------------------------------------------------------------------------------------------------------------------------------------<br />include \masm32\include\windows.inc<br />include \masm32\include\kernel32.inc<br />include \masm32\include\user32.inc<br /><br />includelib \masm32\lib\kernel32.lib<br />includelib \masm32\lib\user32.lib<br />includelib NoConsoleDLL.lib     ;The lib for the Engine DLL <br /><br />include \masm32\include\macros.inc<br />;----------------------------------------------------------------------------------------------------------------------------------------<br />;----------------------------------------------------------------------------------------------------------------------------------------<br />;----------------------------------------------------------------------------------------------------------------------------------------<br />;PROTOTYPES FOR DLL FUNCTIONS<br />;----------------------------------------------------------------------------------------------------------------------------------------<br />WinMain                  PROTO &#58;DWORD,&#58;DWORD,&#58;DWORD,&#58;DWORD<br />SetPreInitCallBack PROTO &#58;DWORD<br />SetPostInitCallBack PROTO &#58;DWORD<br />SetUpdateCallBack PROTO &#58;DWORD<br />SetRenderCallBack PROTO &#58;DWORD<br />SetKeyboardCallBack PROTO &#58;DWORD<br />GetTileAddress        PROTO &#58;DWORD,&#58;DWORD<br />GetScrollX                PROTO<br />SetScrollX                PROTO &#58;DWORD<br />GetScrollY                PROTO<br />GetSizeX                  PROTO<br />glPrint			PROTO &#58;DWORD, &#58;DWORD, &#58;DWORD, &#58;UINT<br /><br />;----------------------------------------------------------------------------------------------------------------------------------------<br />;----------------------------------------------------------------------------------------------------------------------------------------<br />.code<br />;----------------------------------------------------------------------------------------------------------------------------------------<br />;The User must provide a WndProc function, it MUST process WM_CLOSE as shown.<br />;Any other messages of interest may be processed by the user as normal if they wish.<br />;----------------------------------------------------------------------------------------------------------------------------------------<br />WndProc proc hWind&#58;HWND, uMsg&#58;UINT, wParam&#58;WPARAM, lParam&#58;LPARAM<br />      .if uMsg==WM_CLOSE<br />              invoke PostQuitMessage,0<br />              xor eax,eax<br />              ret<br />      .endif<br />    invoke DefWindowProc,hWind,uMsg,wParam,lParam<br />    ret<br />WndProc endp<br />;----------------------------------------------------------------------------------------------------------------------------------------<br />;The User may provide several key CallBack functions&#58;<br />;Update is called from the main loop just after the Time is updated<br />;and Elapsed Time calculated, the Elapsed Time is passed as the<br />;only parameter for the procedure.<br />;Render is called from the internal rendering code, which occurs<br />;after Update but before keyboard processing. It requires NO parameters.<br />;PreInit and PostInit CallBacks require no params.<br />;They are called either side of the Window Creation code at startup<br />;and never again - they are onetime callbacks.<br />;They will not be called again if the window is &quot;recreated&quot; for any reason.<br />;Keyboard VallBack expects one param, it's ptr to keys array<br />;----------------------------------------------------------------------------------------------------------------------------------------<br /><br />Pre proc <br />;Message &quot;pre&quot;<br />ret<br />Pre endp<br /><br />Post proc <br />;Message &quot;post&quot;<br />ret<br />Post endp<br /><br />Update proc fTimeElapsed     <br />ret<br />Update endp<br /><br />Render proc <br />local buf &#91;256&#93;&#58;BYTE<br />local ex<br />local why<br />    invoke GetScrollX<br />    mov ex,eax<br />    invoke GetScrollY<br />    mov why,eax<br />    invoke wsprintf, addr buf,CTEXT&#40;&quot;ScrollPosition&#58; X=%lu Y=%lu&quot;&#41;,ex, why<br />    invoke glPrint, 0, 0, addr buf, 1<br />    ret<br />Render endp<br /><br />;=====================================<br />Keys proc uses esi  pKeys&#58;DWORD<br />local ex<br />local sighsex<br />    mov esi,pKeys<br />    .if byte ptr &#91;esi+VK_LEFT&#93;<br />        mov byte ptr &#91;esi+VK_LEFT&#93;,0<br />        invoke GetSizeX<br />        mov sighsex,eax<br />        invoke GetScrollX<br />        mov ex,eax<br />        .if eax&lt;sighsex<br />           inc ex<br />           invoke SetScrollX, ex<br />        .endif<br />    .endif<br /><br />    .if byte ptr &#91;esi+VK_RIGHT&#93;<br />        mov byte ptr &#91;esi+VK_RIGHT&#93;,0<br />        invoke GetSizeX<br />        mov sighsex,eax<br />        invoke GetScrollX<br />        mov ex,eax<br />        .if ex!=0<br />           dec ex<br />           invoke SetScrollX, ex<br />        .endif<br />    .endif<br />    ret<br />Keys endp<br />;=====================================<br />;----------------------------------------------------------------------------------------------------------------------------------------<br />start&#58;<br />; Check	if we should start in full screen<br />    invoke MessageBox,NULL,CTEXT&#40;&quot;Do you want to run in fullscreen?&quot;&#41;,CTEXT&#40;&quot;Graphics mode&quot;&#41;,MB_YESNO or MB_ICONQUESTION<br />    .IF eax == IDNO<br />        push FALSE<br />    .ELSE<br />        push TRUE<br />    .ENDIF<br /><br />    invoke SetPreInitCallBack, addr Pre             ;Tell Engine about my OneTime proc<br />    invoke SetPostInitCallBack, addr Post           ;Tell Engine about my OneTime proc<br />    invoke SetUpdateCallBack, addr Update       ;Tell Engine about my Update proc<br />    invoke SetRenderCallBack, addr Render       ;Tell Engine about my Render proc<br />    invoke SetKeyboardCallBack, addr Keys       ;Tell Engine about my Keys proc<br /><br />    invoke GetModuleHandle,0<br />    pop ebx<br />    invoke WinMain,eax,addr WndProc,ebx,0     ;params are hInstance , address of User WndProc , bWindowed<br />    invoke ExitProcess, eax                                 ;returnvalue from WinMain is exitcode<br />;----------------------------------------------------------------------------------------------------------------------------------------<br />end start<br /></code></pre><br /><br />Seriously, this thing will make 2d gamedev a lot easier, and support for 3D is inherently available since the 2d is really 3D-Assisted.<br />No interest out there?</div>
    <div class="meta">Posted on 2004-11-10 02:09:23 by Homer</div>
   </div>
   <div class="post" id="post-152633">
    <div class="subject"><a href="#post-152633">OpenGL Engine DLL</a></div>
    <div class="body">I no have real clue on game developevement or engine :S, I whant to watch :P</div>
    <div class="meta">Posted on 2004-11-10 02:46:28 by rea</div>
   </div>
   <div class="post" id="post-152649">
    <div class="subject"><a href="#post-152649">OpenGL Engine DLL</a></div>
    <div class="body">What I'm writing is a DLL that contains all the &quot;boring&quot; parts of a 2D or 3D game, supplying the would-be gamedev with a solid foundation to build a real game without having to stare at the housekeeping code.</div>
    <div class="meta">Posted on 2004-11-10 08:29:37 by Homer</div>
   </div>
   <div class="post" id="post-152883">
    <div class="subject"><a href="#post-152883">OpenGL Engine DLL</a></div>
    <div class="body">Not much progress to report except for the following improvement to keyboard processing:<br /><br />I no longer catch and process keyboard related WMs, I now call GetKeyboardState. The reason is that the former method does not allow us to check for multiple simultaneous keypresses because a keypress is processed as soon as it is detected.. the latter method although more expensive allows us to much more cleanly detect for example the UP and LEFT cursor keys both at once.</div>
    <div class="meta">Posted on 2004-11-14 06:51:37 by Homer</div>
   </div>
   <div class="post" id="post-152947">
    <div class="subject"><a href="#post-152947">OpenGL Engine DLL</a></div>
    <div class="body">The code for the Timer has been replaced with HighPerformanceTimer code which was ungraciously stolen from Scronty's DX8 includes :)<br />All the Timer related functions return Time as a floating point QWORD on the fpu stack.<br />Any mention of GetTickCount has been removed.<br />If your hardware does not support the HighPerformanceTimer, the Timer code will use timeGetTime calls instead.</div>
    <div class="meta">Posted on 2004-11-14 22:10:13 by Homer</div>
   </div>
   <div class="post" id="post-153058">
    <div class="subject"><a href="#post-153058">OpenGL Engine DLL</a></div>
    <div class="body">The engine now boasts its first instanced 3d object - a textured cube.<br />The cube object is encapulated within the Cube class.<br />Another class, CubeManager, has been instanced within the engine to manage an array of pointers to live instances of the Cube object.<br />(That means you can have as many Cubes as you like.)<br /><br />A function has been exported to allow the User to create managed Cube instances. It is recommended that you call CubeManager methods in preference to calling Cube methods.<br /><br />Far cooler than the Cube stuff is the MousePick code I've implemented.<br />It uses the OpenGL NameStack, so that means the Cube class (and any future 3dobject classes) has TWO render methods - Selectable and Non Selectable. <br /><br />Since a &quot;Name&quot; in OpenGL is just a DWORD, I'm using the pointer to the Cube instance as the &quot;Name&quot; during Select-rendering. <br />This is the &quot;ID&quot; I am returned by my &quot;What The Hell Did I Click On&quot; function (called in response to left mouse down).<br /><br />A decent start :)</div>
    <div class="meta">Posted on 2004-11-16 05:21:02 by Homer</div>
   </div>
   <div class="post" id="post-153159">
    <div class="subject"><a href="#post-153159">OpenGL Engine DLL</a></div>
    <div class="body">I for one know next to nothing about graphic related programming (such as your project).  Any idea if there will be documentation/tutorial(s) and perhaps even a sample (if that's not too much work) game/program once the library is complete?</div>
    <div class="meta">Posted on 2004-11-17 21:21:41 by DaRetard</div>
   </div>
   <div class="post" id="post-153166">
    <div class="subject"><a href="#post-153166">OpenGL Engine DLL</a></div>
    <div class="body">Of course - complete and verbose documentation and examples will both be provided in good time. You won't need to know a lot of heavy programming or 3d math to create cool and fast 3d games and applications with this library - its purpose is to do all the dirty work for you, leaving you to worry about the nuts and bolts of your app.<br /><br />Yesterday I wrote Fustrum Culling code, and today I wrote a Camera class. These will probably both be implemented by tomorrow :)</div>
    <div class="meta">Posted on 2004-11-18 01:14:18 by Homer</div>
   </div>
   <div class="post" id="post-153203">
    <div class="subject"><a href="#post-153203">OpenGL Engine DLL</a></div>
    <div class="body"><div class="quote">Yesterday I wrote Fustrum Culling code, and today I wrote a Camera class.</div><br /><br />No idea what that is but your project definitely seems pretty cool.  Keep up the great work  :-D</div>
    <div class="meta">Posted on 2004-11-18 18:50:18 by DaRetard</div>
   </div>
   <div class="post" id="post-153205">
    <div class="subject"><a href="#post-153205">OpenGL Engine DLL</a></div>
    <div class="body">If I am mentioning subjects which seem alien to you, and you are interested in this topic (gamedev), then it might pay to look them up :)<br /><br />A fustrum is a pyramid with a rectangular base , and with the point sliced off so that it resembles a cube with tapered sides.<br /><br />A view fustrum is an imaginary pyramid which is being projected from your eyeball , the point of the fustrum would be in your eye. The view fustrum is the area of 3D world that you can see.. imagine theres a pyramid coming out of an eyeball and moving about in the 3D world ... if we can figure out what stuff is inside the fustrum, we can draw that stuff on the screen, and we don't have to draw anything else. If its not partially or fully inside the fustrum, its OFFSCREEN AND NOT VISIBLE !!<br /><br />So this fustrum culling concept is simply an attempt to not have to draw stuff thats not visible anyway :)<br /><br />If you had a complex and large 3D world made of 3 and a half zillion triangles, but only 20 triangles are visible, then throwing 3 and a half zillion triangles at your graphic card 30 or times a second starts to sound as silly as it is... if we can mathematically eliminate stuff thats simply not visible at the time, we can render much faster.<br /><br />As for the Camera class... when I mention 'class' that refers to oop (object oriented programming) - in essence what this means is you can if you like make infinite number of cameras and put them where u like or even attatch them to other objects... like a player model or a flying missile..say, that oop stuff sounds ok, doesn't it? :)</div>
    <div class="meta">Posted on 2004-11-18 20:30:16 by Homer</div>
   </div>
   <div class="post" id="post-153273">
    <div class="subject"><a href="#post-153273">OpenGL Engine DLL</a></div>
    <div class="body">Hi EvilHomer2k, how do you do frustum culling? do you check every vertex? or maybe check one vertex per object? is it even considerable to perform 'every-vertex' checking? i'm following this thread, because i plan do write 3d engine for direct3d9 with custom shaders. i understand whole DX architecture, and know how to do things using it, but first i'd like to collect some experience :)</div>
    <div class="meta">Posted on 2004-11-20 19:23:12 by ti_mo_n</div>
   </div>
   <div class="post" id="post-153277">
    <div class="subject"><a href="#post-153277">OpenGL Engine DLL</a></div>
    <div class="body">Well that's a good question, and it depends what you want to cull, but the general answer to that question is that you should surround chunks of geometry in an imaginary bounding cube or sphere.<br />For &quot;3d objects&quot;, these can be defined with as little as a single Radius value (given that your &quot;object&quot; already has position vector)<br /><br />Your fustrum checks should be performed not against the geometry itself but against imaginary container geometries... if the container is not partially within the fustrum, then you know its contents aren't visible.<br /><br />When it comes to fustrum culling of &quot;static world geometry&quot; like maybe a 3d terrain or a castle ruin, you should be using some kind of &quot;space partitioning&quot; to containerize chunks of the world geometry in EXACTLY the same way as described above, the only difference being that the bounding geometry may need to be explicitly defined in order to achive &quot;tighter fits&quot;.<br /><br />If you can picture a world full of objects that are encapsulated by glass fishtanks of simple geometry, you can see that you only need to be culling the fishtanks, not the fish :)<br /><br />Having done that you can perform lowlevel culling on the fish if you like, but by this time there's not many half-visible fish left to worry about and its absolutely ok to not bother..<br /><br />Hope you liked my analogy :)</div>
    <div class="meta">Posted on 2004-11-20 21:24:01 by Homer</div>
   </div>
   <div class="post" id="post-153278">
    <div class="subject"><a href="#post-153278">OpenGL Engine DLL</a></div>
    <div class="body">I ought to point out now that there's a very efficient way of extracting the fustrum planes from the current view, rather than defining the fustrum as a cube and then deforming it into a view fustrum using matrices, we can extract the planes of the fustrum from the current view mathematically.</div>
    <div class="meta">Posted on 2004-11-20 21:28:01 by Homer</div>
   </div>
   <div class="post" id="post-153283">
    <div class="subject"><a href="#post-153283">OpenGL Engine DLL</a></div>
    <div class="body">thanx :) now i got it. so i need to encapsulate my very_complicated_object_consisting_of_999999999_triangles into simple cube (or sphere) and check wheter the cube is inside the frustum. to do that i extract 6 frustum planes (left, right, top, bottom, near, far), and do plane equation with cube's vertices, right?</div>
    <div class="meta">Posted on 2004-11-20 22:21:24 by ti_mo_n</div>
   </div>
   <div class="post" id="post-153284">
    <div class="subject"><a href="#post-153284">OpenGL Engine DLL</a></div>
    <div class="body">That's right :)<br /><br />If you want to go further, you can divide the imaginary cube into cubelets, and divide the object geometry among the cubelets, now surround the cubelets with the original cube and you have hierarchical octal space partitioning, which if you like can be N deep - split the cubelets !! Stop when some minimum triangles are in a cubelet :)<br /><br />Just stuff to make you think, if your models are VERY complex, its worth applying osp to the models themselves as you would to an entire world :)<br /><br />In such a system - if the mother cube is visible, check all its babies - for each visible baby cube, check its babies... all the geometry is stored in the lowest nodes (smallest cubes) of such a tree, so you only have to render when the cube is visible, has no visible babies, and contains triangles :)</div>
    <div class="meta">Posted on 2004-11-20 22:25:43 by Homer</div>
   </div>
   <div class="post" id="post-153288">
    <div class="subject"><a href="#post-153288">OpenGL Engine DLL</a></div>
    <div class="body">Camera class has been implemented - YAY :)<br />Thanks to ti_mo_n for noticing my silly fpu overflow !!<br /><br />Now debugging my Frustum class , which encapsulates Frustum Culling of Point, Sphere and Cube entities :-D  :-D  :-D</div>
    <div class="meta">Posted on 2004-11-21 02:13:14 by Homer</div>
   </div>
   <div class="post" id="post-153341">
    <div class="subject"><a href="#post-153341">OpenGL Engine DLL</a></div>
    <div class="body">Frustum class has been debugged, I'm trying to decide now how to best implement it.<br />I am thinking seriously about making it a dynamic subclass of the Camera class .. ie, a Camera instance owns a Frustum instance which is strongly associated with THAT Camera instance only.<br />Every Camera owns a Frustum, we simply call the culling methods of the active camera instance :) Sound ok?</div>
    <div class="meta">Posted on 2004-11-22 02:00:32 by Homer</div>
   </div>
   <div class="post" id="post-153342">
    <div class="subject"><a href="#post-153342">OpenGL Engine DLL</a></div>
    <div class="body">Now the &quot;active Camera&quot; needs to take responsibility not just for setting up the View, but also for culling stuff during rending... should I simply move the call to RenderScene inside the Camera class, so that the Active Camera does all the rending in its own context? Anyone have a better idea which doesnt involve throwing stuff at the Camera to deal with?</div>
    <div class="meta">Posted on 2004-11-22 02:05:47 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=19865&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=19865&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="19865" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=19865&amp;page=2">&gt;</a><a href="../?id=19865&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>