<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Modulus Power... - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=15924" />
    <link rel="next" href="../?id=15924&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=15924">Modulus Power...</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=15924&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=15924&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="15924" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=15924&amp;page=2">&gt;</a><a href="../?id=15924&amp;page=2">&raquo;</a></form>   <div class="post" id="post-123373">
    <div class="subject"><a href="#post-123373">Modulus Power...</a></div>
    <div class="body"><pre><code>; Example&#58;<br />;<br />__K__ QWORD 0B1F00FFF800003FFh<br /><br />;	compute&#58; 7^12821765729162363903 MOD 1973 = 911<br />;<br />	lea	esi, __K__	; exponent<br />	mov	ebx, 64 - 1	; bits in __K__ - 1<br />	mov	edi, 7		; mod<br />	mov	ecx, 1973	; modulus base<br />	call	MOD_POW<br /><br />;----------------<br /><br />MOD_POW&#58;<br />	mov	edx, 1<br />	jmp	_1<br /><br />_0&#58;	mul	eax		; A^2<br />	div	ecx		; MOD N<br />_1&#58;	bt	&#91;esi&#93;, ebx	; B&#40;n-1&#41;, B&#40;n-2&#41;, ... , 2, 1, 0<br />	mov	eax, edi<br />	jnc	_2		; *UNPREDICTABLE CONDITIONAL JUMP*<br />	mul	edx		; A*M<br />	div	ecx		; MOD N<br />_2&#58;	dec	ebx		; next lower bit of power<br />	mov	eax, edx	; bound to MOD N<br />	jns	_0		; until all bits of power have been tested<br /><br />	ret</code></pre>...fresh out of a hot steaming oven.<br />Don't you just love the smell...<br /><br />Cook up some code! :grin:<br /><br />From the book:<br /><a target="_blank" href="http://computerscience.jbpub.com/catalog/0763723878/"><em>Foundations of Algorithms Using C++ Pseudocode</em></a>, Third Edition<br />by Richard Neapolitan and Kumarss Naimipour<br /><br />The C++ in this book is crazy - he doesn't use any high-level types (vector, matrix, etc.) - instead he mixes the mathematical expressions with the C++ -- damn crazy to understand.  I just wanted to read the code and translate into ASM, but the code was too scary by itself.  He couldn't have put much thought into this, imho.  Luckily, I was able to gleam enough from the book text to reconstruct the algorithm - which he did explain well.<br /><br />I've been thinking of ways to speed up the algorithm - lazy at first, then maybe for more exotic transformations.  I also have not browsed every corner of the web for a solution, or looked through the libraries on my harddrive for someone else's code -- the goal here is to use my own creative ideas - for me it helps to have a clean slate so to speak, a fresh mind.<br /><br />Well, the very first thing to hit my mind was not such a simple thing:  I was thinking about creating 256 optimized routines and then branching on a byte instead of a bit - because that branch is going to be very costly on newer machines and I really want to reduce that negitive.  Oh, and those divides - I don't like them either.<br /><br />...I'm rambling, but bandwidth is getting cheaper as you read this. :grin:</div>
    <div class="meta">Posted on 2003-11-03 22:18:53 by bitRAKE</div>
   </div>
   <div class="post" id="post-123391">
    <div class="subject"><a href="#post-123391">Modular Exponentiation...</a></div>
    <div class="body">Hello Bitrake<br /><br />What about extending The Svin's divider to 64-bit (u know, that trick that allows to compute q = x / y as a MUL ; after that u would just make a x - (q * 1973) to get the remainder :) No, useless : I think his divider gives u the remainder too.<br />And as I am lazy, please code it for my Opteron ;)</div>
    <div class="meta">Posted on 2003-11-04 05:21:05 by valy</div>
   </div>
   <div class="post" id="post-123400">
    <div class="subject"><a href="#post-123400">Modular Exponentiation...</a></div>
    <div class="body">Hi bitRAKE,<br /><br />&quot;modulus power&quot; is slightly bad choosen, better &quot;modular exponentation&quot; :)<br />The  bt , ebx should be avoided. Instead left shift the exponent until the MSB goes into carry. Then the BT instruction can be replaced by simple ADD ESI,ESI and JNC/JC. EBX should contains the bitcount of the exponent. <br />But contrary to your code, it works then only to 32 bit exponents.<br /><br />One optimization more can be done. We can work with Montgomery trick. Instead 1 MUL + 1 DIV we use then 2 MUL + 1 IMUL. We need the values U = M^-1 mod 2^32, M = Modulus, Base' = Base * 2^32 mod M.<br />Reduceing are then:<br /><br /><pre><code><br /><br />         mul  eax      // Base' = Base'^2 <br /><br />         mov  edi,eax  // montgomery REDC<br />         mov  esi,edx<br />         imul eax,U     <br />         mul  M<br />         add  eax,edi  // eax = 0<br />         adc  edx,esi<br />         jnc  @@1<br />         sub  edx,M<br />@@1&#58; <br />   <br /><br /></code></pre><br /><br />Reducing two times a value we convert from montgomery domain back to normal domain.<br />If we want a fast primality check then your exponentation is the basis algorithm. The montgomery percomputation are than only one times done, for more as one exponentation. This trick get us the way to use SSE2.<br /><br />And it exists ways to reduce big exponents down to size smaller the modulus.<br /><br />If you are interessted I have some IsPrime() code for 2^32 bounds.<br /><br />Hagen</div>
    <div class="meta">Posted on 2003-11-04 07:45:21 by Hagen</div>
   </div>
   <div class="post" id="post-123449">
    <div class="subject"><a href="#post-123449">Modular Exponentiation...</a></div>
    <div class="body"><strong>Hagen</strong>, Thanks for clearing up the naming - I want to confuse the least number of people as possible. :)<br /><br />The BT instruction is okay on Athlons - in fact the register version is direct path and only one cycle.  Branching on a byte would remove this instruction and the branch altogether.<br /><br />The multiply/divide reduction is very good.  I was trying to think of something like this, but didn't make the connection just yet.<br /><br /><u>Handbook of Applied Cryptography</u><br />by Alfred J. Menezes, Paul C. Van Oorschot, Scott A. Vanstone<br /><span style="font-size:9px><a target="_blank" href="">http://www.cacr.math.uwaterloo.ca/hac/index.html</a> (PDF sample chapters to download)</span><br />p.600, Section 14.3.2, explains the Montgomery reduction and gives examples.<br /><br />I would like to see your IsPrime() code, but it might be better suited to it's own thread or attached to an existing <a target="_blank" href="http://www.asmcommunity.net/board/index.php?topic=13322&amp;highlight=prime">thread on primes</a>.  Primes seem to get people motivated because of their uses, but my goals are more general - I mentioned it merely as where I first came across the algorithm. Many people want to learn about algorithm development and I think reduction of mathematical operations on very large numbers is an area where many people can relate easily.  Also, there seems to be some quite experienced people in this area that frequent the board. ;)<br /><br /><strong>valy</strong>, It is not always clear where to go from a na?ve implementation of an algorithm.  There are two distinct skills to develop: on one hand we have the knowledge of the most optimal algorithm, and on the other hand there is the implementation.  The same techniques we apply within the algorithm can be used to build the algorithm - high-level programming does not require this added complexity.  I mean you can try to order things to give the compiler a better chance at optimization, but it does not have the same effectiveness of coding in ASM.<br /><span style="font-size:9px><br />Oh, I just wanted to make note of the numbers above chosen for the sample - I made them up and it came out to 911 - I was surprised.  7 was chosen on a whim - I usually pick 5.  Then the exponent is just the bit pattern of the fibonocci sequence.  Finally, the modulus is the year I was born.  I just thought it strange.<br /><br />7^12821765729162363903 MOD 1973 = 911</span> :eek:</div>
    <div class="meta">Posted on 2003-11-04 20:13:42 by bitRAKE</div>
   </div>
   <div class="post" id="post-123563">
    <div class="subject"><a href="#post-123563">Modular Exponentiation...</a></div>
    <div class="body">I think it would be useful to apply <a target="_blank" href="http://www.math.okstate.edu/~wrightd/crypt/lecnotes/node19.html">Fermat's Theorem</a> at the outset in order to reduce the size of the exponent. For our purposes 7^12821765729162363903 = 7^1923 mod 1973, according to the theorem. This reduces the complexity significantly and works well with exponents that are larger than the prime modulus.</div>
    <div class="meta">Posted on 2003-11-05 19:27:01 by Poimander</div>
   </div>
   <div class="post" id="post-123875">
    <div class="subject"><a href="#post-123875">Modular Exponentiation...</a></div>
    <div class="body">In general does anyone think it would be a performance inprovement to store the numbers as an array of primes.  For example, 72 would be stored as 2,2,2,3,3 or rather (2,3),(3,2) might be better.  Could also store negitive exponents rather than performing the divide.  72/13 = (2,3),(3,2),(13,-1). Add and subtract operations would take longer, but I'd think it would simplify many other algorithms.</div>
    <div class="meta">Posted on 2003-11-09 11:43:34 by bitRAKE</div>
   </div>
   <div class="post" id="post-123940">
    <div class="subject"><a href="#post-123940">Modular Exponentiation...</a></div>
    <div class="body">Isn't the (2,3)(3,2) thing called factorisation? (sorry for compactness i'm on a F-keyboard, scrambled everything)</div>
    <div class="meta">Posted on 2003-11-10 10:02:32 by inFinie</div>
   </div>
   <div class="post" id="post-124014">
    <div class="subject"><a href="#post-124014">Modular Exponentiation...</a></div>
    <div class="body">@bitRAKE, that depends on what you want to compute. Using the prime factorization leads as example in computation of big factorial/binomials etc. to very fast algorithms.<br />Using it for plan modular exponentation are'nt helpfully. Then it is better for arbitrary integers to use a prime remainder representation of each number. Now addition, subtractions are linear and modular reduction works only on the remainder arrays. With some special hardware we get the fastest performances. Take a look for David Bernstein, he descripe this technic. Some other sources are Arnold Sch?nhage with the Modular Fermat Fast Fourier Transformation where the numbers are remainder representations to modulis of the form 2^(r*m) +1. All these technics are based on the Chinese Remainder Theorem.<br /><br />Best Regards, Hagen</div>
    <div class="meta">Posted on 2003-11-11 05:39:08 by Hagen</div>
   </div>
   <div class="post" id="post-124467">
    <div class="subject"><a href="#post-124467">Modular Exponentiation...</a></div>
    <div class="body">I found this link to a very entertaining and readable <br />survey paper on fast modular exponentiation algorithms:  <a target="_blank" href="http://citeseer.ist.psu.edu/gordon97survey.html">http://citeseer.ist.psu.edu/gordon97survey.html</a></div>
    <div class="meta">Posted on 2003-11-15 16:41:01 by Poimander</div>
   </div>
   <div class="post" id="post-124560">
    <div class="subject"><a href="#post-124560">Modular Exponentiation...</a></div>
    <div class="body">This is how long Mathematica takes for my test numbers:<pre><code>In&#91;1&#93;&#58;= Timing&#91;PowerMod&#91;2^9689 - 1, 2^9941 - 1, 2^11213 - 1&#93;;&#93;<br />Out&#91;1&#93;= &#123;7.656 Second, Null&#125;</code></pre>If <strong>Hagen</strong> or anyone else could post timings of their algortihms to give me a reference.  What is the fastest you can compute (2^9689 - 1) ^ (2^9941 - 1) MOD (2^11213 - 1)?  Thank you, <strong>Poimander</strong>, that was exactly what I was looking for - should be some more code coming soon.</div>
    <div class="meta">Posted on 2003-11-16 18:51:52 by bitRAKE</div>
   </div>
   <div class="post" id="post-124578">
    <div class="subject"><a href="#post-124578">Modular Exponentiation...</a></div>
    <div class="body">With my lib 1.2 seconds, but thats a little bit tricky to explain :)<br />Your numbers are all of special form of 2^k-1, thus we can use special algorithms there are special exorbitant faster ! If I use a generic modular Exponentation then my lib need about 8 seconds. Thus Mathematika as a interpreter MUST be taken care of your special numbers. Otherwise I could'nt explain why Mathematica should run such as fast.<br /><br />I used for the 1.2 second variant a B^E mod (2^k-1) algorithm, but it should be realy faster to use another algorithm, because B = 2^k-1 and E = 2^k-1.<br /><br />Thus, try to generate Random Numbers B = 9689 bits, E = 9941 bits and M = 11213 bits and even. Then run a test with Mathematica. If than Mathematica runs faster as 8 seconds, my Library must be realy slow :-)<br /><br /><br />Best regards, Hagen</div>
    <div class="meta">Posted on 2003-11-17 04:49:13 by Hagen</div>
   </div>
   <div class="post" id="post-124580">
    <div class="subject"><a href="#post-124580">Modular Exponentiation...</a></div>
    <div class="body">Hagen: how fast your library is, compared to LibGMP ?<br /><br />I used LibNTL to do some lattice reductions, and had to convert LibGMP in Intel assembly format.<br />If you have a fast library, I'm interested in adding it to my current code...</div>
    <div class="meta">Posted on 2003-11-17 05:59:14 by MCoder</div>
   </div>
   <div class="post" id="post-124589">
    <div class="subject"><a href="#post-124589">Modular Exponentiation...</a></div>
    <div class="body"><strong>Hagen</strong>, Mathematica is actually faster with random numbers!?<pre><code>In&#91;1&#93;&#58;= R1 = Random&#91;Integer, &#123;2^9689, 2^9690&#125;&#93;;<br />        R2 = Random&#91;Integer, &#123;2^9941, 2^9942&#125;&#93;;<br />        R3 = 2 * Random&#91;Integer, &#123;2^11212, 2^11213&#125;&#93;;<br />        Timing&#91;PowerMod&#91;R1, R2, R3&#93;;&#93;<br /><br />Out&#91;1&#93;= &#123;5.625 Second, Null&#125;</code></pre>My code doesn't work yet. So, anything else is faster at this point, but I'd like to beat the best thing out there. :)</div>
    <div class="meta">Posted on 2003-11-17 08:46:32 by bitRAKE</div>
   </div>
   <div class="post" id="post-124657">
    <div class="subject"><a href="#post-124657">Modular Exponentiation...</a></div>
    <div class="body">@MCoder, my Lib is faster as LibGMP. That depends on some different things.<br />1. my Lib use equal many lines of assembler optimized code, especialy for SSE2<br />2. my Lib use assembler optimized Algorithms for as example Montgomery, where GMP don't use such Algorithms.<br />3. especialy with very large arbitrary Integers I have used better Algorithms as in GMP. As Example, i and GMP use a Sch?nhage Fermat Fast Fourier Transformation combined with a Fast Karatsuba Division of Burnikel &amp; Ziegler. But GMP use a one to one translation of Burnikel &amp; Ziegler Papers. Thats strange because they Algorithm use only half the Time they described advantages. (you can call it as a bug :-) My own Version of this fast Division use always they fast trick and should be thus about 2 times faster.<br />4. try Miracl instead of GMP. Miracl is faster as GMP especial with modular computation.<br />5. GMP is a usefull base to get very low level optimized source. If we want a fast math library we can use GMP as base to implement the important and complex algorithm. But exactly this step is the hardest one, harder as to program a simple and fast addition,multiplication into assembler. As example a clever modular multiplication on Elliptic Curve use some mathematical tricks. Understanding these math tricks and get it running are the harder work.<br /><br />But all these matters are'nt the big differences. My Lib is in Pascal and use a quit better Interface for usage. Means I implemented Garbarge Collections and Copy on Write demand Feature. And there exists no need for the user to take care of allocation, deallocations or complex and fast algorithms. My goal was it to get a ready to use math library to concentrate your self on the mathematical problem.<br /><br /><br />Follow a small piece of code to create and test RSA keygeneration, encryption and decryption.<br />The variables with type IInteger are the arbitrary numbers. There is no manual deallocations needed and all numbers are allocated on need. If we assign such number to another, we don't copy the full context. Instead it's reference based. Operations that modify such a multireferenced Number made a &quot;Copy on Write demand&quot;, means detects modifications and copy the actual context to a new single used context. Especialy THIS operation get us a easy to controled and fully transparant base to optimze any operation to use &quot;move memory by the way&quot; in these operation. Instead to copy memory on any assignment we copy the memory context inclusive doing the specificaly operation, such as subtraction,addition and so on.<br /><br />The ONLY feature are missed in PASCAL are Operator Overloading such as in C++. By the way I mean that &quot;Operator Overloading&quot; as it is, is only usefull with such a math library :-)<br /><br /><pre><code><br />procedure TestRSA&#40;KeySize&#58; Integer&#41;;<br />var<br />  P,Q,E,D,N,Dp,Dq,U&#58; IInteger; // RSA key param<br />  M,C,X,Y&#58; IInteger;  // RSA en/decryption<br />  S&#58; Integer;<br />begin<br />  repeat<br />    S &#58;= KeySize shr 1;<br />    NRnd&#40;P, S&#41;;<br />    NBit&#40;P, S -2, True&#41;;<br />    NMakePrime&#40;P, &#91;1, 2&#93;&#41;;<br />    S &#58;= KeySize - NSize&#40;P&#41;;<br />    repeat<br />      NRnd&#40;Q, S&#41;;<br />      NBit&#40;Q, S -2, True&#41;;<br />      NMakePrime&#40;Q, &#91;1, 2&#93;&#41;;<br />    until NCmp&#40;P, Q&#41; &lt;&gt; 0;<br />    if NCmp&#40;P, Q&#41; &lt; 0 then NSwp&#40;P, Q&#41;;<br />    NMul&#40;N, P, Q&#41;;<br />  until NSize&#40;N&#41; = KeySize;<br />  NDec&#40;P&#41;;<br />  NDec&#40;Q&#41;;<br />  NLCM&#40;U, P, Q&#41;;       // U = LCM&#40;P -1, Q -1&#41;<br />  repeat<br />    repeat<br />      NRnd&#40;E, NLog2&#40;NSize&#40;N&#41;&#41; * 4&#41;;<br />      NOdd&#40;E, True&#41;;<br />    until NGCD1&#40;E, P&#41; and NGCD1&#40;E, Q&#41;;<br />  until NInvMod&#40;D, E, U&#41; and &#40;NSize&#40;D&#41; &gt;= NSize&#40;E&#41;&#41; and NGCD1&#40;D, N&#41;;<br />  NMod&#40;Dp, D, P&#41;;    // Dp = D mod &#40;P -1&#41;<br />  NMod&#40;Dq, D, Q&#41;;    // Dq = Q mod &#40;Q -1&#41;<br />  NInc&#40;P&#41;;<br />  NInc&#40;Q&#41;;<br />  NInvMod&#40;U, P, Q&#41;;  // U = P^-1 mod Q<br /><br />// Encryption<br />  NSet&#40;M, 'RSA Public Key scheme with DEC', 256&#41;;<br />  NPowMod&#40;C, M, E, N&#41;;<br /><br />// Decryption with CRT<br />  NPowMod&#40;X, C, Dp, P&#41;;<br />  NPowMod&#40;Y, C, Dq, Q&#41;;<br />  NSub&#40;Y, X&#41;;<br />  NMulMod&#40;Y, U, Q&#41;;<br />  NMul&#40;Y, P&#41;;<br />  NAdd&#40;Y, X&#41;;<br />end;<br /></code></pre><br /><br />@BitRAKE: 5 seconds thats realy strange for me !? on a P4  50 Ghz Machine ? My timings are on P4 1.5GHz. Wich Version of Mathematica are used ?<br /><br />Best Regards, Hagen</div>
    <div class="meta">Posted on 2003-11-18 03:19:55 by Hagen</div>
   </div>
   <div class="post" id="post-124661">
    <div class="subject"><a href="#post-124661">Modular Exponentiation...</a></div>
    <div class="body"><div class="quote"><br />@BitRAKE: 5 seconds thats realy strange for me !? on a P4  50 Ghz Machine ? My timings are on P4 1.5GHz. Wich Version of Mathematica are used ?</div>It is version 5, and I'm testing on a 2Ghz XP Barton.<br /><br />I am working on a big integer lib - so far all my algorithms are faster than GMP, but they are specially optimized for XP processors (I'll get an Opteron in a couple months <strong>valy</strong> and start working on optimizing for it).  AMD processors have a faster multiply and faster MMX/FPU than P4.  I haven't done anything with SSE2, yet.<br /><br />For example, I was able to reduce the single limb multiply down to 3 cycles per limb for cached data - fastest possible on XP processors.  AMD says MUL has a latency of 6 cycles.  Not only is the processor doing two MUL's at once, but all other instructions are executed in the latency shadow.  How is this possible when one multiple requires the result of the other!?  This is a 10% improvement over GMP (and it is smaller in code size :)).</div>
    <div class="meta">Posted on 2003-11-18 05:39:37 by bitRAKE</div>
   </div>
   <div class="post" id="post-124664">
    <div class="subject"><a href="#post-124664">Modular Exponentiation...</a></div>
    <div class="body">Wow !<br /><br />Your both libs should improve factoring projects like ECMNet significantly (<a target="_blank" href="http://www.loria.fr/~zimmerma/records/ecmnet.html">http://www.loria.fr/~zimmerma/records/ecmnet.html</a>).<br /><br />In my project (named SumBKZ), I needed: mpn_sub, mpn_add, mpn_mul, mpn_lshift, mpn_rshift and a multiprecision multiplication.<br /><br />If your libs are freely available, I'll be glad to include them in this project !</div>
    <div class="meta">Posted on 2003-11-18 07:07:07 by MCoder</div>
   </div>
   <div class="post" id="post-124804">
    <div class="subject"><a href="#post-124804">Modular Exponentiation...</a></div>
    <div class="body">Hm, Mathematica should than need ~7 seconds on a 1.5GHz P4, thats always better as my code. I can't believe this. Could you try smaller numbers please, as example in range 4096 bit ?? My lib need 600 ms for this.<br /><br /><div class="quote"><br />AMD processors have a faster multiply and faster MMX/FPU than P4. I haven't done anything with SSE2, yet.<br /></div><br /><br />You can assume that SSE2 Code is minimal 2 times faster as plain i486 code.<br /><br />3 cyles per digit/limb is very good. My lib need 6 cycles. Can I see your optimizations ?? You use native i386 code ??<br /><br /><br /><br />@MCoder: sorry my lib is'nt freely available :(<br />Improving ECMNet depends not on best optimized assemblercode. Any small better algorithm thats used is far faster as very good assembler optimization of the currently used algorithms. Thus optimizing the used mathematical algorithms or introducing of distibuted computing would improve far more. Thats my 3 cent meaning, of course :)<br /><br />Best regards, Hagen</div>
    <div class="meta">Posted on 2003-11-19 08:54:08 by Hagen</div>
   </div>
   <div class="post" id="post-125083">
    <div class="subject"><a href="#post-125083">Modular Exponentiation...</a></div>
    <div class="body"><div class="quote"><br />3 cyles per digit/limb is very good. My lib need 6 cycles. Can I see your optimizations ?? You use native i386 code ??</div>I will be forwarding my code for inclusion in GMP, but can post the algorithm here as well.  I have not yet worked to find a useful algorithm in MMX for multi-percision multiply.<pre><code>	OPTION PROLOGUE&#58;NONE<br />	OPTION EPILOGUE&#58;NONE<br /><br />	ALIGN _CODE_ALIGNMENT_<br /><br />; loop range from 2 thru 62<br />;32&#58; 3.0700 cycles per limb &#40;DWORD&#41;<br />mpn_mul_1__k7_04_UNROLL = 32<br /><br />mpn_mul_1__k7_04 PROC USES ebx esi edi, bInt&#58;PTR BIGINT, limb&#58;DWORD, carry&#58;DWORD<br />	pBIGINT	EQU &lt;&#91;esp+4*&#40;4+1&#41;&#93;&gt;<br />	_limb	EQU &lt;&#91;esp+4*&#40;4+2&#41;&#93;&gt;<br />	_carry	EQU &lt;&#91;esp+4*&#40;4+3&#41;&#93;&gt;<br /><br />	push	ebp<br />	push	ebx<br />	push	esi<br />	push	edi<br /><br />	mov	esi, pBIGINT<br />IF 32 EQ mpn_mul_1__k7_04_UNROLL<br />	mov	ecx, mpn_mul_1__k7_04_UNROLL<br />	mov	edi, &#91;esi&#93;.BIGINT.limbs - SIZEOF BIGINT<br />	mov	edx, edi<br />	shr	edi, 5		; divide by 32<br />	and	edx, 1Fh	; remainder<br />ELSE<br />	mov	ecx, mpn_mul_1__k7_04_UNROLL<br />	mov	eax, &#91;esi&#93;.BIGINT.limbs - SIZEOF BIGINT<br />	cdq<br />	div	ecx<br />	mov	edi, eax<br />ENDIF<br /><br />	imul	ecx, edx, -14		; mpn_mul_1__k7_04_LIMB_CODE<br /><br />	mov	eax, &#91;esi&#93;		; &#91;-4*mpn_mul_1__k7_03_UNROLL&#93;<br />	mov	ebp, _limb		; multiplier<br />	mov	ebx, _carry		; carry<br /><br />	; adjust ESI to point at correct block of data to allow greater<br />	; unroll range while still having only a bytes offset&#58;<br />	;	each block can be a maximum of 128 bytes<br />	;<br />	; ESI points at BIGINT&#91;0&#93;, but needs to point at BIGINT&#91;80h - &#40;BIGINT.limbs MOD UNROLL&#41; + UNROLL&#93;<br />	;<br />; ESI = ESI + 4*&#40;UNROLL - &#40;BIGINT.limbs MOD UNROLL&#41;&#41;<br />	sub	edx, 31<br />	shl	edx, 2<br />	add	esi, edx<br /><br />	; jump to complete partial roll first<br />	lea	edx, &#91;ecx&#93;&#91;_2&#93;<br />	xor	ecx, ecx<br />	jmp	edx<br /><br />	ALIGN 16<br /><br />_0&#58;<br />	i=80h - 4*mpn_mul_1__k7_04_UNROLL<br />	WHILE i LT 80h<br />		mul	ebp<br />		add	ebx, eax<br />		IF i EQ 0<br />			BYTE 8Bh, 46h, 00h<br />			mov	&#91;esi&#93;&#91;i&#93;&#91;-4&#93;, ebx<br />		ELSEIF i EQ 4<br />			mov	eax, &#91;esi&#93;&#91;i&#93;<br />			BYTE 89h, 5Eh, 00h<br />		ELSEIF i GT -80h<br />			mov	eax, &#91;esi&#93;&#91;i&#93;<br />			mov	&#91;esi&#93;&#91;i&#93;&#91;-4&#93;, ebx<br />		ELSE ; only byte offsets<br />			.err mpn_mul_1__k7_04_UNROLL too big!<br />		ENDIF<br />		mov	ebx, ecx<br />		adc	ebx, edx<br />	i=i+4<br />	ENDM<br /><br />_2&#58;	dec	edi<br />	lea	esi, &#91;esi + 4*mpn_mul_1__k7_04_UNROLL&#93;<br />	jns	_0<br /><br />	mov	eax, ebx ; return carry<br /><br />	pop	edi<br />	pop	esi<br />	pop	ebx<br />	pop	ebp<br />	retn	4*3<br />mpn_mul_1__k7_04 ENDP</code></pre>I should try a speed test with 16 bytes of code per limb and see if it executes at the same speed, so I can simplify the setup code.<br /><br />...on a side note, I think I might have found a faster MMX string length!  But it's only better for a larger than average string length (256+ maybe, and in the cache).  Long string that we don't know the length of are rarely in the cache. :)<br /><br /><pre><code>R1 = 2^4095 - 5;<br />R2 = 2^4095 - 3;<br />R3 = 2^4095 - 1;<br />Timing&#91;PowerMod&#91;R1, R2, R3&#93;;&#93;</code></pre>{0.36 Second, Null}</div>
    <div class="meta">Posted on 2003-11-22 01:42:06 by bitRAKE</div>
   </div>
   <div class="post" id="post-127398">
    <div class="subject"><a href="#post-127398">Modular Exponentiation...</a></div>
    <div class="body">Hi bitRake<br /><br /><div class="quote"><br />R1 = 2^4095 - 5;<br />R2 = 2^4095 - 3;<br />R3 = 2^4095 - 1;<br />Timing;<br /></div><br /><br />Thats not what I wanted, all numbers are of special form. Now, Mathematica is an interpreter and possible know of this special form, and thus can use a highly specialized version of PowerMod.<br />I need a comparsion with real random choosen numbers in range of 4096 bits.<br /><br />Regards, Hagen</div>
    <div class="meta">Posted on 2003-12-11 10:55:25 by Hagen</div>
   </div>
   <div class="post" id="post-128073">
    <div class="subject"><a href="#post-128073">Modular Exponentiation...</a></div>
    <div class="body">Sorry for my haste.<br /><br />0.437 Second on average, for random numbers of 4096 bits.</div>
    <div class="meta">Posted on 2003-12-16 20:28:09 by bitRAKE</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=15924&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=15924&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="15924" /><input type="number" name="page" min="1" max="2" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=15924&amp;page=2">&gt;</a><a href="../?id=15924&amp;page=2">&raquo;</a></form>  </div>
 </body>
</html>