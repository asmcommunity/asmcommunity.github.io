<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Probably a very noobish question  - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=30011" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=30011">Probably a very noobish question </a></p>
   <div class="post" id="post-211863">
    <div class="subject"><a href="#post-211863">Probably a very noobish question </a></div>
    <div class="body">Hi everybody,<br />just starting to learn assembly and having problems with my hello world program(it won&#039;t assemble in &#039;coff&#039; and won&#039;t link in &#039;bin&#039;) if I could get some help it would be great, the code is bellow.<br /><br /><br /><br /><br />Attempted to assemble under nasm with nasm -f coff -o hello.o hello.asm<br /><br /><pre><code><br />segment .data<br />	msg		db		&quot;Hello World of Assembly language!!!&quot;, 0 ; Create a string to print<br />	<br />segment .text<br />	global _main ;Required for the linker<br />	<br />_main:<br />	mov dx, msg<br />	mov ah, 9<br />	int 21h<br />	mov ah, 4ch<br />	int 21h<br />	leave<br />	ret<br /></code></pre><br /><br />I then used this command to link: gcc hello.o hello.c -o hello.exe<br /><br /><pre><code><br />#include &quot;cdecl.h&quot;<br /><br />int PRE_CDECL _main( void ) POST_CDECL;<br /><br />int main()<br />{<br />&nbsp; return _main();<br />}<br /></code></pre><br /><br />any help you can give me is greatly appreciated<br /><br /><br />Sari</div>
    <div class="meta">Posted on 2010-05-29 18:37:57 by sari</div>
   </div>
   <div class="post" id="post-211867">
    <div class="subject"><a href="#post-211867">Re: Probably a very noobish question </a></div>
    <div class="body">What are you trying to do, Sari? &quot;-f coff&quot;, despite being able to use int 21h, is a 32-bit format. You&#039;d want &quot;mov edx, msg&quot;, not dx. That&#039;ll get it to assemble. There may be an issue with calling your procedure &quot;main&quot; or &quot;_main&quot; - I would suggest calling it &quot;asm_main&quot; or something. That should build and run under DJGPP gcc. My experience has been that the executable will be quite large.<br /><br />&quot;-f bin&quot; is not a linkable format. Shouldn&#039;t need linking, if it&#039;s assembled as a &quot;.com&quot; file.. You would need to add &quot;org 100h&quot; (or org &quot;256&quot; if you don&#039;t like hex). This doesn&#039;t &quot;cause&quot; your program to be loaded at 100h (into whatever segment dos loads it), it merely informs Nasm that it *will* be loaded at 100h (if it&#039;s named &quot;.com&quot;). You will need to specify the output file name: &quot;nasm myprog.asm -o myprog.com&quot; (otherwise Nasm defaults to just &quot;myprog&quot;). That should get your message on screen, but may not be what you want to do...<br /><br />The &quot;leave&quot; and &quot;ret&quot; are redundant - you&#039;ve exited the program at that point, and they won&#039;t be executed. Good thing, because &quot;leave&quot; undoes the effects of &quot;enter&quot;, which you haven&#039;t got.<br /><br />If you&#039;re not running DJGPP, &quot;-f coff&quot; is not what you want. Get back to us, in that case...<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-05-30 02:11:51 by fbkotler</div>
   </div>
   <div class="post" id="post-211874">
    <div class="subject"><a href="#post-211874">Re: Probably a very noobish question </a></div>
    <div class="body">I changed dx to edx and tried it this time it assembles but crashes also, I am learning 32 - bit asm so correct me if I am wrong but &quot;.com&quot; is not an option. Also I don&#039;t have DJGPP I have MinGW32 but I think they are mostly compatible (again correct me if I&#039;m wrong. Also changed _main to _asm_main. </div>
    <div class="meta">Posted on 2010-05-30 22:41:32 by sari</div>
   </div>
   <div class="post" id="post-211876">
    <div class="subject"><a href="#post-211876">Re: Probably a very noobish question </a></div>
    <div class="body"><strong>sari</strong>,<br /><br />For what target are you compiling? DOS services can be used from protected mode if you use DOS extender. Plain console PE will fault on <strong>int 21h</strong>.</div>
    <div class="meta">Posted on 2010-05-31 00:08:41 by baldr</div>
   </div>
   <div class="post" id="post-211879">
    <div class="subject"><a href="#post-211879">Re: Probably a very noobish question </a></div>
    <div class="body">Okay, you&#039;re wrong. :)<br /><br />The two object formats, DJGPP coff (what Nasm calls &quot;-f coff&quot;), and MScoff (what Windows uses, and what Nasm calls &quot;-f win32&quot;), are quite similar. But DJGPP provides a &quot;runtime&quot; with a 32-bit version of int 21h. It is &quot;32-bit extended dos&quot;. Without that, forget int 21h.<br /><br />You&#039;re right that .com is out for 32-bit code. Well, if you start in &quot;real, real mode dos&quot;, you can go into 32-bit mode and code 32 bits... but you don&#039;t want to. :)<br /><br />Lemme see...<br /><br /><pre><code><br />global _main<br />extern _printf<br /><br />section .data<br />&nbsp;  msg db &quot;Hello, Win32!&quot;, 13, 10, 0<br /><br />section .text<br />_main:<br />&nbsp;  enter 0, 0<br />&nbsp;  pusha<br /><br />&nbsp;  push msg<br />&nbsp;  call _printf<br />&nbsp;  add esp, 4<br /><br />&nbsp;  popa<br />&nbsp;  leave<br />&nbsp;  ret<br /></code></pre><br /><br />That&#039;s just off the top of my head, and may have errors. I think it&#039;s close, see what the CPU thinks. :)<br /><br />Assemble that as &quot;nasm -f win32 hello.asm&quot;. That should give you &quot;hello.obj&quot;. Then link it (there&#039;s nothing to &quot;compile&quot;, really, gcc just calls ld for us) with &quot;gcc -o hello.exe hello.obj&quot;. If it complains about not being able to find &quot;_printf&quot;, add &quot;-lc&quot; to the command line, but I don&#039;t think you need it.<br /><br />If that works, you&#039;re on your way! Well, you can call printf, at least. More like a C program than assembly language, but it&#039;s a start...<br /><br />I cut it down to one program - trying to keep it as simple as possible - but you can call your asm program from a C &quot;main&quot; like you were doing. Dr Paul Carter uses this technique - &quot;driver.c&quot; calls &quot;asm_main&quot; in your asm program - to produce a tutorial that can be used on many platforms. He&#039;s got example files for Cygwin, says &quot;might work for MinGW too&quot;. I&#039;ll bet it does, and if it doesn&#039;t, I&#039;ll bet we can get it to work! That might be something to look at...<br /><br />http://www.drpaulcarter.com/pcasm/<br /><br />There&#039;s a post over on the Nasm forum that explains how to cross-compile a file like you&#039;ve got for Linux and Windows. I consulted it to confirm that the command line to MinGW gcc was what I thought. It might interest you, but... on second thought, maybe not too much...<br /><br />http://forum.nasm.us/index.php?topic=810.0<br /><br />If you want to use the Windows APIs directly, rather than letting libc call them for you (which is what happens when you use printf), there&#039;s the NASMX package, here:<br /><br />http://www.asmcommunity.net/projects/nasmx<br /><br />It uses a different linker, but there may be a way to use it with ld from MinGW. Dunno. I used Cygwin briefly (horrid slow thing) when I was running Windows, but never tried MinGW, so I don&#039;t know what it&#039;ll do. I suspect that telling it where to find the libraries is the &quot;trick&quot;. I think I got Cygwin&#039;s ld to work by feeding it Hutch&#039;s MASM32 library...<br /><br />Anyway, see if my attempt above will work for ya, and then see where you want to go from there...<br /><br />Best,<br />Frank<br /><br /><br /></div>
    <div class="meta">Posted on 2010-05-31 00:48:43 by fbkotler</div>
   </div>
   <div class="post" id="post-211885">
    <div class="subject"><a href="#post-211885">Re: Probably a very noobish question </a></div>
    <div class="body">Thanks alot frank that worked perfectly. But a few questions on how that works.<br /><br />First: msg db &quot;Hello, Win32!&quot;, 13, 10, 0<br />I know 13 is the length but what are 10 and 0 for?<br /><br />Second: add esp, 4<br />What are we doing here?</div>
    <div class="meta">Posted on 2010-05-31 19:20:49 by sari</div>
   </div>
   <div class="post" id="post-211886">
    <div class="subject"><a href="#post-211886">Re: Probably a very noobish question </a></div>
    <div class="body"><div class="quote"><br />Thanks alot frank that worked perfectly. But a few questions on how that works.<br /><br />First: msg db &quot;Hello, Win32!&quot;, 13, 10, 0<br />I know 13 is the length but what are 10 and 0 for?<br /><br />Second: add esp, 4<br />What are we doing here?<br /></div><br /><br />13,10, and 0 produce a linefeed.<br /><br /></div>
    <div class="meta">Posted on 2010-05-31 19:54:40 by skywalker</div>
   </div>
   <div class="post" id="post-211887">
    <div class="subject"><a href="#post-211887">Re: Probably a very noobish question </a></div>
    <div class="body">ok so what does add esp, 4 do?</div>
    <div class="meta">Posted on 2010-05-31 21:06:29 by sari</div>
   </div>
   <div class="post" id="post-211889">
    <div class="subject"><a href="#post-211889">Re: Probably a very noobish question </a></div>
    <div class="body"><div class="quote"><br />First: msg db &quot;Hello, Win32!&quot;, 13, 10, 0<br />I know 13 is the length but what are 10 and 0 for?<br /><br />Second: add esp, 4<br />What are we doing here?<br /></div><br /><br />1. 13 is an ASCII code for CR (carriage return), 10 — for LF (line feed), 0 is string terminator (by definition of C strings).<br /><br />2. That&#039;s a part of <strong>cdecl</strong> calling conventions. Called function doesn&#039;t remove its arguments from stack.</div>
    <div class="meta">Posted on 2010-06-01 00:50:02 by baldr</div>
   </div>
   <div class="post" id="post-211891">
    <div class="subject"><a href="#post-211891">Re: Probably a very noobish question </a></div>
    <div class="body">Right.<br /><br />1) I perhaps should have written this as<br /><br /><pre><code><br />%define CR 13 ; or 0xD, if you like<br />%define LF 10 ; or 0xA<br /><br />; perhaps even<br />%define NL CR, LF<br />; or for Linux<br />; %define NL LF<br /><br />msg db &quot;hello&quot;, CR, LF, 0<br /></code></pre><br /><br />I don&#039;t think we actually need both of them, do we? I used both &quot;just to be sure&quot;. We do need the zero - C calls it &quot;NULL&quot;, I guess... or &quot;NUL&quot;? Maybe should have &quot;%define&quot;d that, too...<br /><br />There&#039;s a fairly recent Nasm feature... Nasm will do &quot;\n&quot; (and other Cish stuff), if the string is enclosed in &quot;back apostrophes&quot; or &quot;back ticks&quot;... (under the &#039;~&#039;... on my keyboard)<br /><br /><pre><code><br />msg db `hello\n`, 0<br /></code></pre><br /><br />if you want to do it like that... There are Windows and Linux APIs that require the length to be passed as a parameter, instead of the zero termination, but all(?) C functions and some Win/Lin APIs want it.<br /><br />2) Might be worth discussing the &quot;other&quot; calling convention - &quot;stdcall&quot; - where the callee *does* remove parameters from the stack, since the Windows APIs use it. In fact, it might be worth discussing &quot;the stack&quot; a little, since beginners don&#039;t know about it automatically. The stack is just memory that ss:esp points to. In dos executables, we were expected to declare a stack - &quot;segment stack stack&quot; - or the linker would complain. In 32-bit code, the OS tells *us* where the stack is. We can just start using it.<br /><br />The &quot;obvious&quot; instructions that use the stack are &quot;push&quot; and &quot;pop&quot;. &quot;push xxx&quot; does essentially &quot;sub esp, 4&quot;/&quot;mov , xxx&quot;. &quot;pop xxx&quot; does essentially &quot;mov xxx, &quot;/&quot;add esp, 4&quot;. (where &quot;xxx&quot; can be a register or an &quot;immediate&quot; number, including an address, or contents of memory, &quot;dword &quot; - we have to say &quot;dword&quot; if it&#039;s contents of memory - dunno why, it&#039;s - almost - always a dword...)<br /><br />Less obvious is that the &quot;call&quot; instruction uses the stack. &quot;call foo&quot; essentially pushes the &quot;return address&quot; - the address of the instruction immediately following the call - and jumps to the label &quot;foo:&quot;. When &quot;foo&quot; ends with &quot;ret&quot;, we essentially &quot;pop&quot; the return address off the stack, and jump there. If esp doesn&#039;t point to the return address when &quot;ret&quot; is encountered, we jump off into the tall weeds instead of back where we came from. That&#039;s why it&#039;s important that somebody - calling function (caller) or called function (callee) - &quot;balance&quot; or &quot;clean up&quot; the stack. This need not be done immediately after every function call - it can be &quot;deferred&quot;...<br /><br />I used &quot;enter 0, 0&quot; and &quot;leave&quot;... let me rewrite that with more explicit instructions that do the same thing...<br /><br /><pre><code><br />&nbsp;  push ebp ; save caller&#039;s ebp - they were using it!<br />&nbsp;  mov ebp, esp<br />&nbsp;  pusha<br /><br />&nbsp;  push msg<br />&nbsp;  call _printf<br />&nbsp;  add esp, 4<br /><br />&nbsp;  popa<br />&nbsp;  mov esp, ebp<br />&nbsp;  pop ebp<br />&nbsp;  ret<br /></code></pre><br /><br />As you can see(?), the &quot;mov esp, ebp&quot; would have restored esp to its proper value, even if we hadn&#039;t done it. The &quot;pusha&quot; and &quot;popa&quot; are overkill, too. The calling convention, besides specifying who cleans up stack, specifies that certain registers are preserved - besides ebp (the caller was presumably using it for the same thing we are), ebx, esi, and edi are expected to retain their values across a call. Since we didn&#039;t change any of them (besides ebp), we don&#039;t have to do anything here. &quot;pusha&quot;/&quot;popa&quot; is just a quick and dirty way to cover it. It has the disadvantage that we lose the value in eax. The calling convention specifies that the return value is in eax (or edx:eax or top of FPU stack, depending on return type). Since &quot;main&quot; returns &quot;int&quot;, I really should have had &quot;xor eax, eax&quot; in there. (zero indicates &quot;no error&quot;, generally) Oh, well...<br /><br />The &quot;stdcall&quot; convention is much the same, except that callee cleans up stack. Windows APIs use it. (this is not intended to be working code!)<br /><br /><pre><code><br />_main:<br /><br />&nbsp;  push 0 ; MB_OK<br />&nbsp;  push caption<br />&nbsp;  push string<br />&nbsp;  push 0<br />&nbsp;  call MessageBoxA<br /><br />&nbsp;  ret<br /></code></pre><br /><br />We didn&#039;t have to &quot;add esp, 4 * 4&quot; (I write it that way to indicate 4 parameters at 4 bytes each). The code for MessageBoxA, which we don&#039;t get to see, ends with &quot;ret 16&quot; (or &quot;ret 4 * 4&quot; perhaps), which &quot;removes&quot; the 4 parameters from the stack - same as &quot;add esp, 16&quot; - after fetching the all-important return address from the stack(!).<br /><br />So that&#039;s what the &quot;add esp, 4&quot; is for... doesn&#039;t really need to be there at all... :)<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-06-01 04:06:46 by fbkotler</div>
   </div>
   <div class="post" id="post-211892">
    <div class="subject"><a href="#post-211892">Re: Probably a very noobish question </a></div>
    <div class="body"><div class="quote"><br />I don&#039;t think we actually need both of them, do we? I used both &quot;just to be sure&quot;. We do need the zero - C calls it &quot;NULL&quot;, I guess... or &quot;NUL&quot;? Maybe should have &quot;%define&quot;d that, too...</div><br /><br />Actually we do. I/O library distinguishes text and binary mode files on platforms where <a target="_blank" href="http://en.wikipedia.org/wiki/Newline">newline</a> is not a single LF (as in various Unix flavors). As a consequence, under DOS/Windows that code outputs <strong>&quot;hello&quot;, 13, 13, 10</strong> (<strong>stdout</strong> by default is opened in text mode).<br /><br />NULL often refers to pointer of value 0, NUL is the mnemonic for <a target="_blank" href="http://en.wikipedia.org/wiki/ASCII">ASCII<a target="_blank" href="http://code 0.<br /><br />[quote author=fbkotler link=topic=30011.msg211891#msg211891 date=1275383206"><br />The &quot;obvious&quot; instructions that use the stack are &quot;push&quot; and &quot;pop&quot;. &quot;push xxx&quot; does essentially &quot;sub esp, 4&quot;/&quot;mov , xxx&quot;. &quot;pop xxx&quot; does essentially &quot;mov xxx, &quot;/&quot;add esp, 4&quot;. (where &quot;xxx&quot; can be a register or an &quot;immediate&quot; number, including an address, or contents of memory, &quot;dword &quot; - we have to say &quot;dword&quot; if it&#039;s contents of memory - dunno why, it&#039;s - almost - always a dword...)<br /></div><br /><br />It also should be noted that if <strong>esp</strong> is used in effective address or as a source for <strong>push</strong> / <strong>pop</strong>, the value used in address calculation or as a source is <strong>esp</strong> <em>before</em> the instruction is executed (thus above examples should be written like <strong>mov <em>tmp</em>, <em>xxx</em></strong> / <strong>sub esp, 4</strong> / <strong>mov , <em>tmp</em></strong>). E.g. <strong>push </strong> copies value on the top of the stack, and <strong>pop </strong> discards value just below top of the stack (for those familiar with <a target="_blank" href="http://en.wikipedia.org/wiki/Forth_(programming_language)">Forth] code 0.<br /><br /><div class="quote"><br />The &quot;obvious&quot; instructions that use the stack are &quot;push&quot; and &quot;pop&quot;. &quot;push xxx&quot; does essentially &quot;sub esp, 4&quot;/&quot;mov , xxx&quot;. &quot;pop xxx&quot; does essentially &quot;mov xxx, &quot;/&quot;add esp, 4&quot;. (where &quot;xxx&quot; can be a register or an &quot;immediate&quot; number, including an address, or contents of memory, &quot;dword &quot; - we have to say &quot;dword&quot; if it&#039;s contents of memory - dunno why, it&#039;s - almost - always a dword...)<br /></div><br /><br />It also should be noted that if <strong>esp</strong> is used in effective address or as a source for <strong>push</strong> / <strong>pop</strong>, the value used in address calculation or as a source is <strong>esp</strong> <em>before</em> the instruction is executed (thus above examples should be written like <strong>mov <em>tmp</em>, <em>xxx</em></strong> / <strong>sub esp, 4</strong> / <strong>mov , <em>tmp</em></strong>). E.g. <strong>push </strong> copies value on the top of the stack, and <strong>pop </strong> discards value just below top of the stack (for those familiar with <a target="_blank" href="http://en.wikipedia.org/wiki/Forth_(programming_language)">Forth</a> it&#039;s <strong>DUP</strong> and <strong>NIP</strong> ;)).<br /><br />There is a difference of <strong>push sp</strong> handling in pre-80286 processors, though. They use <strong>sp</strong> value <em>after</em> it was decreased by 2.</div>
    <div class="meta">Posted on 2010-06-01 06:14:14 by baldr</div>
   </div>
   <div class="post" id="post-211893">
    <div class="subject"><a href="#post-211893">Re: Probably a very noobish question </a></div>
    <div class="body"><div class="quote"><br /><div class="quote"><br />First: msg db &quot;Hello, Win32!&quot;, 13, 10, 0<br />I know 13 is the length but what are 10 and 0 for?<br /><br />Second: add esp, 4<br />What are we doing here?<br /></div><br /><br />1. 13 is an ASCII code for CR (carriage return), 10 — for LF (line feed), 0 is string terminator (by definition of C strings).<br /><br />2. That&#039;s a part of <strong>cdecl</strong> calling conventions. Called function doesn&#039;t remove its arguments from stack.<br /></div><br /><br />So that&#039;s how C does that the only time I&#039;ve used cdecl is as a pointer to a function.<br /><br />Frank, <br /><br /><br />Thank you very much for that post It was very informative and I think I understand that now.<br /><br />Could someone show me&nbsp; how would I use the parameters to print out formatted text and scanf too?</div>
    <div class="meta">Posted on 2010-06-01 06:48:23 by sari</div>
   </div>
   <div class="post" id="post-211895">
    <div class="subject"><a href="#post-211895">Re: Probably a very noobish question </a></div>
    <div class="body"><div class="quote"><br />So that&#039;s how C does that the only time I&#039;ve used cdecl is as a pointer to a function.<br /></div><br /><br />Can you rephrase this sentence? English isn&#039;t my native language, I didn&#039;t quite understand what you&#039;ve meant.<br /><br /><div class="quote"><br />Could someone show me&nbsp; how would I use the parameters to print out formatted text and scanf too?<br /></div><br /><br /><a target="_blank" href="http://msdn.microsoft.com/en-us/library/56e442dc(v=VS.71).aspx">MSDN</a>, <a target="_blank" href="http://www.opengroup.org/onlinepubs/009695399/functions/printf.html">POSIX</a> or <a target="_blank" href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1425.pdf">ISO/IEC 9899:201x</a> (.PDF, subchapter 7.20.6) can help. For particular usage you may ask here. ;)</div>
    <div class="meta">Posted on 2010-06-01 08:05:13 by baldr</div>
   </div>
   <div class="post" id="post-211957">
    <div class="subject"><a href="#post-211957">Re: Probably a very noobish question </a></div>
    <div class="body">Yes I can, sorry for the late reply.<br /><br /><br />I simply did not know how C converted that to assembly.<br /><br />The other one means that I want to know how to use scanf in assembly and the parameters for printf.<br /><br /><br />Also just started on paul carters tutorial on PC ASM and decided to try and write a simple program can someone help correct it.<br /><br />Here it is:<br /><br /><br /><pre><code><br />%include &quot;asm_io.inc&quot;<br /><br />segment .data<br />	endl		db 		&quot; &quot;, 13, 10, 0<br />	same		db		&quot;The first name = second name&quot;, 0<br />	diff		db		&quot;They are not equal&quot;, 0<br />	outp1		db		&quot;The first name is: &quot;, 0<br />	outp2		db 		&quot;The second name is: &quot;, 0<br />	name1 		db&nbsp; 	&quot;Keith&quot;, 0<br />	name2 		db 		&quot;Daniel&quot;, 0<br />	<br />segment .text<br />	<br />	global _asm_main<br />	<br />	_asm_main:<br />		<br />		enter 0, 0<br />		pusha<br />		<br />		mov eax, outp1<br />		call print_string<br />		<br />		mov eax, name1<br />		call print_string<br />		<br />		call own<br />		call own<br />		<br />		mov eax, outp2<br />		call print_string<br />		<br />		mov eax, name2<br />		call print_string<br />		<br />		mov ebx, name1<br />		mov eax, name2<br />		cmp ebx, eax<br />		jne not_equal<br />		<br />	equal:<br />		mov eax, same<br />		call print_string<br />		call exit<br />		<br />		<br />	own: ;prints a newline<br />		mov eax, endl<br />		call print_string<br />		<br />	<br />	not_equal:<br />		mov eax, diff<br />		call print_string<br />		call exit<br />		<br />	exit:<br />		popa<br />		mov eax, 0<br />		leave<br />		ret<br />	<br />	<br />	<br />	<br /><br />	<br /><br />	<br />	<br />	<br />	<br />	<br />	<br />	<br />	<br />	<br />;What It&#039;s supposed to do in C.<br /><br />;int main() {<br />;	char szFirstName[25] = &quot;Keith&quot;;<br />;	char szSecondName[25] = &quot;Daniel&quot;;<br />;	<br />;	printf(&quot;The first name is: %s\n&quot;, &amp;szFirstName);<br />;	printf(&quot;The second name is: %s\n&quot;, &amp;szSecondName);<br />;	<br />;	if (!strcmp(szFirstName, szSecondName)) {<br />;		printf(&quot;They are equal\n&quot;);<br />;	} else {<br />;		printf(&quot;Not equal\n&quot;);<br />;	}<br />;<br />;	return 0;<br />;}<br /></code></pre><br /><br />Here is my current output:<br /><br />The first name is: Keith<br />They are not equal<br /><br /><br />Then it crashes.<br /><br />Thanks</div>
    <div class="meta">Posted on 2010-06-04 19:04:01 by sari</div>
   </div>
   <div class="post" id="post-211963">
    <div class="subject"><a href="#post-211963">Re: Probably a very noobish question </a></div>
    <div class="body">The main problem seems to be that you &quot;call own&quot;... but &quot;own&quot; doesn&#039;t return!<br /><br />Put a &quot;ret&quot; at the end of this subroutine, and you&#039;ll get a little farther. There are a couple of good places to put your subroutines - in the middle of your code is not one of them (although it&#039;ll work in this case). I prefer to put &#039;em at the end of my code, after the &quot;exit&quot;. Many programmers put their subroutines first, and leave &quot;main&quot; for dessert :) After &quot;section .text&quot; but before &quot;asm_main&quot; would be good. The idea is that you want this code to execute *only* when it&#039;s called - don&#039;t &quot;fall through&quot; into it (usually).<br /><br />&quot;call exit&quot; is an error, too. The &quot;key&quot; here is that &quot;call&quot; puts the return address on the stack, and &quot;ret&quot; removes it, and goes there. If esp points to something other than the return address when &quot;ret&quot; is executed, we go someplace else instead. This almost never works!<br /><br />I told you something incorrect earlier. I said that the &quot;add esp, 4&quot; wasn&#039;t really neccessary, that &quot;mov esp, ebp&quot; (or &quot;leave&quot;) would &quot;save our asm&quot;. Well, it would have, if we hadn&#039;t altered ebp. We didn&#039;t explicitly alter ebp, but we outsmarted ourselves with &quot;pusha&quot;/&quot;popa&quot;! That&#039;s a &quot;quick and dirty&quot; way to preserve the registers that need to be preserved (ebx, esi, edi) - if we alter them - and a bunch of registers that don&#039;t need to be preserved... including ebp! (ebp *does* need to be preserved, but we did it separately) This would not be a problem if esp had pointed to the same place as it did when we &quot;pusha&quot;ed... but with &quot;call exit&quot;, there&#039;s a return address on the stack that &quot;popa&quot; wasn&#039;t expecting, so all the registers are filled with the wrong values. ebp is the real killer, but... it&#039;s just plain wrong... So just use &quot;jmp exit&quot;, not &quot;call exit&quot;. (and do use &quot;add esp, 4&quot; or whatever is correct)<br /><br />With those problems fixed, I think your code will run to completion, and correctly report that the names are not equal. It will report that they&#039;re not equal even if they are, though. Your comparison routine is comparing the addresses of the two names, and since they&#039;re stored at different addresses, they&#039;ll never be equal! You want to compare the &quot;&quot; of memory... &quot;cmp , &quot; won&#039;t work - we only have one address bus - you&#039;ll have to:<br /><br /><pre><code><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov ebx, name1<br />		mov eax, name2<br />compare_byte:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov cl, <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp , cl<br />		jne not_equal<br /><br />; equal so far, try next byte<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc ebx<br /><br />;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jmp compare_byte<br />; oops, not yet - maybe we&#039;re done?<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp cl, 0 ; zero terminated string, yes?<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jne compare_byte<br />; they are equal...<br /></code></pre><br /><br />The &quot;cmpsb&quot; instruction compares the byte at  with the byte at , and increments both esi and edi. In conjunction with the &quot;rep&quot; prefix (holding the string length), it can be used to code a very short string compare. I think it&#039;s easier to understand the &quot;naive&quot; version, but you might want to try it that way, too...<br /><br />For usage and parameters to printf and scanf... the net must be full of C references... (asm_io.asm might provide examples, too) One thing I&#039;ve found out: printf thinks all floats are doubles, even if it says &quot;%f&quot;! Dunno if this is true of scanf. The parameters to scanf want to be *addresses* of the string, int, float, whatever. K&amp;R says this is &quot;the most common error&quot;! I think this fact may be a little more intuitive in asm, actually. I consider scanf to be an &quot;unruly beast&quot; (and less printable things), and avoid it at all cost. Dr. Carter&#039;s &quot;read_*&quot; functions use it. See his &quot;array1c.c&quot; for an attempt to get it under control. Works okay if the user behaves...<br /><br />In the course of looking at your program, I commented out a couple of &quot;suspicious&quot; instructions, and it segfaulted without printing anything. Seemed to be getting *less* far before it segfaulted. But this was just printf messin&#039; with me. printf does &quot;buffered i/o&quot; (this is a Good Thing) and doesn&#039;t actually print anything until the buffer is flushed. Printing a newline will flush the buffer, as will reading buffered input, as will exiting the program. But if we segfault before printing a newline, nothing at all gets printed. Something to keep in mind if you&#039;re getting &quot;mysterious&quot; results from printf. I never would have known that, without making errors! :)<br /><br />You might want to try fixing the problems in your code one at a time. First, just put a &quot;ret at the end of the &quot;own&quot; routine. Just a matter of &quot;style&quot;, but I really would move it to &quot;first&quot; or &quot;last&quot;, even though it&#039;ll work where it is. Then get rid of the &quot;call exit&quot;. Then tackle the &quot;compare&quot; routine - you might want to make that a subroutine, too...<br /><br />Maybe you can answer a question for me. In your first posted code, you used the &quot;PRE_CDECL and POST_CDECL macros. I&#039;m ASSuming that those simply keep C++ from &quot;decorating&quot; (mutilating) the name. Do you know if that&#039;s correct?<br /><br />Best,<br />Frank<br /><br /><br /></div>
    <div class="meta">Posted on 2010-06-04 23:52:02 by fbkotler</div>
   </div>
   <div class="post" id="post-211964">
    <div class="subject"><a href="#post-211964">Re: Probably a very noobish question </a></div>
    <div class="body">Thank you very much frank that was very informative I&#039;ll post It when I get it to work ;) <br /><br />Not completely sure on the PRE_CDECL I haven&#039;t used them very much before learning assembly but that would make perfect sense I&#039;m sure it adds it&#039;s little decorations to the code maybe try disassembling a piece of code with them and one with out to see the difference. I&#039;ll get back to you on that one. <br /><br />Edit: looks like it may just allow C to prototype it outside of the &#039;.c&#039; file itself.<br /><br />BTW C Seperates floats and doubles with scanf ran into this a couple months back.</div>
    <div class="meta">Posted on 2010-06-05 01:11:20 by sari</div>
   </div>
   <div class="post" id="post-211965">
    <div class="subject"><a href="#post-211965">Re: Probably a very noobish question </a></div>
    <div class="body">Here is the remastered version of our code:<br /><br /><pre><code><br />%include &quot;asm_io.inc&quot;<br /><br />segment .data<br />	endl		db 		&quot; &quot;, 13, 10, 0<br />	same		db		&quot;The first name = second name&quot;, 0<br />	diff		db		&quot;They are not equal&quot;, 0<br />	outp1		db		&quot;The first name is: &quot;, 0<br />	outp2		db 		&quot;The second name is: &quot;, 0<br />	name1 		db&nbsp; 	&quot;Keith&quot;, 0<br />	name2 		db 		&quot;Daniel&quot;, 0<br />	<br />segment .text<br />	<br />	equal:<br />		mov eax, same ;print our &#039;same&#039; string<br />		call print_string<br />		jmp exit<br />	<br />	not_equal:<br />		mov eax, diff ;print our &#039;different&#039; string<br />		call print_string<br />		jmp exit<br />		<br />	newl: ;previously own<br />		mov eax, endl<br />		call print_string<br />		ret<br />		<br />	exit:<br />		popa<br />		mov eax, 0<br />		mov ebx, 0<br />		leave<br />		ret<br />	<br />	<br />	global _asm_main ;Required for linker<br />	<br />	_asm_main: ;Main routine<br />		<br />		enter 0, 0 ; Enter the program<br />		pusha<br />		<br />		mov eax, outp1 ;print out our first name string<br />		call print_string <br />		<br />		mov eax, name1 ;print out our first name<br />		call print_string<br />		<br />		call newl		<br />		call newl<br />		call newl<br />		<br />		mov eax, outp2 ;print our second name string<br />		call print_string<br />		<br />		mov eax, name2 ;print our second name<br />		call print_string<br />		<br />		call newl<br />		call newl<br />		call newl<br />		<br />		mov ebx, name1 ;move then compare our names <br />		mov eax, name2<br />		compare_byte:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov cl, <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp , cl<br />				jne not_equal<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc eax<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc ebx<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp cl, 0 <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jne compare_byte<br /><br />		jmp equal <br /><br />		<br />	<br />	<br />	<br />	<br /><br />	<br /><br />	<br />	<br />	<br />	<br />	<br />	<br />	<br />	<br />	<br />;What It&#039;s supposed to do in C.<br /><br />;int main() {<br />;	char szFirstName[25] = &quot;Keith&quot;;<br />;	char szSecondName[25] = &quot;Daniel&quot;;<br />;	<br />;	printf(&quot;The first name is: %s\n&quot;, &amp;szFirstName);<br />;	printf(&quot;The second name is: %s\n&quot;, &amp;szSecondName);<br />;	<br />;	if (!strcmp(szFirstName, szSecondName)) {<br />;		printf(&quot;They are equal\n&quot;);<br />;	} else {<br />;		printf(&quot;Not equal\n&quot;);<br />;	}<br />;<br />;	return 0;<br />;}<br /></code></pre><br /><br />I think next will be user enters three numbers and I will order them from greatest to least.</div>
    <div class="meta">Posted on 2010-06-05 01:58:50 by sari</div>
   </div>
   <div class="post" id="post-211975">
    <div class="subject"><a href="#post-211975">Re: Probably a very noobish question </a></div>
    <div class="body">Okay, equal, not_equal, and exit aren&#039;t what I&#039;d call subroutines... but it&#039;ll work...<br /><br />Best,<br />Frank<br /><br /></div>
    <div class="meta">Posted on 2010-06-06 12:18:01 by fbkotler</div>
   </div>
  </div>
 </body>
</html>