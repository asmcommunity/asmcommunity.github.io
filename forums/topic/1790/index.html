<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Loading constants (FPU) - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=1790" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=1790">Loading constants (FPU)</a></p>
   <div class="post" id="post-11418">
    <div class="subject"><a href="#post-11418">Loading constants (FPU)</a></div>
    <div class="body">Hi everyone. I was just wondering how to load a constant onto the FPU? For example, I would like to do something equivelent to this....<br /><br />   fld   0.1<br /><br />or how can I multiply by constants...<br /><br />   fmul   31.45<br /><br />Is there a better way than creating a temporary variable and loading it? Thanks for any help.</div>
    <div class="meta">Posted on 2001-11-08 05:32:30 by AlexEiffel</div>
   </div>
   <div class="post" id="post-11431">
    <div class="subject"><a href="#post-11431">Loading constants (FPU)</a></div>
    <div class="body">The only better way is for a couple of pre defined constants<br /><br />fldpi   Load Pi<br />fld1   Load 1.0<br />fldz   Load 0.0<br /><br />Check out the FP help file with Masm32 for the rest of them.<br /><br />I assume however that this isn't much help as you want to load your own constants.</div>
    <div class="meta">Posted on 2001-11-08 09:28:05 by Eóin</div>
   </div>
   <div class="post" id="post-11436">
    <div class="subject"><a href="#post-11436">Loading constants (FPU)</a></div>
    <div class="body">Load the constant from a memory location and then do the operation with the value loaded on the stack.  Guess you could even use a macro to store the constant and load it onto the stack.  I'll work on it when I'm at home later...</div>
    <div class="meta">Posted on 2001-11-08 10:23:38 by bitRAKE</div>
   </div>
   <div class="post" id="post-11440">
    <div class="subject"><a href="#post-11440">Loading constants (FPU)</a></div>
    <div class="body">Heres one possible macro:<br /><br />fldr4 MACRO Val:VARARG<br />LOCAL ddVal<br />.data<br />	ddVal dd Val<br />.code<br />	fld ddVal<br />EndM<br /><br />Usage is simply fldr4 123.456 and  then st(0) = 123.456. Of course you may prefeer to used QWORDs or even TBYTEs for better accuracy.</div>
    <div class="meta">Posted on 2001-11-08 13:00:58 by Eóin</div>
   </div>
   <div class="post" id="post-11441">
    <div class="subject"><a href="#post-11441">Loading constants (FPU)</a></div>
    <div class="body">I was thinking more of an inline macro that so you could just have one line of code that produces two instructions. :)  Something like:<br /><br />fmul fpconst(2.5)<br />fadd st(3),fpconst(2.35813)</div>
    <div class="meta">Posted on 2001-11-08 13:25:42 by bitRAKE</div>
   </div>
   <div class="post" id="post-11446">
    <div class="subject"><a href="#post-11446">Loading constants (FPU)</a></div>
    <div class="body">Surely it would have to generate one entry in the data section and one line of code.<br /><br />And if you could do that it would be incredibly useful.</div>
    <div class="meta">Posted on 2001-11-08 15:06:28 by Eóin</div>
   </div>
   <div class="post" id="post-11457">
    <div class="subject"><a href="#post-11457">Loading constants (FPU)</a></div>
    <div class="body">Hello Alex !<br /><br />Also this is a way to store / use real4-values immediately:<br /><br /><pre><code><br />db	068h		; PUSH imm32<br />dd	aFlt<br /></code></pre><br /><br />But you have to correct the stack-pointer after using this value by <br /><br /><pre><code><br />add	esp, 4<br /></code></pre><br /><br />Greetings, CALEB</div>
    <div class="meta">Posted on 2001-11-08 17:37:20 by Caleb</div>
   </div>
   <div class="post" id="post-11479">
    <div class="subject"><a href="#post-11479">Loading constants (FPU)</a></div>
    <div class="body">Thanks everyone. Hey Caleb, could you explain what your code does please? I don't quite see how it works and what the db   068h means.</div>
    <div class="meta">Posted on 2001-11-09 00:25:26 by AlexEiffel</div>
   </div>
   <div class="post" id="post-11482">
    <div class="subject"><a href="#post-11482">Loading constants (FPU)</a></div>
    <div class="body">Pretty easy :)  only took a couple seconds actually.<pre><code>fpc MACRO val&#58;REQ<br />	LOCAL y<br /><br />	CONST SEGMENT DWORD PUBLIC 'DATA'<br />		y val<br />	CONST ENDS<br /><br />	fld y<br />	EXITM &lt;st&gt;<br />ENDM<br /><br />	fadd st&#40;1&#41;,fpc&#40;REAL4 5.3521&#41;<br />	fadd st&#40;2&#41;,fpc&#40;REAL8 7.3389&#41;<br />	fadd st&#40;3&#41;,fpc&#40;REAL10 1.11255297&#41;</code></pre>It'd be harder, but fun - to make the macro keep track of used constants.  So, as to not duplicate the storage in the data section.  Who cares about program size these days, though. :)  You could create separate macros for REAL4, REAL8, REAL10, of course.  (Thanks, E?in for the code. :))</div>
    <div class="meta">Posted on 2001-11-09 00:57:51 by bitRAKE</div>
   </div>
   <div class="post" id="post-11485">
    <div class="subject"><a href="#post-11485">Loading constants (FPU)</a></div>
    <div class="body">bitRAKE, what do you mean by<br /><br /><div class="quote">So, as to not duplicate the storage in the data section.  Who cares about program size these days, though. </div><br /><br />does your macro set aside memory every time it is called? I'm using this in a timer, so it will be called a few hundred times a second with a simple program.</div>
    <div class="meta">Posted on 2001-11-09 01:17:55 by AlexEiffel</div>
   </div>
   <div class="post" id="post-11523">
    <div class="subject"><a href="#post-11523">Loading constants (FPU)</a></div>
    <div class="body">Hello Alex !<br /><br />The data-byte <strong>db 068h</strong> defines the opcode for <strong>push dword value</strong>, this means that the float-const will be pushed onto the stack. After that you can load it with <strong>fld dword ptr </strong> onto the fpu-stack.<br /><br />Also it is quite usefull if real4-values are demanded by subroutines as parameters.<br /><br />Bye, CALEB</div>
    <div class="meta">Posted on 2001-11-09 16:33:21 by Caleb</div>
   </div>
   <div class="post" id="post-11528">
    <div class="subject"><a href="#post-11528">Loading constants (FPU)</a></div>
    <div class="body">The macro only sets aside space in the DATA segment each time it is used.  For example, if you used the macro twice with the same value, there would be two occurances of that constant in the DATA segment - instead of referencing the same constant.  This is only a personal gripe of mine because HLL's will consolidate duplicate constants within a program, but it is very difficult to do the same in assembler.</div>
    <div class="meta">Posted on 2001-11-09 17:47:08 by bitRAKE</div>
   </div>
   <div class="post" id="post-12312">
    <div class="subject"><a href="#post-12312">Loading constants (FPU)</a></div>
    <div class="body">I create the macro with the feature I mentioned above: not duplicating data in the program.  I've also add a feature where the data defaults to REAL4 type, and intergers can be specified.<pre><code>fpc MACRO val&#58;REQ<br />	LOCAL w,x,y,z<br /><br />	;; split type and value, defaulting to REAL4<br />	z INSTR 1,&lt;&amp;val&gt;,&lt;! &gt;<br />	IF z EQ 0<br />		y TEXTEQU &lt;REAL4&gt;<br />		x TEXTEQU &lt;&amp;val&gt;<br />	ELSE<br />		y TEXTEQU @SubStr&#40;&lt;&amp;val&gt;,1,z-1&#41;	;; Type<br />		x TEXTEQU @SubStr&#40;&lt;&amp;val&gt;,z+1,&#41;	;; Value<br />	ENDIF<br /><br />	;; replace . with _<br />	z INSTR 1,x,&lt;!.&gt;<br />	IF z EQ 0<br />		w TEXTEQU x<br />		x CATSTR x,&lt;.0&gt; ;; prevent error message<br />	ELSE<br />		w CATSTR @SubStr&#40;%x,1,z-1&#41;,&lt;_&gt;,@SubStr&#40;%x,z+1,&#41;<br />	ENDIF<br /><br />	;; figure out global name for constant<br />	z SIZESTR y ;; use last char for size distiction<br />	w CATSTR &lt;__&gt;,w,&lt;r&gt;,@SubStr&#40;%y,z,1&#41;<br /><br />	IF &#40;OPATTR&#40;w&#41;&#41; EQ 0 ;; not defined<br />		CONST SEGMENT<br />			w y x<br />		CONST ENDS<br />	ENDIF<br />	EXITM w<br />ENDM</code></pre>Please, ask questions if anyone has a hard time following what's going on.  This macro is used differently than the ones above to make it more usable. :)  If you have problems using this macro with other macros or certain coding situations, I'd like to fix it - please let me know.  Here are some examples of it's use:<pre><code>fld fpc&#40;20&#41; ; defaults to REAL4 20.0<br />fld fpc&#40;REAL8 2.5&#41;<br />fld fpc&#40;2.5&#41; ; REAL4<br /><br />mcall &#91;g_device&#93;, IDirect3DDevice8_Clear, 0, 0, D3DCLEAR_ZBUFFER, 0, fpc&#40;1&#41;, 0<br />fld fpc&#40;1&#41; ; this uses the same constant used above</code></pre></div>
    <div class="meta">Posted on 2001-11-17 02:58:59 by bitRAKE</div>
   </div>
   <div class="post" id="post-12329">
    <div class="subject"><a href="#post-12329">Fixed Point Math</a></div>
    <div class="body">I am an oldschooler, I admit it, but I noticed not a soul has mentioned Fixed-Point Math, that old heresy that went before we had FPU, and its very simple and very fast in asm.<br /><br />     To put it in moronically simple terms, we are trying to deal with numbers smaller than one, ie fractions.<br />     To store them in an integer-based environment, I will give the modern example here of 16:16 FPM, we simply multiply every number in our equation by a fixed factor, in this case, we will be multiplying by 65536, so that our 32 bit integer representation of a fractional number will be maximum 65535.65535, where the lower 16 bits represent a fraction of 65536, ie one half would be 0.32768, or 00008000 as a dword.<br />     We convert any number we want to use in a math formula into this 16:16 FPM format before we do the math, then we simply divide the answer by our factor to convert it back into regular old integer form. Note the multiplying and dividing is done using binary shift opcodes, SHL and SHR, making it very fast. <br />    The resolution on fractions is 1/65536, or 0.0000152587890625 being the smallest number recordable using this system, and being the incremental resolution of the math. If you expect the answer to fall between that number and 65536, then this may be for you.<br />In the olde dayes of 8-bit machinecode (16-bit addressing), we'd merely use a factor of 256, ie an 8-bit shift, but that didn't give the greatest resolution, fractions of 256... I still use this today on Pentium-based 32-bit machines in preference to FPU for the overall saving in terms of cpu time I can achieve due to remaining loyal to binary math and low-level logic.  :)</div>
    <div class="meta">Posted on 2001-11-17 06:01:10 by Homer</div>
   </div>
   <div class="post" id="post-12370">
    <div class="subject"><a href="#post-12370">Loading constants (FPU)</a></div>
    <div class="body"><strong>EvilHomer2k</strong>, the FPU used to be a lot slower - that isn't the case any more.  Both techniques can be used together even.  Which is especially useful when your trying to interface an API that uses REAL4 numbers.</div>
    <div class="meta">Posted on 2001-11-17 13:13:14 by bitRAKE</div>
   </div>
   <div class="post" id="post-12397">
    <div class="subject"><a href="#post-12397">Loading constants (FPU)</a></div>
    <div class="body">bitRAKE, wonderful MACRO. For work with the FPU its a God send, thank you.<br /><br />However, for use with invoke its not the best solution. A guy called serge coban wrote a couple of MACROs for gl which allowed you to push Real4 and 8 values as immediates:<br /><br /><pre><code>GLfloat		TYPEDEF		REAL4<br />GLclampf	TYPEDEF		REAL4  ; float clamped to &#91;0,1&#93;<br />GLdouble	TYPEDEF		REAL8<br />GLclampd	TYPEDEF		REAL8  ; double clamped to &#91;0,1&#93;<br /><br />gl_fpush MACRO numb<br />LOCAL prmstr,prmlen,x,n<br /> prmstr EQU &lt;numb&gt;<br /> prmlen SIZESTR prmstr<br />IF &#40;prmlen LE 7&#41;<br />  ;; constant or varname<br />  x SUBSTR prmstr,prmlen,1<br />  IFIDNI x,&lt;f&gt;<br />   x SUBSTR prmstr,1,prmlen-1<br />   push 12345678h<br />   ORG $-4<br />   real4 &amp;x<br />  ELSE<br />   push GLfloat ptr prmstr<br />  ENDIF<br />ELSE<br /> x SUBSTR prmstr,1,7<br /> IFIDNI x,&lt;&#40;float&#41;&gt;<br />  x SUBSTR prmstr,8<br />  n=&amp;x<br />  x TEXTEQU %n<br />  x CATSTR x,&lt;.0&gt;<br />  push 12345678h<br />  ORG $-4<br />  real4 &amp;x<br /> ELSE<br />  x SUBSTR prmstr,prmlen,1<br />  IFIDNI x,&lt;f&gt;<br />   x SUBSTR prmstr,1,prmlen-1<br />   push 12345678h<br />   ORG $-4<br />   real4 &amp;x<br />  ELSE<br />   push GLfloat ptr prmstr<br />  ENDIF<br /> ENDIF<br />ENDIF<br />ENDM<br /><br /><br />; version without auto-convertion<br />_gl_fpush MACRO numb<br />LOCAL prmstr,prmlen,x<br /> prmstr EQU &lt;numb&gt;<br /> prmlen SIZESTR prmstr<br /> x SUBSTR prmstr,prmlen,1<br /> IFIDNI x,&lt;f&gt;<br />  x SUBSTR prmstr,1,prmlen-1<br />  push 12345678h<br />  ORG $-4<br />  real4 &amp;x<br /> ELSE<br />  push GLfloat ptr prmstr<br /> ENDIF<br />ENDM<br /><br /><br /><br />; ugly, ugly, ugly... but yet works &#40;from time to time&#41;<br />IF 0 ; this version is more stable, but generated code much more close to insane<br />gl_dpush MACRO numb<br />LOCAL loc1,dat,prmstr,prmlen,x<br /> prmstr EQU &lt;numb&gt;<br /> prmlen SIZESTR prmstr<br /> x SUBSTR prmstr,prmlen,1<br /> IFIDNI x,&lt;f&gt;<br />  x SUBSTR prmstr,1,prmlen-1<br />  jmp loc1<br />   ALIGN DWORD<br />   dat real8 &amp;x<br />  loc1&#58;<br />   push dword ptr dat&#91;4&#93;<br />   push dword ptr dat<br /> ELSE<br />  x CATSTR prmstr,&lt;&#91;4&#93;&gt;<br />  push dword ptr x<br />  push dword ptr prmstr<br /> ENDIF<br />ENDM<br /><br />ELSE<br /><br />gl_dpush MACRO numb<br />LOCAL prmstr,prmlen,x<br /> prmstr EQU &lt;numb&gt;<br /> prmlen SIZESTR prmstr<br /> x SUBSTR prmstr,prmlen,1<br /> IFIDNI x,&lt;f&gt;<br /> x SUBSTR prmstr,1,prmlen-1<br /> real8 &amp;x<br /> db 68h<br /> real8 &amp;x<br /> ORG $-8-1-8<br /> db 8Dh,40h,0 ; lea eax,&#91;eax+0&#93;<br /> db 68h<br /> ORG $+4+1+4<br /> ELSE<br /> x CATSTR prmstr,&lt;&#91;4&#93;&gt;<br /> mov eax,eax<br /> mov ebx,ebx<br /> push dword ptr x<br /> push dword ptr prmstr<br /> ENDIF<br />ENDM<br /><br />ENDIF</code></pre><br />When used as follows you'll see the advantage:<br /><pre><code>gl_fpush 67.7f<br />push fpc&#40;67.7&#41;<br /></code></pre>Produces<br /><pre><code>004010FA 6866668742             push    42876666h<br />004010FF FF3540204000           push    dword ptr &#91;402040h&#93;</code></pre><br />Unfortunatly all is not rosey with these, Following is an instance where normal code produces bizarre results:<pre><code>OpenEye MACRO <br />    gl_dpush 0.0f<br />    gl_dpush 1.0f<br />    gl_dpush 0.0f<br /><br />&#91;COLOR=darkred&#93;	fld Eye.z<br />	fadd Eye.d.z<br />	fstp tdq&#91;/COLOR&#93;<br />    gl_dpush tdq<br />	fld Eye.y<br />	fadd Eye.d.y<br />	fstp tdq<br />    gl_dpush tdq<br />	fld Eye.x<br />	fadd Eye.d.x<br />	fstp tdq<br />    gl_dpush tdq<br /><br />    gl_dpush Eye.z<br />    gl_dpush Eye.y<br />    gl_dpush Eye.x<br /><br />    mov eax, eax<br />    mov ecx, ecx<br />    call gluLookAt<br />ENDM<br /><br />compiles to<br /><br />00403363 8D4000                 lea     eax,&#91;eax&#93;<br />00403366 6800000000             push    0<br />0040336B 6800000000             push    0<br />00403370 8D4000                 lea     eax,&#91;eax&#93;<br />00403373 680000F03F             push    3FF00000h<br />00403378 6800000000             push    0<br />0040337D 8D4000                 lea     eax,&#91;eax&#93;<br />00403380 6800000000             push    0<br />00403385 6800000000             push    0&#91;COLOR=darkred&#93;<br />0040338A DD0510000000           fld     qword ptr &#91;10h&#93;<br />00403390 775A                   ja      loc_004033EC<br />00403392 035540                 add     edx,&#91;ebp+40h&#93;<br />00403395 00D9                   add     cl,bl<br />00403397 1D78554000             sbb     eax,405578h&#91;/COLOR&#93;<br />0040339C 8BC0                   mov     eax,eax<br />0040339E 8BDB                   mov     ebx,ebx<br />004033A0 FF357C554000           push    dword ptr &#91;40557Ch&#93;<br />004033A6 FF3578554000           push    dword ptr &#91;405578h&#93;<br />004033AC DD05A3544000           fld     qword ptr &#91;4054A3h&#93;<br />004033B2 DC05BB544000           fadd    qword ptr &#91;4054BBh&#93;<br />004033B8 D91D78554000           fstp    dword ptr &#91;405578h&#93;<br />004033BE 8BC0                   mov     eax,eax<br />004033C0 8BDB                   mov     ebx,ebx<br />004033C2 FF357C554000           push    dword ptr &#91;40557Ch&#93;<br />004033C8 FF3578554000           push    dword ptr &#91;405578h&#93;<br />004033CE DD059B544000           fld     qword ptr &#91;40549Bh&#93;<br />004033D4 DC05B3544000           fadd    qword ptr &#91;4054B3h&#93;<br />004033DA D91D78554000           fstp    dword ptr &#91;405578h&#93;<br />004033E0 8BC0                   mov     eax,eax<br />004033E2 8BDB                   mov     ebx,ebx<br />004033E4 FF357C554000           push    dword ptr &#91;40557Ch&#93;<br />004033EA FF3578554000           push    dword ptr &#91;405578h&#93;<br />004033F0 8BC0                   mov     eax,eax<br />004033F2 8BDB                   mov     ebx,ebx<br />004033F4 FF35AF544000           push    dword ptr &#91;4054AFh&#93;<br />004033FA FF35AB544000           push    dword ptr &#91;4054ABh&#93;<br />00403400 8BC0                   mov     eax,eax<br />00403402 8BDB                   mov     ebx,ebx<br />00403404 FF35A7544000           push    dword ptr &#91;4054A7h&#93;<br />0040340A FF35A3544000           push    dword ptr &#91;4054A3h&#93;<br />00403410 8BC0                   mov     eax,eax<br />00403412 8BDB                   mov     ebx,ebx<br />00403414 FF359F544000           push    dword ptr &#91;40549Fh&#93;<br />0040341A FF359B544000           push    dword ptr &#91;40549Bh&#93;<br />00403420 8BC0                   mov     eax,eax<br />00403422 8BC9                   mov     ecx,ecx<br />00403424 E877070000             call    fn_00403BA0</code></pre><br /><br />I can't understand why the affected code is after the MACRO. Note that if this code is rearranged i.e. the three initial gl_dpushes are moved to just prior to the last three (the Eye ones) it compiles fine and generates the code you'd expect, sadly than the values are out of order on the stack.<br /><br />Just some bedtime reading :grin:</div>
    <div class="meta">Posted on 2001-11-17 19:08:35 by Eóin</div>
   </div>
   <div class="post" id="post-12401">
    <div class="subject"><a href="#post-12401">Loading constants (FPU)</a></div>
    <div class="body"><strong>E?in</strong>, that error is because of the way <strong>org $-4</strong> is used within the macro to back over code -- this is bad.  I have found that this messes with the internal lists within MASM - mainly code relocation.  Use:<pre><code>db 068h<br />REAL4 val</code></pre>...instead.  Pushing a REAL8 is even worse.  There is no way around this that I know of - this is a limitation of MASM - <em>org</em> is bad to use for this.  If I figure out a solution I'll surely post it.<br /><br />As the FPU can't load immediate data, this macro is mainly for use directly with the FPU instructions.  I'm working on my own version of mcall - it'll have as many features as I can pack in. :)</div>
    <div class="meta">Posted on 2001-11-18 00:35:05 by bitRAKE</div>
   </div>
   <div class="post" id="post-15835">
    <div class="subject"><a href="#post-15835">To bitRAKE</a></div>
    <div class="body"><strong>BitRake</strong><br />The macro that you have posted (fpc) has a bug, it does not work with negative values.<br /><br />Thus:<br /><br />fld fpc(1.0) <br /><br />will work<br /><br />but<br /><br />fld fpc(-2.0)<br /><br />will not.<br /><br />The following is your macro with the correction for negative numbers.<br /><br /><pre><code><br />fpc MACRO val&#58;REQ<br />	LOCAL w,x,y,z,zz,ww<br /><br />	;; split type and value, defaulting to REAL4<br />	z INSTR 1,&lt;&amp;val&gt;,&lt;! &gt;<br />	IF z EQ 0<br />		y TEXTEQU &lt;REAL4&gt;<br />		x TEXTEQU &lt;&amp;val&gt;<br />	ELSE<br />		y TEXTEQU @SubStr&#40;&lt;&amp;val&gt;,1,z-1&#41;	;; Type<br />		x TEXTEQU @SubStr&#40;&lt;&amp;val&gt;,z+1,&#41;	;; Value<br />	ENDIF<br /><br />	;; replace . with _<br />	z INSTR 1,x,&lt;!.&gt;<br />	IF z EQ 0<br />		w TEXTEQU x<br />		x CATSTR x,&lt;.0&gt; ;; prevent error message<br />	ELSE<br />		w CATSTR @SubStr&#40;%x,1,z-1&#41;,&lt;_&gt;,@SubStr&#40;%x,z+1,&#41;<br />	ENDIF<br /><br />	;; replace - with _<br />	zz INSTR 1,w,&lt;!-&gt;<br />	IF zz EQ 0<br />		ww TEXTEQU w<br />	ELSE<br />		ww CATSTR @SubStr&#40;%w,1,zz-1&#41;,&lt;_&gt;,@SubStr&#40;%w,zz+1,&#41;<br />	ENDIF<br /><br />	;; figure out global name for constant<br />	z SIZESTR y ;; use last char for size distiction<br />	ww CATSTR &lt;__&gt;,ww,&lt;r&gt;,@SubStr&#40;%y,z,1&#41;<br /><br />	IF &#40;OPATTR&#40;ww&#41;&#41; EQ 0 ;; not defined<br />		CONST SEGMENT<br />			ww y x<br />		CONST ENDS<br />	ENDIF<br />	EXITM ww<br />ENDM<br /><br /></code></pre> <br /><br />So that a -2.0 becomes ___2_0_<br /><br />PS: I know that it has been a long time since you posted the macro, but I just found the bug today.</div>
    <div class="meta">Posted on 2001-12-22 21:30:03 by dxantos</div>
   </div>
   <div class="post" id="post-15838">
    <div class="subject"><a href="#post-15838">Loading constants (FPU)</a></div>
    <div class="body">Thanks, nice to know someone actually uses these things.  :grin:</div>
    <div class="meta">Posted on 2001-12-22 21:45:28 by bitRAKE</div>
   </div>
   <div class="post" id="post-93513">
    <div class="subject"><a href="#post-93513">Loading constants (FPU)</a></div>
    <div class="body"><div class="quote"><br /><strong>E?in</strong>, that error is because of the way <strong>org $-4</strong> is used within the macro to back over code -- this is bad.  I have found that this messes with the internal lists within MASM - mainly code relocation.  Use:<pre><code>db 068h<br />REAL4 val</code></pre>...instead.  Pushing a REAL8 is even worse.  There is no way around this that I know of - this is a limitation of MASM - <em>org</em> is bad to use for this.  If I figure out a solution I'll surely post it.<br /><br />As the FPU can't load immediate data, this macro is mainly for use directly with the FPU instructions.  I'm working on my own version of mcall - it'll have as many features as I can pack in. :) </div><br /><br />I wander if anyone found solution to push real8?</div>
    <div class="meta">Posted on 2003-04-05 15:10:55 by The Svin</div>
   </div>
  </div>
 </body>
</html>