<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Md5 optimization - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=973" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=973">Md5 optimization</a></p>
   <div class="post" id="post-6295">
    <div class="subject"><a href="#post-6295">Md5 optimization</a></div>
    <div class="body">I am trying to optimize RudeBoy's Md5 implementation.I searched and read several articles and found something to optimize rounds of this functions.<br />In Md5 description they are described as F,G,H,I<br />only F and G can be optimized according to this papers also instead of adding two registers and constant lea will be used.So I tried to change this functions.<br /><br />Md5 defines this functions<br />#define	F(x,y,z)	(((x) &amp; (y))  |  ((~(x)) &amp; (z)))<br />#define	G(x,y,z)	(((x) &amp; (z))  |  ((y) &amp; (~(z))))<br /><br />so in RudeBoy's source.<br />if<br />;	eax = X<br />;	ebx = Y<br />;	edx = Z<br />_MD5Trans1 MACRO<br /><br />;F------------------------<br />	and ebx, eax  ;  Y &amp; X<br />	not eax	      ;  ~X<br />	and eax, edx  ; X &amp; Z	<br />	or eax, ebx   ;  X | Y<br />;---------------------------<br />ENDM<br />_MD5Trans2 MACRO<br />;G--------------------------<br />	and eax, edx	; X &amp; Z<br />	not edx		; ~Z<br />	and ebx, edx	; Y &amp; Z<br />	or eax, ebx	; X | Y<br />;---------------------------<br />ENDM<br /><br />so it can be translated to<br />#define	F(x,y,z)	((((y) ^ (z)) &amp; (x)) ^ (z))<br />#define	G(x,y,z)	((((x) ^ (y)) &amp; (z)) ^ (y))<br /><br />Which is also pointed on SSLeay package <a target="_blank" href="ftp://ftp.psy.uq.oz.au/pub/Crypto/SSL/">ftp://ftp.psy.uq.oz.au/pub/Crypto/SSL/</a> and below articles<br /><a target="_blank" href="http://citeseer.nj.nec.com/bosselaers96fast.html">http://citeseer.nj.nec.com/bosselaers96fast.html</a><br /><a target="_blank" href="http://citeseer.nj.nec.com/bosselaers97even.html">http://citeseer.nj.nec.com/bosselaers97even.html</a><br /><br />so in assembly <br /><pre><code><br />;	eax = X<br />;	ebx = Y<br />;	edx = Z<br />_MD5Trans1 MACRO<br />;F------------------------<br />  xor ebx,edx  ; Y ^ Z   <br />  and ebx,eax  ; Y &amp; X<br />  xor ebx,edx  ; Y ^ Z<br />;-------------------------<br />ENDM<br /><br />_MD5Trans2 MACRO<br />;G------------------------<br />   xor eax,ebx  ; X ^ Y<br />   and eax,edx  ; X &amp; Z<br />   xor eax,ebx  ; X ^ Y<br />;-------------------------<br />ENDM<br /></code></pre><br />Everything seems to correct however.G function works whereas, F function doesnt work.It gives bad result.It only works if I change to<br /><pre><code><br /> xor ebx,edx  ; Y ^ Z<br /> and eax,ebx  ; X &amp; Y<br /> xor eax,edx  ; X ^ Z<br /><br /></code></pre><br />But this does not fit the definition of algo.Also in SSLeay package there is a optimized asm source of MD5(it is ugly formatted and I cant managed to  make it work.Which is like this<br /><pre><code><br />	;R0 first round<br />	xor	edi,		edx   ;  Y ^ Z  <br />	and	edi,		ebx   ;  Y &amp; X          ;this and lea can be exchanged.<br />	lea	eax,		DWORD PTR 3614090360&#91;ebp*1+eax&#93;<br />	mov	ebp,		DWORD PTR 4&#91;esi&#93;<br />	xor	edi,		edx   ;  Y ^ Z<br />	add	eax,		edi<br />	mov	edi,		ebx<br />	rol	eax,		7<br />	add	eax,		ebx<br />        ;first round ends<br /></code></pre><br />it can be changed to<br /><pre><code>								     Cycles      <br />	xor	edi,		edx   ;  Y ^ Z                       paired<br />	lea	eax,		DWORD PTR 3614090360&#91;ebp*1+eax&#93;      1<br />	and	edi,		ebx   ;  Y &amp; X                       paired<br />	mov	ebp,		DWORD PTR 4&#91;esi&#93;		     1	<br />	xor	edi,		edx   ;  Y ^ Z                       paired<br />	add	eax,		edi                                  1<br />	mov	edi,		ebx				     paired<br />	rol	eax,		7                                    1<br />	add	eax,		ebx				     1<br /></code></pre><br /><br />As you see it xors same registers.I have tried to call this proc like this<br /><pre><code><br />invoke MDxInit,addr msum<br />invoke MDxPad,addr myData, 11h, 11h<br />push 11h<br />push offset myData<br />push offset msum<br />call _md5_block_x86 ; it is in SSLeay package.<br /></code></pre><br />It seems to work.However, if I hash continuesly  after 86351 operation it gives stack error.I guess it is related to buffer owerflow.RudeBoy's source can be downloaded from <br /><a target="_blank" href="http://thor.prohosting.com/~win32asm">http://thor.prohosting.com/~win32asm</a><br />Thanks for any response</div>
    <div class="meta">Posted on 2001-09-05 16:51:07 by LaptoniC</div>
   </div>
   <div class="post" id="post-6327">
    <div class="subject"><a href="#post-6327">Md5 optimization</a></div>
    <div class="body">Whats the function <strong>_md5_block_x86</strong>'s calling type?<br />If it is a C function then you need to clean up the stack after the call and this could be why you end up with a stack overflow.<br /><br />86351 * 4 * 3 = almost 1 MB of data (which I think is the default allocation of stack space).<br />That seems like too much of a coincidence to me!<br /><br />As for your other problem, in what way is it a <em>bad</em> result?<br />Where are you expecting your result?<br />In the 'G' macro the result is held in <strong>eax</strong>, in 'F' it should be in <strong>ebx</strong>.<br />I'm sorry if you know this already, but sometimes we miss the obvious :D<br /><br />Mirno</div>
    <div class="meta">Posted on 2001-09-06 05:17:52 by Mirno</div>
   </div>
   <div class="post" id="post-6334">
    <div class="subject"><a href="#post-6334">Md5 optimization</a></div>
    <div class="body">How can I free the stack ?.I dont know much about stack.Original asm source is like this.<br />TITLE	md5-586.asm<br /> .386<br />.model FLAT<br />_TEXT	SEGMENT<br />PUBLIC	_md5_block_x86<br /><br />_md5_block_x86 PROC NEAR<br />..<br />..<br />_md5_block_x86 ENDP<br />_TEXT	ENDS<br />END<br /><br />In the Ssleay source code and articles I saw that they are xoring same registers so this puzzled me.<br />Thanks</div>
    <div class="meta">Posted on 2001-09-06 07:08:18 by LaptoniC</div>
   </div>
   <div class="post" id="post-6341">
    <div class="subject"><a href="#post-6341">Md5 optimization</a></div>
    <div class="body">To check whether it is the stack that is the problem, you need to check the value of <strong>esp</strong> before and after the call (ie before all the pushes, and after the call has executed).<br />If the stack is the problem, then you'll find that <strong>esp</strong> is smaller by 12 after the call. This is because you are pushing 3 dwords (12 bytes).<br />Simply solve this by adding 12 to <strong>esp</strong> as this is what MASM does for you when the calling convention is C (<em>see the MASM generated code listing below for an example</em>)!<br /><pre><code><br /> 00000000                            .code<br /> 00000000                            start&#58;<br />                                         invoke myPROC, 1, 2<br /> 00000000   1   6A 02           *        push   +000000002h<br /> 00000002   1   6A 01           *        push   +000000001h<br /> 00000004   1   E8 0000000A     *        call   myPROC<br /> 00000009   1   83 C4 08        *        add    esp, 000000008h<br /><br />                                         invoke ExitProcess, 0<br /> 0000000C   1   6A 00           *        push   +000000000h<br /> 0000000E   1   E8 00000000 E   *        call   ExitProcess<br /><br /> 00000013                            myPROC PROC C a&#58;DWORD, b&#58;DWORD<br /> 00000013   1   55		*        push   ebp<br /> 00000014   1   8B EC		*        mov    ebp, esp<br /> 00000016   1   8B 45 08                 mov    eax, a<br /> 00000019   2   03 45 0C                 add    eax, b<br />                                         ret<br /> 0000001C   3   C9              *        leave	<br /> 0000001D   2   C3              *        ret    00000h<br /> 0000001E                            myPROC endp<br /><br />                                     end start<br /></code></pre><br /><br />I've also looked at the macro's Rudeboy wrote, they return the value in <strong>eax</strong>. In your speedy macro, the result will be in <strong>ebx</strong>, you can simply solve this by re-ordering the variables in the macro, or change your code so it reads the result from <strong>ebx</strong> instead (both will need a coding change), or simply add:<br /><pre><code>   mov eax, ebx </code></pre><br />to the end of your macro for F.<br /><br />Mirno</div>
    <div class="meta">Posted on 2001-09-06 08:46:22 by Mirno</div>
   </div>
   <div class="post" id="post-6381">
    <div class="subject"><a href="#post-6381">Md5 optimization</a></div>
    <div class="body">Thanks it  worked when I  add add    esp, 000000012 after call.I appreciate your help.Now Md5 is faster :):alright:</div>
    <div class="meta">Posted on 2001-09-06 15:57:10 by LaptoniC</div>
   </div>
  </div>
 </body>
</html>