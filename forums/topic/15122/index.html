<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>HLXClasses - beta release - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=15122" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=38">Object Oriented Programming</a> &raquo; <a href="../?id=15122">HLXClasses - beta release</a></p>
   <div class="post" id="post-117525">
    <div class="subject"><a href="#post-117525">HLXClasses - beta release</a></div>
    <div class="body">Hi all!<br /><br />First of all I must admit, that I'm a little bit confused. I haven't had visited this forum since my motherboard broke down. It took some time to gather and rebuild some of my resources and tools, but it seems, that everything comes back to the normality. Why confused? Well... I started my work on my own implementation of OOP macros a couple of months ago, rewriting the whole set a couple of times. And I visited back the community a few days ago. And what do I see here? A special section related to the OOP. What's more - I see more and more different OOP macros growing like mushrooms in the rain. So it is not the lonely crusade of NaN no more...<br /><br />I've been following the paths designed in C++ (and - partialy - in Delphi), so - this could be the main reason of any similarity to other solutions (regarding the keywords, not the code itself). I hope, that I have managed to provide some additional functionality to the whole asm OOP. Who knows? Anyway - the best and basic source of knowledge was Randall's AoA (thanks to him) and some advices given by my old friends in C++...<br /><br /><strong>Features (mostly these, that I consider as more or less innovative):</strong><br />1) fields of the class are divided to &quot;dynamic&quot; (unique - is it really the best name match?) and static (shared);<br />2) there are four supported method types: &quot;ordinary&quot;, static, virtual and abstract;<br />3) since abstract methods are supported, the abstract classes are supported too;<br />4) abstract method calls are not allowed, however - I've designed a special type of method call, provided just for abstract methods. A pure abstract class (consisting of abstract methods only) is a (more or less) flexible way of handling COM interfaces;<br />5) since method prototypes are always PROTOs, the true body of each method can be defined in any part of code: in a different module, in a separate LIB or even in a DLL (this one has not been tested yet);<br />6) (theoreticaly) unlimited inheritance level<br />7) pure static classes (consisting of static members only) could work as templates for projects (design a static class, build &quot;common&quot; static methods and declare other static methods to be built by the user)<br />8) auto constructor / destructor calls - be warned and expect an extra INVOKE after creation or destruction of an object;<br />9) no &quot;default&quot; constructors / destructors (this one match the Delphi type, not the C++ one)<br />10) polymorphism support<br />11) a simple system of error messages, so the whole set has an average error protection<br /><br /><br /><strong>Things to do, missing features and expected troubles:</strong><br />1) auto chain-call for constructors and destructors of derived classes - since direct constructor / destructor call will not be allowed (to be implemented), this feature is strongly required in case of derived classes (I have already built the scheme in my head, but it hasn't been done yet);<br />2) some minor features like ISCLASS function;<br />3) due to the huge amount of information stored by the compiler, a really extensive use of classes may cause an overflow of global symbol table (proabably? not tested...)<br />4) due to the huge number of local parameters, an extensive use of classes may cause an overflow of local symbol table (local symbol redefinition error) - this one is more proabable and was tested against the size of LST, however - I do not expect to meet such an error in most of cases. Anyway - I'm going to optimize the usage of local parameters, so the problem should be reduced (but not eliminated)<br />5) I still have to write a simple reference :) On the other hand - we don't have such a good forum in Poland, so I will surely write a small set of tutors in Polish. Dunno whether to do it in English also - there's a lot of better sources here and in AoA...<br />6) The whole set shall be only a part (but the most important part) of the full extension called HLX (Higher Level Xtension), which includes other macros, divided into &quot;language&quot; macros ($INVOKE, SWITCH/CASE, RETURN, a.s.o.) and asm macros (like MOVM - provided for moving DWORD operands from MEM to MEM directly)<br />7) I have noticed a strange behavior of the whole set while using STRPTR macro (equal to the known CTEXT), so I was forced to add the location pointer workaround. The methods were simply loosing the last few bytes of code without it - dunno why... I can share an example of this bug, if necessary.<br /><br />Well... The code is a little bit messy in the last part, but it is only a beta version and it hasn't been heavily tested for bugs. I have left the possibility to make a direct call to the constructor and destructor of an object - just because I've not implemented the auto chain-calling for a set of derived classes. If necessary, perform a direct constructor / destructor call from the constructor / destructor of a derived class to the one of parent class. However - it will be done automaticaly in a nearly future.<br /><br />A small sample app (with executable and a commented fragment of disasm) and a quick macro reference included...<br /><br />Hope you'll like it. Regards, Mikael</div>
    <div class="meta">Posted on 2003-09-08 18:13:40 by MikaelC</div>
   </div>
  </div>
 </body>
</html>