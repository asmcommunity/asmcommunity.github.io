<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Very simple string arrays - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=17385" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=3">MAIN</a> &raquo; <a href="../?id=17385">Very simple string arrays</a></p>
   <div class="post" id="post-134616">
    <div class="subject"><a href="#post-134616">Very simple string arrays</a></div>
    <div class="body">There are times when you want an array of strings, either in order or not and don't want a big production like linked lists etc. For example for error code lookups in your program, you would generally have an error number and a message. Given the number you would normally create an array of pointers to strings. This seems a bit much for such a simple task and handling each on an ad-hoc basis is a pain so I came up with this. It is designed to generate error messages so it is not fast nor does it need to be...<br /><br /><pre><code>.data<br />STRINGBLOCK		DB	080h,&quot;String Entry 0&quot;,0<br />			DB	081h,&quot;String Entry 1&quot;,0<br />			DB	082h,&quot;String Entry 2&quot;,0<br />			DB	083h,&quot;String Entry 3&quot;,0<br />			DB	084h,&quot;String Entry 4&quot;,0<br />			DB	085h,&quot;String Entry 5&quot;,0<br />ENDSTRINGBLOCK&#58;<br />			DB	&quot;No entry found&quot;,0<br /><br />LENSTRINGBLOCK		EQU	ENDSTRINGBLOCK-STRINGBLOCK<br /><br />.code<br />GetString FRAME iString<br />	uses edi<br />	mov al,&#91;iString&#93;<br />	add al,080h<br />	mov ecx,LENSTRINGBLOCK<br />	mov edi,OFFSET STRINGBLOCK<br />	repne scasb<br />	mov eax,edi<br />	ret<br />ENDF</code></pre><br /><br />When you want string 0 you simply <strong>invoke GetString,0</strong> and it will return the offset of the first string, zero terminated and ready to copy or display or whatever.<br /><br />The strings are keyed with the index number (beginning at 080h so they don't interfere with content) and the proc just adds 080h to the index and scans for that byte value returning the offset of the character immediately following it. For values that do not exist, the pointer will be one past the end of the array so that points to &quot;No entry found&quot; and will return that. Like I said it is not fast but it is simple and pretty much fool-proof and in the context that it is intended it is more than efficient enough.</div>
    <div class="meta">Posted on 2004-02-23 17:30:30 by donkey</div>
   </div>
   <div class="post" id="post-134632">
    <div class="subject"><a href="#post-134632">Very simple string arrays</a></div>
    <div class="body">mov eax, strings<br />mov ecx, string_number<br />_0: movzx edx, <br />dec ecx<br />lea eax, <br />jns _0<br />sub eax, edx<br />ret<br /><br />strings:<br />DB 8<br />DB &quot;1234567&quot;,0<br />DB 8<br />DB &quot;1234567&quot;,0<br />DB 8<br />DB &quot;1234567&quot;,0<br /><br />A macro could automate string length calculation.</div>
    <div class="meta">Posted on 2004-02-23 20:15:03 by bitRAKE</div>
   </div>
   <div class="post" id="post-134635">
    <div class="subject"><a href="#post-134635">Very simple string arrays</a></div>
    <div class="body">I'm not sure exactly what yours does.<br /><br />You move the offset of the strings into EAX, the first value (I assume the movzx is moving a byte) in EDX would be 8. You then add 1 to it (making 9) then attempt to read that as an address. I would think it would GPF after the first itteration.<br /><br /><br /><br />Shouldn't it be :<br /><br />lea eax, <br /><br />To add the length to the address ?<br /><br />But besides that, mine is meant for error codes and I didn't want to scan in order. I wanted the string found by it's code no matter what order it was in. That way I can just add new errors to the end of the array and not have to worry about sequentially numbering the errors or keeping them in order.<br /><br />For example:<br /><br /><pre><code>STRINGBLOCK		DB	080h,&quot;String Entry 0&quot;,0<br />			DB	081h,&quot;String Entry 1&quot;,0<br />			DB	082h,&quot;String Entry 2&quot;,0<br />			DB	083h,&quot;String Entry 3&quot;,0<br />			DB	084h,&quot;String Entry 4&quot;,0<br />			DB	087h,&quot;String Entry 7&quot;,0</code></pre><br /><br />7 would still give string 7 but 5&amp;6 would remain unfound and give a default message. In my app a neg return value always indicates an error so I just send it straight to the lookups (no +80h). But each type of error has a different high nibble. For example there may only be one error in Cx but 5 in Dx and 3 in Ex etc...</div>
    <div class="meta">Posted on 2004-02-23 20:28:38 by donkey</div>
   </div>
   <div class="post" id="post-134636">
    <div class="subject"><a href="#post-134636">Very simple string arrays</a></div>
    <div class="body">Yeah, I meant LEA EAX,.<br /><br />Okay, I see now how neatly that fits your use. Error codes are usually not time critical.</div>
    <div class="meta">Posted on 2004-02-23 21:22:31 by bitRAKE</div>
   </div>
   <div class="post" id="post-134638">
    <div class="subject"><a href="#post-134638">Very simple string arrays</a></div>
    <div class="body">Yeah,<br /><br />I like yours though and will definitely find it useful. Mine is pretty much specific to looking up things by index that are not time critical but I thought somebody might find a use for my solution to the problem. Like I had said though it is for error messages, I doubt I would use it elsewhere, maybe messageboxes with predefined messages or some other thing where speed was pointless.<br /><br />It is the great advantage of assembly that we can tailor everything to it's specific application and not be herded in to one size fits all type solutions.</div>
    <div class="meta">Posted on 2004-02-23 21:34:04 by donkey</div>
   </div>
   <div class="post" id="post-134643">
    <div class="subject"><a href="#post-134643">Very simple string arrays</a></div>
    <div class="body"><div class="quote"><br />It is the great advantage of assembly that we can tailor everything to it's specific application and not be herded in to one size fits all type solutions.</div>To me, this puts more value in the programmer and stresses the importance of understanding the problem.  Whereas HLLs tend to overstress reuse: devaluing the programmer and moving too quickly to a solution prior to really understanding the problem.  Or maybe I've just known too many bad HLL programmers, and project managers to be objective.<br /><br /><span style="font-size:9px>(we just purchased a very expensive software solution which we lack the hardware to use properly and are finding it almost impossible to get funding for the hardware.  even if we had the money to buy it, we need people to implement the hardware.  they are not my decisions - I just live with consequences. :(  &quot;I alone and afraid, in a world I never made.&quot; - A E Housman )</span></div>
    <div class="meta">Posted on 2004-02-23 22:19:27 by bitRAKE</div>
   </div>
   <div class="post" id="post-134649">
    <div class="subject"><a href="#post-134649">Very simple string arrays</a></div>
    <div class="body">What about the following? IMO it's rather easy to manage. Personally, I would probably choose a pair of String-ID's and string pointers, so I can add/remove strings as I see fit - this also encourages the use of some ID_ERR_* (or whatever name) equates, so 'magic numbers' don't crop up in your code.<br /><br />The scheme could be changed somewhat, for instance with changed logic in the geterror proc, the first table entry could be used to hold amount of string entries (still computed automatically at build-time), so you only have to pass index number and table-start. Or macros could be written for the current routine etc.<br /><br />Error table lookup isn't really a critical task, so you might not want to spend four bytes per string for the table pointers. The idea of 80+string-id is cute enough, but of course limits the amount of strings and excludes non-english OEM charsets :)<br /><br /><pre><code><br />CTEXT MACRO y&#58;VARARG<br />	LOCAL sym<br /><br />	CONST segment<br />		IFIDNI &lt;y&gt;,&lt;&gt;<br />			sym db 0<br />		ELSE<br />			sym db y,0<br />		ENDIF<br />	CONST ends<br /><br />	EXITM &lt;OFFSET sym&gt;<br />ENDM<br /><br />.data<br />errorstrings_s&#58;<br />	dd  0 ; first entry = out-of-bounds value<br />	dd	CTEXT&#40;&quot;Message 1 - you'll never see this&quot;&#41;<br />	dd	CTEXT&#40;&quot;Uh oh, the printer's on fire&quot;&#41;<br />	dd	CTEXT&#40;&quot;Critical Surface Error&quot;&#41;<br />	dd	CTEXT&#40;&quot;Ugh. Stone-age tactics&quot;&#41;<br />errorstrings_e&#58;<br /><br />.code<br />geterror	PROC	idx&#58;dword, tblstart&#58;dword, tblend&#58;dword<br />	mov		eax, &#91;idx&#93;<br />	mov		ecx, &#91;tblend&#93;<br />	mov		edx, &#91;tblstart&#93;<br /><br />	; bounds checking<br />	sub		ecx, edx<br />	cmp		eax, ecx<br />	jl		@@inbounds<br /><br />	; string entry 0 = out-of-bounds value to return<br />	xor		eax, eax<br /><br />@@inbounds&#58;<br />	; return string from table<br />	mov		eax, &#91;edx + eax*4&#93;<br />	ret<br />geterror	ENDP<br /></code></pre></div>
    <div class="meta">Posted on 2004-02-24 00:59:40 by f0dder</div>
   </div>
   <div class="post" id="post-134656">
    <div class="subject"><a href="#post-134656">Very simple string arrays</a></div>
    <div class="body">Donkey,<br /><br />Maybe I have missed something but isn't it simpler to write the array and the set of strings then just access them by the array ?<br /><pre><code><br />    .data<br />      st0 db &quot;string0&quot;,0<br />      st1 db &quot;string1&quot;,0<br />      st2 db &quot;string2&quot;,0<br />      st3 db &quot;string3&quot;,0<br />      st4 db &quot;string4&quot;,0<br />      st5 db &quot;string5&quot;,0<br />      st6 db &quot;string6&quot;,0<br />      st7 db &quot;string7&quot;,0<br />      st8 db &quot;string8&quot;,0<br />      st9 db &quot;string9&quot;,0<br /><br />      sarr dd st0,st1,st2,st3,st4,st5,st6,st7,st8,st9<br /><br />; call proc<br />invoke GetString,4,OFFSET sarr<br />invoke SetWindowText,hWnd,eax<br /><br />; procedure<br />GetString proc num&#58;DWORD,lparray&#58;DWORD<br /><br />    mov edx, num<br />    mov ecx, lparray<br />    mov eax, &#91;ecx+edx*4&#93;<br /><br />    ret<br /><br />GetString endp<br /></code></pre></div>
    <div class="meta">Posted on 2004-02-24 05:25:43 by hutch--</div>
   </div>
   <div class="post" id="post-134657">
    <div class="subject"><a href="#post-134657">Very simple string arrays</a></div>
    <div class="body">Hi Hutch,<br /><br />The idea was to have the ability to skip indexes. I will leave holes in my error codes for future expansion while still remaining in the structure I have laid out. So there may very well be quite a few holes in the array, for example this is a portion of the HTTPUpdate error code equates :<br /><br /><pre><code>/*<br />#################################################<br /> ERROR CODES<br />#################################################<br />90 = Exit code error from main application<br />91 = Main app not responding &#40;timeout&#41;<br /><br />Internet connection codes<br />A0 = InternetOpen failed<br />A1 = URL ping failed<br />A2 = InternetOpenUrl failed<br />A3 = Could not allocate memory<br />A4 = InternetReadFile Failed<br />A5 = zero bytes read<br />A6 = Invalid script format or syntax error<br />A7 = Zero bytes written to file or byte counts don't match<br />A8 = Query file size failed<br /><br />Merge registry error codes<br />B0 = Could not update registry key<br />B1 = Problem in termination of RegEdit.exe<br /><br />Download error codes<br />C0 = CRC did not match<br /><br />D0 = General download error<br />D1 = Could not create temp file<br /><br />Decompression error codes<br />E1 = Z_ERRNO<br />E2 = Z_STREAM_ERROR<br />E3 = Z_DATA_ERROR<br />E4 = Z_MEM_ERROR<br />E5 = Z_BUF_ERROR<br />E6 = Z_VERSION_ERROR<br /><br />F1 = Could not open compressed file<br />F2 = Could not create compressed heap<br />F3 = Could not create uncompressed heap<br />F4 = Could not create ucompressed file<br />*/</code></pre><br /><br />As you can see I needed a solution tailored to the way I like to define my error codes. Each high order nibble is indicative of the procedure that the error occured in.</div>
    <div class="meta">Posted on 2004-02-24 05:38:50 by donkey</div>
   </div>
   <div class="post" id="post-134658">
    <div class="subject"><a href="#post-134658">Very simple string arrays</a></div>
    <div class="body"><div class="quote"><em>Originally posted by bitRAKE</em><br />To me, this puts more value in the programmer and stresses the importance of understanding the problem. Whereas HLLs tend to overstress reuse: devaluing the programmer and moving too quickly to a solution prior to really understanding the problem.</div><br /><br />From my experience this usually happens when people think and code in the wrong order. Of course asm has the advantage here, that it takes so much longer to code stuff that most people inevitably start to think at some point :grin:</div>
    <div class="meta">Posted on 2004-02-24 05:45:09 by Jibz</div>
   </div>
   <div class="post" id="post-134691">
    <div class="subject"><a href="#post-134691">Very simple string arrays</a></div>
    <div class="body">hutch, your sample is basically the same as mine - except of the manual overhead of defining 'sarr' and the lack of bounds checking. Much nicer to use a macro for the string pointer table, this gives the additional benefit that it would be a matter of changing the macro (perhaps with an assemble-time equate) to get UNICODE support, too :)<br /><br />Last time I needed stringtables was for an engineering app a friend and me wrote for a danish company. The app needed to be (and was) localized for at least Danish, English and German - perhaps French, too. In the scale of 'real world' things it was a sorta small application, but I guess a lot of people here would think of it as 'big'. <br /><br />The approach was to parse an ini file with &quot;stringid=string&quot; lines into a binary format - header, pairs of &lt;stringid,format&gt; DWORDs, raw stringdata. Very fast to load, very fast to search... while not really a big deal with a few hundred strings as I think we had, I did implement a binary search just for the heck of it :)<br /><br />The advantage to using resources, was that we didn't have to build any resource DLLs, that it was easy to write a tool to define the strings (we just used notepad though), and that using a string at runtime was a matter of calling the getstring routine with the ID - no need to LoadString into a buffer first.<br /><br />Might be overkill for what you need though, but it was pretty nice and supported whatever OEM character sets we could think of.</div>
    <div class="meta">Posted on 2004-02-24 08:54:25 by f0dder</div>
   </div>
   <div class="post" id="post-134747">
    <div class="subject"><a href="#post-134747">Very simple string arrays</a></div>
    <div class="body">f0dder,<br /><br />The technique you used sounds fine for small counts and any dynamic technique is more flexible in terms of being able to use external files for the data.<br /><br />The bounds check for the code I posted is simple if you ned it, just check the number against the maximum and disallow it if its bigger.<br /><br />For future applications especially where you need multilingual support, probably the OLE string capacity for either ANSI or UNICODE is the most flexible as it uses string handles where the data pairs can comfortably be written to a single string.<br /><br />In an application like the one Donkey has in mind, I would probably allocate a dynamic array, fill it with a default address for each member then add the specific addresses for the strings that have so far been added so you have the capacity to simply add extra data.</div>
    <div class="meta">Posted on 2004-02-24 18:43:38 by hutch--</div>
   </div>
   <div class="post" id="post-134785">
    <div class="subject"><a href="#post-134785">Very simple string arrays</a></div>
    <div class="body">Hutch, the code asm you posted was basically the same as mine - only that I used a macro to automate the generation of the &quot;sarr&quot; table and had bounds checking in the getstring - not really a big deal, I think the macroized approach is a bit cleaner and less work to manage, but whatever :)<br /><br />As for the &quot;getstring library&quot; I described, it's overkill for a lot of situations - but it's pretty beautiful :P<br /><br />It's very convenient to use, you call the getstring routine and it returns a string pointer; no need for loading into a buffer first, as with the WIN32 LoadString.<br /><br />It uses DWORD identifiers, so you can have a lot of strings. The identifiers can be discontiguous, like donkey needs (it's pretty nice when you need to add some error message you hadn't thought of, heh). And since the table is id-sorted at buildtime, binary search can be used for looking up strings. This is pretty fast, and I think the code would scale pretty well even for a <strong>lot</strong> of strings.<br /><br />One of the biggest advantages, as we saw it, is that the string data files are more compact and easier to distribute than string resource DLLs... besides, they're portable :grin: whic might actually matter, as my friend has betrayed windows somewhat in favour of linux (that fool ;)).</div>
    <div class="meta">Posted on 2004-02-25 10:19:16 by f0dder</div>
   </div>
  </div>
 </body>
</html>