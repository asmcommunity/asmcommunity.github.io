<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Opcode #4 Prefixes - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=9062" />
     </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=5">Algorithms &amp; Source Code</a> &raquo; <a href="../?id=9062">Opcode #4 Prefixes</a></p>
   <div class="post" id="post-66561">
    <div class="subject"><a href="#post-66561">Opcode #4 Prefixes</a></div>
    <div class="body">Prefixes.<br /><br />Open testopcode app.<br />Type MNEMONICS<br />	or eax,-1<br />	mov ecx,edx<br />	and ebx,ebp<br />Insert OPCODE below typed commands<br />Do it this way<br />	first byte 66<br />	then type opcode of or eax,-1 <br />	that you can see in the place where you insert or eax,-1 menemonic<br />	press Enter move cursor to nearest NOP<br />And create the same way 2 opcodes build with<br />66 + opcode of the rest to commands.<br /><br />As you can see instruction that were generated that way<br />plactically identical to first 3 mnemonics except they<br />work with 16 registers.<br />	or ax,-1<br />	mov cx,dx<br />	and bx,bp<br /><br />66 is prefix.<br />Prefixes are first logical block in order of those<br />blocks that used to generate opcode.<br />Let's refresh our memory on those blocks and their order:<br />1. Prefixes<br />2. Code<br />3. byte mod r/m<br />4. byte sib<br />5. offset in command<br />6. imm. operand.<br />Remember also that not necesserelly all blocks are used in particular opcode<br />but any opcode has CODE block and order of other blocks is never changed.<br /><br />Prefixes block is the easiest to understand, though it is unique in many hences.<br />1. It is the only block that may occur BEFORE code block.<br />2. Any prefix has 1 byte size.<br />3. There maybe several prefixes in one opcode.<br /><br />Let us illustrate (3.)<br />Before it we look closely to prefix 66.<br />This prefix is &quot;change default size of operand&quot;<br />There might be only two &quot;Default sizes of oprand&quot;<br />16 bit and 32 bit.<br />In Win32 programming default size of operand is 32 bit.<br />When instruction may be used either with 16 or 32 bit operands<br />it is coded absolutly identically for both cases, the only difference<br />is if there is prefix 66 leading opcode.<br />Let see example were operand size is not seen as argument in opcode<br />but actually might be different size.<br />TYPE mnemomics with 1 opcode byte:<br />	LODSB<br />	LODSW<br />	LODSD<br />Huh!<br />LODSW and LODSD have the same opcode. It is actually the same instruction<br />but LODSW uses word (which is NOT DEFAULT OPERAND SIZE in Win32)<br />and LODSD uses dword (which IS DEFAULT OPERAND SIZE in Win32)<br />So in this case we need to specify prefix 66h before opcode <br />and let us remember that specifying it we are NOT saying preocessor<br />&quot;use WORD as operand&quot;<br />we are saying<br />&quot;use operand size OPPOSIT to DEFAULT&quot;<br />if DEFAULT is DWORD processor seeing 66h uses WORD<br />elseif DEFAULT is WORD processor seeing 66h uses DWORD<br />Kinda trigger.<br />Opcodes that are using other than word\dword operands (bytes,qwords, etc.)<br />coded the same with any of current DEFAULT operand size.<br /><br />TYPE MNEMONIC<br />	mov al,0ff<br />	mov al,cl<br />Look at opcodes<br />INSERT OPCODE below those two instructions<br />using opcode of them with leading 66 prefix.<br />    66:B0 FF       MOV AL,0FF<br />    66:8AC1        MOV AL,CL<br />as you can see nothing has been changed in memomonics.<br /><br />Keeping in mind that we can use 66 prefix only with words and dwords<br />we may assume that in case with opcode that is using bytes as operands<br />we placed 66 prefix in inapprepriate place.<br />And probably we've created illegal opcode?<br />Well, not exactly.<br />Run the code<br />    66:B0 FF       MOV AL,0FF<br />    66:8AC1        MOV AL,CL<br /><br />As you can see nothing bad has happened.<br />It worked the same way as it does with<br /><br />   B0 FF          MOV AL,0FF<br />   8AC1           MOV AL,CL<br /><br />So next thing we can understand is:<br />If prefix that processor met can not be applyed to following opcode,<br />it is ignored.<br />Let's test it with next funny example.<br />Other type of prefix is rep prefix, prefix that is used<br />to make processor repid following it instruction ecx(cx) times.<br />opcode for inc eax is 40h<br />let's try to use prefix F3 (rep) to make this instruction repid 3 times.<br />If you have td32.exe this example is easier to run in it.<br />Open testopcode app in td32.exe<br />type in it<br />	xor eax,eax<br />	mov ecx,3<br />	rep inc eax<br />then run it.<br />You can see two thigs<br />1. Value in eax = 1. It means that prefix F3 didn't work and was ignored.<br />2. Nothing bad happend. No exeptions etc.<br />In OllyDbg you will have two problems<br />1. If you type inside it mnemonic<br />	rep inc eax<br />It would tell you &quot;unrecognized command&quot;.<br />But you are super lowlevelmachine coder. Aren't you? :)<br />It can't stop you anymore. 'Cause instead of <br />rep inc eax<br />you can insert opcode<br />	F3 40<br />OllyDbg  still doesn't recognize it.<br />If you use F8 to step trough typed code, you will have a problem on<br />the F3 40 opcode. Try it.<br />But you can check it other way.<br />Set brake point somewere below (for example on 3rd nop after inserted <br />instructions)<br />To set brakepoint: dblclick on line where you want to place it.<br />Address part of line should become red.<br />(to remove it dblclick on it again. It works like a trigger)<br />Then use F9 (run) to make processor run through line where you placed<br />F3 40 opcode.<br />You can see the same results.<br />1. eax =1<br />2. nothing bad has happend, processor just ignored 66 prefix that was<br />placed before unappropriate opcode.<br /><br />IF PREFIX CANNOT NOT BE USED WITH OPCODE IT LEADS THE PREFIX IS IGNORED.<br />Type mnemonic that need to be spefied with 2 prefixes<br />	REP LODSW<br />66:F3:AD       REP LODS <br /><br />You can see 2 prefixes here 66 (change default operand size) and F3 (rep)<br />Next note then:<br />ONE INSTRUCTION CAN HAVE SEVERAL PREFIXES.<br />It's another unique thing about this 1st block - prefixes.<br />Any opcode may have only one CODE block, one mod r/m, offset etc.<br />But may have several prefixes.<br /><br />Now final note about prefix 66h.<br />You may wrongly assume that when you in real mode default size of operand<br />is WORD, and when you are in protected mode it's DWORD.<br />Not quite so.<br />The only thing you can remember for sure: when you code Win32 programm<br />DEFAULT size is DWORD.<br />So with any instruction that you use in you Win32 app operating words you<br />are creating opcodes that 1 byte bigger (on prefix 66) and takes 1 more clock<br />to execute. It's not always bad, but you need get used to calculation of math<br />model of your opcode size generation and approximated speed calculation to<br />see if it's worthy to use words here. Any instruction with words will cost you<br />1 more byte and 1 more clock to decode prefix.<br />As to how default size is specified - it's spesified by bit D in segment <br />descriptor. In real mode it always assumed 0. So in real mode DEFAULT size<br />is always WORD indeed. In protect mode bit D might be 0 or 1 (in Win32 apps<br />it's 1).<br />SO<br />	if (PROTECTED MODE &amp;&amp; BIT D==1)<br />	AD = LODSD<br />	66 AD = LODSW<br />	else<br />	AD = LODSW<br />	66 AD = LODSD<br />So we know from previous tutorials that<br />some different opcodes may have the same name(mnemonic)<br />one opcode may have several names(mnemonics)<br />Now we see type of opcode wich may mean 2 different things depending on<br />some conditions.<br />Regarding opcodes that can be used with 66 prefix, you can see those<br />conditions and meanings above.<br /><br />Next time we'll continue to learn about 1st logical block of OPCODE - prefixes.<br />Meanwhile I ask to recommend readers reference manuals on instruction set<br />for x86, where all mnemonics described with opcode. And not just with opcodes<br />but with opcodes structurized in its logical parts - blocks.<br /><br />I have many manuals, but none of them even close to be perfect to meet the <br />conditions above (including Intel manuals).<br />As work manual I have one reference paper book by russian author V.Yurov<br />but still it has lots of errors so it havilly corrected by me, <br />and we are continuesly discussing those errors with the author by email,<br />he promisses to fix them but when it will happen nobody knows.<br />The rest reference I have are even worse. I'll try to fix this reference problem<br />in my book but I have no idea when it'll be finished.<br />Untill that time please recommend readers some manual with opcode reference<br />wich is at least the best among existing.<br /><br />Learning other then prefix blocks need to be done with that kind of reference.<br />Opcode structurized in blocks.</div>
    <div class="meta">Posted on 2002-11-20 04:20:54 by The Svin</div>
   </div>
  </div>
 </body>
</html>