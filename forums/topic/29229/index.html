<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Better, Faster, Stronger Physics 2009 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29229" />
    <link rel="next" href="../?id=29229&amp;page=2" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29229">Better, Faster, Stronger Physics 2009</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29229&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29229&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29229" /><input type="number" name="page" min="1" max="7" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29229&amp;page=2">&gt;</a><a href="../?id=29229&amp;page=7">&raquo;</a></form>   <div class="post" id="post-206430">
    <div class="subject"><a href="#post-206430">Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I&#039;ve decided to revisit my old Physics code.<br />This time I&#039;ll be disregarding the old framework for arbitrary geometries, at first.<br />I want to concentrate on the most simple geometry (sphere), and I want to look deeper into things I barely touched apon, such as arbitrary contraints.<br /><br />The major difference in the framework will be the very clear distinction between a collision body, and a dynamic body.<br /><br />A collision body is a 3D geometry which supports detection of collisions. It has a shape, it supports velocity, but not mass, and has no way to RESPOND to a collision. An example of this : missiles that explode apon contact.<br /><br />A dynamic body is a derivation of the collision body - it does everything a collision body does, but it has mass, and it can respond to a collision. Do I have to give examples? Look around you.<br /><br />The new engine will handle both of these, in context.<br /><br />Stand by for my first code... especially if all the stuff I posted in the past made no sense to you!<br /></div>
    <div class="meta">Posted on 2008-12-09 02:49:36 by Homer</div>
   </div>
   <div class="post" id="post-206433">
    <div class="subject"><a href="#post-206433">Some notes about collision detection</a></div>
    <div class="body"><br />I still really like the idea of using Spheres to perform the &#039;broad phase&#039; collision testing.<br />The Bullet physics engine uses &#039;axially aligned bounding boxes&#039; (aabb&#039;s) for this, and I think its a bad idea. Why?<br />Rotating objects need to have their aabb calculated for every frame, and worse than that...<br />If we need to search within the current timestep for the moment of impact, the aabb of a rotating object will be constantly changing, and need to be calculated once for each moment of time at which we apply an instantaneous test for intersection... this means extracting eight constantly changing vertices, and performing a series of point/plane tests, whereas a sphere is just a single test.<br /><br />Spheres don&#039;t change shape, and can be used in a &#039;swept test&#039; to quickly determine whether a sphere is remotely likely to collide with something during the current timestep, and if so, can tell us the time at which a sphere will make &#039;first contact&#039; - ie, the moment of impact. <br />If the object is in fact NOT a sphere (ie, is merely using a sphere to perform rough testing), we can then search the timestep using the actual geometry, and beginning at the sphere impact time (rather than the beginning of the timestep), potentially speeding up that search by several orders.<br /><br />It&#039;s also worth noting that the swept sphere test will work for objects moving at high velocity, whereas the more expensive aabb test can fail to detect high-speed collisions, and that means things that are moving fast can potentially fly straight through walls and each other, which really doesn&#039;t look very professional.<br />If we detect a sphere collision, we will often still need to perform some secondary testing using a better geometric approximation, which we call &#039;narrow phase&#039; collision detection - but we would always need to do this for anything that is not actually sphere shaped.<br /><br />Although I won&#039;t be implementing any other geometries at first, it&#039;s nice to know that the Sphere code is useful for GENERAL broad-phase collision testing of ARBITRARY geometries... we can write a single broadphase collision detector, and a geometry-specific narrow phase detector to find the exact moment of impact.<br /><br />Basically, we want to create a list of pairs of objects which will collide during the timestep, figure out which collision is going to occur first, wind the simulation forward to that time, resolve that collision, search the list for any other mentions of those two bodies and re-evaluate those collisions, then find the next earliest collision in the list and repeat this until the list is exhausted. We&#039;re probably still not at the end of the current timestep, but thats ok, we can continue simulating from the most advanced moment of impact we could find.<br /><br /><br /></div>
    <div class="meta">Posted on 2008-12-09 21:51:31 by Homer</div>
   </div>
   <div class="post" id="post-206434">
    <div class="subject"><a href="#post-206434">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">You can find references to &#039;sphere sweep test&#039; on Google, if you are interested, but if we forget about the math for a moment, what we&#039;re really doing is &#039;extruding&#039; two Spheres in the direction of their velocities, creating two &#039;capsules&#039; (cylinders with half-spheres on the end caps), and checking whether they intersect (I like to imagine them as Light Sabers clashing in the darkness).<br />Although the spheres may not be moving linearly (most things move in curves), for the duration of a single timestep we can consider the motion to be linear, and so we can use a linear equation to solve the problem.<br />Mathematically, we can express the problem as a Quadratic Equation, which is a linear equation.<br /><br />Anyway, enough about this, the basic elements we need to get a small demo together are just these:<br />- CollisionBody class, describing the most simple collidable object.<br />- Simulator class, which contains and drives the simulated objects, and knows about Time.<br /><br />In the next few posts I&#039;ll describe these classes, using as little code as possible.<br />We can add stuff to them later, when we require it.<br />But I&#039;d like to walk through the building of a physics engine from the ground up, so I&#039;ll try hard not to jump ahead too much.<br /><br /></div>
    <div class="meta">Posted on 2008-12-10 02:02:50 by Homer</div>
   </div>
   <div class="post" id="post-206435">
    <div class="subject"><a href="#post-206435">From little things, big things grow</a></div>
    <div class="body">The most important data type we&#039;ll use in physics is called a 3D Vector.<br />You might imagine this as a three dimensional arrow - it points in one direction, and it has a length - but we can also use a Vec3 to describe things like &#039;Position in World space&#039;, which isn&#039;t so obviously a &#039;pointing&#039; thing, but if I said &#039;draw an arrow from the origin of the universe to a given point in space&#039;, we can see that position can also be thought of in terms of an arrow.<br /><br />We&#039;ll define a 3D Vector using a structure like this:<br /><br />Vec3 struct<br /> X real4 ?<br /> Y real4 ?<br /> Z real4 ?<br />Vec3 ends<br /><br />We can see that the Vec3 struct describes three floating-point values, which define its direction and magnitude.<br />In this case, I&#039;ve defined the three fields as 32-bit values, but that decision is arbitrary, they could be 64-bit (real8), or any other size, depending on the accuracy that you require.<br />If you can&#039;t understand what a Vec3 is, then you have absolutely no chance of understanding this thread, so I would suggest that you try to figure out what the heck this thing is NOW, before blundering onwards.<br /><br />In order to simulate the physical state of a set of collidable bodies, we&#039;re going to need to describe the physical state of a SINGLE body ... in fact, we need to define TWO physics states for each body - the &#039;current&#039; state, and the &#039;next&#039; state (ie, the state NOW, and the state after some time has passed).<br />So let&#039;s define the most simple Physical State using another structure:<br /><br />;This struct describes the minimal physical State for collision checking.<br />;Note that this describes a physical body &#039;without mass&#039;,<br />;although &#039;CM&#039; refers to the Center of Mass of the object, which is ASSUMED to be its Origin.<br />state struct<br />&nbsp; &nbsp; CMPosition Vec3 &lt;&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Position in world space<br />&nbsp; &nbsp; CMVelocity Vec3 &lt;&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Rate of change of Position<br />&nbsp; &nbsp; Orientation Mat33 &lt;&gt;&nbsp; &nbsp; &nbsp; &nbsp; ;rotation matrix, bodyspace to worldspace<br />&nbsp; &nbsp; CMAngVel&nbsp; &nbsp;Vec3 &lt;&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Rate of change of orientation<br />state ends<br /><br />Can we make sense of this?<br />Position is pretty obvious and doesn&#039;t require explaining.<br />(Linear) Velocity can be thought of as &#039;speed and direction&#039; - it describes which direction the object is moving in, and at what rate. It&#039;s important to know that velocity describes the RATE OF CHANGE OF POSITION... to find the &quot;new position&quot;, we&#039;ll multiply the velocity by some amount of Time, and then add the &quot;old position&quot;.<br />Orientation is described as a 3x3 matrix, which is just one way that we can describe rotation. Other people have other ideas about which is the &#039;best&#039; way to do this, but this is the one I&#039;m using.<br />ANGULAR Velocity describes the RATE OF CHANGE OF ORIENTATION - its telling us how fast the object is spinning, and around which 3D axis. I won&#039;t be going too deeply into the Rotation side of things for a while, so don&#039;t panic too much, but what the heck is a Mat33?<br /><br />Mat33 struct<br />m00 real4 ?<br />m01 real4 ?<br />m02 real4 ?<br />m10 real4 ?<br />m11 real4 ?<br />m12 real4 ?<br />m20 real4 ?<br />m21 real4 ?<br />m22 real4 ?<br />Mat33 ends<br /><br />DirectX uses &#039;row major order&#039;, and OpenGL uses &#039;column major order&#039;.<br />Since I mainly work with DirectX, I&#039;ll stick to that format..<br />A 3x3 matrix, in &#039;row major order&#039;, looks like this:<br /><br />m00 m01 m02<br />m10 m11 m12<br />m20 m21 m22<br /><br />We could think of it as three Vec3&#039;s (m00 m01 m02) (m10 m11 m12) (m20 m21 m22)<br /><br />Again, its not really important to us yet, so lets leave it alone... ok, just one more thing to say about Mat33, THEN we&#039;ll leave it alone (for now)..<br />If we fill the matrix so that the diagonal from top left to bottom right contains ONE, and the rest contains ZERO, its called an IDENTITY MATRIX - and this means &quot;no change&quot; - for a Mat33, being used to describe a rotation, it means &quot;no rotation&quot;... the Identity Matrix for a 3x3 matrix would be:<br /><br />1.0&nbsp;  0&nbsp;  0<br />0&nbsp; &nbsp; 1.0&nbsp; 0<br />0&nbsp; &nbsp;  0&nbsp; 1.0<br /><br /><br />Now we have described the most important data elements that we&#039;ll use in physics simulation, we can go on to describe the basic collidable body... we already know that it needs two States, but there&#039;s a few other things it will need too, in my next post we can take a good look at that, then we can begin looking at the simulator.<br /><br /></div>
    <div class="meta">Posted on 2008-12-10 03:01:57 by Homer</div>
   </div>
   <div class="post" id="post-206440">
    <div class="subject"><a href="#post-206440">CollisionBody</a></div>
    <div class="body">Here&#039;s an early version of the CollisionBody class.<br />This class describes a 3D geometric object that supports collision detection, but not collision resolution - we can tell when one of these smacks into something, but we can&#039;t make it bounce off. Later I&#039;ll introduce a new class derived from this one that DOES support collision response.<br /><br />We can see the two State structs that I mentioned, and a few other data members.<br />Since I am going to start with the most simple 3D geometric primitive (sphere), there is a field to define the Radius of a sphere. <br />dShapeID is used to determine what geometric shape the body is, so later we can define more shapes.<br />IsAwake is a boolean which we can use to put bodies to sleep when they are no longer moving, we can do less computations for sleeping bodies.<br />m44_BodyToWorld is a 4x4 transformation matrix, similar to the Mat33 we saw previously<br />We can combine a rotation and a translation in a single Mat44, and use it to draw our 3D object correctly when we get around to that (I mean, 3D stuff is not much fun if you can&#039;t see it on the screen, is it?)<br />We&#039;ll learn about the Mat44 later, when we need to.<br /><br />Now on to the Methods of this Class.<br />The Init method sets the shape id, and doesn&#039;t do much else.<br />CreateSphere is used to initialize the object as a Sphere.<br />BroadSweep is used to perform broadphase collision detection of &#039;this&#039; object with another object.<br />It will use some kind of Sweep algorithm, such as &#039;sphere/sphere sweep&#039;, depending on what kind of objects we are dealing with.<br />Get_Closing_And_Relative_Velocities does what it says.. these values are required for sweep tests.<br />The Closing Velocity is the speed two objects have, relative to each other, as a single floating point value.<br />That means it doesn&#039;t have a direction as such, although its Sign tells us if the objects are approaching one another or moving apart from one another.<br />Relative Velocity is a Vec3, it tells us the actual direction of the closing velocity, as taken from one object with respect to the other.<br />Don&#039;t worry if these concepts sound alien, you can find much better descriptions of them at your leisure.<br />For now, we just need to know that they are useful for performing sweep tests.<br /><br />I won&#039;t be providing code for any of these Methods today, I think it&#039;s better that I show the two most important class definitions first, then start providing code. So here is the CollisionBody class, and next post will contain the Simulator class. Please note that these classes are not complete, and will be subject to change as we need more stuff it will be added.<br /><br />;The CollisionBody class describes a collidable object.<br />;It has linear and angular velocity (3D speed and spin), but has NO Mass-related properties, <br />;and cannot RESOLVE collisions, only DETECT them.<br />Object CollisionBody, 82124, Shape<br />&nbsp; &nbsp; RedefineMethod Init, Pointer, dword<br />&nbsp; &nbsp; VirtualMethod&nbsp; CreateSphere, Pointer, real4, real4, BOOL<br />&nbsp; &nbsp; VirtualMethod&nbsp; BroadSweep,Pointer<br />&nbsp; &nbsp; VirtualMethod&nbsp; Get_Closing_And_Relative_Velocities, Pointer<br /><br />;Physical State<br />&nbsp; &nbsp; DefineVariable OldState, state, {&lt;&gt;}			&nbsp; ;physical state, with no &#039;Mass&#039; stuff<br />&nbsp; &nbsp; DefineVariable NewState, state, {&lt;&gt;}<br /><br />&nbsp; &nbsp; DefineVariable fRadius, real4, 0.0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;BoundingSphere Radius<br />&nbsp; &nbsp; DefineVariable dShapeID, dword, SHAPEID_UNDEFINED&nbsp;  ;describes the shape of the 3D geometry<br />&nbsp; &nbsp; DefineVariable IsAwake,BOOL,FALSE			&nbsp; ;Sleeping objects cannot &#039;cause&#039; a collision<br />&nbsp; &nbsp; DefineVariable m44_BodyToWorld, Mat44, {&lt;&gt;}	&nbsp; ;rotation &amp; translation (no scaling or shear)<br /><br />ObjectEnd<br /><br /></div>
    <div class="meta">Posted on 2008-12-11 01:23:03 by Homer</div>
   </div>
   <div class="post" id="post-206441">
    <div class="subject"><a href="#post-206441">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Here&#039;s a very rough class definition for the Simulator.<br />The most important thing to note is the embedded collection to hold arbitrary bodies.<br />This class does not merely DRIVE the simulated bodies, it CONTAINS them - it&#039;s a container.<br /><br />We can see that the simulator supports Gravity and Damping.<br />I think we all know what Gravity is - well, I hope so!<br />Damping is a mechanism for removing energy from moving bodies.<br />It&#039;s a way to guarantee that bodies will eventually settle down and stop moving, in the absence of external forces acting on them.<br />As with the CollisionBody class, we can expect this class to grow and change.. this is merely a stripped-down version of my old physics simulator class, I&#039;ve removed things like &#039;springs&#039; from it, because I intend to support a much wider variety of &#039;constraints&#039; than I had previously.<br /><br />I won&#039;t talk more about the methods in this object at this time, as I would be skipping too far ahead for some people, but we&#039;ll get to that as soon as we&#039;ve looked at the CollisionBody methods in more detail.<br />Once we&#039;ve outlined the methods for both object classes, we will be ready to put together a very rough demo - the first demo won&#039;t have any 3D rendering code, it will just emit text messages to let us see that values are changing over time. If the output looks sane, we&#039;ll put together a graphical demo so we can see things on the screen.<br /><br />Object PhysicsSimulator, 83453, Streamable<br /><br />&nbsp; &nbsp; RedefineMethod Init,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  Pointer, real4<br />&nbsp; &nbsp; RedefineMethod Done<br />&nbsp; &nbsp; VirtualMethod ToggleGravity<br />&nbsp; &nbsp; VirtualMethod ToggleDamping<br />&nbsp; &nbsp; VirtualMethod Update,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; real8<br />&nbsp; &nbsp; VirtualMethod ComputeForces<br />&nbsp; &nbsp; VirtualMethod Simulate,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; real8&nbsp; &nbsp; <br />&nbsp; &nbsp; VirtualMethod Integrate,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; real8<br />&nbsp; &nbsp; VirtualMethod CheckCollisions,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; real8<br />&nbsp; &nbsp; VirtualMethod FindExactCollisionTime,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Pointer, Pointer, real8, real8, Pointer<br /><br />&nbsp; &nbsp; DefineVariable DampingActive,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BOOL,TRUE&nbsp; &nbsp; <br />&nbsp; &nbsp; DefineVariable GravityActive,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BOOL,TRUE<br /><br />&nbsp; &nbsp; Embed Bodies,&nbsp; &nbsp; &nbsp; &nbsp;  Collection<br /><br />ObjectEnd<br /><br />I think 60 views of this thread in three days is encouraging (given the number of hits this site receives per day), obviously this is a popular topic, and I hope I can make this information as easy to understand as possible - physics people tend to write for other physics people, keeping this stuff close to their chest, and making it seem much more complicated than it really is. I think that there is something of a superiority complex amongst many of them, they treat this field as a private club, and I think that is deplorable and despicable, and ultimately, it is self destructive as it isolates them from the rest of us, it marginalizes them, and that is the road to obscurity and thus oblivion. Science is not just for scientists, physics is not just for physicists, computers are not just for programmers - we all live in the same reality, we are all subject to its laws.<br /><br /></div>
    <div class="meta">Posted on 2008-12-11 02:40:23 by Homer</div>
   </div>
   <div class="post" id="post-206442">
    <div class="subject"><a href="#post-206442">Integrating the Position with Time</a></div>
    <div class="body">Physics does not need to be hard.<br />Let&#039;s ignore rotation for now, and just think about linear velocity and position.<br /><br />The simulation depends very much apon Time, and the most simple physics simulators divide time into relatively small &#039;timesteps&#039;, for example one tenth of a second (0.1 seconds).<br />The main job of the simulator is to advance the state of the simulated bodies.<br />Given the &#039;old&#039; state of a body, and the elapsed amount of Time, we can calculate the &#039;new&#039; state of a body.<br /><br />The most simple formula in physics is used to move our body in linear space according to its linear velocity.<br />Given that V = linear velocity, and T = the elapsed Time, and P = the position of the body, we can calculate the change of position as follows:<br /><br />dP = V * T ... the change in position equals velocity multiplied by elapsed time.<br /><br />To find the new Position, we need to take the old Position into account...<br />newP = dP + oldP<br /><br />Calculating the new state from the old state with respect to Time is called &quot;Integration&quot; (and also, &quot;numerical integration&quot;).<br />The above formula gives us enough knowledge to write a very simple &quot;integrator&quot; method for our simulator that can make our simulated bodies move linearly - this formula describes &quot;Euler Integration&quot; after the man who invented it.<br />As mentioned previously, most things really move in curves, not linearly, and so there are many improved algorithms based on Euler&#039;s work, most notably &quot;RK4&quot; (Runge Kutta fourth order numerical integration).<br />Sounds complex, but it&#039;s actually not difficult to implement, I&#039;ll show you how at a later date.<br /><br />Anyway, I think we have enough to write a very, very simple Integration method for our simulator which will change the positions of the bodies according to their velocity. <br />I know that I&#039;m jumping the gun a little bit here, but it&#039;s very important to understand how to turn those nasty physics formulas into working code - the implementation of a concept!<br />Stand by for the code for this most important method, we&#039;ll get something that we can compile as soon as possible, and then build on that.<br /></div>
    <div class="meta">Posted on 2008-12-11 05:51:30 by Homer</div>
   </div>
   <div class="post" id="post-206446">
    <div class="subject"><a href="#post-206446">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body"><div class="quote">obviously this is a popular topic</div><br />Yup, it is ^^<br /><br />I wonder if you&#039;ve seen <a target="_blank" href="http://developer.nvidia.com/object/physx_downloads.html">Nvidia&#039;s PhysX</a> and would like to hear your opinion on this one, if possible? Nvidia claims that PhysX enables super-accurate physics simulation with minimal coding effort and they advertise it by showing how it uses hardware acceleration on &quot;GeForce 200&quot;-series cards. Is this really our future or kinda worthless crap given that the modern CPUs don&#039;t have anythig to do, because GFX cards handle like 95% of the rendering process..?</div>
    <div class="meta">Posted on 2008-12-11 11:25:14 by ti_mo_n</div>
   </div>
   <div class="post" id="post-206449">
    <div class="subject"><a href="#post-206449">Re: PhysX</a></div>
    <div class="body">I&#039;ve had a bit of a play around with PhysX - and let me tell you, unless you are running a physics accelerator in hardware, it&#039;s utter garbage.<br />The only thing that makes it remotely appealing to developers is that it is easily portable across a number of popular platforms.<br /><br />Basically, PhysX (in software) is so slow that you are quite limited in the number of objects that can be simulated - in order to hide this inadequacy, the demos that ship with PhysX just have objects disappearing when a certain count (a couple of hundred) is reached - even when simulating something as simple as spheres with a dozen or so collision surfaces to bounce and roll apon. Simply having objects disappearing is quite alarming to me, where did they go? What happened to them? This completely destroys any suspension of disbelief - I would rather see objects &#039;glitching&#039; than simply ceasing to exist !!<br /><br />Further confirmation of the low quality of this engine can be found in the list of games (and game developers) who currently support it... my, what an obscure bunch, have never heard of most of them, with the notable exception of Atari, who for all intents and purposes (at least in terms of game development) are DECEASED (their Melbourne, Australia office, whom they acquired as part of their acquisition of long-term game developer Melbourne House, and which was their worldwide headquarters for gamedev, is now registered to Infogrames).<br />PhysX just simply is not fast enough for anything but lightweight applications, I&#039;m sure it will appeal to some developers, but no &#039;serious&#039; developer would use this engine.<br /><br />Believe me, in terms of a purely software solution, the Bullet engine is miles (and miles) ahead, is several orders faster (and supports MANY more objects), is open-sourced, has attracted a whole bunch of contributing authors from around the world, and is free for commercial use (PhysX requires a license for commercial purposes).<br />In fact, Walt Disney Studios have just used Bullet in their new movie, and have posted their Bullet plugin for Maya on the Bullet forum (which already had its own physics engine that is too slow and not very feature rich).<br />I think that is a glowing recommendation for using Bullet.<br /><br />Having said all of that, Bullet is far from efficient due to its determination to be all things to all users... in my opinion, it&#039;s a little bit over-engineered in that pretty printing and proper structure are given priority over its purported goal of sheer speed and believability. This is probably a little unfair of me, since I am really judging C++ against ObjAsm32, where we can introduce a lot of cheats and shortcuts (such as directly accessing the data elements of an object rather than using lots of &#039;Get&#039; and &#039;Set&#039; methods). But the bottom line is this: even though Bullet is well-regarded as one of the fastest and most robust engines around, it&#039;s easily possible to improve its speed by several orders.<br /><br />Ultimately my biggest complaint against Bullet is that it is poorly documented, and contains barely any useful comments - you&#039;re forced to trawl through the web forum in order to understand any part of its internals.<br />It&#039;s not really aimed at people who wish to understand physics simulation and implement their own - it doesn&#039;t teach anything useful, it&#039;s &#039;prug and pray&#039; code for lazy developers who must then whine on the forum about why things don&#039;t work the way they expected, and hope they get a response that makes sense, even though they don&#039;t have the fundamental knowledge or understanding to modify the code for themselves.<br /><br /></div>
    <div class="meta">Posted on 2008-12-12 00:31:29 by Homer</div>
   </div>
   <div class="post" id="post-206450">
    <div class="subject"><a href="#post-206450">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Time to start putting this baby together... today we&#039;ll be working on the PhysicsSimulator class methods.<br />I&#039;m going to disregard the Init method (aka constructor method) for the moment, as its quite boring.<br />Instead, let&#039;s start by looking at the method which we call from our main program loop in order to drive the simulator. For now, all code will be stripped down, so we won&#039;t worry about collisions or anything else, just the nuts and bolts.<br /><br />In our main loop, we obtain the elapsed time, using the high performance timer.<br />Then we call the Update method, which advances the simulation in discrete timesteps.<br />The Update method calls the Simulate method once for each discrete timestep.<br />This means that the physics might be updated several times for each rendered frame.<br />For example, if 302 ms have elapsed, and the timestep is set to 100ms (0.1 seconds), then the Update method will call the Simulate method three times, and add the remaining 2ms to an internal accumulator.<br /><br />;Advances the physics simulation by one TimeStep for each TimeStep that has elapsed.<br />;This method decouples rendering from physics in regards to Time.<br />;Your application should call this from its main loop, <br />;it&#039;s your entrypoint to drive the simulation.<br />Method PhysicsSimulator.Update,uses esi,deltaTime:real8<br />&nbsp; &nbsp; SetObject esi<br />&nbsp; &nbsp; .if .Bodies.dCount==0<br />&nbsp; &nbsp; &nbsp; &nbsp; ExitMethod<br />&nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; ;Accumulator = Accumulator + deltaTime<br />&nbsp; &nbsp; fld&nbsp; deltaTime&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Add the deltaTime to the Accumulator<br />&nbsp; &nbsp; fadd PhysicsTimeAccumulator<br />&nbsp; &nbsp; fstp PhysicsTimeAccumulator<br />&nbsp; &nbsp; .repeat<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; fld&nbsp;  PhysicsTimeAccumulator&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; fsub&nbsp; PhysicsTimeStep<br />&nbsp; &nbsp; &nbsp; &nbsp; fstpReg eax<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax!=0 &amp;&amp; eax!=80000000h<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .ifBitSet eax,BIT31&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;accumulator &lt; timestep&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;DbgWarning &quot;not time yet&quot;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .break&nbsp; &nbsp; ;Do nothing, its not time yet<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; OCall Simulate&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Advance the simulation by one TimeStep&nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; fchs&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;counter = counter - consumed<br />&nbsp; &nbsp; &nbsp; &nbsp; fadd PhysicsTimeAccumulator<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp PhysicsTimeAccumulator<br /><br />&nbsp; &nbsp; .until 0<br /><br />MethodEnd<br /><br />The Simulate method does a few things.<br />#1 - it calculates the current &#039;internal forces&#039; of all bodies.<br />#2 - it calculates the &#039;new&#039; state of all bodies b<br />#3 - (disabled) check for and resolve all Collisions<br />#4 - switches the &#039;old&#039; and &#039;new&#039; states of all bodies.<br /><br />;This method will attempt to advance the simulation by DeltaTime.<br />Method PhysicsSimulator.Simulate,uses esi<br />&nbsp; &nbsp; SetObject esi<br /><br />&nbsp; &nbsp; ;calculate Force and Torque (due to current linear momentum, and gravity)<br />&nbsp; &nbsp; OCall ComputeForces<br /><br />&nbsp; &nbsp; ;Integrate our system forward<br />&nbsp; &nbsp; OCall Integrate, PhysicsTimeStep<br /><br />&nbsp; &nbsp; ;Here&#039;s where we would perform collision detection and resolution<br />&nbsp; &nbsp; ;....<br /><br />&nbsp; &nbsp; ;Swap the States<br />&nbsp; &nbsp; OCall SwapStates<br /><br />MethodEnd<br /><br />Now we&#039;ve seen the two functions which drive our simulation, we just need a little bit of code for the new methods that have been mentioned, and we can build a very primitive simulator - it won&#039;t do much except advance the simulation, and move bodies linearly according to their velocity.<br />So a couple more posts and we&#039;ll have enough to build our first test program :)<br /></div>
    <div class="meta">Posted on 2008-12-12 03:13:38 by Homer</div>
   </div>
   <div class="post" id="post-206453">
    <div class="subject"><a href="#post-206453">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Just a little remark: if you use a decent compiler infrastructure, get* and set* methods should be inlined, giving effectively the same speed as directly accessing the data. With a system that supports link-time code generation, it works even when the getters and setters are defined at .cpp scope instead of the header file.<br /><br />Other than that, I&#039;m just lurking, and looking forward to a demo simulation I can play with ^_^</div>
    <div class="meta">Posted on 2008-12-12 06:05:11 by f0dder</div>
   </div>
   <div class="post" id="post-206454">
    <div class="subject"><a href="#post-206454">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Biterider has, at my request, implemented &#039;inline methods&#039; in OA32, so I can write those ugly Get and Set methods and not pay for them... but I still prefer just simple directly accessing the data, the inline methods are only to make things easier on the casual reader. Although they appear to be &#039;real methods&#039;, they compile as inline code... pretty much as you described.</div>
    <div class="meta">Posted on 2008-12-12 06:33:18 by Homer</div>
   </div>
   <div class="post" id="post-206455">
    <div class="subject"><a href="#post-206455">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">For a lot of stuff getters and setters are sorta irrelevant anyway, apart from &quot;it&#039;s good programming style&quot;. I still do prefer using them though, since they can offer nice debugging hooks, can ensure invariants are satisfied, make it easier to add caching if necessary, etc. And since simple getters/setters get optimized into simple data access, there isn&#039;t much reason not to use them :)<br /><br />If we look aside from the software implementation and focus only on the hardware acceleration, how well does PhysX do? Significantly faster than software-only solutions? My GF8800 should supposedly support HW PhysX acceleration, but all the recent nvidia drivers cause BSOD on startup on my system, so I can&#039;t play around &gt;_&lt;</div>
    <div class="meta">Posted on 2008-12-12 06:43:58 by f0dder</div>
   </div>
   <div class="post" id="post-206456">
    <div class="subject"><a href="#post-206456">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I have an 8800 card too - this card does not sport a physics coprocessor, no - the claim is that much of the physics math can be offloaded onto the gpu, which is true - but this is at the cost of visual effects (shaders suffer), and that&#039;s really not much of a tradeoff.<br />Please note that the GF8800 is &#039;CUDA-friendly&#039; - and that CUDA is just nvidia&#039;s proprietary version of GPGPU.<br />Even with gpu assisted processing, the PhysX engine is not that great... perhaps they should evaluate their algorithms rather than trying to offload the processing work onto the graphics processor?<br />It would be better if the physics engine supported some kind of load-balancing, where the workload was processed on the device which was least busy at the time..<br />Unfortunately, I can&#039;t tell you how well PhysX does on cards that DO support a true physics coprocessor, but I can say that has very little to do with the PhysX engine anyway!</div>
    <div class="meta">Posted on 2008-12-12 07:23:11 by Homer</div>
   </div>
   <div class="post" id="post-206473">
    <div class="subject"><a href="#post-206473">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I&#039;m beginning to suspect that some (if not most) of the list of game developers using PhysX are startup companies which are indirectly owned by nvidia - this is just an exercise in self promotion, where are the benchmarks? They benchmark everything else. I think the demos that they ship with it tell the real story.<br /></div>
    <div class="meta">Posted on 2008-12-12 22:35:45 by Homer</div>
   </div>
   <div class="post" id="post-206477">
    <div class="subject"><a href="#post-206477">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body"><div class="quote">I have an 8800 card too - this card does not sport a physics coprocessor, no</div>AFAIK none of the GeForce cards have PPUs, but execute physics code on the GPU. Again, AFAIK, it&#039;s only supported on the 8xxx series and upwards since that&#039;s the first GPU that&#039;s generic (and powerful) enough to support it?<br /><br /><div class="quote">Even with gpu assisted processing, the PhysX engine is not that great... perhaps they should evaluate their algorithms rather than trying to offload the processing work onto the graphics processor?</div>If it isn&#039;t all that fast, that would probably be an idea :)<br /><br /><div class="quote">It would be better if the physics engine supported some kind of load-balancing, where the workload was processed on the device which was least busy at the time..</div>I wonder how well that would work? A GPU is supposed to be orders of magnitudes faster at stuff like physics processing than a standard CPU?<br /><br /><div class="quote">Unfortunately, I can&#039;t tell you how well PhysX does on cards that DO support a true physics coprocessor, but I can say that has very little to do with the PhysX engine anyway!</div>The PhysX PPU was discontinued after nvidia bought up the company, and I haven&#039;t heard anything about integrating a discrete PPU on their graphics cards?</div>
    <div class="meta">Posted on 2008-12-13 07:49:19 by f0dder</div>
   </div>
   <div class="post" id="post-206486">
    <div class="subject"><a href="#post-206486">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I just found some benchmarks on the 9600gt and upwards... 3 to 4 times faster than the cpu - considering that gpu operations can be easily coded to be 4x parallel, this is no suprise at all.... I mentioned in another thread that the gpu can be used to accelerate many kinds of conventional processing through parallel operation, and I was told I was an idiot... there you go.<br />Still, that assumes that we don&#039;t want to use the gpu for the purpose for which it was intended!<br /></div>
    <div class="meta">Posted on 2008-12-13 11:38:48 by Homer</div>
   </div>
   <div class="post" id="post-206490">
    <div class="subject"><a href="#post-206490">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">GPUs are still not fast enough to draw almost-movie-quality stuff onscreen, they are high-latency, and PC drivers+interfaces(GL/DX) add too much overhead. Few have SLI, so a multicore solution sounds nicer to me :). <br />That said, I have only a GF8600GT+ C2D E4600 and the physx-nvidia demos running at 15fps were not charming. </div>
    <div class="meta">Posted on 2008-12-13 13:08:07 by Ultrano</div>
   </div>
   <div class="post" id="post-206497">
    <div class="subject"><a href="#post-206497">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">In order to write our physics simulator, we&#039;ll need some building blocks.<br />I&#039;ve said that the most common data that we&#039;ll work with is in the form of 3D vectors.<br />Attached is a small set of macros for performing vector math operations using FPU code and real4 accuracy.<br />This file contains the most important / common math ops, but there will be others that we&#039;ll require, and so this file will be extended as we need them.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2690" target="_blank">Vector3.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2008-12-13 20:49:03 by Homer</div>
   </div>
   <div class="post" id="post-206498">
    <div class="subject"><a href="#post-206498">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Here&#039;s our earliest testbed project - it includes the maths, collisionbody and simulator.<br />The application doesn&#039;t really do anything, but it compiles, and all the code for linear motion is in place.<br />Hey, it&#039;s a start :)<br /><br />Please study the code provided, and ask any questions that you feel need to be asked at this time.<br />Also, note that MASM and ObjAsm32 are both REQUIRED to build this project - and the RadASM IDE is RECOMMENDED - but you can still study the code even if you don&#039;t have these.<br /><br />As I keep saying, all these files are subject to change, and updates will be made available as I continue this work.<br />If you have suggestions, or notice any lurking bugs, or you feel like writing MMX versions of the math functions, please let me know in this thread!!</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2691" target="_blank">PhysicsTestBed.rar</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2008-12-13 22:21:33 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29229&amp;page=1" style="visibility:hidden;">&laquo;</a><a href="../?id=29229&amp;page=0" style="visibility:hidden;">&lt;</a><input type="hidden" name="id" value="29229" /><input type="number" name="page" min="1" max="7" step="1" value="1" onchange="this.form.submit();" /><a href="../?id=29229&amp;page=2">&gt;</a><a href="../?id=29229&amp;page=7">&raquo;</a></form>  </div>
 </body>
</html>