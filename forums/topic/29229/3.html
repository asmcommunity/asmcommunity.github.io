<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Better, Faster, Stronger Physics 2009 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29229" />
  <link rel="prev" href="../?id=29229&amp;page=2" />  <link rel="next" href="../?id=29229&amp;page=4" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29229">Better, Faster, Stronger Physics 2009</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29229&amp;page=1" style="">&laquo;</a><a href="../?id=29229&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="29229" /><input type="number" name="page" min="1" max="7" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=29229&amp;page=4">&gt;</a><a href="../?id=29229&amp;page=7">&raquo;</a></form>   <div class="post" id="post-206559">
    <div class="subject"><a href="#post-206559">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body"><br />At this point, we have calculated a Vec3 representing the linear velocity of the collision point on Body A in Contact space.<br />If there&#039;s a Body B&nbsp; in this collision, repeat for the other body, and subtract the resulting Vec3 (for Body B) from the result we have for Body A.<br />Let&#039;s call this vector &#039;the relative closing velocity of the collision point(s) in Contact Space&#039;.<br />We should immediately check the sign of the X axis of this vector - if its Positive, then the collision is a fake - the body(s) move AWAY from penetration !! Let&#039;s assume we have a Negative closing velocity - if we don&#039;t resolve this collision, we shall see a penetration occur... we better do something!<br /><br />Next, we calculate (in WorldSpace) the linear velocity due only to acceleration of each Body, and only in the direction of the Collision Normal.<br />We actually did this earlier but we calculated it directly in ContactSpace (using TransMult) - we&#039;d be trying to get the X vector which we set to zero earlier, we&#039;d be setting the Y and Z to zero, and then transforming the result back into WorldSpace ... so let&#039;s ignore that we already kinda had this answer, and do the operation again, but this time directly in WorldSpace:<br />accVelocity = DotProduct (CollisionNormal, VelocityDeltaForThisTimeStep)<br />Again, if there is a BodyB, we calculate this vector for BodyB, and subtract it from the result of BodyA.<br />We&#039;ll call the resulting vector &#039;the relative linear velocity due to acceleration in WorldSpace&#039;.<br /><br />To calculate the (post-collision) DesiredDeltaVelocity, we need the velocity of the contact point in contact space, velocity of the contact point in world space, and a &#039;coefficient of restitution&#039;.<br />desiredDeltaVelocity in WorldSpace = - (contactspaceVelocity.x - (Restitution * (contactspaceVelocity.x - velocityFromAcc)))<br /><br />The restitution coefficient is a floating-point value between 0.0 and 1.0 which determines how &#039;rubbery&#039; the collision is... Higher values make the collision &#039;more bouncey&#039; and indicate &#039;harder&#039; materials (glass marble on stone floor) while smaller values make the collision &#039;less bouncey&#039; and indicate &#039;softer&#039; materials (glass marble on mud).<br />For two bodies who each have their own Restitution value, we should use the lower value of the two.<br /><br />We are now ready to calculate the Impulse that will make our bodies bounce away from each other.<br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-12-24 17:52:07 by Homer</div>
   </div>
   <div class="post" id="post-206560">
    <div class="subject"><a href="#post-206560">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Let&#039;s calculate the impulse required to resolve this collision... we will build a vector that shows the change in velocity (in world space) for a UNIT impulse in the direction of the contact normal, and then we will SCALE that unit-impulse so that it causes EXACTLY the change in velocity that we desire. <br /> &nbsp; &nbsp;<br />To calculate the &#039;Torque per Unit of Impulse&#039;, we need &quot;the collision point relative to each Body&quot; and we need the collision normal:<br />torquePerUnitImpulse = CrossProduct(relativePosition,CollisionNormal) &nbsp; &nbsp;<br /><br />Now we use the (WorldSpace) Inverse Inertia Tensor (of each Body) to convert torquePerUnitImpulse into rotationPerUnitImpulse:<br />rotationPerUnitImpulse = InverseWorldInertiaTensor * torquePerUnitImpulse <br /><br />I&#039;ve provided a macro called Mat33_Mul_Vec3 so don&#039;t panic :P<br /><br />Now we must find the Linear Velocity that is due to only rotation and that is along the collision normal:<br />velocityPerUnitImpulse = CrossProduct(rotationPerUnitImpulse, relativePosition)<br /><br />Now we must calculate the change of velocity in ContactSpace:<br />ImpulseDenominator = BodyA.OneOverMass + DotProduct(velocityPerUnitImpulse,CollisionNormal)		<br /><br />If we have a BodyB in this collision, we should go through the sequence again for BodyB, which we ADD rather than subtract, to the result of BodyA, so we get:<br />ImpulseDenominator = (BodyA.OneOverMass + DotProduct(velocityPerUnitImpulseA,CollisionNormal)) + (BodyB.OneOverMass + DotProduct(velocityPerUnitImpulseB,CollisionNormal))<br /><br />Now we can calculate our desired impulse:<br />ContactSpaceImpulse = &lt;desiredDeltaVelocity / ImpulseDenominator , 0.0, 0.0&gt;<br /><br />See that our impulse is returned as a Vec3 in ContactSpace, see that it only has a value in the X axis.<br />Note that this is clearly showing that a Frictionless collision results in an impulse that is applied ONLY in the direction of the Collision Normal.<br /><br />Let&#039;s finish resolving this collision.<br />We need to convert the contactspace impulse into worldspace:<br />WorldImpulse = &nbsp;ContactToWorld * ContactSpaceImpulse<br /><br />Now we Split the impulse into linear and angular components, and calculate the delta-velocity and delta-angMomentum:<br />impulsiveTorque = CrossProduct(relativePositionA,WorldImpulse)<br />deltaAngMomentum = impulsiveTorque * BodyA.OneOverMass<br />deltaVelocity = BodyA.OneOverMass * WorldImpulse <br /><br />And if there&#039;s a BodyB:<br />impulsiveTorqueB = &nbsp;CrossProduct (WorldImpulse, relativePositionB) &lt;-- note we swapped the order here<br />deltaAngMomentumB = impulsiveTorque * -BodyB.OneOverMass<br />deltaVelocityB = -BodyB.OneOverMass * WorldImpulse <br /><br />We can add these deltas to the Body(s) immediately, however I suggest that there may be simultaneous collisions (ie, more than one collision at the same moment in time): we should resolve all simultaneous collisions using our current state, accumulating the deltas in the bodies... then when we&#039;re done resolving all simultaneous collisions, we should apply the delta sums to the body states. This allows us to resolve all the simultaneous collisions &#039;together&#039;, and then to advance our simulation &#039;together&#039;, so our bodies don&#039;t go &#039;out of synch&#039;.<br /><br />Next we&#039;ll learn how to calculate a response with Friction :)<br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-12-24 18:34:06 by Homer</div>
   </div>
   <div class="post" id="post-206561">
    <div class="subject"><a href="#post-206561">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">In order to implement friction, we&#039;ll use some of the previous calculations..however, the implementation is quite different.<br />When using Matrices, the equivalent of a CrossProduct is multiplication by a skew symmetric matrix.<br />Now we&#039;ll build the matrix for converting between linear and angular quantities.<br />impulseToTorqueA = Mat33_Star(relativePositionA)<br /><br />Now we&#039;ll build the matrix to convert contactspace impulse into a change in worldspace velocity:<br />deltaVelWorld = - ((impulseToTorqueA, InverseWorldInertiaTensor) * impulseToTorqueA)<br /><br />If theres a BodyB, we calculate its deltaVelWorld matrix the same way, and add the two result matrices.<br />Now we use a similarity transform to do a &#039;change of basis&#039; to get results as contact coordinates:<br />deltaVelocity = Transpose (ContactToWorld) * deltaVelWorld * ContactToWorld<br /><br />Now we&#039;ll add in the linear velocity by hand, to the Diagonal components:<br />deltaVelocity.m00 += inverseMass<br />deltaVelocity.m11 += inverseMass<br />deltaVelocity.m22 += inverseMass<br /><br />Note that for two Bodies, inverseMass is the sum of their inverse masses.<br /><br />We now need to INVERT the matrix to get &#039;impulse per unit velocity&#039;:<br />impulseMatrix = Mat33_Inverse(deltaVelocity)<br /><br />Now we find the Target Velocities that we need to kill:<br />velKill = &lt;desiredDeltaVelocity, ContactVelocity.y, ContactVelocity.z&gt;<br /><br />Now find the impulse needed to kill this velocity:<br />impulseContactSpace = impulseMatrix * vellKill<br /><br />Now we need to check if theres enough PLANAR impulse to overcome STATIC friction:<br />planarImpulse = sqrt(impulseContactSpace.y^2 + impulseContactSpace.z^2)<br /><br />IF (planarImpulse &gt; impulseContactSpace.x * STATIC friction), we need to use DYNAMIC friction, and find a new value for impulseContactSpace...<br />ELSE, we&#039;re happy to use the impulseContactSpace as it stands.<br /><br />My next post will show you how to implement dynamic friction (how to mangle the impulseContactSpace we have already calculated) , and that will wrap up Collision Response.<br /><br /></div>
    <div class="meta">Posted on 2008-12-24 19:44:17 by Homer</div>
   </div>
   <div class="post" id="post-206564">
    <div class="subject"><a href="#post-206564">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">OK - to implement dynamic friction, we must mangle the frictionless impulse (contact space):<br />impulseContactOut.yz /= planarImpulse<br /><br />impulseContactOut.x =&nbsp; deltaVelocity.m00 +<br />&nbsp; &nbsp; 			&nbsp; &nbsp; deltaVelocity.m01*friction*impulseContactOut.y +<br />&nbsp; &nbsp; 			&nbsp; &nbsp; deltaVelocity.m02*friction*impulseContactOut.z<br /><br />impulseContactOut.x = desiredDeltaVelocity / impulseContactOut.x<br /><br />impulseContactOut.y *= Dynamic Friction * impulseContact.x<br /><br />impulseContactOut.z *= Dynamic Friction* impulseContact.x<br /><br /><br />Physical objects are made of Physical Materials.<br /><br />Attached is a file containing a table of static and dynamic friction coefficients for various combinations of two materials. Note that this table is incomplete, and really just something to start with.<br />Actually, there are three tables, representing the coefficients under Dry, Slippery and Sticky conditions :)<br /><br />The file contains a macro to help us obtain a set of coefficients for a pair of materials, and also to look up the Density of a material.<br />We supply the Condition (dry, wet, slippery) we want, and the IDs of the two materials.<br />It returns in EAX a ptr to the pair of friction coefficients for those materials under those conditions.<br /><br />Now we&#039;re able to put it all together :)<br />I&#039;ve got some testing to do on the current code (theres at least one special condition to handle), so I won&#039;t provide an update just yet, but here&#039;s that Friction table to look at.<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2702" target="_blank">Friction.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2008-12-24 23:49:09 by Homer</div>
   </div>
   <div class="post" id="post-206565">
    <div class="subject"><a href="#post-206565">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">There is at least one special case to consider.<br /><br />OldState and NewState are both Penetrating... This shouldn&#039;t happen, it&#039;s due to poor implementation.<br /><br />One way this can happen: If a body has too little velocity to escape penetration (ie due to gravity alone) then it will begin the next iteration with its OldState and NewState both penetrating. eg A body starts life with zero velocity, it is resting on a Floor Plane. In the first iteration, a collision is detected, and the body is given velocity in Y+ to fight gravity, but its not enough, so it falls a small distance. In the next iteration, the body is still falling, so its Old and New states are both Penetrating.<br /><br />If we detect this state, we can attempt to Correct the Penetration.<br /><br />We can determine how much the Linear and Angular motions contributed to the Penetration, and use that ratio to find linear and angular &#039;corrections&#039; to force the Body backwards in Time into the Colliding position.<br />We should then correct all other affected state members, and resolve the Collision, assuming the collision time to be zero.<br /><br />I&#039;m not sure how my integration maths goes with negative time, so for now, we end up with the penetrating body being forced back into the colliding state, and this body glitches slightly forward in Time.<br />If I can get my Integrate method to work with negative Time, then I can fix this time glitch.<br /><br />In my next post, I&#039;ll show you pseudocode for the penetration correction which works for any body shape.<br /><br /></div>
    <div class="meta">Posted on 2008-12-25 03:30:19 by Homer</div>
   </div>
   <div class="post" id="post-206573">
    <div class="subject"><a href="#post-206573">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">So, something has slipped through our net, we have detected a Penetration case... a body is penetrating in both its Old and New states - ouch !! Can we fix it? Well, we can try :)<br /><br />Let&#039;s assume that we know the Penetration Depth (in the deepest case - at the New position).<br />Our Body was travelling with known linear and angular motions, and it caused a Penetration.<br />We can work out how much the linear and angular motions each contributed to the penetration depth, and calculate linear and angular &#039;corrections&#039; that should place the body back into the Colliding state.<br /><br />The first thing we need to do is calculate the linear momentum that is due only to rotation.<br />Lets do that in stages:<br /><br />Caculate Torque per unit impulse at contact point.. torque = R cross N = change in angular momentum over time:<br />TorquePerUnitImpulse = CrossProduct(relativeContactPosition,ContactNormal)<br /><br />Convert that into Angular Momentum:<br />angularInertiaWorld = Body.InverseWorldInertiaTensor * TorquePerUnitImpulse <br /><br />Find the inertia at the contact point:<br />angularInertiaWorld = CrossProduct (angularInertiaWorld,relativeContactPosition)<br /><br />Find the Linear part that is along the Contact Normal:<br />LinearMomentumDueToRotation = DotProduct (angularInertiaWorld, ContactNormal)<br /><br />When we continue, we&#039;ll learn how to use this value to determine how much Linear and Angular motions contributed to the penetration... then we can figure out how much linear and angular change is required to correct the penetration.</div>
    <div class="meta">Posted on 2008-12-27 22:50:05 by Homer</div>
   </div>
   <div class="post" id="post-206579">
    <div class="subject"><a href="#post-206579">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Now that we know the linear momentum at the contact point that is due only to Rotation and is in the direction of the collision normal.. we need to find the &#039;total&#039; linear momentum, by adding the NON-rotational component of linear momentum, which is simply the Mass of the Body... if theres another Body, repeat these steps, summing the result.. we now have the TOTAL momentum at the point of collision due to our body or bodies.<br /><br />We can now determine how much the Angular motion contributed to the Penetration Depth:<br /><br />AngularMove = ((AngularInertia / TotalInertia) * fPenetrationDepth)<br /><br />We can now also find the linear correction value:<br />LinearMove = fPenetrationDepth - AngularMove<br /><br />Now we know how much the Angular motion contributed to the penetration, we need to calculate the Rotation which caused this..we want the correct rotation direction, and scaled to produce the change we want:<br /><br />targetAngularDirection = CrossProduct (relativeContactPosition,contactNormal)<br />angularChange = Body.InverseWorldInertiaTensor * targetAngularDirection * (angularMove/AngularInertia )<br /><br /><br />The result is the change in Angular Momentum required to produce the desired change in rotation :)<br /><br />As for the Linear change, well, thats a straightforward change in Position which consumes whatever penetration depth remains. And if we have a second Body, as usual, we must reproduce these steps for Body B.<br /><br />And that brings us to the end of this brief but meaty introduction to Penetration Correction :)<br /><br /></div>
    <div class="meta">Posted on 2008-12-28 21:08:13 by Homer</div>
   </div>
   <div class="post" id="post-206581">
    <div class="subject"><a href="#post-206581">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Now its time to start laying out the pseudocode for the collision detection and response algorithm.<br /><br />WITHOUT any collision detection, the main loop of the simulator looks like this:<br />-Calculate the instantaneous Forces acting on our Body based on its Old state<br />-Integrate to find the New state, based on the Old state, instantaneous Forces, and TIMESTEP.<br /><br />WITH collision detection, we add the following steps:<br />-For all unique Pairs of Bodies:<br />--Perform Broadphase collision detection (based on BoundingSphere)<br />--If collision detected,<br />----Perform Narrowphase collision detection&nbsp; (based on actual shape)<br />----Add record of collision event to a List which is Sorted by CollisionTime<br />--Endif<br />-EndFor<br /><br />-For all Collision records:<br />--Peek at the first Collision record<br />--If the CollisionTime is NOT ZERO<br />----Integrate the entire simulation forward to the CollisionTime<br />--EndIf<br />--For all CollisionRecords which have the same CollisionTime:<br />----Resolve Collision... accumulate resulting changes to LinVelocity / AngMomentum<br />--EndFor<br />--Apply accumulated changes to affected Bodies, and swap the States of those Bodies<br />--If there are more Collisions<br />----Integrate the entire Simulation forward to the time of the NEXT collision<br />--Else<br />----Integrate the entire Simulation forward to the end of the current TimeStep<br />--EndIf<br />-EndFor<br /><br />You can see that I am making particular effort to:<br />1 - handle multiple simultaneous collision events as a GROUP<br />2 - integrate the simulation forwards in time as a GROUP<br /><br />I&#039;m trying hard to keep the simulation &#039;in synch&#039; , but this won&#039;t always be possible - and there are implementations where this is absolutely undesirable, which I might yet talk about at some point.<br /><br />Please note that this is just a rough draft of the algorithm I&#039;ve already implemented, it should serve only as a guide and is liable to be changed (there is at least one problematic singularity that I feel can be handled better).<br /><br />Now I&#039;ve talked about integration, collision detection, collision response, and penetration correction for rigid body dynamics using Spheres, it&#039;s probably time to turn our attention to more complex geometries, and as we go, introduce some mathematical shortcuts and speedups that work only for specific geometries.<br />It&#039;s probably time for me to post another update of the testbed code too, and sometime very soon I&#039;ll have to add some 3D rendering code so we can actually see something ;)<br /></div>
    <div class="meta">Posted on 2008-12-28 23:01:27 by Homer</div>
   </div>
   <div class="post" id="post-206584">
    <div class="subject"><a href="#post-206584">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I spent a little time today fusing the Physics engine into the framework from Biterider&#039;s D3D &#039;Vectors&#039; demo.<br />Having done that, I began deriving some new objects based on OA32&#039;s D3D_MeshManager and D3D_MeshManaged.<br /><br />Here&#039;s a rundown of my new objects:<br /><br />D3D_Simulator - derived from my physics Simulator class, this object is a replacement for D3D_MeshManager.<br />Apart from doing everything that the Simulator normally does, it keeps a list of &#039;reference meshes&#039; (These are used to efficiently support &#039;instancing&#039; of meshes using shared resources).<br /><br />D3D_PhysicalEntity - derived from my CollisionBody class, this object is a replacement for D3D_MeshManaged.<br />Apart from doing everything that the CollisionBody class normally does, it implements a &#039;Living Instance&#039; of a Reference Mesh.<br /><br />If these objects work out for me, I&#039;ll probably port all the &#039;inherited&#039; code (from Simulator / CollisionBody) into them, and eliminate the inheritance layer.<br /><br />Anyway, it means I&#039;m pretty much ready to start rendering objects on-screen, although there&#039;s a fair bit of duplication of resources to eliminate (things like bounding sphere are already in the D3D_Mesh baseclass) and the Simulator needs to be made more friendly to externally-stored entities.<br /><br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-12-29 07:37:33 by Homer</div>
   </div>
   <div class="post" id="post-206587">
    <div class="subject"><a href="#post-206587">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body"><div class="quote">Anyway, it means I&#039;m pretty much ready to start rendering objects on-screen,</div><br />Woo-hoo! I&#039;m looking forward to a graphical demo to play around with :)<br /><br />I&#039;ve been reading most of your posts in the thread, btw, but since I&#039;ve never done physics myself I haven&#039;t had anything intelligent to say :)</div>
    <div class="meta">Posted on 2008-12-29 10:03:14 by f0dder</div>
   </div>
   <div class="post" id="post-206595">
    <div class="subject"><a href="#post-206595">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body"><div class="quote"><br />Nvidia claims that PhysX enables super-accurate physics simulation with minimal coding effort and they advertise it by showing how it uses hardware acceleration on &quot;GeForce 200&quot;-series cards. Is this really our future or kinda worthless crap given that the modern CPUs don&#039;t have anythig to do, because GFX cards handle like 95% of the rendering process..?</div><br />NVIDIA deliberately makes/keeps PhysX slow on the CPU. It doesn&#039;t make proper use of SSE, and it doesn&#039;t do multi-threading.<br /><br />The result is quite ironic. In &#039;software&#039; mode only a fraction of your CPU&#039;s true power is used, <em>leading to low framerates</em>, and in &#039;hardware&#039; mode the CPU is mostly idle while the GPU gets to do graphics <strong>and</strong> physics, <em>leading to low framerates</em>.</div>
    <div class="meta">Posted on 2008-12-29 21:32:38 by C0D1F1ED</div>
   </div>
   <div class="post" id="post-206596">
    <div class="subject"><a href="#post-206596">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Please note that all the current work is involved in the efficient importing of MESH-based geometries into the simulation.<br />Arbitrary collision hulls will still be supported: although the PhysicalEntity class supports Loading/Instancing/Rendering<br /> of specific meshes, we can still declare the shape to be used for collision detection<br /><br />I had to &#039;retrograde&#039; my D3D_Simulator (formerly D3D_MeshManager), D3D_PhysicalEntity (formerly D3D_MeshManaged) and D3D_SimpleMesh (aka D3D_Mesh) classes.<br /><br />The public version of MeshManager stores all intances of a reference mesh WITHIN that reference mesh ... if we have several different reference meshes, with instances of each, we end up with several Collections of instances, and that&#039;s not very good for collision detection purposes... so I&#039;ve modified my D3D_Simulator class to store ALL instances (doesnt matter which ref mesh) under a single collection within the Simulator class.<br />This just means that when we perform &#039;BroadPhase&#039; collision testing, we&#039;re &#039;touching&#039; less memory pages and can better take advantage of caching in the cpu (less cache misses leading to faster execution).<br /><br />Another key change I made was to modify the Simulator.AddCollisionSphere method and move/rename it to D3D_PhysicalEntity.SetProperties : we can use this method to set up the physical properties of a meshed body we already instanced, specify whether or not the mesh is HOLLOW (and if so specify the THICKNESS), specify the SHAPE to use for Volume/Mass calculation and NarrowPhase collision detection, and take advantage of the fact that the D3D_Mesh class has already calculated the BoundingSphere for all meshes.<br /><br /></div>
    <div class="meta">Posted on 2008-12-29 22:50:34 by Homer</div>
   </div>
   <div class="post" id="post-206603">
    <div class="subject"><a href="#post-206603">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I&#039;m trying now to handle better the &#039;special case&#039; of collision at time T=0<br /><br />Most of the time, collision will occur somewhere between T=0 and T=PhysicsTimeStep<br />IE, the Body.NewState is Penetrating, unless we correct it via a response.<br /><br />If collision occurs at Time Zero, we should IMMEDIATELY resolve the collision, apply the results to the Body, and integrate this Body forwards in time so that its post-collision trajectory can be tested correctly against the other entities.<br /><br />Fortunately, I&#039;m already collecting collision events in a list that is sorted by Collision Time... so we&#039;ll find all these T=0 collisions right at the start of the list... the ResolveCollisions method can deal with these renegades, but if ResolveCollisions detects T=0 collisions, it should ONLY handle these ones, and then cause a secondary call to detect collisions so that we can properly detect subsequent collisions of our renegades, and then make another call to resolve all the pending collisions (including the ones we ignored).<br />As long as we do all this without actually integrating the whole system forwards in time, the bodies will remain synchronized.<br /><br />At first it will appear like I&#039;m cracking a walnut with a sledgehammer, but if you think about it, we&#039;re integrating BEFORE we detect/resolve collisions, so if something collides at T=0, it HAS no post-collision trajectory for the remainder of the current timestep (since its not APPLIED until the next Integrate call) so we really NEED to fix these, and Integrate them forwards, or they cannot interact for the remainder of this timestep!</div>
    <div class="meta">Posted on 2008-12-30 07:14:51 by Homer</div>
   </div>
   <div class="post" id="post-206608">
    <div class="subject"><a href="#post-206608">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I&#039;ve handled part of that special case, and set up an INT 3 trap and a debug message on the unhandled part, if I see it being triggered, I&#039;ll deal with it. Found a couple of small memory leaks involving the CollisionPair object (this object is a record of a point-collision, we store them in a Sorted List).<br /><br />Most important new change is the implementation of a &#039;sleep&#039; flag... if a Body collides with a fixed World Plane, and the Body has very little pre-collision velocity, we will say that the body is &#039;at rest&#039;, and put it to sleep.<br />Sleeping bodies will not be Integrated, and cannot be the CAUSE of collisions - bodies which are at rest can only be &#039;woken&#039; by a collision with another body (which obviously is NOT at rest).<br /><br />You can probably see that sleeping bodies are much cheaper to deal with... in a game environment which has a lot of physical bodies, we want to spend our cpu time on the MOVING stuff, something that isn&#039;t moving SHOULD cost less than something that is moving.<br /><br />Today I&#039;ll be experimenting with my existing code - if all is well, I&#039;ll begin implementing code for collision against a fixed Triangle as an introduction to collision against a body composed of moving triangles (mesh body).<br />I&#039;ll be sure to make a post or two about how I detect these collisions, but the collision response will be handled generically by the existing code.<br /><br />Remember - we need to know about the moment of impact, position in worldspace, and contact normal for each point of impact, the shapes involved are absolutely irrelevant.<br /><br /><br /></div>
    <div class="meta">Posted on 2008-12-30 20:11:36 by Homer</div>
   </div>
   <div class="post" id="post-206610">
    <div class="subject"><a href="#post-206610">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">There&#039;s some good news, and some bad news.<br /><br />For my current testing, I am allowing gravity to whack a single body into a single &#039;floor plane&#039;.<br />With friction enabled, the response appears to be perfect under all conditions.<br />But with NO friction, and with the floor plane tilted on an angle, the collision response is too powerful.<br />The problem is obviously in the &#039;CalculateFrictionlessImpulse&#039; method.<br /><br />Since physics simulation is SO much cooler with friction enabled (we&#039;ll pretty much always have it turned on), I&#039;m not that inclined to dig too deeply into this problem right now, however I&#039;ll certainly come back to it just for the sake of that warm fuzzy feeling you get when you actually complete what you set out to do.<br /><br />On the bright side, with friction enabled, I see my body bounce a few times, losing velocity as it does so... eventually it Penetrates the floor plane just once, Penetration Correction occurs, it tries to move just once more, and then it gets put to sleep - I&#039;d say that&#039;s damned near to perfect :)<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-12-30 20:40:10 by Homer</div>
   </div>
   <div class="post" id="post-206613">
    <div class="subject"><a href="#post-206613">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">It is useful to note that a Triangle is ALWAYS FLAT - that is to say, it always rests apon some 3D Plane.<br />So in order to detect collision between a Triangle and another Body, we begin by testing for collision against that Plane.. if we see collision, we note the intersection point apon the Plane, and then determine whether the Point lays INSIDE THE TRIANGLE, or outside of it.<br /><br />Here is some code that can tell us whether a Point is inside a triangle, or not... I&#039;ve commented the code with pseudocode that describes what the code is doing, however I&#039;m not inclined to explain it further.<br />You can read about Barycentric coordinates in your own time.. suffice to say, this technique is a lot faster than the more common &#039;which side of all edges does the point lay&#039; technique.<br /><br /><pre><code><br /><br />;This procedure uses the Barycentric technique<br />;to determine whether the given Point<br />;is located within the given 3D Triangle<br />;Returns TRUE/FALSE<br />;pvPoint = Point to be tested<br />;pvA&nbsp; &nbsp;  = Triangle Vertex A<br />;pvB&nbsp; &nbsp;  = Triangle Vertex B<br />;pvC&nbsp; &nbsp;  = Triangle Vertex C<br />;<br />;NOTES : The Barycentric coordinates (u,v) can be<br />;thought of as &#039;weights&#039; for linear interpolation along<br />;the triangle edges AB and AC.<br />;It is therefore possible to convert these coordinates<br />;into TEXTURE COORDINATES via linear interpolation<br />;of the texcoords at the three points of the triangle <br />IsPointInTriangle proc uses ebx ecx pvPoint,pvA,pvB,pvC<br />LOCAL v0:Vec3<br />LOCAL v1:Vec3<br />LOCAL v2:Vec3<br />LOCAL dot00:real8<br />LOCAL dot01:real8<br />LOCAL dot02:real8<br />LOCAL dot11:real8<br />LOCAL dot12:real8<br />LOCAL invDenom:real8<br /><br />; Compute vectors&nbsp; &nbsp; &nbsp; &nbsp; <br />;v0 = C - A<br />;v1 = B - A<br />;v2 = P - A<br />mov eax,pvA<br />mov ebx,pvB<br />mov ecx,pvC<br />mov edx,pvPoint<br />Vec3_Sub .Vec3, .Vec3<br />Vec3_Stow v0<br />Vec3_Sub .Vec3, .Vec3<br />Vec3_Stow v1<br />Vec3_Sub .Vec3, .Vec3<br />Vec3_Stow v2<br /><br />; Compute dot products<br />;dot00 = dot(v0, v0)<br />;dot01 = dot(v0, v1)<br />;dot02 = dot(v0, v2)<br />;dot11 = dot(v1, v1)<br />;dot12 = dot(v1, v2)<br />Vec3_Dot v0,v0<br />fstp dot00<br />Vec3_Dot v0,v1<br />fstp dot01<br />Vec3_Dot v0,v2<br />fstp dot02<br />Vec3_Dot v1,v1<br />fstp dot11<br />Vec3_Dot v1,v2<br />fstp dot12<br /><br />; Compute barycentric coordinates:<br />;invDenom = 1 / (dot00 * dot11 - dot01 * dot01)<br />;u = (dot11 * dot02 - dot01 * dot12) * invDenom<br />;v = (dot00 * dot12 - dot01 * dot02) * invDenom<br />fld1<br />fld&nbsp; dot00<br />fmul dot11<br />fld&nbsp; dot01<br />fmul st(0),st(0)<br />fsub<br />fdiv<br />fst invDenom<br /><br />fld&nbsp; dot11<br />fmul dot02<br />fld&nbsp; dot01<br />fmul dot12<br />fsub<br />fmul ;invDenom<br />fstp u<br /><br />fld&nbsp; dot00<br />fmul dot12<br />fld&nbsp; dot01<br />fmul dot02<br />fsub<br />fmul invDenom<br />fstp v<br /><br />; Check if point is in triangle<br />;return (u &gt; 0) &amp;&amp; (v &gt; 0) &amp;&amp; (u + v &lt; 1)<br />fld u<br />fldz<br />fcompp<br />fjle @F<br />fld v<br />fldz<br />fcompp<br />fjle @F<br />fld&nbsp; u<br />fadd v<br />fld1<br />fjge @F<br /><br />return TRUE<br /><br />@@:<br />return FALSE<br />IsPointInTriangle endp<br /><br /></code></pre><br /><br />I haven&#039;t tested this code yet, however I am confident that it will work correctly.<br /></div>
    <div class="meta">Posted on 2008-12-30 21:23:30 by Homer</div>
   </div>
   <div class="post" id="post-206614">
    <div class="subject"><a href="#post-206614">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Collision testing for two arbitrary meshes begins with a broadphase swept test of their bounding spheres.<br />If those collide, a narrowphase test is made for the earliest Time of Impact (TOI).<br />It is worth noting that just because the Spheres collide, actual collision of the GEOMETRY may not occur - we could have a &#039;near miss&#039; !!! But let&#039;s assume the collision is not a &#039;near miss&#039;.<br /><br />Since we have already placed the spheres so they are touching, and since the spheres are generally larger than the mesh they contain, we know that our bodies are either &#039;just touching&#039;, or are damn close to it.<br />At this point, we can find the CLOSEST FEATURES on both the Bodies, and then iteratively search for the earliest time of impact (or impacts).<br /><br />We need to find which Points of Body A are closest to which Faces of Body B... we also need to find which Points of Body B are closest to which Faces of Body A.<br />Having collected this data, we can then integrate &#039;just these points&#039; within a search loop.<br />Please note that since a Face is DESCRIBED by a set of Points, so we really only need to deal with points.<br /><br />To find the closest features, we use the standard &#039;Distance from Point to Plane&#039; , which involves a DotProduct of the Point and the Normal of the plane, and subtracting of &#039;PlaneD&#039; (the Plane.w component).<br /><br />It is possible to accelerate this testing by performing the testing in the Space of one of the Bodies.<br />Although we still Integrate both Bodies, we only need to Transform the features of the Other body (from its bodyspace, into worldspace, and then into the test bodyspace, via a single Similarity Transform).<br />As the bodies grow in complexity, this optimization becomes worth ever more to us.<br /><br />Once we&#039;ve collected all the collisions that occur at the earliest TOI, we can resolve that manifold as usual.<br /></div>
    <div class="meta">Posted on 2008-12-30 21:47:40 by Homer</div>
   </div>
   <div class="post" id="post-206619">
    <div class="subject"><a href="#post-206619">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I just changed the value for Gravity from 0.86 to 0.9806, and now I am seeing the body escape through the plane - the debug stream shows me that we are detecting zerotime collisions where it should clearly be a penetration correction - not sure whats going on here but I&#039;ll get to the bottom of it.<br /><br />I want my engine to be an out-of-the-box solution, not something that relies on &#039;tweaks&#039;.<br />It should be robust, maybe I need to be a little more aggressive in the collision side of things.<br /><br /></div>
    <div class="meta">Posted on 2008-12-31 01:50:48 by Homer</div>
   </div>
   <div class="post" id="post-206636">
    <div class="subject"><a href="#post-206636">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">There were some small bugs in the collision resolution code, just silly stuff really.<br />Collision Response now works perfectly, with friction disabled OR enabled.<br />In the latter case, both static and dynamic friction are implemented, which means that bodies interact more realistically, for example causing a sphere to ROLL apon a surface rather than simply SLIDE along it.<br /><br />Good stuff!<br /><br />Now I&#039;m ready to start making a real effort to handle arbitrary meshes, which will introduce a new problem to be solved in regards to collision detection and response.<br />So far, my simulator only works correctly with &#039;single point of contact&#039; collisions between bodies.<br />Very soon I will have to deal with &#039;edge collisions&#039; and &#039;face collisions&#039;, which are a little more complicated.. we can&#039;t simply process these simultaneous point collisions sequentially and expect plausible results... can we?<br /><br /></div>
    <div class="meta">Posted on 2009-01-01 22:22:01 by Homer</div>
   </div>
   <div class="post" id="post-206642">
    <div class="subject"><a href="#post-206642">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I&#039;m having trouble sourcing information that I can actually understand in regards to multiple simultaneous contact resolution. If anyone knows of good websites or whitepapers which can help me, I&#039;d certainly appreciate you letting me know.<br /><br />The major issue for me is the way my CURRENT code works... I currently calculate a &#039;desired post-collision velocity&#039; based on the impact velocity along the contact normal, then I calculate the impulse that causes a UNIT change in velocity along the normal, and finally I scale the impulse so that it produces my &#039;desired&#039; velocity.<br /><br />This approach won&#039;t work if there&#039;s more than one collision normal - I don&#039;t know how to find the &#039;desired velocity&#039; anymore, and besides that, we have multiple impulses whose torques fight one another, so the linear part of the impulse becomes unclear.<br /><br />I know that I need to solve this as a simultaneous equation, I&#039;m just not good enough with maths to elegantly describe the problem, much less solve it. I understand this problem falls under the category of &quot;Linear Complementary Problem&quot; (LCP) and normally an iterative approach is taken to find an impulse for each contact that doesn&#039;t break the contraints imposed by the other contacts.<br /><br />Is anyone willing to assist in regards to developing a viable solver without friction? If I can solve the non-friction case I think I can go on and solve the friction case by myself.<br /></div>
    <div class="meta">Posted on 2009-01-02 01:04:10 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29229&amp;page=1" style="">&laquo;</a><a href="../?id=29229&amp;page=2" style="">&lt;</a><input type="hidden" name="id" value="29229" /><input type="number" name="page" min="1" max="7" step="1" value="3" onchange="this.form.submit();" /><a href="../?id=29229&amp;page=4">&gt;</a><a href="../?id=29229&amp;page=7">&raquo;</a></form>  </div>
 </body>
</html>