<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Better, Faster, Stronger Physics 2009 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29229" />
  <link rel="prev" href="../?id=29229&amp;page=1" />  <link rel="next" href="../?id=29229&amp;page=3" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29229">Better, Faster, Stronger Physics 2009</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29229&amp;page=1" style="">&laquo;</a><a href="../?id=29229&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29229" /><input type="number" name="page" min="1" max="7" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=29229&amp;page=3">&gt;</a><a href="../?id=29229&amp;page=7">&raquo;</a></form>   <div class="post" id="post-206502">
    <div class="subject"><a href="#post-206502">Re: Integrating Velocity from Linear Force (as applied at the center of mass)</a></div>
    <div class="body">And here&#039;s our first update.<br /><br />This version contains a couple more Vector3 macros, and a small extension to the Integrate method.<br />After integrating the Position, we also integrate the Velocity.<br />This new step requires that we have computed the Linear Force of each Body (see ComputeForces), which in turn requires that we know the MASS.<br />This is our earliest introduction to Mass, later we&#039;ll learn how to calculate it properly, but for now we&#039;ll just assume that the Mass is always 1.0f<br />I&#039;ve also introduced &#039;inverse mass&#039;, which is simply 1/Mass.<br />If a physics formula requires that we divide something by Mass, we can instead multiply it by 1/Mass, thus avoiding the slower division operation, and speeding up the math... integrating velocity is one such formula where this small optimization can be made, and makes a good example.<br /><br />So now, assuming that Gravity is turned on, not only will Position change, but Velocity will too... gravity will accelerate the body toward the ground.<br /><br />I&#039;ve also taken the step of rewriting my old Timer code as a new OA32 object.<br />The next update will include this file, I just want to check it for bugs first.<br /><br />EDIT: I&#039;ve tested the Timer code, I&#039;ve embedded a timer in the Simulator, I&#039;ve moved the CreateSphere method from CollisionBody into Simulator, I&#039;ve added Start and Stop methods to the Simulator that control a thread which is dedicated to driving the simulator.<br />Now the user doesn&#039;t need to worry about the Timer code, and the physics stuff is completely decoupled from the GUI and Rendering code (if any).<br />We should see big performance gains on multi-cpu systems, and it will still work on single-core machines at the cost of an extra thread.<br />Best of all, its more user-friendly.<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2692" target="_blank">PhysicsTestBed.rar</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2008-12-15 07:15:58 by Homer</div>
   </div>
   <div class="post" id="post-206507">
    <div class="subject"><a href="#post-206507">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Here&#039;s our first working proof of the code so far.<br />Included is the new Timer object (yes, I found bugs, and rewrote it)... if you look, you&#039;ll notice that I used the &quot;inversion&quot; trick to avoid divide operations in the timer (the Period field is actually 1/TimerFrequency).<br /><br />As mentioned, the simulator class now contains its own driving thread, which means that the simulation will execute concurrently with any other code that you might have...&nbsp; and if you have more than one logical CPU, you&#039;ll see a big performance improvement when the simulator is placed under load, and/or we&#039;re doing expensive stuff in other threads at the same time, like rendering 3D graphics. This version also embeds its own Timer, and is very easy to use since the user doesn&#039;t need to worry about time.<br /><br /><br />The demo provided will add a Sphere object to the simulator, beginning at Position &lt;0,0,0&gt; and Velocity &lt;0,0,0&gt; with Gravity enabled.<br />The demo will emit messages to DebugCenter (do you have this installed?) which clearly shows the object falling in the Y-MINUS axis (since Y-PLUS is UP)... its velocity increases over time as it accelerates under the force of gravity, and its positional changes become greater in response.<br /><br />Just nice to actually be able to see &#039;something&#039; :)<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2693" target="_blank">PhysicsTestBed.rar</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2008-12-16 08:09:09 by Homer</div>
   </div>
   <div class="post" id="post-206513">
    <div class="subject"><a href="#post-206513">Re: Calculating the Mass of solid and hollow Spheres</a></div>
    <div class="body">The current code uses a default Mass of 1.0 ...<br />It&#039;s time to learn another simple physics formula, this one is for calculating Mass from Volume and Density:<br /><br />Mass = Volume * Density<br /><br />Pretty easy, eh? Well, it&#039;s easy if we know how to calculate the Volume of a given geometry.<br />For a Box, the volume would be: Volume = Length * Width * Height<br />But we&#039;re working (at least for now) only with Spheres.<br /><br />Assuming that the Sphere is SOLID, we can calculate the Volume of a Sphere like this:<br />Volume = 4/3 * PI * R^3<br /><br />And if the Sphere is HOLLOW, we just calculate the major and minor volumes of the inner and outer walls of the sphere, and subtract the smaller value from the larger one.<br />Given R1 = outer radius of sphere and R2 = inner radius (ie, thickness = R1-R2) :<br />Volume = (4/3 * PI * R1^3) - (4/3 * PI * R2^3)<br /><br />So now we&#039;re able to find the volume of solid and hollow spheres, what about the Density?<br />We can&#039;t actually calculate it, because it depends totally on the material that the Sphere is made of.<br />Basically, early scientists decided that water had a density of 1.0, and compared other materials to it.<br />Things that are lighter than water (and thus float, regardless of shape) have a density less than one.<br />And things that are heavier than water (and sink unless they displace a large volume, like boats do) have a density of greater than one.<br />Each kind of material has a specific Density, we can create a table of densities for common materials.<br />Here&#039;s a few:<br /><br />STUFF LIGHTER THAN WATER<br />Balsa Wood = 0.17<br />Willow&nbsp; &nbsp; &nbsp; &nbsp; = 0.42<br />Oak&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0.75<br /><br />WATER HAS UNIT DENSITY<br />Water&nbsp; &nbsp; &nbsp; &nbsp;= 1.0<br /><br />STUFF HEAVIER THAN WATER<br />Aluminium = 2.7<br />Iron&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 7.8<br />Copper&nbsp; &nbsp; &nbsp; = 8.6<br />Gold&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= 19.3<br /><br />Using this knowledge, we can write a general-purpose SetMass method for all bodies:<br /><br /><pre><code><br />;This method creates a new Sphere collision body and adds it to the simulator <br />Method Simulator.AddCollisionSphere, uses esi, fOuterRadius:real4, fMaterialDensity:real4, IsHollow:BOOL, fInnerRadius:real4<br />LOCAL fVolume:real8<br />&nbsp; &nbsp; SetObject esi<br />&nbsp; &nbsp; New CollisionBody,Init, esi, SHAPEID_SPHERE<br />&nbsp; &nbsp; m2m .CollisionBody.fRadius,&nbsp; fRadius,edx<br />&nbsp; &nbsp; m2m .CollisionBody.Density,&nbsp; fMaterialDensity,edx<br />&nbsp; &nbsp; m2m .CollisionBody.IsHollow, IsHollow, edx<br />&nbsp; &nbsp; ;Add the new sphere to the simulator<br />&nbsp; &nbsp; OCall .Bodies::Collection.Insert, eax<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Calculate VOLUME<br />&nbsp; &nbsp; mov edx,4<br />&nbsp; &nbsp; fildReg edx<br />&nbsp; &nbsp; mov edx,3<br />&nbsp; &nbsp; fildReg edx<br />&nbsp; &nbsp; fdiv&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;4/3<br />&nbsp; &nbsp; fldpi<br />&nbsp; &nbsp; fmul&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;* pi<br />&nbsp; &nbsp; fld&nbsp; fOuterRadius<br />&nbsp; &nbsp; fmul fOuterRadius<br />&nbsp; &nbsp; fmul fOuterRadius<br />&nbsp; &nbsp; fmul&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;* r^3<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; .if IsHollow==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; mov edx,4<br />&nbsp; &nbsp; &nbsp; &nbsp; fildReg edx<br />&nbsp; &nbsp; &nbsp; &nbsp; mov edx,3<br />&nbsp; &nbsp; &nbsp; &nbsp; fildReg edx<br />&nbsp; &nbsp; &nbsp; &nbsp; fdiv&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;4/3<br />&nbsp; &nbsp; &nbsp; &nbsp; fldpi<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;* pi<br />&nbsp; &nbsp; &nbsp; &nbsp; fld&nbsp; fOuterRadius<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul fOuterRadius<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul fOuterRadius<br />&nbsp; &nbsp; &nbsp; &nbsp; fmul&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;* r^3<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; fsub&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;find the difference<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; fstp fVolume<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; OCall eax::CollisionBody.SetMass, fMaterialDensity, fVolume<br />MethodEnd<br /></code></pre><br /><br />We&#039;ve had to add an extra parameter to the AddCollisionSphere for the &#039;inner radius&#039;, but its only valid if the sphere is hollow (IsHollow = TRUE).<br /><br />Given that we &#039;know&#039; the density of the material that a sphere is made of, we now have code that can accurately calculate the Mass, whether it is hollow or solid.<br /><br />Later we&#039;ll look at &#039;buoyancy&#039; - we&#039;ll be able to determine whether a hollow sphere will float or sink in water (and other liquids) based on its &#039;displacement&#039; and its mass.<br /><br /><br /></div>
    <div class="meta">Posted on 2008-12-17 00:19:25 by Homer</div>
   </div>
   <div class="post" id="post-206515">
    <div class="subject"><a href="#post-206515">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Now I&#039;m not quite sure which way to take this thread next.<br />There&#039;s basically two ways to go: we can introduce rotation and then collision, in which case rotation must immediately be part of the collision response discussion.<br />Alternatively, we can introduce basic linear collision and response, then add rotation into the fray.<br /><br />Which path should we take?<br /><br />EDIT : That was a question, you can put your own opinion here.<br /></div>
    <div class="meta">Posted on 2008-12-17 05:52:22 by Homer</div>
   </div>
   <div class="post" id="post-206520">
    <div class="subject"><a href="#post-206520">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">rotation :)</div>
    <div class="meta">Posted on 2008-12-17 09:58:02 by Ultrano</div>
   </div>
   <div class="post" id="post-206525">
    <div class="subject"><a href="#post-206525">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">OK, we&#039;ll do it the hard way then :P<br /><br />The first thing we need to know : Linear and Angular calculatations are completely separate.<br />We&#039;ll need to write Angular counterparts to all our Linear code.<br /><br />We&#039;ve described Linear Velocity as being &#039;the rate of change of Position&#039; - literally, the rate at which the Position is changing, or &#039;how fast its moving&#039;.<br />Now we introduce Angular Velocity, which I&#039;ll defined as &#039;the rate of change of Orientation&#039; - literally, the rate at which the body&#039;s Orientation is changing, or &#039;how fast its spinning&#039;.<br /><br />In the ComputeForces method, we calculated Linear Force from Linear Velocity.<br />For rotation, we calculate Angular Force (also known as Torque) from the Angular Velocity.<br /><br />The formula for calculating Torque is essentially the same as its linear counterpart.<br />linear force += velocity * linear damping<br />angular force += angular velocity * angular damping<br /><br />So the changes to the ComputeForces method are really easy.<br />However, the changes to the Integrate method are not ALL so simple... but we&#039;ll deal with each problem as we come to it.<br /><br />In the Integrate method, after the &#039;Linear&#039; code we already have, the first thing we need to add is some code to calculate the ANGULAR MOMENTUM. The reason we need Angular Momentum is that at the very end of the Integrate method, we&#039;ll use it to extract a new value for the Angular Velocity.<br /><br />New AngularMomentum = Old AngularMomentum + DeltaTime * Old Torque<br /><br />OK, so far, so good.<br />The remainder of the Integrate method contains some fairly complex maths, so before we dive head-first into that, let&#039;s pause briefly and talk about a couple of important things.<br />I&#039;ve mentioned previously that I&#039;m using a 3x3 Matrix to describe Orientation.<br />One of the reasons for this is that we&#039;ll be using a 4x4 Matrix to render our object on the screen, and the Mat33 Orientation matrix fits neatly in the top left corner of the 4x4 transformation matrix (the remaining cells are used to describe position and scale).<br />Now I&#039;d like you to imagine that you are in outer space, playing a game of pool : you are poking a ball with a stick in &#039;mid-air&#039; , with no gravity, no other forces.<br />When we apply an external force to a body in a line that passes through the center of mass, the linear velocity of the object will change, but its angular velocity won&#039;t ... the way it is spinning is not affected.<br />If we poke the ball &#039;off-center&#039;, we&#039;ll cause its spin to change as well as its linear velocity.<br />And if we poke it with a &#039;glancing blow&#039; on its very edge, its spin will change considerable, while linear velocity is unaffected.<br /><br />In order to convert forces into changes in angular velocity, we employ a mathematical tool called INERTIA TENSOR.<br />This is another 3x3 Matrix, however it does NOT represent an orientation.<br />It describes the way that Mass is distributed across the volume of the body, which is a function of its SHAPE.<br />Just as for Density, we can create a table of inertia tensors for common shapes, however we can also calculate the inertia tensor for ARBITRARY shapes - I won&#039;t be getting into that now, and I won&#039;t talk much about the inertia tensor, only that its a Mat33, and that its content is &quot;known&quot; for common shapes like Sphere.<br /><br />In my next post, we&#039;ll write the remaining code for the Integrate method, which will mention the inertia tensor.<br /></div>
    <div class="meta">Posted on 2008-12-18 00:09:22 by Homer</div>
   </div>
   <div class="post" id="post-206526">
    <div class="subject"><a href="#post-206526">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body"><br />So, we&#039;ve just calculated the relatively easy &#039;instantaneous angular momentum&#039;.<br />The reason we can&#039;t simply track this value is that (for anything other than a sphere) it is constantly changing based on the shape of the object and its current axis of rotation... but calculating it wasn&#039;t hard, was it?<br /><br />Now we&#039;re ready to find the new Orientation.<br />To do that, we&#039;ll need to apply the angular velocity for some Time ... deltaTime.<br />We&#039;ll be using another mathematical tool based on the Mat33 called a &#039;skew&#039;symmetric matrix&#039;, which is built from our angular velocity vector.<br />That matrix will be multiplied by the Body&#039;s OLD Orientation, and scaled by DeltaTime, resulting in an &#039;offset rotation matrix&#039; which describes the CHANGE in orientation over the given time period.<br />Finally, we add to it the original Orientation matrix, resulting in a NEW Orientation matrix...<br /><br />OffsetOrientation = (DeltaTime * SkewSymmetric(Source.AngularVelocity) * OLD Orientation)<br />NEW Orientation = OLD Orientation + OffsetOrientation<br /><br />We can create a SkewSymmetric Mat33 from a Vec3 using the STAR Matrix Operator.<br />I&#039;ll provide a Mat33_Star macro for this purpose.<br /><br />So now we have our NEW ORIENTATION! Woohoo! But we&#039;re not done yet.<br />Due to the imprecise nature of floating point math, we will find that the above operations will &#039;deform&#039; our Orientation Matrix... after a few iterations, it will no longer represent a rotation matrix, and that&#039;s bad.<br />So the very next thing we&#039;ll do is &#039;squash&#039; our Orientation matrix back into shape, forcing it to be a nice rotation matrix. This is known as &#039;orthonormalizing&#039;, and I&#039;ll provide a Mat33_OrthoNormalize macro for you to use.<br /><br />So we have a new orientation matrix, and its a nice rotation matrix, are we there yet? NO! Quiet in the back seat or I&#039;ll pull over and make you walk!<br /><br />The Inertia Tensor we stored in our Body is given in &#039;Body Space&#039;, so that it stays legal no matter what orientation the body has... and we take the liberty of INVERTING this matrix to avoid Divisions...<br />Our next step is to transform the Inverse BodySpace Inertia Tensor into WorldSpace using the new orientation matrix we just calculated. To do this, we use a &#039;Similarity Transform&#039; as follows:<br /><br />InverseWorldInertiaTensor = New Orientation * InverseBodyInertiaTensor * Transpose(New Orientation)	<br /><br />Finally, we can extract the new Angular Velocity from the tensor we just calculated, and the angular momentum we calculated earlier:<br /><br />New AngularVelocity = InverseWorldInertiaTensor * New AngularMomentum<br /><br />Whew !! We now have all the stuff we need for both the CalculateForces and Integrate methods.<br />Furthermore, we have everything in place that we need to apply external forces to our body and see its rotation changing correctly, so when we introduce collisions and friction, our body will behave as it should.<br /><br />I told you rotation wasn&#039;t as simple, but we&#039;ve completely covered the stuff we needed to, and we can put it behind us and move on (just tell yourself it was a bad dream).<br />Actually, we&#039;ve just covered the most complicated stuff in the physics simulator - from now on, everything is pretty easy!<br /><br />Coming up next, we&#039;ll spend some time looking at collision detection, we&#039;ll implement that code in a demo, and then we&#039;ll move on to collision response without Friction, and finally, we&#039;ll implement a friction model that will allow our bodies to realistically interact with the surfaces they encounter, causing things like &#039;rolling&#039; to &#039;magically happen&#039;.<br /></div>
    <div class="meta">Posted on 2008-12-18 00:42:25 by Homer</div>
   </div>
   <div class="post" id="post-206528">
    <div class="subject"><a href="#post-206528">Re: Networked Physics</a></div>
    <div class="body">In regard to NETWORKED Physics, it&#039;s worth noting at this point that we have everything we need for CLIENTSIDE physics... <br /><br />The simulation is executed on both the Client and Server.<br />But the Client only integrates bodies, it does not perform collision testing, or collision resolving.... it simply performs &#039;Dead Reckoning&#039; based on the last known physics state of each simulated object.<br /><br />The Server implements a full-featured simulator which does &#039;everything&#039;, and periodically sends state information to the Clients, who make &#039;corrections&#039; (as directed by the Server) to their simulation.<br /><br />If it wasn&#039;t for the Server, the Client would be able to walk through walls etc.<br /><br />Doing things this way makes a lot of sense - usually, the Server doesn&#039;t have a 3D rendering interface, it doesn&#039;t render anything at all, it&#039;s just a networking program crossed with a physics simulator.<br /><br />The client is busy doing a lot of 3D rendering, by NOT performing collision testing, the client can concentrate on doing its main job of drawing eyecandy, and just integrate the bodies it simulates until the Server tells it &#039;hey, this thing just changed directions due to a collision&#039;.<br /><br /><br /></div>
    <div class="meta">Posted on 2008-12-18 03:21:56 by Homer</div>
   </div>
   <div class="post" id="post-206532">
    <div class="subject"><a href="#post-206532">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Attached is a complete update, containing code for pretty much everything I&#039;ve talked about so far.<br />Of particular note is the new Mat33 macro set for 3x3 matrix math operations.<br /><br />The demo doesn&#039;t appear to do anything more than it was before, because I haven&#039;t asked it to - but all the new code is being called, and the application is not crashing and burning :P<br /><br />Over 400 views in 10 days, that&#039;s just under two hits per hour, 24 hours a day - someone out there is watching..<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2699" target="_blank">PhysicsTestBed.rar</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2008-12-18 07:44:12 by Homer</div>
   </div>
   <div class="post" id="post-206538">
    <div class="subject"><a href="#post-206538">Re: Instantaneous collision tests for Sphere (INTERSECTION TESTS)</a></div>
    <div class="body"><br />It&#039;s time to begin talking about collision detection - I&#039;ll treat collision response as a separate topic.<br /><br />There&#039;s two basic kinds of collision testing, we can call them &#039;swept and instantaneous&#039;, or we can call them &#039;broadphase and narrowphase&#039;. Let&#039;s begin by looking at the narrow phase (instantaneous) testing, which is quite simply testing for INTERSECTION of two entities at a specific moment in time.<br /><br />For two spheres, the instantaneous test involves calculating the distance between the centers of the two spheres, and comparing that distance with the sum of the radii of both spheres... <br />If the distance is less than the sum of the radii, then the spheres are penetrating one another, ie, intersecting.<br />If the distance is equal to the summed radii, then the spheres are colliding (touching one another).<br />If the distance is greater than the summed radii, then the spheres are clear of one another.<br /><br />What if we wanted to check for intersection of a sphere and a flat surface?<br />All flat surfaces lay apon a 3D PLANE. <br />Planes always have a &#039;surface normal&#039;, which tells us which direction in 3D space the plane is facing.<br />There is a well-known test to find the distance between a POINT and a PLANE... we calculate the Dot Product of the Normal and the Point - the result is the Signed distance, and negative values indicate which SIDE of the Plane the point lays. This Point/Plane test can be extended to deal with Spheres, we must take the radius into account - we can either modify the distance result by the radius, or we can shift the plane normal by the radius before we calculate the distance. Either way, we can determine whether the plane intersects the sphere (and if so, by how much) or whether the sphere is totally behind or in front of the plane (and find the distance between them).<br /><br /></div>
    <div class="meta">Posted on 2008-12-18 21:35:04 by Homer</div>
   </div>
   <div class="post" id="post-206541">
    <div class="subject"><a href="#post-206541">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">And what if we want to check for intersection (perform instantaneous collision detection) of a sphere and a triangle?<br />First, we find the Plane of the triangle, and perform the sphere/plane test, and if the sphere is colliding, penetrating, or BEHIND the plane (anything but CLEAR of it), we find the point of intersection on the plane, and then test if that point is within the bounds of the Triangle ...Here&#039;s two possible methods for doing that .. &quot;Same Side&quot; and &quot;Barycentric&quot; techniques for determining if a point is within a triangle: http://www.blackpawn.com/texts/pointinpoly/default.html<br /><br />Now we&#039;ve talked about a few instantaneous intersection tests, we can move on to swept tests.<br />I&#039;ve already provided the sourcecode for an implementation of the sphere/sphere sweep test.<br />You can find algorithms and pseudocode for sphere/sphere and sphere/plane sweep tests here: http://www.gamasutra.com/features/19991018/Gomez_2.htm<br /><br />Instantaneous tests are only good for testing if theres a collision at a specific instant in time.<br />Swept tests are different because they test a whole slice of time - we can define the start time and the end time, and check all the time inbetween with a single test by using &#039;quadratic equations&#039;. Of course, this linear solution is not accurate over large slices of time, we&#039;re talking about a maximum of (PhysicsTimeStep) seconds of time.<br />So we&#039;re likely to be passing 0.100 as the time-range for these tests. Swept tests are particularly good at detecting collisions of small and fast-moving entities such as bullets.<br /><br />For moving spheres we see that instantaneous testing isn&#039;t generally useful to us : collision detection should always begin with a Swept test.<br />If the sweep test finds a collision, it will return the time-delta which represents the first moment of contact.<br />We can then wind the simulation forward to that moment in time, handle the collision event, and then continue the simulation from the time of impact.<br /></div>
    <div class="meta">Posted on 2008-12-19 17:54:01 by Homer</div>
   </div>
   <div class="post" id="post-206542">
    <div class="subject"><a href="#post-206542">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">So - for two spheres. the goal of broad-phase collision testing is to determine if a collision is possible, and my implementation also tells us about the moment of impact, and where it occurred.<br />Narrow-phase collision is not necessary for Spheres, but other shapes will need them.<br />I&#039;d rather talk about collision response and complete the engine for Spheres before talking about other shapes.<br /><br />My collision testing/resolving will begin with testing all pairs of bodies, and making a list of pairs of colliding bodies, sorted by the time at which the collision occurs.<br />Then I will process this list in a loop:<br />1. integrate the system to that time, <br />2. we take the pair with the earliest collision time from the list, we try to resolve this collision<br />3. If a collision was resolved, we swap the states of all our bodies.<br />&nbsp; &nbsp;(there can be &#039;non collisions&#039; where a collision has become invalid)<br />3. we subtract the &#039;earliest collision time&#039; from all remaining collision pairs in the list<br />4. we LOOP on step 2 until the list is empty.<br /><br /><br /></div>
    <div class="meta">Posted on 2008-12-20 00:25:05 by Homer</div>
   </div>
   <div class="post" id="post-206543">
    <div class="subject"><a href="#post-206543">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Hey Homer,<br /><br />I&#039;m quite curious how do you check for intersection between polygons...&nbsp; ;)</div>
    <div class="meta">Posted on 2008-12-20 03:59:32 by roticv</div>
   </div>
   <div class="post" id="post-206544">
    <div class="subject"><a href="#post-206544">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I didn&#039;t want to talk about more complex shapes yet - but since you insist..<br /><br />Polygons begin with the most simple 3D polygon - the tetrahedron.<br />This is a triangular pyramid with four faces, and four vertices.<br />We can say a cube has six faces, and eight vertices.<br /><br />Any 3D polygon can be described as a set of faces and a set of planes relative to the origin of that polygon (ie, the geometric description of the polygon is made in &#039;Body Space&#039;).<br />The reason that we choose the BodySpace representation is that it doesn&#039;t change while our Body is rotating.<br />We perform the collision test from one Body&#039;s Space , so that only the geometric features of the other Body need to be transformed before testing. Collision points are returned to WorldSpace, where the Collision Normal is found.<br /><br />One way to check for intersection of two arbitrary polygons: we must compare the closest vertices of each body against the closest faces of the other body.&nbsp; An improved method uses the Separating Axis Theorem, with Voronoi regions used to identify the closest features.<br />There&#039;s a totally new algorithm too, the name completely slips my mind, which doesn&#039;t require voronoi.<br /><br />Anyway, the more complex a geometry becomes, the more expensive it is to collide with.<br />So beyond some limit, we should surround our complex 3D geometry with an imposter - a convex hull made from one or more geometric primitives which closely represents our more complex geometry.<br />There are algorithms which can construct a convex approximation of an arbitrary geometry which accept a &#039;cloud of points&#039; as input.<br />For complex geometries, we should always perform a preliminary test against an imposter, and if that collides, we can perform full intersection testing using the real geometries.<br /><br /><br /> </div>
    <div class="meta">Posted on 2008-12-20 19:05:17 by Homer</div>
   </div>
   <div class="post" id="post-206545">
    <div class="subject"><a href="#post-206545">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I now have another choice of direction - composite rigid body physics, or collision resolution.<br />Please vote for something :)<br /></div>
    <div class="meta">Posted on 2008-12-21 02:59:35 by Homer</div>
   </div>
   <div class="post" id="post-206546">
    <div class="subject"><a href="#post-206546">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Hope I at least got you thinking?<br /></div>
    <div class="meta">Posted on 2008-12-21 06:43:32 by Homer</div>
   </div>
   <div class="post" id="post-206547">
    <div class="subject"><a href="#post-206547">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I vote for collision resolution.</div>
    <div class="meta">Posted on 2008-12-21 17:41:16 by ti_mo_n</div>
   </div>
   <div class="post" id="post-206548">
    <div class="subject"><a href="#post-206548">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I vote for collision resolution too.<br /><br />The idea of using convex hull to approximate the collision is a good idea. It seems extremely complicated and time consuming to check every vertex. Imagine 100 objects which are complex polygons with 1000 vertices each and checking the collision for everything.</div>
    <div class="meta">Posted on 2008-12-22 09:55:35 by roticv</div>
   </div>
   <div class="post" id="post-206556">
    <div class="subject"><a href="#post-206556">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Depending on the implementation, I would use convex imposters only to determine if a collision of the high-resolution geometry is LIKELY - ie, as a preliminary test. If we see the convex imposter collide, then we can perform the most expensive test using the true geometry (for games, we&#039;re probably happy with the result of the imposter collision).<br /><br />OK, now let&#039;s start talking about collision resolution.<br />I&#039;m going to make the assumption that we have not only detected a collision will occur in the current timestep at some small future time delta, but we have used that time delta to integrate the simulation forwards to the exact moment of collision - the body or bodies must be in the colliding state where they are &#039;just touching&#039;.<br />In this example, I&#039;m going to discuss the most simple collision of a single spherical body and a fixed Plane.<br />So we have this sphere, and it&#039;s positioned so that it has just made contact with the plane.<br />In order to resolve a collision, we need two important pieces of information.<br />The first is the Collision Normal: for a collision of a body and a fixed plane, its simply the normal of the plane... for two bodies, we use the convention that it is the normal from body B back to body A.<br />The second piece of information we need is the &#039;Contact Point&#039; - the place where the two entities actually made &#039;first contact&#039;.<br />My solution of the collision is performed in &#039;Contact Space&#039; - although this is not necessary for &#039;frictionless&#039; collisions, it is VERY necessary when we introduce friction, so let&#039;s learn how it&#039;s done.<br />We&#039;re going to calculate the linear forces at the collision point which are in the direction of the collision normal, use that to calculate a Collision Impulse Per Unit Velocity, and then scale the impulse to achieve a Desired Post-Collision Velocity.<br /><br />In the next post I&#039;ll cover all the steps we must follow in order to calculate a Collision Impulse in Contact Space, and transform it back to WorldSpace.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2008-12-23 21:05:50 by Homer</div>
   </div>
   <div class="post" id="post-206557">
    <div class="subject"><a href="#post-206557">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">For now, I&#039;ll assume that the Body is &#039;Clear&#039; in its Old state, and &#039;Colliding&#039; in its New state.<br /><br />The first thing we need is a 3x3 Matrix for transforming (rotating) between worldspace and contact space.<br />Mat33_OrthoNormalBasis is a macro I&#039;ll be providing which requires only the Collision Normal to produce a matric we&#039;ll call ContactToWorld.<br /><br />Just a quick word about Vectors in ContactSpace coordinates - the X axis represent the direction of the collision normal - the Y and Z axes represent the vectors orthogonal and normal to X, ie the &#039;sliding&#039; vectors.. it will make more sense as we go.<br /><br />The next thing we need is the position of the collision point with respect to the center of mass of each body.<br />RelativePosition = CollisionPoint - Body.NewState.CMPosition<br /><br />Now I want you to imagine that the collision point is actually &#039;stuck&#039; to the body - theres a particle on the surface of the body that happened to coincide with the collision point at the collision moment in time.<br />Now we&#039;re going to learn how to find the linear velocity of that particle on the surface of a body.<br />Given that the body is probably moving AND rotating, this is NOT the same as the linear velocity of the Center of Mass of that body !!! Furthermore, for my solution to work, I want that velocity in Contact Space.<br />We&#039;re going to need the RelativePosition and the ContactToWorld matrix.<br /><br />First off, to find the velocity of the collision point, in world space:<br />Linear Velocity of Point in WorldSpace = CrossProduct(Angular velocity of body, RelativePosition) + Linear velocity of body<br /><br />Now, we want to transform that from WorldSpace to ContactSpace:<br />&nbsp; &nbsp; LinVel of Point in ContactSpace = Transpose(ContactToWorld) * Linear Velocity of Point in WorldSpace<br /><br />To make that transformation a little cheaper, I&#039;ve included a &#039;TransMult&#039; macro (it performs the multiplication against what WOULD be the transpose of the input matrix).<br /><br />We need to also find &#039;the change in linear velocity that was due to acceleration in this timestep&quot;, convert it to Contact coordinates, and zero the X axis of the resulting vector - we&#039;re not interested in the collision normal direction this time, but we&#039;re interested in acceleration along the &#039;friction&#039; vectors - with sufficient friction, these will be eliminated - with NO friction, they must be present. We add the two vectors we produced, and the result is the Linear Velocity in ContactSpace which we wanted.<br />If this collision involves TWO bodies, we&#039;ll need to go through all of that for the second body as well.<br /><br />We are now ready to calculate our &#039;Desired Delta Velocity&#039; which we would like our body to have AFTER the collision, and using that, we can calculate an IMPULSE which would produce that change in velocity.<br /><br />Please note that frictionless collision resolution can be a whole lot more simple than I am making it by using ContactSpace - but collisions with friction really require that we work in contact space, and they&#039;re a whole lot more interesting and realistic than non-friction collisions.<br />Imagine a ball falling onto a flat surface, and that the ball is spinning (has angular velocity).<br />With no friction, it will bounce straight back up every time... the fact that it is rotating will be ignored!<br />But with friction, it will go flying off in the direction that it was rotating, and its angular velocity will be reduced.. some of the energy it was using to rotate will be transformed into linear motion. That&#039;s much more realistic, isnt it?<br /><br />The next post will take us through the process of calculating DesiredVelocityDelta (WorldSpace) and Impulse (ContactSpace).<br /></div>
    <div class="meta">Posted on 2008-12-23 23:58:01 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29229&amp;page=1" style="">&laquo;</a><a href="../?id=29229&amp;page=1" style="">&lt;</a><input type="hidden" name="id" value="29229" /><input type="number" name="page" min="1" max="7" step="1" value="2" onchange="this.form.submit();" /><a href="../?id=29229&amp;page=3">&gt;</a><a href="../?id=29229&amp;page=7">&raquo;</a></form>  </div>
 </body>
</html>