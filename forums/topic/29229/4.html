<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Better, Faster, Stronger Physics 2009 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29229" />
  <link rel="prev" href="../?id=29229&amp;page=3" />  <link rel="next" href="../?id=29229&amp;page=5" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29229">Better, Faster, Stronger Physics 2009</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29229&amp;page=1" style="">&laquo;</a><a href="../?id=29229&amp;page=3" style="">&lt;</a><input type="hidden" name="id" value="29229" /><input type="number" name="page" min="1" max="7" step="1" value="4" onchange="this.form.submit();" /><a href="../?id=29229&amp;page=5">&gt;</a><a href="../?id=29229&amp;page=7">&raquo;</a></form>   <div class="post" id="post-206643">
    <div class="subject"><a href="#post-206643">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">OK I&#039;ll rephrase the question.<br />Who has experience in using matrix operations to solve non-trivial simultaneous equations?<br /></div>
    <div class="meta">Posted on 2009-01-02 11:21:17 by Homer</div>
   </div>
   <div class="post" id="post-206647">
    <div class="subject"><a href="#post-206647">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Why not scaling the vectors according to the velocities they represent and then just add them all together?</div>
    <div class="meta">Posted on 2009-01-02 14:14:36 by ti_mo_n</div>
   </div>
   <div class="post" id="post-206651">
    <div class="subject"><a href="#post-206651">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">For multiple simultaneous contacts apon a single body, we can&#039;t simply add the vectors, or average them, or calculate them individually and add the resultant motions, or average them.<br />We can&#039;t do this because these events are codependant - they are not independant because although they are applied at different points, the application of these forces affects the other contacts through the center of mass via the inertia tensor.<br />We really need to solve this as a simultaneous equation, which can be expressed as matrix alegbra, although that is not absolutely necessary it is certainly computer-friendly and handles the general case well.<br /><br />Sure there are some cases where we can apply an average impulse to a mean point of contact - we can do it if there is an edge / face collision involving only two bodies.<br />But if a body collides with more than one other body (say, it hits two walls in a corner), or if there are MORE than two points of contact (police car lands on its roof) then we can&#039;t cheat.<br /><br />We need to find (for each simultaneous contact) a linear impulsive force which satisfies an entire set of constraints - those of the local collision event, and those of all the other simultaneous contacts.<br /><br /></div>
    <div class="meta">Posted on 2009-01-02 19:44:41 by Homer</div>
   </div>
   <div class="post" id="post-206653">
    <div class="subject"><a href="#post-206653">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body"><div class="quote"><br />OK I&#039;ll rephrase the question.<br />Who has experience in using matrix operations to solve non-trivial simultaneous equations?<br /><br /></div><br /><br />Are we supposed to use Gaussian elimination to solve such a problem? http://en.wikipedia.org/wiki/Gaussian_elimination I have C code for it...</div>
    <div class="meta">Posted on 2009-01-02 23:29:04 by roticv</div>
   </div>
   <div class="post" id="post-206654">
    <div class="subject"><a href="#post-206654">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">That will work for a collision with just two points of contact, since (without proof) we are working with matrices that ALWAYS have a clean inverse... however it won&#039;t work for three or more contacts.<br />Same for Jacobian rotation (another way to row-reduce a matrix).<br /><br />Perhaps I&#039;d be better off either describing the simultaneous equations I am talking about in matrix form so you can see the problems for yourself, and maybe posting some simple sketches that show why summed / averaged vectors don&#039;t provide an accurate solution.<br /><br />Perhaps accuracy isn&#039;t even that important, since I am game-oriented in terms of my aspirations... perhaps I should just settle for &#039;visibly plausable&#039; rather than &#039;physically accurate&#039; - but if I do, I will never be able to create &#039;stacking&#039; simulations - if I accept that I don&#039;t need stacking, I can forget this whole problem.... although stacking certainly seems like a reasonable expectation, even for lowly game simulation.<br /><br />As things stand, I don&#039;t even distinguish between Resting and Colliding contacts - although I understand that this is the currently preferred model.<br /><br /><br /></div>
    <div class="meta">Posted on 2009-01-03 04:28:12 by Homer</div>
   </div>
   <div class="post" id="post-206655">
    <div class="subject"><a href="#post-206655">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">OK - this post will make a few assumptions, and shed a little light on my current thoughts.<br />Let&#039;s assume that there are more than two contacts, and that those contacts are striking a body &#039;off-center&#039;.<br /><br />We need to think about the linear and angular characteristics of our body as being completely separated.<br /><br />The impulses we will apply to the body are equal and opposide to the impact forces, which are linear.<br />These impulses are applied at / to the points of contact.<br /><br />Linear impulses applied to an arbitrary contact point can be further split into their effects apon the center of mass (linear and angular).<br /><br />Speaking of the linear, a linear force applied ANYWHERE on the body DIRECTLY affects the center of mass - we can say that ALL of the linear force is applied &quot;linearly&quot; at the center of mass - the whole body is affected linearly.<br /><br />But a linear force applied OFF CENTER OF MASS causes angular effects.<br />It causes a TORQUE, which causes change in angular momentum, which causes change in angular velocity, which causes change in orientation.<br /><br />We can and should treat the linear and angular components separately.<br /><br />LINEAR: We can always use the AVERAGE of the input forces, since they are always all applied to the center of mass.<br /><br />ANGULAR: We can always use the SUM of the input forces, since they always tend toward the Origin of the Body (else there is no collision) and thus at opposing extremes, cancel each other out.<br /><br />I think this will create plausible results in all cases - not physically accurate, but visibly plausible.<br />I will attempt to sketch some examples to prove this before I code it.<br /><br />If I am right, I am a very! happy man, because I outsmarted those nasty mathematicians using intuition alone.<br /></div>
    <div class="meta">Posted on 2009-01-03 06:14:21 by Homer</div>
   </div>
   <div class="post" id="post-206660">
    <div class="subject"><a href="#post-206660">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">OK, here&#039;s some visual examples of some multipoint collisions. They&#039;re only 2D, and they&#039;re relatively simplistic examples, but I think they&#039;re useless nonetheless.<br /><br />Example 1: <br />A box has fallen flat, and on to flat ground. <br />The red circles indicate two points of impact, and the red arrows indicate the impulses which result from the collision forces. <br />The green circle indicates the center of mass, and the green arrow indicates the total impulse applied to the center of mass. As we can see, it is an AVERAGE of the two input impulses... if we SUMMED them, the green arrow would be twice as long as the red ones, and we&#039;d have too much collision response. It&#039;s pretty clear that there is NO ROTATION resulting from these two collisions - actually there is, but it cancels out perfectly... this proves that the impulse torques SHOULD BE SUMMED... why dont we average them too? lets see another example.<br /><br />Example 2:<br />A box has fallen flat, and into a Valley (ie a&nbsp; vee)<br />This time we have some (thin) purple arrows which show the (angular) Torque forces, which are applied on a radius from the center of mass (the radii are shown as thick purple lines).<br />Now we can see more clearly that these angular forces are cancelling out when we add them together.<br />But we still can&#039;t see why we can&#039;t average them.. so one more example.<br /><br />Example 3:<br />The box is in &#039;mid air&#039;, not touching the ground.<br />We&#039;re applying two forces at two diagonally opposite corners, and in different directions.<br />The linear forces cancel each other out.<br />But the angular forces MUST BE SUMMED... if they were averaged, we&#039;d have HALF the angular force that we would expect, it would be as if only one of the impacts occurred.<br />Intuition tells us that we should expect the box to rotate TWICE as much with both contacts affecting the box.<br />And it also tells us that we expect the linear result of the impact to be Zero.<br /><br />So in summary - if we Average the linear forces, and Sum the angular forces, we should get realistic outcomes in all cases.<br /><br />What do YOU think? Do you agree? No? Why?<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2705" target="_blank">phys_1.JPG</a></li>
      <li><a href="../../attachments/?id=2707" target="_blank">phys_2.JPG</a></li>
      <li><a href="../../attachments/?id=2709" target="_blank">phys_3.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-01-04 21:26:58 by Homer</div>
   </div>
   <div class="post" id="post-206661">
    <div class="subject"><a href="#post-206661">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I&#039;ve implemented the few small changes necessary to deal with the proposed solution to the problem of multiple contact as described above.<br /><br />However while doing so, I noticed a rather big problem in my collision response.<br />I&#039;m not fixing up the angular velocity after a collision occurs !!!<br /><br />Let&#039;s look closely at the series of equations that I use to INTEGRATE a body forwards in time..<br />Here we can see how I am extracting a new AngularVelocity from the change in orientation due to the old AngularVelocity..<br /><br />1: NewAngularMomentum = OldAngularMomentum + (Torque * Time)<br />2: NewOrientation = OldOrientation + (Star(Old AngularVelocity) * Time)<br />3: (orthonormalize the NewOrientation)<br />4: invWorldInertiaTensor = NewOrientation * invBodyInertiaTensor * Transpose (OldOrientation)<br />5: New AngularVelocity = invWorldInertiaTensor * NewAngularMomentum<br /><br />Please note that for collision response, we don&#039;t need to alter the orientation, since the collision is assumed to have occured &#039;instantly&#039; (no time has passed).. orientation will change during the NEXT call of the Integrate function (ie, as the body bounces away from the collision)... but for that to happen correctly, we need to already know the post-collision angular velocity.<br /><br />We already know the new angular momentum.<br />Can we rearrange these equations to give us a new angular velocity?<br />Is it actually necessary?<br /><br />My guess : since no time has passed, the invWorldInertiaTensor has not changed... it should be perfectly legal to just use Step 5 and update our new angular velocity from the new angular momentum and the invWorldInertiaTensor which we already calculated in the Integrate function.<br /><br />I would like to hear your opinion!</div>
    <div class="meta">Posted on 2009-01-05 00:03:26 by Homer</div>
   </div>
   <div class="post" id="post-206673">
    <div class="subject"><a href="#post-206673">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Disappointed that nobody has an opinion on this.<br />Anyway, I won&#039;t know if this works until I have implemented &#039;higher order&#039; polygons than Sphere (which means ANY other polytope, eg Box)... I suspect I might have to INVERT the already-inverted worldspace inertia tensor.<br /><br />Speaking of high-order polygons, I am currently inclined to implement a general purpose 3D mesh class as my next step, rather than implement other Plutonic polytopes (cone, cylinder etc) which are not &#039;triangle-friendly&#039;.<br /><br />Last time, I tried to implement a hierarchy of polytopes based on their complexity, I still feel that was the right path, however I am impatient... I want to describe the WORLD, or at least chunks of it, as just another physics body I can collide with.<br /><br />On another topic, I had a thought last night about Networked physics.<br />Typically, the physics is performed on both the server and the clients (but only the server does collision handling), and the server sends all the clients information whenever a physical body diverts from its current trajectory (ie due to a collision, or for player models, due to actions of the player).<br />In most 3D multiplayer games, players don&#039;t typically move in straight lines for long periods, and from the Client perspective, why the hell do we care about the physical state of something that is not visible?<br />It seems worthy to try sending only the combined world transform of currently-visible objects to each Client.<br />This means two things: firstly, the Client doesn&#039;t need a physics engine AT ALL ... and secondly, the Client does not have to perform ANY visibility checks - it simply draws what it is told to draw.<br />This places a little more cpu load on the Server, but I suspect it will actually REDUCE network bandwidth considerably in a massively-multiplayer scenario, while freeing up valuable clientside cpu time for even more eyecandy!<br /><br />Please, your opinion?</div>
    <div class="meta">Posted on 2009-01-06 00:05:57 by Homer</div>
   </div>
   <div class="post" id="post-206677">
    <div class="subject"><a href="#post-206677">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Homer, I think your solution for the 1st example isn&#039;t quite right. I think the points of impact is throughout all the points in contact with the ground. Yeah for your last example it should be rotating.<br /><br />Haha you need a physics major. I&#039;m only a mathematics major.&nbsp; ;)</div>
    <div class="meta">Posted on 2009-01-08 09:00:46 by roticv</div>
   </div>
   <div class="post" id="post-206678">
    <div class="subject"><a href="#post-206678">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Victor, I agree with that.. #1 is really a &#039;contact region&#039; problem - however, my understanding is that this has no bearing on impact forces, its only related to the application of friction and restitution which slightly changes the contact resolution - ie theres more friction because theres more surface area in contact, but if we disregard this, the collision can be resolved by using the bounding points. The difference is tiny for a &#039;head-on&#039; collision, but gets larger if the object is sliding... basically, I&#039;m not interested in simulating physics with absolute accuracy, I&#039;m more interested in producing realistic (plausible) outcomes with as few cycles as possible.<br />Still, if any physics majors happen to read this thread, I&#039;d love to hear from them :)<br /><br /></div>
    <div class="meta">Posted on 2009-01-08 09:21:28 by Homer</div>
   </div>
   <div class="post" id="post-206685">
    <div class="subject"><a href="#post-206685">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Networked physics: I&#039;ve decided that Clients should all run a simulator.<br />Client will inform Server if/when the user presses a &#039;player control&#039;.<br />Server will broadcast this to all other Clients WHO CAN SEE THAT PLAYER.<br /><br />From the client point of view, if another player is on your screen, you&#039;re getting sent data about which keys/controls they are pressing... and when another player becomes visible for the first time, or they collide with something, you&#039;re getting sent the full physics state as well.<br /><br />So we only get sent data about the physical state of on-screen players when they first breach the view frustum, or they bounced off something and their trajectory changed.<br /><br />This way we further minimize the amount of data being sent by the server to the clients, and take more advantage of dead-reckoning on the client side.<br /><br /></div>
    <div class="meta">Posted on 2009-01-09 09:30:09 by Homer</div>
   </div>
   <div class="post" id="post-206686">
    <div class="subject"><a href="#post-206686">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Today I decided to add support for CollisionTriangle.<br />Because I&#039;m such a nice guy, I&#039;ve given code for the most primitive triangle-based collision method.. it tests if a given 3D point (assumed to be on the triangle&#039;s plane) is inside the Triangle, or outside of it.. I&#039;ve called it CollisionTriangle.versus_Point :) We&#039;d expect to call a preliminary method to test for intersection of (eg) a Ray and a Plane, and then pass the intersection point to this method to see if we actually hit the triangle.<br />There&#039;s an update of the CollisionBody.inc file attached below.<br /><br />The inheritance hierarchy for collidable stuff now looks like this:<br /><br />CollisionShape<br />--CollisionPlane<br />----CollisionTriangle<br />--CollisionBody<br />----CollisionSphere<br /><br />As we derive more complex entities, we will add them to this tree, taking full advantage of the power of Object Oriented Programming in the way it was intended to be used (rather than merely for the sake of it).<br /><br />Soon we&#039;ll need to depart from this clean tree somewhat, as we&#039;ll be deriving shapes which are based apon other shapes... for example, a 3D cube will be composed of triangles and planes.<br /><br />When we get to that stage, I&#039;ll probably improve the way I am storing the points (vertices) of the primitives (most likely I&#039;ll index a global array rather than keep duplicate points everywhere).<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2712" target="_blank">CollisionBody.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-01-10 01:24:43 by Homer</div>
   </div>
   <div class="post" id="post-206689">
    <div class="subject"><a href="#post-206689">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I see that this thread is still popular, so I will continue with my public posts.<br />It should be clear by now that the class which performs all the physics stuff is separate from the class(es) which performs the collision detections.<br /><br />Our main physics body class works for ANY SHAPE... it does not care, with the exception of the Inertia Tensor...<br />But the collision detection depends on the shape of the body.</div>
    <div class="meta">Posted on 2009-01-11 07:58:30 by Homer</div>
   </div>
   <div class="post" id="post-206699">
    <div class="subject"><a href="#post-206699">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Today saw the introduction of two new classes.<br /><br />CollisionPolygon derives from CollisionBody, it is a baseclass for arbitrary 3D polygons.<br />CollisionBox derives from CollisionBody, it describes a 3D Box-shaped collision hull.<br /><br />I will be removing the CollisionTriangle class... since CollisionPolygon stores a list of collision primitives (points, edges, planes, triangles) which have been defined as simple structs.<br />Its functionality will be absorbed by the CollisionPolygon class in the immediate future.<br /><br />Also, I will be removing the fields and methods of CollisionBody which deal with the physical State of a Body, and moving them into a new class called PhysicalEntity: CollisionBody and its relatives will describe a Reference geometrical entity, while PhysicalEntity will describe a LIVING INSTANCE of a CollisionBody, and that&#039;s where the State information really belongs.<br /><br />PhysicalEntity will not derive from any existing class: it will be &#039;friendly&#039; with the Collision classes, and will use a pointer field to identify which (previously-created) collision geometry best describes it.<br /><br />Finally, I will be writing a PhysicalMeshEntity class which derives from PhysicalEntity, and those will represent the Living Instances of a D3D_Mesh object.<br /><br />It&#039;s nice when you find a good design pattern, everything falls into place, even if it took a while to find the right path.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2009-01-12 08:59:27 by Homer</div>
   </div>
   <div class="post" id="post-206702">
    <div class="subject"><a href="#post-206702">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I made a mistake in my last post.<br />CollisionBox derives from CollisionPolygon.<br /><br />It should be obvious?</div>
    <div class="meta">Posted on 2009-01-13 02:48:19 by Homer</div>
   </div>
   <div class="post" id="post-206721">
    <div class="subject"><a href="#post-206721">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I&#039;ve done a fair bit of work to split the CollisionBody class, mostly to improve the use of memory when the number of physical entities is high (yes, I am optimistic).<br /><br />CollisionBody now represents the BodySpace geometry and mass attributes of a physical body, but does not describe anything about its physical State (ie, there is no Position, there is no Orientation, there is no Velocity).<br /><br />A new class called CollisionBodyInstance contains the physical State information, as well as a pointer to a CollisionBody (and thus any number of instances can share the same reference object).<br /><br />I&#039;ve decided to store all instances in one collection (in the Simulator), in order to keep the code loops as unrolled as possible, and in order to reduce cache misses during broad-phase collision testing.<br /><br />We now have two object trees that look like this:<br /><br />-CollisionShape<br />----CollisionPlane<br />--------CollisionTriangle<br />----CollisionBody<br /><br />-CollisionBodyInstance<br />----CollisionPolygon<br />--------CollisionBox<br /><br />...and you can draw a nice pointy arrow from CollisionBodyInstance to CollisionBody.<br /><br />I&#039;m fairly unhappy with the naming convention now, but CollisionPolygonInstance is rather long to type :P<br /><br />I think I can safely merge the code from the CollisionPlane and CollisionTriangle classes into CollisionPolygon, and get rid of CollisionShape completely, leaving me with only CollisionBody in the upper object tree.<br />That will mean that all the point/plane styled collisions will be handled by CollisionPolygon, which makes sense to me.<br />I will leave the lower object tree alone, as I intend to add &#039;implicit&#039; geometries later (ellipses, cones, cylinders etc).<br /><br />Guess I&#039;ll post another update soon :)<br /></div>
    <div class="meta">Posted on 2009-01-18 23:27:03 by Homer</div>
   </div>
   <div class="post" id="post-206724">
    <div class="subject"><a href="#post-206724">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I&#039;ve finished moving code from one class to another (for now).<br /><br />We now have:<br />Collision Primitive structs (Point, Edge, Plane).<br />CollisionBody (reference object), and its derived D3D_CollisionMesh.<br />CollisionBodyInstance, and its derived classes (CollisionBox,CollisionPolygon,D3D_PhysicalEntity).<br /><br />The simulator operates apon INSTANCE objects, but is aware of REFERENCE objects.<br />For now, the ref objects are stored outside the simulator (ie, in the application).<br /><br />Any questions? I&#039;m ok to answer any and all relevant questions at this time.<br /></div>
    <div class="meta">Posted on 2009-01-19 03:18:48 by Homer</div>
   </div>
   <div class="post" id="post-206732">
    <div class="subject"><a href="#post-206732">Re: Static, collidable game scenery</a></div>
    <div class="body">I haven&#039;t done a lot of coding in the past few days, but today I did add a new attribute (switch) to the CollisionBodyInstance class which allows us to defy the laws of physics for a body instance which is &#039;static&#039; - no forces (gravity, collisions) will ever affect it, it will not rotate or move, it is a static part of the physical world (this could be thought of as the equivalent a zero dof constraint). This means that much of the game world can be constructed from physical mesh instances (ie using a custom level editing tool and/or scripts) rather than laboriously constructed from unique surfaces in a 3D modeling application.<br />Of course, you&#039;ll still need to create the reference meshes in a 3D modeling app... but having done so, you can import them into the game and create as many instances as you like, rotating and positioning each instance to suit yourself, while arbitrarily declaring instances as being static or dynamic.<br />This being the case, it might be cool if we can disable (collision detection and rendering for) given faces of a given instance, knowing that these faces will always be occluded.... but I&#039;ll leave such optimizing until I have a rough &quot;in-game&quot; level editor.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2009-01-22 00:12:37 by Homer</div>
   </div>
   <div class="post" id="post-206742">
    <div class="subject"><a href="#post-206742">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Today I made a few small but interesting changes.<br />CollisionBodyInstance.Integrate is now a Dynamic method.<br />It is redefined in the derived CollisionPolygon class, where extra code has been added which transforms the bounding points from bodyspace to worldspace.<br /><br />Now, whenever the Integrate method is called, the WorldSpace bounding points are recomputed automagically :)<br />This is incredibly important for the &#039;narrow&#039; (aka &#039;discrete&#039;) collision testing.<br /><br />In my next post, I&#039;ll begin to discuss collision tests for 3D convex polygons other than the Sphere.<br />There&#039;s almost as many opinions about this stuff as there are implementations, let&#039;s explore :)</div>
    <div class="meta">Posted on 2009-01-23 02:43:26 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29229&amp;page=1" style="">&laquo;</a><a href="../?id=29229&amp;page=3" style="">&lt;</a><input type="hidden" name="id" value="29229" /><input type="number" name="page" min="1" max="7" step="1" value="4" onchange="this.form.submit();" /><a href="../?id=29229&amp;page=5">&gt;</a><a href="../?id=29229&amp;page=7">&raquo;</a></form>  </div>
 </body>
</html>