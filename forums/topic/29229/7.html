<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Better, Faster, Stronger Physics 2009 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29229" />
  <link rel="prev" href="../?id=29229&amp;page=6" />   </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29229">Better, Faster, Stronger Physics 2009</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29229&amp;page=1" style="">&laquo;</a><a href="../?id=29229&amp;page=6" style="">&lt;</a><input type="hidden" name="id" value="29229" /><input type="number" name="page" min="1" max="7" step="1" value="7" onchange="this.form.submit();" /></form>   <div class="post" id="post-207241">
    <div class="subject"><a href="#post-207241">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">In this post, I&#039;ll provide code for Separation Test of a Sphere and an arbitrary Mesh.<br />The following post will contain code for Contact Generation of a Sphere/Mesh pair.<br /><br />As mentioned previously, I use a special kind of Tree for accelerating collision detection against arbitrary meshes. You&#039;ll see me calling them SphereTrees, and also BVH&#039;s (Bounding Volume Hierarchies).<br /><br />The CollisionBodyInstance class (baseclass for the various collision shapes) defines several &#039;Dynamic Abstract&#039; methods which are of interest to us - I&#039;ll list them below. These are placeholders for functions which are defined in classes which derive from CollisionBodyInstance... the abstracts we&#039;re interested in are:<br />versus_Sphere<br />versus_Mesh<br />Find_Contacts_versus_Sphere<br />Find_Contacts_versus_Mesh<br /><br />Now if we look at the D3D_PhysicalEntity class, we can see some of these methods have been &#039;redefined&#039; - and since they are &#039;dynamic&#039;, any calls to these methods in the Ancestor (CollisionBodyInstance) class are marshalled to those methods in the Derived classes.<br /><br />We can redefine these methods in EACH derived class, so we can have &#039;box versus sphere&#039;, etc, just by &#039;overloading&#039; the same method...<br />When we define D3D_PhysicalEntity.versus_Sphere, we&#039;re really defining a &#039;Mesh Versus Sphere&#039; test.... hope this makes sense :)<br /><br /><pre><code><br />Method D3D_PhysicalEntity.versus_Sphere,uses esi,pSphere<br />LOCAL vtemp:Vec3<br />&nbsp; &nbsp; SetObject esi<br /><br />&nbsp; &nbsp; ;We will perform our tests in &#039;this body&#039;s space&#039;<br />&nbsp; &nbsp; ;(which is where we defined the BVH)<br />&nbsp; &nbsp; ;so the triangles and their planes are all legal values<br />&nbsp; &nbsp; ;(we avoid transforming the triangles and planes)<br />&nbsp; &nbsp; ;Therefore we need to get the input Sphere into &#039;this space&#039;.<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Transform the Origin of input Sphere <br />&nbsp; &nbsp; ;from WorldSpace into &#039;this&#039; bodyspace<br />&nbsp; &nbsp; ;vtemp = Sphere&#039;s origin in &#039;this&#039; space...<br />&nbsp; &nbsp; mov edi,pSphere<br />&nbsp; &nbsp; OCall esi.Transform_Vec3_WorldToBody, addr .CollisionBodyInstance.NewState.CMPosition,&nbsp; addr .NewState.Orientation <br />&nbsp; &nbsp; Vec3_Stow vtemp<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; ;Pass the Root Node of the owner body&#039;s SphereTree to our recursive function<br />&nbsp; &nbsp; mov edx,.pOwner<br />&nbsp; &nbsp; OCall esi.Short_recurse_Sphere,pSphere,.D3D_CollisionMesh.pRootNode,addr vtemp<br />MethodEnd<br /></code></pre><br /><br />Given a pointer to an entity that uses a spherical hull, and called apon an entity that uses a Mesh BVH, this method wraps a call to the recursive function (below).<br />We &#039;walk the tree&#039;, testing the input sphere against the boundingsphere described by each Tree Node, until we find Leaf Nodes whose boundingsphere intersects the input sphere.<br />Since our special Tree has Leaf nodes which contain One Triangle each, we can then test for intersection of the input sphere versus each Leaf triangle.<br />This function will terminate early if Penetration is detected.<br /><br /><pre><code><br />;Recursive separation test of BoundingSphere and Mesh&#039;s BVH (using &#039;New&#039; State)<br />;Test will exit as soon as penetration of a triangle is detected.<br />;pSphere = ptr to input CollisionBodyInstance (type = sphere)<br />;pNode&nbsp; &nbsp;= ptr to input BSPNode (Node in SphereTree)<br />;pvOrigin= ptr to Vec3 containing Origin of input Sphere, in this Mesh&#039;s BodySpace<br />;Returns Penetrating, Colliding, or Clear<br />Method D3D_PhysicalEntity.Short_recurse_Sphere,uses esi edi ebx,pSphere,pNode,pvOrigin<br />LOCAL vtemp:Vec3<br />LOCAL distance:real8<br />LOCAL sumrad:real8<br />LOCAL result<br /><br />&nbsp; &nbsp; SetObject esi<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; mov result,Clear<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Calculate the distance between the origins of the input boundingsphere<br />&nbsp; &nbsp; ;and the input Node&#039;s boundingsphere...<br />&nbsp; &nbsp; mov edx,pvOrigin<br />&nbsp; &nbsp; mov eax,pNode<br />&nbsp; &nbsp; Vec3_Distance .BSPNode.vOrigin, .Vec3<br />&nbsp; &nbsp; fstp distance<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Calculate the Sum of the radii<br />&nbsp; &nbsp; mov edx,pNode<br />&nbsp; &nbsp; fld .BSPNode.fRadius<br />&nbsp; &nbsp; mov edx,pSphere<br />&nbsp; &nbsp; mov edx,.CollisionBodyInstance.pOwner<br />&nbsp; &nbsp; fadd .CollisionBody.fRadius<br />&nbsp; &nbsp; fstp sumrad<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;If the distance is greater than the sum of the radii,<br />&nbsp; &nbsp; ;then the sign is Positive for separation<br />&nbsp; &nbsp; ;Otherwise it is Negative for penetration<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;If sumradsqu &gt;= distance then collision/penetration are possible<br />&nbsp; &nbsp; .if $IsGreaterOrEqual(sumrad,distance)==TRUE<br /><br />&nbsp; &nbsp; @@: mov eax,pNode<br />&nbsp; &nbsp; &nbsp; &nbsp; .if .BSPNode.pFaces==0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;It&#039;s NOT a Leaf Node, so there MUST be Two Children (right?)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Recurse front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov edx,pNode<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or result,$OCall (esi.Short_recurse_Sphere,pSphere,.BSPNode.pFront,pvOrigin)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==Penetrating<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Recurse back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov edx,pNode<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or result,$OCall (esi.Short_recurse_Sphere,pSphere,.BSPNode.pBack,pvOrigin)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==Penetrating<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;It&#039;s a Leaf Node, so it should contain a single triangle<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;represented by a Face struct... we should find this<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;lonely triangle as the only element within a Collection (ugh)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,pNode<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,.BSPNode.pFaces<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,.DataCollection.pItems<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,&nbsp; &nbsp; &nbsp; ;ptr to Face struct<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Test for intersection of Triangle and Sphere&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;or result,$OCall (esi.Triangle_versus_Sphere,edx,pSphere)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==Penetrating<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endIf<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; mov eax,result<br />MethodEnd<br /></code></pre><br /><br />Given that our Tree is a simple Binary Tree structure, I guess most of you reading this won&#039;t have too much trouble understanding the code presented today.<br />I&#039;ll wrap this post up with code for testing Sphere/Triangle.<br />The remaining code can be found in the Physics_Classify.inc file posted previously.<br /><pre><code><br />;Compare (the New State of) a Sphere and a 3D Triangle given as a Face in BodySpace<br />;Return Penetrating, Separating or Clear<br />Method CollisionBodyInstance.Triangle_versus_Sphere,uses esi, pTriangleFace, pSphere<br />LOCAL temp:Vec3<br />LOCAL vSphereOrigin:Vec3<br />local dist<br />LOCAL tri:triangle<br />&nbsp; &nbsp; SetObject esi<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Transform the Sphere into Triangle Space<br />&nbsp; &nbsp; mov edx,pSphere<br />&nbsp; &nbsp; OCall esi.Transform_Vec3_WorldToBody, addr .CollisionBodyInstance.NewState.CMPosition, addr .NewState.Orientation<br />&nbsp; &nbsp; Vec3_Stow vSphereOrigin<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Find closest point on Sphere to Plane of triangle<br />&nbsp; &nbsp; mov eax,pTriangleFace<br />&nbsp; &nbsp; mov eax,.Face.pPlane<br />&nbsp; &nbsp; Vec3_Neg temp,.Vec3<br />&nbsp; &nbsp; mov edx,pSphere<br />&nbsp; &nbsp; mov edx,.CollisionBodyInstance.pOwner<br />&nbsp; &nbsp; Vec3_Scale temp,.CollisionBody.fRadius<br />&nbsp; &nbsp; Vec3_AddFrom vSphereOrigin<br />&nbsp; &nbsp; Vec3_Stow temp<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Find the distance from that point to the plane<br />&nbsp; &nbsp; mov edx,pTriangleFace<br />&nbsp; &nbsp; mov edx,.Face.pPlane<br />&nbsp; &nbsp; Vec3_Distance_Plane temp,.Vec4<br />&nbsp; &nbsp; fstp dist<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;If the distance is greater than zero theres no collision<br />&nbsp; &nbsp; .if $IsPositive(dist)==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; ;If the distance is less than Epsilon<br />&nbsp; &nbsp; &nbsp; &nbsp; .if $IsLess(dist,fEpsilon)==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jmp @F<br />&nbsp; &nbsp; &nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Clear<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;We&#039;re definitely penetrating the Plane..<br />&nbsp; &nbsp; ;Let&#039;s project our test point onto the Plane<br />&nbsp; &nbsp; ;by moving it in the direction of the Normal<br />&nbsp; &nbsp; ;by the amount of Penetration Distance<br />&nbsp; &nbsp; mov edx,pTriangleFace<br />&nbsp; &nbsp; mov edx,.Face.pPlane<br />&nbsp; &nbsp; Vec3_Scale .Vec4,dist<br />&nbsp; &nbsp; Vec3_AddFrom vSphereOrigin<br />&nbsp; &nbsp; Vec3_Stow temp<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Convert face to triangle struct<br />&nbsp; &nbsp; mov edx,pTriangleFace<br />&nbsp; &nbsp; mov eax, .Face.pV0<br />&nbsp; &nbsp; Vec3_Load .Vec3<br />&nbsp; &nbsp; Vec3_Stow tri.v0<br />&nbsp; &nbsp; mov eax, .Face.pV1<br />&nbsp; &nbsp; Vec3_Load .Vec3<br />&nbsp; &nbsp; Vec3_Stow tri.v1<br />&nbsp; &nbsp; mov eax, .Face.pV2<br />&nbsp; &nbsp; Vec3_Load .Vec3<br />&nbsp; &nbsp; Vec3_Stow tri.v2<br />&nbsp; &nbsp; ;Is the point inside the triangle?<br />&nbsp; &nbsp; ;If so, we have our intersection point.<br />@@: invoke PointInTriangle, addr tri,.Face.pPlane, addr temp<br />&nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; .if $IsLess(dist,fEpsilon)==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Penetrating<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; mov eax,Clear<br />&nbsp; &nbsp; <br />MethodEnd<br /></code></pre><br /><br />As I said, the next post will contain code for Contact Generation of Sphere/Mesh.<br /><br /></div>
    <div class="meta">Posted on 2009-04-06 19:25:04 by Homer</div>
   </div>
   <div class="post" id="post-207256">
    <div class="subject"><a href="#post-207256">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Generating a list of Contacts been a Mesh and a Sphere is a similar process to collision detection - we must once more recurse the BVH against the Sphere, however this time we will do so more thoroughly, determining points of contact as we do so.<br />Again, our recursion begins from a &#039;wrapper&#039; method which passes the Root Node of the BVH to the search function:<br /><br /><pre><code><br />;This method finds all the contacts for a Mesh/Sphere CollisionPair.<br />;pSphere &nbsp; = &#039;other body&#039; (derived from CollisionBodyInstance)<br />;pPair &nbsp; &nbsp; = CollisionPair<br />;pContacts = output list of Contacts<br />Method D3D_PhysicalEntity.Find_Contacts_versus_Sphere,uses esi,pSphere,pPair,pContacts<br />LOCAL vSphereOrigin:Vec3<br /> &nbsp; &nbsp;SetObject esi<br /> &nbsp; &nbsp;<br /> &nbsp; &nbsp;;Transform the input Sphere from WorldSpace to this mesh&#039;s BodySpace<br /> &nbsp; &nbsp;mov edi,pSphere<br /> &nbsp; &nbsp;OCall esi.Transform_Vec3_WorldToBody, addr .CollisionBodyInstance.NewState.CMPosition, &nbsp;addr .NewState.Orientation <br /> &nbsp; &nbsp;Vec3_Stow vSphereOrigin<br /> &nbsp; &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp;;Pass the Root Node of the owner body&#039;s SphereTree to our recursive function<br /> &nbsp; &nbsp;mov edx,.pOwner<br /> &nbsp; &nbsp;OCall esi.Long_recurse_Sphere,pSphere,.D3D_CollisionMesh.pRootNode,addr vSphereOrigin,pPair,pContacts<br />MethodEnd<br /></code></pre><br /><br />Nothing much to see there.<br />Let&#039;s look at the recursive function:<br /><pre><code><br />;Recursive search for Contacts between Mesh and Sphere<br />;Returns nothing<br />Method D3D_PhysicalEntity.Long_recurse_Sphere,uses esi edi ebx,pSphere,pNode,pvOrigin,pPair,pContacts<br />LOCAL vtemp:Vec3<br />LOCAL distance:real8<br />LOCAL sumrad:real8<br />LOCAL result<br /><br /> &nbsp; &nbsp;SetObject esi<br /> &nbsp; &nbsp;<br /> &nbsp; &nbsp;mov edx,pvOrigin<br /> &nbsp; &nbsp;Vec3_Dot .Vec3,.Vec3<br /> &nbsp; &nbsp;mov edx,pvOrigin<br /> &nbsp; &nbsp;mov eax,pNode<br /> &nbsp; &nbsp;Vec3_Distance .BSPNode.vOrigin, .Vec3<br /> &nbsp; &nbsp;fstp distance<br /> &nbsp; &nbsp;<br /> &nbsp; &nbsp;mov edx,pNode<br /> &nbsp; &nbsp;fld .BSPNode.fRadius<br /> &nbsp; &nbsp;mov edx,pSphere<br /> &nbsp; &nbsp;mov edx,.CollisionBodyInstance.pOwner<br /> &nbsp; &nbsp;fadd .CollisionBody.fRadius<br /> &nbsp; &nbsp;fstp sumrad<br /><br /> &nbsp; &nbsp;.if $IsGreaterOrEqual(sumrad,distance)==TRUE<br /> &nbsp; &nbsp;@@: mov eax,pNode<br /> &nbsp; &nbsp; &nbsp; &nbsp;.if .BSPNode.pFaces==0<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,pNode<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall esi.Long_recurse_Sphere,pSphere,.BSPNode.pFront,pvOrigin,pPair,pContacts<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,pNode<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall esi.Long_recurse_Sphere,pSphere,.BSPNode.pBack,pvOrigin,pPair,pContacts<br /> &nbsp; &nbsp; &nbsp; &nbsp;.else<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,pNode<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,.BSPNode.pFaces<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,.DataCollection.pItems<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx, &nbsp; &nbsp;<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or result,$OCall (esi.Triangle_Contact_Sphere,edx,pSphere,pPair,pContacts)<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.if eax!=Clear<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp; &nbsp; &nbsp;.endIf<br /> &nbsp; &nbsp;<br /> &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp;mov eax,result<br />MethodEnd<br /></code></pre><br /><br />This method walks the BVH tree until it finds Leaf nodes whose boundingspheres intersect the input sphere, then it tests the Triangle in each discovered leaf against the input sphere using the following method:<br /><br /><pre><code><br />;Generate a Contact between Triangle and Sphere<br />;Returns nothing<br />Method CollisionBodyInstance.Triangle_Contact_Sphere,uses esi, pTriangleFace, pSphere, pPair, pContacts<br />LOCAL temp:Vec3,norm:Vec3<br />LOCAL vSphereOrigin:Vec3<br />local dist<br /> &nbsp; &nbsp;SetObject esi<br /> &nbsp; &nbsp;<br /> &nbsp; &nbsp;;Transform the Sphere into Triangle Space (avoid recalculate plane)<br /> &nbsp; &nbsp;;or transform the Triangle into World space (need new points and plane)<br /> &nbsp; &nbsp;mov edx,pSphere<br /> &nbsp; &nbsp;OCall esi.Transform_Vec3_WorldToBody, addr .CollisionBodyInstance.NewState.CMPosition, addr .NewState.Orientation<br /> &nbsp; &nbsp;Vec3_Stow vSphereOrigin<br /> &nbsp; &nbsp;<br /> &nbsp; &nbsp;;Find closest point on Sphere to Plane of triangle<br /> &nbsp; &nbsp;mov eax,pTriangleFace<br /> &nbsp; &nbsp;mov eax,.Face.pPlane<br /> &nbsp; &nbsp;Vec3_Neg temp,.Vec3<br /> &nbsp; &nbsp;mov edx,pSphere<br /> &nbsp; &nbsp;mov edx,.CollisionBodyInstance.pOwner<br /> &nbsp; &nbsp;Vec3_Scale temp,.CollisionBody.fRadius<br /> &nbsp; &nbsp;Vec3_AddFrom vSphereOrigin<br /> &nbsp; &nbsp;Vec3_Stow temp<br /> &nbsp; &nbsp;<br /> &nbsp; &nbsp;;Find the distance from that point to the plane<br /> &nbsp; &nbsp;mov edx,pTriangleFace<br /> &nbsp; &nbsp;mov edx,.Face.pPlane<br /> &nbsp; &nbsp;Vec3_Distance_Plane temp,.Vec4<br /> &nbsp; &nbsp;fstp dist<br /> &nbsp; &nbsp;<br /> &nbsp; &nbsp;;If the distance is greater than zero theres no collision<br /> &nbsp; &nbsp;.if $IsPositive(dist)==TRUE<br /> &nbsp; &nbsp; &nbsp; &nbsp;;If the distance is less than Epsilon<br /> &nbsp; &nbsp; &nbsp; &nbsp;.if $IsLess(dist,fEpsilon)==TRUE<br /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp @F<br /> &nbsp; &nbsp; &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp;.endif<br /> &nbsp; &nbsp;<br /> &nbsp; &nbsp;;We&#039;re definitely penetrating the Plane..<br /> &nbsp; &nbsp;;Let&#039;s project our test point onto the Plane<br /> &nbsp; &nbsp;;by moving it in the direction of the Normal<br /> &nbsp; &nbsp;;by the amount of Penetration Distance<br /> &nbsp; &nbsp;mov edx,pTriangleFace<br /> &nbsp; &nbsp;mov edx,.Face.pPlane<br /> &nbsp; &nbsp;Vec3_Scale .Vec4,dist<br /> &nbsp; &nbsp;Vec3_AddFrom vSphereOrigin<br /> &nbsp; &nbsp;Vec3_Stow temp<br /> &nbsp; &nbsp;<br /> &nbsp; &nbsp;;We have our intersection point.<br />@@: <br /> &nbsp; &nbsp;;Transform point &#039;temp&#039; to WorldSpace<br /> &nbsp; &nbsp;mov edx,pSphere<br /> &nbsp; &nbsp;OCall esi.Transform_Vec3_BodyToWorld, addr temp, addr .NewState.Orientation<br /> &nbsp; &nbsp;Vec3_Stow temp<br /> &nbsp; &nbsp;;Rotate the Face Normal from BodySpace to WorldSpace<br /> &nbsp; &nbsp;mov edx,pTriangleFace<br /> &nbsp; &nbsp;mov edx,.Face.pPlane<br /> &nbsp; &nbsp;Mat33_Mul_Vec3 .NewState.Orientation,.Vec3<br /> &nbsp; &nbsp;Vec3_Stow norm<br /> &nbsp; &nbsp;;Generate a Contact<br /> &nbsp; &nbsp;mov edx,pTriangleFace &nbsp; &nbsp; &nbsp; &nbsp;<br /> &nbsp; &nbsp;OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr temp,addr norm) &nbsp; &nbsp; &nbsp; &nbsp;<br />MethodEnd<br /></code></pre><br /><br />There&#039;s my Triangle/Sphere test.<br />It&#039;s quite unlike other tests I&#039;ve seen - it works by back-projecting the most deeply penetrating point on the sphere onto the plane of the triangle, then checking if that point is within the bounds of the triangle.<br /><br />That is the end of the Mesh/Sphere collision detection and contact generation code.<br />In the next exciting episode, we&#039;ll begin to look at the code for Mesh/Mesh collisions and contacts.<br /></div>
    <div class="meta">Posted on 2009-04-08 00:20:08 by Homer</div>
   </div>
   <div class="post" id="post-207270">
    <div class="subject"><a href="#post-207270">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Just a quick post to mention the newest code addition to Simulator class.<br />I&#039;ve implemented a couple of new methods to sink collision event notifications, implemented at two discrete levels of complexity.<br />They are:<br />1 - Simulator.On_Collision_Pair<br />2 - Simulator.On_Collision_Contact<br /><br />Your game or app can override them in order to receive these notifications.<br />The first method is triggered whenever a pair of bodies collides.<br />The value that you return from this method will determine what the Simulator does next.<br />0 - Typical collision response (ie continue to Contact generation etc).<br />1 - Attempt to mark both Bodies for automatic garbage collection (try to destroy both)<br />More values can be added if it seems worthwhile.<br /><br />Anyway, the idea is that when we detect a CollisionPair, we ask the game/app what to do with the two objects.... ie, the game/app figures out what two things just collided and thus whether they go &#039;bounce or boom&#039;.<br />If they go boom, we can mark them as &#039;dead&#039;, we don&#039;t need to deal with them anymore, the internal garbage collection will find them when it is convenient and safe.<br />But if they didn&#039;t explode, the game will receive further notifications as each contact is detected. I may change this. Hell, I might change everything.<br />At the moment, the Simulator ignores the return value for On_Collision_Contact.<br /><br />It&#039;s not much, but it does make the Simulator easier to plug into different games/apps.<br /><br /></div>
    <div class="meta">Posted on 2009-04-09 08:24:28 by Homer</div>
   </div>
   <div class="post" id="post-207295">
    <div class="subject"><a href="#post-207295">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">The Separation test for Mesh/Mesh looks quite similar to the Sphere/Mesh test... well, at least at the beginning it does.. Essentially, we&#039;re going to walk two BVH trees at once in order to identify which triangles from the two meshes are closest together, then we&#039;re testing those pairs of triangles for intersection...<br /><br /><pre><code><br />;Recursive separation test of two Mesh entities via their BVH trees<br />;Returns Penetrating, Colliding, or Clear<br />Method D3D_PhysicalEntity.versus_Mesh,uses esi,pOtherEntity<br />&nbsp; &nbsp; SetObject esi<br />&nbsp; &nbsp; ;Pass the Root Nodes of the two BVH trees to our recursive function<br />&nbsp; &nbsp; mov edx,.pOwner<br />&nbsp; &nbsp; mov eax,pOtherEntity<br />&nbsp; &nbsp; mov eax,.D3D_CollisionMesh.pOwner<br />&nbsp; &nbsp; OCall esi.Short_recurse_Mesh,pOtherEntity,.D3D_CollisionMesh.pRootNode,.D3D_CollisionMesh.pRootNode<br />MethodEnd<br /><br /></code></pre><br /><br />We&#039;re going to perform a &#039;dual tree walk&#039;...<br />Here&#039;s our entrypoint &#039;wrapper&#039; which passes the root nodes of both trees to the following recursive function:<br /><br /><pre><code><br />; Recursive separation test of two Meshes via Dual Tree Recursion<br />; Arguments: None.<br />; Return:&nbsp; &nbsp; Colliding, Penetrating or Clear<br />Method D3D_PhysicalEntity.Short_recurse_Mesh,uses esi edi ebx,pEntityB,pNodeOnA,pNodeOnB<br />LOCAL vtemp:Vec3<br />&nbsp; &nbsp; SetObject esi<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;vtemp = NodeB&#039;s origin in Body A&#039;s space...<br />&nbsp; &nbsp; ;First, transform NodeB&#039;s origin into WorldSpace<br />&nbsp; &nbsp; mov edx,pNodeOnB<br />&nbsp; &nbsp; mov edi,pEntityB<br />&nbsp; &nbsp; OCall edi::CollisionBodyInstance.Transform_Vec3_BodyToWorld, addr .BSPNode.vOrigin, addr .CollisionBodyInstance.NewState.Orientation<br />&nbsp; &nbsp; Vec3_Stow vtemp<br />&nbsp; &nbsp; ;Next, transform it into A&#039;s bodyspace<br />&nbsp; &nbsp; OCall esi.Transform_Vec3_WorldToBody, addr vtemp,&nbsp; addr .NewState.Orientation <br />&nbsp; &nbsp; Vec3_Stow vtemp<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Finally, calculate the distance from A to B<br />&nbsp; &nbsp; ;Since we work in A&#039;s bodyspace, A&#039;s position is ZERO<br />&nbsp; &nbsp; ;so distance = sqrt(vtemp.x^2+vtemp.y^2+vtemp.z^2)<br />&nbsp; &nbsp; Vec3_Dot vtemp,vtemp<br />&nbsp; &nbsp; ;fsqrt&nbsp; ... we&#039;ll avoid the sqrt by squaring the sum of the radii<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;If (A.radius+B.radius) &lt; distance(A,B)<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; mov edx,pNodeOnA<br />&nbsp; &nbsp; fld .BSPNode.fRadius<br />&nbsp; &nbsp; mov edx,pNodeOnB<br />&nbsp; &nbsp; fadd .BSPNode.fRadius<br />&nbsp; &nbsp; fmul st(0),st(0)<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; fsub<br />&nbsp; &nbsp; fstpReg eax<br />&nbsp; &nbsp; ;If the distance is greater than the sum of the radii,<br />&nbsp; &nbsp; ;then the sign is Positive for separation<br />&nbsp; &nbsp; ;Otherwise it is Negative for penetration<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; .if eax==0<br />&nbsp; &nbsp; &nbsp; &nbsp; jmp @F&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;collision, treat as penetration<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; .ifBitSet eax,BIT31&nbsp; &nbsp; &nbsp;;negative, so we have penetration<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />@@:&nbsp; &nbsp; &nbsp;;If NodeA is not a leaf:<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,pNodeOnA<br />&nbsp; &nbsp; &nbsp; &nbsp; .if .BSPNode.pFaces==0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;If NodeB is not a leaf:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,pNodeOnB<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if .BSPNode.pFaces==0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Recurse A.front, B.front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall esi.Short_recurse_Mesh,pEntityB,.BSPNode.pFront,.BSPNode.pFront<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.if eax==Penetrating<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Recurse A.front, B.back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov eax,pNodeOnA<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov edx,pNodeOnB<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall esi.Short_recurse_Mesh,pEntityB,.BSPNode.pFront,.BSPNode.pBack<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.if eax==Penetrating<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Recurse A.back, B.front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov eax,pNodeOnA<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov edx,pNodeOnB<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall esi.Short_recurse_Mesh,pEntityB,.BSPNode.pBack,.BSPNode.pFront<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.if eax==Penetrating<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Recurse A.back, B.back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov eax,pNodeOnA<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov edx,pNodeOnB<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall esi.Short_recurse_Mesh,pEntityB,.BSPNode.pBack,.BSPNode.pBack<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Recurse A.front, B<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall esi.Short_recurse_Mesh,pEntityB,.BSPNode.pFront,pNodeOnB&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==Penetrating<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;Recurse A.back, B<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov eax,pNodeOnA<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall esi.Short_recurse_Mesh,pEntityB,.BSPNode.pBack,pNodeOnB<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;If NodeB is not a leaf:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,pNodeOnB<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if .BSPNode.pFaces==0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Recurse A, B.front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall esi.Short_recurse_Mesh,pEntityB,pNodeOnA,.BSPNode.pFront&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.if eax==Penetrating<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Recurse A, B.back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,pNodeOnB<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;OCall esi.Short_recurse_Mesh,pEntityB,pNodeOnA,.BSPNode.pBack <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,.BSPNode.pFaces<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,.Collection.pItems<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov eax,pNodeOnA<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov eax,.BSPNode.pFaces<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov eax,.Collection.pItems<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov eax,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall esi.Face_vs_Face, pEntityB,eax,edx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endIf<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; <br />MethodEnd<br /></code></pre><br /><br />The recursive function searches for pairs of proximate triangles (ie whose boundingspheres overlap) and passes those to the following method:<br /><br /><pre><code><br />;Test for Separation of two triangles (which belong to two mesh entities)<br />;Returns Penetrating,Colliding, or Clear<br />Method D3D_PhysicalEntity.Face_vs_Face,uses esi ,pEntityB,pFaceA,pFaceB<br />LOCAL tri1:triangle, tri2:triangle<br />LOCAL plane1:Vec4<br />LOCAL E1:Vec3,E2:Vec3<br /><br />&nbsp; &nbsp; SetObject esi<br /><br />&nbsp; &nbsp; ;Transform the face from this body (FaceA) into worldspace (tri1)<br />&nbsp; &nbsp; OCall esi.Transform_Face_BodyToWorld,pFaceA,addr .NewState.Orientation,addr tri1<br />&nbsp; &nbsp; ;Transform the face from other body (pFaceB) into worldspace (tri2)<br />&nbsp; &nbsp; OCall pEntityB::CollisionBodyInstance.Transform_Face_BodyToWorld,pFaceB,addr .NewState.Orientation,addr tri2<br /><br />&nbsp; &nbsp; ;compute plane of tri1<br />&nbsp; &nbsp; ;E1 = tri1[1] - tri1[0]<br />&nbsp; &nbsp; ;E2 = tri1[2] - tri1[0]<br />&nbsp; &nbsp; ;planeN = CrossProduct(E1,E2)<br />&nbsp; &nbsp; ;planeD = - Dotproduct(plane1,tri1[0])<br />&nbsp; &nbsp; Vec3_Sub&nbsp; &nbsp;tri1.v1,tri1.v0<br />&nbsp; &nbsp; Vec3_Stow&nbsp; E1<br />&nbsp; &nbsp; Vec3_Sub&nbsp; &nbsp;tri1.v2,tri1.v0<br />&nbsp; &nbsp; Vec3_Stow&nbsp; E2<br />&nbsp; &nbsp; Vec3_Cross E1,E2<br />&nbsp; &nbsp; Vec3_Stow&nbsp; plane1<br />&nbsp; &nbsp; Vec3_Dot&nbsp; &nbsp;plane1, tri1.v0<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fstp plane1.w<br /><br />&nbsp; &nbsp; ;Classify tri2 against plane1 <br />&nbsp; &nbsp; .switch $invoke (ClassifyTrianglePlane,addr tri2,addr plane1)<br />&nbsp; &nbsp; ;Case 1: tri2 is completely clear of tri1&#039;s plane<br />&nbsp; &nbsp; .case FRONTFRONTFRONT<br />&nbsp; &nbsp; &nbsp; &nbsp; return Clear<br /><br />&nbsp; &nbsp; ;Case 2: One point of tri2 is touching the plane of tri1, the others are in front<br />&nbsp; &nbsp; .case COPLANARFRONTFRONT<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr plane1, addr tri2.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return Clear<br />&nbsp; &nbsp; .case FRONTCOPLANARFRONT<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr tri2.v1<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return Clear<br />&nbsp; &nbsp; .case FRONTFRONTCOPLANAR<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr tri2.v2<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return Clear<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; ;Case 3 : One edge of tri2 is touching the plane of tri1, the other point is infront<br />&nbsp; &nbsp; .case FRONTCOPLANARCOPLANAR<br />&nbsp; &nbsp; &nbsp; &nbsp; ;we need to test/generate two contacts at tri2.v1 and tri2.v2<br />&nbsp; &nbsp; &nbsp; &nbsp; xor edi,edi<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr plane1,addr tri2.v1<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr plane1,addr tri2.v2<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return Clear<br />&nbsp; &nbsp; .case COPLANARFRONTCOPLANAR <br />&nbsp; &nbsp; &nbsp; &nbsp; ;we need to test/generate two contacts at tri2.v0 and tri2.v2<br />&nbsp; &nbsp; &nbsp; &nbsp; xor edi,edi<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr plane1,addr tri2.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr plane1,addr tri2.v2<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return Clear<br /><br />&nbsp; &nbsp; .case COPLANARCOPLANARFRONT<br />&nbsp; &nbsp; &nbsp; &nbsp; ;we need to test/generate two contacts at tri2.v0 and tri2.v1<br />&nbsp; &nbsp; &nbsp; &nbsp; xor edi,edi<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr plane1,addr tri2.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr plane1,addr tri2.v1<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return Clear<br />&nbsp; &nbsp; .endsw<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; mov eax,Penetrating<br />MethodEnd<br /></code></pre><br /><br />This last method quickly determines whether two given triangles are clear, colliding or penetrating, and will terminate early if penetration is found.<br /><br />That&#039;s enough for this post.<br />As you can see, its all quite similar to the Mesh/Sphere code, just a little more complex since we have to walk BOTH trees whenever possible.<br />It&#039;s worth noting that we are not solving this problem in the same Space as we did for the Mesh/Sphere problem ;)<br /><br />Next post will contain the Mesh/Mesh contact generation code.<br /></div>
    <div class="meta">Posted on 2009-04-11 02:28:38 by Homer</div>
   </div>
   <div class="post" id="post-207568">
    <div class="subject"><a href="#post-207568">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Hang in there guys, I&#039;m just trying to drag the rest of my game engine up to the same standard before I complete the physics engine ;)<br /></div>
    <div class="meta">Posted on 2009-05-11 02:37:55 by Homer</div>
   </div>
   <div class="post" id="post-208159">
    <div class="subject"><a href="#post-208159">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">The game engine is now waiting on the physics engine to be updated!<br /><br />If you&#039;ve been following my GameDev thread, you&#039;ll be aware that I&#039;m making some hefty changes to the architecture - but the physics code itself is essentially unchanged.<br /><br />Today I spent some time reading about the physics of Buoyancy (ie, the magical force that makes things float on water despite their mass).<br /><br />The author had written code which represented the water as a Plane, and implemented an equation which generated a Force in the Direction of the Plane Normal.<br /><br />I have a few problems with this.<br />#1 - Is water ever &#039;inclined&#039;? I mean, we&#039;re used to seeing it flat, even if it&#039;s flowing.<br /><br />#2 - Assuming water CAN be inclined, is Buoyant Force acting along the Plane Normal, or is it (as I suspect) always acting in an UPWARD direction (essentially, counteracting Gravity) ??<br /><br />What is your opinion?<br /></div>
    <div class="meta">Posted on 2009-07-14 04:37:58 by Homer</div>
   </div>
   <div class="post" id="post-208169">
    <div class="subject"><a href="#post-208169">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Ad #1:<br />Water always tries to make its plane parallel to ground &quot;plane&quot; because gravity attacts each water particle equally (assuming that it is water and not some variable-density variable-mass liquid). Water can be made &quot;inclined&quot; for some short time (via movement inertia) but it will reach the aforementioned state sooner or later (usually sooner ;) ).<br /><br />Ad #2:<br />Buoyancy is a force acting on a body in water (in liquids, generally). The body pushes water particles around it while these particles try to return back to &quot;their place&quot;. Buoyancy is a direct effect of the fact stated in point #1, so it is always &quot;upward&quot;. It is possible to make it work sideways via some movement inertia but it will be only temporary and -in fact- only apparent to local observer. You know - imagine moving a cup of water left or right very quickly. For some short time the water surface won&#039;t be parallel in respect to gravity. And in this exact amount of time, buoyancy won&#039;t be acting &quot;upward&quot; - it will be acting perpendicularly to the water&#039;s surface because the water particles which are BELOW the body won&#039;t be pushing it for some short time. Effectively, force from one side is weakened because of some particles being below the body, while force from another side is strengthened because of some particles right next to the body (of even above it if the inertia is strong). Resulting vector points more or less (depending on the inertia) sideways.<br /><br />Interesting example od buoyancy is a ball submerged a bit and dropped down a waterfall - while falling down it will move slightly away from the waterfall because some water particles will push it from one side (and the air will push it from another but gases are usually weaker).<br /><br /><br />I hope it&#039;s clear and anderstandable ^^</div>
    <div class="meta">Posted on 2009-07-14 11:18:01 by ti_mo_n</div>
   </div>
   <div class="post" id="post-208171">
    <div class="subject"><a href="#post-208171">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I think in your last example, you are suggesting that the only reason for &quot;sideways&quot; motion is due to the friction/drag of the waterfall against the half-submerged ball, which is only present because Buoyancy is tending the ball UPWARDS (otherwise the water and the ball would fall at very close to exactly the same speed, and side forces would then be negligable).<br /><br />So you agree, that Buoyancy always acts UPWARDS, even in extreme examples such as a ship half-way up the side of a tsunami (again, only drag causing side motion)?<br /><br />This would seem accurate, because flotsam and jetsam tends not to be pushed along by waves, as it has little drag force, but lots of buoyancy.<br /><br />I think I&#039;m happy to accept that &quot;buoyancy can be considered as opposing Gravity&quot; - apply it only in the UP vector, and take advantage of a few math/code shortcuts that become possible under this premise.<br /></div>
    <div class="meta">Posted on 2009-07-15 02:13:55 by Homer</div>
   </div>
   <div class="post" id="post-208181">
    <div class="subject"><a href="#post-208181">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I think I have the answer.<br /><br />Buoyancy is simply a manifestation of a density differential....<br />If we consider that things which are less dense float in things which are more dense, and if we further consider the AVERAGE density of a buoyant object (IE, its mass divided by its volume), then it becomes clear that an object&#039;s buoyancy is related to its mass/space ratio. It then follows that since we&#039;ve determined that buoyancy is in fact an example of density-displacement, it always acts in the upward (away from the planet) direction!</div>
    <div class="meta">Posted on 2009-07-15 10:34:35 by Homer</div>
   </div>
   <div class="post" id="post-208182">
    <div class="subject"><a href="#post-208182">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">It&#039;s not about density, but mass. Of course more density means more mass in a given area but directly it&#039;s all about mass and indirectly about density ^^ If the mass of the submerged object is equal than the mass of all water particles around it (multiplied by their angles -- more on this later), then it floats. If the mass of the object is larger - it sinks. And if it&#039;s smaller - it moves upwards. And there&#039;s more: Every water particle acts on the object in direction perpendicular to the plane between the object&#039;s nearest particle and water&#039;s particle in question.<br /><br />Image 1 shows the forces acting on a stationary submerged object. Air pressure is negligible in real-world situation because as atmospheric pressure increases so does the water pressure. Air pressure&#039;s effect is then effectively reduced.<br /><br />If we want an object to float then its mass must be euqal to the mass of all particles touching its submerged area (multiplied by their angles -- more on this later). Every water particle that touches the object will create a force perpendicular to the plane positioned exactly between water&#039;s particle and object&#039;s particle.<br /><br />If we submerge an object only slightly (image 2) then we have fewer buoyancy focre vectors (because of smaller area touching the water) so the effective buoyancy is weaker and the object will probably sink more. The object will stop sinking if the mass of all particles pushing it upwards is equal to the object&#039;s mass. But there&#039;s a catch: if a water particle is acting at an angle different than 180 deg in respect to gravity (in other words: different than &quot;upwards&quot;) then it effect on buoyancy is smaller (because it pushes more to the side than upwards).<br /><br />If we increase liquid&#039;s density and therefore mass acting on the submerged objects, its buoyancy (yellow vectors) will increase. If we increase the gas&#039; density without touching the liquid&#039;s density (unlikely to happen in real world) then the light-blue vectors will increase withot the yellow ones increasing. So the buoyancy will be reduced.<br /><br />Therefore we need many particles pushing an object upwards. It will be so if the object is a flat square (image 3). Almost every particle acts upwards in case of a flat square. That&#039;s why it&#039;s difficult to sink objects like that. The pink object on image 3 will be easy to sink because most of the water&#039;s particles act on it sideways, not upwards.<br /><br />There&#039;s yet another thing: stabilization. If most of the water&#039;s particles act upwards then the object is difficult to sink but unstable (it easy to rotate it). This is why it&#039;s easy to rotate a submerged ball (actually it starts to rotate on its own if you push it in some direction while it&#039;s submerged). If we want to stabilize an object we must add some water&#039;s particles acting sideways. I don&#039;t know if anyone wants me to copy my physics book here but the short story is that if water&#039;s particles act sideways then they stabilize an object and it&#039;s harder to rotate it. This is exactly what is done with ships (image 4). Ships are made so like most of their area is sunk. Their sides are very steep (for stabilization) and thir bottoms are almost parallel to the ground (for buoyancy). Playing with the bottoms of the ships you can increase buoyancy at the cost of stabilization (usually done with sports ships or fast military ships or any ship which has to be quick and maneuverable) or you can increase stabilization at the cost of buoyancy (cargo/passenger ships - they must be stable so you can easily drink a cup of coffee regardless of height of the waves. but on the other hand it&#039;s difficult to maneuver such ships).<br /><br />Now going back to image 3: the flat square is difficult to sink now but it&#039;s unstable - you can easily rotate whichever way you like. You can even align it perpendicularly to the water&#039;s surface so it becomes very stable but also ver easy to sink. The pink object is easy to sink but difficult to rotate. If it sinks enough, it will touch the bottom of the water basin. Now you can push its top so it will fall and align itself with water&#039;s surface making itself unstable and difficult to sink (this is what happens when trees fall into water).<br /><br />About flotsam and jetsam: This stuff is usually more or less round/spherical (<a target="_blank" href="http://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/Flostam_tern_island.JPG/800px-Flostam_tern_island.JPG">&gt;link&lt;</a>)- that&#039;s why it gets little drag from waves. I have omitted side movement for simplicity here. The entire post assumes stationary object in a waveless, static liquid.<br /><br />PS: Image 3 has an incorrect label saying it&#039;s a ship.</div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2809" target="_blank">buo1.png</a></li>
      <li><a href="../../attachments/?id=2811" target="_blank">buo2.png</a></li>
      <li><a href="../../attachments/?id=2813" target="_blank">buo3.png</a></li>
      <li><a href="../../attachments/?id=2815" target="_blank">buo4.png</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-07-15 14:42:42 by ti_mo_n</div>
   </div>
   <div class="post" id="post-208185">
    <div class="subject"><a href="#post-208185">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Thanks for the feedback, it&#039;s appreciated.<br />Your comments and images are interesting, the implications are obvious (to me) and agree with my observations of the physical world around us.<br /><br />The simplistic implementation I looked at computed the intersection of the water&#039;s plane with the body&#039;s mesh, calculated the submerged and not-submerged half-volumes, and then calculated a force vector that operates along the water plane&#039;s normal, and is based largely on the ratio of half-volumes versus a special constant for &#039;density of water in the context of air&quot;.<br /><br />A more accurate implementation would calculate forces on a per-submerged-vertex basis, weighted by the area of the faces which that vertex shares, calculate the physics deltas for this force, and sum those deltas to compute a total change in linear and angular velocity.<br /><br />This would make the body ROLL ACCURATELY and find its own angular equilibrium with respect to the water around it, irrespective of the angle of the water.<br /></div>
    <div class="meta">Posted on 2009-07-16 02:43:01 by Homer</div>
   </div>
   <div class="post" id="post-208189">
    <div class="subject"><a href="#post-208189">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Yup, the more accurate method would be nice ^^ Imagine player character&#039;s body falling into water - the more accurate method will rotate it first and keep it properly submerged. Also, the more accurate method will rotate, for example, crates (due to drag) if you push them while they are submerged. I think it&#039;s definitely the way to go for :)</div>
    <div class="meta">Posted on 2009-07-16 08:58:35 by ti_mo_n</div>
   </div>
   <div class="post" id="post-208217">
    <div class="subject"><a href="#post-208217">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Bad things today, I loaded a more complex world model and everything went pear shaped.<br />I must halt physics work and correct anomolies!<br /><br />Sorry peoples.<br /></div>
    <div class="meta">Posted on 2009-07-19 11:36:54 by Homer</div>
   </div>
   <div class="post" id="post-208450">
    <div class="subject"><a href="#post-208450">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Good news - bugs eliminated in the world-processor (portalizer), ready to continue the good work!<br /></div>
    <div class="meta">Posted on 2009-08-17 04:34:09 by Homer</div>
   </div>
   <div class="post" id="post-210438">
    <div class="subject"><a href="#post-210438">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">I am unpinning this thread because noone appears interested in this anymore.<br />Sad really.</div>
    <div class="meta">Posted on 2010-01-28 02:26:41 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29229&amp;page=1" style="">&laquo;</a><a href="../?id=29229&amp;page=6" style="">&lt;</a><input type="hidden" name="id" value="29229" /><input type="number" name="page" min="1" max="7" step="1" value="7" onchange="this.form.submit();" /></form>  </div>
 </body>
</html>