<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Better, Faster, Stronger Physics 2009 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29229" />
  <link rel="prev" href="../?id=29229&amp;page=5" />  <link rel="next" href="../?id=29229&amp;page=7" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29229">Better, Faster, Stronger Physics 2009</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29229&amp;page=1" style="">&laquo;</a><a href="../?id=29229&amp;page=5" style="">&lt;</a><input type="hidden" name="id" value="29229" /><input type="number" name="page" min="1" max="7" step="1" value="6" onchange="this.form.submit();" /><a href="../?id=29229&amp;page=7">&gt;</a><a href="../?id=29229&amp;page=7">&raquo;</a></form>   <div class="post" id="post-206935">
    <div class="subject"><a href="#post-206935">Optimizing the Triangle/Triangle Intersection Test</a></div>
    <div class="body">Just before we examine the code for the dual tree walk, lets discuss what we&#039;re trying to achieve.<br /><br />We&#039;re walking two bounding volume hierarchies (BVH&#039;s) in order to determine which pairs of Triangles are so close that they COULD be intersecting (or colliding)... essentially it&#039;s a search for closest pair of features from two bodies, where the features are always triangles.<br />Having done this, we&#039;ll need to be able to test a given pair of Triangles to check if they actually ARE intersecting (or colliding).<br /><br />I&#039;ve been looking for an ideal triangle/triangle intersection test for a week now.<br />Many of them seem to be based on the same algorithm, in that the first thing they do is to classify the points of one triangle (eg triangle A) against the PLANE of the other triangle (eg triangle B).<br />If all the points clearly fall on the same side of the plane, and the points do not ALL live APON the plane (ie the triangles are NOT COPLANAR) then that Plane must be a Separating Axis, and these two triangles cannot be intersecting, so we can exit the intersection test early.<br /><br />Many implementations will then go on to test the same pair of triangles in reverse order ... ie, classifying the points of triangle B against the plane of triangle A.<br />I believe that this second test is REDUNDANT as we have already determined that the PLANES MUST INTERSECT, and that intersection is at least POSSIBLE.<br />Furthermore, I believe that this situation has occurred through the misunderstanding of a simple statement in an early whitepaper on the subject, which says something along the lines of &quot;if the points of EITHER triangle fall to one side of the plane of the other triangle&quot;, which IMPLIES that we need to perform two tests of this kind, so that a programmer who read the notes on the algorithm without TRULY UNDERSTANDING IT would inevitably fall for this trap.<br /><br />Just remember that we&#039;ll be calling these functions a LOT, so any savings we can make will impact dramatically apon the performance of the simulator, especially when it is under load !!!<br /><br />Anyway, I&#039;ll be posting the code for the tree walk, then I&#039;ll post the code for the triangle-pair intersection test, and I&#039;ll provide descriptions and comments so you can understand exactly what is going on... perhaps someone will see further optimizations that can be made to further accelerate what will become the most cpu-intensive code in the entire engine (an obvious bottleneck).<br /><br /></div>
    <div class="meta">Posted on 2009-03-01 09:04:59 by Homer</div>
   </div>
   <div class="post" id="post-207013">
    <div class="subject"><a href="#post-207013">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body"><div class="quote"><br />Unfortunately, I can&#039;t tell you how well PhysX does on cards that DO support a true physics coprocessor, but I can say that has very little to do with the PhysX engine anyway!<br /></div><br /><br />There is no need for a &#039;true physics coprocessor&#039;. The current Cuda implementation is already faster than a dedicated PhysX card on a GeForce 9800GTX+ or better (this is while the GPU does both graphics and physics vs the GPU doing graphics and the PPU doing physics).<br />Cuda is an elegant and cost-effective solution. Dedicated physics hardware will probably be marginally faster at best (which I doubt in the first place, given the G80/92/200 architecture), yet cannot be used for anything but physics. So it will either lead to larger, more expensive chips, or chips with smaller GPU portions.</div>
    <div class="meta">Posted on 2009-03-09 07:58:25 by Scali</div>
   </div>
   <div class="post" id="post-207014">
    <div class="subject"><a href="#post-207014">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body"><div class="quote"><br />I&#039;m beginning to suspect that some (if not most) of the list of game developers using PhysX are startup companies which are indirectly owned by nvidia - this is just an exercise in self promotion, where are the benchmarks? They benchmark everything else. I think the demos that they ship with it tell the real story.<br /><br /></div><br /><br />There are also some big names involved... The UT3 engine uses PhysX... and EA has licensed the technology... an A-list game like Mirror&#039;s Edge now uses it too.<br />Aside from that, I&#039;ve not seen any proof that Havok is any better than PhysX, even in software. So I don&#039;t think PhysX is doing all that badly even for those without an nVidia card.<br />Obviously for those WITH an nVidia card, the performance and realism levels are just well above any alternative solution.</div>
    <div class="meta">Posted on 2009-03-09 08:02:08 by Scali</div>
   </div>
   <div class="post" id="post-207015">
    <div class="subject"><a href="#post-207015">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body"><div class="quote">Dedicated physics hardware will probably be marginally faster at best (which I doubt in the first place, given the G80/92/200 architecture), yet cannot be used for anything but physics. So it will either lead to larger, more expensive chips, or chips with smaller GPU portions.</div>I thought the PhysX board was generally programmable?</div>
    <div class="meta">Posted on 2009-03-09 10:57:14 by f0dder</div>
   </div>
   <div class="post" id="post-207017">
    <div class="subject"><a href="#post-207017">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body"><div class="quote"><br /><div class="quote">Dedicated physics hardware will probably be marginally faster at best (which I doubt in the first place, given the G80/92/200 architecture), yet cannot be used for anything but physics. So it will either lead to larger, more expensive chips, or chips with smaller GPU portions.</div>I thought the PhysX board was generally programmable?<br /></div><br /><br />Sure it is, but it&#039;s not exactly DX10-compliant shader stuff :)<br />Aside from that, it lacks the fixed-function hardware that a GPU has.<br />If it did, it wouldn&#039;t be dedicated anymore.<br /><br />It&#039;s only slightly different from the Cuda architecture in nature.<br />The key to the PPU was not the raw processing power itself, but rather the network-like architecture, which allowed the execution units to quickly forward results.<br />Cuda has a huge shared cache which allows the shaders to do the same. That&#039;s what&#039;s unique about nVidia&#039;s architecture... it is a feature that has no function whatsoever for graphics (data is never shared between shaders, other than basic cached textures and such), it is solely for improving GPGPU performance.<br />I&#039;m not sure if ATi has something similar actually.<br /><br />So basically what I think it boils down to is this:<br />- The PPU might be slightly more efficient in data forwarding than the Cuda architecture, but not that much.<br />- The PPU isn&#039;t very useful for graphics, if at all.<br />- Cuda is probably as good or better at other general-purpose tasks.<br /><br />So to me it makes more sense to do physics on the GPU than the other way around.<br />nVidia elegantly turned its GPU into an efficient physics processor by adding the shared cache.<br />Trying to turn a PPU into a GPU/CPU seems to be a bit backwards, especially for a company like nVidia.<br />So I don&#039;t think you can really improve the current nVidia architecture by adding a dedicated physics architecture.</div>
    <div class="meta">Posted on 2009-03-09 12:24:29 by Scali</div>
   </div>
   <div class="post" id="post-207038">
    <div class="subject"><a href="#post-207038">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">So I take a couple of days away from my thread and another thousand views :) Really I must apologize for the delay in my usually regular postings, but I don&#039;t want to ramble about something if I don&#039;t have the sourcecode to back it up, and just recently I&#039;ve had a heavy workload, which in the current economic environment is a Good Thing.<br /><br />I will be posting some more juicy stuff over the coming days, so the wait will have been worth it, but in the meanwhile, here&#039;s some stuffing:<br /><br /><pre><code><br />Method D3D_PhysicalEntity.Find_Contacts,uses esi ebx, pOtherEntity<br />LOCAL pNodeA,pNodeB<br />&nbsp; &nbsp; SetObject esi<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Obtain ptrs to the Root of each SphereTree<br />&nbsp; &nbsp; mov edx,.pOwner<br />&nbsp; &nbsp; m2m pNodeA,.D3D_CollisionMesh.pRootNode,eax<br />&nbsp; &nbsp; mov edx,pOtherEntity<br />&nbsp; &nbsp; mov edx,.D3D_PhysicalEntity.pOwner<br />&nbsp; &nbsp; m2m pNodeB,.D3D_CollisionMesh.pRootNode,ebx<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;vtemp = NodeB&#039;s origin in Body A&#039;s space<br />&nbsp; &nbsp; ;If (A.radius+B.radius) &lt; distance(A,B)<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ;If NodeA is not a leaf:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;If NodeB is not a leaf:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Recurse A.front, B.front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Recurse A.front, B.back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Recurse A.back, B.front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Recurse A.back, B.back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Recurse A.front, B<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;Recurse A.back, B<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;EndIf<br />&nbsp; &nbsp; &nbsp; &nbsp; ;Else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;If NodeB is not a leaf:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Recurse A, B.front<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Recurse A, B.back<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;If A and B are both leaf nodes:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Test A.face, B.face<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;EndIf<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;EndIf<br />&nbsp; &nbsp; &nbsp; &nbsp; ;EndIf<br />&nbsp; &nbsp; ;EndIf<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; <br />MethodEnd<br /></code></pre><br /></div>
    <div class="meta">Posted on 2009-03-11 05:04:19 by Homer</div>
   </div>
   <div class="post" id="post-207105">
    <div class="subject"><a href="#post-207105">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">The entire collision algorithm has been reworked. Here&#039;s a brief in regards to the revised algorithm:<br /><br />The main collision detection method finds pairs of entities whose boundingspheres are going to intersect during the current timestep, calculating First and Last moments of contact for each pair (the time when the spheres begin to touch, and the time they begin to separate again).<br />Each pair is then passed to a function which uses these two times as a &#039;search window&#039;, and proceeds to bisect that search window to find the moment of contact between the underlying geometry of the pair of entities.<br />This, of course, involves calls to our NarrowPhase separation test at various &#039;test times&#039;.<br />Since our search window is one TimeStep (0.100 Seconds) or less (generally far less), we quickly bisect our way to a moment of impact within the tolerance of our epsilon (numerical limit of accuracy).<br />It&#039;s entirely possible that the underlying geometries of the input pair of bodies NEVER ACTUALLY TOUCHED and so false positives are pruned at this point.<br />Each pair that actually DOES collide is recorded along with the moment of impact, and the record is stored in a list that is sorted by moment of impact.<br />Note that no actual Contacts have been generated yet.<br /><br />Once all the collision testing has been completed, the simulator will attempt to exhaust the list of records of colliding pairs of entities. <br /><br />Starting with the pair at the earliest moment of contact, it integrates the entire simulation to that time, then generates the contacts between these bodies, resolves the contacts and calculates net changes to the physical state of each body BUT DOES NOT APPLY THEM.<br />Any further records which have the same moment of contact are now consumed.<br />Now the net changes in physics state are applied to the bodies we touched so far.<br />And now we repeat all the above until our list of records is exhausted.<br /><br />The goal of Contact generation is to calculate points of contact, and for each point, a contact normal.<br />My implementation involves an extension of our NarrowPhase collision code...<br />We already know that our pair of bodies have been integrated to our best estimate of the moment of contact.<br />Penetrations, if any, are minimal.<br />If the primitives collide, or if they intersect, we wish to know where and how.<br /><br /><br /></div>
    <div class="meta">Posted on 2009-03-19 01:00:41 by Homer</div>
   </div>
   <div class="post" id="post-207108">
    <div class="subject"><a href="#post-207108">It's getting better all the time</a></div>
    <div class="body">We&#039;ll take a look at the entire collision detection algo from start to finish, sorry its taking so long but I keep finding things to improve and I&#039;d rather post stuff I&#039;m happy with than repeat myself in variations.<br /><br />Basically I&#039;ve divided the NarrowPhase code into two categories - fast testing for separation / penetration / collision of two bodies (with early-outs for fastest possible response) and thorough searching for Contacts (which can be resolved inline, as long as we accumulate the response deltas until all simultaneous contacts are resolved).<br /><br />I am tempted to collect Contacts into a proper &#039;Manifold&#039;, however I see no runtime benefit from doing so - its merely a courtesy and so I&#039;ll probably refrain from that and simply resolve contacts as I detect them as mentioned above.<br /><br />Anyway, personally I find it very nice to be monkeying around with the whole collision detection process, based on existing and working code, because I believe that the biggest speedups will be obtained by using better algorithms, rather than optimizing inferior ones.<br /></div>
    <div class="meta">Posted on 2009-03-20 01:01:29 by Homer</div>
   </div>
   <div class="post" id="post-207162">
    <div class="subject"><a href="#post-207162">Re: Improved Triangle/Triangle separation test</a></div>
    <div class="body">I&#039;ve just rewritten my Triangle/Triangle test for the fourth time.<br />Previous versions have been based on existing algorithms (Moller etc).<br />The new version is my own, it is the culmination of my preconceptions and my observations of existing algorithms.<br />That is to say - I threw everything away and went back to one of my own early ideas.<br />This seems to be a recurring theme, perhaps I have a natural affinity to geometric calculation.<br /><br />Anyway, here&#039;s some pseudocode that describes my new test for separation of two triangles, given as Faces in their respective BodySpaces:<br /><br />-Transform both Faces into WorldSpace<br />-Calculate Plane of triangle #1<br />-Classify the Points of triangle #2 against the Plane of triangle #1<br />-If the three resulting Point/Plane Distances are positive, return Clear<br />-If one or two points are Coplanar and the other(s) positive, test whether the coplanar point(s) are inside triangle #1, and if so, return Colliding, else return Clear<br />-return Penetrating<br /><br />This algorithm clearly defines the classifications &#039;Clear, Colliding and Penetrating&#039;.<br />Clear means the triangles are separated, and are in front of one another.<br />Colliding means the triangles are touching, and are in front of one another.<br />Anything else means they are Penetrating, regardless of penetration depth.<br /><br />As with all the NarrowPhase (separation) tests, I have written a more thorough variant which generates Contacts between the triangles. I will describe this in my next post, then we&#039;ll begin looking over the entire collision detection pipeline.<br /><br />Pipeline makes it sound really technical, but each stage is relatively simple by itself so don&#039;t worry too much about that buzzword, I&#039;m simply referring to the fact that there ARE several linear stages.<br /></div>
    <div class="meta">Posted on 2009-03-26 00:43:25 by Homer</div>
   </div>
   <div class="post" id="post-207176">
    <div class="subject"><a href="#post-207176">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">We wish to generate Contacts between a pair of triangles.<br />This is a structure that contains a Point of Impact, and a Collision Normal.<br />For our purposes, the Normal will always be that of the test Plane.<br /><br />In order to generate Contacts between two triangles, we need to extend the previous algorithm.<br />It&#039;s worth thinking about the different ways that two triangles can interact, given the three categories of Clear, Colliding or Penetrating.<br /><br />For collision cases (where one or more points of a triangle are coplanar with the other triangle and within the other triangles bounds) we wish to generate Contacts at those coplanar points of contact.<br /><br />Penetration cases are more tricky... start by noting that two triangles always intersect in exactly two places... we need to identify which Edges of a triangle are intersecting the Plane of the other triangle, find proposed intersection points on the plane along each edge, check if each proposed intersection point is inside the other triangles bounds, and if so, generate a Contact at that point of intersection.<br />And depending on how the two triangles are intersecting, we might only find one Contact this way, and we&#039;ll need to perform all these tests with the triangles switched around to find the other one.<br /><br />Then we have the special case of two coplanar triangles, which is solved by performing point-in-triangle tests.<br /><br />And finally, the case of a deep penetration where all the points of a triangle are behind the plane of the other.<br />This should never arise, since we&#039;re meant to be in a Colliding, or Shallow Penetration situation.<br />So I won&#039;t generate contacts, I&#039;ll throw an error here.<br /><br />In my next post, I&#039;ll present code for Separation Test and for Contact Generation.<br /><br /></div>
    <div class="meta">Posted on 2009-03-26 22:06:20 by Homer</div>
   </div>
   <div class="post" id="post-207189">
    <div class="subject"><a href="#post-207189">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Here&#039;s the code which tests for Separation of two Triangles.<br />My next post will contain code for Contact Generation of two intersecting triangles.<br />Please note that neither of these functions have been tested in the engine yet, as they&#039;ve been the subject of recent furious coding sessions and are thereby subject to further change without notice.<br /><br /><pre><code><br />;Test for Separation of two triangles (which belong to two mesh entities)<br />;Returns Penetrating,Colliding, or Clear<br />Method D3D_PhysicalEntity.Face_vs_Face,uses esi ,pEntityB,pFaceA,pFaceB<br />LOCAL tmp<br />LOCAL tri1:triangle, tri2:triangle<br />LOCAL plane1:Vec4<br />LOCAL E1:Vec3,E2:Vec3<br /><br />&nbsp; &nbsp; SetObject esi<br /><br />&nbsp; &nbsp; ;Transform the face from this body (FaceA) into worldspace (tri1)<br />&nbsp; &nbsp; OCall esi.Transform_Face_BodyToWorld,pFaceA,addr .NewState.Orientation,addr tri1<br />&nbsp; &nbsp; ;Transform the face from other body (pFaceB) into worldspace (tri2)<br />&nbsp; &nbsp; OCall pEntityB::CollisionBodyInstance.Transform_Face_BodyToWorld,pFaceB,addr .NewState.Orientation,addr tri2<br /><br />&nbsp; &nbsp; ;compute plane of tri1<br />&nbsp; &nbsp; ;E1 = tri1[1] - tri1[0]<br />&nbsp; &nbsp; ;E2 = tri1[2] - tri1[0]<br />&nbsp; &nbsp; ;planeN = CrossProduct(E1,E2)<br />&nbsp; &nbsp; ;planeD = - Dotproduct(plane1,tri1[0])<br />&nbsp; &nbsp; Vec3_Sub&nbsp;  tri1.v1,tri1.v0<br />&nbsp; &nbsp; Vec3_Stow&nbsp; E1<br />&nbsp; &nbsp; Vec3_Sub&nbsp;  tri1.v2,tri1.v0<br />&nbsp; &nbsp; Vec3_Stow&nbsp; E2<br />&nbsp; &nbsp; Vec3_Cross E1,E2<br />&nbsp; &nbsp; Vec3_Stow&nbsp; plane1<br />&nbsp; &nbsp; Vec3_Dot&nbsp;  plane1, tri1.v0<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fstp plane1.w<br /><br />&nbsp; &nbsp; ;Classify tri2 against plane1 <br />&nbsp; &nbsp; invoke ClassifyTrianglePlane,addr tri2,addr plane1<br />&nbsp; &nbsp; ;Case 1: tri2 is completely clear of tri1&#039;s plane<br />&nbsp; &nbsp; .if eax==FRONTFRONTFRONT<br />&nbsp; &nbsp; &nbsp; &nbsp; return Clear<br /><br />&nbsp; &nbsp; ;Case 2: One point of tri2 is touching the plane of tri1, the others are in front<br />&nbsp; &nbsp; .elseif eax==COPLANARFRONTFRONT<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr tri2.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return Clear<br />&nbsp; &nbsp; .elseif eax==FRONTCOPLANARFRONT<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr tri2.v1<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return Clear<br />&nbsp; &nbsp; .elseif eax==FRONTFRONTCOPLANAR<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr tri2.v2<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return Clear<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; ;Case 3 : One edge of tri2 is touching the plane of tri1, the other point is infront<br />&nbsp; &nbsp; .elseif eax==FRONTCOPLANARCOPLANAR<br />&nbsp; &nbsp; &nbsp; &nbsp; xor edi,edi<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr tri2.v1<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr tri2.v2<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return Clear<br />&nbsp; &nbsp; .elseif eax==COPLANARFRONTCOPLANAR <br />&nbsp; &nbsp; &nbsp; &nbsp; xor edi,edi<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr tri2.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr tri2.v2<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return Clear<br /><br />&nbsp; &nbsp; .elseif eax==COPLANARCOPLANARFRONT<br />&nbsp; &nbsp; &nbsp; &nbsp; xor edi,edi<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr tri2.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr tri2.v1<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Colliding<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return Clear<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; mov eax,Penetrating<br />MethodEnd<br /><br /></code></pre><br /><br />I&#039;m testing the points of the second triangle against the plane of the first triangle, via a procedure called &#039;ClassifyTrianglePlane&#039;, which returns a value that describes each point of the input triangle classified against the input plane,&nbsp; such as FRONTFRONTCOPLANAR and BACKCOPLANARFRONT.<br />We return Clear, Colliding or Penetrating, based on the return value.<br /><br />It certainly appears that in order to quickly determine whether the triangles are clear, colliding or penetrating, we only need to test the points of one triangle against the plane of the other triangle... we don&#039;t need to do this test again with the triangles switched about.... do we? Can you see any problems?<br /></div>
    <div class="meta">Posted on 2009-03-30 00:13:51 by Homer</div>
   </div>
   <div class="post" id="post-207213">
    <div class="subject"><a href="#post-207213">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Here&#039;s the code which generates Contacts between two triangles.<br />Its quite lengthy, but it executes quickly since its just a big bunch of IF cases.<br /><br /><pre><code><br />;This macro is used in the method below<br />;for handling the special case of coplanar triangles<br />TestEdges macro vstart1,vend1,vstart2,vend2&nbsp; <br />.if $invoke (Edge_intersect_Edge,addr vstart1,addr vend1,addr vstart2,addr vend2)==TRUE<br />&nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; inc numcontacts<br />&nbsp; &nbsp; .if numcontacts==6<br />&nbsp; &nbsp; &nbsp; &nbsp; return TRUE<br />&nbsp; &nbsp; .endif<br />.endif<br />endm<br /><br />;Generates Contacts<br />;Returns TRUE (no more tests needed)<br />;or FALSE (need second call with triangles switched)<br />Method D3D_PhysicalEntity.Face_Contact_Face,uses esi ,pEntityB,pFaceA,pFaceB,pPair,pContacts<br />LOCAL tmp<br />LOCAL tri1:triangle, tri2:triangle<br />LOCAL plane1:Vec4<br />LOCAL E1:Vec3,E2:Vec3<br />LOCAL numcontacts<br />LOCAL vIntersection:Vec3<br /><br />&nbsp; &nbsp; SetObject esi<br />&nbsp; &nbsp; mov numcontacts,0<br /><br />&nbsp; &nbsp; ;Transform the face from this body (FaceA) into worldspace (tri1)<br />&nbsp; &nbsp; OCall esi.Transform_Face_BodyToWorld,pFaceA,addr .NewState.Orientation,addr tri1<br />&nbsp; &nbsp; ;Transform the face from other body (pFaceB) into worldspace (tri2)<br />&nbsp; &nbsp; OCall pEntityB::CollisionBodyInstance.Transform_Face_BodyToWorld,pFaceB,addr .NewState.Orientation,addr tri2<br /><br />&nbsp; &nbsp; ;compute plane of tri1<br />&nbsp; &nbsp; ;E1 = tri1[1] - tri1[0]<br />&nbsp; &nbsp; ;E2 = tri1[2] - tri1[0]<br />&nbsp; &nbsp; ;planeN = CrossProduct(E1,E2)<br />&nbsp; &nbsp; ;planeD = - Dotproduct(plane1,tri1[0])<br />&nbsp; &nbsp; Vec3_Sub&nbsp; &nbsp;tri1.v1,tri1.v0<br />&nbsp; &nbsp; Vec3_Stow&nbsp; E1<br />&nbsp; &nbsp; Vec3_Sub&nbsp; &nbsp;tri1.v2,tri1.v0<br />&nbsp; &nbsp; Vec3_Stow&nbsp; E2<br />&nbsp; &nbsp; Vec3_Cross E1,E2<br />&nbsp; &nbsp; Vec3_Stow&nbsp; plane1<br />&nbsp; &nbsp; Vec3_Dot&nbsp; &nbsp;plane1, tri1.v0<br />&nbsp; &nbsp; fchs<br />&nbsp; &nbsp; fstp plane1.w<br /><br />&nbsp; &nbsp; ;Classify tri2 against plane1 <br />&nbsp; &nbsp; invoke ClassifyTrianglePlane,addr tri2,addr plane1<br />&nbsp; &nbsp; .switch eax<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Special case - triangles are coplanar<br />&nbsp; &nbsp; .case COPLANARCOPLANARCOPLANAR<br />&nbsp; &nbsp; &nbsp; &nbsp; ;We must test all Edges of each Tri against the other Tri&#039;s 3 edges<br />&nbsp; &nbsp; &nbsp; &nbsp; ;The maximum number of Contacts for two coplanar triangles is SIX.<br />&nbsp; &nbsp; &nbsp; &nbsp; ;Just imagine the &#039;Star of David&#039; configuration of two triangles.&nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; TestEdges tri1.v0,tri1.v1,tri2.v0,tri2.v1<br />&nbsp; &nbsp; &nbsp; &nbsp; TestEdges tri1.v0,tri1.v1,tri2.v1,tri2.v2<br />&nbsp; &nbsp; &nbsp; &nbsp; TestEdges tri1.v0,tri1.v1,tri2.v2,tri2.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; TestEdges tri1.v1,tri1.v2,tri2.v0,tri2.v1<br />&nbsp; &nbsp; &nbsp; &nbsp; TestEdges tri1.v1,tri1.v2,tri2.v1,tri2.v2<br />&nbsp; &nbsp; &nbsp; &nbsp; TestEdges tri1.v1,tri1.v2,tri2.v2,tri2.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; TestEdges tri1.v2,tri1.v0,tri2.v0,tri2.v1<br />&nbsp; &nbsp; &nbsp; &nbsp; TestEdges tri1.v2,tri1.v0,tri2.v1,tri2.v2<br />&nbsp; &nbsp; &nbsp; &nbsp; TestEdges tri1.v2,tri1.v0,tri2.v2,tri2.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; return TRUE<br /><br />&nbsp; &nbsp; ;Case 1: tri2 is completely clear of tri1&#039;s plane<br />&nbsp; &nbsp; .case FRONTFRONTFRONT<br />&nbsp; &nbsp; &nbsp; &nbsp; DbgWarning &quot;Warning - Triangle pair is Clear&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; return TRUE<br /><br />&nbsp; &nbsp; ;Case 2: One point of tri2 is touching the plane of tri1, the others are in front<br />&nbsp; &nbsp; ;Test whether the coplanar point of tri2 is inside tri1<br />&nbsp; &nbsp; ;If so, generate a Contact there<br />&nbsp; &nbsp; ;This is a Terminal Case - no further tests are required<br />&nbsp; &nbsp; .case COPLANARFRONTFRONT<br />&nbsp; &nbsp; &nbsp; &nbsp; .if $invoke (PointInTriangle,addr tri1, addr plane1,addr tri2.v0)==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v0,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return TRUE<br />&nbsp; &nbsp; .case FRONTCOPLANARFRONT&nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; .if $invoke (PointInTriangle,addr tri1, addr plane1,addr tri2.v1)==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v1,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return TRUE<br />&nbsp; &nbsp; .case FRONTFRONTCOPLANAR&nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; .if $invoke (PointInTriangle,addr tri1, addr plane1,addr tri2.v2)==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v2,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return TRUE<br /><br />&nbsp; &nbsp; ;Case 3 : One edge of tri2 is touching the plane of tri1, the other point is infront<br />&nbsp; &nbsp; ;test coplanar edge for intersection with 3 edges of tri1 <br />&nbsp; &nbsp; ;until we have 2 contacts or run out of tests.<br />&nbsp; &nbsp; .case FRONTCOPLANARCOPLANAR<br />&nbsp; &nbsp; &nbsp; &nbsp; ;find intersections of coplanar edge and edges of t1<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Edge,addr tri2.v1,addr tri2.v2,addr tri1.v0,addr tri1.v1<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc numcontacts<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Edge,addr tri2.v1,addr tri2.v2,addr tri1.v1,addr tri1.v2<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc numcontacts<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if numcontacts==2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Edge,addr tri2.v1,addr tri2.v2,addr tri1.v2,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; .case COPLANARCOPLANARFRONT<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Edge,addr tri2.v0,addr tri2.v1,addr tri1.v0,addr tri1.v1<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc numcontacts<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Edge,addr tri2.v0,addr tri2.v1,addr tri1.v1,addr tri1.v2<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc numcontacts<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if numcontacts==2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Edge,addr tri2.v0,addr tri2.v1,addr tri1.v2,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; .case COPLANARFRONTCOPLANAR <br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Edge,addr tri2.v2,addr tri2.v0,addr tri1.v0,addr tri1.v1<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc numcontacts<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Edge,addr tri2.v2,addr tri2.v0,addr tri1.v1,addr tri1.v2<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc numcontacts<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if numcontacts==2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Edge,addr tri2.v2,addr tri2.v0,addr tri1.v2,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return TRUE<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; ;Case 4 : One point of tri2 is touching the plane of tri1, the others are behind<br />&nbsp; &nbsp; ;Test whether coplanar point is inside tri1<br />&nbsp; &nbsp; ;If so, Generate contacts for the two Penetrating points <br />&nbsp; &nbsp; .case COPLANARBACKBACK<br />&nbsp; &nbsp; &nbsp; &nbsp; .if $invoke (PointInTriangle,addr tri1, addr plane1,addr tri2.v0)==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v1,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v2,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return TRUE&nbsp; &nbsp;<br />&nbsp; &nbsp; .case BACKCOPLANARBACK<br />&nbsp; &nbsp; &nbsp; &nbsp; .if $invoke (PointInTriangle,addr tri1, addr plane1,addr tri2.v1)==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v1,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v2,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return TRUE<br />&nbsp; &nbsp; .case BACKBACKCOPLANAR<br />&nbsp; &nbsp; &nbsp; &nbsp; .if $invoke (PointInTriangle,addr tri1, addr plane1,addr tri2.v2)==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v1,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v2,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; return TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; ;Case 5 : One edge of tri2 is touching the plane of tri1, the other point is behind<br />&nbsp; &nbsp; ;Generate a single contact for the penetrating point<br />&nbsp; &nbsp; .case BACKCOPLANARCOPLANAR<br />&nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v0,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; .case COPLANARBACKCOPLANAR<br />&nbsp; &nbsp; &nbsp; &nbsp; ;Generate one contact for the Penetrating point<br />&nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v1,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; .case COPLANARCOPLANARBACK<br />&nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v2,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; ;Case 6 : One point is coplanar, the other two lay each side of the plane<br />&nbsp; &nbsp; ;Check coplanar Point and spanning Edge<br />&nbsp; &nbsp; .case BACKCOPLANARFRONT<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr plane1,addr tri2.v1<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v1,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v2,addr tri2.v0,addr plane1,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr plane1,addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif&nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; .case FRONTCOPLANARBACK<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr tri2.v1<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v1,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v0,addr tri2.v2,addr plane1, addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; .case COPLANARFRONTBACK<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr tri2.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v0,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v1,addr tri2.v2,addr plane1,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; .case COPLANARBACKFRONT<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr plane1,addr tri2.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v0,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v2,addr tri2.v1,addr plane1,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; .case FRONTBACKCOPLANAR<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr tri2.v2<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v2,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v0,addr tri2.v1,addr plane1,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; .case BACKFRONTCOPLANAR<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr tri2.v2<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr tri2.v2,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v1,addr tri2.v0,addr plane1,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; ;Case 7: triangle intersection<br />&nbsp; &nbsp; .case FRONTBACKBACK<br />&nbsp; &nbsp; &nbsp; &nbsp; ;check edges AB and AC<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v0,addr tri2.v1,addr plane1,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v0,addr tri2.v2,addr plane1,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr plane1,addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; .case BACKFRONTFRONT<br />&nbsp; &nbsp; &nbsp; &nbsp; ;check edges BA and CA<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v1,addr tri2.v0,addr plane1,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr plane1,addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v2,addr tri2.v0,addr plane1,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr plane1,addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; .case FRONTBACKFRONT<br />&nbsp; &nbsp; &nbsp; &nbsp; ;check edges AB and CB<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v0,addr tri2.v1,addr plane1,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1, addr plane1,addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v2,addr tri2.v1,addr plane1,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; .case BACKFRONTBACK<br />&nbsp; &nbsp; &nbsp; &nbsp; ;check edges BA and BC<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v1,addr tri2.v0,addr plane1,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v1,addr tri2.v2,addr plane1,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; .case FRONTFRONTBACK<br />&nbsp; &nbsp; &nbsp; &nbsp; ;check edges BC and AC<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v1,addr tri2.v2,addr plane1,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v0,addr tri2.v2,addr plane1,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; .case BACKBACKFRONT<br />&nbsp; &nbsp; &nbsp; &nbsp; ;check edges CB and CA<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v2,addr tri2.v1,addr plane1,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; invoke Edge_intersect_Plane,addr tri2.v2,addr tri2.v0,addr plane1,addr tri1.v0<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vIntersection<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke PointInTriangle,addr tri1,addr plane1, addr vIntersection&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pContacts::Collection.Insert,$New(Contact,Init,pPair,addr vIntersection,addr plane1)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; .default<br />&nbsp; &nbsp; &nbsp; &nbsp; DbgWarning &quot;Unhandled case in Face_Contact_Face&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; DbgDec eax,&quot;unhandled switch&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; int 3<br />&nbsp; &nbsp; .endsw<br /><br />MethodEnd<br /></code></pre><br /><br />As you can see, testing for separation and finding contacts for just a PAIR OF TRIANGLES is quite intensive, so doing this for two GROUPS of triangles is just out of the question... this is why we extended the BSP algorithm so that the leaf nodes contain no more than one triangle - its cheaper to walk a few tree nodes and test several pairs of triangles than it is to exhaustively test a pair of convex clusters of triangles.<br /><br />I&#039;m not going to discuss the above code too much, I&#039;ll leave it to you to examine and tell me if you think (as I do) that we don&#039;t need to call this function again with the triangles switched around - this version handles all cases in a single call.<br /><br />I&#039;m going to assume there&#039;s no problems in the above code, and move on.<br />I did say the code was subject to change without notice :P<br /><br />I think we&#039;re ready to look over the entire collision detection pipeline from start to finish :)<br /></div>
    <div class="meta">Posted on 2009-04-02 23:49:36 by Homer</div>
   </div>
   <div class="post" id="post-207214">
    <div class="subject"><a href="#post-207214">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">For those brave enough, I&#039;ve attached a file which contains the core functions for intersection calculations.<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2747" target="_blank">Physics_Classify.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-04-02 23:59:59 by Homer</div>
   </div>
   <div class="post" id="post-207215">
    <div class="subject"><a href="#post-207215">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">And here&#039;s an update of what the engine layout looks like:<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2748" target="_blank">tree.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-04-03 00:25:16 by Homer</div>
   </div>
   <div class="post" id="post-207221">
    <div class="subject"><a href="#post-207221">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">It&#039;s time to take a look at the entire collision detection pipeline.<br />We&#039;ll begin with the Simulator.Simulate method.<br />Its purpose is to attempt to advance the simulation by one timestep or less, by calculating the &#039;new state&#039; of the physics simulation<br />(ie the new physical state of every physical entity), to detect (and collect) collisions within the current timestep, and if collisions were detected, to resolve them, leaving the simulation at the last known moment of contact.<br />This method returns (on the fpu) the time delta by which the simulation has been advanced (one timestep, or less).<br />We can consider this as the entrypoint to the collision detection code.<br /><br /><pre><code><br />;This method will attempt to advance the simulation by one whole TimeStep.<br />;When this method returns, the States of all Bodies have been Swapped,<br />;so that the &#039;current state&#039; is the OLD state, and the &#039;next state&#039; is UNKNOWN.<br />;It will return (on the fpu) the deltaTime that the Simulation should advance to.<br />;This is between zero (collisions at end of timestep)<br />;and PhysicsTimeStep (no collisions, or collisions at start of timestep).<br />Method Simulator.Simulate,uses esi<br />&nbsp; &nbsp; SetObject esi<br /><br />&nbsp; &nbsp; DbgLine<br />&nbsp; &nbsp; ;Integrate our system forward by one whole timestep<br />&nbsp; &nbsp; ;We are calculating the &#039;New States&#039; from &#039;Old States&#039; after &#039;deltaTime&#039;<br />&nbsp; &nbsp; OCall Integrate, PhysicsTimeStep<br /><br />&nbsp; &nbsp; ;If enabled, perform collision detection and resolution..<br />&nbsp; &nbsp; .if .IsCollisionEnabled==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; OCall esi.DetectCollisions<br />&nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;This method returns the time we are allowed to advance by...<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;It can be as much as one PhysicsTimeStep<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;(either NO collisions occurred, or collisions were at Time Zero)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;or it can be as little as Zero<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;(collisions detected at the very end of the timestep)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall esi.ResolveCollisions<br />&nbsp; &nbsp; &nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fld PhysicsTimeStep<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; OCall esi.SwapStates&nbsp; &nbsp;<br />&nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; OCall esi.SwapStates<br />&nbsp; &nbsp; &nbsp; &nbsp; fld PhysicsTimeStep<br />&nbsp; &nbsp; .endif<br /><br /><br />MethodEnd<br /></code></pre><br /><br />Since I&#039;ve posted the Integrate method previously, we&#039;ll just turn our attention to the DetectCollisions and ResolveCollisions methods.<br /><br /></div>
    <div class="meta">Posted on 2009-04-05 03:29:09 by Homer</div>
   </div>
   <div class="post" id="post-207222">
    <div class="subject"><a href="#post-207222">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Let&#039;s ignore collision response for now, and concentrate on collision detection.<br /><br />The Simulator.DetectCollisions method operates apon the premise that we know the BoundingSphere of every physical entity, regardless of the shape we choose to represent its collision hull.<br />It tests pairs of Spheres using a &#039;swept algorithm&#039; that boils down to solving a Quadratic Equation.<br />It can tell if the boundingspheres of two entities will collide within the current timestep, and if so, when.... all this happens within the &#039;BroadCheck_BodyBody&#039; method.<br />If sphere/sphere collision is detected, we perform a binary search for the exact moment of impact of the two bodies, using whatever collision hulls were selected.<br />Given that we know the moment of impact for the sphere pairs is within the current timestep, finding the exact time by exhaustive bisection is fairly quick.<br />We&#039;re returned either the exact time of impact, or a time where the penetration is known to be smallest, and in this case the penetration depth is returned too.<br />All of this information is recorded as a &#039;CollisionPair&#039; object, which is just a database record being stored in a list, with automatic sorting of the list based on time of impact.<br />We record all the CollisionPairs that we can find within the current timestep, and return to the caller.<br /><br /><br /><pre><code><br />;This method detects &amp; collects all Collisions in the current TimeStep,<br />;and sorts them by &#039;Time of Impact&#039;.<br />;Returns TRUE (found one or more collisions) or FALSE (no collisions found)<br />;Note: this method deals with INSTANCES of collision bodies.<br />Method Simulator.DetectCollisions,uses esi<br />LOCAL pBodyA,pBodyB<br />LOCAL fCollisionTime:real8<br />LOCAL fdepth:real8<br />LOCAL FoundCollisions<br />&nbsp; &nbsp; SetObject esi<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; <br />&nbsp; &nbsp; xor ecx,ecx<br />&nbsp; &nbsp; mov FoundCollisions,ecx&nbsp; &nbsp; &nbsp; &nbsp;  ;FALSE<br />&nbsp; &nbsp; .while ecx&lt;.Bodies.dCount<br />&nbsp; &nbsp; &nbsp; &nbsp; push ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; mov pBodyA,$OCall (.Bodies::Collection.ItemAt,ecx)<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ;Body A is considered to be the &#039;aggressor&#039; during collision tests,<br />&nbsp; &nbsp; &nbsp; &nbsp; ;which implies that it must be free to move, and actually be moving.&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; .if .CollisionBodyInstance.IsStatic==FALSE &amp;&amp; .CollisionBodyInstance.IsAwake==TRUE<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Compare BodyA against all bodies FURTHER along the list<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;This ensures that we are only testing UNIQUE PAIRS<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pop ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; push ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .while ecx&lt;.Bodies.dCount<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; push ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;For collision testing, we don&#039;t care if BodyB is static or asleep.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;We just want to know if BodyA collided with it.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall .Bodies::Collection.ItemAt,ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Make sure this CollisionPair does not already exist in the list...<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;This can ONLY happen if the list stays full through N timesteps<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;which in the current version of the code does not happen...<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall .CollisionPairs::CollisionPairList.FindCollisionPair,pBodyA,pBodyB<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==NULL <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Sweep the Spheres<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall BroadCheck_BodyBody,pBodyA,pBodyB<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==TRUE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fmul PhysicsTimeStep<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fstp fCollisionTime<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Find the exact moment of impact (if any)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or FoundCollisions,$OCall (esi.FindExactCollisionTime,pBodyA,pBodyB)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .if eax==Colliding&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fstp fCollisionTime<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fldz<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fstp fdepth<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Make a new CollisionPair record<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall .CollisionPairs::CollisionPairList.Insert,$New (CollisionPair)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall eax::CollisionPair.Init,pBodyA,pBodyB,fCollisionTime,fdepth<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .elseif eax==Penetrating<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fstp fCollisionTime<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fstp fdepth<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Make a new CollisionPair record<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall .CollisionPairs::CollisionPairList.Insert,$New (CollisionPair)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall eax::CollisionPair.Init,pBodyA,pBodyB,fCollisionTime,fdepth<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pop ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inc ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endw<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; pop ecx<br />&nbsp; &nbsp; &nbsp; &nbsp; inc ecx<br />&nbsp; &nbsp; .endw<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; mov eax,FoundCollisions<br />MethodEnd<br /></code></pre><br /><br />Now we have a sorted list of CollisionPair records.<br />We&#039;ve detected all the collisions between pairs of entities within the current timestep.<br />We know which pairs collided, and when.<br />This is important because we can expect simultaneous collisions to occur.<br />The ResolveCollisions method must be prepared to cope with sets of CollisionPair records which have the same Time Of Impact, and handle them simultaneously.<br /></div>
    <div class="meta">Posted on 2009-04-05 04:21:04 by Homer</div>
   </div>
   <div class="post" id="post-207226">
    <div class="subject"><a href="#post-207226">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">It&#039;s worth noting that the FindExactCollisionTime method also weeds out &#039;false positives&#039; - cases where a pair of boundingspheres collide, but the geometric entities inside those spheres never actually collide (ie a &#039;near miss&#039;).<br /><br />Now that we&#039;ve covered the first half of the collision detection (broadphase : identifying which pairs of entities truly do collide, and at what time they first touch), we can take a look at the ResolveCollisions method, then we&#039;ll go back to look more closely at the NarrowPhase collision detection (which is called from FindExactCollisionTime).<br /><br /><pre><code><br />;This method will detect and resolve collisions &#039;continuously&#039;<br />;until collisions fall outside the scope of the hardcoded physics timestep.<br />;Returns FPU = last known moment of impact within the current timestep<br />;(which is the most that we can advance the simulation)<br />Method Simulator.ResolveCollisions,uses esi<br />LOCAL fTimeTotal:real8,fTimeTemp:real8<br />LOCAL pPair<br /><br />&nbsp; &nbsp; SetObject esi<br />&nbsp; &nbsp; DbgWarning &quot;Resolving Collisions&quot;<br />&nbsp; &nbsp; fld PhysicsTimeStep<br />&nbsp; &nbsp; fstp fTimeTotal<br />&nbsp; &nbsp; <br /><br />&nbsp; &nbsp; <br /><br />&nbsp; &nbsp; DbgDec .CollisionPairs.dCount<br /><br /><br />&nbsp; &nbsp; .while .CollisionPairs.dCount!=0<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ;Peek at the first CollisionPair on the sorted list<br />&nbsp; &nbsp; &nbsp; &nbsp; OCall .CollisionPairs::CollisionPairList.ItemAt,NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ;Break if the collision time is outside the original scope of one physics timestep<br />&nbsp; &nbsp; &nbsp; &nbsp; fld fTimeTotal<br />&nbsp; &nbsp; &nbsp; &nbsp; fld .CollisionPair.CollisionTime<br />&nbsp; &nbsp; &nbsp; &nbsp; fst fTimeTemp<br />&nbsp; &nbsp; &nbsp; &nbsp; fsub<br />&nbsp; &nbsp; &nbsp; &nbsp; fstReg edx<br />&nbsp; &nbsp; &nbsp; &nbsp; .ifBitSet edx,BIT31 <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;This collision event is during the next TimeFrame<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DbgWarning &quot;Breaking because CollisionTime is outside scope of TimeStep&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DbgWarning &quot;How the heck did that happen?&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DbgFloat edx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int 3<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .break<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; fstp fTimeTotal<br /> <br />&nbsp; &nbsp; &nbsp; &nbsp;  ;Grab the first CollisionPair on the sorted list<br />&nbsp; &nbsp; &nbsp; &nbsp;  mov pPair,$OCall (.CollisionPairs::CollisionPairList.DeleteAt,NULL)<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ;Integrate the system to the earliest collision time<br />&nbsp; &nbsp; &nbsp; &nbsp; fld fTimeTemp<br />&nbsp; &nbsp; &nbsp; &nbsp; fstpReg edx<br />&nbsp; &nbsp; &nbsp; &nbsp; .if edx==0 || edx==80000000h<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DbgWarning &quot;Collision at TIME ZERO - Special Case&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int 3<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .else<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DbgWarning &quot;Integrating to Time Of Impact&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall esi.Integrate, fTimeTemp<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; ;Calculate the Collision Response<br />&nbsp; &nbsp; &nbsp; &nbsp; ;We will accumulate deltas of lin velocity and ang momentum<br />&nbsp; &nbsp; &nbsp; &nbsp; OCall esi.CollisionResponse,pPair<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ;Add the two entities to an output list of <br />&nbsp; &nbsp; &nbsp; &nbsp; ;all unique entities which were involved in collisions.&nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; mov ebx,pPair<br />&nbsp; &nbsp; &nbsp; &nbsp; OCall .CollidedBodies::DwordCollection.Insert, .CollisionPair.pBodyA<br />&nbsp; &nbsp; &nbsp; &nbsp; OCall .CollidedBodies::DwordCollection.Insert, .CollisionPair.pBodyB<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ;Release the CollisionPair<br />&nbsp; &nbsp; &nbsp; &nbsp; Destroy pPair<br /> <br /> @more:&nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; ;Loop for all CollisionPairs with the same Collision Time (simultaneous collision)<br />&nbsp; &nbsp; &nbsp; &nbsp; .while .CollisionPairs.dCount!=0<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Peek at the next item on the list<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall .CollisionPairs::CollisionPairList.ItemAt,NULL<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Break if the next collision time is greater<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fld fTimeTemp<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsub .CollisionPair.CollisionTime<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fstpReg edx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .ifBitSet edx,BIT31<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .break<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Grab the next item from the list<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov pPair,$OCall (.CollisionPairs::CollisionPairList.DeleteAt,NULL)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Calculate the Collision Response<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;We will accumulate deltas of lin velocity and ang momentum<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall esi.CollisionResponse,pPair<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Add the CollisionPair to list of CollidedBodies&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov ebx,pPair<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall .CollidedBodies::DwordCollection.Insert, .CollisionPair.pBodyA<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall .CollidedBodies::DwordCollection.Insert, .CollisionPair.pBodyB<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; .endw<br /> <br /><br />&nbsp; &nbsp; &nbsp; &nbsp; ;Subtract the earliest collision time from all remaining pairs<br />&nbsp; &nbsp; &nbsp; &nbsp; xor ebx,ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; .while ecx&lt;.CollisionPairs.dCount<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall .CollisionPairs::CollisionPairList.ItemAt,ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fld .CollisionPair.CollisionTime<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsub fTimeTemp<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fstp .CollisionPair.CollisionTime<br />&nbsp; &nbsp; &nbsp; &nbsp; .endw&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ;Apply the collision impulse deltas and swap the body states<br />&nbsp; &nbsp; &nbsp; &nbsp; ;of all bodies which were involved in collisions.<br />&nbsp; &nbsp; &nbsp; &nbsp; ;This exhausts the CollidedBodies collection.<br />&nbsp; &nbsp; &nbsp; &nbsp; OCall ApplyResponse, addr .CollidedBodies<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; ;Check if the collision event causes subsequent collisions<br />&nbsp; &nbsp; ;&nbsp; &nbsp; OCall esi.DetectCollisions<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; &nbsp; &nbsp; ;Repeat until no collision pairs remain, or collisions are outside the current timestep<br /><br />&nbsp; &nbsp; .endw<br />&nbsp; &nbsp; <br /><br />&nbsp; &nbsp; DbgWarning &quot;Resolved&quot;<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Return the time of the last known collision<br />&nbsp; &nbsp; DbgWarning &quot;Last known collision time:&quot;<br />&nbsp; &nbsp; DbgFloat fTimeTotal<br />&nbsp; &nbsp; fld fTimeTotal<br />MethodEnd<br /><br /></code></pre><br /><br />This method exhausts the list of CollisionPairs, advancing the simulation to each Time Of Impact, resolving all collisions at that Time, then advancing to the next Time Of Impact, and so on, until the list of CollisionPairs is exhausted.<br />If it finds a series of CollisionPairs with the same Time Of Impact, it processes them as a group, creating a list of entities which have been involved in collisions.<br />Collision Responses are calculated (as delta velocity and delta angular momentum), and are applied to each complete list of simultaneously-colliding entities.<br /><br />This function could use some work...<br />Currently, I have commented out a line which causes a recursive test for any further Collisions which are the direct result of our resolving of collisions... ie, where a body involved in a collision bounces off into some other body, causing a subsequent collision.<br />I&#039;m trying to decide how best to deal with this, however its nice to know that we&#039;re able to take advantage of our cache of CollisionPairs, we don&#039;t need to test CollisionPairs that are already cached.<br /><br />In my next post, we&#039;ll look at the Simulator.CollisionResponse method, then we&#039;ll look deeper into the NarrowPhase collision detection.</div>
    <div class="meta">Posted on 2009-04-05 21:32:35 by Homer</div>
   </div>
   <div class="post" id="post-207232">
    <div class="subject"><a href="#post-207232">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Attached is an image which shows the layout of the collision detection pipeline.<br />It should help some of you to better understand how the pieces fit together.<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2750" target="_blank">ColDet.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-04-06 02:42:32 by Homer</div>
   </div>
   <div class="post" id="post-207233">
    <div class="subject"><a href="#post-207233">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body"><br />Here&#039;s the Simulator.CollisionResponse method.<br />We&#039;ll notice that the Simulator supports a global list of Contacts.<br />After we&#039;ve looked at the attached code, we&#039;ll also notice that this list is temporary - I&#039;m simply avoiding destroying/recreating of this temp list by recycling the same collection object.<br /><br /><pre><code><br />;Generates / Resolves all contacts for a CollisionPair	<br />Method Simulator.CollisionResponse, uses esi ebx, pCollisionPair<br />	SetObject esi<br /><br />&nbsp; &nbsp; DbgWarning &quot;Simulator.CollisionResponse&quot;<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Build a list of Contacts between the bodies in this CollisionPair<br />&nbsp; &nbsp; OCall esi.GenerateContacts, pCollisionPair<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Resolve all the Contacts<br />&nbsp; &nbsp; .while .Contacts.dCount != 0<br />&nbsp; &nbsp; &nbsp; &nbsp; OCall .Contacts::Collection.DeleteAt,0<br />&nbsp; &nbsp; &nbsp; &nbsp; push eax<br />&nbsp; &nbsp; &nbsp; &nbsp; ;Resolve the Contact<br />&nbsp; &nbsp; &nbsp; &nbsp; OCall esi.ResolveContact, eax<br />&nbsp; &nbsp; &nbsp; &nbsp; ;Destroy the Contact - this version does not support Contact Caching...<br />&nbsp; &nbsp; &nbsp; &nbsp; ;If we keep Contacts across Frames, we can find &#039;Rests&#039; and &#039;Supports&#039;.<br />&nbsp; &nbsp; &nbsp; &nbsp; ;That&#039;s for a future version :)<br />&nbsp; &nbsp; &nbsp; &nbsp; pop eax<br />&nbsp; &nbsp; &nbsp; &nbsp; Destroy eax<br />&nbsp; &nbsp; .endw<br />MethodEnd<br /></code></pre><br /><br />Given a CollisionPair (which have been integrated to the Time Of Impact), this method will generate a set of simultaneous Contacts between these two Bodies, and it will calculate a response impulse for each contact, and the resulting changes to the linear velocity and angular momentum of each Body, accumulating these Deltas in the Bodies, but not Applying them to the physical state of the bodies.<br /><br />I&#039;m not going to delve too deeply into the calculation of physical response because I&#039;d rather continue to examine the collision detection stuff. However if you&#039;re really interested, you can ask :)<br /><br />So how exactly do we find the set of contacts for a collision between two bodies?<br />The next post will contain the code for the Simulator.GenerateContacts method.<br /></div>
    <div class="meta">Posted on 2009-04-06 03:04:02 by Homer</div>
   </div>
   <div class="post" id="post-207238">
    <div class="subject"><a href="#post-207238">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body"><br />Here is the Simulator.GenerateContacts method.<br />Given a CollisionPair, it will generate a set of Contacts between the two colliding bodies.<br />The code presented only handles Sphere/Sphere, Sphere/Mesh and Mesh/Mesh collisions.<br />I expect to support a number of other collision hulls, including geometric primitives (box, cylinder etc) and complex Convex Hulls. Some code already exists with this in mind.<br /><br /><pre><code><br />;A Pair of bodies are known to Collide at our best estimate of the Moment of Impact.<br />;We have integrated these Bodies to that moment in Time.<br />;This method detects and collects a list of Contacts between this Pair of bodies.<br />Method Simulator.GenerateContacts,uses esi,pCollisionPair<br />LOCAL pBodyInstanceA,pBodyInstanceB<br />local vAB:Vec3<br />LOCAL vContactPoint:Vec3<br />&nbsp; &nbsp; SetObject esi<br />&nbsp; &nbsp; ;The test function will be determined by the type of bounding hulls involved.<br />&nbsp; &nbsp; mov eax,pCollisionPair<br />&nbsp; &nbsp; m2m pBodyInstanceA,.CollisionPair.pBodyA, eax<br />&nbsp; &nbsp; mov eax,.CollisionBodyInstance.pOwner<br />&nbsp; &nbsp; .switch .CollisionBody.dShapeID<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; .case SHAPEID_SPHERE<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,pCollisionPair<br />&nbsp; &nbsp; &nbsp; &nbsp; m2m pBodyInstanceB,.CollisionPair.pBodyB,eax<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,.CollisionBodyInstance.pOwner<br />&nbsp; &nbsp; &nbsp; &nbsp; .switch .CollisionBody.dShapeID<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; .case SHAPEID_SPHERE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;In the case of two Spheres, there is only one Contact to consider,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;and it is rather trivial to calculate the Position and Contact Normal.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,pBodyInstanceB<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov eax,pBodyInstanceA<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Sub .CollisionBodyInstance.NewState.vPosition, .CollisionBodyInstance.NewState.vPosition<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vAB<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Normalize vAB&nbsp; ;nomalized direction from sphere a to sphere b<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov eax,pBodyInstanceA<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx,.CollisionBodyInstance.pOwner<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Scale vAB,.CollisionBody.fRadius<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_AddFrom .CollisionBodyInstance.NewState.vPosition<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Vec3_Stow vContactPoint<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall .Contacts::Collection.Insert,$New(Contact,Init,pCollisionPair,addr vContactPoint,addr vAB)<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; .case SHAPEID_MESH<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;SPHERE versus MESH<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Usually there will just be one Contact, but there COULD be more.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Let&#039;s search the Mesh&#039;s BVH Tree for Triangles which are<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;either Touching or Intersecting the Sphere.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pBodyInstanceB::CollisionBodyInstance.Find_Contacts_versus_Sphere,pBodyInstanceA,pCollisionPair,addr .Contacts<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; .default<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DbgWarning &quot;Unhandled BodyShape B in GenerateContacts&quot;&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; .endsw<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; .case SHAPEID_MESH<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,pBodyInstanceB<br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,.CollisionBodyInstance.pOwner<br />&nbsp; &nbsp; &nbsp; &nbsp; .switch .CollisionBody.dShapeID<br />&nbsp; &nbsp; &nbsp; &nbsp; .case SHAPEID_SPHERE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;MESH versus SPHERE<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;We know how to handle this one, yes?<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pBodyInstanceA::CollisionBodyInstance.Find_Contacts_versus_Sphere,pBodyInstanceB,pCollisionPair,addr .Contacts<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; .case SHAPEID_MESH<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;MESH versus MESH<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Search both BVH Trees for all Contacts.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OCall pBodyInstanceA::CollisionBodyInstance.Find_Contacts_versus_Mesh,pBodyInstanceB,pCollisionPair,addr .Contacts<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; .default<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DbgWarning &quot;Unhandled BodyShape B in GenerateContacts&quot;&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; &nbsp; &nbsp; .endsw<br />&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; .default<br />&nbsp; &nbsp; &nbsp; &nbsp; DbgWarning &quot;Unhandled BodyShape A in GenerateContacts&quot;<br />&nbsp; &nbsp; &nbsp; &nbsp; int 3<br />&nbsp; &nbsp; .endsw<br />&nbsp; &nbsp; <br />MethodEnd<br /></code></pre><br /><br />We can see that the Sphere/Sphere case is trivial... one Contact is generated on the surface of Sphere A , and in the direction of Sphere B.<br />Next, we&#039;ll continue deeper, looking at the code for Mesh/Sphere and Mesh/Mesh contact generation.</div>
    <div class="meta">Posted on 2009-04-06 06:20:19 by Homer</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29229&amp;page=1" style="">&laquo;</a><a href="../?id=29229&amp;page=5" style="">&lt;</a><input type="hidden" name="id" value="29229" /><input type="number" name="page" min="1" max="7" step="1" value="6" onchange="this.form.submit();" /><a href="../?id=29229&amp;page=7">&gt;</a><a href="../?id=29229&amp;page=7">&raquo;</a></form>  </div>
 </body>
</html>