<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <title>Better, Faster, Stronger Physics 2009 - Forums - ASM Community</title>
  <link rel="stylesheet" type="text/css" href="../../../style.css" />
  <link rel="canonical" href="../?id=29229" />
  <link rel="prev" href="../?id=29229&amp;page=4" />  <link rel="next" href="../?id=29229&amp;page=6" /> </head>
 <body>
  <div id="header">
   <h1><a href="../../../">ASM Community</a></h1>
  </div>
  <div id="content">
   <p class="breadcrumbs"><a href="../../../">Home</a> &raquo; <a href="../../">Forums</a> &raquo; <a href="../../board/?id=10">Graphics &amp; Game Development</a> &raquo; <a href="../?id=29229">Better, Faster, Stronger Physics 2009</a></p>
<form class="pagination" action="../" method="get"><a href="../?id=29229&amp;page=1" style="">&laquo;</a><a href="../?id=29229&amp;page=4" style="">&lt;</a><input type="hidden" name="id" value="29229" /><input type="number" name="page" min="1" max="7" step="1" value="5" onchange="this.form.submit();" /><a href="../?id=29229&amp;page=6">&gt;</a><a href="../?id=29229&amp;page=7">&raquo;</a></form>   <div class="post" id="post-206759">
    <div class="subject"><a href="#post-206759">Re: GJK Algorithm</a></div>
    <div class="body">There was a mathematician called Minkowski who found a way to perform math operations with 3D convex polygons.<br />He is most famous for an equation called the Minkowski Sum, which is something like this:<br />For two bodies A and B:<br /><br />&nbsp; For X = each point in A<br />&nbsp; &nbsp; For Y = each Point in B<br />&nbsp; &nbsp; &nbsp;  Q = X + Y<br />&nbsp; &nbsp; &nbsp;  Add Q to list<br />&nbsp; &nbsp; EndFor<br />&nbsp; EndFor<br /><br />For collision detection purposes, we should be very interested in an equation called the Minkowski Difference.<br />Instead of collecting a list of the sum of all combinations of two points, we want to collect a list of the difference..<br />&nbsp; &nbsp;  Q = X - Y<br /><br />Furthermore, having generated this &#039;cloud of points&#039;, we are actually only interested in those points which lay apon the &#039;surface&#039;, forming a &#039;convex hull&#039;... this is known as the &#039;surface&#039; of the Minkowski difference.<br /><br />Please watch this video, I&#039;ve watched it several times.<br /><br />http://mollyrocket.com/849<br /><br /><br />This collision test supports optimizing based on our prior knowledge of the input geometries, it works for any pair of 3D objects at any orientation, and it&#039;s faster than it sounds.<br />This is gold.<br /><br /></div>
    <div class="meta">Posted on 2009-01-29 20:50:38 by Homer</div>
   </div>
   <div class="post" id="post-206760">
    <div class="subject"><a href="#post-206760">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">The algorithm is based apon a particular property of the Minkowski Difference.<br />If the Origin of the World is inside the 3D convex hull we know as the Minkowski Difference, then the two input polygons are intersecting.<br /><br />The GJK algorithm uses an incremental search to find a 3D tetrahedron which is formed from the points of the Minkoswki Difference and which encloses the Origin.<br />If we can find a tetrahedron which encloses the Origin, then the two shapes intersect.<br /><br />For each shape, we write a function which, given a direction, can find the bounding point furthest along in that direction. This is our &#039;Support&#039; function.That is the core function apon which this algorithm is based.<br /><br />In order to test for intersection of two bodies, it is sufficient to begin with any point that lays apon the surface of the Minkowski difference - ie, &quot;any point in A minus any point in B&quot;.<br /><br />Luckily, I&#039;ve already provided functions to transform vectors from worldspace to bodyspace and back again.<br />This means we can transform a WorldSpace direction into each BodySpace in order to find the maximal point in any given direction.<br /><br />In bodyspace, how do we find the furthest point in a given direction?<br />We simply use a DotProduct (direction, point).<br />If its negative, then the point is in the wrong direction, its backwards, so its not useful.<br />And if its positive, we want the one that is most positive.<br />We don&#039;t need to normalize anything, we don&#039;t care about scale, just direction.<br />So the &#039;Support&#039; function can be very optimized based on the shape.<br /><br />In order to search for a tetrahedron which encloses the origin, we use a thing called a Simplex.<br />It is a set of 2, 3 or 4 points taken from the Minkowski Difference.<br />You can think of it as an Edge, a Triangle or a Tetrahedron.<br />This list of points is central to our search for a tetrahedron which encloses the Origin.<br />We use it to &#039;walk&#039; the surface of the Minkowski sum, always seeking the direction of the Origin from our current Simplex. <br /><br />It can return the penetration / separation distance for the pair, which is very nice since we can then apply our Penetration Correction code in order to move the bodies back out of penetration based on their linear and angular motions, and accelerate our search for Time of Impact.<br /><br /><br /></div>
    <div class="meta">Posted on 2009-01-29 21:08:12 by Homer</div>
   </div>
   <div class="post" id="post-206763">
    <div class="subject"><a href="#post-206763">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">As I mentioned, we&#039;re interested only in the points of the Minkowski Difference which lay apon its (convex) surface (and not any points which fall inside its volume).<br />For two input bodies A and B, this means we&#039;re interested in the most extreme points of A and B that are in opposite directions in worldspace ... if we&#039;re given a direction D in worldspace, and we find the most extreme point on the (oriented) body A in that direction, then we must also grab the the most extreme point on B in the MINUS D direction, then subtract B from A. This gives us a guarantee that the point we calculated is on the very outside boundary of the surface represented by the Minkowski difference.<br /><br />As Casey points out in his video presentation, it is sufficient to begin the GJK algorithm with any point on the surface of the Minkowski difference - ie, any point in A minus any point in B is good enough to start with.<br />But bearing in mind that our goal is to attempt to enclose the Origin with a tetrahedron, we can pick our starting point with a little more intelligence, by selecting an intelligent Direction for our first call to our Support function.<br /><br />For &#039;swept&#039; GJK testing, we might use the vector of the relative motions of A and B.<br />For &#039;instantaneous&#039; testing, simply the vector between their origins.<br /><br />Again, as Casey points out, it shouldn&#039;t make a whole lot of difference, since this algorithm is very good at &#039;converging&#039; apon a solution within a small number of iterations (search steps).<br /><br /><br />In regards to the Support function, I mentioned that we can optimize this function based on our prior knowledge of the specific geometry we&#039;re working with.<br />Let&#039;s have a look at my Support function for a Box:<br /><pre><code><br />;Given a Direction vector (in WorldSpace),<br />;this method returns the bounding point which is furthest in that Direction.<br />;The point is returned in WorldSpace.<br />;** Returns Vec3 on FPU<br />Method CollisionBox.Get_GJK_Support,uses esi,pvDirection_WorldSpace<br />LOCAL vDir:Vec3<br />&nbsp; &nbsp; SetObject esi<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Transform the Direction vector from WorldSpace to BodySpace<br />&nbsp; &nbsp; mov edx,pvDirection_WorldSpace<br />&nbsp; &nbsp; Mat33_TransMult_Vec3 .OldState.Orientation,.Vec3&nbsp; ;unrotate<br />&nbsp; &nbsp; Vec3_Stow vDir<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Select the Support vertex via the sign of the axes<br />&nbsp; &nbsp; fld .fHalfWidth<br />&nbsp; &nbsp; .ifBitSet vDir.x, BIT31<br />&nbsp; &nbsp; &nbsp; &nbsp; fchs<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; fld .fHalfHeight<br />&nbsp; &nbsp; .ifBitSet vDir.y, BIT31<br />&nbsp; &nbsp; &nbsp; &nbsp; fchs<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; fld .fHalfLength<br />&nbsp; &nbsp; .ifBitSet vDir.z, BIT31<br />&nbsp; &nbsp; &nbsp; &nbsp; fchs<br />&nbsp; &nbsp; .endif<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; ;Transform the &#039;best&#039; point back into WorldSpace<br />&nbsp; &nbsp; Vec3_Stow vDir<br />&nbsp; &nbsp; OCall esi.Transform_Vec3_BodyToWorld, addr vDir<br /><br />MethodEnd<br /></code></pre><br /><br />We can see that I choose to transform the Direction vector into BodySpace so that I can more intelligently select the point which is furthest in that direction.<br />Once I&#039;ve got the direction relative to the origin of the Box (rather than the World), I can just check the sign of each axis in the vector to determine which &#039;octant&#039; we&#039;re pointing at, and therefore, which corner vertex we want.<br /><br /><br />For polygons whose geometry is arbitrary, we have another test.<br />Because we&#039;re keeping a copy of the WORLDSPACE (oriented and translated) bounding points for each Body (updated by the Integrate method), we&#039;re able to work directly in WorldSpace.<br />We will find the Dotproduct of the Direction and each Point.<br />We wish to find the Point which produces the most positive Dot, as it is the point furthest in that direction.<br />Points which produce a negative dot are &#039;behind&#039; our direction, ie, in the wrong direction, and not interesting to us.<br /><br /><pre><code><br />;Given a Direction vector (in WorldSpace),<br />;this method returns the bounding point which is furthest in that Direction.<br />;Point is returned in WorldSpace.<br />;** Returns Vec3 on FPU<br />Method CollisionPolygon.Get_GJK_Support,uses esi edi,pvDirection_WorldSpace<br />LOCAL fmax:real4<br />LOCAL pmax<br />LOCAL fCur:real4<br />&nbsp; &nbsp; SetObject esi<br />&nbsp; &nbsp; <br />&nbsp; &nbsp; mov edi,.pOwner&nbsp; &nbsp; <br />&nbsp; &nbsp; xor ebx,ebx&nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; mov fmax,ebx<br />&nbsp; &nbsp; .while ebx&lt;.CollisionBody.BoundingPoints.dCount <br />&nbsp; &nbsp; &nbsp; &nbsp; mov eax,sizeof Point<br />&nbsp; &nbsp; &nbsp; &nbsp; mul ebx<br />&nbsp; &nbsp; &nbsp; &nbsp; add eax,.pWorldBoundingPoints<br />&nbsp; &nbsp; &nbsp; &nbsp; mov edx,pvDirection_WorldSpace&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; Vec3_Dot .Vec3,.Vec3<br />&nbsp; &nbsp; &nbsp; &nbsp; fst fCur<br />&nbsp; &nbsp; &nbsp; &nbsp; .ifBitClr fCur,BIT31&nbsp; &nbsp; &nbsp; &nbsp; ;negative is not useful to us - direction is backwards<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsub fmax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fstpReg edx<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .ifBitClr edx,BIT31&nbsp; &nbsp; &nbsp;;if cur-max is positive, then cur&gt;=max<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov pmax,eax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;we got a new &#039;best candidate&#039;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m2m fmax, fCur<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; .endif<br />&nbsp; &nbsp; &nbsp; &nbsp; inc ebx<br />&nbsp; &nbsp; .endw<br />&nbsp; &nbsp; mov eax,pmax<br />&nbsp; &nbsp; Vec3_Load .Vec3<br /><br />MethodEnd<br /></code></pre><br /><br />Even though the geometry of the convex polygon is not clearly defined, we are nonetheless able to find the maximal boundingpoint in a given direction :)<br /><br />We can go ahead and write Support functions for all the geometric primitives that we might use, eg capsules, cones, ellipses etc, even though their surfaces are only described &#039;implicitly&#039;, and not as a set of bounding points, as long as we&#039;re able to return a point on the surface of the body in a given direction, we&#039;re happy :)<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2009-01-30 19:25:49 by Homer</div>
   </div>
   <div class="post" id="post-206799">
    <div class="subject"><a href="#post-206799">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">So, we now know how to write the Support function for each 3D shape.<br /><br />If we&#039;re implementing GJK, we need a function that works for a pair of arbitrary bodies.<br />This new function must return a Support point for the Minkowski Difference of two bodies.<br /><br />So, let&#039;s rephrase the problem.<br />Given two Bodies, and a Direction vector in worldspace, return a point on the surface of the Minkowski Difference (MD).<br /><br />What we want is the support on A in Direction D, minus the support on B in Direction MINUS D.<br /><br />vA=A.Support(D)&nbsp;  ... support on A, direction D<br />vB=B.Support(-D) ... support on B, direction -D<br />vC=vA-vB&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ... support on Minkowski Difference, direction D<br /><br />Now that we can see clearly how to find Supports on the MD surface, we can start to examine the rest of the algorithm.<br /></div>
    <div class="meta">Posted on 2009-02-02 23:59:07 by Homer</div>
   </div>
   <div class="post" id="post-206800">
    <div class="subject"><a href="#post-206800">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">The complete GJK algorithm has three parts.<br />So far we&#039;ve taken a close look at the Support function (for MD, and its subfunction for each shape).<br /><br />The main part of the GJK algorithm is a closed loop with two exit conditions.<br />Let&#039;s take a look at it.<br />I&#039;m writing the pseudocode for this, look below for a step by step explanation.<br /><br />1. S = Support(?)<br />2. &#91;] = S<br />3. D = -S<br />4. LOOP<br />5.&nbsp; &nbsp; &nbsp; A = Support(D)<br />6.&nbsp; &nbsp; &nbsp; IF Dot(A,D) &lt; 0<br />7.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (exit - there is no intersection)<br />8.&nbsp; &nbsp; &nbsp; ENDIF<br />9.&nbsp; &nbsp; &nbsp; &#91;] += A<br />10.&nbsp; &nbsp; &nbsp; IF (DoSimplex(&#91;],D) = TRUE<br />11.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(exit - there IS an intersection)<br />12.&nbsp; &nbsp; ENDIF<br />13. UNTIL 0<br /><br />1: find S = a Support on the MD in ANY DIRECTION.<br /><br />2: add this Point to a container that will represent our current Simplex.<br /><br />3. set D = -S ... given that S is a point on the surface of MD, we can imagine a scaled vector from the World Origin in the direction of S, and possibly on the other side of the World Origin.. remember, GJK doesn&#039;t need normalized direction vectors, scale is not important. D is the direction that goes from S back toward the World&nbsp; Origin. From now on I&#039;ll just mention &#039;origin&#039; and it means &#039;World Origin&#039;.<br /><br />4. Begin an infinite Loop.. we&#039;ll break out of it if we need to.<br /><br />5. find A = a Support on the MD in the specific direction D<br />This is the point that is furthest away from S in the direction of the origin.<br /><br />6 - 7 - 8. Use a dotproduct to compare our current search direction D and the direction (from the Origin to) A.<br />If its negative, then S and A are on the same side of the Origin - we never actually reached the origin, so we can&#039;t possibly enclose it... there can&#039;t possibly be any intersection of this pair of bodies, so we&#039;re done.<br />If its positive, then S and A are on opposite sides of the origin, and so we&#039;ll continue.<br /><br />9. Add the new point to our Simplex<br /><br />10 11 12. Perform magical Simplex function , handing it our Simplex and D(irection).<br />If the result is TRUE, then bodies A and B are intersecting, we&#039;re done.<br /><br />13. Repeat loop until the cows come home.<br /><br /><br />In my next post, we&#039;ll look at the third and final part of this algorithm, the magical and mysterious Simplex function, where we&#039;ll learn exactly what a Simplex is, because we&#039;ll be using it.<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2009-02-03 00:44:22 by Homer</div>
   </div>
   <div class="post" id="post-206802">
    <div class="subject"><a href="#post-206802">Re: Voronoi Regions are not scary</a></div>
    <div class="body">For the purposes of GJK, a Simplex is a group of two, three, or four points which describe an Edge, a Triangle or a Tetrahedron respectively.<br /><br />The GJK algorithm searches the surface of the MD for a Tetrahedron which encloses the Origin. It does this by building an edge which encloses the origin, then a triangle which encloses the origin, then trying to find a fourth point to form a tetrahedron which encloses the origin, trying new points at the same level of complexity or falling back to the next lower order of complexity if the origin is not enclosed.<br /><br />The Simplex describes the current test geometry during this search.<br /><br />If you look back to the main algorithm in the previous post, you&#039;ll notice that when we first call the DoSimplex function, our Simplex contains two points.<br />In fact, it will never contain less than two, and never more than four.<br /><br />Rather than describing what DoSimplex does, I&#039;ll begin by describing its input and output.<br />Given a Simplex of 2,3 or 4 points and our current D(irection of search), it will return a new Simplex, and it may return a new D.<br /><br />So, how does DoSimplex work, and what does it look like?<br />Basically, inside this function will be some code to handle each of the three levels of complexity of the input simplex ... ie, there will code to deal with an input Edge, code to deal with an input Triangle, and code to deal with an input Tetrahedron.<br /><br />I&#039;ll use Casey&#039;s naming convention, which is that &#039;Point A is the most recent point obtained from the Support function&#039;.<br /><br />Assuming we have just started the algorithm, the very first point we obtained is B, and the second point (obtained in the direction from B to the Origin) is A.<br /><br />&nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|<br />&nbsp; &nbsp; &nbsp; B---------A<br />3&nbsp; &nbsp; &nbsp;|&nbsp; 2&nbsp; &nbsp; &nbsp; &nbsp;| 1<br /><br /><br />See that we can visualize three &#039;Voronoi Regions&#039;.... it might not have occurred to you that even an Edge can be broken into Voronoi Regions, hehe...<br />We wish to determine which Region the Origin lays within.<br />It&#039;s not immediately obvious, but the Origin cannot possibly be in Region 3.<br />B is the first point we chose, and A was chosen to be in the direction of the origin.<br />So we know that the origin cannot be &#039;behind&#039; B.<br />It might be somewhere between A and B (region 2), or somewhere on the other side of A (region 1). But we can totally forget about region 3.<br />In order to find out which region the origin is in, we&#039;ll cast a ray backwards from A to B... we&#039;ll compare the direction of AB to the direction of AO.<br />&quot;Is the arrow from A to B pointing roughly the same way as the arrow from A to Origin?&quot;<br />Our pseudocode for this test is:<br /><br />IF Dot(AB, AO) &gt; 0 (direction from A to Origin is similar to direction from A to B, therefore Origin is between A and B)<br />&nbsp; D = AB cross AO cross AB (new direction is perpendicular to AB and AO)<br />&nbsp; &#91;] = AB (no change to simplex, we&#039;re happy with this Edge, we want to try to add a third point and so form a Triangle)<br />ELSE (direction AO is NOT similar to direction AB, so the Origin is NOT between A and B, its somewhere behind A, we failed to enclose the origin with this simplex)<br />&nbsp; D = AO (new direction is from A toward the origin)<br />&nbsp; &#91;] =  (we reduced the simplex, we discarded the OLD point, we want to try a new Edge starting at the newer point A)<br />ENDIF<br /><br />ok, so if the Origin fell into region 2 (ie between A and B), we&#039;ll set a new search direction perpendicular to the existing edge, and when we return and add a new point in that direction, we are actually trying to form a triangle around the origin.<br /><br />But if the Origin fell into region 1 (the far side of A), then edge BA did not reach the Origin yet, so we&#039;ll correct our direction to AO (from the new point toward the origin), and we&#039;ll dump our older point B from the simplex. When we return and add a new point in the new direction, we&#039;ll actually be forming a new Edge whose endpoints are more likely to fall on either side of the Origin (ie the previous case, region 2).<br /><br />Note that we are once more using the sign of a dotproduct when comparing direction vectors, just like we do in the main algorithm.<br /><br />So, there you have it, that is all we need to do for the Edge Simplex.<br />You can now understand how the main algorithm will either try another edge (same complexity), or form a triangle (higher complexity).<br /><br />My next post will be about handling the Triangle Simplex.<br /></div>
    <div class="meta">Posted on 2009-02-03 07:51:37 by Homer</div>
   </div>
   <div class="post" id="post-206804">
    <div class="subject"><a href="#post-206804">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Below is a Triangle excuse the ascii art.<br />I&#039;m going to draw it the same way that Casey did, however it should be mentioned that the conventional winding order for triangles is COUNTER clockwise... this will matter when we need to know which is the &#039;front&#039; of the triangle and which is the &#039;back&#039; of it.<br />Anyway, here&#039;s our triangle, I guess we&#039;re looking at the back of it because its winding order is clockwise...<br /><br /><br /><br />\ 6&nbsp; /<br />&nbsp; &nbsp; C&nbsp; &nbsp; &nbsp; 1<br />&nbsp; &nbsp; &nbsp; &nbsp;+<br />&nbsp; &nbsp; +&nbsp; &nbsp; &nbsp; +&nbsp; &nbsp; /<br />7&nbsp; &nbsp; &nbsp; 2,3&nbsp; &nbsp; A&nbsp; &nbsp;5<br />&nbsp; &nbsp; +&nbsp; &nbsp; &nbsp; +&nbsp; &nbsp; \<br />&nbsp; &nbsp; &nbsp; &nbsp;+<br />&nbsp; &nbsp; B&nbsp; &nbsp; &nbsp; &nbsp;4<br />/ 8&nbsp; \<br />&nbsp; <br /><br />Point A is the most recently added point, and points B and C are the input edge (ie A and B in the previous posting).<br /><br />Although there are eight Voronoi Regions for a Triangle, for this algorithm we can safely ignore regions 6, 7 and 8... if BC are the points of our old edge, and A was selected in the direction of the origin, then the origin CANNOT be behind the BC edge, its somewhere towards A.<br /><br />So let&#039;s see the algorithm which determines which of the five potential regions the origin is within... note that &#039;x&#039; is a CrossProduct operator, and pairs of letters indicate EDGES ie AB is EDGE AB = B - A ok ?<br /><br />vABC = AB x AC&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;Plane Normal<br />IF Dot(vABC x AC) , AO) &gt; 0&nbsp; &nbsp; &nbsp; ;is the origin above edge AC?<br />&nbsp; IF Dot(AC,AO) &gt; 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;is the origin&nbsp; between A and C?<br />&nbsp; &nbsp; &#91;] = &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;region 1<br />&nbsp; &nbsp; D = AC x AO x AC<br />&nbsp; ELSE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;origin is in region 4 or 5<br />&nbsp; &nbsp; GOTO CASEY<br />&nbsp; ENDIF<br />ELSE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;origin is below edge AC<br />&nbsp; IF Dot((AB x vABC) , A0) &gt; 0&nbsp; &nbsp; ;if origin is in region 4 or 5<br />&nbsp; &nbsp; GOTO CASEY <br />&nbsp; ELSE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;origin is in region 2 or 3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  <br />&nbsp; &nbsp; IF Dot(vABC, AO) &gt; 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;is origin in front of triangle<br />&nbsp; &nbsp; &nbsp; &nbsp;&#91;] = &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;region 2<br />&nbsp; &nbsp; &nbsp; &nbsp;D = vABC<br />&nbsp; &nbsp; ELSE<br />&nbsp; &nbsp; &nbsp; &nbsp;&#91;] = &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;region 3<br />&nbsp; &nbsp; &nbsp; &nbsp; D = -vABC&nbsp; ;note sign&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br />&nbsp; &nbsp; ENDIF<br />ENDIF<br /><br />CASEY:<br />IF (Dot(AB, AO) &gt; 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ;is origin between A and B<br />&nbsp; &#91;] = &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;region 4<br />&nbsp; D = AB x AO x AB<br />ELSE<br />&nbsp; &#91;] = A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;region 5<br />&nbsp; D = AO<br />ENDIF<br /><br />Just like last time, we&#039;re performing dotproducts to find out which region the origin is within, and we&#039;re using crossproducts to generate new directions perpendicular to existing edges.<br /><br />In my next post, we&#039;ll look at the handler for tetrahedrons, then we will have seen the complete GJK algorithm implemented in pseudocode, and hopefully we&#039;ve learned enough to implement it in our language of choice :)<br /><br /><br /></div>
    <div class="meta">Posted on 2009-02-04 01:38:01 by Homer</div>
   </div>
   <div class="post" id="post-206805">
    <div class="subject"><a href="#post-206805">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">OK, here&#039;s the test that Casey didn&#039;t provide..<br /><br />Attached is an image which shows a tetrahedron.<br />The black triangle (BCD) at the bottom of the tetrahedron is the input triangle (simplex).<br />The red edges lead to a new point which is in the direction of the origin (from the triangle).<br />This construction has four triangular faces... one we&#039;ve seen before, and three new ones.<br />They are ABC, ACD and ADB. We will use some point/plane tests to determine which region the origin lays within.<br /><br />Yet again, there are subspaces where the origin simply cannot be.<br />We know that it can&#039;t be below triangle BCD because we already tested that.<br />So we only need to perform tests against the remaining three planes, ie, the new planes of the new triangles.<br /><br />So far we&#039;ve only been interested in the Surface Normal of a triangle.<br />This tells us the direction which the Plane is facing, but does not tell us where in space the Plane is located.<br /><br />In order to find the Plane of a triangle We need to know the Plane Equation:<br />AX + BY + CZ + D = 0<br /><br />ABC are the points of the triangle, and D is the distance from world origin to the plane.<br />Hey, D is exactly what we need .. Plane Distance to origin... we won&#039;t need to actually test point versus plane, we already have what we need.<br /><br />We just need to rearrange it to get:<br />D = AX + BY + CZ , where ABC are points of a triangle, and XYZ is the normal of the triangle.<br />If the sign of D is negative, then the origin is behind this triangle, and so potentially inside the tetrahedron.<br />But if the sign is positive, then the origin is outside the tetrahedron, we can return FALSE.<br /><br />We perform this test apon all three new triangles, and if the origin is behind them all, then it is inside the tetrahedron.<br /><br />If we keep the D values for these three tests, and find the D value for our OLD triangle, we can now determine which side of the tetrahedron the origin is closest to, which tells us the direction AND the depth of the penetration.<br /><br />We can return TRUE, and we can return the penetration data, which we could use to perform a Penetration Correction that should bring our Bodies to the time of impact (TOI) without needing to search the timestep for it.... or at least to predict the TOI.<br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2723" target="_blank">Tetrahedron.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-02-04 03:03:02 by Homer</div>
   </div>
   <div class="post" id="post-206815">
    <div class="subject"><a href="#post-206815">Re: Penetration Detection and Correction</a></div>
    <div class="body">Now we have all the pseudocode to implement a GJK penetration detector which returns maximum penetration depth.<br /><br />Rest assured I will post actual code for this, however I will forge on with these postings while I set about implementing and debugging the GJK code.<br /><br />1. We integrated the system from time zero (T0) to the end of the timestep (T1).<br /><br />2. We used a sphere sweep test to find the first (TS) and last (TE) contact times of the boundingspheres of body A and body B (TS). <br /><br />We now know that the SPHERES first touch at TS, and they separate from each other at TS.<br /><br />Generally, the timeline looks like this:<br /><br />T0 ...... TS(..penetrating..)TE ...... T1<br /><br />The time at which the BODIES first make contact (TOI) is somewhere between TS and TE.<br />Let&#039;s use a little intuition here. At the halfway point between TS and TE (we&#039;ll call it TM), the bodies are probably at their worst possible penetration, basically overlapping in space... so the TOI is probably somewhere between TS and that midpoint.<br /><br />We could employ a binary search for the exact TOI which would integrate the bodies to various times while &#039;shrinking the search window&#039;, but let&#039;s get serious.<br /><br />#1 - this is for games, we only aim for plausible results, we&#039;re not trying to simulate reality. #2 - our timestep is only one tenth of a second (by default), and a fraction of one tenth of a second is hardly worth worrying about.<br /><br />So we could just assume that TOI = ((TM-TS)/2) + TS<br />That would place TOI halfway between TS and TM.<br />We can be pretty damned sure that the bodies will be penetrating at this time, and we can also be pretty damned sure that the penetration is shallow (the bodies are well within the first fifty percent of the overlapping region of the projection of their boundingspheres).<br /><br />So, having found TOI quickly and within a reasonable accuracy, do we actually NEED a GJK collision test at all? After all, it can&#039;t actually tell us much about the COLLISION, it can only tell us about the PENETRATION, it can&#039;t tell us about multiple CONTACTS, just the maximum penetration depth and direction.<br /><br />Well, we can still use it.<br />Given that we have a pretty good idea that the bodies are actually penetrating slightly at our estimated TOI, we can run one pass of our GJK, expecting it to always return TRUE (penetrating), and we can hand the returned max. penetration depth to our Penetration Correction mechanism.<br /><br />My next post will discuss Penetration Correction.</div>
    <div class="meta">Posted on 2009-02-06 01:53:54 by Homer</div>
   </div>
   <div class="post" id="post-206816">
    <div class="subject"><a href="#post-206816">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">So, we used GJK to test for penetration at estimated TOI, which is the time that is 50% between TS and TM.<br />We found a penetration, and measured its depth, and its direction.<br />How can we correct the error in our TOI estimate?<br /><br />We need to examine the relative motion of the two bodies.<br />For each body, we need to find out how much the linear and angular components of its motion contributed to the penetration.<br />I&#039;ve already provided code for this, see the Simulator.Correct_Penetration method.<br />This method will &#039;wind the bodies backward&#039;, so that the Bodies are now &#039;just touching&#039;, and we can perform collision response.<br /><br />This results in the pair of bodies being glitched very slightly forwards in time (with respect to the rest of the simulation), and we COULD estimate the time correction and adjust for it, but I&#039;m not going to bother since I don&#039;t think the order of microcollisions is going to be a huge concern for gaming purposes..<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2009-02-06 05:22:44 by Homer</div>
   </div>
   <div class="post" id="post-206820">
    <div class="subject"><a href="#post-206820">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">So, we have integrated our bodies to the estimated time of impact ...Now we need to check the ACTUAL GEOMETRY for collision, and if they are colliding, we want to generate one or more CONTACTS, where a Contact is a point of collision on both bodies, and a Normal which describes the Direction which will be used to separate the bodies at this contact point.<br /><br />I&#039;m going to restrict my discussion to Oriented Bounding Boxes for now.<br /><br />There&#039;s a number of ways we could determine the set of contacts for a pair of boxes, and the most obvious is to determine which Points of each box are inside the space occupied by the other box... however, this method is inefficient because we&#039;re testing all points of each box against all planes of the other, which is 8 x 6 x 2 = 96 dotproducts, and we&#039;ll completely miss &#039;edge/edge&#039; collisions!!<br /><br />Another option is to test all Edges of each body against all Planes of the other body, which yields 12 x 6 x 2 = 144 dotproducts. Now we&#039;ve caught the &#039;edge/edge&#039; collisions, but we&#039;re performing even more tests than before!!<br /><br />Obviously, we want to perform as few tests as possible, so how can we optimize this?<br /><br />The answer is to determine the CLOSEST PAIR OF FEATURES from each Body, where a Feature is a Point, an Edge, or a Face.<br /><br />So, given that our Primary Goal is to find the closest pair of features, then our Secondary Goal is to formulate an algorithm which works for arbitrary geometry rather than just for boxes - we&#039;ll just keep that in mind as we write our method for a pair of Boxes, so that we don&#039;t have too much trouble supporting other shapes.<br /><br />In my next post, we&#039;ll take a look at how we might find the closest features for a pair of boxes, and how to use this knowledge to determine a set of contacts.<br /><br /><br /><br /><br />Request For Feedback:<br />Do you enjoy reading this thread? Is it too complex? Too simple?<br />Do you find this thread educational? Enlightening? Inspiring? Boring?<br />Do you feel I cover each topic thoroughly? Do I gloss over some things? Have I completely failed to mention anything?<br /><br />Please let me know as I will attempt to address any shortcomings.<br /><br /></div>
    <div class="meta">Posted on 2009-02-07 23:25:16 by Homer</div>
   </div>
   <div class="post" id="post-206821">
    <div class="subject"><a href="#post-206821">Re: Finding the closest pair of features</a></div>
    <div class="body">There&#039;s already a well-known algorithm for doing this, it&#039;s called the Lin-Canny Algorithm, and it works by testing the distance between all possible pairs of features apon a pair of bodies... this is simply a bruteforce approach, and we&#039;ve already established that bruteforce is not the way we want to go... it&#039;s too slow, too costly.<br /><br />So again I ask you, how can we optimize this?<br /><br />Sometimes when a problem seems too difficult to solve, it can be useful to redefine the problem.<br />So let&#039;s take a look at the image I&#039;ve attached... scary, isn&#039;t it? The image is showing the Voronoi Regions around a 3D box... unfortunately, we can&#039;t see the whole box since its just a 2D image, but we can imagine the Voronoi regions that we can&#039;t see. What matters most is that we realize that each Voronoi Region is associated with exactly one Feature (point, edge or face)... if we can find the Voronoi Region (VR) which encloses a test point, then we have found the closest feature to that test point.<br /><br />We also already established that Voronoi Regions are not as scary as they appear.<br />Given that the Box is constructed from eight points, six faces and twelve edges, and there is one VR for each feature, that means there must be 26 VR&#039;s in total... that&#039;s just for this box.<br />If we were to test all possible combinations of VR&#039;s on TWO boxes, we would have 26^2 tests to perform, thats 626 tests, this SOUNDS like the worst method we&#039;ve encountered so far!<br /><br />I&#039;m going to show you how we can cut that down to about 6 tests per box, by using the same technique we saw in the GJK simplex resolver.. this solution assumes that the two boxes are within the first 50 percent of the overlapping region of their paths (ie, the penetration, if any, is not extremely deep).<br />For each box, we&#039;ll use planes to cut away the subspaces that are &#039;not interesting&#039; until we&#039;re left with the subspace that contains the origin of the other box. This will yield exactly one Feature for each Box, which are the closest pair of features for this pair of boxes.<br /><br />In order to understand this better we&#039;ll go through the solution for a 2D box, and then build on that to create a 3D solution.<br /><br />I&#039;ll go away and create the 2D art to accompany this, meanwhile I ask you to think about how we might solve it :)<br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2725" target="_blank">Box_VRegions.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-02-08 05:59:27 by Homer</div>
   </div>
   <div class="post" id="post-206824">
    <div class="subject"><a href="#post-206824">Re: Closest Feature of Box</a></div>
    <div class="body">Look at the attached images to understand the following random dribble.<br />Note that it is expressed in &#039;Box Space&#039;.<br /><br />We have a 2D Box which is intersecting some other body.<br />If we were to extend all the edges of the box, we&#039;d get a grid of 3x3 cells, with the box occupying the middle cell, and the other eight representing voronoi regions for the corners and faces of the box... we wish to know which of the nine regions the ORIGIN of the OTHER body (our test point) is located within.. <br /><br />We begin by creating a vector from the origin of the Box to the origin of the other body.<br />We examine the components of this vector to determine which Axis has the greatest magnitude, in this example it is the X axis, and the Direction of X is Positive.<br />We then obtain A = Supporting Face in the +X Direction. I&#039;ll explain this more below.<br />We perform a Point/Plane test using the Plane of A and the &quot;test point&quot;.<br />This carves off all of the VR&#039;s except for a few.. <br /><br />We now repeat this process for the remaining axis (or axes if 3D) of greatest magnitude.<br /><br />Since the example is only 2D, we see that the second round of the algorithm will be performed apon the Y axis.<br />The final image shows that the top face of the box was selected (by finding the support face in the +Y Direction).<br />Our 2D example ends here because we&#039;ve identified the voronoi region containing the test point, its the top right one, which is associated with the top right point of the box... thats our closest feature.<br />But if the point had been below the Plane during this test instead of above it, we would have been forced to perform a third test against the Support face in the Minus Y direction.<br /><br /><br /><br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2727" target="_blank">BlackBox_1.JPG</a></li>
      <li><a href="../../attachments/?id=2729" target="_blank">BlackBox_2.JPG</a></li>
      <li><a href="../../attachments/?id=2731" target="_blank">BlackBox_3.JPG</a></li>
      <li><a href="../../attachments/?id=2733" target="_blank">BlackBox_4.JPG</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-02-08 07:37:10 by Homer</div>
   </div>
   <div class="post" id="post-206850">
    <div class="subject"><a href="#post-206850">Re: Using a Bounding Tree to accelerate narrowphase collision detection</a></div>
    <div class="body">The images in my previous post may have reminded you of the process of constructing a BSP Tree.<br /><br />It is becoming common to generate a Tree which encodes the geometry of an input 3D model, and then using that tree to accelerate our collision detection. Several common trees being used for this include AABB, OBB and Sphere trees. I have decided to work with Sphere trees because spheres are rotationally invariant (as opposed to OBB&#039;s), meaning we eliminate rotational transformations when working with these trees, while requiring only a single test for intersection (as opposed to AABB&#039;s which need to perform 6 signed axial tests). A major advantage of using trees for collision testing is that we&#039;re no longer restricted to convex polytopes - we can use complex (or even illegal) 3D shapes of any kind.<br /><br />Generating a sphere tree from an input &#039;triangle soup&#039; can be done in various ways, which all fall under two categories: &quot;top down&quot;, and &quot;bottom up&quot;... either way, the goal is to construct a Tree whose &#039;leaf&#039; nodes contain just one triangle each. <br /><br />Sphere trees can be generated using any kind of spatial partitioning algorithm, for example we can build an Octree of BoundingBoxes, and convert all the nodes into Spheres when we&#039;re finished.<br /><br />I have decided to use the BSP Tree algorithm as the basis for construction of my Sphere Tree.<br />The goal of BSP construction is to find a Plane which cuts the input set of triangles into two child sets which contain similar numbers of triangles, while &#039;cutting&#039; as few triangles as possible.<br />Most BSP generators will restrict the selection of Plane to the set of Planes represented by the input triangles, and will terminate construction of the tree when the number of triangles in a node is too low, or when the set of triangles forms a CONVEX SET.<br />This is not sufficient for us, we want to continue until each leaf contains a single triangle, and in the case where a suitable cutting plane cannot be found by conventional means, we&#039;ll need another means to generate our child nodes.<br /><br />It is certainly worth noting that our trees are constructed in BODYSPACE... so when we need to perform collisiontesting in WorldSpace, we&#039;ll need to transform spheres from body B into the space of Body A.<br /><br />Our broadphase (coarse) collision testing has already identified pairs of bodies whose boundingspheres are intersecting. So we know that the spheres at the ROOT NODES of those sphere trees are intersecting.<br />In order to perform narrowphase collision testing between bodies A and B, and given that we are working in the BodySpace of body A, our algorithm needs to walk both trees at once, with tree A as our &#039;major&#039; tree, and tree B as our &#039;minor&#039; tree.. we will walk the nodes of B&#039;s tree, transforming their spheres into A&#039;s space, and we will test them for intersection against our current node in A&#039;s tree.<br />As long as we find intersection, we will walk the two trees, eventually finding pairs of leaf nodes whose spheres intersect.<br />These leaf nodes contain a single triangle, so we have detected pairs of triangles which MAY intersect...<br />Now we have to perform a triangle/triangle intersection test, which may generate intersection points.<br />Finally, we emit a Contact at each intersection point.<br />In this way we are able to build a full set of contacts, aka a Contact Manifold, between two arbitrary bodies.<br />Now we can pass the Contact Manifold to our existing collision response function ;)<br /><br />In my next post, I&#039;ll describe an an alternative sub-algorithm for the cases where standard BSP fails to identify a suitable cutting plane, and we&#039;ll lay out the complete algorithm for generating a binary sphere tree from a triangle soup :)<br /><br /></div>
    <div class="meta">Posted on 2009-02-12 21:58:23 by Homer</div>
   </div>
   <div class="post" id="post-206851">
    <div class="subject"><a href="#post-206851">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">BSP&#039;s &#039;cuttingplane selection&#039; subalgorithm can fail under two circumstances.<br />The first is that the set of input triangles is completely convex (faces all point outwards) or completely concave (faces all point inwards)... for regular BSP, these are both terminal cases since they both identify a closed subspace (regardless of whether we mean &#039;all inside&#039;, or &#039;all outside&#039;).<br />The second is that there&#039;s only two faces to choose from.<br /><br />The second case is easy, we just declare each of these triangles as a leafnode in our sphere tree.<br />But the former case requires more work.<br />What we&#039;ll do is generate all the possible planes that we can construct from a combination of three points, and test all of them to determine the optimal cutting plane using our existing bsptree plane evaluating function.<br /><br />Given the example of a convex body such as a 3D box, it is clear that none of the faces have a plane which evenly divides the triangles, but we can imagine a diagonal plane which cuts the triangles in half while splitting ZERO triangles (the plane passes through the box diagonally, not cutting any faces).<br /><br />I&#039;m not particularly interested in optimizing this because it&#039;s a PREPROCESSING STEP, it doesn&#039;t happen at runtime so the time it takes is not critical, the amount of analyzing is more important because it means LESS analyzing is done at runtime - make sense?<br /><br />Now we can begin to lay out the complete algorithm for generating our sphere tree.<br />I&#039;m pretty certain this algorithm is already in use so I won&#039;t give it a name, please tell me what it&#039;s called if you recognize it !!<br /><br /><br /><br /></div>
    <div class="meta">Posted on 2009-02-12 22:39:05 by Homer</div>
   </div>
   <div class="post" id="post-206852">
    <div class="subject"><a href="#post-206852">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Here is the initializing work we must do before generating our tree:<br />-Associate each Triangle with its Plane<br />-Create a Root Node with an empty list of Triangles <br />-Shove all Triangles into the Root Node<br />-Call recursive function to generate tree<br /><br />Here is the recursive algorithm for generating the tree:<br />-From the input set of triangles, find the triangle whose Plane best divides the remaining triangles.<br />-Divide the triangles into two child subsets based on which side of the plane they fall within. If a triangle is coplanar, or is cut by the dividing plane, send it to both output lists.<br />-Place each subset of triangles into a child node.. if the child node contains a single triangle, then it is a Leaf node and we dont need to recurse it... otherwise,<br />-Recurse each child node until they contain a single triangle, or we reach a special case.<br />-Calculate the boundingsphere for the current node as the last step before returning to our caller.<br /><br />The special cases have already been defined, as has the algorithm we will execute in these cases.<br /><br />It is worth mentioning that we don&#039;t need the &#039;complete&#039; BSP implementation because we NEVER SPLIT TRIANGLES - we end up with a tree where we are guaranteed that each Leaf contains a single triangle, although there may be more than one path which leads to that triangle (ie, a triangle may exist in more than one leaf node).<br /><br />We&#039;re now ready to see some actual code for implementing this algorithm!<br /><br /></div>
    <div class="meta">Posted on 2009-02-12 23:04:52 by Homer</div>
   </div>
   <div class="post" id="post-206859">
    <div class="subject"><a href="#post-206859">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Just before we dive into code, it would be good to understand how we can use these Sphere Trees to accelerate our narrowphase collision detection :P<br /><br />Our primary goal is to find pairs of Leaf Nodes (from two input trees) whose spheres are intersecting, and thus identify and test pairs of proximate Triangles for intersection.<br /><br />Our secondary goal is to traverse the two Trees as efficiently as possible, thus performing as few tests as possible.<br /><br />Our broadphase collision detector finds pairs of bodies whose boundingspheres intersect.<br />We can therefore safely assume the following:<br />For any pair of bodies which is handed to the narrowphase test, the Root BoundingSpheres of their Sphere Trees must be intersecting... so we don&#039;t need to test this pair of spheres.<br />We need a recursive function which attempts to walk BOTH TREES AT ONCE for as long as this is possible, thus eliminating as many BRANCH PAIRS as possible, as early as possible.<br /><br />The recursive function looks something like this..<br /><br />Given current nodes of Bodies A and B:<br /><br />If current node of BodyA is NOT A LEAF,<br />&nbsp; If current node of BodyB is NOT A LEAF,<br />&nbsp; &nbsp;  Recurse A.Front, B.Front<br />&nbsp; &nbsp;  Recurse A.Front, B.Back<br />&nbsp; &nbsp;  Recurse A.Back,B.Front<br />&nbsp; &nbsp;  Recurse A.Back,B.Back<br />&nbsp; Else<br />&nbsp; &nbsp;  Recurse A.Front, B<br />&nbsp; &nbsp;  Recurse A.Back, B<br />&nbsp; EndIf<br />ElseIf current node of BodyB is NOT A LEAF,<br />&nbsp; Recurse A,B.Front<br />&nbsp; Recurse A,B.Back<br />Else<br />&nbsp; Test A.Triangle, B.Triangle<br />EndIf<br /><br />It works like this: If current node on both trees are non leaf, walk both trees... if one node is a non leaf, walk that tree... if both nodes are leaves (contain a single triangle), test for intersection and generate contacts for intersection case.<br /><br />The tricky part which I haven&#039;t mentioned is that each of these trees is valid only in the BodySpace of its owner - so we need to choose a common space for the actual tests, and transform the test geometry into that space (I choose to test in the space of Body A).<br /></div>
    <div class="meta">Posted on 2009-02-15 22:45:01 by Homer</div>
   </div>
   <div class="post" id="post-206873">
    <div class="subject"><a href="#post-206873">Beyond BSP - Completing the Top-Down SphereTree Algorithm</a></div>
    <div class="body">There&#039;s just one problem left to tackle.<br /><br />The BSP Tree generating algorithm recursively divides the input &#039;triangle soup&#039; into a binary tree whose leaf nodes contain &#039;convex sets&#039; of triangles.<br />In this context, &#039;convex&#039; means &#039;a set of triangles whose surface normals (planes) all point inwards, or all point outwards, with respect to each other&#039;. There is no plane (in the limited set of planes we can extract from the input triangles) which can be used to divide a convex set... and we want our leaf nodes to contain no more than one triangle each, so when our BSP generator &#039;discovers&#039; a convex set, we need to switch to a new recursive algorithm in order to continue bisecting that convex set.<br /><br />I&#039;ve devised my own algorithm for this, however it&#039;s probably not new.<br />It&#039;s a &#039;top down&#039; algorithm like BSP... at first it might sound like &#039;a recursion within a recursion&#039; but it is really just a natural extension to the existing BSP generator&#039;s recursion. Basically, it works by grouping the triangles according to their proximity to two expanding spheres.<br /><br />The recursive function for handling convex clusters of triangles in the leaf nodes of a BSP-based tree is as follows:<br /><br />First, I find the two triangles whose Centroids are furthest apart, and I move each of them into a new collection, lets call them List_A and List_B.<br />Now I process the remaining triangles with this algorithm:<br /><br />-While the number of input triangles is greater than zero<br />--Find the extents and origin of List_A<br />--Find the triangle whose centroid is closest to List_A<br />--Move this triangle into List_A<br />--If the number of input triangles is still greater than zero<br />----Find the extents and origin of List_B<br />----Find the triangle whose centroid is closest to List_B<br />----Move this triangle into List_B<br />--EndIf<br />-EndWhile<br /><br />Now I move the two Lists into two new Child nodes, and I recurse any Child nodes which contain at least 2 triangles.<br /><br /></div>
    <div class="meta">Posted on 2009-02-19 22:07:26 by Homer</div>
   </div>
   <div class="post" id="post-206884">
    <div class="subject"><a href="#post-206884">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body">Together we&#039;ve reached a milestone of well over 4000 views in three months - a personal record, and proof that this board is alive and well :)<br /><br /><br />Attached is my current version of D3D_CollisionMesh.<br /><br />Derived from my CollisionBody class, it&#039;s an extended version of OA32&#039;s D3D_Mesh object.<br />It implements the algorithms I&#039;ve posted for generating a Sphere Tree from arbitrary input geometry via &#039;Extended BSP Tree Generator Algorithm&#039; (I still haven&#039;t found this algorithm published elsewhere, however I still strongly suspect that this particular hybrid algorithm is not new).<br /><br />Like D3D_Mesh, the class I&#039;ve provided is designed to act as a &#039;reference object&#039; from which many &#039;living instance&#039; can be created... D3D_PhysicalEntity is the class which implements such instances from an existing D3D_CollisionMesh.<br /><br />Now we have baked a nice cake, it&#039;s time for the frosting.<br />In my next post, I&#039;ll provide collision detection code for pairs of D3D_PhysicalEntities, based apon the previously posted algorithm for dual tree-walking. <br /><br />If you have any questions at all, please feel free to ask... either in this thread, or via Private Message.<br /></div>
    <div class="attachments">Attachments:
     <ul>
      <li><a href="../../attachments/?id=2738" target="_blank">D3D_CollisionMesh.inc</a></li>
     </ul>
    </div>
    <div class="meta">Posted on 2009-02-24 05:29:40 by Homer</div>
   </div>
   <div class="post" id="post-206906">
    <div class="subject"><a href="#post-206906">Re: Better, Faster, Stronger Physics 2009</a></div>
    <div class="body"><div class="quote">(...)and proof that this board is alive and well :)</div><br />...And proof that you can be a lecturer or at least a tutor! ^^</div>
    <div class="meta">Posted on 2009-02-25 12:21:50 by ti_mo_n</div>
   </div>
<form class="pagination" action="../" method="get"><a href="../?id=29229&amp;page=1" style="">&laquo;</a><a href="../?id=29229&amp;page=4" style="">&lt;</a><input type="hidden" name="id" value="29229" /><input type="number" name="page" min="1" max="7" step="1" value="5" onchange="this.form.submit();" /><a href="../?id=29229&amp;page=6">&gt;</a><a href="../?id=29229&amp;page=7">&raquo;</a></form>  </div>
 </body>
</html>